diff --git a/src/lib/asn1/ber_dec.cpp b/src/lib/asn1/ber_dec.cpp
index 1b92fc037d7..886923c567a 100644
--- a/src/lib/asn1/ber_dec.cpp
+++ b/src/lib/asn1/ber_dec.cpp
@@ -227,6 +227,14 @@ BER_Decoder& BER_Decoder::discard_remaining() {
    return (*this);
 }
 
+const BER_Object& BER_Decoder::peek_next_object() {
+   if(!m_pushed.is_set()) {
+      m_pushed = get_next_object();
+   }
+
+   return m_pushed;
+}
+
 /*
 * Return the BER encoding of the next object
 */
diff --git a/src/lib/asn1/ber_dec.h b/src/lib/asn1/ber_dec.h
index 2f6cecd46ab..61399bd6632 100644
--- a/src/lib/asn1/ber_dec.h
+++ b/src/lib/asn1/ber_dec.h
@@ -71,6 +71,16 @@ class BOTAN_PUBLIC_API(2, 0) BER_Decoder final {
          return (*this);
       }
 
+      /**
+      * Peek at the next object without removing it from the stream
+      *
+      * If an object has been pushed, then it returns that object.
+      * Otherwise it reads the next object and pushes it. Thus, a you
+      * call peek_next_object followed by push_back without a
+      * subsequent read, it will fail.
+      */
+      const BER_Object& peek_next_object();
+
       /**
       * Push an object back onto the stream. Throws if another
       * object was previously pushed and has not been subsequently
@@ -253,6 +263,11 @@ class BOTAN_PUBLIC_API(2, 0) BER_Decoder final {
                                ASN1_Type type_tag = ASN1_Type::Sequence,
                                ASN1_Class class_tag = ASN1_Class::Universal);
 
+      template <typename T>
+      bool decode_optional_list(std::vector<T>& out,
+                                ASN1_Type type_tag = ASN1_Type::Sequence,
+                                ASN1_Class class_tag = ASN1_Class::Universal);
+
       template <typename T>
       BER_Decoder& decode_and_check(const T& expected, std::string_view error_msg) {
          T actual;
@@ -375,6 +390,19 @@ BER_Decoder& BER_Decoder::decode_list(std::vector<T>& vec, ASN1_Type type_tag, A
    return (*this);
 }
 
+/*
+* Decode an optional list of homogenously typed values
+*/
+template <typename T>
+bool BER_Decoder::decode_optional_list(std::vector<T>& vec, ASN1_Type type_tag, ASN1_Class class_tag) {
+   if(peek_next_object().is_a(type_tag, class_tag)) {
+      decode_list(vec, type_tag, class_tag);
+      return true;
+   }
+
+   return false;
+}
+
 }  // namespace Botan
 
 #endif
diff --git a/src/lib/utils/stl_util.h b/src/lib/utils/stl_util.h
index cb721765830..93cc996d8c9 100644
--- a/src/lib/utils/stl_util.h
+++ b/src/lib/utils/stl_util.h
@@ -374,6 +374,20 @@ class scoped_cleanup {
       std::optional<FunT> m_cleanup;
 };
 
+/**
+* Define BOTAN_ASSERT_IS_SOME
+*/
+template <typename T>
+T assert_is_some(std::optional<T> v, const char* expr, const char* func, const char* file, int line) {
+   if(v) {
+      return *v;
+   } else {
+      Botan::assertion_failure(expr, "optional had value", func, file, line);
+   }
+}
+
+#define BOTAN_ASSERT_IS_SOME(v) assert_is_some(v, #v, __func__, __FILE__, __LINE__)
+
 }  // namespace Botan
 
 #endif
diff --git a/src/lib/x509/alt_name.cpp b/src/lib/x509/alt_name.cpp
index 66f60a03c17..e17153e0a16 100644
--- a/src/lib/x509/alt_name.cpp
+++ b/src/lib/x509/alt_name.cpp
@@ -8,8 +8,10 @@
 
 #include <botan/ber_dec.h>
 #include <botan/der_enc.h>
+#include <botan/internal/int_utils.h>
 #include <botan/internal/loadstor.h>
 #include <botan/internal/parsing.h>
+#include <botan/internal/stl_util.h>
 
 namespace Botan {
 
@@ -27,7 +29,7 @@ void AlternativeName::add_email(std::string_view addr) {
 
 void AlternativeName::add_dns(std::string_view dns) {
    if(!dns.empty()) {
-      m_dns.insert(std::string(dns));
+      m_dns.insert(tolower_string(dns));
    }
 }
 
@@ -39,32 +41,19 @@ void AlternativeName::add_dn(const X509_DN& dn) {
    m_dn_names.insert(dn);
 }
 
-void AlternativeName::add_ip_address(std::string_view ip) {
-   if(!ip.empty()) {
-      m_ip_addr.insert(std::string(ip));
-   }
+void AlternativeName::add_ipv4_address(uint32_t ip) {
+   m_ipv4_addr.insert(ip);
+}
+
+size_t AlternativeName::count() const {
+   const auto sum = checked_add(
+      m_dns.size(), m_uri.size(), m_email.size(), m_ipv4_addr.size(), m_dn_names.size(), m_othernames.size());
+
+   return BOTAN_ASSERT_IS_SOME(sum);
 }
 
 bool AlternativeName::has_items() const {
-   if(!this->dns().empty()) {
-      return true;
-   }
-   if(!this->uris().empty()) {
-      return true;
-   }
-   if(!this->email().empty()) {
-      return true;
-   }
-   if(!this->ip_address().empty()) {
-      return true;
-   }
-   if(!this->directory_names().empty()) {
-      return true;
-   }
-   if(!this->other_names().empty()) {
-      return true;
-   }
-   return false;
+   return this->count() > 0;
 }
 
 void AlternativeName::encode_into(DER_Encoder& der) const {
@@ -111,8 +100,8 @@ void AlternativeName::encode_into(DER_Encoder& der) const {
       der.add_object(ASN1_Type(6), ASN1_Class::ContextSpecific, str.value());
    }
 
-   for(const auto& ip : m_ip_addr) {
-      auto ip_buf = store_be(string_to_ipv4(ip));
+   for(uint32_t ip : m_ipv4_addr) {
+      auto ip_buf = store_be(ip);
       der.add_object(ASN1_Type(7), ASN1_Class::ContextSpecific, ip_buf.data(), 4);
    }
 
@@ -161,7 +150,7 @@ void AlternativeName::decode_from(BER_Decoder& source) {
       } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {
          if(obj.length() == 4) {
             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);
-            this->add_ip_address(ipv4_to_string(ip));
+            this->add_ipv4_address(ip);
          }
       }
    }
diff --git a/src/lib/x509/asn1_alt_name.cpp b/src/lib/x509/asn1_alt_name.cpp
index aa24b7d44bf..03609ca5518 100644
--- a/src/lib/x509/asn1_alt_name.cpp
+++ b/src/lib/x509/asn1_alt_name.cpp
@@ -9,6 +9,7 @@
 #include <botan/pkix_types.h>
 
 #include <botan/internal/fmt.h>
+#include <botan/internal/parsing.h>
 #include <sstream>
 
 namespace Botan {
@@ -30,7 +31,7 @@ AlternativeName::AlternativeName(std::string_view email_addr,
       add_uri(uri);
    }
    if(!ip.empty()) {
-      add_ip_address(ip);
+      add_ipv4_address(string_to_ipv4(ip));
    }
 }
 
@@ -54,7 +55,7 @@ void AlternativeName::add_attribute(std::string_view type, std::string_view valu
       ss >> dn;
       this->add_dn(dn);
    } else if(type == "IP") {
-      this->add_ip_address(value);
+      this->add_ipv4_address(string_to_ipv4(value));
    } else {
       throw Not_Implemented(fmt("Unknown AlternativeName name type {}", type));
    }
@@ -88,8 +89,8 @@ std::multimap<std::string, std::string> AlternativeName::contents() const {
       names.emplace("URI", nm);
    }
 
-   for(const auto& nm : this->ip_address()) {
-      names.emplace("IP", nm);
+   for(uint32_t ipv4 : this->ipv4_address()) {
+      names.emplace("IP", ipv4_to_string(ipv4));
    }
 
    for(const auto& nm : this->directory_names()) {
@@ -145,7 +146,11 @@ std::vector<std::string> AlternativeName::get_attribute(std::string_view attr) c
 
       return ret;
    } else if(attr == "IP") {
-      return set_to_vector(this->ip_address());
+      std::vector<std::string> ip_str;
+      for(uint32_t ipv4 : this->ipv4_address()) {
+         ip_str.push_back(ipv4_to_string(ipv4));
+      }
+      return ip_str;
    } else {
       return {};
    }
diff --git a/src/lib/x509/name_constraint.cpp b/src/lib/x509/name_constraint.cpp
index bccb14e6cdc..a35c6448eb7 100644
--- a/src/lib/x509/name_constraint.cpp
+++ b/src/lib/x509/name_constraint.cpp
@@ -1,6 +1,7 @@
 /*
 * X.509 Name Constraint
 * (C) 2015 Kai Michaelis
+*     2024 Jack Lloyd
 *
 * Botan is released under the Simplified BSD License (see license.txt)
 */
@@ -9,6 +10,7 @@
 
 #include <botan/ber_dec.h>
 #include <botan/x509cert.h>
+#include <botan/internal/fmt.h>
 #include <botan/internal/loadstor.h>
 #include <botan/internal/parsing.h>
 #include <functional>
@@ -18,14 +20,41 @@ namespace Botan {
 
 class DER_Encoder;
 
-GeneralName::GeneralName(const std::string& str) : GeneralName() {
-   size_t p = str.find(':');
+std::string GeneralName::type() const {
+   switch(m_type) {
+      case NameType::Unknown:
+         throw Encoding_Error("Could not convert unknown NameType to string");
+      case NameType::RFC822:
+         return "RFC822";
+      case NameType::DNS:
+         return "DNS";
+      case NameType::URI:
+         return "URI";
+      case NameType::DN:
+         return "DN";
+      case NameType::IPv4:
+         return "IP";
+   }
+
+   BOTAN_ASSERT_UNREACHABLE();
+}
 
-   if(p != std::string::npos) {
-      m_type = str.substr(0, p);
-      m_name = str.substr(p + 1, std::string::npos);
+std::string GeneralName::name() const {
+   const size_t index = m_names.index();
+
+   if(index == RFC822_IDX) {
+      return std::get<RFC822_IDX>(m_names);
+   } else if(index == DNS_IDX) {
+      return std::get<DNS_IDX>(m_names);
+   } else if(index == URI_IDX) {
+      return std::get<URI_IDX>(m_names);
+   } else if(index == DN_IDX) {
+      return std::get<DN_IDX>(m_names).to_string();
+   } else if(index == IPV4_IDX) {
+      auto [net, mask] = std::get<IPV4_IDX>(m_names);
+      return fmt("{}/{}", ipv4_to_string(net), ipv4_to_string(mask));
    } else {
-      throw Invalid_Argument("Failed to decode Name Constraint");
+      BOTAN_ASSERT_UNREACHABLE();
    }
 }
 
@@ -37,121 +66,154 @@ void GeneralName::decode_from(BER_Decoder& ber) {
    BER_Object obj = ber.get_next_object();
 
    if(obj.is_a(1, ASN1_Class::ContextSpecific)) {
-      m_type = "RFC822";
-      m_name = ASN1::to_string(obj);
+      m_type = NameType::RFC822;
+      m_names.emplace<RFC822_IDX>(ASN1::to_string(obj));
    } else if(obj.is_a(2, ASN1_Class::ContextSpecific)) {
-      m_type = "DNS";
-      m_name = ASN1::to_string(obj);
+      m_type = NameType::DNS;
+      // Store it in case insensitive form so we don't have to do it
+      // again while matching
+      m_names.emplace<DNS_IDX>(tolower_string(ASN1::to_string(obj)));
    } else if(obj.is_a(6, ASN1_Class::ContextSpecific)) {
-      m_type = "URI";
-      m_name = ASN1::to_string(obj);
+      m_type = NameType::URI;
+      m_names.emplace<URI_IDX>(ASN1::to_string(obj));
    } else if(obj.is_a(4, ASN1_Class::ContextSpecific | ASN1_Class::Constructed)) {
-      m_type = "DN";
       X509_DN dn;
       BER_Decoder dec(obj);
-      std::stringstream ss;
-
       dn.decode_from(dec);
-      ss << dn;
-
-      m_name = ss.str();
+      m_type = NameType::DN;
+      m_names.emplace<DN_IDX>(dn);
    } else if(obj.is_a(7, ASN1_Class::ContextSpecific)) {
       if(obj.length() == 8) {
-         m_type = "IP";
-         m_name =
-            ipv4_to_string(load_be<uint32_t>(obj.bits(), 0)) + "/" + ipv4_to_string(load_be<uint32_t>(obj.bits(), 1));
+         const uint32_t net = load_be<uint32_t>(obj.bits(), 0);
+         const uint32_t mask = load_be<uint32_t>(obj.bits(), 1);
+
+         m_type = NameType::IPv4;
+         m_names.emplace<IPV4_IDX>(std::make_pair(net, mask));
       } else if(obj.length() == 32) {
-         throw Decoding_Error("Unsupported IPv6 name constraint");
+         // IPv6 name constraints are not implemented
+         m_type = NameType::Unknown;
       } else {
          throw Decoding_Error("Invalid IP name constraint size " + std::to_string(obj.length()));
       }
    } else {
-      throw Decoding_Error("Found unknown GeneralName type");
+      m_type = NameType::Unknown;
+   }
+}
+
+bool GeneralName::is_unknown_type() const {
+   if(m_type == NameType::Unknown) {
+      return true;
    }
+
+   // We don't currently implement matching for URIs or emails, so we
+   // need to reject any cert with a critical email or URI name
+   // constraint.
+   return (m_type == NameType::URI || m_type == NameType::RFC822);
 }
 
 GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) const {
-   std::vector<std::string> nam;
-   std::function<bool(const GeneralName*, const std::string&)> match_fn;
+   class MatchScore final {
+      public:
+         MatchScore() : m_any(false), m_some(false), m_all(true) {}
+
+         void add(bool m) {
+            m_any = true;
+            m_some |= m;
+            m_all &= m;
+         }
+
+         MatchResult result() const {
+            if(!m_any) {
+               return MatchResult::NotFound;
+            } else if(m_all) {
+               return MatchResult::All;
+            } else if(m_some) {
+               return MatchResult::Some;
+            } else {
+               return MatchResult::None;
+            }
+         }
+
+      private:
+         bool m_any;
+         bool m_some;
+         bool m_all;
+   };
 
    const X509_DN& dn = cert.subject_dn();
    const AlternativeName& alt_name = cert.subject_alt_name();
 
-   if(type() == "DNS") {
-      match_fn = std::mem_fn(&GeneralName::matches_dns);
+   MatchScore score;
+
+   if(m_type == NameType::DNS) {
+      const auto& constraint = std::get<1>(m_names);
 
-      nam = alt_name.get_attribute("DNS");
+      const auto& alt_names = alt_name.dns();
 
-      if(nam.empty()) {
-         nam = dn.get_attribute("CN");
+      for(const std::string& dns : alt_names) {
+         score.add(matches_dns(dns, constraint));
       }
-   } else if(type() == "DN") {
-      match_fn = std::mem_fn(&GeneralName::matches_dn);
 
-      nam.push_back(dn.to_string());
+      if(alt_names.empty()) {
+         // Check CN instead...
+         for(const std::string& cn : dn.get_attribute("CN")) {
+            score.add(matches_dns(cn, constraint));
+         }
+      }
+   } else if(m_type == NameType::DN) {
+      const X509_DN& constraint = std::get<3>(m_names);
+      score.add(matches_dn(dn, constraint));
+
+      for(const auto& alt_dn : alt_name.directory_names()) {
+         score.add(matches_dn(alt_dn, constraint));
+      }
+   } else if(m_type == NameType::IPv4) {
+      auto [net, mask] = std::get<4>(m_names);
 
-      const auto alt_dn = alt_name.dn();
-      if(!alt_dn.empty()) {
-         nam.push_back(alt_dn.to_string());
+      for(uint32_t ipv4 : alt_name.ipv4_address()) {
+         bool match = (ipv4 & mask) == net;
+         score.add(match);
       }
-   } else if(type() == "IP") {
-      match_fn = std::mem_fn(&GeneralName::matches_ip);
-      nam = alt_name.get_attribute("IP");
    } else {
+      // URI and email name constraint matching not implemented
       return MatchResult::UnknownType;
    }
 
-   if(nam.empty()) {
-      return MatchResult::NotFound;
-   }
-
-   bool some = false;
-   bool all = true;
-
-   for(const std::string& n : nam) {
-      bool m = match_fn(this, n);
-
-      some |= m;
-      all &= m;
-   }
-
-   if(all) {
-      return MatchResult::All;
-   } else if(some) {
-      return MatchResult::Some;
-   } else {
-      return MatchResult::None;
-   }
+   return score.result();
 }
 
-bool GeneralName::matches_dns(const std::string& nam) const {
-   if(nam.size() == name().size()) {
-      return tolower_string(nam) == tolower_string(name());
-   } else if(name().size() > nam.size()) {
+//static
+bool GeneralName::matches_dns(const std::string& name, const std::string& constraint) {
+   // both constraint and name are assumed already tolower
+   if(name.size() == constraint.size()) {
+      return name == constraint;
+   } else if(constraint.size() > name.size()) {
       // The constraint is longer than the issued name: not possibly a match
       return false;
-   } else  // name.size() < nam.size()
-   {
-      // constr is suffix of nam
-      const std::string constr = name().front() == '.' ? name() : "." + name();
-      const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());
-      return tolower_string(constr) == tolower_string(substr);
-   }
-}
+   } else {
+      BOTAN_ASSERT_NOMSG(name.size() > constraint.size());
+
+      if(constraint.empty()) {
+         return true;
+      }
 
-bool GeneralName::matches_dn(const std::string& nam) const {
-   std::stringstream ss(nam);
-   std::stringstream tt(name());
-   X509_DN nam_dn, my_dn;
+      std::string_view substr = std::string_view(name).substr(name.size() - constraint.size(), constraint.size());
 
-   ss >> nam_dn;
-   tt >> my_dn;
+      if(constraint.front() == '.') {
+         return substr == constraint;
+      } else {
+         return substr[0] == '.' && substr.substr(1) == constraint;
+      }
+   }
+}
 
-   auto attr = nam_dn.get_attributes();
+//static
+bool GeneralName::matches_dn(const X509_DN& name, const X509_DN& constraint) {
+   const auto attr = name.get_attributes();
    bool ret = true;
    size_t trys = 0;
 
-   for(const auto& c : my_dn.dn_info()) {
+   for(const auto& c : constraint.dn_info()) {
       auto i = attr.equal_range(c.first);
 
       if(i.first != i.second) {
@@ -163,59 +225,87 @@ bool GeneralName::matches_dn(const std::string& nam) const {
    return trys > 0 && ret;
 }
 
-bool GeneralName::matches_ip(const std::string& nam) const {
-   uint32_t ip = string_to_ipv4(nam);
-   std::vector<std::string> p = split_on(name(), '/');
-
-   if(p.size() != 2) {
-      throw Decoding_Error("failed to parse IPv4 address");
-   }
-
-   uint32_t net = string_to_ipv4(p.at(0));
-   uint32_t mask = string_to_ipv4(p.at(1));
-
-   return (ip & mask) == net;
-}
-
 std::ostream& operator<<(std::ostream& os, const GeneralName& gn) {
    os << gn.type() << ":" << gn.name();
    return os;
 }
 
-GeneralSubtree::GeneralSubtree(const std::string& str) : GeneralSubtree() {
-   size_t p0, p1;
-   const auto min = std::stoull(str, &p0, 10);
-   const auto max = std::stoull(str.substr(p0 + 1), &p1, 10);
-   GeneralName gn(str.substr(p0 + p1 + 2));
-
-   if(p0 > 0 && p1 > 0) {
-      m_minimum = static_cast<size_t>(min);
-      m_maximum = static_cast<size_t>(max);
-      m_base = gn;
-   } else {
-      throw Invalid_Argument("Failed to decode Name Constraint");
-   }
-}
-
 void GeneralSubtree::encode_into(DER_Encoder& /*to*/) const {
-   throw Not_Implemented("General Subtree encoding");
+   throw Not_Implemented("GeneralSubtree encoding");
 }
 
 void GeneralSubtree::decode_from(BER_Decoder& ber) {
+   size_t minimum;
+
    ber.start_sequence()
       .decode(m_base)
-      .decode_optional(m_minimum, ASN1_Type(0), ASN1_Class::ContextSpecific, size_t(0))
+      .decode_optional(minimum, ASN1_Type(0), ASN1_Class::ContextSpecific, size_t(0))
       .end_cons();
 
-   if(m_minimum != 0) {
+   if(minimum != 0) {
       throw Decoding_Error("GeneralSubtree minimum must be 0");
    }
-
-   m_maximum = std::numeric_limits<std::size_t>::max();
 }
 
 std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs) {
-   os << gs.minimum() << "," << gs.maximum() << "," << gs.base();
+   os << gs.base();
    return os;
 }
+
+NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,
+                                 std::vector<GeneralSubtree>&& excluded_subtrees) :
+      m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {
+   auto contains_unknown = [](const std::vector<GeneralSubtree>& tree) -> bool {
+      for(const auto& c : tree) {
+         if(c.base().is_unknown_type()) {
+            return true;
+         }
+      }
+      return false;
+   };
+
+   m_permitted_contains_unknown = contains_unknown(m_permitted_subtrees);
+   m_excluded_contains_unknown = contains_unknown(m_excluded_subtrees);
+}
+
+bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {
+   if(reject_unknown && m_permitted_contains_unknown) {
+      return false;
+   }
+
+   if(permitted().empty()) {
+      return true;
+   }
+
+   for(const auto& c : m_permitted_subtrees) {
+      const auto m = c.base().matches(cert);
+
+      if(m == GeneralName::MatchResult::All) {
+         return true;
+      }
+   }
+
+   return false;
+}
+
+bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {
+   if(reject_unknown && m_excluded_contains_unknown) {
+      return true;
+   }
+
+   if(excluded().empty()) {
+      return false;
+   }
+
+   for(const auto& c : m_excluded_subtrees) {
+      const auto m = c.base().matches(cert);
+
+      if(m == GeneralName::MatchResult::All || m == GeneralName::MatchResult::Some) {
+         return true;
+      }
+   }
+
+   return false;
+}
+
 }  // namespace Botan
diff --git a/src/lib/x509/pkix_types.h b/src/lib/x509/pkix_types.h
index c1407f1fc98..6cb0bce7ed5 100644
--- a/src/lib/x509/pkix_types.h
+++ b/src/lib/x509/pkix_types.h
@@ -18,6 +18,7 @@
 #include <set>
 #include <string>
 #include <string_view>
+#include <variant>
 #include <vector>
 
 namespace Botan {
@@ -137,9 +138,7 @@ class BOTAN_PUBLIC_API(2, 0) AlternativeName final : public ASN1_Object {
       void add_dn(const X509_DN& dn);
 
       /// Add an IP address to this alternative name
-      ///
-      /// Note: currently only IPv4 is accepted
-      void add_ip_address(std::string_view ip_str);
+      void add_ipv4_address(uint32_t ipv4);
 
       /// Return the set of URIs included in this alternative name
       const std::set<std::string>& uris() const { return m_uri; }
@@ -151,7 +150,7 @@ class BOTAN_PUBLIC_API(2, 0) AlternativeName final : public ASN1_Object {
       const std::set<std::string>& dns() const { return m_dns; }
 
       /// Return the set of IPv4 addresses included in this alternative name
-      const std::set<std::string>& ip_address() const { return m_ip_addr; }
+      const std::set<uint32_t>& ipv4_address() const { return m_ipv4_addr; }
 
       /// Return the set of "other names" included in this alternative name
       const std::set<std::pair<OID, ASN1_String>>& other_names() const { return m_othernames; }
@@ -159,7 +158,13 @@ class BOTAN_PUBLIC_API(2, 0) AlternativeName final : public ASN1_Object {
       /// Return the set of directory names included in this alternative name
       const std::set<X509_DN>& directory_names() const { return m_dn_names; }
 
-      // Return true if this has any names set
+      /// Return the total number of names in this AlternativeName
+      ///
+      /// This only counts names which were parsed, ignoring names which
+      /// were of some unknown type
+      size_t count() const;
+
+      /// Return true if this has any names set
       bool has_items() const;
 
       // Old, now deprecated interface follows:
@@ -188,7 +193,7 @@ class BOTAN_PUBLIC_API(2, 0) AlternativeName final : public ASN1_Object {
 
       BOTAN_DEPRECATED("Use AlternativeName::directory_names") X509_DN dn() const;
 
-      BOTAN_DEPRECATED("Use plain constructor plus add_{uri,dns,email,ip}")
+      BOTAN_DEPRECATED("Use plain constructor plus add_{uri,dns,email,ipv4_address}")
       AlternativeName(std::string_view email_addr,
                       std::string_view uri = "",
                       std::string_view dns = "",
@@ -198,7 +203,7 @@ class BOTAN_PUBLIC_API(2, 0) AlternativeName final : public ASN1_Object {
       std::set<std::string> m_dns;
       std::set<std::string> m_uri;
       std::set<std::string> m_email;
-      std::set<std::string> m_ip_addr;
+      std::set<uint32_t> m_ipv4_addr;
       std::set<X509_DN> m_dn_names;
       std::set<std::pair<OID, ASN1_String>> m_othernames;
 };
@@ -245,17 +250,9 @@ class BOTAN_PUBLIC_API(2, 0) GeneralName final : public ASN1_Object {
          UnknownType,
       };
 
-      /**
-      * Creates an empty GeneralName.
-      */
       GeneralName() = default;
 
-      /**
-      * Creates a new GeneralName for its string format.
-      * @param str type and name, colon-separated, e.g., "DNS:google.com"
-      */
-      GeneralName(const std::string& str);
-
+      // Encoding is not implemented
       void encode_into(DER_Encoder&) const override;
 
       void decode_from(BER_Decoder&) override;
@@ -263,12 +260,20 @@ class BOTAN_PUBLIC_API(2, 0) GeneralName final : public ASN1_Object {
       /**
       * @return Type of the name. Can be DN, DNS, IP, RFC822 or URI.
       */
-      const std::string& type() const { return m_type; }
+      std::string type() const;
 
       /**
       * @return The name as string. Format depends on type.
       */
-      const std::string& name() const { return m_name; }
+      std::string name() const;
+
+      /**
+      * @return true if this name is a type we don't understand
+      *
+      * Note this returns true also for the case of URIs and email, which we can
+      * parse but do not currently implement matching for.
+      */
+      bool is_unknown_type() const;
 
       /**
       * Checks whether a given certificate (partially) matches this name.
@@ -278,12 +283,27 @@ class BOTAN_PUBLIC_API(2, 0) GeneralName final : public ASN1_Object {
       MatchResult matches(const X509_Certificate& cert) const;
 
    private:
-      std::string m_type;
-      std::string m_name;
+      enum class NameType : uint8_t {
+         Unknown = 0,
+         RFC822 = 1,
+         DNS = 2,
+         URI = 3,
+         DN = 4,
+         IPv4 = 5,
+      };
+
+      static constexpr size_t RFC822_IDX = 0;
+      static constexpr size_t DNS_IDX = 1;
+      static constexpr size_t URI_IDX = 2;
+      static constexpr size_t DN_IDX = 3;
+      static constexpr size_t IPV4_IDX = 4;
+
+      NameType m_type;
+      std::variant<std::string, std::string, std::string, X509_DN, std::pair<uint32_t, uint32_t>> m_names;
 
-      bool matches_dns(const std::string&) const;
-      bool matches_dn(const std::string&) const;
-      bool matches_ip(const std::string&) const;
+      static bool matches_dns(const std::string& name, const std::string& constraint);
+
+      static bool matches_dn(const X509_DN& name, const X509_DN& constraint);
 };
 
 std::ostream& operator<<(std::ostream& os, const GeneralName& gn);
@@ -293,28 +313,14 @@ std::ostream& operator<<(std::ostream& os, const GeneralName& gn);
 *
 * The Name Constraint extension adds a minimum and maximum path
 * length to a GeneralName to form a constraint. The length limits
-* are currently unused.
+* are not used in PKIX.
 */
 class BOTAN_PUBLIC_API(2, 0) GeneralSubtree final : public ASN1_Object {
    public:
       /**
       * Creates an empty name constraint.
       */
-      GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max()) {}
-
-      /***
-      * Creates a new name constraint.
-      * @param base name
-      * @param min minimum path length
-      * @param max maximum path length
-      */
-      GeneralSubtree(const GeneralName& base, size_t min, size_t max) : m_base(base), m_minimum(min), m_maximum(max) {}
-
-      /**
-      * Creates a new name constraint for its string format.
-      * @param str name constraint
-      */
-      GeneralSubtree(const std::string& str);
+      GeneralSubtree() : m_base() {}
 
       void encode_into(DER_Encoder&) const override;
 
@@ -325,23 +331,11 @@ class BOTAN_PUBLIC_API(2, 0) GeneralSubtree final : public ASN1_Object {
       */
       const GeneralName& base() const { return m_base; }
 
-      /**
-      * @return minimum path length
-      */
-      size_t minimum() const { return m_minimum; }
-
-      /**
-      * @return maximum path length
-      */
-      size_t maximum() const { return m_maximum; }
-
    private:
       GeneralName m_base;
-      size_t m_minimum;
-      size_t m_maximum;
 };
 
-std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs);
+BOTAN_DEPRECATED("Deprecated no replacement") std::ostream& operator<<(std::ostream& os, const GeneralSubtree& gs);
 
 /**
 * @brief Name Constraints
@@ -361,8 +355,7 @@ class BOTAN_PUBLIC_API(2, 0) NameConstraints final {
       * @param excluded_subtrees names for which the certificate is not permitted
       */
       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,
-                      std::vector<GeneralSubtree>&& excluded_subtrees) :
-            m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees) {}
+                      std::vector<GeneralSubtree>&& excluded_subtrees);
 
       /**
       * @return permitted names
@@ -374,9 +367,17 @@ class BOTAN_PUBLIC_API(2, 0) NameConstraints final {
       */
       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }
 
+      // Return true if this certificate is known to be permitted
+      bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;
+
+      // Return true if this certificate is known to be excluded
+      bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;
+
    private:
       std::vector<GeneralSubtree> m_permitted_subtrees;
       std::vector<GeneralSubtree> m_excluded_subtrees;
+      bool m_permitted_contains_unknown;
+      bool m_excluded_contains_unknown;
 };
 
 /**
diff --git a/src/lib/x509/x509_ext.cpp b/src/lib/x509/x509_ext.cpp
index 3ba900e5112..59f830dda81 100644
--- a/src/lib/x509/x509_ext.cpp
+++ b/src/lib/x509/x509_ext.cpp
@@ -477,35 +477,30 @@ std::vector<uint8_t> Name_Constraints::encode_inner() const {
 * Decode the extension
 */
 void Name_Constraints::decode_inner(const std::vector<uint8_t>& in) {
-   std::vector<GeneralSubtree> permit, exclude;
    BER_Decoder ber(in);
-   BER_Decoder ext = ber.start_sequence();
-   BER_Object per = ext.get_next_object();
-
-   ext.push_back(per);
-   if(per.is_a(0, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {
-      ext.decode_list(permit, ASN1_Type(0), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);
-      if(permit.empty()) {
-         throw Encoding_Error("Empty Name Contraint list");
+   BER_Decoder inner = ber.start_sequence();
+
+   std::vector<GeneralSubtree> permitted;
+   if(inner.decode_optional_list(permitted, ASN1_Type(0), ASN1_Class::ExplicitContextSpecific)) {
+      if(permitted.empty()) {
+         throw Decoding_Error("Empty NameConstraint permitted list");
       }
    }
 
-   BER_Object exc = ext.get_next_object();
-   ext.push_back(exc);
-   if(per.is_a(1, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {
-      ext.decode_list(exclude, ASN1_Type(1), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);
-      if(exclude.empty()) {
-         throw Encoding_Error("Empty Name Contraint list");
+   std::vector<GeneralSubtree> excluded;
+   if(inner.decode_optional_list(excluded, ASN1_Type(1), ASN1_Class::ExplicitContextSpecific)) {
+      if(excluded.empty()) {
+         throw Decoding_Error("Empty NameConstraint excluded list");
       }
    }
 
-   ext.end_cons();
+   inner.end_cons();
 
-   if(permit.empty() && exclude.empty()) {
-      throw Encoding_Error("Empty Name Contraint extension");
+   if(permitted.empty() && excluded.empty()) {
+      throw Decoding_Error("Empty NameConstraint extension");
    }
 
-   m_name_constraints = NameConstraints(std::move(permit), std::move(exclude));
+   m_name_constraints = NameConstraints(std::move(permitted), std::move(excluded));
 }
 
 void Name_Constraints::validate(const X509_Certificate& subject,
@@ -522,40 +517,16 @@ void Name_Constraints::validate(const X509_Certificate& subject,
 
       // Check that all subordinate certs pass the name constraint
       for(size_t j = 0; j < pos; ++j) {
-         bool permitted = m_name_constraints.permitted().empty();
-         bool failed = false;
-
-         for(const auto& c : m_name_constraints.permitted()) {
-            switch(c.base().matches(cert_path.at(j))) {
-               case GeneralName::MatchResult::NotFound:
-               case GeneralName::MatchResult::All:
-                  permitted = true;
-                  break;
-               case GeneralName::MatchResult::UnknownType:
-                  failed = issuer_name_constraint_critical;
-                  permitted = true;
-                  break;
-               default:
-                  break;
-            }
-         }
+         const auto& cert = cert_path.at(j);
 
-         for(const auto& c : m_name_constraints.excluded()) {
-            switch(c.base().matches(cert_path.at(j))) {
-               case GeneralName::MatchResult::All:
-               case GeneralName::MatchResult::Some:
-                  failed = true;
-                  break;
-               case GeneralName::MatchResult::UnknownType:
-                  failed = issuer_name_constraint_critical;
-                  break;
-               default:
-                  break;
-            }
+         if(!m_name_constraints.is_permitted(cert, issuer_name_constraint_critical)) {
+            cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);
+            continue;
          }
 
-         if(failed || !permitted) {
+         if(m_name_constraints.is_excluded(cert, issuer_name_constraint_critical)) {
             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);
+            continue;
          }
       }
    }
diff --git a/src/lib/x509/x509cert.cpp b/src/lib/x509/x509cert.cpp
index c2de98ece0d..c2f1235ead0 100644
--- a/src/lib/x509/x509cert.cpp
+++ b/src/lib/x509/x509cert.cpp
@@ -524,7 +524,11 @@ std::vector<std::string> get_cert_user_info(std::string_view req, const X509_DN&
    } else if(req == "URI") {
       return set_to_vector(alt_name.uris());
    } else if(req == "IP") {
-      return set_to_vector(alt_name.ip_address());
+      std::vector<std::string> ip_str;
+      for(uint32_t ipv4 : alt_name.ipv4_address()) {
+         ip_str.push_back(ipv4_to_string(ipv4));
+      }
+      return ip_str;
    } else {
       return {};
    }
diff --git a/src/lib/x509/x509self.cpp b/src/lib/x509/x509self.cpp
index 2a84001ff26..70841f5f855 100644
--- a/src/lib/x509/x509self.cpp
+++ b/src/lib/x509/x509self.cpp
@@ -13,6 +13,7 @@
 #include <botan/x509_ca.h>
 #include <botan/x509_ext.h>
 #include <botan/x509_key.h>
+#include <botan/internal/parsing.h>
 
 namespace Botan {
 
@@ -56,7 +57,9 @@ auto create_alt_name_ext(const X509_Cert_Options& opts, Extensions& extensions)
    }
    subject_alt.add_uri(opts.uri);
    subject_alt.add_email(opts.email);
-   subject_alt.add_ip_address(opts.ip);
+   if(!opts.ip.empty()) {
+      subject_alt.add_ipv4_address(string_to_ipv4(opts.ip));
+   }
 
    if(!opts.xmpp.empty()) {
       subject_alt.add_other_name(OID::from_string("PKIX.XMPPAddr"), ASN1_String(opts.xmpp, ASN1_Type::Utf8String));
