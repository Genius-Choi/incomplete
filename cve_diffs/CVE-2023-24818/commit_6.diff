diff --git a/sys/net/link_layer/ieee802154/ieee802154.c b/sys/net/link_layer/ieee802154/ieee802154.c
index 7b7227270fd1..9d51bc815843 100644
--- a/sys/net/link_layer/ieee802154/ieee802154.c
+++ b/sys/net/link_layer/ieee802154/ieee802154.c
@@ -115,27 +115,39 @@ size_t ieee802154_set_frame_hdr(uint8_t *buf, const uint8_t *src, size_t src_len
 size_t ieee802154_get_frame_hdr_len(const uint8_t *mhr)
 {
     /* TODO: include security header implications */
-    uint8_t tmp;
+    uint8_t tmp, has_dst = 0;
     size_t len = 3; /* 2 byte FCF, 1 byte sequence number */
 
-    /* figure out address sizes */
-    tmp = (mhr[1] & IEEE802154_FCF_DST_ADDR_MASK);
-    if (tmp == IEEE802154_FCF_DST_ADDR_SHORT) {
-        len += 4;   /* 2 byte dst PAN + 2 byte dst short address */
-    }
-    else if (tmp == IEEE802154_FCF_DST_ADDR_LONG) {
-        len += 10;  /* 2 byte dst PAN + 2 byte dst long address */
-    }
-    else if (tmp != IEEE802154_FCF_DST_ADDR_VOID) {
-        return 0;
-    }
-    else if (mhr[0] & IEEE802154_FCF_PAN_COMP) {
-        /* PAN compression, but no destination address => illegal state */
+    tmp = (mhr[0] & IEEE802154_FCF_TYPE_MASK);
+    if (tmp == IEEE802154_FCF_TYPE_ACK) {
+        /* ACK contains no other fields */
+        return len;
+    } else if (tmp != IEEE802154_FCF_TYPE_BEACON) {
+        /* Beacon contains no dst address */
+        tmp = (mhr[1] & IEEE802154_FCF_DST_ADDR_MASK);
+        if (tmp == IEEE802154_FCF_DST_ADDR_SHORT) {
+            len += 4;   /* 2 byte dst PAN + 2 byte dst short address */
+            has_dst = 1;
+        }
+        else if (tmp == IEEE802154_FCF_DST_ADDR_LONG) {
+            len += 10;  /* 2 byte dst PAN + 8 byte dst long address */
+            has_dst = 1;
+        }
+        else if (tmp != IEEE802154_FCF_DST_ADDR_VOID) {
+            return 0;
+        }
+        else if (mhr[0] & IEEE802154_FCF_PAN_COMP) {
+            /* PAN compression, but no destination address => illegal state */
+            return 0;
+        }
+    } else if (mhr[0] & IEEE802154_FCF_PAN_COMP) {
+        /* Beacon can't use PAN compression */
         return 0;
     }
     tmp = (mhr[1] & IEEE802154_FCF_SRC_ADDR_MASK);
     if (tmp == IEEE802154_FCF_SRC_ADDR_VOID) {
-        return len;
+        /* One of dst or src address must be present */
+        return has_dst ? len : 0;
     }
     else {
         if (!(mhr[0] & IEEE802154_FCF_PAN_COMP)) {
