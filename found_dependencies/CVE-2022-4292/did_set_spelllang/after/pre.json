[
    {
        "line": 6,
        "fullcodeline": "char_u\tregion_cp[3];"
    },
    {
        "line": 11,
        "fullcodeline": "char_u\tlang[MAXWLEN + 1];"
    },
    {
        "line": 12,
        "fullcodeline": "char_u\tspf_name[MAXPATHL];"
    },
    {
        "line": 17,
        "fullcodeline": "char_u\t*use_region = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "int\t\tdont_use_region = FALSE;"
    },
    {
        "line": 19,
        "fullcodeline": "int\t\tnobreak = FALSE;"
    },
    {
        "line": 22,
        "fullcodeline": "static int\trecursive = FALSE;"
    },
    {
        "line": 23,
        "fullcodeline": "char\t*ret_msg = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "set_bufref(&bufref, wp->w_buffer);"
    },
    {
        "line": 36,
        "fullcodeline": "ga_init2(&ga, sizeof(langp_T), 2);"
    },
    {
        "line": 37,
        "fullcodeline": "clear_midword(wp);"
    },
    {
        "line": 41,
        "fullcodeline": "spl_copy = vim_strsave(wp->w_s->b_p_spl);"
    },
    {
        "line": 186,
        "fullcodeline": "spf = curwin->w_s->b_p_spf;"
    },
    {
        "line": 313,
        "fullcodeline": "redraw_win_later(wp, UPD_NOT_VALID);"
    },
    {
        "line": 42,
        "fullcodeline": "if (spl_copy == NULL)"
    },
    {
        "line": 48,
        "fullcodeline": "for (splp = spl_copy; *splp != NUL; )"
    },
    {
        "line": 187,
        "fullcodeline": "for (round = 0; round == 0 || *spf != NUL; ++round)"
    },
    {
        "line": 273,
        "fullcodeline": "for (i = 0; i < ga.ga_len; ++i)"
    },
    {
        "line": 51,
        "fullcodeline": "copy_option_part(&splp, lang, MAXWLEN, \",\");"
    },
    {
        "line": 52,
        "fullcodeline": "region = NULL;"
    },
    {
        "line": 53,
        "fullcodeline": "len = (int)STRLEN(lang);"
    },
    {
        "line": 275,
        "fullcodeline": "lp = LANGP_ENTRY(ga, i);"
    },
    {
        "line": 106,
        "fullcodeline": "if (region != NULL)"
    },
    {
        "line": 116,
        "fullcodeline": "if (slang == NULL)"
    },
    {
        "line": 189,
        "fullcodeline": "if (round == 0)"
    },
    {
        "line": 216,
        "fullcodeline": "if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)"
    },
    {
        "line": 219,
        "fullcodeline": "if (slang == NULL)"
    },
    {
        "line": 55,
        "fullcodeline": "if (!valid_spelllang(lang))"
    },
    {
        "line": 58,
        "fullcodeline": "if (STRCMP(lang, \"cjk\") == 0)"
    },
    {
        "line": 67,
        "fullcodeline": "if (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)"
    },
    {
        "line": 72,
        "fullcodeline": "p = vim_strchr(gettail(lang), '_');"
    },
    {
        "line": 112,
        "fullcodeline": "use_region = region;"
    },
    {
        "line": 137,
        "fullcodeline": "if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)"
    },
    {
        "line": 139,
        "fullcodeline": ": STRICMP(lang, slang->sl_name) == 0)"
    },
    {
        "line": 141,
        "fullcodeline": "region_mask = REGION_ALL;"
    },
    {
        "line": 194,
        "fullcodeline": "int_wordlist_spl(spf_name);"
    },
    {
        "line": 233,
        "fullcodeline": "slang = spell_load_file(spf_name, lang, NULL, TRUE);"
    },
    {
        "line": 240,
        "fullcodeline": "if (slang != NULL && ga_grow(&ga, 1) == OK)"
    },
    {
        "line": 242,
        "fullcodeline": "region_mask = REGION_ALL;"
    },
    {
        "line": 85,
        "fullcodeline": "if (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)"
    },
    {
        "line": 164,
        "fullcodeline": "if (region_mask != 0)"
    },
    {
        "line": 192,
        "fullcodeline": "if (int_wordlist == NULL)"
    },
    {
        "line": 199,
        "fullcodeline": "copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");"
    },
    {
        "line": 200,
        "fullcodeline": "STRCAT(spf_name, \".spl\");"
    },
    {
        "line": 224,
        "fullcodeline": "if (round == 0)"
    },
    {
        "line": 254,
        "fullcodeline": "if (region_mask != 0)"
    },
    {
        "line": 73,
        "fullcodeline": "if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])"
    },
    {
        "line": 74,
        "fullcodeline": "&& !ASCII_ISALPHA(p[3]))"
    },
    {
        "line": 76,
        "fullcodeline": "vim_strncpy(region_cp, p + 1, 2);"
    },
    {
        "line": 78,
        "fullcodeline": "region = region_cp;"
    },
    {
        "line": 102,
        "fullcodeline": "if (STRICMP(lang, slang->sl_name) == 0)"
    },
    {
        "line": 110,
        "fullcodeline": "if (use_region != NULL && STRCMP(region, use_region) != 0)"
    },
    {
        "line": 111,
        "fullcodeline": "dont_use_region = TRUE;"
    },
    {
        "line": 142,
        "fullcodeline": "if (!filename && region != NULL)"
    },
    {
        "line": 145,
        "fullcodeline": "c = find_region(slang->sl_regions, region);"
    },
    {
        "line": 174,
        "fullcodeline": "++ga.ga_len;"
    },
    {
        "line": 175,
        "fullcodeline": "use_midword(slang, wp);"
    },
    {
        "line": 203,
        "fullcodeline": "for (c = 0; c < ga.ga_len; ++c)"
    },
    {
        "line": 210,
        "fullcodeline": "if (c < ga.ga_len)"
    },
    {
        "line": 225,
        "fullcodeline": "STRCPY(lang, \"internal wordlist\");"
    },
    {
        "line": 237,
        "fullcodeline": "if (slang != NULL && nobreak)"
    },
    {
        "line": 238,
        "fullcodeline": "slang->sl_nobreak = TRUE;"
    },
    {
        "line": 243,
        "fullcodeline": "if (use_region != NULL && !dont_use_region)"
    },
    {
        "line": 246,
        "fullcodeline": "c = find_region(slang->sl_regions, use_region);"
    },
    {
        "line": 260,
        "fullcodeline": "++ga.ga_len;"
    },
    {
        "line": 261,
        "fullcodeline": "use_midword(slang, wp);"
    },
    {
        "line": 283,
        "fullcodeline": "for (j = 0; j < ga.ga_len; ++j)"
    },
    {
        "line": 301,
        "fullcodeline": "for (j = 0; j < ga.ga_len; ++j)"
    },
    {
        "line": 77,
        "fullcodeline": "mch_memmove(p, p + 3, len - (p - lang) - 2);"
    },
    {
        "line": 81,
        "fullcodeline": "dont_use_region = TRUE;"
    },
    {
        "line": 91,
        "fullcodeline": "if (len > 3 && lang[len - 3] == '_')"
    },
    {
        "line": 93,
        "fullcodeline": "region = lang + len - 2;"
    },
    {
        "line": 95,
        "fullcodeline": "lang[len] = NUL;"
    },
    {
        "line": 119,
        "fullcodeline": "(void)spell_load_file(lang, lang, NULL, FALSE);"
    },
    {
        "line": 122,
        "fullcodeline": "spell_load_lang(lang);"
    },
    {
        "line": 146,
        "fullcodeline": "if (c == REGION_ALL)"
    },
    {
        "line": 166,
        "fullcodeline": "if (ga_grow(&ga, 1) == FAIL)"
    },
    {
        "line": 205,
        "fullcodeline": "p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;"
    },
    {
        "line": 228,
        "fullcodeline": "vim_strncpy(lang, gettail(spf_name), MAXWLEN);"
    },
    {
        "line": 229,
        "fullcodeline": "p = vim_strchr(lang, '.');"
    },
    {
        "line": 247,
        "fullcodeline": "if (c != REGION_ALL)"
    },
    {
        "line": 285,
        "fullcodeline": "lp2 = LANGP_ENTRY(ga, j);"
    },
    {
        "line": 303,
        "fullcodeline": "lp2 = LANGP_ENTRY(ga, j);"
    },
    {
        "line": 98,
        "fullcodeline": "dont_use_region = TRUE;"
    },
    {
        "line": 169,
        "fullcodeline": "ret_msg = e_out_of_memory;"
    },
    {
        "line": 172,
        "fullcodeline": "LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;"
    },
    {
        "line": 173,
        "fullcodeline": "LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;"
    },
    {
        "line": 177,
        "fullcodeline": "nobreak = TRUE;"
    },
    {
        "line": 230,
        "fullcodeline": "if (p != NULL)"
    },
    {
        "line": 248,
        "fullcodeline": "region_mask = 1 << c;"
    },
    {
        "line": 256,
        "fullcodeline": "LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;"
    },
    {
        "line": 257,
        "fullcodeline": "LANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;"
    },
    {
        "line": 258,
        "fullcodeline": "LANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;"
    },
    {
        "line": 259,
        "fullcodeline": "LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;"
    },
    {
        "line": 286,
        "fullcodeline": "if (lp2->lp_slang->sl_sal.ga_len > 0"
    },
    {
        "line": 304,
        "fullcodeline": "if (lp2->lp_slang->sl_rep.ga_len > 0"
    },
    {
        "line": 125,
        "fullcodeline": "if (!bufref_valid(&bufref) || !win_valid_any_tab(wp))"
    },
    {
        "line": 127,
        "fullcodeline": "ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);"
    },
    {
        "line": 161,
        "fullcodeline": "region_mask = 1 << c;"
    },
    {
        "line": 206,
        "fullcodeline": "if (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)"
    },
    {
        "line": 231,
        "fullcodeline": "*p = NUL;\t// truncate at \".encoding.add\""
    },
    {
        "line": 287,
        "fullcodeline": "&& STRNCMP(lp->lp_slang->sl_name,"
    },
    {
        "line": 305,
        "fullcodeline": "&& STRNCMP(lp->lp_slang->sl_name,"
    },
    {
        "line": 249,
        "fullcodeline": "else if (*slang->sl_regions != NUL)"
    },
    {
        "line": 150,
        "fullcodeline": "if (*slang->sl_regions != NUL)"
    },
    {
        "line": 251,
        "fullcodeline": "region_mask = 0;"
    },
    {
        "line": 152,
        "fullcodeline": "region_mask = 0;"
    },
    {
        "line": 157,
        "fullcodeline": "smsg(_(\"Warning: region %s not supported\"),"
    }
]