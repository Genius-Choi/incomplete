[
    {
        "line": 4,
        "fullcodeline": "struct rtable *rt = skb_rtable(skb);"
    },
    {
        "line": 5,
        "fullcodeline": "struct net *net = dev_net(rt->dst.dev);"
    },
    {
        "line": 13,
        "fullcodeline": "sk = icmp_xmit_lock(net);"
    },
    {
        "line": 21,
        "fullcodeline": "daddr = ipc.addr = rt->rt_src;"
    },
    {
        "line": 22,
        "fullcodeline": "ipc.opt = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "ipc.tx_flags = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "if (ip_options_echo(&icmp_param->replyopts, skb))"
    },
    {
        "line": 14,
        "fullcodeline": "if (sk == NULL)"
    },
    {
        "line": 16,
        "fullcodeline": "inet = inet_sk(sk);"
    },
    {
        "line": 30,
        "fullcodeline": "struct flowi4 fl4 = {"
    },
    {
        "line": 37,
        "fullcodeline": "rt = ip_route_output_key(net, &fl4);"
    },
    {
        "line": 41,
        "fullcodeline": "if (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,"
    },
    {
        "line": 20,
        "fullcodeline": "inet->tos = ip_hdr(skb)->tos;"
    },
    {
        "line": 25,
        "fullcodeline": "ipc.opt = &icmp_param->replyopts;"
    },
    {
        "line": 36,
        "fullcodeline": "security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));"
    },
    {
        "line": 38,
        "fullcodeline": "if (IS_ERR(rt))"
    },
    {
        "line": 43,
        "fullcodeline": "icmp_push_reply(icmp_param, &ipc, &rt);"
    },
    {
        "line": 27,
        "fullcodeline": "daddr = icmp_param->replyopts.faddr;"
    },
    {
        "line": 31,
        "fullcodeline": ".daddr = daddr,"
    },
    {
        "line": 32,
        "fullcodeline": ".saddr = rt->rt_spec_dst,"
    },
    {
        "line": 33,
        "fullcodeline": ".flowi4_tos = RT_TOS(ip_hdr(skb)->tos),"
    },
    {
        "line": 34,
        "fullcodeline": ".flowi4_proto = IPPROTO_ICMP,"
    }
]