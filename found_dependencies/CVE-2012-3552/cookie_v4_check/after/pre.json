[
    {
        "line": 8,
        "fullcodeline": "struct tcp_sock *tp = tcp_sk(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "const struct tcphdr *th = tcp_hdr(skb);"
    },
    {
        "line": 10,
        "fullcodeline": "__u32 cookie = ntohl(th->ack_seq) - 1;"
    },
    {
        "line": 11,
        "fullcodeline": "struct sock *ret = sk;"
    },
    {
        "line": 27,
        "fullcodeline": "NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);"
    },
    {
        "line": 30,
        "fullcodeline": "memset(&tcp_opt, 0, sizeof(tcp_opt));"
    },
    {
        "line": 31,
        "fullcodeline": "tcp_parse_options(skb, &tcp_opt, &hash_location, 0);"
    },
    {
        "line": 36,
        "fullcodeline": "ret = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "req = inet_reqsk_alloc(&tcp_request_sock_ops); /* for safety */"
    },
    {
        "line": 41,
        "fullcodeline": "ireq = inet_rsk(req);"
    },
    {
        "line": 42,
        "fullcodeline": "treq = tcp_rsk(req);"
    },
    {
        "line": 43,
        "fullcodeline": "treq->rcv_isn\t\t= ntohl(th->seq) - 1;"
    },
    {
        "line": 44,
        "fullcodeline": "treq->snt_isn\t\t= cookie;"
    },
    {
        "line": 45,
        "fullcodeline": "req->mss\t\t= mss;"
    },
    {
        "line": 46,
        "fullcodeline": "ireq->loc_port\t\t= th->dest;"
    },
    {
        "line": 47,
        "fullcodeline": "ireq->rmt_port\t\t= th->source;"
    },
    {
        "line": 48,
        "fullcodeline": "ireq->loc_addr\t\t= ip_hdr(skb)->daddr;"
    },
    {
        "line": 49,
        "fullcodeline": "ireq->rmt_addr\t\t= ip_hdr(skb)->saddr;"
    },
    {
        "line": 50,
        "fullcodeline": "ireq->ecn_ok\t\t= ecn_ok;"
    },
    {
        "line": 51,
        "fullcodeline": "ireq->snd_wscale\t= tcp_opt.snd_wscale;"
    },
    {
        "line": 52,
        "fullcodeline": "ireq->sack_ok\t\t= tcp_opt.sack_ok;"
    },
    {
        "line": 53,
        "fullcodeline": "ireq->wscale_ok\t\t= tcp_opt.wscale_ok;"
    },
    {
        "line": 54,
        "fullcodeline": "ireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;"
    },
    {
        "line": 55,
        "fullcodeline": "req->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;"
    },
    {
        "line": 75,
        "fullcodeline": "req->expires\t= 0UL;"
    },
    {
        "line": 76,
        "fullcodeline": "req->retrans\t= 0;"
    },
    {
        "line": 101,
        "fullcodeline": "req->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);"
    },
    {
        "line": 103,
        "fullcodeline": "tcp_select_initial_window(tcp_full_space(sk), req->mss,"
    },
    {
        "line": 108,
        "fullcodeline": "ireq->rcv_wscale  = rcv_wscale;"
    },
    {
        "line": 110,
        "fullcodeline": "ret = get_cookie_sock(sk, skb, req, &rt->dst);"
    },
    {
        "line": 18,
        "fullcodeline": "if (!sysctl_tcp_syncookies || !th->ack || th->rst)"
    },
    {
        "line": 21,
        "fullcodeline": "if (tcp_synq_no_recent_overflow(sk) ||"
    },
    {
        "line": 33,
        "fullcodeline": "if (!cookie_check_timestamp(&tcp_opt, &ecn_ok))"
    },
    {
        "line": 38,
        "fullcodeline": "if (!req)"
    },
    {
        "line": 60,
        "fullcodeline": "if (opt && opt->optlen) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (security_inet_conn_request(sk, skb, req)) {"
    },
    {
        "line": 87,
        "fullcodeline": "flowi4_init_output(&fl4, 0, sk->sk_mark, RT_CONN_FLAGS(sk),"
    },
    {
        "line": 92,
        "fullcodeline": "security_req_classify_flow(req, flowi4_to_flowi(&fl4));"
    },
    {
        "line": 93,
        "fullcodeline": "rt = ip_route_output_key(sock_net(sk), &fl4);"
    },
    {
        "line": 106,
        "fullcodeline": "dst_metric(&rt->dst, RTAX_INITRWND));"
    },
    {
        "line": 22,
        "fullcodeline": "(mss = cookie_check(skb, cookie)) == 0) {"
    },
    {
        "line": 23,
        "fullcodeline": "NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);"
    },
    {
        "line": 61,
        "fullcodeline": "int opt_size = sizeof(struct ip_options_rcu) + opt->optlen;"
    },
    {
        "line": 63,
        "fullcodeline": "ireq->opt = kmalloc(opt_size, GFP_ATOMIC);"
    },
    {
        "line": 71,
        "fullcodeline": "reqsk_free(req);"
    },
    {
        "line": 89,
        "fullcodeline": "inet_sk_flowi_flags(sk),"
    },
    {
        "line": 90,
        "fullcodeline": "(opt && opt->srr) ? opt->faddr : ireq->rmt_addr,"
    },
    {
        "line": 94,
        "fullcodeline": "if (IS_ERR(rt)) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {"
    },
    {
        "line": 95,
        "fullcodeline": "reqsk_free(req);"
    },
    {
        "line": 65,
        "fullcodeline": "kfree(ireq->opt);"
    },
    {
        "line": 66,
        "fullcodeline": "ireq->opt = NULL;"
    }
]