[
    {
        "line": 6,
        "fullcodeline": "const size_t entry_offset = indx->entries_count;"
    },
    {
        "line": 7,
        "fullcodeline": "const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];"
    },
    {
        "line": 8,
        "fullcodeline": "mobi_buffer_setpos(buf, idxt.offsets[curr_number]);"
    },
    {
        "line": 9,
        "fullcodeline": "size_t entry_number = curr_number + entry_offset;"
    },
    {
        "line": 15,
        "fullcodeline": "const size_t buf_maxlen = buf->maxlen;"
    },
    {
        "line": 20,
        "fullcodeline": "buf->maxlen = buf->offset + entry_length;"
    },
    {
        "line": 21,
        "fullcodeline": "size_t label_length = mobi_buffer_get8(buf);"
    },
    {
        "line": 26,
        "fullcodeline": "char text[INDX_LABEL_SIZEMAX + 1];"
    },
    {
        "line": 37,
        "fullcodeline": "indx->entries[entry_number].label = malloc(label_length + 1);"
    },
    {
        "line": 45,
        "fullcodeline": "control_bytes = buf->data + buf->offset;"
    },
    {
        "line": 46,
        "fullcodeline": "mobi_buffer_seek(buf, (int) tagx->control_byte_count);"
    },
    {
        "line": 47,
        "fullcodeline": "indx->entries[entry_number].tags_count = 0;"
    },
    {
        "line": 2,
        "fullcodeline": "if (indx == NULL) {"
    },
    {
        "line": 10,
        "fullcodeline": "if (entry_number >= indx->total_entries_count) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (buf->offset + entry_length >= buf_maxlen) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (label_length > entry_length) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (indx->entries[entry_number].label == NULL) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (tagx->tags_count > 0) {"
    },
    {
        "line": 3,
        "fullcodeline": "debug_print(\"%s\", \"INDX structure not initialized\\n\");"
    },
    {
        "line": 29,
        "fullcodeline": "label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);"
    },
    {
        "line": 56,
        "fullcodeline": "MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));"
    },
    {
        "line": 61,
        "fullcodeline": "uint32_t ptagx_count = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "size_t i = 0;"
    },
    {
        "line": 101,
        "fullcodeline": "indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));"
    },
    {
        "line": 107,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);"
    },
    {
        "line": 57,
        "fullcodeline": "if (ptagx == NULL) {"
    },
    {
        "line": 64,
        "fullcodeline": "while (i < tagx->tags_count) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (indx->entries[entry_number].tags == NULL) {"
    },
    {
        "line": 108,
        "fullcodeline": "while (i < ptagx_count) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (buf->error != MOBI_SUCCESS) {"
    },
    {
        "line": 70,
        "fullcodeline": "uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;"
    },
    {
        "line": 99,
        "fullcodeline": "i++;"
    },
    {
        "line": 109,
        "fullcodeline": "uint32_t tagvalues_count = 0;"
    },
    {
        "line": 112,
        "fullcodeline": "uint32_t tagvalues[INDX_TAGVALUES_MAX];"
    },
    {
        "line": 144,
        "fullcodeline": "i++;"
    },
    {
        "line": 58,
        "fullcodeline": "debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));"
    },
    {
        "line": 71,
        "fullcodeline": "if (value != 0) {"
    },
    {
        "line": 103,
        "fullcodeline": "debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));"
    },
    {
        "line": 113,
        "fullcodeline": "if (ptagx[i].value_count != MOBI_NOTSET) {"
    },
    {
        "line": 66,
        "fullcodeline": "control_bytes++;"
    },
    {
        "line": 67,
        "fullcodeline": "i++;"
    },
    {
        "line": 73,
        "fullcodeline": "uint32_t value_count = MOBI_NOTSET;"
    },
    {
        "line": 74,
        "fullcodeline": "uint32_t value_bytes = MOBI_NOTSET;"
    },
    {
        "line": 97,
        "fullcodeline": "ptagx_count++;"
    },
    {
        "line": 114,
        "fullcodeline": "size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;"
    },
    {
        "line": 130,
        "fullcodeline": "const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);"
    },
    {
        "line": 131,
        "fullcodeline": "indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);"
    },
    {
        "line": 76,
        "fullcodeline": "if (value == tagx->tags[i].bitmask) {"
    },
    {
        "line": 115,
        "fullcodeline": "while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {"
    },
    {
        "line": 123,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 132,
        "fullcodeline": "if (indx->entries[entry_number].tags[i].tagvalues == NULL) {"
    },
    {
        "line": 116,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 117,
        "fullcodeline": "const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);"
    },
    {
        "line": 118,
        "fullcodeline": "tagvalues[tagvalues_count++] = value_bytes;"
    },
    {
        "line": 124,
        "fullcodeline": "while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {"
    },
    {
        "line": 86,
        "fullcodeline": "uint8_t mask = tagx->tags[i].bitmask;"
    },
    {
        "line": 91,
        "fullcodeline": "value_count = value;"
    },
    {
        "line": 125,
        "fullcodeline": "const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);"
    },
    {
        "line": 126,
        "fullcodeline": "tagvalues[tagvalues_count++] = value_bytes;"
    },
    {
        "line": 78,
        "fullcodeline": "if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {"
    },
    {
        "line": 80,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "value_bytes = mobi_buffer_get_varlen(buf, &len);"
    },
    {
        "line": 83,
        "fullcodeline": "value_count = 1;"
    },
    {
        "line": 87,
        "fullcodeline": "while ((mask & 1) == 0) {"
    },
    {
        "line": 88,
        "fullcodeline": "mask >>= 1;"
    },
    {
        "line": 89,
        "fullcodeline": "value >>= 1;"
    }
]