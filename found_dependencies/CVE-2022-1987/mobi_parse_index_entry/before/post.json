[
    {
        "line": 6,
        "fullcodeline": "const size_t entry_offset = indx->entries_count;"
    },
    {
        "line": 7,
        "fullcodeline": "const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];"
    },
    {
        "line": 8,
        "fullcodeline": "mobi_buffer_setpos(buf, idxt.offsets[curr_number]);"
    },
    {
        "line": 9,
        "fullcodeline": "size_t entry_number = curr_number + entry_offset;"
    },
    {
        "line": 15,
        "fullcodeline": "const size_t buf_maxlen = buf->maxlen;"
    },
    {
        "line": 20,
        "fullcodeline": "buf->maxlen = buf->offset + entry_length;"
    },
    {
        "line": 21,
        "fullcodeline": "size_t label_length = mobi_buffer_get8(buf);"
    },
    {
        "line": 26,
        "fullcodeline": "char text[INDX_LABEL_SIZEMAX];"
    },
    {
        "line": 33,
        "fullcodeline": "indx->entries[entry_number].label = malloc(label_length + 1);"
    },
    {
        "line": 38,
        "fullcodeline": "strncpy(indx->entries[entry_number].label, text, label_length + 1);"
    },
    {
        "line": 41,
        "fullcodeline": "control_bytes = buf->data + buf->offset;"
    },
    {
        "line": 42,
        "fullcodeline": "mobi_buffer_seek(buf, (int) tagx->control_byte_count);"
    },
    {
        "line": 43,
        "fullcodeline": "indx->entries[entry_number].tags_count = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "indx->entries[entry_number].tags = NULL;"
    },
    {
        "line": 145,
        "fullcodeline": "buf->maxlen = buf_maxlen;"
    },
    {
        "line": 2,
        "fullcodeline": "if (indx == NULL) {"
    },
    {
        "line": 10,
        "fullcodeline": "if (entry_number >= indx->total_entries_count) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (buf->offset + entry_length >= buf_maxlen) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (label_length > entry_length) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (indx->entries[entry_number].label == NULL) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (tagx->tags_count > 0) {"
    },
    {
        "line": 3,
        "fullcodeline": "debug_print(\"%s\", \"INDX structure not initialized\\n\");"
    },
    {
        "line": 11,
        "fullcodeline": "debug_print(\"Entry number beyond array: %zu\\n\", entry_number);"
    },
    {
        "line": 17,
        "fullcodeline": "debug_print(\"Entry length too long: %zu\\n\", entry_length);"
    },
    {
        "line": 23,
        "fullcodeline": "debug_print(\"Label length too long: %zu\\n\", label_length);"
    },
    {
        "line": 29,
        "fullcodeline": "label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);"
    },
    {
        "line": 35,
        "fullcodeline": "debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);"
    },
    {
        "line": 52,
        "fullcodeline": "MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));"
    },
    {
        "line": 57,
        "fullcodeline": "uint32_t ptagx_count = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "size_t i = 0;"
    },
    {
        "line": 97,
        "fullcodeline": "indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));"
    },
    {
        "line": 103,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 142,
        "fullcodeline": "free(ptagx);"
    },
    {
        "line": 31,
        "fullcodeline": "label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);"
    },
    {
        "line": 53,
        "fullcodeline": "if (ptagx == NULL) {"
    },
    {
        "line": 60,
        "fullcodeline": "while (i < tagx->tags_count) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (indx->entries[entry_number].tags == NULL) {"
    },
    {
        "line": 104,
        "fullcodeline": "while (i < ptagx_count) {"
    },
    {
        "line": 54,
        "fullcodeline": "debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));"
    },
    {
        "line": 66,
        "fullcodeline": "uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;"
    },
    {
        "line": 95,
        "fullcodeline": "i++;"
    },
    {
        "line": 99,
        "fullcodeline": "debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));"
    },
    {
        "line": 100,
        "fullcodeline": "free(ptagx);"
    },
    {
        "line": 105,
        "fullcodeline": "uint32_t tagvalues_count = 0;"
    },
    {
        "line": 108,
        "fullcodeline": "uint32_t tagvalues[INDX_TAGVALUES_MAX];"
    },
    {
        "line": 138,
        "fullcodeline": "indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;"
    },
    {
        "line": 139,
        "fullcodeline": "indx->entries[entry_number].tags_count++;"
    },
    {
        "line": 140,
        "fullcodeline": "i++;"
    },
    {
        "line": 61,
        "fullcodeline": "if (tagx->tags[i].control_byte == 1) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (value != 0) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (ptagx[i].value_count != MOBI_NOTSET) {"
    },
    {
        "line": 62,
        "fullcodeline": "control_bytes++;"
    },
    {
        "line": 63,
        "fullcodeline": "i++;"
    },
    {
        "line": 69,
        "fullcodeline": "uint32_t value_count = MOBI_NOTSET;"
    },
    {
        "line": 70,
        "fullcodeline": "uint32_t value_bytes = MOBI_NOTSET;"
    },
    {
        "line": 91,
        "fullcodeline": "ptagx[ptagx_count].value_count = value_count;"
    },
    {
        "line": 92,
        "fullcodeline": "ptagx[ptagx_count].value_bytes = value_bytes;"
    },
    {
        "line": 93,
        "fullcodeline": "ptagx_count++;"
    },
    {
        "line": 110,
        "fullcodeline": "size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;"
    },
    {
        "line": 126,
        "fullcodeline": "const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);"
    },
    {
        "line": 127,
        "fullcodeline": "indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);"
    },
    {
        "line": 133,
        "fullcodeline": "memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);"
    },
    {
        "line": 72,
        "fullcodeline": "if (value == tagx->tags[i].bitmask) {"
    },
    {
        "line": 111,
        "fullcodeline": "while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {"
    },
    {
        "line": 119,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 128,
        "fullcodeline": "if (indx->entries[entry_number].tags[i].tagvalues == NULL) {"
    },
    {
        "line": 135,
        "fullcodeline": "indx->entries[entry_number].tags[i].tagvalues = NULL;"
    },
    {
        "line": 112,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 113,
        "fullcodeline": "const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);"
    },
    {
        "line": 114,
        "fullcodeline": "tagvalues[tagvalues_count++] = value_bytes;"
    },
    {
        "line": 120,
        "fullcodeline": "while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {"
    },
    {
        "line": 129,
        "fullcodeline": "debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);"
    },
    {
        "line": 130,
        "fullcodeline": "free(ptagx);"
    },
    {
        "line": 74,
        "fullcodeline": "if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {"
    },
    {
        "line": 82,
        "fullcodeline": "uint8_t mask = tagx->tags[i].bitmask;"
    },
    {
        "line": 87,
        "fullcodeline": "value_count = value;"
    },
    {
        "line": 121,
        "fullcodeline": "const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);"
    },
    {
        "line": 122,
        "fullcodeline": "tagvalues[tagvalues_count++] = value_bytes;"
    },
    {
        "line": 76,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 77,
        "fullcodeline": "value_bytes = mobi_buffer_get_varlen(buf, &len);"
    },
    {
        "line": 83,
        "fullcodeline": "while ((mask & 1) == 0) {"
    },
    {
        "line": 79,
        "fullcodeline": "value_count = 1;"
    },
    {
        "line": 84,
        "fullcodeline": "mask >>= 1;"
    },
    {
        "line": 85,
        "fullcodeline": "value >>= 1;"
    }
]