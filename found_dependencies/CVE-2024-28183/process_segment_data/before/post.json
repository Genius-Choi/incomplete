[
    {
        "line": 10,
        "fullcodeline": "const uint32_t *data = (const uint32_t *)bootloader_mmap(data_addr, data_len);"
    },
    {
        "line": 36,
        "fullcodeline": "const uint32_t *src = data;"
    },
    {
        "line": 60,
        "fullcodeline": "bootloader_munmap(data);"
    },
    {
        "line": 5,
        "fullcodeline": "if (!do_load && checksum == NULL) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (!data) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (checksum == NULL && sha_handle == NULL) {"
    },
    {
        "line": 38,
        "fullcodeline": "for (size_t i = 0; i < data_len; i += 4) {"
    },
    {
        "line": 6,
        "fullcodeline": "ESP_LOGD(TAG, \"skipping checksum for segment\");"
    },
    {
        "line": 12,
        "fullcodeline": "ESP_LOGE(TAG, \"bootloader_mmap(0x%x, 0x%x) failed\","
    },
    {
        "line": 18,
        "fullcodeline": "memcpy((void *)load_addr, data, data_len);"
    },
    {
        "line": 19,
        "fullcodeline": "bootloader_munmap(data);"
    },
    {
        "line": 39,
        "fullcodeline": "int w_i = i / 4; // Word index"
    },
    {
        "line": 40,
        "fullcodeline": "uint32_t w = src[w_i];"
    },
    {
        "line": 53,
        "fullcodeline": "const size_t SHA_CHUNK = 1024;"
    },
    {
        "line": 41,
        "fullcodeline": "if (checksum != NULL) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (sha_handle != NULL && i % SHA_CHUNK == 0) {"
    },
    {
        "line": 42,
        "fullcodeline": "*checksum ^= w;"
    },
    {
        "line": 55,
        "fullcodeline": "bootloader_sha256_data(sha_handle, &src[w_i],"
    },
    {
        "line": 56,
        "fullcodeline": "MIN(SHA_CHUNK, data_len - i));"
    }
]