[
    {
        "line": 3,
        "fullcodeline": "esp_err_t err = ESP_OK;"
    },
    {
        "line": 4,
        "fullcodeline": "uint32_t start_segments = data->start_addr + data->image_len;"
    },
    {
        "line": 5,
        "fullcodeline": "uint32_t next_addr = start_segments;"
    },
    {
        "line": 15,
        "fullcodeline": "uint32_t end_addr = next_addr;"
    },
    {
        "line": 20,
        "fullcodeline": "data->image_len += end_addr - start_segments;"
    },
    {
        "line": 21,
        "fullcodeline": "ESP_LOGV(TAG, \"image start 0x%08x end of last section 0x%08x\", data->start_addr, end_addr);"
    },
    {
        "line": 6,
        "fullcodeline": "for (int i = 0; i < data->image.segment_count; i++) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (end_addr < data->start_addr) {"
    },
    {
        "line": 8,
        "fullcodeline": "ESP_LOGV(TAG, \"loading segment header %d at offset 0x%x\", i, next_addr);"
    },
    {
        "line": 9,
        "fullcodeline": "CHECK_ERR(process_segment(i, next_addr, header, silent, do_load, sha_handle, checksum));"
    },
    {
        "line": 10,
        "fullcodeline": "next_addr += sizeof(esp_image_segment_header_t);"
    },
    {
        "line": 11,
        "fullcodeline": "data->segment_data[i] = next_addr;"
    },
    {
        "line": 12,
        "fullcodeline": "next_addr += header->data_len;"
    },
    {
        "line": 17,
        "fullcodeline": "FAIL_LOAD(\"image offset has wrapped\");"
    }
]