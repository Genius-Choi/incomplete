[
    {
        "line": 5,
        "fullcodeline": "int\t\textra = interpolate ? 1 : 0;"
    },
    {
        "line": 6,
        "fullcodeline": "int\t\toff = interpolate ? 0 : 1;"
    },
    {
        "line": 62,
        "fullcodeline": "rettv->v_type = VAR_STRING;"
    },
    {
        "line": 63,
        "fullcodeline": "len = (int)(p - *arg + extra);"
    },
    {
        "line": 64,
        "fullcodeline": "rettv->vval.v_string = alloc(len);"
    },
    {
        "line": 67,
        "fullcodeline": "end = rettv->vval.v_string;"
    },
    {
        "line": 10,
        "fullcodeline": "for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))"
    },
    {
        "line": 47,
        "fullcodeline": "if (*p != '\"' && !(interpolate && *p == '{'))"
    },
    {
        "line": 65,
        "fullcodeline": "if (rettv->vval.v_string == NULL)"
    },
    {
        "line": 69,
        "fullcodeline": "for (p = *arg + off; *p != NUL && *p != '\"'; )"
    },
    {
        "line": 165,
        "fullcodeline": "if (*p == '\"' && !interpolate)"
    },
    {
        "line": 166,
        "fullcodeline": "++p;"
    },
    {
        "line": 12,
        "fullcodeline": "if (*p == '\\\\' && p[1] != NUL)"
    },
    {
        "line": 49,
        "fullcodeline": "semsg(_(e_missing_double_quote_str), *arg);"
    },
    {
        "line": 71,
        "fullcodeline": "if (*p == '\\\\')"
    },
    {
        "line": 14,
        "fullcodeline": "++p;"
    },
    {
        "line": 18,
        "fullcodeline": "if (*p == '<')"
    },
    {
        "line": 161,
        "fullcodeline": "MB_COPY_CHAR(p, end);"
    },
    {
        "line": 20,
        "fullcodeline": "int\t\tmodifiers = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tflags = FSK_KEYCODE | FSK_IN_STRING;"
    },
    {
        "line": 23,
        "fullcodeline": "extra += 5;"
    },
    {
        "line": 33,
        "fullcodeline": "else if (interpolate && (*p == '{' || *p == '}'))"
    },
    {
        "line": 73,
        "fullcodeline": "switch (*++p)"
    },
    {
        "line": 75,
        "fullcodeline": "case 'b': *end++ = BS; ++p; break;"
    },
    {
        "line": 76,
        "fullcodeline": "case 'e': *end++ = ESC; ++p; break;"
    },
    {
        "line": 77,
        "fullcodeline": "case 'f': *end++ = FF; ++p; break;"
    },
    {
        "line": 78,
        "fullcodeline": "case 'n': *end++ = NL; ++p; break;"
    },
    {
        "line": 79,
        "fullcodeline": "case 'r': *end++ = CAR; ++p; break;"
    },
    {
        "line": 80,
        "fullcodeline": "case 't': *end++ = TAB; ++p; break;"
    },
    {
        "line": 121,
        "fullcodeline": "case '7': *end = *p++ - '0';"
    },
    {
        "line": 128,
        "fullcodeline": "++end;"
    },
    {
        "line": 149,
        "fullcodeline": "default: MB_COPY_CHAR(p, end);"
    },
    {
        "line": 155,
        "fullcodeline": "if (interpolate && (*p == '{' || *p == '}'))"
    },
    {
        "line": 27,
        "fullcodeline": "if (p[1] != '*')"
    },
    {
        "line": 29,
        "fullcodeline": "if (find_special_key(&p, &modifiers, flags, NULL) != 0)"
    },
    {
        "line": 37,
        "fullcodeline": "++p;"
    },
    {
        "line": 43,
        "fullcodeline": "--extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\""
    },
    {
        "line": 86,
        "fullcodeline": "if (vim_isxdigit(p[1]))"
    },
    {
        "line": 122,
        "fullcodeline": "if (*p >= '0' && *p <= '7')"
    },
    {
        "line": 134,
        "fullcodeline": "int flags = FSK_KEYCODE | FSK_IN_STRING;"
    },
    {
        "line": 138,
        "fullcodeline": "extra = trans_special(&p, end, flags, FALSE, NULL);"
    },
    {
        "line": 159,
        "fullcodeline": "++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\""
    },
    {
        "line": 28,
        "fullcodeline": "flags |= FSK_SIMPLIFY;"
    },
    {
        "line": 30,
        "fullcodeline": "--p;  // leave \"p\" on the \">\""
    },
    {
        "line": 35,
        "fullcodeline": "if (*p == '{' && p[1] != '{') // start of expression"
    },
    {
        "line": 38,
        "fullcodeline": "if (p[-1] == '}' && *p != '}') // single '}' is an error"
    },
    {
        "line": 89,
        "fullcodeline": "int\tc = toupper(*p);"
    },
    {
        "line": 97,
        "fullcodeline": "nr = 0;"
    },
    {
        "line": 103,
        "fullcodeline": "++p;"
    },
    {
        "line": 124,
        "fullcodeline": "*end = (*end << 3) + *p++ - '0';"
    },
    {
        "line": 136,
        "fullcodeline": "if (p[1] != '*')"
    },
    {
        "line": 139,
        "fullcodeline": "if (extra != 0)"
    },
    {
        "line": 40,
        "fullcodeline": "semsg(_(e_stray_closing_curly_str), *arg);"
    },
    {
        "line": 91,
        "fullcodeline": "if (c == 'X')"
    },
    {
        "line": 125,
        "fullcodeline": "if (*p >= '0' && *p <= '7')"
    },
    {
        "line": 137,
        "fullcodeline": "flags |= FSK_SIMPLIFY;"
    },
    {
        "line": 141,
        "fullcodeline": "end += extra;"
    },
    {
        "line": 157,
        "fullcodeline": "if (*p == '{' && p[1] != '{') // start of expression"
    },
    {
        "line": 92,
        "fullcodeline": "n = 2;"
    },
    {
        "line": 98,
        "fullcodeline": "while (--n >= 0 && vim_isxdigit(p[1]))"
    },
    {
        "line": 100,
        "fullcodeline": "++p;"
    },
    {
        "line": 101,
        "fullcodeline": "nr = (nr << 4) + hex2nr(*p);"
    },
    {
        "line": 107,
        "fullcodeline": "end += (*mb_char2bytes)(nr, end);"
    },
    {
        "line": 126,
        "fullcodeline": "*end = (*end << 3) + *p++ - '0';"
    },
    {
        "line": 142,
        "fullcodeline": "if (end >= rettv->vval.v_string + len)"
    },
    {
        "line": 93,
        "fullcodeline": "else if (*p == 'u')"
    },
    {
        "line": 94,
        "fullcodeline": "n = 4;"
    },
    {
        "line": 109,
        "fullcodeline": "*end++ = nr;"
    },
    {
        "line": 96,
        "fullcodeline": "n = 8;"
    }
]