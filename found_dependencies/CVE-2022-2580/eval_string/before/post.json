[
    {
        "line": 5,
        "fullcodeline": "int\t\textra = interpolate ? 1 : 0;"
    },
    {
        "line": 6,
        "fullcodeline": "int\t\toff = interpolate ? 0 : 1;"
    },
    {
        "line": 50,
        "fullcodeline": "rettv->v_type = VAR_STRING;"
    },
    {
        "line": 51,
        "fullcodeline": "len = (int)(p - *arg + extra);"
    },
    {
        "line": 52,
        "fullcodeline": "rettv->vval.v_string = alloc(len);"
    },
    {
        "line": 55,
        "fullcodeline": "end = rettv->vval.v_string;"
    },
    {
        "line": 152,
        "fullcodeline": "*end = NUL;"
    },
    {
        "line": 155,
        "fullcodeline": "*arg = p;"
    },
    {
        "line": 10,
        "fullcodeline": "for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))"
    },
    {
        "line": 35,
        "fullcodeline": "if (*p != '\"' && !(interpolate && *p == '{'))"
    },
    {
        "line": 42,
        "fullcodeline": "if (!evaluate)"
    },
    {
        "line": 53,
        "fullcodeline": "if (rettv->vval.v_string == NULL)"
    },
    {
        "line": 57,
        "fullcodeline": "for (p = *arg + off; *p != NUL && *p != '\"'; )"
    },
    {
        "line": 153,
        "fullcodeline": "if (*p == '\"' && !interpolate)"
    },
    {
        "line": 37,
        "fullcodeline": "semsg(_(e_missing_double_quote_str), *arg);"
    },
    {
        "line": 44,
        "fullcodeline": "*arg = p + off;"
    },
    {
        "line": 154,
        "fullcodeline": "++p;"
    },
    {
        "line": 12,
        "fullcodeline": "if (*p == '\\\\' && p[1] != NUL)"
    },
    {
        "line": 59,
        "fullcodeline": "if (*p == '\\\\')"
    },
    {
        "line": 14,
        "fullcodeline": "++p;"
    },
    {
        "line": 18,
        "fullcodeline": "if (*p == '<')"
    },
    {
        "line": 149,
        "fullcodeline": "MB_COPY_CHAR(p, end);"
    },
    {
        "line": 19,
        "fullcodeline": "extra += 5;"
    },
    {
        "line": 21,
        "fullcodeline": "else if (interpolate && (*p == '{' || *p == '}'))"
    },
    {
        "line": 61,
        "fullcodeline": "switch (*++p)"
    },
    {
        "line": 63,
        "fullcodeline": "case 'b': *end++ = BS; ++p; break;"
    },
    {
        "line": 64,
        "fullcodeline": "case 'e': *end++ = ESC; ++p; break;"
    },
    {
        "line": 65,
        "fullcodeline": "case 'f': *end++ = FF; ++p; break;"
    },
    {
        "line": 66,
        "fullcodeline": "case 'n': *end++ = NL; ++p; break;"
    },
    {
        "line": 67,
        "fullcodeline": "case 'r': *end++ = CAR; ++p; break;"
    },
    {
        "line": 68,
        "fullcodeline": "case 't': *end++ = TAB; ++p; break;"
    },
    {
        "line": 109,
        "fullcodeline": "case '7': *end = *p++ - '0';"
    },
    {
        "line": 116,
        "fullcodeline": "++end;"
    },
    {
        "line": 137,
        "fullcodeline": "default: MB_COPY_CHAR(p, end);"
    },
    {
        "line": 143,
        "fullcodeline": "if (interpolate && (*p == '{' || *p == '}'))"
    },
    {
        "line": 25,
        "fullcodeline": "++p;"
    },
    {
        "line": 31,
        "fullcodeline": "--extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\""
    },
    {
        "line": 74,
        "fullcodeline": "if (vim_isxdigit(p[1]))"
    },
    {
        "line": 110,
        "fullcodeline": "if (*p >= '0' && *p <= '7')"
    },
    {
        "line": 122,
        "fullcodeline": "int flags = FSK_KEYCODE | FSK_IN_STRING;"
    },
    {
        "line": 126,
        "fullcodeline": "extra = trans_special(&p, end, flags, FALSE, NULL);"
    },
    {
        "line": 147,
        "fullcodeline": "++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\""
    },
    {
        "line": 23,
        "fullcodeline": "if (*p == '{' && p[1] != '{') // start of expression"
    },
    {
        "line": 26,
        "fullcodeline": "if (p[-1] == '}' && *p != '}') // single '}' is an error"
    },
    {
        "line": 77,
        "fullcodeline": "int\tc = toupper(*p);"
    },
    {
        "line": 85,
        "fullcodeline": "nr = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "++p;"
    },
    {
        "line": 112,
        "fullcodeline": "*end = (*end << 3) + *p++ - '0';"
    },
    {
        "line": 124,
        "fullcodeline": "if (p[1] != '*')"
    },
    {
        "line": 127,
        "fullcodeline": "if (extra != 0)"
    },
    {
        "line": 145,
        "fullcodeline": "if (*p == '{' && p[1] != '{') // start of expression"
    },
    {
        "line": 28,
        "fullcodeline": "semsg(_(e_stray_closing_curly_str), *arg);"
    },
    {
        "line": 79,
        "fullcodeline": "if (c == 'X')"
    },
    {
        "line": 86,
        "fullcodeline": "while (--n >= 0 && vim_isxdigit(p[1]))"
    },
    {
        "line": 94,
        "fullcodeline": "if (c != 'X')"
    },
    {
        "line": 113,
        "fullcodeline": "if (*p >= '0' && *p <= '7')"
    },
    {
        "line": 125,
        "fullcodeline": "flags |= FSK_SIMPLIFY;"
    },
    {
        "line": 129,
        "fullcodeline": "end += extra;"
    },
    {
        "line": 80,
        "fullcodeline": "n = 2;"
    },
    {
        "line": 88,
        "fullcodeline": "++p;"
    },
    {
        "line": 89,
        "fullcodeline": "nr = (nr << 4) + hex2nr(*p);"
    },
    {
        "line": 95,
        "fullcodeline": "end += (*mb_char2bytes)(nr, end);"
    },
    {
        "line": 114,
        "fullcodeline": "*end = (*end << 3) + *p++ - '0';"
    },
    {
        "line": 130,
        "fullcodeline": "if (end >= rettv->vval.v_string + len)"
    },
    {
        "line": 97,
        "fullcodeline": "*end++ = nr;"
    },
    {
        "line": 131,
        "fullcodeline": "iemsg(\"eval_string() used more space than allocated\");"
    },
    {
        "line": 81,
        "fullcodeline": "else if (*p == 'u')"
    },
    {
        "line": 82,
        "fullcodeline": "n = 4;"
    },
    {
        "line": 84,
        "fullcodeline": "n = 8;"
    }
]