[
    {
        "line": 6,
        "fullcodeline": "struct ipv6_pinfo *np = inet6_sk(sk);"
    },
    {
        "line": 7,
        "fullcodeline": "struct ipv6_txoptions *opt_to_free = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "struct ipv6_txoptions *opt = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "struct ip6_flowlabel *flowlabel = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "struct dst_entry *dst = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "int addr_len = msg->msg_namelen;"
    },
    {
        "line": 13,
        "fullcodeline": "int hlimit = -1;"
    },
    {
        "line": 14,
        "fullcodeline": "int tclass = -1;"
    },
    {
        "line": 15,
        "fullcodeline": "int dontfrag = -1;"
    },
    {
        "line": 16,
        "fullcodeline": "int transhdrlen = 4; /* zero session-id */"
    },
    {
        "line": 17,
        "fullcodeline": "int ulen = len + transhdrlen;"
    },
    {
        "line": 33,
        "fullcodeline": "memset(&fl6, 0, sizeof(fl6));"
    },
    {
        "line": 35,
        "fullcodeline": "fl6.flowi6_mark = sk->sk_mark;"
    },
    {
        "line": 103,
        "fullcodeline": "opt = ipv6_fixup_options(&opt_space, opt);"
    },
    {
        "line": 105,
        "fullcodeline": "fl6.flowi6_proto = sk->sk_protocol;"
    },
    {
        "line": 113,
        "fullcodeline": "final_p = fl6_update_dst(&fl6, opt, &final);"
    },
    {
        "line": 120,
        "fullcodeline": "security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));"
    },
    {
        "line": 122,
        "fullcodeline": "dst = ip6_dst_lookup_flow(sk, &fl6, final_p);"
    },
    {
        "line": 141,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 142,
        "fullcodeline": "err = ip6_append_data(sk, ip_generic_getfrag, msg,"
    },
    {
        "line": 160,
        "fullcodeline": "dst_confirm(dst);"
    },
    {
        "line": 163,
        "fullcodeline": "err = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "if (len > INT_MAX)"
    },
    {
        "line": 27,
        "fullcodeline": "if (msg->msg_flags & MSG_OOB)"
    },
    {
        "line": 74,
        "fullcodeline": "if (fl6.flowi6_oif == 0)"
    },
    {
        "line": 97,
        "fullcodeline": "if (!opt) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (IS_ERR(dst)) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (hlimit < 0)"
    },
    {
        "line": 131,
        "fullcodeline": "if (tclass < 0)"
    },
    {
        "line": 134,
        "fullcodeline": "if (dontfrag < 0)"
    },
    {
        "line": 137,
        "fullcodeline": "if (msg->msg_flags & MSG_CONFIRM)"
    },
    {
        "line": 157,
        "fullcodeline": "return err < 0 ? err : len;"
    },
    {
        "line": 161,
        "fullcodeline": "if (!(msg->msg_flags & MSG_PROBE) || len)"
    },
    {
        "line": 44,
        "fullcodeline": "daddr = &lsa->l2tp_addr;"
    },
    {
        "line": 75,
        "fullcodeline": "fl6.flowi6_oif = sk->sk_bound_dev_if;"
    },
    {
        "line": 78,
        "fullcodeline": "opt = &opt_space;"
    },
    {
        "line": 79,
        "fullcodeline": "memset(opt, 0, sizeof(struct ipv6_txoptions));"
    },
    {
        "line": 80,
        "fullcodeline": "opt->tot_len = sizeof(struct ipv6_txoptions);"
    },
    {
        "line": 82,
        "fullcodeline": "err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,"
    },
    {
        "line": 98,
        "fullcodeline": "opt = txopt_get(np);"
    },
    {
        "line": 99,
        "fullcodeline": "opt_to_free = opt;"
    },
    {
        "line": 102,
        "fullcodeline": "opt = fl6_merge_options(&opt_space, flowlabel, opt);"
    },
    {
        "line": 106,
        "fullcodeline": "if (!ipv6_addr_any(daddr))"
    },
    {
        "line": 107,
        "fullcodeline": "fl6.daddr = *daddr;"
    },
    {
        "line": 110,
        "fullcodeline": "if (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))"
    },
    {
        "line": 111,
        "fullcodeline": "fl6.saddr = np->saddr;"
    },
    {
        "line": 115,
        "fullcodeline": "if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))"
    },
    {
        "line": 116,
        "fullcodeline": "fl6.flowi6_oif = np->mcast_oif;"
    },
    {
        "line": 124,
        "fullcodeline": "err = PTR_ERR(dst);"
    },
    {
        "line": 129,
        "fullcodeline": "hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);"
    },
    {
        "line": 132,
        "fullcodeline": "tclass = np->tclass;"
    },
    {
        "line": 135,
        "fullcodeline": "dontfrag = np->dontfrag;"
    },
    {
        "line": 147,
        "fullcodeline": "ip6_flush_pending_frames(sk);"
    },
    {
        "line": 24,
        "fullcodeline": "return -EMSGSIZE;"
    },
    {
        "line": 28,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 38,
        "fullcodeline": "if (addr_len < SIN6_LEN_RFC2133)"
    },
    {
        "line": 70,
        "fullcodeline": "daddr = &sk->sk_v6_daddr;"
    },
    {
        "line": 71,
        "fullcodeline": "fl6.flowlabel = np->flow_label;"
    },
    {
        "line": 84,
        "fullcodeline": "if (err < 0) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)"
    },
    {
        "line": 46,
        "fullcodeline": "fl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;"
    },
    {
        "line": 58,
        "fullcodeline": "if (sk->sk_state == TCP_ESTABLISHED &&"
    },
    {
        "line": 59,
        "fullcodeline": "ipv6_addr_equal(daddr, &sk->sk_v6_daddr))"
    },
    {
        "line": 60,
        "fullcodeline": "daddr = &sk->sk_v6_daddr;"
    },
    {
        "line": 62,
        "fullcodeline": "if (addr_len >= sizeof(struct sockaddr_in6) &&"
    },
    {
        "line": 64,
        "fullcodeline": "ipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)"
    },
    {
        "line": 65,
        "fullcodeline": "fl6.flowi6_oif = lsa->l2tp_scope_id;"
    },
    {
        "line": 67,
        "fullcodeline": "if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 88,
        "fullcodeline": "if ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {"
    },
    {
        "line": 89,
        "fullcodeline": "flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);"
    },
    {
        "line": 93,
        "fullcodeline": "if (!(opt->opt_nflen|opt->opt_flen))"
    },
    {
        "line": 94,
        "fullcodeline": "opt = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "else if (!fl6.flowi6_oif)"
    },
    {
        "line": 39,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 42,
        "fullcodeline": "return -EAFNOSUPPORT;"
    },
    {
        "line": 47,
        "fullcodeline": "if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (flowlabel == NULL)"
    },
    {
        "line": 118,
        "fullcodeline": "fl6.flowi6_oif = np->ucast_oif;"
    },
    {
        "line": 148,
        "fullcodeline": "else if (!(msg->msg_flags & MSG_MORE))"
    },
    {
        "line": 149,
        "fullcodeline": "err = l2tp_ip6_push_pending_frames(sk);"
    },
    {
        "line": 48,
        "fullcodeline": "flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);"
    },
    {
        "line": 68,
        "fullcodeline": "return -EDESTADDRREQ;"
    },
    {
        "line": 49,
        "fullcodeline": "if (flowlabel == NULL)"
    },
    {
        "line": 91,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 50,
        "fullcodeline": "return -EINVAL;"
    }
]