[
    {
        "line": 4,
        "fullcodeline": "struct udp_sock *up = udp_sk(sk);"
    },
    {
        "line": 5,
        "fullcodeline": "struct inet_sock *inet = inet_sk(sk);"
    },
    {
        "line": 6,
        "fullcodeline": "struct ipv6_pinfo *np = inet6_sk(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "struct ipv6_txoptions *opt = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "struct ip6_flowlabel *flowlabel = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "int addr_len = msg->msg_namelen;"
    },
    {
        "line": 14,
        "fullcodeline": "int ulen = len;"
    },
    {
        "line": 15,
        "fullcodeline": "int hlimit = -1;"
    },
    {
        "line": 16,
        "fullcodeline": "int tclass = -1;"
    },
    {
        "line": 17,
        "fullcodeline": "int dontfrag = -1;"
    },
    {
        "line": 18,
        "fullcodeline": "int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;"
    },
    {
        "line": 20,
        "fullcodeline": "int connected = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "int is_udplite = IS_UDPLITE(sk);"
    },
    {
        "line": 76,
        "fullcodeline": "getfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;"
    },
    {
        "line": 93,
        "fullcodeline": "ulen += sizeof(struct udphdr);"
    },
    {
        "line": 95,
        "fullcodeline": "memset(&fl6, 0, sizeof(fl6));"
    },
    {
        "line": 141,
        "fullcodeline": "fl6.flowi6_mark = sk->sk_mark;"
    },
    {
        "line": 167,
        "fullcodeline": "opt = ipv6_fixup_options(&opt_space, opt);"
    },
    {
        "line": 169,
        "fullcodeline": "fl6.flowi6_proto = sk->sk_protocol;"
    },
    {
        "line": 176,
        "fullcodeline": "fl6.fl6_sport = inet->inet_sport;"
    },
    {
        "line": 178,
        "fullcodeline": "final_p = fl6_update_dst(&fl6, opt, &final);"
    },
    {
        "line": 188,
        "fullcodeline": "security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));"
    },
    {
        "line": 190,
        "fullcodeline": "dst = ip6_sk_dst_lookup_flow(sk, &fl6, final_p);"
    },
    {
        "line": 221,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 232,
        "fullcodeline": "up->pending = AF_INET6;"
    },
    {
        "line": 237,
        "fullcodeline": "up->len += ulen;"
    },
    {
        "line": 238,
        "fullcodeline": "err = ip6_append_data(sk, getfrag, msg, ulen,"
    },
    {
        "line": 251,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 271,
        "fullcodeline": "dst_release(dst);"
    },
    {
        "line": 272,
        "fullcodeline": "fl6_sock_release(flowlabel);"
    },
    {
        "line": 289,
        "fullcodeline": "dst_confirm(dst);"
    },
    {
        "line": 292,
        "fullcodeline": "err = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "if (up->pending == AF_INET)"
    },
    {
        "line": 73,
        "fullcodeline": "if (len > INT_MAX - sizeof(struct udphdr))"
    },
    {
        "line": 135,
        "fullcodeline": "if (!fl6.flowi6_oif)"
    },
    {
        "line": 138,
        "fullcodeline": "if (!fl6.flowi6_oif)"
    },
    {
        "line": 163,
        "fullcodeline": "if (!opt)"
    },
    {
        "line": 170,
        "fullcodeline": "if (!ipv6_addr_any(daddr))"
    },
    {
        "line": 174,
        "fullcodeline": "if (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))"
    },
    {
        "line": 182,
        "fullcodeline": "if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) {"
    },
    {
        "line": 191,
        "fullcodeline": "if (IS_ERR(dst)) {"
    },
    {
        "line": 197,
        "fullcodeline": "if (hlimit < 0)"
    },
    {
        "line": 200,
        "fullcodeline": "if (tclass < 0)"
    },
    {
        "line": 203,
        "fullcodeline": "if (msg->msg_flags&MSG_CONFIRM)"
    },
    {
        "line": 208,
        "fullcodeline": "if (!corkreq) {"
    },
    {
        "line": 222,
        "fullcodeline": "if (unlikely(up->pending)) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (dontfrag < 0)"
    },
    {
        "line": 249,
        "fullcodeline": "if (err > 0)"
    },
    {
        "line": 273,
        "fullcodeline": "if (!err)"
    },
    {
        "line": 282,
        "fullcodeline": "if (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {"
    },
    {
        "line": 290,
        "fullcodeline": "if (!(msg->msg_flags&MSG_PROBE) || len)"
    },
    {
        "line": 82,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 91,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 101,
        "fullcodeline": "fl6.fl6_dport = sin6->sin6_port;"
    },
    {
        "line": 102,
        "fullcodeline": "daddr = &sin6->sin6_addr;"
    },
    {
        "line": 136,
        "fullcodeline": "fl6.flowi6_oif = sk->sk_bound_dev_if;"
    },
    {
        "line": 144,
        "fullcodeline": "opt = &opt_space;"
    },
    {
        "line": 145,
        "fullcodeline": "memset(opt, 0, sizeof(struct ipv6_txoptions));"
    },
    {
        "line": 148,
        "fullcodeline": "err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,"
    },
    {
        "line": 161,
        "fullcodeline": "connected = 0;"
    },
    {
        "line": 164,
        "fullcodeline": "opt = np->opt;"
    },
    {
        "line": 166,
        "fullcodeline": "opt = fl6_merge_options(&opt_space, flowlabel, opt);"
    },
    {
        "line": 175,
        "fullcodeline": "fl6.saddr = np->saddr;"
    },
    {
        "line": 180,
        "fullcodeline": "connected = 0;"
    },
    {
        "line": 183,
        "fullcodeline": "fl6.flowi6_oif = np->mcast_oif;"
    },
    {
        "line": 184,
        "fullcodeline": "connected = 0;"
    },
    {
        "line": 192,
        "fullcodeline": "err = PTR_ERR(dst);"
    },
    {
        "line": 193,
        "fullcodeline": "dst = NULL;"
    },
    {
        "line": 198,
        "fullcodeline": "hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);"
    },
    {
        "line": 201,
        "fullcodeline": "tclass = np->tclass;"
    },
    {
        "line": 211,
        "fullcodeline": "skb = ip6_make_skb(sk, getfrag, msg, ulen,"
    },
    {
        "line": 215,
        "fullcodeline": "err = PTR_ERR(skb);"
    },
    {
        "line": 225,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 227,
        "fullcodeline": "net_dbg_ratelimited(\"udp cork app bug 2\\n\");"
    },
    {
        "line": 228,
        "fullcodeline": "err = -EINVAL;"
    },
    {
        "line": 236,
        "fullcodeline": "dontfrag = np->dontfrag;"
    },
    {
        "line": 240,
        "fullcodeline": "(struct rt6_info *)dst,"
    },
    {
        "line": 241,
        "fullcodeline": "corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag);"
    },
    {
        "line": 243,
        "fullcodeline": "udp_v6_flush_pending_frames(sk);"
    },
    {
        "line": 250,
        "fullcodeline": "err = np->recverr ? net_xmit_errno(err) : 0;"
    },
    {
        "line": 267,
        "fullcodeline": "dst = NULL;"
    },
    {
        "line": 283,
        "fullcodeline": "UDP6_INC_STATS_USER(sock_net(sk),"
    },
    {
        "line": 53,
        "fullcodeline": "if (ipv6_addr_v4mapped(daddr)) {"
    },
    {
        "line": 68,
        "fullcodeline": "return udp_sendmsg(sk, msg, len);"
    },
    {
        "line": 74,
        "fullcodeline": "return -EMSGSIZE;"
    },
    {
        "line": 83,
        "fullcodeline": "if (likely(up->pending)) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (sin6->sin6_port == 0)"
    },
    {
        "line": 117,
        "fullcodeline": "if (sk->sk_state == TCP_ESTABLISHED &&"
    },
    {
        "line": 121,
        "fullcodeline": "if (addr_len >= sizeof(struct sockaddr_in6) &&"
    },
    {
        "line": 129,
        "fullcodeline": "fl6.fl6_dport = inet->inet_dport;"
    },
    {
        "line": 130,
        "fullcodeline": "daddr = &sk->sk_v6_daddr;"
    },
    {
        "line": 131,
        "fullcodeline": "fl6.flowlabel = np->flow_label;"
    },
    {
        "line": 132,
        "fullcodeline": "connected = 1;"
    },
    {
        "line": 150,
        "fullcodeline": "if (err < 0) {"
    },
    {
        "line": 154,
        "fullcodeline": "if ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (!(opt->opt_nflen|opt->opt_flen))"
    },
    {
        "line": 173,
        "fullcodeline": "fl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */"
    },
    {
        "line": 216,
        "fullcodeline": "if (!IS_ERR_OR_NULL(skb))"
    },
    {
        "line": 38,
        "fullcodeline": "msg->msg_name = sin6 = NULL;"
    },
    {
        "line": 39,
        "fullcodeline": "msg->msg_namelen = addr_len = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "daddr = NULL;"
    },
    {
        "line": 45,
        "fullcodeline": "} else if (!up->pending) {"
    },
    {
        "line": 55,
        "fullcodeline": "sin.sin_family = AF_INET;"
    },
    {
        "line": 56,
        "fullcodeline": "sin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;"
    },
    {
        "line": 58,
        "fullcodeline": "msg->msg_name = &sin;"
    },
    {
        "line": 88,
        "fullcodeline": "dst = NULL;"
    },
    {
        "line": 105,
        "fullcodeline": "fl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;"
    },
    {
        "line": 118,
        "fullcodeline": "ipv6_addr_equal(daddr, &sk->sk_v6_daddr))"
    },
    {
        "line": 119,
        "fullcodeline": "daddr = &sk->sk_v6_daddr;"
    },
    {
        "line": 123,
        "fullcodeline": "__ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))"
    },
    {
        "line": 124,
        "fullcodeline": "fl6.flowi6_oif = sin6->sin6_scope_id;"
    },
    {
        "line": 126,
        "fullcodeline": "if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 151,
        "fullcodeline": "fl6_sock_release(flowlabel);"
    },
    {
        "line": 155,
        "fullcodeline": "flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);"
    },
    {
        "line": 160,
        "fullcodeline": "opt = NULL;"
    },
    {
        "line": 185,
        "fullcodeline": "} else if (!fl6.flowi6_oif)"
    },
    {
        "line": 213,
        "fullcodeline": "&fl6, (struct rt6_info *)dst,"
    },
    {
        "line": 217,
        "fullcodeline": "err = udp_v6_send_skb(skb, &fl6);"
    },
    {
        "line": 244,
        "fullcodeline": "else if (!corkreq)"
    },
    {
        "line": 256,
        "fullcodeline": "ip6_dst_store(sk, dst,"
    },
    {
        "line": 27,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 31,
        "fullcodeline": "if (addr_len < SIN6_LEN_RFC2133)"
    },
    {
        "line": 43,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 48,
        "fullcodeline": "daddr = &sk->sk_v6_daddr;"
    },
    {
        "line": 61,
        "fullcodeline": "if (__ipv6_only_sock(sk))"
    },
    {
        "line": 63,
        "fullcodeline": "return udp_sendmsg(sk, msg, len);"
    },
    {
        "line": 84,
        "fullcodeline": "if (unlikely(up->pending != AF_INET6)) {"
    },
    {
        "line": 99,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 106,
        "fullcodeline": "if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {"
    },
    {
        "line": 156,
        "fullcodeline": "if (!flowlabel)"
    },
    {
        "line": 186,
        "fullcodeline": "fl6.flowi6_oif = np->ucast_oif;"
    },
    {
        "line": 245,
        "fullcodeline": "err = udp_v6_push_pending_frames(sk);"
    },
    {
        "line": 257,
        "fullcodeline": "ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?"
    },
    {
        "line": 265,
        "fullcodeline": "dst_release(dst);"
    },
    {
        "line": 46,
        "fullcodeline": "if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 50,
        "fullcodeline": "daddr = NULL;"
    },
    {
        "line": 85,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 107,
        "fullcodeline": "flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);"
    },
    {
        "line": 127,
        "fullcodeline": "return -EDESTADDRREQ;"
    },
    {
        "line": 32,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 62,
        "fullcodeline": "return -ENETUNREACH;"
    },
    {
        "line": 86,
        "fullcodeline": "return -EAFNOSUPPORT;"
    },
    {
        "line": 108,
        "fullcodeline": "if (!flowlabel)"
    },
    {
        "line": 157,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 246,
        "fullcodeline": "else if (unlikely(skb_queue_empty(&sk->sk_write_queue)))"
    },
    {
        "line": 47,
        "fullcodeline": "return -EDESTADDRREQ;"
    },
    {
        "line": 247,
        "fullcodeline": "up->pending = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "return -EINVAL;"
    }
]