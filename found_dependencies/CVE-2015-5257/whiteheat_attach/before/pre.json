[
    {
        "line": 12,
        "fullcodeline": "command_port = serial->port[COMMAND_PORT];"
    },
    {
        "line": 14,
        "fullcodeline": "pipe = usb_sndbulkpipe(serial->dev,"
    },
    {
        "line": 16,
        "fullcodeline": "command = kmalloc(2, GFP_KERNEL);"
    },
    {
        "line": 19,
        "fullcodeline": "command[0] = WHITEHEAT_GET_HW_INFO;"
    },
    {
        "line": 20,
        "fullcodeline": "command[1] = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "result = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);"
    },
    {
        "line": 30,
        "fullcodeline": "usb_clear_halt(serial->dev, pipe);"
    },
    {
        "line": 31,
        "fullcodeline": "ret = usb_bulk_msg(serial->dev, pipe, command, 2,"
    },
    {
        "line": 43,
        "fullcodeline": "pipe = usb_rcvbulkpipe(serial->dev,"
    },
    {
        "line": 46,
        "fullcodeline": "usb_clear_halt(serial->dev, pipe);"
    },
    {
        "line": 47,
        "fullcodeline": "ret = usb_bulk_msg(serial->dev, pipe, result,"
    },
    {
        "line": 63,
        "fullcodeline": "hw_info = (struct whiteheat_hw_info *)&result[1];"
    },
    {
        "line": 65,
        "fullcodeline": "dev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\","
    },
    {
        "line": 69,
        "fullcodeline": "command_info = kmalloc(sizeof(struct whiteheat_command_private),"
    },
    {
        "line": 74,
        "fullcodeline": "mutex_init(&command_info->mutex);"
    },
    {
        "line": 75,
        "fullcodeline": "command_info->port_running = 0;"
    },
    {
        "line": 76,
        "fullcodeline": "init_waitqueue_head(&command_info->wait_command);"
    },
    {
        "line": 77,
        "fullcodeline": "usb_set_serial_port_data(command_port, command_info);"
    },
    {
        "line": 78,
        "fullcodeline": "command_port->write_urb->complete = command_port_write_callback;"
    },
    {
        "line": 79,
        "fullcodeline": "command_port->read_urb->complete = command_port_read_callback;"
    },
    {
        "line": 80,
        "fullcodeline": "kfree(result);"
    },
    {
        "line": 81,
        "fullcodeline": "kfree(command);"
    },
    {
        "line": 87,
        "fullcodeline": "dev_err(&serial->dev->dev,"
    },
    {
        "line": 90,
        "fullcodeline": "dev_err(&serial->dev->dev,"
    },
    {
        "line": 17,
        "fullcodeline": "if (!command)"
    },
    {
        "line": 23,
        "fullcodeline": "if (!result)"
    },
    {
        "line": 71,
        "fullcodeline": "if (!command_info)"
    },
    {
        "line": 98,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 105,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 34,
        "fullcodeline": "dev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\","
    },
    {
        "line": 50,
        "fullcodeline": "dev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\","
    },
    {
        "line": 37,
        "fullcodeline": "} else if (alen != 2) {"
    },
    {
        "line": 53,
        "fullcodeline": "} else if (alen != sizeof(*hw_info) + 1) {"
    },
    {
        "line": 38,
        "fullcodeline": "dev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\","
    },
    {
        "line": 54,
        "fullcodeline": "dev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\","
    },
    {
        "line": 57,
        "fullcodeline": "} else if (result[0] != command[0]) {"
    },
    {
        "line": 58,
        "fullcodeline": "dev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\","
    }
]