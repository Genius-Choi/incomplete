[
    {
        "line": 4,
        "fullcodeline": "EXRContext *s = avctx->priv_data;"
    },
    {
        "line": 5,
        "fullcodeline": "ThreadFrame frame = { .f = data };"
    },
    {
        "line": 6,
        "fullcodeline": "AVFrame *picture = data;"
    },
    {
        "line": 17,
        "fullcodeline": "bytestream2_init(&s->gb, avpkt->data, avpkt->size);"
    },
    {
        "line": 94,
        "fullcodeline": "s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt);"
    },
    {
        "line": 154,
        "fullcodeline": "avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);"
    },
    {
        "line": 156,
        "fullcodeline": "ymax = FFMAX(0, s->ymax + 1);"
    },
    {
        "line": 166,
        "fullcodeline": "picture->pict_type = AV_PICTURE_TYPE_I;"
    },
    {
        "line": 19,
        "fullcodeline": "if ((ret = decode_header(s, picture)) < 0)"
    },
    {
        "line": 60,
        "fullcodeline": "if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED)"
    },
    {
        "line": 98,
        "fullcodeline": "if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks)"
    },
    {
        "line": 144,
        "fullcodeline": "for (i = 0; i < planes; i++) {"
    },
    {
        "line": 158,
        "fullcodeline": "for (i = 0; i < planes; i++) {"
    },
    {
        "line": 61,
        "fullcodeline": "avctx->color_trc = s->apply_trc_type;"
    },
    {
        "line": 67,
        "fullcodeline": "s->scan_lines_per_block = 1;"
    },
    {
        "line": 71,
        "fullcodeline": "s->scan_lines_per_block = 16;"
    },
    {
        "line": 76,
        "fullcodeline": "s->scan_lines_per_block = 32;"
    },
    {
        "line": 85,
        "fullcodeline": "if (s->xmin > s->xmax  || s->ymin > s->ymax ||"
    },
    {
        "line": 86,
        "fullcodeline": "s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) {"
    },
    {
        "line": 91,
        "fullcodeline": "if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0)"
    },
    {
        "line": 99,
        "fullcodeline": "planes           = s->desc->nb_components;"
    },
    {
        "line": 100,
        "fullcodeline": "out_line_size    = avctx->width * 4;"
    },
    {
        "line": 107,
        "fullcodeline": "nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) *"
    },
    {
        "line": 114,
        "fullcodeline": "if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)"
    },
    {
        "line": 121,
        "fullcodeline": "if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) {"
    },
    {
        "line": 122,
        "fullcodeline": "av_log(s->avctx, AV_LOG_DEBUG, \"recreating invalid scanline offset table\\n\");"
    },
    {
        "line": 124,
        "fullcodeline": "start_offset_table = bytestream2_tell(&s->gb);"
    },
    {
        "line": 125,
        "fullcodeline": "start_next_scanline = start_offset_table + nb_blocks * 8;"
    },
    {
        "line": 126,
        "fullcodeline": "bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8);"
    },
    {
        "line": 145,
        "fullcodeline": "ptr = picture->data[i];"
    },
    {
        "line": 159,
        "fullcodeline": "ptr = picture->data[i] + (ymax * picture->linesize[i]);"
    },
    {
        "line": 102,
        "fullcodeline": "planes           = 1;"
    },
    {
        "line": 103,
        "fullcodeline": "out_line_size    = avctx->width * 2 * s->desc->nb_components;"
    },
    {
        "line": 110,
        "fullcodeline": "nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) /"
    },
    {
        "line": 128,
        "fullcodeline": "for (y = 0; y < nb_blocks; y++) {"
    },
    {
        "line": 146,
        "fullcodeline": "for (y = 0; y < s->ymin; y++) {"
    },
    {
        "line": 160,
        "fullcodeline": "for (y = ymax; y < avctx->height; y++) {"
    },
    {
        "line": 108,
        "fullcodeline": "((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize);"
    },
    {
        "line": 130,
        "fullcodeline": "bytestream2_put_le64(&offset_table_writer, start_next_scanline);"
    },
    {
        "line": 133,
        "fullcodeline": "bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET);/* skip line number */"
    },
    {
        "line": 134,
        "fullcodeline": "start_next_scanline += (bytestream2_get_le32(&s->gb) + 8);"
    },
    {
        "line": 147,
        "fullcodeline": "memset(ptr, 0, out_line_size);"
    },
    {
        "line": 148,
        "fullcodeline": "ptr += picture->linesize[i];"
    },
    {
        "line": 161,
        "fullcodeline": "memset(ptr, 0, out_line_size);"
    },
    {
        "line": 162,
        "fullcodeline": "ptr += picture->linesize[i];"
    },
    {
        "line": 27,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;"
    },
    {
        "line": 43,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_RGBA64;"
    },
    {
        "line": 30,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_GBRAPF32;"
    },
    {
        "line": 34,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_GBRPF32;"
    },
    {
        "line": 45,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_YA16;"
    },
    {
        "line": 49,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_RGB48;"
    },
    {
        "line": 36,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_GRAYF32;"
    },
    {
        "line": 51,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_GRAY16;"
    }
]