[
    {
        "line": 3,
        "fullcodeline": "MXFPackage *material_package = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_TRACE, \"metadata sets count %d\\n\", mxf->metadata_sets_count);"
    },
    {
        "line": 17,
        "fullcodeline": "mxf_add_umid_metadata(&mxf->fc->metadata, \"material_package_umid\", material_package);"
    },
    {
        "line": 20,
        "fullcodeline": "mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);"
    },
    {
        "line": 393,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "for (i = 0; i < mxf->packages_count; i++) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (!material_package) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (material_package->name && material_package->name[0])"
    },
    {
        "line": 22,
        "fullcodeline": "for (i = 0; i < material_package->tracks_count; i++) {"
    },
    {
        "line": 9,
        "fullcodeline": "material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);"
    },
    {
        "line": 13,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"no material package found\\n\");"
    },
    {
        "line": 19,
        "fullcodeline": "av_dict_set(&mxf->fc->metadata, \"material_package_name\", material_package->name, 0);"
    },
    {
        "line": 23,
        "fullcodeline": "MXFPackage *source_package = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "MXFTrack *material_track = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "MXFTrack *source_track = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "MXFTrack *temp_track = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "MXFDescriptor *descriptor = NULL;"
    },
    {
        "line": 28,
        "fullcodeline": "MXFStructuralComponent *component = NULL;"
    },
    {
        "line": 29,
        "fullcodeline": "MXFTimecodeComponent *mxf_tc = NULL;"
    },
    {
        "line": 30,
        "fullcodeline": "UID *essence_container_ul = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "const MXFCodecUL *codec_ul = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "const MXFCodecUL *container_ul = NULL;"
    },
    {
        "line": 33,
        "fullcodeline": "const MXFCodecUL *pix_fmt_ul = NULL;"
    },
    {
        "line": 136,
        "fullcodeline": "st = avformat_new_stream(mxf->fc, NULL);"
    },
    {
        "line": 142,
        "fullcodeline": "st->id = material_track->track_id;"
    },
    {
        "line": 143,
        "fullcodeline": "st->priv_data = source_track;"
    },
    {
        "line": 145,
        "fullcodeline": "source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);"
    },
    {
        "line": 146,
        "fullcodeline": "descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);"
    },
    {
        "line": 157,
        "fullcodeline": "st->start_time = component->start_position;"
    },
    {
        "line": 167,
        "fullcodeline": "avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);"
    },
    {
        "line": 171,
        "fullcodeline": "source_track->edit_rate = material_track->edit_rate;"
    },
    {
        "line": 173,
        "fullcodeline": "PRINT_KEY(mxf->fc, \"data definition   ul\", source_track->sequence->data_definition_ul);"
    },
    {
        "line": 174,
        "fullcodeline": "codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);"
    },
    {
        "line": 175,
        "fullcodeline": "st->codecpar->codec_type = codec_ul->id;"
    },
    {
        "line": 181,
        "fullcodeline": "PRINT_KEY(mxf->fc, \"essence codec     ul\", descriptor->essence_codec_ul);"
    },
    {
        "line": 182,
        "fullcodeline": "PRINT_KEY(mxf->fc, \"essence container ul\", descriptor->essence_container_ul);"
    },
    {
        "line": 183,
        "fullcodeline": "essence_container_ul = &descriptor->essence_container_ul;"
    },
    {
        "line": 184,
        "fullcodeline": "source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);"
    },
    {
        "line": 201,
        "fullcodeline": "codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);"
    },
    {
        "line": 202,
        "fullcodeline": "st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;"
    },
    {
        "line": 208,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_VERBOSE, \"%s: Universal Label: \","
    },
    {
        "line": 216,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_VERBOSE, \"\\n\");"
    },
    {
        "line": 218,
        "fullcodeline": "mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", source_package);"
    },
    {
        "line": 224,
        "fullcodeline": "mxf_parse_physical_source_package(mxf, source_track, st);"
    },
    {
        "line": 38,
        "fullcodeline": "if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {"
    },
    {
        "line": 43,
        "fullcodeline": "if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {"
    },
    {
        "line": 56,
        "fullcodeline": "for (j = 0; j < material_track->sequence->structural_components_count; j++) {"
    },
    {
        "line": 70,
        "fullcodeline": "if(material_track->sequence->structural_components_count > 1)"
    },
    {
        "line": 74,
        "fullcodeline": "for (j = 0; j < material_track->sequence->structural_components_count; j++) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (!source_track || !component || !source_package) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (!st) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (descriptor && descriptor->duration != AV_NOPTS_VALUE)"
    },
    {
        "line": 155,
        "fullcodeline": "if (st->duration == -1)"
    },
    {
        "line": 158,
        "fullcodeline": "if (material_track->edit_rate.num <= 0 ||"
    },
    {
        "line": 177,
        "fullcodeline": "if (!descriptor) {"
    },
    {
        "line": 185,
        "fullcodeline": "if (source_track->wrapping == UnknownWrapped)"
    },
    {
        "line": 189,
        "fullcodeline": "if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {"
    },
    {
        "line": 203,
        "fullcodeline": "if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {"
    },
    {
        "line": 209,
        "fullcodeline": "avcodec_get_name(st->codecpar->codec_id));"
    },
    {
        "line": 210,
        "fullcodeline": "for (k = 0; k < 16; k++) {"
    },
    {
        "line": 219,
        "fullcodeline": "if (source_package->name && source_package->name[0])"
    },
    {
        "line": 221,
        "fullcodeline": "if (material_track->name && material_track->name[0])"
    },
    {
        "line": 226,
        "fullcodeline": "if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {"
    },
    {
        "line": 387,
        "fullcodeline": "if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {"
    },
    {
        "line": 39,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track strong ref\\n\");"
    },
    {
        "line": 44,
        "fullcodeline": "mxf_tc = (MXFTimecodeComponent*)component;"
    },
    {
        "line": 45,
        "fullcodeline": "flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;"
    },
    {
        "line": 52,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track sequence strong ref\\n\");"
    },
    {
        "line": 57,
        "fullcodeline": "component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);"
    },
    {
        "line": 61,
        "fullcodeline": "mxf_tc = (MXFTimecodeComponent*)component;"
    },
    {
        "line": 62,
        "fullcodeline": "flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;"
    },
    {
        "line": 71,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_WARNING, \"material track %d: has %d components\\n\","
    },
    {
        "line": 75,
        "fullcodeline": "component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);"
    },
    {
        "line": 79,
        "fullcodeline": "source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);"
    },
    {
        "line": 124,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");"
    },
    {
        "line": 125,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 132,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: DataDefinition mismatch\\n\", material_track->track_id);"
    },
    {
        "line": 138,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate stream\\n\");"
    },
    {
        "line": 139,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    },
    {
        "line": 151,
        "fullcodeline": "source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);"
    },
    {
        "line": 156,
        "fullcodeline": "st->duration = AV_NOPTS_VALUE;"
    },
    {
        "line": 159,
        "fullcodeline": "material_track->edit_rate.den <= 0) {"
    },
    {
        "line": 160,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_WARNING,"
    },
    {
        "line": 165,
        "fullcodeline": "material_track->edit_rate = (AVRational){25, 1};"
    },
    {
        "line": 178,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_INFO, \"source track %d: stream %d, no descriptor found\\n\", source_track->track_id, st->index);"
    },
    {
        "line": 186,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_INFO, \"wrapping of stream %d is unknown\\n\", st->index);"
    },
    {
        "line": 190,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_INFO, \"broken encrypted mxf file\\n\");"
    },
    {
        "line": 204,
        "fullcodeline": "codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);"
    },
    {
        "line": 205,
        "fullcodeline": "st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;"
    },
    {
        "line": 211,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_VERBOSE, \"%.2x\","
    },
    {
        "line": 220,
        "fullcodeline": "av_dict_set(&st->metadata, \"file_package_name\", source_package->name, 0);"
    },
    {
        "line": 222,
        "fullcodeline": "av_dict_set(&st->metadata, \"track_name\", material_track->name, 0);"
    },
    {
        "line": 227,
        "fullcodeline": "source_track->intra_only = mxf_is_intra_only(descriptor);"
    },
    {
        "line": 228,
        "fullcodeline": "container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);"
    },
    {
        "line": 231,
        "fullcodeline": "st->codecpar->width = descriptor->width;"
    },
    {
        "line": 232,
        "fullcodeline": "st->codecpar->height = descriptor->height; /* Field height, not frame height */"
    },
    {
        "line": 315,
        "fullcodeline": "st->need_parsing = AVSTREAM_PARSE_HEADERS;"
    },
    {
        "line": 389,
        "fullcodeline": "st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;"
    },
    {
        "line": 46,
        "fullcodeline": "if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (!component)"
    },
    {
        "line": 63,
        "fullcodeline": "if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (!component)"
    },
    {
        "line": 80,
        "fullcodeline": "if (!source_package) {"
    },
    {
        "line": 84,
        "fullcodeline": "for (k = 0; k < source_package->tracks_count; k++) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (!source_track) {"
    },
    {
        "line": 100,
        "fullcodeline": "for (k = 0; k < mxf->essence_container_data_count; k++) {"
    },
    {
        "line": 114,
        "fullcodeline": "if(source_track && component)"
    },
    {
        "line": 118,
        "fullcodeline": "if((ret = mxf_add_metadata_stream(mxf, material_track)))"
    },
    {
        "line": 153,
        "fullcodeline": "source_track->original_duration = st->duration = component->duration;"
    },
    {
        "line": 191,
        "fullcodeline": "for (k = 0; k < mxf->metadata_sets_count; k++) {"
    },
    {
        "line": 213,
        "fullcodeline": "if (!(k+1 & 19) || k == 5)"
    },
    {
        "line": 229,
        "fullcodeline": "if (st->codecpar->codec_id == AV_CODEC_ID_NONE)"
    },
    {
        "line": 294,
        "fullcodeline": "if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {"
    },
    {
        "line": 375,
        "fullcodeline": "if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {"
    },
    {
        "line": 47,
        "fullcodeline": "mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);"
    },
    {
        "line": 64,
        "fullcodeline": "mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);"
    },
    {
        "line": 81,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_TRACE, \"material track %d: no corresponding source package found\\n\", material_track->track_id);"
    },
    {
        "line": 96,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);"
    },
    {
        "line": 214,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_VERBOSE, \".\");"
    },
    {
        "line": 230,
        "fullcodeline": "st->codecpar->codec_id = container_ul->id;"
    },
    {
        "line": 235,
        "fullcodeline": "st->codecpar->field_order = AV_FIELD_PROGRESSIVE;"
    },
    {
        "line": 239,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_INFO, \"OneField frame layout isn't currently supported\\n\");"
    },
    {
        "line": 246,
        "fullcodeline": "st->codecpar->field_order = AV_FIELD_PROGRESSIVE;"
    },
    {
        "line": 248,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_DEBUG, \"video_line_map: (%d, %d), field_dominance: %d\\n\","
    },
    {
        "line": 289,
        "fullcodeline": "st->codecpar->height *= 2;"
    },
    {
        "line": 292,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_INFO, \"Unknown frame layout type: %d\\n\", descriptor->frame_layout);"
    },
    {
        "line": 295,
        "fullcodeline": "st->codecpar->format = descriptor->pix_fmt;"
    },
    {
        "line": 317,
        "fullcodeline": "av_dict_set_int(&st->metadata, \"material_track_origin\", material_track->sequence->origin, 0);"
    },
    {
        "line": 320,
        "fullcodeline": "av_dict_set_int(&st->metadata, \"source_track_origin\", source_track->sequence->origin, 0);"
    },
    {
        "line": 323,
        "fullcodeline": "st->display_aspect_ratio = descriptor->aspect_ratio;"
    },
    {
        "line": 324,
        "fullcodeline": "} else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {"
    },
    {
        "line": 376,
        "fullcodeline": "memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);"
    },
    {
        "line": 378,
        "fullcodeline": "} else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (temp_track->track_id == component->source_track_id) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {"
    },
    {
        "line": 107,
        "fullcodeline": "if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {"
    },
    {
        "line": 193,
        "fullcodeline": "if (metadata->type == CryptoContext) {"
    },
    {
        "line": 251,
        "fullcodeline": "if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {"
    },
    {
        "line": 296,
        "fullcodeline": "if (st->codecpar->format == AV_PIX_FMT_NONE) {"
    },
    {
        "line": 325,
        "fullcodeline": "container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);"
    },
    {
        "line": 329,
        "fullcodeline": "st->codecpar->channels = descriptor->channels;"
    },
    {
        "line": 330,
        "fullcodeline": "st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;"
    },
    {
        "line": 383,
        "fullcodeline": "ret = ff_generate_avci_extradata(st);"
    },
    {
        "line": 86,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");"
    },
    {
        "line": 87,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 91,
        "fullcodeline": "source_track = temp_track;"
    },
    {
        "line": 104,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");"
    },
    {
        "line": 108,
        "fullcodeline": "source_track->body_sid = essence_data->body_sid;"
    },
    {
        "line": 109,
        "fullcodeline": "source_track->index_sid = essence_data->index_sid;"
    },
    {
        "line": 297,
        "fullcodeline": "pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,"
    },
    {
        "line": 299,
        "fullcodeline": "st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;"
    },
    {
        "line": 327,
        "fullcodeline": "if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))"
    },
    {
        "line": 332,
        "fullcodeline": "if (descriptor->sample_rate.den > 0) {"
    },
    {
        "line": 344,
        "fullcodeline": "if (st->duration != AV_NOPTS_VALUE)"
    },
    {
        "line": 350,
        "fullcodeline": "if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {"
    },
    {
        "line": 384,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 258,
        "fullcodeline": "if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {"
    },
    {
        "line": 300,
        "fullcodeline": "if (st->codecpar->format== AV_PIX_FMT_NONE) {"
    },
    {
        "line": 328,
        "fullcodeline": "st->codecpar->codec_id = (enum AVCodecID)container_ul->id;"
    },
    {
        "line": 333,
        "fullcodeline": "st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;"
    },
    {
        "line": 334,
        "fullcodeline": "avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);"
    },
    {
        "line": 345,
        "fullcodeline": "st->duration = av_rescale_q(st->duration,"
    },
    {
        "line": 363,
        "fullcodeline": "} else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {"
    },
    {
        "line": 379,
        "fullcodeline": "int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,"
    },
    {
        "line": 382,
        "fullcodeline": "st->codecpar->width = coded_width;"
    },
    {
        "line": 336,
        "fullcodeline": "av_log(mxf->fc, AV_LOG_WARNING, \"invalid sample rate (%d/%d) \""
    },
    {
        "line": 340,
        "fullcodeline": "avpriv_set_pts_info(st, 64, 1, 48000);"
    },
    {
        "line": 351,
        "fullcodeline": "if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)"
    },
    {
        "line": 365,
        "fullcodeline": "container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);"
    },
    {
        "line": 368,
        "fullcodeline": "type = avcodec_get_type(st->codecpar->codec_id);"
    },
    {
        "line": 194,
        "fullcodeline": "essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;"
    },
    {
        "line": 303,
        "fullcodeline": "if (!st->codecpar->codec_tag) {"
    },
    {
        "line": 346,
        "fullcodeline": "av_inv_q(material_track->edit_rate),"
    },
    {
        "line": 352,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;"
    },
    {
        "line": 355,
        "fullcodeline": "} else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {"
    },
    {
        "line": 366,
        "fullcodeline": "if (st->codecpar->codec_id == AV_CODEC_ID_NONE)"
    },
    {
        "line": 369,
        "fullcodeline": "if (type == AVMEDIA_TYPE_SUBTITLE)"
    },
    {
        "line": 262,
        "fullcodeline": "st->codecpar->field_order = AV_FIELD_TT;"
    },
    {
        "line": 265,
        "fullcodeline": "st->codecpar->field_order = AV_FIELD_TB;"
    },
    {
        "line": 268,
        "fullcodeline": "avpriv_request_sample(mxf->fc,"
    },
    {
        "line": 301,
        "fullcodeline": "st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,"
    },
    {
        "line": 367,
        "fullcodeline": "st->codecpar->codec_id = container_ul->id;"
    },
    {
        "line": 370,
        "fullcodeline": "st->codecpar->codec_type = type;"
    },
    {
        "line": 372,
        "fullcodeline": "av_dict_set(&st->metadata, \"data_type\", container_ul->desc, 0);"
    },
    {
        "line": 276,
        "fullcodeline": "st->codecpar->field_order = AV_FIELD_BB;"
    },
    {
        "line": 279,
        "fullcodeline": "st->codecpar->field_order = AV_FIELD_BT;"
    },
    {
        "line": 282,
        "fullcodeline": "avpriv_request_sample(mxf->fc,"
    },
    {
        "line": 306,
        "fullcodeline": "if (descriptor->horiz_subsampling == 2 &&"
    },
    {
        "line": 353,
        "fullcodeline": "else if (descriptor->bits_per_sample == 32)"
    },
    {
        "line": 356,
        "fullcodeline": "if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)"
    },
    {
        "line": 308,
        "fullcodeline": "descriptor->component_depth == 8) {"
    },
    {
        "line": 309,
        "fullcodeline": "st->codecpar->format = AV_PIX_FMT_UYVY422;"
    },
    {
        "line": 354,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;"
    },
    {
        "line": 357,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;"
    },
    {
        "line": 360,
        "fullcodeline": "} else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {"
    },
    {
        "line": 307,
        "fullcodeline": "descriptor->vert_subsampling == 1 &&"
    },
    {
        "line": 361,
        "fullcodeline": "st->need_parsing = AVSTREAM_PARSE_FULL;"
    },
    {
        "line": 358,
        "fullcodeline": "else if (descriptor->bits_per_sample == 32)"
    },
    {
        "line": 359,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;"
    }
]