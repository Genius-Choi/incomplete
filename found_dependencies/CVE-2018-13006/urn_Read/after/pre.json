[
    {
        "line": 5,
        "fullcodeline": "GF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;"
    },
    {
        "line": 9,
        "fullcodeline": "to_read = (u32) ptr->size;"
    },
    {
        "line": 10,
        "fullcodeline": "tmpName = (char*)gf_malloc(sizeof(char) * to_read);"
    },
    {
        "line": 13,
        "fullcodeline": "gf_bs_read_data(bs, tmpName, to_read);"
    },
    {
        "line": 16,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "ptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));"
    },
    {
        "line": 37,
        "fullcodeline": "ptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));"
    },
    {
        "line": 44,
        "fullcodeline": "memcpy(ptr->nameURN, tmpName, i + 1);"
    },
    {
        "line": 6,
        "fullcodeline": "if (! ptr->size ) return GF_OK;"
    },
    {
        "line": 11,
        "fullcodeline": "if (!tmpName) return GF_OUT_OF_MEM;"
    },
    {
        "line": 21,
        "fullcodeline": "if (i == to_read) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (i == to_read - 1) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (!ptr->nameURN) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (!ptr->location) {"
    },
    {
        "line": 45,
        "fullcodeline": "memcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));"
    },
    {
        "line": 17,
        "fullcodeline": "while ( (i < to_read) && (tmpName[i] != 0) ) {"
    },
    {
        "line": 18,
        "fullcodeline": "i++;"
    }
]