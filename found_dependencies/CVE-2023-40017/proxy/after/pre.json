[
    {
        "line": 14,
        "fullcodeline": "from geonode.geoserver.helpers import ogc_server_settings"
    },
    {
        "line": 20,
        "fullcodeline": "PROXY_ALLOWED_HOSTS = getattr(settings, \"PROXY_ALLOWED_HOSTS\", ())"
    },
    {
        "line": 28,
        "fullcodeline": "raw_url = url or request.GET[\"url\"]"
    },
    {
        "line": 29,
        "fullcodeline": "raw_url = urljoin(settings.SITEURL, raw_url) if raw_url.startswith(\"/\") else raw_url"
    },
    {
        "line": 30,
        "fullcodeline": "url = urlsplit(raw_url)"
    },
    {
        "line": 31,
        "fullcodeline": "scheme = str(url.scheme)"
    },
    {
        "line": 32,
        "fullcodeline": "locator = str(url.path)"
    },
    {
        "line": 39,
        "fullcodeline": "site_url = urlsplit(settings.SITEURL)"
    },
    {
        "line": 95,
        "fullcodeline": "user = get_auth_user(access_token)"
    },
    {
        "line": 98,
        "fullcodeline": "parsed = urlparse(raw_url)"
    },
    {
        "line": 99,
        "fullcodeline": "parsed._replace(path=locator.encode(\"utf8\"))"
    },
    {
        "line": 103,
        "fullcodeline": "_url = parsed.geturl()"
    },
    {
        "line": 110,
        "fullcodeline": "_url = URL.from_text(_url).normalize().to_text()"
    },
    {
        "line": 116,
        "fullcodeline": "_data = request.body.decode(\"utf-8\")"
    },
    {
        "line": 130,
        "fullcodeline": "content = response.content or response.reason"
    },
    {
        "line": 131,
        "fullcodeline": "status = response.status_code"
    },
    {
        "line": 132,
        "fullcodeline": "response_headers = response.headers"
    },
    {
        "line": 133,
        "fullcodeline": "content_type = response.headers.get(\"Content-Type\")"
    },
    {
        "line": 147,
        "fullcodeline": "PLAIN_CONTENT_TYPES = [\"text\", \"plain\", \"html\", \"json\", \"xml\", \"gml\"]"
    },
    {
        "line": 16,
        "fullcodeline": "if not timeout:"
    },
    {
        "line": 23,
        "fullcodeline": "if \"url\" not in request.GET and not url:"
    },
    {
        "line": 33,
        "fullcodeline": "if url.query != \"\":"
    },
    {
        "line": 35,
        "fullcodeline": "if url.fragment != \"\":"
    },
    {
        "line": 85,
        "fullcodeline": "if not headers:"
    },
    {
        "line": 87,
        "fullcodeline": "if not access_token:"
    },
    {
        "line": 112,
        "fullcodeline": "if request.method == \"GET\" and access_token and \"access_token\" not in _url:"
    },
    {
        "line": 119,
        "fullcodeline": "if check_ogc_backend(geoserver.BACKEND_PACKAGE):"
    },
    {
        "line": 125,
        "fullcodeline": "response, content = http_client.request("
    },
    {
        "line": 128,
        "fullcodeline": "if response is None:"
    },
    {
        "line": 135,
        "fullcodeline": "if status >= 400:"
    },
    {
        "line": 141,
        "fullcodeline": "if content and content_type and content_type == \"gzip\":"
    },
    {
        "line": 148,
        "fullcodeline": "for _ct in PLAIN_CONTENT_TYPES:"
    },
    {
        "line": 156,
        "fullcodeline": "if response and response_callback:"
    },
    {
        "line": 17,
        "fullcodeline": "timeout = getattr(ogc_server_settings, \"TIMEOUT\", TIMEOUT)"
    },
    {
        "line": 34,
        "fullcodeline": "locator += f\"?{url.query}\""
    },
    {
        "line": 36,
        "fullcodeline": "locator += f\"#{url.fragment}\""
    },
    {
        "line": 40,
        "fullcodeline": "if sec_chk_hosts and not settings.DEBUG:"
    },
    {
        "line": 46,
        "fullcodeline": "hostname = (ogc_server_settings.hostname,) if ogc_server_settings else ()"
    },
    {
        "line": 65,
        "fullcodeline": "from geonode.services.models import Service"
    },
    {
        "line": 88,
        "fullcodeline": "auth_header = None"
    },
    {
        "line": 100,
        "fullcodeline": "if parsed.netloc == site_url.netloc and scheme != site_url.scheme:"
    },
    {
        "line": 101,
        "fullcodeline": "parsed = parsed._replace(scheme=site_url.scheme)"
    },
    {
        "line": 113,
        "fullcodeline": "query_separator = \"&\" if \"?\" in _url else \"?\""
    },
    {
        "line": 114,
        "fullcodeline": "_url = f\"{_url}{query_separator}access_token={access_token}\""
    },
    {
        "line": 120,
        "fullcodeline": "from geonode.geoserver.helpers import ogc_server_settings"
    },
    {
        "line": 122,
        "fullcodeline": "_url = _url.replace(f\"{settings.SITEURL}geoserver\", ogc_server_settings.LOCATION.rstrip(\"/\"))"
    },
    {
        "line": 123,
        "fullcodeline": "_data = _data.replace(f\"{settings.SITEURL}geoserver\", ogc_server_settings.LOCATION.rstrip(\"/\"))"
    },
    {
        "line": 136,
        "fullcodeline": "_response = HttpResponse(content=content, reason=content, status=status, content_type=content_type)"
    },
    {
        "line": 142,
        "fullcodeline": "buf = io.BytesIO(content)"
    },
    {
        "line": 157,
        "fullcodeline": "kwargs = {} if not kwargs else kwargs"
    },
    {
        "line": 24,
        "fullcodeline": "return HttpResponse("
    },
    {
        "line": 42,
        "fullcodeline": "if site_url.hostname not in PROXY_ALLOWED_HOSTS:"
    },
    {
        "line": 47,
        "fullcodeline": "if hostname not in PROXY_ALLOWED_HOSTS:"
    },
    {
        "line": 51,
        "fullcodeline": "if url.query and ows_regexp.match(url.query):"
    },
    {
        "line": 67,
        "fullcodeline": "for _s in Service.objects.all():"
    },
    {
        "line": 86,
        "fullcodeline": "headers, access_token = get_headers(request, url, raw_url, allowed_hosts=allowed_hosts)"
    },
    {
        "line": 89,
        "fullcodeline": "if \"Authorization\" in headers:"
    },
    {
        "line": 126,
        "fullcodeline": "_url, method=request.method, data=_data.encode(\"utf-8\"), headers=headers, timeout=timeout, user=user"
    },
    {
        "line": 129,
        "fullcodeline": "return HttpResponse(content=content, reason=content, status=500)"
    },
    {
        "line": 137,
        "fullcodeline": "return fetch_response_headers(_response, response_headers)"
    },
    {
        "line": 143,
        "fullcodeline": "with gzip.GzipFile(fileobj=buf) as f:"
    },
    {
        "line": 167,
        "fullcodeline": "return response_callback(**kwargs)"
    },
    {
        "line": 170,
        "fullcodeline": "if status and status in (301, 302, 303, 307):"
    },
    {
        "line": 43,
        "fullcodeline": "PROXY_ALLOWED_HOSTS += (site_url.hostname,)"
    },
    {
        "line": 48,
        "fullcodeline": "PROXY_ALLOWED_HOSTS += hostname"
    },
    {
        "line": 52,
        "fullcodeline": "ows_tokens = ows_regexp.match(url.query).groups()"
    },
    {
        "line": 71,
        "fullcodeline": "if not validate_host(extract_ip_or_domain(raw_url), PROXY_ALLOWED_HOSTS):"
    },
    {
        "line": 90,
        "fullcodeline": "auth_header = headers[\"Authorization\"]"
    },
    {
        "line": 94,
        "fullcodeline": "access_token = get_token_from_auth_header(auth_header, create_if_not_exists=True)"
    },
    {
        "line": 149,
        "fullcodeline": "if content_type and _ct in content_type and not isinstance(content, str):"
    },
    {
        "line": 159,
        "fullcodeline": "{"
    },
    {
        "line": 171,
        "fullcodeline": "_response = HttpResponse("
    },
    {
        "line": 179,
        "fullcodeline": "_response[\"Location\"] = response.getheader(\"Location\")"
    },
    {
        "line": 193,
        "fullcodeline": "_response = HttpResponse("
    },
    {
        "line": 68,
        "fullcodeline": "_remote_host = urlsplit(_s.base_url).hostname"
    },
    {
        "line": 69,
        "fullcodeline": "PROXY_ALLOWED_HOSTS += (_remote_host,)"
    },
    {
        "line": 72,
        "fullcodeline": "return HttpResponse("
    },
    {
        "line": 91,
        "fullcodeline": "elif \"HTTP_AUTHORIZATION\" in request.META:"
    },
    {
        "line": 144,
        "fullcodeline": "content = f.read()"
    },
    {
        "line": 180,
        "fullcodeline": "return fetch_response_headers(_response, response_headers)"
    },
    {
        "line": 199,
        "fullcodeline": "return fetch_response_headers(_response, response_headers)"
    },
    {
        "line": 54,
        "fullcodeline": "len(ows_tokens) == 4"
    },
    {
        "line": 55,
        "fullcodeline": "and \"version\" == ows_tokens[0]"
    },
    {
        "line": 73,
        "fullcodeline": "\"DEBUG is set to False but the host of the path provided to the proxy service\""
    },
    {
        "line": 92,
        "fullcodeline": "auth_header = request.META.get(\"HTTP_AUTHORIZATION\", request.META.get(\"HTTP_AUTHORIZATION2\"))"
    },
    {
        "line": 173,
        "fullcodeline": "f\"This proxy does not support redirects. The server in '{url}' \""
    },
    {
        "line": 61,
        "fullcodeline": "if url.hostname not in PROXY_ALLOWED_HOSTS:"
    },
    {
        "line": 151,
        "fullcodeline": "content = content.decode()"
    },
    {
        "line": 174,
        "fullcodeline": "f\"asked for a redirect to '{response.getheader('Location')}'\""
    },
    {
        "line": 195,
        "fullcodeline": "reason=_get_message(content) if status not in (200, 201) else None,"
    },
    {
        "line": 62,
        "fullcodeline": "PROXY_ALLOWED_HOSTS += (url.hostname,)"
    }
]