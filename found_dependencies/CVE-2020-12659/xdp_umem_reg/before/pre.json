[
    {
        "line": 3,
        "fullcodeline": "bool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;"
    },
    {
        "line": 4,
        "fullcodeline": "u32 chunk_size = mr->chunk_size, headroom = mr->headroom;"
    },
    {
        "line": 6,
        "fullcodeline": "u64 addr = mr->addr, size = mr->len;"
    },
    {
        "line": 36,
        "fullcodeline": "chunks = (unsigned int)div_u64(size, chunk_size);"
    },
    {
        "line": 46,
        "fullcodeline": "size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;"
    },
    {
        "line": 50,
        "fullcodeline": "umem->address = (unsigned long)addr;"
    },
    {
        "line": 51,
        "fullcodeline": "umem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK"
    },
    {
        "line": 53,
        "fullcodeline": "umem->size = size;"
    },
    {
        "line": 54,
        "fullcodeline": "umem->headroom = headroom;"
    },
    {
        "line": 55,
        "fullcodeline": "umem->chunk_size_nohr = chunk_size - headroom;"
    },
    {
        "line": 56,
        "fullcodeline": "umem->npgs = size / PAGE_SIZE;"
    },
    {
        "line": 57,
        "fullcodeline": "umem->pgs = NULL;"
    },
    {
        "line": 58,
        "fullcodeline": "umem->user = NULL;"
    },
    {
        "line": 59,
        "fullcodeline": "umem->flags = mr->flags;"
    },
    {
        "line": 65,
        "fullcodeline": "err = xdp_umem_account_pages(umem);"
    },
    {
        "line": 69,
        "fullcodeline": "err = xdp_umem_pin_pages(umem);"
    },
    {
        "line": 73,
        "fullcodeline": "umem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),"
    },
    {
        "line": 80,
        "fullcodeline": "err = xdp_umem_map_pages(umem);"
    },
    {
        "line": 84,
        "fullcodeline": "kvfree(umem->pages);"
    },
    {
        "line": 87,
        "fullcodeline": "xdp_umem_unpin_pages(umem);"
    },
    {
        "line": 9,
        "fullcodeline": "if (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |"
    },
    {
        "line": 33,
        "fullcodeline": "if ((addr + size) < addr)"
    },
    {
        "line": 37,
        "fullcodeline": "if (chunks == 0)"
    },
    {
        "line": 75,
        "fullcodeline": "if (!umem->pages) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (!err)"
    },
    {
        "line": 23,
        "fullcodeline": "if (!unaligned_chunks && !is_power_of_2(chunk_size))"
    },
    {
        "line": 26,
        "fullcodeline": "if (!PAGE_ALIGNED(addr)) {"
    },
    {
        "line": 41,
        "fullcodeline": "chunks_per_page = PAGE_SIZE / chunk_size;"
    },
    {
        "line": 52,
        "fullcodeline": ": ~((u64)chunk_size - 1);"
    },
    {
        "line": 76,
        "fullcodeline": "err = -ENOMEM;"
    },
    {
        "line": 16,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 21,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 24,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 30,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 34,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 38,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 48,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 42,
        "fullcodeline": "if (chunks < chunks_per_page || chunks % chunks_per_page)"
    },
    {
        "line": 43,
        "fullcodeline": "return -EINVAL;"
    }
]