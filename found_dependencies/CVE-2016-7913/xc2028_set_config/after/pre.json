[
    {
        "line": 3,
        "fullcodeline": "struct xc2028_data *priv = fe->tuner_priv;"
    },
    {
        "line": 4,
        "fullcodeline": "struct xc2028_ctrl *p    = priv_cfg;"
    },
    {
        "line": 5,
        "fullcodeline": "int                 rc   = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "tuner_dbg(\"%s called\\n\", __func__);"
    },
    {
        "line": 9,
        "fullcodeline": "mutex_lock(&priv->lock);"
    },
    {
        "line": 16,
        "fullcodeline": "kfree(priv->ctrl.fname);"
    },
    {
        "line": 17,
        "fullcodeline": "priv->ctrl.fname = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "memcpy(&priv->ctrl, p, sizeof(priv->ctrl));"
    },
    {
        "line": 36,
        "fullcodeline": "if (priv->state == XC2028_NO_FIRMWARE) {"
    },
    {
        "line": 20,
        "fullcodeline": "priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);"
    },
    {
        "line": 29,
        "fullcodeline": "if (!firmware_name[0] && p->fname &&"
    },
    {
        "line": 30,
        "fullcodeline": "priv->fname && strcmp(p->fname, priv->fname))"
    },
    {
        "line": 31,
        "fullcodeline": "free_firmware(priv);"
    },
    {
        "line": 42,
        "fullcodeline": "rc = request_firmware_nowait(THIS_MODULE, 1,"
    },
    {
        "line": 21,
        "fullcodeline": "if (priv->ctrl.fname == NULL)"
    },
    {
        "line": 37,
        "fullcodeline": "if (!firmware_name[0])"
    },
    {
        "line": 47,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 38,
        "fullcodeline": "priv->fname = priv->ctrl.fname;"
    },
    {
        "line": 50,
        "fullcodeline": "priv->state = XC2028_NODEV;"
    },
    {
        "line": 22,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 40,
        "fullcodeline": "priv->fname = firmware_name;"
    },
    {
        "line": 52,
        "fullcodeline": "priv->state = XC2028_WAITING_FIRMWARE;"
    }
]