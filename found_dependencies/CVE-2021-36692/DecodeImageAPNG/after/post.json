[
    {
        "line": 6,
        "fullcodeline": "unsigned char sig[8];"
    },
    {
        "line": 11,
        "fullcodeline": "std::vector<CHUNK> chunksInfo;"
    },
    {
        "line": 12,
        "fullcodeline": "bool isAnimated = false;"
    },
    {
        "line": 13,
        "fullcodeline": "bool skipFirst = false;"
    },
    {
        "line": 14,
        "fullcodeline": "bool hasInfo = false;"
    },
    {
        "line": 15,
        "fullcodeline": "bool all_dispose_bg = true;"
    },
    {
        "line": 16,
        "fullcodeline": "APNGFrame frameRaw = {};"
    },
    {
        "line": 20,
        "fullcodeline": "unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};"
    },
    {
        "line": 24,
        "fullcodeline": "id = read_chunk(&r, &chunkIHDR);"
    },
    {
        "line": 26,
        "fullcodeline": "io->frames.clear();"
    },
    {
        "line": 27,
        "fullcodeline": "io->dec_pixels = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "io->metadata.m.SetUintSamples(8);"
    },
    {
        "line": 29,
        "fullcodeline": "io->metadata.m.SetAlphaBits(8);"
    },
    {
        "line": 30,
        "fullcodeline": "io->metadata.m.color_encoding ="
    },
    {
        "line": 32,
        "fullcodeline": "(void)io->dec_hints.Foreach("
    },
    {
        "line": 38,
        "fullcodeline": "bool errorstate = true;"
    },
    {
        "line": 208,
        "fullcodeline": "chunksInfo.clear();"
    },
    {
        "line": 209,
        "fullcodeline": "delete[] chunkIHDR.p;"
    },
    {
        "line": 212,
        "fullcodeline": "SetIntensityTarget(io);"
    },
    {
        "line": 21,
        "fullcodeline": "if (r.Read(sig, 8) || memcmp(sig, png_signature, 8) != 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (id == kId_IHDR && chunkIHDR.size == 25) {"
    },
    {
        "line": 206,
        "fullcodeline": "for (i = 0; i < chunksInfo.size(); i++) delete[] chunksInfo[i].p;"
    },
    {
        "line": 40,
        "fullcodeline": "w0 = w = png_get_uint_32(chunkIHDR.p + 8);"
    },
    {
        "line": 41,
        "fullcodeline": "h0 = h = png_get_uint_32(chunkIHDR.p + 12);"
    },
    {
        "line": 47,
        "fullcodeline": "x0 = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "y0 = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "delay_num = 1;"
    },
    {
        "line": 50,
        "fullcodeline": "delay_den = 10;"
    },
    {
        "line": 51,
        "fullcodeline": "dop = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "bop = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "rowbytes = w * 4;"
    },
    {
        "line": 54,
        "fullcodeline": "imagesize = h * rowbytes;"
    },
    {
        "line": 56,
        "fullcodeline": "frameRaw.p = new unsigned char[imagesize];"
    },
    {
        "line": 57,
        "fullcodeline": "frameRaw.rows = new png_bytep[h * sizeof(png_bytep)];"
    },
    {
        "line": 202,
        "fullcodeline": "delete[] frameRaw.rows;"
    },
    {
        "line": 203,
        "fullcodeline": "delete[] frameRaw.p;"
    },
    {
        "line": 43,
        "fullcodeline": "if (w > cMaxPNGSize || h > cMaxPNGSize) {"
    },
    {
        "line": 58,
        "fullcodeline": "for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p + j * rowbytes;"
    },
    {
        "line": 60,
        "fullcodeline": "if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,"
    },
    {
        "line": 62,
        "fullcodeline": "bool last_base_was_none = true;"
    },
    {
        "line": 63,
        "fullcodeline": "while (!r.Eof()) {"
    },
    {
        "line": 64,
        "fullcodeline": "id = read_chunk(&r, &chunk);"
    },
    {
        "line": 66,
        "fullcodeline": "JXL_ASSERT(chunk.p != nullptr);"
    },
    {
        "line": 199,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 65,
        "fullcodeline": "if (!id) break;"
    },
    {
        "line": 68,
        "fullcodeline": "if (id == kId_acTL && !hasInfo && !isAnimated) {"
    },
    {
        "line": 69,
        "fullcodeline": "isAnimated = true;"
    },
    {
        "line": 70,
        "fullcodeline": "skipFirst = true;"
    },
    {
        "line": 71,
        "fullcodeline": "io->metadata.m.have_animation = true;"
    },
    {
        "line": 72,
        "fullcodeline": "io->metadata.m.animation.tps_numerator = 1000;"
    },
    {
        "line": 73,
        "fullcodeline": "} else if (id == kId_IEND ||"
    },
    {
        "line": 74,
        "fullcodeline": "(id == kId_fcTL && (!hasInfo || isAnimated))) {"
    },
    {
        "line": 142,
        "fullcodeline": "w0 = png_get_uint_32(chunk.p + 12);"
    },
    {
        "line": 143,
        "fullcodeline": "h0 = png_get_uint_32(chunk.p + 16);"
    },
    {
        "line": 144,
        "fullcodeline": "x0 = png_get_uint_32(chunk.p + 20);"
    },
    {
        "line": 145,
        "fullcodeline": "y0 = png_get_uint_32(chunk.p + 24);"
    },
    {
        "line": 146,
        "fullcodeline": "delay_num = png_get_uint_16(chunk.p + 28);"
    },
    {
        "line": 147,
        "fullcodeline": "delay_den = png_get_uint_16(chunk.p + 30);"
    },
    {
        "line": 137,
        "fullcodeline": "if (id == kId_IEND) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (!delay_den) delay_den = 100;"
    },
    {
        "line": 153,
        "fullcodeline": "if (w0 > cMaxPNGSize || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||"
    },
    {
        "line": 170,
        "fullcodeline": "if (io->frames.size() == (skipFirst ? 1 : 0)) {"
    },
    {
        "line": 138,
        "fullcodeline": "errorstate = false;"
    },
    {
        "line": 155,
        "fullcodeline": "bop > 1) {"
    },
    {
        "line": 156,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 161,
        "fullcodeline": "memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);"
    },
    {
        "line": 171,
        "fullcodeline": "bop = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "} else if (id == kId_IDAT) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (!processing_finish(png_ptr, info_ptr)) {"
    },
    {
        "line": 154,
        "fullcodeline": "y0 > cMaxPNGSize || x0 + w0 > w || y0 + h0 > h || dop > 2 ||"
    },
    {
        "line": 162,
        "fullcodeline": "if (processing_start(png_ptr, info_ptr, (void*)&frameRaw, hasInfo,"
    },
    {
        "line": 168,
        "fullcodeline": "skipFirst = false;"
    },
    {
        "line": 172,
        "fullcodeline": "if (dop == 2) dop = 1;"
    },
    {
        "line": 175,
        "fullcodeline": "hasInfo = true;"
    },
    {
        "line": 77,
        "fullcodeline": "ImageBundle bundle(&io->metadata.m);"
    },
    {
        "line": 78,
        "fullcodeline": "bundle.duration = delay_num * 1000 / delay_den;"
    },
    {
        "line": 79,
        "fullcodeline": "bundle.origin.x0 = x0;"
    },
    {
        "line": 80,
        "fullcodeline": "bundle.origin.y0 = y0;"
    },
    {
        "line": 102,
        "fullcodeline": "bundle.blend = bop != 0;"
    },
    {
        "line": 103,
        "fullcodeline": "io->dec_pixels += w0 * h0;"
    },
    {
        "line": 105,
        "fullcodeline": "Image3F sub_frame(w0, h0);"
    },
    {
        "line": 106,
        "fullcodeline": "ImageF sub_frame_alpha(w0, h0);"
    },
    {
        "line": 127,
        "fullcodeline": "bundle.SetFromImage(std::move(sub_frame), ColorEncoding::SRGB());"
    },
    {
        "line": 128,
        "fullcodeline": "bundle.SetAlpha(std::move(sub_frame_alpha),"
    },
    {
        "line": 130,
        "fullcodeline": "io->frames.push_back(std::move(bundle));"
    },
    {
        "line": 164,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 176,
        "fullcodeline": "if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (last_base_was_none && !all_dispose_bg &&"
    },
    {
        "line": 107,
        "fullcodeline": "for (size_t y = 0; y < h0; ++y) {"
    },
    {
        "line": 132,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 177,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 180,
        "fullcodeline": "} else if (id == kId_fdAT && isAnimated) {"
    },
    {
        "line": 83,
        "fullcodeline": "(x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0)) {"
    },
    {
        "line": 90,
        "fullcodeline": "bundle.use_for_next_frame = true;"
    },
    {
        "line": 91,
        "fullcodeline": "last_base_was_none = false;"
    },
    {
        "line": 92,
        "fullcodeline": "all_dispose_bg = false;"
    },
    {
        "line": 95,
        "fullcodeline": "bundle.use_for_next_frame = false;"
    },
    {
        "line": 96,
        "fullcodeline": "all_dispose_bg = false;"
    },
    {
        "line": 99,
        "fullcodeline": "bundle.use_for_next_frame = false;"
    },
    {
        "line": 100,
        "fullcodeline": "last_base_was_none = true;"
    },
    {
        "line": 108,
        "fullcodeline": "float* const JXL_RESTRICT row_r = sub_frame.PlaneRow(0, y);"
    },
    {
        "line": 109,
        "fullcodeline": "float* const JXL_RESTRICT row_g = sub_frame.PlaneRow(1, y);"
    },
    {
        "line": 110,
        "fullcodeline": "float* const JXL_RESTRICT row_b = sub_frame.PlaneRow(2, y);"
    },
    {
        "line": 111,
        "fullcodeline": "float* const JXL_RESTRICT row_alpha = sub_frame_alpha.Row(y);"
    },
    {
        "line": 181,
        "fullcodeline": "png_save_uint_32(chunk.p + 4, chunk.size - 16);"
    },
    {
        "line": 182,
        "fullcodeline": "memcpy(chunk.p + 8, \"IDAT\", 4);"
    },
    {
        "line": 84,
        "fullcodeline": "return JXL_FAILURE("
    },
    {
        "line": 113,
        "fullcodeline": "for (size_t x = 0; x < w0; ++x) {"
    },
    {
        "line": 183,
        "fullcodeline": "if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {"
    },
    {
        "line": 121,
        "fullcodeline": "row_r[x] = f[4 * x + 0] * (1.f / 255);"
    },
    {
        "line": 122,
        "fullcodeline": "row_g[x] = f[4 * x + 1] * (1.f / 255);"
    },
    {
        "line": 123,
        "fullcodeline": "row_b[x] = f[4 * x + 2] * (1.f / 255);"
    },
    {
        "line": 124,
        "fullcodeline": "row_alpha[x] = f[4 * x + 3] * (1.f / 255);"
    },
    {
        "line": 184,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 187,
        "fullcodeline": "} else if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||"
    },
    {
        "line": 114,
        "fullcodeline": "if (f[4 * x + 3] == 0) {"
    },
    {
        "line": 188,
        "fullcodeline": "!isAbc(chunk.p[6]) || !isAbc(chunk.p[7])) {"
    },
    {
        "line": 189,
        "fullcodeline": "delete[] chunk.p;"
    },
    {
        "line": 115,
        "fullcodeline": "row_alpha[x] = 0;"
    },
    {
        "line": 116,
        "fullcodeline": "row_r[x] = 0;"
    },
    {
        "line": 117,
        "fullcodeline": "row_g[x] = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "row_b[x] = 0;"
    },
    {
        "line": 191,
        "fullcodeline": "} else if (!hasInfo) {"
    },
    {
        "line": 196,
        "fullcodeline": "chunksInfo.push_back(chunk);"
    },
    {
        "line": 192,
        "fullcodeline": "if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size)) {"
    },
    {
        "line": 193,
        "fullcodeline": "delete[] chunk.p;"
    }
]