[
    {
        "line": 5,
        "fullcodeline": "struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);"
    },
    {
        "line": 6,
        "fullcodeline": "struct dj_report *dj_report = (struct dj_report *) data;"
    },
    {
        "line": 8,
        "fullcodeline": "bool report_processed = false;"
    },
    {
        "line": 10,
        "fullcodeline": "dbg_hid(\"%s, size:%d\\n\", __func__, size);"
    },
    {
        "line": 42,
        "fullcodeline": "spin_lock_irqsave(&djrcv_dev->lock, flags);"
    },
    {
        "line": 35,
        "fullcodeline": "if ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||"
    },
    {
        "line": 43,
        "fullcodeline": "if (dj_report->report_id == REPORT_ID_DJ_SHORT) {"
    },
    {
        "line": 36,
        "fullcodeline": "(dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {"
    },
    {
        "line": 37,
        "fullcodeline": "dev_err(&hdev->dev, \"%s: invalid device index:%d\\n\","
    },
    {
        "line": 58,
        "fullcodeline": "report_processed = true;"
    },
    {
        "line": 47,
        "fullcodeline": "logi_dj_recv_queue_notification(djrcv_dev, dj_report);"
    },
    {
        "line": 56,
        "fullcodeline": "logi_dj_recv_forward_report(djrcv_dev, dj_report);"
    },
    {
        "line": 50,
        "fullcodeline": "if (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] =="
    },
    {
        "line": 52,
        "fullcodeline": "logi_dj_recv_forward_null_report(djrcv_dev, dj_report);"
    }
]