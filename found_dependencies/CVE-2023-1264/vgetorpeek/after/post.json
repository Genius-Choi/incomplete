[
    {
        "line": 4,
        "fullcodeline": "int\t\ttimedout = FALSE;\t// waited for more than 'timeoutlen'"
    },
    {
        "line": 7,
        "fullcodeline": "int\t\tmapdepth = 0;\t\t// check for recursive mapping"
    },
    {
        "line": 8,
        "fullcodeline": "int\t\tmode_deleted = FALSE;   // set when mode has been deleted"
    },
    {
        "line": 31,
        "fullcodeline": "++vgetc_busy;"
    },
    {
        "line": 39,
        "fullcodeline": "init_typebuf();"
    },
    {
        "line": 40,
        "fullcodeline": "start_stuff();"
    },
    {
        "line": 41,
        "fullcodeline": "check_end_reg_executing(advance);"
    },
    {
        "line": 528,
        "fullcodeline": "--vgetc_busy;"
    },
    {
        "line": 28,
        "fullcodeline": "if (vgetc_busy > 0 && ex_normal_busy == 0)"
    },
    {
        "line": 487,
        "fullcodeline": "} while ((c < 0 && c != K_CANCEL) || (advance && c == NUL));"
    },
    {
        "line": 494,
        "fullcodeline": "if (advance && p_smd && msg_silent == 0 && (State & MODE_INSERT))"
    },
    {
        "line": 516,
        "fullcodeline": "if (timedout && c == ESC)"
    },
    {
        "line": 35,
        "fullcodeline": "KeyStuffed = FALSE;"
    },
    {
        "line": 36,
        "fullcodeline": "typebuf_was_empty = FALSE;"
    },
    {
        "line": 518,
        "fullcodeline": "char_u nop_buf[3];"
    },
    {
        "line": 522,
        "fullcodeline": "nop_buf[0] = K_SPECIAL;"
    },
    {
        "line": 523,
        "fullcodeline": "nop_buf[1] = KS_EXTRA;"
    },
    {
        "line": 524,
        "fullcodeline": "nop_buf[2] = KE_NOP;"
    },
    {
        "line": 525,
        "fullcodeline": "gotchars(nop_buf, 3);"
    },
    {
        "line": 47,
        "fullcodeline": "if (typeahead_char != 0)"
    },
    {
        "line": 55,
        "fullcodeline": "if (c != NUL && !got_int)"
    },
    {
        "line": 496,
        "fullcodeline": "if (c == ESC && !mode_deleted && !no_mapping && mode_displayed)"
    },
    {
        "line": 49,
        "fullcodeline": "c = typeahead_char;"
    },
    {
        "line": 54,
        "fullcodeline": "c = read_readbuffers(advance);"
    },
    {
        "line": 64,
        "fullcodeline": "if (typebuf.tb_no_abbr_cnt == 0)"
    },
    {
        "line": 498,
        "fullcodeline": "if (typebuf.tb_len && !KeyTyped)"
    },
    {
        "line": 51,
        "fullcodeline": "typeahead_char = 0;"
    },
    {
        "line": 62,
        "fullcodeline": "KeyStuffed = TRUE;"
    },
    {
        "line": 65,
        "fullcodeline": "typebuf.tb_no_abbr_cnt = 1;\t// no abbreviations now"
    },
    {
        "line": 499,
        "fullcodeline": "redraw_cmdline = TRUE;\t    // delete mode later"
    },
    {
        "line": 503,
        "fullcodeline": "else if (c != ESC && mode_deleted)"
    },
    {
        "line": 78,
        "fullcodeline": "int\tkeylen = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "check_end_reg_executing(advance);"
    },
    {
        "line": 178,
        "fullcodeline": "c = 0;"
    },
    {
        "line": 179,
        "fullcodeline": "new_wcol = curwin->w_wcol;"
    },
    {
        "line": 180,
        "fullcodeline": "new_wrow = curwin->w_wrow;"
    },
    {
        "line": 292,
        "fullcodeline": "typebuf.tb_len += c;"
    },
    {
        "line": 369,
        "fullcodeline": "showcmd_idx = 0;"
    },
    {
        "line": 370,
        "fullcodeline": "int showing_partial = FALSE;"
    },
    {
        "line": 441,
        "fullcodeline": "wait_tb_len = typebuf.tb_len;"
    },
    {
        "line": 442,
        "fullcodeline": "c = inchar(typebuf.tb_buf + typebuf.tb_off + typebuf.tb_len,"
    },
    {
        "line": 501,
        "fullcodeline": "unshowmode(FALSE);"
    },
    {
        "line": 181,
        "fullcodeline": "if (\t   advance"
    },
    {
        "line": 285,
        "fullcodeline": "if (c < 0)"
    },
    {
        "line": 290,
        "fullcodeline": "for (n = 1; n <= c; ++n)"
    },
    {
        "line": 291,
        "fullcodeline": "typebuf.tb_noremap[typebuf.tb_off + n] = RM_YES;"
    },
    {
        "line": 295,
        "fullcodeline": "if (typebuf.tb_len >= typebuf.tb_maplen + MAXMAPLEN)"
    },
    {
        "line": 301,
        "fullcodeline": "if (ex_normal_busy > 0)"
    },
    {
        "line": 356,
        "fullcodeline": "if (((State & MODE_INSERT) != 0 || p_lz)"
    },
    {
        "line": 371,
        "fullcodeline": "if (typebuf.tb_len > 0 && advance && !exmode_active)"
    },
    {
        "line": 421,
        "fullcodeline": "if (typebuf.tb_len == 0)"
    },
    {
        "line": 446,
        "fullcodeline": "if (showcmd_idx != 0)"
    },
    {
        "line": 459,
        "fullcodeline": "if (c < 0)"
    },
    {
        "line": 461,
        "fullcodeline": "if (c == NUL)\t\t// no character available"
    },
    {
        "line": 505,
        "fullcodeline": "if (typebuf.tb_len && !KeyTyped)"
    },
    {
        "line": 87,
        "fullcodeline": "line_breakcheck();"
    },
    {
        "line": 93,
        "fullcodeline": "c = inchar(typebuf.tb_buf, typebuf.tb_buflen - 1, 0L);"
    },
    {
        "line": 107,
        "fullcodeline": "flush_buffers(FLUSH_INPUT);\t// flush all typeahead"
    },
    {
        "line": 116,
        "fullcodeline": "cmd_silent = FALSE;"
    },
    {
        "line": 191,
        "fullcodeline": "&& (c = inchar(typebuf.tb_buf + typebuf.tb_off"
    },
    {
        "line": 194,
        "fullcodeline": "colnr_T\tcol = 0;"
    },
    {
        "line": 215,
        "fullcodeline": "validate_cursor();"
    },
    {
        "line": 216,
        "fullcodeline": "old_wcol = curwin->w_wcol;"
    },
    {
        "line": 217,
        "fullcodeline": "old_wrow = curwin->w_wrow;"
    },
    {
        "line": 278,
        "fullcodeline": "setcursor();"
    },
    {
        "line": 279,
        "fullcodeline": "out_flush();"
    },
    {
        "line": 280,
        "fullcodeline": "new_wcol = curwin->w_wcol;"
    },
    {
        "line": 281,
        "fullcodeline": "new_wrow = curwin->w_wrow;"
    },
    {
        "line": 282,
        "fullcodeline": "curwin->w_wcol = old_wcol;"
    },
    {
        "line": 283,
        "fullcodeline": "curwin->w_wrow = old_wrow;"
    },
    {
        "line": 297,
        "fullcodeline": "timedout = TRUE;"
    },
    {
        "line": 303,
        "fullcodeline": "static int tc = 0;"
    },
    {
        "line": 331,
        "fullcodeline": "tc = c;"
    },
    {
        "line": 341,
        "fullcodeline": "typebuf.tb_no_abbr_cnt = 0;"
    },
    {
        "line": 358,
        "fullcodeline": "&& advance && must_redraw != 0 && !need_wait_return)"
    },
    {
        "line": 360,
        "fullcodeline": "update_screen(0);"
    },
    {
        "line": 361,
        "fullcodeline": "setcursor(); // put cursor back where it belongs"
    },
    {
        "line": 424,
        "fullcodeline": "timedout = FALSE;"
    },
    {
        "line": 443,
        "fullcodeline": "typebuf.tb_buflen - typebuf.tb_off - typebuf.tb_len - 1,"
    },
    {
        "line": 447,
        "fullcodeline": "pop_showcmd();"
    },
    {
        "line": 506,
        "fullcodeline": "redraw_cmdline = TRUE;\t    // show mode later"
    },
    {
        "line": 89,
        "fullcodeline": "ui_breakcheck();\t\t// check for CTRL-C"
    },
    {
        "line": 102,
        "fullcodeline": "if ((c || typebuf.tb_maplen)"
    },
    {
        "line": 189,
        "fullcodeline": "&& (p_timeout"
    },
    {
        "line": 220,
        "fullcodeline": "if (curwin->w_cursor.col != 0)"
    },
    {
        "line": 308,
        "fullcodeline": "if (typebuf.tb_len > 0)"
    },
    {
        "line": 320,
        "fullcodeline": "if (p_im && (State & MODE_INSERT))"
    },
    {
        "line": 373,
        "fullcodeline": "if (((State & (MODE_NORMAL | MODE_INSERT))"
    },
    {
        "line": 404,
        "fullcodeline": "if ((State & MODE_CMDLINE)"
    },
    {
        "line": 428,
        "fullcodeline": "if (typebuf.tb_len == 0"
    },
    {
        "line": 439,
        "fullcodeline": "wait_time = 0;"
    },
    {
        "line": 450,
        "fullcodeline": "if (State & MODE_INSERT)"
    },
    {
        "line": 452,
        "fullcodeline": "if ((State & MODE_CMDLINE)"
    },
    {
        "line": 463,
        "fullcodeline": "if (!advance)"
    },
    {
        "line": 465,
        "fullcodeline": "if (wait_tb_len > 0)\t// timed out"
    },
    {
        "line": 508,
        "fullcodeline": "showmode();"
    },
    {
        "line": 103,
        "fullcodeline": "&& (State & (MODE_INSERT | MODE_CMDLINE)))"
    },
    {
        "line": 104,
        "fullcodeline": "c = ESC;"
    },
    {
        "line": 113,
        "fullcodeline": "*typebuf.tb_buf = c;"
    },
    {
        "line": 114,
        "fullcodeline": "gotchars(typebuf.tb_buf, 1);"
    },
    {
        "line": 120,
        "fullcodeline": "else if (typebuf.tb_len > 0)"
    },
    {
        "line": 188,
        "fullcodeline": "&& (State & MODE_INSERT)"
    },
    {
        "line": 190,
        "fullcodeline": "|| (keylen == KEYLEN_PART_KEY && p_ttimeout))"
    },
    {
        "line": 199,
        "fullcodeline": "unshowmode(TRUE);"
    },
    {
        "line": 200,
        "fullcodeline": "mode_deleted = TRUE;"
    },
    {
        "line": 310,
        "fullcodeline": "timedout = TRUE;"
    },
    {
        "line": 321,
        "fullcodeline": "c = Ctrl_L;"
    },
    {
        "line": 334,
        "fullcodeline": "typebuf_was_empty = TRUE;"
    },
    {
        "line": 338,
        "fullcodeline": "exmode_active = EXMODE_NORMAL;"
    },
    {
        "line": 375,
        "fullcodeline": "&& State != MODE_HITRETURN)"
    },
    {
        "line": 388,
        "fullcodeline": "old_wcol = curwin->w_wcol;"
    },
    {
        "line": 389,
        "fullcodeline": "old_wrow = curwin->w_wrow;"
    },
    {
        "line": 390,
        "fullcodeline": "curwin->w_wcol = new_wcol;"
    },
    {
        "line": 391,
        "fullcodeline": "curwin->w_wrow = new_wrow;"
    },
    {
        "line": 392,
        "fullcodeline": "push_showcmd();"
    },
    {
        "line": 398,
        "fullcodeline": "curwin->w_wcol = old_wcol;"
    },
    {
        "line": 399,
        "fullcodeline": "curwin->w_wrow = old_wrow;"
    },
    {
        "line": 409,
        "fullcodeline": "&& ptr2cells(typebuf.tb_buf + typebuf.tb_off"
    },
    {
        "line": 412,
        "fullcodeline": "putcmdline(typebuf.tb_buf[typebuf.tb_off"
    },
    {
        "line": 414,
        "fullcodeline": "showing_partial = TRUE;"
    },
    {
        "line": 429,
        "fullcodeline": "|| !(p_timeout"
    },
    {
        "line": 432,
        "fullcodeline": "wait_time = -1L;"
    },
    {
        "line": 451,
        "fullcodeline": "edit_unputchar();"
    },
    {
        "line": 453,
        "fullcodeline": "&& get_cmdline_info()->cmdbuff != NULL)"
    },
    {
        "line": 454,
        "fullcodeline": "unputcmdline();"
    },
    {
        "line": 467,
        "fullcodeline": "timedout = TRUE;"
    },
    {
        "line": 473,
        "fullcodeline": "while (typebuf.tb_buf[typebuf.tb_off"
    },
    {
        "line": 475,
        "fullcodeline": "typebuf.tb_noremap[typebuf.tb_off"
    },
    {
        "line": 106,
        "fullcodeline": "c = Ctrl_C;"
    },
    {
        "line": 125,
        "fullcodeline": "map_result_T result = handle_mapping("
    },
    {
        "line": 187,
        "fullcodeline": "&& typebuf.tb_maplen == 0"
    },
    {
        "line": 222,
        "fullcodeline": "if (curwin->w_wcol > 0)"
    },
    {
        "line": 268,
        "fullcodeline": "if (has_mbyte && col > 0 && curwin->w_wcol > 0)"
    },
    {
        "line": 357,
        "fullcodeline": "&& (State & MODE_CMDLINE) == 0"
    },
    {
        "line": 374,
        "fullcodeline": "|| State == MODE_LANGMAP)"
    },
    {
        "line": 378,
        "fullcodeline": "if (State & MODE_INSERT"
    },
    {
        "line": 393,
        "fullcodeline": "if (typebuf.tb_len > SHOWCMD_COLS)"
    },
    {
        "line": 395,
        "fullcodeline": "while (showcmd_idx < typebuf.tb_len)"
    },
    {
        "line": 396,
        "fullcodeline": "(void)add_to_showcmd("
    },
    {
        "line": 405,
        "fullcodeline": "&& get_cmdline_info()->cmdbuff != NULL"
    },
    {
        "line": 456,
        "fullcodeline": "setcursor();\t// put cursor back where it belongs"
    },
    {
        "line": 128,
        "fullcodeline": "if (result == map_result_retry)"
    },
    {
        "line": 131,
        "fullcodeline": "if (result == map_result_fail)"
    },
    {
        "line": 137,
        "fullcodeline": "if (result == map_result_get)"
    },
    {
        "line": 186,
        "fullcodeline": "&& ex_normal_busy == 0"
    },
    {
        "line": 272,
        "fullcodeline": "ptr = ml_get_curline();"
    },
    {
        "line": 273,
        "fullcodeline": "col -= (*mb_head_off)(ptr, ptr + col);"
    },
    {
        "line": 326,
        "fullcodeline": "else if ((State & MODE_CMDLINE)"
    },
    {
        "line": 379,
        "fullcodeline": "&& ptr2cells(typebuf.tb_buf + typebuf.tb_off"
    },
    {
        "line": 382,
        "fullcodeline": "edit_putchar(typebuf.tb_buf[typebuf.tb_off"
    },
    {
        "line": 384,
        "fullcodeline": "setcursor(); // put cursor back where it belongs"
    },
    {
        "line": 385,
        "fullcodeline": "showing_partial = TRUE;"
    },
    {
        "line": 394,
        "fullcodeline": "showcmd_idx = typebuf.tb_len - SHOWCMD_COLS;"
    },
    {
        "line": 430,
        "fullcodeline": "|| (p_ttimeout && keylen == KEYLEN_PART_KEY)))"
    },
    {
        "line": 433,
        "fullcodeline": "else if (keylen == KEYLEN_PART_KEY && p_ttm >= 0)"
    },
    {
        "line": 134,
        "fullcodeline": "c = -1;"
    },
    {
        "line": 142,
        "fullcodeline": "c = typebuf.tb_buf[typebuf.tb_off];"
    },
    {
        "line": 185,
        "fullcodeline": "&& kitty_protocol_state != KKPS_ENABLED"
    },
    {
        "line": 228,
        "fullcodeline": "if (did_ai && *skipwhite(ml_get_curline()"
    },
    {
        "line": 274,
        "fullcodeline": "if ((*mb_ptr2cells)(ptr + col) > 1)"
    },
    {
        "line": 327,
        "fullcodeline": "|| (cmdwin_type > 0 && tc == ESC))"
    },
    {
        "line": 328,
        "fullcodeline": "c = Ctrl_C;"
    },
    {
        "line": 434,
        "fullcodeline": "wait_time = p_ttm;"
    },
    {
        "line": 476,
        "fullcodeline": "+ typebuf.tb_len++] = RM_YES;"
    },
    {
        "line": 184,
        "fullcodeline": "&& !no_mapping"
    },
    {
        "line": 233,
        "fullcodeline": "curwin->w_wcol = 0;"
    },
    {
        "line": 234,
        "fullcodeline": "ptr = ml_get_curline();"
    },
    {
        "line": 235,
        "fullcodeline": "init_chartabsize_arg(&cts, curwin,"
    },
    {
        "line": 248,
        "fullcodeline": "clear_chartabsize_arg(&cts);"
    },
    {
        "line": 250,
        "fullcodeline": "curwin->w_wrow = curwin->w_cline_row"
    },
    {
        "line": 252,
        "fullcodeline": "curwin->w_wcol %= curwin->w_width;"
    },
    {
        "line": 253,
        "fullcodeline": "curwin->w_wcol += curwin_col_off();"
    },
    {
        "line": 254,
        "fullcodeline": "col = 0;\t// no correction needed"
    },
    {
        "line": 262,
        "fullcodeline": "else if (curwin->w_p_wrap && curwin->w_wrow)"
    },
    {
        "line": 275,
        "fullcodeline": "--curwin->w_wcol;"
    },
    {
        "line": 330,
        "fullcodeline": "c = ESC;"
    },
    {
        "line": 397,
        "fullcodeline": "typebuf.tb_buf[typebuf.tb_off + showcmd_idx++]);"
    },
    {
        "line": 436,
        "fullcodeline": "wait_time = p_tm;"
    },
    {
        "line": 145,
        "fullcodeline": "cmd_silent = (typebuf.tb_silent > 0);"
    },
    {
        "line": 157,
        "fullcodeline": "del_typebuf(1, 0);"
    },
    {
        "line": 183,
        "fullcodeline": "&& typebuf.tb_buf[typebuf.tb_off] == ESC"
    },
    {
        "line": 237,
        "fullcodeline": "while (cts.cts_ptr < ptr + curwin->w_cursor.col)"
    },
    {
        "line": 258,
        "fullcodeline": "--curwin->w_wcol;"
    },
    {
        "line": 259,
        "fullcodeline": "col = curwin->w_cursor.col - 1;"
    },
    {
        "line": 264,
        "fullcodeline": "--curwin->w_wrow;"
    },
    {
        "line": 265,
        "fullcodeline": "curwin->w_wcol = curwin->w_width - 1;"
    },
    {
        "line": 266,
        "fullcodeline": "col = curwin->w_cursor.col - 1;"
    },
    {
        "line": 146,
        "fullcodeline": "if (typebuf.tb_maplen > 0)"
    },
    {
        "line": 182,
        "fullcodeline": "&& typebuf.tb_len == 1"
    },
    {
        "line": 241,
        "fullcodeline": "cts.cts_vcol += lbr_chartabsize(&cts);"
    },
    {
        "line": 251,
        "fullcodeline": "+ curwin->w_wcol / curwin->w_width;"
    },
    {
        "line": 147,
        "fullcodeline": "KeyTyped = FALSE;"
    },
    {
        "line": 239,
        "fullcodeline": "if (!VIM_ISWHITE(*cts.cts_ptr))"
    },
    {
        "line": 150,
        "fullcodeline": "KeyTyped = TRUE;"
    },
    {
        "line": 152,
        "fullcodeline": "gotchars(typebuf.tb_buf"
    },
    {
        "line": 240,
        "fullcodeline": "curwin->w_wcol = cts.cts_vcol;"
    },
    {
        "line": 243,
        "fullcodeline": "cts.cts_ptr +="
    },
    {
        "line": 244,
        "fullcodeline": "(*mb_ptr2len)(cts.cts_ptr);"
    },
    {
        "line": 246,
        "fullcodeline": "++cts.cts_ptr;"
    }
]