[
    {
        "line": 8,
        "fullcodeline": "size_t pos = 0, identifier_len = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "int error = -1, n;"
    },
    {
        "line": 10,
        "fullcodeline": "git_str buf = GIT_STR_INIT;"
    },
    {
        "line": 12,
        "fullcodeline": "git_reference *reference = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "git_object *base_rev = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "bool should_return_reference = true;"
    },
    {
        "line": 17,
        "fullcodeline": "GIT_ASSERT_ARG(object_out);"
    },
    {
        "line": 18,
        "fullcodeline": "GIT_ASSERT_ARG(reference_out);"
    },
    {
        "line": 19,
        "fullcodeline": "GIT_ASSERT_ARG(repo);"
    },
    {
        "line": 20,
        "fullcodeline": "GIT_ASSERT_ARG(spec);"
    },
    {
        "line": 22,
        "fullcodeline": "*object_out = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "*reference_out = NULL;"
    },
    {
        "line": 150,
        "fullcodeline": "*object_out = base_rev;"
    },
    {
        "line": 151,
        "fullcodeline": "*reference_out = reference;"
    },
    {
        "line": 152,
        "fullcodeline": "*identifier_len_out = identifier_len;"
    },
    {
        "line": 153,
        "fullcodeline": "error = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "git_str_dispose(&buf);"
    },
    {
        "line": 142,
        "fullcodeline": "if ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)"
    },
    {
        "line": 145,
        "fullcodeline": "if (!should_return_reference) {"
    },
    {
        "line": 146,
        "fullcodeline": "git_reference_free(reference);"
    },
    {
        "line": 147,
        "fullcodeline": "reference = NULL;"
    },
    {
        "line": 161,
        "fullcodeline": "git_object_free(base_rev);"
    },
    {
        "line": 162,
        "fullcodeline": "git_reference_free(reference);"
    },
    {
        "line": 157,
        "fullcodeline": "if (error == GIT_EINVALIDSPEC)"
    },
    {
        "line": 28,
        "fullcodeline": "should_return_reference = false;"
    },
    {
        "line": 137,
        "fullcodeline": "pos++;"
    },
    {
        "line": 138,
        "fullcodeline": "identifier_len++;"
    },
    {
        "line": 158,
        "fullcodeline": "git_error_set(GIT_ERROR_INVALID,"
    },
    {
        "line": 30,
        "fullcodeline": "if ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)"
    },
    {
        "line": 33,
        "fullcodeline": "if (spec[pos+1] == '{') {"
    },
    {
        "line": 60,
        "fullcodeline": "git_object *temp_object = NULL;"
    },
    {
        "line": 62,
        "fullcodeline": "should_return_reference = false;"
    },
    {
        "line": 73,
        "fullcodeline": "git_object_free(base_rev);"
    },
    {
        "line": 74,
        "fullcodeline": "base_rev = temp_object;"
    },
    {
        "line": 80,
        "fullcodeline": "git_object *temp_object = NULL;"
    },
    {
        "line": 82,
        "fullcodeline": "should_return_reference = false;"
    },
    {
        "line": 109,
        "fullcodeline": "git_object_free(base_rev);"
    },
    {
        "line": 110,
        "fullcodeline": "base_rev = temp_object;"
    },
    {
        "line": 115,
        "fullcodeline": "if (spec[pos+1] == '{') {"
    },
    {
        "line": 134,
        "fullcodeline": "if ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)"
    },
    {
        "line": 34,
        "fullcodeline": "git_object *temp_object = NULL;"
    },
    {
        "line": 42,
        "fullcodeline": "git_object_free(base_rev);"
    },
    {
        "line": 43,
        "fullcodeline": "base_rev = temp_object;"
    },
    {
        "line": 64,
        "fullcodeline": "if ((error = extract_how_many(&n, spec, &pos)) < 0)"
    },
    {
        "line": 67,
        "fullcodeline": "if ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)"
    },
    {
        "line": 70,
        "fullcodeline": "if ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)"
    },
    {
        "line": 84,
        "fullcodeline": "if ((error = extract_path(&buf, spec, &pos)) < 0)"
    },
    {
        "line": 87,
        "fullcodeline": "if (any_left_hand_identifier(base_rev, reference, identifier_len)) {"
    },
    {
        "line": 116,
        "fullcodeline": "git_object *temp_object = NULL;"
    },
    {
        "line": 36,
        "fullcodeline": "if ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)"
    },
    {
        "line": 39,
        "fullcodeline": "if ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)"
    },
    {
        "line": 45,
        "fullcodeline": "git_object *temp_object = NULL;"
    },
    {
        "line": 53,
        "fullcodeline": "git_object_free(base_rev);"
    },
    {
        "line": 54,
        "fullcodeline": "base_rev = temp_object;"
    },
    {
        "line": 118,
        "fullcodeline": "if ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)"
    },
    {
        "line": 121,
        "fullcodeline": "if ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)"
    },
    {
        "line": 124,
        "fullcodeline": "if ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_str_cstr(&buf))) < 0)"
    },
    {
        "line": 127,
        "fullcodeline": "if (temp_object != NULL)"
    },
    {
        "line": 47,
        "fullcodeline": "if ((error = extract_how_many(&n, spec, &pos)) < 0)"
    },
    {
        "line": 50,
        "fullcodeline": "if ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)"
    },
    {
        "line": 88,
        "fullcodeline": "if ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)"
    },
    {
        "line": 91,
        "fullcodeline": "if ((error = handle_colon_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)"
    },
    {
        "line": 128,
        "fullcodeline": "base_rev = temp_object;"
    },
    {
        "line": 94,
        "fullcodeline": "if (*git_str_cstr(&buf) == '/') {"
    },
    {
        "line": 95,
        "fullcodeline": "if ((error = handle_grep_syntax(&temp_object, repo, NULL, git_str_cstr(&buf) + 1)) < 0)"
    },
    {
        "line": 103,
        "fullcodeline": "git_error_set(GIT_ERROR_INVALID, \"unimplemented\");"
    },
    {
        "line": 104,
        "fullcodeline": "error = GIT_ERROR;"
    }
]