[
    {
        "line": 4,
        "fullcodeline": "int drive = (long)bdev->bd_disk->private_data;"
    },
    {
        "line": 5,
        "fullcodeline": "int type = ITYPE(drive_state[drive].fd_device);"
    },
    {
        "line": 31,
        "fullcodeline": "ret = normalize_ioctl(&cmd, &size);"
    },
    {
        "line": 20,
        "fullcodeline": "if (cmd == CDROMEJECT ||\t/* CD-ROM eject */"
    },
    {
        "line": 27,
        "fullcodeline": "if (!((cmd & 0xff00) == 0x0200))"
    },
    {
        "line": 45,
        "fullcodeline": "if (_IOC_DIR(cmd) & _IOC_WRITE) {"
    },
    {
        "line": 21,
        "fullcodeline": "cmd == 0x6470) {\t\t/* SunOS floppy eject */"
    },
    {
        "line": 22,
        "fullcodeline": "DPRINT(\"obsolete eject ioctl\\n\");"
    },
    {
        "line": 23,
        "fullcodeline": "DPRINT(\"please use floppycontrol --eject\\n\");"
    },
    {
        "line": 24,
        "fullcodeline": "cmd = FDEJECT;"
    },
    {
        "line": 36,
        "fullcodeline": "if (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||"
    },
    {
        "line": 37,
        "fullcodeline": "((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))"
    },
    {
        "line": 40,
        "fullcodeline": "if (WARN_ON(size < 0 || size > sizeof(inparam)))"
    },
    {
        "line": 61,
        "fullcodeline": "ret = fd_eject(UNIT(drive));"
    },
    {
        "line": 63,
        "fullcodeline": "set_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);"
    },
    {
        "line": 64,
        "fullcodeline": "set_bit(FD_VERIFY_BIT, &drive_state[drive].flags);"
    },
    {
        "line": 70,
        "fullcodeline": "current_type[drive] = NULL;"
    },
    {
        "line": 78,
        "fullcodeline": "ret = get_floppy_geometry(drive, type,"
    },
    {
        "line": 97,
        "fullcodeline": "ret = drive_state[drive].flags;"
    },
    {
        "line": 123,
        "fullcodeline": "outparam = drive_name(type, drive);"
    },
    {
        "line": 170,
        "fullcodeline": "twaddle(current_fdc, current_drive);"
    },
    {
        "line": 28,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 38,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 41,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 56,
        "fullcodeline": "if (lock_fdc(drive))"
    },
    {
        "line": 71,
        "fullcodeline": "floppy_sizes[drive] = MAX_DISK_SIZE << 1;"
    },
    {
        "line": 73,
        "fullcodeline": "return invalidate_drive(bdev);"
    },
    {
        "line": 76,
        "fullcodeline": "return set_geometry(cmd, &inparam.g, drive, type, bdev);"
    },
    {
        "line": 90,
        "fullcodeline": "drive_params[drive].flags &= ~FTD_MSG;"
    },
    {
        "line": 99,
        "fullcodeline": "if (ret & FD_VERIFY)"
    },
    {
        "line": 107,
        "fullcodeline": "return do_format(drive, &inparam.f);"
    },
    {
        "line": 112,
        "fullcodeline": "return invalidate_drive(bdev);"
    },
    {
        "line": 146,
        "fullcodeline": "return user_reset_fdc(drive, (int)param, true);"
    },
    {
        "line": 159,
        "fullcodeline": "if (lock_fdc(drive))"
    },
    {
        "line": 163,
        "fullcodeline": "if (i == -EINTR)"
    },
    {
        "line": 174,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 95,
        "fullcodeline": "if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)"
    },
    {
        "line": 101,
        "fullcodeline": "if (!(ret & FD_DISK_WRITABLE))"
    },
    {
        "line": 114,
        "fullcodeline": "drive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);"
    },
    {
        "line": 124,
        "fullcodeline": "SUPBOUND(size, strlen((const char *)outparam) + 1);"
    },
    {
        "line": 127,
        "fullcodeline": "if (!valid_floppy_drive_params(inparam.dp.autodetect,"
    },
    {
        "line": 138,
        "fullcodeline": "if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)"
    },
    {
        "line": 55,
        "fullcodeline": "return -EBUSY;"
    },
    {
        "line": 57,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 69,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 94,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 96,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 100,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 102,
        "fullcodeline": "return -EROFS;"
    },
    {
        "line": 106,
        "fullcodeline": "return -EBUSY;"
    },
    {
        "line": 111,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 129,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 137,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 139,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 158,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 160,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 164,
        "fullcodeline": "return -EINTR;"
    },
    {
        "line": 169,
        "fullcodeline": "return -EINTR;"
    }
]