[
    {
        "line": 5,
        "fullcodeline": "struct sock_iocb *siocb = kiocb_to_siocb(iocb);"
    },
    {
        "line": 7,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 8,
        "fullcodeline": "struct unix_sock *u = unix_sk(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "struct sockaddr_un *sunaddr = msg->msg_name;"
    },
    {
        "line": 10,
        "fullcodeline": "int copied = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int check_creds = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "err = -EINVAL;"
    },
    {
        "line": 21,
        "fullcodeline": "err = -EOPNOTSUPP;"
    },
    {
        "line": 25,
        "fullcodeline": "target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);"
    },
    {
        "line": 26,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);"
    },
    {
        "line": 37,
        "fullcodeline": "err = mutex_lock_interruptible(&u->readlock);"
    },
    {
        "line": 153,
        "fullcodeline": "mutex_unlock(&u->readlock);"
    },
    {
        "line": 154,
        "fullcodeline": "scm_recv(sock, msg, siocb->scm, flags);"
    },
    {
        "line": 18,
        "fullcodeline": "if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 22,
        "fullcodeline": "if (flags&MSG_OOB)"
    },
    {
        "line": 32,
        "fullcodeline": "if (!siocb->scm) {"
    },
    {
        "line": 156,
        "fullcodeline": "return copied ? : err;"
    },
    {
        "line": 33,
        "fullcodeline": "siocb->scm = &tmp_scm;"
    },
    {
        "line": 34,
        "fullcodeline": "memset(&tmp_scm, 0, sizeof(tmp_scm));"
    },
    {
        "line": 39,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 47,
        "fullcodeline": "unix_state_lock(sk);"
    },
    {
        "line": 48,
        "fullcodeline": "last = skb = skb_peek(&sk->sk_receive_queue);"
    },
    {
        "line": 85,
        "fullcodeline": "skip = sk_peek_offset(sk, flags);"
    },
    {
        "line": 94,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 121,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 122,
        "fullcodeline": "size -= chunk;"
    },
    {
        "line": 50,
        "fullcodeline": "if (skb == NULL) {"
    },
    {
        "line": 86,
        "fullcodeline": "while (skip >= unix_skb_len(skb)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (skb_copy_datagram_iovec(skb, UNIXCB(skb).consumed + skip,"
    },
    {
        "line": 125,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 51,
        "fullcodeline": "unix_sk(sk)->recursion_level = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 65,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 66,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 69,
        "fullcodeline": "mutex_unlock(&u->readlock);"
    },
    {
        "line": 71,
        "fullcodeline": "timeo = unix_stream_data_wait(sk, timeo, last);"
    },
    {
        "line": 81,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 87,
        "fullcodeline": "skip -= unix_skb_len(skb);"
    },
    {
        "line": 88,
        "fullcodeline": "last = skb;"
    },
    {
        "line": 89,
        "fullcodeline": "skb = skb_peek_next(skb, &sk->sk_receive_queue);"
    },
    {
        "line": 110,
        "fullcodeline": "unix_copy_addr(msg, skb->sk);"
    },
    {
        "line": 111,
        "fullcodeline": "sunaddr = NULL;"
    },
    {
        "line": 126,
        "fullcodeline": "UNIXCB(skb).consumed += chunk;"
    },
    {
        "line": 128,
        "fullcodeline": "sk_peek_offset_bwd(sk, chunk);"
    },
    {
        "line": 136,
        "fullcodeline": "skb_unlink(skb, &sk->sk_receive_queue);"
    },
    {
        "line": 137,
        "fullcodeline": "consume_skb(skb);"
    },
    {
        "line": 52,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 62,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 67,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 73,
        "fullcodeline": "if (signal_pending(current)"
    },
    {
        "line": 90,
        "fullcodeline": "if (!skb)"
    },
    {
        "line": 98,
        "fullcodeline": "if ((UNIXCB(skb).pid  != siocb->scm->pid) ||"
    },
    {
        "line": 117,
        "fullcodeline": "if (copied == 0)"
    },
    {
        "line": 133,
        "fullcodeline": "if (unix_skb_len(skb))"
    },
    {
        "line": 147,
        "fullcodeline": "sk_peek_offset_fwd(sk, chunk);"
    },
    {
        "line": 74,
        "fullcodeline": "||  mutex_lock_interruptible(&u->readlock)) {"
    },
    {
        "line": 75,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 100,
        "fullcodeline": "!gid_eq(UNIXCB(skb).gid, siocb->scm->creds.gid))"
    },
    {
        "line": 102,
        "fullcodeline": "} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {"
    },
    {
        "line": 118,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 130,
        "fullcodeline": "if (UNIXCB(skb).fp)"
    },
    {
        "line": 131,
        "fullcodeline": "unix_detach_fds(siocb->scm, skb);"
    },
    {
        "line": 99,
        "fullcodeline": "!uid_eq(UNIXCB(skb).uid, siocb->scm->creds.uid) ||"
    },
    {
        "line": 104,
        "fullcodeline": "scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);"
    },
    {
        "line": 105,
        "fullcodeline": "check_creds = 1;"
    },
    {
        "line": 144,
        "fullcodeline": "if (UNIXCB(skb).fp)"
    },
    {
        "line": 145,
        "fullcodeline": "siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);"
    }
]