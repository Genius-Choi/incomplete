[
    {
        "line": 4,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 5,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "size_t target, copied = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "msg->msg_namelen = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "BT_DBG(\"sk %p size %zu\", sk, size);"
    },
    {
        "line": 16,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 18,
        "fullcodeline": "target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);"
    },
    {
        "line": 19,
        "fullcodeline": "timeo  = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);"
    },
    {
        "line": 103,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "if (flags & MSG_OOB)"
    },
    {
        "line": 104,
        "fullcodeline": "return copied ? : err;"
    },
    {
        "line": 25,
        "fullcodeline": "skb = skb_dequeue(&sk->sk_receive_queue);"
    },
    {
        "line": 56,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 57,
        "fullcodeline": "size   -= chunk;"
    },
    {
        "line": 59,
        "fullcodeline": "sock_recv_ts_and_drops(msg, sk, skb);"
    },
    {
        "line": 10,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 26,
        "fullcodeline": "if (!skb) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (skb_copy_datagram_iovec(skb, 0, msg->msg_iov, chunk)) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 30,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 36,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 40,
        "fullcodeline": "timeo = bt_sock_data_wait(sk, timeo);"
    },
    {
        "line": 51,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 62,
        "fullcodeline": "int skb_len = skb_headlen(skb);"
    },
    {
        "line": 93,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 27,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 33,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 37,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 42,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (!copied)"
    },
    {
        "line": 64,
        "fullcodeline": "if (chunk <= skb_len) {"
    },
    {
        "line": 97,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 43,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 53,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 65,
        "fullcodeline": "__skb_pull(skb, chunk);"
    },
    {
        "line": 90,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 69,
        "fullcodeline": "__skb_pull(skb, skb_len);"
    },
    {
        "line": 70,
        "fullcodeline": "chunk -= skb_len;"
    },
    {
        "line": 72,
        "fullcodeline": "skb_walk_frags(skb, frag) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (chunk <= frag->len) {"
    },
    {
        "line": 75,
        "fullcodeline": "skb->len -= chunk;"
    },
    {
        "line": 76,
        "fullcodeline": "skb->data_len -= chunk;"
    },
    {
        "line": 77,
        "fullcodeline": "__skb_pull(frag, chunk);"
    },
    {
        "line": 81,
        "fullcodeline": "chunk -= frag->len;"
    },
    {
        "line": 82,
        "fullcodeline": "skb->len -= frag->len;"
    },
    {
        "line": 83,
        "fullcodeline": "skb->data_len -= frag->len;"
    },
    {
        "line": 84,
        "fullcodeline": "__skb_pull(frag, frag->len);"
    }
]