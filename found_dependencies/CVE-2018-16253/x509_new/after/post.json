[
    {
        "line": 4,
        "fullcodeline": "int ret = X509_NOT_OK, offset = 0, cert_size = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "int version = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "*ctx = (X509_CTX *)calloc(1, sizeof(X509_CTX));"
    },
    {
        "line": 12,
        "fullcodeline": "x509_ctx = *ctx;"
    },
    {
        "line": 15,
        "fullcodeline": "asn1_skip_obj(cert, &cert_size, ASN1_SEQUENCE);"
    },
    {
        "line": 20,
        "fullcodeline": "begin_tbs = offset;         /* start of the tbs */"
    },
    {
        "line": 21,
        "fullcodeline": "end_tbs = begin_tbs;        /* work out the end of the tbs */"
    },
    {
        "line": 22,
        "fullcodeline": "asn1_skip_obj(cert, &end_tbs, ASN1_SEQUENCE);"
    },
    {
        "line": 49,
        "fullcodeline": "begin_spki = offset;"
    },
    {
        "line": 52,
        "fullcodeline": "end_spki = offset;"
    },
    {
        "line": 54,
        "fullcodeline": "x509_ctx->fingerprint = malloc(SHA1_SIZE);"
    },
    {
        "line": 56,
        "fullcodeline": "SHA1_Init(&sha_fp_ctx);"
    },
    {
        "line": 57,
        "fullcodeline": "SHA1_Update(&sha_fp_ctx, &cert[0], cert_size);"
    },
    {
        "line": 58,
        "fullcodeline": "SHA1_Final(x509_ctx->fingerprint, &sha_fp_ctx);"
    },
    {
        "line": 60,
        "fullcodeline": "x509_ctx->spki_sha256 = malloc(SHA256_SIZE);"
    },
    {
        "line": 62,
        "fullcodeline": "SHA256_Init(&spki_hash_ctx);"
    },
    {
        "line": 63,
        "fullcodeline": "SHA256_Update(&spki_hash_ctx, &cert[begin_spki], end_spki-begin_spki);"
    },
    {
        "line": 64,
        "fullcodeline": "SHA256_Final(x509_ctx->spki_sha256, &spki_hash_ctx);"
    },
    {
        "line": 143,
        "fullcodeline": "ret = X509_OK;"
    },
    {
        "line": 17,
        "fullcodeline": "if (asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)"
    },
    {
        "line": 24,
        "fullcodeline": "if (asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)"
    },
    {
        "line": 28,
        "fullcodeline": "if (cert[offset] == ASN1_EXPLICIT_TAG &&"
    },
    {
        "line": 32,
        "fullcodeline": "if (asn1_skip_obj(cert, &offset, ASN1_INTEGER) || /* serial number */"
    },
    {
        "line": 37,
        "fullcodeline": "if (asn1_signature_type(cert, &offset, x509_ctx))"
    },
    {
        "line": 43,
        "fullcodeline": "if (asn1_name(cert, &offset, x509_ctx->ca_cert_dn) ||"
    },
    {
        "line": 50,
        "fullcodeline": "if (asn1_public_key(cert, &offset, x509_ctx))"
    },
    {
        "line": 29,
        "fullcodeline": "asn1_version(cert, &offset, &version) == X509_NOT_OK)"
    },
    {
        "line": 33,
        "fullcodeline": "asn1_next_obj(cert, &offset, ASN1_SEQUENCE) < 0)"
    },
    {
        "line": 39,
        "fullcodeline": "ret = X509_VFY_ERROR_UNSUPPORTED_DIGEST;"
    },
    {
        "line": 45,
        "fullcodeline": "asn1_name(cert, &offset, x509_ctx->cert_dn))"
    },
    {
        "line": 147,
        "fullcodeline": "*len = cert_size;"
    },
    {
        "line": 157,
        "fullcodeline": "x509_free(x509_ctx);"
    },
    {
        "line": 158,
        "fullcodeline": "*ctx = NULL;"
    },
    {
        "line": 44,
        "fullcodeline": "asn1_validity(cert, &offset, x509_ctx) ||"
    }
]