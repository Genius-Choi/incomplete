[
    {
        "line": 4,
        "fullcodeline": "int HaveCom = FALSE;"
    },
    {
        "line": 6,
        "fullcodeline": "a = fgetc(infile);"
    },
    {
        "line": 8,
        "fullcodeline": "if (a != 0xff || fgetc(infile) != M_SOI){"
    },
    {
        "line": 12,
        "fullcodeline": "ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;"
    },
    {
        "line": 18,
        "fullcodeline": "int marker = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "prev = 0;"
    },
    {
        "line": 41,
        "fullcodeline": "lh = fgetc(infile);"
    },
    {
        "line": 42,
        "fullcodeline": "ll = fgetc(infile);"
    },
    {
        "line": 47,
        "fullcodeline": "itemlen = (lh << 8) | ll;"
    },
    {
        "line": 55,
        "fullcodeline": "Data = (uchar *)malloc(itemlen);"
    },
    {
        "line": 62,
        "fullcodeline": "Data[0] = (uchar)lh;"
    },
    {
        "line": 63,
        "fullcodeline": "Data[1] = (uchar)ll;"
    },
    {
        "line": 65,
        "fullcodeline": "got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section."
    },
    {
        "line": 69,
        "fullcodeline": "SectionsRead += 1;"
    },
    {
        "line": 25,
        "fullcodeline": "for (a=0;;a++){"
    },
    {
        "line": 34,
        "fullcodeline": "if (a > 10){"
    },
    {
        "line": 49,
        "fullcodeline": "if (itemlen < 2){"
    },
    {
        "line": 56,
        "fullcodeline": "if (Data == NULL){"
    },
    {
        "line": 26,
        "fullcodeline": "marker = fgetc(infile);"
    },
    {
        "line": 31,
        "fullcodeline": "prev = marker;"
    },
    {
        "line": 35,
        "fullcodeline": "ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);"
    },
    {
        "line": 43,
        "fullcodeline": "if (lh == EOF || ll == EOF){"
    },
    {
        "line": 66,
        "fullcodeline": "if (got != itemlen-2){"
    },
    {
        "line": 142,
        "fullcodeline": "ImageInfo.JfifHeader.ResolutionUnits = Data[9];"
    },
    {
        "line": 143,
        "fullcodeline": "ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];"
    },
    {
        "line": 144,
        "fullcodeline": "ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];"
    },
    {
        "line": 28,
        "fullcodeline": "if (marker == EOF){"
    },
    {
        "line": 75,
        "fullcodeline": "if (ReadMode & READ_IMAGE){"
    },
    {
        "line": 167,
        "fullcodeline": "if (ReadMode & READ_METADATA){"
    },
    {
        "line": 187,
        "fullcodeline": "if (ReadMode & READ_METADATA){"
    },
    {
        "line": 27,
        "fullcodeline": "if (marker != 0xff && prev == 0xff) break;"
    },
    {
        "line": 78,
        "fullcodeline": "cp = ftell(infile);"
    },
    {
        "line": 79,
        "fullcodeline": "fseek(infile, 0, SEEK_END);"
    },
    {
        "line": 80,
        "fullcodeline": "ep = ftell(infile);"
    },
    {
        "line": 81,
        "fullcodeline": "fseek(infile, cp, SEEK_SET);"
    },
    {
        "line": 83,
        "fullcodeline": "size = ep-cp;"
    },
    {
        "line": 84,
        "fullcodeline": "Data = (uchar *)malloc(size);"
    },
    {
        "line": 89,
        "fullcodeline": "got = fread(Data, 1, size, infile);"
    },
    {
        "line": 97,
        "fullcodeline": "Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;"
    },
    {
        "line": 99,
        "fullcodeline": "HaveAll = 1;"
    },
    {
        "line": 119,
        "fullcodeline": "if (HaveCom || ((ReadMode & READ_METADATA) == 0)){"
    },
    {
        "line": 134,
        "fullcodeline": "fprintf(stderr,\"Jfif header too short\\n\");"
    },
    {
        "line": 138,
        "fullcodeline": "fprintf(stderr,\"Header missing JFIF marker\\n\");"
    },
    {
        "line": 212,
        "fullcodeline": "fprintf(stderr,\"Section too short\\n\");"
    },
    {
        "line": 85,
        "fullcodeline": "if (Data == NULL){"
    },
    {
        "line": 90,
        "fullcodeline": "if (got != size){"
    },
    {
        "line": 124,
        "fullcodeline": "HaveCom = TRUE;"
    },
    {
        "line": 155,
        "fullcodeline": "if (Data[14] || Data[15]){"
    },
    {
        "line": 162,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 183,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 156,
        "fullcodeline": "fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");"
    },
    {
        "line": 168,
        "fullcodeline": "if (memcmp(Data+2, \"Exif\", 4) == 0){"
    },
    {
        "line": 121,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 194,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 171,
        "fullcodeline": "}else if (memcmp(Data+2, \"http:\", 5) == 0){"
    },
    {
        "line": 172,
        "fullcodeline": "Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes."
    },
    {
        "line": 176,
        "fullcodeline": "ShowXmp(Sections[SectionsRead-1]);"
    }
]