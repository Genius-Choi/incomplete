[
    {
        "line": 4,
        "fullcodeline": "int HaveCom = FALSE;"
    },
    {
        "line": 6,
        "fullcodeline": "a = fgetc(infile);"
    },
    {
        "line": 12,
        "fullcodeline": "ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;"
    },
    {
        "line": 13,
        "fullcodeline": "ImageInfo.JfifHeader.ResolutionUnits = 1;"
    },
    {
        "line": 8,
        "fullcodeline": "if (a != 0xff || fgetc(infile) != M_SOI){"
    },
    {
        "line": 18,
        "fullcodeline": "int marker = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "CheckSectionsAllocated();"
    },
    {
        "line": 24,
        "fullcodeline": "prev = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "Sections[SectionsRead].Type = marker;"
    },
    {
        "line": 41,
        "fullcodeline": "lh = fgetc(infile);"
    },
    {
        "line": 42,
        "fullcodeline": "ll = fgetc(infile);"
    },
    {
        "line": 47,
        "fullcodeline": "itemlen = (lh << 8) | ll;"
    },
    {
        "line": 53,
        "fullcodeline": "Sections[SectionsRead].Size = itemlen;"
    },
    {
        "line": 58,
        "fullcodeline": "Data = (uchar *)malloc(itemlen+20);"
    },
    {
        "line": 62,
        "fullcodeline": "Sections[SectionsRead].Data = Data;"
    },
    {
        "line": 65,
        "fullcodeline": "Data[0] = (uchar)lh;"
    },
    {
        "line": 66,
        "fullcodeline": "Data[1] = (uchar)ll;"
    },
    {
        "line": 68,
        "fullcodeline": "got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section."
    },
    {
        "line": 72,
        "fullcodeline": "SectionsRead += 1;"
    },
    {
        "line": 25,
        "fullcodeline": "for (a=0;;a++){"
    },
    {
        "line": 34,
        "fullcodeline": "if (a > 10){"
    },
    {
        "line": 43,
        "fullcodeline": "if (lh == EOF || ll == EOF){"
    },
    {
        "line": 49,
        "fullcodeline": "if (itemlen < 2){"
    },
    {
        "line": 59,
        "fullcodeline": "if (Data == NULL){"
    },
    {
        "line": 69,
        "fullcodeline": "if (got != itemlen-2){"
    },
    {
        "line": 26,
        "fullcodeline": "marker = fgetc(infile);"
    },
    {
        "line": 31,
        "fullcodeline": "prev = marker;"
    },
    {
        "line": 35,
        "fullcodeline": "ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);"
    },
    {
        "line": 44,
        "fullcodeline": "ErrFatal(\"Unexpected end of file\");"
    },
    {
        "line": 50,
        "fullcodeline": "ErrFatal(\"invalid marker\");"
    },
    {
        "line": 60,
        "fullcodeline": "ErrFatal(\"Could not allocate memory\");"
    },
    {
        "line": 70,
        "fullcodeline": "ErrFatal(\"Premature end of file?\");"
    },
    {
        "line": 108,
        "fullcodeline": "process_DQT(Data, itemlen);"
    },
    {
        "line": 113,
        "fullcodeline": "process_DHT(Data, itemlen);"
    },
    {
        "line": 118,
        "fullcodeline": "fprintf(stderr,\"No image in jpeg!\\n\");"
    },
    {
        "line": 144,
        "fullcodeline": "ImageInfo.JfifHeader.Present = TRUE;"
    },
    {
        "line": 145,
        "fullcodeline": "ImageInfo.JfifHeader.ResolutionUnits = Data[9];"
    },
    {
        "line": 146,
        "fullcodeline": "ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];"
    },
    {
        "line": 147,
        "fullcodeline": "ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];"
    },
    {
        "line": 218,
        "fullcodeline": "process_SOFn(Data, marker);"
    },
    {
        "line": 27,
        "fullcodeline": "if (marker != 0xff && prev == 0xff) break;"
    },
    {
        "line": 28,
        "fullcodeline": "if (marker == EOF){"
    },
    {
        "line": 78,
        "fullcodeline": "if (ReadMode & READ_IMAGE){"
    },
    {
        "line": 122,
        "fullcodeline": "if (HaveCom || ((ReadMode & READ_METADATA) == 0)){"
    },
    {
        "line": 136,
        "fullcodeline": "if (itemlen < 16){"
    },
    {
        "line": 140,
        "fullcodeline": "if (memcmp(Data+2, \"JFIF\\0\",5)){"
    },
    {
        "line": 170,
        "fullcodeline": "if (ReadMode & READ_METADATA){"
    },
    {
        "line": 190,
        "fullcodeline": "if (ReadMode & READ_METADATA){"
    },
    {
        "line": 214,
        "fullcodeline": "if (itemlen < 8){"
    },
    {
        "line": 29,
        "fullcodeline": "ErrFatal(\"Unexpected end of file\");"
    },
    {
        "line": 81,
        "fullcodeline": "cp = ftell(infile);"
    },
    {
        "line": 82,
        "fullcodeline": "fseek(infile, 0, SEEK_END);"
    },
    {
        "line": 83,
        "fullcodeline": "ep = ftell(infile);"
    },
    {
        "line": 84,
        "fullcodeline": "fseek(infile, cp, SEEK_SET);"
    },
    {
        "line": 86,
        "fullcodeline": "size = ep-cp;"
    },
    {
        "line": 87,
        "fullcodeline": "Data = (uchar *)malloc(size);"
    },
    {
        "line": 92,
        "fullcodeline": "got = fread(Data, 1, size, infile);"
    },
    {
        "line": 97,
        "fullcodeline": "CheckSectionsAllocated();"
    },
    {
        "line": 98,
        "fullcodeline": "Sections[SectionsRead].Data = Data;"
    },
    {
        "line": 99,
        "fullcodeline": "Sections[SectionsRead].Size = size;"
    },
    {
        "line": 100,
        "fullcodeline": "Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;"
    },
    {
        "line": 101,
        "fullcodeline": "SectionsRead ++;"
    },
    {
        "line": 102,
        "fullcodeline": "HaveAll = 1;"
    },
    {
        "line": 137,
        "fullcodeline": "fprintf(stderr,\"Jfif header too short\\n\");"
    },
    {
        "line": 141,
        "fullcodeline": "fprintf(stderr,\"Header missing JFIF marker\\n\");"
    },
    {
        "line": 149,
        "fullcodeline": "printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);"
    },
    {
        "line": 156,
        "fullcodeline": "printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);"
    },
    {
        "line": 215,
        "fullcodeline": "fprintf(stderr,\"Section too short\\n\");"
    },
    {
        "line": 223,
        "fullcodeline": "printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);"
    },
    {
        "line": 88,
        "fullcodeline": "if (Data == NULL){"
    },
    {
        "line": 93,
        "fullcodeline": "if (got != size){"
    },
    {
        "line": 126,
        "fullcodeline": "process_COM(Data, itemlen);"
    },
    {
        "line": 127,
        "fullcodeline": "HaveCom = TRUE;"
    },
    {
        "line": 158,
        "fullcodeline": "if (Data[14] || Data[15]){"
    },
    {
        "line": 165,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 171,
        "fullcodeline": "if (memcmp(Data+2, \"Exif\", 4) == 0){"
    },
    {
        "line": 186,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 89,
        "fullcodeline": "ErrFatal(\"could not allocate data for entire image\");"
    },
    {
        "line": 94,
        "fullcodeline": "ErrFatal(\"could not read the rest of the image\");"
    },
    {
        "line": 151,
        "fullcodeline": "case 0: printf(\"(aspect ratio)\"); break;"
    },
    {
        "line": 152,
        "fullcodeline": "case 1: printf(\"(dots per inch)\"); break;"
    },
    {
        "line": 153,
        "fullcodeline": "case 2: printf(\"(dots per cm)\"); break;"
    },
    {
        "line": 154,
        "fullcodeline": "default: printf(\"(unknown)\"); break;"
    },
    {
        "line": 159,
        "fullcodeline": "fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");"
    },
    {
        "line": 172,
        "fullcodeline": "process_EXIF(Data, itemlen);"
    },
    {
        "line": 192,
        "fullcodeline": "printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);"
    },
    {
        "line": 124,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 174,
        "fullcodeline": "}else if (memcmp(Data+2, \"http:\", 5) == 0){"
    },
    {
        "line": 197,
        "fullcodeline": "free(Sections[--SectionsRead].Data);"
    },
    {
        "line": 175,
        "fullcodeline": "Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes."
    },
    {
        "line": 177,
        "fullcodeline": "printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);"
    },
    {
        "line": 179,
        "fullcodeline": "ShowXmp(Sections[SectionsRead-1]);"
    }
]