[
    {
        "line": 31,
        "fullcodeline": "VariableLocationKind kind = LOCATION_UNKNOWN;"
    },
    {
        "line": 32,
        "fullcodeline": "st64 offset = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "ut64 address = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "ut64 reg_num = -1;"
    },
    {
        "line": 35,
        "fullcodeline": "const char *reg_name = NULL; /* literal */"
    },
    {
        "line": 203,
        "fullcodeline": "VariableLocation *location = R_NEW0 (VariableLocation);"
    },
    {
        "line": 10,
        "fullcodeline": "if (loc->kind != DW_AT_KIND_BLOCK && loc->kind != DW_AT_KIND_LOCLISTPTR && loc->kind != DW_AT_KIND_REFERENCE && loc->kind != DW_AT_KIND_CONSTANT) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (loc->kind == DW_AT_KIND_LOCLISTPTR || loc->kind == DW_AT_KIND_REFERENCE || loc->kind == DW_AT_KIND_CONSTANT) {"
    },
    {
        "line": 37,
        "fullcodeline": "for (i = 0; i < block.length; i++) {"
    },
    {
        "line": 200,
        "fullcodeline": "if (kind == LOCATION_UNKNOWN) {"
    },
    {
        "line": 15,
        "fullcodeline": "ut64 offset = loc->reference;"
    },
    {
        "line": 16,
        "fullcodeline": "RBinDwarfLocList *range_list = ht_up_find (ctx->locations, offset, NULL);"
    },
    {
        "line": 21,
        "fullcodeline": "RBinDwarfLocRange *range = find_largest_loc_range (range_list->list);"
    },
    {
        "line": 205,
        "fullcodeline": "location->reg_name = reg_name;"
    },
    {
        "line": 206,
        "fullcodeline": "location->reg_num = reg_num;"
    },
    {
        "line": 207,
        "fullcodeline": "location->kind = kind;"
    },
    {
        "line": 208,
        "fullcodeline": "location->offset = offset;"
    },
    {
        "line": 209,
        "fullcodeline": "location->address = address;"
    },
    {
        "line": 17,
        "fullcodeline": "if (!range_list) { /* for some reason offset isn't there, wrong parsing or malformed dwarf */"
    },
    {
        "line": 22,
        "fullcodeline": "if (!range) {"
    },
    {
        "line": 29,
        "fullcodeline": "block = loc->block;"
    },
    {
        "line": 45,
        "fullcodeline": "const ut8 *dump = &block.data[++i];"
    },
    {
        "line": 46,
        "fullcodeline": "offset = r_sleb128 (&dump, &block.data[loc->block.length]);"
    },
    {
        "line": 96,
        "fullcodeline": "reg_num = block.data[i] - DW_OP_reg0; // get the reg number"
    },
    {
        "line": 97,
        "fullcodeline": "reg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);"
    },
    {
        "line": 137,
        "fullcodeline": "reg_num = block.data[i] - DW_OP_breg0; // get the reg number"
    },
    {
        "line": 138,
        "fullcodeline": "const ut8 *buffer = &block.data[++i];"
    },
    {
        "line": 139,
        "fullcodeline": "offset = r_sleb128 (&buffer, &block.data[block.length]);"
    },
    {
        "line": 141,
        "fullcodeline": "i += buffer - &block.data[0];"
    },
    {
        "line": 142,
        "fullcodeline": "reg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);"
    },
    {
        "line": 151,
        "fullcodeline": "const ut8 *buffer = &block.data[++i];"
    },
    {
        "line": 152,
        "fullcodeline": "const ut8 *buf_end = &block.data[block.length];"
    },
    {
        "line": 153,
        "fullcodeline": "buffer = r_uleb128 (buffer, buf_end - buffer, &reg_num, NULL);"
    },
    {
        "line": 157,
        "fullcodeline": "offset = r_sleb128 (&buffer, buf_end);"
    },
    {
        "line": 158,
        "fullcodeline": "reg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);"
    },
    {
        "line": 164,
        "fullcodeline": "const int addr_size = ctx->anal->bits / 8;"
    },
    {
        "line": 165,
        "fullcodeline": "const ut8 *dump = &block.data[++i];"
    },
    {
        "line": 187,
        "fullcodeline": "kind = LOCATION_GLOBAL; // address"
    },
    {
        "line": 192,
        "fullcodeline": "kind = LOCATION_BP;"
    },
    {
        "line": 193,
        "fullcodeline": "offset += 16;"
    },
    {
        "line": 42,
        "fullcodeline": "if (i == block.length - 1) {"
    },
    {
        "line": 132,
        "fullcodeline": "if (i == block.length - 1) {"
    },
    {
        "line": 146,
        "fullcodeline": "if (i == block.length - 1) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (buffer == buf_end) {"
    },
    {
        "line": 167,
        "fullcodeline": "if (block.length - i < addr_size) {"
    },
    {
        "line": 50,
        "fullcodeline": "VariableLocation *location = parse_dwarf_location (ctx, frame_base, NULL);"
    },
    {
        "line": 172,
        "fullcodeline": "address = r_read_ble8 (dump);"
    },
    {
        "line": 175,
        "fullcodeline": "address = r_read_ble16 (dump, ctx->anal->big_endian);"
    },
    {
        "line": 178,
        "fullcodeline": "address = r_read_ble32 (dump, ctx->anal->big_endian);"
    },
    {
        "line": 181,
        "fullcodeline": "address = r_read_ble64 (dump, ctx->anal->big_endian);"
    },
    {
        "line": 184,
        "fullcodeline": "r_warn_if_reached (); /* weird addr_size */"
    },
    {
        "line": 52,
        "fullcodeline": "location->offset += offset;"
    }
]