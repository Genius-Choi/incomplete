[
    {
        "line": 31,
        "fullcodeline": "VariableLocationKind kind = LOCATION_UNKNOWN;"
    },
    {
        "line": 32,
        "fullcodeline": "st64 offset = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "ut64 address = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "ut64 reg_num = -1;"
    },
    {
        "line": 35,
        "fullcodeline": "const char *reg_name = NULL; /* literal */"
    },
    {
        "line": 206,
        "fullcodeline": "VariableLocation *location = R_NEW0 (VariableLocation);"
    },
    {
        "line": 10,
        "fullcodeline": "if (loc->kind != DW_AT_KIND_BLOCK && loc->kind != DW_AT_KIND_LOCLISTPTR && loc->kind != DW_AT_KIND_REFERENCE && loc->kind != DW_AT_KIND_CONSTANT) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (loc->kind == DW_AT_KIND_LOCLISTPTR || loc->kind == DW_AT_KIND_REFERENCE || loc->kind == DW_AT_KIND_CONSTANT) {"
    },
    {
        "line": 37,
        "fullcodeline": "for (i = 0; i < block.length; i++) {"
    },
    {
        "line": 203,
        "fullcodeline": "if (kind == LOCATION_UNKNOWN) {"
    },
    {
        "line": 15,
        "fullcodeline": "ut64 offset = loc->reference;"
    },
    {
        "line": 16,
        "fullcodeline": "RBinDwarfLocList *range_list = ht_up_find (ctx->locations, offset, NULL);"
    },
    {
        "line": 21,
        "fullcodeline": "RBinDwarfLocRange *range = find_largest_loc_range (range_list->list);"
    },
    {
        "line": 208,
        "fullcodeline": "location->reg_name = reg_name;"
    },
    {
        "line": 209,
        "fullcodeline": "location->reg_num = reg_num;"
    },
    {
        "line": 210,
        "fullcodeline": "location->kind = kind;"
    },
    {
        "line": 211,
        "fullcodeline": "location->offset = offset;"
    },
    {
        "line": 212,
        "fullcodeline": "location->address = address;"
    },
    {
        "line": 17,
        "fullcodeline": "if (!range_list) { /* for some reason offset isn't there, wrong parsing or malformed dwarf */"
    },
    {
        "line": 22,
        "fullcodeline": "if (!range) {"
    },
    {
        "line": 29,
        "fullcodeline": "block = loc->block;"
    },
    {
        "line": 45,
        "fullcodeline": "i++;"
    },
    {
        "line": 46,
        "fullcodeline": "const ut8 *dump = block.data + i;"
    },
    {
        "line": 51,
        "fullcodeline": "offset = r_sleb128 (&dump, block.data + loc->block.length);"
    },
    {
        "line": 99,
        "fullcodeline": "reg_num = block.data[i] - DW_OP_reg0; // get the reg number"
    },
    {
        "line": 100,
        "fullcodeline": "reg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);"
    },
    {
        "line": 140,
        "fullcodeline": "reg_num = block.data[i] - DW_OP_breg0; // get the reg number"
    },
    {
        "line": 141,
        "fullcodeline": "const ut8 *buffer = &block.data[++i];"
    },
    {
        "line": 142,
        "fullcodeline": "offset = r_sleb128 (&buffer, &block.data[block.length]);"
    },
    {
        "line": 144,
        "fullcodeline": "i += buffer - &block.data[0];"
    },
    {
        "line": 145,
        "fullcodeline": "reg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);"
    },
    {
        "line": 154,
        "fullcodeline": "const ut8 *buffer = &block.data[++i];"
    },
    {
        "line": 155,
        "fullcodeline": "const ut8 *buf_end = &block.data[block.length];"
    },
    {
        "line": 156,
        "fullcodeline": "buffer = r_uleb128 (buffer, buf_end - buffer, &reg_num, NULL);"
    },
    {
        "line": 160,
        "fullcodeline": "offset = r_sleb128 (&buffer, buf_end);"
    },
    {
        "line": 161,
        "fullcodeline": "reg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);"
    },
    {
        "line": 167,
        "fullcodeline": "const int addr_size = ctx->anal->bits / 8;"
    },
    {
        "line": 168,
        "fullcodeline": "const ut8 *dump = &block.data[++i];"
    },
    {
        "line": 190,
        "fullcodeline": "kind = LOCATION_GLOBAL; // address"
    },
    {
        "line": 195,
        "fullcodeline": "kind = LOCATION_BP;"
    },
    {
        "line": 196,
        "fullcodeline": "offset += 16;"
    },
    {
        "line": 42,
        "fullcodeline": "if (i == block.length - 1) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (loc->block.length > block.length) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (i == block.length - 1) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (i == block.length - 1) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (buffer == buf_end) {"
    },
    {
        "line": 170,
        "fullcodeline": "if (block.length - i < addr_size) {"
    },
    {
        "line": 55,
        "fullcodeline": "VariableLocation *location = parse_dwarf_location (ctx, frame_base, NULL);"
    },
    {
        "line": 175,
        "fullcodeline": "address = r_read_ble8 (dump);"
    },
    {
        "line": 178,
        "fullcodeline": "address = r_read_ble16 (dump, ctx->anal->big_endian);"
    },
    {
        "line": 181,
        "fullcodeline": "address = r_read_ble32 (dump, ctx->anal->big_endian);"
    },
    {
        "line": 184,
        "fullcodeline": "address = r_read_ble64 (dump, ctx->anal->big_endian);"
    },
    {
        "line": 187,
        "fullcodeline": "r_warn_if_reached (); /* weird addr_size */"
    },
    {
        "line": 57,
        "fullcodeline": "location->offset += offset;"
    }
]