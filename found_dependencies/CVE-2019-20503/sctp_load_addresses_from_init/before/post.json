[
    {
        "line": 19,
        "fullcodeline": "uint8_t random_store[SCTP_PARAM_BUFFER_SIZE];"
    },
    {
        "line": 20,
        "fullcodeline": "struct sctp_auth_random *p_random = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "uint16_t random_len = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "uint8_t hmacs_store[SCTP_PARAM_BUFFER_SIZE];"
    },
    {
        "line": 23,
        "fullcodeline": "struct sctp_auth_hmac_algo *hmacs = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "uint16_t hmacs_len = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "uint8_t saw_asconf = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "uint8_t saw_asconf_ack = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "uint8_t chunks_store[SCTP_PARAM_BUFFER_SIZE];"
    },
    {
        "line": 28,
        "fullcodeline": "struct sctp_auth_chunk_list *chunks = NULL;"
    },
    {
        "line": 29,
        "fullcodeline": "uint16_t num_chunks = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "int got_random = 0, got_hmacs = 0, got_chklist = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "peer_supports_idata = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "peer_supports_ecn = 0;"
    },
    {
        "line": 73,
        "fullcodeline": "peer_supports_prsctp = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "peer_supports_auth = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "peer_supports_asconf = 0;"
    },
    {
        "line": 76,
        "fullcodeline": "peer_supports_reconfig = 0;"
    },
    {
        "line": 77,
        "fullcodeline": "peer_supports_nrsack = 0;"
    },
    {
        "line": 78,
        "fullcodeline": "peer_supports_pktdrop = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {"
    },
    {
        "line": 84,
        "fullcodeline": "inp = stcb->sctp_ep;"
    },
    {
        "line": 85,
        "fullcodeline": "atomic_add_int(&stcb->asoc.refcnt, 1);"
    },
    {
        "line": 86,
        "fullcodeline": "stcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net_tmp, dst, stcb);"
    },
    {
        "line": 87,
        "fullcodeline": "atomic_add_int(&stcb->asoc.refcnt, -1);"
    },
    {
        "line": 138,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));"
    },
    {
        "line": 577,
        "fullcodeline": "TAILQ_FOREACH_SAFE(net, &stcb->asoc.nets, sctp_next, nnet) {"
    },
    {
        "line": 640,
        "fullcodeline": "keylen = sizeof(*p_random) + random_len + sizeof(*hmacs) + hmacs_len;"
    },
    {
        "line": 644,
        "fullcodeline": "new_key = sctp_alloc_key(keylen);"
    },
    {
        "line": 670,
        "fullcodeline": "stcb->asoc.authinfo.peer_random = new_key;"
    },
    {
        "line": 671,
        "fullcodeline": "sctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.assoc_keyid);"
    },
    {
        "line": 672,
        "fullcodeline": "sctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.recv_keyid);"
    },
    {
        "line": 81,
        "fullcodeline": "net->dest_state |= SCTP_ADDR_NOT_IN_ASSOC;"
    },
    {
        "line": 89,
        "fullcodeline": "if ((stcb_tmp == NULL && inp == stcb->sctp_ep) || inp == NULL) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (stcb->asoc.state == 0) {"
    },
    {
        "line": 591,
        "fullcodeline": "if ((stcb->asoc.ecn_supported == 1) &&"
    },
    {
        "line": 595,
        "fullcodeline": "if ((stcb->asoc.prsctp_supported == 1) &&"
    },
    {
        "line": 599,
        "fullcodeline": "if ((stcb->asoc.auth_supported == 1) &&"
    },
    {
        "line": 604,
        "fullcodeline": "if ((stcb->asoc.asconf_supported == 1) &&"
    },
    {
        "line": 610,
        "fullcodeline": "if ((stcb->asoc.reconfig_supported == 1) &&"
    },
    {
        "line": 614,
        "fullcodeline": "if ((stcb->asoc.idata_supported == 1) &&"
    },
    {
        "line": 618,
        "fullcodeline": "if ((stcb->asoc.nrsack_supported == 1) &&"
    },
    {
        "line": 622,
        "fullcodeline": "if ((stcb->asoc.pktdrop_supported == 1) &&"
    },
    {
        "line": 627,
        "fullcodeline": "if ((peer_supports_auth == 0) && (got_chklist == 1)) {"
    },
    {
        "line": 631,
        "fullcodeline": "if ((peer_supports_asconf == 1) && (peer_supports_auth == 0)) {"
    },
    {
        "line": 641,
        "fullcodeline": "if (chunks != NULL) {"
    },
    {
        "line": 645,
        "fullcodeline": "if (new_key != NULL) {"
    },
    {
        "line": 668,
        "fullcodeline": "if (stcb->asoc.authinfo.peer_random != NULL)"
    },
    {
        "line": 67,
        "fullcodeline": "sa = altsa;"
    },
    {
        "line": 140,
        "fullcodeline": "ptype = ntohs(phdr->param_type);"
    },
    {
        "line": 141,
        "fullcodeline": "plen = ntohs(phdr->param_length);"
    },
    {
        "line": 569,
        "fullcodeline": "offset += SCTP_SIZE32(plen);"
    },
    {
        "line": 573,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset, &param_buf,"
    },
    {
        "line": 578,
        "fullcodeline": "if ((net->dest_state & SCTP_ADDR_NOT_IN_ASSOC) =="
    },
    {
        "line": 592,
        "fullcodeline": "(peer_supports_ecn == 0)) {"
    },
    {
        "line": 593,
        "fullcodeline": "stcb->asoc.ecn_supported = 0;"
    },
    {
        "line": 596,
        "fullcodeline": "(peer_supports_prsctp == 0)) {"
    },
    {
        "line": 597,
        "fullcodeline": "stcb->asoc.prsctp_supported = 0;"
    },
    {
        "line": 600,
        "fullcodeline": "((peer_supports_auth == 0) ||"
    },
    {
        "line": 602,
        "fullcodeline": "stcb->asoc.auth_supported = 0;"
    },
    {
        "line": 605,
        "fullcodeline": "((peer_supports_asconf == 0) || (peer_supports_asconf_ack == 0) ||"
    },
    {
        "line": 608,
        "fullcodeline": "stcb->asoc.asconf_supported = 0;"
    },
    {
        "line": 611,
        "fullcodeline": "(peer_supports_reconfig == 0)) {"
    },
    {
        "line": 612,
        "fullcodeline": "stcb->asoc.reconfig_supported = 0;"
    },
    {
        "line": 615,
        "fullcodeline": "(peer_supports_idata == 0)) {"
    },
    {
        "line": 616,
        "fullcodeline": "stcb->asoc.idata_supported = 0;"
    },
    {
        "line": 619,
        "fullcodeline": "(peer_supports_nrsack == 0)) {"
    },
    {
        "line": 620,
        "fullcodeline": "stcb->asoc.nrsack_supported = 0;"
    },
    {
        "line": 623,
        "fullcodeline": "(peer_supports_pktdrop == 0)){"
    },
    {
        "line": 624,
        "fullcodeline": "stcb->asoc.pktdrop_supported = 0;"
    },
    {
        "line": 642,
        "fullcodeline": "keylen += sizeof(*chunks) + num_chunks;"
    },
    {
        "line": 669,
        "fullcodeline": "sctp_free_key(stcb->asoc.authinfo.peer_random);"
    },
    {
        "line": 69,
        "fullcodeline": "sa = src;"
    },
    {
        "line": 135,
        "fullcodeline": "return (-4);"
    },
    {
        "line": 146,
        "fullcodeline": "if (offset + plen > limit) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (plen == 0) {"
    },
    {
        "line": 337,
        "fullcodeline": "if (ptype == SCTP_ECN_CAPABLE) {"
    },
    {
        "line": 570,
        "fullcodeline": "if (offset >= limit) {"
    },
    {
        "line": 583,
        "fullcodeline": "TAILQ_REMOVE(&stcb->asoc.nets, net, sctp_next);"
    },
    {
        "line": 584,
        "fullcodeline": "sctp_free_remote_addr(net);"
    },
    {
        "line": 601,
        "fullcodeline": "(got_random == 0) || (got_hmacs == 0))) {"
    },
    {
        "line": 607,
        "fullcodeline": "(saw_asconf == 0) || (saw_asconf_ack == 0))) {"
    },
    {
        "line": 629,
        "fullcodeline": "return (-31);"
    },
    {
        "line": 633,
        "fullcodeline": "return (-32);"
    },
    {
        "line": 647,
        "fullcodeline": "if (p_random != NULL) {"
    },
    {
        "line": 654,
        "fullcodeline": "if (chunks != NULL) {"
    },
    {
        "line": 660,
        "fullcodeline": "if (hmacs != NULL) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (net_tmp != NULL && stcb_tmp == stcb) {"
    },
    {
        "line": 338,
        "fullcodeline": "peer_supports_ecn = 1;"
    },
    {
        "line": 585,
        "fullcodeline": "if (net == stcb->asoc.primary_destination) {"
    },
    {
        "line": 634,
        "fullcodeline": "} else if ((peer_supports_asconf == 1) &&"
    },
    {
        "line": 648,
        "fullcodeline": "keylen = sizeof(*p_random) + random_len;"
    },
    {
        "line": 649,
        "fullcodeline": "memcpy(new_key->key, p_random, keylen);"
    },
    {
        "line": 655,
        "fullcodeline": "memcpy(new_key->key + keylen, chunks,"
    },
    {
        "line": 657,
        "fullcodeline": "keylen += sizeof(*chunks) + num_chunks;"
    },
    {
        "line": 661,
        "fullcodeline": "memcpy(new_key->key + keylen, hmacs,"
    },
    {
        "line": 666,
        "fullcodeline": "return (-34);"
    },
    {
        "line": 125,
        "fullcodeline": "net_tmp->dest_state &= ~SCTP_ADDR_NOT_IN_ASSOC;"
    },
    {
        "line": 586,
        "fullcodeline": "stcb->asoc.primary_destination = NULL;"
    },
    {
        "line": 587,
        "fullcodeline": "sctp_select_primary_destination(stcb);"
    },
    {
        "line": 606,
        "fullcodeline": "(stcb->asoc.auth_supported == 0) ||"
    },
    {
        "line": 636,
        "fullcodeline": "((saw_asconf == 0) || (saw_asconf_ack == 0))) {"
    },
    {
        "line": 651,
        "fullcodeline": "keylen = 0;"
    },
    {
        "line": 656,
        "fullcodeline": "sizeof(*chunks) + num_chunks);"
    },
    {
        "line": 662,
        "fullcodeline": "sizeof(*hmacs) + hmacs_len);"
    },
    {
        "line": 339,
        "fullcodeline": "} else if (ptype == SCTP_ULP_ADAPTATION) {"
    },
    {
        "line": 635,
        "fullcodeline": "(peer_supports_auth == 1) &&"
    },
    {
        "line": 637,
        "fullcodeline": "return (-33);"
    },
    {
        "line": 126,
        "fullcodeline": "} else if (stcb_tmp != stcb) {"
    },
    {
        "line": 340,
        "fullcodeline": "if (stcb->asoc.state != SCTP_STATE_OPEN) {"
    },
    {
        "line": 130,
        "fullcodeline": "return (-3);"
    },
    {
        "line": 343,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset,"
    },
    {
        "line": 345,
        "fullcodeline": "aip = (struct sctp_adaptation_layer_indication *)phdr;"
    },
    {
        "line": 351,
        "fullcodeline": "} else if (ptype == SCTP_SET_PRIM_ADDR) {"
    },
    {
        "line": 129,
        "fullcodeline": "SCTP_TCB_UNLOCK(stcb_tmp);"
    },
    {
        "line": 354,
        "fullcodeline": "struct sockaddr *lsa = NULL;"
    },
    {
        "line": 365,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset,"
    },
    {
        "line": 371,
        "fullcodeline": "fee = (struct sctp_asconf_addr_param *)phdr;"
    },
    {
        "line": 372,
        "fullcodeline": "lptype = ntohs(fee->addrp.ph.param_type);"
    },
    {
        "line": 344,
        "fullcodeline": "(struct sctp_paramhdr *)&ai, sizeof(ai));"
    },
    {
        "line": 347,
        "fullcodeline": "stcb->asoc.peers_adaptation = ntohl(aip->indication);"
    },
    {
        "line": 348,
        "fullcodeline": "stcb->asoc.adaptation_needed = 1;"
    },
    {
        "line": 359,
        "fullcodeline": "if (stcb->asoc.asconf_supported == 0) {"
    },
    {
        "line": 362,
        "fullcodeline": "if (plen > sizeof(lstore)) {"
    },
    {
        "line": 368,
        "fullcodeline": "if (phdr == NULL) {"
    },
    {
        "line": 366,
        "fullcodeline": "(struct sctp_paramhdr *)&lstore,"
    },
    {
        "line": 407,
        "fullcodeline": "(void)sctp_set_primary_addr(stcb, sa, NULL);"
    },
    {
        "line": 409,
        "fullcodeline": "} else if (ptype == SCTP_HAS_NAT_SUPPORT) {"
    },
    {
        "line": 360,
        "fullcodeline": "return (-100);"
    },
    {
        "line": 363,
        "fullcodeline": "return (-23);"
    },
    {
        "line": 369,
        "fullcodeline": "return (-24);"
    },
    {
        "line": 410,
        "fullcodeline": "stcb->asoc.peer_supports_nat = 1;"
    },
    {
        "line": 411,
        "fullcodeline": "} else if (ptype == SCTP_PRSCTP_SUPPORTED) {"
    },
    {
        "line": 413,
        "fullcodeline": "peer_supports_prsctp = 1;"
    },
    {
        "line": 414,
        "fullcodeline": "} else if (ptype == SCTP_SUPPORTED_CHUNK_EXT) {"
    },
    {
        "line": 417,
        "fullcodeline": "uint8_t local_store[SCTP_PARAM_BUFFER_SIZE];"
    },
    {
        "line": 423,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset,"
    },
    {
        "line": 428,
        "fullcodeline": "pr_supported = (struct sctp_supported_chunk_types_param *)phdr;"
    },
    {
        "line": 429,
        "fullcodeline": "num_ent = plen - sizeof(struct sctp_paramhdr);"
    },
    {
        "line": 420,
        "fullcodeline": "if (plen > sizeof(local_store)) {"
    },
    {
        "line": 425,
        "fullcodeline": "if (phdr == NULL) {"
    },
    {
        "line": 430,
        "fullcodeline": "for (i = 0; i < num_ent; i++) {"
    },
    {
        "line": 424,
        "fullcodeline": "(struct sctp_paramhdr *)&local_store, plen);"
    },
    {
        "line": 462,
        "fullcodeline": "} else if (ptype == SCTP_RANDOM) {"
    },
    {
        "line": 421,
        "fullcodeline": "return (-35);"
    },
    {
        "line": 426,
        "fullcodeline": "return (-25);"
    },
    {
        "line": 469,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset,"
    },
    {
        "line": 474,
        "fullcodeline": "p_random = (struct sctp_auth_random *)phdr;"
    },
    {
        "line": 475,
        "fullcodeline": "random_len = plen - sizeof(*p_random);"
    },
    {
        "line": 481,
        "fullcodeline": "got_random = 1;"
    },
    {
        "line": 433,
        "fullcodeline": "peer_supports_asconf = 1;"
    },
    {
        "line": 436,
        "fullcodeline": "peer_supports_asconf_ack = 1;"
    },
    {
        "line": 439,
        "fullcodeline": "peer_supports_prsctp = 1;"
    },
    {
        "line": 442,
        "fullcodeline": "peer_supports_pktdrop = 1;"
    },
    {
        "line": 445,
        "fullcodeline": "peer_supports_nrsack = 1;"
    },
    {
        "line": 448,
        "fullcodeline": "peer_supports_reconfig = 1;"
    },
    {
        "line": 451,
        "fullcodeline": "peer_supports_auth = 1;"
    },
    {
        "line": 454,
        "fullcodeline": "peer_supports_idata = 1;"
    },
    {
        "line": 463,
        "fullcodeline": "if (plen > sizeof(random_store))"
    },
    {
        "line": 472,
        "fullcodeline": "if (phdr == NULL)"
    },
    {
        "line": 477,
        "fullcodeline": "if (random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED) {"
    },
    {
        "line": 470,
        "fullcodeline": "(struct sctp_paramhdr *)random_store,"
    },
    {
        "line": 478,
        "fullcodeline": "SCTPDBG(SCTP_DEBUG_AUTH1, \"SCTP: invalid RANDOM len\\n\");"
    },
    {
        "line": 482,
        "fullcodeline": "} else if (ptype == SCTP_HMAC_LIST) {"
    },
    {
        "line": 473,
        "fullcodeline": "return (-26);"
    },
    {
        "line": 479,
        "fullcodeline": "return (-27);"
    },
    {
        "line": 492,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset,"
    },
    {
        "line": 497,
        "fullcodeline": "hmacs = (struct sctp_auth_hmac_algo *)phdr;"
    },
    {
        "line": 498,
        "fullcodeline": "hmacs_len = plen - sizeof(*hmacs);"
    },
    {
        "line": 499,
        "fullcodeline": "num_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);"
    },
    {
        "line": 506,
        "fullcodeline": "stcb->asoc.peer_hmacs = sctp_alloc_hmaclist(num_hmacs);"
    },
    {
        "line": 513,
        "fullcodeline": "got_hmacs = 1;"
    },
    {
        "line": 486,
        "fullcodeline": "if (plen > sizeof(hmacs_store))"
    },
    {
        "line": 495,
        "fullcodeline": "if (phdr == NULL)"
    },
    {
        "line": 501,
        "fullcodeline": "if (sctp_verify_hmac_param(hmacs, num_hmacs)) {"
    },
    {
        "line": 504,
        "fullcodeline": "if (stcb->asoc.peer_hmacs != NULL)"
    },
    {
        "line": 507,
        "fullcodeline": "if (stcb->asoc.peer_hmacs != NULL) {"
    },
    {
        "line": 493,
        "fullcodeline": "(struct sctp_paramhdr *)hmacs_store,"
    },
    {
        "line": 505,
        "fullcodeline": "sctp_free_hmaclist(stcb->asoc.peer_hmacs);"
    },
    {
        "line": 514,
        "fullcodeline": "} else if (ptype == SCTP_CHUNK_LIST) {"
    },
    {
        "line": 496,
        "fullcodeline": "return (-28);"
    },
    {
        "line": 502,
        "fullcodeline": "return (-29);"
    },
    {
        "line": 508,
        "fullcodeline": "for (i = 0; i < num_hmacs; i++) {"
    },
    {
        "line": 523,
        "fullcodeline": "phdr = sctp_get_next_param(m, offset,"
    },
    {
        "line": 528,
        "fullcodeline": "chunks = (struct sctp_auth_chunk_list *)phdr;"
    },
    {
        "line": 529,
        "fullcodeline": "num_chunks = plen - sizeof(*chunks);"
    },
    {
        "line": 544,
        "fullcodeline": "got_chklist = 1;"
    },
    {
        "line": 509,
        "fullcodeline": "(void)sctp_auth_add_hmacid(stcb->asoc.peer_hmacs,"
    },
    {
        "line": 517,
        "fullcodeline": "if (plen > sizeof(chunks_store))"
    },
    {
        "line": 526,
        "fullcodeline": "if (phdr == NULL)"
    },
    {
        "line": 530,
        "fullcodeline": "if (stcb->asoc.peer_auth_chunks != NULL)"
    },
    {
        "line": 534,
        "fullcodeline": "for (i = 0; i < num_chunks; i++) {"
    },
    {
        "line": 524,
        "fullcodeline": "(struct sctp_paramhdr *)chunks_store,"
    },
    {
        "line": 531,
        "fullcodeline": "sctp_clear_chunklist(stcb->asoc.peer_auth_chunks);"
    },
    {
        "line": 535,
        "fullcodeline": "(void)sctp_auth_add_chunk(chunks->chunk_types[i],"
    },
    {
        "line": 545,
        "fullcodeline": "} else if ((ptype == SCTP_HEARTBEAT_INFO) ||"
    },
    {
        "line": 527,
        "fullcodeline": "return (-30);"
    },
    {
        "line": 533,
        "fullcodeline": "stcb->asoc.peer_auth_chunks = sctp_alloc_chunklist();"
    },
    {
        "line": 538,
        "fullcodeline": "if (chunks->chunk_types[i] == SCTP_ASCONF)"
    },
    {
        "line": 540,
        "fullcodeline": "if (chunks->chunk_types[i] == SCTP_ASCONF_ACK)"
    },
    {
        "line": 553,
        "fullcodeline": "(ptype == SCTP_SUCCESS_REPORT)) {"
    },
    {
        "line": 539,
        "fullcodeline": "saw_asconf = 1;"
    },
    {
        "line": 541,
        "fullcodeline": "saw_asconf_ack = 1;"
    },
    {
        "line": 552,
        "fullcodeline": "(ptype == SCTP_ERROR_CAUSE_IND) ||"
    },
    {
        "line": 551,
        "fullcodeline": "(ptype == SCTP_DEL_IP_ADDRESS) ||"
    },
    {
        "line": 556,
        "fullcodeline": "if ((ptype & 0x8000) == 0x0000) {"
    },
    {
        "line": 550,
        "fullcodeline": "(ptype == SCTP_ADD_IP_ADDRESS) ||"
    },
    {
        "line": 549,
        "fullcodeline": "(ptype == SCTP_SUPPORTED_ADDRTYPE) ||"
    },
    {
        "line": 548,
        "fullcodeline": "(ptype == SCTP_COOKIE_PRESERVE) ||"
    },
    {
        "line": 547,
        "fullcodeline": "(ptype == SCTP_UNRECOG_PARAM) ||"
    },
    {
        "line": 546,
        "fullcodeline": "(ptype == SCTP_STATE_COOKIE) ||"
    }
]