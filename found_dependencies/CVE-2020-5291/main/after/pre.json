[
    {
        "line": 5,
        "fullcodeline": "const char *base_path = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *old_cwd = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int event_fd = -1;"
    },
    {
        "line": 10,
        "fullcodeline": "int child_wait_fd = -1;"
    },
    {
        "line": 11,
        "fullcodeline": "int setup_finished_pipe[] = {-1, -1};"
    },
    {
        "line": 18,
        "fullcodeline": "cleanup_free char *seccomp_data = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "cleanup_free char *args_data = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "int intermediate_pids_sockets[2] = {-1, -1};"
    },
    {
        "line": 32,
        "fullcodeline": "real_uid = getuid ();"
    },
    {
        "line": 33,
        "fullcodeline": "real_gid = getgid ();"
    },
    {
        "line": 36,
        "fullcodeline": "acquire_privs ();"
    },
    {
        "line": 45,
        "fullcodeline": "read_overflowids ();"
    },
    {
        "line": 47,
        "fullcodeline": "argv0 = argv[0];"
    },
    {
        "line": 52,
        "fullcodeline": "argv++;"
    },
    {
        "line": 53,
        "fullcodeline": "argc--;"
    },
    {
        "line": 58,
        "fullcodeline": "parse_args (&argc, (const char ***) &argv);"
    },
    {
        "line": 61,
        "fullcodeline": "args_data = opt_args_data;"
    },
    {
        "line": 62,
        "fullcodeline": "opt_args_data = NULL;"
    },
    {
        "line": 142,
        "fullcodeline": "__debug__ ((\"Creating root mount point\\n\"));"
    },
    {
        "line": 166,
        "fullcodeline": "proc_fd = open (\"/proc\", O_PATH);"
    },
    {
        "line": 176,
        "fullcodeline": "base_path = \"/tmp\";"
    },
    {
        "line": 178,
        "fullcodeline": "__debug__ ((\"creating new namespace\\n\"));"
    },
    {
        "line": 188,
        "fullcodeline": "block_sigchild ();"
    },
    {
        "line": 190,
        "fullcodeline": "clone_flags = SIGCHLD | CLONE_NEWNS;"
    },
    {
        "line": 219,
        "fullcodeline": "child_wait_fd = eventfd (0, EFD_CLOEXEC);"
    },
    {
        "line": 248,
        "fullcodeline": "pid = raw_clone (clone_flags, NULL);"
    },
    {
        "line": 262,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 263,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 395,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 396,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 417,
        "fullcodeline": "old_umask = umask (0);"
    },
    {
        "line": 432,
        "fullcodeline": "old_cwd = get_current_dir_name ();"
    },
    {
        "line": 599,
        "fullcodeline": "new_cwd = \"/\";"
    },
    {
        "line": 29,
        "fullcodeline": "if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))"
    },
    {
        "line": 39,
        "fullcodeline": "if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)"
    },
    {
        "line": 49,
        "fullcodeline": "if (isatty (1))"
    },
    {
        "line": 55,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 64,
        "fullcodeline": "if ((requested_caps[0] || requested_caps[1]) && is_privileged)"
    },
    {
        "line": 67,
        "fullcodeline": "if (opt_userns_block_fd != -1 && !opt_unshare_user)"
    },
    {
        "line": 70,
        "fullcodeline": "if (opt_userns_block_fd != -1 && opt_info_fd == -1)"
    },
    {
        "line": 73,
        "fullcodeline": "if (opt_userns_fd != -1 && opt_unshare_user)"
    },
    {
        "line": 76,
        "fullcodeline": "if (opt_userns_fd != -1 && opt_unshare_user_try)"
    },
    {
        "line": 91,
        "fullcodeline": "if (opt_userns_fd != -1 && is_privileged)"
    },
    {
        "line": 94,
        "fullcodeline": "if (opt_userns2_fd != -1 && is_privileged)"
    },
    {
        "line": 99,
        "fullcodeline": "if (!is_privileged && getuid () != 0 && opt_userns_fd == -1)"
    },
    {
        "line": 108,
        "fullcodeline": "if (opt_unshare_user_try &&"
    },
    {
        "line": 139,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 144,
        "fullcodeline": "if (opt_sandbox_uid == -1)"
    },
    {
        "line": 146,
        "fullcodeline": "if (opt_sandbox_gid == -1)"
    },
    {
        "line": 149,
        "fullcodeline": "if (!opt_unshare_user && opt_userns_fd == -1 && opt_sandbox_uid != real_uid)"
    },
    {
        "line": 152,
        "fullcodeline": "if (!opt_unshare_user && opt_userns_fd == -1 && opt_sandbox_gid != real_gid)"
    },
    {
        "line": 155,
        "fullcodeline": "if (!opt_unshare_uts && opt_sandbox_hostname != NULL)"
    },
    {
        "line": 158,
        "fullcodeline": "if (opt_as_pid_1 && !opt_unshare_pid)"
    },
    {
        "line": 161,
        "fullcodeline": "if (opt_as_pid_1 && lock_files != NULL)"
    },
    {
        "line": 167,
        "fullcodeline": "if (proc_fd == -1)"
    },
    {
        "line": 180,
        "fullcodeline": "if (opt_unshare_pid && !opt_as_pid_1)"
    },
    {
        "line": 193,
        "fullcodeline": "if (opt_unshare_pid && opt_pidns_fd == -1)"
    },
    {
        "line": 220,
        "fullcodeline": "if (child_wait_fd == -1)"
    },
    {
        "line": 224,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 233,
        "fullcodeline": "if (opt_userns_fd > 0 && setns (opt_userns_fd, CLONE_NEWUSER) != 0)"
    },
    {
        "line": 241,
        "fullcodeline": "if (opt_pidns_fd != -1)"
    },
    {
        "line": 249,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 265,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 337,
        "fullcodeline": "if (opt_pidns_fd > 0)"
    },
    {
        "line": 376,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 379,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 383,
        "fullcodeline": "res = read (child_wait_fd, &val, 8);"
    },
    {
        "line": 397,
        "fullcodeline": "if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 516,
        "fullcodeline": "if (umount2 (\"oldroot\", MNT_DETACH))"
    },
    {
        "line": 525,
        "fullcodeline": "{ cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);"
    },
    {
        "line": 573,
        "fullcodeline": "drop_privs (!is_privileged, TRUE);"
    },
    {
        "line": 575,
        "fullcodeline": "if (opt_block_fd != -1)"
    },
    {
        "line": 582,
        "fullcodeline": "if (opt_seccomp_fd != -1)"
    },
    {
        "line": 622,
        "fullcodeline": "if (opt_new_session &&"
    },
    {
        "line": 667,
        "fullcodeline": "__debug__ ((\"launch executable %s\\n\", argv[0]));"
    },
    {
        "line": 669,
        "fullcodeline": "if (proc_fd != -1)"
    },
    {
        "line": 695,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 30,
        "fullcodeline": "print_version_and_exit ();"
    },
    {
        "line": 40,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");"
    },
    {
        "line": 50,
        "fullcodeline": "host_tty_dev = ttyname (1);"
    },
    {
        "line": 56,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 65,
        "fullcodeline": "die (\"--cap-add in setuid mode can be used only by root\");"
    },
    {
        "line": 68,
        "fullcodeline": "die (\"--userns-block-fd requires --unshare-user\");"
    },
    {
        "line": 71,
        "fullcodeline": "die (\"--userns-block-fd requires --info-fd\");"
    },
    {
        "line": 74,
        "fullcodeline": "die (\"--userns not compatible --unshare-user\");"
    },
    {
        "line": 77,
        "fullcodeline": "die (\"--userns not compatible --unshare-user-try\");"
    },
    {
        "line": 92,
        "fullcodeline": "die (\"--userns doesn't work in setuid mode\");"
    },
    {
        "line": 95,
        "fullcodeline": "die (\"--userns2 doesn't work in setuid mode\");"
    },
    {
        "line": 100,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 109,
        "fullcodeline": "stat (\"/proc/self/ns/user\", &sbuf) == 0)"
    },
    {
        "line": 111,
        "fullcodeline": "bool disabled = FALSE;"
    },
    {
        "line": 140,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 145,
        "fullcodeline": "opt_sandbox_uid = real_uid;"
    },
    {
        "line": 147,
        "fullcodeline": "opt_sandbox_gid = real_gid;"
    },
    {
        "line": 150,
        "fullcodeline": "die (\"Specifying --uid requires --unshare-user or --userns\");"
    },
    {
        "line": 153,
        "fullcodeline": "die (\"Specifying --gid requires --unshare-user or --userns\");"
    },
    {
        "line": 156,
        "fullcodeline": "die (\"Specifying --hostname requires --unshare-uts\");"
    },
    {
        "line": 159,
        "fullcodeline": "die (\"Specifying --as-pid-1 requires --unshare-pid\");"
    },
    {
        "line": 162,
        "fullcodeline": "die (\"Specifying --as-pid-1 and --lock-file is not permitted\");"
    },
    {
        "line": 168,
        "fullcodeline": "die_with_error (\"Can't open /proc\");"
    },
    {
        "line": 182,
        "fullcodeline": "event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);"
    },
    {
        "line": 192,
        "fullcodeline": "clone_flags |= CLONE_NEWUSER;"
    },
    {
        "line": 194,
        "fullcodeline": "clone_flags |= CLONE_NEWPID;"
    },
    {
        "line": 196,
        "fullcodeline": "clone_flags |= CLONE_NEWNET;"
    },
    {
        "line": 198,
        "fullcodeline": "clone_flags |= CLONE_NEWIPC;"
    },
    {
        "line": 200,
        "fullcodeline": "clone_flags |= CLONE_NEWUTS;"
    },
    {
        "line": 210,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 214,
        "fullcodeline": "opt_unshare_cgroup = !stat (\"/proc/self/ns/cgroup\", &sbuf);"
    },
    {
        "line": 221,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 227,
        "fullcodeline": "ret = pipe2 (setup_finished_pipe, O_CLOEXEC);"
    },
    {
        "line": 237,
        "fullcodeline": "die_with_error (\"Joining specified user namespace failed\");"
    },
    {
        "line": 244,
        "fullcodeline": "prctl (PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0);"
    },
    {
        "line": 245,
        "fullcodeline": "create_pid_socketpair (intermediate_pids_sockets);"
    },
    {
        "line": 259,
        "fullcodeline": "die_with_error (\"Creating new namespace failed\");"
    },
    {
        "line": 277,
        "fullcodeline": "namespace_ids_read (pid);"
    },
    {
        "line": 300,
        "fullcodeline": "drop_privs (FALSE, FALSE);"
    },
    {
        "line": 303,
        "fullcodeline": "handle_die_with_parent ();"
    },
    {
        "line": 329,
        "fullcodeline": "val = 1;"
    },
    {
        "line": 330,
        "fullcodeline": "res = write (child_wait_fd, &val, 8);"
    },
    {
        "line": 332,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 358,
        "fullcodeline": "send_pid_on_socket (intermediate_pids_sockets[1]);"
    },
    {
        "line": 412,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 425,
        "fullcodeline": "if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)"
    },
    {
        "line": 429,
        "fullcodeline": "if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)"
    },
    {
        "line": 436,
        "fullcodeline": "if (chdir (base_path) != 0)"
    },
    {
        "line": 448,
        "fullcodeline": "if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)"
    },
    {
        "line": 457,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 463,
        "fullcodeline": "int privsep_sockets[2];"
    },
    {
        "line": 468,
        "fullcodeline": "child = fork ();"
    },
    {
        "line": 513,
        "fullcodeline": "if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)"
    },
    {
        "line": 526,
        "fullcodeline": "if (oldrootfd < 0)"
    },
    {
        "line": 550,
        "fullcodeline": "if (opt_userns2_fd > 0 && setns (opt_userns2_fd, CLONE_NEWUSER) != 0)"
    },
    {
        "line": 553,
        "fullcodeline": "if (opt_unshare_user &&"
    },
    {
        "line": 555,
        "fullcodeline": "opt_userns_block_fd == -1)"
    },
    {
        "line": 565,
        "fullcodeline": "drop_cap_bounding_set (FALSE);"
    },
    {
        "line": 567,
        "fullcodeline": "write_uid_gid_map (opt_sandbox_uid, ns_uid,"
    },
    {
        "line": 577,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 584,
        "fullcodeline": "seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);"
    },
    {
        "line": 591,
        "fullcodeline": "seccomp_prog.len = seccomp_len / 8;"
    },
    {
        "line": 592,
        "fullcodeline": "seccomp_prog.filter = (struct sock_filter *) seccomp_data;"
    },
    {
        "line": 604,
        "fullcodeline": "new_cwd = opt_chdir_path;"
    },
    {
        "line": 623,
        "fullcodeline": "setsid () == (pid_t) -1)"
    },
    {
        "line": 626,
        "fullcodeline": "if (label_exec (opt_exec_label) == -1)"
    },
    {
        "line": 627,
        "fullcodeline": "die_with_error (\"label_exec %s\", argv[0]);"
    },
    {
        "line": 631,
        "fullcodeline": "if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))"
    },
    {
        "line": 639,
        "fullcodeline": "pid = fork ();"
    },
    {
        "line": 691,
        "fullcodeline": "if (seccomp_data != NULL &&"
    },
    {
        "line": 692,
        "fullcodeline": "prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)"
    },
    {
        "line": 697,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 703,
        "fullcodeline": "if (execvp (argv[0], argv) == -1)"
    },
    {
        "line": 114,
        "fullcodeline": "if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)"
    },
    {
        "line": 123,
        "fullcodeline": "if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)"
    },
    {
        "line": 135,
        "fullcodeline": "if (!disabled)"
    },
    {
        "line": 183,
        "fullcodeline": "if (event_fd == -1)"
    },
    {
        "line": 203,
        "fullcodeline": "if (stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 228,
        "fullcodeline": "if (ret == -1)"
    },
    {
        "line": 235,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 269,
        "fullcodeline": "if (intermediate_pids_sockets[0] != -1)"
    },
    {
        "line": 279,
        "fullcodeline": "if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 296,
        "fullcodeline": "if (opt_userns2_fd > 0 && setns (opt_userns2_fd, CLONE_NEWUSER) != 0)"
    },
    {
        "line": 305,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 313,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 321,
        "fullcodeline": "if (opt_userns_block_fd != -1)"
    },
    {
        "line": 334,
        "fullcodeline": "return monitor_child (event_fd, pid, setup_finished_pipe[0]);"
    },
    {
        "line": 414,
        "fullcodeline": "-1, TRUE, FALSE);"
    },
    {
        "line": 469,
        "fullcodeline": "if (child == -1)"
    },
    {
        "line": 472,
        "fullcodeline": "if (child == 0)"
    },
    {
        "line": 507,
        "fullcodeline": "setup_newroot (opt_unshare_pid, -1);"
    },
    {
        "line": 528,
        "fullcodeline": "if (chdir (\"/newroot\") != 0)"
    },
    {
        "line": 540,
        "fullcodeline": "if (pivot_root (\".\", \".\") != 0)"
    },
    {
        "line": 542,
        "fullcodeline": "if (fchdir (oldrootfd) < 0)"
    },
    {
        "line": 544,
        "fullcodeline": "if (umount2 (\".\", MNT_DETACH) < 0)"
    },
    {
        "line": 546,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 554,
        "fullcodeline": "(ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&"
    },
    {
        "line": 569,
        "fullcodeline": "-1, FALSE, FALSE);"
    },
    {
        "line": 578,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));"
    },
    {
        "line": 585,
        "fullcodeline": "if (seccomp_data == NULL)"
    },
    {
        "line": 602,
        "fullcodeline": "if (chdir (opt_chdir_path))"
    },
    {
        "line": 640,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 643,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 676,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 698,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 705,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 116,
        "fullcodeline": "cleanup_free char *enable = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");"
    },
    {
        "line": 125,
        "fullcodeline": "cleanup_free char *max_user_ns = NULL;"
    },
    {
        "line": 126,
        "fullcodeline": "max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");"
    },
    {
        "line": 136,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 184,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 216,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 229,
        "fullcodeline": "die_with_error (\"pipe2()\");"
    },
    {
        "line": 236,
        "fullcodeline": "die (\"Joining the specified user namespace failed, it might not be a descendant of the current user namespace.\");"
    },
    {
        "line": 271,
        "fullcodeline": "close (intermediate_pids_sockets[1]);"
    },
    {
        "line": 272,
        "fullcodeline": "pid = read_pid_from_socket (intermediate_pids_sockets[0]);"
    },
    {
        "line": 273,
        "fullcodeline": "close (intermediate_pids_sockets[0]);"
    },
    {
        "line": 289,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 297,
        "fullcodeline": "die_with_error (\"Setting userns2 failed\");"
    },
    {
        "line": 307,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\", pid);"
    },
    {
        "line": 308,
        "fullcodeline": "dump_info (opt_info_fd, output, TRUE);"
    },
    {
        "line": 309,
        "fullcodeline": "namespace_ids_write (opt_info_fd, FALSE);"
    },
    {
        "line": 310,
        "fullcodeline": "dump_info (opt_info_fd, \"\\n}\\n\", TRUE);"
    },
    {
        "line": 311,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 315,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i\", pid);"
    },
    {
        "line": 316,
        "fullcodeline": "dump_info (opt_json_status_fd, output, TRUE);"
    },
    {
        "line": 317,
        "fullcodeline": "namespace_ids_write (opt_json_status_fd, TRUE);"
    },
    {
        "line": 318,
        "fullcodeline": "dump_info (opt_json_status_fd, \" }\\n\", TRUE);"
    },
    {
        "line": 323,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 324,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));"
    },
    {
        "line": 325,
        "fullcodeline": "close (opt_userns_block_fd);"
    },
    {
        "line": 339,
        "fullcodeline": "if (setns (opt_pidns_fd, CLONE_NEWPID) != 0)"
    },
    {
        "line": 408,
        "fullcodeline": "ns_uid = 0;"
    },
    {
        "line": 409,
        "fullcodeline": "ns_gid = 0;"
    },
    {
        "line": 465,
        "fullcodeline": "if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)"
    },
    {
        "line": 475,
        "fullcodeline": "drop_privs (FALSE, TRUE);"
    },
    {
        "line": 477,
        "fullcodeline": "setup_newroot (opt_unshare_pid, privsep_sockets[1]);"
    },
    {
        "line": 588,
        "fullcodeline": "if (seccomp_len % 8 != 0)"
    },
    {
        "line": 603,
        "fullcodeline": "die_with_error (\"Can't chdir to %s\", opt_chdir_path);"
    },
    {
        "line": 707,
        "fullcodeline": "int saved_errno = errno;"
    },
    {
        "line": 708,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "if (enable != NULL && enable[0] == 'N')"
    },
    {
        "line": 127,
        "fullcodeline": "if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)"
    },
    {
        "line": 205,
        "fullcodeline": "if (errno == ENOENT)"
    },
    {
        "line": 253,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 488,
        "fullcodeline": "unpriv_socket = privsep_sockets[0];"
    },
    {
        "line": 606,
        "fullcodeline": "else if (chdir (old_cwd) == 0)"
    },
    {
        "line": 609,
        "fullcodeline": "new_cwd = old_cwd;"
    },
    {
        "line": 653,
        "fullcodeline": "int dont_close[3];"
    },
    {
        "line": 654,
        "fullcodeline": "int j = 0;"
    },
    {
        "line": 659,
        "fullcodeline": "dont_close[j++] = -1;"
    },
    {
        "line": 660,
        "fullcodeline": "fdwalk (proc_fd, close_extra_fds, dont_close);"
    },
    {
        "line": 663,
        "fullcodeline": "return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);"
    },
    {
        "line": 709,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 119,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 128,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 206,
        "fullcodeline": "die (\"Cannot create new cgroup namespace because the kernel does not support it\");"
    },
    {
        "line": 254,
        "fullcodeline": "die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");"
    },
    {
        "line": 483,
        "fullcodeline": "uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */"
    },
    {
        "line": 486,
        "fullcodeline": "cleanup_fd int unpriv_socket = -1;"
    },
    {
        "line": 499,
        "fullcodeline": "while (op != PRIV_SEP_OP_DONE);"
    },
    {
        "line": 614,
        "fullcodeline": "const char *home = getenv (\"HOME\");"
    },
    {
        "line": 655,
        "fullcodeline": "if (event_fd != -1)"
    },
    {
        "line": 657,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 208,
        "fullcodeline": "die_with_error (\"stat on /proc/self/ns/cgroup failed\");"
    },
    {
        "line": 493,
        "fullcodeline": "op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),"
    },
    {
        "line": 495,
        "fullcodeline": "privileged_op (-1, op, flags, arg1, arg2);"
    },
    {
        "line": 255,
        "fullcodeline": "else if (errno == EPERM && !is_privileged)"
    },
    {
        "line": 615,
        "fullcodeline": "if (home != NULL &&"
    },
    {
        "line": 616,
        "fullcodeline": "chdir (home) == 0)"
    },
    {
        "line": 617,
        "fullcodeline": "new_cwd = home;"
    },
    {
        "line": 256,
        "fullcodeline": "die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");"
    },
    {
        "line": 496,
        "fullcodeline": "if (write (unpriv_socket, buffer, 1) != 1)"
    },
    {
        "line": 656,
        "fullcodeline": "dont_close[j++] = event_fd;"
    },
    {
        "line": 658,
        "fullcodeline": "dont_close[j++] = opt_sync_fd;"
    }
]