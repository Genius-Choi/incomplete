[
    {
        "line": 5,
        "fullcodeline": "const char *base_path = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *old_cwd = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int event_fd = -1;"
    },
    {
        "line": 10,
        "fullcodeline": "int child_wait_fd = -1;"
    },
    {
        "line": 11,
        "fullcodeline": "int setup_finished_pipe[] = {-1, -1};"
    },
    {
        "line": 18,
        "fullcodeline": "cleanup_free char *seccomp_data = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "cleanup_free char *args_data = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "int intermediate_pids_sockets[2] = {-1, -1};"
    },
    {
        "line": 32,
        "fullcodeline": "real_uid = getuid ();"
    },
    {
        "line": 33,
        "fullcodeline": "real_gid = getgid ();"
    },
    {
        "line": 36,
        "fullcodeline": "acquire_privs ();"
    },
    {
        "line": 45,
        "fullcodeline": "read_overflowids ();"
    },
    {
        "line": 47,
        "fullcodeline": "argv0 = argv[0];"
    },
    {
        "line": 52,
        "fullcodeline": "argv++;"
    },
    {
        "line": 53,
        "fullcodeline": "argc--;"
    },
    {
        "line": 58,
        "fullcodeline": "parse_args (&argc, (const char ***) &argv);"
    },
    {
        "line": 61,
        "fullcodeline": "args_data = opt_args_data;"
    },
    {
        "line": 62,
        "fullcodeline": "opt_args_data = NULL;"
    },
    {
        "line": 139,
        "fullcodeline": "__debug__ ((\"Creating root mount point\\n\"));"
    },
    {
        "line": 163,
        "fullcodeline": "proc_fd = open (\"/proc\", O_PATH);"
    },
    {
        "line": 173,
        "fullcodeline": "base_path = \"/tmp\";"
    },
    {
        "line": 175,
        "fullcodeline": "__debug__ ((\"creating new namespace\\n\"));"
    },
    {
        "line": 185,
        "fullcodeline": "block_sigchild ();"
    },
    {
        "line": 187,
        "fullcodeline": "clone_flags = SIGCHLD | CLONE_NEWNS;"
    },
    {
        "line": 216,
        "fullcodeline": "child_wait_fd = eventfd (0, EFD_CLOEXEC);"
    },
    {
        "line": 245,
        "fullcodeline": "pid = raw_clone (clone_flags, NULL);"
    },
    {
        "line": 259,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 260,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 380,
        "fullcodeline": "res = read (child_wait_fd, &val, 8);"
    },
    {
        "line": 381,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 387,
        "fullcodeline": "switch_to_user_with_privs ();"
    },
    {
        "line": 392,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 393,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 414,
        "fullcodeline": "old_umask = umask (0);"
    },
    {
        "line": 417,
        "fullcodeline": "resolve_symlinks_in_ops ();"
    },
    {
        "line": 429,
        "fullcodeline": "old_cwd = get_current_dir_name ();"
    },
    {
        "line": 507,
        "fullcodeline": "close_ops_fd ();"
    },
    {
        "line": 570,
        "fullcodeline": "drop_privs (!is_privileged);"
    },
    {
        "line": 594,
        "fullcodeline": "umask (old_umask);"
    },
    {
        "line": 596,
        "fullcodeline": "new_cwd = \"/\";"
    },
    {
        "line": 616,
        "fullcodeline": "xsetenv (\"PWD\", new_cwd, 1);"
    },
    {
        "line": 617,
        "fullcodeline": "free (old_cwd);"
    },
    {
        "line": 626,
        "fullcodeline": "__debug__ ((\"forking for child\\n\"));"
    },
    {
        "line": 664,
        "fullcodeline": "__debug__ ((\"launch executable %s\\n\", argv[0]));"
    },
    {
        "line": 678,
        "fullcodeline": "unblock_sigchild ();"
    },
    {
        "line": 681,
        "fullcodeline": "handle_die_with_parent ();"
    },
    {
        "line": 29,
        "fullcodeline": "if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))"
    },
    {
        "line": 39,
        "fullcodeline": "if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)"
    },
    {
        "line": 49,
        "fullcodeline": "if (isatty (1))"
    },
    {
        "line": 55,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 64,
        "fullcodeline": "if ((requested_caps[0] || requested_caps[1]) && is_privileged)"
    },
    {
        "line": 67,
        "fullcodeline": "if (opt_userns_block_fd != -1 && !opt_unshare_user)"
    },
    {
        "line": 70,
        "fullcodeline": "if (opt_userns_block_fd != -1 && opt_info_fd == -1)"
    },
    {
        "line": 73,
        "fullcodeline": "if (opt_userns_fd != -1 && opt_unshare_user)"
    },
    {
        "line": 76,
        "fullcodeline": "if (opt_userns_fd != -1 && opt_unshare_user_try)"
    },
    {
        "line": 91,
        "fullcodeline": "if (opt_userns_fd != -1 && is_privileged)"
    },
    {
        "line": 96,
        "fullcodeline": "if (!is_privileged && getuid () != 0 && opt_userns_fd == -1)"
    },
    {
        "line": 105,
        "fullcodeline": "if (opt_unshare_user_try &&"
    },
    {
        "line": 136,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 141,
        "fullcodeline": "if (opt_sandbox_uid == -1)"
    },
    {
        "line": 143,
        "fullcodeline": "if (opt_sandbox_gid == -1)"
    },
    {
        "line": 146,
        "fullcodeline": "if (!opt_unshare_user && opt_userns_fd == -1 && opt_sandbox_uid != real_uid)"
    },
    {
        "line": 149,
        "fullcodeline": "if (!opt_unshare_user && opt_userns_fd == -1 && opt_sandbox_gid != real_gid)"
    },
    {
        "line": 152,
        "fullcodeline": "if (!opt_unshare_uts && opt_sandbox_hostname != NULL)"
    },
    {
        "line": 155,
        "fullcodeline": "if (opt_as_pid_1 && !opt_unshare_pid)"
    },
    {
        "line": 158,
        "fullcodeline": "if (opt_as_pid_1 && lock_files != NULL)"
    },
    {
        "line": 164,
        "fullcodeline": "if (proc_fd == -1)"
    },
    {
        "line": 177,
        "fullcodeline": "if (opt_unshare_pid && !opt_as_pid_1)"
    },
    {
        "line": 190,
        "fullcodeline": "if (opt_unshare_pid && opt_pidns_fd == -1)"
    },
    {
        "line": 217,
        "fullcodeline": "if (child_wait_fd == -1)"
    },
    {
        "line": 221,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 230,
        "fullcodeline": "if (opt_userns_fd > 0 && setns (opt_userns_fd, CLONE_NEWUSER) != 0)"
    },
    {
        "line": 238,
        "fullcodeline": "if (opt_pidns_fd != -1)"
    },
    {
        "line": 246,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 262,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 334,
        "fullcodeline": "if (opt_pidns_fd > 0)"
    },
    {
        "line": 373,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 376,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 394,
        "fullcodeline": "if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 422,
        "fullcodeline": "if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)"
    },
    {
        "line": 426,
        "fullcodeline": "if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)"
    },
    {
        "line": 433,
        "fullcodeline": "if (chdir (base_path) != 0)"
    },
    {
        "line": 442,
        "fullcodeline": "if (mkdir (\"newroot\", 0755))"
    },
    {
        "line": 445,
        "fullcodeline": "if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)"
    },
    {
        "line": 448,
        "fullcodeline": "if (mkdir (\"oldroot\", 0755))"
    },
    {
        "line": 451,
        "fullcodeline": "if (pivot_root (base_path, \"oldroot\"))"
    },
    {
        "line": 454,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 510,
        "fullcodeline": "if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)"
    },
    {
        "line": 513,
        "fullcodeline": "if (umount2 (\"oldroot\", MNT_DETACH))"
    },
    {
        "line": 522,
        "fullcodeline": "{ cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);"
    },
    {
        "line": 547,
        "fullcodeline": "if (opt_userns2_fd > 0 && setns (opt_userns2_fd, CLONE_NEWUSER) != 0)"
    },
    {
        "line": 550,
        "fullcodeline": "if (opt_unshare_user &&"
    },
    {
        "line": 572,
        "fullcodeline": "if (opt_block_fd != -1)"
    },
    {
        "line": 579,
        "fullcodeline": "if (opt_seccomp_fd != -1)"
    },
    {
        "line": 619,
        "fullcodeline": "if (opt_new_session &&"
    },
    {
        "line": 623,
        "fullcodeline": "if (label_exec (opt_exec_label) == -1)"
    },
    {
        "line": 628,
        "fullcodeline": "if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))"
    },
    {
        "line": 666,
        "fullcodeline": "if (proc_fd != -1)"
    },
    {
        "line": 671,
        "fullcodeline": "if (!opt_as_pid_1)"
    },
    {
        "line": 683,
        "fullcodeline": "if (!is_privileged)"
    },
    {
        "line": 688,
        "fullcodeline": "if (seccomp_data != NULL &&"
    },
    {
        "line": 692,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 700,
        "fullcodeline": "if (execvp (argv[0], argv) == -1)"
    },
    {
        "line": 30,
        "fullcodeline": "print_version_and_exit ();"
    },
    {
        "line": 40,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");"
    },
    {
        "line": 50,
        "fullcodeline": "host_tty_dev = ttyname (1);"
    },
    {
        "line": 56,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 65,
        "fullcodeline": "die (\"--cap-add in setuid mode can be used only by root\");"
    },
    {
        "line": 68,
        "fullcodeline": "die (\"--userns-block-fd requires --unshare-user\");"
    },
    {
        "line": 71,
        "fullcodeline": "die (\"--userns-block-fd requires --info-fd\");"
    },
    {
        "line": 74,
        "fullcodeline": "die (\"--userns not compatible --unshare-user\");"
    },
    {
        "line": 77,
        "fullcodeline": "die (\"--userns not compatible --unshare-user-try\");"
    },
    {
        "line": 92,
        "fullcodeline": "die (\"--userns doesn't work in setuid mode\");"
    },
    {
        "line": 97,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 106,
        "fullcodeline": "stat (\"/proc/self/ns/user\", &sbuf) == 0)"
    },
    {
        "line": 108,
        "fullcodeline": "bool disabled = FALSE;"
    },
    {
        "line": 137,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 142,
        "fullcodeline": "opt_sandbox_uid = real_uid;"
    },
    {
        "line": 144,
        "fullcodeline": "opt_sandbox_gid = real_gid;"
    },
    {
        "line": 147,
        "fullcodeline": "die (\"Specifying --uid requires --unshare-user or --userns\");"
    },
    {
        "line": 150,
        "fullcodeline": "die (\"Specifying --gid requires --unshare-user or --userns\");"
    },
    {
        "line": 153,
        "fullcodeline": "die (\"Specifying --hostname requires --unshare-uts\");"
    },
    {
        "line": 156,
        "fullcodeline": "die (\"Specifying --as-pid-1 requires --unshare-pid\");"
    },
    {
        "line": 159,
        "fullcodeline": "die (\"Specifying --as-pid-1 and --lock-file is not permitted\");"
    },
    {
        "line": 165,
        "fullcodeline": "die_with_error (\"Can't open /proc\");"
    },
    {
        "line": 179,
        "fullcodeline": "event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);"
    },
    {
        "line": 189,
        "fullcodeline": "clone_flags |= CLONE_NEWUSER;"
    },
    {
        "line": 191,
        "fullcodeline": "clone_flags |= CLONE_NEWPID;"
    },
    {
        "line": 193,
        "fullcodeline": "clone_flags |= CLONE_NEWNET;"
    },
    {
        "line": 195,
        "fullcodeline": "clone_flags |= CLONE_NEWIPC;"
    },
    {
        "line": 197,
        "fullcodeline": "clone_flags |= CLONE_NEWUTS;"
    },
    {
        "line": 207,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 211,
        "fullcodeline": "opt_unshare_cgroup = !stat (\"/proc/self/ns/cgroup\", &sbuf);"
    },
    {
        "line": 218,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 224,
        "fullcodeline": "ret = pipe2 (setup_finished_pipe, O_CLOEXEC);"
    },
    {
        "line": 234,
        "fullcodeline": "die_with_error (\"Joining specified user namespace failed\");"
    },
    {
        "line": 241,
        "fullcodeline": "prctl (PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0);"
    },
    {
        "line": 242,
        "fullcodeline": "create_pid_socketpair (intermediate_pids_sockets);"
    },
    {
        "line": 256,
        "fullcodeline": "die_with_error (\"Creating new namespace failed\");"
    },
    {
        "line": 274,
        "fullcodeline": "namespace_ids_read (pid);"
    },
    {
        "line": 297,
        "fullcodeline": "drop_privs (FALSE);"
    },
    {
        "line": 300,
        "fullcodeline": "handle_die_with_parent ();"
    },
    {
        "line": 326,
        "fullcodeline": "val = 1;"
    },
    {
        "line": 327,
        "fullcodeline": "res = write (child_wait_fd, &val, 8);"
    },
    {
        "line": 329,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 340,
        "fullcodeline": "fork_intermediate_child ();"
    },
    {
        "line": 354,
        "fullcodeline": "close (intermediate_pids_sockets[0]);"
    },
    {
        "line": 355,
        "fullcodeline": "send_pid_on_socket (intermediate_pids_sockets[1]);"
    },
    {
        "line": 356,
        "fullcodeline": "close (intermediate_pids_sockets[1]);"
    },
    {
        "line": 374,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 377,
        "fullcodeline": "close (opt_json_status_fd);"
    },
    {
        "line": 390,
        "fullcodeline": "loopback_setup (); /* Will exit if unsuccessful */"
    },
    {
        "line": 409,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 423,
        "fullcodeline": "die_with_error (\"Failed to make / slave\");"
    },
    {
        "line": 427,
        "fullcodeline": "die_with_error (\"Failed to mount tmpfs\");"
    },
    {
        "line": 434,
        "fullcodeline": "die_with_error (\"chdir base_path\");"
    },
    {
        "line": 443,
        "fullcodeline": "die_with_error (\"Creating newroot failed\");"
    },
    {
        "line": 446,
        "fullcodeline": "die_with_error (\"setting up newroot bind\");"
    },
    {
        "line": 449,
        "fullcodeline": "die_with_error (\"Creating oldroot failed\");"
    },
    {
        "line": 452,
        "fullcodeline": "die_with_error (\"pivot_root\");"
    },
    {
        "line": 455,
        "fullcodeline": "die_with_error (\"chdir / (base path)\");"
    },
    {
        "line": 460,
        "fullcodeline": "int privsep_sockets[2];"
    },
    {
        "line": 465,
        "fullcodeline": "child = fork ();"
    },
    {
        "line": 511,
        "fullcodeline": "die_with_error (\"Failed to make old root rprivate\");"
    },
    {
        "line": 514,
        "fullcodeline": "die_with_error (\"unmount old root\");"
    },
    {
        "line": 523,
        "fullcodeline": "if (oldrootfd < 0)"
    },
    {
        "line": 525,
        "fullcodeline": "if (chdir (\"/newroot\") != 0)"
    },
    {
        "line": 537,
        "fullcodeline": "if (pivot_root (\".\", \".\") != 0)"
    },
    {
        "line": 539,
        "fullcodeline": "if (fchdir (oldrootfd) < 0)"
    },
    {
        "line": 541,
        "fullcodeline": "if (umount2 (\".\", MNT_DETACH) < 0)"
    },
    {
        "line": 543,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 548,
        "fullcodeline": "die_with_error (\"Setting userns2 failed\");"
    },
    {
        "line": 552,
        "fullcodeline": "opt_userns_block_fd == -1)"
    },
    {
        "line": 562,
        "fullcodeline": "drop_cap_bounding_set (FALSE);"
    },
    {
        "line": 564,
        "fullcodeline": "write_uid_gid_map (opt_sandbox_uid, ns_uid,"
    },
    {
        "line": 574,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 575,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));"
    },
    {
        "line": 576,
        "fullcodeline": "close (opt_block_fd);"
    },
    {
        "line": 581,
        "fullcodeline": "seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);"
    },
    {
        "line": 588,
        "fullcodeline": "seccomp_prog.len = seccomp_len / 8;"
    },
    {
        "line": 589,
        "fullcodeline": "seccomp_prog.filter = (struct sock_filter *) seccomp_data;"
    },
    {
        "line": 591,
        "fullcodeline": "close (opt_seccomp_fd);"
    },
    {
        "line": 601,
        "fullcodeline": "new_cwd = opt_chdir_path;"
    },
    {
        "line": 620,
        "fullcodeline": "setsid () == (pid_t) -1)"
    },
    {
        "line": 621,
        "fullcodeline": "die_with_error (\"setsid\");"
    },
    {
        "line": 624,
        "fullcodeline": "die_with_error (\"label_exec %s\", argv[0]);"
    },
    {
        "line": 636,
        "fullcodeline": "pid = fork ();"
    },
    {
        "line": 667,
        "fullcodeline": "close (proc_fd);"
    },
    {
        "line": 684,
        "fullcodeline": "set_ambient_capabilities ();"
    },
    {
        "line": 689,
        "fullcodeline": "prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)"
    },
    {
        "line": 690,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_SECCOMP)\");"
    },
    {
        "line": 694,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 695,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 711,
        "fullcodeline": "die_with_error (\"execvp %s\", argv[0]);"
    },
    {
        "line": 111,
        "fullcodeline": "if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)"
    },
    {
        "line": 120,
        "fullcodeline": "if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)"
    },
    {
        "line": 132,
        "fullcodeline": "if (!disabled)"
    },
    {
        "line": 180,
        "fullcodeline": "if (event_fd == -1)"
    },
    {
        "line": 200,
        "fullcodeline": "if (stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 225,
        "fullcodeline": "if (ret == -1)"
    },
    {
        "line": 232,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 266,
        "fullcodeline": "if (intermediate_pids_sockets[0] != -1)"
    },
    {
        "line": 276,
        "fullcodeline": "if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 293,
        "fullcodeline": "if (opt_userns2_fd > 0 && setns (opt_userns2_fd, CLONE_NEWUSER) != 0)"
    },
    {
        "line": 302,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 310,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 318,
        "fullcodeline": "if (opt_userns_block_fd != -1)"
    },
    {
        "line": 331,
        "fullcodeline": "return monitor_child (event_fd, pid, setup_finished_pipe[0]);"
    },
    {
        "line": 336,
        "fullcodeline": "if (setns (opt_pidns_fd, CLONE_NEWPID) != 0)"
    },
    {
        "line": 411,
        "fullcodeline": "-1, TRUE, FALSE);"
    },
    {
        "line": 462,
        "fullcodeline": "if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)"
    },
    {
        "line": 466,
        "fullcodeline": "if (child == -1)"
    },
    {
        "line": 469,
        "fullcodeline": "if (child == 0)"
    },
    {
        "line": 504,
        "fullcodeline": "setup_newroot (opt_unshare_pid, -1);"
    },
    {
        "line": 524,
        "fullcodeline": "die_with_error (\"can't open /\");"
    },
    {
        "line": 526,
        "fullcodeline": "die_with_error (\"chdir /newroot\");"
    },
    {
        "line": 538,
        "fullcodeline": "die_with_error (\"pivot_root(/newroot)\");"
    },
    {
        "line": 540,
        "fullcodeline": "die_with_error (\"fchdir to oldroot\");"
    },
    {
        "line": 542,
        "fullcodeline": "die_with_error (\"umount old root\");"
    },
    {
        "line": 544,
        "fullcodeline": "die_with_error (\"chdir /\");"
    },
    {
        "line": 551,
        "fullcodeline": "(ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&"
    },
    {
        "line": 558,
        "fullcodeline": "if (unshare (CLONE_NEWUSER))"
    },
    {
        "line": 566,
        "fullcodeline": "-1, FALSE, FALSE);"
    },
    {
        "line": 582,
        "fullcodeline": "if (seccomp_data == NULL)"
    },
    {
        "line": 585,
        "fullcodeline": "if (seccomp_len % 8 != 0)"
    },
    {
        "line": 599,
        "fullcodeline": "if (chdir (opt_chdir_path))"
    },
    {
        "line": 637,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 640,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 673,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 702,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 113,
        "fullcodeline": "cleanup_free char *enable = NULL;"
    },
    {
        "line": 114,
        "fullcodeline": "enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");"
    },
    {
        "line": 122,
        "fullcodeline": "cleanup_free char *max_user_ns = NULL;"
    },
    {
        "line": 123,
        "fullcodeline": "max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");"
    },
    {
        "line": 133,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 181,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 213,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 226,
        "fullcodeline": "die_with_error (\"pipe2()\");"
    },
    {
        "line": 233,
        "fullcodeline": "die (\"Joining the specified user namespace failed, it might not be a descendant of the current user namespace.\");"
    },
    {
        "line": 268,
        "fullcodeline": "close (intermediate_pids_sockets[1]);"
    },
    {
        "line": 269,
        "fullcodeline": "pid = read_pid_from_socket (intermediate_pids_sockets[0]);"
    },
    {
        "line": 270,
        "fullcodeline": "close (intermediate_pids_sockets[0]);"
    },
    {
        "line": 286,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 294,
        "fullcodeline": "die_with_error (\"Setting userns2 failed\");"
    },
    {
        "line": 304,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\", pid);"
    },
    {
        "line": 305,
        "fullcodeline": "dump_info (opt_info_fd, output, TRUE);"
    },
    {
        "line": 306,
        "fullcodeline": "namespace_ids_write (opt_info_fd, FALSE);"
    },
    {
        "line": 307,
        "fullcodeline": "dump_info (opt_info_fd, \"\\n}\\n\", TRUE);"
    },
    {
        "line": 308,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 312,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i\", pid);"
    },
    {
        "line": 313,
        "fullcodeline": "dump_info (opt_json_status_fd, output, TRUE);"
    },
    {
        "line": 314,
        "fullcodeline": "namespace_ids_write (opt_json_status_fd, TRUE);"
    },
    {
        "line": 315,
        "fullcodeline": "dump_info (opt_json_status_fd, \" }\\n\", TRUE);"
    },
    {
        "line": 320,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 321,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));"
    },
    {
        "line": 322,
        "fullcodeline": "close (opt_userns_block_fd);"
    },
    {
        "line": 337,
        "fullcodeline": "die_with_error (\"Setting pidns failed\");"
    },
    {
        "line": 349,
        "fullcodeline": "fork_intermediate_child ();"
    },
    {
        "line": 405,
        "fullcodeline": "ns_uid = 0;"
    },
    {
        "line": 406,
        "fullcodeline": "ns_gid = 0;"
    },
    {
        "line": 463,
        "fullcodeline": "die_with_error (\"Can't create privsep socket\");"
    },
    {
        "line": 467,
        "fullcodeline": "die_with_error (\"Can't fork unprivileged helper\");"
    },
    {
        "line": 472,
        "fullcodeline": "drop_privs (FALSE);"
    },
    {
        "line": 473,
        "fullcodeline": "close (privsep_sockets[0]);"
    },
    {
        "line": 474,
        "fullcodeline": "setup_newroot (opt_unshare_pid, privsep_sockets[1]);"
    },
    {
        "line": 475,
        "fullcodeline": "exit (0);"
    },
    {
        "line": 559,
        "fullcodeline": "die_with_error (\"unshare user ns\");"
    },
    {
        "line": 583,
        "fullcodeline": "die_with_error (\"Can't read seccomp data\");"
    },
    {
        "line": 586,
        "fullcodeline": "die (\"Invalid seccomp data, must be multiple of 8\");"
    },
    {
        "line": 600,
        "fullcodeline": "die_with_error (\"Can't chdir to %s\", opt_chdir_path);"
    },
    {
        "line": 603,
        "fullcodeline": "else if (chdir (old_cwd) == 0)"
    },
    {
        "line": 638,
        "fullcodeline": "die_with_error (\"Can't fork for pid 1\");"
    },
    {
        "line": 642,
        "fullcodeline": "drop_all_caps (FALSE);"
    },
    {
        "line": 674,
        "fullcodeline": "close (opt_sync_fd);"
    },
    {
        "line": 704,
        "fullcodeline": "int saved_errno = errno;"
    },
    {
        "line": 705,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 706,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 707,
        "fullcodeline": "errno = saved_errno;"
    },
    {
        "line": 115,
        "fullcodeline": "if (enable != NULL && enable[0] == 'N')"
    },
    {
        "line": 124,
        "fullcodeline": "if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)"
    },
    {
        "line": 202,
        "fullcodeline": "if (errno == ENOENT)"
    },
    {
        "line": 250,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 345,
        "fullcodeline": "if (unshare (CLONE_NEWPID))"
    },
    {
        "line": 480,
        "fullcodeline": "uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */"
    },
    {
        "line": 483,
        "fullcodeline": "cleanup_fd int unpriv_socket = -1;"
    },
    {
        "line": 485,
        "fullcodeline": "unpriv_socket = privsep_sockets[0];"
    },
    {
        "line": 486,
        "fullcodeline": "close (privsep_sockets[1]);"
    },
    {
        "line": 498,
        "fullcodeline": "waitpid (child, &status, 0);"
    },
    {
        "line": 606,
        "fullcodeline": "new_cwd = old_cwd;"
    },
    {
        "line": 650,
        "fullcodeline": "int dont_close[3];"
    },
    {
        "line": 651,
        "fullcodeline": "int j = 0;"
    },
    {
        "line": 656,
        "fullcodeline": "dont_close[j++] = -1;"
    },
    {
        "line": 657,
        "fullcodeline": "fdwalk (proc_fd, close_extra_fds, dont_close);"
    },
    {
        "line": 660,
        "fullcodeline": "return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);"
    },
    {
        "line": 116,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 125,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 203,
        "fullcodeline": "die (\"Cannot create new cgroup namespace because the kernel does not support it\");"
    },
    {
        "line": 251,
        "fullcodeline": "die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");"
    },
    {
        "line": 346,
        "fullcodeline": "die_with_error (\"unshare pid ns\");"
    },
    {
        "line": 496,
        "fullcodeline": "while (op != PRIV_SEP_OP_DONE);"
    },
    {
        "line": 611,
        "fullcodeline": "const char *home = getenv (\"HOME\");"
    },
    {
        "line": 652,
        "fullcodeline": "if (event_fd != -1)"
    },
    {
        "line": 654,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 205,
        "fullcodeline": "die_with_error (\"stat on /proc/self/ns/cgroup failed\");"
    },
    {
        "line": 490,
        "fullcodeline": "op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),"
    },
    {
        "line": 492,
        "fullcodeline": "privileged_op (-1, op, flags, arg1, arg2);"
    },
    {
        "line": 612,
        "fullcodeline": "if (home != NULL &&"
    },
    {
        "line": 653,
        "fullcodeline": "dont_close[j++] = event_fd;"
    },
    {
        "line": 655,
        "fullcodeline": "dont_close[j++] = opt_sync_fd;"
    },
    {
        "line": 252,
        "fullcodeline": "else if (errno == EPERM && !is_privileged)"
    },
    {
        "line": 493,
        "fullcodeline": "if (write (unpriv_socket, buffer, 1) != 1)"
    },
    {
        "line": 613,
        "fullcodeline": "chdir (home) == 0)"
    },
    {
        "line": 614,
        "fullcodeline": "new_cwd = home;"
    },
    {
        "line": 253,
        "fullcodeline": "die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");"
    },
    {
        "line": 494,
        "fullcodeline": "die (\"Can't write to op_socket\");"
    }
]