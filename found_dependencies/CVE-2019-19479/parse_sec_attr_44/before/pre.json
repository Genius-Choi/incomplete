[
    {
        "line": 4,
        "fullcodeline": "const int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/"
    },
    {
        "line": 8,
        "fullcodeline": "const int ef_idx[8] = {"
    },
    {
        "line": 12,
        "fullcodeline": "const int efi_idx[8] = { /* internal EF used for RSA keys */"
    },
    {
        "line": 19,
        "fullcodeline": "int\t\tiKeyRef = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\tiOffset = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "while (len > 1) {\t\t\t\t/* minimum length = 2 */"
    },
    {
        "line": 7,
        "fullcodeline": "SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};"
    },
    {
        "line": 11,
        "fullcodeline": "-1, SC_AC_OP_ERASE, -1};"
    },
    {
        "line": 15,
        "fullcodeline": "-1, SC_AC_OP_ERASE, -1};"
    },
    {
        "line": 28,
        "fullcodeline": "size_t iACLen   = buf[iOffset] & 0x0F;"
    },
    {
        "line": 32,
        "fullcodeline": "iMethod = SC_AC_NONE;\t\t/* default no authentication required */"
    },
    {
        "line": 150,
        "fullcodeline": "iOffset += iACLen +1;\t\t/* AC + PTL-byte */"
    },
    {
        "line": 151,
        "fullcodeline": "len     -= iACLen +1;"
    },
    {
        "line": 29,
        "fullcodeline": "if (iACLen > len)"
    },
    {
        "line": 34,
        "fullcodeline": "if (buf[iOffset] & 0X80) { /* AC in adaptive coding */"
    },
    {
        "line": 36,
        "fullcodeline": "size_t\tiParmLen = 1;\t\t\t/* command-byte is always present */"
    },
    {
        "line": 37,
        "fullcodeline": "size_t\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */"
    },
    {
        "line": 89,
        "fullcodeline": "sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);"
    },
    {
        "line": 39,
        "fullcodeline": "if (buf[iOffset]   & 0x20) iKeyLen++;"
    },
    {
        "line": 40,
        "fullcodeline": "if (buf[iOffset+1] & 0x40) iParmLen++;"
    },
    {
        "line": 41,
        "fullcodeline": "if (buf[iOffset+1] & 0x20) iParmLen++;"
    },
    {
        "line": 42,
        "fullcodeline": "if (buf[iOffset+1] & 0x10) iParmLen++;"
    },
    {
        "line": 43,
        "fullcodeline": "if (buf[iOffset+1] & 0x08) iParmLen++;"
    },
    {
        "line": 68,
        "fullcodeline": "if (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */"
    },
    {
        "line": 76,
        "fullcodeline": "if (len < 1+2)"
    },
    {
        "line": 108,
        "fullcodeline": "iPinCount = iACLen - 1;"
    },
    {
        "line": 142,
        "fullcodeline": "bValue = buf[iOffset + 1];"
    },
    {
        "line": 50,
        "fullcodeline": "iSC = buf[iOffset+iACLen];"
    },
    {
        "line": 64,
        "fullcodeline": "iKeyRef = iSC & 0x1F;\t\t\t/* get key number */"
    },
    {
        "line": 71,
        "fullcodeline": "iKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */"
    },
    {
        "line": 72,
        "fullcodeline": "iMethod = SC_AC_CHV;"
    },
    {
        "line": 80,
        "fullcodeline": "iOperation = SC_AC_OP_CRYPTO;"
    },
    {
        "line": 83,
        "fullcodeline": "iOperation = SC_AC_OP_UPDATE;"
    },
    {
        "line": 86,
        "fullcodeline": "iOperation = SC_AC_OP_SELECT;"
    },
    {
        "line": 110,
        "fullcodeline": "if (buf[iOffset] & 0x20) {"
    },
    {
        "line": 134,
        "fullcodeline": "if ( iPinCount > 0 ) {"
    },
    {
        "line": 143,
        "fullcodeline": "for (i = 0; i < 8; i++) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (len < 1+(size_t)iACLen)"
    },
    {
        "line": 52,
        "fullcodeline": "switch( (iSC>>5) & 0x03 ){"
    },
    {
        "line": 69,
        "fullcodeline": "if (len < 1+1+1+(size_t)iParmLen)"
    },
    {
        "line": 97,
        "fullcodeline": "p_idx = df_idx;"
    },
    {
        "line": 100,
        "fullcodeline": "p_idx = efi_idx;"
    },
    {
        "line": 103,
        "fullcodeline": "p_idx = ef_idx;"
    },
    {
        "line": 114,
        "fullcodeline": "iSC = buf[iOffset + iACLen];"
    },
    {
        "line": 128,
        "fullcodeline": "iKeyRef = iSC & 0x1F;\t\t\t/* get key number */"
    },
    {
        "line": 130,
        "fullcodeline": "iPinCount--;\t\t\t\t/* one byte used for keyReference  */"
    },
    {
        "line": 137,
        "fullcodeline": "iKeyRef = buf[iOffset + 2];\t/* pin ref */"
    },
    {
        "line": 138,
        "fullcodeline": "iMethod = SC_AC_CHV;"
    },
    {
        "line": 146,
        "fullcodeline": "bValue >>= 1;"
    },
    {
        "line": 54,
        "fullcodeline": "iMethod = SC_AC_TERM;\t\t/* key authentication */"
    },
    {
        "line": 57,
        "fullcodeline": "iMethod = SC_AC_AUT;\t\t/* key authentication  */"
    },
    {
        "line": 61,
        "fullcodeline": "iMethod = SC_AC_PRO;\t\t/* secure messaging */"
    },
    {
        "line": 112,
        "fullcodeline": "if (len < 1 + (size_t)iACLen)"
    },
    {
        "line": 116,
        "fullcodeline": "switch( (iSC>>5) & 0x03 ) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (len < 1 + 2)"
    },
    {
        "line": 144,
        "fullcodeline": "if((bValue & 1) && (p_idx[i] >= 0))"
    },
    {
        "line": 118,
        "fullcodeline": "iMethod = SC_AC_TERM;\t\t/* key authentication */"
    },
    {
        "line": 121,
        "fullcodeline": "iMethod = SC_AC_AUT;\t\t/* key authentication  */"
    },
    {
        "line": 125,
        "fullcodeline": "iMethod = SC_AC_PRO;\t\t/* secure messaging */"
    },
    {
        "line": 145,
        "fullcodeline": "sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);"
    }
]