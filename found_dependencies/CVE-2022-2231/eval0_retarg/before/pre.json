[
    {
        "line": 11,
        "fullcodeline": "int\t\tdid_emsg_before = did_emsg;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tcalled_emsg_before = called_emsg;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tcheck_for_end = retarg == NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tend_error = FALSE;"
    },
    {
        "line": 17,
        "fullcodeline": "p = skipwhite(arg);"
    },
    {
        "line": 18,
        "fullcodeline": "ret = eval1(&p, rettv, evalarg);"
    },
    {
        "line": 19,
        "fullcodeline": "expr_end = p;"
    },
    {
        "line": 20,
        "fullcodeline": "p = skipwhite(p);"
    },
    {
        "line": 25,
        "fullcodeline": "if (in_vim9script() && p > expr_end && retarg == NULL)"
    },
    {
        "line": 38,
        "fullcodeline": "if (ret != FAIL && check_for_end)"
    },
    {
        "line": 40,
        "fullcodeline": "if (ret == FAIL || end_error)"
    },
    {
        "line": 70,
        "fullcodeline": "if (retarg != NULL)"
    },
    {
        "line": 39,
        "fullcodeline": "end_error = !ends_excmd2(arg, p);"
    },
    {
        "line": 26,
        "fullcodeline": "while (*p == '#')"
    },
    {
        "line": 42,
        "fullcodeline": "if (ret != FAIL)"
    },
    {
        "line": 50,
        "fullcodeline": "if (!aborting()"
    },
    {
        "line": 65,
        "fullcodeline": "if (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')"
    },
    {
        "line": 28,
        "fullcodeline": "char_u *nl = vim_strchr(p, NL);"
    },
    {
        "line": 32,
        "fullcodeline": "p = skipwhite(nl + 1);"
    },
    {
        "line": 35,
        "fullcodeline": "check_for_end = FALSE;"
    },
    {
        "line": 43,
        "fullcodeline": "clear_tv(rettv);"
    },
    {
        "line": 54,
        "fullcodeline": "&& (!in_vim9script() || !vim9_bad_comment(p)))"
    },
    {
        "line": 66,
        "fullcodeline": "eap->nextcmd = check_nextcmd(p);"
    },
    {
        "line": 30,
        "fullcodeline": "if (nl == NULL)"
    },
    {
        "line": 33,
        "fullcodeline": "if (eap != NULL && *p != NUL)"
    },
    {
        "line": 53,
        "fullcodeline": "&& (flags & EVAL_CONSTANT) == 0"
    },
    {
        "line": 72,
        "fullcodeline": "else if (check_for_end && eap != NULL)"
    },
    {
        "line": 34,
        "fullcodeline": "eap->nextcmd = p;"
    },
    {
        "line": 52,
        "fullcodeline": "&& called_emsg == called_emsg_before"
    },
    {
        "line": 57,
        "fullcodeline": "semsg(_(e_trailing_characters_str), p);"
    },
    {
        "line": 51,
        "fullcodeline": "&& did_emsg == did_emsg_before"
    },
    {
        "line": 59,
        "fullcodeline": "semsg(_(e_invalid_expression_str), arg);"
    }
]