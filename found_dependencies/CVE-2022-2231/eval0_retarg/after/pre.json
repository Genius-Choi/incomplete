[
    {
        "line": 11,
        "fullcodeline": "int\t\tdid_emsg_before = did_emsg;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tcalled_emsg_before = called_emsg;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tcheck_for_end = retarg == NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tend_error = FALSE;"
    },
    {
        "line": 17,
        "fullcodeline": "p = skipwhite(arg);"
    },
    {
        "line": 18,
        "fullcodeline": "ret = eval1(&p, rettv, evalarg);"
    },
    {
        "line": 20,
        "fullcodeline": "if (ret != FAIL)"
    },
    {
        "line": 45,
        "fullcodeline": "if (ret == FAIL || end_error)"
    },
    {
        "line": 76,
        "fullcodeline": "if (retarg != NULL)"
    },
    {
        "line": 22,
        "fullcodeline": "expr_end = p;"
    },
    {
        "line": 23,
        "fullcodeline": "p = skipwhite(p);"
    },
    {
        "line": 28,
        "fullcodeline": "if (in_vim9script() && p > expr_end && retarg == NULL)"
    },
    {
        "line": 47,
        "fullcodeline": "if (ret != FAIL)"
    },
    {
        "line": 55,
        "fullcodeline": "if (!aborting()"
    },
    {
        "line": 70,
        "fullcodeline": "if (eap != NULL && p != NULL"
    },
    {
        "line": 42,
        "fullcodeline": "end_error = !ends_excmd2(arg, p);"
    },
    {
        "line": 48,
        "fullcodeline": "clear_tv(rettv);"
    },
    {
        "line": 59,
        "fullcodeline": "&& (!in_vim9script() || !vim9_bad_comment(p)))"
    },
    {
        "line": 71,
        "fullcodeline": "&&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')"
    },
    {
        "line": 72,
        "fullcodeline": "eap->nextcmd = check_nextcmd(p);"
    },
    {
        "line": 29,
        "fullcodeline": "while (*p == '#')"
    },
    {
        "line": 58,
        "fullcodeline": "&& (flags & EVAL_CONSTANT) == 0"
    },
    {
        "line": 78,
        "fullcodeline": "else if (check_for_end && eap != NULL)"
    },
    {
        "line": 31,
        "fullcodeline": "char_u *nl = vim_strchr(p, NL);"
    },
    {
        "line": 35,
        "fullcodeline": "p = skipwhite(nl + 1);"
    },
    {
        "line": 38,
        "fullcodeline": "check_for_end = FALSE;"
    },
    {
        "line": 57,
        "fullcodeline": "&& called_emsg == called_emsg_before"
    },
    {
        "line": 62,
        "fullcodeline": "semsg(_(e_trailing_characters_str), p);"
    },
    {
        "line": 33,
        "fullcodeline": "if (nl == NULL)"
    },
    {
        "line": 36,
        "fullcodeline": "if (eap != NULL && *p != NUL)"
    },
    {
        "line": 56,
        "fullcodeline": "&& did_emsg == did_emsg_before"
    },
    {
        "line": 64,
        "fullcodeline": "semsg(_(e_invalid_expression_str), arg);"
    },
    {
        "line": 37,
        "fullcodeline": "eap->nextcmd = p;"
    }
]