[
    {
        "line": 7,
        "fullcodeline": "bool power_ctrl_enabled = true;"
    },
    {
        "line": 9,
        "fullcodeline": "qcadev = devm_kzalloc(&serdev->dev, sizeof(*qcadev), GFP_KERNEL);"
    },
    {
        "line": 13,
        "fullcodeline": "qcadev->serdev_hu.serdev = serdev;"
    },
    {
        "line": 14,
        "fullcodeline": "data = device_get_match_data(&serdev->dev);"
    },
    {
        "line": 15,
        "fullcodeline": "serdev_device_set_drvdata(serdev, qcadev);"
    },
    {
        "line": 16,
        "fullcodeline": "device_property_read_string(&serdev->dev, \"firmware-name\","
    },
    {
        "line": 18,
        "fullcodeline": "device_property_read_u32(&serdev->dev, \"max-speed\","
    },
    {
        "line": 10,
        "fullcodeline": "if (!qcadev)"
    },
    {
        "line": 20,
        "fullcodeline": "if (!qcadev->oper_speed)"
    },
    {
        "line": 23,
        "fullcodeline": "if (data &&"
    },
    {
        "line": 21,
        "fullcodeline": "BT_DBG(\"UART will pick default operating speed\");"
    },
    {
        "line": 24,
        "fullcodeline": "(qca_is_wcn399x(data->soc_type) ||"
    },
    {
        "line": 26,
        "fullcodeline": "qcadev->btsoc_type = data->soc_type;"
    },
    {
        "line": 27,
        "fullcodeline": "qcadev->bt_power = devm_kzalloc(&serdev->dev,"
    },
    {
        "line": 33,
        "fullcodeline": "qcadev->bt_power->dev = &serdev->dev;"
    },
    {
        "line": 34,
        "fullcodeline": "err = qca_init_regulators(qcadev->bt_power, data->vregs,"
    },
    {
        "line": 41,
        "fullcodeline": "qcadev->bt_power->vregs_on = false;"
    },
    {
        "line": 43,
        "fullcodeline": "qcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\","
    },
    {
        "line": 50,
        "fullcodeline": "qcadev->sw_ctrl = devm_gpiod_get_optional(&serdev->dev, \"swctrl\","
    },
    {
        "line": 55,
        "fullcodeline": "qcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);"
    },
    {
        "line": 61,
        "fullcodeline": "err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);"
    },
    {
        "line": 103,
        "fullcodeline": "set_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);"
    },
    {
        "line": 104,
        "fullcodeline": "hdev->shutdown = qca_power_off;"
    },
    {
        "line": 11,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 25,
        "fullcodeline": "qca_is_wcn6750(data->soc_type))) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (!qcadev->bt_power)"
    },
    {
        "line": 45,
        "fullcodeline": "if (!qcadev->bt_en && data->soc_type == QCA_WCN6750) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (!qcadev->sw_ctrl && data->soc_type == QCA_WCN6750)"
    },
    {
        "line": 56,
        "fullcodeline": "if (IS_ERR(qcadev->susclk)) {"
    },
    {
        "line": 72,
        "fullcodeline": "qcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\","
    },
    {
        "line": 79,
        "fullcodeline": "qcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);"
    },
    {
        "line": 84,
        "fullcodeline": "err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);"
    },
    {
        "line": 88,
        "fullcodeline": "err = clk_prepare_enable(qcadev->susclk);"
    },
    {
        "line": 92,
        "fullcodeline": "err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);"
    },
    {
        "line": 111,
        "fullcodeline": "if (data->capabilities & QCA_CAP_WIDEBAND_SPEECH)"
    },
    {
        "line": 115,
        "fullcodeline": "if (data->capabilities & QCA_CAP_VALID_LE_STATES)"
    },
    {
        "line": 37,
        "fullcodeline": "BT_ERR(\"Failed to init regulators:%d\", err);"
    },
    {
        "line": 46,
        "fullcodeline": "dev_err(&serdev->dev, \"failed to acquire BT_EN gpio\\n\");"
    },
    {
        "line": 47,
        "fullcodeline": "power_ctrl_enabled = false;"
    },
    {
        "line": 53,
        "fullcodeline": "dev_warn(&serdev->dev, \"failed to acquire SW_CTRL gpio\\n\");"
    },
    {
        "line": 57,
        "fullcodeline": "dev_err(&serdev->dev, \"failed to acquire clk\\n\");"
    },
    {
        "line": 63,
        "fullcodeline": "BT_ERR(\"wcn3990 serdev registration failed\");"
    },
    {
        "line": 74,
        "fullcodeline": "if (!qcadev->bt_en) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (IS_ERR(qcadev->susclk)) {"
    },
    {
        "line": 112,
        "fullcodeline": "set_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,"
    },
    {
        "line": 116,
        "fullcodeline": "set_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);"
    },
    {
        "line": 31,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 58,
        "fullcodeline": "return PTR_ERR(qcadev->susclk);"
    },
    {
        "line": 68,
        "fullcodeline": "qcadev->btsoc_type = data->soc_type;"
    },
    {
        "line": 75,
        "fullcodeline": "dev_warn(&serdev->dev, \"failed to acquire enable gpio\\n\");"
    },
    {
        "line": 76,
        "fullcodeline": "power_ctrl_enabled = false;"
    },
    {
        "line": 81,
        "fullcodeline": "dev_warn(&serdev->dev, \"failed to acquire clk\\n\");"
    },
    {
        "line": 94,
        "fullcodeline": "BT_ERR(\"Rome serdev registration failed\");"
    },
    {
        "line": 95,
        "fullcodeline": "clk_disable_unprepare(qcadev->susclk);"
    },
    {
        "line": 70,
        "fullcodeline": "qcadev->btsoc_type = QCA_ROME;"
    },
    {
        "line": 82,
        "fullcodeline": "return PTR_ERR(qcadev->susclk);"
    }
]