[
    {
        "line": 6,
        "fullcodeline": "MOBI_RET ret = MOBI_SUCCESS;"
    },
    {
        "line": 7,
        "fullcodeline": "int8_t bitcount = 32;"
    },
    {
        "line": 9,
        "fullcodeline": "int bitsleft = (int) (buf_in->maxlen * 8);"
    },
    {
        "line": 11,
        "fullcodeline": "uint64_t buffer = mobi_buffer_fill64(buf_in);"
    },
    {
        "line": 2,
        "fullcodeline": "if (depth > MOBI_HUFFMAN_MAXDEPTH) {"
    },
    {
        "line": 12,
        "fullcodeline": "while (ret == MOBI_SUCCESS) {"
    },
    {
        "line": 3,
        "fullcodeline": "debug_print(\"Too many levels of recursion: %zu\\n\", depth);"
    },
    {
        "line": 17,
        "fullcodeline": "uint32_t code = (buffer >> bitcount) & 0xffffffffU;"
    },
    {
        "line": 19,
        "fullcodeline": "uint32_t t1 = huffcdic->table1[code >> 24];"
    },
    {
        "line": 21,
        "fullcodeline": "code_length = t1 & 0x1f;"
    },
    {
        "line": 22,
        "fullcodeline": "uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;"
    },
    {
        "line": 31,
        "fullcodeline": "bitcount -= code_length;"
    },
    {
        "line": 32,
        "fullcodeline": "bitsleft -= code_length;"
    },
    {
        "line": 37,
        "fullcodeline": "uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);"
    },
    {
        "line": 45,
        "fullcodeline": "uint32_t offset = huffcdic->symbol_offsets[index];"
    },
    {
        "line": 46,
        "fullcodeline": "uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];"
    },
    {
        "line": 50,
        "fullcodeline": "symbol_length &= 0x7fff;"
    },
    {
        "line": 13,
        "fullcodeline": "if (bitcount <= 0) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (bitsleft < 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);"
    },
    {
        "line": 40,
        "fullcodeline": "if (index >= huffcdic->index_count) {"
    },
    {
        "line": 48,
        "fullcodeline": "int is_decompressed = symbol_length >> 15;"
    },
    {
        "line": 14,
        "fullcodeline": "bitcount += 32;"
    },
    {
        "line": 15,
        "fullcodeline": "buffer = mobi_buffer_fill64(buf_in);"
    },
    {
        "line": 24,
        "fullcodeline": "if (!(t1 & 0x80)) {"
    },
    {
        "line": 29,
        "fullcodeline": "maxcode = huffcdic->maxcode_table[code_length];"
    },
    {
        "line": 53,
        "fullcodeline": "mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);"
    },
    {
        "line": 54,
        "fullcodeline": "ret = buf_out->error;"
    },
    {
        "line": 26,
        "fullcodeline": "while (code < huffcdic->mincode_table[code_length]) {"
    },
    {
        "line": 59,
        "fullcodeline": "buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;"
    },
    {
        "line": 60,
        "fullcodeline": "buf_sym.offset = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "buf_sym.maxlen = symbol_length;"
    },
    {
        "line": 62,
        "fullcodeline": "buf_sym.error = MOBI_SUCCESS;"
    },
    {
        "line": 63,
        "fullcodeline": "ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);"
    },
    {
        "line": 27,
        "fullcodeline": "code_length++;"
    }
]