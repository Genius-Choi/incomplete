[
    {
        "line": 10,
        "fullcodeline": "CLIPRDR_FORMAT* formats = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "UINT error = CHANNEL_RC_OK;"
    },
    {
        "line": 13,
        "fullcodeline": "asciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;"
    },
    {
        "line": 15,
        "fullcodeline": "index = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "formatList->formats = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "formatList->numFormats = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "Stream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);"
    },
    {
        "line": 163,
        "fullcodeline": "cliprdr_free_format_list(formatList);"
    },
    {
        "line": 21,
        "fullcodeline": "if (!Stream_SafeSeek(s, formatList->dataLen))"
    },
    {
        "line": 24,
        "fullcodeline": "if (!formatList->dataLen)"
    },
    {
        "line": 27,
        "fullcodeline": "else if (!useLongFormatNames)"
    },
    {
        "line": 29,
        "fullcodeline": "const size_t cap = Stream_Capacity(&sub1);"
    },
    {
        "line": 30,
        "fullcodeline": "formatList->numFormats = (cap / 36);"
    },
    {
        "line": 47,
        "fullcodeline": "formatList->formats = formats;"
    },
    {
        "line": 32,
        "fullcodeline": "if ((formatList->numFormats * 36) != cap)"
    },
    {
        "line": 41,
        "fullcodeline": "if (!formats)"
    },
    {
        "line": 49,
        "fullcodeline": "while (Stream_GetRemainingLength(&sub1) >= 4)"
    },
    {
        "line": 105,
        "fullcodeline": "sub2 = sub1;"
    },
    {
        "line": 130,
        "fullcodeline": "formatList->formats = formats;"
    },
    {
        "line": 39,
        "fullcodeline": "formats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));"
    },
    {
        "line": 43,
        "fullcodeline": "WLog_ERR(TAG, \"calloc failed!\");"
    },
    {
        "line": 51,
        "fullcodeline": "Stream_Read_UINT32(&sub1, formats[index].formatId); /* formatId (4 bytes) */"
    },
    {
        "line": 53,
        "fullcodeline": "formats[index].formatName = NULL;"
    },
    {
        "line": 63,
        "fullcodeline": "szFormatName = (char*)Stream_Pointer(&sub1);"
    },
    {
        "line": 64,
        "fullcodeline": "wszFormatName = (WCHAR*)Stream_Pointer(&sub1);"
    },
    {
        "line": 100,
        "fullcodeline": "index++;"
    },
    {
        "line": 106,
        "fullcodeline": "while (Stream_GetRemainingLength(&sub1) > 0)"
    },
    {
        "line": 124,
        "fullcodeline": "if (!formats)"
    },
    {
        "line": 132,
        "fullcodeline": "while (Stream_GetRemainingLength(&sub2) >= 4)"
    },
    {
        "line": 65,
        "fullcodeline": "if (!Stream_SafeSeek(&sub1, 32))"
    },
    {
        "line": 112,
        "fullcodeline": "wszFormatName = (WCHAR*)Stream_Pointer(&sub1);"
    },
    {
        "line": 113,
        "fullcodeline": "rest = Stream_GetRemainingLength(&sub1);"
    },
    {
        "line": 114,
        "fullcodeline": "formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));"
    },
    {
        "line": 118,
        "fullcodeline": "formatList->numFormats++;"
    },
    {
        "line": 122,
        "fullcodeline": "formats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));"
    },
    {
        "line": 126,
        "fullcodeline": "WLog_ERR(TAG, \"calloc failed!\");"
    },
    {
        "line": 135,
        "fullcodeline": "Stream_Read_UINT32(&sub2, formats[index].formatId); /* formatId (4 bytes) */"
    },
    {
        "line": 137,
        "fullcodeline": "formats[index].formatName = NULL;"
    },
    {
        "line": 139,
        "fullcodeline": "wszFormatName = (WCHAR*)Stream_Pointer(&sub2);"
    },
    {
        "line": 140,
        "fullcodeline": "rest = Stream_GetRemainingLength(&sub2);"
    },
    {
        "line": 141,
        "fullcodeline": "formatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));"
    },
    {
        "line": 156,
        "fullcodeline": "index++;"
    },
    {
        "line": 109,
        "fullcodeline": "if (!Stream_SafeSeek(&sub1, 4)) /* formatId (4 bytes) */"
    },
    {
        "line": 116,
        "fullcodeline": "if (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))"
    },
    {
        "line": 142,
        "fullcodeline": "if (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))"
    },
    {
        "line": 72,
        "fullcodeline": "formats[index].formatName = (char*)malloc(32 + 1);"
    },
    {
        "line": 79,
        "fullcodeline": "CopyMemory(formats[index].formatName, szFormatName, 32);"
    },
    {
        "line": 80,
        "fullcodeline": "formats[index].formatName[32] = '\\0';"
    },
    {
        "line": 147,
        "fullcodeline": "if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,"
    },
    {
        "line": 73,
        "fullcodeline": "if (!formats[index].formatName)"
    },
    {
        "line": 150,
        "fullcodeline": "WLog_ERR(TAG, \"failed to convert long clipboard format name\");"
    },
    {
        "line": 151,
        "fullcodeline": "error = ERROR_INTERNAL_ERROR;"
    },
    {
        "line": 75,
        "fullcodeline": "WLog_ERR(TAG, \"malloc failed!\");"
    },
    {
        "line": 76,
        "fullcodeline": "error = CHANNEL_RC_NO_MEMORY;"
    },
    {
        "line": 90,
        "fullcodeline": "if (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, 16,"
    },
    {
        "line": 93,
        "fullcodeline": "WLog_ERR(TAG, \"failed to convert short clipboard format name\");"
    },
    {
        "line": 94,
        "fullcodeline": "error = ERROR_INTERNAL_ERROR;"
    }
]