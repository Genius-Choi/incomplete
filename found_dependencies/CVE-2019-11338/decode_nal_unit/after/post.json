[
    {
        "line": 3,
        "fullcodeline": "HEVCLocalContext *lc = s->HEVClc;"
    },
    {
        "line": 4,
        "fullcodeline": "GetBitContext *gb    = &lc->gb;"
    },
    {
        "line": 7,
        "fullcodeline": "*gb              = nal->gb;"
    },
    {
        "line": 8,
        "fullcodeline": "s->nal_unit_type = nal->type;"
    },
    {
        "line": 9,
        "fullcodeline": "s->temporal_id   = nal->temporal_id;"
    },
    {
        "line": 183,
        "fullcodeline": "if (s->avctx->err_recognition & AV_EF_EXPLODE)"
    },
    {
        "line": 21,
        "fullcodeline": "ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);"
    },
    {
        "line": 34,
        "fullcodeline": "ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,"
    },
    {
        "line": 48,
        "fullcodeline": "ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);"
    },
    {
        "line": 62,
        "fullcodeline": "ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);"
    },
    {
        "line": 82,
        "fullcodeline": "ret = hls_slice_header(s);"
    },
    {
        "line": 170,
        "fullcodeline": "s->seq_decode = (s->seq_decode + 1) & 0xff;"
    },
    {
        "line": 171,
        "fullcodeline": "s->max_ra     = INT_MAX;"
    },
    {
        "line": 177,
        "fullcodeline": "av_log(s->avctx, AV_LOG_INFO,"
    },
    {
        "line": 22,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 36,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 49,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 63,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 83,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 85,
        "fullcodeline": "if (ret == 1) {"
    },
    {
        "line": 92,
        "fullcodeline": "(s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||"
    },
    {
        "line": 126,
        "fullcodeline": "if (s->nal_unit_type != s->first_nal_type) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (!s->sh.dependent_slice_segment_flag &&"
    },
    {
        "line": 14,
        "fullcodeline": "ret = s->avctx->hwaccel->decode_params(s->avctx,"
    },
    {
        "line": 27,
        "fullcodeline": "ret = s->avctx->hwaccel->decode_params(s->avctx,"
    },
    {
        "line": 41,
        "fullcodeline": "ret = s->avctx->hwaccel->decode_params(s->avctx,"
    },
    {
        "line": 55,
        "fullcodeline": "ret = s->avctx->hwaccel->decode_params(s->avctx,"
    },
    {
        "line": 86,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 94,
        "fullcodeline": "(s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {"
    },
    {
        "line": 117,
        "fullcodeline": "s->overlap ++;"
    },
    {
        "line": 118,
        "fullcodeline": "ret = hevc_frame_start(s);"
    },
    {
        "line": 127,
        "fullcodeline": "av_log(s->avctx, AV_LOG_ERROR,"
    },
    {
        "line": 134,
        "fullcodeline": "s->sh.slice_type != HEVC_SLICE_I) {"
    },
    {
        "line": 135,
        "fullcodeline": "ret = ff_hevc_slice_rpl(s);"
    },
    {
        "line": 144,
        "fullcodeline": "ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);"
    },
    {
        "line": 150,
        "fullcodeline": "ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);"
    },
    {
        "line": 18,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 31,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 45,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 59,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 93,
        "fullcodeline": "(s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||"
    },
    {
        "line": 99,
        "fullcodeline": "if (s->max_ra == INT_MAX) {"
    },
    {
        "line": 108,
        "fullcodeline": "if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&"
    },
    {
        "line": 119,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 136,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 151,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 109,
        "fullcodeline": "s->poc <= s->max_ra) {"
    },
    {
        "line": 110,
        "fullcodeline": "s->is_decoded = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "} else if (!s->ref) {"
    },
    {
        "line": 137,
        "fullcodeline": "av_log(s->avctx, AV_LOG_WARNING,"
    },
    {
        "line": 154,
        "fullcodeline": "if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)"
    },
    {
        "line": 158,
        "fullcodeline": "if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {"
    },
    {
        "line": 162,
        "fullcodeline": "if (ctb_addr_ts < 0) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {"
    },
    {
        "line": 122,
        "fullcodeline": "av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");"
    },
    {
        "line": 155,
        "fullcodeline": "ctb_addr_ts = hls_slice_data_wpp(s, nal);"
    },
    {
        "line": 159,
        "fullcodeline": "s->is_decoded = 1;"
    },
    {
        "line": 163,
        "fullcodeline": "ret = ctb_addr_ts;"
    },
    {
        "line": 101,
        "fullcodeline": "s->max_ra = s->poc;"
    },
    {
        "line": 113,
        "fullcodeline": "if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)"
    },
    {
        "line": 157,
        "fullcodeline": "ctb_addr_ts = hls_slice_data(s);"
    },
    {
        "line": 114,
        "fullcodeline": "s->max_ra = INT_MIN;"
    },
    {
        "line": 103,
        "fullcodeline": "if (IS_IDR(s))"
    },
    {
        "line": 104,
        "fullcodeline": "s->max_ra = INT_MIN;"
    }
]