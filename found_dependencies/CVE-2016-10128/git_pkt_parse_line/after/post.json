[
    {
        "line": 11,
        "fullcodeline": "len = parse_len(line);"
    },
    {
        "line": 41,
        "fullcodeline": "line += PKT_LEN_SIZE;"
    },
    {
        "line": 57,
        "fullcodeline": "len -= PKT_LEN_SIZE; /* the encoded length includes its own size */"
    },
    {
        "line": 82,
        "fullcodeline": "*out = line + len;"
    },
    {
        "line": 8,
        "fullcodeline": "if (bufflen > 0 && bufflen < PKT_LEN_SIZE)"
    },
    {
        "line": 12,
        "fullcodeline": "if (len < 0) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (bufflen > 0 && bufflen < (size_t)len)"
    },
    {
        "line": 38,
        "fullcodeline": "if (len != 0 && len < PKT_LEN_SIZE)"
    },
    {
        "line": 46,
        "fullcodeline": "if (len == PKT_LEN_SIZE) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (len == 0) { /* Flush pkt */"
    },
    {
        "line": 59,
        "fullcodeline": "if (*line == GIT_SIDE_BAND_DATA)"
    },
    {
        "line": 47,
        "fullcodeline": "*head = NULL;"
    },
    {
        "line": 48,
        "fullcodeline": "*out = line;"
    },
    {
        "line": 53,
        "fullcodeline": "*out = line;"
    },
    {
        "line": 60,
        "fullcodeline": "ret = data_pkt(head, line, len);"
    },
    {
        "line": 17,
        "fullcodeline": "if (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {"
    },
    {
        "line": 23,
        "fullcodeline": "return (int)len;"
    },
    {
        "line": 54,
        "fullcodeline": "return flush_pkt(head);"
    },
    {
        "line": 18,
        "fullcodeline": "giterr_clear();"
    },
    {
        "line": 19,
        "fullcodeline": "*out = line;"
    },
    {
        "line": 61,
        "fullcodeline": "else if (*line == GIT_SIDE_BAND_PROGRESS)"
    },
    {
        "line": 20,
        "fullcodeline": "return pack_pkt(head);"
    },
    {
        "line": 62,
        "fullcodeline": "ret = sideband_progress_pkt(head, line, len);"
    },
    {
        "line": 63,
        "fullcodeline": "else if (*line == GIT_SIDE_BAND_ERROR)"
    },
    {
        "line": 64,
        "fullcodeline": "ret = sideband_error_pkt(head, line, len);"
    },
    {
        "line": 65,
        "fullcodeline": "else if (!git__prefixcmp(line, \"ACK\"))"
    },
    {
        "line": 66,
        "fullcodeline": "ret = ack_pkt(head, line, len);"
    },
    {
        "line": 67,
        "fullcodeline": "else if (!git__prefixcmp(line, \"NAK\"))"
    },
    {
        "line": 68,
        "fullcodeline": "ret = nak_pkt(head);"
    },
    {
        "line": 69,
        "fullcodeline": "else if (!git__prefixcmp(line, \"ERR \"))"
    },
    {
        "line": 70,
        "fullcodeline": "ret = err_pkt(head, line, len);"
    },
    {
        "line": 71,
        "fullcodeline": "else if (*line == '#')"
    },
    {
        "line": 72,
        "fullcodeline": "ret = comment_pkt(head, line, len);"
    },
    {
        "line": 73,
        "fullcodeline": "else if (!git__prefixcmp(line, \"ok\"))"
    },
    {
        "line": 74,
        "fullcodeline": "ret = ok_pkt(head, line, len);"
    },
    {
        "line": 75,
        "fullcodeline": "else if (!git__prefixcmp(line, \"ng\"))"
    },
    {
        "line": 76,
        "fullcodeline": "ret = ng_pkt(head, line, len);"
    },
    {
        "line": 77,
        "fullcodeline": "else if (!git__prefixcmp(line, \"unpack\"))"
    },
    {
        "line": 78,
        "fullcodeline": "ret = unpack_pkt(head, line, len);"
    },
    {
        "line": 80,
        "fullcodeline": "ret = ref_pkt(head, line, len);"
    }
]