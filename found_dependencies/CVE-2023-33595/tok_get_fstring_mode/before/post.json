[
    {
        "line": 3,
        "fullcodeline": "const char *p_start = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "const char *p_end = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "int end_quote_size = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "int unicode_escape = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "tok->start = tok->cur;"
    },
    {
        "line": 9,
        "fullcodeline": "tok->first_lineno = tok->lineno;"
    },
    {
        "line": 10,
        "fullcodeline": "tok->starting_col_offset = tok->col_offset;"
    },
    {
        "line": 14,
        "fullcodeline": "int start_char = tok_nextc(tok);"
    },
    {
        "line": 48,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 49,
        "fullcodeline": "p_end = tok->cur;"
    },
    {
        "line": 50,
        "fullcodeline": "tok->tok_mode_stack_index--;"
    },
    {
        "line": 168,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 169,
        "fullcodeline": "p_end = tok->cur;"
    },
    {
        "line": 15,
        "fullcodeline": "if (start_char == '{') {"
    },
    {
        "line": 33,
        "fullcodeline": "for (int i = 0; i < current_tok->f_string_quote_size; i++) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (current_tok->last_expr_buffer != NULL) {"
    },
    {
        "line": 51,
        "fullcodeline": "return MAKE_TOKEN(FSTRING_END);"
    },
    {
        "line": 55,
        "fullcodeline": "while (end_quote_size != current_tok->f_string_quote_size) {"
    },
    {
        "line": 165,
        "fullcodeline": "for (int i = 0; i < current_tok->f_string_quote_size; i++) {"
    },
    {
        "line": 170,
        "fullcodeline": "return MAKE_TOKEN(FSTRING_MIDDLE);"
    },
    {
        "line": 16,
        "fullcodeline": "int peek1 = tok_nextc(tok);"
    },
    {
        "line": 17,
        "fullcodeline": "tok_backup(tok, peek1);"
    },
    {
        "line": 18,
        "fullcodeline": "tok_backup(tok, start_char);"
    },
    {
        "line": 34,
        "fullcodeline": "int quote = tok_nextc(tok);"
    },
    {
        "line": 42,
        "fullcodeline": "PyMem_Free(current_tok->last_expr_buffer);"
    },
    {
        "line": 43,
        "fullcodeline": "current_tok->last_expr_buffer = NULL;"
    },
    {
        "line": 44,
        "fullcodeline": "current_tok->last_expr_size = 0;"
    },
    {
        "line": 45,
        "fullcodeline": "current_tok->last_expr_end = -1;"
    },
    {
        "line": 56,
        "fullcodeline": "int c = tok_nextc(tok);"
    },
    {
        "line": 87,
        "fullcodeline": "int in_format_spec = ("
    },
    {
        "line": 166,
        "fullcodeline": "tok_backup(tok, current_tok->f_string_quote);"
    },
    {
        "line": 19,
        "fullcodeline": "if (peek1 != '{') {"
    },
    {
        "line": 29,
        "fullcodeline": "tok_backup(tok, start_char);"
    },
    {
        "line": 35,
        "fullcodeline": "if (quote != current_tok->f_string_quote) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (c == EOF || (current_tok->f_string_quote_size == 1 && c == '\\n')) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (c == current_tok->f_string_quote) {"
    },
    {
        "line": 88,
        "fullcodeline": "current_tok->last_expr_end != -1"
    },
    {
        "line": 92,
        "fullcodeline": "if (c == '{') {"
    },
    {
        "line": 20,
        "fullcodeline": "current_tok->curly_bracket_expr_start_depth++;"
    },
    {
        "line": 24,
        "fullcodeline": "TOK_GET_MODE(tok)->kind = TOK_REGULAR_MODE;"
    },
    {
        "line": 36,
        "fullcodeline": "tok_backup(tok, quote);"
    },
    {
        "line": 58,
        "fullcodeline": "assert(tok->multi_line_start != NULL);"
    },
    {
        "line": 62,
        "fullcodeline": "tok->cur = (char *)current_tok->f_string_start;"
    },
    {
        "line": 63,
        "fullcodeline": "tok->cur++;"
    },
    {
        "line": 64,
        "fullcodeline": "tok->line_start = current_tok->f_string_multi_line_start;"
    },
    {
        "line": 65,
        "fullcodeline": "int start = tok->lineno;"
    },
    {
        "line": 66,
        "fullcodeline": "tok->lineno = tok->first_lineno;"
    },
    {
        "line": 81,
        "fullcodeline": "end_quote_size += 1;"
    },
    {
        "line": 90,
        "fullcodeline": "INSIDE_FSTRING_EXPR(current_tok)"
    },
    {
        "line": 93,
        "fullcodeline": "int peek = tok_nextc(tok);"
    },
    {
        "line": 21,
        "fullcodeline": "if (current_tok->curly_bracket_expr_start_depth >= MAX_EXPR_NESTING) {"
    },
    {
        "line": 25,
        "fullcodeline": "return tok_get_normal_mode(tok, current_tok, token);"
    },
    {
        "line": 68,
        "fullcodeline": "if (current_tok->f_string_quote_size == 3) {"
    },
    {
        "line": 84,
        "fullcodeline": "end_quote_size = 0;"
    },
    {
        "line": 94,
        "fullcodeline": "if (peek != '{' || in_format_spec) {"
    },
    {
        "line": 108,
        "fullcodeline": "return MAKE_TOKEN(FSTRING_MIDDLE);"
    },
    {
        "line": 95,
        "fullcodeline": "tok_backup(tok, peek);"
    },
    {
        "line": 96,
        "fullcodeline": "tok_backup(tok, c);"
    },
    {
        "line": 97,
        "fullcodeline": "current_tok->curly_bracket_expr_start_depth++;"
    },
    {
        "line": 101,
        "fullcodeline": "TOK_GET_MODE(tok)->kind = TOK_REGULAR_MODE;"
    },
    {
        "line": 102,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 103,
        "fullcodeline": "p_end = tok->cur;"
    },
    {
        "line": 109,
        "fullcodeline": "} else if (c == '}') {"
    },
    {
        "line": 22,
        "fullcodeline": "return MAKE_TOKEN(syntaxerror(tok, \"f-string: expressions nested too deeply\"));"
    },
    {
        "line": 69,
        "fullcodeline": "return MAKE_TOKEN(syntaxerror(tok,"
    },
    {
        "line": 98,
        "fullcodeline": "if (current_tok->curly_bracket_expr_start_depth >= MAX_EXPR_NESTING) {"
    },
    {
        "line": 105,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 106,
        "fullcodeline": "p_end = tok->cur - 1;"
    },
    {
        "line": 115,
        "fullcodeline": "int peek = tok_nextc(tok);"
    },
    {
        "line": 74,
        "fullcodeline": "return MAKE_TOKEN(syntaxerror(tok,"
    },
    {
        "line": 121,
        "fullcodeline": "if (peek == '}' && !in_format_spec) {"
    },
    {
        "line": 131,
        "fullcodeline": "return MAKE_TOKEN(FSTRING_MIDDLE);"
    },
    {
        "line": 99,
        "fullcodeline": "return MAKE_TOKEN(syntaxerror(tok, \"f-string: expressions nested too deeply\"));"
    },
    {
        "line": 111,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 112,
        "fullcodeline": "p_end = tok->cur;"
    },
    {
        "line": 122,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 123,
        "fullcodeline": "p_end = tok->cur - 1;"
    },
    {
        "line": 132,
        "fullcodeline": "} else if (c == '\\\\') {"
    },
    {
        "line": 113,
        "fullcodeline": "return MAKE_TOKEN(FSTRING_MIDDLE);"
    },
    {
        "line": 125,
        "fullcodeline": "tok_backup(tok, peek);"
    },
    {
        "line": 126,
        "fullcodeline": "tok_backup(tok, c);"
    },
    {
        "line": 127,
        "fullcodeline": "TOK_GET_MODE(tok)->kind = TOK_REGULAR_MODE;"
    },
    {
        "line": 128,
        "fullcodeline": "p_start = tok->start;"
    },
    {
        "line": 129,
        "fullcodeline": "p_end = tok->cur;"
    },
    {
        "line": 133,
        "fullcodeline": "int peek = tok_nextc(tok);"
    },
    {
        "line": 137,
        "fullcodeline": "if (peek == '{' || peek == '}') {"
    },
    {
        "line": 147,
        "fullcodeline": "if (!current_tok->f_string_raw) {"
    },
    {
        "line": 143,
        "fullcodeline": "tok_backup(tok, peek);"
    },
    {
        "line": 138,
        "fullcodeline": "if (!current_tok->f_string_raw) {"
    },
    {
        "line": 148,
        "fullcodeline": "if (peek == 'N') {"
    },
    {
        "line": 150,
        "fullcodeline": "peek = tok_nextc(tok);"
    },
    {
        "line": 139,
        "fullcodeline": "if (warn_invalid_escape_sequence(tok, peek)) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (peek == '{') {"
    },
    {
        "line": 152,
        "fullcodeline": "unicode_escape = 1;"
    },
    {
        "line": 140,
        "fullcodeline": "return MAKE_TOKEN(ERRORTOKEN);"
    },
    {
        "line": 154,
        "fullcodeline": "tok_backup(tok, peek);"
    }
]