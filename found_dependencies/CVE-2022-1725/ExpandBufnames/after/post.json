[
    {
        "line": 7,
        "fullcodeline": "int\t\tcount = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "char_u\t*patc = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "fuzmatch_str_T  *fuzmatch = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "*num_file = 0;\t\t    // return values in case of FAIL"
    },
    {
        "line": 20,
        "fullcodeline": "*file = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "fuzzy = cmdline_fuzzy_complete(pat);"
    },
    {
        "line": 209,
        "fullcodeline": "*num_file = count;"
    },
    {
        "line": 31,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 47,
        "fullcodeline": "for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)"
    },
    {
        "line": 176,
        "fullcodeline": "if (!fuzzy && patc != pat)"
    },
    {
        "line": 210,
        "fullcodeline": "return (count == 0 ? FAIL : OK);"
    },
    {
        "line": 50,
        "fullcodeline": "int\t\tscore = 0;"
    },
    {
        "line": 177,
        "fullcodeline": "vim_free(patc);"
    },
    {
        "line": 33,
        "fullcodeline": "if (*pat == '^')"
    },
    {
        "line": 52,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 61,
        "fullcodeline": "for (round = 1; round <= 2; ++round)"
    },
    {
        "line": 168,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 35,
        "fullcodeline": "patc = alloc(STRLEN(pat) + 11);"
    },
    {
        "line": 38,
        "fullcodeline": "STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");"
    },
    {
        "line": 39,
        "fullcodeline": "STRCPY(patc + 11, pat + 1);"
    },
    {
        "line": 56,
        "fullcodeline": "regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);"
    },
    {
        "line": 63,
        "fullcodeline": "count = 0;"
    },
    {
        "line": 64,
        "fullcodeline": "FOR_ALL_BUFFERS(buf)"
    },
    {
        "line": 170,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 36,
        "fullcodeline": "if (patc == NULL)"
    },
    {
        "line": 42,
        "fullcodeline": "patc = pat;"
    },
    {
        "line": 54,
        "fullcodeline": "if (attempt > 0 && patc == pat)"
    },
    {
        "line": 136,
        "fullcodeline": "if (count == 0)\t// no match found, break here"
    },
    {
        "line": 138,
        "fullcodeline": "if (round == 1)"
    },
    {
        "line": 66,
        "fullcodeline": "if (!buf->b_p_bl)\t// skip unlisted buffers"
    },
    {
        "line": 76,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 101,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 104,
        "fullcodeline": "if (round == 1)"
    },
    {
        "line": 110,
        "fullcodeline": "if (options & WILD_HOME_REPLACE)"
    },
    {
        "line": 115,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 85,
        "fullcodeline": "p = buflist_match(&regmatch, buf, p_wic);"
    },
    {
        "line": 106,
        "fullcodeline": "++count;"
    },
    {
        "line": 111,
        "fullcodeline": "p = home_replace_save(buf, p);"
    },
    {
        "line": 126,
        "fullcodeline": "(*file)[count++] = p;"
    },
    {
        "line": 140,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 78,
        "fullcodeline": "if (regmatch.regprog == NULL)"
    },
    {
        "line": 89,
        "fullcodeline": "p = NULL;"
    },
    {
        "line": 113,
        "fullcodeline": "p = vim_strsave(p);"
    },
    {
        "line": 130,
        "fullcodeline": "fuzmatch[count].idx = count;"
    },
    {
        "line": 131,
        "fullcodeline": "fuzmatch[count].str = p;"
    },
    {
        "line": 132,
        "fullcodeline": "fuzmatch[count].score = score;"
    },
    {
        "line": 133,
        "fullcodeline": "count++;"
    },
    {
        "line": 91,
        "fullcodeline": "if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)"
    },
    {
        "line": 93,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 143,
        "fullcodeline": "if (*file == NULL)"
    },
    {
        "line": 157,
        "fullcodeline": "fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);"
    },
    {
        "line": 81,
        "fullcodeline": "if (patc != pat)"
    },
    {
        "line": 92,
        "fullcodeline": "p = buf->b_sfname;"
    },
    {
        "line": 145,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 158,
        "fullcodeline": "if (fuzmatch == NULL)"
    },
    {
        "line": 82,
        "fullcodeline": "vim_free(patc);"
    },
    {
        "line": 96,
        "fullcodeline": "if ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)"
    },
    {
        "line": 146,
        "fullcodeline": "if (patc != pat)"
    },
    {
        "line": 160,
        "fullcodeline": "*num_file = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "*file = NULL;"
    },
    {
        "line": 97,
        "fullcodeline": "p = buf->b_ffname;"
    },
    {
        "line": 147,
        "fullcodeline": "vim_free(patc);"
    }
]