[
    {
        "line": 7,
        "fullcodeline": "int\t\tcount = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "char_u\t*patc = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "fuzmatch_str_T  *fuzmatch = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "*num_file = 0;\t\t    // return values in case of FAIL"
    },
    {
        "line": 20,
        "fullcodeline": "*file = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "fuzzy = cmdline_fuzzy_complete(pat);"
    },
    {
        "line": 206,
        "fullcodeline": "*num_file = count;"
    },
    {
        "line": 31,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 47,
        "fullcodeline": "for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)"
    },
    {
        "line": 173,
        "fullcodeline": "if (!fuzzy && patc != pat)"
    },
    {
        "line": 207,
        "fullcodeline": "return (count == 0 ? FAIL : OK);"
    },
    {
        "line": 50,
        "fullcodeline": "int\t\tscore = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "vim_free(patc);"
    },
    {
        "line": 33,
        "fullcodeline": "if (*pat == '^')"
    },
    {
        "line": 52,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 67,
        "fullcodeline": "for (round = 1; round <= 2; ++round)"
    },
    {
        "line": 165,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 35,
        "fullcodeline": "patc = alloc(STRLEN(pat) + 11);"
    },
    {
        "line": 38,
        "fullcodeline": "STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");"
    },
    {
        "line": 39,
        "fullcodeline": "STRCPY(patc + 11, pat + 1);"
    },
    {
        "line": 56,
        "fullcodeline": "regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);"
    },
    {
        "line": 69,
        "fullcodeline": "count = 0;"
    },
    {
        "line": 70,
        "fullcodeline": "FOR_ALL_BUFFERS(buf)"
    },
    {
        "line": 167,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 36,
        "fullcodeline": "if (patc == NULL)"
    },
    {
        "line": 42,
        "fullcodeline": "patc = pat;"
    },
    {
        "line": 54,
        "fullcodeline": "if (attempt > 0 && patc == pat)"
    },
    {
        "line": 57,
        "fullcodeline": "if (regmatch.regprog == NULL)"
    },
    {
        "line": 133,
        "fullcodeline": "if (count == 0)\t// no match found, break here"
    },
    {
        "line": 135,
        "fullcodeline": "if (round == 1)"
    },
    {
        "line": 72,
        "fullcodeline": "if (!buf->b_p_bl)\t// skip unlisted buffers"
    },
    {
        "line": 82,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 98,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 101,
        "fullcodeline": "if (round == 1)"
    },
    {
        "line": 107,
        "fullcodeline": "if (options & WILD_HOME_REPLACE)"
    },
    {
        "line": 112,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 59,
        "fullcodeline": "if (patc != pat)"
    },
    {
        "line": 83,
        "fullcodeline": "p = buflist_match(&regmatch, buf, p_wic);"
    },
    {
        "line": 103,
        "fullcodeline": "++count;"
    },
    {
        "line": 108,
        "fullcodeline": "p = home_replace_save(buf, p);"
    },
    {
        "line": 123,
        "fullcodeline": "(*file)[count++] = p;"
    },
    {
        "line": 137,
        "fullcodeline": "if (!fuzzy)"
    },
    {
        "line": 60,
        "fullcodeline": "vim_free(patc);"
    },
    {
        "line": 86,
        "fullcodeline": "p = NULL;"
    },
    {
        "line": 110,
        "fullcodeline": "p = vim_strsave(p);"
    },
    {
        "line": 127,
        "fullcodeline": "fuzmatch[count].idx = count;"
    },
    {
        "line": 128,
        "fullcodeline": "fuzmatch[count].str = p;"
    },
    {
        "line": 129,
        "fullcodeline": "fuzmatch[count].score = score;"
    },
    {
        "line": 130,
        "fullcodeline": "count++;"
    },
    {
        "line": 88,
        "fullcodeline": "if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)"
    },
    {
        "line": 90,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 140,
        "fullcodeline": "if (*file == NULL)"
    },
    {
        "line": 154,
        "fullcodeline": "fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);"
    },
    {
        "line": 89,
        "fullcodeline": "p = buf->b_sfname;"
    },
    {
        "line": 142,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 155,
        "fullcodeline": "if (fuzmatch == NULL)"
    },
    {
        "line": 93,
        "fullcodeline": "if ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)"
    },
    {
        "line": 143,
        "fullcodeline": "if (patc != pat)"
    },
    {
        "line": 157,
        "fullcodeline": "*num_file = 0;"
    },
    {
        "line": 158,
        "fullcodeline": "*file = NULL;"
    },
    {
        "line": 94,
        "fullcodeline": "p = buf->b_ffname;"
    },
    {
        "line": 144,
        "fullcodeline": "vim_free(patc);"
    }
]