[
    {
        "line": 4,
        "fullcodeline": "char ExecString[PATH_MAX*3];"
    },
    {
        "line": 5,
        "fullcodeline": "char TempName[PATH_MAX+10];"
    },
    {
        "line": 6,
        "fullcodeline": "int TempUsed = FALSE;"
    },
    {
        "line": 8,
        "fullcodeline": "e = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "a = strlen(FileName)-1;"
    },
    {
        "line": 14,
        "fullcodeline": "memcpy(TempName, FileName, a);"
    },
    {
        "line": 15,
        "fullcodeline": "strcpy(TempName+a, \"XXXXXX\");"
    },
    {
        "line": 23,
        "fullcodeline": "mktemp(TempName);"
    },
    {
        "line": 59,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "a = system(ExecString);"
    },
    {
        "line": 13,
        "fullcodeline": "while(a > 0 && FileName[a-1] != SLASH) a--;"
    },
    {
        "line": 26,
        "fullcodeline": "if(!TempName[0]) {"
    },
    {
        "line": 32,
        "fullcodeline": "for (a=0;;a++){"
    },
    {
        "line": 62,
        "fullcodeline": "if (a || errno){"
    },
    {
        "line": 27,
        "fullcodeline": "ErrFatal(\"Cannot find available temporary file name\");"
    },
    {
        "line": 53,
        "fullcodeline": "ExecString[e++] = ApplyCommand[a];"
    },
    {
        "line": 57,
        "fullcodeline": "if (ShowIt) printf(\"Cmd:%s\\n\",ExecString);"
    },
    {
        "line": 65,
        "fullcodeline": "ErrFatal(\"Problem executing specified command\");"
    },
    {
        "line": 33,
        "fullcodeline": "if (ApplyCommand[a] == '&'){"
    },
    {
        "line": 54,
        "fullcodeline": "if (ApplyCommand[a] == 0) break;"
    },
    {
        "line": 71,
        "fullcodeline": "if (stat(TempName, &dummy) == 0){"
    },
    {
        "line": 34,
        "fullcodeline": "printf(\"Arg &%c, e=%d max %d\\n\",ApplyCommand[a+1], e, PATH_MAX);"
    },
    {
        "line": 64,
        "fullcodeline": "if (errno) perror(\"system\");"
    },
    {
        "line": 73,
        "fullcodeline": "int stat_result = stat(FileName, &buf);"
    },
    {
        "line": 75,
        "fullcodeline": "unlink(FileName);"
    },
    {
        "line": 76,
        "fullcodeline": "rename(TempName, FileName);"
    },
    {
        "line": 35,
        "fullcodeline": "if (ApplyCommand[a+1] == 'i' || ApplyCommand[a+1] == 'o'){"
    },
    {
        "line": 39,
        "fullcodeline": "if (ApplyCommand[a+1] == 'i'){"
    },
    {
        "line": 45,
        "fullcodeline": "if (ApplyCommand[a+1] == 'o'){"
    },
    {
        "line": 77,
        "fullcodeline": "if (stat_result == 0){"
    },
    {
        "line": 41,
        "fullcodeline": "e += shellescape(ExecString+e, FileName);"
    },
    {
        "line": 42,
        "fullcodeline": "a += 1;"
    },
    {
        "line": 47,
        "fullcodeline": "e += shellescape(ExecString+e, TempName);"
    },
    {
        "line": 48,
        "fullcodeline": "a += 1;"
    },
    {
        "line": 49,
        "fullcodeline": "TempUsed = TRUE;"
    },
    {
        "line": 80,
        "fullcodeline": "chmod(FileName, buf.st_mode);"
    },
    {
        "line": 82,
        "fullcodeline": "mtime.actime = buf.st_atime;"
    },
    {
        "line": 83,
        "fullcodeline": "mtime.modtime = buf.st_mtime;"
    },
    {
        "line": 85,
        "fullcodeline": "utime(FileName, &mtime);"
    },
    {
        "line": 36,
        "fullcodeline": "if (e > PATH_MAX * 2) ErrFatal(\"Specified command line too long\");"
    }
]