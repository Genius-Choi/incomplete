[
    {
        "line": 5,
        "fullcodeline": "int ret = -EINVAL;"
    },
    {
        "line": 14,
        "fullcodeline": "env = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);"
    },
    {
        "line": 17,
        "fullcodeline": "log = &env->log;"
    },
    {
        "line": 19,
        "fullcodeline": "env->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *"
    },
    {
        "line": 21,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 24,
        "fullcodeline": "env->prog = *prog;"
    },
    {
        "line": 25,
        "fullcodeline": "env->ops = bpf_verifier_ops[env->prog->type];"
    },
    {
        "line": 28,
        "fullcodeline": "mutex_lock(&bpf_verifier_lock);"
    },
    {
        "line": 45,
        "fullcodeline": "env->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);"
    },
    {
        "line": 55,
        "fullcodeline": "ret = replace_map_fd_with_map_ptr(env);"
    },
    {
        "line": 59,
        "fullcodeline": "env->explored_states = kcalloc(env->prog->len,"
    },
    {
        "line": 62,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 66,
        "fullcodeline": "ret = check_cfg(env);"
    },
    {
        "line": 70,
        "fullcodeline": "env->allow_ptr_leaks = capable(CAP_SYS_ADMIN);"
    },
    {
        "line": 72,
        "fullcodeline": "ret = do_check(env);"
    },
    {
        "line": 80,
        "fullcodeline": "free_states(env);"
    },
    {
        "line": 123,
        "fullcodeline": "*prog = env->prog;"
    },
    {
        "line": 125,
        "fullcodeline": "mutex_unlock(&bpf_verifier_lock);"
    },
    {
        "line": 126,
        "fullcodeline": "vfree(env->insn_aux_data);"
    },
    {
        "line": 128,
        "fullcodeline": "kfree(env);"
    },
    {
        "line": 8,
        "fullcodeline": "if (ARRAY_SIZE(bpf_verifier_ops) == 0)"
    },
    {
        "line": 15,
        "fullcodeline": "if (!env)"
    },
    {
        "line": 22,
        "fullcodeline": "if (!env->insn_aux_data)"
    },
    {
        "line": 30,
        "fullcodeline": "if (attr->log_level || attr->log_buf || attr->log_size) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))"
    },
    {
        "line": 56,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 63,
        "fullcodeline": "if (!env->explored_states)"
    },
    {
        "line": 67,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 79,
        "fullcodeline": "while (!pop_stack(env, NULL, NULL));"
    },
    {
        "line": 82,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 86,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 89,
        "fullcodeline": "if (log->level && bpf_verifier_log_full(log))"
    },
    {
        "line": 91,
        "fullcodeline": "if (log->level && !log->ubuf) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (ret == 0 && env->used_map_cnt) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (!env->prog->aux->used_maps)"
    },
    {
        "line": 34,
        "fullcodeline": "log->level = attr->log_level;"
    },
    {
        "line": 36,
        "fullcodeline": "log->len_total = attr->log_size;"
    },
    {
        "line": 38,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 47,
        "fullcodeline": "env->strict_alignment = true;"
    },
    {
        "line": 50,
        "fullcodeline": "ret = bpf_prog_offload_verifier_prep(env);"
    },
    {
        "line": 74,
        "fullcodeline": "free_verifier_state(env->cur_state, true);"
    },
    {
        "line": 75,
        "fullcodeline": "env->cur_state = NULL;"
    },
    {
        "line": 84,
        "fullcodeline": "ret = convert_ctx_accesses(env);"
    },
    {
        "line": 87,
        "fullcodeline": "ret = fixup_bpf_calls(env);"
    },
    {
        "line": 90,
        "fullcodeline": "ret = -ENOSPC;"
    },
    {
        "line": 92,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 98,
        "fullcodeline": "env->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,"
    },
    {
        "line": 107,
        "fullcodeline": "memcpy(env->prog->aux->used_maps, env->used_maps,"
    },
    {
        "line": 109,
        "fullcodeline": "env->prog->aux->used_map_cnt = env->used_map_cnt;"
    },
    {
        "line": 114,
        "fullcodeline": "convert_pseudo_ld_imm64(env);"
    },
    {
        "line": 122,
        "fullcodeline": "release_maps(env);"
    },
    {
        "line": 9,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 16,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 40,
        "fullcodeline": "if (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||"
    },
    {
        "line": 102,
        "fullcodeline": "if (!env->prog->aux->used_maps) {"
    },
    {
        "line": 108,
        "fullcodeline": "sizeof(env->used_maps[0]) * env->used_map_cnt);"
    },
    {
        "line": 41,
        "fullcodeline": "!log->level || !log->ubuf)"
    },
    {
        "line": 103,
        "fullcodeline": "ret = -ENOMEM;"
    }
]