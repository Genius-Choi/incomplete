[
    {
        "line": 4,
        "fullcodeline": "struct xusb_req *req\t= udc->req;"
    },
    {
        "line": 6,
        "fullcodeline": "u16 status = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "req->usb_req.length = 2;"
    },
    {
        "line": 41,
        "fullcodeline": "*(u16 *)req->usb_req.buf = cpu_to_le16(status);"
    },
    {
        "line": 42,
        "fullcodeline": "ret = __xudc_ep0_queue(ep0, req);"
    },
    {
        "line": 46,
        "fullcodeline": "dev_err(udc->dev, \"Can't respond to getstatus request\\n\");"
    },
    {
        "line": 47,
        "fullcodeline": "xudc_ep0_stall(udc);"
    },
    {
        "line": 12,
        "fullcodeline": "switch (udc->setup.bRequestType & USB_RECIP_MASK) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 15,
        "fullcodeline": "status = 1 << USB_DEVICE_SELF_POWERED;"
    },
    {
        "line": 22,
        "fullcodeline": "epnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;"
    },
    {
        "line": 24,
        "fullcodeline": "epcfgreg = udc->read_fn(udc->addr + target_ep->offset);"
    },
    {
        "line": 25,
        "fullcodeline": "halt = epcfgreg & XUSB_EP_CFG_STALL_MASK;"
    },
    {
        "line": 26,
        "fullcodeline": "if (udc->setup.wIndex & USB_DIR_IN) {"
    },
    {
        "line": 17,
        "fullcodeline": "status |= (1 << USB_DEVICE_REMOTE_WAKEUP);"
    },
    {
        "line": 34,
        "fullcodeline": "status = 1 << USB_ENDPOINT_HALT;"
    },
    {
        "line": 27,
        "fullcodeline": "if (!target_ep->is_in)"
    }
]