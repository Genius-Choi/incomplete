[
    {
        "line": 3,
        "fullcodeline": "if params[:username] && !params[:recent]"
    },
    {
        "line": 11,
        "fullcodeline": "guardian.ensure_can_see_notifications!(user)"
    },
    {
        "line": 13,
        "fullcodeline": "if notification_types = params[:filter_by_types]&.split(\",\").presence"
    },
    {
        "line": 4,
        "fullcodeline": "user_record = User.find_by(username: params[:username].to_s)"
    },
    {
        "line": 7,
        "fullcodeline": "else"
    },
    {
        "line": 14,
        "fullcodeline": "notification_types.map! do |type|"
    },
    {
        "line": 21,
        "fullcodeline": "limit = fetch_limit_from_params(default: 15, max: INDEX_LIMIT)"
    },
    {
        "line": 25,
        "fullcodeline": "notifications ="
    },
    {
        "line": 28,
        "fullcodeline": "include_reviewables = notification_types.blank? && guardian.can_see_review_queue?"
    },
    {
        "line": 49,
        "fullcodeline": "notifications = filter_inaccessible_notifications(notifications)"
    },
    {
        "line": 51,
        "fullcodeline": "json = {"
    },
    {
        "line": 65,
        "fullcodeline": "offset = params[:offset].to_i"
    },
    {
        "line": 67,
        "fullcodeline": "notifications ="
    },
    {
        "line": 74,
        "fullcodeline": "total_rows = notifications.dup.count"
    },
    {
        "line": 75,
        "fullcodeline": "notifications = notifications.offset(offset).limit(60)"
    },
    {
        "line": 76,
        "fullcodeline": "notifications = filter_inaccessible_notifications(notifications)"
    },
    {
        "line": 5,
        "fullcodeline": "raise Discourse::NotFound if !user_record"
    },
    {
        "line": 26,
        "fullcodeline": "Notification.prioritized_list(current_user, count: limit, types: notification_types)"
    },
    {
        "line": 30,
        "fullcodeline": "if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)"
    },
    {
        "line": 63,
        "fullcodeline": "render_json_dump(json)"
    },
    {
        "line": 68,
        "fullcodeline": "Notification.where(user_id: user.id).visible.includes(:topic).order(created_at: :desc)"
    },
    {
        "line": 70,
        "fullcodeline": "notifications = notifications.where(read: true) if params[:filter] == \"read\""
    },
    {
        "line": 72,
        "fullcodeline": "notifications = notifications.where(read: false) if params[:filter] == \"unread\""
    },
    {
        "line": 77,
        "fullcodeline": "render_json_dump("
    },
    {
        "line": 37,
        "fullcodeline": "if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode &&"
    },
    {
        "line": 40,
        "fullcodeline": "Scheduler::Defer.later \"bump last seen reviewable for user\" do"
    },
    {
        "line": 52,
        "fullcodeline": "notifications: serialize_data(notifications, NotificationSerializer),"
    },
    {
        "line": 53,
        "fullcodeline": "seen_notification_id: current_user.seen_notification_id,"
    },
    {
        "line": 57,
        "fullcodeline": "json[:pending_reviewables] = Reviewable.basic_serializers_for_list("
    },
    {
        "line": 78,
        "fullcodeline": "notifications: serialize_data(notifications, NotificationSerializer),"
    },
    {
        "line": 82,
        "fullcodeline": "notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]),"
    },
    {
        "line": 58,
        "fullcodeline": "Reviewable.user_menu_list_for(current_user),"
    }
]