[
    {
        "line": 7,
        "fullcodeline": "int\t\tresult = FALSE;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t\tsize = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tflag = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "int\t\tgo_to_nextline = FALSE;"
    },
    {
        "line": 12,
        "fullcodeline": "nfa_list_T\tlist[2];"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\t*listids = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\tlistids_len = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tadd_off = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\ttoplevel = start->c == NFA_MOPEN;"
    },
    {
        "line": 30,
        "fullcodeline": "fast_breakcheck();"
    },
    {
        "line": 46,
        "fullcodeline": "nfa_match = FALSE;"
    },
    {
        "line": 49,
        "fullcodeline": "size = (prog->nstate + 1) * sizeof(nfa_thread_T);"
    },
    {
        "line": 51,
        "fullcodeline": "list[0].t = alloc(size);"
    },
    {
        "line": 52,
        "fullcodeline": "list[0].len = prog->nstate + 1;"
    },
    {
        "line": 53,
        "fullcodeline": "list[1].t = alloc(size);"
    },
    {
        "line": 54,
        "fullcodeline": "list[1].len = prog->nstate + 1;"
    },
    {
        "line": 75,
        "fullcodeline": "thislist = &list[0];"
    },
    {
        "line": 76,
        "fullcodeline": "thislist->n = 0;"
    },
    {
        "line": 77,
        "fullcodeline": "thislist->has_pim = FALSE;"
    },
    {
        "line": 78,
        "fullcodeline": "nextlist = &list[1];"
    },
    {
        "line": 79,
        "fullcodeline": "nextlist->n = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "nextlist->has_pim = FALSE;"
    },
    {
        "line": 84,
        "fullcodeline": "thislist->id = rex.nfa_listid + 1;"
    },
    {
        "line": 1449,
        "fullcodeline": "vim_free(list[0].t);"
    },
    {
        "line": 1450,
        "fullcodeline": "vim_free(list[1].t);"
    },
    {
        "line": 1451,
        "fullcodeline": "vim_free(listids);"
    },
    {
        "line": 55,
        "fullcodeline": "if (list[0].t == NULL || list[1].t == NULL)"
    },
    {
        "line": 102,
        "fullcodeline": "if (r == NULL)"
    },
    {
        "line": 97,
        "fullcodeline": "m->norm.in_use = 1;"
    },
    {
        "line": 98,
        "fullcodeline": "r = addstate(thislist, start->out, m, NULL, 0);"
    },
    {
        "line": 104,
        "fullcodeline": "nfa_match = NFA_TOO_EXPENSIVE;"
    },
    {
        "line": 139,
        "fullcodeline": "thislist = &list[flag];"
    },
    {
        "line": 140,
        "fullcodeline": "nextlist = &list[flag ^= 1];"
    },
    {
        "line": 141,
        "fullcodeline": "nextlist->n = 0;\t    // clear nextlist"
    },
    {
        "line": 142,
        "fullcodeline": "nextlist->has_pim = FALSE;"
    },
    {
        "line": 143,
        "fullcodeline": "++rex.nfa_listid;"
    },
    {
        "line": 156,
        "fullcodeline": "thislist->id = rex.nfa_listid;"
    },
    {
        "line": 157,
        "fullcodeline": "nextlist->id = rex.nfa_listid + 1;"
    },
    {
        "line": 1427,
        "fullcodeline": "line_breakcheck();"
    },
    {
        "line": 101,
        "fullcodeline": "r = addstate(thislist, start, m, NULL, 0);"
    },
    {
        "line": 132,
        "fullcodeline": "if (curc == NUL)"
    },
    {
        "line": 144,
        "fullcodeline": "if (prog->re_engine == AUTOMATIC_ENGINE"
    },
    {
        "line": 179,
        "fullcodeline": "if (thislist->n == 0)"
    },
    {
        "line": 183,
        "fullcodeline": "for (listidx = 0; listidx < thislist->n; ++listidx)"
    },
    {
        "line": 1324,
        "fullcodeline": "if (nfa_match == FALSE"
    },
    {
        "line": 1418,
        "fullcodeline": "if (clen != 0)"
    },
    {
        "line": 93,
        "fullcodeline": "m->norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);"
    },
    {
        "line": 124,
        "fullcodeline": "curc = (*mb_ptr2char)(rex.input);"
    },
    {
        "line": 125,
        "fullcodeline": "clen = (*mb_ptr2len)(rex.input);"
    },
    {
        "line": 134,
        "fullcodeline": "clen = 0;"
    },
    {
        "line": 135,
        "fullcodeline": "go_to_nextline = FALSE;"
    },
    {
        "line": 145,
        "fullcodeline": "&& (rex.nfa_listid >= NFA_MAX_STATES"
    },
    {
        "line": 152,
        "fullcodeline": "nfa_match = NFA_TOO_EXPENSIVE;"
    },
    {
        "line": 187,
        "fullcodeline": "fast_breakcheck();"
    },
    {
        "line": 225,
        "fullcodeline": "add_state = NULL;"
    },
    {
        "line": 226,
        "fullcodeline": "add_here = FALSE;"
    },
    {
        "line": 227,
        "fullcodeline": "add_count = 0;"
    },
    {
        "line": 1325,
        "fullcodeline": "&& ((toplevel"
    },
    {
        "line": 1419,
        "fullcodeline": "rex.input += clen;"
    },
    {
        "line": 129,
        "fullcodeline": "curc = *rex.input;"
    },
    {
        "line": 130,
        "fullcodeline": "clen = 1;"
    },
    {
        "line": 1212,
        "fullcodeline": "if (add_state != NULL)"
    },
    {
        "line": 1330,
        "fullcodeline": "|| (nfa_endp != NULL"
    },
    {
        "line": 308,
        "fullcodeline": "nfa_match = TRUE;"
    },
    {
        "line": 549,
        "fullcodeline": "result = TRUE;"
    },
    {
        "line": 576,
        "fullcodeline": "result = TRUE;"
    },
    {
        "line": 813,
        "fullcodeline": "result = vim_isIDc(curc);"
    },
    {
        "line": 814,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 818,
        "fullcodeline": "result = !VIM_ISDIGIT(curc) && vim_isIDc(curc);"
    },
    {
        "line": 819,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 823,
        "fullcodeline": "result = vim_iswordp_buf(rex.input, rex.reg_buf);"
    },
    {
        "line": 824,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 828,
        "fullcodeline": "result = !VIM_ISDIGIT(curc)"
    },
    {
        "line": 830,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 834,
        "fullcodeline": "result = vim_isfilec(curc);"
    },
    {
        "line": 835,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 839,
        "fullcodeline": "result = !VIM_ISDIGIT(curc) && vim_isfilec(curc);"
    },
    {
        "line": 840,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 844,
        "fullcodeline": "result = vim_isprintc(PTR2CHAR(rex.input));"
    },
    {
        "line": 845,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 849,
        "fullcodeline": "result = !VIM_ISDIGIT(curc) && vim_isprintc(PTR2CHAR(rex.input));"
    },
    {
        "line": 850,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 854,
        "fullcodeline": "result = VIM_ISWHITE(curc);"
    },
    {
        "line": 855,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 859,
        "fullcodeline": "result = curc != NUL && !VIM_ISWHITE(curc);"
    },
    {
        "line": 860,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 864,
        "fullcodeline": "result = ri_digit(curc);"
    },
    {
        "line": 865,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 869,
        "fullcodeline": "result = curc != NUL && !ri_digit(curc);"
    },
    {
        "line": 870,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 874,
        "fullcodeline": "result = ri_hex(curc);"
    },
    {
        "line": 875,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 879,
        "fullcodeline": "result = curc != NUL && !ri_hex(curc);"
    },
    {
        "line": 880,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 884,
        "fullcodeline": "result = ri_octal(curc);"
    },
    {
        "line": 885,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 889,
        "fullcodeline": "result = curc != NUL && !ri_octal(curc);"
    },
    {
        "line": 890,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 894,
        "fullcodeline": "result = ri_word(curc);"
    },
    {
        "line": 895,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 899,
        "fullcodeline": "result = curc != NUL && !ri_word(curc);"
    },
    {
        "line": 900,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 904,
        "fullcodeline": "result = ri_head(curc);"
    },
    {
        "line": 905,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 909,
        "fullcodeline": "result = curc != NUL && !ri_head(curc);"
    },
    {
        "line": 910,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 914,
        "fullcodeline": "result = ri_alpha(curc);"
    },
    {
        "line": 915,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 919,
        "fullcodeline": "result = curc != NUL && !ri_alpha(curc);"
    },
    {
        "line": 920,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 924,
        "fullcodeline": "result = ri_lower(curc);"
    },
    {
        "line": 925,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 929,
        "fullcodeline": "result = curc != NUL && !ri_lower(curc);"
    },
    {
        "line": 930,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 934,
        "fullcodeline": "result = ri_upper(curc);"
    },
    {
        "line": 935,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 939,
        "fullcodeline": "result = curc != NUL && !ri_upper(curc);"
    },
    {
        "line": 940,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 944,
        "fullcodeline": "result = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));"
    },
    {
        "line": 945,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 949,
        "fullcodeline": "result = curc != NUL"
    },
    {
        "line": 951,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 955,
        "fullcodeline": "result = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));"
    },
    {
        "line": 956,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 960,
        "fullcodeline": "result = curc != NUL"
    },
    {
        "line": 962,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 1050,
        "fullcodeline": "result = (REG_MULTI &&"
    },
    {
        "line": 1063,
        "fullcodeline": "result = nfa_re_num_cmp(t->state->val, t->state->c - NFA_COL,"
    },
    {
        "line": 1142,
        "fullcodeline": "result = (rex.reg_win != NULL"
    },
    {
        "line": 1155,
        "fullcodeline": "result = reg_match_visual();"
    },
    {
        "line": 1328,
        "fullcodeline": "&& (rex.reg_maxcol == 0"
    },
    {
        "line": 1331,
        "fullcodeline": "&& (REG_MULTI"
    },
    {
        "line": 1345,
        "fullcodeline": "int add = TRUE;"
    },
    {
        "line": 1420,
        "fullcodeline": "else if (go_to_nextline || (nfa_endp != NULL && REG_MULTI"
    },
    {
        "line": 239,
        "fullcodeline": "nfa_match = TRUE;"
    },
    {
        "line": 240,
        "fullcodeline": "copy_sub(&submatch->norm, &t->subs.norm);"
    },
    {
        "line": 288,
        "fullcodeline": "if (nfa_endp != NULL && (REG_MULTI"
    },
    {
        "line": 296,
        "fullcodeline": "if (t->state->c != NFA_END_INVISIBLE_NEG)"
    },
    {
        "line": 310,
        "fullcodeline": "if (nextlist->n == 0)"
    },
    {
        "line": 424,
        "fullcodeline": "nfa_state_T *skip = NULL;"
    },
    {
        "line": 465,
        "fullcodeline": "copy_sub_off(&m->norm, &t->subs.norm);"
    },
    {
        "line": 472,
        "fullcodeline": "result = recursive_regmatch(t->state, NULL, prog,"
    },
    {
        "line": 533,
        "fullcodeline": "if (rex.input == rex.line)"
    },
    {
        "line": 541,
        "fullcodeline": "if (curc == NUL)"
    },
    {
        "line": 551,
        "fullcodeline": "if (curc == NUL)"
    },
    {
        "line": 577,
        "fullcodeline": "if (rex.input == rex.line)"
    },
    {
        "line": 602,
        "fullcodeline": "if (rex.lnum == 0 && rex.input == rex.line"
    },
    {
        "line": 611,
        "fullcodeline": "if (rex.lnum == rex.reg_maxline && curc == NUL)"
    },
    {
        "line": 620,
        "fullcodeline": "int\t    mc = curc;"
    },
    {
        "line": 621,
        "fullcodeline": "int\t    len = 0;"
    },
    {
        "line": 624,
        "fullcodeline": "int\t    cchars[MAX_MCO];"
    },
    {
        "line": 625,
        "fullcodeline": "int\t    ccount = 0;"
    },
    {
        "line": 629,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 689,
        "fullcodeline": "end = t->state->out1;\t    // NFA_END_COMPOSING"
    },
    {
        "line": 690,
        "fullcodeline": "ADD_STATE_IF_MATCH(end);"
    },
    {
        "line": 695,
        "fullcodeline": "if (curc == NUL && !rex.reg_line_lbr && REG_MULTI"
    },
    {
        "line": 727,
        "fullcodeline": "result_if_matched = (t->state->c == NFA_START_COLL);"
    },
    {
        "line": 787,
        "fullcodeline": "if (curc > 0)"
    },
    {
        "line": 797,
        "fullcodeline": "if (enc_utf8 && utf_iscomposing(curc))"
    },
    {
        "line": 1032,
        "fullcodeline": "if (t->count - clen <= 0)"
    },
    {
        "line": 1076,
        "fullcodeline": "int     op = t->state->c - NFA_VCOL;"
    },
    {
        "line": 1077,
        "fullcodeline": "colnr_T col = (colnr_T)(rex.input - rex.line);"
    },
    {
        "line": 1078,
        "fullcodeline": "win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;"
    },
    {
        "line": 1085,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 1111,
        "fullcodeline": "pos_T\t*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);"
    },
    {
        "line": 1192,
        "fullcodeline": "int c = t->state->c;"
    },
    {
        "line": 1198,
        "fullcodeline": "result = (c == curc);"
    },
    {
        "line": 1206,
        "fullcodeline": "ADD_STATE_IF_MATCH(t->state);"
    },
    {
        "line": 1217,
        "fullcodeline": "if (t->pim.result == NFA_PIM_UNUSED)"
    },
    {
        "line": 1224,
        "fullcodeline": "if (pim != NULL && (clen == 0 || match_follows(add_state, 0)))"
    },
    {
        "line": 1292,
        "fullcodeline": "if (pim == &t->pim)"
    },
    {
        "line": 1307,
        "fullcodeline": "if (r == NULL)"
    },
    {
        "line": 1327,
        "fullcodeline": "&& clen != 0"
    },
    {
        "line": 1329,
        "fullcodeline": "|| (colnr_T)(rex.input - rex.line) < rex.reg_maxcol))"
    },
    {
        "line": 1332,
        "fullcodeline": "? (rex.lnum < nfa_endp->se_u.pos.lnum"
    },
    {
        "line": 1336,
        "fullcodeline": ": rex.input < nfa_endp->se_u.ptr))))"
    },
    {
        "line": 1348,
        "fullcodeline": "if (prog->regstart != NUL && clen != 0)"
    },
    {
        "line": 1422,
        "fullcodeline": "reg_nextline();"
    },
    {
        "line": 235,
        "fullcodeline": "if (enc_utf8 && !rex.reg_icombine"
    },
    {
        "line": 252,
        "fullcodeline": "if (nextlist->n == 0)"
    },
    {
        "line": 298,
        "fullcodeline": "copy_sub(&m->norm, &t->subs.norm);"
    },
    {
        "line": 311,
        "fullcodeline": "clen = 0;"
    },
    {
        "line": 330,
        "fullcodeline": "if (t->pim.result != NFA_PIM_UNUSED"
    },
    {
        "line": 431,
        "fullcodeline": "if (state_in_list(nextlist, t->state->out1->out, &t->subs))"
    },
    {
        "line": 454,
        "fullcodeline": "if (skip != NULL)"
    },
    {
        "line": 474,
        "fullcodeline": "if (result == NFA_TOO_EXPENSIVE)"
    },
    {
        "line": 535,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 543,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 552,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 570,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 578,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 596,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 603,
        "fullcodeline": "&& (!REG_MULTI || rex.reg_firstlnum == 1))"
    },
    {
        "line": 605,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 613,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 630,
        "fullcodeline": "if (utf_iscomposing(sta->c))"
    },
    {
        "line": 637,
        "fullcodeline": "if (rex.reg_icombine && len == 0)"
    },
    {
        "line": 696,
        "fullcodeline": "&& rex.lnum <= rex.reg_maxline)"
    },
    {
        "line": 698,
        "fullcodeline": "go_to_nextline = TRUE;"
    },
    {
        "line": 702,
        "fullcodeline": "add_off = -1;"
    },
    {
        "line": 723,
        "fullcodeline": "if (curc == NUL)"
    },
    {
        "line": 790,
        "fullcodeline": "add_off = clen;"
    },
    {
        "line": 799,
        "fullcodeline": "add_off = clen;"
    },
    {
        "line": 829,
        "fullcodeline": "&& vim_iswordp_buf(rex.input, rex.reg_buf);"
    },
    {
        "line": 950,
        "fullcodeline": "&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));"
    },
    {
        "line": 961,
        "fullcodeline": "&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));"
    },
    {
        "line": 990,
        "fullcodeline": "if (t->state->c <= NFA_BACKREF9)"
    },
    {
        "line": 1036,
        "fullcodeline": "add_off = clen;"
    },
    {
        "line": 1051,
        "fullcodeline": "nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,"
    },
    {
        "line": 1055,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1064,
        "fullcodeline": "(long_u)(rex.input - rex.line) + 1);"
    },
    {
        "line": 1067,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1082,
        "fullcodeline": "if (op != 1 && col > t->state->val"
    },
    {
        "line": 1086,
        "fullcodeline": "if (op == 1 && col - 1 > t->state->val && col > 100)"
    },
    {
        "line": 1096,
        "fullcodeline": "if (!result)"
    },
    {
        "line": 1115,
        "fullcodeline": "if (pos != NULL && pos->lnum > 0)"
    },
    {
        "line": 1145,
        "fullcodeline": "&& ((colnr_T)(rex.input - rex.line)"
    },
    {
        "line": 1149,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1158,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1200,
        "fullcodeline": "if (!result && rex.reg_ic)"
    },
    {
        "line": 1204,
        "fullcodeline": "if (result && enc_utf8 && !rex.reg_icombine)"
    },
    {
        "line": 1218,
        "fullcodeline": "pim = NULL;"
    },
    {
        "line": 1286,
        "fullcodeline": "pim = NULL;"
    },
    {
        "line": 1294,
        "fullcodeline": "copy_pim(&pim_copy, pim);"
    },
    {
        "line": 1295,
        "fullcodeline": "pim = &pim_copy;"
    },
    {
        "line": 1299,
        "fullcodeline": "r = addstate_here(thislist, add_state, &t->subs,"
    },
    {
        "line": 1309,
        "fullcodeline": "nfa_match = NFA_TOO_EXPENSIVE;"
    },
    {
        "line": 1326,
        "fullcodeline": "&& rex.lnum == 0"
    },
    {
        "line": 1333,
        "fullcodeline": "|| (rex.lnum == nfa_endp->se_u.pos.lnum"
    },
    {
        "line": 1396,
        "fullcodeline": "if (addstate(nextlist, start, m, NULL, clen) == NULL)"
    },
    {
        "line": 1421,
        "fullcodeline": "&& rex.lnum < nfa_endp->se_u.pos.lnum))"
    },
    {
        "line": 236,
        "fullcodeline": "&& rex.input != rex.line && utf_iscomposing(curc))"
    },
    {
        "line": 253,
        "fullcodeline": "clen = 0;"
    },
    {
        "line": 289,
        "fullcodeline": "? (rex.lnum != nfa_endp->se_u.pos.lnum"
    },
    {
        "line": 292,
        "fullcodeline": ": rex.input != nfa_endp->se_u.ptr))"
    },
    {
        "line": 334,
        "fullcodeline": "|| t->state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)"
    },
    {
        "line": 336,
        "fullcodeline": "int in_use = m->norm.in_use;"
    },
    {
        "line": 340,
        "fullcodeline": "copy_sub_off(&m->norm, &t->subs.norm);"
    },
    {
        "line": 350,
        "fullcodeline": "result = recursive_regmatch(t->state, NULL, prog,"
    },
    {
        "line": 383,
        "fullcodeline": "m->norm.in_use = in_use;"
    },
    {
        "line": 433,
        "fullcodeline": "skip = t->state->out1->out;"
    },
    {
        "line": 476,
        "fullcodeline": "nfa_match = result;"
    },
    {
        "line": 488,
        "fullcodeline": "copy_sub_off(&t->subs.norm, &m->norm);"
    },
    {
        "line": 635,
        "fullcodeline": "len += mb_char2len(mc);"
    },
    {
        "line": 773,
        "fullcodeline": "state = state->out;"
    },
    {
        "line": 779,
        "fullcodeline": "add_state = t->state->out1->out;"
    },
    {
        "line": 780,
        "fullcodeline": "add_off = clen;"
    },
    {
        "line": 803,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 804,
        "fullcodeline": "add_off = 0;"
    },
    {
        "line": 992,
        "fullcodeline": "subidx = t->state->c - NFA_BACKREF1 + 1;"
    },
    {
        "line": 993,
        "fullcodeline": "result = match_backref(&t->subs.norm, subidx, &bytelen);"
    },
    {
        "line": 1041,
        "fullcodeline": "add_state = t->state;"
    },
    {
        "line": 1042,
        "fullcodeline": "add_off = 0;"
    },
    {
        "line": 1043,
        "fullcodeline": "add_count = t->count - clen;"
    },
    {
        "line": 1052,
        "fullcodeline": "(long_u)(rex.lnum + rex.reg_firstlnum)));"
    },
    {
        "line": 1094,
        "fullcodeline": "result = col > t->state->val * ts;"
    },
    {
        "line": 1097,
        "fullcodeline": "result = nfa_re_num_cmp(t->state->val, op,"
    },
    {
        "line": 1101,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1117,
        "fullcodeline": "colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum"
    },
    {
        "line": 1123,
        "fullcodeline": "result = (pos->lnum == rex.lnum + rex.reg_firstlnum"
    },
    {
        "line": 1143,
        "fullcodeline": "&& (rex.lnum + rex.reg_firstlnum"
    },
    {
        "line": 1201,
        "fullcodeline": "result = MB_CASEFOLD(c) == MB_CASEFOLD(curc);"
    },
    {
        "line": 1205,
        "fullcodeline": "clen = utf_ptr2len(rex.input);"
    },
    {
        "line": 1220,
        "fullcodeline": "pim = &t->pim;"
    },
    {
        "line": 1226,
        "fullcodeline": "if (pim->result == NFA_PIM_TODO)"
    },
    {
        "line": 1266,
        "fullcodeline": "if (result != (pim->state->c == NFA_START_INVISIBLE_NEG"
    },
    {
        "line": 1303,
        "fullcodeline": "r = addstate(nextlist, add_state, &t->subs, pim, add_off);"
    },
    {
        "line": 1334,
        "fullcodeline": "&& (int)(rex.input - rex.line)"
    },
    {
        "line": 1350,
        "fullcodeline": "if (nextlist->n == 0)"
    },
    {
        "line": 1387,
        "fullcodeline": "if (addstate(nextlist, start->out, m, NULL, clen) == NULL)"
    },
    {
        "line": 1398,
        "fullcodeline": "nfa_match = NFA_TOO_EXPENSIVE;"
    },
    {
        "line": 290,
        "fullcodeline": "|| (int)(rex.input - rex.line)"
    },
    {
        "line": 333,
        "fullcodeline": "|| t->state->c == NFA_START_INVISIBLE_BEFORE_FIRST"
    },
    {
        "line": 352,
        "fullcodeline": "if (result == NFA_TOO_EXPENSIVE)"
    },
    {
        "line": 360,
        "fullcodeline": "if (result != (t->state->c == NFA_START_INVISIBLE_NEG"
    },
    {
        "line": 395,
        "fullcodeline": "pim.state = t->state;"
    },
    {
        "line": 396,
        "fullcodeline": "pim.result = NFA_PIM_TODO;"
    },
    {
        "line": 397,
        "fullcodeline": "pim.subs.norm.in_use = 0;"
    },
    {
        "line": 505,
        "fullcodeline": "if (bytelen == 0)"
    },
    {
        "line": 641,
        "fullcodeline": "if (sta->c != curc)"
    },
    {
        "line": 645,
        "fullcodeline": "while (sta->c != NFA_END_COMPOSING)"
    },
    {
        "line": 646,
        "fullcodeline": "sta = sta->out;"
    },
    {
        "line": 704,
        "fullcodeline": "else if (curc == '\\n' && rex.reg_line_lbr)"
    },
    {
        "line": 730,
        "fullcodeline": "if (state->c == NFA_END_COLL)"
    },
    {
        "line": 735,
        "fullcodeline": "if (state->c == NFA_RANGE_MIN)"
    },
    {
        "line": 1005,
        "fullcodeline": "if (bytelen == 0)"
    },
    {
        "line": 1092,
        "fullcodeline": "if (ts < 4)"
    },
    {
        "line": 1234,
        "fullcodeline": "result = recursive_regmatch(pim->state, pim,"
    },
    {
        "line": 1236,
        "fullcodeline": "pim->result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;"
    },
    {
        "line": 1274,
        "fullcodeline": "copy_sub_off(&t->subs.norm, &pim->subs.norm);"
    },
    {
        "line": 1304,
        "fullcodeline": "if (add_count > 0)"
    },
    {
        "line": 1352,
        "fullcodeline": "colnr_T col = (colnr_T)(rex.input - rex.line) + clen;"
    },
    {
        "line": 1362,
        "fullcodeline": "rex.input = rex.line + col - clen;"
    },
    {
        "line": 1383,
        "fullcodeline": "m->norm.list.multi[0].start_col ="
    },
    {
        "line": 1389,
        "fullcodeline": "nfa_match = NFA_TOO_EXPENSIVE;"
    },
    {
        "line": 332,
        "fullcodeline": "|| t->state->c == NFA_START_INVISIBLE_NEG_FIRST"
    },
    {
        "line": 354,
        "fullcodeline": "nfa_match = result;"
    },
    {
        "line": 368,
        "fullcodeline": "copy_sub_off(&t->subs.norm, &m->norm);"
    },
    {
        "line": 375,
        "fullcodeline": "copy_ze_off(&t->subs.norm, &m->norm);"
    },
    {
        "line": 380,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 381,
        "fullcodeline": "add_state = t->state->out1->out;"
    },
    {
        "line": 412,
        "fullcodeline": "if (addstate_here(thislist, t->state->out1->out,"
    },
    {
        "line": 438,
        "fullcodeline": "else if (state_in_list(nextlist,"
    },
    {
        "line": 497,
        "fullcodeline": "bytelen = m->norm.list.multi[0].end_col"
    },
    {
        "line": 510,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 511,
        "fullcodeline": "add_state = t->state->out1->out->out;"
    },
    {
        "line": 558,
        "fullcodeline": "this_class = mb_get_class_buf(rex.input, rex.reg_buf);"
    },
    {
        "line": 584,
        "fullcodeline": "this_class = mb_get_class_buf(rex.input, rex.reg_buf);"
    },
    {
        "line": 585,
        "fullcodeline": "prev_class = reg_prev_class();"
    },
    {
        "line": 642,
        "fullcodeline": "result = FAIL;"
    },
    {
        "line": 650,
        "fullcodeline": "else if (len > 0 || mc == sta->c)"
    },
    {
        "line": 708,
        "fullcodeline": "add_off = 1;"
    },
    {
        "line": 732,
        "fullcodeline": "result = !result_if_matched;"
    },
    {
        "line": 737,
        "fullcodeline": "c1 = state->val;"
    },
    {
        "line": 738,
        "fullcodeline": "state = state->out; // advance to NFA_RANGE_MAX"
    },
    {
        "line": 739,
        "fullcodeline": "c2 = state->val;"
    },
    {
        "line": 1009,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1083,
        "fullcodeline": "* (has_mbyte ? MB_MAXBYTES : 1))"
    },
    {
        "line": 1093,
        "fullcodeline": "ts = 4;"
    },
    {
        "line": 1098,
        "fullcodeline": "(long_u)win_linetabsize(wp, rex.line, col) + 1);"
    },
    {
        "line": 1119,
        "fullcodeline": "? (colnr_T)STRLEN(reg_getline("
    },
    {
        "line": 1124,
        "fullcodeline": "? (pos_col == (colnr_T)(rex.input - rex.line)"
    },
    {
        "line": 1129,
        "fullcodeline": ": (pos->lnum < rex.lnum + rex.reg_firstlnum"
    },
    {
        "line": 1134,
        "fullcodeline": "add_here = TRUE;"
    },
    {
        "line": 1239,
        "fullcodeline": "if (result != (pim->state->c == NFA_START_INVISIBLE_NEG"
    },
    {
        "line": 1256,
        "fullcodeline": "result = (pim->result == NFA_PIM_MATCH);"
    },
    {
        "line": 1270,
        "fullcodeline": "|| pim->state->c"
    },
    {
        "line": 1305,
        "fullcodeline": "nextlist->t[nextlist->n - 1].count = add_count;"
    },
    {
        "line": 1356,
        "fullcodeline": "if (skip_to_start(prog->regstart, &col) == FAIL)"
    },
    {
        "line": 1368,
        "fullcodeline": "c = PTR2CHAR(rex.input + clen);"
    },
    {
        "line": 1384,
        "fullcodeline": "(colnr_T)(rex.input - rex.line) + clen;"
    },
    {
        "line": 1386,
        "fullcodeline": "m->norm.list.line[0].start = rex.input + clen;"
    },
    {
        "line": 331,
        "fullcodeline": "|| t->state->c == NFA_START_INVISIBLE_FIRST"
    },
    {
        "line": 364,
        "fullcodeline": "|| t->state->c"
    },
    {
        "line": 403,
        "fullcodeline": "pim.end.pos.col = (int)(rex.input - rex.line);"
    },
    {
        "line": 404,
        "fullcodeline": "pim.end.pos.lnum = rex.lnum;"
    },
    {
        "line": 415,
        "fullcodeline": "nfa_match = NFA_TOO_EXPENSIVE;"
    },
    {
        "line": 441,
        "fullcodeline": "skip = t->state->out1->out->out;"
    },
    {
        "line": 500,
        "fullcodeline": "bytelen = (int)(m->norm.list.line[0].end - rex.input);"
    },
    {
        "line": 559,
        "fullcodeline": "if (this_class <= 1)"
    },
    {
        "line": 586,
        "fullcodeline": "if (this_class == prev_class"
    },
    {
        "line": 644,
        "fullcodeline": "result = OK;"
    },
    {
        "line": 672,
        "fullcodeline": "result = OK;"
    },
    {
        "line": 744,
        "fullcodeline": "if (curc >= c1 && curc <= c2)"
    },
    {
        "line": 1118,
        "fullcodeline": "&& pos->col == MAXCOL"
    },
    {
        "line": 1125,
        "fullcodeline": "? t->state->c == NFA_MARK"
    },
    {
        "line": 1126,
        "fullcodeline": ": (pos_col < (colnr_T)(rex.input - rex.line)"
    },
    {
        "line": 1130,
        "fullcodeline": "? t->state->c == NFA_MARK_GT"
    },
    {
        "line": 1131,
        "fullcodeline": ": t->state->c == NFA_MARK_LT));"
    },
    {
        "line": 1247,
        "fullcodeline": "copy_sub_off(&pim->subs.norm, &m->norm);"
    },
    {
        "line": 1268,
        "fullcodeline": "|| pim->state->c"
    },
    {
        "line": 1369,
        "fullcodeline": "if (c != prog->regstart && (!rex.reg_ic"
    },
    {
        "line": 362,
        "fullcodeline": "|| t->state->c"
    },
    {
        "line": 407,
        "fullcodeline": "pim.end.ptr = rex.input;"
    },
    {
        "line": 498,
        "fullcodeline": "- (int)(rex.input - rex.line);"
    },
    {
        "line": 513,
        "fullcodeline": "else if (bytelen <= clen)"
    },
    {
        "line": 560,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 564,
        "fullcodeline": "else if (!vim_iswordc_buf(curc, rex.reg_buf)"
    },
    {
        "line": 587,
        "fullcodeline": "|| prev_class == 0 || prev_class == 1)"
    },
    {
        "line": 588,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 590,
        "fullcodeline": "else if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)"
    },
    {
        "line": 652,
        "fullcodeline": "if (len == 0)"
    },
    {
        "line": 660,
        "fullcodeline": "while (len < clen)"
    },
    {
        "line": 673,
        "fullcodeline": "while (sta->c != NFA_END_COMPOSING)"
    },
    {
        "line": 687,
        "fullcodeline": "result = FAIL;"
    },
    {
        "line": 746,
        "fullcodeline": "result = result_if_matched;"
    },
    {
        "line": 751,
        "fullcodeline": "int curc_low = MB_CASEFOLD(curc);"
    },
    {
        "line": 752,
        "fullcodeline": "int done = FALSE;"
    },
    {
        "line": 765,
        "fullcodeline": "else if (state->c < 0 ? check_char_class(state->c, curc)"
    },
    {
        "line": 1012,
        "fullcodeline": "else if (bytelen <= clen)"
    },
    {
        "line": 1127,
        "fullcodeline": "? t->state->c == NFA_MARK_GT"
    },
    {
        "line": 1128,
        "fullcodeline": ": t->state->c == NFA_MARK_LT))"
    },
    {
        "line": 1243,
        "fullcodeline": "|| pim->state->c"
    },
    {
        "line": 1267,
        "fullcodeline": "|| pim->state->c == NFA_START_INVISIBLE_NEG_FIRST"
    },
    {
        "line": 1375,
        "fullcodeline": "add = FALSE;"
    },
    {
        "line": 361,
        "fullcodeline": "|| t->state->c == NFA_START_INVISIBLE_NEG_FIRST"
    },
    {
        "line": 446,
        "fullcodeline": "else if (state_in_list(thislist,"
    },
    {
        "line": 517,
        "fullcodeline": "add_state = t->state->out1->out->out;"
    },
    {
        "line": 518,
        "fullcodeline": "add_off = clen;"
    },
    {
        "line": 565,
        "fullcodeline": "|| (rex.input > rex.line"
    },
    {
        "line": 567,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 591,
        "fullcodeline": "|| (rex.input[0] != NUL"
    },
    {
        "line": 593,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 654,
        "fullcodeline": "len += mb_char2len(mc);"
    },
    {
        "line": 655,
        "fullcodeline": "sta = sta->out;"
    },
    {
        "line": 662,
        "fullcodeline": "mc = mb_ptr2char(rex.input + len);"
    },
    {
        "line": 663,
        "fullcodeline": "cchars[ccount++] = mc;"
    },
    {
        "line": 664,
        "fullcodeline": "len += mb_char2len(mc);"
    },
    {
        "line": 683,
        "fullcodeline": "sta = sta->out;"
    },
    {
        "line": 754,
        "fullcodeline": "for ( ; c1 <= c2; ++c1)"
    },
    {
        "line": 766,
        "fullcodeline": ": (curc == state->c"
    },
    {
        "line": 770,
        "fullcodeline": "result = result_if_matched;"
    },
    {
        "line": 1017,
        "fullcodeline": "add_off = clen;"
    },
    {
        "line": 1120,
        "fullcodeline": "pos->lnum - rex.reg_firstlnum))"
    },
    {
        "line": 1241,
        "fullcodeline": "|| pim->state->c"
    },
    {
        "line": 1370,
        "fullcodeline": "|| MB_CASEFOLD(c) != MB_CASEFOLD(prog->regstart)))"
    },
    {
        "line": 449,
        "fullcodeline": "skip = t->state->out1->out->out;"
    },
    {
        "line": 524,
        "fullcodeline": "add_state = t->state->out1->out;"
    },
    {
        "line": 525,
        "fullcodeline": "add_off = bytelen;"
    },
    {
        "line": 526,
        "fullcodeline": "add_count = bytelen - clen;"
    },
    {
        "line": 561,
        "fullcodeline": "else if (reg_prev_class() == this_class)"
    },
    {
        "line": 566,
        "fullcodeline": "&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))"
    },
    {
        "line": 592,
        "fullcodeline": "&& vim_iswordc_buf(curc, rex.reg_buf)))"
    },
    {
        "line": 665,
        "fullcodeline": "if (ccount == MAX_MCO)"
    },
    {
        "line": 675,
        "fullcodeline": "for (j = 0; j < ccount; ++j)"
    },
    {
        "line": 678,
        "fullcodeline": "if (j == ccount)"
    },
    {
        "line": 755,
        "fullcodeline": "if (MB_CASEFOLD(c1) == curc_low)"
    },
    {
        "line": 767,
        "fullcodeline": "|| (rex.reg_ic && MB_CASEFOLD(curc)"
    },
    {
        "line": 1024,
        "fullcodeline": "add_off = bytelen;"
    },
    {
        "line": 1025,
        "fullcodeline": "add_count = bytelen - clen;"
    },
    {
        "line": 1240,
        "fullcodeline": "|| pim->state->c == NFA_START_INVISIBLE_NEG_FIRST"
    },
    {
        "line": 562,
        "fullcodeline": "result = FALSE;"
    },
    {
        "line": 676,
        "fullcodeline": "if (cchars[j] == sta->c)"
    },
    {
        "line": 680,
        "fullcodeline": "result = FAIL;"
    },
    {
        "line": 757,
        "fullcodeline": "result = result_if_matched;"
    },
    {
        "line": 758,
        "fullcodeline": "done = TRUE;"
    },
    {
        "line": 768,
        "fullcodeline": "== MB_CASEFOLD(state->c))))"
    }
]