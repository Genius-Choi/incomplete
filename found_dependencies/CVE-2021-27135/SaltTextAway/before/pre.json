[
    {
        "line": 6,
        "fullcodeline": "TScreen *screen = TScreenOf(xw);"
    },
    {
        "line": 10,
        "fullcodeline": "int need = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "CELL first = *cellc;"
    },
    {
        "line": 14,
        "fullcodeline": "CELL last = *cell;"
    },
    {
        "line": 20,
        "fullcodeline": "scp = &(screen->selected_cells[which]);"
    },
    {
        "line": 30,
        "fullcodeline": "--last.col;"
    },
    {
        "line": 65,
        "fullcodeline": "line[need] = '\\0';\t\t/* make sure it is null terminated */"
    },
    {
        "line": 66,
        "fullcodeline": "lp = line;\t\t\t/* lp points to where to save the text */"
    },
    {
        "line": 81,
        "fullcodeline": "*lp = '\\0';\t\t\t/* make sure we have end marked */"
    },
    {
        "line": 16,
        "fullcodeline": "if (which < 0 || which >= MAX_SELECTIONS) {"
    },
    {
        "line": 22,
        "fullcodeline": "TRACE((\"SaltTextAway which=%d, first=%d,%d, last=%d,%d\\n\","
    },
    {
        "line": 33,
        "fullcodeline": "if (isSameRow(&last, &first)) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (need < 0)"
    },
    {
        "line": 62,
        "fullcodeline": "if (line == 0)"
    },
    {
        "line": 83,
        "fullcodeline": "TRACE((\"Salted TEXT:%u:%s\\n\", (unsigned) (lp - line),"
    },
    {
        "line": 86,
        "fullcodeline": "scp->data_length = (size_t) (lp - line);"
    },
    {
        "line": 17,
        "fullcodeline": "TRACE((\"SaltTextAway - which selection?\\n\"));"
    },
    {
        "line": 25,
        "fullcodeline": "if (isSameRow(&first, &last) && first.col > last.col) {"
    },
    {
        "line": 27,
        "fullcodeline": "EXCHANGE(first.col, last.col, tmp);"
    },
    {
        "line": 34,
        "fullcodeline": "need = Length(screen, first.row, first.col, last.col);"
    },
    {
        "line": 68,
        "fullcodeline": "lp = SaveText(screen, last.row, first.col, last.col, lp, &eol);"
    },
    {
        "line": 36,
        "fullcodeline": "need += Length(screen, first.row, first.col, screen->max_col) + 1;"
    },
    {
        "line": 57,
        "fullcodeline": "scp->data_limit = (size_t) (need + 1);"
    },
    {
        "line": 59,
        "fullcodeline": "line = scp->data_buffer;"
    },
    {
        "line": 70,
        "fullcodeline": "lp = SaveText(screen, first.row, first.col, screen->max_col, lp, &eol);"
    },
    {
        "line": 84,
        "fullcodeline": "visibleChars(line, (unsigned) (lp - line))));"
    },
    {
        "line": 37,
        "fullcodeline": "for (i = first.row + 1; i < last.row; i++)"
    },
    {
        "line": 38,
        "fullcodeline": "need += Length(screen, i, 0, screen->max_col) + 1;"
    },
    {
        "line": 39,
        "fullcodeline": "if (last.col >= 0)"
    },
    {
        "line": 53,
        "fullcodeline": "if ((line = (Char *) malloc((size_t) need + 1)) == 0)"
    },
    {
        "line": 54,
        "fullcodeline": "SysError(ERROR_BMALLOC2);"
    },
    {
        "line": 73,
        "fullcodeline": "for (i = first.row + 1; i < last.row; i++) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (last.col >= 0)"
    },
    {
        "line": 40,
        "fullcodeline": "need += Length(screen, last.row, 0, last.col);"
    },
    {
        "line": 74,
        "fullcodeline": "lp = SaveText(screen, i, 0, screen->max_col, lp, &eol);"
    },
    {
        "line": 79,
        "fullcodeline": "lp = SaveText(screen, last.row, 0, last.col, lp, &eol);"
    },
    {
        "line": 72,
        "fullcodeline": "*lp++ = '\\n';\t/* put in newline at end of line */"
    },
    {
        "line": 76,
        "fullcodeline": "*lp++ = '\\n';"
    }
]