[
    {
        "line": 2,
        "fullcodeline": "{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;"
    },
    {
        "line": 3,
        "fullcodeline": "const FLAC__Frame *frame = pflac->frame ;"
    },
    {
        "line": 4,
        "fullcodeline": "const int32_t* const *buffer = pflac->wbuffer ;"
    },
    {
        "line": 5,
        "fullcodeline": "unsigned i = 0, j, offset, channels, len ;"
    },
    {
        "line": 21,
        "fullcodeline": "channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;"
    },
    {
        "line": 41,
        "fullcodeline": "len = SF_MIN (pflac->len, frame->header.blocksize) ;"
    },
    {
        "line": 155,
        "fullcodeline": "offset = i * channels ;"
    },
    {
        "line": 156,
        "fullcodeline": "pflac->pos += i * channels ;"
    },
    {
        "line": 12,
        "fullcodeline": "if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)"
    },
    {
        "line": 18,
        "fullcodeline": "if (frame->header.channels > FLAC__MAX_CHANNELS)"
    },
    {
        "line": 23,
        "fullcodeline": "if (pflac->ptr == NULL)"
    },
    {
        "line": 43,
        "fullcodeline": "if (pflac->remain % channels != 0)"
    },
    {
        "line": 13,
        "fullcodeline": "{\tpsf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;"
    },
    {
        "line": 14,
        "fullcodeline": "psf->error = SFE_INTERNAL ;"
    },
    {
        "line": 19,
        "fullcodeline": "psf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;"
    },
    {
        "line": 35,
        "fullcodeline": "pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;"
    },
    {
        "line": 44,
        "fullcodeline": "{\tpsf_log_printf (psf, \"Error: pflac->remain %u    channels %u\\n\", pflac->remain, channels) ;"
    },
    {
        "line": 28,
        "fullcodeline": "for (i = 0 ; i < channels ; i++)"
    },
    {
        "line": 50,
        "fullcodeline": "{\tshort *retpcm = (short*) pflac->ptr ;"
    },
    {
        "line": 51,
        "fullcodeline": "int shift = 16 - frame->header.bits_per_sample ;"
    },
    {
        "line": 90,
        "fullcodeline": "{\tint *retpcm = (int*) pflac->ptr ;"
    },
    {
        "line": 91,
        "fullcodeline": "int shift = 32 - frame->header.bits_per_sample ;"
    },
    {
        "line": 110,
        "fullcodeline": "{\tfloat *retpcm = (float*) pflac->ptr ;"
    },
    {
        "line": 111,
        "fullcodeline": "float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;"
    },
    {
        "line": 131,
        "fullcodeline": "{\tdouble *retpcm = (double*) pflac->ptr ;"
    },
    {
        "line": 132,
        "fullcodeline": "double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;"
    },
    {
        "line": 33,
        "fullcodeline": "memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;"
    },
    {
        "line": 52,
        "fullcodeline": "if (shift < 0)"
    },
    {
        "line": 92,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 113,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 134,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 30,
        "fullcodeline": "if (pflac->rbuffer [i] == NULL)"
    },
    {
        "line": 53,
        "fullcodeline": "{\tshift = abs (shift) ;"
    },
    {
        "line": 93,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 103,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 104,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 114,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 124,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 125,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 135,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 145,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 146,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 31,
        "fullcodeline": "pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;"
    },
    {
        "line": 54,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 95,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 98,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 101,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 102,
        "fullcodeline": "retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;"
    },
    {
        "line": 116,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 119,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 122,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 123,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;"
    },
    {
        "line": 137,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 140,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 143,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 144,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;"
    },
    {
        "line": 55,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 65,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 66,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 70,
        "fullcodeline": "{\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 57,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 60,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 63,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 64,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;"
    },
    {
        "line": 71,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 82,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 83,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 73,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 76,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 79,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 80,
        "fullcodeline": "retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;"
    }
]