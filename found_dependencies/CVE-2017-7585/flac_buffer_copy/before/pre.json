[
    {
        "line": 2,
        "fullcodeline": "{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;"
    },
    {
        "line": 3,
        "fullcodeline": "const FLAC__Frame *frame = pflac->frame ;"
    },
    {
        "line": 4,
        "fullcodeline": "const int32_t* const *buffer = pflac->wbuffer ;"
    },
    {
        "line": 5,
        "fullcodeline": "unsigned i = 0, j, offset, channels, len ;"
    },
    {
        "line": 21,
        "fullcodeline": "channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;"
    },
    {
        "line": 42,
        "fullcodeline": "len = SF_MIN (pflac->len, frame->header.blocksize) ;"
    },
    {
        "line": 151,
        "fullcodeline": "offset = i * channels ;"
    },
    {
        "line": 12,
        "fullcodeline": "if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)"
    },
    {
        "line": 18,
        "fullcodeline": "if (frame->header.channels > FLAC__MAX_CHANNELS)"
    },
    {
        "line": 23,
        "fullcodeline": "if (pflac->ptr == NULL)"
    },
    {
        "line": 152,
        "fullcodeline": "pflac->pos += i * channels ;"
    },
    {
        "line": 13,
        "fullcodeline": "{\tpsf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;"
    },
    {
        "line": 14,
        "fullcodeline": "psf->error = SFE_INTERNAL ;"
    },
    {
        "line": 19,
        "fullcodeline": "psf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;"
    },
    {
        "line": 29,
        "fullcodeline": "for (i = 0 ; i < channels ; i++)"
    },
    {
        "line": 47,
        "fullcodeline": "int shift = 16 - frame->header.bits_per_sample ;"
    },
    {
        "line": 87,
        "fullcodeline": "int shift = 32 - frame->header.bits_per_sample ;"
    },
    {
        "line": 107,
        "fullcodeline": "float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;"
    },
    {
        "line": 128,
        "fullcodeline": "double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;"
    },
    {
        "line": 34,
        "fullcodeline": "memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;"
    },
    {
        "line": 48,
        "fullcodeline": "if (shift < 0)"
    },
    {
        "line": 88,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 109,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 130,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 31,
        "fullcodeline": "if (pflac->rbuffer [i] == NULL)"
    },
    {
        "line": 49,
        "fullcodeline": "{\tshift = abs (shift) ;"
    },
    {
        "line": 89,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 99,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 100,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 110,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 120,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 121,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 131,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 141,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 142,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 32,
        "fullcodeline": "pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;"
    },
    {
        "line": 50,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 91,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 97,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 112,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 118,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 133,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 139,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 51,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 61,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 62,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 66,
        "fullcodeline": "{\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 98,
        "fullcodeline": "retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;"
    },
    {
        "line": 119,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;"
    },
    {
        "line": 140,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;"
    },
    {
        "line": 53,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 59,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 67,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 78,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 79,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 60,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;"
    },
    {
        "line": 69,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 75,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 76,
        "fullcodeline": "retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;"
    }
]