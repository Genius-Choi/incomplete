[
    {
        "line": 4,
        "fullcodeline": "ptls_context_t *tlsctx = ptls_get_context(tls);"
    },
    {
        "line": 5,
        "fullcodeline": "ptls_cipher_suite_t *cipher = ptls_get_cipher(tls);"
    },
    {
        "line": 9,
        "fullcodeline": "static const char *log_labels[2][4] = {"
    },
    {
        "line": 14,
        "fullcodeline": "QUICLY_PROBE(CRYPTO_UPDATE_SECRET, conn, conn->stash.now, is_enc, epoch, log_label,"
    },
    {
        "line": 15,
        "fullcodeline": "QUICLY_PROBE_HEXDUMP(secret, cipher->hash->digest_size));"
    },
    {
        "line": 23,
        "fullcodeline": "if (tlsctx->log_event != NULL) {"
    },
    {
        "line": 78,
        "fullcodeline": "if ((ret = setup_cipher(conn, epoch, is_enc, hp_slot, aead_slot, cipher->aead, cipher->hash, secret)) != 0)"
    },
    {
        "line": 81,
        "fullcodeline": "if (epoch == QUICLY_EPOCH_1RTT && is_enc) {"
    },
    {
        "line": 3,
        "fullcodeline": "quicly_conn_t *conn = *ptls_get_data_ptr(tls);"
    },
    {
        "line": 10,
        "fullcodeline": "{NULL, \"CLIENT_EARLY_TRAFFIC_SECRET\", \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", \"CLIENT_TRAFFIC_SECRET_0\"},"
    },
    {
        "line": 11,
        "fullcodeline": "{NULL, NULL, \"SERVER_HANDSHAKE_TRAFFIC_SECRET\", \"SERVER_TRAFFIC_SECRET_0\"}};"
    },
    {
        "line": 24,
        "fullcodeline": "char hexbuf[PTLS_MAX_DIGEST_SIZE * 2 + 1];"
    },
    {
        "line": 25,
        "fullcodeline": "ptls_hexdump(hexbuf, secret, cipher->hash->digest_size);"
    },
    {
        "line": 26,
        "fullcodeline": "tlsctx->log_event->cb(tlsctx->log_event, tls, log_label, \"%s\", hexbuf);"
    },
    {
        "line": 37,
        "fullcodeline": "assert(is_enc == quicly_is_client(conn));"
    },
    {
        "line": 50,
        "fullcodeline": "SELECT_CIPHER_CONTEXT(is_enc ? &conn->handshake->cipher.egress : &conn->handshake->cipher.ingress);"
    },
    {
        "line": 72,
        "fullcodeline": "assert(!\"logic flaw\");"
    },
    {
        "line": 83,
        "fullcodeline": "conn->application->one_rtt_writable = 1;"
    },
    {
        "line": 84,
        "fullcodeline": "open_blocked_streams(conn, 1);"
    },
    {
        "line": 85,
        "fullcodeline": "open_blocked_streams(conn, 0);"
    },
    {
        "line": 93,
        "fullcodeline": "size_t size = local_cid_size(conn);"
    },
    {
        "line": 12,
        "fullcodeline": "const char *log_label = log_labels[ptls_is_server(tls) == is_enc][epoch];"
    },
    {
        "line": 38,
        "fullcodeline": "if (conn->application == NULL && (ret = setup_application_space(conn)) != 0)"
    },
    {
        "line": 48,
        "fullcodeline": "if (conn->handshake == NULL && (ret = setup_handshake_space_and_flow(conn, QUICLY_EPOCH_HANDSHAKE)) != 0)"
    },
    {
        "line": 69,
        "fullcodeline": "memcpy(secret_store, secret, cipher->hash->digest_size);"
    },
    {
        "line": 87,
        "fullcodeline": "if (!quicly_is_client(conn) && conn->super.ctx->generate_resumption_token != NULL) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (quicly_local_cid_set_size(&conn->super.local.cid_set, size))"
    },
    {
        "line": 56,
        "fullcodeline": "if (conn->application == NULL && (ret = setup_application_space(conn)) != 0)"
    },
    {
        "line": 88,
        "fullcodeline": "ret = quicly_send_resumption_token(conn);"
    },
    {
        "line": 89,
        "fullcodeline": "assert(ret == 0);"
    },
    {
        "line": 95,
        "fullcodeline": "conn->egress.pending_flows |= QUICLY_PENDING_FLOW_OTHERS_BIT;"
    },
    {
        "line": 62,
        "fullcodeline": "SELECT_CIPHER_CONTEXT(&conn->application->cipher.egress.key);"
    },
    {
        "line": 54,
        "fullcodeline": "if ((ret = apply_remote_transport_params(conn)) != 0)"
    },
    {
        "line": 60,
        "fullcodeline": "if (conn->application->cipher.egress.key.aead != NULL)"
    },
    {
        "line": 61,
        "fullcodeline": "dispose_cipher(&conn->application->cipher.egress.key);"
    }
]