[
    {
        "line": 6,
        "fullcodeline": "if (conn->egress.path_challenge.head != NULL) {"
    },
    {
        "line": 26,
        "fullcodeline": "if ((ret = send_max_streams(conn, 1, s)) != 0)"
    },
    {
        "line": 28,
        "fullcodeline": "if ((ret = send_max_streams(conn, 0, s)) != 0)"
    },
    {
        "line": 32,
        "fullcodeline": "if (should_send_max_data(conn)) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (conn->egress.data_blocked == QUICLY_SENDER_STATE_SEND && (ret = send_data_blocked(conn, s)) != 0)"
    },
    {
        "line": 49,
        "fullcodeline": "if ((ret = send_streams_blocked(conn, 1, s)) != 0)"
    },
    {
        "line": 51,
        "fullcodeline": "if ((ret = send_streams_blocked(conn, 0, s)) != 0)"
    },
    {
        "line": 55,
        "fullcodeline": "size_t i, size = quicly_local_cid_get_size(&conn->super.local.cid_set);"
    },
    {
        "line": 64,
        "fullcodeline": "quicly_local_cid_on_sent(&conn->super.local.cid_set, i);"
    },
    {
        "line": 70,
        "fullcodeline": "size_t i, size = quicly_retire_cid_get_num_pending(&conn->egress.retire_cid);"
    },
    {
        "line": 76,
        "fullcodeline": "quicly_retire_cid_shift(&conn->egress.retire_cid, i);"
    },
    {
        "line": 21,
        "fullcodeline": "conn->egress.path_challenge.tail_ref = &conn->egress.path_challenge.head;"
    },
    {
        "line": 22,
        "fullcodeline": "s->target.full_size = 1; /* datagrams carrying PATH_CHALLENGE / PATH_RESPONSE have to be full-sized */"
    },
    {
        "line": 37,
        "fullcodeline": "s->dst = quicly_encode_max_data_frame(s->dst, new_value);"
    },
    {
        "line": 38,
        "fullcodeline": "quicly_maxsender_record(&conn->ingress.max_data.sender, new_value, &sent->data.max_data.args);"
    },
    {
        "line": 40,
        "fullcodeline": "QUICLY_PROBE(MAX_DATA_SEND, conn, conn->stash.now, new_value);"
    },
    {
        "line": 56,
        "fullcodeline": "for (i = 0; i < size; i++) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (ret != 0)"
    },
    {
        "line": 71,
        "fullcodeline": "for (i = 0; i < size; i++) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (ret != 0)"
    },
    {
        "line": 20,
        "fullcodeline": "} while (conn->egress.path_challenge.head != NULL);"
    },
    {
        "line": 34,
        "fullcodeline": "if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_MAX_DATA_FRAME_CAPACITY, &sent, on_ack_max_data)) != 0)"
    },
    {
        "line": 8,
        "fullcodeline": "struct st_quicly_pending_path_challenge_t *c = conn->egress.path_challenge.head;"
    },
    {
        "line": 12,
        "fullcodeline": "s->dst = quicly_encode_path_challenge_frame(s->dst, c->is_response, c->data);"
    },
    {
        "line": 18,
        "fullcodeline": "conn->egress.path_challenge.head = c->next;"
    },
    {
        "line": 19,
        "fullcodeline": "free(c);"
    },
    {
        "line": 59,
        "fullcodeline": "if (c->state != QUICLY_LOCAL_CID_STATE_PENDING)"
    },
    {
        "line": 61,
        "fullcodeline": "if ((ret = send_new_connection_id(conn, s, c)) != 0)"
    },
    {
        "line": 73,
        "fullcodeline": "if ((ret = send_retire_connection_id(conn, s, sequence)) != 0)"
    },
    {
        "line": 9,
        "fullcodeline": "if ((ret = do_allocate_frame(conn, s, QUICLY_PATH_CHALLENGE_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) !="
    }
]