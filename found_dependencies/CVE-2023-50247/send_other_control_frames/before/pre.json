[
    {
        "line": 6,
        "fullcodeline": "if (conn->egress.path_challenge.head != NULL) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (should_send_max_data(conn)) {"
    },
    {
        "line": 55,
        "fullcodeline": "size_t i, size = quicly_local_cid_get_size(&conn->super.local.cid_set);"
    },
    {
        "line": 70,
        "fullcodeline": "size_t i, size = quicly_retire_cid_get_num_pending(&conn->egress.retire_cid);"
    },
    {
        "line": 26,
        "fullcodeline": "if ((ret = send_max_streams(conn, 1, s)) != 0)"
    },
    {
        "line": 28,
        "fullcodeline": "if ((ret = send_max_streams(conn, 0, s)) != 0)"
    },
    {
        "line": 36,
        "fullcodeline": "uint64_t new_value = conn->ingress.max_data.bytes_consumed + conn->super.ctx->transport_params.max_data;"
    },
    {
        "line": 37,
        "fullcodeline": "s->dst = quicly_encode_max_data_frame(s->dst, new_value);"
    },
    {
        "line": 38,
        "fullcodeline": "quicly_maxsender_record(&conn->ingress.max_data.sender, new_value, &sent->data.max_data.args);"
    },
    {
        "line": 40,
        "fullcodeline": "QUICLY_PROBE(MAX_DATA_SEND, conn, conn->stash.now, new_value);"
    },
    {
        "line": 45,
        "fullcodeline": "if (conn->egress.data_blocked == QUICLY_SENDER_STATE_SEND && (ret = send_data_blocked(conn, s)) != 0)"
    },
    {
        "line": 49,
        "fullcodeline": "if ((ret = send_streams_blocked(conn, 1, s)) != 0)"
    },
    {
        "line": 51,
        "fullcodeline": "if ((ret = send_streams_blocked(conn, 0, s)) != 0)"
    },
    {
        "line": 56,
        "fullcodeline": "for (i = 0; i < size; i++) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (ret != 0)"
    },
    {
        "line": 71,
        "fullcodeline": "for (i = 0; i < size; i++) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (ret != 0)"
    },
    {
        "line": 20,
        "fullcodeline": "} while (conn->egress.path_challenge.head != NULL);"
    },
    {
        "line": 58,
        "fullcodeline": "struct st_quicly_local_cid_t *c = &conn->super.local.cid_set.cids[i];"
    },
    {
        "line": 72,
        "fullcodeline": "uint64_t sequence = conn->egress.retire_cid.sequences[i];"
    },
    {
        "line": 8,
        "fullcodeline": "struct st_quicly_pending_path_challenge_t *c = conn->egress.path_challenge.head;"
    },
    {
        "line": 12,
        "fullcodeline": "s->dst = quicly_encode_path_challenge_frame(s->dst, c->is_response, c->data);"
    },
    {
        "line": 18,
        "fullcodeline": "conn->egress.path_challenge.head = c->next;"
    },
    {
        "line": 34,
        "fullcodeline": "if ((ret = allocate_ack_eliciting_frame(conn, s, QUICLY_MAX_DATA_FRAME_CAPACITY, &sent, on_ack_max_data)) != 0)"
    },
    {
        "line": 59,
        "fullcodeline": "if (c->state != QUICLY_LOCAL_CID_STATE_PENDING)"
    },
    {
        "line": 9,
        "fullcodeline": "if ((ret = do_allocate_frame(conn, s, QUICLY_PATH_CHALLENGE_FRAME_CAPACITY, ALLOCATE_FRAME_TYPE_NON_ACK_ELICITING)) !="
    },
    {
        "line": 61,
        "fullcodeline": "if ((ret = send_new_connection_id(conn, s, c)) != 0)"
    },
    {
        "line": 73,
        "fullcodeline": "if ((ret = send_retire_connection_id(conn, s, sequence)) != 0)"
    },
    {
        "line": 14,
        "fullcodeline": "++conn->super.stats.num_frames_sent.path_response;"
    },
    {
        "line": 16,
        "fullcodeline": "++conn->super.stats.num_frames_sent.path_challenge;"
    }
]