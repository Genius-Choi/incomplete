[
    {
        "line": 3,
        "fullcodeline": "const int32_t num_split = context->num_outputs();"
    },
    {
        "line": 4,
        "fullcodeline": "const Tensor& input = context->input(0);"
    },
    {
        "line": 5,
        "fullcodeline": "const TensorShape& input_shape = input.shape();"
    },
    {
        "line": 6,
        "fullcodeline": "const Tensor& split_tensor = context->input(1);"
    },
    {
        "line": 7,
        "fullcodeline": "const Tensor& split_dim_tensor = context->input(2);"
    },
    {
        "line": 9,
        "fullcodeline": "OP_REQUIRES(context, split_dim_tensor.NumElements() == 1,"
    },
    {
        "line": 13,
        "fullcodeline": "const int32_t split_dim_orig = split_dim_tensor.flat<int32>()(0);"
    },
    {
        "line": 14,
        "fullcodeline": "const int32_t split_dim ="
    },
    {
        "line": 17,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 25,
        "fullcodeline": "auto split_sizes_d = split_tensor.vec<Tlen>();"
    },
    {
        "line": 27,
        "fullcodeline": "split_sizes_vec->resize(split_sizes_d.size());"
    },
    {
        "line": 29,
        "fullcodeline": "std::copy(split_sizes_d.data(), split_sizes_d.data() + split_sizes_d.size(),"
    },
    {
        "line": 32,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 37,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 43,
        "fullcodeline": "Tlen input_size_split_dim = input_shape.dim_size(split_dim);"
    },
    {
        "line": 59,
        "fullcodeline": "int neg_one_dim = -1;"
    },
    {
        "line": 60,
        "fullcodeline": "Tlen determined_size = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 10,
        "fullcodeline": "errors::InvalidArgument(\"split_dim_tensor must have \""
    },
    {
        "line": 15,
        "fullcodeline": "split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;"
    },
    {
        "line": 19,
        "fullcodeline": "split_tensor.dims() == 1 && split_tensor.NumElements() == num_split,"
    },
    {
        "line": 20,
        "fullcodeline": "errors::InvalidArgument(\"size of the split_tensor must be 1-D and have \""
    },
    {
        "line": 30,
        "fullcodeline": "split_sizes_vec->begin());"
    },
    {
        "line": 33,
        "fullcodeline": "context, num_split > 0,"
    },
    {
        "line": 34,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 38,
        "fullcodeline": "context, 0 <= split_dim && split_dim < input.dims(),"
    },
    {
        "line": 39,
        "fullcodeline": "errors::InvalidArgument(\"-input rank(-\", input.dims(),"
    },
    {
        "line": 46,
        "fullcodeline": "if (num_split == 1) {"
    },
    {
        "line": 61,
        "fullcodeline": "for (int d = 0; d < split_sizes_vec->size(); ++d) {"
    },
    {
        "line": 76,
        "fullcodeline": "(neg_one_dim == -1 && determined_size == input_size_split_dim) ||"
    },
    {
        "line": 78,
        "fullcodeline": "errors::InvalidArgument(\"Determined shape must either match \""
    },
    {
        "line": 22,
        "fullcodeline": "split_tensor.dims(), \" -D and \","
    },
    {
        "line": 23,
        "fullcodeline": "split_tensor.NumElements(), \" elements\"));"
    },
    {
        "line": 40,
        "fullcodeline": "\") <= split_dim < input rank (\", input.dims(),"
    },
    {
        "line": 47,
        "fullcodeline": "context->set_output(0, context->input(0));"
    },
    {
        "line": 48,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 54,
        "fullcodeline": "*done = true;"
    },
    {
        "line": 62,
        "fullcodeline": "Tlen size = (*split_sizes_vec)[d];"
    },
    {
        "line": 77,
        "fullcodeline": "(neg_one_dim >= 0 && determined_size <= input_size_split_dim),"
    },
    {
        "line": 86,
        "fullcodeline": "(*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;"
    },
    {
        "line": 100,
        "fullcodeline": "input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {"
    },
    {
        "line": 101,
        "fullcodeline": "Tlen start = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "context, (*split_sizes_vec)[0] == input_size_split_dim,"
    },
    {
        "line": 50,
        "fullcodeline": "errors::InvalidArgument(\"If there is only one output, it must have \""
    },
    {
        "line": 64,
        "fullcodeline": "if (size == -1) {"
    },
    {
        "line": 102,
        "fullcodeline": "for (int i = 0; i < num_split; ++i) {"
    },
    {
        "line": 65,
        "fullcodeline": "OP_REQUIRES(context, neg_one_dim == -1,"
    },
    {
        "line": 68,
        "fullcodeline": "neg_one_dim = d;"
    },
    {
        "line": 103,
        "fullcodeline": "context->set_output(i,"
    },
    {
        "line": 105,
        "fullcodeline": "start += (*split_sizes_vec)[i];"
    },
    {
        "line": 66,
        "fullcodeline": "errors::InvalidArgument(\"There can only be one -1 in the \""
    },
    {
        "line": 70,
        "fullcodeline": "determined_size += size;"
    },
    {
        "line": 104,
        "fullcodeline": "input.Slice(start, start + (*split_sizes_vec)[i]));"
    }
]