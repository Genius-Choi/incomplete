[
    {
        "line": 12,
        "fullcodeline": "u8 ip_proto = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "key_control = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 31,
        "fullcodeline": "key_basic = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 298,
        "fullcodeline": "key_basic->n_proto = proto;"
    },
    {
        "line": 299,
        "fullcodeline": "key_basic->ip_proto = ip_proto;"
    },
    {
        "line": 300,
        "fullcodeline": "key_control->thoff = (u16)nhoff;"
    },
    {
        "line": 14,
        "fullcodeline": "if (!data) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 302,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 15,
        "fullcodeline": "data = skb->data;"
    },
    {
        "line": 16,
        "fullcodeline": "proto = skb->protocol;"
    },
    {
        "line": 17,
        "fullcodeline": "nhoff = skb_network_offset(skb);"
    },
    {
        "line": 18,
        "fullcodeline": "hlen = skb_headlen(skb);"
    },
    {
        "line": 37,
        "fullcodeline": "struct ethhdr *eth = eth_hdr(skb);"
    },
    {
        "line": 40,
        "fullcodeline": "key_eth_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 43,
        "fullcodeline": "memcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));"
    },
    {
        "line": 48,
        "fullcodeline": "case htons(ETH_P_IP): {"
    },
    {
        "line": 72,
        "fullcodeline": "case htons(ETH_P_IPV6): {"
    },
    {
        "line": 110,
        "fullcodeline": "case htons(ETH_P_8021AD):"
    },
    {
        "line": 111,
        "fullcodeline": "case htons(ETH_P_8021Q): {"
    },
    {
        "line": 132,
        "fullcodeline": "case htons(ETH_P_PPP_SES): {"
    },
    {
        "line": 151,
        "fullcodeline": "case htons(ETH_P_TIPC): {"
    },
    {
        "line": 173,
        "fullcodeline": "case htons(ETH_P_MPLS_UC):"
    },
    {
        "line": 174,
        "fullcodeline": "case htons(ETH_P_MPLS_MC): {"
    },
    {
        "line": 203,
        "fullcodeline": "case htons(ETH_P_FCOE):"
    },
    {
        "line": 204,
        "fullcodeline": "key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);"
    },
    {
        "line": 286,
        "fullcodeline": "proto = htons(ETH_P_IP);"
    },
    {
        "line": 289,
        "fullcodeline": "proto = htons(ETH_P_IPV6);"
    },
    {
        "line": 292,
        "fullcodeline": "proto = htons(ETH_P_MPLS_UC);"
    },
    {
        "line": 304,
        "fullcodeline": "key_ports = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 307,
        "fullcodeline": "key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,"
    },
    {
        "line": 52,
        "fullcodeline": "iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);"
    },
    {
        "line": 55,
        "fullcodeline": "nhoff += iph->ihl * 4;"
    },
    {
        "line": 57,
        "fullcodeline": "ip_proto = iph->protocol;"
    },
    {
        "line": 65,
        "fullcodeline": "key_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 67,
        "fullcodeline": "memcpy(&key_addrs->v4addrs, &iph->saddr,"
    },
    {
        "line": 69,
        "fullcodeline": "key_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;"
    },
    {
        "line": 78,
        "fullcodeline": "iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);"
    },
    {
        "line": 82,
        "fullcodeline": "ip_proto = iph->nexthdr;"
    },
    {
        "line": 83,
        "fullcodeline": "nhoff += sizeof(struct ipv6hdr);"
    },
    {
        "line": 97,
        "fullcodeline": "flow_label = ip6_flowlabel(iph);"
    },
    {
        "line": 115,
        "fullcodeline": "vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);"
    },
    {
        "line": 128,
        "fullcodeline": "proto = vlan->h_vlan_encapsulated_proto;"
    },
    {
        "line": 129,
        "fullcodeline": "nhoff += sizeof(*vlan);"
    },
    {
        "line": 137,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);"
    },
    {
        "line": 140,
        "fullcodeline": "proto = hdr->proto;"
    },
    {
        "line": 141,
        "fullcodeline": "nhoff += PPPOE_SES_HLEN;"
    },
    {
        "line": 156,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);"
    },
    {
        "line": 159,
        "fullcodeline": "key_basic->n_proto = proto;"
    },
    {
        "line": 160,
        "fullcodeline": "key_control->thoff = (u16)nhoff;"
    },
    {
        "line": 175,
        "fullcodeline": "struct mpls_label *hdr, _hdr[2];"
    },
    {
        "line": 177,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,"
    },
    {
        "line": 218,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);"
    },
    {
        "line": 228,
        "fullcodeline": "proto = hdr->proto;"
    },
    {
        "line": 229,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 270,
        "fullcodeline": "u8 _opthdr[2], *opthdr;"
    },
    {
        "line": 275,
        "fullcodeline": "opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),"
    },
    {
        "line": 280,
        "fullcodeline": "ip_proto = opthdr[0];"
    },
    {
        "line": 281,
        "fullcodeline": "nhoff += (opthdr[1] + 1) << 3;"
    },
    {
        "line": 53,
        "fullcodeline": "if (!iph || iph->ihl < 5)"
    },
    {
        "line": 58,
        "fullcodeline": "if (ip_is_fragment(iph))"
    },
    {
        "line": 61,
        "fullcodeline": "if (!skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 79,
        "fullcodeline": "if (!iph)"
    },
    {
        "line": 85,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 116,
        "fullcodeline": "if (!vlan)"
    },
    {
        "line": 119,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 138,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 157,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 162,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 179,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 182,
        "fullcodeline": "if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>"
    },
    {
        "line": 219,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 225,
        "fullcodeline": "if (hdr->flags & (GRE_VERSION | GRE_ROUTING))"
    },
    {
        "line": 230,
        "fullcodeline": "if (hdr->flags & GRE_CSUM)"
    },
    {
        "line": 232,
        "fullcodeline": "if (hdr->flags & GRE_KEY) {"
    },
    {
        "line": 251,
        "fullcodeline": "if (hdr->flags & GRE_SEQ)"
    },
    {
        "line": 253,
        "fullcodeline": "if (proto == htons(ETH_P_TEB)) {"
    },
    {
        "line": 272,
        "fullcodeline": "if (proto != htons(ETH_P_IPV6))"
    },
    {
        "line": 277,
        "fullcodeline": "if (!opthdr)"
    },
    {
        "line": 59,
        "fullcodeline": "ip_proto = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 93,
        "fullcodeline": "memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));"
    },
    {
        "line": 94,
        "fullcodeline": "key_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;"
    },
    {
        "line": 121,
        "fullcodeline": "key_tags = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 125,
        "fullcodeline": "key_tags->vlan_id = skb_vlan_tag_get_id(skb);"
    },
    {
        "line": 143,
        "fullcodeline": "case htons(PPP_IP):"
    },
    {
        "line": 145,
        "fullcodeline": "case htons(PPP_IPV6):"
    },
    {
        "line": 164,
        "fullcodeline": "key_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 167,
        "fullcodeline": "key_addrs->tipcaddrs.srcnode = hdr->srcnode;"
    },
    {
        "line": 168,
        "fullcodeline": "key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;"
    },
    {
        "line": 193,
        "fullcodeline": "key_basic->n_proto = proto;"
    },
    {
        "line": 194,
        "fullcodeline": "key_basic->ip_proto = ip_proto;"
    },
    {
        "line": 195,
        "fullcodeline": "key_control->thoff = (u16)nhoff;"
    },
    {
        "line": 231,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 236,
        "fullcodeline": "keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),"
    },
    {
        "line": 249,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 252,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 257,
        "fullcodeline": "eth = __skb_header_pointer(skb, nhoff,"
    },
    {
        "line": 262,
        "fullcodeline": "proto = eth->h_proto;"
    },
    {
        "line": 263,
        "fullcodeline": "nhoff += sizeof(*eth);"
    },
    {
        "line": 99,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 184,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 239,
        "fullcodeline": "if (!keyid)"
    },
    {
        "line": 242,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 260,
        "fullcodeline": "if (!eth)"
    },
    {
        "line": 101,
        "fullcodeline": "key_tags = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 104,
        "fullcodeline": "key_tags->flow_label = ntohl(flow_label);"
    },
    {
        "line": 186,
        "fullcodeline": "key_keyid = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 189,
        "fullcodeline": "key_keyid->keyid = hdr[1].entry &"
    },
    {
        "line": 244,
        "fullcodeline": "key_keyid = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 190,
        "fullcodeline": "htonl(MPLS_LS_LABEL_MASK);"
    }
]