[
    {
        "line": 12,
        "fullcodeline": "u8 ip_proto = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "bool ret = false;"
    },
    {
        "line": 25,
        "fullcodeline": "key_control = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 32,
        "fullcodeline": "key_basic = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 303,
        "fullcodeline": "ret = true;"
    },
    {
        "line": 306,
        "fullcodeline": "key_basic->n_proto = proto;"
    },
    {
        "line": 307,
        "fullcodeline": "key_basic->ip_proto = ip_proto;"
    },
    {
        "line": 308,
        "fullcodeline": "key_control->thoff = (u16)nhoff;"
    },
    {
        "line": 15,
        "fullcodeline": "if (!data) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 293,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 16,
        "fullcodeline": "data = skb->data;"
    },
    {
        "line": 17,
        "fullcodeline": "proto = skb->protocol;"
    },
    {
        "line": 18,
        "fullcodeline": "nhoff = skb_network_offset(skb);"
    },
    {
        "line": 19,
        "fullcodeline": "hlen = skb_headlen(skb);"
    },
    {
        "line": 38,
        "fullcodeline": "struct ethhdr *eth = eth_hdr(skb);"
    },
    {
        "line": 41,
        "fullcodeline": "key_eth_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 44,
        "fullcodeline": "memcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));"
    },
    {
        "line": 49,
        "fullcodeline": "case htons(ETH_P_IP): {"
    },
    {
        "line": 73,
        "fullcodeline": "case htons(ETH_P_IPV6): {"
    },
    {
        "line": 111,
        "fullcodeline": "case htons(ETH_P_8021AD):"
    },
    {
        "line": 112,
        "fullcodeline": "case htons(ETH_P_8021Q): {"
    },
    {
        "line": 133,
        "fullcodeline": "case htons(ETH_P_PPP_SES): {"
    },
    {
        "line": 152,
        "fullcodeline": "case htons(ETH_P_TIPC): {"
    },
    {
        "line": 172,
        "fullcodeline": "case htons(ETH_P_MPLS_UC):"
    },
    {
        "line": 173,
        "fullcodeline": "case htons(ETH_P_MPLS_MC): {"
    },
    {
        "line": 198,
        "fullcodeline": "case htons(ETH_P_FCOE):"
    },
    {
        "line": 199,
        "fullcodeline": "key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);"
    },
    {
        "line": 281,
        "fullcodeline": "proto = htons(ETH_P_IP);"
    },
    {
        "line": 284,
        "fullcodeline": "proto = htons(ETH_P_IPV6);"
    },
    {
        "line": 287,
        "fullcodeline": "proto = htons(ETH_P_MPLS_UC);"
    },
    {
        "line": 295,
        "fullcodeline": "key_ports = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 298,
        "fullcodeline": "key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,"
    },
    {
        "line": 53,
        "fullcodeline": "iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);"
    },
    {
        "line": 56,
        "fullcodeline": "nhoff += iph->ihl * 4;"
    },
    {
        "line": 58,
        "fullcodeline": "ip_proto = iph->protocol;"
    },
    {
        "line": 66,
        "fullcodeline": "key_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 68,
        "fullcodeline": "memcpy(&key_addrs->v4addrs, &iph->saddr,"
    },
    {
        "line": 70,
        "fullcodeline": "key_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;"
    },
    {
        "line": 79,
        "fullcodeline": "iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);"
    },
    {
        "line": 83,
        "fullcodeline": "ip_proto = iph->nexthdr;"
    },
    {
        "line": 84,
        "fullcodeline": "nhoff += sizeof(struct ipv6hdr);"
    },
    {
        "line": 98,
        "fullcodeline": "flow_label = ip6_flowlabel(iph);"
    },
    {
        "line": 116,
        "fullcodeline": "vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);"
    },
    {
        "line": 129,
        "fullcodeline": "proto = vlan->h_vlan_encapsulated_proto;"
    },
    {
        "line": 130,
        "fullcodeline": "nhoff += sizeof(*vlan);"
    },
    {
        "line": 138,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);"
    },
    {
        "line": 141,
        "fullcodeline": "proto = hdr->proto;"
    },
    {
        "line": 142,
        "fullcodeline": "nhoff += PPPOE_SES_HLEN;"
    },
    {
        "line": 157,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);"
    },
    {
        "line": 174,
        "fullcodeline": "struct mpls_label *hdr, _hdr[2];"
    },
    {
        "line": 176,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,"
    },
    {
        "line": 213,
        "fullcodeline": "hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);"
    },
    {
        "line": 223,
        "fullcodeline": "proto = hdr->proto;"
    },
    {
        "line": 224,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 265,
        "fullcodeline": "u8 _opthdr[2], *opthdr;"
    },
    {
        "line": 270,
        "fullcodeline": "opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),"
    },
    {
        "line": 275,
        "fullcodeline": "ip_proto = opthdr[0];"
    },
    {
        "line": 276,
        "fullcodeline": "nhoff += (opthdr[1] + 1) << 3;"
    },
    {
        "line": 54,
        "fullcodeline": "if (!iph || iph->ihl < 5)"
    },
    {
        "line": 59,
        "fullcodeline": "if (ip_is_fragment(iph))"
    },
    {
        "line": 62,
        "fullcodeline": "if (!skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 69,
        "fullcodeline": "sizeof(key_addrs->v4addrs));"
    },
    {
        "line": 80,
        "fullcodeline": "if (!iph)"
    },
    {
        "line": 86,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 117,
        "fullcodeline": "if (!vlan)"
    },
    {
        "line": 120,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 139,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 158,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 161,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 178,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 181,
        "fullcodeline": "if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>"
    },
    {
        "line": 214,
        "fullcodeline": "if (!hdr)"
    },
    {
        "line": 220,
        "fullcodeline": "if (hdr->flags & (GRE_VERSION | GRE_ROUTING))"
    },
    {
        "line": 225,
        "fullcodeline": "if (hdr->flags & GRE_CSUM)"
    },
    {
        "line": 227,
        "fullcodeline": "if (hdr->flags & GRE_KEY) {"
    },
    {
        "line": 246,
        "fullcodeline": "if (hdr->flags & GRE_SEQ)"
    },
    {
        "line": 248,
        "fullcodeline": "if (proto == htons(ETH_P_TEB)) {"
    },
    {
        "line": 267,
        "fullcodeline": "if (proto != htons(ETH_P_IPV6))"
    },
    {
        "line": 272,
        "fullcodeline": "if (!opthdr)"
    },
    {
        "line": 60,
        "fullcodeline": "ip_proto = 0;"
    },
    {
        "line": 90,
        "fullcodeline": "key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 94,
        "fullcodeline": "memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));"
    },
    {
        "line": 95,
        "fullcodeline": "key_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;"
    },
    {
        "line": 122,
        "fullcodeline": "key_tags = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 126,
        "fullcodeline": "key_tags->vlan_id = skb_vlan_tag_get_id(skb);"
    },
    {
        "line": 144,
        "fullcodeline": "case htons(PPP_IP):"
    },
    {
        "line": 146,
        "fullcodeline": "case htons(PPP_IPV6):"
    },
    {
        "line": 163,
        "fullcodeline": "key_addrs = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 166,
        "fullcodeline": "key_addrs->tipcaddrs.srcnode = hdr->srcnode;"
    },
    {
        "line": 167,
        "fullcodeline": "key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;"
    },
    {
        "line": 226,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 231,
        "fullcodeline": "keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),"
    },
    {
        "line": 244,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 247,
        "fullcodeline": "nhoff += 4;"
    },
    {
        "line": 252,
        "fullcodeline": "eth = __skb_header_pointer(skb, nhoff,"
    },
    {
        "line": 257,
        "fullcodeline": "proto = eth->h_proto;"
    },
    {
        "line": 258,
        "fullcodeline": "nhoff += sizeof(*eth);"
    },
    {
        "line": 100,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 183,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 234,
        "fullcodeline": "if (!keyid)"
    },
    {
        "line": 237,
        "fullcodeline": "if (skb_flow_dissector_uses_key(flow_dissector,"
    },
    {
        "line": 255,
        "fullcodeline": "if (!eth)"
    },
    {
        "line": 102,
        "fullcodeline": "key_tags = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 105,
        "fullcodeline": "key_tags->flow_label = ntohl(flow_label);"
    },
    {
        "line": 185,
        "fullcodeline": "key_keyid = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 188,
        "fullcodeline": "key_keyid->keyid = hdr[1].entry &"
    },
    {
        "line": 239,
        "fullcodeline": "key_keyid = skb_flow_dissector_target(flow_dissector,"
    },
    {
        "line": 242,
        "fullcodeline": "key_keyid->keyid = *keyid;"
    },
    {
        "line": 253,
        "fullcodeline": "sizeof(_eth),"
    },
    {
        "line": 189,
        "fullcodeline": "htonl(MPLS_LS_LABEL_MASK);"
    }
]