[
    {
        "line": 10,
        "fullcodeline": "curwin->w_cursor.lnum = eap->line2;"
    },
    {
        "line": 11,
        "fullcodeline": "beginline(BL_SOL | BL_FIX);"
    },
    {
        "line": 32,
        "fullcodeline": "check_cursor();"
    },
    {
        "line": 34,
        "fullcodeline": "eap->cmdidx = CMD_visual;"
    },
    {
        "line": 35,
        "fullcodeline": "do_exedit(eap, NULL);"
    },
    {
        "line": 12,
        "fullcodeline": "if (*eap->arg == '/')"
    },
    {
        "line": 15,
        "fullcodeline": "++eap->arg;"
    },
    {
        "line": 16,
        "fullcodeline": "p = skip_regexp(eap->arg, '/', magic_isset());"
    },
    {
        "line": 17,
        "fullcodeline": "*p = NUL;"
    },
    {
        "line": 18,
        "fullcodeline": "regmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);"
    },
    {
        "line": 30,
        "fullcodeline": "eap->arg += STRLEN(eap->arg);"
    },
    {
        "line": 19,
        "fullcodeline": "if (regmatch.regprog != NULL)"
    },
    {
        "line": 21,
        "fullcodeline": "regmatch.rm_ic = p_ic;"
    },
    {
        "line": 22,
        "fullcodeline": "p = ml_get_curline();"
    },
    {
        "line": 27,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 23,
        "fullcodeline": "if (vim_regexec(&regmatch, p, (colnr_T)0))"
    },
    {
        "line": 24,
        "fullcodeline": "curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);"
    },
    {
        "line": 26,
        "fullcodeline": "emsg(_(e_nomatch));"
    }
]