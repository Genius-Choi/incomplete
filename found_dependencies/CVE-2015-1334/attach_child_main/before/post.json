[
    {
        "line": 3,
        "fullcodeline": "struct attach_clone_payload* payload = (struct attach_clone_payload*)data;"
    },
    {
        "line": 4,
        "fullcodeline": "int ipc_socket = payload->ipc_socket;"
    },
    {
        "line": 5,
        "fullcodeline": "lxc_attach_options_t* options = payload->options;"
    },
    {
        "line": 6,
        "fullcodeline": "struct lxc_proc_context_info* init_ctx = payload->init_ctx;"
    },
    {
        "line": 21,
        "fullcodeline": "expected = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "status = -1;"
    },
    {
        "line": 23,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);"
    },
    {
        "line": 70,
        "fullcodeline": "ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);"
    },
    {
        "line": 78,
        "fullcodeline": "new_uid = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "new_gid = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "status = 1;"
    },
    {
        "line": 122,
        "fullcodeline": "ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));"
    },
    {
        "line": 132,
        "fullcodeline": "expected = 2;"
    },
    {
        "line": 133,
        "fullcodeline": "status = -1;"
    },
    {
        "line": 134,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);"
    },
    {
        "line": 141,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 142,
        "fullcodeline": "close(ipc_socket);"
    },
    {
        "line": 170,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 211,
        "fullcodeline": "rexit(payload->exec_function(payload->exec_payload));"
    },
    {
        "line": 24,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (options->namespaces & CLONE_NEWUSER)"
    },
    {
        "line": 86,
        "fullcodeline": "if (options->uid != (uid_t)-1)"
    },
    {
        "line": 88,
        "fullcodeline": "if (options->gid != (gid_t)-1)"
    },
    {
        "line": 92,
        "fullcodeline": "if (options->stdin_fd && isatty(options->stdin_fd)) {"
    },
    {
        "line": 107,
        "fullcodeline": "if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (ret != sizeof(status)) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 145,
        "fullcodeline": "if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {"
    },
    {
        "line": 164,
        "fullcodeline": "if (init_ctx->container && init_ctx->container->lxc_conf &&"
    },
    {
        "line": 182,
        "fullcodeline": "if (options->stdin_fd >= 0 && options->stdin_fd != 0)"
    },
    {
        "line": 184,
        "fullcodeline": "if (options->stdout_fd >= 0 && options->stdout_fd != 1)"
    },
    {
        "line": 186,
        "fullcodeline": "if (options->stderr_fd >= 0 && options->stderr_fd != 2)"
    },
    {
        "line": 190,
        "fullcodeline": "if (options->stdin_fd > 2)"
    },
    {
        "line": 192,
        "fullcodeline": "if (options->stdout_fd > 2)"
    },
    {
        "line": 194,
        "fullcodeline": "if (options->stderr_fd > 2)"
    },
    {
        "line": 199,
        "fullcodeline": "for (fd = 0; fd <= 2; fd++) {"
    },
    {
        "line": 25,
        "fullcodeline": "ERROR(\"error using IPC to receive notification from initial process (0)\");"
    },
    {
        "line": 26,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 27,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 36,
        "fullcodeline": "ret = lxc_attach_remount_sys_proc();"
    },
    {
        "line": 61,
        "fullcodeline": "ret = lxc_attach_drop_privs(init_ctx);"
    },
    {
        "line": 72,
        "fullcodeline": "ERROR(\"could not set initial environment for attached process\");"
    },
    {
        "line": 73,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 74,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 84,
        "fullcodeline": "lxc_attach_get_init_uidgid(&new_uid, &new_gid);"
    },
    {
        "line": 87,
        "fullcodeline": "new_uid = options->uid;"
    },
    {
        "line": 89,
        "fullcodeline": "new_gid = options->gid;"
    },
    {
        "line": 115,
        "fullcodeline": "SYSERROR(\"switching to container uid\");"
    },
    {
        "line": 116,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 117,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 124,
        "fullcodeline": "ERROR(\"error using IPC to notify initial process for initialization (1)\");"
    },
    {
        "line": 125,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 126,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 136,
        "fullcodeline": "ERROR(\"error using IPC to receive final notification from initial process (2)\");"
    },
    {
        "line": 137,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 138,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 149,
        "fullcodeline": "on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;"
    },
    {
        "line": 150,
        "fullcodeline": "proc_mounted = mount_proc_if_needed(\"/\");"
    },
    {
        "line": 155,
        "fullcodeline": "ret = lsm_process_label_set(init_ctx->lsm_label,"
    },
    {
        "line": 165,
        "fullcodeline": "lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {"
    },
    {
        "line": 166,
        "fullcodeline": "ERROR(\"Loading seccomp policy\");"
    },
    {
        "line": 167,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 183,
        "fullcodeline": "dup2(options->stdin_fd, 0);"
    },
    {
        "line": 185,
        "fullcodeline": "dup2(options->stdout_fd, 1);"
    },
    {
        "line": 187,
        "fullcodeline": "dup2(options->stderr_fd, 2);"
    },
    {
        "line": 191,
        "fullcodeline": "close(options->stdin_fd);"
    },
    {
        "line": 193,
        "fullcodeline": "close(options->stdout_fd);"
    },
    {
        "line": 195,
        "fullcodeline": "close(options->stderr_fd);"
    },
    {
        "line": 200,
        "fullcodeline": "flags = fcntl(fd, F_GETFL);"
    },
    {
        "line": 37,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (setsid() < 0) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (setgid(new_gid) || setgroups(0, NULL)) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (proc_mounted == -1) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (flags < 0)"
    },
    {
        "line": 203,
        "fullcodeline": "if (flags & FD_CLOEXEC) {"
    },
    {
        "line": 38,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 39,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 63,
        "fullcodeline": "ERROR(\"could not drop privileges\");"
    },
    {
        "line": 64,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 65,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 94,
        "fullcodeline": "SYSERROR(\"unable to setsid\");"
    },
    {
        "line": 95,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 96,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 100,
        "fullcodeline": "SYSERROR(\"unable to TIOCSTTY\");"
    },
    {
        "line": 101,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 102,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 109,
        "fullcodeline": "SYSERROR(\"switching to container gid\");"
    },
    {
        "line": 110,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 111,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 152,
        "fullcodeline": "ERROR(\"Error mounting a sane /proc\");"
    },
    {
        "line": 153,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 158,
        "fullcodeline": "umount(\"/proc\");"
    },
    {
        "line": 160,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 204,
        "fullcodeline": "if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) {"
    },
    {
        "line": 205,
        "fullcodeline": "SYSERROR(\"Unable to clear CLOEXEC from fd\");"
    }
]