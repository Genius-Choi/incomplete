[
    {
        "line": 4,
        "fullcodeline": "int len = iov_length(from, count) - offset;"
    },
    {
        "line": 5,
        "fullcodeline": "int copy = skb_headlen(skb);"
    },
    {
        "line": 6,
        "fullcodeline": "int size, offset1 = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "while (count && (offset >= from->iov_len)) {"
    },
    {
        "line": 17,
        "fullcodeline": "while (count && (copy > 0)) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (len == offset1)"
    },
    {
        "line": 35,
        "fullcodeline": "while (count--) {"
    },
    {
        "line": 11,
        "fullcodeline": "offset -= from->iov_len;"
    },
    {
        "line": 12,
        "fullcodeline": "++from;"
    },
    {
        "line": 13,
        "fullcodeline": "--count;"
    },
    {
        "line": 28,
        "fullcodeline": "copy -= size;"
    },
    {
        "line": 29,
        "fullcodeline": "offset1 += size;"
    },
    {
        "line": 36,
        "fullcodeline": "struct page *page[MAX_SKB_FRAGS];"
    },
    {
        "line": 41,
        "fullcodeline": "len = from->iov_len - offset;"
    },
    {
        "line": 47,
        "fullcodeline": "base = (unsigned long)from->iov_base + offset;"
    },
    {
        "line": 48,
        "fullcodeline": "size = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;"
    },
    {
        "line": 49,
        "fullcodeline": "num_pages = get_user_pages_fast(base, size, 0, &page[i]);"
    },
    {
        "line": 56,
        "fullcodeline": "truesize = size * PAGE_SIZE;"
    },
    {
        "line": 57,
        "fullcodeline": "skb->data_len += len;"
    },
    {
        "line": 58,
        "fullcodeline": "skb->len += len;"
    },
    {
        "line": 59,
        "fullcodeline": "skb->truesize += truesize;"
    },
    {
        "line": 60,
        "fullcodeline": "atomic_add(truesize, &skb->sk->sk_wmem_alloc);"
    },
    {
        "line": 71,
        "fullcodeline": "offset = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "++from;"
    },
    {
        "line": 19,
        "fullcodeline": "if (copy_from_user(skb->data + offset1, from->iov_base + offset,"
    },
    {
        "line": 22,
        "fullcodeline": "if (copy > size) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (!len) {"
    },
    {
        "line": 50,
        "fullcodeline": "if ((num_pages != size) ||"
    },
    {
        "line": 23,
        "fullcodeline": "++from;"
    },
    {
        "line": 24,
        "fullcodeline": "--count;"
    },
    {
        "line": 25,
        "fullcodeline": "offset = 0;"
    },
    {
        "line": 43,
        "fullcodeline": "offset = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "++from;"
    },
    {
        "line": 51,
        "fullcodeline": "(num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {"
    },
    {
        "line": 62,
        "fullcodeline": "int off = base & ~PAGE_MASK;"
    },
    {
        "line": 64,
        "fullcodeline": "__skb_fill_page_desc(skb, i, page[i], off, size);"
    },
    {
        "line": 65,
        "fullcodeline": "skb_shinfo(skb)->nr_frags++;"
    },
    {
        "line": 67,
        "fullcodeline": "base += size;"
    },
    {
        "line": 68,
        "fullcodeline": "len -= size;"
    },
    {
        "line": 69,
        "fullcodeline": "i++;"
    },
    {
        "line": 21,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 27,
        "fullcodeline": "offset += size;"
    },
    {
        "line": 52,
        "fullcodeline": "for (i = 0; i < num_pages; i++)"
    },
    {
        "line": 53,
        "fullcodeline": "put_page(page[i]);"
    },
    {
        "line": 54,
        "fullcodeline": "return -EFAULT;"
    }
]