[
    {
        "line": 3,
        "fullcodeline": "struct gs_can *dev = netdev_priv(netdev);"
    },
    {
        "line": 4,
        "fullcodeline": "struct gs_usb *parent = dev->parent;"
    },
    {
        "line": 9,
        "fullcodeline": "rc = open_candev(netdev);"
    },
    {
        "line": 69,
        "fullcodeline": "dm = kmalloc(sizeof(*dm), GFP_KERNEL);"
    },
    {
        "line": 74,
        "fullcodeline": "ctrlmode = dev->can.ctrlmode;"
    },
    {
        "line": 75,
        "fullcodeline": "dm->flags = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "dm->mode = GS_CAN_MODE_START;"
    },
    {
        "line": 93,
        "fullcodeline": "rc = usb_control_msg(interface_to_usbdev(dev->iface),"
    },
    {
        "line": 112,
        "fullcodeline": "dev->can.state = CAN_STATE_ERROR_ACTIVE;"
    },
    {
        "line": 70,
        "fullcodeline": "if (!dm)"
    },
    {
        "line": 77,
        "fullcodeline": "if (ctrlmode & CAN_CTRLMODE_LOOPBACK)"
    },
    {
        "line": 85,
        "fullcodeline": "if (ctrlmode & CAN_CTRLMODE_ONE_SHOT)"
    },
    {
        "line": 88,
        "fullcodeline": "if (ctrlmode & CAN_CTRLMODE_3_SAMPLES)"
    },
    {
        "line": 104,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 13,
        "fullcodeline": "if (atomic_add_return(1, &parent->active_channels) == 1) {"
    },
    {
        "line": 78,
        "fullcodeline": "dm->flags |= GS_CAN_MODE_LOOP_BACK;"
    },
    {
        "line": 86,
        "fullcodeline": "dm->flags |= GS_CAN_MODE_ONE_SHOT;"
    },
    {
        "line": 89,
        "fullcodeline": "dm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;"
    },
    {
        "line": 94,
        "fullcodeline": "usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),"
    },
    {
        "line": 96,
        "fullcodeline": "USB_DIR_OUT | USB_TYPE_VENDOR |"
    },
    {
        "line": 105,
        "fullcodeline": "netdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);"
    },
    {
        "line": 114,
        "fullcodeline": "if (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))"
    },
    {
        "line": 14,
        "fullcodeline": "for (i = 0; i < GS_MAX_RX_URBS; i++) {"
    },
    {
        "line": 71,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 19,
        "fullcodeline": "urb = usb_alloc_urb(0, GFP_KERNEL);"
    },
    {
        "line": 24,
        "fullcodeline": "buf = usb_alloc_coherent(dev->udev,"
    },
    {
        "line": 36,
        "fullcodeline": "usb_fill_bulk_urb(urb,"
    },
    {
        "line": 44,
        "fullcodeline": "urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;"
    },
    {
        "line": 46,
        "fullcodeline": "usb_anchor_urb(urb, &parent->rx_submitted);"
    },
    {
        "line": 48,
        "fullcodeline": "rc = usb_submit_urb(urb, GFP_KERNEL);"
    },
    {
        "line": 79,
        "fullcodeline": "else if (ctrlmode & CAN_CTRLMODE_LISTENONLY)"
    },
    {
        "line": 20,
        "fullcodeline": "if (!urb)"
    },
    {
        "line": 28,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 38,
        "fullcodeline": "usb_rcvbulkpipe(dev->udev,"
    },
    {
        "line": 80,
        "fullcodeline": "dm->flags |= GS_CAN_MODE_LISTEN_ONLY;"
    },
    {
        "line": 53,
        "fullcodeline": "netdev_err(netdev,"
    },
    {
        "line": 57,
        "fullcodeline": "usb_unanchor_urb(urb);"
    },
    {
        "line": 21,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 32,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 50,
        "fullcodeline": "if (rc == -ENODEV)"
    }
]