[
    {
        "line": 3,
        "fullcodeline": "struct usb_device *hdev = hub->hdev;"
    },
    {
        "line": 8,
        "fullcodeline": "bool need_debounce_delay = false;"
    },
    {
        "line": 219,
        "fullcodeline": "hub->quiescing = 0;"
    },
    {
        "line": 221,
        "fullcodeline": "status = usb_submit_urb(hub->urb, GFP_NOIO);"
    },
    {
        "line": 229,
        "fullcodeline": "kick_hub_wq(hub);"
    },
    {
        "line": 12,
        "fullcodeline": "if (type == HUB_INIT2)"
    },
    {
        "line": 14,
        "fullcodeline": "if (type == HUB_INIT3)"
    },
    {
        "line": 27,
        "fullcodeline": "if (type != HUB_RESUME) {"
    },
    {
        "line": 92,
        "fullcodeline": "for (port1 = 1; port1 <= hdev->maxchild; ++port1) {"
    },
    {
        "line": 222,
        "fullcodeline": "if (status < 0)"
    },
    {
        "line": 224,
        "fullcodeline": "if (hub->has_indicators && blinkenlights)"
    },
    {
        "line": 232,
        "fullcodeline": "if (type <= HUB_INIT3)"
    },
    {
        "line": 94,
        "fullcodeline": "struct usb_device *udev = port_dev->child;"
    },
    {
        "line": 97,
        "fullcodeline": "portstatus = portchange = 0;"
    },
    {
        "line": 98,
        "fullcodeline": "status = hub_port_status(hub, port1, &portstatus, &portchange);"
    },
    {
        "line": 205,
        "fullcodeline": "delay = HUB_DEBOUNCE_STABLE;"
    },
    {
        "line": 223,
        "fullcodeline": "dev_err(hub->intfdev, \"activate --> %d\\n\", status);"
    },
    {
        "line": 225,
        "fullcodeline": "queue_delayed_work(system_power_efficient_wq,"
    },
    {
        "line": 233,
        "fullcodeline": "usb_autopm_put_interface_async(to_usb_interface(hub->intfdev));"
    },
    {
        "line": 28,
        "fullcodeline": "if (hdev->parent && hub_is_superspeed(hdev)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (type == HUB_INIT) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (udev || (portstatus & USB_PORT_STAT_CONNECTION))"
    },
    {
        "line": 109,
        "fullcodeline": "if ((portstatus & USB_PORT_STAT_ENABLE) && ("
    },
    {
        "line": 127,
        "fullcodeline": "if (portchange & USB_PORT_STAT_C_CONNECTION) {"
    },
    {
        "line": 132,
        "fullcodeline": "if (portchange & USB_PORT_STAT_C_ENABLE) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (portchange & USB_PORT_STAT_C_RESET) {"
    },
    {
        "line": 142,
        "fullcodeline": "if ((portchange & USB_PORT_STAT_C_BH_RESET) &&"
    },
    {
        "line": 151,
        "fullcodeline": "if (!(portstatus & USB_PORT_STAT_CONNECTION) ||"
    },
    {
        "line": 155,
        "fullcodeline": "if (!udev || udev->state == USB_STATE_NOTATTACHED) {"
    },
    {
        "line": 208,
        "fullcodeline": "if (type == HUB_INIT2) {"
    },
    {
        "line": 29,
        "fullcodeline": "ret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),"
    },
    {
        "line": 51,
        "fullcodeline": "delay = hub_power_on_good_delay(hub);"
    },
    {
        "line": 53,
        "fullcodeline": "hub_power_on(hub, false);"
    },
    {
        "line": 54,
        "fullcodeline": "INIT_DELAYED_WORK(&hub->init_work, hub_init_func2);"
    },
    {
        "line": 55,
        "fullcodeline": "queue_delayed_work(system_power_efficient_wq,"
    },
    {
        "line": 60,
        "fullcodeline": "usb_autopm_get_interface_no_resume("
    },
    {
        "line": 93,
        "fullcodeline": "struct usb_port *port_dev = hub->ports[port1 - 1];"
    },
    {
        "line": 100,
        "fullcodeline": "dev_dbg(&port_dev->dev, \"status %04x change %04x\\n\","
    },
    {
        "line": 110,
        "fullcodeline": "type != HUB_RESUME ||"
    },
    {
        "line": 120,
        "fullcodeline": "portstatus &= ~USB_PORT_STAT_ENABLE;"
    },
    {
        "line": 128,
        "fullcodeline": "need_debounce_delay = true;"
    },
    {
        "line": 129,
        "fullcodeline": "usb_clear_port_feature(hub->hdev, port1,"
    },
    {
        "line": 133,
        "fullcodeline": "need_debounce_delay = true;"
    },
    {
        "line": 134,
        "fullcodeline": "usb_clear_port_feature(hub->hdev, port1,"
    },
    {
        "line": 138,
        "fullcodeline": "need_debounce_delay = true;"
    },
    {
        "line": 139,
        "fullcodeline": "usb_clear_port_feature(hub->hdev, port1,"
    },
    {
        "line": 143,
        "fullcodeline": "hub_is_superspeed(hub->hdev)) {"
    },
    {
        "line": 144,
        "fullcodeline": "need_debounce_delay = true;"
    },
    {
        "line": 145,
        "fullcodeline": "usb_clear_port_feature(hub->hdev, port1,"
    },
    {
        "line": 152,
        "fullcodeline": "(portchange & USB_PORT_STAT_C_CONNECTION))"
    },
    {
        "line": 153,
        "fullcodeline": "clear_bit(port1, hub->removed_bits);"
    },
    {
        "line": 209,
        "fullcodeline": "INIT_DELAYED_WORK(&hub->init_work, hub_init_func3);"
    },
    {
        "line": 210,
        "fullcodeline": "queue_delayed_work(system_power_efficient_wq,"
    },
    {
        "line": 33,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 57,
        "fullcodeline": "msecs_to_jiffies(delay));"
    },
    {
        "line": 61,
        "fullcodeline": "to_usb_interface(hub->intfdev));"
    },
    {
        "line": 113,
        "fullcodeline": "udev->state == USB_STATE_NOTATTACHED)) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (!hub_is_superspeed(hdev))"
    },
    {
        "line": 159,
        "fullcodeline": "if (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||"
    },
    {
        "line": 212,
        "fullcodeline": "msecs_to_jiffies(delay));"
    },
    {
        "line": 215,
        "fullcodeline": "msleep(delay);"
    },
    {
        "line": 31,
        "fullcodeline": "hdev->level - 1, 0, NULL, 0,"
    },
    {
        "line": 34,
        "fullcodeline": "dev_err(hub->intfdev,"
    },
    {
        "line": 63,
        "fullcodeline": "} else if (type == HUB_RESET_RESUME) {"
    },
    {
        "line": 112,
        "fullcodeline": "!udev ||"
    },
    {
        "line": 122,
        "fullcodeline": "usb_clear_port_feature(hdev, port1,"
    },
    {
        "line": 160,
        "fullcodeline": "(portstatus & USB_PORT_STAT_OVERCURRENT))"
    },
    {
        "line": 161,
        "fullcodeline": "set_bit(port1, hub->change_bits);"
    },
    {
        "line": 163,
        "fullcodeline": "} else if (portstatus & USB_PORT_STAT_ENABLE) {"
    },
    {
        "line": 68,
        "fullcodeline": "hcd = bus_to_hcd(hdev->bus);"
    },
    {
        "line": 81,
        "fullcodeline": "hub_power_on(hub, true);"
    },
    {
        "line": 111,
        "fullcodeline": "!(portstatus & USB_PORT_STAT_CONNECTION) ||"
    },
    {
        "line": 164,
        "fullcodeline": "bool port_resumed = (portstatus &"
    },
    {
        "line": 83,
        "fullcodeline": "hub_power_on(hub, true);"
    },
    {
        "line": 175,
        "fullcodeline": "if (portchange || (hub_is_superspeed(hub->hdev) &&"
    },
    {
        "line": 70,
        "fullcodeline": "ret = hcd->driver->update_hub_device(hcd, hdev,"
    },
    {
        "line": 177,
        "fullcodeline": "set_bit(port1, hub->change_bits);"
    },
    {
        "line": 72,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "dev_err(hub->intfdev, \"Host not \""
    },
    {
        "line": 76,
        "fullcodeline": "dev_err(hub->intfdev, \"LS/FS devices \""
    },
    {
        "line": 186,
        "fullcodeline": "if (test_bit(port1, hub->power_bits))"
    },
    {
        "line": 191,
        "fullcodeline": "usb_set_device_state(udev, USB_STATE_NOTATTACHED);"
    },
    {
        "line": 192,
        "fullcodeline": "set_bit(port1, hub->change_bits);"
    },
    {
        "line": 187,
        "fullcodeline": "set_bit(port1, hub->change_bits);"
    }
]