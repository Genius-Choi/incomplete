[
    {
        "line": 4,
        "fullcodeline": "ssize_t written = -1;"
    },
    {
        "line": 14,
        "fullcodeline": "PCCERT_CONTEXT client_certs[1] = { NULL };"
    },
    {
        "line": 15,
        "fullcodeline": "SECURITY_STATUS sspi_status = SEC_E_OK;"
    },
    {
        "line": 16,
        "fullcodeline": "struct Curl_schannel_cred *old_cred = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "char * const hostname = SSL_HOST_NAME();"
    },
    {
        "line": 25,
        "fullcodeline": "DEBUGF(infof(data,"
    },
    {
        "line": 46,
        "fullcodeline": "BACKEND->use_alpn = false;"
    },
    {
        "line": 80,
        "fullcodeline": "BACKEND->cred = NULL;"
    },
    {
        "line": 482,
        "fullcodeline": "InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);"
    },
    {
        "line": 483,
        "fullcodeline": "InitSecBufferDesc(&inbuf_desc, &inbuf, 1);"
    },
    {
        "line": 487,
        "fullcodeline": "InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);"
    },
    {
        "line": 488,
        "fullcodeline": "InitSecBufferDesc(&outbuf_desc, &outbuf, 1);"
    },
    {
        "line": 491,
        "fullcodeline": "BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |"
    },
    {
        "line": 500,
        "fullcodeline": "BACKEND->ctxt = (struct Curl_schannel_ctxt *)"
    },
    {
        "line": 507,
        "fullcodeline": "host_name = curlx_convert_UTF8_to_tchar(hostname);"
    },
    {
        "line": 518,
        "fullcodeline": "sspi_status = s_pSecFn->InitializeSecurityContext("
    },
    {
        "line": 524,
        "fullcodeline": "curlx_unicodefree(host_name);"
    },
    {
        "line": 556,
        "fullcodeline": "DEBUGF(infof(data, \"schannel: sending initial handshake data: \""
    },
    {
        "line": 560,
        "fullcodeline": "result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,"
    },
    {
        "line": 562,
        "fullcodeline": "s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);"
    },
    {
        "line": 569,
        "fullcodeline": "DEBUGF(infof(data, \"schannel: sent initial handshake data: \""
    },
    {
        "line": 572,
        "fullcodeline": "BACKEND->recv_unrecoverable_err = CURLE_OK;"
    },
    {
        "line": 573,
        "fullcodeline": "BACKEND->recv_sspi_close_notify = false;"
    },
    {
        "line": 574,
        "fullcodeline": "BACKEND->recv_connection_closed = false;"
    },
    {
        "line": 575,
        "fullcodeline": "BACKEND->encdata_is_incomplete = false;"
    },
    {
        "line": 578,
        "fullcodeline": "connssl->connecting_state = ssl_connect_2;"
    },
    {
        "line": 29,
        "fullcodeline": "if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,"
    },
    {
        "line": 73,
        "fullcodeline": "if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {"
    },
    {
        "line": 100,
        "fullcodeline": "if(!BACKEND->cred) {"
    },
    {
        "line": 425,
        "fullcodeline": "if(Curl_inet_pton(AF_INET, hostname, &addr)"
    },
    {
        "line": 495,
        "fullcodeline": "if(!SSL_SET_OPTION(auto_client_cert)) {"
    },
    {
        "line": 502,
        "fullcodeline": "if(!BACKEND->ctxt) {"
    },
    {
        "line": 508,
        "fullcodeline": "if(!host_name)"
    },
    {
        "line": 526,
        "fullcodeline": "if(sspi_status != SEC_I_CONTINUE_NEEDED) {"
    },
    {
        "line": 563,
        "fullcodeline": "if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {"
    },
    {
        "line": 33,
        "fullcodeline": "infof(data, \"schannel: Windows version is old and may not be able to \""
    },
    {
        "line": 74,
        "fullcodeline": "failf(data, \"schannel: CA cert support not built in\");"
    },
    {
        "line": 84,
        "fullcodeline": "Curl_ssl_sessionid_lock(data);"
    },
    {
        "line": 97,
        "fullcodeline": "Curl_ssl_sessionid_unlock(data);"
    },
    {
        "line": 102,
        "fullcodeline": "memset(&schannel_cred, 0, sizeof(schannel_cred));"
    },
    {
        "line": 103,
        "fullcodeline": "schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;"
    },
    {
        "line": 381,
        "fullcodeline": "BACKEND->cred = (struct Curl_schannel_cred *)"
    },
    {
        "line": 391,
        "fullcodeline": "BACKEND->cred->refcount = 1;"
    },
    {
        "line": 395,
        "fullcodeline": "sspi_status ="
    },
    {
        "line": 430,
        "fullcodeline": "infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");"
    },
    {
        "line": 496,
        "fullcodeline": "BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;"
    },
    {
        "line": 501,
        "fullcodeline": "calloc(1, sizeof(struct Curl_schannel_ctxt));"
    },
    {
        "line": 503,
        "fullcodeline": "failf(data, \"schannel: unable to allocate memory\");"
    },
    {
        "line": 520,
        "fullcodeline": "(BACKEND->use_alpn ? &inbuf_desc : NULL),"
    },
    {
        "line": 527,
        "fullcodeline": "char buffer[STRERROR_LEN];"
    },
    {
        "line": 528,
        "fullcodeline": "Curl_safefree(BACKEND->ctxt);"
    },
    {
        "line": 564,
        "fullcodeline": "failf(data, \"schannel: failed to send initial handshake data: \""
    },
    {
        "line": 85,
        "fullcodeline": "if(!Curl_ssl_getsessionid(data, conn,"
    },
    {
        "line": 148,
        "fullcodeline": "if(!SSL_SET_OPTION(auto_client_cert)) {"
    },
    {
        "line": 178,
        "fullcodeline": "if(SSL_CONN_CONFIG(cipher_list)) {"
    },
    {
        "line": 383,
        "fullcodeline": "if(!BACKEND->cred) {"
    },
    {
        "line": 396,
        "fullcodeline": "s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,"
    },
    {
        "line": 405,
        "fullcodeline": "if(sspi_status != SEC_E_OK) {"
    },
    {
        "line": 88,
        "fullcodeline": "BACKEND->cred = old_cred;"
    },
    {
        "line": 89,
        "fullcodeline": "DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));"
    },
    {
        "line": 93,
        "fullcodeline": "DEBUGF(infof(data,"
    },
    {
        "line": 111,
        "fullcodeline": "schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;"
    },
    {
        "line": 142,
        "fullcodeline": "schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;"
    },
    {
        "line": 143,
        "fullcodeline": "DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \""
    },
    {
        "line": 149,
        "fullcodeline": "schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;"
    },
    {
        "line": 150,
        "fullcodeline": "schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;"
    },
    {
        "line": 151,
        "fullcodeline": "infof(data, \"schannel: disabled automatic use of client certificate\\n\");"
    },
    {
        "line": 171,
        "fullcodeline": "failf(data, \"SSL versions not supported\");"
    },
    {
        "line": 174,
        "fullcodeline": "failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");"
    },
    {
        "line": 179,
        "fullcodeline": "result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),"
    },
    {
        "line": 375,
        "fullcodeline": "failf(data, \"schannel: client cert support not built in\");"
    },
    {
        "line": 382,
        "fullcodeline": "calloc(1, sizeof(struct Curl_schannel_cred));"
    },
    {
        "line": 384,
        "fullcodeline": "failf(data, \"schannel: unable to allocate memory\");"
    },
    {
        "line": 403,
        "fullcodeline": "CertFreeCertificateContext(client_certs[0]);"
    },
    {
        "line": 406,
        "fullcodeline": "char buffer[STRERROR_LEN];"
    },
    {
        "line": 407,
        "fullcodeline": "failf(data, \"schannel: AcquireCredentialsHandle failed: %s\","
    },
    {
        "line": 409,
        "fullcodeline": "Curl_safefree(BACKEND->cred);"
    },
    {
        "line": 531,
        "fullcodeline": "failf(data, \"schannel: initial InitializeSecurityContext failed: %s\","
    },
    {
        "line": 535,
        "fullcodeline": "failf(data, \"schannel: SNI or certificate check failed: %s\","
    },
    {
        "line": 550,
        "fullcodeline": "failf(data, \"schannel: initial InitializeSecurityContext failed: %s\","
    },
    {
        "line": 86,
        "fullcodeline": "SSL_IS_PROXY() ? TRUE : FALSE,"
    },
    {
        "line": 87,
        "fullcodeline": "(void **)&old_cred, NULL, sockindex)) {"
    },
    {
        "line": 113,
        "fullcodeline": "if(SSL_SET_OPTION(no_revoke)) {"
    },
    {
        "line": 134,
        "fullcodeline": "schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |"
    },
    {
        "line": 137,
        "fullcodeline": "DEBUGF(infof(data,"
    },
    {
        "line": 154,
        "fullcodeline": "infof(data, \"schannel: enabled automatic use of client certificate\\n\");"
    },
    {
        "line": 164,
        "fullcodeline": "result = set_ssl_version_min_max(&schannel_cred, data, conn);"
    },
    {
        "line": 181,
        "fullcodeline": "if(CURLE_OK != result) {"
    },
    {
        "line": 408,
        "fullcodeline": "Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));"
    },
    {
        "line": 532,
        "fullcodeline": "Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));"
    },
    {
        "line": 536,
        "fullcodeline": "Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));"
    },
    {
        "line": 551,
        "fullcodeline": "Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));"
    },
    {
        "line": 114,
        "fullcodeline": "schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |"
    },
    {
        "line": 117,
        "fullcodeline": "DEBUGF(infof(data, \"schannel: disabled server certificate revocation \""
    },
    {
        "line": 165,
        "fullcodeline": "if(result != CURLE_OK)"
    },
    {
        "line": 182,
        "fullcodeline": "failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");"
    },
    {
        "line": 387,
        "fullcodeline": "CertFreeCertificateContext(client_certs[0]);"
    },
    {
        "line": 120,
        "fullcodeline": "else if(SSL_SET_OPTION(revoke_best_effort)) {"
    },
    {
        "line": 121,
        "fullcodeline": "schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |"
    },
    {
        "line": 124,
        "fullcodeline": "DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));"
    },
    {
        "line": 127,
        "fullcodeline": "schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;"
    },
    {
        "line": 129,
        "fullcodeline": "DEBUGF(infof(data,"
    }
]