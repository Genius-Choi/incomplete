[
    {
        "line": 5,
        "fullcodeline": "const int64 batch_size = bcast.output_batch_size();"
    },
    {
        "line": 6,
        "fullcodeline": "const int64 cost_per_unit ="
    },
    {
        "line": 8,
        "fullcodeline": "auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());"
    },
    {
        "line": 16,
        "fullcodeline": "auto matrix = ConstMatrixMap(in_x.flat<Scalar>().data(), in_x.dim_size(1),"
    },
    {
        "line": 24,
        "fullcodeline": "OP_REQUIRES(context, min_abs_pivot > RealScalar(0),"
    },
    {
        "line": 27,
        "fullcodeline": "Shard(worker_threads.num_threads, worker_threads.workers, batch_size,"
    },
    {
        "line": 7,
        "fullcodeline": "in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);"
    },
    {
        "line": 25,
        "fullcodeline": "errors::InvalidArgument(\"Input matrix is not invertible.\"));"
    },
    {
        "line": 17,
        "fullcodeline": "in_x.dim_size(2));"
    },
    {
        "line": 20,
        "fullcodeline": "min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();"
    },
    {
        "line": 22,
        "fullcodeline": "min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();"
    }
]