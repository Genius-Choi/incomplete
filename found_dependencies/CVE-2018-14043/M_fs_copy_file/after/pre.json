[
    {
        "line": 5,
        "fullcodeline": "M_fs_info_t   *info         = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "unsigned char  temp[M_FS_BUF_SIZE];"
    },
    {
        "line": 9,
        "fullcodeline": "size_t         wrote_total  = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);"
    },
    {
        "line": 30,
        "fullcodeline": "res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);"
    },
    {
        "line": 15,
        "fullcodeline": "if (res != M_FS_ERROR_SUCCESS) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (res != M_FS_ERROR_SUCCESS) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (res != M_FS_ERROR_SUCCESS) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {"
    },
    {
        "line": 20,
        "fullcodeline": "res = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);"
    },
    {
        "line": 25,
        "fullcodeline": "perms = M_fs_info_get_perms(info);"
    },
    {
        "line": 38,
        "fullcodeline": "while ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "offset = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "if (res != M_FS_ERROR_SUCCESS) {"
    },
    {
        "line": 40,
        "fullcodeline": "while (offset < read_len) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (res != M_FS_ERROR_SUCCESS) {"
    },
    {
        "line": 41,
        "fullcodeline": "res          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);"
    },
    {
        "line": 42,
        "fullcodeline": "offset      += wrote_len;"
    },
    {
        "line": 43,
        "fullcodeline": "wrote_total += wrote_len;"
    },
    {
        "line": 61,
        "fullcodeline": "if (res != M_FS_ERROR_SUCCESS) {"
    },
    {
        "line": 46,
        "fullcodeline": "M_fs_progress_set_result(progress, res);"
    },
    {
        "line": 47,
        "fullcodeline": "if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (progress_flags & M_FS_PROGRESS_COUNT) {"
    },
    {
        "line": 48,
        "fullcodeline": "M_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);"
    },
    {
        "line": 51,
        "fullcodeline": "M_fs_progress_set_size_current_progress(progress, wrote_total);"
    },
    {
        "line": 54,
        "fullcodeline": "M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);"
    },
    {
        "line": 56,
        "fullcodeline": "if (!cb(progress)) {"
    },
    {
        "line": 57,
        "fullcodeline": "res = M_FS_ERROR_CANCELED;"
    }
]