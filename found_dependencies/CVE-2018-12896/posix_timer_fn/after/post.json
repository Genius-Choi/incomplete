[
    {
        "line": 5,
        "fullcodeline": "int si_private = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "enum hrtimer_restart ret = HRTIMER_NORESTART;"
    },
    {
        "line": 9,
        "fullcodeline": "spin_lock_irqsave(&timr->it_lock, flags);"
    },
    {
        "line": 11,
        "fullcodeline": "timr->it_active = 0;"
    },
    {
        "line": 62,
        "fullcodeline": "unlock_timer(timr, flags);"
    },
    {
        "line": 12,
        "fullcodeline": "if (timr->it_interval != 0)"
    },
    {
        "line": 15,
        "fullcodeline": "if (posix_timer_event(timr, si_private)) {"
    },
    {
        "line": 13,
        "fullcodeline": "si_private = ++timr->it_requeue_pending;"
    },
    {
        "line": 21,
        "fullcodeline": "if (timr->it_interval != 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "ktime_t now = hrtimer_cb_get_time(timer);"
    },
    {
        "line": 54,
        "fullcodeline": "timr->it_overrun += hrtimer_forward(timer, now,"
    },
    {
        "line": 56,
        "fullcodeline": "ret = HRTIMER_RESTART;"
    },
    {
        "line": 57,
        "fullcodeline": "++timr->it_requeue_pending;"
    },
    {
        "line": 58,
        "fullcodeline": "timr->it_active = 1;"
    }
]