[
    {
        "line": 5,
        "fullcodeline": "struct gnttab_copy *gop = *gopp;"
    },
    {
        "line": 6,
        "fullcodeline": "u16 pending_idx = *((u16 *)skb->data);"
    },
    {
        "line": 7,
        "fullcodeline": "struct pending_tx_info *pending_tx_info = netbk->pending_tx_info;"
    },
    {
        "line": 8,
        "fullcodeline": "struct xenvif *vif = pending_tx_info[pending_idx].vif;"
    },
    {
        "line": 10,
        "fullcodeline": "struct skb_shared_info *shinfo = skb_shinfo(skb);"
    },
    {
        "line": 11,
        "fullcodeline": "int nr_frags = shinfo->nr_frags;"
    },
    {
        "line": 15,
        "fullcodeline": "err = gop->status;"
    },
    {
        "line": 26,
        "fullcodeline": "start = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);"
    },
    {
        "line": 66,
        "fullcodeline": "*gopp = gop + 1;"
    },
    {
        "line": 16,
        "fullcodeline": "if (unlikely(err)) {"
    },
    {
        "line": 28,
        "fullcodeline": "for (i = start; i < nr_frags; i++) {"
    },
    {
        "line": 18,
        "fullcodeline": "index = pending_index(netbk->pending_prod++);"
    },
    {
        "line": 19,
        "fullcodeline": "txp = &pending_tx_info[pending_idx].req;"
    },
    {
        "line": 20,
        "fullcodeline": "make_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);"
    },
    {
        "line": 21,
        "fullcodeline": "netbk->pending_ring[index] = pending_idx;"
    },
    {
        "line": 22,
        "fullcodeline": "xenvif_put(vif);"
    },
    {
        "line": 32,
        "fullcodeline": "pending_idx = frag_get_pending_idx(&shinfo->frags[i]);"
    },
    {
        "line": 35,
        "fullcodeline": "newerr = (++gop)->status;"
    },
    {
        "line": 44,
        "fullcodeline": "txp = &netbk->pending_tx_info[pending_idx].req;"
    },
    {
        "line": 45,
        "fullcodeline": "make_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);"
    },
    {
        "line": 46,
        "fullcodeline": "index = pending_index(netbk->pending_prod++);"
    },
    {
        "line": 47,
        "fullcodeline": "netbk->pending_ring[index] = pending_idx;"
    },
    {
        "line": 48,
        "fullcodeline": "xenvif_put(vif);"
    },
    {
        "line": 55,
        "fullcodeline": "pending_idx = *((u16 *)skb->data);"
    },
    {
        "line": 56,
        "fullcodeline": "xen_netbk_idx_release(netbk, pending_idx);"
    },
    {
        "line": 63,
        "fullcodeline": "err = newerr;"
    },
    {
        "line": 36,
        "fullcodeline": "if (likely(!newerr)) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (j = start; j < i; j++) {"
    },
    {
        "line": 58,
        "fullcodeline": "pending_idx = frag_get_pending_idx(&shinfo->frags[j]);"
    },
    {
        "line": 59,
        "fullcodeline": "xen_netbk_idx_release(netbk, pending_idx);"
    },
    {
        "line": 38,
        "fullcodeline": "if (unlikely(err))"
    },
    {
        "line": 39,
        "fullcodeline": "xen_netbk_idx_release(netbk, pending_idx);"
    }
]