[
    {
        "line": 4,
        "fullcodeline": "struct net_device *dev = skb->dev;"
    },
    {
        "line": 10,
        "fullcodeline": "struct sk_buff *ret_skb = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "clone = skb_clone(skb, GFP_ATOMIC);"
    },
    {
        "line": 27,
        "fullcodeline": "NFCT_FRAG6_CB(clone)->orig = skb;"
    },
    {
        "line": 34,
        "fullcodeline": "skb_set_transport_header(clone, fhoff);"
    },
    {
        "line": 35,
        "fullcodeline": "hdr = ipv6_hdr(clone);"
    },
    {
        "line": 36,
        "fullcodeline": "fhdr = (struct frag_hdr *)skb_transport_header(clone);"
    },
    {
        "line": 47,
        "fullcodeline": "fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);"
    },
    {
        "line": 68,
        "fullcodeline": "spin_unlock_bh(&fq->q.lock);"
    },
    {
        "line": 70,
        "fullcodeline": "fq_put(fq);"
    },
    {
        "line": 74,
        "fullcodeline": "kfree_skb(clone);"
    },
    {
        "line": 13,
        "fullcodeline": "if (ipv6_hdr(skb)->payload_len == 0) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)"
    },
    {
        "line": 22,
        "fullcodeline": "if (clone == NULL) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (!(fhdr->frag_off & htons(0xFFF9))) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)"
    },
    {
        "line": 48,
        "fullcodeline": "if (fq == NULL) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&"
    },
    {
        "line": 14,
        "fullcodeline": "pr_debug(\"payload len = 0\\n\");"
    },
    {
        "line": 23,
        "fullcodeline": "pr_debug(\"Can't clone skb\\n\");"
    },
    {
        "line": 30,
        "fullcodeline": "pr_debug(\"message is too short.\\n\");"
    },
    {
        "line": 39,
        "fullcodeline": "pr_debug(\"Invalid fragment offset\\n\");"
    },
    {
        "line": 45,
        "fullcodeline": "nf_ct_frag6_evictor();"
    },
    {
        "line": 49,
        "fullcodeline": "pr_debug(\"Can't find and can't create new queue\\n\");"
    },
    {
        "line": 56,
        "fullcodeline": "spin_unlock_bh(&fq->q.lock);"
    },
    {
        "line": 57,
        "fullcodeline": "pr_debug(\"Can't insert skb to queue\\n\");"
    },
    {
        "line": 58,
        "fullcodeline": "fq_put(fq);"
    },
    {
        "line": 64,
        "fullcodeline": "ret_skb = nf_ct_frag6_reasm(fq, dev);"
    },
    {
        "line": 65,
        "fullcodeline": "if (ret_skb == NULL)"
    },
    {
        "line": 66,
        "fullcodeline": "pr_debug(\"Can't reassemble fragmented packets\\n\");"
    }
]