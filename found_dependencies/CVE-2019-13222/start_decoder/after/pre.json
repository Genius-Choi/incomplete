[
    {
        "line": 3,
        "fullcodeline": "uint8 header[6], x,y;"
    },
    {
        "line": 4,
        "fullcodeline": "int len,i,j,k, max_submaps = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "int longest_floorlist=0;"
    },
    {
        "line": 39,
        "fullcodeline": "f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 41,
        "fullcodeline": "f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 42,
        "fullcodeline": "get32(f); // bitrate_maximum"
    },
    {
        "line": 43,
        "fullcodeline": "get32(f); // bitrate_nominal"
    },
    {
        "line": 44,
        "fullcodeline": "get32(f); // bitrate_minimum"
    },
    {
        "line": 45,
        "fullcodeline": "x = get8(f);"
    },
    {
        "line": 58,
        "fullcodeline": "x = get8(f);"
    },
    {
        "line": 93,
        "fullcodeline": "f->codebook_count = get_bits(f,8) + 1;"
    },
    {
        "line": 94,
        "fullcodeline": "f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);"
    },
    {
        "line": 96,
        "fullcodeline": "memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);"
    },
    {
        "line": 308,
        "fullcodeline": "x = get_bits(f, 6) + 1;"
    },
    {
        "line": 315,
        "fullcodeline": "f->floor_count = get_bits(f, 6)+1;"
    },
    {
        "line": 316,
        "fullcodeline": "f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));"
    },
    {
        "line": 391,
        "fullcodeline": "f->residue_count = get_bits(f, 6)+1;"
    },
    {
        "line": 392,
        "fullcodeline": "f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));"
    },
    {
        "line": 394,
        "fullcodeline": "memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));"
    },
    {
        "line": 443,
        "fullcodeline": "f->mapping_count = get_bits(f,6)+1;"
    },
    {
        "line": 444,
        "fullcodeline": "f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));"
    },
    {
        "line": 446,
        "fullcodeline": "memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));"
    },
    {
        "line": 494,
        "fullcodeline": "f->mode_count = get_bits(f, 6)+1;"
    },
    {
        "line": 506,
        "fullcodeline": "flush_packet(f);"
    },
    {
        "line": 508,
        "fullcodeline": "f->previous_length = 0;"
    },
    {
        "line": 564,
        "fullcodeline": "f->first_decode = TRUE;"
    },
    {
        "line": 9,
        "fullcodeline": "if (!start_page(f))                              return FALSE;"
    },
    {
        "line": 12,
        "fullcodeline": "if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 13,
        "fullcodeline": "if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 15,
        "fullcodeline": "if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 16,
        "fullcodeline": "if (f->segments[0] != 30) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 40,
        "fullcodeline": "if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);"
    },
    {
        "line": 48,
        "fullcodeline": "log0 = x & 15;"
    },
    {
        "line": 49,
        "fullcodeline": "log1 = x >> 4;"
    },
    {
        "line": 50,
        "fullcodeline": "f->blocksize_0 = 1 << log0;"
    },
    {
        "line": 51,
        "fullcodeline": "f->blocksize_1 = 1 << log1;"
    },
    {
        "line": 75,
        "fullcodeline": "if (IS_PUSH_MODE(f)) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 88,
        "fullcodeline": "for (i=0; i < 6; ++i) header[i] = get8_packet(f);"
    },
    {
        "line": 95,
        "fullcodeline": "if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);"
    },
    {
        "line": 97,
        "fullcodeline": "for (i=0; i < f->codebook_count; ++i) {"
    },
    {
        "line": 309,
        "fullcodeline": "for (i=0; i < x; ++i) {"
    },
    {
        "line": 317,
        "fullcodeline": "if (f->floor_config == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 318,
        "fullcodeline": "for (i=0; i < f->floor_count; ++i) {"
    },
    {
        "line": 393,
        "fullcodeline": "if (f->residue_config == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 395,
        "fullcodeline": "for (i=0; i < f->residue_count; ++i) {"
    },
    {
        "line": 445,
        "fullcodeline": "if (f->mapping == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 447,
        "fullcodeline": "for (i=0; i < f->mapping_count; ++i) {"
    },
    {
        "line": 495,
        "fullcodeline": "for (i=0; i < f->mode_count; ++i) {"
    },
    {
        "line": 510,
        "fullcodeline": "for (i=0; i < f->channels; ++i) {"
    },
    {
        "line": 538,
        "fullcodeline": "uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);"
    },
    {
        "line": 540,
        "fullcodeline": "int i,max_part_read=0;"
    },
    {
        "line": 552,
        "fullcodeline": "classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));"
    },
    {
        "line": 559,
        "fullcodeline": "f->temp_memory_required = classify_mem;"
    },
    {
        "line": 573,
        "fullcodeline": "f->first_audio_page_offset = stb_vorbis_get_file_offset(f);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 35,
        "fullcodeline": "if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);"
    },
    {
        "line": 36,
        "fullcodeline": "if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 38,
        "fullcodeline": "if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 59,
        "fullcodeline": "if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 62,
        "fullcodeline": "if (!start_page(f))                              return FALSE;"
    },
    {
        "line": 64,
        "fullcodeline": "if (!start_packet(f))                            return FALSE;"
    },
    {
        "line": 66,
        "fullcodeline": "len = next_segment(f);"
    },
    {
        "line": 67,
        "fullcodeline": "skip(f, len);"
    },
    {
        "line": 68,
        "fullcodeline": "f->bytes_in_seg = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "if (!start_packet(f))                            return FALSE;"
    },
    {
        "line": 89,
        "fullcodeline": "if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 100,
        "fullcodeline": "int total=0;"
    },
    {
        "line": 102,
        "fullcodeline": "Codebook *c = f->codebooks+i;"
    },
    {
        "line": 103,
        "fullcodeline": "CHECK(f);"
    },
    {
        "line": 104,
        "fullcodeline": "x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 105,
        "fullcodeline": "x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 106,
        "fullcodeline": "x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 107,
        "fullcodeline": "x = get_bits(f, 8);"
    },
    {
        "line": 108,
        "fullcodeline": "c->dimensions = (get_bits(f, 8)<<8) + x;"
    },
    {
        "line": 109,
        "fullcodeline": "x = get_bits(f, 8);"
    },
    {
        "line": 110,
        "fullcodeline": "y = get_bits(f, 8);"
    },
    {
        "line": 111,
        "fullcodeline": "c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;"
    },
    {
        "line": 113,
        "fullcodeline": "c->sparse = ordered ? 0 : get_bits(f,1);"
    },
    {
        "line": 175,
        "fullcodeline": "c->sorted_entries = sorted_count;"
    },
    {
        "line": 176,
        "fullcodeline": "values = NULL;"
    },
    {
        "line": 178,
        "fullcodeline": "CHECK(f);"
    },
    {
        "line": 222,
        "fullcodeline": "compute_accelerated_huffman(c);"
    },
    {
        "line": 224,
        "fullcodeline": "CHECK(f);"
    },
    {
        "line": 225,
        "fullcodeline": "c->lookup_type = get_bits(f, 4);"
    },
    {
        "line": 303,
        "fullcodeline": "CHECK(f);"
    },
    {
        "line": 310,
        "fullcodeline": "uint32 z = get_bits(f, 16);"
    },
    {
        "line": 319,
        "fullcodeline": "f->floor_types[i] = get_bits(f, 16);"
    },
    {
        "line": 396,
        "fullcodeline": "uint8 residue_cascade[64];"
    },
    {
        "line": 397,
        "fullcodeline": "Residue *r = f->residue_config+i;"
    },
    {
        "line": 398,
        "fullcodeline": "f->residue_types[i] = get_bits(f, 16);"
    },
    {
        "line": 400,
        "fullcodeline": "r->begin = get_bits(f, 24);"
    },
    {
        "line": 401,
        "fullcodeline": "r->end = get_bits(f, 24);"
    },
    {
        "line": 403,
        "fullcodeline": "r->part_size = get_bits(f,24)+1;"
    },
    {
        "line": 404,
        "fullcodeline": "r->classifications = get_bits(f,6)+1;"
    },
    {
        "line": 405,
        "fullcodeline": "r->classbook = get_bits(f,8);"
    },
    {
        "line": 414,
        "fullcodeline": "r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);"
    },
    {
        "line": 428,
        "fullcodeline": "r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);"
    },
    {
        "line": 448,
        "fullcodeline": "Mapping *m = f->mapping + i;"
    },
    {
        "line": 449,
        "fullcodeline": "int mapping_type = get_bits(f,16);"
    },
    {
        "line": 451,
        "fullcodeline": "m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));"
    },
    {
        "line": 496,
        "fullcodeline": "Mode *m = f->mode_config+i;"
    },
    {
        "line": 498,
        "fullcodeline": "m->windowtype = get_bits(f,16);"
    },
    {
        "line": 499,
        "fullcodeline": "m->transformtype = get_bits(f,16);"
    },
    {
        "line": 500,
        "fullcodeline": "m->mapping = get_bits(f,8);"
    },
    {
        "line": 511,
        "fullcodeline": "f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);"
    },
    {
        "line": 512,
        "fullcodeline": "f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);"
    },
    {
        "line": 513,
        "fullcodeline": "f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);"
    },
    {
        "line": 522,
        "fullcodeline": "if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;"
    },
    {
        "line": 523,
        "fullcodeline": "if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;"
    },
    {
        "line": 541,
        "fullcodeline": "for (i=0; i < f->residue_count; ++i) {"
    },
    {
        "line": 560,
        "fullcodeline": "if (imdct_mem > f->temp_memory_required)"
    },
    {
        "line": 52,
        "fullcodeline": "if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 53,
        "fullcodeline": "if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 112,
        "fullcodeline": "ordered = get_bits(f,1);"
    },
    {
        "line": 122,
        "fullcodeline": "if (!lengths) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 150,
        "fullcodeline": "if (c->sparse && total >= c->entries >> 2) {"
    },
    {
        "line": 179,
        "fullcodeline": "if (!c->sparse) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 227,
        "fullcodeline": "if (c->lookup_type > 0) {"
    },
    {
        "line": 320,
        "fullcodeline": "if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 402,
        "fullcodeline": "if (r->end < r->begin) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 406,
        "fullcodeline": "if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 407,
        "fullcodeline": "for (j=0; j < r->classifications; ++j) {"
    },
    {
        "line": 415,
        "fullcodeline": "if (r->residue_books == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 416,
        "fullcodeline": "for (j=0; j < r->classifications; ++j) {"
    },
    {
        "line": 429,
        "fullcodeline": "if (!r->classdata) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 430,
        "fullcodeline": "memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);"
    },
    {
        "line": 431,
        "fullcodeline": "for (j=0; j < f->codebooks[r->classbook].entries; ++j) {"
    },
    {
        "line": 452,
        "fullcodeline": "if (m->chan == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 453,
        "fullcodeline": "if (get_bits(f,1))"
    },
    {
        "line": 457,
        "fullcodeline": "if (m->submaps > max_submaps)"
    },
    {
        "line": 459,
        "fullcodeline": "if (get_bits(f,1)) {"
    },
    {
        "line": 473,
        "fullcodeline": "if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 474,
        "fullcodeline": "if (m->submaps > 1) {"
    },
    {
        "line": 484,
        "fullcodeline": "for (j=0; j < m->submaps; ++j) {"
    },
    {
        "line": 497,
        "fullcodeline": "m->blockflag = get_bits(f,1);"
    },
    {
        "line": 503,
        "fullcodeline": "if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 515,
        "fullcodeline": "memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);"
    },
    {
        "line": 542,
        "fullcodeline": "Residue *r = f->residue_config + i;"
    },
    {
        "line": 543,
        "fullcodeline": "unsigned int actual_size = f->blocksize_1 / 2;"
    },
    {
        "line": 544,
        "fullcodeline": "unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;"
    },
    {
        "line": 545,
        "fullcodeline": "unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;"
    },
    {
        "line": 546,
        "fullcodeline": "int n_read = limit_r_end - limit_r_begin;"
    },
    {
        "line": 547,
        "fullcodeline": "int part_read = n_read / r->part_size;"
    },
    {
        "line": 561,
        "fullcodeline": "f->temp_memory_required = imdct_mem;"
    },
    {
        "line": 567,
        "fullcodeline": "assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);"
    },
    {
        "line": 18,
        "fullcodeline": "if (f->segments[0] == 64 &&"
    },
    {
        "line": 27,
        "fullcodeline": "get8(f)   == '\\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);"
    },
    {
        "line": 54,
        "fullcodeline": "if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 76,
        "fullcodeline": "if (!is_whole_packet_present(f, TRUE)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 118,
        "fullcodeline": "lengths = (uint8 *) setup_temp_malloc(f, c->entries);"
    },
    {
        "line": 125,
        "fullcodeline": "int current_entry = 0;"
    },
    {
        "line": 126,
        "fullcodeline": "int current_length = get_bits(f,5) + 1;"
    },
    {
        "line": 155,
        "fullcodeline": "c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);"
    },
    {
        "line": 157,
        "fullcodeline": "memcpy(c->codeword_lengths, lengths, c->entries);"
    },
    {
        "line": 158,
        "fullcodeline": "setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!"
    },
    {
        "line": 159,
        "fullcodeline": "lengths = c->codeword_lengths;"
    },
    {
        "line": 160,
        "fullcodeline": "c->sparse = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "sorted_count = total;"
    },
    {
        "line": 180,
        "fullcodeline": "c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);"
    },
    {
        "line": 197,
        "fullcodeline": "if (!compute_codewords(c, lengths, c->entries, values)) {"
    },
    {
        "line": 204,
        "fullcodeline": "c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));"
    },
    {
        "line": 208,
        "fullcodeline": "c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));"
    },
    {
        "line": 210,
        "fullcodeline": "++c->sorted_values;"
    },
    {
        "line": 211,
        "fullcodeline": "c->sorted_values[-1] = -1;"
    },
    {
        "line": 212,
        "fullcodeline": "compute_sorted_huffman(c, lengths, values);"
    },
    {
        "line": 216,
        "fullcodeline": "setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);"
    },
    {
        "line": 217,
        "fullcodeline": "setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);"
    },
    {
        "line": 218,
        "fullcodeline": "setup_temp_free(f, lengths, c->entries);"
    },
    {
        "line": 219,
        "fullcodeline": "c->codewords = NULL;"
    },
    {
        "line": 229,
        "fullcodeline": "c->minimum_value = float32_unpack(get_bits(f, 32));"
    },
    {
        "line": 230,
        "fullcodeline": "c->delta_value = float32_unpack(get_bits(f, 32));"
    },
    {
        "line": 231,
        "fullcodeline": "c->value_bits = get_bits(f, 4)+1;"
    },
    {
        "line": 232,
        "fullcodeline": "c->sequence_p = get_bits(f,1);"
    },
    {
        "line": 241,
        "fullcodeline": "mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);"
    },
    {
        "line": 299,
        "fullcodeline": "setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);"
    },
    {
        "line": 301,
        "fullcodeline": "CHECK(f);"
    },
    {
        "line": 322,
        "fullcodeline": "Floor0 *g = &f->floor_config[i].floor0;"
    },
    {
        "line": 328,
        "fullcodeline": "g->number_of_books = get_bits(f,4) + 1;"
    },
    {
        "line": 408,
        "fullcodeline": "uint8 high_bits=0;"
    },
    {
        "line": 409,
        "fullcodeline": "uint8 low_bits=get_bits(f,3);"
    },
    {
        "line": 412,
        "fullcodeline": "residue_cascade[j] = high_bits*8 + low_bits;"
    },
    {
        "line": 432,
        "fullcodeline": "int classwords = f->codebooks[r->classbook].dimensions;"
    },
    {
        "line": 433,
        "fullcodeline": "int temp = j;"
    },
    {
        "line": 434,
        "fullcodeline": "r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);"
    },
    {
        "line": 454,
        "fullcodeline": "m->submaps = get_bits(f,4)+1;"
    },
    {
        "line": 458,
        "fullcodeline": "max_submaps = m->submaps;"
    },
    {
        "line": 460,
        "fullcodeline": "m->coupling_steps = get_bits(f,8)+1;"
    },
    {
        "line": 485,
        "fullcodeline": "get_bits(f,8); // discard"
    },
    {
        "line": 486,
        "fullcodeline": "m->submap_floor[j] = get_bits(f,8);"
    },
    {
        "line": 487,
        "fullcodeline": "m->submap_residue[j] = get_bits(f,8);"
    },
    {
        "line": 514,
        "fullcodeline": "if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 548,
        "fullcodeline": "if (part_read > max_part_read)"
    },
    {
        "line": 26,
        "fullcodeline": "get8(f)   == 'd' &&"
    },
    {
        "line": 78,
        "fullcodeline": "if (f->error == VORBIS_invalid_stream)"
    },
    {
        "line": 120,
        "fullcodeline": "lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);"
    },
    {
        "line": 127,
        "fullcodeline": "while (current_entry < c->entries) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (c->entries > (int) f->setup_temp_memory_required)"
    },
    {
        "line": 156,
        "fullcodeline": "if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 167,
        "fullcodeline": "sorted_count = 0;"
    },
    {
        "line": 181,
        "fullcodeline": "if (!c->codewords)                  return error(f, VORBIS_outofmem);"
    },
    {
        "line": 192,
        "fullcodeline": "size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;"
    },
    {
        "line": 199,
        "fullcodeline": "return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 205,
        "fullcodeline": "if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 209,
        "fullcodeline": "if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 233,
        "fullcodeline": "if (c->lookup_type == 1) {"
    },
    {
        "line": 240,
        "fullcodeline": "if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 242,
        "fullcodeline": "if (mults == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 243,
        "fullcodeline": "for (j=0; j < (int) c->lookup_values; ++j) {"
    },
    {
        "line": 250,
        "fullcodeline": "if (c->lookup_type == 1) {"
    },
    {
        "line": 311,
        "fullcodeline": "if (z != 0) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 323,
        "fullcodeline": "g->order = get_bits(f,8);"
    },
    {
        "line": 324,
        "fullcodeline": "g->rate = get_bits(f,16);"
    },
    {
        "line": 325,
        "fullcodeline": "g->bark_map_size = get_bits(f,16);"
    },
    {
        "line": 326,
        "fullcodeline": "g->amplitude_bits = get_bits(f,6);"
    },
    {
        "line": 327,
        "fullcodeline": "g->amplitude_offset = get_bits(f,8);"
    },
    {
        "line": 329,
        "fullcodeline": "for (j=0; j < g->number_of_books; ++j)"
    },
    {
        "line": 331,
        "fullcodeline": "return error(f, VORBIS_feature_not_supported);"
    },
    {
        "line": 333,
        "fullcodeline": "stbv__floor_ordering p[31*8+2];"
    },
    {
        "line": 334,
        "fullcodeline": "Floor1 *g = &f->floor_config[i].floor1;"
    },
    {
        "line": 335,
        "fullcodeline": "int max_class = -1;"
    },
    {
        "line": 336,
        "fullcodeline": "g->partitions = get_bits(f, 5);"
    },
    {
        "line": 355,
        "fullcodeline": "g->rangebits = get_bits(f,4);"
    },
    {
        "line": 356,
        "fullcodeline": "g->Xlist[0] = 0;"
    },
    {
        "line": 357,
        "fullcodeline": "g->Xlist[1] = 1 << g->rangebits;"
    },
    {
        "line": 358,
        "fullcodeline": "g->values = 2;"
    },
    {
        "line": 371,
        "fullcodeline": "qsort(p, g->values, sizeof(p[0]), point_compare);"
    },
    {
        "line": 399,
        "fullcodeline": "if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 410,
        "fullcodeline": "if (get_bits(f,1))"
    },
    {
        "line": 417,
        "fullcodeline": "for (k=0; k < 8; ++k) {"
    },
    {
        "line": 435,
        "fullcodeline": "if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);"
    },
    {
        "line": 436,
        "fullcodeline": "for (k=classwords-1; k >= 0; --k) {"
    },
    {
        "line": 450,
        "fullcodeline": "if (mapping_type != 0) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 456,
        "fullcodeline": "m->submaps = 1;"
    },
    {
        "line": 461,
        "fullcodeline": "if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 462,
        "fullcodeline": "for (k=0; k < m->coupling_steps; ++k) {"
    },
    {
        "line": 475,
        "fullcodeline": "for (j=0; j < f->channels; ++j) {"
    },
    {
        "line": 488,
        "fullcodeline": "if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 489,
        "fullcodeline": "if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 501,
        "fullcodeline": "if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 502,
        "fullcodeline": "if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 549,
        "fullcodeline": "max_part_read = part_read;"
    },
    {
        "line": 570,
        "fullcodeline": "return error(f, VORBIS_outofmem);"
    },
    {
        "line": 25,
        "fullcodeline": "header[5] == 'a' &&"
    },
    {
        "line": 29,
        "fullcodeline": "return error(f, VORBIS_invalid_first_page);"
    },
    {
        "line": 128,
        "fullcodeline": "int limit = c->entries - current_entry;"
    },
    {
        "line": 129,
        "fullcodeline": "int n = get_bits(f, ilog(limit));"
    },
    {
        "line": 132,
        "fullcodeline": "memset(lengths + current_entry, current_length, n);"
    },
    {
        "line": 133,
        "fullcodeline": "current_entry += n;"
    },
    {
        "line": 134,
        "fullcodeline": "++current_length;"
    },
    {
        "line": 137,
        "fullcodeline": "for (j=0; j < c->entries; ++j) {"
    },
    {
        "line": 153,
        "fullcodeline": "f->setup_temp_memory_required = c->entries;"
    },
    {
        "line": 169,
        "fullcodeline": "for (j=0; j < c->entries; ++j)"
    },
    {
        "line": 193,
        "fullcodeline": "if (size > f->setup_temp_memory_required)"
    },
    {
        "line": 198,
        "fullcodeline": "if (c->sparse) setup_temp_free(f, values, 0);"
    },
    {
        "line": 234,
        "fullcodeline": "int values = lookup1_values(c->entries, c->dimensions);"
    },
    {
        "line": 236,
        "fullcodeline": "c->lookup_values = (uint32) values;"
    },
    {
        "line": 244,
        "fullcodeline": "int q = get_bits(f, c->value_bits);"
    },
    {
        "line": 246,
        "fullcodeline": "mults[j] = q;"
    },
    {
        "line": 252,
        "fullcodeline": "float last=0;"
    },
    {
        "line": 260,
        "fullcodeline": "len = sparse ? c->sorted_entries : c->entries;"
    },
    {
        "line": 280,
        "fullcodeline": "c->lookup_type = 2;"
    },
    {
        "line": 330,
        "fullcodeline": "g->book_list[j] = get_bits(f,8);"
    },
    {
        "line": 337,
        "fullcodeline": "for (j=0; j < g->partitions; ++j) {"
    },
    {
        "line": 342,
        "fullcodeline": "for (j=0; j <= max_class; ++j) {"
    },
    {
        "line": 359,
        "fullcodeline": "for (j=0; j < g->partitions; ++j) {"
    },
    {
        "line": 367,
        "fullcodeline": "for (j=0; j < g->values; ++j) {"
    },
    {
        "line": 372,
        "fullcodeline": "for (j=0; j < g->values-1; ++j)"
    },
    {
        "line": 375,
        "fullcodeline": "for (j=0; j < g->values; ++j)"
    },
    {
        "line": 378,
        "fullcodeline": "for (j=2; j < g->values; ++j) {"
    },
    {
        "line": 385,
        "fullcodeline": "if (g->values > longest_floorlist)"
    },
    {
        "line": 411,
        "fullcodeline": "high_bits = get_bits(f,5);"
    },
    {
        "line": 437,
        "fullcodeline": "r->classdata[j][k] = temp % r->classifications;"
    },
    {
        "line": 438,
        "fullcodeline": "temp /= r->classifications;"
    },
    {
        "line": 463,
        "fullcodeline": "m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));"
    },
    {
        "line": 464,
        "fullcodeline": "m->chan[k].angle = get_bits(f, ilog(f->channels-1));"
    },
    {
        "line": 476,
        "fullcodeline": "m->chan[j].mux = get_bits(f, 4);"
    },
    {
        "line": 481,
        "fullcodeline": "for (j=0; j < f->channels; ++j)"
    },
    {
        "line": 24,
        "fullcodeline": "header[4] == 'e' &&"
    },
    {
        "line": 130,
        "fullcodeline": "if (current_length >= 32) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 185,
        "fullcodeline": "c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);"
    },
    {
        "line": 187,
        "fullcodeline": "c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);"
    },
    {
        "line": 189,
        "fullcodeline": "values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);"
    },
    {
        "line": 194,
        "fullcodeline": "f->setup_temp_memory_required = size;"
    },
    {
        "line": 235,
        "fullcodeline": "if (values < 0) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 238,
        "fullcodeline": "c->lookup_values = c->entries * c->dimensions;"
    },
    {
        "line": 245,
        "fullcodeline": "if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }"
    },
    {
        "line": 259,
        "fullcodeline": "if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }"
    },
    {
        "line": 261,
        "fullcodeline": "for (j=0; j < len; ++j) {"
    },
    {
        "line": 285,
        "fullcodeline": "float last=0;"
    },
    {
        "line": 286,
        "fullcodeline": "CHECK(f);"
    },
    {
        "line": 287,
        "fullcodeline": "c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);"
    },
    {
        "line": 338,
        "fullcodeline": "g->partition_class_list[j] = get_bits(f, 4);"
    },
    {
        "line": 344,
        "fullcodeline": "g->class_subclasses[j] = get_bits(f, 2);"
    },
    {
        "line": 354,
        "fullcodeline": "g->floor1_multiplier = get_bits(f,2)+1;"
    },
    {
        "line": 380,
        "fullcodeline": "neighbors(g->Xlist, j, &low,&hi);"
    },
    {
        "line": 386,
        "fullcodeline": "longest_floorlist = g->values;"
    },
    {
        "line": 465,
        "fullcodeline": "if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 466,
        "fullcodeline": "if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 477,
        "fullcodeline": "if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 23,
        "fullcodeline": "header[3] == 'h' &&"
    },
    {
        "line": 170,
        "fullcodeline": "if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)"
    },
    {
        "line": 171,
        "fullcodeline": "++sorted_count;"
    },
    {
        "line": 186,
        "fullcodeline": "if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);"
    },
    {
        "line": 188,
        "fullcodeline": "if (!c->codewords)                  return error(f, VORBIS_outofmem);"
    },
    {
        "line": 190,
        "fullcodeline": "if (!values)                        return error(f, VORBIS_outofmem);"
    },
    {
        "line": 256,
        "fullcodeline": "c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);"
    },
    {
        "line": 262,
        "fullcodeline": "unsigned int z = sparse ? c->sorted_values[j] : j;"
    },
    {
        "line": 263,
        "fullcodeline": "unsigned int div=1;"
    },
    {
        "line": 288,
        "fullcodeline": "if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }"
    },
    {
        "line": 289,
        "fullcodeline": "for (j=0; j < (int) c->lookup_values; ++j) {"
    },
    {
        "line": 339,
        "fullcodeline": "if (g->partition_class_list[j] > max_class)"
    },
    {
        "line": 349,
        "fullcodeline": "for (k=0; k < 1 << g->class_subclasses[j]; ++k) {"
    },
    {
        "line": 361,
        "fullcodeline": "for (k=0; k < g->class_dimensions[c]; ++k) {"
    },
    {
        "line": 418,
        "fullcodeline": "if (residue_cascade[j] & (1 << k)) {"
    },
    {
        "line": 419,
        "fullcodeline": "r->residue_books[j][k] = get_bits(f, 8);"
    },
    {
        "line": 22,
        "fullcodeline": "header[2] == 's' &&"
    },
    {
        "line": 131,
        "fullcodeline": "if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }"
    },
    {
        "line": 138,
        "fullcodeline": "int present = c->sparse ? get_bits(f,1) : 1;"
    },
    {
        "line": 140,
        "fullcodeline": "lengths[j] = get_bits(f, 5) + 1;"
    },
    {
        "line": 141,
        "fullcodeline": "++total;"
    },
    {
        "line": 255,
        "fullcodeline": "if (c->sorted_entries == 0) goto skip;"
    },
    {
        "line": 258,
        "fullcodeline": "c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);"
    },
    {
        "line": 264,
        "fullcodeline": "for (k=0; k < c->dimensions; ++k) {"
    },
    {
        "line": 290,
        "fullcodeline": "float val = mults[j] * c->delta_value + c->minimum_value + last;"
    },
    {
        "line": 291,
        "fullcodeline": "c->multiplicands[j] = val;"
    },
    {
        "line": 340,
        "fullcodeline": "max_class = g->partition_class_list[j];"
    },
    {
        "line": 343,
        "fullcodeline": "g->class_dimensions[j] = get_bits(f, 3)+1;"
    },
    {
        "line": 346,
        "fullcodeline": "g->class_masterbooks[j] = get_bits(f, 8);"
    },
    {
        "line": 350,
        "fullcodeline": "g->subclass_books[j][k] = get_bits(f,8)-1;"
    },
    {
        "line": 362,
        "fullcodeline": "g->Xlist[g->values] = get_bits(f, g->rangebits);"
    },
    {
        "line": 363,
        "fullcodeline": "++g->values;"
    },
    {
        "line": 374,
        "fullcodeline": "return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 420,
        "fullcodeline": "if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 467,
        "fullcodeline": "if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 21,
        "fullcodeline": "header[1] == 'i' &&"
    },
    {
        "line": 142,
        "fullcodeline": "if (lengths[j] == 32)"
    },
    {
        "line": 145,
        "fullcodeline": "lengths[j] = NO_CODE;"
    },
    {
        "line": 267,
        "fullcodeline": "val = mults[off]*c->delta_value + c->minimum_value + last;"
    },
    {
        "line": 268,
        "fullcodeline": "c->multiplicands[j*c->dimensions + k] = val;"
    },
    {
        "line": 347,
        "fullcodeline": "if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 351,
        "fullcodeline": "if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 422,
        "fullcodeline": "r->residue_books[j][k] = -1;"
    },
    {
        "line": 20,
        "fullcodeline": "header[0] == 'f' &&"
    },
    {
        "line": 265,
        "fullcodeline": "int off = (z / div) % c->lookup_values;"
    },
    {
        "line": 271,
        "fullcodeline": "if (k+1 < c->dimensions) {"
    },
    {
        "line": 293,
        "fullcodeline": "last = val;"
    },
    {
        "line": 19,
        "fullcodeline": "getn(f, header, 6) &&"
    },
    {
        "line": 143,
        "fullcodeline": "return error(f, VORBIS_invalid_setup);"
    },
    {
        "line": 270,
        "fullcodeline": "last = val;"
    },
    {
        "line": 276,
        "fullcodeline": "div *= c->lookup_values;"
    },
    {
        "line": 272,
        "fullcodeline": "if (div > UINT_MAX / (unsigned int) c->lookup_values) {"
    },
    {
        "line": 273,
        "fullcodeline": "setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);"
    },
    {
        "line": 274,
        "fullcodeline": "return error(f, VORBIS_invalid_setup);"
    }
]