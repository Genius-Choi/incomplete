[
    {
        "line": 4,
        "fullcodeline": "int retval, ctrl, status=PAM_AUTH_ERR;"
    },
    {
        "line": 9,
        "fullcodeline": "struct tac_attrib *attr = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "user = tty = r_addr = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "memset(&arep, 0, sizeof(arep));"
    },
    {
        "line": 20,
        "fullcodeline": "ctrl = _pam_parse (argc, argv);"
    },
    {
        "line": 32,
        "fullcodeline": "tty = _pam_get_terminal(pamh);"
    },
    {
        "line": 38,
        "fullcodeline": "r_addr = _pam_get_rhost(pamh);"
    },
    {
        "line": 64,
        "fullcodeline": "tac_add_attrib(&attr, \"service\", tac_service);"
    },
    {
        "line": 68,
        "fullcodeline": "tac_fd = tac_connect_single(active_server.addr, active_server.key, NULL, tac_timeout);"
    },
    {
        "line": 76,
        "fullcodeline": "retval = tac_author_send(tac_fd, user, tty, r_addr, attr);"
    },
    {
        "line": 78,
        "fullcodeline": "tac_free_attrib(&attr);"
    },
    {
        "line": 92,
        "fullcodeline": "tac_author_read(tac_fd, &arep);"
    },
    {
        "line": 108,
        "fullcodeline": "status = PAM_SUCCESS;"
    },
    {
        "line": 110,
        "fullcodeline": "attr = arep.attr;"
    },
    {
        "line": 152,
        "fullcodeline": "close(tac_fd);"
    },
    {
        "line": 22,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 26,
        "fullcodeline": "if ((user = _pam_get_user(pamh)) == NULL)"
    },
    {
        "line": 29,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 33,
        "fullcodeline": "if(!strncmp(tty, \"/dev/\", 5))"
    },
    {
        "line": 35,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 39,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 46,
        "fullcodeline": "if(active_server.addr == NULL) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 65,
        "fullcodeline": "if(tac_protocol[0] != '\\0')"
    },
    {
        "line": 69,
        "fullcodeline": "if(tac_fd < 0) {"
    },
    {
        "line": 80,
        "fullcodeline": "if(retval < 0) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 94,
        "fullcodeline": "if(arep.status != AUTHOR_STATUS_PASS_ADD &&"
    },
    {
        "line": 105,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 111,
        "fullcodeline": "while (attr != NULL)  {"
    },
    {
        "line": 146,
        "fullcodeline": "if(arep.attr != NULL)"
    },
    {
        "line": 149,
        "fullcodeline": "if(arep.msg != NULL)"
    },
    {
        "line": 23,
        "fullcodeline": "syslog (LOG_DEBUG, \"%s: called (pam_tacplus v%u.%u.%u)\""
    },
    {
        "line": 30,
        "fullcodeline": "syslog(LOG_DEBUG, \"%s: username obtained [%s]\", __FUNCTION__, user);"
    },
    {
        "line": 34,
        "fullcodeline": "tty += 5;"
    },
    {
        "line": 36,
        "fullcodeline": "syslog(LOG_DEBUG, \"%s: tty obtained [%s]\", __FUNCTION__, tty);"
    },
    {
        "line": 40,
        "fullcodeline": "syslog(LOG_DEBUG, \"%s: rhost obtained [%s]\", __FUNCTION__, r_addr);"
    },
    {
        "line": 47,
        "fullcodeline": "_pam_log (LOG_ERR, \"user not authenticated by TACACS+\");"
    },
    {
        "line": 51,
        "fullcodeline": "syslog (LOG_DEBUG, \"%s: active server is [%s]\", __FUNCTION__,"
    },
    {
        "line": 57,
        "fullcodeline": "_pam_log (LOG_ERR, \"SM: TACACS+ service type not configured\");"
    },
    {
        "line": 61,
        "fullcodeline": "_pam_log (LOG_ERR, \"SM: TACACS+ protocol type not configured (IGNORED)\");"
    },
    {
        "line": 66,
        "fullcodeline": "tac_add_attrib(&attr, \"protocol\", tac_protocol);"
    },
    {
        "line": 70,
        "fullcodeline": "_pam_log (LOG_ERR, \"TACACS+ server unavailable\");"
    },
    {
        "line": 81,
        "fullcodeline": "_pam_log (LOG_ERR, \"error getting authorization\");"
    },
    {
        "line": 85,
        "fullcodeline": "close(tac_fd);"
    },
    {
        "line": 90,
        "fullcodeline": "syslog(LOG_DEBUG, \"%s: sent authorization request\", __FUNCTION__);"
    },
    {
        "line": 95,
        "fullcodeline": "arep.status != AUTHOR_STATUS_PASS_REPL) {"
    },
    {
        "line": 97,
        "fullcodeline": "_pam_log (LOG_ERR, \"TACACS+ authorisation failed for [%s]\", user);"
    },
    {
        "line": 101,
        "fullcodeline": "close(tac_fd);"
    },
    {
        "line": 106,
        "fullcodeline": "syslog(LOG_DEBUG, \"%s: user [%s] successfully authorized\", __FUNCTION__, user);"
    },
    {
        "line": 112,
        "fullcodeline": "char attribute[attr->attr_len];"
    },
    {
        "line": 113,
        "fullcodeline": "char value[attr->attr_len];"
    },
    {
        "line": 116,
        "fullcodeline": "sep = index(attr->attr, '=');"
    },
    {
        "line": 142,
        "fullcodeline": "attr = attr->next;"
    },
    {
        "line": 147,
        "fullcodeline": "tac_free_attrib(&arep.attr);"
    },
    {
        "line": 150,
        "fullcodeline": "free (arep.msg);"
    },
    {
        "line": 71,
        "fullcodeline": "if(arep.msg != NULL)"
    },
    {
        "line": 82,
        "fullcodeline": "if(arep.msg != NULL)"
    },
    {
        "line": 98,
        "fullcodeline": "if(arep.msg != NULL)"
    },
    {
        "line": 117,
        "fullcodeline": "if(sep == NULL)"
    },
    {
        "line": 119,
        "fullcodeline": "if(sep != NULL) {"
    },
    {
        "line": 72,
        "fullcodeline": "free (arep.msg);"
    },
    {
        "line": 83,
        "fullcodeline": "free (arep.msg);"
    },
    {
        "line": 99,
        "fullcodeline": "free (arep.msg);"
    },
    {
        "line": 118,
        "fullcodeline": "sep = index(attr->attr, '*');"
    },
    {
        "line": 120,
        "fullcodeline": "bcopy(attr->attr, attribute, attr->attr_len-strlen(sep));"
    },
    {
        "line": 121,
        "fullcodeline": "attribute[attr->attr_len-strlen(sep)] = '\\0';"
    },
    {
        "line": 122,
        "fullcodeline": "bcopy(sep, value, strlen(sep));"
    },
    {
        "line": 123,
        "fullcodeline": "value[strlen(sep)] = '\\0';"
    },
    {
        "line": 126,
        "fullcodeline": "for (i = 0; attribute[i] != '\\0'; i++) {"
    },
    {
        "line": 132,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG)"
    },
    {
        "line": 136,
        "fullcodeline": "if (pam_putenv(pamh, strncat(attribute, value, strlen(value))) != PAM_SUCCESS)"
    },
    {
        "line": 140,
        "fullcodeline": "syslog(LOG_WARNING, \"%s: invalid attribute `%s', no separator\", __FUNCTION__, attr->attr);"
    },
    {
        "line": 127,
        "fullcodeline": "attribute[i] = toupper(attribute[i]);"
    },
    {
        "line": 133,
        "fullcodeline": "syslog(LOG_DEBUG, \"%s: returned attribute `%s%s' from server\", __FUNCTION__, attribute, value);"
    },
    {
        "line": 137,
        "fullcodeline": "syslog(LOG_WARNING, \"%s: unable to set PAM environment\", __FUNCTION__);"
    },
    {
        "line": 128,
        "fullcodeline": "if (attribute[i] == '-')"
    },
    {
        "line": 129,
        "fullcodeline": "attribute[i] = '_';"
    }
]