[
    {
        "line": 9,
        "fullcodeline": "pkey_ctx = backend._lib.EVP_PKEY_CTX_new(key._evp_pkey, backend._ffi.NULL)"
    },
    {
        "line": 10,
        "fullcodeline": "backend.openssl_assert(pkey_ctx != backend._ffi.NULL)"
    },
    {
        "line": 11,
        "fullcodeline": "pkey_ctx = backend._ffi.gc(pkey_ctx, backend._lib.EVP_PKEY_CTX_free)"
    },
    {
        "line": 12,
        "fullcodeline": "res = init(pkey_ctx)"
    },
    {
        "line": 13,
        "fullcodeline": "backend.openssl_assert(res == 1)"
    },
    {
        "line": 14,
        "fullcodeline": "res = backend._lib.EVP_PKEY_CTX_set_rsa_padding(pkey_ctx, padding_enum)"
    },
    {
        "line": 15,
        "fullcodeline": "backend.openssl_assert(res > 0)"
    },
    {
        "line": 16,
        "fullcodeline": "buf_size = backend._lib.EVP_PKEY_size(key._evp_pkey)"
    },
    {
        "line": 17,
        "fullcodeline": "backend.openssl_assert(buf_size > 0)"
    },
    {
        "line": 43,
        "fullcodeline": "outlen = backend._ffi.new(\"size_t *\", buf_size)"
    },
    {
        "line": 44,
        "fullcodeline": "buf = backend._ffi.new(\"unsigned char[]\", buf_size)"
    },
    {
        "line": 45,
        "fullcodeline": "res = crypt(pkey_ctx, buf, outlen, data, len(data))"
    },
    {
        "line": 2,
        "fullcodeline": "if isinstance(key, _RSAPublicKey):"
    },
    {
        "line": 18,
        "fullcodeline": "if isinstance(padding, OAEP) and backend._lib.Cryptography_HAS_RSA_OAEP_MD:"
    },
    {
        "line": 29,
        "fullcodeline": "isinstance(padding, OAEP)"
    },
    {
        "line": 46,
        "fullcodeline": "if res <= 0:"
    },
    {
        "line": 49,
        "fullcodeline": "return backend._ffi.buffer(buf)[: outlen[0]]"
    },
    {
        "line": 19,
        "fullcodeline": "mgf1_md = backend._evp_md_non_null_from_algorithm("
    },
    {
        "line": 22,
        "fullcodeline": "res = backend._lib.EVP_PKEY_CTX_set_rsa_mgf1_md(pkey_ctx, mgf1_md)"
    },
    {
        "line": 23,
        "fullcodeline": "backend.openssl_assert(res > 0)"
    },
    {
        "line": 24,
        "fullcodeline": "oaep_md = backend._evp_md_non_null_from_algorithm(padding._algorithm)"
    },
    {
        "line": 25,
        "fullcodeline": "res = backend._lib.EVP_PKEY_CTX_set_rsa_oaep_md(pkey_ctx, oaep_md)"
    },
    {
        "line": 26,
        "fullcodeline": "backend.openssl_assert(res > 0)"
    },
    {
        "line": 30,
        "fullcodeline": "and padding._label is not None"
    },
    {
        "line": 35,
        "fullcodeline": "labelptr = backend._lib.OPENSSL_malloc(len(padding._label))"
    },
    {
        "line": 36,
        "fullcodeline": "backend.openssl_assert(labelptr != backend._ffi.NULL)"
    },
    {
        "line": 38,
        "fullcodeline": "res = backend._lib.EVP_PKEY_CTX_set0_rsa_oaep_label("
    },
    {
        "line": 41,
        "fullcodeline": "backend.openssl_assert(res == 1)"
    },
    {
        "line": 47,
        "fullcodeline": "_handle_rsa_enc_dec_error(backend, key)"
    },
    {
        "line": 37,
        "fullcodeline": "backend._ffi.memmove(labelptr, padding._label, len(padding._label))"
    },
    {
        "line": 39,
        "fullcodeline": "pkey_ctx, labelptr, len(padding._label)"
    }
]