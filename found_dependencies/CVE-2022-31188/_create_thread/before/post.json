[
    {
        "line": 7,
        "fullcodeline": "db_data = db_task.data"
    },
    {
        "line": 8,
        "fullcodeline": "upload_dir = db_data.get_upload_dirname()"
    },
    {
        "line": 13,
        "fullcodeline": "manifest_files = []"
    },
    {
        "line": 14,
        "fullcodeline": "media = _count_files(data, manifest_files)"
    },
    {
        "line": 23,
        "fullcodeline": "manifest_root = None"
    },
    {
        "line": 29,
        "fullcodeline": "manifest_file = _validate_manifest(manifest_files, manifest_root)"
    },
    {
        "line": 65,
        "fullcodeline": "av_scan_paths(upload_dir)"
    },
    {
        "line": 67,
        "fullcodeline": "job = rq.get_current_job()"
    },
    {
        "line": 68,
        "fullcodeline": "job.meta['status'] = 'Media files are being extracted...'"
    },
    {
        "line": 69,
        "fullcodeline": "job.save_meta()"
    },
    {
        "line": 71,
        "fullcodeline": "db_images = []"
    },
    {
        "line": 72,
        "fullcodeline": "extractor = None"
    },
    {
        "line": 73,
        "fullcodeline": "manifest_index = _get_manifest_frame_indexer()"
    },
    {
        "line": 117,
        "fullcodeline": "validate_dimension = ValidateDimension()"
    },
    {
        "line": 148,
        "fullcodeline": "related_images = {}"
    },
    {
        "line": 180,
        "fullcodeline": "db_task.mode = task_mode"
    },
    {
        "line": 184,
        "fullcodeline": "def update_progress(progress):"
    },
    {
        "line": 197,
        "fullcodeline": "compressed_chunk_writer_class = Mpeg4CompressedChunkWriter if db_data.compressed_chunk_type == models.DataChoice.VIDEO else ZipCompressedChunkWriter"
    },
    {
        "line": 207,
        "fullcodeline": "kwargs = {}"
    },
    {
        "line": 210,
        "fullcodeline": "compressed_chunk_writer = compressed_chunk_writer_class(db_data.image_quality, **kwargs)"
    },
    {
        "line": 211,
        "fullcodeline": "original_chunk_writer = original_chunk_writer_class(original_quality)"
    },
    {
        "line": 226,
        "fullcodeline": "video_path = \"\""
    },
    {
        "line": 227,
        "fullcodeline": "video_size = (0, 0)"
    },
    {
        "line": 229,
        "fullcodeline": "def _update_status(msg):"
    },
    {
        "line": 386,
        "fullcodeline": "preview = extractor.get_preview()"
    },
    {
        "line": 387,
        "fullcodeline": "preview.save(db_data.get_preview_path())"
    },
    {
        "line": 390,
        "fullcodeline": "_save_task_to_db(db_task)"
    },
    {
        "line": 2,
        "fullcodeline": "if isinstance(db_task, int):"
    },
    {
        "line": 5,
        "fullcodeline": "slogger.glob.info(\"create task #{}\".format(db_task.id))"
    },
    {
        "line": 10,
        "fullcodeline": "if data['remote_files'] and not isDatasetImport:"
    },
    {
        "line": 15,
        "fullcodeline": "media, task_mode = _validate_data(media, manifest_files)"
    },
    {
        "line": 24,
        "fullcodeline": "if db_data.storage in {models.StorageChoice.LOCAL, models.StorageChoice.SHARE}:"
    },
    {
        "line": 30,
        "fullcodeline": "if manifest_file and (not settings.USE_CACHE or db_data.storage_method != models.StorageMethodChoice.CACHE):"
    },
    {
        "line": 33,
        "fullcodeline": "if data['server_files'] and db_data.storage == models.StorageChoice.CLOUD_STORAGE:"
    },
    {
        "line": 77,
        "fullcodeline": "if (data['server_files']) and len(media['directory']) and len(media['image']):"
    },
    {
        "line": 87,
        "fullcodeline": "for media_type, media_files in media.items():"
    },
    {
        "line": 118,
        "fullcodeline": "if isinstance(extractor, MEDIA_TYPES['zip']['extractor']):"
    },
    {
        "line": 121,
        "fullcodeline": "if db_data.storage == models.StorageChoice.LOCAL or \\"
    },
    {
        "line": 127,
        "fullcodeline": "if db_task.project is not None and db_task.project.tasks.count() > 1 and db_task.project.tasks.first().dimension != validate_dimension.dimension:"
    },
    {
        "line": 130,
        "fullcodeline": "if validate_dimension.dimension == models.DimensionType.DIM_3D:"
    },
    {
        "line": 149,
        "fullcodeline": "if isinstance(extractor, MEDIA_TYPES['image']['extractor']):"
    },
    {
        "line": 153,
        "fullcodeline": "if isBackupRestore and not isinstance(extractor, MEDIA_TYPES['video']['extractor']) and db_data.storage_method == models.StorageMethodChoice.CACHE and \\"
    },
    {
        "line": 198,
        "fullcodeline": "if db_data.original_chunk_type == models.DataChoice.VIDEO:"
    },
    {
        "line": 208,
        "fullcodeline": "if validate_dimension.dimension == models.DimensionType.DIM_3D:"
    },
    {
        "line": 214,
        "fullcodeline": "if db_data.chunk_size is None:"
    },
    {
        "line": 233,
        "fullcodeline": "if settings.USE_CACHE and db_data.storage_method == models.StorageMethodChoice.CACHE:"
    },
    {
        "line": 332,
        "fullcodeline": "if db_data.storage_method == models.StorageMethodChoice.FILE_SYSTEM or not settings.USE_CACHE:"
    },
    {
        "line": 362,
        "fullcodeline": "if db_task.mode == 'annotation':"
    },
    {
        "line": 379,
        "fullcodeline": "if db_data.stop_frame == 0:"
    },
    {
        "line": 389,
        "fullcodeline": "slogger.glob.info(\"Found frames {} for Data #{}\".format(db_data.size, db_data.id))"
    },
    {
        "line": 3,
        "fullcodeline": "db_task = models.Task.objects.select_for_update().get(pk=db_task)"
    },
    {
        "line": 11,
        "fullcodeline": "data['remote_files'] = _download_data(data['remote_files'], upload_dir)"
    },
    {
        "line": 25,
        "fullcodeline": "manifest_root = upload_dir"
    },
    {
        "line": 31,
        "fullcodeline": "raise Exception(\"File with meta information can be uploaded if 'Use cache' option is also selected\")"
    },
    {
        "line": 35,
        "fullcodeline": "db_cloud_storage = db_data.cloud_storage"
    },
    {
        "line": 36,
        "fullcodeline": "credentials = Credentials()"
    },
    {
        "line": 37,
        "fullcodeline": "credentials.convert_from_db({"
    },
    {
        "line": 42,
        "fullcodeline": "details = {"
    },
    {
        "line": 47,
        "fullcodeline": "cloud_storage_instance = get_cloud_storage_instance(cloud_provider=db_cloud_storage.provider_type, **details)"
    },
    {
        "line": 48,
        "fullcodeline": "sorted_media = sort(media['image'], data['sorting_method'])"
    },
    {
        "line": 49,
        "fullcodeline": "first_sorted_media_image = sorted_media[0]"
    },
    {
        "line": 50,
        "fullcodeline": "cloud_storage_instance.download_file(first_sorted_media_image, os.path.join(upload_dir, first_sorted_media_image))"
    },
    {
        "line": 55,
        "fullcodeline": "manifest = ImageManifestManager(db_data.get_manifest_path())"
    },
    {
        "line": 56,
        "fullcodeline": "cloud_storage_manifest = ImageManifestManager("
    },
    {
        "line": 60,
        "fullcodeline": "cloud_storage_manifest.set_index()"
    },
    {
        "line": 62,
        "fullcodeline": "sorted_content = (i[1] for i in sorted(zip(sequence, content)))"
    },
    {
        "line": 63,
        "fullcodeline": "manifest.create(sorted_content)"
    },
    {
        "line": 85,
        "fullcodeline": "media['directory'] = []"
    },
    {
        "line": 119,
        "fullcodeline": "extractor.extract()"
    },
    {
        "line": 122,
        "fullcodeline": "(db_data.storage == models.StorageChoice.SHARE and \\"
    },
    {
        "line": 124,
        "fullcodeline": "validate_dimension.set_path(upload_dir)"
    },
    {
        "line": 125,
        "fullcodeline": "validate_dimension.validate()"
    },
    {
        "line": 128,
        "fullcodeline": "raise Exception(f'Dimension ({validate_dimension.dimension}) of the task must be the same as other tasks in project ({db_task.project.tasks.first().dimension})')"
    },
    {
        "line": 131,
        "fullcodeline": "db_task.dimension = models.DimensionType.DIM_3D"
    },
    {
        "line": 133,
        "fullcodeline": "keys_of_related_files = validate_dimension.related_files.keys()"
    },
    {
        "line": 134,
        "fullcodeline": "absolute_keys_of_related_files = [os.path.join(upload_dir, f) for f in keys_of_related_files]"
    },
    {
        "line": 138,
        "fullcodeline": "source_files = absolute_keys_of_related_files if not isBackupRestore else \\"
    },
    {
        "line": 140,
        "fullcodeline": "extractor.reconcile("
    },
    {
        "line": 150,
        "fullcodeline": "extractor.filter(lambda x: not re.search(r'(^|{0})related_images{0}'.format(os.sep), x))"
    },
    {
        "line": 151,
        "fullcodeline": "related_images = detect_related_images(extractor.absolute_source_paths, upload_dir)"
    },
    {
        "line": 157,
        "fullcodeline": "manifest = ImageManifestManager(db_data.get_manifest_path())"
    },
    {
        "line": 158,
        "fullcodeline": "manifest.set_index()"
    },
    {
        "line": 159,
        "fullcodeline": "sorted_media_files = []"
    },
    {
        "line": 169,
        "fullcodeline": "media_files = sorted_media_files.copy()"
    },
    {
        "line": 170,
        "fullcodeline": "del sorted_media_files"
    },
    {
        "line": 172,
        "fullcodeline": "extractor.reconcile("
    },
    {
        "line": 181,
        "fullcodeline": "db_data.compressed_chunk_type = models.DataChoice.VIDEO if task_mode == 'interpolation' and not data['use_zip_chunks'] else models.DataChoice.IMAGESET"
    },
    {
        "line": 182,
        "fullcodeline": "db_data.original_chunk_type = models.DataChoice.VIDEO if task_mode == 'interpolation' else models.DataChoice.IMAGESET"
    },
    {
        "line": 199,
        "fullcodeline": "original_chunk_writer_class = Mpeg4ChunkWriter"
    },
    {
        "line": 202,
        "fullcodeline": "original_quality = 67"
    },
    {
        "line": 204,
        "fullcodeline": "original_chunk_writer_class = ZipChunkWriter"
    },
    {
        "line": 205,
        "fullcodeline": "original_quality = 100"
    },
    {
        "line": 209,
        "fullcodeline": "kwargs[\"dimension\"] = validate_dimension.dimension"
    },
    {
        "line": 333,
        "fullcodeline": "counter = itertools.count()"
    },
    {
        "line": 334,
        "fullcodeline": "generator = itertools.groupby(extractor, lambda x: next(counter) // db_data.chunk_size)"
    },
    {
        "line": 364,
        "fullcodeline": "created_images = models.Image.objects.filter(data_id=db_data.id)"
    },
    {
        "line": 366,
        "fullcodeline": "db_related_files = ["
    },
    {
        "line": 372,
        "fullcodeline": "db_images = []"
    },
    {
        "line": 380,
        "fullcodeline": "db_data.stop_frame = db_data.start_frame + (db_data.size - 1) * db_data.get_frame_step()"
    },
    {
        "line": 383,
        "fullcodeline": "db_data.stop_frame = min(db_data.stop_frame, \\"
    },
    {
        "line": 18,
        "fullcodeline": "if db_data.storage == models.StorageChoice.LOCAL:"
    },
    {
        "line": 26,
        "fullcodeline": "elif db_data.storage == models.StorageChoice.CLOUD_STORAGE:"
    },
    {
        "line": 34,
        "fullcodeline": "if not manifest_file: raise Exception('A manifest file not found')"
    },
    {
        "line": 61,
        "fullcodeline": "sequence, content = cloud_storage_manifest.get_subset(sorted_media)"
    },
    {
        "line": 78,
        "fullcodeline": "media['image'].extend("
    },
    {
        "line": 123,
        "fullcodeline": "isinstance(extractor, MEDIA_TYPES['zip']['extractor'])):"
    },
    {
        "line": 142,
        "fullcodeline": "step=db_data.get_frame_step(),"
    },
    {
        "line": 161,
        "fullcodeline": "for idx in range(len(extractor.absolute_source_paths)):"
    },
    {
        "line": 174,
        "fullcodeline": "step=db_data.get_frame_step(),"
    },
    {
        "line": 215,
        "fullcodeline": "if isinstance(compressed_chunk_writer, ZipCompressedChunkWriter):"
    },
    {
        "line": 234,
        "fullcodeline": "for media_type, media_files in media.items():"
    },
    {
        "line": 335,
        "fullcodeline": "for chunk_idx, chunk_data in generator:"
    },
    {
        "line": 363,
        "fullcodeline": "models.Image.objects.bulk_create(db_images)"
    },
    {
        "line": 371,
        "fullcodeline": "models.RelatedFile.objects.bulk_create(db_related_files)"
    },
    {
        "line": 374,
        "fullcodeline": "models.Video.objects.create("
    },
    {
        "line": 19,
        "fullcodeline": "_copy_data_from_source(data['server_files'], upload_dir, data.get('server_files_path'))"
    },
    {
        "line": 27,
        "fullcodeline": "manifest_root = db_data.cloud_storage.get_storage_dirname()"
    },
    {
        "line": 221,
        "fullcodeline": "area = h * w"
    },
    {
        "line": 222,
        "fullcodeline": "db_data.chunk_size = max(2, min(72, 36 * 1920 * 1080 // area))"
    },
    {
        "line": 224,
        "fullcodeline": "db_data.chunk_size = 36"
    },
    {
        "line": 384,
        "fullcodeline": "db_data.start_frame + (db_data.size - 1) * db_data.get_frame_step())"
    },
    {
        "line": 20,
        "fullcodeline": "elif db_data.storage == models.StorageChoice.SHARE:"
    },
    {
        "line": 45,
        "fullcodeline": "'specific_attributes': db_cloud_storage.get_specific_attributes()"
    },
    {
        "line": 57,
        "fullcodeline": "os.path.join(db_data.cloud_storage.get_storage_dirname(), manifest_file),"
    },
    {
        "line": 58,
        "fullcodeline": "db_data.cloud_storage.get_storage_dirname()"
    },
    {
        "line": 79,
        "fullcodeline": "[os.path.relpath(image, upload_dir) for image in"
    },
    {
        "line": 96,
        "fullcodeline": "source_paths=[os.path.join(upload_dir, f) for f in media_files]"
    },
    {
        "line": 103,
        "fullcodeline": "details = {"
    },
    {
        "line": 115,
        "fullcodeline": "extractor = MEDIA_TYPES[media_type]['extractor'](**details)"
    },
    {
        "line": 139,
        "fullcodeline": "[item for item in extractor.absolute_source_paths if item in absolute_keys_of_related_files]"
    },
    {
        "line": 162,
        "fullcodeline": "properties = manifest[idx]"
    },
    {
        "line": 163,
        "fullcodeline": "image_name = properties.get('name', None)"
    },
    {
        "line": 164,
        "fullcodeline": "image_extension = properties.get('extension', None)"
    },
    {
        "line": 166,
        "fullcodeline": "full_image_path = os.path.join(upload_dir, f\"{image_name}{image_extension}\") if image_name and image_extension else None"
    },
    {
        "line": 216,
        "fullcodeline": "if not (db_data.storage == models.StorageChoice.CLOUD_STORAGE):"
    },
    {
        "line": 336,
        "fullcodeline": "chunk_data = list(chunk_data)"
    },
    {
        "line": 337,
        "fullcodeline": "original_chunk_path = db_data.get_original_chunk_path(chunk_idx)"
    },
    {
        "line": 338,
        "fullcodeline": "original_chunk_writer.save_as_chunk(chunk_data, original_chunk_path)"
    },
    {
        "line": 340,
        "fullcodeline": "compressed_chunk_path = db_data.get_compressed_chunk_path(chunk_idx)"
    },
    {
        "line": 341,
        "fullcodeline": "img_sizes = compressed_chunk_writer.save_as_chunk(chunk_data, compressed_chunk_path)"
    },
    {
        "line": 358,
        "fullcodeline": "db_data.size += len(chunk_data)"
    },
    {
        "line": 359,
        "fullcodeline": "progress = extractor.get_progress(chunk_data[-1][2])"
    },
    {
        "line": 360,
        "fullcodeline": "update_progress(progress)"
    },
    {
        "line": 376,
        "fullcodeline": "path=os.path.relpath(video_path, upload_dir),"
    },
    {
        "line": 89,
        "fullcodeline": "if extractor is not None:"
    },
    {
        "line": 91,
        "fullcodeline": "if (isDatasetImport or isBackupRestore) and media_type == 'image' and db_data.storage == models.StorageChoice.SHARE:"
    },
    {
        "line": 97,
        "fullcodeline": "if manifest_file and not isBackupRestore and data['sorting_method'] in {models.SortingMethod.RANDOM, models.SortingMethod.PREDEFINED}:"
    },
    {
        "line": 99,
        "fullcodeline": "if isBackupRestore and db_data.storage_method == models.StorageMethodChoice.FILE_SYSTEM and \\"
    },
    {
        "line": 109,
        "fullcodeline": "if media_type in {'archive', 'zip', 'pdf'} and db_data.storage == models.StorageChoice.SHARE:"
    },
    {
        "line": 113,
        "fullcodeline": "if media_type != 'video':"
    },
    {
        "line": 167,
        "fullcodeline": "if full_image_path and full_image_path in extractor:"
    },
    {
        "line": 219,
        "fullcodeline": "img_properties = manifest[0]"
    },
    {
        "line": 236,
        "fullcodeline": "if not media_files:"
    },
    {
        "line": 240,
        "fullcodeline": "if manifest_file and not os.path.exists(db_data.get_manifest_path()):"
    },
    {
        "line": 246,
        "fullcodeline": "if task_mode == MEDIA_TYPES['video']['mode']:"
    },
    {
        "line": 343,
        "fullcodeline": "if db_task.mode == 'annotation':"
    },
    {
        "line": 90,
        "fullcodeline": "raise Exception('Combined data types are not supported')"
    },
    {
        "line": 92,
        "fullcodeline": "manifest_index = _get_manifest_frame_indexer(db_data.start_frame, db_data.get_frame_step())"
    },
    {
        "line": 93,
        "fullcodeline": "db_data.start_frame = 0"
    },
    {
        "line": 94,
        "fullcodeline": "data['stop_frame'] = None"
    },
    {
        "line": 95,
        "fullcodeline": "db_data.frame_filter = ''"
    },
    {
        "line": 98,
        "fullcodeline": "raise Exception(\"It isn't supported to upload manifest file and use random sorting\")"
    },
    {
        "line": 101,
        "fullcodeline": "raise Exception(\"It isn't supported to import the task that was created without cache but with random/predefined sorting\")"
    },
    {
        "line": 110,
        "fullcodeline": "details['extract_dir'] = db_data.get_upload_dirname()"
    },
    {
        "line": 111,
        "fullcodeline": "upload_dir = db_data.get_upload_dirname()"
    },
    {
        "line": 112,
        "fullcodeline": "db_data.storage = models.StorageChoice.LOCAL"
    },
    {
        "line": 114,
        "fullcodeline": "details['sorting_method'] = data['sorting_method']"
    },
    {
        "line": 168,
        "fullcodeline": "sorted_media_files.append(full_image_path)"
    },
    {
        "line": 217,
        "fullcodeline": "w, h = extractor.get_image_size(0)"
    },
    {
        "line": 220,
        "fullcodeline": "w, h = img_properties['width'], img_properties['height']"
    },
    {
        "line": 241,
        "fullcodeline": "shutil.copyfile(os.path.join(upload_dir, manifest_file),"
    },
    {
        "line": 296,
        "fullcodeline": "db_data.size = len(extractor)"
    },
    {
        "line": 297,
        "fullcodeline": "manifest = ImageManifestManager(db_data.get_manifest_path())"
    },
    {
        "line": 308,
        "fullcodeline": "counter = itertools.count()"
    },
    {
        "line": 344,
        "fullcodeline": "db_images.extend(["
    },
    {
        "line": 355,
        "fullcodeline": "video_size = img_sizes[0]"
    },
    {
        "line": 105,
        "fullcodeline": "'step': db_data.get_frame_step(),"
    },
    {
        "line": 242,
        "fullcodeline": "db_data.get_manifest_path())"
    },
    {
        "line": 243,
        "fullcodeline": "if upload_dir != settings.SHARE_ROOT:"
    },
    {
        "line": 298,
        "fullcodeline": "if not manifest_file:"
    },
    {
        "line": 309,
        "fullcodeline": "for _, chunk_frames in itertools.groupby(extractor.frame_range, lambda x: next(counter) // db_data.chunk_size):"
    },
    {
        "line": 244,
        "fullcodeline": "os.remove(os.path.join(upload_dir, manifest_file))"
    },
    {
        "line": 248,
        "fullcodeline": "manifest_is_prepared = False"
    },
    {
        "line": 285,
        "fullcodeline": "db_data.size = len(range(db_data.start_frame, min(data['stop_frame'] + 1 \\"
    },
    {
        "line": 287,
        "fullcodeline": "video_path = os.path.join(upload_dir, media_files[0])"
    },
    {
        "line": 299,
        "fullcodeline": "manifest.link("
    },
    {
        "line": 305,
        "fullcodeline": "manifest.create()"
    },
    {
        "line": 307,
        "fullcodeline": "manifest.init_index()"
    },
    {
        "line": 80,
        "fullcodeline": "MEDIA_TYPES['directory']['extractor']("
    },
    {
        "line": 270,
        "fullcodeline": "if not manifest_is_prepared:"
    },
    {
        "line": 303,
        "fullcodeline": "DIM_3D=(db_task.dimension == models.DimensionType.DIM_3D),"
    },
    {
        "line": 310,
        "fullcodeline": "chunk_paths = [(extractor.get_path(i), i) for i in chunk_frames]"
    },
    {
        "line": 311,
        "fullcodeline": "img_sizes = []"
    },
    {
        "line": 325,
        "fullcodeline": "db_images.extend(["
    },
    {
        "line": 271,
        "fullcodeline": "_update_status('Start prepare a manifest file')"
    },
    {
        "line": 272,
        "fullcodeline": "manifest = VideoManifestManager(db_data.get_manifest_path())"
    },
    {
        "line": 273,
        "fullcodeline": "manifest.link("
    },
    {
        "line": 278,
        "fullcodeline": "manifest.create()"
    },
    {
        "line": 279,
        "fullcodeline": "_update_status('A manifest had been created')"
    },
    {
        "line": 281,
        "fullcodeline": "all_frames = len(manifest.reader)"
    },
    {
        "line": 283,
        "fullcodeline": "manifest_is_prepared = True"
    },
    {
        "line": 289,
        "fullcodeline": "db_data.storage_method = models.StorageMethodChoice.FILE_SYSTEM"
    },
    {
        "line": 290,
        "fullcodeline": "manifest.remove()"
    },
    {
        "line": 291,
        "fullcodeline": "del manifest"
    },
    {
        "line": 292,
        "fullcodeline": "base_msg = str(ex) if isinstance(ex, AssertionError) \\"
    },
    {
        "line": 294,
        "fullcodeline": "_update_status(\"{} The task will be created using the old method\".format(base_msg))"
    },
    {
        "line": 301,
        "fullcodeline": "meta={ k: {'related_images': related_images[k] } for k in related_images },"
    },
    {
        "line": 313,
        "fullcodeline": "for chunk_path, frame_id in chunk_paths:"
    },
    {
        "line": 369,
        "fullcodeline": "for related_file_path in related_images.get(image.path, [])"
    },
    {
        "line": 367,
        "fullcodeline": "models.RelatedFile(data=image.data, primary_image=image, path=os.path.join(upload_dir, related_file_path))"
    },
    {
        "line": 81,
        "fullcodeline": "source_path=[os.path.join(upload_dir, f) for f in media['directory']],"
    },
    {
        "line": 286,
        "fullcodeline": "if data['stop_frame'] else all_frames, all_frames), db_data.get_frame_step()))"
    },
    {
        "line": 251,
        "fullcodeline": "manifest = VideoManifestValidator(source_path=os.path.join(upload_dir, media_files[0]),"
    },
    {
        "line": 253,
        "fullcodeline": "manifest.init_index()"
    },
    {
        "line": 254,
        "fullcodeline": "manifest.validate_seek_key_frames()"
    },
    {
        "line": 255,
        "fullcodeline": "manifest.validate_frame_numbers()"
    },
    {
        "line": 256,
        "fullcodeline": "assert len(manifest) > 0, 'No key frames.'"
    },
    {
        "line": 258,
        "fullcodeline": "all_frames = manifest.video_length"
    },
    {
        "line": 259,
        "fullcodeline": "video_size = manifest.video_resolution"
    },
    {
        "line": 260,
        "fullcodeline": "manifest_is_prepared = True"
    },
    {
        "line": 314,
        "fullcodeline": "properties = manifest[manifest_index(frame_id)]"
    },
    {
        "line": 323,
        "fullcodeline": "img_sizes.append(resolution)"
    },
    {
        "line": 352,
        "fullcodeline": "for data, size in zip(chunk_data, img_sizes)"
    },
    {
        "line": 345,
        "fullcodeline": "models.Image("
    },
    {
        "line": 317,
        "fullcodeline": "if not chunk_path.endswith(f\"{properties['name']}{properties['extension']}\"):"
    },
    {
        "line": 319,
        "fullcodeline": "if db_task.dimension == models.DimensionType.DIM_2D:"
    },
    {
        "line": 252,
        "fullcodeline": "manifest_path=db_data.get_manifest_path())"
    },
    {
        "line": 262,
        "fullcodeline": "manifest.remove()"
    },
    {
        "line": 268,
        "fullcodeline": "_update_status('{} Start prepare a valid manifest file.'.format(base_msg))"
    },
    {
        "line": 318,
        "fullcodeline": "raise Exception('Incorrect file mapping to manifest content')"
    },
    {
        "line": 320,
        "fullcodeline": "resolution = (properties['width'], properties['height'])"
    },
    {
        "line": 322,
        "fullcodeline": "resolution = extractor.get_image_size(frame_id)"
    },
    {
        "line": 347,
        "fullcodeline": "path=os.path.relpath(data[1], upload_dir),"
    },
    {
        "line": 263,
        "fullcodeline": "if isinstance(ex, AssertionError):"
    },
    {
        "line": 329,
        "fullcodeline": "for (path, frame), (w, h) in zip(chunk_paths, img_sizes)"
    },
    {
        "line": 326,
        "fullcodeline": "models.Image(data=db_data,"
    },
    {
        "line": 264,
        "fullcodeline": "base_msg = str(ex)"
    },
    {
        "line": 266,
        "fullcodeline": "base_msg = 'Invalid manifest file was upload.'"
    },
    {
        "line": 267,
        "fullcodeline": "slogger.glob.warning(str(ex))"
    },
    {
        "line": 327,
        "fullcodeline": "path=os.path.relpath(path, upload_dir),"
    }
]