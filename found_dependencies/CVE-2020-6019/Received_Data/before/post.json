[
    {
        "line": 11,
        "fullcodeline": "const UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;"
    },
    {
        "line": 23,
        "fullcodeline": "uint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );"
    },
    {
        "line": 55,
        "fullcodeline": "const uint8 *pIn = pPkt + sizeof(*hdr);"
    },
    {
        "line": 56,
        "fullcodeline": "const uint8 *pPktEnd = pPkt + cbPkt;"
    },
    {
        "line": 60,
        "fullcodeline": "CMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;"
    },
    {
        "line": 61,
        "fullcodeline": "uint32 cbStatsMsgIn = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "const void *pChunk = pIn;"
    },
    {
        "line": 92,
        "fullcodeline": "int cbChunk = pPktEnd - pIn;"
    },
    {
        "line": 96,
        "fullcodeline": "ctx.m_usecNow = usecNow;"
    },
    {
        "line": 97,
        "fullcodeline": "ctx.m_pTransport = this;"
    },
    {
        "line": 98,
        "fullcodeline": "ctx.m_pStatsIn = pMsgStatsIn;"
    },
    {
        "line": 103,
        "fullcodeline": "RecvValidUDPDataPacket( ctx );"
    },
    {
        "line": 106,
        "fullcodeline": "int usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?"
    },
    {
        "line": 4,
        "fullcodeline": "if ( cbPkt < sizeof(UDPDataMsgHdr) )"
    },
    {
        "line": 12,
        "fullcodeline": "if ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )"
    },
    {
        "line": 26,
        "fullcodeline": "switch ( ConnectionState() )"
    },
    {
        "line": 62,
        "fullcodeline": "if ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )"
    },
    {
        "line": 99,
        "fullcodeline": "if ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )"
    },
    {
        "line": 107,
        "fullcodeline": "if ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )"
    },
    {
        "line": 6,
        "fullcodeline": "ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );"
    },
    {
        "line": 16,
        "fullcodeline": "ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Incorrect connection ID\" );"
    },
    {
        "line": 31,
        "fullcodeline": "Assert( false );"
    },
    {
        "line": 37,
        "fullcodeline": "SendConnectionClosedOrNoConnection();"
    },
    {
        "line": 66,
        "fullcodeline": "pIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );"
    },
    {
        "line": 85,
        "fullcodeline": "pMsgStatsIn = &msgStats;"
    },
    {
        "line": 88,
        "fullcodeline": "pIn += cbStatsMsgIn;"
    },
    {
        "line": 112,
        "fullcodeline": "RecvStats( *pMsgStatsIn, usecNow );"
    },
    {
        "line": 17,
        "fullcodeline": "if ( BCheckGlobalSpamReplyRateLimit( usecNow ) )"
    },
    {
        "line": 67,
        "fullcodeline": "if ( pIn == NULL )"
    },
    {
        "line": 72,
        "fullcodeline": "if ( pIn + cbStatsMsgIn > pPktEnd )"
    },
    {
        "line": 78,
        "fullcodeline": "if ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )"
    },
    {
        "line": 19,
        "fullcodeline": "SendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );"
    },
    {
        "line": 69,
        "fullcodeline": "ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );"
    },
    {
        "line": 74,
        "fullcodeline": "ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );"
    },
    {
        "line": 80,
        "fullcodeline": "ReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );"
    }
]