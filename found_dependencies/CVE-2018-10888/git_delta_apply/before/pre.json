[
    {
        "line": 9,
        "fullcodeline": "const unsigned char *delta_end = delta + delta_len;"
    },
    {
        "line": 13,
        "fullcodeline": "*out = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "*out_len = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "GITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);"
    },
    {
        "line": 32,
        "fullcodeline": "res_dp = git__malloc(alloc_sz);"
    },
    {
        "line": 33,
        "fullcodeline": "GITERR_CHECK_ALLOC(res_dp);"
    },
    {
        "line": 35,
        "fullcodeline": "res_dp[res_sz] = '\\0';"
    },
    {
        "line": 36,
        "fullcodeline": "*out = res_dp;"
    },
    {
        "line": 21,
        "fullcodeline": "if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {"
    },
    {
        "line": 39,
        "fullcodeline": "while (delta < delta_end) {"
    },
    {
        "line": 90,
        "fullcodeline": "return -1;"
    },
    {
        "line": 22,
        "fullcodeline": "giterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");"
    },
    {
        "line": 26,
        "fullcodeline": "if (hdr_sz(&res_sz, &delta, delta_end) < 0) {"
    },
    {
        "line": 40,
        "fullcodeline": "unsigned char cmd = *delta++;"
    },
    {
        "line": 79,
        "fullcodeline": "if (delta != delta_end || res_sz)"
    },
    {
        "line": 23,
        "fullcodeline": "return -1;"
    },
    {
        "line": 28,
        "fullcodeline": "return -1;"
    },
    {
        "line": 41,
        "fullcodeline": "if (cmd & 0x80) {"
    },
    {
        "line": 43,
        "fullcodeline": "size_t off = 0, len = 0;"
    },
    {
        "line": 57,
        "fullcodeline": "memcpy(res_dp, base + off, len);"
    },
    {
        "line": 58,
        "fullcodeline": "res_dp += len;"
    },
    {
        "line": 59,
        "fullcodeline": "res_sz -= len;"
    },
    {
        "line": 45,
        "fullcodeline": "if (cmd & 0x01) off = *delta++;"
    },
    {
        "line": 46,
        "fullcodeline": "if (cmd & 0x02) off |= *delta++ << 8UL;"
    },
    {
        "line": 47,
        "fullcodeline": "if (cmd & 0x04) off |= *delta++ << 16UL;"
    },
    {
        "line": 48,
        "fullcodeline": "if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);"
    },
    {
        "line": 50,
        "fullcodeline": "if (cmd & 0x10) len = *delta++;"
    },
    {
        "line": 51,
        "fullcodeline": "if (cmd & 0x20) len |= *delta++ << 8UL;"
    },
    {
        "line": 53,
        "fullcodeline": "if (!len)       len = 0x10000;"
    },
    {
        "line": 52,
        "fullcodeline": "if (cmd & 0x40) len |= *delta++ << 16UL;"
    },
    {
        "line": 55,
        "fullcodeline": "if (base_len < off + len || res_sz < len)"
    },
    {
        "line": 68,
        "fullcodeline": "memcpy(res_dp, delta, cmd);"
    },
    {
        "line": 69,
        "fullcodeline": "delta += cmd;"
    },
    {
        "line": 70,
        "fullcodeline": "res_dp += cmd;"
    },
    {
        "line": 71,
        "fullcodeline": "res_sz -= cmd;"
    },
    {
        "line": 66,
        "fullcodeline": "if (delta_end - delta < cmd || res_sz < cmd)"
    }
]