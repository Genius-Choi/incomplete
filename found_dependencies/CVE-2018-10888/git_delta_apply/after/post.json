[
    {
        "line": 9,
        "fullcodeline": "const unsigned char *delta_end = delta + delta_len;"
    },
    {
        "line": 13,
        "fullcodeline": "*out = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "*out_len = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "GITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);"
    },
    {
        "line": 32,
        "fullcodeline": "res_dp = git__malloc(alloc_sz);"
    },
    {
        "line": 33,
        "fullcodeline": "GITERR_CHECK_ALLOC(res_dp);"
    },
    {
        "line": 35,
        "fullcodeline": "res_dp[res_sz] = '\\0';"
    },
    {
        "line": 36,
        "fullcodeline": "*out = res_dp;"
    },
    {
        "line": 37,
        "fullcodeline": "*out_len = res_sz;"
    },
    {
        "line": 86,
        "fullcodeline": "git__free(*out);"
    },
    {
        "line": 88,
        "fullcodeline": "*out = NULL;"
    },
    {
        "line": 89,
        "fullcodeline": "*out_len = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "giterr_set(GITERR_INVALID, \"failed to apply delta\");"
    },
    {
        "line": 21,
        "fullcodeline": "if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (hdr_sz(&res_sz, &delta, delta_end) < 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "while (delta < delta_end) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (delta != delta_end || res_sz)"
    },
    {
        "line": 92,
        "fullcodeline": "return -1;"
    },
    {
        "line": 22,
        "fullcodeline": "giterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");"
    },
    {
        "line": 27,
        "fullcodeline": "giterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");"
    },
    {
        "line": 23,
        "fullcodeline": "return -1;"
    },
    {
        "line": 28,
        "fullcodeline": "return -1;"
    },
    {
        "line": 41,
        "fullcodeline": "if (cmd & 0x80) {"
    },
    {
        "line": 40,
        "fullcodeline": "unsigned char cmd = *delta++;"
    },
    {
        "line": 43,
        "fullcodeline": "size_t off = 0, len = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "memcpy(res_dp, base + off, len);"
    },
    {
        "line": 60,
        "fullcodeline": "res_dp += len;"
    },
    {
        "line": 61,
        "fullcodeline": "res_sz -= len;"
    },
    {
        "line": 46,
        "fullcodeline": "if (cmd & 0x01) ADD_DELTA(off, 0UL);"
    },
    {
        "line": 47,
        "fullcodeline": "if (cmd & 0x02) ADD_DELTA(off, 8UL);"
    },
    {
        "line": 48,
        "fullcodeline": "if (cmd & 0x04) ADD_DELTA(off, 16UL);"
    },
    {
        "line": 49,
        "fullcodeline": "if (cmd & 0x08) ADD_DELTA(off, 24UL);"
    },
    {
        "line": 51,
        "fullcodeline": "if (cmd & 0x10) ADD_DELTA(len, 0UL);"
    },
    {
        "line": 52,
        "fullcodeline": "if (cmd & 0x20) ADD_DELTA(len, 8UL);"
    },
    {
        "line": 53,
        "fullcodeline": "if (cmd & 0x40) ADD_DELTA(len, 16UL);"
    },
    {
        "line": 54,
        "fullcodeline": "if (!len)       len = 0x10000;"
    },
    {
        "line": 57,
        "fullcodeline": "if (base_len < off + len || res_sz < len)"
    },
    {
        "line": 70,
        "fullcodeline": "memcpy(res_dp, delta, cmd);"
    },
    {
        "line": 71,
        "fullcodeline": "delta += cmd;"
    },
    {
        "line": 72,
        "fullcodeline": "res_dp += cmd;"
    },
    {
        "line": 73,
        "fullcodeline": "res_sz -= cmd;"
    },
    {
        "line": 68,
        "fullcodeline": "if (delta_end - delta < cmd || res_sz < cmd)"
    }
]