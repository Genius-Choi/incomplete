[
    {
        "line": 2,
        "fullcodeline": "int ctrl = 0;"
    },
    {
        "line": 3,
        "fullcodeline": "const char *current_secret = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);"
    },
    {
        "line": 7,
        "fullcodeline": "memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);"
    },
    {
        "line": 8,
        "fullcodeline": "memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);"
    },
    {
        "line": 9,
        "fullcodeline": "memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);"
    },
    {
        "line": 10,
        "fullcodeline": "tac_srv_no = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "tac_service[0] = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "tac_protocol[0] = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "tac_prompt[0] = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "tac_login[0] = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "for (ctrl = 0; argc-- > 0; ++argv) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (ctrl & PAM_TAC_DEBUG) {"
    },
    {
        "line": 127,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);"
    },
    {
        "line": 134,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);"
    },
    {
        "line": 135,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);"
    },
    {
        "line": 136,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);"
    },
    {
        "line": 137,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);"
    },
    {
        "line": 18,
        "fullcodeline": "if (!strcmp(*argv, \"debug\")) { /* all */"
    },
    {
        "line": 129,
        "fullcodeline": "for (n = 0; n < tac_srv_no; n++) {"
    },
    {
        "line": 19,
        "fullcodeline": "ctrl |= PAM_TAC_DEBUG;"
    },
    {
        "line": 130,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,"
    },
    {
        "line": 20,
        "fullcodeline": "} else if (!strcmp(*argv, \"use_first_pass\")) {"
    },
    {
        "line": 21,
        "fullcodeline": "ctrl |= PAM_TAC_USE_FIRST_PASS;"
    },
    {
        "line": 22,
        "fullcodeline": "} else if (!strcmp(*argv, \"try_first_pass\")) {"
    },
    {
        "line": 23,
        "fullcodeline": "ctrl |= PAM_TAC_TRY_FIRST_PASS;"
    },
    {
        "line": 24,
        "fullcodeline": "} else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */"
    },
    {
        "line": 25,
        "fullcodeline": "xstrcpy(tac_service, *argv + 8, sizeof(tac_service));"
    },
    {
        "line": 26,
        "fullcodeline": "} else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */"
    },
    {
        "line": 27,
        "fullcodeline": "xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));"
    },
    {
        "line": 28,
        "fullcodeline": "} else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */"
    },
    {
        "line": 29,
        "fullcodeline": "xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));"
    },
    {
        "line": 32,
        "fullcodeline": "for (chr = 0; chr < strlen(tac_prompt); chr++) {"
    },
    {
        "line": 37,
        "fullcodeline": "} else if (!strncmp(*argv, \"login=\", 6)) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (tac_prompt[chr] == '_') {"
    },
    {
        "line": 38,
        "fullcodeline": "xstrcpy(tac_login, *argv + 6, sizeof(tac_login));"
    },
    {
        "line": 34,
        "fullcodeline": "tac_prompt[chr] = ' ';"
    },
    {
        "line": 39,
        "fullcodeline": "} else if (!strcmp(*argv, \"acct_all\")) {"
    },
    {
        "line": 40,
        "fullcodeline": "ctrl |= PAM_TAC_ACCT;"
    },
    {
        "line": 41,
        "fullcodeline": "} else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */"
    },
    {
        "line": 42,
        "fullcodeline": "if (tac_srv_no < TAC_PLUS_MAXSERVERS) {"
    },
    {
        "line": 45,
        "fullcodeline": "char *close_bracket, *server_name, *port, server_buf[256];"
    },
    {
        "line": 47,
        "fullcodeline": "memset(&hints, 0, sizeof hints);"
    },
    {
        "line": 48,
        "fullcodeline": "memset(&server_buf, 0, sizeof(server_buf));"
    },
    {
        "line": 49,
        "fullcodeline": "hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */"
    },
    {
        "line": 50,
        "fullcodeline": "hints.ai_socktype = SOCK_STREAM;"
    },
    {
        "line": 56,
        "fullcodeline": "strcpy(server_buf, *argv + 7);"
    },
    {
        "line": 74,
        "fullcodeline": "_pam_log (LOG_DEBUG,"
    },
    {
        "line": 95,
        "fullcodeline": "} else if (!strncmp(*argv, \"secret=\", 7)) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (strlen(*argv + 7) >= sizeof(server_buf)) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (*server_buf == '[' &&"
    },
    {
        "line": 70,
        "fullcodeline": "if (port != NULL) {"
    },
    {
        "line": 77,
        "fullcodeline": "if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {"
    },
    {
        "line": 92,
        "fullcodeline": "_pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\","
    },
    {
        "line": 96,
        "fullcodeline": "current_secret = *argv + 7;     /* points right into argv (which is const) */"
    },
    {
        "line": 53,
        "fullcodeline": "_pam_log(LOG_ERR, \"server address too long, sorry\");"
    },
    {
        "line": 59,
        "fullcodeline": "(close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */"
    },
    {
        "line": 60,
        "fullcodeline": "server_name = server_buf + 1;"
    },
    {
        "line": 61,
        "fullcodeline": "_pam_log (LOG_ERR,"
    },
    {
        "line": 64,
        "fullcodeline": "port = strchr(close_bracket, ':');"
    },
    {
        "line": 65,
        "fullcodeline": "*close_bracket = '\\0';"
    },
    {
        "line": 71,
        "fullcodeline": "*port = '\\0';"
    },
    {
        "line": 72,
        "fullcodeline": "port++;"
    },
    {
        "line": 84,
        "fullcodeline": "_pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);"
    },
    {
        "line": 85,
        "fullcodeline": "freeaddrinfo (servers);"
    },
    {
        "line": 99,
        "fullcodeline": "if (tac_srv_no == 0) {"
    },
    {
        "line": 67,
        "fullcodeline": "server_name = server_buf;"
    },
    {
        "line": 68,
        "fullcodeline": "port = strchr(server_buf, ':');"
    },
    {
        "line": 79,
        "fullcodeline": "server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {"
    },
    {
        "line": 87,
        "fullcodeline": "_pam_log(LOG_ERR,"
    },
    {
        "line": 100,
        "fullcodeline": "_pam_log(LOG_ERR, \"secret set but no servers configured yet\");"
    },
    {
        "line": 105,
        "fullcodeline": "} else if (!strncmp(*argv, \"timeout=\", 8)) {"
    },
    {
        "line": 78,
        "fullcodeline": "for (server = servers;"
    },
    {
        "line": 80,
        "fullcodeline": "set_tac_srv_addr(tac_srv_no, server);"
    },
    {
        "line": 81,
        "fullcodeline": "set_tac_srv_key(tac_srv_no, current_secret);"
    },
    {
        "line": 82,
        "fullcodeline": "tac_srv_no++;"
    },
    {
        "line": 89,
        "fullcodeline": "server_name, gai_strerror(rv));"
    },
    {
        "line": 103,
        "fullcodeline": "set_tac_srv_key(tac_srv_no - 1, current_secret);"
    },
    {
        "line": 111,
        "fullcodeline": "tac_timeout = atoi(*argv + 8);"
    },
    {
        "line": 113,
        "fullcodeline": "if (tac_timeout == LONG_MAX) {"
    },
    {
        "line": 120,
        "fullcodeline": "_pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);"
    },
    {
        "line": 114,
        "fullcodeline": "_pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);"
    },
    {
        "line": 115,
        "fullcodeline": "tac_timeout = 0;"
    },
    {
        "line": 117,
        "fullcodeline": "tac_readtimeout_enable = 1;"
    }
]