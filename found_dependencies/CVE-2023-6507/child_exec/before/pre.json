[
    {
        "line": 19,
        "fullcodeline": "int i, saved_errno, reached_preexec = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "const char* err_msg = \"\";"
    },
    {
        "line": 23,
        "fullcodeline": "char hex_errno[sizeof(saved_errno)*2+1];"
    },
    {
        "line": 35,
        "fullcodeline": "POSIX_CALL(close(errpipe_read));"
    },
    {
        "line": 127,
        "fullcodeline": "reached_preexec = 1;"
    },
    {
        "line": 152,
        "fullcodeline": "saved_errno = 0;"
    },
    {
        "line": 169,
        "fullcodeline": "saved_errno = errno;"
    },
    {
        "line": 25,
        "fullcodeline": "if (make_inheritable(fds_to_keep, fds_to_keep_len, errpipe_write) < 0)"
    },
    {
        "line": 29,
        "fullcodeline": "if (p2cwrite != -1)"
    },
    {
        "line": 31,
        "fullcodeline": "if (c2pread != -1)"
    },
    {
        "line": 33,
        "fullcodeline": "if (errread != -1)"
    },
    {
        "line": 39,
        "fullcodeline": "if (c2pwrite == 0) {"
    },
    {
        "line": 46,
        "fullcodeline": "while (errwrite == 0 || errwrite == 1) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (p2cread == 0) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (c2pwrite == 1) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (errwrite == 2) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (child_umask >= 0)"
    },
    {
        "line": 128,
        "fullcodeline": "if (preexec_fn != Py_None && preexec_fn_args_tuple) {"
    },
    {
        "line": 153,
        "fullcodeline": "for (i = 0; exec_array[i] != NULL; ++i) {"
    },
    {
        "line": 30,
        "fullcodeline": "POSIX_CALL(close(p2cwrite));"
    },
    {
        "line": 32,
        "fullcodeline": "POSIX_CALL(close(c2pread));"
    },
    {
        "line": 34,
        "fullcodeline": "POSIX_CALL(close(errread));"
    },
    {
        "line": 40,
        "fullcodeline": "POSIX_CALL(c2pwrite = dup(c2pwrite));"
    },
    {
        "line": 47,
        "fullcodeline": "POSIX_CALL(errwrite = dup(errwrite));"
    },
    {
        "line": 82,
        "fullcodeline": "POSIX_CALL(chdir(cwd));"
    },
    {
        "line": 85,
        "fullcodeline": "umask(child_umask);  /* umask() always succeeds. */"
    },
    {
        "line": 88,
        "fullcodeline": "_Py_RestoreSignals();"
    },
    {
        "line": 130,
        "fullcodeline": "result = PyObject_Call(preexec_fn, preexec_fn_args_tuple, NULL);"
    },
    {
        "line": 147,
        "fullcodeline": "_close_open_fds(3, fds_to_keep, fds_to_keep_len);"
    },
    {
        "line": 154,
        "fullcodeline": "const char *executable = exec_array[i];"
    },
    {
        "line": 166,
        "fullcodeline": "errno = saved_errno;"
    },
    {
        "line": 177,
        "fullcodeline": "_Py_write_noraise(errpipe_write, \"OSError:\", 8);"
    },
    {
        "line": 178,
        "fullcodeline": "cur = hex_errno + sizeof(hex_errno);"
    },
    {
        "line": 183,
        "fullcodeline": "_Py_write_noraise(errpipe_write, cur, hex_errno + sizeof(hex_errno) - cur);"
    },
    {
        "line": 184,
        "fullcodeline": "_Py_write_noraise(errpipe_write, \":\", 1);"
    },
    {
        "line": 42,
        "fullcodeline": "if (_Py_set_inheritable_async_safe(c2pwrite, 0, NULL) < 0) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (_Py_set_inheritable_async_safe(errwrite, 0, NULL) < 0) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (_Py_set_inheritable_async_safe(p2cread, 1, NULL) < 0)"
    },
    {
        "line": 65,
        "fullcodeline": "if (_Py_set_inheritable_async_safe(c2pwrite, 1, NULL) < 0)"
    },
    {
        "line": 72,
        "fullcodeline": "if (_Py_set_inheritable_async_safe(errwrite, 1, NULL) < 0)"
    },
    {
        "line": 131,
        "fullcodeline": "if (result == NULL) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (errno != ENOENT && errno != ENOTDIR && saved_errno == 0) {"
    },
    {
        "line": 179,
        "fullcodeline": "while (saved_errno != 0 && cur != hex_errno) {"
    },
    {
        "line": 185,
        "fullcodeline": "if (!reached_preexec) {"
    },
    {
        "line": 192,
        "fullcodeline": "_Py_write_noraise(errpipe_write, \"SubprocessError:0:\", 18);"
    },
    {
        "line": 61,
        "fullcodeline": "else if (p2cread != -1)"
    },
    {
        "line": 68,
        "fullcodeline": "else if (c2pwrite != -1)"
    },
    {
        "line": 75,
        "fullcodeline": "else if (errwrite != -1)"
    },
    {
        "line": 137,
        "fullcodeline": "err_msg = \"Exception occurred in preexec_fn.\";"
    },
    {
        "line": 138,
        "fullcodeline": "errno = 0;  /* We don't want to report an OSError. */"
    },
    {
        "line": 156,
        "fullcodeline": "execve(executable, argv, envp);"
    },
    {
        "line": 161,
        "fullcodeline": "saved_errno = errno;"
    },
    {
        "line": 180,
        "fullcodeline": "*--cur = Py_hexdigits[saved_errno % 16];"
    },
    {
        "line": 181,
        "fullcodeline": "saved_errno /= 16;"
    },
    {
        "line": 187,
        "fullcodeline": "_Py_write_noraise(errpipe_write, \"noexec\", 6);"
    },
    {
        "line": 193,
        "fullcodeline": "_Py_write_noraise(errpipe_write, err_msg, strlen(err_msg));"
    },
    {
        "line": 62,
        "fullcodeline": "POSIX_CALL(dup2(p2cread, 0));  /* stdin */"
    },
    {
        "line": 69,
        "fullcodeline": "POSIX_CALL(dup2(c2pwrite, 1));  /* stdout */"
    },
    {
        "line": 76,
        "fullcodeline": "POSIX_CALL(dup2(errwrite, 2));  /* stderr */"
    },
    {
        "line": 158,
        "fullcodeline": "execv(executable, argv);"
    }
]