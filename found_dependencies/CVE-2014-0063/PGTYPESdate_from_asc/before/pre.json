[
    {
        "line": 6,
        "fullcodeline": "*tm = &tt;"
    },
    {
        "line": 9,
        "fullcodeline": "char\t   *field[MAXDATEFIELDS];"
    },
    {
        "line": 10,
        "fullcodeline": "int\t\t\tftype[MAXDATEFIELDS];"
    },
    {
        "line": 11,
        "fullcodeline": "char\t\tlowstr[MAXDATELEN + 1];"
    },
    {
        "line": 13,
        "fullcodeline": "char\t  **ptr = (endptr != NULL) ? endptr : &realptr;"
    },
    {
        "line": 15,
        "fullcodeline": "bool\t\tEuroDates = FALSE;"
    },
    {
        "line": 17,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "dDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));"
    },
    {
        "line": 18,
        "fullcodeline": "if (strlen(str) >= sizeof(lowstr))"
    },
    {
        "line": 20,
        "fullcodeline": "errno = PGTYPES_DATE_BAD_DATE;"
    },
    {
        "line": 24,
        "fullcodeline": "if (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||"
    },
    {
        "line": 25,
        "fullcodeline": "DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)"
    },
    {
        "line": 37,
        "fullcodeline": "if (GetEpochTime(tm) < 0)"
    }
]