[
    {
        "line": 6,
        "fullcodeline": "DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );"
    },
    {
        "line": 7,
        "fullcodeline": "DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );"
    },
    {
        "line": 10,
        "fullcodeline": "DIP__DECLARE_JPEG_EXIT( \"Error writing JPEG file\" );"
    },
    {
        "line": 11,
        "fullcodeline": "JpegOutput jpeg( filename, setjmp_buffer );"
    },
    {
        "line": 14,
        "fullcodeline": "int nchan = static_cast< int >( image.TensorElements() );"
    },
    {
        "line": 15,
        "fullcodeline": "jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));"
    },
    {
        "line": 16,
        "fullcodeline": "jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));"
    },
    {
        "line": 17,
        "fullcodeline": "jpeg.cinfo().input_components = nchan;"
    },
    {
        "line": 18,
        "fullcodeline": "jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;"
    },
    {
        "line": 19,
        "fullcodeline": "jpeg_set_defaults( jpeg.cinfoptr() );"
    },
    {
        "line": 20,
        "fullcodeline": "jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( clamp< dip::uint >( jpegLevel, 1, 100 )), FALSE );"
    },
    {
        "line": 21,
        "fullcodeline": "jpeg.cinfo().density_unit = 2; // dots per cm"
    },
    {
        "line": 22,
        "fullcodeline": "jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); // let's assume it's meter"
    },
    {
        "line": 23,
        "fullcodeline": "jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );"
    },
    {
        "line": 26,
        "fullcodeline": "Image image_u8 = image.QuickCopy();"
    },
    {
        "line": 27,
        "fullcodeline": "image_u8.Convert( DT_UINT8 );"
    },
    {
        "line": 30,
        "fullcodeline": "jpeg_start_compress( jpeg.cinfoptr(), TRUE );"
    },
    {
        "line": 31,
        "fullcodeline": "std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));"
    },
    {
        "line": 32,
        "fullcodeline": "dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );"
    },
    {
        "line": 33,
        "fullcodeline": "auto stride = image_u8.Strides();"
    },
    {
        "line": 34,
        "fullcodeline": "auto tStride = image_u8.TensorStride();"
    },
    {
        "line": 49,
        "fullcodeline": "jpeg_finish_compress( jpeg.cinfoptr());"
    },
    {
        "line": 35,
        "fullcodeline": "for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {"
    },
    {
        "line": 36,
        "fullcodeline": "JSAMPLE* outdata = buffer.data();"
    },
    {
        "line": 37,
        "fullcodeline": "dip::uint8* indata = imagedata;"
    },
    {
        "line": 45,
        "fullcodeline": "outdata = buffer.data();"
    },
    {
        "line": 46,
        "fullcodeline": "jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );"
    },
    {
        "line": 47,
        "fullcodeline": "imagedata += stride[ 1 ];"
    },
    {
        "line": 38,
        "fullcodeline": "for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {"
    },
    {
        "line": 43,
        "fullcodeline": "indata += stride[ 0 ];"
    },
    {
        "line": 39,
        "fullcodeline": "for( int kk = 0; kk < nchan; ++kk ) {"
    },
    {
        "line": 40,
        "fullcodeline": "*outdata = *( indata + kk * tStride );"
    },
    {
        "line": 41,
        "fullcodeline": "++outdata;"
    }
]