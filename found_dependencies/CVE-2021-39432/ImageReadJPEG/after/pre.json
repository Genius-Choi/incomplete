[
    {
        "line": 6,
        "fullcodeline": "DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );"
    },
    {
        "line": 7,
        "fullcodeline": "JpegInput jpeg( filename, setjmp_buffer );"
    },
    {
        "line": 10,
        "fullcodeline": "FileInformation info = GetJPEGInfo( jpeg );"
    },
    {
        "line": 13,
        "fullcodeline": "int nchan = jpeg.cinfo().num_components;"
    },
    {
        "line": 14,
        "fullcodeline": "jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;"
    },
    {
        "line": 15,
        "fullcodeline": "out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );"
    },
    {
        "line": 16,
        "fullcodeline": "out.SetPixelSize( info.pixelSize );"
    },
    {
        "line": 17,
        "fullcodeline": "out.SetColorSpace( info.colorSpace );"
    },
    {
        "line": 20,
        "fullcodeline": "jpeg_start_decompress( jpeg.cinfoptr() );"
    },
    {
        "line": 21,
        "fullcodeline": "std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); // casting to unsigned rather than dip::uint to shut up GCC warning."
    },
    {
        "line": 22,
        "fullcodeline": "dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );"
    },
    {
        "line": 23,
        "fullcodeline": "auto stride = out.Strides();"
    },
    {
        "line": 24,
        "fullcodeline": "auto tStride = out.TensorStride();"
    },
    {
        "line": 46,
        "fullcodeline": "jpeg_finish_decompress( jpeg.cinfoptr() );"
    },
    {
        "line": 25,
        "fullcodeline": "for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {"
    },
    {
        "line": 26,
        "fullcodeline": "JSAMPLE* indata = buffer.data();"
    },
    {
        "line": 27,
        "fullcodeline": "jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );"
    },
    {
        "line": 28,
        "fullcodeline": "dip::uint8* outdata = imagedata;"
    },
    {
        "line": 44,
        "fullcodeline": "imagedata += stride[ 1 ];"
    },
    {
        "line": 29,
        "fullcodeline": "if( nchan > 1 ) {"
    },
    {
        "line": 30,
        "fullcodeline": "for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {"
    },
    {
        "line": 35,
        "fullcodeline": "outdata += stride[ 0 ];"
    },
    {
        "line": 38,
        "fullcodeline": "for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {"
    },
    {
        "line": 31,
        "fullcodeline": "for( int kk = 0; kk < nchan; ++kk ) {"
    },
    {
        "line": 39,
        "fullcodeline": "*outdata = *indata;"
    },
    {
        "line": 40,
        "fullcodeline": "++indata;"
    },
    {
        "line": 41,
        "fullcodeline": "outdata += stride[ 0 ];"
    },
    {
        "line": 32,
        "fullcodeline": "*( outdata + kk * tStride ) = *indata;"
    },
    {
        "line": 33,
        "fullcodeline": "++indata;"
    }
]