[
    {
        "line": 2,
        "fullcodeline": "big_relocs = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "Packer::handleStub(fi, fo, adam_offset);"
    },
    {
        "line": 6,
        "fullcodeline": "const unsigned usize = ih.imagesize;"
    },
    {
        "line": 7,
        "fullcodeline": "const unsigned rsize = ih.relocsize;"
    },
    {
        "line": 9,
        "fullcodeline": "ibuf.alloc(usize + rsize + 128);"
    },
    {
        "line": 10,
        "fullcodeline": "obuf.allocForCompression(usize + rsize + 128);"
    },
    {
        "line": 13,
        "fullcodeline": "mb_wrkmem.alloc(rsize + EXTRA_INFO); // relocations"
    },
    {
        "line": 14,
        "fullcodeline": "SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);"
    },
    {
        "line": 16,
        "fullcodeline": "fi->seek(adam_offset + sizeof(ih), SEEK_SET);"
    },
    {
        "line": 17,
        "fullcodeline": "fi->readx(ibuf, usize);"
    },
    {
        "line": 18,
        "fullcodeline": "fi->readx(wrkmem + 4, rsize);"
    },
    {
        "line": 19,
        "fullcodeline": "const unsigned overlay = file_size - fi->tell();"
    },
    {
        "line": 26,
        "fullcodeline": "checkOverlay(overlay);"
    },
    {
        "line": 28,
        "fullcodeline": "unsigned relocsize = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "wrkmem[relocsize++] = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "set_le32(wrkmem + relocsize, ih.entry); // save original entry point"
    },
    {
        "line": 39,
        "fullcodeline": "relocsize += 4;"
    },
    {
        "line": 40,
        "fullcodeline": "set_le32(wrkmem + relocsize, relocsize + 4);"
    },
    {
        "line": 41,
        "fullcodeline": "relocsize += 4;"
    },
    {
        "line": 42,
        "fullcodeline": "memcpy(ibuf + usize, wrkmem, relocsize);"
    },
    {
        "line": 45,
        "fullcodeline": "ph.u_len = usize + relocsize;"
    },
    {
        "line": 47,
        "fullcodeline": "Filter ft(ph.level);"
    },
    {
        "line": 48,
        "fullcodeline": "ft.buf_len = usize;"
    },
    {
        "line": 51,
        "fullcodeline": "cconf.reset();"
    },
    {
        "line": 53,
        "fullcodeline": "cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack"
    },
    {
        "line": 54,
        "fullcodeline": "compressWithFilters(&ft, 512, &cconf);"
    },
    {
        "line": 56,
        "fullcodeline": "const unsigned lsize = getLoaderSize();"
    },
    {
        "line": 57,
        "fullcodeline": "const unsigned s_point = getLoaderSection(\"TMTMAIN1\");"
    },
    {
        "line": 58,
        "fullcodeline": "int e_len = getLoaderSectionStart(\"TMTCUTPO\");"
    },
    {
        "line": 59,
        "fullcodeline": "const unsigned d_len = lsize - e_len;"
    },
    {
        "line": 60,
        "fullcodeline": "assert(e_len > 0 && s_point > 0);"
    },
    {
        "line": 63,
        "fullcodeline": "linker->defineSymbol(\"original_entry\", ih.entry);"
    },
    {
        "line": 64,
        "fullcodeline": "defineDecompressorSymbols();"
    },
    {
        "line": 65,
        "fullcodeline": "defineFilterSymbols(&ft);"
    },
    {
        "line": 67,
        "fullcodeline": "linker->defineSymbol(\"bytes_to_copy\", ph.c_len + d_len);"
    },
    {
        "line": 68,
        "fullcodeline": "linker->defineSymbol(\"copy_dest\", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1));"
    },
    {
        "line": 69,
        "fullcodeline": "linker->defineSymbol(\"copy_source\", ph.c_len + lsize - 1);"
    },
    {
        "line": 70,
        "fullcodeline": "linker->defineSymbol(\"TMTCUTPO\", ph.u_len + ph.overlap_overhead);"
    },
    {
        "line": 71,
        "fullcodeline": "relocateLoader();"
    },
    {
        "line": 73,
        "fullcodeline": "MemBuffer loader(lsize);"
    },
    {
        "line": 74,
        "fullcodeline": "memcpy(loader, getLoader(), lsize);"
    },
    {
        "line": 75,
        "fullcodeline": "patchPackHeader(loader, e_len);"
    },
    {
        "line": 77,
        "fullcodeline": "memcpy(&oh, &ih, sizeof(oh));"
    },
    {
        "line": 78,
        "fullcodeline": "oh.imagesize = ph.c_len + lsize; // new size"
    },
    {
        "line": 79,
        "fullcodeline": "oh.entry = s_point;              // new entry point"
    },
    {
        "line": 80,
        "fullcodeline": "oh.relocsize = 4;"
    },
    {
        "line": 83,
        "fullcodeline": "fo->write(&oh, sizeof(oh));"
    },
    {
        "line": 84,
        "fullcodeline": "fo->write(loader, e_len);"
    },
    {
        "line": 85,
        "fullcodeline": "fo->write(obuf, ph.c_len);"
    },
    {
        "line": 86,
        "fullcodeline": "fo->write(loader + lsize - d_len, d_len); // decompressor"
    },
    {
        "line": 87,
        "fullcodeline": "char rel_entry[4];"
    },
    {
        "line": 88,
        "fullcodeline": "set_le32(rel_entry, 5 + s_point);"
    },
    {
        "line": 89,
        "fullcodeline": "fo->write(rel_entry, sizeof(rel_entry));"
    },
    {
        "line": 92,
        "fullcodeline": "verifyOverlappingDecompression();"
    },
    {
        "line": 95,
        "fullcodeline": "copyOverlay(fo, overlay, obuf);"
    },
    {
        "line": 21,
        "fullcodeline": "if (find_le32(ibuf, 128, get_le32(\"UPX \")) >= 0)"
    },
    {
        "line": 23,
        "fullcodeline": "if (rsize == 0)"
    },
    {
        "line": 33,
        "fullcodeline": "relocsize ="
    },
    {
        "line": 98,
        "fullcodeline": "if (!checkFinalCompressionRatio(fo))"
    },
    {
        "line": 22,
        "fullcodeline": "throwAlreadyPacked();"
    },
    {
        "line": 24,
        "fullcodeline": "throwCantPack(\"file is already compressed with another packer\");"
    },
    {
        "line": 31,
        "fullcodeline": "for (unsigned ic = 4; ic <= rsize; ic += 4)"
    },
    {
        "line": 32,
        "fullcodeline": "set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4);"
    },
    {
        "line": 34,
        "fullcodeline": "optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs);"
    },
    {
        "line": 99,
        "fullcodeline": "throwNotCompressible();"
    }
]