[
    {
        "line": 19,
        "fullcodeline": "pc->last_index= pc->index;"
    },
    {
        "line": 35,
        "fullcodeline": "*buf_size="
    },
    {
        "line": 10,
        "fullcodeline": "for(; pc->overread>0; pc->overread--){"
    },
    {
        "line": 15,
        "fullcodeline": "if(!*buf_size && next == END_NOT_FOUND){"
    },
    {
        "line": 22,
        "fullcodeline": "if(next == END_NOT_FOUND){"
    },
    {
        "line": 36,
        "fullcodeline": "pc->overread_index= pc->index + next;"
    },
    {
        "line": 55,
        "fullcodeline": "for(;next < 0; next++){"
    },
    {
        "line": 4,
        "fullcodeline": "av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\","
    },
    {
        "line": 6,
        "fullcodeline": "av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);"
    },
    {
        "line": 16,
        "fullcodeline": "next= 0;"
    },
    {
        "line": 23,
        "fullcodeline": "void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);"
    },
    {
        "line": 29,
        "fullcodeline": "pc->buffer = new_buffer;"
    },
    {
        "line": 30,
        "fullcodeline": "memcpy(&pc->buffer[pc->index], *buf, *buf_size);"
    },
    {
        "line": 31,
        "fullcodeline": "pc->index += *buf_size;"
    },
    {
        "line": 40,
        "fullcodeline": "void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);"
    },
    {
        "line": 46,
        "fullcodeline": "pc->buffer = new_buffer;"
    },
    {
        "line": 50,
        "fullcodeline": "pc->index = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "*buf= pc->buffer;"
    },
    {
        "line": 56,
        "fullcodeline": "pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];"
    },
    {
        "line": 57,
        "fullcodeline": "pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];"
    },
    {
        "line": 58,
        "fullcodeline": "pc->overread++;"
    },
    {
        "line": 62,
        "fullcodeline": "av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\","
    },
    {
        "line": 64,
        "fullcodeline": "av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);"
    },
    {
        "line": 25,
        "fullcodeline": "if(!new_buffer) {"
    },
    {
        "line": 32,
        "fullcodeline": "return -1;"
    },
    {
        "line": 41,
        "fullcodeline": "if(!new_buffer) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (next > -FF_INPUT_BUFFER_PADDING_SIZE)"
    },
    {
        "line": 11,
        "fullcodeline": "pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];"
    },
    {
        "line": 26,
        "fullcodeline": "pc->index = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "pc->overread_index ="
    },
    {
        "line": 48,
        "fullcodeline": "memcpy(&pc->buffer[pc->index], *buf,"
    },
    {
        "line": 27,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 43,
        "fullcodeline": "pc->index = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 49,
        "fullcodeline": "next + FF_INPUT_BUFFER_PADDING_SIZE);"
    }
]