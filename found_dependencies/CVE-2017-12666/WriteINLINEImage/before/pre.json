[
    {
        "line": 6,
        "fullcodeline": "message[MagickPathExtent];"
    },
    {
        "line": 30,
        "fullcodeline": "assert(image_info != (const ImageInfo *) NULL);"
    },
    {
        "line": 31,
        "fullcodeline": "assert(image_info->signature == MagickCoreSignature);"
    },
    {
        "line": 32,
        "fullcodeline": "assert(image != (Image *) NULL);"
    },
    {
        "line": 33,
        "fullcodeline": "assert(image->signature == MagickCoreSignature);"
    },
    {
        "line": 36,
        "fullcodeline": "write_info=CloneImageInfo(image_info);"
    },
    {
        "line": 37,
        "fullcodeline": "(void) SetImageInfo(write_info,1,exception);"
    },
    {
        "line": 40,
        "fullcodeline": "magick_info=GetMagickInfo(write_info->magick,exception);"
    },
    {
        "line": 44,
        "fullcodeline": "(void) CopyMagickString(image->filename,write_info->filename,"
    },
    {
        "line": 46,
        "fullcodeline": "blob_length=2048;"
    },
    {
        "line": 47,
        "fullcodeline": "write_image=CloneImage(image,0,0,MagickTrue,exception);"
    },
    {
        "line": 53,
        "fullcodeline": "blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,"
    },
    {
        "line": 59,
        "fullcodeline": "encode_length=0;"
    },
    {
        "line": 60,
        "fullcodeline": "base64=Base64Encode(blob,blob_length,&encode_length);"
    },
    {
        "line": 67,
        "fullcodeline": "status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);"
    },
    {
        "line": 34,
        "fullcodeline": "if (image->debug != MagickFalse)"
    },
    {
        "line": 38,
        "fullcodeline": "if (LocaleCompare(write_info->magick,\"INLINE\") == 0)"
    },
    {
        "line": 41,
        "fullcodeline": "if ((magick_info == (const MagickInfo *) NULL) ||"
    },
    {
        "line": 48,
        "fullcodeline": "if (write_image == (Image *) NULL)"
    },
    {
        "line": 55,
        "fullcodeline": "write_image=DestroyImage(write_image);"
    },
    {
        "line": 56,
        "fullcodeline": "write_info=DestroyImageInfo(write_info);"
    },
    {
        "line": 57,
        "fullcodeline": "if (blob == (unsigned char *) NULL)"
    },
    {
        "line": 62,
        "fullcodeline": "if (base64 == (char *) NULL)"
    },
    {
        "line": 68,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 73,
        "fullcodeline": "(void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\","
    },
    {
        "line": 75,
        "fullcodeline": "(void) WriteBlobString(image,message);"
    },
    {
        "line": 76,
        "fullcodeline": "(void) WriteBlobString(image,base64);"
    },
    {
        "line": 77,
        "fullcodeline": "base64=DestroyString(base64);"
    },
    {
        "line": 35,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);"
    },
    {
        "line": 39,
        "fullcodeline": "(void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);"
    },
    {
        "line": 42,
        "fullcodeline": "(GetMagickMimeType(magick_info) == (const char *) NULL))"
    },
    {
        "line": 43,
        "fullcodeline": "ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");"
    },
    {
        "line": 50,
        "fullcodeline": "write_info=DestroyImageInfo(write_info);"
    },
    {
        "line": 61,
        "fullcodeline": "blob=(unsigned char *) RelinquishMagickMemory(blob);"
    },
    {
        "line": 63,
        "fullcodeline": "ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 74,
        "fullcodeline": "GetMagickMimeType(magick_info));"
    },
    {
        "line": 70,
        "fullcodeline": "base64=DestroyString(base64);"
    }
]