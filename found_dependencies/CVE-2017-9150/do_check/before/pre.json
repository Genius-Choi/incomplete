[
    {
        "line": 3,
        "fullcodeline": "struct bpf_verifier_state *state = &env->cur_state;"
    },
    {
        "line": 4,
        "fullcodeline": "struct bpf_insn *insns = env->prog->insnsi;"
    },
    {
        "line": 5,
        "fullcodeline": "struct bpf_reg_state *regs = state->regs;"
    },
    {
        "line": 6,
        "fullcodeline": "int insn_cnt = env->prog->len;"
    },
    {
        "line": 7,
        "fullcodeline": "int insn_idx, prev_insn_idx = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int insn_processed = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "bool do_print_state = false;"
    },
    {
        "line": 11,
        "fullcodeline": "init_reg_state(regs);"
    },
    {
        "line": 12,
        "fullcodeline": "insn_idx = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "env->varlen_map_value_access = false;"
    },
    {
        "line": 25,
        "fullcodeline": "insn = &insns[insn_idx];"
    },
    {
        "line": 26,
        "fullcodeline": "class = BPF_CLASS(insn->code);"
    },
    {
        "line": 34,
        "fullcodeline": "err = is_state_visited(env, insn_idx);"
    },
    {
        "line": 60,
        "fullcodeline": "err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);"
    },
    {
        "line": 270,
        "fullcodeline": "insn_idx++;"
    },
    {
        "line": 19,
        "fullcodeline": "if (insn_idx >= insn_cnt) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 37,
        "fullcodeline": "if (err == 1) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (log_level && do_print_state) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (class == BPF_ALU || class == BPF_ALU64) {"
    },
    {
        "line": 20,
        "fullcodeline": "verbose(\"invalid insn idx %d insn_cnt %d\\n\","
    },
    {
        "line": 50,
        "fullcodeline": "verbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);"
    },
    {
        "line": 51,
        "fullcodeline": "print_verifier_state(&env->cur_state);"
    },
    {
        "line": 52,
        "fullcodeline": "do_print_state = false;"
    },
    {
        "line": 56,
        "fullcodeline": "verbose(\"%d: \", insn_idx);"
    },
    {
        "line": 57,
        "fullcodeline": "print_bpf_insn(insn);"
    },
    {
        "line": 65,
        "fullcodeline": "err = check_alu_op(env, insn);"
    },
    {
        "line": 22,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 31,
        "fullcodeline": "return -E2BIG;"
    },
    {
        "line": 69,
        "fullcodeline": "} else if (class == BPF_LDX) {"
    },
    {
        "line": 75,
        "fullcodeline": "err = check_reg_arg(regs, insn->src_reg, SRC_OP);"
    },
    {
        "line": 79,
        "fullcodeline": "err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);"
    },
    {
        "line": 83,
        "fullcodeline": "src_reg_type = regs[insn->src_reg].type;"
    },
    {
        "line": 88,
        "fullcodeline": "err = check_mem_access(env, insn->src_reg, insn->off,"
    },
    {
        "line": 100,
        "fullcodeline": "prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;"
    },
    {
        "line": 41,
        "fullcodeline": "verbose(\"\\nfrom %d to %d: safe\\n\","
    },
    {
        "line": 94,
        "fullcodeline": "if (BPF_SIZE(insn->code) != BPF_W &&"
    },
    {
        "line": 102,
        "fullcodeline": "if (*prev_src_type == NOT_INIT) {"
    },
    {
        "line": 44,
        "fullcodeline": "verbose(\"%d: safe\\n\", insn_idx);"
    },
    {
        "line": 89,
        "fullcodeline": "BPF_SIZE(insn->code), BPF_READ,"
    },
    {
        "line": 95,
        "fullcodeline": "BPF_SIZE(insn->code) != BPF_DW) {"
    },
    {
        "line": 96,
        "fullcodeline": "insn_idx++;"
    },
    {
        "line": 107,
        "fullcodeline": "*prev_src_type = src_reg_type;"
    },
    {
        "line": 123,
        "fullcodeline": "} else if (class == BPF_STX) {"
    },
    {
        "line": 135,
        "fullcodeline": "err = check_reg_arg(regs, insn->src_reg, SRC_OP);"
    },
    {
        "line": 139,
        "fullcodeline": "err = check_reg_arg(regs, insn->dst_reg, SRC_OP);"
    },
    {
        "line": 143,
        "fullcodeline": "dst_reg_type = regs[insn->dst_reg].type;"
    },
    {
        "line": 146,
        "fullcodeline": "err = check_mem_access(env, insn->dst_reg, insn->off,"
    },
    {
        "line": 152,
        "fullcodeline": "prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;"
    },
    {
        "line": 109,
        "fullcodeline": "} else if (src_reg_type != *prev_src_type &&"
    },
    {
        "line": 126,
        "fullcodeline": "if (BPF_MODE(insn->code) == BPF_XADD) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (*prev_dst_type == NOT_INIT) {"
    },
    {
        "line": 110,
        "fullcodeline": "(src_reg_type == PTR_TO_CTX ||"
    },
    {
        "line": 127,
        "fullcodeline": "err = check_xadd(env, insn);"
    },
    {
        "line": 130,
        "fullcodeline": "insn_idx++;"
    },
    {
        "line": 147,
        "fullcodeline": "BPF_SIZE(insn->code), BPF_WRITE,"
    },
    {
        "line": 155,
        "fullcodeline": "*prev_dst_type = dst_reg_type;"
    },
    {
        "line": 163,
        "fullcodeline": "} else if (class == BPF_ST) {"
    },
    {
        "line": 111,
        "fullcodeline": "*prev_src_type == PTR_TO_CTX)) {"
    },
    {
        "line": 120,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 170,
        "fullcodeline": "err = check_reg_arg(regs, insn->dst_reg, SRC_OP);"
    },
    {
        "line": 175,
        "fullcodeline": "err = check_mem_access(env, insn->dst_reg, insn->off,"
    },
    {
        "line": 156,
        "fullcodeline": "} else if (dst_reg_type != *prev_dst_type &&"
    },
    {
        "line": 164,
        "fullcodeline": "if (BPF_MODE(insn->code) != BPF_MEM ||"
    },
    {
        "line": 157,
        "fullcodeline": "(dst_reg_type == PTR_TO_CTX ||"
    },
    {
        "line": 165,
        "fullcodeline": "insn->src_reg != BPF_REG_0) {"
    },
    {
        "line": 176,
        "fullcodeline": "BPF_SIZE(insn->code), BPF_WRITE,"
    },
    {
        "line": 177,
        "fullcodeline": "-1);"
    },
    {
        "line": 181,
        "fullcodeline": "} else if (class == BPF_JMP) {"
    },
    {
        "line": 158,
        "fullcodeline": "*prev_dst_type == PTR_TO_CTX)) {"
    },
    {
        "line": 160,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 167,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 182,
        "fullcodeline": "u8 opcode = BPF_OP(insn->code);"
    },
    {
        "line": 184,
        "fullcodeline": "if (opcode == BPF_CALL) {"
    },
    {
        "line": 193,
        "fullcodeline": "err = check_call(env, insn->imm, insn_idx);"
    },
    {
        "line": 246,
        "fullcodeline": "} else if (class == BPF_LD) {"
    },
    {
        "line": 185,
        "fullcodeline": "if (BPF_SRC(insn->code) != BPF_K ||"
    },
    {
        "line": 247,
        "fullcodeline": "u8 mode = BPF_MODE(insn->code);"
    },
    {
        "line": 264,
        "fullcodeline": "reset_reg_range_values(regs, insn->dst_reg);"
    },
    {
        "line": 188,
        "fullcodeline": "insn->dst_reg != BPF_REG_0) {"
    },
    {
        "line": 197,
        "fullcodeline": "} else if (opcode == BPF_JA) {"
    },
    {
        "line": 249,
        "fullcodeline": "if (mode == BPF_ABS || mode == BPF_IND) {"
    },
    {
        "line": 187,
        "fullcodeline": "insn->src_reg != BPF_REG_0 ||"
    },
    {
        "line": 190,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 206,
        "fullcodeline": "insn_idx += insn->off + 1;"
    },
    {
        "line": 250,
        "fullcodeline": "err = check_ld_abs(env, insn);"
    },
    {
        "line": 267,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 186,
        "fullcodeline": "insn->off != 0 ||"
    },
    {
        "line": 198,
        "fullcodeline": "if (BPF_SRC(insn->code) != BPF_K ||"
    },
    {
        "line": 201,
        "fullcodeline": "insn->dst_reg != BPF_REG_0) {"
    },
    {
        "line": 209,
        "fullcodeline": "} else if (opcode == BPF_EXIT) {"
    },
    {
        "line": 254,
        "fullcodeline": "} else if (mode == BPF_IMM) {"
    },
    {
        "line": 200,
        "fullcodeline": "insn->src_reg != BPF_REG_0 ||"
    },
    {
        "line": 203,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 224,
        "fullcodeline": "err = check_reg_arg(regs, BPF_REG_0, SRC_OP);"
    },
    {
        "line": 234,
        "fullcodeline": "insn_idx = pop_stack(env, &prev_insn_idx);"
    },
    {
        "line": 255,
        "fullcodeline": "err = check_ld_imm(env, insn);"
    },
    {
        "line": 259,
        "fullcodeline": "insn_idx++;"
    },
    {
        "line": 199,
        "fullcodeline": "insn->imm != 0 ||"
    },
    {
        "line": 210,
        "fullcodeline": "if (BPF_SRC(insn->code) != BPF_K ||"
    },
    {
        "line": 228,
        "fullcodeline": "if (is_pointer_value(env, BPF_REG_0)) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (insn_idx < 0) {"
    },
    {
        "line": 242,
        "fullcodeline": "err = check_cond_jmp_op(env, insn, &insn_idx);"
    },
    {
        "line": 213,
        "fullcodeline": "insn->dst_reg != BPF_REG_0) {"
    },
    {
        "line": 262,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 212,
        "fullcodeline": "insn->src_reg != BPF_REG_0 ||"
    },
    {
        "line": 215,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 230,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 238,
        "fullcodeline": "do_print_state = true;"
    },
    {
        "line": 211,
        "fullcodeline": "insn->imm != 0 ||"
    }
]