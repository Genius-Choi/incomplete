[
    {
        "line": 5,
        "fullcodeline": "size_t remote_addr_len = SIZE_MAX;"
    },
    {
        "line": 6,
        "fullcodeline": "char remote_addr[NI_MAXHOST];"
    },
    {
        "line": 9,
        "fullcodeline": "h2o_iovec_t xff_buf = {NULL}, via_buf = {NULL};"
    },
    {
        "line": 10,
        "fullcodeline": "int preserve_x_forwarded_proto = req->conn->ctx->globalconf->proxy.preserve_x_forwarded_proto;"
    },
    {
        "line": 11,
        "fullcodeline": "int emit_x_forwarded_headers = req->conn->ctx->globalconf->proxy.emit_x_forwarded_headers;"
    },
    {
        "line": 12,
        "fullcodeline": "int emit_via_header = req->conn->ctx->globalconf->proxy.emit_via_header;"
    },
    {
        "line": 24,
        "fullcodeline": "*method = h2o_strdup(&req->pool, req->method.base, req->method.len);"
    },
    {
        "line": 27,
        "fullcodeline": "h2o_url_init(url, origin->scheme, req->authority, h2o_strdup(&req->pool, req->path.base, req->path.len));"
    },
    {
        "line": 59,
        "fullcodeline": "h2o_iovec_vector_t cookie_values = {NULL};"
    },
    {
        "line": 60,
        "fullcodeline": "int found_early_data = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "if ((sslen = req->conn->callbacks->get_peername(req->conn, (void *)&ss)) != 0)"
    },
    {
        "line": 18,
        "fullcodeline": "if (props->proxy_protocol != NULL && use_proxy_protocol) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (props->connection_header != NULL) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (!req->is_tunnel_req) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (H2O_LIKELY(req->headers.size != 0)) {"
    },
    {
        "line": 106,
        "fullcodeline": "if (cookie_values.size == 1) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (req->overrides != NULL && req->overrides->headers_cmds != NULL) {"
    },
    {
        "line": 16,
        "fullcodeline": "remote_addr_len = h2o_socket_getnumerichost((void *)&ss, sslen, remote_addr);"
    },
    {
        "line": 20,
        "fullcodeline": "props->proxy_protocol->len = h2o_stringify_proxy_header(req->conn, props->proxy_protocol->base);"
    },
    {
        "line": 101,
        "fullcodeline": "*reprocess_if_too_early = 0;"
    },
    {
        "line": 108,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_COOKIE, NULL, cookie_values.entries[0].base, cookie_values.entries[0].len);"
    },
    {
        "line": 127,
        "fullcodeline": "added.len = 0;"
    },
    {
        "line": 136,
        "fullcodeline": "added.base[added.len++] = ' ';"
    },
    {
        "line": 137,
        "fullcodeline": "memcpy(added.base + added.len, req->input.authority.base, req->input.authority.len);"
    },
    {
        "line": 138,
        "fullcodeline": "added.len += req->input.authority.len;"
    },
    {
        "line": 140,
        "fullcodeline": "via_buf = build_request_merge_headers(&req->pool, via_buf, added, ',');"
    },
    {
        "line": 141,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_VIA, NULL, via_buf.base, via_buf.len);"
    },
    {
        "line": 30,
        "fullcodeline": "if (upgrade_to != NULL && upgrade_to != h2o_httpclient_upgrade_to_connect) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (req->proceed_req == NULL) {"
    },
    {
        "line": 62,
        "fullcodeline": "for (const h2o_header_t *h = req->headers.entries, *h_end = h + req->headers.size; h != h_end; ++h) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (!preserve_x_forwarded_proto)"
    },
    {
        "line": 119,
        "fullcodeline": "if (remote_addr_len != SIZE_MAX)"
    },
    {
        "line": 121,
        "fullcodeline": "if (xff_buf.len != 0)"
    },
    {
        "line": 129,
        "fullcodeline": "if (req->version < 0x200) {"
    },
    {
        "line": 147,
        "fullcodeline": "for (cmd = req->overrides->headers_cmds; cmd->cmd != H2O_HEADERS_CMD_NULL; ++cmd)"
    },
    {
        "line": 148,
        "fullcodeline": "h2o_rewrite_headers(&req->pool, headers, cmd);"
    },
    {
        "line": 31,
        "fullcodeline": "*props->connection_header = h2o_iovec_init(H2O_STRLIT(\"upgrade\"));"
    },
    {
        "line": 32,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_UPGRADE, NULL, upgrade_to, strlen(upgrade_to));"
    },
    {
        "line": 109,
        "fullcodeline": "} else if (cookie_values.size > 1) {"
    },
    {
        "line": 117,
        "fullcodeline": "h2o_add_header_by_str(&req->pool, headers, H2O_STRLIT(\"x-forwarded-proto\"), 0, NULL, req->input.scheme->name.base,"
    },
    {
        "line": 120,
        "fullcodeline": "xff_buf = build_request_merge_headers(&req->pool, xff_buf, h2o_strdup(&req->pool, remote_addr, remote_addr_len), ',');"
    },
    {
        "line": 122,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_X_FORWARDED_FOR, NULL, xff_buf.base, xff_buf.len);"
    },
    {
        "line": 130,
        "fullcodeline": "added.base[added.len++] = '1';"
    },
    {
        "line": 131,
        "fullcodeline": "added.base[added.len++] = '.';"
    },
    {
        "line": 132,
        "fullcodeline": "added.base[added.len++] = '0' + (0x100 <= req->version && req->version <= 0x109 ? req->version - 0x100 : 0);"
    },
    {
        "line": 43,
        "fullcodeline": "if (req->entity.base != NULL || req_requires_content_length(req)) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (h2o_iovec_is_token(h->name)) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (h2o_iovec_is_token(h->name)) {"
    },
    {
        "line": 103,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_EARLY_DATA, NULL, H2O_STRLIT(\"1\"));"
    },
    {
        "line": 111,
        "fullcodeline": "h2o_iovec_t cookie_buf ="
    },
    {
        "line": 113,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_COOKIE, NULL, cookie_buf.base, cookie_buf.len);"
    },
    {
        "line": 134,
        "fullcodeline": "added.base[added.len++] = '0' + req->version / 0x100;"
    },
    {
        "line": 44,
        "fullcodeline": "h2o_iovec_t cl_buf = build_content_length(&req->pool, req->entity.len);"
    },
    {
        "line": 45,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_CONTENT_LENGTH, NULL, cl_buf.base, cl_buf.len);"
    },
    {
        "line": 48,
        "fullcodeline": "if (req->content_length != SIZE_MAX) {"
    },
    {
        "line": 64,
        "fullcodeline": "const h2o_token_t *token = (void *)h->name;"
    },
    {
        "line": 88,
        "fullcodeline": "if (!preserve_x_forwarded_proto && h2o_lcstris(h->name->base, h->name->len, H2O_STRLIT(\"x-forwarded-proto\")))"
    },
    {
        "line": 92,
        "fullcodeline": "const h2o_token_t *token = (void *)h->name;"
    },
    {
        "line": 93,
        "fullcodeline": "h2o_add_header(&req->pool, headers, token, h->orig_name, h->value.base, h->value.len);"
    },
    {
        "line": 112,
        "fullcodeline": "h2o_join_list(&req->pool, cookie_values.entries, cookie_values.size, h2o_iovec_init(H2O_STRLIT(\"; \")));"
    },
    {
        "line": 34,
        "fullcodeline": "*props->connection_header = h2o_iovec_init(H2O_STRLIT(\"keep-alive\"));"
    },
    {
        "line": 49,
        "fullcodeline": "h2o_iovec_t cl_buf = build_content_length(&req->pool, req->content_length);"
    },
    {
        "line": 50,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_CONTENT_LENGTH, NULL, cl_buf.base, cl_buf.len);"
    },
    {
        "line": 67,
        "fullcodeline": "if (token == H2O_TOKEN_COOKIE) {"
    },
    {
        "line": 95,
        "fullcodeline": "h2o_add_header_by_str(&req->pool, headers, h->name->base, h->name->len, 0, h->orig_name, h->value.base,"
    },
    {
        "line": 36,
        "fullcodeline": "*props->connection_header = h2o_iovec_init(H2O_STRLIT(\"close\"));"
    },
    {
        "line": 68,
        "fullcodeline": "h2o_vector_reserve(&req->pool, &cookie_values, cookie_values.size + 1);"
    },
    {
        "line": 69,
        "fullcodeline": "cookie_values.entries[cookie_values.size++] = h->value;"
    },
    {
        "line": 51,
        "fullcodeline": "} else if (props->chunked != NULL) {"
    },
    {
        "line": 52,
        "fullcodeline": "*props->chunked = 1;"
    },
    {
        "line": 53,
        "fullcodeline": "h2o_add_header(&req->pool, headers, H2O_TOKEN_TRANSFER_ENCODING, NULL, H2O_STRLIT(\"chunked\"));"
    },
    {
        "line": 71,
        "fullcodeline": "} else if (token == H2O_TOKEN_VIA) {"
    },
    {
        "line": 75,
        "fullcodeline": "via_buf = build_request_merge_headers(&req->pool, via_buf, h->value, ',');"
    },
    {
        "line": 77,
        "fullcodeline": "} else if (token == H2O_TOKEN_X_FORWARDED_FOR) {"
    },
    {
        "line": 81,
        "fullcodeline": "xff_buf = build_request_merge_headers(&req->pool, xff_buf, h->value, ',');"
    },
    {
        "line": 83,
        "fullcodeline": "} else if (token == H2O_TOKEN_EARLY_DATA) {"
    }
]