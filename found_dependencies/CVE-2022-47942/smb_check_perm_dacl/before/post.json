[
    {
        "line": 4,
        "fullcodeline": "struct user_namespace *user_ns = mnt_user_ns(path->mnt);"
    },
    {
        "line": 5,
        "fullcodeline": "struct smb_ntsd *pntsd = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "int rc = 0, acl_size;"
    },
    {
        "line": 10,
        "fullcodeline": "int granted = le32_to_cpu(*pdaccess & ~FILE_MAXIMAL_ACCESS_LE);"
    },
    {
        "line": 12,
        "fullcodeline": "int i, found = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "unsigned int access_bits = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "struct smb_ace *others_ace = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "unsigned int sid_type = SIDOWNER;"
    },
    {
        "line": 19,
        "fullcodeline": "ksmbd_debug(SMB, \"check permission using windows acl\\n\");"
    },
    {
        "line": 20,
        "fullcodeline": "acl_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,"
    },
    {
        "line": 27,
        "fullcodeline": "pdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));"
    },
    {
        "line": 28,
        "fullcodeline": "end_of_acl = ((char *)pntsd) + acl_size;"
    },
    {
        "line": 68,
        "fullcodeline": "id_to_sid(uid, sid_type, &sid);"
    },
    {
        "line": 70,
        "fullcodeline": "ace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));"
    },
    {
        "line": 154,
        "fullcodeline": "*pdaccess = cpu_to_le32(granted);"
    },
    {
        "line": 156,
        "fullcodeline": "kfree(pntsd);"
    },
    {
        "line": 22,
        "fullcodeline": "if (acl_size <= 0 || !pntsd || !pntsd->dacloffset) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (end_of_acl <= (char *)pdacl) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size) ||"
    },
    {
        "line": 40,
        "fullcodeline": "if (!pdacl->num_aces) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (*pdaccess & FILE_MAXIMAL_ACCESS_LE) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (!uid)"
    },
    {
        "line": 71,
        "fullcodeline": "for (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (*pdaccess & FILE_MAXIMAL_ACCESS_LE && found) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (!found) {"
    },
    {
        "line": 146,
        "fullcodeline": "if (granted &"
    },
    {
        "line": 23,
        "fullcodeline": "kfree(pntsd);"
    },
    {
        "line": 30,
        "fullcodeline": "kfree(pntsd);"
    },
    {
        "line": 35,
        "fullcodeline": "le16_to_cpu(pdacl->size) < sizeof(struct smb_acl)) {"
    },
    {
        "line": 36,
        "fullcodeline": "kfree(pntsd);"
    },
    {
        "line": 46,
        "fullcodeline": "kfree(pntsd);"
    },
    {
        "line": 51,
        "fullcodeline": "granted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |"
    },
    {
        "line": 54,
        "fullcodeline": "ace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));"
    },
    {
        "line": 67,
        "fullcodeline": "sid_type = SIDUNIX_USER;"
    },
    {
        "line": 80,
        "fullcodeline": "ace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));"
    },
    {
        "line": 86,
        "fullcodeline": "granted = READ_CONTROL | WRITE_DAC | FILE_READ_ATTRIBUTES |"
    },
    {
        "line": 89,
        "fullcodeline": "granted |= le32_to_cpu(ace->access_req);"
    },
    {
        "line": 96,
        "fullcodeline": "posix_acls = get_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);"
    },
    {
        "line": 137,
        "fullcodeline": "access_bits = le32_to_cpu(ace->access_req);"
    },
    {
        "line": 141,
        "fullcodeline": "access_bits = le32_to_cpu(~ace->access_req);"
    },
    {
        "line": 147,
        "fullcodeline": "~(access_bits | FILE_READ_ATTRIBUTES | READ_CONTROL | WRITE_DAC | DELETE)) {"
    },
    {
        "line": 148,
        "fullcodeline": "ksmbd_debug(SMB, \"Access denied with winACL, granted : %x, access_req : %x\\n\","
    },
    {
        "line": 150,
        "fullcodeline": "rc = -EACCES;"
    },
    {
        "line": 41,
        "fullcodeline": "if (!(le16_to_cpu(pdacl->size) - sizeof(struct smb_acl)) &&"
    },
    {
        "line": 55,
        "fullcodeline": "for (i = 0; i < le32_to_cpu(pdacl->num_aces); i++) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (!pdacl->num_aces)"
    },
    {
        "line": 72,
        "fullcodeline": "if (!compare_sids(&sid, &ace->sid) ||"
    },
    {
        "line": 77,
        "fullcodeline": "if (!compare_sids(&sid_everyone, &ace->sid))"
    },
    {
        "line": 81,
        "fullcodeline": "if (end_of_acl < (char *)ace)"
    },
    {
        "line": 91,
        "fullcodeline": "if (!pdacl->num_aces)"
    },
    {
        "line": 97,
        "fullcodeline": "if (posix_acls && !found) {"
    },
    {
        "line": 149,
        "fullcodeline": "granted, le32_to_cpu(ace->access_req));"
    },
    {
        "line": 42,
        "fullcodeline": "*pdaccess & ~(FILE_READ_CONTROL_LE | FILE_WRITE_DAC_LE)) {"
    },
    {
        "line": 43,
        "fullcodeline": "rc = -EACCES;"
    },
    {
        "line": 56,
        "fullcodeline": "granted |= le32_to_cpu(ace->access_req);"
    },
    {
        "line": 57,
        "fullcodeline": "ace = (struct smb_ace *)((char *)ace + le16_to_cpu(ace->size));"
    },
    {
        "line": 63,
        "fullcodeline": "granted = GENERIC_ALL_FLAGS;"
    },
    {
        "line": 73,
        "fullcodeline": "!compare_sids(&sid_unix_NFS_mode, &ace->sid)) {"
    },
    {
        "line": 74,
        "fullcodeline": "found = 1;"
    },
    {
        "line": 78,
        "fullcodeline": "others_ace = ace;"
    },
    {
        "line": 92,
        "fullcodeline": "granted = GENERIC_ALL_FLAGS;"
    },
    {
        "line": 98,
        "fullcodeline": "unsigned int id = -1;"
    },
    {
        "line": 100,
        "fullcodeline": "pa_entry = posix_acls->a_entries;"
    },
    {
        "line": 122,
        "fullcodeline": "posix_acl_release(posix_acls);"
    },
    {
        "line": 127,
        "fullcodeline": "ace = others_ace;"
    },
    {
        "line": 58,
        "fullcodeline": "if (end_of_acl < (char *)ace)"
    },
    {
        "line": 101,
        "fullcodeline": "for (i = 0; i < posix_acls->a_count; i++, pa_entry++) {"
    },
    {
        "line": 129,
        "fullcodeline": "ksmbd_debug(SMB, \"Can't find corresponding sid\\n\");"
    },
    {
        "line": 130,
        "fullcodeline": "rc = -EACCES;"
    },
    {
        "line": 102,
        "fullcodeline": "if (pa_entry->e_tag == ACL_USER)"
    },
    {
        "line": 109,
        "fullcodeline": "if (id == uid) {"
    },
    {
        "line": 103,
        "fullcodeline": "id = posix_acl_uid_translate(user_ns, pa_entry);"
    },
    {
        "line": 110,
        "fullcodeline": "mode_to_access_flags(pa_entry->e_perm,"
    },
    {
        "line": 116,
        "fullcodeline": "posix_acl_release(posix_acls);"
    },
    {
        "line": 113,
        "fullcodeline": "if (!access_bits)"
    },
    {
        "line": 104,
        "fullcodeline": "else if (pa_entry->e_tag == ACL_GROUP)"
    },
    {
        "line": 114,
        "fullcodeline": "access_bits ="
    },
    {
        "line": 105,
        "fullcodeline": "id = posix_acl_gid_translate(user_ns, pa_entry);"
    }
]