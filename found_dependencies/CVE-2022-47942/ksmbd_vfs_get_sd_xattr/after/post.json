[
    {
        "line": 8,
        "fullcodeline": "struct inode *inode = d_inode(dentry);"
    },
    {
        "line": 9,
        "fullcodeline": "struct ndr acl_ndr = {0};"
    },
    {
        "line": 11,
        "fullcodeline": "struct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};"
    },
    {
        "line": 14,
        "fullcodeline": "rc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);"
    },
    {
        "line": 18,
        "fullcodeline": "n.length = rc;"
    },
    {
        "line": 19,
        "fullcodeline": "rc = ndr_decode_v4_ntacl(&n, &acl);"
    },
    {
        "line": 23,
        "fullcodeline": "smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,"
    },
    {
        "line": 29,
        "fullcodeline": "rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,"
    },
    {
        "line": 36,
        "fullcodeline": "rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);"
    },
    {
        "line": 48,
        "fullcodeline": "*pntsd = acl.sd_buf;"
    },
    {
        "line": 54,
        "fullcodeline": "(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -"
    },
    {
        "line": 56,
        "fullcodeline": "(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -"
    },
    {
        "line": 58,
        "fullcodeline": "(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -"
    },
    {
        "line": 61,
        "fullcodeline": "rc = acl.sd_size;"
    },
    {
        "line": 63,
        "fullcodeline": "kfree(acl_ndr.data);"
    },
    {
        "line": 64,
        "fullcodeline": "kfree(smb_acl);"
    },
    {
        "line": 65,
        "fullcodeline": "kfree(def_smb_acl);"
    },
    {
        "line": 72,
        "fullcodeline": "kfree(n.data);"
    },
    {
        "line": 15,
        "fullcodeline": "if (rc <= 0)"
    },
    {
        "line": 25,
        "fullcodeline": "if (S_ISDIR(inode->i_mode))"
    },
    {
        "line": 42,
        "fullcodeline": "if (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (acl.sd_size < sizeof(struct smb_ntsd)) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 26,
        "fullcodeline": "def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,"
    },
    {
        "line": 32,
        "fullcodeline": "pr_err(\"failed to encode ndr to posix acl\\n\");"
    },
    {
        "line": 38,
        "fullcodeline": "pr_err(\"failed to generate hash for ndr acl\\n\");"
    },
    {
        "line": 43,
        "fullcodeline": "pr_err(\"hash value diff\\n\");"
    },
    {
        "line": 44,
        "fullcodeline": "rc = -EINVAL;"
    },
    {
        "line": 50,
        "fullcodeline": "pr_err(\"sd size is invalid\\n\");"
    },
    {
        "line": 67,
        "fullcodeline": "kfree(acl.sd_buf);"
    },
    {
        "line": 68,
        "fullcodeline": "*pntsd = NULL;"
    }
]