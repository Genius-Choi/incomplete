[
    {
        "line": 8,
        "fullcodeline": "struct inode *inode = d_inode(dentry);"
    },
    {
        "line": 9,
        "fullcodeline": "struct ndr acl_ndr = {0};"
    },
    {
        "line": 11,
        "fullcodeline": "struct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};"
    },
    {
        "line": 14,
        "fullcodeline": "rc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);"
    },
    {
        "line": 18,
        "fullcodeline": "n.length = rc;"
    },
    {
        "line": 19,
        "fullcodeline": "rc = ndr_decode_v4_ntacl(&n, &acl);"
    },
    {
        "line": 23,
        "fullcodeline": "smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,"
    },
    {
        "line": 29,
        "fullcodeline": "rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,"
    },
    {
        "line": 36,
        "fullcodeline": "rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);"
    },
    {
        "line": 56,
        "fullcodeline": "rc = acl.sd_size;"
    },
    {
        "line": 15,
        "fullcodeline": "if (rc <= 0)"
    },
    {
        "line": 25,
        "fullcodeline": "if (S_ISDIR(inode->i_mode))"
    },
    {
        "line": 49,
        "fullcodeline": "(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -"
    },
    {
        "line": 51,
        "fullcodeline": "(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -"
    },
    {
        "line": 53,
        "fullcodeline": "(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -"
    },
    {
        "line": 61,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 26,
        "fullcodeline": "def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,"
    },
    {
        "line": 44,
        "fullcodeline": "rc = -EINVAL;"
    }
]