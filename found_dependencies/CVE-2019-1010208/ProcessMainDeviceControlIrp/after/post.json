[
    {
        "line": 3,
        "fullcodeline": "PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);"
    },
    {
        "line": 928,
        "fullcodeline": "return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);"
    },
    {
        "line": 357,
        "fullcodeline": "WipeCache ();"
    },
    {
        "line": 359,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 360,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 364,
        "fullcodeline": "Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;"
    },
    {
        "line": 365,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 382,
        "fullcodeline": "Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;"
    },
    {
        "line": 383,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 775,
        "fullcodeline": "Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);"
    },
    {
        "line": 776,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 780,
        "fullcodeline": "Irp->IoStatus.Status = AbortBootEncryptionSetup();"
    },
    {
        "line": 781,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 785,
        "fullcodeline": "GetBootEncryptionStatus (Irp, irpSp);"
    },
    {
        "line": 789,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 790,
        "fullcodeline": "Irp->IoStatus.Status = GetSetupResult();"
    },
    {
        "line": 794,
        "fullcodeline": "GetBootDriveVolumeProperties (Irp, irpSp);"
    },
    {
        "line": 798,
        "fullcodeline": "GetBootLoaderVersion (Irp, irpSp);"
    },
    {
        "line": 802,
        "fullcodeline": "ReopenBootVolumeHeader (Irp, irpSp);"
    },
    {
        "line": 806,
        "fullcodeline": "GetBootLoaderFingerprint (Irp, irpSp);"
    },
    {
        "line": 810,
        "fullcodeline": "GetBootEncryptionAlgorithmName (Irp, irpSp);"
    },
    {
        "line": 823,
        "fullcodeline": "Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);"
    },
    {
        "line": 824,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 828,
        "fullcodeline": "Irp->IoStatus.Status = AbortDecoySystemWipe();"
    },
    {
        "line": 829,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 833,
        "fullcodeline": "Irp->IoStatus.Status = GetDecoySystemWipeResult();"
    },
    {
        "line": 834,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 838,
        "fullcodeline": "GetDecoySystemWipeStatus (Irp, irpSp);"
    },
    {
        "line": 842,
        "fullcodeline": "Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);"
    },
    {
        "line": 843,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 870,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 874,
        "fullcodeline": "Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);"
    },
    {
        "line": 875,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))"
    },
    {
        "line": 20,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 29,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 44,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 74,
        "fullcodeline": "ACCESS_MASK access = FILE_READ_ATTRIBUTES;"
    },
    {
        "line": 79,
        "fullcodeline": "EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));"
    },
    {
        "line": 80,
        "fullcodeline": "RtlInitUnicodeString (&FullFileName, opentest->wszFileName);"
    },
    {
        "line": 82,
        "fullcodeline": "InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);"
    },
    {
        "line": 87,
        "fullcodeline": "ntStatus = ZwCreateFile (&NtFileHandle,"
    },
    {
        "line": 219,
        "fullcodeline": "Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;"
    },
    {
        "line": 220,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 232,
        "fullcodeline": "size_t devicePathLen = 0;"
    },
    {
        "line": 250,
        "fullcodeline": "EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));"
    },
    {
        "line": 251,
        "fullcodeline": "RtlInitUnicodeString (&FullFileName, request->DevicePath);"
    },
    {
        "line": 253,
        "fullcodeline": "InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);"
    },
    {
        "line": 255,
        "fullcodeline": "ntStatus = ZwCreateFile (&NtFileHandle,"
    },
    {
        "line": 369,
        "fullcodeline": "if (!UserCanAccessDriveDevice())"
    },
    {
        "line": 388,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))"
    },
    {
        "line": 431,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))"
    },
    {
        "line": 446,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 498,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 517,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 578,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 598,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 666,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))"
    },
    {
        "line": 709,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 742,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 763,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 814,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 847,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))"
    },
    {
        "line": 862,
        "fullcodeline": "if (UserCanAccessDriveDevice())"
    },
    {
        "line": 879,
        "fullcodeline": "if (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))"
    },
    {
        "line": 901,
        "fullcodeline": "return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);"
    },
    {
        "line": 12,
        "fullcodeline": "LONG tmp = VERSION_NUM;"
    },
    {
        "line": 13,
        "fullcodeline": "memcpy (Irp->AssociatedIrp.SystemBuffer, &tmp, 4);"
    },
    {
        "line": 15,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 22,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = DeviceObject->ReferenceCount;"
    },
    {
        "line": 24,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 31,
        "fullcodeline": "LONG deviceObjectCount = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;"
    },
    {
        "line": 39,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 47,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = 0;"
    },
    {
        "line": 62,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 76,
        "fullcodeline": "if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 84,
        "fullcodeline": "if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)"
    },
    {
        "line": 91,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 234,
        "fullcodeline": "if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))"
    },
    {
        "line": 238,
        "fullcodeline": "if (\t!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))"
    },
    {
        "line": 259,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 371,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_ACCESS_DENIED;"
    },
    {
        "line": 372,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 394,
        "fullcodeline": "list->ulMountedDrives = 0;"
    },
    {
        "line": 425,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 437,
        "fullcodeline": "memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);"
    },
    {
        "line": 438,
        "fullcodeline": "*(uint32 *) Irp->AssociatedIrp.SystemBuffer = 0xffffFFFF;"
    },
    {
        "line": 440,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 441,
        "fullcodeline": "Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;"
    },
    {
        "line": 449,
        "fullcodeline": "PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);"
    },
    {
        "line": 451,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 452,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 674,
        "fullcodeline": "EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));"
    },
    {
        "line": 676,
        "fullcodeline": "RtlInitUnicodeString (&name, request->DeviceName);"
    },
    {
        "line": 677,
        "fullcodeline": "status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);"
    },
    {
        "line": 685,
        "fullcodeline": "status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);"
    },
    {
        "line": 686,
        "fullcodeline": "ObDereferenceObject (fileObject);"
    },
    {
        "line": 725,
        "fullcodeline": "EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));"
    },
    {
        "line": 726,
        "fullcodeline": "EnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));"
    },
    {
        "line": 729,
        "fullcodeline": "Irp->IoStatus.Status = MountDevice (DeviceObject, mount);"
    },
    {
        "line": 731,
        "fullcodeline": "burn (&mount->VolumePassword, sizeof (mount->VolumePassword));"
    },
    {
        "line": 732,
        "fullcodeline": "burn (&mount->ProtectedHidVolPassword, sizeof (mount->ProtectedHidVolPassword));"
    },
    {
        "line": 733,
        "fullcodeline": "burn (&mount->pkcs5_prf, sizeof (mount->pkcs5_prf));"
    },
    {
        "line": 734,
        "fullcodeline": "burn (&mount->VolumePim, sizeof (mount->VolumePim));"
    },
    {
        "line": 735,
        "fullcodeline": "burn (&mount->bTrueCryptMode, sizeof (mount->bTrueCryptMode));"
    },
    {
        "line": 736,
        "fullcodeline": "burn (&mount->ProtectedHidVolPkcs5Prf, sizeof (mount->ProtectedHidVolPkcs5Prf));"
    },
    {
        "line": 737,
        "fullcodeline": "burn (&mount->ProtectedHidVolPim, sizeof (mount->ProtectedHidVolPim));"
    },
    {
        "line": 745,
        "fullcodeline": "PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);"
    },
    {
        "line": 747,
        "fullcodeline": "unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;"
    },
    {
        "line": 758,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 767,
        "fullcodeline": "unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);"
    },
    {
        "line": 770,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 816,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = IsHiddenSystemRunning() ? 1 : 0;"
    },
    {
        "line": 818,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 851,
        "fullcodeline": "flags->PagingFileCreationPrevented = PagingFileCreationPrevented;"
    },
    {
        "line": 852,
        "fullcodeline": "PagingFileCreationPrevented = FALSE;"
    },
    {
        "line": 853,
        "fullcodeline": "flags->SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty;"
    },
    {
        "line": 854,
        "fullcodeline": "SystemFavoriteVolumeDirty = FALSE;"
    },
    {
        "line": 857,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 864,
        "fullcodeline": "SystemFavoriteVolumeDirty = TRUE;"
    },
    {
        "line": 865,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 880,
        "fullcodeline": "&&\t(Irp->RequestorMode == KernelMode)"
    },
    {
        "line": 885,
        "fullcodeline": "request->BootDriveFilterExtension = GetBootDriveFilterExtension();"
    },
    {
        "line": 35,
        "fullcodeline": "if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)"
    },
    {
        "line": 49,
        "fullcodeline": "for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)"
    },
    {
        "line": 58,
        "fullcodeline": "if (IsBootDriveMounted())"
    },
    {
        "line": 85,
        "fullcodeline": "access |= FILE_READ_DATA;"
    },
    {
        "line": 88,
        "fullcodeline": "SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,"
    },
    {
        "line": 89,
        "fullcodeline": "0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);"
    },
    {
        "line": 93,
        "fullcodeline": "opentest->TCBootLoaderDetected = FALSE;"
    },
    {
        "line": 94,
        "fullcodeline": "opentest->FilesystemDetected = FALSE;"
    },
    {
        "line": 95,
        "fullcodeline": "memset (opentest->VolumeIDComputed, 0, sizeof (opentest->VolumeIDComputed));"
    },
    {
        "line": 96,
        "fullcodeline": "memset (opentest->volumeIDs, 0, sizeof (opentest->volumeIDs));"
    },
    {
        "line": 209,
        "fullcodeline": "ZwClose (NtFileHandle);"
    },
    {
        "line": 210,
        "fullcodeline": "Dump (\"Open test on file %ls success.\\n\", opentest->wszFileName);"
    },
    {
        "line": 242,
        "fullcodeline": "||\t(memcmp (&request->DevicePath[devicePathLen - 11], L\"\\\\Partition0\", 11 * sizeof (WCHAR)))"
    },
    {
        "line": 245,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 246,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 256,
        "fullcodeline": "SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,"
    },
    {
        "line": 257,
        "fullcodeline": "FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);"
    },
    {
        "line": 261,
        "fullcodeline": "byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);"
    },
    {
        "line": 345,
        "fullcodeline": "ZwClose (NtFileHandle);"
    },
    {
        "line": 376,
        "fullcodeline": "PortableMode = TRUE;"
    },
    {
        "line": 377,
        "fullcodeline": "Dump (\"Setting portable mode\\n\");"
    },
    {
        "line": 396,
        "fullcodeline": "for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)"
    },
    {
        "line": 504,
        "fullcodeline": "EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));"
    },
    {
        "line": 506,
        "fullcodeline": "ntStatus = SymbolicLinkToTarget (resolve->symLinkName,"
    },
    {
        "line": 511,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 524,
        "fullcodeline": "EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));"
    },
    {
        "line": 526,
        "fullcodeline": "ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));"
    },
    {
        "line": 562,
        "fullcodeline": "info->IsDynamic = FALSE;"
    },
    {
        "line": 572,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 584,
        "fullcodeline": "EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));"
    },
    {
        "line": 585,
        "fullcodeline": "Dump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);"
    },
    {
        "line": 587,
        "fullcodeline": "ntStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 592,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 603,
        "fullcodeline": "PVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data"
    },
    {
        "line": 678,
        "fullcodeline": "if (!NT_SUCCESS (status))"
    },
    {
        "line": 688,
        "fullcodeline": "if (status == STATUS_TIMEOUT)"
    },
    {
        "line": 713,
        "fullcodeline": "if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD"
    },
    {
        "line": 868,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_ACCESS_DENIED;"
    },
    {
        "line": 886,
        "fullcodeline": "if (IsBootDriveMounted() && request->BootDriveFilterExtension)"
    },
    {
        "line": 36,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = TRUE;"
    },
    {
        "line": 59,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = 1;"
    },
    {
        "line": 98,
        "fullcodeline": "if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)"
    },
    {
        "line": 241,
        "fullcodeline": "||\t(memcmp (request->DevicePath, L\"\\\\Device\\\\Harddisk\", 16 * sizeof (WCHAR)))"
    },
    {
        "line": 262,
        "fullcodeline": "if (!readBuffer)"
    },
    {
        "line": 350,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 351,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 400,
        "fullcodeline": "ListDevice = GetVirtualVolumeDeviceObject (drive);"
    },
    {
        "line": 404,
        "fullcodeline": "ListExtension = (PEXTENSION) ListDevice->DeviceExtension;"
    },
    {
        "line": 456,
        "fullcodeline": "PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;"
    },
    {
        "line": 527,
        "fullcodeline": "if (NT_SUCCESS(ntStatus))"
    },
    {
        "line": 550,
        "fullcodeline": "if (!NT_SUCCESS (ntStatus))"
    },
    {
        "line": 564,
        "fullcodeline": "if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)"
    },
    {
        "line": 680,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 681,
        "fullcodeline": "Irp->IoStatus.Status = status;"
    },
    {
        "line": 690,
        "fullcodeline": "request->TimeOut = TRUE;"
    },
    {
        "line": 692,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 717,
        "fullcodeline": "|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)"
    },
    {
        "line": 720,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 721,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 751,
        "fullcodeline": "PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;"
    },
    {
        "line": 888,
        "fullcodeline": "request->HwEncryptionEnabled = IsHwEncryptionEnabled();"
    },
    {
        "line": 889,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 51,
        "fullcodeline": "if (GetVirtualVolumeDeviceObject (drive))"
    },
    {
        "line": 100,
        "fullcodeline": "byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);"
    },
    {
        "line": 240,
        "fullcodeline": "||\t(devicePathLen > 30) // 30 is the length of \"\\\\Device\\\\Harddisk255\\\\Partition0\" which is the maximum"
    },
    {
        "line": 264,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;"
    },
    {
        "line": 265,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 401,
        "fullcodeline": "if (!ListDevice)"
    },
    {
        "line": 405,
        "fullcodeline": "if (IsVolumeAccessibleByCurrentUser (ListExtension))"
    },
    {
        "line": 457,
        "fullcodeline": "if (IsVolumeAccessibleByCurrentUser (ListExtension))"
    },
    {
        "line": 529,
        "fullcodeline": "memset (&info->partInfo, 0, sizeof (info->partInfo));"
    },
    {
        "line": 541,
        "fullcodeline": "info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;"
    },
    {
        "line": 553,
        "fullcodeline": "ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));"
    },
    {
        "line": 606,
        "fullcodeline": "EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));"
    },
    {
        "line": 607,
        "fullcodeline": "Dump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);"
    },
    {
        "line": 609,
        "fullcodeline": "ntStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 651,
        "fullcodeline": "TCfree (buffer);"
    },
    {
        "line": 654,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 716,
        "fullcodeline": "|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID"
    },
    {
        "line": 753,
        "fullcodeline": "if (IsVolumeAccessibleByCurrentUser (ListExtension))"
    },
    {
        "line": 894,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 895,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = 1;"
    },
    {
        "line": 101,
        "fullcodeline": "if (!readBuffer)"
    },
    {
        "line": 239,
        "fullcodeline": "||\t(devicePathLen < 28) // 28 is the length of \"\\\\Device\\\\Harddisk0\\\\Partition0\" which is the minimum"
    },
    {
        "line": 270,
        "fullcodeline": "offset.QuadPart = 0;\t// MBR"
    },
    {
        "line": 272,
        "fullcodeline": "ntStatus = ZwReadFile (NtFileHandle,"
    },
    {
        "line": 342,
        "fullcodeline": "TCfree (readBuffer);"
    },
    {
        "line": 407,
        "fullcodeline": "list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);"
    },
    {
        "line": 408,
        "fullcodeline": "RtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);"
    },
    {
        "line": 409,
        "fullcodeline": "RtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);"
    },
    {
        "line": 410,
        "fullcodeline": "memcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);"
    },
    {
        "line": 411,
        "fullcodeline": "list->diskLength[ListExtension->nDosDriveNo] = ListExtension->DiskLength;"
    },
    {
        "line": 459,
        "fullcodeline": "prop->uniqueId = ListExtension->UniqueVolumeId;"
    },
    {
        "line": 460,
        "fullcodeline": "RtlStringCbCopyW (prop->wszVolume, sizeof(prop->wszVolume),ListExtension->wszVolume);"
    },
    {
        "line": 461,
        "fullcodeline": "RtlStringCbCopyW (prop->wszLabel, sizeof(prop->wszLabel),ListExtension->wszLabel);"
    },
    {
        "line": 462,
        "fullcodeline": "memcpy (prop->volumeID, ListExtension->volumeID, VOLUME_ID_SIZE);"
    },
    {
        "line": 463,
        "fullcodeline": "prop->bDriverSetLabel = ListExtension->bDriverSetLabel;"
    },
    {
        "line": 464,
        "fullcodeline": "prop->diskLength = ListExtension->DiskLength;"
    },
    {
        "line": 475,
        "fullcodeline": "prop->readOnly = ListExtension->bReadOnly;"
    },
    {
        "line": 476,
        "fullcodeline": "prop->removable = ListExtension->bRemovable;"
    },
    {
        "line": 477,
        "fullcodeline": "prop->partitionInInactiveSysEncScope = ListExtension->PartitionInInactiveSysEncScope;"
    },
    {
        "line": 488,
        "fullcodeline": "prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;"
    },
    {
        "line": 490,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 535,
        "fullcodeline": "if (pi.PartitionStyle == PARTITION_STYLE_MBR)"
    },
    {
        "line": 546,
        "fullcodeline": "ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));"
    },
    {
        "line": 547,
        "fullcodeline": "info->IsGPT = FALSE;"
    },
    {
        "line": 555,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 567,
        "fullcodeline": "if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))"
    },
    {
        "line": 613,
        "fullcodeline": "if (NT_SUCCESS(ntStatus))"
    },
    {
        "line": 658,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;"
    },
    {
        "line": 659,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 694,
        "fullcodeline": "else if (!NT_SUCCESS (status))"
    },
    {
        "line": 754,
        "fullcodeline": "unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);"
    },
    {
        "line": 103,
        "fullcodeline": "ntStatus = STATUS_INSUFFICIENT_RESOURCES;"
    },
    {
        "line": 282,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 557,
        "fullcodeline": "memset (&info->partInfo, 0, sizeof (info->partInfo));"
    },
    {
        "line": 568,
        "fullcodeline": "info->IsDynamic = FALSE;"
    },
    {
        "line": 615,
        "fullcodeline": "PDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;"
    },
    {
        "line": 616,
        "fullcodeline": "memcpy (&g->diskGeometry, &pGeo->Geometry, sizeof (DISK_GEOMETRY));"
    },
    {
        "line": 696,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 697,
        "fullcodeline": "Irp->IoStatus.Status = status;"
    },
    {
        "line": 715,
        "fullcodeline": "||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX"
    },
    {
        "line": 205,
        "fullcodeline": "TCfree (readBuffer);"
    },
    {
        "line": 414,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume"
    },
    {
        "line": 481,
        "fullcodeline": "prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;"
    },
    {
        "line": 621,
        "fullcodeline": "DISK_GEOMETRY dg = {0};"
    },
    {
        "line": 622,
        "fullcodeline": "Dump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);"
    },
    {
        "line": 623,
        "fullcodeline": "ntStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 701,
        "fullcodeline": "request->TimeOut = FALSE;"
    },
    {
        "line": 703,
        "fullcodeline": "Irp->IoStatus.Status = status;"
    },
    {
        "line": 107,
        "fullcodeline": "if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)"
    },
    {
        "line": 165,
        "fullcodeline": "if (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))"
    },
    {
        "line": 285,
        "fullcodeline": "if (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)"
    },
    {
        "line": 338,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 339,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 483,
        "fullcodeline": "prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;"
    },
    {
        "line": 627,
        "fullcodeline": "if (NT_SUCCESS(ntStatus))"
    },
    {
        "line": 714,
        "fullcodeline": "||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID"
    },
    {
        "line": 111,
        "fullcodeline": "offset.QuadPart = 0;"
    },
    {
        "line": 113,
        "fullcodeline": "ntStatus = ZwReadFile (NtFileHandle,"
    },
    {
        "line": 290,
        "fullcodeline": "request->DriveIsDynamic = FALSE;"
    },
    {
        "line": 305,
        "fullcodeline": "request->BootLoaderVersion = 0;"
    },
    {
        "line": 306,
        "fullcodeline": "request->Configuration = 0;"
    },
    {
        "line": 307,
        "fullcodeline": "request->UserConfiguration = 0;"
    },
    {
        "line": 308,
        "fullcodeline": "request->CustomUserMessage[0] = 0;"
    },
    {
        "line": 327,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 629,
        "fullcodeline": "memcpy (&g->diskGeometry, &dg, sizeof (DISK_GEOMETRY));"
    },
    {
        "line": 630,
        "fullcodeline": "g->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;"
    },
    {
        "line": 123,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 170,
        "fullcodeline": "volumeType < TC_VOLUME_TYPE_COUNT;"
    },
    {
        "line": 171,
        "fullcodeline": "volumeType++)"
    },
    {
        "line": 292,
        "fullcodeline": "if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)"
    },
    {
        "line": 311,
        "fullcodeline": "for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)"
    },
    {
        "line": 332,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 333,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 416,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)"
    },
    {
        "line": 632,
        "fullcodeline": "if (OsMajorVersion >= 6)"
    },
    {
        "line": 169,
        "fullcodeline": "for (volumeType = TC_VOLUME_TYPE_NORMAL;"
    },
    {
        "line": 186,
        "fullcodeline": "ntStatus = ZwReadFile (NtFileHandle,"
    },
    {
        "line": 634,
        "fullcodeline": "STORAGE_READ_CAPACITY storage = {0};"
    },
    {
        "line": 637,
        "fullcodeline": "Dump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);"
    },
    {
        "line": 638,
        "fullcodeline": "lStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 127,
        "fullcodeline": "if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)"
    },
    {
        "line": 140,
        "fullcodeline": "if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))"
    },
    {
        "line": 196,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 295,
        "fullcodeline": "for (i = 0; i < 4; ++i)"
    },
    {
        "line": 313,
        "fullcodeline": "if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)"
    },
    {
        "line": 641,
        "fullcodeline": "if (\tNT_SUCCESS(lStatus)"
    },
    {
        "line": 177,
        "fullcodeline": "offset.QuadPart = TC_VOLUME_HEADER_OFFSET;"
    },
    {
        "line": 182,
        "fullcodeline": "offset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;"
    },
    {
        "line": 199,
        "fullcodeline": "sha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);"
    },
    {
        "line": 200,
        "fullcodeline": "opentest->VolumeIDComputed[volumeType] = TRUE;"
    },
    {
        "line": 315,
        "fullcodeline": "request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));"
    },
    {
        "line": 316,
        "fullcodeline": "request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];"
    },
    {
        "line": 418,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)"
    },
    {
        "line": 642,
        "fullcodeline": "&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))"
    },
    {
        "line": 130,
        "fullcodeline": "for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)"
    },
    {
        "line": 297,
        "fullcodeline": "if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)"
    },
    {
        "line": 318,
        "fullcodeline": "if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)"
    },
    {
        "line": 420,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume"
    },
    {
        "line": 153,
        "fullcodeline": "opentest->FilesystemDetected = TRUE;"
    },
    {
        "line": 299,
        "fullcodeline": "request->DriveIsDynamic = TRUE;"
    },
    {
        "line": 320,
        "fullcodeline": "request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];"
    },
    {
        "line": 321,
        "fullcodeline": "memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);"
    },
    {
        "line": 132,
        "fullcodeline": "if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)"
    },
    {
        "line": 142,
        "fullcodeline": "switch (BE64 (*(uint64 *) readBuffer))"
    },
    {
        "line": 157,
        "fullcodeline": "if (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))"
    },
    {
        "line": 134,
        "fullcodeline": "opentest->TCBootLoaderDetected = TRUE;"
    },
    {
        "line": 158,
        "fullcodeline": "opentest->FilesystemDetected = TRUE;"
    }
]