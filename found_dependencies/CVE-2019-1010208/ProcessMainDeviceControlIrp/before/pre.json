[
    {
        "line": 3,
        "fullcodeline": "PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);"
    },
    {
        "line": 895,
        "fullcodeline": "return TCCompleteIrp (Irp, Irp->IoStatus.Status, Irp->IoStatus.Information);"
    },
    {
        "line": 326,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 327,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 331,
        "fullcodeline": "Irp->IoStatus.Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS;"
    },
    {
        "line": 332,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 349,
        "fullcodeline": "Irp->IoStatus.Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;"
    },
    {
        "line": 350,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 742,
        "fullcodeline": "Irp->IoStatus.Status = StartBootEncryptionSetup (DeviceObject, Irp, irpSp);"
    },
    {
        "line": 743,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 747,
        "fullcodeline": "Irp->IoStatus.Status = AbortBootEncryptionSetup();"
    },
    {
        "line": 748,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 752,
        "fullcodeline": "GetBootEncryptionStatus (Irp, irpSp);"
    },
    {
        "line": 756,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 757,
        "fullcodeline": "Irp->IoStatus.Status = GetSetupResult();"
    },
    {
        "line": 761,
        "fullcodeline": "GetBootDriveVolumeProperties (Irp, irpSp);"
    },
    {
        "line": 765,
        "fullcodeline": "GetBootLoaderVersion (Irp, irpSp);"
    },
    {
        "line": 769,
        "fullcodeline": "ReopenBootVolumeHeader (Irp, irpSp);"
    },
    {
        "line": 773,
        "fullcodeline": "GetBootLoaderFingerprint (Irp, irpSp);"
    },
    {
        "line": 777,
        "fullcodeline": "GetBootEncryptionAlgorithmName (Irp, irpSp);"
    },
    {
        "line": 790,
        "fullcodeline": "Irp->IoStatus.Status = StartDecoySystemWipe (DeviceObject, Irp, irpSp);"
    },
    {
        "line": 791,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 795,
        "fullcodeline": "Irp->IoStatus.Status = AbortDecoySystemWipe();"
    },
    {
        "line": 796,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 800,
        "fullcodeline": "Irp->IoStatus.Status = GetDecoySystemWipeResult();"
    },
    {
        "line": 801,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 805,
        "fullcodeline": "GetDecoySystemWipeStatus (Irp, irpSp);"
    },
    {
        "line": 809,
        "fullcodeline": "Irp->IoStatus.Status = WriteBootDriveSector (Irp, irpSp);"
    },
    {
        "line": 810,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 837,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 841,
        "fullcodeline": "Irp->IoStatus.Status = ReadRegistryConfigFlags (FALSE);"
    },
    {
        "line": 842,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (LONG), ValidateOutput))"
    },
    {
        "line": 20,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 29,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 44,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 68,
        "fullcodeline": "OPEN_TEST_STRUCT *opentest = (OPEN_TEST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 74,
        "fullcodeline": "ACCESS_MASK access = FILE_READ_ATTRIBUTES;"
    },
    {
        "line": 79,
        "fullcodeline": "EnsureNullTerminatedString (opentest->wszFileName, sizeof (opentest->wszFileName));"
    },
    {
        "line": 80,
        "fullcodeline": "RtlInitUnicodeString (&FullFileName, opentest->wszFileName);"
    },
    {
        "line": 82,
        "fullcodeline": "InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);"
    },
    {
        "line": 87,
        "fullcodeline": "ntStatus = ZwCreateFile (&NtFileHandle,"
    },
    {
        "line": 219,
        "fullcodeline": "Irp->IoStatus.Information = NT_SUCCESS (ntStatus) ? sizeof (OPEN_TEST_STRUCT) : 0;"
    },
    {
        "line": 220,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 226,
        "fullcodeline": "GetSystemDriveConfigurationRequest *request = (GetSystemDriveConfigurationRequest *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 237,
        "fullcodeline": "EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));"
    },
    {
        "line": 238,
        "fullcodeline": "RtlInitUnicodeString (&FullFileName, request->DevicePath);"
    },
    {
        "line": 240,
        "fullcodeline": "InitializeObjectAttributes (&ObjectAttributes, &FullFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);"
    },
    {
        "line": 242,
        "fullcodeline": "ntStatus = ZwCreateFile (&NtFileHandle,"
    },
    {
        "line": 355,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (MOUNT_LIST_STRUCT), ValidateOutput))"
    },
    {
        "line": 398,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (uint32), ValidateOutput))"
    },
    {
        "line": 413,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (VOLUME_PROPERTIES_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 465,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (RESOLVE_SYMLINK_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 484,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (DISK_PARTITION_INFO_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 545,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 565,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (DISK_GEOMETRY_EX_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 633,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (ProbeRealDriveSizeRequest), ValidateInputOutput))"
    },
    {
        "line": 676,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (MOUNT_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 709,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 730,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (UNMOUNT_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 781,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (int), ValidateOutput))"
    },
    {
        "line": 814,
        "fullcodeline": "if (ValidateIOBufferSize (Irp, sizeof (GetWarningFlagsRequest), ValidateOutput))"
    },
    {
        "line": 868,
        "fullcodeline": "return TCCompleteIrp (Irp, STATUS_INVALID_DEVICE_REQUEST, 0);"
    },
    {
        "line": 12,
        "fullcodeline": "LONG tmp = VERSION_NUM;"
    },
    {
        "line": 14,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (LONG);"
    },
    {
        "line": 15,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 23,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (int);"
    },
    {
        "line": 24,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 31,
        "fullcodeline": "LONG deviceObjectCount = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "*(int *) Irp->AssociatedIrp.SystemBuffer = DriverUnloadDisabled;"
    },
    {
        "line": 38,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (int);"
    },
    {
        "line": 39,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 61,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (int);"
    },
    {
        "line": 62,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 84,
        "fullcodeline": "if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)"
    },
    {
        "line": 91,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 232,
        "fullcodeline": "byte readBuffer [TC_SECTOR_SIZE_BIOS];"
    },
    {
        "line": 246,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 338,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_ACCESS_DENIED;"
    },
    {
        "line": 339,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 357,
        "fullcodeline": "MOUNT_LIST_STRUCT *list = (MOUNT_LIST_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 361,
        "fullcodeline": "list->ulMountedDrives = 0;"
    },
    {
        "line": 392,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 393,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (MOUNT_LIST_STRUCT);"
    },
    {
        "line": 404,
        "fullcodeline": "memset (Irp->AssociatedIrp.SystemBuffer, 0, irpSp->Parameters.DeviceIoControl.OutputBufferLength);"
    },
    {
        "line": 407,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 408,
        "fullcodeline": "Irp->IoStatus.Information = irpSp->Parameters.DeviceIoControl.OutputBufferLength;"
    },
    {
        "line": 415,
        "fullcodeline": "VOLUME_PROPERTIES_STRUCT *prop = (VOLUME_PROPERTIES_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 416,
        "fullcodeline": "PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (prop->driveNo);"
    },
    {
        "line": 418,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 419,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 467,
        "fullcodeline": "RESOLVE_SYMLINK_STRUCT *resolve = (RESOLVE_SYMLINK_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 486,
        "fullcodeline": "DISK_PARTITION_INFO_STRUCT *info = (DISK_PARTITION_INFO_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 547,
        "fullcodeline": "DISK_GEOMETRY_STRUCT *g = (DISK_GEOMETRY_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 567,
        "fullcodeline": "DISK_GEOMETRY_EX_STRUCT *g = (DISK_GEOMETRY_EX_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 635,
        "fullcodeline": "ProbeRealDriveSizeRequest *request = (ProbeRealDriveSizeRequest *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 641,
        "fullcodeline": "EnsureNullTerminatedString (request->DeviceName, sizeof (request->DeviceName));"
    },
    {
        "line": 643,
        "fullcodeline": "RtlInitUnicodeString (&name, request->DeviceName);"
    },
    {
        "line": 644,
        "fullcodeline": "status = IoGetDeviceObjectPointer (&name, FILE_READ_ATTRIBUTES, &fileObject, &deviceObject);"
    },
    {
        "line": 652,
        "fullcodeline": "status = ProbeRealDriveSize (deviceObject, &request->RealDriveSize);"
    },
    {
        "line": 678,
        "fullcodeline": "MOUNT_STRUCT *mount = (MOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 692,
        "fullcodeline": "EnsureNullTerminatedString (mount->wszVolume, sizeof (mount->wszVolume));"
    },
    {
        "line": 693,
        "fullcodeline": "EnsureNullTerminatedString (mount->wszLabel, sizeof (mount->wszLabel));"
    },
    {
        "line": 695,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (MOUNT_STRUCT);"
    },
    {
        "line": 696,
        "fullcodeline": "Irp->IoStatus.Status = MountDevice (DeviceObject, mount);"
    },
    {
        "line": 711,
        "fullcodeline": "UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 712,
        "fullcodeline": "PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject (unmount->nDosDriveNo);"
    },
    {
        "line": 714,
        "fullcodeline": "unmount->nReturnCode = ERR_DRIVE_NOT_FOUND;"
    },
    {
        "line": 724,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);"
    },
    {
        "line": 725,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 732,
        "fullcodeline": "UNMOUNT_STRUCT *unmount = (UNMOUNT_STRUCT *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 736,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (UNMOUNT_STRUCT);"
    },
    {
        "line": 737,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 784,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (int);"
    },
    {
        "line": 785,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 823,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (GetWarningFlagsRequest);"
    },
    {
        "line": 824,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 832,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 846,
        "fullcodeline": "if (\t(ValidateIOBufferSize (Irp, sizeof (GetSystemDriveDumpConfigRequest), ValidateOutput))"
    },
    {
        "line": 847,
        "fullcodeline": "&&\t(Irp->RequestorMode == KernelMode)"
    },
    {
        "line": 850,
        "fullcodeline": "GetSystemDriveDumpConfigRequest *request = (GetSystemDriveDumpConfigRequest *) Irp->AssociatedIrp.SystemBuffer;"
    },
    {
        "line": 852,
        "fullcodeline": "request->BootDriveFilterExtension = GetBootDriveFilterExtension();"
    },
    {
        "line": 49,
        "fullcodeline": "for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)"
    },
    {
        "line": 76,
        "fullcodeline": "if (!ValidateIOBufferSize (Irp, sizeof (OPEN_TEST_STRUCT), ValidateInputOutput))"
    },
    {
        "line": 85,
        "fullcodeline": "access |= FILE_READ_DATA;"
    },
    {
        "line": 88,
        "fullcodeline": "SYNCHRONIZE | access, &ObjectAttributes, &IoStatus, NULL,"
    },
    {
        "line": 89,
        "fullcodeline": "0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);"
    },
    {
        "line": 94,
        "fullcodeline": "opentest->FilesystemDetected = FALSE;"
    },
    {
        "line": 234,
        "fullcodeline": "if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))"
    },
    {
        "line": 243,
        "fullcodeline": "SYNCHRONIZE | GENERIC_READ, &ObjectAttributes, &IoStatus, NULL,"
    },
    {
        "line": 244,
        "fullcodeline": "FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS, NULL, 0);"
    },
    {
        "line": 249,
        "fullcodeline": "offset.QuadPart = 0;\t// MBR"
    },
    {
        "line": 251,
        "fullcodeline": "ntStatus = ZwReadFile (NtFileHandle,"
    },
    {
        "line": 363,
        "fullcodeline": "for (drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER; ++drive)"
    },
    {
        "line": 471,
        "fullcodeline": "EnsureNullTerminatedString (resolve->symLinkName, sizeof (resolve->symLinkName));"
    },
    {
        "line": 473,
        "fullcodeline": "ntStatus = SymbolicLinkToTarget (resolve->symLinkName,"
    },
    {
        "line": 477,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (RESOLVE_SYMLINK_STRUCT);"
    },
    {
        "line": 478,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 491,
        "fullcodeline": "EnsureNullTerminatedString (info->deviceName, sizeof (info->deviceName));"
    },
    {
        "line": 493,
        "fullcodeline": "ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &pi, sizeof (pi));"
    },
    {
        "line": 529,
        "fullcodeline": "info->IsDynamic = FALSE;"
    },
    {
        "line": 538,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (DISK_PARTITION_INFO_STRUCT);"
    },
    {
        "line": 539,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 551,
        "fullcodeline": "EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));"
    },
    {
        "line": 552,
        "fullcodeline": "Dump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);"
    },
    {
        "line": 554,
        "fullcodeline": "ntStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 558,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_STRUCT);"
    },
    {
        "line": 559,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 570,
        "fullcodeline": "PVOID buffer = TCalloc (256); // enough for DISK_GEOMETRY_EX and padded data"
    },
    {
        "line": 655,
        "fullcodeline": "if (status == STATUS_TIMEOUT)"
    },
    {
        "line": 734,
        "fullcodeline": "unmount->nReturnCode = UnmountAllDevices (unmount, unmount->ignoreOpenFiles);"
    },
    {
        "line": 835,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_ACCESS_DENIED;"
    },
    {
        "line": 35,
        "fullcodeline": "if (IoEnumerateDeviceObjectList (TCDriverObject, NULL, 0, &deviceObjectCount) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1)"
    },
    {
        "line": 98,
        "fullcodeline": "if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem || opentest->bComputeVolumeIDs)"
    },
    {
        "line": 261,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 317,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 318,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 367,
        "fullcodeline": "ListDevice = GetVirtualVolumeDeviceObject (drive);"
    },
    {
        "line": 371,
        "fullcodeline": "ListExtension = (PEXTENSION) ListDevice->DeviceExtension;"
    },
    {
        "line": 423,
        "fullcodeline": "PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;"
    },
    {
        "line": 494,
        "fullcodeline": "if (NT_SUCCESS(ntStatus))"
    },
    {
        "line": 645,
        "fullcodeline": "if (!NT_SUCCESS (status))"
    },
    {
        "line": 647,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 648,
        "fullcodeline": "Irp->IoStatus.Status = status;"
    },
    {
        "line": 658,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);"
    },
    {
        "line": 659,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 680,
        "fullcodeline": "if (mount->VolumePassword.Length > MAX_PASSWORD || mount->ProtectedHidVolPassword.Length > MAX_PASSWORD"
    },
    {
        "line": 684,
        "fullcodeline": "|| (mount->bTrueCryptMode != FALSE && mount->bTrueCryptMode != TRUE)"
    },
    {
        "line": 687,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 688,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 718,
        "fullcodeline": "PEXTENSION ListExtension = (PEXTENSION) ListDevice->DeviceExtension;"
    },
    {
        "line": 856,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 857,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (*request);"
    },
    {
        "line": 51,
        "fullcodeline": "if (GetVirtualVolumeDeviceObject (drive))"
    },
    {
        "line": 100,
        "fullcodeline": "byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);"
    },
    {
        "line": 284,
        "fullcodeline": "request->CustomUserMessage[0] = 0;"
    },
    {
        "line": 303,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 304,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (*request);"
    },
    {
        "line": 368,
        "fullcodeline": "if (!ListDevice)"
    },
    {
        "line": 372,
        "fullcodeline": "if (IsVolumeAccessibleByCurrentUser (ListExtension))"
    },
    {
        "line": 424,
        "fullcodeline": "if (IsVolumeAccessibleByCurrentUser (ListExtension))"
    },
    {
        "line": 496,
        "fullcodeline": "memset (&info->partInfo, 0, sizeof (info->partInfo));"
    },
    {
        "line": 498,
        "fullcodeline": "info->partInfo.PartitionLength = pi.PartitionLength;"
    },
    {
        "line": 499,
        "fullcodeline": "info->partInfo.PartitionNumber = pi.PartitionNumber;"
    },
    {
        "line": 500,
        "fullcodeline": "info->partInfo.StartingOffset = pi.StartingOffset;"
    },
    {
        "line": 517,
        "fullcodeline": "if (!NT_SUCCESS (ntStatus))"
    },
    {
        "line": 520,
        "fullcodeline": "ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &lengthInfo, sizeof (lengthInfo));"
    },
    {
        "line": 531,
        "fullcodeline": "if (NT_SUCCESS (ntStatus) && OsMajorVersion >= 6)"
    },
    {
        "line": 573,
        "fullcodeline": "EnsureNullTerminatedString (g->deviceName, sizeof (g->deviceName));"
    },
    {
        "line": 574,
        "fullcodeline": "Dump (\"Calling IOCTL_DISK_GET_DRIVE_GEOMETRY_EX on %ls\\n\", g->deviceName);"
    },
    {
        "line": 576,
        "fullcodeline": "ntStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 620,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (DISK_GEOMETRY_EX_STRUCT);"
    },
    {
        "line": 621,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 683,
        "fullcodeline": "|| mount->ProtectedHidVolPkcs5Prf < 0 || mount->ProtectedHidVolPkcs5Prf > LAST_PRF_ID"
    },
    {
        "line": 861,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;"
    },
    {
        "line": 862,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 101,
        "fullcodeline": "if (!readBuffer)"
    },
    {
        "line": 287,
        "fullcodeline": "for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)"
    },
    {
        "line": 308,
        "fullcodeline": "Irp->IoStatus.Status = ntStatus;"
    },
    {
        "line": 309,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 375,
        "fullcodeline": "RtlStringCbCopyW (list->wszVolume[ListExtension->nDosDriveNo], sizeof(list->wszVolume[ListExtension->nDosDriveNo]),ListExtension->wszVolume);"
    },
    {
        "line": 376,
        "fullcodeline": "RtlStringCbCopyW (list->wszLabel[ListExtension->nDosDriveNo], sizeof(list->wszLabel[ListExtension->nDosDriveNo]),ListExtension->wszLabel);"
    },
    {
        "line": 377,
        "fullcodeline": "memcpy (list->volumeID[ListExtension->nDosDriveNo], ListExtension->volumeID, VOLUME_ID_SIZE);"
    },
    {
        "line": 457,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_SUCCESS;"
    },
    {
        "line": 458,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (VOLUME_PROPERTIES_STRUCT);"
    },
    {
        "line": 502,
        "fullcodeline": "if (pi.PartitionStyle == PARTITION_STYLE_MBR)"
    },
    {
        "line": 508,
        "fullcodeline": "info->IsGPT = pi.PartitionStyle == PARTITION_STYLE_GPT;"
    },
    {
        "line": 513,
        "fullcodeline": "ntStatus = TCDeviceIoControl (info->deviceName, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &info->partInfo, sizeof (info->partInfo));"
    },
    {
        "line": 522,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 580,
        "fullcodeline": "if (NT_SUCCESS(ntStatus))"
    },
    {
        "line": 625,
        "fullcodeline": "Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;"
    },
    {
        "line": 626,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 103,
        "fullcodeline": "ntStatus = STATUS_INSUFFICIENT_RESOURCES;"
    },
    {
        "line": 268,
        "fullcodeline": "if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)"
    },
    {
        "line": 374,
        "fullcodeline": "list->ulMountedDrives |= (1 << ListExtension->nDosDriveNo);"
    },
    {
        "line": 455,
        "fullcodeline": "prop->volFormatVersion = ListExtension->cryptoInfo->LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION;"
    },
    {
        "line": 504,
        "fullcodeline": "info->partInfo.PartitionType = pi.Mbr.PartitionType;"
    },
    {
        "line": 505,
        "fullcodeline": "info->partInfo.BootIndicator = pi.Mbr.BootIndicator;"
    },
    {
        "line": 534,
        "fullcodeline": "if (!NT_SUCCESS (TCDeviceIoControl (info->deviceName, IOCTL_VOLUME_IS_DYNAMIC, NULL, 0, &info->IsDynamic, sizeof (info->IsDynamic))))"
    },
    {
        "line": 582,
        "fullcodeline": "PDISK_GEOMETRY_EX pGeo = (PDISK_GEOMETRY_EX) buffer;"
    },
    {
        "line": 661,
        "fullcodeline": "else if (!NT_SUCCESS (status))"
    },
    {
        "line": 663,
        "fullcodeline": "Irp->IoStatus.Information = 0;"
    },
    {
        "line": 664,
        "fullcodeline": "Irp->IoStatus.Status = status;"
    },
    {
        "line": 682,
        "fullcodeline": "||\tmount->VolumePim < -1 || mount->VolumePim == INT_MAX"
    },
    {
        "line": 721,
        "fullcodeline": "unmount->nReturnCode = UnmountDevice (unmount, ListDevice, unmount->ignoreOpenFiles);"
    },
    {
        "line": 271,
        "fullcodeline": "for (i = 0; i < 4; ++i)"
    },
    {
        "line": 381,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_HIDDEN;\t// Hidden volume"
    },
    {
        "line": 588,
        "fullcodeline": "DISK_GEOMETRY dg = {0};"
    },
    {
        "line": 589,
        "fullcodeline": "Dump (\"Failed. Calling IOCTL_DISK_GET_DRIVE_GEOMETRY on %ls\\n\", g->deviceName);"
    },
    {
        "line": 590,
        "fullcodeline": "ntStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 669,
        "fullcodeline": "Irp->IoStatus.Information = sizeof (ProbeRealDriveSizeRequest);"
    },
    {
        "line": 670,
        "fullcodeline": "Irp->IoStatus.Status = status;"
    },
    {
        "line": 107,
        "fullcodeline": "if (opentest->bDetectTCBootLoader || opentest->DetectFilesystem)"
    },
    {
        "line": 289,
        "fullcodeline": "if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)"
    },
    {
        "line": 291,
        "fullcodeline": "request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));"
    },
    {
        "line": 448,
        "fullcodeline": "prop->hiddenVolProtection = ListExtension->cryptoInfo->bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE;"
    },
    {
        "line": 450,
        "fullcodeline": "prop->hiddenVolProtection = HIDVOL_PROT_STATUS_NONE;"
    },
    {
        "line": 594,
        "fullcodeline": "if (NT_SUCCESS(ntStatus))"
    },
    {
        "line": 681,
        "fullcodeline": "||\tmount->pkcs5_prf < 0 || mount->pkcs5_prf > LAST_PRF_ID"
    },
    {
        "line": 111,
        "fullcodeline": "offset.QuadPart = 0;"
    },
    {
        "line": 113,
        "fullcodeline": "ntStatus = ZwReadFile (NtFileHandle,"
    },
    {
        "line": 165,
        "fullcodeline": "if (opentest->bComputeVolumeIDs && (!opentest->DetectFilesystem || !opentest->FilesystemDetected))"
    },
    {
        "line": 273,
        "fullcodeline": "if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)"
    },
    {
        "line": 123,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 170,
        "fullcodeline": "volumeType < TC_VOLUME_TYPE_COUNT;"
    },
    {
        "line": 171,
        "fullcodeline": "volumeType++)"
    },
    {
        "line": 294,
        "fullcodeline": "if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)"
    },
    {
        "line": 297,
        "fullcodeline": "memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);"
    },
    {
        "line": 383,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED;\t// Normal/outer volume (hidden volume protected AND write already prevented)"
    },
    {
        "line": 597,
        "fullcodeline": "g->DiskSize.QuadPart = dg.Cylinders.QuadPart * dg.SectorsPerTrack * dg.TracksPerCylinder * dg.BytesPerSector;"
    },
    {
        "line": 169,
        "fullcodeline": "for (volumeType = TC_VOLUME_TYPE_NORMAL;"
    },
    {
        "line": 186,
        "fullcodeline": "ntStatus = ZwReadFile (NtFileHandle,"
    },
    {
        "line": 601,
        "fullcodeline": "STORAGE_READ_CAPACITY storage = {0};"
    },
    {
        "line": 603,
        "fullcodeline": "storage.Version = sizeof (STORAGE_READ_CAPACITY);"
    },
    {
        "line": 604,
        "fullcodeline": "Dump (\"Calling IOCTL_STORAGE_READ_CAPACITY on %ls\\n\", g->deviceName);"
    },
    {
        "line": 605,
        "fullcodeline": "lStatus = TCDeviceIoControl (g->deviceName,"
    },
    {
        "line": 140,
        "fullcodeline": "if (opentest->DetectFilesystem && IoStatus.Information >= sizeof (int64))"
    },
    {
        "line": 196,
        "fullcodeline": "if (NT_SUCCESS (ntStatus))"
    },
    {
        "line": 127,
        "fullcodeline": "if (opentest->bDetectTCBootLoader && IoStatus.Information >= TC_SECTOR_SIZE_BIOS)"
    },
    {
        "line": 177,
        "fullcodeline": "offset.QuadPart = TC_VOLUME_HEADER_OFFSET;"
    },
    {
        "line": 182,
        "fullcodeline": "offset.QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET;"
    },
    {
        "line": 199,
        "fullcodeline": "sha256 (opentest->volumeIDs[volumeType], readBuffer, TC_VOLUME_HEADER_EFFECTIVE_SIZE);"
    },
    {
        "line": 385,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_OUTER;\t// Normal/outer volume (hidden volume protected)"
    },
    {
        "line": 608,
        "fullcodeline": "if (\tNT_SUCCESS(lStatus)"
    },
    {
        "line": 609,
        "fullcodeline": "&& (storage.Size == sizeof (STORAGE_READ_CAPACITY))"
    },
    {
        "line": 130,
        "fullcodeline": "for (i = 0; i < TC_SECTOR_SIZE_BIOS - strlen (TC_APP_NAME); ++i)"
    },
    {
        "line": 387,
        "fullcodeline": "list->volumeType[ListExtension->nDosDriveNo] = PROP_VOL_TYPE_NORMAL;\t// Normal volume"
    },
    {
        "line": 153,
        "fullcodeline": "opentest->FilesystemDetected = TRUE;"
    },
    {
        "line": 132,
        "fullcodeline": "if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)"
    },
    {
        "line": 157,
        "fullcodeline": "if (IsAllZeroes (readBuffer + 8, TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8))"
    },
    {
        "line": 158,
        "fullcodeline": "opentest->FilesystemDetected = TRUE;"
    }
]