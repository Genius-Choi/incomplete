[
    {
        "line": 9,
        "fullcodeline": "buf = mempool_alloc(buf_pool);"
    },
    {
        "line": 15,
        "fullcodeline": "memset(buf, 0, L2TP_MAX_PACKET_SIZE);"
    },
    {
        "line": 16,
        "fullcodeline": "hdr = (struct l2tp_hdr_t *)buf;"
    },
    {
        "line": 17,
        "fullcodeline": "ptr = (uint8_t *)(hdr + 1);"
    },
    {
        "line": 20,
        "fullcodeline": "list_for_each_entry(attr, &pack->attrs, entry) {"
    },
    {
        "line": 53,
        "fullcodeline": "pack->hdr.length = htons(len);"
    },
    {
        "line": 54,
        "fullcodeline": "memcpy(buf, &pack->hdr, sizeof(pack->hdr));"
    },
    {
        "line": 55,
        "fullcodeline": "hdr->flags = htons(pack->hdr.flags);"
    },
    {
        "line": 57,
        "fullcodeline": "n = sendto(sock, buf, len, 0, &pack->addr, sizeof(pack->addr));"
    },
    {
        "line": 58,
        "fullcodeline": "mempool_free(buf);"
    },
    {
        "line": 10,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 26,
        "fullcodeline": "avp = (struct l2tp_avp_t *)ptr;"
    },
    {
        "line": 27,
        "fullcodeline": "avp->type = htons(attr->attr->id);"
    },
    {
        "line": 28,
        "fullcodeline": "avp->flags = htons((attr->M ? L2TP_AVP_FLAG_M : 0) |"
    },
    {
        "line": 49,
        "fullcodeline": "ptr += sizeof(*avp) + attr->length;"
    },
    {
        "line": 50,
        "fullcodeline": "len += sizeof(*avp) + attr->length;"
    },
    {
        "line": 60,
        "fullcodeline": "if (n < 0) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (n != len) {"
    },
    {
        "line": 11,
        "fullcodeline": "log_emerg(\"l2tp: out of memory\\n\");"
    },
    {
        "line": 21,
        "fullcodeline": "if (len + sizeof(*avp) + attr->length >= L2TP_MAX_PACKET_SIZE) {"
    },
    {
        "line": 12,
        "fullcodeline": "return -1;"
    },
    {
        "line": 22,
        "fullcodeline": "log_error(\"l2tp: cann't send packet (exceeds maximum size)\\n\");"
    },
    {
        "line": 23,
        "fullcodeline": "mempool_free(buf);"
    },
    {
        "line": 32,
        "fullcodeline": "memcpy(avp->val, attr->val.octets, attr->length);"
    },
    {
        "line": 61,
        "fullcodeline": "if (errno == EAGAIN) {"
    },
    {
        "line": 24,
        "fullcodeline": "return -1;"
    },
    {
        "line": 30,
        "fullcodeline": "((sizeof(*avp) + attr->length) & L2TP_AVP_LEN_MASK));"
    },
    {
        "line": 73,
        "fullcodeline": "log_warn(\"l2tp: short write (%i/%i)\\n\", n, len);"
    },
    {
        "line": 29,
        "fullcodeline": "(attr->H ? L2TP_AVP_FLAG_H : 0) |"
    },
    {
        "line": 36,
        "fullcodeline": "*(int16_t *)avp->val = htons(attr->val.int16);"
    },
    {
        "line": 39,
        "fullcodeline": "*(int32_t *)avp->val = htonl(attr->val.int32);"
    },
    {
        "line": 42,
        "fullcodeline": "*(uint64_t *)avp->val = htobe64(attr->val.uint64);"
    },
    {
        "line": 46,
        "fullcodeline": "memcpy(avp->val, attr->val.string, attr->length);"
    },
    {
        "line": 63,
        "fullcodeline": "log_warn(\"l2tp: buffer overflow (packet lost)\\n\");"
    },
    {
        "line": 67,
        "fullcodeline": "return -1;"
    },
    {
        "line": 66,
        "fullcodeline": "log_warn(\"l2tp: sendto: %s\\n\", strerror(errno));"
    }
]