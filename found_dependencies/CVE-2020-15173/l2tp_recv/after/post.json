[
    {
        "line": 7,
        "fullcodeline": "struct l2tp_attr_t *RV = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "*p = NULL;"
    },
    {
        "line": 42,
        "fullcodeline": "buf = mempool_alloc(buf_pool);"
    },
    {
        "line": 47,
        "fullcodeline": "hdr = (struct l2tp_hdr_t *)buf;"
    },
    {
        "line": 48,
        "fullcodeline": "ptr = (uint8_t *)(hdr + 1);"
    },
    {
        "line": 51,
        "fullcodeline": "n = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &addr_len);"
    },
    {
        "line": 69,
        "fullcodeline": "hdr->flags = ntohs(hdr->flags);"
    },
    {
        "line": 99,
        "fullcodeline": "length = ntohs(hdr->length);"
    },
    {
        "line": 110,
        "fullcodeline": "pack = mempool_alloc(pack_pool);"
    },
    {
        "line": 116,
        "fullcodeline": "memset(pack, 0, sizeof(*pack));"
    },
    {
        "line": 117,
        "fullcodeline": "INIT_LIST_HEAD(&pack->attrs);"
    },
    {
        "line": 119,
        "fullcodeline": "memcpy(&pack->addr, &addr, sizeof(addr));"
    },
    {
        "line": 120,
        "fullcodeline": "memcpy(&pack->hdr, hdr, sizeof(*hdr));"
    },
    {
        "line": 121,
        "fullcodeline": "length -= sizeof(*hdr);"
    },
    {
        "line": 247,
        "fullcodeline": "*p = pack;"
    },
    {
        "line": 249,
        "fullcodeline": "mempool_free(buf);"
    },
    {
        "line": 254,
        "fullcodeline": "l2tp_packet_free(pack);"
    },
    {
        "line": 256,
        "fullcodeline": "mempool_free(buf);"
    },
    {
        "line": 263,
        "fullcodeline": "log_emerg(\"l2tp: out of memory\\n\");"
    },
    {
        "line": 43,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (n < 0) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (n < sizeof(*hdr)) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (!(hdr->flags & L2TP_FLAG_T))"
    },
    {
        "line": 72,
        "fullcodeline": "if (!(hdr->flags & L2TP_FLAG_L)) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (!(hdr->flags & L2TP_FLAG_S)) {"
    },
    {
        "line": 82,
        "fullcodeline": "switch (hdr->flags & L2TP_VER_MASK) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (length < sizeof(*hdr)) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (!pack) {"
    },
    {
        "line": 123,
        "fullcodeline": "while (length > 0) {"
    },
    {
        "line": 20,
        "fullcodeline": "char msg_control[128];"
    },
    {
        "line": 22,
        "fullcodeline": "memset(&msg, 0, sizeof(msg));"
    },
    {
        "line": 23,
        "fullcodeline": "msg.msg_control = msg_control;"
    },
    {
        "line": 26,
        "fullcodeline": "n = recvmsg(fd, &msg, MSG_PEEK);"
    },
    {
        "line": 44,
        "fullcodeline": "log_emerg(\"l2tp: out of memory\\n\");"
    },
    {
        "line": 53,
        "fullcodeline": "mempool_free(buf);"
    },
    {
        "line": 59,
        "fullcodeline": "log_error(\"l2tp: recv: %s\\n\", strerror(errno));"
    },
    {
        "line": 112,
        "fullcodeline": "log_emerg(\"l2tp: out of memory\\n\");"
    },
    {
        "line": 134,
        "fullcodeline": "avp = (struct l2tp_avp_t *)ptr;"
    },
    {
        "line": 135,
        "fullcodeline": "avp->flags = ntohs(avp->flags);"
    },
    {
        "line": 136,
        "fullcodeline": "avp_len = avp->flags & L2TP_AVP_LEN_MASK;"
    },
    {
        "line": 150,
        "fullcodeline": "da = l2tp_dict_find_attr_by_id(ntohs(avp->type));"
    },
    {
        "line": 243,
        "fullcodeline": "ptr += avp_len;"
    },
    {
        "line": 244,
        "fullcodeline": "length -= avp_len;"
    },
    {
        "line": 260,
        "fullcodeline": "log_warn(\"l2tp: incorrect avp received (type=%i, incorrect length %i)\\n\", ntohs(avp->type), orig_avp_len);"
    },
    {
        "line": 27,
        "fullcodeline": "if (n < 0) {"
    },
    {
        "line": 34,
        "fullcodeline": "for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (errno == EAGAIN) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (hdr->flags & L2TP_FLAG_O) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (length < sizeof(*avp)) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (avp_len < sizeof(*avp)) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (!da) {"
    },
    {
        "line": 30,
        "fullcodeline": "log_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));"
    },
    {
        "line": 65,
        "fullcodeline": "log_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));"
    },
    {
        "line": 74,
        "fullcodeline": "log_warn(\"l2tp: incorrect control message received (L=0)\\n\");"
    },
    {
        "line": 79,
        "fullcodeline": "log_warn(\"l2tp: incorrect control message received (S=0)\\n\");"
    },
    {
        "line": 94,
        "fullcodeline": "log_warn(\"l2tp: protocol version %i is not supported\\n\","
    },
    {
        "line": 102,
        "fullcodeline": "log_warn(\"l2tp: short packet received (%i/%zu)\\n\", length, sizeof(*hdr));"
    },
    {
        "line": 104,
        "fullcodeline": "} else if (n < length) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (errno == EAGAIN)"
    },
    {
        "line": 35,
        "fullcodeline": "if (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {"
    },
    {
        "line": 55,
        "fullcodeline": "return -1;"
    },
    {
        "line": 95,
        "fullcodeline": "hdr->flags & L2TP_VER_MASK);"
    },
    {
        "line": 156,
        "fullcodeline": "if ((avp->flags & L2TP_AVP_FLAG_M) && !conf_avp_permissive)"
    },
    {
        "line": 200,
        "fullcodeline": "attr = mempool_alloc(attr_pool);"
    },
    {
        "line": 201,
        "fullcodeline": "memset(attr, 0, sizeof(*attr));"
    },
    {
        "line": 202,
        "fullcodeline": "attr->attr = da;"
    },
    {
        "line": 203,
        "fullcodeline": "attr->M = !!(avp->flags & L2TP_AVP_FLAG_M);"
    },
    {
        "line": 204,
        "fullcodeline": "attr->H = 0;"
    },
    {
        "line": 205,
        "fullcodeline": "attr->length = orig_avp_len - sizeof(*avp);"
    },
    {
        "line": 206,
        "fullcodeline": "list_add_tail(&attr->entry, &pack->attrs);"
    },
    {
        "line": 36,
        "fullcodeline": "memcpy(pkt_info, CMSG_DATA(cmsg), sizeof(*pkt_info));"
    },
    {
        "line": 56,
        "fullcodeline": "} else if (errno == ECONNREFUSED) {"
    },
    {
        "line": 86,
        "fullcodeline": "log_warn(\"l2tp: incorrect control message received (O=1)\\n\");"
    },
    {
        "line": 130,
        "fullcodeline": "log_warn(\"l2tp: short avp received\\n\");"
    },
    {
        "line": 139,
        "fullcodeline": "log_warn(\"l2tp: short avp received\\n\");"
    },
    {
        "line": 141,
        "fullcodeline": "} else if (length < avp_len) {"
    },
    {
        "line": 153,
        "fullcodeline": "log_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\","
    },
    {
        "line": 159,
        "fullcodeline": "if (da->M != -1 && !da->M != !(avp->flags & L2TP_AVP_FLAG_M)) {"
    },
    {
        "line": 168,
        "fullcodeline": "if (da->H != -1 && !da->H != !(avp->flags & L2TP_AVP_FLAG_H)) {"
    },
    {
        "line": 177,
        "fullcodeline": "if (avp->flags & L2TP_AVP_FLAG_H) {"
    },
    {
        "line": 208,
        "fullcodeline": "if (attr->attr->id == Random_Vector)"
    },
    {
        "line": 29,
        "fullcodeline": "return -1;"
    },
    {
        "line": 106,
        "fullcodeline": "log_warn(\"l2tp: short packet received (%i/%i)\\n\", n, length);"
    },
    {
        "line": 154,
        "fullcodeline": "ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M));"
    },
    {
        "line": 193,
        "fullcodeline": "orig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);"
    },
    {
        "line": 194,
        "fullcodeline": "orig_avp_val = avp->val + sizeof(uint16_t);"
    },
    {
        "line": 209,
        "fullcodeline": "RV = attr;"
    },
    {
        "line": 215,
        "fullcodeline": "attr->val.uint16 = ntohs(*(uint16_t *)orig_avp_val);"
    },
    {
        "line": 220,
        "fullcodeline": "attr->val.uint32 = ntohl(*(uint32_t *)orig_avp_val);"
    },
    {
        "line": 225,
        "fullcodeline": "attr->val.uint64 = be64toh(*(uint64_t *)orig_avp_val);"
    },
    {
        "line": 228,
        "fullcodeline": "attr->val.octets = _malloc(attr->length);"
    },
    {
        "line": 231,
        "fullcodeline": "memcpy(attr->val.octets, orig_avp_val, attr->length);"
    },
    {
        "line": 234,
        "fullcodeline": "attr->val.string = _malloc(attr->length + 1);"
    },
    {
        "line": 237,
        "fullcodeline": "memcpy(attr->val.string, orig_avp_val, attr->length);"
    },
    {
        "line": 238,
        "fullcodeline": "attr->val.string[attr->length] = 0;"
    },
    {
        "line": 57,
        "fullcodeline": "return -2;"
    },
    {
        "line": 164,
        "fullcodeline": "if (!conf_avp_permissive)"
    },
    {
        "line": 173,
        "fullcodeline": "if (!conf_avp_permissive)"
    },
    {
        "line": 178,
        "fullcodeline": "if (!RV) {"
    },
    {
        "line": 183,
        "fullcodeline": "if (secret == NULL || secret_len == 0) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (decode_avp(avp, RV, secret, secret_len) < 0)"
    },
    {
        "line": 196,
        "fullcodeline": "orig_avp_len = avp_len;"
    },
    {
        "line": 197,
        "fullcodeline": "orig_avp_val = avp->val;"
    },
    {
        "line": 213,
        "fullcodeline": "if (orig_avp_len != sizeof(*avp) + 2)"
    },
    {
        "line": 218,
        "fullcodeline": "if (orig_avp_len != sizeof(*avp) + 4)"
    },
    {
        "line": 223,
        "fullcodeline": "if (orig_avp_len != sizeof(*avp) + 8)"
    },
    {
        "line": 229,
        "fullcodeline": "if (!attr->val.octets)"
    },
    {
        "line": 235,
        "fullcodeline": "if (!attr->val.string)"
    },
    {
        "line": 143,
        "fullcodeline": "log_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");"
    },
    {
        "line": 161,
        "fullcodeline": "log_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\","
    },
    {
        "line": 170,
        "fullcodeline": "log_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\","
    },
    {
        "line": 184,
        "fullcodeline": "log_error(\"l2tp: impossible to decode\""
    },
    {
        "line": 162,
        "fullcodeline": "ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M), da->M);"
    },
    {
        "line": 171,
        "fullcodeline": "ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_H), da->H);"
    },
    {
        "line": 187,
        "fullcodeline": "ntohs(avp->type));"
    },
    {
        "line": 180,
        "fullcodeline": "log_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));"
    }
]