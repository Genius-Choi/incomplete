[
    {
        "line": 3,
        "fullcodeline": "PyMemoEntry *oldtable = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "Py_ssize_t new_size = MT_MINSIZE;"
    },
    {
        "line": 8,
        "fullcodeline": "assert(min_size > 0);"
    },
    {
        "line": 21,
        "fullcodeline": "oldtable = self->mt_table;"
    },
    {
        "line": 22,
        "fullcodeline": "self->mt_table = PyMem_NEW(PyMemoEntry, new_size);"
    },
    {
        "line": 28,
        "fullcodeline": "self->mt_allocated = new_size;"
    },
    {
        "line": 29,
        "fullcodeline": "self->mt_mask = new_size - 1;"
    },
    {
        "line": 30,
        "fullcodeline": "memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);"
    },
    {
        "line": 33,
        "fullcodeline": "to_process = self->mt_used;"
    },
    {
        "line": 11,
        "fullcodeline": "while (new_size < min_size && new_size > 0)"
    },
    {
        "line": 12,
        "fullcodeline": "new_size <<= 1;"
    },
    {
        "line": 13,
        "fullcodeline": "if (new_size <= 0) {"
    },
    {
        "line": 18,
        "fullcodeline": "assert((new_size & (new_size - 1)) == 0);"
    },
    {
        "line": 23,
        "fullcodeline": "if (self->mt_table == NULL) {"
    },
    {
        "line": 34,
        "fullcodeline": "for (oldentry = oldtable; to_process > 0; oldentry++) {"
    },
    {
        "line": 14,
        "fullcodeline": "PyErr_NoMemory();"
    },
    {
        "line": 15,
        "fullcodeline": "return -1;"
    },
    {
        "line": 26,
        "fullcodeline": "return -1;"
    },
    {
        "line": 35,
        "fullcodeline": "if (oldentry->me_key != NULL) {"
    },
    {
        "line": 36,
        "fullcodeline": "to_process--;"
    },
    {
        "line": 40,
        "fullcodeline": "newentry = _PyMemoTable_Lookup(self, oldentry->me_key);"
    }
]