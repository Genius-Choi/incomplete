[
    {
        "line": 3,
        "fullcodeline": "PyMemoEntry *oldtable = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "size_t new_size = MT_MINSIZE;"
    },
    {
        "line": 8,
        "fullcodeline": "assert(min_size > 0);"
    },
    {
        "line": 23,
        "fullcodeline": "oldtable = self->mt_table;"
    },
    {
        "line": 24,
        "fullcodeline": "self->mt_table = PyMem_NEW(PyMemoEntry, new_size);"
    },
    {
        "line": 30,
        "fullcodeline": "self->mt_allocated = new_size;"
    },
    {
        "line": 31,
        "fullcodeline": "self->mt_mask = new_size - 1;"
    },
    {
        "line": 32,
        "fullcodeline": "memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);"
    },
    {
        "line": 35,
        "fullcodeline": "to_process = self->mt_used;"
    },
    {
        "line": 10,
        "fullcodeline": "if (min_size > PY_SSIZE_T_MAX) {"
    },
    {
        "line": 16,
        "fullcodeline": "while (new_size < min_size) {"
    },
    {
        "line": 20,
        "fullcodeline": "assert((new_size & (new_size - 1)) == 0);"
    },
    {
        "line": 25,
        "fullcodeline": "if (self->mt_table == NULL) {"
    },
    {
        "line": 36,
        "fullcodeline": "for (oldentry = oldtable; to_process > 0; oldentry++) {"
    },
    {
        "line": 11,
        "fullcodeline": "PyErr_NoMemory();"
    },
    {
        "line": 17,
        "fullcodeline": "new_size <<= 1;"
    },
    {
        "line": 12,
        "fullcodeline": "return -1;"
    },
    {
        "line": 28,
        "fullcodeline": "return -1;"
    },
    {
        "line": 37,
        "fullcodeline": "if (oldentry->me_key != NULL) {"
    },
    {
        "line": 38,
        "fullcodeline": "to_process--;"
    },
    {
        "line": 42,
        "fullcodeline": "newentry = _PyMemoTable_Lookup(self, oldentry->me_key);"
    }
]