[
    {
        "line": 3,
        "fullcodeline": "static const char module[] = \"PixarLogDecode\";"
    },
    {
        "line": 4,
        "fullcodeline": "TIFFDirectory *td = &tif->tif_dir;"
    },
    {
        "line": 5,
        "fullcodeline": "PixarLogState* sp = DecoderState(tif);"
    },
    {
        "line": 31,
        "fullcodeline": "llen = sp->stride * td->td_imagewidth;"
    },
    {
        "line": 35,
        "fullcodeline": "sp->stream.next_out = (unsigned char *) sp->tbuf;"
    },
    {
        "line": 40,
        "fullcodeline": "sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));"
    },
    {
        "line": 80,
        "fullcodeline": "up = sp->tbuf;"
    },
    {
        "line": 34,
        "fullcodeline": "assert(sp != NULL);"
    },
    {
        "line": 36,
        "fullcodeline": "assert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,"
    },
    {
        "line": 41,
        "fullcodeline": "if (sp->stream.avail_out != nsamples * sizeof(uint16))"
    },
    {
        "line": 47,
        "fullcodeline": "if (sp->stream.avail_out > sp->tbuf_size)"
    },
    {
        "line": 70,
        "fullcodeline": "} while (sp->stream.avail_out > 0);"
    },
    {
        "line": 82,
        "fullcodeline": "if (tif->tif_flags & TIFF_SWAB)"
    },
    {
        "line": 90,
        "fullcodeline": "if (nsamples % llen) {"
    },
    {
        "line": 97,
        "fullcodeline": "for (i = 0; i < nsamples; i += llen, up += llen) {"
    },
    {
        "line": 13,
        "fullcodeline": "nsamples = occ / sizeof(float);\t/* XXX float == 32 bits */"
    },
    {
        "line": 18,
        "fullcodeline": "nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */"
    },
    {
        "line": 22,
        "fullcodeline": "nsamples = occ;"
    },
    {
        "line": 25,
        "fullcodeline": "TIFFErrorExt(tif->tif_clientdata, module,"
    },
    {
        "line": 53,
        "fullcodeline": "int state = inflate(&sp->stream, Z_PARTIAL_FLUSH);"
    },
    {
        "line": 83,
        "fullcodeline": "TIFFSwabArrayOfShort(up, nsamples);"
    },
    {
        "line": 91,
        "fullcodeline": "TIFFWarningExt(tif->tif_clientdata, module,"
    },
    {
        "line": 94,
        "fullcodeline": "nsamples -= nsamples % llen;"
    },
    {
        "line": 54,
        "fullcodeline": "if (state == Z_STREAM_END) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (state == Z_DATA_ERROR) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (state != Z_OK) {"
    },
    {
        "line": 58,
        "fullcodeline": "TIFFErrorExt(tif->tif_clientdata, module,"
    },
    {
        "line": 100,
        "fullcodeline": "horizontalAccumulateF(up, llen, sp->stride,"
    },
    {
        "line": 102,
        "fullcodeline": "op += llen * sizeof(float);"
    },
    {
        "line": 105,
        "fullcodeline": "horizontalAccumulate16(up, llen, sp->stride,"
    },
    {
        "line": 107,
        "fullcodeline": "op += llen * sizeof(uint16);"
    },
    {
        "line": 110,
        "fullcodeline": "horizontalAccumulate12(up, llen, sp->stride,"
    },
    {
        "line": 112,
        "fullcodeline": "op += llen * sizeof(int16);"
    },
    {
        "line": 115,
        "fullcodeline": "horizontalAccumulate11(up, llen, sp->stride,"
    },
    {
        "line": 117,
        "fullcodeline": "op += llen * sizeof(uint16);"
    },
    {
        "line": 120,
        "fullcodeline": "horizontalAccumulate8(up, llen, sp->stride,"
    },
    {
        "line": 122,
        "fullcodeline": "op += llen * sizeof(unsigned char);"
    },
    {
        "line": 125,
        "fullcodeline": "horizontalAccumulate8abgr(up, llen, sp->stride,"
    },
    {
        "line": 127,
        "fullcodeline": "op += llen * sizeof(unsigned char);"
    },
    {
        "line": 61,
        "fullcodeline": "if (inflateSync(&sp->stream) != Z_OK)"
    }
]