[
    {
        "line": 3,
        "fullcodeline": "if (socket()->bytesAvailable() < 4)"
    },
    {
        "line": 10,
        "fullcodeline": "if (!_magicReceived) {"
    },
    {
        "line": 37,
        "fullcodeline": "while (socket()->bytesAvailable() >= 4 && _supportedProtos.size() < 16) { // sanity check"
    },
    {
        "line": 12,
        "fullcodeline": "socket()->peek((char*)&magic, 4);"
    },
    {
        "line": 13,
        "fullcodeline": "magic = qFromBigEndian<quint32>(magic);"
    },
    {
        "line": 25,
        "fullcodeline": "_magicReceived = true;"
    },
    {
        "line": 26,
        "fullcodeline": "quint8 features = magic & 0xff;"
    },
    {
        "line": 33,
        "fullcodeline": "socket()->read((char*)&magic, 4); // read the 4 bytes we've just peeked at"
    },
    {
        "line": 39,
        "fullcodeline": "socket()->read((char*)&data, 4);"
    },
    {
        "line": 40,
        "fullcodeline": "data = qFromBigEndian<quint32>(data);"
    },
    {
        "line": 42,
        "fullcodeline": "Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);"
    },
    {
        "line": 43,
        "fullcodeline": "quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);"
    },
    {
        "line": 44,
        "fullcodeline": "_supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));"
    },
    {
        "line": 15,
        "fullcodeline": "if ((magic & 0xffffff00) != Protocol::magic) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (Core::sslSupported() && (features & Protocol::Encryption))"
    },
    {
        "line": 30,
        "fullcodeline": "if (features & Protocol::Compression)"
    },
    {
        "line": 46,
        "fullcodeline": "if (data >= 0x80000000) { // last protocol"
    },
    {
        "line": 17,
        "fullcodeline": "qDebug() << \"Legacy client detected, switching to compatibility mode\";"
    },
    {
        "line": 18,
        "fullcodeline": "_legacy = true;"
    },
    {
        "line": 19,
        "fullcodeline": "RemotePeer *peer = PeerFactory::createPeer(PeerFactory::ProtoDescriptor(Protocol::LegacyProtocol, 0), this, socket(), Compressor::NoCompression, this);"
    },
    {
        "line": 21,
        "fullcodeline": "setPeer(peer);"
    },
    {
        "line": 29,
        "fullcodeline": "_connectionFeatures |= Protocol::Encryption;"
    },
    {
        "line": 31,
        "fullcodeline": "_connectionFeatures |= Protocol::Compression;"
    },
    {
        "line": 53,
        "fullcodeline": "RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), level, this);"
    },
    {
        "line": 64,
        "fullcodeline": "setPeer(peer);"
    },
    {
        "line": 67,
        "fullcodeline": "quint32 reply = peer->protocol() | peer->enabledFeatures()<<8 | _connectionFeatures<<24;"
    },
    {
        "line": 68,
        "fullcodeline": "reply = qToBigEndian<quint32>(reply);"
    },
    {
        "line": 69,
        "fullcodeline": "socket()->write((char*)&reply, 4);"
    },
    {
        "line": 70,
        "fullcodeline": "socket()->flush();"
    },
    {
        "line": 48,
        "fullcodeline": "if (_connectionFeatures & Protocol::Compression)"
    },
    {
        "line": 54,
        "fullcodeline": "if (!peer) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (peer->protocol() == Protocol::LegacyProtocol) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (!_legacy && (_connectionFeatures & Protocol::Encryption))"
    },
    {
        "line": 55,
        "fullcodeline": "qWarning() << \"Received invalid handshake data from client\" << socket()->peerAddress().toString();"
    },
    {
        "line": 56,
        "fullcodeline": "close();"
    },
    {
        "line": 61,
        "fullcodeline": "_legacy = true;"
    },
    {
        "line": 73,
        "fullcodeline": "startSsl(); // legacy peer enables it later"
    }
]