[
    {
        "line": 5,
        "fullcodeline": "const CPUDevice& d = context->eigen_device<CPUDevice>();"
    },
    {
        "line": 9,
        "fullcodeline": "TF_RETURN_IF_ERROR(context->forward_input_or_allocate_temp("
    },
    {
        "line": 12,
        "fullcodeline": "auto index_to_bin = index_to_bin_tensor.flat<int32>();"
    },
    {
        "line": 14,
        "fullcodeline": "const double step = static_cast<double>(value_range(1) - value_range(0)) /"
    },
    {
        "line": 16,
        "fullcodeline": "const double nbins_minus_1 = static_cast<double>(nbins - 1);"
    },
    {
        "line": 19,
        "fullcodeline": "const Eigen::Tensor<int32, 1, 1> nans_tensor ="
    },
    {
        "line": 21,
        "fullcodeline": "const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();"
    },
    {
        "line": 22,
        "fullcodeline": "const int num_nans = reduced_tensor(0);"
    },
    {
        "line": 20,
        "fullcodeline": "values.isnan().template cast<int32>();"
    },
    {
        "line": 23,
        "fullcodeline": "if (num_nans > 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "index_to_bin.device(d) ="
    },
    {
        "line": 36,
        "fullcodeline": "((values.cwiseMax(value_range(0)) - values.constant(value_range(0)))"
    },
    {
        "line": 43,
        "fullcodeline": "for (int32_t i = 0; i < index_to_bin.size(); i++) {"
    },
    {
        "line": 46,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 10,
        "fullcodeline": "{0}, DataTypeToEnum<int32>::value, TensorShape({values.size()}),"
    },
    {
        "line": 24,
        "fullcodeline": "return errors::InvalidArgument(\"Histogram values must not contain NaN\");"
    },
    {
        "line": 44,
        "fullcodeline": "out(index_to_bin(i)) += Tout(1);"
    }
]