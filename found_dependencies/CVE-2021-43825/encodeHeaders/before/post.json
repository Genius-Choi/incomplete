[
    {
        "line": 12,
        "fullcodeline": "const auto transformation = connection_manager_.config_.serverHeaderTransformation();"
    },
    {
        "line": 18,
        "fullcodeline": "ConnectionManagerUtility::mutateResponseHeaders("
    },
    {
        "line": 23,
        "fullcodeline": "bool drain_connection_due_to_overload = false;"
    },
    {
        "line": 111,
        "fullcodeline": "chargeStats(headers);"
    },
    {
        "line": 113,
        "fullcodeline": "ENVOY_STREAM_LOG(debug, \"encoding headers via codec (end_stream={}):\\n{}\", *this, end_stream,"
    },
    {
        "line": 117,
        "fullcodeline": "filter_manager_.streamInfo().downstreamTiming().onFirstDownstreamTxByteSent("
    },
    {
        "line": 119,
        "fullcodeline": "response_encoder_->encodeHeaders(headers, end_stream);"
    },
    {
        "line": 6,
        "fullcodeline": "if (!headers.Date()) {"
    },
    {
        "line": 13,
        "fullcodeline": "if (transformation == ConnectionManagerConfig::HttpConnectionManagerProto::OVERWRITE ||"
    },
    {
        "line": 19,
        "fullcodeline": "headers, request_headers_.get(), connection_manager_.config_,"
    },
    {
        "line": 20,
        "fullcodeline": "connection_manager_.config_.via(), filter_manager_.streamInfo(),"
    },
    {
        "line": 24,
        "fullcodeline": "if (connection_manager_.drain_state_ == DrainState::NotDraining &&"
    },
    {
        "line": 34,
        "fullcodeline": "if (connection_manager_.drain_state_ == DrainState::NotDraining &&"
    },
    {
        "line": 45,
        "fullcodeline": "if (connection_manager_.codec_->protocol() == Protocol::Http10) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (connection_manager_.drain_state_ == DrainState::NotDraining && state_.saw_connection_close_) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (!filter_manager_.remoteComplete()) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (connection_manager_.drain_state_ != DrainState::NotDraining &&"
    },
    {
        "line": 85,
        "fullcodeline": "if (connection_manager_.config_.tracingConfig()) {"
    },
    {
        "line": 7,
        "fullcodeline": "connection_manager_.config_.dateProvider().setDateHeader(headers);"
    },
    {
        "line": 14,
        "fullcodeline": "(transformation == ConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT &&"
    },
    {
        "line": 16,
        "fullcodeline": "headers.setReferenceServer(connection_manager_.config_.serverName());"
    },
    {
        "line": 25,
        "fullcodeline": "connection_manager_.random_generator_.bernoulli("
    },
    {
        "line": 27,
        "fullcodeline": "ENVOY_STREAM_LOG(debug, \"disabling keepalive due to envoy overload\", *this);"
    },
    {
        "line": 28,
        "fullcodeline": "drain_connection_due_to_overload = true;"
    },
    {
        "line": 35,
        "fullcodeline": "(connection_manager_.drain_close_.drainClose() || drain_connection_due_to_overload)) {"
    },
    {
        "line": 40,
        "fullcodeline": "connection_manager_.startDrainSequence();"
    },
    {
        "line": 42,
        "fullcodeline": "ENVOY_STREAM_LOG(debug, \"drain closing connection\", *this);"
    },
    {
        "line": 59,
        "fullcodeline": "ENVOY_STREAM_LOG(debug, \"closing connection due to connection close header\", *this);"
    },
    {
        "line": 75,
        "fullcodeline": "connection_manager_.codec_->protocol() < Protocol::Http2) {"
    },
    {
        "line": 15,
        "fullcodeline": "headers.Server() == nullptr)) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (!headers.ContentLength()) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (!state_.saw_connection_close_) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (connection_manager_.codec_->protocol() < Protocol::Http2) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (!Utility::isUpgrade(headers) &&"
    },
    {
        "line": 49,
        "fullcodeline": "state_.saw_connection_close_ = true;"
    },
    {
        "line": 54,
        "fullcodeline": "headers.setConnection(Headers::get().ConnectionValues.KeepAlive);"
    },
    {
        "line": 80,
        "fullcodeline": "!HeaderUtility::isConnectResponse(request_headers_.get(), *responseHeaders())) {"
    },
    {
        "line": 81,
        "fullcodeline": "headers.setReferenceConnection(Headers::get().ConnectionValues.Close);"
    },
    {
        "line": 86,
        "fullcodeline": "if (connection_manager_.config_.tracingConfig()->operation_name_ =="
    },
    {
        "line": 92,
        "fullcodeline": "if (decorated_operation_ && state_.decorated_propagate_) {"
    },
    {
        "line": 93,
        "fullcodeline": "headers.setEnvoyDecoratorOperation(*decorated_operation_);"
    },
    {
        "line": 95,
        "fullcodeline": "} else if (connection_manager_.config_.tracingConfig()->operation_name_ =="
    },
    {
        "line": 97,
        "fullcodeline": "const HeaderEntry* resp_operation_override = headers.EnvoyDecoratorOperation();"
    },
    {
        "line": 106,
        "fullcodeline": "headers.removeEnvoyDecoratorOperation();"
    },
    {
        "line": 102,
        "fullcodeline": "if (!resp_operation_override->value().empty() && active_span_) {"
    },
    {
        "line": 103,
        "fullcodeline": "active_span_->setOperation(resp_operation_override->value().getStringView());"
    }
]