[
    {
        "line": 3,
        "fullcodeline": "filter_manager_callbacks_.resetIdleTimer();"
    },
    {
        "line": 6,
        "fullcodeline": "std::list<ActiveStreamEncoderFilterPtr>::iterator entry ="
    },
    {
        "line": 33,
        "fullcodeline": "filter_manager_callbacks_.encodeTrailers(trailers);"
    },
    {
        "line": 37,
        "fullcodeline": "maybeEndEncode(true);"
    },
    {
        "line": 7,
        "fullcodeline": "commonEncodePrefix(filter, true, FilterIterationStartState::CanStartFromCurrent);"
    },
    {
        "line": 8,
        "fullcodeline": "for (; entry != encoder_filters_.end(); entry++) {"
    },
    {
        "line": 9,
        "fullcodeline": "(*entry)->maybeEvaluateMatchTreeWithNewData("
    },
    {
        "line": 20,
        "fullcodeline": "ASSERT(!(state_.filter_call_state_ & FilterCallState::EncodeTrailers));"
    },
    {
        "line": 21,
        "fullcodeline": "state_.filter_call_state_ |= FilterCallState::EncodeTrailers;"
    },
    {
        "line": 22,
        "fullcodeline": "FilterTrailersStatus status = (*entry)->handle_->encodeTrailers(trailers);"
    },
    {
        "line": 23,
        "fullcodeline": "(*entry)->handle_->encodeComplete();"
    },
    {
        "line": 24,
        "fullcodeline": "(*entry)->end_stream_ = true;"
    },
    {
        "line": 25,
        "fullcodeline": "state_.filter_call_state_ &= ~FilterCallState::EncodeTrailers;"
    },
    {
        "line": 26,
        "fullcodeline": "ENVOY_STREAM_LOG(trace, \"encode trailers called: filter={} status={}\", *this,"
    },
    {
        "line": 12,
        "fullcodeline": "if ((*entry)->skipFilter()) {"
    },
    {
        "line": 17,
        "fullcodeline": "if ((*entry)->stoppedAll()) {"
    },
    {
        "line": 27,
        "fullcodeline": "static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));"
    },
    {
        "line": 28,
        "fullcodeline": "if (!(*entry)->commonHandleAfterTrailersCallback(status)) {"
    }
]