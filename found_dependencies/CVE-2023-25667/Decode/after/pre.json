[
    {
        "line": 4,
        "fullcodeline": "int error_code = D_GIF_SUCCEEDED;"
    },
    {
        "line": 5,
        "fullcodeline": "InputBufferInfo info = {reinterpret_cast<const uint8*>(srcdata), datasize};"
    },
    {
        "line": 6,
        "fullcodeline": "GifFileType* gif_file ="
    },
    {
        "line": 8,
        "fullcodeline": "const auto cleanup = gtl::MakeCleanup([gif_file]() {"
    },
    {
        "line": 30,
        "fullcodeline": "int target_num_frames = gif_file->ImageCount;"
    },
    {
        "line": 33,
        "fullcodeline": "int max_frame_width = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "int max_frame_height = 0;"
    },
    {
        "line": 43,
        "fullcodeline": "const int width = max_frame_width;"
    },
    {
        "line": 44,
        "fullcodeline": "const int height = max_frame_height;"
    },
    {
        "line": 45,
        "fullcodeline": "const int channel = 3;"
    },
    {
        "line": 48,
        "fullcodeline": "uint8* const dstdata ="
    },
    {
        "line": 7,
        "fullcodeline": "DGifOpen(static_cast<void*>(&info), &input_callback, &error_code);"
    },
    {
        "line": 15,
        "fullcodeline": "if (error_code != D_GIF_SUCCEEDED) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (DGifSlurp(gif_file) != GIF_OK) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (gif_file->ImageCount <= 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "for (int k = 0; k < target_num_frames; k++) {"
    },
    {
        "line": 49,
        "fullcodeline": "allocate_output(target_num_frames, width, height, channel);"
    },
    {
        "line": 50,
        "fullcodeline": "if (!dstdata) return nullptr;"
    },
    {
        "line": 51,
        "fullcodeline": "for (ptrdiff_t k = 0; k < target_num_frames; k++) {"
    },
    {
        "line": 16,
        "fullcodeline": "*error_string = absl::StrCat(\"failed to open gif file: \","
    },
    {
        "line": 46,
        "fullcodeline": "if (!expand_animations) target_num_frames = 1;"
    },
    {
        "line": 52,
        "fullcodeline": "uint8* this_dst = dstdata + k * width * channel * height;"
    },
    {
        "line": 54,
        "fullcodeline": "SavedImage* this_image = &gif_file->SavedImages[k];"
    },
    {
        "line": 55,
        "fullcodeline": "GifImageDesc* img_desc = &this_image->ImageDesc;"
    },
    {
        "line": 62,
        "fullcodeline": "DGifSavedExtensionToGCB(gif_file, k, &gcb);"
    },
    {
        "line": 64,
        "fullcodeline": "int imgLeft = img_desc->Left;"
    },
    {
        "line": 65,
        "fullcodeline": "int imgTop = img_desc->Top;"
    },
    {
        "line": 66,
        "fullcodeline": "int imgRight = img_desc->Left + img_desc->Width;"
    },
    {
        "line": 67,
        "fullcodeline": "int imgBottom = img_desc->Top + img_desc->Height;"
    },
    {
        "line": 103,
        "fullcodeline": "ColorMapObject* color_map = this_image->ImageDesc.ColorMap"
    },
    {
        "line": 21,
        "fullcodeline": "*error_string = absl::StrCat(\"failed to slurp gif file: \","
    },
    {
        "line": 37,
        "fullcodeline": "if (max_frame_height < si->ImageDesc.Height)"
    },
    {
        "line": 39,
        "fullcodeline": "if (max_frame_width < si->ImageDesc.Width)"
    },
    {
        "line": 69,
        "fullcodeline": "if (k > 0) {"
    },
    {
        "line": 106,
        "fullcodeline": "if (color_map == nullptr) {"
    },
    {
        "line": 111,
        "fullcodeline": "for (ptrdiff_t i = imgTop; i < imgBottom; ++i) {"
    },
    {
        "line": 17,
        "fullcodeline": "GifErrorStringNonNull(error_code));"
    },
    {
        "line": 22,
        "fullcodeline": "GifErrorStringNonNull(gif_file->Error));"
    },
    {
        "line": 38,
        "fullcodeline": "max_frame_height = si->ImageDesc.Height;"
    },
    {
        "line": 40,
        "fullcodeline": "max_frame_width = si->ImageDesc.Width;"
    },
    {
        "line": 70,
        "fullcodeline": "uint8* last_dst = dstdata + (k - 1) * width * channel * height;"
    },
    {
        "line": 82,
        "fullcodeline": "if (img_desc->Left != 0 || img_desc->Top != 0 || img_desc->Width != width ||"
    },
    {
        "line": 83,
        "fullcodeline": "img_desc->Height != height) {"
    },
    {
        "line": 97,
        "fullcodeline": "imgLeft = std::max(imgLeft, 0);"
    },
    {
        "line": 98,
        "fullcodeline": "imgTop = std::max(imgTop, 0);"
    },
    {
        "line": 99,
        "fullcodeline": "imgRight = std::min(imgRight, width);"
    },
    {
        "line": 100,
        "fullcodeline": "imgBottom = std::min(imgBottom, height);"
    },
    {
        "line": 71,
        "fullcodeline": "for (ptrdiff_t i = 0; i < height; ++i) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (k == 0) {"
    },
    {
        "line": 107,
        "fullcodeline": "*error_string = absl::StrCat(\"missing color map for frame \", k);"
    },
    {
        "line": 113,
        "fullcodeline": "for (ptrdiff_t j = imgLeft; j < imgRight; ++j) {"
    },
    {
        "line": 73,
        "fullcodeline": "uint8* l_dst = last_dst + i * width * channel;"
    },
    {
        "line": 112,
        "fullcodeline": "uint8* p_dst = this_dst + i * width * channel;"
    },
    {
        "line": 114,
        "fullcodeline": "GifByteType color_index ="
    },
    {
        "line": 131,
        "fullcodeline": "const GifColorType& gif_color = color_map->Colors[color_index];"
    },
    {
        "line": 74,
        "fullcodeline": "for (ptrdiff_t j = 0; j < width; ++j) {"
    },
    {
        "line": 87,
        "fullcodeline": "for (ptrdiff_t i = 0; i < height; ++i) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (color_index >= color_map->ColorCount) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (color_index == gcb.TransparentColor) {"
    },
    {
        "line": 72,
        "fullcodeline": "uint8* p_dst = this_dst + i * width * channel;"
    },
    {
        "line": 89,
        "fullcodeline": "for (ptrdiff_t j = 0; j < width; ++j) {"
    },
    {
        "line": 115,
        "fullcodeline": "this_image->RasterBits[(i - img_desc->Top) * (img_desc->Width) +"
    },
    {
        "line": 116,
        "fullcodeline": "(j - img_desc->Left)];"
    },
    {
        "line": 119,
        "fullcodeline": "*error_string = absl::StrCat(\"found color index \", color_index,"
    },
    {
        "line": 132,
        "fullcodeline": "p_dst[j * channel + 0] = gif_color.Red;"
    },
    {
        "line": 133,
        "fullcodeline": "p_dst[j * channel + 1] = gif_color.Green;"
    },
    {
        "line": 134,
        "fullcodeline": "p_dst[j * channel + 2] = gif_color.Blue;"
    },
    {
        "line": 88,
        "fullcodeline": "uint8* p_dst = this_dst + i * width * channel;"
    },
    {
        "line": 75,
        "fullcodeline": "p_dst[j * channel + 0] = l_dst[j * channel + 0];"
    },
    {
        "line": 76,
        "fullcodeline": "p_dst[j * channel + 1] = l_dst[j * channel + 1];"
    },
    {
        "line": 77,
        "fullcodeline": "p_dst[j * channel + 2] = l_dst[j * channel + 2];"
    },
    {
        "line": 90,
        "fullcodeline": "p_dst[j * channel + 0] = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "p_dst[j * channel + 1] = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "p_dst[j * channel + 2] = 0;"
    }
]