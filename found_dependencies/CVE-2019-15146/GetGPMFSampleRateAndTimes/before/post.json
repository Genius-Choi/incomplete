[
    {
        "line": 3,
        "fullcodeline": "mp4object *mp4 = (mp4object *)handle;"
    },
    {
        "line": 12,
        "fullcodeline": "key = GPMF_Key(gs);"
    },
    {
        "line": 13,
        "fullcodeline": "repeat = GPMF_Repeat(gs);"
    },
    {
        "line": 23,
        "fullcodeline": "GPMF_CopyState(gs, &find_stream);"
    },
    {
        "line": 4,
        "fullcodeline": "if (mp4 == NULL) return 0.0;"
    },
    {
        "line": 10,
        "fullcodeline": "if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;"
    },
    {
        "line": 14,
        "fullcodeline": "if (rate == 0.0)"
    },
    {
        "line": 17,
        "fullcodeline": "if (rate == 0.0)"
    },
    {
        "line": 24,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 15,
        "fullcodeline": "rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);"
    },
    {
        "line": 19,
        "fullcodeline": "*in = *out = 0.0;"
    },
    {
        "line": 26,
        "fullcodeline": "outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));"
    },
    {
        "line": 27,
        "fullcodeline": "insamples = outsamples - repeat;"
    },
    {
        "line": 29,
        "fullcodeline": "*in = ((double)insamples / (double)rate);"
    },
    {
        "line": 30,
        "fullcodeline": "*out = ((double)outsamples / (double)rate);"
    },
    {
        "line": 35,
        "fullcodeline": "*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);"
    },
    {
        "line": 36,
        "fullcodeline": "*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);"
    }
]