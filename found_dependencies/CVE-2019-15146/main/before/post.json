[
    {
        "line": 3,
        "fullcodeline": "int32_t ret = GPMF_OK;"
    },
    {
        "line": 4,
        "fullcodeline": "GPMF_stream metadata_stream, *ms = &metadata_stream;"
    },
    {
        "line": 6,
        "fullcodeline": "uint32_t *payload = NULL; //buffer to store GPMF samples from the MP4."
    },
    {
        "line": 16,
        "fullcodeline": "size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);"
    },
    {
        "line": 19,
        "fullcodeline": "metadatalength = GetDuration(mp4);"
    },
    {
        "line": 10,
        "fullcodeline": "if (argc != 2)"
    },
    {
        "line": 21,
        "fullcodeline": "if (metadatalength > 0.0)"
    },
    {
        "line": 12,
        "fullcodeline": "printf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);"
    },
    {
        "line": 23,
        "fullcodeline": "uint32_t index, payloads = GetNumberPayloads(mp4);"
    },
    {
        "line": 218,
        "fullcodeline": "if (payload) FreePayload(payload); payload = NULL;"
    },
    {
        "line": 219,
        "fullcodeline": "CloseSource(mp4);"
    },
    {
        "line": 13,
        "fullcodeline": "return -1;"
    },
    {
        "line": 27,
        "fullcodeline": "if (payloads == 1) // Printf the contents of the single payload"
    },
    {
        "line": 58,
        "fullcodeline": "for (index = 0; index < payloads; index++)"
    },
    {
        "line": 205,
        "fullcodeline": "while (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 29,
        "fullcodeline": "uint32_t payloadsize = GetPayloadSize(mp4,0);"
    },
    {
        "line": 30,
        "fullcodeline": "payload = GetPayload(mp4, payload, 0);"
    },
    {
        "line": 34,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 39,
        "fullcodeline": "ret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS); // optional"
    },
    {
        "line": 46,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 51,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 52,
        "fullcodeline": "printf(\"\\n\");"
    },
    {
        "line": 60,
        "fullcodeline": "uint32_t payloadsize = GetPayloadSize(mp4, index);"
    },
    {
        "line": 61,
        "fullcodeline": "float in = 0.0, out = 0.0; //times"
    },
    {
        "line": 62,
        "fullcodeline": "payload = GetPayload(mp4, payload, index);"
    },
    {
        "line": 66,
        "fullcodeline": "ret = GetPayloadTime(mp4, index, &in, &out);"
    },
    {
        "line": 70,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 31,
        "fullcodeline": "if(payload == NULL)"
    },
    {
        "line": 35,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 40,
        "fullcodeline": "if (GPMF_OK != ret)"
    },
    {
        "line": 50,
        "fullcodeline": "} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));"
    },
    {
        "line": 63,
        "fullcodeline": "if (payload == NULL)"
    },
    {
        "line": 67,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 71,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 75,
        "fullcodeline": "if (index == 0) // show first payload"
    },
    {
        "line": 145,
        "fullcodeline": "if (index == 0) // show first payload"
    },
    {
        "line": 207,
        "fullcodeline": "if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream"
    },
    {
        "line": 42,
        "fullcodeline": "printf(\"Invalid Structure\\n\");"
    },
    {
        "line": 49,
        "fullcodeline": "PrintGPMF(ms);  // printf current GPMF KLV"
    },
    {
        "line": 77,
        "fullcodeline": "ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);"
    },
    {
        "line": 136,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 137,
        "fullcodeline": "printf(\"\\n\");"
    },
    {
        "line": 197,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 198,
        "fullcodeline": "printf(\"\\n\");"
    },
    {
        "line": 209,
        "fullcodeline": "uint32_t fourcc = GPMF_Key(ms);"
    },
    {
        "line": 210,
        "fullcodeline": "double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);"
    },
    {
        "line": 211,
        "fullcodeline": "printf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);"
    },
    {
        "line": 78,
        "fullcodeline": "while (GPMF_OK == ret)"
    },
    {
        "line": 147,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPS5\"), GPMF_RECURSE_LEVELS) || //GoPro Hero5/6/7 GPS"
    },
    {
        "line": 80,
        "fullcodeline": "ret = GPMF_SeekToSamples(ms);"
    },
    {
        "line": 148,
        "fullcodeline": "GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPRI\"), GPMF_RECURSE_LEVELS))   //GoPro Karma GPS"
    },
    {
        "line": 150,
        "fullcodeline": "uint32_t key = GPMF_Key(ms);"
    },
    {
        "line": 151,
        "fullcodeline": "uint32_t samples = GPMF_Repeat(ms);"
    },
    {
        "line": 152,
        "fullcodeline": "uint32_t elements = GPMF_ElementsInStruct(ms);"
    },
    {
        "line": 153,
        "fullcodeline": "uint32_t buffersize = samples * elements * sizeof(double);"
    },
    {
        "line": 155,
        "fullcodeline": "double *ptr, *tmpbuffer = malloc(buffersize);"
    },
    {
        "line": 156,
        "fullcodeline": "char units[10][6] = { \"\" };"
    },
    {
        "line": 157,
        "fullcodeline": "uint32_t unit_samples = 1;"
    },
    {
        "line": 159,
        "fullcodeline": "printf(\"MP4 Payload time %.3f to %.3f seconds\\n\", in, out);"
    },
    {
        "line": 81,
        "fullcodeline": "if (GPMF_OK == ret) //find the last FOURCC within the stream"
    },
    {
        "line": 161,
        "fullcodeline": "if (tmpbuffer && samples)"
    },
    {
        "line": 83,
        "fullcodeline": "uint32_t key = GPMF_Key(ms);"
    },
    {
        "line": 84,
        "fullcodeline": "GPMF_SampleType type = GPMF_Type(ms);"
    },
    {
        "line": 85,
        "fullcodeline": "uint32_t elements = GPMF_ElementsInStruct(ms);"
    },
    {
        "line": 87,
        "fullcodeline": "uint32_t samples = GPMF_PayloadSampleCount(ms);"
    },
    {
        "line": 126,
        "fullcodeline": "ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);"
    },
    {
        "line": 166,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 183,
        "fullcodeline": "GPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);  //Output scaled data as floats"
    },
    {
        "line": 185,
        "fullcodeline": "ptr = tmpbuffer;"
    },
    {
        "line": 194,
        "fullcodeline": "free(tmpbuffer);"
    },
    {
        "line": 167,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||"
    },
    {
        "line": 186,
        "fullcodeline": "for (i = 0; i < samples; i++)"
    },
    {
        "line": 91,
        "fullcodeline": "printf(\"  STRM of %c%c%c%c \", PRINTF_4CC(key));"
    },
    {
        "line": 118,
        "fullcodeline": "printf(\"with %d sample%s \", samples, samples > 1 ? \"s\" : \"\");"
    },
    {
        "line": 123,
        "fullcodeline": "printf(\"\\n\");"
    },
    {
        "line": 130,
        "fullcodeline": "if (ret == GPMF_ERROR_BAD_STRUCTURE) // some payload element was corrupt, skip to the next valid GPMF KLV at the previous level."
    },
    {
        "line": 168,
        "fullcodeline": "GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 170,
        "fullcodeline": "char *data = (char *)GPMF_RawData(&find_stream);"
    },
    {
        "line": 171,
        "fullcodeline": "int ssize = GPMF_StructSize(&find_stream);"
    },
    {
        "line": 172,
        "fullcodeline": "unit_samples = GPMF_Repeat(&find_stream);"
    },
    {
        "line": 188,
        "fullcodeline": "printf(\"%c%c%c%c \", PRINTF_4CC(key));"
    },
    {
        "line": 192,
        "fullcodeline": "printf(\"\\n\");"
    },
    {
        "line": 93,
        "fullcodeline": "if (type == GPMF_TYPE_COMPLEX)"
    },
    {
        "line": 120,
        "fullcodeline": "if (elements > 1)"
    },
    {
        "line": 132,
        "fullcodeline": "ret = GPMF_Next(ms, GPMF_CURRENT_LEVEL); // this will be the next stream if any more are present."
    },
    {
        "line": 174,
        "fullcodeline": "for (i = 0; i < unit_samples; i++)"
    },
    {
        "line": 189,
        "fullcodeline": "for (j = 0; j < elements; j++)"
    },
    {
        "line": 190,
        "fullcodeline": "printf(\"%.3f%s, \", *ptr++, units[j%unit_samples]);"
    },
    {
        "line": 96,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 121,
        "fullcodeline": "printf(\"-- %d elements per sample\", elements);"
    },
    {
        "line": 176,
        "fullcodeline": "memcpy(units[i], data, ssize);"
    },
    {
        "line": 177,
        "fullcodeline": "units[i][ssize] = 0;"
    },
    {
        "line": 178,
        "fullcodeline": "data += ssize;"
    },
    {
        "line": 98,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 115,
        "fullcodeline": "printf(\"of type %c \", type);"
    },
    {
        "line": 100,
        "fullcodeline": "char tmp[64];"
    },
    {
        "line": 101,
        "fullcodeline": "char *data = (char *)GPMF_RawData(&find_stream);"
    },
    {
        "line": 102,
        "fullcodeline": "int size = GPMF_RawDataSize(&find_stream);"
    },
    {
        "line": 104,
        "fullcodeline": "if (size < sizeof(tmp))"
    },
    {
        "line": 106,
        "fullcodeline": "memcpy(tmp, data, size);"
    },
    {
        "line": 107,
        "fullcodeline": "tmp[size] = 0;"
    },
    {
        "line": 108,
        "fullcodeline": "printf(\"of type %s \", tmp);"
    }
]