[
    {
        "line": 3,
        "fullcodeline": "mp4object *mp4 = (mp4object *)handle;"
    },
    {
        "line": 6,
        "fullcodeline": "GPMF_stream metadata_stream, *ms = &metadata_stream;"
    },
    {
        "line": 7,
        "fullcodeline": "uint32_t teststart = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "uint32_t testend = mp4->indexcount;"
    },
    {
        "line": 9,
        "fullcodeline": "double rate = 0.0;"
    },
    {
        "line": 20,
        "fullcodeline": "uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload"
    },
    {
        "line": 21,
        "fullcodeline": "uint32_t payloadsize = GetPayloadSize(handle, teststart);"
    },
    {
        "line": 22,
        "fullcodeline": "int32_t ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 4,
        "fullcodeline": "if (mp4 == NULL) return 0.0;"
    },
    {
        "line": 11,
        "fullcodeline": "if (mp4->indexcount < 1)"
    },
    {
        "line": 14,
        "fullcodeline": "if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies."
    },
    {
        "line": 24,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 28,
        "fullcodeline": "uint32_t startsamples = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "uint32_t endsamples = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "uint32_t missing_samples = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "teststart++;"
    },
    {
        "line": 17,
        "fullcodeline": "testend--;"
    },
    {
        "line": 32,
        "fullcodeline": "while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 49,
        "fullcodeline": "if (ret == GPMF_OK)"
    },
    {
        "line": 182,
        "fullcodeline": "FreePayload(payload);"
    },
    {
        "line": 183,
        "fullcodeline": "payload = NULL;"
    },
    {
        "line": 34,
        "fullcodeline": "missing_samples = 1;"
    },
    {
        "line": 35,
        "fullcodeline": "teststart++;"
    },
    {
        "line": 36,
        "fullcodeline": "payload = GetPayload(handle, payload, teststart); // second last payload"
    },
    {
        "line": 37,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, teststart);"
    },
    {
        "line": 38,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 43,
        "fullcodeline": "teststart++;   //samples after sensor start are statistically the best"
    },
    {
        "line": 44,
        "fullcodeline": "payload = GetPayload(handle, payload, teststart);"
    },
    {
        "line": 45,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, teststart);"
    },
    {
        "line": 46,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 51,
        "fullcodeline": "uint32_t samples = GPMF_Repeat(ms);"
    },
    {
        "line": 53,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 55,
        "fullcodeline": "if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 57,
        "fullcodeline": "startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;"
    },
    {
        "line": 59,
        "fullcodeline": "payload = GetPayload(handle, payload, testend); // second last payload"
    },
    {
        "line": 60,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, testend);"
    },
    {
        "line": 61,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 76,
        "fullcodeline": "rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 62,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 65,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 80,
        "fullcodeline": "uint32_t payloadpos = 0, payloadcount = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;"
    },
    {
        "line": 82,
        "fullcodeline": "uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);"
    },
    {
        "line": 83,
        "fullcodeline": "memset(repeatarray, 0, mp4->indexcount * 4 + 4);"
    },
    {
        "line": 85,
        "fullcodeline": "samples = 0;"
    },
    {
        "line": 172,
        "fullcodeline": "free(repeatarray);"
    },
    {
        "line": 67,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 87,
        "fullcodeline": "for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)"
    },
    {
        "line": 68,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 89,
        "fullcodeline": "payload = GetPayload(handle, payload, payloadpos); // second last payload"
    },
    {
        "line": 90,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, payloadpos);"
    },
    {
        "line": 91,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 143,
        "fullcodeline": "meanY /= (double)payloadcount;"
    },
    {
        "line": 144,
        "fullcodeline": "meanX /= (double)payloadcount;"
    },
    {
        "line": 155,
        "fullcodeline": "slope = top / bot;"
    },
    {
        "line": 165,
        "fullcodeline": "rate = slope;"
    },
    {
        "line": 70,
        "fullcodeline": "endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));"
    },
    {
        "line": 71,
        "fullcodeline": "rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 93,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 96,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 146,
        "fullcodeline": "for (payloadpos = teststart; payloadpos < testend; payloadpos++)"
    },
    {
        "line": 169,
        "fullcodeline": "rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 99,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream2);"
    },
    {
        "line": 149,
        "fullcodeline": "GetPayloadTime(handle, payloadpos, &in, &out);"
    },
    {
        "line": 151,
        "fullcodeline": "top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);"
    },
    {
        "line": 152,
        "fullcodeline": "bot += ((double)out - meanX)*((double)out - meanX);"
    },
    {
        "line": 101,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats"
    },
    {
        "line": 121,
        "fullcodeline": "uint32_t repeat = GPMF_Repeat(ms);"
    },
    {
        "line": 122,
        "fullcodeline": "samples += repeat;"
    },
    {
        "line": 112,
        "fullcodeline": "repeatarray[payloadpos] = samples;"
    },
    {
        "line": 113,
        "fullcodeline": "meanY += (double)samples;"
    },
    {
        "line": 115,
        "fullcodeline": "GetPayloadTime(handle, payloadpos, &in, &out);"
    },
    {
        "line": 116,
        "fullcodeline": "meanX += out;"
    },
    {
        "line": 110,
        "fullcodeline": "} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));"
    },
    {
        "line": 128,
        "fullcodeline": "repeatarray[payloadpos] = samples;"
    },
    {
        "line": 129,
        "fullcodeline": "meanY += (double)samples;"
    },
    {
        "line": 131,
        "fullcodeline": "GetPayloadTime(handle, payloadpos, &in, &out);"
    },
    {
        "line": 132,
        "fullcodeline": "meanX += out;"
    },
    {
        "line": 109,
        "fullcodeline": "samples++;"
    }
]