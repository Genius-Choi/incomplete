[
    {
        "line": 4,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 5,
        "fullcodeline": "struct irda_sock *self = irda_sk(sk);"
    },
    {
        "line": 6,
        "fullcodeline": "int noblock = flags & MSG_DONTWAIT;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t copied = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "IRDA_DEBUG(3, \"%s()\\n\", __func__);"
    },
    {
        "line": 24,
        "fullcodeline": "target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);"
    },
    {
        "line": 25,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, noblock);"
    },
    {
        "line": 13,
        "fullcodeline": "if ((err = sock_error(sk)) < 0)"
    },
    {
        "line": 16,
        "fullcodeline": "if (sock->flags & __SO_ACCEPTCON)"
    },
    {
        "line": 19,
        "fullcodeline": "err =-EOPNOTSUPP;"
    },
    {
        "line": 20,
        "fullcodeline": "if (flags & MSG_OOB)"
    },
    {
        "line": 108,
        "fullcodeline": "if (self->rx_flow == FLOW_STOP) {"
    },
    {
        "line": 31,
        "fullcodeline": "struct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);"
    },
    {
        "line": 77,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 17,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 21,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 33,
        "fullcodeline": "if (skb == NULL) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {"
    },
    {
        "line": 34,
        "fullcodeline": "DEFINE_WAIT(wait);"
    },
    {
        "line": 40,
        "fullcodeline": "prepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);"
    },
    {
        "line": 45,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 60,
        "fullcodeline": "finish_wait(sk_sleep(sk), &wait);"
    },
    {
        "line": 81,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 82,
        "fullcodeline": "skb_pull(skb, chunk);"
    },
    {
        "line": 109,
        "fullcodeline": "if ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 64,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 73,
        "fullcodeline": "if (copied == 0)"
    },
    {
        "line": 94,
        "fullcodeline": "IRDA_DEBUG(0, \"%s() questionable!?\\n\", __func__);"
    },
    {
        "line": 74,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 86,
        "fullcodeline": "IRDA_DEBUG(1, \"%s(), back on q!\\n\","
    },
    {
        "line": 48,
        "fullcodeline": "else if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 51,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 52,
        "fullcodeline": "else if (signal_pending(current))"
    },
    {
        "line": 53,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 54,
        "fullcodeline": "else if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 55,
        "fullcodeline": "err = -ENOTCONN;"
    },
    {
        "line": 56,
        "fullcodeline": "else if (skb_peek(&sk->sk_receive_queue) == NULL)"
    }
]