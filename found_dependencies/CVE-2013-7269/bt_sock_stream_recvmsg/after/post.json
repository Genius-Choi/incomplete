[
    {
        "line": 4,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 5,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "size_t target, copied = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "BT_DBG(\"sk %p size %zu\", sk, size);"
    },
    {
        "line": 14,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 16,
        "fullcodeline": "target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);"
    },
    {
        "line": 17,
        "fullcodeline": "timeo  = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);"
    },
    {
        "line": 101,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "if (flags & MSG_OOB)"
    },
    {
        "line": 102,
        "fullcodeline": "return copied ? : err;"
    },
    {
        "line": 23,
        "fullcodeline": "skb = skb_dequeue(&sk->sk_receive_queue);"
    },
    {
        "line": 54,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 55,
        "fullcodeline": "size   -= chunk;"
    },
    {
        "line": 57,
        "fullcodeline": "sock_recv_ts_and_drops(msg, sk, skb);"
    },
    {
        "line": 10,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 24,
        "fullcodeline": "if (!skb) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (skb_copy_datagram_iovec(skb, 0, msg->msg_iov, chunk)) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 28,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 34,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 38,
        "fullcodeline": "timeo = bt_sock_data_wait(sk, timeo);"
    },
    {
        "line": 49,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 60,
        "fullcodeline": "int skb_len = skb_headlen(skb);"
    },
    {
        "line": 91,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 25,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 31,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 35,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 40,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (!copied)"
    },
    {
        "line": 62,
        "fullcodeline": "if (chunk <= skb_len) {"
    },
    {
        "line": 95,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 41,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 51,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 63,
        "fullcodeline": "__skb_pull(skb, chunk);"
    },
    {
        "line": 88,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 67,
        "fullcodeline": "__skb_pull(skb, skb_len);"
    },
    {
        "line": 68,
        "fullcodeline": "chunk -= skb_len;"
    },
    {
        "line": 70,
        "fullcodeline": "skb_walk_frags(skb, frag) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (chunk <= frag->len) {"
    },
    {
        "line": 73,
        "fullcodeline": "skb->len -= chunk;"
    },
    {
        "line": 74,
        "fullcodeline": "skb->data_len -= chunk;"
    },
    {
        "line": 75,
        "fullcodeline": "__skb_pull(frag, chunk);"
    },
    {
        "line": 79,
        "fullcodeline": "chunk -= frag->len;"
    },
    {
        "line": 80,
        "fullcodeline": "skb->len -= frag->len;"
    },
    {
        "line": 81,
        "fullcodeline": "skb->data_len -= frag->len;"
    },
    {
        "line": 82,
        "fullcodeline": "__skb_pull(frag, frag->len);"
    }
]