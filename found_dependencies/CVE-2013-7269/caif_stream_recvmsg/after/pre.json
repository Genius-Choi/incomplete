[
    {
        "line": 5,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 6,
        "fullcodeline": "int copied = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "err = -EOPNOTSUPP;"
    },
    {
        "line": 19,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 23,
        "fullcodeline": "caif_read_lock(sk);"
    },
    {
        "line": 24,
        "fullcodeline": "target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);"
    },
    {
        "line": 25,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);"
    },
    {
        "line": 105,
        "fullcodeline": "caif_read_unlock(sk);"
    },
    {
        "line": 12,
        "fullcodeline": "if (flags&MSG_OOB)"
    },
    {
        "line": 20,
        "fullcodeline": "if (sk->sk_state == CAIF_CONNECTING)"
    },
    {
        "line": 108,
        "fullcodeline": "return copied ? : err;"
    },
    {
        "line": 31,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 32,
        "fullcodeline": "skb = skb_dequeue(&sk->sk_receive_queue);"
    },
    {
        "line": 33,
        "fullcodeline": "caif_check_flow_release(sk);"
    },
    {
        "line": 74,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 82,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 83,
        "fullcodeline": "size -= chunk;"
    },
    {
        "line": 35,
        "fullcodeline": "if (skb == NULL) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 41,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 44,
        "fullcodeline": "err = -ECONNRESET;"
    },
    {
        "line": 48,
        "fullcodeline": "err = -EPIPE;"
    },
    {
        "line": 54,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 56,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 60,
        "fullcodeline": "caif_read_unlock(sk);"
    },
    {
        "line": 62,
        "fullcodeline": "timeo = caif_stream_data_wait(sk, timeo);"
    },
    {
        "line": 68,
        "fullcodeline": "caif_read_lock(sk);"
    },
    {
        "line": 71,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 77,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 87,
        "fullcodeline": "skb_pull(skb, chunk);"
    },
    {
        "line": 94,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 36,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 45,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 49,
        "fullcodeline": "if (sk->sk_state != CAIF_CONNECTED)"
    },
    {
        "line": 51,
        "fullcodeline": "if (sock_flag(sk, SOCK_DEAD))"
    },
    {
        "line": 57,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 64,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (copied == 0)"
    },
    {
        "line": 101,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 65,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 79,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 91,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    }
]