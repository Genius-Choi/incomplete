[
    {
        "line": 4,
        "fullcodeline": "char *line_buf = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "char *temp_val = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "FILE *fs = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "const int line_buf_size = 4096;"
    },
    {
        "line": 9,
        "fullcodeline": "const int min_non_white = 10;"
    },
    {
        "line": 11,
        "fullcodeline": "i = toggle_dac_capability(0, 1);"
    },
    {
        "line": 15,
        "fullcodeline": "i = access(file_name, R_OK);"
    },
    {
        "line": 22,
        "fullcodeline": "fs = fopen(file_name, \"r\");"
    },
    {
        "line": 29,
        "fullcodeline": "i = toggle_dac_capability(0, 0);"
    },
    {
        "line": 33,
        "fullcodeline": "line_buf = (char *)malloc(line_buf_size);"
    },
    {
        "line": 71,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "free(line_buf);"
    },
    {
        "line": 23,
        "fullcodeline": "if (fs == NULL) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (line_buf == NULL) {"
    },
    {
        "line": 40,
        "fullcodeline": "while (fgets(line_buf, line_buf_size, fs)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (fs != NULL)"
    },
    {
        "line": 77,
        "fullcodeline": "if (line_buf != NULL)"
    },
    {
        "line": 17,
        "fullcodeline": "toggle_dac_capability(0, 0);"
    },
    {
        "line": 18,
        "fullcodeline": "i = errno;"
    },
    {
        "line": 24,
        "fullcodeline": "toggle_dac_capability(0, 0);"
    },
    {
        "line": 25,
        "fullcodeline": "i = errno;"
    },
    {
        "line": 35,
        "fullcodeline": "i = EX_SYSERR;"
    },
    {
        "line": 46,
        "fullcodeline": "null_terminate_endl(line_buf);"
    },
    {
        "line": 74,
        "fullcodeline": "fclose(fs);"
    },
    {
        "line": 78,
        "fullcodeline": "memset(line_buf, 0, line_buf_size);"
    },
    {
        "line": 42,
        "fullcodeline": "for (i = 0; i < line_buf_size - min_non_white + 1; i++) {"
    },
    {
        "line": 49,
        "fullcodeline": "switch (parse_cred_line(line_buf + i, &temp_val)) {"
    },
    {
        "line": 51,
        "fullcodeline": "strlcpy(parsed_info->username, temp_val,"
    },
    {
        "line": 53,
        "fullcodeline": "parsed_info->got_user = 1;"
    },
    {
        "line": 56,
        "fullcodeline": "i = set_password(parsed_info, temp_val);"
    },
    {
        "line": 61,
        "fullcodeline": "strlcpy(parsed_info->domain, temp_val,"
    },
    {
        "line": 43,
        "fullcodeline": "if ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))"
    },
    {
        "line": 66,
        "fullcodeline": "fprintf(stderr, \"Credential formatted \""
    }
]