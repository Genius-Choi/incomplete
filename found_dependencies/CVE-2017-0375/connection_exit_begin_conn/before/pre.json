[
    {
        "line": 5,
        "fullcodeline": "char *address = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "uint16_t port = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "or_circuit_t *or_circ = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "const or_options_t *options = get_options();"
    },
    {
        "line": 11,
        "fullcodeline": "uint8_t end_reason=0;"
    },
    {
        "line": 13,
        "fullcodeline": "assert_circuit_ok(circ);"
    },
    {
        "line": 17,
        "fullcodeline": "relay_header_unpack(&rh, cell->payload);"
    },
    {
        "line": 35,
        "fullcodeline": "rv = begin_cell_parse(cell, &bcell, &end_reason);"
    },
    {
        "line": 110,
        "fullcodeline": "log_debug(LD_EXIT,\"Creating new exit connection.\");"
    },
    {
        "line": 113,
        "fullcodeline": "n_stream = edge_connection_new(CONN_TYPE_EXIT, AF_INET);"
    },
    {
        "line": 117,
        "fullcodeline": "n_stream->dirreq_id = circ->dirreq_id;"
    },
    {
        "line": 119,
        "fullcodeline": "n_stream->base_.purpose = EXIT_PURPOSE_CONNECT;"
    },
    {
        "line": 120,
        "fullcodeline": "n_stream->begincell_flags = bcell.flags;"
    },
    {
        "line": 121,
        "fullcodeline": "n_stream->stream_id = rh.stream_id;"
    },
    {
        "line": 124,
        "fullcodeline": "n_stream->package_window = STREAMWINDOW_START;"
    },
    {
        "line": 125,
        "fullcodeline": "n_stream->deliver_window = STREAMWINDOW_START;"
    },
    {
        "line": 181,
        "fullcodeline": "tor_strlower(address);"
    },
    {
        "line": 183,
        "fullcodeline": "n_stream->base_.state = EXIT_CONN_STATE_RESOLVEFAILED;"
    },
    {
        "line": 193,
        "fullcodeline": "n_stream->on_circuit = circ;"
    },
    {
        "line": 205,
        "fullcodeline": "log_debug(LD_EXIT,\"about to start the dns_resolve().\");"
    },
    {
        "line": 14,
        "fullcodeline": "if (!CIRCUIT_IS_ORIGIN(circ))"
    },
    {
        "line": 18,
        "fullcodeline": "if (rh.length > RELAY_PAYLOAD_SIZE)"
    },
    {
        "line": 36,
        "fullcodeline": "if (rv < -1) {"
    },
    {
        "line": 127,
        "fullcodeline": "if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED) {"
    },
    {
        "line": 208,
        "fullcodeline": "switch (dns_resolve(n_stream)) {"
    },
    {
        "line": 15,
        "fullcodeline": "or_circ = TO_OR_CIRCUIT(circ);"
    },
    {
        "line": 26,
        "fullcodeline": "if (!server_mode(options) &&"
    },
    {
        "line": 27,
        "fullcodeline": "circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {"
    },
    {
        "line": 46,
        "fullcodeline": "address = bcell.address;"
    },
    {
        "line": 47,
        "fullcodeline": "port = bcell.port;"
    },
    {
        "line": 100,
        "fullcodeline": "bcell.flags &= ~BEGIN_FLAG_IPV6_PREFERRED;"
    },
    {
        "line": 128,
        "fullcodeline": "origin_circuit_t *origin_circ = TO_ORIGIN_CIRCUIT(circ);"
    },
    {
        "line": 129,
        "fullcodeline": "log_info(LD_REND,\"begin is for rendezvous. configuring stream.\");"
    },
    {
        "line": 131,
        "fullcodeline": "n_stream->base_.state = EXIT_CONN_STATE_CONNECTING;"
    },
    {
        "line": 132,
        "fullcodeline": "n_stream->rend_data = rend_data_dup(origin_circ->rend_data);"
    },
    {
        "line": 134,
        "fullcodeline": "assert_circuit_ok(circ);"
    },
    {
        "line": 136,
        "fullcodeline": "const int r = rend_service_set_connection_addr_port(n_stream, origin_circ);"
    },
    {
        "line": 161,
        "fullcodeline": "assert_circuit_ok(circ);"
    },
    {
        "line": 163,
        "fullcodeline": "n_stream->cpath_layer = origin_circ->cpath->prev; /* link it */"
    },
    {
        "line": 166,
        "fullcodeline": "n_stream->next_stream = origin_circ->p_streams;"
    },
    {
        "line": 167,
        "fullcodeline": "n_stream->on_circuit = circ;"
    },
    {
        "line": 168,
        "fullcodeline": "origin_circ->p_streams = n_stream;"
    },
    {
        "line": 187,
        "fullcodeline": "relay_send_end_cell_from_edge(rh.stream_id, circ,"
    },
    {
        "line": 197,
        "fullcodeline": "tor_assert(or_circ);"
    },
    {
        "line": 215,
        "fullcodeline": "relay_send_end_cell_from_edge(rh.stream_id, circ,"
    },
    {
        "line": 19,
        "fullcodeline": "return -END_CIRC_REASON_TORPROTOCOL;"
    },
    {
        "line": 37,
        "fullcodeline": "return -END_CIRC_REASON_TORPROTOCOL;"
    },
    {
        "line": 49,
        "fullcodeline": "if (or_circ && or_circ->p_chan) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (bcell.flags & BEGIN_FLAG_IPV4_NOT_OK) {"
    },
    {
        "line": 130,
        "fullcodeline": "n_stream->base_.address = tor_strdup(\"(rendezvous)\");"
    },
    {
        "line": 133,
        "fullcodeline": "tor_assert(connection_edge_is_rendezvous_stream(n_stream));"
    },
    {
        "line": 137,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 189,
        "fullcodeline": "connection_free(TO_CONN(n_stream));"
    },
    {
        "line": 202,
        "fullcodeline": "return connection_exit_connect_dir(n_stream);"
    },
    {
        "line": 73,
        "fullcodeline": "} else if (rh.command == RELAY_COMMAND_BEGIN_DIR) {"
    },
    {
        "line": 146,
        "fullcodeline": "relay_send_end_cell_from_edge(rh.stream_id, circ,"
    },
    {
        "line": 199,
        "fullcodeline": "channel_get_addr_if_possible(or_circ->p_chan, &tmp_addr)) {"
    },
    {
        "line": 38,
        "fullcodeline": "} else if (rv == -1) {"
    },
    {
        "line": 88,
        "fullcodeline": "port = 1; /* XXXX This value is never actually used anywhere, and there"
    },
    {
        "line": 149,
        "fullcodeline": "connection_free(TO_CONN(n_stream));"
    },
    {
        "line": 50,
        "fullcodeline": "if (!options->AllowSingleHopExits &&"
    },
    {
        "line": 51,
        "fullcodeline": "(or_circ->is_first_hop ||"
    },
    {
        "line": 84,
        "fullcodeline": "if (or_circ && or_circ->p_chan)"
    },
    {
        "line": 92,
        "fullcodeline": "log_warn(LD_BUG, \"Got an unexpected command %d\", (int)rh.command);"
    },
    {
        "line": 93,
        "fullcodeline": "relay_send_end_cell_from_edge(rh.stream_id, circ,"
    },
    {
        "line": 156,
        "fullcodeline": "if (r < -1)"
    },
    {
        "line": 52,
        "fullcodeline": "(!connection_or_digest_is_known_relay("
    },
    {
        "line": 61,
        "fullcodeline": "safe_str(channel_get_canonical_remote_descr(or_circ->p_chan)),"
    },
    {
        "line": 65,
        "fullcodeline": "or_circ->is_first_hop ?"
    },
    {
        "line": 74,
        "fullcodeline": "if (!directory_permits_begindir_requests(options) ||"
    },
    {
        "line": 75,
        "fullcodeline": "circ->purpose != CIRCUIT_PURPOSE_OR) {"
    },
    {
        "line": 76,
        "fullcodeline": "relay_send_end_cell_from_edge(rh.stream_id, circ,"
    },
    {
        "line": 85,
        "fullcodeline": "address = tor_strdup(channel_get_actual_remote_address(or_circ->p_chan));"
    },
    {
        "line": 54,
        "fullcodeline": "should_refuse_unknown_exits(options)))) {"
    },
    {
        "line": 87,
        "fullcodeline": "address = tor_strdup(\"127.0.0.1\");"
    }
]