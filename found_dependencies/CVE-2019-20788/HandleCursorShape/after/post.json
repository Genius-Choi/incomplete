[
    {
        "line": 6,
        "fullcodeline": "uint32_t colors[2];"
    },
    {
        "line": 11,
        "fullcodeline": "bytesPerPixel = client->format.bitsPerPixel / 8;"
    },
    {
        "line": 12,
        "fullcodeline": "bytesPerRow = (width + 7) / 8;"
    },
    {
        "line": 13,
        "fullcodeline": "bytesMaskData = bytesPerRow * height;"
    },
    {
        "line": 25,
        "fullcodeline": "client->rcSource = malloc(width * height * bytesPerPixel);"
    },
    {
        "line": 29,
        "fullcodeline": "buf = malloc(bytesMaskData);"
    },
    {
        "line": 108,
        "fullcodeline": "client->rcMask = malloc(width * height);"
    },
    {
        "line": 116,
        "fullcodeline": "ptr = client->rcMask;"
    },
    {
        "line": 132,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 15,
        "fullcodeline": "if (width * height == 0)"
    },
    {
        "line": 18,
        "fullcodeline": "if (width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE)"
    },
    {
        "line": 26,
        "fullcodeline": "if (client->rcSource == NULL)"
    },
    {
        "line": 30,
        "fullcodeline": "if (buf == NULL) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (enc == rfbEncodingXCursor) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (!ReadFromRFBServer(client, buf, bytesMaskData)) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (client->rcMask == NULL) {"
    },
    {
        "line": 117,
        "fullcodeline": "for (y = 0; y < height; y++) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (client->GotCursorShape != NULL) {"
    },
    {
        "line": 23,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 31,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 32,
        "fullcodeline": "client->rcSource = NULL;"
    },
    {
        "line": 46,
        "fullcodeline": "colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);"
    },
    {
        "line": 47,
        "fullcodeline": "colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);"
    },
    {
        "line": 58,
        "fullcodeline": "ptr = client->rcSource;"
    },
    {
        "line": 102,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 103,
        "fullcodeline": "client->rcSource = NULL;"
    },
    {
        "line": 104,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 110,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 111,
        "fullcodeline": "client->rcSource = NULL;"
    },
    {
        "line": 112,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 129,
        "fullcodeline": "client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);"
    },
    {
        "line": 40,
        "fullcodeline": "if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (!ReadFromRFBServer(client, buf, bytesMaskData)) {"
    },
    {
        "line": 59,
        "fullcodeline": "for (y = 0; y < height; y++) {"
    },
    {
        "line": 118,
        "fullcodeline": "for (x = 0; x < width / 8; x++) {"
    },
    {
        "line": 123,
        "fullcodeline": "for (b = 7; b > 7 - width % 8; b--) {"
    },
    {
        "line": 41,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 42,
        "fullcodeline": "client->rcSource = NULL;"
    },
    {
        "line": 43,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 51,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 52,
        "fullcodeline": "client->rcSource = NULL;"
    },
    {
        "line": 53,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 90,
        "fullcodeline": "if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {"
    },
    {
        "line": 124,
        "fullcodeline": "*ptr++ = buf[y * bytesPerRow + x] >> b & 1;"
    },
    {
        "line": 60,
        "fullcodeline": "for (x = 0; x < width / 8; x++) {"
    },
    {
        "line": 66,
        "fullcodeline": "for (b = 7; b > 7 - width % 8; b--) {"
    },
    {
        "line": 75,
        "fullcodeline": "for (x = 0; x < width * height; x++)"
    },
    {
        "line": 76,
        "fullcodeline": "client->rcSource[x] = (uint8_t)colors[client->rcSource[x]];"
    },
    {
        "line": 79,
        "fullcodeline": "for (x = 0; x < width * height; x++)"
    },
    {
        "line": 80,
        "fullcodeline": "((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];"
    },
    {
        "line": 83,
        "fullcodeline": "for (x = 0; x < width * height; x++)"
    },
    {
        "line": 84,
        "fullcodeline": "((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];"
    },
    {
        "line": 91,
        "fullcodeline": "free(client->rcSource);"
    },
    {
        "line": 92,
        "fullcodeline": "client->rcSource = NULL;"
    },
    {
        "line": 93,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 119,
        "fullcodeline": "for (b = 7; b >= 0; b--) {"
    },
    {
        "line": 67,
        "fullcodeline": "*ptr = buf[y * bytesPerRow + x] >> b & 1;"
    },
    {
        "line": 68,
        "fullcodeline": "ptr += bytesPerPixel;"
    },
    {
        "line": 120,
        "fullcodeline": "*ptr++ = buf[y * bytesPerRow + x] >> b & 1;"
    },
    {
        "line": 61,
        "fullcodeline": "for (b = 7; b >= 0; b--) {"
    },
    {
        "line": 62,
        "fullcodeline": "*ptr = buf[y * bytesPerRow + x] >> b & 1;"
    },
    {
        "line": 63,
        "fullcodeline": "ptr += bytesPerPixel;"
    }
]