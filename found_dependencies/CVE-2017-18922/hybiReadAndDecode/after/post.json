[
    {
        "line": 11,
        "fullcodeline": "ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;"
    },
    {
        "line": 14,
        "fullcodeline": "memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);"
    },
    {
        "line": 15,
        "fullcodeline": "wsctx->writePos += wsctx->carrylen;"
    },
    {
        "line": 18,
        "fullcodeline": "bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;"
    },
    {
        "line": 25,
        "fullcodeline": "rfbLog(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d\\n)\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);"
    },
    {
        "line": 45,
        "fullcodeline": "wsctx->writePos += n;"
    },
    {
        "line": 56,
        "fullcodeline": "toDecode = wsctx->writePos - hybiPayloadStart(wsctx);"
    },
    {
        "line": 57,
        "fullcodeline": "rfbLog(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);"
    },
    {
        "line": 67,
        "fullcodeline": "data = (unsigned char *)hybiPayloadStart(wsctx);"
    },
    {
        "line": 68,
        "fullcodeline": "data32= (uint32_t *)data;"
    },
    {
        "line": 73,
        "fullcodeline": "rfbLog(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);"
    },
    {
        "line": 96,
        "fullcodeline": "toReturn = toDecode - wsctx->carrylen;"
    },
    {
        "line": 130,
        "fullcodeline": "wsctx->readPos = data;"
    },
    {
        "line": 19,
        "fullcodeline": "if (hybiRemaining(wsctx) > bufsize) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (wsctx->nReadRaw < wsctx->nToRead) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (wsctx->nReadRaw >= wsctx->nToRead) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (toDecode < 0) {"
    },
    {
        "line": 70,
        "fullcodeline": "for (i = 0; i < (toDecode >> 2); i++) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {"
    },
    {
        "line": 132,
        "fullcodeline": "return hybiReturnData(dst, len, wsctx, sockRet);"
    },
    {
        "line": 20,
        "fullcodeline": "nextRead = bufsize;"
    },
    {
        "line": 39,
        "fullcodeline": "wsctx->nReadRaw += n;"
    },
    {
        "line": 40,
        "fullcodeline": "rfbLog(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadRaw);"
    },
    {
        "line": 59,
        "fullcodeline": "rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);"
    },
    {
        "line": 60,
        "fullcodeline": "errno=EIO;"
    },
    {
        "line": 61,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 71,
        "fullcodeline": "data32[i] ^= wsctx->header.mask.u;"
    },
    {
        "line": 82,
        "fullcodeline": "wsctx->carrylen = 0;"
    },
    {
        "line": 115,
        "fullcodeline": "data[toReturn] = '\\0';"
    },
    {
        "line": 116,
        "fullcodeline": "rfbLog(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);"
    },
    {
        "line": 121,
        "fullcodeline": "wsctx->writePos = hybiPayloadStart(wsctx);"
    },
    {
        "line": 124,
        "fullcodeline": "wsctx->readlen = toReturn;"
    },
    {
        "line": 125,
        "fullcodeline": "wsctx->writePos = hybiPayloadStart(wsctx);"
    },
    {
        "line": 128,
        "fullcodeline": "rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);"
    },
    {
        "line": 22,
        "fullcodeline": "nextRead = hybiRemaining(wsctx);"
    },
    {
        "line": 29,
        "fullcodeline": "if (-1 == (n = ws_read(cl, wsctx->writePos, nextRead))) {"
    },
    {
        "line": 42,
        "fullcodeline": "n = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "if (wsctx->nReadRaw > wsctx->nToRead) {"
    },
    {
        "line": 77,
        "fullcodeline": "for (i*=4; i < toDecode; i++) {"
    },
    {
        "line": 85,
        "fullcodeline": "wsctx->carrylen = toDecode - (i * 4);"
    },
    {
        "line": 92,
        "fullcodeline": "rfbLog(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);"
    },
    {
        "line": 93,
        "fullcodeline": "memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);"
    },
    {
        "line": 102,
        "fullcodeline": "if (hybiWsFrameComplete(wsctx)) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (-1 == (wsctx->readlen = b64_pton((char *)data, data, bufsize))) {"
    },
    {
        "line": 30,
        "fullcodeline": "int olderrno = errno;"
    },
    {
        "line": 31,
        "fullcodeline": "rfbErr(\"%s: read; %m\", __func__);"
    },
    {
        "line": 32,
        "fullcodeline": "errno = olderrno;"
    },
    {
        "line": 33,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 49,
        "fullcodeline": "rfbErr(\"%s: internal error, read past websocket frame\", __func__);"
    },
    {
        "line": 50,
        "fullcodeline": "errno=EIO;"
    },
    {
        "line": 51,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 78,
        "fullcodeline": "data[i] ^= wsctx->header.mask.c[i % 4];"
    },
    {
        "line": 86,
        "fullcodeline": "if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {"
    },
    {
        "line": 103,
        "fullcodeline": "rfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)data)[0]));"
    },
    {
        "line": 104,
        "fullcodeline": "errno = ECONNRESET;"
    },
    {
        "line": 105,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 118,
        "fullcodeline": "rfbErr(\"Base64 decode error in %s; data=%p bufsize=%d\", __func__, data, bufsize);"
    },
    {
        "line": 119,
        "fullcodeline": "rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);"
    },
    {
        "line": 87,
        "fullcodeline": "rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);"
    },
    {
        "line": 88,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 89,
        "fullcodeline": "errno = EIO;"
    },
    {
        "line": 108,
        "fullcodeline": "rfbErr(\"%s: close reason with long frame not supported\", __func__);"
    },
    {
        "line": 109,
        "fullcodeline": "errno = EIO;"
    },
    {
        "line": 110,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 35,
        "fullcodeline": "} else if (n == 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "*sockRet = 0;"
    }
]