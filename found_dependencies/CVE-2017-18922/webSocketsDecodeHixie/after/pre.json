[
    {
        "line": 3,
        "fullcodeline": "int retlen = 0, n, i, avail, modlen, needlen;"
    },
    {
        "line": 4,
        "fullcodeline": "char *buf, *end = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;"
    },
    {
        "line": 7,
        "fullcodeline": "buf = wsctx->codeBufDecode;"
    },
    {
        "line": 9,
        "fullcodeline": "n = ws_peek(cl, buf, len*2+2);"
    },
    {
        "line": 42,
        "fullcodeline": "end = memchr(buf, '\\xff', n);"
    },
    {
        "line": 46,
        "fullcodeline": "avail = end - buf;"
    },
    {
        "line": 48,
        "fullcodeline": "len -= wsctx->carrylen;"
    },
    {
        "line": 51,
        "fullcodeline": "modlen = len + (len+2)/3;"
    },
    {
        "line": 52,
        "fullcodeline": "needlen = modlen;"
    },
    {
        "line": 71,
        "fullcodeline": "buf[needlen] = '\\x00';  /* Replace end marker with end of string */"
    },
    {
        "line": 73,
        "fullcodeline": "n = b64_pton(buf, (unsigned char *)dst+retlen, 2+len);"
    },
    {
        "line": 79,
        "fullcodeline": "retlen += n;"
    },
    {
        "line": 84,
        "fullcodeline": "wsctx->carrylen = n - len;"
    },
    {
        "line": 85,
        "fullcodeline": "retlen -= wsctx->carrylen;"
    },
    {
        "line": 11,
        "fullcodeline": "if (n <= 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (buf[0] == '\\xff') {"
    },
    {
        "line": 27,
        "fullcodeline": "if (n == 0) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (buf[0] == '\\x00') {"
    },
    {
        "line": 36,
        "fullcodeline": "if (n == 0) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (!end) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (needlen % 4) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (needlen > avail) {"
    },
    {
        "line": 64,
        "fullcodeline": "for (i=0; i < wsctx->carrylen; i++) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (n < len) {"
    },
    {
        "line": 82,
        "fullcodeline": "i = ws_read(cl, buf, needlen);"
    },
    {
        "line": 86,
        "fullcodeline": "for (i=0; i < wsctx->carrylen; i++) {"
    },
    {
        "line": 13,
        "fullcodeline": "int olderrno = errno;"
    },
    {
        "line": 14,
        "fullcodeline": "rfbErr(\"%s: peek (%d) %m\\n\", __func__, errno);"
    },
    {
        "line": 15,
        "fullcodeline": "errno = olderrno;"
    },
    {
        "line": 24,
        "fullcodeline": "buf++;"
    },
    {
        "line": 25,
        "fullcodeline": "n--;"
    },
    {
        "line": 33,
        "fullcodeline": "buf++;"
    },
    {
        "line": 34,
        "fullcodeline": "n--;"
    },
    {
        "line": 44,
        "fullcodeline": "end = buf + n;"
    },
    {
        "line": 54,
        "fullcodeline": "needlen += 4 - (needlen % 4);"
    },
    {
        "line": 66,
        "fullcodeline": "dst[i] = wsctx->carryBuf[i];"
    },
    {
        "line": 67,
        "fullcodeline": "retlen += 1;"
    },
    {
        "line": 76,
        "fullcodeline": "errno = EIO;"
    },
    {
        "line": 23,
        "fullcodeline": "i = ws_read(cl, buf, 1); /* Consume marker */"
    },
    {
        "line": 29,
        "fullcodeline": "return -1;"
    },
    {
        "line": 32,
        "fullcodeline": "i = ws_read(cl, buf, 1); /* Consume marker */"
    },
    {
        "line": 38,
        "fullcodeline": "return -1;"
    },
    {
        "line": 60,
        "fullcodeline": "return -1;"
    },
    {
        "line": 77,
        "fullcodeline": "return -1;"
    }
]