[
    {
        "line": 5,
        "fullcodeline": "int ret = -1, result = -1;"
    },
    {
        "line": 6,
        "fullcodeline": "int total = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;"
    },
    {
        "line": 33,
        "fullcodeline": "buf = wsctx->codeBufDecode;"
    },
    {
        "line": 34,
        "fullcodeline": "header = (ws_header_t *)wsctx->codeBufDecode;"
    },
    {
        "line": 36,
        "fullcodeline": "ret = ws_peek(cl, buf, B64LEN(len) + WSHLENMAX);"
    },
    {
        "line": 52,
        "fullcodeline": "opcode = header->b0 & 0x0f;"
    },
    {
        "line": 54,
        "fullcodeline": "flength = header->b1 & 0x7f;"
    },
    {
        "line": 87,
        "fullcodeline": "total = fhlen + flength + 4;"
    },
    {
        "line": 88,
        "fullcodeline": "payload = buf + fhlen + 4; /* header length + mask */"
    },
    {
        "line": 103,
        "fullcodeline": "payload32 = (uint32_t *)payload;"
    },
    {
        "line": 38,
        "fullcodeline": "if (ret < 2) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (!(header->b1 & 0x80)) {"
    },
    {
        "line": 68,
        "fullcodeline": "if (flength < 126) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (-1 == (ret = ws_read(cl, buf, total))) {"
    },
    {
        "line": 104,
        "fullcodeline": "for (i = 0; i < flength / 4; i++) {"
    },
    {
        "line": 108,
        "fullcodeline": "for (i*=4; i < flength; i++) {"
    },
    {
        "line": 63,
        "fullcodeline": "rfbErr(\"%s: got frame without mask\\n\", __func__, ret);"
    },
    {
        "line": 64,
        "fullcodeline": "errno = EIO;"
    },
    {
        "line": 69,
        "fullcodeline": "fhlen = 2;"
    },
    {
        "line": 91,
        "fullcodeline": "int olderrno = errno;"
    },
    {
        "line": 92,
        "fullcodeline": "rfbErr(\"%s: read; %m\", __func__);"
    },
    {
        "line": 93,
        "fullcodeline": "errno = olderrno;"
    },
    {
        "line": 105,
        "fullcodeline": "payload32[i] ^= mask.u;"
    },
    {
        "line": 109,
        "fullcodeline": "payload[i] ^= mask.c[i % 4];"
    },
    {
        "line": 114,
        "fullcodeline": "rfbLog(\"got closure, reason %d\\n\", WS_NTOH16(((uint16_t *)payload)[0]));"
    },
    {
        "line": 115,
        "fullcodeline": "errno = ECONNRESET;"
    },
    {
        "line": 122,
        "fullcodeline": "payload = wsctx->codeBufDecode;"
    },
    {
        "line": 131,
        "fullcodeline": "memcpy(dst, payload, flength);"
    },
    {
        "line": 132,
        "fullcodeline": "result = flength;"
    },
    {
        "line": 135,
        "fullcodeline": "rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)opcode, header->b0, header->b1);"
    },
    {
        "line": 19,
        "fullcodeline": "if (wsctx->readbuflen > len) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (-1 == ret) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (-1 == (flength = b64_pton(payload, (unsigned char *)wsctx->codeBufDecode, sizeof(wsctx->codeBufDecode)))) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (flength > len) {"
    },
    {
        "line": 20,
        "fullcodeline": "memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, len);"
    },
    {
        "line": 21,
        "fullcodeline": "result = len;"
    },
    {
        "line": 22,
        "fullcodeline": "wsctx->readbuflen -= len;"
    },
    {
        "line": 23,
        "fullcodeline": "wsctx->readbufstart += len;"
    },
    {
        "line": 41,
        "fullcodeline": "int olderrno = errno;"
    },
    {
        "line": 42,
        "fullcodeline": "rfbErr(\"%s: peek; %m\\n\", __func__);"
    },
    {
        "line": 43,
        "fullcodeline": "errno = olderrno;"
    },
    {
        "line": 71,
        "fullcodeline": "} else if (flength == 126 && 4 <= ret) {"
    },
    {
        "line": 95,
        "fullcodeline": "} else if (ret < total) {"
    },
    {
        "line": 119,
        "fullcodeline": "rfbErr(\"%s: Base64 decode error; %m\\n\", __func__);"
    },
    {
        "line": 126,
        "fullcodeline": "memcpy(wsctx->readbuf, payload + len, flength - len);"
    },
    {
        "line": 127,
        "fullcodeline": "wsctx->readbufstart = 0;"
    },
    {
        "line": 128,
        "fullcodeline": "wsctx->readbuflen = flength - len;"
    },
    {
        "line": 129,
        "fullcodeline": "flength = len;"
    },
    {
        "line": 25,
        "fullcodeline": "memcpy(dst, wsctx->readbuf +  wsctx->readbufstart, wsctx->readbuflen);"
    },
    {
        "line": 26,
        "fullcodeline": "result = wsctx->readbuflen;"
    },
    {
        "line": 27,
        "fullcodeline": "wsctx->readbuflen = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "wsctx->readbufstart = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "flength = WS_NTOH16(header->u.s16.l16);"
    },
    {
        "line": 73,
        "fullcodeline": "fhlen = 4;"
    },
    {
        "line": 97,
        "fullcodeline": "rfbLog(\"%s: read; got partial data\\n\", __func__);"
    },
    {
        "line": 44,
        "fullcodeline": "} else if (0 == ret) {"
    },
    {
        "line": 99,
        "fullcodeline": "buf[ret] = '\\0';"
    },
    {
        "line": 45,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "} else if (flength == 127 && 10 <= ret) {"
    },
    {
        "line": 47,
        "fullcodeline": "errno = EAGAIN;"
    },
    {
        "line": 76,
        "fullcodeline": "flength = WS_NTOH64(header->u.s64.l64);"
    },
    {
        "line": 77,
        "fullcodeline": "fhlen = 10;"
    },
    {
        "line": 81,
        "fullcodeline": "rfbErr(\"%s: incomplete frame header\\n\", __func__, ret);"
    },
    {
        "line": 82,
        "fullcodeline": "errno = EIO;"
    }
]