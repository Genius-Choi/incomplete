[
    {
        "line": 3,
        "fullcodeline": "int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';"
    },
    {
        "line": 4,
        "fullcodeline": "char_u\t*name_start = eap->arg;"
    },
    {
        "line": 5,
        "fullcodeline": "char_u\t*name_end = to_name_end(eap->arg, TRUE);"
    },
    {
        "line": 10,
        "fullcodeline": "int\t\tr = FAIL;"
    },
    {
        "line": 12,
        "fullcodeline": "isn_T\t*funcref_isn = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "lvar_T\t*lvar = NULL;"
    },
    {
        "line": 62,
        "fullcodeline": "eap->arg = name_end;"
    },
    {
        "line": 63,
        "fullcodeline": "fill_exarg_from_cctx(eap, cctx);"
    },
    {
        "line": 65,
        "fullcodeline": "eap->forceit = FALSE;"
    },
    {
        "line": 67,
        "fullcodeline": "lambda_name = vim_strsave(get_lambda_name());"
    },
    {
        "line": 72,
        "fullcodeline": "off = is_global ? 2 : 0;"
    },
    {
        "line": 73,
        "fullcodeline": "func_name = vim_strnsave(name_start + off, name_end - name_start - off);"
    },
    {
        "line": 80,
        "fullcodeline": "ufunc = define_function(eap, lambda_name, lines_to_free);"
    },
    {
        "line": 129,
        "fullcodeline": "compile_type = get_compile_type(ufunc);"
    },
    {
        "line": 21,
        "fullcodeline": "if (*name_start == '/')"
    },
    {
        "line": 68,
        "fullcodeline": "if (lambda_name == NULL)"
    },
    {
        "line": 74,
        "fullcodeline": "if (func_name == NULL)"
    },
    {
        "line": 81,
        "fullcodeline": "if (ufunc == NULL)"
    },
    {
        "line": 86,
        "fullcodeline": "if (eap->nextcmd != NULL)"
    },
    {
        "line": 160,
        "fullcodeline": "return r == FAIL ? NULL : (char_u *)\"\";"
    },
    {
        "line": 17,
        "fullcodeline": "emsg(_(e_cannot_use_bang_with_nested_def));"
    },
    {
        "line": 23,
        "fullcodeline": "name_end = skip_regexp(name_start + 1, '/', TRUE);"
    },
    {
        "line": 26,
        "fullcodeline": "set_nextcmd(eap, name_end);"
    },
    {
        "line": 28,
        "fullcodeline": "if (name_end == name_start || *skipwhite(name_end) != '(')"
    },
    {
        "line": 47,
        "fullcodeline": "if (name_start[1] == ':' && !is_global)"
    },
    {
        "line": 52,
        "fullcodeline": "if (cctx->ctx_skip != SKIP_YES"
    },
    {
        "line": 53,
        "fullcodeline": "&& check_defined(name_start, name_end - name_start, cctx,"
    },
    {
        "line": 56,
        "fullcodeline": "if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))"
    },
    {
        "line": 76,
        "fullcodeline": "r = FAIL;"
    },
    {
        "line": 83,
        "fullcodeline": "r = eap->skip ? OK : FAIL;"
    },
    {
        "line": 90,
        "fullcodeline": "r = FAIL;"
    },
    {
        "line": 96,
        "fullcodeline": "if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)"
    },
    {
        "line": 98,
        "fullcodeline": "int block_depth = cctx->ctx_ufunc->uf_block_depth;"
    },
    {
        "line": 113,
        "fullcodeline": "r = generate_NEWFUNC(cctx, lambda_name, func_name);"
    },
    {
        "line": 114,
        "fullcodeline": "func_name = NULL;"
    },
    {
        "line": 115,
        "fullcodeline": "lambda_name = NULL;"
    },
    {
        "line": 136,
        "fullcodeline": "if (func_needs_compiling(ufunc, compile_type)"
    },
    {
        "line": 137,
        "fullcodeline": "&& compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)"
    },
    {
        "line": 154,
        "fullcodeline": "if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)"
    },
    {
        "line": 24,
        "fullcodeline": "if (*name_end == '/')"
    },
    {
        "line": 43,
        "fullcodeline": "return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;"
    },
    {
        "line": 49,
        "fullcodeline": "semsg(_(e_namespace_not_supported_str), name_start);"
    },
    {
        "line": 58,
        "fullcodeline": "semsg(_(e_function_name_must_start_with_capital_str), name_start);"
    },
    {
        "line": 88,
        "fullcodeline": "semsg(_(e_text_found_after_str_str),"
    },
    {
        "line": 101,
        "fullcodeline": "if (ufunc->uf_block_ids != NULL)"
    },
    {
        "line": 120,
        "fullcodeline": "lvar = reserve_local(cctx, func_name, name_end - name_start,"
    },
    {
        "line": 126,
        "fullcodeline": "r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);"
    },
    {
        "line": 140,
        "fullcodeline": "if (lvar != NULL)"
    },
    {
        "line": 25,
        "fullcodeline": "++name_end;"
    },
    {
        "line": 30,
        "fullcodeline": "if (!ends_excmd2(name_start, name_end))"
    },
    {
        "line": 41,
        "fullcodeline": "if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)"
    },
    {
        "line": 89,
        "fullcodeline": "eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);"
    },
    {
        "line": 103,
        "fullcodeline": "mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,"
    },
    {
        "line": 105,
        "fullcodeline": "ufunc->uf_block_depth = block_depth;"
    },
    {
        "line": 122,
        "fullcodeline": "if (lvar == NULL)"
    },
    {
        "line": 124,
        "fullcodeline": "if (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)"
    },
    {
        "line": 104,
        "fullcodeline": "sizeof(int) * block_depth);"
    },
    {
        "line": 33,
        "fullcodeline": "semsg(_(e_cannot_define_dict_func_in_vim9_script_str),"
    },
    {
        "line": 36,
        "fullcodeline": "semsg(_(e_invalid_command_str), eap->cmd);"
    }
]