[
    {
        "line": 6,
        "fullcodeline": "if (nsops == 1 && !sma->complex_count) {"
    },
    {
        "line": 7,
        "fullcodeline": "struct sem *sem = sma->sem_base + sops->sem_num;"
    },
    {
        "line": 10,
        "fullcodeline": "spin_lock(&sem->lock);"
    },
    {
        "line": 32,
        "fullcodeline": "locknum = sops->sem_num;"
    },
    {
        "line": 16,
        "fullcodeline": "if (unlikely(sma->complex_count)) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (unlikely(spin_is_locked(&sma->sem_perm.lock))) {"
    },
    {
        "line": 47,
        "fullcodeline": "locknum = -1;"
    },
    {
        "line": 17,
        "fullcodeline": "spin_unlock(&sem->lock);"
    },
    {
        "line": 27,
        "fullcodeline": "spin_unlock(&sem->lock);"
    },
    {
        "line": 28,
        "fullcodeline": "spin_unlock_wait(&sma->sem_perm.lock);"
    },
    {
        "line": 43,
        "fullcodeline": "for (i = 0; i < sma->sem_nsems; i++) {"
    },
    {
        "line": 44,
        "fullcodeline": "struct sem *sem = sma->sem_base + i;"
    },
    {
        "line": 45,
        "fullcodeline": "spin_unlock_wait(&sem->lock);"
    }
]