[
    {
        "line": 11,
        "fullcodeline": "list_for_each_entry_safe(un, tu, &sma->list_id, list_id) {"
    },
    {
        "line": 21,
        "fullcodeline": "INIT_LIST_HEAD(&tasks);"
    },
    {
        "line": 22,
        "fullcodeline": "list_for_each_entry_safe(q, tq, &sma->sem_pending, list) {"
    },
    {
        "line": 35,
        "fullcodeline": "sem_rmid(ns, sma);"
    },
    {
        "line": 36,
        "fullcodeline": "sem_unlock(sma);"
    },
    {
        "line": 38,
        "fullcodeline": "wake_up_sem_queue_do(&tasks);"
    },
    {
        "line": 39,
        "fullcodeline": "ns->used_sems -= sma->sem_nsems;"
    },
    {
        "line": 40,
        "fullcodeline": "security_sem_free(sma);"
    },
    {
        "line": 41,
        "fullcodeline": "ipc_rcu_putref(sma);"
    },
    {
        "line": 12,
        "fullcodeline": "list_del(&un->list_id);"
    },
    {
        "line": 14,
        "fullcodeline": "un->semid = -1;"
    },
    {
        "line": 15,
        "fullcodeline": "list_del_rcu(&un->list_proc);"
    },
    {
        "line": 16,
        "fullcodeline": "spin_unlock(&un->ulp->lock);"
    },
    {
        "line": 17,
        "fullcodeline": "kfree_rcu(un, rcu);"
    },
    {
        "line": 23,
        "fullcodeline": "unlink_queue(sma, q);"
    },
    {
        "line": 24,
        "fullcodeline": "wake_up_sem_queue_prepare(&tasks, q, -EIDRM);"
    },
    {
        "line": 26,
        "fullcodeline": "for (i = 0; i < sma->sem_nsems; i++) {"
    },
    {
        "line": 27,
        "fullcodeline": "struct sem *sem = sma->sem_base + i;"
    },
    {
        "line": 28,
        "fullcodeline": "list_for_each_entry_safe(q, tq, &sem->sem_pending, list) {"
    },
    {
        "line": 29,
        "fullcodeline": "unlink_queue(sma, q);"
    },
    {
        "line": 30,
        "fullcodeline": "wake_up_sem_queue_prepare(&tasks, q, -EIDRM);"
    }
]