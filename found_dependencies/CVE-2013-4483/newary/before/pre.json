[
    {
        "line": 7,
        "fullcodeline": "key_t key = params->key;"
    },
    {
        "line": 8,
        "fullcodeline": "int nsems = params->u.nsems;"
    },
    {
        "line": 9,
        "fullcodeline": "int semflg = params->flg;"
    },
    {
        "line": 17,
        "fullcodeline": "size = sizeof (*sma) + nsems * sizeof (struct sem);"
    },
    {
        "line": 18,
        "fullcodeline": "sma = ipc_rcu_alloc(size);"
    },
    {
        "line": 22,
        "fullcodeline": "memset (sma, 0, size);"
    },
    {
        "line": 27,
        "fullcodeline": "sma->sem_perm.security = NULL;"
    },
    {
        "line": 28,
        "fullcodeline": "retval = security_sem_alloc(sma);"
    },
    {
        "line": 34,
        "fullcodeline": "id = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);"
    },
    {
        "line": 42,
        "fullcodeline": "sma->sem_base = (struct sem *) &sma[1];"
    },
    {
        "line": 47,
        "fullcodeline": "sma->complex_count = 0;"
    },
    {
        "line": 50,
        "fullcodeline": "sma->sem_nsems = nsems;"
    },
    {
        "line": 51,
        "fullcodeline": "sma->sem_ctime = get_seconds();"
    },
    {
        "line": 12,
        "fullcodeline": "if (!nsems)"
    },
    {
        "line": 14,
        "fullcodeline": "if (ns->used_sems + nsems > ns->sc_semmns)"
    },
    {
        "line": 19,
        "fullcodeline": "if (!sma) {"
    },
    {
        "line": 24,
        "fullcodeline": "sma->sem_perm.mode = (semflg & S_IRWXUGO);"
    },
    {
        "line": 35,
        "fullcodeline": "if (id < 0) {"
    },
    {
        "line": 44,
        "fullcodeline": "for (i = 0; i < nsems; i++)"
    },
    {
        "line": 36,
        "fullcodeline": "security_sem_free(sma);"
    },
    {
        "line": 13,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 15,
        "fullcodeline": "return -ENOSPC;"
    },
    {
        "line": 20,
        "fullcodeline": "return -ENOMEM;"
    }
]