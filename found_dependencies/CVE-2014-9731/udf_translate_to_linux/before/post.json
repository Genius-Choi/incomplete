[
    {
        "line": 5,
        "fullcodeline": "int index, newIndex = 0, needsCRC = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "int extIndex = 0, newExtIndex = 0, hasExt = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "if (udfName[0] == '.' &&"
    },
    {
        "line": 11,
        "fullcodeline": "(udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {"
    },
    {
        "line": 12,
        "fullcodeline": "needsCRC = 1;"
    },
    {
        "line": 13,
        "fullcodeline": "newIndex = udfLen;"
    },
    {
        "line": 14,
        "fullcodeline": "memcpy(newName, udfName, udfLen);"
    },
    {
        "line": 43,
        "fullcodeline": "uint8_t ext[EXT_SIZE];"
    },
    {
        "line": 44,
        "fullcodeline": "int localExtIndex = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "newName[newIndex++] = CRC_MARK;"
    },
    {
        "line": 72,
        "fullcodeline": "valueCRC = crc_itu_t(0, fidName, fidNameLen);"
    },
    {
        "line": 73,
        "fullcodeline": "newName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);"
    },
    {
        "line": 74,
        "fullcodeline": "newName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);"
    },
    {
        "line": 75,
        "fullcodeline": "newName[newIndex++] = hex_asc_upper_hi(valueCRC);"
    },
    {
        "line": 76,
        "fullcodeline": "newName[newIndex++] = hex_asc_upper_lo(valueCRC);"
    },
    {
        "line": 16,
        "fullcodeline": "for (index = 0; index < udfLen; index++) {"
    },
    {
        "line": 64,
        "fullcodeline": "maxFilenameLen = 250 - localExtIndex;"
    },
    {
        "line": 79,
        "fullcodeline": "newName[newIndex++] = EXT_MARK;"
    },
    {
        "line": 17,
        "fullcodeline": "curr = udfName[index];"
    },
    {
        "line": 49,
        "fullcodeline": "index < EXT_SIZE && extIndex + index + 1 < udfLen;"
    },
    {
        "line": 50,
        "fullcodeline": "index++) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (newIndex > maxFilenameLen)"
    },
    {
        "line": 80,
        "fullcodeline": "for (index = 0; index < localExtIndex; index++)"
    },
    {
        "line": 81,
        "fullcodeline": "newName[newIndex++] = ext[index];"
    },
    {
        "line": 18,
        "fullcodeline": "if (curr == '/' || curr == 0) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (curr == EXT_MARK &&"
    },
    {
        "line": 36,
        "fullcodeline": "if (newIndex < 256)"
    },
    {
        "line": 48,
        "fullcodeline": "for (index = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "curr = udfName[extIndex + index + 1];"
    },
    {
        "line": 62,
        "fullcodeline": "ext[localExtIndex++] = curr;"
    },
    {
        "line": 66,
        "fullcodeline": "newIndex = maxFilenameLen;"
    },
    {
        "line": 69,
        "fullcodeline": "} else if (newIndex > 250)"
    },
    {
        "line": 19,
        "fullcodeline": "needsCRC = 1;"
    },
    {
        "line": 20,
        "fullcodeline": "curr = ILLEGAL_CHAR_MARK;"
    },
    {
        "line": 27,
        "fullcodeline": "(udfLen - index - 1) <= EXT_SIZE) {"
    },
    {
        "line": 37,
        "fullcodeline": "newName[newIndex++] = curr;"
    },
    {
        "line": 53,
        "fullcodeline": "if (curr == '/' || curr == 0) {"
    },
    {
        "line": 68,
        "fullcodeline": "newIndex = newExtIndex;"
    },
    {
        "line": 70,
        "fullcodeline": "newIndex = 250;"
    },
    {
        "line": 21,
        "fullcodeline": "while (index + 1 < udfLen &&"
    },
    {
        "line": 24,
        "fullcodeline": "index++;"
    },
    {
        "line": 28,
        "fullcodeline": "if (udfLen == index + 1)"
    },
    {
        "line": 39,
        "fullcodeline": "needsCRC = 1;"
    },
    {
        "line": 54,
        "fullcodeline": "needsCRC = 1;"
    },
    {
        "line": 55,
        "fullcodeline": "curr = ILLEGAL_CHAR_MARK;"
    },
    {
        "line": 22,
        "fullcodeline": "(udfName[index + 1] == '/' ||"
    },
    {
        "line": 29,
        "fullcodeline": "hasExt = 0;"
    },
    {
        "line": 56,
        "fullcodeline": "while (extIndex + index + 2 < udfLen &&"
    },
    {
        "line": 60,
        "fullcodeline": "index++;"
    },
    {
        "line": 23,
        "fullcodeline": "udfName[index + 1] == 0))"
    },
    {
        "line": 31,
        "fullcodeline": "hasExt = 1;"
    },
    {
        "line": 32,
        "fullcodeline": "extIndex = index;"
    },
    {
        "line": 33,
        "fullcodeline": "newExtIndex = newIndex;"
    },
    {
        "line": 57,
        "fullcodeline": "(index + 1 < EXT_SIZE &&"
    },
    {
        "line": 58,
        "fullcodeline": "(udfName[extIndex + index + 2] == '/' ||"
    },
    {
        "line": 59,
        "fullcodeline": "udfName[extIndex + index + 2] == 0)))"
    }
]