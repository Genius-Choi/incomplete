[
    {
        "line": 5,
        "fullcodeline": "if isinstance(data, oai.Reference):"
    },
    {
        "line": 23,
        "fullcodeline": "if not data.type:"
    },
    {
        "line": 25,
        "fullcodeline": "if data.type == \"string\":"
    },
    {
        "line": 42,
        "fullcodeline": "return PropertyError(data=data, detail=f\"unknown type {data.type}\")"
    },
    {
        "line": 16,
        "fullcodeline": "sub_properties: List[Property] = []"
    },
    {
        "line": 6,
        "fullcodeline": "return RefProperty(name=name, required=required, reference=Reference.from_ref(data.ref), default=None)"
    },
    {
        "line": 8,
        "fullcodeline": "return EnumProperty("
    },
    {
        "line": 17,
        "fullcodeline": "for sub_prop_data in data.anyOf:"
    },
    {
        "line": 22,
        "fullcodeline": "return UnionProperty(name=name, required=required, default=data.default, inner_properties=sub_properties)"
    },
    {
        "line": 24,
        "fullcodeline": "return PropertyError(data=data, detail=\"Schemas must either have one of enum, anyOf, or type defined.\")"
    },
    {
        "line": 26,
        "fullcodeline": "return _string_based_property(name=name, required=required, data=data)"
    },
    {
        "line": 27,
        "fullcodeline": "elif data.type == \"number\":"
    },
    {
        "line": 11,
        "fullcodeline": "values=EnumProperty.values_from_list(data.enum),"
    },
    {
        "line": 12,
        "fullcodeline": "title=data.title or name,"
    },
    {
        "line": 18,
        "fullcodeline": "sub_prop = property_from_data(name=name, required=required, data=sub_prop_data)"
    },
    {
        "line": 21,
        "fullcodeline": "sub_properties.append(sub_prop)"
    },
    {
        "line": 28,
        "fullcodeline": "return FloatProperty(name=name, default=data.default, required=required)"
    },
    {
        "line": 29,
        "fullcodeline": "elif data.type == \"integer\":"
    },
    {
        "line": 19,
        "fullcodeline": "if isinstance(sub_prop, PropertyError):"
    },
    {
        "line": 30,
        "fullcodeline": "return IntProperty(name=name, default=data.default, required=required)"
    },
    {
        "line": 31,
        "fullcodeline": "elif data.type == \"boolean\":"
    },
    {
        "line": 20,
        "fullcodeline": "return PropertyError(detail=f\"Invalid property in union {name}\", data=sub_prop_data)"
    },
    {
        "line": 32,
        "fullcodeline": "return BooleanProperty(name=name, required=required, default=data.default)"
    },
    {
        "line": 33,
        "fullcodeline": "elif data.type == \"array\":"
    },
    {
        "line": 36,
        "fullcodeline": "inner_prop = property_from_data(name=f\"{name}_item\", required=True, data=data.items)"
    },
    {
        "line": 34,
        "fullcodeline": "if data.items is None:"
    },
    {
        "line": 37,
        "fullcodeline": "if isinstance(inner_prop, PropertyError):"
    },
    {
        "line": 39,
        "fullcodeline": "return ListProperty(name=name, required=required, default=data.default, inner_property=inner_prop,)"
    },
    {
        "line": 40,
        "fullcodeline": "elif data.type == \"object\":"
    },
    {
        "line": 35,
        "fullcodeline": "return PropertyError(data=data, detail=\"type array must have items defined\")"
    },
    {
        "line": 38,
        "fullcodeline": "return PropertyError(data=inner_prop.data, detail=f\"invalid data in items of array {name}\")"
    },
    {
        "line": 41,
        "fullcodeline": "return DictProperty(name=name, required=required, default=data.default)"
    }
]