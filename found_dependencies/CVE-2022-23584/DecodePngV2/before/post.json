[
    {
        "line": 2,
        "fullcodeline": "int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;"
    },
    {
        "line": 4,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 14,
        "fullcodeline": "const int width = static_cast<int>(decode.width);"
    },
    {
        "line": 15,
        "fullcodeline": "const int height = static_cast<int>(decode.height);"
    },
    {
        "line": 16,
        "fullcodeline": "const int64_t total_size ="
    },
    {
        "line": 27,
        "fullcodeline": "Tensor* output = nullptr;"
    },
    {
        "line": 57,
        "fullcodeline": "OP_REQUIRES_OK(context, status);"
    },
    {
        "line": 5,
        "fullcodeline": "context, png::CommonInitDecode(input, channels_, channel_bits, &decode),"
    },
    {
        "line": 6,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));"
    },
    {
        "line": 17,
        "fullcodeline": "static_cast<int64_t>(width) * static_cast<int64_t>(height);"
    },
    {
        "line": 18,
        "fullcodeline": "if (width != static_cast<int64_t>(decode.width) || width <= 0 ||"
    },
    {
        "line": 31,
        "fullcodeline": "if (op_type_ == \"DecodeGif\") {"
    },
    {
        "line": 39,
        "fullcodeline": "if (op_type_ == \"DecodeBmp\") {"
    },
    {
        "line": 56,
        "fullcodeline": "if (!status.ok()) png::CommonFreeDecode(&decode);"
    },
    {
        "line": 59,
        "fullcodeline": "if (data_type_ == DataType::DT_UINT8) {"
    },
    {
        "line": 20,
        "fullcodeline": "height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {"
    },
    {
        "line": 21,
        "fullcodeline": "png::CommonFreeDecode(&decode);"
    },
    {
        "line": 22,
        "fullcodeline": "OP_REQUIRES(context, false,"
    },
    {
        "line": 32,
        "fullcodeline": "status = context->allocate_output("
    },
    {
        "line": 45,
        "fullcodeline": "OP_REQUIRES(context, false,"
    },
    {
        "line": 60,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 23,
        "fullcodeline": "errors::InvalidArgument(\"PNG size too large for int: \","
    },
    {
        "line": 35,
        "fullcodeline": "status = context->allocate_output("
    },
    {
        "line": 46,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 62,
        "fullcodeline": "png::CommonFinishDecode("
    },
    {
        "line": 65,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));"
    },
    {
        "line": 33,
        "fullcodeline": "0, TensorShape({1, height, width, decode.channels}), &output);"
    },
    {
        "line": 49,
        "fullcodeline": "} else if (op_type_ == \"DecodeAndCropJpeg\") {"
    },
    {
        "line": 63,
        "fullcodeline": "reinterpret_cast<png_bytep>(output->flat<uint8>().data()),"
    },
    {
        "line": 64,
        "fullcodeline": "decode.channels * width * sizeof(uint8), &decode),"
    },
    {
        "line": 66,
        "fullcodeline": "} else if (data_type_ == DataType::DT_UINT16) {"
    },
    {
        "line": 19,
        "fullcodeline": "width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||"
    },
    {
        "line": 36,
        "fullcodeline": "0, TensorShape({height, width, decode.channels}), &output);"
    },
    {
        "line": 50,
        "fullcodeline": "OP_REQUIRES(context, false,"
    },
    {
        "line": 67,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 51,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 69,
        "fullcodeline": "png::CommonFinishDecode("
    },
    {
        "line": 72,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));"
    },
    {
        "line": 70,
        "fullcodeline": "reinterpret_cast<png_bytep>(output->flat<uint16>().data()),"
    },
    {
        "line": 71,
        "fullcodeline": "decode.channels * width * sizeof(uint16), &decode),"
    },
    {
        "line": 73,
        "fullcodeline": "} else if (data_type_ == DataType::DT_FLOAT) {"
    },
    {
        "line": 77,
        "fullcodeline": "std::unique_ptr<uint16[]> buffer("
    },
    {
        "line": 79,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 88,
        "fullcodeline": "const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();"
    },
    {
        "line": 89,
        "fullcodeline": "TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,"
    },
    {
        "line": 91,
        "fullcodeline": "float scale = 1. / std::numeric_limits<uint16>::max();"
    },
    {
        "line": 93,
        "fullcodeline": "output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;"
    },
    {
        "line": 78,
        "fullcodeline": "new uint16[height * width * decode.channels]);"
    },
    {
        "line": 81,
        "fullcodeline": "png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),"
    },
    {
        "line": 84,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));"
    },
    {
        "line": 82,
        "fullcodeline": "decode.channels * width * sizeof(uint16),"
    }
]