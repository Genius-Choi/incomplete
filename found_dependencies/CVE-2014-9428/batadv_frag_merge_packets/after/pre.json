[
    {
        "line": 5,
        "fullcodeline": "struct sk_buff *skb_out = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "int size, hdr_size = sizeof(struct batadv_frag_packet);"
    },
    {
        "line": 9,
        "fullcodeline": "packet = (struct batadv_frag_packet *)skb->data;"
    },
    {
        "line": 10,
        "fullcodeline": "size = ntohs(packet->total_size);"
    },
    {
        "line": 18,
        "fullcodeline": "hlist_del(&entry->list);"
    },
    {
        "line": 19,
        "fullcodeline": "skb_out = entry->skb;"
    },
    {
        "line": 20,
        "fullcodeline": "kfree(entry);"
    },
    {
        "line": 32,
        "fullcodeline": "skb_pull_rcsum(skb_out, hdr_size);"
    },
    {
        "line": 33,
        "fullcodeline": "memmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);"
    },
    {
        "line": 34,
        "fullcodeline": "skb_set_mac_header(skb_out, -ETH_HLEN);"
    },
    {
        "line": 35,
        "fullcodeline": "skb_reset_network_header(skb_out);"
    },
    {
        "line": 36,
        "fullcodeline": "skb_reset_transport_header(skb_out);"
    },
    {
        "line": 39,
        "fullcodeline": "hlist_for_each_entry(entry, chain, list) {"
    },
    {
        "line": 47,
        "fullcodeline": "batadv_frag_clear_chain(chain);"
    },
    {
        "line": 11,
        "fullcodeline": "if (size > batadv_frag_size_limit())"
    },
    {
        "line": 23,
        "fullcodeline": "if (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {"
    },
    {
        "line": 40,
        "fullcodeline": "size = entry->skb->len - hdr_size;"
    },
    {
        "line": 41,
        "fullcodeline": "memcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,"
    },
    {
        "line": 24,
        "fullcodeline": "kfree_skb(skb_out);"
    },
    {
        "line": 25,
        "fullcodeline": "skb_out = NULL;"
    }
]