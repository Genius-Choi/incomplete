[
    {
        "line": 3,
        "fullcodeline": "struct videobuf_mapping *map = vma->vm_private_data;"
    },
    {
        "line": 4,
        "fullcodeline": "struct videobuf_queue *q = map->q;"
    },
    {
        "line": 7,
        "fullcodeline": "dprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,"
    },
    {
        "line": 10,
        "fullcodeline": "map->count--;"
    },
    {
        "line": 11,
        "fullcodeline": "if (0 == map->count) {"
    },
    {
        "line": 12,
        "fullcodeline": "dprintk(1,\"munmap %p q=%p\\n\",map,q);"
    },
    {
        "line": 13,
        "fullcodeline": "mutex_lock(&q->lock);"
    },
    {
        "line": 26,
        "fullcodeline": "mutex_unlock(&q->lock);"
    },
    {
        "line": 27,
        "fullcodeline": "kfree(map);"
    },
    {
        "line": 14,
        "fullcodeline": "for (i = 0; i < VIDEO_MAX_FRAME; i++) {"
    },
    {
        "line": 21,
        "fullcodeline": "q->ops->buf_release(q,q->bufs[i]);"
    },
    {
        "line": 23,
        "fullcodeline": "q->bufs[i]->map   = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "q->bufs[i]->baddr = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "if (NULL == q->bufs[i])"
    },
    {
        "line": 18,
        "fullcodeline": "if (q->bufs[i]->map != map)"
    }
]