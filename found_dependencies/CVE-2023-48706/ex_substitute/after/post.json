[
    {
        "line": 4,
        "fullcodeline": "long\ti = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,"
    },
    {
        "line": 13,
        "fullcodeline": "char_u\t*pat = NULL, *sub = NULL;\t// init for GCC"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tgot_quit = FALSE;"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\tgot_match = FALSE;"
    },
    {
        "line": 22,
        "fullcodeline": "linenr_T\tfirst_line = 0;\t\t// first changed line"
    },
    {
        "line": 23,
        "fullcodeline": "linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the"
    },
    {
        "line": 29,
        "fullcodeline": "int\t\tendcolumn = FALSE;\t// cursor in last column when done"
    },
    {
        "line": 40,
        "fullcodeline": "cmd = eap->arg;"
    },
    {
        "line": 46,
        "fullcodeline": "start_nsubs = sub_nsubs;"
    },
    {
        "line": 271,
        "fullcodeline": "save_do_all = subflags.do_all;"
    },
    {
        "line": 272,
        "fullcodeline": "save_do_ask = subflags.do_ask;"
    },
    {
        "line": 277,
        "fullcodeline": "cmd = skipwhite(cmd);"
    },
    {
        "line": 304,
        "fullcodeline": "cmd = skipwhite(cmd);"
    },
    {
        "line": 344,
        "fullcodeline": "sub_firstline = NULL;"
    },
    {
        "line": 375,
        "fullcodeline": "line2 = eap->line2;"
    },
    {
        "line": 1210,
        "fullcodeline": "vim_free(sub_firstline); // may have to free allocated copy of the line"
    },
    {
        "line": 1265,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 1266,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 1269,
        "fullcodeline": "subflags.do_all = save_do_all;"
    },
    {
        "line": 1270,
        "fullcodeline": "subflags.do_ask = save_do_ask;"
    },
    {
        "line": 41,
        "fullcodeline": "if (!global_busy)"
    },
    {
        "line": 48,
        "fullcodeline": "if (eap->cmdidx == CMD_tilde)"
    },
    {
        "line": 54,
        "fullcodeline": "if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)"
    },
    {
        "line": 158,
        "fullcodeline": "if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0"
    },
    {
        "line": 204,
        "fullcodeline": "if (*cmd == '&')"
    },
    {
        "line": 278,
        "fullcodeline": "if (VIM_ISDIGIT(*cmd))"
    },
    {
        "line": 305,
        "fullcodeline": "if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment"
    },
    {
        "line": 322,
        "fullcodeline": "if (!subflags.do_count && !curbuf->b_p_ma)"
    },
    {
        "line": 330,
        "fullcodeline": "if (search_regcomp(pat, NULL, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)"
    },
    {
        "line": 339,
        "fullcodeline": "if (subflags.do_ic == 'i')"
    },
    {
        "line": 353,
        "fullcodeline": "if (sub[0] == '\\\\' && sub[1] == '=')"
    },
    {
        "line": 376,
        "fullcodeline": "for (lnum = eap->line1; lnum <= line2 && !(got_quit"
    },
    {
        "line": 380,
        "fullcodeline": "); ++lnum)"
    },
    {
        "line": 1200,
        "fullcodeline": "if (first_line != 0)"
    },
    {
        "line": 1220,
        "fullcodeline": "if (sub_nsubs > start_nsubs)"
    },
    {
        "line": 43,
        "fullcodeline": "sub_nsubs = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "sub_nlines = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "which_pat = RE_LAST;\t// use last used regexp"
    },
    {
        "line": 55,
        "fullcodeline": "&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)"
    },
    {
        "line": 104,
        "fullcodeline": "p = cmd;\t    // remember the start of the substitution"
    },
    {
        "line": 105,
        "fullcodeline": "cmd = skip_substitute(cmd, delimiter);"
    },
    {
        "line": 106,
        "fullcodeline": "sub = vim_strsave(p);"
    },
    {
        "line": 160,
        "fullcodeline": "&& (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'"
    },
    {
        "line": 170,
        "fullcodeline": "curwin->w_cursor.lnum = eap->line1;"
    },
    {
        "line": 180,
        "fullcodeline": "joined_lines_count = eap->line2 - eap->line1 + 1;"
    },
    {
        "line": 195,
        "fullcodeline": "add_to_history(HIST_SEARCH, pat, TRUE, NUL);"
    },
    {
        "line": 196,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 205,
        "fullcodeline": "++cmd;"
    },
    {
        "line": 266,
        "fullcodeline": "++cmd;"
    },
    {
        "line": 269,
        "fullcodeline": "subflags.do_ask = FALSE;"
    },
    {
        "line": 280,
        "fullcodeline": "i = getdigits(&cmd);"
    },
    {
        "line": 295,
        "fullcodeline": "eap->line1 = eap->line2;"
    },
    {
        "line": 296,
        "fullcodeline": "eap->line2 += i - 1;"
    },
    {
        "line": 307,
        "fullcodeline": "set_nextcmd(eap, cmd);"
    },
    {
        "line": 318,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 325,
        "fullcodeline": "emsg(_(e_cannot_make_changes_modifiable_is_off));"
    },
    {
        "line": 326,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 334,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 340,
        "fullcodeline": "regmatch.rmm_ic = TRUE;"
    },
    {
        "line": 355,
        "fullcodeline": "p = vim_strsave(sub);"
    },
    {
        "line": 356,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 359,
        "fullcodeline": "sub = p;"
    },
    {
        "line": 382,
        "fullcodeline": "nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,"
    },
    {
        "line": 1197,
        "fullcodeline": "line_breakcheck();"
    },
    {
        "line": 1205,
        "fullcodeline": "i = curbuf->b_ml.ml_line_count - old_line_count;"
    },
    {
        "line": 1206,
        "fullcodeline": "changed_lines(first_line, 0, last_line - i, i);"
    },
    {
        "line": 1218,
        "fullcodeline": "curwin->w_cursor = old_cursor;"
    },
    {
        "line": 51,
        "fullcodeline": "which_pat = RE_SUBST;\t// use last substitute regexp"
    },
    {
        "line": 58,
        "fullcodeline": "if (check_regexp_delim(*cmd) == FAIL)"
    },
    {
        "line": 71,
        "fullcodeline": "if (*cmd == '\\\\')"
    },
    {
        "line": 107,
        "fullcodeline": "if (sub == NULL)"
    },
    {
        "line": 111,
        "fullcodeline": "if (!eap->skip)"
    },
    {
        "line": 159,
        "fullcodeline": "&& *sub == NUL"
    },
    {
        "line": 171,
        "fullcodeline": "if (*cmd == 'l')"
    },
    {
        "line": 181,
        "fullcodeline": "if (eap->line2 < curbuf->b_ml.ml_line_count)"
    },
    {
        "line": 183,
        "fullcodeline": "if (joined_lines_count > 1)"
    },
    {
        "line": 192,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)"
    },
    {
        "line": 225,
        "fullcodeline": "subflags.do_error = TRUE;"
    },
    {
        "line": 226,
        "fullcodeline": "subflags.do_print = FALSE;"
    },
    {
        "line": 227,
        "fullcodeline": "subflags.do_list = FALSE;"
    },
    {
        "line": 228,
        "fullcodeline": "subflags.do_count = FALSE;"
    },
    {
        "line": 229,
        "fullcodeline": "subflags.do_number = FALSE;"
    },
    {
        "line": 230,
        "fullcodeline": "subflags.do_ic = 0;"
    },
    {
        "line": 238,
        "fullcodeline": "if (*cmd == 'g')"
    },
    {
        "line": 281,
        "fullcodeline": "if (i <= 0 && !eap->skip && subflags.do_error)"
    },
    {
        "line": 297,
        "fullcodeline": "if (eap->line2 > curbuf->b_ml.ml_line_count)"
    },
    {
        "line": 308,
        "fullcodeline": "if (eap->nextcmd == NULL)"
    },
    {
        "line": 357,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 363,
        "fullcodeline": "p = regtilde(sub, magic_isset());"
    },
    {
        "line": 1222,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)"
    },
    {
        "line": 1230,
        "fullcodeline": "if (!global_busy)"
    },
    {
        "line": 78,
        "fullcodeline": "++cmd;"
    },
    {
        "line": 86,
        "fullcodeline": "pat = (char_u *)\"\";\t\t    // empty search pattern"
    },
    {
        "line": 139,
        "fullcodeline": "else if (!eap->skip)\t// use previous pattern and substitution"
    },
    {
        "line": 167,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 172,
        "fullcodeline": "eap->flags = EXFLAG_LIST;"
    },
    {
        "line": 182,
        "fullcodeline": "++joined_lines_count;"
    },
    {
        "line": 185,
        "fullcodeline": "(void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);"
    },
    {
        "line": 186,
        "fullcodeline": "sub_nsubs = joined_lines_count - 1;"
    },
    {
        "line": 187,
        "fullcodeline": "sub_nlines = 1;"
    },
    {
        "line": 188,
        "fullcodeline": "(void)do_sub_msg(FALSE);"
    },
    {
        "line": 189,
        "fullcodeline": "ex_may_print(eap);"
    },
    {
        "line": 193,
        "fullcodeline": "save_re_pat(RE_SUBST, pat, magic_isset());"
    },
    {
        "line": 217,
        "fullcodeline": "if (!p_ed)"
    },
    {
        "line": 239,
        "fullcodeline": "subflags.do_all = !subflags.do_all;"
    },
    {
        "line": 283,
        "fullcodeline": "emsg(_(e_positive_count_required));"
    },
    {
        "line": 284,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 298,
        "fullcodeline": "eap->line2 = curbuf->b_ml.ml_line_count;"
    },
    {
        "line": 310,
        "fullcodeline": "semsg(_(e_trailing_characters_str), cmd);"
    },
    {
        "line": 311,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 333,
        "fullcodeline": "emsg(_(e_invalid_command));"
    },
    {
        "line": 341,
        "fullcodeline": "else if (subflags.do_ic == 'I')"
    },
    {
        "line": 365,
        "fullcodeline": "if (p != sub)"
    },
    {
        "line": 383,
        "fullcodeline": "(colnr_T)0, NULL);"
    },
    {
        "line": 388,
        "fullcodeline": "colnr_T\tprev_matchcol = MAXCOL;"
    },
    {
        "line": 389,
        "fullcodeline": "char_u\t*new_end, *new_start = NULL;"
    },
    {
        "line": 390,
        "fullcodeline": "unsigned\tnew_start_len = 0;"
    },
    {
        "line": 392,
        "fullcodeline": "int\t\tdid_sub = FALSE;"
    },
    {
        "line": 395,
        "fullcodeline": "long\tnmatch_tl = 0;\t// nr of lines matched below lnum"
    },
    {
        "line": 397,
        "fullcodeline": "int\t\tskip_match = FALSE;"
    },
    {
        "line": 450,
        "fullcodeline": "sub_firstlnum = lnum;"
    },
    {
        "line": 451,
        "fullcodeline": "copycol = 0;"
    },
    {
        "line": 452,
        "fullcodeline": "matchcol = 0;"
    },
    {
        "line": 1193,
        "fullcodeline": "vim_free(new_start);\t// for when substitute was cancelled"
    },
    {
        "line": 1194,
        "fullcodeline": "VIM_CLEAR(sub_firstline);\t// free the copy of the original line"
    },
    {
        "line": 1225,
        "fullcodeline": "curbuf->b_op_start.lnum = eap->line1;"
    },
    {
        "line": 1226,
        "fullcodeline": "curbuf->b_op_end.lnum = line2;"
    },
    {
        "line": 1227,
        "fullcodeline": "curbuf->b_op_start.col = curbuf->b_op_end.col = 0;"
    },
    {
        "line": 1246,
        "fullcodeline": "print_line(curwin->w_cursor.lnum,"
    },
    {
        "line": 1249,
        "fullcodeline": "else if (!global_busy)"
    },
    {
        "line": 73,
        "fullcodeline": "if (in_vim9script())"
    },
    {
        "line": 79,
        "fullcodeline": "if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "if (*cmd != '&')"
    },
    {
        "line": 91,
        "fullcodeline": "which_pat = RE_LAST;\t    // use last used regexp"
    },
    {
        "line": 93,
        "fullcodeline": "pat = cmd;\t\t\t    // remember start of search pat"
    },
    {
        "line": 94,
        "fullcodeline": "cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),"
    },
    {
        "line": 114,
        "fullcodeline": "if (STRCMP(sub, \"%\") == 0"
    },
    {
        "line": 146,
        "fullcodeline": "pat = NULL;\t\t// search_regcomp() will use previous pattern"
    },
    {
        "line": 147,
        "fullcodeline": "sub = vim_strsave(old_sub);"
    },
    {
        "line": 151,
        "fullcodeline": "endcolumn = (curwin->w_curswant == MAXCOL);"
    },
    {
        "line": 161,
        "fullcodeline": "|| *cmd == 'p' || *cmd == '#'))))"
    },
    {
        "line": 223,
        "fullcodeline": "subflags.do_ask = FALSE;"
    },
    {
        "line": 342,
        "fullcodeline": "regmatch.rmm_ic = FALSE;"
    },
    {
        "line": 367,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 368,
        "fullcodeline": "sub = p;"
    },
    {
        "line": 455,
        "fullcodeline": "if (!got_match)"
    },
    {
        "line": 1233,
        "fullcodeline": "if (!subflags.do_ask)"
    },
    {
        "line": 1240,
        "fullcodeline": "if (!do_sub_msg(subflags.do_count) && subflags.do_ask)"
    },
    {
        "line": 1244,
        "fullcodeline": "global_need_beginline = TRUE;"
    },
    {
        "line": 75,
        "fullcodeline": "emsg(_(e_cannot_use_s_backslash_in_vim9_script));"
    },
    {
        "line": 81,
        "fullcodeline": "emsg(_(e_backslash_should_be_followed_by));"
    },
    {
        "line": 85,
        "fullcodeline": "which_pat = RE_SEARCH;\t    // use last '/' pattern"
    },
    {
        "line": 87,
        "fullcodeline": "delimiter = *cmd++;\t\t    // remember delimiter character"
    },
    {
        "line": 96,
        "fullcodeline": "if (cmd[0] == delimiter)\t    // end delimiter found"
    },
    {
        "line": 115,
        "fullcodeline": "&& vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)"
    },
    {
        "line": 123,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 124,
        "fullcodeline": "sub = vim_strsave(old_sub);"
    },
    {
        "line": 141,
        "fullcodeline": "if (old_sub == NULL)\t// there is no previous command"
    },
    {
        "line": 173,
        "fullcodeline": "else if (*cmd == '#')"
    },
    {
        "line": 240,
        "fullcodeline": "else if (*cmd == 'c')"
    },
    {
        "line": 287,
        "fullcodeline": "else if (i >= INT_MAX)"
    },
    {
        "line": 457,
        "fullcodeline": "setpcmark();"
    },
    {
        "line": 458,
        "fullcodeline": "got_match = TRUE;"
    },
    {
        "line": 499,
        "fullcodeline": "curwin->w_cursor.lnum = lnum;"
    },
    {
        "line": 500,
        "fullcodeline": "do_again = FALSE;"
    },
    {
        "line": 528,
        "fullcodeline": "matchcol = regmatch.endpos[0].col;"
    },
    {
        "line": 529,
        "fullcodeline": "prev_matchcol = matchcol;"
    },
    {
        "line": 778,
        "fullcodeline": "curwin->w_cursor.col = regmatch.startpos[0].col;"
    },
    {
        "line": 801,
        "fullcodeline": "sublen = vim_regsub_multi(&regmatch,"
    },
    {
        "line": 916,
        "fullcodeline": "copy_len = regmatch.startpos[0].col - copycol;"
    },
    {
        "line": 917,
        "fullcodeline": "needed_len = copy_len + ((unsigned)STRLEN(p1)"
    },
    {
        "line": 959,
        "fullcodeline": "mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);"
    },
    {
        "line": 960,
        "fullcodeline": "new_end += copy_len;"
    },
    {
        "line": 968,
        "fullcodeline": "(void)vim_regsub_multi(&regmatch,"
    },
    {
        "line": 976,
        "fullcodeline": "sub_nsubs++;"
    },
    {
        "line": 977,
        "fullcodeline": "did_sub = TRUE;"
    },
    {
        "line": 981,
        "fullcodeline": "curwin->w_cursor.col = 0;"
    },
    {
        "line": 998,
        "fullcodeline": "copycol = regmatch.endpos[0].col;"
    },
    {
        "line": 1082,
        "fullcodeline": "lastone = (skip_match"
    },
    {
        "line": 1089,
        "fullcodeline": "nmatch = -1;"
    },
    {
        "line": 1188,
        "fullcodeline": "line_breakcheck();"
    },
    {
        "line": 1192,
        "fullcodeline": "++sub_nlines;"
    },
    {
        "line": 1241,
        "fullcodeline": "msg(\"\");"
    },
    {
        "line": 92,
        "fullcodeline": "delimiter = *cmd++;\t\t    // remember delimiter character"
    },
    {
        "line": 97,
        "fullcodeline": "*cmd++ = NUL;\t\t    // replace it with a NUL"
    },
    {
        "line": 117,
        "fullcodeline": "if (old_sub == NULL)\t// there is no previous command"
    },
    {
        "line": 125,
        "fullcodeline": "if (sub == NULL)"
    },
    {
        "line": 131,
        "fullcodeline": "vim_free(old_sub);"
    },
    {
        "line": 132,
        "fullcodeline": "old_sub = vim_strsave(sub);"
    },
    {
        "line": 143,
        "fullcodeline": "emsg(_(e_no_previous_substitute_regular_expression));"
    },
    {
        "line": 174,
        "fullcodeline": "eap->flags = EXFLAG_NR;"
    },
    {
        "line": 220,
        "fullcodeline": "subflags.do_all = TRUE;"
    },
    {
        "line": 241,
        "fullcodeline": "subflags.do_ask = !subflags.do_ask;"
    },
    {
        "line": 289,
        "fullcodeline": "char\tbuf[20];"
    },
    {
        "line": 290,
        "fullcodeline": "vim_snprintf(buf, sizeof(buf), \"%ld\", i);"
    },
    {
        "line": 291,
        "fullcodeline": "semsg(_(e_val_too_large), buf);"
    },
    {
        "line": 292,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 474,
        "fullcodeline": "if (regmatch.startpos[0].lnum > 0)"
    },
    {
        "line": 484,
        "fullcodeline": "if (lnum > curbuf->b_ml.ml_line_count)"
    },
    {
        "line": 487,
        "fullcodeline": "if (sub_firstline == NULL)"
    },
    {
        "line": 507,
        "fullcodeline": "if (matchcol == prev_matchcol"
    },
    {
        "line": 823,
        "fullcodeline": "if (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)"
    },
    {
        "line": 839,
        "fullcodeline": "if (nmatch == 1)"
    },
    {
        "line": 919,
        "fullcodeline": "if (new_start == NULL)"
    },
    {
        "line": 962,
        "fullcodeline": "if ((int)new_start_len - copy_len < sublen)"
    },
    {
        "line": 985,
        "fullcodeline": "if (nmatch > 1)"
    },
    {
        "line": 1017,
        "fullcodeline": "for (p1 = new_end; *p1; ++p1)"
    },
    {
        "line": 1100,
        "fullcodeline": "if (lastone"
    },
    {
        "line": 1252,
        "fullcodeline": "emsg(_(e_interrupted));"
    },
    {
        "line": 119,
        "fullcodeline": "emsg(_(e_no_previous_substitute_regular_expression));"
    },
    {
        "line": 120,
        "fullcodeline": "vim_free(sub);"
    },
    {
        "line": 133,
        "fullcodeline": "if (old_sub == NULL)"
    },
    {
        "line": 222,
        "fullcodeline": "subflags.do_all = FALSE;"
    },
    {
        "line": 476,
        "fullcodeline": "lnum += regmatch.startpos[0].lnum;"
    },
    {
        "line": 477,
        "fullcodeline": "sub_firstlnum += regmatch.startpos[0].lnum;"
    },
    {
        "line": 478,
        "fullcodeline": "nmatch -= regmatch.startpos[0].lnum;"
    },
    {
        "line": 479,
        "fullcodeline": "VIM_CLEAR(sub_firstline);"
    },
    {
        "line": 489,
        "fullcodeline": "sub_firstline = vim_strsave(ml_get(sub_firstlnum));"
    },
    {
        "line": 509,
        "fullcodeline": "&& matchcol == regmatch.endpos[0].col)"
    },
    {
        "line": 547,
        "fullcodeline": "sub_nsubs++;"
    },
    {
        "line": 548,
        "fullcodeline": "did_sub = TRUE;"
    },
    {
        "line": 559,
        "fullcodeline": "int typed = 0;"
    },
    {
        "line": 563,
        "fullcodeline": "save_State = State;"
    },
    {
        "line": 564,
        "fullcodeline": "State = MODE_CONFIRM;"
    },
    {
        "line": 565,
        "fullcodeline": "setmouse();\t\t// disable mouse in xterm"
    },
    {
        "line": 566,
        "fullcodeline": "curwin->w_cursor.col = regmatch.startpos[0].col;"
    },
    {
        "line": 753,
        "fullcodeline": "State = save_State;"
    },
    {
        "line": 754,
        "fullcodeline": "setmouse();"
    },
    {
        "line": 802,
        "fullcodeline": "sub_firstlnum - regmatch.startpos[0].lnum,"
    },
    {
        "line": 804,
        "fullcodeline": "REGSUB_BACKSLASH"
    },
    {
        "line": 825,
        "fullcodeline": "nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;"
    },
    {
        "line": 826,
        "fullcodeline": "skip_match = TRUE;"
    },
    {
        "line": 841,
        "fullcodeline": "p1 = sub_firstline;"
    },
    {
        "line": 926,
        "fullcodeline": "new_start_len = needed_len + 50;"
    },
    {
        "line": 929,
        "fullcodeline": "*new_start = NUL;"
    },
    {
        "line": 930,
        "fullcodeline": "new_end = new_start;"
    },
    {
        "line": 963,
        "fullcodeline": "sublen = new_start_len - copy_len - 1;"
    },
    {
        "line": 969,
        "fullcodeline": "sub_firstlnum - regmatch.startpos[0].lnum,"
    },
    {
        "line": 971,
        "fullcodeline": "REGSUB_COPY | REGSUB_BACKSLASH"
    },
    {
        "line": 987,
        "fullcodeline": "sub_firstlnum += nmatch - 1;"
    },
    {
        "line": 988,
        "fullcodeline": "vim_free(sub_firstline);"
    },
    {
        "line": 989,
        "fullcodeline": "sub_firstline = vim_strsave(ml_get(sub_firstlnum));"
    },
    {
        "line": 1004,
        "fullcodeline": "vim_free(sub_firstline);"
    },
    {
        "line": 1005,
        "fullcodeline": "sub_firstline = vim_strsave((char_u *)\"\");"
    },
    {
        "line": 1006,
        "fullcodeline": "copycol = 0;"
    },
    {
        "line": 1087,
        "fullcodeline": "|| (sub_firstline[matchcol] == NUL && nmatch <= 1"
    },
    {
        "line": 1105,
        "fullcodeline": "|| regmatch.startpos[0].lnum > 0)"
    },
    {
        "line": 1236,
        "fullcodeline": "coladvance((colnr_T)MAXCOL);"
    },
    {
        "line": 175,
        "fullcodeline": "else if (*cmd == 'p')"
    },
    {
        "line": 242,
        "fullcodeline": "else if (*cmd == 'n')"
    },
    {
        "line": 490,
        "fullcodeline": "if (sub_firstline == NULL)"
    },
    {
        "line": 508,
        "fullcodeline": "&& regmatch.endpos[0].lnum == 0"
    },
    {
        "line": 511,
        "fullcodeline": "if (sub_firstline[matchcol] == NUL)"
    },
    {
        "line": 541,
        "fullcodeline": "if (nmatch > 1)"
    },
    {
        "line": 572,
        "fullcodeline": "if (vim_strchr(p_cpo, CPO_UNDO) != NULL)"
    },
    {
        "line": 755,
        "fullcodeline": "if (vim_strchr(p_cpo, CPO_UNDO) != NULL)"
    },
    {
        "line": 758,
        "fullcodeline": "if (typed == 'n')"
    },
    {
        "line": 805,
        "fullcodeline": "| (magic_isset() ? REGSUB_MAGIC : 0));"
    },
    {
        "line": 828,
        "fullcodeline": "if (nmatch < 0)"
    },
    {
        "line": 862,
        "fullcodeline": "linenr_T\tlastlnum = sub_firstlnum + nmatch - 1;"
    },
    {
        "line": 908,
        "fullcodeline": "p1 = ml_get(lastlnum);"
    },
    {
        "line": 909,
        "fullcodeline": "nmatch_tl += nmatch - 1;"
    },
    {
        "line": 927,
        "fullcodeline": "if ((new_start = alloc(new_start_len)) == NULL)"
    },
    {
        "line": 939,
        "fullcodeline": "len = (unsigned)STRLEN(new_start);"
    },
    {
        "line": 940,
        "fullcodeline": "needed_len += len;"
    },
    {
        "line": 953,
        "fullcodeline": "new_end = new_start + len;"
    },
    {
        "line": 972,
        "fullcodeline": "| (magic_isset() ? REGSUB_MAGIC : 0));"
    },
    {
        "line": 991,
        "fullcodeline": "if (sub_firstlnum <= line2)"
    },
    {
        "line": 1019,
        "fullcodeline": "if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash"
    },
    {
        "line": 1086,
        "fullcodeline": "|| !(subflags.do_all || do_again)"
    },
    {
        "line": 1088,
        "fullcodeline": "&& !re_multiline(regmatch.regprog)));"
    },
    {
        "line": 1102,
        "fullcodeline": "|| (nmatch = vim_regexec_multi(&regmatch, curwin,"
    },
    {
        "line": 1107,
        "fullcodeline": "if (new_start != NULL)"
    },
    {
        "line": 1170,
        "fullcodeline": "if (nmatch == -1 && !lastone)"
    },
    {
        "line": 1177,
        "fullcodeline": "if (nmatch <= 0)"
    },
    {
        "line": 1238,
        "fullcodeline": "beginline(BL_WHITE | BL_FIX);"
    },
    {
        "line": 176,
        "fullcodeline": "eap->flags = EXFLAG_PRINT;"
    },
    {
        "line": 243,
        "fullcodeline": "subflags.do_count = TRUE;"
    },
    {
        "line": 492,
        "fullcodeline": "vim_free(new_start);"
    },
    {
        "line": 514,
        "fullcodeline": "skip_match = TRUE;"
    },
    {
        "line": 543,
        "fullcodeline": "matchcol = (colnr_T)STRLEN(sub_firstline);"
    },
    {
        "line": 544,
        "fullcodeline": "nmatch = 1;"
    },
    {
        "line": 545,
        "fullcodeline": "skip_match = TRUE;"
    },
    {
        "line": 568,
        "fullcodeline": "do_check_cursorbind();"
    },
    {
        "line": 573,
        "fullcodeline": "++no_u_sync;"
    },
    {
        "line": 722,
        "fullcodeline": "need_wait_return = FALSE; // no hit-return prompt"
    },
    {
        "line": 756,
        "fullcodeline": "--no_u_sync;"
    },
    {
        "line": 941,
        "fullcodeline": "if (needed_len > (int)new_start_len)"
    },
    {
        "line": 992,
        "fullcodeline": "do_again = TRUE;"
    },
    {
        "line": 1021,
        "fullcodeline": "STRMOVE(p1, p1 + 1);"
    },
    {
        "line": 1085,
        "fullcodeline": "|| lnum > line2"
    },
    {
        "line": 1101,
        "fullcodeline": "|| nmatch_tl > 0"
    },
    {
        "line": 1116,
        "fullcodeline": "STRCAT(new_start, sub_firstline + copycol);"
    },
    {
        "line": 1117,
        "fullcodeline": "matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;"
    },
    {
        "line": 1118,
        "fullcodeline": "prev_matchcol = (colnr_T)STRLEN(sub_firstline)"
    },
    {
        "line": 1123,
        "fullcodeline": "ml_replace(lnum, new_start, TRUE);"
    },
    {
        "line": 1161,
        "fullcodeline": "sub_firstlnum = lnum;"
    },
    {
        "line": 1162,
        "fullcodeline": "vim_free(sub_firstline);    // free the temp buffer"
    },
    {
        "line": 1163,
        "fullcodeline": "sub_firstline = new_start;"
    },
    {
        "line": 1164,
        "fullcodeline": "new_start = NULL;"
    },
    {
        "line": 1165,
        "fullcodeline": "matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;"
    },
    {
        "line": 1166,
        "fullcodeline": "prev_matchcol = (colnr_T)STRLEN(sub_firstline)"
    },
    {
        "line": 1168,
        "fullcodeline": "copycol = 0;"
    },
    {
        "line": 1171,
        "fullcodeline": "nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,"
    },
    {
        "line": 1254,
        "fullcodeline": "msg(\"\");"
    },
    {
        "line": 723,
        "fullcodeline": "if (typed == 'q' || typed == ESC || typed == Ctrl_C"
    },
    {
        "line": 732,
        "fullcodeline": "if (typed == 'n')"
    },
    {
        "line": 734,
        "fullcodeline": "if (typed == 'y')"
    },
    {
        "line": 736,
        "fullcodeline": "if (typed == 'l')"
    },
    {
        "line": 743,
        "fullcodeline": "if (typed == 'a')"
    },
    {
        "line": 748,
        "fullcodeline": "if (typed == Ctrl_E)"
    },
    {
        "line": 765,
        "fullcodeline": "if (nmatch > 1)"
    },
    {
        "line": 943,
        "fullcodeline": "new_start_len = needed_len + 50;"
    },
    {
        "line": 949,
        "fullcodeline": "mch_memmove(p1, new_start, (size_t)(len + 1));"
    },
    {
        "line": 950,
        "fullcodeline": "vim_free(new_start);"
    },
    {
        "line": 951,
        "fullcodeline": "new_start = p1;"
    },
    {
        "line": 994,
        "fullcodeline": "subflags.do_all = FALSE;"
    },
    {
        "line": 1121,
        "fullcodeline": "if (u_savesub(lnum) != OK)"
    },
    {
        "line": 1128,
        "fullcodeline": "if (nmatch_tl > 0)"
    },
    {
        "line": 1182,
        "fullcodeline": "if (nmatch == -1)"
    },
    {
        "line": 244,
        "fullcodeline": "else if (*cmd == 'e')"
    },
    {
        "line": 585,
        "fullcodeline": "print_line_no_prefix(lnum,"
    },
    {
        "line": 588,
        "fullcodeline": "getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);"
    },
    {
        "line": 589,
        "fullcodeline": "curwin->w_cursor.col = regmatch.endpos[0].col - 1;"
    },
    {
        "line": 592,
        "fullcodeline": "getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);"
    },
    {
        "line": 600,
        "fullcodeline": "msg_start();"
    },
    {
        "line": 606,
        "fullcodeline": "resp = getexmodeline('?', NULL, 0, TRUE);"
    },
    {
        "line": 729,
        "fullcodeline": "got_quit = TRUE;"
    },
    {
        "line": 739,
        "fullcodeline": "subflags.do_all = FALSE;"
    },
    {
        "line": 740,
        "fullcodeline": "line2 = lnum;"
    },
    {
        "line": 745,
        "fullcodeline": "subflags.do_ask = FALSE;"
    },
    {
        "line": 749,
        "fullcodeline": "scrollup_clamp();"
    },
    {
        "line": 767,
        "fullcodeline": "matchcol = (colnr_T)STRLEN(sub_firstline);"
    },
    {
        "line": 768,
        "fullcodeline": "skip_match = TRUE;"
    },
    {
        "line": 944,
        "fullcodeline": "if ((p1 = alloc(new_start_len)) == NULL)"
    },
    {
        "line": 1034,
        "fullcodeline": "else if (*p1 == CAR)"
    },
    {
        "line": 1136,
        "fullcodeline": "++lnum;"
    },
    {
        "line": 1141,
        "fullcodeline": "mark_adjust(lnum, lnum + nmatch_tl - 1,"
    },
    {
        "line": 1145,
        "fullcodeline": "--lnum;"
    },
    {
        "line": 1146,
        "fullcodeline": "line2 -= nmatch_tl; // nr of lines decreases"
    },
    {
        "line": 1147,
        "fullcodeline": "nmatch_tl = 0;"
    },
    {
        "line": 1153,
        "fullcodeline": "changed_bytes(lnum, 0);"
    },
    {
        "line": 1183,
        "fullcodeline": "lnum -= regmatch.startpos[0].lnum;"
    },
    {
        "line": 245,
        "fullcodeline": "subflags.do_error = !subflags.do_error;"
    },
    {
        "line": 519,
        "fullcodeline": "matchcol += mb_ptr2len(sub_firstline + matchcol);"
    },
    {
        "line": 590,
        "fullcodeline": "if (curwin->w_cursor.col < 0)"
    },
    {
        "line": 594,
        "fullcodeline": "if (subflags.do_number || curwin->w_p_nu)"
    },
    {
        "line": 601,
        "fullcodeline": "for (i = 0; i < (long)sc; ++i)"
    },
    {
        "line": 602,
        "fullcodeline": "msg_putchar(' ');"
    },
    {
        "line": 603,
        "fullcodeline": "for ( ; i <= (long)ec; ++i)"
    },
    {
        "line": 604,
        "fullcodeline": "msg_putchar('^');"
    },
    {
        "line": 607,
        "fullcodeline": "if (resp != NULL)"
    },
    {
        "line": 620,
        "fullcodeline": "char_u *orig_line = NULL;"
    },
    {
        "line": 621,
        "fullcodeline": "int    len_change = 0;"
    },
    {
        "line": 622,
        "fullcodeline": "int\t   save_p_lz = p_lz;"
    },
    {
        "line": 630,
        "fullcodeline": "int save_RedrawingDisabled = RedrawingDisabled;"
    },
    {
        "line": 631,
        "fullcodeline": "RedrawingDisabled = 0;"
    },
    {
        "line": 634,
        "fullcodeline": "p_lz = FALSE;"
    },
    {
        "line": 666,
        "fullcodeline": "search_match_lines = regmatch.endpos[0].lnum"
    },
    {
        "line": 668,
        "fullcodeline": "search_match_endcol = regmatch.endpos[0].col"
    },
    {
        "line": 674,
        "fullcodeline": "highlight_match = TRUE;"
    },
    {
        "line": 676,
        "fullcodeline": "update_topline();"
    },
    {
        "line": 677,
        "fullcodeline": "validate_cursor();"
    },
    {
        "line": 678,
        "fullcodeline": "update_screen(UPD_SOME_VALID);"
    },
    {
        "line": 679,
        "fullcodeline": "highlight_match = FALSE;"
    },
    {
        "line": 680,
        "fullcodeline": "redraw_later(UPD_SOME_VALID);"
    },
    {
        "line": 687,
        "fullcodeline": "msg_starthere();"
    },
    {
        "line": 688,
        "fullcodeline": "i = msg_scroll;"
    },
    {
        "line": 689,
        "fullcodeline": "msg_scroll = 0;\t\t// truncate msg when"
    },
    {
        "line": 691,
        "fullcodeline": "msg_no_more = TRUE;"
    },
    {
        "line": 694,
        "fullcodeline": "smsg_attr(HL_ATTR(HLF_R),"
    },
    {
        "line": 696,
        "fullcodeline": "msg_no_more = FALSE;"
    },
    {
        "line": 697,
        "fullcodeline": "msg_scroll = i;"
    },
    {
        "line": 698,
        "fullcodeline": "showruler(TRUE);"
    },
    {
        "line": 699,
        "fullcodeline": "windgoto(msg_row, msg_col);"
    },
    {
        "line": 700,
        "fullcodeline": "RedrawingDisabled = save_RedrawingDisabled;"
    },
    {
        "line": 705,
        "fullcodeline": "++no_mapping;\t// don't map this key"
    },
    {
        "line": 706,
        "fullcodeline": "++allow_keys;\t// allow special keys"
    },
    {
        "line": 707,
        "fullcodeline": "typed = plain_vgetc();"
    },
    {
        "line": 708,
        "fullcodeline": "--allow_keys;"
    },
    {
        "line": 709,
        "fullcodeline": "--no_mapping;"
    },
    {
        "line": 712,
        "fullcodeline": "msg_didout = FALSE;\t// don't scroll up"
    },
    {
        "line": 713,
        "fullcodeline": "msg_col = 0;"
    },
    {
        "line": 714,
        "fullcodeline": "gotocmdline(TRUE);"
    },
    {
        "line": 715,
        "fullcodeline": "p_lz = save_p_lz;"
    },
    {
        "line": 946,
        "fullcodeline": "vim_free(new_start);"
    },
    {
        "line": 1137,
        "fullcodeline": "if (u_savedel(lnum, nmatch_tl) != OK)"
    },
    {
        "line": 1139,
        "fullcodeline": "for (i = 0; i < nmatch_tl; ++i)"
    },
    {
        "line": 1140,
        "fullcodeline": "ml_delete(lnum);"
    },
    {
        "line": 1142,
        "fullcodeline": "(long)MAXLNUM, -nmatch_tl);"
    },
    {
        "line": 1158,
        "fullcodeline": "last_line = lnum + 1;"
    },
    {
        "line": 1256,
        "fullcodeline": "semsg(_(e_pattern_not_found_str), get_search_pat());"
    },
    {
        "line": 521,
        "fullcodeline": "++matchcol;"
    },
    {
        "line": 591,
        "fullcodeline": "curwin->w_cursor.col = 0;"
    },
    {
        "line": 596,
        "fullcodeline": "int numw = number_width(curwin) + 1;"
    },
    {
        "line": 597,
        "fullcodeline": "sc += numw;"
    },
    {
        "line": 598,
        "fullcodeline": "ec += numw;"
    },
    {
        "line": 610,
        "fullcodeline": "vim_free(resp);"
    },
    {
        "line": 636,
        "fullcodeline": "if (new_start != NULL)"
    },
    {
        "line": 670,
        "fullcodeline": "if (search_match_lines == 0"
    },
    {
        "line": 685,
        "fullcodeline": "if (msg_row == Rows - 1)"
    },
    {
        "line": 695,
        "fullcodeline": "_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);"
    },
    {
        "line": 718,
        "fullcodeline": "if (orig_line != NULL)"
    },
    {
        "line": 750,
        "fullcodeline": "else if (typed == Ctrl_Y)"
    },
    {
        "line": 1036,
        "fullcodeline": "if (u_inssub(lnum) == OK)   // prepare for undo"
    },
    {
        "line": 1144,
        "fullcodeline": "deleted_lines(lnum, nmatch_tl);"
    },
    {
        "line": 1156,
        "fullcodeline": "if (first_line == 0)"
    },
    {
        "line": 246,
        "fullcodeline": "else if (*cmd == 'r')\t    // use last used regexp"
    },
    {
        "line": 614,
        "fullcodeline": "if (ex_normal_busy && typed == NUL)"
    },
    {
        "line": 643,
        "fullcodeline": "orig_line = vim_strsave(ml_get(lnum));"
    },
    {
        "line": 671,
        "fullcodeline": "&& search_match_endcol == 0)"
    },
    {
        "line": 673,
        "fullcodeline": "search_match_endcol = 1;"
    },
    {
        "line": 686,
        "fullcodeline": "msg_didout = FALSE;\t// avoid a scroll-up"
    },
    {
        "line": 719,
        "fullcodeline": "ml_replace(lnum, orig_line, FALSE);"
    },
    {
        "line": 751,
        "fullcodeline": "scrolldown_clamp();"
    },
    {
        "line": 1038,
        "fullcodeline": "colnr_T\tplen = (colnr_T)(p1 - new_start + 1);"
    },
    {
        "line": 1040,
        "fullcodeline": "*p1 = NUL;\t\t    // truncate up to the CR"
    },
    {
        "line": 1041,
        "fullcodeline": "ml_append(lnum - 1, new_start, plen, FALSE);"
    },
    {
        "line": 1042,
        "fullcodeline": "mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);"
    },
    {
        "line": 1056,
        "fullcodeline": "++sub_firstlnum;"
    },
    {
        "line": 1057,
        "fullcodeline": "++lnum;"
    },
    {
        "line": 1058,
        "fullcodeline": "++line2;"
    },
    {
        "line": 1060,
        "fullcodeline": "++curwin->w_cursor.lnum;"
    },
    {
        "line": 1062,
        "fullcodeline": "STRMOVE(new_start, p1 + 1);"
    },
    {
        "line": 1063,
        "fullcodeline": "p1 = new_start - 1;"
    },
    {
        "line": 1157,
        "fullcodeline": "first_line = lnum;"
    },
    {
        "line": 247,
        "fullcodeline": "which_pat = RE_LAST;"
    },
    {
        "line": 615,
        "fullcodeline": "typed = 'q';"
    },
    {
        "line": 644,
        "fullcodeline": "if (orig_line != NULL)"
    },
    {
        "line": 1067,
        "fullcodeline": "p1 += (*mb_ptr2len)(p1) - 1;"
    },
    {
        "line": 646,
        "fullcodeline": "char_u *new_line = concat_str(new_start,"
    },
    {
        "line": 1044,
        "fullcodeline": "appended_lines(lnum - 1, 1L);"
    },
    {
        "line": 248,
        "fullcodeline": "else if (*cmd == 'p')"
    },
    {
        "line": 649,
        "fullcodeline": "if (new_line == NULL)"
    },
    {
        "line": 1049,
        "fullcodeline": "last_line = lnum + 1;"
    },
    {
        "line": 249,
        "fullcodeline": "subflags.do_print = TRUE;"
    },
    {
        "line": 647,
        "fullcodeline": "sub_firstline + copycol);"
    },
    {
        "line": 650,
        "fullcodeline": "VIM_CLEAR(orig_line);"
    },
    {
        "line": 1047,
        "fullcodeline": "if (first_line == 0)"
    },
    {
        "line": 658,
        "fullcodeline": "len_change = (int)STRLEN(new_line)"
    },
    {
        "line": 660,
        "fullcodeline": "curwin->w_cursor.col += len_change;"
    },
    {
        "line": 661,
        "fullcodeline": "ml_replace(lnum, new_line, FALSE);"
    },
    {
        "line": 1048,
        "fullcodeline": "first_line = lnum;"
    },
    {
        "line": 250,
        "fullcodeline": "else if (*cmd == '#')"
    },
    {
        "line": 252,
        "fullcodeline": "subflags.do_print = TRUE;"
    },
    {
        "line": 253,
        "fullcodeline": "subflags.do_number = TRUE;"
    },
    {
        "line": 659,
        "fullcodeline": "- (int)STRLEN(orig_line);"
    },
    {
        "line": 255,
        "fullcodeline": "else if (*cmd == 'l')"
    },
    {
        "line": 257,
        "fullcodeline": "subflags.do_print = TRUE;"
    },
    {
        "line": 258,
        "fullcodeline": "subflags.do_list = TRUE;"
    },
    {
        "line": 260,
        "fullcodeline": "else if (*cmd == 'i')\t    // ignore case"
    },
    {
        "line": 261,
        "fullcodeline": "subflags.do_ic = 'i';"
    },
    {
        "line": 262,
        "fullcodeline": "else if (*cmd == 'I')\t    // don't ignore case"
    },
    {
        "line": 263,
        "fullcodeline": "subflags.do_ic = 'I';"
    }
]