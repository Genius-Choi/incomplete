[
    {
        "line": 3,
        "fullcodeline": "unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];"
    },
    {
        "line": 4,
        "fullcodeline": "fi->seek(0, SEEK_SET);"
    },
    {
        "line": 5,
        "fullcodeline": "fi->readx(&mhdri, sizeof(mhdri));"
    },
    {
        "line": 12,
        "fullcodeline": "my_cpusubtype = mhdri.cpusubtype;"
    },
    {
        "line": 14,
        "fullcodeline": "unsigned const ncmds = mhdri.ncmds;"
    },
    {
        "line": 15,
        "fullcodeline": "int headway = (int)mhdri.sizeofcmds;"
    },
    {
        "line": 26,
        "fullcodeline": "sz_mach_headers = headway + sizeof(mhdri);"
    },
    {
        "line": 30,
        "fullcodeline": "rawmseg_buf.alloc(mhdri.sizeofcmds);"
    },
    {
        "line": 31,
        "fullcodeline": "rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();"
    },
    {
        "line": 32,
        "fullcodeline": "fi->readx(rawmseg, mhdri.sizeofcmds);"
    },
    {
        "line": 34,
        "fullcodeline": "Mach_segment_command const *ptrTEXT = nullptr;"
    },
    {
        "line": 35,
        "fullcodeline": "upx_uint64_t rip = 0;"
    },
    {
        "line": 36,
        "fullcodeline": "unsigned style = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "off_t offLINK = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "unsigned pos_next = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "unsigned nseg = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "Mach_command const *ptr = (Mach_command const *)rawmseg;"
    },
    {
        "line": 105,
        "fullcodeline": "int const small = 32 + sizeof(overlay_offset);"
    },
    {
        "line": 106,
        "fullcodeline": "unsigned bufsize = 4096;"
    },
    {
        "line": 124,
        "fullcodeline": "MemBuffer buf(bufsize);"
    },
    {
        "line": 126,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 127,
        "fullcodeline": "int i = bufsize;"
    },
    {
        "line": 129,
        "fullcodeline": "i -= small;"
    },
    {
        "line": 221,
        "fullcodeline": "overlay_offset = 0;  // impossible value"
    },
    {
        "line": 222,
        "fullcodeline": "int l = ph.buf_offset + ph.getPackHeaderSize();"
    },
    {
        "line": 7,
        "fullcodeline": "if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic"
    },
    {
        "line": 27,
        "fullcodeline": "if (2048 < headway) {"
    },
    {
        "line": 41,
        "fullcodeline": "for (unsigned j= 0; j < ncmds;"
    },
    {
        "line": 98,
        "fullcodeline": "if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) { // pre-3.91 ?"
    },
    {
        "line": 107,
        "fullcodeline": "if (391 == style) { // PackHeader precedes __LINKEDIT"
    },
    {
        "line": 226,
        "fullcodeline": "if (       overlay_offset < sz_mach_headers"
    },
    {
        "line": 9,
        "fullcodeline": "||  my_filetype  !=mhdri.filetype"
    },
    {
        "line": 18,
        "fullcodeline": "if ((2 == ncmds"
    },
    {
        "line": 20,
        "fullcodeline": "||  (3 <= ncmds"
    },
    {
        "line": 23,
        "fullcodeline": "infoWarning(\"Mach_header.sizeofcmds = %d too small\", headway);"
    },
    {
        "line": 28,
        "fullcodeline": "infoWarning(\"Mach_header.sizeofcmds(%d) > 2048\", headway);"
    },
    {
        "line": 42,
        "fullcodeline": "ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (3==nseg && 395 != style) { // __PAGEZERO, __TEXT, __LINKEDIT;  no __XHDR, no UPX_DATA"
    },
    {
        "line": 96,
        "fullcodeline": "style = 392;"
    },
    {
        "line": 99,
        "fullcodeline": "offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;  // fake __LINKEDIT at EOF"
    },
    {
        "line": 101,
        "fullcodeline": "if (0 == style || 0 == offLINK) {"
    },
    {
        "line": 108,
        "fullcodeline": "fi->seek(offLINK - bufsize, SEEK_SET);"
    },
    {
        "line": 128,
        "fullcodeline": "while (i > small && 0 == buf[--i]) { }"
    },
    {
        "line": 131,
        "fullcodeline": "if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {"
    },
    {
        "line": 134,
        "fullcodeline": "upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;"
    },
    {
        "line": 223,
        "fullcodeline": "if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {"
    },
    {
        "line": 224,
        "fullcodeline": "overlay_offset = get_te32(buf + i + l);"
    },
    {
        "line": 227,
        "fullcodeline": "||  (off_t)overlay_offset >= file_size) {"
    },
    {
        "line": 230,
        "fullcodeline": "fi->seek(sz_mach_headers, SEEK_SET);"
    },
    {
        "line": 231,
        "fullcodeline": "fi->readx(buf2, buf2.getSize());"
    },
    {
        "line": 232,
        "fullcodeline": "unsigned const *p = (unsigned const *)&buf2[0];"
    },
    {
        "line": 233,
        "fullcodeline": "unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];"
    },
    {
        "line": 8,
        "fullcodeline": "||  my_cputype   !=mhdri.cputype"
    },
    {
        "line": 19,
        "fullcodeline": "&& headway < (int)(sizeof(Mach_segment_command) + 4*4))"
    },
    {
        "line": 21,
        "fullcodeline": "&& headway < (int)(3 * sizeof(Mach_segment_command)"
    },
    {
        "line": 43,
        "fullcodeline": "if ((unsigned)headway < ptr->cmdsize) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (lc_seg == ptr->cmd) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (391==style) {"
    },
    {
        "line": 229,
        "fullcodeline": "MemBuffer buf2(umin(1<<14, file_size));"
    },
    {
        "line": 234,
        "fullcodeline": "for (; p <= e_buf2; ++p)"
    },
    {
        "line": 44,
        "fullcodeline": "infoWarning(\"bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\","
    },
    {
        "line": 50,
        "fullcodeline": "Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;"
    },
    {
        "line": 61,
        "fullcodeline": "++nseg;"
    },
    {
        "line": 83,
        "fullcodeline": "pos_next = segptr->filesize + segptr->fileoff;"
    },
    {
        "line": 110,
        "fullcodeline": "if (392 == style) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {"
    },
    {
        "line": 136,
        "fullcodeline": "fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);"
    },
    {
        "line": 137,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 138,
        "fullcodeline": "unsigned char const *b = &buf[0];"
    },
    {
        "line": 139,
        "fullcodeline": "unsigned disp = *(TE32 const *)&b[1];"
    },
    {
        "line": 161,
        "fullcodeline": "TE32 const *uptr = (TE32 const *)&buf[bufsize];"
    },
    {
        "line": 163,
        "fullcodeline": "overlay_offset = *uptr;"
    },
    {
        "line": 171,
        "fullcodeline": "overlay_offset = 0x100c;  // (l_info precedes;) p_info; b_info; cpr_data"
    },
    {
        "line": 175,
        "fullcodeline": "fi->seek(overlay_offset, SEEK_SET);"
    },
    {
        "line": 176,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 177,
        "fullcodeline": "struct p_info const *const p_ptr = (struct p_info const *)&buf[0];"
    },
    {
        "line": 178,
        "fullcodeline": "struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);"
    },
    {
        "line": 179,
        "fullcodeline": "TE32 const *uptr = (TE32 const *)(1+ b_ptr);"
    },
    {
        "line": 201,
        "fullcodeline": "fi->seek(offLINK - 0x1000, SEEK_SET);"
    },
    {
        "line": 202,
        "fullcodeline": "fi->readx(buf, 0x1000);"
    },
    {
        "line": 203,
        "fullcodeline": "unsigned const *const lo = (unsigned const *)&buf[0];"
    },
    {
        "line": 180,
        "fullcodeline": "if (b_ptr->sz_unc < 0x4000"
    },
    {
        "line": 205,
        "fullcodeline": "for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (   0==p[0]  // p_info.p_progid"
    },
    {
        "line": 239,
        "fullcodeline": "&&  sz_mach_headers==get_te32(&p[3])  // b_info.sz_unc"
    },
    {
        "line": 241,
        "fullcodeline": "overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;"
    },
    {
        "line": 22,
        "fullcodeline": "+ sizeof(Mach_main_command)))) {"
    },
    {
        "line": 51,
        "fullcodeline": "if ((unsigned long)file_size < segptr->filesize"
    },
    {
        "line": 53,
        "fullcodeline": "||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {"
    },
    {
        "line": 54,
        "fullcodeline": "infoWarning(\"bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\""
    },
    {
        "line": 62,
        "fullcodeline": "if (!strcmp(\"__XHDR\", segptr->segname)) {"
    },
    {
        "line": 64,
        "fullcodeline": "style = 391;  // UPX 3.91"
    },
    {
        "line": 66,
        "fullcodeline": "if (!strcmp(\"__TEXT\", segptr->segname)) {"
    },
    {
        "line": 67,
        "fullcodeline": "ptrTEXT = segptr;"
    },
    {
        "line": 68,
        "fullcodeline": "style = 391;  // UPX 3.91"
    },
    {
        "line": 70,
        "fullcodeline": "if (!strcmp(\"UPX_DATA\", segptr->segname)) {"
    },
    {
        "line": 72,
        "fullcodeline": "style = 392;  // UPX 3.92"
    },
    {
        "line": 74,
        "fullcodeline": "if (!strcmp(\"__LINKEDIT\", segptr->segname)) {"
    },
    {
        "line": 75,
        "fullcodeline": "offLINK = segptr->fileoff;"
    },
    {
        "line": 84,
        "fullcodeline": "if ((headway -= ptr->cmdsize) < 0) {"
    },
    {
        "line": 85,
        "fullcodeline": "infoWarning(\"Mach_command[%u]{@%lu}.cmdsize = %u\", j,"
    },
    {
        "line": 91,
        "fullcodeline": "else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (MH_DYLIB == my_filetype) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (0xe8==b[0] && disp < bufsize"
    },
    {
        "line": 142,
        "fullcodeline": "&&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {"
    },
    {
        "line": 143,
        "fullcodeline": "unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];"
    },
    {
        "line": 164,
        "fullcodeline": "if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {"
    },
    {
        "line": 181,
        "fullcodeline": "&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {"
    },
    {
        "line": 182,
        "fullcodeline": "unsigned const method = b_ptr->b_method;"
    },
    {
        "line": 188,
        "fullcodeline": "unsigned const magic = get_te32(1+ (char const *)uptr);"
    },
    {
        "line": 238,
        "fullcodeline": "&&  (unsigned)file_size < get_te32(&p[1])  // compression was worthwhile"
    },
    {
        "line": 45,
        "fullcodeline": "j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,"
    },
    {
        "line": 52,
        "fullcodeline": "||  (unsigned long)file_size < segptr->fileoff"
    },
    {
        "line": 76,
        "fullcodeline": "if (segptr->filesize == blankLINK) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (offLINK < (off_t) pos_next) {"
    },
    {
        "line": 92,
        "fullcodeline": "rip = entryVMA = threadc_getPC(ptr);"
    },
    {
        "line": 112,
        "fullcodeline": "fi->seek(fi->st_size() - bufsize, SEEK_SET);"
    },
    {
        "line": 121,
        "fullcodeline": "if (395 == style) {"
    },
    {
        "line": 206,
        "fullcodeline": "overlay_offset  = *(TE32 const *)p;"
    },
    {
        "line": 237,
        "fullcodeline": "&&  p[2]==p[1]  // p_info.p_blocksize == p_info.p_filesize"
    },
    {
        "line": 242,
        "fullcodeline": "if (!(3&overlay_offset  // not word aligned"
    },
    {
        "line": 77,
        "fullcodeline": "style = 395;"
    },
    {
        "line": 80,
        "fullcodeline": "offLINK = pos_next;"
    },
    {
        "line": 86,
        "fullcodeline": "(unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),"
    },
    {
        "line": 118,
        "fullcodeline": "fi->seek(offLINK, SEEK_SET);"
    },
    {
        "line": 122,
        "fullcodeline": "fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);"
    },
    {
        "line": 144,
        "fullcodeline": "if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {"
    },
    {
        "line": 145,
        "fullcodeline": "struct b_info const *bptr = (struct b_info const *)&b[11+disp];"
    },
    {
        "line": 183,
        "fullcodeline": "if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)"
    },
    {
        "line": 185,
        "fullcodeline": "&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {"
    },
    {
        "line": 189,
        "fullcodeline": "if ((M_NRV2B_8 == method || M_NRV2E_8 == method)"
    },
    {
        "line": 191,
        "fullcodeline": "&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {"
    },
    {
        "line": 207,
        "fullcodeline": "if ((off_t)overlay_offset < offLINK) {"
    },
    {
        "line": 236,
        "fullcodeline": "&&     0!=p[1]  // p_info.p_filesize"
    },
    {
        "line": 244,
        "fullcodeline": "|| (off_t)overlay_offset >= file_size)) {"
    },
    {
        "line": 56,
        "fullcodeline": "j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,"
    },
    {
        "line": 184,
        "fullcodeline": "&&  (0xff>>2)==(uptr[0] >> (2+ 24))  // 1st 6 bytes are unique literals"
    },
    {
        "line": 190,
        "fullcodeline": "&& 0xfc==(0xfc & uptr[0])"
    },
    {
        "line": 208,
        "fullcodeline": "overlay_offset = ((char const *)p - (char const *)lo) +"
    },
    {
        "line": 210,
        "fullcodeline": "fi->seek(overlay_offset, SEEK_SET);"
    },
    {
        "line": 211,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 243,
        "fullcodeline": "||        overlay_offset < sz_mach_headers"
    },
    {
        "line": 115,
        "fullcodeline": "if ((off_t)bufsize > (fi->st_size() - offLINK)) {"
    },
    {
        "line": 116,
        "fullcodeline": "bufsize = fi->st_size() - offLINK;"
    },
    {
        "line": 148,
        "fullcodeline": "if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {"
    },
    {
        "line": 149,
        "fullcodeline": "b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);"
    },
    {
        "line": 151,
        "fullcodeline": "overlay_offset = *(TE32 const *)(32 + b);"
    },
    {
        "line": 152,
        "fullcodeline": "if (overlay_offset < 0x1000) {"
    },
    {
        "line": 209,
        "fullcodeline": "(offLINK - 0x1000) - overlay_offset + sizeof(l_info);"
    },
    {
        "line": 212,
        "fullcodeline": "if (b_ptr->sz_unc < 0x4000"
    },
    {
        "line": 213,
        "fullcodeline": "&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {"
    }
]