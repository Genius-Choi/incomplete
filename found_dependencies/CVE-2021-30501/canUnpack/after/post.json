[
    {
        "line": 4,
        "fullcodeline": "fi->seek(0, SEEK_SET);"
    },
    {
        "line": 5,
        "fullcodeline": "fi->readx(&mhdri, sizeof(mhdri));"
    },
    {
        "line": 26,
        "fullcodeline": "sz_mach_headers = headway + sizeof(mhdri);"
    },
    {
        "line": 33,
        "fullcodeline": "rawmseg_buf.alloc(mhdri.sizeofcmds);"
    },
    {
        "line": 34,
        "fullcodeline": "rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();"
    },
    {
        "line": 35,
        "fullcodeline": "fi->readx(rawmseg, mhdri.sizeofcmds);"
    },
    {
        "line": 37,
        "fullcodeline": "Mach_segment_command const *ptrTEXT = nullptr;"
    },
    {
        "line": 38,
        "fullcodeline": "upx_uint64_t rip = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "unsigned style = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "off_t offLINK = 0;"
    },
    {
        "line": 41,
        "fullcodeline": "unsigned pos_next = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "unsigned nseg = 0;"
    },
    {
        "line": 43,
        "fullcodeline": "Mach_command const *ptr = (Mach_command const *)rawmseg;"
    },
    {
        "line": 108,
        "fullcodeline": "int const small = 32 + sizeof(overlay_offset);"
    },
    {
        "line": 109,
        "fullcodeline": "unsigned bufsize = 4096;"
    },
    {
        "line": 127,
        "fullcodeline": "MemBuffer buf(bufsize);"
    },
    {
        "line": 129,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 130,
        "fullcodeline": "int i = bufsize;"
    },
    {
        "line": 132,
        "fullcodeline": "i -= small;"
    },
    {
        "line": 224,
        "fullcodeline": "overlay_offset = 0;  // impossible value"
    },
    {
        "line": 225,
        "fullcodeline": "int l = ph.buf_offset + ph.getPackHeaderSize();"
    },
    {
        "line": 7,
        "fullcodeline": "if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic"
    },
    {
        "line": 18,
        "fullcodeline": "if ((2 == ncmds"
    },
    {
        "line": 27,
        "fullcodeline": "if (2048 < headway) {"
    },
    {
        "line": 30,
        "fullcodeline": "if(!headway){"
    },
    {
        "line": 44,
        "fullcodeline": "for (unsigned j= 0; j < ncmds;"
    },
    {
        "line": 45,
        "fullcodeline": "ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (3==nseg && 395 != style) { // __PAGEZERO, __TEXT, __LINKEDIT;  no __XHDR, no UPX_DATA"
    },
    {
        "line": 101,
        "fullcodeline": "if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) { // pre-3.91 ?"
    },
    {
        "line": 104,
        "fullcodeline": "if (0 == style || 0 == offLINK) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (391 == style) { // PackHeader precedes __LINKEDIT"
    },
    {
        "line": 131,
        "fullcodeline": "while (i > small && 0 == buf[--i]) { }"
    },
    {
        "line": 134,
        "fullcodeline": "if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {"
    },
    {
        "line": 229,
        "fullcodeline": "if (       overlay_offset < sz_mach_headers"
    },
    {
        "line": 3,
        "fullcodeline": "unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];"
    },
    {
        "line": 9,
        "fullcodeline": "||  my_filetype  !=mhdri.filetype"
    },
    {
        "line": 20,
        "fullcodeline": "||  (3 <= ncmds"
    },
    {
        "line": 23,
        "fullcodeline": "infoWarning(\"Mach_header.sizeofcmds = %d too small\", headway);"
    },
    {
        "line": 24,
        "fullcodeline": "throwCantUnpack(\"file corrupted\");"
    },
    {
        "line": 28,
        "fullcodeline": "infoWarning(\"Mach_header.sizeofcmds(%d) > 2048\", headway);"
    },
    {
        "line": 31,
        "fullcodeline": "throwCantPack(\"Mach_header.sizeofcmds == 0\");"
    },
    {
        "line": 99,
        "fullcodeline": "style = 392;"
    },
    {
        "line": 102,
        "fullcodeline": "offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;  // fake __LINKEDIT at EOF"
    },
    {
        "line": 111,
        "fullcodeline": "fi->seek(offLINK - bufsize, SEEK_SET);"
    },
    {
        "line": 137,
        "fullcodeline": "upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;"
    },
    {
        "line": 227,
        "fullcodeline": "overlay_offset = get_te32(buf + i + l);"
    },
    {
        "line": 230,
        "fullcodeline": "||  (off_t)overlay_offset >= file_size) {"
    },
    {
        "line": 231,
        "fullcodeline": "infoWarning(\"file corrupted\");"
    },
    {
        "line": 232,
        "fullcodeline": "MemBuffer buf2(umin(1<<14, file_size));"
    },
    {
        "line": 233,
        "fullcodeline": "fi->seek(sz_mach_headers, SEEK_SET);"
    },
    {
        "line": 234,
        "fullcodeline": "fi->readx(buf2, buf2.getSize());"
    },
    {
        "line": 235,
        "fullcodeline": "unsigned const *p = (unsigned const *)&buf2[0];"
    },
    {
        "line": 236,
        "fullcodeline": "unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];"
    },
    {
        "line": 252,
        "fullcodeline": "throwCantUnpack(\"file corrupted\");"
    },
    {
        "line": 8,
        "fullcodeline": "||  my_cputype   !=mhdri.cputype"
    },
    {
        "line": 19,
        "fullcodeline": "&& headway < (int)(sizeof(Mach_segment_command) + 4*4))"
    },
    {
        "line": 21,
        "fullcodeline": "&& headway < (int)(3 * sizeof(Mach_segment_command)"
    },
    {
        "line": 46,
        "fullcodeline": "if ((unsigned)headway < ptr->cmdsize) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (lc_seg == ptr->cmd) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {"
    },
    {
        "line": 163,
        "fullcodeline": "if (391==style) {"
    },
    {
        "line": 173,
        "fullcodeline": "if (392==style) {"
    },
    {
        "line": 237,
        "fullcodeline": "for (; p <= e_buf2; ++p)"
    },
    {
        "line": 47,
        "fullcodeline": "infoWarning(\"bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\","
    },
    {
        "line": 50,
        "fullcodeline": "throwCantUnpack(\"file corrupted\");"
    },
    {
        "line": 53,
        "fullcodeline": "Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;"
    },
    {
        "line": 64,
        "fullcodeline": "++nseg;"
    },
    {
        "line": 86,
        "fullcodeline": "pos_next = segptr->filesize + segptr->fileoff;"
    },
    {
        "line": 113,
        "fullcodeline": "if (392 == style) {"
    },
    {
        "line": 139,
        "fullcodeline": "fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);"
    },
    {
        "line": 140,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 141,
        "fullcodeline": "unsigned char const *b = &buf[0];"
    },
    {
        "line": 164,
        "fullcodeline": "TE32 const *uptr = (TE32 const *)&buf[bufsize];"
    },
    {
        "line": 170,
        "fullcodeline": "overlay_offset = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "overlay_offset = 0x100c;  // (l_info precedes;) p_info; b_info; cpr_data"
    },
    {
        "line": 178,
        "fullcodeline": "fi->seek(overlay_offset, SEEK_SET);"
    },
    {
        "line": 179,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 180,
        "fullcodeline": "struct p_info const *const p_ptr = (struct p_info const *)&buf[0];"
    },
    {
        "line": 181,
        "fullcodeline": "struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);"
    },
    {
        "line": 182,
        "fullcodeline": "TE32 const *uptr = (TE32 const *)(1+ b_ptr);"
    },
    {
        "line": 200,
        "fullcodeline": "overlay_offset = 0;"
    },
    {
        "line": 204,
        "fullcodeline": "fi->seek(offLINK - 0x1000, SEEK_SET);"
    },
    {
        "line": 205,
        "fullcodeline": "fi->readx(buf, 0x1000);"
    },
    {
        "line": 206,
        "fullcodeline": "unsigned const *const lo = (unsigned const *)&buf[0];"
    },
    {
        "line": 238,
        "fullcodeline": "if (   0==p[0]  // p_info.p_progid"
    },
    {
        "line": 48,
        "fullcodeline": "j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,"
    },
    {
        "line": 49,
        "fullcodeline": "(unsigned long) file_size, (unsigned long)ptr->cmdsize);"
    },
    {
        "line": 54,
        "fullcodeline": "if ((unsigned long)file_size < segptr->filesize"
    },
    {
        "line": 65,
        "fullcodeline": "if (!strcmp(\"__XHDR\", segptr->segname)) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (!strcmp(\"__TEXT\", segptr->segname)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (!strcmp(\"UPX_DATA\", segptr->segname)) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (!strcmp(\"__LINKEDIT\", segptr->segname)) {"
    },
    {
        "line": 87,
        "fullcodeline": "if ((headway -= ptr->cmdsize) < 0) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (0xe8==b[0] && disp < bufsize"
    },
    {
        "line": 165,
        "fullcodeline": "while (0==*--uptr) /*empty*/ ;"
    },
    {
        "line": 167,
        "fullcodeline": "if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {"
    },
    {
        "line": 183,
        "fullcodeline": "if (b_ptr->sz_unc < 0x4000"
    },
    {
        "line": 208,
        "fullcodeline": "for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {"
    },
    {
        "line": 242,
        "fullcodeline": "&&  sz_mach_headers==get_te32(&p[3])  // b_info.sz_unc"
    },
    {
        "line": 244,
        "fullcodeline": "overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;"
    },
    {
        "line": 56,
        "fullcodeline": "||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {"
    },
    {
        "line": 57,
        "fullcodeline": "infoWarning(\"bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\""
    },
    {
        "line": 62,
        "fullcodeline": "throwCantUnpack(\"file corrupted\");"
    },
    {
        "line": 67,
        "fullcodeline": "style = 391;  // UPX 3.91"
    },
    {
        "line": 70,
        "fullcodeline": "ptrTEXT = segptr;"
    },
    {
        "line": 71,
        "fullcodeline": "style = 391;  // UPX 3.91"
    },
    {
        "line": 75,
        "fullcodeline": "style = 392;  // UPX 3.92"
    },
    {
        "line": 78,
        "fullcodeline": "offLINK = segptr->fileoff;"
    },
    {
        "line": 88,
        "fullcodeline": "infoWarning(\"Mach_command[%u]{@%lu}.cmdsize = %u\", j,"
    },
    {
        "line": 91,
        "fullcodeline": "throwCantUnpack(\"sum(.cmdsize) exceeds .sizeofcmds\");"
    },
    {
        "line": 94,
        "fullcodeline": "else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (MH_DYLIB == my_filetype) {"
    },
    {
        "line": 142,
        "fullcodeline": "unsigned disp = *(TE32 const *)&b[1];"
    },
    {
        "line": 145,
        "fullcodeline": "&&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {"
    },
    {
        "line": 146,
        "fullcodeline": "unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];"
    },
    {
        "line": 184,
        "fullcodeline": "&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {"
    },
    {
        "line": 185,
        "fullcodeline": "unsigned const method = b_ptr->b_method;"
    },
    {
        "line": 191,
        "fullcodeline": "unsigned const magic = get_te32(1+ (char const *)uptr);"
    },
    {
        "line": 241,
        "fullcodeline": "&&  (unsigned)file_size < get_te32(&p[1])  // compression was worthwhile"
    },
    {
        "line": 245,
        "fullcodeline": "if (!(3&overlay_offset  // not word aligned"
    },
    {
        "line": 55,
        "fullcodeline": "||  (unsigned long)file_size < segptr->fileoff"
    },
    {
        "line": 59,
        "fullcodeline": "j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,"
    },
    {
        "line": 60,
        "fullcodeline": "(unsigned long) file_size, (unsigned long)ptr->cmdsize,"
    },
    {
        "line": 61,
        "fullcodeline": "(unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);"
    },
    {
        "line": 79,
        "fullcodeline": "if (segptr->filesize == blankLINK) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (offLINK < (off_t) pos_next) {"
    },
    {
        "line": 89,
        "fullcodeline": "(unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),"
    },
    {
        "line": 90,
        "fullcodeline": "(unsigned)ptr->cmdsize);"
    },
    {
        "line": 95,
        "fullcodeline": "rip = entryVMA = threadc_getPC(ptr);"
    },
    {
        "line": 115,
        "fullcodeline": "fi->seek(fi->st_size() - bufsize, SEEK_SET);"
    },
    {
        "line": 124,
        "fullcodeline": "if (395 == style) {"
    },
    {
        "line": 147,
        "fullcodeline": "if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {"
    },
    {
        "line": 186,
        "fullcodeline": "if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)"
    },
    {
        "line": 192,
        "fullcodeline": "if ((M_NRV2B_8 == method || M_NRV2E_8 == method)"
    },
    {
        "line": 240,
        "fullcodeline": "&&  p[2]==p[1]  // p_info.p_blocksize == p_info.p_filesize"
    },
    {
        "line": 248,
        "fullcodeline": "infoWarning(\"attempting recovery, overlay_offset = %#x\", overlay_offset);"
    },
    {
        "line": 80,
        "fullcodeline": "style = 395;"
    },
    {
        "line": 83,
        "fullcodeline": "offLINK = pos_next;"
    },
    {
        "line": 121,
        "fullcodeline": "fi->seek(offLINK, SEEK_SET);"
    },
    {
        "line": 125,
        "fullcodeline": "fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);"
    },
    {
        "line": 148,
        "fullcodeline": "struct b_info const *bptr = (struct b_info const *)&b[11+disp];"
    },
    {
        "line": 188,
        "fullcodeline": "&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {"
    },
    {
        "line": 194,
        "fullcodeline": "&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {"
    },
    {
        "line": 210,
        "fullcodeline": "if ((off_t)overlay_offset < offLINK) {"
    },
    {
        "line": 239,
        "fullcodeline": "&&     0!=p[1]  // p_info.p_filesize"
    },
    {
        "line": 247,
        "fullcodeline": "|| (off_t)overlay_offset >= file_size)) {"
    },
    {
        "line": 118,
        "fullcodeline": "if ((off_t)bufsize > (fi->st_size() - offLINK)) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {"
    },
    {
        "line": 187,
        "fullcodeline": "&&  (0xff>>2)==(uptr[0] >> (2+ 24))  // 1st 6 bytes are unique literals"
    },
    {
        "line": 193,
        "fullcodeline": "&& 0xfc==(0xfc & uptr[0])"
    },
    {
        "line": 209,
        "fullcodeline": "overlay_offset  = *(TE32 const *)p;"
    },
    {
        "line": 211,
        "fullcodeline": "overlay_offset = ((char const *)p - (char const *)lo) +"
    },
    {
        "line": 213,
        "fullcodeline": "fi->seek(overlay_offset, SEEK_SET);"
    },
    {
        "line": 214,
        "fullcodeline": "fi->readx(buf, bufsize);"
    },
    {
        "line": 246,
        "fullcodeline": "||        overlay_offset < sz_mach_headers"
    },
    {
        "line": 119,
        "fullcodeline": "bufsize = fi->st_size() - offLINK;"
    },
    {
        "line": 152,
        "fullcodeline": "b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);"
    },
    {
        "line": 158,
        "fullcodeline": "overlay_offset = 0;"
    },
    {
        "line": 215,
        "fullcodeline": "if (b_ptr->sz_unc < 0x4000"
    },
    {
        "line": 155,
        "fullcodeline": "if (overlay_offset < 0x1000) {"
    },
    {
        "line": 216,
        "fullcodeline": "&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {"
    },
    {
        "line": 154,
        "fullcodeline": "overlay_offset = *(TE32 const *)(32 + b);"
    },
    {
        "line": 212,
        "fullcodeline": "(offLINK - 0x1000) - overlay_offset + sizeof(l_info);"
    }
]