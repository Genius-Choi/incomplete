[
    {
        "line": 3,
        "fullcodeline": "struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);"
    },
    {
        "line": 4,
        "fullcodeline": "struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);"
    },
    {
        "line": 8,
        "fullcodeline": "sm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);"
    },
    {
        "line": 13,
        "fullcodeline": "sbi->sm_info = sm_info;"
    },
    {
        "line": 14,
        "fullcodeline": "sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);"
    },
    {
        "line": 15,
        "fullcodeline": "sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);"
    },
    {
        "line": 16,
        "fullcodeline": "sm_info->segment_count = le32_to_cpu(raw_super->segment_count);"
    },
    {
        "line": 17,
        "fullcodeline": "sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);"
    },
    {
        "line": 18,
        "fullcodeline": "sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);"
    },
    {
        "line": 19,
        "fullcodeline": "sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);"
    },
    {
        "line": 20,
        "fullcodeline": "sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);"
    },
    {
        "line": 21,
        "fullcodeline": "sm_info->rec_prefree_segments = sm_info->main_segments *"
    },
    {
        "line": 28,
        "fullcodeline": "sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;"
    },
    {
        "line": 29,
        "fullcodeline": "sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;"
    },
    {
        "line": 30,
        "fullcodeline": "sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;"
    },
    {
        "line": 32,
        "fullcodeline": "sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;"
    },
    {
        "line": 34,
        "fullcodeline": "INIT_LIST_HEAD(&sm_info->sit_entry_set);"
    },
    {
        "line": 42,
        "fullcodeline": "err = create_discard_cmd_control(sbi);"
    },
    {
        "line": 46,
        "fullcodeline": "err = build_sit_info(sbi);"
    },
    {
        "line": 49,
        "fullcodeline": "err = build_free_segmap(sbi);"
    },
    {
        "line": 52,
        "fullcodeline": "err = build_curseg(sbi);"
    },
    {
        "line": 57,
        "fullcodeline": "build_sit_entries(sbi);"
    },
    {
        "line": 59,
        "fullcodeline": "init_free_segmap(sbi);"
    },
    {
        "line": 60,
        "fullcodeline": "err = build_dirty_segmap(sbi);"
    },
    {
        "line": 64,
        "fullcodeline": "init_min_max_mtime(sbi);"
    },
    {
        "line": 9,
        "fullcodeline": "if (!sm_info)"
    },
    {
        "line": 23,
        "fullcodeline": "if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)"
    },
    {
        "line": 26,
        "fullcodeline": "if (!test_opt(sbi, LFS))"
    },
    {
        "line": 36,
        "fullcodeline": "if (!f2fs_readonly(sbi->sb)) {"
    },
    {
        "line": 24,
        "fullcodeline": "sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;"
    },
    {
        "line": 27,
        "fullcodeline": "sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;"
    },
    {
        "line": 37,
        "fullcodeline": "err = create_flush_cmd_control(sbi);"
    },
    {
        "line": 10,
        "fullcodeline": "return -ENOMEM;"
    }
]