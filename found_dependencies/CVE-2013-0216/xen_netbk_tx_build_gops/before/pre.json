[
    {
        "line": 3,
        "fullcodeline": "struct gnttab_copy *gop = netbk->tx_copy_ops, *request_gop;"
    },
    {
        "line": 7,
        "fullcodeline": "while (((nr_pending_reqs(netbk) + MAX_SKB_FRAGS) < MAX_PENDING_REQS) &&"
    },
    {
        "line": 170,
        "fullcodeline": "return gop - netbk->tx_copy_ops;"
    },
    {
        "line": 8,
        "fullcodeline": "!list_empty(&netbk->net_schedule_list)) {"
    },
    {
        "line": 11,
        "fullcodeline": "struct xen_netif_tx_request txfrags[MAX_SKB_FRAGS];"
    },
    {
        "line": 13,
        "fullcodeline": "struct xen_netif_extra_info extras[XEN_NETIF_EXTRA_TYPE_MAX-1];"
    },
    {
        "line": 21,
        "fullcodeline": "vif = poll_net_schedule_list(netbk);"
    },
    {
        "line": 25,
        "fullcodeline": "RING_FINAL_CHECK_FOR_REQUESTS(&vif->tx, work_to_do);"
    },
    {
        "line": 31,
        "fullcodeline": "idx = vif->tx.req_cons;"
    },
    {
        "line": 32,
        "fullcodeline": "rmb(); /* Ensure that we see the request before we copy it. */"
    },
    {
        "line": 33,
        "fullcodeline": "memcpy(&txreq, RING_GET_REQUEST(&vif->tx, idx), sizeof(txreq));"
    },
    {
        "line": 42,
        "fullcodeline": "vif->remaining_credit -= txreq.size;"
    },
    {
        "line": 44,
        "fullcodeline": "work_to_do--;"
    },
    {
        "line": 45,
        "fullcodeline": "vif->tx.req_cons = ++idx;"
    },
    {
        "line": 47,
        "fullcodeline": "memset(extras, 0, sizeof(extras));"
    },
    {
        "line": 58,
        "fullcodeline": "ret = netbk_count_requests(vif, &txreq, txfrags, work_to_do);"
    },
    {
        "line": 63,
        "fullcodeline": "idx += ret;"
    },
    {
        "line": 82,
        "fullcodeline": "index = pending_index(netbk->pending_cons);"
    },
    {
        "line": 83,
        "fullcodeline": "pending_idx = netbk->pending_ring[index];"
    },
    {
        "line": 85,
        "fullcodeline": "data_len = (txreq.size > PKT_PROT_LEN &&"
    },
    {
        "line": 89,
        "fullcodeline": "skb = alloc_skb(data_len + NET_SKB_PAD + NET_IP_ALIGN,"
    },
    {
        "line": 99,
        "fullcodeline": "skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);"
    },
    {
        "line": 113,
        "fullcodeline": "page = xen_netbk_alloc_page(netbk, skb, pending_idx);"
    },
    {
        "line": 120,
        "fullcodeline": "gop->source.u.ref = txreq.gref;"
    },
    {
        "line": 121,
        "fullcodeline": "gop->source.domid = vif->domid;"
    },
    {
        "line": 122,
        "fullcodeline": "gop->source.offset = txreq.offset;"
    },
    {
        "line": 124,
        "fullcodeline": "gop->dest.u.gmfn = virt_to_mfn(page_address(page));"
    },
    {
        "line": 125,
        "fullcodeline": "gop->dest.domid = DOMID_SELF;"
    },
    {
        "line": 126,
        "fullcodeline": "gop->dest.offset = txreq.offset;"
    },
    {
        "line": 128,
        "fullcodeline": "gop->len = txreq.size;"
    },
    {
        "line": 129,
        "fullcodeline": "gop->flags = GNTCOPY_source_gref;"
    },
    {
        "line": 131,
        "fullcodeline": "gop++;"
    },
    {
        "line": 133,
        "fullcodeline": "memcpy(&netbk->pending_tx_info[pending_idx].req,"
    },
    {
        "line": 135,
        "fullcodeline": "netbk->pending_tx_info[pending_idx].vif = vif;"
    },
    {
        "line": 136,
        "fullcodeline": "*((u16 *)skb->data) = pending_idx;"
    },
    {
        "line": 138,
        "fullcodeline": "__skb_put(skb, data_len);"
    },
    {
        "line": 140,
        "fullcodeline": "skb_shinfo(skb)->nr_frags = ret;"
    },
    {
        "line": 150,
        "fullcodeline": "netbk->pending_cons++;"
    },
    {
        "line": 152,
        "fullcodeline": "request_gop = xen_netbk_get_requests(netbk, vif,"
    },
    {
        "line": 159,
        "fullcodeline": "gop = request_gop;"
    },
    {
        "line": 161,
        "fullcodeline": "__skb_queue_tail(&netbk->tx_queue, skb);"
    },
    {
        "line": 163,
        "fullcodeline": "vif->tx.req_cons = idx;"
    },
    {
        "line": 164,
        "fullcodeline": "xen_netbk_check_rx_xenvif(vif);"
    },
    {
        "line": 22,
        "fullcodeline": "if (!vif)"
    },
    {
        "line": 26,
        "fullcodeline": "if (!work_to_do) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (txreq.size > vif->remaining_credit &&"
    },
    {
        "line": 48,
        "fullcodeline": "if (txreq.flags & XEN_NETTXF_extra_info) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (unlikely(ret < 0)) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (unlikely(txreq.size < ETH_HLEN)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (unlikely((txreq.offset + txreq.size) > PAGE_SIZE)) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (unlikely(skb == NULL)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (!page) {"
    },
    {
        "line": 134,
        "fullcodeline": "&txreq, sizeof(txreq));"
    },
    {
        "line": 141,
        "fullcodeline": "if (data_len < txreq.size) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (request_gop == NULL) {"
    },
    {
        "line": 166,
        "fullcodeline": "if ((gop-netbk->tx_copy_ops) >= ARRAY_SIZE(netbk->tx_copy_ops))"
    },
    {
        "line": 27,
        "fullcodeline": "xenvif_put(vif);"
    },
    {
        "line": 37,
        "fullcodeline": "tx_credit_exceeded(vif, txreq.size)) {"
    },
    {
        "line": 38,
        "fullcodeline": "xenvif_put(vif);"
    },
    {
        "line": 49,
        "fullcodeline": "work_to_do = xen_netbk_get_extras(vif, extras,"
    },
    {
        "line": 51,
        "fullcodeline": "idx = vif->tx.req_cons;"
    },
    {
        "line": 60,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx - ret);"
    },
    {
        "line": 66,
        "fullcodeline": "netdev_dbg(vif->dev,"
    },
    {
        "line": 68,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    },
    {
        "line": 74,
        "fullcodeline": "netdev_dbg(vif->dev,"
    },
    {
        "line": 78,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    },
    {
        "line": 90,
        "fullcodeline": "GFP_ATOMIC | __GFP_NOWARN);"
    },
    {
        "line": 92,
        "fullcodeline": "netdev_dbg(vif->dev,"
    },
    {
        "line": 94,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    },
    {
        "line": 103,
        "fullcodeline": "gso = &extras[XEN_NETIF_EXTRA_TYPE_GSO - 1];"
    },
    {
        "line": 115,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 116,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    },
    {
        "line": 142,
        "fullcodeline": "skb_shinfo(skb)->nr_frags++;"
    },
    {
        "line": 143,
        "fullcodeline": "frag_set_pending_idx(&skb_shinfo(skb)->frags[0],"
    },
    {
        "line": 155,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 156,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    },
    {
        "line": 52,
        "fullcodeline": "if (unlikely(work_to_do < 0)) {"
    },
    {
        "line": 77,
        "fullcodeline": "(txreq.offset&~PAGE_MASK) + txreq.size);"
    },
    {
        "line": 86,
        "fullcodeline": "ret < MAX_SKB_FRAGS) ?"
    },
    {
        "line": 101,
        "fullcodeline": "if (extras[XEN_NETIF_EXTRA_TYPE_GSO - 1].type) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (netbk_set_skb_gso(vif, skb, gso)) {"
    },
    {
        "line": 146,
        "fullcodeline": "frag_set_pending_idx(&skb_shinfo(skb)->frags[0],"
    },
    {
        "line": 53,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    },
    {
        "line": 106,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 107,
        "fullcodeline": "netbk_tx_err(vif, &txreq, idx);"
    }
]