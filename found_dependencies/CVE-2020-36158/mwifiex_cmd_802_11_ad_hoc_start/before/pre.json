[
    {
        "line": 5,
        "fullcodeline": "int rsn_ie_len = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "struct mwifiex_adapter *adapter = priv->adapter;"
    },
    {
        "line": 7,
        "fullcodeline": "struct host_cmd_ds_802_11_ad_hoc_start *adhoc_start ="
    },
    {
        "line": 10,
        "fullcodeline": "u32 cmd_append_size = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "u8 *pos = (u8 *) adhoc_start +"
    },
    {
        "line": 26,
        "fullcodeline": "bss_desc = &priv->curr_bss_params.bss_descriptor;"
    },
    {
        "line": 27,
        "fullcodeline": "priv->attempted_bss_desc = bss_desc;"
    },
    {
        "line": 39,
        "fullcodeline": "memset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);"
    },
    {
        "line": 41,
        "fullcodeline": "memcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);"
    },
    {
        "line": 43,
        "fullcodeline": "mwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\","
    },
    {
        "line": 46,
        "fullcodeline": "memset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);"
    },
    {
        "line": 47,
        "fullcodeline": "memcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);"
    },
    {
        "line": 52,
        "fullcodeline": "adhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;"
    },
    {
        "line": 53,
        "fullcodeline": "bss_desc->bss_mode = NL80211_IFTYPE_ADHOC;"
    },
    {
        "line": 81,
        "fullcodeline": "mwifiex_dbg(adapter, INFO,"
    },
    {
        "line": 110,
        "fullcodeline": "tmp_cap = WLAN_CAPABILITY_IBSS;"
    },
    {
        "line": 126,
        "fullcodeline": "memset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));"
    },
    {
        "line": 127,
        "fullcodeline": "mwifiex_get_active_data_rates(priv, adhoc_start->data_rate);"
    },
    {
        "line": 143,
        "fullcodeline": "priv->curr_bss_params.num_of_rates = i;"
    },
    {
        "line": 146,
        "fullcodeline": "memcpy(&priv->curr_bss_params.data_rates,"
    },
    {
        "line": 149,
        "fullcodeline": "mwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\","
    },
    {
        "line": 152,
        "fullcodeline": "mwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");"
    },
    {
        "line": 192,
        "fullcodeline": "cmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,"
    },
    {
        "line": 21,
        "fullcodeline": "if (!adapter)"
    },
    {
        "line": 24,
        "fullcodeline": "cmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);"
    },
    {
        "line": 54,
        "fullcodeline": "adhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);"
    },
    {
        "line": 75,
        "fullcodeline": "if (!priv->adhoc_channel) {"
    },
    {
        "line": 93,
        "fullcodeline": "sizeof(union ieee_types_phy_param_set));"
    },
    {
        "line": 104,
        "fullcodeline": "= cpu_to_le16(priv->atim_window);"
    },
    {
        "line": 106,
        "fullcodeline": "sizeof(union ieee_types_ss_param_set));"
    },
    {
        "line": 139,
        "fullcodeline": "for (i = 0; i < sizeof(adhoc_start->data_rate); i++)"
    },
    {
        "line": 154,
        "fullcodeline": "if (IS_SUPPORT_MULTI_BANDS(adapter)) {"
    },
    {
        "line": 249,
        "fullcodeline": "cpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)"
    },
    {
        "line": 252,
        "fullcodeline": "if (adapter->adhoc_start_band == BAND_B)"
    },
    {
        "line": 257,
        "fullcodeline": "adhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);"
    },
    {
        "line": 19,
        "fullcodeline": "sizeof(struct host_cmd_ds_802_11_ad_hoc_start);"
    },
    {
        "line": 66,
        "fullcodeline": "if (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,"
    },
    {
        "line": 69,
        "fullcodeline": "cfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,"
    },
    {
        "line": 115,
        "fullcodeline": "mwifiex_dbg(adapter, INFO,"
    },
    {
        "line": 117,
        "fullcodeline": "bss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;"
    },
    {
        "line": 118,
        "fullcodeline": "tmp_cap |= WLAN_CAPABILITY_PRIVACY;"
    },
    {
        "line": 128,
        "fullcodeline": "if ((adapter->adhoc_start_band & BAND_G) &&"
    },
    {
        "line": 129,
        "fullcodeline": "(priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {"
    },
    {
        "line": 140,
        "fullcodeline": "if (!adhoc_start->data_rate[i])"
    },
    {
        "line": 156,
        "fullcodeline": "chan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;"
    },
    {
        "line": 163,
        "fullcodeline": "chan_tlv->chan_scan_param[0].chan_number ="
    },
    {
        "line": 166,
        "fullcodeline": "mwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\","
    },
    {
        "line": 169,
        "fullcodeline": "chan_tlv->chan_scan_param[0].radio_type"
    },
    {
        "line": 182,
        "fullcodeline": "mwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\","
    },
    {
        "line": 184,
        "fullcodeline": "pos += sizeof(chan_tlv->header) +"
    },
    {
        "line": 186,
        "fullcodeline": "cmd_append_size +="
    },
    {
        "line": 196,
        "fullcodeline": "rsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);"
    },
    {
        "line": 199,
        "fullcodeline": "cmd_append_size += rsn_ie_len;"
    },
    {
        "line": 204,
        "fullcodeline": "ht_cap = (struct mwifiex_ie_types_htcap *) pos;"
    },
    {
        "line": 205,
        "fullcodeline": "memset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));"
    },
    {
        "line": 209,
        "fullcodeline": "radio_type = mwifiex_band_to_radio_type("
    },
    {
        "line": 223,
        "fullcodeline": "pos += sizeof(struct mwifiex_ie_types_htcap);"
    },
    {
        "line": 224,
        "fullcodeline": "cmd_append_size += sizeof(struct mwifiex_ie_types_htcap);"
    },
    {
        "line": 227,
        "fullcodeline": "ht_info = (struct mwifiex_ie_types_htinfo *) pos;"
    },
    {
        "line": 244,
        "fullcodeline": "cmd_append_size +="
    },
    {
        "line": 253,
        "fullcodeline": "tmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;"
    },
    {
        "line": 22,
        "fullcodeline": "return -1;"
    },
    {
        "line": 78,
        "fullcodeline": "return -1;"
    },
    {
        "line": 120,
        "fullcodeline": "mwifiex_dbg(adapter, INFO,"
    },
    {
        "line": 123,
        "fullcodeline": "bss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;"
    },
    {
        "line": 130,
        "fullcodeline": "if (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,"
    },
    {
        "line": 157,
        "fullcodeline": "chan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);"
    },
    {
        "line": 170,
        "fullcodeline": "= mwifiex_band_to_radio_type(priv->curr_bss_params.band);"
    },
    {
        "line": 197,
        "fullcodeline": "if (rsn_ie_len == -1)"
    },
    {
        "line": 206,
        "fullcodeline": "ht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);"
    },
    {
        "line": 213,
        "fullcodeline": "if (adapter->sec_chan_offset =="
    },
    {
        "line": 229,
        "fullcodeline": "ht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);"
    },
    {
        "line": 241,
        "fullcodeline": "cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);"
    },
    {
        "line": 255,
        "fullcodeline": "tmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;"
    },
    {
        "line": 72,
        "fullcodeline": "priv->adhoc_channel = (u8) cfp->channel;"
    },
    {
        "line": 171,
        "fullcodeline": "if (adapter->adhoc_start_band & BAND_GN ||"
    },
    {
        "line": 172,
        "fullcodeline": "adapter->adhoc_start_band & BAND_AN) {"
    },
    {
        "line": 208,
        "fullcodeline": "cpu_to_le16(sizeof(struct ieee80211_ht_cap));"
    },
    {
        "line": 217,
        "fullcodeline": "tmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);"
    },
    {
        "line": 218,
        "fullcodeline": "tmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;"
    },
    {
        "line": 219,
        "fullcodeline": "tmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;"
    },
    {
        "line": 231,
        "fullcodeline": "cpu_to_le16(sizeof(struct ieee80211_ht_operation));"
    },
    {
        "line": 236,
        "fullcodeline": "ht_info->ht_oper.ht_param = adapter->sec_chan_offset;"
    },
    {
        "line": 237,
        "fullcodeline": "ht_info->ht_oper.ht_param |="
    },
    {
        "line": 135,
        "fullcodeline": "return -1;"
    },
    {
        "line": 173,
        "fullcodeline": "if (adapter->sec_chan_offset =="
    },
    {
        "line": 198,
        "fullcodeline": "return -1;"
    },
    {
        "line": 220,
        "fullcodeline": "ht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);"
    },
    {
        "line": 175,
        "fullcodeline": "chan_tlv->chan_scan_param[0].radio_type |="
    },
    {
        "line": 176,
        "fullcodeline": "(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);"
    },
    {
        "line": 177,
        "fullcodeline": "else if (adapter->sec_chan_offset =="
    },
    {
        "line": 179,
        "fullcodeline": "chan_tlv->chan_scan_param[0].radio_type |="
    },
    {
        "line": 180,
        "fullcodeline": "(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);"
    }
]