[
    {
        "line": 3,
        "fullcodeline": "struct PopData *pop_data = (struct PopData *) ctx->data;"
    },
    {
        "line": 10,
        "fullcodeline": "time(&pop_data->check_time);"
    },
    {
        "line": 11,
        "fullcodeline": "pop_data->clear_cache = false;"
    },
    {
        "line": 16,
        "fullcodeline": "const int old_count = ctx->msgcount;"
    },
    {
        "line": 17,
        "fullcodeline": "int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);"
    },
    {
        "line": 18,
        "fullcodeline": "const int new_count = ctx->msgcount;"
    },
    {
        "line": 19,
        "fullcodeline": "ctx->msgcount = old_count;"
    },
    {
        "line": 13,
        "fullcodeline": "for (int i = 0; i < ctx->msgcount; i++)"
    },
    {
        "line": 14,
        "fullcodeline": "ctx->hdrs[i]->refno = -1;"
    },
    {
        "line": 21,
        "fullcodeline": "if (pop_data->cmd_uidl == 2)"
    },
    {
        "line": 40,
        "fullcodeline": "if (!ctx->quiet)"
    },
    {
        "line": 46,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 148,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 163,
        "fullcodeline": "return (new_count - old_count);"
    },
    {
        "line": 42,
        "fullcodeline": "mutt_progress_init(&progress, _(\"Fetching message headers...\"),"
    },
    {
        "line": 65,
        "fullcodeline": "bool hcached = false;"
    },
    {
        "line": 160,
        "fullcodeline": "mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);"
    },
    {
        "line": 23,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 30,
        "fullcodeline": "if (ret == -2 && pop_data->cmd_uidl == 2)"
    },
    {
        "line": 43,
        "fullcodeline": "MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);"
    },
    {
        "line": 49,
        "fullcodeline": "for (i = 0, deleted = 0; i < old_count; i++)"
    },
    {
        "line": 57,
        "fullcodeline": "if (deleted > 0)"
    },
    {
        "line": 66,
        "fullcodeline": "for (i = old_count; i < new_count; i++)"
    },
    {
        "line": 140,
        "fullcodeline": "if (i > old_count)"
    },
    {
        "line": 150,
        "fullcodeline": "for (int i = ctx->msgcount; i < new_count; i++)"
    },
    {
        "line": 151,
        "fullcodeline": "mutt_header_free(&ctx->hdrs[i]);"
    },
    {
        "line": 25,
        "fullcodeline": "pop_data->cmd_uidl = 1;"
    },
    {
        "line": 27,
        "fullcodeline": "mutt_debug(1, \"set UIDL capability\\n\");"
    },
    {
        "line": 32,
        "fullcodeline": "pop_data->cmd_uidl = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "mutt_debug(1, \"unset UIDL capability\\n\");"
    },
    {
        "line": 35,
        "fullcodeline": "snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\","
    },
    {
        "line": 59,
        "fullcodeline": "mutt_error("
    },
    {
        "line": 120,
        "fullcodeline": "const bool bcached ="
    },
    {
        "line": 122,
        "fullcodeline": "ctx->hdrs[i]->old = false;"
    },
    {
        "line": 123,
        "fullcodeline": "ctx->hdrs[i]->read = false;"
    },
    {
        "line": 137,
        "fullcodeline": "ctx->msgcount++;"
    },
    {
        "line": 141,
        "fullcodeline": "mx_update_context(ctx, i - old_count);"
    },
    {
        "line": 36,
        "fullcodeline": "_(\"Command UIDL is not supported by server.\"));"
    },
    {
        "line": 51,
        "fullcodeline": "if (ctx->hdrs[i]->refno == -1)"
    },
    {
        "line": 60,
        "fullcodeline": "ngettext(\"%d message has been lost. Try reopening the mailbox.\","
    },
    {
        "line": 68,
        "fullcodeline": "if (!ctx->quiet)"
    },
    {
        "line": 98,
        "fullcodeline": "if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)"
    },
    {
        "line": 121,
        "fullcodeline": "(mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);"
    },
    {
        "line": 53,
        "fullcodeline": "ctx->hdrs[i]->deleted = true;"
    },
    {
        "line": 54,
        "fullcodeline": "deleted++;"
    },
    {
        "line": 69,
        "fullcodeline": "mutt_progress_update(&progress, i + 1 - old_count, -1);"
    },
    {
        "line": 127,
        "fullcodeline": "ctx->hdrs[i]->read = true;"
    },
    {
        "line": 134,
        "fullcodeline": "ctx->hdrs[i]->read = true;"
    },
    {
        "line": 129,
        "fullcodeline": "ctx->hdrs[i]->old = true;"
    }
]