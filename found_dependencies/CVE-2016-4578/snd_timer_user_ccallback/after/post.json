[
    {
        "line": 6,
        "fullcodeline": "struct snd_timer_user *tu = timeri->callback_data;"
    },
    {
        "line": 15,
        "fullcodeline": "memset(&r1, 0, sizeof(r1));"
    },
    {
        "line": 16,
        "fullcodeline": "r1.event = event;"
    },
    {
        "line": 18,
        "fullcodeline": "r1.val = resolution;"
    },
    {
        "line": 19,
        "fullcodeline": "spin_lock_irqsave(&tu->qlock, flags);"
    },
    {
        "line": 20,
        "fullcodeline": "snd_timer_user_append_to_tqueue(tu, &r1);"
    },
    {
        "line": 21,
        "fullcodeline": "spin_unlock_irqrestore(&tu->qlock, flags);"
    },
    {
        "line": 22,
        "fullcodeline": "kill_fasync(&tu->fasync, SIGIO, POLL_IN);"
    },
    {
        "line": 23,
        "fullcodeline": "wake_up(&tu->qchange_sleep);"
    },
    {
        "line": 10,
        "fullcodeline": "if (event >= SNDRV_TIMER_EVENT_START &&"
    },
    {
        "line": 13,
        "fullcodeline": "if ((tu->filter & (1 << event)) == 0 || !tu->tread)"
    },
    {
        "line": 11,
        "fullcodeline": "event <= SNDRV_TIMER_EVENT_PAUSE)"
    }
]