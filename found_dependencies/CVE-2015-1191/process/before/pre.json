[
    {
        "line": 3,
        "fullcodeline": "int method = -1;                /* get_header() return value */"
    },
    {
        "line": 7,
        "fullcodeline": "static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\","
    },
    {
        "line": 163,
        "fullcodeline": "SET_BINARY_MODE(g.ind);"
    },
    {
        "line": 166,
        "fullcodeline": "g.hname = NULL;"
    },
    {
        "line": 276,
        "fullcodeline": "SET_BINARY_MODE(g.outd);"
    },
    {
        "line": 11,
        "fullcodeline": "if (path == NULL) {"
    },
    {
        "line": 280,
        "fullcodeline": "if (g.verbosity > 1)"
    },
    {
        "line": 302,
        "fullcodeline": "if (g.ind != 0)"
    },
    {
        "line": 304,
        "fullcodeline": "if (g.outd != 1) {"
    },
    {
        "line": 12,
        "fullcodeline": "strcpy(g.inf, \"<stdin>\");"
    },
    {
        "line": 13,
        "fullcodeline": "g.ind = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 169,
        "fullcodeline": "method = get_header(1);"
    },
    {
        "line": 212,
        "fullcodeline": "if (path == NULL || g.pipeout) {"
    },
    {
        "line": 214,
        "fullcodeline": "g.outf = MALLOC(strlen(\"<stdout>\") + 1);"
    },
    {
        "line": 217,
        "fullcodeline": "strcpy(g.outf, \"<stdout>\");"
    },
    {
        "line": 218,
        "fullcodeline": "g.outd = 1;"
    },
    {
        "line": 281,
        "fullcodeline": "fprintf(stderr, \"%s to %s \", g.inf, g.outf);"
    },
    {
        "line": 297,
        "fullcodeline": "putc('\\n', stderr);"
    },
    {
        "line": 303,
        "fullcodeline": "close(g.ind);"
    },
    {
        "line": 26,
        "fullcodeline": "len = strlen(g.inf);"
    },
    {
        "line": 155,
        "fullcodeline": "g.ind = open(g.inf, O_RDONLY, 0);"
    },
    {
        "line": 185,
        "fullcodeline": "if (g.decode == 2) {"
    },
    {
        "line": 206,
        "fullcodeline": "if (g.ind != 0)"
    },
    {
        "line": 215,
        "fullcodeline": "if (g.outf == NULL)"
    },
    {
        "line": 227,
        "fullcodeline": "to = g.inf;"
    },
    {
        "line": 234,
        "fullcodeline": "repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";"
    },
    {
        "line": 237,
        "fullcodeline": "g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);"
    },
    {
        "line": 240,
        "fullcodeline": "memcpy(g.outf, to, len);"
    },
    {
        "line": 242,
        "fullcodeline": "g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |"
    },
    {
        "line": 283,
        "fullcodeline": "if (method == 8)"
    },
    {
        "line": 307,
        "fullcodeline": "g.outd = -1;            /* now prevent deletion on interrupt */"
    },
    {
        "line": 313,
        "fullcodeline": "if (g.decode && (g.headis & 2) != 0 && g.stamp)"
    },
    {
        "line": 15,
        "fullcodeline": "g.mtime = g.headis & 2 ?"
    },
    {
        "line": 21,
        "fullcodeline": "if (path != g.inf) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (lstat(g.inf, &st)) {"
    },
    {
        "line": 61,
        "fullcodeline": "if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (g.decode == 1 && !g.pipeout && !g.list) {"
    },
    {
        "line": 156,
        "fullcodeline": "if (g.ind < 0)"
    },
    {
        "line": 170,
        "fullcodeline": "if (method != 8 && method != 257 &&"
    },
    {
        "line": 172,
        "fullcodeline": "!(method == -2 && g.force && g.pipeout && g.decode != 2 &&"
    },
    {
        "line": 219,
        "fullcodeline": "if (!g.decode && !g.force && isatty(g.outd))"
    },
    {
        "line": 238,
        "fullcodeline": "if (g.outf == NULL)"
    },
    {
        "line": 246,
        "fullcodeline": "if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {"
    },
    {
        "line": 273,
        "fullcodeline": "if (g.outd < 0)"
    },
    {
        "line": 306,
        "fullcodeline": "bail(\"write error on \", g.outf);"
    },
    {
        "line": 309,
        "fullcodeline": "copymeta(g.inf, g.outf);"
    },
    {
        "line": 314,
        "fullcodeline": "touch(g.outf, g.stamp);"
    },
    {
        "line": 16,
        "fullcodeline": "(fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;"
    },
    {
        "line": 22,
        "fullcodeline": "strncpy(g.inf, path, sizeof(g.inf));"
    },
    {
        "line": 50,
        "fullcodeline": "len = strlen(g.inf);"
    },
    {
        "line": 55,
        "fullcodeline": "if ((st.st_mode & S_IFMT) != S_IFREG &&"
    },
    {
        "line": 57,
        "fullcodeline": "(st.st_mode & S_IFMT) != S_IFDIR) {"
    },
    {
        "line": 65,
        "fullcodeline": "if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {"
    },
    {
        "line": 71,
        "fullcodeline": "if ((st.st_mode & S_IFMT) == S_IFDIR) {"
    },
    {
        "line": 79,
        "fullcodeline": "here = opendir(g.inf);"
    },
    {
        "line": 82,
        "fullcodeline": "hold = 512;"
    },
    {
        "line": 83,
        "fullcodeline": "roll = MALLOC(hold);"
    },
    {
        "line": 86,
        "fullcodeline": "*roll = 0;"
    },
    {
        "line": 87,
        "fullcodeline": "item = roll;"
    },
    {
        "line": 119,
        "fullcodeline": "item = roll;"
    },
    {
        "line": 137,
        "fullcodeline": "if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&"
    },
    {
        "line": 138,
        "fullcodeline": "strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {"
    },
    {
        "line": 145,
        "fullcodeline": "int suf = compressed_suffix(g.inf);"
    },
    {
        "line": 151,
        "fullcodeline": "len -= suf;"
    },
    {
        "line": 157,
        "fullcodeline": "bail(\"read error on \", g.inf);"
    },
    {
        "line": 160,
        "fullcodeline": "g.name = g.headis & 1 ? justname(g.inf) : NULL;"
    },
    {
        "line": 161,
        "fullcodeline": "g.mtime = g.headis & 2 ? st.st_mtime : 0;"
    },
    {
        "line": 175,
        "fullcodeline": "if (g.ind != 0)"
    },
    {
        "line": 177,
        "fullcodeline": "if (method != -1)"
    },
    {
        "line": 186,
        "fullcodeline": "if (method == 8)"
    },
    {
        "line": 196,
        "fullcodeline": "if (g.ind != 0)"
    },
    {
        "line": 228,
        "fullcodeline": "if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {"
    },
    {
        "line": 229,
        "fullcodeline": "to = g.hname;"
    },
    {
        "line": 230,
        "fullcodeline": "len = strlen(g.hname);"
    },
    {
        "line": 249,
        "fullcodeline": "fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);"
    },
    {
        "line": 250,
        "fullcodeline": "fflush(stderr);"
    },
    {
        "line": 251,
        "fullcodeline": "reply = -1;"
    },
    {
        "line": 263,
        "fullcodeline": "if (g.outd < 0 && errno == EEXIST) {"
    },
    {
        "line": 264,
        "fullcodeline": "complain(\"%s exists -- skipping\", g.outf);"
    },
    {
        "line": 274,
        "fullcodeline": "bail(\"write error on \", g.outf);"
    },
    {
        "line": 31,
        "fullcodeline": "if (errno == ENOENT && (g.list || g.decode)) {"
    },
    {
        "line": 56,
        "fullcodeline": "(st.st_mode & S_IFMT) != S_IFLNK &&"
    },
    {
        "line": 80,
        "fullcodeline": "if (here == NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "if (roll == NULL)"
    },
    {
        "line": 88,
        "fullcodeline": "while ((next = readdir(here)) != NULL) {"
    },
    {
        "line": 113,
        "fullcodeline": "cut = base = g.inf + strlen(g.inf);"
    },
    {
        "line": 146,
        "fullcodeline": "if (suf == 0) {"
    },
    {
        "line": 173,
        "fullcodeline": "!g.list)) {"
    },
    {
        "line": 243,
        "fullcodeline": "(g.force ? 0 : O_EXCL), 0600);"
    },
    {
        "line": 267,
        "fullcodeline": "if (g.ind != 0)"
    },
    {
        "line": 24,
        "fullcodeline": "bail(\"name too long: \", path);"
    },
    {
        "line": 32,
        "fullcodeline": "char **try = sufs;"
    },
    {
        "line": 46,
        "fullcodeline": "g.inf[len] = 0;"
    },
    {
        "line": 47,
        "fullcodeline": "complain(\"%s does not exist -- skipping\", g.inf);"
    },
    {
        "line": 93,
        "fullcodeline": "len = strlen(next->d_name) + 1;"
    },
    {
        "line": 106,
        "fullcodeline": "strcpy(item, next->d_name);"
    },
    {
        "line": 107,
        "fullcodeline": "item += len;"
    },
    {
        "line": 108,
        "fullcodeline": "*item = 0;"
    },
    {
        "line": 114,
        "fullcodeline": "if (base > g.inf && base[-1] != (unsigned char)'/') {"
    },
    {
        "line": 121,
        "fullcodeline": "strncpy(base, item, sizeof(g.inf) - (base - g.inf));"
    },
    {
        "line": 127,
        "fullcodeline": "item += strlen(item) + 1;"
    },
    {
        "line": 253,
        "fullcodeline": "ch = getchar();"
    },
    {
        "line": 256,
        "fullcodeline": "} while (ch != EOF && ch != '\\n' && ch != '\\r');"
    },
    {
        "line": 258,
        "fullcodeline": "g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,"
    },
    {
        "line": 38,
        "fullcodeline": "} while (lstat(g.inf, &st) && errno == ENOENT);"
    },
    {
        "line": 36,
        "fullcodeline": "strcpy(g.inf + len, *try++);"
    },
    {
        "line": 37,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "if (next->d_name[0] == 0 ||"
    },
    {
        "line": 90,
        "fullcodeline": "(next->d_name[0] == '.' && (next->d_name[1] == 0 ||"
    },
    {
        "line": 98,
        "fullcodeline": "bigger = REALLOC(roll, hold);"
    },
    {
        "line": 103,
        "fullcodeline": "item = bigger + (item - roll);"
    },
    {
        "line": 104,
        "fullcodeline": "roll = bigger;"
    },
    {
        "line": 115,
        "fullcodeline": "if ((size_t)(base - g.inf) >= sizeof(g.inf))"
    },
    {
        "line": 117,
        "fullcodeline": "*base++ = '/';"
    },
    {
        "line": 124,
        "fullcodeline": "bail(\"path too long: \", g.inf);"
    },
    {
        "line": 254,
        "fullcodeline": "if (reply < 0 && ch != ' ' && ch != '\\t')"
    },
    {
        "line": 255,
        "fullcodeline": "reply = ch == 'y' || ch == 'Y' ? 1 : 0;"
    },
    {
        "line": 34,
        "fullcodeline": "if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))"
    },
    {
        "line": 99,
        "fullcodeline": "if (bigger == NULL) {"
    },
    {
        "line": 91,
        "fullcodeline": "(next->d_name[1] == '.' && next->d_name[2] == 0))))"
    },
    {
        "line": 96,
        "fullcodeline": "hold <<= 1;"
    },
    {
        "line": 100,
        "fullcodeline": "FREE(roll);"
    },
    {
        "line": 123,
        "fullcodeline": "strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");"
    }
]