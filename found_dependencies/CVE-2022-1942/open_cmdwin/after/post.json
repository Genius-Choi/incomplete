[
    {
        "line": 4,
        "fullcodeline": "win_T\t\t*old_curwin = curwin;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\t\tsave_restart_edit = restart_edit;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\t\tsave_State = State;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\t\tsave_exmode = exmode_active;"
    },
    {
        "line": 35,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 38,
        "fullcodeline": "win_size_save(&winsizes);"
    },
    {
        "line": 42,
        "fullcodeline": "pum_undisplay();"
    },
    {
        "line": 45,
        "fullcodeline": "cmdmod.cmod_tab = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "cmdmod.cmod_flags |= CMOD_NOSWAPFILE;"
    },
    {
        "line": 56,
        "fullcodeline": "got_int = FALSE;"
    },
    {
        "line": 59,
        "fullcodeline": "cmdwin_type = get_cmdline_type();"
    },
    {
        "line": 71,
        "fullcodeline": "apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 72,
        "fullcodeline": "(void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);"
    },
    {
        "line": 73,
        "fullcodeline": "apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 74,
        "fullcodeline": "set_option_value_give_err((char_u *)\"bt\","
    },
    {
        "line": 76,
        "fullcodeline": "curbuf->b_p_ma = TRUE;"
    },
    {
        "line": 84,
        "fullcodeline": "RESET_BINDING(curwin);"
    },
    {
        "line": 87,
        "fullcodeline": "++curbuf_lock;"
    },
    {
        "line": 90,
        "fullcodeline": "need_wait_return = FALSE;"
    },
    {
        "line": 92,
        "fullcodeline": "histtype = hist_char2type(cmdwin_type);"
    },
    {
        "line": 103,
        "fullcodeline": "--curbuf_lock;"
    },
    {
        "line": 107,
        "fullcodeline": "curbuf->b_p_tw = 0;"
    },
    {
        "line": 110,
        "fullcodeline": "init_history();"
    },
    {
        "line": 131,
        "fullcodeline": "ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);"
    },
    {
        "line": 132,
        "fullcodeline": "curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"
    },
    {
        "line": 134,
        "fullcodeline": "changed_line_abv_curs();"
    },
    {
        "line": 135,
        "fullcodeline": "invalidate_botline();"
    },
    {
        "line": 136,
        "fullcodeline": "redraw_later(SOME_VALID);"
    },
    {
        "line": 139,
        "fullcodeline": "exmode_active = 0;"
    },
    {
        "line": 141,
        "fullcodeline": "State = MODE_NORMAL;"
    },
    {
        "line": 142,
        "fullcodeline": "setmouse();"
    },
    {
        "line": 145,
        "fullcodeline": "cmdwin_result = 0;"
    },
    {
        "line": 148,
        "fullcodeline": "trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);"
    },
    {
        "line": 152,
        "fullcodeline": "i = RedrawingDisabled;"
    },
    {
        "line": 153,
        "fullcodeline": "RedrawingDisabled = 0;"
    },
    {
        "line": 158,
        "fullcodeline": "main_loop(TRUE, FALSE);"
    },
    {
        "line": 160,
        "fullcodeline": "RedrawingDisabled = i;"
    },
    {
        "line": 167,
        "fullcodeline": "trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);"
    },
    {
        "line": 174,
        "fullcodeline": "cmdwin_type = 0;"
    },
    {
        "line": 175,
        "fullcodeline": "exmode_active = save_exmode;"
    },
    {
        "line": 270,
        "fullcodeline": "ga_clear(&winsizes);"
    },
    {
        "line": 271,
        "fullcodeline": "restart_edit = save_restart_edit;"
    },
    {
        "line": 276,
        "fullcodeline": "State = save_State;"
    },
    {
        "line": 277,
        "fullcodeline": "setmouse();"
    },
    {
        "line": 22,
        "fullcodeline": "if (text_or_buf_locked())"
    },
    {
        "line": 26,
        "fullcodeline": "if (cmdwin_type != 0"
    },
    {
        "line": 49,
        "fullcodeline": "if (win_split((int)p_cwh, WSP_BOT) == FAIL)"
    },
    {
        "line": 62,
        "fullcodeline": "if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)"
    },
    {
        "line": 75,
        "fullcodeline": "0L, (char_u *)\"nofile\", OPT_LOCAL);"
    },
    {
        "line": 93,
        "fullcodeline": "if (histtype == HIST_CMD || histtype == HIST_DEBUG)"
    },
    {
        "line": 111,
        "fullcodeline": "if (get_hislen() > 0)"
    },
    {
        "line": 149,
        "fullcodeline": "if (restart_edit != 0)\t// autocmd with \":startinsert\""
    },
    {
        "line": 179,
        "fullcodeline": "if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))"
    },
    {
        "line": 32,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 51,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 52,
        "fullcodeline": "ga_clear(&winsizes);"
    },
    {
        "line": 65,
        "fullcodeline": "win_close(curwin, TRUE);"
    },
    {
        "line": 66,
        "fullcodeline": "ga_clear(&winsizes);"
    },
    {
        "line": 67,
        "fullcodeline": "cmdwin_type = 0;"
    },
    {
        "line": 100,
        "fullcodeline": "set_option_value_give_err((char_u *)\"ft\","
    },
    {
        "line": 150,
        "fullcodeline": "stuffcharReadbuff(K_NOP);"
    },
    {
        "line": 181,
        "fullcodeline": "cmdwin_result = Ctrl_C;"
    },
    {
        "line": 182,
        "fullcodeline": "emsg(_(e_active_window_or_buffer_deleted));"
    },
    {
        "line": 95,
        "fullcodeline": "if (p_wc == TAB)"
    },
    {
        "line": 101,
        "fullcodeline": "0L, (char_u *)\"vim\", OPT_LOCAL);"
    },
    {
        "line": 114,
        "fullcodeline": "if (i >= 0)"
    },
    {
        "line": 192,
        "fullcodeline": "vim_free(ccline.cmdbuff);"
    },
    {
        "line": 252,
        "fullcodeline": "wp = curwin;"
    },
    {
        "line": 253,
        "fullcodeline": "set_bufref(&bufref, curbuf);"
    },
    {
        "line": 254,
        "fullcodeline": "win_goto(old_curwin);"
    },
    {
        "line": 267,
        "fullcodeline": "win_size_restore(&winsizes);"
    },
    {
        "line": 97,
        "fullcodeline": "add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT);"
    },
    {
        "line": 98,
        "fullcodeline": "add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL);"
    },
    {
        "line": 113,
        "fullcodeline": "i = *get_hisidx(histtype);"
    },
    {
        "line": 116,
        "fullcodeline": "lnum = 0;"
    },
    {
        "line": 193,
        "fullcodeline": "if (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed"
    },
    {
        "line": 225,
        "fullcodeline": "if (ccline.cmdbuff == NULL)"
    },
    {
        "line": 258,
        "fullcodeline": "if (win_valid(wp) && wp != curwin)"
    },
    {
        "line": 263,
        "fullcodeline": "if (bufref_valid(&bufref) && bufref.br_buf != curbuf)"
    },
    {
        "line": 125,
        "fullcodeline": "while (i != *get_hisidx(histtype));"
    },
    {
        "line": 195,
        "fullcodeline": "char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";"
    },
    {
        "line": 227,
        "fullcodeline": "ccline.cmdbuff = vim_strsave((char_u *)\"\");"
    },
    {
        "line": 228,
        "fullcodeline": "ccline.cmdlen = 0;"
    },
    {
        "line": 229,
        "fullcodeline": "ccline.cmdbufflen = 1;"
    },
    {
        "line": 230,
        "fullcodeline": "ccline.cmdpos = 0;"
    },
    {
        "line": 231,
        "fullcodeline": "cmdwin_result = Ctrl_C;"
    },
    {
        "line": 259,
        "fullcodeline": "win_close(wp, TRUE);"
    },
    {
        "line": 264,
        "fullcodeline": "close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);"
    },
    {
        "line": 197,
        "fullcodeline": "if (histtype == HIST_CMD)"
    },
    {
        "line": 235,
        "fullcodeline": "ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);"
    },
    {
        "line": 236,
        "fullcodeline": "ccline.cmdbufflen = ccline.cmdlen + 1;"
    },
    {
        "line": 237,
        "fullcodeline": "ccline.cmdpos = curwin->w_cursor.col;"
    },
    {
        "line": 119,
        "fullcodeline": "if (++i == get_hislen())"
    },
    {
        "line": 121,
        "fullcodeline": "if (get_histentry(histtype)[i].hisstr != NULL)"
    },
    {
        "line": 200,
        "fullcodeline": "ccline.cmdbuff = vim_strsave((char_u *)p);"
    },
    {
        "line": 201,
        "fullcodeline": "cmdwin_result = CAR;"
    },
    {
        "line": 212,
        "fullcodeline": "else if (cmdwin_result == K_XF2)\t// :qa typed"
    },
    {
        "line": 238,
        "fullcodeline": "if (ccline.cmdpos > ccline.cmdlen)"
    },
    {
        "line": 240,
        "fullcodeline": "if (cmdwin_result == K_IGNORE)"
    },
    {
        "line": 120,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 122,
        "fullcodeline": "ml_append(lnum++, get_histentry(histtype)[i].hisstr,"
    },
    {
        "line": 206,
        "fullcodeline": "ccline.cmdbuff = NULL;"
    },
    {
        "line": 207,
        "fullcodeline": "stuffcharReadbuff(':');"
    },
    {
        "line": 208,
        "fullcodeline": "stuffReadbuff((char_u *)p);"
    },
    {
        "line": 209,
        "fullcodeline": "stuffcharReadbuff(CAR);"
    },
    {
        "line": 214,
        "fullcodeline": "ccline.cmdbuff = vim_strsave((char_u *)\"qa\");"
    },
    {
        "line": 215,
        "fullcodeline": "cmdwin_result = CAR;"
    },
    {
        "line": 239,
        "fullcodeline": "ccline.cmdpos = ccline.cmdlen;"
    },
    {
        "line": 242,
        "fullcodeline": "set_cmdspos_cursor();"
    },
    {
        "line": 243,
        "fullcodeline": "redrawcmd();"
    },
    {
        "line": 123,
        "fullcodeline": "(colnr_T)0, FALSE);"
    },
    {
        "line": 217,
        "fullcodeline": "else if (cmdwin_result == Ctrl_C)"
    },
    {
        "line": 221,
        "fullcodeline": "ccline.cmdbuff = NULL;"
    },
    {
        "line": 224,
        "fullcodeline": "ccline.cmdbuff = vim_strsave(ml_get_curline());"
    }
]