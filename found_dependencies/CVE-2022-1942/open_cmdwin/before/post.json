[
    {
        "line": 4,
        "fullcodeline": "win_T\t\t*old_curwin = curwin;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\t\tsave_restart_edit = restart_edit;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\t\tsave_State = State;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\t\tsave_exmode = exmode_active;"
    },
    {
        "line": 31,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 34,
        "fullcodeline": "win_size_save(&winsizes);"
    },
    {
        "line": 38,
        "fullcodeline": "pum_undisplay();"
    },
    {
        "line": 41,
        "fullcodeline": "cmdmod.cmod_tab = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "cmdmod.cmod_flags |= CMOD_NOSWAPFILE;"
    },
    {
        "line": 52,
        "fullcodeline": "got_int = FALSE;"
    },
    {
        "line": 55,
        "fullcodeline": "cmdwin_type = get_cmdline_type();"
    },
    {
        "line": 67,
        "fullcodeline": "apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 68,
        "fullcodeline": "(void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);"
    },
    {
        "line": 69,
        "fullcodeline": "apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 70,
        "fullcodeline": "set_option_value_give_err((char_u *)\"bt\","
    },
    {
        "line": 72,
        "fullcodeline": "curbuf->b_p_ma = TRUE;"
    },
    {
        "line": 80,
        "fullcodeline": "RESET_BINDING(curwin);"
    },
    {
        "line": 83,
        "fullcodeline": "++curbuf_lock;"
    },
    {
        "line": 86,
        "fullcodeline": "need_wait_return = FALSE;"
    },
    {
        "line": 88,
        "fullcodeline": "histtype = hist_char2type(cmdwin_type);"
    },
    {
        "line": 99,
        "fullcodeline": "--curbuf_lock;"
    },
    {
        "line": 103,
        "fullcodeline": "curbuf->b_p_tw = 0;"
    },
    {
        "line": 106,
        "fullcodeline": "init_history();"
    },
    {
        "line": 127,
        "fullcodeline": "ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);"
    },
    {
        "line": 128,
        "fullcodeline": "curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;"
    },
    {
        "line": 130,
        "fullcodeline": "changed_line_abv_curs();"
    },
    {
        "line": 131,
        "fullcodeline": "invalidate_botline();"
    },
    {
        "line": 132,
        "fullcodeline": "redraw_later(SOME_VALID);"
    },
    {
        "line": 135,
        "fullcodeline": "exmode_active = 0;"
    },
    {
        "line": 137,
        "fullcodeline": "State = MODE_NORMAL;"
    },
    {
        "line": 138,
        "fullcodeline": "setmouse();"
    },
    {
        "line": 141,
        "fullcodeline": "cmdwin_result = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);"
    },
    {
        "line": 148,
        "fullcodeline": "i = RedrawingDisabled;"
    },
    {
        "line": 149,
        "fullcodeline": "RedrawingDisabled = 0;"
    },
    {
        "line": 154,
        "fullcodeline": "main_loop(TRUE, FALSE);"
    },
    {
        "line": 156,
        "fullcodeline": "RedrawingDisabled = i;"
    },
    {
        "line": 163,
        "fullcodeline": "trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);"
    },
    {
        "line": 170,
        "fullcodeline": "cmdwin_type = 0;"
    },
    {
        "line": 171,
        "fullcodeline": "exmode_active = save_exmode;"
    },
    {
        "line": 266,
        "fullcodeline": "ga_clear(&winsizes);"
    },
    {
        "line": 267,
        "fullcodeline": "restart_edit = save_restart_edit;"
    },
    {
        "line": 272,
        "fullcodeline": "State = save_State;"
    },
    {
        "line": 273,
        "fullcodeline": "setmouse();"
    },
    {
        "line": 22,
        "fullcodeline": "if (cmdwin_type != 0"
    },
    {
        "line": 45,
        "fullcodeline": "if (win_split((int)p_cwh, WSP_BOT) == FAIL)"
    },
    {
        "line": 58,
        "fullcodeline": "if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)"
    },
    {
        "line": 71,
        "fullcodeline": "0L, (char_u *)\"nofile\", OPT_LOCAL);"
    },
    {
        "line": 89,
        "fullcodeline": "if (histtype == HIST_CMD || histtype == HIST_DEBUG)"
    },
    {
        "line": 107,
        "fullcodeline": "if (get_hislen() > 0)"
    },
    {
        "line": 145,
        "fullcodeline": "if (restart_edit != 0)\t// autocmd with \":startinsert\""
    },
    {
        "line": 175,
        "fullcodeline": "if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))"
    },
    {
        "line": 28,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 47,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 48,
        "fullcodeline": "ga_clear(&winsizes);"
    },
    {
        "line": 61,
        "fullcodeline": "win_close(curwin, TRUE);"
    },
    {
        "line": 62,
        "fullcodeline": "ga_clear(&winsizes);"
    },
    {
        "line": 63,
        "fullcodeline": "cmdwin_type = 0;"
    },
    {
        "line": 96,
        "fullcodeline": "set_option_value_give_err((char_u *)\"ft\","
    },
    {
        "line": 146,
        "fullcodeline": "stuffcharReadbuff(K_NOP);"
    },
    {
        "line": 177,
        "fullcodeline": "cmdwin_result = Ctrl_C;"
    },
    {
        "line": 178,
        "fullcodeline": "emsg(_(e_active_window_or_buffer_deleted));"
    },
    {
        "line": 91,
        "fullcodeline": "if (p_wc == TAB)"
    },
    {
        "line": 97,
        "fullcodeline": "0L, (char_u *)\"vim\", OPT_LOCAL);"
    },
    {
        "line": 110,
        "fullcodeline": "if (i >= 0)"
    },
    {
        "line": 188,
        "fullcodeline": "vim_free(ccline.cmdbuff);"
    },
    {
        "line": 248,
        "fullcodeline": "wp = curwin;"
    },
    {
        "line": 249,
        "fullcodeline": "set_bufref(&bufref, curbuf);"
    },
    {
        "line": 250,
        "fullcodeline": "win_goto(old_curwin);"
    },
    {
        "line": 263,
        "fullcodeline": "win_size_restore(&winsizes);"
    },
    {
        "line": 93,
        "fullcodeline": "add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT);"
    },
    {
        "line": 94,
        "fullcodeline": "add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL);"
    },
    {
        "line": 109,
        "fullcodeline": "i = *get_hisidx(histtype);"
    },
    {
        "line": 112,
        "fullcodeline": "lnum = 0;"
    },
    {
        "line": 189,
        "fullcodeline": "if (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed"
    },
    {
        "line": 221,
        "fullcodeline": "if (ccline.cmdbuff == NULL)"
    },
    {
        "line": 254,
        "fullcodeline": "if (win_valid(wp) && wp != curwin)"
    },
    {
        "line": 259,
        "fullcodeline": "if (bufref_valid(&bufref) && bufref.br_buf != curbuf)"
    },
    {
        "line": 121,
        "fullcodeline": "while (i != *get_hisidx(histtype));"
    },
    {
        "line": 191,
        "fullcodeline": "char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";"
    },
    {
        "line": 223,
        "fullcodeline": "ccline.cmdbuff = vim_strsave((char_u *)\"\");"
    },
    {
        "line": 224,
        "fullcodeline": "ccline.cmdlen = 0;"
    },
    {
        "line": 225,
        "fullcodeline": "ccline.cmdbufflen = 1;"
    },
    {
        "line": 226,
        "fullcodeline": "ccline.cmdpos = 0;"
    },
    {
        "line": 227,
        "fullcodeline": "cmdwin_result = Ctrl_C;"
    },
    {
        "line": 255,
        "fullcodeline": "win_close(wp, TRUE);"
    },
    {
        "line": 260,
        "fullcodeline": "close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);"
    },
    {
        "line": 193,
        "fullcodeline": "if (histtype == HIST_CMD)"
    },
    {
        "line": 231,
        "fullcodeline": "ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);"
    },
    {
        "line": 232,
        "fullcodeline": "ccline.cmdbufflen = ccline.cmdlen + 1;"
    },
    {
        "line": 233,
        "fullcodeline": "ccline.cmdpos = curwin->w_cursor.col;"
    },
    {
        "line": 115,
        "fullcodeline": "if (++i == get_hislen())"
    },
    {
        "line": 117,
        "fullcodeline": "if (get_histentry(histtype)[i].hisstr != NULL)"
    },
    {
        "line": 196,
        "fullcodeline": "ccline.cmdbuff = vim_strsave((char_u *)p);"
    },
    {
        "line": 197,
        "fullcodeline": "cmdwin_result = CAR;"
    },
    {
        "line": 208,
        "fullcodeline": "else if (cmdwin_result == K_XF2)\t// :qa typed"
    },
    {
        "line": 234,
        "fullcodeline": "if (ccline.cmdpos > ccline.cmdlen)"
    },
    {
        "line": 236,
        "fullcodeline": "if (cmdwin_result == K_IGNORE)"
    },
    {
        "line": 116,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "ml_append(lnum++, get_histentry(histtype)[i].hisstr,"
    },
    {
        "line": 202,
        "fullcodeline": "ccline.cmdbuff = NULL;"
    },
    {
        "line": 203,
        "fullcodeline": "stuffcharReadbuff(':');"
    },
    {
        "line": 204,
        "fullcodeline": "stuffReadbuff((char_u *)p);"
    },
    {
        "line": 205,
        "fullcodeline": "stuffcharReadbuff(CAR);"
    },
    {
        "line": 210,
        "fullcodeline": "ccline.cmdbuff = vim_strsave((char_u *)\"qa\");"
    },
    {
        "line": 211,
        "fullcodeline": "cmdwin_result = CAR;"
    },
    {
        "line": 235,
        "fullcodeline": "ccline.cmdpos = ccline.cmdlen;"
    },
    {
        "line": 238,
        "fullcodeline": "set_cmdspos_cursor();"
    },
    {
        "line": 239,
        "fullcodeline": "redrawcmd();"
    },
    {
        "line": 119,
        "fullcodeline": "(colnr_T)0, FALSE);"
    },
    {
        "line": 213,
        "fullcodeline": "else if (cmdwin_result == Ctrl_C)"
    },
    {
        "line": 217,
        "fullcodeline": "ccline.cmdbuff = NULL;"
    },
    {
        "line": 220,
        "fullcodeline": "ccline.cmdbuff = vim_strsave(ml_get_curline());"
    }
]