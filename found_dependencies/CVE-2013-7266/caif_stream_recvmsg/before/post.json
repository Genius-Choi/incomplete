[
    {
        "line": 5,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 6,
        "fullcodeline": "int copied = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "err = -EOPNOTSUPP;"
    },
    {
        "line": 15,
        "fullcodeline": "msg->msg_namelen = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 25,
        "fullcodeline": "caif_read_lock(sk);"
    },
    {
        "line": 26,
        "fullcodeline": "target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);"
    },
    {
        "line": 27,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);"
    },
    {
        "line": 107,
        "fullcodeline": "caif_read_unlock(sk);"
    },
    {
        "line": 12,
        "fullcodeline": "if (flags&MSG_OOB)"
    },
    {
        "line": 22,
        "fullcodeline": "if (sk->sk_state == CAIF_CONNECTING)"
    },
    {
        "line": 110,
        "fullcodeline": "return copied ? : err;"
    },
    {
        "line": 33,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 34,
        "fullcodeline": "skb = skb_dequeue(&sk->sk_receive_queue);"
    },
    {
        "line": 35,
        "fullcodeline": "caif_check_flow_release(sk);"
    },
    {
        "line": 76,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 84,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 85,
        "fullcodeline": "size -= chunk;"
    },
    {
        "line": 37,
        "fullcodeline": "if (skb == NULL) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 43,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 46,
        "fullcodeline": "err = -ECONNRESET;"
    },
    {
        "line": 50,
        "fullcodeline": "err = -EPIPE;"
    },
    {
        "line": 56,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 58,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 62,
        "fullcodeline": "caif_read_unlock(sk);"
    },
    {
        "line": 64,
        "fullcodeline": "timeo = caif_stream_data_wait(sk, timeo);"
    },
    {
        "line": 70,
        "fullcodeline": "caif_read_lock(sk);"
    },
    {
        "line": 73,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 79,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 89,
        "fullcodeline": "skb_pull(skb, chunk);"
    },
    {
        "line": 96,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 38,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 47,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 51,
        "fullcodeline": "if (sk->sk_state != CAIF_CONNECTED)"
    },
    {
        "line": 53,
        "fullcodeline": "if (sock_flag(sk, SOCK_DEAD))"
    },
    {
        "line": 59,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 66,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (copied == 0)"
    },
    {
        "line": 103,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 67,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 81,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 93,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    }
]