[
    {
        "line": 9,
        "fullcodeline": "int error = sock_error(sk);"
    },
    {
        "line": 14,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);"
    },
    {
        "line": 54,
        "fullcodeline": "*err = error;"
    },
    {
        "line": 49,
        "fullcodeline": "} while (!wait_for_packet(sk, err, &timeo));"
    },
    {
        "line": 24,
        "fullcodeline": "struct sk_buff_head *queue = &sk->sk_receive_queue;"
    },
    {
        "line": 26,
        "fullcodeline": "spin_lock_irqsave(&queue->lock, cpu_flags);"
    },
    {
        "line": 27,
        "fullcodeline": "skb_queue_walk(queue, skb) {"
    },
    {
        "line": 28,
        "fullcodeline": "*peeked = skb->peeked;"
    },
    {
        "line": 39,
        "fullcodeline": "spin_unlock_irqrestore(&queue->lock, cpu_flags);"
    },
    {
        "line": 29,
        "fullcodeline": "if (flags & MSG_PEEK) {"
    },
    {
        "line": 34,
        "fullcodeline": "skb->peeked = 1;"
    },
    {
        "line": 35,
        "fullcodeline": "atomic_inc(&skb->users);"
    },
    {
        "line": 30,
        "fullcodeline": "if (*off >= skb->len) {"
    },
    {
        "line": 37,
        "fullcodeline": "__skb_unlink(skb, queue);"
    },
    {
        "line": 31,
        "fullcodeline": "*off -= skb->len;"
    }
]