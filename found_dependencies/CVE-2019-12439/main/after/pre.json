[
    {
        "line": 5,
        "fullcodeline": "const char *base_path = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *old_cwd = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int event_fd = -1;"
    },
    {
        "line": 10,
        "fullcodeline": "int child_wait_fd = -1;"
    },
    {
        "line": 11,
        "fullcodeline": "int setup_finished_pipe[] = {-1, -1};"
    },
    {
        "line": 18,
        "fullcodeline": "cleanup_free char *seccomp_data = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "cleanup_free char *args_data = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "real_uid = getuid ();"
    },
    {
        "line": 32,
        "fullcodeline": "real_gid = getgid ();"
    },
    {
        "line": 35,
        "fullcodeline": "acquire_privs ();"
    },
    {
        "line": 44,
        "fullcodeline": "read_overflowids ();"
    },
    {
        "line": 46,
        "fullcodeline": "argv0 = argv[0];"
    },
    {
        "line": 51,
        "fullcodeline": "argv++;"
    },
    {
        "line": 52,
        "fullcodeline": "argc--;"
    },
    {
        "line": 57,
        "fullcodeline": "parse_args (&argc, (const char ***) &argv);"
    },
    {
        "line": 60,
        "fullcodeline": "args_data = opt_args_data;"
    },
    {
        "line": 61,
        "fullcodeline": "opt_args_data = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "__debug__ ((\"Creating root mount point\\n\"));"
    },
    {
        "line": 141,
        "fullcodeline": "proc_fd = open (\"/proc\", O_PATH);"
    },
    {
        "line": 151,
        "fullcodeline": "base_path = \"/tmp\";"
    },
    {
        "line": 153,
        "fullcodeline": "__debug__ ((\"creating new namespace\\n\"));"
    },
    {
        "line": 163,
        "fullcodeline": "block_sigchild ();"
    },
    {
        "line": 165,
        "fullcodeline": "clone_flags = SIGCHLD | CLONE_NEWNS;"
    },
    {
        "line": 191,
        "fullcodeline": "child_wait_fd = eventfd (0, EFD_CLOEXEC);"
    },
    {
        "line": 204,
        "fullcodeline": "pid = raw_clone (clone_flags, NULL);"
    },
    {
        "line": 218,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 219,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 309,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 310,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 331,
        "fullcodeline": "old_umask = umask (0);"
    },
    {
        "line": 346,
        "fullcodeline": "old_cwd = get_current_dir_name ();"
    },
    {
        "line": 507,
        "fullcodeline": "new_cwd = \"/\";"
    },
    {
        "line": 28,
        "fullcodeline": "if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))"
    },
    {
        "line": 38,
        "fullcodeline": "if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)"
    },
    {
        "line": 48,
        "fullcodeline": "if (isatty (1))"
    },
    {
        "line": 54,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 63,
        "fullcodeline": "if ((requested_caps[0] || requested_caps[1]) && is_privileged)"
    },
    {
        "line": 66,
        "fullcodeline": "if (opt_userns_block_fd != -1 && !opt_unshare_user)"
    },
    {
        "line": 69,
        "fullcodeline": "if (opt_userns_block_fd != -1 && opt_info_fd == -1)"
    },
    {
        "line": 74,
        "fullcodeline": "if (!is_privileged && getuid () != 0)"
    },
    {
        "line": 83,
        "fullcodeline": "if (opt_unshare_user_try &&"
    },
    {
        "line": 114,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 119,
        "fullcodeline": "if (opt_sandbox_uid == -1)"
    },
    {
        "line": 121,
        "fullcodeline": "if (opt_sandbox_gid == -1)"
    },
    {
        "line": 124,
        "fullcodeline": "if (!opt_unshare_user && opt_sandbox_uid != real_uid)"
    },
    {
        "line": 127,
        "fullcodeline": "if (!opt_unshare_user && opt_sandbox_gid != real_gid)"
    },
    {
        "line": 130,
        "fullcodeline": "if (!opt_unshare_uts && opt_sandbox_hostname != NULL)"
    },
    {
        "line": 133,
        "fullcodeline": "if (opt_as_pid_1 && !opt_unshare_pid)"
    },
    {
        "line": 136,
        "fullcodeline": "if (opt_as_pid_1 && lock_files != NULL)"
    },
    {
        "line": 142,
        "fullcodeline": "if (proc_fd == -1)"
    },
    {
        "line": 155,
        "fullcodeline": "if (opt_unshare_pid && !opt_as_pid_1)"
    },
    {
        "line": 192,
        "fullcodeline": "if (child_wait_fd == -1)"
    },
    {
        "line": 196,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 205,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 221,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 290,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 293,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 297,
        "fullcodeline": "res = read (child_wait_fd, &val, 8);"
    },
    {
        "line": 311,
        "fullcodeline": "if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 430,
        "fullcodeline": "if (umount2 (\"oldroot\", MNT_DETACH))"
    },
    {
        "line": 439,
        "fullcodeline": "{ cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);"
    },
    {
        "line": 481,
        "fullcodeline": "drop_privs (!is_privileged);"
    },
    {
        "line": 483,
        "fullcodeline": "if (opt_block_fd != -1)"
    },
    {
        "line": 490,
        "fullcodeline": "if (opt_seccomp_fd != -1)"
    },
    {
        "line": 530,
        "fullcodeline": "if (opt_new_session &&"
    },
    {
        "line": 575,
        "fullcodeline": "__debug__ ((\"launch executable %s\\n\", argv[0]));"
    },
    {
        "line": 577,
        "fullcodeline": "if (proc_fd != -1)"
    },
    {
        "line": 603,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 29,
        "fullcodeline": "print_version_and_exit ();"
    },
    {
        "line": 39,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");"
    },
    {
        "line": 49,
        "fullcodeline": "host_tty_dev = ttyname (1);"
    },
    {
        "line": 55,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 64,
        "fullcodeline": "die (\"--cap-add in setuid mode can be used only by root\");"
    },
    {
        "line": 67,
        "fullcodeline": "die (\"--userns-block-fd requires --unshare-user\");"
    },
    {
        "line": 70,
        "fullcodeline": "die (\"--userns-block-fd requires --info-fd\");"
    },
    {
        "line": 75,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 84,
        "fullcodeline": "stat (\"/proc/self/ns/user\", &sbuf) == 0)"
    },
    {
        "line": 86,
        "fullcodeline": "bool disabled = FALSE;"
    },
    {
        "line": 115,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 120,
        "fullcodeline": "opt_sandbox_uid = real_uid;"
    },
    {
        "line": 122,
        "fullcodeline": "opt_sandbox_gid = real_gid;"
    },
    {
        "line": 125,
        "fullcodeline": "die (\"Specifying --uid requires --unshare-user\");"
    },
    {
        "line": 128,
        "fullcodeline": "die (\"Specifying --gid requires --unshare-user\");"
    },
    {
        "line": 131,
        "fullcodeline": "die (\"Specifying --hostname requires --unshare-uts\");"
    },
    {
        "line": 134,
        "fullcodeline": "die (\"Specifying --as-pid-1 requires --unshare-pid\");"
    },
    {
        "line": 137,
        "fullcodeline": "die (\"Specifying --as-pid-1 and --lock-file is not permitted\");"
    },
    {
        "line": 143,
        "fullcodeline": "die_with_error (\"Can't open /proc\");"
    },
    {
        "line": 157,
        "fullcodeline": "event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);"
    },
    {
        "line": 167,
        "fullcodeline": "clone_flags |= CLONE_NEWUSER;"
    },
    {
        "line": 169,
        "fullcodeline": "clone_flags |= CLONE_NEWPID;"
    },
    {
        "line": 171,
        "fullcodeline": "clone_flags |= CLONE_NEWNET;"
    },
    {
        "line": 173,
        "fullcodeline": "clone_flags |= CLONE_NEWIPC;"
    },
    {
        "line": 175,
        "fullcodeline": "clone_flags |= CLONE_NEWUTS;"
    },
    {
        "line": 185,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 193,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 199,
        "fullcodeline": "ret = pipe2 (setup_finished_pipe, O_CLOEXEC);"
    },
    {
        "line": 215,
        "fullcodeline": "die_with_error (\"Creating new namespace failed\");"
    },
    {
        "line": 243,
        "fullcodeline": "drop_privs (FALSE);"
    },
    {
        "line": 246,
        "fullcodeline": "handle_die_with_parent ();"
    },
    {
        "line": 268,
        "fullcodeline": "val = 1;"
    },
    {
        "line": 269,
        "fullcodeline": "res = write (child_wait_fd, &val, 8);"
    },
    {
        "line": 271,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 326,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 339,
        "fullcodeline": "if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)"
    },
    {
        "line": 343,
        "fullcodeline": "if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)"
    },
    {
        "line": 350,
        "fullcodeline": "if (chdir (base_path) != 0)"
    },
    {
        "line": 362,
        "fullcodeline": "if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)"
    },
    {
        "line": 371,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 377,
        "fullcodeline": "int privsep_sockets[2];"
    },
    {
        "line": 382,
        "fullcodeline": "child = fork ();"
    },
    {
        "line": 427,
        "fullcodeline": "if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)"
    },
    {
        "line": 440,
        "fullcodeline": "if (oldrootfd < 0)"
    },
    {
        "line": 464,
        "fullcodeline": "if (opt_unshare_user &&"
    },
    {
        "line": 466,
        "fullcodeline": "opt_userns_block_fd == -1)"
    },
    {
        "line": 475,
        "fullcodeline": "write_uid_gid_map (opt_sandbox_uid, ns_uid,"
    },
    {
        "line": 485,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 492,
        "fullcodeline": "seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);"
    },
    {
        "line": 499,
        "fullcodeline": "seccomp_prog.len = seccomp_len / 8;"
    },
    {
        "line": 500,
        "fullcodeline": "seccomp_prog.filter = (struct sock_filter *) seccomp_data;"
    },
    {
        "line": 512,
        "fullcodeline": "new_cwd = opt_chdir_path;"
    },
    {
        "line": 531,
        "fullcodeline": "setsid () == (pid_t) -1)"
    },
    {
        "line": 534,
        "fullcodeline": "if (label_exec (opt_exec_label) == -1)"
    },
    {
        "line": 535,
        "fullcodeline": "die_with_error (\"label_exec %s\", argv[0]);"
    },
    {
        "line": 539,
        "fullcodeline": "if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))"
    },
    {
        "line": 547,
        "fullcodeline": "pid = fork ();"
    },
    {
        "line": 599,
        "fullcodeline": "if (seccomp_data != NULL &&"
    },
    {
        "line": 600,
        "fullcodeline": "prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)"
    },
    {
        "line": 605,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 611,
        "fullcodeline": "if (execvp (argv[0], argv) == -1)"
    },
    {
        "line": 89,
        "fullcodeline": "if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)"
    },
    {
        "line": 98,
        "fullcodeline": "if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)"
    },
    {
        "line": 110,
        "fullcodeline": "if (!disabled)"
    },
    {
        "line": 158,
        "fullcodeline": "if (event_fd == -1)"
    },
    {
        "line": 178,
        "fullcodeline": "if (stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 188,
        "fullcodeline": "if (!stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 200,
        "fullcodeline": "if (ret == -1)"
    },
    {
        "line": 225,
        "fullcodeline": "if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 248,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 254,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 260,
        "fullcodeline": "if (opt_userns_block_fd != -1)"
    },
    {
        "line": 273,
        "fullcodeline": "return monitor_child (event_fd, pid, setup_finished_pipe[0]);"
    },
    {
        "line": 328,
        "fullcodeline": "-1, TRUE, FALSE);"
    },
    {
        "line": 383,
        "fullcodeline": "if (child == -1)"
    },
    {
        "line": 386,
        "fullcodeline": "if (child == 0)"
    },
    {
        "line": 421,
        "fullcodeline": "setup_newroot (opt_unshare_pid, -1);"
    },
    {
        "line": 442,
        "fullcodeline": "if (chdir (\"/newroot\") != 0)"
    },
    {
        "line": 454,
        "fullcodeline": "if (pivot_root (\".\", \".\") != 0)"
    },
    {
        "line": 456,
        "fullcodeline": "if (fchdir (oldrootfd) < 0)"
    },
    {
        "line": 458,
        "fullcodeline": "if (umount2 (\".\", MNT_DETACH) < 0)"
    },
    {
        "line": 460,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 465,
        "fullcodeline": "(ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&"
    },
    {
        "line": 477,
        "fullcodeline": "-1, FALSE, FALSE);"
    },
    {
        "line": 486,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));"
    },
    {
        "line": 493,
        "fullcodeline": "if (seccomp_data == NULL)"
    },
    {
        "line": 510,
        "fullcodeline": "if (chdir (opt_chdir_path))"
    },
    {
        "line": 548,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 551,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 584,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 606,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 613,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 91,
        "fullcodeline": "cleanup_free char *enable = NULL;"
    },
    {
        "line": 92,
        "fullcodeline": "enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");"
    },
    {
        "line": 100,
        "fullcodeline": "cleanup_free char *max_user_ns = NULL;"
    },
    {
        "line": 101,
        "fullcodeline": "max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");"
    },
    {
        "line": 111,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 159,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 189,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 201,
        "fullcodeline": "die_with_error (\"pipe2()\");"
    },
    {
        "line": 235,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 250,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);"
    },
    {
        "line": 251,
        "fullcodeline": "dump_info (opt_info_fd, output, TRUE);"
    },
    {
        "line": 252,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 256,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);"
    },
    {
        "line": 257,
        "fullcodeline": "dump_info (opt_json_status_fd, output, TRUE);"
    },
    {
        "line": 262,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 263,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));"
    },
    {
        "line": 264,
        "fullcodeline": "close (opt_userns_block_fd);"
    },
    {
        "line": 322,
        "fullcodeline": "ns_uid = 0;"
    },
    {
        "line": 323,
        "fullcodeline": "ns_gid = 0;"
    },
    {
        "line": 379,
        "fullcodeline": "if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)"
    },
    {
        "line": 389,
        "fullcodeline": "drop_privs (FALSE);"
    },
    {
        "line": 391,
        "fullcodeline": "setup_newroot (opt_unshare_pid, privsep_sockets[1]);"
    },
    {
        "line": 496,
        "fullcodeline": "if (seccomp_len % 8 != 0)"
    },
    {
        "line": 511,
        "fullcodeline": "die_with_error (\"Can't chdir to %s\", opt_chdir_path);"
    },
    {
        "line": 615,
        "fullcodeline": "int saved_errno = errno;"
    },
    {
        "line": 616,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 93,
        "fullcodeline": "if (enable != NULL && enable[0] == 'N')"
    },
    {
        "line": 102,
        "fullcodeline": "if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)"
    },
    {
        "line": 180,
        "fullcodeline": "if (errno == ENOENT)"
    },
    {
        "line": 209,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 402,
        "fullcodeline": "unpriv_socket = privsep_sockets[0];"
    },
    {
        "line": 514,
        "fullcodeline": "else if (chdir (old_cwd) == 0)"
    },
    {
        "line": 517,
        "fullcodeline": "new_cwd = old_cwd;"
    },
    {
        "line": 561,
        "fullcodeline": "int dont_close[3];"
    },
    {
        "line": 562,
        "fullcodeline": "int j = 0;"
    },
    {
        "line": 567,
        "fullcodeline": "dont_close[j++] = -1;"
    },
    {
        "line": 568,
        "fullcodeline": "fdwalk (proc_fd, close_extra_fds, dont_close);"
    },
    {
        "line": 571,
        "fullcodeline": "return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);"
    },
    {
        "line": 617,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 94,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 103,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 181,
        "fullcodeline": "die (\"Cannot create new cgroup namespace because the kernel does not support it\");"
    },
    {
        "line": 210,
        "fullcodeline": "die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");"
    },
    {
        "line": 397,
        "fullcodeline": "uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */"
    },
    {
        "line": 400,
        "fullcodeline": "cleanup_fd int unpriv_socket = -1;"
    },
    {
        "line": 413,
        "fullcodeline": "while (op != PRIV_SEP_OP_DONE);"
    },
    {
        "line": 522,
        "fullcodeline": "const char *home = getenv (\"HOME\");"
    },
    {
        "line": 563,
        "fullcodeline": "if (event_fd != -1)"
    },
    {
        "line": 565,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 183,
        "fullcodeline": "die_with_error (\"stat on /proc/self/ns/cgroup failed\");"
    },
    {
        "line": 407,
        "fullcodeline": "op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),"
    },
    {
        "line": 409,
        "fullcodeline": "privileged_op (-1, op, flags, arg1, arg2);"
    },
    {
        "line": 211,
        "fullcodeline": "else if (errno == EPERM && !is_privileged)"
    },
    {
        "line": 523,
        "fullcodeline": "if (home != NULL &&"
    },
    {
        "line": 524,
        "fullcodeline": "chdir (home) == 0)"
    },
    {
        "line": 525,
        "fullcodeline": "new_cwd = home;"
    },
    {
        "line": 212,
        "fullcodeline": "die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");"
    },
    {
        "line": 410,
        "fullcodeline": "if (write (unpriv_socket, buffer, 1) != 1)"
    },
    {
        "line": 564,
        "fullcodeline": "dont_close[j++] = event_fd;"
    },
    {
        "line": 566,
        "fullcodeline": "dont_close[j++] = opt_sync_fd;"
    }
]