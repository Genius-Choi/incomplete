[
    {
        "line": 5,
        "fullcodeline": "cleanup_free char *base_path = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *old_cwd = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int event_fd = -1;"
    },
    {
        "line": 10,
        "fullcodeline": "int child_wait_fd = -1;"
    },
    {
        "line": 11,
        "fullcodeline": "int setup_finished_pipe[] = {-1, -1};"
    },
    {
        "line": 18,
        "fullcodeline": "cleanup_free char *seccomp_data = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "cleanup_free char *args_data = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "real_uid = getuid ();"
    },
    {
        "line": 32,
        "fullcodeline": "real_gid = getgid ();"
    },
    {
        "line": 35,
        "fullcodeline": "acquire_privs ();"
    },
    {
        "line": 44,
        "fullcodeline": "read_overflowids ();"
    },
    {
        "line": 46,
        "fullcodeline": "argv0 = argv[0];"
    },
    {
        "line": 51,
        "fullcodeline": "argv++;"
    },
    {
        "line": 52,
        "fullcodeline": "argc--;"
    },
    {
        "line": 57,
        "fullcodeline": "parse_args (&argc, (const char ***) &argv);"
    },
    {
        "line": 60,
        "fullcodeline": "args_data = opt_args_data;"
    },
    {
        "line": 61,
        "fullcodeline": "opt_args_data = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "__debug__ ((\"Creating root mount point\\n\"));"
    },
    {
        "line": 141,
        "fullcodeline": "proc_fd = open (\"/proc\", O_PATH);"
    },
    {
        "line": 147,
        "fullcodeline": "base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);"
    },
    {
        "line": 156,
        "fullcodeline": "__debug__ ((\"creating new namespace\\n\"));"
    },
    {
        "line": 166,
        "fullcodeline": "block_sigchild ();"
    },
    {
        "line": 168,
        "fullcodeline": "clone_flags = SIGCHLD | CLONE_NEWNS;"
    },
    {
        "line": 194,
        "fullcodeline": "child_wait_fd = eventfd (0, EFD_CLOEXEC);"
    },
    {
        "line": 207,
        "fullcodeline": "pid = raw_clone (clone_flags, NULL);"
    },
    {
        "line": 221,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 222,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 300,
        "fullcodeline": "res = read (child_wait_fd, &val, 8);"
    },
    {
        "line": 301,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 307,
        "fullcodeline": "switch_to_user_with_privs ();"
    },
    {
        "line": 312,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 313,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 334,
        "fullcodeline": "old_umask = umask (0);"
    },
    {
        "line": 337,
        "fullcodeline": "resolve_symlinks_in_ops ();"
    },
    {
        "line": 349,
        "fullcodeline": "old_cwd = get_current_dir_name ();"
    },
    {
        "line": 426,
        "fullcodeline": "close_ops_fd ();"
    },
    {
        "line": 483,
        "fullcodeline": "drop_privs (!is_privileged);"
    },
    {
        "line": 507,
        "fullcodeline": "umask (old_umask);"
    },
    {
        "line": 509,
        "fullcodeline": "new_cwd = \"/\";"
    },
    {
        "line": 529,
        "fullcodeline": "xsetenv (\"PWD\", new_cwd, 1);"
    },
    {
        "line": 530,
        "fullcodeline": "free (old_cwd);"
    },
    {
        "line": 539,
        "fullcodeline": "__debug__ ((\"forking for child\\n\"));"
    },
    {
        "line": 577,
        "fullcodeline": "__debug__ ((\"launch executable %s\\n\", argv[0]));"
    },
    {
        "line": 591,
        "fullcodeline": "unblock_sigchild ();"
    },
    {
        "line": 594,
        "fullcodeline": "handle_die_with_parent ();"
    },
    {
        "line": 28,
        "fullcodeline": "if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))"
    },
    {
        "line": 38,
        "fullcodeline": "if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)"
    },
    {
        "line": 48,
        "fullcodeline": "if (isatty (1))"
    },
    {
        "line": 54,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 63,
        "fullcodeline": "if ((requested_caps[0] || requested_caps[1]) && is_privileged)"
    },
    {
        "line": 66,
        "fullcodeline": "if (opt_userns_block_fd != -1 && !opt_unshare_user)"
    },
    {
        "line": 69,
        "fullcodeline": "if (opt_userns_block_fd != -1 && opt_info_fd == -1)"
    },
    {
        "line": 74,
        "fullcodeline": "if (!is_privileged && getuid () != 0)"
    },
    {
        "line": 83,
        "fullcodeline": "if (opt_unshare_user_try &&"
    },
    {
        "line": 114,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 119,
        "fullcodeline": "if (opt_sandbox_uid == -1)"
    },
    {
        "line": 121,
        "fullcodeline": "if (opt_sandbox_gid == -1)"
    },
    {
        "line": 124,
        "fullcodeline": "if (!opt_unshare_user && opt_sandbox_uid != real_uid)"
    },
    {
        "line": 127,
        "fullcodeline": "if (!opt_unshare_user && opt_sandbox_gid != real_gid)"
    },
    {
        "line": 130,
        "fullcodeline": "if (!opt_unshare_uts && opt_sandbox_hostname != NULL)"
    },
    {
        "line": 133,
        "fullcodeline": "if (opt_as_pid_1 && !opt_unshare_pid)"
    },
    {
        "line": 136,
        "fullcodeline": "if (opt_as_pid_1 && lock_files != NULL)"
    },
    {
        "line": 142,
        "fullcodeline": "if (proc_fd == -1)"
    },
    {
        "line": 148,
        "fullcodeline": "if (ensure_dir (base_path, 0755))"
    },
    {
        "line": 158,
        "fullcodeline": "if (opt_unshare_pid && !opt_as_pid_1)"
    },
    {
        "line": 195,
        "fullcodeline": "if (child_wait_fd == -1)"
    },
    {
        "line": 199,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 208,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 224,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 293,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 296,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 314,
        "fullcodeline": "if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 342,
        "fullcodeline": "if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)"
    },
    {
        "line": 346,
        "fullcodeline": "if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)"
    },
    {
        "line": 353,
        "fullcodeline": "if (chdir (base_path) != 0)"
    },
    {
        "line": 361,
        "fullcodeline": "if (mkdir (\"newroot\", 0755))"
    },
    {
        "line": 364,
        "fullcodeline": "if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)"
    },
    {
        "line": 367,
        "fullcodeline": "if (mkdir (\"oldroot\", 0755))"
    },
    {
        "line": 370,
        "fullcodeline": "if (pivot_root (base_path, \"oldroot\"))"
    },
    {
        "line": 373,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 429,
        "fullcodeline": "if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)"
    },
    {
        "line": 432,
        "fullcodeline": "if (umount2 (\"oldroot\", MNT_DETACH))"
    },
    {
        "line": 441,
        "fullcodeline": "{ cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);"
    },
    {
        "line": 466,
        "fullcodeline": "if (opt_unshare_user &&"
    },
    {
        "line": 485,
        "fullcodeline": "if (opt_block_fd != -1)"
    },
    {
        "line": 492,
        "fullcodeline": "if (opt_seccomp_fd != -1)"
    },
    {
        "line": 532,
        "fullcodeline": "if (opt_new_session &&"
    },
    {
        "line": 536,
        "fullcodeline": "if (label_exec (opt_exec_label) == -1)"
    },
    {
        "line": 541,
        "fullcodeline": "if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))"
    },
    {
        "line": 579,
        "fullcodeline": "if (proc_fd != -1)"
    },
    {
        "line": 584,
        "fullcodeline": "if (!opt_as_pid_1)"
    },
    {
        "line": 596,
        "fullcodeline": "if (!is_privileged)"
    },
    {
        "line": 601,
        "fullcodeline": "if (seccomp_data != NULL &&"
    },
    {
        "line": 605,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 613,
        "fullcodeline": "if (execvp (argv[0], argv) == -1)"
    },
    {
        "line": 29,
        "fullcodeline": "print_version_and_exit ();"
    },
    {
        "line": 39,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");"
    },
    {
        "line": 49,
        "fullcodeline": "host_tty_dev = ttyname (1);"
    },
    {
        "line": 55,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 64,
        "fullcodeline": "die (\"--cap-add in setuid mode can be used only by root\");"
    },
    {
        "line": 67,
        "fullcodeline": "die (\"--userns-block-fd requires --unshare-user\");"
    },
    {
        "line": 70,
        "fullcodeline": "die (\"--userns-block-fd requires --info-fd\");"
    },
    {
        "line": 75,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 84,
        "fullcodeline": "stat (\"/proc/self/ns/user\", &sbuf) == 0)"
    },
    {
        "line": 86,
        "fullcodeline": "bool disabled = FALSE;"
    },
    {
        "line": 115,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 120,
        "fullcodeline": "opt_sandbox_uid = real_uid;"
    },
    {
        "line": 122,
        "fullcodeline": "opt_sandbox_gid = real_gid;"
    },
    {
        "line": 125,
        "fullcodeline": "die (\"Specifying --uid requires --unshare-user\");"
    },
    {
        "line": 128,
        "fullcodeline": "die (\"Specifying --gid requires --unshare-user\");"
    },
    {
        "line": 131,
        "fullcodeline": "die (\"Specifying --hostname requires --unshare-uts\");"
    },
    {
        "line": 134,
        "fullcodeline": "die (\"Specifying --as-pid-1 requires --unshare-pid\");"
    },
    {
        "line": 137,
        "fullcodeline": "die (\"Specifying --as-pid-1 and --lock-file is not permitted\");"
    },
    {
        "line": 143,
        "fullcodeline": "die_with_error (\"Can't open /proc\");"
    },
    {
        "line": 150,
        "fullcodeline": "free (base_path);"
    },
    {
        "line": 151,
        "fullcodeline": "base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);"
    },
    {
        "line": 160,
        "fullcodeline": "event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);"
    },
    {
        "line": 170,
        "fullcodeline": "clone_flags |= CLONE_NEWUSER;"
    },
    {
        "line": 172,
        "fullcodeline": "clone_flags |= CLONE_NEWPID;"
    },
    {
        "line": 174,
        "fullcodeline": "clone_flags |= CLONE_NEWNET;"
    },
    {
        "line": 176,
        "fullcodeline": "clone_flags |= CLONE_NEWIPC;"
    },
    {
        "line": 178,
        "fullcodeline": "clone_flags |= CLONE_NEWUTS;"
    },
    {
        "line": 188,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 196,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 202,
        "fullcodeline": "ret = pipe2 (setup_finished_pipe, O_CLOEXEC);"
    },
    {
        "line": 218,
        "fullcodeline": "die_with_error (\"Creating new namespace failed\");"
    },
    {
        "line": 246,
        "fullcodeline": "drop_privs (FALSE);"
    },
    {
        "line": 249,
        "fullcodeline": "handle_die_with_parent ();"
    },
    {
        "line": 271,
        "fullcodeline": "val = 1;"
    },
    {
        "line": 272,
        "fullcodeline": "res = write (child_wait_fd, &val, 8);"
    },
    {
        "line": 274,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 294,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 297,
        "fullcodeline": "close (opt_json_status_fd);"
    },
    {
        "line": 310,
        "fullcodeline": "loopback_setup (); /* Will exit if unsuccessful */"
    },
    {
        "line": 329,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 343,
        "fullcodeline": "die_with_error (\"Failed to make / slave\");"
    },
    {
        "line": 347,
        "fullcodeline": "die_with_error (\"Failed to mount tmpfs\");"
    },
    {
        "line": 354,
        "fullcodeline": "die_with_error (\"chdir base_path\");"
    },
    {
        "line": 362,
        "fullcodeline": "die_with_error (\"Creating newroot failed\");"
    },
    {
        "line": 365,
        "fullcodeline": "die_with_error (\"setting up newroot bind\");"
    },
    {
        "line": 368,
        "fullcodeline": "die_with_error (\"Creating oldroot failed\");"
    },
    {
        "line": 371,
        "fullcodeline": "die_with_error (\"pivot_root\");"
    },
    {
        "line": 374,
        "fullcodeline": "die_with_error (\"chdir / (base path)\");"
    },
    {
        "line": 379,
        "fullcodeline": "int privsep_sockets[2];"
    },
    {
        "line": 384,
        "fullcodeline": "child = fork ();"
    },
    {
        "line": 430,
        "fullcodeline": "die_with_error (\"Failed to make old root rprivate\");"
    },
    {
        "line": 433,
        "fullcodeline": "die_with_error (\"unmount old root\");"
    },
    {
        "line": 442,
        "fullcodeline": "if (oldrootfd < 0)"
    },
    {
        "line": 444,
        "fullcodeline": "if (chdir (\"/newroot\") != 0)"
    },
    {
        "line": 456,
        "fullcodeline": "if (pivot_root (\".\", \".\") != 0)"
    },
    {
        "line": 458,
        "fullcodeline": "if (fchdir (oldrootfd) < 0)"
    },
    {
        "line": 460,
        "fullcodeline": "if (umount2 (\".\", MNT_DETACH) < 0)"
    },
    {
        "line": 462,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 468,
        "fullcodeline": "opt_userns_block_fd == -1)"
    },
    {
        "line": 477,
        "fullcodeline": "write_uid_gid_map (opt_sandbox_uid, ns_uid,"
    },
    {
        "line": 487,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 488,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));"
    },
    {
        "line": 489,
        "fullcodeline": "close (opt_block_fd);"
    },
    {
        "line": 494,
        "fullcodeline": "seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);"
    },
    {
        "line": 501,
        "fullcodeline": "seccomp_prog.len = seccomp_len / 8;"
    },
    {
        "line": 502,
        "fullcodeline": "seccomp_prog.filter = (struct sock_filter *) seccomp_data;"
    },
    {
        "line": 504,
        "fullcodeline": "close (opt_seccomp_fd);"
    },
    {
        "line": 514,
        "fullcodeline": "new_cwd = opt_chdir_path;"
    },
    {
        "line": 533,
        "fullcodeline": "setsid () == (pid_t) -1)"
    },
    {
        "line": 534,
        "fullcodeline": "die_with_error (\"setsid\");"
    },
    {
        "line": 537,
        "fullcodeline": "die_with_error (\"label_exec %s\", argv[0]);"
    },
    {
        "line": 549,
        "fullcodeline": "pid = fork ();"
    },
    {
        "line": 580,
        "fullcodeline": "close (proc_fd);"
    },
    {
        "line": 597,
        "fullcodeline": "set_ambient_capabilities ();"
    },
    {
        "line": 602,
        "fullcodeline": "prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)"
    },
    {
        "line": 603,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_SECCOMP)\");"
    },
    {
        "line": 607,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 608,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 624,
        "fullcodeline": "die_with_error (\"execvp %s\", argv[0]);"
    },
    {
        "line": 89,
        "fullcodeline": "if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)"
    },
    {
        "line": 98,
        "fullcodeline": "if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)"
    },
    {
        "line": 110,
        "fullcodeline": "if (!disabled)"
    },
    {
        "line": 152,
        "fullcodeline": "if (ensure_dir (base_path, 0755))"
    },
    {
        "line": 161,
        "fullcodeline": "if (event_fd == -1)"
    },
    {
        "line": 181,
        "fullcodeline": "if (stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 191,
        "fullcodeline": "if (!stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 203,
        "fullcodeline": "if (ret == -1)"
    },
    {
        "line": 228,
        "fullcodeline": "if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)"
    },
    {
        "line": 251,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 257,
        "fullcodeline": "if (opt_json_status_fd != -1)"
    },
    {
        "line": 263,
        "fullcodeline": "if (opt_userns_block_fd != -1)"
    },
    {
        "line": 276,
        "fullcodeline": "return monitor_child (event_fd, pid, setup_finished_pipe[0]);"
    },
    {
        "line": 331,
        "fullcodeline": "-1, TRUE, FALSE);"
    },
    {
        "line": 381,
        "fullcodeline": "if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)"
    },
    {
        "line": 385,
        "fullcodeline": "if (child == -1)"
    },
    {
        "line": 388,
        "fullcodeline": "if (child == 0)"
    },
    {
        "line": 423,
        "fullcodeline": "setup_newroot (opt_unshare_pid, -1);"
    },
    {
        "line": 443,
        "fullcodeline": "die_with_error (\"can't open /\");"
    },
    {
        "line": 445,
        "fullcodeline": "die_with_error (\"chdir /newroot\");"
    },
    {
        "line": 457,
        "fullcodeline": "die_with_error (\"pivot_root(/newroot)\");"
    },
    {
        "line": 459,
        "fullcodeline": "die_with_error (\"fchdir to oldroot\");"
    },
    {
        "line": 461,
        "fullcodeline": "die_with_error (\"umount old root\");"
    },
    {
        "line": 463,
        "fullcodeline": "die_with_error (\"chdir /\");"
    },
    {
        "line": 467,
        "fullcodeline": "(ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&"
    },
    {
        "line": 474,
        "fullcodeline": "if (unshare (CLONE_NEWUSER))"
    },
    {
        "line": 479,
        "fullcodeline": "-1, FALSE, FALSE);"
    },
    {
        "line": 495,
        "fullcodeline": "if (seccomp_data == NULL)"
    },
    {
        "line": 498,
        "fullcodeline": "if (seccomp_len % 8 != 0)"
    },
    {
        "line": 512,
        "fullcodeline": "if (chdir (opt_chdir_path))"
    },
    {
        "line": 550,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 553,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 586,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 615,
        "fullcodeline": "if (setup_finished_pipe[1] != -1)"
    },
    {
        "line": 91,
        "fullcodeline": "cleanup_free char *enable = NULL;"
    },
    {
        "line": 92,
        "fullcodeline": "enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");"
    },
    {
        "line": 100,
        "fullcodeline": "cleanup_free char *max_user_ns = NULL;"
    },
    {
        "line": 101,
        "fullcodeline": "max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");"
    },
    {
        "line": 111,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 153,
        "fullcodeline": "die_with_error (\"Creating root mountpoint failed\");"
    },
    {
        "line": 162,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 192,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 204,
        "fullcodeline": "die_with_error (\"pipe2()\");"
    },
    {
        "line": 238,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 253,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);"
    },
    {
        "line": 254,
        "fullcodeline": "dump_info (opt_info_fd, output, TRUE);"
    },
    {
        "line": 255,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 259,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);"
    },
    {
        "line": 260,
        "fullcodeline": "dump_info (opt_json_status_fd, output, TRUE);"
    },
    {
        "line": 265,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 266,
        "fullcodeline": "(void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));"
    },
    {
        "line": 267,
        "fullcodeline": "close (opt_userns_block_fd);"
    },
    {
        "line": 325,
        "fullcodeline": "ns_uid = 0;"
    },
    {
        "line": 326,
        "fullcodeline": "ns_gid = 0;"
    },
    {
        "line": 382,
        "fullcodeline": "die_with_error (\"Can't create privsep socket\");"
    },
    {
        "line": 386,
        "fullcodeline": "die_with_error (\"Can't fork unprivileged helper\");"
    },
    {
        "line": 391,
        "fullcodeline": "drop_privs (FALSE);"
    },
    {
        "line": 392,
        "fullcodeline": "close (privsep_sockets[0]);"
    },
    {
        "line": 393,
        "fullcodeline": "setup_newroot (opt_unshare_pid, privsep_sockets[1]);"
    },
    {
        "line": 394,
        "fullcodeline": "exit (0);"
    },
    {
        "line": 475,
        "fullcodeline": "die_with_error (\"unshare user ns\");"
    },
    {
        "line": 496,
        "fullcodeline": "die_with_error (\"Can't read seccomp data\");"
    },
    {
        "line": 499,
        "fullcodeline": "die (\"Invalid seccomp data, must be multiple of 8\");"
    },
    {
        "line": 513,
        "fullcodeline": "die_with_error (\"Can't chdir to %s\", opt_chdir_path);"
    },
    {
        "line": 516,
        "fullcodeline": "else if (chdir (old_cwd) == 0)"
    },
    {
        "line": 551,
        "fullcodeline": "die_with_error (\"Can't fork for pid 1\");"
    },
    {
        "line": 555,
        "fullcodeline": "drop_all_caps (FALSE);"
    },
    {
        "line": 587,
        "fullcodeline": "close (opt_sync_fd);"
    },
    {
        "line": 617,
        "fullcodeline": "int saved_errno = errno;"
    },
    {
        "line": 618,
        "fullcodeline": "char data = 0;"
    },
    {
        "line": 619,
        "fullcodeline": "res = write_to_fd (setup_finished_pipe[1], &data, 1);"
    },
    {
        "line": 620,
        "fullcodeline": "errno = saved_errno;"
    },
    {
        "line": 93,
        "fullcodeline": "if (enable != NULL && enable[0] == 'N')"
    },
    {
        "line": 102,
        "fullcodeline": "if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)"
    },
    {
        "line": 183,
        "fullcodeline": "if (errno == ENOENT)"
    },
    {
        "line": 212,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 399,
        "fullcodeline": "uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */"
    },
    {
        "line": 402,
        "fullcodeline": "cleanup_fd int unpriv_socket = -1;"
    },
    {
        "line": 404,
        "fullcodeline": "unpriv_socket = privsep_sockets[0];"
    },
    {
        "line": 405,
        "fullcodeline": "close (privsep_sockets[1]);"
    },
    {
        "line": 417,
        "fullcodeline": "waitpid (child, &status, 0);"
    },
    {
        "line": 519,
        "fullcodeline": "new_cwd = old_cwd;"
    },
    {
        "line": 563,
        "fullcodeline": "int dont_close[3];"
    },
    {
        "line": 564,
        "fullcodeline": "int j = 0;"
    },
    {
        "line": 569,
        "fullcodeline": "dont_close[j++] = -1;"
    },
    {
        "line": 570,
        "fullcodeline": "fdwalk (proc_fd, close_extra_fds, dont_close);"
    },
    {
        "line": 573,
        "fullcodeline": "return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);"
    },
    {
        "line": 94,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 103,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 184,
        "fullcodeline": "die (\"Cannot create new cgroup namespace because the kernel does not support it\");"
    },
    {
        "line": 213,
        "fullcodeline": "die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");"
    },
    {
        "line": 415,
        "fullcodeline": "while (op != PRIV_SEP_OP_DONE);"
    },
    {
        "line": 524,
        "fullcodeline": "const char *home = getenv (\"HOME\");"
    },
    {
        "line": 565,
        "fullcodeline": "if (event_fd != -1)"
    },
    {
        "line": 567,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 186,
        "fullcodeline": "die_with_error (\"stat on /proc/self/ns/cgroup failed\");"
    },
    {
        "line": 409,
        "fullcodeline": "op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),"
    },
    {
        "line": 411,
        "fullcodeline": "privileged_op (-1, op, flags, arg1, arg2);"
    },
    {
        "line": 525,
        "fullcodeline": "if (home != NULL &&"
    },
    {
        "line": 566,
        "fullcodeline": "dont_close[j++] = event_fd;"
    },
    {
        "line": 568,
        "fullcodeline": "dont_close[j++] = opt_sync_fd;"
    },
    {
        "line": 214,
        "fullcodeline": "else if (errno == EPERM && !is_privileged)"
    },
    {
        "line": 412,
        "fullcodeline": "if (write (unpriv_socket, buffer, 1) != 1)"
    },
    {
        "line": 526,
        "fullcodeline": "chdir (home) == 0)"
    },
    {
        "line": 527,
        "fullcodeline": "new_cwd = home;"
    },
    {
        "line": 215,
        "fullcodeline": "die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");"
    },
    {
        "line": 413,
        "fullcodeline": "die (\"Can't write to op_socket\");"
    }
]