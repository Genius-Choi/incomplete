[
    {
        "line": 3,
        "fullcodeline": "struct userfaultfd_ctx *ctx = file->private_data;"
    },
    {
        "line": 4,
        "fullcodeline": "struct mm_struct *mm = ctx->mm;"
    },
    {
        "line": 7,
        "fullcodeline": "struct userfaultfd_wake_range range = { .len = 0, };"
    },
    {
        "line": 10,
        "fullcodeline": "WRITE_ONCE(ctx->released, true);"
    },
    {
        "line": 23,
        "fullcodeline": "down_write(&mm->mmap_sem);"
    },
    {
        "line": 26,
        "fullcodeline": "prev = NULL;"
    },
    {
        "line": 49,
        "fullcodeline": "up_write(&mm->mmap_sem);"
    },
    {
        "line": 50,
        "fullcodeline": "mmput(mm);"
    },
    {
        "line": 57,
        "fullcodeline": "spin_lock(&ctx->fault_pending_wqh.lock);"
    },
    {
        "line": 58,
        "fullcodeline": "__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);"
    },
    {
        "line": 59,
        "fullcodeline": "__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);"
    },
    {
        "line": 60,
        "fullcodeline": "spin_unlock(&ctx->fault_pending_wqh.lock);"
    },
    {
        "line": 63,
        "fullcodeline": "wake_up_all(&ctx->event_wqh);"
    },
    {
        "line": 65,
        "fullcodeline": "wake_up_poll(&ctx->fd_wqh, EPOLLHUP);"
    },
    {
        "line": 66,
        "fullcodeline": "userfaultfd_ctx_put(ctx);"
    },
    {
        "line": 12,
        "fullcodeline": "if (!mmget_not_zero(mm))"
    },
    {
        "line": 24,
        "fullcodeline": "if (!mmget_still_valid(mm))"
    },
    {
        "line": 27,
        "fullcodeline": "for (vma = mm->mmap; vma; vma = vma->vm_next) {"
    },
    {
        "line": 28,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 29,
        "fullcodeline": "BUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^"
    },
    {
        "line": 35,
        "fullcodeline": "new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);"
    },
    {
        "line": 36,
        "fullcodeline": "prev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,"
    },
    {
        "line": 45,
        "fullcodeline": "vma->vm_flags = new_flags;"
    },
    {
        "line": 46,
        "fullcodeline": "vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;"
    },
    {
        "line": 31,
        "fullcodeline": "if (vma->vm_userfaultfd_ctx.ctx != ctx) {"
    },
    {
        "line": 30,
        "fullcodeline": "!!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));"
    },
    {
        "line": 32,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 39,
        "fullcodeline": "vma_policy(vma),"
    },
    {
        "line": 42,
        "fullcodeline": "vma = prev;"
    },
    {
        "line": 44,
        "fullcodeline": "prev = vma;"
    }
]