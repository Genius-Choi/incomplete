[
    {
        "line": 4,
        "fullcodeline": "struct mm_struct *mm = ctx->mm;"
    },
    {
        "line": 13,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 17,
        "fullcodeline": "ret = validate_range(mm, uffdio_unregister.start,"
    },
    {
        "line": 22,
        "fullcodeline": "start = uffdio_unregister.start;"
    },
    {
        "line": 23,
        "fullcodeline": "end = start + uffdio_unregister.len;"
    },
    {
        "line": 25,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 29,
        "fullcodeline": "down_write(&mm->mmap_sem);"
    },
    {
        "line": 32,
        "fullcodeline": "vma = find_vma_prev(mm, start, &prev);"
    },
    {
        "line": 37,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 55,
        "fullcodeline": "found = false;"
    },
    {
        "line": 56,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 75,
        "fullcodeline": "BUG_ON(!found);"
    },
    {
        "line": 80,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 146,
        "fullcodeline": "up_write(&mm->mmap_sem);"
    },
    {
        "line": 147,
        "fullcodeline": "mmput(mm);"
    },
    {
        "line": 14,
        "fullcodeline": "if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))"
    },
    {
        "line": 26,
        "fullcodeline": "if (!mmget_not_zero(mm))"
    },
    {
        "line": 30,
        "fullcodeline": "if (!mmget_still_valid(mm))"
    },
    {
        "line": 33,
        "fullcodeline": "if (!vma)"
    },
    {
        "line": 38,
        "fullcodeline": "if (vma->vm_start >= end)"
    },
    {
        "line": 45,
        "fullcodeline": "if (is_vm_hugetlb_page(vma)) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (vma->vm_start < start)"
    },
    {
        "line": 144,
        "fullcodeline": "} while (vma && vma->vm_start < end);"
    },
    {
        "line": 46,
        "fullcodeline": "unsigned long vma_hpagesize = vma_kernel_pagesize(vma);"
    },
    {
        "line": 58,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 60,
        "fullcodeline": "BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^"
    },
    {
        "line": 73,
        "fullcodeline": "found = true;"
    },
    {
        "line": 78,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 82,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 84,
        "fullcodeline": "BUG_ON(!vma_can_userfault(vma));"
    },
    {
        "line": 93,
        "fullcodeline": "WARN_ON(!(vma->vm_flags & VM_MAYWRITE));"
    },
    {
        "line": 97,
        "fullcodeline": "vma_end = min(end, vma->vm_end);"
    },
    {
        "line": 112,
        "fullcodeline": "new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);"
    },
    {
        "line": 113,
        "fullcodeline": "prev = vma_merge(mm, prev, start, vma_end, new_flags,"
    },
    {
        "line": 137,
        "fullcodeline": "vma->vm_flags = new_flags;"
    },
    {
        "line": 138,
        "fullcodeline": "vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;"
    },
    {
        "line": 141,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 142,
        "fullcodeline": "start = vma->vm_end;"
    },
    {
        "line": 48,
        "fullcodeline": "if (start & (vma_hpagesize - 1))"
    },
    {
        "line": 70,
        "fullcodeline": "if (!vma_can_userfault(cur))"
    },
    {
        "line": 95,
        "fullcodeline": "if (vma->vm_start > start)"
    },
    {
        "line": 99,
        "fullcodeline": "if (userfaultfd_missing(vma)) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (vma->vm_start < start) {"
    },
    {
        "line": 126,
        "fullcodeline": "if (vma->vm_end > end) {"
    },
    {
        "line": 61,
        "fullcodeline": "!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));"
    },
    {
        "line": 96,
        "fullcodeline": "start = vma->vm_start;"
    },
    {
        "line": 107,
        "fullcodeline": "range.start = start;"
    },
    {
        "line": 108,
        "fullcodeline": "range.len = vma_end - start;"
    },
    {
        "line": 109,
        "fullcodeline": "wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);"
    },
    {
        "line": 115,
        "fullcodeline": "vma_policy(vma),"
    },
    {
        "line": 118,
        "fullcodeline": "vma = prev;"
    },
    {
        "line": 122,
        "fullcodeline": "ret = split_vma(mm, vma, start, 1);"
    },
    {
        "line": 127,
        "fullcodeline": "ret = split_vma(mm, vma, end, 0);"
    }
]