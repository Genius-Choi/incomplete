[
    {
        "line": 4,
        "fullcodeline": "struct mm_struct *mm = ctx->mm;"
    },
    {
        "line": 13,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 17,
        "fullcodeline": "ret = validate_range(mm, uffdio_unregister.start,"
    },
    {
        "line": 22,
        "fullcodeline": "start = uffdio_unregister.start;"
    },
    {
        "line": 23,
        "fullcodeline": "end = start + uffdio_unregister.len;"
    },
    {
        "line": 25,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 29,
        "fullcodeline": "down_write(&mm->mmap_sem);"
    },
    {
        "line": 30,
        "fullcodeline": "vma = find_vma_prev(mm, start, &prev);"
    },
    {
        "line": 35,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 53,
        "fullcodeline": "found = false;"
    },
    {
        "line": 54,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 73,
        "fullcodeline": "BUG_ON(!found);"
    },
    {
        "line": 78,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "up_write(&mm->mmap_sem);"
    },
    {
        "line": 145,
        "fullcodeline": "mmput(mm);"
    },
    {
        "line": 14,
        "fullcodeline": "if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))"
    },
    {
        "line": 26,
        "fullcodeline": "if (!mmget_not_zero(mm))"
    },
    {
        "line": 31,
        "fullcodeline": "if (!vma)"
    },
    {
        "line": 36,
        "fullcodeline": "if (vma->vm_start >= end)"
    },
    {
        "line": 43,
        "fullcodeline": "if (is_vm_hugetlb_page(vma)) {"
    },
    {
        "line": 55,
        "fullcodeline": "for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (vma->vm_start < start)"
    },
    {
        "line": 142,
        "fullcodeline": "} while (vma && vma->vm_start < end);"
    },
    {
        "line": 44,
        "fullcodeline": "unsigned long vma_hpagesize = vma_kernel_pagesize(vma);"
    },
    {
        "line": 56,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 58,
        "fullcodeline": "BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^"
    },
    {
        "line": 71,
        "fullcodeline": "found = true;"
    },
    {
        "line": 76,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 80,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 82,
        "fullcodeline": "BUG_ON(!vma_can_userfault(vma));"
    },
    {
        "line": 91,
        "fullcodeline": "WARN_ON(!(vma->vm_flags & VM_MAYWRITE));"
    },
    {
        "line": 95,
        "fullcodeline": "vma_end = min(end, vma->vm_end);"
    },
    {
        "line": 110,
        "fullcodeline": "new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);"
    },
    {
        "line": 111,
        "fullcodeline": "prev = vma_merge(mm, prev, start, vma_end, new_flags,"
    },
    {
        "line": 135,
        "fullcodeline": "vma->vm_flags = new_flags;"
    },
    {
        "line": 136,
        "fullcodeline": "vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;"
    },
    {
        "line": 139,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 140,
        "fullcodeline": "start = vma->vm_end;"
    },
    {
        "line": 46,
        "fullcodeline": "if (start & (vma_hpagesize - 1))"
    },
    {
        "line": 68,
        "fullcodeline": "if (!vma_can_userfault(cur))"
    },
    {
        "line": 93,
        "fullcodeline": "if (vma->vm_start > start)"
    },
    {
        "line": 97,
        "fullcodeline": "if (userfaultfd_missing(vma)) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (vma->vm_start < start) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (vma->vm_end > end) {"
    },
    {
        "line": 59,
        "fullcodeline": "!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));"
    },
    {
        "line": 94,
        "fullcodeline": "start = vma->vm_start;"
    },
    {
        "line": 105,
        "fullcodeline": "range.start = start;"
    },
    {
        "line": 106,
        "fullcodeline": "range.len = vma_end - start;"
    },
    {
        "line": 107,
        "fullcodeline": "wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);"
    },
    {
        "line": 113,
        "fullcodeline": "vma_policy(vma),"
    },
    {
        "line": 116,
        "fullcodeline": "vma = prev;"
    },
    {
        "line": 120,
        "fullcodeline": "ret = split_vma(mm, vma, start, 1);"
    },
    {
        "line": 125,
        "fullcodeline": "ret = split_vma(mm, vma, end, 0);"
    }
]