[
    {
        "line": 2,
        "fullcodeline": "int stacksize = r_config_get_i (core->config, \"esil.stack.depth\");"
    },
    {
        "line": 3,
        "fullcodeline": "bool iotrap = r_config_get_i (core->config, \"esil.iotrap\");"
    },
    {
        "line": 4,
        "fullcodeline": "bool romem = r_config_get_i (core->config, \"esil.romem\");"
    },
    {
        "line": 5,
        "fullcodeline": "bool stats = r_config_get_i (core->config, \"esil.stats\");"
    },
    {
        "line": 6,
        "fullcodeline": "bool be = core->print->big_endian;"
    },
    {
        "line": 7,
        "fullcodeline": "bool use_color = core->print->flags & R_PRINT_FLAGS_COLOR;"
    },
    {
        "line": 8,
        "fullcodeline": "core->parser->relsub = r_config_get_i (core->config, \"asm.relsub\");"
    },
    {
        "line": 10,
        "fullcodeline": "const char *color = \"\";"
    },
    {
        "line": 14,
        "fullcodeline": "RAnalEsil *esil = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "RAnalOp op = {0};"
    },
    {
        "line": 18,
        "fullcodeline": "bool isFirst = true;"
    },
    {
        "line": 19,
        "fullcodeline": "unsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");"
    },
    {
        "line": 20,
        "fullcodeline": "int totalsize = 0;"
    },
    {
        "line": 322,
        "fullcodeline": "if (fmt == 'j') {"
    },
    {
        "line": 24,
        "fullcodeline": "color = core->cons->pal.label;"
    },
    {
        "line": 32,
        "fullcodeline": "esil = r_anal_esil_new (stacksize, iotrap, addrsize);"
    },
    {
        "line": 36,
        "fullcodeline": "r_anal_esil_to_reil_setup (esil, core->anal, romem, stats);"
    },
    {
        "line": 37,
        "fullcodeline": "r_anal_esil_set_pc (esil, core->offset);"
    },
    {
        "line": 40,
        "fullcodeline": "for (i = idx = ret = 0; idx < len && (!nops || (nops && i < nops)); i++, idx += ret) {"
    },
    {
        "line": 41,
        "fullcodeline": "addr = core->offset + idx;"
    },
    {
        "line": 43,
        "fullcodeline": "hint = r_anal_hint_get (core->anal, addr);"
    },
    {
        "line": 44,
        "fullcodeline": "r_asm_set_pc (core->assembler, addr);"
    },
    {
        "line": 46,
        "fullcodeline": "ret = r_anal_op (core->anal, &op, core->offset + idx, buf + idx, len - idx, R_ANAL_OP_MASK_ESIL);"
    },
    {
        "line": 47,
        "fullcodeline": "esilstr = R_STRBUF_SAFEGET (&op.esil);"
    },
    {
        "line": 48,
        "fullcodeline": "opexstr = R_STRBUF_SAFEGET (&op.opex);"
    },
    {
        "line": 49,
        "fullcodeline": "char *mnem = strdup (r_asm_op_get_asm (&asmop));"
    },
    {
        "line": 50,
        "fullcodeline": "char *sp = strchr (mnem, ' ');"
    },
    {
        "line": 72,
        "fullcodeline": "size = (hint && hint->size)? hint->size: op.size;"
    },
    {
        "line": 319,
        "fullcodeline": "r_anal_op_fini (&op);"
    },
    {
        "line": 33,
        "fullcodeline": "if (!esil) {"
    },
    {
        "line": 45,
        "fullcodeline": "(void)r_asm_disassemble (core->assembler, &asmop, buf + idx, len - idx);"
    },
    {
        "line": 73,
        "fullcodeline": "if (fmt == 'd') {"
    },
    {
        "line": 52,
        "fullcodeline": "*sp = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "if (ret < 1 && fmt != 'd') {"
    },
    {
        "line": 74,
        "fullcodeline": "char *opname = strdup (r_asm_op_get_asm (&asmop));"
    },
    {
        "line": 54,
        "fullcodeline": "char *arg = strdup (sp + 1);"
    },
    {
        "line": 60,
        "fullcodeline": "mnem = arg;"
    },
    {
        "line": 65,
        "fullcodeline": "for (i = idx, j = 0; i < core->blocksize && j < 3; ++i, ++j) {"
    },
    {
        "line": 76,
        "fullcodeline": "r_str_split (opname, ' ');"
    },
    {
        "line": 77,
        "fullcodeline": "char *d = r_asm_describe (core->assembler, opname);"
    },
    {
        "line": 86,
        "fullcodeline": "} else if (fmt == 'e') {"
    },
    {
        "line": 55,
        "fullcodeline": "char *sp = strchr (arg, ' ');"
    },
    {
        "line": 78,
        "fullcodeline": "if (d && *d) {"
    },
    {
        "line": 79,
        "fullcodeline": "r_cons_printf (\"%s: %s\\n\", opname, d);"
    },
    {
        "line": 94,
        "fullcodeline": "} else if (fmt == 's') {"
    },
    {
        "line": 95,
        "fullcodeline": "totalsize += op.size;"
    },
    {
        "line": 96,
        "fullcodeline": "} else if (fmt == 'r') {"
    },
    {
        "line": 103,
        "fullcodeline": "r_anal_esil_parse (esil, esilstr);"
    },
    {
        "line": 104,
        "fullcodeline": "r_anal_esil_dumpstack (esil);"
    },
    {
        "line": 105,
        "fullcodeline": "r_anal_esil_stack_free (esil);"
    },
    {
        "line": 107,
        "fullcodeline": "} else if (fmt == 'j') {"
    },
    {
        "line": 136,
        "fullcodeline": "r_cons_printf (\"\\\"mnemonic\\\":\\\"%s\\\",\", mnem);"
    },
    {
        "line": 142,
        "fullcodeline": "r_cons_printf (\"\\\"id\\\":%d,\", op.id);"
    },
    {
        "line": 190,
        "fullcodeline": "r_cons_printf (\"\\\"cycles\\\":%d,\", op.cycles);"
    },
    {
        "line": 194,
        "fullcodeline": "r_cons_printf (\"\\\"delay\\\":%d,\", op.delay);"
    },
    {
        "line": 113,
        "fullcodeline": "r_cons_printf (\"{\\\"opcode\\\":\\\"%s\\\",\", r_asm_op_get_asm (&asmop));"
    },
    {
        "line": 117,
        "fullcodeline": "r_parse_varsub (core->parser, NULL,"
    },
    {
        "line": 128,
        "fullcodeline": "char *p = strdup (strsub);"
    },
    {
        "line": 137,
        "fullcodeline": "if (hint && hint->opcode) {"
    },
    {
        "line": 140,
        "fullcodeline": "r_cons_printf (\"\\\"sign\\\":%s,\", r_str_bool (op.sign));"
    },
    {
        "line": 143,
        "fullcodeline": "if (opexstr && *opexstr) {"
    },
    {
        "line": 148,
        "fullcodeline": "for (j = 0; j < size; j++) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (op.val != UT64_MAX) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (op.ptr != UT64_MAX) {"
    },
    {
        "line": 160,
        "fullcodeline": "r_anal_optype_to_string (op.type));"
    },
    {
        "line": 170,
        "fullcodeline": "if (hint && hint->esil) {"
    },
    {
        "line": 175,
        "fullcodeline": "if (hint && hint->jump != UT64_MAX) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (op.jump != UT64_MAX) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (hint && hint->fail != UT64_MAX) {"
    },
    {
        "line": 184,
        "fullcodeline": "if (op.refptr != -1) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (op.fail != UT64_MAX) {"
    },
    {
        "line": 196,
        "fullcodeline": "const char *p = r_anal_stackop_tostring (op.stackop);"
    },
    {
        "line": 204,
        "fullcodeline": "const char *arg = (op.type & R_ANAL_OP_TYPE_COND)"
    },
    {
        "line": 210,
        "fullcodeline": "r_cons_printf (\"\\\"family\\\":\\\"%s\\\"}\", r_anal_op_family_to_string (op.family));"
    },
    {
        "line": 222,
        "fullcodeline": "printline (\"mnemonic\", \"%s\\n\", mnem);"
    },
    {
        "line": 235,
        "fullcodeline": "printline (\"id\", \"%d\\n\", op.id);"
    },
    {
        "line": 242,
        "fullcodeline": "printline (\"bytes\", NULL, 0);"
    },
    {
        "line": 253,
        "fullcodeline": "printline (\"size\", \"%d\\n\", size);"
    },
    {
        "line": 256,
        "fullcodeline": "printline (\"cycles\", \"%d\\n\", op.cycles);"
    },
    {
        "line": 109,
        "fullcodeline": "isFirst = false;"
    },
    {
        "line": 115,
        "fullcodeline": "char strsub[128] = { 0 };"
    },
    {
        "line": 119,
        "fullcodeline": "asmop.size, r_asm_op_get_asm (&asmop),"
    },
    {
        "line": 122,
        "fullcodeline": "ut64 killme = UT64_MAX;"
    },
    {
        "line": 138,
        "fullcodeline": "r_cons_printf (\"\\\"ophint\\\":\\\"%s\\\",\", hint->opcode);"
    },
    {
        "line": 149,
        "fullcodeline": "r_cons_printf (\"%02x\", buf[j + idx]);"
    },
    {
        "line": 162,
        "fullcodeline": "r_cons_printf (\"\\\"reg\\\": \\\"%s\\\",\", op.reg);"
    },
    {
        "line": 165,
        "fullcodeline": "r_cons_printf (\"\\\"ireg\\\": \\\"%s\\\",\", op.ireg);"
    },
    {
        "line": 168,
        "fullcodeline": "r_cons_printf (\"\\\"scale\\\":%d,\", op.scale);"
    },
    {
        "line": 171,
        "fullcodeline": "r_cons_printf (\"\\\"esil\\\": \\\"%s\\\",\", hint->esil);"
    },
    {
        "line": 176,
        "fullcodeline": "op.jump = hint->jump;"
    },
    {
        "line": 182,
        "fullcodeline": "op.fail = hint->fail;"
    },
    {
        "line": 185,
        "fullcodeline": "r_cons_printf (\"\\\"refptr\\\":%d,\", op.refptr);"
    },
    {
        "line": 192,
        "fullcodeline": "r_cons_printf (\"\\\"failcycles\\\":%d,\", op.failcycles);"
    },
    {
        "line": 201,
        "fullcodeline": "r_cons_printf (\"\\\"stackptr\\\":%d,\", op.stackptr);"
    },
    {
        "line": 221,
        "fullcodeline": "printline (\"opcode\", \"%s\\n\", r_asm_op_get_asm (&asmop));"
    },
    {
        "line": 243,
        "fullcodeline": "for (j = 0; j < size; j++) {"
    },
    {
        "line": 247,
        "fullcodeline": "if (op.val != UT64_MAX)"
    },
    {
        "line": 249,
        "fullcodeline": "if (op.ptr != UT64_MAX)"
    },
    {
        "line": 251,
        "fullcodeline": "if (op.refptr != -1)"
    },
    {
        "line": 254,
        "fullcodeline": "printline (\"sign\", \"%s\\n\", r_str_bool (op.sign));"
    },
    {
        "line": 255,
        "fullcodeline": "printline (\"type\", \"%s\\n\", r_anal_optype_to_string (op.type));"
    },
    {
        "line": 261,
        "fullcodeline": "const char *t2 = r_anal_optype_to_string (op.type2);"
    },
    {
        "line": 275,
        "fullcodeline": "if (hint && hint->esil) {"
    },
    {
        "line": 280,
        "fullcodeline": "if (hint && hint->jump != UT64_MAX) {"
    },
    {
        "line": 283,
        "fullcodeline": "if (op.jump != UT64_MAX) {"
    },
    {
        "line": 286,
        "fullcodeline": "if (op.direction != 0) {"
    },
    {
        "line": 293,
        "fullcodeline": "if (hint && hint->fail != UT64_MAX) {"
    },
    {
        "line": 296,
        "fullcodeline": "if (op.fail != UT64_MAX) {"
    },
    {
        "line": 302,
        "fullcodeline": "printline (\"stack\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));"
    },
    {
        "line": 304,
        "fullcodeline": "const char *arg = (op.type & R_ANAL_OP_TYPE_COND)?  r_anal_cond_tostring (op.cond): NULL;"
    },
    {
        "line": 309,
        "fullcodeline": "printline (\"family\", \"%s\\n\", r_anal_op_family_to_string (op.family));"
    },
    {
        "line": 310,
        "fullcodeline": "printline (\"stackop\", \"%s\\n\", r_anal_stackop_tostring (op.stackop));"
    },
    {
        "line": 123,
        "fullcodeline": "if (r_io_read_i (core->io, op.ptr, &killme, op.refptr, be)) {"
    },
    {
        "line": 130,
        "fullcodeline": "r_parse_filter (core->parser, addr, core->flags, p,"
    },
    {
        "line": 197,
        "fullcodeline": "if (p && *p && strcmp (p, \"null\"))"
    },
    {
        "line": 205,
        "fullcodeline": "? r_anal_cond_tostring (op.cond): NULL;"
    },
    {
        "line": 244,
        "fullcodeline": "r_cons_printf (\"%02x\", buf[j + idx]);"
    },
    {
        "line": 258,
        "fullcodeline": "printline (\"failcycles\", \"%d\\n\", op.failcycles);"
    },
    {
        "line": 262,
        "fullcodeline": "if (t2 && strcmp (t2, \"null\")) {"
    },
    {
        "line": 267,
        "fullcodeline": "printline (\"reg\", \"%s\\n\", op.reg);"
    },
    {
        "line": 270,
        "fullcodeline": "printline (\"ireg\", \"%s\\n\", op.ireg);"
    },
    {
        "line": 273,
        "fullcodeline": "printline (\"scale\", \"%d\\n\", op.scale);"
    },
    {
        "line": 276,
        "fullcodeline": "printline (\"esil\", \"%s\\n\", hint->esil);"
    },
    {
        "line": 281,
        "fullcodeline": "op.jump = hint->jump;"
    },
    {
        "line": 287,
        "fullcodeline": "const char * dir = op.direction == 1 ? \"read\""
    },
    {
        "line": 291,
        "fullcodeline": "printline (\"direction\", \"%s\\n\", dir);"
    },
    {
        "line": 294,
        "fullcodeline": "op.fail = hint->fail;"
    },
    {
        "line": 300,
        "fullcodeline": "printline (\"delay\", \"%d\\n\", op.delay);"
    },
    {
        "line": 124,
        "fullcodeline": "core->parser->relsub_addr = killme;"
    },
    {
        "line": 225,
        "fullcodeline": "printline (\"ophint\", \"%s\\n\", hint->opcode);"
    },
    {
        "line": 252,
        "fullcodeline": "printline (\"refptr\", \"%d\\n\", op.refptr);"
    },
    {
        "line": 288,
        "fullcodeline": ": op.direction == 2 ? \"write\""
    },
    {
        "line": 289,
        "fullcodeline": ": op.direction == 4 ? \"exec\""
    },
    {
        "line": 290,
        "fullcodeline": ": op.direction == 8 ? \"ref\": \"none\";"
    }
]