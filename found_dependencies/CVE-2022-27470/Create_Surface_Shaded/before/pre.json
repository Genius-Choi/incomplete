[
    {
        "line": 3,
        "fullcodeline": "const int alignment = Get_Alignement() - 1;"
    },
    {
        "line": 6,
        "fullcodeline": "Uint8 bg_alpha = bg.a;"
    },
    {
        "line": 14,
        "fullcodeline": "Sint64 pitch = width + alignment;"
    },
    {
        "line": 15,
        "fullcodeline": "pitch += alignment;"
    },
    {
        "line": 16,
        "fullcodeline": "pitch &= ~alignment;"
    },
    {
        "line": 17,
        "fullcodeline": "size = height * pitch + sizeof (void *) + alignment;"
    },
    {
        "line": 23,
        "fullcodeline": "ptr = SDL_malloc((size_t)size);"
    },
    {
        "line": 29,
        "fullcodeline": "pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);"
    },
    {
        "line": 32,
        "fullcodeline": "textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);"
    },
    {
        "line": 39,
        "fullcodeline": "textbuf->flags &= ~SDL_PREALLOC;"
    },
    {
        "line": 40,
        "fullcodeline": "textbuf->flags |= SDL_SIMD_ALIGNED;"
    },
    {
        "line": 18,
        "fullcodeline": "if (size < 0 || size > SDL_MAX_SINT32) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (ptr == NULL) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (textbuf == NULL) {"
    },
    {
        "line": 43,
        "fullcodeline": "SDL_memset(pixels, 0, height * pitch);"
    },
    {
        "line": 46,
        "fullcodeline": "*color = NUM_GRAYS - 1;"
    },
    {
        "line": 61,
        "fullcodeline": "int rdiff  = fg.r - bg.r;"
    },
    {
        "line": 62,
        "fullcodeline": "int gdiff  = fg.g - bg.g;"
    },
    {
        "line": 63,
        "fullcodeline": "int bdiff  = fg.b - bg.b;"
    },
    {
        "line": 64,
        "fullcodeline": "int adiff  = fg.a - bg.a;"
    },
    {
        "line": 65,
        "fullcodeline": "int sign_r = (rdiff >= 0) ? 1 : 255;"
    },
    {
        "line": 66,
        "fullcodeline": "int sign_g = (gdiff >= 0) ? 1 : 255;"
    },
    {
        "line": 67,
        "fullcodeline": "int sign_b = (bdiff >= 0) ? 1 : 255;"
    },
    {
        "line": 68,
        "fullcodeline": "int sign_a = (adiff >= 0) ? 1 : 255;"
    },
    {
        "line": 49,
        "fullcodeline": "if (fg.a != SDL_ALPHA_OPAQUE || bg.a != SDL_ALPHA_OPAQUE) {"
    },
    {
        "line": 50,
        "fullcodeline": "SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);"
    },
    {
        "line": 71,
        "fullcodeline": "for (i = 0; i < NUM_GRAYS; ++i) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (bg.a == SDL_ALPHA_OPAQUE) {"
    },
    {
        "line": 73,
        "fullcodeline": "int tmp_r = i * rdiff;"
    },
    {
        "line": 74,
        "fullcodeline": "int tmp_g = i * gdiff;"
    },
    {
        "line": 75,
        "fullcodeline": "int tmp_b = i * bdiff;"
    },
    {
        "line": 76,
        "fullcodeline": "int tmp_a = i * adiff;"
    },
    {
        "line": 54,
        "fullcodeline": "bg.a = 0;"
    },
    {
        "line": 77,
        "fullcodeline": "palette->colors[i].r = (Uint8)(bg.r + DIVIDE_BY_255_SIGNED(tmp_r, sign_r));"
    },
    {
        "line": 78,
        "fullcodeline": "palette->colors[i].g = (Uint8)(bg.g + DIVIDE_BY_255_SIGNED(tmp_g, sign_g));"
    },
    {
        "line": 79,
        "fullcodeline": "palette->colors[i].b = (Uint8)(bg.b + DIVIDE_BY_255_SIGNED(tmp_b, sign_b));"
    },
    {
        "line": 80,
        "fullcodeline": "palette->colors[i].a = (Uint8)(bg.a + DIVIDE_BY_255_SIGNED(tmp_a, sign_a));"
    }
]