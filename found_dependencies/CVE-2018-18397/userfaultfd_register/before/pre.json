[
    {
        "line": 4,
        "fullcodeline": "struct mm_struct *mm = ctx->mm;"
    },
    {
        "line": 16,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 21,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 27,
        "fullcodeline": "vm_flags = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "ret = validate_range(mm, uffdio_register.range.start,"
    },
    {
        "line": 45,
        "fullcodeline": "start = uffdio_register.range.start;"
    },
    {
        "line": 46,
        "fullcodeline": "end = start + uffdio_register.range.len;"
    },
    {
        "line": 48,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 52,
        "fullcodeline": "down_write(&mm->mmap_sem);"
    },
    {
        "line": 53,
        "fullcodeline": "vma = find_vma_prev(mm, start, &prev);"
    },
    {
        "line": 58,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 76,
        "fullcodeline": "found = false;"
    },
    {
        "line": 77,
        "fullcodeline": "basic_ioctls = false;"
    },
    {
        "line": 121,
        "fullcodeline": "BUG_ON(!found);"
    },
    {
        "line": 126,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 180,
        "fullcodeline": "up_write(&mm->mmap_sem);"
    },
    {
        "line": 181,
        "fullcodeline": "mmput(mm);"
    },
    {
        "line": 17,
        "fullcodeline": "if (copy_from_user(&uffdio_register, user_uffdio_register,"
    },
    {
        "line": 22,
        "fullcodeline": "if (!uffdio_register.mode)"
    },
    {
        "line": 24,
        "fullcodeline": "if (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|"
    },
    {
        "line": 28,
        "fullcodeline": "if (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)"
    },
    {
        "line": 30,
        "fullcodeline": "if (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (!mmget_not_zero(mm))"
    },
    {
        "line": 54,
        "fullcodeline": "if (!vma)"
    },
    {
        "line": 59,
        "fullcodeline": "if (vma->vm_start >= end)"
    },
    {
        "line": 66,
        "fullcodeline": "if (is_vm_hugetlb_page(vma)) {"
    },
    {
        "line": 78,
        "fullcodeline": "for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (vma->vm_start < start)"
    },
    {
        "line": 178,
        "fullcodeline": "} while (vma && vma->vm_start < end);"
    },
    {
        "line": 182,
        "fullcodeline": "if (!ret) {"
    },
    {
        "line": 29,
        "fullcodeline": "vm_flags |= VM_UFFD_MISSING;"
    },
    {
        "line": 31,
        "fullcodeline": "vm_flags |= VM_UFFD_WP;"
    },
    {
        "line": 36,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 67,
        "fullcodeline": "unsigned long vma_hpagesize = vma_kernel_pagesize(vma);"
    },
    {
        "line": 79,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 81,
        "fullcodeline": "BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^"
    },
    {
        "line": 85,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 108,
        "fullcodeline": "ret = -EBUSY;"
    },
    {
        "line": 119,
        "fullcodeline": "found = true;"
    },
    {
        "line": 124,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 128,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 130,
        "fullcodeline": "BUG_ON(!vma_can_userfault(vma));"
    },
    {
        "line": 131,
        "fullcodeline": "BUG_ON(vma->vm_userfaultfd_ctx.ctx &&"
    },
    {
        "line": 144,
        "fullcodeline": "vma_end = min(end, vma->vm_end);"
    },
    {
        "line": 146,
        "fullcodeline": "new_flags = (vma->vm_flags & ~vm_flags) | vm_flags;"
    },
    {
        "line": 147,
        "fullcodeline": "prev = vma_merge(mm, prev, start, vma_end, new_flags,"
    },
    {
        "line": 171,
        "fullcodeline": "vma->vm_flags = new_flags;"
    },
    {
        "line": 172,
        "fullcodeline": "vma->vm_userfaultfd_ctx.ctx = ctx;"
    },
    {
        "line": 175,
        "fullcodeline": "prev = vma;"
    },
    {
        "line": 176,
        "fullcodeline": "start = vma->vm_end;"
    },
    {
        "line": 177,
        "fullcodeline": "vma = vma->vm_next;"
    },
    {
        "line": 18,
        "fullcodeline": "sizeof(uffdio_register)-sizeof(__u64)))"
    },
    {
        "line": 69,
        "fullcodeline": "if (start & (vma_hpagesize - 1))"
    },
    {
        "line": 86,
        "fullcodeline": "if (!vma_can_userfault(cur))"
    },
    {
        "line": 92,
        "fullcodeline": "if (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&"
    },
    {
        "line": 109,
        "fullcodeline": "if (cur->vm_userfaultfd_ctx.ctx &&"
    },
    {
        "line": 116,
        "fullcodeline": "if (is_vm_hugetlb_page(cur))"
    },
    {
        "line": 138,
        "fullcodeline": "if (vma->vm_userfaultfd_ctx.ctx == ctx &&"
    },
    {
        "line": 142,
        "fullcodeline": "if (vma->vm_start > start)"
    },
    {
        "line": 155,
        "fullcodeline": "if (vma->vm_start < start) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (vma->vm_end > end) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :"
    },
    {
        "line": 82,
        "fullcodeline": "!!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));"
    },
    {
        "line": 93,
        "fullcodeline": "end > cur->vm_start) {"
    },
    {
        "line": 94,
        "fullcodeline": "unsigned long vma_hpagesize = vma_kernel_pagesize(cur);"
    },
    {
        "line": 96,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 110,
        "fullcodeline": "cur->vm_userfaultfd_ctx.ctx != ctx)"
    },
    {
        "line": 117,
        "fullcodeline": "basic_ioctls = true;"
    },
    {
        "line": 132,
        "fullcodeline": "vma->vm_userfaultfd_ctx.ctx != ctx);"
    },
    {
        "line": 139,
        "fullcodeline": "(vma->vm_flags & vm_flags) == vm_flags)"
    },
    {
        "line": 143,
        "fullcodeline": "start = vma->vm_start;"
    },
    {
        "line": 149,
        "fullcodeline": "vma_policy(vma),"
    },
    {
        "line": 150,
        "fullcodeline": "((struct vm_userfaultfd_ctx){ ctx }));"
    },
    {
        "line": 152,
        "fullcodeline": "vma = prev;"
    },
    {
        "line": 156,
        "fullcodeline": "ret = split_vma(mm, vma, start, 1);"
    },
    {
        "line": 161,
        "fullcodeline": "ret = split_vma(mm, vma, end, 0);"
    },
    {
        "line": 191,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 98,
        "fullcodeline": "if (end & (vma_hpagesize - 1))"
    }
]