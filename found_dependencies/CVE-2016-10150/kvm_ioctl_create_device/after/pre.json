[
    {
        "line": 4,
        "fullcodeline": "struct kvm_device_ops *ops = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "bool test = cd->flags & KVM_CREATE_DEVICE_TEST;"
    },
    {
        "line": 12,
        "fullcodeline": "ops = kvm_device_ops_table[cd->type];"
    },
    {
        "line": 19,
        "fullcodeline": "dev = kzalloc(sizeof(*dev), GFP_KERNEL);"
    },
    {
        "line": 23,
        "fullcodeline": "dev->ops = ops;"
    },
    {
        "line": 24,
        "fullcodeline": "dev->kvm = kvm;"
    },
    {
        "line": 26,
        "fullcodeline": "mutex_lock(&kvm->lock);"
    },
    {
        "line": 27,
        "fullcodeline": "ret = ops->create(dev, cd->type);"
    },
    {
        "line": 33,
        "fullcodeline": "list_add(&dev->vm_node, &kvm->devices);"
    },
    {
        "line": 34,
        "fullcodeline": "mutex_unlock(&kvm->lock);"
    },
    {
        "line": 39,
        "fullcodeline": "ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);"
    },
    {
        "line": 9,
        "fullcodeline": "if (cd->type >= ARRAY_SIZE(kvm_device_ops_table))"
    },
    {
        "line": 13,
        "fullcodeline": "if (ops == NULL)"
    },
    {
        "line": 20,
        "fullcodeline": "if (!dev)"
    },
    {
        "line": 28,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "ops->init(dev);"
    },
    {
        "line": 41,
        "fullcodeline": "mutex_lock(&kvm->lock);"
    },
    {
        "line": 10,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 14,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 21,
        "fullcodeline": "return -ENOMEM;"
    }
]