[
    {
        "line": 4,
        "fullcodeline": "const ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);"
    },
    {
        "line": 8,
        "fullcodeline": "if (cu->hdr.length > debug_str_len) {"
    },
    {
        "line": 12,
        "fullcodeline": "while (buf && buf < buf_end && buf >= obuf) {"
    },
    {
        "line": 16,
        "fullcodeline": "buf = r_uleb128 (buf, buf_end - buf, &abbr_code);"
    },
    {
        "line": 21,
        "fullcodeline": "r_bin_dwarf_init_die (&cu->dies[cu->length]);"
    },
    {
        "line": 29,
        "fullcodeline": "cu->dies[cu->length].abbrev_code = abbr_code;"
    },
    {
        "line": 31,
        "fullcodeline": "abbr_code += offset;"
    },
    {
        "line": 60,
        "fullcodeline": "cu->length++;"
    },
    {
        "line": 13,
        "fullcodeline": "if (cu->length && cu->capacity == cu->length) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (abbr_code > da->length || !buf) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (!abbr_code) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (da->capacity < abbr_code) {"
    },
    {
        "line": 37,
        "fullcodeline": "for (i = 0; i < da->decls[abbr_code - 1].length; i++) {"
    },
    {
        "line": 14,
        "fullcodeline": "r_bin_dwarf_expand_cu (cu);"
    },
    {
        "line": 23,
        "fullcodeline": "cu->dies[cu->length].abbrev_code = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "cu->length++;"
    },
    {
        "line": 25,
        "fullcodeline": "buf++;"
    },
    {
        "line": 45,
        "fullcodeline": "memset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));"
    },
    {
        "line": 46,
        "fullcodeline": "buf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,"
    },
    {
        "line": 58,
        "fullcodeline": "cu->dies[cu->length].length++;"
    },
    {
        "line": 30,
        "fullcodeline": "cu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;"
    },
    {
        "line": 38,
        "fullcodeline": "if (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {"
    },
    {
        "line": 39,
        "fullcodeline": "r_bin_dwarf_expand_die (&cu->dies[cu->length]);"
    },
    {
        "line": 42,
        "fullcodeline": "eprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");"
    },
    {
        "line": 52,
        "fullcodeline": "if (name > 1024) { // solve some null derefs"
    },
    {
        "line": 53,
        "fullcodeline": "sdb_set (s, \"DW_AT_comp_dir\", name, 0);"
    },
    {
        "line": 55,
        "fullcodeline": "eprintf (\"Invalid string pointer at %p\\n\", name);"
    },
    {
        "line": 47,
        "fullcodeline": "&da->decls[abbr_code - 1].specs[i],"
    }
]