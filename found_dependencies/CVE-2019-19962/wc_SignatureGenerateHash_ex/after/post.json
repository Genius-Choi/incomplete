[
    {
        "line": 10,
        "fullcodeline": "(void)rng;"
    },
    {
        "line": 26,
        "fullcodeline": "ret = wc_HashGetDigestSize(hash_type);"
    },
    {
        "line": 31,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "if (hash_data == NULL || hash_len <= 0 ||"
    },
    {
        "line": 20,
        "fullcodeline": "if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (ret == 0 && verify) {"
    },
    {
        "line": 15,
        "fullcodeline": "key == NULL || key_len <= 0) {"
    },
    {
        "line": 21,
        "fullcodeline": "WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");"
    },
    {
        "line": 28,
        "fullcodeline": "WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");"
    },
    {
        "line": 48,
        "fullcodeline": "ret = SIG_TYPE_E;"
    },
    {
        "line": 76,
        "fullcodeline": "ret = BAD_FUNC_ARG;"
    },
    {
        "line": 81,
        "fullcodeline": "ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,"
    },
    {
        "line": 64,
        "fullcodeline": "} while (ret == WC_PENDING_E);"
    },
    {
        "line": 65,
        "fullcodeline": "if (ret >= 0) {"
    },
    {
        "line": 14,
        "fullcodeline": "sig == NULL || sig_len == NULL || *sig_len <= 0 ||"
    },
    {
        "line": 66,
        "fullcodeline": "*sig_len = ret;"
    },
    {
        "line": 67,
        "fullcodeline": "ret = 0; /* Success */"
    },
    {
        "line": 61,
        "fullcodeline": "if (ret >= 0)"
    },
    {
        "line": 62,
        "fullcodeline": "ret = wc_RsaSSL_Sign(hash_data, hash_len, sig, *sig_len,"
    },
    {
        "line": 63,
        "fullcodeline": "(RsaKey*)key, rng);"
    }
]