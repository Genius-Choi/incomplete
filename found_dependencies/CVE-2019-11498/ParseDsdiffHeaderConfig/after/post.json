[
    {
        "line": 8,
        "fullcodeline": "infilesize = DoGetFileSize (infile);"
    },
    {
        "line": 9,
        "fullcodeline": "memcpy (&dff_file_header, fourcc, 4);"
    },
    {
        "line": 23,
        "fullcodeline": "WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);"
    },
    {
        "line": 11,
        "fullcodeline": "if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||"
    },
    {
        "line": 25,
        "fullcodeline": "if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&"
    },
    {
        "line": 245,
        "fullcodeline": "if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {"
    },
    {
        "line": 12,
        "fullcodeline": "bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {"
    },
    {
        "line": 13,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 26,
        "fullcodeline": "dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {"
    },
    {
        "line": 27,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);"
    },
    {
        "line": 32,
        "fullcodeline": "error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);"
    },
    {
        "line": 51,
        "fullcodeline": "WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);"
    },
    {
        "line": 243,
        "fullcodeline": "error_line (\"setting configuration with %lld samples\", total_samples);"
    },
    {
        "line": 246,
        "fullcodeline": "error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 40,
        "fullcodeline": "if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||"
    },
    {
        "line": 56,
        "fullcodeline": "if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {"
    },
    {
        "line": 16,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 41,
        "fullcodeline": "bcount != sizeof (DFFChunkHeader)) {"
    },
    {
        "line": 42,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 54,
        "fullcodeline": "error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);"
    },
    {
        "line": 71,
        "fullcodeline": "WavpackBigEndianToNative (&version, \"L\");"
    },
    {
        "line": 17,
        "fullcodeline": "!WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {"
    },
    {
        "line": 18,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 59,
        "fullcodeline": "if (dff_chunk_header.ckDataSize != sizeof (version) ||"
    },
    {
        "line": 45,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 61,
        "fullcodeline": "bcount != sizeof (version)) {"
    },
    {
        "line": 62,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 74,
        "fullcodeline": "error_line (\"dsdiff file version = 0x%08x\", version);"
    },
    {
        "line": 76,
        "fullcodeline": "else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {"
    },
    {
        "line": 46,
        "fullcodeline": "!WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {"
    },
    {
        "line": 47,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 60,
        "fullcodeline": "!DoReadFile (infile, &version, sizeof (version), &bcount) ||"
    },
    {
        "line": 87,
        "fullcodeline": "prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);"
    },
    {
        "line": 200,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 65,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 79,
        "fullcodeline": "if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||"
    },
    {
        "line": 102,
        "fullcodeline": "if (!strncmp (prop_chunk, \"SND \", 4)) {"
    },
    {
        "line": 66,
        "fullcodeline": "!WavpackAddWrapper (wpc, &version, sizeof (version))) {"
    },
    {
        "line": 67,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 80,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 85,
        "fullcodeline": "error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);"
    },
    {
        "line": 90,
        "fullcodeline": "bcount != dff_chunk_header.ckDataSize) {"
    },
    {
        "line": 91,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 92,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 103,
        "fullcodeline": "char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;"
    },
    {
        "line": 104,
        "fullcodeline": "uint16_t numChannels = 0, chansSpecified, chanMask = 0;"
    },
    {
        "line": 105,
        "fullcodeline": "uint32_t sampleRate = 0;"
    },
    {
        "line": 190,
        "fullcodeline": "config->bits_per_sample = 8;"
    },
    {
        "line": 191,
        "fullcodeline": "config->bytes_per_sample = 1;"
    },
    {
        "line": 192,
        "fullcodeline": "config->num_channels = numChannels;"
    },
    {
        "line": 193,
        "fullcodeline": "config->sample_rate = sampleRate / 8;"
    },
    {
        "line": 194,
        "fullcodeline": "config->qmode |= QMODE_DSD_MSB_FIRST;"
    },
    {
        "line": 202,
        "fullcodeline": "else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {"
    },
    {
        "line": 107,
        "fullcodeline": "while (eptr - cptr >= sizeof (dff_chunk_header)) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {"
    },
    {
        "line": 209,
        "fullcodeline": "total_samples = dff_chunk_header.ckDataSize / config->num_channels;"
    },
    {
        "line": 95,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 108,
        "fullcodeline": "memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));"
    },
    {
        "line": 109,
        "fullcodeline": "cptr += sizeof (dff_chunk_header);"
    },
    {
        "line": 110,
        "fullcodeline": "WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);"
    },
    {
        "line": 183,
        "fullcodeline": "error_line (\"this DSDIFF file already has channel order information!\");"
    },
    {
        "line": 184,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 204,
        "fullcodeline": "if (!config->num_channels || !config->sample_rate) {"
    },
    {
        "line": 214,
        "fullcodeline": "int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);"
    },
    {
        "line": 222,
        "fullcodeline": "buff = malloc (bytes_to_copy);"
    },
    {
        "line": 238,
        "fullcodeline": "free (buff);"
    },
    {
        "line": 96,
        "fullcodeline": "!WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {"
    },
    {
        "line": 97,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 98,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 112,
        "fullcodeline": "if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {"
    },
    {
        "line": 197,
        "fullcodeline": "error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\","
    },
    {
        "line": 205,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 217,
        "fullcodeline": "if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {"
    },
    {
        "line": 229,
        "fullcodeline": "if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||"
    },
    {
        "line": 218,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 225,
        "fullcodeline": "error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\","
    },
    {
        "line": 231,
        "fullcodeline": "(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 233,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 234,
        "fullcodeline": "free (buff);"
    },
    {
        "line": 113,
        "fullcodeline": "if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {"
    },
    {
        "line": 176,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 177,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 188,
        "fullcodeline": "config->channel_mask = chanMask;"
    },
    {
        "line": 230,
        "fullcodeline": "bcount != bytes_to_copy ||"
    },
    {
        "line": 232,
        "fullcodeline": "!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {"
    },
    {
        "line": 114,
        "fullcodeline": "memcpy (&sampleRate, cptr, sizeof (sampleRate));"
    },
    {
        "line": 115,
        "fullcodeline": "WavpackBigEndianToNative (&sampleRate, \"L\");"
    },
    {
        "line": 116,
        "fullcodeline": "cptr += dff_chunk_header.ckDataSize;"
    },
    {
        "line": 119,
        "fullcodeline": "error_line (\"got sample rate of %u Hz\", sampleRate);"
    },
    {
        "line": 121,
        "fullcodeline": "else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {"
    },
    {
        "line": 122,
        "fullcodeline": "memcpy (&numChannels, cptr, sizeof (numChannels));"
    },
    {
        "line": 123,
        "fullcodeline": "WavpackBigEndianToNative (&numChannels, \"S\");"
    },
    {
        "line": 124,
        "fullcodeline": "cptr += sizeof (numChannels);"
    },
    {
        "line": 126,
        "fullcodeline": "chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;"
    },
    {
        "line": 128,
        "fullcodeline": "if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {"
    },
    {
        "line": 134,
        "fullcodeline": "while (chansSpecified--) {"
    },
    {
        "line": 129,
        "fullcodeline": "error_line (\"%s is not a valid .DFF file!\", infilename);"
    },
    {
        "line": 130,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 151,
        "fullcodeline": "cptr += 4;"
    },
    {
        "line": 155,
        "fullcodeline": "error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);"
    },
    {
        "line": 157,
        "fullcodeline": "else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))"
    },
    {
        "line": 165,
        "fullcodeline": "cptr += dff_chunk_header.ckDataSize;"
    },
    {
        "line": 136,
        "fullcodeline": "chanMask |= 0x1;"
    },
    {
        "line": 158,
        "fullcodeline": "if (strncmp (cptr, \"DSD \", 4)) {"
    },
    {
        "line": 172,
        "fullcodeline": "cptr += dff_chunk_header.ckDataSize;"
    },
    {
        "line": 159,
        "fullcodeline": "error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\","
    },
    {
        "line": 161,
        "fullcodeline": "free (prop_chunk);"
    },
    {
        "line": 137,
        "fullcodeline": "else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))"
    },
    {
        "line": 169,
        "fullcodeline": "error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],"
    },
    {
        "line": 138,
        "fullcodeline": "chanMask |= 0x2;"
    },
    {
        "line": 139,
        "fullcodeline": "else if (!strncmp (cptr, \"LS  \", 4))"
    },
    {
        "line": 140,
        "fullcodeline": "chanMask |= 0x10;"
    },
    {
        "line": 141,
        "fullcodeline": "else if (!strncmp (cptr, \"RS  \", 4))"
    },
    {
        "line": 142,
        "fullcodeline": "chanMask |= 0x20;"
    },
    {
        "line": 143,
        "fullcodeline": "else if (!strncmp (cptr, \"C   \", 4))"
    },
    {
        "line": 144,
        "fullcodeline": "chanMask |= 0x4;"
    },
    {
        "line": 145,
        "fullcodeline": "else if (!strncmp (cptr, \"LFE \", 4))"
    },
    {
        "line": 146,
        "fullcodeline": "chanMask |= 0x8;"
    },
    {
        "line": 149,
        "fullcodeline": "error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);"
    }
]