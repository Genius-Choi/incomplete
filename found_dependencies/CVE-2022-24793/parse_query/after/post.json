[
    {
        "line": 5,
        "fullcodeline": "const pj_uint8_t *p = start;"
    },
    {
        "line": 10,
        "fullcodeline": "status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);"
    },
    {
        "line": 15,
        "fullcodeline": "q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);"
    },
    {
        "line": 16,
        "fullcodeline": "q->name.slen = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "status = get_name(0, pkt, start, max, &q->name);"
    },
    {
        "line": 23,
        "fullcodeline": "p = (start + name_part_len);"
    },
    {
        "line": 30,
        "fullcodeline": "pj_memcpy(&q->type, p, 2);"
    },
    {
        "line": 31,
        "fullcodeline": "q->type = pj_ntohs(q->type);"
    },
    {
        "line": 32,
        "fullcodeline": "p += 2;"
    },
    {
        "line": 35,
        "fullcodeline": "pj_memcpy(&q->dnsclass, p, 2);"
    },
    {
        "line": 36,
        "fullcodeline": "q->dnsclass = pj_ntohs(q->dnsclass);"
    },
    {
        "line": 37,
        "fullcodeline": "p += 2;"
    },
    {
        "line": 39,
        "fullcodeline": "*parsed_len = (int)(p - start);"
    },
    {
        "line": 11,
        "fullcodeline": "if (status != PJ_SUCCESS)"
    },
    {
        "line": 20,
        "fullcodeline": "if (status != PJ_SUCCESS)"
    },
    {
        "line": 26,
        "fullcodeline": "if (p + 4 > max)"
    }
]