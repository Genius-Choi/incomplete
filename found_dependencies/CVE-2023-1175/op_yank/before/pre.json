[
    {
        "line": 9,
        "fullcodeline": "int\t\t\tyanktype = oap->motion_type;"
    },
    {
        "line": 10,
        "fullcodeline": "long\t\tyanklines = oap->line_count;"
    },
    {
        "line": 11,
        "fullcodeline": "linenr_T\t\tyankendlnum = oap->end.lnum;"
    },
    {
        "line": 38,
        "fullcodeline": "curr = y_current;"
    },
    {
        "line": 60,
        "fullcodeline": "y_current->y_size = yanklines;"
    },
    {
        "line": 61,
        "fullcodeline": "y_current->y_type = yanktype;   // set the yank register type"
    },
    {
        "line": 62,
        "fullcodeline": "y_current->y_width = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);"
    },
    {
        "line": 73,
        "fullcodeline": "y_idx = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "lnum = oap->start.lnum;"
    },
    {
        "line": 20,
        "fullcodeline": "if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))"
    },
    {
        "line": 25,
        "fullcodeline": "if (oap->regname == '_')\t    // black hole: nothing to do"
    },
    {
        "line": 40,
        "fullcodeline": "if (y_append && y_current->y_array != NULL)"
    },
    {
        "line": 64,
        "fullcodeline": "if (y_current->y_array == NULL)"
    },
    {
        "line": 86,
        "fullcodeline": "for ( ; lnum <= yankendlnum; lnum++, y_idx++)"
    },
    {
        "line": 174,
        "fullcodeline": "if (curr != y_current)\t// append the new block to the old block"
    },
    {
        "line": 22,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 36,
        "fullcodeline": "get_yank_register(oap->regname, TRUE);"
    },
    {
        "line": 41,
        "fullcodeline": "y_current = &newreg;"
    },
    {
        "line": 47,
        "fullcodeline": "if (       oap->motion_type == MCHAR"
    },
    {
        "line": 53,
        "fullcodeline": "&& yanklines > 1)"
    },
    {
        "line": 55,
        "fullcodeline": "yanktype = MLINE;"
    },
    {
        "line": 56,
        "fullcodeline": "--yankendlnum;"
    },
    {
        "line": 57,
        "fullcodeline": "--yanklines;"
    },
    {
        "line": 79,
        "fullcodeline": "y_current->y_type = MBLOCK;\t    // set the yank register type"
    },
    {
        "line": 80,
        "fullcodeline": "y_current->y_width = oap->end_vcol - oap->start_vcol;"
    },
    {
        "line": 182,
        "fullcodeline": "curr->y_array = new_ptr;"
    },
    {
        "line": 212,
        "fullcodeline": "curr->y_size = j;"
    },
    {
        "line": 251,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)"
    },
    {
        "line": 52,
        "fullcodeline": "&& oap->end.col == 0"
    },
    {
        "line": 177,
        "fullcodeline": "if (new_ptr == NULL)"
    },
    {
        "line": 179,
        "fullcodeline": "for (j = 0; j < curr->y_size; ++j)"
    },
    {
        "line": 180,
        "fullcodeline": "new_ptr[j] = curr->y_array[j];"
    },
    {
        "line": 187,
        "fullcodeline": "if (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK"
    },
    {
        "line": 210,
        "fullcodeline": "while (y_idx < y_current->y_size)"
    },
    {
        "line": 224,
        "fullcodeline": "if (yanklines > p_report)"
    },
    {
        "line": 51,
        "fullcodeline": "&& !oap->block_mode"
    },
    {
        "line": 82,
        "fullcodeline": "if (curwin->w_curswant == MAXCOL && y_current->y_width > 0)"
    },
    {
        "line": 83,
        "fullcodeline": "y_current->y_width--;"
    },
    {
        "line": 91,
        "fullcodeline": "block_prep(oap, &bd, lnum, FALSE);"
    },
    {
        "line": 188,
        "fullcodeline": "curr->y_type = MLINE;"
    },
    {
        "line": 192,
        "fullcodeline": "if (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)"
    },
    {
        "line": 194,
        "fullcodeline": "pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])"
    },
    {
        "line": 201,
        "fullcodeline": "STRCPY(pnew, curr->y_array[--j]);"
    },
    {
        "line": 202,
        "fullcodeline": "STRCAT(pnew, y_current->y_array[0]);"
    },
    {
        "line": 204,
        "fullcodeline": "vim_free(y_current->y_array[0]);"
    },
    {
        "line": 206,
        "fullcodeline": "y_idx = 1;"
    },
    {
        "line": 219,
        "fullcodeline": "if (yanktype == MCHAR"
    },
    {
        "line": 221,
        "fullcodeline": "&& yanklines == 1)"
    },
    {
        "line": 222,
        "fullcodeline": "yanklines = 0;"
    },
    {
        "line": 226,
        "fullcodeline": "char namebuf[100];"
    },
    {
        "line": 256,
        "fullcodeline": "if (yanktype == MLINE && !oap->block_mode)"
    },
    {
        "line": 50,
        "fullcodeline": "&& (!oap->is_VIsual || *p_sel == 'o')"
    },
    {
        "line": 92,
        "fullcodeline": "if (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)"
    },
    {
        "line": 97,
        "fullcodeline": "if ((y_current->y_array[y_idx] ="
    },
    {
        "line": 104,
        "fullcodeline": "colnr_T startcol = 0, endcol = MAXCOL;"
    },
    {
        "line": 105,
        "fullcodeline": "int\t    is_oneChar = FALSE;"
    },
    {
        "line": 108,
        "fullcodeline": "p = ml_get(lnum);"
    },
    {
        "line": 109,
        "fullcodeline": "bd.startspaces = 0;"
    },
    {
        "line": 110,
        "fullcodeline": "bd.endspaces = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "bd.textstart = p + startcol;"
    },
    {
        "line": 196,
        "fullcodeline": "if (pnew == NULL)"
    },
    {
        "line": 209,
        "fullcodeline": "y_idx = 0;"
    },
    {
        "line": 211,
        "fullcodeline": "curr->y_array[j++] = y_current->y_array[y_idx++];"
    },
    {
        "line": 220,
        "fullcodeline": "&& !oap->block_mode"
    },
    {
        "line": 228,
        "fullcodeline": "if (oap->regname == NUL)"
    },
    {
        "line": 49,
        "fullcodeline": "&& !oap->inclusive"
    },
    {
        "line": 112,
        "fullcodeline": "if (lnum == oap->start.lnum)"
    },
    {
        "line": 129,
        "fullcodeline": "if (lnum == oap->end.lnum)"
    },
    {
        "line": 159,
        "fullcodeline": "if (endcol == MAXCOL)"
    },
    {
        "line": 166,
        "fullcodeline": "if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)"
    },
    {
        "line": 198,
        "fullcodeline": "y_idx = y_current->y_size - 1;"
    },
    {
        "line": 205,
        "fullcodeline": "curr->y_array[j++] = pnew;"
    },
    {
        "line": 229,
        "fullcodeline": "*namebuf = NUL;"
    },
    {
        "line": 48,
        "fullcodeline": "&& oap->start.col == 0"
    },
    {
        "line": 98,
        "fullcodeline": "vim_strsave(ml_get(lnum))) == NULL)"
    },
    {
        "line": 114,
        "fullcodeline": "startcol = oap->start.col;"
    },
    {
        "line": 131,
        "fullcodeline": "endcol = oap->end.col;"
    },
    {
        "line": 160,
        "fullcodeline": "endcol = (colnr_T)STRLEN(p);"
    },
    {
        "line": 161,
        "fullcodeline": "if (startcol > endcol || is_oneChar)"
    },
    {
        "line": 162,
        "fullcodeline": "bd.textlen = 0;"
    },
    {
        "line": 231,
        "fullcodeline": "vim_snprintf(namebuf, sizeof(namebuf),"
    },
    {
        "line": 238,
        "fullcodeline": "smsg(NGETTEXT(\"block of %ld line yanked%s\","
    },
    {
        "line": 164,
        "fullcodeline": "bd.textlen = endcol - startcol + oap->inclusive;"
    },
    {
        "line": 195,
        "fullcodeline": "+ STRLEN(y_current->y_array[0]) + 1);"
    },
    {
        "line": 232,
        "fullcodeline": "_(\" into \\\"%c\"), oap->regname);"
    },
    {
        "line": 244,
        "fullcodeline": "smsg(NGETTEXT(\"%ld line yanked%s\","
    },
    {
        "line": 117,
        "fullcodeline": "getvcol(curwin, &oap->start, &cs, NULL, &ce);"
    },
    {
        "line": 134,
        "fullcodeline": "getvcol(curwin, &oap->end, &cs, NULL, &ce);"
    },
    {
        "line": 118,
        "fullcodeline": "if (ce != cs && oap->start.coladd > 0)"
    },
    {
        "line": 122,
        "fullcodeline": "bd.startspaces = (ce - cs + 1)"
    },
    {
        "line": 124,
        "fullcodeline": "startcol++;"
    },
    {
        "line": 135,
        "fullcodeline": "if (p[endcol] == NUL || (cs + oap->end.coladd < ce"
    },
    {
        "line": 139,
        "fullcodeline": "&& (*mb_head_off)(p, p + endcol) == 0))"
    },
    {
        "line": 141,
        "fullcodeline": "if (oap->start.lnum == oap->end.lnum"
    },
    {
        "line": 142,
        "fullcodeline": "&& oap->start.col == oap->end.col)"
    },
    {
        "line": 145,
        "fullcodeline": "is_oneChar = TRUE;"
    },
    {
        "line": 146,
        "fullcodeline": "bd.startspaces = oap->end.coladd"
    },
    {
        "line": 148,
        "fullcodeline": "endcol = startcol;"
    },
    {
        "line": 152,
        "fullcodeline": "bd.endspaces = oap->end.coladd"
    },
    {
        "line": 154,
        "fullcodeline": "endcol -= oap->inclusive;"
    }
]