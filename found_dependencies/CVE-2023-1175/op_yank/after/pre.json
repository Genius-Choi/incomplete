[
    {
        "line": 9,
        "fullcodeline": "int\t\t\tyanktype = oap->motion_type;"
    },
    {
        "line": 10,
        "fullcodeline": "long\t\tyanklines = oap->line_count;"
    },
    {
        "line": 11,
        "fullcodeline": "linenr_T\t\tyankendlnum = oap->end.lnum;"
    },
    {
        "line": 38,
        "fullcodeline": "curr = y_current;"
    },
    {
        "line": 60,
        "fullcodeline": "y_current->y_size = yanklines;"
    },
    {
        "line": 61,
        "fullcodeline": "y_current->y_type = yanktype;   // set the yank register type"
    },
    {
        "line": 62,
        "fullcodeline": "y_current->y_width = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);"
    },
    {
        "line": 73,
        "fullcodeline": "y_idx = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "lnum = oap->start.lnum;"
    },
    {
        "line": 20,
        "fullcodeline": "if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))"
    },
    {
        "line": 25,
        "fullcodeline": "if (oap->regname == '_')\t    // black hole: nothing to do"
    },
    {
        "line": 40,
        "fullcodeline": "if (y_append && y_current->y_array != NULL)"
    },
    {
        "line": 64,
        "fullcodeline": "if (y_current->y_array == NULL)"
    },
    {
        "line": 86,
        "fullcodeline": "for ( ; lnum <= yankendlnum; lnum++, y_idx++)"
    },
    {
        "line": 176,
        "fullcodeline": "if (curr != y_current)\t// append the new block to the old block"
    },
    {
        "line": 22,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 36,
        "fullcodeline": "get_yank_register(oap->regname, TRUE);"
    },
    {
        "line": 41,
        "fullcodeline": "y_current = &newreg;"
    },
    {
        "line": 47,
        "fullcodeline": "if (       oap->motion_type == MCHAR"
    },
    {
        "line": 53,
        "fullcodeline": "&& yanklines > 1)"
    },
    {
        "line": 55,
        "fullcodeline": "yanktype = MLINE;"
    },
    {
        "line": 56,
        "fullcodeline": "--yankendlnum;"
    },
    {
        "line": 57,
        "fullcodeline": "--yanklines;"
    },
    {
        "line": 79,
        "fullcodeline": "y_current->y_type = MBLOCK;\t    // set the yank register type"
    },
    {
        "line": 80,
        "fullcodeline": "y_current->y_width = oap->end_vcol - oap->start_vcol;"
    },
    {
        "line": 184,
        "fullcodeline": "curr->y_array = new_ptr;"
    },
    {
        "line": 214,
        "fullcodeline": "curr->y_size = j;"
    },
    {
        "line": 253,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)"
    },
    {
        "line": 52,
        "fullcodeline": "&& oap->end.col == 0"
    },
    {
        "line": 179,
        "fullcodeline": "if (new_ptr == NULL)"
    },
    {
        "line": 181,
        "fullcodeline": "for (j = 0; j < curr->y_size; ++j)"
    },
    {
        "line": 182,
        "fullcodeline": "new_ptr[j] = curr->y_array[j];"
    },
    {
        "line": 189,
        "fullcodeline": "if (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK"
    },
    {
        "line": 212,
        "fullcodeline": "while (y_idx < y_current->y_size)"
    },
    {
        "line": 226,
        "fullcodeline": "if (yanklines > p_report)"
    },
    {
        "line": 51,
        "fullcodeline": "&& !oap->block_mode"
    },
    {
        "line": 82,
        "fullcodeline": "if (curwin->w_curswant == MAXCOL && y_current->y_width > 0)"
    },
    {
        "line": 83,
        "fullcodeline": "y_current->y_width--;"
    },
    {
        "line": 91,
        "fullcodeline": "block_prep(oap, &bd, lnum, FALSE);"
    },
    {
        "line": 190,
        "fullcodeline": "curr->y_type = MLINE;"
    },
    {
        "line": 194,
        "fullcodeline": "if (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)"
    },
    {
        "line": 196,
        "fullcodeline": "pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])"
    },
    {
        "line": 203,
        "fullcodeline": "STRCPY(pnew, curr->y_array[--j]);"
    },
    {
        "line": 204,
        "fullcodeline": "STRCAT(pnew, y_current->y_array[0]);"
    },
    {
        "line": 206,
        "fullcodeline": "vim_free(y_current->y_array[0]);"
    },
    {
        "line": 208,
        "fullcodeline": "y_idx = 1;"
    },
    {
        "line": 221,
        "fullcodeline": "if (yanktype == MCHAR"
    },
    {
        "line": 223,
        "fullcodeline": "&& yanklines == 1)"
    },
    {
        "line": 224,
        "fullcodeline": "yanklines = 0;"
    },
    {
        "line": 228,
        "fullcodeline": "char namebuf[100];"
    },
    {
        "line": 258,
        "fullcodeline": "if (yanktype == MLINE && !oap->block_mode)"
    },
    {
        "line": 50,
        "fullcodeline": "&& (!oap->is_VIsual || *p_sel == 'o')"
    },
    {
        "line": 92,
        "fullcodeline": "if (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)"
    },
    {
        "line": 97,
        "fullcodeline": "if ((y_current->y_array[y_idx] ="
    },
    {
        "line": 104,
        "fullcodeline": "colnr_T startcol = 0, endcol = MAXCOL;"
    },
    {
        "line": 105,
        "fullcodeline": "int\t    is_oneChar = FALSE;"
    },
    {
        "line": 108,
        "fullcodeline": "p = ml_get(lnum);"
    },
    {
        "line": 109,
        "fullcodeline": "bd.startspaces = 0;"
    },
    {
        "line": 110,
        "fullcodeline": "bd.endspaces = 0;"
    },
    {
        "line": 167,
        "fullcodeline": "bd.textstart = p + startcol;"
    },
    {
        "line": 198,
        "fullcodeline": "if (pnew == NULL)"
    },
    {
        "line": 211,
        "fullcodeline": "y_idx = 0;"
    },
    {
        "line": 213,
        "fullcodeline": "curr->y_array[j++] = y_current->y_array[y_idx++];"
    },
    {
        "line": 222,
        "fullcodeline": "&& !oap->block_mode"
    },
    {
        "line": 230,
        "fullcodeline": "if (oap->regname == NUL)"
    },
    {
        "line": 49,
        "fullcodeline": "&& !oap->inclusive"
    },
    {
        "line": 112,
        "fullcodeline": "if (lnum == oap->start.lnum)"
    },
    {
        "line": 131,
        "fullcodeline": "if (lnum == oap->end.lnum)"
    },
    {
        "line": 161,
        "fullcodeline": "if (endcol == MAXCOL)"
    },
    {
        "line": 168,
        "fullcodeline": "if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)"
    },
    {
        "line": 200,
        "fullcodeline": "y_idx = y_current->y_size - 1;"
    },
    {
        "line": 207,
        "fullcodeline": "curr->y_array[j++] = pnew;"
    },
    {
        "line": 231,
        "fullcodeline": "*namebuf = NUL;"
    },
    {
        "line": 48,
        "fullcodeline": "&& oap->start.col == 0"
    },
    {
        "line": 98,
        "fullcodeline": "vim_strsave(ml_get(lnum))) == NULL)"
    },
    {
        "line": 114,
        "fullcodeline": "startcol = oap->start.col;"
    },
    {
        "line": 133,
        "fullcodeline": "endcol = oap->end.col;"
    },
    {
        "line": 162,
        "fullcodeline": "endcol = (colnr_T)STRLEN(p);"
    },
    {
        "line": 163,
        "fullcodeline": "if (startcol > endcol || is_oneChar)"
    },
    {
        "line": 164,
        "fullcodeline": "bd.textlen = 0;"
    },
    {
        "line": 233,
        "fullcodeline": "vim_snprintf(namebuf, sizeof(namebuf),"
    },
    {
        "line": 240,
        "fullcodeline": "smsg(NGETTEXT(\"block of %ld line yanked%s\","
    },
    {
        "line": 166,
        "fullcodeline": "bd.textlen = endcol - startcol + oap->inclusive;"
    },
    {
        "line": 197,
        "fullcodeline": "+ STRLEN(y_current->y_array[0]) + 1);"
    },
    {
        "line": 234,
        "fullcodeline": "_(\" into \\\"%c\"), oap->regname);"
    },
    {
        "line": 246,
        "fullcodeline": "smsg(NGETTEXT(\"%ld line yanked%s\","
    },
    {
        "line": 117,
        "fullcodeline": "getvcol(curwin, &oap->start, &cs, NULL, &ce);"
    },
    {
        "line": 136,
        "fullcodeline": "getvcol(curwin, &oap->end, &cs, NULL, &ce);"
    },
    {
        "line": 118,
        "fullcodeline": "if (ce != cs && oap->start.coladd > 0)"
    },
    {
        "line": 122,
        "fullcodeline": "bd.startspaces = (ce - cs + 1)"
    },
    {
        "line": 126,
        "fullcodeline": "startcol++;"
    },
    {
        "line": 137,
        "fullcodeline": "if (p[endcol] == NUL || (cs + oap->end.coladd < ce"
    },
    {
        "line": 124,
        "fullcodeline": "if (bd.startspaces < 0)"
    },
    {
        "line": 141,
        "fullcodeline": "&& (*mb_head_off)(p, p + endcol) == 0))"
    },
    {
        "line": 125,
        "fullcodeline": "bd.startspaces = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "if (oap->start.lnum == oap->end.lnum"
    },
    {
        "line": 144,
        "fullcodeline": "&& oap->start.col == oap->end.col)"
    },
    {
        "line": 147,
        "fullcodeline": "is_oneChar = TRUE;"
    },
    {
        "line": 148,
        "fullcodeline": "bd.startspaces = oap->end.coladd"
    },
    {
        "line": 150,
        "fullcodeline": "endcol = startcol;"
    },
    {
        "line": 154,
        "fullcodeline": "bd.endspaces = oap->end.coladd"
    },
    {
        "line": 156,
        "fullcodeline": "endcol -= oap->inclusive;"
    }
]