[
    {
        "line": 8,
        "fullcodeline": "char_u\t*cmdline_copy = NULL;\t// copy of cmd line"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command"
    },
    {
        "line": 10,
        "fullcodeline": "static int\trecursive = 0;\t\t// recursive depth"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tmsg_didout_before_start = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tcount = 0;\t\t// line number count"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tretval = OK;"
    },
    {
        "line": 38,
        "fullcodeline": "static int\tcall_depth = 0;\t\t// recursiveness"
    },
    {
        "line": 68,
        "fullcodeline": "++call_depth;"
    },
    {
        "line": 131,
        "fullcodeline": "did_emsg = FALSE;"
    },
    {
        "line": 147,
        "fullcodeline": "next_cmdline = cmdline;"
    },
    {
        "line": 574,
        "fullcodeline": "did_emsg_syntax = FALSE;"
    },
    {
        "line": 756,
        "fullcodeline": "if_level = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "if (call_depth >= 200"
    },
    {
        "line": 59,
        "fullcodeline": "emsg(_(e_command_too_recursive));"
    },
    {
        "line": 137,
        "fullcodeline": "if (!(flags & DOCMD_KEYTYPED)"
    },
    {
        "line": 138,
        "fullcodeline": "&& !getline_equal(fgetline, cookie, getexline))"
    },
    {
        "line": 139,
        "fullcodeline": "KeyTyped = FALSE;"
    },
    {
        "line": 298,
        "fullcodeline": "cmdline_copy = next_cmdline;"
    },
    {
        "line": 371,
        "fullcodeline": "++recursive;"
    },
    {
        "line": 372,
        "fullcodeline": "next_cmdline = do_one_cmd(&cmdline_copy, flags,"
    },
    {
        "line": 377,
        "fullcodeline": "--recursive;"
    },
    {
        "line": 547,
        "fullcodeline": "while (!((got_int"
    },
    {
        "line": 567,
        "fullcodeline": "&& (next_cmdline != NULL"
    },
    {
        "line": 155,
        "fullcodeline": "if (next_cmdline == NULL"
    },
    {
        "line": 247,
        "fullcodeline": "if (next_cmdline == NULL)"
    },
    {
        "line": 386,
        "fullcodeline": "if (next_cmdline == NULL)"
    },
    {
        "line": 557,
        "fullcodeline": "&& !(did_emsg"
    },
    {
        "line": 571,
        "fullcodeline": "|| (flags & DOCMD_REPEAT)));"
    },
    {
        "line": 728,
        "fullcodeline": "if (retval == FAIL"
    },
    {
        "line": 166,
        "fullcodeline": "did_emsg = FALSE;"
    },
    {
        "line": 272,
        "fullcodeline": "used_getline = TRUE;"
    },
    {
        "line": 343,
        "fullcodeline": "if (count++ == 0)"
    },
    {
        "line": 363,
        "fullcodeline": "if ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)"
    },
    {
        "line": 364,
        "fullcodeline": "msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);"
    },
    {
        "line": 388,
        "fullcodeline": "VIM_CLEAR(cmdline_copy);"
    },
    {
        "line": 253,
        "fullcodeline": "if (count == 1 && getline_equal(fgetline, cookie, getexline))"
    },
    {
        "line": 277,
        "fullcodeline": "if (flags & DOCMD_KEEPLINE)"
    },
    {
        "line": 394,
        "fullcodeline": "if (getline_equal(fgetline, cookie, getexline)"
    },
    {
        "line": 406,
        "fullcodeline": "STRMOVE(cmdline_copy, next_cmdline);"
    },
    {
        "line": 407,
        "fullcodeline": "next_cmdline = cmdline_copy;"
    },
    {
        "line": 565,
        "fullcodeline": "&& (getline_equal(fgetline, cookie, getexmodeline)"
    },
    {
        "line": 254,
        "fullcodeline": "msg_didout = TRUE;"
    },
    {
        "line": 255,
        "fullcodeline": "if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,"
    },
    {
        "line": 269,
        "fullcodeline": "retval = FAIL;"
    },
    {
        "line": 288,
        "fullcodeline": "else if (cmdline_copy == NULL)"
    },
    {
        "line": 351,
        "fullcodeline": "if (!(flags & DOCMD_NOWAIT) && !recursive)"
    },
    {
        "line": 353,
        "fullcodeline": "msg_didout_before_start = msg_didout;"
    },
    {
        "line": 357,
        "fullcodeline": "++no_wait_return;   // don't wait for return until finished"
    },
    {
        "line": 358,
        "fullcodeline": "++RedrawingDisabled;"
    },
    {
        "line": 395,
        "fullcodeline": "&& new_last_cmdline != NULL)"
    },
    {
        "line": 398,
        "fullcodeline": "last_cmdline = new_last_cmdline;"
    },
    {
        "line": 399,
        "fullcodeline": "new_last_cmdline = NULL;"
    },
    {
        "line": 566,
        "fullcodeline": "|| getline_equal(fgetline, cookie, getexline)))"
    },
    {
        "line": 280,
        "fullcodeline": "if (count == 0)"
    },
    {
        "line": 290,
        "fullcodeline": "next_cmdline = vim_strsave(next_cmdline);"
    },
    {
        "line": 267,
        "fullcodeline": "if (KeyTyped && !(flags & DOCMD_REPEAT))"
    },
    {
        "line": 281,
        "fullcodeline": "repeat_cmdline = vim_strsave(next_cmdline);"
    },
    {
        "line": 291,
        "fullcodeline": "if (next_cmdline == NULL)"
    },
    {
        "line": 261,
        "fullcodeline": ", in_vim9script() ? GETLINE_CONCAT_CONTBAR"
    },
    {
        "line": 283,
        "fullcodeline": "repeat_cmdline = NULL;"
    },
    {
        "line": 294,
        "fullcodeline": "retval = FAIL;"
    },
    {
        "line": 293,
        "fullcodeline": "emsg(_(e_out_of_memory));"
    }
]