[
    {
        "line": 2,
        "fullcodeline": "path.erase(std::remove_if(path.begin(), path.end(), [](char c)->bool {return c == '\"' || c == '*' || c == ':' || c == '<' || c == '>' || c == '?' || c == '|' || c < 32; }), path.end());"
    },
    {
        "line": 3,
        "fullcodeline": "std::vector<std::string> elems = split(path, \"/\\\\\");"
    },
    {
        "line": 4,
        "fullcodeline": "std::list<std::string> pathc;"
    },
    {
        "line": 19,
        "fullcodeline": "std::pair<size_t, bool> max_path = std::make_pair(0, false);"
    },
    {
        "line": 12,
        "fullcodeline": "while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();"
    },
    {
        "line": 13,
        "fullcodeline": "if (!pathc.empty() && pathc.back().size() > 255) {"
    },
    {
        "line": 14,
        "fullcodeline": "std::string s = pathc.back().substr(0, 255);"
    },
    {
        "line": 15,
        "fullcodeline": "pathc.pop_back();"
    },
    {
        "line": 16,
        "fullcodeline": "s = s.substr(0, s.find_last_not_of(' '));"
    },
    {
        "line": 17,
        "fullcodeline": "pathc.push_back(s);"
    },
    {
        "line": 21,
        "fullcodeline": "if (pathc.size() >= std::get<0>(m).size() && std::get<0>(m).size() > max_path.first && std::equal(std::get<0>(m).begin(), std::get<0>(m).end(), pathc.begin()))"
    },
    {
        "line": 6,
        "fullcodeline": "if (s == \"..\") { if (pathc.empty()) return false; else pathc.pop_back(); }"
    },
    {
        "line": 22,
        "fullcodeline": "max_path = std::make_pair(std::get<0>(m).size(), std::get<2>(m));"
    },
    {
        "line": 7,
        "fullcodeline": "else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {"
    },
    {
        "line": 8,
        "fullcodeline": "s = s.substr(s.find_first_not_of(' '), s.find_last_not_of(' ') - s.find_first_not_of(' ') + 1);"
    },
    {
        "line": 9,
        "fullcodeline": "pathc.push_back(s);"
    }
]