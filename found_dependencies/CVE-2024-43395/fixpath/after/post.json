[
    {
        "line": 2,
        "fullcodeline": "path.erase(std::remove_if(path.begin(), path.end(), [](char c)->bool {return c == '\"' || c == '*' || c == ':' || c == '<' || c == '>' || c == '?' || c == '|' || c < 32; }), path.end());"
    },
    {
        "line": 3,
        "fullcodeline": "std::vector<std::string> elems = split(path, \"/\\\\\");"
    },
    {
        "line": 4,
        "fullcodeline": "std::list<std::string> pathc;"
    },
    {
        "line": 15,
        "fullcodeline": "while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();"
    },
    {
        "line": 16,
        "fullcodeline": "if (!pathc.empty() && pathc.back().size() > 255) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (comp->isDebugger && addExt && pathc.size() == 1 && pathc.front() == \"bios.lua\")"
    },
    {
        "line": 102,
        "fullcodeline": "if (path_t::preferred_separator != (path_t::value_type)'/' && (!addExt || isVFSPath(ss))) {"
    },
    {
        "line": 17,
        "fullcodeline": "std::string s = pathc.back().substr(0, 255);"
    },
    {
        "line": 18,
        "fullcodeline": "pathc.pop_back();"
    },
    {
        "line": 19,
        "fullcodeline": "s = s.substr(0, s.find_last_not_of(' '));"
    },
    {
        "line": 20,
        "fullcodeline": "pathc.push_back(s);"
    },
    {
        "line": 31,
        "fullcodeline": "std::pair<size_t, std::vector<_path_t> > max_path = std::make_pair(0, std::vector<_path_t>(1, comp->dataDir));"
    },
    {
        "line": 32,
        "fullcodeline": "std::list<std::string> * mount_list = NULL;"
    },
    {
        "line": 103,
        "fullcodeline": "path_t::string_type str = ss.native();"
    },
    {
        "line": 104,
        "fullcodeline": "std::replace(str.begin(), str.end(), path_t::preferred_separator, (path_t::value_type)'/');"
    },
    {
        "line": 105,
        "fullcodeline": "ss = path_t(str);"
    },
    {
        "line": 6,
        "fullcodeline": "if (s == \"..\") {"
    },
    {
        "line": 26,
        "fullcodeline": "return getROMPath()/\"bios.lua\";"
    },
    {
        "line": 44,
        "fullcodeline": "for (size_t i = 0; i < max_path.first; i++) pathc.pop_front();"
    },
    {
        "line": 45,
        "fullcodeline": "if (isRoot != NULL) *isRoot = pathc.empty();"
    },
    {
        "line": 90,
        "fullcodeline": "if (mountPath != NULL) {"
    },
    {
        "line": 34,
        "fullcodeline": "std::list<std::string> &pathlist = std::get<0>(m);"
    },
    {
        "line": 47,
        "fullcodeline": "bool found = false;"
    },
    {
        "line": 101,
        "fullcodeline": "} else for (const std::string& s : pathc) ss /= s;"
    },
    {
        "line": 7,
        "fullcodeline": "if (pathc.empty() && addExt) return path_t();"
    },
    {
        "line": 35,
        "fullcodeline": "if (pathc.size() >= pathlist.size() && std::equal(pathlist.begin(), pathlist.end(), pathc.begin())) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (!found) return path_t();"
    },
    {
        "line": 91,
        "fullcodeline": "if (mount_list == NULL) *mountPath = \"hdd\";"
    },
    {
        "line": 10,
        "fullcodeline": "} else if (!s.empty() && s.find_first_not_of(' ') != std::string::npos && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {"
    },
    {
        "line": 49,
        "fullcodeline": "path_t sstmp = p;"
    },
    {
        "line": 51,
        "fullcodeline": "e.clear();"
    },
    {
        "line": 59,
        "fullcodeline": "} else if (pathc.size() > 1) {"
    },
    {
        "line": 11,
        "fullcodeline": "s = s.substr(s.find_first_not_of(' '), s.find_last_not_of(' ') - s.find_first_not_of(' ') + 1);"
    },
    {
        "line": 12,
        "fullcodeline": "pathc.push_back(s);"
    },
    {
        "line": 36,
        "fullcodeline": "if (pathlist.size() > max_path.first) {"
    },
    {
        "line": 50,
        "fullcodeline": "for (const std::string& s : pathc) sstmp /= s;"
    },
    {
        "line": 52,
        "fullcodeline": "if ((isVFSPath(p) && nothrow(comp->virtualMounts[(unsigned)std::stoul(p.substr(0, p.size()-1))]->path(sstmp))) || (fs::exists(sstmp, e))) {"
    },
    {
        "line": 60,
        "fullcodeline": "bool found = false;"
    },
    {
        "line": 61,
        "fullcodeline": "std::stack<std::string> oldback;"
    },
    {
        "line": 98,
        "fullcodeline": "*mountPath = ss2.str();"
    },
    {
        "line": 8,
        "fullcodeline": "else if (pathc.empty()) pathc.push_back(\"..\");"
    },
    {
        "line": 37,
        "fullcodeline": "max_path = std::make_pair(pathlist.size(), std::vector<_path_t>(1, std::get<1>(m)));"
    },
    {
        "line": 38,
        "fullcodeline": "mount_list = &pathlist;"
    },
    {
        "line": 53,
        "fullcodeline": "ss /= sstmp;"
    },
    {
        "line": 54,
        "fullcodeline": "found = true;"
    },
    {
        "line": 62,
        "fullcodeline": "while (!found && !pathc.empty()) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (!found) return path_t();"
    },
    {
        "line": 87,
        "fullcodeline": "ss /= max_path.second.front();"
    },
    {
        "line": 94,
        "fullcodeline": "for (auto it = mount_list->begin(); it != mount_list->end(); ++it) {"
    },
    {
        "line": 63,
        "fullcodeline": "found = false;"
    },
    {
        "line": 64,
        "fullcodeline": "std::string back = pathc.back();"
    },
    {
        "line": 65,
        "fullcodeline": "pathc.pop_back();"
    },
    {
        "line": 88,
        "fullcodeline": "for (const std::string& s : pathc) ss /= s;"
    },
    {
        "line": 96,
        "fullcodeline": "ss2 << *it;"
    },
    {
        "line": 9,
        "fullcodeline": "else pathc.pop_back();"
    },
    {
        "line": 39,
        "fullcodeline": "} else if (pathlist.size() == max_path.first) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (!found) oldback.push(back);"
    },
    {
        "line": 95,
        "fullcodeline": "if (it != mount_list->begin()) ss2 << \"/\";"
    },
    {
        "line": 40,
        "fullcodeline": "max_path.second.push_back(std::get<1>(m));"
    },
    {
        "line": 67,
        "fullcodeline": "path_t sstmp = p;"
    },
    {
        "line": 69,
        "fullcodeline": "e.clear();"
    },
    {
        "line": 68,
        "fullcodeline": "for (const std::string& s : pathc) sstmp /= s;"
    },
    {
        "line": 71,
        "fullcodeline": "(isVFSPath(p) && (nothrow(comp->virtualMounts[(unsigned)std::stoul(p.substr(0, p.size()-1))]->path(ss/back)) ||"
    },
    {
        "line": 73,
        "fullcodeline": "(fs::exists(sstmp/back, e)) || (fs::is_directory(sstmp, e))) {"
    },
    {
        "line": 74,
        "fullcodeline": "ss /= sstmp/back;"
    },
    {
        "line": 79,
        "fullcodeline": "found = true;"
    },
    {
        "line": 75,
        "fullcodeline": "while (!oldback.empty()) {"
    },
    {
        "line": 76,
        "fullcodeline": "ss /= oldback.top();"
    },
    {
        "line": 77,
        "fullcodeline": "oldback.pop();"
    },
    {
        "line": 72,
        "fullcodeline": "(nothrow(comp->virtualMounts[(unsigned)std::stoul(p.substr(0, p.size()-1))]->path(sstmp)) && comp->virtualMounts[(unsigned)std::stoul(p.substr(0, p.size()-1))]->path(sstmp).isDir))) ||"
    }
]