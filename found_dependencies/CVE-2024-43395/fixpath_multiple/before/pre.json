[
    {
        "line": 2,
        "fullcodeline": "std::vector<path_t> retval;"
    },
    {
        "line": 3,
        "fullcodeline": "std::vector<std::string> elems = split(path, \"/\\\\\");"
    },
    {
        "line": 4,
        "fullcodeline": "std::list<std::string> pathc;"
    },
    {
        "line": 22,
        "fullcodeline": "std::pair<size_t, std::vector<_path_t> > max_path = std::make_pair(0, std::vector<_path_t>(1, comp->dataDir));"
    },
    {
        "line": 23,
        "fullcodeline": "std::list<std::string> * mount_list = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();"
    },
    {
        "line": 35,
        "fullcodeline": "for (size_t i = 0; i < max_path.first; i++) pathc.pop_front();"
    },
    {
        "line": 16,
        "fullcodeline": "if (comp->isDebugger && pathc.size() == 1 && pathc.front() == \"bios.lua\")"
    },
    {
        "line": 37,
        "fullcodeline": "path_t sstmp = p;"
    },
    {
        "line": 6,
        "fullcodeline": "if (s == \"..\") {"
    },
    {
        "line": 25,
        "fullcodeline": "std::list<std::string> &pathlist = std::get<0>(m);"
    },
    {
        "line": 39,
        "fullcodeline": "for (const std::string& s : pathc) sstmp /= s;"
    },
    {
        "line": 26,
        "fullcodeline": "if (pathc.size() >= pathlist.size() && std::equal(pathlist.begin(), pathlist.end(), pathc.begin())) {"
    },
    {
        "line": 41,
        "fullcodeline": "(isVFSPath(p) && nothrow(comp->virtualMounts[(unsigned)std::stoul(p.substr(0, p.size()-1))]->path(sstmp.string()))) ||"
    },
    {
        "line": 42,
        "fullcodeline": "(fs::exists(sstmp, e))) {"
    },
    {
        "line": 48,
        "fullcodeline": "retval.push_back(sstmp);"
    },
    {
        "line": 7,
        "fullcodeline": "if (pathc.empty()) return retval;"
    },
    {
        "line": 27,
        "fullcodeline": "if (pathlist.size() > max_path.first) {"
    },
    {
        "line": 10,
        "fullcodeline": "} else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {"
    },
    {
        "line": 28,
        "fullcodeline": "max_path = std::make_pair(pathlist.size(), std::vector<_path_t>(1, std::get<1>(m)));"
    },
    {
        "line": 43,
        "fullcodeline": "if (path_t::preferred_separator != (path_t::value_type)'/' && isVFSPath(sstmp)) {"
    },
    {
        "line": 44,
        "fullcodeline": "path_t::string_type str = sstmp.native();"
    },
    {
        "line": 45,
        "fullcodeline": "std::replace(str.begin(), str.end(), path_t::preferred_separator, (path_t::value_type)'/');"
    },
    {
        "line": 46,
        "fullcodeline": "sstmp = path_t(str);"
    },
    {
        "line": 11,
        "fullcodeline": "s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());"
    },
    {
        "line": 12,
        "fullcodeline": "pathc.push_back(s);"
    },
    {
        "line": 8,
        "fullcodeline": "else if (pathc.empty()) pathc.push_back(\"..\");"
    },
    {
        "line": 30,
        "fullcodeline": "} else if (pathlist.size() == max_path.first) {"
    },
    {
        "line": 9,
        "fullcodeline": "else pathc.pop_back();"
    },
    {
        "line": 31,
        "fullcodeline": "max_path.second.push_back(std::get<1>(m));"
    }
]