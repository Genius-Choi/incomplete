[
    {
        "line": 3,
        "fullcodeline": "int ClientID = pPacket->m_ClientID;"
    },
    {
        "line": 5,
        "fullcodeline": "Unpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);"
    },
    {
        "line": 8,
        "fullcodeline": "int Msg = Unpacker.GetInt();"
    },
    {
        "line": 9,
        "fullcodeline": "int Sys = Msg&1;"
    },
    {
        "line": 10,
        "fullcodeline": "Msg >>= 1;"
    },
    {
        "line": 12,
        "fullcodeline": "if(Unpacker.Error())"
    },
    {
        "line": 18,
        "fullcodeline": "if(Msg == NETMSG_INFO)"
    },
    {
        "line": 275,
        "fullcodeline": "GameServer()->OnMessage(Msg, &Unpacker, ClientID);"
    },
    {
        "line": 22,
        "fullcodeline": "const char *pVersion = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 32,
        "fullcodeline": "const char *pPassword = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 41,
        "fullcodeline": "SendMap(ClientID);"
    },
    {
        "line": 44,
        "fullcodeline": "else if(Msg == NETMSG_REQUEST_MAP_DATA)"
    },
    {
        "line": 23,
        "fullcodeline": "if(str_comp(pVersion, GameServer()->NetVersion()) != 0)"
    },
    {
        "line": 33,
        "fullcodeline": "if(g_Config.m_Password[0] != 0 && str_comp(g_Config.m_Password, pPassword) != 0)"
    },
    {
        "line": 49,
        "fullcodeline": "int Chunk = Unpacker.GetInt();"
    },
    {
        "line": 50,
        "fullcodeline": "int ChunkSize = 1024-128;"
    },
    {
        "line": 51,
        "fullcodeline": "int Offset = Chunk * ChunkSize;"
    },
    {
        "line": 52,
        "fullcodeline": "int Last = 0;"
    },
    {
        "line": 66,
        "fullcodeline": "CMsgPacker Msg(NETMSG_MAP_DATA);"
    },
    {
        "line": 67,
        "fullcodeline": "Msg.AddInt(Last);"
    },
    {
        "line": 68,
        "fullcodeline": "Msg.AddInt(m_CurrentMapCrc);"
    },
    {
        "line": 69,
        "fullcodeline": "Msg.AddInt(Chunk);"
    },
    {
        "line": 70,
        "fullcodeline": "Msg.AddInt(ChunkSize);"
    },
    {
        "line": 71,
        "fullcodeline": "Msg.AddRaw(&m_pCurrentMapData[Offset], ChunkSize);"
    },
    {
        "line": 72,
        "fullcodeline": "SendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH, ClientID, true);"
    },
    {
        "line": 26,
        "fullcodeline": "char aReason[256];"
    },
    {
        "line": 27,
        "fullcodeline": "str_format(aReason, sizeof(aReason), \"Wrong version. Server is running '%s' and client '%s'\", GameServer()->NetVersion(), pVersion);"
    },
    {
        "line": 28,
        "fullcodeline": "m_NetServer.Drop(ClientID, aReason);"
    },
    {
        "line": 36,
        "fullcodeline": "m_NetServer.Drop(ClientID, \"Wrong password\");"
    },
    {
        "line": 55,
        "fullcodeline": "if(Chunk < 0 || Offset > m_CurrentMapSize)"
    },
    {
        "line": 58,
        "fullcodeline": "if(Offset+ChunkSize >= m_CurrentMapSize)"
    },
    {
        "line": 60,
        "fullcodeline": "ChunkSize = m_CurrentMapSize-Offset;"
    },
    {
        "line": 63,
        "fullcodeline": "Last = 1;"
    },
    {
        "line": 76,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 77,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"sending chunk %d with size %d\", Chunk, ChunkSize);"
    },
    {
        "line": 78,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);"
    },
    {
        "line": 81,
        "fullcodeline": "else if(Msg == NETMSG_READY)"
    },
    {
        "line": 61,
        "fullcodeline": "if(ChunkSize < 0)"
    },
    {
        "line": 62,
        "fullcodeline": "ChunkSize = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "char aAddrStr[NETADDR_MAXSTRSIZE];"
    },
    {
        "line": 86,
        "fullcodeline": "net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);"
    },
    {
        "line": 88,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 89,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"player is ready. ClientID=%x addr=%s\", ClientID, aAddrStr);"
    },
    {
        "line": 90,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);"
    },
    {
        "line": 92,
        "fullcodeline": "GameServer()->OnClientConnected(ClientID);"
    },
    {
        "line": 93,
        "fullcodeline": "SendConnectionReady(ClientID);"
    },
    {
        "line": 96,
        "fullcodeline": "else if(Msg == NETMSG_ENTERGAME)"
    },
    {
        "line": 98,
        "fullcodeline": "if(m_aClients[ClientID].m_State == CClient::STATE_READY && GameServer()->IsClientReady(ClientID))"
    },
    {
        "line": 100,
        "fullcodeline": "char aAddrStr[NETADDR_MAXSTRSIZE];"
    },
    {
        "line": 101,
        "fullcodeline": "net_addr_str(m_NetServer.ClientAddr(ClientID), aAddrStr, sizeof(aAddrStr), true);"
    },
    {
        "line": 103,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 104,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"player has entered the game. ClientID=%x addr=%s\", ClientID, aAddrStr);"
    },
    {
        "line": 105,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);"
    },
    {
        "line": 107,
        "fullcodeline": "GameServer()->OnClientEnter(ClientID);"
    },
    {
        "line": 110,
        "fullcodeline": "else if(Msg == NETMSG_INPUT)"
    },
    {
        "line": 115,
        "fullcodeline": "m_aClients[ClientID].m_LastAckedSnapshot = Unpacker.GetInt();"
    },
    {
        "line": 116,
        "fullcodeline": "int IntendedTick = Unpacker.GetInt();"
    },
    {
        "line": 117,
        "fullcodeline": "int Size = Unpacker.GetInt();"
    },
    {
        "line": 141,
        "fullcodeline": "m_aClients[ClientID].m_LastInputTick = IntendedTick;"
    },
    {
        "line": 148,
        "fullcodeline": "pInput->m_GameTick = IntendedTick;"
    },
    {
        "line": 153,
        "fullcodeline": "mem_copy(m_aClients[ClientID].m_LatestInput.m_aData, pInput->m_aData, MAX_INPUT_SIZE*sizeof(int));"
    },
    {
        "line": 156,
        "fullcodeline": "m_aClients[ClientID].m_CurrentInput %= 200;"
    },
    {
        "line": 120,
        "fullcodeline": "if(Unpacker.Error() || Size/4 > MAX_INPUT_SIZE)"
    },
    {
        "line": 123,
        "fullcodeline": "if(m_aClients[ClientID].m_LastAckedSnapshot > 0)"
    },
    {
        "line": 126,
        "fullcodeline": "if(m_aClients[ClientID].m_Snapshots.Get(m_aClients[ClientID].m_LastAckedSnapshot, &TagTime, 0, 0) >= 0)"
    },
    {
        "line": 131,
        "fullcodeline": "if(IntendedTick > m_aClients[ClientID].m_LastInputTick)"
    },
    {
        "line": 145,
        "fullcodeline": "if(IntendedTick <= Tick())"
    },
    {
        "line": 150,
        "fullcodeline": "for(int i = 0; i < Size/4; i++)"
    },
    {
        "line": 151,
        "fullcodeline": "pInput->m_aData[i] = Unpacker.GetInt();"
    },
    {
        "line": 127,
        "fullcodeline": "m_aClients[ClientID].m_Latency = (int)(((time_get()-TagTime)*1000)/time_freq());"
    },
    {
        "line": 133,
        "fullcodeline": "int TimeLeft = ((TickStartTime(IntendedTick)-time_get())*1000) / time_freq();"
    },
    {
        "line": 135,
        "fullcodeline": "CMsgPacker Msg(NETMSG_INPUTTIMING);"
    },
    {
        "line": 136,
        "fullcodeline": "Msg.AddInt(IntendedTick);"
    },
    {
        "line": 137,
        "fullcodeline": "Msg.AddInt(TimeLeft);"
    },
    {
        "line": 138,
        "fullcodeline": "SendMsgEx(&Msg, 0, ClientID, true);"
    },
    {
        "line": 146,
        "fullcodeline": "IntendedTick = Tick()+1;"
    },
    {
        "line": 160,
        "fullcodeline": "GameServer()->OnClientDirectInput(ClientID, m_aClients[ClientID].m_LatestInput.m_aData);"
    },
    {
        "line": 162,
        "fullcodeline": "else if(Msg == NETMSG_RCON_CMD)"
    },
    {
        "line": 164,
        "fullcodeline": "const char *pCmd = Unpacker.GetString();"
    },
    {
        "line": 166,
        "fullcodeline": "if(Unpacker.Error() == 0 && m_aClients[ClientID].m_Authed)"
    },
    {
        "line": 168,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 169,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"ClientID=%d rcon='%s'\", ClientID, pCmd);"
    },
    {
        "line": 170,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"server\", aBuf);"
    },
    {
        "line": 171,
        "fullcodeline": "m_RconClientID = ClientID;"
    },
    {
        "line": 173,
        "fullcodeline": "Console()->SetAccessLevel(m_aClients[ClientID].m_Authed == AUTHED_ADMIN ? IConsole::ACCESS_LEVEL_ADMIN : IConsole::ACCESS_LEVEL_MOD);"
    },
    {
        "line": 174,
        "fullcodeline": "Console()->ExecuteLineFlag(pCmd, CFGFLAG_SERVER);"
    },
    {
        "line": 175,
        "fullcodeline": "Console()->SetAccessLevel(IConsole::ACCESS_LEVEL_ADMIN);"
    },
    {
        "line": 177,
        "fullcodeline": "m_RconAuthLevel = AUTHED_ADMIN;"
    },
    {
        "line": 180,
        "fullcodeline": "else if(Msg == NETMSG_RCON_AUTH)"
    },
    {
        "line": 183,
        "fullcodeline": "Unpacker.GetString(); // login name, not used"
    },
    {
        "line": 184,
        "fullcodeline": "pPw = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 186,
        "fullcodeline": "if(Unpacker.Error() == 0)"
    },
    {
        "line": 244,
        "fullcodeline": "else if(Msg == NETMSG_PING)"
    },
    {
        "line": 188,
        "fullcodeline": "if(g_Config.m_SvRconPassword[0] == 0 && g_Config.m_SvRconModPassword[0] == 0)"
    },
    {
        "line": 246,
        "fullcodeline": "CMsgPacker Msg(NETMSG_PING_REPLY);"
    },
    {
        "line": 247,
        "fullcodeline": "SendMsgEx(&Msg, 0, ClientID, true);"
    },
    {
        "line": 190,
        "fullcodeline": "SendRconLine(ClientID, \"No rcon password set on server. Set sv_rcon_password and/or sv_rcon_mod_password to enable the remote console.\");"
    },
    {
        "line": 192,
        "fullcodeline": "else if(g_Config.m_SvRconPassword[0] && str_comp(pPw, g_Config.m_SvRconPassword) == 0)"
    },
    {
        "line": 253,
        "fullcodeline": "char aHex[] = \"0123456789ABCDEF\";"
    },
    {
        "line": 254,
        "fullcodeline": "char aBuf[512];"
    },
    {
        "line": 264,
        "fullcodeline": "char aBufMsg[256];"
    },
    {
        "line": 265,
        "fullcodeline": "str_format(aBufMsg, sizeof(aBufMsg), \"strange message ClientID=%d msg=%d data_size=%d\", ClientID, Msg, pPacket->m_DataSize);"
    },
    {
        "line": 266,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBufMsg);"
    },
    {
        "line": 267,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_DEBUG, \"server\", aBuf);"
    },
    {
        "line": 194,
        "fullcodeline": "CMsgPacker Msg(NETMSG_RCON_AUTH_STATUS);"
    },
    {
        "line": 195,
        "fullcodeline": "Msg.AddInt(1);\t//authed"
    },
    {
        "line": 196,
        "fullcodeline": "Msg.AddInt(1);\t//cmdlist"
    },
    {
        "line": 197,
        "fullcodeline": "SendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);"
    },
    {
        "line": 199,
        "fullcodeline": "m_aClients[ClientID].m_Authed = AUTHED_ADMIN;"
    },
    {
        "line": 200,
        "fullcodeline": "int SendRconCmds = Unpacker.GetInt();"
    },
    {
        "line": 203,
        "fullcodeline": "SendRconLine(ClientID, \"Admin authentication successful. Full remote console access granted.\");"
    },
    {
        "line": 204,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 205,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (admin)\", ClientID);"
    },
    {
        "line": 206,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);"
    },
    {
        "line": 256,
        "fullcodeline": "for(int b = 0; b < pPacket->m_DataSize && b < 32; b++)"
    },
    {
        "line": 201,
        "fullcodeline": "if(Unpacker.Error() == 0 && SendRconCmds)"
    },
    {
        "line": 258,
        "fullcodeline": "aBuf[b*3] = aHex[((const unsigned char *)pPacket->m_pData)[b]>>4];"
    },
    {
        "line": 259,
        "fullcodeline": "aBuf[b*3+1] = aHex[((const unsigned char *)pPacket->m_pData)[b]&0xf];"
    },
    {
        "line": 260,
        "fullcodeline": "aBuf[b*3+2] = ' ';"
    },
    {
        "line": 261,
        "fullcodeline": "aBuf[b*3+3] = 0;"
    },
    {
        "line": 202,
        "fullcodeline": "m_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_ADMIN, CFGFLAG_SERVER);"
    },
    {
        "line": 208,
        "fullcodeline": "else if(g_Config.m_SvRconModPassword[0] && str_comp(pPw, g_Config.m_SvRconModPassword) == 0)"
    },
    {
        "line": 210,
        "fullcodeline": "CMsgPacker Msg(NETMSG_RCON_AUTH_STATUS);"
    },
    {
        "line": 211,
        "fullcodeline": "Msg.AddInt(1);\t//authed"
    },
    {
        "line": 212,
        "fullcodeline": "Msg.AddInt(1);\t//cmdlist"
    },
    {
        "line": 213,
        "fullcodeline": "SendMsgEx(&Msg, MSGFLAG_VITAL, ClientID, true);"
    },
    {
        "line": 215,
        "fullcodeline": "m_aClients[ClientID].m_Authed = AUTHED_MOD;"
    },
    {
        "line": 216,
        "fullcodeline": "int SendRconCmds = Unpacker.GetInt();"
    },
    {
        "line": 219,
        "fullcodeline": "SendRconLine(ClientID, \"Moderator authentication successful. Limited remote console access granted.\");"
    },
    {
        "line": 220,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 221,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"ClientID=%d authed (moderator)\", ClientID);"
    },
    {
        "line": 222,
        "fullcodeline": "Console()->Print(IConsole::OUTPUT_LEVEL_STANDARD, \"server\", aBuf);"
    },
    {
        "line": 217,
        "fullcodeline": "if(Unpacker.Error() == 0 && SendRconCmds)"
    },
    {
        "line": 218,
        "fullcodeline": "m_aClients[ClientID].m_pRconCmdToSend = Console()->FirstCommandInfo(IConsole::ACCESS_LEVEL_MOD, CFGFLAG_SERVER);"
    },
    {
        "line": 227,
        "fullcodeline": "char aBuf[128];"
    },
    {
        "line": 228,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"Wrong password %d/%d.\", m_aClients[ClientID].m_AuthTries, g_Config.m_SvRconMaxTries);"
    },
    {
        "line": 229,
        "fullcodeline": "SendRconLine(ClientID, aBuf);"
    },
    {
        "line": 230,
        "fullcodeline": "if(m_aClients[ClientID].m_AuthTries >= g_Config.m_SvRconMaxTries)"
    },
    {
        "line": 240,
        "fullcodeline": "SendRconLine(ClientID, \"Wrong password.\");"
    },
    {
        "line": 233,
        "fullcodeline": "m_NetServer.Drop(ClientID, \"Too many remote console authentication tries\");"
    },
    {
        "line": 235,
        "fullcodeline": "m_ServerBan.BanAddr(m_NetServer.ClientAddr(ClientID), g_Config.m_SvRconBantime*60, \"Too many remote console authentication tries\");"
    }
]