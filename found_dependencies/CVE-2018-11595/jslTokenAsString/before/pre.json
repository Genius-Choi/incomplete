[
    {
        "line": 103,
        "fullcodeline": "strncpy(str, \"?[\",len);"
    },
    {
        "line": 3,
        "fullcodeline": "if (token>32 && token<128) {"
    },
    {
        "line": 102,
        "fullcodeline": "assert(len>=10);"
    },
    {
        "line": 4,
        "fullcodeline": "assert(len>=4);"
    },
    {
        "line": 5,
        "fullcodeline": "str[0] = '\\'';"
    },
    {
        "line": 6,
        "fullcodeline": "str[1] = (char)token;"
    },
    {
        "line": 7,
        "fullcodeline": "str[2] = '\\'';"
    },
    {
        "line": 8,
        "fullcodeline": "str[3] = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {"
    },
    {
        "line": 26,
        "fullcodeline": "const char tokenNames[] ="
    },
    {
        "line": 90,
        "fullcodeline": "unsigned int p = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "int n = token-_LEX_OPERATOR_START;"
    },
    {
        "line": 92,
        "fullcodeline": "while (n>0 && p<sizeof(tokenNames)) {"
    },
    {
        "line": 97,
        "fullcodeline": "assert(n==0);"
    },
    {
        "line": 94,
        "fullcodeline": "p++; // skip the zero"
    },
    {
        "line": 95,
        "fullcodeline": "n--; // next token"
    },
    {
        "line": 93,
        "fullcodeline": "while (tokenNames[p] && p<sizeof(tokenNames)) p++;"
    }
]