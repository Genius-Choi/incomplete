[
    {
        "line": 102,
        "fullcodeline": "assert(len>=10);"
    },
    {
        "line": 103,
        "fullcodeline": "espruino_snprintf(str, len, \"?[%d]\", token);"
    },
    {
        "line": 3,
        "fullcodeline": "if (token>32 && token<128) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {"
    },
    {
        "line": 4,
        "fullcodeline": "assert(len>=4);"
    },
    {
        "line": 5,
        "fullcodeline": "str[0] = '\\'';"
    },
    {
        "line": 6,
        "fullcodeline": "str[1] = (char)token;"
    },
    {
        "line": 7,
        "fullcodeline": "str[2] = '\\'';"
    },
    {
        "line": 8,
        "fullcodeline": "str[3] = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "case LEX_EOF : strncpy(str, \"EOF\", len); return;"
    },
    {
        "line": 14,
        "fullcodeline": "case LEX_ID : strncpy(str, \"ID\", len); return;"
    },
    {
        "line": 15,
        "fullcodeline": "case LEX_INT : strncpy(str, \"INT\", len); return;"
    },
    {
        "line": 16,
        "fullcodeline": "case LEX_FLOAT : strncpy(str, \"FLOAT\", len); return;"
    },
    {
        "line": 17,
        "fullcodeline": "case LEX_STR : strncpy(str, \"STRING\", len); return;"
    },
    {
        "line": 18,
        "fullcodeline": "case LEX_UNFINISHED_STR : strncpy(str, \"UNFINISHED STRING\", len); return;"
    },
    {
        "line": 19,
        "fullcodeline": "case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;"
    },
    {
        "line": 20,
        "fullcodeline": "case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \"UNFINISHED TEMPLATE LITERAL\", len); return;"
    },
    {
        "line": 21,
        "fullcodeline": "case LEX_REGEX : strncpy(str, \"REGEX\", len); return;"
    },
    {
        "line": 22,
        "fullcodeline": "case LEX_UNFINISHED_REGEX : strncpy(str, \"UNFINISHED REGEX\", len); return;"
    },
    {
        "line": 23,
        "fullcodeline": "case LEX_UNFINISHED_COMMENT : strncpy(str, \"UNFINISHED COMMENT\", len); return;"
    },
    {
        "line": 26,
        "fullcodeline": "const char tokenNames[] ="
    },
    {
        "line": 90,
        "fullcodeline": "unsigned int p = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "int n = token-_LEX_OPERATOR_START;"
    },
    {
        "line": 97,
        "fullcodeline": "assert(n==0);"
    },
    {
        "line": 98,
        "fullcodeline": "strncpy(str, &tokenNames[p], len);"
    },
    {
        "line": 92,
        "fullcodeline": "while (n>0 && p<sizeof(tokenNames)) {"
    },
    {
        "line": 94,
        "fullcodeline": "p++; // skip the zero"
    },
    {
        "line": 95,
        "fullcodeline": "n--; // next token"
    },
    {
        "line": 93,
        "fullcodeline": "while (tokenNames[p] && p<sizeof(tokenNames)) p++;"
    }
]