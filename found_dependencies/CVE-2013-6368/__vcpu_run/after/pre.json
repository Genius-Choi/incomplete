[
    {
        "line": 4,
        "fullcodeline": "struct kvm *kvm = vcpu->kvm;"
    },
    {
        "line": 6,
        "fullcodeline": "vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);"
    },
    {
        "line": 8,
        "fullcodeline": "r = 1;"
    },
    {
        "line": 63,
        "fullcodeline": "srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);"
    },
    {
        "line": 9,
        "fullcodeline": "while (r > 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "clear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);"
    },
    {
        "line": 49,
        "fullcodeline": "kvm_check_async_pf_completion(vcpu);"
    },
    {
        "line": 10,
        "fullcodeline": "if (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&"
    },
    {
        "line": 36,
        "fullcodeline": "if (r <= 0)"
    },
    {
        "line": 40,
        "fullcodeline": "if (kvm_cpu_has_pending_timer(vcpu))"
    },
    {
        "line": 43,
        "fullcodeline": "if (dm_request_for_irq_injection(vcpu)) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (need_resched()) {"
    },
    {
        "line": 11,
        "fullcodeline": "!vcpu->arch.apf.halted)"
    },
    {
        "line": 12,
        "fullcodeline": "r = vcpu_enter_guest(vcpu);"
    },
    {
        "line": 41,
        "fullcodeline": "kvm_inject_pending_timer_irqs(vcpu);"
    },
    {
        "line": 44,
        "fullcodeline": "r = -EINTR;"
    },
    {
        "line": 45,
        "fullcodeline": "vcpu->run->exit_reason = KVM_EXIT_INTR;"
    },
    {
        "line": 46,
        "fullcodeline": "++vcpu->stat.request_irq_exits;"
    },
    {
        "line": 52,
        "fullcodeline": "r = -EINTR;"
    },
    {
        "line": 53,
        "fullcodeline": "vcpu->run->exit_reason = KVM_EXIT_INTR;"
    },
    {
        "line": 54,
        "fullcodeline": "++vcpu->stat.signal_exits;"
    },
    {
        "line": 57,
        "fullcodeline": "srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);"
    },
    {
        "line": 58,
        "fullcodeline": "kvm_resched(vcpu);"
    },
    {
        "line": 59,
        "fullcodeline": "vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);"
    },
    {
        "line": 14,
        "fullcodeline": "srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);"
    },
    {
        "line": 15,
        "fullcodeline": "kvm_vcpu_block(vcpu);"
    },
    {
        "line": 16,
        "fullcodeline": "vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);"
    },
    {
        "line": 17,
        "fullcodeline": "if (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {"
    },
    {
        "line": 18,
        "fullcodeline": "kvm_apic_accept_events(vcpu);"
    },
    {
        "line": 21,
        "fullcodeline": "vcpu->arch.pv.pv_unhalted = false;"
    },
    {
        "line": 22,
        "fullcodeline": "vcpu->arch.mp_state ="
    },
    {
        "line": 25,
        "fullcodeline": "vcpu->arch.apf.halted = false;"
    },
    {
        "line": 30,
        "fullcodeline": "r = -EINTR;"
    }
]