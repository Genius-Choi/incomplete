[
    {
        "line": 7,
        "fullcodeline": "struct kvm *kvm = vcpu->kvm;"
    },
    {
        "line": 8,
        "fullcodeline": "struct kvm_pt_regs *regs = vcpu_regs(vcpu);"
    },
    {
        "line": 11,
        "fullcodeline": "struct kvm_vcpu *vmm_vcpu = to_guest(vcpu->kvm, vcpu);"
    },
    {
        "line": 34,
        "fullcodeline": "r = -ENOMEM;"
    },
    {
        "line": 35,
        "fullcodeline": "vcpu->arch.apic = kzalloc(sizeof(struct kvm_lapic), GFP_KERNEL);"
    },
    {
        "line": 38,
        "fullcodeline": "vcpu->arch.apic->vcpu = vcpu;"
    },
    {
        "line": 40,
        "fullcodeline": "p_ctx->gr[1] = 0;"
    },
    {
        "line": 41,
        "fullcodeline": "p_ctx->gr[12] = (unsigned long)((char *)vmm_vcpu + KVM_STK_OFFSET);"
    },
    {
        "line": 42,
        "fullcodeline": "p_ctx->gr[13] = (unsigned long)vmm_vcpu;"
    },
    {
        "line": 43,
        "fullcodeline": "p_ctx->psr = 0x1008522000UL;"
    },
    {
        "line": 44,
        "fullcodeline": "p_ctx->ar[40] = FPSR_DEFAULT; /*fpsr*/"
    },
    {
        "line": 45,
        "fullcodeline": "p_ctx->caller_unat = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "p_ctx->pr = 0x0;"
    },
    {
        "line": 47,
        "fullcodeline": "p_ctx->ar[36] = 0x0; /*unat*/"
    },
    {
        "line": 48,
        "fullcodeline": "p_ctx->ar[19] = 0x0; /*rnat*/"
    },
    {
        "line": 49,
        "fullcodeline": "p_ctx->ar[18] = (unsigned long)vmm_vcpu +"
    },
    {
        "line": 51,
        "fullcodeline": "p_ctx->ar[64] = 0x0; /*pfs*/"
    },
    {
        "line": 52,
        "fullcodeline": "p_ctx->cr[0] = 0x7e04UL;"
    },
    {
        "line": 54,
        "fullcodeline": "p_ctx->cr[8] = 0x3c;"
    },
    {
        "line": 57,
        "fullcodeline": "p_ctx->rr[0] = 0x30;"
    },
    {
        "line": 58,
        "fullcodeline": "p_ctx->rr[1] = 0x30;"
    },
    {
        "line": 59,
        "fullcodeline": "p_ctx->rr[2] = 0x30;"
    },
    {
        "line": 60,
        "fullcodeline": "p_ctx->rr[3] = 0x30;"
    },
    {
        "line": 61,
        "fullcodeline": "p_ctx->rr[4] = 0x30;"
    },
    {
        "line": 62,
        "fullcodeline": "p_ctx->rr[5] = 0x30;"
    },
    {
        "line": 63,
        "fullcodeline": "p_ctx->rr[7] = 0x30;"
    },
    {
        "line": 72,
        "fullcodeline": "hrtimer_init(&vcpu->arch.hlt_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);"
    },
    {
        "line": 73,
        "fullcodeline": "vcpu->arch.hlt_timer.function = hlt_timer_fn;"
    },
    {
        "line": 75,
        "fullcodeline": "vcpu->arch.last_run_cpu = -1;"
    },
    {
        "line": 76,
        "fullcodeline": "vcpu->arch.vpd = (struct vpd *)VPD_BASE(vcpu->vcpu_id);"
    },
    {
        "line": 77,
        "fullcodeline": "vcpu->arch.vsa_base = kvm_vsa_base;"
    },
    {
        "line": 78,
        "fullcodeline": "vcpu->arch.__gp = kvm_vmm_gp;"
    },
    {
        "line": 79,
        "fullcodeline": "vcpu->arch.dirty_log_lock_pa = __pa(&kvm->arch.dirty_log_lock);"
    },
    {
        "line": 80,
        "fullcodeline": "vcpu->arch.vhpt.hash = (struct thash_data *)VHPT_BASE(vcpu->vcpu_id);"
    },
    {
        "line": 81,
        "fullcodeline": "vcpu->arch.vtlb.hash = (struct thash_data *)VTLB_BASE(vcpu->vcpu_id);"
    },
    {
        "line": 82,
        "fullcodeline": "init_ptce_info(vcpu);"
    },
    {
        "line": 84,
        "fullcodeline": "r = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "if (IS_ERR(vmm_vcpu))"
    },
    {
        "line": 17,
        "fullcodeline": "if (kvm_vcpu_is_bsp(vcpu)) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (!vcpu->arch.apic)"
    },
    {
        "line": 18,
        "fullcodeline": "vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;"
    },
    {
        "line": 21,
        "fullcodeline": "regs->cr_iip = PALE_RESET_ENTRY;"
    },
    {
        "line": 24,
        "fullcodeline": "itc_offset = 0UL - kvm_get_itc(vcpu);"
    },
    {
        "line": 50,
        "fullcodeline": "((sizeof(struct kvm_vcpu)+15) & ~15);"
    },
    {
        "line": 15,
        "fullcodeline": "return PTR_ERR(vmm_vcpu);"
    },
    {
        "line": 25,
        "fullcodeline": "for (i = 0; i < KVM_MAX_VCPUS; i++) {"
    },
    {
        "line": 32,
        "fullcodeline": "vcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;"
    },
    {
        "line": 26,
        "fullcodeline": "v = (struct kvm_vcpu *)((char *)vcpu +"
    },
    {
        "line": 28,
        "fullcodeline": "v->arch.itc_offset = itc_offset;"
    },
    {
        "line": 29,
        "fullcodeline": "v->arch.last_itc = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "sizeof(struct kvm_vcpu_data) * i);"
    }
]