[
    {
        "line": 2,
        "fullcodeline": "size_t idx{0};"
    },
    {
        "line": 3,
        "fullcodeline": "while (idx < len) {"
    },
    {
        "line": 4,
        "fullcodeline": "const uint8_t tlv_type = buf[idx];"
    },
    {
        "line": 5,
        "fullcodeline": "idx++;"
    },
    {
        "line": 15,
        "fullcodeline": "const uint8_t tlv_length_upper = buf[idx];"
    },
    {
        "line": 16,
        "fullcodeline": "const uint8_t tlv_length_lower = buf[idx + 1];"
    },
    {
        "line": 17,
        "fullcodeline": "const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;"
    },
    {
        "line": 18,
        "fullcodeline": "idx += 2;"
    },
    {
        "line": 32,
        "fullcodeline": "absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);"
    },
    {
        "line": 33,
        "fullcodeline": "auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);"
    },
    {
        "line": 58,
        "fullcodeline": "idx += tlv_value_length;"
    },
    {
        "line": 59,
        "fullcodeline": "ASSERT(idx <= len);"
    },
    {
        "line": 7,
        "fullcodeline": "if ((idx + 1) >= len) {"
    },
    {
        "line": 21,
        "fullcodeline": "if ((idx + tlv_value_length - 1) >= len) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (nullptr != key_value_pair) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {"
    },
    {
        "line": 8,
        "fullcodeline": "ENVOY_LOG(debug,"
    },
    {
        "line": 22,
        "fullcodeline": "ENVOY_LOG("
    },
    {
        "line": 36,
        "fullcodeline": "metadata_value.set_string_value(tlv_value.data(), tlv_value.size());"
    },
    {
        "line": 38,
        "fullcodeline": "std::string metadata_key = key_value_pair->metadata_namespace().empty()"
    },
    {
        "line": 44,
        "fullcodeline": "metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});"
    },
    {
        "line": 45,
        "fullcodeline": "cb_->setDynamicMetadata(metadata_key, metadata);"
    },
    {
        "line": 54,
        "fullcodeline": "ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);"
    },
    {
        "line": 55,
        "fullcodeline": "parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});"
    },
    {
        "line": 9,
        "fullcodeline": "fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \""
    },
    {
        "line": 24,
        "fullcodeline": "fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \""
    },
    {
        "line": 47,
        "fullcodeline": "ENVOY_LOG(trace,"
    },
    {
        "line": 40,
        "fullcodeline": ": key_value_pair->metadata_namespace();"
    },
    {
        "line": 43,
        "fullcodeline": "(*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);"
    }
]