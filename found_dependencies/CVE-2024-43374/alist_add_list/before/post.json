[
    {
        "line": 8,
        "fullcodeline": "int\t\told_argcount = ARGCOUNT;"
    },
    {
        "line": 10,
        "fullcodeline": "if (check_arglist_locked() != FAIL"
    },
    {
        "line": 35,
        "fullcodeline": "for (i = 0; i < count; ++i)"
    },
    {
        "line": 36,
        "fullcodeline": "vim_free(files[i]);"
    },
    {
        "line": 11,
        "fullcodeline": "&& GA_GROW_OK(&ALIST(curwin)->al_ga, count))"
    },
    {
        "line": 20,
        "fullcodeline": "arglist_locked = TRUE;"
    },
    {
        "line": 28,
        "fullcodeline": "arglist_locked = FALSE;"
    },
    {
        "line": 29,
        "fullcodeline": "ALIST(curwin)->al_ga.ga_len += count;"
    },
    {
        "line": 13,
        "fullcodeline": "if (after < 0)"
    },
    {
        "line": 15,
        "fullcodeline": "if (after > ARGCOUNT)"
    },
    {
        "line": 17,
        "fullcodeline": "if (after < ARGCOUNT)"
    },
    {
        "line": 21,
        "fullcodeline": "for (i = 0; i < count; ++i)"
    },
    {
        "line": 30,
        "fullcodeline": "if (old_argcount > 0 && curwin->w_arg_idx >= after)"
    },
    {
        "line": 14,
        "fullcodeline": "after = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "after = ARGCOUNT;"
    },
    {
        "line": 18,
        "fullcodeline": "mch_memmove(&(ARGLIST[after + count]), &(ARGLIST[after]),"
    },
    {
        "line": 23,
        "fullcodeline": "int flags = BLN_LISTED | (will_edit ? BLN_CURBUF : 0);"
    },
    {
        "line": 25,
        "fullcodeline": "ARGLIST[after + i].ae_fname = files[i];"
    },
    {
        "line": 26,
        "fullcodeline": "ARGLIST[after + i].ae_fnum = buflist_add(files[i], flags);"
    },
    {
        "line": 31,
        "fullcodeline": "curwin->w_arg_idx += count;"
    },
    {
        "line": 19,
        "fullcodeline": "(ARGCOUNT - after) * sizeof(aentry_T));"
    }
]