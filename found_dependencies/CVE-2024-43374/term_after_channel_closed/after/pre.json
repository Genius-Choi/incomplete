[
    {
        "line": 79,
        "fullcodeline": "redraw_buf_and_status_later(term->tl_buffer, UPD_NOT_VALID);"
    },
    {
        "line": 4,
        "fullcodeline": "if (!term->tl_normal_mode)"
    },
    {
        "line": 6,
        "fullcodeline": "int\tfnum = term->tl_buffer->b_fnum;"
    },
    {
        "line": 8,
        "fullcodeline": "cleanup_vterm(term);"
    },
    {
        "line": 10,
        "fullcodeline": "if (term->tl_finish == TL_FINISH_CLOSE)"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tdo_set_w_closing = term->tl_buffer->b_nwindows == 0;"
    },
    {
        "line": 39,
        "fullcodeline": "aucmd_prepbuf(&aco, term->tl_buffer);"
    },
    {
        "line": 58,
        "fullcodeline": "if (term->tl_finish == TL_FINISH_OPEN"
    },
    {
        "line": 59,
        "fullcodeline": "&& term->tl_buffer->b_nwindows == 0)"
    },
    {
        "line": 61,
        "fullcodeline": "char    *cmd = term->tl_opencmd == NULL"
    },
    {
        "line": 64,
        "fullcodeline": "size_t  len = strlen(cmd) + 50;"
    },
    {
        "line": 65,
        "fullcodeline": "char    *buf = alloc(len);"
    },
    {
        "line": 28,
        "fullcodeline": "if (term->tl_buffer->b_nwindows > 0 && only_one_window())"
    },
    {
        "line": 40,
        "fullcodeline": "if (curbuf == term->tl_buffer)"
    },
    {
        "line": 67,
        "fullcodeline": "if (buf != NULL)"
    },
    {
        "line": 32,
        "fullcodeline": "CLEAR_FIELD(ea);"
    },
    {
        "line": 33,
        "fullcodeline": "ex_quit(&ea);"
    },
    {
        "line": 47,
        "fullcodeline": "do_bufdel(DOBUF_WIPE, (char_u *)\"\", 1, fnum, fnum, FALSE);"
    },
    {
        "line": 70,
        "fullcodeline": "vim_snprintf(buf, len, cmd, fnum);"
    }
]