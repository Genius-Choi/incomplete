[
    {
        "line": 12,
        "fullcodeline": "int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us"
    },
    {
        "line": 14,
        "fullcodeline": "char_u\t*new_name = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "char_u\t*free_fname = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "int\t\tretval = FAIL;"
    },
    {
        "line": 29,
        "fullcodeline": "linenr_T\ttopline = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int\t\tnewcol = -1;"
    },
    {
        "line": 31,
        "fullcodeline": "int\t\tsolcol = -1;"
    },
    {
        "line": 33,
        "fullcodeline": "char_u\t*command = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "int\t\treadfile_flags = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "int\t\tdid_inc_redrawing_disabled = FALSE;"
    },
    {
        "line": 39,
        "fullcodeline": "long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;"
    },
    {
        "line": 48,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 137,
        "fullcodeline": "reset_VIsual();"
    },
    {
        "line": 415,
        "fullcodeline": "++RedrawingDisabled;"
    },
    {
        "line": 416,
        "fullcodeline": "did_inc_redrawing_disabled = TRUE;"
    },
    {
        "line": 418,
        "fullcodeline": "buf = curbuf;"
    },
    {
        "line": 443,
        "fullcodeline": "curbuf->b_did_filetype = FALSE;"
    },
    {
        "line": 517,
        "fullcodeline": "retval = OK;"
    },
    {
        "line": 527,
        "fullcodeline": "check_arg_idx(curwin);"
    },
    {
        "line": 682,
        "fullcodeline": "check_lnums(FALSE);"
    },
    {
        "line": 722,
        "fullcodeline": "did_inc_redrawing_disabled = FALSE;"
    },
    {
        "line": 774,
        "fullcodeline": "vim_free(free_fname);"
    },
    {
        "line": 46,
        "fullcodeline": "if (eap != NULL)"
    },
    {
        "line": 50,
        "fullcodeline": "if (fnum != 0)"
    },
    {
        "line": 118,
        "fullcodeline": "if (  ((!other_file && !(flags & ECMD_OLDBUF))"
    },
    {
        "line": 140,
        "fullcodeline": "if (oldwin != NULL && !win_valid(oldwin))"
    },
    {
        "line": 419,
        "fullcodeline": "if ((flags & ECMD_SET_HELP) || keep_help_flag)"
    },
    {
        "line": 433,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 452,
        "fullcodeline": "if (!other_file && !oldbuf)\t\t// re-use the buffer"
    },
    {
        "line": 521,
        "fullcodeline": "if (!other_file)"
    },
    {
        "line": 529,
        "fullcodeline": "if (!auto_buf)"
    },
    {
        "line": 650,
        "fullcodeline": "if (command == NULL)"
    },
    {
        "line": 688,
        "fullcodeline": "if (oldbuf && !auto_buf)"
    },
    {
        "line": 712,
        "fullcodeline": "if (command != NULL)"
    },
    {
        "line": 720,
        "fullcodeline": "if (RedrawingDisabled > 0)"
    },
    {
        "line": 723,
        "fullcodeline": "if (!skip_redraw)"
    },
    {
        "line": 734,
        "fullcodeline": "if (p_im && (State & MODE_INSERT) == 0)"
    },
    {
        "line": 765,
        "fullcodeline": "if (did_inc_redrawing_disabled && RedrawingDisabled > 0)"
    },
    {
        "line": 47,
        "fullcodeline": "command = eap->do_ecmd_cmd;"
    },
    {
        "line": 54,
        "fullcodeline": "other_file = TRUE;"
    },
    {
        "line": 121,
        "fullcodeline": "&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)"
    },
    {
        "line": 141,
        "fullcodeline": "oldwin = NULL;"
    },
    {
        "line": 402,
        "fullcodeline": "curwin->w_pcmark.lnum = 1;"
    },
    {
        "line": 403,
        "fullcodeline": "curwin->w_pcmark.col = 0;"
    },
    {
        "line": 421,
        "fullcodeline": "prepare_help_buffer();"
    },
    {
        "line": 454,
        "fullcodeline": "set_last_cursor(curwin);\t// may set b_last_cursor"
    },
    {
        "line": 460,
        "fullcodeline": "buf = curbuf;"
    },
    {
        "line": 465,
        "fullcodeline": "set_bufref(&bufref, buf);"
    },
    {
        "line": 497,
        "fullcodeline": "vim_free(new_name);"
    },
    {
        "line": 508,
        "fullcodeline": "buf_clear_file(curbuf);"
    },
    {
        "line": 509,
        "fullcodeline": "curbuf->b_op_start.lnum = 0;\t// clear '[ and '] marks"
    },
    {
        "line": 510,
        "fullcodeline": "curbuf->b_op_end.lnum = 0;"
    },
    {
        "line": 522,
        "fullcodeline": "curbuf->b_flags &= ~BF_NOTEDITED;"
    },
    {
        "line": 536,
        "fullcodeline": "curwin_init();"
    },
    {
        "line": 558,
        "fullcodeline": "orig_pos = curwin->w_cursor;"
    },
    {
        "line": 559,
        "fullcodeline": "topline = curwin->w_topline;"
    },
    {
        "line": 603,
        "fullcodeline": "check_arg_idx(curwin);"
    },
    {
        "line": 623,
        "fullcodeline": "changed_line_abv_curs();"
    },
    {
        "line": 625,
        "fullcodeline": "maketitle();"
    },
    {
        "line": 690,
        "fullcodeline": "int\tmsg_scroll_save = msg_scroll;"
    },
    {
        "line": 698,
        "fullcodeline": "msg_start();"
    },
    {
        "line": 699,
        "fullcodeline": "msg_scroll = msg_scroll_save;"
    },
    {
        "line": 700,
        "fullcodeline": "msg_scrolled_ign = TRUE;"
    },
    {
        "line": 705,
        "fullcodeline": "msg_scrolled_ign = FALSE;"
    },
    {
        "line": 713,
        "fullcodeline": "do_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);"
    },
    {
        "line": 721,
        "fullcodeline": "--RedrawingDisabled;"
    },
    {
        "line": 728,
        "fullcodeline": "update_topline();"
    },
    {
        "line": 729,
        "fullcodeline": "curwin->w_scbind_pos = curwin->w_topline;"
    },
    {
        "line": 730,
        "fullcodeline": "*so_ptr = n;"
    },
    {
        "line": 731,
        "fullcodeline": "redraw_curbuf_later(UPD_NOT_VALID);\t// redraw this buffer later"
    },
    {
        "line": 735,
        "fullcodeline": "need_start_insertmode = TRUE;"
    },
    {
        "line": 766,
        "fullcodeline": "--RedrawingDisabled;"
    },
    {
        "line": 52,
        "fullcodeline": "if (fnum == curbuf->b_fnum)\t// file is already being edited"
    },
    {
        "line": 119,
        "fullcodeline": "|| (curbuf->b_nwindows == 1"
    },
    {
        "line": 126,
        "fullcodeline": "if (fnum == 0 && other_file && ffname != NULL)"
    },
    {
        "line": 177,
        "fullcodeline": "if (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))"
    },
    {
        "line": 223,
        "fullcodeline": "if (buf == NULL)"
    },
    {
        "line": 225,
        "fullcodeline": "if (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)"
    },
    {
        "line": 229,
        "fullcodeline": "if (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet"
    },
    {
        "line": 250,
        "fullcodeline": "if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)"
    },
    {
        "line": 263,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 410,
        "fullcodeline": "oldbuf = (flags & ECMD_OLDBUF);"
    },
    {
        "line": 455,
        "fullcodeline": "if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)"
    },
    {
        "line": 461,
        "fullcodeline": "if (buf->b_fname != NULL)"
    },
    {
        "line": 470,
        "fullcodeline": "if (!(curbuf->b_flags & BF_NEVERLOADED)"
    },
    {
        "line": 492,
        "fullcodeline": "if (!bufref_valid(&bufref))"
    },
    {
        "line": 502,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 560,
        "fullcodeline": "if (!oldbuf)\t\t\t    // need to read the file"
    },
    {
        "line": 608,
        "fullcodeline": "if (!EQUAL_POS(curwin->w_cursor, orig_pos))"
    },
    {
        "line": 619,
        "fullcodeline": "if (curwin->w_topline == topline)"
    },
    {
        "line": 652,
        "fullcodeline": "if (newcol >= 0)\t// position set by autocommands"
    },
    {
        "line": 694,
        "fullcodeline": "if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)"
    },
    {
        "line": 696,
        "fullcodeline": "if (!msg_scroll)\t// wait a bit when overwriting an error msg"
    },
    {
        "line": 702,
        "fullcodeline": "if (!shortmess(SHM_FILEINFO))"
    },
    {
        "line": 726,
        "fullcodeline": "if (topline == 0 && command == NULL)"
    },
    {
        "line": 83,
        "fullcodeline": "if (sfname == NULL)"
    },
    {
        "line": 90,
        "fullcodeline": "if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))"
    },
    {
        "line": 94,
        "fullcodeline": "if (ffname == NULL)"
    },
    {
        "line": 120,
        "fullcodeline": "&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))"
    },
    {
        "line": 124,
        "fullcodeline": "| (eap == NULL ? 0 : CCGD_EXCMD)))"
    },
    {
        "line": 127,
        "fullcodeline": "(void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);"
    },
    {
        "line": 186,
        "fullcodeline": "buf = buflist_findnr(fnum);"
    },
    {
        "line": 227,
        "fullcodeline": "curwin->w_alt_fnum = prev_alt_fnum;"
    },
    {
        "line": 231,
        "fullcodeline": "oldbuf = FALSE;"
    },
    {
        "line": 252,
        "fullcodeline": "pos = buflist_findfpos(buf);"
    },
    {
        "line": 253,
        "fullcodeline": "newlnum = pos->lnum;"
    },
    {
        "line": 254,
        "fullcodeline": "solcol = pos->col;"
    },
    {
        "line": 266,
        "fullcodeline": "int\t\tsave_cmdwin_type = cmdwin_type;"
    },
    {
        "line": 267,
        "fullcodeline": "win_T\t*save_cmdwin_win = cmdwin_win;"
    },
    {
        "line": 272,
        "fullcodeline": "assert(cmdwin_buf == NULL);"
    },
    {
        "line": 275,
        "fullcodeline": "cmdwin_type = 0;"
    },
    {
        "line": 276,
        "fullcodeline": "cmdwin_win = NULL;"
    },
    {
        "line": 290,
        "fullcodeline": "save_au_new_curbuf = au_new_curbuf;"
    },
    {
        "line": 291,
        "fullcodeline": "set_bufref(&au_new_curbuf, buf);"
    },
    {
        "line": 292,
        "fullcodeline": "apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 294,
        "fullcodeline": "cmdwin_type = save_cmdwin_type;"
    },
    {
        "line": 295,
        "fullcodeline": "cmdwin_win = save_cmdwin_win;"
    },
    {
        "line": 398,
        "fullcodeline": "vim_free(new_name);"
    },
    {
        "line": 399,
        "fullcodeline": "au_new_curbuf = save_au_new_curbuf;"
    },
    {
        "line": 407,
        "fullcodeline": "if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)"
    },
    {
        "line": 427,
        "fullcodeline": "if (!curbuf->b_help)"
    },
    {
        "line": 462,
        "fullcodeline": "new_name = vim_strsave(buf->b_fname);"
    },
    {
        "line": 471,
        "fullcodeline": "&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))"
    },
    {
        "line": 474,
        "fullcodeline": "u_sync(FALSE);"
    },
    {
        "line": 481,
        "fullcodeline": "u_unchanged(curbuf);"
    },
    {
        "line": 482,
        "fullcodeline": "buf_freeall(curbuf, BFA_KEEP_UNDO);"
    },
    {
        "line": 485,
        "fullcodeline": "readfile_flags = READ_KEEP_UNDO;"
    },
    {
        "line": 494,
        "fullcodeline": "delbuf_msg(new_name);\t// frees new_name"
    },
    {
        "line": 568,
        "fullcodeline": "swap_exists_action = SEA_DIALOG;"
    },
    {
        "line": 569,
        "fullcodeline": "curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag"
    },
    {
        "line": 580,
        "fullcodeline": "(void)open_buffer(FALSE, eap, readfile_flags);"
    },
    {
        "line": 588,
        "fullcodeline": "handle_swap_exists(&old_curbuf);"
    },
    {
        "line": 610,
        "fullcodeline": "char_u *text = ml_get_curline();"
    },
    {
        "line": 620,
        "fullcodeline": "topline = 0;"
    },
    {
        "line": 654,
        "fullcodeline": "curwin->w_cursor.lnum = newlnum;"
    },
    {
        "line": 655,
        "fullcodeline": "curwin->w_cursor.col = newcol;"
    },
    {
        "line": 656,
        "fullcodeline": "check_cursor();"
    },
    {
        "line": 695,
        "fullcodeline": "msg_scroll = FALSE;"
    },
    {
        "line": 697,
        "fullcodeline": "check_for_delay(FALSE);"
    },
    {
        "line": 703,
        "fullcodeline": "fileinfo(FALSE, TRUE, FALSE);"
    },
    {
        "line": 727,
        "fullcodeline": "*so_ptr = 9999;\t\t// force cursor halfway the window"
    },
    {
        "line": 84,
        "fullcodeline": "sfname = ffname;"
    },
    {
        "line": 91,
        "fullcodeline": "&& (ffname == NULL || *ffname == NUL))"
    },
    {
        "line": 95,
        "fullcodeline": "other_file = TRUE;"
    },
    {
        "line": 123,
        "fullcodeline": "| ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)"
    },
    {
        "line": 179,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)"
    },
    {
        "line": 181,
        "fullcodeline": "if (oldwin != NULL)"
    },
    {
        "line": 215,
        "fullcodeline": "buf = buflist_new(ffname, sfname, 0L,"
    },
    {
        "line": 221,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 235,
        "fullcodeline": "oldbuf = TRUE;"
    },
    {
        "line": 236,
        "fullcodeline": "set_bufref(&bufref, buf);"
    },
    {
        "line": 237,
        "fullcodeline": "(void)buf_check_timestamp(buf, FALSE);"
    },
    {
        "line": 288,
        "fullcodeline": "if (buf->b_fname != NULL)"
    },
    {
        "line": 297,
        "fullcodeline": "if (!bufref_valid(&au_new_curbuf))"
    },
    {
        "line": 312,
        "fullcodeline": "if (buf == curbuf)\t\t// already in new buffer"
    },
    {
        "line": 428,
        "fullcodeline": "set_buflisted(TRUE);"
    },
    {
        "line": 464,
        "fullcodeline": "new_name = NULL;"
    },
    {
        "line": 475,
        "fullcodeline": "if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)"
    },
    {
        "line": 488,
        "fullcodeline": "buf_freeall(curbuf, 0);   // free all things for buffer"
    },
    {
        "line": 574,
        "fullcodeline": "if (flags & ECMD_NOWINENTER)"
    },
    {
        "line": 586,
        "fullcodeline": "if (swap_exists_action == SEA_QUIT)"
    },
    {
        "line": 595,
        "fullcodeline": "do_modelines(OPT_WINONLY);"
    },
    {
        "line": 597,
        "fullcodeline": "apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,"
    },
    {
        "line": 612,
        "fullcodeline": "if (curwin->w_cursor.lnum != orig_pos.lnum"
    },
    {
        "line": 122,
        "fullcodeline": "| (other_file ? 0 : CCGD_MULTWIN)"
    },
    {
        "line": 180,
        "fullcodeline": "curwin->w_alt_fnum = curbuf->b_fnum;"
    },
    {
        "line": 182,
        "fullcodeline": "buflist_altfpos(oldwin);"
    },
    {
        "line": 189,
        "fullcodeline": "if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))"
    },
    {
        "line": 219,
        "fullcodeline": "if (oldwin != NULL)"
    },
    {
        "line": 240,
        "fullcodeline": "if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)"
    },
    {
        "line": 289,
        "fullcodeline": "new_name = vim_strsave(buf->b_fname);"
    },
    {
        "line": 300,
        "fullcodeline": "delbuf_msg(new_name);\t// frees new_name"
    },
    {
        "line": 301,
        "fullcodeline": "au_new_curbuf = save_au_new_curbuf;"
    },
    {
        "line": 313,
        "fullcodeline": "auto_buf = TRUE;"
    },
    {
        "line": 478,
        "fullcodeline": "vim_free(new_name);"
    },
    {
        "line": 575,
        "fullcodeline": "readfile_flags |= READ_NOWINENTER;"
    },
    {
        "line": 587,
        "fullcodeline": "retval = FAIL;"
    },
    {
        "line": 599,
        "fullcodeline": "if ((flags & ECMD_NOWINENTER) == 0)"
    },
    {
        "line": 613,
        "fullcodeline": "|| curwin->w_cursor.col != (int)(skipwhite(text) - text))"
    },
    {
        "line": 615,
        "fullcodeline": "newlnum = curwin->w_cursor.lnum;"
    },
    {
        "line": 616,
        "fullcodeline": "newcol = curwin->w_cursor.col;"
    },
    {
        "line": 658,
        "fullcodeline": "else if (newlnum > 0)\t// line number from caller or old position"
    },
    {
        "line": 97,
        "fullcodeline": "else if (*ffname == NUL && curbuf->b_ffname == NULL)"
    },
    {
        "line": 193,
        "fullcodeline": "linenr_T\ttlnum = 0;"
    },
    {
        "line": 204,
        "fullcodeline": "newbuf = buflist_new(ffname, sfname, tlnum,"
    },
    {
        "line": 216,
        "fullcodeline": "BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));"
    },
    {
        "line": 220,
        "fullcodeline": "oldwin = curwin;"
    },
    {
        "line": 316,
        "fullcodeline": "win_T\t    *the_curwin = curwin;"
    },
    {
        "line": 318,
        "fullcodeline": "buf_T\t    *was_curbuf = curbuf;"
    },
    {
        "line": 322,
        "fullcodeline": "the_curwin->w_closing = TRUE;"
    },
    {
        "line": 323,
        "fullcodeline": "++buf->b_locked;"
    },
    {
        "line": 330,
        "fullcodeline": "u_sync(FALSE);"
    },
    {
        "line": 331,
        "fullcodeline": "did_decrement = close_buffer(oldwin, curbuf,"
    },
    {
        "line": 337,
        "fullcodeline": "--buf->b_locked;"
    },
    {
        "line": 393,
        "fullcodeline": "get_winopts(curbuf);"
    },
    {
        "line": 600,
        "fullcodeline": "apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,"
    },
    {
        "line": 660,
        "fullcodeline": "curwin->w_cursor.lnum = newlnum;"
    },
    {
        "line": 661,
        "fullcodeline": "check_cursor_lnum();"
    },
    {
        "line": 98,
        "fullcodeline": "other_file = FALSE;"
    },
    {
        "line": 196,
        "fullcodeline": "if (command != NULL)"
    },
    {
        "line": 206,
        "fullcodeline": "if (newbuf != NULL)"
    },
    {
        "line": 325,
        "fullcodeline": "if (curbuf == old_curbuf.br_buf)"
    },
    {
        "line": 335,
        "fullcodeline": "if (win_valid(the_curwin))"
    },
    {
        "line": 349,
        "fullcodeline": "if (!bufref_valid(&au_new_curbuf))"
    },
    {
        "line": 356,
        "fullcodeline": "if (buf == curbuf)\t\t// already in new buffer"
    },
    {
        "line": 662,
        "fullcodeline": "if (solcol >= 0 && !p_sol)"
    },
    {
        "line": 677,
        "fullcodeline": "beginline(BL_WHITE | BL_FIX);"
    },
    {
        "line": 106,
        "fullcodeline": "free_fname = fix_fname(ffname); // may expand to full path name"
    },
    {
        "line": 109,
        "fullcodeline": "other_file = otherfile(ffname);"
    },
    {
        "line": 198,
        "fullcodeline": "tlnum = atol((char *)command);"
    },
    {
        "line": 205,
        "fullcodeline": "BLN_LISTED | BLN_NOCURWIN);"
    },
    {
        "line": 326,
        "fullcodeline": "buf_copy_options(buf, BCO_ENTER);"
    },
    {
        "line": 332,
        "fullcodeline": "(flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);"
    },
    {
        "line": 336,
        "fullcodeline": "the_curwin->w_closing = FALSE;"
    },
    {
        "line": 352,
        "fullcodeline": "delbuf_msg(new_name);\t// frees new_name"
    },
    {
        "line": 353,
        "fullcodeline": "au_new_curbuf = save_au_new_curbuf;"
    },
    {
        "line": 364,
        "fullcodeline": "auto_buf = TRUE;"
    },
    {
        "line": 665,
        "fullcodeline": "curwin->w_cursor.col = solcol;"
    },
    {
        "line": 666,
        "fullcodeline": "check_cursor_col();"
    },
    {
        "line": 667,
        "fullcodeline": "curwin->w_cursor.coladd = 0;"
    },
    {
        "line": 668,
        "fullcodeline": "curwin->w_set_curswant = TRUE;"
    },
    {
        "line": 101,
        "fullcodeline": "if (*ffname == NUL)\t\t    // re-edit with same file name"
    },
    {
        "line": 107,
        "fullcodeline": "if (free_fname != NULL)"
    },
    {
        "line": 199,
        "fullcodeline": "if (tlnum <= 0)"
    },
    {
        "line": 208,
        "fullcodeline": "if (flags & ECMD_ALTBUF)"
    },
    {
        "line": 210,
        "fullcodeline": "if (tlnum > 0)"
    },
    {
        "line": 360,
        "fullcodeline": "if (did_decrement && buf_valid(was_curbuf))"
    },
    {
        "line": 362,
        "fullcodeline": "if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)"
    },
    {
        "line": 377,
        "fullcodeline": "curwin->w_buffer = buf;"
    },
    {
        "line": 378,
        "fullcodeline": "curbuf = buf;"
    },
    {
        "line": 379,
        "fullcodeline": "++curbuf->b_nwindows;"
    },
    {
        "line": 671,
        "fullcodeline": "beginline(BL_SOL | BL_FIX);"
    },
    {
        "line": 103,
        "fullcodeline": "ffname = curbuf->b_ffname;"
    },
    {
        "line": 104,
        "fullcodeline": "sfname = curbuf->b_fname;"
    },
    {
        "line": 108,
        "fullcodeline": "ffname = free_fname;"
    },
    {
        "line": 200,
        "fullcodeline": "tlnum = 1L;"
    },
    {
        "line": 209,
        "fullcodeline": "curwin->w_alt_fnum = newbuf->b_fnum;"
    },
    {
        "line": 211,
        "fullcodeline": "newbuf->b_last_cursor.lnum = tlnum;"
    },
    {
        "line": 361,
        "fullcodeline": "++was_curbuf->b_nwindows;"
    },
    {
        "line": 363,
        "fullcodeline": "oldwin->w_buffer = was_curbuf;"
    },
    {
        "line": 382,
        "fullcodeline": "if (!oldbuf && eap != NULL)"
    },
    {
        "line": 384,
        "fullcodeline": "set_file_options(TRUE, eap);"
    },
    {
        "line": 385,
        "fullcodeline": "set_forced_fenc(eap);"
    }
]