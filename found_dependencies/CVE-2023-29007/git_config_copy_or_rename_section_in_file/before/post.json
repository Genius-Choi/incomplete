[
    {
        "line": 5,
        "fullcodeline": "int ret = 0, remove = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "char *filename_buf = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "struct lock_file lock = LOCK_INIT;"
    },
    {
        "line": 9,
        "fullcodeline": "char buf[1024];"
    },
    {
        "line": 10,
        "fullcodeline": "FILE *config_file = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "struct strbuf copystr = STRBUF_INIT;"
    },
    {
        "line": 15,
        "fullcodeline": "memset(&store, 0, sizeof(store));"
    },
    {
        "line": 25,
        "fullcodeline": "out_fd = hold_lock_file_for_update(&lock, config_filename, 0);"
    },
    {
        "line": 138,
        "fullcodeline": "fclose(config_file);"
    },
    {
        "line": 139,
        "fullcodeline": "config_file = NULL;"
    },
    {
        "line": 147,
        "fullcodeline": "rollback_lock_file(&lock);"
    },
    {
        "line": 149,
        "fullcodeline": "free(filename_buf);"
    },
    {
        "line": 150,
        "fullcodeline": "config_store_data_clear(&store);"
    },
    {
        "line": 17,
        "fullcodeline": "if (new_name && !section_name_is_ok(new_name)) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (!config_filename)"
    },
    {
        "line": 26,
        "fullcodeline": "if (out_fd < 0) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (!(config_file = fopen(config_filename, \"rb\"))) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (fstat(fileno(config_file), &st) == -1) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {"
    },
    {
        "line": 50,
        "fullcodeline": "while (fgets(buf, sizeof(buf), config_file)) {"
    },
    {
        "line": 130,
        "fullcodeline": "if (copystr.len > 0) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (commit_lock_file(&lock) < 0)"
    },
    {
        "line": 18,
        "fullcodeline": "ret = error(_(\"invalid section name: %s\"), new_name);"
    },
    {
        "line": 23,
        "fullcodeline": "config_filename = filename_buf = git_pathdup(\"config\");"
    },
    {
        "line": 27,
        "fullcodeline": "ret = error(_(\"could not lock config file %s\"), config_filename);"
    },
    {
        "line": 32,
        "fullcodeline": "ret = warn_on_fopen_errors(config_filename);"
    },
    {
        "line": 40,
        "fullcodeline": "ret = error_errno(_(\"fstat on %s failed\"), config_filename);"
    },
    {
        "line": 45,
        "fullcodeline": "ret = error_errno(_(\"chmod on %s failed\"),"
    },
    {
        "line": 53,
        "fullcodeline": "int is_section = 0;"
    },
    {
        "line": 54,
        "fullcodeline": "char *output = buf;"
    },
    {
        "line": 113,
        "fullcodeline": "length = strlen(output);"
    },
    {
        "line": 135,
        "fullcodeline": "strbuf_reset(&copystr);"
    },
    {
        "line": 142,
        "fullcodeline": "ret = error_errno(_(\"could not write config file %s\"),"
    },
    {
        "line": 146,
        "fullcodeline": "fclose(config_file);"
    },
    {
        "line": 55,
        "fullcodeline": "for (i = 0; buf[i] && isspace(buf[i]); i++)"
    },
    {
        "line": 57,
        "fullcodeline": "if (buf[i] == '[') {"
    },
    {
        "line": 115,
        "fullcodeline": "if (!is_section && copystr.len > 0) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (write_in_full(out_fd, output, length) < 0) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {"
    },
    {
        "line": 46,
        "fullcodeline": "get_lock_file_path(&lock));"
    },
    {
        "line": 60,
        "fullcodeline": "is_section = 1;"
    },
    {
        "line": 76,
        "fullcodeline": "offset = section_name_match(&buf[i], old_name);"
    },
    {
        "line": 109,
        "fullcodeline": "remove = 0;"
    },
    {
        "line": 116,
        "fullcodeline": "strbuf_add(&copystr, output, length);"
    },
    {
        "line": 120,
        "fullcodeline": "ret = write_error(get_lock_file_path(&lock));"
    },
    {
        "line": 132,
        "fullcodeline": "ret = write_error(get_lock_file_path(&lock));"
    },
    {
        "line": 68,
        "fullcodeline": "if (copystr.len > 0) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (offset > 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "strbuf_reset(&copystr);"
    },
    {
        "line": 78,
        "fullcodeline": "ret++;"
    },
    {
        "line": 83,
        "fullcodeline": "store.baselen = strlen(new_name);"
    },
    {
        "line": 69,
        "fullcodeline": "if (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (new_name == NULL) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (!copy) {"
    },
    {
        "line": 70,
        "fullcodeline": "ret = write_error(get_lock_file_path(&lock));"
    },
    {
        "line": 80,
        "fullcodeline": "remove = 1;"
    },
    {
        "line": 94,
        "fullcodeline": "output += offset + i;"
    },
    {
        "line": 85,
        "fullcodeline": "if (write_section(out_fd, new_name, &store) < 0) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (strlen(output) > 0) {"
    },
    {
        "line": 106,
        "fullcodeline": "copystr = store_create_section(new_name, &store);"
    },
    {
        "line": 86,
        "fullcodeline": "ret = write_error(get_lock_file_path(&lock));"
    },
    {
        "line": 102,
        "fullcodeline": "output -= 1;"
    },
    {
        "line": 103,
        "fullcodeline": "output[0] = '\\t';"
    }
]