[
    {
        "line": 24,
        "fullcodeline": "incode = code;"
    },
    {
        "line": 37,
        "fullcodeline": "avail++;"
    },
    {
        "line": 6,
        "fullcodeline": "if (code == clear) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (oldcode == -1) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (code > avail) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (code == avail) {      /* the first code is always < avail */"
    },
    {
        "line": 34,
        "fullcodeline": "*stackp++ = firstchar = suffix[code];"
    },
    {
        "line": 46,
        "fullcodeline": "} while (stackp > stack);"
    },
    {
        "line": 7,
        "fullcodeline": "codesize = datasize + 1;"
    },
    {
        "line": 8,
        "fullcodeline": "codemask = (1 << codesize) - 1;"
    },
    {
        "line": 9,
        "fullcodeline": "avail = clear + 2;"
    },
    {
        "line": 10,
        "fullcodeline": "oldcode = -1;"
    },
    {
        "line": 20,
        "fullcodeline": "fprintf(stderr, \"code %d too large for %d\\n\", code, avail);"
    },
    {
        "line": 27,
        "fullcodeline": "code = oldcode;"
    },
    {
        "line": 31,
        "fullcodeline": "code = prefix[code];"
    },
    {
        "line": 39,
        "fullcodeline": "if (((avail & codemask) == 0) && (avail < 4096)) {"
    },
    {
        "line": 16,
        "fullcodeline": "firstchar = oldcode = code;"
    },
    {
        "line": 26,
        "fullcodeline": "*stackp++ = firstchar;"
    },
    {
        "line": 30,
        "fullcodeline": "*stackp++ = suffix[code];"
    },
    {
        "line": 45,
        "fullcodeline": "*(*fill)++ = *--stackp;"
    }
]