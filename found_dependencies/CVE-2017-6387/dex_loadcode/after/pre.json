[
    {
        "line": 2,
        "fullcodeline": "struct r_bin_t *rbin = arch->rbin;"
    },
    {
        "line": 4,
        "fullcodeline": "int *methods = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "int sym_count = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "bin->code_from = UT64_MAX;"
    },
    {
        "line": 12,
        "fullcodeline": "bin->code_to = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "bin->methods_list = r_list_newf ((RListFree)free);"
    },
    {
        "line": 17,
        "fullcodeline": "bin->imports_list = r_list_newf ((RListFree)free);"
    },
    {
        "line": 22,
        "fullcodeline": "bin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);"
    },
    {
        "line": 35,
        "fullcodeline": "bin->header.method_size = R_MIN (bin->header.method_size, bin->size);"
    },
    {
        "line": 36,
        "fullcodeline": "bin->header.class_size = R_MIN (bin->header.class_size, bin->size);"
    },
    {
        "line": 37,
        "fullcodeline": "bin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);"
    },
    {
        "line": 8,
        "fullcodeline": "if (!bin || bin->methods_list) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (!bin->methods_list) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (!bin->imports_list) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (!bin->classes_list) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (bin->header.method_size>bin->size) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (bin->header.strings_size > bin->size) {"
    },
    {
        "line": 46,
        "fullcodeline": "ut64 amount = sizeof (int) * bin->header.method_size;"
    },
    {
        "line": 50,
        "fullcodeline": "methods = calloc (1, amount + 1);"
    },
    {
        "line": 66,
        "fullcodeline": "int import_count = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "int sym_count = bin->methods_list->length;"
    },
    {
        "line": 51,
        "fullcodeline": "for (i = 0; i < bin->header.class_size; i++) {"
    },
    {
        "line": 69,
        "fullcodeline": "for (i = 0; i < bin->header.method_size; i++) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (amount > UT32_MAX || amount < bin->header.method_size) {"
    },
    {
        "line": 53,
        "fullcodeline": "struct dex_class_t *c = &bin->classes[i];"
    },
    {
        "line": 54,
        "fullcodeline": "class_name = dex_class_name (bin, c);"
    },
    {
        "line": 55,
        "fullcodeline": "super_name = dex_class_super_name (bin, c);"
    },
    {
        "line": 59,
        "fullcodeline": "parse_class (arch, bin, c, i, methods, &sym_count);"
    },
    {
        "line": 83,
        "fullcodeline": "char *class_name = getstr ("
    },
    {
        "line": 90,
        "fullcodeline": "len = strlen (class_name);"
    },
    {
        "line": 94,
        "fullcodeline": "class_name[len - 1] = 0; // remove last char \";\""
    },
    {
        "line": 95,
        "fullcodeline": "char *method_name = dex_method_name (bin, i);"
    },
    {
        "line": 96,
        "fullcodeline": "char *signature = dex_method_signature (bin, i);"
    },
    {
        "line": 75,
        "fullcodeline": "if (bin->methods[i].class_id > bin->header.types_size) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (!class_name) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (len < 1) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (method_name && *method_name) {"
    },
    {
        "line": 57,
        "fullcodeline": "rbin->cb_printf (\"Class #%d            -\\n\", i);"
    },
    {
        "line": 98,
        "fullcodeline": "RBinImport *imp = R_NEW0 (RBinImport);"
    },
    {
        "line": 99,
        "fullcodeline": "imp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);"
    },
    {
        "line": 100,
        "fullcodeline": "imp->type = r_str_const (\"FUNC\");"
    },
    {
        "line": 101,
        "fullcodeline": "imp->bind = r_str_const (\"NONE\");"
    },
    {
        "line": 102,
        "fullcodeline": "imp->ordinal = import_count++;"
    },
    {
        "line": 103,
        "fullcodeline": "r_list_append (bin->imports_list, imp);"
    },
    {
        "line": 105,
        "fullcodeline": "RBinSymbol *sym = R_NEW0 (RBinSymbol);"
    },
    {
        "line": 106,
        "fullcodeline": "sym->name = r_str_newf (\"imp.%s\", imp->name);"
    },
    {
        "line": 107,
        "fullcodeline": "sym->type = r_str_const (\"FUNC\");"
    },
    {
        "line": 108,
        "fullcodeline": "sym->bind = r_str_const (\"NONE\");"
    },
    {
        "line": 111,
        "fullcodeline": "sym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;"
    },
    {
        "line": 112,
        "fullcodeline": "sym->ordinal = sym_count++;"
    },
    {
        "line": 113,
        "fullcodeline": "r_list_append (bin->methods_list, sym);"
    },
    {
        "line": 114,
        "fullcodeline": "sdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);"
    }
]