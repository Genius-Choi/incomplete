[
    {
        "line": 12,
        "fullcodeline": "int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us"
    },
    {
        "line": 14,
        "fullcodeline": "char_u\t*new_name = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "char_u\t*free_fname = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "int\t\tretval = FAIL;"
    },
    {
        "line": 29,
        "fullcodeline": "linenr_T\ttopline = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int\t\tnewcol = -1;"
    },
    {
        "line": 31,
        "fullcodeline": "int\t\tsolcol = -1;"
    },
    {
        "line": 33,
        "fullcodeline": "char_u\t*command = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "int\t\treadfile_flags = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "int\t\tdid_inc_redrawing_disabled = FALSE;"
    },
    {
        "line": 39,
        "fullcodeline": "long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;"
    },
    {
        "line": 48,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 399,
        "fullcodeline": "++RedrawingDisabled;"
    },
    {
        "line": 400,
        "fullcodeline": "did_inc_redrawing_disabled = TRUE;"
    },
    {
        "line": 402,
        "fullcodeline": "buf = curbuf;"
    },
    {
        "line": 427,
        "fullcodeline": "did_filetype = FALSE;"
    },
    {
        "line": 501,
        "fullcodeline": "retval = OK;"
    },
    {
        "line": 511,
        "fullcodeline": "check_arg_idx(curwin);"
    },
    {
        "line": 666,
        "fullcodeline": "check_lnums(FALSE);"
    },
    {
        "line": 706,
        "fullcodeline": "did_inc_redrawing_disabled = FALSE;"
    },
    {
        "line": 46,
        "fullcodeline": "if (eap != NULL)"
    },
    {
        "line": 50,
        "fullcodeline": "if (fnum != 0)"
    },
    {
        "line": 403,
        "fullcodeline": "if ((flags & ECMD_SET_HELP) || keep_help_flag)"
    },
    {
        "line": 417,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 513,
        "fullcodeline": "if (!auto_buf)"
    },
    {
        "line": 634,
        "fullcodeline": "if (command == NULL)"
    },
    {
        "line": 696,
        "fullcodeline": "if (command != NULL)"
    },
    {
        "line": 704,
        "fullcodeline": "if (RedrawingDisabled > 0)"
    },
    {
        "line": 707,
        "fullcodeline": "if (!skip_redraw)"
    },
    {
        "line": 718,
        "fullcodeline": "if (p_im && (State & MODE_INSERT) == 0)"
    },
    {
        "line": 47,
        "fullcodeline": "command = eap->do_ecmd_cmd;"
    },
    {
        "line": 54,
        "fullcodeline": "other_file = TRUE;"
    },
    {
        "line": 118,
        "fullcodeline": "if (  ((!other_file && !(flags & ECMD_OLDBUF))"
    },
    {
        "line": 121,
        "fullcodeline": "&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)"
    },
    {
        "line": 169,
        "fullcodeline": "int prev_alt_fnum = curwin->w_alt_fnum;"
    },
    {
        "line": 436,
        "fullcodeline": "if (!other_file && !oldbuf)\t\t// re-use the buffer"
    },
    {
        "line": 438,
        "fullcodeline": "set_last_cursor(curwin);\t// may set b_last_cursor"
    },
    {
        "line": 444,
        "fullcodeline": "buf = curbuf;"
    },
    {
        "line": 449,
        "fullcodeline": "set_bufref(&bufref, buf);"
    },
    {
        "line": 492,
        "fullcodeline": "buf_clear_file(curbuf);"
    },
    {
        "line": 506,
        "fullcodeline": "curbuf->b_flags &= ~BF_NOTEDITED;"
    },
    {
        "line": 542,
        "fullcodeline": "orig_pos = curwin->w_cursor;"
    },
    {
        "line": 543,
        "fullcodeline": "topline = curwin->w_topline;"
    },
    {
        "line": 587,
        "fullcodeline": "check_arg_idx(curwin);"
    },
    {
        "line": 672,
        "fullcodeline": "if (oldbuf && !auto_buf)"
    },
    {
        "line": 674,
        "fullcodeline": "int\tmsg_scroll_save = msg_scroll;"
    },
    {
        "line": 697,
        "fullcodeline": "do_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);"
    },
    {
        "line": 705,
        "fullcodeline": "--RedrawingDisabled;"
    },
    {
        "line": 709,
        "fullcodeline": "n = *so_ptr;"
    },
    {
        "line": 715,
        "fullcodeline": "redraw_curbuf_later(UPD_NOT_VALID);\t// redraw this buffer later"
    },
    {
        "line": 719,
        "fullcodeline": "need_start_insertmode = TRUE;"
    },
    {
        "line": 749,
        "fullcodeline": "if (did_inc_redrawing_disabled && RedrawingDisabled > 0)"
    },
    {
        "line": 52,
        "fullcodeline": "if (fnum == curbuf->b_fnum)\t// file is already being edited"
    },
    {
        "line": 119,
        "fullcodeline": "|| (curbuf->b_nwindows == 1"
    },
    {
        "line": 217,
        "fullcodeline": "if (buf == NULL)"
    },
    {
        "line": 223,
        "fullcodeline": "if (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet"
    },
    {
        "line": 257,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 394,
        "fullcodeline": "oldbuf = (flags & ECMD_OLDBUF);"
    },
    {
        "line": 445,
        "fullcodeline": "if (buf->b_fname != NULL)"
    },
    {
        "line": 486,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 544,
        "fullcodeline": "if (!oldbuf)\t\t\t    // need to read the file"
    },
    {
        "line": 603,
        "fullcodeline": "if (curwin->w_topline == topline)"
    },
    {
        "line": 636,
        "fullcodeline": "if (newcol >= 0)\t// position set by autocommands"
    },
    {
        "line": 83,
        "fullcodeline": "if (sfname == NULL)"
    },
    {
        "line": 94,
        "fullcodeline": "if (ffname == NULL)"
    },
    {
        "line": 120,
        "fullcodeline": "&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))"
    },
    {
        "line": 124,
        "fullcodeline": "| (eap == NULL ? 0 : CCGD_EXCMD)))"
    },
    {
        "line": 126,
        "fullcodeline": "if (fnum == 0 && other_file && ffname != NULL)"
    },
    {
        "line": 171,
        "fullcodeline": "if (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))"
    },
    {
        "line": 180,
        "fullcodeline": "buf = buflist_findnr(fnum);"
    },
    {
        "line": 219,
        "fullcodeline": "if (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)"
    },
    {
        "line": 221,
        "fullcodeline": "curwin->w_alt_fnum = prev_alt_fnum;"
    },
    {
        "line": 225,
        "fullcodeline": "oldbuf = FALSE;"
    },
    {
        "line": 244,
        "fullcodeline": "if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)"
    },
    {
        "line": 246,
        "fullcodeline": "pos = buflist_findfpos(buf);"
    },
    {
        "line": 247,
        "fullcodeline": "newlnum = pos->lnum;"
    },
    {
        "line": 248,
        "fullcodeline": "solcol = pos->col;"
    },
    {
        "line": 260,
        "fullcodeline": "int\t\tsave_cmdwin_type = cmdwin_type;"
    },
    {
        "line": 277,
        "fullcodeline": "save_au_new_curbuf = au_new_curbuf;"
    },
    {
        "line": 278,
        "fullcodeline": "set_bufref(&au_new_curbuf, buf);"
    },
    {
        "line": 279,
        "fullcodeline": "apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 411,
        "fullcodeline": "if (!curbuf->b_help)"
    },
    {
        "line": 439,
        "fullcodeline": "if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)"
    },
    {
        "line": 441,
        "fullcodeline": "newlnum = curwin->w_cursor.lnum;"
    },
    {
        "line": 442,
        "fullcodeline": "solcol = curwin->w_cursor.col;"
    },
    {
        "line": 446,
        "fullcodeline": "new_name = vim_strsave(buf->b_fname);"
    },
    {
        "line": 454,
        "fullcodeline": "if (!(curbuf->b_flags & BF_NEVERLOADED)"
    },
    {
        "line": 455,
        "fullcodeline": "&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))"
    },
    {
        "line": 458,
        "fullcodeline": "u_sync(FALSE);"
    },
    {
        "line": 465,
        "fullcodeline": "u_unchanged(curbuf);"
    },
    {
        "line": 466,
        "fullcodeline": "buf_freeall(curbuf, BFA_KEEP_UNDO);"
    },
    {
        "line": 469,
        "fullcodeline": "readfile_flags = READ_KEEP_UNDO;"
    },
    {
        "line": 476,
        "fullcodeline": "if (!bufref_valid(&bufref))"
    },
    {
        "line": 552,
        "fullcodeline": "swap_exists_action = SEA_DIALOG;"
    },
    {
        "line": 553,
        "fullcodeline": "curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag"
    },
    {
        "line": 592,
        "fullcodeline": "if (!EQUAL_POS(curwin->w_cursor, orig_pos))"
    },
    {
        "line": 594,
        "fullcodeline": "char_u *text = ml_get_curline();"
    },
    {
        "line": 604,
        "fullcodeline": "topline = 0;"
    },
    {
        "line": 678,
        "fullcodeline": "if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)"
    },
    {
        "line": 679,
        "fullcodeline": "msg_scroll = FALSE;"
    },
    {
        "line": 681,
        "fullcodeline": "check_for_delay(FALSE);"
    },
    {
        "line": 686,
        "fullcodeline": "if (!shortmess(SHM_FILEINFO))"
    },
    {
        "line": 687,
        "fullcodeline": "fileinfo(FALSE, TRUE, FALSE);"
    },
    {
        "line": 710,
        "fullcodeline": "if (topline == 0 && command == NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "sfname = ffname;"
    },
    {
        "line": 90,
        "fullcodeline": "if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))"
    },
    {
        "line": 91,
        "fullcodeline": "&& (ffname == NULL || *ffname == NUL))"
    },
    {
        "line": 95,
        "fullcodeline": "other_file = TRUE;"
    },
    {
        "line": 123,
        "fullcodeline": "| ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)"
    },
    {
        "line": 127,
        "fullcodeline": "(void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);"
    },
    {
        "line": 175,
        "fullcodeline": "if (oldwin != NULL)"
    },
    {
        "line": 209,
        "fullcodeline": "buf = buflist_new(ffname, sfname, 0L,"
    },
    {
        "line": 215,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 229,
        "fullcodeline": "oldbuf = TRUE;"
    },
    {
        "line": 230,
        "fullcodeline": "set_bufref(&bufref, buf);"
    },
    {
        "line": 275,
        "fullcodeline": "if (buf->b_fname != NULL)"
    },
    {
        "line": 296,
        "fullcodeline": "if (buf == curbuf)\t\t// already in new buffer"
    },
    {
        "line": 391,
        "fullcodeline": "if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)"
    },
    {
        "line": 412,
        "fullcodeline": "set_buflisted(TRUE);"
    },
    {
        "line": 448,
        "fullcodeline": "new_name = NULL;"
    },
    {
        "line": 459,
        "fullcodeline": "if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)"
    },
    {
        "line": 472,
        "fullcodeline": "buf_freeall(curbuf, 0);   // free all things for buffer"
    },
    {
        "line": 564,
        "fullcodeline": "(void)open_buffer(FALSE, eap, readfile_flags);"
    },
    {
        "line": 570,
        "fullcodeline": "if (swap_exists_action == SEA_QUIT)"
    },
    {
        "line": 579,
        "fullcodeline": "do_modelines(OPT_WINONLY);"
    },
    {
        "line": 581,
        "fullcodeline": "apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,"
    },
    {
        "line": 122,
        "fullcodeline": "| (other_file ? 0 : CCGD_MULTWIN)"
    },
    {
        "line": 173,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)"
    },
    {
        "line": 174,
        "fullcodeline": "curwin->w_alt_fnum = curbuf->b_fnum;"
    },
    {
        "line": 176,
        "fullcodeline": "buflist_altfpos(oldwin);"
    },
    {
        "line": 183,
        "fullcodeline": "if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))"
    },
    {
        "line": 213,
        "fullcodeline": "if (oldwin != NULL)"
    },
    {
        "line": 231,
        "fullcodeline": "(void)buf_check_timestamp(buf, FALSE);"
    },
    {
        "line": 276,
        "fullcodeline": "new_name = vim_strsave(buf->b_fname);"
    },
    {
        "line": 281,
        "fullcodeline": "if (!bufref_valid(&au_new_curbuf))"
    },
    {
        "line": 297,
        "fullcodeline": "auto_buf = TRUE;"
    },
    {
        "line": 559,
        "fullcodeline": "readfile_flags |= READ_NOWINENTER;"
    },
    {
        "line": 571,
        "fullcodeline": "retval = FAIL;"
    },
    {
        "line": 596,
        "fullcodeline": "if (curwin->w_cursor.lnum != orig_pos.lnum"
    },
    {
        "line": 597,
        "fullcodeline": "|| curwin->w_cursor.col != (int)(skipwhite(text) - text))"
    },
    {
        "line": 599,
        "fullcodeline": "newlnum = curwin->w_cursor.lnum;"
    },
    {
        "line": 600,
        "fullcodeline": "newcol = curwin->w_cursor.col;"
    },
    {
        "line": 642,
        "fullcodeline": "else if (newlnum > 0)\t// line number from caller or old position"
    },
    {
        "line": 187,
        "fullcodeline": "linenr_T\ttlnum = 0;"
    },
    {
        "line": 198,
        "fullcodeline": "newbuf = buflist_new(ffname, sfname, tlnum,"
    },
    {
        "line": 210,
        "fullcodeline": "BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));"
    },
    {
        "line": 214,
        "fullcodeline": "oldwin = curwin;"
    },
    {
        "line": 234,
        "fullcodeline": "if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)"
    },
    {
        "line": 300,
        "fullcodeline": "win_T\t    *the_curwin = curwin;"
    },
    {
        "line": 302,
        "fullcodeline": "buf_T\t    *was_curbuf = curbuf;"
    },
    {
        "line": 306,
        "fullcodeline": "the_curwin->w_closing = TRUE;"
    },
    {
        "line": 307,
        "fullcodeline": "++buf->b_locked;"
    },
    {
        "line": 314,
        "fullcodeline": "u_sync(FALSE);"
    },
    {
        "line": 315,
        "fullcodeline": "did_decrement = close_buffer(oldwin, curbuf,"
    },
    {
        "line": 321,
        "fullcodeline": "--buf->b_locked;"
    },
    {
        "line": 377,
        "fullcodeline": "get_winopts(curbuf);"
    },
    {
        "line": 583,
        "fullcodeline": "if ((flags & ECMD_NOWINENTER) == 0)"
    },
    {
        "line": 584,
        "fullcodeline": "apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,"
    },
    {
        "line": 97,
        "fullcodeline": "else if (*ffname == NUL && curbuf->b_ffname == NULL)"
    },
    {
        "line": 98,
        "fullcodeline": "other_file = FALSE;"
    },
    {
        "line": 190,
        "fullcodeline": "if (command != NULL)"
    },
    {
        "line": 200,
        "fullcodeline": "if (newbuf != NULL)"
    },
    {
        "line": 309,
        "fullcodeline": "if (curbuf == old_curbuf.br_buf)"
    },
    {
        "line": 340,
        "fullcodeline": "if (buf == curbuf)\t\t// already in new buffer"
    },
    {
        "line": 106,
        "fullcodeline": "free_fname = fix_fname(ffname); // may expand to full path name"
    },
    {
        "line": 109,
        "fullcodeline": "other_file = otherfile(ffname);"
    },
    {
        "line": 192,
        "fullcodeline": "tlnum = atol((char *)command);"
    },
    {
        "line": 199,
        "fullcodeline": "BLN_LISTED | BLN_NOCURWIN);"
    },
    {
        "line": 310,
        "fullcodeline": "buf_copy_options(buf, BCO_ENTER);"
    },
    {
        "line": 316,
        "fullcodeline": "(flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);"
    },
    {
        "line": 333,
        "fullcodeline": "if (!bufref_valid(&au_new_curbuf))"
    },
    {
        "line": 348,
        "fullcodeline": "auto_buf = TRUE;"
    },
    {
        "line": 646,
        "fullcodeline": "if (solcol >= 0 && !p_sol)"
    },
    {
        "line": 661,
        "fullcodeline": "beginline(BL_WHITE | BL_FIX);"
    },
    {
        "line": 101,
        "fullcodeline": "if (*ffname == NUL)\t\t    // re-edit with same file name"
    },
    {
        "line": 107,
        "fullcodeline": "if (free_fname != NULL)"
    },
    {
        "line": 193,
        "fullcodeline": "if (tlnum <= 0)"
    },
    {
        "line": 204,
        "fullcodeline": "if (tlnum > 0)"
    },
    {
        "line": 361,
        "fullcodeline": "curwin->w_buffer = buf;"
    },
    {
        "line": 362,
        "fullcodeline": "curbuf = buf;"
    },
    {
        "line": 363,
        "fullcodeline": "++curbuf->b_nwindows;"
    },
    {
        "line": 103,
        "fullcodeline": "ffname = curbuf->b_ffname;"
    },
    {
        "line": 104,
        "fullcodeline": "sfname = curbuf->b_fname;"
    },
    {
        "line": 108,
        "fullcodeline": "ffname = free_fname;"
    },
    {
        "line": 194,
        "fullcodeline": "tlnum = 1L;"
    },
    {
        "line": 344,
        "fullcodeline": "if (did_decrement && buf_valid(was_curbuf))"
    },
    {
        "line": 345,
        "fullcodeline": "++was_curbuf->b_nwindows;"
    },
    {
        "line": 346,
        "fullcodeline": "if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)"
    },
    {
        "line": 366,
        "fullcodeline": "if (!oldbuf && eap != NULL)"
    },
    {
        "line": 655,
        "fullcodeline": "beginline(BL_SOL | BL_FIX);"
    },
    {
        "line": 368,
        "fullcodeline": "set_file_options(TRUE, eap);"
    },
    {
        "line": 369,
        "fullcodeline": "set_forced_fenc(eap);"
    }
]