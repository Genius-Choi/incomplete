[
    {
        "line": 12,
        "fullcodeline": "int\t\tauto_buf = FALSE;\t// TRUE if autocommands brought us"
    },
    {
        "line": 14,
        "fullcodeline": "char_u\t*new_name = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "char_u\t*free_fname = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "int\t\tretval = FAIL;"
    },
    {
        "line": 29,
        "fullcodeline": "linenr_T\ttopline = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int\t\tnewcol = -1;"
    },
    {
        "line": 31,
        "fullcodeline": "int\t\tsolcol = -1;"
    },
    {
        "line": 33,
        "fullcodeline": "char_u\t*command = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "int\t\treadfile_flags = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "int\t\tdid_inc_redrawing_disabled = FALSE;"
    },
    {
        "line": 39,
        "fullcodeline": "long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;"
    },
    {
        "line": 48,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 405,
        "fullcodeline": "++RedrawingDisabled;"
    },
    {
        "line": 406,
        "fullcodeline": "did_inc_redrawing_disabled = TRUE;"
    },
    {
        "line": 408,
        "fullcodeline": "buf = curbuf;"
    },
    {
        "line": 433,
        "fullcodeline": "did_filetype = FALSE;"
    },
    {
        "line": 507,
        "fullcodeline": "retval = OK;"
    },
    {
        "line": 517,
        "fullcodeline": "check_arg_idx(curwin);"
    },
    {
        "line": 672,
        "fullcodeline": "check_lnums(FALSE);"
    },
    {
        "line": 712,
        "fullcodeline": "did_inc_redrawing_disabled = FALSE;"
    },
    {
        "line": 46,
        "fullcodeline": "if (eap != NULL)"
    },
    {
        "line": 50,
        "fullcodeline": "if (fnum != 0)"
    },
    {
        "line": 409,
        "fullcodeline": "if ((flags & ECMD_SET_HELP) || keep_help_flag)"
    },
    {
        "line": 423,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 519,
        "fullcodeline": "if (!auto_buf)"
    },
    {
        "line": 640,
        "fullcodeline": "if (command == NULL)"
    },
    {
        "line": 702,
        "fullcodeline": "if (command != NULL)"
    },
    {
        "line": 710,
        "fullcodeline": "if (RedrawingDisabled > 0)"
    },
    {
        "line": 713,
        "fullcodeline": "if (!skip_redraw)"
    },
    {
        "line": 724,
        "fullcodeline": "if (p_im && (State & MODE_INSERT) == 0)"
    },
    {
        "line": 47,
        "fullcodeline": "command = eap->do_ecmd_cmd;"
    },
    {
        "line": 54,
        "fullcodeline": "other_file = TRUE;"
    },
    {
        "line": 118,
        "fullcodeline": "if (  ((!other_file && !(flags & ECMD_OLDBUF))"
    },
    {
        "line": 121,
        "fullcodeline": "&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)"
    },
    {
        "line": 140,
        "fullcodeline": "if (oldwin != NULL && !win_valid(oldwin))"
    },
    {
        "line": 141,
        "fullcodeline": "oldwin = NULL;"
    },
    {
        "line": 175,
        "fullcodeline": "int prev_alt_fnum = curwin->w_alt_fnum;"
    },
    {
        "line": 442,
        "fullcodeline": "if (!other_file && !oldbuf)\t\t// re-use the buffer"
    },
    {
        "line": 444,
        "fullcodeline": "set_last_cursor(curwin);\t// may set b_last_cursor"
    },
    {
        "line": 450,
        "fullcodeline": "buf = curbuf;"
    },
    {
        "line": 455,
        "fullcodeline": "set_bufref(&bufref, buf);"
    },
    {
        "line": 498,
        "fullcodeline": "buf_clear_file(curbuf);"
    },
    {
        "line": 512,
        "fullcodeline": "curbuf->b_flags &= ~BF_NOTEDITED;"
    },
    {
        "line": 548,
        "fullcodeline": "orig_pos = curwin->w_cursor;"
    },
    {
        "line": 549,
        "fullcodeline": "topline = curwin->w_topline;"
    },
    {
        "line": 593,
        "fullcodeline": "check_arg_idx(curwin);"
    },
    {
        "line": 678,
        "fullcodeline": "if (oldbuf && !auto_buf)"
    },
    {
        "line": 680,
        "fullcodeline": "int\tmsg_scroll_save = msg_scroll;"
    },
    {
        "line": 703,
        "fullcodeline": "do_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);"
    },
    {
        "line": 711,
        "fullcodeline": "--RedrawingDisabled;"
    },
    {
        "line": 715,
        "fullcodeline": "n = *so_ptr;"
    },
    {
        "line": 721,
        "fullcodeline": "redraw_curbuf_later(UPD_NOT_VALID);\t// redraw this buffer later"
    },
    {
        "line": 725,
        "fullcodeline": "need_start_insertmode = TRUE;"
    },
    {
        "line": 755,
        "fullcodeline": "if (did_inc_redrawing_disabled && RedrawingDisabled > 0)"
    },
    {
        "line": 52,
        "fullcodeline": "if (fnum == curbuf->b_fnum)\t// file is already being edited"
    },
    {
        "line": 119,
        "fullcodeline": "|| (curbuf->b_nwindows == 1"
    },
    {
        "line": 223,
        "fullcodeline": "if (buf == NULL)"
    },
    {
        "line": 229,
        "fullcodeline": "if (buf->b_ml.ml_mfp == NULL)\t\t// no memfile yet"
    },
    {
        "line": 263,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 400,
        "fullcodeline": "oldbuf = (flags & ECMD_OLDBUF);"
    },
    {
        "line": 451,
        "fullcodeline": "if (buf->b_fname != NULL)"
    },
    {
        "line": 492,
        "fullcodeline": "if (buf != curbuf)"
    },
    {
        "line": 550,
        "fullcodeline": "if (!oldbuf)\t\t\t    // need to read the file"
    },
    {
        "line": 609,
        "fullcodeline": "if (curwin->w_topline == topline)"
    },
    {
        "line": 642,
        "fullcodeline": "if (newcol >= 0)\t// position set by autocommands"
    },
    {
        "line": 83,
        "fullcodeline": "if (sfname == NULL)"
    },
    {
        "line": 94,
        "fullcodeline": "if (ffname == NULL)"
    },
    {
        "line": 120,
        "fullcodeline": "&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))"
    },
    {
        "line": 124,
        "fullcodeline": "| (eap == NULL ? 0 : CCGD_EXCMD)))"
    },
    {
        "line": 126,
        "fullcodeline": "if (fnum == 0 && other_file && ffname != NULL)"
    },
    {
        "line": 177,
        "fullcodeline": "if (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))"
    },
    {
        "line": 186,
        "fullcodeline": "buf = buflist_findnr(fnum);"
    },
    {
        "line": 225,
        "fullcodeline": "if (curwin->w_alt_fnum == buf->b_fnum && prev_alt_fnum != 0)"
    },
    {
        "line": 227,
        "fullcodeline": "curwin->w_alt_fnum = prev_alt_fnum;"
    },
    {
        "line": 231,
        "fullcodeline": "oldbuf = FALSE;"
    },
    {
        "line": 250,
        "fullcodeline": "if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)"
    },
    {
        "line": 252,
        "fullcodeline": "pos = buflist_findfpos(buf);"
    },
    {
        "line": 253,
        "fullcodeline": "newlnum = pos->lnum;"
    },
    {
        "line": 254,
        "fullcodeline": "solcol = pos->col;"
    },
    {
        "line": 266,
        "fullcodeline": "int\t\tsave_cmdwin_type = cmdwin_type;"
    },
    {
        "line": 283,
        "fullcodeline": "save_au_new_curbuf = au_new_curbuf;"
    },
    {
        "line": 284,
        "fullcodeline": "set_bufref(&au_new_curbuf, buf);"
    },
    {
        "line": 285,
        "fullcodeline": "apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);"
    },
    {
        "line": 417,
        "fullcodeline": "if (!curbuf->b_help)"
    },
    {
        "line": 445,
        "fullcodeline": "if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)"
    },
    {
        "line": 447,
        "fullcodeline": "newlnum = curwin->w_cursor.lnum;"
    },
    {
        "line": 448,
        "fullcodeline": "solcol = curwin->w_cursor.col;"
    },
    {
        "line": 452,
        "fullcodeline": "new_name = vim_strsave(buf->b_fname);"
    },
    {
        "line": 460,
        "fullcodeline": "if (!(curbuf->b_flags & BF_NEVERLOADED)"
    },
    {
        "line": 461,
        "fullcodeline": "&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))"
    },
    {
        "line": 464,
        "fullcodeline": "u_sync(FALSE);"
    },
    {
        "line": 471,
        "fullcodeline": "u_unchanged(curbuf);"
    },
    {
        "line": 472,
        "fullcodeline": "buf_freeall(curbuf, BFA_KEEP_UNDO);"
    },
    {
        "line": 475,
        "fullcodeline": "readfile_flags = READ_KEEP_UNDO;"
    },
    {
        "line": 482,
        "fullcodeline": "if (!bufref_valid(&bufref))"
    },
    {
        "line": 558,
        "fullcodeline": "swap_exists_action = SEA_DIALOG;"
    },
    {
        "line": 559,
        "fullcodeline": "curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag"
    },
    {
        "line": 598,
        "fullcodeline": "if (!EQUAL_POS(curwin->w_cursor, orig_pos))"
    },
    {
        "line": 600,
        "fullcodeline": "char_u *text = ml_get_curline();"
    },
    {
        "line": 610,
        "fullcodeline": "topline = 0;"
    },
    {
        "line": 684,
        "fullcodeline": "if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)"
    },
    {
        "line": 685,
        "fullcodeline": "msg_scroll = FALSE;"
    },
    {
        "line": 687,
        "fullcodeline": "check_for_delay(FALSE);"
    },
    {
        "line": 692,
        "fullcodeline": "if (!shortmess(SHM_FILEINFO))"
    },
    {
        "line": 693,
        "fullcodeline": "fileinfo(FALSE, TRUE, FALSE);"
    },
    {
        "line": 716,
        "fullcodeline": "if (topline == 0 && command == NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "sfname = ffname;"
    },
    {
        "line": 90,
        "fullcodeline": "if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))"
    },
    {
        "line": 91,
        "fullcodeline": "&& (ffname == NULL || *ffname == NUL))"
    },
    {
        "line": 95,
        "fullcodeline": "other_file = TRUE;"
    },
    {
        "line": 123,
        "fullcodeline": "| ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)"
    },
    {
        "line": 127,
        "fullcodeline": "(void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);"
    },
    {
        "line": 181,
        "fullcodeline": "if (oldwin != NULL)"
    },
    {
        "line": 215,
        "fullcodeline": "buf = buflist_new(ffname, sfname, 0L,"
    },
    {
        "line": 221,
        "fullcodeline": "set_bufref(&old_curbuf, curbuf);"
    },
    {
        "line": 235,
        "fullcodeline": "oldbuf = TRUE;"
    },
    {
        "line": 236,
        "fullcodeline": "set_bufref(&bufref, buf);"
    },
    {
        "line": 281,
        "fullcodeline": "if (buf->b_fname != NULL)"
    },
    {
        "line": 302,
        "fullcodeline": "if (buf == curbuf)\t\t// already in new buffer"
    },
    {
        "line": 397,
        "fullcodeline": "if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)"
    },
    {
        "line": 418,
        "fullcodeline": "set_buflisted(TRUE);"
    },
    {
        "line": 454,
        "fullcodeline": "new_name = NULL;"
    },
    {
        "line": 465,
        "fullcodeline": "if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)"
    },
    {
        "line": 478,
        "fullcodeline": "buf_freeall(curbuf, 0);   // free all things for buffer"
    },
    {
        "line": 570,
        "fullcodeline": "(void)open_buffer(FALSE, eap, readfile_flags);"
    },
    {
        "line": 576,
        "fullcodeline": "if (swap_exists_action == SEA_QUIT)"
    },
    {
        "line": 585,
        "fullcodeline": "do_modelines(OPT_WINONLY);"
    },
    {
        "line": 587,
        "fullcodeline": "apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE,"
    },
    {
        "line": 122,
        "fullcodeline": "| (other_file ? 0 : CCGD_MULTWIN)"
    },
    {
        "line": 179,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)"
    },
    {
        "line": 180,
        "fullcodeline": "curwin->w_alt_fnum = curbuf->b_fnum;"
    },
    {
        "line": 182,
        "fullcodeline": "buflist_altfpos(oldwin);"
    },
    {
        "line": 189,
        "fullcodeline": "if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))"
    },
    {
        "line": 219,
        "fullcodeline": "if (oldwin != NULL)"
    },
    {
        "line": 237,
        "fullcodeline": "(void)buf_check_timestamp(buf, FALSE);"
    },
    {
        "line": 282,
        "fullcodeline": "new_name = vim_strsave(buf->b_fname);"
    },
    {
        "line": 287,
        "fullcodeline": "if (!bufref_valid(&au_new_curbuf))"
    },
    {
        "line": 303,
        "fullcodeline": "auto_buf = TRUE;"
    },
    {
        "line": 565,
        "fullcodeline": "readfile_flags |= READ_NOWINENTER;"
    },
    {
        "line": 577,
        "fullcodeline": "retval = FAIL;"
    },
    {
        "line": 602,
        "fullcodeline": "if (curwin->w_cursor.lnum != orig_pos.lnum"
    },
    {
        "line": 603,
        "fullcodeline": "|| curwin->w_cursor.col != (int)(skipwhite(text) - text))"
    },
    {
        "line": 605,
        "fullcodeline": "newlnum = curwin->w_cursor.lnum;"
    },
    {
        "line": 606,
        "fullcodeline": "newcol = curwin->w_cursor.col;"
    },
    {
        "line": 648,
        "fullcodeline": "else if (newlnum > 0)\t// line number from caller or old position"
    },
    {
        "line": 193,
        "fullcodeline": "linenr_T\ttlnum = 0;"
    },
    {
        "line": 204,
        "fullcodeline": "newbuf = buflist_new(ffname, sfname, tlnum,"
    },
    {
        "line": 216,
        "fullcodeline": "BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));"
    },
    {
        "line": 220,
        "fullcodeline": "oldwin = curwin;"
    },
    {
        "line": 240,
        "fullcodeline": "if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)"
    },
    {
        "line": 306,
        "fullcodeline": "win_T\t    *the_curwin = curwin;"
    },
    {
        "line": 308,
        "fullcodeline": "buf_T\t    *was_curbuf = curbuf;"
    },
    {
        "line": 312,
        "fullcodeline": "the_curwin->w_closing = TRUE;"
    },
    {
        "line": 313,
        "fullcodeline": "++buf->b_locked;"
    },
    {
        "line": 320,
        "fullcodeline": "u_sync(FALSE);"
    },
    {
        "line": 321,
        "fullcodeline": "did_decrement = close_buffer(oldwin, curbuf,"
    },
    {
        "line": 327,
        "fullcodeline": "--buf->b_locked;"
    },
    {
        "line": 383,
        "fullcodeline": "get_winopts(curbuf);"
    },
    {
        "line": 589,
        "fullcodeline": "if ((flags & ECMD_NOWINENTER) == 0)"
    },
    {
        "line": 590,
        "fullcodeline": "apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE,"
    },
    {
        "line": 97,
        "fullcodeline": "else if (*ffname == NUL && curbuf->b_ffname == NULL)"
    },
    {
        "line": 98,
        "fullcodeline": "other_file = FALSE;"
    },
    {
        "line": 196,
        "fullcodeline": "if (command != NULL)"
    },
    {
        "line": 206,
        "fullcodeline": "if (newbuf != NULL)"
    },
    {
        "line": 315,
        "fullcodeline": "if (curbuf == old_curbuf.br_buf)"
    },
    {
        "line": 346,
        "fullcodeline": "if (buf == curbuf)\t\t// already in new buffer"
    },
    {
        "line": 106,
        "fullcodeline": "free_fname = fix_fname(ffname); // may expand to full path name"
    },
    {
        "line": 109,
        "fullcodeline": "other_file = otherfile(ffname);"
    },
    {
        "line": 198,
        "fullcodeline": "tlnum = atol((char *)command);"
    },
    {
        "line": 205,
        "fullcodeline": "BLN_LISTED | BLN_NOCURWIN);"
    },
    {
        "line": 316,
        "fullcodeline": "buf_copy_options(buf, BCO_ENTER);"
    },
    {
        "line": 322,
        "fullcodeline": "(flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);"
    },
    {
        "line": 339,
        "fullcodeline": "if (!bufref_valid(&au_new_curbuf))"
    },
    {
        "line": 354,
        "fullcodeline": "auto_buf = TRUE;"
    },
    {
        "line": 652,
        "fullcodeline": "if (solcol >= 0 && !p_sol)"
    },
    {
        "line": 667,
        "fullcodeline": "beginline(BL_WHITE | BL_FIX);"
    },
    {
        "line": 101,
        "fullcodeline": "if (*ffname == NUL)\t\t    // re-edit with same file name"
    },
    {
        "line": 107,
        "fullcodeline": "if (free_fname != NULL)"
    },
    {
        "line": 199,
        "fullcodeline": "if (tlnum <= 0)"
    },
    {
        "line": 210,
        "fullcodeline": "if (tlnum > 0)"
    },
    {
        "line": 367,
        "fullcodeline": "curwin->w_buffer = buf;"
    },
    {
        "line": 368,
        "fullcodeline": "curbuf = buf;"
    },
    {
        "line": 369,
        "fullcodeline": "++curbuf->b_nwindows;"
    },
    {
        "line": 103,
        "fullcodeline": "ffname = curbuf->b_ffname;"
    },
    {
        "line": 104,
        "fullcodeline": "sfname = curbuf->b_fname;"
    },
    {
        "line": 108,
        "fullcodeline": "ffname = free_fname;"
    },
    {
        "line": 200,
        "fullcodeline": "tlnum = 1L;"
    },
    {
        "line": 350,
        "fullcodeline": "if (did_decrement && buf_valid(was_curbuf))"
    },
    {
        "line": 351,
        "fullcodeline": "++was_curbuf->b_nwindows;"
    },
    {
        "line": 352,
        "fullcodeline": "if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)"
    },
    {
        "line": 372,
        "fullcodeline": "if (!oldbuf && eap != NULL)"
    },
    {
        "line": 661,
        "fullcodeline": "beginline(BL_SOL | BL_FIX);"
    },
    {
        "line": 374,
        "fullcodeline": "set_file_options(TRUE, eap);"
    },
    {
        "line": 375,
        "fullcodeline": "set_forced_fenc(eap);"
    }
]