[
    {
        "line": 5,
        "fullcodeline": "lex->depth++;"
    },
    {
        "line": 6,
        "fullcodeline": "if(lex->depth > JSON_PARSER_MAX_DEPTH) {"
    },
    {
        "line": 70,
        "fullcodeline": "if(!json)"
    },
    {
        "line": 7,
        "fullcodeline": "error_set(error, lex, \"maximum parsing depth reached\");"
    },
    {
        "line": 42,
        "fullcodeline": "json = json_true();"
    },
    {
        "line": 46,
        "fullcodeline": "json = json_false();"
    },
    {
        "line": 50,
        "fullcodeline": "json = json_null();"
    },
    {
        "line": 54,
        "fullcodeline": "json = parse_object(lex, flags, error);"
    },
    {
        "line": 58,
        "fullcodeline": "json = parse_array(lex, flags, error);"
    },
    {
        "line": 13,
        "fullcodeline": "const char *value = lex->value.string.val;"
    },
    {
        "line": 14,
        "fullcodeline": "size_t len = lex->value.string.len;"
    },
    {
        "line": 23,
        "fullcodeline": "json = jsonp_stringn_nocheck_own(value, len);"
    },
    {
        "line": 32,
        "fullcodeline": "json = json_integer(lex->value.integer);"
    },
    {
        "line": 37,
        "fullcodeline": "json = json_real(lex->value.real);"
    },
    {
        "line": 16,
        "fullcodeline": "if(!(flags & JSON_ALLOW_NUL)) {"
    },
    {
        "line": 17,
        "fullcodeline": "if(memchr(value, '\\0', len)) {"
    }
]