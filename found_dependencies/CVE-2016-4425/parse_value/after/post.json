[
    {
        "line": 5,
        "fullcodeline": "lex->depth++;"
    },
    {
        "line": 73,
        "fullcodeline": "lex->depth--;"
    },
    {
        "line": 6,
        "fullcodeline": "if(lex->depth > JSON_PARSER_MAX_DEPTH) {"
    },
    {
        "line": 70,
        "fullcodeline": "if(!json)"
    },
    {
        "line": 7,
        "fullcodeline": "error_set(error, lex, \"maximum parsing depth reached\");"
    },
    {
        "line": 42,
        "fullcodeline": "json = json_true();"
    },
    {
        "line": 46,
        "fullcodeline": "json = json_false();"
    },
    {
        "line": 50,
        "fullcodeline": "json = json_null();"
    },
    {
        "line": 54,
        "fullcodeline": "json = parse_object(lex, flags, error);"
    },
    {
        "line": 58,
        "fullcodeline": "json = parse_array(lex, flags, error);"
    },
    {
        "line": 62,
        "fullcodeline": "error_set(error, lex, \"invalid token\");"
    },
    {
        "line": 66,
        "fullcodeline": "error_set(error, lex, \"unexpected token\");"
    },
    {
        "line": 23,
        "fullcodeline": "json = jsonp_stringn_nocheck_own(value, len);"
    },
    {
        "line": 32,
        "fullcodeline": "json = json_integer(lex->value.integer);"
    },
    {
        "line": 37,
        "fullcodeline": "json = json_real(lex->value.real);"
    },
    {
        "line": 16,
        "fullcodeline": "if(!(flags & JSON_ALLOW_NUL)) {"
    },
    {
        "line": 25,
        "fullcodeline": "lex->value.string.val = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "lex->value.string.len = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "if(memchr(value, '\\0', len)) {"
    },
    {
        "line": 18,
        "fullcodeline": "error_set(error, lex, \"\\\\u0000 is not allowed without JSON_ALLOW_NUL\");"
    }
]