[
    {
        "line": 7,
        "fullcodeline": "size_t req_size = NLA_ALIGN(attr_len);"
    },
    {
        "line": 14,
        "fullcodeline": "new_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);"
    },
    {
        "line": 25,
        "fullcodeline": "acts = nla_alloc_flow_actions(new_acts_size);"
    },
    {
        "line": 29,
        "fullcodeline": "memcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);"
    },
    {
        "line": 30,
        "fullcodeline": "acts->actions_len = (*sfa)->actions_len;"
    },
    {
        "line": 32,
        "fullcodeline": "kfree(*sfa);"
    },
    {
        "line": 33,
        "fullcodeline": "*sfa = acts;"
    },
    {
        "line": 36,
        "fullcodeline": "(*sfa)->actions_len += req_size;"
    },
    {
        "line": 11,
        "fullcodeline": "if (req_size <= (ksize(*sfa) - next_offset))"
    },
    {
        "line": 16,
        "fullcodeline": "if (new_acts_size > MAX_ACTIONS_BUFSIZE) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (IS_ERR(acts))"
    },
    {
        "line": 37,
        "fullcodeline": "return  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);"
    },
    {
        "line": 22,
        "fullcodeline": "new_acts_size = MAX_ACTIONS_BUFSIZE;"
    },
    {
        "line": 17,
        "fullcodeline": "if ((next_offset + req_size) > MAX_ACTIONS_BUFSIZE) {"
    },
    {
        "line": 27,
        "fullcodeline": "return (void *)acts;"
    },
    {
        "line": 18,
        "fullcodeline": "OVS_NLERR(log, \"Flow action size exceeds max %u\","
    },
    {
        "line": 20,
        "fullcodeline": "return ERR_PTR(-EMSGSIZE);"
    }
]