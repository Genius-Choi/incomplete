[
    {
        "line": 3,
        "fullcodeline": "struct attach_clone_payload* payload = (struct attach_clone_payload*)data;"
    },
    {
        "line": 4,
        "fullcodeline": "int ipc_socket = payload->ipc_socket;"
    },
    {
        "line": 5,
        "fullcodeline": "lxc_attach_options_t* options = payload->options;"
    },
    {
        "line": 6,
        "fullcodeline": "struct lxc_proc_context_info* init_ctx = payload->init_ctx;"
    },
    {
        "line": 22,
        "fullcodeline": "expected = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "status = -1;"
    },
    {
        "line": 24,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);"
    },
    {
        "line": 71,
        "fullcodeline": "ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);"
    },
    {
        "line": 79,
        "fullcodeline": "new_uid = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "new_gid = 0;"
    },
    {
        "line": 122,
        "fullcodeline": "status = 1;"
    },
    {
        "line": 123,
        "fullcodeline": "ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));"
    },
    {
        "line": 133,
        "fullcodeline": "expected = 2;"
    },
    {
        "line": 134,
        "fullcodeline": "status = -1;"
    },
    {
        "line": 135,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);"
    },
    {
        "line": 159,
        "fullcodeline": "status = 3;"
    },
    {
        "line": 160,
        "fullcodeline": "ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));"
    },
    {
        "line": 196,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 197,
        "fullcodeline": "close(ipc_socket);"
    },
    {
        "line": 198,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 237,
        "fullcodeline": "rexit(payload->exec_function(payload->exec_payload));"
    },
    {
        "line": 36,
        "fullcodeline": "if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (options->namespaces & CLONE_NEWUSER)"
    },
    {
        "line": 87,
        "fullcodeline": "if (options->uid != (uid_t)-1)"
    },
    {
        "line": 89,
        "fullcodeline": "if (options->gid != (gid_t)-1)"
    },
    {
        "line": 93,
        "fullcodeline": "if (options->stdin_fd && isatty(options->stdin_fd)) {"
    },
    {
        "line": 108,
        "fullcodeline": "if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (ret != sizeof(status)) {"
    },
    {
        "line": 144,
        "fullcodeline": "if ((init_ctx->container && init_ctx->container->lxc_conf &&"
    },
    {
        "line": 161,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 167,
        "fullcodeline": "if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (init_ctx->container && init_ctx->container->lxc_conf &&"
    },
    {
        "line": 210,
        "fullcodeline": "if (options->stdin_fd >= 0 && options->stdin_fd != 0)"
    },
    {
        "line": 212,
        "fullcodeline": "if (options->stdout_fd >= 0 && options->stdout_fd != 1)"
    },
    {
        "line": 214,
        "fullcodeline": "if (options->stderr_fd >= 0 && options->stderr_fd != 2)"
    },
    {
        "line": 218,
        "fullcodeline": "if (options->stdin_fd > 2)"
    },
    {
        "line": 220,
        "fullcodeline": "if (options->stdout_fd > 2)"
    },
    {
        "line": 222,
        "fullcodeline": "if (options->stderr_fd > 2)"
    },
    {
        "line": 227,
        "fullcodeline": "for (fd = 0; fd <= 2; fd++) {"
    },
    {
        "line": 26,
        "fullcodeline": "ERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));"
    },
    {
        "line": 27,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 28,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 37,
        "fullcodeline": "ret = lxc_attach_remount_sys_proc();"
    },
    {
        "line": 62,
        "fullcodeline": "ret = lxc_attach_drop_privs(init_ctx);"
    },
    {
        "line": 73,
        "fullcodeline": "ERROR(\"could not set initial environment for attached process\");"
    },
    {
        "line": 74,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 75,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 85,
        "fullcodeline": "lxc_attach_get_init_uidgid(&new_uid, &new_gid);"
    },
    {
        "line": 88,
        "fullcodeline": "new_uid = options->uid;"
    },
    {
        "line": 90,
        "fullcodeline": "new_gid = options->gid;"
    },
    {
        "line": 116,
        "fullcodeline": "SYSERROR(\"switching to container uid\");"
    },
    {
        "line": 117,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 118,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 125,
        "fullcodeline": "ERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));"
    },
    {
        "line": 126,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 127,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 137,
        "fullcodeline": "ERROR(\"Error using IPC to receive message from initial process \""
    },
    {
        "line": 140,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 141,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 146,
        "fullcodeline": "(options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {"
    },
    {
        "line": 154,
        "fullcodeline": "INFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \""
    },
    {
        "line": 162,
        "fullcodeline": "ERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));"
    },
    {
        "line": 163,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 164,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 170,
        "fullcodeline": "ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);"
    },
    {
        "line": 178,
        "fullcodeline": "on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;"
    },
    {
        "line": 185,
        "fullcodeline": "close(lsm_labelfd);"
    },
    {
        "line": 190,
        "fullcodeline": "(lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {"
    },
    {
        "line": 191,
        "fullcodeline": "ERROR(\"Loading seccomp policy\");"
    },
    {
        "line": 192,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 193,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 211,
        "fullcodeline": "dup2(options->stdin_fd, 0);"
    },
    {
        "line": 213,
        "fullcodeline": "dup2(options->stdout_fd, 1);"
    },
    {
        "line": 215,
        "fullcodeline": "dup2(options->stderr_fd, 2);"
    },
    {
        "line": 219,
        "fullcodeline": "close(options->stdin_fd);"
    },
    {
        "line": 221,
        "fullcodeline": "close(options->stdout_fd);"
    },
    {
        "line": 223,
        "fullcodeline": "close(options->stderr_fd);"
    },
    {
        "line": 228,
        "fullcodeline": "flags = fcntl(fd, F_GETFL);"
    },
    {
        "line": 94,
        "fullcodeline": "if (setsid() < 0) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (setgid(new_gid) || setgroups(0, NULL)) {"
    },
    {
        "line": 139,
        "fullcodeline": "strerror(errno));"
    },
    {
        "line": 147,
        "fullcodeline": "if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {"
    },
    {
        "line": 171,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 179,
        "fullcodeline": "if (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {"
    },
    {
        "line": 229,
        "fullcodeline": "if (flags < 0)"
    },
    {
        "line": 231,
        "fullcodeline": "if (flags & FD_CLOEXEC)"
    },
    {
        "line": 39,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 40,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 64,
        "fullcodeline": "ERROR(\"could not drop privileges\");"
    },
    {
        "line": 65,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 66,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 95,
        "fullcodeline": "SYSERROR(\"unable to setsid\");"
    },
    {
        "line": 96,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 97,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 101,
        "fullcodeline": "SYSERROR(\"unable to TIOCSTTY\");"
    },
    {
        "line": 102,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 103,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 110,
        "fullcodeline": "SYSERROR(\"switching to container gid\");"
    },
    {
        "line": 111,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 112,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 148,
        "fullcodeline": "SYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \""
    },
    {
        "line": 151,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 152,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 172,
        "fullcodeline": "ERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));"
    },
    {
        "line": 173,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 174,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 180,
        "fullcodeline": "SYSERROR(\"Failed to set LSM label.\");"
    },
    {
        "line": 181,
        "fullcodeline": "shutdown(ipc_socket, SHUT_RDWR);"
    },
    {
        "line": 182,
        "fullcodeline": "close(lsm_labelfd);"
    },
    {
        "line": 183,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 232,
        "fullcodeline": "if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)"
    },
    {
        "line": 233,
        "fullcodeline": "SYSERROR(\"Unable to clear CLOEXEC from fd\");"
    }
]