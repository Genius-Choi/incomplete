[
    {
        "line": 8,
        "fullcodeline": "int ipc_sockets[2];"
    },
    {
        "line": 14,
        "fullcodeline": "init_pid = lxc_cmd_get_init_pid(name, lxcpath);"
    },
    {
        "line": 20,
        "fullcodeline": "init_ctx = lxc_proc_get_context_info(init_pid);"
    },
    {
        "line": 26,
        "fullcodeline": "personality = get_personality(name, lxcpath);"
    },
    {
        "line": 32,
        "fullcodeline": "init_ctx->personality = personality;"
    },
    {
        "line": 34,
        "fullcodeline": "init_ctx->container = lxc_container_new(name, lxcpath);"
    },
    {
        "line": 44,
        "fullcodeline": "cwd = getcwd(NULL, 0);"
    },
    {
        "line": 93,
        "fullcodeline": "ret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);"
    },
    {
        "line": 113,
        "fullcodeline": "pid = fork();"
    },
    {
        "line": 263,
        "fullcodeline": "close(ipc_sockets[0]);"
    },
    {
        "line": 266,
        "fullcodeline": "expected = 0;"
    },
    {
        "line": 267,
        "fullcodeline": "status = -1;"
    },
    {
        "line": 268,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);"
    },
    {
        "line": 281,
        "fullcodeline": "ret = lxc_attach_to_ns(init_pid, options->namespaces);"
    },
    {
        "line": 293,
        "fullcodeline": "ret = chdir(new_cwd);"
    },
    {
        "line": 296,
        "fullcodeline": "free(cwd);"
    },
    {
        "line": 322,
        "fullcodeline": "ret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));"
    },
    {
        "line": 336,
        "fullcodeline": "rexit(0);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!options)"
    },
    {
        "line": 15,
        "fullcodeline": "if (init_pid < 0) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (!init_ctx) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (init_ctx->personality < 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (!init_ctx->container)"
    },
    {
        "line": 38,
        "fullcodeline": "if (!fetch_seccomp(init_ctx->container, options))"
    },
    {
        "line": 41,
        "fullcodeline": "if (!no_new_privs(init_ctx->container, options))"
    },
    {
        "line": 49,
        "fullcodeline": "if (options->namespaces == -1) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (pid < 0) {"
    },
    {
        "line": 269,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 275,
        "fullcodeline": "if ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())"
    },
    {
        "line": 282,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 294,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 300,
        "fullcodeline": "struct attach_clone_payload payload = {"
    },
    {
        "line": 311,
        "fullcodeline": "pid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);"
    },
    {
        "line": 315,
        "fullcodeline": "if (pid <= 0) {"
    },
    {
        "line": 323,
        "fullcodeline": "if (ret != sizeof(pid)) {"
    },
    {
        "line": 12,
        "fullcodeline": "options = &attach_static_default_options;"
    },
    {
        "line": 16,
        "fullcodeline": "ERROR(\"failed to get the init pid\");"
    },
    {
        "line": 22,
        "fullcodeline": "ERROR(\"failed to get context of the init process, pid = %ld\", (long)init_pid);"
    },
    {
        "line": 28,
        "fullcodeline": "ERROR(\"Failed to get personality of the container\");"
    },
    {
        "line": 29,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 39,
        "fullcodeline": "WARN(\"Failed to get seccomp policy\");"
    },
    {
        "line": 42,
        "fullcodeline": "WARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");"
    },
    {
        "line": 50,
        "fullcodeline": "options->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);"
    },
    {
        "line": 95,
        "fullcodeline": "SYSERROR(\"could not set up required IPC mechanism for attaching\");"
    },
    {
        "line": 96,
        "fullcodeline": "free(cwd);"
    },
    {
        "line": 97,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 116,
        "fullcodeline": "SYSERROR(\"failed to create first subprocess\");"
    },
    {
        "line": 117,
        "fullcodeline": "free(cwd);"
    },
    {
        "line": 118,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 123,
        "fullcodeline": "int procfd = -1;"
    },
    {
        "line": 124,
        "fullcodeline": "pid_t to_cleanup_pid = pid;"
    },
    {
        "line": 129,
        "fullcodeline": "close(ipc_sockets[1]);"
    },
    {
        "line": 130,
        "fullcodeline": "free(cwd);"
    },
    {
        "line": 141,
        "fullcodeline": "procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);"
    },
    {
        "line": 148,
        "fullcodeline": "status = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));"
    },
    {
        "line": 156,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);"
    },
    {
        "line": 170,
        "fullcodeline": "ret = wait_for_pid(pid);"
    },
    {
        "line": 175,
        "fullcodeline": "to_cleanup_pid = attached_pid;"
    },
    {
        "line": 178,
        "fullcodeline": "status = 0;"
    },
    {
        "line": 179,
        "fullcodeline": "ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));"
    },
    {
        "line": 186,
        "fullcodeline": "expected = 1;"
    },
    {
        "line": 187,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);"
    },
    {
        "line": 196,
        "fullcodeline": "status = 2;"
    },
    {
        "line": 197,
        "fullcodeline": "ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));"
    },
    {
        "line": 207,
        "fullcodeline": "expected = 3;"
    },
    {
        "line": 208,
        "fullcodeline": "ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);"
    },
    {
        "line": 234,
        "fullcodeline": "shutdown(ipc_sockets[0], SHUT_RDWR);"
    },
    {
        "line": 235,
        "fullcodeline": "close(ipc_sockets[0]);"
    },
    {
        "line": 236,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 243,
        "fullcodeline": "*attached_process = attached_pid;"
    },
    {
        "line": 252,
        "fullcodeline": "shutdown(ipc_sockets[0], SHUT_RDWR);"
    },
    {
        "line": 253,
        "fullcodeline": "close(ipc_sockets[0]);"
    },
    {
        "line": 256,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 270,
        "fullcodeline": "ERROR(\"error communicating with child process\");"
    },
    {
        "line": 271,
        "fullcodeline": "shutdown(ipc_sockets[1], SHUT_RDWR);"
    },
    {
        "line": 272,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 276,
        "fullcodeline": "options->namespaces |= CLONE_NEWCGROUP;"
    },
    {
        "line": 283,
        "fullcodeline": "ERROR(\"failed to enter the namespace\");"
    },
    {
        "line": 284,
        "fullcodeline": "shutdown(ipc_sockets[1], SHUT_RDWR);"
    },
    {
        "line": 285,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 290,
        "fullcodeline": "new_cwd = options->initial_cwd;"
    },
    {
        "line": 295,
        "fullcodeline": "WARN(\"could not change directory to '%s'\", new_cwd);"
    },
    {
        "line": 316,
        "fullcodeline": "SYSERROR(\"failed to create subprocess\");"
    },
    {
        "line": 317,
        "fullcodeline": "shutdown(ipc_sockets[1], SHUT_RDWR);"
    },
    {
        "line": 318,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 330,
        "fullcodeline": "ERROR(\"error using IPC to notify main process of pid of the attached process\");"
    },
    {
        "line": 331,
        "fullcodeline": "shutdown(ipc_sockets[1], SHUT_RDWR);"
    },
    {
        "line": 332,
        "fullcodeline": "rexit(-1);"
    },
    {
        "line": 17,
        "fullcodeline": "return -1;"
    },
    {
        "line": 23,
        "fullcodeline": "return -1;"
    },
    {
        "line": 30,
        "fullcodeline": "return -1;"
    },
    {
        "line": 36,
        "fullcodeline": "return -1;"
    },
    {
        "line": 52,
        "fullcodeline": "if (options->namespaces == -1) {"
    },
    {
        "line": 98,
        "fullcodeline": "return -1;"
    },
    {
        "line": 119,
        "fullcodeline": "return -1;"
    },
    {
        "line": 133,
        "fullcodeline": "if (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (procfd < 0) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 164,
        "fullcodeline": "if (options->stdin_fd == 0) {"
    },
    {
        "line": 171,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 180,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 209,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 216,
        "fullcodeline": "if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {"
    },
    {
        "line": 250,
        "fullcodeline": "if (procfd >= 0)"
    },
    {
        "line": 257,
        "fullcodeline": "return -1;"
    },
    {
        "line": 292,
        "fullcodeline": "new_cwd = cwd;"
    },
    {
        "line": 53,
        "fullcodeline": "ERROR(\"failed to automatically determine the \""
    },
    {
        "line": 55,
        "fullcodeline": "free(cwd);"
    },
    {
        "line": 56,
        "fullcodeline": "lxc_proc_put_context_info(init_ctx);"
    },
    {
        "line": 143,
        "fullcodeline": "SYSERROR(\"Unable to open /proc.\");"
    },
    {
        "line": 151,
        "fullcodeline": "ERROR(\"error using IPC to notify attached process for initialization (0)\");"
    },
    {
        "line": 165,
        "fullcodeline": "signal(SIGINT, SIG_IGN);"
    },
    {
        "line": 166,
        "fullcodeline": "signal(SIGQUIT, SIG_IGN);"
    },
    {
        "line": 181,
        "fullcodeline": "ERROR(\"error using IPC to notify attached process for initialization (0)\");"
    },
    {
        "line": 199,
        "fullcodeline": "ERROR(\"Error using IPC to notify attached process for \""
    },
    {
        "line": 210,
        "fullcodeline": "ERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\","
    },
    {
        "line": 218,
        "fullcodeline": "on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;"
    },
    {
        "line": 220,
        "fullcodeline": "labelfd = lsm_openat(procfd, attached_pid, on_exec);"
    },
    {
        "line": 225,
        "fullcodeline": "ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);"
    },
    {
        "line": 251,
        "fullcodeline": "close(procfd);"
    },
    {
        "line": 255,
        "fullcodeline": "(void) wait_for_pid(to_cleanup_pid);"
    },
    {
        "line": 301,
        "fullcodeline": ".ipc_socket = ipc_sockets[1],"
    },
    {
        "line": 302,
        "fullcodeline": ".options = options,"
    },
    {
        "line": 303,
        "fullcodeline": ".init_ctx = init_ctx,"
    },
    {
        "line": 304,
        "fullcodeline": ".exec_function = exec_function,"
    },
    {
        "line": 305,
        "fullcodeline": ".exec_payload = exec_payload,"
    },
    {
        "line": 57,
        "fullcodeline": "return -1;"
    },
    {
        "line": 134,
        "fullcodeline": "if (!cgroup_attach(name, lxcpath, pid))"
    },
    {
        "line": 158,
        "fullcodeline": "if (ret != 0)"
    },
    {
        "line": 189,
        "fullcodeline": "if (ret != 0)"
    },
    {
        "line": 200,
        "fullcodeline": "\"initialization (2): %s.\", strerror(errno));"
    },
    {
        "line": 211,
        "fullcodeline": "strerror(errno));"
    },
    {
        "line": 221,
        "fullcodeline": "if (labelfd < 0)"
    },
    {
        "line": 226,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 159,
        "fullcodeline": "ERROR(\"error using IPC to receive pid of attached process\");"
    },
    {
        "line": 190,
        "fullcodeline": "ERROR(\"error using IPC to receive notification \""
    },
    {
        "line": 227,
        "fullcodeline": "ERROR(\"Error using IPC to send child LSM fd (4): %s.\","
    },
    {
        "line": 228,
        "fullcodeline": "strerror(errno));"
    }
]