[
    {
        "line": 3,
        "fullcodeline": "struct lxc_proc_context_info *info = calloc(1, sizeof(*info));"
    },
    {
        "line": 5,
        "fullcodeline": "char proc_fn[MAXPATHLEN];"
    },
    {
        "line": 6,
        "fullcodeline": "char *line = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t line_bufsz = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "snprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", pid);"
    },
    {
        "line": 18,
        "fullcodeline": "proc_file = fopen(proc_fn, \"r\");"
    },
    {
        "line": 24,
        "fullcodeline": "found = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "free(line);"
    },
    {
        "line": 34,
        "fullcodeline": "fclose(proc_file);"
    },
    {
        "line": 42,
        "fullcodeline": "info->lsm_label = lsm_process_label_get(pid);"
    },
    {
        "line": 47,
        "fullcodeline": "free(info);"
    },
    {
        "line": 10,
        "fullcodeline": "if (!info) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (!proc_file) {"
    },
    {
        "line": 25,
        "fullcodeline": "while (getline(&line, &line_bufsz, proc_file) != -1) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (!found) {"
    },
    {
        "line": 11,
        "fullcodeline": "SYSERROR(\"Could not allocate memory.\");"
    },
    {
        "line": 20,
        "fullcodeline": "SYSERROR(\"Could not open %s\", proc_fn);"
    },
    {
        "line": 26,
        "fullcodeline": "ret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);"
    },
    {
        "line": 37,
        "fullcodeline": "SYSERROR(\"Could not read capability bounding set from %s\", proc_fn);"
    },
    {
        "line": 38,
        "fullcodeline": "errno = ENOENT;"
    },
    {
        "line": 27,
        "fullcodeline": "if (ret != EOF && ret > 0) {"
    },
    {
        "line": 28,
        "fullcodeline": "found = 1;"
    }
]