[
    {
        "line": 3,
        "fullcodeline": "char *filename = malloc(PATH_MAX + 1);"
    },
    {
        "line": 30,
        "fullcodeline": "free(filename);"
    },
    {
        "line": 4,
        "fullcodeline": "if (filename == NULL)"
    },
    {
        "line": 8,
        "fullcodeline": "if (Gflag != 0) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (cnt == 0 && max_chars == 0)"
    },
    {
        "line": 5,
        "fullcodeline": "error(\"%s: malloc\", __func__);"
    },
    {
        "line": 19,
        "fullcodeline": "strftime(filename, PATH_MAX, orig_name, local_tm);"
    },
    {
        "line": 25,
        "fullcodeline": "strncpy(buffer, filename, PATH_MAX + 1);"
    },
    {
        "line": 12,
        "fullcodeline": "if ((local_tm = localtime(&Gflag_time)) == NULL) {"
    },
    {
        "line": 21,
        "fullcodeline": "strncpy(filename, orig_name, PATH_MAX);"
    },
    {
        "line": 13,
        "fullcodeline": "error(\"%s: localtime\", __func__);"
    },
    {
        "line": 27,
        "fullcodeline": "if (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)"
    },
    {
        "line": 29,
        "fullcodeline": "error(\"too many output files or filename is too long (> %d)\", PATH_MAX);"
    }
]