[
    {
        "line": 3,
        "fullcodeline": "char *filename = malloc(PATH_MAX + 1);"
    },
    {
        "line": 48,
        "fullcodeline": "free(filename);"
    },
    {
        "line": 4,
        "fullcodeline": "if (filename == NULL)"
    },
    {
        "line": 6,
        "fullcodeline": "if (strlen(orig_name) == 0)"
    },
    {
        "line": 10,
        "fullcodeline": "if (Gflag != 0) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (cnt == 0 && max_chars == 0)"
    },
    {
        "line": 5,
        "fullcodeline": "error(\"%s: malloc\", __func__);"
    },
    {
        "line": 7,
        "fullcodeline": "error(\"an empty string is not a valid file name\");"
    },
    {
        "line": 43,
        "fullcodeline": "strncpy(buffer, filename, PATH_MAX + 1);"
    },
    {
        "line": 14,
        "fullcodeline": "if ((local_tm = localtime(&Gflag_time)) == NULL) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (strftime(filename, PATH_MAX, orig_name, local_tm) == 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "strncpy(filename, orig_name, PATH_MAX);"
    },
    {
        "line": 15,
        "fullcodeline": "error(\"%s: localtime\", __func__);"
    },
    {
        "line": 36,
        "fullcodeline": "error(\"%s: strftime\", __func__);"
    },
    {
        "line": 45,
        "fullcodeline": "if (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)"
    },
    {
        "line": 47,
        "fullcodeline": "error(\"too many output files or filename is too long (> %d)\", PATH_MAX);"
    }
]