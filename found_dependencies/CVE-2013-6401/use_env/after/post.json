[
    {
        "line": 4,
        "fullcodeline": "size_t flags = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "indent = getenv_int(\"JSON_INDENT\");"
    },
    {
        "line": 75,
        "fullcodeline": "json_dumpf(json, stdout, flags);"
    },
    {
        "line": 76,
        "fullcodeline": "json_decref(json);"
    },
    {
        "line": 16,
        "fullcodeline": "if(indent < 0 || indent > 255) {"
    },
    {
        "line": 21,
        "fullcodeline": "if(indent > 0)"
    },
    {
        "line": 24,
        "fullcodeline": "if(getenv_int(\"JSON_COMPACT\") > 0)"
    },
    {
        "line": 27,
        "fullcodeline": "if(getenv_int(\"JSON_ENSURE_ASCII\"))"
    },
    {
        "line": 30,
        "fullcodeline": "if(getenv_int(\"JSON_PRESERVE_ORDER\"))"
    },
    {
        "line": 33,
        "fullcodeline": "if(getenv_int(\"JSON_SORT_KEYS\"))"
    },
    {
        "line": 36,
        "fullcodeline": "if(getenv(\"HASHSEED\"))"
    },
    {
        "line": 39,
        "fullcodeline": "if(getenv_int(\"STRIP\")) {"
    },
    {
        "line": 68,
        "fullcodeline": "if(!json) {"
    },
    {
        "line": 17,
        "fullcodeline": "fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", indent);"
    },
    {
        "line": 22,
        "fullcodeline": "flags |= JSON_INDENT(indent);"
    },
    {
        "line": 25,
        "fullcodeline": "flags |= JSON_COMPACT;"
    },
    {
        "line": 28,
        "fullcodeline": "flags |= JSON_ENSURE_ASCII;"
    },
    {
        "line": 31,
        "fullcodeline": "flags |= JSON_PRESERVE_ORDER;"
    },
    {
        "line": 34,
        "fullcodeline": "flags |= JSON_SORT_KEYS;"
    },
    {
        "line": 37,
        "fullcodeline": "json_object_seed(getenv_int(\"HASHSEED\"));"
    },
    {
        "line": 41,
        "fullcodeline": "size_t size = 0, used = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "char *buffer = NULL;"
    },
    {
        "line": 62,
        "fullcodeline": "json = json_loads(strip(buffer), 0, &error);"
    },
    {
        "line": 63,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 69,
        "fullcodeline": "fprintf(stderr, \"%d %d %d\\n%s\\n\","
    },
    {
        "line": 66,
        "fullcodeline": "json = json_loadf(stdin, 0, &error);"
    },
    {
        "line": 47,
        "fullcodeline": "size = (size == 0 ? 128 : size * 2);"
    },
    {
        "line": 48,
        "fullcodeline": "buffer = realloc(buffer, size);"
    },
    {
        "line": 54,
        "fullcodeline": "count = fread(buffer + used, 1, size - used, stdin);"
    },
    {
        "line": 59,
        "fullcodeline": "used += count;"
    },
    {
        "line": 49,
        "fullcodeline": "if(!buffer) {"
    },
    {
        "line": 55,
        "fullcodeline": "if(count < size - used) {"
    },
    {
        "line": 50,
        "fullcodeline": "fprintf(stderr, \"Unable to allocate %d bytes\\n\", (int)size);"
    },
    {
        "line": 56,
        "fullcodeline": "buffer[used + count] = '\\0';"
    }
]