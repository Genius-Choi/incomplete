[
    {
        "line": 2,
        "fullcodeline": "Vector<uint8_t> src_image;"
    },
    {
        "line": 3,
        "fullcodeline": "int src_image_len = f->get_len();"
    },
    {
        "line": 4,
        "fullcodeline": "ERR_FAIL_COND_V(src_image_len == 0, ERR_FILE_CORRUPT);"
    },
    {
        "line": 5,
        "fullcodeline": "ERR_FAIL_COND_V(src_image_len < (int)sizeof(tga_header_s), ERR_FILE_CORRUPT);"
    },
    {
        "line": 6,
        "fullcodeline": "src_image.resize(src_image_len);"
    },
    {
        "line": 8,
        "fullcodeline": "Error err = OK;"
    },
    {
        "line": 11,
        "fullcodeline": "tga_header.id_length = f->get_8();"
    },
    {
        "line": 12,
        "fullcodeline": "tga_header.color_map_type = f->get_8();"
    },
    {
        "line": 13,
        "fullcodeline": "tga_header.image_type = static_cast<tga_type_e>(f->get_8());"
    },
    {
        "line": 15,
        "fullcodeline": "tga_header.first_color_entry = f->get_16();"
    },
    {
        "line": 16,
        "fullcodeline": "tga_header.color_map_length = f->get_16();"
    },
    {
        "line": 17,
        "fullcodeline": "tga_header.color_map_depth = f->get_8();"
    },
    {
        "line": 19,
        "fullcodeline": "tga_header.x_origin = f->get_16();"
    },
    {
        "line": 20,
        "fullcodeline": "tga_header.y_origin = f->get_16();"
    },
    {
        "line": 21,
        "fullcodeline": "tga_header.image_width = f->get_16();"
    },
    {
        "line": 22,
        "fullcodeline": "tga_header.image_height = f->get_16();"
    },
    {
        "line": 23,
        "fullcodeline": "tga_header.pixel_depth = f->get_8();"
    },
    {
        "line": 24,
        "fullcodeline": "tga_header.image_descriptor = f->get_8();"
    },
    {
        "line": 26,
        "fullcodeline": "bool is_encoded = (tga_header.image_type == TGA_TYPE_RLE_INDEXED || tga_header.image_type == TGA_TYPE_RLE_RGB || tga_header.image_type == TGA_TYPE_RLE_MONOCHROME);"
    },
    {
        "line": 27,
        "fullcodeline": "bool has_color_map = (tga_header.image_type == TGA_TYPE_RLE_INDEXED || tga_header.image_type == TGA_TYPE_INDEXED);"
    },
    {
        "line": 28,
        "fullcodeline": "bool is_monochrome = (tga_header.image_type == TGA_TYPE_RLE_MONOCHROME || tga_header.image_type == TGA_TYPE_MONOCHROME);"
    },
    {
        "line": 101,
        "fullcodeline": "f->close();"
    },
    {
        "line": 30,
        "fullcodeline": "if (tga_header.image_type == TGA_TYPE_NO_DATA) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (tga_header.image_width <= 0 || tga_header.image_height <= 0) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (!(tga_header.pixel_depth == 8 || tga_header.pixel_depth == 24 || tga_header.pixel_depth == 32)) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (err == OK) {"
    },
    {
        "line": 31,
        "fullcodeline": "err = FAILED;"
    },
    {
        "line": 45,
        "fullcodeline": "err = FAILED;"
    },
    {
        "line": 49,
        "fullcodeline": "err = FAILED;"
    },
    {
        "line": 53,
        "fullcodeline": "f->seek(f->get_position() + tga_header.id_length);"
    },
    {
        "line": 55,
        "fullcodeline": "Vector<uint8_t> palette;"
    },
    {
        "line": 68,
        "fullcodeline": "uint8_t *src_image_w = src_image.ptrw();"
    },
    {
        "line": 69,
        "fullcodeline": "f->get_buffer(&src_image_w[0], src_image_len - f->get_position());"
    },
    {
        "line": 71,
        "fullcodeline": "const uint8_t *src_image_r = src_image.ptr();"
    },
    {
        "line": 73,
        "fullcodeline": "const size_t pixel_size = tga_header.pixel_depth >> 3;"
    },
    {
        "line": 74,
        "fullcodeline": "size_t buffer_size = (tga_header.image_width * tga_header.image_height) * pixel_size;"
    },
    {
        "line": 76,
        "fullcodeline": "Vector<uint8_t> uncompressed_buffer;"
    },
    {
        "line": 77,
        "fullcodeline": "uncompressed_buffer.resize(buffer_size);"
    },
    {
        "line": 78,
        "fullcodeline": "uint8_t *uncompressed_buffer_w = uncompressed_buffer.ptrw();"
    },
    {
        "line": 81,
        "fullcodeline": "const uint8_t *buffer = nullptr;"
    },
    {
        "line": 35,
        "fullcodeline": "if (tga_header.color_map_length > 256 || (tga_header.color_map_depth != 24) || tga_header.color_map_type != 1) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (err == OK) {"
    },
    {
        "line": 36,
        "fullcodeline": "err = FAILED;"
    },
    {
        "line": 58,
        "fullcodeline": "size_t color_map_size = tga_header.color_map_length * (tga_header.color_map_depth >> 3);"
    },
    {
        "line": 59,
        "fullcodeline": "err = palette.resize(color_map_size);"
    },
    {
        "line": 84,
        "fullcodeline": "err = decode_tga_rle(src_image_r, pixel_size, uncompressed_buffer_w, buffer_size);"
    },
    {
        "line": 96,
        "fullcodeline": "const uint8_t *palette_r = palette.ptr();"
    },
    {
        "line": 97,
        "fullcodeline": "err = convert_to_image(p_image, buffer, tga_header, palette_r, is_monochrome, buffer_size);"
    },
    {
        "line": 40,
        "fullcodeline": "err = FAILED;"
    },
    {
        "line": 60,
        "fullcodeline": "if (err == OK) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (err == OK) {"
    },
    {
        "line": 91,
        "fullcodeline": "buffer = src_image_r;"
    },
    {
        "line": 92,
        "fullcodeline": "buffer_size = src_image_len;"
    },
    {
        "line": 61,
        "fullcodeline": "uint8_t *palette_w = palette.ptrw();"
    },
    {
        "line": 62,
        "fullcodeline": "f->get_buffer(&palette_w[0], color_map_size);"
    },
    {
        "line": 87,
        "fullcodeline": "uncompressed_buffer_r = uncompressed_buffer.ptr();"
    },
    {
        "line": 88,
        "fullcodeline": "buffer = uncompressed_buffer_r;"
    }
]