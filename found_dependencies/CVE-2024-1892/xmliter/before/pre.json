[
    {
        "line": 12,
        "fullcodeline": "nodename_patt = re.escape(nodename)"
    },
    {
        "line": 14,
        "fullcodeline": "DOCUMENT_HEADER_RE = re.compile(r\"<\\?xml[^>]+>\\s*\", re.S)"
    },
    {
        "line": 15,
        "fullcodeline": "HEADER_END_RE = re.compile(rf\"<\\s*/{nodename_patt}\\s*>\", re.S)"
    },
    {
        "line": 16,
        "fullcodeline": "END_TAG_RE = re.compile(r\"<\\s*/([^\\s>]+)\\s*>\", re.S)"
    },
    {
        "line": 17,
        "fullcodeline": "NAMESPACE_RE = re.compile(r\"((xmlns[:A-Za-z]*)=[^>\\s]+)\", re.S)"
    },
    {
        "line": 18,
        "fullcodeline": "text = _body_or_str(obj)"
    },
    {
        "line": 20,
        "fullcodeline": "document_header_match = re.search(DOCUMENT_HEADER_RE, text)"
    },
    {
        "line": 21,
        "fullcodeline": "document_header = ("
    },
    {
        "line": 24,
        "fullcodeline": "header_end_idx = re_rsearch(HEADER_END_RE, text)"
    },
    {
        "line": 25,
        "fullcodeline": "header_end = text[header_end_idx[1] :].strip() if header_end_idx else \"\""
    },
    {
        "line": 26,
        "fullcodeline": "namespaces: Dict[str, str] = {}"
    },
    {
        "line": 37,
        "fullcodeline": "r = re.compile(rf\"<{nodename_patt}[\\s>].*?</{nodename_patt}>\", re.DOTALL)"
    },
    {
        "line": 22,
        "fullcodeline": "document_header_match.group().strip() if document_header_match else \"\""
    },
    {
        "line": 38,
        "fullcodeline": "for match in r.finditer(text):"
    },
    {
        "line": 28,
        "fullcodeline": "for tagname in reversed(re.findall(END_TAG_RE, header_end)):"
    },
    {
        "line": 39,
        "fullcodeline": "nodetext = ("
    },
    {
        "line": 40,
        "fullcodeline": "document_header"
    },
    {
        "line": 29,
        "fullcodeline": "assert header_end_idx"
    },
    {
        "line": 30,
        "fullcodeline": "tag = re.search("
    },
    {
        "line": 31,
        "fullcodeline": "rf\"<\\s*{tagname}.*?xmlns[:=][^>]*>\", text[: header_end_idx[1]], re.S"
    },
    {
        "line": 41,
        "fullcodeline": "+ match.group().replace("
    },
    {
        "line": 34,
        "fullcodeline": "for x in re.findall(NAMESPACE_RE, tag.group()):"
    },
    {
        "line": 42,
        "fullcodeline": "nodename, f'{nodename} {\" \".join(namespaces.values())}', 1"
    },
    {
        "line": 35,
        "fullcodeline": "namespaces[x[1]] = x[0]"
    }
]