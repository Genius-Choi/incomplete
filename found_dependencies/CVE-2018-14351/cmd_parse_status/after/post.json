[
    {
        "line": 3,
        "fullcodeline": "char *value = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "struct Buffy *inc = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "struct ImapStatus *status = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "short new = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "short new_msg_count = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "char *mailbox = imap_next_word(s);"
    },
    {
        "line": 42,
        "fullcodeline": "status = imap_mboxcache_get(idata, mailbox, 1);"
    },
    {
        "line": 43,
        "fullcodeline": "olduv = status->uidvalidity;"
    },
    {
        "line": 44,
        "fullcodeline": "oldun = status->uidnext;"
    },
    {
        "line": 82,
        "fullcodeline": "mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\","
    },
    {
        "line": 93,
        "fullcodeline": "mutt_debug(3, \"Running default STATUS handler\\n\");"
    },
    {
        "line": 15,
        "fullcodeline": "if (imap_get_literal_count(mailbox, &litlen) == 0)"
    },
    {
        "line": 46,
        "fullcodeline": "if (*s++ != '(')"
    },
    {
        "line": 51,
        "fullcodeline": "while (*s && *s != ')')"
    },
    {
        "line": 87,
        "fullcodeline": "if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)"
    },
    {
        "line": 96,
        "fullcodeline": "for (inc = Incoming; inc; inc = inc->next)"
    },
    {
        "line": 29,
        "fullcodeline": "mailbox = idata->buf;"
    },
    {
        "line": 30,
        "fullcodeline": "s = mailbox + litlen;"
    },
    {
        "line": 31,
        "fullcodeline": "*s = '\\0';"
    },
    {
        "line": 32,
        "fullcodeline": "s++;"
    },
    {
        "line": 33,
        "fullcodeline": "SKIPWS(s);"
    },
    {
        "line": 48,
        "fullcodeline": "mutt_debug(1, \"Error parsing STATUS\\n\");"
    },
    {
        "line": 53,
        "fullcodeline": "value = imap_next_word(s);"
    },
    {
        "line": 55,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 56,
        "fullcodeline": "const unsigned long ulcount = strtoul(value, &value, 10);"
    },
    {
        "line": 62,
        "fullcodeline": "const unsigned int count = (unsigned int) ulcount;"
    },
    {
        "line": 78,
        "fullcodeline": "s = value;"
    },
    {
        "line": 89,
        "fullcodeline": "memcpy(idata->cmddata, status, sizeof(struct ImapStatus));"
    },
    {
        "line": 167,
        "fullcodeline": "FREE(&mx.mbox);"
    },
    {
        "line": 17,
        "fullcodeline": "if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)"
    },
    {
        "line": 23,
        "fullcodeline": "if (strlen(idata->buf) < litlen)"
    },
    {
        "line": 37,
        "fullcodeline": "s = imap_next_word(mailbox);"
    },
    {
        "line": 38,
        "fullcodeline": "*(s - 1) = '\\0';"
    },
    {
        "line": 39,
        "fullcodeline": "imap_unmunge_mbox_name(idata, mailbox);"
    },
    {
        "line": 57,
        "fullcodeline": "if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))"
    },
    {
        "line": 64,
        "fullcodeline": "if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)"
    },
    {
        "line": 79,
        "fullcodeline": "if (*s && *s != ')')"
    },
    {
        "line": 98,
        "fullcodeline": "if (inc->magic != MUTT_IMAP)"
    },
    {
        "line": 101,
        "fullcodeline": "if (imap_parse_path(inc->path, &mx) < 0)"
    },
    {
        "line": 19,
        "fullcodeline": "idata->status = IMAP_FATAL;"
    },
    {
        "line": 25,
        "fullcodeline": "mutt_debug(1, \"Error parsing STATUS mailbox\\n\");"
    },
    {
        "line": 59,
        "fullcodeline": "mutt_debug(1, \"Error parsing STATUS number\\n\");"
    },
    {
        "line": 66,
        "fullcodeline": "status->messages = count;"
    },
    {
        "line": 67,
        "fullcodeline": "new_msg_count = 1;"
    },
    {
        "line": 80,
        "fullcodeline": "s = imap_next_word(s);"
    },
    {
        "line": 103,
        "fullcodeline": "mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);"
    },
    {
        "line": 164,
        "fullcodeline": "FREE(&value);"
    },
    {
        "line": 118,
        "fullcodeline": "if (value && (imap_mxcmp(mailbox, value) == 0))"
    },
    {
        "line": 69,
        "fullcodeline": "else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)"
    },
    {
        "line": 111,
        "fullcodeline": "value = mutt_str_strdup(mx.mbox);"
    },
    {
        "line": 112,
        "fullcodeline": "imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);"
    },
    {
        "line": 113,
        "fullcodeline": "FREE(&mx.mbox);"
    },
    {
        "line": 120,
        "fullcodeline": "mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,"
    },
    {
        "line": 148,
        "fullcodeline": "inc->new = new;"
    },
    {
        "line": 151,
        "fullcodeline": "inc->msg_unread = status->unseen;"
    },
    {
        "line": 160,
        "fullcodeline": "FREE(&value);"
    },
    {
        "line": 70,
        "fullcodeline": "status->recent = count;"
    },
    {
        "line": 116,
        "fullcodeline": "value = mutt_str_strdup(\"INBOX\");"
    },
    {
        "line": 150,
        "fullcodeline": "inc->msg_count = status->messages;"
    },
    {
        "line": 157,
        "fullcodeline": "status->uidnext = oldun;"
    },
    {
        "line": 71,
        "fullcodeline": "else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)"
    },
    {
        "line": 125,
        "fullcodeline": "if (olduv && olduv == status->uidvalidity)"
    },
    {
        "line": 139,
        "fullcodeline": "new = (status->unseen > 0);"
    },
    {
        "line": 72,
        "fullcodeline": "status->uidnext = count;"
    },
    {
        "line": 127,
        "fullcodeline": "if (oldun < status->uidnext)"
    },
    {
        "line": 73,
        "fullcodeline": "else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)"
    },
    {
        "line": 128,
        "fullcodeline": "new = (status->unseen > 0);"
    },
    {
        "line": 130,
        "fullcodeline": "else if (!olduv && !oldun)"
    },
    {
        "line": 74,
        "fullcodeline": "status->uidvalidity = count;"
    },
    {
        "line": 133,
        "fullcodeline": "new = (status->recent > 0);"
    },
    {
        "line": 136,
        "fullcodeline": "new = (status->unseen > 0);"
    },
    {
        "line": 75,
        "fullcodeline": "else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)"
    },
    {
        "line": 76,
        "fullcodeline": "status->unseen = count;"
    }
]