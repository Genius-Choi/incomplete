[
    {
        "line": 110,
        "fullcodeline": "Assert (flush != Z_NO_FLUSH, \"no flush?\");"
    },
    {
        "line": 116,
        "fullcodeline": "s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;"
    },
    {
        "line": 117,
        "fullcodeline": "if (flush == Z_FINISH) {"
    },
    {
        "line": 26,
        "fullcodeline": "hash_head = NIL;"
    },
    {
        "line": 33,
        "fullcodeline": "s->prev_length = s->match_length, s->prev_match = s->match_start;"
    },
    {
        "line": 34,
        "fullcodeline": "s->match_length = MIN_MATCH-1;"
    },
    {
        "line": 112,
        "fullcodeline": "Tracevv((stderr,\"%c\", s->window[s->strstart-1]));"
    },
    {
        "line": 113,
        "fullcodeline": "_tr_tally_lit(s, s->window[s->strstart-1], bflush);"
    },
    {
        "line": 114,
        "fullcodeline": "s->match_available = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "FLUSH_BLOCK(s, 1);"
    },
    {
        "line": 122,
        "fullcodeline": "FLUSH_BLOCK(s, 0);"
    },
    {
        "line": 15,
        "fullcodeline": "if (s->lookahead < MIN_LOOKAHEAD) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (s->lookahead >= MIN_MATCH) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (hash_head != NIL && s->prev_length < s->max_lazy_match &&"
    },
    {
        "line": 61,
        "fullcodeline": "if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {"
    },
    {
        "line": 16,
        "fullcodeline": "fill_window(s);"
    },
    {
        "line": 28,
        "fullcodeline": "INSERT_STRING(s, s->strstart, hash_head);"
    },
    {
        "line": 37,
        "fullcodeline": "s->strstart - hash_head <= MAX_DIST(s)) {"
    },
    {
        "line": 42,
        "fullcodeline": "s->match_length = longest_match (s, hash_head);"
    },
    {
        "line": 62,
        "fullcodeline": "uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;"
    },
    {
        "line": 65,
        "fullcodeline": "check_match(s, s->strstart-1, s->prev_match, s->prev_length);"
    },
    {
        "line": 67,
        "fullcodeline": "_tr_tally_dist(s, s->strstart -1 - s->prev_match,"
    },
    {
        "line": 75,
        "fullcodeline": "s->lookahead -= s->prev_length-1;"
    },
    {
        "line": 76,
        "fullcodeline": "s->prev_length -= 2;"
    },
    {
        "line": 82,
        "fullcodeline": "s->match_available = 0;"
    },
    {
        "line": 83,
        "fullcodeline": "s->match_length = MIN_MATCH-1;"
    },
    {
        "line": 84,
        "fullcodeline": "s->strstart++;"
    },
    {
        "line": 17,
        "fullcodeline": "if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (s->lookahead == 0) break; /* flush the current block */"
    },
    {
        "line": 45,
        "fullcodeline": "if (s->match_length <= 5 && (s->strategy == Z_FILTERED"
    },
    {
        "line": 68,
        "fullcodeline": "s->prev_length - MIN_MATCH, bflush);"
    },
    {
        "line": 81,
        "fullcodeline": "} while (--s->prev_length != 0);"
    },
    {
        "line": 55,
        "fullcodeline": "s->match_length = MIN_MATCH-1;"
    },
    {
        "line": 86,
        "fullcodeline": "if (bflush) FLUSH_BLOCK(s, 0);"
    },
    {
        "line": 47,
        "fullcodeline": "|| (s->match_length == MIN_MATCH &&"
    },
    {
        "line": 78,
        "fullcodeline": "if (++s->strstart <= max_insert) {"
    },
    {
        "line": 93,
        "fullcodeline": "Tracevv((stderr,\"%c\", s->window[s->strstart-1]));"
    },
    {
        "line": 94,
        "fullcodeline": "_tr_tally_lit(s, s->window[s->strstart-1], bflush);"
    },
    {
        "line": 98,
        "fullcodeline": "s->strstart++;"
    },
    {
        "line": 99,
        "fullcodeline": "s->lookahead--;"
    },
    {
        "line": 48,
        "fullcodeline": "s->strstart - s->match_start > TOO_FAR)"
    },
    {
        "line": 79,
        "fullcodeline": "INSERT_STRING(s, s->strstart, hash_head);"
    },
    {
        "line": 100,
        "fullcodeline": "if (s->strm->avail_out == 0) return need_more;"
    },
    {
        "line": 105,
        "fullcodeline": "s->match_available = 1;"
    },
    {
        "line": 106,
        "fullcodeline": "s->strstart++;"
    },
    {
        "line": 107,
        "fullcodeline": "s->lookahead--;"
    },
    {
        "line": 96,
        "fullcodeline": "FLUSH_BLOCK_ONLY(s, 0);"
    }
]