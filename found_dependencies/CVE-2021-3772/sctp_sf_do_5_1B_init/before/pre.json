[
    {
        "line": 8,
        "fullcodeline": "struct sctp_chunk *chunk = arg, *repl, *err_chunk;"
    },
    {
        "line": 63,
        "fullcodeline": "err_chunk = NULL;"
    },
    {
        "line": 99,
        "fullcodeline": "new_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);"
    },
    {
        "line": 119,
        "fullcodeline": "len = 0;"
    },
    {
        "line": 124,
        "fullcodeline": "repl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);"
    },
    {
        "line": 150,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));"
    },
    {
        "line": 152,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));"
    },
    {
        "line": 160,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());"
    },
    {
        "line": 15,
        "fullcodeline": "if (security_sctp_assoc_request((struct sctp_endpoint *)ep,"
    },
    {
        "line": 28,
        "fullcodeline": "if (!chunk->singleton)"
    },
    {
        "line": 34,
        "fullcodeline": "if (ep == sctp_sk(net->sctp.ctl_sock)->ep) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (sctp_sstate(ep->base.sk, CLOSING))"
    },
    {
        "line": 97,
        "fullcodeline": "chunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));"
    },
    {
        "line": 100,
        "fullcodeline": "if (!new_asoc)"
    },
    {
        "line": 125,
        "fullcodeline": "if (!repl)"
    },
    {
        "line": 35,
        "fullcodeline": "SCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);"
    },
    {
        "line": 50,
        "fullcodeline": "if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))"
    },
    {
        "line": 64,
        "fullcodeline": "if (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,"
    },
    {
        "line": 103,
        "fullcodeline": "if (sctp_assoc_set_bind_addr_from_ep(new_asoc,"
    },
    {
        "line": 109,
        "fullcodeline": "if (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),"
    },
    {
        "line": 121,
        "fullcodeline": "len = ntohs(err_chunk->chunk_hdr->length) -"
    },
    {
        "line": 140,
        "fullcodeline": "unk_param = (struct sctp_unrecognized_param *)"
    },
    {
        "line": 146,
        "fullcodeline": "sctp_addto_chunk(repl, len, unk_param);"
    },
    {
        "line": 17,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 29,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 36,
        "fullcodeline": "return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 43,
        "fullcodeline": "return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 51,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 60,
        "fullcodeline": "return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 104,
        "fullcodeline": "sctp_scope(sctp_source(chunk)),"
    },
    {
        "line": 71,
        "fullcodeline": "packet = sctp_abort_pkt_new(net, ep, asoc, arg,"
    },
    {
        "line": 74,
        "fullcodeline": "ntohs(err_chunk->chunk_hdr->length) -"
    },
    {
        "line": 80,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,"
    },
    {
        "line": 82,
        "fullcodeline": "SCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);"
    },
    {
        "line": 88,
        "fullcodeline": "return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,"
    },
    {
        "line": 81,
        "fullcodeline": "SCTP_PACKET(packet));"
    }
]