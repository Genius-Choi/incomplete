[
    {
        "line": 18,
        "fullcodeline": "peer_init = &chunk->subh.cookie_hdr->c.peer_init[0];"
    },
    {
        "line": 63,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());"
    },
    {
        "line": 64,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,"
    },
    {
        "line": 66,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());"
    },
    {
        "line": 71,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,"
    },
    {
        "line": 73,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());"
    },
    {
        "line": 79,
        "fullcodeline": "repl = sctp_make_cookie_ack(asoc, chunk);"
    },
    {
        "line": 84,
        "fullcodeline": "ev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,"
    },
    {
        "line": 91,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));"
    },
    {
        "line": 20,
        "fullcodeline": "if (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,"
    },
    {
        "line": 24,
        "fullcodeline": "if (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))"
    },
    {
        "line": 27,
        "fullcodeline": "if (!sctp_auth_chunk_verify(net, chunk, new_asoc))"
    },
    {
        "line": 43,
        "fullcodeline": "if (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {"
    },
    {
        "line": 65,
        "fullcodeline": "SCTP_TO(SCTP_EVENT_TIMEOUT_SACK));"
    },
    {
        "line": 72,
        "fullcodeline": "SCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));"
    },
    {
        "line": 76,
        "fullcodeline": "if (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))"
    },
    {
        "line": 80,
        "fullcodeline": "if (!repl)"
    },
    {
        "line": 88,
        "fullcodeline": "if (!ev)"
    },
    {
        "line": 34,
        "fullcodeline": "if (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands))"
    },
    {
        "line": 44,
        "fullcodeline": "disposition = __sctp_sf_do_9_2_reshutack(net, ep, asoc,"
    },
    {
        "line": 50,
        "fullcodeline": "err = sctp_make_op_error(asoc, chunk,"
    },
    {
        "line": 92,
        "fullcodeline": "if ((sctp_state(asoc, SHUTDOWN_PENDING) ||"
    },
    {
        "line": 94,
        "fullcodeline": "(sctp_sstate(asoc->base.sk, CLOSING) ||"
    },
    {
        "line": 100,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));"
    },
    {
        "line": 47,
        "fullcodeline": "if (SCTP_DISPOSITION_NOMEM == disposition)"
    },
    {
        "line": 93,
        "fullcodeline": "sctp_state(asoc, SHUTDOWN_SENT)) &&"
    },
    {
        "line": 95,
        "fullcodeline": "sock_flag(asoc->base.sk, SOCK_DEAD))) {"
    },
    {
        "line": 101,
        "fullcodeline": "return sctp_sf_do_9_2_start_shutdown(net, ep, asoc,"
    },
    {
        "line": 105,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,"
    },
    {
        "line": 45,
        "fullcodeline": "SCTP_ST_CHUNK(chunk->chunk_hdr->type),"
    },
    {
        "line": 102,
        "fullcodeline": "SCTP_ST_CHUNK(0), repl,"
    },
    {
        "line": 106,
        "fullcodeline": "SCTP_STATE(SCTP_STATE_ESTABLISHED));"
    },
    {
        "line": 107,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));"
    },
    {
        "line": 55,
        "fullcodeline": "SCTP_CHUNK(err));"
    }
]