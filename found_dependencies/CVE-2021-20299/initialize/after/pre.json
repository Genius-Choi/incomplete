[
    {
        "line": 3,
        "fullcodeline": "readMagicNumberAndVersionField(*_data->is, _data->version);"
    },
    {
        "line": 5,
        "fullcodeline": "bool multipart = isMultiPart(_data->version);"
    },
    {
        "line": 6,
        "fullcodeline": "bool tiled = isTiled(_data->version);"
    },
    {
        "line": 16,
        "fullcodeline": "int pos = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "if (tiled && multipart)"
    },
    {
        "line": 47,
        "fullcodeline": "for (size_t i = 0; i < _data->_headers.size(); i++)"
    },
    {
        "line": 113,
        "fullcodeline": "if (multipart && strictSharedAttribute)"
    },
    {
        "line": 134,
        "fullcodeline": "for (size_t i = 0; i < _data->_headers.size(); i++)"
    },
    {
        "line": 135,
        "fullcodeline": "_data->parts.push_back("
    },
    {
        "line": 20,
        "fullcodeline": "header.readFrom(*_data->is, _data->version);"
    },
    {
        "line": 32,
        "fullcodeline": "_data->_headers.push_back(header);"
    },
    {
        "line": 42,
        "fullcodeline": "if ( _data->_headers.size() == 0)"
    },
    {
        "line": 96,
        "fullcodeline": "set<string> names;"
    },
    {
        "line": 136,
        "fullcodeline": "new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));"
    },
    {
        "line": 13,
        "fullcodeline": "throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");"
    },
    {
        "line": 26,
        "fullcodeline": "if (header.readsNothing())"
    },
    {
        "line": 34,
        "fullcodeline": "if(multipart == false)"
    },
    {
        "line": 97,
        "fullcodeline": "for (size_t i = 0; i < _data->_headers.size(); i++)"
    },
    {
        "line": 115,
        "fullcodeline": "for (size_t i = 1; i < _data->_headers.size(); i++)"
    },
    {
        "line": 53,
        "fullcodeline": "if( _data->_headers[i].hasType() == false )"
    },
    {
        "line": 59,
        "fullcodeline": "_data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);"
    },
    {
        "line": 78,
        "fullcodeline": "if( _data->_headers[i].hasName() == false )"
    },
    {
        "line": 84,
        "fullcodeline": "if (isTiled(_data->_headers[i].type()))"
    },
    {
        "line": 85,
        "fullcodeline": "_data->_headers[i].sanityCheck(true, multipart);"
    },
    {
        "line": 105,
        "fullcodeline": "names.insert(_data->_headers[i].name());"
    },
    {
        "line": 117,
        "fullcodeline": "vector <string> attrs;"
    },
    {
        "line": 87,
        "fullcodeline": "_data->_headers[i].sanityCheck(false, multipart);"
    },
    {
        "line": 118,
        "fullcodeline": "if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))"
    },
    {
        "line": 100,
        "fullcodeline": "if (names.find(_data->_headers[i].name()) != names.end())"
    },
    {
        "line": 70,
        "fullcodeline": "if(!multipart && !isNonImage(_data->version))"
    },
    {
        "line": 72,
        "fullcodeline": "_data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);"
    },
    {
        "line": 121,
        "fullcodeline": "for (size_t j=0; j<attrs.size(); j++)"
    },
    {
        "line": 122,
        "fullcodeline": "attrNames += \" \" + attrs[j];"
    },
    {
        "line": 102,
        "fullcodeline": "throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +"
    },
    {
        "line": 123,
        "fullcodeline": "throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +"
    }
]