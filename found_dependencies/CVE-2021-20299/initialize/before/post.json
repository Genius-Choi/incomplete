[
    {
        "line": 5,
        "fullcodeline": "bool multipart = isMultiPart(_data->version);"
    },
    {
        "line": 6,
        "fullcodeline": "bool tiled = isTiled(_data->version);"
    },
    {
        "line": 16,
        "fullcodeline": "int pos = 0;"
    },
    {
        "line": 133,
        "fullcodeline": "_data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);"
    },
    {
        "line": 12,
        "fullcodeline": "if (tiled && multipart)"
    },
    {
        "line": 42,
        "fullcodeline": "for (size_t i = 0; i < _data->_headers.size(); i++)"
    },
    {
        "line": 108,
        "fullcodeline": "if (multipart && strictSharedAttribute)"
    },
    {
        "line": 129,
        "fullcodeline": "for (size_t i = 0; i < _data->_headers.size(); i++)"
    },
    {
        "line": 130,
        "fullcodeline": "_data->parts.push_back("
    },
    {
        "line": 20,
        "fullcodeline": "header.readFrom(*_data->is, _data->version);"
    },
    {
        "line": 32,
        "fullcodeline": "_data->_headers.push_back(header);"
    },
    {
        "line": 91,
        "fullcodeline": "set<string> names;"
    },
    {
        "line": 131,
        "fullcodeline": "new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));"
    },
    {
        "line": 13,
        "fullcodeline": "throw IEX_NAMESPACE::InputExc (\"Multipart files cannot have the tiled bit set\");"
    },
    {
        "line": 26,
        "fullcodeline": "if (header.readsNothing())"
    },
    {
        "line": 34,
        "fullcodeline": "if(multipart == false)"
    },
    {
        "line": 48,
        "fullcodeline": "if( _data->_headers[i].hasType() == false )"
    },
    {
        "line": 73,
        "fullcodeline": "if( _data->_headers[i].hasName() == false )"
    },
    {
        "line": 79,
        "fullcodeline": "if (isTiled(_data->_headers[i].type()))"
    },
    {
        "line": 92,
        "fullcodeline": "for (size_t i = 0; i < _data->_headers.size(); i++)"
    },
    {
        "line": 110,
        "fullcodeline": "for (size_t i = 1; i < _data->_headers.size(); i++)"
    },
    {
        "line": 28,
        "fullcodeline": "pos++;"
    },
    {
        "line": 54,
        "fullcodeline": "_data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);"
    },
    {
        "line": 80,
        "fullcodeline": "_data->_headers[i].sanityCheck(true, multipart);"
    },
    {
        "line": 100,
        "fullcodeline": "names.insert(_data->_headers[i].name());"
    },
    {
        "line": 112,
        "fullcodeline": "vector <string> attrs;"
    },
    {
        "line": 82,
        "fullcodeline": "_data->_headers[i].sanityCheck(false, multipart);"
    },
    {
        "line": 95,
        "fullcodeline": "if (names.find(_data->_headers[i].name()) != names.end())"
    },
    {
        "line": 113,
        "fullcodeline": "if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))"
    },
    {
        "line": 65,
        "fullcodeline": "if(!multipart && !isNonImage(_data->version))"
    },
    {
        "line": 52,
        "fullcodeline": "throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a type\");"
    },
    {
        "line": 67,
        "fullcodeline": "_data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);"
    },
    {
        "line": 76,
        "fullcodeline": "throw IEX_NAMESPACE::ArgExc (\"Every header in a multipart file should have a name\");"
    },
    {
        "line": 97,
        "fullcodeline": "throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +"
    },
    {
        "line": 116,
        "fullcodeline": "for (size_t j=0; j<attrs.size(); j++)"
    },
    {
        "line": 117,
        "fullcodeline": "attrNames += \" \" + attrs[j];"
    },
    {
        "line": 118,
        "fullcodeline": "throw IEX_NAMESPACE::InputExc (\"Header name \" + _data->_headers[i].name() +"
    }
]