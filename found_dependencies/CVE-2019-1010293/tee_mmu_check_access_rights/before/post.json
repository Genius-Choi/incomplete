[
    {
        "line": 6,
        "fullcodeline": "size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,"
    },
    {
        "line": 9,
        "fullcodeline": "if (ADD_OVERFLOW(uaddr, len, &a))"
    },
    {
        "line": 12,
        "fullcodeline": "if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&"
    },
    {
        "line": 20,
        "fullcodeline": "if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&"
    },
    {
        "line": 24,
        "fullcodeline": "for (a = uaddr; a < (uaddr + len); a += addr_incr) {"
    },
    {
        "line": 13,
        "fullcodeline": "(flags & TEE_MEMORY_ACCESS_SECURE))"
    },
    {
        "line": 21,
        "fullcodeline": "!tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))"
    },
    {
        "line": 28,
        "fullcodeline": "res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);"
    },
    {
        "line": 29,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 32,
        "fullcodeline": "if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&"
    },
    {
        "line": 36,
        "fullcodeline": "if ((flags & TEE_MEMORY_ACCESS_SECURE) &&"
    },
    {
        "line": 40,
        "fullcodeline": "if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))"
    },
    {
        "line": 42,
        "fullcodeline": "if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))"
    },
    {
        "line": 33,
        "fullcodeline": "(attr & TEE_MATTR_SECURE))"
    },
    {
        "line": 37,
        "fullcodeline": "!(attr & TEE_MATTR_SECURE))"
    }
]