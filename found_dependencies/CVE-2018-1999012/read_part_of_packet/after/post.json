[
    {
        "line": 3,
        "fullcodeline": "AVIOContext *pb = s->pb;"
    },
    {
        "line": 4,
        "fullcodeline": "PVAContext *pvactx = s->priv_data;"
    },
    {
        "line": 6,
        "fullcodeline": "int64_t pva_pts = AV_NOPTS_VALUE, startpos;"
    },
    {
        "line": 10,
        "fullcodeline": "startpos = avio_tell(pb);"
    },
    {
        "line": 12,
        "fullcodeline": "syncword = avio_rb16(pb);"
    },
    {
        "line": 13,
        "fullcodeline": "streamid = avio_r8(pb);"
    },
    {
        "line": 14,
        "fullcodeline": "avio_r8(pb);               /* counter not used */"
    },
    {
        "line": 15,
        "fullcodeline": "reserved = avio_r8(pb);"
    },
    {
        "line": 16,
        "fullcodeline": "flags    = avio_r8(pb);"
    },
    {
        "line": 17,
        "fullcodeline": "length   = avio_rb16(pb);"
    },
    {
        "line": 19,
        "fullcodeline": "pts_flag = flags & 0x10;"
    },
    {
        "line": 99,
        "fullcodeline": "*pts   = pva_pts;"
    },
    {
        "line": 100,
        "fullcodeline": "*len   = length;"
    },
    {
        "line": 101,
        "fullcodeline": "*strid = streamid;"
    },
    {
        "line": 21,
        "fullcodeline": "if (syncword != PVA_MAGIC) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (reserved != 0x55) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (length > PVA_MAX_PAYLOAD_LENGTH) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (pva_pts != AV_NOPTS_VALUE)"
    },
    {
        "line": 22,
        "fullcodeline": "pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");"
    },
    {
        "line": 26,
        "fullcodeline": "pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");"
    },
    {
        "line": 30,
        "fullcodeline": "pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");"
    },
    {
        "line": 33,
        "fullcodeline": "pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);"
    },
    {
        "line": 38,
        "fullcodeline": "pva_pts = avio_rb32(pb);"
    },
    {
        "line": 39,
        "fullcodeline": "length -= 4;"
    },
    {
        "line": 97,
        "fullcodeline": "av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);"
    },
    {
        "line": 23,
        "fullcodeline": "return AVERROR(EIO);"
    },
    {
        "line": 27,
        "fullcodeline": "return AVERROR(EIO);"
    },
    {
        "line": 34,
        "fullcodeline": "return AVERROR(EIO);"
    },
    {
        "line": 40,
        "fullcodeline": "} else if (streamid == PVA_AUDIO_PAYLOAD) {"
    },
    {
        "line": 88,
        "fullcodeline": "pvactx->continue_pes -= length;"
    },
    {
        "line": 45,
        "fullcodeline": "if (!pvactx->continue_pes) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (pvactx->continue_pes < 0) {"
    },
    {
        "line": 48,
        "fullcodeline": "unsigned char pes_header_data[256];"
    },
    {
        "line": 50,
        "fullcodeline": "pes_signal             = avio_rb24(pb);"
    },
    {
        "line": 51,
        "fullcodeline": "avio_r8(pb);"
    },
    {
        "line": 52,
        "fullcodeline": "pes_packet_length      = avio_rb16(pb);"
    },
    {
        "line": 53,
        "fullcodeline": "pes_flags              = avio_rb16(pb);"
    },
    {
        "line": 54,
        "fullcodeline": "pes_header_data_length = avio_r8(pb);"
    },
    {
        "line": 69,
        "fullcodeline": "ret = avio_read(pb, pes_header_data, pes_header_data_length);"
    },
    {
        "line": 72,
        "fullcodeline": "length -= 9 + pes_header_data_length;"
    },
    {
        "line": 74,
        "fullcodeline": "pes_packet_length -= 3 + pes_header_data_length;"
    },
    {
        "line": 76,
        "fullcodeline": "pvactx->continue_pes = pes_packet_length;"
    },
    {
        "line": 91,
        "fullcodeline": "pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");"
    },
    {
        "line": 92,
        "fullcodeline": "pvactx->continue_pes = 0;"
    },
    {
        "line": 56,
        "fullcodeline": "if (avio_feof(pb)) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (pes_signal != 1 || pes_header_data_length == 0) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (ret != pes_header_data_length)"
    },
    {
        "line": 78,
        "fullcodeline": "if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {"
    },
    {
        "line": 61,
        "fullcodeline": "pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \""
    },
    {
        "line": 63,
        "fullcodeline": "avio_skip(pb, length - 9);"
    },
    {
        "line": 84,
        "fullcodeline": "pva_pts = ff_parse_pes_pts(pes_header_data);"
    },
    {
        "line": 64,
        "fullcodeline": "if (!read_packet)"
    },
    {
        "line": 71,
        "fullcodeline": "return ret < 0 ? ret : AVERROR_INVALIDDATA;"
    },
    {
        "line": 79,
        "fullcodeline": "if (pes_header_data_length < 5) {"
    },
    {
        "line": 80,
        "fullcodeline": "pva_log(s, AV_LOG_ERROR, \"header too short\\n\");"
    },
    {
        "line": 81,
        "fullcodeline": "avio_skip(pb, length);"
    },
    {
        "line": 65,
        "fullcodeline": "return AVERROR(EIO);"
    }
]