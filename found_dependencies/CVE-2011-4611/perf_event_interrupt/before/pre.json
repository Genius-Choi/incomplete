[
    {
        "line": 4,
        "fullcodeline": "struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);"
    },
    {
        "line": 7,
        "fullcodeline": "int found = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "perf_read_regs(regs);"
    },
    {
        "line": 16,
        "fullcodeline": "nmi = perf_intr_is_nmi(regs);"
    },
    {
        "line": 57,
        "fullcodeline": "write_mmcr0(cpuhw, cpuhw->mmcr[0]);"
    },
    {
        "line": 22,
        "fullcodeline": "for (i = 0; i < cpuhw->n_events; ++i) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (!found) {"
    },
    {
        "line": 11,
        "fullcodeline": "freeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),"
    },
    {
        "line": 18,
        "fullcodeline": "nmi_enter();"
    },
    {
        "line": 23,
        "fullcodeline": "event = cpuhw->event[i];"
    },
    {
        "line": 26,
        "fullcodeline": "val = read_pmc(event->hw.idx);"
    },
    {
        "line": 60,
        "fullcodeline": "nmi_exit();"
    },
    {
        "line": 12,
        "fullcodeline": "mfspr(SPRN_PMC6));"
    },
    {
        "line": 20,
        "fullcodeline": "irq_enter();"
    },
    {
        "line": 24,
        "fullcodeline": "if (!event->hw.idx || is_limited_pmc(event->hw.idx))"
    },
    {
        "line": 27,
        "fullcodeline": "if ((int)val < 0) {"
    },
    {
        "line": 41,
        "fullcodeline": "for (i = 0; i < ppmu->n_counter; ++i) {"
    },
    {
        "line": 29,
        "fullcodeline": "found = 1;"
    },
    {
        "line": 30,
        "fullcodeline": "record_and_restart(event, val, regs, nmi);"
    },
    {
        "line": 44,
        "fullcodeline": "val = read_pmc(i + 1);"
    },
    {
        "line": 42,
        "fullcodeline": "if (is_limited_pmc(i + 1))"
    },
    {
        "line": 45,
        "fullcodeline": "if ((int)val < 0)"
    },
    {
        "line": 46,
        "fullcodeline": "write_pmc(i + 1, 0);"
    }
]