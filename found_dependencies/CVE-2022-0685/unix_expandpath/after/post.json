[
    {
        "line": 11,
        "fullcodeline": "int\t\tstart_len = gap->ga_len;"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\tstarstar = FALSE;"
    },
    {
        "line": 18,
        "fullcodeline": "static int\tstardepth = 0;\t    // depth for \"**\" expansion"
    },
    {
        "line": 32,
        "fullcodeline": "buf = alloc(STRLEN(path) + BASENAMELEN + 5);"
    },
    {
        "line": 41,
        "fullcodeline": "p = buf;"
    },
    {
        "line": 42,
        "fullcodeline": "s = buf;"
    },
    {
        "line": 43,
        "fullcodeline": "e = NULL;"
    },
    {
        "line": 44,
        "fullcodeline": "path_end = path;"
    },
    {
        "line": 72,
        "fullcodeline": "e = p;"
    },
    {
        "line": 73,
        "fullcodeline": "*e = NUL;"
    },
    {
        "line": 92,
        "fullcodeline": "starts_with_dot = *s == '.';"
    },
    {
        "line": 93,
        "fullcodeline": "pat = file_pat_to_reg_pat(s, e, NULL, FALSE);"
    },
    {
        "line": 107,
        "fullcodeline": "regmatch.regprog = vim_regcomp(pat, RE_MAGIC);"
    },
    {
        "line": 110,
        "fullcodeline": "vim_free(pat);"
    },
    {
        "line": 130,
        "fullcodeline": "*s = NUL;"
    },
    {
        "line": 131,
        "fullcodeline": "dirp = opendir(*buf == NUL ? \".\" : (char *)buf);"
    },
    {
        "line": 203,
        "fullcodeline": "vim_free(buf);"
    },
    {
        "line": 204,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 206,
        "fullcodeline": "matches = gap->ga_len - start_len;"
    },
    {
        "line": 24,
        "fullcodeline": "if (stardepth > 0)"
    },
    {
        "line": 33,
        "fullcodeline": "if (buf == NULL)"
    },
    {
        "line": 45,
        "fullcodeline": "while (*path_end != NUL)"
    },
    {
        "line": 78,
        "fullcodeline": "for (p = buf + wildoff; p < s; ++p)"
    },
    {
        "line": 87,
        "fullcodeline": "for (p = s; p < e; ++p)"
    },
    {
        "line": 94,
        "fullcodeline": "if (pat == NULL)"
    },
    {
        "line": 101,
        "fullcodeline": "if (flags & EW_ICASE)"
    },
    {
        "line": 105,
        "fullcodeline": "if (flags & (EW_NOERROR | EW_NOTWILD))"
    },
    {
        "line": 108,
        "fullcodeline": "if (flags & (EW_NOERROR | EW_NOTWILD))"
    },
    {
        "line": 112,
        "fullcodeline": "if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)"
    },
    {
        "line": 120,
        "fullcodeline": "if (!didstar && stardepth < 100 && starstar && e - s == 2"
    },
    {
        "line": 134,
        "fullcodeline": "if (dirp != NULL)"
    },
    {
        "line": 207,
        "fullcodeline": "if (matches > 0)"
    },
    {
        "line": 26,
        "fullcodeline": "ui_breakcheck();"
    },
    {
        "line": 79,
        "fullcodeline": "if (rem_backslash(p))"
    },
    {
        "line": 88,
        "fullcodeline": "if (p[0] == '*' && p[1] == '*')"
    },
    {
        "line": 96,
        "fullcodeline": "vim_free(buf);"
    },
    {
        "line": 102,
        "fullcodeline": "regmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set"
    },
    {
        "line": 106,
        "fullcodeline": "++emsg_silent;"
    },
    {
        "line": 109,
        "fullcodeline": "--emsg_silent;"
    },
    {
        "line": 114,
        "fullcodeline": "vim_free(buf);"
    },
    {
        "line": 121,
        "fullcodeline": "&& *path_end == '/')"
    },
    {
        "line": 123,
        "fullcodeline": "STRCPY(s, path_end + 1);"
    },
    {
        "line": 124,
        "fullcodeline": "++stardepth;"
    },
    {
        "line": 125,
        "fullcodeline": "(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);"
    },
    {
        "line": 126,
        "fullcodeline": "--stardepth;"
    },
    {
        "line": 200,
        "fullcodeline": "closedir(dirp);"
    },
    {
        "line": 208,
        "fullcodeline": "qsort(((char_u **)gap->ga_data) + start_len, matches,"
    },
    {
        "line": 49,
        "fullcodeline": "if (path_end >= path + wildoff && rem_backslash(path_end))"
    },
    {
        "line": 81,
        "fullcodeline": "STRMOVE(p, p + 1);"
    },
    {
        "line": 82,
        "fullcodeline": "--e;"
    },
    {
        "line": 83,
        "fullcodeline": "--s;"
    },
    {
        "line": 89,
        "fullcodeline": "starstar = TRUE;"
    },
    {
        "line": 104,
        "fullcodeline": "regmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set"
    },
    {
        "line": 64,
        "fullcodeline": "len = (*mb_ptr2len)(path_end);"
    },
    {
        "line": 65,
        "fullcodeline": "STRNCPY(p, path_end, len);"
    },
    {
        "line": 66,
        "fullcodeline": "p += len;"
    },
    {
        "line": 67,
        "fullcodeline": "path_end += len;"
    },
    {
        "line": 138,
        "fullcodeline": "dp = readdir(dirp);"
    },
    {
        "line": 139,
        "fullcodeline": "if (dp == NULL)"
    },
    {
        "line": 141,
        "fullcodeline": "if ((dp->d_name[0] != '.' || starts_with_dot"
    },
    {
        "line": 50,
        "fullcodeline": "*p++ = *path_end++;"
    },
    {
        "line": 51,
        "fullcodeline": "else if (*path_end == '/')"
    },
    {
        "line": 145,
        "fullcodeline": "&& ((regmatch.regprog != NULL && vim_regexec(&regmatch,"
    },
    {
        "line": 150,
        "fullcodeline": "STRCPY(s, dp->d_name);"
    },
    {
        "line": 151,
        "fullcodeline": "len = STRLEN(buf);"
    },
    {
        "line": 164,
        "fullcodeline": "STRCPY(buf + len, path_end);"
    },
    {
        "line": 55,
        "fullcodeline": "s = p + 1;"
    },
    {
        "line": 70,
        "fullcodeline": "*p++ = *path_end++;"
    },
    {
        "line": 142,
        "fullcodeline": "|| ((flags & EW_DODOT)"
    },
    {
        "line": 147,
        "fullcodeline": "|| ((flags & EW_NOTWILD)"
    },
    {
        "line": 153,
        "fullcodeline": "if (starstar && stardepth < 100)"
    },
    {
        "line": 165,
        "fullcodeline": "if (mch_has_exp_wildcard(path_end)) // handle more wildcards"
    },
    {
        "line": 53,
        "fullcodeline": "if (e != NULL)"
    },
    {
        "line": 144,
        "fullcodeline": "&& (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))"
    },
    {
        "line": 148,
        "fullcodeline": "&& fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))"
    },
    {
        "line": 157,
        "fullcodeline": "STRCPY(buf + len, \"/**\");"
    },
    {
        "line": 158,
        "fullcodeline": "STRCPY(buf + len + 3, path_end);"
    },
    {
        "line": 159,
        "fullcodeline": "++stardepth;"
    },
    {
        "line": 160,
        "fullcodeline": "(void)unix_expandpath(gap, buf, len + 1, flags, TRUE);"
    },
    {
        "line": 161,
        "fullcodeline": "--stardepth;"
    },
    {
        "line": 169,
        "fullcodeline": "(void)unix_expandpath(gap, buf, len + 1, flags, FALSE);"
    },
    {
        "line": 57,
        "fullcodeline": "else if (path_end >= path + wildoff"
    },
    {
        "line": 143,
        "fullcodeline": "&& dp->d_name[1] != NUL"
    },
    {
        "line": 146,
        "fullcodeline": "(char_u *)dp->d_name, (colnr_T)0))"
    },
    {
        "line": 58,
        "fullcodeline": "&& (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL"
    },
    {
        "line": 61,
        "fullcodeline": "e = p;"
    },
    {
        "line": 177,
        "fullcodeline": "if (*path_end != NUL)"
    },
    {
        "line": 180,
        "fullcodeline": "if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0"
    },
    {
        "line": 59,
        "fullcodeline": "|| (!p_fic && (flags & EW_ICASE)"
    },
    {
        "line": 178,
        "fullcodeline": "backslash_halve(buf + len + 1);"
    },
    {
        "line": 181,
        "fullcodeline": ": mch_getperm(buf) >= 0)"
    },
    {
        "line": 194,
        "fullcodeline": "addfile(gap, buf, flags);"
    },
    {
        "line": 60,
        "fullcodeline": "&& vim_isalpha(PTR2CHAR(path_end)))))"
    }
]