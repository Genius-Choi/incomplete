[
    {
        "line": 5,
        "fullcodeline": "char_u\t*arg = arg_start;"
    },
    {
        "line": 7,
        "fullcodeline": "int\t\tdid_show = FALSE;   // already showed one value"
    },
    {
        "line": 9,
        "fullcodeline": "if (*arg == NUL)"
    },
    {
        "line": 16,
        "fullcodeline": "while (*arg != NUL)\t\t// loop to process all options"
    },
    {
        "line": 12,
        "fullcodeline": "did_show = TRUE;"
    },
    {
        "line": 95,
        "fullcodeline": "arg = skipwhite(arg);"
    },
    {
        "line": 18,
        "fullcodeline": "if (STRNCMP(arg, \"all\", 3) == 0 && !ASCII_ISALPHA(arg[3])"
    },
    {
        "line": 19,
        "fullcodeline": "&& !(opt_flags & OPT_MODELINE))"
    },
    {
        "line": 23,
        "fullcodeline": "arg += 3;"
    },
    {
        "line": 24,
        "fullcodeline": "if (*arg == '&')"
    },
    {
        "line": 26,
        "fullcodeline": "++arg;"
    },
    {
        "line": 28,
        "fullcodeline": "set_options_default(OPT_FREE | opt_flags);"
    },
    {
        "line": 29,
        "fullcodeline": "didset_options();"
    },
    {
        "line": 30,
        "fullcodeline": "didset_options2();"
    },
    {
        "line": 31,
        "fullcodeline": "redraw_all_later(UPD_CLEAR);"
    },
    {
        "line": 39,
        "fullcodeline": "else if (STRNCMP(arg, \"termcap\", 7) == 0 && !(opt_flags & OPT_MODELINE))"
    },
    {
        "line": 35,
        "fullcodeline": "showoptions(1, opt_flags);"
    },
    {
        "line": 36,
        "fullcodeline": "did_show = TRUE;"
    },
    {
        "line": 41,
        "fullcodeline": "showoptions(2, opt_flags);"
    },
    {
        "line": 42,
        "fullcodeline": "show_termcodes(opt_flags);"
    },
    {
        "line": 43,
        "fullcodeline": "did_show = TRUE;"
    },
    {
        "line": 44,
        "fullcodeline": "arg += 7;"
    },
    {
        "line": 48,
        "fullcodeline": "int\t\tstopopteval = FALSE;"
    },
    {
        "line": 49,
        "fullcodeline": "char\t*errmsg = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "char\terrbuf[ERR_BUFLEN];"
    },
    {
        "line": 51,
        "fullcodeline": "char_u\t*startarg = arg;"
    },
    {
        "line": 53,
        "fullcodeline": "errmsg = do_set_option(opt_flags, &arg, arg_start, &startarg,"
    },
    {
        "line": 63,
        "fullcodeline": "for (i = 0; i < 2 ; ++i)"
    },
    {
        "line": 73,
        "fullcodeline": "if (errmsg != NULL)"
    },
    {
        "line": 68,
        "fullcodeline": "arg = skipwhite(arg);"
    },
    {
        "line": 75,
        "fullcodeline": "vim_strncpy(IObuff, (char_u *)_(errmsg), IOSIZE - 1);"
    },
    {
        "line": 76,
        "fullcodeline": "i = (int)STRLEN(IObuff) + 2;"
    },
    {
        "line": 85,
        "fullcodeline": "trans_characters(IObuff, IOSIZE);"
    },
    {
        "line": 87,
        "fullcodeline": "++no_wait_return;\t\t// wait_return() done later"
    },
    {
        "line": 88,
        "fullcodeline": "emsg((char *)IObuff);\t// show error highlighted"
    },
    {
        "line": 89,
        "fullcodeline": "--no_wait_return;"
    },
    {
        "line": 65,
        "fullcodeline": "while (*arg != NUL && !VIM_ISWHITE(*arg))"
    },
    {
        "line": 69,
        "fullcodeline": "if (*arg != '=')"
    },
    {
        "line": 77,
        "fullcodeline": "if (i + (arg - startarg) < IOSIZE)"
    },
    {
        "line": 66,
        "fullcodeline": "if (*arg++ == '\\\\' && *arg != NUL)"
    },
    {
        "line": 80,
        "fullcodeline": "STRCAT(IObuff, \": \");"
    },
    {
        "line": 81,
        "fullcodeline": "mch_memmove(IObuff + i, startarg, (arg - startarg));"
    },
    {
        "line": 82,
        "fullcodeline": "IObuff[i + (arg - startarg)] = NUL;"
    },
    {
        "line": 67,
        "fullcodeline": "++arg;"
    }
]