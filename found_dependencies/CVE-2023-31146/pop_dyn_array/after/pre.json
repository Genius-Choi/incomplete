[
    {
        "line": 2,
        "fullcodeline": "assert isinstance(darray_node.typ, DArrayT)"
    },
    {
        "line": 3,
        "fullcodeline": "assert darray_node.encoding == Encoding.VYPER"
    },
    {
        "line": 4,
        "fullcodeline": "ret = [\"seq\"]"
    },
    {
        "line": 5,
        "fullcodeline": "with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):"
    },
    {
        "line": 6,
        "fullcodeline": "old_len = clamp(\"gt\", get_dyn_array_count(darray_node), 0)"
    },
    {
        "line": 7,
        "fullcodeline": "new_len = IRnode.from_list([\"sub\", old_len, 1], typ=UINT256_T)"
    },
    {
        "line": 9,
        "fullcodeline": "with new_len.cache_when_complex(\"new_len\") as (b2, new_len):"
    },
    {
        "line": 11,
        "fullcodeline": "ret.append(STORE(darray_node, new_len))"
    },
    {
        "line": 22,
        "fullcodeline": "return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=typ, location=location)"
    },
    {
        "line": 15,
        "fullcodeline": "popped_item = get_element_ptr(darray_node, new_len, array_bounds_check=False)"
    },
    {
        "line": 16,
        "fullcodeline": "ret.append(popped_item)"
    },
    {
        "line": 17,
        "fullcodeline": "typ = popped_item.typ"
    },
    {
        "line": 18,
        "fullcodeline": "location = popped_item.location"
    },
    {
        "line": 20,
        "fullcodeline": "typ, location = None, None"
    }
]