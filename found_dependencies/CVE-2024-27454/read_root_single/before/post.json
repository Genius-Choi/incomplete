[
    {
        "line": 35,
        "fullcodeline": "hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;"
    },
    {
        "line": 36,
        "fullcodeline": "alc_num = hdr_len + 1; /* single value */"
    },
    {
        "line": 38,
        "fullcodeline": "val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_num * sizeof(yyjson_val));"
    },
    {
        "line": 40,
        "fullcodeline": "val = val_hdr + hdr_len;"
    },
    {
        "line": 41,
        "fullcodeline": "raw = has_read_flag(NUMBER_AS_RAW) || has_read_flag(BIGNUM_AS_RAW);"
    },
    {
        "line": 42,
        "fullcodeline": "inv = has_read_flag(ALLOW_INVALID_UNICODE) != 0;"
    },
    {
        "line": 43,
        "fullcodeline": "raw_end = NULL;"
    },
    {
        "line": 44,
        "fullcodeline": "pre = raw ? &raw_end : NULL;"
    },
    {
        "line": 88,
        "fullcodeline": "doc = (yyjson_doc *)val_hdr;"
    },
    {
        "line": 89,
        "fullcodeline": "doc->root = val_hdr + hdr_len;"
    },
    {
        "line": 90,
        "fullcodeline": "doc->alc = alc;"
    },
    {
        "line": 91,
        "fullcodeline": "doc->dat_read = (usize)(cur - hdr);"
    },
    {
        "line": 92,
        "fullcodeline": "doc->val_read = 1;"
    },
    {
        "line": 93,
        "fullcodeline": "doc->str_pool = has_read_flag(INSITU) ? NULL : (char *)hdr;"
    },
    {
        "line": 97,
        "fullcodeline": "return_err(cur, INVALID_STRING, msg);"
    },
    {
        "line": 99,
        "fullcodeline": "return_err(cur, INVALID_NUMBER, msg);"
    },
    {
        "line": 101,
        "fullcodeline": "return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");"
    },
    {
        "line": 103,
        "fullcodeline": "return_err(cur, LITERAL, \"invalid literal\");"
    },
    {
        "line": 105,
        "fullcodeline": "return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");"
    },
    {
        "line": 107,
        "fullcodeline": "return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");"
    },
    {
        "line": 109,
        "fullcodeline": "return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");"
    },
    {
        "line": 39,
        "fullcodeline": "if (unlikely(!val_hdr)) goto fail_alloc;"
    },
    {
        "line": 50,
        "fullcodeline": "if (*cur == '\"') {"
    },
    {
        "line": 54,
        "fullcodeline": "if (*cur == 't') {"
    },
    {
        "line": 58,
        "fullcodeline": "if (*cur == 'f') {"
    },
    {
        "line": 62,
        "fullcodeline": "if (*cur == 'n') {"
    },
    {
        "line": 69,
        "fullcodeline": "if (has_read_flag(ALLOW_INF_AND_NAN)) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (unlikely(cur < end) && !has_read_flag(STOP_WHEN_DONE)) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (pre && *pre) **pre = '\\0';"
    },
    {
        "line": 47,
        "fullcodeline": "if (likely(read_number(&cur, pre, flg, val, &msg))) goto doc_end;"
    },
    {
        "line": 51,
        "fullcodeline": "if (likely(read_string(&cur, end, inv, val, &msg))) goto doc_end;"
    },
    {
        "line": 55,
        "fullcodeline": "if (likely(read_true(&cur, val))) goto doc_end;"
    },
    {
        "line": 59,
        "fullcodeline": "if (likely(read_false(&cur, val))) goto doc_end;"
    },
    {
        "line": 63,
        "fullcodeline": "if (likely(read_null(&cur, val))) goto doc_end;"
    },
    {
        "line": 64,
        "fullcodeline": "if (has_read_flag(ALLOW_INF_AND_NAN)) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (read_inf_or_nan(false, &cur, pre, val)) goto doc_end;"
    },
    {
        "line": 77,
        "fullcodeline": "if (has_read_flag(ALLOW_COMMENTS)) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (unlikely(cur < end)) goto fail_garbage;"
    },
    {
        "line": 65,
        "fullcodeline": "if (read_nan(false, &cur, pre, val)) goto doc_end;"
    },
    {
        "line": 78,
        "fullcodeline": "if (!skip_spaces_and_comments(&cur)) {"
    },
    {
        "line": 82,
        "fullcodeline": "while (char_is_space(*cur)) cur++;"
    },
    {
        "line": 79,
        "fullcodeline": "if (byte_match_2(cur, \"/*\")) goto fail_comment;"
    }
]