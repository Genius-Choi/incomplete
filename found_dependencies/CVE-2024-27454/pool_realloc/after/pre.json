[
    {
        "line": 4,
        "fullcodeline": "pool_ctx *ctx = (pool_ctx *)ctx_ptr;"
    },
    {
        "line": 5,
        "fullcodeline": "pool_chunk *cur = ((pool_chunk *)ptr) - 1, *prev, *next, *tmp;"
    },
    {
        "line": 9,
        "fullcodeline": "pool_size_align(&old_size);"
    },
    {
        "line": 10,
        "fullcodeline": "pool_size_align(&size);"
    },
    {
        "line": 15,
        "fullcodeline": "next = ctx->free_list;"
    },
    {
        "line": 8,
        "fullcodeline": "if (unlikely(size >= ctx->size)) return NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "while (next && next < cur) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (unlikely(old_size == size)) return ptr;"
    },
    {
        "line": 18,
        "fullcodeline": "next = next->next;"
    },
    {
        "line": 21,
        "fullcodeline": "if ((u8 *)cur + cur->size == (u8 *)next && cur->size + next->size >= size) {"
    },
    {
        "line": 23,
        "fullcodeline": "usize free_size = cur->size + next->size - size;"
    },
    {
        "line": 24,
        "fullcodeline": "if (free_size > sizeof(pool_chunk) * 2) {"
    },
    {
        "line": 39,
        "fullcodeline": "void *new_ptr = pool_malloc(ctx_ptr, size - sizeof(pool_chunk));"
    },
    {
        "line": 25,
        "fullcodeline": "tmp = (pool_chunk *)(void *)((u8 *)cur + size);"
    },
    {
        "line": 41,
        "fullcodeline": "memcpy(new_ptr, ptr, cur->size - sizeof(pool_chunk));"
    }
]