[
    {
        "line": 5,
        "fullcodeline": "SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;"
    },
    {
        "line": 6,
        "fullcodeline": "size_t maxRank = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions("
    },
    {
        "line": 20,
        "fullcodeline": "SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);"
    },
    {
        "line": 44,
        "fullcodeline": "SmallVector<Value> elements;"
    },
    {
        "line": 13,
        "fullcodeline": "if (maxRank == 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (llvm::is_splat(shape_and_rank_for_dim) &&"
    },
    {
        "line": 45,
        "fullcodeline": "for (int i = 0; i != maxRank; ++i) {"
    },
    {
        "line": 60,
        "fullcodeline": "return Value(builder->create<tensor::FromElementsOp>(loc, elements));"
    },
    {
        "line": 8,
        "fullcodeline": "auto found_shape = analysis.GetValueInfo(shape.value());"
    },
    {
        "line": 10,
        "fullcodeline": "shapes_found.push_back(*found_shape);"
    },
    {
        "line": 11,
        "fullcodeline": "maxRank = std::max(maxRank, found_shape->size());"
    },
    {
        "line": 55,
        "fullcodeline": "Value index = builder->create<ConstantIndexOp>("
    },
    {
        "line": 57,
        "fullcodeline": "elements.push_back(builder->create<tensor::ExtractOp>("
    },
    {
        "line": 9,
        "fullcodeline": "if (!found_shape) return {};"
    },
    {
        "line": 14,
        "fullcodeline": "return Value(builder->create<tensor::FromElementsOp>("
    },
    {
        "line": 27,
        "fullcodeline": "auto index = maxRank - dim.index() - 1;"
    },
    {
        "line": 48,
        "fullcodeline": "auto one = builder->getIntegerAttr("
    },
    {
        "line": 50,
        "fullcodeline": "elements.push_back(builder->create<ConstantOp>(loc, one));"
    },
    {
        "line": 24,
        "fullcodeline": "if (dim.value().isConstant(1)) continue;"
    },
    {
        "line": 28,
        "fullcodeline": "if (!joined_dimensions[index]) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (*joined_dimensions[index] != dim.value()) return {};"
    },
    {
        "line": 56,
        "fullcodeline": "loc, i - maxRank + shape_and_rank_for_dim[i].second);"
    },
    {
        "line": 58,
        "fullcodeline": "loc, shape_and_rank_for_dim[i].first, index));"
    },
    {
        "line": 15,
        "fullcodeline": "loc, shapes[0].getType(), SmallVector<Value>()));"
    },
    {
        "line": 29,
        "fullcodeline": "joined_dimensions[index] = &dim.value();"
    },
    {
        "line": 30,
        "fullcodeline": "shape_and_rank_for_dim[index] ="
    },
    {
        "line": 49,
        "fullcodeline": "shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);"
    },
    {
        "line": 31,
        "fullcodeline": "std::make_pair(shapes[shape.index()], shape.value().size());"
    }
]