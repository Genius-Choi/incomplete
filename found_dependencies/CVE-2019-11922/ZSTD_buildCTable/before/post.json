[
    {
        "line": 9,
        "fullcodeline": "BYTE* op = (BYTE*)dst;"
    },
    {
        "line": 10,
        "fullcodeline": "const BYTE* const oend = op + dstCapacity;"
    },
    {
        "line": 14,
        "fullcodeline": "*op = codeTable[0];"
    },
    {
        "line": 15,
        "fullcodeline": "CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));"
    },
    {
        "line": 18,
        "fullcodeline": "memcpy(nextCTable, prevCTable, prevCTableSize);"
    },
    {
        "line": 21,
        "fullcodeline": "CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));  /* note : could be pre-calculated */"
    },
    {
        "line": 24,
        "fullcodeline": "S16 norm[MaxSeq + 1];"
    },
    {
        "line": 25,
        "fullcodeline": "size_t nbSeq_1 = nbSeq;"
    },
    {
        "line": 26,
        "fullcodeline": "const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);"
    },
    {
        "line": 31,
        "fullcodeline": "assert(nbSeq_1 > 1);"
    },
    {
        "line": 32,
        "fullcodeline": "CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));"
    },
    {
        "line": 39,
        "fullcodeline": "default: return assert(0), ERROR(GENERIC);"
    },
    {
        "line": 27,
        "fullcodeline": "if (count[codeTable[nbSeq-1]] > 1) {"
    },
    {
        "line": 33,
        "fullcodeline": "{   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);   /* overflow protected */"
    },
    {
        "line": 35,
        "fullcodeline": "CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));"
    },
    {
        "line": 28,
        "fullcodeline": "count[codeTable[nbSeq-1]]--;"
    },
    {
        "line": 29,
        "fullcodeline": "nbSeq_1--;"
    },
    {
        "line": 34,
        "fullcodeline": "if (FSE_isError(NCountSize)) return NCountSize;"
    }
]