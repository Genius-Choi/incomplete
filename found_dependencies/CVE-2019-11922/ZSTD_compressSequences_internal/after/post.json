[
    {
        "line": 9,
        "fullcodeline": "const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;"
    },
    {
        "line": 11,
        "fullcodeline": "U32 count[MaxSeq+1];"
    },
    {
        "line": 16,
        "fullcodeline": "const seqDef* const sequences = seqStorePtr->sequencesStart;"
    },
    {
        "line": 17,
        "fullcodeline": "const BYTE* const ofCodeTable = seqStorePtr->ofCode;"
    },
    {
        "line": 18,
        "fullcodeline": "const BYTE* const llCodeTable = seqStorePtr->llCode;"
    },
    {
        "line": 19,
        "fullcodeline": "const BYTE* const mlCodeTable = seqStorePtr->mlCode;"
    },
    {
        "line": 20,
        "fullcodeline": "BYTE* const ostart = (BYTE*)dst;"
    },
    {
        "line": 21,
        "fullcodeline": "BYTE* const oend = ostart + dstCapacity;"
    },
    {
        "line": 22,
        "fullcodeline": "BYTE* op = ostart;"
    },
    {
        "line": 23,
        "fullcodeline": "size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;"
    },
    {
        "line": 25,
        "fullcodeline": "BYTE* lastNCount = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "ZSTD_STATIC_ASSERT(HUF_WORKSPACE_SIZE >= (1<<MAX(MLFSELog,LLFSELog)));"
    },
    {
        "line": 61,
        "fullcodeline": "seqHead = op++;"
    },
    {
        "line": 64,
        "fullcodeline": "ZSTD_seqToCodes(seqStorePtr);"
    },
    {
        "line": 117,
        "fullcodeline": "*seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));"
    },
    {
        "line": 30,
        "fullcodeline": "{   const BYTE* const literals = seqStorePtr->litStart;"
    },
    {
        "line": 31,
        "fullcodeline": "size_t const litSize = seqStorePtr->lit - literals;"
    },
    {
        "line": 32,
        "fullcodeline": "int const disableLiteralCompression = (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);"
    },
    {
        "line": 33,
        "fullcodeline": "size_t const cSize = ZSTD_compressLiterals("
    },
    {
        "line": 42,
        "fullcodeline": "assert(cSize <= dstCapacity);"
    },
    {
        "line": 43,
        "fullcodeline": "op += cSize;"
    },
    {
        "line": 47,
        "fullcodeline": "if ((oend-op) < 3 /*max nbSeq Size*/ + 1 /*seqHead*/) return ERROR(dstSize_tooSmall);"
    },
    {
        "line": 48,
        "fullcodeline": "if (nbSeq < 0x7F)"
    },
    {
        "line": 54,
        "fullcodeline": "if (nbSeq==0) {"
    },
    {
        "line": 66,
        "fullcodeline": "{   U32 max = MaxLL;"
    },
    {
        "line": 67,
        "fullcodeline": "size_t const mostFrequent = HIST_countFast_wksp(count, &max, llCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */"
    },
    {
        "line": 68,
        "fullcodeline": "DEBUGLOG(5, \"Building LL table\");"
    },
    {
        "line": 70,
        "fullcodeline": "LLtype = ZSTD_selectEncodingType(&nextEntropy->fse.litlength_repeatMode, count, max, mostFrequent, nbSeq, LLFSELog, prevEntropy->fse.litlengthCTable, LL_defaultNorm, LL_defaultNormLog, ZSTD_defaultAllowed, strategy);"
    },
    {
        "line": 71,
        "fullcodeline": "assert(set_basic < set_compressed && set_rle < set_compressed);"
    },
    {
        "line": 72,
        "fullcodeline": "assert(!(LLtype < set_compressed && nextEntropy->fse.litlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */"
    },
    {
        "line": 83,
        "fullcodeline": "{   U32 max = MaxOff;"
    },
    {
        "line": 84,
        "fullcodeline": "size_t const mostFrequent = HIST_countFast_wksp(count, &max, ofCodeTable, nbSeq, workspace, wkspSize);  /* can't fail */"
    },
    {
        "line": 86,
        "fullcodeline": "ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;"
    },
    {
        "line": 87,
        "fullcodeline": "DEBUGLOG(5, \"Building OF table\");"
    },
    {
        "line": 89,
        "fullcodeline": "Offtype = ZSTD_selectEncodingType(&nextEntropy->fse.offcode_repeatMode, count, max, mostFrequent, nbSeq, OffFSELog, prevEntropy->fse.offcodeCTable, OF_defaultNorm, OF_defaultNormLog, defaultPolicy, strategy);"
    },
    {
        "line": 90,
        "fullcodeline": "assert(!(Offtype < set_compressed && nextEntropy->fse.offcode_repeatMode != FSE_repeat_none)); /* We don't copy tables */"
    },
    {
        "line": 101,
        "fullcodeline": "{   U32 max = MaxML;"
    },
    {
        "line": 102,
        "fullcodeline": "size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */"
    },
    {
        "line": 103,
        "fullcodeline": "DEBUGLOG(5, \"Building ML table (remaining space : %i)\", (int)(oend-op));"
    },
    {
        "line": 105,
        "fullcodeline": "MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);"
    },
    {
        "line": 106,
        "fullcodeline": "assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */"
    },
    {
        "line": 119,
        "fullcodeline": "{   size_t const bitstreamSize = ZSTD_encodeSequences("
    },
    {
        "line": 127,
        "fullcodeline": "op += bitstreamSize;"
    },
    {
        "line": 145,
        "fullcodeline": "return op - ostart;"
    },
    {
        "line": 40,
        "fullcodeline": "if (ZSTD_isError(cSize))"
    },
    {
        "line": 49,
        "fullcodeline": "*op++ = (BYTE)nbSeq;"
    },
    {
        "line": 56,
        "fullcodeline": "memcpy(&nextEntropy->fse, &prevEntropy->fse, sizeof(prevEntropy->fse));"
    },
    {
        "line": 73,
        "fullcodeline": "{   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,"
    },
    {
        "line": 80,
        "fullcodeline": "op += countSize;"
    },
    {
        "line": 91,
        "fullcodeline": "{   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,"
    },
    {
        "line": 98,
        "fullcodeline": "op += countSize;"
    },
    {
        "line": 107,
        "fullcodeline": "{   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,"
    },
    {
        "line": 114,
        "fullcodeline": "op += countSize;"
    },
    {
        "line": 126,
        "fullcodeline": "if (ZSTD_isError(bitstreamSize)) return bitstreamSize;"
    },
    {
        "line": 136,
        "fullcodeline": "if (lastNCount && (op - lastNCount) < 4) {"
    },
    {
        "line": 57,
        "fullcodeline": "return op - ostart;"
    },
    {
        "line": 77,
        "fullcodeline": "if (ZSTD_isError(countSize)) return countSize;"
    },
    {
        "line": 78,
        "fullcodeline": "if (LLtype == set_compressed)"
    },
    {
        "line": 95,
        "fullcodeline": "if (ZSTD_isError(countSize)) return countSize;"
    },
    {
        "line": 96,
        "fullcodeline": "if (Offtype == set_compressed)"
    },
    {
        "line": 111,
        "fullcodeline": "if (ZSTD_isError(countSize)) return countSize;"
    },
    {
        "line": 112,
        "fullcodeline": "if (MLtype == set_compressed)"
    },
    {
        "line": 120,
        "fullcodeline": "op, oend - op,"
    },
    {
        "line": 138,
        "fullcodeline": "assert(op - lastNCount == 3);"
    },
    {
        "line": 139,
        "fullcodeline": "DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \""
    },
    {
        "line": 50,
        "fullcodeline": "else if (nbSeq < LONGNBSEQ)"
    },
    {
        "line": 79,
        "fullcodeline": "lastNCount = op;"
    },
    {
        "line": 97,
        "fullcodeline": "lastNCount = op;"
    },
    {
        "line": 113,
        "fullcodeline": "lastNCount = op;"
    },
    {
        "line": 51,
        "fullcodeline": "op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;"
    },
    {
        "line": 53,
        "fullcodeline": "op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;"
    }
]