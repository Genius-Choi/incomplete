[
    {
        "line": 5,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "last_dest = dest_mnt;"
    },
    {
        "line": 14,
        "fullcodeline": "first_source = source_mnt;"
    },
    {
        "line": 15,
        "fullcodeline": "last_source = source_mnt;"
    },
    {
        "line": 16,
        "fullcodeline": "mp = dest_mp;"
    },
    {
        "line": 17,
        "fullcodeline": "list = tree_list;"
    },
    {
        "line": 18,
        "fullcodeline": "dest_master = dest_mnt->mnt_master;"
    },
    {
        "line": 40,
        "fullcodeline": "read_seqlock_excl(&mount_lock);"
    },
    {
        "line": 41,
        "fullcodeline": "hlist_for_each_entry(n, tree_list, mnt_hash) {"
    },
    {
        "line": 46,
        "fullcodeline": "read_sequnlock_excl(&mount_lock);"
    },
    {
        "line": 21,
        "fullcodeline": "for (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {"
    },
    {
        "line": 29,
        "fullcodeline": "m = next_group(m, dest_mnt)) {"
    },
    {
        "line": 42,
        "fullcodeline": "m = n->mnt_parent;"
    },
    {
        "line": 22,
        "fullcodeline": "ret = propagate_one(n);"
    },
    {
        "line": 28,
        "fullcodeline": "for (m = next_group(dest_mnt, dest_mnt); m;"
    },
    {
        "line": 31,
        "fullcodeline": "n = m;"
    },
    {
        "line": 43,
        "fullcodeline": "if (m->mnt_master != dest_mnt->mnt_master)"
    },
    {
        "line": 37,
        "fullcodeline": "} while (n != m);"
    },
    {
        "line": 44,
        "fullcodeline": "CLEAR_MNT_MARK(m->mnt_master);"
    },
    {
        "line": 33,
        "fullcodeline": "ret = propagate_one(n);"
    },
    {
        "line": 36,
        "fullcodeline": "n = next_peer(n);"
    }
]