[
    {
        "line": 7,
        "fullcodeline": "OP_REQUIRES_OK(c, c->input_list(\"indices\", indices_inputs));"
    },
    {
        "line": 9,
        "fullcodeline": "int32_t max_index = -1;"
    },
    {
        "line": 24,
        "fullcodeline": "*first_dim_size = max_index + 1;"
    },
    {
        "line": 38,
        "fullcodeline": "OP_REQUIRES_OK(c, c->input_list(\"data\", data_inputs));"
    },
    {
        "line": 65,
        "fullcodeline": "OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(*first_dim_size));"
    },
    {
        "line": 69,
        "fullcodeline": "OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, result_ptr));"
    },
    {
        "line": 41,
        "fullcodeline": "for (int input_num = 0; input_num < indices_inputs->size(); input_num++) {"
    },
    {
        "line": 66,
        "fullcodeline": "for (int d = indices0.dims(); d < data0.dims(); d++) {"
    },
    {
        "line": 11,
        "fullcodeline": "*data_elements_size = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "auto indices_vec = indices.flat<int32>();"
    },
    {
        "line": 44,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 50,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 67,
        "fullcodeline": "OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(data0.dim_size(d)));"
    },
    {
        "line": 14,
        "fullcodeline": "if (indices.NumElements() > 0) {"
    },
    {
        "line": 29,
        "fullcodeline": "for (int i = 0; i < indices_vec.size(); i++) {"
    },
    {
        "line": 45,
        "fullcodeline": "c, TensorShapeUtils::StartsWith(data.shape(), indices.shape()),"
    },
    {
        "line": 46,
        "fullcodeline": "errors::InvalidArgument(\"data[\", input_num,"
    },
    {
        "line": 51,
        "fullcodeline": "c, input_num == 0 || SameExtraShape(data0, indices0, data, indices),"
    },
    {
        "line": 52,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 15,
        "fullcodeline": "Eigen::Tensor<int32, 0, Eigen::RowMajor> m ="
    },
    {
        "line": 17,
        "fullcodeline": "max_index = std::max(m(), max_index);"
    },
    {
        "line": 20,
        "fullcodeline": "*data_elements_size += indices.NumElements();"
    },
    {
        "line": 30,
        "fullcodeline": "int32_t index = internal::SubtleMustCopy(indices_vec(i));"
    },
    {
        "line": 31,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 47,
        "fullcodeline": "\"].shape = \", data.shape().DebugString(),"
    },
    {
        "line": 49,
        "fullcodeline": "\"].shape = \", indices.shape().DebugString()));"
    },
    {
        "line": 53,
        "fullcodeline": "\"Need data[0].shape[\", indices0.dims(), \":] = data[\", input_num,"
    },
    {
        "line": 54,
        "fullcodeline": "\"].shape[\", indices.dims(),"
    },
    {
        "line": 55,
        "fullcodeline": "\":], got data[0].shape = \", data0.shape().DebugString(),"
    },
    {
        "line": 56,
        "fullcodeline": "\", data[\", input_num, \"].shape = \", data.shape().DebugString(),"
    },
    {
        "line": 57,
        "fullcodeline": "\", indices[0].shape = \", indices0.shape().DebugString(),"
    },
    {
        "line": 59,
        "fullcodeline": "\"].shape = \", indices.shape().DebugString()));"
    },
    {
        "line": 32,
        "fullcodeline": "c, FastBoundsCheck(index, *first_dim_size),"
    },
    {
        "line": 33,
        "fullcodeline": "errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));"
    },
    {
        "line": 16,
        "fullcodeline": "indices.flat<int32>().maximum();"
    }
]