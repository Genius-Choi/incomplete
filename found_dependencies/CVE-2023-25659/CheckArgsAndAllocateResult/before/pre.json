[
    {
        "line": 7,
        "fullcodeline": "OP_REQUIRES_OK(c, c->input_list(\"indices\", indices_inputs));"
    },
    {
        "line": 9,
        "fullcodeline": "int32_t max_index = -1;"
    },
    {
        "line": 24,
        "fullcodeline": "*first_dim_size = max_index + 1;"
    },
    {
        "line": 27,
        "fullcodeline": "OP_REQUIRES_OK(c, c->input_list(\"data\", data_inputs));"
    },
    {
        "line": 28,
        "fullcodeline": "const Tensor& data0 = (*data_inputs)[0];"
    },
    {
        "line": 29,
        "fullcodeline": "const Tensor& indices0 = (*indices_inputs)[0];"
    },
    {
        "line": 54,
        "fullcodeline": "OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(*first_dim_size));"
    },
    {
        "line": 58,
        "fullcodeline": "OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, result_ptr));"
    },
    {
        "line": 30,
        "fullcodeline": "for (int input_num = 0; input_num < indices_inputs->size(); input_num++) {"
    },
    {
        "line": 55,
        "fullcodeline": "for (int d = indices0.dims(); d < data0.dims(); d++) {"
    },
    {
        "line": 11,
        "fullcodeline": "*data_elements_size = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "const Tensor& indices = (*indices_inputs)[input_num];"
    },
    {
        "line": 32,
        "fullcodeline": "const Tensor& data = (*data_inputs)[input_num];"
    },
    {
        "line": 33,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 39,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 56,
        "fullcodeline": "OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(data0.dim_size(d)));"
    },
    {
        "line": 14,
        "fullcodeline": "if (indices.NumElements() > 0) {"
    },
    {
        "line": 34,
        "fullcodeline": "c, TensorShapeUtils::StartsWith(data.shape(), indices.shape()),"
    },
    {
        "line": 35,
        "fullcodeline": "errors::InvalidArgument(\"data[\", input_num,"
    },
    {
        "line": 40,
        "fullcodeline": "c, input_num == 0 || SameExtraShape(data0, indices0, data, indices),"
    },
    {
        "line": 41,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 15,
        "fullcodeline": "Eigen::Tensor<int32, 0, Eigen::RowMajor> m ="
    },
    {
        "line": 17,
        "fullcodeline": "max_index = std::max(m(), max_index);"
    },
    {
        "line": 20,
        "fullcodeline": "*data_elements_size += indices.NumElements();"
    },
    {
        "line": 36,
        "fullcodeline": "\"].shape = \", data.shape().DebugString(),"
    },
    {
        "line": 38,
        "fullcodeline": "\"].shape = \", indices.shape().DebugString()));"
    },
    {
        "line": 42,
        "fullcodeline": "\"Need data[0].shape[\", indices0.dims(), \":] = data[\", input_num,"
    },
    {
        "line": 43,
        "fullcodeline": "\"].shape[\", indices.dims(),"
    },
    {
        "line": 44,
        "fullcodeline": "\":], got data[0].shape = \", data0.shape().DebugString(),"
    },
    {
        "line": 45,
        "fullcodeline": "\", data[\", input_num, \"].shape = \", data.shape().DebugString(),"
    },
    {
        "line": 46,
        "fullcodeline": "\", indices[0].shape = \", indices0.shape().DebugString(),"
    },
    {
        "line": 48,
        "fullcodeline": "\"].shape = \", indices.shape().DebugString()));"
    },
    {
        "line": 16,
        "fullcodeline": "indices.flat<int32>().maximum();"
    }
]