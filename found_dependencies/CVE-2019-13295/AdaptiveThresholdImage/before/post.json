[
    {
        "line": 29,
        "fullcodeline": "assert(image != (const Image *) NULL);"
    },
    {
        "line": 30,
        "fullcodeline": "assert(image->signature == MagickCoreSignature);"
    },
    {
        "line": 33,
        "fullcodeline": "assert(exception != (ExceptionInfo *) NULL);"
    },
    {
        "line": 34,
        "fullcodeline": "assert(exception->signature == MagickCoreSignature);"
    },
    {
        "line": 35,
        "fullcodeline": "threshold_image=CloneImage(image,0,0,MagickTrue,exception);"
    },
    {
        "line": 47,
        "fullcodeline": "status=MagickTrue;"
    },
    {
        "line": 48,
        "fullcodeline": "progress=0;"
    },
    {
        "line": 49,
        "fullcodeline": "GetMagickPixelPacket(image,&zero);"
    },
    {
        "line": 50,
        "fullcodeline": "number_pixels=(MagickRealType) (width*height);"
    },
    {
        "line": 51,
        "fullcodeline": "image_view=AcquireVirtualCacheView(image,exception);"
    },
    {
        "line": 52,
        "fullcodeline": "threshold_view=AcquireAuthenticCacheView(threshold_image,exception);"
    },
    {
        "line": 192,
        "fullcodeline": "threshold_view=DestroyCacheView(threshold_view);"
    },
    {
        "line": 193,
        "fullcodeline": "image_view=DestroyCacheView(image_view);"
    },
    {
        "line": 31,
        "fullcodeline": "if (image->debug != MagickFalse)"
    },
    {
        "line": 36,
        "fullcodeline": "if (threshold_image == (Image *) NULL)"
    },
    {
        "line": 38,
        "fullcodeline": "if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)"
    },
    {
        "line": 57,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 194,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 32,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);"
    },
    {
        "line": 40,
        "fullcodeline": "InheritException(exception,&threshold_image->exception);"
    },
    {
        "line": 41,
        "fullcodeline": "threshold_image=DestroyImage(threshold_image);"
    },
    {
        "line": 70,
        "fullcodeline": "*magick_restrict p,"
    },
    {
        "line": 88,
        "fullcodeline": "p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)"
    },
    {
        "line": 90,
        "fullcodeline": "q=GetCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,1,"
    },
    {
        "line": 97,
        "fullcodeline": "indexes=GetCacheViewVirtualIndexQueue(image_view);"
    },
    {
        "line": 98,
        "fullcodeline": "threshold_indexes=GetCacheViewAuthenticIndexQueue(threshold_view);"
    },
    {
        "line": 99,
        "fullcodeline": "channel_bias=zero;"
    },
    {
        "line": 100,
        "fullcodeline": "channel_sum=zero;"
    },
    {
        "line": 101,
        "fullcodeline": "r=p;"
    },
    {
        "line": 175,
        "fullcodeline": "sync=SyncCacheViewAuthenticPixels(threshold_view,exception);"
    },
    {
        "line": 195,
        "fullcodeline": "threshold_image=DestroyImage(threshold_image);"
    },
    {
        "line": 37,
        "fullcodeline": "return((Image *) NULL);"
    },
    {
        "line": 42,
        "fullcodeline": "return((Image *) NULL);"
    },
    {
        "line": 86,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 92,
        "fullcodeline": "if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))"
    },
    {
        "line": 102,
        "fullcodeline": "for (v=0; v < (ssize_t) height; v++)"
    },
    {
        "line": 125,
        "fullcodeline": "for (x=0; x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 176,
        "fullcodeline": "if (sync == MagickFalse)"
    },
    {
        "line": 178,
        "fullcodeline": "if (image->progress_monitor != (MagickProgressMonitor) NULL)"
    },
    {
        "line": 89,
        "fullcodeline": "height/2L,image->columns+width,height,exception);"
    },
    {
        "line": 94,
        "fullcodeline": "status=MagickFalse;"
    },
    {
        "line": 123,
        "fullcodeline": "r+=image->columns+width;"
    },
    {
        "line": 130,
        "fullcodeline": "mean=zero;"
    },
    {
        "line": 131,
        "fullcodeline": "r=p;"
    },
    {
        "line": 132,
        "fullcodeline": "channel_sum.red-=channel_bias.red;"
    },
    {
        "line": 133,
        "fullcodeline": "channel_sum.green-=channel_bias.green;"
    },
    {
        "line": 134,
        "fullcodeline": "channel_sum.blue-=channel_bias.blue;"
    },
    {
        "line": 135,
        "fullcodeline": "channel_sum.opacity-=channel_bias.opacity;"
    },
    {
        "line": 136,
        "fullcodeline": "channel_sum.index-=channel_bias.index;"
    },
    {
        "line": 137,
        "fullcodeline": "channel_bias=zero;"
    },
    {
        "line": 155,
        "fullcodeline": "mean.red=(MagickRealType) (channel_sum.red/number_pixels+offset);"
    },
    {
        "line": 156,
        "fullcodeline": "mean.green=(MagickRealType) (channel_sum.green/number_pixels+offset);"
    },
    {
        "line": 157,
        "fullcodeline": "mean.blue=(MagickRealType) (channel_sum.blue/number_pixels+offset);"
    },
    {
        "line": 158,
        "fullcodeline": "mean.opacity=(MagickRealType) (channel_sum.opacity/number_pixels+offset);"
    },
    {
        "line": 161,
        "fullcodeline": "SetPixelRed(q,((MagickRealType) GetPixelRed(q) <= mean.red) ?"
    },
    {
        "line": 163,
        "fullcodeline": "SetPixelGreen(q,((MagickRealType) GetPixelGreen(q) <= mean.green) ?"
    },
    {
        "line": 165,
        "fullcodeline": "SetPixelBlue(q,((MagickRealType) GetPixelBlue(q) <= mean.blue) ?"
    },
    {
        "line": 167,
        "fullcodeline": "SetPixelOpacity(q,((MagickRealType) GetPixelOpacity(q) <= mean.opacity) ?"
    },
    {
        "line": 172,
        "fullcodeline": "p++;"
    },
    {
        "line": 173,
        "fullcodeline": "q++;"
    },
    {
        "line": 177,
        "fullcodeline": "status=MagickFalse;"
    },
    {
        "line": 186,
        "fullcodeline": "progress++;"
    },
    {
        "line": 187,
        "fullcodeline": "proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);"
    },
    {
        "line": 104,
        "fullcodeline": "for (u=0; u < (ssize_t) width; u++)"
    },
    {
        "line": 138,
        "fullcodeline": "for (v=0; v < (ssize_t) height; v++)"
    },
    {
        "line": 159,
        "fullcodeline": "if (image->colorspace == CMYKColorspace)"
    },
    {
        "line": 169,
        "fullcodeline": "if (image->colorspace == CMYKColorspace)"
    },
    {
        "line": 188,
        "fullcodeline": "if (proceed == MagickFalse)"
    },
    {
        "line": 116,
        "fullcodeline": "channel_sum.red+=r[u].red;"
    },
    {
        "line": 117,
        "fullcodeline": "channel_sum.green+=r[u].green;"
    },
    {
        "line": 118,
        "fullcodeline": "channel_sum.blue+=r[u].blue;"
    },
    {
        "line": 119,
        "fullcodeline": "channel_sum.opacity+=r[u].opacity;"
    },
    {
        "line": 140,
        "fullcodeline": "channel_bias.red+=r[0].red;"
    },
    {
        "line": 141,
        "fullcodeline": "channel_bias.green+=r[0].green;"
    },
    {
        "line": 142,
        "fullcodeline": "channel_bias.blue+=r[0].blue;"
    },
    {
        "line": 143,
        "fullcodeline": "channel_bias.opacity+=r[0].opacity;"
    },
    {
        "line": 146,
        "fullcodeline": "channel_sum.red+=r[width-1].red;"
    },
    {
        "line": 147,
        "fullcodeline": "channel_sum.green+=r[width-1].green;"
    },
    {
        "line": 148,
        "fullcodeline": "channel_sum.blue+=r[width-1].blue;"
    },
    {
        "line": 149,
        "fullcodeline": "channel_sum.opacity+=r[width-1].opacity;"
    },
    {
        "line": 153,
        "fullcodeline": "r+=image->columns+width;"
    },
    {
        "line": 160,
        "fullcodeline": "mean.index=(MagickRealType) (channel_sum.index/number_pixels+offset);"
    },
    {
        "line": 170,
        "fullcodeline": "SetPixelIndex(threshold_indexes+x,(((MagickRealType) GetPixelIndex("
    },
    {
        "line": 189,
        "fullcodeline": "status=MagickFalse;"
    },
    {
        "line": 106,
        "fullcodeline": "if (u == (ssize_t) (width-1))"
    },
    {
        "line": 120,
        "fullcodeline": "if (image->colorspace == CMYKColorspace)"
    },
    {
        "line": 144,
        "fullcodeline": "if (image->colorspace == CMYKColorspace)"
    },
    {
        "line": 150,
        "fullcodeline": "if (image->colorspace == CMYKColorspace)"
    },
    {
        "line": 108,
        "fullcodeline": "channel_bias.red+=r[u].red;"
    },
    {
        "line": 109,
        "fullcodeline": "channel_bias.green+=r[u].green;"
    },
    {
        "line": 110,
        "fullcodeline": "channel_bias.blue+=r[u].blue;"
    },
    {
        "line": 111,
        "fullcodeline": "channel_bias.opacity+=r[u].opacity;"
    },
    {
        "line": 121,
        "fullcodeline": "channel_sum.index=(MagickRealType) GetPixelIndex(indexes+(r-p)+u);"
    },
    {
        "line": 145,
        "fullcodeline": "channel_bias.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+0);"
    },
    {
        "line": 151,
        "fullcodeline": "channel_sum.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+"
    },
    {
        "line": 112,
        "fullcodeline": "if (image->colorspace == CMYKColorspace)"
    },
    {
        "line": 113,
        "fullcodeline": "channel_bias.index=(MagickRealType)"
    },
    {
        "line": 171,
        "fullcodeline": "threshold_indexes+x) <= mean.index) ? 0 : QuantumRange));"
    },
    {
        "line": 114,
        "fullcodeline": "GetPixelIndex(indexes+(r-p)+u);"
    }
]