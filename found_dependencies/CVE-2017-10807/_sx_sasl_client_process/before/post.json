[
    {
        "line": 2,
        "fullcodeline": "_sx_sasl_t ctx = (_sx_sasl_t) p->private;"
    },
    {
        "line": 3,
        "fullcodeline": "_sx_sasl_sess_t sctx = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;"
    },
    {
        "line": 5,
        "fullcodeline": "char hostname[256];"
    },
    {
        "line": 12,
        "fullcodeline": "assert(ctx);"
    },
    {
        "line": 13,
        "fullcodeline": "assert(ctx->cb);"
    },
    {
        "line": 177,
        "fullcodeline": "_sx_debug(ZONE, \"sasl handshake failed; (%d): %s\", ret, gsasl_strerror(ret));"
    },
    {
        "line": 201,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);"
    },
    {
        "line": 15,
        "fullcodeline": "if(mech != NULL) {"
    },
    {
        "line": 125,
        "fullcodeline": "if(buf != NULL) free(buf);"
    },
    {
        "line": 128,
        "fullcodeline": "if(ret == GSASL_OK) {"
    },
    {
        "line": 154,
        "fullcodeline": "if(ret == GSASL_NEEDS_MORE) {"
    },
    {
        "line": 174,
        "fullcodeline": "if(out != NULL) free(out);"
    },
    {
        "line": 16,
        "fullcodeline": "_sx_debug(ZONE, \"auth request from client (mechanism=%s)\", mech);"
    },
    {
        "line": 25,
        "fullcodeline": "ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);"
    },
    {
        "line": 33,
        "fullcodeline": "(ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);"
    },
    {
        "line": 36,
        "fullcodeline": "sctx = gsasl_session_hook_get(sd);"
    },
    {
        "line": 40,
        "fullcodeline": "sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));"
    },
    {
        "line": 41,
        "fullcodeline": "sctx->s = s;"
    },
    {
        "line": 42,
        "fullcodeline": "sctx->ctx = ctx;"
    },
    {
        "line": 43,
        "fullcodeline": "gsasl_session_hook_set(sd, (void *) sctx);"
    },
    {
        "line": 44,
        "fullcodeline": "gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);"
    },
    {
        "line": 45,
        "fullcodeline": "gsasl_property_set(sd, GSASL_REALM, realm);"
    },
    {
        "line": 48,
        "fullcodeline": "hostname[0] = '\\0';"
    },
    {
        "line": 49,
        "fullcodeline": "gethostname(hostname, 256);"
    },
    {
        "line": 50,
        "fullcodeline": "hostname[255] = '\\0';"
    },
    {
        "line": 51,
        "fullcodeline": "gsasl_property_set(sd, GSASL_HOSTNAME, hostname);"
    },
    {
        "line": 54,
        "fullcodeline": "ext_id = NULL;"
    },
    {
        "line": 72,
        "fullcodeline": "_sx_debug(ZONE, \"sasl context initialised for %d\", s->tag);"
    },
    {
        "line": 74,
        "fullcodeline": "s->plugin_data[p->index] = (void *) sd;"
    },
    {
        "line": 103,
        "fullcodeline": "ret = gsasl_step(sd, buf, buflen, &out, &outlen);"
    },
    {
        "line": 129,
        "fullcodeline": "_sx_debug(ZONE, \"sasl handshake completed\");"
    },
    {
        "line": 132,
        "fullcodeline": "ret = gsasl_base64_to(out, outlen, &buf, &buflen);"
    },
    {
        "line": 155,
        "fullcodeline": "_sx_debug(ZONE, \"sasl handshake in progress (challenge: %.*s)\", outlen, out);"
    },
    {
        "line": 158,
        "fullcodeline": "ret = gsasl_base64_to(out, outlen, &buf, &buflen);"
    },
    {
        "line": 189,
        "fullcodeline": "out = _sasl_err_NOT_AUTHORIZED;"
    },
    {
        "line": 193,
        "fullcodeline": "out = _sasl_err_INVALID_MECHANISM;"
    },
    {
        "line": 196,
        "fullcodeline": "out = _sasl_err_INCORRECT_ENCODING;"
    },
    {
        "line": 199,
        "fullcodeline": "out = _sasl_err_MALFORMED_REQUEST;"
    },
    {
        "line": 18,
        "fullcodeline": "if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {"
    },
    {
        "line": 26,
        "fullcodeline": "if(ret != GSASL_OK) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (sctx != NULL) free(sctx);"
    },
    {
        "line": 76,
        "fullcodeline": "if(strcmp(mech, \"ANONYMOUS\") == 0) {"
    },
    {
        "line": 108,
        "fullcodeline": "ret = gsasl_base64_from(in, inlen, &buf, &buflen);"
    },
    {
        "line": 121,
        "fullcodeline": "_sx_debug(ZONE, \"response from client (decoded: %.*s)\", buflen, buf);"
    },
    {
        "line": 122,
        "fullcodeline": "ret = gsasl_step(sd, buf, buflen, &out, &outlen);"
    },
    {
        "line": 133,
        "fullcodeline": "if (ret == GSASL_OK) {"
    },
    {
        "line": 148,
        "fullcodeline": "if(out != NULL) free(out);"
    },
    {
        "line": 159,
        "fullcodeline": "if (ret == GSASL_OK) {"
    },
    {
        "line": 169,
        "fullcodeline": "if(out != NULL) free(out);"
    },
    {
        "line": 19,
        "fullcodeline": "_sx_debug(ZONE, \"client requested mechanism (%s) that we didn't offer\", mech);"
    },
    {
        "line": 20,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);"
    },
    {
        "line": 27,
        "fullcodeline": "_sx_debug(ZONE, \"gsasl_server_start failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));"
    },
    {
        "line": 28,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);"
    },
    {
        "line": 83,
        "fullcodeline": "(ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);"
    },
    {
        "line": 84,
        "fullcodeline": "buf = strdup(out);"
    },
    {
        "line": 85,
        "fullcodeline": "buflen = strlen(buf);"
    },
    {
        "line": 109,
        "fullcodeline": "if (ret != GSASL_OK) {"
    },
    {
        "line": 115,
        "fullcodeline": "if(!sd) {"
    },
    {
        "line": 135,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);"
    },
    {
        "line": 136,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 139,
        "fullcodeline": "((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;"
    },
    {
        "line": 140,
        "fullcodeline": "((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;"
    },
    {
        "line": 160,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);"
    },
    {
        "line": 161,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 110,
        "fullcodeline": "_sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));"
    },
    {
        "line": 111,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);"
    },
    {
        "line": 116,
        "fullcodeline": "_sx_debug(ZONE, \"response send before auth request enabling mechanism (decoded: %.*s)\", buflen, buf);"
    },
    {
        "line": 117,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, \"response send before auth request enabling mechanism\"), 0);"
    },
    {
        "line": 143,
        "fullcodeline": "_sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));"
    },
    {
        "line": 144,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);"
    },
    {
        "line": 164,
        "fullcodeline": "_sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));"
    },
    {
        "line": 165,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);"
    },
    {
        "line": 86,
        "fullcodeline": "} else if (strstr(in, \"<\") != NULL && strncmp(in, \"=\", strstr(in, \"<\") - in ) == 0) {"
    },
    {
        "line": 118,
        "fullcodeline": "if(buf != NULL) free(buf);"
    },
    {
        "line": 145,
        "fullcodeline": "if(buf != NULL) free(buf);"
    },
    {
        "line": 166,
        "fullcodeline": "if(buf != NULL) free(buf);"
    },
    {
        "line": 89,
        "fullcodeline": "_sx_debug(ZONE, \"gsasl auth string is empty\");"
    },
    {
        "line": 90,
        "fullcodeline": "buf = strdup(\"\");"
    },
    {
        "line": 91,
        "fullcodeline": "buflen = strlen(buf);"
    },
    {
        "line": 94,
        "fullcodeline": "ret = gsasl_base64_from(in, inlen, &buf, &buflen);"
    },
    {
        "line": 95,
        "fullcodeline": "if (ret != GSASL_OK) {"
    },
    {
        "line": 96,
        "fullcodeline": "_sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));"
    },
    {
        "line": 97,
        "fullcodeline": "_sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);"
    },
    {
        "line": 98,
        "fullcodeline": "if(buf != NULL) free(buf);"
    }
]