[
    {
        "line": 9,
        "fullcodeline": "const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);"
    },
    {
        "line": 10,
        "fullcodeline": "const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);"
    },
    {
        "line": 11,
        "fullcodeline": "uint8_t *data = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */"
    },
    {
        "line": 18,
        "fullcodeline": "assert(_valid_offset(pkt, offset));"
    },
    {
        "line": 86,
        "fullcodeline": "entry.rbuf = &rbuf[res];"
    },
    {
        "line": 19,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {"
    },
    {
        "line": 90,
        "fullcodeline": "if ((offset + frag_size) > entry.super->datagram_size) {"
    },
    {
        "line": 98,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 20,
        "fullcodeline": "data = _6lo_frag_payload(pkt);"
    },
    {
        "line": 21,
        "fullcodeline": "frag_size = _6lo_frag_size(pkt, offset, data);"
    },
    {
        "line": 22,
        "fullcodeline": "datagram_size = sixlowpan_frag_datagram_size(pkt->data);"
    },
    {
        "line": 23,
        "fullcodeline": "datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);"
    },
    {
        "line": 46,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 49,
        "fullcodeline": "(entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 66,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 92,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 101,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 113,
        "fullcodeline": "entry.super->current_size += (uint16_t)frag_size;"
    },
    {
        "line": 48,
        "fullcodeline": "sixlowpan_frag_n_is(pkt->data) &&"
    },
    {
        "line": 52,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (offset == 0) {"
    },
    {
        "line": 187,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 189,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 25,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 47,
        "fullcodeline": "(offset > 0) &&"
    },
    {
        "line": 75,
        "fullcodeline": "res = RBUF_ADD_FORWARDED;"
    },
    {
        "line": 169,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||"
    },
    {
        "line": 170,
        "fullcodeline": "IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {"
    },
    {
        "line": 176,
        "fullcodeline": "res = _rbuf_resize_for_reassembly(entry.rbuf);"
    },
    {
        "line": 26,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 29,
        "fullcodeline": "data = _6lo_sfr_payload(pkt);"
    },
    {
        "line": 30,
        "fullcodeline": "frag_size = _6lo_sfr_frag_size(pkt);"
    },
    {
        "line": 33,
        "fullcodeline": "datagram_size = _6lo_sfr_datagram_size(pkt, offset);"
    },
    {
        "line": 34,
        "fullcodeline": "datagram_tag = rfrag->base.tag;"
    },
    {
        "line": 79,
        "fullcodeline": "else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 177,
        "fullcodeline": "if (res == RBUF_ADD_ERROR) {"
    },
    {
        "line": 38,
        "fullcodeline": "assert(data != NULL);"
    },
    {
        "line": 39,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 70,
        "fullcodeline": "if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,"
    },
    {
        "line": 115,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&"
    },
    {
        "line": 116,
        "fullcodeline": "sixlowpan_iphc_is(data)) {"
    },
    {
        "line": 118,
        "fullcodeline": "gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);"
    },
    {
        "line": 123,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 139,
        "fullcodeline": "else if (data[0] == SIXLOWPAN_UNCOMP) {"
    },
    {
        "line": 131,
        "fullcodeline": "gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);"
    },
    {
        "line": 141,
        "fullcodeline": "data++;"
    },
    {
        "line": 134,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 142,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 146,
        "fullcodeline": "(entry.super->current_size == frag_size)) {"
    },
    {
        "line": 148,
        "fullcodeline": "gnrc_pktsnip_t tmp = {"
    },
    {
        "line": 145,
        "fullcodeline": "sixlowpan_frag_1_is(pkt->data) &&"
    },
    {
        "line": 154,
        "fullcodeline": "if (_check_hdr(&tmp, page) &&"
    },
    {
        "line": 155,
        "fullcodeline": "(vrbe = gnrc_sixlowpan_frag_vrb_from_route("
    },
    {
        "line": 159,
        "fullcodeline": "_adapt_hdr(&tmp, page);"
    },
    {
        "line": 163,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 149,
        "fullcodeline": ".data = data,"
    },
    {
        "line": 150,
        "fullcodeline": ".size = frag_size,"
    },
    {
        "line": 151,
        "fullcodeline": ".users = 1,"
    },
    {
        "line": 160,
        "fullcodeline": "return _forward_uncomp(pkt, rbuf, vrbe, page);"
    },
    {
        "line": 164,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 157,
        "fullcodeline": "gnrc_netif_hdr_get_netif(netif_hdr),"
    }
]