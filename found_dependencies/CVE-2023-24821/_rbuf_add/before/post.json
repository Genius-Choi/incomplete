[
    {
        "line": 9,
        "fullcodeline": "const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);"
    },
    {
        "line": 10,
        "fullcodeline": "const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);"
    },
    {
        "line": 11,
        "fullcodeline": "uint8_t *data = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */"
    },
    {
        "line": 18,
        "fullcodeline": "assert(_valid_offset(pkt, offset));"
    },
    {
        "line": 43,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_gc();"
    },
    {
        "line": 192,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 19,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 90,
        "fullcodeline": "if ((offset + frag_size) > entry.super->datagram_size) {"
    },
    {
        "line": 98,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 20,
        "fullcodeline": "data = _6lo_frag_payload(pkt);"
    },
    {
        "line": 21,
        "fullcodeline": "frag_size = _6lo_frag_size(pkt, offset, data);"
    },
    {
        "line": 22,
        "fullcodeline": "datagram_size = sixlowpan_frag_datagram_size(pkt->data);"
    },
    {
        "line": 23,
        "fullcodeline": "datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);"
    },
    {
        "line": 49,
        "fullcodeline": "(entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 51,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");"
    },
    {
        "line": 66,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 91,
        "fullcodeline": "DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");"
    },
    {
        "line": 93,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 94,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 100,
        "fullcodeline": "DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");"
    },
    {
        "line": 102,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 105,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 112,
        "fullcodeline": "DEBUG(\"6lo rbuf: add fragment data\\n\");"
    },
    {
        "line": 113,
        "fullcodeline": "entry.super->current_size += (uint16_t)frag_size;"
    },
    {
        "line": 182,
        "fullcodeline": "memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,"
    },
    {
        "line": 48,
        "fullcodeline": "sixlowpan_frag_n_is(pkt->data) &&"
    },
    {
        "line": 52,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (offset == 0) {"
    },
    {
        "line": 169,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||"
    },
    {
        "line": 188,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 189,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 25,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 47,
        "fullcodeline": "(offset > 0) &&"
    },
    {
        "line": 54,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");"
    },
    {
        "line": 55,
        "fullcodeline": "gnrc_sixlowpan_frag_vrb_rm(entry.vrb);"
    },
    {
        "line": 57,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 60,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");"
    },
    {
        "line": 61,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 68,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");"
    },
    {
        "line": 69,
        "fullcodeline": "entry.super->current_size += (uint16_t)frag_size;"
    },
    {
        "line": 75,
        "fullcodeline": "res = RBUF_ADD_FORWARDED;"
    },
    {
        "line": 79,
        "fullcodeline": "else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 170,
        "fullcodeline": "IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {"
    },
    {
        "line": 176,
        "fullcodeline": "res = _rbuf_resize_for_reassembly(entry.rbuf);"
    },
    {
        "line": 26,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 27,
        "fullcodeline": "sixlowpan_sfr_rfrag_t *rfrag = pkt->data;"
    },
    {
        "line": 29,
        "fullcodeline": "data = _6lo_sfr_payload(pkt);"
    },
    {
        "line": 30,
        "fullcodeline": "frag_size = _6lo_sfr_frag_size(pkt);"
    },
    {
        "line": 33,
        "fullcodeline": "datagram_size = _6lo_sfr_datagram_size(pkt, offset);"
    },
    {
        "line": 70,
        "fullcodeline": "if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,"
    },
    {
        "line": 82,
        "fullcodeline": "DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");"
    },
    {
        "line": 83,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 115,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&"
    },
    {
        "line": 177,
        "fullcodeline": "if (res == RBUF_ADD_ERROR) {"
    },
    {
        "line": 38,
        "fullcodeline": "assert(data != NULL);"
    },
    {
        "line": 39,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 72,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");"
    },
    {
        "line": 116,
        "fullcodeline": "sixlowpan_iphc_is(data)) {"
    },
    {
        "line": 117,
        "fullcodeline": "DEBUG(\"6lo rbuf: detected IPHC header.\\n\");"
    },
    {
        "line": 118,
        "fullcodeline": "gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);"
    },
    {
        "line": 178,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 120,
        "fullcodeline": "if (frag_hdr == NULL) {"
    },
    {
        "line": 121,
        "fullcodeline": "DEBUG(\"6lo rbuf: unable to mark fragment header. \""
    },
    {
        "line": 124,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 125,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 139,
        "fullcodeline": "else if (data[0] == SIXLOWPAN_UNCOMP) {"
    },
    {
        "line": 129,
        "fullcodeline": "DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");"
    },
    {
        "line": 131,
        "fullcodeline": "gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);"
    },
    {
        "line": 140,
        "fullcodeline": "DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");"
    },
    {
        "line": 141,
        "fullcodeline": "data++;"
    },
    {
        "line": 133,
        "fullcodeline": "if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 134,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 146,
        "fullcodeline": "(entry.super->current_size == frag_size)) {"
    },
    {
        "line": 148,
        "fullcodeline": "gnrc_pktsnip_t tmp = {"
    },
    {
        "line": 145,
        "fullcodeline": "sixlowpan_frag_1_is(pkt->data) &&"
    },
    {
        "line": 154,
        "fullcodeline": "if (_check_hdr(&tmp, page) &&"
    },
    {
        "line": 155,
        "fullcodeline": "(vrbe = gnrc_sixlowpan_frag_vrb_from_route("
    },
    {
        "line": 159,
        "fullcodeline": "_adapt_hdr(&tmp, page);"
    },
    {
        "line": 163,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 149,
        "fullcodeline": ".data = data,"
    },
    {
        "line": 150,
        "fullcodeline": ".size = frag_size,"
    },
    {
        "line": 151,
        "fullcodeline": ".users = 1,"
    },
    {
        "line": 160,
        "fullcodeline": "return _forward_uncomp(pkt, rbuf, vrbe, page);"
    },
    {
        "line": 164,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 165,
        "fullcodeline": "entry.super->datagram_size--;"
    },
    {
        "line": 157,
        "fullcodeline": "gnrc_netif_hdr_get_netif(netif_hdr),"
    }
]