[
    {
        "line": 11,
        "fullcodeline": "if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)"
    },
    {
        "line": 13,
        "fullcodeline": "int numsubs = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "GlyphFace * const glyphs = new GlyphFace [_num_glyphs];"
    },
    {
        "line": 19,
        "fullcodeline": "_glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);"
    },
    {
        "line": 24,
        "fullcodeline": "const GlyphFace * loaded = _glyphs[0];"
    },
    {
        "line": 53,
        "fullcodeline": "if (_glyphs && glyph(0) == 0)"
    },
    {
        "line": 15,
        "fullcodeline": "if (!glyphs)"
    },
    {
        "line": 25,
        "fullcodeline": "for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)"
    },
    {
        "line": 26,
        "fullcodeline": "_glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);"
    },
    {
        "line": 62,
        "fullcodeline": "_num_glyphs = _num_attrs = _upem = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "_glyphs[0] = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "else if (numsubs > 0 && _boxes)"
    },
    {
        "line": 35,
        "fullcodeline": "GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));"
    },
    {
        "line": 36,
        "fullcodeline": "GlyphBox * currbox = boxes;"
    },
    {
        "line": 38,
        "fullcodeline": "for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)"
    },
    {
        "line": 41,
        "fullcodeline": "currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);"
    }
]