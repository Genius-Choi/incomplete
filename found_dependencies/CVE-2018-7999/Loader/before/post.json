[
    {
        "line": 16,
        "fullcodeline": "const Face::Table maxp = Face::Table(face, Tag::maxp);"
    },
    {
        "line": 19,
        "fullcodeline": "_num_glyphs_graphics = TtfUtil::GlyphCount(maxp);"
    },
    {
        "line": 13,
        "fullcodeline": "if (!operator bool())"
    },
    {
        "line": 17,
        "fullcodeline": "if (!maxp) { _head = Face::Table(); return; }"
    },
    {
        "line": 21,
        "fullcodeline": "if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2))"
    },
    {
        "line": 27,
        "fullcodeline": "if (!dumb_font)"
    },
    {
        "line": 23,
        "fullcodeline": "_head = Face::Table();"
    },
    {
        "line": 36,
        "fullcodeline": "const byte    * p = m_pGloc;"
    },
    {
        "line": 37,
        "fullcodeline": "int       version = be::read<uint32>(p);"
    },
    {
        "line": 38,
        "fullcodeline": "const uint16    flags = be::read<uint16>(p);"
    },
    {
        "line": 39,
        "fullcodeline": "_num_attrs = be::read<uint16>(p);"
    },
    {
        "line": 43,
        "fullcodeline": "_long_fmt              = flags & 1;"
    },
    {
        "line": 44,
        "fullcodeline": "int tmpnumgattrs       = (m_pGloc.size()"
    },
    {
        "line": 58,
        "fullcodeline": "_num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);"
    },
    {
        "line": 59,
        "fullcodeline": "p = m_pGlat;"
    },
    {
        "line": 60,
        "fullcodeline": "version = be::read<uint32>(p);"
    },
    {
        "line": 29,
        "fullcodeline": "if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL"
    },
    {
        "line": 49,
        "fullcodeline": "if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535"
    },
    {
        "line": 61,
        "fullcodeline": "if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       // reject Glat tables that are too new"
    },
    {
        "line": 31,
        "fullcodeline": "|| m_pGloc.size() < 8)"
    },
    {
        "line": 33,
        "fullcodeline": "_head = Face::Table();"
    },
    {
        "line": 52,
        "fullcodeline": "|| m_pGlat.size() < 4)"
    },
    {
        "line": 54,
        "fullcodeline": "_head = Face::Table();"
    },
    {
        "line": 63,
        "fullcodeline": "_head = Face::Table();"
    },
    {
        "line": 30,
        "fullcodeline": "|| (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL"
    },
    {
        "line": 51,
        "fullcodeline": "|| _num_glyphs_graphics > tmpnumgattrs"
    },
    {
        "line": 46,
        "fullcodeline": "- sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))"
    },
    {
        "line": 50,
        "fullcodeline": "|| _num_attrs == 0 || _num_attrs > 0x3000  // is this hard limit appropriate?"
    },
    {
        "line": 66,
        "fullcodeline": "else if (version >= 0x00030000)"
    },
    {
        "line": 45,
        "fullcodeline": "- (p - m_pGloc)"
    },
    {
        "line": 68,
        "fullcodeline": "unsigned int glatflags = be::read<uint32>(p);"
    },
    {
        "line": 69,
        "fullcodeline": "_has_boxes = glatflags & 1;"
    },
    {
        "line": 71,
        "fullcodeline": "_has_boxes = true;"
    }
]