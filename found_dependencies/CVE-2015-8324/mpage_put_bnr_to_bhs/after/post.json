[
    {
        "line": 4,
        "fullcodeline": "struct inode *inode = mpd->inode;"
    },
    {
        "line": 5,
        "fullcodeline": "struct address_space *mapping = inode->i_mapping;"
    },
    {
        "line": 6,
        "fullcodeline": "int blocks = exbh->b_size >> inode->i_blkbits;"
    },
    {
        "line": 7,
        "fullcodeline": "sector_t pblock = exbh->b_blocknr, cur_logical;"
    },
    {
        "line": 13,
        "fullcodeline": "index = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);"
    },
    {
        "line": 14,
        "fullcodeline": "end = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);"
    },
    {
        "line": 15,
        "fullcodeline": "cur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);"
    },
    {
        "line": 17,
        "fullcodeline": "pagevec_init(&pvec, 0);"
    },
    {
        "line": 19,
        "fullcodeline": "while (index <= end) {"
    },
    {
        "line": 21,
        "fullcodeline": "nr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);"
    },
    {
        "line": 76,
        "fullcodeline": "pagevec_release(&pvec);"
    },
    {
        "line": 22,
        "fullcodeline": "if (nr_pages == 0)"
    },
    {
        "line": 24,
        "fullcodeline": "for (i = 0; i < nr_pages; i++) {"
    },
    {
        "line": 27,
        "fullcodeline": "index = page->index;"
    },
    {
        "line": 30,
        "fullcodeline": "index++;"
    },
    {
        "line": 32,
        "fullcodeline": "BUG_ON(!PageLocked(page));"
    },
    {
        "line": 33,
        "fullcodeline": "BUG_ON(PageWriteback(page));"
    },
    {
        "line": 34,
        "fullcodeline": "BUG_ON(!page_has_buffers(page));"
    },
    {
        "line": 36,
        "fullcodeline": "bh = page_buffers(page);"
    },
    {
        "line": 37,
        "fullcodeline": "head = bh;"
    },
    {
        "line": 28,
        "fullcodeline": "if (index > end)"
    },
    {
        "line": 44,
        "fullcodeline": "} while ((bh = bh->b_this_page) != head);"
    },
    {
        "line": 74,
        "fullcodeline": "} while ((bh = bh->b_this_page) != head);"
    },
    {
        "line": 43,
        "fullcodeline": "cur_logical++;"
    },
    {
        "line": 72,
        "fullcodeline": "cur_logical++;"
    },
    {
        "line": 73,
        "fullcodeline": "pblock++;"
    },
    {
        "line": 41,
        "fullcodeline": "if (cur_logical >= logical)"
    },
    {
        "line": 47,
        "fullcodeline": "if (cur_logical >= logical + blocks)"
    },
    {
        "line": 50,
        "fullcodeline": "if (buffer_delay(bh) ||"
    },
    {
        "line": 70,
        "fullcodeline": "if (buffer_uninit(exbh))"
    },
    {
        "line": 51,
        "fullcodeline": "buffer_unwritten(bh)) {"
    },
    {
        "line": 53,
        "fullcodeline": "BUG_ON(bh->b_bdev != inode->i_sb->s_bdev);"
    },
    {
        "line": 71,
        "fullcodeline": "set_buffer_uninit(bh);"
    },
    {
        "line": 55,
        "fullcodeline": "if (buffer_delay(bh)) {"
    },
    {
        "line": 56,
        "fullcodeline": "clear_buffer_delay(bh);"
    },
    {
        "line": 57,
        "fullcodeline": "bh->b_blocknr = pblock;"
    },
    {
        "line": 67,
        "fullcodeline": "} else if (buffer_mapped(bh))"
    },
    {
        "line": 63,
        "fullcodeline": "clear_buffer_unwritten(bh);"
    },
    {
        "line": 64,
        "fullcodeline": "BUG_ON(bh->b_blocknr != pblock);"
    },
    {
        "line": 68,
        "fullcodeline": "BUG_ON(bh->b_blocknr != pblock);"
    }
]