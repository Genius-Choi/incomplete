[
    {
        "line": 5,
        "fullcodeline": "struct inode *inode = mapping->host;"
    },
    {
        "line": 8,
        "fullcodeline": "int retries = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "trace_ext4_write_begin(inode, pos, len, flags);"
    },
    {
        "line": 18,
        "fullcodeline": "needed_blocks = ext4_writepage_trans_blocks(inode) + 1;"
    },
    {
        "line": 19,
        "fullcodeline": "index = pos >> PAGE_CACHE_SHIFT;"
    },
    {
        "line": 20,
        "fullcodeline": "from = pos & (PAGE_CACHE_SIZE - 1);"
    },
    {
        "line": 21,
        "fullcodeline": "to = from + len;"
    },
    {
        "line": 24,
        "fullcodeline": "handle = ext4_journal_start(inode, needed_blocks);"
    },
    {
        "line": 32,
        "fullcodeline": "flags |= AOP_FLAG_NOFS;"
    },
    {
        "line": 34,
        "fullcodeline": "page = grab_cache_page_write_begin(mapping, index, flags);"
    },
    {
        "line": 40,
        "fullcodeline": "*pagep = page;"
    },
    {
        "line": 25,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (!page) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (ext4_should_dioread_nolock(inode))"
    },
    {
        "line": 49,
        "fullcodeline": "if (!ret && ext4_should_journal_data(inode)) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))"
    },
    {
        "line": 26,
        "fullcodeline": "ret = PTR_ERR(handle);"
    },
    {
        "line": 36,
        "fullcodeline": "ext4_journal_stop(handle);"
    },
    {
        "line": 37,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 43,
        "fullcodeline": "ret = block_write_begin(file, mapping, pos, len, flags, pagep,"
    },
    {
        "line": 50,
        "fullcodeline": "ret = walk_page_buffers(handle, page_buffers(page),"
    },
    {
        "line": 55,
        "fullcodeline": "unlock_page(page);"
    },
    {
        "line": 56,
        "fullcodeline": "page_cache_release(page);"
    },
    {
        "line": 68,
        "fullcodeline": "ext4_journal_stop(handle);"
    },
    {
        "line": 46,
        "fullcodeline": "ret = block_write_begin(file, mapping, pos, len, flags, pagep,"
    },
    {
        "line": 65,
        "fullcodeline": "if (pos + len > inode->i_size && ext4_can_truncate(inode))"
    },
    {
        "line": 69,
        "fullcodeline": "if (pos + len > inode->i_size) {"
    },
    {
        "line": 66,
        "fullcodeline": "ext4_orphan_add(handle, inode);"
    },
    {
        "line": 70,
        "fullcodeline": "ext4_truncate_failed_write(inode);"
    },
    {
        "line": 78,
        "fullcodeline": "ext4_orphan_del(NULL, inode);"
    }
]