[
    {
        "line": 5,
        "fullcodeline": "struct file *file = iocb->ki_filp;"
    },
    {
        "line": 6,
        "fullcodeline": "struct inode *inode = file->f_mapping->host;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t count = iov_length(iov, nr_segs);"
    },
    {
        "line": 10,
        "fullcodeline": "loff_t final_size = offset + count;"
    },
    {
        "line": 11,
        "fullcodeline": "if (rw == WRITE && final_size <= inode->i_size) {"
    },
    {
        "line": 89,
        "fullcodeline": "return ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);"
    },
    {
        "line": 32,
        "fullcodeline": "iocb->private = NULL;"
    },
    {
        "line": 33,
        "fullcodeline": "EXT4_I(inode)->cur_aio_dio = NULL;"
    },
    {
        "line": 48,
        "fullcodeline": "ret = blockdev_direct_IO(rw, iocb, inode,"
    },
    {
        "line": 34,
        "fullcodeline": "if (!is_sync_kiocb(iocb)) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {"
    },
    {
        "line": 35,
        "fullcodeline": "iocb->private = ext4_init_io_end(inode);"
    },
    {
        "line": 36,
        "fullcodeline": "if (!iocb->private)"
    },
    {
        "line": 45,
        "fullcodeline": "EXT4_I(inode)->cur_aio_dio = iocb->private;"
    },
    {
        "line": 54,
        "fullcodeline": "EXT4_I(inode)->cur_aio_dio = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 72,
        "fullcodeline": "} else if (ret > 0 && ext4_test_inode_state(inode,"
    },
    {
        "line": 79,
        "fullcodeline": "err = ext4_convert_unwritten_extents(inode,"
    },
    {
        "line": 81,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 82,
        "fullcodeline": "ret = err;"
    }
]