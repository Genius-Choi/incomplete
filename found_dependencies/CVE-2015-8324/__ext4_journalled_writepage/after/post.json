[
    {
        "line": 4,
        "fullcodeline": "struct address_space *mapping = page->mapping;"
    },
    {
        "line": 5,
        "fullcodeline": "struct inode *inode = mapping->host;"
    },
    {
        "line": 7,
        "fullcodeline": "handle_t *handle = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "page_bufs = page_buffers(page);"
    },
    {
        "line": 12,
        "fullcodeline": "BUG_ON(!page_bufs);"
    },
    {
        "line": 13,
        "fullcodeline": "walk_page_buffers(handle, page_bufs, 0, len, NULL, bget_one);"
    },
    {
        "line": 16,
        "fullcodeline": "unlock_page(page);"
    },
    {
        "line": 18,
        "fullcodeline": "handle = ext4_journal_start(inode, ext4_writepage_trans_blocks(inode));"
    },
    {
        "line": 24,
        "fullcodeline": "ret = walk_page_buffers(handle, page_bufs, 0, len, NULL,"
    },
    {
        "line": 27,
        "fullcodeline": "err = walk_page_buffers(handle, page_bufs, 0, len, NULL,"
    },
    {
        "line": 31,
        "fullcodeline": "err = ext4_journal_stop(handle);"
    },
    {
        "line": 35,
        "fullcodeline": "walk_page_buffers(handle, page_bufs, 0, len, NULL, bput_one);"
    },
    {
        "line": 36,
        "fullcodeline": "ext4_set_inode_state(inode, EXT4_STATE_JDATA);"
    },
    {
        "line": 19,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 32,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 20,
        "fullcodeline": "ret = PTR_ERR(handle);"
    },
    {
        "line": 30,
        "fullcodeline": "ret = err;"
    },
    {
        "line": 33,
        "fullcodeline": "ret = err;"
    }
]