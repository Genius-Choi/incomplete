[
    {
        "line": 3,
        "fullcodeline": "struct rxrpc_bundle *bundle = conn->bundle;"
    },
    {
        "line": 5,
        "fullcodeline": "bool need_drop = false;"
    },
    {
        "line": 8,
        "fullcodeline": "_enter(\"C=%x\", conn->debug_id);"
    },
    {
        "line": 13,
        "fullcodeline": "spin_lock(&bundle->channel_lock);"
    },
    {
        "line": 14,
        "fullcodeline": "bindex = conn->bundle_shift / RXRPC_MAXCALLS;"
    },
    {
        "line": 22,
        "fullcodeline": "spin_unlock(&bundle->channel_lock);"
    },
    {
        "line": 10,
        "fullcodeline": "if (conn->flags & RXRPC_CONN_FINAL_ACK_MASK)"
    },
    {
        "line": 15,
        "fullcodeline": "if (bundle->conns[bindex] == conn) {"
    },
    {
        "line": 11,
        "fullcodeline": "rxrpc_process_delayed_final_acks(conn, true);"
    },
    {
        "line": 16,
        "fullcodeline": "_debug(\"clear slot %u\", bindex);"
    },
    {
        "line": 17,
        "fullcodeline": "bundle->conns[bindex] = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "need_drop = true;"
    },
    {
        "line": 25,
        "fullcodeline": "rxrpc_deactivate_bundle(bundle);"
    },
    {
        "line": 26,
        "fullcodeline": "rxrpc_put_connection(conn);"
    },
    {
        "line": 18,
        "fullcodeline": "for (i = 0; i < RXRPC_MAXCALLS; i++)"
    },
    {
        "line": 19,
        "fullcodeline": "clear_bit(conn->bundle_shift + i, &bundle->avail_chans);"
    }
]