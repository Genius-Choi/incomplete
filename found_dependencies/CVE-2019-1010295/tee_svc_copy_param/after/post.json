[
    {
        "line": 10,
        "fullcodeline": "size_t req_mem = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "uint8_t *dst = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "bool ta_private_memref[TEE_NUM_PARAMS];"
    },
    {
        "line": 14,
        "fullcodeline": "struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);"
    },
    {
        "line": 78,
        "fullcodeline": "res = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);"
    },
    {
        "line": 81,
        "fullcodeline": "dst_offs = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "if (!callee_params) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {"
    },
    {
        "line": 39,
        "fullcodeline": "for (n = 0; n < TEE_NUM_PARAMS; n++) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (req_mem == 0)"
    },
    {
        "line": 79,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 83,
        "fullcodeline": "for (n = 0; n < TEE_NUM_PARAMS; n++) {"
    },
    {
        "line": 20,
        "fullcodeline": "memset(param, 0, sizeof(*param));"
    },
    {
        "line": 41,
        "fullcodeline": "ta_private_memref[n] = false;"
    },
    {
        "line": 88,
        "fullcodeline": "s = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));"
    },
    {
        "line": 22,
        "fullcodeline": "res = tee_mmu_check_access_rights(utc,"
    },
    {
        "line": 27,
        "fullcodeline": "res = utee_param_to_param(utc, param, callee_params);"
    },
    {
        "line": 43,
        "fullcodeline": "switch (TEE_PARAM_TYPE_GET(param->types, n)) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (!ta_private_memref[n])"
    },
    {
        "line": 90,
        "fullcodeline": "switch (TEE_PARAM_TYPE_GET(param->types, n)) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 28,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 47,
        "fullcodeline": "va = (void *)param->u[n].mem.offs;"
    },
    {
        "line": 64,
        "fullcodeline": "res = tee_mmu_vbuf_to_mobj_offs(utc, va, s,"
    },
    {
        "line": 93,
        "fullcodeline": "va = (void *)param->u[n].mem.offs;"
    },
    {
        "line": 108,
        "fullcodeline": "va = (void *)param->u[n].mem.offs;"
    },
    {
        "line": 23,
        "fullcodeline": "TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,"
    },
    {
        "line": 24,
        "fullcodeline": "(uaddr_t)callee_params, sizeof(struct utee_params));"
    },
    {
        "line": 49,
        "fullcodeline": "if (!va) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 57,
        "fullcodeline": "s = ROUNDUP(s, sizeof(uint32_t));"
    },
    {
        "line": 60,
        "fullcodeline": "ta_private_memref[n] = true;"
    },
    {
        "line": 95,
        "fullcodeline": "res = tee_svc_copy_from_user(dst, va,"
    },
    {
        "line": 99,
        "fullcodeline": "param->u[n].mem.offs = dst_offs;"
    },
    {
        "line": 101,
        "fullcodeline": "tmp_buf_va[n] = dst;"
    },
    {
        "line": 102,
        "fullcodeline": "dst += s;"
    },
    {
        "line": 103,
        "fullcodeline": "dst_offs += s;"
    },
    {
        "line": 110,
        "fullcodeline": "param->u[n].mem.offs = dst_offs;"
    },
    {
        "line": 112,
        "fullcodeline": "tmp_buf_va[n] = dst;"
    },
    {
        "line": 113,
        "fullcodeline": "dst += s;"
    },
    {
        "line": 114,
        "fullcodeline": "dst_offs += s;"
    },
    {
        "line": 58,
        "fullcodeline": "if (ADD_OVERFLOW(req_mem, s, &req_mem))"
    },
    {
        "line": 97,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    }
]