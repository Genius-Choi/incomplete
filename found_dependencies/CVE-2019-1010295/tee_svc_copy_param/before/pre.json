[
    {
        "line": 10,
        "fullcodeline": "size_t req_mem = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "uint8_t *dst = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "bool ta_private_memref[TEE_NUM_PARAMS];"
    },
    {
        "line": 14,
        "fullcodeline": "struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);"
    },
    {
        "line": 76,
        "fullcodeline": "res = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);"
    },
    {
        "line": 79,
        "fullcodeline": "dst_offs = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "if (!callee_params) {"
    },
    {
        "line": 37,
        "fullcodeline": "for (n = 0; n < TEE_NUM_PARAMS; n++) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (req_mem == 0)"
    },
    {
        "line": 77,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 81,
        "fullcodeline": "for (n = 0; n < TEE_NUM_PARAMS; n++) {"
    },
    {
        "line": 20,
        "fullcodeline": "memset(param, 0, sizeof(*param));"
    },
    {
        "line": 30,
        "fullcodeline": "if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {"
    },
    {
        "line": 39,
        "fullcodeline": "ta_private_memref[n] = false;"
    },
    {
        "line": 86,
        "fullcodeline": "s = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));"
    },
    {
        "line": 22,
        "fullcodeline": "res = tee_mmu_check_access_rights(utc,"
    },
    {
        "line": 27,
        "fullcodeline": "utee_param_to_param(param, callee_params);"
    },
    {
        "line": 41,
        "fullcodeline": "switch (TEE_PARAM_TYPE_GET(param->types, n)) {"
    },
    {
        "line": 88,
        "fullcodeline": "switch (TEE_PARAM_TYPE_GET(param->types, n)) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 45,
        "fullcodeline": "va = (void *)param->u[n].mem.offs;"
    },
    {
        "line": 46,
        "fullcodeline": "s = param->u[n].mem.size;"
    },
    {
        "line": 62,
        "fullcodeline": "res = tee_mmu_vbuf_to_mobj_offs(utc, va, s,"
    },
    {
        "line": 91,
        "fullcodeline": "va = (void *)param->u[n].mem.offs;"
    },
    {
        "line": 23,
        "fullcodeline": "TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,"
    },
    {
        "line": 24,
        "fullcodeline": "(uaddr_t)callee_params, sizeof(struct utee_params));"
    },
    {
        "line": 47,
        "fullcodeline": "if (!va) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    },
    {
        "line": 55,
        "fullcodeline": "s = ROUNDUP(s, sizeof(uint32_t));"
    },
    {
        "line": 58,
        "fullcodeline": "ta_private_memref[n] = true;"
    },
    {
        "line": 93,
        "fullcodeline": "res = tee_svc_copy_from_user(dst, va,"
    },
    {
        "line": 100,
        "fullcodeline": "dst += s;"
    },
    {
        "line": 101,
        "fullcodeline": "dst_offs += s;"
    },
    {
        "line": 111,
        "fullcodeline": "dst += s;"
    },
    {
        "line": 112,
        "fullcodeline": "dst_offs += s;"
    },
    {
        "line": 56,
        "fullcodeline": "if (ADD_OVERFLOW(req_mem, s, &req_mem))"
    },
    {
        "line": 95,
        "fullcodeline": "if (res != TEE_SUCCESS)"
    }
]