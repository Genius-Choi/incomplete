[
    {
        "line": 7,
        "fullcodeline": "u32 xfer_len = rqstp->rq_res.len;"
    },
    {
        "line": 19,
        "fullcodeline": "res_ary = (struct rpcrdma_write_array *)"
    },
    {
        "line": 23,
        "fullcodeline": "nchunks = be32_to_cpu(rp_ary->wc_nchunks);"
    },
    {
        "line": 54,
        "fullcodeline": "svc_rdma_xdr_encode_reply_array(res_ary, chunk_no);"
    },
    {
        "line": 25,
        "fullcodeline": "xfer_len && chunk_no < nchunks;"
    },
    {
        "line": 26,
        "fullcodeline": "chunk_no++) {"
    },
    {
        "line": 60,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 24,
        "fullcodeline": "for (xdr_off = 0, chunk_no = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "ch = &rp_ary->wc_array[chunk_no].wc_target;"
    },
    {
        "line": 29,
        "fullcodeline": "write_len = min(xfer_len, be32_to_cpu(ch->rs_length));"
    },
    {
        "line": 33,
        "fullcodeline": "xdr_decode_hyper((__be32 *)&ch->rs_offset, &rs_offset);"
    },
    {
        "line": 34,
        "fullcodeline": "svc_rdma_xdr_encode_array_chunk(res_ary, chunk_no,"
    },
    {
        "line": 37,
        "fullcodeline": "chunk_off = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "ret = send_write(xprt, rqstp,"
    },
    {
        "line": 47,
        "fullcodeline": "chunk_off += ret;"
    },
    {
        "line": 48,
        "fullcodeline": "xdr_off += ret;"
    },
    {
        "line": 49,
        "fullcodeline": "xfer_len -= ret;"
    },
    {
        "line": 50,
        "fullcodeline": "write_len -= ret;"
    },
    {
        "line": 45,
        "fullcodeline": "if (ret <= 0)"
    },
    {
        "line": 40,
        "fullcodeline": "be32_to_cpu(ch->rs_handle),"
    },
    {
        "line": 41,
        "fullcodeline": "rs_offset + chunk_off,"
    }
]