[
    {
        "line": 7,
        "fullcodeline": "completed = False"
    },
    {
        "line": 8,
        "fullcodeline": "resp = {}"
    },
    {
        "line": 9,
        "fullcodeline": "while not completed:"
    },
    {
        "line": 12,
        "fullcodeline": "task = asyncio.create_task(websocket.recv())"
    },
    {
        "line": 30,
        "fullcodeline": "msg = task.result()"
    },
    {
        "line": 31,
        "fullcodeline": "resp = json.loads(msg)"
    },
    {
        "line": 60,
        "fullcodeline": "completed = resp[\"msg\"] == \"process_completed\""
    },
    {
        "line": 13,
        "fullcodeline": "while not task.done():"
    },
    {
        "line": 54,
        "fullcodeline": "if resp[\"msg\"] == \"queue_full\":"
    },
    {
        "line": 56,
        "fullcodeline": "if resp[\"msg\"] == \"send_hash\":"
    },
    {
        "line": 29,
        "fullcodeline": "await asyncio.sleep(0.01)"
    },
    {
        "line": 55,
        "fullcodeline": "raise QueueError(\"Queue is full! Please try again.\")"
    },
    {
        "line": 57,
        "fullcodeline": "await websocket.send(hash_data)"
    },
    {
        "line": 33,
        "fullcodeline": "with helper.lock:"
    },
    {
        "line": 58,
        "fullcodeline": "elif resp[\"msg\"] == \"send_data\":"
    },
    {
        "line": 59,
        "fullcodeline": "await websocket.send(data)"
    },
    {
        "line": 15,
        "fullcodeline": "with helper.lock:"
    },
    {
        "line": 34,
        "fullcodeline": "has_progress = \"progress_data\" in resp"
    },
    {
        "line": 35,
        "fullcodeline": "status_update = StatusUpdate("
    },
    {
        "line": 46,
        "fullcodeline": "output = resp.get(\"output\", {}).get(\"data\", [])"
    },
    {
        "line": 53,
        "fullcodeline": "helper.job.latest_status = status_update"
    },
    {
        "line": 47,
        "fullcodeline": "if output and status_update.code != Status.FINISHED:"
    },
    {
        "line": 36,
        "fullcodeline": "code=Status.msg_to_status(resp[\"msg\"]),"
    },
    {
        "line": 37,
        "fullcodeline": "queue_size=resp.get(\"queue_size\"),"
    },
    {
        "line": 38,
        "fullcodeline": "rank=resp.get(\"rank\", None),"
    },
    {
        "line": 39,
        "fullcodeline": "success=resp.get(\"success\"),"
    },
    {
        "line": 40,
        "fullcodeline": "time=datetime.now(),"
    },
    {
        "line": 41,
        "fullcodeline": "eta=resp.get(\"rank_eta\"),"
    },
    {
        "line": 42,
        "fullcodeline": "progress_data=ProgressUnit.from_msg(resp[\"progress_data\"])"
    },
    {
        "line": 52,
        "fullcodeline": "helper.job.outputs.append(result)"
    },
    {
        "line": 27,
        "fullcodeline": "raise CancelledError()"
    },
    {
        "line": 49,
        "fullcodeline": "result = helper.prediction_processor(*output)"
    },
    {
        "line": 19,
        "fullcodeline": "async with httpx.AsyncClient() as http:"
    },
    {
        "line": 51,
        "fullcodeline": "result = [e]"
    },
    {
        "line": 20,
        "fullcodeline": "reset = http.post("
    },
    {
        "line": 25,
        "fullcodeline": "task.cancel()"
    },
    {
        "line": 26,
        "fullcodeline": "await asyncio.gather(task, reset, return_exceptions=True)"
    },
    {
        "line": 21,
        "fullcodeline": "helper.reset_url, json=json.loads(hash_data)"
    }
]