[
    {
        "line": 4,
        "fullcodeline": "struct xdr_stream *xdr = &resp->xdr;"
    },
    {
        "line": 8,
        "fullcodeline": "dprintk(\"%s: err %d\\n\", __func__, nfserr);"
    },
    {
        "line": 12,
        "fullcodeline": "nfserr = nfserr_resource;"
    },
    {
        "line": 13,
        "fullcodeline": "p = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));"
    },
    {
        "line": 17,
        "fullcodeline": "*p++ = cpu_to_be32(1);\t/* we always set return-on-close */"
    },
    {
        "line": 18,
        "fullcodeline": "*p++ = cpu_to_be32(lgp->lg_sid.si_generation);"
    },
    {
        "line": 19,
        "fullcodeline": "p = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,"
    },
    {
        "line": 22,
        "fullcodeline": "*p++ = cpu_to_be32(1);\t/* we always return a single layout */"
    },
    {
        "line": 23,
        "fullcodeline": "p = xdr_encode_hyper(p, lgp->lg_seg.offset);"
    },
    {
        "line": 24,
        "fullcodeline": "p = xdr_encode_hyper(p, lgp->lg_seg.length);"
    },
    {
        "line": 25,
        "fullcodeline": "*p++ = cpu_to_be32(lgp->lg_seg.iomode);"
    },
    {
        "line": 26,
        "fullcodeline": "*p++ = cpu_to_be32(lgp->lg_layout_type);"
    },
    {
        "line": 29,
        "fullcodeline": "nfserr = ops->encode_layoutget(xdr, lgp);"
    },
    {
        "line": 31,
        "fullcodeline": "kfree(lgp->lg_content);"
    },
    {
        "line": 14,
        "fullcodeline": "if (!p)"
    }
]