[
    {
        "line": 8,
        "fullcodeline": "const auto& cont = t.args(0);"
    },
    {
        "line": 9,
        "fullcodeline": "const auto& tmpl = t.args(1);"
    },
    {
        "line": 10,
        "fullcodeline": "const auto& t_var = t.args(2);"
    },
    {
        "line": 12,
        "fullcodeline": "StringPiece var_name = t_var.s();"
    },
    {
        "line": 18,
        "fullcodeline": "const AttrValue* attr = attrs.at(var_name);"
    },
    {
        "line": 21,
        "fullcodeline": "result.set_type_id(cont.type_id());"
    },
    {
        "line": 23,
        "fullcodeline": "const auto attr_type = attr->value_case();"
    },
    {
        "line": 2,
        "fullcodeline": "if (t.args_size() != 3) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (attr_type == AttrValue::kType) {"
    },
    {
        "line": 60,
        "fullcodeline": "return OkStatus();"
    },
    {
        "line": 13,
        "fullcodeline": "if (!attrs.contains(var_name)) {"
    },
    {
        "line": 25,
        "fullcodeline": "FullTypeDef* target = result.add_args();"
    },
    {
        "line": 26,
        "fullcodeline": "*target = tmpl;"
    },
    {
        "line": 3,
        "fullcodeline": "return Status(error::INVALID_ARGUMENT,"
    },
    {
        "line": 14,
        "fullcodeline": "return Status("
    },
    {
        "line": 28,
        "fullcodeline": "SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,"
    },
    {
        "line": 29,
        "fullcodeline": "\"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());"
    },
    {
        "line": 4,
        "fullcodeline": "absl::StrCat(\"illegal FOR_EACH type, expected 3 args, got \","
    },
    {
        "line": 16,
        "fullcodeline": "absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));"
    },
    {
        "line": 5,
        "fullcodeline": "t.args_size()));"
    },
    {
        "line": 32,
        "fullcodeline": "const auto& attr_list = attr->list();"
    },
    {
        "line": 33,
        "fullcodeline": "int tsize = attr_list.type_size();"
    },
    {
        "line": 40,
        "fullcodeline": "attrs[var_name] = &replacement;"
    },
    {
        "line": 34,
        "fullcodeline": "if (tsize == 0) {"
    },
    {
        "line": 41,
        "fullcodeline": "for (int i = 0; i < tsize; i++) {"
    },
    {
        "line": 43,
        "fullcodeline": "FullTypeDef* target = result.add_args();"
    },
    {
        "line": 44,
        "fullcodeline": "*target = tmpl;"
    },
    {
        "line": 45,
        "fullcodeline": "TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),"
    },
    {
        "line": 55,
        "fullcodeline": "return Status(error::UNIMPLEMENTED,"
    },
    {
        "line": 35,
        "fullcodeline": "return Status(error::UNIMPLEMENTED,"
    },
    {
        "line": 42,
        "fullcodeline": "replacement.set_type(attr_list.type(i));"
    },
    {
        "line": 47,
        "fullcodeline": "\"' from\\n\", attr->DebugString(), \"\\n[\", i,"
    },
    {
        "line": 48,
        "fullcodeline": "\"] into\\n\", target->DebugString());"
    },
    {
        "line": 56,
        "fullcodeline": "absl::StrCat(\"unsupported attribute type\\n\","
    },
    {
        "line": 36,
        "fullcodeline": "absl::StrCat(\"unsupported list attribute type\\n\","
    },
    {
        "line": 57,
        "fullcodeline": "attr->DebugString(), \"\\nfor name \", var_name));"
    },
    {
        "line": 37,
        "fullcodeline": "attr_list.DebugString(), \"\\nkey=\", var_name));"
    }
]