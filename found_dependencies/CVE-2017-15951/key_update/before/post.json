[
    {
        "line": 4,
        "fullcodeline": "struct key *key = key_ref_to_ptr(key_ref);"
    },
    {
        "line": 7,
        "fullcodeline": "key_check(key);"
    },
    {
        "line": 10,
        "fullcodeline": "ret = key_permission(key_ref, KEY_NEED_WRITE);"
    },
    {
        "line": 18,
        "fullcodeline": "memset(&prep, 0, sizeof(prep));"
    },
    {
        "line": 19,
        "fullcodeline": "prep.data = payload;"
    },
    {
        "line": 20,
        "fullcodeline": "prep.datalen = plen;"
    },
    {
        "line": 22,
        "fullcodeline": "prep.expiry = TIME_T_MAX;"
    },
    {
        "line": 29,
        "fullcodeline": "down_write(&key->sem);"
    },
    {
        "line": 31,
        "fullcodeline": "ret = key->type->update(key, &prep);"
    },
    {
        "line": 36,
        "fullcodeline": "up_write(&key->sem);"
    },
    {
        "line": 11,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 32,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 24,
        "fullcodeline": "ret = key->type->preparse(&prep);"
    },
    {
        "line": 34,
        "fullcodeline": "clear_bit(KEY_FLAG_NEGATIVE, &key->flags);"
    },
    {
        "line": 40,
        "fullcodeline": "key->type->free_preparse(&prep);"
    },
    {
        "line": 16,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 25,
        "fullcodeline": "if (ret < 0)"
    }
]