[
    {
        "line": 3,
        "fullcodeline": "int rez = HevcUnit::deserialize();"
    },
    {
        "line": 10,
        "fullcodeline": "int payloadType = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int payloadSize = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "int nbyte = 0xFF;"
    },
    {
        "line": 18,
        "fullcodeline": "nbyte = 0xFF;"
    },
    {
        "line": 64,
        "fullcodeline": "} while (m_reader.getBitsLeft() > 16);"
    },
    {
        "line": 15,
        "fullcodeline": "nbyte = m_reader.getBits(8);"
    },
    {
        "line": 16,
        "fullcodeline": "payloadType += nbyte;"
    },
    {
        "line": 21,
        "fullcodeline": "nbyte = m_reader.getBits(8);"
    },
    {
        "line": 22,
        "fullcodeline": "payloadSize += nbyte;"
    },
    {
        "line": 24,
        "fullcodeline": "if (payloadType == 137 && !isHDR10)  // mastering_display_colour_volume"
    },
    {
        "line": 26,
        "fullcodeline": "isHDR10 = true;"
    },
    {
        "line": 27,
        "fullcodeline": "V3_flags |= HDR10;"
    },
    {
        "line": 28,
        "fullcodeline": "HDR10_metadata[0] = m_reader.getBits(32);  // display_primaries Green"
    },
    {
        "line": 29,
        "fullcodeline": "HDR10_metadata[1] = m_reader.getBits(32);  // display_primaries Red"
    },
    {
        "line": 30,
        "fullcodeline": "HDR10_metadata[2] = m_reader.getBits(32);  // display_primaries Blue"
    },
    {
        "line": 31,
        "fullcodeline": "HDR10_metadata[3] = m_reader.getBits(32);  // White Point"
    },
    {
        "line": 32,
        "fullcodeline": "HDR10_metadata[4] = ((m_reader.getBits(32) / 10000) << 16) +"
    },
    {
        "line": 33,
        "fullcodeline": "m_reader.getBits(32);  // max & min display_mastering_luminance"
    },
    {
        "line": 35,
        "fullcodeline": "else if (payloadType == 144)  // content_light_level_info"
    },
    {
        "line": 37,
        "fullcodeline": "int maxCLL = m_reader.getBits(16);"
    },
    {
        "line": 38,
        "fullcodeline": "int maxFALL = m_reader.getBits(16);"
    },
    {
        "line": 39,
        "fullcodeline": "if (maxCLL > (HDR10_metadata[5] >> 16) || maxFALL > (HDR10_metadata[5] & 0x0000ffff))"
    },
    {
        "line": 41,
        "fullcodeline": "maxCLL = (std::max)(maxCLL, HDR10_metadata[5] >> 16);"
    },
    {
        "line": 42,
        "fullcodeline": "maxFALL = (std::max)(maxFALL, HDR10_metadata[5] & 0x0000ffff);"
    },
    {
        "line": 43,
        "fullcodeline": "HDR10_metadata[5] = (maxCLL << 16) + maxFALL;"
    },
    {
        "line": 46,
        "fullcodeline": "else if (payloadType == 4 && payloadSize >= 8 && !isHDR10plus)"
    },
    {
        "line": 48,
        "fullcodeline": "m_reader.skipBits(8);   // country_code"
    },
    {
        "line": 49,
        "fullcodeline": "m_reader.skipBits(32);  // terminal_provider"
    },
    {
        "line": 50,
        "fullcodeline": "int application_identifier = m_reader.getBits(8);"
    },
    {
        "line": 51,
        "fullcodeline": "int application_version = m_reader.getBits(8);"
    },
    {
        "line": 52,
        "fullcodeline": "int num_windows = m_reader.getBits(2);"
    },
    {
        "line": 53,
        "fullcodeline": "m_reader.skipBits(6);"
    },
    {
        "line": 59,
        "fullcodeline": "payloadSize -= 8;"
    },
    {
        "line": 60,
        "fullcodeline": "for (int i = 0; i < payloadSize; i++) m_reader.skipBits(8);"
    },
    {
        "line": 54,
        "fullcodeline": "if (application_identifier == 4 && application_version == 1 && num_windows == 1)"
    },
    {
        "line": 56,
        "fullcodeline": "isHDR10plus = true;"
    },
    {
        "line": 57,
        "fullcodeline": "V3_flags |= HDR10PLUS;"
    },
    {
        "line": 63,
        "fullcodeline": "for (int i = 0; i < payloadSize; i++) m_reader.skipBits(8);"
    }
]