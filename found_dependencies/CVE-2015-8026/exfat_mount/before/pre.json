[
    {
        "line": 6,
        "fullcodeline": "exfat_tzset();"
    },
    {
        "line": 7,
        "fullcodeline": "memset(ef, 0, sizeof(struct exfat));"
    },
    {
        "line": 9,
        "fullcodeline": "parse_options(ef, options);"
    },
    {
        "line": 17,
        "fullcodeline": "ef->dev = exfat_open(spec, mode);"
    },
    {
        "line": 28,
        "fullcodeline": "ef->sb = malloc(sizeof(struct exfat_super_block));"
    },
    {
        "line": 35,
        "fullcodeline": "memset(ef->sb, 0, sizeof(struct exfat_super_block));"
    },
    {
        "line": 51,
        "fullcodeline": "ef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));"
    },
    {
        "line": 67,
        "fullcodeline": "memset(ef->zero_cluster, 0, CLUSTER_SIZE(*ef->sb));"
    },
    {
        "line": 106,
        "fullcodeline": "ef->root = malloc(sizeof(struct exfat_node));"
    },
    {
        "line": 115,
        "fullcodeline": "memset(ef->root, 0, sizeof(struct exfat_node));"
    },
    {
        "line": 116,
        "fullcodeline": "ef->root->flags = EXFAT_ATTRIB_DIR;"
    },
    {
        "line": 117,
        "fullcodeline": "ef->root->start_cluster = le32_to_cpu(ef->sb->rootdir_cluster);"
    },
    {
        "line": 118,
        "fullcodeline": "ef->root->fptr_cluster = ef->root->start_cluster;"
    },
    {
        "line": 120,
        "fullcodeline": "ef->root->size = rootdir_size(ef);"
    },
    {
        "line": 130,
        "fullcodeline": "ef->root->mtime = 0;"
    },
    {
        "line": 131,
        "fullcodeline": "ef->root->atime = 0;"
    },
    {
        "line": 133,
        "fullcodeline": "exfat_get_node(ef->root);"
    },
    {
        "line": 135,
        "fullcodeline": "rc = exfat_cache_directory(ef, ef->root);"
    },
    {
        "line": 155,
        "fullcodeline": "exfat_put_node(ef, ef->root);"
    },
    {
        "line": 156,
        "fullcodeline": "exfat_reset_cache(ef);"
    },
    {
        "line": 11,
        "fullcodeline": "if (match_option(options, \"ro\"))"
    },
    {
        "line": 18,
        "fullcodeline": "if (ef->dev == NULL)"
    },
    {
        "line": 29,
        "fullcodeline": "if (ef->sb == NULL)"
    },
    {
        "line": 52,
        "fullcodeline": "if (ef->zero_cluster == NULL)"
    },
    {
        "line": 77,
        "fullcodeline": "if (ef->sb->fat_count != 1)"
    },
    {
        "line": 107,
        "fullcodeline": "if (ef->root == NULL)"
    },
    {
        "line": 119,
        "fullcodeline": "ef->root->name[0] = cpu_to_le16('\\0');"
    },
    {
        "line": 121,
        "fullcodeline": "if (ef->root->size == 0)"
    },
    {
        "line": 138,
        "fullcodeline": "if (ef->upcase == NULL)"
    },
    {
        "line": 161,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 12,
        "fullcodeline": "mode = EXFAT_MODE_RO;"
    },
    {
        "line": 20,
        "fullcodeline": "if (exfat_get_mode(ef->dev) == EXFAT_MODE_RO)"
    },
    {
        "line": 37,
        "fullcodeline": "if (exfat_pread(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)"
    },
    {
        "line": 44,
        "fullcodeline": "if (memcmp(ef->sb->oem_name, \"EXFAT   \", 8) != 0)"
    },
    {
        "line": 60,
        "fullcodeline": "if (!verify_vbr_checksum(ef->dev, ef->zero_cluster, SECTOR_SIZE(*ef->sb)))"
    },
    {
        "line": 68,
        "fullcodeline": "if (ef->sb->version.major != 1 || ef->sb->version.minor != 0)"
    },
    {
        "line": 81,
        "fullcodeline": "exfat_error(\"unsupported FAT count: %hhu\", ef->sb->fat_count);"
    },
    {
        "line": 95,
        "fullcodeline": "if (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >"
    },
    {
        "line": 96,
        "fullcodeline": "exfat_get_size(ef->dev))"
    },
    {
        "line": 149,
        "fullcodeline": "if (prepare_super_block(ef) != 0)"
    },
    {
        "line": 19,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 33,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 42,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 49,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 57,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 65,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 75,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 83,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 93,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 113,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 127,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 13,
        "fullcodeline": "else if (match_option(options, \"ro_fallback\"))"
    },
    {
        "line": 23,
        "fullcodeline": "ef->ro = -1;"
    },
    {
        "line": 14,
        "fullcodeline": "mode = EXFAT_MODE_ANY;"
    },
    {
        "line": 25,
        "fullcodeline": "ef->ro = 1;"
    },
    {
        "line": 16,
        "fullcodeline": "mode = EXFAT_MODE_RW;"
    }
]