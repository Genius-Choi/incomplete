[
    {
        "line": 13,
        "fullcodeline": "mungspaces(buf);"
    },
    {
        "line": 24,
        "fullcodeline": "bufp = index(buf, '=');"
    },
    {
        "line": 25,
        "fullcodeline": "altp = index(buf, ':');"
    },
    {
        "line": 40,
        "fullcodeline": "++bufp;"
    },
    {
        "line": 44,
        "fullcodeline": "symp = match_sym(buf);"
    },
    {
        "line": 9,
        "fullcodeline": "if (strlen(buf) >= BUFSZ)"
    },
    {
        "line": 20,
        "fullcodeline": "if ((commentp = rindex(buf, '#')) != 0 && commentp[-1] == ' ')"
    },
    {
        "line": 26,
        "fullcodeline": "if (!bufp || (altp && altp < bufp))"
    },
    {
        "line": 28,
        "fullcodeline": "if (!bufp) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (*bufp == ' ')"
    },
    {
        "line": 45,
        "fullcodeline": "if (!symp) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (!symset[which_set].name) {"
    },
    {
        "line": 10,
        "fullcodeline": "buf[BUFSZ - 1] = '\\0';"
    },
    {
        "line": 21,
        "fullcodeline": "commentp[-1] = '\\0';"
    },
    {
        "line": 27,
        "fullcodeline": "bufp = altp;"
    },
    {
        "line": 42,
        "fullcodeline": "++bufp;"
    },
    {
        "line": 29,
        "fullcodeline": "if (strncmpi(buf, \"finish\", 6) == 0) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (symp->range == SYM_CONTROL) {"
    },
    {
        "line": 33,
        "fullcodeline": "chosen_symset_start = FALSE;"
    },
    {
        "line": 57,
        "fullcodeline": "for (lastsp = symset_list; lastsp; lastsp = lastsp->next)"
    },
    {
        "line": 175,
        "fullcodeline": "val = sym_val(bufp);"
    },
    {
        "line": 32,
        "fullcodeline": "chosen_symset_end = TRUE;"
    },
    {
        "line": 58,
        "fullcodeline": "if (!lastsp->next)"
    },
    {
        "line": 62,
        "fullcodeline": "tmpsp = (struct symsetentry *) alloc(sizeof *tmpsp);"
    },
    {
        "line": 63,
        "fullcodeline": "tmpsp->next = (struct symsetentry *) 0;"
    },
    {
        "line": 71,
        "fullcodeline": "tmpsp->handling = H_UNK;"
    },
    {
        "line": 88,
        "fullcodeline": "tmpsp = lastsp; /* most recent symset */"
    },
    {
        "line": 68,
        "fullcodeline": "tmpsp->idx = symset_count++;"
    },
    {
        "line": 69,
        "fullcodeline": "tmpsp->name = dupstr(bufp);"
    },
    {
        "line": 80,
        "fullcodeline": "for (i = 0; known_handling[i]; ++i)"
    },
    {
        "line": 89,
        "fullcodeline": "if (tmpsp && !tmpsp->desc)"
    },
    {
        "line": 95,
        "fullcodeline": "for (i = 0; known_restrictions[i]; ++i) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (!strcmpi(bufp, symset[which_set].name)) {"
    },
    {
        "line": 155,
        "fullcodeline": "int n = 0;"
    },
    {
        "line": 177,
        "fullcodeline": "if (which_set == PRIMARY) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (!strcmpi(known_handling[i], bufp)) {"
    },
    {
        "line": 90,
        "fullcodeline": "tmpsp->desc = dupstr(bufp);"
    },
    {
        "line": 122,
        "fullcodeline": "if (which_set == ROGUESET)"
    },
    {
        "line": 96,
        "fullcodeline": "if (!strcmpi(known_restrictions[i], bufp)) {"
    },
    {
        "line": 143,
        "fullcodeline": "if (!strcmpi(bufp, \"true\") || !strcmpi(bufp, \"yes\")"
    },
    {
        "line": 144,
        "fullcodeline": "|| !strcmpi(bufp, \"on\"))"
    },
    {
        "line": 158,
        "fullcodeline": "if (!strcmpi(known_restrictions[n], bufp)) {"
    },
    {
        "line": 146,
        "fullcodeline": "else if (!strcmpi(bufp, \"false\")"
    },
    {
        "line": 148,
        "fullcodeline": "|| !strcmpi(bufp, \"off\"))"
    },
    {
        "line": 147,
        "fullcodeline": "|| !strcmpi(bufp, \"no\")"
    }
]