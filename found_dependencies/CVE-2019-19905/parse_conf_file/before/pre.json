[
    {
        "line": 5,
        "fullcodeline": "char inbuf[4 * BUFSZ];"
    },
    {
        "line": 6,
        "fullcodeline": "boolean rv = TRUE; /* assume successful parse */"
    },
    {
        "line": 8,
        "fullcodeline": "boolean skip = FALSE, morelines = FALSE;"
    },
    {
        "line": 9,
        "fullcodeline": "char *buf = (char *) 0;"
    },
    {
        "line": 10,
        "fullcodeline": "size_t inbufsz = sizeof inbuf;"
    },
    {
        "line": 131,
        "fullcodeline": "free_config_sections();"
    },
    {
        "line": 14,
        "fullcodeline": "while (fgets(inbuf, (int) inbufsz, fp)) {"
    },
    {
        "line": 15,
        "fullcodeline": "ep = index(inbuf, '\\n');"
    },
    {
        "line": 129,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 18,
        "fullcodeline": "skip = FALSE; /* found newline; next line is normal */"
    },
    {
        "line": 20,
        "fullcodeline": "if (!ep) {  /* newline missing */"
    },
    {
        "line": 33,
        "fullcodeline": "char *tmpbuf = (char *) 0;"
    },
    {
        "line": 35,
        "fullcodeline": "boolean ignoreline = FALSE;"
    },
    {
        "line": 36,
        "fullcodeline": "boolean oldline = FALSE;"
    },
    {
        "line": 39,
        "fullcodeline": "morelines = (--ep >= inbuf && *ep == '\\\\');"
    },
    {
        "line": 55,
        "fullcodeline": "ep = inbuf;"
    },
    {
        "line": 123,
        "fullcodeline": "buf = (char *) 0;"
    },
    {
        "line": 21,
        "fullcodeline": "if (strlen(inbuf) < (inbufsz - 2)) {"
    },
    {
        "line": 30,
        "fullcodeline": "*ep = '\\0'; /* remove newline */"
    },
    {
        "line": 44,
        "fullcodeline": "while (ep >= inbuf"
    },
    {
        "line": 46,
        "fullcodeline": "*ep-- = '\\0';"
    },
    {
        "line": 48,
        "fullcodeline": "if (!config_error_nextline(inbuf)) {"
    },
    {
        "line": 56,
        "fullcodeline": "while (*ep == ' ' || *ep == '\\t')"
    },
    {
        "line": 57,
        "fullcodeline": "++ep;"
    },
    {
        "line": 60,
        "fullcodeline": "if (!*ep || *ep == '#')"
    },
    {
        "line": 67,
        "fullcodeline": "if (!ignoreline) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (morelines || (ignoreline && !oldline))"
    },
    {
        "line": 84,
        "fullcodeline": "if (handle_config_section(buf)) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (match_varname(buf, \"CHOOSE\", 6)) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (!proc(buf))"
    },
    {
        "line": 24,
        "fullcodeline": "ep = eos(inbuf);"
    },
    {
        "line": 41,
        "fullcodeline": "*ep = '\\0';"
    },
    {
        "line": 45,
        "fullcodeline": "&& (*ep == ' ' || *ep == '\\t' || *ep == '\\r'))"
    },
    {
        "line": 49,
        "fullcodeline": "rv = FALSE;"
    },
    {
        "line": 61,
        "fullcodeline": "ignoreline = TRUE;"
    },
    {
        "line": 64,
        "fullcodeline": "oldline = TRUE;"
    },
    {
        "line": 68,
        "fullcodeline": "len = (int) strlen(ep) + 1; /* +1: final '\\0' */"
    },
    {
        "line": 71,
        "fullcodeline": "tmpbuf = (char *) alloc(len);"
    },
    {
        "line": 72,
        "fullcodeline": "*tmpbuf = '\\0';"
    },
    {
        "line": 77,
        "fullcodeline": "buf = strcat(tmpbuf, ep);"
    },
    {
        "line": 78,
        "fullcodeline": "buf[sizeof inbuf - 1] = '\\0';"
    },
    {
        "line": 86,
        "fullcodeline": "buf = (char *) 0;"
    },
    {
        "line": 94,
        "fullcodeline": "char *bufp = find_optparam(buf);"
    },
    {
        "line": 104,
        "fullcodeline": "bufp++;"
    },
    {
        "line": 107,
        "fullcodeline": "section = choose_random_part(bufp, ',');"
    },
    {
        "line": 115,
        "fullcodeline": "buf = (char *) 0;"
    },
    {
        "line": 120,
        "fullcodeline": "rv = FALSE;"
    },
    {
        "line": 26,
        "fullcodeline": "config_error_add(\"Line too long, skipping\");"
    },
    {
        "line": 27,
        "fullcodeline": "skip = TRUE; /* discard next fgets */"
    },
    {
        "line": 96,
        "fullcodeline": "if (!bufp) {"
    },
    {
        "line": 51,
        "fullcodeline": "free(buf), buf = (char *) 0;"
    },
    {
        "line": 70,
        "fullcodeline": "len += (int) strlen(buf) + 1; /* +1: space */"
    },
    {
        "line": 74,
        "fullcodeline": "Strcat(strcpy(tmpbuf, buf), \" \");"
    },
    {
        "line": 97,
        "fullcodeline": "config_error_add("
    },
    {
        "line": 99,
        "fullcodeline": "rv = FALSE;"
    },
    {
        "line": 101,
        "fullcodeline": "buf = (char *) 0;"
    },
    {
        "line": 106,
        "fullcodeline": "free(config_section_chosen), config_section_chosen = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "config_section_chosen = dupstr(section);"
    },
    {
        "line": 111,
        "fullcodeline": "config_error_add(\"No config section to choose\");"
    },
    {
        "line": 112,
        "fullcodeline": "rv = FALSE;"
    }
]