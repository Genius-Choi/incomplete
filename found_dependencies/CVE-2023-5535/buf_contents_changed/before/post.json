[
    {
        "line": 4,
        "fullcodeline": "int\t\tdiffer = TRUE;"
    },
    {
        "line": 10,
        "fullcodeline": "newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);"
    },
    {
        "line": 22,
        "fullcodeline": "aucmd_prepbuf(&aco, newbuf);"
    },
    {
        "line": 47,
        "fullcodeline": "vim_free(ea.cmd);"
    },
    {
        "line": 50,
        "fullcodeline": "aucmd_restbuf(&aco);"
    },
    {
        "line": 11,
        "fullcodeline": "if (newbuf == NULL)"
    },
    {
        "line": 15,
        "fullcodeline": "if (prep_exarg(&ea, buf) == FAIL)"
    },
    {
        "line": 23,
        "fullcodeline": "if (curbuf != newbuf)"
    },
    {
        "line": 30,
        "fullcodeline": "if (ml_open(curbuf) == OK"
    },
    {
        "line": 52,
        "fullcodeline": "if (curbuf != newbuf)\t// safety check"
    },
    {
        "line": 17,
        "fullcodeline": "wipe_buffer(newbuf, FALSE);"
    },
    {
        "line": 26,
        "fullcodeline": "wipe_buffer(newbuf, FALSE);"
    },
    {
        "line": 31,
        "fullcodeline": "&& readfile(buf->b_ffname, buf->b_fname,"
    },
    {
        "line": 53,
        "fullcodeline": "wipe_buffer(newbuf, FALSE);"
    },
    {
        "line": 32,
        "fullcodeline": "(linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,"
    },
    {
        "line": 33,
        "fullcodeline": "&ea, READ_NEW | READ_DUMMY) == OK)"
    },
    {
        "line": 38,
        "fullcodeline": "differ = FALSE;"
    },
    {
        "line": 39,
        "fullcodeline": "for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)"
    },
    {
        "line": 40,
        "fullcodeline": "if (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)"
    },
    {
        "line": 42,
        "fullcodeline": "differ = TRUE;"
    }
]