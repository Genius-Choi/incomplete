[
    {
        "line": 3,
        "fullcodeline": "int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "char *shell, *format, *pidstr, *agentsocket = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "fd_set *readsetp = NULL, *writesetp = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "char pidstrbuf[1 + 3 * sizeof pid];"
    },
    {
        "line": 13,
        "fullcodeline": "struct timeval *tvp = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "ssh_malloc_init();\t/* must be called before any mallocs */"
    },
    {
        "line": 19,
        "fullcodeline": "sanitise_stdfd();"
    },
    {
        "line": 22,
        "fullcodeline": "setegid(getgid());"
    },
    {
        "line": 23,
        "fullcodeline": "setgid(getgid());"
    },
    {
        "line": 72,
        "fullcodeline": "ac -= optind;"
    },
    {
        "line": 73,
        "fullcodeline": "av += optind;"
    },
    {
        "line": 110,
        "fullcodeline": "parent_pid = getpid();"
    },
    {
        "line": 131,
        "fullcodeline": "prev_mask = umask(0177);"
    },
    {
        "line": 132,
        "fullcodeline": "sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);"
    },
    {
        "line": 138,
        "fullcodeline": "umask(prev_mask);"
    },
    {
        "line": 155,
        "fullcodeline": "pid = fork();"
    },
    {
        "line": 182,
        "fullcodeline": "log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);"
    },
    {
        "line": 189,
        "fullcodeline": "(void)chdir(\"/\");"
    },
    {
        "line": 200,
        "fullcodeline": "rlim.rlim_cur = rlim.rlim_max = 0;"
    },
    {
        "line": 208,
        "fullcodeline": "cleanup_pid = getpid();"
    },
    {
        "line": 213,
        "fullcodeline": "new_socket(AUTH_SOCKET, sock);"
    },
    {
        "line": 216,
        "fullcodeline": "idtab_init();"
    },
    {
        "line": 217,
        "fullcodeline": "signal(SIGPIPE, SIG_IGN);"
    },
    {
        "line": 218,
        "fullcodeline": "signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);"
    },
    {
        "line": 219,
        "fullcodeline": "signal(SIGHUP, cleanup_handler);"
    },
    {
        "line": 220,
        "fullcodeline": "signal(SIGTERM, cleanup_handler);"
    },
    {
        "line": 221,
        "fullcodeline": "nalloc = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "while ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))"
    },
    {
        "line": 78,
        "fullcodeline": "if (ac == 0 && !c_flag && !s_flag) {"
    },
    {
        "line": 112,
        "fullcodeline": "if (agentsocket == NULL) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (sock < 0) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (D_flag || d_flag) {"
    },
    {
        "line": 156,
        "fullcodeline": "if (pid == -1) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (pid != 0) {\t\t/* Parent - execute the given command. */"
    },
    {
        "line": 184,
        "fullcodeline": "if (setsid() == -1) {"
    },
    {
        "line": 190,
        "fullcodeline": "if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (setrlimit(RLIMIT_CORE, &rlim) < 0) {"
    },
    {
        "line": 214,
        "fullcodeline": "if (ac > 0)"
    },
    {
        "line": 223,
        "fullcodeline": "if (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)"
    },
    {
        "line": 76,
        "fullcodeline": "usage();"
    },
    {
        "line": 79,
        "fullcodeline": "shell = getenv(\"SHELL\");"
    },
    {
        "line": 85,
        "fullcodeline": "const char *errstr = NULL;"
    },
    {
        "line": 87,
        "fullcodeline": "pidstr = getenv(SSH_AGENTPID_ENV_NAME);"
    },
    {
        "line": 93,
        "fullcodeline": "pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);"
    },
    {
        "line": 104,
        "fullcodeline": "format = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";"
    },
    {
        "line": 105,
        "fullcodeline": "printf(format, SSH_AUTHSOCKET_ENV_NAME);"
    },
    {
        "line": 106,
        "fullcodeline": "printf(format, SSH_AGENTPID_ENV_NAME);"
    },
    {
        "line": 107,
        "fullcodeline": "printf(\"echo Agent pid %ld killed;\\n\", (long)pid);"
    },
    {
        "line": 108,
        "fullcodeline": "exit(0);"
    },
    {
        "line": 114,
        "fullcodeline": "mktemp_proto(socket_dir, sizeof(socket_dir));"
    },
    {
        "line": 119,
        "fullcodeline": "snprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,"
    },
    {
        "line": 135,
        "fullcodeline": "*socket_name = '\\0'; /* Don't unlink any existing file */"
    },
    {
        "line": 136,
        "fullcodeline": "cleanup_exit(1);"
    },
    {
        "line": 145,
        "fullcodeline": "log_init(__progname,"
    },
    {
        "line": 148,
        "fullcodeline": "format = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";"
    },
    {
        "line": 149,
        "fullcodeline": "printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,"
    },
    {
        "line": 151,
        "fullcodeline": "printf(\"echo Agent pid %ld;\\n\", (long)parent_pid);"
    },
    {
        "line": 152,
        "fullcodeline": "fflush(stdout);"
    },
    {
        "line": 157,
        "fullcodeline": "perror(\"fork\");"
    },
    {
        "line": 158,
        "fullcodeline": "cleanup_exit(1);"
    },
    {
        "line": 161,
        "fullcodeline": "close(sock);"
    },
    {
        "line": 162,
        "fullcodeline": "snprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);"
    },
    {
        "line": 177,
        "fullcodeline": "execvp(av[0], av);"
    },
    {
        "line": 178,
        "fullcodeline": "perror(av[0]);"
    },
    {
        "line": 179,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 185,
        "fullcodeline": "error(\"setsid: %s\", strerror(errno));"
    },
    {
        "line": 186,
        "fullcodeline": "cleanup_exit(1);"
    },
    {
        "line": 192,
        "fullcodeline": "(void)dup2(fd, STDIN_FILENO);"
    },
    {
        "line": 193,
        "fullcodeline": "(void)dup2(fd, STDOUT_FILENO);"
    },
    {
        "line": 194,
        "fullcodeline": "(void)dup2(fd, STDERR_FILENO);"
    },
    {
        "line": 202,
        "fullcodeline": "error(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));"
    },
    {
        "line": 203,
        "fullcodeline": "cleanup_exit(1);"
    },
    {
        "line": 215,
        "fullcodeline": "parent_alive_interval = 10;"
    },
    {
        "line": 224,
        "fullcodeline": "fatal(\"%s: pledge: %s\", __progname, strerror(errno));"
    },
    {
        "line": 227,
        "fullcodeline": "prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);"
    },
    {
        "line": 228,
        "fullcodeline": "result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);"
    },
    {
        "line": 229,
        "fullcodeline": "saved_errno = errno;"
    },
    {
        "line": 232,
        "fullcodeline": "(void) reaper();\t/* remove expired keys */"
    },
    {
        "line": 80,
        "fullcodeline": "if (shell != NULL && (len = strlen(shell)) > 2 &&"
    },
    {
        "line": 88,
        "fullcodeline": "if (pidstr == NULL) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (kill(pid, SIGTERM) == -1) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (mkdtemp(socket_dir) == NULL) {"
    },
    {
        "line": 120,
        "fullcodeline": "(long)parent_pid);"
    },
    {
        "line": 123,
        "fullcodeline": "socket_dir[0] = '\\0';"
    },
    {
        "line": 124,
        "fullcodeline": "strlcpy(socket_name, agentsocket, sizeof socket_name);"
    },
    {
        "line": 146,
        "fullcodeline": "d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,"
    },
    {
        "line": 163,
        "fullcodeline": "if (ac == 0) {"
    },
    {
        "line": 172,
        "fullcodeline": "if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||"
    },
    {
        "line": 195,
        "fullcodeline": "if (fd > 2)"
    },
    {
        "line": 230,
        "fullcodeline": "if (parent_alive_interval != 0)"
    },
    {
        "line": 233,
        "fullcodeline": "if (result < 0) {"
    },
    {
        "line": 32,
        "fullcodeline": "fingerprint_hash = ssh_digest_alg_by_name(optarg);"
    },
    {
        "line": 39,
        "fullcodeline": "c_flag++;"
    },
    {
        "line": 42,
        "fullcodeline": "k_flag++;"
    },
    {
        "line": 47,
        "fullcodeline": "s_flag++;"
    },
    {
        "line": 52,
        "fullcodeline": "d_flag++;"
    },
    {
        "line": 57,
        "fullcodeline": "D_flag++;"
    },
    {
        "line": 60,
        "fullcodeline": "agentsocket = optarg;"
    },
    {
        "line": 69,
        "fullcodeline": "usage();"
    },
    {
        "line": 81,
        "fullcodeline": "strncmp(shell + len - 3, \"csh\", 3) == 0)"
    },
    {
        "line": 82,
        "fullcodeline": "c_flag = 1;"
    },
    {
        "line": 89,
        "fullcodeline": "fprintf(stderr, \"%s not set, cannot kill agent\\n\","
    },
    {
        "line": 91,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 95,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 98,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 101,
        "fullcodeline": "perror(\"kill\");"
    },
    {
        "line": 102,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 116,
        "fullcodeline": "perror(\"mkdtemp: private socket dir\");"
    },
    {
        "line": 117,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 164,
        "fullcodeline": "format = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";"
    },
    {
        "line": 165,
        "fullcodeline": "printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,"
    },
    {
        "line": 167,
        "fullcodeline": "printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,"
    },
    {
        "line": 169,
        "fullcodeline": "printf(\"echo Agent pid %ld;\\n\", (long)pid);"
    },
    {
        "line": 170,
        "fullcodeline": "exit(0);"
    },
    {
        "line": 173,
        "fullcodeline": "setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {"
    },
    {
        "line": 174,
        "fullcodeline": "perror(\"setenv\");"
    },
    {
        "line": 175,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 196,
        "fullcodeline": "close(fd);"
    },
    {
        "line": 231,
        "fullcodeline": "check_parent_exists();"
    },
    {
        "line": 236,
        "fullcodeline": "fatal(\"select: %s\", strerror(saved_errno));"
    },
    {
        "line": 33,
        "fullcodeline": "if (fingerprint_hash == -1)"
    },
    {
        "line": 50,
        "fullcodeline": "if (d_flag || D_flag)"
    },
    {
        "line": 55,
        "fullcodeline": "if (d_flag || D_flag)"
    },
    {
        "line": 63,
        "fullcodeline": "if ((lifetime = convtime(optarg)) == -1) {"
    },
    {
        "line": 234,
        "fullcodeline": "if (saved_errno == EINTR)"
    },
    {
        "line": 34,
        "fullcodeline": "fatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);"
    },
    {
        "line": 38,
        "fullcodeline": "usage();"
    },
    {
        "line": 46,
        "fullcodeline": "usage();"
    },
    {
        "line": 51,
        "fullcodeline": "usage();"
    },
    {
        "line": 56,
        "fullcodeline": "usage();"
    },
    {
        "line": 64,
        "fullcodeline": "fprintf(stderr, \"Invalid lifetime\\n\");"
    },
    {
        "line": 65,
        "fullcodeline": "usage();"
    },
    {
        "line": 237,
        "fullcodeline": "} else if (result > 0)"
    },
    {
        "line": 238,
        "fullcodeline": "after_select(readsetp, writesetp);"
    }
]