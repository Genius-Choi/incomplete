[
    {
        "line": 12,
        "fullcodeline": "const auto base = reinterpret_cast<uintptr_t>(p);"
    },
    {
        "line": 14,
        "fullcodeline": "const auto header = static_cast<const elf_header *>(p);"
    },
    {
        "line": 18,
        "fullcodeline": "const auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff);"
    },
    {
        "line": 19,
        "fullcodeline": "const elf_shdr *const sections_end = sections_begin + header->e_shnum;"
    },
    {
        "line": 20,
        "fullcodeline": "auto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset);"
    },
    {
        "line": 22,
        "fullcodeline": "elf_addr plt_address = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "elf_addr got_address = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "if (header->e_shnum == 0 || header->e_shentsize == 0) {"
    },
    {
        "line": 27,
        "fullcodeline": "for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {"
    },
    {
        "line": 36,
        "fullcodeline": "for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {"
    },
    {
        "line": 123,
        "fullcodeline": "for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {"
    },
    {
        "line": 159,
        "fullcodeline": "for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {"
    },
    {
        "line": 37,
        "fullcodeline": "elf_addr base_address = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "if (strcmp(&section_strings[section->sh_name], \".plt\") == 0) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (strcmp(&section_strings[section->sh_name], \".rela.plt\") == 0) {"
    },
    {
        "line": 29,
        "fullcodeline": "plt_address = section->sh_addr;"
    },
    {
        "line": 39,
        "fullcodeline": "base_address = plt_address;"
    },
    {
        "line": 52,
        "fullcodeline": "elf_addr n      = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "auto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset);"
    },
    {
        "line": 86,
        "fullcodeline": "elf_addr n      = 0;"
    },
    {
        "line": 87,
        "fullcodeline": "auto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset);"
    },
    {
        "line": 128,
        "fullcodeline": "auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);"
    },
    {
        "line": 129,
        "fullcodeline": "auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);"
    },
    {
        "line": 164,
        "fullcodeline": "auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);"
    },
    {
        "line": 165,
        "fullcodeline": "auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);"
    },
    {
        "line": 30,
        "fullcodeline": "} else if (strcmp(&section_strings[section->sh_name], \".got\") == 0) {"
    },
    {
        "line": 40,
        "fullcodeline": "} else if (strcmp(&section_strings[section->sh_name], \".rel.plt\") == 0) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (section->sh_link == 0) {"
    },
    {
        "line": 59,
        "fullcodeline": "for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (section->sh_link == 0) {"
    },
    {
        "line": 93,
        "fullcodeline": "for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {"
    },
    {
        "line": 131,
        "fullcodeline": "for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {"
    },
    {
        "line": 167,
        "fullcodeline": "for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {"
    },
    {
        "line": 31,
        "fullcodeline": "got_address = section->sh_addr;"
    },
    {
        "line": 41,
        "fullcodeline": "base_address = plt_address;"
    },
    {
        "line": 61,
        "fullcodeline": "const size_t sym_index = M::elf_r_sym(relocation[i].r_info);"
    },
    {
        "line": 63,
        "fullcodeline": "auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);"
    },
    {
        "line": 64,
        "fullcodeline": "auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);"
    },
    {
        "line": 66,
        "fullcodeline": "const elf_addr symbol_address = base_address + ++n * M::plt_entry_size;"
    },
    {
        "line": 73,
        "fullcodeline": "plt_addresses.insert(symbol_address);"
    },
    {
        "line": 76,
        "fullcodeline": "sym.address = symbol_address;"
    },
    {
        "line": 77,
        "fullcodeline": "sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);"
    },
    {
        "line": 78,
        "fullcodeline": "sym.name    = &string_tab[symbol_tab[sym_index].st_name];"
    },
    {
        "line": 79,
        "fullcodeline": "sym.name += \"@\";"
    },
    {
        "line": 80,
        "fullcodeline": "sym.name += sym_name;"
    },
    {
        "line": 81,
        "fullcodeline": "sym.type = 'P';"
    },
    {
        "line": 82,
        "fullcodeline": "symbols.push_back(sym);"
    },
    {
        "line": 95,
        "fullcodeline": "const size_t sym_index = M::elf_r_sym(relocation[i].r_info);"
    },
    {
        "line": 97,
        "fullcodeline": "auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);"
    },
    {
        "line": 98,
        "fullcodeline": "auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);"
    },
    {
        "line": 100,
        "fullcodeline": "const elf_addr symbol_address = base_address + ++n * M::plt_entry_size;"
    },
    {
        "line": 107,
        "fullcodeline": "plt_addresses.insert(symbol_address);"
    },
    {
        "line": 110,
        "fullcodeline": "sym.address = symbol_address;"
    },
    {
        "line": 111,
        "fullcodeline": "sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);"
    },
    {
        "line": 113,
        "fullcodeline": "sym.name += \"@\";"
    },
    {
        "line": 114,
        "fullcodeline": "sym.name += sym_name;"
    },
    {
        "line": 115,
        "fullcodeline": "sym.type = 'P';"
    },
    {
        "line": 116,
        "fullcodeline": "symbols.push_back(sym);"
    },
    {
        "line": 133,
        "fullcodeline": "const elf_shdr *related_section = nullptr;"
    },
    {
        "line": 169,
        "fullcodeline": "const elf_shdr *related_section = nullptr;"
    },
    {
        "line": 69,
        "fullcodeline": "if (strlen(sym_name) > (sizeof(\".rela.\") - 1) && memcmp(sym_name, \".rela.\", (sizeof(\".rela.\") - 1)) == 0) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (strlen(sym_name) > (sizeof(\".rel.\") - 1) && memcmp(sym_name, \".rel.\", (sizeof(\".rel.\") - 1)) == 0) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {"
    },
    {
        "line": 171,
        "fullcodeline": "if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {"
    },
    {
        "line": 177,
        "fullcodeline": "if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {"
    },
    {
        "line": 42,
        "fullcodeline": "} else if (strcmp(&section_strings[section->sh_name], \".rela.got\") == 0) {"
    },
    {
        "line": 70,
        "fullcodeline": "sym_name += 6;"
    },
    {
        "line": 104,
        "fullcodeline": "sym_name += 5;"
    },
    {
        "line": 43,
        "fullcodeline": "base_address = got_address;"
    },
    {
        "line": 143,
        "fullcodeline": "if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) {"
    },
    {
        "line": 179,
        "fullcodeline": "if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) {"
    },
    {
        "line": 146,
        "fullcodeline": "sym.address = symbol_tab[i].st_value;"
    },
    {
        "line": 148,
        "fullcodeline": "sym.name    = &string_tab[symbol_tab[i].st_name];"
    },
    {
        "line": 149,
        "fullcodeline": "sym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');"
    },
    {
        "line": 150,
        "fullcodeline": "symbols.push_back(sym);"
    },
    {
        "line": 181,
        "fullcodeline": "sym.address = symbol_tab[i].st_value;"
    },
    {
        "line": 201,
        "fullcodeline": "sym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');"
    },
    {
        "line": 202,
        "fullcodeline": "symbols.push_back(sym);"
    },
    {
        "line": 44,
        "fullcodeline": "} else if (strcmp(&section_strings[section->sh_name], \".rel.got\") == 0) {"
    },
    {
        "line": 184,
        "fullcodeline": "for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {"
    },
    {
        "line": 197,
        "fullcodeline": "if (sym.name.isEmpty()) {"
    },
    {
        "line": 45,
        "fullcodeline": "base_address = got_address;"
    },
    {
        "line": 198,
        "fullcodeline": "sym.name = QString(\"$sym_%1\").arg(edb::v1::format_pointer(symbol_tab[i].st_value));"
    },
    {
        "line": 185,
        "fullcodeline": "if (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) {"
    },
    {
        "line": 186,
        "fullcodeline": "const std::int64_t offset = sym.address - section->sh_addr;"
    },
    {
        "line": 187,
        "fullcodeline": "const QString hexPrefix   = std::abs(offset) > 9 ? \"0x\" : \"\";"
    },
    {
        "line": 188,
        "fullcodeline": "const QString offsetStr   = offset ? \"+\" + hexPrefix + QString::number(offset, 16) : \"\";"
    },
    {
        "line": 189,
        "fullcodeline": "const QString sectionName(&section_strings[section->sh_name]);"
    },
    {
        "line": 190,
        "fullcodeline": "if (!sectionName.isEmpty()) {"
    },
    {
        "line": 191,
        "fullcodeline": "sym.name = QString(sectionName + offsetStr);"
    }
]