[
    {
        "line": 10,
        "fullcodeline": "tkHint->HintSample = tkHint->RTPTime = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "tkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);"
    },
    {
        "line": 13,
        "fullcodeline": "ft.num = tkHint->rtp_p->sl_config.timestampResolution;"
    },
    {
        "line": 14,
        "fullcodeline": "ft.den = tkHint->OrigTimeScale;"
    },
    {
        "line": 16,
        "fullcodeline": "e = GF_OK;"
    },
    {
        "line": 17,
        "fullcodeline": "for (i=0; i<tkHint->TotalSample; i++) {"
    },
    {
        "line": 18,
        "fullcodeline": "samp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);"
    },
    {
        "line": 22,
        "fullcodeline": "tkHint->CurrentSample = i + 1;"
    },
    {
        "line": 31,
        "fullcodeline": "ts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;"
    },
    {
        "line": 32,
        "fullcodeline": "tkHint->rtp_p->sl_header.compositionTimeStamp = ts;"
    },
    {
        "line": 34,
        "fullcodeline": "ts = ft.num * samp->DTS / ft.den;"
    },
    {
        "line": 35,
        "fullcodeline": "tkHint->rtp_p->sl_header.decodingTimeStamp = ts;"
    },
    {
        "line": 36,
        "fullcodeline": "tkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;"
    },
    {
        "line": 38,
        "fullcodeline": "tkHint->base_offset_in_sample = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "duration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);"
    },
    {
        "line": 104,
        "fullcodeline": "tkHint->rtp_p->sl_header.packetSequenceNumber += 1;"
    },
    {
        "line": 107,
        "fullcodeline": "gf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);"
    },
    {
        "line": 109,
        "fullcodeline": "tkHint->rtp_p->sl_header.AU_sequenceNumber += 1;"
    },
    {
        "line": 110,
        "fullcodeline": "gf_isom_sample_del(&samp);"
    },
    {
        "line": 19,
        "fullcodeline": "if (!samp) return gf_isom_last_error(tkHint->file);"
    },
    {
        "line": 26,
        "fullcodeline": "if (samp->IsRAP==RAP_REDUNDANT) {"
    },
    {
        "line": 27,
        "fullcodeline": "tkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;"
    },
    {
        "line": 28,
        "fullcodeline": "samp->IsRAP = RAP;"
    },
    {
        "line": 41,
        "fullcodeline": "GF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);"
    },
    {
        "line": 45,
        "fullcodeline": "gf_free(samp->data);"
    },
    {
        "line": 46,
        "fullcodeline": "samp->data = s->data;"
    },
    {
        "line": 47,
        "fullcodeline": "samp->dataLength = s->dataLength;"
    },
    {
        "line": 48,
        "fullcodeline": "gf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);"
    },
    {
        "line": 49,
        "fullcodeline": "s->data = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "s->dataLength = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "gf_isom_ismacryp_delete_sample(s);"
    },
    {
        "line": 55,
        "fullcodeline": "gf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);"
    },
    {
        "line": 56,
        "fullcodeline": "tkHint->rtp_p->sl_header.paddingBits = PadBits;"
    },
    {
        "line": 67,
        "fullcodeline": "u32 remain = samp->dataLength;"
    },
    {
        "line": 68,
        "fullcodeline": "char *ptr = samp->data;"
    },
    {
        "line": 70,
        "fullcodeline": "tkHint->rtp_p->sl_header.accessUnitStartFlag = 1;"
    },
    {
        "line": 71,
        "fullcodeline": "tkHint->rtp_p->sl_header.accessUnitEndFlag = 0;"
    },
    {
        "line": 43,
        "fullcodeline": "if (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;"
    },
    {
        "line": 44,
        "fullcodeline": "if (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;"
    },
    {
        "line": 58,
        "fullcodeline": "tkHint->rtp_p->sl_header.paddingBits = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "e = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );"
    },
    {
        "line": 73,
        "fullcodeline": "size = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "v = tkHint->avc_nalu_size;"
    },
    {
        "line": 86,
        "fullcodeline": "tkHint->base_offset_in_sample = samp->dataLength-remain;"
    },
    {
        "line": 91,
        "fullcodeline": "remain -= size;"
    },
    {
        "line": 92,
        "fullcodeline": "tkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;"
    },
    {
        "line": 99,
        "fullcodeline": "tkHint->rtp_p->sl_header.accessUnitStartFlag = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "if (v>remain) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (remain < size) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (!size) {"
    },
    {
        "line": 76,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));"
    },
    {
        "line": 80,
        "fullcodeline": "size |= (u8) *ptr;"
    },
    {
        "line": 81,
        "fullcodeline": "ptr++;"
    },
    {
        "line": 82,
        "fullcodeline": "remain--;"
    },
    {
        "line": 83,
        "fullcodeline": "v-=1;"
    },
    {
        "line": 88,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));"
    },
    {
        "line": 94,
        "fullcodeline": "GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is 0, ignoring it\\n\", size));"
    },
    {
        "line": 96,
        "fullcodeline": "e = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );"
    },
    {
        "line": 97,
        "fullcodeline": "ptr += size;"
    },
    {
        "line": 84,
        "fullcodeline": "if (v) size<<=8;"
    }
]