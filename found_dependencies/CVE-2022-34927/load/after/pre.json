[
    {
        "line": 3,
        "fullcodeline": "mp_ubyte insData[230];"
    },
    {
        "line": 4,
        "fullcodeline": "mp_sint32 smpReloc[MP_MAXINSSAMPS];"
    },
    {
        "line": 5,
        "fullcodeline": "mp_ubyte nbu[MP_MAXINSSAMPS];"
    },
    {
        "line": 6,
        "fullcodeline": "mp_uint32 fileSize = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "module->cleanUp();"
    },
    {
        "line": 11,
        "fullcodeline": "TXMHeader*\t\theader = &module->header;"
    },
    {
        "line": 12,
        "fullcodeline": "TXMInstrument*\tinstr  = module->instr;"
    },
    {
        "line": 13,
        "fullcodeline": "TXMSample*\t\tsmp\t   = module->smp;"
    },
    {
        "line": 14,
        "fullcodeline": "TXMPattern*\t\tphead  = module->phead;"
    },
    {
        "line": 20,
        "fullcodeline": "fileSize = f.sizeWithBaseOffset();"
    },
    {
        "line": 22,
        "fullcodeline": "f.read(&header->sig,1,17);"
    },
    {
        "line": 23,
        "fullcodeline": "f.read(&header->name,1,20);"
    },
    {
        "line": 24,
        "fullcodeline": "f.read(&header->whythis1a,1,1);"
    },
    {
        "line": 26,
        "fullcodeline": "f.read(&header->tracker,1,20);"
    },
    {
        "line": 27,
        "fullcodeline": "f.readWords(&header->ver,1);"
    },
    {
        "line": 34,
        "fullcodeline": "f.readDwords(&header->hdrsize,1);"
    },
    {
        "line": 36,
        "fullcodeline": "header->hdrsize-=4;"
    },
    {
        "line": 38,
        "fullcodeline": "mp_uint32 hdrSize = 0x110;"
    },
    {
        "line": 42,
        "fullcodeline": "mp_ubyte* hdrBuff = new mp_ubyte[hdrSize];"
    },
    {
        "line": 43,
        "fullcodeline": "memset(hdrBuff, 0, hdrSize);"
    },
    {
        "line": 45,
        "fullcodeline": "f.read(hdrBuff, 1, header->hdrsize);"
    },
    {
        "line": 47,
        "fullcodeline": "header->ordnum = LittleEndian::GET_WORD(hdrBuff);"
    },
    {
        "line": 49,
        "fullcodeline": "header->channum = LittleEndian::GET_WORD(hdrBuff+4);"
    },
    {
        "line": 50,
        "fullcodeline": "header->patnum = LittleEndian::GET_WORD(hdrBuff+6);"
    },
    {
        "line": 51,
        "fullcodeline": "header->insnum = LittleEndian::GET_WORD(hdrBuff+8);"
    },
    {
        "line": 17,
        "fullcodeline": "if (!phead || !instr || !smp)"
    },
    {
        "line": 39,
        "fullcodeline": "if (header->hdrsize > hdrSize)"
    },
    {
        "line": 48,
        "fullcodeline": "header->restart = LittleEndian::GET_WORD(hdrBuff+2);"
    },
    {
        "line": 52,
        "fullcodeline": "header->freqtab = LittleEndian::GET_WORD(hdrBuff+10);"
    },
    {
        "line": 53,
        "fullcodeline": "header->tempo = LittleEndian::GET_WORD(hdrBuff+12);"
    },
    {
        "line": 54,
        "fullcodeline": "header->speed = LittleEndian::GET_WORD(hdrBuff+14);"
    },
    {
        "line": 56,
        "fullcodeline": "if(header->ordnum > MP_MAXORDERS)"
    },
    {
        "line": 58,
        "fullcodeline": "if(header->insnum > MP_MAXINS)"
    },
    {
        "line": 64,
        "fullcodeline": "header->flags = XModule::MODULE_XMNOTECLIPPING |"
    },
    {
        "line": 72,
        "fullcodeline": "for (i=0;i<32;i++) header->pan[i]=0x80;"
    },
    {
        "line": 75,
        "fullcodeline": "if (header->ver == 0x102 || header->ver == 0x103)"
    },
    {
        "line": 258,
        "fullcodeline": "for (y=0;y<header->patnum;y++) {"
    },
    {
        "line": 689,
        "fullcodeline": "for (mp_sint32 s = 0; s < header->smpnum; s++)"
    },
    {
        "line": 742,
        "fullcodeline": "for (i = 0; i < header->ordnum; i++)"
    },
    {
        "line": 29,
        "fullcodeline": "if (header->ver != 0x102 &&"
    },
    {
        "line": 31,
        "fullcodeline": "header->ver != 0x104)"
    },
    {
        "line": 40,
        "fullcodeline": "hdrSize = header->hdrsize;"
    },
    {
        "line": 57,
        "fullcodeline": "header->ordnum = MP_MAXORDERS;"
    },
    {
        "line": 77,
        "fullcodeline": "mp_sint32 s = 0;"
    },
    {
        "line": 78,
        "fullcodeline": "mp_sint32 e = 0;"
    },
    {
        "line": 253,
        "fullcodeline": "header->smpnum=s;"
    },
    {
        "line": 278,
        "fullcodeline": "phead[y].patternData = new mp_ubyte[phead[y].rows*header->channum*6];"
    },
    {
        "line": 406,
        "fullcodeline": "mp_sint32 s = 0;"
    },
    {
        "line": 407,
        "fullcodeline": "mp_sint32 e = 0;"
    },
    {
        "line": 649,
        "fullcodeline": "header->smpnum=s;"
    },
    {
        "line": 743,
        "fullcodeline": "if (header->ord[i]+1 > header->patnum)"
    },
    {
        "line": 774,
        "fullcodeline": "char buffer[4];"
    },
    {
        "line": 775,
        "fullcodeline": "f.read(buffer, 1, 4);"
    },
    {
        "line": 30,
        "fullcodeline": "header->ver != 0x103 && // untested"
    },
    {
        "line": 79,
        "fullcodeline": "for (y=0;y<header->insnum;y++) {"
    },
    {
        "line": 281,
        "fullcodeline": "if (phead[y].patternData == NULL)"
    },
    {
        "line": 286,
        "fullcodeline": "memset(phead[y].patternData,0,phead[y].rows*header->channum*6);"
    },
    {
        "line": 408,
        "fullcodeline": "for (y=0;y<header->insnum;y++) {"
    },
    {
        "line": 656,
        "fullcodeline": "mp_sint32 s = 0;"
    },
    {
        "line": 691,
        "fullcodeline": "if (smp[s].type & 32)"
    },
    {
        "line": 745,
        "fullcodeline": "header->patnum = header->ord[i]+1;"
    },
    {
        "line": 752,
        "fullcodeline": "for (i = 0; i < header->patnum; i++)"
    },
    {
        "line": 772,
        "fullcodeline": "if (f.posWithBaseOffset() + 8 <= fileSize)"
    },
    {
        "line": 81,
        "fullcodeline": "f.readDwords(&instr[y].size,1);"
    },
    {
        "line": 82,
        "fullcodeline": "f.read(&instr[y].name,1,22);"
    },
    {
        "line": 83,
        "fullcodeline": "f.read(&instr[y].type,1,1);"
    },
    {
        "line": 84,
        "fullcodeline": "mp_uword numSamples = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "f.readWords(&numSamples,1);"
    },
    {
        "line": 88,
        "fullcodeline": "instr[y].samp = numSamples;"
    },
    {
        "line": 100,
        "fullcodeline": "f.readDwords(&instr[y].shsize,1);"
    },
    {
        "line": 102,
        "fullcodeline": "memset(insData, 0, 230);"
    },
    {
        "line": 107,
        "fullcodeline": "f.read(insData, 1, instr[y].size - 33);"
    },
    {
        "line": 247,
        "fullcodeline": "s+=instr[y].samp;"
    },
    {
        "line": 260,
        "fullcodeline": "if (header->ver == 0x104 || header->ver == 0x103)"
    },
    {
        "line": 262,
        "fullcodeline": "f.readDwords(&phead[y].len,1);"
    },
    {
        "line": 263,
        "fullcodeline": "f.read(&phead[y].ptype,1,1);"
    },
    {
        "line": 264,
        "fullcodeline": "f.readWords(&phead[y].rows,1);"
    },
    {
        "line": 265,
        "fullcodeline": "f.readWords(&phead[y].patdata,1);"
    },
    {
        "line": 289,
        "fullcodeline": "mp_ubyte *buffer = new mp_ubyte[phead[y].patdata];"
    },
    {
        "line": 297,
        "fullcodeline": "f.read(buffer,1,phead[y].patdata);"
    },
    {
        "line": 301,
        "fullcodeline": "mp_sint32 pc = 0, bc = 0;"
    },
    {
        "line": 417,
        "fullcodeline": "f.readDwords(&instr[y].size,1);"
    },
    {
        "line": 449,
        "fullcodeline": "f.readDwords(&instr[y].shsize,1);"
    },
    {
        "line": 453,
        "fullcodeline": "memset(insData, 0, 230);"
    },
    {
        "line": 461,
        "fullcodeline": "f.read(insData, 1, instr[y].size - 33);"
    },
    {
        "line": 470,
        "fullcodeline": "memset(smpReloc, 0, sizeof(smpReloc));"
    },
    {
        "line": 657,
        "fullcodeline": "for (y=0;y<header->insnum;y++) {"
    },
    {
        "line": 694,
        "fullcodeline": "smp[s].type &= 3+16;"
    },
    {
        "line": 735,
        "fullcodeline": "if ((smp[s].type & 0x3) == 0x3)"
    },
    {
        "line": 753,
        "fullcodeline": "if (phead[i].patternData == NULL)"
    },
    {
        "line": 776,
        "fullcodeline": "if (memcmp(buffer, \"text\", 4) == 0)"
    },
    {
        "line": 778,
        "fullcodeline": "mp_uint32 len = f.readDword();"
    },
    {
        "line": 779,
        "fullcodeline": "module->allocateSongMessage(len+1);"
    },
    {
        "line": 781,
        "fullcodeline": "memset(module->message, 0, len+1);"
    },
    {
        "line": 783,
        "fullcodeline": "f.read(module->message, 1, len);"
    },
    {
        "line": 86,
        "fullcodeline": "if(numSamples > MP_MAXINSSAMPS)"
    },
    {
        "line": 90,
        "fullcodeline": "if (instr[y].size == 29)"
    },
    {
        "line": 269,
        "fullcodeline": "f.readDwords(&phead[y].len,1);"
    },
    {
        "line": 270,
        "fullcodeline": "f.read(&phead[y].ptype,1,1);"
    },
    {
        "line": 271,
        "fullcodeline": "phead[y].rows = (mp_uword)f.readByte()+1;"
    },
    {
        "line": 272,
        "fullcodeline": "f.readWords(&phead[y].patdata,1);"
    },
    {
        "line": 292,
        "fullcodeline": "if (buffer == NULL)"
    },
    {
        "line": 302,
        "fullcodeline": "for (mp_sint32 r=0;r<phead[y].rows;r++) {"
    },
    {
        "line": 412,
        "fullcodeline": "if (f.posWithBaseOffset() >= fileSize)"
    },
    {
        "line": 434,
        "fullcodeline": "if (instr[y].samp > MP_MAXINSSAMPS)"
    },
    {
        "line": 439,
        "fullcodeline": "if (instr[y].size <= 29)"
    },
    {
        "line": 696,
        "fullcodeline": "if (smp[s].sample == NULL)"
    },
    {
        "line": 736,
        "fullcodeline": "smp[s].type&=~1;"
    },
    {
        "line": 755,
        "fullcodeline": "phead[i].rows = 64;"
    },
    {
        "line": 759,
        "fullcodeline": "phead[i].patternData = new mp_ubyte[phead[i].rows*header->channum*6];"
    },
    {
        "line": 104,
        "fullcodeline": "if (instr[y].size - 33 > 230)"
    },
    {
        "line": 110,
        "fullcodeline": "mp_ubyte* insDataPtr = insData;"
    },
    {
        "line": 112,
        "fullcodeline": "memcpy(nbu, insDataPtr, MP_MAXINSSAMPS);"
    },
    {
        "line": 113,
        "fullcodeline": "insDataPtr+=MP_MAXINSSAMPS;"
    },
    {
        "line": 117,
        "fullcodeline": "memset(&venv,0,sizeof(venv));"
    },
    {
        "line": 118,
        "fullcodeline": "memset(&penv,0,sizeof(penv));"
    },
    {
        "line": 134,
        "fullcodeline": "venv.num = *insDataPtr++;"
    },
    {
        "line": 136,
        "fullcodeline": "penv.num = *insDataPtr++;"
    },
    {
        "line": 138,
        "fullcodeline": "venv.sustain = *insDataPtr++;"
    },
    {
        "line": 139,
        "fullcodeline": "venv.loops = *insDataPtr++;"
    },
    {
        "line": 140,
        "fullcodeline": "venv.loope = *insDataPtr++;"
    },
    {
        "line": 141,
        "fullcodeline": "penv.sustain = *insDataPtr++;"
    },
    {
        "line": 142,
        "fullcodeline": "penv.loops = *insDataPtr++;"
    },
    {
        "line": 143,
        "fullcodeline": "penv.loope = *insDataPtr++;"
    },
    {
        "line": 144,
        "fullcodeline": "venv.type = *insDataPtr++;"
    },
    {
        "line": 145,
        "fullcodeline": "penv.type = *insDataPtr++;"
    },
    {
        "line": 150,
        "fullcodeline": "vibtype = *insDataPtr++;"
    },
    {
        "line": 151,
        "fullcodeline": "vibsweep = *insDataPtr++;"
    },
    {
        "line": 152,
        "fullcodeline": "vibdepth = *insDataPtr++;"
    },
    {
        "line": 153,
        "fullcodeline": "vibrate = *insDataPtr++;"
    },
    {
        "line": 155,
        "fullcodeline": "vibdepth<<=1;"
    },
    {
        "line": 157,
        "fullcodeline": "volfade = LittleEndian::GET_WORD(insDataPtr);"
    },
    {
        "line": 158,
        "fullcodeline": "insDataPtr+=2;"
    },
    {
        "line": 159,
        "fullcodeline": "volfade<<=1;"
    },
    {
        "line": 174,
        "fullcodeline": "mp_sint32 g=0, sc;"
    },
    {
        "line": 226,
        "fullcodeline": "instr[y].samp = g;"
    },
    {
        "line": 235,
        "fullcodeline": "e++;"
    },
    {
        "line": 419,
        "fullcodeline": "if (instr[y].size >= 4 && instr[y].size < 29)"
    },
    {
        "line": 422,
        "fullcodeline": "memset(buffer, 0, sizeof(buffer));"
    },
    {
        "line": 423,
        "fullcodeline": "f.read(buffer, 1, instr[y].size - 4);"
    },
    {
        "line": 424,
        "fullcodeline": "memcpy(instr[y].name, buffer, 22);"
    },
    {
        "line": 426,
        "fullcodeline": "instr[y].samp = LittleEndian::GET_WORD(buffer + 23);"
    },
    {
        "line": 455,
        "fullcodeline": "if (instr[y].size - 33 > 230)"
    },
    {
        "line": 473,
        "fullcodeline": "mp_ubyte* insDataPtr = insData;"
    },
    {
        "line": 477,
        "fullcodeline": "memcpy(nbu, insDataPtr, MP_MAXINSSAMPS);"
    },
    {
        "line": 478,
        "fullcodeline": "insDataPtr+=MP_MAXINSSAMPS;"
    },
    {
        "line": 482,
        "fullcodeline": "memset(&venv,0,sizeof(venv));"
    },
    {
        "line": 483,
        "fullcodeline": "memset(&penv,0,sizeof(penv));"
    },
    {
        "line": 499,
        "fullcodeline": "venv.num = *insDataPtr++;"
    },
    {
        "line": 501,
        "fullcodeline": "penv.num = *insDataPtr++;"
    },
    {
        "line": 503,
        "fullcodeline": "venv.sustain = *insDataPtr++;"
    },
    {
        "line": 504,
        "fullcodeline": "venv.loops = *insDataPtr++;"
    },
    {
        "line": 505,
        "fullcodeline": "venv.loope = *insDataPtr++;"
    },
    {
        "line": 506,
        "fullcodeline": "penv.sustain = *insDataPtr++;"
    },
    {
        "line": 507,
        "fullcodeline": "penv.loops = *insDataPtr++;"
    },
    {
        "line": 508,
        "fullcodeline": "penv.loope = *insDataPtr++;"
    },
    {
        "line": 509,
        "fullcodeline": "venv.type = *insDataPtr++;"
    },
    {
        "line": 510,
        "fullcodeline": "penv.type = *insDataPtr++;"
    },
    {
        "line": 515,
        "fullcodeline": "vibtype = *insDataPtr++;"
    },
    {
        "line": 516,
        "fullcodeline": "vibsweep = *insDataPtr++;"
    },
    {
        "line": 517,
        "fullcodeline": "vibdepth = *insDataPtr++;"
    },
    {
        "line": 518,
        "fullcodeline": "vibrate = *insDataPtr++;"
    },
    {
        "line": 520,
        "fullcodeline": "vibdepth<<=1;"
    },
    {
        "line": 523,
        "fullcodeline": "volfade = LittleEndian::GET_WORD(insDataPtr);"
    },
    {
        "line": 524,
        "fullcodeline": "insDataPtr+=2;"
    },
    {
        "line": 525,
        "fullcodeline": "volfade<<=1;"
    },
    {
        "line": 540,
        "fullcodeline": "mp_sint32 g=0, sc;"
    },
    {
        "line": 593,
        "fullcodeline": "instr[y].samp = g;"
    },
    {
        "line": 634,
        "fullcodeline": "e++;"
    },
    {
        "line": 658,
        "fullcodeline": "for (sc=0;sc<instr[y].samp;sc++) {"
    },
    {
        "line": 699,
        "fullcodeline": "if (!(smp[s].type&16)) {"
    },
    {
        "line": 700,
        "fullcodeline": "smp[s].samplen>>=1;"
    },
    {
        "line": 704,
        "fullcodeline": "mp_sbyte* sample = (mp_sbyte*)smp[s].sample;"
    },
    {
        "line": 705,
        "fullcodeline": "mp_sint32 samplen = smp[s].samplen;"
    },
    {
        "line": 762,
        "fullcodeline": "if (phead[i].patternData == NULL)"
    },
    {
        "line": 767,
        "fullcodeline": "memset(phead[i].patternData,0,phead[i].rows*header->channum*6);"
    },
    {
        "line": 95,
        "fullcodeline": "for (mp_sint32 i = 0; i < 120; i++)"
    },
    {
        "line": 121,
        "fullcodeline": "for (k = 0; k < XM_ENVELOPENUMPOINTS; k++)"
    },
    {
        "line": 127,
        "fullcodeline": "for (k = 0; k < XM_ENVELOPENUMPOINTS; k++)"
    },
    {
        "line": 135,
        "fullcodeline": "if (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;"
    },
    {
        "line": 137,
        "fullcodeline": "if (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;"
    },
    {
        "line": 164,
        "fullcodeline": "for (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {"
    },
    {
        "line": 175,
        "fullcodeline": "for (sc=0;sc<instr[y].samp;sc++) {"
    },
    {
        "line": 228,
        "fullcodeline": "for (sc = 0; sc < MP_MAXINSSAMPS; sc++) {"
    },
    {
        "line": 303,
        "fullcodeline": "for (mp_sint32 c=0;c<header->channum;c++) {"
    },
    {
        "line": 421,
        "fullcodeline": "mp_ubyte buffer[29];"
    },
    {
        "line": 430,
        "fullcodeline": "f.read(&instr[y].name,1,22);"
    },
    {
        "line": 431,
        "fullcodeline": "f.read(&instr[y].type,1,1);"
    },
    {
        "line": 432,
        "fullcodeline": "f.readWords(&instr[y].samp,1);"
    },
    {
        "line": 444,
        "fullcodeline": "for (mp_sint32 i = 0; i < 120; i++)"
    },
    {
        "line": 486,
        "fullcodeline": "for (k = 0; k < XM_ENVELOPENUMPOINTS; k++)"
    },
    {
        "line": 492,
        "fullcodeline": "for (k = 0; k < XM_ENVELOPENUMPOINTS; k++)"
    },
    {
        "line": 500,
        "fullcodeline": "if (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;"
    },
    {
        "line": 502,
        "fullcodeline": "if (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;"
    },
    {
        "line": 530,
        "fullcodeline": "for (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {"
    },
    {
        "line": 541,
        "fullcodeline": "for (sc=0;sc<instr[y].samp;sc++) {"
    },
    {
        "line": 595,
        "fullcodeline": "for (sc = 0; sc < MP_MAXINSSAMPS; sc++) {"
    },
    {
        "line": 602,
        "fullcodeline": "for (sc=0;sc<instr[y].samp;sc++) {"
    },
    {
        "line": 675,
        "fullcodeline": "s++;"
    },
    {
        "line": 706,
        "fullcodeline": "for (mp_sint32 i = 0; i < samplen; i++)"
    },
    {
        "line": 716,
        "fullcodeline": "smp[s].samplen>>=1;"
    },
    {
        "line": 720,
        "fullcodeline": "mp_sword* sample = (mp_sword*)smp[s].sample;"
    },
    {
        "line": 721,
        "fullcodeline": "mp_sint32 samplen = smp[s].samplen;"
    },
    {
        "line": 96,
        "fullcodeline": "instr[y].snum[i] = -1;"
    },
    {
        "line": 125,
        "fullcodeline": "insDataPtr+=4;"
    },
    {
        "line": 131,
        "fullcodeline": "insDataPtr+=4;"
    },
    {
        "line": 165,
        "fullcodeline": "venv.env[l][1]<<=2;"
    },
    {
        "line": 166,
        "fullcodeline": "penv.env[l][1]<<=2;"
    },
    {
        "line": 169,
        "fullcodeline": "if (!module->addVolumeEnvelope(venv))"
    },
    {
        "line": 171,
        "fullcodeline": "if (!module->addPanningEnvelope(penv))"
    },
    {
        "line": 190,
        "fullcodeline": "f.readDwords(&smp[g+s].samplen,1);"
    },
    {
        "line": 191,
        "fullcodeline": "f.readDwords(&smp[g+s].loopstart,1);"
    },
    {
        "line": 192,
        "fullcodeline": "f.readDwords(&smp[g+s].looplen,1);"
    },
    {
        "line": 195,
        "fullcodeline": "f.read(&smp[g+s].finetune,1,1);"
    },
    {
        "line": 196,
        "fullcodeline": "f.read(&smp[g+s].type,1,1);"
    },
    {
        "line": 200,
        "fullcodeline": "f.read(&smp[g+s].pan,1,1);"
    },
    {
        "line": 201,
        "fullcodeline": "f.read(&smp[g+s].relnote,1,1);"
    },
    {
        "line": 202,
        "fullcodeline": "f.read(&smp[g+s].res,1,1);"
    },
    {
        "line": 203,
        "fullcodeline": "f.read(&smp[g+s].name,1,22);"
    },
    {
        "line": 206,
        "fullcodeline": "memset(line, 0, sizeof(line));"
    },
    {
        "line": 207,
        "fullcodeline": "XModule::convertStr(line, smp[g+s].name, 23, false);"
    },
    {
        "line": 240,
        "fullcodeline": "for (mp_sint32 i = 0; i < 120; i++)"
    },
    {
        "line": 305,
        "fullcodeline": "mp_ubyte slot[5];"
    },
    {
        "line": 306,
        "fullcodeline": "memset(slot,0,5);"
    },
    {
        "line": 346,
        "fullcodeline": "char gl=0;"
    },
    {
        "line": 373,
        "fullcodeline": "phead[y].patternData[bc]=slot[0];"
    },
    {
        "line": 374,
        "fullcodeline": "phead[y].patternData[bc+1]=slot[1];"
    },
    {
        "line": 376,
        "fullcodeline": "XModule::convertXMVolumeEffects(slot[2], phead[y].patternData[bc+2], phead[y].patternData[bc+3]);"
    },
    {
        "line": 378,
        "fullcodeline": "phead[y].patternData[bc+4]=slot[3];"
    },
    {
        "line": 379,
        "fullcodeline": "phead[y].patternData[bc+5]=slot[4];"
    },
    {
        "line": 394,
        "fullcodeline": "bc+=6;"
    },
    {
        "line": 445,
        "fullcodeline": "instr[y].snum[i] = -1;"
    },
    {
        "line": 490,
        "fullcodeline": "insDataPtr+=4;"
    },
    {
        "line": 496,
        "fullcodeline": "insDataPtr+=4;"
    },
    {
        "line": 535,
        "fullcodeline": "if (!module->addVolumeEnvelope(venv))"
    },
    {
        "line": 537,
        "fullcodeline": "if (!module->addPanningEnvelope(penv))"
    },
    {
        "line": 557,
        "fullcodeline": "f.readDwords(&smp[g+s].samplen,1);"
    },
    {
        "line": 559,
        "fullcodeline": "f.readDwords(&smp[g+s].loopstart,1);"
    },
    {
        "line": 560,
        "fullcodeline": "f.readDwords(&smp[g+s].looplen,1);"
    },
    {
        "line": 563,
        "fullcodeline": "f.read(&smp[g+s].finetune,1,1);"
    },
    {
        "line": 564,
        "fullcodeline": "f.read(&smp[g+s].type,1,1);"
    },
    {
        "line": 568,
        "fullcodeline": "f.read(&smp[g+s].pan,1,1);"
    },
    {
        "line": 569,
        "fullcodeline": "f.read(&smp[g+s].relnote,1,1);"
    },
    {
        "line": 570,
        "fullcodeline": "f.read(&smp[g+s].res,1,1);"
    },
    {
        "line": 571,
        "fullcodeline": "f.read(&smp[g+s].name,1,22);"
    },
    {
        "line": 574,
        "fullcodeline": "memset(line, 0, sizeof(line));"
    },
    {
        "line": 575,
        "fullcodeline": "XModule::convertStr(line, smp[g+s].name, 23, false);"
    },
    {
        "line": 627,
        "fullcodeline": "s++;"
    },
    {
        "line": 639,
        "fullcodeline": "for (mp_sint32 i = 0; i < 120; i++)"
    },
    {
        "line": 677,
        "fullcodeline": "if (s>=MP_MAXSAMPLES)"
    },
    {
        "line": 708,
        "fullcodeline": "mp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;"
    },
    {
        "line": 711,
        "fullcodeline": "sample[i] = (mp_sbyte)s;"
    },
    {
        "line": 722,
        "fullcodeline": "for (mp_sint32 i = 0; i < samplen; i++)"
    },
    {
        "line": 123,
        "fullcodeline": "venv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);"
    },
    {
        "line": 124,
        "fullcodeline": "venv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);"
    },
    {
        "line": 129,
        "fullcodeline": "penv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);"
    },
    {
        "line": 130,
        "fullcodeline": "penv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);"
    },
    {
        "line": 193,
        "fullcodeline": "smp[g+s].vol=XModule::vol64to255(f.readByte());"
    },
    {
        "line": 205,
        "fullcodeline": "char line[30];"
    },
    {
        "line": 229,
        "fullcodeline": "if (smpReloc[nbu[sc]] == -1)"
    },
    {
        "line": 241,
        "fullcodeline": "instr[y].snum[i] = -1;"
    },
    {
        "line": 308,
        "fullcodeline": "if ((buffer[pc]&128)) {"
    },
    {
        "line": 347,
        "fullcodeline": "for (mp_sint32 i=0;i<XModule::numValidXMEffects;i++)"
    },
    {
        "line": 359,
        "fullcodeline": "if ((!slot[3])&&(slot[4])) slot[3]=0x20;"
    },
    {
        "line": 361,
        "fullcodeline": "if (slot[3]==0xE) {"
    },
    {
        "line": 366,
        "fullcodeline": "if (slot[3]==0x21) {"
    },
    {
        "line": 371,
        "fullcodeline": "if (slot[0]==97) slot[0]=XModule::NOTE_OFF;"
    },
    {
        "line": 488,
        "fullcodeline": "venv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);"
    },
    {
        "line": 489,
        "fullcodeline": "venv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);"
    },
    {
        "line": 494,
        "fullcodeline": "penv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);"
    },
    {
        "line": 495,
        "fullcodeline": "penv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);"
    },
    {
        "line": 561,
        "fullcodeline": "smp[g+s].vol=XModule::vol64to255(f.readByte());"
    },
    {
        "line": 573,
        "fullcodeline": "char line[30];"
    },
    {
        "line": 596,
        "fullcodeline": "if (smpReloc[nbu[sc]] == -1)"
    },
    {
        "line": 629,
        "fullcodeline": "if (s>=MP_MAXSAMPLES)"
    },
    {
        "line": 640,
        "fullcodeline": "instr[y].snum[i] = -1;"
    },
    {
        "line": 662,
        "fullcodeline": "mp_uint32 oldSize = smp[s].samplen;"
    },
    {
        "line": 670,
        "fullcodeline": "mp_sint32 result = module->loadModuleSample(f, s, XModule::ST_DELTA, XModule::ST_DELTA | XModule::ST_16BIT, oldSize);"
    },
    {
        "line": 709,
        "fullcodeline": "if (s < -128) s = -128;"
    },
    {
        "line": 710,
        "fullcodeline": "if (s > 127) s = 127;"
    },
    {
        "line": 724,
        "fullcodeline": "mp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;"
    },
    {
        "line": 727,
        "fullcodeline": "sample[i] = (mp_sword)s;"
    },
    {
        "line": 209,
        "fullcodeline": "module->addSongMessageLine(line);"
    },
    {
        "line": 215,
        "fullcodeline": "smpReloc[sc] = g;"
    },
    {
        "line": 216,
        "fullcodeline": "g++;"
    },
    {
        "line": 310,
        "fullcodeline": "mp_ubyte pb = buffer[pc];"
    },
    {
        "line": 311,
        "fullcodeline": "pc++;"
    },
    {
        "line": 348,
        "fullcodeline": "if (slot[3]==XModule::validXMEffects[i]) gl=1;"
    },
    {
        "line": 350,
        "fullcodeline": "if (!gl) slot[3]=slot[4]=0;"
    },
    {
        "line": 352,
        "fullcodeline": "if ((slot[3]==0xC)||(slot[3]==0x10)) {"
    },
    {
        "line": 353,
        "fullcodeline": "slot[4] = XModule::vol64to255(slot[4]);"
    },
    {
        "line": 362,
        "fullcodeline": "slot[3]=(slot[4]>>4)+0x30;"
    },
    {
        "line": 363,
        "fullcodeline": "slot[4]=slot[4]&0xf;"
    },
    {
        "line": 367,
        "fullcodeline": "slot[3]=(slot[4]>>4)+0x40;"
    },
    {
        "line": 368,
        "fullcodeline": "slot[4]=slot[4]&0xf;"
    },
    {
        "line": 577,
        "fullcodeline": "module->addSongMessageLine(line);"
    },
    {
        "line": 582,
        "fullcodeline": "smpReloc[sc] = g;"
    },
    {
        "line": 583,
        "fullcodeline": "g++;"
    },
    {
        "line": 608,
        "fullcodeline": "mp_uint32 oldSize = smp[s].samplen;"
    },
    {
        "line": 616,
        "fullcodeline": "mp_sint32 result = module->loadModuleSample(f, s,"
    },
    {
        "line": 671,
        "fullcodeline": "if (result != MP_OK)"
    },
    {
        "line": 725,
        "fullcodeline": "if (s < -32768) s = -32768;"
    },
    {
        "line": 726,
        "fullcodeline": "if (s > 32767) s = 32767;"
    },
    {
        "line": 219,
        "fullcodeline": "smpReloc[sc] = -1;"
    },
    {
        "line": 230,
        "fullcodeline": "instr[y].snum[sc] = -1;"
    },
    {
        "line": 313,
        "fullcodeline": "if ((pb&1)) {"
    },
    {
        "line": 318,
        "fullcodeline": "if ((pb&2)) {"
    },
    {
        "line": 323,
        "fullcodeline": "if ((pb&4)) {"
    },
    {
        "line": 328,
        "fullcodeline": "if ((pb&8)) {"
    },
    {
        "line": 342,
        "fullcodeline": "memcpy(slot,buffer+pc,5);"
    },
    {
        "line": 343,
        "fullcodeline": "pc+=5;"
    },
    {
        "line": 586,
        "fullcodeline": "smpReloc[sc] = -1;"
    },
    {
        "line": 597,
        "fullcodeline": "instr[y].snum[sc] = -1;"
    },
    {
        "line": 606,
        "fullcodeline": "bool adpcm = (smp[s].res == 0xAD);"
    },
    {
        "line": 620,
        "fullcodeline": "if (result != MP_OK)"
    },
    {
        "line": 315,
        "fullcodeline": "slot[0]=buffer[pc];"
    },
    {
        "line": 316,
        "fullcodeline": "pc++;"
    },
    {
        "line": 320,
        "fullcodeline": "slot[1]=buffer[pc];"
    },
    {
        "line": 321,
        "fullcodeline": "pc++;"
    },
    {
        "line": 325,
        "fullcodeline": "slot[2]=buffer[pc];"
    },
    {
        "line": 326,
        "fullcodeline": "pc++;"
    },
    {
        "line": 330,
        "fullcodeline": "slot[3]=buffer[pc];"
    },
    {
        "line": 331,
        "fullcodeline": "pc++;"
    },
    {
        "line": 335,
        "fullcodeline": "slot[4]=buffer[pc];"
    },
    {
        "line": 336,
        "fullcodeline": "pc++;"
    },
    {
        "line": 618,
        "fullcodeline": "adpcm ? (XModule::ST_PACKING_ADPCM | XModule::ST_16BIT) : (XModule::ST_DELTA | XModule::ST_16BIT),"
    }
]