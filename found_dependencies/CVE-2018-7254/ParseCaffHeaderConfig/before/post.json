[
    {
        "line": 3,
        "fullcodeline": "uint32_t chan_chunk = 0, channel_layout = 0, bcount;"
    },
    {
        "line": 4,
        "fullcodeline": "unsigned char *channel_identities = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "unsigned char *channel_reorder = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "int64_t total_samples = 0, infilesize;"
    },
    {
        "line": 12,
        "fullcodeline": "infilesize = DoGetFileSize (infile);"
    },
    {
        "line": 13,
        "fullcodeline": "memcpy (&caf_file_header, fourcc, 4);"
    },
    {
        "line": 26,
        "fullcodeline": "WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);"
    },
    {
        "line": 15,
        "fullcodeline": "if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||"
    },
    {
        "line": 28,
        "fullcodeline": "if (caf_file_header.mFileVersion != 1) {"
    },
    {
        "line": 367,
        "fullcodeline": "if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))"
    },
    {
        "line": 370,
        "fullcodeline": "if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {"
    },
    {
        "line": 378,
        "fullcodeline": "if (channel_layout || channel_reorder) {"
    },
    {
        "line": 16,
        "fullcodeline": "bcount != sizeof (CAFFileHeader) - 4)) {"
    },
    {
        "line": 17,
        "fullcodeline": "error_line (\"%s is not a valid .CAF file!\", infilename);"
    },
    {
        "line": 29,
        "fullcodeline": "error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);"
    },
    {
        "line": 48,
        "fullcodeline": "WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);"
    },
    {
        "line": 368,
        "fullcodeline": "config->channel_mask = 0x5 - config->num_channels;"
    },
    {
        "line": 371,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 376,
        "fullcodeline": "free (channel_identities);"
    },
    {
        "line": 37,
        "fullcodeline": "if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||"
    },
    {
        "line": 53,
        "fullcodeline": "if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {"
    },
    {
        "line": 379,
        "fullcodeline": "if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {"
    },
    {
        "line": 20,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 38,
        "fullcodeline": "bcount != sizeof (CAFChunkHeader)) {"
    },
    {
        "line": 39,
        "fullcodeline": "error_line (\"%s is not a valid .CAF file!\", infilename);"
    },
    {
        "line": 54,
        "fullcodeline": "int supported = TRUE;"
    },
    {
        "line": 68,
        "fullcodeline": "WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);"
    },
    {
        "line": 104,
        "fullcodeline": "config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;"
    },
    {
        "line": 105,
        "fullcodeline": "config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;"
    },
    {
        "line": 106,
        "fullcodeline": "config->bits_per_sample = caf_audio_format.mBitsPerChannel;"
    },
    {
        "line": 107,
        "fullcodeline": "config->num_channels = caf_audio_format.mChannelsPerFrame;"
    },
    {
        "line": 108,
        "fullcodeline": "config->sample_rate = (int) caf_audio_format.mSampleRate;"
    },
    {
        "line": 380,
        "fullcodeline": "error_line (\"problem with setting channel layout (should not happen)\");"
    },
    {
        "line": 385,
        "fullcodeline": "free (channel_reorder);"
    },
    {
        "line": 21,
        "fullcodeline": "!WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {"
    },
    {
        "line": 22,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 56,
        "fullcodeline": "if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||"
    },
    {
        "line": 83,
        "fullcodeline": "if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))"
    },
    {
        "line": 99,
        "fullcodeline": "if (!supported) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)"
    },
    {
        "line": 113,
        "fullcodeline": "if (config->bytes_per_sample == 1)"
    },
    {
        "line": 42,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 58,
        "fullcodeline": "bcount != caf_chunk_header.mChunkSize) {"
    },
    {
        "line": 59,
        "fullcodeline": "error_line (\"%s is not a valid .CAF file!\", infilename);"
    },
    {
        "line": 71,
        "fullcodeline": "char formatstr [5];"
    },
    {
        "line": 73,
        "fullcodeline": "memcpy (formatstr, caf_audio_format.mFormatID, 4);"
    },
    {
        "line": 74,
        "fullcodeline": "formatstr [4] = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "error_line (\"format = %s, flags = %x, sampling rate = %g\","
    },
    {
        "line": 77,
        "fullcodeline": "error_line (\"packet = %d bytes and %d frames\","
    },
    {
        "line": 79,
        "fullcodeline": "error_line (\"channels per frame = %d, bits per channel = %d\","
    },
    {
        "line": 84,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 100,
        "fullcodeline": "error_line (\"%s is an unsupported .CAF format!\", infilename);"
    },
    {
        "line": 111,
        "fullcodeline": "config->qmode |= QMODE_BIG_ENDIAN;"
    },
    {
        "line": 114,
        "fullcodeline": "config->qmode |= QMODE_SIGNED_BYTES;"
    },
    {
        "line": 124,
        "fullcodeline": "else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {"
    },
    {
        "line": 43,
        "fullcodeline": "!WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {"
    },
    {
        "line": 44,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 57,
        "fullcodeline": "!DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||"
    },
    {
        "line": 117,
        "fullcodeline": "if (config->float_norm_exp == 127)"
    },
    {
        "line": 125,
        "fullcodeline": "CAFChannelLayout *caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);"
    },
    {
        "line": 141,
        "fullcodeline": "WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);"
    },
    {
        "line": 142,
        "fullcodeline": "chan_chunk = 1;"
    },
    {
        "line": 294,
        "fullcodeline": "free (caf_channel_layout);"
    },
    {
        "line": 62,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 85,
        "fullcodeline": "else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||"
    },
    {
        "line": 118,
        "fullcodeline": "error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");"
    },
    {
        "line": 127,
        "fullcodeline": "if (caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout) ||"
    },
    {
        "line": 144,
        "fullcodeline": "if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {"
    },
    {
        "line": 63,
        "fullcodeline": "!WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {"
    },
    {
        "line": 64,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 86,
        "fullcodeline": "caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))"
    },
    {
        "line": 87,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 120,
        "fullcodeline": "error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\","
    },
    {
        "line": 129,
        "fullcodeline": "bcount != caf_chunk_header.mChunkSize) {"
    },
    {
        "line": 130,
        "fullcodeline": "error_line (\"%s is not a valid .CAF file!\", infilename);"
    },
    {
        "line": 131,
        "fullcodeline": "free (caf_channel_layout);"
    },
    {
        "line": 145,
        "fullcodeline": "error_line (\"this CAF file already has channel order information!\");"
    },
    {
        "line": 146,
        "fullcodeline": "free (caf_channel_layout);"
    },
    {
        "line": 258,
        "fullcodeline": "config->channel_mask = caf_channel_layout->mChannelBitmap;"
    },
    {
        "line": 296,
        "fullcodeline": "else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop"
    },
    {
        "line": 121,
        "fullcodeline": "config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);"
    },
    {
        "line": 128,
        "fullcodeline": "!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||"
    },
    {
        "line": 153,
        "fullcodeline": "CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);"
    },
    {
        "line": 154,
        "fullcodeline": "int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;"
    },
    {
        "line": 155,
        "fullcodeline": "int label, cindex = 0, idents = 0;"
    },
    {
        "line": 173,
        "fullcodeline": "channel_reorder = malloc (num_descriptions);"
    },
    {
        "line": 174,
        "fullcodeline": "memset (channel_reorder, -1, num_descriptions);"
    },
    {
        "line": 175,
        "fullcodeline": "channel_identities = malloc (num_descriptions+1);"
    },
    {
        "line": 267,
        "fullcodeline": "for (i = 0; i < NUM_LAYOUTS; ++i)"
    },
    {
        "line": 287,
        "fullcodeline": "if (i == NUM_LAYOUTS && debug_logging_mode)"
    },
    {
        "line": 88,
        "fullcodeline": "else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)"
    },
    {
        "line": 134,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 157,
        "fullcodeline": "if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||"
    },
    {
        "line": 164,
        "fullcodeline": "if (num_descriptions >= 256) {"
    },
    {
        "line": 179,
        "fullcodeline": "for (i = 0; i < num_descriptions; ++i) {"
    },
    {
        "line": 188,
        "fullcodeline": "for (label = 1; label <= 18; ++label)"
    },
    {
        "line": 198,
        "fullcodeline": "for (i = 0; i < num_descriptions; ++i)"
    },
    {
        "line": 216,
        "fullcodeline": "for (i = 0; i < num_descriptions; ++i)"
    },
    {
        "line": 220,
        "fullcodeline": "if (i == num_descriptions) {"
    },
    {
        "line": 229,
        "fullcodeline": "if (!idents) {                              // if no non-MS channels, free the identities string"
    },
    {
        "line": 261,
        "fullcodeline": "error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\","
    },
    {
        "line": 268,
        "fullcodeline": "if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {"
    },
    {
        "line": 288,
        "fullcodeline": "error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\","
    },
    {
        "line": 299,
        "fullcodeline": "if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||"
    },
    {
        "line": 310,
        "fullcodeline": "if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {"
    },
    {
        "line": 346,
        "fullcodeline": "int bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;"
    },
    {
        "line": 347,
        "fullcodeline": "char *buff = malloc (bytes_to_copy);"
    },
    {
        "line": 363,
        "fullcodeline": "free (buff);"
    },
    {
        "line": 89,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 135,
        "fullcodeline": "!WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {"
    },
    {
        "line": 136,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 137,
        "fullcodeline": "free (caf_channel_layout);"
    },
    {
        "line": 158,
        "fullcodeline": "num_descriptions != config->num_channels) {"
    },
    {
        "line": 159,
        "fullcodeline": "error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");"
    },
    {
        "line": 160,
        "fullcodeline": "free (caf_channel_layout);"
    },
    {
        "line": 165,
        "fullcodeline": "error_line (\"%d channel descriptions is more than we can handle...ignoring!\");"
    },
    {
        "line": 180,
        "fullcodeline": "WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);"
    },
    {
        "line": 189,
        "fullcodeline": "for (i = 0; i < num_descriptions; ++i)"
    },
    {
        "line": 199,
        "fullcodeline": "if (channel_reorder [i] == (unsigned char) -1) {"
    },
    {
        "line": 217,
        "fullcodeline": "if (channel_reorder [i] != i)"
    },
    {
        "line": 221,
        "fullcodeline": "free (channel_reorder);                 // no reordering required, so don't"
    },
    {
        "line": 222,
        "fullcodeline": "channel_reorder = NULL;"
    },
    {
        "line": 230,
        "fullcodeline": "free (channel_identities);"
    },
    {
        "line": 231,
        "fullcodeline": "channel_identities = NULL;"
    },
    {
        "line": 237,
        "fullcodeline": "error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\","
    },
    {
        "line": 270,
        "fullcodeline": "channel_layout = layouts [i].mChannelLayoutTag;"
    },
    {
        "line": 300,
        "fullcodeline": "bcount != sizeof (mEditCount)) {"
    },
    {
        "line": 301,
        "fullcodeline": "error_line (\"%s is not a valid .CAF file!\", infilename);"
    },
    {
        "line": 311,
        "fullcodeline": "config->qmode |= QMODE_IGNORE_LENGTH;"
    },
    {
        "line": 354,
        "fullcodeline": "if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||"
    },
    {
        "line": 190,
        "fullcodeline": "if (descriptions [i].mChannelLabel == label) {"
    },
    {
        "line": 211,
        "fullcodeline": "channel_reorder [i] = cindex++;"
    },
    {
        "line": 225,
        "fullcodeline": "config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout"
    },
    {
        "line": 226,
        "fullcodeline": "channel_layout = num_descriptions;"
    },
    {
        "line": 234,
        "fullcodeline": "channel_identities [idents] = 0;        // otherwise NULL terminate it"
    },
    {
        "line": 243,
        "fullcodeline": "if (channel_reorder && num_descriptions <= 8) {"
    },
    {
        "line": 313,
        "fullcodeline": "if (infilesize && DoGetFilePosition (infile) != -1)"
    },
    {
        "line": 329,
        "fullcodeline": "total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;"
    },
    {
        "line": 350,
        "fullcodeline": "error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\","
    },
    {
        "line": 356,
        "fullcodeline": "(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 358,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 359,
        "fullcodeline": "free (buff);"
    },
    {
        "line": 90,
        "fullcodeline": "else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||"
    },
    {
        "line": 183,
        "fullcodeline": "error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);"
    },
    {
        "line": 191,
        "fullcodeline": "config->channel_mask |= 1 << (label - 1);"
    },
    {
        "line": 192,
        "fullcodeline": "channel_reorder [i] = cindex++;"
    },
    {
        "line": 202,
        "fullcodeline": "if (clabel == 0 || clabel == 0xffffffff || clabel == 100)"
    },
    {
        "line": 244,
        "fullcodeline": "char reorder_string [] = \"12345678\";"
    },
    {
        "line": 249,
        "fullcodeline": "reorder_string [i] = 0;"
    },
    {
        "line": 250,
        "fullcodeline": "error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);"
    },
    {
        "line": 273,
        "fullcodeline": "channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);"
    },
    {
        "line": 274,
        "fullcodeline": "config->qmode |= QMODE_REORDERED_CHANS;"
    },
    {
        "line": 278,
        "fullcodeline": "channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);"
    },
    {
        "line": 281,
        "fullcodeline": "error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\","
    },
    {
        "line": 304,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 314,
        "fullcodeline": "total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;"
    },
    {
        "line": 319,
        "fullcodeline": "if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {"
    },
    {
        "line": 324,
        "fullcodeline": "if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {"
    },
    {
        "line": 331,
        "fullcodeline": "if (!total_samples) {"
    },
    {
        "line": 336,
        "fullcodeline": "if (total_samples > MAX_WAVPACK_SAMPLES) {"
    },
    {
        "line": 355,
        "fullcodeline": "bcount != bytes_to_copy ||"
    },
    {
        "line": 357,
        "fullcodeline": "!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {"
    },
    {
        "line": 91,
        "fullcodeline": "((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))"
    },
    {
        "line": 92,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 203,
        "fullcodeline": "channel_identities [idents++] = 0xff;"
    },
    {
        "line": 246,
        "fullcodeline": "for (i = 0; i < num_descriptions; ++i)"
    },
    {
        "line": 247,
        "fullcodeline": "reorder_string [i] = channel_reorder [i] + '1';"
    },
    {
        "line": 282,
        "fullcodeline": "channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");"
    },
    {
        "line": 305,
        "fullcodeline": "!WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {"
    },
    {
        "line": 306,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 316,
        "fullcodeline": "total_samples = -1;"
    },
    {
        "line": 320,
        "fullcodeline": "error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);"
    },
    {
        "line": 325,
        "fullcodeline": "error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);"
    },
    {
        "line": 332,
        "fullcodeline": "error_line (\"this .CAF file has no audio samples, probably is corrupt!\");"
    },
    {
        "line": 337,
        "fullcodeline": "error_line (\"%s has too many samples for WavPack!\", infilename);"
    },
    {
        "line": 93,
        "fullcodeline": "else if (caf_audio_format.mFramesPerPacket != 1 ||"
    },
    {
        "line": 204,
        "fullcodeline": "else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))"
    },
    {
        "line": 96,
        "fullcodeline": "caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)"
    },
    {
        "line": 97,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 205,
        "fullcodeline": "channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;"
    },
    {
        "line": 95,
        "fullcodeline": "caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||"
    },
    {
        "line": 207,
        "fullcodeline": "error_line (\"warning: unknown channel descriptions label: %d\", clabel);"
    },
    {
        "line": 208,
        "fullcodeline": "channel_identities [idents++] = 0xff;"
    },
    {
        "line": 94,
        "fullcodeline": "caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||"
    }
]