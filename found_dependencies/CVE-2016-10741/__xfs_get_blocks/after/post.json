[
    {
        "line": 9,
        "fullcodeline": "struct xfs_inode\t*ip = XFS_I(inode);"
    },
    {
        "line": 10,
        "fullcodeline": "struct xfs_mount\t*mp = ip->i_mount;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\t\terror = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\t\tlockmode = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\t\tnimaps = 1;"
    },
    {
        "line": 18,
        "fullcodeline": "int\t\t\tnew = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "bool\t\t\tis_cow = false;"
    },
    {
        "line": 20,
        "fullcodeline": "bool\t\t\tneed_alloc = false;"
    },
    {
        "line": 22,
        "fullcodeline": "BUG_ON(create && !direct);"
    },
    {
        "line": 27,
        "fullcodeline": "offset = (xfs_off_t)iblock << inode->i_blkbits;"
    },
    {
        "line": 28,
        "fullcodeline": "ASSERT(bh_result->b_size >= (1 << inode->i_blkbits));"
    },
    {
        "line": 29,
        "fullcodeline": "size = bh_result->b_size;"
    },
    {
        "line": 38,
        "fullcodeline": "lockmode = xfs_ilock_data_map_shared(ip);"
    },
    {
        "line": 40,
        "fullcodeline": "ASSERT(offset <= mp->m_super->s_maxbytes);"
    },
    {
        "line": 43,
        "fullcodeline": "end_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + size);"
    },
    {
        "line": 44,
        "fullcodeline": "offset_fsb = XFS_B_TO_FSBT(mp, offset);"
    },
    {
        "line": 65,
        "fullcodeline": "ASSERT(!need_alloc);"
    },
    {
        "line": 128,
        "fullcodeline": "xfs_map_trim_size(inode, iblock, bh_result, &imap, offset, size);"
    },
    {
        "line": 161,
        "fullcodeline": "bh_result->b_bdev = xfs_find_bdev_for_inode(inode);"
    },
    {
        "line": 181,
        "fullcodeline": "xfs_iunlock(ip, lockmode);"
    },
    {
        "line": 24,
        "fullcodeline": "if (XFS_FORCED_SHUTDOWN(mp))"
    },
    {
        "line": 31,
        "fullcodeline": "if (!create && offset >= i_size_read(inode))"
    },
    {
        "line": 41,
        "fullcodeline": "if (offset + size > mp->m_super->s_maxbytes)"
    },
    {
        "line": 46,
        "fullcodeline": "if (create && direct && xfs_is_reflink_inode(ip))"
    },
    {
        "line": 49,
        "fullcodeline": "if (!is_cow) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (direct && imap.br_startblock == DELAYSTARTBLOCK) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (create &&"
    },
    {
        "line": 121,
        "fullcodeline": "if (IS_DAX(inode) && create) {"
    },
    {
        "line": 134,
        "fullcodeline": "if (imap.br_startblock != HOLESTARTBLOCK &&"
    },
    {
        "line": 172,
        "fullcodeline": "if (create &&"
    },
    {
        "line": 42,
        "fullcodeline": "size = mp->m_super->s_maxbytes - offset;"
    },
    {
        "line": 47,
        "fullcodeline": "is_cow = xfs_reflink_find_cow_mapping(ip, offset, &imap,"
    },
    {
        "line": 50,
        "fullcodeline": "error = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,"
    },
    {
        "line": 86,
        "fullcodeline": "WARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));"
    },
    {
        "line": 91,
        "fullcodeline": "(!nimaps ||"
    },
    {
        "line": 102,
        "fullcodeline": "error = xfs_iomap_write_direct(ip, offset, size,"
    },
    {
        "line": 106,
        "fullcodeline": "new = 1;"
    },
    {
        "line": 108,
        "fullcodeline": "trace_xfs_get_blocks_alloc(ip, offset, size,"
    },
    {
        "line": 122,
        "fullcodeline": "ASSERT(!ISUNWRITTEN(&imap));"
    },
    {
        "line": 124,
        "fullcodeline": "new = 0;"
    },
    {
        "line": 136,
        "fullcodeline": "(create || !ISUNWRITTEN(&imap))) {"
    },
    {
        "line": 144,
        "fullcodeline": "xfs_map_buffer(inode, bh_result, &imap, offset);"
    },
    {
        "line": 173,
        "fullcodeline": "((!buffer_mapped(bh_result) && !buffer_uptodate(bh_result)) ||"
    },
    {
        "line": 176,
        "fullcodeline": "set_buffer_new(bh_result);"
    },
    {
        "line": 25,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 58,
        "fullcodeline": "if (create && direct && nimaps &&"
    },
    {
        "line": 81,
        "fullcodeline": "if (!create || offset < i_size_read(VFS_I(ip))) {"
    },
    {
        "line": 94,
        "fullcodeline": "(IS_DAX(inode) && ISUNWRITTEN(&imap)))) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (lockmode == XFS_ILOCK_EXCL)"
    },
    {
        "line": 109,
        "fullcodeline": "ISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN"
    },
    {
        "line": 135,
        "fullcodeline": "imap.br_startblock != DELAYSTARTBLOCK &&"
    },
    {
        "line": 137,
        "fullcodeline": "if (create && direct && !is_cow) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (ISUNWRITTEN(&imap))"
    },
    {
        "line": 175,
        "fullcodeline": "(new || ISUNWRITTEN(&imap))))"
    },
    {
        "line": 61,
        "fullcodeline": "!ISUNWRITTEN(&imap))"
    },
    {
        "line": 62,
        "fullcodeline": "xfs_reflink_trim_irec_to_next_cow(ip, offset_fsb,"
    },
    {
        "line": 82,
        "fullcodeline": "WARN_ON_ONCE(1);"
    },
    {
        "line": 83,
        "fullcodeline": "error = -EIO;"
    },
    {
        "line": 92,
        "fullcodeline": "(imap.br_startblock == HOLESTARTBLOCK ||"
    },
    {
        "line": 100,
        "fullcodeline": "xfs_ilock_demote(ip, lockmode);"
    },
    {
        "line": 138,
        "fullcodeline": "error = xfs_bounce_unaligned_dio_write(ip, offset_fsb,"
    },
    {
        "line": 146,
        "fullcodeline": "set_buffer_unwritten(bh_result);"
    },
    {
        "line": 174,
        "fullcodeline": "(offset >= i_size_read(inode)) ||"
    },
    {
        "line": 60,
        "fullcodeline": "imap.br_startblock != DELAYSTARTBLOCK &&"
    },
    {
        "line": 93,
        "fullcodeline": "imap.br_startblock == DELAYSTARTBLOCK) ||"
    },
    {
        "line": 112,
        "fullcodeline": "trace_xfs_get_blocks_found(ip, offset, size,"
    },
    {
        "line": 115,
        "fullcodeline": "xfs_iunlock(ip, lockmode);"
    },
    {
        "line": 59,
        "fullcodeline": "imap.br_startblock != HOLESTARTBLOCK &&"
    },
    {
        "line": 113,
        "fullcodeline": "ISUNWRITTEN(&imap) ? XFS_IO_UNWRITTEN"
    },
    {
        "line": 117,
        "fullcodeline": "trace_xfs_get_blocks_notfound(ip, offset, size);"
    },
    {
        "line": 150,
        "fullcodeline": "ASSERT(!ISUNWRITTEN(&imap));"
    },
    {
        "line": 152,
        "fullcodeline": "xfs_map_direct(inode, bh_result, &imap, offset,"
    }
]