[
    {
        "line": 7,
        "fullcodeline": "int\t\tevaluate = evalarg != NULL"
    },
    {
        "line": 11,
        "fullcodeline": "char_u\t*name_start = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tret = OK;"
    },
    {
        "line": 15,
        "fullcodeline": "static\tint recurse = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "rettv->v_type = VAR_UNKNOWN;"
    },
    {
        "line": 26,
        "fullcodeline": "start_leader = *arg;"
    },
    {
        "line": 29,
        "fullcodeline": "end_leader = *arg;"
    },
    {
        "line": 49,
        "fullcodeline": "++recurse;"
    },
    {
        "line": 27,
        "fullcodeline": "if (eval_leader(arg, in_vim9script()) == FAIL)"
    },
    {
        "line": 44,
        "fullcodeline": "if (recurse == 1000)"
    },
    {
        "line": 200,
        "fullcodeline": "if (ret == NOTDONE)"
    },
    {
        "line": 272,
        "fullcodeline": "if (ret == OK)"
    },
    {
        "line": 8,
        "fullcodeline": "&& (evalarg->eval_flags & EVAL_EVALUATE);"
    },
    {
        "line": 31,
        "fullcodeline": "if (**arg == '.' && (!isdigit(*(*arg + 1))"
    },
    {
        "line": 37,
        "fullcodeline": "semsg(_(e_invalid_expression_str), *arg);"
    },
    {
        "line": 66,
        "fullcodeline": "case '.':\tret = eval_number(arg, rettv, evaluate, want_string);"
    },
    {
        "line": 78,
        "fullcodeline": "case '\"':\tret = eval_string(arg, rettv, evaluate);"
    },
    {
        "line": 84,
        "fullcodeline": "case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);"
    },
    {
        "line": 90,
        "fullcodeline": "case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);"
    },
    {
        "line": 124,
        "fullcodeline": "case '&':\tret = eval_option(arg, rettv, evaluate);"
    },
    {
        "line": 130,
        "fullcodeline": "case '$':\tret = eval_env_var(arg, rettv, evaluate);"
    },
    {
        "line": 136,
        "fullcodeline": "case '@':\t++*arg;"
    },
    {
        "line": 158,
        "fullcodeline": "case '(':\tret = NOTDONE;"
    },
    {
        "line": 196,
        "fullcodeline": "default:\tret = NOTDONE;"
    },
    {
        "line": 206,
        "fullcodeline": "s = *arg;"
    },
    {
        "line": 207,
        "fullcodeline": "len = get_name_len(arg, &alias, evaluate, TRUE);"
    },
    {
        "line": 273,
        "fullcodeline": "ret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);"
    },
    {
        "line": 278,
        "fullcodeline": "if (ret == OK && evaluate && end_leader > start_leader)"
    },
    {
        "line": 279,
        "fullcodeline": "ret = eval7_leader(rettv, FALSE, start_leader, &end_leader);"
    },
    {
        "line": 46,
        "fullcodeline": "semsg(_(e_expression_too_recursive_str), *arg);"
    },
    {
        "line": 96,
        "fullcodeline": "case '#':\tif (in_vim9script())"
    },
    {
        "line": 113,
        "fullcodeline": "case '{':\tif (in_vim9script())"
    },
    {
        "line": 117,
        "fullcodeline": "if (ret == NOTDONE)"
    },
    {
        "line": 150,
        "fullcodeline": "if (**arg != NUL)"
    },
    {
        "line": 159,
        "fullcodeline": "if (in_vim9script())"
    },
    {
        "line": 179,
        "fullcodeline": "if (ret == NOTDONE)"
    },
    {
        "line": 208,
        "fullcodeline": "if (alias != NULL)"
    },
    {
        "line": 211,
        "fullcodeline": "if (len <= 0)"
    },
    {
        "line": 70,
        "fullcodeline": "if (ret == OK && evaluate && end_leader > start_leader"
    },
    {
        "line": 71,
        "fullcodeline": "&& rettv->v_type != VAR_BLOB)"
    },
    {
        "line": 72,
        "fullcodeline": "ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);"
    },
    {
        "line": 98,
        "fullcodeline": "ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;"
    },
    {
        "line": 114,
        "fullcodeline": "ret = NOTDONE;"
    },
    {
        "line": 118,
        "fullcodeline": "ret = eval_dict(arg, rettv, evalarg, FALSE);"
    },
    {
        "line": 151,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 161,
        "fullcodeline": "ret = get_lambda_tv(arg, rettv, TRUE, evalarg);"
    },
    {
        "line": 181,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg + 1, evalarg);"
    },
    {
        "line": 182,
        "fullcodeline": "ret = eval1(arg, rettv, evalarg);\t// recursive!"
    },
    {
        "line": 184,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 209,
        "fullcodeline": "s = alias;"
    },
    {
        "line": 212,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 116,
        "fullcodeline": "ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);"
    },
    {
        "line": 139,
        "fullcodeline": "if (in_vim9script() && IS_WHITE_OR_NUL(**arg))"
    },
    {
        "line": 162,
        "fullcodeline": "if (ret == OK && evaluate)"
    },
    {
        "line": 185,
        "fullcodeline": "if (**arg == ')')"
    },
    {
        "line": 215,
        "fullcodeline": "int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;"
    },
    {
        "line": 100,
        "fullcodeline": "else if ((*arg)[1] == '{')"
    },
    {
        "line": 140,
        "fullcodeline": "semsg(_(e_syntax_error_at_str), *arg);"
    },
    {
        "line": 164,
        "fullcodeline": "ufunc_T *ufunc = rettv->vval.v_partial->pt_func;"
    },
    {
        "line": 186,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 102,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 103,
        "fullcodeline": "ret = eval_dict(arg, rettv, evalarg, TRUE);"
    },
    {
        "line": 169,
        "fullcodeline": "if (ufunc->uf_ret_type->tt_type == VAR_VOID)"
    },
    {
        "line": 171,
        "fullcodeline": "if (compile_def_function(ufunc,"
    },
    {
        "line": 217,
        "fullcodeline": "if (evaluate && in_vim9script() && len == 1 && *s == '_')"
    },
    {
        "line": 220,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 106,
        "fullcodeline": "ret = NOTDONE;"
    },
    {
        "line": 141,
        "fullcodeline": "else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))"
    },
    {
        "line": 170,
        "fullcodeline": "ufunc->uf_ret_type = &t_unknown;"
    },
    {
        "line": 174,
        "fullcodeline": "clear_tv(rettv);"
    },
    {
        "line": 175,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 187,
        "fullcodeline": "else if (ret == OK)"
    },
    {
        "line": 219,
        "fullcodeline": "emsg(_(e_cannot_use_underscore_here));"
    },
    {
        "line": 142,
        "fullcodeline": "emsg_invreg(**arg);"
    },
    {
        "line": 172,
        "fullcodeline": "FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)"
    },
    {
        "line": 190,
        "fullcodeline": "clear_tv(rettv);"
    },
    {
        "line": 191,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 145,
        "fullcodeline": "rettv->v_type = VAR_STRING;"
    },
    {
        "line": 189,
        "fullcodeline": "emsg(_(e_missing_closing_paren));"
    },
    {
        "line": 225,
        "fullcodeline": "*arg = skipwhite(*arg);"
    },
    {
        "line": 226,
        "fullcodeline": "ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);"
    },
    {
        "line": 146,
        "fullcodeline": "rettv->vval.v_string = get_reg_contents(**arg,"
    },
    {
        "line": 222,
        "fullcodeline": "else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')"
    },
    {
        "line": 228,
        "fullcodeline": "else if (flags & EVAL_CONSTANT)"
    },
    {
        "line": 229,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 264,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 233,
        "fullcodeline": "if (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)"
    },
    {
        "line": 235,
        "fullcodeline": "rettv->v_type = VAR_BOOL;"
    },
    {
        "line": 236,
        "fullcodeline": "rettv->vval.v_number = VVAL_TRUE;"
    },
    {
        "line": 237,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 239,
        "fullcodeline": "else if (len == 5 && in_vim9script()"
    },
    {
        "line": 240,
        "fullcodeline": "&& STRNCMP(s, \"false\", 5) == 0)"
    },
    {
        "line": 242,
        "fullcodeline": "rettv->v_type = VAR_BOOL;"
    },
    {
        "line": 243,
        "fullcodeline": "rettv->vval.v_number = VVAL_FALSE;"
    },
    {
        "line": 244,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 246,
        "fullcodeline": "else if (len == 4 && in_vim9script()"
    },
    {
        "line": 247,
        "fullcodeline": "&& STRNCMP(s, \"null\", 4) == 0)"
    },
    {
        "line": 249,
        "fullcodeline": "rettv->v_type = VAR_SPECIAL;"
    },
    {
        "line": 250,
        "fullcodeline": "rettv->vval.v_number = VVAL_NULL;"
    },
    {
        "line": 251,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 255,
        "fullcodeline": "name_start = s;"
    },
    {
        "line": 256,
        "fullcodeline": "ret = eval_variable(s, len, 0, rettv, NULL,"
    },
    {
        "line": 257,
        "fullcodeline": "EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);"
    }
]