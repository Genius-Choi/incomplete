[
    {
        "line": 7,
        "fullcodeline": "int\t\tevaluate = evalarg != NULL"
    },
    {
        "line": 11,
        "fullcodeline": "char_u\t*name_start = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tret = OK;"
    },
    {
        "line": 20,
        "fullcodeline": "rettv->v_type = VAR_UNKNOWN;"
    },
    {
        "line": 25,
        "fullcodeline": "start_leader = *arg;"
    },
    {
        "line": 28,
        "fullcodeline": "end_leader = *arg;"
    },
    {
        "line": 26,
        "fullcodeline": "if (eval_leader(arg, in_vim9script()) == FAIL)"
    },
    {
        "line": 190,
        "fullcodeline": "if (ret == NOTDONE)"
    },
    {
        "line": 262,
        "fullcodeline": "if (ret == OK)"
    },
    {
        "line": 8,
        "fullcodeline": "&& (evalarg->eval_flags & EVAL_EVALUATE);"
    },
    {
        "line": 30,
        "fullcodeline": "if (**arg == '.' && (!isdigit(*(*arg + 1))"
    },
    {
        "line": 36,
        "fullcodeline": "semsg(_(e_invalid_expression_str), *arg);"
    },
    {
        "line": 56,
        "fullcodeline": "case '.':\tret = eval_number(arg, rettv, evaluate, want_string);"
    },
    {
        "line": 68,
        "fullcodeline": "case '\"':\tret = eval_string(arg, rettv, evaluate);"
    },
    {
        "line": 74,
        "fullcodeline": "case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);"
    },
    {
        "line": 80,
        "fullcodeline": "case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);"
    },
    {
        "line": 114,
        "fullcodeline": "case '&':\tret = eval_option(arg, rettv, evaluate);"
    },
    {
        "line": 120,
        "fullcodeline": "case '$':\tret = eval_env_var(arg, rettv, evaluate);"
    },
    {
        "line": 126,
        "fullcodeline": "case '@':\t++*arg;"
    },
    {
        "line": 148,
        "fullcodeline": "case '(':\tret = NOTDONE;"
    },
    {
        "line": 186,
        "fullcodeline": "default:\tret = NOTDONE;"
    },
    {
        "line": 196,
        "fullcodeline": "s = *arg;"
    },
    {
        "line": 197,
        "fullcodeline": "len = get_name_len(arg, &alias, evaluate, TRUE);"
    },
    {
        "line": 263,
        "fullcodeline": "ret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);"
    },
    {
        "line": 268,
        "fullcodeline": "if (ret == OK && evaluate && end_leader > start_leader)"
    },
    {
        "line": 269,
        "fullcodeline": "ret = eval7_leader(rettv, FALSE, start_leader, &end_leader);"
    },
    {
        "line": 86,
        "fullcodeline": "case '#':\tif (in_vim9script())"
    },
    {
        "line": 103,
        "fullcodeline": "case '{':\tif (in_vim9script())"
    },
    {
        "line": 107,
        "fullcodeline": "if (ret == NOTDONE)"
    },
    {
        "line": 140,
        "fullcodeline": "if (**arg != NUL)"
    },
    {
        "line": 149,
        "fullcodeline": "if (in_vim9script())"
    },
    {
        "line": 169,
        "fullcodeline": "if (ret == NOTDONE)"
    },
    {
        "line": 198,
        "fullcodeline": "if (alias != NULL)"
    },
    {
        "line": 201,
        "fullcodeline": "if (len <= 0)"
    },
    {
        "line": 60,
        "fullcodeline": "if (ret == OK && evaluate && end_leader > start_leader"
    },
    {
        "line": 61,
        "fullcodeline": "&& rettv->v_type != VAR_BLOB)"
    },
    {
        "line": 62,
        "fullcodeline": "ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);"
    },
    {
        "line": 88,
        "fullcodeline": "ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;"
    },
    {
        "line": 104,
        "fullcodeline": "ret = NOTDONE;"
    },
    {
        "line": 108,
        "fullcodeline": "ret = eval_dict(arg, rettv, evalarg, FALSE);"
    },
    {
        "line": 141,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 151,
        "fullcodeline": "ret = get_lambda_tv(arg, rettv, TRUE, evalarg);"
    },
    {
        "line": 171,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg + 1, evalarg);"
    },
    {
        "line": 172,
        "fullcodeline": "ret = eval1(arg, rettv, evalarg);\t// recursive!"
    },
    {
        "line": 174,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 199,
        "fullcodeline": "s = alias;"
    },
    {
        "line": 202,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 106,
        "fullcodeline": "ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);"
    },
    {
        "line": 129,
        "fullcodeline": "if (in_vim9script() && IS_WHITE_OR_NUL(**arg))"
    },
    {
        "line": 152,
        "fullcodeline": "if (ret == OK && evaluate)"
    },
    {
        "line": 175,
        "fullcodeline": "if (**arg == ')')"
    },
    {
        "line": 205,
        "fullcodeline": "int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;"
    },
    {
        "line": 90,
        "fullcodeline": "else if ((*arg)[1] == '{')"
    },
    {
        "line": 130,
        "fullcodeline": "semsg(_(e_syntax_error_at_str), *arg);"
    },
    {
        "line": 154,
        "fullcodeline": "ufunc_T *ufunc = rettv->vval.v_partial->pt_func;"
    },
    {
        "line": 176,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 92,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 93,
        "fullcodeline": "ret = eval_dict(arg, rettv, evalarg, TRUE);"
    },
    {
        "line": 159,
        "fullcodeline": "if (ufunc->uf_ret_type->tt_type == VAR_VOID)"
    },
    {
        "line": 161,
        "fullcodeline": "if (compile_def_function(ufunc,"
    },
    {
        "line": 207,
        "fullcodeline": "if (evaluate && in_vim9script() && len == 1 && *s == '_')"
    },
    {
        "line": 210,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 96,
        "fullcodeline": "ret = NOTDONE;"
    },
    {
        "line": 131,
        "fullcodeline": "else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))"
    },
    {
        "line": 160,
        "fullcodeline": "ufunc->uf_ret_type = &t_unknown;"
    },
    {
        "line": 164,
        "fullcodeline": "clear_tv(rettv);"
    },
    {
        "line": 165,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 177,
        "fullcodeline": "else if (ret == OK)"
    },
    {
        "line": 209,
        "fullcodeline": "emsg(_(e_cannot_use_underscore_here));"
    },
    {
        "line": 132,
        "fullcodeline": "emsg_invreg(**arg);"
    },
    {
        "line": 162,
        "fullcodeline": "FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)"
    },
    {
        "line": 180,
        "fullcodeline": "clear_tv(rettv);"
    },
    {
        "line": 181,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 135,
        "fullcodeline": "rettv->v_type = VAR_STRING;"
    },
    {
        "line": 179,
        "fullcodeline": "emsg(_(e_missing_closing_paren));"
    },
    {
        "line": 215,
        "fullcodeline": "*arg = skipwhite(*arg);"
    },
    {
        "line": 216,
        "fullcodeline": "ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);"
    },
    {
        "line": 136,
        "fullcodeline": "rettv->vval.v_string = get_reg_contents(**arg,"
    },
    {
        "line": 212,
        "fullcodeline": "else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')"
    },
    {
        "line": 218,
        "fullcodeline": "else if (flags & EVAL_CONSTANT)"
    },
    {
        "line": 219,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 254,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 223,
        "fullcodeline": "if (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)"
    },
    {
        "line": 225,
        "fullcodeline": "rettv->v_type = VAR_BOOL;"
    },
    {
        "line": 226,
        "fullcodeline": "rettv->vval.v_number = VVAL_TRUE;"
    },
    {
        "line": 227,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 229,
        "fullcodeline": "else if (len == 5 && in_vim9script()"
    },
    {
        "line": 230,
        "fullcodeline": "&& STRNCMP(s, \"false\", 5) == 0)"
    },
    {
        "line": 232,
        "fullcodeline": "rettv->v_type = VAR_BOOL;"
    },
    {
        "line": 233,
        "fullcodeline": "rettv->vval.v_number = VVAL_FALSE;"
    },
    {
        "line": 234,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 236,
        "fullcodeline": "else if (len == 4 && in_vim9script()"
    },
    {
        "line": 237,
        "fullcodeline": "&& STRNCMP(s, \"null\", 4) == 0)"
    },
    {
        "line": 239,
        "fullcodeline": "rettv->v_type = VAR_SPECIAL;"
    },
    {
        "line": 240,
        "fullcodeline": "rettv->vval.v_number = VVAL_NULL;"
    },
    {
        "line": 241,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 245,
        "fullcodeline": "name_start = s;"
    },
    {
        "line": 246,
        "fullcodeline": "ret = eval_variable(s, len, 0, rettv, NULL,"
    },
    {
        "line": 247,
        "fullcodeline": "EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);"
    }
]