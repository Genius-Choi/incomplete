[
    {
        "line": 10,
        "fullcodeline": "Runtime::Module* module = nullptr;"
    },
    {
        "line": 36,
        "fullcodeline": "Compartment* compartment = Runtime::createCompartment();"
    },
    {
        "line": 37,
        "fullcodeline": "Context* context = Runtime::createContext(compartment);"
    },
    {
        "line": 38,
        "fullcodeline": "RootResolver rootResolver(compartment);"
    },
    {
        "line": 40,
        "fullcodeline": "Emscripten::Instance* emscriptenInstance = nullptr;"
    },
    {
        "line": 58,
        "fullcodeline": "LinkResult linkResult = linkModule(irModule, rootResolver);"
    },
    {
        "line": 74,
        "fullcodeline": "ModuleInstance* moduleInstance = instantiateModule("
    },
    {
        "line": 79,
        "fullcodeline": "FunctionInstance* startFunction = getStartFunction(moduleInstance);"
    },
    {
        "line": 111,
        "fullcodeline": "FunctionType functionType = getFunctionType(functionInstance);"
    },
    {
        "line": 114,
        "fullcodeline": "std::vector<Value> invokeArgs;"
    },
    {
        "line": 170,
        "fullcodeline": "IR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);"
    },
    {
        "line": 171,
        "fullcodeline": "Timing::logTimer(\"Invoked function\", executionTimer);"
    },
    {
        "line": 6,
        "fullcodeline": "if(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }"
    },
    {
        "line": 11,
        "fullcodeline": "if(!options.precompiled) { module = Runtime::compileModule(irModule); }"
    },
    {
        "line": 59,
        "fullcodeline": "if(!linkResult.success)"
    },
    {
        "line": 76,
        "fullcodeline": "if(!moduleInstance) { return EXIT_FAILURE; }"
    },
    {
        "line": 90,
        "fullcodeline": "if(!options.functionName)"
    },
    {
        "line": 115,
        "fullcodeline": "if(!options.functionName)"
    },
    {
        "line": 43,
        "fullcodeline": "emscriptenInstance = Emscripten::instantiate(compartment, irModule);"
    },
    {
        "line": 54,
        "fullcodeline": "ModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);"
    },
    {
        "line": 55,
        "fullcodeline": "rootResolver.moduleNameToInstanceMap.set(\"threadTest\", threadTestInstance);"
    },
    {
        "line": 61,
        "fullcodeline": "Log::printf(Log::error, \"Failed to link module:\\n\");"
    },
    {
        "line": 75,
        "fullcodeline": "compartment, module, std::move(linkResult.resolvedImports), options.filename);"
    },
    {
        "line": 80,
        "fullcodeline": "if(startFunction) { invokeFunctionChecked(context, startFunction, {}); }"
    },
    {
        "line": 85,
        "fullcodeline": "Emscripten::initializeGlobals(context, irModule, moduleInstance);"
    },
    {
        "line": 92,
        "fullcodeline": "functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"main\"));"
    },
    {
        "line": 175,
        "fullcodeline": "Log::printf(Log::debug,"
    },
    {
        "line": 14,
        "fullcodeline": "const UserSection* precompiledObjectSection = nullptr;"
    },
    {
        "line": 93,
        "fullcodeline": "if(!functionInstance)"
    },
    {
        "line": 95,
        "fullcodeline": "if(!functionInstance)"
    },
    {
        "line": 103,
        "fullcodeline": "functionInstance"
    },
    {
        "line": 117,
        "fullcodeline": "if(functionType.params().size() == 2)"
    },
    {
        "line": 178,
        "fullcodeline": "asString(functionResults).c_str());"
    },
    {
        "line": 24,
        "fullcodeline": "if(!precompiledObjectSection)"
    },
    {
        "line": 46,
        "fullcodeline": "rootResolver.moduleNameToInstanceMap.set(\"env\", emscriptenInstance->env);"
    },
    {
        "line": 47,
        "fullcodeline": "rootResolver.moduleNameToInstanceMap.set(\"asm2wasm\", emscriptenInstance->asm2wasm);"
    },
    {
        "line": 48,
        "fullcodeline": "rootResolver.moduleNameToInstanceMap.set(\"global\", emscriptenInstance->global);"
    },
    {
        "line": 64,
        "fullcodeline": "Log::printf(Log::error,"
    },
    {
        "line": 94,
        "fullcodeline": "{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, \"_main\")); }"
    },
    {
        "line": 97,
        "fullcodeline": "Log::printf(Log::error, \"Module does not export main function\\n\");"
    },
    {
        "line": 104,
        "fullcodeline": "= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));"
    },
    {
        "line": 105,
        "fullcodeline": "if(!functionInstance)"
    },
    {
        "line": 148,
        "fullcodeline": "for(U32 i = 0; options.args[i]; ++i)"
    },
    {
        "line": 181,
        "fullcodeline": "else if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)"
    },
    {
        "line": 26,
        "fullcodeline": "Log::printf(Log::error, \"Input file did not contain 'wavm.precompiled_object' section\");"
    },
    {
        "line": 68,
        "fullcodeline": "asString(missingImport.type).c_str());"
    },
    {
        "line": 107,
        "fullcodeline": "Log::printf(Log::error, \"Module does not export '%s'\\n\", options.functionName);"
    },
    {
        "line": 119,
        "fullcodeline": "if(!emscriptenInstance)"
    },
    {
        "line": 164,
        "fullcodeline": "invokeArgs.push_back(value);"
    },
    {
        "line": 17,
        "fullcodeline": "if(userSection.name == \"wavm.precompiled_object\")"
    },
    {
        "line": 31,
        "fullcodeline": "module = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);"
    },
    {
        "line": 121,
        "fullcodeline": "Log::printf("
    },
    {
        "line": 137,
        "fullcodeline": "else if(functionType.params().size() > 0)"
    },
    {
        "line": 19,
        "fullcodeline": "precompiledObjectSection = &userSection;"
    },
    {
        "line": 129,
        "fullcodeline": "argStrings.push_back(options.filename);"
    },
    {
        "line": 130,
        "fullcodeline": "char** args = options.args;"
    },
    {
        "line": 133,
        "fullcodeline": "wavmAssert(emscriptenInstance);"
    },
    {
        "line": 134,
        "fullcodeline": "Emscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);"
    },
    {
        "line": 151,
        "fullcodeline": "switch(functionType.params()[i])"
    },
    {
        "line": 153,
        "fullcodeline": "case ValueType::i32: value = (U32)atoi(options.args[i]); break;"
    },
    {
        "line": 154,
        "fullcodeline": "case ValueType::i64: value = (U64)atol(options.args[i]); break;"
    },
    {
        "line": 155,
        "fullcodeline": "case ValueType::f32: value = (F32)atof(options.args[i]); break;"
    },
    {
        "line": 156,
        "fullcodeline": "case ValueType::f64: value = atof(options.args[i]); break;"
    },
    {
        "line": 160,
        "fullcodeline": "Errors::fatalf(\"Cannot parse command-line argument for %s function parameter\","
    },
    {
        "line": 162,
        "fullcodeline": "default: Errors::unreachable();"
    },
    {
        "line": 131,
        "fullcodeline": "while(*args) { argStrings.push_back(*args++); };"
    },
    {
        "line": 161,
        "fullcodeline": "asString(functionType.params()[i]));"
    }
]