[
    {
        "line": 3,
        "fullcodeline": "m_all_images.clear();"
    },
    {
        "line": 4,
        "fullcodeline": "m_top_level_images.clear();"
    },
    {
        "line": 5,
        "fullcodeline": "m_primary_image.reset();"
    },
    {
        "line": 10,
        "fullcodeline": "std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();"
    },
    {
        "line": 12,
        "fullcodeline": "bool primary_is_grid = false;"
    },
    {
        "line": 46,
        "fullcodeline": "auto iref_box = m_heif_file->get_iref_box();"
    },
    {
        "line": 37,
        "fullcodeline": "if (!m_primary_image) {"
    },
    {
        "line": 14,
        "fullcodeline": "auto infe_box = m_heif_file->get_infe_box(id);"
    },
    {
        "line": 187,
        "fullcodeline": "auto& image = pair.second;"
    },
    {
        "line": 207,
        "fullcodeline": "auto& image = pair.second;"
    },
    {
        "line": 209,
        "fullcodeline": "std::vector<Box_ipco::Property> properties;"
    },
    {
        "line": 211,
        "fullcodeline": "Error err = m_heif_file->get_properties(pair.first, properties);"
    },
    {
        "line": 217,
        "fullcodeline": "bool primary_colr_set = false;"
    },
    {
        "line": 288,
        "fullcodeline": "std::string item_type    = m_heif_file->get_item_type(id);"
    },
    {
        "line": 289,
        "fullcodeline": "std::string content_type = m_heif_file->get_content_type(id);"
    },
    {
        "line": 15,
        "fullcodeline": "if (!infe_box) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (item_type_is_image(infe_box->get_item_type())) {"
    },
    {
        "line": 38,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 189,
        "fullcodeline": "std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());"
    },
    {
        "line": 21,
        "fullcodeline": "auto image = std::make_shared<Image>(this, id);"
    },
    {
        "line": 22,
        "fullcodeline": "m_all_images.insert(std::make_pair(id, image));"
    },
    {
        "line": 51,
        "fullcodeline": "auto& image = pair.second;"
    },
    {
        "line": 190,
        "fullcodeline": "if (infe->get_item_type() == \"hvc1\") {"
    },
    {
        "line": 192,
        "fullcodeline": "auto ipma = m_heif_file->get_ipma_box();"
    },
    {
        "line": 193,
        "fullcodeline": "auto ipco = m_heif_file->get_ipco_box();"
    },
    {
        "line": 219,
        "fullcodeline": "auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);"
    },
    {
        "line": 261,
        "fullcodeline": "auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);"
    },
    {
        "line": 290,
        "fullcodeline": "if (item_type == \"Exif\" ||"
    },
    {
        "line": 291,
        "fullcodeline": "(item_type==\"mime\" && content_type==\"application/rdf+xml\")) {"
    },
    {
        "line": 293,
        "fullcodeline": "metadata->item_id = id;"
    },
    {
        "line": 294,
        "fullcodeline": "metadata->item_type = item_type;"
    },
    {
        "line": 295,
        "fullcodeline": "metadata->content_type = content_type;"
    },
    {
        "line": 297,
        "fullcodeline": "Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));"
    },
    {
        "line": 24,
        "fullcodeline": "if (!infe_box->is_hidden_item()) {"
    },
    {
        "line": 53,
        "fullcodeline": "std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());"
    },
    {
        "line": 292,
        "fullcodeline": "std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();"
    },
    {
        "line": 31,
        "fullcodeline": "m_top_level_images.push_back(image);"
    },
    {
        "line": 56,
        "fullcodeline": "uint32_t type = ref.header.get_short_type();"
    },
    {
        "line": 195,
        "fullcodeline": "if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {"
    },
    {
        "line": 221,
        "fullcodeline": "uint32_t width = ispe->get_width();"
    },
    {
        "line": 222,
        "fullcodeline": "uint32_t height = ispe->get_height();"
    },
    {
        "line": 238,
        "fullcodeline": "image->set_resolution(width, height);"
    },
    {
        "line": 239,
        "fullcodeline": "image->set_ispe_resolution(width, height);"
    },
    {
        "line": 244,
        "fullcodeline": "auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);"
    },
    {
        "line": 250,
        "fullcodeline": "auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);"
    },
    {
        "line": 263,
        "fullcodeline": "auto profile = colr->get_color_profile();"
    },
    {
        "line": 265,
        "fullcodeline": "image->set_color_profile(profile);"
    },
    {
        "line": 272,
        "fullcodeline": "const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();"
    },
    {
        "line": 25,
        "fullcodeline": "if (id==m_heif_file->get_primary_image_ID()) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (type==fourcc(\"thmb\")) {"
    },
    {
        "line": 196,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 308,
        "fullcodeline": "std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);"
    },
    {
        "line": 26,
        "fullcodeline": "image->set_primary(true);"
    },
    {
        "line": 27,
        "fullcodeline": "m_primary_image = image;"
    },
    {
        "line": 28,
        "fullcodeline": "primary_is_grid = infe_box->get_item_type() == \"grid\";"
    },
    {
        "line": 68,
        "fullcodeline": "image->set_is_thumbnail_of(refs[0]);"
    },
    {
        "line": 70,
        "fullcodeline": "auto master_iter = m_all_images.find(refs[0]);"
    },
    {
        "line": 88,
        "fullcodeline": "master_iter->second->add_thumbnail(image);"
    },
    {
        "line": 90,
        "fullcodeline": "remove_top_level_image(image);"
    },
    {
        "line": 227,
        "fullcodeline": "if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||"
    },
    {
        "line": 228,
        "fullcodeline": "height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {"
    },
    {
        "line": 246,
        "fullcodeline": "image->set_resolution( clap->get_width_rounded(),"
    },
    {
        "line": 274,
        "fullcodeline": "if (primary_is_grid &&"
    },
    {
        "line": 278,
        "fullcodeline": "primary_colr_set = true;"
    },
    {
        "line": 61,
        "fullcodeline": "std::vector<heif_item_id> refs = ref.to_item_ID;"
    },
    {
        "line": 71,
        "fullcodeline": "if (master_iter == m_all_images.end()) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (master_iter->second->is_thumbnail()) {"
    },
    {
        "line": 230,
        "fullcodeline": "sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \""
    },
    {
        "line": 233,
        "fullcodeline": "return Error(heif_error_Memory_allocation_error,"
    },
    {
        "line": 247,
        "fullcodeline": "clap->get_height_rounded() );"
    },
    {
        "line": 275,
        "fullcodeline": "!primary_colr_set &&"
    },
    {
        "line": 62,
        "fullcodeline": "if (refs.size() != 1) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (image.get() == master_iter->second.get()) {"
    },
    {
        "line": 235,
        "fullcodeline": "sstr.str());"
    },
    {
        "line": 252,
        "fullcodeline": "if (irot->get_rotation()==90 ||"
    },
    {
        "line": 253,
        "fullcodeline": "irot->get_rotation()==270) {"
    },
    {
        "line": 255,
        "fullcodeline": "image->set_resolution( image->get_height(),"
    },
    {
        "line": 310,
        "fullcodeline": "if (ref.header.get_short_type() == fourcc(\"cdsc\")) {"
    },
    {
        "line": 318,
        "fullcodeline": "uint32_t exif_image_id = refs[0];"
    },
    {
        "line": 319,
        "fullcodeline": "auto img_iter = m_all_images.find(exif_image_id);"
    },
    {
        "line": 326,
        "fullcodeline": "img_iter->second->add_metadata(metadata);"
    },
    {
        "line": 63,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 72,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 78,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 84,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 92,
        "fullcodeline": "else if (type==fourcc(\"auxl\")) {"
    },
    {
        "line": 97,
        "fullcodeline": "std::vector<Box_ipco::Property> properties;"
    },
    {
        "line": 98,
        "fullcodeline": "Error err = m_heif_file->get_properties(image->get_id(), properties);"
    },
    {
        "line": 103,
        "fullcodeline": "std::shared_ptr<Box_auxC> auxC_property;"
    },
    {
        "line": 174,
        "fullcodeline": "remove_top_level_image(image);"
    },
    {
        "line": 256,
        "fullcodeline": "image->get_width() );"
    },
    {
        "line": 311,
        "fullcodeline": "std::vector<uint32_t> refs = ref.to_item_ID;"
    },
    {
        "line": 320,
        "fullcodeline": "if (img_iter == m_all_images.end()) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (!auxC_property) {"
    },
    {
        "line": 119,
        "fullcodeline": "std::vector<heif_item_id> refs = ref.to_item_ID;"
    },
    {
        "line": 312,
        "fullcodeline": "if (refs.size() != 1) {"
    },
    {
        "line": 105,
        "fullcodeline": "auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);"
    },
    {
        "line": 120,
        "fullcodeline": "if (refs.size() != 1) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||"
    },
    {
        "line": 130,
        "fullcodeline": "auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {"
    },
    {
        "line": 131,
        "fullcodeline": "image->set_is_alpha_channel_of(refs[0]);"
    },
    {
        "line": 133,
        "fullcodeline": "auto master_iter = m_all_images.find(refs[0]);"
    },
    {
        "line": 144,
        "fullcodeline": "master_iter->second->set_alpha_channel(image);"
    },
    {
        "line": 150,
        "fullcodeline": "if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {"
    },
    {
        "line": 151,
        "fullcodeline": "image->set_is_depth_channel_of(refs[0]);"
    },
    {
        "line": 153,
        "fullcodeline": "auto master_iter = m_all_images.find(refs[0]);"
    },
    {
        "line": 159,
        "fullcodeline": "master_iter->second->set_depth_channel(image);"
    },
    {
        "line": 161,
        "fullcodeline": "auto subtypes = auxC_property->get_subtypes();"
    },
    {
        "line": 313,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 321,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 113,
        "fullcodeline": "sstr << \"No auxC property for image \" << image->get_id();"
    },
    {
        "line": 114,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 121,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 134,
        "fullcodeline": "if (master_iter == m_all_images.end()) {"
    },
    {
        "line": 163,
        "fullcodeline": "std::vector<std::shared_ptr<SEIMessage>> sei_messages;"
    },
    {
        "line": 164,
        "fullcodeline": "Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);"
    },
    {
        "line": 107,
        "fullcodeline": "auxC_property = auxC;"
    },
    {
        "line": 116,
        "fullcodeline": "sstr.str());"
    },
    {
        "line": 139,
        "fullcodeline": "if (image.get() == master_iter->second.get()) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (image.get() == master_iter->second.get()) {"
    },
    {
        "line": 135,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 140,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 155,
        "fullcodeline": "return Error(heif_error_Invalid_input,"
    },
    {
        "line": 167,
        "fullcodeline": "auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);"
    },
    {
        "line": 169,
        "fullcodeline": "image->set_depth_representation_info(*depth_msg);"
    }
]