[
    {
        "line": 4,
        "fullcodeline": "long compDataSize = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "long waveletDataOffset = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "long compCoeffDataOffset = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "int32_t toSubbands = 3 * img->levels + 1;"
    },
    {
        "line": 8,
        "fullcodeline": "int32_t transformWidth = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "CrxSubband *subbands = planeComp->subBands;"
    },
    {
        "line": 38,
        "fullcodeline": "planeComp->compBuf = (uint8_t *)"
    },
    {
        "line": 47,
        "fullcodeline": "uint64_t subbandMdatOffset = img->mdatOffset + mdatOffset;"
    },
    {
        "line": 48,
        "fullcodeline": "uint8_t *subbandBuf = planeComp->compBuf;"
    },
    {
        "line": 13,
        "fullcodeline": "for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)"
    },
    {
        "line": 43,
        "fullcodeline": "if (!planeComp->compBuf)"
    },
    {
        "line": 50,
        "fullcodeline": "for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)"
    },
    {
        "line": 112,
        "fullcodeline": "for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)"
    },
    {
        "line": 15,
        "fullcodeline": "subbands[subbandNum].bandSize ="
    },
    {
        "line": 17,
        "fullcodeline": "compDataSize += subbands[subbandNum].bandSize;"
    },
    {
        "line": 22,
        "fullcodeline": "int32_t encLevels = img->levels ? img->levels : 1;"
    },
    {
        "line": 23,
        "fullcodeline": "waveletDataOffset = (compDataSize + 7) & ~7;"
    },
    {
        "line": 24,
        "fullcodeline": "compDataSize ="
    },
    {
        "line": 26,
        "fullcodeline": "compCoeffDataOffset = compDataSize;"
    },
    {
        "line": 42,
        "fullcodeline": "malloc(compDataSize);"
    },
    {
        "line": 52,
        "fullcodeline": "subbands[subbandNum].bandBuf = subbandBuf;"
    },
    {
        "line": 53,
        "fullcodeline": "subbandBuf += subbands[subbandNum].bandSize;"
    },
    {
        "line": 54,
        "fullcodeline": "subbands[subbandNum].mdatOffset ="
    },
    {
        "line": 61,
        "fullcodeline": "CrxWaveletTransform *waveletTransforms ="
    },
    {
        "line": 63,
        "fullcodeline": "int32_t *paramData = (int32_t *)(planeComp->compBuf + compCoeffDataOffset);"
    },
    {
        "line": 65,
        "fullcodeline": "planeComp->waveletTransform = waveletTransforms;"
    },
    {
        "line": 66,
        "fullcodeline": "waveletTransforms[0].subband0Buf = (int32_t *)subbands->bandBuf;"
    },
    {
        "line": 25,
        "fullcodeline": "(sizeof(CrxWaveletTransform) * encLevels + waveletDataOffset + 7) & ~7;"
    },
    {
        "line": 29,
        "fullcodeline": "for (int level = 0; level < img->levels; ++level)"
    },
    {
        "line": 44,
        "fullcodeline": "return -1;"
    },
    {
        "line": 55,
        "fullcodeline": "subbandMdatOffset + subbands[subbandNum].dataOffset;"
    },
    {
        "line": 62,
        "fullcodeline": "(CrxWaveletTransform *)(planeComp->compBuf + waveletDataOffset);"
    },
    {
        "line": 68,
        "fullcodeline": "for (int level = 0; level < img->levels; ++level)"
    },
    {
        "line": 30,
        "fullcodeline": "if (level < img->levels - 1)"
    },
    {
        "line": 70,
        "fullcodeline": "int32_t band = 3 * level + 1;"
    },
    {
        "line": 82,
        "fullcodeline": "waveletTransforms[level].width = transformWidth;"
    },
    {
        "line": 83,
        "fullcodeline": "waveletTransforms[level].lineBuf[0] = paramData;"
    },
    {
        "line": 84,
        "fullcodeline": "waveletTransforms[level].lineBuf[1] ="
    },
    {
        "line": 86,
        "fullcodeline": "waveletTransforms[level].lineBuf[2] ="
    },
    {
        "line": 88,
        "fullcodeline": "waveletTransforms[level].lineBuf[3] ="
    },
    {
        "line": 90,
        "fullcodeline": "waveletTransforms[level].lineBuf[4] ="
    },
    {
        "line": 92,
        "fullcodeline": "waveletTransforms[level].lineBuf[5] ="
    },
    {
        "line": 94,
        "fullcodeline": "waveletTransforms[level].lineBuf[6] ="
    },
    {
        "line": 96,
        "fullcodeline": "waveletTransforms[level].lineBuf[7] ="
    },
    {
        "line": 98,
        "fullcodeline": "waveletTransforms[level].curLine = 0;"
    },
    {
        "line": 99,
        "fullcodeline": "waveletTransforms[level].curH = 0;"
    },
    {
        "line": 100,
        "fullcodeline": "waveletTransforms[level].fltTapH = 0;"
    },
    {
        "line": 107,
        "fullcodeline": "paramData = waveletTransforms[level].lineBuf[7] + transformWidth;"
    },
    {
        "line": 116,
        "fullcodeline": "int32_t supportsPartial = 0;"
    },
    {
        "line": 117,
        "fullcodeline": "uint32_t roundedBitsMask = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "compDataSize += 8 * sizeof(int32_t) *"
    },
    {
        "line": 72,
        "fullcodeline": "if (level >= img->levels - 1)"
    },
    {
        "line": 85,
        "fullcodeline": "waveletTransforms[level].lineBuf[0] + transformWidth;"
    },
    {
        "line": 87,
        "fullcodeline": "waveletTransforms[level].lineBuf[1] + transformWidth;"
    },
    {
        "line": 89,
        "fullcodeline": "waveletTransforms[level].lineBuf[2] + transformWidth;"
    },
    {
        "line": 91,
        "fullcodeline": "waveletTransforms[level].lineBuf[3] + transformWidth;"
    },
    {
        "line": 93,
        "fullcodeline": "waveletTransforms[level].lineBuf[4] + transformWidth;"
    },
    {
        "line": 95,
        "fullcodeline": "waveletTransforms[level].lineBuf[5] + transformWidth;"
    },
    {
        "line": 97,
        "fullcodeline": "waveletTransforms[level].lineBuf[6] + transformWidth;"
    },
    {
        "line": 119,
        "fullcodeline": "if (planeComp->supportsPartial && subbandNum == 0)"
    },
    {
        "line": 124,
        "fullcodeline": "if (crxParamInit("
    },
    {
        "line": 34,
        "fullcodeline": "compDataSize += 8 * sizeof(int32_t) * tile->width;"
    },
    {
        "line": 74,
        "fullcodeline": "waveletTransforms[level].height = tile->height;"
    },
    {
        "line": 75,
        "fullcodeline": "transformWidth = tile->width;"
    },
    {
        "line": 121,
        "fullcodeline": "roundedBitsMask = planeComp->roundedBitsMask;"
    },
    {
        "line": 122,
        "fullcodeline": "supportsPartial = 1;"
    },
    {
        "line": 133,
        "fullcodeline": "return -1;"
    },
    {
        "line": 103,
        "fullcodeline": "(int32_t *)subbands[band + 1].bandBuf;"
    },
    {
        "line": 105,
        "fullcodeline": "(int32_t *)subbands[band + 2].bandBuf;"
    },
    {
        "line": 32,
        "fullcodeline": "planeComp->subBands[3 * (level + 1) + 2].width;"
    },
    {
        "line": 79,
        "fullcodeline": "waveletTransforms[level].height = subbands[band + 3].height;"
    },
    {
        "line": 80,
        "fullcodeline": "transformWidth = subbands[band + 4].width;"
    }
]