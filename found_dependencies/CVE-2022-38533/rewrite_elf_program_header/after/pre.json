[
    {
        "line": 11,
        "fullcodeline": "bool phdr_included = false;"
    },
    {
        "line": 13,
        "fullcodeline": "struct elf_segment_map *phdr_adjust_seg = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "unsigned int phdr_adjust_num = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "unsigned int opb = bfd_octets_per_byte (ibfd, NULL);"
    },
    {
        "line": 18,
        "fullcodeline": "bed = get_elf_backend_data (ibfd);"
    },
    {
        "line": 19,
        "fullcodeline": "iehdr = elf_elfheader (ibfd);"
    },
    {
        "line": 21,
        "fullcodeline": "map_first = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "pointer_to_map = &map_first;"
    },
    {
        "line": 24,
        "fullcodeline": "num_segments = elf_elfheader (ibfd)->e_phnum;"
    },
    {
        "line": 107,
        "fullcodeline": "p_paddr_valid = false;"
    },
    {
        "line": 598,
        "fullcodeline": "elf_seg_map (obfd) = map_first;"
    },
    {
        "line": 95,
        "fullcodeline": "for (section = ibfd->sections; section != NULL; section = section->next)"
    },
    {
        "line": 109,
        "fullcodeline": "i < num_segments;"
    },
    {
        "line": 110,
        "fullcodeline": "i++, segment++)"
    },
    {
        "line": 122,
        "fullcodeline": "i < num_segments;"
    },
    {
        "line": 123,
        "fullcodeline": "i++, segment++)"
    },
    {
        "line": 196,
        "fullcodeline": "i < num_segments;"
    },
    {
        "line": 197,
        "fullcodeline": "i++, segment++)"
    },
    {
        "line": 603,
        "fullcodeline": "if (phdr_adjust_seg != NULL)"
    },
    {
        "line": 97,
        "fullcodeline": "asection *o = section->output_section;"
    },
    {
        "line": 100,
        "fullcodeline": "section->segment_mark = false;"
    },
    {
        "line": 111,
        "fullcodeline": "if (segment->p_paddr != 0)"
    },
    {
        "line": 195,
        "fullcodeline": "for (i = 0, segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 212,
        "fullcodeline": "first_section = NULL;"
    },
    {
        "line": 231,
        "fullcodeline": "amt = sizeof (struct elf_segment_map) - sizeof (asection *);"
    },
    {
        "line": 232,
        "fullcodeline": "amt += section_count * sizeof (asection *);"
    },
    {
        "line": 233,
        "fullcodeline": "map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);"
    },
    {
        "line": 239,
        "fullcodeline": "map->next = NULL;"
    },
    {
        "line": 240,
        "fullcodeline": "map->p_type = segment->p_type;"
    },
    {
        "line": 241,
        "fullcodeline": "map->p_flags = segment->p_flags;"
    },
    {
        "line": 242,
        "fullcodeline": "map->p_flags_valid = 1;"
    },
    {
        "line": 266,
        "fullcodeline": "map->includes_filehdr = (segment->p_offset == 0"
    },
    {
        "line": 268,
        "fullcodeline": "map->includes_phdrs = 0;"
    },
    {
        "line": 335,
        "fullcodeline": "amt = section_count * sizeof (asection *);"
    },
    {
        "line": 336,
        "fullcodeline": "sections = (asection **) bfd_malloc (amt);"
    },
    {
        "line": 346,
        "fullcodeline": "isec = 0;"
    },
    {
        "line": 347,
        "fullcodeline": "matching_lma = NULL;"
    },
    {
        "line": 348,
        "fullcodeline": "suggested_lma = NULL;"
    },
    {
        "line": 402,
        "fullcodeline": "BFD_ASSERT (j == section_count);"
    },
    {
        "line": 481,
        "fullcodeline": "isec = 0;"
    },
    {
        "line": 595,
        "fullcodeline": "free (sections);"
    },
    {
        "line": 98,
        "fullcodeline": "if (o != NULL && o->alignment_power >= (sizeof (bfd_vma) * 8) - 1)"
    },
    {
        "line": 108,
        "fullcodeline": "for (i = 0, segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 113,
        "fullcodeline": "p_paddr_valid = true;"
    },
    {
        "line": 121,
        "fullcodeline": "for (i = 0, segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 128,
        "fullcodeline": "if (segment->p_type == PT_INTERP)"
    },
    {
        "line": 138,
        "fullcodeline": "if (segment->p_type != PT_LOAD)"
    },
    {
        "line": 147,
        "fullcodeline": "for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2++)"
    },
    {
        "line": 209,
        "fullcodeline": "if (segment->p_type == PT_NULL)"
    },
    {
        "line": 215,
        "fullcodeline": "section != NULL;"
    },
    {
        "line": 216,
        "fullcodeline": "section = section->next)"
    },
    {
        "line": 234,
        "fullcodeline": "if (map == NULL)"
    },
    {
        "line": 244,
        "fullcodeline": "if (map->p_type == PT_LOAD"
    },
    {
        "line": 258,
        "fullcodeline": "if (!first_section || first_section->output_section != NULL)"
    },
    {
        "line": 270,
        "fullcodeline": "if (!phdr_included || segment->p_type != PT_LOAD)"
    },
    {
        "line": 282,
        "fullcodeline": "if (section_count == 0)"
    },
    {
        "line": 337,
        "fullcodeline": "if (sections == NULL)"
    },
    {
        "line": 351,
        "fullcodeline": "section != NULL;"
    },
    {
        "line": 352,
        "fullcodeline": "section = section->next)"
    },
    {
        "line": 406,
        "fullcodeline": "if (isec == section_count)"
    },
    {
        "line": 593,
        "fullcodeline": "while (isec < section_count);"
    },
    {
        "line": 607,
        "fullcodeline": "for (count = 0, map = map_first; map != NULL; map = map->next)"
    },
    {
        "line": 608,
        "fullcodeline": "count++;"
    },
    {
        "line": 610,
        "fullcodeline": "if (count > phdr_adjust_num)"
    },
    {
        "line": 614,
        "fullcodeline": "for (map = map_first; map != NULL; map = map->next)"
    },
    {
        "line": 99,
        "fullcodeline": "o->alignment_power = 0;"
    },
    {
        "line": 214,
        "fullcodeline": "for (section = ibfd->sections, section_count = 0;"
    },
    {
        "line": 247,
        "fullcodeline": "&& segment->p_align > 1)"
    },
    {
        "line": 249,
        "fullcodeline": "map->p_align = segment->p_align;"
    },
    {
        "line": 252,
        "fullcodeline": "map->p_align_valid = 1;"
    },
    {
        "line": 260,
        "fullcodeline": "map->p_paddr = segment->p_paddr;"
    },
    {
        "line": 261,
        "fullcodeline": "map->p_paddr_valid = p_paddr_valid;"
    },
    {
        "line": 267,
        "fullcodeline": "&& segment->p_filesz >= iehdr->e_ehsize);"
    },
    {
        "line": 272,
        "fullcodeline": "map->includes_phdrs ="
    },
    {
        "line": 299,
        "fullcodeline": "map->p_vaddr_offset = segment->p_vaddr / opb;"
    },
    {
        "line": 300,
        "fullcodeline": "map->count = 0;"
    },
    {
        "line": 301,
        "fullcodeline": "*pointer_to_map = map;"
    },
    {
        "line": 302,
        "fullcodeline": "pointer_to_map = &map->next;"
    },
    {
        "line": 350,
        "fullcodeline": "for (section = first_section, j = 0;"
    },
    {
        "line": 412,
        "fullcodeline": "map->count = section_count;"
    },
    {
        "line": 413,
        "fullcodeline": "*pointer_to_map = map;"
    },
    {
        "line": 414,
        "fullcodeline": "pointer_to_map = &map->next;"
    },
    {
        "line": 431,
        "fullcodeline": "free (sections);"
    },
    {
        "line": 484,
        "fullcodeline": "map->count = 0;"
    },
    {
        "line": 485,
        "fullcodeline": "suggested_lma = NULL;"
    },
    {
        "line": 557,
        "fullcodeline": "*pointer_to_map = map;"
    },
    {
        "line": 558,
        "fullcodeline": "pointer_to_map = &map->next;"
    },
    {
        "line": 589,
        "fullcodeline": "bfd_set_error (bfd_error_sorry);"
    },
    {
        "line": 611,
        "fullcodeline": "phdr_adjust_seg->p_paddr"
    },
    {
        "line": 615,
        "fullcodeline": "if (map->p_type == PT_PHDR)"
    },
    {
        "line": 129,
        "fullcodeline": "for (section = ibfd->sections; section; section = section->next)"
    },
    {
        "line": 141,
        "fullcodeline": "if (segment->p_type == PT_GNU_RELRO)"
    },
    {
        "line": 151,
        "fullcodeline": "if (segment2->p_type != PT_LOAD"
    },
    {
        "line": 156,
        "fullcodeline": "if (segment2->p_vaddr < segment->p_vaddr)"
    },
    {
        "line": 220,
        "fullcodeline": "if (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb))"
    },
    {
        "line": 246,
        "fullcodeline": "&& maxpagesize > 1"
    },
    {
        "line": 250,
        "fullcodeline": "if (segment->p_align > maxpagesize)"
    },
    {
        "line": 273,
        "fullcodeline": "(segment->p_offset <= (bfd_vma) iehdr->e_phoff"
    },
    {
        "line": 278,
        "fullcodeline": "if (segment->p_type == PT_LOAD && map->includes_phdrs)"
    },
    {
        "line": 354,
        "fullcodeline": "if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed, opb))"
    },
    {
        "line": 416,
        "fullcodeline": "if (p_paddr_valid"
    },
    {
        "line": 442,
        "fullcodeline": "map->p_paddr = matching_lma->lma * opb;"
    },
    {
        "line": 488,
        "fullcodeline": "for (j = 0; j < section_count; j++)"
    },
    {
        "line": 560,
        "fullcodeline": "if (isec < section_count)"
    },
    {
        "line": 612,
        "fullcodeline": "-= (count - phdr_adjust_num) * iehdr->e_phentsize;"
    },
    {
        "line": 617,
        "fullcodeline": "bfd_vma adjust"
    },
    {
        "line": 130,
        "fullcodeline": "if (IS_SOLARIS_PT_INTERP (segment, section))"
    },
    {
        "line": 142,
        "fullcodeline": "segment->p_type = PT_NULL;"
    },
    {
        "line": 152,
        "fullcodeline": "|| !SEGMENT_OVERLAPS (segment, segment2))"
    },
    {
        "line": 160,
        "fullcodeline": "extra_length = (segment_end (segment, segment->p_vaddr)"
    },
    {
        "line": 169,
        "fullcodeline": "segment->p_type = PT_NULL;"
    },
    {
        "line": 172,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 173,
        "fullcodeline": "segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 245,
        "fullcodeline": "&& (ibfd->flags & D_PAGED) != 0"
    },
    {
        "line": 251,
        "fullcodeline": "map->p_align = maxpagesize;"
    },
    {
        "line": 274,
        "fullcodeline": "&& (segment->p_offset + segment->p_filesz"
    },
    {
        "line": 279,
        "fullcodeline": "phdr_included = true;"
    },
    {
        "line": 356,
        "fullcodeline": "output_section = section->output_section;"
    },
    {
        "line": 358,
        "fullcodeline": "sections[j++] = section;"
    },
    {
        "line": 417,
        "fullcodeline": "&& !bed->want_p_paddr_set_to_zero)"
    },
    {
        "line": 419,
        "fullcodeline": "bfd_vma hdr_size = 0;"
    },
    {
        "line": 427,
        "fullcodeline": "map->p_vaddr_offset = ((map->p_paddr + hdr_size) / opb"
    },
    {
        "line": 439,
        "fullcodeline": "if (matching_lma == NULL)"
    },
    {
        "line": 490,
        "fullcodeline": "section = sections[j];"
    },
    {
        "line": 495,
        "fullcodeline": "output_section = section->output_section;"
    },
    {
        "line": 497,
        "fullcodeline": "BFD_ASSERT (output_section != NULL);"
    },
    {
        "line": 565,
        "fullcodeline": "amt = sizeof (struct elf_segment_map) - sizeof (asection *);"
    },
    {
        "line": 566,
        "fullcodeline": "amt += section_count * sizeof (asection *);"
    },
    {
        "line": 567,
        "fullcodeline": "map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);"
    },
    {
        "line": 577,
        "fullcodeline": "map->next = NULL;"
    },
    {
        "line": 578,
        "fullcodeline": "map->p_type = segment->p_type;"
    },
    {
        "line": 579,
        "fullcodeline": "map->p_flags = segment->p_flags;"
    },
    {
        "line": 580,
        "fullcodeline": "map->p_flags_valid = 1;"
    },
    {
        "line": 581,
        "fullcodeline": "map->p_paddr = suggested_lma->lma * opb;"
    },
    {
        "line": 582,
        "fullcodeline": "map->p_paddr_valid = p_paddr_valid;"
    },
    {
        "line": 583,
        "fullcodeline": "map->includes_filehdr = 0;"
    },
    {
        "line": 584,
        "fullcodeline": "map->includes_phdrs = 0;"
    },
    {
        "line": 134,
        "fullcodeline": "segment->p_vaddr = section->vma * opb;"
    },
    {
        "line": 163,
        "fullcodeline": "if (extra_length > 0)"
    },
    {
        "line": 180,
        "fullcodeline": "extra_length = (segment_end (segment2, segment2->p_vaddr)"
    },
    {
        "line": 189,
        "fullcodeline": "segment2->p_type = PT_NULL;"
    },
    {
        "line": 222,
        "fullcodeline": "if (first_section == NULL)"
    },
    {
        "line": 224,
        "fullcodeline": "if (section->output_section != NULL)"
    },
    {
        "line": 275,
        "fullcodeline": ">= ((bfd_vma) iehdr->e_phoff"
    },
    {
        "line": 364,
        "fullcodeline": "if (!p_paddr_valid"
    },
    {
        "line": 381,
        "fullcodeline": "if (is_contained_by (output_section, segment, map->p_paddr,"
    },
    {
        "line": 397,
        "fullcodeline": "if (j == section_count)"
    },
    {
        "line": 440,
        "fullcodeline": "matching_lma = suggested_lma;"
    },
    {
        "line": 448,
        "fullcodeline": "map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;"
    },
    {
        "line": 455,
        "fullcodeline": "phdr_adjust_num = iehdr->e_phnum;"
    },
    {
        "line": 456,
        "fullcodeline": "phdr_adjust_seg = map;"
    },
    {
        "line": 461,
        "fullcodeline": "bfd_vma align = (bfd_vma) 1 << matching_lma->alignment_power;"
    },
    {
        "line": 462,
        "fullcodeline": "map->p_paddr -= iehdr->e_ehsize;"
    },
    {
        "line": 470,
        "fullcodeline": "map->p_paddr &= -(align * opb);"
    },
    {
        "line": 492,
        "fullcodeline": "if (section == NULL)"
    },
    {
        "line": 499,
        "fullcodeline": "if (is_contained_by (output_section, segment, map->p_paddr,"
    },
    {
        "line": 568,
        "fullcodeline": "if (map == NULL)"
    },
    {
        "line": 161,
        "fullcodeline": "- segment_end (segment2, segment2->p_vaddr));"
    },
    {
        "line": 165,
        "fullcodeline": "segment2->p_memsz += extra_length;"
    },
    {
        "line": 166,
        "fullcodeline": "segment2->p_filesz += extra_length;"
    },
    {
        "line": 183,
        "fullcodeline": "if (extra_length > 0)"
    },
    {
        "line": 223,
        "fullcodeline": "first_section = section;"
    },
    {
        "line": 225,
        "fullcodeline": "++section_count;"
    },
    {
        "line": 276,
        "fullcodeline": "+ iehdr->e_phnum * iehdr->e_phentsize)));"
    },
    {
        "line": 369,
        "fullcodeline": "&& (align_power (segment->p_vaddr"
    },
    {
        "line": 377,
        "fullcodeline": "map->p_paddr = segment->p_vaddr;"
    },
    {
        "line": 383,
        "fullcodeline": "|| is_note (segment, section))"
    },
    {
        "line": 392,
        "fullcodeline": "map->sections[isec++] = output_section;"
    },
    {
        "line": 421,
        "fullcodeline": "hdr_size = iehdr->e_ehsize;"
    },
    {
        "line": 423,
        "fullcodeline": "hdr_size += iehdr->e_phnum * iehdr->e_phentsize;"
    },
    {
        "line": 468,
        "fullcodeline": "if (segment->p_align != 0 && segment->p_align < align)"
    },
    {
        "line": 501,
        "fullcodeline": "|| is_note (segment, section))"
    },
    {
        "line": 540,
        "fullcodeline": "map->sections[map->count++] = output_section;"
    },
    {
        "line": 541,
        "fullcodeline": "++isec;"
    },
    {
        "line": 542,
        "fullcodeline": "sections[j] = NULL;"
    },
    {
        "line": 181,
        "fullcodeline": "- segment_end (segment, segment->p_vaddr));"
    },
    {
        "line": 185,
        "fullcodeline": "segment->p_memsz += extra_length;"
    },
    {
        "line": 186,
        "fullcodeline": "segment->p_filesz += extra_length;"
    },
    {
        "line": 368,
        "fullcodeline": "&& output_section->lma != 0"
    },
    {
        "line": 376,
        "fullcodeline": "== (output_section->vma * opb)))"
    },
    {
        "line": 382,
        "fullcodeline": "map->p_paddr + map->p_vaddr_offset, opb, bed)"
    },
    {
        "line": 385,
        "fullcodeline": "if (matching_lma == NULL"
    },
    {
        "line": 469,
        "fullcodeline": "align = segment->p_align;"
    },
    {
        "line": 500,
        "fullcodeline": "map->p_paddr + map->p_vaddr_offset, opb, bed)"
    },
    {
        "line": 503,
        "fullcodeline": "if (map->count == 0)"
    },
    {
        "line": 543,
        "fullcodeline": "if (segment->p_type == PT_LOAD)"
    },
    {
        "line": 367,
        "fullcodeline": "&& isec == 0"
    },
    {
        "line": 375,
        "fullcodeline": "output_section->alignment_power * opb)"
    },
    {
        "line": 386,
        "fullcodeline": "|| output_section->lma < matching_lma->lma)"
    },
    {
        "line": 387,
        "fullcodeline": "matching_lma = output_section;"
    },
    {
        "line": 394,
        "fullcodeline": "else if (suggested_lma == NULL)"
    },
    {
        "line": 544,
        "fullcodeline": "section->segment_mark = true;"
    },
    {
        "line": 546,
        "fullcodeline": "else if (suggested_lma == NULL)"
    },
    {
        "line": 366,
        "fullcodeline": "&& !bed->want_p_paddr_set_to_zero"
    },
    {
        "line": 372,
        "fullcodeline": "+ (map->includes_phdrs"
    },
    {
        "line": 395,
        "fullcodeline": "suggested_lma = output_section;"
    },
    {
        "line": 508,
        "fullcodeline": "if (align_power (map->p_paddr"
    },
    {
        "line": 522,
        "fullcodeline": "prev_sec = map->sections[map->count - 1];"
    },
    {
        "line": 547,
        "fullcodeline": "suggested_lma = output_section;"
    },
    {
        "line": 365,
        "fullcodeline": "&& segment->p_vaddr != 0"
    },
    {
        "line": 370,
        "fullcodeline": "+ (map->includes_filehdr"
    },
    {
        "line": 373,
        "fullcodeline": "? iehdr->e_phnum * iehdr->e_phentsize"
    },
    {
        "line": 515,
        "fullcodeline": "!= output_section->lma * opb)"
    },
    {
        "line": 527,
        "fullcodeline": "if ((BFD_ALIGN (prev_sec->lma + prev_sec->size,"
    },
    {
        "line": 514,
        "fullcodeline": "output_section->alignment_power * opb)"
    },
    {
        "line": 530,
        "fullcodeline": "|| (prev_sec->lma + prev_sec->size"
    },
    {
        "line": 511,
        "fullcodeline": "+ (map->includes_phdrs"
    },
    {
        "line": 529,
        "fullcodeline": "< BFD_ALIGN (output_section->lma, maxpagesize))"
    },
    {
        "line": 533,
        "fullcodeline": "if (suggested_lma == NULL)"
    },
    {
        "line": 509,
        "fullcodeline": "+ (map->includes_filehdr"
    },
    {
        "line": 512,
        "fullcodeline": "? iehdr->e_phnum * iehdr->e_phentsize"
    },
    {
        "line": 534,
        "fullcodeline": "suggested_lma = output_section;"
    }
]