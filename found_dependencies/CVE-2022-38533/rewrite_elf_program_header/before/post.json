[
    {
        "line": 11,
        "fullcodeline": "bool phdr_included = false;"
    },
    {
        "line": 13,
        "fullcodeline": "struct elf_segment_map *phdr_adjust_seg = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "unsigned int phdr_adjust_num = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "unsigned int opb = bfd_octets_per_byte (ibfd, NULL);"
    },
    {
        "line": 18,
        "fullcodeline": "bed = get_elf_backend_data (ibfd);"
    },
    {
        "line": 19,
        "fullcodeline": "iehdr = elf_elfheader (ibfd);"
    },
    {
        "line": 21,
        "fullcodeline": "map_first = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "pointer_to_map = &map_first;"
    },
    {
        "line": 149,
        "fullcodeline": "p_paddr_valid = false;"
    },
    {
        "line": 642,
        "fullcodeline": "elf_seg_map (obfd) = map_first;"
    },
    {
        "line": 137,
        "fullcodeline": "for (section = ibfd->sections; section != NULL; section = section->next)"
    },
    {
        "line": 151,
        "fullcodeline": "i < num_segments;"
    },
    {
        "line": 152,
        "fullcodeline": "i++, segment++)"
    },
    {
        "line": 164,
        "fullcodeline": "i < num_segments;"
    },
    {
        "line": 165,
        "fullcodeline": "i++, segment++)"
    },
    {
        "line": 238,
        "fullcodeline": "i < num_segments;"
    },
    {
        "line": 239,
        "fullcodeline": "i++, segment++)"
    },
    {
        "line": 647,
        "fullcodeline": "if (phdr_adjust_seg != NULL)"
    },
    {
        "line": 24,
        "fullcodeline": "num_segments = elf_elfheader (ibfd)->e_phnum;"
    },
    {
        "line": 139,
        "fullcodeline": "asection *o = section->output_section;"
    },
    {
        "line": 142,
        "fullcodeline": "section->segment_mark = false;"
    },
    {
        "line": 150,
        "fullcodeline": "for (i = 0, segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 153,
        "fullcodeline": "if (segment->p_paddr != 0)"
    },
    {
        "line": 163,
        "fullcodeline": "for (i = 0, segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 237,
        "fullcodeline": "for (i = 0, segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 254,
        "fullcodeline": "first_section = NULL;"
    },
    {
        "line": 274,
        "fullcodeline": "amt += section_count * sizeof (asection *);"
    },
    {
        "line": 275,
        "fullcodeline": "map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);"
    },
    {
        "line": 281,
        "fullcodeline": "map->next = NULL;"
    },
    {
        "line": 282,
        "fullcodeline": "map->p_type = segment->p_type;"
    },
    {
        "line": 283,
        "fullcodeline": "map->p_flags = segment->p_flags;"
    },
    {
        "line": 284,
        "fullcodeline": "map->p_flags_valid = 1;"
    },
    {
        "line": 308,
        "fullcodeline": "map->includes_filehdr = (segment->p_offset == 0"
    },
    {
        "line": 310,
        "fullcodeline": "map->includes_phdrs = 0;"
    },
    {
        "line": 377,
        "fullcodeline": "amt = section_count * sizeof (asection *);"
    },
    {
        "line": 378,
        "fullcodeline": "sections = (asection **) bfd_malloc (amt);"
    },
    {
        "line": 388,
        "fullcodeline": "isec = 0;"
    },
    {
        "line": 389,
        "fullcodeline": "matching_lma = NULL;"
    },
    {
        "line": 390,
        "fullcodeline": "suggested_lma = NULL;"
    },
    {
        "line": 446,
        "fullcodeline": "BFD_ASSERT (j == section_count);"
    },
    {
        "line": 525,
        "fullcodeline": "isec = 0;"
    },
    {
        "line": 639,
        "fullcodeline": "free (sections);"
    },
    {
        "line": 140,
        "fullcodeline": "if (o != NULL && o->alignment_power >= (sizeof (bfd_vma) * 8) - 1)"
    },
    {
        "line": 155,
        "fullcodeline": "p_paddr_valid = true;"
    },
    {
        "line": 170,
        "fullcodeline": "if (segment->p_type == PT_INTERP)"
    },
    {
        "line": 180,
        "fullcodeline": "if (segment->p_type != PT_LOAD)"
    },
    {
        "line": 189,
        "fullcodeline": "for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2++)"
    },
    {
        "line": 251,
        "fullcodeline": "if (segment->p_type == PT_NULL)"
    },
    {
        "line": 257,
        "fullcodeline": "section != NULL;"
    },
    {
        "line": 258,
        "fullcodeline": "section = section->next)"
    },
    {
        "line": 276,
        "fullcodeline": "if (map == NULL)"
    },
    {
        "line": 286,
        "fullcodeline": "if (map->p_type == PT_LOAD"
    },
    {
        "line": 300,
        "fullcodeline": "if (!first_section || first_section->output_section != NULL)"
    },
    {
        "line": 312,
        "fullcodeline": "if (!phdr_included || segment->p_type != PT_LOAD)"
    },
    {
        "line": 324,
        "fullcodeline": "if (section_count == 0)"
    },
    {
        "line": 379,
        "fullcodeline": "if (sections == NULL)"
    },
    {
        "line": 393,
        "fullcodeline": "section != NULL;"
    },
    {
        "line": 394,
        "fullcodeline": "section = section->next)"
    },
    {
        "line": 450,
        "fullcodeline": "if (isec == section_count)"
    },
    {
        "line": 637,
        "fullcodeline": "while (isec < section_count);"
    },
    {
        "line": 651,
        "fullcodeline": "for (count = 0, map = map_first; map != NULL; map = map->next)"
    },
    {
        "line": 652,
        "fullcodeline": "count++;"
    },
    {
        "line": 654,
        "fullcodeline": "if (count > phdr_adjust_num)"
    },
    {
        "line": 658,
        "fullcodeline": "for (map = map_first; map != NULL; map = map->next)"
    },
    {
        "line": 141,
        "fullcodeline": "o->alignment_power = 0;"
    },
    {
        "line": 256,
        "fullcodeline": "for (section = ibfd->sections, section_count = 0;"
    },
    {
        "line": 289,
        "fullcodeline": "&& segment->p_align > 1)"
    },
    {
        "line": 291,
        "fullcodeline": "map->p_align = segment->p_align;"
    },
    {
        "line": 294,
        "fullcodeline": "map->p_align_valid = 1;"
    },
    {
        "line": 302,
        "fullcodeline": "map->p_paddr = segment->p_paddr;"
    },
    {
        "line": 303,
        "fullcodeline": "map->p_paddr_valid = p_paddr_valid;"
    },
    {
        "line": 309,
        "fullcodeline": "&& segment->p_filesz >= iehdr->e_ehsize);"
    },
    {
        "line": 314,
        "fullcodeline": "map->includes_phdrs ="
    },
    {
        "line": 341,
        "fullcodeline": "map->p_vaddr_offset = segment->p_vaddr / opb;"
    },
    {
        "line": 342,
        "fullcodeline": "map->count = 0;"
    },
    {
        "line": 343,
        "fullcodeline": "*pointer_to_map = map;"
    },
    {
        "line": 344,
        "fullcodeline": "pointer_to_map = &map->next;"
    },
    {
        "line": 392,
        "fullcodeline": "for (section = first_section, j = 0;"
    },
    {
        "line": 456,
        "fullcodeline": "map->count = section_count;"
    },
    {
        "line": 457,
        "fullcodeline": "*pointer_to_map = map;"
    },
    {
        "line": 458,
        "fullcodeline": "pointer_to_map = &map->next;"
    },
    {
        "line": 475,
        "fullcodeline": "free (sections);"
    },
    {
        "line": 528,
        "fullcodeline": "map->count = 0;"
    },
    {
        "line": 529,
        "fullcodeline": "suggested_lma = NULL;"
    },
    {
        "line": 601,
        "fullcodeline": "*pointer_to_map = map;"
    },
    {
        "line": 602,
        "fullcodeline": "pointer_to_map = &map->next;"
    },
    {
        "line": 633,
        "fullcodeline": "bfd_set_error (bfd_error_sorry);"
    },
    {
        "line": 634,
        "fullcodeline": "free (sections);"
    },
    {
        "line": 655,
        "fullcodeline": "phdr_adjust_seg->p_paddr"
    },
    {
        "line": 659,
        "fullcodeline": "if (map->p_type == PT_PHDR)"
    },
    {
        "line": 171,
        "fullcodeline": "for (section = ibfd->sections; section; section = section->next)"
    },
    {
        "line": 183,
        "fullcodeline": "if (segment->p_type == PT_GNU_RELRO)"
    },
    {
        "line": 193,
        "fullcodeline": "if (segment2->p_type != PT_LOAD"
    },
    {
        "line": 198,
        "fullcodeline": "if (segment2->p_vaddr < segment->p_vaddr)"
    },
    {
        "line": 262,
        "fullcodeline": "if (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb))"
    },
    {
        "line": 288,
        "fullcodeline": "&& maxpagesize > 1"
    },
    {
        "line": 292,
        "fullcodeline": "if (segment->p_align > maxpagesize)"
    },
    {
        "line": 315,
        "fullcodeline": "(segment->p_offset <= (bfd_vma) iehdr->e_phoff"
    },
    {
        "line": 320,
        "fullcodeline": "if (segment->p_type == PT_LOAD && map->includes_phdrs)"
    },
    {
        "line": 396,
        "fullcodeline": "if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed, opb))"
    },
    {
        "line": 460,
        "fullcodeline": "if (p_paddr_valid"
    },
    {
        "line": 486,
        "fullcodeline": "map->p_paddr = matching_lma->lma * opb;"
    },
    {
        "line": 532,
        "fullcodeline": "for (j = 0; j < section_count; j++)"
    },
    {
        "line": 604,
        "fullcodeline": "if (isec < section_count)"
    },
    {
        "line": 656,
        "fullcodeline": "-= (count - phdr_adjust_num) * iehdr->e_phentsize;"
    },
    {
        "line": 661,
        "fullcodeline": "bfd_vma adjust"
    },
    {
        "line": 663,
        "fullcodeline": "map->p_paddr = phdr_adjust_seg->p_paddr + adjust;"
    },
    {
        "line": 172,
        "fullcodeline": "if (IS_SOLARIS_PT_INTERP (segment, section))"
    },
    {
        "line": 184,
        "fullcodeline": "segment->p_type = PT_NULL;"
    },
    {
        "line": 194,
        "fullcodeline": "|| !SEGMENT_OVERLAPS (segment, segment2))"
    },
    {
        "line": 202,
        "fullcodeline": "extra_length = (SEGMENT_END (segment, segment->p_vaddr)"
    },
    {
        "line": 211,
        "fullcodeline": "segment->p_type = PT_NULL;"
    },
    {
        "line": 214,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 287,
        "fullcodeline": "&& (ibfd->flags & D_PAGED) != 0"
    },
    {
        "line": 293,
        "fullcodeline": "map->p_align = maxpagesize;"
    },
    {
        "line": 316,
        "fullcodeline": "&& (segment->p_offset + segment->p_filesz"
    },
    {
        "line": 321,
        "fullcodeline": "phdr_included = true;"
    },
    {
        "line": 398,
        "fullcodeline": "output_section = section->output_section;"
    },
    {
        "line": 400,
        "fullcodeline": "sections[j++] = section;"
    },
    {
        "line": 461,
        "fullcodeline": "&& !bed->want_p_paddr_set_to_zero)"
    },
    {
        "line": 463,
        "fullcodeline": "bfd_vma hdr_size = 0;"
    },
    {
        "line": 471,
        "fullcodeline": "map->p_vaddr_offset = ((map->p_paddr + hdr_size) / opb"
    },
    {
        "line": 483,
        "fullcodeline": "if (matching_lma == NULL)"
    },
    {
        "line": 534,
        "fullcodeline": "section = sections[j];"
    },
    {
        "line": 539,
        "fullcodeline": "output_section = section->output_section;"
    },
    {
        "line": 541,
        "fullcodeline": "BFD_ASSERT (output_section != NULL);"
    },
    {
        "line": 610,
        "fullcodeline": "amt += section_count * sizeof (asection *);"
    },
    {
        "line": 611,
        "fullcodeline": "map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);"
    },
    {
        "line": 621,
        "fullcodeline": "map->next = NULL;"
    },
    {
        "line": 622,
        "fullcodeline": "map->p_type = segment->p_type;"
    },
    {
        "line": 623,
        "fullcodeline": "map->p_flags = segment->p_flags;"
    },
    {
        "line": 624,
        "fullcodeline": "map->p_flags_valid = 1;"
    },
    {
        "line": 625,
        "fullcodeline": "map->p_paddr = suggested_lma->lma * opb;"
    },
    {
        "line": 626,
        "fullcodeline": "map->p_paddr_valid = p_paddr_valid;"
    },
    {
        "line": 627,
        "fullcodeline": "map->includes_filehdr = 0;"
    },
    {
        "line": 628,
        "fullcodeline": "map->includes_phdrs = 0;"
    },
    {
        "line": 662,
        "fullcodeline": "= phdr_adjust_seg->includes_filehdr ? iehdr->e_ehsize : 0;"
    },
    {
        "line": 176,
        "fullcodeline": "segment->p_vaddr = section->vma * opb;"
    },
    {
        "line": 205,
        "fullcodeline": "if (extra_length > 0)"
    },
    {
        "line": 222,
        "fullcodeline": "extra_length = (SEGMENT_END (segment2, segment2->p_vaddr)"
    },
    {
        "line": 231,
        "fullcodeline": "segment2->p_type = PT_NULL;"
    },
    {
        "line": 264,
        "fullcodeline": "if (first_section == NULL)"
    },
    {
        "line": 266,
        "fullcodeline": "if (section->output_section != NULL)"
    },
    {
        "line": 317,
        "fullcodeline": ">= ((bfd_vma) iehdr->e_phoff"
    },
    {
        "line": 406,
        "fullcodeline": "if (!p_paddr_valid"
    },
    {
        "line": 423,
        "fullcodeline": "if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,"
    },
    {
        "line": 441,
        "fullcodeline": "if (j == section_count)"
    },
    {
        "line": 484,
        "fullcodeline": "matching_lma = suggested_lma;"
    },
    {
        "line": 492,
        "fullcodeline": "map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;"
    },
    {
        "line": 499,
        "fullcodeline": "phdr_adjust_num = iehdr->e_phnum;"
    },
    {
        "line": 500,
        "fullcodeline": "phdr_adjust_seg = map;"
    },
    {
        "line": 505,
        "fullcodeline": "bfd_vma align = (bfd_vma) 1 << matching_lma->alignment_power;"
    },
    {
        "line": 506,
        "fullcodeline": "map->p_paddr -= iehdr->e_ehsize;"
    },
    {
        "line": 514,
        "fullcodeline": "map->p_paddr &= -(align * opb);"
    },
    {
        "line": 536,
        "fullcodeline": "if (section == NULL)"
    },
    {
        "line": 543,
        "fullcodeline": "if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,"
    },
    {
        "line": 612,
        "fullcodeline": "if (map == NULL)"
    },
    {
        "line": 203,
        "fullcodeline": "- SEGMENT_END (segment2, segment2->p_vaddr));"
    },
    {
        "line": 207,
        "fullcodeline": "segment2->p_memsz += extra_length;"
    },
    {
        "line": 208,
        "fullcodeline": "segment2->p_filesz += extra_length;"
    },
    {
        "line": 215,
        "fullcodeline": "segment = elf_tdata (ibfd)->phdr;"
    },
    {
        "line": 225,
        "fullcodeline": "if (extra_length > 0)"
    },
    {
        "line": 265,
        "fullcodeline": "first_section = section;"
    },
    {
        "line": 267,
        "fullcodeline": "++section_count;"
    },
    {
        "line": 318,
        "fullcodeline": "+ iehdr->e_phnum * iehdr->e_phentsize)));"
    },
    {
        "line": 411,
        "fullcodeline": "&& (align_power (segment->p_vaddr"
    },
    {
        "line": 419,
        "fullcodeline": "map->p_paddr = segment->p_vaddr;"
    },
    {
        "line": 426,
        "fullcodeline": "|| (bed->want_p_paddr_set_to_zero"
    },
    {
        "line": 436,
        "fullcodeline": "map->sections[isec++] = output_section;"
    },
    {
        "line": 465,
        "fullcodeline": "hdr_size = iehdr->e_ehsize;"
    },
    {
        "line": 467,
        "fullcodeline": "hdr_size += iehdr->e_phnum * iehdr->e_phentsize;"
    },
    {
        "line": 512,
        "fullcodeline": "if (segment->p_align != 0 && segment->p_align < align)"
    },
    {
        "line": 545,
        "fullcodeline": "|| IS_COREFILE_NOTE (segment, section))"
    },
    {
        "line": 584,
        "fullcodeline": "map->sections[map->count++] = output_section;"
    },
    {
        "line": 585,
        "fullcodeline": "++isec;"
    },
    {
        "line": 586,
        "fullcodeline": "sections[j] = NULL;"
    },
    {
        "line": 614,
        "fullcodeline": "free (sections);"
    },
    {
        "line": 223,
        "fullcodeline": "- SEGMENT_END (segment, segment->p_vaddr));"
    },
    {
        "line": 227,
        "fullcodeline": "segment->p_memsz += extra_length;"
    },
    {
        "line": 228,
        "fullcodeline": "segment->p_filesz += extra_length;"
    },
    {
        "line": 410,
        "fullcodeline": "&& output_section->lma != 0"
    },
    {
        "line": 418,
        "fullcodeline": "== (output_section->vma * opb)))"
    },
    {
        "line": 425,
        "fullcodeline": "|| IS_COREFILE_NOTE (segment, section)"
    },
    {
        "line": 427,
        "fullcodeline": "&& IS_CONTAINED_BY_VMA (output_section, segment, opb)))"
    },
    {
        "line": 429,
        "fullcodeline": "if (matching_lma == NULL"
    },
    {
        "line": 513,
        "fullcodeline": "align = segment->p_align;"
    },
    {
        "line": 547,
        "fullcodeline": "if (map->count == 0)"
    },
    {
        "line": 587,
        "fullcodeline": "if (segment->p_type == PT_LOAD)"
    },
    {
        "line": 409,
        "fullcodeline": "&& isec == 0"
    },
    {
        "line": 417,
        "fullcodeline": "output_section->alignment_power * opb)"
    },
    {
        "line": 430,
        "fullcodeline": "|| output_section->lma < matching_lma->lma)"
    },
    {
        "line": 431,
        "fullcodeline": "matching_lma = output_section;"
    },
    {
        "line": 438,
        "fullcodeline": "else if (suggested_lma == NULL)"
    },
    {
        "line": 588,
        "fullcodeline": "section->segment_mark = true;"
    },
    {
        "line": 590,
        "fullcodeline": "else if (suggested_lma == NULL)"
    },
    {
        "line": 408,
        "fullcodeline": "&& !bed->want_p_paddr_set_to_zero"
    },
    {
        "line": 414,
        "fullcodeline": "+ (map->includes_phdrs"
    },
    {
        "line": 439,
        "fullcodeline": "suggested_lma = output_section;"
    },
    {
        "line": 552,
        "fullcodeline": "if (align_power (map->p_paddr"
    },
    {
        "line": 591,
        "fullcodeline": "suggested_lma = output_section;"
    },
    {
        "line": 407,
        "fullcodeline": "&& segment->p_vaddr != 0"
    },
    {
        "line": 412,
        "fullcodeline": "+ (map->includes_filehdr"
    },
    {
        "line": 415,
        "fullcodeline": "? iehdr->e_phnum * iehdr->e_phentsize"
    },
    {
        "line": 559,
        "fullcodeline": "!= output_section->lma * opb)"
    },
    {
        "line": 571,
        "fullcodeline": "if ((BFD_ALIGN (prev_sec->lma + prev_sec->size,"
    },
    {
        "line": 558,
        "fullcodeline": "output_section->alignment_power * opb)"
    },
    {
        "line": 566,
        "fullcodeline": "prev_sec = map->sections[map->count - 1];"
    },
    {
        "line": 574,
        "fullcodeline": "|| (prev_sec->lma + prev_sec->size"
    },
    {
        "line": 555,
        "fullcodeline": "+ (map->includes_phdrs"
    },
    {
        "line": 573,
        "fullcodeline": "< BFD_ALIGN (output_section->lma, maxpagesize))"
    },
    {
        "line": 577,
        "fullcodeline": "if (suggested_lma == NULL)"
    },
    {
        "line": 553,
        "fullcodeline": "+ (map->includes_filehdr"
    },
    {
        "line": 556,
        "fullcodeline": "? iehdr->e_phnum * iehdr->e_phentsize"
    },
    {
        "line": 578,
        "fullcodeline": "suggested_lma = output_section;"
    }
]