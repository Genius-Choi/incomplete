[
    {
        "line": 4,
        "fullcodeline": "struct device\t\t*dev = &pdev->dev;"
    },
    {
        "line": 6,
        "fullcodeline": "struct resource\t\t*res, *parent_res = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "qcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL);"
    },
    {
        "line": 14,
        "fullcodeline": "platform_set_drvdata(pdev, qcom);"
    },
    {
        "line": 15,
        "fullcodeline": "qcom->dev = &pdev->dev;"
    },
    {
        "line": 25,
        "fullcodeline": "qcom->resets = devm_reset_control_array_get_optional_exclusive(dev);"
    },
    {
        "line": 32,
        "fullcodeline": "ret = reset_control_assert(qcom->resets);"
    },
    {
        "line": 38,
        "fullcodeline": "usleep_range(10, 1000);"
    },
    {
        "line": 40,
        "fullcodeline": "ret = reset_control_deassert(qcom->resets);"
    },
    {
        "line": 46,
        "fullcodeline": "ret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np));"
    },
    {
        "line": 52,
        "fullcodeline": "res = platform_get_resource(pdev, IORESOURCE_MEM, 0);"
    },
    {
        "line": 75,
        "fullcodeline": "qcom->qscratch_base = devm_ioremap_resource(dev, parent_res);"
    },
    {
        "line": 81,
        "fullcodeline": "ret = dwc3_qcom_setup_irq(pdev);"
    },
    {
        "line": 91,
        "fullcodeline": "ignore_pipe_clk = device_property_read_bool(dev,"
    },
    {
        "line": 106,
        "fullcodeline": "ret = dwc3_qcom_interconnect_init(qcom);"
    },
    {
        "line": 110,
        "fullcodeline": "qcom->mode = usb_get_dr_mode(&qcom->dwc3->dev);"
    },
    {
        "line": 117,
        "fullcodeline": "ret = dwc3_qcom_register_extcon(qcom);"
    },
    {
        "line": 121,
        "fullcodeline": "device_init_wakeup(&pdev->dev, 1);"
    },
    {
        "line": 122,
        "fullcodeline": "qcom->is_suspended = false;"
    },
    {
        "line": 123,
        "fullcodeline": "pm_runtime_set_active(dev);"
    },
    {
        "line": 124,
        "fullcodeline": "pm_runtime_enable(dev);"
    },
    {
        "line": 125,
        "fullcodeline": "pm_runtime_forbid(dev);"
    },
    {
        "line": 130,
        "fullcodeline": "dwc3_qcom_interconnect_exit(qcom);"
    },
    {
        "line": 142,
        "fullcodeline": "reset_control_assert(qcom->resets);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!qcom)"
    },
    {
        "line": 17,
        "fullcodeline": "if (has_acpi_companion(dev)) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (IS_ERR(qcom->resets)) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (IS_ERR(qcom->qscratch_base)) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (qcom->mode == USB_DR_MODE_PERIPHERAL)"
    },
    {
        "line": 137,
        "fullcodeline": "for (i = qcom->num_clocks - 1; i >= 0; i--) {"
    },
    {
        "line": 18,
        "fullcodeline": "qcom->acpi_pdata = acpi_device_get_match_data(dev);"
    },
    {
        "line": 27,
        "fullcodeline": "ret = PTR_ERR(qcom->resets);"
    },
    {
        "line": 28,
        "fullcodeline": "dev_err(&pdev->dev, \"failed to get resets, err=%d\\n\", ret);"
    },
    {
        "line": 34,
        "fullcodeline": "dev_err(&pdev->dev, \"failed to assert resets, err=%d\\n\", ret);"
    },
    {
        "line": 42,
        "fullcodeline": "dev_err(&pdev->dev, \"failed to deassert resets, err=%d\\n\", ret);"
    },
    {
        "line": 48,
        "fullcodeline": "dev_err(dev, \"failed to get clocks\\n\");"
    },
    {
        "line": 55,
        "fullcodeline": "parent_res = res;"
    },
    {
        "line": 77,
        "fullcodeline": "ret = PTR_ERR(qcom->qscratch_base);"
    },
    {
        "line": 83,
        "fullcodeline": "dev_err(dev, \"failed to setup IRQs, err=%d\\n\", ret);"
    },
    {
        "line": 94,
        "fullcodeline": "dwc3_qcom_select_utmi_clk(qcom);"
    },
    {
        "line": 97,
        "fullcodeline": "ret = dwc3_qcom_of_register_core(pdev);"
    },
    {
        "line": 102,
        "fullcodeline": "dev_err(dev, \"failed to register DWC3 Core, err=%d\\n\", ret);"
    },
    {
        "line": 114,
        "fullcodeline": "dwc3_qcom_vbus_override_enable(qcom, true);"
    },
    {
        "line": 133,
        "fullcodeline": "of_platform_depopulate(&pdev->dev);"
    },
    {
        "line": 138,
        "fullcodeline": "clk_disable_unprepare(qcom->clks[i]);"
    },
    {
        "line": 139,
        "fullcodeline": "clk_put(qcom->clks[i]);"
    },
    {
        "line": 12,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 19,
        "fullcodeline": "if (!qcom->acpi_pdata) {"
    },
    {
        "line": 57,
        "fullcodeline": "parent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL);"
    },
    {
        "line": 61,
        "fullcodeline": "parent_res->start = res->start +"
    },
    {
        "line": 63,
        "fullcodeline": "parent_res->end = parent_res->start +"
    },
    {
        "line": 99,
        "fullcodeline": "ret = dwc3_qcom_acpi_register_core(pdev);"
    },
    {
        "line": 135,
        "fullcodeline": "platform_device_put(pdev);"
    },
    {
        "line": 20,
        "fullcodeline": "dev_err(&pdev->dev, \"no supporting ACPI device data\\n\");"
    },
    {
        "line": 58,
        "fullcodeline": "if (!parent_res)"
    },
    {
        "line": 21,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 67,
        "fullcodeline": "qcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);"
    },
    {
        "line": 59,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 68,
        "fullcodeline": "if (!qcom->urs_usb) {"
    },
    {
        "line": 69,
        "fullcodeline": "dev_err(dev, \"failed to create URS USB platdev\\n\");"
    },
    {
        "line": 70,
        "fullcodeline": "return -ENODEV;"
    }
]