[
    {
        "line": 4,
        "fullcodeline": "struct zip *zip = (struct zip *)a->format->data;"
    },
    {
        "line": 6,
        "fullcodeline": "int64_t offset = archive_filter_bytes(&a->archive, 0);"
    },
    {
        "line": 9,
        "fullcodeline": "int ret = ARCHIVE_OK, eof;"
    },
    {
        "line": 45,
        "fullcodeline": "metadata = malloc((size_t)rsrc->uncompressed_size);"
    },
    {
        "line": 58,
        "fullcodeline": "hsize = zip_get_local_file_header_size(a, 0);"
    },
    {
        "line": 59,
        "fullcodeline": "__archive_read_consume(a, hsize);"
    },
    {
        "line": 61,
        "fullcodeline": "remaining_bytes = (size_t)rsrc->compressed_size;"
    },
    {
        "line": 62,
        "fullcodeline": "metadata_bytes = (size_t)rsrc->uncompressed_size;"
    },
    {
        "line": 63,
        "fullcodeline": "mp = metadata;"
    },
    {
        "line": 64,
        "fullcodeline": "eof = 0;"
    },
    {
        "line": 139,
        "fullcodeline": "archive_entry_copy_mac_metadata(entry, metadata,"
    },
    {
        "line": 32,
        "fullcodeline": "if (rsrc->uncompressed_size > (4 * 1024 * 1024)) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (rsrc->compressed_size > (4 * 1024 * 1024)) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (metadata == NULL) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (offset < rsrc->local_header_offset)"
    },
    {
        "line": 65,
        "fullcodeline": "while (!eof && remaining_bytes) {"
    },
    {
        "line": 140,
        "fullcodeline": "(size_t)rsrc->uncompressed_size - metadata_bytes);"
    },
    {
        "line": 47,
        "fullcodeline": "archive_set_error(&a->archive, ENOMEM,"
    },
    {
        "line": 53,
        "fullcodeline": "__archive_read_consume(a, rsrc->local_header_offset - offset);"
    },
    {
        "line": 70,
        "fullcodeline": "p = __archive_read_ahead(a, 1, &bytes_avail);"
    },
    {
        "line": 136,
        "fullcodeline": "__archive_read_consume(a, bytes_used);"
    },
    {
        "line": 137,
        "fullcodeline": "remaining_bytes -= bytes_used;"
    },
    {
        "line": 13,
        "fullcodeline": "if (rsrc->uncompressed_size != rsrc->compressed_size) {"
    },
    {
        "line": 26,
        "fullcodeline": "compression_name(rsrc->compression));"
    },
    {
        "line": 71,
        "fullcodeline": "if (p == NULL) {"
    },
    {
        "line": 78,
        "fullcodeline": "if ((size_t)bytes_avail > remaining_bytes)"
    },
    {
        "line": 14,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
    },
    {
        "line": 54,
        "fullcodeline": "else if (offset != rsrc->local_header_offset) {"
    },
    {
        "line": 75,
        "fullcodeline": "ret = ARCHIVE_WARN;"
    },
    {
        "line": 79,
        "fullcodeline": "bytes_avail = remaining_bytes;"
    },
    {
        "line": 84,
        "fullcodeline": "memcpy(mp, p, bytes_avail);"
    },
    {
        "line": 85,
        "fullcodeline": "bytes_used = (size_t)bytes_avail;"
    },
    {
        "line": 86,
        "fullcodeline": "metadata_bytes -= bytes_used;"
    },
    {
        "line": 87,
        "fullcodeline": "mp += bytes_used;"
    },
    {
        "line": 133,
        "fullcodeline": "bytes_used = 0;"
    },
    {
        "line": 55,
        "fullcodeline": "__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);"
    },
    {
        "line": 82,
        "fullcodeline": "if ((size_t)bytes_avail > metadata_bytes)"
    },
    {
        "line": 88,
        "fullcodeline": "if (metadata_bytes == 0)"
    },
    {
        "line": 83,
        "fullcodeline": "bytes_avail = metadata_bytes;"
    },
    {
        "line": 89,
        "fullcodeline": "eof = 1;"
    }
]