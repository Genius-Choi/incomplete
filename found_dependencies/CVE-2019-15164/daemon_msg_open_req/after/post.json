[
    {
        "line": 4,
        "fullcodeline": "char errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors"
    },
    {
        "line": 5,
        "fullcodeline": "char errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client"
    },
    {
        "line": 8,
        "fullcodeline": "char sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered"
    },
    {
        "line": 9,
        "fullcodeline": "int sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered"
    },
    {
        "line": 18,
        "fullcodeline": "nread = sock_recv(pars->sockctrl, source, plen,"
    },
    {
        "line": 25,
        "fullcodeline": "source[nread] = '\\0';"
    },
    {
        "line": 26,
        "fullcodeline": "plen -= nread;"
    },
    {
        "line": 50,
        "fullcodeline": "rpcap_createhdr((struct rpcap_header *) sendbuf, ver,"
    },
    {
        "line": 53,
        "fullcodeline": "openreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];"
    },
    {
        "line": 59,
        "fullcodeline": "memset(openreply, 0, sizeof(struct rpcap_openreply));"
    },
    {
        "line": 60,
        "fullcodeline": "openreply->linktype = htonl(pcap_datalink(fp));"
    },
    {
        "line": 61,
        "fullcodeline": "openreply->tzoff = 0; /* This is always 0 for live captures */"
    },
    {
        "line": 64,
        "fullcodeline": "pcap_close(fp);"
    },
    {
        "line": 12,
        "fullcodeline": "if (plen > sourcelen - 1)"
    },
    {
        "line": 20,
        "fullcodeline": "if (nread == -1)"
    },
    {
        "line": 30,
        "fullcodeline": "if (is_url(source))"
    },
    {
        "line": 38,
        "fullcodeline": "if ((fp = pcap_open_live(source,"
    },
    {
        "line": 46,
        "fullcodeline": "if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,"
    },
    {
        "line": 55,
        "fullcodeline": "if (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,"
    },
    {
        "line": 67,
        "fullcodeline": "if (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)"
    },
    {
        "line": 75,
        "fullcodeline": "if (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,"
    },
    {
        "line": 84,
        "fullcodeline": "if (rpcapd_discard(pars->sockctrl, plen) == -1)"
    },
    {
        "line": 14,
        "fullcodeline": "pcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");"
    },
    {
        "line": 19,
        "fullcodeline": "SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);"
    },
    {
        "line": 22,
        "fullcodeline": "rpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);"
    },
    {
        "line": 32,
        "fullcodeline": "pcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");"
    },
    {
        "line": 47,
        "fullcodeline": "RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)"
    },
    {
        "line": 56,
        "fullcodeline": "RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)"
    },
    {
        "line": 69,
        "fullcodeline": "rpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);"
    },
    {
        "line": 76,
        "fullcodeline": "errmsgbuf, errbuf) == -1)"
    },
    {
        "line": 79,
        "fullcodeline": "rpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);"
    },
    {
        "line": 23,
        "fullcodeline": "return -1;"
    },
    {
        "line": 70,
        "fullcodeline": "return -1;"
    },
    {
        "line": 80,
        "fullcodeline": "return -1;"
    },
    {
        "line": 86,
        "fullcodeline": "return -1;"
    }
]