[
    {
        "line": 10,
        "fullcodeline": "bool decode, ignore_reg_unreg = false;"
    },
    {
        "line": 30,
        "fullcodeline": "ops = dev->dev_ops;"
    },
    {
        "line": 13,
        "fullcodeline": "if (bi != NULL) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (dev == NULL || (bytes != 1 && bytes != 2 && bytes != 4) ||"
    },
    {
        "line": 40,
        "fullcodeline": "if (strcmp(\"passthru\", ops->class_name)) {"
    },
    {
        "line": 24,
        "fullcodeline": "(coff & (bytes - 1)) != 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "pci_emul_hdrtype_fixup(bus, slot, coff, bytes, eax);"
    },
    {
        "line": 17,
        "fullcodeline": "dev = NULL;"
    },
    {
        "line": 41,
        "fullcodeline": "if (coff >= PCI_REGMAX + 1) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (ops->vdev_cfgread != NULL) {"
    },
    {
        "line": 26,
        "fullcodeline": "*eax = 0xffffffff;"
    },
    {
        "line": 64,
        "fullcodeline": "needcfg = ops->vdev_cfgread(ctx, vcpu, dev, coff, bytes,"
    },
    {
        "line": 71,
        "fullcodeline": "*eax = CFGREAD(dev, coff, bytes);"
    },
    {
        "line": 76,
        "fullcodeline": "if (ops->vdev_cfgwrite != NULL &&"
    },
    {
        "line": 84,
        "fullcodeline": "if (coff >= PCIR_BAR(0) && coff < PCIR_BAR(PCI_BARMAX + 1)) {"
    },
    {
        "line": 67,
        "fullcodeline": "needcfg = 1;"
    },
    {
        "line": 77,
        "fullcodeline": "(*ops->vdev_cfgwrite)(ctx, vcpu, dev,"
    },
    {
        "line": 91,
        "fullcodeline": "idx = (coff - PCIR_BAR(0)) / 4;"
    },
    {
        "line": 92,
        "fullcodeline": "mask = ~(dev->bar[idx].size - 1);"
    },
    {
        "line": 167,
        "fullcodeline": "pci_set_cfgdata32(dev, coff, bar);"
    },
    {
        "line": 43,
        "fullcodeline": "*eax = 0xffffffff;"
    },
    {
        "line": 89,
        "fullcodeline": "if (bytes != 4 || (coff & 0x3) != 0)"
    },
    {
        "line": 94,
        "fullcodeline": "if (dev->bar[idx].type == PCIBAR_IO)"
    },
    {
        "line": 51,
        "fullcodeline": "if (coff <= PCI_REGMAX + 4)"
    },
    {
        "line": 95,
        "fullcodeline": "decode = porten(dev);"
    },
    {
        "line": 119,
        "fullcodeline": "dev->bar[idx].addr = bar = 0;"
    },
    {
        "line": 122,
        "fullcodeline": "addr = *eax & mask;"
    },
    {
        "line": 123,
        "fullcodeline": "addr &= 0xffff;"
    },
    {
        "line": 124,
        "fullcodeline": "bar = addr | PCIM_BAR_IO_SPACE;"
    },
    {
        "line": 135,
        "fullcodeline": "addr = bar = *eax & mask;"
    },
    {
        "line": 136,
        "fullcodeline": "bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32;"
    },
    {
        "line": 144,
        "fullcodeline": "addr = bar = *eax & mask;"
    },
    {
        "line": 145,
        "fullcodeline": "bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 |"
    },
    {
        "line": 154,
        "fullcodeline": "assert(idx >= 1);"
    },
    {
        "line": 155,
        "fullcodeline": "mask = ~(dev->bar[idx - 1].size - 1);"
    },
    {
        "line": 156,
        "fullcodeline": "addr = ((uint64_t)*eax << 32) & mask;"
    },
    {
        "line": 157,
        "fullcodeline": "bar = addr >> 32;"
    },
    {
        "line": 165,
        "fullcodeline": "assert(0);"
    },
    {
        "line": 169,
        "fullcodeline": "} else if (coff == PCIR_BIOS) {"
    },
    {
        "line": 52,
        "fullcodeline": "*eax = 0x00000000;"
    },
    {
        "line": 97,
        "fullcodeline": "decode = memen(dev);"
    },
    {
        "line": 108,
        "fullcodeline": "if (!dev->bar[idx].sizing && (*eax == ~0U)) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (addr != dev->bar[idx].addr) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (addr != dev->bar[idx].addr) {"
    },
    {
        "line": 147,
        "fullcodeline": "if (addr != (uint32_t)dev->bar[idx].addr) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (bar != dev->bar[idx - 1].addr >> 32) {"
    },
    {
        "line": 109,
        "fullcodeline": "dev->bar[idx].sizing = true;"
    },
    {
        "line": 110,
        "fullcodeline": "ignore_reg_unreg = true;"
    },
    {
        "line": 129,
        "fullcodeline": "update_bar_address(ctx, dev, addr, idx,"
    },
    {
        "line": 138,
        "fullcodeline": "update_bar_address(ctx, dev, addr, idx,"
    },
    {
        "line": 148,
        "fullcodeline": "update_bar_address(ctx, dev, addr, idx,"
    },
    {
        "line": 159,
        "fullcodeline": "update_bar_address(ctx, dev, addr, idx - 1,"
    },
    {
        "line": 171,
        "fullcodeline": "} else if (pci_emul_iscap(dev, coff)) {"
    },
    {
        "line": 111,
        "fullcodeline": "} else if (dev->bar[idx].sizing && (*eax != ~0U)) {"
    },
    {
        "line": 172,
        "fullcodeline": "pci_emul_capwrite(dev, coff, bytes, *eax);"
    },
    {
        "line": 112,
        "fullcodeline": "dev->bar[idx].sizing = false;"
    },
    {
        "line": 113,
        "fullcodeline": "ignore_reg_unreg = true;"
    },
    {
        "line": 173,
        "fullcodeline": "} else if (coff >= PCIR_COMMAND && coff < PCIR_REVID) {"
    },
    {
        "line": 174,
        "fullcodeline": "pci_emul_cmdsts_write(dev, coff, *eax, bytes);"
    },
    {
        "line": 176,
        "fullcodeline": "CFGWRITE(dev, coff, *eax, bytes);"
    }
]