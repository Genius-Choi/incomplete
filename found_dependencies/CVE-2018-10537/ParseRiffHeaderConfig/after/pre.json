[
    {
        "line": 3,
        "fullcodeline": "int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0, format_chunk = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "int64_t total_samples = 0, infilesize;"
    },
    {
        "line": 11,
        "fullcodeline": "CLEAR (WaveHeader);"
    },
    {
        "line": 12,
        "fullcodeline": "CLEAR (ds64_chunk);"
    },
    {
        "line": 13,
        "fullcodeline": "infilesize = DoGetFileSize (infile);"
    },
    {
        "line": 20,
        "fullcodeline": "memcpy (&riff_chunk_header, fourcc, 4);"
    },
    {
        "line": 15,
        "fullcodeline": "if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {"
    },
    {
        "line": 16,
        "fullcodeline": "error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");"
    },
    {
        "line": 22,
        "fullcodeline": "if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||"
    },
    {
        "line": 23,
        "fullcodeline": "bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {"
    },
    {
        "line": 48,
        "fullcodeline": "WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);"
    },
    {
        "line": 268,
        "fullcodeline": "if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {"
    },
    {
        "line": 269,
        "fullcodeline": "error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 37,
        "fullcodeline": "if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||"
    },
    {
        "line": 38,
        "fullcodeline": "bcount != sizeof (ChunkHeader)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {"
    },
    {
        "line": 63,
        "fullcodeline": "got_ds64 = 1;"
    },
    {
        "line": 64,
        "fullcodeline": "WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);"
    },
    {
        "line": 27,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 28,
        "fullcodeline": "!WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {"
    },
    {
        "line": 76,
        "fullcodeline": "while (ds64_chunk.tableLength--) {"
    },
    {
        "line": 29,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 51,
        "fullcodeline": "if (chunk_header.ckSize < sizeof (DS64Chunk) ||"
    },
    {
        "line": 53,
        "fullcodeline": "bcount != sizeof (DS64Chunk)) {"
    },
    {
        "line": 67,
        "fullcodeline": "error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\","
    },
    {
        "line": 71,
        "fullcodeline": "if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {"
    },
    {
        "line": 42,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 43,
        "fullcodeline": "!WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {"
    },
    {
        "line": 52,
        "fullcodeline": "!DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||"
    },
    {
        "line": 87,
        "fullcodeline": "else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and"
    },
    {
        "line": 88,
        "fullcodeline": "int supported = TRUE, format;                        // make sure it's a .wav file we can handle"
    },
    {
        "line": 107,
        "fullcodeline": "WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);"
    },
    {
        "line": 128,
        "fullcodeline": "format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?"
    },
    {
        "line": 131,
        "fullcodeline": "config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?"
    },
    {
        "line": 44,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 78,
        "fullcodeline": "if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||"
    },
    {
        "line": 80,
        "fullcodeline": "(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 154,
        "fullcodeline": "if (chunk_header.ckSize < 40) {"
    },
    {
        "line": 57,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 58,
        "fullcodeline": "!WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {"
    },
    {
        "line": 79,
        "fullcodeline": "bcount != sizeof (CS64Chunk) ||"
    },
    {
        "line": 81,
        "fullcodeline": "!WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {"
    },
    {
        "line": 82,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 95,
        "fullcodeline": "if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||"
    },
    {
        "line": 97,
        "fullcodeline": "bcount != chunk_header.ckSize) {"
    },
    {
        "line": 110,
        "fullcodeline": "error_line (\"format tag size = %d\", chunk_header.ckSize);"
    },
    {
        "line": 111,
        "fullcodeline": "error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\","
    },
    {
        "line": 113,
        "fullcodeline": "error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\","
    },
    {
        "line": 125,
        "fullcodeline": "if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)"
    },
    {
        "line": 126,
        "fullcodeline": "config->qmode |= QMODE_ADOBE_MODE;"
    },
    {
        "line": 134,
        "fullcodeline": "if (format != 1 && format != 3)"
    },
    {
        "line": 135,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 137,
        "fullcodeline": "if (format == 3 && config->bits_per_sample != 32)"
    },
    {
        "line": 138,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 140,
        "fullcodeline": "if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||"
    },
    {
        "line": 143,
        "fullcodeline": "WaveHeader.BlockAlign % WaveHeader.NumChannels)"
    },
    {
        "line": 144,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 146,
        "fullcodeline": "if (config->bits_per_sample < 1 || config->bits_per_sample > 32)"
    },
    {
        "line": 147,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 172,
        "fullcodeline": "config->float_norm_exp = 127;"
    },
    {
        "line": 59,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 96,
        "fullcodeline": "!DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||"
    },
    {
        "line": 116,
        "fullcodeline": "if (chunk_header.ckSize > 16)"
    },
    {
        "line": 120,
        "fullcodeline": "if (chunk_header.ckSize > 20)"
    },
    {
        "line": 142,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||"
    },
    {
        "line": 182,
        "fullcodeline": "if (config->float_norm_exp == 127)"
    },
    {
        "line": 192,
        "fullcodeline": "else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop"
    },
    {
        "line": 194,
        "fullcodeline": "int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?"
    },
    {
        "line": 233,
        "fullcodeline": "config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;"
    },
    {
        "line": 234,
        "fullcodeline": "config->num_channels = WaveHeader.NumChannels;"
    },
    {
        "line": 235,
        "fullcodeline": "config->sample_rate = WaveHeader.SampleRate;"
    },
    {
        "line": 117,
        "fullcodeline": "error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,"
    },
    {
        "line": 121,
        "fullcodeline": "error_line (\"ChannelMask = %x, SubFormat = %d\","
    },
    {
        "line": 141,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||"
    },
    {
        "line": 155,
        "fullcodeline": "if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {"
    },
    {
        "line": 164,
        "fullcodeline": "else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {"
    },
    {
        "line": 208,
        "fullcodeline": "if (config->qmode & QMODE_IGNORE_LENGTH) {"
    },
    {
        "line": 240,
        "fullcodeline": "int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;"
    },
    {
        "line": 248,
        "fullcodeline": "buff = malloc (bytes_to_copy);"
    },
    {
        "line": 101,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 102,
        "fullcodeline": "!WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {"
    },
    {
        "line": 156,
        "fullcodeline": "if (WaveHeader.NumChannels <= 2)"
    },
    {
        "line": 173,
        "fullcodeline": "else if ((config->qmode & QMODE_ADOBE_MODE) &&"
    },
    {
        "line": 174,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)"
    },
    {
        "line": 203,
        "fullcodeline": "if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {"
    },
    {
        "line": 103,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 157,
        "fullcodeline": "config->channel_mask = 0x5 - WaveHeader.NumChannels;"
    },
    {
        "line": 175,
        "fullcodeline": "if (WaveHeader.BitsPerSample == 24)"
    },
    {
        "line": 209,
        "fullcodeline": "if (infilesize && DoGetFilePosition (infile) != -1)"
    },
    {
        "line": 215,
        "fullcodeline": "total_samples = data_chunk_size / WaveHeader.BlockAlign;"
    },
    {
        "line": 243,
        "fullcodeline": "if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {"
    },
    {
        "line": 251,
        "fullcodeline": "error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\","
    },
    {
        "line": 255,
        "fullcodeline": "if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||"
    },
    {
        "line": 257,
        "fullcodeline": "(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 176,
        "fullcodeline": "config->float_norm_exp = 127 + 23;"
    },
    {
        "line": 210,
        "fullcodeline": "total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;"
    },
    {
        "line": 222,
        "fullcodeline": "if (!total_samples) {"
    },
    {
        "line": 227,
        "fullcodeline": "if (total_samples > MAX_WAVPACK_SAMPLES) {"
    },
    {
        "line": 256,
        "fullcodeline": "bcount != bytes_to_copy ||"
    },
    {
        "line": 258,
        "fullcodeline": "!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {"
    },
    {
        "line": 259,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 158,
        "fullcodeline": "else if (WaveHeader.NumChannels <= 18)"
    },
    {
        "line": 169,
        "fullcodeline": "config->channel_mask = WaveHeader.ChannelMask;"
    },
    {
        "line": 186,
        "fullcodeline": "config->float_norm_exp - 126, 150 - config->float_norm_exp);"
    },
    {
        "line": 188,
        "fullcodeline": "error_line (\"data format: %d-bit integers stored in %d byte(s)\","
    },
    {
        "line": 212,
        "fullcodeline": "total_samples = -1;"
    },
    {
        "line": 217,
        "fullcodeline": "if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {"
    },
    {
        "line": 159,
        "fullcodeline": "config->channel_mask = (1 << WaveHeader.NumChannels) - 1;"
    },
    {
        "line": 177,
        "fullcodeline": "else if (WaveHeader.BitsPerSample == 32)"
    },
    {
        "line": 189,
        "fullcodeline": "config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);"
    },
    {
        "line": 161,
        "fullcodeline": "config->channel_mask = 0x3ffff;"
    },
    {
        "line": 178,
        "fullcodeline": "config->float_norm_exp = 127 + 15;"
    }
]