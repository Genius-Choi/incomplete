[
    {
        "line": 3,
        "fullcodeline": "int bugs = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "if (!inifile.isDirty())"
    },
    {
        "line": 89,
        "fullcodeline": "return bugs ? -1 : 0;"
    },
    {
        "line": 6,
        "fullcodeline": "y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());"
    },
    {
        "line": 19,
        "fullcodeline": "ci = inifile.getContainerBegin (),"
    },
    {
        "line": 20,
        "fullcodeline": "ce = inifile.getContainerEnd ();"
    },
    {
        "line": 22,
        "fullcodeline": "for (;ci != ce; ++ci)"
    },
    {
        "line": 65,
        "fullcodeline": "for (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)"
    },
    {
        "line": 74,
        "fullcodeline": "Pathname pn (file);"
    },
    {
        "line": 83,
        "fullcodeline": "write_helper (inifile, of, 0);"
    },
    {
        "line": 86,
        "fullcodeline": "timestamp = getTimeStamp ();"
    },
    {
        "line": 11,
        "fullcodeline": "y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());"
    },
    {
        "line": 75,
        "fullcodeline": "PathInfo::assert_dir (pn.dirname ());"
    },
    {
        "line": 76,
        "fullcodeline": "ofstream of(file.c_str());"
    },
    {
        "line": 24,
        "fullcodeline": "if (ci->t () == SECTION)"
    },
    {
        "line": 66,
        "fullcodeline": "if (multi_files.find (*i) != multi_files.end ()) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (!of.good())"
    },
    {
        "line": 26,
        "fullcodeline": "IniSection&s = ci->s ();"
    },
    {
        "line": 27,
        "fullcodeline": "int wb = s.getRewriteBy (); // bug #19066"
    },
    {
        "line": 28,
        "fullcodeline": "string filename = getFileName (s.getName (), wb);"
    },
    {
        "line": 34,
        "fullcodeline": "deleted_sections.erase (filename);"
    },
    {
        "line": 40,
        "fullcodeline": "s.initReadBy ();"
    },
    {
        "line": 42,
        "fullcodeline": "Pathname pn (filename);"
    },
    {
        "line": 51,
        "fullcodeline": "write_helper (s, of, 0);"
    },
    {
        "line": 53,
        "fullcodeline": "of.close ();"
    },
    {
        "line": 67,
        "fullcodeline": "y2debug (\"Removing file %s\\n\", (*i).c_str());"
    },
    {
        "line": 68,
        "fullcodeline": "unlink ((*i).c_str());"
    },
    {
        "line": 79,
        "fullcodeline": "y2error (\"Can not open file %s for write\", file.c_str());"
    },
    {
        "line": 80,
        "fullcodeline": "return -1;"
    },
    {
        "line": 43,
        "fullcodeline": "PathInfo::assert_dir (pn.dirname ());"
    },
    {
        "line": 44,
        "fullcodeline": "ofstream of(filename.c_str());"
    },
    {
        "line": 36,
        "fullcodeline": "if (!s.isDirty ()) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (!of.good())"
    },
    {
        "line": 58,
        "fullcodeline": "ci->e ().getName ());"
    },
    {
        "line": 37,
        "fullcodeline": "y2debug (\"Skipping file %s that was not changed.\", filename.c_str());"
    },
    {
        "line": 48,
        "fullcodeline": "y2error (\"Can not open file %s for write\", filename.c_str());"
    }
]