[
    {
        "line": 3,
        "fullcodeline": "char *buf = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "int rc = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "size_t len = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "size_t chunk_size = max_size ? max_size : 1024;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t buf_size = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t read_size = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "buf = calloc(1, chunk_size + 1);"
    },
    {
        "line": 18,
        "fullcodeline": "buf_size = chunk_size;"
    },
    {
        "line": 10,
        "fullcodeline": "if (session == NULL) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (!len) {"
    },
    {
        "line": 21,
        "fullcodeline": "read_size = buf_size - len;"
    },
    {
        "line": 33,
        "fullcodeline": "rc = gnutls_record_recv(*session, buf + len, read_size);"
    },
    {
        "line": 67,
        "fullcodeline": "*recv_len = len;"
    },
    {
        "line": 71,
        "fullcodeline": "buf = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "if (!max_size && (read_size < (chunk_size / 2))) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (rc > 0) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (max_size && (max_size == read_size)) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (rc == GNUTLS_E_INTERRUPTED) {"
    },
    {
        "line": 12,
        "fullcodeline": "*disconnected = 1;"
    },
    {
        "line": 25,
        "fullcodeline": "buf_size += chunk_size;"
    },
    {
        "line": 26,
        "fullcodeline": "crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);"
    },
    {
        "line": 27,
        "fullcodeline": "buf = realloc(buf, buf_size + 1);"
    },
    {
        "line": 28,
        "fullcodeline": "CRM_ASSERT(buf != NULL);"
    },
    {
        "line": 30,
        "fullcodeline": "read_size = buf_size - len;"
    },
    {
        "line": 36,
        "fullcodeline": "crm_trace(\"Got %d more bytes.\", rc);"
    },
    {
        "line": 37,
        "fullcodeline": "len += rc;"
    },
    {
        "line": 39,
        "fullcodeline": "buf[len] = '\\0';"
    },
    {
        "line": 42,
        "fullcodeline": "crm_trace(\"Buffer max read size %d met\" , max_size);"
    },
    {
        "line": 48,
        "fullcodeline": "crm_trace(\"EINTR encoutered, retry tls read\");"
    },
    {
        "line": 49,
        "fullcodeline": "} else if (rc == GNUTLS_E_AGAIN) {"
    },
    {
        "line": 50,
        "fullcodeline": "crm_trace(\"non-blocking, exiting read on rc = %d\", rc);"
    },
    {
        "line": 52,
        "fullcodeline": "} else if (rc <= 0) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (rc == 0) {"
    },
    {
        "line": 54,
        "fullcodeline": "crm_debug(\"EOF encoutered during TLS read\");"
    },
    {
        "line": 59,
        "fullcodeline": "*disconnected = 1;"
    },
    {
        "line": 56,
        "fullcodeline": "crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);"
    }
]