[
    {
        "line": 6,
        "fullcodeline": "MOBI_RET ret = MOBI_SUCCESS;"
    },
    {
        "line": 7,
        "fullcodeline": "int8_t bitcount = 32;"
    },
    {
        "line": 9,
        "fullcodeline": "int bitsleft = (int) (buf_in->maxlen * 8);"
    },
    {
        "line": 10,
        "fullcodeline": "uint8_t code_length = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "uint64_t buffer = mobi_buffer_fill64(buf_in);"
    },
    {
        "line": 2,
        "fullcodeline": "if (depth > MOBI_HUFFMAN_MAXDEPTH) {"
    },
    {
        "line": 12,
        "fullcodeline": "while (ret == MOBI_SUCCESS) {"
    },
    {
        "line": 3,
        "fullcodeline": "debug_print(\"Too many levels of recursion: %zu\\n\", depth);"
    },
    {
        "line": 17,
        "fullcodeline": "uint32_t code = (buffer >> bitcount) & 0xffffffffU;"
    },
    {
        "line": 21,
        "fullcodeline": "code_length = t1 & 0x1f;"
    },
    {
        "line": 22,
        "fullcodeline": "uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;"
    },
    {
        "line": 34,
        "fullcodeline": "bitcount -= code_length;"
    },
    {
        "line": 35,
        "fullcodeline": "bitsleft -= code_length;"
    },
    {
        "line": 40,
        "fullcodeline": "uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);"
    },
    {
        "line": 42,
        "fullcodeline": "uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);"
    },
    {
        "line": 49,
        "fullcodeline": "uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];"
    },
    {
        "line": 51,
        "fullcodeline": "int is_decompressed = symbol_length >> 15;"
    },
    {
        "line": 53,
        "fullcodeline": "symbol_length &= 0x7fff;"
    },
    {
        "line": 13,
        "fullcodeline": "if (bitcount <= 0) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (!(t1 & 0x80)) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (bitsleft < 0) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (index >= huffcdic->index_count) {"
    },
    {
        "line": 14,
        "fullcodeline": "bitcount += 32;"
    },
    {
        "line": 15,
        "fullcodeline": "buffer = mobi_buffer_fill64(buf_in);"
    },
    {
        "line": 19,
        "fullcodeline": "uint32_t t1 = huffcdic->table1[code >> 24];"
    },
    {
        "line": 44,
        "fullcodeline": "debug_print(\"Wrong symbol offsets index: %u\\n\", index);"
    },
    {
        "line": 56,
        "fullcodeline": "mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);"
    },
    {
        "line": 57,
        "fullcodeline": "ret = buf_out->error;"
    },
    {
        "line": 26,
        "fullcodeline": "while (code < huffcdic->mincode_table[code_length]) {"
    },
    {
        "line": 62,
        "fullcodeline": "buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;"
    },
    {
        "line": 63,
        "fullcodeline": "buf_sym.offset = 0;"
    },
    {
        "line": 64,
        "fullcodeline": "buf_sym.maxlen = symbol_length;"
    },
    {
        "line": 65,
        "fullcodeline": "buf_sym.error = MOBI_SUCCESS;"
    },
    {
        "line": 66,
        "fullcodeline": "ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);"
    },
    {
        "line": 27,
        "fullcodeline": "if (++code_length >= HUFF_CODETABLE_SIZE) {"
    },
    {
        "line": 28,
        "fullcodeline": "debug_print(\"Wrong offset to mincode table: %hhu\\n\", code_length);"
    }
]