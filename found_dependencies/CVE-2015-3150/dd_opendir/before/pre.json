[
    {
        "line": 3,
        "fullcodeline": "struct dump_dir *dd = dd_init();"
    },
    {
        "line": 5,
        "fullcodeline": "dir = dd->dd_dirname = rm_trailing_slashes(dir);"
    },
    {
        "line": 11,
        "fullcodeline": "dd->mode = (stat_buf.st_mode & 0666);"
    },
    {
        "line": 13,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "dd->dd_uid = (uid_t)-1L;"
    },
    {
        "line": 62,
        "fullcodeline": "dd->dd_gid = (gid_t)-1L;"
    },
    {
        "line": 8,
        "fullcodeline": "if (stat(dir, &stat_buf) != 0)"
    },
    {
        "line": 14,
        "fullcodeline": "if (dd_lock(dd, WAIT_FOR_OTHER_PROCESS_USLEEP, flags) < 0)"
    },
    {
        "line": 73,
        "fullcodeline": "dd->dd_uid = stat_buf.st_uid;"
    },
    {
        "line": 74,
        "fullcodeline": "dd->dd_gid = stat_buf.st_gid;"
    },
    {
        "line": 16,
        "fullcodeline": "if ((flags & DD_OPEN_READONLY) && errno == EACCES)"
    },
    {
        "line": 32,
        "fullcodeline": "if (errno == EISDIR)"
    },
    {
        "line": 67,
        "fullcodeline": "if (stat(dir, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode))"
    },
    {
        "line": 20,
        "fullcodeline": "if (stat(dir, &stat_buf) == 0"
    },
    {
        "line": 22,
        "fullcodeline": "&& access(dir, R_OK) == 0"
    },
    {
        "line": 21,
        "fullcodeline": "&& S_ISDIR(stat_buf.st_mode)"
    },
    {
        "line": 24,
        "fullcodeline": "if(dd_check(dd) != NULL)"
    },
    {
        "line": 46,
        "fullcodeline": "if (errno == ENOENT || errno == ENOTDIR)"
    },
    {
        "line": 26,
        "fullcodeline": "dd_close(dd);"
    },
    {
        "line": 27,
        "fullcodeline": "dd = NULL;"
    },
    {
        "line": 48,
        "fullcodeline": "if (!(flags & DD_FAIL_QUIETLY_ENOENT))"
    },
    {
        "line": 53,
        "fullcodeline": "if (!(flags & DD_FAIL_QUIETLY_EACCES))"
    }
]