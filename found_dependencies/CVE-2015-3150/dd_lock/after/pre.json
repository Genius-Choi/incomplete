[
    {
        "line": 6,
        "fullcodeline": "char pid_buf[sizeof(long)*3 + 2];"
    },
    {
        "line": 7,
        "fullcodeline": "snprintf(pid_buf, sizeof(pid_buf), \"%lu\", (long)getpid());"
    },
    {
        "line": 9,
        "fullcodeline": "unsigned count = NO_TIME_FILE_COUNT;"
    },
    {
        "line": 46,
        "fullcodeline": "dd->locked = true;"
    },
    {
        "line": 24,
        "fullcodeline": "if (sleep_usec == WAIT_FOR_OTHER_PROCESS_USLEEP) /* yes */"
    },
    {
        "line": 4,
        "fullcodeline": "error_msg_and_die(\"Locking bug on '%s'\", dd->dd_dirname);"
    },
    {
        "line": 14,
        "fullcodeline": "int r = create_symlink_lockfile_at(dd->dd_fd, \".lock\", pid_buf);"
    },
    {
        "line": 20,
        "fullcodeline": "usleep(sleep_usec);"
    },
    {
        "line": 26,
        "fullcodeline": "const char *missing_file = dd_check(dd);"
    },
    {
        "line": 15,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 17,
        "fullcodeline": "if (r > 0)"
    },
    {
        "line": 34,
        "fullcodeline": "xunlinkat(dd->dd_fd, \".lock\", /*only files*/0);"
    },
    {
        "line": 35,
        "fullcodeline": "log_warning(\"Unlocked '%s' (no or corrupted '%s' file)\", dd->dd_dirname, missing_file);"
    },
    {
        "line": 41,
        "fullcodeline": "usleep(NO_TIME_FILE_USLEEP);"
    },
    {
        "line": 36,
        "fullcodeline": "if (--count == 0 || flags & DD_DONT_WAIT_FOR_LOCK)"
    },
    {
        "line": 38,
        "fullcodeline": "errno = EISDIR; /* \"this is an ordinary dir, not dump dir\" */"
    },
    {
        "line": 39,
        "fullcodeline": "return -1;"
    }
]