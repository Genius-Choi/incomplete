[
    {
        "line": 6,
        "fullcodeline": "DIR *dp = opendir(path);"
    },
    {
        "line": 14,
        "fullcodeline": "int brk = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "closedir(dp);"
    },
    {
        "line": 7,
        "fullcodeline": "if (!dp)"
    },
    {
        "line": 16,
        "fullcodeline": "while ((dent = readdir(dp)) != NULL)"
    },
    {
        "line": 21,
        "fullcodeline": "char *full_name = concat_path_file(path, dent->d_name);"
    },
    {
        "line": 23,
        "fullcodeline": "int dir_fd = dd_openfd(full_name);"
    },
    {
        "line": 49,
        "fullcodeline": "free(full_name);"
    },
    {
        "line": 18,
        "fullcodeline": "if (dot_or_dotdot(dent->d_name))"
    },
    {
        "line": 24,
        "fullcodeline": "if (dir_fd < 0)"
    },
    {
        "line": 30,
        "fullcodeline": "if (caller_uid == -1 || fdump_dir_accessible_by_uid(dir_fd, caller_uid))"
    },
    {
        "line": 26,
        "fullcodeline": "VERB2 perror_msg(\"can't open problem directory '%s'\", full_name);"
    },
    {
        "line": 36,
        "fullcodeline": "int sv_logmode = logmode;"
    },
    {
        "line": 37,
        "fullcodeline": "logmode = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "struct dump_dir *dd = dd_fdopendir(dir_fd, full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);"
    },
    {
        "line": 39,
        "fullcodeline": "logmode = sv_logmode;"
    },
    {
        "line": 47,
        "fullcodeline": "close(dir_fd);"
    },
    {
        "line": 42,
        "fullcodeline": "brk = callback ? callback(dd, arg) : 0;"
    },
    {
        "line": 43,
        "fullcodeline": "dd_close(dd);"
    }
]