[
    {
        "line": 3,
        "fullcodeline": "while (symlinkat(pid, dir_fd, lock_file) != 0)"
    },
    {
        "line": 16,
        "fullcodeline": "ssize_t r = readlinkat(dir_fd, lock_file, pid_buf, sizeof(pid_buf) - 1);"
    },
    {
        "line": 29,
        "fullcodeline": "pid_buf[r] = '\\0';"
    },
    {
        "line": 5,
        "fullcodeline": "if (errno != EEXIST)"
    },
    {
        "line": 15,
        "fullcodeline": "char pid_buf[sizeof(pid_t)*3 + 4];"
    },
    {
        "line": 31,
        "fullcodeline": "if (strcmp(pid_buf, pid) == 0)"
    },
    {
        "line": 39,
        "fullcodeline": "snprintf(pid_str, sizeof(pid_str), \"/proc/%s\", pid_buf);"
    },
    {
        "line": 45,
        "fullcodeline": "log(\"Lock file '%s' was locked by process %s, but it crashed?\", lock_file, pid_buf);"
    },
    {
        "line": 48,
        "fullcodeline": "if (unlinkat(dir_fd, lock_file, /*only files*/0) != 0 && errno != ENOENT)"
    },
    {
        "line": 7,
        "fullcodeline": "if (errno != ENOENT && errno != ENOTDIR && errno != EACCES)"
    },
    {
        "line": 12,
        "fullcodeline": "return -1;"
    },
    {
        "line": 27,
        "fullcodeline": "return -1;"
    },
    {
        "line": 38,
        "fullcodeline": "char pid_str[sizeof(\"/proc/\") + sizeof(pid_buf)];"
    },
    {
        "line": 52,
        "fullcodeline": "return -1;"
    },
    {
        "line": 9,
        "fullcodeline": "perror_msg(\"Can't create lock file '%s'\", lock_file);"
    },
    {
        "line": 10,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "usleep(SYMLINK_RETRY_USLEEP); /* avoid CPU eating loop */"
    },
    {
        "line": 40,
        "fullcodeline": "if (access(pid_str, F_OK) == 0)"
    }
]