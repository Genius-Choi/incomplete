[
    {
        "line": 83,
        "fullcodeline": "nested_splits = []"
    },
    {
        "line": 84,
        "fullcodeline": "values = pylist"
    },
    {
        "line": 93,
        "fullcodeline": "values = inner_factory("
    },
    {
        "line": 22,
        "fullcodeline": "if ragged_tensor.is_ragged(pylist):"
    },
    {
        "line": 25,
        "fullcodeline": "if not isinstance(pylist, (list, tuple)) and np.ndim(pylist) == 0:"
    },
    {
        "line": 36,
        "fullcodeline": "if ragged_rank is not None and ragged_rank < 0:"
    },
    {
        "line": 41,
        "fullcodeline": "scalar_depth, max_depth = _find_scalar_and_max_depth(pylist)"
    },
    {
        "line": 42,
        "fullcodeline": "if scalar_depth is not None:"
    },
    {
        "line": 68,
        "fullcodeline": "if inner_shape is None:"
    },
    {
        "line": 75,
        "fullcodeline": "if ragged_rank is None:"
    },
    {
        "line": 85,
        "fullcodeline": "for dim in range(ragged_rank):"
    },
    {
        "line": 95,
        "fullcodeline": "for row_splits in reversed(nested_splits):"
    },
    {
        "line": 23,
        "fullcodeline": "raise TypeError(\"pylist may not be a RaggedTensor or RaggedTensorValue.\")"
    },
    {
        "line": 52,
        "fullcodeline": "if inner_shape is not None and ragged_rank is not None:"
    },
    {
        "line": 53,
        "fullcodeline": "expected_depth = ragged_rank + len(inner_shape) + 1"
    },
    {
        "line": 61,
        "fullcodeline": "if (ragged_rank == 0 or"
    },
    {
        "line": 62,
        "fullcodeline": "(ragged_rank is None and"
    },
    {
        "line": 27,
        "fullcodeline": "if ragged_rank is not None and ragged_rank != 0:"
    },
    {
        "line": 30,
        "fullcodeline": "if inner_shape is not None and inner_shape:"
    },
    {
        "line": 34,
        "fullcodeline": "return inner_factory(pylist, dtype, ())"
    },
    {
        "line": 37,
        "fullcodeline": "raise ValueError("
    },
    {
        "line": 43,
        "fullcodeline": "if max_depth > scalar_depth:"
    },
    {
        "line": 46,
        "fullcodeline": "if ragged_rank is not None and max_depth < ragged_rank:"
    },
    {
        "line": 63,
        "fullcodeline": "((max_depth < 2) or"
    },
    {
        "line": 65,
        "fullcodeline": "return inner_factory(pylist, dtype, inner_shape)"
    },
    {
        "line": 69,
        "fullcodeline": "if ragged_rank is None:"
    },
    {
        "line": 76,
        "fullcodeline": "if scalar_depth is None:"
    },
    {
        "line": 86,
        "fullcodeline": "nested_splits.append([0])"
    },
    {
        "line": 87,
        "fullcodeline": "concatenated_values = []"
    },
    {
        "line": 91,
        "fullcodeline": "values = concatenated_values"
    },
    {
        "line": 94,
        "fullcodeline": "values, dtype=dtype, shape=(len(values),) + inner_shape, name=\"values\")"
    },
    {
        "line": 96,
        "fullcodeline": "values = ragged_factory(values, row_splits)"
    },
    {
        "line": 28,
        "fullcodeline": "raise ValueError(\"Invalid pylist=%r: incompatible with ragged_rank=%d\" %"
    },
    {
        "line": 31,
        "fullcodeline": "raise ValueError("
    },
    {
        "line": 38,
        "fullcodeline": "\"Invalid ragged_rank=%r: must be nonnegative\" % ragged_rank)"
    },
    {
        "line": 54,
        "fullcodeline": "if ((scalar_depth is not None and expected_depth != scalar_depth) or"
    },
    {
        "line": 55,
        "fullcodeline": "(scalar_depth is None and expected_depth < max_depth)):"
    },
    {
        "line": 64,
        "fullcodeline": "(inner_shape is not None and max_depth - len(inner_shape) < 2)))):"
    },
    {
        "line": 70,
        "fullcodeline": "inner_shape = ()"
    },
    {
        "line": 72,
        "fullcodeline": "inner_shape = _default_inner_shape_for_pylist(pylist, ragged_rank)"
    },
    {
        "line": 77,
        "fullcodeline": "ragged_rank = max(1, max_depth - 1)"
    },
    {
        "line": 79,
        "fullcodeline": "ragged_rank = max(1, scalar_depth - 1 - len(inner_shape))"
    },
    {
        "line": 88,
        "fullcodeline": "for row in values:"
    },
    {
        "line": 44,
        "fullcodeline": "raise ValueError(\"Invalid pylist=%r: empty list nesting is greater \""
    },
    {
        "line": 47,
        "fullcodeline": "raise ValueError(f\"Invalid pylist={pylist}, max depth smaller than \""
    },
    {
        "line": 56,
        "fullcodeline": "raise ValueError("
    },
    {
        "line": 32,
        "fullcodeline": "\"Invalid pylist=%r: incompatible with dim(inner_shape)=%d\" %"
    },
    {
        "line": 57,
        "fullcodeline": "\"Invalid pylist=%r: incompatible with ragged_rank=%d \""
    },
    {
        "line": 90,
        "fullcodeline": "concatenated_values.extend(row)"
    },
    {
        "line": 29,
        "fullcodeline": "(pylist, ragged_rank))"
    },
    {
        "line": 33,
        "fullcodeline": "(pylist, len(inner_shape)))"
    },
    {
        "line": 48,
        "fullcodeline": "f\"ragged_rank={ragged_rank}\")"
    },
    {
        "line": 58,
        "fullcodeline": "\"and dim(inner_shape)=%d\" % (pylist, ragged_rank, len(inner_shape)))"
    },
    {
        "line": 89,
        "fullcodeline": "nested_splits[dim].append(nested_splits[dim][-1] + len(row))"
    }
]