[
    {
        "line": 11,
        "fullcodeline": "long align=0;"
    },
    {
        "line": 22,
        "fullcodeline": "left  = rb->left;"
    },
    {
        "line": 79,
        "fullcodeline": "len = s->packet_length;"
    },
    {
        "line": 80,
        "fullcodeline": "pkt = rb->buf+align;"
    },
    {
        "line": 147,
        "fullcodeline": "rb->offset += n;"
    },
    {
        "line": 148,
        "fullcodeline": "rb->left = left - n;"
    },
    {
        "line": 149,
        "fullcodeline": "s->packet_length += n;"
    },
    {
        "line": 150,
        "fullcodeline": "s->rwstate=SSL_NOTHING;"
    },
    {
        "line": 15,
        "fullcodeline": "if (n <= 0) return n;"
    },
    {
        "line": 18,
        "fullcodeline": "if (rb->buf == NULL)"
    },
    {
        "line": 28,
        "fullcodeline": "if (!extend)"
    },
    {
        "line": 60,
        "fullcodeline": "if (SSL_IS_DTLS(s))"
    },
    {
        "line": 69,
        "fullcodeline": "if (left >= n)"
    },
    {
        "line": 84,
        "fullcodeline": "if (s->packet != pkt) /* len > 0 */"
    },
    {
        "line": 91,
        "fullcodeline": "if (n > (int)(rb->len - rb->offset)) /* does not happen */"
    },
    {
        "line": 97,
        "fullcodeline": "if (!s->read_ahead)"
    },
    {
        "line": 108,
        "fullcodeline": "while (left < n)"
    },
    {
        "line": 52,
        "fullcodeline": "s->packet = rb->buf + rb->offset;"
    },
    {
        "line": 53,
        "fullcodeline": "s->packet_length = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "s->packet_length+=n;"
    },
    {
        "line": 72,
        "fullcodeline": "rb->left=left-n;"
    },
    {
        "line": 73,
        "fullcodeline": "rb->offset+=n;"
    },
    {
        "line": 86,
        "fullcodeline": "memmove(pkt, s->packet, len+left);"
    },
    {
        "line": 87,
        "fullcodeline": "s->packet = pkt;"
    },
    {
        "line": 88,
        "fullcodeline": "rb->offset = len + align;"
    },
    {
        "line": 93,
        "fullcodeline": "SSLerr(SSL_F_SSL3_READ_N,ERR_R_INTERNAL_ERROR);"
    },
    {
        "line": 99,
        "fullcodeline": "max = n;"
    },
    {
        "line": 114,
        "fullcodeline": "clear_sys_error();"
    },
    {
        "line": 135,
        "fullcodeline": "left+=i;"
    },
    {
        "line": 19,
        "fullcodeline": "if (!ssl3_setup_read_buffer(s))"
    },
    {
        "line": 31,
        "fullcodeline": "if (left == 0)"
    },
    {
        "line": 62,
        "fullcodeline": "if (left == 0 && extend)"
    },
    {
        "line": 64,
        "fullcodeline": "if (left > 0 && n > left)"
    },
    {
        "line": 94,
        "fullcodeline": "return -1;"
    },
    {
        "line": 115,
        "fullcodeline": "if (s->rbio != NULL)"
    },
    {
        "line": 126,
        "fullcodeline": "if (i <= 0)"
    },
    {
        "line": 139,
        "fullcodeline": "if (SSL_IS_DTLS(s))"
    },
    {
        "line": 32,
        "fullcodeline": "rb->offset = align;"
    },
    {
        "line": 65,
        "fullcodeline": "n = left;"
    },
    {
        "line": 102,
        "fullcodeline": "if (max < n)"
    },
    {
        "line": 104,
        "fullcodeline": "if (max > (int)(rb->len - rb->offset))"
    },
    {
        "line": 117,
        "fullcodeline": "s->rwstate=SSL_READING;"
    },
    {
        "line": 118,
        "fullcodeline": "i=BIO_read(s->rbio,pkt+len+left, max-left);"
    },
    {
        "line": 128,
        "fullcodeline": "rb->left = left;"
    },
    {
        "line": 20,
        "fullcodeline": "return -1;"
    },
    {
        "line": 103,
        "fullcodeline": "max = n;"
    },
    {
        "line": 105,
        "fullcodeline": "max = rb->len - rb->offset;"
    },
    {
        "line": 122,
        "fullcodeline": "SSLerr(SSL_F_SSL3_READ_N,SSL_R_READ_BIO_NOT_SET);"
    },
    {
        "line": 123,
        "fullcodeline": "i = -1;"
    },
    {
        "line": 129,
        "fullcodeline": "if (s->mode & SSL_MODE_RELEASE_BUFFERS &&"
    },
    {
        "line": 141,
        "fullcodeline": "if (n > left)"
    },
    {
        "line": 33,
        "fullcodeline": "else if (align != 0 && left >= SSL3_RT_HEADER_LENGTH)"
    },
    {
        "line": 130,
        "fullcodeline": "!SSL_IS_DTLS(s))"
    },
    {
        "line": 142,
        "fullcodeline": "n = left; /* makes the while condition false */"
    },
    {
        "line": 37,
        "fullcodeline": "pkt = rb->buf + rb->offset;"
    },
    {
        "line": 131,
        "fullcodeline": "if (len+left == 0)"
    },
    {
        "line": 38,
        "fullcodeline": "if (pkt[0] == SSL3_RT_APPLICATION_DATA"
    },
    {
        "line": 132,
        "fullcodeline": "ssl3_release_read_buffer(s);"
    },
    {
        "line": 39,
        "fullcodeline": "&& (pkt[3]<<8|pkt[4]) >= 128)"
    },
    {
        "line": 48,
        "fullcodeline": "memmove (rb->buf+align,pkt,left);"
    },
    {
        "line": 49,
        "fullcodeline": "rb->offset = align;"
    }
]