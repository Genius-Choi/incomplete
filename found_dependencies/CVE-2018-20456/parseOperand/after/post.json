[
    {
        "line": 2,
        "fullcodeline": "size_t pos, nextpos = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "int size_token = 1;"
    },
    {
        "line": 5,
        "fullcodeline": "bool explicit_size = false;"
    },
    {
        "line": 6,
        "fullcodeline": "int reg_index = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "op->type = 0;"
    },
    {
        "line": 47,
        "fullcodeline": "if (str[pos] == '[') {"
    },
    {
        "line": 11,
        "fullcodeline": "pos = nextpos;"
    },
    {
        "line": 12,
        "fullcodeline": "last_type = getToken (str, &pos, &nextpos);"
    },
    {
        "line": 55,
        "fullcodeline": "op->offset = op->scale[0] = op->scale[1] = 0;"
    },
    {
        "line": 57,
        "fullcodeline": "ut64 temp = 1;"
    },
    {
        "line": 58,
        "fullcodeline": "Register reg = X86R_UNDEFINED;"
    },
    {
        "line": 59,
        "fullcodeline": "bool first_reg = true;"
    },
    {
        "line": 15,
        "fullcodeline": "if (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (!op->type) {"
    },
    {
        "line": 60,
        "fullcodeline": "while (str[pos] != ']') {"
    },
    {
        "line": 50,
        "fullcodeline": "op->type = OT_MEMORY;"
    },
    {
        "line": 65,
        "fullcodeline": "pos = nextpos;"
    },
    {
        "line": 69,
        "fullcodeline": "last_type = getToken (str, &pos, &nextpos);"
    },
    {
        "line": 163,
        "fullcodeline": "} else if (last_type == TT_WORD) {   // register"
    },
    {
        "line": 61,
        "fullcodeline": "if (pos > nextpos) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (!str[pos]) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (last_type == TT_SPECIAL) {"
    },
    {
        "line": 164,
        "fullcodeline": "nextpos = pos;"
    },
    {
        "line": 174,
        "fullcodeline": "op->reg = parseReg (a, str, &nextpos, &op->type);"
    },
    {
        "line": 176,
        "fullcodeline": "op->extended = false;"
    },
    {
        "line": 17,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {"
    },
    {
        "line": 177,
        "fullcodeline": "if (op->reg > 8) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (op->type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 185,
        "fullcodeline": "if (op->reg == X86R_UNDEFINED) {"
    },
    {
        "line": 208,
        "fullcodeline": "op->type = OT_CONSTANT;"
    },
    {
        "line": 209,
        "fullcodeline": "op->sign = 1;"
    },
    {
        "line": 210,
        "fullcodeline": "char *p = strchr (str, '-');"
    },
    {
        "line": 215,
        "fullcodeline": "op->immediate = getnum (a, str);"
    },
    {
        "line": 18,
        "fullcodeline": "op->type |= OT_MEMORY | OT_BYTE;"
    },
    {
        "line": 19,
        "fullcodeline": "op->dest_size = OT_BYTE;"
    },
    {
        "line": 20,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 72,
        "fullcodeline": "if (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {"
    },
    {
        "line": 168,
        "fullcodeline": "op->is_good_flag = false;"
    },
    {
        "line": 169,
        "fullcodeline": "strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);"
    },
    {
        "line": 170,
        "fullcodeline": "op->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';"
    },
    {
        "line": 178,
        "fullcodeline": "op->extended = true;"
    },
    {
        "line": 179,
        "fullcodeline": "op->reg -= 9;"
    },
    {
        "line": 182,
        "fullcodeline": "parse_segment_offset (a, str, &nextpos, op, reg_index);"
    },
    {
        "line": 186,
        "fullcodeline": "op->is_good_flag = false;"
    },
    {
        "line": 190,
        "fullcodeline": "op->type = OT_CONSTANT;"
    },
    {
        "line": 191,
        "fullcodeline": "RCore *core = a->num? (RCore *)(a->num->userptr): NULL;"
    },
    {
        "line": 196,
        "fullcodeline": "char *p = strchr (str, '-');"
    },
    {
        "line": 201,
        "fullcodeline": "op->immediate = getnum (a, str);"
    },
    {
        "line": 85,
        "fullcodeline": "temp = 1;"
    },
    {
        "line": 86,
        "fullcodeline": "reg = X86R_UNDEFINED;"
    },
    {
        "line": 94,
        "fullcodeline": "else if (last_type == TT_WORD) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (a->num && a->num->value == 0) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (core && (flag = r_flag_get (core->flags, str))) {"
    },
    {
        "line": 212,
        "fullcodeline": "op->sign = -1;"
    },
    {
        "line": 213,
        "fullcodeline": "str = ++p;"
    },
    {
        "line": 21,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (reg != X86R_UNDEFINED) {"
    },
    {
        "line": 95,
        "fullcodeline": "ut32 reg_type = 0;"
    },
    {
        "line": 103,
        "fullcodeline": "nextpos = pos;"
    },
    {
        "line": 104,
        "fullcodeline": "reg = parseReg (a, str, &nextpos, &reg_type);"
    },
    {
        "line": 127,
        "fullcodeline": "op->reg_size = reg_type;"
    },
    {
        "line": 128,
        "fullcodeline": "op->explicit_size = explicit_size;"
    },
    {
        "line": 193,
        "fullcodeline": "op->is_good_flag = true;"
    },
    {
        "line": 198,
        "fullcodeline": "op->sign = -1;"
    },
    {
        "line": 199,
        "fullcodeline": "str = ++p;"
    },
    {
        "line": 202,
        "fullcodeline": "} else if (op->reg < X86R_UNDEFINED) {"
    },
    {
        "line": 22,
        "fullcodeline": "op->type |= OT_MEMORY | OT_WORD;"
    },
    {
        "line": 23,
        "fullcodeline": "op->dest_size = OT_WORD;"
    },
    {
        "line": 24,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 78,
        "fullcodeline": "++reg_index;"
    },
    {
        "line": 87,
        "fullcodeline": "} else if (str[pos] == '*') {"
    },
    {
        "line": 98,
        "fullcodeline": "if (reg != X86R_UNDEFINED) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (reg_type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (!explicit_size) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (!(reg_type & OT_GPREG)) {"
    },
    {
        "line": 136,
        "fullcodeline": "char *p = strchr (str, '+');"
    },
    {
        "line": 137,
        "fullcodeline": "op->offset_sign = 1;"
    },
    {
        "line": 145,
        "fullcodeline": "char * plus = strchr (str, '+');"
    },
    {
        "line": 146,
        "fullcodeline": "char * minus = strchr (str, '-');"
    },
    {
        "line": 147,
        "fullcodeline": "char * closeB = strchr (str, ']');"
    },
    {
        "line": 155,
        "fullcodeline": "tmp = malloc (strlen (str + pos) + 1);"
    },
    {
        "line": 156,
        "fullcodeline": "strcpy (tmp, str + pos);"
    },
    {
        "line": 157,
        "fullcodeline": "strtok (tmp, \"+-\");"
    },
    {
        "line": 158,
        "fullcodeline": "st64 read = getnum (a, tmp);"
    },
    {
        "line": 159,
        "fullcodeline": "free (tmp);"
    },
    {
        "line": 160,
        "fullcodeline": "temp *= read;"
    },
    {
        "line": 203,
        "fullcodeline": "strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);"
    },
    {
        "line": 204,
        "fullcodeline": "op->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';"
    },
    {
        "line": 74,
        "fullcodeline": "if (reg_index < 2) {"
    },
    {
        "line": 80,
        "fullcodeline": "op->offset += temp;"
    },
    {
        "line": 99,
        "fullcodeline": "op->type = 0;\t// Make the result invalid"
    },
    {
        "line": 107,
        "fullcodeline": "op->extended = false;"
    },
    {
        "line": 112,
        "fullcodeline": "first_reg = false;"
    },
    {
        "line": 117,
        "fullcodeline": "op->reg = reg;"
    },
    {
        "line": 118,
        "fullcodeline": "op->type = reg_type;"
    },
    {
        "line": 119,
        "fullcodeline": "parse_segment_offset (a, str, &nextpos, op, reg_index);"
    },
    {
        "line": 125,
        "fullcodeline": "op->type |= reg_type;"
    },
    {
        "line": 132,
        "fullcodeline": "op->type = 0;\t// Make the result invalid"
    },
    {
        "line": 138,
        "fullcodeline": "if (!p) {"
    },
    {
        "line": 148,
        "fullcodeline": "if (plus && minus && plus < closeB && minus < closeB) {"
    },
    {
        "line": 25,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {"
    },
    {
        "line": 75,
        "fullcodeline": "op->regs[reg_index] = reg;"
    },
    {
        "line": 76,
        "fullcodeline": "op->scale[reg_index] = temp;"
    },
    {
        "line": 81,
        "fullcodeline": "if (reg_index < 2) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (reg > 8) {"
    },
    {
        "line": 139,
        "fullcodeline": "p = strchr (str, '-');"
    },
    {
        "line": 149,
        "fullcodeline": "op->offset_sign = -1;"
    },
    {
        "line": 26,
        "fullcodeline": "op->type |= OT_MEMORY | OT_DWORD;"
    },
    {
        "line": 27,
        "fullcodeline": "op->dest_size = OT_DWORD;"
    },
    {
        "line": 28,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 82,
        "fullcodeline": "op->regs[reg_index] = X86R_UNDEFINED;"
    },
    {
        "line": 109,
        "fullcodeline": "op->extended = true;"
    },
    {
        "line": 110,
        "fullcodeline": "op->reg = reg - 9;"
    },
    {
        "line": 113,
        "fullcodeline": "} else if (reg > 8) {"
    },
    {
        "line": 114,
        "fullcodeline": "op->reg = reg - 9;"
    },
    {
        "line": 141,
        "fullcodeline": "op->offset_sign = -1;"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {"
    },
    {
        "line": 30,
        "fullcodeline": "op->type |= OT_MEMORY | OT_QWORD;"
    },
    {
        "line": 31,
        "fullcodeline": "op->dest_size = OT_QWORD;"
    },
    {
        "line": 32,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 33,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {"
    },
    {
        "line": 34,
        "fullcodeline": "op->type |= OT_MEMORY | OT_OWORD;"
    },
    {
        "line": 35,
        "fullcodeline": "op->dest_size = OT_OWORD;"
    },
    {
        "line": 36,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 37,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {"
    },
    {
        "line": 38,
        "fullcodeline": "op->type |= OT_MEMORY | OT_TBYTE;"
    },
    {
        "line": 39,
        "fullcodeline": "op->dest_size = OT_TBYTE;"
    },
    {
        "line": 40,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 42,
        "fullcodeline": "size_token = 0;"
    }
]