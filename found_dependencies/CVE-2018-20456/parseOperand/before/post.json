[
    {
        "line": 2,
        "fullcodeline": "size_t pos, nextpos = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "int size_token = 1;"
    },
    {
        "line": 5,
        "fullcodeline": "bool explicit_size = false;"
    },
    {
        "line": 6,
        "fullcodeline": "int reg_index = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "op->type = 0;"
    },
    {
        "line": 47,
        "fullcodeline": "if (str[pos] == '[') {"
    },
    {
        "line": 11,
        "fullcodeline": "pos = nextpos;"
    },
    {
        "line": 12,
        "fullcodeline": "last_type = getToken (str, &pos, &nextpos);"
    },
    {
        "line": 55,
        "fullcodeline": "op->offset = op->scale[0] = op->scale[1] = 0;"
    },
    {
        "line": 57,
        "fullcodeline": "ut64 temp = 1;"
    },
    {
        "line": 58,
        "fullcodeline": "Register reg = X86R_UNDEFINED;"
    },
    {
        "line": 59,
        "fullcodeline": "bool first_reg = true;"
    },
    {
        "line": 15,
        "fullcodeline": "if (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (!op->type) {"
    },
    {
        "line": 60,
        "fullcodeline": "while (str[pos] != ']') {"
    },
    {
        "line": 50,
        "fullcodeline": "op->type = OT_MEMORY;"
    },
    {
        "line": 65,
        "fullcodeline": "pos = nextpos;"
    },
    {
        "line": 69,
        "fullcodeline": "last_type = getToken (str, &pos, &nextpos);"
    },
    {
        "line": 160,
        "fullcodeline": "} else if (last_type == TT_WORD) {   // register"
    },
    {
        "line": 61,
        "fullcodeline": "if (pos > nextpos) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (!str[pos]) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (last_type == TT_SPECIAL) {"
    },
    {
        "line": 161,
        "fullcodeline": "nextpos = pos;"
    },
    {
        "line": 171,
        "fullcodeline": "op->reg = parseReg (a, str, &nextpos, &op->type);"
    },
    {
        "line": 173,
        "fullcodeline": "op->extended = false;"
    },
    {
        "line": 17,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {"
    },
    {
        "line": 174,
        "fullcodeline": "if (op->reg > 8) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (op->type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (op->reg == X86R_UNDEFINED) {"
    },
    {
        "line": 205,
        "fullcodeline": "op->type = OT_CONSTANT;"
    },
    {
        "line": 206,
        "fullcodeline": "op->sign = 1;"
    },
    {
        "line": 207,
        "fullcodeline": "char *p = strchr (str, '-');"
    },
    {
        "line": 212,
        "fullcodeline": "op->immediate = getnum (a, str);"
    },
    {
        "line": 18,
        "fullcodeline": "op->type |= OT_MEMORY | OT_BYTE;"
    },
    {
        "line": 19,
        "fullcodeline": "op->dest_size = OT_BYTE;"
    },
    {
        "line": 20,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 72,
        "fullcodeline": "if (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {"
    },
    {
        "line": 165,
        "fullcodeline": "op->is_good_flag = false;"
    },
    {
        "line": 166,
        "fullcodeline": "strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);"
    },
    {
        "line": 167,
        "fullcodeline": "op->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';"
    },
    {
        "line": 175,
        "fullcodeline": "op->extended = true;"
    },
    {
        "line": 176,
        "fullcodeline": "op->reg -= 9;"
    },
    {
        "line": 179,
        "fullcodeline": "parse_segment_offset (a, str, &nextpos, op, reg_index);"
    },
    {
        "line": 183,
        "fullcodeline": "op->is_good_flag = false;"
    },
    {
        "line": 187,
        "fullcodeline": "op->type = OT_CONSTANT;"
    },
    {
        "line": 188,
        "fullcodeline": "RCore *core = a->num? (RCore *)(a->num->userptr): NULL;"
    },
    {
        "line": 193,
        "fullcodeline": "char *p = strchr (str, '-');"
    },
    {
        "line": 198,
        "fullcodeline": "op->immediate = getnum (a, str);"
    },
    {
        "line": 82,
        "fullcodeline": "temp = 1;"
    },
    {
        "line": 83,
        "fullcodeline": "reg = X86R_UNDEFINED;"
    },
    {
        "line": 91,
        "fullcodeline": "else if (last_type == TT_WORD) {"
    },
    {
        "line": 184,
        "fullcodeline": "if (a->num && a->num->value == 0) {"
    },
    {
        "line": 189,
        "fullcodeline": "if (core && (flag = r_flag_get (core->flags, str))) {"
    },
    {
        "line": 209,
        "fullcodeline": "op->sign = -1;"
    },
    {
        "line": 210,
        "fullcodeline": "str = ++p;"
    },
    {
        "line": 21,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (reg != X86R_UNDEFINED) {"
    },
    {
        "line": 92,
        "fullcodeline": "ut32 reg_type = 0;"
    },
    {
        "line": 100,
        "fullcodeline": "nextpos = pos;"
    },
    {
        "line": 101,
        "fullcodeline": "reg = parseReg (a, str, &nextpos, &reg_type);"
    },
    {
        "line": 124,
        "fullcodeline": "op->reg_size = reg_type;"
    },
    {
        "line": 125,
        "fullcodeline": "op->explicit_size = explicit_size;"
    },
    {
        "line": 190,
        "fullcodeline": "op->is_good_flag = true;"
    },
    {
        "line": 195,
        "fullcodeline": "op->sign = -1;"
    },
    {
        "line": 196,
        "fullcodeline": "str = ++p;"
    },
    {
        "line": 199,
        "fullcodeline": "} else if (op->reg < X86R_UNDEFINED) {"
    },
    {
        "line": 22,
        "fullcodeline": "op->type |= OT_MEMORY | OT_WORD;"
    },
    {
        "line": 23,
        "fullcodeline": "op->dest_size = OT_WORD;"
    },
    {
        "line": 24,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 74,
        "fullcodeline": "op->regs[reg_index] = reg;"
    },
    {
        "line": 75,
        "fullcodeline": "op->scale[reg_index] = temp;"
    },
    {
        "line": 76,
        "fullcodeline": "++reg_index;"
    },
    {
        "line": 84,
        "fullcodeline": "} else if (str[pos] == '*') {"
    },
    {
        "line": 95,
        "fullcodeline": "if (reg != X86R_UNDEFINED) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (reg_type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (!explicit_size) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (!(reg_type & OT_GPREG)) {"
    },
    {
        "line": 133,
        "fullcodeline": "char *p = strchr (str, '+');"
    },
    {
        "line": 134,
        "fullcodeline": "op->offset_sign = 1;"
    },
    {
        "line": 142,
        "fullcodeline": "char * plus = strchr (str, '+');"
    },
    {
        "line": 143,
        "fullcodeline": "char * minus = strchr (str, '-');"
    },
    {
        "line": 144,
        "fullcodeline": "char * closeB = strchr (str, ']');"
    },
    {
        "line": 152,
        "fullcodeline": "tmp = malloc (strlen (str + pos) + 1);"
    },
    {
        "line": 153,
        "fullcodeline": "strcpy (tmp, str + pos);"
    },
    {
        "line": 154,
        "fullcodeline": "strtok (tmp, \"+-\");"
    },
    {
        "line": 155,
        "fullcodeline": "st64 read = getnum (a, tmp);"
    },
    {
        "line": 156,
        "fullcodeline": "free (tmp);"
    },
    {
        "line": 157,
        "fullcodeline": "temp *= read;"
    },
    {
        "line": 200,
        "fullcodeline": "strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);"
    },
    {
        "line": 201,
        "fullcodeline": "op->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';"
    },
    {
        "line": 78,
        "fullcodeline": "op->offset += temp;"
    },
    {
        "line": 79,
        "fullcodeline": "op->regs[reg_index] = X86R_UNDEFINED;"
    },
    {
        "line": 96,
        "fullcodeline": "op->type = 0;\t// Make the result invalid"
    },
    {
        "line": 104,
        "fullcodeline": "op->extended = false;"
    },
    {
        "line": 109,
        "fullcodeline": "first_reg = false;"
    },
    {
        "line": 114,
        "fullcodeline": "op->reg = reg;"
    },
    {
        "line": 115,
        "fullcodeline": "op->type = reg_type;"
    },
    {
        "line": 116,
        "fullcodeline": "parse_segment_offset (a, str, &nextpos, op, reg_index);"
    },
    {
        "line": 122,
        "fullcodeline": "op->type |= reg_type;"
    },
    {
        "line": 129,
        "fullcodeline": "op->type = 0;\t// Make the result invalid"
    },
    {
        "line": 135,
        "fullcodeline": "if (!p) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (plus && minus && plus < closeB && minus < closeB) {"
    },
    {
        "line": 25,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (reg > 8) {"
    },
    {
        "line": 136,
        "fullcodeline": "p = strchr (str, '-');"
    },
    {
        "line": 146,
        "fullcodeline": "op->offset_sign = -1;"
    },
    {
        "line": 26,
        "fullcodeline": "op->type |= OT_MEMORY | OT_DWORD;"
    },
    {
        "line": 27,
        "fullcodeline": "op->dest_size = OT_DWORD;"
    },
    {
        "line": 28,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 106,
        "fullcodeline": "op->extended = true;"
    },
    {
        "line": 107,
        "fullcodeline": "op->reg = reg - 9;"
    },
    {
        "line": 110,
        "fullcodeline": "} else if (reg > 8) {"
    },
    {
        "line": 111,
        "fullcodeline": "op->reg = reg - 9;"
    },
    {
        "line": 138,
        "fullcodeline": "op->offset_sign = -1;"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {"
    },
    {
        "line": 30,
        "fullcodeline": "op->type |= OT_MEMORY | OT_QWORD;"
    },
    {
        "line": 31,
        "fullcodeline": "op->dest_size = OT_QWORD;"
    },
    {
        "line": 32,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 33,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {"
    },
    {
        "line": 34,
        "fullcodeline": "op->type |= OT_MEMORY | OT_OWORD;"
    },
    {
        "line": 35,
        "fullcodeline": "op->dest_size = OT_OWORD;"
    },
    {
        "line": 36,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 37,
        "fullcodeline": "} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {"
    },
    {
        "line": 38,
        "fullcodeline": "op->type |= OT_MEMORY | OT_TBYTE;"
    },
    {
        "line": 39,
        "fullcodeline": "op->dest_size = OT_TBYTE;"
    },
    {
        "line": 40,
        "fullcodeline": "explicit_size = true;"
    },
    {
        "line": 42,
        "fullcodeline": "size_token = 0;"
    }
]