[
    {
        "line": 5,
        "fullcodeline": "struct bpf_verifier_state *state = env->cur_state;"
    },
    {
        "line": 6,
        "fullcodeline": "struct bpf_reg_state *regs = state->regs;"
    },
    {
        "line": 9,
        "fullcodeline": "if (regs[regno].type != PTR_TO_STACK) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (!tnum_is_const(regs[regno].var_off)) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||"
    },
    {
        "line": 38,
        "fullcodeline": "if (env->prog->aux->stack_depth < -off)"
    },
    {
        "line": 41,
        "fullcodeline": "if (meta && meta->raw_mode) {"
    },
    {
        "line": 47,
        "fullcodeline": "for (i = 0; i < access_size; i++) {"
    },
    {
        "line": 15,
        "fullcodeline": "verbose(env, \"R%d type=%s expected=%s\\n\", regno,"
    },
    {
        "line": 23,
        "fullcodeline": "char tn_buf[48];"
    },
    {
        "line": 25,
        "fullcodeline": "tnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);"
    },
    {
        "line": 26,
        "fullcodeline": "verbose(env, \"invalid variable stack read R%d var_off=%s\\n\","
    },
    {
        "line": 32,
        "fullcodeline": "access_size < 0 || (access_size == 0 && !zero_size_allowed)) {"
    },
    {
        "line": 33,
        "fullcodeline": "verbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\","
    },
    {
        "line": 39,
        "fullcodeline": "env->prog->aux->stack_depth = -off;"
    },
    {
        "line": 42,
        "fullcodeline": "meta->access_size = access_size;"
    },
    {
        "line": 43,
        "fullcodeline": "meta->regno = regno;"
    },
    {
        "line": 48,
        "fullcodeline": "slot = -(off + i) - 1;"
    },
    {
        "line": 49,
        "fullcodeline": "spi = slot / BPF_REG_SIZE;"
    },
    {
        "line": 11,
        "fullcodeline": "if (zero_size_allowed && access_size == 0 &&"
    },
    {
        "line": 18,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 28,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 35,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 50,
        "fullcodeline": "if (state->allocated_stack <= slot ||"
    },
    {
        "line": 12,
        "fullcodeline": "register_is_null(regs[regno]))"
    },
    {
        "line": 51,
        "fullcodeline": "state->stack[spi].slot_type[slot % BPF_REG_SIZE] !="
    },
    {
        "line": 53,
        "fullcodeline": "verbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\","
    },
    {
        "line": 55,
        "fullcodeline": "return -EACCES;"
    }
]