[
    {
        "line": 4,
        "fullcodeline": "struct mm_struct *mm = vma->vm_mm;"
    },
    {
        "line": 14,
        "fullcodeline": "int ret = SWAP_AGAIN;"
    },
    {
        "line": 15,
        "fullcodeline": "int locked_vma = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "address = (vma->vm_start + cursor) & CLUSTER_MASK;"
    },
    {
        "line": 18,
        "fullcodeline": "end = address + CLUSTER_SIZE;"
    },
    {
        "line": 24,
        "fullcodeline": "pmd = mm_find_pmd(mm, address);"
    },
    {
        "line": 28,
        "fullcodeline": "mmun_start = address;"
    },
    {
        "line": 29,
        "fullcodeline": "mmun_end   = end;"
    },
    {
        "line": 30,
        "fullcodeline": "mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);"
    },
    {
        "line": 42,
        "fullcodeline": "pte = pte_offset_map_lock(mm, pmd, address, &ptl);"
    },
    {
        "line": 45,
        "fullcodeline": "update_hiwater_rss(mm);"
    },
    {
        "line": 19,
        "fullcodeline": "if (address < vma->vm_start)"
    },
    {
        "line": 21,
        "fullcodeline": "if (end > vma->vm_end)"
    },
    {
        "line": 25,
        "fullcodeline": "if (!pmd)"
    },
    {
        "line": 36,
        "fullcodeline": "if (down_read_trylock(&vma->vm_mm->mmap_sem)) {"
    },
    {
        "line": 47,
        "fullcodeline": "for (; address < end; pte++, address += PAGE_SIZE) {"
    },
    {
        "line": 94,
        "fullcodeline": "pte_unmap_unlock(pte - 1, ptl);"
    },
    {
        "line": 20,
        "fullcodeline": "address = vma->vm_start;"
    },
    {
        "line": 22,
        "fullcodeline": "end = vma->vm_end;"
    },
    {
        "line": 37,
        "fullcodeline": "locked_vma = (vma->vm_flags & VM_LOCKED);"
    },
    {
        "line": 50,
        "fullcodeline": "page = vm_normal_page(vma, address, *pte);"
    },
    {
        "line": 74,
        "fullcodeline": "flush_cache_page(vma, address, pte_pfn(*pte));"
    },
    {
        "line": 75,
        "fullcodeline": "pteval = ptep_clear_flush(vma, address, pte);"
    },
    {
        "line": 89,
        "fullcodeline": "page_remove_rmap(page);"
    },
    {
        "line": 91,
        "fullcodeline": "dec_mm_counter(mm, MM_FILEPAGES);"
    },
    {
        "line": 51,
        "fullcodeline": "BUG_ON(!page || PageAnon(page));"
    },
    {
        "line": 70,
        "fullcodeline": "if (ptep_clear_flush_young_notify(vma, address, pte))"
    },
    {
        "line": 78,
        "fullcodeline": "if (page->index != linear_page_index(vma, address)) {"
    },
    {
        "line": 39,
        "fullcodeline": "up_read(&vma->vm_mm->mmap_sem); /* don't need it */"
    },
    {
        "line": 48,
        "fullcodeline": "if (!pte_present(*pte))"
    },
    {
        "line": 79,
        "fullcodeline": "pte_t ptfile = pgoff_to_pte(page->index);"
    },
    {
        "line": 82,
        "fullcodeline": "set_pte_at(mm, address, pte, ptfile);"
    },
    {
        "line": 87,
        "fullcodeline": "set_page_dirty(page);"
    },
    {
        "line": 54,
        "fullcodeline": "if (page == check_page) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (pte_soft_dirty(pteval))"
    },
    {
        "line": 57,
        "fullcodeline": "ret = SWAP_MLOCK;"
    },
    {
        "line": 81,
        "fullcodeline": "pte_file_mksoft_dirty(ptfile);"
    },
    {
        "line": 58,
        "fullcodeline": "} else if (trylock_page(page)) {"
    },
    {
        "line": 64,
        "fullcodeline": "mlock_vma_page(page);"
    }
]