[
    {
        "line": 2,
        "fullcodeline": "CallInfo *ci = L->ci;"
    },
    {
        "line": 3,
        "fullcodeline": "lu_byte mask = L->hookmask;"
    },
    {
        "line": 4,
        "fullcodeline": "const Proto *p = ci_func(ci)->p;"
    },
    {
        "line": 7,
        "fullcodeline": "int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;"
    },
    {
        "line": 12,
        "fullcodeline": "pc++;  /* reference is always next instruction */"
    },
    {
        "line": 13,
        "fullcodeline": "ci->u.l.savedpc = pc;  /* save 'pc' */"
    },
    {
        "line": 8,
        "fullcodeline": "if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */"
    },
    {
        "line": 14,
        "fullcodeline": "counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));"
    },
    {
        "line": 19,
        "fullcodeline": "if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */"
    },
    {
        "line": 37,
        "fullcodeline": "if (L->status == LUA_YIELD) {  /* did hook yield? */"
    },
    {
        "line": 9,
        "fullcodeline": "ci->u.l.trap = 0;  /* don't need to stop again */"
    },
    {
        "line": 16,
        "fullcodeline": "resethookcount(L);  /* reset count */"
    },
    {
        "line": 23,
        "fullcodeline": "if (!isIT(*(ci->u.l.savedpc - 1)))"
    },
    {
        "line": 24,
        "fullcodeline": "L->top = ci->top;  /* prepare top */"
    },
    {
        "line": 26,
        "fullcodeline": "luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */"
    },
    {
        "line": 28,
        "fullcodeline": "int npci = pcRel(pc, p);"
    },
    {
        "line": 35,
        "fullcodeline": "L->oldpc = npci;  /* 'pc' of last call to line hook */"
    },
    {
        "line": 20,
        "fullcodeline": "ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */"
    },
    {
        "line": 29,
        "fullcodeline": "if (npci == 0 ||  /* call linehook when enter a new function, */"
    },
    {
        "line": 31,
        "fullcodeline": "changedline(p, oldpc, npci)) {  /* enter new line */"
    },
    {
        "line": 32,
        "fullcodeline": "int newline = luaG_getfuncline(p, npci);"
    },
    {
        "line": 33,
        "fullcodeline": "luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */"
    },
    {
        "line": 39,
        "fullcodeline": "L->hookcount = 1;  /* undo decrement to zero */"
    },
    {
        "line": 17,
        "fullcodeline": "else if (!(mask & LUA_MASKLINE))"
    },
    {
        "line": 30,
        "fullcodeline": "pc <= invpcRel(oldpc, p) ||  /* when jump back (loop), or when */"
    }
]