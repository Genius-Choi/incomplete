[
    {
        "line": 2,
        "fullcodeline": "CallInfo *ci = L->ci;"
    },
    {
        "line": 3,
        "fullcodeline": "lu_byte mask = L->hookmask;"
    },
    {
        "line": 9,
        "fullcodeline": "pc++;  /* reference is always next instruction */"
    },
    {
        "line": 10,
        "fullcodeline": "ci->u.l.savedpc = pc;  /* save 'pc' */"
    },
    {
        "line": 5,
        "fullcodeline": "if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */"
    },
    {
        "line": 11,
        "fullcodeline": "counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));"
    },
    {
        "line": 16,
        "fullcodeline": "if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */"
    },
    {
        "line": 35,
        "fullcodeline": "if (L->status == LUA_YIELD) {  /* did hook yield? */"
    },
    {
        "line": 6,
        "fullcodeline": "ci->u.l.trap = 0;  /* don't need to stop again */"
    },
    {
        "line": 13,
        "fullcodeline": "resethookcount(L);  /* reset count */"
    },
    {
        "line": 20,
        "fullcodeline": "if (!isIT(*(ci->u.l.savedpc - 1)))"
    },
    {
        "line": 21,
        "fullcodeline": "L->top = ci->top;  /* prepare top */"
    },
    {
        "line": 23,
        "fullcodeline": "luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */"
    },
    {
        "line": 25,
        "fullcodeline": "const Proto *p = ci_func(ci)->p;"
    },
    {
        "line": 26,
        "fullcodeline": "int npci = pcRel(pc, p);"
    },
    {
        "line": 33,
        "fullcodeline": "L->oldpc = pc;  /* 'pc' of last call to line hook */"
    },
    {
        "line": 17,
        "fullcodeline": "ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */"
    },
    {
        "line": 27,
        "fullcodeline": "if (npci == 0 ||  /* call linehook when enter a new function, */"
    },
    {
        "line": 29,
        "fullcodeline": "changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */"
    },
    {
        "line": 30,
        "fullcodeline": "int newline = luaG_getfuncline(p, npci);"
    },
    {
        "line": 31,
        "fullcodeline": "luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */"
    },
    {
        "line": 37,
        "fullcodeline": "L->hookcount = 1;  /* undo decrement to zero */"
    },
    {
        "line": 14,
        "fullcodeline": "else if (!(mask & LUA_MASKLINE))"
    },
    {
        "line": 28,
        "fullcodeline": "pc <= L->oldpc ||  /* when jump back (loop), or when */"
    }
]