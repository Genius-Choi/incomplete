[
    {
        "line": 3,
        "fullcodeline": "lex< css_comments >(false);"
    },
    {
        "line": 82,
        "fullcodeline": "css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");"
    },
    {
        "line": 4,
        "fullcodeline": "if (lex< ampersand >())"
    },
    {
        "line": 11,
        "fullcodeline": "if (lex< kwd_important >())"
    },
    {
        "line": 15,
        "fullcodeline": "if (lex< sequence < percentage, lookahead < number > > >())"
    },
    {
        "line": 18,
        "fullcodeline": "if (lex< sequence < number, lookahead< sequence < op, number > > > >())"
    },
    {
        "line": 22,
        "fullcodeline": "if (lex< sequence < quoted_string, lookahead < exactly <'-'> > > >())"
    },
    {
        "line": 29,
        "fullcodeline": "if (lex< quoted_string >())"
    },
    {
        "line": 32,
        "fullcodeline": "if (lex< kwd_true >())"
    },
    {
        "line": 35,
        "fullcodeline": "if (lex< kwd_false >())"
    },
    {
        "line": 38,
        "fullcodeline": "if (lex< kwd_null >())"
    },
    {
        "line": 41,
        "fullcodeline": "if (lex< identifier >()) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (lex< percentage >())"
    },
    {
        "line": 49,
        "fullcodeline": "if (lex< sequence < alternatives< hex, hex0 >, negate < exactly<'-'> > > >())"
    },
    {
        "line": 52,
        "fullcodeline": "if (lex< hexa >())"
    },
    {
        "line": 65,
        "fullcodeline": "if (lex< sequence < exactly <'#'>, identifier > >())"
    },
    {
        "line": 70,
        "fullcodeline": "if (lex< sequence< dimension, optional< sequence< exactly<'-'>, lookahead< alternatives < space > > > > > >())"
    },
    {
        "line": 73,
        "fullcodeline": "if (lex< sequence< static_component, one_plus< strict_identifier > > >())"
    },
    {
        "line": 76,
        "fullcodeline": "if (lex< number >())"
    },
    {
        "line": 79,
        "fullcodeline": "if (lex< variable >())"
    },
    {
        "line": 25,
        "fullcodeline": "if (const char* stop = peek< value_schema >())"
    },
    {
        "line": 54,
        "fullcodeline": "std::string s = lexed.to_string();"
    },
    {
        "line": 56,
        "fullcodeline": "deprecated("
    },
    {
        "line": 6,
        "fullcodeline": "if (match< ampersand >()) {"
    },
    {
        "line": 9,
        "fullcodeline": "return SASS_MEMORY_NEW(Parent_Selector, pstate); }"
    },
    {
        "line": 12,
        "fullcodeline": "{ return SASS_MEMORY_NEW(String_Constant, pstate, \"!important\"); }"
    },
    {
        "line": 16,
        "fullcodeline": "{ return lexed_percentage(lexed); }"
    },
    {
        "line": 19,
        "fullcodeline": "{ return lexed_number(lexed); }"
    },
    {
        "line": 23,
        "fullcodeline": "{ return parse_string(); }"
    },
    {
        "line": 26,
        "fullcodeline": "{ return parse_value_schema(stop); }"
    },
    {
        "line": 30,
        "fullcodeline": "{ return parse_string(); }"
    },
    {
        "line": 33,
        "fullcodeline": "{ return SASS_MEMORY_NEW(Boolean, pstate, true); }"
    },
    {
        "line": 36,
        "fullcodeline": "{ return SASS_MEMORY_NEW(Boolean, pstate, false); }"
    },
    {
        "line": 39,
        "fullcodeline": "{ return SASS_MEMORY_NEW(Null, pstate); }"
    },
    {
        "line": 42,
        "fullcodeline": "return color_or_string(lexed);"
    },
    {
        "line": 46,
        "fullcodeline": "{ return lexed_percentage(lexed); }"
    },
    {
        "line": 50,
        "fullcodeline": "{ return lexed_hex_color(lexed); }"
    },
    {
        "line": 57,
        "fullcodeline": "\"The value \\\"\"+s+\"\\\" is currently parsed as a string, but it will be parsed as a color in\","
    },
    {
        "line": 58,
        "fullcodeline": "\"future versions of Sass. Use \\\"unquote('\"+s+\"')\\\" to continue parsing it as a string.\","
    },
    {
        "line": 62,
        "fullcodeline": "return SASS_MEMORY_NEW(String_Quoted, pstate, lexed);"
    },
    {
        "line": 66,
        "fullcodeline": "{ return SASS_MEMORY_NEW(String_Quoted, pstate, lexed); }"
    },
    {
        "line": 71,
        "fullcodeline": "{ return lexed_dimension(lexed); }"
    },
    {
        "line": 74,
        "fullcodeline": "{ return SASS_MEMORY_NEW(String_Constant, pstate, lexed); }"
    },
    {
        "line": 77,
        "fullcodeline": "{ return lexed_number(lexed); }"
    },
    {
        "line": 80,
        "fullcodeline": "{ return SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)); }"
    },
    {
        "line": 7,
        "fullcodeline": "warning(\"In Sass, \\\"&&\\\" means two copies of the parent selector. You probably want to use \\\"and\\\" instead.\", pstate);"
    }
]