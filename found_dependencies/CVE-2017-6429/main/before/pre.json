[
    {
        "line": 7,
        "fullcodeline": "char buf[10000];"
    },
    {
        "line": 13,
        "fullcodeline": "optct = optionProcess(&tcpcapinfoOptions, argc, argv);"
    },
    {
        "line": 14,
        "fullcodeline": "argc -= optct;"
    },
    {
        "line": 15,
        "fullcodeline": "argv += optct;"
    },
    {
        "line": 22,
        "fullcodeline": "for (i = 0; i < argc; i++) {"
    },
    {
        "line": 23,
        "fullcodeline": "dbgx(1, \"processing:  %s\\n\", argv[i]);"
    },
    {
        "line": 35,
        "fullcodeline": "dbgx(3, \"Read %d bytes for file header\", ret);"
    },
    {
        "line": 37,
        "fullcodeline": "swapped = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "memcpy(&pcap_fh, &buf, sizeof(pcap_fh));"
    },
    {
        "line": 41,
        "fullcodeline": "pkthdrlen = 16; /* pcap_pkthdr isn't the actual on-disk format for 64bit systems! */"
    },
    {
        "line": 104,
        "fullcodeline": "printf(\"version     = %hu.%hu\\n\", pcap_fh.version_major, pcap_fh.version_minor);"
    },
    {
        "line": 116,
        "fullcodeline": "dbgx(5, \"Packet header len: %d\", pkthdrlen);"
    },
    {
        "line": 124,
        "fullcodeline": "pktcnt = 0;"
    },
    {
        "line": 125,
        "fullcodeline": "last_sec = 0;"
    },
    {
        "line": 126,
        "fullcodeline": "last_usec = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "if ((fd = open(argv[i], O_RDONLY)) < 0)"
    },
    {
        "line": 27,
        "fullcodeline": "if (fstat(fd, &statinfo) < 0)"
    },
    {
        "line": 32,
        "fullcodeline": "if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))"
    },
    {
        "line": 95,
        "fullcodeline": "if (swapped == 1) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (pkthdrlen == 24) {"
    },
    {
        "line": 127,
        "fullcodeline": "while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {"
    },
    {
        "line": 25,
        "fullcodeline": "errx(-1, \"Error opening file %s: %s\", argv[i], strerror(errno));"
    },
    {
        "line": 28,
        "fullcodeline": "errx(-1, \"Error getting file stat info %s: %s\", argv[i], strerror(errno));"
    },
    {
        "line": 33,
        "fullcodeline": "errx(-1, \"File too small.  Unable to read pcap_file_header from %s\", argv[i]);"
    },
    {
        "line": 48,
        "fullcodeline": "case SWAPLONG(TCPDUMP_MAGIC):"
    },
    {
        "line": 50,
        "fullcodeline": "swapped = 1;"
    },
    {
        "line": 54,
        "fullcodeline": "pkthdrlen = sizeof(pcap_patched_ph);"
    },
    {
        "line": 58,
        "fullcodeline": "case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):"
    },
    {
        "line": 59,
        "fullcodeline": "pkthdrlen = sizeof(pcap_patched_ph);"
    },
    {
        "line": 61,
        "fullcodeline": "swapped = 1;"
    },
    {
        "line": 68,
        "fullcodeline": "case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC):"
    },
    {
        "line": 70,
        "fullcodeline": "swapped = 1;"
    },
    {
        "line": 77,
        "fullcodeline": "case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):"
    },
    {
        "line": 79,
        "fullcodeline": "swapped = 1;"
    },
    {
        "line": 86,
        "fullcodeline": "case SWAPLONG(NSEC_TCPDUMP_MAGIC):"
    },
    {
        "line": 88,
        "fullcodeline": "swapped = 1;"
    },
    {
        "line": 96,
        "fullcodeline": "pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major);"
    },
    {
        "line": 97,
        "fullcodeline": "pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor);"
    },
    {
        "line": 98,
        "fullcodeline": "pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone);"
    },
    {
        "line": 99,
        "fullcodeline": "pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs);"
    },
    {
        "line": 100,
        "fullcodeline": "pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);"
    },
    {
        "line": 101,
        "fullcodeline": "pcap_fh.linktype = SWAPLONG(pcap_fh.linktype);"
    },
    {
        "line": 111,
        "fullcodeline": "printf(\"Sorry, we only support file format version 2.4\\n\");"
    },
    {
        "line": 112,
        "fullcodeline": "close(fd);"
    },
    {
        "line": 119,
        "fullcodeline": "printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\t\\tIndex\\tProto\\tPktType\\tPktCsum\\tNote\\n\");"
    },
    {
        "line": 128,
        "fullcodeline": "pktcnt ++;"
    },
    {
        "line": 129,
        "fullcodeline": "backwards = 0;"
    },
    {
        "line": 130,
        "fullcodeline": "caplentoobig = 0;"
    },
    {
        "line": 133,
        "fullcodeline": "memset(&pcap_ph, 0, sizeof(pcap_ph));"
    },
    {
        "line": 215,
        "fullcodeline": "printf(\"\\t%x\\t\", do_checksum_math((u_int16_t *)buf, caplen));"
    },
    {
        "line": 121,
        "fullcodeline": "printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\tCsum\\tNote\\n\");"
    },
    {
        "line": 136,
        "fullcodeline": "if (pkthdrlen == sizeof(pcap_patched_ph)) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (last_sec > 0 && last_usec > 0) {"
    },
    {
        "line": 194,
        "fullcodeline": "if (pkthdrlen == sizeof(pcap_patched_ph)) {"
    },
    {
        "line": 203,
        "fullcodeline": "if ((ret = read(fd, &buf, caplen)) != caplen) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (! backwards && ! caplentoobig) {"
    },
    {
        "line": 137,
        "fullcodeline": "memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));"
    },
    {
        "line": 158,
        "fullcodeline": "caplen = pcap_patched_ph.caplen;"
    },
    {
        "line": 195,
        "fullcodeline": "last_sec = pcap_patched_ph.ts.tv_sec;"
    },
    {
        "line": 196,
        "fullcodeline": "last_usec = pcap_patched_ph.ts.tv_usec;"
    },
    {
        "line": 210,
        "fullcodeline": "close(fd);"
    },
    {
        "line": 219,
        "fullcodeline": "printf(\"OK\\n\");"
    },
    {
        "line": 139,
        "fullcodeline": "if (swapped == 1) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (pcap_fh.snaplen < pcap_patched_ph.caplen) {"
    },
    {
        "line": 162,
        "fullcodeline": "memcpy(&readword, buf, 4);"
    },
    {
        "line": 163,
        "fullcodeline": "pcap_ph.ts.tv_sec = readword;"
    },
    {
        "line": 164,
        "fullcodeline": "memcpy(&readword, &buf[4], 4);"
    },
    {
        "line": 165,
        "fullcodeline": "pcap_ph.ts.tv_usec = readword;"
    },
    {
        "line": 166,
        "fullcodeline": "memcpy(&pcap_ph.caplen, &buf[8], 4);"
    },
    {
        "line": 167,
        "fullcodeline": "memcpy(&pcap_ph.len, &buf[12], 4);"
    },
    {
        "line": 183,
        "fullcodeline": "caplen = pcap_ph.caplen;"
    },
    {
        "line": 188,
        "fullcodeline": "if ((pcap_ph.ts.tv_sec == last_sec) ?"
    },
    {
        "line": 198,
        "fullcodeline": "last_sec = pcap_ph.ts.tv_sec;"
    },
    {
        "line": 199,
        "fullcodeline": "last_usec = pcap_ph.ts.tv_usec;"
    },
    {
        "line": 204,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 140,
        "fullcodeline": "dbg(3, \"Swapping packet header bytes...\");"
    },
    {
        "line": 141,
        "fullcodeline": "pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);"
    },
    {
        "line": 142,
        "fullcodeline": "pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len);"
    },
    {
        "line": 143,
        "fullcodeline": "pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec);"
    },
    {
        "line": 144,
        "fullcodeline": "pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec);"
    },
    {
        "line": 145,
        "fullcodeline": "pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index);"
    },
    {
        "line": 146,
        "fullcodeline": "pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol);"
    },
    {
        "line": 155,
        "fullcodeline": "caplentoobig = 1;"
    },
    {
        "line": 169,
        "fullcodeline": "if (swapped == 1) {"
    },
    {
        "line": 180,
        "fullcodeline": "if (pcap_fh.snaplen < pcap_ph.caplen) {"
    },
    {
        "line": 189,
        "fullcodeline": "(pcap_ph.ts.tv_usec < last_usec) :"
    },
    {
        "line": 190,
        "fullcodeline": "(pcap_ph.ts.tv_sec < last_sec)) {"
    },
    {
        "line": 191,
        "fullcodeline": "backwards = 1;"
    },
    {
        "line": 205,
        "fullcodeline": "printf(\"Error reading file: %s: %s\\n\", argv[i], strerror(errno));"
    },
    {
        "line": 220,
        "fullcodeline": "} else if (backwards && ! caplentoobig) {"
    },
    {
        "line": 170,
        "fullcodeline": "dbg(3, \"Swapping packet header bytes...\");"
    },
    {
        "line": 171,
        "fullcodeline": "pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);"
    },
    {
        "line": 172,
        "fullcodeline": "pcap_ph.len = SWAPLONG(pcap_ph.len);"
    },
    {
        "line": 173,
        "fullcodeline": "pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec);"
    },
    {
        "line": 174,
        "fullcodeline": "pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec);"
    },
    {
        "line": 181,
        "fullcodeline": "caplentoobig = 1;"
    },
    {
        "line": 207,
        "fullcodeline": "printf(\"File truncated!  Unable to jump to next packet.\\n\");"
    },
    {
        "line": 221,
        "fullcodeline": "printf(\"BAD_TS\\n\");"
    },
    {
        "line": 222,
        "fullcodeline": "} else if (caplentoobig && ! backwards) {"
    },
    {
        "line": 223,
        "fullcodeline": "printf(\"TOOBIG\\n\");"
    },
    {
        "line": 224,
        "fullcodeline": "} else if (backwards && caplentoobig) {"
    },
    {
        "line": 225,
        "fullcodeline": "printf(\"BAD_TS|TOOBIG\");"
    }
]