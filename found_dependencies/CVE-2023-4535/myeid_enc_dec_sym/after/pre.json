[
    {
        "line": 8,
        "fullcodeline": "u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];"
    },
    {
        "line": 9,
        "fullcodeline": "u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];"
    },
    {
        "line": 11,
        "fullcodeline": "int r, padding = 0, cbc = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "size_t return_len = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "assert(card != NULL);"
    },
    {
        "line": 22,
        "fullcodeline": "ctx = card->ctx;"
    },
    {
        "line": 23,
        "fullcodeline": "LOG_FUNC_CALLED(ctx);"
    },
    {
        "line": 26,
        "fullcodeline": "priv = (myeid_private_data_t *)card->drv_data;"
    },
    {
        "line": 32,
        "fullcodeline": "max_apdu_datalen = sc_get_max_send_size(card);"
    },
    {
        "line": 39,
        "fullcodeline": "sc_log(ctx, \"algorithm %d algorithm_flags %x\", priv->algorithm, priv->algorithm_flags);"
    },
    {
        "line": 81,
        "fullcodeline": "rest_len = priv->sym_crypt_buffer_len;"
    },
    {
        "line": 137,
        "fullcodeline": "len = datalen + rest_len;"
    },
    {
        "line": 139,
        "fullcodeline": "sc_log(ctx, \"datalen=%zu rest_len=%zu len=%zu outlen=%zu\", datalen, rest_len, len, *outlen);"
    },
    {
        "line": 141,
        "fullcodeline": "len -= (len % block_size);"
    },
    {
        "line": 144,
        "fullcodeline": "*outlen = len;"
    },
    {
        "line": 227,
        "fullcodeline": "sc_log(ctx, \"rest data len = %zu\", datalen);"
    },
    {
        "line": 230,
        "fullcodeline": "sc_log(ctx, \"return data len = %zu\", return_len);"
    },
    {
        "line": 33,
        "fullcodeline": "if (max_apdu_datalen > sc_get_max_recv_size(card))"
    },
    {
        "line": 36,
        "fullcodeline": "if (max_apdu_datalen > SC_MAX_APDU_BUFFER_SIZE)"
    },
    {
        "line": 45,
        "fullcodeline": "if (outlen == NULL) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (data == NULL) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (out == NULL)"
    },
    {
        "line": 148,
        "fullcodeline": "if (*outlen < len)"
    },
    {
        "line": 152,
        "fullcodeline": "while (len >= block_size) {"
    },
    {
        "line": 34,
        "fullcodeline": "max_apdu_datalen = sc_get_max_recv_size(card);"
    },
    {
        "line": 37,
        "fullcodeline": "max_apdu_datalen = SC_MAX_APDU_BUFFER_SIZE;"
    },
    {
        "line": 47,
        "fullcodeline": "sc_log(ctx, \"%s (symmetric key) initialized\", decipher ? \"C_DecryptInit\" : \"C_EncryptInit\");"
    },
    {
        "line": 48,
        "fullcodeline": "priv->sym_crypt_buffer_len = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "priv->sym_plain_buffer_len = 0;"
    },
    {
        "line": 55,
        "fullcodeline": "block_size = 16;"
    },
    {
        "line": 68,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);"
    },
    {
        "line": 76,
        "fullcodeline": "max_apdu_datalen -= max_apdu_datalen % block_size;"
    },
    {
        "line": 146,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_SUCCESS);"
    },
    {
        "line": 149,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);"
    },
    {
        "line": 157,
        "fullcodeline": "apdu.cla = 0;"
    },
    {
        "line": 167,
        "fullcodeline": "len -= apdu_datalen;"
    },
    {
        "line": 168,
        "fullcodeline": "sdata = sbuf;"
    },
    {
        "line": 170,
        "fullcodeline": "apdu.le = apdu_datalen;"
    },
    {
        "line": 171,
        "fullcodeline": "apdu.lc = apdu_datalen;"
    },
    {
        "line": 172,
        "fullcodeline": "apdu.datalen = apdu_datalen;"
    },
    {
        "line": 173,
        "fullcodeline": "apdu.data = sbuf;"
    },
    {
        "line": 174,
        "fullcodeline": "apdu.resplen = sizeof(rbuf);"
    },
    {
        "line": 175,
        "fullcodeline": "apdu.resp = rbuf;"
    },
    {
        "line": 190,
        "fullcodeline": "r = sc_transmit_apdu(card, &apdu);"
    },
    {
        "line": 191,
        "fullcodeline": "LOG_TEST_RET(ctx, r, \"APDU transmit failed\");"
    },
    {
        "line": 192,
        "fullcodeline": "r = sc_check_sw(card, apdu.sw1, apdu.sw2);"
    },
    {
        "line": 193,
        "fullcodeline": "LOG_TEST_RET(ctx, r, \"decrypt_sym/encrypt_sym failed\");"
    },
    {
        "line": 196,
        "fullcodeline": "memcpy(out, apdu.resp, apdu.resplen);"
    },
    {
        "line": 197,
        "fullcodeline": "out += apdu.resplen;"
    },
    {
        "line": 198,
        "fullcodeline": "return_len += apdu.resplen;"
    },
    {
        "line": 207,
        "fullcodeline": "uint8_t tmp_buf[16];"
    },
    {
        "line": 56,
        "fullcodeline": "if (priv->algorithm_flags & SC_ALGORITHM_AES_ECB) {"
    },
    {
        "line": 78,
        "fullcodeline": "max_apdu_datalen = block_size;"
    },
    {
        "line": 85,
        "fullcodeline": "if (datalen != 0)"
    },
    {
        "line": 159,
        "fullcodeline": "if (len > max_apdu_datalen)"
    },
    {
        "line": 194,
        "fullcodeline": "if (apdu.resplen != apdu.datalen)"
    },
    {
        "line": 208,
        "fullcodeline": "if (return_len >= block_size) {"
    },
    {
        "line": 86,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);"
    },
    {
        "line": 96,
        "fullcodeline": "return_len = block_size;"
    },
    {
        "line": 117,
        "fullcodeline": "*outlen = return_len;"
    },
    {
        "line": 154,
        "fullcodeline": "sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x84, 0x80);"
    },
    {
        "line": 160,
        "fullcodeline": "apdu_datalen = max_apdu_datalen;"
    },
    {
        "line": 165,
        "fullcodeline": "apdu.cla = 0x10;"
    },
    {
        "line": 179,
        "fullcodeline": "memcpy(sbuf, priv->sym_crypt_buffer, rest_len);"
    },
    {
        "line": 180,
        "fullcodeline": "sdata += rest_len;"
    },
    {
        "line": 181,
        "fullcodeline": "apdu_datalen -= rest_len;"
    },
    {
        "line": 183,
        "fullcodeline": "rest_len = 0;"
    },
    {
        "line": 186,
        "fullcodeline": "memcpy(sdata, data, apdu_datalen);"
    },
    {
        "line": 187,
        "fullcodeline": "data += apdu_datalen;"
    },
    {
        "line": 188,
        "fullcodeline": "datalen -= apdu_datalen;"
    },
    {
        "line": 195,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);"
    },
    {
        "line": 210,
        "fullcodeline": "memcpy(tmp_buf, out - block_size, block_size);"
    },
    {
        "line": 219,
        "fullcodeline": "memcpy(priv->sym_plain_buffer, tmp_buf, block_size);"
    },
    {
        "line": 90,
        "fullcodeline": "if (priv->sym_plain_buffer_len != block_size)"
    },
    {
        "line": 111,
        "fullcodeline": "if (out == NULL) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (return_len > *outlen)"
    },
    {
        "line": 156,
        "fullcodeline": "sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x84);"
    },
    {
        "line": 162,
        "fullcodeline": "apdu_datalen = len;"
    },
    {
        "line": 59,
        "fullcodeline": "} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC) {"
    },
    {
        "line": 91,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);"
    },
    {
        "line": 94,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);"
    },
    {
        "line": 99,
        "fullcodeline": "uint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);"
    },
    {
        "line": 101,
        "fullcodeline": "sc_log(ctx, \"Found padding byte %02x\", pad_byte);"
    },
    {
        "line": 104,
        "fullcodeline": "sdata = priv->sym_plain_buffer + block_size;"
    },
    {
        "line": 108,
        "fullcodeline": "return_len = block_size - pad_byte;"
    },
    {
        "line": 112,
        "fullcodeline": "*outlen = return_len;"
    },
    {
        "line": 113,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_SUCCESS);"
    },
    {
        "line": 116,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);"
    },
    {
        "line": 213,
        "fullcodeline": "sc_log(ctx, \"inserting block from previous decrypt\");"
    },
    {
        "line": 215,
        "fullcodeline": "memcpy(out - return_len, priv->sym_plain_buffer, block_size);"
    },
    {
        "line": 105,
        "fullcodeline": "for (i = 0; i < pad_byte; i++)"
    },
    {
        "line": 124,
        "fullcodeline": "uint8_t pad_byte = block_size - rest_len;"
    },
    {
        "line": 125,
        "fullcodeline": "sc_log(ctx, \"Generating padding, padding byte: %d\", pad_byte);"
    },
    {
        "line": 126,
        "fullcodeline": "sdata = priv->sym_crypt_buffer + rest_len;"
    },
    {
        "line": 128,
        "fullcodeline": "rest_len = block_size;"
    },
    {
        "line": 214,
        "fullcodeline": "memmove(out - return_len + block_size, out - return_len, return_len - block_size);"
    },
    {
        "line": 217,
        "fullcodeline": "return_len -= block_size;"
    },
    {
        "line": 102,
        "fullcodeline": "if (pad_byte == 0 || pad_byte > block_size)"
    },
    {
        "line": 103,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);"
    },
    {
        "line": 106,
        "fullcodeline": "if (*(--sdata) != pad_byte)"
    },
    {
        "line": 62,
        "fullcodeline": "} else if (priv->algorithm_flags & SC_ALGORITHM_AES_CBC_PAD) {"
    },
    {
        "line": 107,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);"
    },
    {
        "line": 131,
        "fullcodeline": "LOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);"
    }
]