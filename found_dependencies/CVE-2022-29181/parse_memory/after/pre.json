[
    {
        "line": 5,
        "fullcodeline": "Check_Type(data, T_STRING);"
    },
    {
        "line": 11,
        "fullcodeline": "ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),"
    },
    {
        "line": 7,
        "fullcodeline": "if (!(int)RSTRING_LEN(data)) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (RTEST(encoding)) {"
    },
    {
        "line": 29,
        "fullcodeline": "return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);"
    },
    {
        "line": 8,
        "fullcodeline": "rb_raise(rb_eRuntimeError, \"data cannot be empty\");"
    },
    {
        "line": 12,
        "fullcodeline": "(int)RSTRING_LEN(data));"
    },
    {
        "line": 14,
        "fullcodeline": "xmlFree(ctxt->sax);"
    },
    {
        "line": 15,
        "fullcodeline": "ctxt->sax = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));"
    },
    {
        "line": 20,
        "fullcodeline": "if (enc != NULL) {"
    },
    {
        "line": 21,
        "fullcodeline": "xmlSwitchToEncoding(ctxt, enc);"
    },
    {
        "line": 22,
        "fullcodeline": "if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {"
    },
    {
        "line": 23,
        "fullcodeline": "rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\","
    },
    {
        "line": 24,
        "fullcodeline": "StringValueCStr(encoding));"
    }
]