[
    {
        "line": 3,
        "fullcodeline": "struct l2cap_conf_rsp *rsp = data;"
    },
    {
        "line": 4,
        "fullcodeline": "void *ptr = rsp->data;"
    },
    {
        "line": 5,
        "fullcodeline": "void *endptr = data + data_size;"
    },
    {
        "line": 6,
        "fullcodeline": "void *req = chan->conf_req;"
    },
    {
        "line": 7,
        "fullcodeline": "int len = chan->conf_len;"
    },
    {
        "line": 10,
        "fullcodeline": "struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };"
    },
    {
        "line": 12,
        "fullcodeline": "u8 remote_efs = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "u16 mtu = L2CAP_DEFAULT_MTU;"
    },
    {
        "line": 14,
        "fullcodeline": "u16 result = L2CAP_CONF_SUCCESS;"
    },
    {
        "line": 17,
        "fullcodeline": "BT_DBG(\"chan %p\", chan);"
    },
    {
        "line": 19,
        "fullcodeline": "while (len >= L2CAP_CONF_OPT_SIZE) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (chan->num_conf_rsp || chan->num_conf_req > 1)"
    },
    {
        "line": 109,
        "fullcodeline": "if (chan->mode != rfc.mode) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (result == L2CAP_CONF_SUCCESS) {"
    },
    {
        "line": 219,
        "fullcodeline": "rsp->scid   = cpu_to_le16(chan->dcid);"
    },
    {
        "line": 220,
        "fullcodeline": "rsp->result = cpu_to_le16(result);"
    },
    {
        "line": 221,
        "fullcodeline": "rsp->flags  = cpu_to_le16(0);"
    },
    {
        "line": 223,
        "fullcodeline": "return ptr - data;"
    },
    {
        "line": 20,
        "fullcodeline": "len -= l2cap_get_conf_opt(&req, &type, &olen, &val);"
    },
    {
        "line": 24,
        "fullcodeline": "hint  = type & L2CAP_CONF_HINT;"
    },
    {
        "line": 25,
        "fullcodeline": "type &= L2CAP_CONF_MASK;"
    },
    {
        "line": 110,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 116,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),"
    },
    {
        "line": 130,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);"
    },
    {
        "line": 21,
        "fullcodeline": "if (len < 0)"
    },
    {
        "line": 102,
        "fullcodeline": "if (chan->mode != rfc.mode)"
    },
    {
        "line": 113,
        "fullcodeline": "if (chan->num_conf_rsp == 1)"
    },
    {
        "line": 117,
        "fullcodeline": "(unsigned long) &rfc, endptr - ptr);"
    },
    {
        "line": 124,
        "fullcodeline": "if (mtu < L2CAP_DEFAULT_MIN_MTU)"
    },
    {
        "line": 216,
        "fullcodeline": "if (result == L2CAP_CONF_SUCCESS)"
    },
    {
        "line": 31,
        "fullcodeline": "mtu = val;"
    },
    {
        "line": 37,
        "fullcodeline": "chan->flush_to = val;"
    },
    {
        "line": 46,
        "fullcodeline": "memcpy(&rfc, (void *) val, olen);"
    },
    {
        "line": 59,
        "fullcodeline": "remote_efs = 1;"
    },
    {
        "line": 60,
        "fullcodeline": "memcpy(&efs, (void *) val, olen);"
    },
    {
        "line": 68,
        "fullcodeline": "set_bit(FLAG_EXT_CTRL, &chan->flags);"
    },
    {
        "line": 69,
        "fullcodeline": "set_bit(CONF_EWS_RECV, &chan->conf_state);"
    },
    {
        "line": 70,
        "fullcodeline": "chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;"
    },
    {
        "line": 71,
        "fullcodeline": "chan->remote_tx_win = val;"
    },
    {
        "line": 77,
        "fullcodeline": "result = L2CAP_CONF_UNKNOWN;"
    },
    {
        "line": 78,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr);"
    },
    {
        "line": 89,
        "fullcodeline": "if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {"
    },
    {
        "line": 90,
        "fullcodeline": "chan->mode = l2cap_select_mode(rfc.mode,"
    },
    {
        "line": 125,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 155,
        "fullcodeline": "set_bit(CONF_MODE_DONE, &chan->conf_state);"
    },
    {
        "line": 164,
        "fullcodeline": "chan->remote_max_tx = rfc.max_transmit;"
    },
    {
        "line": 166,
        "fullcodeline": "size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),"
    },
    {
        "line": 169,
        "fullcodeline": "rfc.max_pdu_size = cpu_to_le16(size);"
    },
    {
        "line": 170,
        "fullcodeline": "chan->remote_mps = size;"
    },
    {
        "line": 172,
        "fullcodeline": "__l2cap_set_ertm_timeouts(chan, &rfc);"
    },
    {
        "line": 174,
        "fullcodeline": "set_bit(CONF_MODE_DONE, &chan->conf_state);"
    },
    {
        "line": 176,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,"
    },
    {
        "line": 196,
        "fullcodeline": "size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),"
    },
    {
        "line": 202,
        "fullcodeline": "set_bit(CONF_MODE_DONE, &chan->conf_state);"
    },
    {
        "line": 204,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),"
    },
    {
        "line": 210,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 217,
        "fullcodeline": "set_bit(CONF_OUTPUT_DONE, &chan->conf_state);"
    },
    {
        "line": 29,
        "fullcodeline": "if (olen != 2)"
    },
    {
        "line": 35,
        "fullcodeline": "if (olen != 2)"
    },
    {
        "line": 44,
        "fullcodeline": "if (olen != sizeof(rfc))"
    },
    {
        "line": 50,
        "fullcodeline": "if (olen != 1)"
    },
    {
        "line": 52,
        "fullcodeline": "if (val == L2CAP_FCS_NONE)"
    },
    {
        "line": 57,
        "fullcodeline": "if (olen != sizeof(efs))"
    },
    {
        "line": 64,
        "fullcodeline": "if (olen != 2)"
    },
    {
        "line": 66,
        "fullcodeline": "if (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))"
    },
    {
        "line": 96,
        "fullcodeline": "if (__l2cap_efs_supported(chan->conn))"
    },
    {
        "line": 103,
        "fullcodeline": "return -ECONNREFUSED;"
    },
    {
        "line": 114,
        "fullcodeline": "return -ECONNREFUSED;"
    },
    {
        "line": 127,
        "fullcodeline": "chan->omtu = mtu;"
    },
    {
        "line": 128,
        "fullcodeline": "set_bit(CONF_MTU_DONE, &chan->conf_state);"
    },
    {
        "line": 177,
        "fullcodeline": "sizeof(rfc), (unsigned long) &rfc, endptr - ptr);"
    },
    {
        "line": 199,
        "fullcodeline": "rfc.max_pdu_size = cpu_to_le16(size);"
    },
    {
        "line": 205,
        "fullcodeline": "(unsigned long) &rfc, endptr - ptr);"
    },
    {
        "line": 53,
        "fullcodeline": "set_bit(CONF_RECV_NO_FCS, &chan->conf_state);"
    },
    {
        "line": 97,
        "fullcodeline": "set_bit(FLAG_EFS_ENABLE, &chan->flags);"
    },
    {
        "line": 133,
        "fullcodeline": "if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&"
    },
    {
        "line": 135,
        "fullcodeline": "efs.stype != chan->local_stype) {"
    },
    {
        "line": 137,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 142,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,"
    },
    {
        "line": 159,
        "fullcodeline": "if (!test_bit(CONF_EWS_RECV, &chan->conf_state))"
    },
    {
        "line": 160,
        "fullcodeline": "chan->remote_tx_win = rfc.txwin_size;"
    },
    {
        "line": 167,
        "fullcodeline": "chan->conn->mtu - L2CAP_EXT_HDR_SIZE -"
    },
    {
        "line": 189,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,"
    },
    {
        "line": 197,
        "fullcodeline": "chan->conn->mtu - L2CAP_EXT_HDR_SIZE -"
    },
    {
        "line": 67,
        "fullcodeline": "return -ECONNREFUSED;"
    },
    {
        "line": 134,
        "fullcodeline": "efs.stype != L2CAP_SERV_NOTRAFIC &&"
    },
    {
        "line": 139,
        "fullcodeline": "if (chan->num_conf_req >= 1)"
    },
    {
        "line": 144,
        "fullcodeline": "(unsigned long) &efs, endptr - ptr);"
    },
    {
        "line": 147,
        "fullcodeline": "result = L2CAP_CONF_PENDING;"
    },
    {
        "line": 148,
        "fullcodeline": "set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);"
    },
    {
        "line": 162,
        "fullcodeline": "rfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;"
    },
    {
        "line": 182,
        "fullcodeline": "chan->remote_msdu = le16_to_cpu(efs.msdu);"
    },
    {
        "line": 184,
        "fullcodeline": "le32_to_cpu(efs.flush_to);"
    },
    {
        "line": 186,
        "fullcodeline": "le32_to_cpu(efs.acc_lat);"
    },
    {
        "line": 188,
        "fullcodeline": "le32_to_cpu(efs.sdu_itime);"
    },
    {
        "line": 191,
        "fullcodeline": "(unsigned long) &efs, endptr - ptr);"
    },
    {
        "line": 99,
        "fullcodeline": "return -ECONNREFUSED;"
    },
    {
        "line": 140,
        "fullcodeline": "return -ECONNREFUSED;"
    }
]