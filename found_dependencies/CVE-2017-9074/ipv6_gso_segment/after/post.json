[
    {
        "line": 4,
        "fullcodeline": "struct sk_buff *segs = ERR_PTR(-EINVAL);"
    },
    {
        "line": 12,
        "fullcodeline": "int offset = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "skb_reset_network_header(skb);"
    },
    {
        "line": 18,
        "fullcodeline": "nhoff = skb_network_header(skb) - skb_mac_header(skb);"
    },
    {
        "line": 22,
        "fullcodeline": "encap = SKB_GSO_CB(skb)->encap_level > 0;"
    },
    {
        "line": 25,
        "fullcodeline": "SKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);"
    },
    {
        "line": 27,
        "fullcodeline": "ipv6h = ipv6_hdr(skb);"
    },
    {
        "line": 28,
        "fullcodeline": "__skb_pull(skb, sizeof(*ipv6h));"
    },
    {
        "line": 29,
        "fullcodeline": "segs = ERR_PTR(-EPROTONOSUPPORT);"
    },
    {
        "line": 31,
        "fullcodeline": "proto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);"
    },
    {
        "line": 39,
        "fullcodeline": "ops = rcu_dereference(inet6_offloads[proto]);"
    },
    {
        "line": 48,
        "fullcodeline": "gso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);"
    },
    {
        "line": 19,
        "fullcodeline": "if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))"
    },
    {
        "line": 33,
        "fullcodeline": "if (skb->encapsulation &&"
    },
    {
        "line": 40,
        "fullcodeline": "if (likely(ops && ops->callbacks.gso_segment)) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (IS_ERR_OR_NULL(segs))"
    },
    {
        "line": 50,
        "fullcodeline": "for (skb = segs; skb; skb = skb->next) {"
    },
    {
        "line": 24,
        "fullcodeline": "features &= skb->dev->hw_enc_features;"
    },
    {
        "line": 34,
        "fullcodeline": "skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))"
    },
    {
        "line": 35,
        "fullcodeline": "udpfrag = proto == IPPROTO_UDP && encap;"
    },
    {
        "line": 41,
        "fullcodeline": "skb_reset_transport_header(skb);"
    },
    {
        "line": 42,
        "fullcodeline": "segs = ops->callbacks.gso_segment(skb, features);"
    },
    {
        "line": 51,
        "fullcodeline": "ipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);"
    },
    {
        "line": 58,
        "fullcodeline": "ipv6h->payload_len = htons(payload_len);"
    },
    {
        "line": 59,
        "fullcodeline": "skb->network_header = (u8 *)ipv6h - skb->head;"
    },
    {
        "line": 37,
        "fullcodeline": "udpfrag = proto == IPPROTO_UDP && !skb->encapsulation;"
    },
    {
        "line": 53,
        "fullcodeline": "payload_len = skb_shinfo(skb)->gso_size +"
    },
    {
        "line": 62,
        "fullcodeline": "unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);"
    },
    {
        "line": 65,
        "fullcodeline": "fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);"
    },
    {
        "line": 66,
        "fullcodeline": "fptr->frag_off = htons(offset);"
    },
    {
        "line": 69,
        "fullcodeline": "offset += (ntohs(ipv6h->payload_len) -"
    },
    {
        "line": 73,
        "fullcodeline": "skb_reset_inner_headers(skb);"
    },
    {
        "line": 57,
        "fullcodeline": "payload_len = skb->len - nhoff - sizeof(*ipv6h);"
    },
    {
        "line": 63,
        "fullcodeline": "if (unfrag_ip6hlen < 0)"
    },
    {
        "line": 55,
        "fullcodeline": "skb->head - (unsigned char *)(ipv6h + 1);"
    },
    {
        "line": 68,
        "fullcodeline": "fptr->frag_off |= htons(IP6_MF);"
    },
    {
        "line": 64,
        "fullcodeline": "return ERR_PTR(unfrag_ip6hlen);"
    },
    {
        "line": 54,
        "fullcodeline": "SKB_GSO_CB(skb)->data_offset +"
    }
]