[
    {
        "line": 5,
        "fullcodeline": "struct sock_iocb *siocb = kiocb_to_siocb(iocb);"
    },
    {
        "line": 7,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 8,
        "fullcodeline": "struct unix_sock *u = unix_sk(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "int noblock = flags & MSG_DONTWAIT;"
    },
    {
        "line": 14,
        "fullcodeline": "err = -EOPNOTSUPP;"
    },
    {
        "line": 18,
        "fullcodeline": "msg->msg_namelen = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "err = mutex_lock_interruptible(&u->readlock);"
    },
    {
        "line": 26,
        "fullcodeline": "skip = sk_peek_offset(sk, flags);"
    },
    {
        "line": 28,
        "fullcodeline": "skb = __skb_recv_datagram(sk, flags, &peeked, &skip, &err);"
    },
    {
        "line": 39,
        "fullcodeline": "wake_up_interruptible_sync_poll(&u->peer_wait,"
    },
    {
        "line": 50,
        "fullcodeline": "err = skb_copy_datagram_iovec(skb, skip, msg->msg_iov, size);"
    },
    {
        "line": 61,
        "fullcodeline": "scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);"
    },
    {
        "line": 62,
        "fullcodeline": "unix_set_secdata(siocb->scm, skb);"
    },
    {
        "line": 88,
        "fullcodeline": "err = (flags & MSG_TRUNC) ? skb->len - skip : size;"
    },
    {
        "line": 90,
        "fullcodeline": "scm_recv(sock, msg, siocb->scm, flags);"
    },
    {
        "line": 93,
        "fullcodeline": "skb_free_datagram(sk, skb);"
    },
    {
        "line": 95,
        "fullcodeline": "mutex_unlock(&u->readlock);"
    },
    {
        "line": 15,
        "fullcodeline": "if (flags&MSG_OOB)"
    },
    {
        "line": 29,
        "fullcodeline": "if (!skb) {"
    },
    {
        "line": 40,
        "fullcodeline": "POLLOUT | POLLWRNORM | POLLWRBAND);"
    },
    {
        "line": 45,
        "fullcodeline": "if (size > skb->len - skip)"
    },
    {
        "line": 54,
        "fullcodeline": "if (sock_flag(sk, SOCK_RCVTSTAMP))"
    },
    {
        "line": 57,
        "fullcodeline": "if (!siocb->scm) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 22,
        "fullcodeline": "err = sock_intr_errno(sock_rcvtimeo(sk, noblock));"
    },
    {
        "line": 30,
        "fullcodeline": "unix_state_lock(sk);"
    },
    {
        "line": 35,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 43,
        "fullcodeline": "unix_copy_addr(msg, skb->sk);"
    },
    {
        "line": 46,
        "fullcodeline": "size = skb->len - skip;"
    },
    {
        "line": 55,
        "fullcodeline": "__sock_recv_timestamp(msg, sk, skb);"
    },
    {
        "line": 58,
        "fullcodeline": "siocb->scm = &tmp_scm;"
    },
    {
        "line": 59,
        "fullcodeline": "memset(&tmp_scm, 0, sizeof(tmp_scm));"
    },
    {
        "line": 68,
        "fullcodeline": "sk_peek_offset_bwd(sk, skb->len);"
    },
    {
        "line": 32,
        "fullcodeline": "if (sk->sk_type == SOCK_SEQPACKET && err == -EAGAIN &&"
    },
    {
        "line": 83,
        "fullcodeline": "sk_peek_offset_fwd(sk, size);"
    },
    {
        "line": 33,
        "fullcodeline": "(sk->sk_shutdown & RCV_SHUTDOWN))"
    },
    {
        "line": 34,
        "fullcodeline": "err = 0;"
    },
    {
        "line": 47,
        "fullcodeline": "else if (size < skb->len - skip)"
    },
    {
        "line": 65,
        "fullcodeline": "if (UNIXCB(skb).fp)"
    },
    {
        "line": 66,
        "fullcodeline": "unix_detach_fds(siocb->scm, skb);"
    },
    {
        "line": 48,
        "fullcodeline": "msg->msg_flags |= MSG_TRUNC;"
    },
    {
        "line": 85,
        "fullcodeline": "if (UNIXCB(skb).fp)"
    },
    {
        "line": 86,
        "fullcodeline": "siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);"
    }
]