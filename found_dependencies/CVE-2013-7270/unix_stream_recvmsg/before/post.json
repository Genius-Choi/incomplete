[
    {
        "line": 5,
        "fullcodeline": "struct sock_iocb *siocb = kiocb_to_siocb(iocb);"
    },
    {
        "line": 7,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 8,
        "fullcodeline": "struct unix_sock *u = unix_sk(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "struct sockaddr_un *sunaddr = msg->msg_name;"
    },
    {
        "line": 10,
        "fullcodeline": "int copied = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int check_creds = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "err = -EINVAL;"
    },
    {
        "line": 21,
        "fullcodeline": "err = -EOPNOTSUPP;"
    },
    {
        "line": 25,
        "fullcodeline": "target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);"
    },
    {
        "line": 26,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);"
    },
    {
        "line": 28,
        "fullcodeline": "msg->msg_namelen = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "err = mutex_lock_interruptible(&u->readlock);"
    },
    {
        "line": 155,
        "fullcodeline": "mutex_unlock(&u->readlock);"
    },
    {
        "line": 156,
        "fullcodeline": "scm_recv(sock, msg, siocb->scm, flags);"
    },
    {
        "line": 18,
        "fullcodeline": "if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 22,
        "fullcodeline": "if (flags&MSG_OOB)"
    },
    {
        "line": 34,
        "fullcodeline": "if (!siocb->scm) {"
    },
    {
        "line": 158,
        "fullcodeline": "return copied ? : err;"
    },
    {
        "line": 35,
        "fullcodeline": "siocb->scm = &tmp_scm;"
    },
    {
        "line": 36,
        "fullcodeline": "memset(&tmp_scm, 0, sizeof(tmp_scm));"
    },
    {
        "line": 41,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 49,
        "fullcodeline": "unix_state_lock(sk);"
    },
    {
        "line": 50,
        "fullcodeline": "last = skb = skb_peek(&sk->sk_receive_queue);"
    },
    {
        "line": 87,
        "fullcodeline": "skip = sk_peek_offset(sk, flags);"
    },
    {
        "line": 96,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 123,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 124,
        "fullcodeline": "size -= chunk;"
    },
    {
        "line": 52,
        "fullcodeline": "if (skb == NULL) {"
    },
    {
        "line": 88,
        "fullcodeline": "while (skip >= unix_skb_len(skb)) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (skb_copy_datagram_iovec(skb, UNIXCB(skb).consumed + skip,"
    },
    {
        "line": 127,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 53,
        "fullcodeline": "unix_sk(sk)->recursion_level = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 67,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 68,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 71,
        "fullcodeline": "mutex_unlock(&u->readlock);"
    },
    {
        "line": 73,
        "fullcodeline": "timeo = unix_stream_data_wait(sk, timeo, last);"
    },
    {
        "line": 83,
        "fullcodeline": "unix_state_unlock(sk);"
    },
    {
        "line": 89,
        "fullcodeline": "skip -= unix_skb_len(skb);"
    },
    {
        "line": 90,
        "fullcodeline": "last = skb;"
    },
    {
        "line": 91,
        "fullcodeline": "skb = skb_peek_next(skb, &sk->sk_receive_queue);"
    },
    {
        "line": 112,
        "fullcodeline": "unix_copy_addr(msg, skb->sk);"
    },
    {
        "line": 113,
        "fullcodeline": "sunaddr = NULL;"
    },
    {
        "line": 128,
        "fullcodeline": "UNIXCB(skb).consumed += chunk;"
    },
    {
        "line": 130,
        "fullcodeline": "sk_peek_offset_bwd(sk, chunk);"
    },
    {
        "line": 138,
        "fullcodeline": "skb_unlink(skb, &sk->sk_receive_queue);"
    },
    {
        "line": 139,
        "fullcodeline": "consume_skb(skb);"
    },
    {
        "line": 54,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 64,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 69,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 75,
        "fullcodeline": "if (signal_pending(current)"
    },
    {
        "line": 92,
        "fullcodeline": "if (!skb)"
    },
    {
        "line": 100,
        "fullcodeline": "if ((UNIXCB(skb).pid  != siocb->scm->pid) ||"
    },
    {
        "line": 119,
        "fullcodeline": "if (copied == 0)"
    },
    {
        "line": 135,
        "fullcodeline": "if (unix_skb_len(skb))"
    },
    {
        "line": 149,
        "fullcodeline": "sk_peek_offset_fwd(sk, chunk);"
    },
    {
        "line": 76,
        "fullcodeline": "||  mutex_lock_interruptible(&u->readlock)) {"
    },
    {
        "line": 77,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 102,
        "fullcodeline": "!gid_eq(UNIXCB(skb).gid, siocb->scm->creds.gid))"
    },
    {
        "line": 104,
        "fullcodeline": "} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {"
    },
    {
        "line": 120,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 132,
        "fullcodeline": "if (UNIXCB(skb).fp)"
    },
    {
        "line": 133,
        "fullcodeline": "unix_detach_fds(siocb->scm, skb);"
    },
    {
        "line": 101,
        "fullcodeline": "!uid_eq(UNIXCB(skb).uid, siocb->scm->creds.uid) ||"
    },
    {
        "line": 106,
        "fullcodeline": "scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);"
    },
    {
        "line": 107,
        "fullcodeline": "check_creds = 1;"
    },
    {
        "line": 146,
        "fullcodeline": "if (UNIXCB(skb).fp)"
    },
    {
        "line": 147,
        "fullcodeline": "siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);"
    }
]