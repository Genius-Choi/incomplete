[
    {
        "line": 4,
        "fullcodeline": "int noblock = flags & MSG_DONTWAIT;"
    },
    {
        "line": 5,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 6,
        "fullcodeline": "struct iucv_sock *iucv = iucv_sk(sk);"
    },
    {
        "line": 9,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "skb = skb_recv_datagram(sk, flags, noblock, &err);"
    },
    {
        "line": 31,
        "fullcodeline": "rlen   = skb->len - offset;\t\t/* real length of skb */"
    },
    {
        "line": 36,
        "fullcodeline": "cskb = skb;"
    },
    {
        "line": 54,
        "fullcodeline": "err = put_cmsg(msg, SOL_IUCV, SCM_IUCV_TRGCLS,"
    },
    {
        "line": 12,
        "fullcodeline": "if ((sk->sk_state == IUCV_DISCONN) &&"
    },
    {
        "line": 18,
        "fullcodeline": "if (flags & (MSG_OOB))"
    },
    {
        "line": 24,
        "fullcodeline": "if (!skb) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (!rlen)"
    },
    {
        "line": 37,
        "fullcodeline": "if (skb_copy_datagram_iovec(cskb, offset, msg->msg_iov, copied)) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (sk->sk_type == SOCK_SEQPACKET) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))"
    },
    {
        "line": 30,
        "fullcodeline": "offset = IUCV_SKB_CB(skb)->offset;"
    },
    {
        "line": 34,
        "fullcodeline": "sk->sk_shutdown = sk->sk_shutdown | RCV_SHUTDOWN;"
    },
    {
        "line": 48,
        "fullcodeline": "msg->msg_flags |= MSG_EOR;"
    },
    {
        "line": 74,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 86,
        "fullcodeline": "rskb = skb_dequeue(&iucv->backlog_skb_q);"
    },
    {
        "line": 109,
        "fullcodeline": "spin_unlock_bh(&iucv->message_q.lock);"
    },
    {
        "line": 115,
        "fullcodeline": "copied = rlen;"
    },
    {
        "line": 14,
        "fullcodeline": "skb_queue_empty(&sk->sk_receive_queue) &&"
    },
    {
        "line": 19,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 25,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 38,
        "fullcodeline": "if (!(flags & MSG_PEEK))"
    },
    {
        "line": 40,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 45,
        "fullcodeline": "if (copied < rlen)"
    },
    {
        "line": 58,
        "fullcodeline": "if (!(flags & MSG_PEEK))"
    },
    {
        "line": 67,
        "fullcodeline": "if (sk->sk_type == SOCK_STREAM) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (iucv->transport == AF_IUCV_TRANS_HIPER) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (skb_queue_empty(&iucv->backlog_skb_q)) {"
    },
    {
        "line": 13,
        "fullcodeline": "skb_queue_empty(&iucv->backlog_skb_q) &&"
    },
    {
        "line": 39,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 46,
        "fullcodeline": "msg->msg_flags |= MSG_TRUNC;"
    },
    {
        "line": 55,
        "fullcodeline": "sizeof(IUCV_SKB_CB(skb)->class),"
    },
    {
        "line": 59,
        "fullcodeline": "skb_queue_head(&sk->sk_receive_queue, skb);"
    },
    {
        "line": 76,
        "fullcodeline": "atomic_inc(&iucv->msg_recv);"
    },
    {
        "line": 88,
        "fullcodeline": "IUCV_SKB_CB(rskb)->offset = 0;"
    },
    {
        "line": 56,
        "fullcodeline": "(void *)&IUCV_SKB_CB(skb)->class);"
    },
    {
        "line": 68,
        "fullcodeline": "if (copied < rlen) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (atomic_read(&iucv->msg_recv) > iucv->msglimit) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (sock_queue_rcv_skb(sk, rskb)) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (!list_empty(&iucv->message_q.list))"
    },
    {
        "line": 100,
        "fullcodeline": "if (atomic_read(&iucv->msg_recv) >="
    },
    {
        "line": 69,
        "fullcodeline": "IUCV_SKB_CB(skb)->offset = offset + copied;"
    },
    {
        "line": 78,
        "fullcodeline": "WARN_ON(1);"
    },
    {
        "line": 79,
        "fullcodeline": "iucv_sock_close(sk);"
    },
    {
        "line": 90,
        "fullcodeline": "skb_queue_head(&iucv->backlog_skb_q,"
    },
    {
        "line": 99,
        "fullcodeline": "iucv_process_message_q(sk);"
    },
    {
        "line": 101,
        "fullcodeline": "iucv->msglimit / 2) {"
    },
    {
        "line": 102,
        "fullcodeline": "err = iucv_send_ctrl(sk, AF_IUCV_FLAG_WIN);"
    },
    {
        "line": 80,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 94,
        "fullcodeline": "rskb = skb_dequeue(&iucv->backlog_skb_q);"
    },
    {
        "line": 104,
        "fullcodeline": "sk->sk_state = IUCV_DISCONN;"
    },
    {
        "line": 105,
        "fullcodeline": "sk->sk_state_change(sk);"
    }
]