[
    {
        "line": 3,
        "fullcodeline": "uint8_t state[CONTEXT_SIZE];"
    },
    {
        "line": 4,
        "fullcodeline": "int i, j, context_count = -1; //-1 to avoid warning"
    },
    {
        "line": 7,
        "fullcodeline": "memset(state, 128, sizeof(state));"
    },
    {
        "line": 147,
        "fullcodeline": "av_dlog(f->avctx, \"%d %d %d\\n\","
    },
    {
        "line": 9,
        "fullcodeline": "if (f->version < 2) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (f->colorspace == 0) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (f->version < 2) {"
    },
    {
        "line": 170,
        "fullcodeline": "if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {"
    },
    {
        "line": 175,
        "fullcodeline": "for (j = 0; j < f->slice_count; j++) {"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned v= get_symbol(c, state, 0);"
    },
    {
        "line": 16,
        "fullcodeline": "f->version = v;"
    },
    {
        "line": 17,
        "fullcodeline": "f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);"
    },
    {
        "line": 23,
        "fullcodeline": "colorspace          = get_symbol(c, state, 0); //YUV cs type"
    },
    {
        "line": 24,
        "fullcodeline": "bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;"
    },
    {
        "line": 25,
        "fullcodeline": "chroma_planes       = get_rac(c, state);"
    },
    {
        "line": 26,
        "fullcodeline": "chroma_h_shift      = get_symbol(c, state, 0);"
    },
    {
        "line": 27,
        "fullcodeline": "chroma_v_shift      = get_symbol(c, state, 0);"
    },
    {
        "line": 28,
        "fullcodeline": "transparency        = get_rac(c, state);"
    },
    {
        "line": 48,
        "fullcodeline": "f->colorspace                 = colorspace;"
    },
    {
        "line": 49,
        "fullcodeline": "f->avctx->bits_per_raw_sample = bits_per_raw_sample;"
    },
    {
        "line": 50,
        "fullcodeline": "f->chroma_planes              = chroma_planes;"
    },
    {
        "line": 51,
        "fullcodeline": "f->chroma_h_shift             = chroma_h_shift;"
    },
    {
        "line": 52,
        "fullcodeline": "f->chroma_v_shift             = chroma_v_shift;"
    },
    {
        "line": 53,
        "fullcodeline": "f->transparency               = transparency;"
    },
    {
        "line": 55,
        "fullcodeline": "f->plane_count    = 2 + f->transparency;"
    },
    {
        "line": 143,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");"
    },
    {
        "line": 150,
        "fullcodeline": "context_count = read_quant_tables(c, f->quant_table);"
    },
    {
        "line": 155,
        "fullcodeline": "f->slice_count = f->max_slice_count;"
    },
    {
        "line": 171,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid (max=%d)\\n\", f->slice_count, f->max_slice_count);"
    },
    {
        "line": 177,
        "fullcodeline": "fs->ac            = f->ac;"
    },
    {
        "line": 178,
        "fullcodeline": "fs->packed_at_lsb = f->packed_at_lsb;"
    },
    {
        "line": 180,
        "fullcodeline": "fs->slice_damaged = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "if (v >= 2) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (f->ac > 1) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (chroma_h_shift > 4U || chroma_v_shift > 4U) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (!f->transparency && !f->chroma_planes) {"
    },
    {
        "line": 144,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 151,
        "fullcodeline": "if (context_count < 0) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (f->version == 2) {"
    },
    {
        "line": 200,
        "fullcodeline": "for (i = 0; i < f->plane_count; i++) {"
    },
    {
        "line": 13,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);"
    },
    {
        "line": 43,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"chroma shift parameters %d %d are invalid\\n\","
    },
    {
        "line": 59,
        "fullcodeline": "if (f->avctx->skip_alpha) f->transparency = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "} else if (f->colorspace == 1) {"
    },
    {
        "line": 152,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");"
    },
    {
        "line": 156,
        "fullcodeline": "} else if (f->version < 3) {"
    },
    {
        "line": 183,
        "fullcodeline": "fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;"
    },
    {
        "line": 184,
        "fullcodeline": "fs->slice_y      =  get_symbol(c, state, 0)      * f->height;"
    },
    {
        "line": 185,
        "fullcodeline": "fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;"
    },
    {
        "line": 186,
        "fullcodeline": "fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;"
    },
    {
        "line": 188,
        "fullcodeline": "fs->slice_x     /= f->num_h_slices;"
    },
    {
        "line": 189,
        "fullcodeline": "fs->slice_y     /= f->num_v_slices;"
    },
    {
        "line": 190,
        "fullcodeline": "fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;"
    },
    {
        "line": 191,
        "fullcodeline": "fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;"
    },
    {
        "line": 19,
        "fullcodeline": "for (i = 1; i < 256; i++)"
    },
    {
        "line": 20,
        "fullcodeline": "f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];"
    },
    {
        "line": 31,
        "fullcodeline": "if (colorspace          != f->colorspace                 ||"
    },
    {
        "line": 61,
        "fullcodeline": "if (f->avctx->bits_per_raw_sample <= 8)"
    },
    {
        "line": 157,
        "fullcodeline": "f->slice_count = get_symbol(c, state, 0);"
    },
    {
        "line": 192,
        "fullcodeline": "if ((unsigned)fs->slice_width  > f->width ||"
    },
    {
        "line": 195,
        "fullcodeline": "if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width"
    },
    {
        "line": 203,
        "fullcodeline": "if (f->version == 2) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (f->version <= 2) {"
    },
    {
        "line": 36,
        "fullcodeline": "transparency        != f->transparency) {"
    },
    {
        "line": 37,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");"
    },
    {
        "line": 62,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;"
    },
    {
        "line": 65,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (f->chroma_h_shift || f->chroma_v_shift) {"
    },
    {
        "line": 127,
        "fullcodeline": "if (     f->avctx->bits_per_raw_sample ==  9)"
    },
    {
        "line": 139,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");"
    },
    {
        "line": 159,
        "fullcodeline": "const uint8_t *p = c->bytestream_end;"
    },
    {
        "line": 193,
        "fullcodeline": "(unsigned)fs->slice_height > f->height)"
    },
    {
        "line": 196,
        "fullcodeline": "|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)"
    },
    {
        "line": 204,
        "fullcodeline": "int idx = get_symbol(c, state, 0);"
    },
    {
        "line": 210,
        "fullcodeline": "p->quant_table_index = idx;"
    },
    {
        "line": 211,
        "fullcodeline": "memcpy(p->quant_table, f->quant_tables[idx],"
    },
    {
        "line": 219,
        "fullcodeline": "av_assert0(context_count >= 0);"
    },
    {
        "line": 224,
        "fullcodeline": "p->context_count = context_count;"
    },
    {
        "line": 35,
        "fullcodeline": "chroma_v_shift      != f->chroma_v_shift             ||"
    },
    {
        "line": 64,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;"
    },
    {
        "line": 123,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR,"
    },
    {
        "line": 128,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;"
    },
    {
        "line": 140,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 161,
        "fullcodeline": "f->slice_count < MAX_SLICES && 3 + 5*!!f->ec < p - c->bytestream_start;"
    },
    {
        "line": 162,
        "fullcodeline": "f->slice_count++) {"
    },
    {
        "line": 205,
        "fullcodeline": "if (idx > (unsigned)f->quant_table_count) {"
    },
    {
        "line": 215,
        "fullcodeline": "memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));"
    },
    {
        "line": 220,
        "fullcodeline": "if (p->context_count < context_count) {"
    },
    {
        "line": 34,
        "fullcodeline": "chroma_h_shift      != f->chroma_h_shift             ||"
    },
    {
        "line": 66,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 125,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 160,
        "fullcodeline": "for (f->slice_count = 0;"
    },
    {
        "line": 163,
        "fullcodeline": "int trailer = 3 + 5*!!f->ec;"
    },
    {
        "line": 164,
        "fullcodeline": "int size = AV_RB24(p-trailer);"
    },
    {
        "line": 167,
        "fullcodeline": "p -= size + trailer;"
    },
    {
        "line": 206,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR,"
    },
    {
        "line": 221,
        "fullcodeline": "av_freep(&p->state);"
    },
    {
        "line": 222,
        "fullcodeline": "av_freep(&p->vlc_state);"
    },
    {
        "line": 33,
        "fullcodeline": "chroma_planes       != f->chroma_planes              ||"
    },
    {
        "line": 67,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;"
    },
    {
        "line": 68,
        "fullcodeline": "case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;"
    },
    {
        "line": 69,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;"
    },
    {
        "line": 70,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;"
    },
    {
        "line": 71,
        "fullcodeline": "case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;"
    },
    {
        "line": 72,
        "fullcodeline": "case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;"
    },
    {
        "line": 74,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {"
    },
    {
        "line": 129,
        "fullcodeline": "else if (f->avctx->bits_per_raw_sample == 10)"
    },
    {
        "line": 165,
        "fullcodeline": "if (size + trailer > p - c->bytestream_start)"
    },
    {
        "line": 32,
        "fullcodeline": "bits_per_raw_sample != f->avctx->bits_per_raw_sample ||"
    },
    {
        "line": 130,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;"
    },
    {
        "line": 75,
        "fullcodeline": "switch(16*f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 76,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;"
    },
    {
        "line": 77,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;"
    },
    {
        "line": 78,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;"
    },
    {
        "line": 80,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {"
    },
    {
        "line": 131,
        "fullcodeline": "else if (f->avctx->bits_per_raw_sample == 12)"
    },
    {
        "line": 81,
        "fullcodeline": "f->packed_at_lsb = 1;"
    },
    {
        "line": 132,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;"
    },
    {
        "line": 82,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 83,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;"
    },
    {
        "line": 84,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;"
    },
    {
        "line": 85,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;"
    },
    {
        "line": 87,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {"
    },
    {
        "line": 133,
        "fullcodeline": "else if (f->avctx->bits_per_raw_sample == 14)"
    },
    {
        "line": 88,
        "fullcodeline": "f->packed_at_lsb = 1;"
    },
    {
        "line": 134,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;"
    },
    {
        "line": 89,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 90,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;"
    },
    {
        "line": 91,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;"
    },
    {
        "line": 92,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;"
    },
    {
        "line": 94,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {"
    },
    {
        "line": 95,
        "fullcodeline": "f->packed_at_lsb = 1;"
    },
    {
        "line": 136,
        "fullcodeline": "if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;"
    },
    {
        "line": 96,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 137,
        "fullcodeline": "else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;"
    },
    {
        "line": 97,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;"
    },
    {
        "line": 98,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;"
    },
    {
        "line": 99,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;"
    },
    {
        "line": 101,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {"
    },
    {
        "line": 102,
        "fullcodeline": "f->packed_at_lsb = 1;"
    },
    {
        "line": 103,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 104,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;"
    },
    {
        "line": 105,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;"
    },
    {
        "line": 106,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;"
    },
    {
        "line": 108,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){"
    },
    {
        "line": 109,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 110,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;"
    },
    {
        "line": 111,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;"
    },
    {
        "line": 112,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;"
    },
    {
        "line": 114,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){"
    },
    {
        "line": 115,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 116,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;"
    },
    {
        "line": 117,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;"
    },
    {
        "line": 118,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;"
    }
]