[
    {
        "line": 13,
        "fullcodeline": "memcpy(wsctx->writePos, wsctx->carryBuf, wsctx->carrylen);"
    },
    {
        "line": 14,
        "fullcodeline": "wsctx->writePos += wsctx->carrylen;"
    },
    {
        "line": 17,
        "fullcodeline": "bufsize = wsctx->codeBufDecode + ARRAYSIZE(wsctx->codeBufDecode) - wsctx->writePos - 1;"
    },
    {
        "line": 18,
        "fullcodeline": "ws_dbg(\"bufsize=%d\\n\", bufsize);"
    },
    {
        "line": 25,
        "fullcodeline": "ws_dbg(\"calling read with buf=%p and len=%d (decodebuf=%p headerLen=%d)\\n\", wsctx->writePos, nextRead, wsctx->codeBufDecode, wsctx->header.headerLen);"
    },
    {
        "line": 45,
        "fullcodeline": "wsctx->nReadPayload += n;"
    },
    {
        "line": 46,
        "fullcodeline": "wsctx->writePos += n;"
    },
    {
        "line": 54,
        "fullcodeline": "toDecode = n + wsctx->carrylen + nInBuf;"
    },
    {
        "line": 55,
        "fullcodeline": "ws_dbg(\"toDecode=%d from n=%d carrylen=%d headerLen=%d\\n\", toDecode, n, wsctx->carrylen, wsctx->header.headerLen);"
    },
    {
        "line": 65,
        "fullcodeline": "data = (unsigned char *)(wsctx->writePos - toDecode);"
    },
    {
        "line": 66,
        "fullcodeline": "data32= (uint32_t *)data;"
    },
    {
        "line": 71,
        "fullcodeline": "ws_dbg(\"mask decoding; i=%d toDecode=%d\\n\", i, toDecode);"
    },
    {
        "line": 95,
        "fullcodeline": "toReturn = toDecode - wsctx->carrylen;"
    },
    {
        "line": 129,
        "fullcodeline": "wsctx->readPos = data;"
    },
    {
        "line": 19,
        "fullcodeline": "if (hybiRemaining(wsctx) > bufsize) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (nextRead > 0) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (hybiRemaining(wsctx) == 0) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (toDecode < 0) {"
    },
    {
        "line": 68,
        "fullcodeline": "for (i = 0; i < (toDecode >> 2); i++) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (wsctx->hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE) {"
    },
    {
        "line": 131,
        "fullcodeline": "return hybiReturnData(dst, len, wsctx, sockRet);"
    },
    {
        "line": 20,
        "fullcodeline": "nextRead = bufsize;"
    },
    {
        "line": 49,
        "fullcodeline": "wsctx->hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE;"
    },
    {
        "line": 57,
        "fullcodeline": "rfbErr(\"%s: internal error; negative number of bytes to decode: %d\", __func__, toDecode);"
    },
    {
        "line": 58,
        "fullcodeline": "errno=EIO;"
    },
    {
        "line": 59,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 69,
        "fullcodeline": "data32[i] ^= wsctx->header.mask.u;"
    },
    {
        "line": 80,
        "fullcodeline": "wsctx->carrylen = 0;"
    },
    {
        "line": 114,
        "fullcodeline": "data[toReturn] = '\\0';"
    },
    {
        "line": 115,
        "fullcodeline": "ws_dbg(\"Initiate Base64 decoding in %p with max size %d and '\\\\0' at %p\\n\", data, bufsize, data + toReturn);"
    },
    {
        "line": 119,
        "fullcodeline": "wsctx->writePos = hybiPayloadStart(wsctx);"
    },
    {
        "line": 122,
        "fullcodeline": "wsctx->readlen = toReturn;"
    },
    {
        "line": 123,
        "fullcodeline": "wsctx->writePos = hybiPayloadStart(wsctx);"
    },
    {
        "line": 124,
        "fullcodeline": "ws_dbg(\"set readlen=%d writePos=%p\\n\", wsctx->readlen, wsctx->writePos);"
    },
    {
        "line": 127,
        "fullcodeline": "rfbErr(\"%s: unhandled opcode %d, b0: %02x, b1: %02x\\n\", __func__, (int)wsctx->header.opcode, wsctx->header.data->b0, wsctx->header.data->b1);"
    },
    {
        "line": 22,
        "fullcodeline": "nextRead = hybiRemaining(wsctx);"
    },
    {
        "line": 29,
        "fullcodeline": "if (-1 == (n = wsctx->ctxInfo.readFunc(wsctx->ctxInfo.ctxPtr, wsctx->writePos, nextRead))) {"
    },
    {
        "line": 42,
        "fullcodeline": "n = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "for (i*=4; i < toDecode; i++) {"
    },
    {
        "line": 83,
        "fullcodeline": "wsctx->carrylen = toDecode - (i * 4);"
    },
    {
        "line": 90,
        "fullcodeline": "ws_dbg(\"carrying over %d bytes from %p to %p\\n\", wsctx->carrylen, wsctx->writePos + (i * 4), wsctx->carryBuf);"
    },
    {
        "line": 91,
        "fullcodeline": "memcpy(wsctx->carryBuf, data + (i * 4), wsctx->carrylen);"
    },
    {
        "line": 92,
        "fullcodeline": "wsctx->writePos -= wsctx->carrylen;"
    },
    {
        "line": 100,
        "fullcodeline": "if (hybiWsFrameComplete(wsctx)) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (-1 == (wsctx->readlen = rfbBase64PtoN((char *)data, data, bufsize))) {"
    },
    {
        "line": 30,
        "fullcodeline": "int olderrno = errno;"
    },
    {
        "line": 31,
        "fullcodeline": "rfbErr(\"%s: read; %s\", __func__, strerror(errno));"
    },
    {
        "line": 32,
        "fullcodeline": "errno = olderrno;"
    },
    {
        "line": 33,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 76,
        "fullcodeline": "data[i] ^= wsctx->header.mask.c[i % 4];"
    },
    {
        "line": 84,
        "fullcodeline": "if (wsctx->carrylen < 0 || wsctx->carrylen > ARRAYSIZE(wsctx->carryBuf)) {"
    },
    {
        "line": 101,
        "fullcodeline": "*(wsctx->writePos) = '\\0';"
    },
    {
        "line": 102,
        "fullcodeline": "ws_dbg(\"got close cmd %d, reason %d: %s\\n\", (int)(wsctx->writePos - hybiPayloadStart(wsctx)), WS_NTOH16(((uint16_t *)hybiPayloadStart(wsctx))[0]), &hybiPayloadStart(wsctx)[2]);"
    },
    {
        "line": 103,
        "fullcodeline": "errno = ECONNRESET;"
    },
    {
        "line": 104,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 117,
        "fullcodeline": "rfbErr(\"%s: Base64 decode error; %s\\n\", __func__, strerror(errno));"
    },
    {
        "line": 85,
        "fullcodeline": "rfbErr(\"%s: internal error, invalid carry over size: carrylen=%d, toDecode=%d, i=%d\", __func__, wsctx->carrylen, toDecode, i);"
    },
    {
        "line": 86,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 87,
        "fullcodeline": "errno = EIO;"
    },
    {
        "line": 107,
        "fullcodeline": "ws_dbg(\"got close cmd; waiting for %d more bytes to arrive\\n\", hybiRemaining(wsctx));"
    },
    {
        "line": 108,
        "fullcodeline": "*sockRet = -1;"
    },
    {
        "line": 109,
        "fullcodeline": "errno = EAGAIN;"
    },
    {
        "line": 35,
        "fullcodeline": "} else if (n == 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "*sockRet = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "ws_dbg(\"read %d bytes from socket; nRead=%d\\n\", n, wsctx->nReadPayload);"
    }
]