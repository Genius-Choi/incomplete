[
    {
        "line": 4,
        "fullcodeline": "const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;"
    },
    {
        "line": 5,
        "fullcodeline": "const char *dagid_str = \"<elided>\";"
    },
    {
        "line": 7,
        "fullcodeline": "ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);"
    },
    {
        "line": 11,
        "fullcodeline": "bp += ND_RPL_DAOACK_MIN_LEN;"
    },
    {
        "line": 12,
        "fullcodeline": "length -= ND_RPL_DAOACK_MIN_LEN;"
    },
    {
        "line": 22,
        "fullcodeline": "ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\","
    },
    {
        "line": 8,
        "fullcodeline": "if (length < ND_RPL_DAOACK_MIN_LEN)"
    },
    {
        "line": 13,
        "fullcodeline": "if(RPL_DAOACK_D(daoack->rpl_flags)) {"
    },
    {
        "line": 29,
        "fullcodeline": "if(ndo->ndo_vflag > 1) {"
    },
    {
        "line": 40,
        "fullcodeline": "ND_PRINT((ndo,\" [|dao-length too short]\"));"
    },
    {
        "line": 14,
        "fullcodeline": "ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);"
    },
    {
        "line": 17,
        "fullcodeline": "dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);"
    },
    {
        "line": 18,
        "fullcodeline": "bp += DAGID_LEN;"
    },
    {
        "line": 19,
        "fullcodeline": "length -= DAGID_LEN;"
    },
    {
        "line": 30,
        "fullcodeline": "const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;"
    },
    {
        "line": 31,
        "fullcodeline": "rpl_dio_printopt(ndo, opt, length);"
    },
    {
        "line": 15,
        "fullcodeline": "if (length < DAGID_LEN)"
    }
]