[
    {
        "line": 4,
        "fullcodeline": "struct tipc_aead_key *skey = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "u16 key_gen = msg_key_gen(hdr);"
    },
    {
        "line": 6,
        "fullcodeline": "u16 size = msg_data_sz(hdr);"
    },
    {
        "line": 7,
        "fullcodeline": "u8 *data = msg_data(hdr);"
    },
    {
        "line": 16,
        "fullcodeline": "keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));"
    },
    {
        "line": 25,
        "fullcodeline": "spin_lock(&rx->lock);"
    },
    {
        "line": 33,
        "fullcodeline": "skey = kmalloc(size, GFP_ATOMIC);"
    },
    {
        "line": 40,
        "fullcodeline": "skey->keylen = keylen;"
    },
    {
        "line": 41,
        "fullcodeline": "memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);"
    },
    {
        "line": 42,
        "fullcodeline": "memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),"
    },
    {
        "line": 45,
        "fullcodeline": "rx->key_gen = key_gen;"
    },
    {
        "line": 46,
        "fullcodeline": "rx->skey_mode = msg_key_mode(hdr);"
    },
    {
        "line": 47,
        "fullcodeline": "rx->skey = skey;"
    },
    {
        "line": 48,
        "fullcodeline": "rx->nokey = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "mb(); /* for nokey flag */"
    },
    {
        "line": 52,
        "fullcodeline": "spin_unlock(&rx->lock);"
    },
    {
        "line": 11,
        "fullcodeline": "if (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||"
    },
    {
        "line": 26,
        "fullcodeline": "if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (unlikely(!skey)) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))"
    },
    {
        "line": 3,
        "fullcodeline": "struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;"
    },
    {
        "line": 12,
        "fullcodeline": "pr_debug(\"%s: message data size is too small\\n\", rx->name);"
    },
    {
        "line": 21,
        "fullcodeline": "pr_debug(\"%s: invalid MSG_CRYPTO key size\\n\", rx->name);"
    },
    {
        "line": 27,
        "fullcodeline": "pr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,"
    },
    {
        "line": 35,
        "fullcodeline": "pr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);"
    },
    {
        "line": 20,
        "fullcodeline": "keylen > TIPC_AEAD_KEY_SIZE_MAX)) {"
    }
]