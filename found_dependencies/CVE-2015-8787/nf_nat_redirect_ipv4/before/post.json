[
    {
        "line": 10,
        "fullcodeline": "NF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||"
    },
    {
        "line": 13,
        "fullcodeline": "ct = nf_ct_get(skb, &ctinfo);"
    },
    {
        "line": 14,
        "fullcodeline": "NF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));"
    },
    {
        "line": 38,
        "fullcodeline": "memset(&newrange.min_addr, 0, sizeof(newrange.min_addr));"
    },
    {
        "line": 39,
        "fullcodeline": "memset(&newrange.max_addr, 0, sizeof(newrange.max_addr));"
    },
    {
        "line": 40,
        "fullcodeline": "newrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;"
    },
    {
        "line": 41,
        "fullcodeline": "newrange.min_addr.ip = newdst;"
    },
    {
        "line": 42,
        "fullcodeline": "newrange.max_addr.ip = newdst;"
    },
    {
        "line": 17,
        "fullcodeline": "if (hooknum == NF_INET_LOCAL_OUT) {"
    },
    {
        "line": 47,
        "fullcodeline": "return nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);"
    },
    {
        "line": 11,
        "fullcodeline": "hooknum == NF_INET_LOCAL_OUT);"
    },
    {
        "line": 18,
        "fullcodeline": "newdst = htonl(0x7F000001);"
    },
    {
        "line": 23,
        "fullcodeline": "newdst = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "rcu_read_lock();"
    },
    {
        "line": 26,
        "fullcodeline": "indev = __in_dev_get_rcu(skb->dev);"
    },
    {
        "line": 31,
        "fullcodeline": "rcu_read_unlock();"
    },
    {
        "line": 27,
        "fullcodeline": "if (indev != NULL) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (!newdst)"
    },
    {
        "line": 28,
        "fullcodeline": "ifa = indev->ifa_list;"
    },
    {
        "line": 29,
        "fullcodeline": "newdst = ifa->ifa_local;"
    }
]