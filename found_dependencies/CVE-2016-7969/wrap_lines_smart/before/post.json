[
    {
        "line": 12,
        "fullcodeline": "TextInfo *text_info = &render_priv->text_info;"
    },
    {
        "line": 14,
        "fullcodeline": "last_space = -1;"
    },
    {
        "line": 15,
        "fullcodeline": "text_info->n_lines = 1;"
    },
    {
        "line": 16,
        "fullcodeline": "break_type = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "s1 = text_info->glyphs;     // current line start"
    },
    {
        "line": 61,
        "fullcodeline": "exit = 0;"
    },
    {
        "line": 112,
        "fullcodeline": "assert(text_info->n_lines >= 1);"
    },
    {
        "line": 115,
        "fullcodeline": "measure_text(render_priv);"
    },
    {
        "line": 116,
        "fullcodeline": "trim_whitespace(render_priv);"
    },
    {
        "line": 118,
        "fullcodeline": "cur_line = 1;"
    },
    {
        "line": 119,
        "fullcodeline": "run_offset = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 122,
        "fullcodeline": "cur = text_info->glyphs + i;"
    },
    {
        "line": 125,
        "fullcodeline": "pen_shift_x = d6_to_double(-cur->pos.x);"
    },
    {
        "line": 126,
        "fullcodeline": "pen_shift_y = 0.;"
    },
    {
        "line": 147,
        "fullcodeline": "text_info->lines[cur_line - 1].len ="
    },
    {
        "line": 18,
        "fullcodeline": "for (i = 0; i < text_info->length; ++i) {"
    },
    {
        "line": 62,
        "fullcodeline": "while (!exit && render_priv->state.wrap_style != 1) {"
    },
    {
        "line": 123,
        "fullcodeline": "while (i < text_info->length && cur->skip)"
    },
    {
        "line": 124,
        "fullcodeline": "cur = text_info->glyphs + ++i;"
    },
    {
        "line": 128,
        "fullcodeline": "for (i = 0; i < text_info->length; ++i) {"
    },
    {
        "line": 148,
        "fullcodeline": "text_info->length - text_info->lines[cur_line - 1].offset;"
    },
    {
        "line": 19,
        "fullcodeline": "int break_at = -1;"
    },
    {
        "line": 21,
        "fullcodeline": "cur = text_info->glyphs + i;"
    },
    {
        "line": 22,
        "fullcodeline": "s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);"
    },
    {
        "line": 23,
        "fullcodeline": "len = d6_to_double(cur->bbox.xMax + cur->pos.x) - s_offset;"
    },
    {
        "line": 63,
        "fullcodeline": "exit = 1;"
    },
    {
        "line": 64,
        "fullcodeline": "s3 = text_info->glyphs;"
    },
    {
        "line": 65,
        "fullcodeline": "s1 = s2 = 0;"
    },
    {
        "line": 129,
        "fullcodeline": "cur = text_info->glyphs + i;"
    },
    {
        "line": 144,
        "fullcodeline": "cur->pos.x += double_to_d6(pen_shift_x);"
    },
    {
        "line": 145,
        "fullcodeline": "cur->pos.y += double_to_d6(pen_shift_y);"
    },
    {
        "line": 25,
        "fullcodeline": "if (cur->symbol == '\\n') {"
    },
    {
        "line": 41,
        "fullcodeline": "if (break_at != -1) {"
    },
    {
        "line": 66,
        "fullcodeline": "for (i = 0; i <= text_info->length; ++i) {"
    },
    {
        "line": 26,
        "fullcodeline": "break_type = 2;"
    },
    {
        "line": 27,
        "fullcodeline": "break_at = i;"
    },
    {
        "line": 28,
        "fullcodeline": "ass_msg(render_priv->library, MSGL_DBG2,"
    },
    {
        "line": 44,
        "fullcodeline": "int lead = break_at + 1;    // the first symbol of the new line"
    },
    {
        "line": 67,
        "fullcodeline": "cur = text_info->glyphs + i;"
    },
    {
        "line": 136,
        "fullcodeline": "text_info->lines[cur_line - 1].len = i -"
    },
    {
        "line": 138,
        "fullcodeline": "text_info->lines[cur_line].offset = i;"
    },
    {
        "line": 139,
        "fullcodeline": "cur_line++;"
    },
    {
        "line": 140,
        "fullcodeline": "run_offset++;"
    },
    {
        "line": 141,
        "fullcodeline": "pen_shift_x = d6_to_double(-cur->pos.x);"
    },
    {
        "line": 142,
        "fullcodeline": "pen_shift_y += height + render_priv->settings.line_spacing;"
    },
    {
        "line": 45,
        "fullcodeline": "if (text_info->n_lines >= text_info->max_lines) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (lead < text_info->length) {"
    },
    {
        "line": 68,
        "fullcodeline": "if ((i == text_info->length) || cur->linebreak) {"
    },
    {
        "line": 107,
        "fullcodeline": "if (i == text_info->length)"
    },
    {
        "line": 131,
        "fullcodeline": "while (i < text_info->length && cur->skip && cur->symbol != '\\n')"
    },
    {
        "line": 132,
        "fullcodeline": "cur = text_info->glyphs + ++i;"
    },
    {
        "line": 30,
        "fullcodeline": "} else if (cur->symbol == ' ') {"
    },
    {
        "line": 47,
        "fullcodeline": "text_info->max_lines *= 2;"
    },
    {
        "line": 48,
        "fullcodeline": "text_info->lines = realloc(text_info->lines,"
    },
    {
        "line": 53,
        "fullcodeline": "text_info->glyphs[lead].linebreak = break_type;"
    },
    {
        "line": 54,
        "fullcodeline": "last_space = -1;"
    },
    {
        "line": 55,
        "fullcodeline": "s1 = text_info->glyphs + lead;"
    },
    {
        "line": 56,
        "fullcodeline": "text_info->n_lines++;"
    },
    {
        "line": 69,
        "fullcodeline": "s1 = s2;"
    },
    {
        "line": 70,
        "fullcodeline": "s2 = s3;"
    },
    {
        "line": 71,
        "fullcodeline": "s3 = cur;"
    },
    {
        "line": 31,
        "fullcodeline": "last_space = i;"
    },
    {
        "line": 72,
        "fullcodeline": "if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'"
    },
    {
        "line": 49,
        "fullcodeline": "sizeof(LineInfo) *"
    },
    {
        "line": 74,
        "fullcodeline": "GlyphInfo *w = s2;"
    },
    {
        "line": 82,
        "fullcodeline": "e1 = w;"
    },
    {
        "line": 89,
        "fullcodeline": "l1 = d6_to_double(((s2 - 1)->bbox.xMax + (s2 - 1)->pos.x) -"
    },
    {
        "line": 91,
        "fullcodeline": "l2 = d6_to_double(((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -"
    },
    {
        "line": 93,
        "fullcodeline": "l1_new = d6_to_double("
    },
    {
        "line": 96,
        "fullcodeline": "l2_new = d6_to_double("
    },
    {
        "line": 134,
        "fullcodeline": "text_info->lines[cur_line - 1].desc +"
    },
    {
        "line": 137,
        "fullcodeline": "text_info->lines[cur_line - 1].offset;"
    },
    {
        "line": 32,
        "fullcodeline": "} else if (len >= max_text_width"
    },
    {
        "line": 78,
        "fullcodeline": "} while ((w > s1) && (w->symbol == ' '));"
    },
    {
        "line": 79,
        "fullcodeline": "while ((w > s1) && (w->symbol != ' ')) {"
    },
    {
        "line": 83,
        "fullcodeline": "while ((e1 > s1) && (e1->symbol == ' ')) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (w->symbol == ' ')"
    },
    {
        "line": 100,
        "fullcodeline": "if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {"
    },
    {
        "line": 33,
        "fullcodeline": "&& (render_priv->state.wrap_style != 2)) {"
    },
    {
        "line": 34,
        "fullcodeline": "break_type = 1;"
    },
    {
        "line": 35,
        "fullcodeline": "break_at = last_space;"
    },
    {
        "line": 77,
        "fullcodeline": "--w;"
    },
    {
        "line": 80,
        "fullcodeline": "--w;"
    },
    {
        "line": 84,
        "fullcodeline": "--e1;"
    },
    {
        "line": 87,
        "fullcodeline": "++w;"
    },
    {
        "line": 101,
        "fullcodeline": "w->linebreak = 1;"
    },
    {
        "line": 102,
        "fullcodeline": "s2->linebreak = 0;"
    },
    {
        "line": 103,
        "fullcodeline": "exit = 0;"
    },
    {
        "line": 36,
        "fullcodeline": "if (break_at >= 0)"
    },
    {
        "line": 37,
        "fullcodeline": "ass_msg(render_priv->library, MSGL_DBG2, \"line break at %d\","
    },
    {
        "line": 97,
        "fullcodeline": "((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -"
    }
]