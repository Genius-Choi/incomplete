[
    {
        "line": 4,
        "fullcodeline": "ALGobject * new=NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "int keylen, IVlen=0, mode=MODE_ECB, segment_size=0;"
    },
    {
        "line": 6,
        "fullcodeline": "PyObject *counter = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "int counter_shortcut = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "new = newALGobject();"
    },
    {
        "line": 112,
        "fullcodeline": "new->segment_size = segment_size;"
    },
    {
        "line": 113,
        "fullcodeline": "new->counter = counter;"
    },
    {
        "line": 114,
        "fullcodeline": "Py_XINCREF(counter);"
    },
    {
        "line": 115,
        "fullcodeline": "new->counter_shortcut = counter_shortcut;"
    },
    {
        "line": 120,
        "fullcodeline": "block_init(&(new->st), key, keylen);"
    },
    {
        "line": 126,
        "fullcodeline": "memset(new->IV, 0, BLOCK_SIZE);"
    },
    {
        "line": 127,
        "fullcodeline": "memset(new->oldCipher, 0, BLOCK_SIZE);"
    },
    {
        "line": 128,
        "fullcodeline": "memcpy(new->IV, IV, IVlen);"
    },
    {
        "line": 129,
        "fullcodeline": "new->mode = mode;"
    },
    {
        "line": 130,
        "fullcodeline": "new->count=BLOCK_SIZE;   /* stores how many bytes in new->oldCipher have been used */"
    },
    {
        "line": 12,
        "fullcodeline": "if (!PyArg_ParseTupleAndKeywords(args, kwdict, \"s#|is#Oi\""
    },
    {
        "line": 27,
        "fullcodeline": "if (mode<MODE_ECB || mode>MODE_CTR)"
    },
    {
        "line": 34,
        "fullcodeline": "if (mode == MODE_PGP) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (KEY_SIZE!=0 && keylen!=KEY_SIZE)"
    },
    {
        "line": 46,
        "fullcodeline": "if (KEY_SIZE==0 && keylen==0)"
    },
    {
        "line": 52,
        "fullcodeline": "if (IVlen != 0 && mode == MODE_ECB)"
    },
    {
        "line": 57,
        "fullcodeline": "if (IVlen != 0 && mode == MODE_CTR)"
    },
    {
        "line": 63,
        "fullcodeline": "if (IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR)"
    },
    {
        "line": 71,
        "fullcodeline": "if (mode == MODE_CFB) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (mode == MODE_CTR) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (PyErr_Occurred())"
    },
    {
        "line": 29,
        "fullcodeline": "PyErr_Format(PyExc_ValueError,"
    },
    {
        "line": 35,
        "fullcodeline": "PyErr_Format(PyExc_ValueError,"
    },
    {
        "line": 41,
        "fullcodeline": "PyErr_Format(PyExc_ValueError,"
    },
    {
        "line": 48,
        "fullcodeline": "PyErr_SetString(PyExc_ValueError,"
    },
    {
        "line": 54,
        "fullcodeline": "PyErr_Format(PyExc_ValueError, \"ECB mode does not use IV\");"
    },
    {
        "line": 59,
        "fullcodeline": "PyErr_Format(PyExc_ValueError,"
    },
    {
        "line": 65,
        "fullcodeline": "PyErr_Format(PyExc_ValueError,"
    },
    {
        "line": 123,
        "fullcodeline": "Py_DECREF(new);"
    },
    {
        "line": 72,
        "fullcodeline": "if (segment_size == 0) segment_size = 8;"
    },
    {
        "line": 73,
        "fullcodeline": "if (segment_size < 1 || segment_size > BLOCK_SIZE*8 || ((segment_size & 7) != 0)) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (counter == NULL) {"
    },
    {
        "line": 74,
        "fullcodeline": "PyErr_Format(PyExc_ValueError,"
    },
    {
        "line": 82,
        "fullcodeline": "PyErr_SetString(PyExc_TypeError,"
    },
    {
        "line": 93,
        "fullcodeline": "if (counter != NULL) {"
    },
    {
        "line": 76,
        "fullcodeline": "\"between 1 and %i\", BLOCK_SIZE*8);"
    },
    {
        "line": 94,
        "fullcodeline": "PyErr_SetString(PyExc_ValueError,"
    },
    {
        "line": 85,
        "fullcodeline": "} else if (Py_TYPE(counter) == PCT_CounterBEType || Py_TYPE(counter) == PCT_CounterLEType) {"
    },
    {
        "line": 86,
        "fullcodeline": "counter_shortcut = 1;"
    },
    {
        "line": 87,
        "fullcodeline": "} else if (!PyCallable_Check(counter)) {"
    },
    {
        "line": 88,
        "fullcodeline": "PyErr_SetString(PyExc_ValueError,"
    }
]