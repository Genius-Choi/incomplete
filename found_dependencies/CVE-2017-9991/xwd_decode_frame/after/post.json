[
    {
        "line": 4,
        "fullcodeline": "AVFrame *p = data;"
    },
    {
        "line": 5,
        "fullcodeline": "const uint8_t *buf = avpkt->data;"
    },
    {
        "line": 6,
        "fullcodeline": "int i, ret, buf_size = avpkt->size;"
    },
    {
        "line": 10,
        "fullcodeline": "uint32_t rgb[3];"
    },
    {
        "line": 17,
        "fullcodeline": "bytestream2_init(&gb, buf, buf_size);"
    },
    {
        "line": 18,
        "fullcodeline": "header_size = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 20,
        "fullcodeline": "version = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 31,
        "fullcodeline": "pixformat     = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 32,
        "fullcodeline": "pixdepth      = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 33,
        "fullcodeline": "avctx->width  = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 34,
        "fullcodeline": "avctx->height = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 35,
        "fullcodeline": "xoffset       = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 36,
        "fullcodeline": "be            = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 37,
        "fullcodeline": "bunit         = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 38,
        "fullcodeline": "bitorder      = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 39,
        "fullcodeline": "bpad          = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 40,
        "fullcodeline": "bpp           = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 41,
        "fullcodeline": "lsize         = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 42,
        "fullcodeline": "vclass        = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 43,
        "fullcodeline": "rgb[0]        = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 44,
        "fullcodeline": "rgb[1]        = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 45,
        "fullcodeline": "rgb[2]        = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 46,
        "fullcodeline": "bytestream2_skipu(&gb, 8);"
    },
    {
        "line": 47,
        "fullcodeline": "ncolors       = bytestream2_get_be32u(&gb);"
    },
    {
        "line": 48,
        "fullcodeline": "bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20));"
    },
    {
        "line": 108,
        "fullcodeline": "rsize = FFALIGN(avctx->width * bpp, bpad) / 8;"
    },
    {
        "line": 124,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_NONE;"
    },
    {
        "line": 183,
        "fullcodeline": "p->key_frame = 1;"
    },
    {
        "line": 184,
        "fullcodeline": "p->pict_type = AV_PICTURE_TYPE_I;"
    },
    {
        "line": 211,
        "fullcodeline": "*got_frame       = 1;"
    },
    {
        "line": 14,
        "fullcodeline": "if (buf_size < XWD_HEADER_SIZE)"
    },
    {
        "line": 21,
        "fullcodeline": "if (version != XWD_VERSION) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (buf_size < header_size || header_size < XWD_HEADER_SIZE) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (pixformat > XWD_Z_PIXMAP) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (pixdepth == 0 || pixdepth > 32) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (be > 1) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (bitorder > 1) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (bunit != 8 && bunit != 16 && bunit != 32) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (bpad != 8 && bpad != 16 && bpad != 32) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (bpp == 0 || bpp > 32) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (ncolors > 256) {"
    },
    {
        "line": 105,
        "fullcodeline": "if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0)"
    },
    {
        "line": 109,
        "fullcodeline": "if (lsize < rsize) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (pixformat != XWD_Z_PIXMAP) {"
    },
    {
        "line": 173,
        "fullcodeline": "if (avctx->pix_fmt == AV_PIX_FMT_NONE) {"
    },
    {
        "line": 180,
        "fullcodeline": "if ((ret = ff_get_buffer(avctx, p, 0)) < 0)"
    },
    {
        "line": 186,
        "fullcodeline": "if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {"
    },
    {
        "line": 205,
        "fullcodeline": "for (i = 0; i < avctx->height; i++) {"
    },
    {
        "line": 22,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"unsupported version\\n\");"
    },
    {
        "line": 27,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid header size\\n\");"
    },
    {
        "line": 61,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid pixmap format\\n\");"
    },
    {
        "line": 66,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid pixmap depth\\n\");"
    },
    {
        "line": 76,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid byte order\\n\");"
    },
    {
        "line": 81,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid bitmap bit order\\n\");"
    },
    {
        "line": 86,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid bitmap unit\\n\");"
    },
    {
        "line": 91,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid bitmap scan-line pad\\n\");"
    },
    {
        "line": 96,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid bits per pixel\\n\");"
    },
    {
        "line": 101,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid number of entries in colormap\\n\");"
    },
    {
        "line": 110,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid bytes per scan-line\\n\");"
    },
    {
        "line": 115,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"input buffer too small\\n\");"
    },
    {
        "line": 166,
        "fullcodeline": "bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE);"
    },
    {
        "line": 169,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"invalid visual class\\n\");"
    },
    {
        "line": 206,
        "fullcodeline": "bytestream2_get_bufferu(&gb, ptr, rsize);"
    },
    {
        "line": 207,
        "fullcodeline": "bytestream2_skipu(&gb, lsize - rsize);"
    },
    {
        "line": 208,
        "fullcodeline": "ptr += p->linesize[0];"
    },
    {
        "line": 128,
        "fullcodeline": "if (bpp != 1 && bpp != 8)"
    },
    {
        "line": 130,
        "fullcodeline": "if (bpp == 1 && pixdepth == 1) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (bpp == 8)"
    },
    {
        "line": 143,
        "fullcodeline": "if (bpp != 16 && bpp != 24 && bpp != 32)"
    },
    {
        "line": 145,
        "fullcodeline": "if (bpp == 16 && pixdepth == 15) {"
    },
    {
        "line": 190,
        "fullcodeline": "for (i = 0; i < ncolors; i++) {"
    },
    {
        "line": 131,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;"
    },
    {
        "line": 139,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_PAL8;"
    },
    {
        "line": 192,
        "fullcodeline": "bytestream2_skipu(&gb, 4); // skip colormap entry number"
    },
    {
        "line": 193,
        "fullcodeline": "red    = bytestream2_get_byteu(&gb);"
    },
    {
        "line": 194,
        "fullcodeline": "bytestream2_skipu(&gb, 1);"
    },
    {
        "line": 195,
        "fullcodeline": "green  = bytestream2_get_byteu(&gb);"
    },
    {
        "line": 196,
        "fullcodeline": "bytestream2_skipu(&gb, 1);"
    },
    {
        "line": 197,
        "fullcodeline": "blue   = bytestream2_get_byteu(&gb);"
    },
    {
        "line": 198,
        "fullcodeline": "bytestream2_skipu(&gb, 3); // skip bitmask flag and padding"
    },
    {
        "line": 200,
        "fullcodeline": "dst[i] = red << 16 | green << 8 | blue;"
    },
    {
        "line": 146,
        "fullcodeline": "if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F)"
    },
    {
        "line": 132,
        "fullcodeline": "} else if (bpp == 8 && pixdepth == 8) {"
    },
    {
        "line": 147,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE;"
    },
    {
        "line": 150,
        "fullcodeline": "} else if (bpp == 16 && pixdepth == 16) {"
    },
    {
        "line": 133,
        "fullcodeline": "avctx->pix_fmt = AV_PIX_FMT_GRAY8;"
    },
    {
        "line": 148,
        "fullcodeline": "else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00)"
    },
    {
        "line": 151,
        "fullcodeline": "if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F)"
    },
    {
        "line": 149,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE;"
    },
    {
        "line": 152,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE;"
    },
    {
        "line": 155,
        "fullcodeline": "} else if (bpp == 24) {"
    },
    {
        "line": 153,
        "fullcodeline": "else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800)"
    },
    {
        "line": 156,
        "fullcodeline": "if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)"
    },
    {
        "line": 154,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE;"
    },
    {
        "line": 157,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24;"
    },
    {
        "line": 160,
        "fullcodeline": "} else if (bpp == 32) {"
    },
    {
        "line": 158,
        "fullcodeline": "else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)"
    },
    {
        "line": 161,
        "fullcodeline": "if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)"
    },
    {
        "line": 159,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24;"
    },
    {
        "line": 162,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA;"
    },
    {
        "line": 163,
        "fullcodeline": "else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)"
    },
    {
        "line": 164,
        "fullcodeline": "avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA;"
    }
]