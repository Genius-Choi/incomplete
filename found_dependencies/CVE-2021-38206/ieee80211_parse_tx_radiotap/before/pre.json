[
    {
        "line": 4,
        "fullcodeline": "struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);"
    },
    {
        "line": 6,
        "fullcodeline": "struct ieee80211_radiotap_header *rthdr ="
    },
    {
        "line": 8,
        "fullcodeline": "struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);"
    },
    {
        "line": 9,
        "fullcodeline": "struct ieee80211_supported_band *sband ="
    },
    {
        "line": 11,
        "fullcodeline": "int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,"
    },
    {
        "line": 14,
        "fullcodeline": "u16 rate = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "bool rate_found = false;"
    },
    {
        "line": 16,
        "fullcodeline": "u8 rate_retries = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "u16 rate_flags = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "u8 vht_mcs = 0, vht_nss = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |"
    },
    {
        "line": 7,
        "fullcodeline": "(struct ieee80211_radiotap_header *) skb->data;"
    },
    {
        "line": 24,
        "fullcodeline": "if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))"
    },
    {
        "line": 44,
        "fullcodeline": "while (!ret) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))"
    },
    {
        "line": 45,
        "fullcodeline": "ret = ieee80211_radiotap_iterator_next(&iterator);"
    },
    {
        "line": 169,
        "fullcodeline": "if (ret != -ENOENT) /* ie, if we didn't simply run out of fields */"
    },
    {
        "line": 173,
        "fullcodeline": "info->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;"
    },
    {
        "line": 175,
        "fullcodeline": "for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (rate_flags & IEEE80211_TX_RC_MCS) {"
    },
    {
        "line": 200,
        "fullcodeline": "info->control.rates[0].count = min_t(u8, rate_retries + 1,"
    },
    {
        "line": 79,
        "fullcodeline": "txflags = get_unaligned_le16(iterator.this_arg);"
    },
    {
        "line": 90,
        "fullcodeline": "rate = *iterator.this_arg;"
    },
    {
        "line": 91,
        "fullcodeline": "rate_flags = 0;"
    },
    {
        "line": 96,
        "fullcodeline": "rate_retries = *iterator.this_arg;"
    },
    {
        "line": 100,
        "fullcodeline": "mcs_known = iterator.this_arg[0];"
    },
    {
        "line": 101,
        "fullcodeline": "mcs_flags = iterator.this_arg[1];"
    },
    {
        "line": 106,
        "fullcodeline": "rate = iterator.this_arg[2];"
    },
    {
        "line": 107,
        "fullcodeline": "rate_flags = IEEE80211_TX_RC_MCS;"
    },
    {
        "line": 113,
        "fullcodeline": "mcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;"
    },
    {
        "line": 133,
        "fullcodeline": "vht_known = get_unaligned_le16(iterator.this_arg);"
    },
    {
        "line": 136,
        "fullcodeline": "rate_flags = IEEE80211_TX_RC_VHT_MCS;"
    },
    {
        "line": 154,
        "fullcodeline": "vht_mcs = iterator.this_arg[4] >> 4;"
    },
    {
        "line": 155,
        "fullcodeline": "vht_nss = iterator.this_arg[4] & 0xF;"
    },
    {
        "line": 182,
        "fullcodeline": "info->control.rates[0].idx = rate;"
    },
    {
        "line": 59,
        "fullcodeline": "if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)"
    },
    {
        "line": 74,
        "fullcodeline": "if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)"
    },
    {
        "line": 80,
        "fullcodeline": "if (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)"
    },
    {
        "line": 82,
        "fullcodeline": "if (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)"
    },
    {
        "line": 84,
        "fullcodeline": "if (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)"
    },
    {
        "line": 122,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (vht_known &"
    },
    {
        "line": 176,
        "fullcodeline": "info->control.rates[i].idx = -1;"
    },
    {
        "line": 197,
        "fullcodeline": "info->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;"
    },
    {
        "line": 70,
        "fullcodeline": "skb_trim(skb, skb->len - FCS_LEN);"
    },
    {
        "line": 73,
        "fullcodeline": "info->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;"
    },
    {
        "line": 75,
        "fullcodeline": "info->flags &= ~IEEE80211_TX_CTL_DONTFRAG;"
    },
    {
        "line": 81,
        "fullcodeline": "info->flags |= IEEE80211_TX_CTL_NO_ACK;"
    },
    {
        "line": 83,
        "fullcodeline": "info->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;"
    },
    {
        "line": 85,
        "fullcodeline": "info->control.flags |="
    },
    {
        "line": 102,
        "fullcodeline": "if (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))"
    },
    {
        "line": 109,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&"
    },
    {
        "line": 110,
        "fullcodeline": "mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)"
    },
    {
        "line": 111,
        "fullcodeline": "rate_flags |= IEEE80211_TX_RC_SHORT_GI;"
    },
    {
        "line": 114,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&"
    },
    {
        "line": 115,
        "fullcodeline": "mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)"
    },
    {
        "line": 116,
        "fullcodeline": "rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;"
    },
    {
        "line": 118,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&"
    },
    {
        "line": 119,
        "fullcodeline": "mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)"
    },
    {
        "line": 120,
        "fullcodeline": "info->flags |= IEEE80211_TX_CTL_LDPC;"
    },
    {
        "line": 123,
        "fullcodeline": "u8 stbc = u8_get_bits(mcs_flags,"
    },
    {
        "line": 126,
        "fullcodeline": "info->flags |="
    },
    {
        "line": 137,
        "fullcodeline": "if ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&"
    },
    {
        "line": 138,
        "fullcodeline": "(iterator.this_arg[2] &"
    },
    {
        "line": 140,
        "fullcodeline": "rate_flags |= IEEE80211_TX_RC_SHORT_GI;"
    },
    {
        "line": 183,
        "fullcodeline": "} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (skb->len < (iterator._max_length + FCS_LEN))"
    },
    {
        "line": 127,
        "fullcodeline": "u32_encode_bits(stbc,"
    },
    {
        "line": 143,
        "fullcodeline": "if (iterator.this_arg[3] == 1)"
    },
    {
        "line": 144,
        "fullcodeline": "rate_flags |="
    },
    {
        "line": 187,
        "fullcodeline": "for (i = 0; i < sband->n_bitrates; i++) {"
    },
    {
        "line": 146,
        "fullcodeline": "else if (iterator.this_arg[3] == 4)"
    },
    {
        "line": 191,
        "fullcodeline": "info->control.rates[0].idx = i;"
    },
    {
        "line": 147,
        "fullcodeline": "rate_flags |="
    },
    {
        "line": 188,
        "fullcodeline": "if (rate * 5 != sband->bitrates[i].bitrate)"
    },
    {
        "line": 149,
        "fullcodeline": "else if (iterator.this_arg[3] == 11)"
    },
    {
        "line": 150,
        "fullcodeline": "rate_flags |="
    }
]