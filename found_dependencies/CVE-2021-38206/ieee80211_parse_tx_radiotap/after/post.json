[
    {
        "line": 4,
        "fullcodeline": "struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);"
    },
    {
        "line": 6,
        "fullcodeline": "struct ieee80211_radiotap_header *rthdr ="
    },
    {
        "line": 8,
        "fullcodeline": "struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);"
    },
    {
        "line": 9,
        "fullcodeline": "int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,"
    },
    {
        "line": 12,
        "fullcodeline": "u16 rate = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "bool rate_found = false;"
    },
    {
        "line": 14,
        "fullcodeline": "u8 rate_retries = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "u16 rate_flags = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "u8 vht_mcs = 0, vht_nss = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |"
    },
    {
        "line": 7,
        "fullcodeline": "(struct ieee80211_radiotap_header *) skb->data;"
    },
    {
        "line": 21,
        "fullcodeline": "if (!ieee80211_validate_radiotap_len(skb))"
    },
    {
        "line": 33,
        "fullcodeline": "while (!ret) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (ret != -ENOENT) /* ie, if we didn't simply run out of fields */"
    },
    {
        "line": 34,
        "fullcodeline": "ret = ieee80211_radiotap_iterator_next(&iterator);"
    },
    {
        "line": 165,
        "fullcodeline": "info->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;"
    },
    {
        "line": 191,
        "fullcodeline": "info->control.rates[0].flags = rate_flags;"
    },
    {
        "line": 192,
        "fullcodeline": "info->control.rates[0].count = min_t(u8, rate_retries + 1,"
    },
    {
        "line": 167,
        "fullcodeline": "for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {"
    },
    {
        "line": 173,
        "fullcodeline": "if (rate_flags & IEEE80211_TX_RC_MCS) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (info->control.rates[0].idx < 0)"
    },
    {
        "line": 68,
        "fullcodeline": "txflags = get_unaligned_le16(iterator.this_arg);"
    },
    {
        "line": 79,
        "fullcodeline": "rate = *iterator.this_arg;"
    },
    {
        "line": 80,
        "fullcodeline": "rate_flags = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "rate_found = true;"
    },
    {
        "line": 85,
        "fullcodeline": "rate_retries = *iterator.this_arg;"
    },
    {
        "line": 89,
        "fullcodeline": "mcs_known = iterator.this_arg[0];"
    },
    {
        "line": 94,
        "fullcodeline": "rate_found = true;"
    },
    {
        "line": 95,
        "fullcodeline": "rate = iterator.this_arg[2];"
    },
    {
        "line": 96,
        "fullcodeline": "rate_flags = IEEE80211_TX_RC_MCS;"
    },
    {
        "line": 102,
        "fullcodeline": "mcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;"
    },
    {
        "line": 122,
        "fullcodeline": "vht_known = get_unaligned_le16(iterator.this_arg);"
    },
    {
        "line": 123,
        "fullcodeline": "rate_found = true;"
    },
    {
        "line": 125,
        "fullcodeline": "rate_flags = IEEE80211_TX_RC_VHT_MCS;"
    },
    {
        "line": 143,
        "fullcodeline": "vht_mcs = iterator.this_arg[4] >> 4;"
    },
    {
        "line": 144,
        "fullcodeline": "vht_nss = iterator.this_arg[4] & 0xF;"
    },
    {
        "line": 168,
        "fullcodeline": "info->control.rates[i].idx = -1;"
    },
    {
        "line": 169,
        "fullcodeline": "info->control.rates[i].flags = 0;"
    },
    {
        "line": 170,
        "fullcodeline": "info->control.rates[i].count = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "info->control.rates[0].idx = rate;"
    },
    {
        "line": 189,
        "fullcodeline": "info->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;"
    },
    {
        "line": 48,
        "fullcodeline": "if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)"
    },
    {
        "line": 63,
        "fullcodeline": "if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)"
    },
    {
        "line": 69,
        "fullcodeline": "if (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)"
    },
    {
        "line": 71,
        "fullcodeline": "if (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)"
    },
    {
        "line": 73,
        "fullcodeline": "if (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)"
    },
    {
        "line": 91,
        "fullcodeline": "if (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))"
    },
    {
        "line": 98,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&"
    },
    {
        "line": 103,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&"
    },
    {
        "line": 107,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&"
    },
    {
        "line": 111,
        "fullcodeline": "if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {"
    },
    {
        "line": 126,
        "fullcodeline": "if ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&"
    },
    {
        "line": 130,
        "fullcodeline": "if (vht_known &"
    },
    {
        "line": 59,
        "fullcodeline": "skb_trim(skb, skb->len - FCS_LEN);"
    },
    {
        "line": 62,
        "fullcodeline": "info->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;"
    },
    {
        "line": 64,
        "fullcodeline": "info->flags &= ~IEEE80211_TX_CTL_DONTFRAG;"
    },
    {
        "line": 70,
        "fullcodeline": "info->flags |= IEEE80211_TX_CTL_NO_ACK;"
    },
    {
        "line": 72,
        "fullcodeline": "info->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;"
    },
    {
        "line": 74,
        "fullcodeline": "info->control.flags |="
    },
    {
        "line": 99,
        "fullcodeline": "mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)"
    },
    {
        "line": 100,
        "fullcodeline": "rate_flags |= IEEE80211_TX_RC_SHORT_GI;"
    },
    {
        "line": 104,
        "fullcodeline": "mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)"
    },
    {
        "line": 105,
        "fullcodeline": "rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;"
    },
    {
        "line": 108,
        "fullcodeline": "mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)"
    },
    {
        "line": 109,
        "fullcodeline": "info->flags |= IEEE80211_TX_CTL_LDPC;"
    },
    {
        "line": 112,
        "fullcodeline": "u8 stbc = u8_get_bits(mcs_flags,"
    },
    {
        "line": 115,
        "fullcodeline": "info->flags |="
    },
    {
        "line": 127,
        "fullcodeline": "(iterator.this_arg[2] &"
    },
    {
        "line": 129,
        "fullcodeline": "rate_flags |= IEEE80211_TX_RC_SHORT_GI;"
    },
    {
        "line": 175,
        "fullcodeline": "} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (skb->len < (iterator._max_length + FCS_LEN))"
    },
    {
        "line": 116,
        "fullcodeline": "u32_encode_bits(stbc,"
    },
    {
        "line": 132,
        "fullcodeline": "if (iterator.this_arg[3] == 1)"
    },
    {
        "line": 176,
        "fullcodeline": "ieee80211_rate_set_vht(info->control.rates, vht_mcs,"
    },
    {
        "line": 133,
        "fullcodeline": "rate_flags |="
    },
    {
        "line": 135,
        "fullcodeline": "else if (iterator.this_arg[3] == 4)"
    },
    {
        "line": 136,
        "fullcodeline": "rate_flags |="
    },
    {
        "line": 179,
        "fullcodeline": "for (i = 0; i < sband->n_bitrates; i++) {"
    },
    {
        "line": 183,
        "fullcodeline": "info->control.rates[0].idx = i;"
    },
    {
        "line": 138,
        "fullcodeline": "else if (iterator.this_arg[3] == 11)"
    },
    {
        "line": 180,
        "fullcodeline": "if (rate * 5 != sband->bitrates[i].bitrate)"
    },
    {
        "line": 139,
        "fullcodeline": "rate_flags |="
    }
]