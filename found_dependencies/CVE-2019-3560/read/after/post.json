[
    {
        "line": 4,
        "fullcodeline": "folly::io::Cursor cursor(buf.front());"
    },
    {
        "line": 11,
        "fullcodeline": "msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());"
    },
    {
        "line": 41,
        "fullcodeline": "receivedRecordVersion_ ="
    },
    {
        "line": 44,
        "fullcodeline": "auto length = cursor.readBE<uint16_t>();"
    },
    {
        "line": 55,
        "fullcodeline": "cursor.clone(msg.fragment, length);"
    },
    {
        "line": 57,
        "fullcodeline": "buf.trimStart(cursor - buf.front());"
    },
    {
        "line": 6,
        "fullcodeline": "if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {"
    },
    {
        "line": 42,
        "fullcodeline": "static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());"
    },
    {
        "line": 45,
        "fullcodeline": "if (length > kMaxPlaintextRecordSize) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (length == 0) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (buf.chainLength() < (cursor - buf.front()) + length) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (msg.type == ContentType::change_cipher_spec) {"
    },
    {
        "line": 69,
        "fullcodeline": "return std::move(msg);"
    },
    {
        "line": 60,
        "fullcodeline": "msg.fragment->coalesce();"
    },
    {
        "line": 14,
        "fullcodeline": "if (msg.type == ContentType::application_data) {"
    },
    {
        "line": 34,
        "fullcodeline": "throw std::runtime_error(folly::to<std::string>("
    },
    {
        "line": 46,
        "fullcodeline": "throw std::runtime_error(\"received too long plaintext record\");"
    },
    {
        "line": 49,
        "fullcodeline": "throw std::runtime_error(\"received empty plaintext record\");"
    },
    {
        "line": 61,
        "fullcodeline": "if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {"
    },
    {
        "line": 15,
        "fullcodeline": "cursor.skip(sizeof(ProtocolVersion));"
    },
    {
        "line": 16,
        "fullcodeline": "auto length = cursor.readBE<uint16_t>();"
    },
    {
        "line": 20,
        "fullcodeline": "buf.trimStart(static_cast<size_t>(kPlaintextHeaderSize) + length);"
    },
    {
        "line": 17,
        "fullcodeline": "if (buf.chainLength() < (cursor - buf.front()) + length) {"
    },
    {
        "line": 22,
        "fullcodeline": "} else if (msg.type != ContentType::change_cipher_spec) {"
    },
    {
        "line": 35,
        "fullcodeline": "\"received plaintext content type \","
    },
    {
        "line": 64,
        "fullcodeline": "throw FizzException("
    },
    {
        "line": 23,
        "fullcodeline": "skipEncryptedRecords_ = false;"
    },
    {
        "line": 36,
        "fullcodeline": "static_cast<ContentTypeType>(msg.type),"
    },
    {
        "line": 38,
        "fullcodeline": "folly::hexlify(buf.splitAtMost(10)->coalesce())));"
    }
]