[
    {
        "line": 5,
        "fullcodeline": "int   ret = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "byte* msg = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "byte salt[WC_MAX_DIGEST_SIZE];"
    },
    {
        "line": 26,
        "fullcodeline": "hLen = wc_HashGetDigestSize(hType);"
    },
    {
        "line": 33,
        "fullcodeline": "hiBits = (bits - 1) & 0x7;"
    },
    {
        "line": 74,
        "fullcodeline": "maskLen = pkcsBlockLen - 1 - hLen;"
    },
    {
        "line": 110,
        "fullcodeline": "s = m;"
    },
    {
        "line": 111,
        "fullcodeline": "XMEMSET(m, 0, RSA_PSS_PAD_SZ);"
    },
    {
        "line": 112,
        "fullcodeline": "m += RSA_PSS_PAD_SZ;"
    },
    {
        "line": 113,
        "fullcodeline": "XMEMCPY(m, input, inputLen);"
    },
    {
        "line": 114,
        "fullcodeline": "m += inputLen;"
    },
    {
        "line": 115,
        "fullcodeline": "o = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "if (hLen < 0)"
    },
    {
        "line": 29,
        "fullcodeline": "if ((int)inputLen != hLen) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (hiBits == 0) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {"
    },
    {
        "line": 71,
        "fullcodeline": "if ((int)pkcsBlockLen - hLen < saltLen + 2) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (pkcsBlockLen < RSA_PSS_PAD_SZ + inputLen + saltLen) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (saltLen > 0) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (ret == 0) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (ret == 0) {"
    },
    {
        "line": 134,
        "fullcodeline": "if (ret == 0) {"
    },
    {
        "line": 148,
        "fullcodeline": "if (msg != NULL) {"
    },
    {
        "line": 38,
        "fullcodeline": "*(pkcsBlock++) = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "pkcsBlockLen--;"
    },
    {
        "line": 43,
        "fullcodeline": "saltLen = hLen;"
    },
    {
        "line": 99,
        "fullcodeline": "msg = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,"
    },
    {
        "line": 105,
        "fullcodeline": "m = msg;"
    },
    {
        "line": 117,
        "fullcodeline": "ret = wc_RNG_GenerateBlock(rng, salt, saltLen);"
    },
    {
        "line": 126,
        "fullcodeline": "ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);"
    },
    {
        "line": 130,
        "fullcodeline": "pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;"
    },
    {
        "line": 132,
        "fullcodeline": "ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);"
    },
    {
        "line": 140,
        "fullcodeline": "m = pkcsBlock + maskLen - saltLen - 1;"
    },
    {
        "line": 141,
        "fullcodeline": "*(m++) ^= 0x01;"
    },
    {
        "line": 149,
        "fullcodeline": "XFREE(msg, heap, DYNAMIC_TYPE_RSA_BUFFER);"
    },
    {
        "line": 101,
        "fullcodeline": "if (msg == NULL) {"
    },
    {
        "line": 108,
        "fullcodeline": "m = pkcsBlock;"
    },
    {
        "line": 118,
        "fullcodeline": "if (ret == 0) {"
    },
    {
        "line": 142,
        "fullcodeline": "for (i = 0; i < saltLen; i++) {"
    },
    {
        "line": 52,
        "fullcodeline": "else if (saltLen > hLen) {"
    },
    {
        "line": 119,
        "fullcodeline": "XMEMCPY(m, salt, saltLen);"
    },
    {
        "line": 120,
        "fullcodeline": "m += saltLen;"
    },
    {
        "line": 138,
        "fullcodeline": "pkcsBlock[0] &= (1 << hiBits) - 1;"
    },
    {
        "line": 143,
        "fullcodeline": "m[i] ^= salt[o + i];"
    },
    {
        "line": 57,
        "fullcodeline": "else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {"
    }
]