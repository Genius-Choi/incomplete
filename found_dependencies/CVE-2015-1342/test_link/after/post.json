[
    {
        "line": 3,
        "fullcodeline": "char *d = strdupa(path), *tmpname;"
    },
    {
        "line": 4,
        "fullcodeline": "d = dirname(d);"
    },
    {
        "line": 5,
        "fullcodeline": "size_t len = strlen(path) + 30;"
    },
    {
        "line": 6,
        "fullcodeline": "tmpname = alloca(len);"
    },
    {
        "line": 7,
        "fullcodeline": "snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());"
    },
    {
        "line": 9,
        "fullcodeline": "if (link(path, tmpname) == 0) {"
    },
    {
        "line": 13,
        "fullcodeline": "if (errno != ENOENT && errno != ENOSYS) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (link(tmpname, path) == 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (errno != ENOENT && errno != ENOSYS) {"
    },
    {
        "line": 10,
        "fullcodeline": "fprintf(stderr, \"leak at link of %s\\n\", path);"
    },
    {
        "line": 11,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 14,
        "fullcodeline": "fprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));"
    },
    {
        "line": 15,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 19,
        "fullcodeline": "fprintf(stderr, \"leak at link (2) of %s\\n\", path);"
    },
    {
        "line": 20,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 23,
        "fullcodeline": "fprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));"
    },
    {
        "line": 24,
        "fullcodeline": "exit(1);"
    }
]