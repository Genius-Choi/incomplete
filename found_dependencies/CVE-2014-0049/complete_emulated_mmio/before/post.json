[
    {
        "line": 3,
        "fullcodeline": "struct kvm_run *run = vcpu->run;"
    },
    {
        "line": 7,
        "fullcodeline": "BUG_ON(!vcpu->mmio_needed);"
    },
    {
        "line": 11,
        "fullcodeline": "len = min(8u, frag->len);"
    },
    {
        "line": 36,
        "fullcodeline": "run->exit_reason = KVM_EXIT_MMIO;"
    },
    {
        "line": 37,
        "fullcodeline": "run->mmio.phys_addr = frag->gpa;"
    },
    {
        "line": 40,
        "fullcodeline": "run->mmio.len = min(8u, frag->len);"
    },
    {
        "line": 41,
        "fullcodeline": "run->mmio.is_write = vcpu->mmio_is_write;"
    },
    {
        "line": 42,
        "fullcodeline": "vcpu->arch.complete_userspace_io = complete_emulated_mmio;"
    },
    {
        "line": 12,
        "fullcodeline": "if (!vcpu->mmio_is_write)"
    },
    {
        "line": 15,
        "fullcodeline": "if (frag->len <= 8) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {"
    },
    {
        "line": 13,
        "fullcodeline": "memcpy(frag->data, run->mmio.data, len);"
    },
    {
        "line": 17,
        "fullcodeline": "frag++;"
    },
    {
        "line": 18,
        "fullcodeline": "vcpu->mmio_cur_fragment++;"
    },
    {
        "line": 27,
        "fullcodeline": "vcpu->mmio_needed = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "vcpu->mmio_read_completed = 1;"
    },
    {
        "line": 39,
        "fullcodeline": "memcpy(run->mmio.data, frag->data, min(8u, frag->len));"
    },
    {
        "line": 21,
        "fullcodeline": "frag->data += len;"
    },
    {
        "line": 22,
        "fullcodeline": "frag->gpa += len;"
    },
    {
        "line": 23,
        "fullcodeline": "frag->len -= len;"
    },
    {
        "line": 33,
        "fullcodeline": "return complete_emulated_io(vcpu);"
    }
]