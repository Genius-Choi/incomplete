[
    {
        "line": 2,
        "fullcodeline": "module = AnsibleModule("
    },
    {
        "line": 57,
        "fullcodeline": "base_dir = os.path.dirname(module.params['path']) or '.'"
    },
    {
        "line": 52,
        "fullcodeline": "if module.params['version'] != 1:"
    },
    {
        "line": 58,
        "fullcodeline": "if not os.path.isdir(base_dir):"
    },
    {
        "line": 62,
        "fullcodeline": "if backend == 'auto':"
    },
    {
        "line": 3,
        "fullcodeline": "argument_spec=dict("
    },
    {
        "line": 43,
        "fullcodeline": "required_together=[('authority_cert_issuer', 'authority_cert_serial_number')],"
    },
    {
        "line": 44,
        "fullcodeline": "required_if=[('state', 'present', ['privatekey_path', 'privatekey_content'], True)],"
    },
    {
        "line": 45,
        "fullcodeline": "mutually_exclusive=("
    },
    {
        "line": 53,
        "fullcodeline": "module.deprecate('The version option will only support allowed values from community.crypto 2.0.0 on. '"
    },
    {
        "line": 59,
        "fullcodeline": "module.fail_json(name=base_dir, msg='The directory %s does not exist or the file is not a directory' % base_dir)"
    },
    {
        "line": 64,
        "fullcodeline": "can_use_cryptography = CRYPTOGRAPHY_FOUND and CRYPTOGRAPHY_VERSION >= LooseVersion(MINIMAL_CRYPTOGRAPHY_VERSION)"
    },
    {
        "line": 65,
        "fullcodeline": "can_use_pyopenssl = PYOPENSSL_FOUND and PYOPENSSL_VERSION >= LooseVersion(MINIMAL_PYOPENSSL_VERSION)"
    },
    {
        "line": 114,
        "fullcodeline": "result = csr.dump()"
    },
    {
        "line": 115,
        "fullcodeline": "module.exit_json(**result)"
    },
    {
        "line": 4,
        "fullcodeline": "state=dict(type='str', default='present', choices=['absent', 'present']),"
    },
    {
        "line": 5,
        "fullcodeline": "digest=dict(type='str', default='sha256'),"
    },
    {
        "line": 6,
        "fullcodeline": "privatekey_path=dict(type='path'),"
    },
    {
        "line": 7,
        "fullcodeline": "privatekey_content=dict(type='str'),"
    },
    {
        "line": 8,
        "fullcodeline": "privatekey_passphrase=dict(type='str', no_log=True),"
    },
    {
        "line": 9,
        "fullcodeline": "version=dict(type='int', default=1),"
    },
    {
        "line": 10,
        "fullcodeline": "force=dict(type='bool', default=False),"
    },
    {
        "line": 11,
        "fullcodeline": "path=dict(type='path', required=True),"
    },
    {
        "line": 12,
        "fullcodeline": "subject=dict(type='dict'),"
    },
    {
        "line": 13,
        "fullcodeline": "country_name=dict(type='str', aliases=['C', 'countryName']),"
    },
    {
        "line": 14,
        "fullcodeline": "state_or_province_name=dict(type='str', aliases=['ST', 'stateOrProvinceName']),"
    },
    {
        "line": 15,
        "fullcodeline": "locality_name=dict(type='str', aliases=['L', 'localityName']),"
    },
    {
        "line": 16,
        "fullcodeline": "organization_name=dict(type='str', aliases=['O', 'organizationName']),"
    },
    {
        "line": 17,
        "fullcodeline": "organizational_unit_name=dict(type='str', aliases=['OU', 'organizationalUnitName']),"
    },
    {
        "line": 18,
        "fullcodeline": "common_name=dict(type='str', aliases=['CN', 'commonName']),"
    },
    {
        "line": 19,
        "fullcodeline": "email_address=dict(type='str', aliases=['E', 'emailAddress']),"
    },
    {
        "line": 20,
        "fullcodeline": "subject_alt_name=dict(type='list', elements='str', aliases=['subjectAltName']),"
    },
    {
        "line": 21,
        "fullcodeline": "subject_alt_name_critical=dict(type='bool', default=False, aliases=['subjectAltName_critical']),"
    },
    {
        "line": 22,
        "fullcodeline": "use_common_name_for_san=dict(type='bool', default=True, aliases=['useCommonNameForSAN']),"
    },
    {
        "line": 23,
        "fullcodeline": "key_usage=dict(type='list', elements='str', aliases=['keyUsage']),"
    },
    {
        "line": 24,
        "fullcodeline": "key_usage_critical=dict(type='bool', default=False, aliases=['keyUsage_critical']),"
    },
    {
        "line": 25,
        "fullcodeline": "extended_key_usage=dict(type='list', elements='str', aliases=['extKeyUsage', 'extendedKeyUsage']),"
    },
    {
        "line": 26,
        "fullcodeline": "extended_key_usage_critical=dict(type='bool', default=False, aliases=['extKeyUsage_critical', 'extendedKeyUsage_critical']),"
    },
    {
        "line": 27,
        "fullcodeline": "basic_constraints=dict(type='list', elements='str', aliases=['basicConstraints']),"
    },
    {
        "line": 28,
        "fullcodeline": "basic_constraints_critical=dict(type='bool', default=False, aliases=['basicConstraints_critical']),"
    },
    {
        "line": 29,
        "fullcodeline": "ocsp_must_staple=dict(type='bool', default=False, aliases=['ocspMustStaple']),"
    },
    {
        "line": 30,
        "fullcodeline": "ocsp_must_staple_critical=dict(type='bool', default=False, aliases=['ocspMustStaple_critical']),"
    },
    {
        "line": 31,
        "fullcodeline": "name_constraints_permitted=dict(type='list', elements='str'),"
    },
    {
        "line": 32,
        "fullcodeline": "name_constraints_excluded=dict(type='list', elements='str'),"
    },
    {
        "line": 33,
        "fullcodeline": "name_constraints_critical=dict(type='bool', default=False),"
    },
    {
        "line": 34,
        "fullcodeline": "backup=dict(type='bool', default=False),"
    },
    {
        "line": 35,
        "fullcodeline": "create_subject_key_identifier=dict(type='bool', default=False),"
    },
    {
        "line": 36,
        "fullcodeline": "subject_key_identifier=dict(type='str'),"
    },
    {
        "line": 37,
        "fullcodeline": "authority_key_identifier=dict(type='str'),"
    },
    {
        "line": 38,
        "fullcodeline": "authority_cert_issuer=dict(type='list', elements='str'),"
    },
    {
        "line": 39,
        "fullcodeline": "authority_cert_serial_number=dict(type='int'),"
    },
    {
        "line": 40,
        "fullcodeline": "select_crypto_backend=dict(type='str', default='auto', choices=['auto', 'cryptography', 'pyopenssl']),"
    },
    {
        "line": 41,
        "fullcodeline": "return_content=dict(type='bool', default=False),"
    },
    {
        "line": 46,
        "fullcodeline": "['privatekey_path', 'privatekey_content'],"
    },
    {
        "line": 74,
        "fullcodeline": "if backend == 'auto':"
    },
    {
        "line": 80,
        "fullcodeline": "if backend == 'pyopenssl':"
    },
    {
        "line": 98,
        "fullcodeline": "if module.params['state'] == 'present':"
    },
    {
        "line": 69,
        "fullcodeline": "backend = 'cryptography'"
    },
    {
        "line": 75,
        "fullcodeline": "module.fail_json(msg=(\"Can't detect any of the required Python libraries \""
    },
    {
        "line": 89,
        "fullcodeline": "module.deprecate('The module is using the PyOpenSSL backend. This backend has been deprecated',"
    },
    {
        "line": 91,
        "fullcodeline": "csr = CertificateSigningRequestPyOpenSSL(module)"
    },
    {
        "line": 104,
        "fullcodeline": "csr.generate(module)"
    },
    {
        "line": 112,
        "fullcodeline": "csr.remove(module)"
    },
    {
        "line": 117,
        "fullcodeline": "module.fail_json(msg=to_native(exc))"
    },
    {
        "line": 81,
        "fullcodeline": "if not PYOPENSSL_FOUND:"
    },
    {
        "line": 92,
        "fullcodeline": "elif backend == 'cryptography':"
    },
    {
        "line": 71,
        "fullcodeline": "backend = 'pyopenssl'"
    },
    {
        "line": 82,
        "fullcodeline": "module.fail_json(msg=missing_required_lib('pyOpenSSL >= {0}'.format(MINIMAL_PYOPENSSL_VERSION)),"
    },
    {
        "line": 85,
        "fullcodeline": "getattr(crypto.X509Req, 'get_extensions')"
    },
    {
        "line": 96,
        "fullcodeline": "csr = CertificateSigningRequestCryptography(module)"
    },
    {
        "line": 100,
        "fullcodeline": "result = csr.dump()"
    },
    {
        "line": 101,
        "fullcodeline": "result['changed'] = module.params['force'] or not csr.check(module)"
    },
    {
        "line": 102,
        "fullcodeline": "module.exit_json(**result)"
    },
    {
        "line": 108,
        "fullcodeline": "result = csr.dump()"
    },
    {
        "line": 109,
        "fullcodeline": "result['changed'] = os.path.exists(module.params['path'])"
    },
    {
        "line": 110,
        "fullcodeline": "module.exit_json(**result)"
    },
    {
        "line": 93,
        "fullcodeline": "if not CRYPTOGRAPHY_FOUND:"
    },
    {
        "line": 87,
        "fullcodeline": "module.fail_json(msg='You need to have PyOpenSSL>=0.15 to generate CSRs')"
    },
    {
        "line": 94,
        "fullcodeline": "module.fail_json(msg=missing_required_lib('cryptography >= {0}'.format(MINIMAL_CRYPTOGRAPHY_VERSION)),"
    }
]