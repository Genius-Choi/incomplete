[
    {
        "line": 4,
        "fullcodeline": "RAnalOp aop = {0};"
    },
    {
        "line": 5,
        "fullcodeline": "bool resolved = false;"
    },
    {
        "line": 7,
        "fullcodeline": "r_return_if_fail (core && core->anal && fcn);"
    },
    {
        "line": 14,
        "fullcodeline": "RAnal *anal = core->anal;"
    },
    {
        "line": 15,
        "fullcodeline": "Sdb *TDB = anal->sdb_types;"
    },
    {
        "line": 16,
        "fullcodeline": "bool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");"
    },
    {
        "line": 17,
        "fullcodeline": "int ret, bsize = R_MAX (64, core->blocksize);"
    },
    {
        "line": 18,
        "fullcodeline": "const int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);"
    },
    {
        "line": 19,
        "fullcodeline": "const int minopcode = R_MAX (1, mininstrsz);"
    },
    {
        "line": 20,
        "fullcodeline": "int cur_idx , prev_idx = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "RConfigHold *hc = r_config_hold_new (core->config);"
    },
    {
        "line": 25,
        "fullcodeline": "RDebugTrace *dt = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "RAnalEsilTrace *et = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "ut8 *buf = malloc (bsize);"
    },
    {
        "line": 40,
        "fullcodeline": "ht_pp_free (etracedb->ht);"
    },
    {
        "line": 41,
        "fullcodeline": "etracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);"
    },
    {
        "line": 42,
        "fullcodeline": "etracedb->ht->opt = opt;"
    },
    {
        "line": 45,
        "fullcodeline": "ht_pp_free (dtrace->ht);"
    },
    {
        "line": 46,
        "fullcodeline": "dtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);"
    },
    {
        "line": 47,
        "fullcodeline": "dtrace->ht->opt = opt;"
    },
    {
        "line": 49,
        "fullcodeline": "char *fcn_name = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "char *ret_type = NULL;"
    },
    {
        "line": 51,
        "fullcodeline": "bool str_flag = false;"
    },
    {
        "line": 52,
        "fullcodeline": "bool prop = false;"
    },
    {
        "line": 53,
        "fullcodeline": "bool prev_var = false;"
    },
    {
        "line": 54,
        "fullcodeline": "char prev_type[256] = {0};"
    },
    {
        "line": 55,
        "fullcodeline": "const char *prev_dest = NULL;"
    },
    {
        "line": 56,
        "fullcodeline": "char *ret_reg = NULL;"
    },
    {
        "line": 57,
        "fullcodeline": "const char *pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);"
    },
    {
        "line": 62,
        "fullcodeline": "RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);"
    },
    {
        "line": 67,
        "fullcodeline": "r_cons_break_push (NULL, NULL);"
    },
    {
        "line": 68,
        "fullcodeline": "r_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address"
    },
    {
        "line": 69,
        "fullcodeline": "r_list_foreach (fcn->bbs, it, bb) {"
    },
    {
        "line": 308,
        "fullcodeline": "RList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);"
    },
    {
        "line": 311,
        "fullcodeline": "r_list_foreach (list, iter, rvar) {"
    },
    {
        "line": 324,
        "fullcodeline": "r_list_free (list);"
    },
    {
        "line": 326,
        "fullcodeline": "R_FREE (ret_reg);"
    },
    {
        "line": 327,
        "fullcodeline": "R_FREE (ret_type);"
    },
    {
        "line": 328,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 329,
        "fullcodeline": "r_cons_break_pop();"
    },
    {
        "line": 330,
        "fullcodeline": "anal_emul_restore (core, hc, dt, et);"
    },
    {
        "line": 22,
        "fullcodeline": "if (!hc) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (!anal_emul_init (core, hc, &dt, &et) || !fcn) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (!pc) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (!r) {"
    },
    {
        "line": 70,
        "fullcodeline": "ut64 addr = bb->addr;"
    },
    {
        "line": 71,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "r_reg_set_value (core->dbg->reg, r, addr);"
    },
    {
        "line": 312,
        "fullcodeline": "RAnalVar *lvar = r_anal_var_get_dst_var (rvar);"
    },
    {
        "line": 313,
        "fullcodeline": "RRegItem *i = r_reg_index_get (anal->reg, rvar->delta);"
    },
    {
        "line": 10,
        "fullcodeline": "eprintf (\"Please run aeim\\n\");"
    },
    {
        "line": 28,
        "fullcodeline": "anal_emul_restore (core, hc, dt, et);"
    },
    {
        "line": 33,
        "fullcodeline": "anal_emul_restore (core, hc, dt, et);"
    },
    {
        "line": 59,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 64,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 314,
        "fullcodeline": "if (!i) {"
    },
    {
        "line": 80,
        "fullcodeline": "ut64 pcval = r_reg_getv (anal->reg, pc);"
    },
    {
        "line": 87,
        "fullcodeline": "ret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);"
    },
    {
        "line": 105,
        "fullcodeline": "bool userfnc = false;"
    },
    {
        "line": 107,
        "fullcodeline": "cur_idx = sdb_num_get (trace, \"idx\", 0);"
    },
    {
        "line": 108,
        "fullcodeline": "RAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);"
    },
    {
        "line": 109,
        "fullcodeline": "RAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); // | _VAL ?"
    },
    {
        "line": 110,
        "fullcodeline": "ut32 type = aop.type & R_ANAL_OP_TYPE_MASK;"
    },
    {
        "line": 266,
        "fullcodeline": "prev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);"
    },
    {
        "line": 267,
        "fullcodeline": "str_flag = false;"
    },
    {
        "line": 268,
        "fullcodeline": "prop = false;"
    },
    {
        "line": 269,
        "fullcodeline": "prev_dest = NULL;"
    },
    {
        "line": 300,
        "fullcodeline": "i += ret;"
    },
    {
        "line": 301,
        "fullcodeline": "addr += ret;"
    },
    {
        "line": 302,
        "fullcodeline": "r_anal_op_free (next_op);"
    },
    {
        "line": 303,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 319,
        "fullcodeline": "__var_retype (anal, rvar, NULL, lvar->type, false, false);"
    },
    {
        "line": 321,
        "fullcodeline": "__var_retype (anal, lvar, NULL, rvar->type, false, false);"
    },
    {
        "line": 74,
        "fullcodeline": "if (r_cons_is_breaked ()) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (i >= (bsize - 32)) {"
    },
    {
        "line": 81,
        "fullcodeline": "if ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (!i) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (r_anal_op_nonlinear (aop.type)) {   // skip the instr"
    },
    {
        "line": 111,
        "fullcodeline": "if (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {"
    },
    {
        "line": 78,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "r_io_read_at (core->io, addr, buf, bsize);"
    },
    {
        "line": 89,
        "fullcodeline": "i += minopcode;"
    },
    {
        "line": 90,
        "fullcodeline": "addr += minopcode;"
    },
    {
        "line": 91,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 96,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 101,
        "fullcodeline": "r_reg_set_value (core->dbg->reg, r, addr + ret);"
    },
    {
        "line": 112,
        "fullcodeline": "char *full_name = NULL;"
    },
    {
        "line": 211,
        "fullcodeline": "bool sign = false;"
    },
    {
        "line": 293,
        "fullcodeline": "const char *query = sdb_fmt (\"%d.reg.write\", cur_idx);"
    },
    {
        "line": 294,
        "fullcodeline": "prev_dest = sdb_const_get (trace, query, 0);"
    },
    {
        "line": 103,
        "fullcodeline": "r_core_esil_step (core, UT64_MAX, NULL, NULL, false);"
    },
    {
        "line": 114,
        "fullcodeline": "if (aop.type == R_ANAL_OP_TYPE_CALL) {"
    },
    {
        "line": 212,
        "fullcodeline": "if ((type == R_ANAL_OP_TYPE_CMP) && next_op) {"
    },
    {
        "line": 221,
        "fullcodeline": "if (sign || aop.sign) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {"
    },
    {
        "line": 237,
        "fullcodeline": "if (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)"
    },
    {
        "line": 274,
        "fullcodeline": "if (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {"
    },
    {
        "line": 290,
        "fullcodeline": "if (var && str_flag) {"
    },
    {
        "line": 115,
        "fullcodeline": "RAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);"
    },
    {
        "line": 137,
        "fullcodeline": "const char* Cc = r_anal_cc_func (anal, fcn_name);"
    },
    {
        "line": 168,
        "fullcodeline": "free (fcn_name);"
    },
    {
        "line": 170,
        "fullcodeline": "} else if (!resolved && ret_type && ret_reg) {"
    },
    {
        "line": 222,
        "fullcodeline": "__var_retype (anal, var, NULL, \"signed\", false, true);"
    },
    {
        "line": 227,
        "fullcodeline": "char reg[REGNAME_SIZE] = {0};"
    },
    {
        "line": 228,
        "fullcodeline": "get_src_regname (core, addr, reg, sizeof (reg));"
    },
    {
        "line": 229,
        "fullcodeline": "bool match = strstr (prev_dest, reg) != NULL;"
    },
    {
        "line": 238,
        "fullcodeline": "&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {"
    },
    {
        "line": 239,
        "fullcodeline": "bool jmp = false;"
    },
    {
        "line": 240,
        "fullcodeline": "RAnalOp *jmp_op = {0};"
    },
    {
        "line": 241,
        "fullcodeline": "ut64 jmp_addr = next_op->jump;"
    },
    {
        "line": 242,
        "fullcodeline": "RAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);"
    },
    {
        "line": 259,
        "fullcodeline": "RAnalVarConstraint constr = {"
    },
    {
        "line": 263,
        "fullcodeline": "r_anal_var_add_constraint (var, &constr);"
    },
    {
        "line": 291,
        "fullcodeline": "__var_retype (anal, var, NULL, \"const char *\", false, false);"
    },
    {
        "line": 296,
        "fullcodeline": "strncpy (prev_type, var->type, sizeof (prev_type) - 1);"
    },
    {
        "line": 297,
        "fullcodeline": "prop = true;"
    },
    {
        "line": 128,
        "fullcodeline": "if (r_type_func_exist (TDB, full_name)) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (!fcn_name) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (Cc && r_anal_cc_exist (anal, Cc)) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (!strcmp (fcn_name, \"__stack_chk_fail\")) {"
    },
    {
        "line": 172,
        "fullcodeline": "char src[REGNAME_SIZE] = {0};"
    },
    {
        "line": 173,
        "fullcodeline": "const char *query = sdb_fmt (\"%d.reg.write\", cur_idx);"
    },
    {
        "line": 174,
        "fullcodeline": "const char *cur_dest = sdb_const_get (trace, query, 0);"
    },
    {
        "line": 175,
        "fullcodeline": "get_src_regname (core, aop.addr, src, sizeof (src));"
    },
    {
        "line": 230,
        "fullcodeline": "if (str_flag && match) {"
    },
    {
        "line": 233,
        "fullcodeline": "if (prop && match && prev_var) {"
    },
    {
        "line": 245,
        "fullcodeline": "for (i = 0; i < MAX_INSTR ; i++) {"
    },
    {
        "line": 275,
        "fullcodeline": "if (type == R_ANAL_OP_TYPE_LOAD) {"
    },
    {
        "line": 117,
        "fullcodeline": "full_name = fcn_call->name;"
    },
    {
        "line": 118,
        "fullcodeline": "callee_addr = fcn_call->addr;"
    },
    {
        "line": 120,
        "fullcodeline": "} else if (aop.ptr != UT64_MAX) {"
    },
    {
        "line": 129,
        "fullcodeline": "fcn_name = strdup (full_name);"
    },
    {
        "line": 134,
        "fullcodeline": "fcn_name = strdup (full_name);"
    },
    {
        "line": 135,
        "fullcodeline": "userfnc = true;"
    },
    {
        "line": 139,
        "fullcodeline": "char *cc = strdup (Cc);"
    },
    {
        "line": 140,
        "fullcodeline": "type_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);"
    },
    {
        "line": 141,
        "fullcodeline": "prev_idx = cur_idx;"
    },
    {
        "line": 142,
        "fullcodeline": "R_FREE (ret_type);"
    },
    {
        "line": 143,
        "fullcodeline": "const char *rt = r_type_func_ret (TDB, fcn_name);"
    },
    {
        "line": 147,
        "fullcodeline": "R_FREE (ret_reg);"
    },
    {
        "line": 148,
        "fullcodeline": "const char *rr = r_anal_cc_ret (anal, cc);"
    },
    {
        "line": 152,
        "fullcodeline": "resolved = false;"
    },
    {
        "line": 153,
        "fullcodeline": "free (cc);"
    },
    {
        "line": 156,
        "fullcodeline": "const char *query = sdb_fmt (\"%d.addr\", cur_idx - 1);"
    },
    {
        "line": 157,
        "fullcodeline": "ut64 mov_addr = sdb_num_get (trace, query, 0);"
    },
    {
        "line": 158,
        "fullcodeline": "RAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);"
    },
    {
        "line": 166,
        "fullcodeline": "r_anal_op_free (mop);"
    },
    {
        "line": 176,
        "fullcodeline": "if (ret_reg && *src && strstr (ret_reg, src)) {"
    },
    {
        "line": 214,
        "fullcodeline": "sign = true;"
    },
    {
        "line": 231,
        "fullcodeline": "__var_retype (anal, var, NULL, \"const char *\", false, false);"
    },
    {
        "line": 234,
        "fullcodeline": "__var_retype (anal, var, NULL, prev_type, false, false);"
    },
    {
        "line": 246,
        "fullcodeline": "jmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);"
    },
    {
        "line": 256,
        "fullcodeline": "jmp_addr += jmp_op->size;"
    },
    {
        "line": 257,
        "fullcodeline": "r_anal_op_free (jmp_op);"
    },
    {
        "line": 276,
        "fullcodeline": "ut8 buf[256] = {0};"
    },
    {
        "line": 277,
        "fullcodeline": "r_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);"
    },
    {
        "line": 278,
        "fullcodeline": "ut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);"
    },
    {
        "line": 121,
        "fullcodeline": "RFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);"
    },
    {
        "line": 131,
        "fullcodeline": "fcn_name = r_type_func_guess (TDB, full_name);"
    },
    {
        "line": 217,
        "fullcodeline": "__var_retype (anal, var, NULL, \"unsigned\", false, true);"
    },
    {
        "line": 247,
        "fullcodeline": "if (!jmp_op) {"
    },
    {
        "line": 250,
        "fullcodeline": "if ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))"
    },
    {
        "line": 260,
        "fullcodeline": ".cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,"
    },
    {
        "line": 261,
        "fullcodeline": ".val = aop.val"
    },
    {
        "line": 279,
        "fullcodeline": "if (ptr && ptr != UT64_MAX) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (flag && flag->realname) {"
    },
    {
        "line": 145,
        "fullcodeline": "ret_type = strdup (rt);"
    },
    {
        "line": 150,
        "fullcodeline": "ret_reg = strdup (rr);"
    },
    {
        "line": 160,
        "fullcodeline": "RAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);"
    },
    {
        "line": 161,
        "fullcodeline": "ut32 type = mop->type & R_ANAL_OP_TYPE_MASK;"
    },
    {
        "line": 177,
        "fullcodeline": "if (var && aop.direction == R_ANAL_OP_DIR_WRITE) {"
    },
    {
        "line": 251,
        "fullcodeline": "|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {"
    },
    {
        "line": 252,
        "fullcodeline": "jmp = true;"
    },
    {
        "line": 253,
        "fullcodeline": "r_anal_op_free (jmp_op);"
    },
    {
        "line": 280,
        "fullcodeline": "RFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);"
    },
    {
        "line": 285,
        "fullcodeline": "} else if (r_flag_exist_at (core->flags, \"str\", 3, aop.ptr)) {"
    },
    {
        "line": 123,
        "fullcodeline": "full_name = flag->realname;"
    },
    {
        "line": 124,
        "fullcodeline": "callee_addr = aop.ptr;"
    },
    {
        "line": 162,
        "fullcodeline": "if (type == R_ANAL_OP_TYPE_MOV) {"
    },
    {
        "line": 178,
        "fullcodeline": "__var_retype (anal, var, NULL, ret_type, false, false);"
    },
    {
        "line": 179,
        "fullcodeline": "resolved = true;"
    },
    {
        "line": 286,
        "fullcodeline": "str_flag = true;"
    },
    {
        "line": 163,
        "fullcodeline": "__var_rename (anal, mopvar, \"canary\", addr);"
    },
    {
        "line": 187,
        "fullcodeline": "char *foo = strdup (cur_dest);"
    },
    {
        "line": 188,
        "fullcodeline": "char *tmp = strchr (foo, ',');"
    },
    {
        "line": 206,
        "fullcodeline": "free (foo);"
    },
    {
        "line": 282,
        "fullcodeline": "str_flag = true;"
    },
    {
        "line": 180,
        "fullcodeline": "} else if (type == R_ANAL_OP_TYPE_MOV) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {"
    },
    {
        "line": 181,
        "fullcodeline": "R_FREE (ret_reg);"
    },
    {
        "line": 190,
        "fullcodeline": "*tmp++ = '\\0';"
    },
    {
        "line": 193,
        "fullcodeline": "resolved = true;"
    },
    {
        "line": 183,
        "fullcodeline": "ret_reg = strdup (cur_dest);"
    },
    {
        "line": 194,
        "fullcodeline": "} else if (type == R_ANAL_OP_TYPE_MOV &&"
    },
    {
        "line": 195,
        "fullcodeline": "(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){"
    },
    {
        "line": 199,
        "fullcodeline": "char nsrc[REGNAME_SIZE] = {0};"
    },
    {
        "line": 200,
        "fullcodeline": "get_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));"
    },
    {
        "line": 201,
        "fullcodeline": "if (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&"
    },
    {
        "line": 202,
        "fullcodeline": "aop.direction == R_ANAL_OP_DIR_READ) {"
    },
    {
        "line": 203,
        "fullcodeline": "__var_retype (anal, var, NULL, ret_type, true, false);"
    }
]