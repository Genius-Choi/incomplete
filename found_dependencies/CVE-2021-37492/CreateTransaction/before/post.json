[
    {
        "line": 4,
        "fullcodeline": "CAmount nValue = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "int nChangePosRequest = nChangePosInOut;"
    },
    {
        "line": 6,
        "fullcodeline": "unsigned int nSubtractFeeFromAmount = 0;"
    },
    {
        "line": 47,
        "fullcodeline": "txNew.nLockTime = chainActive.Height();"
    },
    {
        "line": 56,
        "fullcodeline": "assert(txNew.nLockTime <= (unsigned int)chainActive.Height());"
    },
    {
        "line": 57,
        "fullcodeline": "assert(txNew.nLockTime < LOCKTIME_THRESHOLD);"
    },
    {
        "line": 369,
        "fullcodeline": "LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Needed:%d Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\","
    },
    {
        "line": 19,
        "fullcodeline": "if (vecSend.empty())"
    },
    {
        "line": 53,
        "fullcodeline": "if (GetRandInt(10) == 0)"
    },
    {
        "line": 62,
        "fullcodeline": "std::set<CInputCoin> setCoins;"
    },
    {
        "line": 63,
        "fullcodeline": "LOCK2(cs_main, cs_wallet);"
    },
    {
        "line": 343,
        "fullcodeline": "tx = MakeTransactionRef(std::move(txNew));"
    },
    {
        "line": 353,
        "fullcodeline": "if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {"
    },
    {
        "line": 370,
        "fullcodeline": "nFeeRet, nBytes, nFeeNeeded, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,"
    },
    {
        "line": 372,
        "fullcodeline": "100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),"
    },
    {
        "line": 375,
        "fullcodeline": "100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool),"
    },
    {
        "line": 14,
        "fullcodeline": "nValue += recipient.nAmount;"
    },
    {
        "line": 21,
        "fullcodeline": "strFailReason = _(\"Transaction must have at least one recipient\");"
    },
    {
        "line": 54,
        "fullcodeline": "txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));"
    },
    {
        "line": 65,
        "fullcodeline": "std::vector<COutput> vAvailableCoins;"
    },
    {
        "line": 66,
        "fullcodeline": "AvailableCoins(vAvailableCoins, true, &coin_control);"
    },
    {
        "line": 100,
        "fullcodeline": "CTxOut change_prototype_txout(0, scriptChange);"
    },
    {
        "line": 101,
        "fullcodeline": "coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);"
    },
    {
        "line": 103,
        "fullcodeline": "CFeeRate discard_rate = GetDiscardRate(::feeEstimator);"
    },
    {
        "line": 106,
        "fullcodeline": "CFeeRate nFeeRateNeeded = GetMinimumFeeRate(coin_control, ::mempool, ::feeEstimator, &feeCalc);"
    },
    {
        "line": 108,
        "fullcodeline": "nFeeRet = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "bool pick_new_inputs = true;"
    },
    {
        "line": 110,
        "fullcodeline": "CAmount nValueIn = 0;"
    },
    {
        "line": 114,
        "fullcodeline": "coin_selection_params.use_bnb = nSubtractFeeFromAmount == 0; // If we are doing subtract fee from recipient, then don't use BnB"
    },
    {
        "line": 319,
        "fullcodeline": "if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change"
    },
    {
        "line": 346,
        "fullcodeline": "if (GetTransactionWeight(*tx) >= MAX_STANDARD_TX_WEIGHT)"
    },
    {
        "line": 356,
        "fullcodeline": "CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);"
    },
    {
        "line": 358,
        "fullcodeline": "size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);"
    },
    {
        "line": 359,
        "fullcodeline": "size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;"
    },
    {
        "line": 360,
        "fullcodeline": "size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);"
    },
    {
        "line": 361,
        "fullcodeline": "size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;"
    },
    {
        "line": 9,
        "fullcodeline": "if (nValue < 0 || recipient.nAmount < 0)"
    },
    {
        "line": 75,
        "fullcodeline": "if (!boost::get<CNoDestination>(&coin_control.destChange)) {"
    },
    {
        "line": 323,
        "fullcodeline": "CTransaction txNewConst(txNew);"
    },
    {
        "line": 324,
        "fullcodeline": "int nIn = 0;"
    },
    {
        "line": 348,
        "fullcodeline": "strFailReason = _(\"Transaction too large\");"
    },
    {
        "line": 363,
        "fullcodeline": "if (!mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {"
    },
    {
        "line": 11,
        "fullcodeline": "strFailReason = _(\"Transaction amounts must not be negative\");"
    },
    {
        "line": 17,
        "fullcodeline": "nSubtractFeeFromAmount++;"
    },
    {
        "line": 76,
        "fullcodeline": "scriptChange = GetScriptForDestination(coin_control.destChange);"
    },
    {
        "line": 118,
        "fullcodeline": "nChangePosInOut = nChangePosRequest;"
    },
    {
        "line": 119,
        "fullcodeline": "txNew.vin.clear();"
    },
    {
        "line": 120,
        "fullcodeline": "txNew.vout.clear();"
    },
    {
        "line": 121,
        "fullcodeline": "bool fFirst = true;"
    },
    {
        "line": 123,
        "fullcodeline": "CAmount nValueToSelect = nValue;"
    },
    {
        "line": 128,
        "fullcodeline": "coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)"
    },
    {
        "line": 184,
        "fullcodeline": "const CAmount nChange = nValueIn - nValueToSelect;"
    },
    {
        "line": 228,
        "fullcodeline": "const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);"
    },
    {
        "line": 233,
        "fullcodeline": "nBytes = CalculateMaximumSignedTxSize(txNew, this);"
    },
    {
        "line": 239,
        "fullcodeline": "nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);"
    },
    {
        "line": 313,
        "fullcodeline": "nFeeRet = nFeeNeeded;"
    },
    {
        "line": 314,
        "fullcodeline": "coin_selection_params.use_bnb = false;"
    },
    {
        "line": 364,
        "fullcodeline": "strFailReason = _(\"Transaction has too long of a mempool chain\");"
    },
    {
        "line": 88,
        "fullcodeline": "ret = reservekey.GetReservedKey(vchPubKey, true);"
    },
    {
        "line": 95,
        "fullcodeline": "const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);"
    },
    {
        "line": 97,
        "fullcodeline": "LearnRelatedScripts(vchPubKey, change_type);"
    },
    {
        "line": 98,
        "fullcodeline": "scriptChange = GetScriptForDestination(GetDestinationForKey(vchPubKey, change_type));"
    },
    {
        "line": 124,
        "fullcodeline": "if (nSubtractFeeFromAmount == 0)"
    },
    {
        "line": 185,
        "fullcodeline": "if (nChange > 0)"
    },
    {
        "line": 230,
        "fullcodeline": "txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),"
    },
    {
        "line": 234,
        "fullcodeline": "if (nBytes < 0) {"
    },
    {
        "line": 240,
        "fullcodeline": "if (feeCalc.reason == FeeReason::FALLBACK && !g_wallet_allow_fallback_fee) {"
    },
    {
        "line": 248,
        "fullcodeline": "if (nFeeNeeded < ::minRelayTxFee.GetFee(nBytes))"
    },
    {
        "line": 254,
        "fullcodeline": "if (nFeeRet >= nFeeNeeded) {"
    },
    {
        "line": 295,
        "fullcodeline": "if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {"
    },
    {
        "line": 308,
        "fullcodeline": "if (nSubtractFeeFromAmount > 0) {"
    },
    {
        "line": 338,
        "fullcodeline": "nIn++;"
    },
    {
        "line": 89,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 125,
        "fullcodeline": "nValueToSelect += nFeeRet;"
    },
    {
        "line": 131,
        "fullcodeline": "CTxOut txout(recipient.nAmount, recipient.scriptPubKey);"
    },
    {
        "line": 145,
        "fullcodeline": "coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);"
    },
    {
        "line": 160,
        "fullcodeline": "txNew.vout.push_back(txout);"
    },
    {
        "line": 166,
        "fullcodeline": "nValueIn = 0;"
    },
    {
        "line": 167,
        "fullcodeline": "setCoins.clear();"
    },
    {
        "line": 168,
        "fullcodeline": "coin_selection_params.change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);"
    },
    {
        "line": 169,
        "fullcodeline": "coin_selection_params.effective_fee = nFeeRateNeeded;"
    },
    {
        "line": 188,
        "fullcodeline": "CTxOut newTxOut(nChange, scriptChange);"
    },
    {
        "line": 235,
        "fullcodeline": "strFailReason = _(\"Signing transaction failed\");"
    },
    {
        "line": 242,
        "fullcodeline": "strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");"
    },
    {
        "line": 250,
        "fullcodeline": "strFailReason = _(\"Transaction too large for fee policy\");"
    },
    {
        "line": 296,
        "fullcodeline": "CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;"
    },
    {
        "line": 297,
        "fullcodeline": "std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;"
    },
    {
        "line": 309,
        "fullcodeline": "pick_new_inputs = false;"
    },
    {
        "line": 330,
        "fullcodeline": "if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.txout.nValue, SIGHASH_ALL), scriptPubKey, sigdata))"
    },
    {
        "line": 91,
        "fullcodeline": "strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");"
    },
    {
        "line": 147,
        "fullcodeline": "if (IsDust(txout, ::dustRelayFee))"
    },
    {
        "line": 170,
        "fullcodeline": "if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coin_control, coin_selection_params, bnb_used))"
    },
    {
        "line": 193,
        "fullcodeline": "if (IsDust(newTxOut, discard_rate) || bnb_used)"
    },
    {
        "line": 215,
        "fullcodeline": "nChangePosInOut = -1;"
    },
    {
        "line": 265,
        "fullcodeline": "if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {"
    },
    {
        "line": 277,
        "fullcodeline": "if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {"
    },
    {
        "line": 299,
        "fullcodeline": "if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {"
    },
    {
        "line": 332,
        "fullcodeline": "strFailReason = _(\"Signing transaction failed\");"
    },
    {
        "line": 135,
        "fullcodeline": "assert(nSubtractFeeFromAmount != 0);"
    },
    {
        "line": 136,
        "fullcodeline": "txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient"
    },
    {
        "line": 195,
        "fullcodeline": "nChangePosInOut = -1;"
    },
    {
        "line": 196,
        "fullcodeline": "nFeeRet += nChange;"
    },
    {
        "line": 266,
        "fullcodeline": "unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size"
    },
    {
        "line": 267,
        "fullcodeline": "CAmount fee_needed_with_change = GetMinimumFee(tx_size_with_change, coin_control, ::mempool, ::feeEstimator, nullptr);"
    },
    {
        "line": 268,
        "fullcodeline": "CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);"
    },
    {
        "line": 278,
        "fullcodeline": "CAmount extraFeePaid = nFeeRet - nFeeNeeded;"
    },
    {
        "line": 279,
        "fullcodeline": "std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;"
    },
    {
        "line": 280,
        "fullcodeline": "change_position->nValue += extraFeePaid;"
    },
    {
        "line": 281,
        "fullcodeline": "nFeeRet -= extraFeePaid;"
    },
    {
        "line": 285,
        "fullcodeline": "else if (!pick_new_inputs) {"
    },
    {
        "line": 300,
        "fullcodeline": "change_position->nValue -= additionalFeeNeeded;"
    },
    {
        "line": 301,
        "fullcodeline": "nFeeRet += additionalFeeNeeded;"
    },
    {
        "line": 335,
        "fullcodeline": "UpdateTransaction(txNew, nIn, sigdata);"
    },
    {
        "line": 149,
        "fullcodeline": "if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)"
    },
    {
        "line": 211,
        "fullcodeline": "std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;"
    },
    {
        "line": 212,
        "fullcodeline": "txNew.vout.insert(position, newTxOut);"
    },
    {
        "line": 269,
        "fullcodeline": "if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {"
    },
    {
        "line": 290,
        "fullcodeline": "strFailReason = _(\"Transaction fee and change calculation failed\");"
    },
    {
        "line": 140,
        "fullcodeline": "fFirst = false;"
    },
    {
        "line": 141,
        "fullcodeline": "txout.nValue -= nFeeRet % nSubtractFeeFromAmount;"
    },
    {
        "line": 174,
        "fullcodeline": "coin_selection_params.use_bnb = false;"
    },
    {
        "line": 200,
        "fullcodeline": "if (nChangePosInOut == -1)"
    },
    {
        "line": 270,
        "fullcodeline": "pick_new_inputs = false;"
    },
    {
        "line": 271,
        "fullcodeline": "nFeeRet = fee_needed_with_change;"
    },
    {
        "line": 151,
        "fullcodeline": "if (txout.nValue < 0)"
    },
    {
        "line": 157,
        "fullcodeline": "strFailReason = _(\"Transaction amount too small\");"
    },
    {
        "line": 178,
        "fullcodeline": "strFailReason = _(\"Insufficient funds\");"
    },
    {
        "line": 203,
        "fullcodeline": "nChangePosInOut = GetRandInt(txNew.vout.size()+1);"
    },
    {
        "line": 152,
        "fullcodeline": "strFailReason = _(\"The transaction amount is too small to pay the fee\");"
    },
    {
        "line": 154,
        "fullcodeline": "strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");"
    },
    {
        "line": 205,
        "fullcodeline": "else if ((unsigned int)nChangePosInOut > txNew.vout.size())"
    },
    {
        "line": 207,
        "fullcodeline": "strFailReason = _(\"Change index out of range\");"
    }
]