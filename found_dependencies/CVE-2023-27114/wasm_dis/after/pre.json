[
    {
        "line": 2,
        "fullcodeline": "int id = buf[0];"
    },
    {
        "line": 3,
        "fullcodeline": "if (id < 0xc0) {"
    },
    {
        "line": 720,
        "fullcodeline": "if (txt && !op->txt) {"
    },
    {
        "line": 4,
        "fullcodeline": "op->type = WASM_TYPE_OP_CORE;"
    },
    {
        "line": 5,
        "fullcodeline": "op->op.core = id;"
    },
    {
        "line": 6,
        "fullcodeline": "op->len = 1;"
    },
    {
        "line": 7,
        "fullcodeline": "WasmOpDef *opdef = &opcodes[id];"
    },
    {
        "line": 721,
        "fullcodeline": "op->txt = strdup (\"incorrect\");"
    },
    {
        "line": 728,
        "fullcodeline": "op->txt = strdup (\"invalid\");"
    },
    {
        "line": 389,
        "fullcodeline": "} else if (id == 0xfe) {"
    },
    {
        "line": 139,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 147,
        "fullcodeline": "st32 val = 0;"
    },
    {
        "line": 148,
        "fullcodeline": "size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);"
    },
    {
        "line": 177,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 184,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &op->val);"
    },
    {
        "line": 191,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 196,
        "fullcodeline": "ut32 count = 0, *table = NULL, def = 0;"
    },
    {
        "line": 197,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);"
    },
    {
        "line": 205,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 216,
        "fullcodeline": "n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);"
    },
    {
        "line": 220,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 232,
        "fullcodeline": "free (table);"
    },
    {
        "line": 241,
        "fullcodeline": "ut32 val = 0, reserved = 0;"
    },
    {
        "line": 242,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);"
    },
    {
        "line": 246,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 247,
        "fullcodeline": "n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);"
    },
    {
        "line": 251,
        "fullcodeline": "reserved &= 0x1;"
    },
    {
        "line": 255,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 264,
        "fullcodeline": "ut32 val = 0;"
    },
    {
        "line": 265,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);"
    },
    {
        "line": 272,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 299,
        "fullcodeline": "ut32 flag = 0, offset = 0;"
    },
    {
        "line": 300,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);"
    },
    {
        "line": 304,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 305,
        "fullcodeline": "n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);"
    },
    {
        "line": 312,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 318,
        "fullcodeline": "ut32 reserved = 0;"
    },
    {
        "line": 319,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);"
    },
    {
        "line": 323,
        "fullcodeline": "reserved &= 0x1;"
    },
    {
        "line": 327,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 332,
        "fullcodeline": "st32 val = 0;"
    },
    {
        "line": 333,
        "fullcodeline": "size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);"
    },
    {
        "line": 340,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 345,
        "fullcodeline": "st64 val = 0;"
    },
    {
        "line": 346,
        "fullcodeline": "size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);"
    },
    {
        "line": 353,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 357,
        "fullcodeline": "if (buf_len > 4) {"
    },
    {
        "line": 372,
        "fullcodeline": "if (buf_len > 8) {"
    },
    {
        "line": 390,
        "fullcodeline": "op->type =  WASM_TYPE_OP_ATOMIC;"
    },
    {
        "line": 392,
        "fullcodeline": "op->len = 2;"
    },
    {
        "line": 393,
        "fullcodeline": "id = buf[1]; // skip 0xfe"
    },
    {
        "line": 394,
        "fullcodeline": "op->op.atomic = id;"
    },
    {
        "line": 395,
        "fullcodeline": "WasmOpDef *opdef = &opcodes_threads[id];"
    },
    {
        "line": 140,
        "fullcodeline": "op->txt = strdup (opdef->txt);"
    },
    {
        "line": 149,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 185,
        "fullcodeline": "if (n <= 0 || n >= buf_len) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (!(n > 0 && n < buf_len && count < 0xffff)) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (!(table = calloc (count, sizeof (ut32)))) {"
    },
    {
        "line": 206,
        "fullcodeline": "for (i = 0; i < count; i++) {"
    },
    {
        "line": 217,
        "fullcodeline": "if (!(n > 0 && n + op->len < buf_len)) {"
    },
    {
        "line": 221,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 243,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 248,
        "fullcodeline": "if (!(n == 1 && op->len + n <= buf_len)) {"
    },
    {
        "line": 252,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 266,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 269,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 301,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 306,
        "fullcodeline": "if (!(n > 0 && op->len + n <= buf_len)) {"
    },
    {
        "line": 309,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 320,
        "fullcodeline": "if (!(n == 1 && n < buf_len)) {"
    },
    {
        "line": 324,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 334,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 337,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 347,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 350,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 362,
        "fullcodeline": "u.v = r_read_at_le32 (buf, 1);"
    },
    {
        "line": 366,
        "fullcodeline": "op->len += 4;"
    },
    {
        "line": 377,
        "fullcodeline": "u.v = r_read_at_le64 (buf, 1);"
    },
    {
        "line": 381,
        "fullcodeline": "op->len += 8;"
    },
    {
        "line": 391,
        "fullcodeline": "if (buf_len < 2) goto err;"
    },
    {
        "line": 189,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d\", opdef->txt, op->val);"
    },
    {
        "line": 207,
        "fullcodeline": "n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);"
    },
    {
        "line": 214,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 222,
        "fullcodeline": "RStrBuf *sb = r_strbuf_new (\"\");"
    },
    {
        "line": 253,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d %d\", opdef->txt, val, reserved);"
    },
    {
        "line": 270,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d\", opdef->txt, val);"
    },
    {
        "line": 310,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d %d\", opdef->txt, flag, offset);"
    },
    {
        "line": 325,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d\", opdef->txt, reserved);"
    },
    {
        "line": 363,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 378,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 473,
        "fullcodeline": "} else if (id == 0xfd) {"
    },
    {
        "line": 208,
        "fullcodeline": "if (!(op->len + n <= buf_len)) {"
    },
    {
        "line": 211,
        "fullcodeline": "if (n < 1) {"
    },
    {
        "line": 364,
        "fullcodeline": "op->txt = r_str_newf (\"%s %f\", opdef->txt, u.f);"
    },
    {
        "line": 379,
        "fullcodeline": "op->txt = r_str_newf (\"%s %f\", opdef->txt, u.f);"
    },
    {
        "line": 454,
        "fullcodeline": "ut32 flag = 0, offset = 0;"
    },
    {
        "line": 455,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 2, buf + buf_len, &flag);"
    },
    {
        "line": 459,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 460,
        "fullcodeline": "n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);"
    },
    {
        "line": 467,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 478,
        "fullcodeline": "op->type = WASM_TYPE_OP_SIMD;"
    },
    {
        "line": 479,
        "fullcodeline": "size_t simdop_size = read_u32_leb128 (buf + 1, buf + buf_len, &simdop);"
    },
    {
        "line": 483,
        "fullcodeline": "op->len = 1 + simdop_size;"
    },
    {
        "line": 484,
        "fullcodeline": "op->op.simd = simdop;"
    },
    {
        "line": 485,
        "fullcodeline": "id = simdop; // this isn't great because we're losing the sign"
    },
    {
        "line": 487,
        "fullcodeline": "WasmOpDef *opdef = &opcodes_simd[id];"
    },
    {
        "line": 155,
        "fullcodeline": "op->txt = strdup (opdef->txt);"
    },
    {
        "line": 158,
        "fullcodeline": "op->txt = r_str_newf (\"%s (result i32)\", opdef->txt);"
    },
    {
        "line": 161,
        "fullcodeline": "op->txt = r_str_newf (\"%s (result i64)\", opdef->txt);"
    },
    {
        "line": 164,
        "fullcodeline": "op->txt = r_str_newf (\"%s (result f32)\", opdef->txt);"
    },
    {
        "line": 167,
        "fullcodeline": "op->txt = r_str_newf (\"%s (result f64)\", opdef->txt);"
    },
    {
        "line": 170,
        "fullcodeline": "op->txt = r_str_newf (\"%s (result v128)\", opdef->txt);"
    },
    {
        "line": 173,
        "fullcodeline": "op->txt = r_str_newf (\"%s (result ?)\", opdef->txt);"
    },
    {
        "line": 224,
        "fullcodeline": "r_strbuf_setf (sb, \"%s %d \", opdef->txt, count);"
    },
    {
        "line": 228,
        "fullcodeline": "r_strbuf_appendf (sb, \"%d\", def);"
    },
    {
        "line": 229,
        "fullcodeline": "op->txt = r_strbuf_drain (sb);"
    },
    {
        "line": 456,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 461,
        "fullcodeline": "if (!(n > 0 && op->len + n <= buf_len)) {"
    },
    {
        "line": 464,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 474,
        "fullcodeline": "if (buf_len < 2) {"
    },
    {
        "line": 480,
        "fullcodeline": "if (simdop_size > buf_len) {"
    },
    {
        "line": 225,
        "fullcodeline": "for (i = 0; i < count; i++) {"
    },
    {
        "line": 465,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d %d\", opdef->txt, flag, offset);"
    },
    {
        "line": 226,
        "fullcodeline": "r_strbuf_appendf (sb, \"%d \", table[i]);"
    },
    {
        "line": 636,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 653,
        "fullcodeline": "ut32 offset = 0, align = 0;"
    },
    {
        "line": 654,
        "fullcodeline": "size_t n = read_u32_leb128 (buf + 1 + simdop_size, buf + buf_len, &offset);"
    },
    {
        "line": 655,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 659,
        "fullcodeline": "n = read_u32_leb128 (buf + 1 + simdop_size + n, buf + buf_len, &align);"
    },
    {
        "line": 660,
        "fullcodeline": "op->len += n;"
    },
    {
        "line": 675,
        "fullcodeline": "op->len += 16;"
    },
    {
        "line": 676,
        "fullcodeline": "ut8 bytes[16] = {0};"
    },
    {
        "line": 709,
        "fullcodeline": "unsigned char lane = buf[1 + simdop_size];"
    },
    {
        "line": 710,
        "fullcodeline": "++op->len;"
    },
    {
        "line": 637,
        "fullcodeline": "op->txt = strdup (opdef->txt);"
    },
    {
        "line": 661,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 664,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 672,
        "fullcodeline": "if (buf_len < 18) {"
    },
    {
        "line": 678,
        "fullcodeline": "for (i = 0; i < 16; i++) {"
    },
    {
        "line": 706,
        "fullcodeline": "if (buf_len < 3) {"
    },
    {
        "line": 711,
        "fullcodeline": "if (txt && opdef->txt) {"
    },
    {
        "line": 656,
        "fullcodeline": "if (!(n > 0 && n < buf_len)) {"
    },
    {
        "line": 665,
        "fullcodeline": "op->txt = r_str_newf (\"%s o:%d a:2^%d\", opdef->txt, offset, align);"
    },
    {
        "line": 679,
        "fullcodeline": "bytes[i] = buf[i + 1 + simdop_size];"
    },
    {
        "line": 682,
        "fullcodeline": "op->txt = r_str_newf (\"%s %02x %02x %02x %02x %02x %02x %02x \" \\"
    },
    {
        "line": 712,
        "fullcodeline": "op->txt = r_str_newf (\"%s %d\", opdef->txt, lane);"
    },
    {
        "line": 684,
        "fullcodeline": "r_str_get (opdef->txt), bytes[0], bytes[1], bytes[2], bytes[3],"
    }
]