[
    {
        "line": 11,
        "fullcodeline": "int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", std::numeric_limits<int64_t>::max());"
    },
    {
        "line": 12,
        "fullcodeline": "bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);"
    },
    {
        "line": 15,
        "fullcodeline": "unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());"
    },
    {
        "line": 18,
        "fullcodeline": "int64 nFees = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "int nSigOps = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "BOOST_FOREACH(CTransaction& tx, vtx)"
    },
    {
        "line": 77,
        "fullcodeline": "SyncWithWallets(tx, this, true);"
    },
    {
        "line": 4,
        "fullcodeline": "if (!CheckBlock())"
    },
    {
        "line": 17,
        "fullcodeline": "map<uint256, CTxIndex> mapQueuedChanges;"
    },
    {
        "line": 22,
        "fullcodeline": "nSigOps += tx.GetLegacySigOpCount();"
    },
    {
        "line": 26,
        "fullcodeline": "CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);"
    },
    {
        "line": 52,
        "fullcodeline": "mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());"
    },
    {
        "line": 56,
        "fullcodeline": "for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)"
    },
    {
        "line": 76,
        "fullcodeline": "BOOST_FOREACH(CTransaction& tx, vtx)"
    },
    {
        "line": 23,
        "fullcodeline": "if (nSigOps > MAX_BLOCK_SIGOPS)"
    },
    {
        "line": 27,
        "fullcodeline": "nTxPos += ::GetSerializeSize(tx, SER_DISK);"
    },
    {
        "line": 62,
        "fullcodeline": "if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))"
    },
    {
        "line": 69,
        "fullcodeline": "CDiskBlockIndex blockindexPrev(pindex->pprev);"
    },
    {
        "line": 70,
        "fullcodeline": "blockindexPrev.hashNext = pindex->GetBlockHash();"
    },
    {
        "line": 30,
        "fullcodeline": "if (!tx.IsCoinBase())"
    },
    {
        "line": 46,
        "fullcodeline": "nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();"
    },
    {
        "line": 24,
        "fullcodeline": "return DoS(100, error(\"ConnectBlock() : too many sigops\"));"
    },
    {
        "line": 58,
        "fullcodeline": "if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))"
    },
    {
        "line": 71,
        "fullcodeline": "if (!txdb.WriteBlockIndex(blockindexPrev))"
    },
    {
        "line": 33,
        "fullcodeline": "if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))"
    },
    {
        "line": 41,
        "fullcodeline": "nSigOps += tx.GetP2SHSigOpCount(mapInputs);"
    },
    {
        "line": 48,
        "fullcodeline": "if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))"
    },
    {
        "line": 59,
        "fullcodeline": "return error(\"ConnectBlock() : UpdateTxIndex failed\");"
    },
    {
        "line": 72,
        "fullcodeline": "return error(\"ConnectBlock() : WriteBlockIndex failed\");"
    },
    {
        "line": 43,
        "fullcodeline": "return DoS(100, error(\"ConnectBlock() : too many sigops\"));"
    }
]