[
    {
        "line": 18,
        "fullcodeline": "BOOST_FOREACH(CTransaction& tx, vtx)"
    },
    {
        "line": 31,
        "fullcodeline": "int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", std::numeric_limits<int64_t>::max());"
    },
    {
        "line": 32,
        "fullcodeline": "bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);"
    },
    {
        "line": 35,
        "fullcodeline": "unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());"
    },
    {
        "line": 37,
        "fullcodeline": "map<uint256, CTxIndex> mapQueuedChanges;"
    },
    {
        "line": 38,
        "fullcodeline": "int64 nFees = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "int nSigOps = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "BOOST_FOREACH(CTransaction& tx, vtx)"
    },
    {
        "line": 96,
        "fullcodeline": "BOOST_FOREACH(CTransaction& tx, vtx)"
    },
    {
        "line": 97,
        "fullcodeline": "SyncWithWallets(tx, this, true);"
    },
    {
        "line": 4,
        "fullcodeline": "if (!CheckBlock())"
    },
    {
        "line": 22,
        "fullcodeline": "BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)"
    },
    {
        "line": 42,
        "fullcodeline": "nSigOps += tx.GetLegacySigOpCount();"
    },
    {
        "line": 46,
        "fullcodeline": "CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);"
    },
    {
        "line": 47,
        "fullcodeline": "nTxPos += ::GetSerializeSize(tx, SER_DISK);"
    },
    {
        "line": 72,
        "fullcodeline": "mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());"
    },
    {
        "line": 76,
        "fullcodeline": "for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)"
    },
    {
        "line": 82,
        "fullcodeline": "if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))"
    },
    {
        "line": 23,
        "fullcodeline": "if (pos.IsNull())"
    },
    {
        "line": 43,
        "fullcodeline": "if (nSigOps > MAX_BLOCK_SIGOPS)"
    },
    {
        "line": 50,
        "fullcodeline": "if (!tx.IsCoinBase())"
    },
    {
        "line": 89,
        "fullcodeline": "CDiskBlockIndex blockindexPrev(pindex->pprev);"
    },
    {
        "line": 90,
        "fullcodeline": "blockindexPrev.hashNext = pindex->GetBlockHash();"
    },
    {
        "line": 66,
        "fullcodeline": "nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();"
    },
    {
        "line": 78,
        "fullcodeline": "if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))"
    },
    {
        "line": 91,
        "fullcodeline": "if (!txdb.WriteBlockIndex(blockindexPrev))"
    },
    {
        "line": 44,
        "fullcodeline": "return DoS(100, error(\"ConnectBlock() : too many sigops\"));"
    },
    {
        "line": 53,
        "fullcodeline": "if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))"
    },
    {
        "line": 68,
        "fullcodeline": "if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))"
    },
    {
        "line": 61,
        "fullcodeline": "nSigOps += tx.GetP2SHSigOpCount(mapInputs);"
    },
    {
        "line": 79,
        "fullcodeline": "return error(\"ConnectBlock() : UpdateTxIndex failed\");"
    },
    {
        "line": 92,
        "fullcodeline": "return error(\"ConnectBlock() : WriteBlockIndex failed\");"
    },
    {
        "line": 62,
        "fullcodeline": "if (nSigOps > MAX_BLOCK_SIGOPS)"
    },
    {
        "line": 63,
        "fullcodeline": "return DoS(100, error(\"ConnectBlock() : too many sigops\"));"
    }
]