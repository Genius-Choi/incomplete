[
    {
        "line": 8,
        "fullcodeline": "dev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");"
    },
    {
        "line": 10,
        "fullcodeline": "status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);"
    },
    {
        "line": 14,
        "fullcodeline": "status_buf[0] = 0xff;"
    },
    {
        "line": 15,
        "fullcodeline": "status_buf[1] = 0xff;"
    },
    {
        "line": 16,
        "fullcodeline": "rc = usb_control_msg(port->serial->dev,"
    },
    {
        "line": 38,
        "fullcodeline": "kfree(status_buf);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!status_buf)"
    },
    {
        "line": 25,
        "fullcodeline": "if (rc != KLSI_STATUSBUF_LEN) {"
    },
    {
        "line": 17,
        "fullcodeline": "usb_rcvctrlpipe(port->serial->dev, 0),"
    },
    {
        "line": 19,
        "fullcodeline": "USB_TYPE_VENDOR | USB_DIR_IN,"
    },
    {
        "line": 26,
        "fullcodeline": "dev_err(&port->dev, \"reading line status failed: %d\\n\", rc);"
    },
    {
        "line": 12,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 27,
        "fullcodeline": "if (rc >= 0)"
    },
    {
        "line": 30,
        "fullcodeline": "status = get_unaligned_le16(status_buf);"
    },
    {
        "line": 32,
        "fullcodeline": "dev_info(&port->serial->dev->dev, \"read status %x %x\\n\","
    },
    {
        "line": 35,
        "fullcodeline": "*line_state_p = klsi_105_status2linestate(status);"
    },
    {
        "line": 28,
        "fullcodeline": "rc = -EIO;"
    }
]