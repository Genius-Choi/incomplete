[
    {
        "line": 10,
        "fullcodeline": "byte    data   [WEBP_TAG_SIZE*3];"
    },
    {
        "line": 11,
        "fullcodeline": "DataBuf chunkId(WEBP_TAG_SIZE+1);"
    },
    {
        "line": 12,
        "fullcodeline": "chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';"
    },
    {
        "line": 14,
        "fullcodeline": "readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 15,
        "fullcodeline": "uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);"
    },
    {
        "line": 22,
        "fullcodeline": "bool has_size  = false;"
    },
    {
        "line": 23,
        "fullcodeline": "bool has_xmp   = false;"
    },
    {
        "line": 24,
        "fullcodeline": "bool has_exif  = false;"
    },
    {
        "line": 25,
        "fullcodeline": "bool has_vp8x  = false;"
    },
    {
        "line": 26,
        "fullcodeline": "bool has_alpha = false;"
    },
    {
        "line": 27,
        "fullcodeline": "bool has_icc   = iccProfileDefined();"
    },
    {
        "line": 29,
        "fullcodeline": "int width      = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int height     = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "byte       size_buff[WEBP_TAG_SIZE];"
    },
    {
        "line": 47,
        "fullcodeline": "has_xmp = xmpPacket_.size() > 0;"
    },
    {
        "line": 48,
        "fullcodeline": "std::string xmp(xmpPacket_);"
    },
    {
        "line": 189,
        "fullcodeline": "io_->seek(12, BasicIo::beg);"
    },
    {
        "line": 292,
        "fullcodeline": "outIo.seek(0, BasicIo::beg);"
    },
    {
        "line": 293,
        "fullcodeline": "filesize = outIo.size() - 8;"
    },
    {
        "line": 294,
        "fullcodeline": "outIo.seek(4, BasicIo::beg);"
    },
    {
        "line": 295,
        "fullcodeline": "ul2Data(data, (uint32_t) filesize, littleEndian);"
    },
    {
        "line": 3,
        "fullcodeline": "if (!io_->isopen()) throw Error(kerInputDataReadFailed);"
    },
    {
        "line": 4,
        "fullcodeline": "if (!outIo.isopen()) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 18,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)"
    },
    {
        "line": 35,
        "fullcodeline": "if (exifData_.count() > 0) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (xmpData_.count() > 0 && !writeXmpFromPacket()) {"
    },
    {
        "line": 53,
        "fullcodeline": "while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {"
    },
    {
        "line": 184,
        "fullcodeline": "if (!has_vp8x) {"
    },
    {
        "line": 190,
        "fullcodeline": "while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {"
    },
    {
        "line": 296,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 36,
        "fullcodeline": "ExifParser::encode(blob, littleEndian, exifData_);"
    },
    {
        "line": 43,
        "fullcodeline": "XmpParser::encode(xmpPacket_, xmpData_,"
    },
    {
        "line": 54,
        "fullcodeline": "readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 55,
        "fullcodeline": "readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 56,
        "fullcodeline": "const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);"
    },
    {
        "line": 59,
        "fullcodeline": "enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),"
    },
    {
        "line": 61,
        "fullcodeline": "const long size = static_cast<long>(size_u32);"
    },
    {
        "line": 62,
        "fullcodeline": "DataBuf payload(size);"
    },
    {
        "line": 63,
        "fullcodeline": "readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 185,
        "fullcodeline": "inject_VP8X(outIo, has_xmp, has_exif, has_alpha,"
    },
    {
        "line": 191,
        "fullcodeline": "readOrThrow(*io_, chunkId.pData_, 4, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 192,
        "fullcodeline": "readOrThrow(*io_, size_buff, 4, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 194,
        "fullcodeline": "const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);"
    },
    {
        "line": 197,
        "fullcodeline": "enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),"
    },
    {
        "line": 199,
        "fullcodeline": "const long size = static_cast<long>(size_u32);"
    },
    {
        "line": 201,
        "fullcodeline": "DataBuf payload(size);"
    },
    {
        "line": 202,
        "fullcodeline": "readOrThrow(*io_, payload.pData_, size, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 267,
        "fullcodeline": "us2Data(data, (uint16_t) blob.size()+8, bigEndian);"
    },
    {
        "line": 268,
        "fullcodeline": "ul2Data(data, (uint32_t) blob.size(), littleEndian);"
    },
    {
        "line": 281,
        "fullcodeline": "ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);"
    },
    {
        "line": 19,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 37,
        "fullcodeline": "if (blob.size() > 0) {"
    },
    {
        "line": 64,
        "fullcodeline": "if ( payload.size_ % 2 ) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {"
    },
    {
        "line": 127,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {"
    },
    {
        "line": 161,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {"
    },
    {
        "line": 203,
        "fullcodeline": "if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad"
    },
    {
        "line": 205,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {"
    },
    {
        "line": 260,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 266,
        "fullcodeline": "if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 269,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 270,
        "fullcodeline": "if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())"
    },
    {
        "line": 274,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 280,
        "fullcodeline": "if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 282,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 283,
        "fullcodeline": "if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {"
    },
    {
        "line": 286,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 38,
        "fullcodeline": "has_exif = true;"
    },
    {
        "line": 66,
        "fullcodeline": "readOrThrow(*io_, &c, 1, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 72,
        "fullcodeline": "has_vp8x = true;"
    },
    {
        "line": 75,
        "fullcodeline": "enforce(size >= 10, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 76,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 77,
        "fullcodeline": "byte size_buf[WEBP_TAG_SIZE];"
    },
    {
        "line": 80,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[4], 3);"
    },
    {
        "line": 81,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 82,
        "fullcodeline": "width = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 85,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[7], 3);"
    },
    {
        "line": 86,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 87,
        "fullcodeline": "height = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 104,
        "fullcodeline": "enforce(size >= 10, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 105,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 106,
        "fullcodeline": "byte size_buf[2];"
    },
    {
        "line": 112,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[6], 2);"
    },
    {
        "line": 113,
        "fullcodeline": "width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;"
    },
    {
        "line": 116,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[8], 2);"
    },
    {
        "line": 117,
        "fullcodeline": "height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;"
    },
    {
        "line": 122,
        "fullcodeline": "enforce(size >= 5, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 128,
        "fullcodeline": "enforce(size >= 5, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 129,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 130,
        "fullcodeline": "byte size_buf_w[2];"
    },
    {
        "line": 131,
        "fullcodeline": "byte size_buf_h[3];"
    },
    {
        "line": 139,
        "fullcodeline": "memcpy(&size_buf_w, &payload.pData_[1], 2);"
    },
    {
        "line": 140,
        "fullcodeline": "size_buf_w[1] &= 0x3F;"
    },
    {
        "line": 141,
        "fullcodeline": "width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;"
    },
    {
        "line": 144,
        "fullcodeline": "memcpy(&size_buf_h, &payload.pData_[2], 3);"
    },
    {
        "line": 145,
        "fullcodeline": "size_buf_h[0] ="
    },
    {
        "line": 148,
        "fullcodeline": "size_buf_h[1] ="
    },
    {
        "line": 151,
        "fullcodeline": "height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;"
    },
    {
        "line": 156,
        "fullcodeline": "enforce(size >= 6, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 162,
        "fullcodeline": "enforce(size >= 12, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 163,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 164,
        "fullcodeline": "byte size_buf[WEBP_TAG_SIZE];"
    },
    {
        "line": 167,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[6], 3);"
    },
    {
        "line": 168,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 169,
        "fullcodeline": "width = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 172,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[9], 3);"
    },
    {
        "line": 173,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "height = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 179,
        "fullcodeline": "has_alpha = true;"
    },
    {
        "line": 206,
        "fullcodeline": "enforce(size >= 1, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 123,
        "fullcodeline": "if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {"
    },
    {
        "line": 146,
        "fullcodeline": "((size_buf_h[0] >> 6) & 0x3) |"
    },
    {
        "line": 149,
        "fullcodeline": "((size_buf_h[1] >> 6) & 0x3) |"
    },
    {
        "line": 157,
        "fullcodeline": "if ((payload.pData_[5] & 0x2) == 0x2) {"
    },
    {
        "line": 225,
        "fullcodeline": "if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 227,
        "fullcodeline": "if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 229,
        "fullcodeline": "if (outIo.write(payload.pData_, payload.size_) != payload.size_)"
    },
    {
        "line": 231,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 261,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 272,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 275,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 284,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 287,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 124,
        "fullcodeline": "has_alpha = true;"
    },
    {
        "line": 147,
        "fullcodeline": "((size_buf_h[1] & 0x3F) << 0x2);"
    },
    {
        "line": 150,
        "fullcodeline": "((size_buf_h[2] & 0xF) << 0x2);"
    },
    {
        "line": 158,
        "fullcodeline": "has_alpha = true;"
    },
    {
        "line": 208,
        "fullcodeline": "payload.pData_[0] |= WEBP_VP8X_ICC_BIT;"
    },
    {
        "line": 214,
        "fullcodeline": "payload.pData_[0] |= WEBP_VP8X_XMP_BIT;"
    },
    {
        "line": 220,
        "fullcodeline": "payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;"
    },
    {
        "line": 237,
        "fullcodeline": "ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);"
    },
    {
        "line": 242,
        "fullcodeline": "has_icc = false;"
    },
    {
        "line": 244,
        "fullcodeline": "} else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {"
    },
    {
        "line": 210,
        "fullcodeline": "payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;"
    },
    {
        "line": 216,
        "fullcodeline": "payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;"
    },
    {
        "line": 222,
        "fullcodeline": "payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;"
    },
    {
        "line": 226,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 228,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 230,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 232,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 236,
        "fullcodeline": "if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 238,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 239,
        "fullcodeline": "if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {"
    },
    {
        "line": 240,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 246,
        "fullcodeline": "} else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {"
    },
    {
        "line": 248,
        "fullcodeline": "} else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {"
    },
    {
        "line": 251,
        "fullcodeline": "if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 253,
        "fullcodeline": "if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 255,
        "fullcodeline": "if (outIo.write(payload.pData_, payload.size_) != payload.size_)"
    },
    {
        "line": 252,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 254,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    },
    {
        "line": 256,
        "fullcodeline": "throw Error(kerImageWriteFailed);"
    }
]