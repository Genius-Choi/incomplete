[
    {
        "line": 10,
        "fullcodeline": "byte    data   [WEBP_TAG_SIZE*3];"
    },
    {
        "line": 12,
        "fullcodeline": "chunkId.pData_ [WEBP_TAG_SIZE] = '\\0';"
    },
    {
        "line": 14,
        "fullcodeline": "io_->read(data, WEBP_TAG_SIZE * 3);"
    },
    {
        "line": 15,
        "fullcodeline": "uint64_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian);"
    },
    {
        "line": 22,
        "fullcodeline": "bool has_size  = false;"
    },
    {
        "line": 24,
        "fullcodeline": "bool has_exif  = false;"
    },
    {
        "line": 25,
        "fullcodeline": "bool has_vp8x  = false;"
    },
    {
        "line": 26,
        "fullcodeline": "bool has_alpha = false;"
    },
    {
        "line": 27,
        "fullcodeline": "bool has_icc   = iccProfileDefined();"
    },
    {
        "line": 29,
        "fullcodeline": "int width      = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int height     = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "byte       size_buff[WEBP_TAG_SIZE];"
    },
    {
        "line": 47,
        "fullcodeline": "has_xmp = xmpPacket_.size() > 0;"
    },
    {
        "line": 176,
        "fullcodeline": "io_->seek(12, BasicIo::beg);"
    },
    {
        "line": 273,
        "fullcodeline": "outIo.seek(0, BasicIo::beg);"
    },
    {
        "line": 274,
        "fullcodeline": "filesize = outIo.size() - 8;"
    },
    {
        "line": 275,
        "fullcodeline": "outIo.seek(4, BasicIo::beg);"
    },
    {
        "line": 276,
        "fullcodeline": "ul2Data(data, (uint32_t) filesize, littleEndian);"
    },
    {
        "line": 3,
        "fullcodeline": "if (!io_->isopen()) throw Error(kerInputDataReadFailed);"
    },
    {
        "line": 53,
        "fullcodeline": "while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {"
    },
    {
        "line": 4,
        "fullcodeline": "if (!outIo.isopen()) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 18,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE * 3) != WEBP_TAG_SIZE * 3)"
    },
    {
        "line": 35,
        "fullcodeline": "if (exifData_.count() > 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "ExifParser::encode(blob, littleEndian, exifData_);"
    },
    {
        "line": 42,
        "fullcodeline": "if (xmpData_.count() > 0 && !writeXmpFromPacket()) {"
    },
    {
        "line": 43,
        "fullcodeline": "XmpParser::encode(xmpPacket_, xmpData_,"
    },
    {
        "line": 54,
        "fullcodeline": "io_->read(chunkId.pData_, WEBP_TAG_SIZE);"
    },
    {
        "line": 55,
        "fullcodeline": "io_->read(size_buff, WEBP_TAG_SIZE);"
    },
    {
        "line": 56,
        "fullcodeline": "long size = Exiv2::getULong(size_buff, littleEndian);"
    },
    {
        "line": 58,
        "fullcodeline": "io_->read(payload.pData_, payload.size_);"
    },
    {
        "line": 172,
        "fullcodeline": "inject_VP8X(outIo, has_xmp, has_exif, has_alpha,"
    },
    {
        "line": 177,
        "fullcodeline": "while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {"
    },
    {
        "line": 178,
        "fullcodeline": "io_->read(chunkId.pData_, 4);"
    },
    {
        "line": 179,
        "fullcodeline": "io_->read(size_buff, 4);"
    },
    {
        "line": 181,
        "fullcodeline": "long size = Exiv2::getULong(size_buff, littleEndian);"
    },
    {
        "line": 183,
        "fullcodeline": "DataBuf payload(size);"
    },
    {
        "line": 184,
        "fullcodeline": "io_->read(payload.pData_, size);"
    },
    {
        "line": 248,
        "fullcodeline": "us2Data(data, (uint16_t) blob.size()+8, bigEndian);"
    },
    {
        "line": 249,
        "fullcodeline": "ul2Data(data, (uint32_t) blob.size(), littleEndian);"
    },
    {
        "line": 262,
        "fullcodeline": "ul2Data(data, (uint32_t) xmpPacket().size(), littleEndian);"
    },
    {
        "line": 277,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 44,
        "fullcodeline": "XmpParser::useCompactFormat |"
    },
    {
        "line": 60,
        "fullcodeline": "if ( payload.size_ % 2 ) io_->read(&c,1);"
    },
    {
        "line": 67,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_size) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8) && !has_size) {"
    },
    {
        "line": 112,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_alpha) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8L) && !has_size) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_alpha) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ANMF) && !has_size) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (equalsWebPTag(chunkId, \"ALPH\") && !has_alpha) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X)) {"
    },
    {
        "line": 247,
        "fullcodeline": "if (outIo.write((const byte*)WEBP_CHUNK_HEADER_EXIF, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 250,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 261,
        "fullcodeline": "if (outIo.write((const byte*)WEBP_CHUNK_HEADER_XMP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 263,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 37,
        "fullcodeline": "if (blob.size() > 0) {"
    },
    {
        "line": 38,
        "fullcodeline": "has_exif = true;"
    },
    {
        "line": 64,
        "fullcodeline": "if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_VP8X) && !has_vp8x) {"
    },
    {
        "line": 65,
        "fullcodeline": "has_vp8x = true;"
    },
    {
        "line": 68,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 69,
        "fullcodeline": "byte size_buf[WEBP_TAG_SIZE];"
    },
    {
        "line": 72,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[4], 3);"
    },
    {
        "line": 73,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "width = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 77,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[7], 3);"
    },
    {
        "line": 78,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "height = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 96,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 97,
        "fullcodeline": "byte size_buf[2];"
    },
    {
        "line": 103,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[6], 2);"
    },
    {
        "line": 104,
        "fullcodeline": "width = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;"
    },
    {
        "line": 107,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[8], 2);"
    },
    {
        "line": 108,
        "fullcodeline": "height = Exiv2::getUShort(size_buf, littleEndian) & 0x3fff;"
    },
    {
        "line": 118,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 119,
        "fullcodeline": "byte size_buf_w[2];"
    },
    {
        "line": 120,
        "fullcodeline": "byte size_buf_h[3];"
    },
    {
        "line": 128,
        "fullcodeline": "memcpy(&size_buf_w, &payload.pData_[1], 2);"
    },
    {
        "line": 129,
        "fullcodeline": "size_buf_w[1] &= 0x3F;"
    },
    {
        "line": 130,
        "fullcodeline": "width = Exiv2::getUShort(size_buf_w, littleEndian) + 1;"
    },
    {
        "line": 133,
        "fullcodeline": "memcpy(&size_buf_h, &payload.pData_[2], 3);"
    },
    {
        "line": 134,
        "fullcodeline": "size_buf_h[0] ="
    },
    {
        "line": 137,
        "fullcodeline": "size_buf_h[1] ="
    },
    {
        "line": 140,
        "fullcodeline": "height = Exiv2::getUShort(size_buf_h, littleEndian) + 1;"
    },
    {
        "line": 150,
        "fullcodeline": "has_size = true;"
    },
    {
        "line": 151,
        "fullcodeline": "byte size_buf[WEBP_TAG_SIZE];"
    },
    {
        "line": 154,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[6], 3);"
    },
    {
        "line": 155,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 156,
        "fullcodeline": "width = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 159,
        "fullcodeline": "memcpy(&size_buf, &payload.pData_[9], 3);"
    },
    {
        "line": 160,
        "fullcodeline": "size_buf[3] = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "height = Exiv2::getULong(size_buf, littleEndian) + 1;"
    },
    {
        "line": 166,
        "fullcodeline": "has_alpha = true;"
    },
    {
        "line": 185,
        "fullcodeline": "if ( io_->tell() % 2 ) io_->seek(+1,BasicIo::cur); // skip pad"
    },
    {
        "line": 241,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 251,
        "fullcodeline": "if (outIo.write((const byte*)&blob[0], static_cast<long>(blob.size())) != (long)blob.size())"
    },
    {
        "line": 255,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 264,
        "fullcodeline": "if (outIo.write((const byte*)xmp.data(), static_cast<long>(xmp.size())) != (long)xmp.size()) {"
    },
    {
        "line": 267,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 113,
        "fullcodeline": "if ((payload.pData_[4] & WEBP_VP8X_ALPHA_BIT) == WEBP_VP8X_ALPHA_BIT) {"
    },
    {
        "line": 135,
        "fullcodeline": "((size_buf_h[0] >> 6) & 0x3) |"
    },
    {
        "line": 138,
        "fullcodeline": "((size_buf_h[1] >> 6) & 0x3) |"
    },
    {
        "line": 206,
        "fullcodeline": "if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 208,
        "fullcodeline": "if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 210,
        "fullcodeline": "if (outIo.write(payload.pData_, payload.size_) != payload.size_)"
    },
    {
        "line": 114,
        "fullcodeline": "has_alpha = true;"
    },
    {
        "line": 136,
        "fullcodeline": "((size_buf_h[1] & 0x3F) << 0x2);"
    },
    {
        "line": 139,
        "fullcodeline": "((size_buf_h[2] & 0xF) << 0x2);"
    },
    {
        "line": 145,
        "fullcodeline": "if ((payload.pData_[5] & 0x2) == 0x2) {"
    },
    {
        "line": 146,
        "fullcodeline": "has_alpha = true;"
    },
    {
        "line": 189,
        "fullcodeline": "payload.pData_[0] |= WEBP_VP8X_ICC_BIT;"
    },
    {
        "line": 195,
        "fullcodeline": "payload.pData_[0] |= WEBP_VP8X_XMP_BIT;"
    },
    {
        "line": 201,
        "fullcodeline": "payload.pData_[0] |= WEBP_VP8X_EXIF_BIT;"
    },
    {
        "line": 212,
        "fullcodeline": "if (outIo.tell() % 2) {"
    },
    {
        "line": 218,
        "fullcodeline": "ul2Data(data, (uint32_t) iccProfile_.size_, littleEndian);"
    },
    {
        "line": 225,
        "fullcodeline": "} else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {"
    },
    {
        "line": 242,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 256,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 268,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 191,
        "fullcodeline": "payload.pData_[0] &= ~WEBP_VP8X_ICC_BIT;"
    },
    {
        "line": 197,
        "fullcodeline": "payload.pData_[0] &= ~WEBP_VP8X_XMP_BIT;"
    },
    {
        "line": 203,
        "fullcodeline": "payload.pData_[0] &= ~WEBP_VP8X_EXIF_BIT;"
    },
    {
        "line": 217,
        "fullcodeline": "if (outIo.write((const byte*)WEBP_CHUNK_HEADER_ICCP, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 219,
        "fullcodeline": "if (outIo.write(data, WEBP_TAG_SIZE) != WEBP_TAG_SIZE) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 220,
        "fullcodeline": "if (outIo.write(iccProfile_.pData_, iccProfile_.size_) != iccProfile_.size_) {"
    },
    {
        "line": 213,
        "fullcodeline": "if (outIo.write(&WEBP_PAD_ODD, 1) != 1) throw Error(kerImageWriteFailed);"
    },
    {
        "line": 227,
        "fullcodeline": "} else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {"
    },
    {
        "line": 229,
        "fullcodeline": "} else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {"
    },
    {
        "line": 232,
        "fullcodeline": "if (outIo.write(chunkId.pData_, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 234,
        "fullcodeline": "if (outIo.write(size_buff, WEBP_TAG_SIZE) != WEBP_TAG_SIZE)"
    },
    {
        "line": 236,
        "fullcodeline": "if (outIo.write(payload.pData_, payload.size_) != payload.size_)"
    }
]