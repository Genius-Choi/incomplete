[
    {
        "line": 9,
        "fullcodeline": "OnigRegion *regs = nullptr;"
    },
    {
        "line": 14,
        "fullcodeline": "char pat_buf[2];"
    },
    {
        "line": 27,
        "fullcodeline": "eval = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "re = php_mbregex_compile_pattern(spattern, options,"
    },
    {
        "line": 59,
        "fullcodeline": "err = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "pos = (OnigUChar*)str.data();"
    },
    {
        "line": 61,
        "fullcodeline": "string_lim = (OnigUChar*)(str.data() + str.size());"
    },
    {
        "line": 62,
        "fullcodeline": "regs = onig_region_new();"
    },
    {
        "line": 20,
        "fullcodeline": "current_enc_name = php_mb_regex_mbctype2name(MBSTRG(current_mbctype));"
    },
    {
        "line": 39,
        "fullcodeline": "if (pattern.isString()) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (re == nullptr) {"
    },
    {
        "line": 63,
        "fullcodeline": "while (err >= 0) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (regs != nullptr) {"
    },
    {
        "line": 136,
        "fullcodeline": "return out_buf.detach();"
    },
    {
        "line": 21,
        "fullcodeline": "if (current_enc_name == nullptr ||"
    },
    {
        "line": 40,
        "fullcodeline": "spattern = pattern.toString();"
    },
    {
        "line": 49,
        "fullcodeline": "MBSTRG(current_mbctype), syntax);"
    },
    {
        "line": 64,
        "fullcodeline": "err = onig_search(re, (OnigUChar *)str.data(), (OnigUChar *)string_lim,"
    },
    {
        "line": 126,
        "fullcodeline": "onig_region_free(regs, 0);"
    },
    {
        "line": 133,
        "fullcodeline": "if (err <= -2) {"
    },
    {
        "line": 22,
        "fullcodeline": "(enc = mbfl_name2encoding(current_enc_name)) == nullptr) {"
    },
    {
        "line": 23,
        "fullcodeline": "raise_warning(\"Unknown error\");"
    },
    {
        "line": 29,
        "fullcodeline": "if (!option.empty()) {"
    },
    {
        "line": 30,
        "fullcodeline": "_php_mb_regex_init_options(option.data(), option.size(),"
    },
    {
        "line": 43,
        "fullcodeline": "pat_buf[0] = pattern.toByte();"
    },
    {
        "line": 44,
        "fullcodeline": "pat_buf[1] = '\\0';"
    },
    {
        "line": 45,
        "fullcodeline": "spattern = String(pat_buf, 1, CopyString);"
    },
    {
        "line": 66,
        "fullcodeline": "if (err <= -2) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (err >= 0) {"
    },
    {
        "line": 33,
        "fullcodeline": "options |= MBSTRG(regex_default_options);"
    },
    {
        "line": 34,
        "fullcodeline": "syntax = MBSTRG(regex_default_syntax);"
    },
    {
        "line": 67,
        "fullcodeline": "OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];"
    },
    {
        "line": 68,
        "fullcodeline": "onig_error_code_to_str(err_str, err);"
    },
    {
        "line": 80,
        "fullcodeline": "out_buf.append((const char *)pos,"
    },
    {
        "line": 83,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 84,
        "fullcodeline": "p = replacement.data();"
    },
    {
        "line": 111,
        "fullcodeline": "n = regs->end[0];"
    },
    {
        "line": 81,
        "fullcodeline": "(OnigUChar *)(str.data() + regs->beg[0]) - pos);"
    },
    {
        "line": 85,
        "fullcodeline": "while (i < replacement.size()) {"
    },
    {
        "line": 112,
        "fullcodeline": "if ((pos - (OnigUChar *)str.data()) < n) {"
    },
    {
        "line": 86,
        "fullcodeline": "int fwd = (int)php_mb_mbchar_bytes_ex(p, enc);"
    },
    {
        "line": 87,
        "fullcodeline": "n = -1;"
    },
    {
        "line": 88,
        "fullcodeline": "auto const remaining = replacement.size() - i;"
    },
    {
        "line": 113,
        "fullcodeline": "pos = (OnigUChar *)(str.data() + n);"
    },
    {
        "line": 118,
        "fullcodeline": "pos++;"
    },
    {
        "line": 122,
        "fullcodeline": "if (string_lim - pos > 0) {"
    },
    {
        "line": 123,
        "fullcodeline": "out_buf.append((const char *)pos, string_lim - pos);"
    },
    {
        "line": 89,
        "fullcodeline": "if (remaining >= 2 && fwd == 1 &&"
    },
    {
        "line": 90,
        "fullcodeline": "p[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {"
    },
    {
        "line": 91,
        "fullcodeline": "n = p[1] - '0';"
    },
    {
        "line": 93,
        "fullcodeline": "if (n >= 0 && n < regs->num_regs) {"
    },
    {
        "line": 99,
        "fullcodeline": "p += 2;"
    },
    {
        "line": 100,
        "fullcodeline": "i += 2;"
    },
    {
        "line": 115,
        "fullcodeline": "if (pos < string_lim) {"
    },
    {
        "line": 116,
        "fullcodeline": "out_buf.append((const char *)pos, 1);"
    },
    {
        "line": 94,
        "fullcodeline": "if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] &&"
    },
    {
        "line": 95,
        "fullcodeline": "regs->end[n] <= str.size()) {"
    },
    {
        "line": 96,
        "fullcodeline": "out_buf.append(str.data() + regs->beg[n],"
    },
    {
        "line": 101,
        "fullcodeline": "} else if (remaining >= fwd) {"
    },
    {
        "line": 97,
        "fullcodeline": "regs->end[n] - regs->beg[n]);"
    },
    {
        "line": 102,
        "fullcodeline": "out_buf.append(p, fwd);"
    },
    {
        "line": 103,
        "fullcodeline": "p += fwd;"
    },
    {
        "line": 104,
        "fullcodeline": "i += fwd;"
    },
    {
        "line": 106,
        "fullcodeline": "raise_warning(\"Replacement ends with unterminated %s: 0x%hhx\","
    }
]