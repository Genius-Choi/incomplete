[
    {
        "line": 2,
        "fullcodeline": "if withargs is None:"
    },
    {
        "line": 4,
        "fullcodeline": "if not isinstance(withargs, dict):"
    },
    {
        "line": 7,
        "fullcodeline": "if existing_labels is None:"
    },
    {
        "line": 9,
        "fullcodeline": "if not isinstance(existing_labels, set):"
    },
    {
        "line": 13,
        "fullcodeline": "if isinstance(code.value, str) and code.value.upper() in get_opcodes():"
    },
    {
        "line": 3,
        "fullcodeline": "withargs = {}"
    },
    {
        "line": 5,
        "fullcodeline": "raise CompilerPanic(f\"Incorrect type for withargs: {type(withargs)}\")"
    },
    {
        "line": 8,
        "fullcodeline": "existing_labels = set()"
    },
    {
        "line": 10,
        "fullcodeline": "raise CompilerPanic(f\"Incorrect type for existing_labels: {type(existing_labels)}\")"
    },
    {
        "line": 14,
        "fullcodeline": "o = []"
    },
    {
        "line": 17,
        "fullcodeline": "o.append(code.value.upper())"
    },
    {
        "line": 15,
        "fullcodeline": "for i, c in enumerate(code.args[::-1]):"
    },
    {
        "line": 20,
        "fullcodeline": "elif isinstance(code.value, int):"
    },
    {
        "line": 25,
        "fullcodeline": "bytez = num_to_bytearray(code.value % 2 ** 256) or [0]"
    },
    {
        "line": 16,
        "fullcodeline": "o.extend(_compile_to_assembly(c, withargs, existing_labels, break_dest, height + i))"
    },
    {
        "line": 21,
        "fullcodeline": "if code.value < -(2 ** 255):"
    },
    {
        "line": 26,
        "fullcodeline": "return [\"PUSH\" + str(len(bytez))] + bytez"
    },
    {
        "line": 28,
        "fullcodeline": "elif isinstance(code.value, str) and code.value in withargs:"
    },
    {
        "line": 22,
        "fullcodeline": "raise Exception(f\"Value too low: {code.value}\")"
    },
    {
        "line": 23,
        "fullcodeline": "elif code.value >= 2 ** 256:"
    },
    {
        "line": 31,
        "fullcodeline": "return [\"DUP\" + str(height - withargs[code.value])]"
    },
    {
        "line": 33,
        "fullcodeline": "elif code.value == \"set\":"
    },
    {
        "line": 29,
        "fullcodeline": "if height - withargs[code.value] > 16:"
    },
    {
        "line": 24,
        "fullcodeline": "raise Exception(f\"Value too high: {code.value}\")"
    },
    {
        "line": 30,
        "fullcodeline": "raise Exception(\"With statement too deep\")"
    },
    {
        "line": 38,
        "fullcodeline": "return _compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height) + ["
    },
    {
        "line": 43,
        "fullcodeline": "elif code.value in (\"pass\", \"dummy\"):"
    },
    {
        "line": 34,
        "fullcodeline": "if len(code.args) != 2 or code.args[0].value not in withargs:"
    },
    {
        "line": 36,
        "fullcodeline": "if height - withargs[code.args[0].value] > 16:"
    },
    {
        "line": 35,
        "fullcodeline": "raise Exception(\"Set expects two arguments, the first being a stack variable\")"
    },
    {
        "line": 37,
        "fullcodeline": "raise Exception(\"With statement too deep\")"
    },
    {
        "line": 44,
        "fullcodeline": "return []"
    },
    {
        "line": 46,
        "fullcodeline": "elif code.value == \"~codelen\":"
    },
    {
        "line": 39,
        "fullcodeline": "\"SWAP\" + str(height - withargs[code.args[0].value]),"
    },
    {
        "line": 47,
        "fullcodeline": "return [\"_sym_codeend\"]"
    },
    {
        "line": 49,
        "fullcodeline": "elif code.value == \"codeload\":"
    },
    {
        "line": 50,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 51,
        "fullcodeline": "LLLnode.from_list("
    },
    {
        "line": 64,
        "fullcodeline": "elif code.value in (\"if\", \"if_unchecked\") and len(code.args) == 2:"
    },
    {
        "line": 65,
        "fullcodeline": "o = []"
    },
    {
        "line": 66,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 67,
        "fullcodeline": "end_symbol = mksymbol()"
    },
    {
        "line": 68,
        "fullcodeline": "o.extend([\"ISZERO\", end_symbol, \"JUMPI\"])"
    },
    {
        "line": 69,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 70,
        "fullcodeline": "o.extend([end_symbol, \"JUMPDEST\"])"
    },
    {
        "line": 52,
        "fullcodeline": "["
    },
    {
        "line": 54,
        "fullcodeline": "[\"codecopy\", MemoryPositions.FREE_VAR_SPACE, code.args[0], 32],"
    },
    {
        "line": 55,
        "fullcodeline": "[\"mload\", MemoryPositions.FREE_VAR_SPACE],"
    },
    {
        "line": 73,
        "fullcodeline": "elif code.value == \"if\" and len(code.args) == 3:"
    },
    {
        "line": 74,
        "fullcodeline": "o = []"
    },
    {
        "line": 75,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 76,
        "fullcodeline": "mid_symbol = mksymbol()"
    },
    {
        "line": 77,
        "fullcodeline": "end_symbol = mksymbol()"
    },
    {
        "line": 78,
        "fullcodeline": "o.extend([\"ISZERO\", mid_symbol, \"JUMPI\"])"
    },
    {
        "line": 79,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 80,
        "fullcodeline": "o.extend([end_symbol, \"JUMP\", mid_symbol, \"JUMPDEST\"])"
    },
    {
        "line": 81,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[2], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 82,
        "fullcodeline": "o.extend([end_symbol, \"JUMPDEST\"])"
    },
    {
        "line": 86,
        "fullcodeline": "elif code.value == \"repeat\":"
    },
    {
        "line": 87,
        "fullcodeline": "o = []"
    },
    {
        "line": 88,
        "fullcodeline": "loops = num_to_bytearray(code.args[2].value)"
    },
    {
        "line": 90,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 91,
        "fullcodeline": "o.extend("
    },
    {
        "line": 94,
        "fullcodeline": "o.extend([\"PUSH\" + str(len(loops))] + loops)"
    },
    {
        "line": 96,
        "fullcodeline": "o.extend([\"DUP2\", \"DUP4\", \"MSTORE\", \"ADD\", start, \"JUMPDEST\"])"
    },
    {
        "line": 98,
        "fullcodeline": "o.extend("
    },
    {
        "line": 108,
        "fullcodeline": "o.extend("
    },
    {
        "line": 123,
        "fullcodeline": "o.extend([\"DUP2\", \"EQ\", \"ISZERO\", start, \"JUMPI\", end, \"JUMPDEST\", \"POP\", \"POP\"])"
    },
    {
        "line": 89,
        "fullcodeline": "start, continue_dest, end = mksymbol(), mksymbol(), mksymbol()"
    },
    {
        "line": 92,
        "fullcodeline": "_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height + 1,)"
    },
    {
        "line": 99,
        "fullcodeline": "_compile_to_assembly("
    },
    {
        "line": 109,
        "fullcodeline": "["
    },
    {
        "line": 126,
        "fullcodeline": "elif code.value == \"continue\":"
    },
    {
        "line": 103,
        "fullcodeline": "(end, continue_dest, height + 2),"
    },
    {
        "line": 127,
        "fullcodeline": "if not break_dest:"
    },
    {
        "line": 129,
        "fullcodeline": "dest, continue_dest, break_height = break_dest"
    },
    {
        "line": 130,
        "fullcodeline": "return [continue_dest, \"JUMP\"]"
    },
    {
        "line": 132,
        "fullcodeline": "elif code.value == \"break\":"
    },
    {
        "line": 128,
        "fullcodeline": "raise CompilerPanic(\"Invalid break\")"
    },
    {
        "line": 133,
        "fullcodeline": "if not break_dest:"
    },
    {
        "line": 135,
        "fullcodeline": "dest, continue_dest, break_height = break_dest"
    },
    {
        "line": 136,
        "fullcodeline": "return [\"POP\"] * (height - break_height) + [dest, \"JUMP\"]"
    },
    {
        "line": 138,
        "fullcodeline": "elif code.value == \"exit_repeater\":"
    },
    {
        "line": 134,
        "fullcodeline": "raise CompilerPanic(\"Invalid break\")"
    },
    {
        "line": 139,
        "fullcodeline": "if not break_dest:"
    },
    {
        "line": 141,
        "fullcodeline": "_, _, break_height = break_dest"
    },
    {
        "line": 142,
        "fullcodeline": "return [\"POP\"] * break_height"
    },
    {
        "line": 144,
        "fullcodeline": "elif code.value == \"with\":"
    },
    {
        "line": 145,
        "fullcodeline": "o = []"
    },
    {
        "line": 146,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 147,
        "fullcodeline": "old = withargs.get(code.args[0].value, None)"
    },
    {
        "line": 148,
        "fullcodeline": "withargs[code.args[0].value] = height"
    },
    {
        "line": 149,
        "fullcodeline": "o.extend("
    },
    {
        "line": 140,
        "fullcodeline": "raise CompilerPanic(\"Invalid break\")"
    },
    {
        "line": 150,
        "fullcodeline": "_compile_to_assembly(code.args[2], withargs, existing_labels, break_dest, height + 1,)"
    },
    {
        "line": 156,
        "fullcodeline": "if old is not None:"
    },
    {
        "line": 162,
        "fullcodeline": "elif code.value == \"lll\":"
    },
    {
        "line": 153,
        "fullcodeline": "o.extend([\"SWAP1\", \"POP\"])"
    },
    {
        "line": 155,
        "fullcodeline": "o.extend([\"POP\"])"
    },
    {
        "line": 163,
        "fullcodeline": "o = []"
    },
    {
        "line": 164,
        "fullcodeline": "begincode = mksymbol()"
    },
    {
        "line": 165,
        "fullcodeline": "endcode = mksymbol()"
    },
    {
        "line": 166,
        "fullcodeline": "o.extend([endcode, \"JUMP\", begincode, \"BLANK\"])"
    },
    {
        "line": 168,
        "fullcodeline": "lll = _compile_to_assembly(code.args[0], {}, existing_labels, None, 0)"
    },
    {
        "line": 177,
        "fullcodeline": "o.append(lll)"
    },
    {
        "line": 179,
        "fullcodeline": "o.extend([endcode, \"JUMPDEST\", begincode, endcode, \"SUB\", begincode])"
    },
    {
        "line": 180,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 183,
        "fullcodeline": "o.extend([\"CODECOPY\", begincode, endcode, \"SUB\"])"
    },
    {
        "line": 186,
        "fullcodeline": "elif code.value == \"seq\":"
    },
    {
        "line": 187,
        "fullcodeline": "o = []"
    },
    {
        "line": 188,
        "fullcodeline": "for arg in code.args:"
    },
    {
        "line": 194,
        "fullcodeline": "elif code.value == \"seq_unchecked\":"
    },
    {
        "line": 195,
        "fullcodeline": "o = []"
    },
    {
        "line": 189,
        "fullcodeline": "o.extend(_compile_to_assembly(arg, withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 196,
        "fullcodeline": "for arg in code.args:"
    },
    {
        "line": 201,
        "fullcodeline": "elif code.value == \"assert_unreachable\":"
    },
    {
        "line": 202,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 203,
        "fullcodeline": "end_symbol = mksymbol()"
    },
    {
        "line": 204,
        "fullcodeline": "o.extend([end_symbol, \"JUMPI\", \"INVALID\", end_symbol, \"JUMPDEST\"])"
    },
    {
        "line": 190,
        "fullcodeline": "if arg.valency == 1 and arg != code.args[-1]:"
    },
    {
        "line": 191,
        "fullcodeline": "o.append(\"POP\")"
    },
    {
        "line": 197,
        "fullcodeline": "o.extend(_compile_to_assembly(arg, withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 198,
        "fullcodeline": "height += arg.valency"
    },
    {
        "line": 207,
        "fullcodeline": "elif code.value == \"assert\":"
    },
    {
        "line": 208,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 209,
        "fullcodeline": "o.extend([\"ISZERO\"])"
    },
    {
        "line": 210,
        "fullcodeline": "o.extend(_assert_false())"
    },
    {
        "line": 213,
        "fullcodeline": "elif code.value in CLAMP_OP_NAMES:"
    },
    {
        "line": 234,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 235,
        "fullcodeline": "o.extend("
    },
    {
        "line": 238,
        "fullcodeline": "o.extend([\"DUP2\"])"
    },
    {
        "line": 256,
        "fullcodeline": "o.extend(_assert_false())"
    },
    {
        "line": 236,
        "fullcodeline": "_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height + 1,)"
    },
    {
        "line": 240,
        "fullcodeline": "if code.value == \"uclamplt\":"
    },
    {
        "line": 259,
        "fullcodeline": "elif code.value in (\"clamp\", \"uclamp\"):"
    },
    {
        "line": 214,
        "fullcodeline": "if isinstance(code.args[0].value, int) and isinstance(code.args[1].value, int):"
    },
    {
        "line": 216,
        "fullcodeline": "args_0_val = code.args[0].value"
    },
    {
        "line": 217,
        "fullcodeline": "args_1_val = code.args[1].value"
    },
    {
        "line": 241,
        "fullcodeline": "o.extend([\"LT\", \"ISZERO\"])"
    },
    {
        "line": 260,
        "fullcodeline": "comp1 = \"SGT\" if code.value == \"clamp\" else \"GT\""
    },
    {
        "line": 261,
        "fullcodeline": "comp2 = \"SLT\" if code.value == \"clamp\" else \"LT\""
    },
    {
        "line": 262,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 263,
        "fullcodeline": "o.extend("
    },
    {
        "line": 266,
        "fullcodeline": "o.extend([\"DUP1\"])"
    },
    {
        "line": 267,
        "fullcodeline": "o.extend("
    },
    {
        "line": 270,
        "fullcodeline": "o.extend([\"SWAP1\", comp1])"
    },
    {
        "line": 271,
        "fullcodeline": "o.extend(_assert_false())"
    },
    {
        "line": 272,
        "fullcodeline": "o.extend([\"DUP1\", \"SWAP2\", \"SWAP1\", comp2])"
    },
    {
        "line": 273,
        "fullcodeline": "o.extend(_assert_false())"
    },
    {
        "line": 218,
        "fullcodeline": "is_free_of_clamp_errors = any("
    },
    {
        "line": 242,
        "fullcodeline": "elif code.value == \"clamplt\":"
    },
    {
        "line": 264,
        "fullcodeline": "_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height + 1,)"
    },
    {
        "line": 268,
        "fullcodeline": "_compile_to_assembly(code.args[2], withargs, existing_labels, break_dest, height + 3,)"
    },
    {
        "line": 276,
        "fullcodeline": "elif code.value == \"clamp_nonzero\":"
    },
    {
        "line": 219,
        "fullcodeline": "("
    },
    {
        "line": 243,
        "fullcodeline": "o.extend([\"SLT\", \"ISZERO\"])"
    },
    {
        "line": 277,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 278,
        "fullcodeline": "o.extend([\"DUP1\", \"ISZERO\"])"
    },
    {
        "line": 279,
        "fullcodeline": "o.extend(_assert_false())"
    },
    {
        "line": 220,
        "fullcodeline": "code.value in (\"uclamplt\", \"clamplt\") and 0 <= args_0_val < args_1_val,"
    },
    {
        "line": 221,
        "fullcodeline": "code.value in (\"uclample\", \"clample\") and 0 <= args_0_val <= args_1_val,"
    },
    {
        "line": 222,
        "fullcodeline": "code.value in (\"uclampgt\", \"clampgt\") and 0 <= args_0_val > args_1_val,"
    },
    {
        "line": 223,
        "fullcodeline": "code.value in (\"uclampge\", \"clampge\") and 0 <= args_0_val >= args_1_val,"
    },
    {
        "line": 227,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 231,
        "fullcodeline": "raise Exception("
    },
    {
        "line": 244,
        "fullcodeline": "elif code.value == \"uclample\":"
    },
    {
        "line": 282,
        "fullcodeline": "elif code.value == \"sha3_32\":"
    },
    {
        "line": 232,
        "fullcodeline": "f\"Invalid {code.value} with values {code.args[0]} and {code.args[1]}\""
    },
    {
        "line": 245,
        "fullcodeline": "o.extend([\"GT\"])"
    },
    {
        "line": 283,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 284,
        "fullcodeline": "o.extend("
    },
    {
        "line": 246,
        "fullcodeline": "elif code.value == \"clample\":"
    },
    {
        "line": 285,
        "fullcodeline": "["
    },
    {
        "line": 298,
        "fullcodeline": "elif code.value == \"sha3_64\":"
    },
    {
        "line": 247,
        "fullcodeline": "o.extend([\"SGT\"])"
    },
    {
        "line": 299,
        "fullcodeline": "o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)"
    },
    {
        "line": 300,
        "fullcodeline": "o.extend(_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height))"
    },
    {
        "line": 301,
        "fullcodeline": "o.extend("
    },
    {
        "line": 248,
        "fullcodeline": "elif code.value == \"uclampgt\":"
    },
    {
        "line": 302,
        "fullcodeline": "["
    },
    {
        "line": 318,
        "fullcodeline": "elif code.value == \"le\":"
    },
    {
        "line": 249,
        "fullcodeline": "o.extend([\"GT\", \"ISZERO\"])"
    },
    {
        "line": 250,
        "fullcodeline": "elif code.value == \"clampgt\":"
    },
    {
        "line": 319,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 327,
        "fullcodeline": "elif code.value == \"ge\":"
    },
    {
        "line": 251,
        "fullcodeline": "o.extend([\"SGT\", \"ISZERO\"])"
    },
    {
        "line": 320,
        "fullcodeline": "LLLnode.from_list([\"iszero\", [\"gt\", code.args[0], code.args[1]]]),"
    },
    {
        "line": 252,
        "fullcodeline": "elif code.value == \"uclampge\":"
    },
    {
        "line": 328,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 336,
        "fullcodeline": "elif code.value == \"sle\":"
    },
    {
        "line": 253,
        "fullcodeline": "o.extend([\"LT\"])"
    },
    {
        "line": 329,
        "fullcodeline": "LLLnode.from_list([\"iszero\", [\"lt\", code.args[0], code.args[1]]]),"
    },
    {
        "line": 337,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 345,
        "fullcodeline": "elif code.value == \"sge\":"
    },
    {
        "line": 255,
        "fullcodeline": "o.extend([\"SLT\"])"
    },
    {
        "line": 338,
        "fullcodeline": "LLLnode.from_list([\"iszero\", [\"sgt\", code.args[0], code.args[1]]]),"
    },
    {
        "line": 346,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 354,
        "fullcodeline": "elif code.value == \"ne\":"
    },
    {
        "line": 347,
        "fullcodeline": "LLLnode.from_list([\"iszero\", [\"slt\", code.args[0], code.args[1]]]),"
    },
    {
        "line": 355,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 363,
        "fullcodeline": "elif code.value == \"ceil32\":"
    },
    {
        "line": 356,
        "fullcodeline": "LLLnode.from_list([\"iszero\", [\"eq\", code.args[0], code.args[1]]]),"
    },
    {
        "line": 364,
        "fullcodeline": "return _compile_to_assembly("
    },
    {
        "line": 379,
        "fullcodeline": "elif code.value == \"goto\":"
    },
    {
        "line": 365,
        "fullcodeline": "LLLnode.from_list("
    },
    {
        "line": 380,
        "fullcodeline": "o = []"
    },
    {
        "line": 383,
        "fullcodeline": "o.extend([\"_sym_\" + str(code.args[0]), \"JUMP\"])"
    },
    {
        "line": 366,
        "fullcodeline": "["
    },
    {
        "line": 381,
        "fullcodeline": "for i, c in enumerate(reversed(code.args[1:])):"
    },
    {
        "line": 370,
        "fullcodeline": "[\"sub\", [\"add\", \"_val\", 31], [\"mod\", [\"sub\", \"_val\", 1], 32]],"
    },
    {
        "line": 385,
        "fullcodeline": "elif isinstance(code.value, str) and is_symbol(code.value):"
    },
    {
        "line": 382,
        "fullcodeline": "o.extend(_compile_to_assembly(c, withargs, existing_labels, break_dest, height + i))"
    },
    {
        "line": 386,
        "fullcodeline": "return [code.value]"
    },
    {
        "line": 388,
        "fullcodeline": "elif code.value == \"label\":"
    },
    {
        "line": 389,
        "fullcodeline": "label_name = str(code.args[0])"
    },
    {
        "line": 391,
        "fullcodeline": "if label_name in existing_labels:"
    },
    {
        "line": 396,
        "fullcodeline": "return [\"_sym_\" + label_name, \"JUMPDEST\"]"
    },
    {
        "line": 398,
        "fullcodeline": "elif code.value == \"debugger\":"
    },
    {
        "line": 394,
        "fullcodeline": "existing_labels.add(label_name)"
    },
    {
        "line": 392,
        "fullcodeline": "raise Exception(f\"Label with name {label_name} already exists!\")"
    },
    {
        "line": 399,
        "fullcodeline": "return mkdebug(pc_debugger=False, pos=code.pos)"
    },
    {
        "line": 401,
        "fullcodeline": "elif code.value == \"pc_debugger\":"
    },
    {
        "line": 402,
        "fullcodeline": "return mkdebug(pc_debugger=True, pos=code.pos)"
    },
    {
        "line": 404,
        "fullcodeline": "raise Exception(\"Weird code element: \" + repr(code))"
    }
]