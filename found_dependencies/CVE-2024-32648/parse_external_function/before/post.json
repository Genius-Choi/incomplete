[
    {
        "line": 19,
        "fullcodeline": "clampers = []"
    },
    {
        "line": 22,
        "fullcodeline": "copier: List[Any] = [\"pass\"]"
    },
    {
        "line": 28,
        "fullcodeline": "clampers.append(copier)"
    },
    {
        "line": 36,
        "fullcodeline": "default_args_start_pos = len(sig.base_args)"
    },
    {
        "line": 17,
        "fullcodeline": "nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)"
    },
    {
        "line": 23,
        "fullcodeline": "if not len(sig.base_args):"
    },
    {
        "line": 30,
        "fullcodeline": "if check_nonpayable and sig.mutability != \"payable\":"
    },
    {
        "line": 37,
        "fullcodeline": "for i, arg in enumerate(sig.args):"
    },
    {
        "line": 68,
        "fullcodeline": "if sig.name == \"__init__\":"
    },
    {
        "line": 24,
        "fullcodeline": "copier = [\"pass\"]"
    },
    {
        "line": 33,
        "fullcodeline": "clampers.append([\"assert\", [\"iszero\", \"callvalue\"]])"
    },
    {
        "line": 69,
        "fullcodeline": "o = LLLnode.from_list("
    },
    {
        "line": 25,
        "fullcodeline": "elif sig.name == \"__init__\":"
    },
    {
        "line": 74,
        "fullcodeline": "elif sig.is_default_func():"
    },
    {
        "line": 26,
        "fullcodeline": "copier = [\"codecopy\", MemoryPositions.RESERVED_MEMORY, \"~codelen\", sig.base_copy_size]"
    },
    {
        "line": 38,
        "fullcodeline": "if i < len(sig.base_args):"
    },
    {
        "line": 47,
        "fullcodeline": "if isinstance(arg.typ, ByteArrayLike):"
    },
    {
        "line": 70,
        "fullcodeline": "[\"seq\"] + clampers + [parse_body(code.body, context)],  # type: ignore"
    },
    {
        "line": 71,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 75,
        "fullcodeline": "o = LLLnode.from_list("
    },
    {
        "line": 27,
        "fullcodeline": "context.memory_allocator.expand_memory(sig.max_copy_size)"
    },
    {
        "line": 39,
        "fullcodeline": "clampers.append("
    },
    {
        "line": 48,
        "fullcodeline": "mem_pos = context.memory_allocator.expand_memory(32 * get_size_of_type(arg.typ))"
    },
    {
        "line": 49,
        "fullcodeline": "context.vars[arg.name] = VariableRecord(arg.name, mem_pos, arg.typ, False)"
    },
    {
        "line": 82,
        "fullcodeline": "if sig.total_default_args > 0:"
    },
    {
        "line": 40,
        "fullcodeline": "make_arg_clamper("
    },
    {
        "line": 51,
        "fullcodeline": "if sig.name == \"__init__\":"
    },
    {
        "line": 76,
        "fullcodeline": "[\"seq\"] + clampers + [parse_body(code.body, context)] + [[\"stop\"]],  # type: ignore"
    },
    {
        "line": 77,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 83,
        "fullcodeline": "function_routine = f\"{sig.name}_{sig.method_id}\""
    },
    {
        "line": 84,
        "fullcodeline": "default_sigs = sig_utils.generate_default_arg_sigs("
    },
    {
        "line": 87,
        "fullcodeline": "sig_chain: List[Any] = [\"seq\"]"
    },
    {
        "line": 163,
        "fullcodeline": "function_jump_label = f\"{sig.name}_{sig.method_id}_skip\""
    },
    {
        "line": 164,
        "fullcodeline": "o = LLLnode.from_list("
    },
    {
        "line": 188,
        "fullcodeline": "o = LLLnode.from_list("
    },
    {
        "line": 44,
        "fullcodeline": "sig.name == \"__init__\","
    },
    {
        "line": 52,
        "fullcodeline": "context.vars[arg.name] = VariableRecord("
    },
    {
        "line": 89,
        "fullcodeline": "for default_sig in default_sigs:"
    },
    {
        "line": 187,
        "fullcodeline": "sig_compare, _ = get_sig_statements(sig, getpos(code))"
    },
    {
        "line": 42,
        "fullcodeline": "context.memory_allocator.get_next_memory_position(),"
    },
    {
        "line": 55,
        "fullcodeline": "elif i >= default_args_start_pos:  # default args need to be allocated in memory."
    },
    {
        "line": 165,
        "fullcodeline": "["
    },
    {
        "line": 182,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 189,
        "fullcodeline": "["
    },
    {
        "line": 200,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 53,
        "fullcodeline": "arg.name, MemoryPositions.RESERVED_MEMORY + arg.pos, arg.typ, False,"
    },
    {
        "line": 56,
        "fullcodeline": "type_size = get_size_of_type(arg.typ) * 32"
    },
    {
        "line": 57,
        "fullcodeline": "default_arg_pos = context.memory_allocator.expand_memory(type_size)"
    },
    {
        "line": 58,
        "fullcodeline": "context.vars[arg.name] = VariableRecord("
    },
    {
        "line": 62,
        "fullcodeline": "context.vars[arg.name] = VariableRecord("
    },
    {
        "line": 93,
        "fullcodeline": "set_defaults = []"
    },
    {
        "line": 106,
        "fullcodeline": "current_sig_arg_names = {x.name for x in default_sig.args}"
    },
    {
        "line": 107,
        "fullcodeline": "base_arg_names = {arg.name for arg in sig.base_args}"
    },
    {
        "line": 108,
        "fullcodeline": "copier_arg_count = len(default_sig.args) - len(sig.base_args)"
    },
    {
        "line": 109,
        "fullcodeline": "copier_arg_names = list(current_sig_arg_names - base_arg_names)"
    },
    {
        "line": 112,
        "fullcodeline": "copier_arg_names = [x.name for x in default_sig.args if x.name in copier_arg_names]"
    },
    {
        "line": 115,
        "fullcodeline": "default_copiers: List[Any] = []"
    },
    {
        "line": 149,
        "fullcodeline": "sig_chain.append("
    },
    {
        "line": 168,
        "fullcodeline": "["
    },
    {
        "line": 192,
        "fullcodeline": "[\"seq\"]"
    },
    {
        "line": 90,
        "fullcodeline": "sig_compare, _ = get_sig_statements(default_sig, getpos(code))"
    },
    {
        "line": 94,
        "fullcodeline": "for arg_name in get_default_names_to_set(sig, default_sig):"
    },
    {
        "line": 116,
        "fullcodeline": "if copier_arg_count > 0:"
    },
    {
        "line": 150,
        "fullcodeline": "["
    },
    {
        "line": 170,
        "fullcodeline": "[\"goto\", function_jump_label],"
    },
    {
        "line": 171,
        "fullcodeline": "[\"label\", function_routine],"
    },
    {
        "line": 172,
        "fullcodeline": "[\"seq\"]"
    },
    {
        "line": 178,
        "fullcodeline": "[\"label\", function_jump_label],"
    },
    {
        "line": 197,
        "fullcodeline": "+ [[\"stop\"]],"
    },
    {
        "line": 63,
        "fullcodeline": "name=arg.name, pos=4 + arg.pos, typ=arg.typ, mutable=False, location=\"calldata\""
    },
    {
        "line": 118,
        "fullcodeline": "offset = 4"
    },
    {
        "line": 119,
        "fullcodeline": "calldata_offset_map = {}"
    },
    {
        "line": 147,
        "fullcodeline": "default_copiers.append(0)  # for over arching seq, POP"
    },
    {
        "line": 153,
        "fullcodeline": "["
    },
    {
        "line": 177,
        "fullcodeline": "+ [[\"stop\"]],"
    },
    {
        "line": 97,
        "fullcodeline": "left = LLLnode.from_list("
    },
    {
        "line": 104,
        "fullcodeline": "set_defaults.append(make_setter(left, value, \"memory\", pos=getpos(code)))"
    },
    {
        "line": 120,
        "fullcodeline": "for arg in default_sig.args:"
    },
    {
        "line": 129,
        "fullcodeline": "for arg_name in copier_arg_names:"
    },
    {
        "line": 155,
        "fullcodeline": "[\"seq\"] + set_defaults if set_defaults else [\"pass\"],"
    },
    {
        "line": 156,
        "fullcodeline": "[\"seq_unchecked\"] + default_copiers if default_copiers else [\"pass\"],"
    },
    {
        "line": 157,
        "fullcodeline": "[\"goto\", function_routine],"
    },
    {
        "line": 195,
        "fullcodeline": "+ [parse_body(c, context) for c in code.body]"
    },
    {
        "line": 95,
        "fullcodeline": "value = Expr(sig.default_values[arg_name], context).lll_node"
    },
    {
        "line": 101,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 121,
        "fullcodeline": "calldata_offset_map[arg.name] = offset"
    },
    {
        "line": 122,
        "fullcodeline": "offset += ("
    },
    {
        "line": 131,
        "fullcodeline": "calldata_offset = calldata_offset_map[arg_name]"
    },
    {
        "line": 134,
        "fullcodeline": "default_copiers.append("
    },
    {
        "line": 138,
        "fullcodeline": "_offset: Union[int, List[Any]] = calldata_offset"
    },
    {
        "line": 141,
        "fullcodeline": "default_copiers.append("
    },
    {
        "line": 175,
        "fullcodeline": "+ [parse_body(c, context) for c in code.body]"
    },
    {
        "line": 123,
        "fullcodeline": "32"
    },
    {
        "line": 135,
        "fullcodeline": "make_arg_clamper(calldata_offset - 4, var.pos, var.typ,)"
    },
    {
        "line": 139,
        "fullcodeline": "if isinstance(var.typ, ByteArrayLike):"
    },
    {
        "line": 142,
        "fullcodeline": "get_external_arg_copier("
    },
    {
        "line": 124,
        "fullcodeline": "if isinstance(arg.typ, ByteArrayLike)"
    },
    {
        "line": 125,
        "fullcodeline": "else get_size_of_type(arg.typ) * 32"
    },
    {
        "line": 140,
        "fullcodeline": "_offset = [\"add\", 4, [\"calldataload\", calldata_offset]]"
    },
    {
        "line": 143,
        "fullcodeline": "memory_dest=var.pos, total_size=var.size * 32, offset=_offset,"
    }
]