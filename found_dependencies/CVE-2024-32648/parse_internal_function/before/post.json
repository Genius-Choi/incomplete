[
    {
        "line": 19,
        "fullcodeline": "clampers: List[LLLnode] = []"
    },
    {
        "line": 24,
        "fullcodeline": "_post_callback_ptr = f\"{sig.name}_{sig.method_id}_post_callback_ptr\""
    },
    {
        "line": 25,
        "fullcodeline": "context.callback_ptr = context.new_internal_variable(typ=BaseType(\"uint256\"))"
    },
    {
        "line": 26,
        "fullcodeline": "clampers.append("
    },
    {
        "line": 63,
        "fullcodeline": "dyn_variable_names = [a.name for a in sig.base_args if isinstance(a.typ, ByteArrayLike)]"
    },
    {
        "line": 15,
        "fullcodeline": "nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)"
    },
    {
        "line": 22,
        "fullcodeline": "context.memory_allocator.expand_memory(sig.max_copy_size)"
    },
    {
        "line": 27,
        "fullcodeline": "LLLnode.from_list("
    },
    {
        "line": 31,
        "fullcodeline": "if sig.total_default_args > 0:"
    },
    {
        "line": 37,
        "fullcodeline": "if sig.output_type is None:"
    },
    {
        "line": 43,
        "fullcodeline": "if len(sig.base_args) == 0:"
    },
    {
        "line": 53,
        "fullcodeline": "for arg in sig.args:"
    },
    {
        "line": 88,
        "fullcodeline": "if sig.total_default_args > 0:  # Function with default parameters."
    },
    {
        "line": 28,
        "fullcodeline": "[\"mstore\", context.callback_ptr, \"pass\"], annotation=\"pop callback pointer\","
    },
    {
        "line": 32,
        "fullcodeline": "clampers.append(LLLnode.from_list([\"label\", _post_callback_ptr]))"
    },
    {
        "line": 38,
        "fullcodeline": "stop_func = [[\"jump\", [\"mload\", context.callback_ptr]]]"
    },
    {
        "line": 40,
        "fullcodeline": "stop_func = [[\"stop\"]]"
    },
    {
        "line": 44,
        "fullcodeline": "copier = [\"pass\"]"
    },
    {
        "line": 45,
        "fullcodeline": "clampers.append(LLLnode.from_list(copier))"
    },
    {
        "line": 65,
        "fullcodeline": "i_placeholder = context.new_internal_variable(typ=BaseType(\"uint256\"))"
    },
    {
        "line": 66,
        "fullcodeline": "unpackers: List[Any] = []"
    },
    {
        "line": 77,
        "fullcodeline": "unpackers.append(0)"
    },
    {
        "line": 78,
        "fullcodeline": "clampers.append("
    },
    {
        "line": 90,
        "fullcodeline": "default_sigs = sig_utils.generate_default_arg_sigs(code, context.sigs, context.global_ctx)"
    },
    {
        "line": 91,
        "fullcodeline": "sig_chain: List[Any] = [\"seq\"]"
    },
    {
        "line": 173,
        "fullcodeline": "_clampers = [[\"label\", _post_callback_ptr]]"
    },
    {
        "line": 46,
        "fullcodeline": "elif sig.total_default_args == 0:"
    },
    {
        "line": 67,
        "fullcodeline": "for idx, var_name in enumerate(dyn_variable_names):"
    },
    {
        "line": 73,
        "fullcodeline": "if not unpackers:"
    },
    {
        "line": 79,
        "fullcodeline": "LLLnode.from_list("
    },
    {
        "line": 93,
        "fullcodeline": "for default_sig in default_sigs:"
    },
    {
        "line": 176,
        "fullcodeline": "return LLLnode.from_list("
    },
    {
        "line": 193,
        "fullcodeline": "sig_compare, internal_label = get_sig_statements(sig, getpos(code))"
    },
    {
        "line": 194,
        "fullcodeline": "return LLLnode.from_list("
    },
    {
        "line": 47,
        "fullcodeline": "copier = get_internal_arg_copier("
    },
    {
        "line": 50,
        "fullcodeline": "clampers.append(LLLnode.from_list(copier))"
    },
    {
        "line": 54,
        "fullcodeline": "if isinstance(arg.typ, ByteArrayLike):"
    },
    {
        "line": 74,
        "fullcodeline": "unpackers = [\"pass\"]"
    },
    {
        "line": 80,
        "fullcodeline": "[\"seq_unchecked\"] + unpackers,"
    },
    {
        "line": 83,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 177,
        "fullcodeline": "["
    },
    {
        "line": 188,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 195,
        "fullcodeline": "[\"seq\"]"
    },
    {
        "line": 203,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 55,
        "fullcodeline": "mem_pos = context.memory_allocator.expand_memory(32 * get_size_of_type(arg.typ))"
    },
    {
        "line": 56,
        "fullcodeline": "context.vars[arg.name] = VariableRecord(arg.name, mem_pos, arg.typ, False)"
    },
    {
        "line": 58,
        "fullcodeline": "context.vars[arg.name] = VariableRecord("
    },
    {
        "line": 69,
        "fullcodeline": "ident = f\"_load_args_{sig.method_id}_dynarg{idx}\""
    },
    {
        "line": 70,
        "fullcodeline": "o = make_unpacker(ident=ident, i_placeholder=i_placeholder, begin_pos=var.pos)"
    },
    {
        "line": 71,
        "fullcodeline": "unpackers.append(o)"
    },
    {
        "line": 97,
        "fullcodeline": "set_defaults = []"
    },
    {
        "line": 105,
        "fullcodeline": "current_sig_arg_names = [x.name for x in default_sig.args]"
    },
    {
        "line": 109,
        "fullcodeline": "copier_arg_count = len(default_sig.args)"
    },
    {
        "line": 110,
        "fullcodeline": "copier_arg_names = current_sig_arg_names"
    },
    {
        "line": 113,
        "fullcodeline": "copier_arg_names = [x.name for x in default_sig.args if x.name in copier_arg_names]"
    },
    {
        "line": 116,
        "fullcodeline": "default_copiers: List[Any] = []"
    },
    {
        "line": 152,
        "fullcodeline": "sig_chain.append("
    },
    {
        "line": 180,
        "fullcodeline": "[\"seq\"]"
    },
    {
        "line": 94,
        "fullcodeline": "sig_compare, internal_label = get_sig_statements(default_sig, getpos(code))"
    },
    {
        "line": 98,
        "fullcodeline": "for arg_name in get_default_names_to_set(sig, default_sig):"
    },
    {
        "line": 117,
        "fullcodeline": "if copier_arg_count > 0:"
    },
    {
        "line": 153,
        "fullcodeline": "["
    },
    {
        "line": 59,
        "fullcodeline": "arg.name, MemoryPositions.RESERVED_MEMORY + arg.pos, arg.typ, False,"
    },
    {
        "line": 119,
        "fullcodeline": "offset = 4"
    },
    {
        "line": 120,
        "fullcodeline": "calldata_offset_map = {}"
    },
    {
        "line": 128,
        "fullcodeline": "dynamics = []"
    },
    {
        "line": 150,
        "fullcodeline": "default_copiers.append(0)  # for over arching seq, POP"
    },
    {
        "line": 156,
        "fullcodeline": "["
    },
    {
        "line": 101,
        "fullcodeline": "left = LLLnode.from_list("
    },
    {
        "line": 104,
        "fullcodeline": "set_defaults.append(make_setter(left, value, \"memory\", pos=getpos(code)))"
    },
    {
        "line": 121,
        "fullcodeline": "for arg in default_sig.args:"
    },
    {
        "line": 129,
        "fullcodeline": "for arg_name in copier_arg_names:"
    },
    {
        "line": 159,
        "fullcodeline": "LLLnode.from_list("
    },
    {
        "line": 164,
        "fullcodeline": "[\"seq\"] + set_defaults if set_defaults else [\"pass\"],"
    },
    {
        "line": 165,
        "fullcodeline": "[\"seq_unchecked\"] + default_copiers if default_copiers else [\"pass\"],"
    },
    {
        "line": 166,
        "fullcodeline": "[\"goto\", _post_callback_ptr],"
    },
    {
        "line": 199,
        "fullcodeline": "+ [parse_body(c, context) for c in code.body]"
    },
    {
        "line": 142,
        "fullcodeline": "i_placeholder = context.new_internal_variable(typ=BaseType(\"uint256\"))"
    },
    {
        "line": 160,
        "fullcodeline": "[\"mstore\", context.callback_ptr, \"pass\"],"
    },
    {
        "line": 162,
        "fullcodeline": "pos=getpos(code),"
    },
    {
        "line": 183,
        "fullcodeline": "+ [parse_body(c, context) for c in code.body]"
    },
    {
        "line": 99,
        "fullcodeline": "value = Expr(sig.default_values[arg_name], context).lll_node"
    },
    {
        "line": 102,
        "fullcodeline": "var.pos, typ=var.typ, location=\"memory\", pos=getpos(code), mutable=var.mutable"
    },
    {
        "line": 122,
        "fullcodeline": "calldata_offset_map[arg.name] = offset"
    },
    {
        "line": 123,
        "fullcodeline": "offset += ("
    },
    {
        "line": 136,
        "fullcodeline": "default_copiers.append("
    },
    {
        "line": 143,
        "fullcodeline": "for idx, var_pos in enumerate(dynamics):"
    },
    {
        "line": 196,
        "fullcodeline": "+ [internal_label]"
    },
    {
        "line": 124,
        "fullcodeline": "32 if isinstance(arg.typ, ByteArrayLike) else get_size_of_type(arg.typ) * 32"
    },
    {
        "line": 131,
        "fullcodeline": "if isinstance(var.typ, ByteArrayLike):"
    },
    {
        "line": 137,
        "fullcodeline": "get_internal_arg_copier(memory_dest=var.pos, total_size=_size,)"
    },
    {
        "line": 132,
        "fullcodeline": "_size = 32"
    },
    {
        "line": 133,
        "fullcodeline": "dynamics.append(var.pos)"
    },
    {
        "line": 135,
        "fullcodeline": "_size = var.size * 32"
    },
    {
        "line": 144,
        "fullcodeline": "ident = f\"unpack_default_sig_dyn_{default_sig.method_id}_arg{idx}\""
    },
    {
        "line": 145,
        "fullcodeline": "default_copiers.append("
    },
    {
        "line": 146,
        "fullcodeline": "make_unpacker("
    }
]