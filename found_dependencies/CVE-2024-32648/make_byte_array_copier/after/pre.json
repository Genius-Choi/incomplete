[
    {
        "line": 58,
        "fullcodeline": "max_length = 32 if source.value is None else source.typ.maxlen + 32"
    },
    {
        "line": 2,
        "fullcodeline": "if not isinstance(source.typ, ByteArrayLike):"
    },
    {
        "line": 4,
        "fullcodeline": "if isinstance(source.typ, ByteArrayLike) and source.typ.maxlen > destination.typ.maxlen:"
    },
    {
        "line": 11,
        "fullcodeline": "if isinstance(source.typ, ByteArrayLike):"
    },
    {
        "line": 19,
        "fullcodeline": "if destination.location == \"memory\" and source.location in (\"memory\", \"code\", \"calldata\"):"
    },
    {
        "line": 39,
        "fullcodeline": "if source.value is None:"
    },
    {
        "line": 44,
        "fullcodeline": "if source.value is None:"
    },
    {
        "line": 53,
        "fullcodeline": "if destination.location == \"storage\":"
    },
    {
        "line": 59,
        "fullcodeline": "return LLLnode.from_list("
    },
    {
        "line": 3,
        "fullcodeline": "raise TypeMismatch(f\"Cannot cast from {source.typ} to {destination.typ}\", pos)"
    },
    {
        "line": 5,
        "fullcodeline": "raise TypeMismatch("
    },
    {
        "line": 30,
        "fullcodeline": "_sz_lll = [\"add\", 32, [load_op(source.location), \"src\"]]"
    },
    {
        "line": 31,
        "fullcodeline": "o = LLLnode.from_list("
    },
    {
        "line": 40,
        "fullcodeline": "pos_node = source"
    },
    {
        "line": 42,
        "fullcodeline": "pos_node = LLLnode.from_list(\"_pos\", typ=source.typ, location=source.location)"
    },
    {
        "line": 45,
        "fullcodeline": "length = 1"
    },
    {
        "line": 54,
        "fullcodeline": "destination = LLLnode.from_list("
    },
    {
        "line": 60,
        "fullcodeline": "["
    },
    {
        "line": 12,
        "fullcodeline": "if source.value is None and source.typ.maxlen != destination.typ.maxlen:"
    },
    {
        "line": 20,
        "fullcodeline": "if source.location == \"memory\":"
    },
    {
        "line": 46,
        "fullcodeline": "elif source.location in (\"memory\", \"code\", \"calldata\"):"
    },
    {
        "line": 64,
        "fullcodeline": "make_byte_slice_copier(destination, pos_node, length, max_length, pos=pos),"
    },
    {
        "line": 6,
        "fullcodeline": "f\"Cannot cast from greater max-length {source.typ.maxlen} to shorter \""
    },
    {
        "line": 13,
        "fullcodeline": "raise TypeMismatch("
    },
    {
        "line": 22,
        "fullcodeline": "copy_op = [\"assert\", [\"call\", [\"gas\"], 4, 0, \"src\", \"sz\", destination, \"sz\"]]"
    },
    {
        "line": 23,
        "fullcodeline": "gas_bound = _identity_gas_bound(source.typ.maxlen)"
    },
    {
        "line": 32,
        "fullcodeline": "[\"with\", \"src\", source, [\"with\", \"sz\", _sz_lll, copy_op]],"
    },
    {
        "line": 47,
        "fullcodeline": "length = [\"add\", [load_op(source.location), \"_pos\"], 32]"
    },
    {
        "line": 63,
        "fullcodeline": "0 if source.value is None else source,"
    },
    {
        "line": 7,
        "fullcodeline": "f\"max-length {destination.typ.maxlen}\""
    },
    {
        "line": 24,
        "fullcodeline": "elif source.location == \"calldata\":"
    },
    {
        "line": 48,
        "fullcodeline": "elif source.location == \"storage\":"
    },
    {
        "line": 14,
        "fullcodeline": "f\"Bad type for clearing bytes: expected {destination.typ}\" f\" but got {source.typ}\""
    },
    {
        "line": 25,
        "fullcodeline": "copy_op = [\"calldatacopy\", destination, \"src\", \"sz\"]"
    },
    {
        "line": 26,
        "fullcodeline": "gas_bound = _calldatacopy_gas_bound(source.typ.maxlen)"
    },
    {
        "line": 49,
        "fullcodeline": "length = [\"add\", [\"sload\", \"_pos\"], 32]"
    },
    {
        "line": 50,
        "fullcodeline": "pos_node = LLLnode.from_list(pos_node, typ=source.typ, location=source.location,)"
    },
    {
        "line": 27,
        "fullcodeline": "elif source.location == \"code\":"
    },
    {
        "line": 52,
        "fullcodeline": "raise CompilerPanic(f\"Unsupported location: {source.location} to {destination.location}\")"
    },
    {
        "line": 28,
        "fullcodeline": "copy_op = [\"codecopy\", destination, \"src\", \"sz\"]"
    },
    {
        "line": 29,
        "fullcodeline": "gas_bound = _codecopy_gas_bound(source.typ.maxlen)"
    }
]