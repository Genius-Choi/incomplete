[
    {
        "line": 57,
        "fullcodeline": "max_length = 32 if source.value is None else source.typ.maxlen + 32"
    },
    {
        "line": 2,
        "fullcodeline": "if not isinstance(source.typ, ByteArrayLike):"
    },
    {
        "line": 5,
        "fullcodeline": "if isinstance(source.typ, ByteArrayLike) and source.typ.maxlen > destination.typ.maxlen:"
    },
    {
        "line": 12,
        "fullcodeline": "if isinstance(source.typ, ByteArrayLike):"
    },
    {
        "line": 19,
        "fullcodeline": "if source.location == \"memory\" and destination.location == \"memory\":"
    },
    {
        "line": 38,
        "fullcodeline": "if source.value is None:"
    },
    {
        "line": 43,
        "fullcodeline": "if source.value is None:"
    },
    {
        "line": 52,
        "fullcodeline": "if destination.location == \"storage\":"
    },
    {
        "line": 58,
        "fullcodeline": "return LLLnode.from_list("
    },
    {
        "line": 3,
        "fullcodeline": "btype = \"byte array\" if isinstance(destination.typ, ByteArrayType) else \"string\""
    },
    {
        "line": 4,
        "fullcodeline": "raise TypeMismatch(f\"Can only set a {btype} to another {btype}\", pos)"
    },
    {
        "line": 6,
        "fullcodeline": "raise TypeMismatch("
    },
    {
        "line": 20,
        "fullcodeline": "o = LLLnode.from_list("
    },
    {
        "line": 39,
        "fullcodeline": "pos_node = source"
    },
    {
        "line": 41,
        "fullcodeline": "pos_node = LLLnode.from_list(\"_pos\", typ=source.typ, location=source.location)"
    },
    {
        "line": 44,
        "fullcodeline": "length = 1"
    },
    {
        "line": 53,
        "fullcodeline": "destination = LLLnode.from_list("
    },
    {
        "line": 59,
        "fullcodeline": "["
    },
    {
        "line": 13,
        "fullcodeline": "if source.value is None and source.typ.maxlen != destination.typ.maxlen:"
    },
    {
        "line": 45,
        "fullcodeline": "elif source.location == \"memory\":"
    },
    {
        "line": 63,
        "fullcodeline": "make_byte_slice_copier(destination, pos_node, length, max_length, pos=pos),"
    },
    {
        "line": 7,
        "fullcodeline": "f\"Cannot cast from greater max-length {source.typ.maxlen} to shorter \""
    },
    {
        "line": 14,
        "fullcodeline": "raise TypeMismatch("
    },
    {
        "line": 21,
        "fullcodeline": "["
    },
    {
        "line": 33,
        "fullcodeline": "add_gas_estimate=_identity_gas_bound(source.typ.maxlen),"
    },
    {
        "line": 46,
        "fullcodeline": "length = [\"add\", [\"mload\", \"_pos\"], 32]"
    },
    {
        "line": 62,
        "fullcodeline": "0 if source.value is None else source,"
    },
    {
        "line": 8,
        "fullcodeline": "f\"max-length {destination.typ.maxlen}\""
    },
    {
        "line": 25,
        "fullcodeline": "["
    },
    {
        "line": 47,
        "fullcodeline": "elif source.location == \"storage\":"
    },
    {
        "line": 15,
        "fullcodeline": "f\"Bad type for clearing bytes: expected {destination.typ}\" f\" but got {source.typ}\""
    },
    {
        "line": 28,
        "fullcodeline": "[\"add\", 32, [\"mload\", \"_source\"]],"
    },
    {
        "line": 29,
        "fullcodeline": "[\"assert\", [\"call\", [\"gas\"], 4, 0, \"_source\", \"_sz\", destination, \"_sz\"]],"
    },
    {
        "line": 48,
        "fullcodeline": "length = [\"add\", [\"sload\", \"_pos\"], 32]"
    },
    {
        "line": 49,
        "fullcodeline": "pos_node = LLLnode.from_list(pos_node, typ=source.typ, location=source.location,)"
    },
    {
        "line": 51,
        "fullcodeline": "raise CompilerPanic(f\"Unsupported location: {source.location}\")"
    }
]