[
    {
        "line": 3,
        "fullcodeline": "struct mesh_state* mstate = (struct mesh_state*) arg;"
    },
    {
        "line": 4,
        "fullcodeline": "struct module_qstate* qstate = &mstate->s;"
    },
    {
        "line": 9,
        "fullcodeline": "struct mesh_reply* prev = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "struct sldns_buffer* prev_buffer = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "struct sldns_buffer* r_buffer = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "struct reply_info* partial_rep = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "struct ub_packed_rrset_key* alias_rrset = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "struct reply_info* encode_rep = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "struct query_info* lookup_qinfo = &qstate->qinfo;"
    },
    {
        "line": 18,
        "fullcodeline": "struct timeval tv = {0, 0};"
    },
    {
        "line": 19,
        "fullcodeline": "int must_validate = (!(qstate->query_flags&BIT_CD)"
    },
    {
        "line": 21,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "verbose(VERB_ALGO, \"Serve expired: Trying to reply with expired data\");"
    },
    {
        "line": 25,
        "fullcodeline": "qstate->serve_expired_data->timer = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "if(!qstate->serve_expired_data) return;"
    },
    {
        "line": 28,
        "fullcodeline": "if(qstate->no_cache_lookup || qstate->is_drop) {"
    },
    {
        "line": 89,
        "fullcodeline": "if(verbosity >= VERB_ALGO)"
    },
    {
        "line": 92,
        "fullcodeline": "for(r = mstate->reply_list; r; r = r->next) {"
    },
    {
        "line": 148,
        "fullcodeline": "if(i > 0) {"
    },
    {
        "line": 174,
        "fullcodeline": "while((c = mstate->cb_list) != NULL) {"
    },
    {
        "line": 29,
        "fullcodeline": "verbose(VERB_ALGO,"
    },
    {
        "line": 36,
        "fullcodeline": "fptr_ok(fptr_whitelist_serve_expired_lookup("
    },
    {
        "line": 38,
        "fullcodeline": "msg = (*qstate->serve_expired_data->get_cached_answer)(qstate,"
    },
    {
        "line": 43,
        "fullcodeline": "encode_rep = msg->rep;"
    },
    {
        "line": 44,
        "fullcodeline": "memset(&actinfo, 0, sizeof(actinfo));"
    },
    {
        "line": 45,
        "fullcodeline": "actinfo.action = respip_none;"
    },
    {
        "line": 46,
        "fullcodeline": "alias_rrset = NULL;"
    },
    {
        "line": 90,
        "fullcodeline": "log_dns_msg(\"Serve expired lookup\", &qstate->qinfo, msg->rep);"
    },
    {
        "line": 94,
        "fullcodeline": "timeval_subtract(&old, mstate->s.env->now_tv, &r->start_time);"
    },
    {
        "line": 115,
        "fullcodeline": "i++;"
    },
    {
        "line": 116,
        "fullcodeline": "tv = r->start_time;"
    },
    {
        "line": 138,
        "fullcodeline": "mesh_send_reply(mstate, LDNS_RCODE_NOERROR, msg->rep,"
    },
    {
        "line": 142,
        "fullcodeline": "infra_wait_limit_dec(mstate->s.env->infra_cache,"
    },
    {
        "line": 144,
        "fullcodeline": "prev = r;"
    },
    {
        "line": 145,
        "fullcodeline": "prev_buffer = r_buffer;"
    },
    {
        "line": 149,
        "fullcodeline": "mesh->ans_expired += i;"
    },
    {
        "line": 164,
        "fullcodeline": "mstate->reply_list = NULL;"
    },
    {
        "line": 182,
        "fullcodeline": "mstate->cb_list = c->next;"
    },
    {
        "line": 186,
        "fullcodeline": "mesh_do_callback(mstate, LDNS_RCODE_NOERROR, msg->rep, c, &tv);"
    },
    {
        "line": 40,
        "fullcodeline": "if(!msg)"
    },
    {
        "line": 47,
        "fullcodeline": "if((mesh->use_response_ip || mesh->use_rpz) &&"
    },
    {
        "line": 58,
        "fullcodeline": "if(!encode_rep || alias_rrset) {"
    },
    {
        "line": 95,
        "fullcodeline": "if(mstate->s.env->cfg->discard_timeout != 0 &&"
    },
    {
        "line": 129,
        "fullcodeline": "if (r->edns.edns_present && qstate->env->cfg->ede_serve_expired &&"
    },
    {
        "line": 150,
        "fullcodeline": "if(actinfo.addrinfo && qstate->env->cfg->stat_extended &&"
    },
    {
        "line": 165,
        "fullcodeline": "if(!mstate->reply_list && !mstate->cb_list) {"
    },
    {
        "line": 177,
        "fullcodeline": "if(!mstate->reply_list && mstate->cb_list && !c->next) {"
    },
    {
        "line": 183,
        "fullcodeline": "if(!mstate->reply_list && !mstate->cb_list &&"
    },
    {
        "line": 48,
        "fullcodeline": "!partial_rep && !apply_respip_action(qstate, &qstate->qinfo,"
    },
    {
        "line": 74,
        "fullcodeline": "memset(&qinfo_tmp, 0, sizeof(qinfo_tmp));"
    },
    {
        "line": 75,
        "fullcodeline": "get_cname_target(alias_rrset, &qinfo_tmp.qname,"
    },
    {
        "line": 83,
        "fullcodeline": "lookup_qinfo = &qinfo_tmp;"
    },
    {
        "line": 96,
        "fullcodeline": "((int)old.tv_sec)*1000+((int)old.tv_usec)/1000 >"
    },
    {
        "line": 104,
        "fullcodeline": "struct mesh_reply* reply_list = mstate->reply_list;"
    },
    {
        "line": 105,
        "fullcodeline": "verbose(VERB_ALGO, \"drop reply, it is older than discard-timeout\");"
    },
    {
        "line": 106,
        "fullcodeline": "infra_wait_limit_dec(mstate->s.env->infra_cache,"
    },
    {
        "line": 108,
        "fullcodeline": "mstate->reply_list = NULL;"
    },
    {
        "line": 109,
        "fullcodeline": "comm_point_drop_reply(&r->query_reply);"
    },
    {
        "line": 110,
        "fullcodeline": "mstate->reply_list = reply_list;"
    },
    {
        "line": 121,
        "fullcodeline": "respip_inform_print(&actinfo, r->qname,"
    },
    {
        "line": 131,
        "fullcodeline": "edns_opt_list_append_ede(&r->edns.opt_list_out,"
    },
    {
        "line": 141,
        "fullcodeline": "tcp_req_info_remove_mesh_state(r->query_reply.c->tcp_req_info, mstate);"
    },
    {
        "line": 166,
        "fullcodeline": "log_assert(mesh->num_reply_states > 0);"
    },
    {
        "line": 167,
        "fullcodeline": "mesh->num_reply_states--;"
    },
    {
        "line": 179,
        "fullcodeline": "log_assert(qstate->env->mesh->num_reply_states > 0);"
    },
    {
        "line": 180,
        "fullcodeline": "qstate->env->mesh->num_reply_states--;"
    },
    {
        "line": 184,
        "fullcodeline": "mstate->super_set.count == 0)"
    },
    {
        "line": 59,
        "fullcodeline": "if(!encode_rep) {"
    },
    {
        "line": 77,
        "fullcodeline": "if(!qinfo_tmp.qname) {"
    },
    {
        "line": 168,
        "fullcodeline": "if(mstate->super_set.count == 0) {"
    },
    {
        "line": 52,
        "fullcodeline": "} else if(partial_rep &&"
    },
    {
        "line": 78,
        "fullcodeline": "log_err(\"Serve expired: unexpected: invalid answer alias\");"
    },
    {
        "line": 153,
        "fullcodeline": "qstate->env->mesh->rpz_action[RPZ_DISABLED_ACTION] += i;"
    },
    {
        "line": 155,
        "fullcodeline": "qstate->env->mesh->rpz_action[RPZ_CNAME_OVERRIDE_ACTION] += i;"
    },
    {
        "line": 169,
        "fullcodeline": "mesh->num_detached_states++;"
    },
    {
        "line": 53,
        "fullcodeline": "!respip_merge_cname(partial_rep, &qstate->qinfo, msg->rep,"
    },
    {
        "line": 64,
        "fullcodeline": "partial_rep = encode_rep;"
    },
    {
        "line": 157,
        "fullcodeline": "qstate->env->mesh->rpz_action["
    },
    {
        "line": 158,
        "fullcodeline": "respip_action_to_rpz_action(actinfo.action)] += i;"
    }
]