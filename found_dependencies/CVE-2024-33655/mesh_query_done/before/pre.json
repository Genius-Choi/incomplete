[
    {
        "line": 4,
        "fullcodeline": "struct mesh_reply* prev = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "struct sldns_buffer* prev_buffer = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "struct reply_info* rep = (mstate->s.return_msg?"
    },
    {
        "line": 9,
        "fullcodeline": "struct timeval tv = {0, 0};"
    },
    {
        "line": 10,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "mstate->replies_sent = 1;"
    },
    {
        "line": 16,
        "fullcodeline": "if(mstate->s.return_rcode == LDNS_RCODE_SERVFAIL ||"
    },
    {
        "line": 27,
        "fullcodeline": "for(r = mstate->reply_list; r; r = r->next) {"
    },
    {
        "line": 71,
        "fullcodeline": "if(i > 0 && mstate->s.respip_action_info &&"
    },
    {
        "line": 83,
        "fullcodeline": "if(!mstate->s.is_drop && i > 0) {"
    },
    {
        "line": 104,
        "fullcodeline": "while((c = mstate->cb_list) != NULL) {"
    },
    {
        "line": 13,
        "fullcodeline": "comm_timer_delete(mstate->s.serve_expired_data->timer);"
    },
    {
        "line": 14,
        "fullcodeline": "mstate->s.serve_expired_data->timer = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "(rep && FLAGS_GET_RCODE(rep->flags) == LDNS_RCODE_SERVFAIL)) {"
    },
    {
        "line": 19,
        "fullcodeline": "mesh_serve_expired_callback(mstate);"
    },
    {
        "line": 28,
        "fullcodeline": "i++;"
    },
    {
        "line": 29,
        "fullcodeline": "tv = r->start_time;"
    },
    {
        "line": 92,
        "fullcodeline": "mstate->reply_list = NULL;"
    },
    {
        "line": 112,
        "fullcodeline": "mstate->cb_list = c->next;"
    },
    {
        "line": 116,
        "fullcodeline": "mesh_do_callback(mstate, mstate->s.return_rcode, rep, c, &tv);"
    },
    {
        "line": 20,
        "fullcodeline": "if((mstate->reply_list || mstate->cb_list)"
    },
    {
        "line": 33,
        "fullcodeline": "if(mstate->s.respip_action_info &&"
    },
    {
        "line": 84,
        "fullcodeline": "if(mstate->s.env->cfg->stat_extended"
    },
    {
        "line": 93,
        "fullcodeline": "if(!mstate->reply_list && !mstate->cb_list) {"
    },
    {
        "line": 98,
        "fullcodeline": "if(!mstate->reply_list && !mstate->cb_list &&"
    },
    {
        "line": 22,
        "fullcodeline": "&& !mstate->s.env->cfg->val_log_squelch) {"
    },
    {
        "line": 23,
        "fullcodeline": "char* err = errinf_to_str_servfail(&mstate->s);"
    },
    {
        "line": 35,
        "fullcodeline": "respip_inform_print(mstate->s.respip_action_info,"
    },
    {
        "line": 50,
        "fullcodeline": "struct mesh_reply* reply_list = mstate->reply_list;"
    },
    {
        "line": 52,
        "fullcodeline": "comm_point_drop_reply(&r->query_reply);"
    },
    {
        "line": 53,
        "fullcodeline": "mstate->reply_list = reply_list;"
    },
    {
        "line": 76,
        "fullcodeline": "mstate->s.env->mesh->rpz_action[RPZ_DISABLED_ACTION] += i;"
    },
    {
        "line": 78,
        "fullcodeline": "mstate->s.env->mesh->rpz_action[RPZ_CNAME_OVERRIDE_ACTION] += i;"
    },
    {
        "line": 86,
        "fullcodeline": "mstate->s.env->mesh->ans_cachedb += i;"
    },
    {
        "line": 95,
        "fullcodeline": "log_assert(mstate->s.env->mesh->num_reply_states > 0);"
    },
    {
        "line": 96,
        "fullcodeline": "mstate->s.env->mesh->num_reply_states--;"
    },
    {
        "line": 99,
        "fullcodeline": "mstate->super_set.count == 0)"
    },
    {
        "line": 100,
        "fullcodeline": "mstate->s.env->mesh->num_detached_states++;"
    },
    {
        "line": 107,
        "fullcodeline": "if(!mstate->reply_list && mstate->cb_list && !c->next) {"
    },
    {
        "line": 110,
        "fullcodeline": "mstate->s.env->mesh->num_reply_states--;"
    },
    {
        "line": 113,
        "fullcodeline": "if(!mstate->reply_list && !mstate->cb_list &&"
    },
    {
        "line": 114,
        "fullcodeline": "mstate->super_set.count == 0)"
    },
    {
        "line": 55,
        "fullcodeline": "struct sldns_buffer* r_buffer = r->query_reply.c->buffer;"
    },
    {
        "line": 60,
        "fullcodeline": "mesh_send_reply(mstate, mstate->s.return_rcode, rep,"
    },
    {
        "line": 66,
        "fullcodeline": "prev = r;"
    },
    {
        "line": 67,
        "fullcodeline": "prev_buffer = r_buffer;"
    },
    {
        "line": 80,
        "fullcodeline": "mstate->s.env->mesh->rpz_action[respip_action_to_rpz_action("
    },
    {
        "line": 109,
        "fullcodeline": "log_assert(mstate->s.env->mesh->num_reply_states > 0);"
    },
    {
        "line": 24,
        "fullcodeline": "if(err) { log_err(\"%s\", err); }"
    },
    {
        "line": 57,
        "fullcodeline": "r_buffer = r->query_reply.c->tcp_req_info->spool_buffer;"
    },
    {
        "line": 58,
        "fullcodeline": "prev_buffer = NULL;"
    },
    {
        "line": 63,
        "fullcodeline": "tcp_req_info_remove_mesh_state(r->query_reply.c->tcp_req_info, mstate);"
    },
    {
        "line": 64,
        "fullcodeline": "r_buffer = NULL;"
    }
]