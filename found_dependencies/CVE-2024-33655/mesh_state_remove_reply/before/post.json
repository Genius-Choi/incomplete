[
    {
        "line": 4,
        "fullcodeline": "struct mesh_reply* n, *prev = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "n = m->reply_list;"
    },
    {
        "line": 8,
        "fullcodeline": "if(!n) return; /* nothing to remove, also no accounting needed */"
    },
    {
        "line": 26,
        "fullcodeline": "if(!m->reply_list && !m->cb_list"
    },
    {
        "line": 31,
        "fullcodeline": "if(!m->reply_list && !m->cb_list) {"
    },
    {
        "line": 22,
        "fullcodeline": "prev = n;"
    },
    {
        "line": 23,
        "fullcodeline": "n = n->next;"
    },
    {
        "line": 27,
        "fullcodeline": "&& m->super_set.count == 0) {"
    },
    {
        "line": 28,
        "fullcodeline": "mesh->num_detached_states++;"
    },
    {
        "line": 32,
        "fullcodeline": "log_assert(mesh->num_reply_states > 0);"
    },
    {
        "line": 33,
        "fullcodeline": "mesh->num_reply_states--;"
    },
    {
        "line": 10,
        "fullcodeline": "if(n->query_reply.c == cp) {"
    },
    {
        "line": 15,
        "fullcodeline": "log_assert(mesh->num_reply_addrs > 0);"
    },
    {
        "line": 16,
        "fullcodeline": "mesh->num_reply_addrs--;"
    },
    {
        "line": 19,
        "fullcodeline": "n = n->next;"
    },
    {
        "line": 12,
        "fullcodeline": "if(prev) prev->next = n->next;"
    },
    {
        "line": 13,
        "fullcodeline": "else m->reply_list = n->next;"
    }
]