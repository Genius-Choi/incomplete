[
    {
        "line": 7,
        "fullcodeline": "mesh = mstate->s.env->mesh;"
    },
    {
        "line": 5,
        "fullcodeline": "if(!mstate)"
    },
    {
        "line": 9,
        "fullcodeline": "if(mstate->s.serve_expired_data && mstate->s.serve_expired_data->timer) {"
    },
    {
        "line": 37,
        "fullcodeline": "for(i=0; i<mesh->mods.num; i++) {"
    },
    {
        "line": 15,
        "fullcodeline": "struct mesh_reply* rep = mstate->reply_list;"
    },
    {
        "line": 39,
        "fullcodeline": "(*mesh->mods.mod[i]->clear)(&mstate->s, i);"
    },
    {
        "line": 41,
        "fullcodeline": "mstate->s.ext_state[i] = module_finished;"
    },
    {
        "line": 21,
        "fullcodeline": "for(; rep; rep=rep->next) {"
    },
    {
        "line": 26,
        "fullcodeline": "while((cb = mstate->cb_list)!=NULL) {"
    },
    {
        "line": 38,
        "fullcodeline": "fptr_ok(fptr_whitelist_mod_clear(mesh->mods.mod[i]->clear));"
    },
    {
        "line": 24,
        "fullcodeline": "mesh->num_reply_addrs--;"
    },
    {
        "line": 27,
        "fullcodeline": "mstate->cb_list = cb->next;"
    },
    {
        "line": 29,
        "fullcodeline": "(*cb->cb)(cb->cb_arg, LDNS_RCODE_SERVFAIL, NULL,"
    },
    {
        "line": 32,
        "fullcodeline": "mesh->num_reply_addrs--;"
    },
    {
        "line": 23,
        "fullcodeline": "log_assert(mesh->num_reply_addrs > 0);"
    },
    {
        "line": 28,
        "fullcodeline": "fptr_ok(fptr_whitelist_mesh_cb(cb->cb));"
    },
    {
        "line": 31,
        "fullcodeline": "log_assert(mesh->num_reply_addrs > 0);"
    }
]