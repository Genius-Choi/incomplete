[
    {
        "line": 12,
        "fullcodeline": "char buf1[GSS_BUFSIZE], buf2[GSS_BUFSIZE];"
    },
    {
        "line": 23,
        "fullcodeline": "snprintf(buf1, sizeof(buf1), \"imap@%s\", idata->conn->account.host);"
    },
    {
        "line": 24,
        "fullcodeline": "request_buf.value = buf1;"
    },
    {
        "line": 25,
        "fullcodeline": "request_buf.length = strlen(buf1);"
    },
    {
        "line": 26,
        "fullcodeline": "maj_stat = gss_import_name(&min_stat, &request_buf, gss_nt_service_name, &target_name);"
    },
    {
        "line": 39,
        "fullcodeline": "sec_token = GSS_C_NO_BUFFER;"
    },
    {
        "line": 40,
        "fullcodeline": "context = GSS_C_NO_CONTEXT;"
    },
    {
        "line": 43,
        "fullcodeline": "maj_stat = gss_init_sec_context(&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name,"
    },
    {
        "line": 59,
        "fullcodeline": "imap_cmd_start(idata, \"AUTHENTICATE GSSAPI\");"
    },
    {
        "line": 75,
        "fullcodeline": "mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);"
    },
    {
        "line": 76,
        "fullcodeline": "gss_release_buffer(&min_stat, &send_token);"
    },
    {
        "line": 77,
        "fullcodeline": "mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");"
    },
    {
        "line": 78,
        "fullcodeline": "mutt_socket_send(idata->conn, buf1);"
    },
    {
        "line": 117,
        "fullcodeline": "gss_release_name(&min_stat, &target_name);"
    },
    {
        "line": 129,
        "fullcodeline": "request_buf.length = mutt_b64_decode(buf2, idata->buf + 2);"
    },
    {
        "line": 130,
        "fullcodeline": "request_buf.value = buf2;"
    },
    {
        "line": 132,
        "fullcodeline": "maj_stat = gss_unwrap(&min_stat, context, &request_buf, &send_token, &cflags, &quality);"
    },
    {
        "line": 143,
        "fullcodeline": "server_conf_flags = ((char *) send_token.value)[0];"
    },
    {
        "line": 153,
        "fullcodeline": "buf_size = ntohl(*((long *) send_token.value));"
    },
    {
        "line": 154,
        "fullcodeline": "gss_release_buffer(&min_stat, &send_token);"
    },
    {
        "line": 159,
        "fullcodeline": "mutt_debug(2, \"Maximum GSS token size is %ld\\n\", buf_size);"
    },
    {
        "line": 162,
        "fullcodeline": "buf_size = htonl(buf_size); /* not relevant without integrity/privacy */"
    },
    {
        "line": 163,
        "fullcodeline": "memcpy(buf1, &buf_size, 4);"
    },
    {
        "line": 164,
        "fullcodeline": "buf1[0] = GSS_AUTH_P_NONE;"
    },
    {
        "line": 166,
        "fullcodeline": "strncpy(buf1 + 4, idata->conn->account.user, sizeof(buf1) - 4);"
    },
    {
        "line": 167,
        "fullcodeline": "request_buf.value = buf1;"
    },
    {
        "line": 168,
        "fullcodeline": "request_buf.length = 4 + strlen(idata->conn->account.user);"
    },
    {
        "line": 169,
        "fullcodeline": "maj_stat = gss_wrap(&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf,"
    },
    {
        "line": 177,
        "fullcodeline": "mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);"
    },
    {
        "line": 179,
        "fullcodeline": "mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");"
    },
    {
        "line": 180,
        "fullcodeline": "mutt_socket_send(idata->conn, buf1);"
    },
    {
        "line": 211,
        "fullcodeline": "mutt_socket_send(idata->conn, \"*\\r\\n\");"
    },
    {
        "line": 16,
        "fullcodeline": "if (!mutt_bit_isset(idata->capabilities, AGSSAPI))"
    },
    {
        "line": 27,
        "fullcodeline": "if (maj_stat != GSS_S_COMPLETE)"
    },
    {
        "line": 47,
        "fullcodeline": "if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)"
    },
    {
        "line": 57,
        "fullcodeline": "mutt_message(_(\"Authenticating (GSSAPI)...\"));"
    },
    {
        "line": 63,
        "fullcodeline": "rc = imap_cmd_step(idata);"
    },
    {
        "line": 64,
        "fullcodeline": "while (rc == IMAP_CMD_CONTINUE);"
    },
    {
        "line": 66,
        "fullcodeline": "if (rc != IMAP_CMD_RESPOND)"
    },
    {
        "line": 80,
        "fullcodeline": "while (maj_stat == GSS_S_CONTINUE_NEEDED)"
    },
    {
        "line": 121,
        "fullcodeline": "rc = imap_cmd_step(idata);"
    },
    {
        "line": 122,
        "fullcodeline": "while (rc == IMAP_CMD_CONTINUE);"
    },
    {
        "line": 124,
        "fullcodeline": "if (rc != IMAP_CMD_RESPOND)"
    },
    {
        "line": 133,
        "fullcodeline": "if (maj_stat != GSS_S_COMPLETE)"
    },
    {
        "line": 171,
        "fullcodeline": "if (maj_stat != GSS_S_COMPLETE)"
    },
    {
        "line": 184,
        "fullcodeline": "rc = imap_cmd_step(idata);"
    },
    {
        "line": 185,
        "fullcodeline": "while (rc == IMAP_CMD_CONTINUE);"
    },
    {
        "line": 213,
        "fullcodeline": "rc = imap_cmd_step(idata);"
    },
    {
        "line": 217,
        "fullcodeline": "mutt_error(_(\"GSSAPI authentication failed.\"));"
    },
    {
        "line": 19,
        "fullcodeline": "if (mutt_account_getuser(&idata->conn->account) < 0)"
    },
    {
        "line": 44,
        "fullcodeline": "GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG,"
    },
    {
        "line": 49,
        "fullcodeline": "print_gss_error(maj_stat, min_stat);"
    },
    {
        "line": 94,
        "fullcodeline": "request_buf.length = mutt_b64_decode(buf2, idata->buf + 2);"
    },
    {
        "line": 95,
        "fullcodeline": "request_buf.value = buf2;"
    },
    {
        "line": 96,
        "fullcodeline": "sec_token = &request_buf;"
    },
    {
        "line": 99,
        "fullcodeline": "maj_stat = gss_init_sec_context("
    },
    {
        "line": 111,
        "fullcodeline": "mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);"
    },
    {
        "line": 112,
        "fullcodeline": "gss_release_buffer(&min_stat, &send_token);"
    },
    {
        "line": 113,
        "fullcodeline": "mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");"
    },
    {
        "line": 114,
        "fullcodeline": "mutt_socket_send(idata->conn, buf1);"
    },
    {
        "line": 135,
        "fullcodeline": "print_gss_error(maj_stat, min_stat);"
    },
    {
        "line": 144,
        "fullcodeline": "if (!(((char *) send_token.value)[0] & GSS_AUTH_P_NONE))"
    },
    {
        "line": 156,
        "fullcodeline": "(server_conf_flags & GSS_AUTH_P_NONE) ? 'N' : '-',"
    },
    {
        "line": 157,
        "fullcodeline": "(server_conf_flags & GSS_AUTH_P_INTEGRITY) ? 'I' : '-',"
    },
    {
        "line": 158,
        "fullcodeline": "(server_conf_flags & GSS_AUTH_P_PRIVACY) ? 'P' : '-');"
    },
    {
        "line": 195,
        "fullcodeline": "maj_stat = gss_delete_sec_context(&min_stat, &context, &send_token);"
    },
    {
        "line": 84,
        "fullcodeline": "rc = imap_cmd_step(idata);"
    },
    {
        "line": 85,
        "fullcodeline": "while (rc == IMAP_CMD_CONTINUE);"
    },
    {
        "line": 87,
        "fullcodeline": "if (rc != IMAP_CMD_RESPOND)"
    },
    {
        "line": 32,
        "fullcodeline": "else if (DebugLevel >= 2)"
    },
    {
        "line": 101,
        "fullcodeline": "GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS,"
    },
    {
        "line": 103,
        "fullcodeline": "if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)"
    },
    {
        "line": 105,
        "fullcodeline": "print_gss_error(maj_stat, min_stat);"
    },
    {
        "line": 34,
        "fullcodeline": "gss_display_name(&min_stat, target_name, &request_buf, &mech_name);"
    },
    {
        "line": 36,
        "fullcodeline": "gss_release_buffer(&min_stat, &request_buf);"
    }
]