[
    {
        "line": 13,
        "fullcodeline": "opj_image_t *l_image = 00;"
    },
    {
        "line": 14,
        "fullcodeline": "opj_cp_t *l_cp = 00;"
    },
    {
        "line": 15,
        "fullcodeline": "opj_image_comp_t * l_img_comp = 00;"
    },
    {
        "line": 16,
        "fullcodeline": "opj_tcp_t * l_current_tile_param = 00;"
    },
    {
        "line": 19,
        "fullcodeline": "assert(p_j2k != 00);"
    },
    {
        "line": 20,
        "fullcodeline": "assert(p_manager != 00);"
    },
    {
        "line": 21,
        "fullcodeline": "assert(p_header_data != 00);"
    },
    {
        "line": 23,
        "fullcodeline": "l_image = p_j2k->m_private_image;"
    },
    {
        "line": 24,
        "fullcodeline": "l_cp = &(p_j2k->m_cp);"
    },
    {
        "line": 32,
        "fullcodeline": "l_remaining_size = p_header_size - 36;"
    },
    {
        "line": 33,
        "fullcodeline": "l_nb_comp = l_remaining_size / 3;"
    },
    {
        "line": 34,
        "fullcodeline": "l_nb_comp_remain = l_remaining_size % 3;"
    },
    {
        "line": 40,
        "fullcodeline": "opj_read_bytes(p_header_data,&l_tmp ,2);                                                /* Rsiz (capabilities) */"
    },
    {
        "line": 41,
        "fullcodeline": "p_header_data+=2;"
    },
    {
        "line": 42,
        "fullcodeline": "l_cp->rsiz = (OPJ_UINT16) l_tmp;"
    },
    {
        "line": 43,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);   /* Xsiz */"
    },
    {
        "line": 44,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 45,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);   /* Ysiz */"
    },
    {
        "line": 46,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 47,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);   /* X0siz */"
    },
    {
        "line": 48,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 49,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);   /* Y0siz */"
    },
    {
        "line": 50,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 51,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx, 4);             /* XTsiz */"
    },
    {
        "line": 52,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 53,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy, 4);             /* YTsiz */"
    },
    {
        "line": 54,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 55,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0, 4);             /* XT0siz */"
    },
    {
        "line": 56,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 57,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0, 4);             /* YT0siz */"
    },
    {
        "line": 58,
        "fullcodeline": "p_header_data+=4;"
    },
    {
        "line": 59,
        "fullcodeline": "opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp, 2);                 /* Csiz */"
    },
    {
        "line": 60,
        "fullcodeline": "p_header_data+=2;"
    },
    {
        "line": 92,
        "fullcodeline": "l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx); /* manage overflow */"
    },
    {
        "line": 93,
        "fullcodeline": "l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy); /* manage overflow */"
    },
    {
        "line": 142,
        "fullcodeline": "l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps, sizeof(opj_image_comp_t));"
    },
    {
        "line": 149,
        "fullcodeline": "l_img_comp = l_image->comps;"
    },
    {
        "line": 211,
        "fullcodeline": "l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0), (OPJ_INT32)l_cp->tdx);"
    },
    {
        "line": 212,
        "fullcodeline": "l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0), (OPJ_INT32)l_cp->tdy);"
    },
    {
        "line": 221,
        "fullcodeline": "l_nb_tiles = l_cp->tw * l_cp->th;"
    },
    {
        "line": 278,
        "fullcodeline": "l_cp->tcps = (opj_tcp_t*) opj_calloc(l_nb_tiles, sizeof(opj_tcp_t));"
    },
    {
        "line": 297,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps ="
    },
    {
        "line": 304,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records ="
    },
    {
        "line": 311,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records = OPJ_J2K_MCT_DEFAULT_NB_RECORDS;"
    },
    {
        "line": 313,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records ="
    },
    {
        "line": 321,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records = OPJ_J2K_MCC_DEFAULT_NB_RECORDS;"
    },
    {
        "line": 330,
        "fullcodeline": "l_current_tile_param = l_cp->tcps;"
    },
    {
        "line": 341,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_state =  J2K_STATE_MH; /* FIXME J2K_DEC_STATE_MH; */"
    },
    {
        "line": 342,
        "fullcodeline": "opj_image_comp_header_update(l_image,l_cp);"
    },
    {
        "line": 27,
        "fullcodeline": "if (p_header_size < 36) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (l_nb_comp_remain != 0){"
    },
    {
        "line": 61,
        "fullcodeline": "if (l_tmp < 16385)"
    },
    {
        "line": 68,
        "fullcodeline": "if (l_image->numcomps != l_nb_comp) {"
    },
    {
        "line": 75,
        "fullcodeline": "if ((l_image->x0 >= l_image->x1) || (l_image->y0 >= l_image->y1)) {"
    },
    {
        "line": 80,
        "fullcodeline": "if ((l_cp->tdx == 0U) || (l_cp->tdy == 0U)) {"
    },
    {
        "line": 86,
        "fullcodeline": "if ((0xFFFFFFFFU / l_image->x1) < l_image->y1) {"
    },
    {
        "line": 94,
        "fullcodeline": "if ((l_cp->tx0 > l_image->x0) || (l_cp->ty0 > l_image->y0) || (l_tx1 <= l_image->x0) || (l_ty1 <= l_image->y0) ) {"
    },
    {
        "line": 143,
        "fullcodeline": "if (l_image->comps == 00){"
    },
    {
        "line": 152,
        "fullcodeline": "for (i = 0; i < l_image->numcomps; ++i){"
    },
    {
        "line": 215,
        "fullcodeline": "if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {"
    },
    {
        "line": 279,
        "fullcodeline": "if (l_cp->tcps == 00) {"
    },
    {
        "line": 298,
        "fullcodeline": "(opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));"
    },
    {
        "line": 299,
        "fullcodeline": "if(p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps  == 00) {"
    },
    {
        "line": 305,
        "fullcodeline": "(opj_mct_data_t*)opj_calloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS ,sizeof(opj_mct_data_t));"
    },
    {
        "line": 307,
        "fullcodeline": "if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {"
    },
    {
        "line": 314,
        "fullcodeline": "(opj_simple_mcc_decorrelation_data_t*)"
    },
    {
        "line": 317,
        "fullcodeline": "if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {"
    },
    {
        "line": 324,
        "fullcodeline": "for (i=0;i<l_image->numcomps;++i) {"
    },
    {
        "line": 331,
        "fullcodeline": "for     (i = 0; i < l_nb_tiles; ++i) {"
    },
    {
        "line": 28,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");"
    },
    {
        "line": 36,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");"
    },
    {
        "line": 62,
        "fullcodeline": "l_image->numcomps = (OPJ_UINT16) l_tmp;"
    },
    {
        "line": 69,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\\n\", l_image->numcomps, l_nb_comp);"
    },
    {
        "line": 81,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\\n\", l_cp->tdx, l_cp->tdy);"
    },
    {
        "line": 87,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Prevent buffer overflow (x1: %d, y1: %d)\\n\", l_image->x1, l_image->y1);"
    },
    {
        "line": 95,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: illegal tile offset\\n\");"
    },
    {
        "line": 144,
        "fullcodeline": "l_image->numcomps = 0;"
    },
    {
        "line": 145,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");"
    },
    {
        "line": 154,
        "fullcodeline": "opj_read_bytes(p_header_data,&tmp,1);   /* Ssiz_i */"
    },
    {
        "line": 155,
        "fullcodeline": "++p_header_data;"
    },
    {
        "line": 156,
        "fullcodeline": "l_img_comp->prec = (tmp & 0x7f) + 1;"
    },
    {
        "line": 157,
        "fullcodeline": "l_img_comp->sgnd = tmp >> 7;"
    },
    {
        "line": 158,
        "fullcodeline": "opj_read_bytes(p_header_data,&tmp,1);   /* XRsiz_i */"
    },
    {
        "line": 159,
        "fullcodeline": "++p_header_data;"
    },
    {
        "line": 160,
        "fullcodeline": "l_img_comp->dx = (OPJ_UINT32)tmp; /* should be between 1 and 255 */"
    },
    {
        "line": 161,
        "fullcodeline": "opj_read_bytes(p_header_data,&tmp,1);   /* YRsiz_i */"
    },
    {
        "line": 162,
        "fullcodeline": "++p_header_data;"
    },
    {
        "line": 163,
        "fullcodeline": "l_img_comp->dy = (OPJ_UINT32)tmp; /* should be between 1 and 255 */"
    },
    {
        "line": 205,
        "fullcodeline": "l_img_comp->resno_decoded = 0;                                                          /* number of resolution decoded */"
    },
    {
        "line": 207,
        "fullcodeline": "++l_img_comp;"
    },
    {
        "line": 216,
        "fullcodeline": "opj_event_msg(  p_manager, EVT_ERROR,"
    },
    {
        "line": 225,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;"
    },
    {
        "line": 226,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;"
    },
    {
        "line": 227,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0), (OPJ_INT32)l_cp->tdx);"
    },
    {
        "line": 228,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0), (OPJ_INT32)l_cp->tdy);"
    },
    {
        "line": 280,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");"
    },
    {
        "line": 300,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");"
    },
    {
        "line": 308,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");"
    },
    {
        "line": 315,
        "fullcodeline": "opj_calloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS, sizeof(opj_simple_mcc_decorrelation_data_t));"
    },
    {
        "line": 318,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");"
    },
    {
        "line": 332,
        "fullcodeline": "l_current_tile_param->tccps = (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));"
    },
    {
        "line": 338,
        "fullcodeline": "++l_current_tile_param;"
    },
    {
        "line": 64,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: number of component is illegal -> %d\\n\", l_tmp);"
    },
    {
        "line": 164,
        "fullcodeline": "if( l_img_comp->dx < 1 || l_img_comp->dx > 255 ||"
    },
    {
        "line": 171,
        "fullcodeline": "if( l_img_comp->prec > 38) { /* TODO openjpeg won't handle more than ? */"
    },
    {
        "line": 231,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;"
    },
    {
        "line": 232,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;"
    },
    {
        "line": 233,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;"
    },
    {
        "line": 234,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;"
    },
    {
        "line": 333,
        "fullcodeline": "if (l_current_tile_param->tccps == 00) {"
    },
    {
        "line": 165,
        "fullcodeline": "l_img_comp->dy < 1 || l_img_comp->dy > 255 ) {"
    },
    {
        "line": 166,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR,"
    },
    {
        "line": 172,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR,"
    },
    {
        "line": 326,
        "fullcodeline": "p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1 << (l_image->comps[i].prec - 1);"
    },
    {
        "line": 334,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");"
    }
]