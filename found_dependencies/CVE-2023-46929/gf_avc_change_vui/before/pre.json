[
    {
        "line": 8,
        "fullcodeline": "orig = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "memset(&avc, 0, sizeof(AVCState));"
    },
    {
        "line": 11,
        "fullcodeline": "avc.sps_active_idx = -1;"
    },
    {
        "line": 13,
        "fullcodeline": "i=0;"
    },
    {
        "line": 14,
        "fullcodeline": "while ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {"
    },
    {
        "line": 15,
        "fullcodeline": "u8 *no_emulation_buf = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "u32 no_emulation_buf_size = 0, emulation_bytes = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "idx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);"
    },
    {
        "line": 25,
        "fullcodeline": "no_emulation_buf = gf_malloc((slc->size - 1) * sizeof(char));"
    },
    {
        "line": 26,
        "fullcodeline": "no_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data + 1, no_emulation_buf, slc->size - 1);"
    },
    {
        "line": 28,
        "fullcodeline": "orig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);"
    },
    {
        "line": 29,
        "fullcodeline": "gf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);"
    },
    {
        "line": 30,
        "fullcodeline": "gf_bs_seek(orig, 0);"
    },
    {
        "line": 31,
        "fullcodeline": "mod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);"
    },
    {
        "line": 34,
        "fullcodeline": "assert(bit_offset >= 8);"
    },
    {
        "line": 41,
        "fullcodeline": "avc_hevc_vvc_rewrite_vui(vui_info, orig, mod, GF_CODECID_AVC);"
    },
    {
        "line": 48,
        "fullcodeline": "gf_bs_del(orig);"
    },
    {
        "line": 49,
        "fullcodeline": "orig = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "gf_free(no_emulation_buf);"
    },
    {
        "line": 53,
        "fullcodeline": "gf_bs_get_content(mod, &no_emulation_buf, &flag);"
    },
    {
        "line": 54,
        "fullcodeline": "emulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, flag);"
    },
    {
        "line": 57,
        "fullcodeline": "slc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data + 1, flag) + 1;"
    },
    {
        "line": 59,
        "fullcodeline": "gf_bs_del(mod);"
    },
    {
        "line": 60,
        "fullcodeline": "gf_free(no_emulation_buf);"
    },
    {
        "line": 18,
        "fullcodeline": "if (idx<0) {"
    },
    {
        "line": 35,
        "fullcodeline": "while (bit_offset - 8/*bit_offset doesn't take care of the first byte (NALU type)*/) {"
    },
    {
        "line": 44,
        "fullcodeline": "while (gf_bs_bits_available(orig)) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (flag+emulation_bytes+1>slc->size)"
    },
    {
        "line": 36,
        "fullcodeline": "flag = gf_bs_read_int(orig, 1);"
    },
    {
        "line": 37,
        "fullcodeline": "gf_bs_write_int(mod, flag, 1);"
    },
    {
        "line": 38,
        "fullcodeline": "bit_offset--;"
    },
    {
        "line": 45,
        "fullcodeline": "flag = gf_bs_read_int(orig, 1);"
    },
    {
        "line": 46,
        "fullcodeline": "gf_bs_write_int(mod, flag, 1);"
    },
    {
        "line": 56,
        "fullcodeline": "slc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);"
    },
    {
        "line": 20,
        "fullcodeline": "gf_bs_del(orig);"
    }
]