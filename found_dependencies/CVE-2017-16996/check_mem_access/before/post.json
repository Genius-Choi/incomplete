[
    {
        "line": 5,
        "fullcodeline": "struct bpf_verifier_state *state = env->cur_state;"
    },
    {
        "line": 6,
        "fullcodeline": "struct bpf_reg_state *regs = cur_regs(env);"
    },
    {
        "line": 7,
        "fullcodeline": "struct bpf_reg_state *reg = regs + regno;"
    },
    {
        "line": 8,
        "fullcodeline": "int size, err = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "size = bpf_size_to_bytes(bpf_size);"
    },
    {
        "line": 15,
        "fullcodeline": "err = check_ptr_alignment(env, reg, off, size);"
    },
    {
        "line": 20,
        "fullcodeline": "off += reg->off;"
    },
    {
        "line": 11,
        "fullcodeline": "if (size < 0)"
    },
    {
        "line": 22,
        "fullcodeline": "if (reg->type == PTR_TO_MAP_VALUE) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&"
    },
    {
        "line": 29,
        "fullcodeline": "err = check_map_access(env, regno, off, size, false);"
    },
    {
        "line": 126,
        "fullcodeline": "regs[value_regno].type == SCALAR_VALUE) {"
    },
    {
        "line": 128,
        "fullcodeline": "regs[value_regno].var_off ="
    },
    {
        "line": 130,
        "fullcodeline": "__update_reg_bounds(&regs[value_regno]);"
    },
    {
        "line": 23,
        "fullcodeline": "if (t == BPF_WRITE && value_regno >= 0 &&"
    },
    {
        "line": 30,
        "fullcodeline": "if (!err && t == BPF_READ && value_regno >= 0)"
    },
    {
        "line": 129,
        "fullcodeline": "tnum_cast(regs[value_regno].var_off, size);"
    },
    {
        "line": 24,
        "fullcodeline": "is_pointer_value(env, value_regno)) {"
    },
    {
        "line": 25,
        "fullcodeline": "verbose(env, \"R%d leaks addr into map\\n\", value_regno);"
    },
    {
        "line": 31,
        "fullcodeline": "mark_reg_unknown(env, regs, value_regno);"
    },
    {
        "line": 33,
        "fullcodeline": "} else if (reg->type == PTR_TO_CTX) {"
    },
    {
        "line": 26,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 34,
        "fullcodeline": "enum bpf_reg_type reg_type = SCALAR_VALUE;"
    },
    {
        "line": 59,
        "fullcodeline": "err = check_ctx_access(env, insn_idx, off, size, t, &reg_type);"
    },
    {
        "line": 36,
        "fullcodeline": "if (t == BPF_WRITE && value_regno >= 0 &&"
    },
    {
        "line": 50,
        "fullcodeline": "if (!tnum_is_const(reg->var_off) || reg->var_off.value) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (!err && t == BPF_READ && value_regno >= 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "is_pointer_value(env, value_regno)) {"
    },
    {
        "line": 38,
        "fullcodeline": "verbose(env, \"R%d leaks addr into ctx\\n\", value_regno);"
    },
    {
        "line": 45,
        "fullcodeline": "verbose(env,"
    },
    {
        "line": 51,
        "fullcodeline": "char tn_buf[48];"
    },
    {
        "line": 53,
        "fullcodeline": "tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);"
    },
    {
        "line": 54,
        "fullcodeline": "verbose(env,"
    },
    {
        "line": 70,
        "fullcodeline": "regs[value_regno].id = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "regs[value_regno].off = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "regs[value_regno].range = 0;"
    },
    {
        "line": 73,
        "fullcodeline": "regs[value_regno].type = reg_type;"
    },
    {
        "line": 76,
        "fullcodeline": "} else if (reg->type == PTR_TO_STACK) {"
    },
    {
        "line": 39,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 47,
        "fullcodeline": "regno, reg->off, off - reg->off);"
    },
    {
        "line": 48,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 57,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 65,
        "fullcodeline": "if (reg_type == SCALAR_VALUE)"
    },
    {
        "line": 89,
        "fullcodeline": "off += reg->var_off.value;"
    },
    {
        "line": 66,
        "fullcodeline": "mark_reg_unknown(env, regs, value_regno);"
    },
    {
        "line": 81,
        "fullcodeline": "if (!tnum_is_const(reg->var_off)) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (off >= 0 || off < -MAX_BPF_STACK) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (env->prog->aux->stack_depth < -off)"
    },
    {
        "line": 99,
        "fullcodeline": "if (t == BPF_WRITE)"
    },
    {
        "line": 68,
        "fullcodeline": "mark_reg_known_zero(env, regs,"
    },
    {
        "line": 82,
        "fullcodeline": "char tn_buf[48];"
    },
    {
        "line": 84,
        "fullcodeline": "tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);"
    },
    {
        "line": 85,
        "fullcodeline": "verbose(env, \"variable stack access var_off=%s off=%d size=%d\","
    },
    {
        "line": 91,
        "fullcodeline": "verbose(env, \"invalid stack off=%d size=%d\\n\", off,"
    },
    {
        "line": 97,
        "fullcodeline": "env->prog->aux->stack_depth = -off;"
    },
    {
        "line": 100,
        "fullcodeline": "err = check_stack_write(env, state, off, size,"
    },
    {
        "line": 105,
        "fullcodeline": "} else if (reg_is_pkt_pointer(reg)) {"
    },
    {
        "line": 87,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 93,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 103,
        "fullcodeline": "err = check_stack_read(env, state, off, size,"
    },
    {
        "line": 116,
        "fullcodeline": "err = check_packet_access(env, regno, off, size, false);"
    },
    {
        "line": 106,
        "fullcodeline": "if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (t == BPF_WRITE && value_regno >= 0 &&"
    },
    {
        "line": 117,
        "fullcodeline": "if (!err && t == BPF_READ && value_regno >= 0)"
    },
    {
        "line": 120,
        "fullcodeline": "verbose(env, \"R%d invalid mem access '%s'\\n\", regno,"
    },
    {
        "line": 107,
        "fullcodeline": "verbose(env, \"cannot write into packet\\n\");"
    },
    {
        "line": 111,
        "fullcodeline": "is_pointer_value(env, value_regno)) {"
    },
    {
        "line": 112,
        "fullcodeline": "verbose(env, \"R%d leaks addr into packet\\n\","
    },
    {
        "line": 118,
        "fullcodeline": "mark_reg_unknown(env, regs, value_regno);"
    },
    {
        "line": 122,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 108,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 114,
        "fullcodeline": "return -EACCES;"
    }
]