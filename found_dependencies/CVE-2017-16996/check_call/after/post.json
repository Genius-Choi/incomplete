[
    {
        "line": 3,
        "fullcodeline": "const struct bpf_func_proto *fn = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "changes_data = bpf_helper_changes_pkt_data(fn->func);"
    },
    {
        "line": 39,
        "fullcodeline": "memset(&meta, 0, sizeof(meta));"
    },
    {
        "line": 40,
        "fullcodeline": "meta.pkt_access = fn->pkt_access;"
    },
    {
        "line": 45,
        "fullcodeline": "err = check_raw_mode(fn);"
    },
    {
        "line": 53,
        "fullcodeline": "err = check_func_arg(env, BPF_REG_1, fn->arg1_type, &meta);"
    },
    {
        "line": 56,
        "fullcodeline": "err = check_func_arg(env, BPF_REG_2, fn->arg2_type, &meta);"
    },
    {
        "line": 59,
        "fullcodeline": "err = check_func_arg(env, BPF_REG_3, fn->arg3_type, &meta);"
    },
    {
        "line": 62,
        "fullcodeline": "err = check_func_arg(env, BPF_REG_4, fn->arg4_type, &meta);"
    },
    {
        "line": 65,
        "fullcodeline": "err = check_func_arg(env, BPF_REG_5, fn->arg5_type, &meta);"
    },
    {
        "line": 78,
        "fullcodeline": "regs = cur_regs(env);"
    },
    {
        "line": 120,
        "fullcodeline": "err = check_map_func_compatibility(env, meta.map_ptr, func_id);"
    },
    {
        "line": 10,
        "fullcodeline": "if (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (!fn) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (!env->prog->gpl_compatible && fn->gpl_only) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (changes_data && fn->arg1_type != ARG_PTR_TO_CTX) {"
    },
    {
        "line": 72,
        "fullcodeline": "for (i = 0; i < meta.access_size; i++) {"
    },
    {
        "line": 80,
        "fullcodeline": "for (i = 0; i < CALLER_SAVED_REGS; i++) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (fn->ret_type == RET_INTEGER) {"
    },
    {
        "line": 11,
        "fullcodeline": "verbose(env, \"invalid func %s#%d\\n\", func_id_name(func_id),"
    },
    {
        "line": 17,
        "fullcodeline": "fn = env->ops->get_func_proto(func_id);"
    },
    {
        "line": 20,
        "fullcodeline": "verbose(env, \"unknown func %s#%d\\n\", func_id_name(func_id),"
    },
    {
        "line": 27,
        "fullcodeline": "verbose(env, \"cannot call GPL only function from proprietary program\\n\");"
    },
    {
        "line": 34,
        "fullcodeline": "verbose(env, \"kernel subsystem misconfigured func %s#%d: r1 != ctx\\n\","
    },
    {
        "line": 47,
        "fullcodeline": "verbose(env, \"kernel subsystem misconfigured func %s#%d\\n\","
    },
    {
        "line": 73,
        "fullcodeline": "err = check_mem_access(env, insn_idx, meta.regno, i, BPF_B, BPF_WRITE, -1);"
    },
    {
        "line": 81,
        "fullcodeline": "mark_reg_not_init(env, regs, caller_saved[i]);"
    },
    {
        "line": 82,
        "fullcodeline": "check_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);"
    },
    {
        "line": 88,
        "fullcodeline": "mark_reg_unknown(env, regs, BPF_REG_0);"
    },
    {
        "line": 125,
        "fullcodeline": "clear_all_pkt_pointers(env);"
    },
    {
        "line": 13,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 22,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 28,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 35,
        "fullcodeline": "func_id_name(func_id), func_id);"
    },
    {
        "line": 36,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 48,
        "fullcodeline": "func_id_name(func_id), func_id);"
    },
    {
        "line": 89,
        "fullcodeline": "} else if (fn->ret_type == RET_VOID) {"
    },
    {
        "line": 90,
        "fullcodeline": "regs[BPF_REG_0].type = NOT_INIT;"
    },
    {
        "line": 91,
        "fullcodeline": "} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {"
    },
    {
        "line": 94,
        "fullcodeline": "regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;"
    },
    {
        "line": 96,
        "fullcodeline": "mark_reg_known_zero(env, regs, BPF_REG_0);"
    },
    {
        "line": 97,
        "fullcodeline": "regs[BPF_REG_0].off = 0;"
    },
    {
        "line": 107,
        "fullcodeline": "regs[BPF_REG_0].map_ptr = meta.map_ptr;"
    },
    {
        "line": 108,
        "fullcodeline": "regs[BPF_REG_0].id = ++env->id_gen;"
    },
    {
        "line": 102,
        "fullcodeline": "if (meta.map_ptr == NULL) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (!insn_aux->map_ptr)"
    },
    {
        "line": 115,
        "fullcodeline": "verbose(env, \"unknown return type %d of func %s#%d\\n\","
    },
    {
        "line": 103,
        "fullcodeline": "verbose(env,"
    },
    {
        "line": 111,
        "fullcodeline": "insn_aux->map_ptr = meta.map_ptr;"
    },
    {
        "line": 116,
        "fullcodeline": "fn->ret_type, func_id_name(func_id), func_id);"
    },
    {
        "line": 117,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 105,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 112,
        "fullcodeline": "else if (insn_aux->map_ptr != meta.map_ptr)"
    },
    {
        "line": 113,
        "fullcodeline": "insn_aux->map_ptr = BPF_MAP_PTR_POISON;"
    }
]