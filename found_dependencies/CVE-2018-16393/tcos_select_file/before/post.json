[
    {
        "line": 7,
        "fullcodeline": "sc_file_t *file=NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;"
    },
    {
        "line": 12,
        "fullcodeline": "assert(card != NULL && in_path != NULL);"
    },
    {
        "line": 13,
        "fullcodeline": "ctx=card->ctx;"
    },
    {
        "line": 14,
        "fullcodeline": "memcpy(path, in_path->value, in_path->len);"
    },
    {
        "line": 15,
        "fullcodeline": "pathlen = in_path->len;"
    },
    {
        "line": 17,
        "fullcodeline": "sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);"
    },
    {
        "line": 43,
        "fullcodeline": "apdu.lc = pathlen;"
    },
    {
        "line": 44,
        "fullcodeline": "apdu.data = path;"
    },
    {
        "line": 45,
        "fullcodeline": "apdu.datalen = pathlen;"
    },
    {
        "line": 58,
        "fullcodeline": "r = sc_transmit_apdu(card, &apdu);"
    },
    {
        "line": 59,
        "fullcodeline": "SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");"
    },
    {
        "line": 60,
        "fullcodeline": "r = sc_check_sw(card, apdu.sw1, apdu.sw2);"
    },
    {
        "line": 68,
        "fullcodeline": "file = sc_file_new();"
    },
    {
        "line": 70,
        "fullcodeline": "*file_out = file;"
    },
    {
        "line": 108,
        "fullcodeline": "file->magic = SC_FILE_MAGIC;"
    },
    {
        "line": 110,
        "fullcodeline": "parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);"
    },
    {
        "line": 41,
        "fullcodeline": "if( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;"
    },
    {
        "line": 47,
        "fullcodeline": "if (file_out != NULL) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);"
    },
    {
        "line": 63,
        "fullcodeline": "if (apdu.resplen < 1 || apdu.resp[0] != 0x62){"
    },
    {
        "line": 69,
        "fullcodeline": "if (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);"
    },
    {
        "line": 73,
        "fullcodeline": "for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){"
    },
    {
        "line": 24,
        "fullcodeline": "apdu.p1 = 9;"
    },
    {
        "line": 27,
        "fullcodeline": "apdu.p1 = 4;"
    },
    {
        "line": 30,
        "fullcodeline": "apdu.p1 = 8;"
    },
    {
        "line": 35,
        "fullcodeline": "apdu.p1 = 3;"
    },
    {
        "line": 36,
        "fullcodeline": "pathlen = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);"
    },
    {
        "line": 48,
        "fullcodeline": "apdu.resp = buf;"
    },
    {
        "line": 50,
        "fullcodeline": "apdu.le = 256;"
    },
    {
        "line": 64,
        "fullcodeline": "sc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);"
    },
    {
        "line": 65,
        "fullcodeline": "SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);"
    },
    {
        "line": 75,
        "fullcodeline": "unsigned char type=apdu.resp[i], *d=apdu.resp+i+2;"
    },
    {
        "line": 21,
        "fullcodeline": "if (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;"
    },
    {
        "line": 31,
        "fullcodeline": "if (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;"
    },
    {
        "line": 32,
        "fullcodeline": "if (pathlen == 0) apdu.p1 = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "apdu.resplen = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "apdu.le = 0;"
    },
    {
        "line": 54,
        "fullcodeline": "apdu.p2 = 0x0C;"
    },
    {
        "line": 55,
        "fullcodeline": "apdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;"
    },
    {
        "line": 74,
        "fullcodeline": "int j, len=apdu.resp[i+1];"
    },
    {
        "line": 80,
        "fullcodeline": "file->size=0;"
    },
    {
        "line": 84,
        "fullcodeline": "file->shareable = (d[0] & 0x40) ? 1 : 0;"
    },
    {
        "line": 85,
        "fullcodeline": "file->ef_structure = d[0] & 7;"
    },
    {
        "line": 95,
        "fullcodeline": "file->id = (d[0]<<8) | d[1];"
    },
    {
        "line": 98,
        "fullcodeline": "memcpy(file->name, d, len);"
    },
    {
        "line": 99,
        "fullcodeline": "file->namelen = len;"
    },
    {
        "line": 102,
        "fullcodeline": "sc_file_set_sec_attr(file, d, len);"
    },
    {
        "line": 81,
        "fullcodeline": "for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];"
    },
    {
        "line": 86,
        "fullcodeline": "switch ((d[0]>>3) & 7) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (len>0) sc_file_set_prop_attr(file, d, len);"
    },
    {
        "line": 87,
        "fullcodeline": "case 0: file->type = SC_FILE_TYPE_WORKING_EF; break;"
    },
    {
        "line": 88,
        "fullcodeline": "case 7: file->type = SC_FILE_TYPE_DF; break;"
    },
    {
        "line": 90,
        "fullcodeline": "sc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);"
    },
    {
        "line": 91,
        "fullcodeline": "SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);"
    }
]