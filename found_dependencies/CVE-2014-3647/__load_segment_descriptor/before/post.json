[
    {
        "line": 6,
        "fullcodeline": "unsigned err_vec = GP_VECTOR;"
    },
    {
        "line": 7,
        "fullcodeline": "u32 err_code = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "bool null_selector = !(selector & ~0x3); /* 0000-0003 are null */"
    },
    {
        "line": 12,
        "fullcodeline": "u32 base3 = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "memset(&seg_desc, 0, sizeof seg_desc);"
    },
    {
        "line": 33,
        "fullcodeline": "rpl = selector & 3;"
    },
    {
        "line": 50,
        "fullcodeline": "ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);"
    },
    {
        "line": 54,
        "fullcodeline": "err_code = selector & 0xfffc;"
    },
    {
        "line": 55,
        "fullcodeline": "err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR;"
    },
    {
        "line": 66,
        "fullcodeline": "dpl = seg_desc.dpl;"
    },
    {
        "line": 142,
        "fullcodeline": "ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);"
    },
    {
        "line": 16,
        "fullcodeline": "if (ctxt->mode == X86EMUL_MODE_REAL) {"
    },
    {
        "line": 36,
        "fullcodeline": "if ((seg == VCPU_SREG_CS"
    },
    {
        "line": 44,
        "fullcodeline": "if (seg == VCPU_SREG_TR && (selector & (1 << 2)))"
    },
    {
        "line": 51,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 58,
        "fullcodeline": "if (seg <= VCPU_SREG_GS && !seg_desc.s)"
    },
    {
        "line": 61,
        "fullcodeline": "if (!seg_desc.p) {"
    },
    {
        "line": 145,
        "fullcodeline": "return emulate_exception(ctxt, err_vec, err_code, true);"
    },
    {
        "line": 19,
        "fullcodeline": "ctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);"
    },
    {
        "line": 20,
        "fullcodeline": "set_desc_base(&seg_desc, selector << 4);"
    },
    {
        "line": 62,
        "fullcodeline": "err_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;"
    },
    {
        "line": 100,
        "fullcodeline": "selector = (selector & 0xfffc) | cpl;"
    },
    {
        "line": 105,
        "fullcodeline": "old_desc = seg_desc;"
    },
    {
        "line": 106,
        "fullcodeline": "seg_desc.type |= 2; /* busy */"
    },
    {
        "line": 107,
        "fullcodeline": "ret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,"
    },
    {
        "line": 131,
        "fullcodeline": "seg_desc.type |= 1;"
    },
    {
        "line": 132,
        "fullcodeline": "ret = write_segment_descriptor(ctxt, selector, &seg_desc);"
    },
    {
        "line": 39,
        "fullcodeline": "|| seg == VCPU_SREG_TR)"
    },
    {
        "line": 74,
        "fullcodeline": "if (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)"
    },
    {
        "line": 78,
        "fullcodeline": "if (!(seg_desc.type & 8))"
    },
    {
        "line": 81,
        "fullcodeline": "if (seg_desc.type & 4) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (seg_desc.d && seg_desc.l) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))"
    },
    {
        "line": 109,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 113,
        "fullcodeline": "if (seg_desc.s || seg_desc.type != 2)"
    },
    {
        "line": 122,
        "fullcodeline": "if ((seg_desc.type & 0xa) == 0x8 ||"
    },
    {
        "line": 133,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 22,
        "fullcodeline": "} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {"
    },
    {
        "line": 37,
        "fullcodeline": "|| (seg == VCPU_SREG_SS"
    },
    {
        "line": 92,
        "fullcodeline": "u64 efer = 0;"
    },
    {
        "line": 94,
        "fullcodeline": "ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);"
    },
    {
        "line": 123,
        "fullcodeline": "(((seg_desc.type & 0xc) != 0xc) &&"
    },
    {
        "line": 135,
        "fullcodeline": "} else if (ctxt->mode == X86EMUL_MODE_PROT64) {"
    },
    {
        "line": 24,
        "fullcodeline": "set_desc_base(&seg_desc, selector << 4);"
    },
    {
        "line": 25,
        "fullcodeline": "set_desc_limit(&seg_desc, 0xffff);"
    },
    {
        "line": 26,
        "fullcodeline": "seg_desc.type = 3;"
    },
    {
        "line": 27,
        "fullcodeline": "seg_desc.p = 1;"
    },
    {
        "line": 28,
        "fullcodeline": "seg_desc.s = 1;"
    },
    {
        "line": 29,
        "fullcodeline": "seg_desc.dpl = 3;"
    },
    {
        "line": 38,
        "fullcodeline": "&& (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))"
    },
    {
        "line": 83,
        "fullcodeline": "if (dpl > cpl)"
    },
    {
        "line": 95,
        "fullcodeline": "if (efer & EFER_LMA)"
    },
    {
        "line": 124,
        "fullcodeline": "(rpl > dpl && cpl > dpl)))"
    },
    {
        "line": 136,
        "fullcodeline": "ret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,"
    },
    {
        "line": 87,
        "fullcodeline": "if (rpl > cpl || dpl != cpl)"
    },
    {
        "line": 138,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    }
]