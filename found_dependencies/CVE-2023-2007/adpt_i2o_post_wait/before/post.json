[
    {
        "line": 6,
        "fullcodeline": "ADPT_DECLARE_WAIT_QUEUE_HEAD(adpt_wq_i2o_post);"
    },
    {
        "line": 7,
        "fullcodeline": "int status = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "ulong flags = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "struct adpt_i2o_post_wait_data *wait_data ="
    },
    {
        "line": 12,
        "fullcodeline": "DECLARE_WAITQUEUE(wait, current);"
    },
    {
        "line": 21,
        "fullcodeline": "spin_lock_irqsave(&adpt_post_wait_lock, flags);"
    },
    {
        "line": 24,
        "fullcodeline": "wait_data->next = adpt_post_wait_queue;"
    },
    {
        "line": 25,
        "fullcodeline": "adpt_post_wait_queue = wait_data;"
    },
    {
        "line": 26,
        "fullcodeline": "adpt_post_wait_id++;"
    },
    {
        "line": 27,
        "fullcodeline": "adpt_post_wait_id &= 0x7fff;"
    },
    {
        "line": 28,
        "fullcodeline": "wait_data->id =  adpt_post_wait_id;"
    },
    {
        "line": 29,
        "fullcodeline": "spin_unlock_irqrestore(&adpt_post_wait_lock, flags);"
    },
    {
        "line": 31,
        "fullcodeline": "wait_data->wq = &adpt_wq_i2o_post;"
    },
    {
        "line": 32,
        "fullcodeline": "wait_data->status = -ETIMEDOUT;"
    },
    {
        "line": 34,
        "fullcodeline": "add_wait_queue(&adpt_wq_i2o_post, &wait);"
    },
    {
        "line": 36,
        "fullcodeline": "msg[2] |= 0x80000000 | ((u32)wait_data->id);"
    },
    {
        "line": 37,
        "fullcodeline": "timeout *= HZ;"
    },
    {
        "line": 56,
        "fullcodeline": "remove_wait_queue(&adpt_wq_i2o_post, &wait);"
    },
    {
        "line": 65,
        "fullcodeline": "p2 = NULL;"
    },
    {
        "line": 66,
        "fullcodeline": "spin_lock_irqsave(&adpt_post_wait_lock, flags);"
    },
    {
        "line": 80,
        "fullcodeline": "spin_unlock_irqrestore(&adpt_post_wait_lock, flags);"
    },
    {
        "line": 82,
        "fullcodeline": "kfree(wait_data);"
    },
    {
        "line": 11,
        "fullcodeline": "kmalloc(sizeof(struct adpt_i2o_post_wait_data), GFP_ATOMIC);"
    },
    {
        "line": 14,
        "fullcodeline": "if (!wait_data)"
    },
    {
        "line": 38,
        "fullcodeline": "if((status = adpt_i2o_post_this(pHba, msg, len)) == 0){"
    },
    {
        "line": 58,
        "fullcodeline": "if(status == -ETIMEDOUT){"
    },
    {
        "line": 67,
        "fullcodeline": "for(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p1->next) {"
    },
    {
        "line": 39,
        "fullcodeline": "set_current_state(TASK_INTERRUPTIBLE);"
    },
    {
        "line": 15,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 42,
        "fullcodeline": "if (!timeout)"
    },
    {
        "line": 68,
        "fullcodeline": "if(p1 == wait_data) {"
    },
    {
        "line": 43,
        "fullcodeline": "schedule();"
    },
    {
        "line": 54,
        "fullcodeline": "spin_lock_irq(pHba->host->host_lock);"
    },
    {
        "line": 45,
        "fullcodeline": "timeout = schedule_timeout(timeout);"
    },
    {
        "line": 69,
        "fullcodeline": "if(p1->status == I2O_DETAIL_STATUS_UNSUPPORTED_FUNCTION ) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (timeout == 0) {"
    },
    {
        "line": 70,
        "fullcodeline": "status = -EOPNOTSUPP;"
    },
    {
        "line": 73,
        "fullcodeline": "p2->next = p1->next;"
    },
    {
        "line": 50,
        "fullcodeline": "status = -ETIME;"
    },
    {
        "line": 75,
        "fullcodeline": "adpt_post_wait_queue = p1->next;"
    }
]