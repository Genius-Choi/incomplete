[
    {
        "line": 7,
        "fullcodeline": "i2o_lct *lct = pHba->lct;"
    },
    {
        "line": 8,
        "fullcodeline": "u8 bus_no = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "u32 buf[10]; // larger than 7, or 8 ..."
    },
    {
        "line": 19,
        "fullcodeline": "max = lct->table_size;"
    },
    {
        "line": 20,
        "fullcodeline": "max -= 3;"
    },
    {
        "line": 21,
        "fullcodeline": "max /= 9;"
    },
    {
        "line": 81,
        "fullcodeline": "bus_no = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "if (lct == NULL) {"
    },
    {
        "line": 23,
        "fullcodeline": "for(i=0;i<max;i++) {"
    },
    {
        "line": 82,
        "fullcodeline": "for(d = pHba->devices; d ; d = d->next) {"
    },
    {
        "line": 108,
        "fullcodeline": "for(d = pHba->devices; d ; d = d->next) {"
    },
    {
        "line": 64,
        "fullcodeline": "d = kmalloc(sizeof(struct i2o_device), GFP_KERNEL);"
    },
    {
        "line": 71,
        "fullcodeline": "d->controller = pHba;"
    },
    {
        "line": 72,
        "fullcodeline": "d->next = NULL;"
    },
    {
        "line": 74,
        "fullcodeline": "memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));"
    },
    {
        "line": 76,
        "fullcodeline": "d->flags = 0;"
    },
    {
        "line": 78,
        "fullcodeline": "adpt_i2o_report_hba_unit(pHba, d);"
    },
    {
        "line": 79,
        "fullcodeline": "adpt_i2o_install_device(pHba, d);"
    },
    {
        "line": 16,
        "fullcodeline": "return -1;"
    },
    {
        "line": 24,
        "fullcodeline": "if( lct->lct_entry[i].user_tid != 0xfff){"
    },
    {
        "line": 65,
        "fullcodeline": "if(d==NULL)"
    },
    {
        "line": 83,
        "fullcodeline": "if(d->lct_data.class_id  == I2O_CLASS_BUS_ADAPTER_PORT ||"
    },
    {
        "line": 109,
        "fullcodeline": "if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||"
    },
    {
        "line": 42,
        "fullcodeline": "bus_no = buf[0]>>16;"
    },
    {
        "line": 43,
        "fullcodeline": "scsi_id = buf[1];"
    },
    {
        "line": 44,
        "fullcodeline": "scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);"
    },
    {
        "line": 84,
        "fullcodeline": "d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PORT){"
    },
    {
        "line": 91,
        "fullcodeline": "pHba->channel[bus_no].type = d->lct_data.class_id;"
    },
    {
        "line": 92,
        "fullcodeline": "pHba->channel[bus_no].tid = tid;"
    },
    {
        "line": 99,
        "fullcodeline": "bus_no++;"
    },
    {
        "line": 111,
        "fullcodeline": "d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){"
    },
    {
        "line": 114,
        "fullcodeline": "scsi_id = -1;"
    },
    {
        "line": 32,
        "fullcodeline": "if( lct->lct_entry[i].class_id != I2O_CLASS_RANDOM_BLOCK_STORAGE &&"
    },
    {
        "line": 39,
        "fullcodeline": "if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {"
    },
    {
        "line": 45,
        "fullcodeline": "if(bus_no >= MAX_CHANNEL) {\t// Something wrong skip it"
    },
    {
        "line": 49,
        "fullcodeline": "if (scsi_id >= MAX_ID){"
    },
    {
        "line": 53,
        "fullcodeline": "if(bus_no > pHba->top_scsi_channel){"
    },
    {
        "line": 56,
        "fullcodeline": "if(scsi_id > pHba->top_scsi_id){"
    },
    {
        "line": 59,
        "fullcodeline": "if(scsi_lun > pHba->top_scsi_lun){"
    },
    {
        "line": 68,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 88,
        "fullcodeline": "if(bus_no > pHba->top_scsi_channel){"
    },
    {
        "line": 93,
        "fullcodeline": "if(adpt_i2o_query_scalar(pHba, tid, 0x0200, -1, buf, 28)>=0)"
    },
    {
        "line": 100,
        "fullcodeline": "if(bus_no >= MAX_CHANNEL) {\t// Something wrong skip it"
    },
    {
        "line": 110,
        "fullcodeline": "d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||"
    },
    {
        "line": 116,
        "fullcodeline": "if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {"
    },
    {
        "line": 157,
        "fullcodeline": "if(scsi_id == -1){"
    },
    {
        "line": 34,
        "fullcodeline": "lct->lct_entry[i].class_id != I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){"
    },
    {
        "line": 54,
        "fullcodeline": "pHba->top_scsi_channel = bus_no;"
    },
    {
        "line": 57,
        "fullcodeline": "pHba->top_scsi_id = scsi_id;"
    },
    {
        "line": 60,
        "fullcodeline": "pHba->top_scsi_lun = scsi_lun;"
    },
    {
        "line": 89,
        "fullcodeline": "pHba->top_scsi_channel = bus_no;"
    },
    {
        "line": 95,
        "fullcodeline": "pHba->channel[bus_no].scsi_id = buf[1];"
    },
    {
        "line": 96,
        "fullcodeline": "PDEBUG(\"Bus %d - SCSI ID %d.\\n\", bus_no, buf[1]);"
    },
    {
        "line": 117,
        "fullcodeline": "bus_no = buf[0]>>16;"
    },
    {
        "line": 118,
        "fullcodeline": "scsi_id = buf[1];"
    },
    {
        "line": 119,
        "fullcodeline": "scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);"
    },
    {
        "line": 142,
        "fullcodeline": "pDev->tid = tid;"
    },
    {
        "line": 143,
        "fullcodeline": "pDev->scsi_channel = bus_no;"
    },
    {
        "line": 144,
        "fullcodeline": "pDev->scsi_id = scsi_id;"
    },
    {
        "line": 145,
        "fullcodeline": "pDev->scsi_lun = scsi_lun;"
    },
    {
        "line": 146,
        "fullcodeline": "pDev->pI2o_dev = d;"
    },
    {
        "line": 147,
        "fullcodeline": "d->owner = pDev;"
    },
    {
        "line": 148,
        "fullcodeline": "pDev->type = (buf[0])&0xff;"
    },
    {
        "line": 149,
        "fullcodeline": "pDev->flags = (buf[0]>>8)&0xff;"
    },
    {
        "line": 33,
        "fullcodeline": "lct->lct_entry[i].class_id != I2O_CLASS_SCSI_PERIPHERAL &&"
    },
    {
        "line": 120,
        "fullcodeline": "if(bus_no >= MAX_CHANNEL) {\t// Something wrong skip it"
    },
    {
        "line": 123,
        "fullcodeline": "if (scsi_id >= MAX_ID) {"
    },
    {
        "line": 126,
        "fullcodeline": "if( pHba->channel[bus_no].device[scsi_id] == NULL){"
    },
    {
        "line": 150,
        "fullcodeline": "if(scsi_id > pHba->top_scsi_id){"
    },
    {
        "line": 153,
        "fullcodeline": "if(scsi_lun > pHba->top_scsi_lun){"
    },
    {
        "line": 127,
        "fullcodeline": "pDev =  kzalloc(sizeof(struct adpt_device),GFP_KERNEL);"
    },
    {
        "line": 131,
        "fullcodeline": "pHba->channel[bus_no].device[scsi_id] = pDev;"
    },
    {
        "line": 151,
        "fullcodeline": "pHba->top_scsi_id = scsi_id;"
    },
    {
        "line": 154,
        "fullcodeline": "pHba->top_scsi_lun = scsi_lun;"
    },
    {
        "line": 128,
        "fullcodeline": "if(pDev == NULL) {"
    },
    {
        "line": 136,
        "fullcodeline": "pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);"
    },
    {
        "line": 140,
        "fullcodeline": "pDev = pDev->next_lun;"
    },
    {
        "line": 134,
        "fullcodeline": "pDev->next_lun; pDev = pDev->next_lun){"
    },
    {
        "line": 137,
        "fullcodeline": "if(pDev->next_lun == NULL) {"
    },
    {
        "line": 129,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 133,
        "fullcodeline": "for( pDev = pHba->channel[bus_no].device[scsi_id];"
    },
    {
        "line": 138,
        "fullcodeline": "return -ENOMEM;"
    }
]