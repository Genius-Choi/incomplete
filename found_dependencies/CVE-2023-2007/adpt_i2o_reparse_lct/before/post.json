[
    {
        "line": 7,
        "fullcodeline": "i2o_lct *lct = pHba->lct;"
    },
    {
        "line": 8,
        "fullcodeline": "u8 bus_no = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "u32 buf[10]; // at least 8 u32's"
    },
    {
        "line": 12,
        "fullcodeline": "struct adpt_device* pDev = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "struct i2o_device* pI2o_dev = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "max = lct->table_size;"
    },
    {
        "line": 21,
        "fullcodeline": "max -= 3;"
    },
    {
        "line": 22,
        "fullcodeline": "max /= 9;"
    },
    {
        "line": 15,
        "fullcodeline": "if (lct == NULL) {"
    },
    {
        "line": 25,
        "fullcodeline": "for (d = pHba->devices; d; d = d->next) {"
    },
    {
        "line": 35,
        "fullcodeline": "for(i=0;i<max;i++) {"
    },
    {
        "line": 149,
        "fullcodeline": "for (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {"
    },
    {
        "line": 26,
        "fullcodeline": "pDev =(struct adpt_device*) d->owner;"
    },
    {
        "line": 30,
        "fullcodeline": "pDev->state |= DPTI_DEV_UNSCANNED;"
    },
    {
        "line": 150,
        "fullcodeline": "pDev =(struct adpt_device*) pI2o_dev->owner;"
    },
    {
        "line": 17,
        "fullcodeline": "return -1;"
    },
    {
        "line": 27,
        "fullcodeline": "if(!pDev){"
    },
    {
        "line": 36,
        "fullcodeline": "if( lct->lct_entry[i].user_tid != 0xfff){"
    },
    {
        "line": 40,
        "fullcodeline": "if( lct->lct_entry[i].class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||"
    },
    {
        "line": 151,
        "fullcodeline": "if(!pDev){"
    },
    {
        "line": 156,
        "fullcodeline": "if (pDev->state & DPTI_DEV_UNSCANNED){"
    },
    {
        "line": 42,
        "fullcodeline": "lct->lct_entry[i].class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){"
    },
    {
        "line": 48,
        "fullcodeline": "bus_no = buf[0]>>16;"
    },
    {
        "line": 56,
        "fullcodeline": "scsi_id = buf[1];"
    },
    {
        "line": 57,
        "fullcodeline": "scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);"
    },
    {
        "line": 58,
        "fullcodeline": "pDev = pHba->channel[bus_no].device[scsi_id];"
    },
    {
        "line": 157,
        "fullcodeline": "pDev->state = DPTI_DEV_OFFLINE;"
    },
    {
        "line": 41,
        "fullcodeline": "lct->lct_entry[i].class_id == I2O_CLASS_SCSI_PERIPHERAL ||"
    },
    {
        "line": 44,
        "fullcodeline": "if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (bus_no >= MAX_CHANNEL) {\t/* Something wrong skip it */"
    },
    {
        "line": 66,
        "fullcodeline": "if(!pDev ) { // Something new add it"
    },
    {
        "line": 64,
        "fullcodeline": "pDev = pDev->next_lun;"
    },
    {
        "line": 67,
        "fullcodeline": "d = kmalloc(sizeof(struct i2o_device),"
    },
    {
        "line": 75,
        "fullcodeline": "d->controller = pHba;"
    },
    {
        "line": 76,
        "fullcodeline": "d->next = NULL;"
    },
    {
        "line": 78,
        "fullcodeline": "memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));"
    },
    {
        "line": 80,
        "fullcodeline": "d->flags = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "adpt_i2o_report_hba_unit(pHba, d);"
    },
    {
        "line": 82,
        "fullcodeline": "adpt_i2o_install_device(pHba, d);"
    },
    {
        "line": 105,
        "fullcodeline": "pDev->scsi_channel = bus_no;"
    },
    {
        "line": 106,
        "fullcodeline": "pDev->scsi_id = scsi_id;"
    },
    {
        "line": 107,
        "fullcodeline": "pDev->scsi_lun = scsi_lun;"
    },
    {
        "line": 108,
        "fullcodeline": "pDev->pI2o_dev = d;"
    },
    {
        "line": 109,
        "fullcodeline": "d->owner = pDev;"
    },
    {
        "line": 110,
        "fullcodeline": "pDev->type = (buf[0])&0xff;"
    },
    {
        "line": 111,
        "fullcodeline": "pDev->flags = (buf[0]>>8)&0xff;"
    },
    {
        "line": 145,
        "fullcodeline": "pDev = pDev->next_lun;"
    },
    {
        "line": 160,
        "fullcodeline": "scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);"
    },
    {
        "line": 61,
        "fullcodeline": "if(pDev->scsi_lun == scsi_lun) {"
    },
    {
        "line": 69,
        "fullcodeline": "if(d==NULL)"
    },
    {
        "line": 85,
        "fullcodeline": "if( pDev == NULL){"
    },
    {
        "line": 113,
        "fullcodeline": "if(scsi_id > pHba->top_scsi_id){"
    },
    {
        "line": 116,
        "fullcodeline": "if(scsi_lun > pHba->top_scsi_lun){"
    },
    {
        "line": 124,
        "fullcodeline": "if(pDev->scsi_lun == scsi_lun) {"
    },
    {
        "line": 86,
        "fullcodeline": "pDev ="
    },
    {
        "line": 92,
        "fullcodeline": "pHba->channel[bus_no].device[scsi_id] = pDev;"
    },
    {
        "line": 114,
        "fullcodeline": "pHba->top_scsi_id = scsi_id;"
    },
    {
        "line": 117,
        "fullcodeline": "pHba->top_scsi_lun = scsi_lun;"
    },
    {
        "line": 132,
        "fullcodeline": "d = pDev->pI2o_dev;"
    },
    {
        "line": 142,
        "fullcodeline": "pDev->state = DPTI_DEV_ONLINE;"
    },
    {
        "line": 72,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 87,
        "fullcodeline": "kzalloc(sizeof(struct adpt_device),"
    },
    {
        "line": 89,
        "fullcodeline": "if(pDev == NULL) {"
    },
    {
        "line": 97,
        "fullcodeline": "pDev = pDev->next_lun ="
    },
    {
        "line": 125,
        "fullcodeline": "if(!scsi_device_online(pDev->pScsi_dev)) {"
    },
    {
        "line": 133,
        "fullcodeline": "if(d->lct_data.tid != tid) { // something changed"
    },
    {
        "line": 100,
        "fullcodeline": "if(pDev == NULL) {"
    },
    {
        "line": 134,
        "fullcodeline": "pDev->tid = tid;"
    },
    {
        "line": 135,
        "fullcodeline": "memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));"
    },
    {
        "line": 90,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 95,
        "fullcodeline": "pDev = pDev->next_lun;"
    },
    {
        "line": 98,
        "fullcodeline": "kzalloc(sizeof(struct adpt_device),"
    },
    {
        "line": 101,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 129,
        "fullcodeline": "scsi_device_set_state(pDev->pScsi_dev, SDEV_RUNNING);"
    },
    {
        "line": 137,
        "fullcodeline": "pDev->pScsi_dev->changed = TRUE;"
    },
    {
        "line": 138,
        "fullcodeline": "pDev->pScsi_dev->removable = TRUE;"
    }
]