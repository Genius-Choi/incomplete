[
    {
        "line": 3,
        "fullcodeline": "int lfcrending = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "OUT_COPY_BYTE_OR_RETURN(connp);"
    },
    {
        "line": 6,
        "fullcodeline": "if (connp->out_status == HTP_STREAM_CLOSED) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (connp->out_next_byte != LF && connp->out_next_byte != CR) {"
    },
    {
        "line": 8,
        "fullcodeline": "htp_status_t rc = htp_connp_res_receiver_finalize_clear(connp);"
    },
    {
        "line": 12,
        "fullcodeline": "rc = htp_hook_run_all(connp->cfg->hook_response_trailer, connp->out_tx);"
    },
    {
        "line": 15,
        "fullcodeline": "connp->out_state = htp_connp_RES_FINALIZE;"
    },
    {
        "line": 22,
        "fullcodeline": "lfcrending = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "if (rc != HTP_OK) return rc;"
    },
    {
        "line": 13,
        "fullcodeline": "if (rc != HTP_OK) return rc;"
    },
    {
        "line": 24,
        "fullcodeline": "endwithcr = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "int next_no_lf = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "htp_chomp(data, &len);"
    },
    {
        "line": 200,
        "fullcodeline": "htp_connp_res_clear_buffer(connp);"
    },
    {
        "line": 25,
        "fullcodeline": "if (connp->out_next_byte == CR) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (htp_connp_res_consolidate_data(connp, &data, &len) != HTP_OK) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (endwithcr && len < 2) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (connp->out_current_read_offset < connp->out_current_len &&"
    },
    {
        "line": 85,
        "fullcodeline": "if (htp_connp_is_line_terminator(connp, data, len, next_no_lf)) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (htp_connp_is_line_folded(data, len) == 0) {"
    },
    {
        "line": 26,
        "fullcodeline": "OUT_PEEK_NEXT(connp);"
    },
    {
        "line": 50,
        "fullcodeline": "lfcrending = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "endwithcr = 1;"
    },
    {
        "line": 81,
        "fullcodeline": "connp->out_current_data[connp->out_current_read_offset] != LF) {"
    },
    {
        "line": 82,
        "fullcodeline": "next_no_lf = 1;"
    },
    {
        "line": 95,
        "fullcodeline": "htp_connp_res_clear_buffer(connp);"
    },
    {
        "line": 136,
        "fullcodeline": "OUT_PEEK_NEXT(connp);"
    },
    {
        "line": 27,
        "fullcodeline": "if (connp->out_next_byte == -1) {"
    },
    {
        "line": 54,
        "fullcodeline": "OUT_PEEK_NEXT(connp);"
    },
    {
        "line": 55,
        "fullcodeline": "lfcrending = 0;"
    },
    {
        "line": 87,
        "fullcodeline": "if (connp->out_header != NULL) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (connp->out_tx->response_progress == HTP_RESPONSE_HEADERS) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (connp->out_header != NULL) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (htp_is_folding_char(connp->out_next_byte) == 0) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (connp->out_next_byte == CR) {"
    },
    {
        "line": 91,
        "fullcodeline": "bstr_free(connp->out_header);"
    },
    {
        "line": 92,
        "fullcodeline": "connp->out_header = NULL;"
    },
    {
        "line": 102,
        "fullcodeline": "connp->out_state = htp_connp_RES_BODY_DETERMINE;"
    },
    {
        "line": 132,
        "fullcodeline": "bstr_free(connp->out_header);"
    },
    {
        "line": 133,
        "fullcodeline": "connp->out_header = NULL;"
    },
    {
        "line": 148,
        "fullcodeline": "if (connp->out_header == NULL) {"
    },
    {
        "line": 58,
        "fullcodeline": "OUT_COPY_BYTE_OR_RETURN(connp);"
    },
    {
        "line": 59,
        "fullcodeline": "lfcrending = 1;"
    },
    {
        "line": 88,
        "fullcodeline": "if (connp->cfg->process_response_header(connp, bstr_ptr(connp->out_header),"
    },
    {
        "line": 107,
        "fullcodeline": "htp_status_t rc = htp_connp_res_receiver_finalize_clear(connp);"
    },
    {
        "line": 111,
        "fullcodeline": "rc = htp_hook_run_all(connp->cfg->hook_response_trailer, connp->out_tx);"
    },
    {
        "line": 115,
        "fullcodeline": "connp->out_state = htp_connp_RES_FINALIZE;"
    },
    {
        "line": 129,
        "fullcodeline": "if (connp->cfg->process_response_header(connp, bstr_ptr(connp->out_header),"
    },
    {
        "line": 140,
        "fullcodeline": "if (connp->cfg->process_response_header(connp, data, len) != HTP_OK) return HTP_ERROR;"
    },
    {
        "line": 143,
        "fullcodeline": "connp->out_header = bstr_dup_mem(data, len);"
    },
    {
        "line": 158,
        "fullcodeline": "size_t trim = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "connp->out_header = bstr_dup_mem(data + trim, len - trim);"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (connp->out_next_byte == LF) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (rc != HTP_OK) return rc;"
    },
    {
        "line": 112,
        "fullcodeline": "if (rc != HTP_OK) return rc;"
    },
    {
        "line": 144,
        "fullcodeline": "if (connp->out_header == NULL) return HTP_ERROR;"
    },
    {
        "line": 152,
        "fullcodeline": "if (!(connp->out_tx->flags & HTP_INVALID_FOLDING)) {"
    },
    {
        "line": 159,
        "fullcodeline": "while(trim < len) {"
    },
    {
        "line": 166,
        "fullcodeline": "if (connp->out_header == NULL) return HTP_ERROR;"
    },
    {
        "line": 168,
        "fullcodeline": "size_t colon_pos = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "OUT_COPY_BYTE_OR_RETURN(connp);"
    },
    {
        "line": 89,
        "fullcodeline": "bstr_len(connp->out_header)) != HTP_OK) return HTP_ERROR;"
    },
    {
        "line": 130,
        "fullcodeline": "bstr_len(connp->out_header)) != HTP_OK) return HTP_ERROR;"
    },
    {
        "line": 153,
        "fullcodeline": "connp->out_tx->flags |= HTP_INVALID_FOLDING;"
    },
    {
        "line": 154,
        "fullcodeline": "htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Invalid response field folding\");"
    },
    {
        "line": 163,
        "fullcodeline": "trim++;"
    },
    {
        "line": 169,
        "fullcodeline": "while ((colon_pos < len) && (data[colon_pos] != ':')) colon_pos++;"
    },
    {
        "line": 171,
        "fullcodeline": "if (colon_pos < len &&"
    },
    {
        "line": 160,
        "fullcodeline": "if (!htp_is_folding_char(data[trim])) {"
    },
    {
        "line": 173,
        "fullcodeline": "connp->out_tx->response_protocol_number == HTP_PROTOCOL_1_1) {"
    },
    {
        "line": 182,
        "fullcodeline": "bstr_free(connp->out_header);"
    },
    {
        "line": 183,
        "fullcodeline": "connp->out_header = bstr_dup_mem(data+1, len-1);"
    },
    {
        "line": 34,
        "fullcodeline": "OUT_PEEK_NEXT(connp);"
    },
    {
        "line": 47,
        "fullcodeline": "} else if (connp->out_next_byte == CR) {"
    },
    {
        "line": 172,
        "fullcodeline": "bstr_chr(connp->out_header, ':') >= 0 &&"
    },
    {
        "line": 175,
        "fullcodeline": "if (!(connp->out_tx->flags & HTP_INVALID_FOLDING)) {"
    },
    {
        "line": 179,
        "fullcodeline": "if (connp->cfg->process_response_header(connp, bstr_ptr(connp->out_header),"
    },
    {
        "line": 184,
        "fullcodeline": "if (connp->out_header == NULL)"
    },
    {
        "line": 35,
        "fullcodeline": "if (connp->out_next_byte == CR) {"
    },
    {
        "line": 176,
        "fullcodeline": "connp->out_tx->flags |= HTP_INVALID_FOLDING;"
    },
    {
        "line": 177,
        "fullcodeline": "htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Invalid response field folding\");"
    },
    {
        "line": 188,
        "fullcodeline": "if (bstr_len(connp->out_header) < HTP_MAX_HEADER_FOLDED) {"
    },
    {
        "line": 36,
        "fullcodeline": "OUT_COPY_BYTE_OR_RETURN(connp);"
    },
    {
        "line": 37,
        "fullcodeline": "connp->out_current_consume_offset++;"
    },
    {
        "line": 38,
        "fullcodeline": "OUT_PEEK_NEXT(connp);"
    },
    {
        "line": 180,
        "fullcodeline": "bstr_len(connp->out_header)) != HTP_OK)"
    },
    {
        "line": 189,
        "fullcodeline": "bstr *new_out_header = bstr_add_mem(connp->out_header, data, len);"
    },
    {
        "line": 192,
        "fullcodeline": "connp->out_header = new_out_header;"
    },
    {
        "line": 39,
        "fullcodeline": "if (connp->out_next_byte == LF) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (new_out_header == NULL)"
    },
    {
        "line": 194,
        "fullcodeline": "htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Response field length exceeds folded maximum\");"
    },
    {
        "line": 40,
        "fullcodeline": "OUT_COPY_BYTE_OR_RETURN(connp);"
    },
    {
        "line": 41,
        "fullcodeline": "connp->out_current_consume_offset++;"
    },
    {
        "line": 42,
        "fullcodeline": "htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0,"
    }
]