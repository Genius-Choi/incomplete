[
    {
        "line": 11,
        "fullcodeline": "const bool self_signed_ee_cert = (cert_path.size() == 1);"
    },
    {
        "line": 13,
        "fullcodeline": "X509_Time validation_time(ref_time);"
    },
    {
        "line": 15,
        "fullcodeline": "CertificatePathStatusCodes cert_status(cert_path.size());"
    },
    {
        "line": 147,
        "fullcodeline": "size_t max_path_length = cert_path.size();"
    },
    {
        "line": 8,
        "fullcodeline": "if(cert_path.empty())"
    },
    {
        "line": 17,
        "fullcodeline": "if(!hostname.empty() && !cert_path[0]->matches_dns_name(hostname))"
    },
    {
        "line": 20,
        "fullcodeline": "if(!cert_path[0]->allowed_usage(usage))"
    },
    {
        "line": 23,
        "fullcodeline": "if(cert_path[0]->is_CA_cert() == false &&"
    },
    {
        "line": 37,
        "fullcodeline": "for(size_t i = 0; i != cert_path.size(); ++i)"
    },
    {
        "line": 148,
        "fullcodeline": "for(size_t i = cert_path.size() - 1; i > 0 ; --i)"
    },
    {
        "line": 21,
        "fullcodeline": "cert_status[0].insert(Certificate_Status_Code::INVALID_USAGE);"
    },
    {
        "line": 24,
        "fullcodeline": "cert_path[0]->has_constraints(KEY_CERT_SIGN))"
    },
    {
        "line": 34,
        "fullcodeline": "cert_status[0].insert(Certificate_Status_Code::INVALID_USAGE);"
    },
    {
        "line": 39,
        "fullcodeline": "std::set<Certificate_Status_Code>& status = cert_status.at(i);"
    },
    {
        "line": 41,
        "fullcodeline": "const bool at_self_signed_root = (i == cert_path.size() - 1);"
    },
    {
        "line": 43,
        "fullcodeline": "const std::shared_ptr<const X509_Certificate>& subject = cert_path[i];"
    },
    {
        "line": 45,
        "fullcodeline": "const std::shared_ptr<const X509_Certificate>& issuer = cert_path[at_self_signed_root ? (i) : (i + 1)];"
    },
    {
        "line": 86,
        "fullcodeline": "std::unique_ptr<Public_Key> issuer_key(issuer->subject_public_key());"
    },
    {
        "line": 130,
        "fullcodeline": "Extensions extensions = subject->v3_extensions();"
    },
    {
        "line": 131,
        "fullcodeline": "const auto& extensions_vec = extensions.extensions();"
    },
    {
        "line": 150,
        "fullcodeline": "std::set<Certificate_Status_Code>& status = cert_status.at(i);"
    },
    {
        "line": 151,
        "fullcodeline": "const std::shared_ptr<const X509_Certificate>& subject = cert_path[i];"
    },
    {
        "line": 9,
        "fullcodeline": "throw Invalid_Argument(\"PKIX::check_chain cert_path empty\");"
    },
    {
        "line": 47,
        "fullcodeline": "if(at_self_signed_root && (issuer->is_self_signed() == false))"
    },
    {
        "line": 52,
        "fullcodeline": "if(subject->issuer_dn() != issuer->subject_dn())"
    },
    {
        "line": 58,
        "fullcodeline": "if(subject->is_serial_negative())"
    },
    {
        "line": 76,
        "fullcodeline": "if(validation_time < subject->not_before())"
    },
    {
        "line": 79,
        "fullcodeline": "if(validation_time > subject->not_after())"
    },
    {
        "line": 83,
        "fullcodeline": "if(!issuer->is_CA_cert() && !self_signed_ee_cert)"
    },
    {
        "line": 89,
        "fullcodeline": "if(OIDS::oid2str_or_empty(subject->signature_algorithm().get_oid()).empty())"
    },
    {
        "line": 121,
        "fullcodeline": "if(subject->x509_version() == 1)"
    },
    {
        "line": 132,
        "fullcodeline": "if(subject->x509_version() < 3 && !extensions_vec.empty())"
    },
    {
        "line": 140,
        "fullcodeline": "if(extensions.extensions().size() != extensions.get_extension_oids().size())"
    },
    {
        "line": 157,
        "fullcodeline": "if(subject->subject_dn() != subject->issuer_dn())"
    },
    {
        "line": 173,
        "fullcodeline": "if(subject->path_limit() != Cert_Extension::NO_CERT_PATH_LIMIT && subject->path_limit() < max_path_length)"
    },
    {
        "line": 49,
        "fullcodeline": "status.insert(Certificate_Status_Code::CHAIN_LACKS_TRUST_ROOT);"
    },
    {
        "line": 54,
        "fullcodeline": "status.insert(Certificate_Status_Code::CHAIN_NAME_MISMATCH);"
    },
    {
        "line": 60,
        "fullcodeline": "status.insert(Certificate_Status_Code::CERT_SERIAL_NEGATIVE);"
    },
    {
        "line": 67,
        "fullcodeline": "const size_t dn_ub = X509_DN::lookup_ub(dn_pair.first);"
    },
    {
        "line": 77,
        "fullcodeline": "status.insert(Certificate_Status_Code::CERT_NOT_YET_VALID);"
    },
    {
        "line": 80,
        "fullcodeline": "status.insert(Certificate_Status_Code::CERT_HAS_EXPIRED);"
    },
    {
        "line": 84,
        "fullcodeline": "status.insert(Certificate_Status_Code::CA_CERT_NOT_FOR_CERT_ISSUER);"
    },
    {
        "line": 91,
        "fullcodeline": "status.insert(Certificate_Status_Code::SIGNATURE_ALGO_UNKNOWN);"
    },
    {
        "line": 134,
        "fullcodeline": "status.insert(Certificate_Status_Code::EXT_IN_V1_V2_CERT);"
    },
    {
        "line": 138,
        "fullcodeline": "extension.first->validate(*subject, *issuer, cert_path, cert_status, i);"
    },
    {
        "line": 142,
        "fullcodeline": "status.insert(Certificate_Status_Code::DUPLICATE_CERT_EXTENSION);"
    },
    {
        "line": 175,
        "fullcodeline": "max_path_length = subject->path_limit();"
    },
    {
        "line": 69,
        "fullcodeline": "if(dn_ub > 0 && dn_pair.second.size() > dn_ub)"
    },
    {
        "line": 123,
        "fullcodeline": "if(subject->v2_issuer_key_id().empty() == false ||"
    },
    {
        "line": 159,
        "fullcodeline": "if(max_path_length > 0)"
    },
    {
        "line": 71,
        "fullcodeline": "status.insert(Certificate_Status_Code::DN_TOO_LONG);"
    },
    {
        "line": 96,
        "fullcodeline": "if(!issuer_key)"
    },
    {
        "line": 112,
        "fullcodeline": "if(trusted_hashes.size() > 0 && !at_self_signed_root)"
    },
    {
        "line": 124,
        "fullcodeline": "subject->v2_subject_key_id().empty() == false)"
    },
    {
        "line": 126,
        "fullcodeline": "status.insert(Certificate_Status_Code::V2_IDENTIFIERS_IN_V1_CERT);"
    },
    {
        "line": 161,
        "fullcodeline": "--max_path_length;"
    },
    {
        "line": 98,
        "fullcodeline": "status.insert(Certificate_Status_Code::CERT_PUBKEY_INVALID);"
    },
    {
        "line": 165,
        "fullcodeline": "status.insert(Certificate_Status_Code::CERT_CHAIN_TOO_LONG);"
    },
    {
        "line": 102,
        "fullcodeline": "const Certificate_Status_Code sig_status = subject->verify_signature(*issuer_key);"
    },
    {
        "line": 114,
        "fullcodeline": "if(trusted_hashes.count(subject->hash_used_for_signature()) == 0)"
    },
    {
        "line": 104,
        "fullcodeline": "if(sig_status != Certificate_Status_Code::VERIFIED)"
    },
    {
        "line": 107,
        "fullcodeline": "if(issuer_key->estimated_strength() < min_signature_algo_strength)"
    },
    {
        "line": 115,
        "fullcodeline": "status.insert(Certificate_Status_Code::UNTRUSTED_HASH);"
    },
    {
        "line": 105,
        "fullcodeline": "status.insert(sig_status);"
    },
    {
        "line": 108,
        "fullcodeline": "status.insert(Certificate_Status_Code::SIGNATURE_METHOD_TOO_WEAK);"
    }
]