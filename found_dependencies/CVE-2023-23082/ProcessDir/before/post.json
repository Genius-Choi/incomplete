[
    {
        "line": 12,
        "fullcodeline": "char IndentString[25];"
    },
    {
        "line": 13,
        "fullcodeline": "memset(IndentString, ' ', 25);"
    },
    {
        "line": 14,
        "fullcodeline": "IndentString[NestingLevel * 4] = '\\0';"
    },
    {
        "line": 17,
        "fullcodeline": "int NumDirEntries = Get16((const void*)DirStart, m_MotorolaOrder);"
    },
    {
        "line": 19,
        "fullcodeline": "const unsigned char* const DirEnd = DIR_ENTRY_ADDR(DirStart, NumDirEntries);"
    },
    {
        "line": 6,
        "fullcodeline": "if (NestingLevel > 4)"
    },
    {
        "line": 20,
        "fullcodeline": "if (DirEnd+4 > (OffsetBase+ExifLength))"
    },
    {
        "line": 34,
        "fullcodeline": "for (int de=0;de<NumDirEntries;de++)"
    },
    {
        "line": 373,
        "fullcodeline": "if (DIR_ENTRY_ADDR(DirStart, NumDirEntries) + 4 <= OffsetBase+ExifLength)"
    },
    {
        "line": 8,
        "fullcodeline": "ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);"
    },
    {
        "line": 39,
        "fullcodeline": "const unsigned char* const DirEntry = DIR_ENTRY_ADDR(DirStart, de);"
    },
    {
        "line": 41,
        "fullcodeline": "Tag = Get16(DirEntry, m_MotorolaOrder);"
    },
    {
        "line": 42,
        "fullcodeline": "Format = Get16(DirEntry+2, m_MotorolaOrder);"
    },
    {
        "line": 43,
        "fullcodeline": "Components = Get32(DirEntry+4, m_MotorolaOrder);"
    },
    {
        "line": 57,
        "fullcodeline": "ByteCount = Components * BytesPerFormat[Format - 1];"
    },
    {
        "line": 375,
        "fullcodeline": "Offset = (unsigned)Get32(DirStart+2+12*NumDirEntries, m_MotorolaOrder);"
    },
    {
        "line": 412,
        "fullcodeline": "m_ExifInfo->ThumbnailAtEnd = false;"
    },
    {
        "line": 22,
        "fullcodeline": "if (DirEnd+2 == OffsetBase+ExifLength || DirEnd == OffsetBase+ExifLength)"
    },
    {
        "line": 45,
        "fullcodeline": "if (Format <= 0 || Format > NUM_FORMATS)"
    },
    {
        "line": 51,
        "fullcodeline": "if ((unsigned)Components > 0x10000)"
    },
    {
        "line": 59,
        "fullcodeline": "if (ByteCount > 4)"
    },
    {
        "line": 414,
        "fullcodeline": "if (m_ExifInfo->ThumbnailOffset <= ExifLength)"
    },
    {
        "line": 47,
        "fullcodeline": "ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);"
    },
    {
        "line": 53,
        "fullcodeline": "ErrNonfatal(\"Illegal number of components %d for tag %04x\", Components, Tag);"
    },
    {
        "line": 62,
        "fullcodeline": "OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);"
    },
    {
        "line": 70,
        "fullcodeline": "ValuePtr = (unsigned char*)(const_cast<unsigned char*>(OffsetBase)+OffsetVal);"
    },
    {
        "line": 116,
        "fullcodeline": "case TAG_FOCALPLANEXRES:    m_FocalPlaneXRes  = ConvertAnyFormat(ValuePtr, Format);               break;"
    },
    {
        "line": 117,
        "fullcodeline": "case TAG_THUMBNAIL_OFFSET:  m_ExifInfo->ThumbnailOffset = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;"
    },
    {
        "line": 118,
        "fullcodeline": "case TAG_THUMBNAIL_LENGTH:  m_ExifInfo->ThumbnailSize   = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;"
    },
    {
        "line": 198,
        "fullcodeline": "m_ExifInfo->ApertureFNumber = (float)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 214,
        "fullcodeline": "m_ExifInfo->FocalLength = (float)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 246,
        "fullcodeline": "m_ExifInfo->FlashUsed = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 250,
        "fullcodeline": "m_ExifInfo->Orientation = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 283,
        "fullcodeline": "m_ExifInfo->ExposureBias = (float)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 287,
        "fullcodeline": "m_ExifInfo->Whitebalance = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 292,
        "fullcodeline": "m_ExifInfo->LightSource = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 296,
        "fullcodeline": "m_ExifInfo->MeteringMode = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 300,
        "fullcodeline": "m_ExifInfo->ExposureProgram = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 314,
        "fullcodeline": "m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 320,
        "fullcodeline": "m_ExifInfo->ExposureMode = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 324,
        "fullcodeline": "m_ExifInfo->DigitalZoomRatio = (float)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 362,
        "fullcodeline": "m_ExifInfo->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 378,
        "fullcodeline": "const unsigned char* const SubdirStart = OffsetBase + Offset;"
    },
    {
        "line": 29,
        "fullcodeline": "ErrNonfatal(\"Illegally sized directory\", 0,0);"
    },
    {
        "line": 64,
        "fullcodeline": "if (OffsetVal+ByteCount > ExifLength)"
    },
    {
        "line": 72,
        "fullcodeline": "if (OffsetVal > m_LargestExifOffset)"
    },
    {
        "line": 80,
        "fullcodeline": "ValuePtr = (unsigned char*)(const_cast<unsigned char*>(DirEntry)+8);"
    },
    {
        "line": 89,
        "fullcodeline": "int length = max(ByteCount, 0);"
    },
    {
        "line": 90,
        "fullcodeline": "length = min(length, MAX_COMMENT);"
    },
    {
        "line": 91,
        "fullcodeline": "strncpy(m_ExifInfo->Description, (char *)ValuePtr, length);"
    },
    {
        "line": 92,
        "fullcodeline": "m_ExifInfo->Description[length] = '\\0';"
    },
    {
        "line": 162,
        "fullcodeline": "m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNKNOWN;"
    },
    {
        "line": 164,
        "fullcodeline": "const int EXIF_COMMENT_CHARSET_LENGTH = 8;"
    },
    {
        "line": 188,
        "fullcodeline": "m_ExifInfo->XPCommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;"
    },
    {
        "line": 189,
        "fullcodeline": "size_t length = min(ByteCount, MAX_COMMENT);"
    },
    {
        "line": 190,
        "fullcodeline": "memcpy(m_ExifInfo->XPComment, ValuePtr, length);"
    },
    {
        "line": 191,
        "fullcodeline": "m_ExifInfo->XPComment[length] = '\\0';"
    },
    {
        "line": 205,
        "fullcodeline": "if (m_ExifInfo->ApertureFNumber == 0)"
    },
    {
        "line": 221,
        "fullcodeline": "float distance = (float)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 222,
        "fullcodeline": "m_ExifInfo->Distance = distance;"
    },
    {
        "line": 230,
        "fullcodeline": "float expTime = (float)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 239,
        "fullcodeline": "if (m_ExifInfo->ExposureTime == 0)"
    },
    {
        "line": 251,
        "fullcodeline": "if (m_ExifInfo->Orientation < 0 || m_ExifInfo->Orientation > 8)"
    },
    {
        "line": 263,
        "fullcodeline": "int a = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 269,
        "fullcodeline": "switch((int)ConvertAnyFormat(ValuePtr, Format))"
    },
    {
        "line": 304,
        "fullcodeline": "if (m_ExifInfo->ISOequivalent == 0)"
    },
    {
        "line": 315,
        "fullcodeline": "if (m_ExifInfo->ISOequivalent < 50)"
    },
    {
        "line": 330,
        "fullcodeline": "const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);"
    },
    {
        "line": 345,
        "fullcodeline": "const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);"
    },
    {
        "line": 379,
        "fullcodeline": "if (SubdirStart > OffsetBase+ExifLength || SubdirStart < OffsetBase)"
    },
    {
        "line": 399,
        "fullcodeline": "if (Offset > m_LargestExifOffset)"
    },
    {
        "line": 416,
        "fullcodeline": "if (m_ExifInfo->ThumbnailSize > ExifLength - m_ExifInfo->ThumbnailOffset)"
    },
    {
        "line": 67,
        "fullcodeline": "ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);"
    },
    {
        "line": 74,
        "fullcodeline": "m_LargestExifOffset = OffsetVal;"
    },
    {
        "line": 98,
        "fullcodeline": "if (space > 0)"
    },
    {
        "line": 108,
        "fullcodeline": "if (space > 0)"
    },
    {
        "line": 128,
        "fullcodeline": "if (space > 0)"
    },
    {
        "line": 140,
        "fullcodeline": "if (!m_DateFound)"
    },
    {
        "line": 165,
        "fullcodeline": "if (ByteCount >= EXIF_COMMENT_CHARSET_LENGTH)"
    },
    {
        "line": 207,
        "fullcodeline": "m_ExifInfo->ApertureFNumber = (float)exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)*0.5);"
    },
    {
        "line": 241,
        "fullcodeline": "m_ExifInfo->ExposureTime = (float)(1/exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)));"
    },
    {
        "line": 253,
        "fullcodeline": "ErrNonfatal(\"Undefined rotation value %d\", m_ExifInfo->Orientation, 0);"
    },
    {
        "line": 254,
        "fullcodeline": "m_ExifInfo->Orientation = 0;"
    },
    {
        "line": 264,
        "fullcodeline": "if (m_ExifImageWidth < a) m_ExifImageWidth = a;"
    },
    {
        "line": 274,
        "fullcodeline": "case 1: m_FocalPlaneUnits = 25.4; break;  // inch"
    },
    {
        "line": 275,
        "fullcodeline": "case 2: m_FocalPlaneUnits = 25.4; break;"
    },
    {
        "line": 276,
        "fullcodeline": "case 3: m_FocalPlaneUnits = 10;   break;  // centimeter"
    },
    {
        "line": 277,
        "fullcodeline": "case 4: m_FocalPlaneUnits = 1;    break;  // millimeter"
    },
    {
        "line": 278,
        "fullcodeline": "case 5: m_FocalPlaneUnits = .001; break;  // micrometer"
    },
    {
        "line": 309,
        "fullcodeline": "m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);"
    },
    {
        "line": 316,
        "fullcodeline": "m_ExifInfo->ISOequivalent *= 200;          // Fixes strange encoding on some older digicams."
    },
    {
        "line": 331,
        "fullcodeline": "if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)"
    },
    {
        "line": 346,
        "fullcodeline": "if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)"
    },
    {
        "line": 401,
        "fullcodeline": "m_LargestExifOffset = Offset;"
    },
    {
        "line": 421,
        "fullcodeline": "m_ExifInfo->ThumbnailSize = ExifLength - m_ExifInfo->ThumbnailOffset;"
    },
    {
        "line": 100,
        "fullcodeline": "strncpy(m_ExifInfo->CameraMake, (char *)ValuePtr, space - 1);"
    },
    {
        "line": 101,
        "fullcodeline": "m_ExifInfo->CameraMake[space - 1] = '\\0';"
    },
    {
        "line": 110,
        "fullcodeline": "strncpy(m_ExifInfo->CameraModel, (char *)ValuePtr, space - 1);"
    },
    {
        "line": 111,
        "fullcodeline": "m_ExifInfo->CameraModel[space - 1] = '\\0';"
    },
    {
        "line": 130,
        "fullcodeline": "strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);"
    },
    {
        "line": 131,
        "fullcodeline": "m_ExifInfo->DateTime[space - 1] = '\\0';"
    },
    {
        "line": 133,
        "fullcodeline": "m_DateFound = true;"
    },
    {
        "line": 176,
        "fullcodeline": "int length = ByteCount - EXIF_COMMENT_CHARSET_LENGTH;"
    },
    {
        "line": 177,
        "fullcodeline": "length = min(length, MAX_COMMENT);"
    },
    {
        "line": 178,
        "fullcodeline": "memcpy(m_ExifInfo->Comments, ValuePtr + EXIF_COMMENT_CHARSET_LENGTH, length);"
    },
    {
        "line": 179,
        "fullcodeline": "m_ExifInfo->Comments[length] = '\\0';"
    },
    {
        "line": 232,
        "fullcodeline": "m_ExifInfo->ExposureTime = expTime;"
    },
    {
        "line": 333,
        "fullcodeline": "ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);"
    },
    {
        "line": 348,
        "fullcodeline": "ErrNonfatal(\"Illegal GPS directory link\",0,0);"
    },
    {
        "line": 381,
        "fullcodeline": "if (SubdirStart > OffsetBase && SubdirStart < OffsetBase+ExifLength+20)"
    },
    {
        "line": 145,
        "fullcodeline": "if (space > 0)"
    },
    {
        "line": 169,
        "fullcodeline": "if (memcmp(ValuePtr, \"ASCII\", 5) == 0)"
    },
    {
        "line": 337,
        "fullcodeline": "ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);"
    },
    {
        "line": 352,
        "fullcodeline": "ProcessGpsInfo(SubdirStart, ByteCount, OffsetBase, ExifLength);"
    },
    {
        "line": 394,
        "fullcodeline": "if (SubdirStart <= OffsetBase+ExifLength)"
    },
    {
        "line": 147,
        "fullcodeline": "strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);"
    },
    {
        "line": 148,
        "fullcodeline": "m_ExifInfo->DateTime[space - 1] = '\\0';"
    },
    {
        "line": 170,
        "fullcodeline": "m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_ASCII;"
    },
    {
        "line": 389,
        "fullcodeline": "ErrNonfatal(\"Illegal subdirectory link\",0,0);"
    },
    {
        "line": 396,
        "fullcodeline": "ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);"
    },
    {
        "line": 171,
        "fullcodeline": "else if (memcmp(ValuePtr, \"UNICODE\", 7) == 0)"
    },
    {
        "line": 172,
        "fullcodeline": "m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;"
    },
    {
        "line": 173,
        "fullcodeline": "else if (memcmp(ValuePtr, \"JIS\", 3) == 0)"
    },
    {
        "line": 174,
        "fullcodeline": "m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_JIS;"
    }
]