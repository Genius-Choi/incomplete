[
    {
        "line": 8,
        "fullcodeline": "u32 i, k, *newOff, new_chunk_idx=0;"
    },
    {
        "line": 10,
        "fullcodeline": "s32 insert_idx = -1;"
    },
    {
        "line": 13,
        "fullcodeline": "stsc = stbl->SampleToChunk;"
    },
    {
        "line": 85,
        "fullcodeline": "ent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0;"
    },
    {
        "line": 86,
        "fullcodeline": "ent->sampleDescriptionIndex = StreamDescIndex;"
    },
    {
        "line": 87,
        "fullcodeline": "ent->samplesPerChunk = nb_pack;"
    },
    {
        "line": 88,
        "fullcodeline": "ent->nextChunk = ent->firstChunk+1;"
    },
    {
        "line": 18,
        "fullcodeline": "if (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (sampleNumber == stsc->w_lastSampleNumber + 1) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (sampleNumber + nb_pack - 1 == stsc->w_lastSampleNumber) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {"
    },
    {
        "line": 20,
        "fullcodeline": "ALLOC_INC(stsc->alloc_size);"
    },
    {
        "line": 21,
        "fullcodeline": "stsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size);"
    },
    {
        "line": 23,
        "fullcodeline": "memset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) );"
    },
    {
        "line": 26,
        "fullcodeline": "ent = &stsc->entries[stsc->nb_entries];"
    },
    {
        "line": 27,
        "fullcodeline": "stsc->w_lastChunkNumber ++;"
    },
    {
        "line": 28,
        "fullcodeline": "ent->firstChunk = stsc->w_lastChunkNumber;"
    },
    {
        "line": 31,
        "fullcodeline": "new_chunk_idx = stsc->w_lastChunkNumber;"
    },
    {
        "line": 32,
        "fullcodeline": "stsc->w_lastSampleNumber = sampleNumber + nb_pack-1;"
    },
    {
        "line": 33,
        "fullcodeline": "stsc->nb_entries += 1;"
    },
    {
        "line": 95,
        "fullcodeline": "stbl->SampleToChunk->currentIndex = stsc->nb_entries-1;"
    },
    {
        "line": 96,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber;"
    },
    {
        "line": 98,
        "fullcodeline": "stbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber;"
    },
    {
        "line": 99,
        "fullcodeline": "stbl->SampleToChunk->ghostNumber = 1;"
    },
    {
        "line": 112,
        "fullcodeline": "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 19,
        "fullcodeline": "if (!stsc->alloc_size) stsc->alloc_size = 1;"
    },
    {
        "line": 22,
        "fullcodeline": "if (!stsc->entries) return GF_OUT_OF_MEM;"
    },
    {
        "line": 35,
        "fullcodeline": "u32 cur_samp = 1;"
    },
    {
        "line": 36,
        "fullcodeline": "u32 samples_in_next_entry = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "u32 next_entry_first_chunk = 1;"
    },
    {
        "line": 83,
        "fullcodeline": "new_chunk_idx = next_entry_first_chunk;"
    },
    {
        "line": 114,
        "fullcodeline": "if (offset > 0xFFFFFFFF) {"
    },
    {
        "line": 164,
        "fullcodeline": "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 29,
        "fullcodeline": "if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber;"
    },
    {
        "line": 38,
        "fullcodeline": "for (i=0; i<stsc->nb_entries; i++) {"
    },
    {
        "line": 93,
        "fullcodeline": "stsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk;"
    },
    {
        "line": 102,
        "fullcodeline": "for (i = insert_idx+1; i<stsc->nb_entries+1; i++) {"
    },
    {
        "line": 115,
        "fullcodeline": "co64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64);"
    },
    {
        "line": 117,
        "fullcodeline": "co64->nb_entries = stco->nb_entries + 1;"
    },
    {
        "line": 118,
        "fullcodeline": "co64->alloc_size = co64->nb_entries;"
    },
    {
        "line": 119,
        "fullcodeline": "co64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries);"
    },
    {
        "line": 121,
        "fullcodeline": "k = 0;"
    },
    {
        "line": 130,
        "fullcodeline": "gf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset);"
    },
    {
        "line": 131,
        "fullcodeline": "stbl->ChunkOffset = (GF_Box *) co64;"
    },
    {
        "line": 165,
        "fullcodeline": "if (sampleNumber > co64->nb_entries) {"
    },
    {
        "line": 39,
        "fullcodeline": "u32 nb_chunks = 1;"
    },
    {
        "line": 40,
        "fullcodeline": "ent = &stsc->entries[i];"
    },
    {
        "line": 59,
        "fullcodeline": "memmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1));"
    },
    {
        "line": 61,
        "fullcodeline": "ent = &stsc->entries[insert_idx];"
    },
    {
        "line": 63,
        "fullcodeline": "stsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry;"
    },
    {
        "line": 64,
        "fullcodeline": "stsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1;"
    },
    {
        "line": 67,
        "fullcodeline": "ent = &stsc->entries[insert_idx+1];"
    },
    {
        "line": 68,
        "fullcodeline": "ent->firstChunk = next_entry_first_chunk;"
    },
    {
        "line": 70,
        "fullcodeline": "stsc->nb_entries += 2;"
    },
    {
        "line": 116,
        "fullcodeline": "if (!co64) return GF_OUT_OF_MEM;"
    },
    {
        "line": 120,
        "fullcodeline": "if (!co64->offsets) return GF_OUT_OF_MEM;"
    },
    {
        "line": 122,
        "fullcodeline": "for (i=0; i<stco->nb_entries; i++) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (!k) co64->offsets[co64->nb_entries - 1] = offset;"
    },
    {
        "line": 173,
        "fullcodeline": "co64->offsets[co64->nb_entries] = offset;"
    },
    {
        "line": 174,
        "fullcodeline": "co64->nb_entries += 1;"
    },
    {
        "line": 41,
        "fullcodeline": "if (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk;"
    },
    {
        "line": 42,
        "fullcodeline": "for (k=0; k<nb_chunks; k++) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (insert_idx>=0) break;"
    },
    {
        "line": 80,
        "fullcodeline": "ent->firstChunk = next_entry_first_chunk;"
    },
    {
        "line": 81,
        "fullcodeline": "stsc->nb_entries += 1;"
    },
    {
        "line": 104,
        "fullcodeline": "if (i+1<stsc->nb_entries)"
    },
    {
        "line": 134,
        "fullcodeline": "if (new_chunk_idx > stco->nb_entries) {"
    },
    {
        "line": 166,
        "fullcodeline": "if (!co64->alloc_size) co64->alloc_size = co64->nb_entries;"
    },
    {
        "line": 167,
        "fullcodeline": "if (co64->nb_entries == co64->alloc_size) {"
    },
    {
        "line": 177,
        "fullcodeline": "newLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1));"
    },
    {
        "line": 179,
        "fullcodeline": "k=0;"
    },
    {
        "line": 187,
        "fullcodeline": "gf_free(co64->offsets);"
    },
    {
        "line": 188,
        "fullcodeline": "co64->offsets = newLarge;"
    },
    {
        "line": 189,
        "fullcodeline": "co64->nb_entries++;"
    },
    {
        "line": 190,
        "fullcodeline": "co64->alloc_size++;"
    },
    {
        "line": 52,
        "fullcodeline": "cur_samp += ent->samplesPerChunk;"
    },
    {
        "line": 53,
        "fullcodeline": "next_entry_first_chunk++;"
    },
    {
        "line": 62,
        "fullcodeline": "stsc->entries[insert_idx+2] = *ent;"
    },
    {
        "line": 72,
        "fullcodeline": "if (insert_idx<0) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (i + 1 == new_chunk_idx) {"
    },
    {
        "line": 142,
        "fullcodeline": "stco->offsets[stco->nb_entries] = (u32) offset;"
    },
    {
        "line": 143,
        "fullcodeline": "stco->nb_entries += 1;"
    },
    {
        "line": 168,
        "fullcodeline": "ALLOC_INC(co64->alloc_size);"
    },
    {
        "line": 169,
        "fullcodeline": "co64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size);"
    },
    {
        "line": 171,
        "fullcodeline": "memset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) );"
    },
    {
        "line": 178,
        "fullcodeline": "if (!newLarge) return GF_OUT_OF_MEM;"
    },
    {
        "line": 180,
        "fullcodeline": "for (i=0; i<co64->nb_entries; i++) {"
    },
    {
        "line": 43,
        "fullcodeline": "if ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) {"
    },
    {
        "line": 73,
        "fullcodeline": "ent = &stsc->entries[stsc->nb_entries];"
    },
    {
        "line": 74,
        "fullcodeline": "insert_idx = stsc->nb_entries;"
    },
    {
        "line": 124,
        "fullcodeline": "co64->offsets[i] = offset;"
    },
    {
        "line": 125,
        "fullcodeline": "k = 1;"
    },
    {
        "line": 127,
        "fullcodeline": "co64->offsets[i+k] = (u64) stco->offsets[i];"
    },
    {
        "line": 135,
        "fullcodeline": "if (!stco->alloc_size) stco->alloc_size = stco->nb_entries;"
    },
    {
        "line": 136,
        "fullcodeline": "if (stco->nb_entries == stco->alloc_size) {"
    },
    {
        "line": 146,
        "fullcodeline": "newOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1));"
    },
    {
        "line": 148,
        "fullcodeline": "k=0;"
    },
    {
        "line": 156,
        "fullcodeline": "gf_free(stco->offsets);"
    },
    {
        "line": 157,
        "fullcodeline": "stco->offsets = newOff;"
    },
    {
        "line": 158,
        "fullcodeline": "stco->nb_entries ++;"
    },
    {
        "line": 159,
        "fullcodeline": "stco->alloc_size = stco->nb_entries;"
    },
    {
        "line": 170,
        "fullcodeline": "if (!co64->offsets) return GF_OUT_OF_MEM;"
    },
    {
        "line": 44,
        "fullcodeline": "insert_idx = i;"
    },
    {
        "line": 76,
        "fullcodeline": "memmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx));"
    },
    {
        "line": 77,
        "fullcodeline": "ent = &stsc->entries[insert_idx+1];"
    },
    {
        "line": 137,
        "fullcodeline": "ALLOC_INC(stco->alloc_size);"
    },
    {
        "line": 138,
        "fullcodeline": "stco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size);"
    },
    {
        "line": 140,
        "fullcodeline": "memset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) );"
    },
    {
        "line": 147,
        "fullcodeline": "if (!newOff) return GF_OUT_OF_MEM;"
    },
    {
        "line": 149,
        "fullcodeline": "for (i=0; i<stco->nb_entries; i++) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (i+1 == new_chunk_idx) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (sampleNumber>cur_samp) {"
    },
    {
        "line": 105,
        "fullcodeline": "stsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk;"
    },
    {
        "line": 139,
        "fullcodeline": "if (!stco->offsets) return GF_OUT_OF_MEM;"
    },
    {
        "line": 182,
        "fullcodeline": "newLarge[i] = offset;"
    },
    {
        "line": 183,
        "fullcodeline": "k=1;"
    },
    {
        "line": 185,
        "fullcodeline": "newLarge[i+k] = co64->offsets[i];"
    },
    {
        "line": 47,
        "fullcodeline": "samples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp);"
    },
    {
        "line": 48,
        "fullcodeline": "ent->samplesPerChunk = sampleNumber-cur_samp;"
    },
    {
        "line": 150,
        "fullcodeline": "if (i+1 == new_chunk_idx) {"
    },
    {
        "line": 151,
        "fullcodeline": "newOff[i] = (u32) offset;"
    },
    {
        "line": 152,
        "fullcodeline": "k=1;"
    },
    {
        "line": 154,
        "fullcodeline": "newOff[i+k] = stco->offsets[i];"
    }
]