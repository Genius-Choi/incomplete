[
    {
        "line": 4,
        "fullcodeline": "struct stream *s = BGP_INPUT (peer);"
    },
    {
        "line": 5,
        "fullcodeline": "size_t end = stream_get_getp (s) + length;"
    },
    {
        "line": 7,
        "fullcodeline": "assert (STREAM_READABLE (s) >= length);"
    },
    {
        "line": 9,
        "fullcodeline": "while (stream_get_getp (s) < end)"
    },
    {
        "line": 12,
        "fullcodeline": "u_char *sp = stream_pnt (s);"
    },
    {
        "line": 23,
        "fullcodeline": "caphdr.code = stream_getc (s);"
    },
    {
        "line": 24,
        "fullcodeline": "caphdr.length = stream_getc (s);"
    },
    {
        "line": 25,
        "fullcodeline": "start = stream_get_getp (s);"
    },
    {
        "line": 16,
        "fullcodeline": "if (stream_get_getp(s) + 2 > end)"
    },
    {
        "line": 28,
        "fullcodeline": "if (start + caphdr.length > end)"
    },
    {
        "line": 35,
        "fullcodeline": "if (BGP_DEBUG (normal, NORMAL))"
    },
    {
        "line": 125,
        "fullcodeline": "if (stream_get_getp(s) != (start + caphdr.length))"
    },
    {
        "line": 18,
        "fullcodeline": "zlog_info (\"%s Capability length error (< header)\", peer->host);"
    },
    {
        "line": 19,
        "fullcodeline": "bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);"
    },
    {
        "line": 30,
        "fullcodeline": "zlog_info (\"%s Capability length error (< length)\", peer->host);"
    },
    {
        "line": 36,
        "fullcodeline": "zlog_debug (\"%s OPEN has %s capability (%u), length %u\","
    },
    {
        "line": 107,
        "fullcodeline": "SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);"
    },
    {
        "line": 131,
        "fullcodeline": "stream_set_getp (s, start + caphdr.length);"
    },
    {
        "line": 20,
        "fullcodeline": "return -1;"
    },
    {
        "line": 32,
        "fullcodeline": "return -1;"
    },
    {
        "line": 38,
        "fullcodeline": "LOOKUP (capcode_str, caphdr.code),"
    },
    {
        "line": 52,
        "fullcodeline": "if (caphdr.length < cap_minsizes[caphdr.code])"
    },
    {
        "line": 99,
        "fullcodeline": "if (bgp_capability_orf (peer, &caphdr))"
    },
    {
        "line": 103,
        "fullcodeline": "if (bgp_capability_restart (peer, &caphdr))"
    },
    {
        "line": 110,
        "fullcodeline": "if (caphdr.code > 128)"
    },
    {
        "line": 127,
        "fullcodeline": "if (stream_get_getp(s) > (start + caphdr.length))"
    },
    {
        "line": 54,
        "fullcodeline": "zlog_info (\"%s %s Capability length error: got %u,\""
    },
    {
        "line": 72,
        "fullcodeline": "if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))"
    },
    {
        "line": 91,
        "fullcodeline": "if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)"
    },
    {
        "line": 114,
        "fullcodeline": "zlog_warn (\"%s Vendor specific capability %d\","
    },
    {
        "line": 128,
        "fullcodeline": "zlog_warn (\"%s Cap-parser for %s read past cap-length, %u!\","
    },
    {
        "line": 57,
        "fullcodeline": "LOOKUP (capcode_str, caphdr.code),"
    },
    {
        "line": 60,
        "fullcodeline": "return -1;"
    },
    {
        "line": 75,
        "fullcodeline": "ret = bgp_capability_mp (peer, &caphdr);"
    },
    {
        "line": 92,
        "fullcodeline": "SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);"
    },
    {
        "line": 100,
        "fullcodeline": "return -1;"
    },
    {
        "line": 104,
        "fullcodeline": "return -1;"
    },
    {
        "line": 119,
        "fullcodeline": "zlog_warn (\"%s unrecognized capability code: %d - ignored\","
    },
    {
        "line": 121,
        "fullcodeline": "memcpy (*error, sp, caphdr.length + 2);"
    },
    {
        "line": 122,
        "fullcodeline": "*error += caphdr.length + 2;"
    },
    {
        "line": 129,
        "fullcodeline": "peer->host, LOOKUP (capcode_str, caphdr.code),"
    },
    {
        "line": 78,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 94,
        "fullcodeline": "SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);"
    },
    {
        "line": 81,
        "fullcodeline": "memcpy (*error, sp, caphdr.length + 2);"
    },
    {
        "line": 82,
        "fullcodeline": "*error += caphdr.length + 2;"
    }
]