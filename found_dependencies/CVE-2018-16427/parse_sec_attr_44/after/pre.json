[
    {
        "line": 4,
        "fullcodeline": "const int df_idx[8] = {\t /* byte 1 = OpenSC type of AC Bit0,  byte 2 = OpenSC type of AC Bit1 ...*/"
    },
    {
        "line": 8,
        "fullcodeline": "const int ef_idx[8] = {"
    },
    {
        "line": 12,
        "fullcodeline": "const int efi_idx[8] = { /* internal EF used for RSA keys */"
    },
    {
        "line": 19,
        "fullcodeline": "int\t\tiKeyRef = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\tiOffset = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "while (len > 1) {\t\t\t\t/* minimum length = 2 */"
    },
    {
        "line": 7,
        "fullcodeline": "SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1};"
    },
    {
        "line": 11,
        "fullcodeline": "-1, SC_AC_OP_ERASE, -1};"
    },
    {
        "line": 15,
        "fullcodeline": "-1, SC_AC_OP_ERASE, -1};"
    },
    {
        "line": 28,
        "fullcodeline": "int\tiACLen   = buf[iOffset] & 0x0F;"
    },
    {
        "line": 32,
        "fullcodeline": "iPinCount = -1;\t\t\t/* default no pin required */"
    },
    {
        "line": 33,
        "fullcodeline": "iMethod = SC_AC_NONE;\t\t/* default no authentication required */"
    },
    {
        "line": 151,
        "fullcodeline": "iOffset += iACLen +1;\t\t/* AC + PTL-byte */"
    },
    {
        "line": 152,
        "fullcodeline": "len     -= iACLen +1;"
    },
    {
        "line": 29,
        "fullcodeline": "if ((size_t) iACLen > len)"
    },
    {
        "line": 35,
        "fullcodeline": "if (buf[iOffset] & 0X80) { /* AC in adaptive coding */"
    },
    {
        "line": 37,
        "fullcodeline": "int\tiParmLen = 1;\t\t\t/* command-byte is always present */"
    },
    {
        "line": 38,
        "fullcodeline": "int\tiKeyLen  = 0;\t\t\t/* Encryption key is optional */"
    },
    {
        "line": 90,
        "fullcodeline": "sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef);"
    },
    {
        "line": 40,
        "fullcodeline": "if (buf[iOffset]   & 0x20) iKeyLen++;"
    },
    {
        "line": 41,
        "fullcodeline": "if (buf[iOffset+1] & 0x40) iParmLen++;"
    },
    {
        "line": 42,
        "fullcodeline": "if (buf[iOffset+1] & 0x20) iParmLen++;"
    },
    {
        "line": 43,
        "fullcodeline": "if (buf[iOffset+1] & 0x10) iParmLen++;"
    },
    {
        "line": 44,
        "fullcodeline": "if (buf[iOffset+1] & 0x08) iParmLen++;"
    },
    {
        "line": 69,
        "fullcodeline": "if (iACLen > (1+iParmLen+iKeyLen)) {  /* check via total length if pin is present */"
    },
    {
        "line": 77,
        "fullcodeline": "if (len < 1+2)"
    },
    {
        "line": 109,
        "fullcodeline": "iPinCount = iACLen - 1;"
    },
    {
        "line": 143,
        "fullcodeline": "bValue = buf[iOffset + 1];"
    },
    {
        "line": 51,
        "fullcodeline": "iSC = buf[iOffset+iACLen];"
    },
    {
        "line": 65,
        "fullcodeline": "iKeyRef = iSC & 0x1F;\t\t\t/* get key number */"
    },
    {
        "line": 72,
        "fullcodeline": "iKeyRef = buf[iOffset+1+1+iParmLen];  /* PTL + AM-header + parameter-bytes */"
    },
    {
        "line": 73,
        "fullcodeline": "iMethod = SC_AC_CHV;"
    },
    {
        "line": 81,
        "fullcodeline": "iOperation = SC_AC_OP_CRYPTO;"
    },
    {
        "line": 84,
        "fullcodeline": "iOperation = SC_AC_OP_UPDATE;"
    },
    {
        "line": 87,
        "fullcodeline": "iOperation = SC_AC_OP_SELECT;"
    },
    {
        "line": 111,
        "fullcodeline": "if (buf[iOffset] & 0x20) {"
    },
    {
        "line": 135,
        "fullcodeline": "if ( iPinCount > 0 ) {"
    },
    {
        "line": 144,
        "fullcodeline": "for (i = 0; i < 8; i++) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (len < 1+iACLen)"
    },
    {
        "line": 53,
        "fullcodeline": "switch( (iSC>>5) & 0x03 ){"
    },
    {
        "line": 70,
        "fullcodeline": "if (len < 1+1+1+iParmLen)"
    },
    {
        "line": 98,
        "fullcodeline": "p_idx = df_idx;"
    },
    {
        "line": 101,
        "fullcodeline": "p_idx = efi_idx;"
    },
    {
        "line": 104,
        "fullcodeline": "p_idx = ef_idx;"
    },
    {
        "line": 115,
        "fullcodeline": "iSC = buf[iOffset + iACLen];"
    },
    {
        "line": 129,
        "fullcodeline": "iKeyRef = iSC & 0x1F;\t\t\t/* get key number */"
    },
    {
        "line": 131,
        "fullcodeline": "iPinCount--;\t\t\t\t/* one byte used for keyReference  */"
    },
    {
        "line": 138,
        "fullcodeline": "iKeyRef = buf[iOffset + 2];\t/* pin ref */"
    },
    {
        "line": 139,
        "fullcodeline": "iMethod = SC_AC_CHV;"
    },
    {
        "line": 147,
        "fullcodeline": "bValue >>= 1;"
    },
    {
        "line": 55,
        "fullcodeline": "iMethod = SC_AC_TERM;\t\t/* key authentication */"
    },
    {
        "line": 58,
        "fullcodeline": "iMethod = SC_AC_AUT;\t\t/* key authentication  */"
    },
    {
        "line": 62,
        "fullcodeline": "iMethod = SC_AC_PRO;\t\t/* secure messaging */"
    },
    {
        "line": 113,
        "fullcodeline": "if (len < 1 + iACLen)"
    },
    {
        "line": 117,
        "fullcodeline": "switch( (iSC>>5) & 0x03 ) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (len < 1 + 2)"
    },
    {
        "line": 145,
        "fullcodeline": "if((bValue & 1) && (p_idx[i] >= 0))"
    },
    {
        "line": 119,
        "fullcodeline": "iMethod = SC_AC_TERM;\t\t/* key authentication */"
    },
    {
        "line": 122,
        "fullcodeline": "iMethod = SC_AC_AUT;\t\t/* key authentication  */"
    },
    {
        "line": 126,
        "fullcodeline": "iMethod = SC_AC_PRO;\t\t/* secure messaging */"
    },
    {
        "line": 146,
        "fullcodeline": "sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef);"
    }
]