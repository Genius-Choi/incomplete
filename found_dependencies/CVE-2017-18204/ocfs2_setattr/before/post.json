[
    {
        "line": 3,
        "fullcodeline": "int status = 0, size_change;"
    },
    {
        "line": 4,
        "fullcodeline": "int inode_locked = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "struct inode *inode = d_inode(dentry);"
    },
    {
        "line": 6,
        "fullcodeline": "struct super_block *sb = inode->i_sb;"
    },
    {
        "line": 7,
        "fullcodeline": "struct ocfs2_super *osb = OCFS2_SB(sb);"
    },
    {
        "line": 8,
        "fullcodeline": "struct buffer_head *bh = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "handle_t *handle = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "struct dquot *transfer_to[MAXQUOTAS] = { };"
    },
    {
        "line": 15,
        "fullcodeline": "trace_ocfs2_setattr(inode, dentry,"
    },
    {
        "line": 31,
        "fullcodeline": "status = setattr_prepare(dentry, attr);"
    },
    {
        "line": 40,
        "fullcodeline": "size_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;"
    },
    {
        "line": 49,
        "fullcodeline": "had_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh);"
    },
    {
        "line": 74,
        "fullcodeline": "inode_locked = 1;"
    },
    {
        "line": 145,
        "fullcodeline": "setattr_copy(inode, attr);"
    },
    {
        "line": 146,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 148,
        "fullcodeline": "status = ocfs2_mark_inode_dirty(handle, inode, bh);"
    },
    {
        "line": 153,
        "fullcodeline": "ocfs2_commit_trans(osb, handle);"
    },
    {
        "line": 176,
        "fullcodeline": "brelse(bh);"
    },
    {
        "line": 19,
        "fullcodeline": "from_kuid(&init_user_ns, attr->ia_uid),"
    },
    {
        "line": 20,
        "fullcodeline": "from_kgid(&init_user_ns, attr->ia_gid));"
    },
    {
        "line": 23,
        "fullcodeline": "if (S_ISLNK(inode->i_mode))"
    },
    {
        "line": 28,
        "fullcodeline": "if (!(attr->ia_valid & OCFS2_VALID_ATTRS))"
    },
    {
        "line": 35,
        "fullcodeline": "if (is_quota_modification(inode, attr)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (had_lock < 0) {"
    },
    {
        "line": 101,
        "fullcodeline": "if ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||"
    },
    {
        "line": 149,
        "fullcodeline": "if (status < 0)"
    },
    {
        "line": 155,
        "fullcodeline": "if (status && inode_locked) {"
    },
    {
        "line": 165,
        "fullcodeline": "for (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++)"
    },
    {
        "line": 166,
        "fullcodeline": "dqput(transfer_to[qtype]);"
    },
    {
        "line": 168,
        "fullcodeline": "if (!status && attr->ia_valid & ATTR_MODE) {"
    },
    {
        "line": 24,
        "fullcodeline": "attr->ia_valid &= ~ATTR_SIZE;"
    },
    {
        "line": 36,
        "fullcodeline": "status = dquot_initialize(inode);"
    },
    {
        "line": 42,
        "fullcodeline": "status = ocfs2_rw_lock(inode, 1);"
    },
    {
        "line": 51,
        "fullcodeline": "status = had_lock;"
    },
    {
        "line": 77,
        "fullcodeline": "status = inode_newsize_ok(inode, attr->ia_size);"
    },
    {
        "line": 81,
        "fullcodeline": "inode_dio_wait(inode);"
    },
    {
        "line": 102,
        "fullcodeline": "(attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {"
    },
    {
        "line": 126,
        "fullcodeline": "handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +"
    },
    {
        "line": 133,
        "fullcodeline": "status = __dquot_transfer(inode, transfer_to);"
    },
    {
        "line": 150,
        "fullcodeline": "mlog_errno(status);"
    },
    {
        "line": 156,
        "fullcodeline": "ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);"
    },
    {
        "line": 157,
        "fullcodeline": "inode_locked = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "ocfs2_rw_unlock(inode, 1);"
    },
    {
        "line": 169,
        "fullcodeline": "status = ocfs2_acl_chmod(inode, bh);"
    },
    {
        "line": 174,
        "fullcodeline": "ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);"
    },
    {
        "line": 16,
        "fullcodeline": "(unsigned long long)OCFS2_I(inode)->ip_blkno,"
    },
    {
        "line": 43,
        "fullcodeline": "if (status < 0) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (i_size_read(inode) >= attr->ia_size) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (status < 0) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)"
    },
    {
        "line": 117,
        "fullcodeline": "if (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid)"
    },
    {
        "line": 128,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 134,
        "fullcodeline": "if (status < 0)"
    },
    {
        "line": 137,
        "fullcodeline": "handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);"
    },
    {
        "line": 170,
        "fullcodeline": "if (status < 0)"
    },
    {
        "line": 44,
        "fullcodeline": "mlog_errno(status);"
    },
    {
        "line": 90,
        "fullcodeline": "status = ocfs2_truncate_file(inode, bh, attr->ia_size);"
    },
    {
        "line": 96,
        "fullcodeline": "status = -ENOSPC;"
    },
    {
        "line": 109,
        "fullcodeline": "&& OCFS2_HAS_RO_COMPAT_FEATURE(sb,"
    },
    {
        "line": 111,
        "fullcodeline": "transfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid));"
    },
    {
        "line": 118,
        "fullcodeline": "&& OCFS2_HAS_RO_COMPAT_FEATURE(sb,"
    },
    {
        "line": 120,
        "fullcodeline": "transfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid));"
    },
    {
        "line": 129,
        "fullcodeline": "status = PTR_ERR(handle);"
    },
    {
        "line": 130,
        "fullcodeline": "mlog_errno(status);"
    },
    {
        "line": 138,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 171,
        "fullcodeline": "mlog_errno(status);"
    },
    {
        "line": 71,
        "fullcodeline": "mlog(ML_ERROR, \"Another case of recursive locking:\\n\");"
    },
    {
        "line": 72,
        "fullcodeline": "dump_stack();"
    },
    {
        "line": 84,
        "fullcodeline": "if (ocfs2_should_order_data(inode)) {"
    },
    {
        "line": 92,
        "fullcodeline": "status = ocfs2_extend_file(inode, bh, attr->ia_size);"
    },
    {
        "line": 94,
        "fullcodeline": "if (status != -ENOSPC)"
    },
    {
        "line": 112,
        "fullcodeline": "if (IS_ERR(transfer_to[USRQUOTA])) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (IS_ERR(transfer_to[GRPQUOTA])) {"
    },
    {
        "line": 127,
        "fullcodeline": "2 * ocfs2_quota_trans_credits(sb));"
    },
    {
        "line": 139,
        "fullcodeline": "status = PTR_ERR(handle);"
    },
    {
        "line": 140,
        "fullcodeline": "mlog_errno(status);"
    },
    {
        "line": 85,
        "fullcodeline": "status = ocfs2_begin_ordered_truncate(inode,"
    },
    {
        "line": 95,
        "fullcodeline": "mlog_errno(status);"
    },
    {
        "line": 113,
        "fullcodeline": "status = PTR_ERR(transfer_to[USRQUOTA]);"
    },
    {
        "line": 122,
        "fullcodeline": "status = PTR_ERR(transfer_to[GRPQUOTA]);"
    }
]