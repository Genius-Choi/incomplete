[
    {
        "line": 4,
        "fullcodeline": "client_settings = ClientSettings.new(env, @storage, start)"
    },
    {
        "line": 7,
        "fullcodeline": "status = headers = body = nil"
    },
    {
        "line": 8,
        "fullcodeline": "query_string = env['QUERY_STRING']"
    },
    {
        "line": 9,
        "fullcodeline": "path         = env['PATH_INFO'].sub('//', '/')"
    },
    {
        "line": 12,
        "fullcodeline": "env['RACK_MINI_PROFILER_ORIGINAL_SCRIPT_NAME'] = env['SCRIPT_NAME']"
    },
    {
        "line": 14,
        "fullcodeline": "skip_it = (@config.pre_authorize_cb && !@config.pre_authorize_cb.call(env)) ||"
    },
    {
        "line": 28,
        "fullcodeline": "has_disable_cookie = client_settings.disable_profiling?"
    },
    {
        "line": 70,
        "fullcodeline": "MiniProfiler.create_current(env, @config)"
    },
    {
        "line": 84,
        "fullcodeline": "flamegraph = nil"
    },
    {
        "line": 86,
        "fullcodeline": "trace_exceptions = query_string =~ /pp=trace-exceptions/ && defined? TracePoint"
    },
    {
        "line": 87,
        "fullcodeline": "status, headers, body, exceptions,trace = nil"
    },
    {
        "line": 165,
        "fullcodeline": "page_struct[:user] = user(env)"
    },
    {
        "line": 166,
        "fullcodeline": "page_struct[:root].record_time((Time.now - start) * 1000)"
    },
    {
        "line": 190,
        "fullcodeline": "client_settings.handle_cookie([status, headers, body])"
    },
    {
        "line": 5,
        "fullcodeline": "MiniProfiler.deauthorize_request if @config.authorization_mode == :whitelist"
    },
    {
        "line": 18,
        "fullcodeline": "if skip_it || ("
    },
    {
        "line": 26,
        "fullcodeline": "return client_settings.handle_cookie(serve_html(env)) if path.start_with? @config.base_url_path"
    },
    {
        "line": 30,
        "fullcodeline": "if query_string =~ /pp=disable/ || has_disable_cookie"
    },
    {
        "line": 34,
        "fullcodeline": "if query_string =~ /pp=enable/"
    },
    {
        "line": 39,
        "fullcodeline": "if skip_it || !config.enabled"
    },
    {
        "line": 48,
        "fullcodeline": "if query_string =~ /pp=profile-gc/"
    },
    {
        "line": 54,
        "fullcodeline": "if query_string =~ /pp=profile-memory/"
    },
    {
        "line": 72,
        "fullcodeline": "if query_string =~ /pp=normal-backtrace/"
    },
    {
        "line": 137,
        "fullcodeline": "if (config.authorization_mode == :whitelist && !MiniProfiler.request_authorized?)"
    },
    {
        "line": 149,
        "fullcodeline": "if query_string =~ /pp=env/ && !config.disable_env_dump"
    },
    {
        "line": 154,
        "fullcodeline": "if query_string =~ /pp=analyze-memory/"
    },
    {
        "line": 159,
        "fullcodeline": "if query_string =~ /pp=help/"
    },
    {
        "line": 194,
        "fullcodeline": "self.current = nil"
    },
    {
        "line": 16,
        "fullcodeline": "query_string =~ /pp=skip/"
    },
    {
        "line": 19,
        "fullcodeline": "@config.authorization_mode == :whitelist &&"
    },
    {
        "line": 31,
        "fullcodeline": "skip_it = true"
    },
    {
        "line": 35,
        "fullcodeline": "skip_it = false"
    },
    {
        "line": 36,
        "fullcodeline": "config.enabled = true"
    },
    {
        "line": 40,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 41,
        "fullcodeline": "client_settings.disable_profiling = true"
    },
    {
        "line": 44,
        "fullcodeline": "client_settings.disable_profiling = false"
    },
    {
        "line": 55,
        "fullcodeline": "query_params = Rack::Utils.parse_nested_query(query_string)"
    },
    {
        "line": 56,
        "fullcodeline": "options = {"
    },
    {
        "line": 61,
        "fullcodeline": "result = StringIO.new"
    },
    {
        "line": 62,
        "fullcodeline": "report = MemoryProfiler.report(options) do"
    },
    {
        "line": 66,
        "fullcodeline": "report.pretty_print(result)"
    },
    {
        "line": 91,
        "fullcodeline": "exceptions = []"
    },
    {
        "line": 92,
        "fullcodeline": "trace      = TracePoint.new(:raise) do |tp|"
    },
    {
        "line": 138,
        "fullcodeline": "skip_it = true"
    },
    {
        "line": 176,
        "fullcodeline": "@storage.set_unviewed(page_struct[:user], page_struct[:id])"
    },
    {
        "line": 177,
        "fullcodeline": "@storage.save(page_struct)"
    },
    {
        "line": 15,
        "fullcodeline": "(@config.skip_paths && @config.skip_paths.any?{ |p| path.start_with?(p) }) ||"
    },
    {
        "line": 20,
        "fullcodeline": "!client_settings.has_valid_cookie?"
    },
    {
        "line": 22,
        "fullcodeline": "return client_settings.handle_cookie(@app.call(env))"
    },
    {
        "line": 42,
        "fullcodeline": "return client_settings.handle_cookie([status,headers,body])"
    },
    {
        "line": 50,
        "fullcodeline": "return client_settings.handle_cookie(Rack::MiniProfiler::GCProfiler.new.profile_gc(@app, env))"
    },
    {
        "line": 60,
        "fullcodeline": "options[:top]= Integer(query_params['memory_profiler_top']) if query_params.key?('memory_profiler_top')"
    },
    {
        "line": 67,
        "fullcodeline": "return client_settings.handle_cookie(text_result(result.string))"
    },
    {
        "line": 74,
        "fullcodeline": "elsif query_string =~ /pp=no-backtrace/"
    },
    {
        "line": 107,
        "fullcodeline": "if query_string =~ /pp=flamegraph/"
    },
    {
        "line": 141,
        "fullcodeline": "return client_settings.handle_cookie([status,headers,body]) if skip_it"
    },
    {
        "line": 145,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 146,
        "fullcodeline": "return client_settings.handle_cookie(dump_exceptions exceptions)"
    },
    {
        "line": 150,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 151,
        "fullcodeline": "return client_settings.handle_cookie(dump_env env)"
    },
    {
        "line": 155,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 156,
        "fullcodeline": "return client_settings.handle_cookie(analyze_memory)"
    },
    {
        "line": 160,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 161,
        "fullcodeline": "return client_settings.handle_cookie(help(client_settings, env))"
    },
    {
        "line": 169,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 170,
        "fullcodeline": "return client_settings.handle_cookie(self.flamegraph(flamegraph))"
    },
    {
        "line": 180,
        "fullcodeline": "if status >= 200 && status < 300"
    },
    {
        "line": 49,
        "fullcodeline": "current.measure = false if current"
    },
    {
        "line": 57,
        "fullcodeline": ":ignore_files => query_params['memory_profiler_ignore_files'],"
    },
    {
        "line": 58,
        "fullcodeline": ":allow_files => query_params['memory_profiler_allow_files'],"
    },
    {
        "line": 75,
        "fullcodeline": "current.skip_backtrace = true"
    },
    {
        "line": 103,
        "fullcodeline": "env['HTTP_IF_MODIFIED_SINCE'] = ''"
    },
    {
        "line": 104,
        "fullcodeline": "env['HTTP_IF_NONE_MATCH']     = ''"
    },
    {
        "line": 129,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 181,
        "fullcodeline": "result = inject_profiler(env,status,headers,body)"
    },
    {
        "line": 185,
        "fullcodeline": "if @config.storage_failure != nil"
    },
    {
        "line": 77,
        "fullcodeline": "elsif query_string =~ /pp=full-backtrace/ || client_settings.backtrace_full?"
    },
    {
        "line": 108,
        "fullcodeline": "unless defined?(Flamegraph) && Flamegraph.respond_to?(:generate)"
    },
    {
        "line": 186,
        "fullcodeline": "@config.storage_failure.call(e)"
    },
    {
        "line": 78,
        "fullcodeline": "current.full_backtrace = true"
    },
    {
        "line": 110,
        "fullcodeline": "flamegraph = \"Please install the flamegraph gem and require it: add gem 'flamegraph' to your Gemfile\""
    },
    {
        "line": 111,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 114,
        "fullcodeline": "current.measure = false"
    },
    {
        "line": 115,
        "fullcodeline": "match_data      = query_string.match(/flamegraph_sample_rate=([\\d\\.]+)/)"
    },
    {
        "line": 117,
        "fullcodeline": "mode = query_string =~ /mode=c/ ? :c : :ruby"
    },
    {
        "line": 124,
        "fullcodeline": "flamegraph = Flamegraph.generate(nil, :fidelity => sample_rate, :embed_resources => query_string =~ /embed/, :mode => mode) do"
    },
    {
        "line": 119,
        "fullcodeline": "if match_data && !match_data[1].to_f.zero?"
    },
    {
        "line": 182,
        "fullcodeline": "return client_settings.handle_cookie(result) if result"
    },
    {
        "line": 81,
        "fullcodeline": "current.skip_backtrace = true"
    },
    {
        "line": 120,
        "fullcodeline": "sample_rate = match_data[1].to_f"
    }
]