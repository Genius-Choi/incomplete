[
    {
        "line": 3,
        "fullcodeline": "client_settings = ClientSettings.new(env)"
    },
    {
        "line": 5,
        "fullcodeline": "status = headers = body = nil"
    },
    {
        "line": 6,
        "fullcodeline": "query_string = env['QUERY_STRING']"
    },
    {
        "line": 7,
        "fullcodeline": "path         = env['PATH_INFO'].sub('//', '/')"
    },
    {
        "line": 10,
        "fullcodeline": "env['RACK_MINI_PROFILER_ORIGINAL_SCRIPT_NAME'] = env['SCRIPT_NAME']"
    },
    {
        "line": 12,
        "fullcodeline": "skip_it = (@config.pre_authorize_cb && !@config.pre_authorize_cb.call(env)) ||"
    },
    {
        "line": 16,
        "fullcodeline": "has_profiling_cookie = client_settings.has_cookie?"
    },
    {
        "line": 29,
        "fullcodeline": "has_disable_cookie = client_settings.disable_profiling?"
    },
    {
        "line": 72,
        "fullcodeline": "MiniProfiler.create_current(env, @config)"
    },
    {
        "line": 87,
        "fullcodeline": "flamegraph = nil"
    },
    {
        "line": 89,
        "fullcodeline": "trace_exceptions = query_string =~ /pp=trace-exceptions/ && defined? TracePoint"
    },
    {
        "line": 90,
        "fullcodeline": "status, headers, body, exceptions,trace = nil"
    },
    {
        "line": 175,
        "fullcodeline": "page_struct[:user] = user(env)"
    },
    {
        "line": 176,
        "fullcodeline": "page_struct[:root].record_time((Time.now - start) * 1000)"
    },
    {
        "line": 201,
        "fullcodeline": "client_settings.write!(headers)"
    },
    {
        "line": 202,
        "fullcodeline": "[status, headers, body]"
    },
    {
        "line": 18,
        "fullcodeline": "if skip_it || (@config.authorization_mode == :whitelist && !has_profiling_cookie)"
    },
    {
        "line": 27,
        "fullcodeline": "return serve_html(env) if path.start_with? @config.base_url_path"
    },
    {
        "line": 31,
        "fullcodeline": "if query_string =~ /pp=disable/ || has_disable_cookie"
    },
    {
        "line": 35,
        "fullcodeline": "if query_string =~ /pp=enable/ && (@config.authorization_mode != :whitelist || MiniProfiler.request_authorized?)"
    },
    {
        "line": 40,
        "fullcodeline": "if skip_it || !config.enabled"
    },
    {
        "line": 50,
        "fullcodeline": "if query_string =~ /pp=profile-gc/"
    },
    {
        "line": 56,
        "fullcodeline": "if query_string =~ /pp=profile-memory/"
    },
    {
        "line": 73,
        "fullcodeline": "MiniProfiler.deauthorize_request if @config.authorization_mode == :whitelist"
    },
    {
        "line": 75,
        "fullcodeline": "if query_string =~ /pp=normal-backtrace/"
    },
    {
        "line": 142,
        "fullcodeline": "if (config.authorization_mode == :whitelist && !MiniProfiler.request_authorized?)"
    },
    {
        "line": 159,
        "fullcodeline": "if query_string =~ /pp=env/ && !config.disable_env_dump"
    },
    {
        "line": 164,
        "fullcodeline": "if query_string =~ /pp=analyze-memory/"
    },
    {
        "line": 169,
        "fullcodeline": "if query_string =~ /pp=help/"
    },
    {
        "line": 206,
        "fullcodeline": "self.current = nil"
    },
    {
        "line": 14,
        "fullcodeline": "query_string =~ /pp=skip/"
    },
    {
        "line": 19,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 32,
        "fullcodeline": "skip_it = true"
    },
    {
        "line": 36,
        "fullcodeline": "skip_it = false"
    },
    {
        "line": 37,
        "fullcodeline": "config.enabled = true"
    },
    {
        "line": 41,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 42,
        "fullcodeline": "client_settings.disable_profiling = true"
    },
    {
        "line": 43,
        "fullcodeline": "client_settings.write!(headers)"
    },
    {
        "line": 46,
        "fullcodeline": "client_settings.disable_profiling = false"
    },
    {
        "line": 57,
        "fullcodeline": "query_params = Rack::Utils.parse_nested_query(query_string)"
    },
    {
        "line": 58,
        "fullcodeline": "options = {"
    },
    {
        "line": 63,
        "fullcodeline": "result = StringIO.new"
    },
    {
        "line": 64,
        "fullcodeline": "report = MemoryProfiler.report(options) do"
    },
    {
        "line": 68,
        "fullcodeline": "report.pretty_print(result)"
    },
    {
        "line": 95,
        "fullcodeline": "exceptions = []"
    },
    {
        "line": 96,
        "fullcodeline": "trace      = TracePoint.new(:raise) do |tp|"
    },
    {
        "line": 135,
        "fullcodeline": "client_settings.write!(headers)"
    },
    {
        "line": 148,
        "fullcodeline": "skip_it = true"
    },
    {
        "line": 186,
        "fullcodeline": "@storage.set_unviewed(page_struct[:user], page_struct[:id])"
    },
    {
        "line": 187,
        "fullcodeline": "@storage.save(page_struct)"
    },
    {
        "line": 13,
        "fullcodeline": "(@config.skip_paths && @config.skip_paths.any?{ |p| path.start_with?(p) }) ||"
    },
    {
        "line": 20,
        "fullcodeline": "if !skip_it && @config.authorization_mode == :whitelist && !has_profiling_cookie && MiniProfiler.request_authorized?"
    },
    {
        "line": 23,
        "fullcodeline": "return [status,headers,body]"
    },
    {
        "line": 44,
        "fullcodeline": "return [status,headers,body]"
    },
    {
        "line": 52,
        "fullcodeline": "return Rack::MiniProfiler::GCProfiler.new.profile_gc(@app, env)"
    },
    {
        "line": 62,
        "fullcodeline": "options[:top]= Integer(query_params['memory_profiler_top']) if query_params.key?('memory_profiler_top')"
    },
    {
        "line": 69,
        "fullcodeline": "return text_result(result.string)"
    },
    {
        "line": 77,
        "fullcodeline": "elsif query_string =~ /pp=no-backtrace/"
    },
    {
        "line": 111,
        "fullcodeline": "if query_string =~ /pp=flamegraph/"
    },
    {
        "line": 145,
        "fullcodeline": "if status.to_i >= 200 && status.to_i < 300 && ((Time.now - start) > 0.1)"
    },
    {
        "line": 151,
        "fullcodeline": "return [status,headers,body] if skip_it"
    },
    {
        "line": 155,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 156,
        "fullcodeline": "return dump_exceptions exceptions"
    },
    {
        "line": 160,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 161,
        "fullcodeline": "return dump_env env"
    },
    {
        "line": 165,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 170,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 171,
        "fullcodeline": "return help(client_settings, env)"
    },
    {
        "line": 179,
        "fullcodeline": "body.close if body.respond_to? :close"
    },
    {
        "line": 180,
        "fullcodeline": "return self.flamegraph(flamegraph)"
    },
    {
        "line": 190,
        "fullcodeline": "if status >= 200 && status < 300"
    },
    {
        "line": 21,
        "fullcodeline": "client_settings.write!(headers)"
    },
    {
        "line": 51,
        "fullcodeline": "current.measure = false if current"
    },
    {
        "line": 59,
        "fullcodeline": ":ignore_files => query_params['memory_profiler_ignore_files'],"
    },
    {
        "line": 60,
        "fullcodeline": ":allow_files => query_params['memory_profiler_allow_files'],"
    },
    {
        "line": 78,
        "fullcodeline": "current.skip_backtrace = true"
    },
    {
        "line": 107,
        "fullcodeline": "env['HTTP_IF_MODIFIED_SINCE'] = ''"
    },
    {
        "line": 108,
        "fullcodeline": "env['HTTP_IF_NONE_MATCH']     = ''"
    },
    {
        "line": 133,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 146,
        "fullcodeline": "client_settings.discard_cookie!(headers)"
    },
    {
        "line": 191,
        "fullcodeline": "client_settings.write!(headers)"
    },
    {
        "line": 192,
        "fullcodeline": "result = inject_profiler(env,status,headers,body)"
    },
    {
        "line": 196,
        "fullcodeline": "if @config.storage_failure != nil"
    },
    {
        "line": 80,
        "fullcodeline": "elsif query_string =~ /pp=full-backtrace/ || client_settings.backtrace_full?"
    },
    {
        "line": 112,
        "fullcodeline": "unless defined?(Flamegraph) && Flamegraph.respond_to?(:generate)"
    },
    {
        "line": 197,
        "fullcodeline": "@config.storage_failure.call(e)"
    },
    {
        "line": 81,
        "fullcodeline": "current.full_backtrace = true"
    },
    {
        "line": 114,
        "fullcodeline": "flamegraph = \"Please install the flamegraph gem and require it: add gem 'flamegraph' to your Gemfile\""
    },
    {
        "line": 115,
        "fullcodeline": "status,headers,body = @app.call(env)"
    },
    {
        "line": 118,
        "fullcodeline": "current.measure = false"
    },
    {
        "line": 119,
        "fullcodeline": "match_data      = query_string.match(/flamegraph_sample_rate=([\\d\\.]+)/)"
    },
    {
        "line": 121,
        "fullcodeline": "mode = query_string =~ /mode=c/ ? :c : :ruby"
    },
    {
        "line": 128,
        "fullcodeline": "flamegraph = Flamegraph.generate(nil, :fidelity => sample_rate, :embed_resources => query_string =~ /embed/, :mode => mode) do"
    },
    {
        "line": 123,
        "fullcodeline": "if match_data && !match_data[1].to_f.zero?"
    },
    {
        "line": 84,
        "fullcodeline": "current.skip_backtrace = true"
    },
    {
        "line": 124,
        "fullcodeline": "sample_rate = match_data[1].to_f"
    }
]