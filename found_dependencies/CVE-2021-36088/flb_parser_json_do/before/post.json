[
    {
        "line": 12,
        "fullcodeline": "double tmfrac = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "char *mp_buf = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "char *tmp_out_buf = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "char tmp[255];"
    },
    {
        "line": 17,
        "fullcodeline": "size_t tmp_out_size = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "size_t off = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "msgpack_object *k = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "msgpack_object *v = NULL;"
    },
    {
        "line": 29,
        "fullcodeline": "struct tm tm = {0};"
    },
    {
        "line": 33,
        "fullcodeline": "ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,"
    },
    {
        "line": 45,
        "fullcodeline": "msgpack_unpacked_init(&result);"
    },
    {
        "line": 63,
        "fullcodeline": "tmp_out_buf = mp_buf;"
    },
    {
        "line": 64,
        "fullcodeline": "tmp_out_size = mp_size;"
    },
    {
        "line": 82,
        "fullcodeline": "*out_buf = tmp_out_buf;"
    },
    {
        "line": 83,
        "fullcodeline": "*out_size = tmp_out_size;"
    },
    {
        "line": 100,
        "fullcodeline": "slen = strlen(time_key);"
    },
    {
        "line": 104,
        "fullcodeline": "skip = map_size;"
    },
    {
        "line": 150,
        "fullcodeline": "ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,"
    },
    {
        "line": 168,
        "fullcodeline": "msgpack_sbuffer_init(&mp_sbuf);"
    },
    {
        "line": 169,
        "fullcodeline": "msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);"
    },
    {
        "line": 187,
        "fullcodeline": "flb_free(tmp_out_buf);"
    },
    {
        "line": 188,
        "fullcodeline": "*out_buf = mp_sbuf.data;"
    },
    {
        "line": 189,
        "fullcodeline": "*out_size = mp_sbuf.size;"
    },
    {
        "line": 191,
        "fullcodeline": "t = out_time;"
    },
    {
        "line": 192,
        "fullcodeline": "t->tm.tv_sec  = time_lookup;"
    },
    {
        "line": 193,
        "fullcodeline": "t->tm.tv_nsec = (tmfrac * 1000000000);"
    },
    {
        "line": 195,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 35,
        "fullcodeline": "if (ret != 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (records != 1) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (mp_buf != tmp_out_buf) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (!parser->time_fmt) {"
    },
    {
        "line": 105,
        "fullcodeline": "for (i = 0; i < map_size; i++) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (i >= map_size || !k || !v) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (v->type != MSGPACK_OBJECT_STR) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (ret == -1) {"
    },
    {
        "line": 171,
        "fullcodeline": "if (parser->time_keep == FLB_FALSE) {"
    },
    {
        "line": 178,
        "fullcodeline": "for (i = 0; i < map_size; i++) {"
    },
    {
        "line": 40,
        "fullcodeline": "flb_free(mp_buf);"
    },
    {
        "line": 47,
        "fullcodeline": "map = result.data;"
    },
    {
        "line": 68,
        "fullcodeline": "ret = flb_parser_decoder_do(parser->decoders,"
    },
    {
        "line": 85,
        "fullcodeline": "flb_free(mp_buf);"
    },
    {
        "line": 90,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 95,
        "fullcodeline": "time_key = parser->time_key;"
    },
    {
        "line": 133,
        "fullcodeline": "k = NULL;"
    },
    {
        "line": 134,
        "fullcodeline": "v = NULL;"
    },
    {
        "line": 139,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 145,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 153,
        "fullcodeline": "len = v->via.str.size;"
    },
    {
        "line": 157,
        "fullcodeline": "memcpy(tmp, v->via.str.ptr, len);"
    },
    {
        "line": 158,
        "fullcodeline": "tmp[len] = '\\0';"
    },
    {
        "line": 159,
        "fullcodeline": "flb_warn(\"[parser:%s] invalid time format %s for '%s'\","
    },
    {
        "line": 161,
        "fullcodeline": "time_lookup = 0;"
    },
    {
        "line": 172,
        "fullcodeline": "msgpack_pack_map(&mp_pck, map_size - 1);"
    },
    {
        "line": 182,
        "fullcodeline": "msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);"
    },
    {
        "line": 183,
        "fullcodeline": "msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);"
    },
    {
        "line": 36,
        "fullcodeline": "return -1;"
    },
    {
        "line": 41,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "if (map.type != MSGPACK_OBJECT_MAP) {"
    },
    {
        "line": 58,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 71,
        "fullcodeline": "if (ret == 0) {"
    },
    {
        "line": 98,
        "fullcodeline": "time_key = \"time\";"
    },
    {
        "line": 109,
        "fullcodeline": "if (k->via.str.size != slen) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (k->via.str.ptr == NULL) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (len > sizeof(tmp) - 1) {"
    },
    {
        "line": 164,
        "fullcodeline": "time_lookup = flb_parser_tm2time(&tm);"
    },
    {
        "line": 175,
        "fullcodeline": "msgpack_pack_map(&mp_pck, map_size);"
    },
    {
        "line": 179,
        "fullcodeline": "if (i == skip) {"
    },
    {
        "line": 49,
        "fullcodeline": "flb_free(mp_buf);"
    },
    {
        "line": 50,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 55,
        "fullcodeline": "if (mp_size > 0) {"
    },
    {
        "line": 59,
        "fullcodeline": "return -1;"
    },
    {
        "line": 73,
        "fullcodeline": "off = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 75,
        "fullcodeline": "msgpack_unpacked_init(&result);"
    },
    {
        "line": 76,
        "fullcodeline": "msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);"
    },
    {
        "line": 77,
        "fullcodeline": "map = result.data;"
    },
    {
        "line": 115,
        "fullcodeline": "flb_free(mp_buf);"
    },
    {
        "line": 116,
        "fullcodeline": "*out_buf = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "msgpack_unpacked_destroy(&result);"
    },
    {
        "line": 155,
        "fullcodeline": "len = sizeof(tmp) - 1;"
    },
    {
        "line": 51,
        "fullcodeline": "return -1;"
    },
    {
        "line": 56,
        "fullcodeline": "flb_free(mp_buf);"
    },
    {
        "line": 118,
        "fullcodeline": "return -1;"
    },
    {
        "line": 123,
        "fullcodeline": "if (parser->time_keep == FLB_FALSE) {"
    },
    {
        "line": 124,
        "fullcodeline": "skip = i;"
    },
    {
        "line": 128,
        "fullcodeline": "skip = -1;"
    }
]