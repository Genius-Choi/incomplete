[
    {
        "line": 4,
        "fullcodeline": "const Tensor& images_t = ctx->input(0);"
    },
    {
        "line": 5,
        "fullcodeline": "const Tensor& transform_t = ctx->input(1);"
    },
    {
        "line": 6,
        "fullcodeline": "OP_REQUIRES(ctx, images_t.shape().dims() == 4,"
    },
    {
        "line": 8,
        "fullcodeline": "OP_REQUIRES(ctx,"
    },
    {
        "line": 37,
        "fullcodeline": "T fill_value(0);"
    },
    {
        "line": 49,
        "fullcodeline": "OP_REQUIRES_OK("
    },
    {
        "line": 53,
        "fullcodeline": "OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &output_t));"
    },
    {
        "line": 54,
        "fullcodeline": "auto output = output_t->tensor<T, 4>();"
    },
    {
        "line": 55,
        "fullcodeline": "auto images = images_t.tensor<T, 4>();"
    },
    {
        "line": 56,
        "fullcodeline": "auto transform = transform_t.matrix<float>();"
    },
    {
        "line": 58,
        "fullcodeline": "(FillProjectiveTransform<Device, T>(interpolation))("
    },
    {
        "line": 7,
        "fullcodeline": "errors::InvalidArgument(\"Input images must have rank 4\"));"
    },
    {
        "line": 9,
        "fullcodeline": "(TensorShapeUtils::IsMatrix(transform_t.shape()) &&"
    },
    {
        "line": 13,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 18,
        "fullcodeline": "if (ctx->num_inputs() >= 3) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (ctx->num_inputs() >= 4) {"
    },
    {
        "line": 50,
        "fullcodeline": "ctx, TensorShape::BuildTensorShape({images_t.dim_size(0), out_height,"
    },
    {
        "line": 59,
        "fullcodeline": "ctx->eigen_device<Device>(), &output, images, transform, fill_mode,"
    },
    {
        "line": 12,
        "fullcodeline": "transform_t.dim_size(1) == 8),"
    },
    {
        "line": 19,
        "fullcodeline": "const Tensor& shape_t = ctx->input(2);"
    },
    {
        "line": 20,
        "fullcodeline": "OP_REQUIRES(ctx, shape_t.dims() == 1,"
    },
    {
        "line": 23,
        "fullcodeline": "OP_REQUIRES(ctx, shape_t.NumElements() == 2,"
    },
    {
        "line": 26,
        "fullcodeline": "auto shape_vec = shape_t.vec<int32>();"
    },
    {
        "line": 27,
        "fullcodeline": "out_height = shape_vec(0);"
    },
    {
        "line": 28,
        "fullcodeline": "out_width = shape_vec(1);"
    },
    {
        "line": 29,
        "fullcodeline": "OP_REQUIRES(ctx, out_height > 0 && out_width > 0,"
    },
    {
        "line": 40,
        "fullcodeline": "const Tensor& fill_value_t = ctx->input(3);"
    },
    {
        "line": 41,
        "fullcodeline": "OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(fill_value_t.shape()),"
    },
    {
        "line": 44,
        "fullcodeline": "fill_value = static_cast<T>(*(fill_value_t.scalar<float>().data()));"
    },
    {
        "line": 10,
        "fullcodeline": "(transform_t.dim_size(0) == images_t.dim_size(0) ||"
    },
    {
        "line": 21,
        "fullcodeline": "errors::InvalidArgument(\"output shape must be 1-dimensional\","
    },
    {
        "line": 24,
        "fullcodeline": "errors::InvalidArgument(\"output shape must have two elements\","
    },
    {
        "line": 30,
        "fullcodeline": "errors::InvalidArgument(\"output dimensions must be positive\"));"
    },
    {
        "line": 33,
        "fullcodeline": "out_height = images_t.shape().dim_size(1);"
    },
    {
        "line": 34,
        "fullcodeline": "out_width = images_t.shape().dim_size(2);"
    },
    {
        "line": 42,
        "fullcodeline": "errors::InvalidArgument(\"fill_value must be a scalar\","
    },
    {
        "line": 51,
        "fullcodeline": "out_width, images_t.dim_size(3)},"
    },
    {
        "line": 11,
        "fullcodeline": "transform_t.dim_size(0) == 1) &&"
    },
    {
        "line": 22,
        "fullcodeline": "shape_t.shape().DebugString()));"
    },
    {
        "line": 25,
        "fullcodeline": "shape_t.shape().DebugString()));"
    },
    {
        "line": 43,
        "fullcodeline": "fill_value_t.shape().DebugString()));"
    }
]