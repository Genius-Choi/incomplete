[
    {
        "line": 3,
        "fullcodeline": "struct hwsim_new_radio_params param = { 0 };"
    },
    {
        "line": 4,
        "fullcodeline": "const char *hwname = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "param.channels = channels;"
    },
    {
        "line": 45,
        "fullcodeline": "ret = mac80211_hwsim_new_radio(info, &param);"
    },
    {
        "line": 46,
        "fullcodeline": "kfree(hwname);"
    },
    {
        "line": 14,
        "fullcodeline": "param.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);"
    },
    {
        "line": 17,
        "fullcodeline": "param.no_vif = true;"
    },
    {
        "line": 20,
        "fullcodeline": "hwname = kasprintf(GFP_KERNEL, \"%.*s\","
    },
    {
        "line": 25,
        "fullcodeline": "param.hwname = hwname;"
    },
    {
        "line": 29,
        "fullcodeline": "param.use_chanctx = true;"
    },
    {
        "line": 34,
        "fullcodeline": "param.reg_alpha2 ="
    },
    {
        "line": 38,
        "fullcodeline": "u32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);"
    },
    {
        "line": 42,
        "fullcodeline": "param.regd = hwsim_world_regdom_custom[idx];"
    },
    {
        "line": 23,
        "fullcodeline": "if (!hwname)"
    },
    {
        "line": 31,
        "fullcodeline": "param.use_chanctx = (param.channels > 1);"
    },
    {
        "line": 40,
        "fullcodeline": "if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))"
    },
    {
        "line": 22,
        "fullcodeline": "(char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));"
    },
    {
        "line": 24,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 41,
        "fullcodeline": "return -EINVAL;"
    }
]