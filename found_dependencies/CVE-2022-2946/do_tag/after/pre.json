[
    {
        "line": 8,
        "fullcodeline": "taggy_T\t*tagstack = curwin->w_tagstack;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\ttagstackidx = curwin->w_tagstackidx;"
    },
    {
        "line": 10,
        "fullcodeline": "int\t\ttagstacklen = curwin->w_tagstacklen;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tcur_match = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tcur_fnum = curbuf->b_fnum;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\toldtagstackidx = tagstackidx;"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tprevtagstackidx = tagstackidx;"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tnew_tag = FALSE;"
    },
    {
        "line": 19,
        "fullcodeline": "int\t\tno_regexp = FALSE;"
    },
    {
        "line": 20,
        "fullcodeline": "int\t\terror_cur_match = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tsave_pos = FALSE;"
    },
    {
        "line": 29,
        "fullcodeline": "int\t\tskip_msg = FALSE;"
    },
    {
        "line": 30,
        "fullcodeline": "char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for"
    },
    {
        "line": 32,
        "fullcodeline": "int\t\tuse_tfu = 1;"
    },
    {
        "line": 33,
        "fullcodeline": "char_u\t*tofree = NULL;"
    },
    {
        "line": 36,
        "fullcodeline": "static int\t\tnum_matches = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "static int\t\tmax_num_matches = 0;  // limit used for match search"
    },
    {
        "line": 38,
        "fullcodeline": "static char_u\t**matches = NULL;"
    },
    {
        "line": 69,
        "fullcodeline": "prev_num_matches = num_matches;"
    },
    {
        "line": 70,
        "fullcodeline": "free_string_option(nofile_fname);"
    },
    {
        "line": 71,
        "fullcodeline": "nofile_fname = NULL;"
    },
    {
        "line": 73,
        "fullcodeline": "CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0"
    },
    {
        "line": 74,
        "fullcodeline": "saved_fmark.fnum = 0;"
    },
    {
        "line": 675,
        "fullcodeline": "postponed_split = 0;\t// don't split next time"
    },
    {
        "line": 680,
        "fullcodeline": "vim_free(tofree);"
    },
    {
        "line": 62,
        "fullcodeline": "if (type == DT_HELP)"
    },
    {
        "line": 79,
        "fullcodeline": "if ((!p_tgst && *tag != NUL))"
    },
    {
        "line": 363,
        "fullcodeline": "if (cur_fnum != curbuf->b_fnum)"
    },
    {
        "line": 673,
        "fullcodeline": "if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)"
    },
    {
        "line": 64,
        "fullcodeline": "type = DT_TAG;"
    },
    {
        "line": 65,
        "fullcodeline": "no_regexp = TRUE;"
    },
    {
        "line": 66,
        "fullcodeline": "use_tfu = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "use_tagstack = FALSE;"
    },
    {
        "line": 82,
        "fullcodeline": "new_tag = TRUE;"
    },
    {
        "line": 365,
        "fullcodeline": "buf_T *buf = buflist_findnr(cur_fnum);"
    },
    {
        "line": 395,
        "fullcodeline": "other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);"
    },
    {
        "line": 674,
        "fullcodeline": "curwin->w_tagstackidx = tagstackidx;"
    },
    {
        "line": 99,
        "fullcodeline": "use_tagstack = TRUE;"
    },
    {
        "line": 367,
        "fullcodeline": "if (buf != NULL)"
    },
    {
        "line": 396,
        "fullcodeline": "if (new_tag"
    },
    {
        "line": 475,
        "fullcodeline": "if (num_matches <= 0)"
    },
    {
        "line": 102,
        "fullcodeline": "if (*tag != NUL"
    },
    {
        "line": 341,
        "fullcodeline": "saved_fmark = tagstack[tagstackidx].fmark;"
    },
    {
        "line": 351,
        "fullcodeline": "curwin->w_tagstackidx = tagstackidx;"
    },
    {
        "line": 368,
        "fullcodeline": "buf_ffname = buf->b_ffname;"
    },
    {
        "line": 385,
        "fullcodeline": "name = vim_strsave(tagstack[tagstackidx].tagname);"
    },
    {
        "line": 387,
        "fullcodeline": "tofree = name;"
    },
    {
        "line": 470,
        "fullcodeline": "FreeWild(num_matches, matches);"
    },
    {
        "line": 471,
        "fullcodeline": "num_matches = new_num_matches;"
    },
    {
        "line": 472,
        "fullcodeline": "matches = new_matches;"
    },
    {
        "line": 103,
        "fullcodeline": "&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP"
    },
    {
        "line": 163,
        "fullcodeline": "new_tag = TRUE;"
    },
    {
        "line": 352,
        "fullcodeline": "if (type != DT_SELECT && type != DT_JUMP)"
    },
    {
        "line": 394,
        "fullcodeline": "name = tag;"
    },
    {
        "line": 397,
        "fullcodeline": "|| (cur_match >= num_matches && max_num_matches != MAXCOL)"
    },
    {
        "line": 406,
        "fullcodeline": "if (type == DT_SELECT || type == DT_JUMP"
    },
    {
        "line": 412,
        "fullcodeline": "if (type == DT_TAG)"
    },
    {
        "line": 418,
        "fullcodeline": "if (!no_regexp && *name == '/')"
    },
    {
        "line": 433,
        "fullcodeline": "if (!use_tfu)"
    },
    {
        "line": 436,
        "fullcodeline": "if (find_tags(name, &new_num_matches, &new_matches, flags,"
    },
    {
        "line": 445,
        "fullcodeline": "if (!new_tag && !other_name)"
    },
    {
        "line": 485,
        "fullcodeline": "int ask_for_selection = FALSE;"
    },
    {
        "line": 586,
        "fullcodeline": "ic = (matches[cur_match][0] & MT_IC_OFF);"
    },
    {
        "line": 628,
        "fullcodeline": "i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);"
    },
    {
        "line": 158,
        "fullcodeline": "curwin->w_tagstacklen = tagstacklen;"
    },
    {
        "line": 160,
        "fullcodeline": "save_pos = TRUE;\t// save the cursor position below"
    },
    {
        "line": 344,
        "fullcodeline": "tagstack[tagstackidx].fmark.mark = curwin->w_cursor;"
    },
    {
        "line": 345,
        "fullcodeline": "tagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;"
    },
    {
        "line": 354,
        "fullcodeline": "curwin->w_tagstack[tagstackidx].cur_match = cur_match;"
    },
    {
        "line": 355,
        "fullcodeline": "curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;"
    },
    {
        "line": 402,
        "fullcodeline": "vim_free(tagmatchname);"
    },
    {
        "line": 403,
        "fullcodeline": "tagmatchname = vim_strsave(name);"
    },
    {
        "line": 411,
        "fullcodeline": "cur_match = MAXCOL - 1;"
    },
    {
        "line": 413,
        "fullcodeline": "max_num_matches = MAXCOL;"
    },
    {
        "line": 420,
        "fullcodeline": "flags = TAG_REGEXP;"
    },
    {
        "line": 421,
        "fullcodeline": "++name;"
    },
    {
        "line": 431,
        "fullcodeline": "flags |= TAG_VERBOSE;"
    },
    {
        "line": 434,
        "fullcodeline": "flags |= TAG_NO_TAGFUNC;"
    },
    {
        "line": 438,
        "fullcodeline": "&& new_num_matches < max_num_matches)"
    },
    {
        "line": 439,
        "fullcodeline": "max_num_matches = MAXCOL; // If less than max_num_matches"
    },
    {
        "line": 448,
        "fullcodeline": "int\t    idx = 0;"
    },
    {
        "line": 478,
        "fullcodeline": "semsg(_(e_tag_not_found_str), name);"
    },
    {
        "line": 495,
        "fullcodeline": "if (type == DT_TAG && *tag != NUL)"
    },
    {
        "line": 513,
        "fullcodeline": "if (ask_for_selection == TRUE)"
    },
    {
        "line": 536,
        "fullcodeline": "if (cur_match >= num_matches)"
    },
    {
        "line": 582,
        "fullcodeline": "if (nofile_fname != NULL && error_cur_match != cur_match)"
    },
    {
        "line": 587,
        "fullcodeline": "if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP"
    },
    {
        "line": 634,
        "fullcodeline": "if (i == NOTAGFILE)"
    },
    {
        "line": 137,
        "fullcodeline": "while (tagstackidx < tagstacklen)"
    },
    {
        "line": 138,
        "fullcodeline": "tagstack_clear_entry(&tagstack[--tagstacklen]);"
    },
    {
        "line": 141,
        "fullcodeline": "if (++tagstacklen > TAGSTACKSIZE)"
    },
    {
        "line": 153,
        "fullcodeline": "if ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)"
    },
    {
        "line": 171,
        "fullcodeline": "tagstacklen == 0)"
    },
    {
        "line": 178,
        "fullcodeline": "if (type == DT_POP)\t\t// go to older position"
    },
    {
        "line": 244,
        "fullcodeline": "if (type == DT_TAG"
    },
    {
        "line": 415,
        "fullcodeline": "max_num_matches = cur_match + 1;"
    },
    {
        "line": 424,
        "fullcodeline": "flags = TAG_NOIC;"
    },
    {
        "line": 453,
        "fullcodeline": "for (j = 0; j < num_matches; ++j)"
    },
    {
        "line": 498,
        "fullcodeline": "cur_match = count > 0 ? count - 1 : 0;"
    },
    {
        "line": 518,
        "fullcodeline": "i = prompt_for_number(NULL);"
    },
    {
        "line": 533,
        "fullcodeline": "cur_match = i - 1;"
    },
    {
        "line": 550,
        "fullcodeline": "cur_match = num_matches - 1;"
    },
    {
        "line": 556,
        "fullcodeline": "tagstack[tagstackidx].cur_match = cur_match;"
    },
    {
        "line": 557,
        "fullcodeline": "tagstack[tagstackidx].cur_fnum = cur_fnum;"
    },
    {
        "line": 568,
        "fullcodeline": "++tagstackidx;"
    },
    {
        "line": 583,
        "fullcodeline": "smsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);"
    },
    {
        "line": 592,
        "fullcodeline": "&& !skip_msg)"
    },
    {
        "line": 595,
        "fullcodeline": "sprintf((char *)IObuff, _(\"tag %d of %d%s\"),"
    },
    {
        "line": 655,
        "fullcodeline": "semsg(_(e_file_str_does_not_exist), nofile_fname);"
    },
    {
        "line": 143,
        "fullcodeline": "tagstacklen = TAGSTACKSIZE;"
    },
    {
        "line": 144,
        "fullcodeline": "tagstack_clear_entry(&tagstack[0]);"
    },
    {
        "line": 147,
        "fullcodeline": "--tagstackidx;"
    },
    {
        "line": 155,
        "fullcodeline": "curwin->w_tagstacklen = tagstacklen - 1;"
    },
    {
        "line": 174,
        "fullcodeline": "emsg(_(e_tag_stack_empty));"
    },
    {
        "line": 204,
        "fullcodeline": "saved_fmark = tagstack[tagstackidx].fmark;"
    },
    {
        "line": 226,
        "fullcodeline": "curwin->w_cursor.col = saved_fmark.mark.col;"
    },
    {
        "line": 227,
        "fullcodeline": "curwin->w_set_curswant = TRUE;"
    },
    {
        "line": 228,
        "fullcodeline": "check_cursor();"
    },
    {
        "line": 235,
        "fullcodeline": "FreeWild(num_matches, matches);"
    },
    {
        "line": 239,
        "fullcodeline": "num_matches = 0;"
    },
    {
        "line": 240,
        "fullcodeline": "tag_freematch();"
    },
    {
        "line": 281,
        "fullcodeline": "new_tag = TRUE;"
    },
    {
        "line": 455,
        "fullcodeline": "parse_match(matches[j], &tagp);"
    },
    {
        "line": 519,
        "fullcodeline": "if (i <= 0 || i > num_matches || got_int)"
    },
    {
        "line": 541,
        "fullcodeline": "if ((type == DT_NEXT || type == DT_FIRST)"
    },
    {
        "line": 560,
        "fullcodeline": "if (use_tfu && parse_match(matches[cur_match], &tagp) == OK"
    },
    {
        "line": 591,
        "fullcodeline": "&& (num_matches > 1 || ic)"
    },
    {
        "line": 596,
        "fullcodeline": "cur_match + 1,"
    },
    {
        "line": 598,
        "fullcodeline": "max_num_matches != MAXCOL ? _(\" or more\") : \"\");"
    },
    {
        "line": 601,
        "fullcodeline": "if ((num_matches > prev_num_matches || new_tag)"
    },
    {
        "line": 612,
        "fullcodeline": "if (ic && !msg_scrolled && msg_silent == 0)"
    },
    {
        "line": 637,
        "fullcodeline": "if ((type == DT_PREV && cur_match > 0)"
    },
    {
        "line": 145,
        "fullcodeline": "for (i = 1; i < tagstacklen; ++i)"
    },
    {
        "line": 146,
        "fullcodeline": "tagstack[i - 1] = tagstack[i];"
    },
    {
        "line": 183,
        "fullcodeline": "if ((tagstackidx -= count) < 0)"
    },
    {
        "line": 205,
        "fullcodeline": "if (saved_fmark.fnum != curbuf->b_fnum)"
    },
    {
        "line": 260,
        "fullcodeline": "save_pos = TRUE;\t// save the cursor position below"
    },
    {
        "line": 278,
        "fullcodeline": "cur_match = tagstack[tagstackidx].cur_match;"
    },
    {
        "line": 279,
        "fullcodeline": "cur_fnum = tagstack[tagstackidx].cur_fnum;"
    },
    {
        "line": 286,
        "fullcodeline": "prevtagstackidx = tagstackidx;"
    },
    {
        "line": 456,
        "fullcodeline": "for (i = idx; i < new_num_matches; ++i)"
    },
    {
        "line": 499,
        "fullcodeline": "else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))"
    },
    {
        "line": 542,
        "fullcodeline": "&& nofile_fname == NULL)"
    },
    {
        "line": 548,
        "fullcodeline": "skip_msg = TRUE;"
    },
    {
        "line": 563,
        "fullcodeline": "VIM_CLEAR(tagstack[tagstackidx].user_data);"
    },
    {
        "line": 564,
        "fullcodeline": "tagstack[tagstackidx].user_data = vim_strnsave("
    },
    {
        "line": 600,
        "fullcodeline": "STRCAT(IObuff, _(\"  Using tag with different case!\"));"
    },
    {
        "line": 602,
        "fullcodeline": "&& num_matches > 1)"
    },
    {
        "line": 608,
        "fullcodeline": "msg_scroll = TRUE;\t// don't overwrite this message"
    },
    {
        "line": 614,
        "fullcodeline": "out_flush();"
    },
    {
        "line": 615,
        "fullcodeline": "ui_delay(1007L, TRUE);"
    },
    {
        "line": 638,
        "fullcodeline": "|| ((type == DT_TAG || type == DT_NEXT"
    },
    {
        "line": 643,
        "fullcodeline": "error_cur_match = cur_match;"
    },
    {
        "line": 661,
        "fullcodeline": "if (use_tagstack && tagstackidx > curwin->w_tagstacklen)"
    },
    {
        "line": 185,
        "fullcodeline": "emsg(_(e_at_bottom_of_tag_stack));"
    },
    {
        "line": 194,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 219,
        "fullcodeline": "curwin->w_cursor.lnum = saved_fmark.mark.lnum;"
    },
    {
        "line": 261,
        "fullcodeline": "if ((tagstackidx += count - 1) >= tagstacklen)"
    },
    {
        "line": 299,
        "fullcodeline": "cur_match = tagstack[tagstackidx].cur_match;"
    },
    {
        "line": 300,
        "fullcodeline": "cur_fnum = tagstack[tagstackidx].cur_fnum;"
    },
    {
        "line": 314,
        "fullcodeline": "if (cur_match >= MAXCOL)"
    },
    {
        "line": 458,
        "fullcodeline": "parse_match(new_matches[i], &tagp2);"
    },
    {
        "line": 501,
        "fullcodeline": "print_tag_list(new_tag, use_tagstack, num_matches, matches);"
    },
    {
        "line": 502,
        "fullcodeline": "ask_for_selection = TRUE;"
    },
    {
        "line": 544,
        "fullcodeline": "if (num_matches == 1)"
    },
    {
        "line": 611,
        "fullcodeline": "give_warning(IObuff, ic);"
    },
    {
        "line": 640,
        "fullcodeline": "&& (max_num_matches != MAXCOL"
    },
    {
        "line": 646,
        "fullcodeline": "if (type == DT_PREV)"
    },
    {
        "line": 662,
        "fullcodeline": "tagstackidx = curwin->w_tagstackidx;"
    },
    {
        "line": 186,
        "fullcodeline": "if (tagstackidx + count == 0)"
    },
    {
        "line": 211,
        "fullcodeline": "if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,"
    },
    {
        "line": 223,
        "fullcodeline": "setpcmark();"
    },
    {
        "line": 224,
        "fullcodeline": "curwin->w_cursor.lnum = saved_fmark.mark.lnum;"
    },
    {
        "line": 268,
        "fullcodeline": "tagstackidx = tagstacklen - 1;"
    },
    {
        "line": 269,
        "fullcodeline": "emsg(_(e_at_top_of_tag_stack));"
    },
    {
        "line": 270,
        "fullcodeline": "save_pos = FALSE;"
    },
    {
        "line": 297,
        "fullcodeline": "if (--tagstackidx < 0)"
    },
    {
        "line": 304,
        "fullcodeline": "case DT_FIRST: cur_match = count - 1; break;"
    },
    {
        "line": 310,
        "fullcodeline": "case DT_LAST:  cur_match = MAXCOL - 1; break;"
    },
    {
        "line": 311,
        "fullcodeline": "case DT_NEXT:  cur_match += count; break;"
    },
    {
        "line": 312,
        "fullcodeline": "case DT_PREV:  cur_match -= count; break;"
    },
    {
        "line": 315,
        "fullcodeline": "cur_match = MAXCOL - 1;"
    },
    {
        "line": 459,
        "fullcodeline": "if (STRCMP(tagp.tagname, tagp2.tagname) == 0)"
    },
    {
        "line": 524,
        "fullcodeline": "tagstack[tagstackidx].fmark = saved_fmark;"
    },
    {
        "line": 525,
        "fullcodeline": "tagstackidx = prevtagstackidx;"
    },
    {
        "line": 545,
        "fullcodeline": "emsg(_(e_there_is_only_one_matching_tag));"
    },
    {
        "line": 565,
        "fullcodeline": "tagp.user_data, tagp.user_data_end - tagp.user_data);"
    },
    {
        "line": 605,
        "fullcodeline": "msg_attr((char *)IObuff, HL_ATTR(HLF_W));"
    },
    {
        "line": 639,
        "fullcodeline": "|| type == DT_FIRST)"
    },
    {
        "line": 641,
        "fullcodeline": "|| cur_match < num_matches - 1)))"
    },
    {
        "line": 645,
        "fullcodeline": "--tagstackidx;"
    },
    {
        "line": 647,
        "fullcodeline": "--cur_match;"
    },
    {
        "line": 189,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 196,
        "fullcodeline": "else if (tagstackidx >= tagstacklen)    // count == 0?"
    },
    {
        "line": 214,
        "fullcodeline": "tagstackidx = oldtagstackidx;  // back to old posn"
    },
    {
        "line": 298,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 461,
        "fullcodeline": "char_u *p = new_matches[i];"
    },
    {
        "line": 464,
        "fullcodeline": "new_matches[idx++] = p;"
    },
    {
        "line": 547,
        "fullcodeline": "emsg(_(e_cannot_go_beyond_last_matching_tag));"
    },
    {
        "line": 607,
        "fullcodeline": "msg((char *)IObuff);"
    },
    {
        "line": 650,
        "fullcodeline": "type = DT_NEXT;"
    },
    {
        "line": 651,
        "fullcodeline": "++cur_match;"
    },
    {
        "line": 198,
        "fullcodeline": "emsg(_(e_at_top_of_tag_stack));"
    },
    {
        "line": 272,
        "fullcodeline": "else if (tagstackidx < 0)\t// must have been count == 0"
    },
    {
        "line": 316,
        "fullcodeline": "else if (cur_match < 0)"
    },
    {
        "line": 462,
        "fullcodeline": "for (k = i; k > idx; --k)"
    },
    {
        "line": 463,
        "fullcodeline": "new_matches[k] = new_matches[k - 1];"
    },
    {
        "line": 274,
        "fullcodeline": "emsg(_(e_at_bottom_of_tag_stack));"
    },
    {
        "line": 275,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 318,
        "fullcodeline": "emsg(_(e_cannot_go_before_first_matching_tag));"
    },
    {
        "line": 319,
        "fullcodeline": "skip_msg = TRUE;"
    },
    {
        "line": 320,
        "fullcodeline": "cur_match = 0;"
    },
    {
        "line": 321,
        "fullcodeline": "cur_fnum = curbuf->b_fnum;"
    }
]