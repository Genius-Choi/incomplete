[
    {
        "line": 11,
        "fullcodeline": "int\t\tcur_match = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\toldtagstackidx = tagstackidx;"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tprevtagstackidx = tagstackidx;"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tnew_tag = FALSE;"
    },
    {
        "line": 19,
        "fullcodeline": "int\t\tno_regexp = FALSE;"
    },
    {
        "line": 20,
        "fullcodeline": "int\t\terror_cur_match = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tsave_pos = FALSE;"
    },
    {
        "line": 29,
        "fullcodeline": "int\t\tskip_msg = FALSE;"
    },
    {
        "line": 32,
        "fullcodeline": "int\t\tuse_tfu = 1;"
    },
    {
        "line": 35,
        "fullcodeline": "static int\t\tnum_matches = 0;"
    },
    {
        "line": 36,
        "fullcodeline": "static int\t\tmax_num_matches = 0;  // limit used for match search"
    },
    {
        "line": 37,
        "fullcodeline": "static char_u\t**matches = NULL;"
    },
    {
        "line": 68,
        "fullcodeline": "prev_num_matches = num_matches;"
    },
    {
        "line": 69,
        "fullcodeline": "free_string_option(nofile_fname);"
    },
    {
        "line": 70,
        "fullcodeline": "nofile_fname = NULL;"
    },
    {
        "line": 73,
        "fullcodeline": "saved_fmark.fnum = 0;"
    },
    {
        "line": 669,
        "fullcodeline": "postponed_split = 0;\t// don't split next time"
    },
    {
        "line": 61,
        "fullcodeline": "if (type == DT_HELP)"
    },
    {
        "line": 78,
        "fullcodeline": "if ((!p_tgst && *tag != NUL))"
    },
    {
        "line": 362,
        "fullcodeline": "if (cur_fnum != curbuf->b_fnum)"
    },
    {
        "line": 667,
        "fullcodeline": "if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)"
    },
    {
        "line": 63,
        "fullcodeline": "type = DT_TAG;"
    },
    {
        "line": 64,
        "fullcodeline": "no_regexp = TRUE;"
    },
    {
        "line": 65,
        "fullcodeline": "use_tfu = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "use_tagstack = FALSE;"
    },
    {
        "line": 81,
        "fullcodeline": "new_tag = TRUE;"
    },
    {
        "line": 364,
        "fullcodeline": "buf_T *buf = buflist_findnr(cur_fnum);"
    },
    {
        "line": 389,
        "fullcodeline": "other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);"
    },
    {
        "line": 668,
        "fullcodeline": "curwin->w_tagstackidx = tagstackidx;"
    },
    {
        "line": 98,
        "fullcodeline": "use_tagstack = TRUE;"
    },
    {
        "line": 366,
        "fullcodeline": "if (buf != NULL)"
    },
    {
        "line": 390,
        "fullcodeline": "if (new_tag"
    },
    {
        "line": 469,
        "fullcodeline": "if (num_matches <= 0)"
    },
    {
        "line": 101,
        "fullcodeline": "if (*tag != NUL"
    },
    {
        "line": 350,
        "fullcodeline": "curwin->w_tagstackidx = tagstackidx;"
    },
    {
        "line": 367,
        "fullcodeline": "buf_ffname = buf->b_ffname;"
    },
    {
        "line": 464,
        "fullcodeline": "FreeWild(num_matches, matches);"
    },
    {
        "line": 465,
        "fullcodeline": "num_matches = new_num_matches;"
    },
    {
        "line": 466,
        "fullcodeline": "matches = new_matches;"
    },
    {
        "line": 102,
        "fullcodeline": "&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP"
    },
    {
        "line": 162,
        "fullcodeline": "new_tag = TRUE;"
    },
    {
        "line": 351,
        "fullcodeline": "if (type != DT_SELECT && type != DT_JUMP)"
    },
    {
        "line": 388,
        "fullcodeline": "name = tag;"
    },
    {
        "line": 391,
        "fullcodeline": "|| (cur_match >= num_matches && max_num_matches != MAXCOL)"
    },
    {
        "line": 400,
        "fullcodeline": "if (type == DT_SELECT || type == DT_JUMP"
    },
    {
        "line": 406,
        "fullcodeline": "if (type == DT_TAG)"
    },
    {
        "line": 412,
        "fullcodeline": "if (!no_regexp && *name == '/')"
    },
    {
        "line": 427,
        "fullcodeline": "if (!use_tfu)"
    },
    {
        "line": 430,
        "fullcodeline": "if (find_tags(name, &new_num_matches, &new_matches, flags,"
    },
    {
        "line": 439,
        "fullcodeline": "if (!new_tag && !other_name)"
    },
    {
        "line": 479,
        "fullcodeline": "int ask_for_selection = FALSE;"
    },
    {
        "line": 580,
        "fullcodeline": "ic = (matches[cur_match][0] & MT_IC_OFF);"
    },
    {
        "line": 622,
        "fullcodeline": "i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);"
    },
    {
        "line": 157,
        "fullcodeline": "curwin->w_tagstacklen = tagstacklen;"
    },
    {
        "line": 159,
        "fullcodeline": "save_pos = TRUE;\t// save the cursor position below"
    },
    {
        "line": 353,
        "fullcodeline": "curwin->w_tagstack[tagstackidx].cur_match = cur_match;"
    },
    {
        "line": 354,
        "fullcodeline": "curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;"
    },
    {
        "line": 396,
        "fullcodeline": "vim_free(tagmatchname);"
    },
    {
        "line": 397,
        "fullcodeline": "tagmatchname = vim_strsave(name);"
    },
    {
        "line": 405,
        "fullcodeline": "cur_match = MAXCOL - 1;"
    },
    {
        "line": 407,
        "fullcodeline": "max_num_matches = MAXCOL;"
    },
    {
        "line": 414,
        "fullcodeline": "flags = TAG_REGEXP;"
    },
    {
        "line": 415,
        "fullcodeline": "++name;"
    },
    {
        "line": 425,
        "fullcodeline": "flags |= TAG_VERBOSE;"
    },
    {
        "line": 428,
        "fullcodeline": "flags |= TAG_NO_TAGFUNC;"
    },
    {
        "line": 432,
        "fullcodeline": "&& new_num_matches < max_num_matches)"
    },
    {
        "line": 433,
        "fullcodeline": "max_num_matches = MAXCOL; // If less than max_num_matches"
    },
    {
        "line": 442,
        "fullcodeline": "int\t    idx = 0;"
    },
    {
        "line": 472,
        "fullcodeline": "semsg(_(e_tag_not_found_str), name);"
    },
    {
        "line": 489,
        "fullcodeline": "if (type == DT_TAG && *tag != NUL)"
    },
    {
        "line": 507,
        "fullcodeline": "if (ask_for_selection == TRUE)"
    },
    {
        "line": 530,
        "fullcodeline": "if (cur_match >= num_matches)"
    },
    {
        "line": 576,
        "fullcodeline": "if (nofile_fname != NULL && error_cur_match != cur_match)"
    },
    {
        "line": 581,
        "fullcodeline": "if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP"
    },
    {
        "line": 628,
        "fullcodeline": "if (i == NOTAGFILE)"
    },
    {
        "line": 136,
        "fullcodeline": "while (tagstackidx < tagstacklen)"
    },
    {
        "line": 137,
        "fullcodeline": "tagstack_clear_entry(&tagstack[--tagstacklen]);"
    },
    {
        "line": 140,
        "fullcodeline": "if (++tagstacklen > TAGSTACKSIZE)"
    },
    {
        "line": 152,
        "fullcodeline": "if ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)"
    },
    {
        "line": 170,
        "fullcodeline": "tagstacklen == 0)"
    },
    {
        "line": 177,
        "fullcodeline": "if (type == DT_POP)\t\t// go to older position"
    },
    {
        "line": 243,
        "fullcodeline": "if (type == DT_TAG"
    },
    {
        "line": 409,
        "fullcodeline": "max_num_matches = cur_match + 1;"
    },
    {
        "line": 418,
        "fullcodeline": "flags = TAG_NOIC;"
    },
    {
        "line": 447,
        "fullcodeline": "for (j = 0; j < num_matches; ++j)"
    },
    {
        "line": 492,
        "fullcodeline": "cur_match = count > 0 ? count - 1 : 0;"
    },
    {
        "line": 512,
        "fullcodeline": "i = prompt_for_number(NULL);"
    },
    {
        "line": 527,
        "fullcodeline": "cur_match = i - 1;"
    },
    {
        "line": 544,
        "fullcodeline": "cur_match = num_matches - 1;"
    },
    {
        "line": 550,
        "fullcodeline": "tagstack[tagstackidx].cur_match = cur_match;"
    },
    {
        "line": 551,
        "fullcodeline": "tagstack[tagstackidx].cur_fnum = cur_fnum;"
    },
    {
        "line": 562,
        "fullcodeline": "++tagstackidx;"
    },
    {
        "line": 577,
        "fullcodeline": "smsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);"
    },
    {
        "line": 586,
        "fullcodeline": "&& !skip_msg)"
    },
    {
        "line": 589,
        "fullcodeline": "sprintf((char *)IObuff, _(\"tag %d of %d%s\"),"
    },
    {
        "line": 649,
        "fullcodeline": "semsg(_(e_file_str_does_not_exist), nofile_fname);"
    },
    {
        "line": 142,
        "fullcodeline": "tagstacklen = TAGSTACKSIZE;"
    },
    {
        "line": 143,
        "fullcodeline": "tagstack_clear_entry(&tagstack[0]);"
    },
    {
        "line": 146,
        "fullcodeline": "--tagstackidx;"
    },
    {
        "line": 154,
        "fullcodeline": "curwin->w_tagstacklen = tagstacklen - 1;"
    },
    {
        "line": 173,
        "fullcodeline": "emsg(_(e_tag_stack_empty));"
    },
    {
        "line": 226,
        "fullcodeline": "curwin->w_set_curswant = TRUE;"
    },
    {
        "line": 227,
        "fullcodeline": "check_cursor();"
    },
    {
        "line": 234,
        "fullcodeline": "FreeWild(num_matches, matches);"
    },
    {
        "line": 238,
        "fullcodeline": "num_matches = 0;"
    },
    {
        "line": 239,
        "fullcodeline": "tag_freematch();"
    },
    {
        "line": 280,
        "fullcodeline": "new_tag = TRUE;"
    },
    {
        "line": 449,
        "fullcodeline": "parse_match(matches[j], &tagp);"
    },
    {
        "line": 513,
        "fullcodeline": "if (i <= 0 || i > num_matches || got_int)"
    },
    {
        "line": 535,
        "fullcodeline": "if ((type == DT_NEXT || type == DT_FIRST)"
    },
    {
        "line": 554,
        "fullcodeline": "if (use_tfu && parse_match(matches[cur_match], &tagp) == OK"
    },
    {
        "line": 585,
        "fullcodeline": "&& (num_matches > 1 || ic)"
    },
    {
        "line": 590,
        "fullcodeline": "cur_match + 1,"
    },
    {
        "line": 592,
        "fullcodeline": "max_num_matches != MAXCOL ? _(\" or more\") : \"\");"
    },
    {
        "line": 595,
        "fullcodeline": "if ((num_matches > prev_num_matches || new_tag)"
    },
    {
        "line": 606,
        "fullcodeline": "if (ic && !msg_scrolled && msg_silent == 0)"
    },
    {
        "line": 631,
        "fullcodeline": "if ((type == DT_PREV && cur_match > 0)"
    },
    {
        "line": 144,
        "fullcodeline": "for (i = 1; i < tagstacklen; ++i)"
    },
    {
        "line": 145,
        "fullcodeline": "tagstack[i - 1] = tagstack[i];"
    },
    {
        "line": 182,
        "fullcodeline": "if ((tagstackidx -= count) < 0)"
    },
    {
        "line": 204,
        "fullcodeline": "if (saved_fmark.fnum != curbuf->b_fnum)"
    },
    {
        "line": 259,
        "fullcodeline": "save_pos = TRUE;\t// save the cursor position below"
    },
    {
        "line": 285,
        "fullcodeline": "prevtagstackidx = tagstackidx;"
    },
    {
        "line": 450,
        "fullcodeline": "for (i = idx; i < new_num_matches; ++i)"
    },
    {
        "line": 493,
        "fullcodeline": "else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))"
    },
    {
        "line": 536,
        "fullcodeline": "&& nofile_fname == NULL)"
    },
    {
        "line": 542,
        "fullcodeline": "skip_msg = TRUE;"
    },
    {
        "line": 558,
        "fullcodeline": "tagstack[tagstackidx].user_data = vim_strnsave("
    },
    {
        "line": 594,
        "fullcodeline": "STRCAT(IObuff, _(\"  Using tag with different case!\"));"
    },
    {
        "line": 596,
        "fullcodeline": "&& num_matches > 1)"
    },
    {
        "line": 602,
        "fullcodeline": "msg_scroll = TRUE;\t// don't overwrite this message"
    },
    {
        "line": 608,
        "fullcodeline": "out_flush();"
    },
    {
        "line": 609,
        "fullcodeline": "ui_delay(1007L, TRUE);"
    },
    {
        "line": 632,
        "fullcodeline": "|| ((type == DT_TAG || type == DT_NEXT"
    },
    {
        "line": 637,
        "fullcodeline": "error_cur_match = cur_match;"
    },
    {
        "line": 655,
        "fullcodeline": "if (use_tagstack && tagstackidx > curwin->w_tagstacklen)"
    },
    {
        "line": 184,
        "fullcodeline": "emsg(_(e_at_bottom_of_tag_stack));"
    },
    {
        "line": 193,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 218,
        "fullcodeline": "curwin->w_cursor.lnum = saved_fmark.mark.lnum;"
    },
    {
        "line": 260,
        "fullcodeline": "if ((tagstackidx += count - 1) >= tagstacklen)"
    },
    {
        "line": 313,
        "fullcodeline": "if (cur_match >= MAXCOL)"
    },
    {
        "line": 452,
        "fullcodeline": "parse_match(new_matches[i], &tagp2);"
    },
    {
        "line": 495,
        "fullcodeline": "print_tag_list(new_tag, use_tagstack, num_matches, matches);"
    },
    {
        "line": 496,
        "fullcodeline": "ask_for_selection = TRUE;"
    },
    {
        "line": 538,
        "fullcodeline": "if (num_matches == 1)"
    },
    {
        "line": 605,
        "fullcodeline": "give_warning(IObuff, ic);"
    },
    {
        "line": 634,
        "fullcodeline": "&& (max_num_matches != MAXCOL"
    },
    {
        "line": 640,
        "fullcodeline": "if (type == DT_PREV)"
    },
    {
        "line": 656,
        "fullcodeline": "tagstackidx = curwin->w_tagstackidx;"
    },
    {
        "line": 185,
        "fullcodeline": "if (tagstackidx + count == 0)"
    },
    {
        "line": 210,
        "fullcodeline": "if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,"
    },
    {
        "line": 222,
        "fullcodeline": "setpcmark();"
    },
    {
        "line": 267,
        "fullcodeline": "tagstackidx = tagstacklen - 1;"
    },
    {
        "line": 268,
        "fullcodeline": "emsg(_(e_at_top_of_tag_stack));"
    },
    {
        "line": 269,
        "fullcodeline": "save_pos = FALSE;"
    },
    {
        "line": 296,
        "fullcodeline": "if (--tagstackidx < 0)"
    },
    {
        "line": 303,
        "fullcodeline": "case DT_FIRST: cur_match = count - 1; break;"
    },
    {
        "line": 309,
        "fullcodeline": "case DT_LAST:  cur_match = MAXCOL - 1; break;"
    },
    {
        "line": 310,
        "fullcodeline": "case DT_NEXT:  cur_match += count; break;"
    },
    {
        "line": 311,
        "fullcodeline": "case DT_PREV:  cur_match -= count; break;"
    },
    {
        "line": 314,
        "fullcodeline": "cur_match = MAXCOL - 1;"
    },
    {
        "line": 453,
        "fullcodeline": "if (STRCMP(tagp.tagname, tagp2.tagname) == 0)"
    },
    {
        "line": 518,
        "fullcodeline": "tagstack[tagstackidx].fmark = saved_fmark;"
    },
    {
        "line": 519,
        "fullcodeline": "tagstackidx = prevtagstackidx;"
    },
    {
        "line": 539,
        "fullcodeline": "emsg(_(e_there_is_only_one_matching_tag));"
    },
    {
        "line": 559,
        "fullcodeline": "tagp.user_data, tagp.user_data_end - tagp.user_data);"
    },
    {
        "line": 599,
        "fullcodeline": "msg_attr((char *)IObuff, HL_ATTR(HLF_W));"
    },
    {
        "line": 633,
        "fullcodeline": "|| type == DT_FIRST)"
    },
    {
        "line": 635,
        "fullcodeline": "|| cur_match < num_matches - 1)))"
    },
    {
        "line": 639,
        "fullcodeline": "--tagstackidx;"
    },
    {
        "line": 641,
        "fullcodeline": "--cur_match;"
    },
    {
        "line": 188,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 195,
        "fullcodeline": "else if (tagstackidx >= tagstacklen)    // count == 0?"
    },
    {
        "line": 213,
        "fullcodeline": "tagstackidx = oldtagstackidx;  // back to old posn"
    },
    {
        "line": 297,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 455,
        "fullcodeline": "char_u *p = new_matches[i];"
    },
    {
        "line": 458,
        "fullcodeline": "new_matches[idx++] = p;"
    },
    {
        "line": 541,
        "fullcodeline": "emsg(_(e_cannot_go_beyond_last_matching_tag));"
    },
    {
        "line": 601,
        "fullcodeline": "msg((char *)IObuff);"
    },
    {
        "line": 644,
        "fullcodeline": "type = DT_NEXT;"
    },
    {
        "line": 645,
        "fullcodeline": "++cur_match;"
    },
    {
        "line": 197,
        "fullcodeline": "emsg(_(e_at_top_of_tag_stack));"
    },
    {
        "line": 271,
        "fullcodeline": "else if (tagstackidx < 0)\t// must have been count == 0"
    },
    {
        "line": 315,
        "fullcodeline": "else if (cur_match < 0)"
    },
    {
        "line": 456,
        "fullcodeline": "for (k = i; k > idx; --k)"
    },
    {
        "line": 273,
        "fullcodeline": "emsg(_(e_at_bottom_of_tag_stack));"
    },
    {
        "line": 274,
        "fullcodeline": "tagstackidx = 0;"
    },
    {
        "line": 317,
        "fullcodeline": "emsg(_(e_cannot_go_before_first_matching_tag));"
    },
    {
        "line": 318,
        "fullcodeline": "skip_msg = TRUE;"
    },
    {
        "line": 319,
        "fullcodeline": "cur_match = 0;"
    },
    {
        "line": 457,
        "fullcodeline": "new_matches[k] = new_matches[k - 1];"
    }
]