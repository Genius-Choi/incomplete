[
    {
        "line": 24,
        "fullcodeline": "char* combinedBuf{nullptr};"
    },
    {
        "line": 32,
        "fullcodeline": "*countWritten = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "*partialWritten = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "ssize_t totalWritten = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "size_t bytesStolenFromNextBuffer = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "if (sslState_ == STATE_UNENCRYPTED) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (sslState_ != STATE_ESTABLISHED) {"
    },
    {
        "line": 36,
        "fullcodeline": "for (uint32_t i = 0; i < count; i++) {"
    },
    {
        "line": 150,
        "fullcodeline": "return WriteResult(totalWritten);"
    },
    {
        "line": 12,
        "fullcodeline": "LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)"
    },
    {
        "line": 37,
        "fullcodeline": "const iovec* v = vec + i;"
    },
    {
        "line": 38,
        "fullcodeline": "size_t offset = bytesStolenFromNextBuffer;"
    },
    {
        "line": 39,
        "fullcodeline": "bytesStolenFromNextBuffer = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "size_t len = v->iov_len - offset;"
    },
    {
        "line": 46,
        "fullcodeline": "buf = ((const char*)v->iov_base) + offset;"
    },
    {
        "line": 49,
        "fullcodeline": "uint32_t buffersStolen = 0;"
    },
    {
        "line": 50,
        "fullcodeline": "auto sslWriteBuf = buf;"
    },
    {
        "line": 107,
        "fullcodeline": "corkCurrentWrite_ ="
    },
    {
        "line": 113,
        "fullcodeline": "appEorByteWriteFlags_ = flags & kEorRelevantWriteFlags;"
    },
    {
        "line": 114,
        "fullcodeline": "bool trackEor = appEorByteWriteFlags_ != folly::WriteFlags::NONE &&"
    },
    {
        "line": 116,
        "fullcodeline": "bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);"
    },
    {
        "line": 128,
        "fullcodeline": "totalWritten += bytes;"
    },
    {
        "line": 8,
        "fullcodeline": "return AsyncSocket::performWrite("
    },
    {
        "line": 17,
        "fullcodeline": "return WriteResult("
    },
    {
        "line": 42,
        "fullcodeline": "if (len == 0) {"
    },
    {
        "line": 51,
        "fullcodeline": "if ((len < minWriteSize_) && ((i + 1) < count)) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (bytesStolenFromNextBuffer == 0) {"
    },
    {
        "line": 108,
        "fullcodeline": "isSet(flags, WriteFlags::CORK) || (i + buffersStolen + 1 < count);"
    },
    {
        "line": 118,
        "fullcodeline": "if (bytes <= 0) {"
    },
    {
        "line": 130,
        "fullcodeline": "if (bytes == (ssize_t)len) {"
    },
    {
        "line": 18,
        "fullcodeline": "WRITE_ERROR, std::make_unique<SSLException>(SSLError::EARLY_WRITE));"
    },
    {
        "line": 43,
        "fullcodeline": "(*countWritten)++;"
    },
    {
        "line": 70,
        "fullcodeline": "assert(combinedBuf != nullptr);"
    },
    {
        "line": 71,
        "fullcodeline": "sslWriteBuf = combinedBuf;"
    },
    {
        "line": 73,
        "fullcodeline": "memcpy(combinedBuf, buf, len);"
    },
    {
        "line": 115,
        "fullcodeline": "(i + buffersStolen + 1 == count);"
    },
    {
        "line": 119,
        "fullcodeline": "int error = SSL_get_error(ssl_.get(), int(bytes));"
    },
    {
        "line": 132,
        "fullcodeline": "(*countWritten) += 1 + buffersStolen;"
    },
    {
        "line": 133,
        "fullcodeline": "i += buffersStolen;"
    },
    {
        "line": 61,
        "fullcodeline": "if (combinedBuf == nullptr) {"
    },
    {
        "line": 94,
        "fullcodeline": "} while ((i + buffersStolen + 1) < count && (len < minWriteSize_));"
    },
    {
        "line": 99,
        "fullcodeline": "while ((i + buffersStolen + 1) < count &&"
    },
    {
        "line": 120,
        "fullcodeline": "if (error == SSL_ERROR_WANT_WRITE) {"
    },
    {
        "line": 125,
        "fullcodeline": "return interpretSSLError(int(bytes), error);"
    },
    {
        "line": 136,
        "fullcodeline": "bytes += offset; // adjust bytes to account for all of v"
    },
    {
        "line": 145,
        "fullcodeline": "*partialWritten = uint32_t(bytes);"
    },
    {
        "line": 76,
        "fullcodeline": "uint32_t nextIndex = i + buffersStolen + 1;"
    },
    {
        "line": 77,
        "fullcodeline": "bytesStolenFromNextBuffer ="
    },
    {
        "line": 86,
        "fullcodeline": "len += bytesStolenFromNextBuffer;"
    },
    {
        "line": 100,
        "fullcodeline": "vec[i + buffersStolen + 1].iov_len == 0) {"
    },
    {
        "line": 101,
        "fullcodeline": "buffersStolen++;"
    },
    {
        "line": 122,
        "fullcodeline": "*partialWritten = uint32_t(offset);"
    },
    {
        "line": 137,
        "fullcodeline": "while (bytes >= (ssize_t)v->iov_len) {"
    },
    {
        "line": 146,
        "fullcodeline": "return WriteResult(totalWritten);"
    },
    {
        "line": 62,
        "fullcodeline": "if (minWriteSize_ > MAX_STACK_BUF_SIZE) {"
    },
    {
        "line": 78,
        "fullcodeline": "std::min(vec[nextIndex].iov_len, minWriteSize_ - len);"
    },
    {
        "line": 79,
        "fullcodeline": "if (bytesStolenFromNextBuffer > 0) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (bytesStolenFromNextBuffer < vec[nextIndex].iov_len) {"
    },
    {
        "line": 123,
        "fullcodeline": "return WriteResult(totalWritten);"
    },
    {
        "line": 141,
        "fullcodeline": "bytes -= v->iov_len;"
    },
    {
        "line": 142,
        "fullcodeline": "(*countWritten)++;"
    },
    {
        "line": 143,
        "fullcodeline": "v = &(vec[++i]);"
    },
    {
        "line": 64,
        "fullcodeline": "combinedBuf = new char[minWriteSize_];"
    },
    {
        "line": 80,
        "fullcodeline": "assert(vec[nextIndex].iov_base != nullptr);"
    },
    {
        "line": 81,
        "fullcodeline": "::memcpy("
    },
    {
        "line": 67,
        "fullcodeline": "combinedBuf = (char*)alloca(minWriteSize_);"
    },
    {
        "line": 82,
        "fullcodeline": "combinedBuf + len,"
    },
    {
        "line": 91,
        "fullcodeline": "bytesStolenFromNextBuffer = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "buffersStolen++;"
    }
]