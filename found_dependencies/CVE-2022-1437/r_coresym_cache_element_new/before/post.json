[
    {
        "line": 2,
        "fullcodeline": "RCoreSymCacheElement *result = NULL;"
    },
    {
        "line": 3,
        "fullcodeline": "ut8 *b = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "RCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);"
    },
    {
        "line": 16,
        "fullcodeline": "result = R_NEW0 (RCoreSymCacheElement);"
    },
    {
        "line": 20,
        "fullcodeline": "result->hdr = hdr;"
    },
    {
        "line": 21,
        "fullcodeline": "b = malloc (hdr->size);"
    },
    {
        "line": 28,
        "fullcodeline": "ut8 *end = b + hdr->size;"
    },
    {
        "line": 37,
        "fullcodeline": "const size_t word_size = bits / 8;"
    },
    {
        "line": 38,
        "fullcodeline": "const ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;"
    },
    {
        "line": 39,
        "fullcodeline": "const ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;"
    },
    {
        "line": 40,
        "fullcodeline": "const ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;"
    },
    {
        "line": 41,
        "fullcodeline": "const ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;"
    },
    {
        "line": 42,
        "fullcodeline": "const ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;"
    },
    {
        "line": 43,
        "fullcodeline": "const ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;"
    },
    {
        "line": 44,
        "fullcodeline": "const ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;"
    },
    {
        "line": 46,
        "fullcodeline": "ut64 page_zero_size = 0;"
    },
    {
        "line": 47,
        "fullcodeline": "size_t page_zero_idx = 0;"
    },
    {
        "line": 101,
        "fullcodeline": "bool relative_to_strings = false;"
    },
    {
        "line": 244,
        "fullcodeline": "free (b);"
    },
    {
        "line": 5,
        "fullcodeline": "if (!hdr) {"
    },
    {
        "line": 8,
        "fullcodeline": "if (hdr->version != 1) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (!result) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (!b) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (hdr->n_segments > 0) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (hdr->n_sections > 0) {"
    },
    {
        "line": 9,
        "fullcodeline": "eprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);"
    },
    {
        "line": 13,
        "fullcodeline": "eprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);"
    },
    {
        "line": 30,
        "fullcodeline": "result->file_name = file_name;"
    },
    {
        "line": 35,
        "fullcodeline": "result->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);"
    },
    {
        "line": 60,
        "fullcodeline": "result->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);"
    },
    {
        "line": 65,
        "fullcodeline": "ut8 *cursor = b + R_CS_EL_OFF_SEGS;"
    },
    {
        "line": 104,
        "fullcodeline": "result->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);"
    },
    {
        "line": 109,
        "fullcodeline": "ut8 *cursor = b + start_of_sections;"
    },
    {
        "line": 143,
        "fullcodeline": "result->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);"
    },
    {
        "line": 148,
        "fullcodeline": "ut8 *cursor = b + start_of_symbols;"
    },
    {
        "line": 173,
        "fullcodeline": "result->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);"
    },
    {
        "line": 178,
        "fullcodeline": "ut8 *cursor = b + start_of_lined_symbols;"
    },
    {
        "line": 213,
        "fullcodeline": "result->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);"
    },
    {
        "line": 218,
        "fullcodeline": "ut8 *cursor = b + start_of_line_info;"
    },
    {
        "line": 61,
        "fullcodeline": "if (!result->segments) {"
    },
    {
        "line": 66,
        "fullcodeline": "for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {"
    },
    {
        "line": 91,
        "fullcodeline": "for (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (!result->sections) {"
    },
    {
        "line": 110,
        "fullcodeline": "for (i = 0; i < hdr->n_sections && cursor < end; i++) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (!result->symbols) {"
    },
    {
        "line": 149,
        "fullcodeline": "for (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {"
    },
    {
        "line": 174,
        "fullcodeline": "if (!result->lined_symbols) {"
    },
    {
        "line": 179,
        "fullcodeline": "for (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {"
    },
    {
        "line": 214,
        "fullcodeline": "if (!result->line_info) {"
    },
    {
        "line": 219,
        "fullcodeline": "for (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {"
    },
    {
        "line": 50,
        "fullcodeline": "} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {"
    },
    {
        "line": 67,
        "fullcodeline": "RCoreSymCacheElementSegment *seg = &result->segments[i];"
    },
    {
        "line": 68,
        "fullcodeline": "seg->paddr = seg->vaddr = r_read_le64 (cursor);"
    },
    {
        "line": 69,
        "fullcodeline": "cursor += 8;"
    },
    {
        "line": 73,
        "fullcodeline": "seg->size = seg->vsize = r_read_le64 (cursor);"
    },
    {
        "line": 74,
        "fullcodeline": "cursor += 8;"
    },
    {
        "line": 78,
        "fullcodeline": "seg->name = str_dup_safe_fixed (b, cursor, 16, end);"
    },
    {
        "line": 79,
        "fullcodeline": "cursor += 16;"
    },
    {
        "line": 95,
        "fullcodeline": "RCoreSymCacheElementSegment *seg = &result->segments[i];"
    },
    {
        "line": 111,
        "fullcodeline": "ut8 *sect_start = cursor;"
    },
    {
        "line": 112,
        "fullcodeline": "RCoreSymCacheElementSection *sect = &result->sections[i];"
    },
    {
        "line": 113,
        "fullcodeline": "sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);"
    },
    {
        "line": 117,
        "fullcodeline": "cursor += word_size;"
    },
    {
        "line": 121,
        "fullcodeline": "sect->size = r_read_ble (cursor, false, bits);"
    },
    {
        "line": 122,
        "fullcodeline": "cursor += word_size;"
    },
    {
        "line": 126,
        "fullcodeline": "ut64 sect_name_off = r_read_ble (cursor, false, bits);"
    },
    {
        "line": 130,
        "fullcodeline": "cursor += word_size;"
    },
    {
        "line": 134,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : sect_start;"
    },
    {
        "line": 150,
        "fullcodeline": "RCoreSymCacheElementSymbol *sym = &result->symbols[i];"
    },
    {
        "line": 151,
        "fullcodeline": "sym->paddr = r_read_le32 (cursor);"
    },
    {
        "line": 152,
        "fullcodeline": "sym->size = r_read_le32 (cursor + 0x4);"
    },
    {
        "line": 153,
        "fullcodeline": "sym->unk1 = r_read_le32 (cursor + 0x8);"
    },
    {
        "line": 154,
        "fullcodeline": "size_t name_off = r_read_le32 (cursor + 0xc);"
    },
    {
        "line": 155,
        "fullcodeline": "size_t mangled_name_off = r_read_le32 (cursor + 0x10);"
    },
    {
        "line": 156,
        "fullcodeline": "sym->unk2 = (st32)r_read_le32 (cursor + 0x14);"
    },
    {
        "line": 157,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : cursor;"
    },
    {
        "line": 158,
        "fullcodeline": "sym->name = str_dup_safe (b, string_origin + name_off, end);"
    },
    {
        "line": 163,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : cursor;"
    },
    {
        "line": 164,
        "fullcodeline": "sym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);"
    },
    {
        "line": 169,
        "fullcodeline": "cursor += R_CS_EL_SIZE_SYM;"
    },
    {
        "line": 180,
        "fullcodeline": "RCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];"
    },
    {
        "line": 181,
        "fullcodeline": "lsym->sym.paddr = r_read_le32 (cursor);"
    },
    {
        "line": 182,
        "fullcodeline": "lsym->sym.size = r_read_le32 (cursor + 0x4);"
    },
    {
        "line": 183,
        "fullcodeline": "lsym->sym.unk1 = r_read_le32 (cursor + 0x8);"
    },
    {
        "line": 184,
        "fullcodeline": "size_t name_off = r_read_le32 (cursor + 0xc);"
    },
    {
        "line": 185,
        "fullcodeline": "size_t mangled_name_off = r_read_le32 (cursor + 0x10);"
    },
    {
        "line": 186,
        "fullcodeline": "lsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);"
    },
    {
        "line": 187,
        "fullcodeline": "size_t file_name_off = r_read_le32 (cursor + 0x18);"
    },
    {
        "line": 188,
        "fullcodeline": "lsym->flc.line = r_read_le32 (cursor + 0x1c);"
    },
    {
        "line": 189,
        "fullcodeline": "lsym->flc.col = r_read_le32 (cursor + 0x20);"
    },
    {
        "line": 190,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : cursor;"
    },
    {
        "line": 191,
        "fullcodeline": "lsym->sym.name = str_dup_safe (b, string_origin + name_off, end);"
    },
    {
        "line": 196,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : cursor;"
    },
    {
        "line": 197,
        "fullcodeline": "lsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);"
    },
    {
        "line": 202,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : cursor;"
    },
    {
        "line": 203,
        "fullcodeline": "lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);"
    },
    {
        "line": 208,
        "fullcodeline": "cursor += R_CS_EL_SIZE_LSYM;"
    },
    {
        "line": 209,
        "fullcodeline": "meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);"
    },
    {
        "line": 220,
        "fullcodeline": "RCoreSymCacheElementLineInfo *info = &result->line_info[i];"
    },
    {
        "line": 221,
        "fullcodeline": "info->paddr = r_read_le32 (cursor);"
    },
    {
        "line": 222,
        "fullcodeline": "info->size = r_read_le32 (cursor + 4);"
    },
    {
        "line": 223,
        "fullcodeline": "size_t file_name_off = r_read_le32 (cursor + 8);"
    },
    {
        "line": 224,
        "fullcodeline": "info->flc.line = r_read_le32 (cursor + 0xc);"
    },
    {
        "line": 225,
        "fullcodeline": "info->flc.col = r_read_le32 (cursor + 0x10);"
    },
    {
        "line": 226,
        "fullcodeline": "string_origin = relative_to_strings? b + start_of_strings : cursor;"
    },
    {
        "line": 227,
        "fullcodeline": "info->flc.file = str_dup_safe (b, string_origin + file_name_off, end);"
    },
    {
        "line": 231,
        "fullcodeline": "cursor += R_CS_EL_SIZE_LINFO;"
    },
    {
        "line": 232,
        "fullcodeline": "meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);"
    },
    {
        "line": 32,
        "fullcodeline": "result->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);"
    },
    {
        "line": 70,
        "fullcodeline": "if (cursor >= end) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (cursor >= end) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (!seg->name) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (!strcmp (seg->name, \"__PAGEZERO\")) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (i == page_zero_idx) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (seg->vaddr < page_zero_size) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (sect->vaddr < page_zero_size) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (cursor + word_size >= end) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (cursor + word_size >= end) {"
    },
    {
        "line": 127,
        "fullcodeline": "if (!i && !sect_name_off) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (bits == 32) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (sect_name_off < (ut64)(size_t)(end - string_origin)) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (!sym->name) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (!sym->mangled_name) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (!lsym->sym.name) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (!lsym->sym.mangled_name) {"
    },
    {
        "line": 204,
        "fullcodeline": "if (!lsym->flc.file) {"
    },
    {
        "line": 228,
        "fullcodeline": "if (!info->flc.file) {"
    },
    {
        "line": 85,
        "fullcodeline": "page_zero_size = seg->size;"
    },
    {
        "line": 86,
        "fullcodeline": "page_zero_idx = i;"
    },
    {
        "line": 87,
        "fullcodeline": "seg->paddr = seg->vaddr = 0;"
    },
    {
        "line": 88,
        "fullcodeline": "seg->size = 0;"
    },
    {
        "line": 97,
        "fullcodeline": "seg->vaddr += page_zero_size;"
    },
    {
        "line": 115,
        "fullcodeline": "sect->vaddr += page_zero_size;"
    },
    {
        "line": 128,
        "fullcodeline": "relative_to_strings = true;"
    },
    {
        "line": 132,
        "fullcodeline": "cursor += word_size;"
    },
    {
        "line": 136,
        "fullcodeline": "sect->name = str_dup_safe (b, string_origin + sect_name_off, end);"
    },
    {
        "line": 160,
        "fullcodeline": "cursor += R_CS_EL_SIZE_SYM;"
    },
    {
        "line": 166,
        "fullcodeline": "cursor += R_CS_EL_SIZE_SYM;"
    },
    {
        "line": 193,
        "fullcodeline": "cursor += R_CS_EL_SIZE_LSYM;"
    },
    {
        "line": 199,
        "fullcodeline": "cursor += R_CS_EL_SIZE_LSYM;"
    },
    {
        "line": 205,
        "fullcodeline": "cursor += R_CS_EL_SIZE_LSYM;"
    },
    {
        "line": 52,
        "fullcodeline": "} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {"
    },
    {
        "line": 138,
        "fullcodeline": "sect->name = strdup (\"\");"
    },
    {
        "line": 54,
        "fullcodeline": "} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {"
    },
    {
        "line": 56,
        "fullcodeline": "} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {"
    }
]