[
    {
        "line": 3,
        "fullcodeline": "GF_BitStream *bs = gf_bs_new(id3_buf, id3_buf_size, GF_BITSTREAM_READ);"
    },
    {
        "line": 5,
        "fullcodeline": "char *_buf=NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "u32 buf_alloc=0;"
    },
    {
        "line": 7,
        "fullcodeline": "gf_bs_skip_bytes(bs, 3);"
    },
    {
        "line": 8,
        "fullcodeline": "/*u8 major = */gf_bs_read_u8(bs);"
    },
    {
        "line": 9,
        "fullcodeline": "/*u8 minor = */gf_bs_read_u8(bs);"
    },
    {
        "line": 10,
        "fullcodeline": "/*u8 unsync = */gf_bs_read_int(bs, 1);"
    },
    {
        "line": 11,
        "fullcodeline": "u8 ext_hdr = gf_bs_read_int(bs, 1);"
    },
    {
        "line": 12,
        "fullcodeline": "gf_bs_read_int(bs, 6);"
    },
    {
        "line": 13,
        "fullcodeline": "u32 size = gf_id3_read_size(bs);"
    },
    {
        "line": 111,
        "fullcodeline": "gf_bs_del(bs);"
    },
    {
        "line": 20,
        "fullcodeline": "while (size && (gf_bs_available(bs)>=10) ) {"
    },
    {
        "line": 22,
        "fullcodeline": "char szTag[1024];"
    },
    {
        "line": 27,
        "fullcodeline": "u32 ftag = gf_bs_read_u32(bs);"
    },
    {
        "line": 28,
        "fullcodeline": "u32 fsize = gf_id3_read_size(bs);"
    },
    {
        "line": 29,
        "fullcodeline": "/*u16 fflags = */gf_bs_read_u16(bs);"
    },
    {
        "line": 31,
        "fullcodeline": "size -= 10;"
    },
    {
        "line": 45,
        "fullcodeline": "gf_bs_read_data(bs, _buf+1, fsize);"
    },
    {
        "line": 46,
        "fullcodeline": "_buf[fsize+1]=0;"
    },
    {
        "line": 47,
        "fullcodeline": "_buf[fsize+2]=0;"
    },
    {
        "line": 48,
        "fullcodeline": "buf = _buf+1;"
    },
    {
        "line": 50,
        "fullcodeline": "tag_idx = gf_itags_find_by_id3tag(ftag);"
    },
    {
        "line": 109,
        "fullcodeline": "size -= fsize;"
    },
    {
        "line": 112,
        "fullcodeline": "if (_buf) gf_free(_buf);"
    },
    {
        "line": 32,
        "fullcodeline": "if (!fsize)"
    },
    {
        "line": 35,
        "fullcodeline": "if (size<fsize) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (buf_alloc<=fsize) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (ftag==GF_ID3V2_FRAME_TXXX) {"
    },
    {
        "line": 36,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Broken ID3 frame tag %s, size %d but remaining bytes %d\\n\", gf_4cc_to_str(ftag), fsize, size));"
    },
    {
        "line": 41,
        "fullcodeline": "_buf = gf_realloc(_buf, fsize+3);"
    },
    {
        "line": 42,
        "fullcodeline": "buf_alloc = fsize+3;"
    },
    {
        "line": 53,
        "fullcodeline": "sep = memchr(buf, 0, fsize);"
    },
    {
        "line": 63,
        "fullcodeline": "} else if (ftag == GF_ID3V2_FRAME_APIC) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (!stricmp(buf+1, \"comment\")) {"
    },
    {
        "line": 66,
        "fullcodeline": "sep = memchr(buf+1, 0, fsize-1);"
    },
    {
        "line": 68,
        "fullcodeline": "sep_desc = memchr(sep+2, 0, fsize-1);"
    },
    {
        "line": 56,
        "fullcodeline": "id3dmx_set_string(audio_pid, \"comment\", sep+1, GF_FALSE);"
    },
    {
        "line": 58,
        "fullcodeline": "strcpy(szTag, \"tag_\");"
    },
    {
        "line": 59,
        "fullcodeline": "strncat(szTag, buf+1, 1019);"
    },
    {
        "line": 60,
        "fullcodeline": "id3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);"
    },
    {
        "line": 72,
        "fullcodeline": "pic_size = (u32) ( (sep_desc + 1) - buf);"
    },
    {
        "line": 73,
        "fullcodeline": "pic_size = fsize - pic_size;"
    },
    {
        "line": 98,
        "fullcodeline": "} else if (tag_idx>=0) {"
    },
    {
        "line": 99,
        "fullcodeline": "const char *tag_name = gf_itags_get_name((u32) tag_idx);"
    },
    {
        "line": 100,
        "fullcodeline": "id3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);"
    },
    {
        "line": 76,
        "fullcodeline": "e = gf_filter_pid_raw_new(filter, NULL, NULL, buf+1, NULL, sep_desc+1, pic_size, GF_FALSE, video_pid_p);"
    },
    {
        "line": 102,
        "fullcodeline": "sprintf(szTag, \"tag_%s\", gf_4cc_to_str(ftag));"
    },
    {
        "line": 95,
        "fullcodeline": "gf_filter_pid_set_property(audio_pid, GF_PROP_PID_COVER_ART, &PROP_DATA(sep_desc+1, pic_size) );"
    },
    {
        "line": 103,
        "fullcodeline": "if ((ftag>>24) == 'T') {"
    },
    {
        "line": 78,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));"
    },
    {
        "line": 83,
        "fullcodeline": "gf_filter_pid_set_name(*video_pid_p, \"CoverArt\");"
    },
    {
        "line": 84,
        "fullcodeline": "gf_filter_pid_set_property(*video_pid_p, GF_PROP_PID_COVER_ART, &PROP_BOOL(GF_TRUE));"
    },
    {
        "line": 85,
        "fullcodeline": "dst_pck = gf_filter_pck_new_alloc(*video_pid_p, pic_size, &out_buffer);"
    },
    {
        "line": 92,
        "fullcodeline": "gf_filter_pid_set_eos(*video_pid_p);"
    },
    {
        "line": 104,
        "fullcodeline": "id3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);"
    },
    {
        "line": 106,
        "fullcodeline": "gf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );"
    },
    {
        "line": 87,
        "fullcodeline": "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);"
    },
    {
        "line": 88,
        "fullcodeline": "memcpy(out_buffer, sep_desc+1, pic_size);"
    },
    {
        "line": 89,
        "fullcodeline": "gf_filter_pck_send(dst_pck);"
    }
]