[
    {
        "line": 3,
        "fullcodeline": "struct efx_nic *efx = tx_queue->efx;"
    },
    {
        "line": 4,
        "fullcodeline": "struct pci_dev *pci_dev = efx->pci_dev;"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned int len, unmap_len = 0, fill_level, insert_ptr;"
    },
    {
        "line": 8,
        "fullcodeline": "dma_addr_t dma_addr, unmap_addr = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int q_space, i = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "netdev_tx_t rc = NETDEV_TX_OK;"
    },
    {
        "line": 14,
        "fullcodeline": "EFX_BUG_ON_PARANOID(tx_queue->write_count != tx_queue->insert_count);"
    },
    {
        "line": 20,
        "fullcodeline": "len = skb_headlen(skb);"
    },
    {
        "line": 30,
        "fullcodeline": "fill_level = tx_queue->insert_count - tx_queue->old_read_count;"
    },
    {
        "line": 31,
        "fullcodeline": "q_space = efx->txq_entries - 1 - fill_level;"
    },
    {
        "line": 37,
        "fullcodeline": "unmap_single = true;"
    },
    {
        "line": 38,
        "fullcodeline": "dma_addr = pci_map_single(pci_dev, skb->data, len, PCI_DMA_TODEVICE);"
    },
    {
        "line": 126,
        "fullcodeline": "netif_err(efx, tx_err, efx->net_dev,"
    },
    {
        "line": 136,
        "fullcodeline": "while (tx_queue->insert_count != tx_queue->write_count) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (skb_shinfo(skb)->gso_size)"
    },
    {
        "line": 23,
        "fullcodeline": "if (EFX_WORKAROUND_15592(efx) && skb->len <= 32) {"
    },
    {
        "line": 24,
        "fullcodeline": "EFX_BUG_ON_PARANOID(skb->data_len);"
    },
    {
        "line": 25,
        "fullcodeline": "len = 32 + 1;"
    },
    {
        "line": 47,
        "fullcodeline": "unmap_len = len;"
    },
    {
        "line": 48,
        "fullcodeline": "unmap_addr = dma_addr;"
    },
    {
        "line": 100,
        "fullcodeline": "buffer->unmap_single = unmap_single;"
    },
    {
        "line": 101,
        "fullcodeline": "buffer->unmap_len = unmap_len;"
    },
    {
        "line": 102,
        "fullcodeline": "unmap_len = 0;"
    },
    {
        "line": 107,
        "fullcodeline": "fragment = &skb_shinfo(skb)->frags[i];"
    },
    {
        "line": 108,
        "fullcodeline": "len = skb_frag_size(fragment);"
    },
    {
        "line": 109,
        "fullcodeline": "i++;"
    },
    {
        "line": 111,
        "fullcodeline": "unmap_single = false;"
    },
    {
        "line": 112,
        "fullcodeline": "dma_addr = skb_frag_dma_map(&pci_dev->dev, fragment, 0, len,"
    },
    {
        "line": 137,
        "fullcodeline": "--tx_queue->insert_count;"
    },
    {
        "line": 139,
        "fullcodeline": "buffer = &tx_queue->buffer[insert_ptr];"
    },
    {
        "line": 140,
        "fullcodeline": "efx_dequeue_buffer(tx_queue, buffer);"
    },
    {
        "line": 141,
        "fullcodeline": "buffer->len = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "return efx_enqueue_skb_tso(tx_queue, skb);"
    },
    {
        "line": 26,
        "fullcodeline": "if (skb_pad(skb, len - skb->len))"
    },
    {
        "line": 105,
        "fullcodeline": "if (i >= skb_shinfo(skb)->nr_frags)"
    },
    {
        "line": 129,
        "fullcodeline": "skb_shinfo(skb)->nr_frags + 1);"
    },
    {
        "line": 138,
        "fullcodeline": "insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;"
    },
    {
        "line": 42,
        "fullcodeline": "if (unlikely(pci_dma_mapping_error(pci_dev, dma_addr)))"
    },
    {
        "line": 79,
        "fullcodeline": "buffer = &tx_queue->buffer[insert_ptr];"
    },
    {
        "line": 80,
        "fullcodeline": "efx_tsoh_free(tx_queue, buffer);"
    },
    {
        "line": 81,
        "fullcodeline": "EFX_BUG_ON_PARANOID(buffer->tsoh);"
    },
    {
        "line": 82,
        "fullcodeline": "EFX_BUG_ON_PARANOID(buffer->skb);"
    },
    {
        "line": 85,
        "fullcodeline": "EFX_BUG_ON_PARANOID(buffer->unmap_len);"
    },
    {
        "line": 87,
        "fullcodeline": "dma_len = efx_max_tx_len(efx, dma_addr);"
    },
    {
        "line": 92,
        "fullcodeline": "buffer->len = dma_len;"
    },
    {
        "line": 93,
        "fullcodeline": "buffer->dma_addr = dma_addr;"
    },
    {
        "line": 94,
        "fullcodeline": "len -= dma_len;"
    },
    {
        "line": 95,
        "fullcodeline": "dma_addr += dma_len;"
    },
    {
        "line": 96,
        "fullcodeline": "++tx_queue->insert_count;"
    },
    {
        "line": 78,
        "fullcodeline": "insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;"
    },
    {
        "line": 84,
        "fullcodeline": "EFX_BUG_ON_PARANOID(!buffer->continuation);"
    },
    {
        "line": 52,
        "fullcodeline": "if (unlikely(q_space-- <= 0)) {"
    },
    {
        "line": 58,
        "fullcodeline": "netif_tx_stop_queue(tx_queue->core_txq);"
    },
    {
        "line": 63,
        "fullcodeline": "tx_queue->old_read_count ="
    },
    {
        "line": 65,
        "fullcodeline": "fill_level = (tx_queue->insert_count"
    },
    {
        "line": 67,
        "fullcodeline": "q_space = efx->txq_entries - 1 - fill_level;"
    },
    {
        "line": 88,
        "fullcodeline": "if (likely(dma_len >= len))"
    },
    {
        "line": 89,
        "fullcodeline": "dma_len = len;"
    },
    {
        "line": 64,
        "fullcodeline": "ACCESS_ONCE(tx_queue->read_count);"
    },
    {
        "line": 68,
        "fullcodeline": "if (unlikely(q_space-- <= 0)) {"
    },
    {
        "line": 69,
        "fullcodeline": "rc = NETDEV_TX_BUSY;"
    },
    {
        "line": 73,
        "fullcodeline": "if (likely(!efx->loopback_selftest))"
    },
    {
        "line": 74,
        "fullcodeline": "netif_tx_start_queue("
    }
]