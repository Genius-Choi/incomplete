[
    {
        "line": 3,
        "fullcodeline": "struct net_device *net_dev = efx->net_dev;"
    },
    {
        "line": 7,
        "fullcodeline": "net_dev->watchdog_timeo = 5 * HZ;"
    },
    {
        "line": 9,
        "fullcodeline": "net_dev->netdev_ops = &efx_netdev_ops;"
    },
    {
        "line": 10,
        "fullcodeline": "SET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);"
    },
    {
        "line": 13,
        "fullcodeline": "efx->mac_op->update_stats(efx);"
    },
    {
        "line": 14,
        "fullcodeline": "memset(&efx->mac_stats, 0, sizeof(efx->mac_stats));"
    },
    {
        "line": 16,
        "fullcodeline": "rtnl_lock();"
    },
    {
        "line": 18,
        "fullcodeline": "rc = dev_alloc_name(net_dev, net_dev->name);"
    },
    {
        "line": 21,
        "fullcodeline": "efx_update_name(efx);"
    },
    {
        "line": 23,
        "fullcodeline": "rc = register_netdevice(net_dev);"
    },
    {
        "line": 27,
        "fullcodeline": "efx_for_each_channel(channel, efx) {"
    },
    {
        "line": 34,
        "fullcodeline": "netif_carrier_off(efx->net_dev);"
    },
    {
        "line": 36,
        "fullcodeline": "rtnl_unlock();"
    },
    {
        "line": 38,
        "fullcodeline": "rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);"
    },
    {
        "line": 48,
        "fullcodeline": "rtnl_unlock();"
    },
    {
        "line": 49,
        "fullcodeline": "netif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");"
    },
    {
        "line": 53,
        "fullcodeline": "unregister_netdev(net_dev);"
    },
    {
        "line": 19,
        "fullcodeline": "if (rc < 0)"
    },
    {
        "line": 29,
        "fullcodeline": "efx_for_each_channel_tx_queue(tx_queue, channel)"
    },
    {
        "line": 30,
        "fullcodeline": "efx_init_tx_queue_core_txq(tx_queue);"
    },
    {
        "line": 40,
        "fullcodeline": "netif_err(efx, drv, efx->net_dev,"
    }
]