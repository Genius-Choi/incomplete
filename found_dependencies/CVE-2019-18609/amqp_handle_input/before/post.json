[
    {
        "line": 8,
        "fullcodeline": "decoded_frame->frame_type = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "bytes_consumed = consume_data(state, &received_data);"
    },
    {
        "line": 10,
        "fullcodeline": "if (received_data.len == 0) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (state->state == CONNECTION_STATE_IDLE) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (state->inbound_offset < state->target_size) {"
    },
    {
        "line": 15,
        "fullcodeline": "state->state = CONNECTION_STATE_HEADER;"
    },
    {
        "line": 165,
        "fullcodeline": "amqp_abort(\"Internal error: invalid amqp_connection_state_t->state %d\","
    },
    {
        "line": 23,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 31,
        "fullcodeline": "if (memcmp(raw_frame, \"AMQP\", 4) == 0) {"
    },
    {
        "line": 55,
        "fullcodeline": "channel = amqp_d16(amqp_offset(raw_frame, 1));"
    },
    {
        "line": 57,
        "fullcodeline": "state->target_size ="
    },
    {
        "line": 64,
        "fullcodeline": "channel_pool = amqp_get_or_create_channel_pool(state, channel);"
    },
    {
        "line": 69,
        "fullcodeline": "amqp_pool_alloc_bytes(channel_pool, state->target_size,"
    },
    {
        "line": 74,
        "fullcodeline": "memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);"
    },
    {
        "line": 75,
        "fullcodeline": "raw_frame = state->inbound_buffer.bytes;"
    },
    {
        "line": 77,
        "fullcodeline": "state->state = CONNECTION_STATE_BODY;"
    },
    {
        "line": 79,
        "fullcodeline": "bytes_consumed += consume_data(state, &received_data);"
    },
    {
        "line": 100,
        "fullcodeline": "decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));"
    },
    {
        "line": 101,
        "fullcodeline": "decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));"
    },
    {
        "line": 103,
        "fullcodeline": "channel_pool ="
    },
    {
        "line": 160,
        "fullcodeline": "return_to_idle(state);"
    },
    {
        "line": 32,
        "fullcodeline": "decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;"
    },
    {
        "line": 33,
        "fullcodeline": "decoded_frame->channel = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "decoded_frame->payload.protocol_header.transport_high ="
    },
    {
        "line": 37,
        "fullcodeline": "decoded_frame->payload.protocol_header.transport_low ="
    },
    {
        "line": 39,
        "fullcodeline": "decoded_frame->payload.protocol_header.protocol_version_major ="
    },
    {
        "line": 41,
        "fullcodeline": "decoded_frame->payload.protocol_header.protocol_version_minor ="
    },
    {
        "line": 44,
        "fullcodeline": "return_to_idle(state);"
    },
    {
        "line": 58,
        "fullcodeline": "amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;"
    },
    {
        "line": 60,
        "fullcodeline": "if ((size_t)state->frame_max < state->target_size) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (NULL == channel_pool) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (NULL == state->inbound_buffer.bytes) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (state->inbound_offset < state->target_size) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !="
    },
    {
        "line": 104,
        "fullcodeline": "amqp_get_or_create_channel_pool(state, decoded_frame->channel);"
    },
    {
        "line": 105,
        "fullcodeline": "if (NULL == channel_pool) {"
    },
    {
        "line": 161,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 36,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 4));"
    },
    {
        "line": 38,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 5));"
    },
    {
        "line": 40,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 6));"
    },
    {
        "line": 42,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 7));"
    },
    {
        "line": 45,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 111,
        "fullcodeline": "decoded_frame->payload.method.id ="
    },
    {
        "line": 113,
        "fullcodeline": "encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);"
    },
    {
        "line": 114,
        "fullcodeline": "encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;"
    },
    {
        "line": 116,
        "fullcodeline": "res = amqp_decode_method(decoded_frame->payload.method.id,"
    },
    {
        "line": 126,
        "fullcodeline": "decoded_frame->payload.properties.class_id ="
    },
    {
        "line": 129,
        "fullcodeline": "decoded_frame->payload.properties.body_size ="
    },
    {
        "line": 131,
        "fullcodeline": "encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);"
    },
    {
        "line": 132,
        "fullcodeline": "encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;"
    },
    {
        "line": 133,
        "fullcodeline": "decoded_frame->payload.properties.raw = encoded;"
    },
    {
        "line": 135,
        "fullcodeline": "res = amqp_decode_properties("
    },
    {
        "line": 145,
        "fullcodeline": "decoded_frame->payload.body_fragment.len ="
    },
    {
        "line": 147,
        "fullcodeline": "decoded_frame->payload.body_fragment.bytes ="
    },
    {
        "line": 156,
        "fullcodeline": "decoded_frame->frame_type = 0;"
    },
    {
        "line": 84,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 112,
        "fullcodeline": "amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));"
    },
    {
        "line": 119,
        "fullcodeline": "if (res < 0) {"
    },
    {
        "line": 127,
        "fullcodeline": "amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));"
    },
    {
        "line": 130,
        "fullcodeline": "amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));"
    },
    {
        "line": 138,
        "fullcodeline": "if (res < 0) {"
    },
    {
        "line": 146,
        "fullcodeline": "state->target_size - HEADER_SIZE - FOOTER_SIZE;"
    },
    {
        "line": 148,
        "fullcodeline": "amqp_offset(raw_frame, HEADER_SIZE);"
    }
]