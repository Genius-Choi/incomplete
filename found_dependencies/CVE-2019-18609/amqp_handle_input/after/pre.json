[
    {
        "line": 8,
        "fullcodeline": "decoded_frame->frame_type = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "bytes_consumed = consume_data(state, &received_data);"
    },
    {
        "line": 26,
        "fullcodeline": "raw_frame = state->inbound_buffer.bytes;"
    },
    {
        "line": 10,
        "fullcodeline": "if (received_data.len == 0) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (state->state == CONNECTION_STATE_IDLE) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (state->inbound_offset < state->target_size) {"
    },
    {
        "line": 15,
        "fullcodeline": "state->state = CONNECTION_STATE_HEADER;"
    },
    {
        "line": 23,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 56,
        "fullcodeline": "channel = amqp_d16(amqp_offset(raw_frame, 1));"
    },
    {
        "line": 59,
        "fullcodeline": "frame_size = amqp_d32(amqp_offset(raw_frame, 3));"
    },
    {
        "line": 68,
        "fullcodeline": "state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;"
    },
    {
        "line": 73,
        "fullcodeline": "channel_pool = amqp_get_or_create_channel_pool(state, channel);"
    },
    {
        "line": 78,
        "fullcodeline": "amqp_pool_alloc_bytes(channel_pool, state->target_size,"
    },
    {
        "line": 83,
        "fullcodeline": "memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);"
    },
    {
        "line": 84,
        "fullcodeline": "raw_frame = state->inbound_buffer.bytes;"
    },
    {
        "line": 86,
        "fullcodeline": "state->state = CONNECTION_STATE_BODY;"
    },
    {
        "line": 88,
        "fullcodeline": "bytes_consumed += consume_data(state, &received_data);"
    },
    {
        "line": 110,
        "fullcodeline": "decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));"
    },
    {
        "line": 112,
        "fullcodeline": "channel_pool ="
    },
    {
        "line": 31,
        "fullcodeline": "if (memcmp(raw_frame, \"AMQP\", 4) == 0) {"
    },
    {
        "line": 32,
        "fullcodeline": "decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;"
    },
    {
        "line": 64,
        "fullcodeline": "if (frame_size >= INT32_MAX) {"
    },
    {
        "line": 69,
        "fullcodeline": "if ((size_t)state->frame_max < state->target_size) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (NULL == channel_pool) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (NULL == state->inbound_buffer.bytes) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (state->inbound_offset < state->target_size) {"
    },
    {
        "line": 104,
        "fullcodeline": "if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !="
    },
    {
        "line": 109,
        "fullcodeline": "decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));"
    },
    {
        "line": 113,
        "fullcodeline": "amqp_get_or_create_channel_pool(state, decoded_frame->channel);"
    },
    {
        "line": 114,
        "fullcodeline": "if (NULL == channel_pool) {"
    },
    {
        "line": 170,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 36,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 4));"
    },
    {
        "line": 38,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 5));"
    },
    {
        "line": 40,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 6));"
    },
    {
        "line": 42,
        "fullcodeline": "amqp_d8(amqp_offset(raw_frame, 7));"
    },
    {
        "line": 45,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 120,
        "fullcodeline": "decoded_frame->payload.method.id ="
    },
    {
        "line": 122,
        "fullcodeline": "encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);"
    },
    {
        "line": 123,
        "fullcodeline": "encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;"
    },
    {
        "line": 125,
        "fullcodeline": "res = amqp_decode_method(decoded_frame->payload.method.id,"
    },
    {
        "line": 135,
        "fullcodeline": "decoded_frame->payload.properties.class_id ="
    },
    {
        "line": 140,
        "fullcodeline": "encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);"
    },
    {
        "line": 141,
        "fullcodeline": "encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;"
    },
    {
        "line": 144,
        "fullcodeline": "res = amqp_decode_properties("
    },
    {
        "line": 93,
        "fullcodeline": "return (int)bytes_consumed;"
    },
    {
        "line": 121,
        "fullcodeline": "amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));"
    },
    {
        "line": 128,
        "fullcodeline": "if (res < 0) {"
    },
    {
        "line": 136,
        "fullcodeline": "amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));"
    },
    {
        "line": 139,
        "fullcodeline": "amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));"
    },
    {
        "line": 147,
        "fullcodeline": "if (res < 0) {"
    },
    {
        "line": 155,
        "fullcodeline": "state->target_size - HEADER_SIZE - FOOTER_SIZE;"
    },
    {
        "line": 157,
        "fullcodeline": "amqp_offset(raw_frame, HEADER_SIZE);"
    }
]