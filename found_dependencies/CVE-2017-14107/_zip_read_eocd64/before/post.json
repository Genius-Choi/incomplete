[
    {
        "line": 5,
        "fullcodeline": "zip_uint8_t eocd[EOCD64LEN];"
    },
    {
        "line": 11,
        "fullcodeline": "eocdloc_offset = _zip_buffer_offset(buffer);"
    },
    {
        "line": 13,
        "fullcodeline": "_zip_buffer_get(buffer, 4); /* magic already verified */"
    },
    {
        "line": 15,
        "fullcodeline": "num_disks = _zip_buffer_get_16(buffer);"
    },
    {
        "line": 16,
        "fullcodeline": "eocd_disk = _zip_buffer_get_16(buffer);"
    },
    {
        "line": 17,
        "fullcodeline": "eocd_offset = _zip_buffer_get_64(buffer);"
    },
    {
        "line": 52,
        "fullcodeline": "size = _zip_buffer_get_64(buffer);"
    },
    {
        "line": 62,
        "fullcodeline": "_zip_buffer_get(buffer, 4); /* skip version made by/needed */"
    },
    {
        "line": 64,
        "fullcodeline": "num_disks64 = _zip_buffer_get_32(buffer);"
    },
    {
        "line": 65,
        "fullcodeline": "eocd_disk64 = _zip_buffer_get_32(buffer);"
    },
    {
        "line": 91,
        "fullcodeline": "nentry = _zip_buffer_get_64(buffer);"
    },
    {
        "line": 92,
        "fullcodeline": "i = _zip_buffer_get_64(buffer);"
    },
    {
        "line": 102,
        "fullcodeline": "size = _zip_buffer_get_64(buffer);"
    },
    {
        "line": 103,
        "fullcodeline": "offset = _zip_buffer_get_64(buffer);"
    },
    {
        "line": 129,
        "fullcodeline": "cd->is_zip64 = true;"
    },
    {
        "line": 130,
        "fullcodeline": "cd->size = size;"
    },
    {
        "line": 131,
        "fullcodeline": "cd->offset = offset;"
    },
    {
        "line": 19,
        "fullcodeline": "if (eocd_offset > ZIP_INT64_MAX || eocd_offset + EOCD64LEN < eocd_offset) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (eocd_offset + EOCD64LEN > eocdloc_offset + buf_offset) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (eocd_offset >= buf_offset && eocd_offset + EOCD64LEN <= buf_offset + _zip_buffer_size(buffer)) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {"
    },
    {
        "line": 54,
        "fullcodeline": "if ((flags & ZIP_CHECKCONS) && size + eocd_offset + 12 != buf_offset + eocdloc_offset) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (num_disks == 0xffff) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (eocd_disk == 0xffff) {"
    },
    {
        "line": 76,
        "fullcodeline": "if ((flags & ZIP_CHECKCONS) && (eocd_disk != eocd_disk64 || num_disks != num_disks64)) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (num_disks != 0 || eocd_disk != 0) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (nentry != i) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (!_zip_buffer_ok(buffer)) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (offset > ZIP_INT64_MAX || offset+size < offset) {"
    },
    {
        "line": 121,
        "fullcodeline": "if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) {"
    },
    {
        "line": 126,
        "fullcodeline": "if ((cd=_zip_cdir_new(nentry, error)) == NULL)"
    },
    {
        "line": 20,
        "fullcodeline": "zip_error_set(error, ZIP_ER_SEEK, EFBIG);"
    },
    {
        "line": 25,
        "fullcodeline": "zip_error_set(error, ZIP_ER_INCONS, 0);"
    },
    {
        "line": 30,
        "fullcodeline": "_zip_buffer_set_offset(buffer, eocd_offset - buf_offset);"
    },
    {
        "line": 31,
        "fullcodeline": "free_buffer = false;"
    },
    {
        "line": 45,
        "fullcodeline": "zip_error_set(error, ZIP_ER_INCONS, 0);"
    },
    {
        "line": 55,
        "fullcodeline": "zip_error_set(error, ZIP_ER_INCONS, 0);"
    },
    {
        "line": 71,
        "fullcodeline": "num_disks = num_disks64;"
    },
    {
        "line": 74,
        "fullcodeline": "eocd_disk = eocd_disk64;"
    },
    {
        "line": 77,
        "fullcodeline": "zip_error_set(error, ZIP_ER_INCONS, 0);"
    },
    {
        "line": 84,
        "fullcodeline": "zip_error_set(error, ZIP_ER_MULTIDISK, 0);"
    },
    {
        "line": 95,
        "fullcodeline": "zip_error_set(error, ZIP_ER_MULTIDISK, 0);"
    },
    {
        "line": 106,
        "fullcodeline": "zip_error_set(error, ZIP_ER_INTERNAL, 0);"
    },
    {
        "line": 114,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 118,
        "fullcodeline": "zip_error_set(error, ZIP_ER_SEEK, EFBIG);"
    },
    {
        "line": 122,
        "fullcodeline": "zip_error_set(error, ZIP_ER_INCONS, 0);"
    },
    {
        "line": 41,
        "fullcodeline": "free_buffer = true;"
    },
    {
        "line": 34,
        "fullcodeline": "if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) < 0) {"
    },
    {
        "line": 38,
        "fullcodeline": "if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {"
    },
    {
        "line": 47,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 57,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 79,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 86,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 97,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 108,
        "fullcodeline": "_zip_buffer_free(buffer);"
    },
    {
        "line": 35,
        "fullcodeline": "_zip_error_set_from_source(error, src);"
    }
]