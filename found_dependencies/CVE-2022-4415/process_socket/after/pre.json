[
    {
        "line": 2,
        "fullcodeline": "_cleanup_close_ int input_fd = -EBADF;"
    },
    {
        "line": 3,
        "fullcodeline": "Context context = {};"
    },
    {
        "line": 4,
        "fullcodeline": "struct iovec_wrapper iovw = {};"
    },
    {
        "line": 8,
        "fullcodeline": "assert(fd >= 0);"
    },
    {
        "line": 10,
        "fullcodeline": "log_setup();"
    },
    {
        "line": 12,
        "fullcodeline": "log_debug(\"Processing coredump received on stdin...\");"
    },
    {
        "line": 77,
        "fullcodeline": "assert(input_fd >= 0);"
    },
    {
        "line": 79,
        "fullcodeline": "r = save_context(&context, &iovw);"
    },
    {
        "line": 92,
        "fullcodeline": "r = submit_coredump(&context, &iovw, input_fd);"
    },
    {
        "line": 95,
        "fullcodeline": "iovw_free_contents(&iovw, true);"
    },
    {
        "line": 80,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 84,
        "fullcodeline": "for (int i = 0; i < _META_MANDATORY_MAX; i++)"
    },
    {
        "line": 15,
        "fullcodeline": "CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(int))) control;"
    },
    {
        "line": 16,
        "fullcodeline": "struct msghdr mh = {"
    },
    {
        "line": 24,
        "fullcodeline": "l = next_datagram_size_fd(fd);"
    },
    {
        "line": 30,
        "fullcodeline": "iovec.iov_len = l;"
    },
    {
        "line": 31,
        "fullcodeline": "iovec.iov_base = malloc(l + 1);"
    },
    {
        "line": 37,
        "fullcodeline": "mh.msg_iov = &iovec;"
    },
    {
        "line": 39,
        "fullcodeline": "n = recvmsg_safe(fd, &mh, MSG_CMSG_CLOEXEC);"
    },
    {
        "line": 68,
        "fullcodeline": "((char*) iovec.iov_base)[n] = 0;"
    },
    {
        "line": 69,
        "fullcodeline": "iovec.iov_len = (size_t) n;"
    },
    {
        "line": 71,
        "fullcodeline": "r = iovw_put(&iovw, iovec.iov_base, iovec.iov_len);"
    },
    {
        "line": 85,
        "fullcodeline": "if (!context.meta[i]) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (l < 0) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (!iovec.iov_base) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (n < 0)  {"
    },
    {
        "line": 48,
        "fullcodeline": "if (n == 0) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 86,
        "fullcodeline": "r = log_error_errno(SYNTHETIC_ERRNO(EINVAL),"
    },
    {
        "line": 26,
        "fullcodeline": "r = log_error_errno(l, \"Failed to determine datagram size to read: %m\");"
    },
    {
        "line": 33,
        "fullcodeline": "r = log_oom();"
    },
    {
        "line": 41,
        "fullcodeline": "free(iovec.iov_base);"
    },
    {
        "line": 42,
        "fullcodeline": "r = log_error_errno(n, \"Failed to receive datagram: %m\");"
    },
    {
        "line": 51,
        "fullcodeline": "free(iovec.iov_base);"
    },
    {
        "line": 53,
        "fullcodeline": "found = cmsg_find(&mh, SOL_SOCKET, SCM_RIGHTS, CMSG_LEN(sizeof(int)));"
    },
    {
        "line": 61,
        "fullcodeline": "assert(input_fd < 0);"
    },
    {
        "line": 62,
        "fullcodeline": "input_fd = *(int*) CMSG_DATA(found);"
    },
    {
        "line": 17,
        "fullcodeline": ".msg_control = &control,"
    },
    {
        "line": 18,
        "fullcodeline": ".msg_controllen = sizeof(control),"
    },
    {
        "line": 19,
        "fullcodeline": ".msg_iovlen = 1,"
    },
    {
        "line": 54,
        "fullcodeline": "if (!found) {"
    },
    {
        "line": 65,
        "fullcodeline": "cmsg_close_all(&mh);"
    },
    {
        "line": 55,
        "fullcodeline": "cmsg_close_all(&mh);"
    },
    {
        "line": 56,
        "fullcodeline": "r = log_error_errno(SYNTHETIC_ERRNO(EBADMSG),"
    }
]