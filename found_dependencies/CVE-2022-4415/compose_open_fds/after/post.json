[
    {
        "line": 2,
        "fullcodeline": "_cleanup_closedir_ DIR *proc_fd_dir = NULL;"
    },
    {
        "line": 3,
        "fullcodeline": "_cleanup_close_ int proc_fdinfo_fd = -EBADF;"
    },
    {
        "line": 4,
        "fullcodeline": "_cleanup_free_ char *buffer = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "_cleanup_fclose_ FILE *stream = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "const char *fddelim = \"\", *path;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t size = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "assert(pid >= 0);"
    },
    {
        "line": 11,
        "fullcodeline": "assert(open_fds != NULL);"
    },
    {
        "line": 13,
        "fullcodeline": "path = procfs_file_alloca(pid, \"fd\");"
    },
    {
        "line": 14,
        "fullcodeline": "proc_fd_dir = opendir(path);"
    },
    {
        "line": 18,
        "fullcodeline": "proc_fdinfo_fd = openat(dirfd(proc_fd_dir), \"../fdinfo\", O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC|O_PATH);"
    },
    {
        "line": 22,
        "fullcodeline": "stream = open_memstream_unlocked(&buffer, &size);"
    },
    {
        "line": 61,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 62,
        "fullcodeline": "stream = safe_fclose(stream);"
    },
    {
        "line": 67,
        "fullcodeline": "*open_fds = TAKE_PTR(buffer);"
    },
    {
        "line": 15,
        "fullcodeline": "if (!proc_fd_dir)"
    },
    {
        "line": 19,
        "fullcodeline": "if (proc_fdinfo_fd < 0)"
    },
    {
        "line": 23,
        "fullcodeline": "if (!stream)"
    },
    {
        "line": 64,
        "fullcodeline": "if (errno > 0)"
    },
    {
        "line": 16,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 20,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 24,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 65,
        "fullcodeline": "return -errno;"
    }
]