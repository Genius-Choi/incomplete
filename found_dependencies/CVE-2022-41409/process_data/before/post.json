[
    {
        "line": 6,
        "fullcodeline": "uint32_t g_notempty = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "PCRE2_SIZE ovecsave[3];"
    },
    {
        "line": 27,
        "fullcodeline": "subject_literal = (pat_patctl.control2 & CTL2_SUBJECT_LITERAL) != 0;"
    },
    {
        "line": 35,
        "fullcodeline": "DATCTXCPY(dat_context, default_dat_context);"
    },
    {
        "line": 36,
        "fullcodeline": "memcpy(&dat_datctl, &def_datctl, sizeof(datctl));"
    },
    {
        "line": 37,
        "fullcodeline": "dat_datctl.control |= (pat_patctl.control & CTL_ALLPD);"
    },
    {
        "line": 38,
        "fullcodeline": "dat_datctl.control2 |= (pat_patctl.control2 & CTL2_ALLPD);"
    },
    {
        "line": 39,
        "fullcodeline": "strcpy((char *)dat_datctl.replacement, (char *)pat_patctl.replacement);"
    },
    {
        "line": 54,
        "fullcodeline": "utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;"
    },
    {
        "line": 57,
        "fullcodeline": "start_rep = NULL;"
    },
    {
        "line": 58,
        "fullcodeline": "len = strlen((const char *)buffer);"
    },
    {
        "line": 60,
        "fullcodeline": "buffer[len] = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "p = buffer;"
    },
    {
        "line": 93,
        "fullcodeline": "needlen = (size_t)((len+1) * code_unit_size);"
    },
    {
        "line": 104,
        "fullcodeline": "SETCASTPTR(q, dbuffer);  /* Sets q8, q16, or q32, as appropriate. */"
    },
    {
        "line": 376,
        "fullcodeline": "SET(*q, 0);"
    },
    {
        "line": 378,
        "fullcodeline": "ulen = len/code_unit_size;                /* Length in code units */"
    },
    {
        "line": 379,
        "fullcodeline": "arg_ulen = ulen;                          /* Value to use in match arg */"
    },
    {
        "line": 437,
        "fullcodeline": "c = code_unit_size * (((pat_patctl.control & CTL_POSIX) +"
    },
    {
        "line": 439,
        "fullcodeline": "pp = memmove(dbuffer + dbuffer_size - len - c, dbuffer, len + c);"
    },
    {
        "line": 585,
        "fullcodeline": "use_dat_context = ((dat_datctl.control & CTL_NULLCONTEXT) != 0)?"
    },
    {
        "line": 591,
        "fullcodeline": "show_memory = (dat_datctl.control & CTL_MEMORY) != 0;"
    },
    {
        "line": 658,
        "fullcodeline": "ovector = FLD(match_data, ovector);"
    },
    {
        "line": 659,
        "fullcodeline": "PCRE2_GET_OVECTOR_COUNT(oveccount, match_data);"
    },
    {
        "line": 871,
        "fullcodeline": "ovecsave[0] = ovecsave[1] = ovecsave[2] = PCRE2_UNSET;"
    },
    {
        "line": 1498,
        "fullcodeline": "show_memory = FALSE;"
    },
    {
        "line": 40,
        "fullcodeline": "if (dat_datctl.jitstack == 0) dat_datctl.jitstack = pat_patctl.jitstack;"
    },
    {
        "line": 42,
        "fullcodeline": "if (dat_datctl.substitute_skip == 0)"
    },
    {
        "line": 44,
        "fullcodeline": "if (dat_datctl.substitute_stop == 0)"
    },
    {
        "line": 59,
        "fullcodeline": "while (len > 0 && isspace(buffer[len-1])) len--;"
    },
    {
        "line": 62,
        "fullcodeline": "while (isspace(*p)) p++;"
    },
    {
        "line": 94,
        "fullcodeline": "if (dbuffer == NULL || needlen >= dbuffer_size)"
    },
    {
        "line": 111,
        "fullcodeline": "while ((c = *p++) != 0)"
    },
    {
        "line": 383,
        "fullcodeline": "if (p[-1] != 0 && !decode_modifiers(p, CTX_DAT, NULL, &dat_datctl))"
    },
    {
        "line": 388,
        "fullcodeline": "if (dat_datctl.substitute_skip != 0 || dat_datctl.substitute_stop != 0)"
    },
    {
        "line": 394,
        "fullcodeline": "for (k = 0; k < sizeof(exclusive_dat_controls)/sizeof(uint32_t); k++)"
    },
    {
        "line": 405,
        "fullcodeline": "if (pat_patctl.replacement[0] != 0)"
    },
    {
        "line": 420,
        "fullcodeline": "if ((dat_datctl.control & CTL_DFA) != 0)"
    },
    {
        "line": 447,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_NULL_SUBJECT) != 0) pp = NULL;"
    },
    {
        "line": 564,
        "fullcodeline": "if (dat_datctl.startend[0] != CFORE_UNSET)"
    },
    {
        "line": 570,
        "fullcodeline": "if ((dat_datctl.control & (CTL_ALLUSEDTEXT|CTL_DFA)) == CTL_ALLUSEDTEXT &&"
    },
    {
        "line": 579,
        "fullcodeline": "if ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)"
    },
    {
        "line": 593,
        "fullcodeline": "if (show_memory &&"
    },
    {
        "line": 600,
        "fullcodeline": "if (dat_datctl.jitstack != 0)"
    },
    {
        "line": 624,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_stack == NULL)"
    },
    {
        "line": 632,
        "fullcodeline": "if (dat_datctl.oveccount == 0)"
    },
    {
        "line": 663,
        "fullcodeline": "if (dat_datctl.replacement[0] != 0 && (dat_datctl.control & CTL_DFA) != 0)"
    },
    {
        "line": 673,
        "fullcodeline": "if (dat_datctl.replacement[0] != 0)"
    },
    {
        "line": 873,
        "fullcodeline": "for (gmatched = 0;; gmatched++)"
    },
    {
        "line": 71,
        "fullcodeline": "int n = 1;"
    },
    {
        "line": 97,
        "fullcodeline": "dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);"
    },
    {
        "line": 113,
        "fullcodeline": "int32_t i = 0;"
    },
    {
        "line": 389,
        "fullcodeline": "dat_datctl.control2 |= CTL2_SUBSTITUTE_CALLOUT;"
    },
    {
        "line": 396,
        "fullcodeline": "c = dat_datctl.control & exclusive_dat_controls[k];"
    },
    {
        "line": 565,
        "fullcodeline": "fprintf(outfile, \"** \\\\=posix_startend ignored for non-POSIX matching\\n\");"
    },
    {
        "line": 571,
        "fullcodeline": "FLD(compiled_code, executable_jit) != NULL)"
    },
    {
        "line": 573,
        "fullcodeline": "fprintf(outfile, \"** Showing all consulted text is not supported by JIT: ignored\\n\");"
    },
    {
        "line": 574,
        "fullcodeline": "dat_datctl.control &= ~CTL_ALLUSEDTEXT;"
    },
    {
        "line": 580,
        "fullcodeline": "arg_ulen = PCRE2_ZERO_TERMINATED;"
    },
    {
        "line": 586,
        "fullcodeline": "NULL : PTR(dat_context);"
    },
    {
        "line": 594,
        "fullcodeline": "(pat_patctl.control & dat_datctl.control & CTL_NULLCONTEXT) != 0)"
    },
    {
        "line": 595,
        "fullcodeline": "fprintf(outfile, \"** \\\\=memory requires either a pattern or a subject \""
    },
    {
        "line": 608,
        "fullcodeline": "PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, jit_stack);"
    },
    {
        "line": 626,
        "fullcodeline": "PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, NULL);"
    },
    {
        "line": 634,
        "fullcodeline": "PCRE2_MATCH_DATA_FREE(match_data);"
    },
    {
        "line": 635,
        "fullcodeline": "PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code,"
    },
    {
        "line": 637,
        "fullcodeline": "PCRE2_GET_OVECTOR_COUNT(max_oveccount, match_data);"
    },
    {
        "line": 652,
        "fullcodeline": "fprintf(outfile, \"** Failed to get memory for recording matching \""
    },
    {
        "line": 654,
        "fullcodeline": "max_oveccount = 0;"
    },
    {
        "line": 665,
        "fullcodeline": "fprintf(outfile, \"** Ignored for DFA matching: replace\\n\");"
    },
    {
        "line": 666,
        "fullcodeline": "dat_datctl.replacement[0] = 0;"
    },
    {
        "line": 677,
        "fullcodeline": "uint8_t rbuffer[REPLACE_BUFFSIZE];"
    },
    {
        "line": 678,
        "fullcodeline": "uint8_t nbuffer[REPLACE_BUFFSIZE];"
    },
    {
        "line": 683,
        "fullcodeline": "BOOL badutf = FALSE;"
    },
    {
        "line": 710,
        "fullcodeline": "emoption = ((dat_datctl.control2 & CTL2_SUBSTITUTE_MATCHED) == 0)? 0 :"
    },
    {
        "line": 719,
        "fullcodeline": "xoptions = emoption |"
    },
    {
        "line": 735,
        "fullcodeline": "SETCASTPTR(r, rbuffer);  /* Sets r8, r16, or r32, as appropriate. */"
    },
    {
        "line": 736,
        "fullcodeline": "pr = dat_datctl.replacement;"
    },
    {
        "line": 741,
        "fullcodeline": "nsize = REPLACE_BUFFSIZE/code_unit_size;"
    },
    {
        "line": 815,
        "fullcodeline": "SET(*r, 0);"
    },
    {
        "line": 833,
        "fullcodeline": "rbptr = ((dat_datctl.control2 & CTL2_NULL_REPLACEMENT) == 0)? rbuffer : NULL;"
    },
    {
        "line": 835,
        "fullcodeline": "PCRE2_SUBSTITUTE(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,"
    },
    {
        "line": 856,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 857,
        "fullcodeline": "show_memory = FALSE;"
    },
    {
        "line": 886,
        "fullcodeline": "jit_was_used = (pat_patctl.control & CTL_JITFAST) != 0;"
    },
    {
        "line": 72,
        "fullcodeline": "for (q = p; n > 0 && *q; q += n) n = utf82ord(q, &cc);"
    },
    {
        "line": 73,
        "fullcodeline": "if (n <= 0)"
    },
    {
        "line": 96,
        "fullcodeline": "while (needlen >= dbuffer_size) dbuffer_size *= 2;"
    },
    {
        "line": 98,
        "fullcodeline": "if (dbuffer == NULL)"
    },
    {
        "line": 118,
        "fullcodeline": "if (c == ']' && start_rep != NULL)"
    },
    {
        "line": 181,
        "fullcodeline": "if (c != '\\\\' || subject_literal)"
    },
    {
        "line": 397,
        "fullcodeline": "if (c != 0 && c != (c & (~c+1)))"
    },
    {
        "line": 407,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0 &&"
    },
    {
        "line": 414,
        "fullcodeline": "if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)"
    },
    {
        "line": 422,
        "fullcodeline": "if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)"
    },
    {
        "line": 602,
        "fullcodeline": "if (dat_datctl.jitstack != jit_stack_size)"
    },
    {
        "line": 698,
        "fullcodeline": "for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;"
    },
    {
        "line": 703,
        "fullcodeline": "if ((dat_datctl.control & CTL_ALTGLOBAL) != 0)"
    },
    {
        "line": 713,
        "fullcodeline": "if (emoption != 0)"
    },
    {
        "line": 742,
        "fullcodeline": "if (*pr == '[')"
    },
    {
        "line": 771,
        "fullcodeline": "if (!utf || badutf)"
    },
    {
        "line": 821,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0)"
    },
    {
        "line": 836,
        "fullcodeline": "dat_datctl.options|xoptions, match_data, use_dat_context,"
    },
    {
        "line": 839,
        "fullcodeline": "if (rc < 0)"
    },
    {
        "line": 861,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)"
    },
    {
        "line": 881,
        "fullcodeline": "for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;"
    },
    {
        "line": 890,
        "fullcodeline": "if (timeitm > 0)"
    },
    {
        "line": 944,
        "fullcodeline": "if ((dat_datctl.control & (CTL_FINDLIMITS|CTL_FINDLIMITS_NOHEAP)) != 0)"
    },
    {
        "line": 1029,
        "fullcodeline": "if (capcount >= 0)"
    },
    {
        "line": 1412,
        "fullcodeline": "if ((dat_datctl.control & CTL_ANYGLOB) == 0) break; else"
    },
    {
        "line": 75,
        "fullcodeline": "fprintf(outfile, \"** Failed: invalid UTF-8 string cannot be used as input \""
    },
    {
        "line": 100,
        "fullcodeline": "fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);"
    },
    {
        "line": 101,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 129,
        "fullcodeline": "li = strtol((const char *)p, &endptr, 10);"
    },
    {
        "line": 136,
        "fullcodeline": "p = (uint8_t *)endptr;"
    },
    {
        "line": 143,
        "fullcodeline": "i = (int32_t)li;"
    },
    {
        "line": 150,
        "fullcodeline": "replen = CAST8VAR(q) - start_rep;"
    },
    {
        "line": 151,
        "fullcodeline": "needlen += replen * i;"
    },
    {
        "line": 174,
        "fullcodeline": "start_rep = NULL;"
    },
    {
        "line": 183,
        "fullcodeline": "uint32_t topbit = 0;"
    },
    {
        "line": 191,
        "fullcodeline": "c |= topbit;"
    },
    {
        "line": 399,
        "fullcodeline": "show_controls(c, 0, \"** Not allowed together:\");"
    },
    {
        "line": 400,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 408,
        "fullcodeline": "(dat_datctl.control & CTL_NULLCONTEXT) != 0)"
    },
    {
        "line": 410,
        "fullcodeline": "fprintf(outfile, \"** Replacement callouts are not supported with null_context.\\n\");"
    },
    {
        "line": 415,
        "fullcodeline": "fprintf(outfile, \"** Ignored with replacement text: allcaptures\\n\");"
    },
    {
        "line": 423,
        "fullcodeline": "fprintf(outfile, \"** Ignored after DFA matching: allcaptures\\n\");"
    },
    {
        "line": 604,
        "fullcodeline": "PCRE2_JIT_STACK_FREE(jit_stack);"
    },
    {
        "line": 605,
        "fullcodeline": "PCRE2_JIT_STACK_CREATE(jit_stack, 1, dat_datctl.jitstack * 1024, NULL);"
    },
    {
        "line": 606,
        "fullcodeline": "jit_stack_size = dat_datctl.jitstack;"
    },
    {
        "line": 613,
        "fullcodeline": "else if (jit_stack != NULL)"
    },
    {
        "line": 639,
        "fullcodeline": "else if (dat_datctl.oveccount <= max_oveccount)"
    },
    {
        "line": 701,
        "fullcodeline": "fprintf(outfile, \"** Timing is not supported with replace: ignored\\n\");"
    },
    {
        "line": 704,
        "fullcodeline": "fprintf(outfile, \"** Altglobal is not supported with replace: ignored\\n\");"
    },
    {
        "line": 715,
        "fullcodeline": "PCRE2_MATCH(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,"
    },
    {
        "line": 732,
        "fullcodeline": "(((dat_datctl.control2 & CTL2_SUBSTITUTE_UNSET_EMPTY) == 0)? 0 :"
    },
    {
        "line": 744,
        "fullcodeline": "PCRE2_SIZE n = 0;"
    },
    {
        "line": 757,
        "fullcodeline": "nsize = n;"
    },
    {
        "line": 767,
        "fullcodeline": "if (utf) badutf = valid_utf(pr, strlen((const char *)pr), &erroroffset);"
    },
    {
        "line": 823,
        "fullcodeline": "PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, substitute_callout_function, NULL);"
    },
    {
        "line": 841,
        "fullcodeline": "fprintf(outfile, \"Failed: error %d\", rc);"
    },
    {
        "line": 844,
        "fullcodeline": "fprintf(outfile, \": \");"
    },
    {
        "line": 862,
        "fullcodeline": "show_ovector(ovector, oveccount);"
    },
    {
        "line": 934,
        "fullcodeline": "total_match_time += (time_taken = clock() - start_time);"
    },
    {
        "line": 935,
        "fullcodeline": "fprintf(outfile, \"Match time %.4f milliseconds\\n\","
    },
    {
        "line": 946,
        "fullcodeline": "capcount = 0;  /* This stops compiler warnings */"
    },
    {
        "line": 955,
        "fullcodeline": "capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,"
    },
    {
        "line": 123,
        "fullcodeline": "if (*p++ != '{')"
    },
    {
        "line": 130,
        "fullcodeline": "if (S32OVERFLOW(li))"
    },
    {
        "line": 137,
        "fullcodeline": "if (*p++ != '}')"
    },
    {
        "line": 144,
        "fullcodeline": "if (i-- == 0)"
    },
    {
        "line": 153,
        "fullcodeline": "if (needlen >= dbuffer_size)"
    },
    {
        "line": 168,
        "fullcodeline": "while (i-- > 0)"
    },
    {
        "line": 184,
        "fullcodeline": "if (test_mode == PCRE32_MODE && c == 0xff && *p != 0)"
    },
    {
        "line": 189,
        "fullcodeline": "if ((utf || (pat_patctl.control & CTL_UTF8_INPUT) != 0) &&"
    },
    {
        "line": 438,
        "fullcodeline": "(dat_datctl.control & CTL_ZERO_TERMINATE) != 0)? 1:0);"
    },
    {
        "line": 615,
        "fullcodeline": "PCRE2_JIT_STACK_ASSIGN(dat_context, NULL, NULL);"
    },
    {
        "line": 616,
        "fullcodeline": "PCRE2_JIT_STACK_FREE(jit_stack);"
    },
    {
        "line": 617,
        "fullcodeline": "jit_stack = NULL;"
    },
    {
        "line": 618,
        "fullcodeline": "jit_stack_size = 0;"
    },
    {
        "line": 641,
        "fullcodeline": "SETFLD(match_data, oveccount, dat_datctl.oveccount);"
    },
    {
        "line": 730,
        "fullcodeline": "(((dat_datctl.control2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) == 0)? 0 :"
    },
    {
        "line": 745,
        "fullcodeline": "while ((c = *(++pr)) >= CHAR_0 && c <= CHAR_9) n = n * 10 + c - CHAR_0;"
    },
    {
        "line": 746,
        "fullcodeline": "if (*pr++ != ']')"
    },
    {
        "line": 751,
        "fullcodeline": "if (n > nsize)"
    },
    {
        "line": 773,
        "fullcodeline": "while ((c = *pr++) != 0)"
    },
    {
        "line": 827,
        "fullcodeline": "PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, NULL, NULL);  /* No callout */"
    },
    {
        "line": 842,
        "fullcodeline": "if (rc != PCRE2_ERROR_NOMEMORY && nsize != PCRE2_UNSET)"
    },
    {
        "line": 845,
        "fullcodeline": "if (!print_error_message(rc, \"\", \"\")) return PR_ABEND;"
    },
    {
        "line": 846,
        "fullcodeline": "if (rc == PCRE2_ERROR_NOMEMORY &&"
    },
    {
        "line": 852,
        "fullcodeline": "fprintf(outfile, \"%2d: \", rc);"
    },
    {
        "line": 853,
        "fullcodeline": "PCHARSV(nbuffer, 0, nsize, utf, outfile);"
    },
    {
        "line": 895,
        "fullcodeline": "if ((dat_datctl.control & CTL_DFA) != 0)"
    },
    {
        "line": 936,
        "fullcodeline": "(((double)time_taken * 1000.0) / (double)timeitm) /"
    },
    {
        "line": 948,
        "fullcodeline": "if ((dat_datctl.control & CTL_FINDLIMITS_NOHEAP) == 0 &&"
    },
    {
        "line": 958,
        "fullcodeline": "if (FLD(compiled_code, executable_jit) == NULL ||"
    },
    {
        "line": 966,
        "fullcodeline": "if (capcount == 0)"
    },
    {
        "line": 1033,
        "fullcodeline": "if (pp == NULL) pp = (uint8_t *)\"\";"
    },
    {
        "line": 1035,
        "fullcodeline": "if (capcount > (int)oveccount)   /* Check for lunatic return value */"
    },
    {
        "line": 1051,
        "fullcodeline": "if ((dat_datctl.options & PCRE2_COPY_MATCHED_SUBJECT) != 0 &&"
    },
    {
        "line": 1077,
        "fullcodeline": "if (gmatched > 0 && ovecsave[0] == ovector[0] && ovecsave[1] == ovector[1])"
    },
    {
        "line": 1096,
        "fullcodeline": "if ((dat_datctl.control & (CTL_ALLCAPTURES|CTL_DFA)) == CTL_ALLCAPTURES)"
    },
    {
        "line": 1104,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0) capcount = oveccount;"
    },
    {
        "line": 1109,
        "fullcodeline": "for (i = 0; i < 2*capcount; i += 2)"
    },
    {
        "line": 1246,
        "fullcodeline": "if (!copy_and_get(utf, capcount)) return PR_ABEND;"
    },
    {
        "line": 125,
        "fullcodeline": "fprintf(outfile, \"** Expected '{' after \\\\[....]\\n\");"
    },
    {
        "line": 132,
        "fullcodeline": "fprintf(outfile, \"** Repeat count too large\\n\");"
    },
    {
        "line": 139,
        "fullcodeline": "fprintf(outfile, \"** Expected '}' after \\\\[...]{...\\n\");"
    },
    {
        "line": 146,
        "fullcodeline": "fprintf(outfile, \"** Zero repeat not allowed\\n\");"
    },
    {
        "line": 155,
        "fullcodeline": "size_t qoffset = CAST8VAR(q) - dbuffer;"
    },
    {
        "line": 156,
        "fullcodeline": "size_t rep_offset = start_rep - dbuffer;"
    },
    {
        "line": 158,
        "fullcodeline": "dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);"
    },
    {
        "line": 164,
        "fullcodeline": "SETCASTPTR(q, dbuffer + qoffset);"
    },
    {
        "line": 165,
        "fullcodeline": "start_rep = dbuffer + rep_offset;"
    },
    {
        "line": 170,
        "fullcodeline": "memcpy(CAST8VAR(q), start_rep, replen);"
    },
    {
        "line": 171,
        "fullcodeline": "SETPLUS(q, replen/code_unit_size);"
    },
    {
        "line": 186,
        "fullcodeline": "topbit = 0x80000000;"
    },
    {
        "line": 190,
        "fullcodeline": "HASUTF8EXTRALEN(c)) { GETUTF8INC(c, p); }"
    },
    {
        "line": 645,
        "fullcodeline": "max_oveccount = dat_datctl.oveccount;"
    },
    {
        "line": 646,
        "fullcodeline": "PCRE2_MATCH_DATA_FREE(match_data);"
    },
    {
        "line": 647,
        "fullcodeline": "PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, general_context);"
    },
    {
        "line": 728,
        "fullcodeline": "(((dat_datctl.control2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) == 0)? 0 :"
    },
    {
        "line": 748,
        "fullcodeline": "fprintf(outfile, \"Bad buffer size in replacement string\\n\");"
    },
    {
        "line": 789,
        "fullcodeline": "else while ((c = *pr++) != 0)"
    },
    {
        "line": 843,
        "fullcodeline": "fprintf(outfile, \" at offset %ld in replacement\", (long int)nsize);"
    },
    {
        "line": 847,
        "fullcodeline": "(xoptions & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)"
    },
    {
        "line": 848,
        "fullcodeline": "fprintf(outfile, \": %ld code units are needed\", (long int)nsize);"
    },
    {
        "line": 904,
        "fullcodeline": "start_time = clock();"
    },
    {
        "line": 937,
        "fullcodeline": "(double)CLOCKS_PER_SEC);"
    },
    {
        "line": 949,
        "fullcodeline": "(FLD(compiled_code, executable_jit) == NULL ||"
    },
    {
        "line": 952,
        "fullcodeline": "(void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, \"heap\");"
    },
    {
        "line": 960,
        "fullcodeline": "(dat_datctl.control & CTL_DFA) != 0)"
    },
    {
        "line": 962,
        "fullcodeline": "capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_DEPTHLIMIT,"
    },
    {
        "line": 968,
        "fullcodeline": "fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");"
    },
    {
        "line": 969,
        "fullcodeline": "capcount = dat_datctl.oveccount;"
    },
    {
        "line": 978,
        "fullcodeline": "if ((dat_datctl.control & CTL_CALLOUT_NONE) == 0)"
    },
    {
        "line": 993,
        "fullcodeline": "if ((dat_datctl.control & CTL_DFA) != 0)"
    },
    {
        "line": 1037,
        "fullcodeline": "fprintf(outfile,"
    },
    {
        "line": 1040,
        "fullcodeline": "capcount = oveccount;"
    },
    {
        "line": 1052,
        "fullcodeline": "(pat_patctl.control & CTL_JITFAST) == 0)"
    },
    {
        "line": 1085,
        "fullcodeline": "fprintf(outfile,"
    },
    {
        "line": 1087,
        "fullcodeline": "fprintf(outfile, \"** Global loop abandoned\\n\");"
    },
    {
        "line": 1088,
        "fullcodeline": "dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */"
    },
    {
        "line": 1098,
        "fullcodeline": "capcount = maxcapcount + 1;   /* Allow for full match */"
    },
    {
        "line": 1112,
        "fullcodeline": "PCRE2_SIZE start = ovector[i];"
    },
    {
        "line": 1113,
        "fullcodeline": "PCRE2_SIZE end = ovector[i+1];"
    },
    {
        "line": 1123,
        "fullcodeline": "fprintf(outfile, \"%2d: \", i/2);"
    },
    {
        "line": 1220,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1239,
        "fullcodeline": "fprintf(outfile, \"MK: \");"
    },
    {
        "line": 1241,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1255,
        "fullcodeline": "else if (capcount == PCRE2_ERROR_PARTIAL)"
    },
    {
        "line": 1430,
        "fullcodeline": "if (match_offset == end_offset)"
    },
    {
        "line": 1478,
        "fullcodeline": "if ((dat_datctl.control & CTL_GLOBAL) != 0)"
    },
    {
        "line": 157,
        "fullcodeline": "while (needlen >= dbuffer_size) dbuffer_size *= 2;"
    },
    {
        "line": 159,
        "fullcodeline": "if (dbuffer == NULL)"
    },
    {
        "line": 199,
        "fullcodeline": "case 'a': c = CHAR_BEL; break;"
    },
    {
        "line": 200,
        "fullcodeline": "case 'b': c = '\\b'; break;"
    },
    {
        "line": 201,
        "fullcodeline": "case 'e': c = CHAR_ESC; break;"
    },
    {
        "line": 202,
        "fullcodeline": "case 'f': c = '\\f'; break;"
    },
    {
        "line": 203,
        "fullcodeline": "case 'n': c = '\\n'; break;"
    },
    {
        "line": 204,
        "fullcodeline": "case 'r': c = '\\r'; break;"
    },
    {
        "line": 205,
        "fullcodeline": "case 't': c = '\\t'; break;"
    },
    {
        "line": 206,
        "fullcodeline": "case 'v': c = '\\v'; break;"
    },
    {
        "line": 210,
        "fullcodeline": "c -= '0';"
    },
    {
        "line": 263,
        "fullcodeline": "c = 0;"
    },
    {
        "line": 279,
        "fullcodeline": "p--;"
    },
    {
        "line": 291,
        "fullcodeline": "start_rep = CAST8VAR(q);"
    },
    {
        "line": 726,
        "fullcodeline": "(((dat_datctl.control2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) == 0)? 0 :"
    },
    {
        "line": 897,
        "fullcodeline": "if ((dat_datctl.options & PCRE2_DFA_RESTART) != 0)"
    },
    {
        "line": 902,
        "fullcodeline": "if (dfa_workspace == NULL)"
    },
    {
        "line": 905,
        "fullcodeline": "for (i = 0; i < timeitm; i++)"
    },
    {
        "line": 950,
        "fullcodeline": "(dat_datctl.options & PCRE2_NO_JIT) != 0))"
    },
    {
        "line": 959,
        "fullcodeline": "(dat_datctl.options & PCRE2_NO_JIT) != 0 ||"
    },
    {
        "line": 980,
        "fullcodeline": "PCRE2_SET_CALLOUT(dat_context, callout_function,"
    },
    {
        "line": 982,
        "fullcodeline": "first_callout = TRUE;"
    },
    {
        "line": 983,
        "fullcodeline": "last_callout_mark = NULL;"
    },
    {
        "line": 984,
        "fullcodeline": "callout_count = 0;"
    },
    {
        "line": 999,
        "fullcodeline": "PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,"
    },
    {
        "line": 1041,
        "fullcodeline": "if ((dat_datctl.control & CTL_ANYGLOB) != 0)"
    },
    {
        "line": 1054,
        "fullcodeline": "if ((FLD(match_data, flags) & PCRE2_MD_COPIED_SUBJECT) == 0)"
    },
    {
        "line": 1079,
        "fullcodeline": "if (ovector[0] == ovector[1] && ovecsave[2] != dat_datctl.offset)"
    },
    {
        "line": 1099,
        "fullcodeline": "if (capcount > (int)oveccount) capcount = oveccount;"
    },
    {
        "line": 1115,
        "fullcodeline": "if (start > end)"
    },
    {
        "line": 1127,
        "fullcodeline": "if (start == PCRE2_UNSET && end == PCRE2_UNSET)"
    },
    {
        "line": 1138,
        "fullcodeline": "if (start > ulen || end > ulen)"
    },
    {
        "line": 1158,
        "fullcodeline": "if (i == 0)"
    },
    {
        "line": 1225,
        "fullcodeline": "if ((dat_datctl.control & CTL_ALLAFTERTEXT) != 0 ||"
    },
    {
        "line": 1259,
        "fullcodeline": "int rubriclength = 0;"
    },
    {
        "line": 1267,
        "fullcodeline": "fprintf(outfile, \"Partial match\");"
    },
    {
        "line": 1276,
        "fullcodeline": "fprintf(outfile, \": \");"
    },
    {
        "line": 1277,
        "fullcodeline": "rubriclength += 15;"
    },
    {
        "line": 1279,
        "fullcodeline": "PCHARS(backlength, pp, leftchar, ovector[0] - leftchar, utf, outfile);"
    },
    {
        "line": 1280,
        "fullcodeline": "PCHARSV(pp, ovector[0], ulen - ovector[0], utf, outfile);"
    },
    {
        "line": 1284,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1414,
        "fullcodeline": "PCRE2_SIZE match_offset = FLD(match_data, ovector)[0];"
    },
    {
        "line": 1415,
        "fullcodeline": "PCRE2_SIZE end_offset = FLD(match_data, ovector)[1];"
    },
    {
        "line": 1480,
        "fullcodeline": "ovecsave[0] = ovector[0];"
    },
    {
        "line": 1481,
        "fullcodeline": "ovecsave[1] = ovector[1];"
    },
    {
        "line": 1482,
        "fullcodeline": "ovecsave[2] = dat_datctl.offset;"
    },
    {
        "line": 1483,
        "fullcodeline": "dat_datctl.offset = end_offset;"
    },
    {
        "line": 161,
        "fullcodeline": "fprintf(stderr, \"pcre2test: realloc(%d) failed\\n\", (int)dbuffer_size);"
    },
    {
        "line": 162,
        "fullcodeline": "exit(1);"
    },
    {
        "line": 187,
        "fullcodeline": "c = *p++;"
    },
    {
        "line": 196,
        "fullcodeline": "else switch ((c = *p++))"
    },
    {
        "line": 211,
        "fullcodeline": "while (i++ < 2 && isdigit(*p) && *p != '8' && *p != '9')"
    },
    {
        "line": 212,
        "fullcodeline": "c = c * 8 + *p++ - '0';"
    },
    {
        "line": 216,
        "fullcodeline": "if (*p == '{')"
    },
    {
        "line": 233,
        "fullcodeline": "if (*p == '{')"
    },
    {
        "line": 264,
        "fullcodeline": "while (i++ < 2 && isxdigit(*p))"
    },
    {
        "line": 286,
        "fullcodeline": "if (start_rep != NULL)"
    },
    {
        "line": 295,
        "fullcodeline": "if (isalnum(c))"
    },
    {
        "line": 724,
        "fullcodeline": "(((dat_datctl.control2 & CTL2_SUBSTITUTE_LITERAL) == 0)? 0 :"
    },
    {
        "line": 791,
        "fullcodeline": "if (HASUTF8EXTRALEN(c)) { GETUTF8INC(c, pr); }"
    },
    {
        "line": 899,
        "fullcodeline": "fprintf(outfile, \"Timing DFA restarts is not supported\\n\");"
    },
    {
        "line": 903,
        "fullcodeline": "dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));"
    },
    {
        "line": 907,
        "fullcodeline": "PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,"
    },
    {
        "line": 913,
        "fullcodeline": "else if ((pat_patctl.control & CTL_JITFAST) != 0)"
    },
    {
        "line": 988,
        "fullcodeline": "PCRE2_SET_CALLOUT(dat_context, NULL, NULL);  /* No callout */"
    },
    {
        "line": 995,
        "fullcodeline": "if (dfa_workspace == NULL)"
    },
    {
        "line": 997,
        "fullcodeline": "if (dfa_matched++ == 0)"
    },
    {
        "line": 1000,
        "fullcodeline": "dat_datctl.offset, dat_datctl.options | g_notempty, match_data,"
    },
    {
        "line": 1002,
        "fullcodeline": "if (capcount == 0)"
    },
    {
        "line": 1043,
        "fullcodeline": "fprintf(outfile, \"** Global loop abandoned\\n\");"
    },
    {
        "line": 1044,
        "fullcodeline": "dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */"
    },
    {
        "line": 1055,
        "fullcodeline": "fprintf(outfile,"
    },
    {
        "line": 1059,
        "fullcodeline": "fprintf(outfile,"
    },
    {
        "line": 1063,
        "fullcodeline": "fprintf(outfile,"
    },
    {
        "line": 1081,
        "fullcodeline": "g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;"
    },
    {
        "line": 1082,
        "fullcodeline": "ovecsave[2] = dat_datctl.offset;"
    },
    {
        "line": 1117,
        "fullcodeline": "start = ovector[i+1];"
    },
    {
        "line": 1118,
        "fullcodeline": "end = ovector[i];"
    },
    {
        "line": 1119,
        "fullcodeline": "fprintf(outfile, \"Start of matched string is beyond its end - \""
    },
    {
        "line": 1129,
        "fullcodeline": "fprintf(outfile, \"<unset>\\n\");"
    },
    {
        "line": 1226,
        "fullcodeline": "(i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0))"
    },
    {
        "line": 1228,
        "fullcodeline": "fprintf(outfile, \"%2d+ \", i/2);"
    },
    {
        "line": 1229,
        "fullcodeline": "PCHARSV(pp, ovector[i+1], ulen - ovector[i+1], utf, outfile);"
    },
    {
        "line": 1230,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1261,
        "fullcodeline": "if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)"
    },
    {
        "line": 1282,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)"
    },
    {
        "line": 1286,
        "fullcodeline": "if (backlength != 0)"
    },
    {
        "line": 1294,
        "fullcodeline": "if (ulen != ovector[1])"
    },
    {
        "line": 1300,
        "fullcodeline": "if (!copy_and_get(utf, 1)) return PR_ABEND;"
    },
    {
        "line": 1304,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)"
    },
    {
        "line": 1432,
        "fullcodeline": "if (end_offset == ulen) break;           /* End of subject */"
    },
    {
        "line": 1433,
        "fullcodeline": "if (match_offset <= dat_datctl.offset)"
    },
    {
        "line": 1446,
        "fullcodeline": "g_notempty = 0;   /* Set for a \"normal\" repeat */"
    },
    {
        "line": 1490,
        "fullcodeline": "pp += end_offset * code_unit_size;"
    },
    {
        "line": 1491,
        "fullcodeline": "len -= end_offset * code_unit_size;"
    },
    {
        "line": 1492,
        "fullcodeline": "ulen -= end_offset;"
    },
    {
        "line": 218,
        "fullcodeline": "uint8_t *pt = p;"
    },
    {
        "line": 219,
        "fullcodeline": "c = 0;"
    },
    {
        "line": 235,
        "fullcodeline": "uint8_t *pt = p;"
    },
    {
        "line": 236,
        "fullcodeline": "c = 0;"
    },
    {
        "line": 266,
        "fullcodeline": "c = c * 16 + tolower(*p) - ((isdigit(*p))? '0' : 'a' - 10);"
    },
    {
        "line": 267,
        "fullcodeline": "p++;"
    },
    {
        "line": 288,
        "fullcodeline": "fprintf(outfile, \"** Nested replication is not supported\\n\");"
    },
    {
        "line": 297,
        "fullcodeline": "fprintf(outfile, \"** Unrecognized escape sequence \\\"\\\\%c\\\"\\n\", c);"
    },
    {
        "line": 722,
        "fullcodeline": "(((dat_datctl.control2 & CTL2_SUBSTITUTE_EXTENDED) == 0)? 0 :"
    },
    {
        "line": 908,
        "fullcodeline": "dat_datctl.offset, dat_datctl.options | g_notempty, match_data,"
    },
    {
        "line": 915,
        "fullcodeline": "start_time = clock();"
    },
    {
        "line": 996,
        "fullcodeline": "dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));"
    },
    {
        "line": 998,
        "fullcodeline": "dfa_workspace[0] = -1;  /* To catch bad restart */"
    },
    {
        "line": 1004,
        "fullcodeline": "fprintf(outfile, \"Matched, but offsets vector is too small to show all matches\\n\");"
    },
    {
        "line": 1005,
        "fullcodeline": "capcount = dat_datctl.oveccount;"
    },
    {
        "line": 1010,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITFAST) != 0)"
    },
    {
        "line": 1016,
        "fullcodeline": "if (capcount == 0)"
    },
    {
        "line": 1140,
        "fullcodeline": "if (((dat_datctl.control & CTL_DFA) != 0 ||"
    },
    {
        "line": 1163,
        "fullcodeline": "if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)"
    },
    {
        "line": 1217,
        "fullcodeline": "PCHARSV(pp, start, end - start, utf, outfile);"
    },
    {
        "line": 1263,
        "fullcodeline": "leftchar = FLD(match_data, leftchar);"
    },
    {
        "line": 1271,
        "fullcodeline": "fprintf(outfile, \", mark=\");"
    },
    {
        "line": 1274,
        "fullcodeline": "rubriclength += 7;"
    },
    {
        "line": 1283,
        "fullcodeline": "fprintf(outfile, \" (JIT)\");"
    },
    {
        "line": 1291,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1295,
        "fullcodeline": "fprintf(outfile, \"** ovector[1] is not equal to the subject length: \""
    },
    {
        "line": 1305,
        "fullcodeline": "show_ovector(ovector, oveccount);"
    },
    {
        "line": 1325,
        "fullcodeline": "else if (g_notempty != 0)   /* There was a previous null match */"
    },
    {
        "line": 1434,
        "fullcodeline": "g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;"
    },
    {
        "line": 1447,
        "fullcodeline": "if ((dat_datctl.control & CTL_GLOBAL) != 0)"
    },
    {
        "line": 1493,
        "fullcodeline": "if (arg_ulen != PCRE2_ZERO_TERMINATED) arg_ulen -= end_offset;"
    },
    {
        "line": 220,
        "fullcodeline": "for (pt++; isdigit(*pt) && *pt != '8' && *pt != '9'; pt++)"
    },
    {
        "line": 227,
        "fullcodeline": "if (*pt == '}') p = pt + 1;"
    },
    {
        "line": 243,
        "fullcodeline": "for (pt++; isxdigit(*pt); pt++)"
    },
    {
        "line": 250,
        "fullcodeline": "if (*pt == '}')"
    },
    {
        "line": 720,
        "fullcodeline": "(((dat_datctl.control & CTL_GLOBAL) == 0)? 0 :"
    },
    {
        "line": 916,
        "fullcodeline": "for (i = 0; i < timeitm; i++)"
    },
    {
        "line": 926,
        "fullcodeline": "start_time = clock();"
    },
    {
        "line": 1011,
        "fullcodeline": "PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,"
    },
    {
        "line": 1018,
        "fullcodeline": "fprintf(outfile, \"Matched, but too many substrings\\n\");"
    },
    {
        "line": 1019,
        "fullcodeline": "capcount = dat_datctl.oveccount;"
    },
    {
        "line": 1142,
        "fullcodeline": "start == JUNK_OFFSET && end == JUNK_OFFSET)"
    },
    {
        "line": 1143,
        "fullcodeline": "fprintf(outfile, \"<unchanged>\\n\");"
    },
    {
        "line": 1165,
        "fullcodeline": "leftchar = FLD(match_data, leftchar);"
    },
    {
        "line": 1166,
        "fullcodeline": "rightchar = FLD(match_data, rightchar);"
    },
    {
        "line": 1167,
        "fullcodeline": "showallused = i == 0 && (leftchar < start || rightchar > end);"
    },
    {
        "line": 1173,
        "fullcodeline": "PCHARS(lleft, pp, leftchar, start - leftchar, utf, outfile);"
    },
    {
        "line": 1174,
        "fullcodeline": "PCHARS(lmiddle, pp, start, end - start, utf, outfile);"
    },
    {
        "line": 1175,
        "fullcodeline": "PCHARS(lright, pp, end, rightchar - end, utf, outfile);"
    },
    {
        "line": 1178,
        "fullcodeline": "fprintf(outfile, \"\\n    \");"
    },
    {
        "line": 1265,
        "fullcodeline": "else leftchar = ovector[0];"
    },
    {
        "line": 1289,
        "fullcodeline": "for (i = 0; i < rubriclength; i++) fprintf(outfile, \" \");"
    },
    {
        "line": 1290,
        "fullcodeline": "for (i = 0; i < backlength; i++) fprintf(outfile, \"<\");"
    },
    {
        "line": 1296,
        "fullcodeline": "\"%ld != %ld\\n\", (unsigned long int)ovector[1], (unsigned long int)ulen);"
    },
    {
        "line": 1327,
        "fullcodeline": "uint16_t nl = FLD(compiled_code, newline_convention);"
    },
    {
        "line": 1328,
        "fullcodeline": "PCRE2_SIZE start_offset = dat_datctl.offset;    /* Where the match was */"
    },
    {
        "line": 1329,
        "fullcodeline": "PCRE2_SIZE end_offset = start_offset + 1;"
    },
    {
        "line": 1352,
        "fullcodeline": "SETFLDVEC(match_data, ovector, 0, start_offset);"
    },
    {
        "line": 1353,
        "fullcodeline": "SETFLDVEC(match_data, ovector, 1, end_offset);"
    },
    {
        "line": 1450,
        "fullcodeline": "PCRE2_GET_STARTCHAR(startchar, match_data);"
    },
    {
        "line": 252,
        "fullcodeline": "p = pt + 1;"
    },
    {
        "line": 918,
        "fullcodeline": "PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen,"
    },
    {
        "line": 927,
        "fullcodeline": "for (i = 0; i < timeitm; i++)"
    },
    {
        "line": 1012,
        "fullcodeline": "dat_datctl.options | g_notempty, match_data, use_dat_context);"
    },
    {
        "line": 1014,
        "fullcodeline": "PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,"
    },
    {
        "line": 1145,
        "fullcodeline": "fprintf(outfile, \"ERROR: bad value(s) for offset(s): 0x%lx 0x%lx\\n\","
    },
    {
        "line": 1169,
        "fullcodeline": "else showallused = FALSE;"
    },
    {
        "line": 1176,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)"
    },
    {
        "line": 1179,
        "fullcodeline": "for (j = 0; j < lleft; j++) fprintf(outfile, \"<\");"
    },
    {
        "line": 1180,
        "fullcodeline": "for (j = 0; j < lmiddle; j++) fprintf(outfile, \" \");"
    },
    {
        "line": 1181,
        "fullcodeline": "for (j = 0; j < lright; j++) fprintf(outfile, \">\");"
    },
    {
        "line": 1331,
        "fullcodeline": "if ((nl == PCRE2_NEWLINE_CRLF || nl == PCRE2_NEWLINE_ANY ||"
    },
    {
        "line": 1451,
        "fullcodeline": "if (end_offset <= startchar)"
    },
    {
        "line": 222,
        "fullcodeline": "if (++i == 12)"
    },
    {
        "line": 228,
        "fullcodeline": "else fprintf(outfile, \"** Missing } after \\\\o{ (assumed)\\n\");"
    },
    {
        "line": 245,
        "fullcodeline": "if (++i == 9)"
    },
    {
        "line": 919,
        "fullcodeline": "dat_datctl.offset, dat_datctl.options | g_notempty, match_data,"
    },
    {
        "line": 929,
        "fullcodeline": "PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen,"
    },
    {
        "line": 1015,
        "fullcodeline": "dat_datctl.options | g_notempty, match_data, use_dat_context);"
    },
    {
        "line": 1141,
        "fullcodeline": "i >= (int)(2*maxcapcount + 2)) &&"
    },
    {
        "line": 1146,
        "fullcodeline": "(unsigned long int)start, (unsigned long int)end);"
    },
    {
        "line": 1177,
        "fullcodeline": "fprintf(outfile, \" (JIT)\");"
    },
    {
        "line": 1188,
        "fullcodeline": "else if ((dat_datctl.control & CTL_STARTCHAR) != 0)"
    },
    {
        "line": 1335,
        "fullcodeline": "CODE_UNIT(pp, end_offset) == '\\n')"
    },
    {
        "line": 1336,
        "fullcodeline": "end_offset++;"
    },
    {
        "line": 1454,
        "fullcodeline": "end_offset = startchar + 1;"
    },
    {
        "line": 223,
        "fullcodeline": "fprintf(outfile, \"** Too many octal digits in \\\\o{...} item; \""
    },
    {
        "line": 246,
        "fullcodeline": "fprintf(outfile, \"** Too many hex digits in \\\\x{...} item; \""
    },
    {
        "line": 930,
        "fullcodeline": "dat_datctl.offset, dat_datctl.options | g_notempty, match_data,"
    },
    {
        "line": 1191,
        "fullcodeline": "PCRE2_GET_STARTCHAR(startchar, match_data);"
    },
    {
        "line": 1192,
        "fullcodeline": "PCHARS(lleft, pp, startchar, start - startchar, utf, outfile);"
    },
    {
        "line": 1193,
        "fullcodeline": "PCHARSV(pp, start, end - start, utf, outfile);"
    },
    {
        "line": 1334,
        "fullcodeline": "CODE_UNIT(pp, start_offset) == '\\r' &&"
    },
    {
        "line": 1385,
        "fullcodeline": "fprintf(outfile, \"Error %d (bad UTF-%d offset)\\n\", capcount, test_mode);"
    },
    {
        "line": 1389,
        "fullcodeline": "fprintf(outfile, \"Failed: error %d: \", capcount);"
    },
    {
        "line": 1398,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1453,
        "fullcodeline": "if (startchar >= ulen) break;       /* End of subject */"
    },
    {
        "line": 1455,
        "fullcodeline": "if (utf && test_mode != PCRE32_MODE)"
    },
    {
        "line": 225,
        "fullcodeline": "else c = c * 8 + *pt - '0';"
    },
    {
        "line": 248,
        "fullcodeline": "else c = c * 16 + tolower(*pt) - ((isdigit(*pt))? '0' : 'a' - 10);"
    },
    {
        "line": 1194,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)"
    },
    {
        "line": 1196,
        "fullcodeline": "if (startchar != start)"
    },
    {
        "line": 1207,
        "fullcodeline": "PCHARSV(pp, start, end - start, utf, outfile);"
    },
    {
        "line": 1333,
        "fullcodeline": "start_offset < ulen - 1 &&"
    },
    {
        "line": 1338,
        "fullcodeline": "else if (utf && test_mode != PCRE32_MODE)"
    },
    {
        "line": 1364,
        "fullcodeline": "if (gmatched == 0)"
    },
    {
        "line": 1390,
        "fullcodeline": "if (!print_error_message(capcount, \"\", \"\")) return PR_ABEND;"
    },
    {
        "line": 1391,
        "fullcodeline": "if (capcount <= PCRE2_ERROR_UTF8_ERR1 &&"
    },
    {
        "line": 1195,
        "fullcodeline": "fprintf(outfile, \" (JIT)\");"
    },
    {
        "line": 1198,
        "fullcodeline": "fprintf(outfile, \"\\n    \");"
    },
    {
        "line": 1208,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)"
    },
    {
        "line": 1332,
        "fullcodeline": "nl == PCRE2_NEWLINE_ANYCRLF) &&"
    },
    {
        "line": 1366,
        "fullcodeline": "fprintf(outfile, \"No match\");"
    },
    {
        "line": 1375,
        "fullcodeline": "fprintf(outfile, \"\\n\");"
    },
    {
        "line": 1392,
        "fullcodeline": "capcount >= PCRE2_ERROR_UTF32_ERR2)"
    },
    {
        "line": 1395,
        "fullcodeline": "PCRE2_GET_STARTCHAR(startchar, match_data);"
    },
    {
        "line": 1457,
        "fullcodeline": "if (test_mode == PCRE8_MODE)"
    },
    {
        "line": 1199,
        "fullcodeline": "for (j = 0; j < lleft; j++) fprintf(outfile, \"^\");"
    },
    {
        "line": 1209,
        "fullcodeline": "fprintf(outfile, \" (JIT)\");"
    },
    {
        "line": 1340,
        "fullcodeline": "if (test_mode == PCRE8_MODE)"
    },
    {
        "line": 1373,
        "fullcodeline": "if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)"
    },
    {
        "line": 1379,
        "fullcodeline": "if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)"
    },
    {
        "line": 1370,
        "fullcodeline": "fprintf(outfile, \", mark = \");"
    },
    {
        "line": 1374,
        "fullcodeline": "fprintf(outfile, \" (JIT)\");"
    },
    {
        "line": 1380,
        "fullcodeline": "show_ovector(ovector, oveccount);"
    },
    {
        "line": 1459,
        "fullcodeline": "for (; end_offset < ulen; end_offset++)"
    },
    {
        "line": 1342,
        "fullcodeline": "for (; end_offset < ulen; end_offset++)"
    },
    {
        "line": 1460,
        "fullcodeline": "if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;"
    },
    {
        "line": 1464,
        "fullcodeline": "for (; end_offset < ulen; end_offset++)"
    },
    {
        "line": 1343,
        "fullcodeline": "if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;"
    },
    {
        "line": 1347,
        "fullcodeline": "for (; end_offset < ulen; end_offset++)"
    },
    {
        "line": 1465,
        "fullcodeline": "if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;"
    },
    {
        "line": 1348,
        "fullcodeline": "if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;"
    }
]