[
    {
        "line": 4,
        "fullcodeline": "struct inode *inode = file->f_path.dentry->d_inode;"
    },
    {
        "line": 5,
        "fullcodeline": "struct gfs2_sbd *sdp = GFS2_SB(inode);"
    },
    {
        "line": 6,
        "fullcodeline": "struct gfs2_inode *ip = GFS2_I(inode);"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned int data_blocks = 0, ind_blocks = 0, rblocks;"
    },
    {
        "line": 11,
        "fullcodeline": "loff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);"
    },
    {
        "line": 12,
        "fullcodeline": "loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;"
    },
    {
        "line": 13,
        "fullcodeline": "loff_t max_chunk_size = UINT_MAX & bsize_mask;"
    },
    {
        "line": 14,
        "fullcodeline": "next = (next + 1) << sdp->sd_sb.sb_bsize_shift;"
    },
    {
        "line": 20,
        "fullcodeline": "offset &= bsize_mask;"
    },
    {
        "line": 22,
        "fullcodeline": "len = next - offset;"
    },
    {
        "line": 23,
        "fullcodeline": "bytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;"
    },
    {
        "line": 26,
        "fullcodeline": "bytes &= bsize_mask;"
    },
    {
        "line": 30,
        "fullcodeline": "gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);"
    },
    {
        "line": 31,
        "fullcodeline": "error = gfs2_glock_nq(&ip->i_gh);"
    },
    {
        "line": 96,
        "fullcodeline": "gfs2_inplace_release(ip);"
    },
    {
        "line": 98,
        "fullcodeline": "gfs2_quota_unlock(ip);"
    },
    {
        "line": 100,
        "fullcodeline": "gfs2_alloc_put(ip);"
    },
    {
        "line": 102,
        "fullcodeline": "gfs2_glock_dq(&ip->i_gh);"
    },
    {
        "line": 17,
        "fullcodeline": "if (mode & ~FALLOC_FL_KEEP_SIZE)"
    },
    {
        "line": 24,
        "fullcodeline": "if (!bytes)"
    },
    {
        "line": 27,
        "fullcodeline": "if (bytes == 0)"
    },
    {
        "line": 32,
        "fullcodeline": "if (unlikely(error))"
    },
    {
        "line": 38,
        "fullcodeline": "while (len > 0) {"
    },
    {
        "line": 25,
        "fullcodeline": "bytes = UINT_MAX;"
    },
    {
        "line": 28,
        "fullcodeline": "bytes = sdp->sd_sb.sb_bsize;"
    },
    {
        "line": 35,
        "fullcodeline": "if (!gfs2_write_alloc_required(ip, offset, len))"
    },
    {
        "line": 41,
        "fullcodeline": "al = gfs2_alloc_get(ip);"
    },
    {
        "line": 47,
        "fullcodeline": "error = gfs2_quota_lock_check(ip);"
    },
    {
        "line": 52,
        "fullcodeline": "gfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);"
    },
    {
        "line": 55,
        "fullcodeline": "error = gfs2_inplace_reserve(ip);"
    },
    {
        "line": 66,
        "fullcodeline": "max_bytes = bytes;"
    },
    {
        "line": 67,
        "fullcodeline": "calc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,"
    },
    {
        "line": 69,
        "fullcodeline": "al->al_requested = data_blocks + ind_blocks;"
    },
    {
        "line": 71,
        "fullcodeline": "rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +"
    },
    {
        "line": 76,
        "fullcodeline": "error = gfs2_trans_begin(sdp, rblocks,"
    },
    {
        "line": 81,
        "fullcodeline": "error = fallocate_chunk(inode, offset, max_bytes, mode);"
    },
    {
        "line": 82,
        "fullcodeline": "gfs2_trans_end(sdp);"
    },
    {
        "line": 87,
        "fullcodeline": "len -= max_bytes;"
    },
    {
        "line": 88,
        "fullcodeline": "offset += max_bytes;"
    },
    {
        "line": 89,
        "fullcodeline": "gfs2_inplace_release(ip);"
    },
    {
        "line": 90,
        "fullcodeline": "gfs2_quota_unlock(ip);"
    },
    {
        "line": 91,
        "fullcodeline": "gfs2_alloc_put(ip);"
    },
    {
        "line": 18,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 39,
        "fullcodeline": "if (len < bytes)"
    },
    {
        "line": 73,
        "fullcodeline": "if (gfs2_is_jdata(ip))"
    },
    {
        "line": 40,
        "fullcodeline": "bytes = len;"
    },
    {
        "line": 43,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 72,
        "fullcodeline": "RES_RG_HDR + gfs2_rg_blocks(ip);"
    },
    {
        "line": 74,
        "fullcodeline": "rblocks += data_blocks ? data_blocks : 1;"
    },
    {
        "line": 77,
        "fullcodeline": "PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);"
    },
    {
        "line": 57,
        "fullcodeline": "if (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {"
    },
    {
        "line": 58,
        "fullcodeline": "bytes >>= 1;"
    },
    {
        "line": 59,
        "fullcodeline": "bytes &= bsize_mask;"
    },
    {
        "line": 60,
        "fullcodeline": "if (bytes == 0)"
    },
    {
        "line": 61,
        "fullcodeline": "bytes = sdp->sd_sb.sb_bsize;"
    }
]