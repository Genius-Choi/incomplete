[
    {
        "line": 14,
        "fullcodeline": "auto id     = (subimage == 0) ? m_primary_id : m_item_ids[subimage - 1];"
    },
    {
        "line": 15,
        "fullcodeline": "m_ihandle   = m_ctx->get_image_handle(id);"
    },
    {
        "line": 17,
        "fullcodeline": "auto chroma = m_has_alpha ? heif_chroma_interleaved_RGBA"
    },
    {
        "line": 33,
        "fullcodeline": "options(heif_decoding_options_alloc(), heif_decoding_options_free);"
    },
    {
        "line": 34,
        "fullcodeline": "options->ignore_transformations = !m_reorient;"
    },
    {
        "line": 36,
        "fullcodeline": "struct heif_image* img_tmp = nullptr;"
    },
    {
        "line": 37,
        "fullcodeline": "struct heif_error herr = heif_decode_image(m_ihandle.get_raw_image_handle(),"
    },
    {
        "line": 49,
        "fullcodeline": "int bits = m_himage.get_bits_per_pixel(heif_channel_interleaved);"
    },
    {
        "line": 50,
        "fullcodeline": "m_spec = ImageSpec(m_ihandle.get_width(), m_ihandle.get_height(), bits / 8,"
    },
    {
        "line": 53,
        "fullcodeline": "m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");"
    },
    {
        "line": 73,
        "fullcodeline": "m_associated_alpha = true;  // assume/hope"
    },
    {
        "line": 120,
        "fullcodeline": "int orientation = 1;"
    },
    {
        "line": 121,
        "fullcodeline": "const heif_context* raw_ctx"
    },
    {
        "line": 123,
        "fullcodeline": "int xpcount = heif_item_get_transformation_properties(raw_ctx, id, nullptr,"
    },
    {
        "line": 125,
        "fullcodeline": "xpcount     = std::min(xpcount, 100);  // clamp to some reasonable limit"
    },
    {
        "line": 127,
        "fullcodeline": "heif_item_get_transformation_properties(raw_ctx, id, xprops.data(),"
    },
    {
        "line": 3,
        "fullcodeline": "if (miplevel != 0)"
    },
    {
        "line": 6,
        "fullcodeline": "if (subimage == m_subimage) {"
    },
    {
        "line": 10,
        "fullcodeline": "if (subimage >= m_num_subimages) {"
    },
    {
        "line": 16,
        "fullcodeline": "m_has_alpha = m_ihandle.has_alpha_channel();"
    },
    {
        "line": 76,
        "fullcodeline": "auto meta_ids = m_ihandle.get_list_of_metadata_block_IDs();"
    },
    {
        "line": 122,
        "fullcodeline": "= reinterpret_cast<std::shared_ptr<heif_context>*>(m_ctx.get())->get();"
    },
    {
        "line": 126,
        "fullcodeline": "std::vector<heif_property_id> xprops(xpcount);"
    },
    {
        "line": 129,
        "fullcodeline": "for (int i = 0; i < xpcount; ++i) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (orientation != 1) {"
    },
    {
        "line": 39,
        "fullcodeline": "chroma, options.get());"
    },
    {
        "line": 41,
        "fullcodeline": "m_himage = heif::Image(img_tmp);"
    },
    {
        "line": 42,
        "fullcodeline": "if (herr.code != heif_error_Ok || !img_tmp) {"
    },
    {
        "line": 130,
        "fullcodeline": "auto type = heif_item_get_property_type(raw_ctx, id, xprops[i]);"
    },
    {
        "line": 79,
        "fullcodeline": "std::vector<uint8_t> metacontents;"
    },
    {
        "line": 131,
        "fullcodeline": "if (type == heif_item_property_type_transform_rotation) {"
    },
    {
        "line": 81,
        "fullcodeline": "metacontents = m_ihandle.get_metadata(m);"
    },
    {
        "line": 90,
        "fullcodeline": "if (Strutil::iequals(m_ihandle.get_metadata_type(m), \"Exif\")"
    },
    {
        "line": 91,
        "fullcodeline": "&& metacontents.size() >= 10) {"
    },
    {
        "line": 93,
        "fullcodeline": "decode_exif(s, m_spec);"
    },
    {
        "line": 132,
        "fullcodeline": "int rot = heif_item_get_property_transform_rotation_ccw(raw_ctx, id,"
    },
    {
        "line": 135,
        "fullcodeline": "static const int cw[] = { 0, 6, 7, 8, 5, 2, 3, 4, 1 };"
    },
    {
        "line": 165,
        "fullcodeline": "m_spec.attribute(\"oiio:OriginalOrientation\", orientation);"
    },
    {
        "line": 92,
        "fullcodeline": "cspan<uint8_t> s(&metacontents[10], metacontents.size() - 10);"
    },
    {
        "line": 136,
        "fullcodeline": "for (int i = 0; i < rot / 90; ++i)"
    },
    {
        "line": 137,
        "fullcodeline": "orientation = cw[orientation];"
    },
    {
        "line": 138,
        "fullcodeline": "} else if (type == heif_item_property_type_transform_mirror) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (err.get_code() == heif_error_Usage_error"
    },
    {
        "line": 84,
        "fullcodeline": "&& err.get_subcode() == heif_suberror_Null_pointer_argument) {"
    },
    {
        "line": 94,
        "fullcodeline": "} else if (0  // For now, skip this, I haven't seen anything useful"
    },
    {
        "line": 96,
        "fullcodeline": "&& Strutil::iequals(m_ihandle.get_metadata_content_type(m),"
    },
    {
        "line": 98,
        "fullcodeline": "decode_xmp(metacontents, m_spec);"
    },
    {
        "line": 139,
        "fullcodeline": "int mirror = heif_item_get_property_transform_mirror(raw_ctx, id,"
    },
    {
        "line": 142,
        "fullcodeline": "static const int mirrorh[] = { 0, 2, 1, 4, 3, 6, 5, 8, 7 };"
    },
    {
        "line": 143,
        "fullcodeline": "static const int mirrorv[] = { 0, 4, 3, 2, 1, 8, 7, 6, 5 };"
    },
    {
        "line": 95,
        "fullcodeline": "&& Strutil::iequals(m_ihandle.get_metadata_type(m), \"mime\")"
    },
    {
        "line": 144,
        "fullcodeline": "if (mirror == heif_transform_mirror_direction_vertical) {"
    },
    {
        "line": 145,
        "fullcodeline": "orientation = mirrorv[orientation];"
    },
    {
        "line": 146,
        "fullcodeline": "} else if (mirror == heif_transform_mirror_direction_horizontal) {"
    },
    {
        "line": 147,
        "fullcodeline": "orientation = mirrorh[orientation];"
    }
]