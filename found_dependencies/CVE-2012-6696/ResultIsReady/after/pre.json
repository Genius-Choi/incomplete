[
    {
        "line": 3,
        "fullcodeline": "unsigned i = 0, o;"
    },
    {
        "line": 4,
        "fullcodeline": "int q = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "rr.type = DNS_QUERY_NONE;"
    },
    {
        "line": 11,
        "fullcodeline": "rr.rdlength = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "rr.ttl = 1;\t/* GCC is a whiney bastard -- see the XXX below. */"
    },
    {
        "line": 13,
        "fullcodeline": "rr.rr_class = 0; /* Same for VC++ */"
    },
    {
        "line": 28,
        "fullcodeline": "length -= 12;"
    },
    {
        "line": 47,
        "fullcodeline": "curanswer = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "if (!(header.flags1 & FLAGS_MASK_QR))"
    },
    {
        "line": 18,
        "fullcodeline": "if (header.flags1 & FLAGS_MASK_OPCODE)"
    },
    {
        "line": 21,
        "fullcodeline": "if (header.flags2 & FLAGS_MASK_RCODE)"
    },
    {
        "line": 24,
        "fullcodeline": "if (header.ancount < 1)"
    },
    {
        "line": 30,
        "fullcodeline": "while ((unsigned int)q < header.qdcount && i < length)"
    },
    {
        "line": 48,
        "fullcodeline": "while ((unsigned)curanswer < header.ancount)"
    },
    {
        "line": 90,
        "fullcodeline": "if ((unsigned int)curanswer == header.ancount)"
    },
    {
        "line": 96,
        "fullcodeline": "if (rr.rdlength > 1023)"
    },
    {
        "line": 170,
        "fullcodeline": "return std::make_pair(res,\"No error\");"
    },
    {
        "line": 50,
        "fullcodeline": "q = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "DNS::FillResourceRecord(&rr,&header.payload[i]);"
    },
    {
        "line": 74,
        "fullcodeline": "i += 10;"
    },
    {
        "line": 75,
        "fullcodeline": "ServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d\", rr.type, this->type, rr.rr_class, this->rr_class);"
    },
    {
        "line": 108,
        "fullcodeline": "o = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "q = 0;"
    },
    {
        "line": 150,
        "fullcodeline": "res[o] = 0;"
    },
    {
        "line": 156,
        "fullcodeline": "memcpy(res,&header.payload[i],rr.rdlength);"
    },
    {
        "line": 157,
        "fullcodeline": "res[rr.rdlength] = 0;"
    },
    {
        "line": 163,
        "fullcodeline": "memcpy(res,&header.payload[i],rr.rdlength);"
    },
    {
        "line": 164,
        "fullcodeline": "res[rr.rdlength] = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"Not a query result\");"
    },
    {
        "line": 19,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"Unexpected value in DNS reply packet\");"
    },
    {
        "line": 22,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"Domain name not found\");"
    },
    {
        "line": 25,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"No resource records returned\");"
    },
    {
        "line": 32,
        "fullcodeline": "if (header.payload[i] > 63)"
    },
    {
        "line": 51,
        "fullcodeline": "while (q == 0 && i < length)"
    },
    {
        "line": 76,
        "fullcodeline": "if (rr.type != this->type)"
    },
    {
        "line": 82,
        "fullcodeline": "if (rr.rr_class != this->rr_class)"
    },
    {
        "line": 91,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"No A, AAAA or PTR type answers (\" + ConvToStr(header.ancount) + \" answers)\");"
    },
    {
        "line": 94,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"Resource record larger than stated\");"
    },
    {
        "line": 97,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"Resource record too large\");"
    },
    {
        "line": 153,
        "fullcodeline": "if (rr.rdlength != sizeof(struct in6_addr))"
    },
    {
        "line": 160,
        "fullcodeline": "if (rr.rdlength != sizeof(struct in_addr))"
    },
    {
        "line": 167,
        "fullcodeline": "return std::make_pair((unsigned char *) NULL, \"don't know how to handle undefined type (\" + ConvToStr(rr.type) + \") -- rejecting\");"
    },
    {
        "line": 34,
        "fullcodeline": "i += 6;"
    },
    {
        "line": 35,
        "fullcodeline": "q++;"
    },
    {
        "line": 78,
        "fullcodeline": "curanswer++;"
    },
    {
        "line": 79,
        "fullcodeline": "i += rr.rdlength;"
    },
    {
        "line": 84,
        "fullcodeline": "curanswer++;"
    },
    {
        "line": 85,
        "fullcodeline": "i += rr.rdlength;"
    },
    {
        "line": 110,
        "fullcodeline": "while (q == 0 && i < length && o + 256 < 1023)"
    },
    {
        "line": 53,
        "fullcodeline": "if (header.payload[i] > 63)"
    },
    {
        "line": 68,
        "fullcodeline": "if (static_cast<int>(length - i) < 10)"
    },
    {
        "line": 69,
        "fullcodeline": "return std::make_pair((unsigned char*)NULL,\"Incorrectly sized DNS reply\");"
    },
    {
        "line": 113,
        "fullcodeline": "if (header.payload[i] > 63)"
    },
    {
        "line": 154,
        "fullcodeline": "return std::make_pair((unsigned char *) NULL, \"rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?\");"
    },
    {
        "line": 161,
        "fullcodeline": "return std::make_pair((unsigned char *) NULL, \"rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?\");"
    },
    {
        "line": 39,
        "fullcodeline": "if (header.payload[i] == 0)"
    },
    {
        "line": 55,
        "fullcodeline": "i += 2;"
    },
    {
        "line": 56,
        "fullcodeline": "q = 1;"
    },
    {
        "line": 115,
        "fullcodeline": "memcpy(&ptr,&header.payload[i],2);"
    },
    {
        "line": 117,
        "fullcodeline": "i = ntohs(ptr);"
    },
    {
        "line": 127,
        "fullcodeline": "i =- 12;"
    },
    {
        "line": 41,
        "fullcodeline": "q++;"
    },
    {
        "line": 42,
        "fullcodeline": "i += 5;"
    },
    {
        "line": 124,
        "fullcodeline": "i &= ~DN_COMP_BITMASK;"
    },
    {
        "line": 44,
        "fullcodeline": "else i += header.payload[i] + 1;"
    },
    {
        "line": 60,
        "fullcodeline": "if (header.payload[i] == 0)"
    },
    {
        "line": 120,
        "fullcodeline": "if (!(i & DN_COMP_BITMASK))"
    },
    {
        "line": 131,
        "fullcodeline": "if (header.payload[i] == 0)"
    },
    {
        "line": 62,
        "fullcodeline": "i++;"
    },
    {
        "line": 63,
        "fullcodeline": "q = 1;"
    },
    {
        "line": 121,
        "fullcodeline": "return std::make_pair((unsigned char *) NULL, \"DN label decompression header is bogus\");"
    },
    {
        "line": 133,
        "fullcodeline": "q = 1;"
    },
    {
        "line": 65,
        "fullcodeline": "else i += header.payload[i] + 1; /* skip length and label */"
    },
    {
        "line": 137,
        "fullcodeline": "res[o] = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "memcpy(&res[o], &header.payload[i + 1], header.payload[i]);"
    },
    {
        "line": 145,
        "fullcodeline": "o += header.payload[i];"
    },
    {
        "line": 146,
        "fullcodeline": "i += header.payload[i] + 1;"
    },
    {
        "line": 138,
        "fullcodeline": "if (o != 0)"
    },
    {
        "line": 139,
        "fullcodeline": "res[o++] = '.';"
    },
    {
        "line": 141,
        "fullcodeline": "if (o + header.payload[i] > sizeof(DNSHeader))"
    },
    {
        "line": 142,
        "fullcodeline": "return std::make_pair((unsigned char *) NULL, \"DN label decompression is impossible -- malformed/hostile packet?\");"
    }
]