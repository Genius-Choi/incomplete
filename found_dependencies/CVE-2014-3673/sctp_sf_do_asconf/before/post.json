[
    {
        "line": 7,
        "fullcodeline": "struct sctp_chunk\t*chunk = arg;"
    },
    {
        "line": 8,
        "fullcodeline": "struct sctp_chunk\t*asconf_ack = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "struct sctp_paramhdr\t*err_param = NULL;"
    },
    {
        "line": 36,
        "fullcodeline": "serial = ntohl(hdr->serial);"
    },
    {
        "line": 38,
        "fullcodeline": "addr_param = (union sctp_addr_param *)hdr->params;"
    },
    {
        "line": 39,
        "fullcodeline": "length = ntohs(addr_param->p.length);"
    },
    {
        "line": 113,
        "fullcodeline": "asconf_ack->dest = chunk->source;"
    },
    {
        "line": 114,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));"
    },
    {
        "line": 15,
        "fullcodeline": "if (!sctp_vtag_verify(chunk, asoc)) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (!net->sctp.addip_noauth && !chunk->auth)"
    },
    {
        "line": 31,
        "fullcodeline": "if (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))"
    },
    {
        "line": 40,
        "fullcodeline": "if (length < sizeof(sctp_paramhdr_t))"
    },
    {
        "line": 45,
        "fullcodeline": "if (!sctp_verify_asconf(asoc,"
    },
    {
        "line": 56,
        "fullcodeline": "if (serial == asoc->peer.addip_serial + 1) {"
    },
    {
        "line": 16,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,"
    },
    {
        "line": 71,
        "fullcodeline": "asconf_ack = sctp_process_asconf((struct sctp_association *)"
    },
    {
        "line": 116,
        "fullcodeline": "sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);"
    },
    {
        "line": 117,
        "fullcodeline": "((struct sctp_association *)asoc)->new_transport = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 28,
        "fullcodeline": "return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 32,
        "fullcodeline": "return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,"
    },
    {
        "line": 41,
        "fullcodeline": "return sctp_sf_violation_paramlen(net, ep, asoc, type, arg,"
    },
    {
        "line": 46,
        "fullcodeline": "(sctp_paramhdr_t *)((void *)addr_param + length),"
    },
    {
        "line": 47,
        "fullcodeline": "(void *)chunk->chunk_end,"
    },
    {
        "line": 49,
        "fullcodeline": "return sctp_sf_violation_paramlen(net, ep, asoc, type, arg,"
    },
    {
        "line": 60,
        "fullcodeline": "if (!chunk->has_asconf)"
    },
    {
        "line": 73,
        "fullcodeline": "if (!asconf_ack)"
    },
    {
        "line": 42,
        "fullcodeline": "(void *)addr_param, commands);"
    },
    {
        "line": 50,
        "fullcodeline": "(void *)err_param, commands);"
    },
    {
        "line": 61,
        "fullcodeline": "sctp_assoc_clean_asconf_ack_cache(asoc);"
    },
    {
        "line": 75,
        "fullcodeline": "} else if (serial < asoc->peer.addip_serial + 1) {"
    },
    {
        "line": 88,
        "fullcodeline": "asconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);"
    },
    {
        "line": 96,
        "fullcodeline": "asconf_ack->transport = NULL;"
    },
    {
        "line": 89,
        "fullcodeline": "if (!asconf_ack)"
    }
]