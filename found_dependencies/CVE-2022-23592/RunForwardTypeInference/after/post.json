[
    {
        "line": 2,
        "fullcodeline": "VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();"
    },
    {
        "line": 8,
        "fullcodeline": "std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);"
    },
    {
        "line": 9,
        "fullcodeline": "std::vector<int> input_idx(props_->input_types.size(), 0);"
    },
    {
        "line": 32,
        "fullcodeline": "static FullTypeDef* no_type = new FullTypeDef();"
    },
    {
        "line": 62,
        "fullcodeline": "const auto infer_type = props_->fwd_type_fn(input_types);"
    },
    {
        "line": 63,
        "fullcodeline": "const FullTypeDef infer_typedef = infer_type.ValueOrDie();"
    },
    {
        "line": 4,
        "fullcodeline": "if (props_->fwd_type_fn == nullptr) {"
    },
    {
        "line": 35,
        "fullcodeline": "for (int i = 0; i < input_nodes.size(); i++) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (infer_typedef.type_id() != TFT_UNSET) {"
    },
    {
        "line": 14,
        "fullcodeline": "DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();"
    },
    {
        "line": 15,
        "fullcodeline": "int i = edge->dst_input();"
    },
    {
        "line": 16,
        "fullcodeline": "input_nodes.at(i) = edge->src();"
    },
    {
        "line": 17,
        "fullcodeline": "input_idx.at(i) = edge->src_output();"
    },
    {
        "line": 36,
        "fullcodeline": "const auto* node = input_nodes[i];"
    },
    {
        "line": 65,
        "fullcodeline": "MaybeCopyOnWrite();"
    },
    {
        "line": 66,
        "fullcodeline": "*(props_->node_def.mutable_experimental_type()) = infer_typedef;"
    },
    {
        "line": 11,
        "fullcodeline": "if (edge->IsControlEdge()) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (node == nullptr) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (node->def().has_experimental_type()) {"
    },
    {
        "line": 27,
        "fullcodeline": "ClearTypeInfo();"
    },
    {
        "line": 38,
        "fullcodeline": "const auto& node_t = node->def().experimental_type();"
    },
    {
        "line": 39,
        "fullcodeline": "if (node_t.type_id() != TFT_UNSET) {"
    },
    {
        "line": 57,
        "fullcodeline": "ClearTypeInfo();"
    },
    {
        "line": 40,
        "fullcodeline": "int ix = input_idx[i];"
    },
    {
        "line": 51,
        "fullcodeline": "input_types.emplace_back(node_t.args(ix));"
    },
    {
        "line": 41,
        "fullcodeline": "if (ix >= node_t.args_size()) {"
    },
    {
        "line": 53,
        "fullcodeline": "input_types.emplace_back(*no_type);"
    },
    {
        "line": 42,
        "fullcodeline": "LOG(WARNING) << name() << \" has bad type information: input \" << i"
    },
    {
        "line": 48,
        "fullcodeline": "ClearTypeInfo();"
    },
    {
        "line": 45,
        "fullcodeline": "<< \" outputs: \" << node_t.DebugString()"
    },
    {
        "line": 44,
        "fullcodeline": "<< \" but instead only has \" << node_t.args_size()"
    }
]