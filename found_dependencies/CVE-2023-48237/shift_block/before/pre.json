[
    {
        "line": 3,
        "fullcodeline": "int\t\t\tleft = (oap->op_type == OP_LSHIFT);"
    },
    {
        "line": 4,
        "fullcodeline": "int\t\t\toldstate = State;"
    },
    {
        "line": 7,
        "fullcodeline": "int\t\t\toldcol = curwin->w_cursor.col;"
    },
    {
        "line": 8,
        "fullcodeline": "int\t\t\tsw_val = (int)get_sw_value_indent(curbuf);"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\t\tts_val = (int)curbuf->b_p_ts;"
    },
    {
        "line": 22,
        "fullcodeline": "State = MODE_INSERT;\t// don't want MODE_REPLACE for State"
    },
    {
        "line": 23,
        "fullcodeline": "block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);"
    },
    {
        "line": 28,
        "fullcodeline": "total = (int)((unsigned)amount * (unsigned)sw_val);"
    },
    {
        "line": 32,
        "fullcodeline": "oldp = ml_get_curline();"
    },
    {
        "line": 202,
        "fullcodeline": "added = new_line_len - (int)STRLEN(oldp);"
    },
    {
        "line": 203,
        "fullcodeline": "ml_replace(curwin->w_cursor.lnum, newp, FALSE);"
    },
    {
        "line": 29,
        "fullcodeline": "if ((total / sw_val) != amount)"
    },
    {
        "line": 36,
        "fullcodeline": "int\t\ttabs = 0, spaces = 0;"
    },
    {
        "line": 45,
        "fullcodeline": "total += bd.pre_whitesp; // all virtual WS up to & incl a split TAB"
    },
    {
        "line": 46,
        "fullcodeline": "ws_vcol = bd.start_vcol - bd.pre_whitesp;"
    },
    {
        "line": 64,
        "fullcodeline": "init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum,"
    },
    {
        "line": 72,
        "fullcodeline": "bd.textstart = cts.cts_ptr;"
    },
    {
        "line": 93,
        "fullcodeline": "bd.textcol -= bd.pre_whitesp_c - (bd.startspaces != 0);"
    },
    {
        "line": 95,
        "fullcodeline": "new_line_len = bd.textcol + tabs + spaces + (int)STRLEN(bd.textstart);"
    },
    {
        "line": 96,
        "fullcodeline": "newp = alloc(new_line_len + 1);"
    },
    {
        "line": 99,
        "fullcodeline": "mch_memmove(newp, oldp, (size_t)bd.textcol);"
    },
    {
        "line": 100,
        "fullcodeline": "vim_memset(newp + bd.textcol, TAB, (size_t)tabs);"
    },
    {
        "line": 66,
        "fullcodeline": "for ( ; VIM_ISWHITE(*cts.cts_ptr); )"
    },
    {
        "line": 87,
        "fullcodeline": "if (tabs > 0)"
    },
    {
        "line": 97,
        "fullcodeline": "if (newp == NULL)"
    },
    {
        "line": 116,
        "fullcodeline": "char_u\t    *non_white = bd.textstart;"
    },
    {
        "line": 135,
        "fullcodeline": "non_white_col = bd.start_vcol;"
    },
    {
        "line": 137,
        "fullcodeline": "init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum,"
    },
    {
        "line": 144,
        "fullcodeline": "non_white_col = cts.cts_vcol;"
    },
    {
        "line": 145,
        "fullcodeline": "non_white = cts.cts_ptr;"
    },
    {
        "line": 146,
        "fullcodeline": "clear_chartabsize_arg(&cts);"
    },
    {
        "line": 148,
        "fullcodeline": "block_space_width = non_white_col - oap->start_vcol;"
    },
    {
        "line": 150,
        "fullcodeline": "shift_amount = (block_space_width < (size_t)total"
    },
    {
        "line": 154,
        "fullcodeline": "destination_col = (colnr_T)(non_white_col - shift_amount);"
    },
    {
        "line": 158,
        "fullcodeline": "verbatim_copy_end = bd.textstart;"
    },
    {
        "line": 159,
        "fullcodeline": "verbatim_copy_width = bd.start_vcol;"
    },
    {
        "line": 166,
        "fullcodeline": "init_chartabsize_arg(&cts, curwin, 0, verbatim_copy_width,"
    },
    {
        "line": 176,
        "fullcodeline": "verbatim_copy_width = cts.cts_vcol;"
    },
    {
        "line": 177,
        "fullcodeline": "verbatim_copy_end = cts.cts_ptr;"
    },
    {
        "line": 183,
        "fullcodeline": "fill = destination_col - verbatim_copy_width;"
    },
    {
        "line": 189,
        "fullcodeline": "new_line_len = (unsigned)(verbatim_copy_end - oldp)"
    },
    {
        "line": 193,
        "fullcodeline": "newp = alloc(new_line_len + 1);"
    },
    {
        "line": 196,
        "fullcodeline": "mch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));"
    },
    {
        "line": 68,
        "fullcodeline": "incr = lbr_chartabsize_adv(&cts);"
    },
    {
        "line": 69,
        "fullcodeline": "total += incr;"
    },
    {
        "line": 70,
        "fullcodeline": "cts.cts_vcol += incr;"
    },
    {
        "line": 86,
        "fullcodeline": "tabs = ((ws_vcol % ts_val) + total) / ts_val; // number of tabs"
    },
    {
        "line": 88,
        "fullcodeline": "spaces = ((ws_vcol % ts_val) + total) % ts_val; // number of spp"
    },
    {
        "line": 139,
        "fullcodeline": "while (VIM_ISWHITE(*cts.cts_ptr))"
    },
    {
        "line": 168,
        "fullcodeline": "while (cts.cts_vcol < destination_col)"
    },
    {
        "line": 194,
        "fullcodeline": "if (newp == NULL)"
    },
    {
        "line": 90,
        "fullcodeline": "spaces = total;"
    },
    {
        "line": 132,
        "fullcodeline": "MB_PTR_ADV(non_white);"
    },
    {
        "line": 141,
        "fullcodeline": "incr = lbr_chartabsize_adv(&cts);"
    },
    {
        "line": 142,
        "fullcodeline": "cts.cts_vcol += incr;"
    },
    {
        "line": 165,
        "fullcodeline": "verbatim_copy_width -= bd.start_char_vcols;"
    },
    {
        "line": 170,
        "fullcodeline": "incr = lbr_chartabsize(&cts);"
    },
    {
        "line": 173,
        "fullcodeline": "cts.cts_vcol += incr;"
    },
    {
        "line": 174,
        "fullcodeline": "MB_PTR_ADV(cts.cts_ptr);"
    },
    {
        "line": 197,
        "fullcodeline": "vim_memset(newp + (verbatim_copy_end - oldp), ' ', (size_t)fill);"
    },
    {
        "line": 171,
        "fullcodeline": "if (cts.cts_vcol + incr > destination_col)"
    },
    {
        "line": 191,
        "fullcodeline": "+ (unsigned)STRLEN(non_white);"
    },
    {
        "line": 199,
        "fullcodeline": "STRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);"
    },
    {
        "line": 60,
        "fullcodeline": "++bd.textstart;"
    },
    {
        "line": 51,
        "fullcodeline": "if ((*mb_ptr2len)(bd.textstart) == 1)"
    },
    {
        "line": 52,
        "fullcodeline": "++bd.textstart;"
    },
    {
        "line": 55,
        "fullcodeline": "ws_vcol = 0;"
    },
    {
        "line": 56,
        "fullcodeline": "bd.startspaces = 0;"
    }
]