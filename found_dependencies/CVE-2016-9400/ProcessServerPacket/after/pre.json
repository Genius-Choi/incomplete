[
    {
        "line": 4,
        "fullcodeline": "Unpacker.Reset(pPacket->m_pData, pPacket->m_DataSize);"
    },
    {
        "line": 7,
        "fullcodeline": "int Msg = Unpacker.GetInt();"
    },
    {
        "line": 8,
        "fullcodeline": "int Sys = Msg&1;"
    },
    {
        "line": 9,
        "fullcodeline": "Msg >>= 1;"
    },
    {
        "line": 11,
        "fullcodeline": "if(Unpacker.Error())"
    },
    {
        "line": 17,
        "fullcodeline": "if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_CHANGE)"
    },
    {
        "line": 19,
        "fullcodeline": "const char *pMap = Unpacker.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES);"
    },
    {
        "line": 20,
        "fullcodeline": "int MapCrc = Unpacker.GetInt();"
    },
    {
        "line": 21,
        "fullcodeline": "int MapSize = Unpacker.GetInt();"
    },
    {
        "line": 22,
        "fullcodeline": "const char *pError = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "if(MapSize < 0)"
    },
    {
        "line": 391,
        "fullcodeline": "if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0)"
    },
    {
        "line": 28,
        "fullcodeline": "if(!m_MapChecker.IsMapValid(pMap, MapCrc, MapSize))"
    },
    {
        "line": 29,
        "fullcodeline": "pError = \"invalid standard map\";"
    },
    {
        "line": 31,
        "fullcodeline": "for(int i = 0; pMap[i]; i++) // protect the player from nasty map names"
    },
    {
        "line": 38,
        "fullcodeline": "pError = \"invalid map size\";"
    },
    {
        "line": 394,
        "fullcodeline": "if(m_DemoRecorder.IsRecording())"
    },
    {
        "line": 44,
        "fullcodeline": "pError = LoadMapSearch(pMap, MapCrc);"
    },
    {
        "line": 80,
        "fullcodeline": "else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_DATA)"
    },
    {
        "line": 83,
        "fullcodeline": "int MapCRC = Unpacker.GetInt();"
    },
    {
        "line": 84,
        "fullcodeline": "int Chunk = Unpacker.GetInt();"
    },
    {
        "line": 85,
        "fullcodeline": "int Size = Unpacker.GetInt();"
    },
    {
        "line": 86,
        "fullcodeline": "const unsigned char *pData = Unpacker.GetRaw(Size);"
    },
    {
        "line": 92,
        "fullcodeline": "io_write(m_MapdownloadFile, pData, Size);"
    },
    {
        "line": 33,
        "fullcodeline": "if(pMap[i] == '/' || pMap[i] == '\\\\')"
    },
    {
        "line": 34,
        "fullcodeline": "pError = \"strange character in map name\";"
    },
    {
        "line": 82,
        "fullcodeline": "int Last = Unpacker.GetInt();"
    },
    {
        "line": 89,
        "fullcodeline": "if(Unpacker.Error() || Size <= 0 || MapCRC != m_MapdownloadCrc || Chunk != m_MapdownloadChunk || !m_MapdownloadFile)"
    },
    {
        "line": 99,
        "fullcodeline": "m_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", \"download complete, loading map\");"
    },
    {
        "line": 108,
        "fullcodeline": "pError = LoadMap(m_aMapdownloadName, m_aMapdownloadFilename, m_MapdownloadCrc);"
    },
    {
        "line": 53,
        "fullcodeline": "str_format(m_aMapdownloadFilename, sizeof(m_aMapdownloadFilename), \"downloadedmaps/%s_%08x.map\", pMap, MapCrc);"
    },
    {
        "line": 56,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"starting to download map to '%s'\", m_aMapdownloadFilename);"
    },
    {
        "line": 57,
        "fullcodeline": "m_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, \"client/network\", aBuf);"
    },
    {
        "line": 59,
        "fullcodeline": "m_MapdownloadChunk = 0;"
    },
    {
        "line": 69,
        "fullcodeline": "Msg.AddInt(m_MapdownloadChunk);"
    },
    {
        "line": 105,
        "fullcodeline": "m_MapdownloadTotalsize = -1;"
    },
    {
        "line": 109,
        "fullcodeline": "if(!pError)"
    },
    {
        "line": 120,
        "fullcodeline": "m_MapdownloadChunk++;"
    },
    {
        "line": 123,
        "fullcodeline": "Msg.AddInt(m_MapdownloadChunk);"
    },
    {
        "line": 134,
        "fullcodeline": "else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_CON_READY)"
    },
    {
        "line": 55,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 63,
        "fullcodeline": "m_MapdownloadFile = Storage()->OpenFile(m_aMapdownloadFilename, IOFLAG_WRITE, IStorage::TYPE_SAVE);"
    },
    {
        "line": 70,
        "fullcodeline": "SendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);"
    },
    {
        "line": 124,
        "fullcodeline": "SendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH);"
    },
    {
        "line": 74,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"requested chunk %d\", m_MapdownloadChunk);"
    },
    {
        "line": 129,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"requested chunk %d\", m_MapdownloadChunk);"
    },
    {
        "line": 138,
        "fullcodeline": "else if(Msg == NETMSG_PING)"
    },
    {
        "line": 128,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 143,
        "fullcodeline": "else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_ADD)"
    },
    {
        "line": 145,
        "fullcodeline": "const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 146,
        "fullcodeline": "const char *pHelp = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 147,
        "fullcodeline": "const char *pParams = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 148,
        "fullcodeline": "if(Unpacker.Error() == 0)"
    },
    {
        "line": 149,
        "fullcodeline": "m_pConsole->RegisterTemp(pName, pParams, CFGFLAG_SERVER, pHelp);"
    },
    {
        "line": 151,
        "fullcodeline": "else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_REM)"
    },
    {
        "line": 153,
        "fullcodeline": "const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC);"
    },
    {
        "line": 154,
        "fullcodeline": "if(Unpacker.Error() == 0)"
    },
    {
        "line": 157,
        "fullcodeline": "else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_STATUS)"
    },
    {
        "line": 159,
        "fullcodeline": "int Result = Unpacker.GetInt();"
    },
    {
        "line": 162,
        "fullcodeline": "int Old = m_UseTempRconCommands;"
    },
    {
        "line": 163,
        "fullcodeline": "m_UseTempRconCommands = Unpacker.GetInt();"
    },
    {
        "line": 160,
        "fullcodeline": "if(Unpacker.Error() == 0)"
    },
    {
        "line": 161,
        "fullcodeline": "m_RconAuthed = Result;"
    },
    {
        "line": 164,
        "fullcodeline": "if(Unpacker.Error() != 0)"
    },
    {
        "line": 165,
        "fullcodeline": "m_UseTempRconCommands = 0;"
    },
    {
        "line": 166,
        "fullcodeline": "if(Old != 0 && m_UseTempRconCommands == 0)"
    },
    {
        "line": 169,
        "fullcodeline": "else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_LINE)"
    },
    {
        "line": 171,
        "fullcodeline": "const char *pLine = Unpacker.GetString();"
    },
    {
        "line": 172,
        "fullcodeline": "if(Unpacker.Error() == 0)"
    },
    {
        "line": 175,
        "fullcodeline": "else if(Msg == NETMSG_PING_REPLY)"
    },
    {
        "line": 178,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"latency %.2f\", (time_get() - m_PingStartTime)*1000 / (float)time_freq());"
    },
    {
        "line": 177,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 181,
        "fullcodeline": "else if(Msg == NETMSG_INPUTTIMING)"
    },
    {
        "line": 183,
        "fullcodeline": "int InputPredTick = Unpacker.GetInt();"
    },
    {
        "line": 184,
        "fullcodeline": "int TimeLeft = Unpacker.GetInt();"
    },
    {
        "line": 187,
        "fullcodeline": "int64 Target = 0;"
    },
    {
        "line": 188,
        "fullcodeline": "for(int k = 0; k < 200; k++)"
    },
    {
        "line": 201,
        "fullcodeline": "else if(Msg == NETMSG_SNAP || Msg == NETMSG_SNAPSINGLE || Msg == NETMSG_SNAPEMPTY)"
    },
    {
        "line": 203,
        "fullcodeline": "int NumParts = 1;"
    },
    {
        "line": 204,
        "fullcodeline": "int Part = 0;"
    },
    {
        "line": 205,
        "fullcodeline": "int GameTick = Unpacker.GetInt();"
    },
    {
        "line": 206,
        "fullcodeline": "int DeltaTick = GameTick-Unpacker.GetInt();"
    },
    {
        "line": 207,
        "fullcodeline": "int PartSize = 0;"
    },
    {
        "line": 208,
        "fullcodeline": "int Crc = 0;"
    },
    {
        "line": 228,
        "fullcodeline": "pData = (const char *)Unpacker.GetRaw(PartSize);"
    },
    {
        "line": 192,
        "fullcodeline": "Target = m_aInputs[k].m_PredictedTime + (time_get() - m_aInputs[k].m_Time);"
    },
    {
        "line": 193,
        "fullcodeline": "Target = Target - (int64)(((TimeLeft-PREDICTION_MARGIN)/1000.0f)*time_freq());"
    },
    {
        "line": 216,
        "fullcodeline": "if(Msg == NETMSG_SNAP)"
    },
    {
        "line": 222,
        "fullcodeline": "if(Msg != NETMSG_SNAPEMPTY)"
    },
    {
        "line": 233,
        "fullcodeline": "if(GameTick >= m_CurrentRecvTick)"
    },
    {
        "line": 218,
        "fullcodeline": "NumParts = Unpacker.GetInt();"
    },
    {
        "line": 219,
        "fullcodeline": "Part = Unpacker.GetInt();"
    },
    {
        "line": 224,
        "fullcodeline": "Crc = Unpacker.GetInt();"
    },
    {
        "line": 225,
        "fullcodeline": "PartSize = Unpacker.GetInt();"
    },
    {
        "line": 230,
        "fullcodeline": "if(Unpacker.Error() || NumParts < 1 || NumParts > CSnapshot::MAX_PARTS || Part < 0 | Part >= NumParts || PartSize < 0 || PartSize > MAX_SNAPSHOT_PACKSIZE)"
    },
    {
        "line": 242,
        "fullcodeline": "mem_copy((char*)m_aSnapshotIncommingData + Part*MAX_SNAPSHOT_PACKSIZE, pData, PartSize);"
    },
    {
        "line": 243,
        "fullcodeline": "m_SnapshotParts |= 1<<Part;"
    },
    {
        "line": 235,
        "fullcodeline": "if(GameTick != m_CurrentRecvTick)"
    },
    {
        "line": 237,
        "fullcodeline": "m_SnapshotParts = 0;"
    },
    {
        "line": 248,
        "fullcodeline": "CSnapshot *pDeltaShot = &Emptysnap;"
    },
    {
        "line": 252,
        "fullcodeline": "unsigned char aTmpBuffer2[CSnapshot::MAX_SIZE];"
    },
    {
        "line": 253,
        "fullcodeline": "unsigned char aTmpBuffer3[CSnapshot::MAX_SIZE];"
    },
    {
        "line": 254,
        "fullcodeline": "CSnapshot *pTmpBuffer3 = (CSnapshot*)aTmpBuffer3;\t// Fix compiler warning for strict-aliasing"
    },
    {
        "line": 257,
        "fullcodeline": "CompleteSize = (NumParts-1) * MAX_SNAPSHOT_PACKSIZE + PartSize;"
    },
    {
        "line": 289,
        "fullcodeline": "pDeltaData = m_SnapshotDelta.EmptyDelta();"
    },
    {
        "line": 290,
        "fullcodeline": "DeltaSize = sizeof(int)*3;"
    },
    {
        "line": 304,
        "fullcodeline": "SnapSize = m_SnapshotDelta.UnpackDelta(pDeltaShot, pTmpBuffer3, pDeltaData, DeltaSize);"
    },
    {
        "line": 338,
        "fullcodeline": "PurgeTick = DeltaTick;"
    },
    {
        "line": 343,
        "fullcodeline": "m_SnapshotStorage.PurgeUntil(PurgeTick);"
    },
    {
        "line": 346,
        "fullcodeline": "m_SnapshotStorage.Add(GameTick, time_get(), SnapSize, pTmpBuffer3, 1);"
    },
    {
        "line": 356,
        "fullcodeline": "m_RecivedSnapshots++;"
    },
    {
        "line": 245,
        "fullcodeline": "if(m_SnapshotParts == (unsigned)((1<<NumParts)-1))"
    },
    {
        "line": 266,
        "fullcodeline": "if(DeltaTick >= 0)"
    },
    {
        "line": 305,
        "fullcodeline": "if(SnapSize < 0)"
    },
    {
        "line": 349,
        "fullcodeline": "if(m_DemoRecorder.IsRecording())"
    },
    {
        "line": 361,
        "fullcodeline": "if(m_RecivedSnapshots == 2)"
    },
    {
        "line": 268,
        "fullcodeline": "int DeltashotSize = m_SnapshotStorage.Get(DeltaTick, 0, &pDeltaShot, 0);"
    },
    {
        "line": 294,
        "fullcodeline": "int IntSize = CVariableInt::Decompress(m_aSnapshotIncommingData, CompleteSize, aTmpBuffer2);"
    },
    {
        "line": 299,
        "fullcodeline": "pDeltaData = aTmpBuffer2;"
    },
    {
        "line": 300,
        "fullcodeline": "DeltaSize = IntSize;"
    },
    {
        "line": 311,
        "fullcodeline": "if(Msg != NETMSG_SNAPEMPTY && pTmpBuffer3->Crc() != Crc)"
    },
    {
        "line": 321,
        "fullcodeline": "m_SnapCrcErrors++;"
    },
    {
        "line": 339,
        "fullcodeline": "if(m_aSnapshots[SNAP_PREV] && m_aSnapshots[SNAP_PREV]->m_Tick < PurgeTick)"
    },
    {
        "line": 340,
        "fullcodeline": "PurgeTick = m_aSnapshots[SNAP_PREV]->m_Tick;"
    },
    {
        "line": 341,
        "fullcodeline": "if(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_CURRENT]->m_Tick < PurgeTick)"
    },
    {
        "line": 342,
        "fullcodeline": "PurgeTick = m_aSnapshots[SNAP_CURRENT]->m_Tick;"
    },
    {
        "line": 352,
        "fullcodeline": "m_DemoRecorder.RecordSnapshot(GameTick, pTmpBuffer3, SnapSize);"
    },
    {
        "line": 364,
        "fullcodeline": "m_PredictedTime.Init(GameTick*time_freq()/50);"
    },
    {
        "line": 366,
        "fullcodeline": "m_GameTime.Init((GameTick-1)*time_freq()/50);"
    },
    {
        "line": 369,
        "fullcodeline": "m_LocalStartTime = time_get();"
    },
    {
        "line": 377,
        "fullcodeline": "int64 Now = m_GameTime.Get(time_get());"
    },
    {
        "line": 378,
        "fullcodeline": "int64 TickStart = GameTick*time_freq()/50;"
    },
    {
        "line": 379,
        "fullcodeline": "int64 TimeLeft = (TickStart-Now)*1000 / time_freq();"
    },
    {
        "line": 296,
        "fullcodeline": "if(IntSize < 0) // failure during decompression, bail"
    },
    {
        "line": 380,
        "fullcodeline": "m_GameTime.Update(&m_GametimeMarginGraph, (GameTick-1)*time_freq()/50, TimeLeft, 0);"
    },
    {
        "line": 316,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"snapshot crc error #%d - tick=%d wantedcrc=%d gotcrc=%d compressed_size=%d delta_tick=%d\","
    },
    {
        "line": 283,
        "fullcodeline": "m_AckGameTick = -1;"
    },
    {
        "line": 315,
        "fullcodeline": "char aBuf[256];"
    },
    {
        "line": 317,
        "fullcodeline": "m_SnapCrcErrors, GameTick, Crc, pTmpBuffer3->Crc(), CompleteSize, DeltaTick);"
    },
    {
        "line": 325,
        "fullcodeline": "m_AckGameTick = -1;"
    },
    {
        "line": 277,
        "fullcodeline": "str_format(aBuf, sizeof(aBuf), \"error, couldn't find the delta snapshot\");"
    },
    {
        "line": 276,
        "fullcodeline": "char aBuf[256];"
    }
]