[
    {
        "line": 2,
        "fullcodeline": "decoder_info->width = get_flc(16, stream);"
    },
    {
        "line": 3,
        "fullcodeline": "decoder_info->height = get_flc(16, stream);"
    },
    {
        "line": 4,
        "fullcodeline": "decoder_info->log2_sb_size = get_flc(3, stream);"
    },
    {
        "line": 5,
        "fullcodeline": "decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));"
    },
    {
        "line": 6,
        "fullcodeline": "decoder_info->pb_split = get_flc(1, stream);"
    },
    {
        "line": 7,
        "fullcodeline": "decoder_info->tb_split_enable = get_flc(1, stream);"
    },
    {
        "line": 8,
        "fullcodeline": "decoder_info->max_num_ref = get_flc(2, stream) + 1;"
    },
    {
        "line": 9,
        "fullcodeline": "decoder_info->interp_ref = get_flc(2, stream);"
    },
    {
        "line": 10,
        "fullcodeline": "decoder_info->max_delta_qp = get_flc(1, stream);"
    },
    {
        "line": 11,
        "fullcodeline": "decoder_info->deblocking = get_flc(1, stream);"
    },
    {
        "line": 12,
        "fullcodeline": "decoder_info->clpf = get_flc(1, stream);"
    },
    {
        "line": 13,
        "fullcodeline": "decoder_info->use_block_contexts = get_flc(1, stream);"
    },
    {
        "line": 14,
        "fullcodeline": "decoder_info->bipred = get_flc(2, stream);"
    },
    {
        "line": 15,
        "fullcodeline": "decoder_info->qmtx = get_flc(1, stream);"
    },
    {
        "line": 19,
        "fullcodeline": "decoder_info->subsample = get_flc(2, stream);"
    },
    {
        "line": 20,
        "fullcodeline": "decoder_info->subsample = // 0: 400  1: 420  2: 422  3: 444"
    },
    {
        "line": 23,
        "fullcodeline": "decoder_info->num_reorder_pics = get_flc(4, stream);"
    },
    {
        "line": 28,
        "fullcodeline": "decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;"
    },
    {
        "line": 31,
        "fullcodeline": "decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;"
    },
    {
        "line": 21,
        "fullcodeline": "(decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +"
    },
    {
        "line": 24,
        "fullcodeline": "if (decoder_info->subsample != 400) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (decoder_info->bitdepth == 10)"
    },
    {
        "line": 32,
        "fullcodeline": "if (decoder_info->input_bitdepth == 10)"
    },
    {
        "line": 17,
        "fullcodeline": "decoder_info->qmtx_offset = get_flc(6, stream) - 32;"
    },
    {
        "line": 25,
        "fullcodeline": "decoder_info->cfl_intra = get_flc(1, stream);"
    },
    {
        "line": 26,
        "fullcodeline": "decoder_info->cfl_inter = get_flc(1, stream);"
    },
    {
        "line": 30,
        "fullcodeline": "decoder_info->bitdepth += 2 * get_flc(1, stream);"
    },
    {
        "line": 33,
        "fullcodeline": "decoder_info->input_bitdepth += 2 * get_flc(1, stream);"
    },
    {
        "line": 22,
        "fullcodeline": "((decoder_info->subsample & 3) == 3) * 2 + 400;"
    }
]