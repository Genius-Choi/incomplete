[
    {
        "line": 4,
        "fullcodeline": "struct tw5864_input *input = frame->input;"
    },
    {
        "line": 5,
        "fullcodeline": "struct tw5864_dev *dev = input->root;"
    },
    {
        "line": 8,
        "fullcodeline": "int frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;"
    },
    {
        "line": 9,
        "fullcodeline": "u8 *dst = input->buf_cur_ptr;"
    },
    {
        "line": 10,
        "fullcodeline": "u8 tail_mask, vlc_mask = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "u8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];"
    },
    {
        "line": 25,
        "fullcodeline": "spin_lock_irqsave(&input->slock, flags);"
    },
    {
        "line": 26,
        "fullcodeline": "vb = input->vb;"
    },
    {
        "line": 27,
        "fullcodeline": "input->vb = NULL;"
    },
    {
        "line": 28,
        "fullcodeline": "spin_unlock_irqrestore(&input->slock, flags);"
    },
    {
        "line": 30,
        "fullcodeline": "v4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);"
    },
    {
        "line": 50,
        "fullcodeline": "tail_mask = (~vlc_mask) & 0xff;"
    },
    {
        "line": 52,
        "fullcodeline": "dst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);"
    },
    {
        "line": 53,
        "fullcodeline": "frame_len--;"
    },
    {
        "line": 54,
        "fullcodeline": "dst++;"
    },
    {
        "line": 57,
        "fullcodeline": "src = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;"
    },
    {
        "line": 58,
        "fullcodeline": "src_end = src + frame_len;"
    },
    {
        "line": 59,
        "fullcodeline": "zero_run = 0;"
    },
    {
        "line": 74,
        "fullcodeline": "vb2_set_plane_payload(&vb->vb.vb2_buf, 0,"
    },
    {
        "line": 77,
        "fullcodeline": "vb->vb.vb2_buf.timestamp = frame->timestamp;"
    },
    {
        "line": 78,
        "fullcodeline": "v4l2_buf->field = V4L2_FIELD_INTERLACED;"
    },
    {
        "line": 79,
        "fullcodeline": "v4l2_buf->sequence = frame->seqno;"
    },
    {
        "line": 95,
        "fullcodeline": "vb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);"
    },
    {
        "line": 32,
        "fullcodeline": "if (!vb) { /* Gone because of disabling */"
    },
    {
        "line": 41,
        "fullcodeline": "if (input->buf_cur_space_left < frame_len * 5 / 4) {"
    },
    {
        "line": 48,
        "fullcodeline": "for (i = 0; i < 8 - input->tail_nb_bits; i++)"
    },
    {
        "line": 49,
        "fullcodeline": "vlc_mask |= 1 << i;"
    },
    {
        "line": 60,
        "fullcodeline": "for (; src < src_end; src++) {"
    },
    {
        "line": 75,
        "fullcodeline": "dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));"
    },
    {
        "line": 33,
        "fullcodeline": "dev_dbg(&dev->pci->dev, \"vb is empty, dropping frame\\n\");"
    },
    {
        "line": 83,
        "fullcodeline": "tw5864_is_motion_triggered(frame)) {"
    },
    {
        "line": 84,
        "fullcodeline": "struct v4l2_event ev = {"
    },
    {
        "line": 61,
        "fullcodeline": "if (zero_run < 2) {"
    },
    {
        "line": 71,
        "fullcodeline": "*dst++ = *src;"
    },
    {
        "line": 62,
        "fullcodeline": "if (*src == 0)"
    },
    {
        "line": 69,
        "fullcodeline": "zero_run = *src == 0;"
    },
    {
        "line": 85,
        "fullcodeline": ".type = V4L2_EVENT_MOTION_DET,"
    },
    {
        "line": 86,
        "fullcodeline": ".u.motion_det = {"
    },
    {
        "line": 63,
        "fullcodeline": "++zero_run;"
    },
    {
        "line": 65,
        "fullcodeline": "zero_run = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "if ((*src & ~0x03) == 0)"
    },
    {
        "line": 87,
        "fullcodeline": ".flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,"
    },
    {
        "line": 88,
        "fullcodeline": ".frame_sequence = v4l2_buf->sequence,"
    },
    {
        "line": 68,
        "fullcodeline": "*dst++ = 0x03;"
    }
]