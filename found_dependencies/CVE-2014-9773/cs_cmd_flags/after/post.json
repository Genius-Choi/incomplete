[
    {
        "line": 5,
        "fullcodeline": "char *channel = parv[0];"
    },
    {
        "line": 6,
        "fullcodeline": "char *target = sstrdup(parv[1]);"
    },
    {
        "line": 7,
        "fullcodeline": "char *flagstr = parv[2];"
    },
    {
        "line": 20,
        "fullcodeline": "mc = mychan_find(channel);"
    },
    {
        "line": 334,
        "fullcodeline": "free(target);"
    },
    {
        "line": 13,
        "fullcodeline": "if (parc < 1)"
    },
    {
        "line": 21,
        "fullcodeline": "if (!mc)"
    },
    {
        "line": 27,
        "fullcodeline": "if (metadata_find(mc, \"private:close:closer\") && (target || !has_priv(si, PRIV_CHAN_AUSPEX)))"
    },
    {
        "line": 33,
        "fullcodeline": "if (!target || (target && target[0] == '+' && flagstr == NULL))"
    },
    {
        "line": 163,
        "fullcodeline": "restrictflags = chanacs_source_flags(mc, si);"
    },
    {
        "line": 328,
        "fullcodeline": "flagstr = bitmask_to_flags2(addflags, removeflags);"
    },
    {
        "line": 329,
        "fullcodeline": "command_success_nodata(si, _(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\"), flagstr, target, channel);"
    },
    {
        "line": 330,
        "fullcodeline": "logcommand(si, CMDLOG_SET, \"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\", mc->name, target, flagstr);"
    },
    {
        "line": 331,
        "fullcodeline": "verbose(mc, \"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\", get_source_name(si), flagstr, target);"
    },
    {
        "line": 15,
        "fullcodeline": "command_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");"
    },
    {
        "line": 16,
        "fullcodeline": "command_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <channel> [target] [flags]\"));"
    },
    {
        "line": 23,
        "fullcodeline": "command_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);"
    },
    {
        "line": 29,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), channel);"
    },
    {
        "line": 35,
        "fullcodeline": "unsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0;"
    },
    {
        "line": 37,
        "fullcodeline": "do_list(si, mc, flags);"
    },
    {
        "line": 122,
        "fullcodeline": "if (!si->smu)"
    },
    {
        "line": 128,
        "fullcodeline": "if (!flagstr)"
    },
    {
        "line": 164,
        "fullcodeline": "if (restrictflags & CA_FOUNDER)"
    },
    {
        "line": 187,
        "fullcodeline": "if (*flagstr == '+' || *flagstr == '-' || *flagstr == '=')"
    },
    {
        "line": 211,
        "fullcodeline": "if (!validhostmask(target))"
    },
    {
        "line": 323,
        "fullcodeline": "if ((addflags | removeflags) == 0)"
    },
    {
        "line": 124,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You are not logged in.\"));"
    },
    {
        "line": 158,
        "fullcodeline": "logcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2 on \\2%s\\2\", mc->name, target);"
    },
    {
        "line": 165,
        "fullcodeline": "restrictflags = ca_all;"
    },
    {
        "line": 189,
        "fullcodeline": "flags_make_bitmasks(flagstr, &addflags, &removeflags);"
    },
    {
        "line": 218,
        "fullcodeline": "free(target);"
    },
    {
        "line": 219,
        "fullcodeline": "target = sstrdup(mt->name);"
    },
    {
        "line": 221,
        "fullcodeline": "ca = chanacs_open(mc, mt, NULL, true, entity(si->smu));"
    },
    {
        "line": 276,
        "fullcodeline": "req.ca = ca;"
    },
    {
        "line": 277,
        "fullcodeline": "req.oldlevel = ca->level;"
    },
    {
        "line": 286,
        "fullcodeline": "req.newlevel = ca->level;"
    },
    {
        "line": 288,
        "fullcodeline": "hook_call_channel_acl_change(&req);"
    },
    {
        "line": 289,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 325,
        "fullcodeline": "command_fail(si, fault_nochange, _(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\"), channel, target);"
    },
    {
        "line": 68,
        "fullcodeline": "else if (anope_flags_compat && !strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)"
    },
    {
        "line": 130,
        "fullcodeline": "if (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))"
    },
    {
        "line": 135,
        "fullcodeline": "if (validhostmask(target))"
    },
    {
        "line": 148,
        "fullcodeline": "if (ca != NULL)"
    },
    {
        "line": 190,
        "fullcodeline": "if (addflags == 0 && removeflags == 0)"
    },
    {
        "line": 198,
        "fullcodeline": "addflags = get_template_flags(mc, flagstr);"
    },
    {
        "line": 208,
        "fullcodeline": "removeflags = ca_all & ~addflags;"
    },
    {
        "line": 213,
        "fullcodeline": "if (!(mt = myentity_find_ext(target)))"
    },
    {
        "line": 223,
        "fullcodeline": "if (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER))"
    },
    {
        "line": 228,
        "fullcodeline": "if (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1)"
    },
    {
        "line": 233,
        "fullcodeline": "if (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER)"
    },
    {
        "line": 254,
        "fullcodeline": "if (addflags & CA_FOUNDER)"
    },
    {
        "line": 262,
        "fullcodeline": "if (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK)))"
    },
    {
        "line": 269,
        "fullcodeline": "if (ca->level == 0 && chanacs_is_table_full(ca))"
    },
    {
        "line": 279,
        "fullcodeline": "if (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))"
    },
    {
        "line": 299,
        "fullcodeline": "ca = chanacs_open(mc, NULL, target, true, entity(si->smu));"
    },
    {
        "line": 307,
        "fullcodeline": "req.ca = ca;"
    },
    {
        "line": 308,
        "fullcodeline": "req.oldlevel = ca->level;"
    },
    {
        "line": 317,
        "fullcodeline": "req.newlevel = ca->level;"
    },
    {
        "line": 319,
        "fullcodeline": "hook_call_channel_acl_change(&req);"
    },
    {
        "line": 320,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 70,
        "fullcodeline": "do_list(si, mc, 0);"
    },
    {
        "line": 71,
        "fullcodeline": "free(target);"
    },
    {
        "line": 132,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));"
    },
    {
        "line": 136,
        "fullcodeline": "ca = chanacs_find_host_literal(mc, target, 0);"
    },
    {
        "line": 150,
        "fullcodeline": "str1 = bitmask_to_flags2(ca->level, 0);"
    },
    {
        "line": 151,
        "fullcodeline": "command_success_string(si, str1, _(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\"),"
    },
    {
        "line": 168,
        "fullcodeline": "if (!(restrictflags & CA_FLAGS))"
    },
    {
        "line": 181,
        "fullcodeline": "if (irccasecmp(target, entity(si->smu)->name))"
    },
    {
        "line": 192,
        "fullcodeline": "command_fail(si, fault_badparams, _(\"No valid flags given, use /%s%s HELP FLAGS for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp);"
    },
    {
        "line": 199,
        "fullcodeline": "if (addflags == 0)"
    },
    {
        "line": 215,
        "fullcodeline": "command_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);"
    },
    {
        "line": 225,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You may not remove a founder's +f access.\"));"
    },
    {
        "line": 230,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You may not remove the last founder.\"));"
    },
    {
        "line": 264,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);"
    },
    {
        "line": 265,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 271,
        "fullcodeline": "command_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);"
    },
    {
        "line": 272,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 281,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name);"
    },
    {
        "line": 282,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 293,
        "fullcodeline": "if (addflags & CA_FOUNDER)"
    },
    {
        "line": 300,
        "fullcodeline": "if (ca->level == 0 && chanacs_is_table_full(ca))"
    },
    {
        "line": 310,
        "fullcodeline": "if (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))"
    },
    {
        "line": 144,
        "fullcodeline": "free(target);"
    },
    {
        "line": 145,
        "fullcodeline": "target = sstrdup(mt->name);"
    },
    {
        "line": 146,
        "fullcodeline": "ca = chanacs_find_literal(mc, mt, 0);"
    },
    {
        "line": 156,
        "fullcodeline": "command_success_string(si, \"\", _(\"No flags for \\2%s\\2 in \\2%s\\2.\"),"
    },
    {
        "line": 182,
        "fullcodeline": "restrictflags = allow_flags(mc, restrictflags);"
    },
    {
        "line": 235,
        "fullcodeline": "if (mychan_num_founders(mc) >= chansvs.maxfounders)"
    },
    {
        "line": 241,
        "fullcodeline": "if (!myentity_can_register_channel(mt))"
    },
    {
        "line": 247,
        "fullcodeline": "if (!myentity_allow_foundership(mt))"
    },
    {
        "line": 255,
        "fullcodeline": "addflags |= CA_FLAGS, removeflags &= ~CA_FLAGS;"
    },
    {
        "line": 295,
        "fullcodeline": "command_fail(si, fault_badparams, _(\"You may not set founder status on a hostmask.\"));"
    },
    {
        "line": 302,
        "fullcodeline": "command_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);"
    },
    {
        "line": 303,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 312,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), target, mc->name);"
    },
    {
        "line": 313,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 75,
        "fullcodeline": "else if (anope_flags_compat && !strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)"
    },
    {
        "line": 139,
        "fullcodeline": "if (!(mt = myentity_find_ext(target)))"
    },
    {
        "line": 172,
        "fullcodeline": "if (restrictflags & CA_AKICK ||"
    },
    {
        "line": 184,
        "fullcodeline": "restrictflags |= allow_flags(mc, restrictflags);"
    },
    {
        "line": 202,
        "fullcodeline": "if (*target == '+' || *target == '-' || *target == '=')"
    },
    {
        "line": 237,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"Only %d founders allowed per channel.\"), chansvs.maxfounders);"
    },
    {
        "line": 238,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 243,
        "fullcodeline": "command_fail(si, fault_toomany, _(\"\\2%s\\2 has too many channels registered.\"), mt->name);"
    },
    {
        "line": 244,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 249,
        "fullcodeline": "command_fail(si, fault_toomany, _(\"\\2%s\\2 cannot take foundership of a channel.\"), mt->name);"
    },
    {
        "line": 250,
        "fullcodeline": "chanacs_close(ca);"
    },
    {
        "line": 77,
        "fullcodeline": "free(target);"
    },
    {
        "line": 87,
        "fullcodeline": "MOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)"
    },
    {
        "line": 97,
        "fullcodeline": "logcommand(si, CMDLOG_DO, \"CLEAR:FLAGS: \\2%s\\2\", mc->name);"
    },
    {
        "line": 98,
        "fullcodeline": "command_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);"
    },
    {
        "line": 141,
        "fullcodeline": "command_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);"
    },
    {
        "line": 175,
        "fullcodeline": "strcmp(flagstr, \"-*\"))"
    },
    {
        "line": 177,
        "fullcodeline": "command_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));"
    },
    {
        "line": 203,
        "fullcodeline": "command_fail(si, fault_badparams, _(\"Usage: FLAGS %s [target] [flags]\"), mc->name);"
    },
    {
        "line": 79,
        "fullcodeline": "if (!chanacs_source_has_flag(mc, si, CA_FOUNDER))"
    },
    {
        "line": 89,
        "fullcodeline": "ca = n->data;"
    },
    {
        "line": 94,
        "fullcodeline": "object_unref(ca);"
    },
    {
        "line": 174,
        "fullcodeline": "irccasecmp(target, entity(si->smu)->name) ||"
    },
    {
        "line": 205,
        "fullcodeline": "command_fail(si, fault_badparams, _(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp, mc->name);"
    },
    {
        "line": 81,
        "fullcodeline": "command_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");"
    },
    {
        "line": 91,
        "fullcodeline": "if (ca->level & CA_FOUNDER)"
    },
    {
        "line": 101,
        "fullcodeline": "else if (anope_flags_compat && !strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)"
    },
    {
        "line": 173,
        "fullcodeline": "si->smu == NULL ||"
    },
    {
        "line": 103,
        "fullcodeline": "free(target);"
    },
    {
        "line": 112,
        "fullcodeline": "flagstr = strchr(parv[2], ' ');"
    },
    {
        "line": 116,
        "fullcodeline": "target = strdup(parv[2]);"
    },
    {
        "line": 105,
        "fullcodeline": "if (parc < 3)"
    },
    {
        "line": 107,
        "fullcodeline": "command_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");"
    },
    {
        "line": 108,
        "fullcodeline": "command_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\"));"
    },
    {
        "line": 114,
        "fullcodeline": "*flagstr++ = '\\0';"
    }
]