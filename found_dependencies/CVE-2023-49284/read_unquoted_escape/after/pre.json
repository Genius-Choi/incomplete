[
    {
        "line": 3,
        "fullcodeline": "assert(input[0] == L'\\\\' && \"Not an escape\");"
    },
    {
        "line": 7,
        "fullcodeline": "maybe_t<wchar_t> result_char_or_none = none();"
    },
    {
        "line": 9,
        "fullcodeline": "bool errored = false;"
    },
    {
        "line": 10,
        "fullcodeline": "size_t in_pos = 1;  // in_pos always tracks the next character to read (and therefore the number"
    },
    {
        "line": 16,
        "fullcodeline": "const wchar_t c = input[in_pos++];"
    },
    {
        "line": 186,
        "fullcodeline": "if (fish_reserved_codepoint(*result_char_or_none)) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (!byte_buff.empty()) {"
    },
    {
        "line": 179,
        "fullcodeline": "result->append(str2wcstring(byte_buff));"
    },
    {
        "line": 21,
        "fullcodeline": "assert(in_pos > 0);"
    },
    {
        "line": 22,
        "fullcodeline": "in_pos--;"
    },
    {
        "line": 41,
        "fullcodeline": "long long res = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "size_t chars = 2;"
    },
    {
        "line": 43,
        "fullcodeline": "int base = 16;"
    },
    {
        "line": 44,
        "fullcodeline": "bool byte_literal = false;"
    },
    {
        "line": 45,
        "fullcodeline": "wchar_t max_val = ASCII_MAX;"
    },
    {
        "line": 114,
        "fullcodeline": "result_char_or_none = L'\\a';"
    },
    {
        "line": 119,
        "fullcodeline": "result_char_or_none = L'\\b';"
    },
    {
        "line": 124,
        "fullcodeline": "const wchar_t sequence_char = input[in_pos++];"
    },
    {
        "line": 136,
        "fullcodeline": "result_char_or_none = L'\\x1B';"
    },
    {
        "line": 141,
        "fullcodeline": "result_char_or_none = L'\\f';"
    },
    {
        "line": 146,
        "fullcodeline": "result_char_or_none = L'\\n';"
    },
    {
        "line": 151,
        "fullcodeline": "result_char_or_none = L'\\r';"
    },
    {
        "line": 156,
        "fullcodeline": "result_char_or_none = L'\\t';"
    },
    {
        "line": 161,
        "fullcodeline": "result_char_or_none = L'\\v';"
    },
    {
        "line": 166,
        "fullcodeline": "result_char_or_none = none();"
    },
    {
        "line": 171,
        "fullcodeline": "result_char_or_none = c;"
    },
    {
        "line": 176,
        "fullcodeline": "if (errored) return none();"
    },
    {
        "line": 187,
        "fullcodeline": "return none();"
    },
    {
        "line": 25,
        "fullcodeline": "if (!allow_incomplete) errored = true;"
    },
    {
        "line": 78,
        "fullcodeline": "for (size_t i = 0; i < chars; i++) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (!errored && res <= max_val) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (sequence_char >= L'a' && sequence_char <= (L'a' + 32)) {"
    },
    {
        "line": 79,
        "fullcodeline": "long d = convert_digit(input[in_pos], base);"
    },
    {
        "line": 86,
        "fullcodeline": "res = (res * base) + d;"
    },
    {
        "line": 87,
        "fullcodeline": "in_pos++;"
    },
    {
        "line": 126,
        "fullcodeline": "result_char_or_none = sequence_char - L'a' + 1;"
    },
    {
        "line": 170,
        "fullcodeline": "if (unescape_special) result->push_back(INTERNAL_SEPARATOR);"
    },
    {
        "line": 49,
        "fullcodeline": "chars = 4;"
    },
    {
        "line": 50,
        "fullcodeline": "max_val = UCS2_MAX;"
    },
    {
        "line": 54,
        "fullcodeline": "chars = 8;"
    },
    {
        "line": 55,
        "fullcodeline": "max_val = WCHAR_MAX;"
    },
    {
        "line": 63,
        "fullcodeline": "byte_literal = true;"
    },
    {
        "line": 64,
        "fullcodeline": "max_val = BYTE_MAX;"
    },
    {
        "line": 68,
        "fullcodeline": "base = 8;"
    },
    {
        "line": 69,
        "fullcodeline": "chars = 3;"
    },
    {
        "line": 72,
        "fullcodeline": "assert(in_pos > 0);"
    },
    {
        "line": 73,
        "fullcodeline": "in_pos--;"
    },
    {
        "line": 80,
        "fullcodeline": "if (d < 0) {"
    },
    {
        "line": 107,
        "fullcodeline": "errored = true;"
    },
    {
        "line": 58,
        "fullcodeline": "if (0x10FFFF < max_val) max_val = static_cast<wchar_t>(0x10FFFF);"
    },
    {
        "line": 96,
        "fullcodeline": "byte_buff.push_back(static_cast<char>(res));"
    },
    {
        "line": 97,
        "fullcodeline": "result_char_or_none = none();"
    },
    {
        "line": 127,
        "fullcodeline": "} else if (sequence_char >= L'A' && sequence_char <= (L'A' + 32)) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (i == 0) errored = true;"
    },
    {
        "line": 98,
        "fullcodeline": "if (input[in_pos] == L'\\\\'"
    },
    {
        "line": 104,
        "fullcodeline": "result_char_or_none = static_cast<wchar_t>(res);"
    },
    {
        "line": 128,
        "fullcodeline": "result_char_or_none = sequence_char - L'A' + 1;"
    },
    {
        "line": 99,
        "fullcodeline": "&& (input[in_pos + 1] == L'X' || input[in_pos + 1] == L'x')) {"
    },
    {
        "line": 100,
        "fullcodeline": "in_pos++;"
    },
    {
        "line": 130,
        "fullcodeline": "errored = true;"
    }
]