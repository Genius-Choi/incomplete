[
    {
        "line": 3,
        "fullcodeline": "assert(in != nullptr);"
    },
    {
        "line": 6,
        "fullcodeline": "result.reserve(in_len);"
    },
    {
        "line": 8,
        "fullcodeline": "size_t in_pos = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "mbstate_t state = {};"
    },
    {
        "line": 2,
        "fullcodeline": "if (in_len == 0) return wcstring();"
    },
    {
        "line": 10,
        "fullcodeline": "while (in_pos < in_len) {"
    },
    {
        "line": 13,
        "fullcodeline": "size_t ascii_prefix_length = count_ascii_prefix(&in[in_pos], in_len - in_pos);"
    },
    {
        "line": 14,
        "fullcodeline": "result.insert(result.end(), &in[in_pos], &in[in_pos + ascii_prefix_length]);"
    },
    {
        "line": 15,
        "fullcodeline": "in_pos += ascii_prefix_length;"
    },
    {
        "line": 16,
        "fullcodeline": "assert(in_pos <= in_len && \"Position overflowed length\");"
    },
    {
        "line": 20,
        "fullcodeline": "bool use_encode_direct = false;"
    },
    {
        "line": 21,
        "fullcodeline": "size_t ret = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "wchar_t wc = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "if (in_pos == in_len) break;"
    },
    {
        "line": 60,
        "fullcodeline": "wc = ENCODE_DIRECT_BASE + static_cast<unsigned char>(in[in_pos]);"
    },
    {
        "line": 61,
        "fullcodeline": "result.push_back(wc);"
    },
    {
        "line": 62,
        "fullcodeline": "in_pos++;"
    },
    {
        "line": 63,
        "fullcodeline": "std::memset(&state, 0, sizeof state);"
    },
    {
        "line": 31,
        "fullcodeline": "} else if (sizeof(wchar_t) == 2 &&  //!OCLINT(constant if expression)"
    },
    {
        "line": 64,
        "fullcodeline": "} else if (ret == 0) {  // embedded null byte!"
    },
    {
        "line": 32,
        "fullcodeline": "(in[in_pos] & 0xF8) == 0xF0) {"
    },
    {
        "line": 36,
        "fullcodeline": "use_encode_direct = true;"
    },
    {
        "line": 65,
        "fullcodeline": "result.push_back(L'\\0');"
    },
    {
        "line": 66,
        "fullcodeline": "in_pos++;"
    },
    {
        "line": 67,
        "fullcodeline": "std::memset(&state, 0, sizeof state);"
    },
    {
        "line": 38,
        "fullcodeline": "ret = std::mbrtowc(&wc, &in[in_pos], in_len - in_pos, &state);"
    },
    {
        "line": 69,
        "fullcodeline": "result.push_back(wc);"
    },
    {
        "line": 70,
        "fullcodeline": "in_pos += ret;"
    },
    {
        "line": 40,
        "fullcodeline": "if (fish_reserved_codepoint(wc)) {"
    },
    {
        "line": 41,
        "fullcodeline": "use_encode_direct = true;"
    },
    {
        "line": 42,
        "fullcodeline": "} else if (ret == static_cast<size_t>(-2)) {"
    },
    {
        "line": 44,
        "fullcodeline": "use_encode_direct = true;"
    },
    {
        "line": 45,
        "fullcodeline": "} else if (ret == static_cast<size_t>(-1)) {"
    },
    {
        "line": 47,
        "fullcodeline": "use_encode_direct = true;"
    },
    {
        "line": 48,
        "fullcodeline": "} else if (ret > in_len - in_pos) {"
    },
    {
        "line": 50,
        "fullcodeline": "use_encode_direct = true;"
    },
    {
        "line": 51,
        "fullcodeline": "} else if (sizeof(wchar_t) == 2 && wc >= 0xD800 &&  //!OCLINT(constant if expression)"
    },
    {
        "line": 52,
        "fullcodeline": "wc <= 0xDFFF) {"
    },
    {
        "line": 55,
        "fullcodeline": "use_encode_direct = true;"
    }
]