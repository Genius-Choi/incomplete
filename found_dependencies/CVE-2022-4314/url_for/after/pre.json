[
    {
        "line": 8,
        "fullcodeline": "path = \"\""
    },
    {
        "line": 32,
        "fullcodeline": "qs = [(k, v.epoch() if hasattr(v, 'epoch') else v) for k, v in sorted(kwargs.items()) if v is not None]"
    },
    {
        "line": 9,
        "fullcodeline": "for chunk in args:"
    },
    {
        "line": 33,
        "fullcodeline": "return cherrypy.url(path=path, qs=qs)"
    },
    {
        "line": 10,
        "fullcodeline": "if not chunk:"
    },
    {
        "line": 12,
        "fullcodeline": "if hasattr(chunk, 'owner') and hasattr(chunk, 'repopath'):"
    },
    {
        "line": 14,
        "fullcodeline": "path += \"/\""
    },
    {
        "line": 15,
        "fullcodeline": "path += chunk.owner"
    },
    {
        "line": 16,
        "fullcodeline": "path += \"/\""
    },
    {
        "line": 17,
        "fullcodeline": "path += rdw_helpers.quote_url(chunk.repopath.strip(\"/\"))"
    },
    {
        "line": 18,
        "fullcodeline": "elif hasattr(chunk, 'path'):"
    },
    {
        "line": 23,
        "fullcodeline": "elif chunk and isinstance(chunk, bytes):"
    },
    {
        "line": 21,
        "fullcodeline": "path += \"/\""
    },
    {
        "line": 22,
        "fullcodeline": "path += rdw_helpers.quote_url(chunk.path.strip(b\"/\"))"
    },
    {
        "line": 24,
        "fullcodeline": "path += \"/\""
    },
    {
        "line": 25,
        "fullcodeline": "path += rdw_helpers.quote_url(chunk.strip(b\"/\"))"
    },
    {
        "line": 26,
        "fullcodeline": "elif chunk and isinstance(chunk, str):"
    },
    {
        "line": 27,
        "fullcodeline": "path += \"/\""
    },
    {
        "line": 28,
        "fullcodeline": "path += chunk.strip(\"/\")"
    },
    {
        "line": 30,
        "fullcodeline": "raise ValueError('invalid positional arguments, url_for accept str, bytes or RepoPath: %r' % chunk)"
    }
]