[
    {
        "line": 2,
        "fullcodeline": "ENVOY_CONN_LOG(trace, \"recv frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));"
    },
    {
        "line": 7,
        "fullcodeline": "ASSERT(frame->hd.type != NGHTTP2_CONTINUATION);"
    },
    {
        "line": 24,
        "fullcodeline": "StreamImpl* stream = getStream(frame->hd.stream_id);"
    },
    {
        "line": 9,
        "fullcodeline": "if (frame->hd.type == NGHTTP2_DATA) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (frame->hd.type == NGHTTP2_GOAWAY && !raised_goaway_) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (!stream) {"
    },
    {
        "line": 18,
        "fullcodeline": "ASSERT(frame->hd.stream_id == 0);"
    },
    {
        "line": 19,
        "fullcodeline": "raised_goaway_ = true;"
    },
    {
        "line": 20,
        "fullcodeline": "callbacks().onGoAway();"
    },
    {
        "line": 10,
        "fullcodeline": "if (!trackInboundFrames(&frame->hd, frame->data.padlen)) {"
    },
    {
        "line": 31,
        "fullcodeline": "stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;"
    },
    {
        "line": 93,
        "fullcodeline": "stream->headers_.reset();"
    },
    {
        "line": 97,
        "fullcodeline": "stream->remote_end_stream_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;"
    },
    {
        "line": 105,
        "fullcodeline": "stream->pending_recv_data_.drain(stream->pending_recv_data_.length());"
    },
    {
        "line": 109,
        "fullcodeline": "ENVOY_CONN_LOG(trace, \"remote reset: {}\", connection_, frame->rst_stream.error_code);"
    },
    {
        "line": 32,
        "fullcodeline": "if (!stream->cookies_.empty()) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (!stream->deferred_reset_) {"
    },
    {
        "line": 34,
        "fullcodeline": "stream->headers_->addViaMove(std::move(key), std::move(stream->cookies_));"
    },
    {
        "line": 102,
        "fullcodeline": "stream->decoder_->decodeData(stream->pending_recv_data_, stream->remote_end_stream_);"
    },
    {
        "line": 53,
        "fullcodeline": "stream->decodeHeaders();"
    },
    {
        "line": 39,
        "fullcodeline": "if (CodeUtility::is1xx(Http::Utility::getResponseStatus(*stream->headers_))) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (stream->headers_->Status()->value() == \"100\") {"
    },
    {
        "line": 60,
        "fullcodeline": "if (!stream->deferred_reset_) {"
    },
    {
        "line": 40,
        "fullcodeline": "stream->waiting_for_non_informational_headers_ = true;"
    },
    {
        "line": 44,
        "fullcodeline": "ASSERT(!stream->remote_end_stream_);"
    },
    {
        "line": 45,
        "fullcodeline": "stream->decoder_->decode100ContinueHeaders(std::move(stream->headers_));"
    },
    {
        "line": 47,
        "fullcodeline": "stream->decodeHeaders();"
    },
    {
        "line": 61,
        "fullcodeline": "if (!stream->waiting_for_non_informational_headers_) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (!stream->remote_end_stream_) {"
    },
    {
        "line": 75,
        "fullcodeline": "ASSERT(!nghttp2_session_check_server_session(session_));"
    },
    {
        "line": 76,
        "fullcodeline": "stream->waiting_for_non_informational_headers_ = false;"
    },
    {
        "line": 81,
        "fullcodeline": "stream->decodeHeaders();"
    },
    {
        "line": 70,
        "fullcodeline": "throw CodecProtocolException(\"Unexpected 'trailers' with no end stream.\");"
    },
    {
        "line": 72,
        "fullcodeline": "stream->decoder_->decodeTrailers(std::move(stream->headers_));"
    }
]