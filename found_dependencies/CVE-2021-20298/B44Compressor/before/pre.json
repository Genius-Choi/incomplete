[
    {
        "line": 19,
        "fullcodeline": "(void)_maxScanLineSize;"
    },
    {
        "line": 27,
        "fullcodeline": "_tmpBuffer = new unsigned short"
    },
    {
        "line": 31,
        "fullcodeline": "const ChannelList &channels = header().channels();"
    },
    {
        "line": 32,
        "fullcodeline": "int numHalfChans = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;"
    },
    {
        "line": 51,
        "fullcodeline": "_outBuffer = new char"
    },
    {
        "line": 54,
        "fullcodeline": "_channelData = new ChannelData[_numChans];"
    },
    {
        "line": 56,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 69,
        "fullcodeline": "const Box2i &dataWindow = hdr.dataWindow();"
    },
    {
        "line": 71,
        "fullcodeline": "_minX = dataWindow.min.x;"
    },
    {
        "line": 72,
        "fullcodeline": "_maxX = dataWindow.max.x;"
    },
    {
        "line": 73,
        "fullcodeline": "_maxY = dataWindow.max.y;"
    },
    {
        "line": 80,
        "fullcodeline": "assert (sizeof (unsigned short) == pixelTypeSize (HALF));"
    },
    {
        "line": 35,
        "fullcodeline": "c != channels.end();"
    },
    {
        "line": 36,
        "fullcodeline": "++c)"
    },
    {
        "line": 59,
        "fullcodeline": "c != channels.end();"
    },
    {
        "line": 60,
        "fullcodeline": "++c, ++i)"
    },
    {
        "line": 82,
        "fullcodeline": "if (_numChans == numHalfChans)"
    },
    {
        "line": 34,
        "fullcodeline": "for (ChannelList::ConstIterator c = channels.begin();"
    },
    {
        "line": 38,
        "fullcodeline": "assert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);"
    },
    {
        "line": 39,
        "fullcodeline": "++_numChans;"
    },
    {
        "line": 58,
        "fullcodeline": "for (ChannelList::ConstIterator c = channels.begin();"
    },
    {
        "line": 62,
        "fullcodeline": "_channelData[i].ys = c.channel().ySampling;"
    },
    {
        "line": 63,
        "fullcodeline": "_channelData[i].type = c.channel().type;"
    },
    {
        "line": 64,
        "fullcodeline": "_channelData[i].pLinear = c.channel().pLinear;"
    },
    {
        "line": 65,
        "fullcodeline": "_channelData[i].size ="
    },
    {
        "line": 83,
        "fullcodeline": "_format = NATIVE;"
    },
    {
        "line": 41,
        "fullcodeline": "if (c.channel().type == HALF)"
    },
    {
        "line": 66,
        "fullcodeline": "pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);"
    },
    {
        "line": 42,
        "fullcodeline": "++numHalfChans;"
    }
]