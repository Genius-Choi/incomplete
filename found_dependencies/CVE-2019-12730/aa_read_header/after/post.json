[
    {
        "line": 3,
        "fullcodeline": "int i, j, idx, largest_idx = -1;"
    },
    {
        "line": 4,
        "fullcodeline": "uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;"
    },
    {
        "line": 5,
        "fullcodeline": "char key[128], val[128], codec_name[64] = {0};"
    },
    {
        "line": 6,
        "fullcodeline": "uint8_t output[24], dst[8], src[8];"
    },
    {
        "line": 7,
        "fullcodeline": "int64_t largest_size = -1, current_size = -1, chapter_pos;"
    },
    {
        "line": 11,
        "fullcodeline": "} TOC[MAX_TOC_ENTRIES];"
    },
    {
        "line": 12,
        "fullcodeline": "uint32_t header_key_part[4];"
    },
    {
        "line": 13,
        "fullcodeline": "uint8_t header_key[16] = {0};"
    },
    {
        "line": 14,
        "fullcodeline": "AADemuxContext *c = s->priv_data;"
    },
    {
        "line": 15,
        "fullcodeline": "AVIOContext *pb = s->pb;"
    },
    {
        "line": 20,
        "fullcodeline": "avio_skip(pb, 4); // file size"
    },
    {
        "line": 21,
        "fullcodeline": "avio_skip(pb, 4); // magic string"
    },
    {
        "line": 22,
        "fullcodeline": "toc_size = avio_rb32(pb); // TOC size"
    },
    {
        "line": 23,
        "fullcodeline": "avio_skip(pb, 4); // unidentified integer"
    },
    {
        "line": 31,
        "fullcodeline": "avio_skip(pb, 24); // header termination block (ignored)"
    },
    {
        "line": 32,
        "fullcodeline": "npairs = avio_rb32(pb); // read dictionary entries"
    },
    {
        "line": 82,
        "fullcodeline": "c->tea_ctx = av_tea_alloc();"
    },
    {
        "line": 85,
        "fullcodeline": "av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);"
    },
    {
        "line": 86,
        "fullcodeline": "output[0] = output[1] = 0; // purely for padding purposes"
    },
    {
        "line": 87,
        "fullcodeline": "memcpy(output + 2, header_key, 16);"
    },
    {
        "line": 88,
        "fullcodeline": "idx = 0;"
    },
    {
        "line": 98,
        "fullcodeline": "memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output"
    },
    {
        "line": 99,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"File key is \");"
    },
    {
        "line": 102,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"\\n\");"
    },
    {
        "line": 105,
        "fullcodeline": "st = avformat_new_stream(s, NULL);"
    },
    {
        "line": 110,
        "fullcodeline": "st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;"
    },
    {
        "line": 144,
        "fullcodeline": "avio_seek(pb, start, SEEK_SET);"
    },
    {
        "line": 148,
        "fullcodeline": "st->start_time = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "c->content_start = start;"
    },
    {
        "line": 150,
        "fullcodeline": "c->content_end = start + largest_size;"
    },
    {
        "line": 163,
        "fullcodeline": "st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;"
    },
    {
        "line": 165,
        "fullcodeline": "ff_update_cur_dts(s, st, 0);"
    },
    {
        "line": 166,
        "fullcodeline": "avio_seek(pb, start, SEEK_SET);"
    },
    {
        "line": 167,
        "fullcodeline": "c->current_chapter_size = 0;"
    },
    {
        "line": 168,
        "fullcodeline": "c->seek_offset = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "if (toc_size > MAX_TOC_ENTRIES)"
    },
    {
        "line": 26,
        "fullcodeline": "for (i = 0; i < toc_size; i++) { // read TOC"
    },
    {
        "line": 33,
        "fullcodeline": "if (npairs > MAX_DICTIONARY_ENTRIES)"
    },
    {
        "line": 35,
        "fullcodeline": "for (i = 0; i < npairs; i++) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (c->aa_fixed_key_len != 16) {"
    },
    {
        "line": 76,
        "fullcodeline": "if ((c->codec_second_size = get_second_size(codec_name)) == -1) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (!c->tea_ctx)"
    },
    {
        "line": 89,
        "fullcodeline": "for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness"
    },
    {
        "line": 100,
        "fullcodeline": "for (i = 0; i < 16; i++)"
    },
    {
        "line": 101,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"%02x\", c->file_key[i]);"
    },
    {
        "line": 106,
        "fullcodeline": "if (!st) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (!strcmp(codec_name, \"mp332\")) {"
    },
    {
        "line": 136,
        "fullcodeline": "for (i = 1; i < toc_size; i++) { // skip the first entry!"
    },
    {
        "line": 152,
        "fullcodeline": "while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {"
    },
    {
        "line": 27,
        "fullcodeline": "avio_skip(pb, 4); // TOC entry index"
    },
    {
        "line": 28,
        "fullcodeline": "TOC[i].offset = avio_rb32(pb); // block offset"
    },
    {
        "line": 29,
        "fullcodeline": "TOC[i].size = avio_rb32(pb); // block size"
    },
    {
        "line": 36,
        "fullcodeline": "memset(val, 0, sizeof(val));"
    },
    {
        "line": 37,
        "fullcodeline": "memset(key, 0, sizeof(key));"
    },
    {
        "line": 38,
        "fullcodeline": "avio_skip(pb, 1); // unidentified integer"
    },
    {
        "line": 39,
        "fullcodeline": "nkey = avio_rb32(pb); // key string length"
    },
    {
        "line": 40,
        "fullcodeline": "nval = avio_rb32(pb); // value string length"
    },
    {
        "line": 41,
        "fullcodeline": "avio_get_str(pb, nkey, key, sizeof(key));"
    },
    {
        "line": 42,
        "fullcodeline": "avio_get_str(pb, nval, val, sizeof(val));"
    },
    {
        "line": 71,
        "fullcodeline": "av_log(s, AV_LOG_ERROR, \"aa_fixed_key value needs to be 16 bytes!\\n\");"
    },
    {
        "line": 77,
        "fullcodeline": "av_log(s, AV_LOG_ERROR, \"unknown codec <%s>!\\n\", codec_name);"
    },
    {
        "line": 90,
        "fullcodeline": "AV_WB32(src, header_seed);"
    },
    {
        "line": 91,
        "fullcodeline": "AV_WB32(src + 4, header_seed + 1);"
    },
    {
        "line": 92,
        "fullcodeline": "header_seed += 2;"
    },
    {
        "line": 93,
        "fullcodeline": "av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt"
    },
    {
        "line": 107,
        "fullcodeline": "av_freep(&c->tea_ctx);"
    },
    {
        "line": 112,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_MP3;"
    },
    {
        "line": 113,
        "fullcodeline": "st->codecpar->sample_rate = 22050;"
    },
    {
        "line": 114,
        "fullcodeline": "st->need_parsing = AVSTREAM_PARSE_FULL_RAW;"
    },
    {
        "line": 115,
        "fullcodeline": "avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);"
    },
    {
        "line": 153,
        "fullcodeline": "int chapter_idx = s->nb_chapters;"
    },
    {
        "line": 154,
        "fullcodeline": "uint32_t chapter_size = avio_rb32(pb);"
    },
    {
        "line": 156,
        "fullcodeline": "chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;"
    },
    {
        "line": 157,
        "fullcodeline": "avio_skip(pb, 4 + chapter_size);"
    },
    {
        "line": 43,
        "fullcodeline": "if (!strcmp(key, \"codec\")) {"
    },
    {
        "line": 72,
        "fullcodeline": "return AVERROR(EINVAL);"
    },
    {
        "line": 78,
        "fullcodeline": "return AVERROR(EINVAL);"
    },
    {
        "line": 84,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 94,
        "fullcodeline": "for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {"
    },
    {
        "line": 108,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 138,
        "fullcodeline": "if (current_size > largest_size) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (chapter_size == 0) break;"
    },
    {
        "line": 158,
        "fullcodeline": "if (!avpriv_new_chapter(s, chapter_idx, st->time_base,"
    },
    {
        "line": 44,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"Codec is <%s>\\n\", val);"
    },
    {
        "line": 45,
        "fullcodeline": "strncpy(codec_name, val, sizeof(codec_name) - 1);"
    },
    {
        "line": 95,
        "fullcodeline": "output[idx] = output[idx] ^ dst[j];"
    },
    {
        "line": 117,
        "fullcodeline": "} else if (!strcmp(codec_name, \"acelp85\")) {"
    },
    {
        "line": 139,
        "fullcodeline": "largest_idx = i;"
    },
    {
        "line": 140,
        "fullcodeline": "largest_size = current_size;"
    },
    {
        "line": 118,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_SIPR;"
    },
    {
        "line": 119,
        "fullcodeline": "st->codecpar->block_align = 19;"
    },
    {
        "line": 120,
        "fullcodeline": "st->codecpar->channels = 1;"
    },
    {
        "line": 121,
        "fullcodeline": "st->codecpar->sample_rate = 8500;"
    },
    {
        "line": 122,
        "fullcodeline": "st->codecpar->bit_rate = 8500;"
    },
    {
        "line": 123,
        "fullcodeline": "st->need_parsing = AVSTREAM_PARSE_FULL_RAW;"
    },
    {
        "line": 124,
        "fullcodeline": "avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);"
    },
    {
        "line": 159,
        "fullcodeline": "chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))"
    },
    {
        "line": 160,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 46,
        "fullcodeline": "} else if (!strcmp(key, \"HeaderSeed\")) {"
    },
    {
        "line": 47,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"HeaderSeed is <%s>\\n\", val);"
    },
    {
        "line": 48,
        "fullcodeline": "header_seed = atoi(val);"
    },
    {
        "line": 125,
        "fullcodeline": "} else if (!strcmp(codec_name, \"acelp16\")) {"
    },
    {
        "line": 126,
        "fullcodeline": "st->codecpar->codec_id = AV_CODEC_ID_SIPR;"
    },
    {
        "line": 127,
        "fullcodeline": "st->codecpar->block_align = 20;"
    },
    {
        "line": 128,
        "fullcodeline": "st->codecpar->channels = 1;"
    },
    {
        "line": 129,
        "fullcodeline": "st->codecpar->sample_rate = 16000;"
    },
    {
        "line": 130,
        "fullcodeline": "st->codecpar->bit_rate = 16000;"
    },
    {
        "line": 131,
        "fullcodeline": "st->need_parsing = AVSTREAM_PARSE_FULL_RAW;"
    },
    {
        "line": 132,
        "fullcodeline": "avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);"
    },
    {
        "line": 49,
        "fullcodeline": "} else if (!strcmp(key, \"HeaderKey\")) { // this looks like \"1234567890 1234567890 1234567890 1234567890\""
    },
    {
        "line": 50,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"HeaderKey is <%s>\\n\", val);"
    },
    {
        "line": 60,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"Processed HeaderKey is \");"
    },
    {
        "line": 63,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"\\n\");"
    },
    {
        "line": 54,
        "fullcodeline": "if (ret != 4)"
    },
    {
        "line": 57,
        "fullcodeline": "for (idx = 0; idx < 4; idx++) {"
    },
    {
        "line": 61,
        "fullcodeline": "for (i = 0; i < 16; i++)"
    },
    {
        "line": 62,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"%02x\", header_key[i]);"
    },
    {
        "line": 65,
        "fullcodeline": "av_dict_set(&s->metadata, key, val, 0);"
    },
    {
        "line": 58,
        "fullcodeline": "AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!"
    }
]