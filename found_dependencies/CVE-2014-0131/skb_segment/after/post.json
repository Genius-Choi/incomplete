[
    {
        "line": 4,
        "fullcodeline": "struct sk_buff *segs = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "struct sk_buff *tail = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "unsigned int doffset = head_skb->data - skb_mac_header(head_skb);"
    },
    {
        "line": 10,
        "fullcodeline": "struct sk_buff *frag_skb = head_skb;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned int offset = doffset;"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned int tnl_hlen = skb_tnl_header_len(head_skb);"
    },
    {
        "line": 17,
        "fullcodeline": "int sg = !!(features & NETIF_F_SG);"
    },
    {
        "line": 19,
        "fullcodeline": "int err = -ENOMEM;"
    },
    {
        "line": 20,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "proto = skb_network_protocol(head_skb);"
    },
    {
        "line": 27,
        "fullcodeline": "csum = !!can_checksum_protocol(features, proto);"
    },
    {
        "line": 28,
        "fullcodeline": "__skb_push(head_skb, doffset);"
    },
    {
        "line": 29,
        "fullcodeline": "headroom = skb_headroom(head_skb);"
    },
    {
        "line": 30,
        "fullcodeline": "pos = skb_headlen(head_skb);"
    },
    {
        "line": 200,
        "fullcodeline": "kfree_skb_list(segs);"
    },
    {
        "line": 24,
        "fullcodeline": "if (unlikely(!proto))"
    },
    {
        "line": 195,
        "fullcodeline": "} while ((offset += len) < head_skb->len);"
    },
    {
        "line": 201,
        "fullcodeline": "return ERR_PTR(err);"
    },
    {
        "line": 6,
        "fullcodeline": "struct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;"
    },
    {
        "line": 7,
        "fullcodeline": "skb_frag_t *frag = skb_shinfo(head_skb)->frags;"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned int mss = skb_shinfo(head_skb)->gso_size;"
    },
    {
        "line": 18,
        "fullcodeline": "int nfrags = skb_shinfo(head_skb)->nr_frags;"
    },
    {
        "line": 38,
        "fullcodeline": "len = head_skb->len - offset;"
    },
    {
        "line": 42,
        "fullcodeline": "hsize = skb_headlen(head_skb) - offset;"
    },
    {
        "line": 106,
        "fullcodeline": "tail = nskb;"
    },
    {
        "line": 108,
        "fullcodeline": "__copy_skb_header(nskb, head_skb);"
    },
    {
        "line": 109,
        "fullcodeline": "nskb->mac_len = head_skb->mac_len;"
    },
    {
        "line": 111,
        "fullcodeline": "skb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);"
    },
    {
        "line": 113,
        "fullcodeline": "skb_copy_from_linear_data_offset(head_skb, -tnl_hlen,"
    },
    {
        "line": 130,
        "fullcodeline": "skb_copy_from_linear_data_offset(head_skb, offset,"
    },
    {
        "line": 133,
        "fullcodeline": "skb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &"
    },
    {
        "line": 185,
        "fullcodeline": "nskb->data_len = len - hsize;"
    },
    {
        "line": 186,
        "fullcodeline": "nskb->len += nskb->data_len;"
    },
    {
        "line": 187,
        "fullcodeline": "nskb->truesize += nskb->data_len;"
    },
    {
        "line": 25,
        "fullcodeline": "return ERR_PTR(-EINVAL);"
    },
    {
        "line": 39,
        "fullcodeline": "if (len > mss)"
    },
    {
        "line": 43,
        "fullcodeline": "if (hsize < 0)"
    },
    {
        "line": 45,
        "fullcodeline": "if (hsize > len || !sg)"
    },
    {
        "line": 48,
        "fullcodeline": "if (!hsize && i >= nfrags && skb_headlen(list_skb) &&"
    },
    {
        "line": 114,
        "fullcodeline": "nskb->data - tnl_hlen,"
    },
    {
        "line": 115,
        "fullcodeline": "doffset + tnl_hlen);"
    },
    {
        "line": 117,
        "fullcodeline": "if (nskb->len == len + doffset)"
    },
    {
        "line": 120,
        "fullcodeline": "if (!sg) {"
    },
    {
        "line": 131,
        "fullcodeline": "skb_put(nskb, hsize), hsize);"
    },
    {
        "line": 136,
        "fullcodeline": "while (pos < offset + len) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (!csum) {"
    },
    {
        "line": 40,
        "fullcodeline": "len = mss;"
    },
    {
        "line": 44,
        "fullcodeline": "hsize = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "hsize = len;"
    },
    {
        "line": 49,
        "fullcodeline": "(skb_headlen(list_skb) == len || sg)) {"
    },
    {
        "line": 50,
        "fullcodeline": "BUG_ON(skb_headlen(list_skb) > len);"
    },
    {
        "line": 52,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 55,
        "fullcodeline": "frag_skb = list_skb;"
    },
    {
        "line": 56,
        "fullcodeline": "pos += skb_headlen(list_skb);"
    },
    {
        "line": 70,
        "fullcodeline": "nskb = skb_clone(list_skb, GFP_ATOMIC);"
    },
    {
        "line": 71,
        "fullcodeline": "list_skb = list_skb->next;"
    },
    {
        "line": 81,
        "fullcodeline": "hsize = skb_end_offset(nskb);"
    },
    {
        "line": 87,
        "fullcodeline": "nskb->truesize += skb_end_offset(nskb) - hsize;"
    },
    {
        "line": 88,
        "fullcodeline": "skb_release_head_state(nskb);"
    },
    {
        "line": 89,
        "fullcodeline": "__skb_push(nskb, doffset);"
    },
    {
        "line": 103,
        "fullcodeline": "tail->next = nskb;"
    },
    {
        "line": 121,
        "fullcodeline": "nskb->ip_summed = CHECKSUM_NONE;"
    },
    {
        "line": 122,
        "fullcodeline": "nskb->csum = skb_copy_and_csum_bits(head_skb, offset,"
    },
    {
        "line": 128,
        "fullcodeline": "nskb_frag = skb_shinfo(nskb)->frags;"
    },
    {
        "line": 162,
        "fullcodeline": "__skb_frag_ref(nskb_frag);"
    },
    {
        "line": 163,
        "fullcodeline": "size = skb_frag_size(nskb_frag);"
    },
    {
        "line": 170,
        "fullcodeline": "skb_shinfo(nskb)->nr_frags++;"
    },
    {
        "line": 181,
        "fullcodeline": "nskb_frag++;"
    },
    {
        "line": 191,
        "fullcodeline": "nskb->csum = skb_checksum(nskb, doffset,"
    },
    {
        "line": 193,
        "fullcodeline": "nskb->ip_summed = CHECKSUM_NONE;"
    },
    {
        "line": 58,
        "fullcodeline": "while (pos < offset + len) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (unlikely(!nskb))"
    },
    {
        "line": 76,
        "fullcodeline": "if (unlikely(pskb_trim(nskb, len))) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (skb_cow_head(nskb, doffset + headroom)) {"
    },
    {
        "line": 91,
        "fullcodeline": "nskb = __alloc_skb(hsize + doffset + headroom,"
    },
    {
        "line": 98,
        "fullcodeline": "skb_reserve(nskb, headroom);"
    },
    {
        "line": 99,
        "fullcodeline": "__skb_put(nskb, doffset);"
    },
    {
        "line": 105,
        "fullcodeline": "segs = nskb;"
    },
    {
        "line": 137,
        "fullcodeline": "if (i >= nfrags) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (unlikely(skb_shinfo(nskb)->nr_frags >="
    },
    {
        "line": 158,
        "fullcodeline": "if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))"
    },
    {
        "line": 165,
        "fullcodeline": "if (pos < offset) {"
    },
    {
        "line": 172,
        "fullcodeline": "if (pos + size <= offset + len) {"
    },
    {
        "line": 53,
        "fullcodeline": "nfrags = skb_shinfo(list_skb)->nr_frags;"
    },
    {
        "line": 54,
        "fullcodeline": "frag = skb_shinfo(list_skb)->frags;"
    },
    {
        "line": 59,
        "fullcodeline": "BUG_ON(i >= nfrags);"
    },
    {
        "line": 61,
        "fullcodeline": "size = skb_frag_size(frag);"
    },
    {
        "line": 65,
        "fullcodeline": "i++;"
    },
    {
        "line": 66,
        "fullcodeline": "pos += size;"
    },
    {
        "line": 67,
        "fullcodeline": "frag++;"
    },
    {
        "line": 77,
        "fullcodeline": "kfree_skb(nskb);"
    },
    {
        "line": 83,
        "fullcodeline": "kfree_skb(nskb);"
    },
    {
        "line": 95,
        "fullcodeline": "if (unlikely(!nskb))"
    },
    {
        "line": 123,
        "fullcodeline": "skb_put(nskb, len),"
    },
    {
        "line": 138,
        "fullcodeline": "BUG_ON(skb_headlen(list_skb));"
    },
    {
        "line": 140,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "frag_skb = list_skb;"
    },
    {
        "line": 145,
        "fullcodeline": "BUG_ON(!nfrags);"
    },
    {
        "line": 147,
        "fullcodeline": "list_skb = list_skb->next;"
    },
    {
        "line": 152,
        "fullcodeline": "net_warn_ratelimited("
    },
    {
        "line": 166,
        "fullcodeline": "nskb_frag->page_offset += offset - pos;"
    },
    {
        "line": 167,
        "fullcodeline": "skb_frag_size_sub(nskb_frag, offset - pos);"
    },
    {
        "line": 173,
        "fullcodeline": "i++;"
    },
    {
        "line": 174,
        "fullcodeline": "frag++;"
    },
    {
        "line": 175,
        "fullcodeline": "pos += size;"
    },
    {
        "line": 192,
        "fullcodeline": "nskb->len - doffset, 0);"
    },
    {
        "line": 62,
        "fullcodeline": "if (pos + size > offset + len)"
    },
    {
        "line": 92,
        "fullcodeline": "GFP_ATOMIC, skb_alloc_rx_flag(head_skb),"
    },
    {
        "line": 177,
        "fullcodeline": "skb_frag_size_sub(nskb_frag, pos + size - (offset + len));"
    },
    {
        "line": 141,
        "fullcodeline": "nfrags = skb_shinfo(list_skb)->nr_frags;"
    },
    {
        "line": 142,
        "fullcodeline": "frag = skb_shinfo(list_skb)->frags;"
    }
]