[
    {
        "line": 2,
        "fullcodeline": "while not quit_now:"
    },
    {
        "line": 3,
        "fullcodeline": "time.sleep(10)"
    },
    {
        "line": 5,
        "fullcodeline": "BAN_TIME = int(f2boptions['ban_time'])"
    },
    {
        "line": 6,
        "fullcodeline": "MAX_BAN_TIME = int(f2boptions['max_ban_time'])"
    },
    {
        "line": 7,
        "fullcodeline": "BAN_TIME_INCREMENT = bool(f2boptions['ban_time_increment'])"
    },
    {
        "line": 8,
        "fullcodeline": "MAX_ATTEMPTS = int(f2boptions['max_attempts'])"
    },
    {
        "line": 9,
        "fullcodeline": "QUEUE_UNBAN = r.hgetall('F2B_QUEUE_UNBAN')"
    },
    {
        "line": 13,
        "fullcodeline": "for net in bans.copy():"
    },
    {
        "line": 11,
        "fullcodeline": "for net in QUEUE_UNBAN:"
    },
    {
        "line": 15,
        "fullcodeline": "NET_BAN_TIME = BAN_TIME if not BAN_TIME_INCREMENT else BAN_TIME * 2 ** bans[net]['ban_counter']"
    },
    {
        "line": 16,
        "fullcodeline": "TIME_SINCE_LAST_ATTEMPT = time.time() - bans[net]['last_attempt']"
    },
    {
        "line": 12,
        "fullcodeline": "unban(str(net))"
    },
    {
        "line": 17,
        "fullcodeline": "if TIME_SINCE_LAST_ATTEMPT > NET_BAN_TIME or TIME_SINCE_LAST_ATTEMPT > MAX_BAN_TIME:"
    }
]