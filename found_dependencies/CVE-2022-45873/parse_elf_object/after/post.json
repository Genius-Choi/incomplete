[
    {
        "line": 2,
        "fullcodeline": "_cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 };"
    },
    {
        "line": 3,
        "fullcodeline": "_cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "_cleanup_free_ char *buf = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "assert(fd >= 0);"
    },
    {
        "line": 9,
        "fullcodeline": "r = dlopen_dw();"
    },
    {
        "line": 13,
        "fullcodeline": "r = dlopen_elf();"
    },
    {
        "line": 17,
        "fullcodeline": "r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));"
    },
    {
        "line": 39,
        "fullcodeline": "r = safe_fork_full(\"(sd-parse-elf)\","
    },
    {
        "line": 120,
        "fullcodeline": "error_pipe[1] = safe_close(error_pipe[1]);"
    },
    {
        "line": 121,
        "fullcodeline": "return_pipe[1] = safe_close(return_pipe[1]);"
    },
    {
        "line": 122,
        "fullcodeline": "json_pipe[1] = safe_close(json_pipe[1]);"
    },
    {
        "line": 10,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 14,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 18,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 44,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));"
    },
    {
        "line": 28,
        "fullcodeline": "r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));"
    },
    {
        "line": 40,
        "fullcodeline": "(int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] },"
    },
    {
        "line": 42,
        "fullcodeline": "FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG,"
    },
    {
        "line": 67,
        "fullcodeline": "r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);"
    },
    {
        "line": 113,
        "fullcodeline": "_exit(EXIT_SUCCESS);"
    },
    {
        "line": 116,
        "fullcodeline": "(void) write(error_pipe[1], &r, sizeof(r));"
    },
    {
        "line": 117,
        "fullcodeline": "_exit(EXIT_FAILURE);"
    },
    {
        "line": 125,
        "fullcodeline": "_cleanup_fclose_ FILE *in = NULL;"
    },
    {
        "line": 127,
        "fullcodeline": "in = take_fdopen(&return_pipe[0], \"r\");"
    },
    {
        "line": 131,
        "fullcodeline": "r = read_full_stream(in, &buf, NULL);"
    },
    {
        "line": 137,
        "fullcodeline": "_cleanup_fclose_ FILE *json_in = NULL;"
    },
    {
        "line": 139,
        "fullcodeline": "json_in = take_fdopen(&json_pipe[0], \"r\");"
    },
    {
        "line": 143,
        "fullcodeline": "r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);"
    },
    {
        "line": 149,
        "fullcodeline": "*ret = TAKE_PTR(buf);"
    },
    {
        "line": 151,
        "fullcodeline": "*ret_package_metadata = TAKE_PTR(package_metadata);"
    },
    {
        "line": 23,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 29,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 45,
        "fullcodeline": "if (r == -EPROTO) { /* We should have the errno from the child, but don't clobber original error */"
    },
    {
        "line": 68,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 128,
        "fullcodeline": "if (!in)"
    },
    {
        "line": 132,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 140,
        "fullcodeline": "if (!json_in)"
    },
    {
        "line": 144,
        "fullcodeline": "if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */"
    },
    {
        "line": 48,
        "fullcodeline": "k = read(error_pipe[0], &e, sizeof(e));"
    },
    {
        "line": 62,
        "fullcodeline": "r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));"
    },
    {
        "line": 72,
        "fullcodeline": "size_t len = strlen(buf);"
    },
    {
        "line": 84,
        "fullcodeline": "(void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);"
    },
    {
        "line": 86,
        "fullcodeline": "r = loop_write(return_pipe[1], buf, len, false);"
    },
    {
        "line": 92,
        "fullcodeline": "return_pipe[1] = safe_close(return_pipe[1]);"
    },
    {
        "line": 96,
        "fullcodeline": "_cleanup_fclose_ FILE *json_out = NULL;"
    },
    {
        "line": 100,
        "fullcodeline": "(void) fcntl(json_pipe[1], F_SETPIPE_SZ, COREDUMP_PIPE_MAX);"
    },
    {
        "line": 102,
        "fullcodeline": "json_out = take_fdopen(&json_pipe[1], \"w\");"
    },
    {
        "line": 108,
        "fullcodeline": "r = json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);"
    },
    {
        "line": 145,
        "fullcodeline": "log_warning_errno(r, \"Failed to read or parse json metadata, ignoring: %m\");"
    },
    {
        "line": 49,
        "fullcodeline": "if (k < 0 && errno != EAGAIN) /* Pipe is non-blocking, EAGAIN means there's nothing */"
    },
    {
        "line": 51,
        "fullcodeline": "if (k == sizeof(e))"
    },
    {
        "line": 53,
        "fullcodeline": "if (k != 0)"
    },
    {
        "line": 63,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 74,
        "fullcodeline": "if (len > COREDUMP_PIPE_MAX) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (r == -EAGAIN)"
    },
    {
        "line": 103,
        "fullcodeline": "if (!json_out) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 129,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 141,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 77,
        "fullcodeline": "log_warning(\"Generated backtrace is %zu bytes (more than the limit of %u bytes), backtrace will be truncated.\","
    },
    {
        "line": 79,
        "fullcodeline": "len = COREDUMP_PIPE_MAX;"
    },
    {
        "line": 88,
        "fullcodeline": "log_warning(\"Write failed, backtrace will be truncated.\");"
    },
    {
        "line": 104,
        "fullcodeline": "r = -errno;"
    },
    {
        "line": 110,
        "fullcodeline": "log_warning_errno(r, \"Failed to write JSON package metadata, ignoring: %m\");"
    },
    {
        "line": 50,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 54,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 89,
        "fullcodeline": "else if (r < 0)"
    }
]