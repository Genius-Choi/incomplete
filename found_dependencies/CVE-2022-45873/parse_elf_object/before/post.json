[
    {
        "line": 2,
        "fullcodeline": "_cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 };"
    },
    {
        "line": 3,
        "fullcodeline": "_cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "_cleanup_free_ char *buf = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "assert(fd >= 0);"
    },
    {
        "line": 9,
        "fullcodeline": "r = dlopen_dw();"
    },
    {
        "line": 13,
        "fullcodeline": "r = dlopen_elf();"
    },
    {
        "line": 17,
        "fullcodeline": "r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));"
    },
    {
        "line": 39,
        "fullcodeline": "r = safe_fork_full(\"(sd-parse-elf)\","
    },
    {
        "line": 98,
        "fullcodeline": "error_pipe[1] = safe_close(error_pipe[1]);"
    },
    {
        "line": 99,
        "fullcodeline": "return_pipe[1] = safe_close(return_pipe[1]);"
    },
    {
        "line": 100,
        "fullcodeline": "json_pipe[1] = safe_close(json_pipe[1]);"
    },
    {
        "line": 10,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 14,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 18,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 44,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));"
    },
    {
        "line": 28,
        "fullcodeline": "r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));"
    },
    {
        "line": 40,
        "fullcodeline": "(int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] },"
    },
    {
        "line": 42,
        "fullcodeline": "FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG,"
    },
    {
        "line": 67,
        "fullcodeline": "r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);"
    },
    {
        "line": 91,
        "fullcodeline": "_exit(EXIT_SUCCESS);"
    },
    {
        "line": 94,
        "fullcodeline": "(void) write(error_pipe[1], &r, sizeof(r));"
    },
    {
        "line": 95,
        "fullcodeline": "_exit(EXIT_FAILURE);"
    },
    {
        "line": 103,
        "fullcodeline": "_cleanup_fclose_ FILE *in = NULL;"
    },
    {
        "line": 105,
        "fullcodeline": "in = take_fdopen(&return_pipe[0], \"r\");"
    },
    {
        "line": 109,
        "fullcodeline": "r = read_full_stream(in, &buf, NULL);"
    },
    {
        "line": 115,
        "fullcodeline": "_cleanup_fclose_ FILE *json_in = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "json_in = take_fdopen(&json_pipe[0], \"r\");"
    },
    {
        "line": 121,
        "fullcodeline": "r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);"
    },
    {
        "line": 127,
        "fullcodeline": "*ret = TAKE_PTR(buf);"
    },
    {
        "line": 129,
        "fullcodeline": "*ret_package_metadata = TAKE_PTR(package_metadata);"
    },
    {
        "line": 23,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 29,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 45,
        "fullcodeline": "if (r == -EPROTO) { /* We should have the errno from the child, but don't clobber original error */"
    },
    {
        "line": 68,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 106,
        "fullcodeline": "if (!in)"
    },
    {
        "line": 110,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 118,
        "fullcodeline": "if (!json_in)"
    },
    {
        "line": 122,
        "fullcodeline": "if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */"
    },
    {
        "line": 48,
        "fullcodeline": "k = read(error_pipe[0], &e, sizeof(e));"
    },
    {
        "line": 62,
        "fullcodeline": "r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));"
    },
    {
        "line": 72,
        "fullcodeline": "r = loop_write(return_pipe[1], buf, strlen(buf), false);"
    },
    {
        "line": 76,
        "fullcodeline": "return_pipe[1] = safe_close(return_pipe[1]);"
    },
    {
        "line": 80,
        "fullcodeline": "_cleanup_fclose_ FILE *json_out = NULL;"
    },
    {
        "line": 82,
        "fullcodeline": "json_out = take_fdopen(&json_pipe[1], \"w\");"
    },
    {
        "line": 88,
        "fullcodeline": "json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);"
    },
    {
        "line": 49,
        "fullcodeline": "if (k < 0 && errno != EAGAIN) /* Pipe is non-blocking, EAGAIN means there's nothing */"
    },
    {
        "line": 51,
        "fullcodeline": "if (k == sizeof(e))"
    },
    {
        "line": 53,
        "fullcodeline": "if (k != 0)"
    },
    {
        "line": 63,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 73,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 83,
        "fullcodeline": "if (!json_out) {"
    },
    {
        "line": 107,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 119,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 84,
        "fullcodeline": "r = -errno;"
    },
    {
        "line": 50,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 54,
        "fullcodeline": "return -EIO;"
    }
]