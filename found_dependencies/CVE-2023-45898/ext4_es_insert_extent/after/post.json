[
    {
        "line": 6,
        "fullcodeline": "ext4_lblk_t end = lblk + len - 1;"
    },
    {
        "line": 7,
        "fullcodeline": "int err1 = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int err2 = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
    },
    {
        "line": 10,
        "fullcodeline": "struct extent_status *es1 = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "struct extent_status *es2 = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "es_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\","
    },
    {
        "line": 22,
        "fullcodeline": "BUG_ON(end < lblk);"
    },
    {
        "line": 32,
        "fullcodeline": "newes.es_lblk = lblk;"
    },
    {
        "line": 33,
        "fullcodeline": "newes.es_len = len;"
    },
    {
        "line": 34,
        "fullcodeline": "ext4_es_store_pblock_status(&newes, pblk, status);"
    },
    {
        "line": 35,
        "fullcodeline": "trace_ext4_es_insert_extent(inode, &newes);"
    },
    {
        "line": 37,
        "fullcodeline": "ext4_es_insert_extent_check(inode, &newes);"
    },
    {
        "line": 44,
        "fullcodeline": "write_lock(&EXT4_I(inode)->i_es_lock);"
    },
    {
        "line": 46,
        "fullcodeline": "err1 = __es_remove_extent(inode, lblk, end, NULL, es1);"
    },
    {
        "line": 56,
        "fullcodeline": "err2 = __es_insert_extent(inode, &newes, es2);"
    },
    {
        "line": 73,
        "fullcodeline": "write_unlock(&EXT4_I(inode)->i_es_lock);"
    },
    {
        "line": 77,
        "fullcodeline": "ext4_es_print_tree(inode);"
    },
    {
        "line": 13,
        "fullcodeline": "if (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)"
    },
    {
        "line": 19,
        "fullcodeline": "if (!len)"
    },
    {
        "line": 24,
        "fullcodeline": "if ((status & EXTENT_STATUS_DELAYED) &&"
    },
    {
        "line": 40,
        "fullcodeline": "if (err1 && !es1)"
    },
    {
        "line": 42,
        "fullcodeline": "if ((err1 || err2) && !es2)"
    },
    {
        "line": 47,
        "fullcodeline": "if (err1 != 0)"
    },
    {
        "line": 57,
        "fullcodeline": "if (err2 == -ENOMEM && !ext4_es_must_keep(&newes))"
    },
    {
        "line": 59,
        "fullcodeline": "if (err2 != 0)"
    },
    {
        "line": 68,
        "fullcodeline": "if (sbi->s_cluster_ratio > 1 && test_opt(inode->i_sb, DELALLOC) &&"
    },
    {
        "line": 74,
        "fullcodeline": "if (err1 || err2)"
    },
    {
        "line": 25,
        "fullcodeline": "(status & EXTENT_STATUS_WRITTEN)) {"
    },
    {
        "line": 26,
        "fullcodeline": "ext4_warning(inode->i_sb, \"Inserting extent [%u/%u] as \""
    },
    {
        "line": 29,
        "fullcodeline": "WARN_ON(1);"
    },
    {
        "line": 41,
        "fullcodeline": "es1 = __es_alloc_extent(true);"
    },
    {
        "line": 43,
        "fullcodeline": "es2 = __es_alloc_extent(true);"
    },
    {
        "line": 53,
        "fullcodeline": "es1 = NULL;"
    },
    {
        "line": 58,
        "fullcodeline": "err2 = 0;"
    },
    {
        "line": 65,
        "fullcodeline": "es2 = NULL;"
    },
    {
        "line": 69,
        "fullcodeline": "(status & EXTENT_STATUS_WRITTEN ||"
    },
    {
        "line": 71,
        "fullcodeline": "__revise_pending(inode, lblk, len);"
    },
    {
        "line": 51,
        "fullcodeline": "if (!es1->es_len)"
    },
    {
        "line": 63,
        "fullcodeline": "if (!es2->es_len)"
    },
    {
        "line": 70,
        "fullcodeline": "status & EXTENT_STATUS_UNWRITTEN))"
    },
    {
        "line": 52,
        "fullcodeline": "__es_free_extent(es1);"
    },
    {
        "line": 64,
        "fullcodeline": "__es_free_extent(es2);"
    }
]