[
    {
        "line": 6,
        "fullcodeline": "Elf64_Dyn const *const dynp0 = dynp;"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned ndx = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned const limit = headway / sizeof(*dynp);"
    },
    {
        "line": 36,
        "fullcodeline": "upx_dt_init = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "strtab_end = !z_str ? 0 : get_te64(&dynp0[-1+ z_str].d_val);"
    },
    {
        "line": 75,
        "fullcodeline": "unsigned const dt_names[] = { // *.d_val are often in this order"
    },
    {
        "line": 88,
        "fullcodeline": "unsigned dt_offsets[sizeof(dt_names)/sizeof(dt_names[0])];"
    },
    {
        "line": 89,
        "fullcodeline": "unsigned n_off = 0, k;"
    },
    {
        "line": 109,
        "fullcodeline": "dt_offsets[n_off++] = file_size;  // sentinel"
    },
    {
        "line": 110,
        "fullcodeline": "qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);"
    },
    {
        "line": 112,
        "fullcodeline": "unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);"
    },
    {
        "line": 159,
        "fullcodeline": "unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);"
    },
    {
        "line": 267,
        "fullcodeline": "unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);"
    },
    {
        "line": 43,
        "fullcodeline": "if (!z_str || (u64_t)file_size <= strtab_end) { // FIXME: weak"
    },
    {
        "line": 53,
        "fullcodeline": "if (x_sym && x_str) {"
    },
    {
        "line": 90,
        "fullcodeline": "for (unsigned j=0; ((k = dt_names[j]),  k); ++j) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (v_hsh && file_image) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (v_gsh && file_image) {"
    },
    {
        "line": 268,
        "fullcodeline": "if (e_shnum <= e_shstrndx"
    },
    {
        "line": 44,
        "fullcodeline": "char msg[50]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 46,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 54,
        "fullcodeline": "upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);"
    },
    {
        "line": 55,
        "fullcodeline": "upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);"
    },
    {
        "line": 57,
        "fullcodeline": "unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)"
    },
    {
        "line": 91,
        "fullcodeline": "dt_offsets[n_off] = 0;  // default to \"not found\""
    },
    {
        "line": 107,
        "fullcodeline": "n_off += !!dt_offsets[n_off];"
    },
    {
        "line": 114,
        "fullcodeline": "hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);"
    },
    {
        "line": 129,
        "fullcodeline": "unsigned const nbucket = get_te32(&hashtab[0]);"
    },
    {
        "line": 130,
        "fullcodeline": "unsigned const *const buckets = &hashtab[2];"
    },
    {
        "line": 131,
        "fullcodeline": "unsigned const *const chains = &buckets[nbucket]; (void)chains;"
    },
    {
        "line": 133,
        "fullcodeline": "unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);"
    },
    {
        "line": 143,
        "fullcodeline": "unsigned chmax = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);"
    },
    {
        "line": 176,
        "fullcodeline": "unsigned const n_bucket = get_te32(&gashtab[0]);"
    },
    {
        "line": 177,
        "fullcodeline": "unsigned const symbias  = get_te32(&gashtab[1]);"
    },
    {
        "line": 178,
        "fullcodeline": "unsigned const n_bitmask = get_te32(&gashtab[2]);"
    },
    {
        "line": 179,
        "fullcodeline": "unsigned const gnu_shift = get_te32(&gashtab[3]);"
    },
    {
        "line": 180,
        "fullcodeline": "upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];"
    },
    {
        "line": 181,
        "fullcodeline": "unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];"
    },
    {
        "line": 182,
        "fullcodeline": "unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;"
    },
    {
        "line": 192,
        "fullcodeline": "unsigned bmax = 0;"
    },
    {
        "line": 218,
        "fullcodeline": "bmax -= symbias;"
    },
    {
        "line": 221,
        "fullcodeline": "Elf64_Shdr const *sec_gash = elf_find_section_type(Elf64_Shdr::SHT_GNU_HASH);"
    },
    {
        "line": 222,
        "fullcodeline": "unsigned const off_symtab = elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB);"
    },
    {
        "line": 223,
        "fullcodeline": "unsigned const off_strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);"
    },
    {
        "line": 224,
        "fullcodeline": "unsigned const off_gshtab = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);"
    },
    {
        "line": 246,
        "fullcodeline": "upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);"
    },
    {
        "line": 247,
        "fullcodeline": "unsigned r = 0;"
    },
    {
        "line": 269,
        "fullcodeline": "&&  !(0==e_shnum && 0==e_shstrndx) ) {"
    },
    {
        "line": 270,
        "fullcodeline": "char msg[40]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 272,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 10,
        "fullcodeline": "for (; ; ++ndx, ++dynp) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (sz_sym < sizeof(Elf64_Sym)) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (v_sym < v_str) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (symnum_end < 1) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (k < DT_NUM) { // in range of easy table"
    },
    {
        "line": 102,
        "fullcodeline": "if (file_size <= dt_offsets[n_off]) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (!hashtab) {"
    },
    {
        "line": 120,
        "fullcodeline": "for (unsigned j = 0; j < n_off; ++j) {"
    },
    {
        "line": 134,
        "fullcodeline": "if ((unsigned)file_size <= nbucket/sizeof(*buckets)  // FIXME: weak"
    },
    {
        "line": 144,
        "fullcodeline": "for (unsigned j= 0; j < nbucket; ++j) {"
    },
    {
        "line": 150,
        "fullcodeline": "if ((v_hsh < v_sym) && (v_sym - v_hsh) <"
    },
    {
        "line": 162,
        "fullcodeline": "if (!gashtab) {"
    },
    {
        "line": 167,
        "fullcodeline": "for (unsigned j = 0; j < n_off; ++j) { // linear search of short table"
    },
    {
        "line": 183,
        "fullcodeline": "if (!n_bucket || (1u<<31) <= n_bucket  /* fie on fuzzers */"
    },
    {
        "line": 193,
        "fullcodeline": "for (unsigned j= 0; j < n_bucket; ++j) {"
    },
    {
        "line": 207,
        "fullcodeline": "if (1==n_bucket  && 0==buckets[0]"
    },
    {
        "line": 225,
        "fullcodeline": "if (off_gshtab < file_size  // paranoia"
    },
    {
        "line": 248,
        "fullcodeline": "if (!n_bucket || !n_bitmask || !v_sym"
    },
    {
        "line": 14,
        "fullcodeline": "upx_uint64_t const d_tag = get_te64(&dynp->d_tag);"
    },
    {
        "line": 60,
        "fullcodeline": "char msg[50]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 62,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 65,
        "fullcodeline": "symnum_end = (v_str - v_sym) / sz_sym;"
    },
    {
        "line": 68,
        "fullcodeline": "throwCantPack(\"bad DT_SYMTAB\");"
    },
    {
        "line": 103,
        "fullcodeline": "char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\","
    },
    {
        "line": 105,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 116,
        "fullcodeline": "char msg[40]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 118,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 136,
        "fullcodeline": "|| ((v_hsh < v_sym) && (v_sym - v_hsh) < sizeof(*buckets)*(2+ nbucket))"
    },
    {
        "line": 138,
        "fullcodeline": "char msg[80]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 141,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 145,
        "fullcodeline": "unsigned x = get_te32(&buckets[j]);"
    },
    {
        "line": 152,
        "fullcodeline": "char msg[80]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 155,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 163,
        "fullcodeline": "char msg[40]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 165,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 184,
        "fullcodeline": "|| (void const *)&file_image[file_size] <= (void const *)hasharr) {"
    },
    {
        "line": 185,
        "fullcodeline": "char msg[80]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 187,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 194,
        "fullcodeline": "unsigned bj = get_te32(&buckets[j]);"
    },
    {
        "line": 208,
        "fullcodeline": "&&  1==n_bitmask && 0==bitmask[0]) {"
    },
    {
        "line": 227,
        "fullcodeline": "&&  off_symtab < file_size ) {"
    },
    {
        "line": 228,
        "fullcodeline": "unsigned sz_gshtab = 0;"
    },
    {
        "line": 255,
        "fullcodeline": "|| (r=6, ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers"
    },
    {
        "line": 261,
        "fullcodeline": "char msg[90]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 264,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 11,
        "fullcodeline": "if (limit <= ndx) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (d_tag>>32) { // outrageous"
    },
    {
        "line": 20,
        "fullcodeline": "if (d_tag < DT_NUM) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (Elf64_Dyn::DT_NULL == d_tag) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (v_hsh == dt_offsets[j]) {"
    },
    {
        "line": 135,
        "fullcodeline": "|| !v_sym || (unsigned)file_size <= v_sym"
    },
    {
        "line": 140,
        "fullcodeline": "nbucket, (v_sym - v_hsh));"
    },
    {
        "line": 146,
        "fullcodeline": "if (chmax < x) {"
    },
    {
        "line": 151,
        "fullcodeline": "(sizeof(*buckets)*(2+ nbucket) + sizeof(*chains)*(1+ chmax))) {"
    },
    {
        "line": 154,
        "fullcodeline": "nbucket, (v_sym - v_hsh));"
    },
    {
        "line": 168,
        "fullcodeline": "if (v_gsh == dt_offsets[j]) {"
    },
    {
        "line": 226,
        "fullcodeline": "&&  off_strtab < file_size"
    },
    {
        "line": 229,
        "fullcodeline": "if (sec_gash && off_gshtab == get_te32(&sec_gash->sh_offset)) {"
    },
    {
        "line": 240,
        "fullcodeline": "if (sz_gshtab <= (file_size - off_gshtab)) {"
    },
    {
        "line": 253,
        "fullcodeline": "|| (r=5, ((file_size/sizeof(unsigned))"
    },
    {
        "line": 263,
        "fullcodeline": "n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh), r);"
    },
    {
        "line": 12,
        "fullcodeline": "throwCantPack(\"DT_NULL not found\");"
    },
    {
        "line": 16,
        "fullcodeline": "char msg[50]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 18,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 30,
        "fullcodeline": "dt_table[d_tag] = 1+ ndx;"
    },
    {
        "line": 94,
        "fullcodeline": "dt_offsets[n_off] = get_te64(&dynp0[-1+ dt_table[k]].d_val);"
    },
    {
        "line": 147,
        "fullcodeline": "chmax = x;"
    },
    {
        "line": 213,
        "fullcodeline": "if ((1+ bmax) < symbias) {"
    },
    {
        "line": 230,
        "fullcodeline": "sz_gshtab = get_te32(&sec_gash->sh_size);"
    },
    {
        "line": 241,
        "fullcodeline": "gashend = (unsigned const *)(void const *)"
    },
    {
        "line": 252,
        "fullcodeline": "|| (r=4, (n_bitmask>>30))"
    },
    {
        "line": 17,
        "fullcodeline": "\"bad Elf64_Dyn[%d].d_tag %#lx\", ndx, (long unsigned)d_tag);"
    },
    {
        "line": 21,
        "fullcodeline": "if (Elf64_Dyn::DT_NEEDED != d_tag"
    },
    {
        "line": 99,
        "fullcodeline": "dt_offsets[n_off] = elf_unsigned_dynamic(k);  // zero if not found"
    },
    {
        "line": 196,
        "fullcodeline": "if (bj < symbias) {"
    },
    {
        "line": 202,
        "fullcodeline": "if (bmax < bj) {"
    },
    {
        "line": 214,
        "fullcodeline": "char msg[90]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 216,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 251,
        "fullcodeline": "|| (r=3, (n_bucket>>30))  // fie on fuzzers"
    },
    {
        "line": 23,
        "fullcodeline": "&&    get_te64(&dynp->d_val)"
    },
    {
        "line": 25,
        "fullcodeline": "char msg[50]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 28,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 58,
        "fullcodeline": ": get_te64(&dynp0[-1+ z_sym].d_val);"
    },
    {
        "line": 122,
        "fullcodeline": "if (dt_offsets[1+ j]) {"
    },
    {
        "line": 123,
        "fullcodeline": "hashend = (unsigned const *)(void const *)"
    },
    {
        "line": 169,
        "fullcodeline": "if (dt_offsets[1+ j]) {"
    },
    {
        "line": 170,
        "fullcodeline": "gashend = (unsigned const *)(void const *)"
    },
    {
        "line": 197,
        "fullcodeline": "char msg[90]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 200,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 203,
        "fullcodeline": "bmax = bj;"
    },
    {
        "line": 215,
        "fullcodeline": "\"bad DT_GNU_HASH (1+ max_bucket)=%#x < symbias=%#x\", 1+ bmax, symbias);"
    },
    {
        "line": 233,
        "fullcodeline": "if (off_gshtab < off_strtab) {"
    },
    {
        "line": 250,
        "fullcodeline": "|| (r=2, (8*sizeof(upx_uint64_t) <= gnu_shift))  // shifted result always == 0"
    },
    {
        "line": 254,
        "fullcodeline": "<= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)))  // FIXME: weak"
    },
    {
        "line": 27,
        "fullcodeline": "(unsigned)d_tag, -1+ dt_table[d_tag], ndx);"
    },
    {
        "line": 234,
        "fullcodeline": "sz_gshtab = off_strtab - off_gshtab;"
    },
    {
        "line": 242,
        "fullcodeline": "(sz_gshtab + (char const *)gashtab);"
    },
    {
        "line": 249,
        "fullcodeline": "|| (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2"
    },
    {
        "line": 258,
        "fullcodeline": "+ sizeof(*hasharr)*(1+ bmax)  // hasharr"
    },
    {
        "line": 257,
        "fullcodeline": "+ sizeof(*buckets)*n_bucket  // buckets"
    },
    {
        "line": 124,
        "fullcodeline": "((dt_offsets[1+ j] - dt_offsets[j]) + (char const *)hashtab);"
    },
    {
        "line": 171,
        "fullcodeline": "((dt_offsets[1+ j] - dt_offsets[j]) + (char const *)gashtab);"
    },
    {
        "line": 236,
        "fullcodeline": "else if (off_gshtab < off_symtab) {"
    },
    {
        "line": 256,
        "fullcodeline": "+ sizeof(*bitmask)*n_bitmask  // bitmask"
    },
    {
        "line": 237,
        "fullcodeline": "sz_gshtab = off_symtab - off_gshtab;"
    },
    {
        "line": 24,
        "fullcodeline": "!= get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {"
    }
]