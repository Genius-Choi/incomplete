[
    {
        "line": 2,
        "fullcodeline": "int mode = MODE_ENCODE;"
    },
    {
        "line": 5,
        "fullcodeline": "char *input = NULL, *output = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "char *f1 = NULL, *f2 = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "int force = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "int force_stdstreams = 0, workers = 0, batch = 0, verbose = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "u32 block_size = MiB(16);"
    },
    {
        "line": 18,
        "fullcodeline": "const char * short_options = \"Bb:cdefhktvVz\";"
    },
    {
        "line": 21,
        "fullcodeline": "static struct option long_options[] = { { \"encode\", no_argument, 0, 'e' },"
    },
    {
        "line": 237,
        "fullcodeline": "FILE *input_des = NULL, *output_des = NULL;"
    },
    {
        "line": 239,
        "fullcodeline": "output_des = mode != MODE_TEST ? open_output(output, force) : NULL;"
    },
    {
        "line": 240,
        "fullcodeline": "input_des = open_input(input);"
    },
    {
        "line": 245,
        "fullcodeline": "int r = process(input_des, output_des, mode, block_size, workers, verbose, input);"
    },
    {
        "line": 247,
        "fullcodeline": "fclose(input_des);"
    },
    {
        "line": 248,
        "fullcodeline": "close_out_file(output_des);"
    },
    {
        "line": 99,
        "fullcodeline": "if (block_size < KiB(65) || block_size > MiB(511)) {"
    },
    {
        "line": 177,
        "fullcodeline": "while (optind < argc) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (f1 == NULL && f2 == NULL)"
    },
    {
        "line": 242,
        "fullcodeline": "if(output != f2)"
    },
    {
        "line": 249,
        "fullcodeline": "if (fclose(stdout)) {"
    },
    {
        "line": 22,
        "fullcodeline": "{ \"decode\", no_argument, 0, 'd' },"
    },
    {
        "line": 23,
        "fullcodeline": "{ \"test\", no_argument, 0, 't' },"
    },
    {
        "line": 24,
        "fullcodeline": "{ \"stdout\", no_argument, 0, 'c' },"
    },
    {
        "line": 25,
        "fullcodeline": "{ \"force\", no_argument, 0, 'f' },"
    },
    {
        "line": 26,
        "fullcodeline": "{ \"help\", no_argument, 0, 'h' },"
    },
    {
        "line": 27,
        "fullcodeline": "{ \"keep\", no_argument, 0, 'k' },"
    },
    {
        "line": 28,
        "fullcodeline": "{ \"version\", no_argument, 0, 'V' },"
    },
    {
        "line": 29,
        "fullcodeline": "{ \"verbose\", no_argument, 0, 'v' },"
    },
    {
        "line": 30,
        "fullcodeline": "{ \"block\", required_argument, 0, 'b' },"
    },
    {
        "line": 31,
        "fullcodeline": "{ \"batch\", no_argument, 0, 'B' },"
    },
    {
        "line": 35,
        "fullcodeline": "{ 0, 0, 0, 0 } };"
    },
    {
        "line": 38,
        "fullcodeline": "int option_index = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "int c = getopt_long(argc, argv, short_options, long_options, &option_index);"
    },
    {
        "line": 100,
        "fullcodeline": "fprintf(stderr, \"Block size must be between 65 KiB and 511 MiB.\\n\");"
    },
    {
        "line": 179,
        "fullcodeline": "char * arg = argv[optind++];"
    },
    {
        "line": 193,
        "fullcodeline": "input = NULL, output = NULL;"
    },
    {
        "line": 243,
        "fullcodeline": "free(output);"
    },
    {
        "line": 250,
        "fullcodeline": "fprintf(stderr, \"Error: Failed on fclose(stdout): %s\\n\", strerror(errno));"
    },
    {
        "line": 40,
        "fullcodeline": "if (c == -1) break;"
    },
    {
        "line": 169,
        "fullcodeline": "if (fclose(stdout)) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (f1 != NULL && f2 != NULL) {"
    },
    {
        "line": 186,
        "fullcodeline": "if (f1 == NULL)"
    },
    {
        "line": 44,
        "fullcodeline": "fprintf(stderr, \"Try 'bzip3 --help' for more information.\\n\");"
    },
    {
        "line": 47,
        "fullcodeline": "mode = MODE_ENCODE;"
    },
    {
        "line": 50,
        "fullcodeline": "mode = MODE_DECODE;"
    },
    {
        "line": 53,
        "fullcodeline": "mode = MODE_TEST;"
    },
    {
        "line": 56,
        "fullcodeline": "force_stdstreams = 1;"
    },
    {
        "line": 59,
        "fullcodeline": "force = 1;"
    },
    {
        "line": 64,
        "fullcodeline": "help();"
    },
    {
        "line": 67,
        "fullcodeline": "version();"
    },
    {
        "line": 70,
        "fullcodeline": "batch = 1;"
    },
    {
        "line": 73,
        "fullcodeline": "verbose = 1;"
    },
    {
        "line": 80,
        "fullcodeline": "block_size = MiB(atoi(optarg));"
    },
    {
        "line": 170,
        "fullcodeline": "fprintf(stderr, \"Error: Failed on fclose(stdout): %s\\n\", strerror(errno));"
    },
    {
        "line": 182,
        "fullcodeline": "fprintf(stderr, \"Error: too many files specified.\\n\");"
    },
    {
        "line": 187,
        "fullcodeline": "f1 = arg;"
    },
    {
        "line": 194,
        "fullcodeline": "else if (mode == MODE_TEST)"
    },
    {
        "line": 76,
        "fullcodeline": "if (!is_numeric(optarg)) {"
    },
    {
        "line": 108,
        "fullcodeline": "while (optind < argc) {"
    },
    {
        "line": 131,
        "fullcodeline": "while (optind < argc) {"
    },
    {
        "line": 159,
        "fullcodeline": "while (optind < argc) {"
    },
    {
        "line": 189,
        "fullcodeline": "f2 = arg;"
    },
    {
        "line": 195,
        "fullcodeline": "input = f1;"
    },
    {
        "line": 77,
        "fullcodeline": "fprintf(stderr, \"bzip3: invalid block size: %s\\n\", optarg);"
    },
    {
        "line": 109,
        "fullcodeline": "char * arg = argv[optind++];"
    },
    {
        "line": 111,
        "fullcodeline": "FILE * input_des = open_input(arg);"
    },
    {
        "line": 121,
        "fullcodeline": "FILE * output_des = open_output(output_name, force);"
    },
    {
        "line": 122,
        "fullcodeline": "process(input_des, output_des, mode, block_size, workers, verbose, arg);"
    },
    {
        "line": 124,
        "fullcodeline": "fclose(input_des);"
    },
    {
        "line": 125,
        "fullcodeline": "close_out_file(output_des);"
    },
    {
        "line": 132,
        "fullcodeline": "char * arg = argv[optind++];"
    },
    {
        "line": 134,
        "fullcodeline": "FILE * input_des = open_input(arg);"
    },
    {
        "line": 149,
        "fullcodeline": "FILE * output_des = open_output(output_name, force);"
    },
    {
        "line": 150,
        "fullcodeline": "process(input_des, output_des, mode, block_size, workers, verbose, arg);"
    },
    {
        "line": 152,
        "fullcodeline": "fclose(input_des);"
    },
    {
        "line": 153,
        "fullcodeline": "close_out_file(output_des);"
    },
    {
        "line": 160,
        "fullcodeline": "char * arg = argv[optind++];"
    },
    {
        "line": 162,
        "fullcodeline": "FILE * input_des = open_input(arg);"
    },
    {
        "line": 163,
        "fullcodeline": "process(input_des, NULL, mode, block_size, workers, verbose, arg);"
    },
    {
        "line": 164,
        "fullcodeline": "fclose(input_des);"
    },
    {
        "line": 126,
        "fullcodeline": "if (!force_stdstreams) free(output_name);"
    },
    {
        "line": 154,
        "fullcodeline": "if (!force_stdstreams) free(output_name);"
    },
    {
        "line": 197,
        "fullcodeline": "if (mode == MODE_ENCODE) {"
    },
    {
        "line": 114,
        "fullcodeline": "output_name = NULL;"
    },
    {
        "line": 137,
        "fullcodeline": "output_name = NULL;"
    },
    {
        "line": 116,
        "fullcodeline": "output_name = malloc(strlen(arg) + 5);"
    },
    {
        "line": 117,
        "fullcodeline": "strcpy(output_name, arg);"
    },
    {
        "line": 118,
        "fullcodeline": "strcat(output_name, \".bz3\");"
    },
    {
        "line": 139,
        "fullcodeline": "output_name = malloc(strlen(arg) + 1);"
    },
    {
        "line": 140,
        "fullcodeline": "strcpy(output_name, arg);"
    },
    {
        "line": 198,
        "fullcodeline": "if (f2 == NULL) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (strlen(output_name) > 4 && !strcmp(output_name + strlen(output_name) - 4, \".bz3\"))"
    },
    {
        "line": 200,
        "fullcodeline": "input = f1;"
    },
    {
        "line": 213,
        "fullcodeline": "} else if (mode == MODE_DECODE) {"
    },
    {
        "line": 142,
        "fullcodeline": "output_name[strlen(output_name) - 4] = 0;"
    },
    {
        "line": 210,
        "fullcodeline": "input = f1;"
    },
    {
        "line": 211,
        "fullcodeline": "output = f2;"
    },
    {
        "line": 144,
        "fullcodeline": "fprintf(stderr, \"Warning: file %s has an unknown extension, skipping.\\n\", arg);"
    },
    {
        "line": 202,
        "fullcodeline": "output = NULL;"
    },
    {
        "line": 214,
        "fullcodeline": "if (f2 == NULL) {"
    },
    {
        "line": 204,
        "fullcodeline": "output = malloc(strlen(f1) + 5);"
    },
    {
        "line": 205,
        "fullcodeline": "strcpy(output, f1);"
    },
    {
        "line": 206,
        "fullcodeline": "strcat(output, \".bz3\");"
    },
    {
        "line": 216,
        "fullcodeline": "input = f1;"
    },
    {
        "line": 231,
        "fullcodeline": "input = f1;"
    },
    {
        "line": 232,
        "fullcodeline": "output = f2;"
    },
    {
        "line": 218,
        "fullcodeline": "output = NULL;"
    },
    {
        "line": 220,
        "fullcodeline": "output = malloc(strlen(f1) + 1);"
    },
    {
        "line": 221,
        "fullcodeline": "strcpy(output, f1);"
    },
    {
        "line": 222,
        "fullcodeline": "if (strlen(output) > 4 && !strcmp(output + strlen(output) - 4, \".bz3\"))"
    },
    {
        "line": 223,
        "fullcodeline": "output[strlen(output) - 4] = 0;"
    },
    {
        "line": 225,
        "fullcodeline": "fprintf(stderr, \"Warning: file %s has an unknown extension, skipping.\\n\", f1);"
    }
]