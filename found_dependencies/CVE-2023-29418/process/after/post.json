[
    {
        "line": 2,
        "fullcodeline": "uint64_t bytes_read = 0, bytes_written = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "u8 byteswap_buf[4];"
    },
    {
        "line": 57,
        "fullcodeline": "struct bz3_state * state = bz3_new(block_size);"
    },
    {
        "line": 64,
        "fullcodeline": "u8 * buffer = malloc(block_size + block_size / 50 + 32);"
    },
    {
        "line": 141,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 143,
        "fullcodeline": "bz3_free(state);"
    },
    {
        "line": 4,
        "fullcodeline": "if ((mode == MODE_ENCODE && isatty(fileno(output_des))) ||"
    },
    {
        "line": 59,
        "fullcodeline": "if (state == NULL) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (!buffer) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (mode == MODE_ENCODE) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (bz3_last_error(state) != BZ3_OK) {"
    },
    {
        "line": 5,
        "fullcodeline": "((mode == MODE_DECODE || mode == MODE_TEST) && isatty(fileno(input_des)))) {"
    },
    {
        "line": 6,
        "fullcodeline": "fprintf(stderr, \"Refusing to read/write binary data from/to the terminal.\\n\");"
    },
    {
        "line": 17,
        "fullcodeline": "xwrite(\"BZ3v1\", 5, 1, output_des);"
    },
    {
        "line": 19,
        "fullcodeline": "write_neutral_s32(byteswap_buf, block_size);"
    },
    {
        "line": 20,
        "fullcodeline": "xwrite(byteswap_buf, 4, 1, output_des);"
    },
    {
        "line": 22,
        "fullcodeline": "bytes_written += 9;"
    },
    {
        "line": 60,
        "fullcodeline": "fprintf(stderr, \"Failed to create a block encoder state.\\n\");"
    },
    {
        "line": 67,
        "fullcodeline": "fprintf(stderr, \"Failed to allocate memory.\\n\");"
    },
    {
        "line": 93,
        "fullcodeline": "fflush(output_des);"
    },
    {
        "line": 137,
        "fullcodeline": "fprintf(stderr, \"Failed to read data: %s\\n\", bz3_strerror(state));"
    },
    {
        "line": 26,
        "fullcodeline": "char signature[5];"
    },
    {
        "line": 33,
        "fullcodeline": "xread_noeof(byteswap_buf, 4, 1, input_des);"
    },
    {
        "line": 35,
        "fullcodeline": "block_size = read_neutral_s32(byteswap_buf);"
    },
    {
        "line": 44,
        "fullcodeline": "bytes_read += 9;"
    },
    {
        "line": 73,
        "fullcodeline": "while (!feof(input_des)) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (xread(signature, 5, 1, input_des) != 1 || strncmp(signature, \"BZ3v1\", 5) != 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (block_size < KiB(65) || block_size > MiB(511)) {"
    },
    {
        "line": 74,
        "fullcodeline": "read_count = xread(buffer, 1, block_size, input_des);"
    },
    {
        "line": 75,
        "fullcodeline": "bytes_read += read_count;"
    },
    {
        "line": 80,
        "fullcodeline": "s32 new_size = bz3_encode_block(state, buffer, read_count);"
    },
    {
        "line": 86,
        "fullcodeline": "write_neutral_s32(byteswap_buf, new_size);"
    },
    {
        "line": 87,
        "fullcodeline": "xwrite(byteswap_buf, 4, 1, output_des);"
    },
    {
        "line": 88,
        "fullcodeline": "write_neutral_s32(byteswap_buf, read_count);"
    },
    {
        "line": 89,
        "fullcodeline": "xwrite(byteswap_buf, 4, 1, output_des);"
    },
    {
        "line": 90,
        "fullcodeline": "xwrite(buffer, new_size, 1, output_des);"
    },
    {
        "line": 91,
        "fullcodeline": "bytes_written += 8 + new_size;"
    },
    {
        "line": 94,
        "fullcodeline": "} else if (mode == MODE_DECODE) {"
    },
    {
        "line": 253,
        "fullcodeline": "if(file_name) fprintf(stderr, \" %s:\", file_name);"
    },
    {
        "line": 29,
        "fullcodeline": "fprintf(stderr, \"Invalid signature.\\n\");"
    },
    {
        "line": 38,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 77,
        "fullcodeline": "if(read_count == 0)"
    },
    {
        "line": 81,
        "fullcodeline": "if (new_size == -1) {"
    },
    {
        "line": 115,
        "fullcodeline": "fflush(output_des);"
    },
    {
        "line": 82,
        "fullcodeline": "fprintf(stderr, \"Failed to encode a block: %s\\n\", bz3_strerror(state));"
    },
    {
        "line": 96,
        "fullcodeline": "while (!feof(input_des)) {"
    },
    {
        "line": 99,
        "fullcodeline": "new_size = read_neutral_s32(byteswap_buf);"
    },
    {
        "line": 100,
        "fullcodeline": "xread_noeof(&byteswap_buf, 1, 4, input_des);"
    },
    {
        "line": 101,
        "fullcodeline": "old_size = read_neutral_s32(byteswap_buf);"
    },
    {
        "line": 106,
        "fullcodeline": "xread_noeof(buffer, 1, new_size, input_des);"
    },
    {
        "line": 107,
        "fullcodeline": "bytes_read += 8 + new_size;"
    },
    {
        "line": 112,
        "fullcodeline": "xwrite(buffer, old_size, 1, output_des);"
    },
    {
        "line": 113,
        "fullcodeline": "bytes_written += old_size;"
    },
    {
        "line": 116,
        "fullcodeline": "} else if (mode == MODE_TEST) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;"
    },
    {
        "line": 102,
        "fullcodeline": "if(old_size > block_size + 31) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {"
    },
    {
        "line": 103,
        "fullcodeline": "fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\");"
    },
    {
        "line": 109,
        "fullcodeline": "fprintf(stderr, \"Failed to decode a block: %s\\n\", bz3_strerror(state));"
    },
    {
        "line": 118,
        "fullcodeline": "while (!feof(input_des)) {"
    },
    {
        "line": 120,
        "fullcodeline": "new_size = read_neutral_s32(byteswap_buf);"
    },
    {
        "line": 121,
        "fullcodeline": "xread_noeof(&byteswap_buf, 1, 4, input_des);"
    },
    {
        "line": 122,
        "fullcodeline": "old_size = read_neutral_s32(byteswap_buf);"
    },
    {
        "line": 127,
        "fullcodeline": "xread_noeof(buffer, 1, new_size, input_des);"
    },
    {
        "line": 128,
        "fullcodeline": "bytes_read += 8 + new_size;"
    },
    {
        "line": 119,
        "fullcodeline": "if (!xread_eofcheck(&byteswap_buf, 1, 4, input_des)) continue;"
    },
    {
        "line": 123,
        "fullcodeline": "if(old_size > block_size + 31) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (bz3_decode_block(state, buffer, new_size, old_size) == -1) {"
    },
    {
        "line": 124,
        "fullcodeline": "fprintf(stderr, \"Failed to decode a block: Inconsistent headers.\\n\");"
    },
    {
        "line": 130,
        "fullcodeline": "fprintf(stderr, \"Failed to decode a block: %s\\n\", bz3_strerror(state));"
    }
]