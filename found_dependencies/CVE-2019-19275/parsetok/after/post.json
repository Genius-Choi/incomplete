[
    {
        "line": 6,
        "fullcodeline": "int started = 0;"
    },
    {
        "line": 185,
        "fullcodeline": "PyParser_Delete(ps);"
    },
    {
        "line": 229,
        "fullcodeline": "PyTokenizer_Free(tok);"
    },
    {
        "line": 10,
        "fullcodeline": "if (!growable_int_array_init(&type_ignores, 10)) {"
    },
    {
        "line": 16,
        "fullcodeline": "if ((ps = PyParser_New(g, start)) == NULL) {"
    },
    {
        "line": 127,
        "fullcodeline": "if (err_ret->error == E_DONE) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (n == NULL) {"
    },
    {
        "line": 231,
        "fullcodeline": "if (n != NULL) {"
    },
    {
        "line": 11,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 12,
        "fullcodeline": "PyTokenizer_Free(tok);"
    },
    {
        "line": 17,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 18,
        "fullcodeline": "PyTokenizer_Free(tok);"
    },
    {
        "line": 33,
        "fullcodeline": "col_offset = -1;"
    },
    {
        "line": 37,
        "fullcodeline": "type = PyTokenizer_Get(tok, &a, &b);"
    },
    {
        "line": 57,
        "fullcodeline": "len = (a != NULL && b != NULL) ? b - a : 0;"
    },
    {
        "line": 58,
        "fullcodeline": "str = (char *) PyObject_MALLOC(len + 1);"
    },
    {
        "line": 65,
        "fullcodeline": "str[len] = '\\0';"
    },
    {
        "line": 89,
        "fullcodeline": "lineno = type == STRING ? tok->first_lineno : tok->lineno;"
    },
    {
        "line": 90,
        "fullcodeline": "line_start = type == STRING ? tok->multi_line_start : tok->line_start;"
    },
    {
        "line": 128,
        "fullcodeline": "n = ps->p_tree;"
    },
    {
        "line": 129,
        "fullcodeline": "ps->p_tree = NULL;"
    },
    {
        "line": 147,
        "fullcodeline": "growable_int_array_deallocate(&type_ignores);"
    },
    {
        "line": 190,
        "fullcodeline": "err_ret->lineno = tok->lineno;"
    },
    {
        "line": 232,
        "fullcodeline": "_PyNode_FinalizeEndPos(n);"
    },
    {
        "line": 38,
        "fullcodeline": "if (type == ERRORTOKEN) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (type == ENDMARKER && started) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (str == NULL) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (len > 0)"
    },
    {
        "line": 91,
        "fullcodeline": "if (a != NULL && a >= line_start) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (b != NULL && b >= tok->line_start) {"
    },
    {
        "line": 107,
        "fullcodeline": "if (type == TYPE_IGNORE) {"
    },
    {
        "line": 115,
        "fullcodeline": "if ((err_ret->error ="
    },
    {
        "line": 131,
        "fullcodeline": "if (n->n_type == file_input) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (start == single_input) {"
    },
    {
        "line": 180,
        "fullcodeline": "n = NULL;"
    },
    {
        "line": 188,
        "fullcodeline": "if (tok->done == E_EOF)"
    },
    {
        "line": 191,
        "fullcodeline": "if (tok->buf != NULL) {"
    },
    {
        "line": 39,
        "fullcodeline": "err_ret->error = tok->done;"
    },
    {
        "line": 43,
        "fullcodeline": "type = NEWLINE; /* Add an extra newline */"
    },
    {
        "line": 44,
        "fullcodeline": "started = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 64,
        "fullcodeline": "strncpy(str, a, len);"
    },
    {
        "line": 137,
        "fullcodeline": "num = NCH(n);"
    },
    {
        "line": 138,
        "fullcodeline": "ch = CHILD(n, num - 1);"
    },
    {
        "line": 139,
        "fullcodeline": "REQ(ch, ENDMARKER);"
    },
    {
        "line": 155,
        "fullcodeline": "char *cur = tok->cur;"
    },
    {
        "line": 189,
        "fullcodeline": "err_ret->error = E_EOF;"
    },
    {
        "line": 193,
        "fullcodeline": "assert(tok->cur - tok->buf < INT_MAX);"
    },
    {
        "line": 197,
        "fullcodeline": "err_ret->offset = col_offset != -1 ? col_offset + 1 : ((int)(tok->cur - tok->buf));"
    },
    {
        "line": 198,
        "fullcodeline": "len = tok->inp - tok->buf;"
    },
    {
        "line": 199,
        "fullcodeline": "err_ret->text = (char *) PyObject_MALLOC(len + 1);"
    },
    {
        "line": 206,
        "fullcodeline": "} else if (tok->encoding != NULL) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (tok->indent &&"
    },
    {
        "line": 56,
        "fullcodeline": "started = 1;"
    },
    {
        "line": 96,
        "fullcodeline": "col_offset = -1;"
    },
    {
        "line": 104,
        "fullcodeline": "end_col_offset = -1;"
    },
    {
        "line": 108,
        "fullcodeline": "if (!growable_int_array_add(&type_ignores, tok->lineno)) {"
    },
    {
        "line": 116,
        "fullcodeline": "PyParser_AddToken(ps, (int)type, str,"
    },
    {
        "line": 119,
        "fullcodeline": "if (err_ret->error != E_DONE) {"
    },
    {
        "line": 141,
        "fullcodeline": "for (i = 0; i < type_ignores.num_items; i++) {"
    },
    {
        "line": 200,
        "fullcodeline": "if (err_ret->text != NULL) {"
    },
    {
        "line": 210,
        "fullcodeline": "node* r = PyNode_New(encoding_decl);"
    },
    {
        "line": 220,
        "fullcodeline": "strcpy(r->n_str, tok->encoding);"
    },
    {
        "line": 221,
        "fullcodeline": "PyMem_FREE(tok->encoding);"
    },
    {
        "line": 222,
        "fullcodeline": "tok->encoding = NULL;"
    },
    {
        "line": 223,
        "fullcodeline": "r->n_nchildren = 1;"
    },
    {
        "line": 224,
        "fullcodeline": "r->n_child = n;"
    },
    {
        "line": 225,
        "fullcodeline": "n = r;"
    },
    {
        "line": 49,
        "fullcodeline": "!(*flags & PyPARSE_DONT_IMPLY_DEDENT))"
    },
    {
        "line": 51,
        "fullcodeline": "tok->pendin = -tok->indent;"
    },
    {
        "line": 52,
        "fullcodeline": "tok->indent = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 120,
        "fullcodeline": "PyObject_FREE(str);"
    },
    {
        "line": 121,
        "fullcodeline": "err_ret->token = type;"
    },
    {
        "line": 142,
        "fullcodeline": "PyNode_AddChild(ch, TYPE_IGNORE, NULL,"
    },
    {
        "line": 203,
        "fullcodeline": "err_ret->text[len] = '\\0';"
    },
    {
        "line": 213,
        "fullcodeline": "if (!r || !r->n_str) {"
    },
    {
        "line": 159,
        "fullcodeline": "while (c == ' ' || c == '\\t' || c == '\\n' || c == '\\014')"
    },
    {
        "line": 162,
        "fullcodeline": "if (!c)"
    },
    {
        "line": 165,
        "fullcodeline": "if (c != '#') {"
    },
    {
        "line": 173,
        "fullcodeline": "while (c && c != '\\n')"
    },
    {
        "line": 201,
        "fullcodeline": "if (len > 0)"
    },
    {
        "line": 212,
        "fullcodeline": "r->n_str = PyObject_MALLOC(strlen(tok->encoding)+1);"
    },
    {
        "line": 214,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 217,
        "fullcodeline": "n = NULL;"
    },
    {
        "line": 166,
        "fullcodeline": "err_ret->error = E_BADSINGLE;"
    },
    {
        "line": 167,
        "fullcodeline": "PyNode_Free(n);"
    },
    {
        "line": 168,
        "fullcodeline": "n = NULL;"
    },
    {
        "line": 202,
        "fullcodeline": "strncpy(err_ret->text, tok->buf, len);"
    },
    {
        "line": 160,
        "fullcodeline": "c = *++cur;"
    },
    {
        "line": 174,
        "fullcodeline": "c = *++cur;"
    },
    {
        "line": 216,
        "fullcodeline": "PyObject_FREE(r);"
    }
]