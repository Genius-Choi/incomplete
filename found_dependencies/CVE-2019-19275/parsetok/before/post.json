[
    {
        "line": 6,
        "fullcodeline": "int started = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "PyParser_Delete(ps);"
    },
    {
        "line": 193,
        "fullcodeline": "PyTokenizer_Free(tok);"
    },
    {
        "line": 9,
        "fullcodeline": "if ((ps = PyParser_New(g, start)) == NULL) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (err_ret->error == E_DONE) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (n == NULL) {"
    },
    {
        "line": 195,
        "fullcodeline": "if (n != NULL) {"
    },
    {
        "line": 10,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 11,
        "fullcodeline": "PyTokenizer_Free(tok);"
    },
    {
        "line": 24,
        "fullcodeline": "col_offset = -1;"
    },
    {
        "line": 28,
        "fullcodeline": "type = PyTokenizer_Get(tok, &a, &b);"
    },
    {
        "line": 48,
        "fullcodeline": "len = (a != NULL && b != NULL) ? b - a : 0;"
    },
    {
        "line": 49,
        "fullcodeline": "str = (char *) PyObject_MALLOC(len + 1);"
    },
    {
        "line": 56,
        "fullcodeline": "str[len] = '\\0';"
    },
    {
        "line": 80,
        "fullcodeline": "lineno = type == STRING ? tok->first_lineno : tok->lineno;"
    },
    {
        "line": 81,
        "fullcodeline": "line_start = type == STRING ? tok->multi_line_start : tok->line_start;"
    },
    {
        "line": 110,
        "fullcodeline": "n = ps->p_tree;"
    },
    {
        "line": 111,
        "fullcodeline": "ps->p_tree = NULL;"
    },
    {
        "line": 154,
        "fullcodeline": "err_ret->lineno = tok->lineno;"
    },
    {
        "line": 196,
        "fullcodeline": "_PyNode_FinalizeEndPos(n);"
    },
    {
        "line": 29,
        "fullcodeline": "if (type == ERRORTOKEN) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (type == ENDMARKER && started) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (str == NULL) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (len > 0)"
    },
    {
        "line": 82,
        "fullcodeline": "if (a != NULL && a >= line_start) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (b != NULL && b >= tok->line_start) {"
    },
    {
        "line": 97,
        "fullcodeline": "if ((err_ret->error ="
    },
    {
        "line": 118,
        "fullcodeline": "if (start == single_input) {"
    },
    {
        "line": 144,
        "fullcodeline": "n = NULL;"
    },
    {
        "line": 152,
        "fullcodeline": "if (tok->done == E_EOF)"
    },
    {
        "line": 155,
        "fullcodeline": "if (tok->buf != NULL) {"
    },
    {
        "line": 30,
        "fullcodeline": "err_ret->error = tok->done;"
    },
    {
        "line": 34,
        "fullcodeline": "type = NEWLINE; /* Add an extra newline */"
    },
    {
        "line": 35,
        "fullcodeline": "started = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 55,
        "fullcodeline": "strncpy(str, a, len);"
    },
    {
        "line": 119,
        "fullcodeline": "char *cur = tok->cur;"
    },
    {
        "line": 153,
        "fullcodeline": "err_ret->error = E_EOF;"
    },
    {
        "line": 157,
        "fullcodeline": "assert(tok->cur - tok->buf < INT_MAX);"
    },
    {
        "line": 161,
        "fullcodeline": "err_ret->offset = col_offset != -1 ? col_offset + 1 : ((int)(tok->cur - tok->buf));"
    },
    {
        "line": 162,
        "fullcodeline": "len = tok->inp - tok->buf;"
    },
    {
        "line": 163,
        "fullcodeline": "err_ret->text = (char *) PyObject_MALLOC(len + 1);"
    },
    {
        "line": 170,
        "fullcodeline": "} else if (tok->encoding != NULL) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (tok->indent &&"
    },
    {
        "line": 47,
        "fullcodeline": "started = 1;"
    },
    {
        "line": 87,
        "fullcodeline": "col_offset = -1;"
    },
    {
        "line": 95,
        "fullcodeline": "end_col_offset = -1;"
    },
    {
        "line": 98,
        "fullcodeline": "PyParser_AddToken(ps, (int)type, str,"
    },
    {
        "line": 101,
        "fullcodeline": "if (err_ret->error != E_DONE) {"
    },
    {
        "line": 164,
        "fullcodeline": "if (err_ret->text != NULL) {"
    },
    {
        "line": 174,
        "fullcodeline": "node* r = PyNode_New(encoding_decl);"
    },
    {
        "line": 184,
        "fullcodeline": "strcpy(r->n_str, tok->encoding);"
    },
    {
        "line": 185,
        "fullcodeline": "PyMem_FREE(tok->encoding);"
    },
    {
        "line": 186,
        "fullcodeline": "tok->encoding = NULL;"
    },
    {
        "line": 187,
        "fullcodeline": "r->n_nchildren = 1;"
    },
    {
        "line": 188,
        "fullcodeline": "r->n_child = n;"
    },
    {
        "line": 189,
        "fullcodeline": "n = r;"
    },
    {
        "line": 40,
        "fullcodeline": "!(*flags & PyPARSE_DONT_IMPLY_DEDENT))"
    },
    {
        "line": 42,
        "fullcodeline": "tok->pendin = -tok->indent;"
    },
    {
        "line": 43,
        "fullcodeline": "tok->indent = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "PyObject_FREE(str);"
    },
    {
        "line": 103,
        "fullcodeline": "err_ret->token = type;"
    },
    {
        "line": 167,
        "fullcodeline": "err_ret->text[len] = '\\0';"
    },
    {
        "line": 177,
        "fullcodeline": "if (!r || !r->n_str) {"
    },
    {
        "line": 123,
        "fullcodeline": "while (c == ' ' || c == '\\t' || c == '\\n' || c == '\\014')"
    },
    {
        "line": 126,
        "fullcodeline": "if (!c)"
    },
    {
        "line": 129,
        "fullcodeline": "if (c != '#') {"
    },
    {
        "line": 137,
        "fullcodeline": "while (c && c != '\\n')"
    },
    {
        "line": 165,
        "fullcodeline": "if (len > 0)"
    },
    {
        "line": 176,
        "fullcodeline": "r->n_str = PyObject_MALLOC(strlen(tok->encoding)+1);"
    },
    {
        "line": 178,
        "fullcodeline": "err_ret->error = E_NOMEM;"
    },
    {
        "line": 181,
        "fullcodeline": "n = NULL;"
    },
    {
        "line": 130,
        "fullcodeline": "err_ret->error = E_BADSINGLE;"
    },
    {
        "line": 131,
        "fullcodeline": "PyNode_Free(n);"
    },
    {
        "line": 132,
        "fullcodeline": "n = NULL;"
    },
    {
        "line": 166,
        "fullcodeline": "strncpy(err_ret->text, tok->buf, len);"
    },
    {
        "line": 124,
        "fullcodeline": "c = *++cur;"
    },
    {
        "line": 138,
        "fullcodeline": "c = *++cur;"
    },
    {
        "line": 180,
        "fullcodeline": "PyObject_FREE(r);"
    }
]