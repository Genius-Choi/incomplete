[
    {
        "line": 12,
        "fullcodeline": "assert(expr_end >= expr_start);"
    },
    {
        "line": 13,
        "fullcodeline": "assert(*(expr_start-1) == '{');"
    },
    {
        "line": 14,
        "fullcodeline": "assert(*expr_end == '}' || *expr_end == '!' || *expr_end == ':');"
    },
    {
        "line": 33,
        "fullcodeline": "len = expr_end - expr_start;"
    },
    {
        "line": 35,
        "fullcodeline": "str = PyMem_RawMalloc(len + 3);"
    },
    {
        "line": 41,
        "fullcodeline": "str[0] = '(';"
    },
    {
        "line": 42,
        "fullcodeline": "memcpy(str+1, expr_start, len);"
    },
    {
        "line": 43,
        "fullcodeline": "str[len+1] = ')';"
    },
    {
        "line": 44,
        "fullcodeline": "str[len+2] = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "cf.cf_flags = PyCF_ONLY_AST;"
    },
    {
        "line": 47,
        "fullcodeline": "mod_n = PyParser_SimpleParseStringFlagsFilename(str, \"<fstring>\","
    },
    {
        "line": 54,
        "fullcodeline": "str[0] = '{';"
    },
    {
        "line": 55,
        "fullcodeline": "str[len+1] = '}';"
    },
    {
        "line": 56,
        "fullcodeline": "fstring_fix_node_location(n, mod_n, str);"
    },
    {
        "line": 57,
        "fullcodeline": "mod = PyAST_FromNode(mod_n, &cf, \"<fstring>\", c->c_arena);"
    },
    {
        "line": 20,
        "fullcodeline": "for (s = expr_start; s != expr_end; s++) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (s == expr_end) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (str == NULL) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (!mod_n) {"
    },
    {
        "line": 21,
        "fullcodeline": "char c = *s;"
    },
    {
        "line": 29,
        "fullcodeline": "ast_error(c, n, \"f-string: empty expression not allowed\");"
    },
    {
        "line": 24,
        "fullcodeline": "if (!(c == ' ' || c == '\\t' || c == '\\n' || c == '\\f')) {"
    }
]