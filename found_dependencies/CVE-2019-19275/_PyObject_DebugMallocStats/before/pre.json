[
    {
        "line": 4,
        "fullcodeline": "const uint numclasses = SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT;"
    },
    {
        "line": 6,
        "fullcodeline": "size_t numpools[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];"
    },
    {
        "line": 7,
        "fullcodeline": "size_t numblocks[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];"
    },
    {
        "line": 8,
        "fullcodeline": "size_t numfreeblocks[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];"
    },
    {
        "line": 10,
        "fullcodeline": "size_t allocated_bytes = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "size_t available_bytes = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "uint numfreepools = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "size_t arena_alignment = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "size_t pool_header_bytes = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "size_t quantization = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "size_t narenas = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "char buf[128];"
    },
    {
        "line": 30,
        "fullcodeline": "fprintf(out, \"Small block threshold = %d, in %u size classes.\\n\","
    },
    {
        "line": 83,
        "fullcodeline": "assert(narenas == narenas_currently_allocated);"
    },
    {
        "line": 85,
        "fullcodeline": "fputc('\\n', out);"
    },
    {
        "line": 86,
        "fullcodeline": "fputs(\"class   size   num pools   blocks in use  avail blocks\\n\""
    },
    {
        "line": 109,
        "fullcodeline": "fputc('\\n', out);"
    },
    {
        "line": 112,
        "fullcodeline": "(void)printone(out, \"# arenas allocated total\", ntimes_arena_allocated);"
    },
    {
        "line": 113,
        "fullcodeline": "(void)printone(out, \"# arenas reclaimed\", ntimes_arena_allocated - narenas);"
    },
    {
        "line": 114,
        "fullcodeline": "(void)printone(out, \"# arenas highwater mark\", narenas_highwater);"
    },
    {
        "line": 115,
        "fullcodeline": "(void)printone(out, \"# arenas allocated current\", narenas);"
    },
    {
        "line": 120,
        "fullcodeline": "(void)printone(out, buf, narenas * ARENA_SIZE);"
    },
    {
        "line": 122,
        "fullcodeline": "fputc('\\n', out);"
    },
    {
        "line": 124,
        "fullcodeline": "total = printone(out, \"# bytes in allocated blocks\", allocated_bytes);"
    },
    {
        "line": 125,
        "fullcodeline": "total += printone(out, \"# bytes in available blocks\", available_bytes);"
    },
    {
        "line": 127,
        "fullcodeline": "PyOS_snprintf(buf, sizeof(buf),"
    },
    {
        "line": 129,
        "fullcodeline": "total += printone(out, buf, (size_t)numfreepools * POOL_SIZE);"
    },
    {
        "line": 131,
        "fullcodeline": "total += printone(out, \"# bytes lost to pool headers\", pool_header_bytes);"
    },
    {
        "line": 132,
        "fullcodeline": "total += printone(out, \"# bytes lost to quantization\", quantization);"
    },
    {
        "line": 133,
        "fullcodeline": "total += printone(out, \"# bytes lost to arena alignment\", arena_alignment);"
    },
    {
        "line": 134,
        "fullcodeline": "(void)printone(out, \"Total\", total);"
    },
    {
        "line": 33,
        "fullcodeline": "for (i = 0; i < numclasses; ++i)"
    },
    {
        "line": 34,
        "fullcodeline": "numpools[i] = numblocks[i] = numfreeblocks[i] = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "for (i = 0; i < maxarenas; ++i) {"
    },
    {
        "line": 90,
        "fullcodeline": "for (i = 0; i < numclasses; ++i) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (_PyMem_DebugEnabled())"
    },
    {
        "line": 42,
        "fullcodeline": "uintptr_t base = arenas[i].address;"
    },
    {
        "line": 47,
        "fullcodeline": "narenas += 1;"
    },
    {
        "line": 49,
        "fullcodeline": "numfreepools += arenas[i].nfreepools;"
    },
    {
        "line": 59,
        "fullcodeline": "assert(base <= (uintptr_t) arenas[i].pool_address);"
    },
    {
        "line": 91,
        "fullcodeline": "size_t p = numpools[i];"
    },
    {
        "line": 92,
        "fullcodeline": "size_t b = numblocks[i];"
    },
    {
        "line": 93,
        "fullcodeline": "size_t f = numfreeblocks[i];"
    },
    {
        "line": 94,
        "fullcodeline": "uint size = INDEX2SIZE(i);"
    },
    {
        "line": 104,
        "fullcodeline": "allocated_bytes += b * size;"
    },
    {
        "line": 105,
        "fullcodeline": "available_bytes += f * size;"
    },
    {
        "line": 106,
        "fullcodeline": "pool_header_bytes += p * POOL_OVERHEAD;"
    },
    {
        "line": 107,
        "fullcodeline": "quantization += p * ((POOL_SIZE - POOL_OVERHEAD) % size);"
    },
    {
        "line": 111,
        "fullcodeline": "(void)printone(out, \"# times object malloc called\", serialno);"
    },
    {
        "line": 45,
        "fullcodeline": "if (arenas[i].address == (uintptr_t)NULL)"
    },
    {
        "line": 52,
        "fullcodeline": "if (base & (uintptr_t)POOL_SIZE_MASK) {"
    },
    {
        "line": 60,
        "fullcodeline": "for (j = 0; base < (uintptr_t) arenas[i].pool_address;"
    },
    {
        "line": 61,
        "fullcodeline": "++j, base += POOL_SIZE) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (p == 0) {"
    },
    {
        "line": 53,
        "fullcodeline": "arena_alignment += POOL_SIZE;"
    },
    {
        "line": 54,
        "fullcodeline": "base &= ~(uintptr_t)POOL_SIZE_MASK;"
    },
    {
        "line": 55,
        "fullcodeline": "base += POOL_SIZE;"
    },
    {
        "line": 62,
        "fullcodeline": "poolp p = (poolp)base;"
    },
    {
        "line": 63,
        "fullcodeline": "const uint sz = p->szidx;"
    },
    {
        "line": 73,
        "fullcodeline": "++numpools[sz];"
    },
    {
        "line": 74,
        "fullcodeline": "numblocks[sz] += p->ref.count;"
    },
    {
        "line": 75,
        "fullcodeline": "freeblocks = NUMBLOCKS(sz) - p->ref.count;"
    },
    {
        "line": 76,
        "fullcodeline": "numfreeblocks[sz] += freeblocks;"
    },
    {
        "line": 96,
        "fullcodeline": "assert(b == 0 && f == 0);"
    },
    {
        "line": 66,
        "fullcodeline": "if (p->ref.count == 0) {"
    }
]