[
    {
        "line": 7,
        "fullcodeline": "setbuf(stdout, NULL);"
    },
    {
        "line": 8,
        "fullcodeline": "setbuf(stderr, NULL);"
    },
    {
        "line": 9,
        "fullcodeline": "user_umask = umask(0); umask(user_umask);"
    },
    {
        "line": 11,
        "fullcodeline": "MSPACK_SYS_SELFTEST(i);"
    },
    {
        "line": 14,
        "fullcodeline": "if ((chmd = mspack_create_chm_decompressor(NULL))) {"
    },
    {
        "line": 43,
        "fullcodeline": "mspack_destroy_chm_decompressor(chmd);"
    },
    {
        "line": 15,
        "fullcodeline": "for (argv++; *argv; argv++) {"
    },
    {
        "line": 16,
        "fullcodeline": "printf(\"%s\\n\", *argv);"
    },
    {
        "line": 17,
        "fullcodeline": "if ((chm = chmd->open(chmd, *argv))) {"
    },
    {
        "line": 37,
        "fullcodeline": "chmd->close(chmd, chm);"
    },
    {
        "line": 20,
        "fullcodeline": "for (numf=0, file=chm->files; file; file = file->next) numf++;"
    },
    {
        "line": 21,
        "fullcodeline": "if ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {"
    },
    {
        "line": 40,
        "fullcodeline": "printf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));"
    },
    {
        "line": 23,
        "fullcodeline": "qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);"
    },
    {
        "line": 35,
        "fullcodeline": "free(f);"
    },
    {
        "line": 22,
        "fullcodeline": "for (i=0, file=chm->files; file; file = file->next) f[i++] = file;"
    },
    {
        "line": 25,
        "fullcodeline": "for (i = 0; i < numf; i++) {"
    },
    {
        "line": 26,
        "fullcodeline": "char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);"
    },
    {
        "line": 27,
        "fullcodeline": "printf(\"Extracting %s\\n\", outname);"
    },
    {
        "line": 28,
        "fullcodeline": "ensure_filepath(outname);"
    },
    {
        "line": 33,
        "fullcodeline": "free(outname);"
    },
    {
        "line": 29,
        "fullcodeline": "if (chmd->extract(chmd, f[i], outname)) {"
    },
    {
        "line": 30,
        "fullcodeline": "printf(\"%s: extract error on \\\"%s\\\": %s\\n\","
    },
    {
        "line": 31,
        "fullcodeline": "*argv, f[i]->filename, ERROR(chmd));"
    }
]