[
    {
        "line": 5,
        "fullcodeline": "for (int c=0; c<channelCount; c++)"
    },
    {
        "line": 18,
        "fullcodeline": "for (int n=0; n<m_framesPerPacket - 1; n += 8)"
    },
    {
        "line": 36,
        "fullcodeline": "return m_framesPerPacket * channelCount * sizeof (int16_t);"
    },
    {
        "line": 7,
        "fullcodeline": "m_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];"
    },
    {
        "line": 11,
        "fullcodeline": "m_adpcmState[c].index = clamp(encoded[2], 0, 88);"
    },
    {
        "line": 13,
        "fullcodeline": "*decoded++ = m_adpcmState[c].previousValue;"
    },
    {
        "line": 15,
        "fullcodeline": "encoded += 4;"
    },
    {
        "line": 33,
        "fullcodeline": "decoded += channelCount * 8;"
    },
    {
        "line": 8,
        "fullcodeline": "if (encoded[1] & 0x80)"
    },
    {
        "line": 20,
        "fullcodeline": "for (int c=0; c<channelCount; c++)"
    },
    {
        "line": 9,
        "fullcodeline": "m_adpcmState[c].previousValue -= 0x10000;"
    },
    {
        "line": 22,
        "fullcodeline": "int16_t *output = decoded + c;"
    },
    {
        "line": 23,
        "fullcodeline": "for (int s=0; s<4; s++)"
    },
    {
        "line": 25,
        "fullcodeline": "*output = decodeSample(m_adpcmState[c], *encoded & 0xf);"
    },
    {
        "line": 26,
        "fullcodeline": "output += channelCount;"
    },
    {
        "line": 27,
        "fullcodeline": "*output = decodeSample(m_adpcmState[c], *encoded >> 4);"
    },
    {
        "line": 28,
        "fullcodeline": "output += channelCount;"
    },
    {
        "line": 29,
        "fullcodeline": "encoded++;"
    }
]