[
    {
        "line": 3,
        "fullcodeline": "int channelCount = m_track->f.channelCount;"
    },
    {
        "line": 5,
        "fullcodeline": "for (int c=0; c<channelCount; c++)"
    },
    {
        "line": 25,
        "fullcodeline": "return m_framesPerPacket * channelCount * sizeof (int16_t);"
    },
    {
        "line": 8,
        "fullcodeline": "int predictor = (encoded[0] << 8) | (encoded[1] & 0x80);"
    },
    {
        "line": 12,
        "fullcodeline": "state.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);"
    },
    {
        "line": 13,
        "fullcodeline": "state.index = clamp(encoded[1] & 0x7f, 0, 88);"
    },
    {
        "line": 14,
        "fullcodeline": "encoded += 2;"
    },
    {
        "line": 9,
        "fullcodeline": "if (predictor & 0x8000)"
    },
    {
        "line": 16,
        "fullcodeline": "for (int n=0; n<m_framesPerPacket; n+=2)"
    },
    {
        "line": 10,
        "fullcodeline": "predictor -= 0x10000;"
    },
    {
        "line": 18,
        "fullcodeline": "uint8_t e = *encoded;"
    },
    {
        "line": 19,
        "fullcodeline": "decoded[n*channelCount + c] = decodeSample(state, e & 0xf);"
    },
    {
        "line": 20,
        "fullcodeline": "decoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);"
    },
    {
        "line": 21,
        "fullcodeline": "encoded++;"
    }
]