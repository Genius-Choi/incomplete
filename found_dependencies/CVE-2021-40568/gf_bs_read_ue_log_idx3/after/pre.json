[
    {
        "line": 3,
        "fullcodeline": "u32 val=0, code;"
    },
    {
        "line": 4,
        "fullcodeline": "s32 nb_lead = -1;"
    },
    {
        "line": 5,
        "fullcodeline": "u32 bits = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "for (code=0; !code; nb_lead++) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (nb_lead>=32) {"
    },
    {
        "line": 10,
        "fullcodeline": "code = gf_bs_read_int(bs, 1);"
    },
    {
        "line": 11,
        "fullcodeline": "bits++;"
    },
    {
        "line": 26,
        "fullcodeline": "u32 leads=1;"
    },
    {
        "line": 27,
        "fullcodeline": "val = gf_bs_read_int(bs, nb_lead);"
    },
    {
        "line": 28,
        "fullcodeline": "leads <<= nb_lead;"
    },
    {
        "line": 29,
        "fullcodeline": "leads -= 1;"
    },
    {
        "line": 30,
        "fullcodeline": "val += leads;"
    },
    {
        "line": 32,
        "fullcodeline": "bits += nb_lead;"
    },
    {
        "line": 36,
        "fullcodeline": "gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);"
    },
    {
        "line": 7,
        "fullcodeline": "if (nb_lead>=32) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (!gf_bs_available(bs)) {"
    },
    {
        "line": 18,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));"
    },
    {
        "line": 20,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));"
    }
]