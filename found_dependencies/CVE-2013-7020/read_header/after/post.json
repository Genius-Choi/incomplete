[
    {
        "line": 3,
        "fullcodeline": "uint8_t state[CONTEXT_SIZE];"
    },
    {
        "line": 4,
        "fullcodeline": "int i, j, context_count = -1; //-1 to avoid warning"
    },
    {
        "line": 7,
        "fullcodeline": "memset(state, 128, sizeof(state));"
    },
    {
        "line": 131,
        "fullcodeline": "av_dlog(f->avctx, \"%d %d %d\\n\","
    },
    {
        "line": 9,
        "fullcodeline": "if (f->version < 2) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (f->colorspace == 0) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (f->version < 2) {"
    },
    {
        "line": 153,
        "fullcodeline": "if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {"
    },
    {
        "line": 158,
        "fullcodeline": "for (j = 0; j < f->slice_count; j++) {"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned v= get_symbol(c, state, 0);"
    },
    {
        "line": 16,
        "fullcodeline": "f->version = v;"
    },
    {
        "line": 17,
        "fullcodeline": "f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);"
    },
    {
        "line": 23,
        "fullcodeline": "colorspace     = get_symbol(c, state, 0); //YUV cs type"
    },
    {
        "line": 24,
        "fullcodeline": "bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;"
    },
    {
        "line": 25,
        "fullcodeline": "chroma_planes  = get_rac(c, state);"
    },
    {
        "line": 26,
        "fullcodeline": "chroma_h_shift = get_symbol(c, state, 0);"
    },
    {
        "line": 27,
        "fullcodeline": "chroma_v_shift = get_symbol(c, state, 0);"
    },
    {
        "line": 28,
        "fullcodeline": "transparency   = get_rac(c, state);"
    },
    {
        "line": 42,
        "fullcodeline": "f->colorspace     = colorspace;"
    },
    {
        "line": 43,
        "fullcodeline": "f->avctx->bits_per_raw_sample = bits_per_raw_sample;"
    },
    {
        "line": 44,
        "fullcodeline": "f->chroma_planes  = chroma_planes;"
    },
    {
        "line": 45,
        "fullcodeline": "f->chroma_h_shift = chroma_h_shift;"
    },
    {
        "line": 46,
        "fullcodeline": "f->chroma_v_shift = chroma_v_shift;"
    },
    {
        "line": 47,
        "fullcodeline": "f->transparency   = transparency;"
    },
    {
        "line": 49,
        "fullcodeline": "f->plane_count    = 2 + f->transparency;"
    },
    {
        "line": 134,
        "fullcodeline": "context_count = read_quant_tables(c, f->quant_table);"
    },
    {
        "line": 154,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);"
    },
    {
        "line": 160,
        "fullcodeline": "fs->ac            = f->ac;"
    },
    {
        "line": 161,
        "fullcodeline": "fs->packed_at_lsb = f->packed_at_lsb;"
    },
    {
        "line": 163,
        "fullcodeline": "fs->slice_damaged = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "if (v >= 2) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (f->ac > 1) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (!f->transparency && !f->chroma_planes) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (context_count < 0) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (f->version == 2) {"
    },
    {
        "line": 183,
        "fullcodeline": "for (i = 0; i < f->plane_count; i++) {"
    },
    {
        "line": 13,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);"
    },
    {
        "line": 109,
        "fullcodeline": "} else if (f->colorspace == 1) {"
    },
    {
        "line": 136,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");"
    },
    {
        "line": 139,
        "fullcodeline": "} else if (f->version < 3) {"
    },
    {
        "line": 166,
        "fullcodeline": "fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;"
    },
    {
        "line": 167,
        "fullcodeline": "fs->slice_y      =  get_symbol(c, state, 0)      * f->height;"
    },
    {
        "line": 168,
        "fullcodeline": "fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;"
    },
    {
        "line": 169,
        "fullcodeline": "fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;"
    },
    {
        "line": 171,
        "fullcodeline": "fs->slice_x     /= f->num_h_slices;"
    },
    {
        "line": 172,
        "fullcodeline": "fs->slice_y     /= f->num_v_slices;"
    },
    {
        "line": 173,
        "fullcodeline": "fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;"
    },
    {
        "line": 174,
        "fullcodeline": "fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;"
    },
    {
        "line": 19,
        "fullcodeline": "for (i = 1; i < 256; i++)"
    },
    {
        "line": 20,
        "fullcodeline": "f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];"
    },
    {
        "line": 31,
        "fullcodeline": "if (   colorspace    != f->colorspace"
    },
    {
        "line": 54,
        "fullcodeline": "if (f->avctx->bits_per_raw_sample <= 8)"
    },
    {
        "line": 140,
        "fullcodeline": "f->slice_count = get_symbol(c, state, 0);"
    },
    {
        "line": 175,
        "fullcodeline": "if ((unsigned)fs->slice_width  > f->width ||"
    },
    {
        "line": 178,
        "fullcodeline": "if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width"
    },
    {
        "line": 186,
        "fullcodeline": "if (f->version == 2) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (f->version <= 2) {"
    },
    {
        "line": 36,
        "fullcodeline": "|| transparency  != f->transparency) {"
    },
    {
        "line": 37,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");"
    },
    {
        "line": 55,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;"
    },
    {
        "line": 58,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (f->chroma_h_shift || f->chroma_v_shift) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (     f->avctx->bits_per_raw_sample ==  9)"
    },
    {
        "line": 127,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");"
    },
    {
        "line": 142,
        "fullcodeline": "const uint8_t *p = c->bytestream_end;"
    },
    {
        "line": 176,
        "fullcodeline": "(unsigned)fs->slice_height > f->height)"
    },
    {
        "line": 179,
        "fullcodeline": "|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)"
    },
    {
        "line": 187,
        "fullcodeline": "int idx = get_symbol(c, state, 0);"
    },
    {
        "line": 193,
        "fullcodeline": "p->quant_table_index = idx;"
    },
    {
        "line": 194,
        "fullcodeline": "memcpy(p->quant_table, f->quant_tables[idx],"
    },
    {
        "line": 202,
        "fullcodeline": "av_assert0(context_count >= 0);"
    },
    {
        "line": 207,
        "fullcodeline": "p->context_count = context_count;"
    },
    {
        "line": 35,
        "fullcodeline": "|| chroma_v_shift!= f->chroma_v_shift"
    },
    {
        "line": 57,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;"
    },
    {
        "line": 111,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR,"
    },
    {
        "line": 116,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;"
    },
    {
        "line": 128,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 144,
        "fullcodeline": "f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;"
    },
    {
        "line": 145,
        "fullcodeline": "f->slice_count++) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (idx > (unsigned)f->quant_table_count) {"
    },
    {
        "line": 198,
        "fullcodeline": "memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));"
    },
    {
        "line": 203,
        "fullcodeline": "if (p->context_count < context_count) {"
    },
    {
        "line": 34,
        "fullcodeline": "|| chroma_h_shift!= f->chroma_h_shift"
    },
    {
        "line": 59,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 113,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 143,
        "fullcodeline": "for (f->slice_count = 0;"
    },
    {
        "line": 146,
        "fullcodeline": "int trailer = 3 + 5*!!f->ec;"
    },
    {
        "line": 147,
        "fullcodeline": "int size = AV_RB24(p-trailer);"
    },
    {
        "line": 150,
        "fullcodeline": "p -= size + trailer;"
    },
    {
        "line": 189,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR,"
    },
    {
        "line": 204,
        "fullcodeline": "av_freep(&p->state);"
    },
    {
        "line": 205,
        "fullcodeline": "av_freep(&p->vlc_state);"
    },
    {
        "line": 33,
        "fullcodeline": "|| chroma_planes != f->chroma_planes"
    },
    {
        "line": 60,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;"
    },
    {
        "line": 61,
        "fullcodeline": "case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;"
    },
    {
        "line": 62,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;"
    },
    {
        "line": 63,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;"
    },
    {
        "line": 64,
        "fullcodeline": "case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;"
    },
    {
        "line": 65,
        "fullcodeline": "case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;"
    },
    {
        "line": 67,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");"
    },
    {
        "line": 70,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {"
    },
    {
        "line": 117,
        "fullcodeline": "else if (f->avctx->bits_per_raw_sample == 10)"
    },
    {
        "line": 148,
        "fullcodeline": "if (size + trailer > p - c->bytestream_start)"
    },
    {
        "line": 32,
        "fullcodeline": "|| bits_per_raw_sample != f->avctx->bits_per_raw_sample"
    },
    {
        "line": 68,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 118,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;"
    },
    {
        "line": 71,
        "fullcodeline": "switch(16*f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 72,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;"
    },
    {
        "line": 73,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;"
    },
    {
        "line": 74,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;"
    },
    {
        "line": 76,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");"
    },
    {
        "line": 79,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 9) {"
    },
    {
        "line": 119,
        "fullcodeline": "else if (f->avctx->bits_per_raw_sample == 12)"
    },
    {
        "line": 77,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 80,
        "fullcodeline": "f->packed_at_lsb = 1;"
    },
    {
        "line": 120,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;"
    },
    {
        "line": 81,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 82,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;"
    },
    {
        "line": 83,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;"
    },
    {
        "line": 84,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;"
    },
    {
        "line": 86,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");"
    },
    {
        "line": 89,
        "fullcodeline": "} else if (f->avctx->bits_per_raw_sample == 10) {"
    },
    {
        "line": 121,
        "fullcodeline": "else if (f->avctx->bits_per_raw_sample == 14)"
    },
    {
        "line": 87,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 90,
        "fullcodeline": "f->packed_at_lsb = 1;"
    },
    {
        "line": 122,
        "fullcodeline": "f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;"
    },
    {
        "line": 91,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 92,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;"
    },
    {
        "line": 93,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;"
    },
    {
        "line": 94,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;"
    },
    {
        "line": 96,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");"
    },
    {
        "line": 100,
        "fullcodeline": "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {"
    },
    {
        "line": 97,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 101,
        "fullcodeline": "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;"
    },
    {
        "line": 102,
        "fullcodeline": "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;"
    },
    {
        "line": 103,
        "fullcodeline": "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;"
    },
    {
        "line": 105,
        "fullcodeline": "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");"
    },
    {
        "line": 124,
        "fullcodeline": "if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;"
    },
    {
        "line": 106,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 125,
        "fullcodeline": "else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;"
    }
]