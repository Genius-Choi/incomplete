[
    {
        "line": 2,
        "fullcodeline": "TF_RETURN_IF_ERROR(gview_.Initialize(&graph));"
    },
    {
        "line": 6,
        "fullcodeline": "TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));"
    },
    {
        "line": 12,
        "fullcodeline": "root_frame_info_ = frame_info_[\"\"].get();"
    },
    {
        "line": 14,
        "fullcodeline": "pending_ids_.resize(gview_.num_nodes());"
    },
    {
        "line": 18,
        "fullcodeline": "requires_control_flow_ = false;"
    },
    {
        "line": 178,
        "fullcodeline": "InitializePending(&graph, cf_info);"
    },
    {
        "line": 179,
        "fullcodeline": "return gview_.SetAllocAttrs(&graph, params_.device);"
    },
    {
        "line": 9,
        "fullcodeline": "EnsureFrameInfo(it)->nodes ="
    },
    {
        "line": 39,
        "fullcodeline": "const int id = n->id();"
    },
    {
        "line": 40,
        "fullcodeline": "const string& frame_name = cf_info.frame_names[id];"
    },
    {
        "line": 41,
        "fullcodeline": "FrameInfo* frame_info = EnsureFrameInfo(frame_name);"
    },
    {
        "line": 43,
        "fullcodeline": "NodeItem* item = gview_.node(id);"
    },
    {
        "line": 44,
        "fullcodeline": "item->node_id = id;"
    },
    {
        "line": 46,
        "fullcodeline": "item->input_start = frame_info->total_inputs;"
    },
    {
        "line": 47,
        "fullcodeline": "frame_info->total_inputs += n->num_inputs();"
    },
    {
        "line": 49,
        "fullcodeline": "Status s = params_.create_kernel(n->properties(), &item->kernel);"
    },
    {
        "line": 56,
        "fullcodeline": "CHECK(item->kernel);"
    },
    {
        "line": 57,
        "fullcodeline": "item->kernel_is_async = (item->kernel->AsAsync() != nullptr);"
    },
    {
        "line": 58,
        "fullcodeline": "item->is_merge = IsMerge(n);"
    },
    {
        "line": 59,
        "fullcodeline": "item->is_any_consumer_merge_or_control_trigger = false;"
    },
    {
        "line": 66,
        "fullcodeline": "const Tensor* const_tensor = item->kernel->const_tensor();"
    },
    {
        "line": 73,
        "fullcodeline": "item->const_tensor = const_tensor;"
    },
    {
        "line": 74,
        "fullcodeline": "item->is_noop = (item->kernel->type_string_view() == \"NoOp\");"
    },
    {
        "line": 75,
        "fullcodeline": "item->is_enter = IsEnter(n);"
    },
    {
        "line": 106,
        "fullcodeline": "item->is_exit = IsExit(n);"
    },
    {
        "line": 107,
        "fullcodeline": "item->is_control_trigger = IsControlTrigger(n);"
    },
    {
        "line": 108,
        "fullcodeline": "item->is_source = IsSource(n);"
    },
    {
        "line": 109,
        "fullcodeline": "item->is_enter_exit_or_next_iter ="
    },
    {
        "line": 111,
        "fullcodeline": "item->is_transfer_node = IsTransferNode(n);"
    },
    {
        "line": 112,
        "fullcodeline": "item->is_initialization_op = IsInitializationOp(n);"
    },
    {
        "line": 113,
        "fullcodeline": "item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);"
    },
    {
        "line": 114,
        "fullcodeline": "item->is_next_iteration = IsNextIteration(n);"
    },
    {
        "line": 115,
        "fullcodeline": "item->is_distributed_communication = IsDistributedCommunication(n);"
    },
    {
        "line": 122,
        "fullcodeline": "GetMaxPendingCounts(n, &max_pending, &max_dead);"
    },
    {
        "line": 123,
        "fullcodeline": "pending_ids_[id] ="
    },
    {
        "line": 132,
        "fullcodeline": "frame_info->nodes->push_back(item);"
    },
    {
        "line": 140,
        "fullcodeline": "std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);"
    },
    {
        "line": 141,
        "fullcodeline": "std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);"
    },
    {
        "line": 142,
        "fullcodeline": "int32_t unused_outputs = n->num_outputs();"
    },
    {
        "line": 166,
        "fullcodeline": "const int id = n->id();"
    },
    {
        "line": 20,
        "fullcodeline": "if (IsSink(n)) continue;"
    },
    {
        "line": 21,
        "fullcodeline": "if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (!s.ok()) {"
    },
    {
        "line": 110,
        "fullcodeline": "(IsEnter(n) || IsExit(n) || IsNextIteration(n));"
    },
    {
        "line": 124,
        "fullcodeline": "frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);"
    },
    {
        "line": 127,
        "fullcodeline": "if (n->in_edges().empty()) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (unused_outputs > 0) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (IsSink(n)) continue;"
    },
    {
        "line": 167,
        "fullcodeline": "NodeItem* item = gview_.node(id);"
    },
    {
        "line": 22,
        "fullcodeline": "requires_control_flow_ = true;"
    },
    {
        "line": 51,
        "fullcodeline": "params_.delete_kernel(item->kernel);"
    },
    {
        "line": 52,
        "fullcodeline": "item->kernel = nullptr;"
    },
    {
        "line": 53,
        "fullcodeline": "s = AttachDef(s, *n);"
    },
    {
        "line": 71,
        "fullcodeline": "const_tensors_.emplace_back(*const_tensor);"
    },
    {
        "line": 78,
        "fullcodeline": "TF_RETURN_IF_ERROR("
    },
    {
        "line": 80,
        "fullcodeline": "item->is_constant_enter = is_constant_enter;"
    },
    {
        "line": 83,
        "fullcodeline": "TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));"
    },
    {
        "line": 84,
        "fullcodeline": "FrameInfo* frame_info = frame_info_[frame_name].get();"
    },
    {
        "line": 87,
        "fullcodeline": "TF_RETURN_IF_ERROR("
    },
    {
        "line": 102,
        "fullcodeline": "enter_frame_info_[id] = frame_info;"
    },
    {
        "line": 128,
        "fullcodeline": "root_nodes_.push_back(item);"
    },
    {
        "line": 135,
        "fullcodeline": "TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));"
    },
    {
        "line": 136,
        "fullcodeline": "EnsureFrameInfo(enter_name)->input_count++;"
    },
    {
        "line": 158,
        "fullcodeline": "item->outputs_required = std::move(outputs_required);"
    },
    {
        "line": 170,
        "fullcodeline": "const int dst_id = e.dst_id;"
    },
    {
        "line": 171,
        "fullcodeline": "NodeItem* dst_item = gview_.node(dst_id);"
    },
    {
        "line": 61,
        "fullcodeline": "if (IsMerge(consumer) || IsControlTrigger(consumer)) {"
    },
    {
        "line": 79,
        "fullcodeline": "GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));"
    },
    {
        "line": 88,
        "fullcodeline": "GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));"
    },
    {
        "line": 90,
        "fullcodeline": "if (frame_info->parallel_iterations == -1) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (enter_frame_info_.size() <= id) {"
    },
    {
        "line": 104,
        "fullcodeline": "item->is_constant_enter = false;"
    },
    {
        "line": 144,
        "fullcodeline": "if (IsSink(e->dst())) continue;"
    },
    {
        "line": 145,
        "fullcodeline": "if (e->src_output() >= 0) {"
    },
    {
        "line": 153,
        "fullcodeline": "for (int i = 0; i < n->num_outputs(); ++i) {"
    },
    {
        "line": 23,
        "fullcodeline": "} else if (IsRecv(n)) {"
    },
    {
        "line": 91,
        "fullcodeline": "frame_info->parallel_iterations = parallel_iterations;"
    },
    {
        "line": 100,
        "fullcodeline": "enter_frame_info_.resize(id + 1);"
    },
    {
        "line": 32,
        "fullcodeline": "TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));"
    },
    {
        "line": 33,
        "fullcodeline": "TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));"
    },
    {
        "line": 146,
        "fullcodeline": "if (!outputs_required[e->src_output()]) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (!outputs_required[i]) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (send_device != recv_device) {"
    },
    {
        "line": 92,
        "fullcodeline": "} else if (frame_info->parallel_iterations != parallel_iterations) {"
    },
    {
        "line": 147,
        "fullcodeline": "--unused_outputs;"
    },
    {
        "line": 148,
        "fullcodeline": "outputs_required[e->src_output()] = true;"
    },
    {
        "line": 155,
        "fullcodeline": "metrics::RecordUnusedOutput(n->type_string());"
    },
    {
        "line": 35,
        "fullcodeline": "requires_control_flow_ = true;"
    },
    {
        "line": 93,
        "fullcodeline": "LOG(WARNING) << \"Loop frame \\\"\" << frame_name"
    }
]