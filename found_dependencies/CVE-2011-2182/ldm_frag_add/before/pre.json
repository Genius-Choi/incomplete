[
    {
        "line": 7,
        "fullcodeline": "BUG_ON (!data || !frags);"
    },
    {
        "line": 14,
        "fullcodeline": "group = get_unaligned_be32(data + 0x08);"
    },
    {
        "line": 15,
        "fullcodeline": "rec   = get_unaligned_be16(data + 0x0C);"
    },
    {
        "line": 16,
        "fullcodeline": "num   = get_unaligned_be16(data + 0x0E);"
    },
    {
        "line": 26,
        "fullcodeline": "list_for_each (item, frags) {"
    },
    {
        "line": 32,
        "fullcodeline": "f = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);"
    },
    {
        "line": 41,
        "fullcodeline": "f->map   = 0xFF << num;"
    },
    {
        "line": 53,
        "fullcodeline": "data += VBLK_SIZE_HEAD;"
    },
    {
        "line": 54,
        "fullcodeline": "size -= VBLK_SIZE_HEAD;"
    },
    {
        "line": 9,
        "fullcodeline": "if (size < 2 * VBLK_SIZE_HEAD) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (rec >= num) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (!f) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (f->map & (1 << rec)) {"
    },
    {
        "line": 51,
        "fullcodeline": "f->map |= (1 << rec);"
    },
    {
        "line": 10,
        "fullcodeline": "ldm_error(\"Value of size is to small.\");"
    },
    {
        "line": 17,
        "fullcodeline": "if ((num < 1) || (num > 4)) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (f->group == group)"
    },
    {
        "line": 56,
        "fullcodeline": "memcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);"
    }
]