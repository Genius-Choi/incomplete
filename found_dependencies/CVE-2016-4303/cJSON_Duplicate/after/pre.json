[
    {
        "line": 3,
        "fullcodeline": "cJSON *newitem,*cptr,*nptr=0,*newchild;"
    },
    {
        "line": 7,
        "fullcodeline": "newitem=cJSON_New_Item();"
    },
    {
        "line": 16,
        "fullcodeline": "cptr=item->child;"
    },
    {
        "line": 5,
        "fullcodeline": "if (!item) return 0;"
    },
    {
        "line": 8,
        "fullcodeline": "if (!newitem) return 0;"
    },
    {
        "line": 10,
        "fullcodeline": "newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;"
    },
    {
        "line": 11,
        "fullcodeline": "if (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}"
    },
    {
        "line": 12,
        "fullcodeline": "if (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}"
    },
    {
        "line": 19,
        "fullcodeline": "newchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */"
    },
    {
        "line": 23,
        "fullcodeline": "cptr=cptr->next;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!newchild) {cJSON_Delete(newitem);return 0;}"
    },
    {
        "line": 21,
        "fullcodeline": "if (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */"
    },
    {
        "line": 22,
        "fullcodeline": "else\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */"
    }
]