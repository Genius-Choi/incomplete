[
    {
        "line": 4,
        "fullcodeline": "int enc_err, n, i, ret = -1;"
    },
    {
        "line": 9,
        "fullcodeline": "unsigned char md[EVP_MAX_MD_SIZE];"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned int num_recs = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "rr = RECORD_LAYER_get_rrec(&s->rlayer);"
    },
    {
        "line": 17,
        "fullcodeline": "rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);"
    },
    {
        "line": 18,
        "fullcodeline": "max_recs = s->max_pipelines;"
    },
    {
        "line": 21,
        "fullcodeline": "sess = s->session;"
    },
    {
        "line": 247,
        "fullcodeline": "enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);"
    },
    {
        "line": 387,
        "fullcodeline": "ssl3_send_alert(s, SSL3_AL_FATAL, al);"
    },
    {
        "line": 19,
        "fullcodeline": "if (max_recs == 0)"
    },
    {
        "line": 213,
        "fullcodeline": "} while (num_recs < max_recs"
    },
    {
        "line": 225,
        "fullcodeline": "if (SSL_READ_ETM(s) && s->read_hash) {"
    },
    {
        "line": 254,
        "fullcodeline": "if (enc_err == 0) {"
    },
    {
        "line": 339,
        "fullcodeline": "for (j = 0; j < num_recs; j++) {"
    },
    {
        "line": 20,
        "fullcodeline": "max_recs = 1;"
    },
    {
        "line": 167,
        "fullcodeline": "RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);"
    },
    {
        "line": 202,
        "fullcodeline": "rr[num_recs].data = rr[num_recs].input;"
    },
    {
        "line": 203,
        "fullcodeline": "rr[num_recs].orig_len = rr[num_recs].length;"
    },
    {
        "line": 206,
        "fullcodeline": "rr[num_recs].read = 0;"
    },
    {
        "line": 208,
        "fullcodeline": "num_recs++;"
    },
    {
        "line": 211,
        "fullcodeline": "RECORD_LAYER_reset_packet_length(&s->rlayer);"
    },
    {
        "line": 212,
        "fullcodeline": "RECORD_LAYER_clear_first_record(&s->rlayer);"
    },
    {
        "line": 219,
        "fullcodeline": "&& ssl3_record_app_data_waiting(s));"
    },
    {
        "line": 227,
        "fullcodeline": "mac_size = EVP_MD_CTX_size(s->read_hash);"
    },
    {
        "line": 255,
        "fullcodeline": "al = SSL_AD_DECRYPTION_FAILED;"
    },
    {
        "line": 256,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);"
    },
    {
        "line": 270,
        "fullcodeline": "if ((sess != NULL) &&"
    },
    {
        "line": 272,
        "fullcodeline": "(!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {"
    },
    {
        "line": 275,
        "fullcodeline": "unsigned char mac_tmp[EVP_MAX_MD_SIZE];"
    },
    {
        "line": 277,
        "fullcodeline": "mac_size = EVP_MD_CTX_size(s->read_hash);"
    },
    {
        "line": 333,
        "fullcodeline": "al = SSL_AD_BAD_RECORD_MAC;"
    },
    {
        "line": 25,
        "fullcodeline": "if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||"
    },
    {
        "line": 152,
        "fullcodeline": "if (rr[num_recs].rec_version == SSL2_VERSION) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (i > 0) {"
    },
    {
        "line": 174,
        "fullcodeline": "if (rr[num_recs].rec_version == SSL2_VERSION) {"
    },
    {
        "line": 195,
        "fullcodeline": "if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {"
    },
    {
        "line": 217,
        "fullcodeline": "&& (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))"
    },
    {
        "line": 228,
        "fullcodeline": "OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);"
    },
    {
        "line": 229,
        "fullcodeline": "for (j = 0; j < num_recs; j++) {"
    },
    {
        "line": 271,
        "fullcodeline": "(s->enc_read_ctx != NULL) &&"
    },
    {
        "line": 278,
        "fullcodeline": "OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);"
    },
    {
        "line": 280,
        "fullcodeline": "for (j = 0; j < num_recs; j++) {"
    },
    {
        "line": 341,
        "fullcodeline": "if (s->expand != NULL) {"
    },
    {
        "line": 354,
        "fullcodeline": "if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {"
    },
    {
        "line": 26,
        "fullcodeline": "(RECORD_LAYER_get_packet_length(&s->rlayer)"
    },
    {
        "line": 28,
        "fullcodeline": "n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,"
    },
    {
        "line": 33,
        "fullcodeline": "RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);"
    },
    {
        "line": 35,
        "fullcodeline": "p = RECORD_LAYER_get_packet(&s->rlayer);"
    },
    {
        "line": 153,
        "fullcodeline": "i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH"
    },
    {
        "line": 161,
        "fullcodeline": "n = ssl3_read_n(s, i, i, 1, 0);"
    },
    {
        "line": 175,
        "fullcodeline": "rr[num_recs].input ="
    },
    {
        "line": 196,
        "fullcodeline": "al = SSL_AD_RECORD_OVERFLOW;"
    },
    {
        "line": 197,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);"
    },
    {
        "line": 216,
        "fullcodeline": "&& s->enc_read_ctx != NULL"
    },
    {
        "line": 235,
        "fullcodeline": "rr[j].length -= mac_size;"
    },
    {
        "line": 236,
        "fullcodeline": "mac = rr[j].data + rr[j].length;"
    },
    {
        "line": 237,
        "fullcodeline": "i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );"
    },
    {
        "line": 316,
        "fullcodeline": "i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );"
    },
    {
        "line": 355,
        "fullcodeline": "al = SSL_AD_RECORD_OVERFLOW;"
    },
    {
        "line": 356,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);"
    },
    {
        "line": 371,
        "fullcodeline": "RECORD_LAYER_inc_empty_record_count(&s->rlayer);"
    },
    {
        "line": 31,
        "fullcodeline": "if (n <= 0)"
    },
    {
        "line": 40,
        "fullcodeline": "if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)"
    },
    {
        "line": 156,
        "fullcodeline": "i = rr[num_recs].length;"
    },
    {
        "line": 162,
        "fullcodeline": "if (n <= 0)"
    },
    {
        "line": 178,
        "fullcodeline": "rr[num_recs].input ="
    },
    {
        "line": 215,
        "fullcodeline": "&& SSL_USE_EXPLICIT_IV(s)"
    },
    {
        "line": 230,
        "fullcodeline": "if (rr[j].length < mac_size) {"
    },
    {
        "line": 238,
        "fullcodeline": "if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {"
    },
    {
        "line": 296,
        "fullcodeline": "if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {"
    },
    {
        "line": 342,
        "fullcodeline": "if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {"
    },
    {
        "line": 372,
        "fullcodeline": "if (RECORD_LAYER_get_empty_record_count(&s->rlayer)"
    },
    {
        "line": 379,
        "fullcodeline": "RECORD_LAYER_reset_empty_record_count(&s->rlayer);"
    },
    {
        "line": 29,
        "fullcodeline": "SSL3_BUFFER_get_len(rbuf), 0,"
    },
    {
        "line": 30,
        "fullcodeline": "num_recs == 0 ? 1 : 0);"
    },
    {
        "line": 41,
        "fullcodeline": "&& (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {"
    },
    {
        "line": 51,
        "fullcodeline": "rr[num_recs].type = SSL3_RT_HANDSHAKE;"
    },
    {
        "line": 52,
        "fullcodeline": "rr[num_recs].rec_version = SSL2_VERSION;"
    },
    {
        "line": 54,
        "fullcodeline": "rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];"
    },
    {
        "line": 214,
        "fullcodeline": "&& rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA"
    },
    {
        "line": 231,
        "fullcodeline": "al = SSL_AD_DECODE_ERROR;"
    },
    {
        "line": 239,
        "fullcodeline": "al = SSL_AD_BAD_RECORD_MAC;"
    },
    {
        "line": 287,
        "fullcodeline": "if (rr[j].orig_len < mac_size ||"
    },
    {
        "line": 289,
        "fullcodeline": "(EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&"
    },
    {
        "line": 291,
        "fullcodeline": "al = SSL_AD_DECODE_ERROR;"
    },
    {
        "line": 303,
        "fullcodeline": "mac = mac_tmp;"
    },
    {
        "line": 304,
        "fullcodeline": "ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);"
    },
    {
        "line": 305,
        "fullcodeline": "rr[j].length -= mac_size;"
    },
    {
        "line": 317,
        "fullcodeline": "if (i < 0 || mac == NULL"
    },
    {
        "line": 318,
        "fullcodeline": "|| CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)"
    },
    {
        "line": 319,
        "fullcodeline": "enc_err = -1;"
    },
    {
        "line": 321,
        "fullcodeline": "enc_err = -1;"
    },
    {
        "line": 343,
        "fullcodeline": "al = SSL_AD_RECORD_OVERFLOW;"
    },
    {
        "line": 344,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);"
    },
    {
        "line": 347,
        "fullcodeline": "if (!ssl3_do_uncompress(s, &rr[j])) {"
    },
    {
        "line": 348,
        "fullcodeline": "al = SSL_AD_DECOMPRESSION_FAILURE;"
    },
    {
        "line": 349,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);"
    },
    {
        "line": 374,
        "fullcodeline": "al = SSL_AD_UNEXPECTED_MESSAGE;"
    },
    {
        "line": 375,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);"
    },
    {
        "line": 56,
        "fullcodeline": "if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)"
    },
    {
        "line": 63,
        "fullcodeline": "if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {"
    },
    {
        "line": 75,
        "fullcodeline": "rr[num_recs].type = *(p++);"
    },
    {
        "line": 76,
        "fullcodeline": "ssl_major = *(p++);"
    },
    {
        "line": 77,
        "fullcodeline": "ssl_minor = *(p++);"
    },
    {
        "line": 78,
        "fullcodeline": "version = (ssl_major << 8) | ssl_minor;"
    },
    {
        "line": 79,
        "fullcodeline": "rr[num_recs].rec_version = version;"
    },
    {
        "line": 80,
        "fullcodeline": "n2s(p, rr[num_recs].length);"
    },
    {
        "line": 176,
        "fullcodeline": "&(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);"
    },
    {
        "line": 290,
        "fullcodeline": "rr[j].orig_len < mac_size + 1)) {"
    },
    {
        "line": 312,
        "fullcodeline": "rr[j].length -= mac_size;"
    },
    {
        "line": 313,
        "fullcodeline": "mac = &rr[j].data[rr[j].length];"
    },
    {
        "line": 58,
        "fullcodeline": "al = SSL_AD_RECORD_OVERFLOW;"
    },
    {
        "line": 64,
        "fullcodeline": "al = SSL_AD_HANDSHAKE_FAILURE;"
    },
    {
        "line": 83,
        "fullcodeline": "if (!s->first_packet && version != s->version) {"
    },
    {
        "line": 107,
        "fullcodeline": "if ((version >> 8) != SSL3_VERSION_MAJOR) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (rr[num_recs].length >"
    },
    {
        "line": 179,
        "fullcodeline": "&(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);"
    },
    {
        "line": 71,
        "fullcodeline": "s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,"
    },
    {
        "line": 103,
        "fullcodeline": "al = SSL_AD_PROTOCOL_VERSION;"
    },
    {
        "line": 137,
        "fullcodeline": "SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {"
    },
    {
        "line": 138,
        "fullcodeline": "al = SSL_AD_RECORD_OVERFLOW;"
    },
    {
        "line": 108,
        "fullcodeline": "if (RECORD_LAYER_is_first_record(&s->rlayer)) {"
    },
    {
        "line": 85,
        "fullcodeline": "if ((s->version & 0xFF00) == (version & 0xFF00)"
    },
    {
        "line": 86,
        "fullcodeline": "&& !s->enc_write_ctx && !s->write_hash) {"
    },
    {
        "line": 101,
        "fullcodeline": "s->version = (unsigned short)version;"
    },
    {
        "line": 111,
        "fullcodeline": "p = RECORD_LAYER_get_packet(&s->rlayer);"
    },
    {
        "line": 87,
        "fullcodeline": "if (rr->type == SSL3_RT_ALERT) {"
    },
    {
        "line": 131,
        "fullcodeline": "al = SSL_AD_PROTOCOL_VERSION;"
    },
    {
        "line": 112,
        "fullcodeline": "if (strncmp((char *)p, \"GET \", 4) == 0 ||"
    },
    {
        "line": 115,
        "fullcodeline": "strncmp((char *)p, \"PUT \", 4) == 0) {"
    },
    {
        "line": 116,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);"
    },
    {
        "line": 114,
        "fullcodeline": "strncmp((char *)p, \"HEAD \", 5) == 0 ||"
    },
    {
        "line": 113,
        "fullcodeline": "strncmp((char *)p, \"POST \", 5) == 0 ||"
    },
    {
        "line": 118,
        "fullcodeline": "} else if (strncmp((char *)p, \"CONNE\", 5) == 0) {"
    },
    {
        "line": 119,
        "fullcodeline": "SSLerr(SSL_F_SSL3_GET_RECORD,"
    }
]