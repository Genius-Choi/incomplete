[
    {
        "line": 3,
        "fullcodeline": "const unsigned char *buf = buf_;"
    },
    {
        "line": 10,
        "fullcodeline": "SSL3_BUFFER *wb = &s->rlayer.wbuf[0];"
    },
    {
        "line": 18,
        "fullcodeline": "s->rwstate = SSL_NOTHING;"
    },
    {
        "line": 19,
        "fullcodeline": "tot = s->rlayer.wnum;"
    },
    {
        "line": 192,
        "fullcodeline": "n = (len - tot);"
    },
    {
        "line": 194,
        "fullcodeline": "split_send_fragment = s->split_send_fragment;"
    },
    {
        "line": 201,
        "fullcodeline": "maxpipes = s->max_pipelines;"
    },
    {
        "line": 13,
        "fullcodeline": "if (len < 0) {"
    },
    {
        "line": 185,
        "fullcodeline": "if (tot == len) {           /* done? */"
    },
    {
        "line": 202,
        "fullcodeline": "if (maxpipes > SSL_MAX_PIPELINES) {"
    },
    {
        "line": 14,
        "fullcodeline": "SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_NEGATIVE_LENGTH);"
    },
    {
        "line": 30,
        "fullcodeline": "SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);"
    },
    {
        "line": 36,
        "fullcodeline": "if (SSL_in_init(s) && !ossl_statem_get_in_handshake(s)) {"
    },
    {
        "line": 37,
        "fullcodeline": "i = s->handshake_func(s);"
    },
    {
        "line": 51,
        "fullcodeline": "i = ssl3_write_pending(s, type, &buf[tot], s->rlayer.wpend_tot);"
    },
    {
        "line": 57,
        "fullcodeline": "tot += i;               /* this might be last fragment */"
    },
    {
        "line": 210,
        "fullcodeline": "if (maxpipes == 0"
    },
    {
        "line": 214,
        "fullcodeline": "|| !SSL_USE_EXPLICIT_IV(s))"
    },
    {
        "line": 215,
        "fullcodeline": "maxpipes = 1;"
    },
    {
        "line": 216,
        "fullcodeline": "if (s->max_send_fragment == 0 || split_send_fragment > s->max_send_fragment"
    },
    {
        "line": 217,
        "fullcodeline": "|| split_send_fragment == 0) {"
    },
    {
        "line": 227,
        "fullcodeline": "unsigned int pipelens[SSL_MAX_PIPELINES], tmppipelen, remain;"
    },
    {
        "line": 256,
        "fullcodeline": "i = do_ssl3_write(s, type, &(buf[tot]), pipelens, numpipes, 0);"
    },
    {
        "line": 279,
        "fullcodeline": "n -= i;"
    },
    {
        "line": 280,
        "fullcodeline": "tot += i;"
    },
    {
        "line": 15,
        "fullcodeline": "return -1;"
    },
    {
        "line": 31,
        "fullcodeline": "return -1;"
    },
    {
        "line": 38,
        "fullcodeline": "if (i < 0)"
    },
    {
        "line": 52,
        "fullcodeline": "if (i <= 0) {"
    },
    {
        "line": 208,
        "fullcodeline": "return -1;"
    },
    {
        "line": 212,
        "fullcodeline": "|| !(EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx))"
    },
    {
        "line": 223,
        "fullcodeline": "return -1;"
    },
    {
        "line": 230,
        "fullcodeline": "if (n == 0)"
    },
    {
        "line": 234,
        "fullcodeline": "if (numpipes > maxpipes)"
    },
    {
        "line": 237,
        "fullcodeline": "if (n / numpipes >= s->max_send_fragment) {"
    },
    {
        "line": 257,
        "fullcodeline": "if (i <= 0) {"
    },
    {
        "line": 41,
        "fullcodeline": "SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);"
    },
    {
        "line": 186,
        "fullcodeline": "if (s->mode & SSL_MODE_RELEASE_BUFFERS && !SSL_IS_DTLS(s))"
    },
    {
        "line": 211,
        "fullcodeline": "|| s->enc_write_ctx == NULL"
    },
    {
        "line": 231,
        "fullcodeline": "numpipes = 1;"
    },
    {
        "line": 235,
        "fullcodeline": "numpipes = maxpipes;"
    },
    {
        "line": 263,
        "fullcodeline": "if ((i == (int)n) ||"
    },
    {
        "line": 264,
        "fullcodeline": "(type == SSL3_RT_APPLICATION_DATA &&"
    },
    {
        "line": 42,
        "fullcodeline": "return -1;"
    },
    {
        "line": 233,
        "fullcodeline": "numpipes = ((n - 1) / split_send_fragment) + 1;"
    },
    {
        "line": 242,
        "fullcodeline": "for (j = 0; j < numpipes; j++) {"
    },
    {
        "line": 247,
        "fullcodeline": "tmppipelen = n / numpipes;"
    },
    {
        "line": 248,
        "fullcodeline": "remain = n % numpipes;"
    },
    {
        "line": 265,
        "fullcodeline": "(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))) {"
    },
    {
        "line": 276,
        "fullcodeline": "return tot + i;"
    },
    {
        "line": 243,
        "fullcodeline": "pipelens[j] = s->max_send_fragment;"
    },
    {
        "line": 249,
        "fullcodeline": "for (j = 0; j < numpipes; j++) {"
    },
    {
        "line": 272,
        "fullcodeline": "if ((i == (int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&"
    },
    {
        "line": 273,
        "fullcodeline": "!SSL_IS_DTLS(s))"
    },
    {
        "line": 250,
        "fullcodeline": "pipelens[j] = tmppipelen;"
    },
    {
        "line": 251,
        "fullcodeline": "if (j < remain)"
    },
    {
        "line": 252,
        "fullcodeline": "pipelens[j]++;"
    }
]