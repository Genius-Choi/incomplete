[
    {
        "line": 5,
        "fullcodeline": "unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];"
    },
    {
        "line": 6,
        "fullcodeline": "SSL3_RECORD wr[SSL_MAX_PIPELINES];"
    },
    {
        "line": 7,
        "fullcodeline": "int i, mac_size, clear = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int prefix_len = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "size_t align = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "unsigned int totlen = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "sess = s->session;"
    },
    {
        "line": 132,
        "fullcodeline": "totlen = 0;"
    },
    {
        "line": 134,
        "fullcodeline": "memset(wr, 0, sizeof wr);"
    },
    {
        "line": 249,
        "fullcodeline": "s->rlayer.wpend_tot = totlen;"
    },
    {
        "line": 250,
        "fullcodeline": "s->rlayer.wpend_buf = buf;"
    },
    {
        "line": 251,
        "fullcodeline": "s->rlayer.wpend_type = type;"
    },
    {
        "line": 252,
        "fullcodeline": "s->rlayer.wpend_ret = totlen;"
    },
    {
        "line": 16,
        "fullcodeline": "for (j = 0; j < numpipes; j++)"
    },
    {
        "line": 17,
        "fullcodeline": "totlen += pipelens[j];"
    },
    {
        "line": 22,
        "fullcodeline": "if (RECORD_LAYER_write_pending(&s->rlayer))"
    },
    {
        "line": 33,
        "fullcodeline": "if (s->rlayer.numwpipes < numpipes)"
    },
    {
        "line": 37,
        "fullcodeline": "if (totlen == 0 && !create_empty_fragment)"
    },
    {
        "line": 42,
        "fullcodeline": "if ((sess == NULL) ||"
    },
    {
        "line": 55,
        "fullcodeline": "if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {"
    },
    {
        "line": 135,
        "fullcodeline": "for (j = 0; j < numpipes; j++) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)"
    },
    {
        "line": 204,
        "fullcodeline": "for (j = 0; j < numpipes; j++) {"
    },
    {
        "line": 255,
        "fullcodeline": "return ssl3_write_pending(s, type, buf, totlen);"
    },
    {
        "line": 257,
        "fullcodeline": "return -1;"
    },
    {
        "line": 27,
        "fullcodeline": "i = s->method->ssl_dispatch_alert(s);"
    },
    {
        "line": 43,
        "fullcodeline": "(s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {"
    },
    {
        "line": 44,
        "fullcodeline": "clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */"
    },
    {
        "line": 45,
        "fullcodeline": "mac_size = 0;"
    },
    {
        "line": 82,
        "fullcodeline": "s->s3->empty_fragment_done = 1;"
    },
    {
        "line": 96,
        "fullcodeline": "outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;"
    },
    {
        "line": 97,
        "fullcodeline": "SSL3_BUFFER_set_offset(wb, align);"
    },
    {
        "line": 116,
        "fullcodeline": "int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);"
    },
    {
        "line": 137,
        "fullcodeline": "*(outbuf[j]++) = type & 0xff;"
    },
    {
        "line": 138,
        "fullcodeline": "SSL3_RECORD_set_type(&wr[j], type);"
    },
    {
        "line": 140,
        "fullcodeline": "*(outbuf[j]++) = (s->version >> 8);"
    },
    {
        "line": 152,
        "fullcodeline": "plen[j] = outbuf[j];"
    },
    {
        "line": 153,
        "fullcodeline": "outbuf[j] += 2;"
    },
    {
        "line": 156,
        "fullcodeline": "SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);"
    },
    {
        "line": 157,
        "fullcodeline": "SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);"
    },
    {
        "line": 158,
        "fullcodeline": "SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);"
    },
    {
        "line": 159,
        "fullcodeline": "totlen += pipelens[j];"
    },
    {
        "line": 190,
        "fullcodeline": "SSL3_RECORD_set_data(&wr[j], outbuf[j]);"
    },
    {
        "line": 191,
        "fullcodeline": "SSL3_RECORD_reset_input(&wr[j]);"
    },
    {
        "line": 213,
        "fullcodeline": "s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);"
    },
    {
        "line": 223,
        "fullcodeline": "SSL3_RECORD_set_type(&wr[j], type); /* not needed but helps for"
    },
    {
        "line": 225,
        "fullcodeline": "SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);"
    },
    {
        "line": 241,
        "fullcodeline": "SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],"
    },
    {
        "line": 23,
        "fullcodeline": "return (ssl3_write_pending(s, type, buf, totlen));"
    },
    {
        "line": 28,
        "fullcodeline": "if (i <= 0)"
    },
    {
        "line": 34,
        "fullcodeline": "if (!ssl3_setup_write_buffer(s, numpipes, 0))"
    },
    {
        "line": 47,
        "fullcodeline": "mac_size = EVP_MD_CTX_size(s->write_hash);"
    },
    {
        "line": 61,
        "fullcodeline": "if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (mode == EVP_CIPH_CBC_MODE) {"
    },
    {
        "line": 130,
        "fullcodeline": "eivlen = 0;"
    },
    {
        "line": 145,
        "fullcodeline": "if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO"
    },
    {
        "line": 166,
        "fullcodeline": "if (s->compress != NULL) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (!SSL_USE_ETM(s) && mac_size != 0) {"
    },
    {
        "line": 205,
        "fullcodeline": "if (SSL_USE_ETM(s) && mac_size != 0) {"
    },
    {
        "line": 242,
        "fullcodeline": "prefix_len + SSL3_RECORD_get_length(&wr[j]));"
    },
    {
        "line": 48,
        "fullcodeline": "if (mac_size < 0)"
    },
    {
        "line": 68,
        "fullcodeline": "unsigned int tmppipelen = 0;"
    },
    {
        "line": 70,
        "fullcodeline": "prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);"
    },
    {
        "line": 118,
        "fullcodeline": "eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);"
    },
    {
        "line": 146,
        "fullcodeline": "&& !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)"
    },
    {
        "line": 147,
        "fullcodeline": "*(outbuf[j]++) = 0x1;"
    },
    {
        "line": 187,
        "fullcodeline": "SSL3_RECORD_add_length(&wr[j], mac_size);"
    },
    {
        "line": 197,
        "fullcodeline": "SSL3_RECORD_add_length(&wr[j], eivlen);"
    },
    {
        "line": 209,
        "fullcodeline": "SSL3_RECORD_add_length(&wr[j], mac_size);"
    },
    {
        "line": 216,
        "fullcodeline": "s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,"
    },
    {
        "line": 35,
        "fullcodeline": "return -1;"
    },
    {
        "line": 71,
        "fullcodeline": "if (prefix_len <= 0)"
    },
    {
        "line": 74,
        "fullcodeline": "if (prefix_len >"
    },
    {
        "line": 100,
        "fullcodeline": "outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)"
    },
    {
        "line": 119,
        "fullcodeline": "if (eivlen <= 1)"
    },
    {
        "line": 149,
        "fullcodeline": "*(outbuf[j]++) = s->version & 0xff;"
    },
    {
        "line": 167,
        "fullcodeline": "if (!ssl3_do_compress(s, &wr[j])) {"
    },
    {
        "line": 173,
        "fullcodeline": "SSL3_RECORD_reset_input(&wr[j]);"
    },
    {
        "line": 183,
        "fullcodeline": "if (s->method->ssl3_enc->mac(s, &wr[j],"
    },
    {
        "line": 206,
        "fullcodeline": "if (s->method->ssl3_enc->mac(s, &wr[j],"
    },
    {
        "line": 232,
        "fullcodeline": "if (j > 0) {"
    },
    {
        "line": 237,
        "fullcodeline": "return SSL3_RECORD_get_length(wr);"
    },
    {
        "line": 75,
        "fullcodeline": "(SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {"
    },
    {
        "line": 77,
        "fullcodeline": "SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);"
    },
    {
        "line": 120,
        "fullcodeline": "eivlen = 0;"
    },
    {
        "line": 123,
        "fullcodeline": "else if (mode == EVP_CIPH_GCM_MODE)"
    },
    {
        "line": 168,
        "fullcodeline": "SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);"
    },
    {
        "line": 234,
        "fullcodeline": "SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);"
    },
    {
        "line": 103,
        "fullcodeline": "for (j = 0; j < numpipes; j++) {"
    },
    {
        "line": 124,
        "fullcodeline": "eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;"
    },
    {
        "line": 207,
        "fullcodeline": "outbuf[j] + wr[j].length, 1) < 0)"
    },
    {
        "line": 109,
        "fullcodeline": "outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;"
    },
    {
        "line": 110,
        "fullcodeline": "SSL3_BUFFER_set_offset(wb, align);"
    },
    {
        "line": 125,
        "fullcodeline": "else if (mode == EVP_CIPH_CCM_MODE)"
    },
    {
        "line": 184,
        "fullcodeline": "&(outbuf[j][wr[j].length + eivlen]),"
    },
    {
        "line": 126,
        "fullcodeline": "eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;"
    },
    {
        "line": 128,
        "fullcodeline": "eivlen = 0;"
    }
]