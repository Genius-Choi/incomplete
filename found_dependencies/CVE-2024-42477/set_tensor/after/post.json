[
    {
        "line": 6,
        "fullcodeline": "const rpc_tensor * in_tensor = (const rpc_tensor *)input.data();"
    },
    {
        "line": 8,
        "fullcodeline": "memcpy(&offset, input.data() + sizeof(rpc_tensor), sizeof(offset));"
    },
    {
        "line": 9,
        "fullcodeline": "const size_t size = input.size() - sizeof(rpc_tensor) - sizeof(offset);"
    },
    {
        "line": 11,
        "fullcodeline": "struct ggml_init_params params {"
    },
    {
        "line": 16,
        "fullcodeline": "struct ggml_context * ctx = ggml_init(params);"
    },
    {
        "line": 17,
        "fullcodeline": "ggml_tensor * tensor = deserialize_tensor(ctx, in_tensor);"
    },
    {
        "line": 35,
        "fullcodeline": "const void * data = input.data() + sizeof(rpc_tensor) + sizeof(offset);"
    },
    {
        "line": 36,
        "fullcodeline": "ggml_backend_tensor_set(tensor, data, offset, size);"
    },
    {
        "line": 37,
        "fullcodeline": "ggml_free(ctx);"
    },
    {
        "line": 3,
        "fullcodeline": "if (input.size() < sizeof(rpc_tensor) + sizeof(uint64_t)) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (tensor == nullptr) {"
    },
    {
        "line": 27,
        "fullcodeline": "const size_t p0 = (size_t) ggml_backend_buffer_get_base(tensor->buffer);"
    },
    {
        "line": 28,
        "fullcodeline": "const size_t p1 = p0 + ggml_backend_buffer_get_size(tensor->buffer);"
    },
    {
        "line": 19,
        "fullcodeline": "GGML_PRINT_DEBUG(\"[%s] error deserializing tensor\\n\", __func__);"
    },
    {
        "line": 20,
        "fullcodeline": "ggml_free(ctx);"
    },
    {
        "line": 30,
        "fullcodeline": "if (in_tensor->data + offset < p0 || in_tensor->data + offset >= p1 || size > (p1 - in_tensor->data - offset)) {"
    },
    {
        "line": 31,
        "fullcodeline": "GGML_ABORT(\"[%s] tensor->data out of bounds\\n\", __func__);"
    }
]