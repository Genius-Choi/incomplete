[
    {
        "line": 3,
        "fullcodeline": "ut64 addr = core->offset;"
    },
    {
        "line": 7,
        "fullcodeline": "int stacksize = r_config_get_i (core->config, \"esil.stack.depth\");"
    },
    {
        "line": 8,
        "fullcodeline": "int iotrap = r_config_get_i (core->config, \"esil.iotrap\");"
    },
    {
        "line": 9,
        "fullcodeline": "int romem = r_config_get_i (core->config, \"esil.romem\");"
    },
    {
        "line": 10,
        "fullcodeline": "int stats = r_config_get_i (core->config, \"esil.stats\");"
    },
    {
        "line": 11,
        "fullcodeline": "int noNULL = r_config_get_i (core->config, \"esil.noNULL\");"
    },
    {
        "line": 12,
        "fullcodeline": "ut64 until_addr = UT64_MAX;"
    },
    {
        "line": 13,
        "fullcodeline": "unsigned int addrsize = r_config_get_i (core->config, \"esil.addr.size\");"
    },
    {
        "line": 15,
        "fullcodeline": "const char *until_expr = NULL;"
    },
    {
        "line": 48,
        "fullcodeline": "cmd_anal_reg (core, input + 1);"
    },
    {
        "line": 65,
        "fullcodeline": "r_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io"
    },
    {
        "line": 66,
        "fullcodeline": "r_anal_esil_set_pc (esil, core->offset);"
    },
    {
        "line": 67,
        "fullcodeline": "r_anal_esil_parse (esil, input + 1);"
    },
    {
        "line": 68,
        "fullcodeline": "r_anal_esil_dumpstack (esil);"
    },
    {
        "line": 69,
        "fullcodeline": "r_anal_esil_stack_free (esil);"
    },
    {
        "line": 428,
        "fullcodeline": "r_core_cmd_help (core, help_msg_ae);"
    },
    {
        "line": 61,
        "fullcodeline": "if (!esil) {"
    },
    {
        "line": 148,
        "fullcodeline": "if (input[1] == '?') { // \"aec?\""
    },
    {
        "line": 274,
        "fullcodeline": "RAnalFunction *fcn = r_anal_get_fcn_in (core->anal,"
    },
    {
        "line": 344,
        "fullcodeline": "if (input[1] == '?') {"
    },
    {
        "line": 366,
        "fullcodeline": "if (input[1] == '?') {"
    },
    {
        "line": 402,
        "fullcodeline": "input = r_str_trim_ro (input + 1);"
    },
    {
        "line": 403,
        "fullcodeline": "hex = strdup (input);"
    },
    {
        "line": 408,
        "fullcodeline": "RAnalOp aop = R_EMPTY;"
    },
    {
        "line": 409,
        "fullcodeline": "bufsz = r_hex_str2bin (hex, (ut8*)hex);"
    },
    {
        "line": 410,
        "fullcodeline": "ret = r_anal_op (core->anal, &aop, core->offset,"
    },
    {
        "line": 418,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 422,
        "fullcodeline": "if (input[1] == '?') {"
    },
    {
        "line": 31,
        "fullcodeline": "r_anal_pin_list (core->anal);"
    },
    {
        "line": 36,
        "fullcodeline": "r_anal_pin_unset (core->anal, addr);"
    },
    {
        "line": 39,
        "fullcodeline": "r_anal_pin (core->anal, addr, input + 2);"
    },
    {
        "line": 42,
        "fullcodeline": "r_core_cmd_help (core, help_msg_aep);"
    },
    {
        "line": 53,
        "fullcodeline": "r_cons_printf (\"trap: %d\\n\", core->anal->esil->trap);"
    },
    {
        "line": 54,
        "fullcodeline": "r_cons_printf (\"trap-code: %d\\n\", core->anal->esil->trap_code);"
    },
    {
        "line": 80,
        "fullcodeline": "eprintf (\"See: ae?~aes\\n\");"
    },
    {
        "line": 99,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 107,
        "fullcodeline": "r_core_esil_step (core, until_addr, until_expr, NULL);"
    },
    {
        "line": 108,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 112,
        "fullcodeline": "op = r_core_anal_op (core, r_reg_getv (core->anal->reg,"
    },
    {
        "line": 117,
        "fullcodeline": "r_core_esil_step (core, until_addr, until_expr, NULL);"
    },
    {
        "line": 118,
        "fullcodeline": "r_anal_op_free (op);"
    },
    {
        "line": 119,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 122,
        "fullcodeline": "n = strchr (input, ' ');"
    },
    {
        "line": 123,
        "fullcodeline": "n1 = n ? strchr (n + 1, ' ') : NULL;"
    },
    {
        "line": 128,
        "fullcodeline": "adr = r_num_math (core->num, n + 1);"
    },
    {
        "line": 129,
        "fullcodeline": "off = r_num_math (core->num, n1 + 1);"
    },
    {
        "line": 130,
        "fullcodeline": "cmd_aespc (core, adr, off);"
    },
    {
        "line": 133,
        "fullcodeline": "n = strchr (input, ' ');"
    },
    {
        "line": 138,
        "fullcodeline": "off = r_num_math (core->num, n + 1);"
    },
    {
        "line": 139,
        "fullcodeline": "cmd_aespc (core, -1, off);"
    },
    {
        "line": 142,
        "fullcodeline": "r_core_esil_step (core, until_addr, until_expr, NULL);"
    },
    {
        "line": 143,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 149,
        "fullcodeline": "r_core_cmd_help (core, help_msg_aec);"
    },
    {
        "line": 204,
        "fullcodeline": "cmd_esil_mem (core, input + 2);"
    },
    {
        "line": 207,
        "fullcodeline": "r_core_cmd0 (core, \"ar PC=$$\");"
    },
    {
        "line": 210,
        "fullcodeline": "cmd_esil_mem (core, \"?\");"
    },
    {
        "line": 216,
        "fullcodeline": "r_anal_esil_free (esil);"
    },
    {
        "line": 217,
        "fullcodeline": "core->anal->esil = NULL;"
    },
    {
        "line": 220,
        "fullcodeline": "r_anal_esil_free (esil);"
    },
    {
        "line": 231,
        "fullcodeline": "r_anal_esil_setup (esil, core->anal, romem, stats, noNULL); // setup io"
    },
    {
        "line": 232,
        "fullcodeline": "esil->verbose = (int)r_config_get_i (core->config, \"esil.verbose\");"
    },
    {
        "line": 250,
        "fullcodeline": "input = \"123*\";"
    },
    {
        "line": 339,
        "fullcodeline": "eprintf (\"Unknown command. Use `aetr`.\\n\");"
    },
    {
        "line": 345,
        "fullcodeline": "r_core_cmd_help (core, help_msg_aea);"
    },
    {
        "line": 367,
        "fullcodeline": "r_core_cmd_help (core, help_msg_aea);"
    },
    {
        "line": 404,
        "fullcodeline": "if (!hex) {"
    },
    {
        "line": 412,
        "fullcodeline": "if (ret>0) {"
    },
    {
        "line": 423,
        "fullcodeline": "r_core_cmd_help (core, help_detail_ae);"
    },
    {
        "line": 22,
        "fullcodeline": "if (input[2] == ' ') {"
    },
    {
        "line": 56,
        "fullcodeline": "eprintf (\"esil vm not initialized. run `aei`\\n\");"
    },
    {
        "line": 62,
        "fullcodeline": "if (!(core->anal->esil = esil = r_anal_esil_new (stacksize, iotrap, addrsize)))"
    },
    {
        "line": 84,
        "fullcodeline": "ut64 pc = r_debug_reg_get (core->dbg, \"PC\");"
    },
    {
        "line": 85,
        "fullcodeline": "RAnalOp *op = r_core_anal_op (core, pc);"
    },
    {
        "line": 90,
        "fullcodeline": "r_core_esil_step (core, UT64_MAX, NULL, NULL);"
    },
    {
        "line": 91,
        "fullcodeline": "r_debug_reg_set (core->dbg, \"PC\", pc + op->size);"
    },
    {
        "line": 92,
        "fullcodeline": "r_anal_esil_set_pc (esil, pc + op->size);"
    },
    {
        "line": 93,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 96,
        "fullcodeline": "if (!r_core_esil_step_back (core)) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (input[2] == 'e') {"
    },
    {
        "line": 114,
        "fullcodeline": "if (op && op->type == R_ANAL_OP_TYPE_CALL) {"
    },
    {
        "line": 124,
        "fullcodeline": "if ((!n || !n1) || (!(n + 1) || !(n1 + 1))) {"
    },
    {
        "line": 134,
        "fullcodeline": "if (!(n + 1)) {"
    },
    {
        "line": 223,
        "fullcodeline": "const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);"
    },
    {
        "line": 228,
        "fullcodeline": "if (!(esil = core->anal->esil = r_anal_esil_new (stacksize, iotrap, addrsize))) {"
    },
    {
        "line": 235,
        "fullcodeline": "const char *s = r_config_get (core->config, \"cmd.esil.intr\");"
    },
    {
        "line": 253,
        "fullcodeline": "if (esil && esil->stats) {"
    },
    {
        "line": 275,
        "fullcodeline": "core->offset, R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);"
    },
    {
        "line": 278,
        "fullcodeline": "r_list_foreach (fcn->bbs, iter, bb) {"
    },
    {
        "line": 315,
        "fullcodeline": "RAnalEsil *esil = r_anal_esil_new (stacksize, iotrap, addrsize);"
    },
    {
        "line": 318,
        "fullcodeline": "r_anal_esil_to_reil_setup (esil, core->anal, romem, stats);"
    },
    {
        "line": 319,
        "fullcodeline": "r_anal_esil_set_pc (esil, core->offset);"
    },
    {
        "line": 320,
        "fullcodeline": "r_anal_esil_parse (esil, input + 2);"
    },
    {
        "line": 321,
        "fullcodeline": "r_anal_esil_dumpstack (esil);"
    },
    {
        "line": 322,
        "fullcodeline": "r_anal_esil_free (esil);"
    },
    {
        "line": 411,
        "fullcodeline": "(const ut8*)hex, bufsz, R_ANAL_OP_MASK_ALL);"
    },
    {
        "line": 413,
        "fullcodeline": "const char *str = R_STRBUF_SAFEGET (&aop.esil);"
    },
    {
        "line": 414,
        "fullcodeline": "char *str2 = r_str_newf (\" %s\", str);"
    },
    {
        "line": 415,
        "fullcodeline": "cmd_anal_esil (core, str2);"
    },
    {
        "line": 416,
        "fullcodeline": "free (str2);"
    },
    {
        "line": 24,
        "fullcodeline": "r_core_cmdf (core, \"ar PC=%s\", input + 3);"
    },
    {
        "line": 25,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 35,
        "fullcodeline": "addr = r_num_math (core->num, input + 2);"
    },
    {
        "line": 87,
        "fullcodeline": "if (!op) {"
    },
    {
        "line": 97,
        "fullcodeline": "eprintf (\"cannnot step back\\n\");"
    },
    {
        "line": 103,
        "fullcodeline": "until_expr = input + 3;"
    },
    {
        "line": 115,
        "fullcodeline": "until_addr = op->addr + op->size;"
    },
    {
        "line": 125,
        "fullcodeline": "eprintf (\"aesp [offset] [num]\\n\");"
    },
    {
        "line": 135,
        "fullcodeline": "r_core_esil_step (core, until_addr, until_expr, NULL);"
    },
    {
        "line": 150,
        "fullcodeline": "} else if (input[1] == 's') { // \"aecs\""
    },
    {
        "line": 214,
        "fullcodeline": "sdb_reset (esil->stats);"
    },
    {
        "line": 224,
        "fullcodeline": "if (r_reg_getv (core->anal->reg, pc) == 0LL) {"
    },
    {
        "line": 254,
        "fullcodeline": "char *out = sdb_querys (esil->stats, NULL, 0, input + 2);"
    },
    {
        "line": 265,
        "fullcodeline": "sdb_reset (esil->stats);"
    },
    {
        "line": 279,
        "fullcodeline": "ut64 pc = bb->addr;"
    },
    {
        "line": 280,
        "fullcodeline": "ut64 end = bb->addr + bb->size;"
    },
    {
        "line": 283,
        "fullcodeline": "int ret, bbs = end - pc;"
    },
    {
        "line": 288,
        "fullcodeline": "buf = calloc (1, bbs + 1);"
    },
    {
        "line": 289,
        "fullcodeline": "r_io_read_at (core->io, pc, buf, bbs);"
    },
    {
        "line": 316,
        "fullcodeline": "if (!esil)"
    },
    {
        "line": 328,
        "fullcodeline": "r_anal_esil_session_list (esil);"
    },
    {
        "line": 331,
        "fullcodeline": "r_anal_esil_session_add (esil);"
    },
    {
        "line": 334,
        "fullcodeline": "r_core_cmd_help (core, help_msg_aets);"
    },
    {
        "line": 346,
        "fullcodeline": "} else if (input[1] == 'r') {"
    },
    {
        "line": 368,
        "fullcodeline": "} else if (input[1] == 'r') {"
    },
    {
        "line": 27,
        "fullcodeline": "eprintf (\"Missing argument\\n\");"
    },
    {
        "line": 105,
        "fullcodeline": "until_addr = r_num_math (core->num, input + 2);"
    },
    {
        "line": 113,
        "fullcodeline": "r_reg_get_name (core->anal->reg, R_REG_NAME_PC)));"
    },
    {
        "line": 151,
        "fullcodeline": "const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);"
    },
    {
        "line": 225,
        "fullcodeline": "r_core_cmd0 (core, \"ar PC=$$\");"
    },
    {
        "line": 237,
        "fullcodeline": "char *my = strdup (s);"
    },
    {
        "line": 260,
        "fullcodeline": "eprintf (\"esil.stats is empty. Run 'aei'\\n\");"
    },
    {
        "line": 284,
        "fullcodeline": "if (bbs < 1 || bbs > 0xfffff) {"
    },
    {
        "line": 291,
        "fullcodeline": "while (pc < end) {"
    },
    {
        "line": 347,
        "fullcodeline": "cmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 369,
        "fullcodeline": "cmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 196,
        "fullcodeline": "r_core_esil_step (core, until_addr, until_expr, NULL);"
    },
    {
        "line": 197,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 256,
        "fullcodeline": "r_cons_println (out);"
    },
    {
        "line": 257,
        "fullcodeline": "free (out);"
    },
    {
        "line": 285,
        "fullcodeline": "eprintf (\"Invalid block size\\n\");"
    },
    {
        "line": 292,
        "fullcodeline": "left = R_MIN (end - pc, 32);"
    },
    {
        "line": 293,
        "fullcodeline": "r_asm_set_pc (core->assembler, pc);"
    },
    {
        "line": 294,
        "fullcodeline": "ret = r_anal_op (core->anal, &op, addr, buf, left, R_ANAL_OP_MASK_ALL); // read overflow"
    },
    {
        "line": 155,
        "fullcodeline": "op = r_core_anal_op (core, addr);"
    },
    {
        "line": 167,
        "fullcodeline": "ret = r_core_esil_step (core, UT64_MAX, NULL, NULL);"
    },
    {
        "line": 168,
        "fullcodeline": "r_anal_op_free (op);"
    },
    {
        "line": 169,
        "fullcodeline": "op = NULL;"
    },
    {
        "line": 175,
        "fullcodeline": "r_core_cmd0 (core, \".ar*\");"
    },
    {
        "line": 176,
        "fullcodeline": "newaddr = r_num_get (core->num, pc);"
    },
    {
        "line": 185,
        "fullcodeline": "r_anal_op_free (op);"
    },
    {
        "line": 191,
        "fullcodeline": "if (input[1] == 'u' && input[2] == 'e')"
    },
    {
        "line": 239,
        "fullcodeline": "r_config_set (core->config, \"cmd.esil.intr\", my);"
    },
    {
        "line": 240,
        "fullcodeline": "free (my);"
    },
    {
        "line": 348,
        "fullcodeline": "} else if (input[1] == 'w') {"
    },
    {
        "line": 370,
        "fullcodeline": "} else if (input[1] == 'w') {"
    },
    {
        "line": 156,
        "fullcodeline": "if (!op) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (op->type == R_ANAL_OP_TYPE_SWI) {"
    },
    {
        "line": 163,
        "fullcodeline": "if (op->type == R_ANAL_OP_TYPE_TRAP) {"
    },
    {
        "line": 173,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 177,
        "fullcodeline": "if (addr == newaddr) {"
    },
    {
        "line": 192,
        "fullcodeline": "until_expr = input + 3;"
    },
    {
        "line": 296,
        "fullcodeline": "r_reg_set_value_by_role (core->anal->reg, R_REG_NAME_PC, pc);"
    },
    {
        "line": 297,
        "fullcodeline": "r_anal_esil_parse (esil, R_STRBUF_SAFEGET (&op.esil));"
    },
    {
        "line": 298,
        "fullcodeline": "r_anal_esil_dumpstack (esil);"
    },
    {
        "line": 299,
        "fullcodeline": "r_anal_esil_stack_free (esil);"
    },
    {
        "line": 300,
        "fullcodeline": "pc += op.size;"
    },
    {
        "line": 349,
        "fullcodeline": "cmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 371,
        "fullcodeline": "cmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 178,
        "fullcodeline": "addr++;"
    },
    {
        "line": 302,
        "fullcodeline": "pc += 4; // XXX"
    },
    {
        "line": 181,
        "fullcodeline": "addr = newaddr;"
    },
    {
        "line": 193,
        "fullcodeline": "else if (input[1] == 'u')"
    },
    {
        "line": 350,
        "fullcodeline": "} else if (input[1] == 'n') {"
    },
    {
        "line": 372,
        "fullcodeline": "} else if (input[1] == 'n') {"
    },
    {
        "line": 194,
        "fullcodeline": "until_addr = r_num_math (core->num, input + 2);"
    },
    {
        "line": 351,
        "fullcodeline": "cmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 373,
        "fullcodeline": "cmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 195,
        "fullcodeline": "else until_expr = \"0\";"
    },
    {
        "line": 352,
        "fullcodeline": "} else if (input[1] == 'j') {"
    },
    {
        "line": 374,
        "fullcodeline": "} else if (input[1] == 'j') {"
    },
    {
        "line": 353,
        "fullcodeline": "cmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 375,
        "fullcodeline": "cmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 354,
        "fullcodeline": "} else if (input[1] == '*') {"
    },
    {
        "line": 376,
        "fullcodeline": "} else if (input[1] == '*') {"
    },
    {
        "line": 355,
        "fullcodeline": "cmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 377,
        "fullcodeline": "cmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));"
    },
    {
        "line": 356,
        "fullcodeline": "} else if (input[1] == 'f') {"
    },
    {
        "line": 378,
        "fullcodeline": "} else if (input[1] == 'f') {"
    },
    {
        "line": 357,
        "fullcodeline": "RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);"
    },
    {
        "line": 379,
        "fullcodeline": "RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);"
    },
    {
        "line": 362,
        "fullcodeline": "cmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input+2));"
    },
    {
        "line": 393,
        "fullcodeline": "const char *arg = input[1]? input + 2: \"\";"
    },
    {
        "line": 394,
        "fullcodeline": "ut64 len = r_num_math (core->num, arg);"
    },
    {
        "line": 395,
        "fullcodeline": "cmd_aea (core, 0, core->offset, len);"
    },
    {
        "line": 359,
        "fullcodeline": "cmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));"
    },
    {
        "line": 384,
        "fullcodeline": "cmd_aea (core, 1<<4, fcn->addr, r_anal_fcn_size (fcn));"
    },
    {
        "line": 387,
        "fullcodeline": "cmd_aea (core, 1, fcn->addr, r_anal_fcn_size (fcn));"
    }
]