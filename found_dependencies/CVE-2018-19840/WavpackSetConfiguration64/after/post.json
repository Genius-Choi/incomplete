[
    {
        "line": 3,
        "fullcodeline": "uint32_t flags, bps = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "uint32_t chan_mask = config->channel_mask;"
    },
    {
        "line": 5,
        "fullcodeline": "int num_chans = config->num_channels;"
    },
    {
        "line": 13,
        "fullcodeline": "wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;"
    },
    {
        "line": 48,
        "fullcodeline": "wpc->total_samples = total_samples;"
    },
    {
        "line": 49,
        "fullcodeline": "wpc->config.sample_rate = config->sample_rate;"
    },
    {
        "line": 50,
        "fullcodeline": "wpc->config.num_channels = config->num_channels;"
    },
    {
        "line": 51,
        "fullcodeline": "wpc->config.channel_mask = config->channel_mask;"
    },
    {
        "line": 52,
        "fullcodeline": "wpc->config.bits_per_sample = config->bits_per_sample;"
    },
    {
        "line": 53,
        "fullcodeline": "wpc->config.bytes_per_sample = config->bytes_per_sample;"
    },
    {
        "line": 54,
        "fullcodeline": "wpc->config.block_samples = config->block_samples;"
    },
    {
        "line": 55,
        "fullcodeline": "wpc->config.flags = config->flags;"
    },
    {
        "line": 56,
        "fullcodeline": "wpc->config.qmode = config->qmode;"
    },
    {
        "line": 65,
        "fullcodeline": "flags |= i << SRATE_LSB;"
    },
    {
        "line": 227,
        "fullcodeline": "wpc->num_streams = wpc->current_stream;"
    },
    {
        "line": 228,
        "fullcodeline": "wpc->current_stream = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "if (!config->sample_rate) {"
    },
    {
        "line": 15,
        "fullcodeline": "if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (config->flags & CONFIG_VERY_HIGH_FLAG)"
    },
    {
        "line": 61,
        "fullcodeline": "for (i = 0; i < 15; ++i)"
    },
    {
        "line": 69,
        "fullcodeline": "if (!(flags & DSD_FLAG)) {"
    },
    {
        "line": 146,
        "fullcodeline": "for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (config->flags & CONFIG_EXTRA_MODE)"
    },
    {
        "line": 9,
        "fullcodeline": "strcpy (wpc->error_message, \"sample rate cannot be zero!\");"
    },
    {
        "line": 41,
        "fullcodeline": "strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");"
    },
    {
        "line": 59,
        "fullcodeline": "wpc->config.flags |= CONFIG_HIGH_FLAG;"
    },
    {
        "line": 62,
        "fullcodeline": "if (wpc->config.sample_rate == sample_rates [i])"
    },
    {
        "line": 116,
        "fullcodeline": "int lastchan = 0, mask_copy = chan_mask;"
    },
    {
        "line": 148,
        "fullcodeline": "unsigned char left_chan_id = 0, right_chan_id = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "int pos, chans = 1;"
    },
    {
        "line": 152,
        "fullcodeline": "wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));"
    },
    {
        "line": 153,
        "fullcodeline": "wpc->streams [wpc->current_stream] = wps;"
    },
    {
        "line": 203,
        "fullcodeline": "num_chans -= chans;"
    },
    {
        "line": 208,
        "fullcodeline": "memcpy (wps->wphdr.ckID, \"wvpk\", 4);"
    },
    {
        "line": 209,
        "fullcodeline": "wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;"
    },
    {
        "line": 210,
        "fullcodeline": "SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);"
    },
    {
        "line": 211,
        "fullcodeline": "wps->wphdr.version = wpc->stream_version;"
    },
    {
        "line": 212,
        "fullcodeline": "wps->wphdr.flags = flags;"
    },
    {
        "line": 213,
        "fullcodeline": "wps->bits = bps;"
    },
    {
        "line": 231,
        "fullcodeline": "strcpy (wpc->error_message, \"too many channels!\");"
    },
    {
        "line": 236,
        "fullcodeline": "wpc->config.xmode = config->xmode ? config->xmode : 1;"
    },
    {
        "line": 46,
        "fullcodeline": "flags = config->bytes_per_sample - 1;"
    },
    {
        "line": 78,
        "fullcodeline": "if (config->flags & CONFIG_HYBRID_FLAG) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))"
    },
    {
        "line": 108,
        "fullcodeline": "if (config->flags & CONFIG_CREATE_WVC)"
    },
    {
        "line": 118,
        "fullcodeline": "if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!"
    },
    {
        "line": 135,
        "fullcodeline": "for (i = 0; chan_ids [i]; i++)"
    },
    {
        "line": 171,
        "fullcodeline": "while (!right_chan_id && chan_ids && *chan_ids)"
    },
    {
        "line": 178,
        "fullcodeline": "if (!left_chan_id)"
    },
    {
        "line": 186,
        "fullcodeline": "if (num_chans >= 2) {"
    },
    {
        "line": 205,
        "fullcodeline": "if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)"
    },
    {
        "line": 215,
        "fullcodeline": "if (!wpc->current_stream)"
    },
    {
        "line": 218,
        "fullcodeline": "if (!num_chans)"
    },
    {
        "line": 221,
        "fullcodeline": "if (chans == 1) {"
    },
    {
        "line": 71,
        "fullcodeline": "wpc->config.float_norm_exp = config->float_norm_exp;"
    },
    {
        "line": 72,
        "fullcodeline": "wpc->config.flags |= CONFIG_FLOAT_DATA;"
    },
    {
        "line": 73,
        "fullcodeline": "flags |= FLOAT_DATA;"
    },
    {
        "line": 79,
        "fullcodeline": "flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;"
    },
    {
        "line": 106,
        "fullcodeline": "flags |= JOINT_STEREO;"
    },
    {
        "line": 109,
        "fullcodeline": "wpc->wvc_flag = TRUE;"
    },
    {
        "line": 119,
        "fullcodeline": "strcpy (wpc->error_message, \"chan_ids longer than num channels!\");"
    },
    {
        "line": 126,
        "fullcodeline": "if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (chan_ids [i] != 0xff) {"
    },
    {
        "line": 179,
        "fullcodeline": "left_chan_id = right_chan_id = 0xff;"
    },
    {
        "line": 216,
        "fullcodeline": "wps->wphdr.flags |= INITIAL_BLOCK;"
    },
    {
        "line": 219,
        "fullcodeline": "wps->wphdr.flags |= FINAL_BLOCK;"
    },
    {
        "line": 222,
        "fullcodeline": "wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);"
    },
    {
        "line": 223,
        "fullcodeline": "wps->wphdr.flags |= MONO_FLAG;"
    },
    {
        "line": 76,
        "fullcodeline": "flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;"
    },
    {
        "line": 81,
        "fullcodeline": "if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))"
    },
    {
        "line": 93,
        "fullcodeline": "if (config->flags & CONFIG_BITRATE_KBPS) {"
    },
    {
        "line": 103,
        "fullcodeline": "flags |= CROSS_DECORR;"
    },
    {
        "line": 127,
        "fullcodeline": "mask_copy &= ~(1 << (*chan_ids-1));"
    },
    {
        "line": 137,
        "fullcodeline": "wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);"
    },
    {
        "line": 158,
        "fullcodeline": "for (pos = 0; pos < 32; ++pos)"
    },
    {
        "line": 173,
        "fullcodeline": "right_chan_id = *chan_ids;"
    },
    {
        "line": 187,
        "fullcodeline": "if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)"
    },
    {
        "line": 82,
        "fullcodeline": "wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;"
    },
    {
        "line": 83,
        "fullcodeline": "flags |= HYBRID_SHAPE | NEW_SHAPING;"
    },
    {
        "line": 91,
        "fullcodeline": "flags |= CROSS_DECORR;"
    },
    {
        "line": 94,
        "fullcodeline": "bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);"
    },
    {
        "line": 159,
        "fullcodeline": "if (chan_mask & (1 << pos)) {"
    },
    {
        "line": 180,
        "fullcodeline": "else if (!right_chan_id)"
    },
    {
        "line": 188,
        "fullcodeline": "chans = 2;"
    },
    {
        "line": 96,
        "fullcodeline": "if (bps > (64 << 8))"
    },
    {
        "line": 100,
        "fullcodeline": "bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);"
    },
    {
        "line": 128,
        "fullcodeline": "lastchan = *chan_ids++;"
    },
    {
        "line": 181,
        "fullcodeline": "right_chan_id = 0xff;"
    },
    {
        "line": 85,
        "fullcodeline": "else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {"
    },
    {
        "line": 97,
        "fullcodeline": "bps = 64 << 8;"
    },
    {
        "line": 175,
        "fullcodeline": "left_chan_id = *chan_ids++;"
    },
    {
        "line": 190,
        "fullcodeline": "for (i = 0; i < NUM_STEREO_PAIRS; ++i)"
    },
    {
        "line": 86,
        "fullcodeline": "wpc->config.shaping_weight = config->shaping_weight;"
    },
    {
        "line": 87,
        "fullcodeline": "flags |= HYBRID_SHAPE | NEW_SHAPING;"
    },
    {
        "line": 161,
        "fullcodeline": "right_chan_id = pos + 1;"
    },
    {
        "line": 191,
        "fullcodeline": "if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||"
    },
    {
        "line": 165,
        "fullcodeline": "chan_mask &= ~(1 << pos);"
    },
    {
        "line": 166,
        "fullcodeline": "left_chan_id = pos + 1;"
    },
    {
        "line": 192,
        "fullcodeline": "(left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {"
    },
    {
        "line": 198,
        "fullcodeline": "chans = 2;"
    },
    {
        "line": 193,
        "fullcodeline": "if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))"
    },
    {
        "line": 194,
        "fullcodeline": "chan_mask &= ~(1 << (right_chan_id-1));"
    },
    {
        "line": 195,
        "fullcodeline": "else if (chan_ids && *chan_ids == right_chan_id)"
    },
    {
        "line": 196,
        "fullcodeline": "chan_ids++;"
    }
]