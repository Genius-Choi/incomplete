[
    {
        "line": 3,
        "fullcodeline": "uint32_t flags, bps = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "uint32_t chan_mask = config->channel_mask;"
    },
    {
        "line": 5,
        "fullcodeline": "int num_chans = config->num_channels;"
    },
    {
        "line": 8,
        "fullcodeline": "wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;"
    },
    {
        "line": 43,
        "fullcodeline": "wpc->total_samples = total_samples;"
    },
    {
        "line": 44,
        "fullcodeline": "wpc->config.sample_rate = config->sample_rate;"
    },
    {
        "line": 50,
        "fullcodeline": "wpc->config.flags = config->flags;"
    },
    {
        "line": 60,
        "fullcodeline": "flags |= i << SRATE_LSB;"
    },
    {
        "line": 10,
        "fullcodeline": "if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (config->flags & CONFIG_VERY_HIGH_FLAG)"
    },
    {
        "line": 56,
        "fullcodeline": "for (i = 0; i < 15; ++i)"
    },
    {
        "line": 141,
        "fullcodeline": "for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {"
    },
    {
        "line": 230,
        "fullcodeline": "if (config->flags & CONFIG_EXTRA_MODE)"
    },
    {
        "line": 36,
        "fullcodeline": "strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");"
    },
    {
        "line": 54,
        "fullcodeline": "wpc->config.flags |= CONFIG_HIGH_FLAG;"
    },
    {
        "line": 64,
        "fullcodeline": "if (!(flags & DSD_FLAG)) {"
    },
    {
        "line": 111,
        "fullcodeline": "int lastchan = 0, mask_copy = chan_mask;"
    },
    {
        "line": 142,
        "fullcodeline": "WavpackStream *wps = malloc (sizeof (WavpackStream));"
    },
    {
        "line": 143,
        "fullcodeline": "unsigned char left_chan_id = 0, right_chan_id = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "int pos, chans = 1;"
    },
    {
        "line": 147,
        "fullcodeline": "wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));"
    },
    {
        "line": 148,
        "fullcodeline": "wpc->streams [wpc->current_stream] = wps;"
    },
    {
        "line": 149,
        "fullcodeline": "CLEAR (*wps);"
    },
    {
        "line": 198,
        "fullcodeline": "num_chans -= chans;"
    },
    {
        "line": 203,
        "fullcodeline": "memcpy (wps->wphdr.ckID, \"wvpk\", 4);"
    },
    {
        "line": 204,
        "fullcodeline": "wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;"
    },
    {
        "line": 205,
        "fullcodeline": "SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);"
    },
    {
        "line": 207,
        "fullcodeline": "wps->wphdr.flags = flags;"
    },
    {
        "line": 208,
        "fullcodeline": "wps->bits = bps;"
    },
    {
        "line": 41,
        "fullcodeline": "flags = config->bytes_per_sample - 1;"
    },
    {
        "line": 73,
        "fullcodeline": "if (config->flags & CONFIG_HYBRID_FLAG) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (config->flags & CONFIG_CREATE_WVC)"
    },
    {
        "line": 113,
        "fullcodeline": "if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!"
    },
    {
        "line": 166,
        "fullcodeline": "while (!right_chan_id && chan_ids && *chan_ids)"
    },
    {
        "line": 173,
        "fullcodeline": "if (!left_chan_id)"
    },
    {
        "line": 181,
        "fullcodeline": "if (num_chans >= 2) {"
    },
    {
        "line": 200,
        "fullcodeline": "if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)"
    },
    {
        "line": 210,
        "fullcodeline": "if (!wpc->current_stream)"
    },
    {
        "line": 213,
        "fullcodeline": "if (!num_chans)"
    },
    {
        "line": 67,
        "fullcodeline": "wpc->config.flags |= CONFIG_FLOAT_DATA;"
    },
    {
        "line": 68,
        "fullcodeline": "flags |= FLOAT_DATA;"
    },
    {
        "line": 74,
        "fullcodeline": "flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;"
    },
    {
        "line": 100,
        "fullcodeline": "if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))"
    },
    {
        "line": 101,
        "fullcodeline": "flags |= JOINT_STEREO;"
    },
    {
        "line": 130,
        "fullcodeline": "for (i = 0; chan_ids [i]; i++)"
    },
    {
        "line": 131,
        "fullcodeline": "if (chan_ids [i] != 0xff) {"
    },
    {
        "line": 174,
        "fullcodeline": "left_chan_id = right_chan_id = 0xff;"
    },
    {
        "line": 211,
        "fullcodeline": "wps->wphdr.flags |= INITIAL_BLOCK;"
    },
    {
        "line": 214,
        "fullcodeline": "wps->wphdr.flags |= FINAL_BLOCK;"
    },
    {
        "line": 217,
        "fullcodeline": "wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);"
    },
    {
        "line": 218,
        "fullcodeline": "wps->wphdr.flags |= MONO_FLAG;"
    },
    {
        "line": 71,
        "fullcodeline": "flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;"
    },
    {
        "line": 88,
        "fullcodeline": "if (config->flags & CONFIG_BITRATE_KBPS) {"
    },
    {
        "line": 98,
        "fullcodeline": "flags |= CROSS_DECORR;"
    },
    {
        "line": 121,
        "fullcodeline": "if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {"
    },
    {
        "line": 122,
        "fullcodeline": "mask_copy &= ~(1 << (*chan_ids-1));"
    },
    {
        "line": 123,
        "fullcodeline": "lastchan = *chan_ids++;"
    },
    {
        "line": 153,
        "fullcodeline": "for (pos = 0; pos < 32; ++pos)"
    },
    {
        "line": 168,
        "fullcodeline": "right_chan_id = *chan_ids;"
    },
    {
        "line": 76,
        "fullcodeline": "if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {"
    },
    {
        "line": 77,
        "fullcodeline": "wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;"
    },
    {
        "line": 78,
        "fullcodeline": "flags |= HYBRID_SHAPE | NEW_SHAPING;"
    },
    {
        "line": 85,
        "fullcodeline": "if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))"
    },
    {
        "line": 86,
        "fullcodeline": "flags |= CROSS_DECORR;"
    },
    {
        "line": 89,
        "fullcodeline": "bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);"
    },
    {
        "line": 154,
        "fullcodeline": "if (chan_mask & (1 << pos)) {"
    },
    {
        "line": 170,
        "fullcodeline": "left_chan_id = *chan_ids++;"
    },
    {
        "line": 175,
        "fullcodeline": "else if (!right_chan_id)"
    },
    {
        "line": 182,
        "fullcodeline": "if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)"
    },
    {
        "line": 183,
        "fullcodeline": "chans = 2;"
    },
    {
        "line": 91,
        "fullcodeline": "if (bps > (64 << 8))"
    },
    {
        "line": 95,
        "fullcodeline": "bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);"
    },
    {
        "line": 132,
        "fullcodeline": "wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);"
    },
    {
        "line": 176,
        "fullcodeline": "right_chan_id = 0xff;"
    },
    {
        "line": 80,
        "fullcodeline": "else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {"
    },
    {
        "line": 92,
        "fullcodeline": "bps = 64 << 8;"
    },
    {
        "line": 185,
        "fullcodeline": "for (i = 0; i < NUM_STEREO_PAIRS; ++i)"
    },
    {
        "line": 82,
        "fullcodeline": "flags |= HYBRID_SHAPE | NEW_SHAPING;"
    },
    {
        "line": 156,
        "fullcodeline": "right_chan_id = pos + 1;"
    },
    {
        "line": 160,
        "fullcodeline": "chan_mask &= ~(1 << pos);"
    },
    {
        "line": 161,
        "fullcodeline": "left_chan_id = pos + 1;"
    },
    {
        "line": 186,
        "fullcodeline": "if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||"
    },
    {
        "line": 187,
        "fullcodeline": "(left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {"
    },
    {
        "line": 193,
        "fullcodeline": "chans = 2;"
    },
    {
        "line": 188,
        "fullcodeline": "if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))"
    },
    {
        "line": 189,
        "fullcodeline": "chan_mask &= ~(1 << (right_chan_id-1));"
    },
    {
        "line": 190,
        "fullcodeline": "else if (chan_ids && *chan_ids == right_chan_id)"
    },
    {
        "line": 191,
        "fullcodeline": "chan_ids++;"
    }
]