[
    {
        "line": 3,
        "fullcodeline": "struct nfs_server *server = NFS_SERVER(state->inode);"
    },
    {
        "line": 5,
        "fullcodeline": "struct nfs4_state_owner *sp = state->owner;"
    },
    {
        "line": 7,
        "fullcodeline": "struct rpc_message msg = {"
    },
    {
        "line": 11,
        "fullcodeline": "struct rpc_task_setup task_setup_data = {"
    },
    {
        "line": 18,
        "fullcodeline": "int status = -ENOMEM;"
    },
    {
        "line": 20,
        "fullcodeline": "calldata = kmalloc(sizeof(*calldata), GFP_KERNEL);"
    },
    {
        "line": 23,
        "fullcodeline": "calldata->inode = state->inode;"
    },
    {
        "line": 24,
        "fullcodeline": "calldata->state = state;"
    },
    {
        "line": 25,
        "fullcodeline": "calldata->arg.fh = NFS_FH(state->inode);"
    },
    {
        "line": 26,
        "fullcodeline": "calldata->arg.stateid = &state->open_stateid;"
    },
    {
        "line": 28,
        "fullcodeline": "calldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);"
    },
    {
        "line": 31,
        "fullcodeline": "calldata->arg.fmode = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "calldata->arg.bitmask = server->attr_bitmask;"
    },
    {
        "line": 33,
        "fullcodeline": "calldata->res.fattr = &calldata->fattr;"
    },
    {
        "line": 34,
        "fullcodeline": "calldata->res.seqid = calldata->arg.seqid;"
    },
    {
        "line": 35,
        "fullcodeline": "calldata->res.server = server;"
    },
    {
        "line": 36,
        "fullcodeline": "calldata->path.mnt = mntget(path->mnt);"
    },
    {
        "line": 37,
        "fullcodeline": "calldata->path.dentry = dget(path->dentry);"
    },
    {
        "line": 39,
        "fullcodeline": "msg.rpc_argp = &calldata->arg,"
    },
    {
        "line": 42,
        "fullcodeline": "task = rpc_run_task(&task_setup_data);"
    },
    {
        "line": 45,
        "fullcodeline": "status = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "rpc_put_task(task);"
    },
    {
        "line": 51,
        "fullcodeline": "kfree(calldata);"
    },
    {
        "line": 53,
        "fullcodeline": "nfs4_put_open_state(state);"
    },
    {
        "line": 54,
        "fullcodeline": "nfs4_put_state_owner(sp);"
    },
    {
        "line": 21,
        "fullcodeline": "if (calldata == NULL)"
    },
    {
        "line": 29,
        "fullcodeline": "if (calldata->arg.seqid == NULL)"
    },
    {
        "line": 40,
        "fullcodeline": "msg.rpc_resp = &calldata->res,"
    },
    {
        "line": 41,
        "fullcodeline": "task_setup_data.callback_data = calldata;"
    },
    {
        "line": 43,
        "fullcodeline": "if (IS_ERR(task))"
    },
    {
        "line": 47,
        "fullcodeline": "status = rpc_wait_for_completion_task(task);"
    },
    {
        "line": 12,
        "fullcodeline": ".rpc_client = server->client,"
    },
    {
        "line": 13,
        "fullcodeline": ".rpc_message = &msg,"
    },
    {
        "line": 14,
        "fullcodeline": ".callback_ops = &nfs4_close_ops,"
    },
    {
        "line": 15,
        "fullcodeline": ".workqueue = nfsiod_workqueue,"
    },
    {
        "line": 16,
        "fullcodeline": ".flags = RPC_TASK_ASYNC,"
    },
    {
        "line": 44,
        "fullcodeline": "return PTR_ERR(task);"
    }
]