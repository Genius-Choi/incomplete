[
    {
        "line": 14,
        "fullcodeline": "size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;"
    },
    {
        "line": 19,
        "fullcodeline": "void* base = leak_malloc(size);"
    },
    {
        "line": 4,
        "fullcodeline": "if (alignment <= MALLOC_ALIGNMENT)"
    },
    {
        "line": 8,
        "fullcodeline": "if (alignment & (alignment-1))"
    },
    {
        "line": 15,
        "fullcodeline": "if (size < bytes) { // Overflow."
    },
    {
        "line": 20,
        "fullcodeline": "if (base != NULL) {"
    },
    {
        "line": 9,
        "fullcodeline": "alignment = 1L << (31 - __builtin_clz(alignment));"
    },
    {
        "line": 21,
        "fullcodeline": "intptr_t ptr = (intptr_t)base;"
    },
    {
        "line": 26,
        "fullcodeline": "ptr += ((-ptr) % alignment);"
    },
    {
        "line": 29,
        "fullcodeline": "((void**)ptr)[-1] = MEMALIGN_GUARD;"
    },
    {
        "line": 30,
        "fullcodeline": "((void**)ptr)[-2] = base;"
    },
    {
        "line": 5,
        "fullcodeline": "return leak_malloc(bytes);"
    },
    {
        "line": 22,
        "fullcodeline": "if ((ptr % alignment) == 0)"
    },
    {
        "line": 32,
        "fullcodeline": "return (void*)ptr;"
    }
]