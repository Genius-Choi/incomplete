[
    {
        "line": 2,
        "fullcodeline": "urls = args.URL"
    },
    {
        "line": 58,
        "fullcodeline": "kwargs = {"
    },
    {
        "line": 62,
        "fullcodeline": "limit_items = None"
    },
    {
        "line": 194,
        "fullcodeline": "kwargs.update({"
    },
    {
        "line": 204,
        "fullcodeline": "result = _create_prompt_choices(**kwargs)"
    },
    {
        "line": 206,
        "fullcodeline": "args.URL = validate_url(result.id)"
    },
    {
        "line": 5,
        "fullcodeline": "not args.search and"
    },
    {
        "line": 6,
        "fullcodeline": "not args.fetch_library_manga and"
    },
    {
        "line": 64,
        "fullcodeline": "def iter_random_manga():"
    },
    {
        "line": 94,
        "fullcodeline": "iterator = iter_random_manga()"
    },
    {
        "line": 95,
        "fullcodeline": "text = f\"Found random manga\""
    },
    {
        "line": 96,
        "fullcodeline": "on_empty_err = f\"Unknown Error\" # This should never happened"
    },
    {
        "line": 97,
        "fullcodeline": "on_preview = preview_cover_manga"
    },
    {
        "line": 98,
        "fullcodeline": "limit_items = 5"
    },
    {
        "line": 202,
        "fullcodeline": "kwargs.update(limit=limit_items)"
    },
    {
        "line": 14,
        "fullcodeline": "result = urls.split(':')"
    },
    {
        "line": 15,
        "fullcodeline": "file = result[1:]"
    },
    {
        "line": 16,
        "fullcodeline": "file_path = \"\""
    },
    {
        "line": 17,
        "fullcodeline": "err_file = False"
    },
    {
        "line": 50,
        "fullcodeline": "file_content = _try_read(urls)"
    },
    {
        "line": 51,
        "fullcodeline": "file_path = file_content if file_content is not None else urls"
    },
    {
        "line": 53,
        "fullcodeline": "args.URL = validate_url(file_path)"
    },
    {
        "line": 105,
        "fullcodeline": "group_id = __validate(group_id)"
    },
    {
        "line": 106,
        "fullcodeline": "group = Group(group_id)"
    },
    {
        "line": 108,
        "fullcodeline": "iterator = search(None, args.unsafe, group=group.id)"
    },
    {
        "line": 109,
        "fullcodeline": "text = f'List manga from group \"{group.name}\"'"
    },
    {
        "line": 110,
        "fullcodeline": "on_empty_err = f'Group \"{group.name}\" has no uploaded mangas'"
    },
    {
        "line": 111,
        "fullcodeline": "on_preview = preview_cover_manga"
    },
    {
        "line": 24,
        "fullcodeline": "if not file_path:"
    },
    {
        "line": 32,
        "fullcodeline": "for f in file:"
    },
    {
        "line": 36,
        "fullcodeline": "if file_path.startswith('http://') or file_path.startswith('https://'):"
    },
    {
        "line": 101,
        "fullcodeline": "_, group_id = get_key_value(urls, sep=':')"
    },
    {
        "line": 102,
        "fullcodeline": "if not group_id:"
    },
    {
        "line": 20,
        "fullcodeline": "file_path += file.pop(0)"
    },
    {
        "line": 25,
        "fullcodeline": "err_file = True"
    },
    {
        "line": 28,
        "fullcodeline": "parser.error(\"Syntax error: file path argument is empty\")"
    },
    {
        "line": 37,
        "fullcodeline": "r = Net.requests.get(file_path)"
    },
    {
        "line": 43,
        "fullcodeline": "file_path = r.text"
    },
    {
        "line": 55,
        "fullcodeline": "parser.error(str(e))"
    },
    {
        "line": 103,
        "fullcodeline": "parser.error(\"group id or url are required\")"
    },
    {
        "line": 113,
        "fullcodeline": "filter_kwargs = {}"
    },
    {
        "line": 114,
        "fullcodeline": "filters = args.search_filter or []"
    },
    {
        "line": 133,
        "fullcodeline": "iterator = search(urls, args.unsafe, **filter_kwargs)"
    },
    {
        "line": 134,
        "fullcodeline": "text = f\"Search results for \\\"{urls}\\\"\""
    },
    {
        "line": 135,
        "fullcodeline": "on_empty_err = f\"Search results \\\"{urls}\\\" are empty\""
    },
    {
        "line": 136,
        "fullcodeline": "on_preview = preview_cover_manga"
    },
    {
        "line": 33,
        "fullcodeline": "file_path += ':' + f"
    },
    {
        "line": 47,
        "fullcodeline": "elif not os.path.exists(file_path):"
    },
    {
        "line": 115,
        "fullcodeline": "for f in filters:"
    },
    {
        "line": 22,
        "fullcodeline": "err_file = True"
    },
    {
        "line": 39,
        "fullcodeline": "r.raise_for_status()"
    },
    {
        "line": 48,
        "fullcodeline": "parser.error(f\"File \\\"{file_path}\\\" is not exist\")"
    },
    {
        "line": 138,
        "fullcodeline": "result = urls.split(':')"
    },
    {
        "line": 152,
        "fullcodeline": "text = f\"Manga library from user \\\"{user.name}\\\"\""
    },
    {
        "line": 153,
        "fullcodeline": "on_empty_err = f\"User \\\"{user.name}\\\" has no saved mangas\""
    },
    {
        "line": 154,
        "fullcodeline": "on_preview = preview_cover_manga"
    },
    {
        "line": 41,
        "fullcodeline": "raise MangaDexException(f\"Failed to connect '{file_path}', status code = {r.status_code}\")"
    },
    {
        "line": 116,
        "fullcodeline": "key, value  = get_key_value(f)"
    },
    {
        "line": 142,
        "fullcodeline": "status = result[1]"
    },
    {
        "line": 147,
        "fullcodeline": "iterator = get_manga_from_user_library(status, args.unsafe)"
    },
    {
        "line": 159,
        "fullcodeline": "user_id = None"
    },
    {
        "line": 180,
        "fullcodeline": "text = f\"MangaDex List library from user \\\"{user.name}\\\"\""
    },
    {
        "line": 181,
        "fullcodeline": "on_empty_err = f\"User \\\"{user.name}\\\" has no saved lists\""
    },
    {
        "line": 182,
        "fullcodeline": "on_preview = lambda x: preview_list(args, x)"
    },
    {
        "line": 118,
        "fullcodeline": "value_filter_kwargs = filter_kwargs[key]"
    },
    {
        "line": 157,
        "fullcodeline": "_, user = get_key_value(urls, sep=':')"
    },
    {
        "line": 128,
        "fullcodeline": "values = split_comma_separated(value, single_value_to_list=True)"
    },
    {
        "line": 129,
        "fullcodeline": "new_values.extend(values)"
    },
    {
        "line": 131,
        "fullcodeline": "filter_kwargs[key] = new_values"
    },
    {
        "line": 144,
        "fullcodeline": "status = None"
    },
    {
        "line": 149,
        "fullcodeline": "parser.error(str(e))"
    },
    {
        "line": 175,
        "fullcodeline": "user = iterator.user"
    },
    {
        "line": 190,
        "fullcodeline": "text = f\"MangaDex followed List from user \\\"{user.name}\\\"\""
    },
    {
        "line": 191,
        "fullcodeline": "on_empty_err = f\"User \\\"{user.name}\\\" has no followed lists\""
    },
    {
        "line": 192,
        "fullcodeline": "on_preview = lambda x: preview_list(args, x)"
    },
    {
        "line": 120,
        "fullcodeline": "filter_kwargs[key] = split_comma_separated(value)"
    },
    {
        "line": 123,
        "fullcodeline": "if isinstance(value_filter_kwargs, str):"
    },
    {
        "line": 124,
        "fullcodeline": "new_values = [value_filter_kwargs]"
    },
    {
        "line": 126,
        "fullcodeline": "new_values = value_filter_kwargs"
    },
    {
        "line": 162,
        "fullcodeline": "user_id = __validate(user)"
    },
    {
        "line": 168,
        "fullcodeline": "iterator = get_list_from_user(user_id)"
    },
    {
        "line": 170,
        "fullcodeline": "iterator = get_list_from_user_library()"
    },
    {
        "line": 172,
        "fullcodeline": "parser.error(str(e))"
    },
    {
        "line": 185,
        "fullcodeline": "iterator = get_followed_list_from_user_library()"
    },
    {
        "line": 164,
        "fullcodeline": "parser.error(f\"\\\"{user}\\\" is not a valid user\")"
    },
    {
        "line": 187,
        "fullcodeline": "parser.error(str(e))"
    }
]