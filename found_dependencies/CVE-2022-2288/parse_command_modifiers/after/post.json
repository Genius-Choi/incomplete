[
    {
        "line": 7,
        "fullcodeline": "char_u  *orig_cmd = eap->cmd;"
    },
    {
        "line": 8,
        "fullcodeline": "char_u  *cmd_start = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t    use_plus_cmd = FALSE;"
    },
    {
        "line": 10,
        "fullcodeline": "int\t    starts_with_colon = FALSE;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t    vim9script = in_vim9script();"
    },
    {
        "line": 12,
        "fullcodeline": "int\t    has_visual_range = FALSE;"
    },
    {
        "line": 14,
        "fullcodeline": "CLEAR_POINTER(cmod);"
    },
    {
        "line": 15,
        "fullcodeline": "cmod->cmod_flags = sticky_cmdmod_flags;"
    },
    {
        "line": 17,
        "fullcodeline": "if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)"
    },
    {
        "line": 24,
        "fullcodeline": "eap->cmd += 5;"
    },
    {
        "line": 25,
        "fullcodeline": "cmd_start = eap->cmd;"
    },
    {
        "line": 26,
        "fullcodeline": "has_visual_range = TRUE;"
    },
    {
        "line": 78,
        "fullcodeline": "p = skip_range(eap->cmd, TRUE, NULL);"
    },
    {
        "line": 34,
        "fullcodeline": "while (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')"
    },
    {
        "line": 42,
        "fullcodeline": "if (*eap->cmd == NUL && exmode_active"
    },
    {
        "line": 54,
        "fullcodeline": "if (comment_start(eap->cmd, starts_with_colon))"
    },
    {
        "line": 67,
        "fullcodeline": "if (*eap->cmd == NUL)"
    },
    {
        "line": 328,
        "fullcodeline": "if (eap->cmd > cmd_start)"
    },
    {
        "line": 38,
        "fullcodeline": "++eap->cmd;"
    },
    {
        "line": 47,
        "fullcodeline": "use_plus_cmd = TRUE;"
    },
    {
        "line": 94,
        "fullcodeline": "n = skipwhite(s);"
    },
    {
        "line": 105,
        "fullcodeline": "cmod->cmod_split |= WSP_ABOVE;"
    },
    {
        "line": 122,
        "fullcodeline": "cmod->cmod_split |= WSP_BOT;"
    },
    {
        "line": 149,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPJUMPS;"
    },
    {
        "line": 206,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 207,
        "fullcodeline": "cmod->cmod_flags |= CMOD_HIDE;"
    },
    {
        "line": 229,
        "fullcodeline": "cmod->cmod_split |= WSP_ABOVE;"
    },
    {
        "line": 239,
        "fullcodeline": "cmod->cmod_flags |= CMOD_NOSWAPFILE;"
    },
    {
        "line": 244,
        "fullcodeline": "cmod->cmod_split |= WSP_BELOW;"
    },
    {
        "line": 254,
        "fullcodeline": "cmod->cmod_flags |= CMOD_SILENT;"
    },
    {
        "line": 287,
        "fullcodeline": "cmod->cmod_split |= WSP_TOP;"
    },
    {
        "line": 292,
        "fullcodeline": "cmod->cmod_flags |= CMOD_UNSILENT;"
    },
    {
        "line": 320,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 36,
        "fullcodeline": "if (*eap->cmd == ':')"
    },
    {
        "line": 43,
        "fullcodeline": "&& (getline_equal(eap->getline, eap->cookie, getexmodeline)"
    },
    {
        "line": 48,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 57,
        "fullcodeline": "if (eap->nextcmd == NULL)"
    },
    {
        "line": 63,
        "fullcodeline": "if (vim9script && has_cmdmod(cmod, FALSE))"
    },
    {
        "line": 69,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 92,
        "fullcodeline": "for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)"
    },
    {
        "line": 95,
        "fullcodeline": "if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')"
    },
    {
        "line": 103,
        "fullcodeline": "case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))"
    },
    {
        "line": 108,
        "fullcodeline": "case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))"
    },
    {
        "line": 113,
        "fullcodeline": "if (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))"
    },
    {
        "line": 120,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))"
    },
    {
        "line": 125,
        "fullcodeline": "case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))"
    },
    {
        "line": 132,
        "fullcodeline": "case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))"
    },
    {
        "line": 137,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))"
    },
    {
        "line": 142,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))"
    },
    {
        "line": 147,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))"
    },
    {
        "line": 155,
        "fullcodeline": "char_u  *nulp = NULL;"
    },
    {
        "line": 156,
        "fullcodeline": "int\t    c = 0;"
    },
    {
        "line": 198,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 203,
        "fullcodeline": "case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)"
    },
    {
        "line": 210,
        "fullcodeline": "case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))"
    },
    {
        "line": 215,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))"
    },
    {
        "line": 227,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))"
    },
    {
        "line": 232,
        "fullcodeline": "case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))"
    },
    {
        "line": 237,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))"
    },
    {
        "line": 242,
        "fullcodeline": "case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))"
    },
    {
        "line": 247,
        "fullcodeline": "case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))"
    },
    {
        "line": 252,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))"
    },
    {
        "line": 255,
        "fullcodeline": "if (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))"
    },
    {
        "line": 263,
        "fullcodeline": "case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))"
    },
    {
        "line": 285,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))"
    },
    {
        "line": 290,
        "fullcodeline": "case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))"
    },
    {
        "line": 295,
        "fullcodeline": "case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))"
    },
    {
        "line": 300,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))"
    },
    {
        "line": 311,
        "fullcodeline": "if (!checkforcmd_noparen(&p, \"verbose\", 4))"
    },
    {
        "line": 313,
        "fullcodeline": "if (vim_isdigit(*eap->cmd))"
    },
    {
        "line": 361,
        "fullcodeline": "eap->cmd = (char_u *)\"+\";"
    },
    {
        "line": 37,
        "fullcodeline": "starts_with_colon = TRUE;"
    },
    {
        "line": 44,
        "fullcodeline": "|| getline_equal(eap->getline, eap->cookie, getexline))"
    },
    {
        "line": 49,
        "fullcodeline": "ex_pressedreturn = TRUE;"
    },
    {
        "line": 59,
        "fullcodeline": "eap->nextcmd = vim_strchr(eap->cmd, '\\n');"
    },
    {
        "line": 64,
        "fullcodeline": "*errormsg = _(e_command_modifier_without_command);"
    },
    {
        "line": 71,
        "fullcodeline": "ex_pressedreturn = TRUE;"
    },
    {
        "line": 96,
        "fullcodeline": "|| *s == '[')"
    },
    {
        "line": 110,
        "fullcodeline": "cmod->cmod_split |= WSP_BELOW;"
    },
    {
        "line": 134,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPMARKS;"
    },
    {
        "line": 139,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPALT;"
    },
    {
        "line": 144,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPPATTERNS;"
    },
    {
        "line": 158,
        "fullcodeline": "if (!checkforcmd_noparen(&p, \"filter\", 4)"
    },
    {
        "line": 168,
        "fullcodeline": "if (*p == '!')"
    },
    {
        "line": 186,
        "fullcodeline": "if (p == NULL || *p == NUL)"
    },
    {
        "line": 188,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 204,
        "fullcodeline": "|| *p == NUL || ends_excmd(*p))"
    },
    {
        "line": 212,
        "fullcodeline": "cmod->cmod_flags |= CMOD_LOCKMARKS;"
    },
    {
        "line": 223,
        "fullcodeline": "cmod->cmod_flags |= CMOD_LEGACY;"
    },
    {
        "line": 234,
        "fullcodeline": "cmod->cmod_flags |= CMOD_NOAUTOCMD;"
    },
    {
        "line": 249,
        "fullcodeline": "cmod->cmod_flags |= CMOD_SANDBOX;"
    },
    {
        "line": 258,
        "fullcodeline": "eap->cmd = skipwhite(eap->cmd + 1);"
    },
    {
        "line": 259,
        "fullcodeline": "cmod->cmod_flags |= CMOD_ERRSILENT;"
    },
    {
        "line": 282,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 297,
        "fullcodeline": "cmod->cmod_split |= WSP_VERT;"
    },
    {
        "line": 308,
        "fullcodeline": "cmod->cmod_flags |= CMOD_VIM9CMD;"
    },
    {
        "line": 316,
        "fullcodeline": "cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;"
    },
    {
        "line": 336,
        "fullcodeline": "size_t len = STRLEN(cmd_start);"
    },
    {
        "line": 342,
        "fullcodeline": "mch_memmove(orig_cmd, cmd_start, len);"
    },
    {
        "line": 343,
        "fullcodeline": "STRCPY(orig_cmd + len, \" *+\");"
    },
    {
        "line": 60,
        "fullcodeline": "if (eap->nextcmd != NULL)"
    },
    {
        "line": 72,
        "fullcodeline": "if (vim9script && has_cmdmod(cmod, FALSE))"
    },
    {
        "line": 160,
        "fullcodeline": "|| (ends_excmd(*p)"
    },
    {
        "line": 170,
        "fullcodeline": "cmod->cmod_filter_force = TRUE;"
    },
    {
        "line": 171,
        "fullcodeline": "p = skipwhite(p + 1);"
    },
    {
        "line": 181,
        "fullcodeline": "p = skip_vimgrep_pat(p, NULL, NULL);"
    },
    {
        "line": 190,
        "fullcodeline": "cmod->cmod_filter_regmatch.regprog ="
    },
    {
        "line": 217,
        "fullcodeline": "if (ends_excmd2(p, eap->cmd))"
    },
    {
        "line": 265,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 302,
        "fullcodeline": "if (ends_excmd2(p, eap->cmd))"
    },
    {
        "line": 319,
        "fullcodeline": "cmod->cmod_verbose = 2;  // default: verbose == 1"
    },
    {
        "line": 347,
        "fullcodeline": "mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);"
    },
    {
        "line": 348,
        "fullcodeline": "eap->cmd -= 5;"
    },
    {
        "line": 349,
        "fullcodeline": "mch_memmove(eap->cmd - 1, \":'<,'>\", 6);"
    },
    {
        "line": 356,
        "fullcodeline": "eap->cmd = (char_u *)\"'<,'>+\";"
    },
    {
        "line": 61,
        "fullcodeline": "++eap->nextcmd;"
    },
    {
        "line": 73,
        "fullcodeline": "*errormsg = _(e_command_modifier_without_command);"
    },
    {
        "line": 159,
        "fullcodeline": "|| *p == NUL"
    },
    {
        "line": 172,
        "fullcodeline": "if (*p == NUL || ends_excmd(*p))"
    },
    {
        "line": 184,
        "fullcodeline": "p = skip_vimgrep_pat_ext(p, &reg_pat, NULL,"
    },
    {
        "line": 191,
        "fullcodeline": "vim_regcomp(reg_pat, RE_MAGIC);"
    },
    {
        "line": 192,
        "fullcodeline": "if (cmod->cmod_filter_regmatch.regprog == NULL)"
    },
    {
        "line": 195,
        "fullcodeline": "if (nulp != NULL)"
    },
    {
        "line": 219,
        "fullcodeline": "*errormsg ="
    },
    {
        "line": 267,
        "fullcodeline": "long tabnr = get_address(eap, &eap->cmd,"
    },
    {
        "line": 304,
        "fullcodeline": "*errormsg ="
    },
    {
        "line": 358,
        "fullcodeline": "eap->cmd = orig_cmd;"
    },
    {
        "line": 196,
        "fullcodeline": "*nulp = c;"
    },
    {
        "line": 220,
        "fullcodeline": "_(e_legacy_must_be_followed_by_command);"
    },
    {
        "line": 270,
        "fullcodeline": "if (tabnr == MAXLNUM)"
    },
    {
        "line": 305,
        "fullcodeline": "_(e_vim9cmd_must_be_followed_by_command);"
    },
    {
        "line": 271,
        "fullcodeline": "cmod->cmod_tab = tabpage_index(curtab) + 1;"
    },
    {
        "line": 279,
        "fullcodeline": "cmod->cmod_tab = tabnr + 1;"
    },
    {
        "line": 274,
        "fullcodeline": "if (tabnr < 0 || tabnr > LAST_TAB_NR)"
    },
    {
        "line": 276,
        "fullcodeline": "*errormsg = _(e_invalid_range);"
    }
]