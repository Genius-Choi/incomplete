[
    {
        "line": 5,
        "fullcodeline": "struct vm_area_struct *vma = find_vma(mm, addr);"
    },
    {
        "line": 7,
        "fullcodeline": "if (!vma || vma->vm_start > addr)"
    },
    {
        "line": 10,
        "fullcodeline": "if (is_vm_hugetlb_page(vma))"
    },
    {
        "line": 14,
        "fullcodeline": "if (old_len > vma->vm_end - addr)"
    },
    {
        "line": 17,
        "fullcodeline": "if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (vma->vm_flags & VM_LOCKED) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))"
    },
    {
        "line": 34,
        "fullcodeline": "if (vma->vm_flags & VM_ACCOUNT) {"
    },
    {
        "line": 44,
        "fullcodeline": "return ERR_PTR(-EFAULT);"
    },
    {
        "line": 46,
        "fullcodeline": "return ERR_PTR(-EINVAL);"
    },
    {
        "line": 48,
        "fullcodeline": "return ERR_PTR(-ENOMEM);"
    },
    {
        "line": 50,
        "fullcodeline": "return ERR_PTR(-EAGAIN);"
    },
    {
        "line": 24,
        "fullcodeline": "locked = mm->locked_vm << PAGE_SHIFT;"
    },
    {
        "line": 25,
        "fullcodeline": "lock_limit = rlimit(RLIMIT_MEMLOCK);"
    },
    {
        "line": 26,
        "fullcodeline": "locked += new_len - old_len;"
    },
    {
        "line": 35,
        "fullcodeline": "unsigned long charged = (new_len - old_len) >> PAGE_SHIFT;"
    },
    {
        "line": 38,
        "fullcodeline": "*p = charged;"
    },
    {
        "line": 18,
        "fullcodeline": "if (new_len > old_len)"
    },
    {
        "line": 27,
        "fullcodeline": "if (locked > lock_limit && !capable(CAP_IPC_LOCK))"
    },
    {
        "line": 36,
        "fullcodeline": "if (security_vm_enough_memory(charged))"
    }
]