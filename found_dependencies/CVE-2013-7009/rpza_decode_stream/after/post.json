[
    {
        "line": 4,
        "fullcodeline": "int stride = s->frame.linesize[0] / 2;"
    },
    {
        "line": 5,
        "fullcodeline": "int row_inc = stride - 4;"
    },
    {
        "line": 6,
        "fullcodeline": "int stream_ptr = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "unsigned short colorA = 0, colorB;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned short color4[4];"
    },
    {
        "line": 16,
        "fullcodeline": "int row_ptr = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "int pixel_ptr = -4;"
    },
    {
        "line": 28,
        "fullcodeline": "chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;"
    },
    {
        "line": 29,
        "fullcodeline": "stream_ptr += 4;"
    },
    {
        "line": 35,
        "fullcodeline": "chunk_size = s->size;"
    },
    {
        "line": 38,
        "fullcodeline": "total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);"
    },
    {
        "line": 23,
        "fullcodeline": "if (s->buf[stream_ptr] != 0xe1)"
    },
    {
        "line": 32,
        "fullcodeline": "if (chunk_size != s->size)"
    },
    {
        "line": 41,
        "fullcodeline": "while (stream_ptr < chunk_size) {"
    },
    {
        "line": 24,
        "fullcodeline": "av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\","
    },
    {
        "line": 33,
        "fullcodeline": "av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");"
    },
    {
        "line": 42,
        "fullcodeline": "opcode = s->buf[stream_ptr++]; /* Get opcode */"
    },
    {
        "line": 44,
        "fullcodeline": "n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */"
    },
    {
        "line": 47,
        "fullcodeline": "if ((opcode & 0x80) == 0) {"
    },
    {
        "line": 59,
        "fullcodeline": "switch (opcode & 0xe0) {"
    },
    {
        "line": 48,
        "fullcodeline": "colorA = (opcode << 8) | (s->buf[stream_ptr++]);"
    },
    {
        "line": 49,
        "fullcodeline": "opcode = 0;"
    },
    {
        "line": 70,
        "fullcodeline": "colorA = AV_RB16 (&s->buf[stream_ptr]);"
    },
    {
        "line": 71,
        "fullcodeline": "stream_ptr += 2;"
    },
    {
        "line": 87,
        "fullcodeline": "colorA = AV_RB16 (&s->buf[stream_ptr]);"
    },
    {
        "line": 88,
        "fullcodeline": "stream_ptr += 2;"
    },
    {
        "line": 90,
        "fullcodeline": "colorB = AV_RB16 (&s->buf[stream_ptr]);"
    },
    {
        "line": 91,
        "fullcodeline": "stream_ptr += 2;"
    },
    {
        "line": 94,
        "fullcodeline": "color4[0] = colorB;"
    },
    {
        "line": 95,
        "fullcodeline": "color4[1] = 0;"
    },
    {
        "line": 96,
        "fullcodeline": "color4[2] = 0;"
    },
    {
        "line": 97,
        "fullcodeline": "color4[3] = colorA;"
    },
    {
        "line": 100,
        "fullcodeline": "ta = (colorA >> 10) & 0x1F;"
    },
    {
        "line": 101,
        "fullcodeline": "tb = (colorB >> 10) & 0x1F;"
    },
    {
        "line": 102,
        "fullcodeline": "color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;"
    },
    {
        "line": 103,
        "fullcodeline": "color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;"
    },
    {
        "line": 106,
        "fullcodeline": "ta = (colorA >> 5) & 0x1F;"
    },
    {
        "line": 107,
        "fullcodeline": "tb = (colorB >> 5) & 0x1F;"
    },
    {
        "line": 108,
        "fullcodeline": "color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;"
    },
    {
        "line": 109,
        "fullcodeline": "color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;"
    },
    {
        "line": 112,
        "fullcodeline": "ta = colorA & 0x1F;"
    },
    {
        "line": 113,
        "fullcodeline": "tb = colorB & 0x1F;"
    },
    {
        "line": 114,
        "fullcodeline": "color4[1] |= ((11 * ta + 21 * tb) >> 5);"
    },
    {
        "line": 115,
        "fullcodeline": "color4[2] |= ((21 * ta + 11 * tb) >> 5);"
    },
    {
        "line": 138,
        "fullcodeline": "ADVANCE_BLOCK();"
    },
    {
        "line": 139,
        "fullcodeline": "block_ptr = row_ptr + pixel_ptr;"
    },
    {
        "line": 156,
        "fullcodeline": "av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\""
    },
    {
        "line": 50,
        "fullcodeline": "if ((s->buf[stream_ptr] & 0x80) != 0) {"
    },
    {
        "line": 63,
        "fullcodeline": "while (n_blocks--) {"
    },
    {
        "line": 72,
        "fullcodeline": "while (n_blocks--) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (s->size - stream_ptr < n_blocks * 4)"
    },
    {
        "line": 119,
        "fullcodeline": "while (n_blocks--) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (s->size - stream_ptr < 16)"
    },
    {
        "line": 140,
        "fullcodeline": "for (pixel_y = 0; pixel_y < 4; pixel_y++) {"
    },
    {
        "line": 158,
        "fullcodeline": "chunk_size - stream_ptr);"
    },
    {
        "line": 54,
        "fullcodeline": "opcode = 0x20;"
    },
    {
        "line": 55,
        "fullcodeline": "n_blocks = 1;"
    },
    {
        "line": 64,
        "fullcodeline": "ADVANCE_BLOCK();"
    },
    {
        "line": 73,
        "fullcodeline": "ADVANCE_BLOCK()"
    },
    {
        "line": 74,
        "fullcodeline": "block_ptr = row_ptr + pixel_ptr;"
    },
    {
        "line": 120,
        "fullcodeline": "ADVANCE_BLOCK();"
    },
    {
        "line": 121,
        "fullcodeline": "block_ptr = row_ptr + pixel_ptr;"
    },
    {
        "line": 150,
        "fullcodeline": "block_ptr += row_inc;"
    },
    {
        "line": 75,
        "fullcodeline": "for (pixel_y = 0; pixel_y < 4; pixel_y++) {"
    },
    {
        "line": 122,
        "fullcodeline": "for (pixel_y = 0; pixel_y < 4; pixel_y++) {"
    },
    {
        "line": 141,
        "fullcodeline": "for (pixel_x = 0; pixel_x < 4; pixel_x++){"
    },
    {
        "line": 80,
        "fullcodeline": "block_ptr += row_inc;"
    },
    {
        "line": 123,
        "fullcodeline": "index = s->buf[stream_ptr++];"
    },
    {
        "line": 129,
        "fullcodeline": "block_ptr += row_inc;"
    },
    {
        "line": 147,
        "fullcodeline": "pixels[block_ptr] = colorA;"
    },
    {
        "line": 148,
        "fullcodeline": "block_ptr++;"
    },
    {
        "line": 76,
        "fullcodeline": "for (pixel_x = 0; pixel_x < 4; pixel_x++){"
    },
    {
        "line": 124,
        "fullcodeline": "for (pixel_x = 0; pixel_x < 4; pixel_x++){"
    },
    {
        "line": 143,
        "fullcodeline": "if ((pixel_y != 0) || (pixel_x !=0)) {"
    },
    {
        "line": 77,
        "fullcodeline": "pixels[block_ptr] = colorA;"
    },
    {
        "line": 78,
        "fullcodeline": "block_ptr++;"
    },
    {
        "line": 125,
        "fullcodeline": "idx = (index >> (2 * (3 - pixel_x))) & 0x03;"
    },
    {
        "line": 126,
        "fullcodeline": "pixels[block_ptr] = color4[idx];"
    },
    {
        "line": 127,
        "fullcodeline": "block_ptr++;"
    },
    {
        "line": 144,
        "fullcodeline": "colorA = AV_RB16 (&s->buf[stream_ptr]);"
    },
    {
        "line": 145,
        "fullcodeline": "stream_ptr += 2;"
    }
]