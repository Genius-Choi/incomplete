[
    {
        "line": 6,
        "fullcodeline": "u32 index = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "u8 ch_list_idx = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "u8 op_ch_idx = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "if (sta_ch == WILC_INVALID_CHANNEL)"
    },
    {
        "line": 14,
        "fullcodeline": "e = (struct wilc_attr_entry *)&buf[index];"
    },
    {
        "line": 21,
        "fullcodeline": "index += le16_to_cpu(e->attr_len) + sizeof(*e);"
    },
    {
        "line": 29,
        "fullcodeline": "ch_list = (struct wilc_attr_ch_list *)&buf[ch_list_idx];"
    },
    {
        "line": 30,
        "fullcodeline": "attr_size = le16_to_cpu(ch_list->attr_len);"
    },
    {
        "line": 15,
        "fullcodeline": "if (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST)"
    },
    {
        "line": 31,
        "fullcodeline": "for (i = 0; i < attr_size;) {"
    },
    {
        "line": 16,
        "fullcodeline": "ch_list_idx = index;"
    },
    {
        "line": 32,
        "fullcodeline": "e = (struct wilc_ch_list_elem *)(ch_list->elem + i);"
    },
    {
        "line": 37,
        "fullcodeline": "i += e->no_of_channels;"
    },
    {
        "line": 33,
        "fullcodeline": "if (e->op_class == WILC_WLAN_OPERATING_CLASS_2_4GHZ) {"
    },
    {
        "line": 17,
        "fullcodeline": "else if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL)"
    },
    {
        "line": 34,
        "fullcodeline": "memset(e->ch_list, sta_ch, e->no_of_channels);"
    },
    {
        "line": 18,
        "fullcodeline": "op_ch_idx = index;"
    }
]