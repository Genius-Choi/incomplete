[
    {
        "line": 3,
        "fullcodeline": "BLOSC_UNUSED_PARAM(meta);"
    },
    {
        "line": 4,
        "fullcodeline": "BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);"
    },
    {
        "line": 5,
        "fullcodeline": "BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);"
    },
    {
        "line": 15,
        "fullcodeline": "int64_t *shape = malloc(8 * sizeof(int64_t));"
    },
    {
        "line": 16,
        "fullcodeline": "int32_t *chunkshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 17,
        "fullcodeline": "int32_t *blockshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 18,
        "fullcodeline": "deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);"
    },
    {
        "line": 36,
        "fullcodeline": "uint8_t *ip = (uint8_t *) input;"
    },
    {
        "line": 37,
        "fullcodeline": "uint8_t *op = (uint8_t *) output;"
    },
    {
        "line": 42,
        "fullcodeline": "uint8_t bufarea[16];"
    },
    {
        "line": 43,
        "fullcodeline": "uint8_t *buf_cell = bufarea;"
    },
    {
        "line": 44,
        "fullcodeline": "uint8_t buf_triple[12];"
    },
    {
        "line": 45,
        "fullcodeline": "uint8_t buf_pair[8];"
    },
    {
        "line": 47,
        "fullcodeline": "uint32_t tab_cell[1U << 12U] = {0};"
    },
    {
        "line": 48,
        "fullcodeline": "uint32_t tab_triple[1U << 12U] = {0};"
    },
    {
        "line": 49,
        "fullcodeline": "uint32_t tab_pair[1U << 12U] = {0};"
    },
    {
        "line": 50,
        "fullcodeline": "uint32_t update_triple[2] = {0};"
    },
    {
        "line": 51,
        "fullcodeline": "uint32_t update_pair[3] = {0};"
    },
    {
        "line": 56,
        "fullcodeline": "op_limit = op + output_len;"
    },
    {
        "line": 64,
        "fullcodeline": "int overhead = 17 + (blockshape[0] * blockshape[1] / 16 - 1) * 2;"
    },
    {
        "line": 70,
        "fullcodeline": "uint8_t *obase = op;"
    },
    {
        "line": 74,
        "fullcodeline": "memcpy(op, &blockshape[0], 4);"
    },
    {
        "line": 75,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 76,
        "fullcodeline": "memcpy(op, &blockshape[1], 4);"
    },
    {
        "line": 77,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 79,
        "fullcodeline": "uint32_t i_stop[2];"
    },
    {
        "line": 85,
        "fullcodeline": "uint32_t padding[2];"
    },
    {
        "line": 86,
        "fullcodeline": "uint32_t ii[2];"
    },
    {
        "line": 9,
        "fullcodeline": "if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (ndim != 2) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (input_len != (blockshape[0] * blockshape[1])) {"
    },
    {
        "line": 40,
        "fullcodeline": "uint32_t hash_triple[2] = {0};"
    },
    {
        "line": 41,
        "fullcodeline": "uint32_t hash_pair[3] = {0};"
    },
    {
        "line": 59,
        "fullcodeline": "for (unsigned i = 0; i < (1U << 12U); i++) {"
    },
    {
        "line": 80,
        "fullcodeline": "for (int i = 0; i < 2; ++i) {"
    },
    {
        "line": 87,
        "fullcodeline": "for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {"
    },
    {
        "line": 396,
        "fullcodeline": "return (int) (op - obase);"
    },
    {
        "line": 10,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"b2nd layer not found!\");"
    },
    {
        "line": 31,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (input_len < 16 || output_len < overhead) {"
    },
    {
        "line": 73,
        "fullcodeline": "*op++ = ndim;"
    },
    {
        "line": 81,
        "fullcodeline": "i_stop[i] = (blockshape[i] + 3) / 4;"
    },
    {
        "line": 88,
        "fullcodeline": "for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell"
    },
    {
        "line": 103,
        "fullcodeline": "uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;"
    },
    {
        "line": 90,
        "fullcodeline": "for (int h = 0; h < 2; h++) {         // new cell -> new possible references"
    },
    {
        "line": 91,
        "fullcodeline": "update_triple[h] = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "update_pair[h] = 0;"
    },
    {
        "line": 96,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(op + 16 + 1 > op_limit)) {"
    },
    {
        "line": 104,
        "fullcodeline": "if (((blockshape[0] % 4 != 0) && (ii[0] == i_stop[0] - 1)) ||"
    },
    {
        "line": 105,
        "fullcodeline": "((blockshape[1] % 4 != 0) && (ii[1] == i_stop[1] - 1))) {"
    },
    {
        "line": 106,
        "fullcodeline": "token = 0;                                   // padding -> literal copy"
    },
    {
        "line": 385,
        "fullcodeline": "if ((op - obase) > input_len) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (ii[0] == i_stop[0] - 1) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (ii[1] == i_stop[1] - 1) {"
    },
    {
        "line": 118,
        "fullcodeline": "for (uint32_t i = 0; i < padding[0]; i++) {"
    },
    {
        "line": 128,
        "fullcodeline": "buf_cell -= 16;"
    },
    {
        "line": 132,
        "fullcodeline": "uint8_t *anchor = op;    /* comparison starting-point */"
    },
    {
        "line": 135,
        "fullcodeline": "hash_cell = XXH32(buf_cell, 16, 1);        // calculate cell hash"
    },
    {
        "line": 137,
        "fullcodeline": "ref = obase + tab_cell[hash_cell];"
    },
    {
        "line": 107,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 109,
        "fullcodeline": "padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;"
    },
    {
        "line": 114,
        "fullcodeline": "padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;"
    },
    {
        "line": 119,
        "fullcodeline": "memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);"
    },
    {
        "line": 120,
        "fullcodeline": "op += padding[1];"
    },
    {
        "line": 123,
        "fullcodeline": "for (uint64_t i = 0; i < 4; i++) {           // fill cell buffer"
    },
    {
        "line": 136,
        "fullcodeline": "hash_cell >>= 32U - 12U;"
    },
    {
        "line": 140,
        "fullcodeline": "if (tab_cell[hash_cell] == 0) {"
    },
    {
        "line": 159,
        "fullcodeline": "for (int i = 1; i < 16; i++) {"
    },
    {
        "line": 111,
        "fullcodeline": "padding[0] = 4;"
    },
    {
        "line": 116,
        "fullcodeline": "padding[1] = 4;"
    },
    {
        "line": 125,
        "fullcodeline": "memcpy(buf_cell, &ip[ind], 4);"
    },
    {
        "line": 126,
        "fullcodeline": "buf_cell += 4;"
    },
    {
        "line": 141,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 166,
        "fullcodeline": "token = (uint8_t) (1U << 6U);"
    },
    {
        "line": 144,
        "fullcodeline": "buf_aux = obase + tab_cell[hash_cell];"
    },
    {
        "line": 160,
        "fullcodeline": "if (buf_cell[i] != buf_cell[0]) {"
    },
    {
        "line": 124,
        "fullcodeline": "uint64_t ind = orig + i * blockshape[1];"
    },
    {
        "line": 145,
        "fullcodeline": "for (int i = 0; i < 16; i++) {"
    },
    {
        "line": 167,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 168,
        "fullcodeline": "*op++ = buf_cell[0];"
    },
    {
        "line": 152,
        "fullcodeline": "distance = (int32_t) (anchor - ref);"
    },
    {
        "line": 170,
        "fullcodeline": "} else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match"
    },
    {
        "line": 146,
        "fullcodeline": "if (buf_cell[i] != buf_aux[i]) {"
    },
    {
        "line": 154,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "for (int j = 1; j < 4; j++) {"
    },
    {
        "line": 248,
        "fullcodeline": "for (int i = 0; i < 2; i++) {"
    },
    {
        "line": 305,
        "fullcodeline": "for (int i = 0; i < 3; i++) {"
    },
    {
        "line": 377,
        "fullcodeline": "token = (uint8_t) ((1U << 7U) | (1U << 6U));"
    },
    {
        "line": 379,
        "fullcodeline": "uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);"
    },
    {
        "line": 380,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 381,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 175,
        "fullcodeline": "memcpy(buf_pair, buf_cell, 4);"
    },
    {
        "line": 176,
        "fullcodeline": "memcpy(&buf_pair[4], &buf_cell[j * 4], 4);"
    },
    {
        "line": 177,
        "fullcodeline": "hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash"
    },
    {
        "line": 179,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 249,
        "fullcodeline": "memcpy(buf_triple, &buf_cell[i * 4], 4);"
    },
    {
        "line": 306,
        "fullcodeline": "memcpy(buf_pair, &buf_cell[i * 4], 4);"
    },
    {
        "line": 359,
        "fullcodeline": "tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */"
    },
    {
        "line": 370,
        "fullcodeline": "token = 0;"
    },
    {
        "line": 372,
        "fullcodeline": "memcpy(op, buf_cell, 16);"
    },
    {
        "line": 373,
        "fullcodeline": "op += 16;"
    },
    {
        "line": 178,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 183,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 200,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */"
    },
    {
        "line": 250,
        "fullcodeline": "for (int j = i + 1; j < 3; j++) {"
    },
    {
        "line": 307,
        "fullcodeline": "for (int j = i + 1; j < 4; j++) {"
    },
    {
        "line": 378,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 184,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 191,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 196,
        "fullcodeline": "distance = (int32_t) (anchor - ref);"
    },
    {
        "line": 201,
        "fullcodeline": "int k, m, l = -1;"
    },
    {
        "line": 211,
        "fullcodeline": "memcpy(buf_pair, &buf_cell[l * 4], 4);"
    },
    {
        "line": 212,
        "fullcodeline": "memcpy(&buf_pair[4], &buf_cell[m * 4], 4);"
    },
    {
        "line": 213,
        "fullcodeline": "hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash"
    },
    {
        "line": 215,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 251,
        "fullcodeline": "memcpy(&buf_triple[4], &buf_cell[j * 4], 4);"
    },
    {
        "line": 308,
        "fullcodeline": "memcpy(&buf_pair[4], &buf_cell[j * 4], 4);"
    },
    {
        "line": 309,
        "fullcodeline": "hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash"
    },
    {
        "line": 310,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 311,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 371,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 185,
        "fullcodeline": "for (int k = 0; k < 8; k++) {"
    },
    {
        "line": 198,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 202,
        "fullcodeline": "for (k = 1; k < 4; k++) {"
    },
    {
        "line": 214,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 217,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 233,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {   /* 2 pair matches */"
    },
    {
        "line": 252,
        "fullcodeline": "for (int k = j + 1; k < 4; k++) {"
    },
    {
        "line": 315,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 336,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */"
    },
    {
        "line": 361,
        "fullcodeline": "for (int h = 0; h < 2; h++) {"
    },
    {
        "line": 366,
        "fullcodeline": "for (int h = 0; h < 3; h++) {"
    },
    {
        "line": 218,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 229,
        "fullcodeline": "distance = (int32_t) (anchor + l * 4 - ref);"
    },
    {
        "line": 235,
        "fullcodeline": "token = (uint8_t) ((1U << 5U) | (j << 3U));"
    },
    {
        "line": 237,
        "fullcodeline": "uint16_t offset_2 = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 239,
        "fullcodeline": "op += sizeof(offset);"
    },
    {
        "line": 241,
        "fullcodeline": "op += sizeof(offset_2);"
    },
    {
        "line": 253,
        "fullcodeline": "memcpy(&buf_triple[8], &buf_cell[k * 4], 4);"
    },
    {
        "line": 254,
        "fullcodeline": "hval = XXH32(buf_triple, 12, 1);        // calculate triple hash"
    },
    {
        "line": 255,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 275,
        "fullcodeline": "ref = obase + tab_triple[hval];"
    },
    {
        "line": 316,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 323,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 332,
        "fullcodeline": "distance = (int32_t) (anchor + i * 4 - ref);"
    },
    {
        "line": 344,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 345,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 186,
        "fullcodeline": "if (buf_pair[k] != buf_aux[k]) {"
    },
    {
        "line": 203,
        "fullcodeline": "if (k != j) {"
    },
    {
        "line": 219,
        "fullcodeline": "for (k = 0; k < 8; k++) {"
    },
    {
        "line": 231,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 259,
        "fullcodeline": "if (tab_triple[hval] != 0) {"
    },
    {
        "line": 282,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {"
    },
    {
        "line": 317,
        "fullcodeline": "for (int k = 0; k < 8; k++) {"
    },
    {
        "line": 334,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 338,
        "fullcodeline": "if (i == 2) {"
    },
    {
        "line": 346,
        "fullcodeline": "for (int k = 0; k < 4; k++) {"
    },
    {
        "line": 236,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 260,
        "fullcodeline": "buf_aux = obase + tab_triple[hval];"
    },
    {
        "line": 267,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_triple[hval]);"
    },
    {
        "line": 278,
        "fullcodeline": "distance = (int32_t) (anchor + i * 4 - ref);"
    },
    {
        "line": 290,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 291,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 339,
        "fullcodeline": "token = (uint8_t) (1U << 7U);"
    },
    {
        "line": 343,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 204,
        "fullcodeline": "if (l == -1) {"
    },
    {
        "line": 220,
        "fullcodeline": "if (buf_pair[k] != buf_aux[k]) {"
    },
    {
        "line": 261,
        "fullcodeline": "for (int l = 0; l < 12; l++) {"
    },
    {
        "line": 280,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 284,
        "fullcodeline": "if (i == 1) {"
    },
    {
        "line": 292,
        "fullcodeline": "for (int l = 0; l < 4; l++) {"
    },
    {
        "line": 318,
        "fullcodeline": "if (buf_pair[k] != buf_aux[k]) {"
    },
    {
        "line": 326,
        "fullcodeline": "if (j - i == 1) {"
    },
    {
        "line": 341,
        "fullcodeline": "token = (uint8_t) ((1U << 7U) | (i << 5U) | (j << 3U));"
    },
    {
        "line": 205,
        "fullcodeline": "l = k;"
    },
    {
        "line": 285,
        "fullcodeline": "token = (uint8_t) (7U << 5U);"
    },
    {
        "line": 289,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 327,
        "fullcodeline": "update_pair[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */"
    },
    {
        "line": 347,
        "fullcodeline": "if ((k != i) && (k != j)) {"
    },
    {
        "line": 348,
        "fullcodeline": "memcpy(op, &buf_cell[4 * k], 4);"
    },
    {
        "line": 349,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 207,
        "fullcodeline": "m = k;"
    },
    {
        "line": 262,
        "fullcodeline": "if (buf_triple[l] != buf_aux[l]) {"
    },
    {
        "line": 270,
        "fullcodeline": "if ((j - i == 1) && (k - j == 1)) {"
    },
    {
        "line": 287,
        "fullcodeline": "token = (uint8_t) ((7U << 5U) | ((j + k - 2) << 3U));"
    },
    {
        "line": 271,
        "fullcodeline": "update_triple[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */"
    },
    {
        "line": 293,
        "fullcodeline": "if ((l != i) && (l != j) && (l != k)) {"
    },
    {
        "line": 294,
        "fullcodeline": "memcpy(op, &buf_cell[4 * l], 4);"
    },
    {
        "line": 295,
        "fullcodeline": "op += 4;"
    }
]