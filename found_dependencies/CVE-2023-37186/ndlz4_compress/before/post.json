[
    {
        "line": 3,
        "fullcodeline": "BLOSC_UNUSED_PARAM(meta);"
    },
    {
        "line": 13,
        "fullcodeline": "int64_t *shape = malloc(8 * sizeof(int64_t));"
    },
    {
        "line": 14,
        "fullcodeline": "int32_t *chunkshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 15,
        "fullcodeline": "int32_t *blockshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 16,
        "fullcodeline": "deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);"
    },
    {
        "line": 17,
        "fullcodeline": "free(smeta);"
    },
    {
        "line": 34,
        "fullcodeline": "uint8_t *ip = (uint8_t *) input;"
    },
    {
        "line": 35,
        "fullcodeline": "uint8_t *op = (uint8_t *) output;"
    },
    {
        "line": 38,
        "fullcodeline": "uint32_t hash_triple[2] = {0};"
    },
    {
        "line": 39,
        "fullcodeline": "uint32_t hash_pair[3] = {0};"
    },
    {
        "line": 40,
        "fullcodeline": "uint8_t bufarea[16];"
    },
    {
        "line": 41,
        "fullcodeline": "uint8_t *buf_cell = bufarea;"
    },
    {
        "line": 42,
        "fullcodeline": "uint8_t buf_triple[12];"
    },
    {
        "line": 43,
        "fullcodeline": "uint8_t buf_pair[8];"
    },
    {
        "line": 45,
        "fullcodeline": "uint32_t tab_cell[1U << 12U] = {0};"
    },
    {
        "line": 46,
        "fullcodeline": "uint32_t tab_triple[1U << 12U] = {0};"
    },
    {
        "line": 47,
        "fullcodeline": "uint32_t tab_pair[1U << 12U] = {0};"
    },
    {
        "line": 48,
        "fullcodeline": "uint32_t update_triple[2] = {0};"
    },
    {
        "line": 49,
        "fullcodeline": "uint32_t update_pair[3] = {0};"
    },
    {
        "line": 54,
        "fullcodeline": "op_limit = op + output_len;"
    },
    {
        "line": 62,
        "fullcodeline": "int overhead = 17 + (blockshape[0] * blockshape[1] / 16 - 1) * 2;"
    },
    {
        "line": 68,
        "fullcodeline": "uint8_t *obase = op;"
    },
    {
        "line": 71,
        "fullcodeline": "*op++ = ndim;"
    },
    {
        "line": 72,
        "fullcodeline": "memcpy(op, &blockshape[0], 4);"
    },
    {
        "line": 73,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 74,
        "fullcodeline": "memcpy(op, &blockshape[1], 4);"
    },
    {
        "line": 75,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 77,
        "fullcodeline": "uint32_t i_stop[2];"
    },
    {
        "line": 83,
        "fullcodeline": "uint32_t padding[2];"
    },
    {
        "line": 84,
        "fullcodeline": "uint32_t ii[2];"
    },
    {
        "line": 390,
        "fullcodeline": "free(shape);"
    },
    {
        "line": 391,
        "fullcodeline": "free(chunkshape);"
    },
    {
        "line": 392,
        "fullcodeline": "free(blockshape);"
    },
    {
        "line": 7,
        "fullcodeline": "if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (ndim != 2) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (input_len != (blockshape[0] * blockshape[1])) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (unsigned i = 0; i < (1U << 12U); i++) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (input_len < 16 || output_len < overhead) {"
    },
    {
        "line": 78,
        "fullcodeline": "for (int i = 0; i < 2; ++i) {"
    },
    {
        "line": 85,
        "fullcodeline": "for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {"
    },
    {
        "line": 394,
        "fullcodeline": "return (int) (op - obase);"
    },
    {
        "line": 8,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"b2nd layer not found!\");"
    },
    {
        "line": 20,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");"
    },
    {
        "line": 25,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Length not equal to blocksize\");"
    },
    {
        "line": 30,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Output too small\");"
    },
    {
        "line": 58,
        "fullcodeline": "tab_cell[i] = 0;"
    },
    {
        "line": 64,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Incorrect length or maxout\");"
    },
    {
        "line": 79,
        "fullcodeline": "i_stop[i] = (blockshape[i] + 3) / 4;"
    },
    {
        "line": 86,
        "fullcodeline": "for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell"
    },
    {
        "line": 92,
        "fullcodeline": "update_pair[2] = 0;"
    },
    {
        "line": 101,
        "fullcodeline": "uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;"
    },
    {
        "line": 88,
        "fullcodeline": "for (int h = 0; h < 2; h++) {         // new cell -> new possible references"
    },
    {
        "line": 94,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(op + 16 + 1 > op_limit)) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (((blockshape[0] % 4 != 0) && (ii[0] == i_stop[0] - 1)) ||"
    },
    {
        "line": 383,
        "fullcodeline": "if ((op - obase) > input_len) {"
    },
    {
        "line": 89,
        "fullcodeline": "update_triple[h] = 0;"
    },
    {
        "line": 90,
        "fullcodeline": "update_pair[h] = 0;"
    },
    {
        "line": 95,
        "fullcodeline": "free(shape);"
    },
    {
        "line": 96,
        "fullcodeline": "free(chunkshape);"
    },
    {
        "line": 97,
        "fullcodeline": "free(blockshape);"
    },
    {
        "line": 103,
        "fullcodeline": "((blockshape[1] % 4 != 0) && (ii[1] == i_stop[1] - 1))) {"
    },
    {
        "line": 104,
        "fullcodeline": "token = 0;                                   // padding -> literal copy"
    },
    {
        "line": 105,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 384,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Compressed data is bigger than input!\");"
    },
    {
        "line": 106,
        "fullcodeline": "if (ii[0] == i_stop[0] - 1) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (ii[1] == i_stop[1] - 1) {"
    },
    {
        "line": 116,
        "fullcodeline": "for (uint32_t i = 0; i < padding[0]; i++) {"
    },
    {
        "line": 126,
        "fullcodeline": "buf_cell -= 16;"
    },
    {
        "line": 130,
        "fullcodeline": "uint8_t *anchor = op;    /* comparison starting-point */"
    },
    {
        "line": 133,
        "fullcodeline": "hash_cell = XXH32(buf_cell, 16, 1);        // calculate cell hash"
    },
    {
        "line": 134,
        "fullcodeline": "hash_cell >>= 32U - 12U;"
    },
    {
        "line": 135,
        "fullcodeline": "ref = obase + tab_cell[hash_cell];"
    },
    {
        "line": 156,
        "fullcodeline": "bool alleq = true;"
    },
    {
        "line": 107,
        "fullcodeline": "padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;"
    },
    {
        "line": 112,
        "fullcodeline": "padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;"
    },
    {
        "line": 117,
        "fullcodeline": "memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);"
    },
    {
        "line": 118,
        "fullcodeline": "op += padding[1];"
    },
    {
        "line": 121,
        "fullcodeline": "for (uint64_t i = 0; i < 4; i++) {           // fill cell buffer"
    },
    {
        "line": 138,
        "fullcodeline": "if (tab_cell[hash_cell] == 0) {"
    },
    {
        "line": 157,
        "fullcodeline": "for (int i = 1; i < 16; i++) {"
    },
    {
        "line": 109,
        "fullcodeline": "padding[0] = 4;"
    },
    {
        "line": 114,
        "fullcodeline": "padding[1] = 4;"
    },
    {
        "line": 122,
        "fullcodeline": "uint64_t ind = orig + i * blockshape[1];"
    },
    {
        "line": 123,
        "fullcodeline": "memcpy(buf_cell, &ip[ind], 4);"
    },
    {
        "line": 124,
        "fullcodeline": "buf_cell += 4;"
    },
    {
        "line": 139,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 164,
        "fullcodeline": "token = (uint8_t) (1U << 6U);"
    },
    {
        "line": 165,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 166,
        "fullcodeline": "*op++ = buf_cell[0];"
    },
    {
        "line": 141,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 142,
        "fullcodeline": "buf_aux = obase + tab_cell[hash_cell];"
    },
    {
        "line": 158,
        "fullcodeline": "if (buf_cell[i] != buf_cell[0]) {"
    },
    {
        "line": 143,
        "fullcodeline": "for (int i = 0; i < 16; i++) {"
    },
    {
        "line": 159,
        "fullcodeline": "alleq = false;"
    },
    {
        "line": 168,
        "fullcodeline": "} else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match"
    },
    {
        "line": 150,
        "fullcodeline": "distance = (int32_t) (anchor - ref);"
    },
    {
        "line": 169,
        "fullcodeline": "bool literal = true;"
    },
    {
        "line": 144,
        "fullcodeline": "if (buf_cell[i] != buf_aux[i]) {"
    },
    {
        "line": 152,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 172,
        "fullcodeline": "for (int j = 1; j < 4; j++) {"
    },
    {
        "line": 246,
        "fullcodeline": "for (int i = 0; i < 2; i++) {"
    },
    {
        "line": 303,
        "fullcodeline": "for (int i = 0; i < 3; i++) {"
    },
    {
        "line": 375,
        "fullcodeline": "token = (uint8_t) ((1U << 7U) | (1U << 6U));"
    },
    {
        "line": 376,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 377,
        "fullcodeline": "uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);"
    },
    {
        "line": 378,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 379,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 145,
        "fullcodeline": "same = false;"
    },
    {
        "line": 173,
        "fullcodeline": "memcpy(buf_pair, buf_cell, 4);"
    },
    {
        "line": 174,
        "fullcodeline": "memcpy(&buf_pair[4], &buf_cell[j * 4], 4);"
    },
    {
        "line": 175,
        "fullcodeline": "hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash"
    },
    {
        "line": 176,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 177,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 179,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 247,
        "fullcodeline": "memcpy(buf_triple, &buf_cell[i * 4], 4);"
    },
    {
        "line": 304,
        "fullcodeline": "memcpy(buf_pair, &buf_cell[i * 4], 4);"
    },
    {
        "line": 357,
        "fullcodeline": "tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */"
    },
    {
        "line": 368,
        "fullcodeline": "token = 0;"
    },
    {
        "line": 369,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 370,
        "fullcodeline": "memcpy(op, buf_cell, 16);"
    },
    {
        "line": 371,
        "fullcodeline": "op += 16;"
    },
    {
        "line": 181,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 198,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */"
    },
    {
        "line": 248,
        "fullcodeline": "for (int j = i + 1; j < 3; j++) {"
    },
    {
        "line": 305,
        "fullcodeline": "for (int j = i + 1; j < 4; j++) {"
    },
    {
        "line": 358,
        "fullcodeline": "if (update_triple[0] != 0) {"
    },
    {
        "line": 363,
        "fullcodeline": "if (update_pair[0] != 0) {"
    },
    {
        "line": 182,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 189,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 194,
        "fullcodeline": "distance = (int32_t) (anchor - ref);"
    },
    {
        "line": 199,
        "fullcodeline": "int k, m, l = -1;"
    },
    {
        "line": 209,
        "fullcodeline": "memcpy(buf_pair, &buf_cell[l * 4], 4);"
    },
    {
        "line": 210,
        "fullcodeline": "memcpy(&buf_pair[4], &buf_cell[m * 4], 4);"
    },
    {
        "line": 211,
        "fullcodeline": "hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash"
    },
    {
        "line": 212,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 213,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 214,
        "fullcodeline": "same = true;"
    },
    {
        "line": 249,
        "fullcodeline": "memcpy(&buf_triple[4], &buf_cell[j * 4], 4);"
    },
    {
        "line": 306,
        "fullcodeline": "memcpy(&buf_pair[4], &buf_cell[j * 4], 4);"
    },
    {
        "line": 307,
        "fullcodeline": "hval = XXH32(buf_pair, 8, 1);        // calculate rows pair hash"
    },
    {
        "line": 308,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 309,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 311,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 183,
        "fullcodeline": "for (int k = 0; k < 8; k++) {"
    },
    {
        "line": 191,
        "fullcodeline": "same = false;"
    },
    {
        "line": 196,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 200,
        "fullcodeline": "for (k = 1; k < 4; k++) {"
    },
    {
        "line": 215,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 231,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {   /* 2 pair matches */"
    },
    {
        "line": 250,
        "fullcodeline": "for (int k = j + 1; k < 4; k++) {"
    },
    {
        "line": 313,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 334,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* rows pair match */"
    },
    {
        "line": 359,
        "fullcodeline": "for (int h = 0; h < 2; h++) {"
    },
    {
        "line": 364,
        "fullcodeline": "for (int h = 0; h < 3; h++) {"
    },
    {
        "line": 216,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 227,
        "fullcodeline": "distance = (int32_t) (anchor + l * 4 - ref);"
    },
    {
        "line": 232,
        "fullcodeline": "literal = false;"
    },
    {
        "line": 233,
        "fullcodeline": "token = (uint8_t) ((1U << 5U) | (j << 3U));"
    },
    {
        "line": 234,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 235,
        "fullcodeline": "uint16_t offset_2 = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 236,
        "fullcodeline": "*(uint16_t *) op = offset;"
    },
    {
        "line": 237,
        "fullcodeline": "op += sizeof(offset);"
    },
    {
        "line": 238,
        "fullcodeline": "*(uint16_t *) op = offset_2;"
    },
    {
        "line": 239,
        "fullcodeline": "op += sizeof(offset_2);"
    },
    {
        "line": 251,
        "fullcodeline": "memcpy(&buf_triple[8], &buf_cell[k * 4], 4);"
    },
    {
        "line": 252,
        "fullcodeline": "hval = XXH32(buf_triple, 12, 1);        // calculate triple hash"
    },
    {
        "line": 253,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 255,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 273,
        "fullcodeline": "ref = obase + tab_triple[hval];"
    },
    {
        "line": 314,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 321,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 330,
        "fullcodeline": "distance = (int32_t) (anchor + i * 4 - ref);"
    },
    {
        "line": 335,
        "fullcodeline": "literal = false;"
    },
    {
        "line": 341,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 342,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 343,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 360,
        "fullcodeline": "tab_triple[hash_triple[h]] = update_triple[h];"
    },
    {
        "line": 365,
        "fullcodeline": "tab_pair[hash_pair[h]] = update_pair[h];"
    },
    {
        "line": 184,
        "fullcodeline": "if (buf_pair[k] != buf_aux[k]) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (k != j) {"
    },
    {
        "line": 217,
        "fullcodeline": "for (k = 0; k < 8; k++) {"
    },
    {
        "line": 224,
        "fullcodeline": "same = false;"
    },
    {
        "line": 229,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 257,
        "fullcodeline": "if (tab_triple[hval] != 0) {"
    },
    {
        "line": 280,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {"
    },
    {
        "line": 315,
        "fullcodeline": "for (int k = 0; k < 8; k++) {"
    },
    {
        "line": 323,
        "fullcodeline": "same = false;"
    },
    {
        "line": 332,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 336,
        "fullcodeline": "if (i == 2) {"
    },
    {
        "line": 344,
        "fullcodeline": "for (int k = 0; k < 4; k++) {"
    },
    {
        "line": 185,
        "fullcodeline": "same = false;"
    },
    {
        "line": 258,
        "fullcodeline": "buf_aux = obase + tab_triple[hval];"
    },
    {
        "line": 265,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_triple[hval]);"
    },
    {
        "line": 276,
        "fullcodeline": "distance = (int32_t) (anchor + i * 4 - ref);"
    },
    {
        "line": 281,
        "fullcodeline": "literal = false;"
    },
    {
        "line": 287,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 288,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 289,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 324,
        "fullcodeline": "if (j - i == 1) {"
    },
    {
        "line": 337,
        "fullcodeline": "token = (uint8_t) (1U << 7U);"
    },
    {
        "line": 202,
        "fullcodeline": "if (l == -1) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (buf_pair[k] != buf_aux[k]) {"
    },
    {
        "line": 259,
        "fullcodeline": "for (int l = 0; l < 12; l++) {"
    },
    {
        "line": 267,
        "fullcodeline": "same = false;"
    },
    {
        "line": 278,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 282,
        "fullcodeline": "if (i == 1) {"
    },
    {
        "line": 290,
        "fullcodeline": "for (int l = 0; l < 4; l++) {"
    },
    {
        "line": 316,
        "fullcodeline": "if (buf_pair[k] != buf_aux[k]) {"
    },
    {
        "line": 325,
        "fullcodeline": "update_pair[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */"
    },
    {
        "line": 326,
        "fullcodeline": "hash_pair[i] = hval;"
    },
    {
        "line": 339,
        "fullcodeline": "token = (uint8_t) ((1U << 7U) | (i << 5U) | (j << 3U));"
    },
    {
        "line": 345,
        "fullcodeline": "if ((k != i) && (k != j)) {"
    },
    {
        "line": 203,
        "fullcodeline": "l = k;"
    },
    {
        "line": 219,
        "fullcodeline": "same = false;"
    },
    {
        "line": 268,
        "fullcodeline": "if ((j - i == 1) && (k - j == 1)) {"
    },
    {
        "line": 283,
        "fullcodeline": "token = (uint8_t) (7U << 5U);"
    },
    {
        "line": 317,
        "fullcodeline": "same = false;"
    },
    {
        "line": 346,
        "fullcodeline": "memcpy(op, &buf_cell[4 * k], 4);"
    },
    {
        "line": 347,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 205,
        "fullcodeline": "m = k;"
    },
    {
        "line": 260,
        "fullcodeline": "if (buf_triple[l] != buf_aux[l]) {"
    },
    {
        "line": 269,
        "fullcodeline": "update_triple[i] = (uint32_t) (anchor + 1 + i * 4 - obase);     /* update hash table */"
    },
    {
        "line": 270,
        "fullcodeline": "hash_triple[i] = hval;"
    },
    {
        "line": 285,
        "fullcodeline": "token = (uint8_t) ((7U << 5U) | ((j + k - 2) << 3U));"
    },
    {
        "line": 291,
        "fullcodeline": "if ((l != i) && (l != j) && (l != k)) {"
    },
    {
        "line": 261,
        "fullcodeline": "same = false;"
    },
    {
        "line": 292,
        "fullcodeline": "memcpy(op, &buf_cell[4 * l], 4);"
    },
    {
        "line": 293,
        "fullcodeline": "op += 4;"
    }
]