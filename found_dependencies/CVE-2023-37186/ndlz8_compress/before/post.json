[
    {
        "line": 3,
        "fullcodeline": "BLOSC_UNUSED_PARAM(meta);"
    },
    {
        "line": 12,
        "fullcodeline": "const int cell_shape = 8;"
    },
    {
        "line": 13,
        "fullcodeline": "const int cell_size = 64;"
    },
    {
        "line": 15,
        "fullcodeline": "int64_t *shape = malloc(8 * sizeof(int64_t));"
    },
    {
        "line": 16,
        "fullcodeline": "int32_t *chunkshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 17,
        "fullcodeline": "int32_t *blockshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 18,
        "fullcodeline": "deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);"
    },
    {
        "line": 19,
        "fullcodeline": "free(smeta);"
    },
    {
        "line": 36,
        "fullcodeline": "uint8_t *ip = (uint8_t *) input;"
    },
    {
        "line": 37,
        "fullcodeline": "uint8_t *op = (uint8_t *) output;"
    },
    {
        "line": 40,
        "fullcodeline": "uint32_t hash_triple[6] = {0};"
    },
    {
        "line": 41,
        "fullcodeline": "uint32_t hash_pair[7] = {0};"
    },
    {
        "line": 42,
        "fullcodeline": "uint8_t *bufarea = malloc(cell_size);"
    },
    {
        "line": 43,
        "fullcodeline": "uint8_t *buf_cell = bufarea;"
    },
    {
        "line": 45,
        "fullcodeline": "uint32_t tab_cell[1U << 12U] = {0};"
    },
    {
        "line": 46,
        "fullcodeline": "uint32_t tab_triple[1U << 12U] = {0};"
    },
    {
        "line": 47,
        "fullcodeline": "uint32_t tab_pair[1U << 12U] = {0};"
    },
    {
        "line": 48,
        "fullcodeline": "uint32_t update_triple[6] = {0};"
    },
    {
        "line": 49,
        "fullcodeline": "uint32_t update_pair[7] = {0};"
    },
    {
        "line": 54,
        "fullcodeline": "op_limit = op + output_len;"
    },
    {
        "line": 64,
        "fullcodeline": "int overhead = 17 + (blockshape[0] * blockshape[1] / cell_size - 1) * 2;"
    },
    {
        "line": 70,
        "fullcodeline": "uint8_t *obase = op;"
    },
    {
        "line": 73,
        "fullcodeline": "*op++ = ndim;"
    },
    {
        "line": 74,
        "fullcodeline": "memcpy(op, &blockshape[0], 4);"
    },
    {
        "line": 75,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 76,
        "fullcodeline": "memcpy(op, &blockshape[1], 4);"
    },
    {
        "line": 77,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 79,
        "fullcodeline": "uint32_t i_stop[2];"
    },
    {
        "line": 86,
        "fullcodeline": "uint32_t padding[2];"
    },
    {
        "line": 87,
        "fullcodeline": "uint32_t ii[2];"
    },
    {
        "line": 306,
        "fullcodeline": "free(shape);"
    },
    {
        "line": 307,
        "fullcodeline": "free(chunkshape);"
    },
    {
        "line": 308,
        "fullcodeline": "free(blockshape);"
    },
    {
        "line": 309,
        "fullcodeline": "free(bufarea);"
    },
    {
        "line": 7,
        "fullcodeline": "if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (ndim != 2) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (input_len != (blockshape[0] * blockshape[1])) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (unsigned i = 0; i < (1U << 12U); i++) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (input_len < cell_size || output_len < overhead) {"
    },
    {
        "line": 80,
        "fullcodeline": "for (int i = 0; i < 2; ++i) {"
    },
    {
        "line": 88,
        "fullcodeline": "for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {"
    },
    {
        "line": 311,
        "fullcodeline": "return (int) (op - obase);"
    },
    {
        "line": 8,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"b2nd layer not found!\");"
    },
    {
        "line": 22,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");"
    },
    {
        "line": 27,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Length not equal to blocksize\");"
    },
    {
        "line": 32,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Output too small\");"
    },
    {
        "line": 58,
        "fullcodeline": "tab_cell[i] = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "tab_triple[i] = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "tab_pair[i] = 0;"
    },
    {
        "line": 66,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Incorrect length or maxout\");"
    },
    {
        "line": 81,
        "fullcodeline": "i_stop[i] = (blockshape[i] + cell_shape - 1) / cell_shape;"
    },
    {
        "line": 89,
        "fullcodeline": "for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell"
    },
    {
        "line": 105,
        "fullcodeline": "uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;"
    },
    {
        "line": 90,
        "fullcodeline": "for (int h = 0; h < 7; h++) {         // new cell -> new possible references"
    },
    {
        "line": 97,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(op + cell_size + 1 > op_limit)) {"
    },
    {
        "line": 106,
        "fullcodeline": "if (((blockshape[0] % cell_shape != 0) && (ii[0] == i_stop[0] - 1)) ||"
    },
    {
        "line": 295,
        "fullcodeline": "if ((op - obase) > input_len) {"
    },
    {
        "line": 91,
        "fullcodeline": "update_pair[h] = 0;"
    },
    {
        "line": 98,
        "fullcodeline": "free(shape);"
    },
    {
        "line": 99,
        "fullcodeline": "free(chunkshape);"
    },
    {
        "line": 100,
        "fullcodeline": "free(blockshape);"
    },
    {
        "line": 101,
        "fullcodeline": "free(bufarea);"
    },
    {
        "line": 107,
        "fullcodeline": "((blockshape[1] % cell_shape != 0) && (ii[1] == i_stop[1] - 1))) {"
    },
    {
        "line": 108,
        "fullcodeline": "uint8_t token = 0;                                   // padding -> literal copy"
    },
    {
        "line": 109,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 296,
        "fullcodeline": "free(shape);"
    },
    {
        "line": 297,
        "fullcodeline": "free(chunkshape);"
    },
    {
        "line": 298,
        "fullcodeline": "free(blockshape);"
    },
    {
        "line": 299,
        "fullcodeline": "free(bufarea);"
    },
    {
        "line": 300,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"Compressed data is bigger than input!\");"
    },
    {
        "line": 92,
        "fullcodeline": "if (h != 6) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (ii[0] == i_stop[0] - 1) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (ii[1] == i_stop[1] - 1) {"
    },
    {
        "line": 120,
        "fullcodeline": "for (uint32_t i = 0; i < padding[0]; i++) {"
    },
    {
        "line": 130,
        "fullcodeline": "buf_cell -= cell_size;"
    },
    {
        "line": 134,
        "fullcodeline": "uint8_t *anchor = op;    /* comparison starting-point */"
    },
    {
        "line": 137,
        "fullcodeline": "hash_cell = XXH32(buf_cell, cell_size, 1);        // calculate cell hash"
    },
    {
        "line": 138,
        "fullcodeline": "hash_cell >>= 32U - 12U;"
    },
    {
        "line": 139,
        "fullcodeline": "ref = obase + tab_cell[hash_cell];"
    },
    {
        "line": 160,
        "fullcodeline": "bool alleq = true;"
    },
    {
        "line": 93,
        "fullcodeline": "update_triple[h] = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;"
    },
    {
        "line": 116,
        "fullcodeline": "padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;"
    },
    {
        "line": 121,
        "fullcodeline": "memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);"
    },
    {
        "line": 122,
        "fullcodeline": "op += padding[1];"
    },
    {
        "line": 125,
        "fullcodeline": "for (uint64_t i = 0; i < (uint64_t) cell_shape; i++) {           // fill cell buffer"
    },
    {
        "line": 142,
        "fullcodeline": "if (tab_cell[hash_cell] == 0) {"
    },
    {
        "line": 161,
        "fullcodeline": "for (int i = 1; i < cell_size; i++) {"
    },
    {
        "line": 113,
        "fullcodeline": "padding[0] = cell_shape;"
    },
    {
        "line": 118,
        "fullcodeline": "padding[1] = cell_shape;"
    },
    {
        "line": 126,
        "fullcodeline": "uint64_t ind = orig + i * blockshape[1];"
    },
    {
        "line": 127,
        "fullcodeline": "memcpy(buf_cell, &ip[ind], cell_shape);"
    },
    {
        "line": 128,
        "fullcodeline": "buf_cell += cell_shape;"
    },
    {
        "line": 143,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 168,
        "fullcodeline": "uint8_t token = (uint8_t) (1U << 6U);"
    },
    {
        "line": 169,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 170,
        "fullcodeline": "*op++ = buf_cell[0];"
    },
    {
        "line": 145,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 146,
        "fullcodeline": "buf_aux = obase + tab_cell[hash_cell];"
    },
    {
        "line": 162,
        "fullcodeline": "if (buf_cell[i] != buf_cell[0]) {"
    },
    {
        "line": 147,
        "fullcodeline": "for (int i = 0; i < cell_size; i++) {"
    },
    {
        "line": 163,
        "fullcodeline": "alleq = false;"
    },
    {
        "line": 172,
        "fullcodeline": "} else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match"
    },
    {
        "line": 154,
        "fullcodeline": "distance = (int32_t) (anchor - ref);"
    },
    {
        "line": 173,
        "fullcodeline": "bool literal = true;"
    },
    {
        "line": 148,
        "fullcodeline": "if (buf_cell[i] != buf_aux[i]) {"
    },
    {
        "line": 156,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 176,
        "fullcodeline": "for (int i = 0; i < 6; i++) {"
    },
    {
        "line": 220,
        "fullcodeline": "for (int i = 0; i < 7; i++) {"
    },
    {
        "line": 286,
        "fullcodeline": "uint8_t token = (uint8_t) ((1U << 7U) | (1U << 6U));"
    },
    {
        "line": 287,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 288,
        "fullcodeline": "uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);"
    },
    {
        "line": 289,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 290,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 149,
        "fullcodeline": "same = false;"
    },
    {
        "line": 177,
        "fullcodeline": "int triple_start = i * cell_shape;"
    },
    {
        "line": 178,
        "fullcodeline": "hval = XXH32(&buf_cell[triple_start], 24, 1);        // calculate triple hash"
    },
    {
        "line": 179,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 181,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 197,
        "fullcodeline": "ref = obase + tab_triple[hval];"
    },
    {
        "line": 221,
        "fullcodeline": "int pair_start = i * cell_shape;"
    },
    {
        "line": 222,
        "fullcodeline": "hval = XXH32(&buf_cell[pair_start], 16, 1);        // calculate rows pair hash"
    },
    {
        "line": 223,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 224,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 226,
        "fullcodeline": "bool same = true;"
    },
    {
        "line": 266,
        "fullcodeline": "tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */"
    },
    {
        "line": 278,
        "fullcodeline": "uint8_t token = 0;"
    },
    {
        "line": 279,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 280,
        "fullcodeline": "memcpy(op, buf_cell, cell_size);"
    },
    {
        "line": 281,
        "fullcodeline": "op += cell_size;"
    },
    {
        "line": 183,
        "fullcodeline": "if (tab_triple[hval] != 0) {"
    },
    {
        "line": 203,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     // 3 rows match"
    },
    {
        "line": 228,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 247,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* 1 rows pair match */"
    },
    {
        "line": 268,
        "fullcodeline": "if (update_triple[0] != 0) {"
    },
    {
        "line": 273,
        "fullcodeline": "if (update_pair[0] != 0) {"
    },
    {
        "line": 184,
        "fullcodeline": "buf_aux = obase + tab_triple[hval];"
    },
    {
        "line": 191,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_triple[hval]);"
    },
    {
        "line": 199,
        "fullcodeline": "distance = (int32_t) (anchor + triple_start - ref);"
    },
    {
        "line": 204,
        "fullcodeline": "literal = false;"
    },
    {
        "line": 205,
        "fullcodeline": "uint8_t token = (uint8_t) ((21 << 3U) | i);"
    },
    {
        "line": 206,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 207,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 208,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 229,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 236,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 243,
        "fullcodeline": "distance = (int32_t) (anchor + pair_start - ref);"
    },
    {
        "line": 248,
        "fullcodeline": "literal = false;"
    },
    {
        "line": 249,
        "fullcodeline": "uint8_t token = (uint8_t) ((17 << 3U) | i);"
    },
    {
        "line": 250,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 251,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 252,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 253,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 185,
        "fullcodeline": "for (int l = 0; l < 24; l++) {"
    },
    {
        "line": 193,
        "fullcodeline": "same = false;"
    },
    {
        "line": 194,
        "fullcodeline": "update_triple[i] = (uint32_t) (anchor + 1 + triple_start - obase);     /* update hash table */"
    },
    {
        "line": 195,
        "fullcodeline": "hash_triple[i] = hval;"
    },
    {
        "line": 201,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 209,
        "fullcodeline": "for (int l = 0; l < 8; l++) {"
    },
    {
        "line": 230,
        "fullcodeline": "for (int k = 0; k < 16; k++) {"
    },
    {
        "line": 238,
        "fullcodeline": "same = false;"
    },
    {
        "line": 239,
        "fullcodeline": "update_pair[i] = (uint32_t) (anchor + 1 + pair_start - obase);     /* update hash table */"
    },
    {
        "line": 240,
        "fullcodeline": "hash_pair[i] = hval;"
    },
    {
        "line": 245,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 254,
        "fullcodeline": "for (int l = 0; l < 8; l++) {"
    },
    {
        "line": 269,
        "fullcodeline": "for (int h = 0; h < 6; h++) {"
    },
    {
        "line": 274,
        "fullcodeline": "for (int h = 0; h < 7; h++) {"
    },
    {
        "line": 270,
        "fullcodeline": "tab_triple[hash_triple[h]] = update_triple[h];"
    },
    {
        "line": 275,
        "fullcodeline": "tab_pair[hash_pair[h]] = update_pair[h];"
    },
    {
        "line": 186,
        "fullcodeline": "if (buf_cell[triple_start + l] != buf_aux[l]) {"
    },
    {
        "line": 210,
        "fullcodeline": "if ((l < i) || (l > i + 2)) {"
    },
    {
        "line": 231,
        "fullcodeline": "if (buf_cell[pair_start + k] != buf_aux[k]) {"
    },
    {
        "line": 255,
        "fullcodeline": "if ((l < i) || (l > i + 1)) {"
    },
    {
        "line": 187,
        "fullcodeline": "same = false;"
    },
    {
        "line": 211,
        "fullcodeline": "memcpy(op, &buf_cell[l * cell_shape], cell_shape);"
    },
    {
        "line": 212,
        "fullcodeline": "op += cell_shape;"
    },
    {
        "line": 232,
        "fullcodeline": "same = false;"
    },
    {
        "line": 256,
        "fullcodeline": "memcpy(op, &buf_cell[l * cell_shape], cell_shape);"
    },
    {
        "line": 257,
        "fullcodeline": "op += cell_shape;"
    }
]