[
    {
        "line": 3,
        "fullcodeline": "BLOSC_UNUSED_PARAM(meta);"
    },
    {
        "line": 4,
        "fullcodeline": "BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);"
    },
    {
        "line": 5,
        "fullcodeline": "BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);"
    },
    {
        "line": 14,
        "fullcodeline": "const int cell_shape = 8;"
    },
    {
        "line": 15,
        "fullcodeline": "const int cell_size = 64;"
    },
    {
        "line": 17,
        "fullcodeline": "int64_t *shape = malloc(8 * sizeof(int64_t));"
    },
    {
        "line": 18,
        "fullcodeline": "int32_t *chunkshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 19,
        "fullcodeline": "int32_t *blockshape = malloc(8 * sizeof(int32_t));"
    },
    {
        "line": 20,
        "fullcodeline": "deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);"
    },
    {
        "line": 38,
        "fullcodeline": "uint8_t *ip = (uint8_t *) input;"
    },
    {
        "line": 39,
        "fullcodeline": "uint8_t *op = (uint8_t *) output;"
    },
    {
        "line": 44,
        "fullcodeline": "uint8_t *bufarea = malloc(cell_size);"
    },
    {
        "line": 45,
        "fullcodeline": "uint8_t *buf_cell = bufarea;"
    },
    {
        "line": 47,
        "fullcodeline": "uint32_t tab_cell[1U << 12U] = {0};"
    },
    {
        "line": 48,
        "fullcodeline": "uint32_t tab_triple[1U << 12U] = {0};"
    },
    {
        "line": 49,
        "fullcodeline": "uint32_t tab_pair[1U << 12U] = {0};"
    },
    {
        "line": 50,
        "fullcodeline": "uint32_t update_triple[6] = {0};"
    },
    {
        "line": 51,
        "fullcodeline": "uint32_t update_pair[7] = {0};"
    },
    {
        "line": 56,
        "fullcodeline": "op_limit = op + output_len;"
    },
    {
        "line": 66,
        "fullcodeline": "int overhead = 17 + (blockshape[0] * blockshape[1] / cell_size - 1) * 2;"
    },
    {
        "line": 72,
        "fullcodeline": "uint8_t *obase = op;"
    },
    {
        "line": 76,
        "fullcodeline": "memcpy(op, &blockshape[0], 4);"
    },
    {
        "line": 77,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 78,
        "fullcodeline": "memcpy(op, &blockshape[1], 4);"
    },
    {
        "line": 79,
        "fullcodeline": "op += 4;"
    },
    {
        "line": 81,
        "fullcodeline": "uint32_t i_stop[2];"
    },
    {
        "line": 88,
        "fullcodeline": "uint32_t padding[2];"
    },
    {
        "line": 89,
        "fullcodeline": "uint32_t ii[2];"
    },
    {
        "line": 9,
        "fullcodeline": "if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (ndim != 2) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (input_len != (blockshape[0] * blockshape[1])) {"
    },
    {
        "line": 42,
        "fullcodeline": "uint32_t hash_triple[6] = {0};"
    },
    {
        "line": 43,
        "fullcodeline": "uint32_t hash_pair[7] = {0};"
    },
    {
        "line": 59,
        "fullcodeline": "for (unsigned i = 0; i < (1U << 12U); i++) {"
    },
    {
        "line": 82,
        "fullcodeline": "for (int i = 0; i < 2; ++i) {"
    },
    {
        "line": 90,
        "fullcodeline": "for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {"
    },
    {
        "line": 313,
        "fullcodeline": "return (int) (op - obase);"
    },
    {
        "line": 10,
        "fullcodeline": "BLOSC_TRACE_ERROR(\"b2nd layer not found!\");"
    },
    {
        "line": 33,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int) (1 + ndim * sizeof(int32_t)))) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (input_len < cell_size || output_len < overhead) {"
    },
    {
        "line": 75,
        "fullcodeline": "*op++ = ndim;"
    },
    {
        "line": 83,
        "fullcodeline": "i_stop[i] = (blockshape[i] + cell_shape - 1) / cell_shape;"
    },
    {
        "line": 91,
        "fullcodeline": "for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell"
    },
    {
        "line": 107,
        "fullcodeline": "uint32_t orig = ii[0] * cell_shape * blockshape[1] + ii[1] * cell_shape;"
    },
    {
        "line": 92,
        "fullcodeline": "for (int h = 0; h < 7; h++) {         // new cell -> new possible references"
    },
    {
        "line": 93,
        "fullcodeline": "update_pair[h] = 0;"
    },
    {
        "line": 99,
        "fullcodeline": "if (NDLZ_UNEXPECT_CONDITIONAL(op + cell_size + 1 > op_limit)) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (((blockshape[0] % cell_shape != 0) && (ii[0] == i_stop[0] - 1)) ||"
    },
    {
        "line": 109,
        "fullcodeline": "((blockshape[1] % cell_shape != 0) && (ii[1] == i_stop[1] - 1))) {"
    },
    {
        "line": 110,
        "fullcodeline": "uint8_t token = 0;                                   // padding -> literal copy"
    },
    {
        "line": 297,
        "fullcodeline": "if ((op - obase) > input_len) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (h != 6) {"
    },
    {
        "line": 112,
        "fullcodeline": "if (ii[0] == i_stop[0] - 1) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (ii[1] == i_stop[1] - 1) {"
    },
    {
        "line": 122,
        "fullcodeline": "for (uint32_t i = 0; i < padding[0]; i++) {"
    },
    {
        "line": 132,
        "fullcodeline": "buf_cell -= cell_size;"
    },
    {
        "line": 136,
        "fullcodeline": "uint8_t *anchor = op;    /* comparison starting-point */"
    },
    {
        "line": 139,
        "fullcodeline": "hash_cell = XXH32(buf_cell, cell_size, 1);        // calculate cell hash"
    },
    {
        "line": 141,
        "fullcodeline": "ref = obase + tab_cell[hash_cell];"
    },
    {
        "line": 95,
        "fullcodeline": "update_triple[h] = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 113,
        "fullcodeline": "padding[0] = (blockshape[0] % cell_shape == 0) ? cell_shape : blockshape[0] % cell_shape;"
    },
    {
        "line": 118,
        "fullcodeline": "padding[1] = (blockshape[1] % cell_shape == 0) ? cell_shape : blockshape[1] % cell_shape;"
    },
    {
        "line": 123,
        "fullcodeline": "memcpy(op, &ip[orig + i * blockshape[1]], padding[1]);"
    },
    {
        "line": 124,
        "fullcodeline": "op += padding[1];"
    },
    {
        "line": 127,
        "fullcodeline": "for (uint64_t i = 0; i < (uint64_t) cell_shape; i++) {           // fill cell buffer"
    },
    {
        "line": 140,
        "fullcodeline": "hash_cell >>= 32U - 12U;"
    },
    {
        "line": 144,
        "fullcodeline": "if (tab_cell[hash_cell] == 0) {"
    },
    {
        "line": 163,
        "fullcodeline": "for (int i = 1; i < cell_size; i++) {"
    },
    {
        "line": 115,
        "fullcodeline": "padding[0] = cell_shape;"
    },
    {
        "line": 120,
        "fullcodeline": "padding[1] = cell_shape;"
    },
    {
        "line": 129,
        "fullcodeline": "memcpy(buf_cell, &ip[ind], cell_shape);"
    },
    {
        "line": 130,
        "fullcodeline": "buf_cell += cell_shape;"
    },
    {
        "line": 145,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 170,
        "fullcodeline": "uint8_t token = (uint8_t) (1U << 6U);"
    },
    {
        "line": 148,
        "fullcodeline": "buf_aux = obase + tab_cell[hash_cell];"
    },
    {
        "line": 164,
        "fullcodeline": "if (buf_cell[i] != buf_cell[0]) {"
    },
    {
        "line": 128,
        "fullcodeline": "uint64_t ind = orig + i * blockshape[1];"
    },
    {
        "line": 149,
        "fullcodeline": "for (int i = 0; i < cell_size; i++) {"
    },
    {
        "line": 171,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 172,
        "fullcodeline": "*op++ = buf_cell[0];"
    },
    {
        "line": 156,
        "fullcodeline": "distance = (int32_t) (anchor - ref);"
    },
    {
        "line": 174,
        "fullcodeline": "} else if (distance == 0 || (distance >= MAX_DISTANCE)) {   // no cell match"
    },
    {
        "line": 150,
        "fullcodeline": "if (buf_cell[i] != buf_aux[i]) {"
    },
    {
        "line": 158,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 178,
        "fullcodeline": "for (int i = 0; i < 6; i++) {"
    },
    {
        "line": 222,
        "fullcodeline": "for (int i = 0; i < 7; i++) {"
    },
    {
        "line": 288,
        "fullcodeline": "uint8_t token = (uint8_t) ((1U << 7U) | (1U << 6U));"
    },
    {
        "line": 290,
        "fullcodeline": "uint16_t offset = (uint16_t) (anchor - obase - tab_cell[hash_cell]);"
    },
    {
        "line": 291,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 292,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 179,
        "fullcodeline": "int triple_start = i * cell_shape;"
    },
    {
        "line": 180,
        "fullcodeline": "hval = XXH32(&buf_cell[triple_start], 24, 1);        // calculate triple hash"
    },
    {
        "line": 181,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 199,
        "fullcodeline": "ref = obase + tab_triple[hval];"
    },
    {
        "line": 223,
        "fullcodeline": "int pair_start = i * cell_shape;"
    },
    {
        "line": 224,
        "fullcodeline": "hval = XXH32(&buf_cell[pair_start], 16, 1);        // calculate rows pair hash"
    },
    {
        "line": 225,
        "fullcodeline": "hval >>= 32U - 12U;"
    },
    {
        "line": 226,
        "fullcodeline": "ref = obase + tab_pair[hval];"
    },
    {
        "line": 268,
        "fullcodeline": "tab_cell[hash_cell] = (uint32_t) (anchor + 1 - obase);     /* update hash tables */"
    },
    {
        "line": 280,
        "fullcodeline": "uint8_t token = 0;"
    },
    {
        "line": 282,
        "fullcodeline": "memcpy(op, buf_cell, cell_size);"
    },
    {
        "line": 283,
        "fullcodeline": "op += cell_size;"
    },
    {
        "line": 185,
        "fullcodeline": "if (tab_triple[hval] != 0) {"
    },
    {
        "line": 205,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     // 3 rows match"
    },
    {
        "line": 230,
        "fullcodeline": "if (tab_pair[hval] != 0) {"
    },
    {
        "line": 249,
        "fullcodeline": "if ((distance != 0) && (distance < MAX_DISTANCE)) {     /* 1 rows pair match */"
    },
    {
        "line": 289,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 186,
        "fullcodeline": "buf_aux = obase + tab_triple[hval];"
    },
    {
        "line": 193,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_triple[hval]);"
    },
    {
        "line": 201,
        "fullcodeline": "distance = (int32_t) (anchor + triple_start - ref);"
    },
    {
        "line": 207,
        "fullcodeline": "uint8_t token = (uint8_t) ((21 << 3U) | i);"
    },
    {
        "line": 209,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 210,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 231,
        "fullcodeline": "buf_aux = obase + tab_pair[hval];"
    },
    {
        "line": 238,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 245,
        "fullcodeline": "distance = (int32_t) (anchor + pair_start - ref);"
    },
    {
        "line": 251,
        "fullcodeline": "uint8_t token = (uint8_t) ((17 << 3U) | i);"
    },
    {
        "line": 253,
        "fullcodeline": "offset = (uint16_t) (anchor - obase - tab_pair[hval]);"
    },
    {
        "line": 254,
        "fullcodeline": "memcpy(op, &offset, 2);"
    },
    {
        "line": 255,
        "fullcodeline": "op += 2;"
    },
    {
        "line": 281,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 187,
        "fullcodeline": "for (int l = 0; l < 24; l++) {"
    },
    {
        "line": 203,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 211,
        "fullcodeline": "for (int l = 0; l < 8; l++) {"
    },
    {
        "line": 232,
        "fullcodeline": "for (int k = 0; k < 16; k++) {"
    },
    {
        "line": 247,
        "fullcodeline": "distance = 0;"
    },
    {
        "line": 256,
        "fullcodeline": "for (int l = 0; l < 8; l++) {"
    },
    {
        "line": 271,
        "fullcodeline": "for (int h = 0; h < 6; h++) {"
    },
    {
        "line": 276,
        "fullcodeline": "for (int h = 0; h < 7; h++) {"
    },
    {
        "line": 196,
        "fullcodeline": "update_triple[i] = (uint32_t) (anchor + 1 + triple_start - obase);     /* update hash table */"
    },
    {
        "line": 208,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 241,
        "fullcodeline": "update_pair[i] = (uint32_t) (anchor + 1 + pair_start - obase);     /* update hash table */"
    },
    {
        "line": 252,
        "fullcodeline": "*op++ = token;"
    },
    {
        "line": 188,
        "fullcodeline": "if (buf_cell[triple_start + l] != buf_aux[l]) {"
    },
    {
        "line": 233,
        "fullcodeline": "if (buf_cell[pair_start + k] != buf_aux[k]) {"
    },
    {
        "line": 212,
        "fullcodeline": "if ((l < i) || (l > i + 2)) {"
    },
    {
        "line": 213,
        "fullcodeline": "memcpy(op, &buf_cell[l * cell_shape], cell_shape);"
    },
    {
        "line": 214,
        "fullcodeline": "op += cell_shape;"
    },
    {
        "line": 257,
        "fullcodeline": "if ((l < i) || (l > i + 1)) {"
    },
    {
        "line": 258,
        "fullcodeline": "memcpy(op, &buf_cell[l * cell_shape], cell_shape);"
    },
    {
        "line": 259,
        "fullcodeline": "op += cell_shape;"
    }
]