[
    {
        "line": 120,
        "fullcodeline": "assert(image_info != (const ImageInfo *) NULL);"
    },
    {
        "line": 121,
        "fullcodeline": "assert(image_info->signature == MagickCoreSignature);"
    },
    {
        "line": 125,
        "fullcodeline": "assert(exception != (ExceptionInfo *) NULL);"
    },
    {
        "line": 126,
        "fullcodeline": "assert(exception->signature == MagickCoreSignature);"
    },
    {
        "line": 127,
        "fullcodeline": "image=AcquireImage(image_info,exception);"
    },
    {
        "line": 128,
        "fullcodeline": "status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);"
    },
    {
        "line": 137,
        "fullcodeline": "count=ReadBlob(image,1,&viff_info.identifier);"
    },
    {
        "line": 122,
        "fullcodeline": "if (image_info->debug != MagickFalse)"
    },
    {
        "line": 129,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 627,
        "fullcodeline": "} while ((count != 0) && (viff_info.identifier == 0xab));"
    },
    {
        "line": 628,
        "fullcodeline": "(void) CloseBlob(image);"
    },
    {
        "line": 629,
        "fullcodeline": "return(GetFirstImageInList(image));"
    },
    {
        "line": 123,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\","
    },
    {
        "line": 131,
        "fullcodeline": "image=DestroyImageList(image);"
    },
    {
        "line": 155,
        "fullcodeline": "viff_info.comment[511]='\\0';"
    },
    {
        "line": 163,
        "fullcodeline": "viff_info.rows=ReadBlobLong(image);"
    },
    {
        "line": 164,
        "fullcodeline": "viff_info.columns=ReadBlobLong(image);"
    },
    {
        "line": 168,
        "fullcodeline": "viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);"
    },
    {
        "line": 170,
        "fullcodeline": "viff_info.location_type=ReadBlobLong(image);"
    },
    {
        "line": 172,
        "fullcodeline": "viff_info.number_of_images=ReadBlobLong(image);"
    },
    {
        "line": 173,
        "fullcodeline": "viff_info.number_data_bands=ReadBlobLong(image);"
    },
    {
        "line": 174,
        "fullcodeline": "viff_info.data_storage_type=ReadBlobLong(image);"
    },
    {
        "line": 175,
        "fullcodeline": "viff_info.data_encode_scheme=ReadBlobLong(image);"
    },
    {
        "line": 176,
        "fullcodeline": "viff_info.map_scheme=ReadBlobLong(image);"
    },
    {
        "line": 177,
        "fullcodeline": "viff_info.map_storage_type=ReadBlobLong(image);"
    },
    {
        "line": 178,
        "fullcodeline": "viff_info.map_rows=ReadBlobLong(image);"
    },
    {
        "line": 179,
        "fullcodeline": "viff_info.map_columns=ReadBlobLong(image);"
    },
    {
        "line": 183,
        "fullcodeline": "viff_info.color_space_model=ReadBlobLong(image);"
    },
    {
        "line": 188,
        "fullcodeline": "image->columns=viff_info.rows;"
    },
    {
        "line": 189,
        "fullcodeline": "image->rows=viff_info.columns;"
    },
    {
        "line": 190,
        "fullcodeline": "image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :"
    },
    {
        "line": 195,
        "fullcodeline": "number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;"
    },
    {
        "line": 339,
        "fullcodeline": "image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :"
    },
    {
        "line": 341,
        "fullcodeline": "image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :"
    },
    {
        "line": 343,
        "fullcodeline": "image->columns=viff_info.rows;"
    },
    {
        "line": 344,
        "fullcodeline": "image->rows=viff_info.columns;"
    },
    {
        "line": 348,
        "fullcodeline": "status=SetImageExtent(image,image->columns,image->rows,exception);"
    },
    {
        "line": 374,
        "fullcodeline": "pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,"
    },
    {
        "line": 379,
        "fullcodeline": "lsb_first=1;"
    },
    {
        "line": 398,
        "fullcodeline": "min_value=0.0;"
    },
    {
        "line": 399,
        "fullcodeline": "scale_factor=1.0;"
    },
    {
        "line": 449,
        "fullcodeline": "p=(unsigned char *) pixels;"
    },
    {
        "line": 475,
        "fullcodeline": "p=(unsigned char *) pixels;"
    },
    {
        "line": 609,
        "fullcodeline": "count=ReadBlob(image,1,&viff_info.identifier);"
    },
    {
        "line": 132,
        "fullcodeline": "return((Image *) NULL);"
    },
    {
        "line": 148,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);"
    },
    {
        "line": 149,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);"
    },
    {
        "line": 150,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);"
    },
    {
        "line": 151,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.machine_dependency),"
    },
    {
        "line": 153,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);"
    },
    {
        "line": 154,
        "fullcodeline": "count=ReadBlob(image,512,(unsigned char *) viff_info.comment);"
    },
    {
        "line": 165,
        "fullcodeline": "viff_info.subrows=ReadBlobLong(image);"
    },
    {
        "line": 166,
        "fullcodeline": "viff_info.x_offset=ReadBlobSignedLong(image);"
    },
    {
        "line": 167,
        "fullcodeline": "viff_info.y_offset=ReadBlobSignedLong(image);"
    },
    {
        "line": 171,
        "fullcodeline": "viff_info.location_dimension=ReadBlobLong(image);"
    },
    {
        "line": 180,
        "fullcodeline": "viff_info.map_subrows=ReadBlobLong(image);"
    },
    {
        "line": 181,
        "fullcodeline": "viff_info.map_enable=ReadBlobLong(image);"
    },
    {
        "line": 182,
        "fullcodeline": "viff_info.maps_per_cycle=ReadBlobLong(image);"
    },
    {
        "line": 184,
        "fullcodeline": "for (i=0; i < 420; i++)"
    },
    {
        "line": 186,
        "fullcodeline": "if (EOFBlob(image) != MagickFalse)"
    },
    {
        "line": 196,
        "fullcodeline": "if (number_pixels != (size_t) number_pixels)"
    },
    {
        "line": 198,
        "fullcodeline": "if (number_pixels == 0)"
    },
    {
        "line": 226,
        "fullcodeline": "if (viff_info.map_rows == 0)"
    },
    {
        "line": 349,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 362,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_TYP_BIT)"
    },
    {
        "line": 376,
        "fullcodeline": "if (pixels == (unsigned char *) NULL)"
    },
    {
        "line": 378,
        "fullcodeline": "count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);"
    },
    {
        "line": 400,
        "fullcodeline": "if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&"
    },
    {
        "line": 450,
        "fullcodeline": "for (i=0; i < (ssize_t) max_packets; i++)"
    },
    {
        "line": 595,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 597,
        "fullcodeline": "if (EOFBlob(image) != MagickFalse)"
    },
    {
        "line": 606,
        "fullcodeline": "if (image_info->number_scenes != 0)"
    },
    {
        "line": 610,
        "fullcodeline": "if ((count != 0) && (viff_info.identifier == 0xab))"
    },
    {
        "line": 143,
        "fullcodeline": "if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))"
    },
    {
        "line": 144,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");"
    },
    {
        "line": 156,
        "fullcodeline": "if (strlen(viff_info.comment) > 4)"
    },
    {
        "line": 158,
        "fullcodeline": "if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||"
    },
    {
        "line": 159,
        "fullcodeline": "(viff_info.machine_dependency == VFF_DEP_NSORDER))"
    },
    {
        "line": 160,
        "fullcodeline": "image->endian=LSBEndian;"
    },
    {
        "line": 169,
        "fullcodeline": "viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);"
    },
    {
        "line": 185,
        "fullcodeline": "(void) ReadBlobByte(image);"
    },
    {
        "line": 187,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");"
    },
    {
        "line": 197,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 199,
        "fullcodeline": "ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");"
    },
    {
        "line": 200,
        "fullcodeline": "if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))"
    },
    {
        "line": 201,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 202,
        "fullcodeline": "if ((viff_info.data_storage_type != VFF_TYP_BIT) &&"
    },
    {
        "line": 207,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_DOUBLE))"
    },
    {
        "line": 208,
        "fullcodeline": "ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");"
    },
    {
        "line": 210,
        "fullcodeline": "ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");"
    },
    {
        "line": 211,
        "fullcodeline": "if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&"
    },
    {
        "line": 216,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))"
    },
    {
        "line": 217,
        "fullcodeline": "ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");"
    },
    {
        "line": 218,
        "fullcodeline": "if ((viff_info.color_space_model != VFF_CM_NONE) &&"
    },
    {
        "line": 220,
        "fullcodeline": "(viff_info.color_space_model != VFF_CM_genericRGB))"
    },
    {
        "line": 221,
        "fullcodeline": "ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");"
    },
    {
        "line": 223,
        "fullcodeline": "ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");"
    },
    {
        "line": 225,
        "fullcodeline": "ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");"
    },
    {
        "line": 227,
        "fullcodeline": "viff_info.map_scheme=VFF_MS_NONE;"
    },
    {
        "line": 334,
        "fullcodeline": "ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");"
    },
    {
        "line": 345,
        "fullcodeline": "if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))"
    },
    {
        "line": 356,
        "fullcodeline": "case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;"
    },
    {
        "line": 357,
        "fullcodeline": "case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;"
    },
    {
        "line": 358,
        "fullcodeline": "case VFF_TYP_FLOAT: bytes_per_pixel=4; break;"
    },
    {
        "line": 359,
        "fullcodeline": "case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;"
    },
    {
        "line": 360,
        "fullcodeline": "default: bytes_per_pixel=1; break;"
    },
    {
        "line": 366,
        "fullcodeline": "max_packets=((image->columns+7UL) >> 3UL)*image->rows;"
    },
    {
        "line": 377,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 381,
        "fullcodeline": "((viff_info.machine_dependency != VFF_DEP_DECORDER) &&"
    },
    {
        "line": 401,
        "fullcodeline": "(viff_info.map_scheme == VFF_MS_NONE))"
    },
    {
        "line": 417,
        "fullcodeline": "max_value=value;"
    },
    {
        "line": 418,
        "fullcodeline": "min_value=value;"
    },
    {
        "line": 469,
        "fullcodeline": "*p=(unsigned char) ((Quantum) value);"
    },
    {
        "line": 594,
        "fullcodeline": "pixels=(unsigned char *) RelinquishMagickMemory(pixels);"
    },
    {
        "line": 599,
        "fullcodeline": "ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\","
    },
    {
        "line": 615,
        "fullcodeline": "AcquireNextImage(image_info,image,exception);"
    },
    {
        "line": 621,
        "fullcodeline": "image=SyncNextImageInList(image);"
    },
    {
        "line": 622,
        "fullcodeline": "status=SetImageProgress(image,LoadImagesTag,TellBlob(image),"
    },
    {
        "line": 157,
        "fullcodeline": "(void) SetImageProperty(image,\"comment\",viff_info.comment,exception);"
    },
    {
        "line": 162,
        "fullcodeline": "image->endian=MSBEndian;"
    },
    {
        "line": 206,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_FLOAT) &&"
    },
    {
        "line": 215,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&"
    },
    {
        "line": 219,
        "fullcodeline": "(viff_info.color_space_model != VFF_CM_ntscRGB) &&"
    },
    {
        "line": 268,
        "fullcodeline": "image->colors=viff_info.map_columns;"
    },
    {
        "line": 274,
        "fullcodeline": "viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,"
    },
    {
        "line": 283,
        "fullcodeline": "lsb_first=1;"
    },
    {
        "line": 346,
        "fullcodeline": "if (image->scene >= (image_info->scene+image_info->number_scenes-1))"
    },
    {
        "line": 350,
        "fullcodeline": "return(DestroyImageList(image));"
    },
    {
        "line": 364,
        "fullcodeline": "if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)"
    },
    {
        "line": 372,
        "fullcodeline": "max_packets=(size_t) (number_pixels*viff_info.number_data_bands);"
    },
    {
        "line": 375,
        "fullcodeline": "max_packets),bytes_per_pixel*sizeof(*pixels));"
    },
    {
        "line": 382,
        "fullcodeline": "(viff_info.machine_dependency != VFF_DEP_NSORDER)))"
    },
    {
        "line": 419,
        "fullcodeline": "for (i=0; i < (ssize_t) max_packets; i++)"
    },
    {
        "line": 460,
        "fullcodeline": "if (viff_info.map_scheme == VFF_MS_NONE)"
    },
    {
        "line": 481,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 596,
        "fullcodeline": "(void) SyncImage(image,exception);"
    },
    {
        "line": 607,
        "fullcodeline": "if (image->scene >= (image_info->scene+image_info->number_scenes-1))"
    },
    {
        "line": 624,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 205,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_4_BYTE) &&"
    },
    {
        "line": 214,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&"
    },
    {
        "line": 232,
        "fullcodeline": "if (viff_info.number_data_bands < 3)"
    },
    {
        "line": 269,
        "fullcodeline": "if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)"
    },
    {
        "line": 271,
        "fullcodeline": "if (viff_info.map_rows >"
    },
    {
        "line": 276,
        "fullcodeline": "if (viff_colormap == (unsigned char *) NULL)"
    },
    {
        "line": 281,
        "fullcodeline": "count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,"
    },
    {
        "line": 304,
        "fullcodeline": "for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)"
    },
    {
        "line": 365,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 370,
        "fullcodeline": "if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)"
    },
    {
        "line": 411,
        "fullcodeline": "case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;"
    },
    {
        "line": 412,
        "fullcodeline": "case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;"
    },
    {
        "line": 413,
        "fullcodeline": "case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;"
    },
    {
        "line": 414,
        "fullcodeline": "case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;"
    },
    {
        "line": 415,
        "fullcodeline": "default: value=1.0*pixels[0]; break;"
    },
    {
        "line": 435,
        "fullcodeline": "if ((min_value == 0) && (max_value == 0))"
    },
    {
        "line": 436,
        "fullcodeline": "scale_factor=0;"
    },
    {
        "line": 454,
        "fullcodeline": "case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;"
    },
    {
        "line": 455,
        "fullcodeline": "case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;"
    },
    {
        "line": 456,
        "fullcodeline": "case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;"
    },
    {
        "line": 457,
        "fullcodeline": "case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;"
    },
    {
        "line": 458,
        "fullcodeline": "default: value=1.0*pixels[i]; break;"
    },
    {
        "line": 462,
        "fullcodeline": "value=(value-min_value)*scale_factor;"
    },
    {
        "line": 483,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 526,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 616,
        "fullcodeline": "if (GetNextImageInList(image) == (Image *) NULL)"
    },
    {
        "line": 623,
        "fullcodeline": "GetBlobSize(image));"
    },
    {
        "line": 204,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_2_BYTE) &&"
    },
    {
        "line": 213,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&"
    },
    {
        "line": 244,
        "fullcodeline": "status=AcquireImageColormap(image,image->colors,exception);"
    },
    {
        "line": 261,
        "fullcodeline": "case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;"
    },
    {
        "line": 262,
        "fullcodeline": "case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;"
    },
    {
        "line": 263,
        "fullcodeline": "case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;"
    },
    {
        "line": 264,
        "fullcodeline": "case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;"
    },
    {
        "line": 265,
        "fullcodeline": "case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;"
    },
    {
        "line": 266,
        "fullcodeline": "default: bytes_per_pixel=1; break;"
    },
    {
        "line": 270,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 272,
        "fullcodeline": "(viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))"
    },
    {
        "line": 273,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 277,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 285,
        "fullcodeline": "((viff_info.machine_dependency != VFF_DEP_DECORDER) &&"
    },
    {
        "line": 330,
        "fullcodeline": "viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);"
    },
    {
        "line": 371,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 387,
        "fullcodeline": "MSBOrderShort(pixels,bytes_per_pixel*max_packets);"
    },
    {
        "line": 393,
        "fullcodeline": "MSBOrderLong(pixels,bytes_per_pixel*max_packets);"
    },
    {
        "line": 429,
        "fullcodeline": "if (value > max_value)"
    },
    {
        "line": 463,
        "fullcodeline": "if (value > QuantumRange)"
    },
    {
        "line": 484,
        "fullcodeline": "if (q == (Quantum *) NULL)"
    },
    {
        "line": 486,
        "fullcodeline": "for (x=0; x < (ssize_t) (image->columns-7); x+=8)"
    },
    {
        "line": 514,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 516,
        "fullcodeline": "if (image->previous == (Image *) NULL)"
    },
    {
        "line": 618,
        "fullcodeline": "image=DestroyImageList(image);"
    },
    {
        "line": 619,
        "fullcodeline": "return((Image *) NULL);"
    },
    {
        "line": 203,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_1_BYTE) &&"
    },
    {
        "line": 212,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&"
    },
    {
        "line": 237,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_TYP_BIT)"
    },
    {
        "line": 245,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 275,
        "fullcodeline": "viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));"
    },
    {
        "line": 286,
        "fullcodeline": "(viff_info.machine_dependency != VFF_DEP_NSORDER)))"
    },
    {
        "line": 314,
        "fullcodeline": "if (i < (ssize_t) image->colors)"
    },
    {
        "line": 423,
        "fullcodeline": "case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;"
    },
    {
        "line": 424,
        "fullcodeline": "case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;"
    },
    {
        "line": 425,
        "fullcodeline": "case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;"
    },
    {
        "line": 426,
        "fullcodeline": "case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;"
    },
    {
        "line": 427,
        "fullcodeline": "default: value=1.0*pixels[i]; break;"
    },
    {
        "line": 430,
        "fullcodeline": "max_value=value;"
    },
    {
        "line": 438,
        "fullcodeline": "if (min_value == max_value)"
    },
    {
        "line": 464,
        "fullcodeline": "value=QuantumRange;"
    },
    {
        "line": 498,
        "fullcodeline": "p++;"
    },
    {
        "line": 500,
        "fullcodeline": "if ((image->columns % 8) != 0)"
    },
    {
        "line": 512,
        "fullcodeline": "p++;"
    },
    {
        "line": 518,
        "fullcodeline": "status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,"
    },
    {
        "line": 527,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 552,
        "fullcodeline": "number_pixels=(MagickSizeType) image->columns*image->rows;"
    },
    {
        "line": 238,
        "fullcodeline": "image->colors=2;"
    },
    {
        "line": 246,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 308,
        "fullcodeline": "case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;"
    },
    {
        "line": 309,
        "fullcodeline": "case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;"
    },
    {
        "line": 310,
        "fullcodeline": "case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;"
    },
    {
        "line": 311,
        "fullcodeline": "case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;"
    },
    {
        "line": 312,
        "fullcodeline": "default: value=1.0*viff_colormap[i]; break;"
    },
    {
        "line": 440,
        "fullcodeline": "scale_factor=(double) QuantumRange/min_value;"
    },
    {
        "line": 441,
        "fullcodeline": "min_value=0;"
    },
    {
        "line": 488,
        "fullcodeline": "for (bit=0; bit < 8; bit++)"
    },
    {
        "line": 502,
        "fullcodeline": "for (bit=0; bit < (int) (image->columns % 8); bit++)"
    },
    {
        "line": 520,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 529,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 553,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 291,
        "fullcodeline": "MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*"
    },
    {
        "line": 298,
        "fullcodeline": "MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*"
    },
    {
        "line": 316,
        "fullcodeline": "image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 318,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 319,
        "fullcodeline": "image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 432,
        "fullcodeline": "if (value < min_value)"
    },
    {
        "line": 444,
        "fullcodeline": "scale_factor=(double) QuantumRange/(max_value-min_value);"
    },
    {
        "line": 466,
        "fullcodeline": "if (value < 0)"
    },
    {
        "line": 490,
        "fullcodeline": "quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);"
    },
    {
        "line": 491,
        "fullcodeline": "SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 492,
        "fullcodeline": "SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 493,
        "fullcodeline": "SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 496,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 504,
        "fullcodeline": "quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);"
    },
    {
        "line": 505,
        "fullcodeline": "SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 506,
        "fullcodeline": "SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 507,
        "fullcodeline": "SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 510,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 530,
        "fullcodeline": "if (q == (Quantum *) NULL)"
    },
    {
        "line": 532,
        "fullcodeline": "for (x=0; x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 537,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 539,
        "fullcodeline": "if (image->previous == (Image *) NULL)"
    },
    {
        "line": 555,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 240,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)"
    },
    {
        "line": 322,
        "fullcodeline": "if (i < (ssize_t) (2*image->colors))"
    },
    {
        "line": 433,
        "fullcodeline": "min_value=value;"
    },
    {
        "line": 467,
        "fullcodeline": "value=0;"
    },
    {
        "line": 494,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 508,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 534,
        "fullcodeline": "SetPixelIndex(image,*p++,q);"
    },
    {
        "line": 535,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 541,
        "fullcodeline": "status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,"
    },
    {
        "line": 556,
        "fullcodeline": "if (q == (Quantum *) NULL)"
    },
    {
        "line": 558,
        "fullcodeline": "for (x=0; x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 583,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 585,
        "fullcodeline": "if (image->previous == (Image *) NULL)"
    },
    {
        "line": 241,
        "fullcodeline": "image->colors=256UL;"
    },
    {
        "line": 495,
        "fullcodeline": "SetPixelIndex(image,(Quantum) quantum,q);"
    },
    {
        "line": 509,
        "fullcodeline": "SetPixelIndex(image,(Quantum) quantum,q);"
    },
    {
        "line": 543,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 560,
        "fullcodeline": "SetPixelRed(image,ScaleCharToQuantum(*p),q);"
    },
    {
        "line": 561,
        "fullcodeline": "SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);"
    },
    {
        "line": 562,
        "fullcodeline": "SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);"
    },
    {
        "line": 578,
        "fullcodeline": "SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?"
    },
    {
        "line": 580,
        "fullcodeline": "p++;"
    },
    {
        "line": 581,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 587,
        "fullcodeline": "status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,"
    },
    {
        "line": 243,
        "fullcodeline": "image->colors=image->depth <= 8 ? 256UL : 65536UL;"
    },
    {
        "line": 324,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 563,
        "fullcodeline": "if (image->colors != 0)"
    },
    {
        "line": 589,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 326,
        "fullcodeline": "if (i < (ssize_t) (3*image->colors))"
    },
    {
        "line": 568,
        "fullcodeline": "index=(ssize_t) GetPixelRed(image,q);"
    },
    {
        "line": 569,
        "fullcodeline": "SetPixelRed(image,image->colormap["
    },
    {
        "line": 571,
        "fullcodeline": "index=(ssize_t) GetPixelGreen(image,q);"
    },
    {
        "line": 572,
        "fullcodeline": "SetPixelGreen(image,image->colormap["
    },
    {
        "line": 574,
        "fullcodeline": "index=(ssize_t) GetPixelBlue(image,q);"
    },
    {
        "line": 575,
        "fullcodeline": "SetPixelBlue(image,image->colormap["
    },
    {
        "line": 579,
        "fullcodeline": "ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);"
    },
    {
        "line": 323,
        "fullcodeline": "image->colormap[i % image->colors].green="
    },
    {
        "line": 328,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 570,
        "fullcodeline": "ConstrainColormapIndex(image,index,exception)].red,q);"
    },
    {
        "line": 573,
        "fullcodeline": "ConstrainColormapIndex(image,index,exception)].green,q);"
    },
    {
        "line": 576,
        "fullcodeline": "ConstrainColormapIndex(image,index,exception)].blue,q);"
    },
    {
        "line": 327,
        "fullcodeline": "image->colormap[i % image->colors].blue="
    }
]