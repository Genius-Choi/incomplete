[
    {
        "line": 6,
        "fullcodeline": "struct child_process child = CHILD_PROCESS_INIT;"
    },
    {
        "line": 10,
        "fullcodeline": "child.git_cmd = 1;"
    },
    {
        "line": 11,
        "fullcodeline": "child.in = -1;"
    },
    {
        "line": 14,
        "fullcodeline": "strvec_pushl(&child.args, \"-c\", \"fetch.negotiationAlgorithm=noop\","
    },
    {
        "line": 20,
        "fullcodeline": "child_in = xfdopen(child.in, \"w\");"
    },
    {
        "line": 22,
        "fullcodeline": "trace2_data_intmax(\"promisor\", repo, \"fetch_count\", oid_nr);"
    },
    {
        "line": 12,
        "fullcodeline": "if (repo != the_repository)"
    },
    {
        "line": 18,
        "fullcodeline": "if (start_command(&child))"
    },
    {
        "line": 24,
        "fullcodeline": "for (i = 0; i < oid_nr; i++) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (fclose(child_in) < 0)"
    },
    {
        "line": 33,
        "fullcodeline": "return finish_command(&child) ? -1 : 0;"
    },
    {
        "line": 13,
        "fullcodeline": "prepare_other_repo_env(&child.env, repo->gitdir);"
    },
    {
        "line": 19,
        "fullcodeline": "die(_(\"promisor-remote: unable to fork off fetch subprocess\"));"
    },
    {
        "line": 32,
        "fullcodeline": "die_errno(_(\"promisor-remote: could not close stdin to fetch subprocess\"));"
    },
    {
        "line": 25,
        "fullcodeline": "if (fputs(oid_to_hex(&oids[i]), child_in) < 0)"
    },
    {
        "line": 27,
        "fullcodeline": "if (fputc('\\n', child_in) < 0)"
    },
    {
        "line": 26,
        "fullcodeline": "die_errno(_(\"promisor-remote: could not write to fetch subprocess\"));"
    },
    {
        "line": 28,
        "fullcodeline": "die_errno(_(\"promisor-remote: could not write to fetch subprocess\"));"
    }
]