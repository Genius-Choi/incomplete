[
    {
        "line": 24,
        "fullcodeline": "base_url_to_use = base_url if base_url is not None else url"
    },
    {
        "line": 25,
        "fullcodeline": "parsed_base_url = urlparse(base_url_to_use)"
    },
    {
        "line": 26,
        "fullcodeline": "all_links = find_all_links(raw_html, pattern=pattern)"
    },
    {
        "line": 27,
        "fullcodeline": "absolute_paths = set()"
    },
    {
        "line": 40,
        "fullcodeline": "results = []"
    },
    {
        "line": 28,
        "fullcodeline": "for link in all_links:"
    },
    {
        "line": 41,
        "fullcodeline": "for path in absolute_paths:"
    },
    {
        "line": 29,
        "fullcodeline": "parsed_link = urlparse(link)"
    },
    {
        "line": 38,
        "fullcodeline": "absolute_paths.add(absolute_path)"
    },
    {
        "line": 56,
        "fullcodeline": "results.append(path)"
    },
    {
        "line": 31,
        "fullcodeline": "if parsed_link.scheme == \"http\" or parsed_link.scheme == \"https\":"
    },
    {
        "line": 42,
        "fullcodeline": "if any(path.startswith(exclude_prefix) for exclude_prefix in exclude_prefixes):"
    },
    {
        "line": 32,
        "fullcodeline": "absolute_path = link"
    },
    {
        "line": 46,
        "fullcodeline": "parsed_path = urlparse(path)"
    },
    {
        "line": 34,
        "fullcodeline": "elif link.startswith(\"//\"):"
    },
    {
        "line": 48,
        "fullcodeline": "if parsed_base_url.netloc != parsed_path.netloc:"
    },
    {
        "line": 53,
        "fullcodeline": "if not path.startswith(base_url_to_use):"
    },
    {
        "line": 35,
        "fullcodeline": "absolute_path = f\"{urlparse(url).scheme}:{link}\""
    },
    {
        "line": 37,
        "fullcodeline": "absolute_path = urljoin(url, parsed_link.path)"
    }
]