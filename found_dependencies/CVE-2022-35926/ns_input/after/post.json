[
    {
        "line": 3,
        "fullcodeline": "uint8_t flags = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "LOG_INFO(\"Received NS from \");"
    },
    {
        "line": 7,
        "fullcodeline": "LOG_INFO_(\" to \");"
    },
    {
        "line": 9,
        "fullcodeline": "LOG_INFO_(\" with target address \");"
    },
    {
        "line": 11,
        "fullcodeline": "LOG_INFO_(\"\\n\");"
    },
    {
        "line": 12,
        "fullcodeline": "UIP_STAT(++uip_stat.nd6.recv);"
    },
    {
        "line": 24,
        "fullcodeline": "nd6_opt_llao = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "nd6_opt_offset = UIP_ND6_NS_LEN;"
    },
    {
        "line": 85,
        "fullcodeline": "addr = uip_ds6_addr_lookup(&UIP_ND6_NS_BUF->tgtipaddr);"
    },
    {
        "line": 153,
        "fullcodeline": "uipbuf_clear();"
    },
    {
        "line": 154,
        "fullcodeline": "UIP_IP_BUF->vtc = 0x60;"
    },
    {
        "line": 155,
        "fullcodeline": "UIP_IP_BUF->tcflow = 0;"
    },
    {
        "line": 156,
        "fullcodeline": "UIP_IP_BUF->flow = 0;"
    },
    {
        "line": 157,
        "fullcodeline": "uipbuf_set_len_field(UIP_IP_BUF, UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN);"
    },
    {
        "line": 158,
        "fullcodeline": "UIP_IP_BUF->proto = UIP_PROTO_ICMP6;"
    },
    {
        "line": 159,
        "fullcodeline": "UIP_IP_BUF->ttl = UIP_ND6_HOP_LIMIT;"
    },
    {
        "line": 161,
        "fullcodeline": "UIP_ICMP_BUF->type = ICMP6_NA;"
    },
    {
        "line": 162,
        "fullcodeline": "UIP_ICMP_BUF->icode = 0;"
    },
    {
        "line": 164,
        "fullcodeline": "UIP_ND6_NA_BUF->flagsreserved = flags;"
    },
    {
        "line": 165,
        "fullcodeline": "memcpy(&UIP_ND6_NA_BUF->tgtipaddr, &addr->ipaddr, sizeof(uip_ipaddr_t));"
    },
    {
        "line": 167,
        "fullcodeline": "create_llao(&uip_buf[uip_l3_icmp_hdr_len + UIP_ND6_NA_LEN],"
    },
    {
        "line": 170,
        "fullcodeline": "UIP_ICMP_BUF->icmpchksum = 0;"
    },
    {
        "line": 171,
        "fullcodeline": "UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();"
    },
    {
        "line": 173,
        "fullcodeline": "uipbuf_set_len(UIP_IPH_LEN + UIP_ICMPH_LEN + UIP_ND6_NA_LEN + UIP_ND6_OPT_LLAO_LEN);"
    },
    {
        "line": 175,
        "fullcodeline": "UIP_STAT(++uip_stat.nd6.sent);"
    },
    {
        "line": 176,
        "fullcodeline": "LOG_INFO(\"Sending NA to \");"
    },
    {
        "line": 177,
        "fullcodeline": "LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);"
    },
    {
        "line": 178,
        "fullcodeline": "LOG_INFO_(\" from \");"
    },
    {
        "line": 179,
        "fullcodeline": "LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);"
    },
    {
        "line": 180,
        "fullcodeline": "LOG_INFO_(\" with target address \");"
    },
    {
        "line": 181,
        "fullcodeline": "LOG_INFO_6ADDR(&UIP_ND6_NA_BUF->tgtipaddr);"
    },
    {
        "line": 182,
        "fullcodeline": "LOG_INFO_(\"\\n\");"
    },
    {
        "line": 186,
        "fullcodeline": "uipbuf_clear();"
    },
    {
        "line": 26,
        "fullcodeline": "while(uip_l3_icmp_hdr_len + nd6_opt_offset + UIP_ND6_OPT_HDR_LEN < uip_len) {"
    },
    {
        "line": 86,
        "fullcodeline": "if(addr != NULL) {"
    },
    {
        "line": 82,
        "fullcodeline": "nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3);"
    },
    {
        "line": 87,
        "fullcodeline": "if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {"
    },
    {
        "line": 124,
        "fullcodeline": "if(uip_is_addr_solicited_node(&UIP_IP_BUF->destipaddr)) {"
    },
    {
        "line": 132,
        "fullcodeline": "if(uip_ds6_addr_lookup(&UIP_IP_BUF->destipaddr) == addr) {"
    },
    {
        "line": 33,
        "fullcodeline": "switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) {"
    },
    {
        "line": 49,
        "fullcodeline": "extract_lladdr_from_llao_aligned(&lladdr_aligned);"
    },
    {
        "line": 50,
        "fullcodeline": "nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr);"
    },
    {
        "line": 79,
        "fullcodeline": "LOG_WARN(\"ND option not supported in NS\");"
    },
    {
        "line": 125,
        "fullcodeline": "uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);"
    },
    {
        "line": 126,
        "fullcodeline": "uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr);"
    },
    {
        "line": 127,
        "fullcodeline": "flags = UIP_ND6_NA_FLAG_SOLICITED | UIP_ND6_NA_FLAG_OVERRIDE;"
    },
    {
        "line": 133,
        "fullcodeline": "uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);"
    },
    {
        "line": 134,
        "fullcodeline": "uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_ND6_NS_BUF->tgtipaddr);"
    },
    {
        "line": 135,
        "fullcodeline": "flags = UIP_ND6_NA_FLAG_SOLICITED | UIP_ND6_NA_FLAG_OVERRIDE;"
    },
    {
        "line": 35,
        "fullcodeline": "if(uip_l3_icmp_hdr_len + nd6_opt_offset +"
    },
    {
        "line": 51,
        "fullcodeline": "if(nbr == NULL) {"
    },
    {
        "line": 37,
        "fullcodeline": "LOG_ERR(\"Insufficient data for NS SLLAO option\\n\");"
    },
    {
        "line": 52,
        "fullcodeline": "uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned,"
    },
    {
        "line": 40,
        "fullcodeline": "nd6_opt_llao = &uip_buf[uip_l3_icmp_hdr_len + nd6_opt_offset];"
    },
    {
        "line": 55,
        "fullcodeline": "const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr);"
    },
    {
        "line": 56,
        "fullcodeline": "if(lladdr == NULL) {"
    },
    {
        "line": 59,
        "fullcodeline": "if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET],"
    },
    {
        "line": 67,
        "fullcodeline": "nbr->state = NBR_STALE;"
    },
    {
        "line": 61,
        "fullcodeline": "if(uip_ds6_nbr_update_ll(&nbr,"
    },
    {
        "line": 69,
        "fullcodeline": "if(nbr->state == NBR_INCOMPLETE) {"
    },
    {
        "line": 62,
        "fullcodeline": "(const uip_lladdr_t *)&lladdr_aligned)"
    },
    {
        "line": 70,
        "fullcodeline": "nbr->state = NBR_STALE;"
    }
]