[
    {
        "line": 6,
        "fullcodeline": "_cleanup_(free_todo_entries) TodoEntry *todos = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t n_todo = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "_cleanup_free_ char *dirname = NULL; /* Set when we are recursing and want to delete ourselves */"
    },
    {
        "line": 9,
        "fullcodeline": "int ret = 0, r;"
    },
    {
        "line": 15,
        "fullcodeline": "_cleanup_closedir_ DIR *d = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "if (n_todo > 0) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(fd) < 0 && ret >= 0)"
    },
    {
        "line": 105,
        "fullcodeline": "if (n_todo == 0)"
    },
    {
        "line": 20,
        "fullcodeline": "assert(dirname);"
    },
    {
        "line": 21,
        "fullcodeline": "r = unlinkat_harder(dirfd(todos[n_todo-1].dir), dirname, AT_REMOVEDIR, flags);"
    },
    {
        "line": 24,
        "fullcodeline": "dirname = mfree(dirname);"
    },
    {
        "line": 27,
        "fullcodeline": "n_todo --;"
    },
    {
        "line": 28,
        "fullcodeline": "d = TAKE_PTR(todos[n_todo].dir);"
    },
    {
        "line": 29,
        "fullcodeline": "dirname = TAKE_PTR(todos[n_todo].dirname);"
    },
    {
        "line": 31,
        "fullcodeline": "assert(d);"
    },
    {
        "line": 32,
        "fullcodeline": "fd = dirfd(d); /* Retrieve the file descriptor from the DIR object */"
    },
    {
        "line": 103,
        "fullcodeline": "ret = -errno;"
    },
    {
        "line": 22,
        "fullcodeline": "if (r < 0 && r != -ENOENT && ret == 0)"
    },
    {
        "line": 33,
        "fullcodeline": "assert(fd >= 0);"
    },
    {
        "line": 36,
        "fullcodeline": "assert(fd >= 0);"
    },
    {
        "line": 37,
        "fullcodeline": "d = fdopendir(fd);"
    },
    {
        "line": 42,
        "fullcodeline": "fd = dirfd(d); /* We donated the fd to fdopendir(). Let's make sure we sure we have"
    },
    {
        "line": 23,
        "fullcodeline": "ret = r;"
    },
    {
        "line": 38,
        "fullcodeline": "if (!d) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (!(flags & REMOVE_PHYSICAL)) {"
    },
    {
        "line": 39,
        "fullcodeline": "safe_close(fd);"
    },
    {
        "line": 40,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 49,
        "fullcodeline": "if (fstatfs(fd, &sfs) < 0)"
    },
    {
        "line": 52,
        "fullcodeline": "if (is_physical_fs(&sfs)) {"
    },
    {
        "line": 57,
        "fullcodeline": "_cleanup_free_ char *path = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "return -errno;"
    },
    {
        "line": 59,
        "fullcodeline": "(void) fd_get_path(fd, &path);"
    },
    {
        "line": 60,
        "fullcodeline": "return log_error_errno(SYNTHETIC_ERRNO(EPERM),"
    },
    {
        "line": 62,
        "fullcodeline": "strna(path));"
    }
]