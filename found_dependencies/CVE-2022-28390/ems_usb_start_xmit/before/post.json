[
    {
        "line": 3,
        "fullcodeline": "struct ems_usb *dev = netdev_priv(netdev);"
    },
    {
        "line": 4,
        "fullcodeline": "struct ems_tx_urb_context *context = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "struct net_device_stats *stats = &netdev->stats;"
    },
    {
        "line": 6,
        "fullcodeline": "struct can_frame *cf = (struct can_frame *)skb->data;"
    },
    {
        "line": 11,
        "fullcodeline": "size_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN"
    },
    {
        "line": 18,
        "fullcodeline": "urb = usb_alloc_urb(0, GFP_ATOMIC);"
    },
    {
        "line": 22,
        "fullcodeline": "buf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);"
    },
    {
        "line": 29,
        "fullcodeline": "msg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];"
    },
    {
        "line": 31,
        "fullcodeline": "msg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);"
    },
    {
        "line": 32,
        "fullcodeline": "msg->msg.can_msg.length = cf->len;"
    },
    {
        "line": 69,
        "fullcodeline": "context->dev = dev;"
    },
    {
        "line": 70,
        "fullcodeline": "context->echo_index = i;"
    },
    {
        "line": 72,
        "fullcodeline": "usb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,"
    },
    {
        "line": 74,
        "fullcodeline": "urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;"
    },
    {
        "line": 75,
        "fullcodeline": "usb_anchor_urb(urb, &dev->tx_submitted);"
    },
    {
        "line": 77,
        "fullcodeline": "can_put_echo_skb(skb, netdev, context->echo_index, 0);"
    },
    {
        "line": 79,
        "fullcodeline": "atomic_inc(&dev->active_tx_urbs);"
    },
    {
        "line": 81,
        "fullcodeline": "err = usb_submit_urb(urb, GFP_ATOMIC);"
    },
    {
        "line": 112,
        "fullcodeline": "usb_free_urb(urb);"
    },
    {
        "line": 117,
        "fullcodeline": "dev_kfree_skb(skb);"
    },
    {
        "line": 118,
        "fullcodeline": "stats->tx_dropped++;"
    },
    {
        "line": 14,
        "fullcodeline": "if (can_dropped_invalid_skb(netdev, skb))"
    },
    {
        "line": 19,
        "fullcodeline": "if (!urb)"
    },
    {
        "line": 23,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (cf->can_id & CAN_RTR_FLAG) {"
    },
    {
        "line": 49,
        "fullcodeline": "for (i = 0; i < MAX_TX_URBS; i++) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (!context) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (unlikely(err)) {"
    },
    {
        "line": 24,
        "fullcodeline": "netdev_err(netdev, \"No memory left for USB buffer\\n\");"
    },
    {
        "line": 25,
        "fullcodeline": "usb_free_urb(urb);"
    },
    {
        "line": 35,
        "fullcodeline": "msg->type = cf->can_id & CAN_EFF_FLAG ?"
    },
    {
        "line": 38,
        "fullcodeline": "msg->length = CPC_CAN_MSG_MIN_SIZE;"
    },
    {
        "line": 61,
        "fullcodeline": "usb_free_coherent(dev->udev, size, buf, urb->transfer_dma);"
    },
    {
        "line": 62,
        "fullcodeline": "usb_free_urb(urb);"
    },
    {
        "line": 64,
        "fullcodeline": "netdev_warn(netdev, \"couldn't find free context\\n\");"
    },
    {
        "line": 83,
        "fullcodeline": "can_free_echo_skb(netdev, context->echo_index, NULL);"
    },
    {
        "line": 85,
        "fullcodeline": "usb_unanchor_urb(urb);"
    },
    {
        "line": 86,
        "fullcodeline": "usb_free_coherent(dev->udev, size, buf, urb->transfer_dma);"
    },
    {
        "line": 87,
        "fullcodeline": "dev_kfree_skb(skb);"
    },
    {
        "line": 89,
        "fullcodeline": "atomic_dec(&dev->active_tx_urbs);"
    },
    {
        "line": 40,
        "fullcodeline": "msg->type = cf->can_id & CAN_EFF_FLAG ?"
    },
    {
        "line": 46,
        "fullcodeline": "msg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;"
    },
    {
        "line": 50,
        "fullcodeline": "if (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (err == -ENODEV) {"
    },
    {
        "line": 99,
        "fullcodeline": "netif_trans_update(netdev);"
    },
    {
        "line": 43,
        "fullcodeline": "for (i = 0; i < cf->len; i++)"
    },
    {
        "line": 51,
        "fullcodeline": "context = &dev->tx_contexts[i];"
    },
    {
        "line": 92,
        "fullcodeline": "netif_device_detach(netdev);"
    },
    {
        "line": 102,
        "fullcodeline": "if (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||"
    },
    {
        "line": 94,
        "fullcodeline": "netdev_warn(netdev, \"failed tx_urb %d\\n\", err);"
    },
    {
        "line": 96,
        "fullcodeline": "stats->tx_dropped++;"
    },
    {
        "line": 103,
        "fullcodeline": "dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {"
    },
    {
        "line": 104,
        "fullcodeline": "netif_stop_queue(netdev);"
    }
]