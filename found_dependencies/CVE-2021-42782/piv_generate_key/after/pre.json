[
    {
        "line": 5,
        "fullcodeline": "u8 rbuf[4096];"
    },
    {
        "line": 8,
        "fullcodeline": "u8 tagbuf[16];"
    },
    {
        "line": 9,
        "fullcodeline": "u8 outdata[3]; /* we could also add tag 81 for exponent */"
    },
    {
        "line": 15,
        "fullcodeline": "SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);"
    },
    {
        "line": 17,
        "fullcodeline": "keydata->exponent = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "keydata->pubkey = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "keydata->pubkey_len = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "keydata->ecparam = NULL; /* will show size as we only support 2 curves */"
    },
    {
        "line": 21,
        "fullcodeline": "keydata->ecparam_len = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "keydata->ecpoint = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "keydata->ecpoint_len = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "out_len = 3;"
    },
    {
        "line": 26,
        "fullcodeline": "outdata[0] = 0x80;"
    },
    {
        "line": 27,
        "fullcodeline": "outdata[1] = 0x01;"
    },
    {
        "line": 28,
        "fullcodeline": "outdata[2] = keydata->key_algid;"
    },
    {
        "line": 46,
        "fullcodeline": "p = tagbuf;"
    },
    {
        "line": 48,
        "fullcodeline": "r = sc_asn1_put_tag(0xAC, outdata, out_len, tagbuf, sizeof(tagbuf), &p);"
    },
    {
        "line": 54,
        "fullcodeline": "r = piv_general_io(card, 0x47, 0x00, keydata->key_num,"
    },
    {
        "line": 109,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, r);"
    },
    {
        "line": 49,
        "fullcodeline": "if (r != SC_SUCCESS) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (r >= 0) {"
    },
    {
        "line": 30,
        "fullcodeline": "case 0x05: keydata->key_bits = 3072; break;"
    },
    {
        "line": 31,
        "fullcodeline": "case 0x06: keydata->key_bits = 1024; break;"
    },
    {
        "line": 32,
        "fullcodeline": "case 0x07: keydata->key_bits = 2048; break;"
    },
    {
        "line": 34,
        "fullcodeline": "case 0x11: keydata->key_bits = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "keydata->ecparam =0; /* we only support prime256v1 for 11 */"
    },
    {
        "line": 36,
        "fullcodeline": "keydata->ecparam_len =0;"
    },
    {
        "line": 38,
        "fullcodeline": "case 0x14: keydata->key_bits = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "keydata->ecparam = 0; /* we only support secp384r1 */"
    },
    {
        "line": 40,
        "fullcodeline": "keydata->ecparam_len = 0;"
    },
    {
        "line": 43,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);"
    },
    {
        "line": 50,
        "fullcodeline": "sc_log(card->ctx, \"Failed to encode ASN1 tag\");"
    },
    {
        "line": 55,
        "fullcodeline": "tagbuf, p - tagbuf, rbuf, sizeof rbuf);"
    },
    {
        "line": 59,
        "fullcodeline": "keydata->exponent = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "cp = rbuf;"
    },
    {
        "line": 62,
        "fullcodeline": "in_len = r;"
    },
    {
        "line": 65,
        "fullcodeline": "r = sc_asn1_read_tag(&cp, in_len, &cla_out, &tag_out, &in_len);"
    },
    {
        "line": 105,
        "fullcodeline": "r = 0;"
    },
    {
        "line": 66,
        "fullcodeline": "if (cp == NULL || in_len == 0 || cla_out != 0x60 || tag_out != 0x1f49) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (r != SC_SUCCESS) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (keydata->key_bits > 0 ) {"
    },
    {
        "line": 67,
        "fullcodeline": "r = SC_ERROR_ASN1_OBJECT_NOT_FOUND;"
    },
    {
        "line": 70,
        "fullcodeline": "sc_log(card->ctx, \"Tag buffer not found\");"
    },
    {
        "line": 76,
        "fullcodeline": "tag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x82, &taglen);"
    },
    {
        "line": 83,
        "fullcodeline": "tag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x81, &taglen);"
    },
    {
        "line": 77,
        "fullcodeline": "if (tag != NULL && taglen <= 4) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (tag != NULL && taglen > 0) {"
    },
    {
        "line": 93,
        "fullcodeline": "tag = sc_asn1_find_tag(card->ctx, cp, in_len, 0x86, &taglen);"
    },
    {
        "line": 78,
        "fullcodeline": "keydata->exponent = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "keydata->pubkey = malloc(taglen);"
    },
    {
        "line": 88,
        "fullcodeline": "keydata->pubkey_len = taglen;"
    },
    {
        "line": 89,
        "fullcodeline": "memcpy (keydata->pubkey, tag, taglen);"
    },
    {
        "line": 94,
        "fullcodeline": "if (tag != NULL && taglen > 0) {"
    },
    {
        "line": 79,
        "fullcodeline": "for (i = 0; i < taglen;i++)"
    },
    {
        "line": 80,
        "fullcodeline": "keydata->exponent = (keydata->exponent<<8) + tag[i];"
    },
    {
        "line": 86,
        "fullcodeline": "if (keydata->pubkey == NULL)"
    },
    {
        "line": 95,
        "fullcodeline": "keydata->ecpoint = malloc(taglen);"
    },
    {
        "line": 98,
        "fullcodeline": "keydata->ecpoint_len = taglen;"
    },
    {
        "line": 99,
        "fullcodeline": "memcpy (keydata->ecpoint, tag, taglen);"
    },
    {
        "line": 87,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);"
    },
    {
        "line": 96,
        "fullcodeline": "if (keydata->ecpoint == NULL)"
    },
    {
        "line": 97,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);"
    }
]