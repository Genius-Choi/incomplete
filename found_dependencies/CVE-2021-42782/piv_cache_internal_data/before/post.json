[
    {
        "line": 3,
        "fullcodeline": "piv_private_data_t * priv = PIV_DATA(card);"
    },
    {
        "line": 8,
        "fullcodeline": "int compressed = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "body = sc_asn1_find_tag(card->ctx,"
    },
    {
        "line": 93,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);"
    },
    {
        "line": 25,
        "fullcodeline": "if (body == NULL)"
    },
    {
        "line": 29,
        "fullcodeline": "if (piv_objects[enumtag].flags & PIV_OBJECT_TYPE_CERT) {"
    },
    {
        "line": 17,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);"
    },
    {
        "line": 26,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_VALID);"
    },
    {
        "line": 31,
        "fullcodeline": "tag = sc_asn1_find_tag(card->ctx, body, bodylen, 0x71, &taglen);"
    },
    {
        "line": 37,
        "fullcodeline": "tag = sc_asn1_find_tag(card->ctx, body, bodylen, 0x70, &taglen);"
    },
    {
        "line": 34,
        "fullcodeline": "if (tag && taglen > 0 && (((*tag) & 0x80) || ((*tag) & 0x01)))"
    },
    {
        "line": 38,
        "fullcodeline": "if (tag == NULL)"
    },
    {
        "line": 41,
        "fullcodeline": "if (taglen == 0)"
    },
    {
        "line": 35,
        "fullcodeline": "compressed = 1;"
    },
    {
        "line": 39,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_VALID);"
    },
    {
        "line": 42,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_NOT_FOUND);"
    },
    {
        "line": 55,
        "fullcodeline": "sc_log(card->ctx, \"PIV compression not supported, no zlib\");"
    },
    {
        "line": 56,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);"
    },
    {
        "line": 70,
        "fullcodeline": "else if (piv_objects[enumtag].flags & PIV_OBJECT_TYPE_PUBKEY) {"
    },
    {
        "line": 63,
        "fullcodeline": "memcpy(priv->obj_cache[enumtag].internal_obj_data, tag, taglen);"
    },
    {
        "line": 64,
        "fullcodeline": "priv->obj_cache[enumtag].internal_obj_len = taglen;"
    },
    {
        "line": 71,
        "fullcodeline": "tag = sc_asn1_find_tag(card->ctx, body, bodylen, *body, &taglen);"
    },
    {
        "line": 81,
        "fullcodeline": "memcpy(priv->obj_cache[enumtag].internal_obj_data, tag, taglen);"
    },
    {
        "line": 82,
        "fullcodeline": "priv->obj_cache[enumtag].internal_obj_len = taglen;"
    },
    {
        "line": 60,
        "fullcodeline": "if (!(priv->obj_cache[enumtag].internal_obj_data = malloc(taglen)))"
    },
    {
        "line": 72,
        "fullcodeline": "if (tag == NULL)"
    },
    {
        "line": 75,
        "fullcodeline": "if (taglen == 0)"
    },
    {
        "line": 78,
        "fullcodeline": "if (!(priv->obj_cache[enumtag].internal_obj_data = malloc(taglen)))"
    },
    {
        "line": 85,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);"
    },
    {
        "line": 61,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);"
    },
    {
        "line": 73,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_VALID);"
    },
    {
        "line": 76,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_NOT_FOUND);"
    },
    {
        "line": 79,
        "fullcodeline": "LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);"
    }
]