[
    {
        "line": 3,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 4,
        "fullcodeline": "struct rose_sock *rose = rose_sk(sk);"
    },
    {
        "line": 11,
        "fullcodeline": "amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);"
    },
    {
        "line": 19,
        "fullcodeline": "long amount = 0L;"
    },
    {
        "line": 36,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 41,
        "fullcodeline": "if (!capable(CAP_NET_ADMIN))"
    },
    {
        "line": 43,
        "fullcodeline": "return rose_rt_ioctl(cmd, argp);"
    },
    {
        "line": 47,
        "fullcodeline": "rose_cause.cause      = rose->cause;"
    },
    {
        "line": 48,
        "fullcodeline": "rose_cause.diagnostic = rose->diagnostic;"
    },
    {
        "line": 56,
        "fullcodeline": "rose->cause      = rose_cause.cause;"
    },
    {
        "line": 57,
        "fullcodeline": "rose->diagnostic = rose_cause.diagnostic;"
    },
    {
        "line": 62,
        "fullcodeline": "if (!capable(CAP_NET_ADMIN)) return -EPERM;"
    },
    {
        "line": 63,
        "fullcodeline": "if (ax25cmp(&rose_callsign, &null_ax25_address) != 0)"
    },
    {
        "line": 65,
        "fullcodeline": "if (copy_from_user(&rose_callsign, argp, sizeof(ax25_address)))"
    },
    {
        "line": 67,
        "fullcodeline": "if (ax25cmp(&rose_callsign, &null_ax25_address) != 0)"
    },
    {
        "line": 73,
        "fullcodeline": "return copy_to_user(argp, &rose_callsign, sizeof(ax25_address)) ? -EFAULT : 0;"
    },
    {
        "line": 76,
        "fullcodeline": "if (rose->state == ROSE_STATE_5) {"
    },
    {
        "line": 89,
        "fullcodeline": "return -ENOIOCTLCMD;"
    },
    {
        "line": 12,
        "fullcodeline": "if (amount < 0)"
    },
    {
        "line": 21,
        "fullcodeline": "if ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)"
    },
    {
        "line": 49,
        "fullcodeline": "return copy_to_user(argp, &rose_cause, sizeof(struct rose_cause_struct)) ? -EFAULT : 0;"
    },
    {
        "line": 54,
        "fullcodeline": "if (copy_from_user(&rose_cause, argp, sizeof(struct rose_cause_struct)))"
    },
    {
        "line": 64,
        "fullcodeline": "ax25_listen_release(&rose_callsign, NULL);"
    },
    {
        "line": 77,
        "fullcodeline": "rose_write_internal(sk, ROSE_CALL_ACCEPTED);"
    },
    {
        "line": 78,
        "fullcodeline": "rose_start_idletimer(sk);"
    },
    {
        "line": 79,
        "fullcodeline": "rose->condition = 0x00;"
    },
    {
        "line": 80,
        "fullcodeline": "rose->vs        = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "rose->va        = 0;"
    },
    {
        "line": 82,
        "fullcodeline": "rose->vr        = 0;"
    },
    {
        "line": 83,
        "fullcodeline": "rose->vl        = 0;"
    },
    {
        "line": 84,
        "fullcodeline": "rose->state     = ROSE_STATE_3;"
    },
    {
        "line": 13,
        "fullcodeline": "amount = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "amount = skb->len;"
    },
    {
        "line": 42,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 66,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 68,
        "fullcodeline": "return ax25_listen_register(&rose_callsign, NULL);"
    },
    {
        "line": 55,
        "fullcodeline": "return -EFAULT;"
    }
]