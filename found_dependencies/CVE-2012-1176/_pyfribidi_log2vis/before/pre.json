[
    {
        "line": 3,
        "fullcodeline": "PyObject *logical = NULL;\t/* input unicode or string object */"
    },
    {
        "line": 4,
        "fullcodeline": "FriBidiParType base = FRIBIDI_TYPE_RTL;\t/* optional direction */"
    },
    {
        "line": 5,
        "fullcodeline": "const char *encoding = \"utf-8\";\t/* optional input string encoding */"
    },
    {
        "line": 6,
        "fullcodeline": "int clean = 0; /* optional flag to clean the string */"
    },
    {
        "line": 7,
        "fullcodeline": "int reordernsm = 1; /* optional flag to allow reordering of non spacing marks*/"
    },
    {
        "line": 9,
        "fullcodeline": "static char *kwargs[] ="
    },
    {
        "line": 10,
        "fullcodeline": "{ \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };"
    },
    {
        "line": 12,
        "fullcodeline": "if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,"
    },
    {
        "line": 26,
        "fullcodeline": "if (PyUnicode_Check (logical))"
    },
    {
        "line": 18,
        "fullcodeline": "if (!(base == FRIBIDI_TYPE_RTL ||"
    },
    {
        "line": 19,
        "fullcodeline": "base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))"
    },
    {
        "line": 20,
        "fullcodeline": "return PyErr_Format (PyExc_ValueError,"
    },
    {
        "line": 27,
        "fullcodeline": "return log2vis_unicode (logical, base, clean, reordernsm);"
    },
    {
        "line": 28,
        "fullcodeline": "else if (PyString_Check (logical))"
    },
    {
        "line": 29,
        "fullcodeline": "return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);"
    },
    {
        "line": 31,
        "fullcodeline": "return PyErr_Format (PyExc_TypeError,"
    }
]