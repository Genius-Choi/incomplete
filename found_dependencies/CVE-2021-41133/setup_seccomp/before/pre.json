[
    {
        "line": 7,
        "fullcodeline": "gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;"
    },
    {
        "line": 8,
        "fullcodeline": "gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;"
    },
    {
        "line": 10,
        "fullcodeline": "__attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "} syscall_blocklist[] = {"
    },
    {
        "line": 115,
        "fullcodeline": "} syscall_nondevel_blocklist[] = {"
    },
    {
        "line": 129,
        "fullcodeline": "} socket_family_allowlist[] = {"
    },
    {
        "line": 143,
        "fullcodeline": "seccomp = seccomp_init (SCMP_ACT_ALLOW);"
    },
    {
        "line": 240,
        "fullcodeline": "last_allowed_family = -1;"
    },
    {
        "line": 258,
        "fullcodeline": "seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));"
    },
    {
        "line": 266,
        "fullcodeline": "lseek (seccomp_tmpf.fd, 0, SEEK_SET);"
    },
    {
        "line": 144,
        "fullcodeline": "if (!seccomp)"
    },
    {
        "line": 147,
        "fullcodeline": "if (arch != NULL)"
    },
    {
        "line": 203,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)"
    },
    {
        "line": 241,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)"
    },
    {
        "line": 269,
        "fullcodeline": "\"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);"
    },
    {
        "line": 52,
        "fullcodeline": "{SCMP_SYS (syslog), EPERM},"
    },
    {
        "line": 54,
        "fullcodeline": "{SCMP_SYS (uselib), EPERM},"
    },
    {
        "line": 56,
        "fullcodeline": "{SCMP_SYS (acct), EPERM},"
    },
    {
        "line": 59,
        "fullcodeline": "{SCMP_SYS (modify_ldt), EPERM},"
    },
    {
        "line": 61,
        "fullcodeline": "{SCMP_SYS (quotactl), EPERM},"
    },
    {
        "line": 64,
        "fullcodeline": "{SCMP_SYS (add_key), EPERM},"
    },
    {
        "line": 65,
        "fullcodeline": "{SCMP_SYS (keyctl), EPERM},"
    },
    {
        "line": 66,
        "fullcodeline": "{SCMP_SYS (request_key), EPERM},"
    },
    {
        "line": 69,
        "fullcodeline": "{SCMP_SYS (move_pages), EPERM},"
    },
    {
        "line": 70,
        "fullcodeline": "{SCMP_SYS (mbind), EPERM},"
    },
    {
        "line": 71,
        "fullcodeline": "{SCMP_SYS (get_mempolicy), EPERM},"
    },
    {
        "line": 72,
        "fullcodeline": "{SCMP_SYS (set_mempolicy), EPERM},"
    },
    {
        "line": 73,
        "fullcodeline": "{SCMP_SYS (migrate_pages), EPERM},"
    },
    {
        "line": 76,
        "fullcodeline": "{SCMP_SYS (unshare), EPERM},"
    },
    {
        "line": 77,
        "fullcodeline": "{SCMP_SYS (mount), EPERM},"
    },
    {
        "line": 78,
        "fullcodeline": "{SCMP_SYS (pivot_root), EPERM},"
    },
    {
        "line": 85,
        "fullcodeline": "{SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},"
    },
    {
        "line": 89,
        "fullcodeline": "{SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},"
    },
    {
        "line": 95,
        "fullcodeline": "{SCMP_SYS (clone3), ENOSYS},"
    },
    {
        "line": 101,
        "fullcodeline": "{SCMP_SYS (open_tree), ENOSYS},"
    },
    {
        "line": 102,
        "fullcodeline": "{SCMP_SYS (move_mount), ENOSYS},"
    },
    {
        "line": 103,
        "fullcodeline": "{SCMP_SYS (fsopen), ENOSYS},"
    },
    {
        "line": 104,
        "fullcodeline": "{SCMP_SYS (fsconfig), ENOSYS},"
    },
    {
        "line": 105,
        "fullcodeline": "{SCMP_SYS (fsmount), ENOSYS},"
    },
    {
        "line": 106,
        "fullcodeline": "{SCMP_SYS (fspick), ENOSYS},"
    },
    {
        "line": 107,
        "fullcodeline": "{SCMP_SYS (mount_setattr), ENOSYS},"
    },
    {
        "line": 119,
        "fullcodeline": "{SCMP_SYS (perf_event_open), EPERM},"
    },
    {
        "line": 121,
        "fullcodeline": "{SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},"
    },
    {
        "line": 122,
        "fullcodeline": "{SCMP_SYS (ptrace), EPERM}"
    },
    {
        "line": 131,
        "fullcodeline": "{ AF_UNSPEC, 0 },"
    },
    {
        "line": 132,
        "fullcodeline": "{ AF_LOCAL, 0 },"
    },
    {
        "line": 133,
        "fullcodeline": "{ AF_INET, 0 },"
    },
    {
        "line": 134,
        "fullcodeline": "{ AF_INET6, 0 },"
    },
    {
        "line": 135,
        "fullcodeline": "{ AF_NETLINK, 0 },"
    },
    {
        "line": 136,
        "fullcodeline": "{ AF_CAN, FLATPAK_RUN_FLAG_CANBUS },"
    },
    {
        "line": 137,
        "fullcodeline": "{ AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },"
    },
    {
        "line": 149,
        "fullcodeline": "uint32_t arch_id = 0;"
    },
    {
        "line": 150,
        "fullcodeline": "const uint32_t *extra_arches = NULL;"
    },
    {
        "line": 205,
        "fullcodeline": "int scall = syscall_blocklist[i].scall;"
    },
    {
        "line": 206,
        "fullcodeline": "int errnum = syscall_blocklist[i].errnum;"
    },
    {
        "line": 208,
        "fullcodeline": "g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);"
    },
    {
        "line": 243,
        "fullcodeline": "int family = socket_family_allowlist[i].family;"
    },
    {
        "line": 255,
        "fullcodeline": "last_allowed_family = family;"
    },
    {
        "line": 260,
        "fullcodeline": "if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))"
    },
    {
        "line": 263,
        "fullcodeline": "if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)"
    },
    {
        "line": 145,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));"
    },
    {
        "line": 175,
        "fullcodeline": "if (arch_id != 0)"
    },
    {
        "line": 214,
        "fullcodeline": "if (r < 0 && r == -EFAULT /* unknown syscall */)"
    },
    {
        "line": 220,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)"
    },
    {
        "line": 250,
        "fullcodeline": "for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)"
    },
    {
        "line": 264,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));"
    },
    {
        "line": 152,
        "fullcodeline": "if (strcmp (arch, \"i386\") == 0)"
    },
    {
        "line": 154,
        "fullcodeline": "arch_id = SCMP_ARCH_X86;"
    },
    {
        "line": 182,
        "fullcodeline": "r = seccomp_arch_add (seccomp, arch_id);"
    },
    {
        "line": 211,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);"
    },
    {
        "line": 222,
        "fullcodeline": "int scall = syscall_nondevel_blocklist[i].scall;"
    },
    {
        "line": 223,
        "fullcodeline": "int errnum = syscall_nondevel_blocklist[i].errnum;"
    },
    {
        "line": 225,
        "fullcodeline": "g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);"
    },
    {
        "line": 246,
        "fullcodeline": "if (socket_family_allowlist[i].flags_mask != 0 &&"
    },
    {
        "line": 247,
        "fullcodeline": "(socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)"
    },
    {
        "line": 253,
        "fullcodeline": "seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));"
    },
    {
        "line": 183,
        "fullcodeline": "if (r < 0 && r != -EEXIST)"
    },
    {
        "line": 213,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);"
    },
    {
        "line": 215,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);"
    },
    {
        "line": 186,
        "fullcodeline": "if (multiarch && extra_arches != NULL)"
    },
    {
        "line": 228,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);"
    },
    {
        "line": 232,
        "fullcodeline": "if (r < 0 && r == -EFAULT /* unknown syscall */)"
    },
    {
        "line": 156,
        "fullcodeline": "else if (strcmp (arch, \"x86_64\") == 0)"
    },
    {
        "line": 158,
        "fullcodeline": "arch_id = SCMP_ARCH_X86_64;"
    },
    {
        "line": 159,
        "fullcodeline": "extra_arches = seccomp_x86_64_extra_arches;"
    },
    {
        "line": 184,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));"
    },
    {
        "line": 188,
        "fullcodeline": "for (i = 0; extra_arches[i] != 0; i++)"
    },
    {
        "line": 230,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);"
    },
    {
        "line": 233,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);"
    },
    {
        "line": 190,
        "fullcodeline": "r = seccomp_arch_add (seccomp, extra_arches[i]);"
    },
    {
        "line": 161,
        "fullcodeline": "else if (strcmp (arch, \"arm\") == 0)"
    },
    {
        "line": 163,
        "fullcodeline": "arch_id = SCMP_ARCH_ARM;"
    },
    {
        "line": 191,
        "fullcodeline": "if (r < 0 && r != -EEXIST)"
    },
    {
        "line": 192,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));"
    }
]