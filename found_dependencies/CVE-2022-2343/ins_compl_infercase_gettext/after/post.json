[
    {
        "line": 11,
        "fullcodeline": "int\t\thas_lower = FALSE;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\twas_letter = FALSE;"
    },
    {
        "line": 15,
        "fullcodeline": "IObuff[0] = NUL;"
    },
    {
        "line": 22,
        "fullcodeline": "p = str;"
    },
    {
        "line": 30,
        "fullcodeline": "p = compl_orig_text;"
    },
    {
        "line": 73,
        "fullcodeline": "p = compl_orig_text;"
    },
    {
        "line": 87,
        "fullcodeline": "p = IObuff;"
    },
    {
        "line": 88,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "ga_init2(&gap, 1, 500);"
    },
    {
        "line": 124,
        "fullcodeline": "vim_free(wca);"
    },
    {
        "line": 132,
        "fullcodeline": "*p = NUL;"
    },
    {
        "line": 19,
        "fullcodeline": "if (wca == NULL)"
    },
    {
        "line": 23,
        "fullcodeline": "for (i = 0; i < char_len; ++i)"
    },
    {
        "line": 31,
        "fullcodeline": "for (i = 0; i < min_len; ++i)"
    },
    {
        "line": 52,
        "fullcodeline": "if (!has_lower)"
    },
    {
        "line": 74,
        "fullcodeline": "for (i = 0; i < min_len; ++i)"
    },
    {
        "line": 90,
        "fullcodeline": "while (i < char_len)"
    },
    {
        "line": 126,
        "fullcodeline": "if (gap.ga_data != NULL)"
    },
    {
        "line": 54,
        "fullcodeline": "p = compl_orig_text;"
    },
    {
        "line": 128,
        "fullcodeline": "*tofree = gap.ga_data;"
    },
    {
        "line": 25,
        "fullcodeline": "wca[i] = mb_ptr2char_adv(&p);"
    },
    {
        "line": 37,
        "fullcodeline": "if (MB_ISLOWER(c))"
    },
    {
        "line": 55,
        "fullcodeline": "for (i = 0; i < min_len; ++i)"
    },
    {
        "line": 80,
        "fullcodeline": "if (MB_ISLOWER(c))"
    },
    {
        "line": 92,
        "fullcodeline": "if (gap.ga_data != NULL)"
    },
    {
        "line": 34,
        "fullcodeline": "c = mb_ptr2char_adv(&p);"
    },
    {
        "line": 39,
        "fullcodeline": "has_lower = TRUE;"
    },
    {
        "line": 68,
        "fullcodeline": "was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);"
    },
    {
        "line": 77,
        "fullcodeline": "c = mb_ptr2char_adv(&p);"
    },
    {
        "line": 81,
        "fullcodeline": "wca[i] = MB_TOLOWER(wca[i]);"
    },
    {
        "line": 99,
        "fullcodeline": "p = (char_u *)gap.ga_data + gap.ga_len;"
    },
    {
        "line": 40,
        "fullcodeline": "if (MB_ISUPPER(wca[i]))"
    },
    {
        "line": 61,
        "fullcodeline": "if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))"
    },
    {
        "line": 94,
        "fullcodeline": "if (ga_grow(&gap, 10) == FAIL)"
    },
    {
        "line": 27,
        "fullcodeline": "wca[i] = *(p++);"
    },
    {
        "line": 58,
        "fullcodeline": "c = mb_ptr2char_adv(&p);"
    },
    {
        "line": 82,
        "fullcodeline": "else if (MB_ISUPPER(c))"
    },
    {
        "line": 96,
        "fullcodeline": "ga_clear(&gap);"
    },
    {
        "line": 101,
        "fullcodeline": "gap.ga_len += (*mb_char2bytes)(wca[i++], p);"
    },
    {
        "line": 108,
        "fullcodeline": "else if ((p - IObuff) + 6 >= IOSIZE)"
    },
    {
        "line": 36,
        "fullcodeline": "c = *(p++);"
    },
    {
        "line": 43,
        "fullcodeline": "for (i = compl_char_len; i < char_len; ++i)"
    },
    {
        "line": 44,
        "fullcodeline": "wca[i] = MB_TOLOWER(wca[i]);"
    },
    {
        "line": 64,
        "fullcodeline": "for (i = compl_char_len; i < char_len; ++i)"
    },
    {
        "line": 65,
        "fullcodeline": "wca[i] = MB_TOUPPER(wca[i]);"
    },
    {
        "line": 79,
        "fullcodeline": "c = *(p++);"
    },
    {
        "line": 83,
        "fullcodeline": "wca[i] = MB_TOUPPER(wca[i]);"
    },
    {
        "line": 97,
        "fullcodeline": "return (char_u *)\"[failed]\";"
    },
    {
        "line": 104,
        "fullcodeline": "*p = wca[i++];"
    },
    {
        "line": 105,
        "fullcodeline": "++gap.ga_len;"
    },
    {
        "line": 116,
        "fullcodeline": "STRCPY(gap.ga_data, IObuff);"
    },
    {
        "line": 117,
        "fullcodeline": "gap.ga_len = STRLEN(IObuff);"
    },
    {
        "line": 114,
        "fullcodeline": "if (ga_grow(&gap, IOSIZE) == FAIL)"
    },
    {
        "line": 60,
        "fullcodeline": "c = *(p++);"
    },
    {
        "line": 115,
        "fullcodeline": "return (char_u *)\"[failed]\";"
    },
    {
        "line": 120,
        "fullcodeline": "p += (*mb_char2bytes)(wca[i++], p);"
    },
    {
        "line": 122,
        "fullcodeline": "*(p++) = wca[i++];"
    }
]