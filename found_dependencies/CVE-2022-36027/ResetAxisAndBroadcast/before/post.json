[
    {
        "line": 4,
        "fullcodeline": "auto shaped = target.dyn_cast<RankedTensorType>();"
    },
    {
        "line": 6,
        "fullcodeline": "ArrayRef<int64_t> new_shape = shaped.getShape();"
    },
    {
        "line": 8,
        "fullcodeline": "SmallVector<double, 4> scales(qtype.getScales().begin(),"
    },
    {
        "line": 10,
        "fullcodeline": "SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),"
    },
    {
        "line": 5,
        "fullcodeline": "if (!shaped) return {};"
    },
    {
        "line": 9,
        "fullcodeline": "qtype.getScales().end());"
    },
    {
        "line": 13,
        "fullcodeline": "if (new_shape.size() == shape.size()) {  // same rank"
    },
    {
        "line": 41,
        "fullcodeline": "return quant::UniformQuantizedPerAxisType::get("
    },
    {
        "line": 42,
        "fullcodeline": "qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),"
    },
    {
        "line": 43,
        "fullcodeline": "scales, zero_points, quant_dim, qtype.getStorageTypeMin(),"
    },
    {
        "line": 44,
        "fullcodeline": "qtype.getStorageTypeMax());"
    },
    {
        "line": 11,
        "fullcodeline": "qtype.getZeroPoints().end());"
    },
    {
        "line": 25,
        "fullcodeline": "if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||"
    },
    {
        "line": 26,
        "fullcodeline": "BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {"
    },
    {
        "line": 29,
        "fullcodeline": "} else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&"
    },
    {
        "line": 32,
        "fullcodeline": "quant_dim == -1) {"
    },
    {
        "line": 33,
        "fullcodeline": "quant_dim = shape.size() + quant_dim;"
    }
]