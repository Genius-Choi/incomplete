[
    {
        "line": 4,
        "fullcodeline": "x3f_directory_entry_header_t *DEH = &DE->header;"
    },
    {
        "line": 6,
        "fullcodeline": "x3f_huffman_t *HUF = ID->huffman;"
    },
    {
        "line": 8,
        "fullcodeline": "int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};"
    },
    {
        "line": 14,
        "fullcodeline": "set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);"
    },
    {
        "line": 12,
        "fullcodeline": "if (HUF->row_offsets.element[row] > ID->data_size - 1)"
    },
    {
        "line": 16,
        "fullcodeline": "for (col = 0; col < ID->columns; col++)"
    },
    {
        "line": 20,
        "fullcodeline": "for (color = 0; color < 3; color++)"
    },
    {
        "line": 24,
        "fullcodeline": "c[color] += get_huffman_diff(&BS, &HUF->tree);"
    },
    {
        "line": 25,
        "fullcodeline": "if (c[color] < 0)"
    },
    {
        "line": 27,
        "fullcodeline": "c_fix = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] ="
    },
    {
        "line": 44,
        "fullcodeline": "HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;"
    },
    {
        "line": 28,
        "fullcodeline": "if (c[color] < *minimum)"
    },
    {
        "line": 33,
        "fullcodeline": "c_fix = c[color];"
    },
    {
        "line": 41,
        "fullcodeline": "(uint16_t)c_fix;"
    },
    {
        "line": 29,
        "fullcodeline": "*minimum = c[color];"
    }
]