[
    {
        "line": 4,
        "fullcodeline": "const char *s = *startPtr;"
    },
    {
        "line": 15,
        "fullcodeline": "*eventPP = s;"
    },
    {
        "line": 16,
        "fullcodeline": "*startPtr = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "if (enc == parser->m_encoding) {"
    },
    {
        "line": 8,
        "fullcodeline": "eventPP = &parser->m_eventPtr;"
    },
    {
        "line": 10,
        "fullcodeline": "eventEndPP = &parser->m_eventEndPtr;"
    },
    {
        "line": 19,
        "fullcodeline": "const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */"
    },
    {
        "line": 20,
        "fullcodeline": "int tok = XmlCdataSectionTok(enc, s, end, &next);"
    },
    {
        "line": 27,
        "fullcodeline": "UNUSED_P(account);"
    },
    {
        "line": 29,
        "fullcodeline": "*eventEndPP = next;"
    },
    {
        "line": 106,
        "fullcodeline": "*eventPP = s = next;"
    },
    {
        "line": 12,
        "fullcodeline": "eventPP = &(parser->m_openInternalEntities->internalEventPtr);"
    },
    {
        "line": 13,
        "fullcodeline": "eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);"
    },
    {
        "line": 42,
        "fullcodeline": "*startPtr = next;"
    },
    {
        "line": 43,
        "fullcodeline": "*nextPtr = next;"
    },
    {
        "line": 44,
        "fullcodeline": "if (parser->m_parsingStatus.parsing == XML_FINISHED)"
    },
    {
        "line": 56,
        "fullcodeline": "XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;"
    },
    {
        "line": 33,
        "fullcodeline": "parser->m_endCdataSectionHandler(parser->m_handlerArg);"
    },
    {
        "line": 50,
        "fullcodeline": "XML_Char c = 0xA;"
    },
    {
        "line": 51,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);"
    },
    {
        "line": 36,
        "fullcodeline": "else if ((0) && parser->m_characterDataHandler)"
    },
    {
        "line": 58,
        "fullcodeline": "if (MUST_CONVERT(enc, s)) {"
    },
    {
        "line": 37,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,"
    },
    {
        "line": 53,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 72,
        "fullcodeline": "charDataHandler(parser->m_handlerArg, (const XML_Char *)s,"
    },
    {
        "line": 75,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 60,
        "fullcodeline": "ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;"
    },
    {
        "line": 61,
        "fullcodeline": "const enum XML_Convert_Result convert_res = XmlConvert("
    },
    {
        "line": 64,
        "fullcodeline": "charDataHandler(parser->m_handlerArg, parser->m_dataBuf,"
    },
    {
        "line": 69,
        "fullcodeline": "*eventPP = s;"
    },
    {
        "line": 73,
        "fullcodeline": "(int)((const XML_Char *)next - (const XML_Char *)s));"
    },
    {
        "line": 41,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 65,
        "fullcodeline": "(int)(dataPtr - (ICHAR *)parser->m_dataBuf));"
    },
    {
        "line": 66,
        "fullcodeline": "if ((convert_res == XML_CONVERT_COMPLETED)"
    },
    {
        "line": 62,
        "fullcodeline": "enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);"
    },
    {
        "line": 67,
        "fullcodeline": "|| (convert_res == XML_CONVERT_INPUT_INCOMPLETE))"
    }
]