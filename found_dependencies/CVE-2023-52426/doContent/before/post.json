[
    {
        "line": 5,
        "fullcodeline": "DTD *const dtd = parser->m_dtd;"
    },
    {
        "line": 16,
        "fullcodeline": "*eventPP = s;"
    },
    {
        "line": 9,
        "fullcodeline": "if (enc == parser->m_encoding) {"
    },
    {
        "line": 10,
        "fullcodeline": "eventPP = &parser->m_eventPtr;"
    },
    {
        "line": 11,
        "fullcodeline": "eventEndPP = &parser->m_eventEndPtr;"
    },
    {
        "line": 19,
        "fullcodeline": "const char *next = s; /* XmlContentTok doesn't always set the last arg */"
    },
    {
        "line": 20,
        "fullcodeline": "int tok = XmlContentTok(enc, s, end, &next);"
    },
    {
        "line": 32,
        "fullcodeline": "*eventEndPP = next;"
    },
    {
        "line": 457,
        "fullcodeline": "*eventPP = s = next;"
    },
    {
        "line": 39,
        "fullcodeline": "*eventEndPP = end;"
    },
    {
        "line": 52,
        "fullcodeline": "*nextPtr = end;"
    },
    {
        "line": 67,
        "fullcodeline": "*eventPP = next;"
    },
    {
        "line": 412,
        "fullcodeline": "*nextPtr = end;"
    },
    {
        "line": 460,
        "fullcodeline": "*nextPtr = next;"
    },
    {
        "line": 48,
        "fullcodeline": "if (startTagLevel == 0)"
    },
    {
        "line": 50,
        "fullcodeline": "if (parser->m_tagLevel != startTagLevel)"
    },
    {
        "line": 59,
        "fullcodeline": "if (startTagLevel > 0) {"
    },
    {
        "line": 84,
        "fullcodeline": "XML_Char ch = (XML_Char)XmlPredefinedEntityName("
    },
    {
        "line": 101,
        "fullcodeline": "name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,"
    },
    {
        "line": 105,
        "fullcodeline": "entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);"
    },
    {
        "line": 106,
        "fullcodeline": "poolDiscard(&dtd->pool);"
    },
    {
        "line": 176,
        "fullcodeline": "tag->bindings = NULL;"
    },
    {
        "line": 177,
        "fullcodeline": "tag->parent = parser->m_tagStack;"
    },
    {
        "line": 178,
        "fullcodeline": "parser->m_tagStack = tag;"
    },
    {
        "line": 179,
        "fullcodeline": "tag->name.localPart = NULL;"
    },
    {
        "line": 180,
        "fullcodeline": "tag->name.prefix = NULL;"
    },
    {
        "line": 181,
        "fullcodeline": "tag->rawName = s + enc->minBytesPerChar;"
    },
    {
        "line": 182,
        "fullcodeline": "tag->rawNameLength = XmlNameLength(enc, tag->rawName);"
    },
    {
        "line": 183,
        "fullcodeline": "++parser->m_tagLevel;"
    },
    {
        "line": 211,
        "fullcodeline": "tag->name.str = (XML_Char *)tag->buf;"
    },
    {
        "line": 212,
        "fullcodeline": "*toPtr = XML_T('\\0');"
    },
    {
        "line": 213,
        "fullcodeline": "result"
    },
    {
        "line": 222,
        "fullcodeline": "poolClear(&parser->m_tempPool);"
    },
    {
        "line": 228,
        "fullcodeline": "const char *rawName = s + enc->minBytesPerChar;"
    },
    {
        "line": 230,
        "fullcodeline": "BINDING *bindings = NULL;"
    },
    {
        "line": 231,
        "fullcodeline": "XML_Bool noElmHandlers = XML_TRUE;"
    },
    {
        "line": 233,
        "fullcodeline": "name.str = poolStoreString(&parser->m_tempPool, enc, rawName,"
    },
    {
        "line": 237,
        "fullcodeline": "poolFinish(&parser->m_tempPool);"
    },
    {
        "line": 238,
        "fullcodeline": "result = storeAtts(parser, enc, s, &name, &bindings,"
    },
    {
        "line": 244,
        "fullcodeline": "poolFinish(&parser->m_tempPool);"
    },
    {
        "line": 258,
        "fullcodeline": "poolClear(&parser->m_tempPool);"
    },
    {
        "line": 259,
        "fullcodeline": "freeBindings(parser, bindings);"
    },
    {
        "line": 261,
        "fullcodeline": "if ((parser->m_tagLevel == 0)"
    },
    {
        "line": 270,
        "fullcodeline": "if (parser->m_tagLevel == startTagLevel)"
    },
    {
        "line": 332,
        "fullcodeline": "int n = XmlCharRefNumber(enc, s);"
    },
    {
        "line": 374,
        "fullcodeline": "result"
    },
    {
        "line": 404,
        "fullcodeline": "if (startTagLevel == 0) {"
    },
    {
        "line": 408,
        "fullcodeline": "if (parser->m_tagLevel != startTagLevel) {"
    },
    {
        "line": 415,
        "fullcodeline": "XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;"
    },
    {
        "line": 437,
        "fullcodeline": "if (! reportProcessingInstruction(parser, enc, s, next))"
    },
    {
        "line": 441,
        "fullcodeline": "if (! reportComment(parser, enc, s, next))"
    },
    {
        "line": 36,
        "fullcodeline": "*nextPtr = s;"
    },
    {
        "line": 41,
        "fullcodeline": "XML_Char c = 0xA;"
    },
    {
        "line": 42,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);"
    },
    {
        "line": 56,
        "fullcodeline": "*nextPtr = s;"
    },
    {
        "line": 62,
        "fullcodeline": "*nextPtr = s;"
    },
    {
        "line": 71,
        "fullcodeline": "*nextPtr = s;"
    },
    {
        "line": 77,
        "fullcodeline": "*nextPtr = s;"
    },
    {
        "line": 103,
        "fullcodeline": "if (! name)"
    },
    {
        "line": 111,
        "fullcodeline": "if (! dtd->hasParamEntityRefs || dtd->standalone) {"
    },
    {
        "line": 185,
        "fullcodeline": "const char *rawNameEnd = tag->rawName + tag->rawNameLength;"
    },
    {
        "line": 186,
        "fullcodeline": "const char *fromPtr = tag->rawName;"
    },
    {
        "line": 187,
        "fullcodeline": "toPtr = (XML_Char *)tag->buf;"
    },
    {
        "line": 214,
        "fullcodeline": "= storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);"
    },
    {
        "line": 235,
        "fullcodeline": "if (! name.str)"
    },
    {
        "line": 240,
        "fullcodeline": "if (result != XML_ERROR_NONE) {"
    },
    {
        "line": 256,
        "fullcodeline": "if (noElmHandlers && parser->m_defaultHandler)"
    },
    {
        "line": 262,
        "fullcodeline": "&& (parser->m_parsingStatus.parsing != XML_FINISHED)) {"
    },
    {
        "line": 333,
        "fullcodeline": "if (n < 0)"
    },
    {
        "line": 346,
        "fullcodeline": "XML_Char c = 0xA;"
    },
    {
        "line": 347,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);"
    },
    {
        "line": 375,
        "fullcodeline": "= doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);"
    },
    {
        "line": 376,
        "fullcodeline": "if (result != XML_ERROR_NONE)"
    },
    {
        "line": 385,
        "fullcodeline": "*nextPtr = s;"
    },
    {
        "line": 405,
        "fullcodeline": "*eventPP = end;"
    },
    {
        "line": 409,
        "fullcodeline": "*eventPP = end;"
    },
    {
        "line": 453,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 60,
        "fullcodeline": "if (parser->m_tagLevel != startTagLevel)"
    },
    {
        "line": 102,
        "fullcodeline": "next - enc->minBytesPerChar);"
    },
    {
        "line": 137,
        "fullcodeline": "result = processInternalEntity(parser, entity, XML_FALSE);"
    },
    {
        "line": 163,
        "fullcodeline": "tag = parser->m_freeTagList;"
    },
    {
        "line": 218,
        "fullcodeline": "parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,"
    },
    {
        "line": 234,
        "fullcodeline": "rawName + XmlNameLength(enc, rawName));"
    },
    {
        "line": 241,
        "fullcodeline": "freeBindings(parser, bindings);"
    },
    {
        "line": 246,
        "fullcodeline": "parser->m_startElementHandler(parser->m_handlerArg, name.str,"
    },
    {
        "line": 248,
        "fullcodeline": "noElmHandlers = XML_FALSE;"
    },
    {
        "line": 253,
        "fullcodeline": "parser->m_endElementHandler(parser->m_handlerArg, name.str);"
    },
    {
        "line": 254,
        "fullcodeline": "noElmHandlers = XML_FALSE;"
    },
    {
        "line": 257,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 263,
        "fullcodeline": "if (parser->m_parsingStatus.parsing == XML_SUSPENDED)"
    },
    {
        "line": 275,
        "fullcodeline": "TAG *tag = parser->m_tagStack;"
    },
    {
        "line": 276,
        "fullcodeline": "rawName = s + enc->minBytesPerChar * 2;"
    },
    {
        "line": 277,
        "fullcodeline": "len = XmlNameLength(enc, rawName);"
    },
    {
        "line": 283,
        "fullcodeline": "parser->m_tagStack = tag->parent;"
    },
    {
        "line": 284,
        "fullcodeline": "tag->parent = parser->m_freeTagList;"
    },
    {
        "line": 285,
        "fullcodeline": "parser->m_freeTagList = tag;"
    },
    {
        "line": 286,
        "fullcodeline": "--parser->m_tagLevel;"
    },
    {
        "line": 336,
        "fullcodeline": "XML_Char buf[XML_ENCODE_MAX];"
    },
    {
        "line": 337,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, buf,"
    },
    {
        "line": 354,
        "fullcodeline": "parser->m_startCdataSectionHandler(parser->m_handlerArg);"
    },
    {
        "line": 389,
        "fullcodeline": "if (MUST_CONVERT(enc, s)) {"
    },
    {
        "line": 85,
        "fullcodeline": "enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);"
    },
    {
        "line": 112,
        "fullcodeline": "if (! entity)"
    },
    {
        "line": 129,
        "fullcodeline": "if (! parser->m_defaultExpandInternalEntities) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (result != XML_ERROR_NONE)"
    },
    {
        "line": 166,
        "fullcodeline": "tag = (TAG *)MALLOC(parser, sizeof(TAG));"
    },
    {
        "line": 169,
        "fullcodeline": "tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);"
    },
    {
        "line": 174,
        "fullcodeline": "tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;"
    },
    {
        "line": 191,
        "fullcodeline": "const enum XML_Convert_Result convert_res"
    },
    {
        "line": 194,
        "fullcodeline": "convLen = (int)(toPtr - (XML_Char *)tag->buf);"
    },
    {
        "line": 200,
        "fullcodeline": "bufSize = (int)(tag->bufEnd - tag->buf) << 1;"
    },
    {
        "line": 219,
        "fullcodeline": "(const XML_Char **)parser->m_atts);"
    },
    {
        "line": 247,
        "fullcodeline": "(const XML_Char **)parser->m_atts);"
    },
    {
        "line": 264,
        "fullcodeline": "parser->m_processor = epilogProcessor;"
    },
    {
        "line": 278,
        "fullcodeline": "if (len != tag->rawNameLength"
    },
    {
        "line": 322,
        "fullcodeline": "if ((parser->m_tagLevel == 0)"
    },
    {
        "line": 338,
        "fullcodeline": "XmlEncode(n, (ICHAR *)buf));"
    },
    {
        "line": 390,
        "fullcodeline": "ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;"
    },
    {
        "line": 391,
        "fullcodeline": "XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);"
    },
    {
        "line": 392,
        "fullcodeline": "parser->m_characterDataHandler("
    },
    {
        "line": 417,
        "fullcodeline": "if (MUST_CONVERT(enc, s)) {"
    },
    {
        "line": 44,
        "fullcodeline": "reportDefault(parser, enc, s, end);"
    },
    {
        "line": 96,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);"
    },
    {
        "line": 116,
        "fullcodeline": "} else if (! entity) {"
    },
    {
        "line": 167,
        "fullcodeline": "if (! tag)"
    },
    {
        "line": 170,
        "fullcodeline": "if (! tag->buf) {"
    },
    {
        "line": 192,
        "fullcodeline": "= XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,"
    },
    {
        "line": 195,
        "fullcodeline": "if ((fromPtr >= rawNameEnd)"
    },
    {
        "line": 202,
        "fullcodeline": "char *temp = (char *)REALLOC(parser, tag->buf, bufSize);"
    },
    {
        "line": 205,
        "fullcodeline": "tag->buf = temp;"
    },
    {
        "line": 206,
        "fullcodeline": "tag->bufEnd = temp + bufSize;"
    },
    {
        "line": 207,
        "fullcodeline": "toPtr = (XML_Char *)temp + convLen;"
    },
    {
        "line": 252,
        "fullcodeline": "*eventPP = *eventEndPP;"
    },
    {
        "line": 279,
        "fullcodeline": "|| memcmp(tag->rawName, rawName, len) != 0) {"
    },
    {
        "line": 280,
        "fullcodeline": "*eventPP = rawName;"
    },
    {
        "line": 309,
        "fullcodeline": "parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);"
    },
    {
        "line": 313,
        "fullcodeline": "BINDING *b = tag->bindings;"
    },
    {
        "line": 318,
        "fullcodeline": "b->nextTagBinding = parser->m_freeBindingList;"
    },
    {
        "line": 319,
        "fullcodeline": "parser->m_freeBindingList = b;"
    },
    {
        "line": 323,
        "fullcodeline": "&& (parser->m_parsingStatus.parsing != XML_FINISHED)) {"
    },
    {
        "line": 349,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 368,
        "fullcodeline": "else if ((0) && parser->m_characterDataHandler)"
    },
    {
        "line": 378,
        "fullcodeline": "else if (! next) {"
    },
    {
        "line": 394,
        "fullcodeline": "(int)(dataPtr - (ICHAR *)parser->m_dataBuf));"
    },
    {
        "line": 396,
        "fullcodeline": "parser->m_characterDataHandler("
    },
    {
        "line": 400,
        "fullcodeline": "reportDefault(parser, enc, s, end);"
    },
    {
        "line": 142,
        "fullcodeline": "entity->open = XML_TRUE;"
    },
    {
        "line": 143,
        "fullcodeline": "context = getContext(parser);"
    },
    {
        "line": 144,
        "fullcodeline": "entity->open = XML_FALSE;"
    },
    {
        "line": 151,
        "fullcodeline": "poolDiscard(&parser->m_tempPool);"
    },
    {
        "line": 171,
        "fullcodeline": "FREE(parser, tag);"
    },
    {
        "line": 193,
        "fullcodeline": "(ICHAR *)tag->bufEnd - 1);"
    },
    {
        "line": 196,
        "fullcodeline": "|| (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {"
    },
    {
        "line": 197,
        "fullcodeline": "tag->name.strLen = convLen;"
    },
    {
        "line": 203,
        "fullcodeline": "if (temp == NULL)"
    },
    {
        "line": 221,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 266,
        "fullcodeline": "return epilogProcessor(parser, next, end, nextPtr);"
    },
    {
        "line": 292,
        "fullcodeline": "if (parser->m_ns && localPart) {"
    },
    {
        "line": 324,
        "fullcodeline": "if (parser->m_parsingStatus.parsing == XML_SUSPENDED)"
    },
    {
        "line": 340,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 369,
        "fullcodeline": "parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,"
    },
    {
        "line": 379,
        "fullcodeline": "parser->m_processor = cdataSectionProcessor;"
    },
    {
        "line": 397,
        "fullcodeline": "parser->m_handlerArg, (const XML_Char *)s,"
    },
    {
        "line": 398,
        "fullcodeline": "(int)((const XML_Char *)end - (const XML_Char *)s));"
    },
    {
        "line": 431,
        "fullcodeline": "charDataHandler(parser->m_handlerArg, (const XML_Char *)s,"
    },
    {
        "line": 434,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 114,
        "fullcodeline": "else if (! entity->is_internal)"
    },
    {
        "line": 131,
        "fullcodeline": "parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,"
    },
    {
        "line": 145,
        "fullcodeline": "if (! context)"
    },
    {
        "line": 147,
        "fullcodeline": "if (! parser->m_externalEntityRefHandler("
    },
    {
        "line": 307,
        "fullcodeline": "*uri = XML_T('\\0');"
    },
    {
        "line": 315,
        "fullcodeline": "parser->m_endNamespaceDeclHandler(parser->m_handlerArg,"
    },
    {
        "line": 325,
        "fullcodeline": "parser->m_processor = epilogProcessor;"
    },
    {
        "line": 419,
        "fullcodeline": "ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;"
    },
    {
        "line": 420,
        "fullcodeline": "const enum XML_Convert_Result convert_res = XmlConvert("
    },
    {
        "line": 422,
        "fullcodeline": "*eventEndPP = s;"
    },
    {
        "line": 423,
        "fullcodeline": "charDataHandler(parser->m_handlerArg, parser->m_dataBuf,"
    },
    {
        "line": 428,
        "fullcodeline": "*eventPP = s;"
    },
    {
        "line": 432,
        "fullcodeline": "(int)((const XML_Char *)next - (const XML_Char *)s));"
    },
    {
        "line": 98,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 118,
        "fullcodeline": "parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);"
    },
    {
        "line": 302,
        "fullcodeline": "if (parser->m_ns_triplets && prefix) {"
    },
    {
        "line": 311,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 424,
        "fullcodeline": "(int)(dataPtr - (ICHAR *)parser->m_dataBuf));"
    },
    {
        "line": 425,
        "fullcodeline": "if ((convert_res == XML_CONVERT_COMPLETED)"
    },
    {
        "line": 153,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 303,
        "fullcodeline": "*uri++ = parser->m_namespaceSeparator;"
    },
    {
        "line": 327,
        "fullcodeline": "return epilogProcessor(parser, next, end, nextPtr);"
    },
    {
        "line": 373,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 421,
        "fullcodeline": "enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);"
    },
    {
        "line": 426,
        "fullcodeline": "|| (convert_res == XML_CONVERT_INPUT_INCOMPLETE))"
    },
    {
        "line": 134,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 300,
        "fullcodeline": "*uri++ = *localPart++;"
    },
    {
        "line": 120,
        "fullcodeline": "reportDefault(parser, enc, s, next);"
    },
    {
        "line": 305,
        "fullcodeline": "*uri++ = *prefix++;"
    }
]