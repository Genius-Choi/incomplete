[
    {
        "line": 12,
        "fullcodeline": "u_int8_t *software = NULL, *platform = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "int software_len = 0, platform_len = 0, proto, version, nb, caps;"
    },
    {
        "line": 14,
        "fullcodeline": "const unsigned char cdpaddr[] = CDP_MULTICAST_ADDR;"
    },
    {
        "line": 25,
        "fullcodeline": "log_debug(\"cdp\", \"decode CDP frame received on %s\","
    },
    {
        "line": 32,
        "fullcodeline": "TAILQ_INIT(&chassis->c_mgmt);"
    },
    {
        "line": 42,
        "fullcodeline": "length = s;"
    },
    {
        "line": 43,
        "fullcodeline": "pos = (u_int8_t*)frame;"
    },
    {
        "line": 65,
        "fullcodeline": "PEEK_DISCARD(ETHER_ADDR_LEN);\t/* Don't care of source address */"
    },
    {
        "line": 66,
        "fullcodeline": "len_eth = PEEK_UINT16;"
    },
    {
        "line": 72,
        "fullcodeline": "PEEK_DISCARD(6);\t/* Skip beginning of LLC */"
    },
    {
        "line": 73,
        "fullcodeline": "proto = PEEK_UINT16;"
    },
    {
        "line": 104,
        "fullcodeline": "version = PEEK_UINT8;"
    },
    {
        "line": 110,
        "fullcodeline": "chassis->c_ttl = PEEK_UINT8; /* TTL */"
    },
    {
        "line": 316,
        "fullcodeline": "*newchassis = chassis;"
    },
    {
        "line": 317,
        "fullcodeline": "*newport = port;"
    },
    {
        "line": 321,
        "fullcodeline": "lldpd_chassis_cleanup(chassis, 1);"
    },
    {
        "line": 322,
        "fullcodeline": "lldpd_port_cleanup(port, 1);"
    },
    {
        "line": 323,
        "fullcodeline": "free(port);"
    },
    {
        "line": 28,
        "fullcodeline": "if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {"
    },
    {
        "line": 33,
        "fullcodeline": "if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t) /* Ethernet */ +"
    },
    {
        "line": 51,
        "fullcodeline": "if (PEEK_CMP(cdpaddr, sizeof(cdpaddr)) != 0) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (len_eth > length) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (proto != LLC_PID_CDP) {"
    },
    {
        "line": 105,
        "fullcodeline": "if ((version != 1) && (version != 2)) {"
    },
    {
        "line": 277,
        "fullcodeline": "if (!software && platform) {"
    },
    {
        "line": 305,
        "fullcodeline": "if ((chassis->c_id == NULL) ||"
    },
    {
        "line": 324,
        "fullcodeline": "return -1;"
    },
    {
        "line": 29,
        "fullcodeline": "log_warn(\"cdp\", \"failed to allocate remote chassis\");"
    },
    {
        "line": 34,
        "fullcodeline": "log_warn(\"cdp\", \"failed to allocate remote port\");"
    },
    {
        "line": 35,
        "fullcodeline": "free(chassis);"
    },
    {
        "line": 47,
        "fullcodeline": "log_warn(\"cdp\", \"too short CDP/FDP frame received on %s\", hardware->h_ifname);"
    },
    {
        "line": 58,
        "fullcodeline": "log_info(\"cdp\", \"frame not targeted at CDP/FDP multicast address received on %s\","
    },
    {
        "line": 68,
        "fullcodeline": "log_warnx(\"cdp\", \"incorrect 802.3 frame size reported on %s\","
    },
    {
        "line": 106,
        "fullcodeline": "log_warnx(\"cdp\", \"incorrect CDP/FDP version (%d) for frame received on %s\","
    },
    {
        "line": 120,
        "fullcodeline": "tlv_type = PEEK_UINT16;"
    },
    {
        "line": 121,
        "fullcodeline": "tlv_len = PEEK_UINT16 - 4;"
    },
    {
        "line": 122,
        "fullcodeline": "(void)PEEK_SAVE(tlv);"
    },
    {
        "line": 275,
        "fullcodeline": "PEEK_DISCARD(tlv + tlv_len - pos);"
    },
    {
        "line": 283,
        "fullcodeline": "memcpy(chassis->c_descr, platform, platform_len);"
    },
    {
        "line": 311,
        "fullcodeline": "(chassis->c_cap_enabled == 0)) {"
    },
    {
        "line": 312,
        "fullcodeline": "log_warnx(\"cdp\", \"some mandatory CDP/FDP tlv are missing for frame received on %s\","
    },
    {
        "line": 30,
        "fullcodeline": "return -1;"
    },
    {
        "line": 36,
        "fullcodeline": "return -1;"
    },
    {
        "line": 75,
        "fullcodeline": "if ((proto != LLC_PID_DRIP) &&"
    },
    {
        "line": 114,
        "fullcodeline": "if (length < 4) {"
    },
    {
        "line": 123,
        "fullcodeline": "if ((tlv_len < 0) || (length < tlv_len)) {"
    },
    {
        "line": 278,
        "fullcodeline": "if ((chassis->c_descr = (char *)calloc(1,"
    },
    {
        "line": 310,
        "fullcodeline": "(chassis->c_ttl == 0) ||"
    },
    {
        "line": 81,
        "fullcodeline": "(proto != LLC_PID_STP))"
    },
    {
        "line": 82,
        "fullcodeline": "log_debug(\"cdp\", \"incorrect LLC protocol ID received on %s\","
    },
    {
        "line": 115,
        "fullcodeline": "log_warnx(\"cdp\", \"CDP/FDP TLV header is too large for \""
    },
    {
        "line": 124,
        "fullcodeline": "log_warnx(\"cdp\", \"incorrect size in CDP/FDP TLV header for frame \""
    },
    {
        "line": 135,
        "fullcodeline": "PEEK_BYTES(chassis->c_name, tlv_len);"
    },
    {
        "line": 136,
        "fullcodeline": "chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_LOCAL;"
    },
    {
        "line": 141,
        "fullcodeline": "memcpy(chassis->c_id, chassis->c_name, tlv_len);"
    },
    {
        "line": 142,
        "fullcodeline": "chassis->c_id_len = tlv_len;"
    },
    {
        "line": 145,
        "fullcodeline": "CHECK_TLV_SIZE(4, \"Address\");"
    },
    {
        "line": 146,
        "fullcodeline": "addresses_len = tlv_len - 4;"
    },
    {
        "line": 204,
        "fullcodeline": "PEEK_BYTES(port->p_descr, tlv_len);"
    },
    {
        "line": 205,
        "fullcodeline": "port->p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;"
    },
    {
        "line": 210,
        "fullcodeline": "memcpy(port->p_id, port->p_descr, tlv_len);"
    },
    {
        "line": 211,
        "fullcodeline": "port->p_id_len = tlv_len;"
    },
    {
        "line": 229,
        "fullcodeline": "CHECK_TLV_SIZE(4, \"Capabilities\");"
    },
    {
        "line": 230,
        "fullcodeline": "caps = PEEK_UINT32;"
    },
    {
        "line": 237,
        "fullcodeline": "chassis->c_cap_available = chassis->c_cap_enabled;"
    },
    {
        "line": 240,
        "fullcodeline": "software_len = tlv_len;"
    },
    {
        "line": 241,
        "fullcodeline": "(void)PEEK_SAVE(software);"
    },
    {
        "line": 244,
        "fullcodeline": "platform_len = tlv_len;"
    },
    {
        "line": 245,
        "fullcodeline": "(void)PEEK_SAVE(platform);"
    },
    {
        "line": 271,
        "fullcodeline": "log_debug(\"cdp\", \"unknown CDP/FDP TLV type (%d) received on %s\","
    },
    {
        "line": 273,
        "fullcodeline": "hardware->h_rx_unrecognized_cnt++;"
    },
    {
        "line": 280,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for chassis description\");"
    },
    {
        "line": 284,
        "fullcodeline": "} else if (software && !platform) {"
    },
    {
        "line": 309,
        "fullcodeline": "(port->p_descr == NULL) ||"
    },
    {
        "line": 80,
        "fullcodeline": "(proto != LLC_PID_DTP) &&"
    },
    {
        "line": 131,
        "fullcodeline": "if ((chassis->c_name = (char *)calloc(1, tlv_len + 1)) == NULL) {"
    },
    {
        "line": 137,
        "fullcodeline": "if ((chassis->c_id =  (char *)malloc(tlv_len)) == NULL) {"
    },
    {
        "line": 147,
        "fullcodeline": "for (nb = PEEK_UINT32; nb > 0; nb--) {"
    },
    {
        "line": 196,
        "fullcodeline": "if (tlv_len == 0) {"
    },
    {
        "line": 200,
        "fullcodeline": "if ((port->p_descr = (char *)calloc(1, tlv_len + 1)) == NULL) {"
    },
    {
        "line": 206,
        "fullcodeline": "if ((port->p_id =  (char *)calloc(1, tlv_len)) == NULL) {"
    },
    {
        "line": 231,
        "fullcodeline": "if (caps & CDP_CAP_ROUTER)"
    },
    {
        "line": 233,
        "fullcodeline": "if (caps & 0x0e)"
    },
    {
        "line": 235,
        "fullcodeline": "if (chassis->c_cap_enabled == 0)"
    },
    {
        "line": 272,
        "fullcodeline": "ntohs(tlv_type), hardware->h_ifname);"
    },
    {
        "line": 290,
        "fullcodeline": "memcpy(chassis->c_descr, software, software_len);"
    },
    {
        "line": 308,
        "fullcodeline": "(chassis->c_descr == NULL) ||"
    },
    {
        "line": 79,
        "fullcodeline": "(proto != LLC_PID_VTP) &&"
    },
    {
        "line": 132,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for chassis name\");"
    },
    {
        "line": 138,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for chassis ID\");"
    },
    {
        "line": 148,
        "fullcodeline": "(void)PEEK_SAVE(pos_address);"
    },
    {
        "line": 156,
        "fullcodeline": "PEEK_DISCARD_UINT8; addresses_len--;"
    },
    {
        "line": 157,
        "fullcodeline": "address_len = PEEK_UINT8; addresses_len--;"
    },
    {
        "line": 164,
        "fullcodeline": "PEEK_DISCARD(address_len);"
    },
    {
        "line": 165,
        "fullcodeline": "addresses_len -= address_len;"
    },
    {
        "line": 166,
        "fullcodeline": "address_len = PEEK_UINT16; addresses_len -= 2;"
    },
    {
        "line": 173,
        "fullcodeline": "PEEK_DISCARD(address_len);"
    },
    {
        "line": 174,
        "fullcodeline": "(void)PEEK_SAVE(pos_next_address);"
    },
    {
        "line": 177,
        "fullcodeline": "PEEK_RESTORE(pos_address);"
    },
    {
        "line": 192,
        "fullcodeline": "PEEK_RESTORE(pos_next_address);"
    },
    {
        "line": 197,
        "fullcodeline": "log_warn(\"cdp\", \"too short port description received\");"
    },
    {
        "line": 201,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for port description\");"
    },
    {
        "line": 207,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for port ID\");"
    },
    {
        "line": 232,
        "fullcodeline": "chassis->c_cap_enabled |= LLDP_CAP_ROUTER;"
    },
    {
        "line": 234,
        "fullcodeline": "chassis->c_cap_enabled |= LLDP_CAP_BRIDGE;"
    },
    {
        "line": 236,
        "fullcodeline": "chassis->c_cap_enabled = LLDP_CAP_STATION;"
    },
    {
        "line": 285,
        "fullcodeline": "if ((chassis->c_descr = (char *)calloc(1,"
    },
    {
        "line": 307,
        "fullcodeline": "(chassis->c_name == NULL) ||"
    },
    {
        "line": 78,
        "fullcodeline": "(proto != LLC_PID_UDLD) &&"
    },
    {
        "line": 150,
        "fullcodeline": "if (addresses_len < 2) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (addresses_len < address_len + 2) {"
    },
    {
        "line": 167,
        "fullcodeline": "if (addresses_len < address_len) {"
    },
    {
        "line": 178,
        "fullcodeline": "if ((PEEK_UINT8 == 1) && (PEEK_UINT8 == 1) &&"
    },
    {
        "line": 279,
        "fullcodeline": "platform_len + 1)) == NULL) {"
    },
    {
        "line": 287,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for chassis description\");"
    },
    {
        "line": 291,
        "fullcodeline": "} else if (software && platform) {"
    },
    {
        "line": 306,
        "fullcodeline": "(port->p_id == NULL) ||"
    },
    {
        "line": 77,
        "fullcodeline": "(proto != LLC_PID_PVSTP) &&"
    },
    {
        "line": 151,
        "fullcodeline": "log_warn(\"cdp\", \"too short address subframe \""
    },
    {
        "line": 159,
        "fullcodeline": "log_warn(\"cdp\", \"too short address subframe \""
    },
    {
        "line": 168,
        "fullcodeline": "log_warn(\"cdp\", \"too short address subframe \""
    },
    {
        "line": 180,
        "fullcodeline": "(PEEK_UINT16 == sizeof(struct in_addr))) {"
    },
    {
        "line": 181,
        "fullcodeline": "PEEK_BYTES(&addr, sizeof(struct in_addr));"
    },
    {
        "line": 182,
        "fullcodeline": "mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &addr,"
    },
    {
        "line": 189,
        "fullcodeline": "TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);"
    },
    {
        "line": 299,
        "fullcodeline": "memcpy(chassis->c_descr, platform, platform_len);"
    },
    {
        "line": 300,
        "fullcodeline": "memcpy(chassis->c_descr + platform_len,"
    },
    {
        "line": 302,
        "fullcodeline": "memcpy(chassis->c_descr + platform_len + strlen(CONCAT_PLATFORM),"
    },
    {
        "line": 76,
        "fullcodeline": "(proto != LLC_PID_PAGP) &&"
    },
    {
        "line": 179,
        "fullcodeline": "(PEEK_UINT8 == CDP_ADDRESS_PROTO_IP) &&"
    },
    {
        "line": 184,
        "fullcodeline": "if (mgmt == NULL) {"
    },
    {
        "line": 293,
        "fullcodeline": "if ((chassis->c_descr = (char *)calloc(1,"
    },
    {
        "line": 301,
        "fullcodeline": "CONCAT_PLATFORM, strlen(CONCAT_PLATFORM));"
    },
    {
        "line": 185,
        "fullcodeline": "assert(errno == ENOMEM);"
    },
    {
        "line": 186,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for management address\");"
    },
    {
        "line": 286,
        "fullcodeline": "software_len + 1)) == NULL) {"
    },
    {
        "line": 296,
        "fullcodeline": "log_warn(\"cdp\", \"unable to allocate memory for chassis description\");"
    },
    {
        "line": 294,
        "fullcodeline": "software_len + platform_len +"
    },
    {
        "line": 295,
        "fullcodeline": "strlen(CONCAT_PLATFORM) + 1)) == NULL) {"
    }
]