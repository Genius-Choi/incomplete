[
    {
        "line": 3,
        "fullcodeline": "AC3HeaderInfo *hdr = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "info = track->eac3_priv;"
    },
    {
        "line": 22,
        "fullcodeline": "num_blocks = hdr->num_blocks;"
    },
    {
        "line": 133,
        "fullcodeline": "ret = pkt->size;"
    },
    {
        "line": 7,
        "fullcodeline": "if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))"
    },
    {
        "line": 21,
        "fullcodeline": "info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);"
    },
    {
        "line": 114,
        "fullcodeline": "if (!info->num_blocks) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (!info->num_blocks && num_blocks == 6) {"
    },
    {
        "line": 106,
        "fullcodeline": "ret = pkt->size;"
    },
    {
        "line": 115,
        "fullcodeline": "ret = av_packet_ref(&info->pkt, pkt);"
    },
    {
        "line": 8,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 33,
        "fullcodeline": "if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (pkt->size != hdr->frame_size) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 122,
        "fullcodeline": "memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);"
    },
    {
        "line": 123,
        "fullcodeline": "info->num_blocks += num_blocks;"
    },
    {
        "line": 124,
        "fullcodeline": "info->pkt.duration += pkt->duration;"
    },
    {
        "line": 129,
        "fullcodeline": "av_packet_unref(pkt);"
    },
    {
        "line": 130,
        "fullcodeline": "av_packet_move_ref(pkt, &info->pkt);"
    },
    {
        "line": 14,
        "fullcodeline": "av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");"
    },
    {
        "line": 15,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {"
    },
    {
        "line": 27,
        "fullcodeline": "ret = AVERROR(EINVAL);"
    },
    {
        "line": 67,
        "fullcodeline": "int cumul_size = hdr->frame_size;"
    },
    {
        "line": 17,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 35,
        "fullcodeline": "if (hdr->substreamid > info->num_ind_sub + 1) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (hdr->substreamid == info->num_ind_sub + 1) {"
    },
    {
        "line": 70,
        "fullcodeline": "while (cumul_size != pkt->size) {"
    },
    {
        "line": 110,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 120,
        "fullcodeline": "if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)"
    },
    {
        "line": 125,
        "fullcodeline": "if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)"
    },
    {
        "line": 36,
        "fullcodeline": "ret = AVERROR(EINVAL);"
    },
    {
        "line": 43,
        "fullcodeline": "ret = AVERROR_PATCHWELCOME;"
    },
    {
        "line": 51,
        "fullcodeline": "if (hdr->substreamid != 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);"
    },
    {
        "line": 81,
        "fullcodeline": "ret /= 8;"
    },
    {
        "line": 84,
        "fullcodeline": "init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);"
    },
    {
        "line": 86,
        "fullcodeline": "skip_bits(&gbc, 5);"
    },
    {
        "line": 99,
        "fullcodeline": "cumul_size += hdr->frame_size;"
    },
    {
        "line": 53,
        "fullcodeline": "ret = AVERROR_PATCHWELCOME;"
    },
    {
        "line": 74,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 76,
        "fullcodeline": "if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {"
    },
    {
        "line": 88,
        "fullcodeline": "for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (get_bits1(&gbc))"
    },
    {
        "line": 77,
        "fullcodeline": "ret = AVERROR(EINVAL);"
    },
    {
        "line": 89,
        "fullcodeline": "skip_bits(&gbc, 5); // skip dialog normalization"
    },
    {
        "line": 96,
        "fullcodeline": "info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;"
    },
    {
        "line": 45,
        "fullcodeline": "} else if (hdr->substreamid < info->num_ind_sub ||"
    },
    {
        "line": 46,
        "fullcodeline": "hdr->substreamid == 0 && info->substream[0].bsid) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (get_bits1(&gbc)) {"
    },
    {
        "line": 98,
        "fullcodeline": "info->substream[parent].chan_loc |= hdr->channel_mode;"
    },
    {
        "line": 91,
        "fullcodeline": "skip_bits(&gbc, 8); // skip compression gain word"
    }
]