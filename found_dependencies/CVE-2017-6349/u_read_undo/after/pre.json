[
    {
        "line": 6,
        "fullcodeline": "char_u\t*line_ptr = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "long\tnum_head = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "long\tlast_save_nr = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "short\told_idx = -1, new_idx = -1, cur_idx = -1;"
    },
    {
        "line": 15,
        "fullcodeline": "long\tnum_read_uhps = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "u_header_T\t**uhp_table = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "char_u\tread_hash[UNDO_HASH_SIZE];"
    },
    {
        "line": 22,
        "fullcodeline": "char_u\tmagic_buf[UF_START_MAGIC_LEN];"
    },
    {
        "line": 32,
        "fullcodeline": "vim_memset(&bi, 0, sizeof(bi));"
    },
    {
        "line": 68,
        "fullcodeline": "fp = mch_fopen((char *)file_name, \"r\");"
    },
    {
        "line": 75,
        "fullcodeline": "bi.bi_buf = curbuf;"
    },
    {
        "line": 76,
        "fullcodeline": "bi.bi_fp = fp;"
    },
    {
        "line": 87,
        "fullcodeline": "version = get2c(fp);"
    },
    {
        "line": 131,
        "fullcodeline": "line_count = (linenr_T)undo_read_4c(&bi);"
    },
    {
        "line": 148,
        "fullcodeline": "str_len = undo_read_4c(&bi);"
    },
    {
        "line": 153,
        "fullcodeline": "line_lnum = (linenr_T)undo_read_4c(&bi);"
    },
    {
        "line": 154,
        "fullcodeline": "line_colnr = (colnr_T)undo_read_4c(&bi);"
    },
    {
        "line": 162,
        "fullcodeline": "old_header_seq = undo_read_4c(&bi);"
    },
    {
        "line": 163,
        "fullcodeline": "new_header_seq = undo_read_4c(&bi);"
    },
    {
        "line": 164,
        "fullcodeline": "cur_header_seq = undo_read_4c(&bi);"
    },
    {
        "line": 165,
        "fullcodeline": "num_head = undo_read_4c(&bi);"
    },
    {
        "line": 166,
        "fullcodeline": "seq_last = undo_read_4c(&bi);"
    },
    {
        "line": 167,
        "fullcodeline": "seq_cur = undo_read_4c(&bi);"
    },
    {
        "line": 168,
        "fullcodeline": "seq_time = undo_read_time(&bi);"
    },
    {
        "line": 33,
        "fullcodeline": "if (name == NULL)"
    },
    {
        "line": 61,
        "fullcodeline": "if (p_verbose > 0)"
    },
    {
        "line": 69,
        "fullcodeline": "if (fp == NULL)"
    },
    {
        "line": 88,
        "fullcodeline": "if (version == UF_VERSION_CRYPT)"
    },
    {
        "line": 126,
        "fullcodeline": "if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)"
    },
    {
        "line": 149,
        "fullcodeline": "if (str_len < 0)"
    },
    {
        "line": 151,
        "fullcodeline": "if (str_len > 0)"
    },
    {
        "line": 195,
        "fullcodeline": "if (num_head > 0)"
    },
    {
        "line": 204,
        "fullcodeline": "while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)"
    },
    {
        "line": 218,
        "fullcodeline": "if (num_read_uhps != num_head)"
    },
    {
        "line": 223,
        "fullcodeline": "if (c != UF_HEADER_END_MAGIC)"
    },
    {
        "line": 240,
        "fullcodeline": "for (i = 0; i < num_head; i++)"
    },
    {
        "line": 328,
        "fullcodeline": "if (name != NULL)"
    },
    {
        "line": 334,
        "fullcodeline": "if (uhp_table != NULL)"
    },
    {
        "line": 348,
        "fullcodeline": "if (fp != NULL)"
    },
    {
        "line": 350,
        "fullcodeline": "if (file_name != name)"
    },
    {
        "line": 35,
        "fullcodeline": "file_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);"
    },
    {
        "line": 64,
        "fullcodeline": "smsg((char_u *)_(\"Reading undo file: %s\"), file_name);"
    },
    {
        "line": 81,
        "fullcodeline": "if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1"
    },
    {
        "line": 82,
        "fullcodeline": "|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)"
    },
    {
        "line": 84,
        "fullcodeline": "EMSG2(_(\"E823: Not an undo file: %s\"), file_name);"
    },
    {
        "line": 116,
        "fullcodeline": "EMSG2(_(\"E827: Undo file is encrypted: %s\"), file_name);"
    },
    {
        "line": 128,
        "fullcodeline": "corruption_error(\"hash\", file_name);"
    },
    {
        "line": 132,
        "fullcodeline": "if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0"
    },
    {
        "line": 133,
        "fullcodeline": "|| line_count != curbuf->b_ml.ml_line_count)"
    },
    {
        "line": 152,
        "fullcodeline": "line_ptr = read_string_decrypt(&bi, str_len);"
    },
    {
        "line": 155,
        "fullcodeline": "if (line_lnum < 0 || line_colnr < 0)"
    },
    {
        "line": 157,
        "fullcodeline": "corruption_error(\"line lnum/col\", file_name);"
    },
    {
        "line": 173,
        "fullcodeline": "int len = undo_read_byte(&bi);"
    },
    {
        "line": 212,
        "fullcodeline": "uhp = unserialize_uhp(&bi, file_name);"
    },
    {
        "line": 215,
        "fullcodeline": "uhp_table[num_read_uhps++] = uhp;"
    },
    {
        "line": 220,
        "fullcodeline": "corruption_error(\"num_head\", file_name);"
    },
    {
        "line": 225,
        "fullcodeline": "corruption_error(\"end marker\", file_name);"
    },
    {
        "line": 242,
        "fullcodeline": "uhp = uhp_table[i];"
    },
    {
        "line": 329,
        "fullcodeline": "smsg((char_u *)_(\"Finished reading undo file %s\"), file_name);"
    },
    {
        "line": 36,
        "fullcodeline": "if (file_name == NULL)"
    },
    {
        "line": 59,
        "fullcodeline": "file_name = name;"
    },
    {
        "line": 178,
        "fullcodeline": "what = undo_read_byte(&bi);"
    },
    {
        "line": 197,
        "fullcodeline": "if (num_head < LONG_MAX / (long)sizeof(u_header_T *))"
    },
    {
        "line": 200,
        "fullcodeline": "if (uhp_table == NULL)"
    },
    {
        "line": 206,
        "fullcodeline": "if (num_read_uhps >= num_head)"
    },
    {
        "line": 213,
        "fullcodeline": "if (uhp == NULL)"
    },
    {
        "line": 243,
        "fullcodeline": "if (uhp == NULL)"
    },
    {
        "line": 245,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 252,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 260,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 268,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 276,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 336,
        "fullcodeline": "for (i = 0; i < num_read_uhps; i++)"
    },
    {
        "line": 71,
        "fullcodeline": "if (name != NULL || p_verbose > 0)"
    },
    {
        "line": 72,
        "fullcodeline": "EMSG2(_(\"E822: Cannot open undo file for reading: %s\"), file_name);"
    },
    {
        "line": 120,
        "fullcodeline": "else if (version != UF_VERSION)"
    },
    {
        "line": 135,
        "fullcodeline": "if (p_verbose > 0 || name != NULL)"
    },
    {
        "line": 176,
        "fullcodeline": "if (len == 0 || len == EOF)"
    },
    {
        "line": 182,
        "fullcodeline": "last_save_nr = undo_read_4c(&bi);"
    },
    {
        "line": 198,
        "fullcodeline": "uhp_table = (u_header_T **)U_ALLOC_LINE("
    },
    {
        "line": 208,
        "fullcodeline": "corruption_error(\"num_head too small\", file_name);"
    },
    {
        "line": 284,
        "fullcodeline": "if (old_header_seq > 0 && old_idx < 0 && uhp->uh_seq == old_header_seq)"
    },
    {
        "line": 286,
        "fullcodeline": "old_idx = i;"
    },
    {
        "line": 289,
        "fullcodeline": "if (new_header_seq > 0 && new_idx < 0 && uhp->uh_seq == new_header_seq)"
    },
    {
        "line": 291,
        "fullcodeline": "new_idx = i;"
    },
    {
        "line": 294,
        "fullcodeline": "if (cur_header_seq > 0 && cur_idx < 0 && uhp->uh_seq == cur_header_seq)"
    },
    {
        "line": 296,
        "fullcodeline": "cur_idx = i;"
    },
    {
        "line": 337,
        "fullcodeline": "if (uhp_table[i] != NULL)"
    },
    {
        "line": 122,
        "fullcodeline": "EMSG2(_(\"E824: Incompatible undo file: %s\"), file_name);"
    },
    {
        "line": 137,
        "fullcodeline": "if (name == NULL)"
    },
    {
        "line": 141,
        "fullcodeline": "if (name == NULL)"
    },
    {
        "line": 246,
        "fullcodeline": "if (uhp_table[j] != NULL && i != j"
    },
    {
        "line": 247,
        "fullcodeline": "&& uhp_table[i]->uh_seq == uhp_table[j]->uh_seq)"
    },
    {
        "line": 249,
        "fullcodeline": "corruption_error(\"duplicate uh_seq\", file_name);"
    },
    {
        "line": 253,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 254,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_next.seq)"
    },
    {
        "line": 261,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 262,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_prev.seq)"
    },
    {
        "line": 269,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 270,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_alt_next.seq)"
    },
    {
        "line": 277,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 278,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_alt_prev.seq)"
    },
    {
        "line": 338,
        "fullcodeline": "u_free_uhp(uhp_table[i]);"
    },
    {
        "line": 140,
        "fullcodeline": "_(\"File contents changed, cannot use undo info\"), TRUE);"
    },
    {
        "line": 186,
        "fullcodeline": "while (--len >= 0)"
    },
    {
        "line": 187,
        "fullcodeline": "(void)undo_read_byte(&bi);"
    },
    {
        "line": 199,
        "fullcodeline": "num_head * sizeof(u_header_T *));"
    }
]