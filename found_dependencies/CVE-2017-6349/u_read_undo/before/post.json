[
    {
        "line": 6,
        "fullcodeline": "char_u\t*line_ptr = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "int\t\tnum_head = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "long\tlast_save_nr = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "short\told_idx = -1, new_idx = -1, cur_idx = -1;"
    },
    {
        "line": 15,
        "fullcodeline": "long\tnum_read_uhps = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "u_header_T\t**uhp_table = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "char_u\tread_hash[UNDO_HASH_SIZE];"
    },
    {
        "line": 22,
        "fullcodeline": "char_u\tmagic_buf[UF_START_MAGIC_LEN];"
    },
    {
        "line": 32,
        "fullcodeline": "vim_memset(&bi, 0, sizeof(bi));"
    },
    {
        "line": 68,
        "fullcodeline": "fp = mch_fopen((char *)file_name, \"r\");"
    },
    {
        "line": 75,
        "fullcodeline": "bi.bi_buf = curbuf;"
    },
    {
        "line": 76,
        "fullcodeline": "bi.bi_fp = fp;"
    },
    {
        "line": 87,
        "fullcodeline": "version = get2c(fp);"
    },
    {
        "line": 131,
        "fullcodeline": "line_count = (linenr_T)undo_read_4c(&bi);"
    },
    {
        "line": 148,
        "fullcodeline": "str_len = undo_read_4c(&bi);"
    },
    {
        "line": 153,
        "fullcodeline": "line_lnum = (linenr_T)undo_read_4c(&bi);"
    },
    {
        "line": 154,
        "fullcodeline": "line_colnr = (colnr_T)undo_read_4c(&bi);"
    },
    {
        "line": 162,
        "fullcodeline": "old_header_seq = undo_read_4c(&bi);"
    },
    {
        "line": 163,
        "fullcodeline": "new_header_seq = undo_read_4c(&bi);"
    },
    {
        "line": 164,
        "fullcodeline": "cur_header_seq = undo_read_4c(&bi);"
    },
    {
        "line": 165,
        "fullcodeline": "num_head = undo_read_4c(&bi);"
    },
    {
        "line": 166,
        "fullcodeline": "seq_last = undo_read_4c(&bi);"
    },
    {
        "line": 167,
        "fullcodeline": "seq_cur = undo_read_4c(&bi);"
    },
    {
        "line": 168,
        "fullcodeline": "seq_time = undo_read_time(&bi);"
    },
    {
        "line": 302,
        "fullcodeline": "u_blockfree(curbuf);"
    },
    {
        "line": 303,
        "fullcodeline": "curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];"
    },
    {
        "line": 304,
        "fullcodeline": "curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];"
    },
    {
        "line": 305,
        "fullcodeline": "curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];"
    },
    {
        "line": 306,
        "fullcodeline": "curbuf->b_u_line_ptr = line_ptr;"
    },
    {
        "line": 307,
        "fullcodeline": "curbuf->b_u_line_lnum = line_lnum;"
    },
    {
        "line": 308,
        "fullcodeline": "curbuf->b_u_line_colnr = line_colnr;"
    },
    {
        "line": 309,
        "fullcodeline": "curbuf->b_u_numhead = num_head;"
    },
    {
        "line": 310,
        "fullcodeline": "curbuf->b_u_seq_last = seq_last;"
    },
    {
        "line": 311,
        "fullcodeline": "curbuf->b_u_seq_cur = seq_cur;"
    },
    {
        "line": 312,
        "fullcodeline": "curbuf->b_u_time_cur = seq_time;"
    },
    {
        "line": 313,
        "fullcodeline": "curbuf->b_u_save_nr_last = last_save_nr;"
    },
    {
        "line": 314,
        "fullcodeline": "curbuf->b_u_save_nr_cur = last_save_nr;"
    },
    {
        "line": 316,
        "fullcodeline": "curbuf->b_u_synced = TRUE;"
    },
    {
        "line": 317,
        "fullcodeline": "vim_free(uhp_table);"
    },
    {
        "line": 332,
        "fullcodeline": "vim_free(line_ptr);"
    },
    {
        "line": 33,
        "fullcodeline": "if (name == NULL)"
    },
    {
        "line": 61,
        "fullcodeline": "if (p_verbose > 0)"
    },
    {
        "line": 69,
        "fullcodeline": "if (fp == NULL)"
    },
    {
        "line": 81,
        "fullcodeline": "if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1"
    },
    {
        "line": 88,
        "fullcodeline": "if (version == UF_VERSION_CRYPT)"
    },
    {
        "line": 126,
        "fullcodeline": "if (undo_read(&bi, read_hash, (size_t)UNDO_HASH_SIZE) == FAIL)"
    },
    {
        "line": 132,
        "fullcodeline": "if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0"
    },
    {
        "line": 149,
        "fullcodeline": "if (str_len < 0)"
    },
    {
        "line": 151,
        "fullcodeline": "if (str_len > 0)"
    },
    {
        "line": 155,
        "fullcodeline": "if (line_lnum < 0 || line_colnr < 0)"
    },
    {
        "line": 195,
        "fullcodeline": "if (num_head > 0)"
    },
    {
        "line": 203,
        "fullcodeline": "while ((c = undo_read_2c(&bi)) == UF_HEADER_MAGIC)"
    },
    {
        "line": 217,
        "fullcodeline": "if (num_read_uhps != num_head)"
    },
    {
        "line": 222,
        "fullcodeline": "if (c != UF_HEADER_END_MAGIC)"
    },
    {
        "line": 239,
        "fullcodeline": "for (i = 0; i < num_head; i++)"
    },
    {
        "line": 327,
        "fullcodeline": "if (name != NULL)"
    },
    {
        "line": 333,
        "fullcodeline": "if (uhp_table != NULL)"
    },
    {
        "line": 347,
        "fullcodeline": "if (fp != NULL)"
    },
    {
        "line": 349,
        "fullcodeline": "if (file_name != name)"
    },
    {
        "line": 35,
        "fullcodeline": "file_name = u_get_undo_file_name(curbuf->b_ffname, TRUE);"
    },
    {
        "line": 63,
        "fullcodeline": "verbose_enter();"
    },
    {
        "line": 64,
        "fullcodeline": "smsg((char_u *)_(\"Reading undo file: %s\"), file_name);"
    },
    {
        "line": 65,
        "fullcodeline": "verbose_leave();"
    },
    {
        "line": 82,
        "fullcodeline": "|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)"
    },
    {
        "line": 84,
        "fullcodeline": "EMSG2(_(\"E823: Not an undo file: %s\"), file_name);"
    },
    {
        "line": 116,
        "fullcodeline": "EMSG2(_(\"E827: Undo file is encrypted: %s\"), file_name);"
    },
    {
        "line": 128,
        "fullcodeline": "corruption_error(\"hash\", file_name);"
    },
    {
        "line": 133,
        "fullcodeline": "|| line_count != curbuf->b_ml.ml_line_count)"
    },
    {
        "line": 152,
        "fullcodeline": "line_ptr = read_string_decrypt(&bi, str_len);"
    },
    {
        "line": 157,
        "fullcodeline": "corruption_error(\"line lnum/col\", file_name);"
    },
    {
        "line": 173,
        "fullcodeline": "int len = undo_read_byte(&bi);"
    },
    {
        "line": 178,
        "fullcodeline": "what = undo_read_byte(&bi);"
    },
    {
        "line": 197,
        "fullcodeline": "uhp_table = (u_header_T **)U_ALLOC_LINE("
    },
    {
        "line": 211,
        "fullcodeline": "uhp = unserialize_uhp(&bi, file_name);"
    },
    {
        "line": 214,
        "fullcodeline": "uhp_table[num_read_uhps++] = uhp;"
    },
    {
        "line": 219,
        "fullcodeline": "corruption_error(\"num_head\", file_name);"
    },
    {
        "line": 224,
        "fullcodeline": "corruption_error(\"end marker\", file_name);"
    },
    {
        "line": 241,
        "fullcodeline": "uhp = uhp_table[i];"
    },
    {
        "line": 328,
        "fullcodeline": "smsg((char_u *)_(\"Finished reading undo file %s\"), file_name);"
    },
    {
        "line": 338,
        "fullcodeline": "vim_free(uhp_table);"
    },
    {
        "line": 348,
        "fullcodeline": "fclose(fp);"
    },
    {
        "line": 350,
        "fullcodeline": "vim_free(file_name);"
    },
    {
        "line": 36,
        "fullcodeline": "if (file_name == NULL)"
    },
    {
        "line": 59,
        "fullcodeline": "file_name = name;"
    },
    {
        "line": 71,
        "fullcodeline": "if (name != NULL || p_verbose > 0)"
    },
    {
        "line": 135,
        "fullcodeline": "if (p_verbose > 0 || name != NULL)"
    },
    {
        "line": 176,
        "fullcodeline": "if (len == 0 || len == EOF)"
    },
    {
        "line": 199,
        "fullcodeline": "if (uhp_table == NULL)"
    },
    {
        "line": 205,
        "fullcodeline": "if (num_read_uhps >= num_head)"
    },
    {
        "line": 212,
        "fullcodeline": "if (uhp == NULL)"
    },
    {
        "line": 242,
        "fullcodeline": "if (uhp == NULL)"
    },
    {
        "line": 244,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 251,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 259,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 267,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 275,
        "fullcodeline": "for (j = 0; j < num_head; j++)"
    },
    {
        "line": 283,
        "fullcodeline": "if (old_header_seq > 0 && old_idx < 0 && uhp->uh_seq == old_header_seq)"
    },
    {
        "line": 288,
        "fullcodeline": "if (new_header_seq > 0 && new_idx < 0 && uhp->uh_seq == new_header_seq)"
    },
    {
        "line": 293,
        "fullcodeline": "if (cur_header_seq > 0 && cur_idx < 0 && uhp->uh_seq == cur_header_seq)"
    },
    {
        "line": 335,
        "fullcodeline": "for (i = 0; i < num_read_uhps; i++)"
    },
    {
        "line": 72,
        "fullcodeline": "EMSG2(_(\"E822: Cannot open undo file for reading: %s\"), file_name);"
    },
    {
        "line": 120,
        "fullcodeline": "else if (version != UF_VERSION)"
    },
    {
        "line": 139,
        "fullcodeline": "give_warning((char_u *)"
    },
    {
        "line": 182,
        "fullcodeline": "last_save_nr = undo_read_4c(&bi);"
    },
    {
        "line": 207,
        "fullcodeline": "corruption_error(\"num_head too small\", file_name);"
    },
    {
        "line": 245,
        "fullcodeline": "if (uhp_table[j] != NULL && i != j"
    },
    {
        "line": 252,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 260,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 268,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 276,
        "fullcodeline": "if (uhp_table[j] != NULL"
    },
    {
        "line": 285,
        "fullcodeline": "old_idx = i;"
    },
    {
        "line": 290,
        "fullcodeline": "new_idx = i;"
    },
    {
        "line": 295,
        "fullcodeline": "cur_idx = i;"
    },
    {
        "line": 336,
        "fullcodeline": "if (uhp_table[i] != NULL)"
    },
    {
        "line": 122,
        "fullcodeline": "EMSG2(_(\"E824: Incompatible undo file: %s\"), file_name);"
    },
    {
        "line": 137,
        "fullcodeline": "if (name == NULL)"
    },
    {
        "line": 141,
        "fullcodeline": "if (name == NULL)"
    },
    {
        "line": 186,
        "fullcodeline": "while (--len >= 0)"
    },
    {
        "line": 187,
        "fullcodeline": "(void)undo_read_byte(&bi);"
    },
    {
        "line": 198,
        "fullcodeline": "num_head * sizeof(u_header_T *));"
    },
    {
        "line": 246,
        "fullcodeline": "&& uhp_table[i]->uh_seq == uhp_table[j]->uh_seq)"
    },
    {
        "line": 248,
        "fullcodeline": "corruption_error(\"duplicate uh_seq\", file_name);"
    },
    {
        "line": 253,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_next.seq)"
    },
    {
        "line": 255,
        "fullcodeline": "uhp->uh_next.ptr = uhp_table[j];"
    },
    {
        "line": 261,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_prev.seq)"
    },
    {
        "line": 263,
        "fullcodeline": "uhp->uh_prev.ptr = uhp_table[j];"
    },
    {
        "line": 269,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_alt_next.seq)"
    },
    {
        "line": 271,
        "fullcodeline": "uhp->uh_alt_next.ptr = uhp_table[j];"
    },
    {
        "line": 277,
        "fullcodeline": "&& uhp_table[j]->uh_seq == uhp->uh_alt_prev.seq)"
    },
    {
        "line": 279,
        "fullcodeline": "uhp->uh_alt_prev.ptr = uhp_table[j];"
    },
    {
        "line": 337,
        "fullcodeline": "u_free_uhp(uhp_table[i]);"
    },
    {
        "line": 138,
        "fullcodeline": "verbose_enter();"
    },
    {
        "line": 140,
        "fullcodeline": "_(\"File contents changed, cannot use undo info\"), TRUE);"
    },
    {
        "line": 142,
        "fullcodeline": "verbose_leave();"
    }
]