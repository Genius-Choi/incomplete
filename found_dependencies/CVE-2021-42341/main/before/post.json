[
    {
        "line": 4,
        "fullcodeline": "uid_t uid = geteuid();"
    },
    {
        "line": 5,
        "fullcodeline": "gid_t gid = getgid();"
    },
    {
        "line": 6,
        "fullcodeline": "mode_t mode = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "struct passwd *pw = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "struct group *gr = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "inode_t type = inode_unknown;"
    },
    {
        "line": 10,
        "fullcodeline": "int retval = EXIT_SUCCESS;"
    },
    {
        "line": 11,
        "fullcodeline": "bool trunc = false;"
    },
    {
        "line": 12,
        "fullcodeline": "bool chowner = false;"
    },
    {
        "line": 13,
        "fullcodeline": "bool symlinks = false;"
    },
    {
        "line": 14,
        "fullcodeline": "bool writable = false;"
    },
    {
        "line": 15,
        "fullcodeline": "bool selinux_on = false;"
    },
    {
        "line": 17,
        "fullcodeline": "applet = basename_c(argv[0]);"
    },
    {
        "line": 18,
        "fullcodeline": "while ((opt = getopt_long(argc, argv, getoptstring,"
    },
    {
        "line": 61,
        "fullcodeline": "if (optind >= argc)"
    },
    {
        "line": 64,
        "fullcodeline": "if (writable && type != inode_unknown)"
    },
    {
        "line": 74,
        "fullcodeline": "if (selinux_util_open() == 1)"
    },
    {
        "line": 77,
        "fullcodeline": "while (optind < argc) {"
    },
    {
        "line": 19,
        "fullcodeline": "longopts, (int *) 0)) != -1)"
    },
    {
        "line": 62,
        "fullcodeline": "usage(EXIT_FAILURE);"
    },
    {
        "line": 65,
        "fullcodeline": "eerrorx(\"%s: -W cannot be specified along with -d, -f or -p\", applet);"
    },
    {
        "line": 68,
        "fullcodeline": "uid = pw->pw_uid;"
    },
    {
        "line": 69,
        "fullcodeline": "gid = pw->pw_gid;"
    },
    {
        "line": 72,
        "fullcodeline": "gid = gr->gr_gid;"
    },
    {
        "line": 75,
        "fullcodeline": "selinux_on = true;"
    },
    {
        "line": 83,
        "fullcodeline": "optind++;"
    },
    {
        "line": 87,
        "fullcodeline": "selinux_util_close();"
    },
    {
        "line": 80,
        "fullcodeline": "if (do_check(argv[optind], uid, gid, mode, type, trunc, chowner,"
    },
    {
        "line": 23,
        "fullcodeline": "trunc = true;"
    },
    {
        "line": 26,
        "fullcodeline": "type = inode_dir;"
    },
    {
        "line": 29,
        "fullcodeline": "trunc = true;"
    },
    {
        "line": 32,
        "fullcodeline": "type = inode_file;"
    },
    {
        "line": 35,
        "fullcodeline": "type = inode_fifo;"
    },
    {
        "line": 43,
        "fullcodeline": "chowner = true;"
    },
    {
        "line": 50,
        "fullcodeline": "symlinks = true;"
    },
    {
        "line": 54,
        "fullcodeline": "writable = true;"
    },
    {
        "line": 79,
        "fullcodeline": "exit(!is_writable(argv[optind]));"
    },
    {
        "line": 82,
        "fullcodeline": "retval = EXIT_FAILURE;"
    },
    {
        "line": 38,
        "fullcodeline": "if (parse_mode(&mode, optarg) != 0)"
    },
    {
        "line": 44,
        "fullcodeline": "if (parse_owner(&pw, &gr, optarg) != 0)"
    },
    {
        "line": 39,
        "fullcodeline": "eerrorx(\"%s: invalid mode `%s'\","
    },
    {
        "line": 45,
        "fullcodeline": "eerrorx(\"%s: owner `%s' not found\","
    }
]