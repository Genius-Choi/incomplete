[
    {
        "line": 5,
        "fullcodeline": "char *name = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "memset(&st, 0, sizeof(st));"
    },
    {
        "line": 15,
        "fullcodeline": "flags = O_CREAT|O_NDELAY|O_WRONLY|O_NOCTTY;"
    },
    {
        "line": 16,
        "fullcodeline": "readflags = O_NDELAY|O_NOCTTY|O_RDONLY;"
    },
    {
        "line": 27,
        "fullcodeline": "xasprintf(&name, \"%s\", basename_c(path));"
    },
    {
        "line": 28,
        "fullcodeline": "dirfd = get_dirfd(path, symlinks);"
    },
    {
        "line": 29,
        "fullcodeline": "readfd = openat(dirfd, name, readflags);"
    },
    {
        "line": 145,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 30,
        "fullcodeline": "if (readfd == -1 || (type == inode_file && trunc)) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (fstat(readfd, &st) != -1) {"
    },
    {
        "line": 26,
        "fullcodeline": "flags |= O_TRUNC;"
    },
    {
        "line": 31,
        "fullcodeline": "if (type == inode_file) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (type != inode_dir && S_ISDIR(st.st_mode)) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (type != inode_file && S_ISREG(st.st_mode)) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (type != inode_fifo && S_ISFIFO(st.st_mode)) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (mode && (st.st_mode & 0777) != mode) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (chowner && (st.st_uid != uid || st.st_gid != gid)) {"
    },
    {
        "line": 141,
        "fullcodeline": "eerror(\"fstat: %s: %s\", path, strerror(errno));"
    },
    {
        "line": 142,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 32,
        "fullcodeline": "einfo(\"%s: creating file\", path);"
    },
    {
        "line": 35,
        "fullcodeline": "u = umask(0);"
    },
    {
        "line": 36,
        "fullcodeline": "fd = openat(dirfd, name, flags, mode);"
    },
    {
        "line": 37,
        "fullcodeline": "umask(u);"
    },
    {
        "line": 44,
        "fullcodeline": "readfd = fd;"
    },
    {
        "line": 86,
        "fullcodeline": "eerror(\"%s: is a directory\", path);"
    },
    {
        "line": 87,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 91,
        "fullcodeline": "eerror(\"%s: is a file\", path);"
    },
    {
        "line": 92,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 96,
        "fullcodeline": "eerror(\"%s: is a fifo\", path);"
    },
    {
        "line": 97,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 112,
        "fullcodeline": "einfo(\"%s: correcting mode\", path);"
    },
    {
        "line": 131,
        "fullcodeline": "einfo(\"%s: correcting owner\", path);"
    },
    {
        "line": 139,
        "fullcodeline": "selinux_util_label(path);"
    },
    {
        "line": 143,
        "fullcodeline": "return -1;"
    },
    {
        "line": 33,
        "fullcodeline": "if (!mode) /* 664 */"
    },
    {
        "line": 38,
        "fullcodeline": "if (fd == -1) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (readfd != -1 && trunc)"
    },
    {
        "line": 98,
        "fullcodeline": "return -1;"
    },
    {
        "line": 102,
        "fullcodeline": "if ((type != inode_dir) && (st.st_nlink > 1)) {"
    },
    {
        "line": 107,
        "fullcodeline": "if (S_ISLNK(st.st_mode)) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (fchmod(readfd, mode)) {"
    },
    {
        "line": 121,
        "fullcodeline": "if ((type != inode_dir) && (st.st_nlink > 1)) {"
    },
    {
        "line": 126,
        "fullcodeline": "if (S_ISLNK(st.st_mode)) {"
    },
    {
        "line": 132,
        "fullcodeline": "if (fchown(readfd, uid, gid)) {"
    },
    {
        "line": 34,
        "fullcodeline": "mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;"
    },
    {
        "line": 39,
        "fullcodeline": "eerror(\"%s: open: %s\", applet, strerror(errno));"
    },
    {
        "line": 43,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 45,
        "fullcodeline": "} else if (type == inode_dir) {"
    },
    {
        "line": 103,
        "fullcodeline": "eerror(\"%s: chmod: Too many hard links to %s\", applet, path);"
    },
    {
        "line": 104,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 108,
        "fullcodeline": "eerror(\"%s: chmod: %s %s\", applet, path, \" is a symbolic link\");"
    },
    {
        "line": 109,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 114,
        "fullcodeline": "eerror(\"%s: chmod: %s\", applet, strerror(errno));"
    },
    {
        "line": 115,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 122,
        "fullcodeline": "eerror(\"%s: chown: %s %s\", applet, \"Too many hard links to\", path);"
    },
    {
        "line": 123,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 127,
        "fullcodeline": "eerror(\"%s: chown: %s %s\", applet, path, \" is a symbolic link\");"
    },
    {
        "line": 128,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 133,
        "fullcodeline": "eerror(\"%s: chown: %s\", applet, strerror(errno));"
    },
    {
        "line": 134,
        "fullcodeline": "close(readfd);"
    },
    {
        "line": 40,
        "fullcodeline": "return -1;"
    },
    {
        "line": 46,
        "fullcodeline": "einfo(\"%s: creating directory\", path);"
    },
    {
        "line": 49,
        "fullcodeline": "u = umask(0);"
    },
    {
        "line": 51,
        "fullcodeline": "r = mkdirat(dirfd, name, mode);"
    },
    {
        "line": 52,
        "fullcodeline": "umask(u);"
    },
    {
        "line": 58,
        "fullcodeline": "readfd = openat(dirfd, name, readflags);"
    },
    {
        "line": 105,
        "fullcodeline": "return -1;"
    },
    {
        "line": 110,
        "fullcodeline": "return -1;"
    },
    {
        "line": 116,
        "fullcodeline": "return -1;"
    },
    {
        "line": 124,
        "fullcodeline": "return -1;"
    },
    {
        "line": 129,
        "fullcodeline": "return -1;"
    },
    {
        "line": 135,
        "fullcodeline": "return -1;"
    },
    {
        "line": 47,
        "fullcodeline": "if (!mode) /* 775 */"
    },
    {
        "line": 53,
        "fullcodeline": "if (r == -1 && errno != EEXIST) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (readfd == -1) {"
    },
    {
        "line": 48,
        "fullcodeline": "mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;"
    },
    {
        "line": 54,
        "fullcodeline": "eerror(\"%s: mkdirat: %s\", applet,"
    },
    {
        "line": 60,
        "fullcodeline": "eerror(\"%s: unable to open directory: %s\", applet,"
    },
    {
        "line": 64,
        "fullcodeline": "} else if (type == inode_fifo) {"
    },
    {
        "line": 55,
        "fullcodeline": "strerror (errno));"
    },
    {
        "line": 56,
        "fullcodeline": "return -1;"
    },
    {
        "line": 61,
        "fullcodeline": "strerror(errno));"
    },
    {
        "line": 62,
        "fullcodeline": "return -1;"
    },
    {
        "line": 65,
        "fullcodeline": "einfo(\"%s: creating fifo\", path);"
    },
    {
        "line": 68,
        "fullcodeline": "u = umask(0);"
    },
    {
        "line": 69,
        "fullcodeline": "r = mkfifo(path, mode);"
    },
    {
        "line": 70,
        "fullcodeline": "umask(u);"
    },
    {
        "line": 76,
        "fullcodeline": "readfd = openat(dirfd, name, readflags);"
    },
    {
        "line": 66,
        "fullcodeline": "if (!mode) /* 600 */"
    },
    {
        "line": 71,
        "fullcodeline": "if (r == -1 && errno != EEXIST) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (readfd == -1) {"
    },
    {
        "line": 67,
        "fullcodeline": "mode = S_IRUSR | S_IWUSR;"
    },
    {
        "line": 72,
        "fullcodeline": "eerror(\"%s: mkfifo: %s\", applet,"
    },
    {
        "line": 78,
        "fullcodeline": "eerror(\"%s: unable to open fifo: %s\", applet,"
    },
    {
        "line": 73,
        "fullcodeline": "strerror (errno));"
    },
    {
        "line": 74,
        "fullcodeline": "return -1;"
    },
    {
        "line": 79,
        "fullcodeline": "strerror(errno));"
    },
    {
        "line": 80,
        "fullcodeline": "return -1;"
    }
]