[
    {
        "line": 4,
        "fullcodeline": "struct file *filp = iocb->ki_filp;"
    },
    {
        "line": 5,
        "fullcodeline": "struct pipe_inode_info *pipe = filp->private_data;"
    },
    {
        "line": 8,
        "fullcodeline": "struct iovec *iov = (struct iovec *)_iov;"
    },
    {
        "line": 12,
        "fullcodeline": "total_len = iov_length(iov, nr_segs);"
    },
    {
        "line": 18,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "__pipe_lock(pipe);"
    },
    {
        "line": 28,
        "fullcodeline": "chars = total_len & (PAGE_SIZE-1); /* size of the last buffer */"
    },
    {
        "line": 172,
        "fullcodeline": "__pipe_unlock(pipe);"
    },
    {
        "line": 14,
        "fullcodeline": "if (unlikely(total_len == 0))"
    },
    {
        "line": 21,
        "fullcodeline": "if (!pipe->readers) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (pipe->nrbufs && chars != 0) {"
    },
    {
        "line": 23,
        "fullcodeline": "ret = -EPIPE;"
    },
    {
        "line": 30,
        "fullcodeline": "int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &"
    },
    {
        "line": 32,
        "fullcodeline": "struct pipe_buffer *buf = pipe->bufs + lastbuf;"
    },
    {
        "line": 33,
        "fullcodeline": "const struct pipe_buf_operations *ops = buf->ops;"
    },
    {
        "line": 34,
        "fullcodeline": "int offset = buf->offset + buf->len;"
    },
    {
        "line": 82,
        "fullcodeline": "bufs = pipe->nrbufs;"
    },
    {
        "line": 167,
        "fullcodeline": "pipe->waiting_writers++;"
    },
    {
        "line": 168,
        "fullcodeline": "pipe_wait(pipe);"
    },
    {
        "line": 169,
        "fullcodeline": "pipe->waiting_writers--;"
    },
    {
        "line": 177,
        "fullcodeline": "if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {"
    },
    {
        "line": 178,
        "fullcodeline": "int err = file_update_time(filp);"
    },
    {
        "line": 76,
        "fullcodeline": "if (!pipe->readers) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (bufs < pipe->buffers) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (bufs < pipe->buffers)"
    },
    {
        "line": 152,
        "fullcodeline": "if (filp->f_flags & O_NONBLOCK) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 174,
        "fullcodeline": "wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);"
    },
    {
        "line": 31,
        "fullcodeline": "(pipe->buffers - 1);"
    },
    {
        "line": 36,
        "fullcodeline": "if (ops->can_merge && offset + chars <= PAGE_SIZE) {"
    },
    {
        "line": 37,
        "fullcodeline": "int error, atomic = 1;"
    },
    {
        "line": 44,
        "fullcodeline": "iov_fault_in_pages_read(iov, chars);"
    },
    {
        "line": 50,
        "fullcodeline": "error = pipe_iov_copy_from_user(offset + addr, iov,"
    },
    {
        "line": 56,
        "fullcodeline": "ret = error;"
    },
    {
        "line": 66,
        "fullcodeline": "total_len -= chars;"
    },
    {
        "line": 67,
        "fullcodeline": "ret = chars;"
    },
    {
        "line": 84,
        "fullcodeline": "int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);"
    },
    {
        "line": 86,
        "fullcodeline": "struct page *page = pipe->tmp_page;"
    },
    {
        "line": 88,
        "fullcodeline": "int error, atomic = 1;"
    },
    {
        "line": 104,
        "fullcodeline": "chars = PAGE_SIZE;"
    },
    {
        "line": 108,
        "fullcodeline": "iov_fault_in_pages_read(iov, chars);"
    },
    {
        "line": 115,
        "fullcodeline": "error = pipe_iov_copy_from_user(src, iov, chars,"
    },
    {
        "line": 131,
        "fullcodeline": "ret += chars;"
    },
    {
        "line": 143,
        "fullcodeline": "pipe->nrbufs = ++bufs;"
    },
    {
        "line": 144,
        "fullcodeline": "pipe->tmp_page = NULL;"
    },
    {
        "line": 146,
        "fullcodeline": "total_len -= chars;"
    },
    {
        "line": 163,
        "fullcodeline": "wake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);"
    },
    {
        "line": 164,
        "fullcodeline": "kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);"
    },
    {
        "line": 180,
        "fullcodeline": "ret = err;"
    },
    {
        "line": 40,
        "fullcodeline": "error = ops->confirm(pipe, buf);"
    },
    {
        "line": 68,
        "fullcodeline": "if (!total_len)"
    },
    {
        "line": 78,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 90,
        "fullcodeline": "if (!page) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (chars > total_len)"
    },
    {
        "line": 122,
        "fullcodeline": "if (unlikely(error)) {"
    },
    {
        "line": 139,
        "fullcodeline": "if (is_packetized(filp)) {"
    },
    {
        "line": 147,
        "fullcodeline": "if (!total_len)"
    },
    {
        "line": 153,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 158,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 47,
        "fullcodeline": "addr = kmap_atomic(buf->page);"
    },
    {
        "line": 79,
        "fullcodeline": "ret = -EPIPE;"
    },
    {
        "line": 91,
        "fullcodeline": "page = alloc_page(GFP_HIGHUSER);"
    },
    {
        "line": 96,
        "fullcodeline": "pipe->tmp_page = page;"
    },
    {
        "line": 106,
        "fullcodeline": "chars = total_len;"
    },
    {
        "line": 111,
        "fullcodeline": "src = kmap_atomic(page);"
    },
    {
        "line": 141,
        "fullcodeline": "buf->flags = PIPE_BUF_FLAG_PACKET;"
    },
    {
        "line": 154,
        "fullcodeline": "ret = -EAGAIN;"
    },
    {
        "line": 159,
        "fullcodeline": "ret = -ERESTARTSYS;"
    },
    {
        "line": 49,
        "fullcodeline": "addr = kmap(buf->page);"
    },
    {
        "line": 55,
        "fullcodeline": "kunmap(buf->page);"
    },
    {
        "line": 113,
        "fullcodeline": "src = kmap(page);"
    },
    {
        "line": 120,
        "fullcodeline": "kunmap(page);"
    },
    {
        "line": 127,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 60,
        "fullcodeline": "atomic = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "if (unlikely(!page)) {"
    },
    {
        "line": 93,
        "fullcodeline": "ret = ret ? : -ENOMEM;"
    },
    {
        "line": 124,
        "fullcodeline": "atomic = 0;"
    },
    {
        "line": 128,
        "fullcodeline": "ret = error;"
    }
]