[
    {
        "line": 4,
        "fullcodeline": "struct file *filp = iocb->ki_filp;"
    },
    {
        "line": 5,
        "fullcodeline": "struct pipe_inode_info *pipe = filp->private_data;"
    },
    {
        "line": 8,
        "fullcodeline": "struct iovec *iov = (struct iovec *)_iov;"
    },
    {
        "line": 12,
        "fullcodeline": "total_len = iov_length(iov, nr_segs);"
    },
    {
        "line": 17,
        "fullcodeline": "iov_iter_init(&iter, iov, nr_segs, total_len, 0);"
    },
    {
        "line": 20,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "__pipe_lock(pipe);"
    },
    {
        "line": 98,
        "fullcodeline": "__pipe_unlock(pipe);"
    },
    {
        "line": 14,
        "fullcodeline": "if (unlikely(total_len == 0))"
    },
    {
        "line": 105,
        "fullcodeline": "if (ret > 0)"
    },
    {
        "line": 23,
        "fullcodeline": "int bufs = pipe->nrbufs;"
    },
    {
        "line": 96,
        "fullcodeline": "pipe_wait(pipe);"
    },
    {
        "line": 72,
        "fullcodeline": "if (!pipe->writers)"
    },
    {
        "line": 74,
        "fullcodeline": "if (!pipe->waiting_writers) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 102,
        "fullcodeline": "wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);"
    },
    {
        "line": 25,
        "fullcodeline": "int curbuf = pipe->curbuf;"
    },
    {
        "line": 26,
        "fullcodeline": "struct pipe_buffer *buf = pipe->bufs + curbuf;"
    },
    {
        "line": 28,
        "fullcodeline": "size_t chars = buf->len;"
    },
    {
        "line": 35,
        "fullcodeline": "error = ops->confirm(pipe, buf);"
    },
    {
        "line": 42,
        "fullcodeline": "written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);"
    },
    {
        "line": 48,
        "fullcodeline": "ret += chars;"
    },
    {
        "line": 49,
        "fullcodeline": "buf->offset += chars;"
    },
    {
        "line": 50,
        "fullcodeline": "buf->len -= chars;"
    },
    {
        "line": 66,
        "fullcodeline": "total_len -= chars;"
    },
    {
        "line": 93,
        "fullcodeline": "wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);"
    },
    {
        "line": 94,
        "fullcodeline": "kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);"
    },
    {
        "line": 32,
        "fullcodeline": "if (chars > total_len)"
    },
    {
        "line": 53,
        "fullcodeline": "if (buf->flags & PIPE_BUF_FLAG_PACKET) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (!buf->len) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (!total_len)"
    },
    {
        "line": 82,
        "fullcodeline": "if (filp->f_flags & O_NONBLOCK) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 33,
        "fullcodeline": "chars = total_len;"
    },
    {
        "line": 43,
        "fullcodeline": "if (unlikely(written < chars)) {"
    },
    {
        "line": 54,
        "fullcodeline": "total_len = chars;"
    },
    {
        "line": 55,
        "fullcodeline": "buf->len = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "buf->ops = NULL;"
    },
    {
        "line": 60,
        "fullcodeline": "ops->release(pipe, buf);"
    },
    {
        "line": 61,
        "fullcodeline": "curbuf = (curbuf + 1) & (pipe->buffers - 1);"
    },
    {
        "line": 62,
        "fullcodeline": "pipe->curbuf = curbuf;"
    },
    {
        "line": 63,
        "fullcodeline": "pipe->nrbufs = --bufs;"
    },
    {
        "line": 83,
        "fullcodeline": "ret = -EAGAIN;"
    },
    {
        "line": 89,
        "fullcodeline": "ret = -ERESTARTSYS;"
    },
    {
        "line": 37,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 44,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 38,
        "fullcodeline": "ret = error;"
    },
    {
        "line": 45,
        "fullcodeline": "ret = -EFAULT;"
    }
]