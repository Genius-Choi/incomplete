[
    {
        "line": 4,
        "fullcodeline": "struct file *filp = iocb->ki_filp;"
    },
    {
        "line": 5,
        "fullcodeline": "struct pipe_inode_info *pipe = filp->private_data;"
    },
    {
        "line": 8,
        "fullcodeline": "struct iovec *iov = (struct iovec *)_iov;"
    },
    {
        "line": 11,
        "fullcodeline": "total_len = iov_length(iov, nr_segs);"
    },
    {
        "line": 17,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "__pipe_lock(pipe);"
    },
    {
        "line": 112,
        "fullcodeline": "__pipe_unlock(pipe);"
    },
    {
        "line": 13,
        "fullcodeline": "if (unlikely(total_len == 0))"
    },
    {
        "line": 119,
        "fullcodeline": "if (ret > 0)"
    },
    {
        "line": 20,
        "fullcodeline": "int bufs = pipe->nrbufs;"
    },
    {
        "line": 110,
        "fullcodeline": "pipe_wait(pipe);"
    },
    {
        "line": 86,
        "fullcodeline": "if (!pipe->writers)"
    },
    {
        "line": 88,
        "fullcodeline": "if (!pipe->waiting_writers) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 116,
        "fullcodeline": "wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);"
    },
    {
        "line": 22,
        "fullcodeline": "int curbuf = pipe->curbuf;"
    },
    {
        "line": 23,
        "fullcodeline": "struct pipe_buffer *buf = pipe->bufs + curbuf;"
    },
    {
        "line": 26,
        "fullcodeline": "size_t chars = buf->len;"
    },
    {
        "line": 32,
        "fullcodeline": "error = ops->confirm(pipe, buf);"
    },
    {
        "line": 39,
        "fullcodeline": "atomic = !iov_fault_in_pages_write(iov, chars);"
    },
    {
        "line": 45,
        "fullcodeline": "error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);"
    },
    {
        "line": 62,
        "fullcodeline": "ret += chars;"
    },
    {
        "line": 63,
        "fullcodeline": "buf->offset += chars;"
    },
    {
        "line": 64,
        "fullcodeline": "buf->len -= chars;"
    },
    {
        "line": 80,
        "fullcodeline": "total_len -= chars;"
    },
    {
        "line": 107,
        "fullcodeline": "wake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);"
    },
    {
        "line": 108,
        "fullcodeline": "kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);"
    },
    {
        "line": 29,
        "fullcodeline": "if (chars > total_len)"
    },
    {
        "line": 50,
        "fullcodeline": "if (unlikely(error)) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (buf->flags & PIPE_BUF_FLAG_PACKET) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (!buf->len) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (!total_len)"
    },
    {
        "line": 96,
        "fullcodeline": "if (filp->f_flags & O_NONBLOCK) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 30,
        "fullcodeline": "chars = total_len;"
    },
    {
        "line": 42,
        "fullcodeline": "addr = kmap_atomic(buf->page);"
    },
    {
        "line": 68,
        "fullcodeline": "total_len = chars;"
    },
    {
        "line": 69,
        "fullcodeline": "buf->len = 0;"
    },
    {
        "line": 73,
        "fullcodeline": "buf->ops = NULL;"
    },
    {
        "line": 74,
        "fullcodeline": "ops->release(pipe, buf);"
    },
    {
        "line": 75,
        "fullcodeline": "curbuf = (curbuf + 1) & (pipe->buffers - 1);"
    },
    {
        "line": 76,
        "fullcodeline": "pipe->curbuf = curbuf;"
    },
    {
        "line": 77,
        "fullcodeline": "pipe->nrbufs = --bufs;"
    },
    {
        "line": 97,
        "fullcodeline": "ret = -EAGAIN;"
    },
    {
        "line": 103,
        "fullcodeline": "ret = -ERESTARTSYS;"
    },
    {
        "line": 34,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 44,
        "fullcodeline": "addr = kmap(buf->page);"
    },
    {
        "line": 49,
        "fullcodeline": "kunmap(buf->page);"
    },
    {
        "line": 58,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 35,
        "fullcodeline": "ret = error;"
    },
    {
        "line": 55,
        "fullcodeline": "atomic = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "ret = error;"
    }
]