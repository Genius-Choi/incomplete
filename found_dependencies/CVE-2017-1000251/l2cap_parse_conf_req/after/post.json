[
    {
        "line": 3,
        "fullcodeline": "struct l2cap_pinfo *pi = l2cap_pi(sk);"
    },
    {
        "line": 4,
        "fullcodeline": "struct l2cap_conf_rsp *rsp = data;"
    },
    {
        "line": 5,
        "fullcodeline": "void *ptr = rsp->data;"
    },
    {
        "line": 6,
        "fullcodeline": "void *req = pi->conf_req;"
    },
    {
        "line": 7,
        "fullcodeline": "int len = pi->conf_len;"
    },
    {
        "line": 10,
        "fullcodeline": "struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };"
    },
    {
        "line": 11,
        "fullcodeline": "u16 mtu = L2CAP_DEFAULT_MTU;"
    },
    {
        "line": 12,
        "fullcodeline": "u16 result = L2CAP_CONF_SUCCESS;"
    },
    {
        "line": 14,
        "fullcodeline": "BT_DBG(\"sk %p\", sk);"
    },
    {
        "line": 126,
        "fullcodeline": "rsp->scid   = cpu_to_le16(pi->dcid);"
    },
    {
        "line": 127,
        "fullcodeline": "rsp->result = cpu_to_le16(result);"
    },
    {
        "line": 128,
        "fullcodeline": "rsp->flags  = cpu_to_le16(0x0000);"
    },
    {
        "line": 16,
        "fullcodeline": "while (len >= L2CAP_CONF_OPT_SIZE) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (pi->num_conf_rsp || pi->num_conf_req)"
    },
    {
        "line": 65,
        "fullcodeline": "if (pi->mode != rfc.mode) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (result == L2CAP_CONF_SUCCESS) {"
    },
    {
        "line": 130,
        "fullcodeline": "return ptr - data;"
    },
    {
        "line": 17,
        "fullcodeline": "len -= l2cap_get_conf_opt(&req, &type, &olen, &val);"
    },
    {
        "line": 19,
        "fullcodeline": "hint  = type & L2CAP_CONF_HINT;"
    },
    {
        "line": 20,
        "fullcodeline": "type &= L2CAP_CONF_MASK;"
    },
    {
        "line": 55,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;"
    },
    {
        "line": 60,
        "fullcodeline": "pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);"
    },
    {
        "line": 66,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 67,
        "fullcodeline": "rfc.mode = pi->mode;"
    },
    {
        "line": 72,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,"
    },
    {
        "line": 87,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);"
    },
    {
        "line": 120,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,"
    },
    {
        "line": 56,
        "fullcodeline": "if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))"
    },
    {
        "line": 69,
        "fullcodeline": "if (pi->num_conf_rsp == 1)"
    },
    {
        "line": 73,
        "fullcodeline": "sizeof(rfc), (unsigned long) &rfc);"
    },
    {
        "line": 81,
        "fullcodeline": "if (mtu < L2CAP_DEFAULT_MIN_MTU)"
    },
    {
        "line": 121,
        "fullcodeline": "sizeof(rfc), (unsigned long) &rfc);"
    },
    {
        "line": 123,
        "fullcodeline": "if (result == L2CAP_CONF_SUCCESS)"
    },
    {
        "line": 24,
        "fullcodeline": "mtu = val;"
    },
    {
        "line": 28,
        "fullcodeline": "pi->flush_to = val;"
    },
    {
        "line": 43,
        "fullcodeline": "result = L2CAP_CONF_UNKNOWN;"
    },
    {
        "line": 44,
        "fullcodeline": "*((u8 *) ptr++) = type;"
    },
    {
        "line": 82,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 91,
        "fullcodeline": "pi->fcs = L2CAP_FCS_NONE;"
    },
    {
        "line": 92,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_MODE_DONE;"
    },
    {
        "line": 96,
        "fullcodeline": "pi->remote_tx_win = rfc.txwin_size;"
    },
    {
        "line": 97,
        "fullcodeline": "pi->remote_max_tx = rfc.max_transmit;"
    },
    {
        "line": 98,
        "fullcodeline": "pi->max_pdu_size = rfc.max_pdu_size;"
    },
    {
        "line": 100,
        "fullcodeline": "rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;"
    },
    {
        "line": 101,
        "fullcodeline": "rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;"
    },
    {
        "line": 103,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_MODE_DONE;"
    },
    {
        "line": 107,
        "fullcodeline": "pi->remote_tx_win = rfc.txwin_size;"
    },
    {
        "line": 108,
        "fullcodeline": "pi->max_pdu_size = rfc.max_pdu_size;"
    },
    {
        "line": 110,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_MODE_DONE;"
    },
    {
        "line": 114,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 116,
        "fullcodeline": "memset(&rfc, 0, sizeof(rfc));"
    },
    {
        "line": 117,
        "fullcodeline": "rfc.mode = pi->mode;"
    },
    {
        "line": 124,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;"
    },
    {
        "line": 35,
        "fullcodeline": "if (olen == sizeof(rfc))"
    },
    {
        "line": 57,
        "fullcodeline": "return -ECONNREFUSED;"
    },
    {
        "line": 70,
        "fullcodeline": "return -ECONNREFUSED;"
    },
    {
        "line": 84,
        "fullcodeline": "pi->omtu = mtu;"
    },
    {
        "line": 85,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_MTU_DONE;"
    },
    {
        "line": 36,
        "fullcodeline": "memcpy(&rfc, (void *) val, olen);"
    }
]