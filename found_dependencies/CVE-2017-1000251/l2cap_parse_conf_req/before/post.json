[
    {
        "line": 3,
        "fullcodeline": "struct l2cap_pinfo *pi = l2cap_pi(sk);"
    },
    {
        "line": 4,
        "fullcodeline": "struct l2cap_conf_rsp *rsp = data;"
    },
    {
        "line": 5,
        "fullcodeline": "void *ptr = rsp->data;"
    },
    {
        "line": 6,
        "fullcodeline": "void *req = pi->conf_req;"
    },
    {
        "line": 7,
        "fullcodeline": "int len = pi->conf_len;"
    },
    {
        "line": 10,
        "fullcodeline": "struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };"
    },
    {
        "line": 11,
        "fullcodeline": "u16 mtu = L2CAP_DEFAULT_MTU;"
    },
    {
        "line": 12,
        "fullcodeline": "u16 result = L2CAP_CONF_SUCCESS;"
    },
    {
        "line": 14,
        "fullcodeline": "BT_DBG(\"sk %p\", sk);"
    },
    {
        "line": 73,
        "fullcodeline": "rsp->scid   = cpu_to_le16(pi->dcid);"
    },
    {
        "line": 74,
        "fullcodeline": "rsp->result = cpu_to_le16(result);"
    },
    {
        "line": 75,
        "fullcodeline": "rsp->flags  = cpu_to_le16(0x0000);"
    },
    {
        "line": 16,
        "fullcodeline": "while (len >= L2CAP_CONF_OPT_SIZE) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (result == L2CAP_CONF_SUCCESS) {"
    },
    {
        "line": 77,
        "fullcodeline": "return ptr - data;"
    },
    {
        "line": 17,
        "fullcodeline": "len -= l2cap_get_conf_opt(&req, &type, &olen, &val);"
    },
    {
        "line": 19,
        "fullcodeline": "hint  = type & L2CAP_CONF_HINT;"
    },
    {
        "line": 20,
        "fullcodeline": "type &= L2CAP_CONF_MASK;"
    },
    {
        "line": 53,
        "fullcodeline": "if (rfc.mode == L2CAP_MODE_BASIC) {"
    },
    {
        "line": 24,
        "fullcodeline": "mtu = val;"
    },
    {
        "line": 28,
        "fullcodeline": "pi->flush_to = val;"
    },
    {
        "line": 43,
        "fullcodeline": "result = L2CAP_CONF_UNKNOWN;"
    },
    {
        "line": 44,
        "fullcodeline": "*((u8 *) ptr++) = type;"
    },
    {
        "line": 61,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);"
    },
    {
        "line": 35,
        "fullcodeline": "if (olen == sizeof(rfc))"
    },
    {
        "line": 54,
        "fullcodeline": "if (mtu < pi->omtu)"
    },
    {
        "line": 63,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 65,
        "fullcodeline": "memset(&rfc, 0, sizeof(rfc));"
    },
    {
        "line": 66,
        "fullcodeline": "rfc.mode = L2CAP_MODE_BASIC;"
    },
    {
        "line": 68,
        "fullcodeline": "l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,"
    },
    {
        "line": 36,
        "fullcodeline": "memcpy(&rfc, (void *) val, olen);"
    },
    {
        "line": 55,
        "fullcodeline": "result = L2CAP_CONF_UNACCEPT;"
    },
    {
        "line": 69,
        "fullcodeline": "sizeof(rfc), (unsigned long) &rfc);"
    },
    {
        "line": 57,
        "fullcodeline": "pi->omtu = mtu;"
    },
    {
        "line": 58,
        "fullcodeline": "pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;"
    }
]