[
    {
        "line": 3,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 4,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "BT_DBG(\"sk %p backlog %d\", sk, backlog);"
    },
    {
        "line": 8,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 50,
        "fullcodeline": "sk->sk_max_ack_backlog = backlog;"
    },
    {
        "line": 51,
        "fullcodeline": "sk->sk_ack_backlog = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "sk->sk_state = BT_LISTEN;"
    },
    {
        "line": 55,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 10,
        "fullcodeline": "if (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (!l2cap_pi(sk)->psm) {"
    },
    {
        "line": 11,
        "fullcodeline": "err = -EBADFD;"
    },
    {
        "line": 15,
        "fullcodeline": "switch (l2cap_pi(sk)->mode) {"
    },
    {
        "line": 24,
        "fullcodeline": "err = -ENOTSUPP;"
    },
    {
        "line": 29,
        "fullcodeline": "bdaddr_t *src = &bt_sk(sk)->src;"
    },
    {
        "line": 32,
        "fullcodeline": "err = -EINVAL;"
    },
    {
        "line": 34,
        "fullcodeline": "write_lock_bh(&l2cap_sk_list.lock);"
    },
    {
        "line": 44,
        "fullcodeline": "write_unlock_bh(&l2cap_sk_list.lock);"
    },
    {
        "line": 36,
        "fullcodeline": "for (psm = 0x1001; psm < 0x1100; psm += 2)"
    },
    {
        "line": 46,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 37,
        "fullcodeline": "if (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {"
    },
    {
        "line": 38,
        "fullcodeline": "l2cap_pi(sk)->psm   = cpu_to_le16(psm);"
    },
    {
        "line": 39,
        "fullcodeline": "l2cap_pi(sk)->sport = cpu_to_le16(psm);"
    },
    {
        "line": 40,
        "fullcodeline": "err = 0;"
    }
]