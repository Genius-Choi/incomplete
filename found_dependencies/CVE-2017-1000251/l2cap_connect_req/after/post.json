[
    {
        "line": 3,
        "fullcodeline": "struct l2cap_chan_list *list = &conn->chan_list;"
    },
    {
        "line": 4,
        "fullcodeline": "struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;"
    },
    {
        "line": 7,
        "fullcodeline": "int result, status = L2CAP_CS_NO_INFO;"
    },
    {
        "line": 9,
        "fullcodeline": "u16 dcid = 0, scid = __le16_to_cpu(req->scid);"
    },
    {
        "line": 10,
        "fullcodeline": "__le16 psm = req->psm;"
    },
    {
        "line": 12,
        "fullcodeline": "BT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", psm, scid);"
    },
    {
        "line": 15,
        "fullcodeline": "parent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);"
    },
    {
        "line": 29,
        "fullcodeline": "result = L2CAP_CR_NO_MEM;"
    },
    {
        "line": 37,
        "fullcodeline": "sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);"
    },
    {
        "line": 41,
        "fullcodeline": "write_lock_bh(&list->lock);"
    },
    {
        "line": 51,
        "fullcodeline": "hci_conn_hold(conn->hcon);"
    },
    {
        "line": 53,
        "fullcodeline": "l2cap_sock_init(sk, parent);"
    },
    {
        "line": 54,
        "fullcodeline": "bacpy(&bt_sk(sk)->src, conn->src);"
    },
    {
        "line": 55,
        "fullcodeline": "bacpy(&bt_sk(sk)->dst, conn->dst);"
    },
    {
        "line": 56,
        "fullcodeline": "l2cap_pi(sk)->psm  = psm;"
    },
    {
        "line": 57,
        "fullcodeline": "l2cap_pi(sk)->dcid = scid;"
    },
    {
        "line": 59,
        "fullcodeline": "__l2cap_chan_add(conn, sk, parent);"
    },
    {
        "line": 62,
        "fullcodeline": "l2cap_sock_set_timer(sk, sk->sk_sndtimeo);"
    },
    {
        "line": 64,
        "fullcodeline": "l2cap_pi(sk)->ident = cmd->ident;"
    },
    {
        "line": 89,
        "fullcodeline": "write_unlock_bh(&list->lock);"
    },
    {
        "line": 92,
        "fullcodeline": "bh_unlock_sock(parent);"
    },
    {
        "line": 95,
        "fullcodeline": "rsp.scid   = cpu_to_le16(scid);"
    },
    {
        "line": 96,
        "fullcodeline": "rsp.dcid   = cpu_to_le16(dcid);"
    },
    {
        "line": 97,
        "fullcodeline": "rsp.result = cpu_to_le16(result);"
    },
    {
        "line": 98,
        "fullcodeline": "rsp.status = cpu_to_le16(status);"
    },
    {
        "line": 99,
        "fullcodeline": "l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);"
    },
    {
        "line": 16,
        "fullcodeline": "if (!parent) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (psm != cpu_to_le16(0x0001) &&"
    },
    {
        "line": 32,
        "fullcodeline": "if (sk_acceptq_is_full(parent)) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (!sk)"
    },
    {
        "line": 44,
        "fullcodeline": "if (__l2cap_get_chan_by_dcid(list, scid)) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {"
    },
    {
        "line": 17,
        "fullcodeline": "result = L2CAP_CR_BAD_PSM;"
    },
    {
        "line": 23,
        "fullcodeline": "!hci_conn_check_link_mode(conn->hcon)) {"
    },
    {
        "line": 24,
        "fullcodeline": "conn->disc_reason = 0x05;"
    },
    {
        "line": 25,
        "fullcodeline": "result = L2CAP_CR_SEC_BLOCK;"
    },
    {
        "line": 33,
        "fullcodeline": "BT_DBG(\"backlog full %d\", parent->sk_ack_backlog);"
    },
    {
        "line": 45,
        "fullcodeline": "write_unlock_bh(&list->lock);"
    },
    {
        "line": 46,
        "fullcodeline": "sock_set_flag(sk, SOCK_ZAPPED);"
    },
    {
        "line": 47,
        "fullcodeline": "l2cap_sock_kill(sk);"
    },
    {
        "line": 60,
        "fullcodeline": "dcid = l2cap_pi(sk)->scid;"
    },
    {
        "line": 103,
        "fullcodeline": "info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);"
    },
    {
        "line": 105,
        "fullcodeline": "conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;"
    },
    {
        "line": 106,
        "fullcodeline": "conn->info_ident = l2cap_get_ident(conn);"
    },
    {
        "line": 108,
        "fullcodeline": "mod_timer(&conn->info_timer, jiffies +"
    },
    {
        "line": 111,
        "fullcodeline": "l2cap_send_cmd(conn, conn->info_ident,"
    },
    {
        "line": 67,
        "fullcodeline": "if (l2cap_check_security(sk)) {"
    },
    {
        "line": 84,
        "fullcodeline": "sk->sk_state = BT_CONNECT2;"
    },
    {
        "line": 85,
        "fullcodeline": "result = L2CAP_CR_PEND;"
    },
    {
        "line": 86,
        "fullcodeline": "status = L2CAP_CS_NO_INFO;"
    },
    {
        "line": 109,
        "fullcodeline": "msecs_to_jiffies(L2CAP_INFO_TIMEOUT));"
    },
    {
        "line": 79,
        "fullcodeline": "sk->sk_state = BT_CONNECT2;"
    },
    {
        "line": 80,
        "fullcodeline": "result = L2CAP_CR_PEND;"
    },
    {
        "line": 81,
        "fullcodeline": "status = L2CAP_CS_AUTHEN_PEND;"
    },
    {
        "line": 68,
        "fullcodeline": "if (bt_sk(sk)->defer_setup) {"
    },
    {
        "line": 69,
        "fullcodeline": "sk->sk_state = BT_CONNECT2;"
    },
    {
        "line": 70,
        "fullcodeline": "result = L2CAP_CR_PEND;"
    },
    {
        "line": 71,
        "fullcodeline": "status = L2CAP_CS_AUTHOR_PEND;"
    },
    {
        "line": 72,
        "fullcodeline": "parent->sk_data_ready(parent, 0);"
    },
    {
        "line": 74,
        "fullcodeline": "sk->sk_state = BT_CONFIG;"
    },
    {
        "line": 75,
        "fullcodeline": "result = L2CAP_CR_SUCCESS;"
    },
    {
        "line": 76,
        "fullcodeline": "status = L2CAP_CS_NO_INFO;"
    }
]