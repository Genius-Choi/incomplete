[
    {
        "line": 3,
        "fullcodeline": "void * pvReturn = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "static uint8_t * pucAlignedHeap = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "vTaskSuspendAll();"
    },
    {
        "line": 37,
        "fullcodeline": "( void ) xTaskResumeAll();"
    },
    {
        "line": 35,
        "fullcodeline": "traceMALLOC( pvReturn, xWantedSize );"
    },
    {
        "line": 9,
        "fullcodeline": "if( xWantedSize & portBYTE_ALIGNMENT_MASK )"
    },
    {
        "line": 19,
        "fullcodeline": "if( pucAlignedHeap == NULL )"
    },
    {
        "line": 26,
        "fullcodeline": "if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&"
    },
    {
        "line": 12,
        "fullcodeline": "xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );"
    },
    {
        "line": 22,
        "fullcodeline": "pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );"
    },
    {
        "line": 27,
        "fullcodeline": "( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */"
    },
    {
        "line": 31,
        "fullcodeline": "pvReturn = pucAlignedHeap + xNextFreeByte;"
    },
    {
        "line": 32,
        "fullcodeline": "xNextFreeByte += xWantedSize;"
    }
]