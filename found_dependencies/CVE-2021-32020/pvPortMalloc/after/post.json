[
    {
        "line": 3,
        "fullcodeline": "void * pvReturn = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "static uint8_t * pucAlignedHeap = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "vTaskSuspendAll();"
    },
    {
        "line": 45,
        "fullcodeline": "( void ) xTaskResumeAll();"
    },
    {
        "line": 43,
        "fullcodeline": "traceMALLOC( pvReturn, xWantedSize );"
    },
    {
        "line": 9,
        "fullcodeline": "if( xWantedSize & portBYTE_ALIGNMENT_MASK )"
    },
    {
        "line": 26,
        "fullcodeline": "if( pucAlignedHeap == NULL )"
    },
    {
        "line": 33,
        "fullcodeline": "if( ( xWantedSize > 0 ) && /* valid size */"
    },
    {
        "line": 29,
        "fullcodeline": "pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );"
    },
    {
        "line": 35,
        "fullcodeline": "( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */"
    },
    {
        "line": 39,
        "fullcodeline": "pvReturn = pucAlignedHeap + xNextFreeByte;"
    },
    {
        "line": 40,
        "fullcodeline": "xNextFreeByte += xWantedSize;"
    },
    {
        "line": 12,
        "fullcodeline": "if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )"
    },
    {
        "line": 34,
        "fullcodeline": "( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&"
    },
    {
        "line": 14,
        "fullcodeline": "xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );"
    },
    {
        "line": 18,
        "fullcodeline": "xWantedSize = 0;"
    }
]