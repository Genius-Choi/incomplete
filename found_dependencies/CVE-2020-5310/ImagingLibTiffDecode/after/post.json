[
    {
        "line": 2,
        "fullcodeline": "TIFFSTATE *clientstate = (TIFFSTATE *)state->context;"
    },
    {
        "line": 3,
        "fullcodeline": "char *filename = \"tempfile.tif\";"
    },
    {
        "line": 4,
        "fullcodeline": "char *mode = \"r\";"
    },
    {
        "line": 10,
        "fullcodeline": "TRACE((\"in decoder: bytes %d\\n\", bytes));"
    },
    {
        "line": 11,
        "fullcodeline": "TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,"
    },
    {
        "line": 13,
        "fullcodeline": "TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,"
    },
    {
        "line": 15,
        "fullcodeline": "TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));"
    },
    {
        "line": 16,
        "fullcodeline": "TRACE((\"Buffer: %p: %c%c%c%c\\n\", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));"
    },
    {
        "line": 17,
        "fullcodeline": "TRACE((\"State->Buffer: %c%c%c%c\\n\", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));"
    },
    {
        "line": 18,
        "fullcodeline": "TRACE((\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\","
    },
    {
        "line": 20,
        "fullcodeline": "TRACE((\"Image: image8 %p, image32 %p, image %p, block %p \\n\","
    },
    {
        "line": 22,
        "fullcodeline": "TRACE((\"Image: pixelsize: %d, linesize %d \\n\","
    },
    {
        "line": 25,
        "fullcodeline": "dump_state(clientstate);"
    },
    {
        "line": 26,
        "fullcodeline": "clientstate->size = bytes;"
    },
    {
        "line": 27,
        "fullcodeline": "clientstate->eof = clientstate->size;"
    },
    {
        "line": 28,
        "fullcodeline": "clientstate->loc = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "clientstate->data = (tdata_t)buffer;"
    },
    {
        "line": 30,
        "fullcodeline": "clientstate->flrealloc = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "dump_state(clientstate);"
    },
    {
        "line": 33,
        "fullcodeline": "TIFFSetWarningHandler(NULL);"
    },
    {
        "line": 34,
        "fullcodeline": "TIFFSetWarningHandlerExt(NULL);"
    },
    {
        "line": 188,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 189,
        "fullcodeline": "TRACE((\"Done Decoding, Returning \\n\"));"
    },
    {
        "line": 49,
        "fullcodeline": "if (!tiff){"
    },
    {
        "line": 66,
        "fullcodeline": "if (TIFFIsTiled(tiff)) {"
    },
    {
        "line": 192,
        "fullcodeline": "return -1;"
    },
    {
        "line": 37,
        "fullcodeline": "TRACE((\"Opening using fd: %d\\n\",clientstate->fp));"
    },
    {
        "line": 38,
        "fullcodeline": "lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end."
    },
    {
        "line": 39,
        "fullcodeline": "tiff = TIFFFdOpen(clientstate->fp, filename, mode);"
    },
    {
        "line": 50,
        "fullcodeline": "TRACE((\"Error, didn't get the tiff\\n\"));"
    },
    {
        "line": 51,
        "fullcodeline": "state->errcode = IMAGING_CODEC_BROKEN;"
    },
    {
        "line": 57,
        "fullcodeline": "uint32 ifdoffset = clientstate->ifd;"
    },
    {
        "line": 58,
        "fullcodeline": "TRACE((\"reading tiff ifd %u\\n\", ifdoffset));"
    },
    {
        "line": 59,
        "fullcodeline": "rv = TIFFSetSubDirectory(tiff, ifdoffset);"
    },
    {
        "line": 71,
        "fullcodeline": "TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);"
    },
    {
        "line": 72,
        "fullcodeline": "TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);"
    },
    {
        "line": 75,
        "fullcodeline": "row_byte_size = (tile_width * state->bits + 7) / 8;"
    },
    {
        "line": 84,
        "fullcodeline": "state->bytes = row_byte_size * tile_length;"
    },
    {
        "line": 88,
        "fullcodeline": "new_data = realloc (state->buffer, state->bytes);"
    },
    {
        "line": 95,
        "fullcodeline": "state->buffer = new_data;"
    },
    {
        "line": 97,
        "fullcodeline": "TRACE((\"TIFFTileSize: %d\\n\", state->bytes));"
    },
    {
        "line": 41,
        "fullcodeline": "TRACE((\"Opening from string\\n\"));"
    },
    {
        "line": 42,
        "fullcodeline": "tiff = TIFFClientOpen(filename, mode,"
    },
    {
        "line": 52,
        "fullcodeline": "return -1;"
    },
    {
        "line": 60,
        "fullcodeline": "if (!rv){"
    },
    {
        "line": 78,
        "fullcodeline": "if (INT_MAX / row_byte_size < tile_length) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (!new_data) {"
    },
    {
        "line": 99,
        "fullcodeline": "for (y = state->yoff; y < state->ysize; y += tile_length) {"
    },
    {
        "line": 132,
        "fullcodeline": "ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);"
    },
    {
        "line": 136,
        "fullcodeline": "TRACE((\"RowsPerStrip: %u \\n\", rows_per_strip));"
    },
    {
        "line": 139,
        "fullcodeline": "row_byte_size = (state->xsize * state->bits + 7) / 8;"
    },
    {
        "line": 148,
        "fullcodeline": "state->bytes = rows_per_strip * row_byte_size;"
    },
    {
        "line": 150,
        "fullcodeline": "TRACE((\"StripSize: %d \\n\", state->bytes));"
    },
    {
        "line": 154,
        "fullcodeline": "new_data = realloc (state->buffer, state->bytes);"
    },
    {
        "line": 161,
        "fullcodeline": "state->buffer = new_data;"
    },
    {
        "line": 61,
        "fullcodeline": "TRACE((\"error in TIFFSetSubDirectory\"));"
    },
    {
        "line": 79,
        "fullcodeline": "state->errcode = IMAGING_CODEC_MEMORY;"
    },
    {
        "line": 80,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 90,
        "fullcodeline": "state->errcode = IMAGING_CODEC_MEMORY;"
    },
    {
        "line": 91,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 133,
        "fullcodeline": "if (ret != 1) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (INT_MAX / row_byte_size < rows_per_strip) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (!new_data) {"
    },
    {
        "line": 163,
        "fullcodeline": "for (; state->y < state->ysize; state->y += rows_per_strip) {"
    },
    {
        "line": 43,
        "fullcodeline": "(thandle_t) clientstate,"
    },
    {
        "line": 62,
        "fullcodeline": "return -1;"
    },
    {
        "line": 81,
        "fullcodeline": "return -1;"
    },
    {
        "line": 92,
        "fullcodeline": "return -1;"
    },
    {
        "line": 100,
        "fullcodeline": "for (x = state->xoff; x < state->xsize; x += tile_width) {"
    },
    {
        "line": 134,
        "fullcodeline": "rows_per_strip = state->ysize;"
    },
    {
        "line": 143,
        "fullcodeline": "state->errcode = IMAGING_CODEC_MEMORY;"
    },
    {
        "line": 144,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 156,
        "fullcodeline": "state->errcode = IMAGING_CODEC_MEMORY;"
    },
    {
        "line": 157,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 171,
        "fullcodeline": "TRACE((\"Decoded strip for row %d \\n\", state->y));"
    },
    {
        "line": 108,
        "fullcodeline": "TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));"
    },
    {
        "line": 110,
        "fullcodeline": "current_tile_width = min(tile_width, state->xsize - x);"
    },
    {
        "line": 145,
        "fullcodeline": "return -1;"
    },
    {
        "line": 158,
        "fullcodeline": "return -1;"
    },
    {
        "line": 164,
        "fullcodeline": "if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {"
    },
    {
        "line": 174,
        "fullcodeline": "for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {"
    },
    {
        "line": 113,
        "fullcodeline": "for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {"
    },
    {
        "line": 165,
        "fullcodeline": "TRACE((\"Decode Error, strip %d\\n\", TIFFComputeStrip(tiff, state->y, 0)));"
    },
    {
        "line": 166,
        "fullcodeline": "state->errcode = IMAGING_CODEC_BROKEN;"
    },
    {
        "line": 167,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 175,
        "fullcodeline": "TRACE((\"Writing data into line %d ; \\n\", state->y + strip_row));"
    },
    {
        "line": 180,
        "fullcodeline": "state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +"
    },
    {
        "line": 102,
        "fullcodeline": "TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));"
    },
    {
        "line": 103,
        "fullcodeline": "state->errcode = IMAGING_CODEC_BROKEN;"
    },
    {
        "line": 104,
        "fullcodeline": "TIFFClose(tiff);"
    },
    {
        "line": 114,
        "fullcodeline": "TRACE((\"Writing tile data at %dx%d using tile_width: %d; \\n\", tile_y + y, x, current_tile_width));"
    },
    {
        "line": 119,
        "fullcodeline": "state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,"
    },
    {
        "line": 168,
        "fullcodeline": "return -1;"
    },
    {
        "line": 182,
        "fullcodeline": "state->buffer + strip_row * row_byte_size,"
    },
    {
        "line": 105,
        "fullcodeline": "return -1;"
    },
    {
        "line": 120,
        "fullcodeline": "state->buffer + tile_y * row_byte_size,"
    },
    {
        "line": 181,
        "fullcodeline": "state->xoff * im->pixelsize,"
    }
]