[
    {
        "line": 5,
        "fullcodeline": "char uuid[16];"
    },
    {
        "line": 7,
        "fullcodeline": "GF_BitStream *uncomp_bs = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "u8 *uncomp_data = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "u32 compressed_size=0;"
    },
    {
        "line": 11,
        "fullcodeline": "Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;"
    },
    {
        "line": 12,
        "fullcodeline": "Bool is_special = GF_TRUE;"
    },
    {
        "line": 15,
        "fullcodeline": "*outBox = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "comp_start = start = gf_bs_get_position(bs);"
    },
    {
        "line": 22,
        "fullcodeline": "uuid_type = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "size = (u64) gf_bs_read_u32(bs);"
    },
    {
        "line": 24,
        "fullcodeline": "hdr_size = 4;"
    },
    {
        "line": 103,
        "fullcodeline": "memset(uuid, 0, 16);"
    },
    {
        "line": 133,
        "fullcodeline": "restore_type = 0;"
    },
    {
        "line": 178,
        "fullcodeline": "end = gf_bs_available(bs);"
    },
    {
        "line": 185,
        "fullcodeline": "newBox->size = size - hdr_size;"
    },
    {
        "line": 187,
        "fullcodeline": "e = gf_isom_full_box_read(newBox, bs);"
    },
    {
        "line": 193,
        "fullcodeline": "newBox->size = size;"
    },
    {
        "line": 194,
        "fullcodeline": "end = gf_bs_get_position(bs);"
    },
    {
        "line": 256,
        "fullcodeline": "*outBox = newBox;"
    },
    {
        "line": 14,
        "fullcodeline": "if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;"
    },
    {
        "line": 16,
        "fullcodeline": "if (gf_bs_available(bs) < 8) {"
    },
    {
        "line": 26,
        "fullcodeline": "if ((size >= 2) && (size <= 4)) {"
    },
    {
        "line": 104,
        "fullcodeline": "if (type == GF_ISOM_BOX_TYPE_UUID ) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (size == 1) {"
    },
    {
        "line": 124,
        "fullcodeline": "if ( size < hdr_size ) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (parent_size && (parent_size<size)) {"
    },
    {
        "line": 134,
        "fullcodeline": "if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {"
    },
    {
        "line": 169,
        "fullcodeline": "if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {"
    },
    {
        "line": 174,
        "fullcodeline": "if (!newBox->type) newBox->type = type;"
    },
    {
        "line": 179,
        "fullcodeline": "if (size - hdr_size > end ) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (!e) e = gf_isom_box_read(newBox, bs);"
    },
    {
        "line": 227,
        "fullcodeline": "if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {"
    },
    {
        "line": 240,
        "fullcodeline": "if (end-start > size) {"
    },
    {
        "line": 27,
        "fullcodeline": "size = 4;"
    },
    {
        "line": 28,
        "fullcodeline": "type = GF_ISOM_BOX_TYPE_VOID;"
    },
    {
        "line": 108,
        "fullcodeline": "gf_bs_read_data(bs, uuid, 16);"
    },
    {
        "line": 109,
        "fullcodeline": "hdr_size += 16;"
    },
    {
        "line": 110,
        "fullcodeline": "uuid_type = gf_isom_solve_uuid_box(uuid);"
    },
    {
        "line": 118,
        "fullcodeline": "size = gf_bs_read_u64(bs);"
    },
    {
        "line": 119,
        "fullcodeline": "hdr_size += 8;"
    },
    {
        "line": 126,
        "fullcodeline": "ERR_EXIT(GF_ISOM_INVALID_FILE);"
    },
    {
        "line": 131,
        "fullcodeline": "ERR_EXIT(GF_ISOM_INVALID_FILE);"
    },
    {
        "line": 135,
        "fullcodeline": "u64 cookie = gf_bs_get_cookie(bs);"
    },
    {
        "line": 136,
        "fullcodeline": "restore_type = type;"
    },
    {
        "line": 146,
        "fullcodeline": "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);"
    },
    {
        "line": 148,
        "fullcodeline": "((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;"
    },
    {
        "line": 170,
        "fullcodeline": "memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);"
    },
    {
        "line": 171,
        "fullcodeline": "((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;"
    },
    {
        "line": 176,
        "fullcodeline": "newBox->type = restore_type;"
    },
    {
        "line": 180,
        "fullcodeline": "newBox->size = size - hdr_size - end;"
    },
    {
        "line": 181,
        "fullcodeline": "*outBox = newBox;"
    },
    {
        "line": 182,
        "fullcodeline": "ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);"
    },
    {
        "line": 197,
        "fullcodeline": "gf_free(uncomp_data);"
    },
    {
        "line": 198,
        "fullcodeline": "gf_bs_del(uncomp_bs);"
    },
    {
        "line": 205,
        "fullcodeline": "size -= 8;"
    },
    {
        "line": 223,
        "fullcodeline": "newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;"
    },
    {
        "line": 228,
        "fullcodeline": "gf_isom_box_del(newBox);"
    },
    {
        "line": 229,
        "fullcodeline": "*outBox = NULL;"
    },
    {
        "line": 245,
        "fullcodeline": "gf_bs_seek(bs, start+size);"
    },
    {
        "line": 30,
        "fullcodeline": "type = gf_bs_read_u32(bs);"
    },
    {
        "line": 31,
        "fullcodeline": "hdr_size += 4;"
    },
    {
        "line": 105,
        "fullcodeline": "if (gf_bs_available(bs) < 16) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (gf_bs_available(bs) < 8) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)"
    },
    {
        "line": 147,
        "fullcodeline": "if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);"
    },
    {
        "line": 190,
        "fullcodeline": "if (gf_opts_get_bool(\"core\", \"no-check\"))"
    },
    {
        "line": 207,
        "fullcodeline": "if (type==GF_ISOM_BOX_TYPE_MOOF) {"
    },
    {
        "line": 230,
        "fullcodeline": "if (is_root_box && (e==GF_SKIP_BOX))"
    },
    {
        "line": 233,
        "fullcodeline": "if (!skip_logs && (e!=GF_SKIP_BOX)) {"
    },
    {
        "line": 241,
        "fullcodeline": "if (!skip_logs) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (type == GF_ISOM_BOX_TYPE_TOTL)"
    },
    {
        "line": 35,
        "fullcodeline": "if (!size) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (is_root_box && (size>=8)) {"
    },
    {
        "line": 106,
        "fullcodeline": "ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);"
    },
    {
        "line": 116,
        "fullcodeline": "ERR_EXIT(GF_ISOM_INCOMPLETE_FILE);"
    },
    {
        "line": 138,
        "fullcodeline": "type = GF_QT_SUBTYPE_RAW_VID;"
    },
    {
        "line": 149,
        "fullcodeline": "} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {"
    },
    {
        "line": 191,
        "fullcodeline": "e = GF_OK;"
    },
    {
        "line": 200,
        "fullcodeline": "gf_isom_box_del(newBox);"
    },
    {
        "line": 201,
        "fullcodeline": "*outBox = NULL;"
    },
    {
        "line": 208,
        "fullcodeline": "((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;"
    },
    {
        "line": 231,
        "fullcodeline": "e = GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 246,
        "fullcodeline": "} else if (end-start < size) {"
    },
    {
        "line": 34,
        "fullcodeline": "size = 12;"
    },
    {
        "line": 50,
        "fullcodeline": "Bool do_uncompress = GF_FALSE;"
    },
    {
        "line": 51,
        "fullcodeline": "u8 *compb = NULL;"
    },
    {
        "line": 52,
        "fullcodeline": "u32 osize = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "u32 otype = type;"
    },
    {
        "line": 140,
        "fullcodeline": "type = GF_QT_SUBTYPE_RAW_AUD;"
    },
    {
        "line": 150,
        "fullcodeline": "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);"
    },
    {
        "line": 152,
        "fullcodeline": "((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;"
    },
    {
        "line": 247,
        "fullcodeline": "u32 to_skip = (u32) (size-(end-start));"
    },
    {
        "line": 254,
        "fullcodeline": "gf_bs_skip_bytes(bs, to_skip);"
    },
    {
        "line": 54,
        "fullcodeline": "if (type==GF_4CC('!', 'm', 'o', 'f')) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);"
    },
    {
        "line": 211,
        "fullcodeline": "else if (type==GF_ISOM_BOX_TYPE_MOOV) {"
    },
    {
        "line": 248,
        "fullcodeline": "if (!skip_logs) {"
    },
    {
        "line": 40,
        "fullcodeline": "size = gf_bs_available(bs) + 8;"
    },
    {
        "line": 55,
        "fullcodeline": "do_uncompress = GF_TRUE;"
    },
    {
        "line": 56,
        "fullcodeline": "type = GF_ISOM_BOX_TYPE_MOOF;"
    },
    {
        "line": 72,
        "fullcodeline": "compb = gf_malloc((u32) (size-8));"
    },
    {
        "line": 75,
        "fullcodeline": "compressed_size = (u32) (size - 8);"
    },
    {
        "line": 76,
        "fullcodeline": "gf_bs_read_data(bs, compb, compressed_size);"
    },
    {
        "line": 77,
        "fullcodeline": "e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);"
    },
    {
        "line": 85,
        "fullcodeline": "size = osize + 8;"
    },
    {
        "line": 86,
        "fullcodeline": "uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);"
    },
    {
        "line": 87,
        "fullcodeline": "bs = uncomp_bs;"
    },
    {
        "line": 88,
        "fullcodeline": "start = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "gf_free(compb);"
    },
    {
        "line": 153,
        "fullcodeline": "} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {"
    },
    {
        "line": 212,
        "fullcodeline": "((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;"
    },
    {
        "line": 213,
        "fullcodeline": "((GF_MovieBox *)newBox)->file_offset = comp_start;"
    },
    {
        "line": 37,
        "fullcodeline": "if (!skip_logs) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (!compb) return GF_OUT_OF_MEM;"
    },
    {
        "line": 154,
        "fullcodeline": "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);"
    },
    {
        "line": 156,
        "fullcodeline": "((GF_TrackGroupTypeBox*)newBox)->group_type = type;"
    },
    {
        "line": 249,
        "fullcodeline": "if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {"
    },
    {
        "line": 38,
        "fullcodeline": "GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));"
    },
    {
        "line": 42,
        "fullcodeline": "if (!skip_logs) {"
    },
    {
        "line": 58,
        "fullcodeline": "else if (type==GF_4CC('!', 'm', 'o', 'v')) {"
    },
    {
        "line": 79,
        "fullcodeline": "gf_free(compb);"
    },
    {
        "line": 80,
        "fullcodeline": "GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));"
    },
    {
        "line": 155,
        "fullcodeline": "if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);"
    },
    {
        "line": 216,
        "fullcodeline": "else if (type==GF_ISOM_BOX_TYPE_SIDX) {"
    },
    {
        "line": 251,
        "fullcodeline": "unused_bytes += to_skip;"
    },
    {
        "line": 59,
        "fullcodeline": "do_uncompress = GF_TRUE;"
    },
    {
        "line": 60,
        "fullcodeline": "type = GF_ISOM_BOX_TYPE_MOOV;"
    },
    {
        "line": 157,
        "fullcodeline": "} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {"
    },
    {
        "line": 217,
        "fullcodeline": "((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;"
    },
    {
        "line": 158,
        "fullcodeline": "newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);"
    },
    {
        "line": 160,
        "fullcodeline": "((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;"
    },
    {
        "line": 62,
        "fullcodeline": "else if (type==GF_4CC('!', 's', 'i', 'x')) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);"
    },
    {
        "line": 163,
        "fullcodeline": "is_special = GF_FALSE;"
    },
    {
        "line": 164,
        "fullcodeline": "newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);"
    },
    {
        "line": 220,
        "fullcodeline": "else if (type==GF_ISOM_BOX_TYPE_SSIX) {"
    },
    {
        "line": 63,
        "fullcodeline": "do_uncompress = GF_TRUE;"
    },
    {
        "line": 64,
        "fullcodeline": "type = GF_ISOM_BOX_TYPE_SIDX;"
    },
    {
        "line": 165,
        "fullcodeline": "if (!newBox) ERR_EXIT(GF_OUT_OF_MEM);"
    },
    {
        "line": 221,
        "fullcodeline": "((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;"
    },
    {
        "line": 66,
        "fullcodeline": "else if (type==GF_4CC('!', 's', 's', 'x')) {"
    },
    {
        "line": 67,
        "fullcodeline": "do_uncompress = GF_TRUE;"
    },
    {
        "line": 68,
        "fullcodeline": "type = GF_ISOM_BOX_TYPE_SSIX;"
    }
]