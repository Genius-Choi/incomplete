[
    {
        "line": 4,
        "fullcodeline": "int len = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "struct loc_track t = { 0, 0, NULL };"
    },
    {
        "line": 14,
        "fullcodeline": "flush_all(s);"
    },
    {
        "line": 16,
        "fullcodeline": "for_each_node_state(node, N_NORMAL_MEMORY) {"
    },
    {
        "line": 77,
        "fullcodeline": "free_loc_track(&t);"
    },
    {
        "line": 9,
        "fullcodeline": "if (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),"
    },
    {
        "line": 17,
        "fullcodeline": "struct kmem_cache_node *n = get_node(s, node);"
    },
    {
        "line": 24,
        "fullcodeline": "spin_lock_irqsave(&n->list_lock, flags);"
    },
    {
        "line": 25,
        "fullcodeline": "list_for_each_entry(page, &n->partial, lru)"
    },
    {
        "line": 26,
        "fullcodeline": "process_slab(&t, s, page, alloc);"
    },
    {
        "line": 27,
        "fullcodeline": "list_for_each_entry(page, &n->full, lru)"
    },
    {
        "line": 28,
        "fullcodeline": "process_slab(&t, s, page, alloc);"
    },
    {
        "line": 29,
        "fullcodeline": "spin_unlock_irqrestore(&n->list_lock, flags);"
    },
    {
        "line": 32,
        "fullcodeline": "for (i = 0; i < t.count; i++) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (!t.count)"
    },
    {
        "line": 21,
        "fullcodeline": "if (!atomic_long_read(&n->nr_slabs))"
    },
    {
        "line": 37,
        "fullcodeline": "len += sprintf(buf + len, \"%7ld \", l->count);"
    },
    {
        "line": 74,
        "fullcodeline": "len += sprintf(buf + len, \"\\n\");"
    },
    {
        "line": 79,
        "fullcodeline": "len += sprintf(buf, \"No data\\n\");"
    },
    {
        "line": 11,
        "fullcodeline": "return sprintf(buf, \"Out of memory\\n\");"
    },
    {
        "line": 35,
        "fullcodeline": "if (len > PAGE_SIZE - 100)"
    },
    {
        "line": 44,
        "fullcodeline": "if (l->sum_time != l->min_time) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (l->min_pid != l->max_pid)"
    },
    {
        "line": 60,
        "fullcodeline": "if (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&"
    },
    {
        "line": 67,
        "fullcodeline": "if (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&"
    },
    {
        "line": 40,
        "fullcodeline": "len += sprint_symbol(buf + len, (unsigned long)l->addr);"
    },
    {
        "line": 45,
        "fullcodeline": "len += sprintf(buf + len, \" age=%ld/%ld/%ld\","
    },
    {
        "line": 54,
        "fullcodeline": "len += sprintf(buf + len, \" pid=%ld-%ld\","
    },
    {
        "line": 61,
        "fullcodeline": "len < PAGE_SIZE - 60) {"
    },
    {
        "line": 62,
        "fullcodeline": "len += sprintf(buf + len, \" cpus=\");"
    },
    {
        "line": 63,
        "fullcodeline": "len += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,"
    },
    {
        "line": 68,
        "fullcodeline": "len < PAGE_SIZE - 60) {"
    },
    {
        "line": 69,
        "fullcodeline": "len += sprintf(buf + len, \" nodes=\");"
    },
    {
        "line": 70,
        "fullcodeline": "len += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,"
    },
    {
        "line": 42,
        "fullcodeline": "len += sprintf(buf + len, \"<not-available>\");"
    },
    {
        "line": 50,
        "fullcodeline": "len += sprintf(buf + len, \" age=%ld\","
    },
    {
        "line": 57,
        "fullcodeline": "len += sprintf(buf + len, \" pid=%ld\","
    },
    {
        "line": 47,
        "fullcodeline": "(long)div_u64(l->sum_time, l->count),"
    }
]