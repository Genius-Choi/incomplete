[
    {
        "line": 3,
        "fullcodeline": "struct epoll_context_s *context = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "ogs_assert(pollset);"
    },
    {
        "line": 8,
        "fullcodeline": "context = pollset->context;"
    },
    {
        "line": 9,
        "fullcodeline": "ogs_assert(context);"
    },
    {
        "line": 11,
        "fullcodeline": "num_of_poll = epoll_wait(context->epfd, context->event_list,"
    },
    {
        "line": 15,
        "fullcodeline": "if (num_of_poll < 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "for (i = 0; i < num_of_poll; i++) {"
    },
    {
        "line": 13,
        "fullcodeline": "timeout == OGS_INFINITE_TIME ? OGS_INFINITE_TIME :"
    },
    {
        "line": 16,
        "fullcodeline": "ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, \"epoll failed\");"
    },
    {
        "line": 23,
        "fullcodeline": "struct epoll_map_s *map = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "short when = 0;"
    },
    {
        "line": 65,
        "fullcodeline": "ogs_assert(fd != INVALID_SOCKET);"
    },
    {
        "line": 67,
        "fullcodeline": "map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));"
    },
    {
        "line": 14,
        "fullcodeline": "ogs_time_to_msec(timeout));"
    },
    {
        "line": 29,
        "fullcodeline": "if (received & EPOLLERR) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (!when)"
    },
    {
        "line": 68,
        "fullcodeline": "if (!map) continue;"
    },
    {
        "line": 70,
        "fullcodeline": "if (map->read && map->write && map->read == map->write) {"
    },
    {
        "line": 18,
        "fullcodeline": "} else if (num_of_poll == 0) {"
    },
    {
        "line": 44,
        "fullcodeline": "when = OGS_POLLIN;"
    },
    {
        "line": 71,
        "fullcodeline": "map->read->handler(when, map->read->fd, map->read->data);"
    },
    {
        "line": 80,
        "fullcodeline": "map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));"
    },
    {
        "line": 46,
        "fullcodeline": "} else if ((received & EPOLLHUP) && !(received & EPOLLRDHUP)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if ((when & OGS_POLLIN) && map->read)"
    },
    {
        "line": 81,
        "fullcodeline": "if (!map) continue;"
    },
    {
        "line": 83,
        "fullcodeline": "if ((when & OGS_POLLOUT) && map->write)"
    },
    {
        "line": 47,
        "fullcodeline": "when = OGS_POLLIN|OGS_POLLOUT;"
    },
    {
        "line": 74,
        "fullcodeline": "map->read->handler(when, map->read->fd, map->read->data);"
    },
    {
        "line": 84,
        "fullcodeline": "map->write->handler(when, map->write->fd, map->write->data);"
    },
    {
        "line": 49,
        "fullcodeline": "if (received & EPOLLIN) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (received & EPOLLOUT) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (received & EPOLLRDHUP) {"
    },
    {
        "line": 50,
        "fullcodeline": "when |= OGS_POLLIN;"
    },
    {
        "line": 53,
        "fullcodeline": "when |= OGS_POLLOUT;"
    },
    {
        "line": 56,
        "fullcodeline": "when |= OGS_POLLIN;"
    },
    {
        "line": 57,
        "fullcodeline": "when &= ~OGS_POLLOUT;"
    }
]