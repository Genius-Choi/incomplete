[
    {
        "line": 7,
        "fullcodeline": "gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;"
    },
    {
        "line": 8,
        "fullcodeline": "gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;"
    },
    {
        "line": 10,
        "fullcodeline": "__attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "} syscall_blocklist[] = {"
    },
    {
        "line": 116,
        "fullcodeline": "} syscall_nondevel_blocklist[] = {"
    },
    {
        "line": 130,
        "fullcodeline": "} socket_family_allowlist[] = {"
    },
    {
        "line": 144,
        "fullcodeline": "seccomp = seccomp_init (SCMP_ACT_ALLOW);"
    },
    {
        "line": 271,
        "fullcodeline": "last_allowed_family = -1;"
    },
    {
        "line": 289,
        "fullcodeline": "seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));"
    },
    {
        "line": 294,
        "fullcodeline": "r = seccomp_export_bpf (seccomp, seccomp_tmpf.fd);"
    },
    {
        "line": 299,
        "fullcodeline": "lseek (seccomp_tmpf.fd, 0, SEEK_SET);"
    },
    {
        "line": 301,
        "fullcodeline": "flatpak_bwrap_add_args_data_fd (bwrap,"
    },
    {
        "line": 145,
        "fullcodeline": "if (!seccomp)"
    },
    {
        "line": 148,
        "fullcodeline": "if (arch != NULL)"
    },
    {
        "line": 204,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)"
    },
    {
        "line": 228,
        "fullcodeline": "if (!multiarch)"
    },
    {
        "line": 245,
        "fullcodeline": "if (!devel)"
    },
    {
        "line": 272,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)"
    },
    {
        "line": 291,
        "fullcodeline": "if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))"
    },
    {
        "line": 296,
        "fullcodeline": "if (r != 0)"
    },
    {
        "line": 302,
        "fullcodeline": "\"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);"
    },
    {
        "line": 52,
        "fullcodeline": "{SCMP_SYS (syslog), EPERM},"
    },
    {
        "line": 54,
        "fullcodeline": "{SCMP_SYS (uselib), EPERM},"
    },
    {
        "line": 56,
        "fullcodeline": "{SCMP_SYS (acct), EPERM},"
    },
    {
        "line": 58,
        "fullcodeline": "{SCMP_SYS (quotactl), EPERM},"
    },
    {
        "line": 61,
        "fullcodeline": "{SCMP_SYS (add_key), EPERM},"
    },
    {
        "line": 62,
        "fullcodeline": "{SCMP_SYS (keyctl), EPERM},"
    },
    {
        "line": 63,
        "fullcodeline": "{SCMP_SYS (request_key), EPERM},"
    },
    {
        "line": 66,
        "fullcodeline": "{SCMP_SYS (move_pages), EPERM},"
    },
    {
        "line": 67,
        "fullcodeline": "{SCMP_SYS (mbind), EPERM},"
    },
    {
        "line": 68,
        "fullcodeline": "{SCMP_SYS (get_mempolicy), EPERM},"
    },
    {
        "line": 69,
        "fullcodeline": "{SCMP_SYS (set_mempolicy), EPERM},"
    },
    {
        "line": 70,
        "fullcodeline": "{SCMP_SYS (migrate_pages), EPERM},"
    },
    {
        "line": 73,
        "fullcodeline": "{SCMP_SYS (unshare), EPERM},"
    },
    {
        "line": 74,
        "fullcodeline": "{SCMP_SYS (setns), EPERM},"
    },
    {
        "line": 75,
        "fullcodeline": "{SCMP_SYS (mount), EPERM},"
    },
    {
        "line": 76,
        "fullcodeline": "{SCMP_SYS (umount), EPERM},"
    },
    {
        "line": 77,
        "fullcodeline": "{SCMP_SYS (umount2), EPERM},"
    },
    {
        "line": 78,
        "fullcodeline": "{SCMP_SYS (pivot_root), EPERM},"
    },
    {
        "line": 79,
        "fullcodeline": "{SCMP_SYS (chroot), EPERM},"
    },
    {
        "line": 86,
        "fullcodeline": "{SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},"
    },
    {
        "line": 90,
        "fullcodeline": "{SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},"
    },
    {
        "line": 96,
        "fullcodeline": "{SCMP_SYS (clone3), ENOSYS},"
    },
    {
        "line": 102,
        "fullcodeline": "{SCMP_SYS (open_tree), ENOSYS},"
    },
    {
        "line": 103,
        "fullcodeline": "{SCMP_SYS (move_mount), ENOSYS},"
    },
    {
        "line": 104,
        "fullcodeline": "{SCMP_SYS (fsopen), ENOSYS},"
    },
    {
        "line": 105,
        "fullcodeline": "{SCMP_SYS (fsconfig), ENOSYS},"
    },
    {
        "line": 106,
        "fullcodeline": "{SCMP_SYS (fsmount), ENOSYS},"
    },
    {
        "line": 107,
        "fullcodeline": "{SCMP_SYS (fspick), ENOSYS},"
    },
    {
        "line": 108,
        "fullcodeline": "{SCMP_SYS (mount_setattr), ENOSYS},"
    },
    {
        "line": 120,
        "fullcodeline": "{SCMP_SYS (perf_event_open), EPERM},"
    },
    {
        "line": 122,
        "fullcodeline": "{SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},"
    },
    {
        "line": 123,
        "fullcodeline": "{SCMP_SYS (ptrace), EPERM}"
    },
    {
        "line": 132,
        "fullcodeline": "{ AF_UNSPEC, 0 },"
    },
    {
        "line": 133,
        "fullcodeline": "{ AF_LOCAL, 0 },"
    },
    {
        "line": 134,
        "fullcodeline": "{ AF_INET, 0 },"
    },
    {
        "line": 135,
        "fullcodeline": "{ AF_INET6, 0 },"
    },
    {
        "line": 136,
        "fullcodeline": "{ AF_NETLINK, 0 },"
    },
    {
        "line": 137,
        "fullcodeline": "{ AF_CAN, FLATPAK_RUN_FLAG_CANBUS },"
    },
    {
        "line": 138,
        "fullcodeline": "{ AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },"
    },
    {
        "line": 150,
        "fullcodeline": "uint32_t arch_id = 0;"
    },
    {
        "line": 151,
        "fullcodeline": "const uint32_t *extra_arches = NULL;"
    },
    {
        "line": 209,
        "fullcodeline": "g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);"
    },
    {
        "line": 234,
        "fullcodeline": "int scall = SCMP_SYS (modify_ldt);"
    },
    {
        "line": 235,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);"
    },
    {
        "line": 286,
        "fullcodeline": "last_allowed_family = family;"
    },
    {
        "line": 146,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));"
    },
    {
        "line": 153,
        "fullcodeline": "if (strcmp (arch, \"i386\") == 0)"
    },
    {
        "line": 176,
        "fullcodeline": "if (arch_id != 0)"
    },
    {
        "line": 221,
        "fullcodeline": "if (r == -EFAULT)"
    },
    {
        "line": 238,
        "fullcodeline": "if (r == -EFAULT)"
    },
    {
        "line": 247,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)"
    },
    {
        "line": 277,
        "fullcodeline": "if (socket_family_allowlist[i].flags_mask != 0 &&"
    },
    {
        "line": 281,
        "fullcodeline": "for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)"
    },
    {
        "line": 297,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf: %s\"), flatpak_seccomp_strerror (r));"
    },
    {
        "line": 155,
        "fullcodeline": "arch_id = SCMP_ARCH_X86;"
    },
    {
        "line": 183,
        "fullcodeline": "r = seccomp_arch_add (seccomp, arch_id);"
    },
    {
        "line": 212,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);"
    },
    {
        "line": 222,
        "fullcodeline": "g_debug (\"Unable to block syscall %d: syscall not known to libseccomp?\","
    },
    {
        "line": 239,
        "fullcodeline": "g_debug (\"Unable to block syscall %d: syscall not known to libseccomp?\","
    },
    {
        "line": 252,
        "fullcodeline": "g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);"
    },
    {
        "line": 278,
        "fullcodeline": "(socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)"
    },
    {
        "line": 284,
        "fullcodeline": "seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));"
    },
    {
        "line": 184,
        "fullcodeline": "if (r < 0 && r != -EEXIST)"
    },
    {
        "line": 187,
        "fullcodeline": "if (multiarch && extra_arches != NULL)"
    },
    {
        "line": 214,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);"
    },
    {
        "line": 260,
        "fullcodeline": "if (r == -EFAULT)"
    },
    {
        "line": 157,
        "fullcodeline": "else if (strcmp (arch, \"x86_64\") == 0)"
    },
    {
        "line": 224,
        "fullcodeline": "else if (r < 0)"
    },
    {
        "line": 241,
        "fullcodeline": "else if (r < 0)"
    },
    {
        "line": 255,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);"
    },
    {
        "line": 261,
        "fullcodeline": "g_debug (\"Unable to block syscall %d: syscall not known to libseccomp?\","
    },
    {
        "line": 159,
        "fullcodeline": "arch_id = SCMP_ARCH_X86_64;"
    },
    {
        "line": 160,
        "fullcodeline": "extra_arches = seccomp_x86_64_extra_arches;"
    },
    {
        "line": 185,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter: %s\"), flatpak_seccomp_strerror (r));"
    },
    {
        "line": 189,
        "fullcodeline": "for (i = 0; extra_arches[i] != 0; i++)"
    },
    {
        "line": 257,
        "fullcodeline": "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);"
    },
    {
        "line": 191,
        "fullcodeline": "r = seccomp_arch_add (seccomp, extra_arches[i]);"
    },
    {
        "line": 225,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d: %s\"), scall, flatpak_seccomp_strerror (r));"
    },
    {
        "line": 242,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d: %s\"), scall, flatpak_seccomp_strerror (r));"
    },
    {
        "line": 263,
        "fullcodeline": "else if (r < 0)"
    },
    {
        "line": 162,
        "fullcodeline": "else if (strcmp (arch, \"arm\") == 0)"
    },
    {
        "line": 192,
        "fullcodeline": "if (r < 0 && r != -EEXIST)"
    },
    {
        "line": 164,
        "fullcodeline": "arch_id = SCMP_ARCH_ARM;"
    },
    {
        "line": 264,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d: %s\"), scall, flatpak_seccomp_strerror (r));"
    },
    {
        "line": 193,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter: %s\"), flatpak_seccomp_strerror (r));"
    }
]