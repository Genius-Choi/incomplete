[
    {
        "line": 3,
        "fullcodeline": "struct ieee80211_sub_if_data *sdata = sta->sdata;"
    },
    {
        "line": 4,
        "fullcodeline": "struct ieee80211_local *local = sdata->local;"
    },
    {
        "line": 6,
        "fullcodeline": "int filtered = 0, buffered = 0, ac;"
    },
    {
        "line": 9,
        "fullcodeline": "clear_sta_flag(sta, WLAN_STA_SP);"
    },
    {
        "line": 11,
        "fullcodeline": "BUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);"
    },
    {
        "line": 12,
        "fullcodeline": "sta->driver_buffered_tids = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "skb_queue_head_init(&pending);"
    },
    {
        "line": 20,
        "fullcodeline": "spin_lock(&sta->ps_lock);"
    },
    {
        "line": 39,
        "fullcodeline": "ieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);"
    },
    {
        "line": 40,
        "fullcodeline": "spin_unlock(&sta->ps_lock);"
    },
    {
        "line": 55,
        "fullcodeline": "local->total_ps_buffered -= buffered;"
    },
    {
        "line": 57,
        "fullcodeline": "sta_info_recalc_tim(sta);"
    },
    {
        "line": 59,
        "fullcodeline": "ps_dbg(sdata,"
    },
    {
        "line": 14,
        "fullcodeline": "if (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))"
    },
    {
        "line": 22,
        "fullcodeline": "for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (!ieee80211_smps_is_restrictive(sta->known_smps_mode,"
    },
    {
        "line": 15,
        "fullcodeline": "drv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);"
    },
    {
        "line": 23,
        "fullcodeline": "int count = skb_queue_len(&pending), tmp;"
    },
    {
        "line": 25,
        "fullcodeline": "spin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);"
    },
    {
        "line": 26,
        "fullcodeline": "skb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);"
    },
    {
        "line": 27,
        "fullcodeline": "spin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);"
    },
    {
        "line": 28,
        "fullcodeline": "tmp = skb_queue_len(&pending);"
    },
    {
        "line": 29,
        "fullcodeline": "filtered += tmp - count;"
    },
    {
        "line": 30,
        "fullcodeline": "count = tmp;"
    },
    {
        "line": 32,
        "fullcodeline": "spin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);"
    },
    {
        "line": 33,
        "fullcodeline": "skb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);"
    },
    {
        "line": 34,
        "fullcodeline": "spin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);"
    },
    {
        "line": 35,
        "fullcodeline": "tmp = skb_queue_len(&pending);"
    },
    {
        "line": 36,
        "fullcodeline": "buffered += tmp - count;"
    },
    {
        "line": 46,
        "fullcodeline": "sta_info_tx_streams(sta) != 1) {"
    },
    {
        "line": 47,
        "fullcodeline": "ht_dbg(sdata,"
    },
    {
        "line": 50,
        "fullcodeline": "ieee80211_send_smps_action(sdata, sdata->bss->req_smps,"
    },
    {
        "line": 45,
        "fullcodeline": "sta->known_smps_mode != sdata->bss->req_smps &&"
    }
]