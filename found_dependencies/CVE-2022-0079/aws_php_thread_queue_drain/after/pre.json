[
    {
        "line": 2,
        "fullcodeline": "assert("
    },
    {
        "line": 5,
        "fullcodeline": "aws_php_task drain_queue[AWS_PHP_THREAD_QUEUE_MAX_DEPTH];"
    },
    {
        "line": 6,
        "fullcodeline": "aws_mutex_lock(&queue->mutex);"
    },
    {
        "line": 8,
        "fullcodeline": "memcpy(drain_queue, queue->queue, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);"
    },
    {
        "line": 9,
        "fullcodeline": "memset(queue->queue, 0, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);"
    },
    {
        "line": 10,
        "fullcodeline": "queue->write_slot = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "aws_mutex_unlock(&queue->mutex);"
    },
    {
        "line": 13,
        "fullcodeline": "bool did_work = false;"
    },
    {
        "line": 3,
        "fullcodeline": "queue->thread_id == aws_thread_current_thread_id() &&"
    },
    {
        "line": 14,
        "fullcodeline": "for (int idx = 0; idx < AWS_PHP_THREAD_QUEUE_MAX_DEPTH; ++idx) {"
    },
    {
        "line": 15,
        "fullcodeline": "aws_php_task *task = &drain_queue[idx];"
    },
    {
        "line": 19,
        "fullcodeline": "did_work = true;"
    },
    {
        "line": 20,
        "fullcodeline": "task->callback(task->data);"
    },
    {
        "line": 16,
        "fullcodeline": "if (!task->callback) {"
    },
    {
        "line": 22,
        "fullcodeline": "task->dtor(task->data);"
    }
]