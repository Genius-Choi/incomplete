[
    {
        "line": 10,
        "fullcodeline": "int\t\tfd = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tnewfile = (flags & READ_NEW);"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tfiltering = (flags & READ_FILTER);"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tread_stdin = (flags & READ_STDIN);"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tread_buffer = (flags & READ_BUFFER);"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tread_fifo = (flags & READ_FIFO);"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\tset_options = newfile || read_buffer"
    },
    {
        "line": 19,
        "fullcodeline": "linenr_T\tread_buf_lnum = 1;\t/* next line to read from curbuf */"
    },
    {
        "line": 20,
        "fullcodeline": "colnr_T\tread_buf_col = 0;\t/* next char to read from this line */"
    },
    {
        "line": 22,
        "fullcodeline": "linenr_T\tlnum = from;"
    },
    {
        "line": 23,
        "fullcodeline": "char_u\t*ptr = NULL;\t\t/* pointer into read buffer */"
    },
    {
        "line": 24,
        "fullcodeline": "char_u\t*buffer = NULL;\t\t/* read buffer */"
    },
    {
        "line": 25,
        "fullcodeline": "char_u\t*new_buffer = NULL;\t/* init to shut up gcc */"
    },
    {
        "line": 26,
        "fullcodeline": "char_u\t*line_start = NULL;\t/* init to shut up gcc */"
    },
    {
        "line": 29,
        "fullcodeline": "long\tsize = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "off_T\tfilesize = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "int\t\tskip_read = FALSE;"
    },
    {
        "line": 41,
        "fullcodeline": "int\t\tsplit = 0;\t\t/* number of split lines */"
    },
    {
        "line": 44,
        "fullcodeline": "int\t\terror = FALSE;\t\t/* errors encountered */"
    },
    {
        "line": 45,
        "fullcodeline": "int\t\tff_error = EOL_UNKNOWN; /* file format with errors */"
    },
    {
        "line": 46,
        "fullcodeline": "long\tlinerest = 0;\t\t/* remaining chars in line */"
    },
    {
        "line": 53,
        "fullcodeline": "int\t\tfileformat = 0;\t\t/* end-of-line format */"
    },
    {
        "line": 54,
        "fullcodeline": "int\t\tkeep_fileformat = FALSE;"
    },
    {
        "line": 57,
        "fullcodeline": "linenr_T\tskip_count = 0;"
    },
    {
        "line": 58,
        "fullcodeline": "linenr_T\tread_count = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "int\t\tmsg_save = msg_scroll;"
    },
    {
        "line": 60,
        "fullcodeline": "linenr_T\tread_no_eol_lnum = 0;   /* non-zero lnum when last line of"
    },
    {
        "line": 65,
        "fullcodeline": "int\t\tfile_rewind = FALSE;"
    },
    {
        "line": 107,
        "fullcodeline": "curbuf->b_no_eol_lnum = 0;\t/* in case it was set by the previous read */"
    },
    {
        "line": 140,
        "fullcodeline": "ex_no_reprint = TRUE;"
    },
    {
        "line": 143,
        "fullcodeline": "need_fileinfo = FALSE;"
    },
    {
        "line": 268,
        "fullcodeline": "set_file_options(set_options, eap);"
    },
    {
        "line": 276,
        "fullcodeline": "check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));"
    },
    {
        "line": 330,
        "fullcodeline": "file_readonly = FALSE;"
    },
    {
        "line": 518,
        "fullcodeline": "++no_wait_return;\t    /* don't wait for return yet */"
    },
    {
        "line": 526,
        "fullcodeline": "try_mac = (vim_strchr(p_ffs, 'm') != NULL);"
    },
    {
        "line": 527,
        "fullcodeline": "try_dos = (vim_strchr(p_ffs, 'd') != NULL);"
    },
    {
        "line": 528,
        "fullcodeline": "try_unix = (vim_strchr(p_ffs, 'x') != NULL);"
    },
    {
        "line": 603,
        "fullcodeline": "wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);"
    },
    {
        "line": 637,
        "fullcodeline": "linecnt = curbuf->b_ml.ml_line_count;"
    },
    {
        "line": 115,
        "fullcodeline": "if (curbuf->b_ffname == NULL"
    },
    {
        "line": 151,
        "fullcodeline": "if (sfname == NULL)"
    },
    {
        "line": 217,
        "fullcodeline": "if (!read_stdin && !read_buffer && !read_fifo)"
    },
    {
        "line": 277,
        "fullcodeline": "if (check_readonly && !readonlymode)"
    },
    {
        "line": 360,
        "fullcodeline": "if (fd < 0)\t\t\t    /* cannot open at all */"
    },
    {
        "line": 463,
        "fullcodeline": "if ((check_readonly && file_readonly) || curbuf->b_help)"
    },
    {
        "line": 488,
        "fullcodeline": "check_need_swap(newfile);"
    },
    {
        "line": 605,
        "fullcodeline": "if (!recoverymode && !filtering && !(flags & READ_DUMMY))"
    },
    {
        "line": 953,
        "fullcodeline": "if (!skip_read)"
    },
    {
        "line": 984,
        "fullcodeline": "while (!error && !got_int)"
    },
    {
        "line": 2099,
        "fullcodeline": "if (error && read_count == 0)"
    },
    {
        "line": 2197,
        "fullcodeline": "if (!recoverymode)"
    },
    {
        "line": 2453,
        "fullcodeline": "if (flags & READ_KEEP_UNDO)"
    },
    {
        "line": 18,
        "fullcodeline": "|| (eap != NULL && eap->read_edit);"
    },
    {
        "line": 119,
        "fullcodeline": "&& !(flags & READ_DUMMY))"
    },
    {
        "line": 152,
        "fullcodeline": "sfname = fname;"
    },
    {
        "line": 194,
        "fullcodeline": "if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)"
    },
    {
        "line": 205,
        "fullcodeline": "if (fname != NULL && *fname != NUL)"
    },
    {
        "line": 207,
        "fullcodeline": "p = fname + STRLEN(fname);"
    },
    {
        "line": 278,
        "fullcodeline": "curbuf->b_p_ro = FALSE;"
    },
    {
        "line": 280,
        "fullcodeline": "if (newfile && !read_stdin && !read_buffer && !read_fifo)"
    },
    {
        "line": 323,
        "fullcodeline": "curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);"
    },
    {
        "line": 371,
        "fullcodeline": "perm = mch_getperm(fname);  /* check if the file exists */"
    },
    {
        "line": 464,
        "fullcodeline": "curbuf->b_p_ro = TRUE;"
    },
    {
        "line": 523,
        "fullcodeline": "curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);"
    },
    {
        "line": 955,
        "fullcodeline": "linerest = 0;"
    },
    {
        "line": 956,
        "fullcodeline": "filesize = 0;"
    },
    {
        "line": 957,
        "fullcodeline": "skip_count = lines_to_skip;"
    },
    {
        "line": 958,
        "fullcodeline": "read_count = lines_to_read;"
    },
    {
        "line": 2093,
        "fullcodeline": "linerest = (long)(ptr - line_start);"
    },
    {
        "line": 2100,
        "fullcodeline": "error = FALSE;"
    },
    {
        "line": 2107,
        "fullcodeline": "if (!error"
    },
    {
        "line": 2110,
        "fullcodeline": "&& !(!curbuf->b_p_bin"
    },
    {
        "line": 2118,
        "fullcodeline": "*ptr = NUL;"
    },
    {
        "line": 2119,
        "fullcodeline": "len = (colnr_T)(ptr - line_start + 1);"
    },
    {
        "line": 2133,
        "fullcodeline": "save_file_ff(curbuf);\t\t/* remember the current file format */"
    },
    {
        "line": 2164,
        "fullcodeline": "if (!read_buffer && !read_stdin)"
    },
    {
        "line": 2211,
        "fullcodeline": "linecnt = curbuf->b_ml.ml_line_count - linecnt;"
    },
    {
        "line": 118,
        "fullcodeline": "&& vim_strchr(p_cpo, CPO_FNAMER) != NULL"
    },
    {
        "line": 121,
        "fullcodeline": "if (set_rw_fname(fname, sfname) == FAIL)"
    },
    {
        "line": 370,
        "fullcodeline": "isdir_f = (mch_isdir(fname));"
    },
    {
        "line": 470,
        "fullcodeline": "if (!read_buffer)"
    },
    {
        "line": 756,
        "fullcodeline": "while (lnum > from)"
    },
    {
        "line": 757,
        "fullcodeline": "ml_delete(lnum--, FALSE);"
    },
    {
        "line": 993,
        "fullcodeline": "if (linerest >= 0x7ff0)"
    },
    {
        "line": 1982,
        "fullcodeline": "if (fileformat == EOL_MAC)"
    },
    {
        "line": 2109,
        "fullcodeline": "&& linerest != 0"
    },
    {
        "line": 2120,
        "fullcodeline": "if (ml_append(lnum, line_start, len, newfile) == FAIL)"
    },
    {
        "line": 2212,
        "fullcodeline": "if (filesize == 0)"
    },
    {
        "line": 2214,
        "fullcodeline": "if (newfile || read_buffer)"
    },
    {
        "line": 2389,
        "fullcodeline": "if (newfile && (error"
    },
    {
        "line": 2408,
        "fullcodeline": "beginline(BL_WHITE | BL_FIX);\t    /* on first non-blank */"
    },
    {
        "line": 117,
        "fullcodeline": "&& fname != NULL"
    },
    {
        "line": 208,
        "fullcodeline": "if (after_pathsep(fname, p) || STRLEN(fname) >= MAXPATHL)"
    },
    {
        "line": 283,
        "fullcodeline": "if (mch_stat((char *)fname, &st) >= 0)"
    },
    {
        "line": 285,
        "fullcodeline": "buf_store_time(curbuf, &st, fname);"
    },
    {
        "line": 286,
        "fullcodeline": "curbuf->b_mtime_read = curbuf->b_mtime;"
    },
    {
        "line": 338,
        "fullcodeline": "else if (!read_buffer)"
    },
    {
        "line": 472,
        "fullcodeline": "curbuf->b_p_eol = TRUE;"
    },
    {
        "line": 473,
        "fullcodeline": "curbuf->b_start_eol = TRUE;"
    },
    {
        "line": 746,
        "fullcodeline": "read_buf_lnum = 1;"
    },
    {
        "line": 747,
        "fullcodeline": "read_buf_col = 0;"
    },
    {
        "line": 996,
        "fullcodeline": "*ptr = NL;\t\t    /* split line by inserting a NL */"
    },
    {
        "line": 997,
        "fullcodeline": "size = 1;"
    },
    {
        "line": 1984,
        "fullcodeline": "--ptr;"
    },
    {
        "line": 2108,
        "fullcodeline": "&& !got_int"
    },
    {
        "line": 2113,
        "fullcodeline": "&& ptr == line_start + 1))"
    },
    {
        "line": 2117,
        "fullcodeline": "curbuf->b_p_eol = FALSE;"
    },
    {
        "line": 2121,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 2200,
        "fullcodeline": "if (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY))"
    },
    {
        "line": 2205,
        "fullcodeline": "ml_delete(curbuf->b_ml.ml_line_count, FALSE);"
    },
    {
        "line": 2209,
        "fullcodeline": "--linecnt;"
    },
    {
        "line": 2213,
        "fullcodeline": "linecnt = 0;"
    },
    {
        "line": 2216,
        "fullcodeline": "redraw_curbuf_later(NOT_VALID);"
    },
    {
        "line": 2239,
        "fullcodeline": "settmode(TMODE_RAW);\t/* set to raw mode */"
    },
    {
        "line": 2260,
        "fullcodeline": "if (!filtering && !(flags & READ_DUMMY))"
    },
    {
        "line": 2263,
        "fullcodeline": "c = FALSE;"
    },
    {
        "line": 2375,
        "fullcodeline": "p = msg_trunc_attr(IObuff, FALSE, 0);"
    },
    {
        "line": 116,
        "fullcodeline": "&& !filtering"
    },
    {
        "line": 315,
        "fullcodeline": "curbuf->b_mtime = 0;"
    },
    {
        "line": 316,
        "fullcodeline": "curbuf->b_mtime_read = 0;"
    },
    {
        "line": 317,
        "fullcodeline": "curbuf->b_orig_size = 0;"
    },
    {
        "line": 318,
        "fullcodeline": "curbuf->b_orig_mode = 0;"
    },
    {
        "line": 616,
        "fullcodeline": "mch_msg(_(\"Vim: Reading from stdin...\\n\"));"
    },
    {
        "line": 777,
        "fullcodeline": "if (eap != NULL && eap->force_ff != 0)"
    },
    {
        "line": 779,
        "fullcodeline": "fileformat = get_fileformat_force(curbuf, eap);"
    },
    {
        "line": 780,
        "fullcodeline": "try_unix = try_dos = try_mac = FALSE;"
    },
    {
        "line": 1282,
        "fullcodeline": "skip_read = FALSE;"
    },
    {
        "line": 1908,
        "fullcodeline": "filesize += size;"
    },
    {
        "line": 2025,
        "fullcodeline": "--ptr;"
    },
    {
        "line": 2112,
        "fullcodeline": "&& *line_start == Ctrl_Z"
    },
    {
        "line": 2128,
        "fullcodeline": "read_no_eol_lnum = ++lnum;"
    },
    {
        "line": 210,
        "fullcodeline": "filemess(curbuf, fname, (char_u *)_(\"Illegal file name\"), 0);"
    },
    {
        "line": 374,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)_(\"is a directory\"), 0);"
    },
    {
        "line": 627,
        "fullcodeline": "else if (!read_buffer)"
    },
    {
        "line": 749,
        "fullcodeline": "else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0)"
    },
    {
        "line": 1354,
        "fullcodeline": "if (size <= 0)"
    },
    {
        "line": 1913,
        "fullcodeline": "if (fileformat == EOL_UNKNOWN)"
    },
    {
        "line": 1985,
        "fullcodeline": "while (++ptr, --size >= 0)"
    },
    {
        "line": 2111,
        "fullcodeline": "&& fileformat == EOL_DOS"
    },
    {
        "line": 2247,
        "fullcodeline": "if (!(flags & READ_DUMMY))"
    },
    {
        "line": 2298,
        "fullcodeline": "STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));"
    },
    {
        "line": 2299,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2304,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2308,
        "fullcodeline": "STRCAT(IObuff, _(\"[CR missing]\"));"
    },
    {
        "line": 2309,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2313,
        "fullcodeline": "STRCAT(IObuff, _(\"[long lines split]\"));"
    },
    {
        "line": 2314,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2352,
        "fullcodeline": "STRCAT(IObuff, _(\"[READ ERRORS]\"));"
    },
    {
        "line": 2353,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2356,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2376,
        "fullcodeline": "if (read_stdin || read_buffer || restart_edit != 0"
    },
    {
        "line": 2377,
        "fullcodeline": "|| (msg_scrolled != 0 && !need_wait_return))"
    },
    {
        "line": 349,
        "fullcodeline": "if (!newfile"
    },
    {
        "line": 351,
        "fullcodeline": "|| (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0)"
    },
    {
        "line": 353,
        "fullcodeline": "file_readonly = TRUE;"
    },
    {
        "line": 355,
        "fullcodeline": "fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);"
    },
    {
        "line": 628,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)\"\", 0);"
    },
    {
        "line": 752,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 1011,
        "fullcodeline": "size = 0x7ff0L - linerest;\t    /* limit buffer to 32K */"
    },
    {
        "line": 1029,
        "fullcodeline": "buffer = new_buffer;"
    },
    {
        "line": 1030,
        "fullcodeline": "ptr = buffer + linerest;"
    },
    {
        "line": 1031,
        "fullcodeline": "line_start = buffer;"
    },
    {
        "line": 1988,
        "fullcodeline": "if ((c = *ptr) != NUL && c != CAR && c != NL)"
    },
    {
        "line": 1990,
        "fullcodeline": "if (c == NUL)"
    },
    {
        "line": 2026,
        "fullcodeline": "while (++ptr, --size >= 0)"
    },
    {
        "line": 2229,
        "fullcodeline": "appended_lines_mark(from, linecnt);"
    },
    {
        "line": 783,
        "fullcodeline": "fileformat = EOL_UNIX;\t\t/* binary: use Unix format */"
    },
    {
        "line": 1014,
        "fullcodeline": "for ( ; size >= 10; size = (long)((long_u)size >> 1))"
    },
    {
        "line": 1020,
        "fullcodeline": "if (new_buffer == NULL)"
    },
    {
        "line": 1217,
        "fullcodeline": "if (size <= 0)"
    },
    {
        "line": 1916,
        "fullcodeline": "if (try_dos || try_unix)"
    },
    {
        "line": 1965,
        "fullcodeline": "if (fileformat == EOL_UNKNOWN && try_mac)"
    },
    {
        "line": 1969,
        "fullcodeline": "if (fileformat == EOL_UNKNOWN)"
    },
    {
        "line": 1991,
        "fullcodeline": "*ptr = NL;\t/* NULs are replaced by newlines! */"
    },
    {
        "line": 2028,
        "fullcodeline": "if ((c = *ptr) != NUL && c != NL)  /* catch most common case */"
    },
    {
        "line": 2030,
        "fullcodeline": "if (c == NUL)"
    },
    {
        "line": 2249,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)_(e_interr), 0);"
    },
    {
        "line": 391,
        "fullcodeline": "curbuf->b_flags |= BF_NEW;"
    },
    {
        "line": 1023,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 1027,
        "fullcodeline": "mch_memmove(new_buffer, ptr - linerest, (size_t)linerest);"
    },
    {
        "line": 1966,
        "fullcodeline": "fileformat = EOL_MAC;"
    },
    {
        "line": 1970,
        "fullcodeline": "fileformat = default_fileformat();"
    },
    {
        "line": 1974,
        "fullcodeline": "set_fileformat(fileformat, OPT_LOCAL);"
    },
    {
        "line": 2031,
        "fullcodeline": "*ptr = NL;\t/* NULs are replaced by newlines! */"
    },
    {
        "line": 784,
        "fullcodeline": "else if (*p_ffs == NUL)"
    },
    {
        "line": 1016,
        "fullcodeline": "if ((new_buffer = lalloc((long_u)(size + linerest + 1),"
    },
    {
        "line": 1022,
        "fullcodeline": "do_outofmem_msg((long_u)(size * 2 + linerest + 1));"
    },
    {
        "line": 1084,
        "fullcodeline": "if (read_buf_lnum > from)"
    },
    {
        "line": 1143,
        "fullcodeline": "size = read_eintr(fd, ptr, size);"
    },
    {
        "line": 1219,
        "fullcodeline": "if (size < 0)\t\t    /* read error */"
    },
    {
        "line": 1922,
        "fullcodeline": "for (p = ptr; p < ptr + size; ++p)"
    },
    {
        "line": 1938,
        "fullcodeline": "if (fileformat == EOL_UNIX && try_mac)"
    },
    {
        "line": 1992,
        "fullcodeline": "else if (c == NL)"
    },
    {
        "line": 2089,
        "fullcodeline": "line_start = ptr + 1;"
    },
    {
        "line": 415,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)_(\"[New File]\"), 0);"
    },
    {
        "line": 785,
        "fullcodeline": "fileformat = get_fileformat(curbuf);/* use format from buffer */"
    },
    {
        "line": 1085,
        "fullcodeline": "size = 0;"
    },
    {
        "line": 1220,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 1920,
        "fullcodeline": "try_mac = 1;"
    },
    {
        "line": 1941,
        "fullcodeline": "try_mac = 1;"
    },
    {
        "line": 1942,
        "fullcodeline": "try_unix = 1;"
    },
    {
        "line": 1993,
        "fullcodeline": "*ptr = CAR;\t/* NLs are replaced by CRs! */"
    },
    {
        "line": 2034,
        "fullcodeline": "if (skip_count == 0)"
    },
    {
        "line": 417,
        "fullcodeline": "filemess(curbuf, sfname,"
    },
    {
        "line": 451,
        "fullcodeline": "_(\"[Permission Denied]\")), 0);"
    },
    {
        "line": 787,
        "fullcodeline": "fileformat = EOL_UNKNOWN;\t\t/* detect from file */"
    },
    {
        "line": 1091,
        "fullcodeline": "tlen = 0;"
    },
    {
        "line": 1924,
        "fullcodeline": "if (*p == NL)"
    },
    {
        "line": 1943,
        "fullcodeline": "for (; p >= ptr && *p != CAR; p--)"
    },
    {
        "line": 1945,
        "fullcodeline": "if (p >= ptr)"
    },
    {
        "line": 2019,
        "fullcodeline": "line_start = ptr + 1;"
    },
    {
        "line": 2036,
        "fullcodeline": "*ptr = NUL;\t\t/* end of line */"
    },
    {
        "line": 2037,
        "fullcodeline": "len = (colnr_T)(ptr - line_start + 1);"
    },
    {
        "line": 2079,
        "fullcodeline": "++lnum;"
    },
    {
        "line": 1996,
        "fullcodeline": "if (skip_count == 0)"
    },
    {
        "line": 2038,
        "fullcodeline": "if (fileformat == EOL_DOS)"
    },
    {
        "line": 2070,
        "fullcodeline": "if (ml_append(lnum, line_start, len, newfile) == FAIL)"
    },
    {
        "line": 2088,
        "fullcodeline": "--skip_count;"
    },
    {
        "line": 418,
        "fullcodeline": "(char_u *)_(\"[New DIRECTORY]\"), 0);"
    },
    {
        "line": 1094,
        "fullcodeline": "p = ml_get(read_buf_lnum) + read_buf_col;"
    },
    {
        "line": 1095,
        "fullcodeline": "n = (int)STRLEN(p);"
    },
    {
        "line": 1947,
        "fullcodeline": "for (p = ptr; p < ptr + size; ++p)"
    },
    {
        "line": 1954,
        "fullcodeline": "if (try_mac > try_unix)"
    },
    {
        "line": 1958,
        "fullcodeline": "else if (fileformat == EOL_UNKNOWN && try_mac == 1)"
    },
    {
        "line": 1961,
        "fullcodeline": "fileformat = default_fileformat();"
    },
    {
        "line": 1998,
        "fullcodeline": "*ptr = NUL;\t    /* end of line */"
    },
    {
        "line": 1999,
        "fullcodeline": "len = (colnr_T) (ptr - line_start + 1);"
    },
    {
        "line": 2009,
        "fullcodeline": "++lnum;"
    },
    {
        "line": 2072,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 2080,
        "fullcodeline": "if (--read_count == 0)"
    },
    {
        "line": 2082,
        "fullcodeline": "error = TRUE;\t    /* break loop */"
    },
    {
        "line": 2083,
        "fullcodeline": "line_start = ptr;\t/* nothing left to write */"
    },
    {
        "line": 1096,
        "fullcodeline": "if ((int)tlen + n + 1 > size)"
    },
    {
        "line": 1926,
        "fullcodeline": "if (!try_unix"
    },
    {
        "line": 1927,
        "fullcodeline": "|| (try_dos && p > ptr && p[-1] == CAR))"
    },
    {
        "line": 1928,
        "fullcodeline": "fileformat = EOL_DOS;"
    },
    {
        "line": 1933,
        "fullcodeline": "else if (*p == CAR && try_mac)"
    },
    {
        "line": 1955,
        "fullcodeline": "fileformat = EOL_MAC;"
    },
    {
        "line": 2000,
        "fullcodeline": "if (ml_append(lnum, line_start, len, newfile) == FAIL)"
    },
    {
        "line": 2018,
        "fullcodeline": "--skip_count;"
    },
    {
        "line": 1101,
        "fullcodeline": "n = (int)(size - tlen);"
    },
    {
        "line": 1109,
        "fullcodeline": "read_buf_col += n;"
    },
    {
        "line": 1930,
        "fullcodeline": "fileformat = EOL_UNIX;"
    },
    {
        "line": 1934,
        "fullcodeline": "try_mac++;"
    },
    {
        "line": 1949,
        "fullcodeline": "if (*p == NL)"
    },
    {
        "line": 2002,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 2010,
        "fullcodeline": "if (--read_count == 0)"
    },
    {
        "line": 2012,
        "fullcodeline": "error = TRUE;\t/* break loop */"
    },
    {
        "line": 2013,
        "fullcodeline": "line_start = ptr;\t/* nothing left to write */"
    },
    {
        "line": 2040,
        "fullcodeline": "if (ptr > line_start && ptr[-1] == CAR)"
    },
    {
        "line": 2043,
        "fullcodeline": "ptr[-1] = NUL;"
    },
    {
        "line": 2044,
        "fullcodeline": "--len;"
    },
    {
        "line": 1102,
        "fullcodeline": "for (ni = 0; ni < n; ++ni)"
    },
    {
        "line": 1123,
        "fullcodeline": "ptr[tlen++] = NL;"
    },
    {
        "line": 1124,
        "fullcodeline": "read_buf_col = 0;"
    },
    {
        "line": 1950,
        "fullcodeline": "try_unix++;"
    },
    {
        "line": 1116,
        "fullcodeline": "for (ni = 0; ni < n; ++ni)"
    },
    {
        "line": 1125,
        "fullcodeline": "if (++read_buf_lnum > from)"
    },
    {
        "line": 2052,
        "fullcodeline": "else if (ff_error != EOL_DOS)"
    },
    {
        "line": 1104,
        "fullcodeline": "if (p[ni] == NL)"
    },
    {
        "line": 1131,
        "fullcodeline": "size = tlen;"
    },
    {
        "line": 1951,
        "fullcodeline": "else if (*p == CAR)"
    },
    {
        "line": 2067,
        "fullcodeline": "ff_error = EOL_DOS;"
    },
    {
        "line": 1105,
        "fullcodeline": "ptr[tlen++] = NUL;"
    },
    {
        "line": 1118,
        "fullcodeline": "if (p[ni] == NL)"
    },
    {
        "line": 1129,
        "fullcodeline": "if (!curbuf->b_p_eol)"
    },
    {
        "line": 1952,
        "fullcodeline": "try_mac++;"
    },
    {
        "line": 1107,
        "fullcodeline": "ptr[tlen++] = p[ni];"
    },
    {
        "line": 1130,
        "fullcodeline": "--tlen;"
    },
    {
        "line": 2054,
        "fullcodeline": "if (   try_unix"
    },
    {
        "line": 2056,
        "fullcodeline": "&& (read_buffer"
    },
    {
        "line": 2060,
        "fullcodeline": "fileformat = EOL_UNIX;"
    },
    {
        "line": 2055,
        "fullcodeline": "&& !read_stdin"
    },
    {
        "line": 2057,
        "fullcodeline": "|| vim_lseek(fd, (off_T)0L, SEEK_SET)"
    },
    {
        "line": 1119,
        "fullcodeline": "ptr[tlen++] = NUL;"
    },
    {
        "line": 2062,
        "fullcodeline": "set_fileformat(EOL_UNIX, OPT_LOCAL);"
    },
    {
        "line": 1121,
        "fullcodeline": "ptr[tlen++] = p[ni];"
    }
]