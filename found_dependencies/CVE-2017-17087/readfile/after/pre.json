[
    {
        "line": 10,
        "fullcodeline": "int\t\tfd = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tnewfile = (flags & READ_NEW);"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tfiltering = (flags & READ_FILTER);"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tread_stdin = (flags & READ_STDIN);"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tread_buffer = (flags & READ_BUFFER);"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tread_fifo = (flags & READ_FIFO);"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\tset_options = newfile || read_buffer"
    },
    {
        "line": 19,
        "fullcodeline": "linenr_T\tread_buf_lnum = 1;\t/* next line to read from curbuf */"
    },
    {
        "line": 20,
        "fullcodeline": "colnr_T\tread_buf_col = 0;\t/* next char to read from this line */"
    },
    {
        "line": 22,
        "fullcodeline": "linenr_T\tlnum = from;"
    },
    {
        "line": 23,
        "fullcodeline": "char_u\t*ptr = NULL;\t\t/* pointer into read buffer */"
    },
    {
        "line": 24,
        "fullcodeline": "char_u\t*buffer = NULL;\t\t/* read buffer */"
    },
    {
        "line": 25,
        "fullcodeline": "char_u\t*new_buffer = NULL;\t/* init to shut up gcc */"
    },
    {
        "line": 26,
        "fullcodeline": "char_u\t*line_start = NULL;\t/* init to shut up gcc */"
    },
    {
        "line": 29,
        "fullcodeline": "long\tsize = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "off_T\tfilesize = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "int\t\tskip_read = FALSE;"
    },
    {
        "line": 41,
        "fullcodeline": "int\t\tsplit = 0;\t\t/* number of split lines */"
    },
    {
        "line": 44,
        "fullcodeline": "int\t\terror = FALSE;\t\t/* errors encountered */"
    },
    {
        "line": 45,
        "fullcodeline": "int\t\tff_error = EOL_UNKNOWN; /* file format with errors */"
    },
    {
        "line": 46,
        "fullcodeline": "long\tlinerest = 0;\t\t/* remaining chars in line */"
    },
    {
        "line": 53,
        "fullcodeline": "int\t\tfileformat = 0;\t\t/* end-of-line format */"
    },
    {
        "line": 54,
        "fullcodeline": "int\t\tkeep_fileformat = FALSE;"
    },
    {
        "line": 57,
        "fullcodeline": "linenr_T\tskip_count = 0;"
    },
    {
        "line": 58,
        "fullcodeline": "linenr_T\tread_count = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "int\t\tmsg_save = msg_scroll;"
    },
    {
        "line": 60,
        "fullcodeline": "linenr_T\tread_no_eol_lnum = 0;   /* non-zero lnum when last line of"
    },
    {
        "line": 65,
        "fullcodeline": "int\t\tfile_rewind = FALSE;"
    },
    {
        "line": 107,
        "fullcodeline": "curbuf->b_no_eol_lnum = 0;\t/* in case it was set by the previous read */"
    },
    {
        "line": 140,
        "fullcodeline": "ex_no_reprint = TRUE;"
    },
    {
        "line": 143,
        "fullcodeline": "need_fileinfo = FALSE;"
    },
    {
        "line": 268,
        "fullcodeline": "set_file_options(set_options, eap);"
    },
    {
        "line": 276,
        "fullcodeline": "check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));"
    },
    {
        "line": 330,
        "fullcodeline": "file_readonly = FALSE;"
    },
    {
        "line": 540,
        "fullcodeline": "++no_wait_return;\t    /* don't wait for return yet */"
    },
    {
        "line": 548,
        "fullcodeline": "try_mac = (vim_strchr(p_ffs, 'm') != NULL);"
    },
    {
        "line": 549,
        "fullcodeline": "try_dos = (vim_strchr(p_ffs, 'd') != NULL);"
    },
    {
        "line": 550,
        "fullcodeline": "try_unix = (vim_strchr(p_ffs, 'x') != NULL);"
    },
    {
        "line": 625,
        "fullcodeline": "wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);"
    },
    {
        "line": 659,
        "fullcodeline": "linecnt = curbuf->b_ml.ml_line_count;"
    },
    {
        "line": 115,
        "fullcodeline": "if (curbuf->b_ffname == NULL"
    },
    {
        "line": 151,
        "fullcodeline": "if (sfname == NULL)"
    },
    {
        "line": 217,
        "fullcodeline": "if (!read_stdin && !read_buffer && !read_fifo)"
    },
    {
        "line": 277,
        "fullcodeline": "if (check_readonly && !readonlymode)"
    },
    {
        "line": 360,
        "fullcodeline": "if (fd < 0)\t\t\t    /* cannot open at all */"
    },
    {
        "line": 463,
        "fullcodeline": "if ((check_readonly && file_readonly) || curbuf->b_help)"
    },
    {
        "line": 488,
        "fullcodeline": "check_need_swap(newfile);"
    },
    {
        "line": 627,
        "fullcodeline": "if (!recoverymode && !filtering && !(flags & READ_DUMMY))"
    },
    {
        "line": 975,
        "fullcodeline": "if (!skip_read)"
    },
    {
        "line": 1006,
        "fullcodeline": "while (!error && !got_int)"
    },
    {
        "line": 2121,
        "fullcodeline": "if (error && read_count == 0)"
    },
    {
        "line": 2219,
        "fullcodeline": "if (!recoverymode)"
    },
    {
        "line": 2475,
        "fullcodeline": "if (flags & READ_KEEP_UNDO)"
    },
    {
        "line": 18,
        "fullcodeline": "|| (eap != NULL && eap->read_edit);"
    },
    {
        "line": 119,
        "fullcodeline": "&& !(flags & READ_DUMMY))"
    },
    {
        "line": 152,
        "fullcodeline": "sfname = fname;"
    },
    {
        "line": 194,
        "fullcodeline": "if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)"
    },
    {
        "line": 205,
        "fullcodeline": "if (fname != NULL && *fname != NUL)"
    },
    {
        "line": 207,
        "fullcodeline": "p = fname + STRLEN(fname);"
    },
    {
        "line": 278,
        "fullcodeline": "curbuf->b_p_ro = FALSE;"
    },
    {
        "line": 280,
        "fullcodeline": "if (newfile && !read_stdin && !read_buffer && !read_fifo)"
    },
    {
        "line": 323,
        "fullcodeline": "curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);"
    },
    {
        "line": 371,
        "fullcodeline": "perm = mch_getperm(fname);  /* check if the file exists */"
    },
    {
        "line": 464,
        "fullcodeline": "curbuf->b_p_ro = TRUE;"
    },
    {
        "line": 545,
        "fullcodeline": "curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);"
    },
    {
        "line": 977,
        "fullcodeline": "linerest = 0;"
    },
    {
        "line": 978,
        "fullcodeline": "filesize = 0;"
    },
    {
        "line": 979,
        "fullcodeline": "skip_count = lines_to_skip;"
    },
    {
        "line": 980,
        "fullcodeline": "read_count = lines_to_read;"
    },
    {
        "line": 2115,
        "fullcodeline": "linerest = (long)(ptr - line_start);"
    },
    {
        "line": 2122,
        "fullcodeline": "error = FALSE;"
    },
    {
        "line": 2129,
        "fullcodeline": "if (!error"
    },
    {
        "line": 2132,
        "fullcodeline": "&& !(!curbuf->b_p_bin"
    },
    {
        "line": 2140,
        "fullcodeline": "*ptr = NUL;"
    },
    {
        "line": 2141,
        "fullcodeline": "len = (colnr_T)(ptr - line_start + 1);"
    },
    {
        "line": 2155,
        "fullcodeline": "save_file_ff(curbuf);\t\t/* remember the current file format */"
    },
    {
        "line": 2186,
        "fullcodeline": "if (!read_buffer && !read_stdin)"
    },
    {
        "line": 2233,
        "fullcodeline": "linecnt = curbuf->b_ml.ml_line_count - linecnt;"
    },
    {
        "line": 118,
        "fullcodeline": "&& vim_strchr(p_cpo, CPO_FNAMER) != NULL"
    },
    {
        "line": 121,
        "fullcodeline": "if (set_rw_fname(fname, sfname) == FAIL)"
    },
    {
        "line": 370,
        "fullcodeline": "isdir_f = (mch_isdir(fname));"
    },
    {
        "line": 470,
        "fullcodeline": "if (!read_buffer)"
    },
    {
        "line": 778,
        "fullcodeline": "while (lnum > from)"
    },
    {
        "line": 779,
        "fullcodeline": "ml_delete(lnum--, FALSE);"
    },
    {
        "line": 1015,
        "fullcodeline": "if (linerest >= 0x7ff0)"
    },
    {
        "line": 2004,
        "fullcodeline": "if (fileformat == EOL_MAC)"
    },
    {
        "line": 2131,
        "fullcodeline": "&& linerest != 0"
    },
    {
        "line": 2142,
        "fullcodeline": "if (ml_append(lnum, line_start, len, newfile) == FAIL)"
    },
    {
        "line": 2234,
        "fullcodeline": "if (filesize == 0)"
    },
    {
        "line": 2236,
        "fullcodeline": "if (newfile || read_buffer)"
    },
    {
        "line": 2411,
        "fullcodeline": "if (newfile && (error"
    },
    {
        "line": 2430,
        "fullcodeline": "beginline(BL_WHITE | BL_FIX);\t    /* on first non-blank */"
    },
    {
        "line": 117,
        "fullcodeline": "&& fname != NULL"
    },
    {
        "line": 208,
        "fullcodeline": "if (after_pathsep(fname, p) || STRLEN(fname) >= MAXPATHL)"
    },
    {
        "line": 283,
        "fullcodeline": "if (mch_stat((char *)fname, &st) >= 0)"
    },
    {
        "line": 285,
        "fullcodeline": "buf_store_time(curbuf, &st, fname);"
    },
    {
        "line": 286,
        "fullcodeline": "curbuf->b_mtime_read = curbuf->b_mtime;"
    },
    {
        "line": 338,
        "fullcodeline": "else if (!read_buffer)"
    },
    {
        "line": 472,
        "fullcodeline": "curbuf->b_p_eol = TRUE;"
    },
    {
        "line": 473,
        "fullcodeline": "curbuf->b_start_eol = TRUE;"
    },
    {
        "line": 768,
        "fullcodeline": "read_buf_lnum = 1;"
    },
    {
        "line": 769,
        "fullcodeline": "read_buf_col = 0;"
    },
    {
        "line": 1018,
        "fullcodeline": "*ptr = NL;\t\t    /* split line by inserting a NL */"
    },
    {
        "line": 1019,
        "fullcodeline": "size = 1;"
    },
    {
        "line": 2006,
        "fullcodeline": "--ptr;"
    },
    {
        "line": 2130,
        "fullcodeline": "&& !got_int"
    },
    {
        "line": 2135,
        "fullcodeline": "&& ptr == line_start + 1))"
    },
    {
        "line": 2139,
        "fullcodeline": "curbuf->b_p_eol = FALSE;"
    },
    {
        "line": 2143,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 2222,
        "fullcodeline": "if (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY))"
    },
    {
        "line": 2227,
        "fullcodeline": "ml_delete(curbuf->b_ml.ml_line_count, FALSE);"
    },
    {
        "line": 2231,
        "fullcodeline": "--linecnt;"
    },
    {
        "line": 2235,
        "fullcodeline": "linecnt = 0;"
    },
    {
        "line": 2238,
        "fullcodeline": "redraw_curbuf_later(NOT_VALID);"
    },
    {
        "line": 2261,
        "fullcodeline": "settmode(TMODE_RAW);\t/* set to raw mode */"
    },
    {
        "line": 2282,
        "fullcodeline": "if (!filtering && !(flags & READ_DUMMY))"
    },
    {
        "line": 2285,
        "fullcodeline": "c = FALSE;"
    },
    {
        "line": 2397,
        "fullcodeline": "p = msg_trunc_attr(IObuff, FALSE, 0);"
    },
    {
        "line": 116,
        "fullcodeline": "&& !filtering"
    },
    {
        "line": 315,
        "fullcodeline": "curbuf->b_mtime = 0;"
    },
    {
        "line": 316,
        "fullcodeline": "curbuf->b_mtime_read = 0;"
    },
    {
        "line": 317,
        "fullcodeline": "curbuf->b_orig_size = 0;"
    },
    {
        "line": 318,
        "fullcodeline": "curbuf->b_orig_mode = 0;"
    },
    {
        "line": 638,
        "fullcodeline": "mch_msg(_(\"Vim: Reading from stdin...\\n\"));"
    },
    {
        "line": 799,
        "fullcodeline": "if (eap != NULL && eap->force_ff != 0)"
    },
    {
        "line": 801,
        "fullcodeline": "fileformat = get_fileformat_force(curbuf, eap);"
    },
    {
        "line": 802,
        "fullcodeline": "try_unix = try_dos = try_mac = FALSE;"
    },
    {
        "line": 1304,
        "fullcodeline": "skip_read = FALSE;"
    },
    {
        "line": 1930,
        "fullcodeline": "filesize += size;"
    },
    {
        "line": 2047,
        "fullcodeline": "--ptr;"
    },
    {
        "line": 2134,
        "fullcodeline": "&& *line_start == Ctrl_Z"
    },
    {
        "line": 2150,
        "fullcodeline": "read_no_eol_lnum = ++lnum;"
    },
    {
        "line": 210,
        "fullcodeline": "filemess(curbuf, fname, (char_u *)_(\"Illegal file name\"), 0);"
    },
    {
        "line": 374,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)_(\"is a directory\"), 0);"
    },
    {
        "line": 649,
        "fullcodeline": "else if (!read_buffer)"
    },
    {
        "line": 771,
        "fullcodeline": "else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0)"
    },
    {
        "line": 1376,
        "fullcodeline": "if (size <= 0)"
    },
    {
        "line": 1935,
        "fullcodeline": "if (fileformat == EOL_UNKNOWN)"
    },
    {
        "line": 2007,
        "fullcodeline": "while (++ptr, --size >= 0)"
    },
    {
        "line": 2133,
        "fullcodeline": "&& fileformat == EOL_DOS"
    },
    {
        "line": 2269,
        "fullcodeline": "if (!(flags & READ_DUMMY))"
    },
    {
        "line": 2320,
        "fullcodeline": "STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));"
    },
    {
        "line": 2321,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2326,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2330,
        "fullcodeline": "STRCAT(IObuff, _(\"[CR missing]\"));"
    },
    {
        "line": 2331,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2335,
        "fullcodeline": "STRCAT(IObuff, _(\"[long lines split]\"));"
    },
    {
        "line": 2336,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2374,
        "fullcodeline": "STRCAT(IObuff, _(\"[READ ERRORS]\"));"
    },
    {
        "line": 2375,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2378,
        "fullcodeline": "c = TRUE;"
    },
    {
        "line": 2398,
        "fullcodeline": "if (read_stdin || read_buffer || restart_edit != 0"
    },
    {
        "line": 2399,
        "fullcodeline": "|| (msg_scrolled != 0 && !need_wait_return))"
    },
    {
        "line": 349,
        "fullcodeline": "if (!newfile"
    },
    {
        "line": 351,
        "fullcodeline": "|| (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0)"
    },
    {
        "line": 353,
        "fullcodeline": "file_readonly = TRUE;"
    },
    {
        "line": 355,
        "fullcodeline": "fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);"
    },
    {
        "line": 650,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)\"\", 0);"
    },
    {
        "line": 774,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 1033,
        "fullcodeline": "size = 0x7ff0L - linerest;\t    /* limit buffer to 32K */"
    },
    {
        "line": 1051,
        "fullcodeline": "buffer = new_buffer;"
    },
    {
        "line": 1052,
        "fullcodeline": "ptr = buffer + linerest;"
    },
    {
        "line": 1053,
        "fullcodeline": "line_start = buffer;"
    },
    {
        "line": 2010,
        "fullcodeline": "if ((c = *ptr) != NUL && c != CAR && c != NL)"
    },
    {
        "line": 2012,
        "fullcodeline": "if (c == NUL)"
    },
    {
        "line": 2048,
        "fullcodeline": "while (++ptr, --size >= 0)"
    },
    {
        "line": 2251,
        "fullcodeline": "appended_lines_mark(from, linecnt);"
    },
    {
        "line": 805,
        "fullcodeline": "fileformat = EOL_UNIX;\t\t/* binary: use Unix format */"
    },
    {
        "line": 1036,
        "fullcodeline": "for ( ; size >= 10; size = (long)((long_u)size >> 1))"
    },
    {
        "line": 1042,
        "fullcodeline": "if (new_buffer == NULL)"
    },
    {
        "line": 1239,
        "fullcodeline": "if (size <= 0)"
    },
    {
        "line": 1938,
        "fullcodeline": "if (try_dos || try_unix)"
    },
    {
        "line": 1987,
        "fullcodeline": "if (fileformat == EOL_UNKNOWN && try_mac)"
    },
    {
        "line": 1991,
        "fullcodeline": "if (fileformat == EOL_UNKNOWN)"
    },
    {
        "line": 2013,
        "fullcodeline": "*ptr = NL;\t/* NULs are replaced by newlines! */"
    },
    {
        "line": 2050,
        "fullcodeline": "if ((c = *ptr) != NUL && c != NL)  /* catch most common case */"
    },
    {
        "line": 2052,
        "fullcodeline": "if (c == NUL)"
    },
    {
        "line": 2271,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)_(e_interr), 0);"
    },
    {
        "line": 391,
        "fullcodeline": "curbuf->b_flags |= BF_NEW;"
    },
    {
        "line": 1045,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 1049,
        "fullcodeline": "mch_memmove(new_buffer, ptr - linerest, (size_t)linerest);"
    },
    {
        "line": 1988,
        "fullcodeline": "fileformat = EOL_MAC;"
    },
    {
        "line": 1992,
        "fullcodeline": "fileformat = default_fileformat();"
    },
    {
        "line": 1996,
        "fullcodeline": "set_fileformat(fileformat, OPT_LOCAL);"
    },
    {
        "line": 2053,
        "fullcodeline": "*ptr = NL;\t/* NULs are replaced by newlines! */"
    },
    {
        "line": 806,
        "fullcodeline": "else if (*p_ffs == NUL)"
    },
    {
        "line": 1038,
        "fullcodeline": "if ((new_buffer = lalloc((long_u)(size + linerest + 1),"
    },
    {
        "line": 1044,
        "fullcodeline": "do_outofmem_msg((long_u)(size * 2 + linerest + 1));"
    },
    {
        "line": 1106,
        "fullcodeline": "if (read_buf_lnum > from)"
    },
    {
        "line": 1165,
        "fullcodeline": "size = read_eintr(fd, ptr, size);"
    },
    {
        "line": 1241,
        "fullcodeline": "if (size < 0)\t\t    /* read error */"
    },
    {
        "line": 1944,
        "fullcodeline": "for (p = ptr; p < ptr + size; ++p)"
    },
    {
        "line": 1960,
        "fullcodeline": "if (fileformat == EOL_UNIX && try_mac)"
    },
    {
        "line": 2014,
        "fullcodeline": "else if (c == NL)"
    },
    {
        "line": 2111,
        "fullcodeline": "line_start = ptr + 1;"
    },
    {
        "line": 415,
        "fullcodeline": "filemess(curbuf, sfname, (char_u *)_(\"[New File]\"), 0);"
    },
    {
        "line": 807,
        "fullcodeline": "fileformat = get_fileformat(curbuf);/* use format from buffer */"
    },
    {
        "line": 1107,
        "fullcodeline": "size = 0;"
    },
    {
        "line": 1242,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 1942,
        "fullcodeline": "try_mac = 1;"
    },
    {
        "line": 1963,
        "fullcodeline": "try_mac = 1;"
    },
    {
        "line": 1964,
        "fullcodeline": "try_unix = 1;"
    },
    {
        "line": 2015,
        "fullcodeline": "*ptr = CAR;\t/* NLs are replaced by CRs! */"
    },
    {
        "line": 2056,
        "fullcodeline": "if (skip_count == 0)"
    },
    {
        "line": 417,
        "fullcodeline": "filemess(curbuf, sfname,"
    },
    {
        "line": 451,
        "fullcodeline": "_(\"[Permission Denied]\")), 0);"
    },
    {
        "line": 809,
        "fullcodeline": "fileformat = EOL_UNKNOWN;\t\t/* detect from file */"
    },
    {
        "line": 1113,
        "fullcodeline": "tlen = 0;"
    },
    {
        "line": 1946,
        "fullcodeline": "if (*p == NL)"
    },
    {
        "line": 1965,
        "fullcodeline": "for (; p >= ptr && *p != CAR; p--)"
    },
    {
        "line": 1967,
        "fullcodeline": "if (p >= ptr)"
    },
    {
        "line": 2041,
        "fullcodeline": "line_start = ptr + 1;"
    },
    {
        "line": 2058,
        "fullcodeline": "*ptr = NUL;\t\t/* end of line */"
    },
    {
        "line": 2059,
        "fullcodeline": "len = (colnr_T)(ptr - line_start + 1);"
    },
    {
        "line": 2101,
        "fullcodeline": "++lnum;"
    },
    {
        "line": 2018,
        "fullcodeline": "if (skip_count == 0)"
    },
    {
        "line": 2060,
        "fullcodeline": "if (fileformat == EOL_DOS)"
    },
    {
        "line": 2092,
        "fullcodeline": "if (ml_append(lnum, line_start, len, newfile) == FAIL)"
    },
    {
        "line": 2110,
        "fullcodeline": "--skip_count;"
    },
    {
        "line": 418,
        "fullcodeline": "(char_u *)_(\"[New DIRECTORY]\"), 0);"
    },
    {
        "line": 1116,
        "fullcodeline": "p = ml_get(read_buf_lnum) + read_buf_col;"
    },
    {
        "line": 1117,
        "fullcodeline": "n = (int)STRLEN(p);"
    },
    {
        "line": 1969,
        "fullcodeline": "for (p = ptr; p < ptr + size; ++p)"
    },
    {
        "line": 1976,
        "fullcodeline": "if (try_mac > try_unix)"
    },
    {
        "line": 1980,
        "fullcodeline": "else if (fileformat == EOL_UNKNOWN && try_mac == 1)"
    },
    {
        "line": 1983,
        "fullcodeline": "fileformat = default_fileformat();"
    },
    {
        "line": 2020,
        "fullcodeline": "*ptr = NUL;\t    /* end of line */"
    },
    {
        "line": 2021,
        "fullcodeline": "len = (colnr_T) (ptr - line_start + 1);"
    },
    {
        "line": 2031,
        "fullcodeline": "++lnum;"
    },
    {
        "line": 2094,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 2102,
        "fullcodeline": "if (--read_count == 0)"
    },
    {
        "line": 2104,
        "fullcodeline": "error = TRUE;\t    /* break loop */"
    },
    {
        "line": 2105,
        "fullcodeline": "line_start = ptr;\t/* nothing left to write */"
    },
    {
        "line": 1118,
        "fullcodeline": "if ((int)tlen + n + 1 > size)"
    },
    {
        "line": 1948,
        "fullcodeline": "if (!try_unix"
    },
    {
        "line": 1949,
        "fullcodeline": "|| (try_dos && p > ptr && p[-1] == CAR))"
    },
    {
        "line": 1950,
        "fullcodeline": "fileformat = EOL_DOS;"
    },
    {
        "line": 1955,
        "fullcodeline": "else if (*p == CAR && try_mac)"
    },
    {
        "line": 1977,
        "fullcodeline": "fileformat = EOL_MAC;"
    },
    {
        "line": 2022,
        "fullcodeline": "if (ml_append(lnum, line_start, len, newfile) == FAIL)"
    },
    {
        "line": 2040,
        "fullcodeline": "--skip_count;"
    },
    {
        "line": 1123,
        "fullcodeline": "n = (int)(size - tlen);"
    },
    {
        "line": 1131,
        "fullcodeline": "read_buf_col += n;"
    },
    {
        "line": 1952,
        "fullcodeline": "fileformat = EOL_UNIX;"
    },
    {
        "line": 1956,
        "fullcodeline": "try_mac++;"
    },
    {
        "line": 1971,
        "fullcodeline": "if (*p == NL)"
    },
    {
        "line": 2024,
        "fullcodeline": "error = TRUE;"
    },
    {
        "line": 2032,
        "fullcodeline": "if (--read_count == 0)"
    },
    {
        "line": 2034,
        "fullcodeline": "error = TRUE;\t/* break loop */"
    },
    {
        "line": 2035,
        "fullcodeline": "line_start = ptr;\t/* nothing left to write */"
    },
    {
        "line": 2062,
        "fullcodeline": "if (ptr > line_start && ptr[-1] == CAR)"
    },
    {
        "line": 2065,
        "fullcodeline": "ptr[-1] = NUL;"
    },
    {
        "line": 2066,
        "fullcodeline": "--len;"
    },
    {
        "line": 1124,
        "fullcodeline": "for (ni = 0; ni < n; ++ni)"
    },
    {
        "line": 1145,
        "fullcodeline": "ptr[tlen++] = NL;"
    },
    {
        "line": 1146,
        "fullcodeline": "read_buf_col = 0;"
    },
    {
        "line": 1972,
        "fullcodeline": "try_unix++;"
    },
    {
        "line": 1138,
        "fullcodeline": "for (ni = 0; ni < n; ++ni)"
    },
    {
        "line": 1147,
        "fullcodeline": "if (++read_buf_lnum > from)"
    },
    {
        "line": 2074,
        "fullcodeline": "else if (ff_error != EOL_DOS)"
    },
    {
        "line": 1126,
        "fullcodeline": "if (p[ni] == NL)"
    },
    {
        "line": 1153,
        "fullcodeline": "size = tlen;"
    },
    {
        "line": 1973,
        "fullcodeline": "else if (*p == CAR)"
    },
    {
        "line": 2089,
        "fullcodeline": "ff_error = EOL_DOS;"
    },
    {
        "line": 1127,
        "fullcodeline": "ptr[tlen++] = NUL;"
    },
    {
        "line": 1140,
        "fullcodeline": "if (p[ni] == NL)"
    },
    {
        "line": 1151,
        "fullcodeline": "if (!curbuf->b_p_eol)"
    },
    {
        "line": 1974,
        "fullcodeline": "try_mac++;"
    },
    {
        "line": 1129,
        "fullcodeline": "ptr[tlen++] = p[ni];"
    },
    {
        "line": 1152,
        "fullcodeline": "--tlen;"
    },
    {
        "line": 2076,
        "fullcodeline": "if (   try_unix"
    },
    {
        "line": 2078,
        "fullcodeline": "&& (read_buffer"
    },
    {
        "line": 2082,
        "fullcodeline": "fileformat = EOL_UNIX;"
    },
    {
        "line": 2077,
        "fullcodeline": "&& !read_stdin"
    },
    {
        "line": 2079,
        "fullcodeline": "|| vim_lseek(fd, (off_T)0L, SEEK_SET)"
    },
    {
        "line": 1141,
        "fullcodeline": "ptr[tlen++] = NUL;"
    },
    {
        "line": 2084,
        "fullcodeline": "set_fileformat(EOL_UNIX, OPT_LOCAL);"
    },
    {
        "line": 1143,
        "fullcodeline": "ptr[tlen++] = p[ni];"
    }
]