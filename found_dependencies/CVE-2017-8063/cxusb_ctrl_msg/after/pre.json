[
    {
        "line": 4,
        "fullcodeline": "struct cxusb_state *st = d->priv;"
    },
    {
        "line": 17,
        "fullcodeline": "mutex_lock(&d->data_mutex);"
    },
    {
        "line": 18,
        "fullcodeline": "st->data[0] = cmd;"
    },
    {
        "line": 19,
        "fullcodeline": "memcpy(&st->data[1], wbuf, wlen);"
    },
    {
        "line": 20,
        "fullcodeline": "ret = dvb_usb_generic_rw(d, st->data, 1 + wlen, st->data, rlen, 0);"
    },
    {
        "line": 7,
        "fullcodeline": "if (1 + wlen > MAX_XFER_SIZE) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (rlen > MAX_XFER_SIZE) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (!ret && rbuf && rlen)"
    },
    {
        "line": 8,
        "fullcodeline": "warn(\"i2c wr: len=%d is too big!\\n\", wlen);"
    },
    {
        "line": 9,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 14,
        "fullcodeline": "return -EOPNOTSUPP;"
    }
]