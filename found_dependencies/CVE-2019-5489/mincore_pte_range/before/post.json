[
    {
        "line": 5,
        "fullcodeline": "struct vm_area_struct *vma = walk->vma;"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned char *vec = walk->private;"
    },
    {
        "line": 8,
        "fullcodeline": "int nr = (end - addr) >> PAGE_SHIFT;"
    },
    {
        "line": 10,
        "fullcodeline": "ptl = pmd_trans_huge_lock(pmd, vma);"
    },
    {
        "line": 22,
        "fullcodeline": "ptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);"
    },
    {
        "line": 52,
        "fullcodeline": "pte_unmap_unlock(ptep - 1, ptl);"
    },
    {
        "line": 54,
        "fullcodeline": "walk->private += nr;"
    },
    {
        "line": 55,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 17,
        "fullcodeline": "if (pmd_trans_unstable(pmd)) {"
    },
    {
        "line": 23,
        "fullcodeline": "for (; addr != end; ptep++, addr += PAGE_SIZE) {"
    },
    {
        "line": 12,
        "fullcodeline": "memset(vec, 1, nr);"
    },
    {
        "line": 13,
        "fullcodeline": "spin_unlock(ptl);"
    },
    {
        "line": 18,
        "fullcodeline": "__mincore_unmapped_range(addr, end, vma, vec);"
    },
    {
        "line": 50,
        "fullcodeline": "vec++;"
    },
    {
        "line": 26,
        "fullcodeline": "if (pte_none(pte))"
    },
    {
        "line": 27,
        "fullcodeline": "__mincore_unmapped_range(addr, addr + PAGE_SIZE,"
    },
    {
        "line": 29,
        "fullcodeline": "else if (pte_present(pte))"
    },
    {
        "line": 30,
        "fullcodeline": "*vec = 1;"
    },
    {
        "line": 32,
        "fullcodeline": "swp_entry_t entry = pte_to_swp_entry(pte);"
    },
    {
        "line": 34,
        "fullcodeline": "if (non_swap_entry(entry)) {"
    },
    {
        "line": 39,
        "fullcodeline": "*vec = 1;"
    },
    {
        "line": 45,
        "fullcodeline": "WARN_ON(1);"
    },
    {
        "line": 46,
        "fullcodeline": "*vec = 1;"
    }
]