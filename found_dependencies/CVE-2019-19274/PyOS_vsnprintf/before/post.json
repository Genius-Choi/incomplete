[
    {
        "line": 10,
        "fullcodeline": "assert(str != NULL);"
    },
    {
        "line": 11,
        "fullcodeline": "assert(size > 0);"
    },
    {
        "line": 12,
        "fullcodeline": "assert(format != NULL);"
    },
    {
        "line": 25,
        "fullcodeline": "buffer = PyMem_MALLOC(size + _PyOS_vsnprintf_EXTRA_SPACE);"
    },
    {
        "line": 31,
        "fullcodeline": "len = vsprintf(buffer, format, va);"
    },
    {
        "line": 45,
        "fullcodeline": "PyMem_FREE(buffer);"
    },
    {
        "line": 16,
        "fullcodeline": "if (size > INT_MAX - _PyOS_vsnprintf_EXTRA_SPACE) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (buffer == NULL) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (len < 0)"
    },
    {
        "line": 48,
        "fullcodeline": "if (size > 0)"
    },
    {
        "line": 17,
        "fullcodeline": "len = -666;"
    },
    {
        "line": 27,
        "fullcodeline": "len = -666;"
    },
    {
        "line": 49,
        "fullcodeline": "str[size-1] = '\\0';"
    },
    {
        "line": 35,
        "fullcodeline": "else if ((size_t)len >= size + _PyOS_vsnprintf_EXTRA_SPACE)"
    },
    {
        "line": 36,
        "fullcodeline": "Py_FatalError(\"Buffer overflow in PyOS_snprintf/PyOS_vsnprintf\");"
    },
    {
        "line": 39,
        "fullcodeline": "const size_t to_copy = (size_t)len < size ?"
    },
    {
        "line": 41,
        "fullcodeline": "assert(to_copy < size);"
    },
    {
        "line": 42,
        "fullcodeline": "memcpy(str, buffer, to_copy);"
    },
    {
        "line": 43,
        "fullcodeline": "str[to_copy] = '\\0';"
    },
    {
        "line": 40,
        "fullcodeline": "(size_t)len : size - 1;"
    }
]