[
    {
        "line": 9,
        "fullcodeline": "expr_ty format_spec = NULL; /* Optional format specifier. */"
    },
    {
        "line": 10,
        "fullcodeline": "int conversion = -1; /* The conversion char. -1 if not specified. */"
    },
    {
        "line": 14,
        "fullcodeline": "char quote_char = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "int string_type = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "Py_ssize_t nested_depth = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "char parenstack[MAXLEVEL];"
    },
    {
        "line": 33,
        "fullcodeline": "*str += 1;"
    },
    {
        "line": 35,
        "fullcodeline": "expr_start = *str;"
    },
    {
        "line": 140,
        "fullcodeline": "expr_end = *str;"
    },
    {
        "line": 161,
        "fullcodeline": "simple_expression = fstring_compile_expr(expr_start, expr_end, c, n);"
    },
    {
        "line": 207,
        "fullcodeline": "*expression = FormattedValue(simple_expression, conversion,"
    },
    {
        "line": 25,
        "fullcodeline": "if (recurse_lvl >= 2) {"
    },
    {
        "line": 32,
        "fullcodeline": "assert(**str == '{');"
    },
    {
        "line": 36,
        "fullcodeline": "for (; *str < end; (*str)++) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (*str >= end)"
    },
    {
        "line": 162,
        "fullcodeline": "if (!simple_expression)"
    },
    {
        "line": 166,
        "fullcodeline": "if (**str == '!') {"
    },
    {
        "line": 184,
        "fullcodeline": "if (*str >= end)"
    },
    {
        "line": 186,
        "fullcodeline": "if (**str == ':') {"
    },
    {
        "line": 201,
        "fullcodeline": "assert(*str < end);"
    },
    {
        "line": 202,
        "fullcodeline": "assert(**str == '}');"
    },
    {
        "line": 218,
        "fullcodeline": "return -1;"
    },
    {
        "line": 26,
        "fullcodeline": "ast_error(c, n, \"f-string: expressions nested too deeply\");"
    },
    {
        "line": 47,
        "fullcodeline": "ch = **str;"
    },
    {
        "line": 150,
        "fullcodeline": "int opening = parenstack[nested_depth - 1];"
    },
    {
        "line": 167,
        "fullcodeline": "*str += 1;"
    },
    {
        "line": 171,
        "fullcodeline": "conversion = **str;"
    },
    {
        "line": 172,
        "fullcodeline": "*str += 1;"
    },
    {
        "line": 187,
        "fullcodeline": "*str += 1;"
    },
    {
        "line": 192,
        "fullcodeline": "format_spec = fstring_parse(str, end, raw, recurse_lvl+1, c, n);"
    },
    {
        "line": 197,
        "fullcodeline": "if (*str >= end || **str != '}')"
    },
    {
        "line": 208,
        "fullcodeline": "format_spec, LINENO(n), n->n_col_offset,"
    },
    {
        "line": 27,
        "fullcodeline": "return -1;"
    },
    {
        "line": 40,
        "fullcodeline": "assert(nested_depth >= 0);"
    },
    {
        "line": 41,
        "fullcodeline": "assert(*str >= expr_start && *str < end);"
    },
    {
        "line": 49,
        "fullcodeline": "if (ch == '\\\\') {"
    },
    {
        "line": 147,
        "fullcodeline": "return -1;"
    },
    {
        "line": 152,
        "fullcodeline": "return -1;"
    },
    {
        "line": 163,
        "fullcodeline": "return -1;"
    },
    {
        "line": 168,
        "fullcodeline": "if (*str >= end)"
    },
    {
        "line": 188,
        "fullcodeline": "if (*str >= end)"
    },
    {
        "line": 193,
        "fullcodeline": "if (!format_spec)"
    },
    {
        "line": 212,
        "fullcodeline": "return -1;"
    },
    {
        "line": 175,
        "fullcodeline": "if (!(conversion == 's' || conversion == 'r'"
    },
    {
        "line": 43,
        "fullcodeline": "assert(string_type == 1 || string_type == 3);"
    },
    {
        "line": 54,
        "fullcodeline": "return -1;"
    },
    {
        "line": 67,
        "fullcodeline": "if (ch == quote_char) {"
    },
    {
        "line": 176,
        "fullcodeline": "|| conversion == 'a')) {"
    },
    {
        "line": 179,
        "fullcodeline": "return -1;"
    },
    {
        "line": 194,
        "fullcodeline": "return -1;"
    },
    {
        "line": 45,
        "fullcodeline": "assert(string_type == 0);"
    },
    {
        "line": 70,
        "fullcodeline": "if (string_type == 3) {"
    },
    {
        "line": 85,
        "fullcodeline": "} else if (ch == '\\'' || ch == '\"') {"
    },
    {
        "line": 95,
        "fullcodeline": "quote_char = ch;"
    },
    {
        "line": 87,
        "fullcodeline": "if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (*str+2 < end && *(*str+1) == ch && *(*str+2) == ch) {"
    },
    {
        "line": 80,
        "fullcodeline": "quote_char = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "string_type = 0;"
    },
    {
        "line": 88,
        "fullcodeline": "string_type = 3;"
    },
    {
        "line": 89,
        "fullcodeline": "*str += 2;"
    },
    {
        "line": 73,
        "fullcodeline": "*str += 2;"
    },
    {
        "line": 74,
        "fullcodeline": "string_type = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "quote_char = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "string_type = 1;"
    },
    {
        "line": 96,
        "fullcodeline": "} else if (ch == '[' || ch == '{' || ch == '(') {"
    },
    {
        "line": 101,
        "fullcodeline": "parenstack[nested_depth] = ch;"
    },
    {
        "line": 102,
        "fullcodeline": "nested_depth++;"
    },
    {
        "line": 97,
        "fullcodeline": "if (nested_depth >= MAXLEVEL) {"
    },
    {
        "line": 103,
        "fullcodeline": "} else if (ch == '#') {"
    },
    {
        "line": 99,
        "fullcodeline": "return -1;"
    },
    {
        "line": 107,
        "fullcodeline": "return -1;"
    },
    {
        "line": 108,
        "fullcodeline": "} else if (nested_depth == 0 &&"
    },
    {
        "line": 109,
        "fullcodeline": "(ch == '!' || ch == ':' || ch == '}')) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (ch == '!' && *str+1 < end && *(*str+1) == '=') {"
    },
    {
        "line": 119,
        "fullcodeline": "} else if (ch == ']' || ch == '}' || ch == ')') {"
    },
    {
        "line": 124,
        "fullcodeline": "nested_depth--;"
    },
    {
        "line": 125,
        "fullcodeline": "int opening = parenstack[nested_depth];"
    },
    {
        "line": 120,
        "fullcodeline": "if (!nested_depth) {"
    },
    {
        "line": 126,
        "fullcodeline": "if (!((opening == '(' && ch == ')') ||"
    },
    {
        "line": 122,
        "fullcodeline": "return -1;"
    },
    {
        "line": 128,
        "fullcodeline": "(opening == '{' && ch == '}')))"
    },
    {
        "line": 134,
        "fullcodeline": "return -1;"
    },
    {
        "line": 127,
        "fullcodeline": "(opening == '[' && ch == ']') ||"
    }
]