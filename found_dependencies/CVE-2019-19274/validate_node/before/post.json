[
    {
        "line": 3,
        "fullcodeline": "int type = TYPE(tree);"
    },
    {
        "line": 4,
        "fullcodeline": "int nch = NCH(tree);"
    },
    {
        "line": 9,
        "fullcodeline": "assert(ISNONTERMINAL(type));"
    },
    {
        "line": 10,
        "fullcodeline": "type -= NT_OFFSET;"
    },
    {
        "line": 16,
        "fullcodeline": "REQ(tree, nt_dfa->d_type);"
    },
    {
        "line": 64,
        "fullcodeline": "PyErr_Format(parser_error,"
    },
    {
        "line": 11,
        "fullcodeline": "if (type >= _PyParser_Grammar.g_ndfas) {"
    },
    {
        "line": 20,
        "fullcodeline": "for (pos = 0; pos < nch; ++pos) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (arc = 0; arc < dfa_state->s_narcs; ++arc) {"
    },
    {
        "line": 12,
        "fullcodeline": "PyErr_Format(parser_error, \"Unrecognized node type %d.\", TYPE(tree));"
    },
    {
        "line": 21,
        "fullcodeline": "node *ch = CHILD(tree, pos);"
    },
    {
        "line": 22,
        "fullcodeline": "int ch_type = TYPE(ch);"
    },
    {
        "line": 23,
        "fullcodeline": "for (arc = 0; arc < dfa_state->s_narcs; ++arc) {"
    },
    {
        "line": 25,
        "fullcodeline": "assert(a_label < _PyParser_Grammar.g_ll.ll_nlabels);"
    },
    {
        "line": 40,
        "fullcodeline": "if (!a_label) /* Wouldn't accept any more children */"
    },
    {
        "line": 44,
        "fullcodeline": "if (ISNONTERMINAL(next_type))"
    },
    {
        "line": 26,
        "fullcodeline": "if (_PyParser_Grammar.g_ll.ll_label[a_label].lb_type == ch_type) {"
    },
    {
        "line": 45,
        "fullcodeline": "PyErr_Format(parser_error, \"Expected node type %d, got %d.\","
    },
    {
        "line": 48,
        "fullcodeline": "PyErr_Format(parser_error, \"Illegal terminal: expected %s.\","
    },
    {
        "line": 28,
        "fullcodeline": "if (ISNONTERMINAL(ch_type) && !validate_node(ch))"
    }
]