[
    {
        "line": 9,
        "fullcodeline": "_Py_AllocatedBlocks++;"
    },
    {
        "line": 11,
        "fullcodeline": "assert(nelem <= PY_SSIZE_T_MAX / elsize);"
    },
    {
        "line": 12,
        "fullcodeline": "nbytes = nelem * elsize;"
    },
    {
        "line": 21,
        "fullcodeline": "if (nelem == 0 || elsize == 0)"
    },
    {
        "line": 24,
        "fullcodeline": "if ((nbytes - 1) < SMALL_REQUEST_THRESHOLD) {"
    },
    {
        "line": 25,
        "fullcodeline": "LOCK();"
    },
    {
        "line": 29,
        "fullcodeline": "size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;"
    },
    {
        "line": 30,
        "fullcodeline": "pool = usedpools[size + size];"
    },
    {
        "line": 92,
        "fullcodeline": "pool = usable_arenas->freepools;"
    },
    {
        "line": 171,
        "fullcodeline": "pool = (poolp)usable_arenas->pool_address;"
    },
    {
        "line": 174,
        "fullcodeline": "pool->arenaindex = (uint)(usable_arenas - arenas);"
    },
    {
        "line": 176,
        "fullcodeline": "pool->szidx = DUMMY_SIZE_IDX;"
    },
    {
        "line": 177,
        "fullcodeline": "usable_arenas->pool_address += POOL_SIZE;"
    },
    {
        "line": 178,
        "fullcodeline": "--usable_arenas->nfreepools;"
    },
    {
        "line": 209,
        "fullcodeline": "if (!result)"
    },
    {
        "line": 31,
        "fullcodeline": "if (pool != pool->nextpool) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (usable_arenas == NULL) {"
    },
    {
        "line": 89,
        "fullcodeline": "assert(usable_arenas->address != 0);"
    },
    {
        "line": 93,
        "fullcodeline": "if (pool != NULL) {"
    },
    {
        "line": 169,
        "fullcodeline": "assert(usable_arenas->nfreepools > 0);"
    },
    {
        "line": 170,
        "fullcodeline": "assert(usable_arenas->freepools == NULL);"
    },
    {
        "line": 172,
        "fullcodeline": "assert((block*)pool <= (block*)usable_arenas->address +"
    },
    {
        "line": 175,
        "fullcodeline": "assert(&arenas[pool->arenaindex] == usable_arenas);"
    },
    {
        "line": 180,
        "fullcodeline": "if (usable_arenas->nfreepools == 0) {"
    },
    {
        "line": 206,
        "fullcodeline": "result = PyMem_RawCalloc(nelem, elsize);"
    },
    {
        "line": 36,
        "fullcodeline": "++pool->ref.count;"
    },
    {
        "line": 37,
        "fullcodeline": "bp = pool->freeblock;"
    },
    {
        "line": 38,
        "fullcodeline": "assert(bp != NULL);"
    },
    {
        "line": 60,
        "fullcodeline": "next = pool->nextpool;"
    },
    {
        "line": 61,
        "fullcodeline": "pool = pool->prevpool;"
    },
    {
        "line": 62,
        "fullcodeline": "next->prevpool = pool;"
    },
    {
        "line": 81,
        "fullcodeline": "usable_arenas = new_arena();"
    },
    {
        "line": 86,
        "fullcodeline": "usable_arenas->nextarena ="
    },
    {
        "line": 95,
        "fullcodeline": "usable_arenas->freepools = pool->nextpool;"
    },
    {
        "line": 104,
        "fullcodeline": "--usable_arenas->nfreepools;"
    },
    {
        "line": 131,
        "fullcodeline": "next = usedpools[size + size]; /* == prev */"
    },
    {
        "line": 132,
        "fullcodeline": "pool->nextpool = next;"
    },
    {
        "line": 133,
        "fullcodeline": "pool->prevpool = next;"
    },
    {
        "line": 155,
        "fullcodeline": "pool->szidx = size;"
    },
    {
        "line": 156,
        "fullcodeline": "size = INDEX2SIZE(size);"
    },
    {
        "line": 157,
        "fullcodeline": "bp = (block *)pool + POOL_OVERHEAD;"
    },
    {
        "line": 160,
        "fullcodeline": "pool->freeblock = bp + size;"
    },
    {
        "line": 185,
        "fullcodeline": "usable_arenas = usable_arenas->nextarena;"
    },
    {
        "line": 208,
        "fullcodeline": "result = PyMem_RawMalloc(nbytes);"
    },
    {
        "line": 39,
        "fullcodeline": "if ((pool->freeblock = *(block **)bp) != NULL) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (pool->nextoffset <= pool->maxnextoffset) {"
    },
    {
        "line": 67,
        "fullcodeline": "return (void *)bp;"
    },
    {
        "line": 82,
        "fullcodeline": "if (usable_arenas == NULL) {"
    },
    {
        "line": 87,
        "fullcodeline": "usable_arenas->prevarena = NULL;"
    },
    {
        "line": 105,
        "fullcodeline": "if (usable_arenas->nfreepools == 0) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (pool->szidx == size) {"
    },
    {
        "line": 159,
        "fullcodeline": "pool->maxnextoffset = POOL_SIZE - size;"
    },
    {
        "line": 165,
        "fullcodeline": "return (void *)bp;"
    },
    {
        "line": 181,
        "fullcodeline": "assert(usable_arenas->nextarena == NULL ||"
    },
    {
        "line": 186,
        "fullcodeline": "if (usable_arenas != NULL) {"
    },
    {
        "line": 40,
        "fullcodeline": "UNLOCK();"
    },
    {
        "line": 50,
        "fullcodeline": "pool->freeblock = (block*)pool +"
    },
    {
        "line": 66,
        "fullcodeline": "memset(bp, 0, nbytes);"
    },
    {
        "line": 112,
        "fullcodeline": "usable_arenas = usable_arenas->nextarena;"
    },
    {
        "line": 142,
        "fullcodeline": "bp = pool->freeblock;"
    },
    {
        "line": 158,
        "fullcodeline": "pool->nextoffset = POOL_OVERHEAD + (size << 1);"
    },
    {
        "line": 164,
        "fullcodeline": "memset(bp, 0, nbytes);"
    },
    {
        "line": 182,
        "fullcodeline": "usable_arenas->nextarena->prevarena =="
    },
    {
        "line": 43,
        "fullcodeline": "return (void *)bp;"
    },
    {
        "line": 52,
        "fullcodeline": "pool->nextoffset += INDEX2SIZE(size);"
    },
    {
        "line": 57,
        "fullcodeline": "return (void *)bp;"
    },
    {
        "line": 107,
        "fullcodeline": "assert(usable_arenas->freepools == NULL);"
    },
    {
        "line": 108,
        "fullcodeline": "assert(usable_arenas->nextarena == NULL ||"
    },
    {
        "line": 113,
        "fullcodeline": "if (usable_arenas != NULL) {"
    },
    {
        "line": 143,
        "fullcodeline": "assert(bp != NULL);"
    },
    {
        "line": 148,
        "fullcodeline": "return (void *)bp;"
    },
    {
        "line": 188,
        "fullcodeline": "assert(usable_arenas->address != 0);"
    },
    {
        "line": 42,
        "fullcodeline": "memset(bp, 0, nbytes);"
    },
    {
        "line": 56,
        "fullcodeline": "memset(bp, 0, nbytes);"
    },
    {
        "line": 109,
        "fullcodeline": "usable_arenas->nextarena->prevarena =="
    },
    {
        "line": 124,
        "fullcodeline": "assert(usable_arenas->freepools != NULL ||"
    },
    {
        "line": 147,
        "fullcodeline": "memset(bp, 0, nbytes);"
    },
    {
        "line": 115,
        "fullcodeline": "assert(usable_arenas->address != 0);"
    },
    {
        "line": 125,
        "fullcodeline": "usable_arenas->pool_address <="
    },
    {
        "line": 126,
        "fullcodeline": "(block*)usable_arenas->address +"
    }
]