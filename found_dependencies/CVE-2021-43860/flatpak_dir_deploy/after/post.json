[
    {
        "line": 10,
        "fullcodeline": "g_autofree char *resolved_ref = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "g_autofree char *ref_id = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "g_autoptr(GFile) root = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "g_autoptr(GFile) deploy_base = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "g_autoptr(GFile) checkoutdir = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "g_autoptr(GFile) bindir = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "g_autofree char *checkoutdirpath = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "g_autoptr(GFile) real_checkoutdir = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "g_autoptr(GFile) dotref = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "g_autoptr(GFile) files_etc = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "g_autoptr(GFile) deploy_data_file = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "g_autoptr(GVariant) commit_data = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "g_autoptr(GBytes) deploy_data = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "g_autoptr(GFile) export = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "g_autoptr(GFile) extradir = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "g_autoptr(GKeyFile) keyfile = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "guint64 installed_size = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "OstreeRepoCheckoutAtOptions options = { 0, };"
    },
    {
        "line": 29,
        "fullcodeline": "glnx_autofd int checkoutdir_dfd = -1;"
    },
    {
        "line": 30,
        "fullcodeline": "g_autoptr(GFile) tmp_dir_template = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "g_autofree char *tmp_dir_path = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "const char *xa_ref = NULL;"
    },
    {
        "line": 33,
        "fullcodeline": "g_autofree char *checkout_basename = NULL;"
    },
    {
        "line": 34,
        "fullcodeline": "gboolean created_extra_data = FALSE;"
    },
    {
        "line": 35,
        "fullcodeline": "g_autoptr(GVariant) commit_metadata = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "g_autoptr(GFile) metadata_file = NULL;"
    },
    {
        "line": 38,
        "fullcodeline": "g_autofree char *metadata_contents = NULL;"
    },
    {
        "line": 39,
        "fullcodeline": "gsize metadata_size = 0;"
    },
    {
        "line": 45,
        "fullcodeline": "ref_id = flatpak_decomposed_dup_id (ref);"
    },
    {
        "line": 53,
        "fullcodeline": "deploy_base = flatpak_dir_get_deploy_dir (self, ref);"
    },
    {
        "line": 80,
        "fullcodeline": "commit_metadata = g_variant_get_child_value (commit_data, 0);"
    },
    {
        "line": 81,
        "fullcodeline": "checkout_basename = flatpak_dir_get_deploy_subdir (self, checksum, subpaths);"
    },
    {
        "line": 83,
        "fullcodeline": "real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);"
    },
    {
        "line": 88,
        "fullcodeline": "g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);"
    },
    {
        "line": 89,
        "fullcodeline": "tmp_dir_template = g_file_get_child (deploy_base, template);"
    },
    {
        "line": 90,
        "fullcodeline": "tmp_dir_path = g_file_get_path (tmp_dir_template);"
    },
    {
        "line": 99,
        "fullcodeline": "checkoutdir = g_file_new_for_path (tmp_dir_path);"
    },
    {
        "line": 110,
        "fullcodeline": "options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;"
    },
    {
        "line": 111,
        "fullcodeline": "options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;"
    },
    {
        "line": 112,
        "fullcodeline": "options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */"
    },
    {
        "line": 113,
        "fullcodeline": "options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */"
    },
    {
        "line": 114,
        "fullcodeline": "checkoutdirpath = g_file_get_path (checkoutdir);"
    },
    {
        "line": 180,
        "fullcodeline": "extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");"
    },
    {
        "line": 199,
        "fullcodeline": "g_variant_lookup (commit_metadata, \"xa.ref\", \"&s\", &xa_ref);"
    },
    {
        "line": 246,
        "fullcodeline": "keyfile = g_key_file_new ();"
    },
    {
        "line": 247,
        "fullcodeline": "metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");"
    },
    {
        "line": 270,
        "fullcodeline": "dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");"
    },
    {
        "line": 275,
        "fullcodeline": "export = g_file_get_child (checkoutdir, \"export\");"
    },
    {
        "line": 278,
        "fullcodeline": "bindir = g_file_get_child (export, \"bin\");"
    },
    {
        "line": 364,
        "fullcodeline": "deploy_data = flatpak_dir_new_deploy_data (self,"
    },
    {
        "line": 381,
        "fullcodeline": "deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");"
    },
    {
        "line": 42,
        "fullcodeline": "if (!flatpak_dir_ensure_repo (self, cancellable, error))"
    },
    {
        "line": 50,
        "fullcodeline": "if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))"
    },
    {
        "line": 55,
        "fullcodeline": "if (checksum_or_latest == NULL)"
    },
    {
        "line": 77,
        "fullcodeline": "if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))"
    },
    {
        "line": 84,
        "fullcodeline": "if (g_file_query_exists (real_checkoutdir, cancellable))"
    },
    {
        "line": 92,
        "fullcodeline": "if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)"
    },
    {
        "line": 101,
        "fullcodeline": "if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))"
    },
    {
        "line": 107,
        "fullcodeline": "if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))"
    },
    {
        "line": 116,
        "fullcodeline": "if (subpaths == NULL || *subpaths == NULL)"
    },
    {
        "line": 181,
        "fullcodeline": "if (!flatpak_rm_rf (extradir, cancellable, error))"
    },
    {
        "line": 187,
        "fullcodeline": "if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))"
    },
    {
        "line": 200,
        "fullcodeline": "if (xa_ref != NULL)"
    },
    {
        "line": 248,
        "fullcodeline": "if (g_file_load_contents (metadata_file, NULL,"
    },
    {
        "line": 266,
        "fullcodeline": "if (!validate_commit_metadata (commit_data, flatpak_decomposed_get_ref (ref),"
    },
    {
        "line": 271,
        "fullcodeline": "if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,"
    },
    {
        "line": 279,
        "fullcodeline": "if (!flatpak_rm_rf (bindir, cancellable, error))"
    },
    {
        "line": 282,
        "fullcodeline": "if (flatpak_decomposed_is_runtime (ref))"
    },
    {
        "line": 378,
        "fullcodeline": "if (!flatpak_dir_check_parental_controls (self, flatpak_decomposed_get_ref (ref), deploy_data, cancellable, error))"
    },
    {
        "line": 382,
        "fullcodeline": "if (!flatpak_bytes_save (deploy_data_file, deploy_data, cancellable, error))"
    },
    {
        "line": 385,
        "fullcodeline": "if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))"
    },
    {
        "line": 388,
        "fullcodeline": "if (syncfs (checkoutdir_dfd) != 0)"
    },
    {
        "line": 394,
        "fullcodeline": "if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,"
    },
    {
        "line": 398,
        "fullcodeline": "if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))"
    },
    {
        "line": 401,
        "fullcodeline": "if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), checksum, error))"
    },
    {
        "line": 57,
        "fullcodeline": "g_debug (\"No checksum specified, getting tip of %s from origin %s\", flatpak_decomposed_get_ref (ref), origin);"
    },
    {
        "line": 59,
        "fullcodeline": "resolved_ref = flatpak_dir_read_latest (self, origin, flatpak_decomposed_get_ref (ref), NULL, cancellable, error);"
    },
    {
        "line": 66,
        "fullcodeline": "checksum = resolved_ref;"
    },
    {
        "line": 67,
        "fullcodeline": "g_debug (\"tip resolved to: %s\", checksum);"
    },
    {
        "line": 94,
        "fullcodeline": "g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,"
    },
    {
        "line": 103,
        "fullcodeline": "g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);"
    },
    {
        "line": 183,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));"
    },
    {
        "line": 286,
        "fullcodeline": "files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");"
    },
    {
        "line": 372,
        "fullcodeline": "(char **) subpaths,"
    },
    {
        "line": 390,
        "fullcodeline": "glnx_set_error_from_errno (error);"
    },
    {
        "line": 60,
        "fullcodeline": "if (resolved_ref == NULL)"
    },
    {
        "line": 71,
        "fullcodeline": "checksum = checksum_or_latest;"
    },
    {
        "line": 72,
        "fullcodeline": "g_debug (\"Looking for checksum %s in local repo\", checksum);"
    },
    {
        "line": 85,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,"
    },
    {
        "line": 95,
        "fullcodeline": "_(\"Can't create deploy directory\"));"
    },
    {
        "line": 118,
        "fullcodeline": "if (!ostree_repo_checkout_at (self->repo, &options,"
    },
    {
        "line": 129,
        "fullcodeline": "g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");"
    },
    {
        "line": 135,
        "fullcodeline": "options.subpath = \"/metadata\";"
    },
    {
        "line": 192,
        "fullcodeline": "if (!apply_extra_data (self, checkoutdir, cancellable, error))"
    },
    {
        "line": 204,
        "fullcodeline": "if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, origin, &gpg_verify_summary, error))"
    },
    {
        "line": 252,
        "fullcodeline": "if (!g_key_file_load_from_data (keyfile,"
    },
    {
        "line": 258,
        "fullcodeline": "if (!flatpak_check_required_version (flatpak_decomposed_get_ref (ref), keyfile, error))"
    },
    {
        "line": 287,
        "fullcodeline": "if (g_file_query_exists (files_etc, cancellable))"
    },
    {
        "line": 326,
        "fullcodeline": "if (!flatpak_rm_rf (export, cancellable, error))"
    },
    {
        "line": 331,
        "fullcodeline": "g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);"
    },
    {
        "line": 332,
        "fullcodeline": "g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);"
    },
    {
        "line": 333,
        "fullcodeline": "g_autoptr(GFile) wrapper = g_file_get_child (bindir, ref_id);"
    },
    {
        "line": 334,
        "fullcodeline": "g_autofree char *escaped_app = maybe_quote (ref_id);"
    },
    {
        "line": 335,
        "fullcodeline": "g_autofree char *escaped_branch = maybe_quote (ref_branch);"
    },
    {
        "line": 336,
        "fullcodeline": "g_autofree char *escaped_arch = maybe_quote (ref_arch);"
    },
    {
        "line": 337,
        "fullcodeline": "g_autofree char *bin_data = NULL;"
    },
    {
        "line": 349,
        "fullcodeline": "flatpak = FLATPAK_BINDIR \"/flatpak\";"
    },
    {
        "line": 351,
        "fullcodeline": "bin_data = g_strdup_printf (\"#!/bin/sh\\nexec %s run --branch=%s --arch=%s %s \\\"$@\\\"\\n\","
    },
    {
        "line": 62,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to resolve ref %s: \"), flatpak_decomposed_get_ref (ref));"
    },
    {
        "line": 73,
        "fullcodeline": "if (!ostree_repo_read_commit (self->repo, checksum, NULL, NULL, cancellable, NULL))"
    },
    {
        "line": 86,
        "fullcodeline": "_(\"%s commit %s already installed\"), flatpak_decomposed_get_ref (ref), checksum);"
    },
    {
        "line": 123,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);"
    },
    {
        "line": 132,
        "fullcodeline": "if (!g_file_make_directory_with_parents (files, cancellable, error))"
    },
    {
        "line": 137,
        "fullcodeline": "if (!ostree_repo_checkout_at (self->repo, &options,"
    },
    {
        "line": 146,
        "fullcodeline": "for (i = 0; subpaths[i] != NULL; i++)"
    },
    {
        "line": 194,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to apply extra data: \"));"
    },
    {
        "line": 215,
        "fullcodeline": "FlatpakDecomposed *checkout_ref = ref;"
    },
    {
        "line": 216,
        "fullcodeline": "g_autoptr(FlatpakDecomposed) commit_ref = NULL;"
    },
    {
        "line": 218,
        "fullcodeline": "commit_ref = flatpak_decomposed_new_from_ref (xa_ref, error);"
    },
    {
        "line": 289,
        "fullcodeline": "char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };"
    },
    {
        "line": 290,
        "fullcodeline": "g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");"
    },
    {
        "line": 340,
        "fullcodeline": "if (!flatpak_mkdir_p (bindir, cancellable, error))"
    },
    {
        "line": 343,
        "fullcodeline": "if (!flatpak_rewrite_export_dir (ref_id, ref_branch, ref_arch,"
    },
    {
        "line": 353,
        "fullcodeline": "if (!g_file_replace_contents (wrapper, bin_data, strlen (bin_data), NULL, FALSE,"
    },
    {
        "line": 358,
        "fullcodeline": "r = fchmodat (AT_FDCWD, flatpak_file_get_path_cached (wrapper), 0755, 0);"
    },
    {
        "line": 359,
        "fullcodeline": "while (G_UNLIKELY (r == -1 && errno == EINTR));"
    },
    {
        "line": 360,
        "fullcodeline": "if (r == -1)"
    },
    {
        "line": 142,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));"
    },
    {
        "line": 148,
        "fullcodeline": "g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);"
    },
    {
        "line": 149,
        "fullcodeline": "g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);"
    },
    {
        "line": 150,
        "fullcodeline": "g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);"
    },
    {
        "line": 151,
        "fullcodeline": "g_autoptr(GFile) child = NULL;"
    },
    {
        "line": 153,
        "fullcodeline": "child = g_file_resolve_relative_path (root, subpath);"
    },
    {
        "line": 167,
        "fullcodeline": "options.subpath = subpath;"
    },
    {
        "line": 219,
        "fullcodeline": "if (commit_ref == NULL)"
    },
    {
        "line": 226,
        "fullcodeline": "if (!flatpak_decomposed_equal_except_branch (checkout_ref, commit_ref))"
    },
    {
        "line": 234,
        "fullcodeline": "if (strcmp (flatpak_decomposed_get_branch (checkout_ref), flatpak_decomposed_get_branch (commit_ref)) != 0)"
    },
    {
        "line": 292,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)"
    },
    {
        "line": 315,
        "fullcodeline": "if (g_file_query_exists (etc_resolve_conf, cancellable) &&"
    },
    {
        "line": 319,
        "fullcodeline": "if (!g_file_make_symbolic_link (etc_resolve_conf,"
    },
    {
        "line": 74,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"%s is not available\"), flatpak_decomposed_get_ref (ref));"
    },
    {
        "line": 155,
        "fullcodeline": "if (!g_file_query_exists (child, cancellable))"
    },
    {
        "line": 161,
        "fullcodeline": "if (g_mkdir_with_parents (dstpath_parent, 0755))"
    },
    {
        "line": 168,
        "fullcodeline": "if (!ostree_repo_checkout_at (self->repo, &options,"
    },
    {
        "line": 221,
        "fullcodeline": "g_prefix_error (error, _(\"Invalid commit ref %s: \"), xa_ref);"
    },
    {
        "line": 228,
        "fullcodeline": "g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,"
    },
    {
        "line": 235,
        "fullcodeline": "g_warning (_(\"Deployed ref %s branch does not match commit (%s)\"),"
    },
    {
        "line": 238,
        "fullcodeline": "else if (strcmp (flatpak_decomposed_get_ref (ref), xa_ref) != 0)"
    },
    {
        "line": 294,
        "fullcodeline": "g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);"
    },
    {
        "line": 297,
        "fullcodeline": "type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,"
    },
    {
        "line": 316,
        "fullcodeline": "!g_file_delete (etc_resolve_conf, cancellable, error))"
    },
    {
        "line": 361,
        "fullcodeline": "return glnx_throw_errno_prefix (error, \"fchmodat\");"
    },
    {
        "line": 157,
        "fullcodeline": "g_debug (\"subpath %s not in tree\", subpaths[i]);"
    },
    {
        "line": 163,
        "fullcodeline": "glnx_set_error_from_errno (error);"
    },
    {
        "line": 173,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to checkout subpath \u2018%s\u2019: \"), subpath);"
    },
    {
        "line": 229,
        "fullcodeline": "_(\"Deployed ref %s does not match commit (%s)\"),"
    },
    {
        "line": 230,
        "fullcodeline": "flatpak_decomposed_get_ref (ref), xa_ref);"
    },
    {
        "line": 236,
        "fullcodeline": "flatpak_decomposed_get_ref (ref), xa_ref);"
    },
    {
        "line": 240,
        "fullcodeline": "g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,"
    },
    {
        "line": 299,
        "fullcodeline": "if (type == G_FILE_TYPE_REGULAR)"
    },
    {
        "line": 302,
        "fullcodeline": "if (type != G_FILE_TYPE_UNKNOWN)"
    },
    {
        "line": 309,
        "fullcodeline": "if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,"
    },
    {
        "line": 241,
        "fullcodeline": "_(\"Deployed ref %s does not match commit (%s)\"), flatpak_decomposed_get_ref (ref), xa_ref);"
    },
    {
        "line": 305,
        "fullcodeline": "if (!g_file_delete (etc_file, cancellable, error))"
    }
]