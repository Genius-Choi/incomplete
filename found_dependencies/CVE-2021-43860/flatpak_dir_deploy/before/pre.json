[
    {
        "line": 10,
        "fullcodeline": "g_autofree char *resolved_ref = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "g_autofree char *ref_id = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "g_autoptr(GFile) root = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "g_autoptr(GFile) deploy_base = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "g_autoptr(GFile) checkoutdir = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "g_autoptr(GFile) bindir = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "g_autofree char *checkoutdirpath = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "g_autoptr(GFile) real_checkoutdir = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "g_autoptr(GFile) dotref = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "g_autoptr(GFile) files_etc = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "g_autoptr(GFile) deploy_data_file = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "g_autoptr(GVariant) commit_data = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "g_autoptr(GBytes) deploy_data = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "g_autoptr(GFile) export = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "g_autoptr(GFile) extradir = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "g_autoptr(GKeyFile) keyfile = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "guint64 installed_size = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "OstreeRepoCheckoutAtOptions options = { 0, };"
    },
    {
        "line": 29,
        "fullcodeline": "glnx_autofd int checkoutdir_dfd = -1;"
    },
    {
        "line": 30,
        "fullcodeline": "g_autoptr(GFile) tmp_dir_template = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "g_autofree char *tmp_dir_path = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "const char *xa_ref = NULL;"
    },
    {
        "line": 33,
        "fullcodeline": "g_autofree char *checkout_basename = NULL;"
    },
    {
        "line": 34,
        "fullcodeline": "gboolean created_extra_data = FALSE;"
    },
    {
        "line": 35,
        "fullcodeline": "g_autoptr(GVariant) commit_metadata = NULL;"
    },
    {
        "line": 37,
        "fullcodeline": "g_autoptr(GFile) metadata_file = NULL;"
    },
    {
        "line": 38,
        "fullcodeline": "g_autofree char *metadata_contents = NULL;"
    },
    {
        "line": 39,
        "fullcodeline": "gsize metadata_size = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "ref_id = flatpak_decomposed_dup_id (ref);"
    },
    {
        "line": 54,
        "fullcodeline": "deploy_base = flatpak_dir_get_deploy_dir (self, ref);"
    },
    {
        "line": 81,
        "fullcodeline": "commit_metadata = g_variant_get_child_value (commit_data, 0);"
    },
    {
        "line": 82,
        "fullcodeline": "checkout_basename = flatpak_dir_get_deploy_subdir (self, checksum, subpaths);"
    },
    {
        "line": 84,
        "fullcodeline": "real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);"
    },
    {
        "line": 89,
        "fullcodeline": "g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);"
    },
    {
        "line": 90,
        "fullcodeline": "tmp_dir_template = g_file_get_child (deploy_base, template);"
    },
    {
        "line": 91,
        "fullcodeline": "tmp_dir_path = g_file_get_path (tmp_dir_template);"
    },
    {
        "line": 100,
        "fullcodeline": "checkoutdir = g_file_new_for_path (tmp_dir_path);"
    },
    {
        "line": 111,
        "fullcodeline": "options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;"
    },
    {
        "line": 112,
        "fullcodeline": "options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;"
    },
    {
        "line": 113,
        "fullcodeline": "options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */"
    },
    {
        "line": 114,
        "fullcodeline": "options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */"
    },
    {
        "line": 115,
        "fullcodeline": "checkoutdirpath = g_file_get_path (checkoutdir);"
    },
    {
        "line": 181,
        "fullcodeline": "extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");"
    },
    {
        "line": 200,
        "fullcodeline": "g_variant_lookup (commit_metadata, \"xa.ref\", \"&s\", &xa_ref);"
    },
    {
        "line": 247,
        "fullcodeline": "keyfile = g_key_file_new ();"
    },
    {
        "line": 248,
        "fullcodeline": "metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");"
    },
    {
        "line": 269,
        "fullcodeline": "is_oci = flatpak_dir_get_remote_oci (self, origin);"
    },
    {
        "line": 274,
        "fullcodeline": "dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");"
    },
    {
        "line": 279,
        "fullcodeline": "export = g_file_get_child (checkoutdir, \"export\");"
    },
    {
        "line": 282,
        "fullcodeline": "bindir = g_file_get_child (export, \"bin\");"
    },
    {
        "line": 368,
        "fullcodeline": "deploy_data = flatpak_dir_new_deploy_data (self,"
    },
    {
        "line": 385,
        "fullcodeline": "deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");"
    },
    {
        "line": 43,
        "fullcodeline": "if (!flatpak_dir_ensure_repo (self, cancellable, error))"
    },
    {
        "line": 56,
        "fullcodeline": "if (checksum_or_latest == NULL)"
    },
    {
        "line": 85,
        "fullcodeline": "if (g_file_query_exists (real_checkoutdir, cancellable))"
    },
    {
        "line": 93,
        "fullcodeline": "if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)"
    },
    {
        "line": 201,
        "fullcodeline": "if (xa_ref != NULL)"
    },
    {
        "line": 249,
        "fullcodeline": "if (g_file_load_contents (metadata_file, NULL,"
    },
    {
        "line": 286,
        "fullcodeline": "if (flatpak_decomposed_is_runtime (ref))"
    },
    {
        "line": 51,
        "fullcodeline": "if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))"
    },
    {
        "line": 58,
        "fullcodeline": "g_debug (\"No checksum specified, getting tip of %s from origin %s\", flatpak_decomposed_get_ref (ref), origin);"
    },
    {
        "line": 60,
        "fullcodeline": "resolved_ref = flatpak_dir_read_latest (self, origin, flatpak_decomposed_get_ref (ref), NULL, cancellable, error);"
    },
    {
        "line": 67,
        "fullcodeline": "checksum = resolved_ref;"
    },
    {
        "line": 68,
        "fullcodeline": "g_debug (\"tip resolved to: %s\", checksum);"
    },
    {
        "line": 78,
        "fullcodeline": "if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))"
    },
    {
        "line": 95,
        "fullcodeline": "g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,"
    },
    {
        "line": 102,
        "fullcodeline": "if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))"
    },
    {
        "line": 108,
        "fullcodeline": "if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))"
    },
    {
        "line": 117,
        "fullcodeline": "if (subpaths == NULL || *subpaths == NULL)"
    },
    {
        "line": 182,
        "fullcodeline": "if (!flatpak_rm_rf (extradir, cancellable, error))"
    },
    {
        "line": 188,
        "fullcodeline": "if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))"
    },
    {
        "line": 270,
        "fullcodeline": "if (!validate_commit_metadata (commit_data, flatpak_decomposed_get_ref (ref),"
    },
    {
        "line": 275,
        "fullcodeline": "if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,"
    },
    {
        "line": 283,
        "fullcodeline": "if (!flatpak_rm_rf (bindir, cancellable, error))"
    },
    {
        "line": 290,
        "fullcodeline": "files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");"
    },
    {
        "line": 382,
        "fullcodeline": "if (!flatpak_dir_check_parental_controls (self, flatpak_decomposed_get_ref (ref), deploy_data, cancellable, error))"
    },
    {
        "line": 386,
        "fullcodeline": "if (!flatpak_bytes_save (deploy_data_file, deploy_data, cancellable, error))"
    },
    {
        "line": 389,
        "fullcodeline": "if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))"
    },
    {
        "line": 392,
        "fullcodeline": "if (syncfs (checkoutdir_dfd) != 0)"
    },
    {
        "line": 398,
        "fullcodeline": "if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,"
    },
    {
        "line": 402,
        "fullcodeline": "if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))"
    },
    {
        "line": 405,
        "fullcodeline": "if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), checksum, error))"
    },
    {
        "line": 61,
        "fullcodeline": "if (resolved_ref == NULL)"
    },
    {
        "line": 72,
        "fullcodeline": "checksum = checksum_or_latest;"
    },
    {
        "line": 73,
        "fullcodeline": "g_debug (\"Looking for checksum %s in local repo\", checksum);"
    },
    {
        "line": 86,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,"
    },
    {
        "line": 96,
        "fullcodeline": "_(\"Can't create deploy directory\"));"
    },
    {
        "line": 104,
        "fullcodeline": "g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);"
    },
    {
        "line": 130,
        "fullcodeline": "g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");"
    },
    {
        "line": 136,
        "fullcodeline": "options.subpath = \"/metadata\";"
    },
    {
        "line": 184,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));"
    },
    {
        "line": 271,
        "fullcodeline": "metadata_contents, metadata_size, !is_oci, error))"
    },
    {
        "line": 291,
        "fullcodeline": "if (g_file_query_exists (files_etc, cancellable))"
    },
    {
        "line": 335,
        "fullcodeline": "g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);"
    },
    {
        "line": 336,
        "fullcodeline": "g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);"
    },
    {
        "line": 337,
        "fullcodeline": "g_autoptr(GFile) wrapper = g_file_get_child (bindir, ref_id);"
    },
    {
        "line": 338,
        "fullcodeline": "g_autofree char *escaped_app = maybe_quote (ref_id);"
    },
    {
        "line": 339,
        "fullcodeline": "g_autofree char *escaped_branch = maybe_quote (ref_branch);"
    },
    {
        "line": 340,
        "fullcodeline": "g_autofree char *escaped_arch = maybe_quote (ref_arch);"
    },
    {
        "line": 353,
        "fullcodeline": "flatpak = FLATPAK_BINDIR \"/flatpak\";"
    },
    {
        "line": 355,
        "fullcodeline": "bin_data = g_strdup_printf (\"#!/bin/sh\\nexec %s run --branch=%s --arch=%s %s \\\"$@\\\"\\n\","
    },
    {
        "line": 87,
        "fullcodeline": "_(\"%s commit %s already installed\"), flatpak_decomposed_get_ref (ref), checksum);"
    },
    {
        "line": 119,
        "fullcodeline": "if (!ostree_repo_checkout_at (self->repo, &options,"
    },
    {
        "line": 147,
        "fullcodeline": "for (i = 0; subpaths[i] != NULL; i++)"
    },
    {
        "line": 193,
        "fullcodeline": "if (!apply_extra_data (self, checkoutdir, cancellable, error))"
    },
    {
        "line": 205,
        "fullcodeline": "if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, origin, &gpg_verify_summary, error))"
    },
    {
        "line": 216,
        "fullcodeline": "FlatpakDecomposed *checkout_ref = ref;"
    },
    {
        "line": 219,
        "fullcodeline": "commit_ref = flatpak_decomposed_new_from_ref (xa_ref, error);"
    },
    {
        "line": 253,
        "fullcodeline": "if (!g_key_file_load_from_data (keyfile,"
    },
    {
        "line": 259,
        "fullcodeline": "if (!flatpak_check_required_version (flatpak_decomposed_get_ref (ref), keyfile, error))"
    },
    {
        "line": 293,
        "fullcodeline": "char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };"
    },
    {
        "line": 294,
        "fullcodeline": "g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");"
    },
    {
        "line": 330,
        "fullcodeline": "if (!flatpak_rm_rf (export, cancellable, error))"
    },
    {
        "line": 362,
        "fullcodeline": "r = fchmodat (AT_FDCWD, flatpak_file_get_path_cached (wrapper), 0755, 0);"
    },
    {
        "line": 63,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to resolve ref %s: \"), flatpak_decomposed_get_ref (ref));"
    },
    {
        "line": 74,
        "fullcodeline": "if (!ostree_repo_read_commit (self->repo, checksum, NULL, NULL, cancellable, NULL))"
    },
    {
        "line": 124,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);"
    },
    {
        "line": 133,
        "fullcodeline": "if (!g_file_make_directory_with_parents (files, cancellable, error))"
    },
    {
        "line": 138,
        "fullcodeline": "if (!ostree_repo_checkout_at (self->repo, &options,"
    },
    {
        "line": 149,
        "fullcodeline": "g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);"
    },
    {
        "line": 150,
        "fullcodeline": "g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);"
    },
    {
        "line": 151,
        "fullcodeline": "g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);"
    },
    {
        "line": 154,
        "fullcodeline": "child = g_file_resolve_relative_path (root, subpath);"
    },
    {
        "line": 168,
        "fullcodeline": "options.subpath = subpath;"
    },
    {
        "line": 195,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to apply extra data: \"));"
    },
    {
        "line": 220,
        "fullcodeline": "if (commit_ref == NULL)"
    },
    {
        "line": 296,
        "fullcodeline": "for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)"
    },
    {
        "line": 344,
        "fullcodeline": "if (!flatpak_mkdir_p (bindir, cancellable, error))"
    },
    {
        "line": 347,
        "fullcodeline": "if (!flatpak_rewrite_export_dir (ref_id, ref_branch, ref_arch,"
    },
    {
        "line": 357,
        "fullcodeline": "if (!g_file_replace_contents (wrapper, bin_data, strlen (bin_data), NULL, FALSE,"
    },
    {
        "line": 363,
        "fullcodeline": "while (G_UNLIKELY (r == -1 && errno == EINTR));"
    },
    {
        "line": 364,
        "fullcodeline": "if (r == -1)"
    },
    {
        "line": 75,
        "fullcodeline": "return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"%s is not available\"), flatpak_decomposed_get_ref (ref));"
    },
    {
        "line": 143,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));"
    },
    {
        "line": 227,
        "fullcodeline": "if (!flatpak_decomposed_equal_except_branch (checkout_ref, commit_ref))"
    },
    {
        "line": 235,
        "fullcodeline": "if (strcmp (flatpak_decomposed_get_branch (checkout_ref), flatpak_decomposed_get_branch (commit_ref)) != 0)"
    },
    {
        "line": 298,
        "fullcodeline": "g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);"
    },
    {
        "line": 301,
        "fullcodeline": "type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,"
    },
    {
        "line": 319,
        "fullcodeline": "if (g_file_query_exists (etc_resolve_conf, cancellable) &&"
    },
    {
        "line": 320,
        "fullcodeline": "!g_file_delete (etc_resolve_conf, cancellable, error))"
    },
    {
        "line": 323,
        "fullcodeline": "if (!g_file_make_symbolic_link (etc_resolve_conf,"
    },
    {
        "line": 365,
        "fullcodeline": "return glnx_throw_errno_prefix (error, \"fchmodat\");"
    },
    {
        "line": 156,
        "fullcodeline": "if (!g_file_query_exists (child, cancellable))"
    },
    {
        "line": 158,
        "fullcodeline": "g_debug (\"subpath %s not in tree\", subpaths[i]);"
    },
    {
        "line": 169,
        "fullcodeline": "if (!ostree_repo_checkout_at (self->repo, &options,"
    },
    {
        "line": 222,
        "fullcodeline": "g_prefix_error (error, _(\"Invalid commit ref %s: \"), xa_ref);"
    },
    {
        "line": 230,
        "fullcodeline": "_(\"Deployed ref %s does not match commit (%s)\"),"
    },
    {
        "line": 231,
        "fullcodeline": "flatpak_decomposed_get_ref (ref), xa_ref);"
    },
    {
        "line": 236,
        "fullcodeline": "g_warning (_(\"Deployed ref %s branch does not match commit (%s)\"),"
    },
    {
        "line": 237,
        "fullcodeline": "flatpak_decomposed_get_ref (ref), xa_ref);"
    },
    {
        "line": 239,
        "fullcodeline": "else if (strcmp (flatpak_decomposed_get_ref (ref), xa_ref) != 0)"
    },
    {
        "line": 303,
        "fullcodeline": "if (type == G_FILE_TYPE_REGULAR)"
    },
    {
        "line": 306,
        "fullcodeline": "if (type != G_FILE_TYPE_UNKNOWN)"
    },
    {
        "line": 174,
        "fullcodeline": "g_prefix_error (error, _(\"While trying to checkout subpath \u2018%s\u2019: \"), subpath);"
    },
    {
        "line": 242,
        "fullcodeline": "_(\"Deployed ref %s does not match commit (%s)\"), flatpak_decomposed_get_ref (ref), xa_ref);"
    },
    {
        "line": 313,
        "fullcodeline": "if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,"
    },
    {
        "line": 309,
        "fullcodeline": "if (!g_file_delete (etc_file, cancellable, error))"
    }
]