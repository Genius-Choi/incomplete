[
    {
        "line": 3,
        "fullcodeline": "RBin *bin = bf->rbin;"
    },
    {
        "line": 4,
        "fullcodeline": "ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];"
    },
    {
        "line": 5,
        "fullcodeline": "ut64 str_start, needle = from;"
    },
    {
        "line": 6,
        "fullcodeline": "int count = 0, i, rc, runes;"
    },
    {
        "line": 7,
        "fullcodeline": "int str_type = R_STRING_TYPE_DETECT;"
    },
    {
        "line": 10,
        "fullcodeline": "r_return_val_if_fail (bf, -1);"
    },
    {
        "line": 22,
        "fullcodeline": "st64 len = (st64)(to - from);"
    },
    {
        "line": 27,
        "fullcodeline": "ut8 *buf = calloc (len, 1);"
    },
    {
        "line": 32,
        "fullcodeline": "st64 vdelta = 0, pdelta = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "RBinSection *s = NULL;"
    },
    {
        "line": 34,
        "fullcodeline": "bool ascii_only = false;"
    },
    {
        "line": 35,
        "fullcodeline": "PJ *pj = NULL;"
    },
    {
        "line": 42,
        "fullcodeline": "r_buf_read_at (bf->buf, from, buf, len);"
    },
    {
        "line": 43,
        "fullcodeline": "char *charset = r_sys_getenv (\"RABIN2_CHARSET\");"
    },
    {
        "line": 70,
        "fullcodeline": "RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "if (type == -1) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (from == to) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (from > to) {"
    },
    {
        "line": 72,
        "fullcodeline": "while (needle < to) {"
    },
    {
        "line": 13,
        "fullcodeline": "type = R_STRING_TYPE_DETECT;"
    },
    {
        "line": 23,
        "fullcodeline": "if (len < 1 || len > ST32_MAX) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (!buf || !min) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (bf->strmode == R_MODE_JSON && !list) {"
    },
    {
        "line": 37,
        "fullcodeline": "pj = pj_new ();"
    },
    {
        "line": 44,
        "fullcodeline": "if (!R_STR_ISEMPTY (charset)) {"
    },
    {
        "line": 45,
        "fullcodeline": "RCharset *ch = r_charset_new ();"
    },
    {
        "line": 84,
        "fullcodeline": "rc = r_utf8_decode (buf + needle - from, to - needle, NULL);"
    },
    {
        "line": 89,
        "fullcodeline": "bool addr_aligned = !(needle % 4);"
    },
    {
        "line": 125,
        "fullcodeline": "runes = 0;"
    },
    {
        "line": 126,
        "fullcodeline": "str_start = needle;"
    },
    {
        "line": 184,
        "fullcodeline": "tmp[i++] = '\\0';"
    },
    {
        "line": 296,
        "fullcodeline": "ascii_only = false;"
    },
    {
        "line": 300,
        "fullcodeline": "pj_end (pj);"
    },
    {
        "line": 20,
        "fullcodeline": "return -1;"
    },
    {
        "line": 25,
        "fullcodeline": "return -1;"
    },
    {
        "line": 30,
        "fullcodeline": "return -1;"
    },
    {
        "line": 46,
        "fullcodeline": "if (r_charset_use (ch, charset)) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (needle + 4 < to) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (!rc) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (type == R_STRING_TYPE_DETECT) {"
    },
    {
        "line": 129,
        "fullcodeline": "for (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (runes >= min) {"
    },
    {
        "line": 39,
        "fullcodeline": "pj_a (pj);"
    },
    {
        "line": 47,
        "fullcodeline": "int outlen = len * 4;"
    },
    {
        "line": 48,
        "fullcodeline": "ut8 *out = calloc (len, 4);"
    },
    {
        "line": 78,
        "fullcodeline": "ut32 n1 = r_read_le32 (buf + needle - from);"
    },
    {
        "line": 86,
        "fullcodeline": "needle++;"
    },
    {
        "line": 92,
        "fullcodeline": "char *w = (char *)buf + needle + rc - from;"
    },
    {
        "line": 130,
        "fullcodeline": "RRune r = {0};"
    },
    {
        "line": 154,
        "fullcodeline": "needle += rc;"
    },
    {
        "line": 186,
        "fullcodeline": "if (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {"
    },
    {
        "line": 188,
        "fullcodeline": "needle -= 2;"
    },
    {
        "line": 193,
        "fullcodeline": "int *freq_list = NULL, expected_ascii, actual_ascii, num_chars;"
    },
    {
        "line": 240,
        "fullcodeline": "RBinString *bs = R_NEW0 (RBinString);"
    },
    {
        "line": 244,
        "fullcodeline": "bs->type = str_type;"
    },
    {
        "line": 245,
        "fullcodeline": "bs->length = runes;"
    },
    {
        "line": 246,
        "fullcodeline": "bs->size = needle - str_start;"
    },
    {
        "line": 247,
        "fullcodeline": "bs->ordinal = count++;"
    },
    {
        "line": 278,
        "fullcodeline": "ut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;"
    },
    {
        "line": 279,
        "fullcodeline": "bs->paddr = str_start + baddr;"
    },
    {
        "line": 280,
        "fullcodeline": "bs->vaddr = str_start - pdelta + vdelta + baddr;"
    },
    {
        "line": 281,
        "fullcodeline": "bs->string = r_str_ndup ((const char *)tmp, i);"
    },
    {
        "line": 131,
        "fullcodeline": "if (str_type == R_STRING_TYPE_WIDE32) {"
    },
    {
        "line": 194,
        "fullcodeline": "if (str_type == R_STRING_TYPE_ASCII) {"
    },
    {
        "line": 241,
        "fullcodeline": "if (!bs) {"
    },
    {
        "line": 267,
        "fullcodeline": "if (!s) {"
    },
    {
        "line": 50,
        "fullcodeline": "int res = r_charset_encode_str (ch, out, outlen, buf, len);"
    },
    {
        "line": 60,
        "fullcodeline": "buf = out;"
    },
    {
        "line": 80,
        "fullcodeline": "needle += 4;"
    },
    {
        "line": 93,
        "fullcodeline": "if (((to - needle) > 8 + rc)) {"
    },
    {
        "line": 95,
        "fullcodeline": "bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);"
    },
    {
        "line": 120,
        "fullcodeline": "} else if (type == R_STRING_TYPE_UTF8) {"
    },
    {
        "line": 132,
        "fullcodeline": "rc = r_utf32le_decode (buf + needle - from, to - needle, &r);"
    },
    {
        "line": 149,
        "fullcodeline": "if (!rc || (ascii_only && r > 0x7f)) {"
    },
    {
        "line": 150,
        "fullcodeline": "needle++;"
    },
    {
        "line": 156,
        "fullcodeline": "if (r_isprint (r) && r != '\\\\') {"
    },
    {
        "line": 162,
        "fullcodeline": "rc = r_utf8_encode (tmp + i, r);"
    },
    {
        "line": 163,
        "fullcodeline": "runes++;"
    },
    {
        "line": 208,
        "fullcodeline": "num_blocks = 0;"
    },
    {
        "line": 209,
        "fullcodeline": "block_list = r_utf_block_list ((const ut8*)tmp, i - 1,"
    },
    {
        "line": 283,
        "fullcodeline": "r_list_append (list, bs);"
    },
    {
        "line": 291,
        "fullcodeline": "if (from == 0 && to == bf->size) {"
    },
    {
        "line": 293,
        "fullcodeline": "s = NULL;"
    },
    {
        "line": 53,
        "fullcodeline": "for (i = 0; i < res; i++) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (!addr_aligned) {"
    },
    {
        "line": 121,
        "fullcodeline": "str_type = R_STRING_TYPE_ASCII; // initial assumption"
    },
    {
        "line": 157,
        "fullcodeline": "if (str_type == R_STRING_TYPE_WIDE32) {"
    },
    {
        "line": 195,
        "fullcodeline": "for (j = 0; j < i; j++) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (num_blocks > R_STRING_MAX_UNI_BLOCKS) {"
    },
    {
        "line": 288,
        "fullcodeline": "print_string (bf, bs, raw, pj);"
    },
    {
        "line": 304,
        "fullcodeline": "io->cb_printf (\"%s\", pj_string (pj));"
    },
    {
        "line": 103,
        "fullcodeline": "is_wide32le = false;"
    },
    {
        "line": 107,
        "fullcodeline": "str_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?"
    },
    {
        "line": 123,
        "fullcodeline": "str_type = type;"
    },
    {
        "line": 134,
        "fullcodeline": "rc = 4;"
    },
    {
        "line": 136,
        "fullcodeline": "} else if (str_type == R_STRING_TYPE_WIDE) {"
    },
    {
        "line": 196,
        "fullcodeline": "char ch = tmp[j];"
    },
    {
        "line": 217,
        "fullcodeline": "num_chars = 0;"
    },
    {
        "line": 218,
        "fullcodeline": "actual_ascii = 0;"
    },
    {
        "line": 226,
        "fullcodeline": "expected_ascii = num_blocks ? num_chars / num_blocks : 0;"
    },
    {
        "line": 236,
        "fullcodeline": "needle++;"
    },
    {
        "line": 251,
        "fullcodeline": "if (str_start - from > 1) {"
    },
    {
        "line": 252,
        "fullcodeline": "const ut8 *p = buf + str_start - 2 - from;"
    },
    {
        "line": 259,
        "fullcodeline": "if (str_start - from > 3) {"
    },
    {
        "line": 260,
        "fullcodeline": "const ut8 *p = buf + str_start - 4 - from;"
    },
    {
        "line": 269,
        "fullcodeline": "s = section;"
    },
    {
        "line": 274,
        "fullcodeline": "vdelta = s->vaddr;"
    },
    {
        "line": 275,
        "fullcodeline": "pdelta = s->paddr;"
    },
    {
        "line": 285,
        "fullcodeline": "ht_up_insert (bf->o->strings_db, bs->vaddr, bs);"
    },
    {
        "line": 54,
        "fullcodeline": "if (out[i] == '?') {"
    },
    {
        "line": 111,
        "fullcodeline": "str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;"
    },
    {
        "line": 115,
        "fullcodeline": "str_type = R_STRING_TYPE_UTF8; // could be charset if set :?"
    },
    {
        "line": 137,
        "fullcodeline": "rc = r_utf16le_decode (buf + needle - from, to - needle, &r);"
    },
    {
        "line": 158,
        "fullcodeline": "if (r == 0xff) {"
    },
    {
        "line": 165,
        "fullcodeline": "} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {"
    },
    {
        "line": 176,
        "fullcodeline": "rc = 2;"
    },
    {
        "line": 177,
        "fullcodeline": "runes++;"
    },
    {
        "line": 210,
        "fullcodeline": "str_type == R_STRING_TYPE_WIDE? &freq_list: NULL);"
    },
    {
        "line": 212,
        "fullcodeline": "for (j = 0; block_list[j] != -1; j++) {"
    },
    {
        "line": 219,
        "fullcodeline": "for (j = 0; freq_list[j] != -1; j++) {"
    },
    {
        "line": 253,
        "fullcodeline": "if (p[0] == 0xff && p[1] == 0xfe) {"
    },
    {
        "line": 261,
        "fullcodeline": "if (p[0] == 0xff && p[1] == 0xfe) {"
    },
    {
        "line": 55,
        "fullcodeline": "out[i] = 0;"
    },
    {
        "line": 98,
        "fullcodeline": "if (!w[5] && !w[6] && w[7] && w[8]) {"
    },
    {
        "line": 99,
        "fullcodeline": "is_wide32le = false;"
    },
    {
        "line": 110,
        "fullcodeline": "bool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];"
    },
    {
        "line": 117,
        "fullcodeline": "str_type = R_STRING_TYPE_ASCII;"
    },
    {
        "line": 138,
        "fullcodeline": "if (rc == 1) {"
    },
    {
        "line": 142,
        "fullcodeline": "rc = r_utf8_decode (buf + needle - from, to - needle, &r);"
    },
    {
        "line": 159,
        "fullcodeline": "r = 0;"
    },
    {
        "line": 197,
        "fullcodeline": "if (ch != '\\n' && ch != '\\r' && ch != '\\t') {"
    },
    {
        "line": 213,
        "fullcodeline": "num_blocks++;"
    },
    {
        "line": 220,
        "fullcodeline": "num_chars += freq_list[j];"
    },
    {
        "line": 228,
        "fullcodeline": "ascii_only = true;"
    },
    {
        "line": 229,
        "fullcodeline": "needle = str_start;"
    },
    {
        "line": 254,
        "fullcodeline": "str_start -= 2; // \\xff\\xfe"
    },
    {
        "line": 262,
        "fullcodeline": "str_start -= 4; // \\xff\\xfe\\x00\\x00"
    },
    {
        "line": 139,
        "fullcodeline": "rc = 2;"
    },
    {
        "line": 143,
        "fullcodeline": "if (rc > 1) {"
    },
    {
        "line": 166,
        "fullcodeline": "if ((i + 32) < sizeof (tmp) && r < 93) {"
    },
    {
        "line": 167,
        "fullcodeline": "tmp[i + 0] = '\\\\';"
    },
    {
        "line": 168,
        "fullcodeline": "tmp[i + 1] = \"       abtnvfr             e  \""
    },
    {
        "line": 221,
        "fullcodeline": "if (!block_list[j]) { // ASCII"
    },
    {
        "line": 271,
        "fullcodeline": "s = r_bin_get_section_at (bf->o, str_start, false);"
    },
    {
        "line": 144,
        "fullcodeline": "str_type = R_STRING_TYPE_UTF8;"
    },
    {
        "line": 198,
        "fullcodeline": "if (!IS_PRINTABLE (tmp[j])) {"
    },
    {
        "line": 222,
        "fullcodeline": "actual_ascii = freq_list[j];"
    }
]