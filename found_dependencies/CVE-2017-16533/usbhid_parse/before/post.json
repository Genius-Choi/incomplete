[
    {
        "line": 3,
        "fullcodeline": "struct usb_interface *intf = to_usb_interface(hid->dev.parent);"
    },
    {
        "line": 4,
        "fullcodeline": "struct usb_host_interface *interface = intf->cur_altsetting;"
    },
    {
        "line": 5,
        "fullcodeline": "struct usb_device *dev = interface_to_usbdev (intf);"
    },
    {
        "line": 7,
        "fullcodeline": "u32 quirks = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned int rsize = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),"
    },
    {
        "line": 33,
        "fullcodeline": "hid->version = le16_to_cpu(hdesc->bcdHID);"
    },
    {
        "line": 34,
        "fullcodeline": "hid->country = hdesc->bCountryCode;"
    },
    {
        "line": 45,
        "fullcodeline": "rdesc = kmalloc(rsize, GFP_KERNEL);"
    },
    {
        "line": 49,
        "fullcodeline": "hid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);"
    },
    {
        "line": 51,
        "fullcodeline": "ret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,"
    },
    {
        "line": 59,
        "fullcodeline": "ret = hid_parse_report(hid, rdesc, rsize);"
    },
    {
        "line": 60,
        "fullcodeline": "kfree(rdesc);"
    },
    {
        "line": 66,
        "fullcodeline": "hid->quirks |= quirks;"
    },
    {
        "line": 15,
        "fullcodeline": "if (quirks & HID_QUIRK_IGNORE)"
    },
    {
        "line": 20,
        "fullcodeline": "if (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&"
    },
    {
        "line": 36,
        "fullcodeline": "for (n = 0; n < hdesc->bNumDescriptors; n++)"
    },
    {
        "line": 40,
        "fullcodeline": "if (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (!rdesc)"
    },
    {
        "line": 53,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 27,
        "fullcodeline": "(!interface->desc.bNumEndpoints ||"
    },
    {
        "line": 29,
        "fullcodeline": "dbg_hid(\"class descriptor not present\\n\");"
    },
    {
        "line": 37,
        "fullcodeline": "if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)"
    },
    {
        "line": 41,
        "fullcodeline": "dbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);"
    },
    {
        "line": 54,
        "fullcodeline": "dbg_hid(\"reading report descriptor failed\\n\");"
    },
    {
        "line": 55,
        "fullcodeline": "kfree(rdesc);"
    },
    {
        "line": 62,
        "fullcodeline": "dbg_hid(\"parsing report descriptor failed\\n\");"
    },
    {
        "line": 16,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 21,
        "fullcodeline": "if (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||"
    },
    {
        "line": 28,
        "fullcodeline": "usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {"
    },
    {
        "line": 30,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 38,
        "fullcodeline": "rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);"
    },
    {
        "line": 42,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 47,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 22,
        "fullcodeline": "interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)"
    },
    {
        "line": 23,
        "fullcodeline": "quirks |= HID_QUIRK_NOGET;"
    }
]