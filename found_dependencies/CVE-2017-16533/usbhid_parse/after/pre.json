[
    {
        "line": 3,
        "fullcodeline": "struct usb_interface *intf = to_usb_interface(hid->dev.parent);"
    },
    {
        "line": 4,
        "fullcodeline": "struct usb_host_interface *interface = intf->cur_altsetting;"
    },
    {
        "line": 5,
        "fullcodeline": "struct usb_device *dev = interface_to_usbdev (intf);"
    },
    {
        "line": 7,
        "fullcodeline": "u32 quirks = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned int rsize = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),"
    },
    {
        "line": 40,
        "fullcodeline": "hid->version = le16_to_cpu(hdesc->bcdHID);"
    },
    {
        "line": 41,
        "fullcodeline": "hid->country = hdesc->bCountryCode;"
    },
    {
        "line": 55,
        "fullcodeline": "rdesc = kmalloc(rsize, GFP_KERNEL);"
    },
    {
        "line": 59,
        "fullcodeline": "hid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);"
    },
    {
        "line": 61,
        "fullcodeline": "ret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,"
    },
    {
        "line": 69,
        "fullcodeline": "ret = hid_parse_report(hid, rdesc, rsize);"
    },
    {
        "line": 17,
        "fullcodeline": "if (quirks & HID_QUIRK_IGNORE)"
    },
    {
        "line": 22,
        "fullcodeline": "if (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {"
    },
    {
        "line": 46,
        "fullcodeline": "for (n = 0; n < num_descriptors; n++)"
    },
    {
        "line": 56,
        "fullcodeline": "if (!rdesc)"
    },
    {
        "line": 63,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 15,
        "fullcodeline": "le16_to_cpu(dev->descriptor.idProduct));"
    },
    {
        "line": 28,
        "fullcodeline": "if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&"
    },
    {
        "line": 29,
        "fullcodeline": "(!interface->desc.bNumEndpoints ||"
    },
    {
        "line": 35,
        "fullcodeline": "if (hdesc->bLength < sizeof(struct hid_descriptor)) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)"
    },
    {
        "line": 50,
        "fullcodeline": "if (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {"
    },
    {
        "line": 18,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 30,
        "fullcodeline": "usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {"
    },
    {
        "line": 32,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 37,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 48,
        "fullcodeline": "rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);"
    },
    {
        "line": 52,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 57,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 23,
        "fullcodeline": "if (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||"
    },
    {
        "line": 24,
        "fullcodeline": "interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)"
    },
    {
        "line": 25,
        "fullcodeline": "quirks |= HID_QUIRK_NOGET;"
    }
]