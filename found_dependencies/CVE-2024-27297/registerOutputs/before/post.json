[
    {
        "line": 13,
        "fullcodeline": "std::map<std::string, ValidPathInfo> infos;"
    },
    {
        "line": 20,
        "fullcodeline": "Path checkSuffix = \".check\";"
    },
    {
        "line": 34,
        "fullcodeline": "auto toRealPathChroot = [&](const Path & p) -> Path {"
    },
    {
        "line": 135,
        "fullcodeline": "auto sortedOutputNames = topoSort(outputsToSort,"
    },
    {
        "line": 165,
        "fullcodeline": "std::reverse(sortedOutputNames.begin(), sortedOutputNames.end());"
    },
    {
        "line": 28,
        "fullcodeline": "for (auto & p : inputPaths) referenceablePaths.insert(p);"
    },
    {
        "line": 29,
        "fullcodeline": "for (auto & i : scratchOutputs) referenceablePaths.insert(i.second);"
    },
    {
        "line": 30,
        "fullcodeline": "for (auto & p : addedPaths) referenceablePaths.insert(p);"
    },
    {
        "line": 487,
        "fullcodeline": "if (buildMode == bmCheck) {"
    },
    {
        "line": 503,
        "fullcodeline": "auto & localStore = getLocalStore();"
    },
    {
        "line": 509,
        "fullcodeline": "localStore.registerValidPaths(infos2);"
    },
    {
        "line": 51,
        "fullcodeline": "auto scratchOutput = get(scratchOutputs, outputName);"
    },
    {
        "line": 56,
        "fullcodeline": "auto actualPath = toRealPathChroot(worker.store.printStorePath(*scratchOutput));"
    },
    {
        "line": 58,
        "fullcodeline": "outputsToSort.insert(outputName);"
    },
    {
        "line": 61,
        "fullcodeline": "auto initialOutput = get(initialOutputs, outputName);"
    },
    {
        "line": 69,
        "fullcodeline": "initialInfo.wanted = buildMode == bmCheck"
    },
    {
        "line": 102,
        "fullcodeline": "canonicalisePathMetaData("
    },
    {
        "line": 107,
        "fullcodeline": "bool discardReferences = false;"
    },
    {
        "line": 129,
        "fullcodeline": "outputReferencesIfUnregistered.insert_or_assign("
    },
    {
        "line": 132,
        "fullcodeline": "outputStats.insert_or_assign(outputName, std::move(st));"
    },
    {
        "line": 136,
        "fullcodeline": "{[&](const std::string & name) {"
    },
    {
        "line": 158,
        "fullcodeline": "{[&](const std::string & path, const std::string & parent) {"
    },
    {
        "line": 170,
        "fullcodeline": "auto output = get(drv->outputs, outputName);"
    },
    {
        "line": 171,
        "fullcodeline": "auto scratchPath = get(scratchOutputs, outputName);"
    },
    {
        "line": 172,
        "fullcodeline": "assert(output && scratchPath);"
    },
    {
        "line": 173,
        "fullcodeline": "auto actualPath = toRealPathChroot(worker.store.printStorePath(*scratchPath));"
    },
    {
        "line": 175,
        "fullcodeline": "auto finish = [&](StorePath finalStorePath) {"
    },
    {
        "line": 185,
        "fullcodeline": "auto orifu = get(outputReferencesIfUnregistered, outputName);"
    },
    {
        "line": 186,
        "fullcodeline": "assert(orifu);"
    },
    {
        "line": 188,
        "fullcodeline": "std::optional<StorePathSet> referencesOpt = std::visit(overloaded {"
    },
    {
        "line": 202,
        "fullcodeline": "auto rewriteOutput = [&](const StringMap & rewrites) {"
    },
    {
        "line": 224,
        "fullcodeline": "auto rewriteRefs = [&]() -> StoreReferences {"
    },
    {
        "line": 249,
        "fullcodeline": "auto newInfoFromCA = [&](const DerivationOutput::CAFloating outputHash) -> ValidPathInfo {"
    },
    {
        "line": 310,
        "fullcodeline": "ValidPathInfo newInfo = std::visit(overloaded {"
    },
    {
        "line": 385,
        "fullcodeline": "canonicalisePathMetaData(actualPath, {}, inodesSeen);"
    },
    {
        "line": 390,
        "fullcodeline": "auto finalDestPath = worker.store.printStorePath(newInfo.path);"
    },
    {
        "line": 396,
        "fullcodeline": "dynamicOutputLock.setDeletion(true);"
    },
    {
        "line": 397,
        "fullcodeline": "auto optFixedPath = output->path(worker.store, drv->name, outputName);"
    },
    {
        "line": 426,
        "fullcodeline": "auto & localStore = getLocalStore();"
    },
    {
        "line": 469,
        "fullcodeline": "localStore.optimisePath(actualPath, NoRepair); // FIXME: combine with scanForReferences()"
    },
    {
        "line": 470,
        "fullcodeline": "worker.markContentsGood(newInfo.path);"
    },
    {
        "line": 472,
        "fullcodeline": "newInfo.deriver = drvPath;"
    },
    {
        "line": 473,
        "fullcodeline": "newInfo.ultimate = true;"
    },
    {
        "line": 474,
        "fullcodeline": "localStore.signPathInfo(newInfo);"
    },
    {
        "line": 476,
        "fullcodeline": "finish(newInfo.path);"
    },
    {
        "line": 484,
        "fullcodeline": "infos.emplace(outputName, std::move(newInfo));"
    },
    {
        "line": 515,
        "fullcodeline": "std::rethrow_exception(delayedException);"
    },
    {
        "line": 525,
        "fullcodeline": "auto oldinfo = get(initialOutputs, outputName);"
    },
    {
        "line": 526,
        "fullcodeline": "assert(oldinfo);"
    },
    {
        "line": 527,
        "fullcodeline": "auto thisRealisation = Realisation {"
    },
    {
        "line": 540,
        "fullcodeline": "builtOutputs.emplace(outputName, thisRealisation);"
    },
    {
        "line": 11,
        "fullcodeline": "return DerivationGoal::registerOutputs();"
    },
    {
        "line": 52,
        "fullcodeline": "if (!scratchOutput)"
    },
    {
        "line": 62,
        "fullcodeline": "if (!initialOutput)"
    },
    {
        "line": 71,
        "fullcodeline": "if (!initialInfo.wanted) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (lstat(actualPath.c_str(), &st) == -1) {"
    },
    {
        "line": 92,
        "fullcodeline": "if ((!S_ISLNK(st.st_mode) && (st.st_mode & (S_IWGRP | S_IWOTH))) ||"
    },
    {
        "line": 104,
        "fullcodeline": "buildUser ? std::optional(buildUser->getUIDRange()) : std::nullopt,"
    },
    {
        "line": 131,
        "fullcodeline": "PerhapsNeedToRegister { .refs = references });"
    },
    {
        "line": 198,
        "fullcodeline": "if (!referencesOpt)"
    },
    {
        "line": 398,
        "fullcodeline": "if (!optFixedPath ||"
    },
    {
        "line": 406,
        "fullcodeline": "if (worker.store.toRealPath(finalDestPath) != actualPath) {"
    },
    {
        "line": 428,
        "fullcodeline": "if (buildMode == bmCheck) {"
    },
    {
        "line": 493,
        "fullcodeline": "return assertPathValidity();"
    },
    {
        "line": 507,
        "fullcodeline": "infos2.insert_or_assign(newInfo.path, newInfo);"
    },
    {
        "line": 534,
        "fullcodeline": "if (experimentalFeatureSettings.isEnabled(Xp::CaDerivations)"
    },
    {
        "line": 70,
        "fullcodeline": "|| !(initialInfo.known && initialInfo.known->isValid());"
    },
    {
        "line": 72,
        "fullcodeline": "outputReferencesIfUnregistered.insert_or_assign("
    },
    {
        "line": 93,
        "fullcodeline": "(buildUser && st.st_uid != buildUser->getUID()))"
    },
    {
        "line": 108,
        "fullcodeline": "if (auto structuredAttrs = parsedDrv->getStructuredAttrs()) {"
    },
    {
        "line": 120,
        "fullcodeline": "debug(\"discarding references of output '%s'\", outputName);"
    },
    {
        "line": 399,
        "fullcodeline": "worker.store.printStorePath(*optFixedPath) != finalDestPath)"
    },
    {
        "line": 401,
        "fullcodeline": "assert(newInfo.ca);"
    },
    {
        "line": 402,
        "fullcodeline": "dynamicOutputLock.lockPaths({worker.store.toRealPath(finalDestPath)});"
    },
    {
        "line": 482,
        "fullcodeline": "localStore.registerValidPaths({{newInfo.path, newInfo}});"
    },
    {
        "line": 492,
        "fullcodeline": "std::rethrow_exception(delayedException);"
    },
    {
        "line": 535,
        "fullcodeline": "&& !drv->type().isImpure())"
    },
    {
        "line": 537,
        "fullcodeline": "signRealisation(thisRealisation);"
    },
    {
        "line": 538,
        "fullcodeline": "worker.store.registerDrvOutput(thisRealisation);"
    },
    {
        "line": 53,
        "fullcodeline": "throw BuildError("
    },
    {
        "line": 63,
        "fullcodeline": "throw BuildError("
    },
    {
        "line": 74,
        "fullcodeline": "AlreadyRegistered { .path = initialInfo.known->path });"
    },
    {
        "line": 80,
        "fullcodeline": "if (errno == ENOENT)"
    },
    {
        "line": 84,
        "fullcodeline": "throw SysError(\"getting attributes of path '%s'\", actualPath);"
    },
    {
        "line": 94,
        "fullcodeline": "throw BuildError("
    },
    {
        "line": 122,
        "fullcodeline": "debug(\"scanning for references for output '%s' in temp location '%s'\", outputName, actualPath);"
    },
    {
        "line": 126,
        "fullcodeline": "references = scanForReferences(blank, actualPath, referenceablePaths);"
    },
    {
        "line": 407,
        "fullcodeline": "if (buildMode == bmRepair) {"
    },
    {
        "line": 430,
        "fullcodeline": "if (!worker.store.isValidPath(newInfo.path)) continue;"
    },
    {
        "line": 432,
        "fullcodeline": "if (newInfo.narHash != oldInfo.narHash) {"
    },
    {
        "line": 463,
        "fullcodeline": "if (references.count(i))"
    },
    {
        "line": 55,
        "fullcodeline": "worker.store.printStorePath(drvPath), outputName);"
    },
    {
        "line": 65,
        "fullcodeline": "worker.store.printStorePath(drvPath), outputName);"
    },
    {
        "line": 109,
        "fullcodeline": "if (auto udr = get(*structuredAttrs, \"unsafeDiscardReferences\")) {"
    },
    {
        "line": 409,
        "fullcodeline": "replaceValidPath(worker.store.toRealPath(finalDestPath), actualPath);"
    },
    {
        "line": 410,
        "fullcodeline": "actualPath = worker.store.toRealPath(finalDestPath);"
    },
    {
        "line": 431,
        "fullcodeline": "ValidPathInfo oldInfo(*worker.store.queryPathInfo(newInfo.path));"
    },
    {
        "line": 433,
        "fullcodeline": "worker.checkMismatch = true;"
    },
    {
        "line": 453,
        "fullcodeline": "oldInfo.ultimate = true;"
    },
    {
        "line": 454,
        "fullcodeline": "localStore.signPathInfo(oldInfo);"
    },
    {
        "line": 455,
        "fullcodeline": "localStore.registerValidPaths({{oldInfo.path, oldInfo}});"
    },
    {
        "line": 464,
        "fullcodeline": "debug(\"referenced input: '%1%'\", worker.store.printStorePath(i));"
    },
    {
        "line": 528,
        "fullcodeline": ".id = DrvOutput {"
    },
    {
        "line": 532,
        "fullcodeline": ".outPath = newInfo.path"
    },
    {
        "line": 81,
        "fullcodeline": "throw BuildError("
    },
    {
        "line": 466,
        "fullcodeline": "debug(\"unreferenced input: '%1%'\", worker.store.printStorePath(i));"
    },
    {
        "line": 83,
        "fullcodeline": "worker.store.printStorePath(drvPath), outputName, actualPath);"
    },
    {
        "line": 110,
        "fullcodeline": "if (auto output = get(*udr, outputName)) {"
    },
    {
        "line": 113,
        "fullcodeline": "discardReferences = output->get<bool>();"
    },
    {
        "line": 411,
        "fullcodeline": "} else if (buildMode == bmCheck) {"
    },
    {
        "line": 435,
        "fullcodeline": "auto dst = worker.store.toRealPath(finalDestPath + checkSuffix);"
    },
    {
        "line": 436,
        "fullcodeline": "deletePath(dst);"
    },
    {
        "line": 437,
        "fullcodeline": "movePath(actualPath, dst);"
    },
    {
        "line": 439,
        "fullcodeline": "handleDiffHook("
    },
    {
        "line": 111,
        "fullcodeline": "if (!output->is_boolean())"
    },
    {
        "line": 440,
        "fullcodeline": "buildUser ? buildUser->getUID() : getuid(),"
    },
    {
        "line": 441,
        "fullcodeline": "buildUser ? buildUser->getGID() : getgid(),"
    },
    {
        "line": 442,
        "fullcodeline": "finalDestPath, dst, worker.store.printStorePath(drvPath), tmpDir);"
    },
    {
        "line": 444,
        "fullcodeline": "throw NotDeterministic(\"derivation '%s' may not be deterministic: output '%s' differs from '%s'\","
    },
    {
        "line": 445,
        "fullcodeline": "worker.store.printStorePath(drvPath), worker.store.toRealPath(finalDestPath), dst);"
    },
    {
        "line": 447,
        "fullcodeline": "throw NotDeterministic(\"derivation '%s' may not be deterministic: output '%s' differs\","
    },
    {
        "line": 112,
        "fullcodeline": "throw Error(\"attribute 'unsafeDiscardReferences.\\\"%s\\\"' of derivation '%s' must be a Boolean\", outputName, drvPath.to_string());"
    },
    {
        "line": 414,
        "fullcodeline": "} else if (worker.store.isValidPath(newInfo.path)) {"
    },
    {
        "line": 448,
        "fullcodeline": "worker.store.printStorePath(drvPath), worker.store.toRealPath(finalDestPath));"
    },
    {
        "line": 417,
        "fullcodeline": "assert(newInfo.ca);"
    },
    {
        "line": 419,
        "fullcodeline": "auto destPath = worker.store.toRealPath(finalDestPath);"
    },
    {
        "line": 420,
        "fullcodeline": "deletePath(destPath);"
    },
    {
        "line": 421,
        "fullcodeline": "movePath(actualPath, destPath);"
    },
    {
        "line": 422,
        "fullcodeline": "actualPath = destPath;"
    }
]