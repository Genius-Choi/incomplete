[
    {
        "line": 11,
        "fullcodeline": "const HttpHeader *hdr_in = &request->header;"
    },
    {
        "line": 12,
        "fullcodeline": "const HttpHeaderEntry *e = nullptr;"
    },
    {
        "line": 13,
        "fullcodeline": "HttpHeaderPos pos = HttpHeaderInitPos;"
    },
    {
        "line": 14,
        "fullcodeline": "assert (hdr_out->owner == hoRequest);"
    },
    {
        "line": 27,
        "fullcodeline": "bool we_do_ranges = decideIfWeDoRanges (request);"
    },
    {
        "line": 29,
        "fullcodeline": "String strConnection (hdr_in->getList(Http::HdrType::CONNECTION));"
    },
    {
        "line": 45,
        "fullcodeline": "hdr_out->addVia(request->http_ver, hdr_in);"
    },
    {
        "line": 126,
        "fullcodeline": "httpFixupAuthentication(request, hdr_in, hdr_out, flags);"
    },
    {
        "line": 170,
        "fullcodeline": "httpHdrMangleList(hdr_out, request, al, ROR_REQUEST);"
    },
    {
        "line": 172,
        "fullcodeline": "strConnection.clean();"
    },
    {
        "line": 17,
        "fullcodeline": "if (request->lastmod > -1)"
    },
    {
        "line": 22,
        "fullcodeline": "if (request->etag.size() > 0) {"
    },
    {
        "line": 31,
        "fullcodeline": "while ((e = hdr_in->getEntry(&pos)))"
    },
    {
        "line": 32,
        "fullcodeline": "copyOneHeaderFromClientsideRequestToUpstreamRequest(e, strConnection, request, hdr_out, we_do_ranges, flags);"
    },
    {
        "line": 37,
        "fullcodeline": "if (!we_do_ranges && request->multipartRangeRequest()) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (strcmp(opt_forwarded_for, \"delete\") != 0) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (!hdr_out->has(Http::HdrType::HOST)) {"
    },
    {
        "line": 112,
        "fullcodeline": "if (!hdr_out->has(Http::HdrType::AUTHORIZATION)) {"
    },
    {
        "line": 130,
        "fullcodeline": "HttpHdrCc *cc = hdr_in->getCc();"
    },
    {
        "line": 146,
        "fullcodeline": "hdr_out->putCc(cc);"
    },
    {
        "line": 148,
        "fullcodeline": "delete cc;"
    },
    {
        "line": 154,
        "fullcodeline": "if (!hdr_out->has(Http::HdrType::CONNECTION)) // forwardUpgrade() may add it"
    },
    {
        "line": 18,
        "fullcodeline": "hdr_out->putTime(Http::HdrType::IF_MODIFIED_SINCE, request->lastmod);"
    },
    {
        "line": 23,
        "fullcodeline": "hdr_out->addEntry(new HttpHeaderEntry(Http::HdrType::IF_NONE_MATCH, SBuf(),"
    },
    {
        "line": 39,
        "fullcodeline": "request->flags.cachable.veto();"
    },
    {
        "line": 41,
        "fullcodeline": "request->ignoreRange(\"want to request the whole object\");"
    },
    {
        "line": 42,
        "fullcodeline": "request->flags.isRanged = false;"
    },
    {
        "line": 49,
        "fullcodeline": "String strSurrogate(hdr_in->getList(Http::HdrType::SURROGATE_CAPABILITY));"
    },
    {
        "line": 53,
        "fullcodeline": "snprintf(bbuf, BBUF_SZ, \"%s=\\\"Surrogate/1.0\\\"\", Config.Accel.surrogate_id);"
    },
    {
        "line": 55,
        "fullcodeline": "strListAdd(&strSurrogate, bbuf, ',');"
    },
    {
        "line": 56,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::SURROGATE_CAPABILITY, strSurrogate.termedBuf());"
    },
    {
        "line": 62,
        "fullcodeline": "String strFwd = hdr_in->getList(Http::HdrType::X_FORWARDED_FOR);"
    },
    {
        "line": 132,
        "fullcodeline": "if (!cc)"
    },
    {
        "line": 136,
        "fullcodeline": "if (!cc->hasMaxAge() && !cc->hasNoCache()) {"
    },
    {
        "line": 155,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::CONNECTION, flags.keepalive ? \"keep-alive\" : \"close\");"
    },
    {
        "line": 166,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::TRANSFER_ENCODING, \"chunked\");"
    },
    {
        "line": 65,
        "fullcodeline": "if (!strFwd.canGrowBy(strFwd.size())) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (strcmp(opt_forwarded_for, \"on\") == 0) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (strFwd.size() > 0)"
    },
    {
        "line": 113,
        "fullcodeline": "if (flags.toOrigin && !request->url.userInfo().isEmpty()) {"
    },
    {
        "line": 133,
        "fullcodeline": "cc = new HttpHdrCc();"
    },
    {
        "line": 138,
        "fullcodeline": "SBuf tmp(request->effectiveRequestUri());"
    },
    {
        "line": 139,
        "fullcodeline": "cc->maxAge(getMaxAge(entry ? entry->url() : tmp.c_str()));"
    },
    {
        "line": 144,
        "fullcodeline": "cc->onlyIfCached(true);"
    },
    {
        "line": 159,
        "fullcodeline": "if (flags.front_end_https == 1 || request->url.getScheme() == AnyP::PROTO_HTTPS)"
    },
    {
        "line": 24,
        "fullcodeline": "request->etag.termedBuf()));"
    },
    {
        "line": 69,
        "fullcodeline": "strFwd = \"error\";"
    },
    {
        "line": 71,
        "fullcodeline": "static int warnedCount = 0;"
    },
    {
        "line": 97,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::X_FORWARDED_FOR, strFwd.termedBuf());"
    },
    {
        "line": 104,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::HOST, request->peer_domain);"
    },
    {
        "line": 114,
        "fullcodeline": "static char result[base64_encode_len(MAX_URL*2)]; // should be big enough for a single URI segment"
    },
    {
        "line": 116,
        "fullcodeline": "base64_encode_init(&ctx);"
    },
    {
        "line": 117,
        "fullcodeline": "size_t blen = base64_encode_update(&ctx, result, request->url.userInfo().length(), reinterpret_cast<const uint8_t*>(request->url.userInfo().rawContent()));"
    },
    {
        "line": 118,
        "fullcodeline": "blen += base64_encode_final(&ctx, result+blen);"
    },
    {
        "line": 119,
        "fullcodeline": "result[blen] = '\\0';"
    },
    {
        "line": 160,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::FRONT_END_HTTPS, \"On\");"
    },
    {
        "line": 72,
        "fullcodeline": "if (warnedCount++ < 100) {"
    },
    {
        "line": 80,
        "fullcodeline": "if ( request->client_addr.isNoAddr() )"
    },
    {
        "line": 106,
        "fullcodeline": "SBuf authority = request->url.authority();"
    },
    {
        "line": 107,
        "fullcodeline": "hdr_out->putStr(Http::HdrType::HOST, authority.c_str());"
    },
    {
        "line": 73,
        "fullcodeline": "const SBuf url(entry ? SBuf(entry->url()) : request->effectiveRequestUri());"
    },
    {
        "line": 74,
        "fullcodeline": "debugs(11, DBG_IMPORTANT, \"WARNING: likely forwarding loop with \" << url);"
    },
    {
        "line": 81,
        "fullcodeline": "strListAdd(&strFwd, \"unknown\", ',');"
    },
    {
        "line": 84,
        "fullcodeline": "} else if (strcmp(opt_forwarded_for, \"off\") == 0) {"
    },
    {
        "line": 121,
        "fullcodeline": "httpHeaderPutStrf(hdr_out, Http::HdrType::AUTHORIZATION, \"Basic %.*s\", (int)blen, result);"
    },
    {
        "line": 83,
        "fullcodeline": "strListAdd(&strFwd, request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN), ',');"
    },
    {
        "line": 86,
        "fullcodeline": "strListAdd(&strFwd, \"unknown\", ',');"
    },
    {
        "line": 87,
        "fullcodeline": "} else if (strcmp(opt_forwarded_for, \"transparent\") == 0) {"
    },
    {
        "line": 89,
        "fullcodeline": "} else if (strcmp(opt_forwarded_for, \"truncate\") == 0) {"
    },
    {
        "line": 91,
        "fullcodeline": "if ( request->client_addr.isNoAddr() )"
    },
    {
        "line": 92,
        "fullcodeline": "strFwd = \"unknown\";"
    },
    {
        "line": 94,
        "fullcodeline": "strFwd = request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN);"
    }
]