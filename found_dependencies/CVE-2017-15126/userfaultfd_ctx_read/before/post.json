[
    {
        "line": 5,
        "fullcodeline": "DECLARE_WAITQUEUE(wait, current);"
    },
    {
        "line": 14,
        "fullcodeline": "LIST_HEAD(fork_event);"
    },
    {
        "line": 15,
        "fullcodeline": "struct userfaultfd_ctx *fork_nctx = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "__add_wait_queue(&ctx->fd_wqh, &wait);"
    },
    {
        "line": 102,
        "fullcodeline": "__remove_wait_queue(&ctx->fd_wqh, &wait);"
    },
    {
        "line": 103,
        "fullcodeline": "__set_current_state(TASK_RUNNING);"
    },
    {
        "line": 104,
        "fullcodeline": "spin_unlock(&ctx->fd_wqh.lock);"
    },
    {
        "line": 106,
        "fullcodeline": "if (!ret && msg->event == UFFD_EVENT_FORK) {"
    },
    {
        "line": 21,
        "fullcodeline": "set_current_state(TASK_INTERRUPTIBLE);"
    },
    {
        "line": 22,
        "fullcodeline": "spin_lock(&ctx->fault_pending_wqh.lock);"
    },
    {
        "line": 23,
        "fullcodeline": "uwq = find_userfault(ctx);"
    },
    {
        "line": 66,
        "fullcodeline": "spin_unlock(&ctx->fault_pending_wqh.lock);"
    },
    {
        "line": 68,
        "fullcodeline": "spin_lock(&ctx->event_wqh.lock);"
    },
    {
        "line": 69,
        "fullcodeline": "uwq = find_userfault_evt(ctx);"
    },
    {
        "line": 88,
        "fullcodeline": "spin_unlock(&ctx->event_wqh.lock);"
    },
    {
        "line": 98,
        "fullcodeline": "spin_unlock(&ctx->fd_wqh.lock);"
    },
    {
        "line": 99,
        "fullcodeline": "schedule();"
    },
    {
        "line": 100,
        "fullcodeline": "spin_lock(&ctx->fd_wqh.lock);"
    },
    {
        "line": 107,
        "fullcodeline": "ret = resolve_userfault_fork(ctx, fork_nctx, msg);"
    },
    {
        "line": 90,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (!ret) {"
    },
    {
        "line": 32,
        "fullcodeline": "write_seqcount_begin(&ctx->refile_seq);"
    },
    {
        "line": 56,
        "fullcodeline": "__add_wait_queue(&ctx->fault_wqh, &uwq->wq);"
    },
    {
        "line": 58,
        "fullcodeline": "write_seqcount_end(&ctx->refile_seq);"
    },
    {
        "line": 61,
        "fullcodeline": "*msg = uwq->msg;"
    },
    {
        "line": 62,
        "fullcodeline": "spin_unlock(&ctx->fault_pending_wqh.lock);"
    },
    {
        "line": 63,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "*msg = uwq->msg;"
    },
    {
        "line": 83,
        "fullcodeline": "userfaultfd_event_complete(ctx, uwq);"
    },
    {
        "line": 84,
        "fullcodeline": "spin_unlock(&ctx->event_wqh.lock);"
    },
    {
        "line": 85,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "ret = -ERESTARTSYS;"
    },
    {
        "line": 95,
        "fullcodeline": "ret = -EAGAIN;"
    },
    {
        "line": 110,
        "fullcodeline": "spin_lock(&ctx->event_wqh.lock);"
    },
    {
        "line": 119,
        "fullcodeline": "spin_unlock(&ctx->event_wqh.lock);"
    },
    {
        "line": 73,
        "fullcodeline": "if (uwq->msg.event == UFFD_EVENT_FORK) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (!list_empty(&fork_event)) {"
    },
    {
        "line": 77,
        "fullcodeline": "list_move(&uwq->wq.entry, &fork_event);"
    },
    {
        "line": 78,
        "fullcodeline": "spin_unlock(&ctx->event_wqh.lock);"
    },
    {
        "line": 79,
        "fullcodeline": "ret = 0;"
    },
    {
        "line": 115,
        "fullcodeline": "list_del(&uwq->wq.entry);"
    },
    {
        "line": 116,
        "fullcodeline": "__add_wait_queue(&ctx->event_wqh, &uwq->wq);"
    },
    {
        "line": 117,
        "fullcodeline": "userfaultfd_event_complete(ctx, uwq);"
    }
]