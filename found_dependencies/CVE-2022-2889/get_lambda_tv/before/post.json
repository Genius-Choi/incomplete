[
    {
        "line": 7,
        "fullcodeline": "int\t\tevaluate = evalarg != NULL"
    },
    {
        "line": 14,
        "fullcodeline": "ufunc_T\t*fp = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "partial_T   *pt = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "char_u\t*ret_type = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\t*old_eval_lavars = eval_lavars_used;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\teval_lavars = FALSE;"
    },
    {
        "line": 23,
        "fullcodeline": "char_u\t*tofree1 = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "char_u\t*tofree2 = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "int\t\tequal_arrow = **arg == '(';"
    },
    {
        "line": 26,
        "fullcodeline": "int\t\twhite_error = FALSE;"
    },
    {
        "line": 27,
        "fullcodeline": "int\t\tcalled_emsg_start = called_emsg;"
    },
    {
        "line": 28,
        "fullcodeline": "int\t\tvim9script = in_vim9script();"
    },
    {
        "line": 29,
        "fullcodeline": "long\tstart_lnum = SOURCING_LNUM;"
    },
    {
        "line": 34,
        "fullcodeline": "ga_init(&newargs);"
    },
    {
        "line": 35,
        "fullcodeline": "ga_init(&newlines);"
    },
    {
        "line": 39,
        "fullcodeline": "s = *arg + 1;"
    },
    {
        "line": 40,
        "fullcodeline": "ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,"
    },
    {
        "line": 55,
        "fullcodeline": "*arg += 1;"
    },
    {
        "line": 56,
        "fullcodeline": "ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,"
    },
    {
        "line": 69,
        "fullcodeline": "*arg = s;"
    },
    {
        "line": 82,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 104,
        "fullcodeline": "start = *arg;"
    },
    {
        "line": 105,
        "fullcodeline": "ret = skip_expr_concatenate(arg, &start, &end, evalarg);"
    },
    {
        "line": 235,
        "fullcodeline": "eval_lavars_used = old_eval_lavars;"
    },
    {
        "line": 240,
        "fullcodeline": "vim_free(tofree2);"
    },
    {
        "line": 247,
        "fullcodeline": "ga_clear_strings(&newargs);"
    },
    {
        "line": 248,
        "fullcodeline": "ga_clear_strings(&newlines);"
    },
    {
        "line": 249,
        "fullcodeline": "ga_clear_strings(&default_args);"
    },
    {
        "line": 256,
        "fullcodeline": "vim_free(fp);"
    },
    {
        "line": 257,
        "fullcodeline": "vim_free(pt);"
    },
    {
        "line": 262,
        "fullcodeline": "vim_free(tofree2);"
    },
    {
        "line": 263,
        "fullcodeline": "eval_lavars_used = old_eval_lavars;"
    },
    {
        "line": 31,
        "fullcodeline": "if (equal_arrow && !vim9script)"
    },
    {
        "line": 43,
        "fullcodeline": "if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)"
    },
    {
        "line": 60,
        "fullcodeline": "if (ret == FAIL"
    },
    {
        "line": 72,
        "fullcodeline": "if (ret_type != NULL)"
    },
    {
        "line": 85,
        "fullcodeline": "if (equal_arrow && **arg == '{')"
    },
    {
        "line": 97,
        "fullcodeline": "if (default_args.ga_len > 0)"
    },
    {
        "line": 106,
        "fullcodeline": "if (ret == FAIL)"
    },
    {
        "line": 108,
        "fullcodeline": "if (evalarg != NULL)"
    },
    {
        "line": 115,
        "fullcodeline": "if (!equal_arrow)"
    },
    {
        "line": 236,
        "fullcodeline": "if (evalarg != NULL && evalarg->eval_tofree == NULL)"
    },
    {
        "line": 258,
        "fullcodeline": "if (evalarg != NULL && evalarg->eval_tofree == NULL)"
    },
    {
        "line": 8,
        "fullcodeline": "&& (evalarg->eval_flags & EVAL_EVALUATE);"
    },
    {
        "line": 41,
        "fullcodeline": "types_optional ? &argtypes : NULL, types_optional, evalarg,"
    },
    {
        "line": 52,
        "fullcodeline": "pnewargs = &newargs;"
    },
    {
        "line": 57,
        "fullcodeline": "types_optional ? &argtypes : NULL, types_optional, evalarg,"
    },
    {
        "line": 61,
        "fullcodeline": "|| (s = skip_arrow(*arg, equal_arrow, &ret_type,"
    },
    {
        "line": 66,
        "fullcodeline": "ga_clear_strings(&newargs);"
    },
    {
        "line": 74,
        "fullcodeline": "ret_type = vim_strsave(ret_type);"
    },
    {
        "line": 75,
        "fullcodeline": "tofree2 = ret_type;"
    },
    {
        "line": 80,
        "fullcodeline": "eval_lavars_used = &eval_lavars;"
    },
    {
        "line": 90,
        "fullcodeline": "SOURCING_LNUM = start_lnum;  // used for where lambda is defined"
    },
    {
        "line": 99,
        "fullcodeline": "emsg(_(e_cannot_use_default_values_in_lambda));"
    },
    {
        "line": 111,
        "fullcodeline": "tofree1 = evalarg->eval_tofree;"
    },
    {
        "line": 112,
        "fullcodeline": "evalarg->eval_tofree = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 123,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 129,
        "fullcodeline": "int\t    flags = FC_LAMBDA;"
    },
    {
        "line": 132,
        "fullcodeline": "char_u\t    *name = get_lambda_name();"
    },
    {
        "line": 134,
        "fullcodeline": "fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);"
    },
    {
        "line": 137,
        "fullcodeline": "fp->uf_def_status = UF_NOT_COMPILED;"
    },
    {
        "line": 138,
        "fullcodeline": "pt = ALLOC_CLEAR_ONE(partial_T);"
    },
    {
        "line": 142,
        "fullcodeline": "ga_init2(&newlines, sizeof(char_u *), 1);"
    },
    {
        "line": 147,
        "fullcodeline": "line_end = vim_strchr(start, '\\n');"
    },
    {
        "line": 152,
        "fullcodeline": "len = 7 + (int)(line_end - start) + 1;"
    },
    {
        "line": 153,
        "fullcodeline": "p = alloc(len);"
    },
    {
        "line": 156,
        "fullcodeline": "((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;"
    },
    {
        "line": 157,
        "fullcodeline": "STRCPY(p, \"return \");"
    },
    {
        "line": 158,
        "fullcodeline": "vim_strncpy(p + 7, start, line_end - start);"
    },
    {
        "line": 181,
        "fullcodeline": "fp->uf_refcount = 1;"
    },
    {
        "line": 182,
        "fullcodeline": "set_ufunc_name(fp, name);"
    },
    {
        "line": 183,
        "fullcodeline": "fp->uf_args = newargs;"
    },
    {
        "line": 184,
        "fullcodeline": "ga_init(&fp->uf_def_args);"
    },
    {
        "line": 201,
        "fullcodeline": "fp->uf_lines = newlines;"
    },
    {
        "line": 217,
        "fullcodeline": "fp->uf_varargs = !vim9script || varargs;"
    },
    {
        "line": 218,
        "fullcodeline": "fp->uf_flags = flags;"
    },
    {
        "line": 219,
        "fullcodeline": "fp->uf_calls = 0;"
    },
    {
        "line": 220,
        "fullcodeline": "fp->uf_script_ctx = current_sctx;"
    },
    {
        "line": 222,
        "fullcodeline": "fp->uf_script_ctx.sc_lnum += start_lnum;"
    },
    {
        "line": 224,
        "fullcodeline": "function_using_block_scopes(fp, evalarg->eval_cstack);"
    },
    {
        "line": 226,
        "fullcodeline": "pt->pt_func = fp;"
    },
    {
        "line": 227,
        "fullcodeline": "pt->pt_refcount = 1;"
    },
    {
        "line": 228,
        "fullcodeline": "rettv->vval.v_partial = pt;"
    },
    {
        "line": 229,
        "fullcodeline": "rettv->v_type = VAR_PARTIAL;"
    },
    {
        "line": 231,
        "fullcodeline": "hash_add(&func_hashtab, UF2HIKEY(fp));"
    },
    {
        "line": 237,
        "fullcodeline": "evalarg->eval_tofree = tofree1;"
    },
    {
        "line": 242,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 252,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 259,
        "fullcodeline": "evalarg->eval_tofree = tofree1;"
    },
    {
        "line": 47,
        "fullcodeline": "return called_emsg == called_emsg_start ? NOTDONE : FAIL;"
    },
    {
        "line": 54,
        "fullcodeline": "pnewargs = NULL;"
    },
    {
        "line": 67,
        "fullcodeline": "return white_error ? FAIL : NOTDONE;"
    },
    {
        "line": 87,
        "fullcodeline": "if (evalarg == NULL)"
    },
    {
        "line": 91,
        "fullcodeline": "if (lambda_function_body(arg, rettv, evalarg, pnewargs,"
    },
    {
        "line": 118,
        "fullcodeline": "if (**arg != '}')"
    },
    {
        "line": 135,
        "fullcodeline": "if (fp == NULL)"
    },
    {
        "line": 139,
        "fullcodeline": "if (pt == NULL)"
    },
    {
        "line": 143,
        "fullcodeline": "if (ga_grow(&newlines, 1) == FAIL)"
    },
    {
        "line": 148,
        "fullcodeline": "if (line_end == NULL || line_end > end)"
    },
    {
        "line": 154,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 160,
        "fullcodeline": "if (line_end != end)"
    },
    {
        "line": 177,
        "fullcodeline": "if (strstr((char *)p + 7, \"a:\") == NULL)"
    },
    {
        "line": 202,
        "fullcodeline": "if (current_funccal != NULL && eval_lavars)"
    },
    {
        "line": 239,
        "fullcodeline": "vim_free(tofree1);"
    },
    {
        "line": 253,
        "fullcodeline": "if (fp != NULL)"
    },
    {
        "line": 261,
        "fullcodeline": "vim_free(tofree1);"
    },
    {
        "line": 46,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 65,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 120,
        "fullcodeline": "semsg(_(e_expected_right_curly_str), *arg);"
    },
    {
        "line": 149,
        "fullcodeline": "line_end = end;"
    },
    {
        "line": 179,
        "fullcodeline": "flags |= FC_NOARGS;"
    },
    {
        "line": 204,
        "fullcodeline": "flags |= FC_CLOSURE;"
    },
    {
        "line": 214,
        "fullcodeline": "flags |= FC_SANDBOX;"
    },
    {
        "line": 254,
        "fullcodeline": "vim_free(fp->uf_arg_types);"
    },
    {
        "line": 62,
        "fullcodeline": "equal_arrow || vim9script ? &white_error : NULL)) == NULL)"
    },
    {
        "line": 92,
        "fullcodeline": "types_optional ? &argtypes : NULL, varargs,"
    },
    {
        "line": 164,
        "fullcodeline": "while (*line_end == '\\n')"
    },
    {
        "line": 187,
        "fullcodeline": "if (parse_argument_types(fp, &argtypes,"
    },
    {
        "line": 190,
        "fullcodeline": "if (ret_type != NULL)"
    },
    {
        "line": 205,
        "fullcodeline": "if (register_closure(fp) == FAIL)"
    },
    {
        "line": 168,
        "fullcodeline": "start = line_end + 1;"
    },
    {
        "line": 169,
        "fullcodeline": "line_end = vim_strchr(start, '\\n');"
    },
    {
        "line": 172,
        "fullcodeline": "((char_u **)(newlines.ga_data))[newlines.ga_len++] ="
    },
    {
        "line": 192,
        "fullcodeline": "fp->uf_ret_type = parse_type(&ret_type,"
    },
    {
        "line": 166,
        "fullcodeline": "if (ga_grow(&newlines, 1) == FAIL)"
    },
    {
        "line": 170,
        "fullcodeline": "if (line_end == NULL)"
    },
    {
        "line": 173,
        "fullcodeline": "vim_strnsave(start, line_end - start);"
    },
    {
        "line": 188,
        "fullcodeline": "vim9script && varargs) == FAIL)"
    },
    {
        "line": 194,
        "fullcodeline": "if (fp->uf_ret_type == NULL)"
    },
    {
        "line": 198,
        "fullcodeline": "fp->uf_ret_type = &t_unknown;"
    },
    {
        "line": 171,
        "fullcodeline": "line_end = end;"
    }
]