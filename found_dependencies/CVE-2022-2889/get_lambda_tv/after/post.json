[
    {
        "line": 7,
        "fullcodeline": "int\t\tevaluate = evalarg != NULL"
    },
    {
        "line": 14,
        "fullcodeline": "ufunc_T\t*fp = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "partial_T   *pt = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "char_u\t*ret_type = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\t*old_eval_lavars = eval_lavars_used;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\teval_lavars = FALSE;"
    },
    {
        "line": 23,
        "fullcodeline": "char_u\t*tofree2 = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "int\t\tequal_arrow = **arg == '(';"
    },
    {
        "line": 25,
        "fullcodeline": "int\t\twhite_error = FALSE;"
    },
    {
        "line": 26,
        "fullcodeline": "int\t\tcalled_emsg_start = called_emsg;"
    },
    {
        "line": 27,
        "fullcodeline": "int\t\tvim9script = in_vim9script();"
    },
    {
        "line": 28,
        "fullcodeline": "long\tstart_lnum = SOURCING_LNUM;"
    },
    {
        "line": 33,
        "fullcodeline": "ga_init(&newargs);"
    },
    {
        "line": 34,
        "fullcodeline": "ga_init(&newlines);"
    },
    {
        "line": 38,
        "fullcodeline": "s = *arg + 1;"
    },
    {
        "line": 39,
        "fullcodeline": "ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,"
    },
    {
        "line": 54,
        "fullcodeline": "*arg += 1;"
    },
    {
        "line": 55,
        "fullcodeline": "ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,"
    },
    {
        "line": 68,
        "fullcodeline": "*arg = s;"
    },
    {
        "line": 81,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 103,
        "fullcodeline": "start = *arg;"
    },
    {
        "line": 104,
        "fullcodeline": "ret = skip_expr_concatenate(arg, &start, &end, evalarg);"
    },
    {
        "line": 228,
        "fullcodeline": "eval_lavars_used = old_eval_lavars;"
    },
    {
        "line": 229,
        "fullcodeline": "vim_free(tofree2);"
    },
    {
        "line": 236,
        "fullcodeline": "ga_clear_strings(&newargs);"
    },
    {
        "line": 237,
        "fullcodeline": "ga_clear_strings(&newlines);"
    },
    {
        "line": 238,
        "fullcodeline": "ga_clear_strings(&default_args);"
    },
    {
        "line": 245,
        "fullcodeline": "vim_free(fp);"
    },
    {
        "line": 246,
        "fullcodeline": "vim_free(pt);"
    },
    {
        "line": 247,
        "fullcodeline": "vim_free(tofree2);"
    },
    {
        "line": 248,
        "fullcodeline": "eval_lavars_used = old_eval_lavars;"
    },
    {
        "line": 30,
        "fullcodeline": "if (equal_arrow && !vim9script)"
    },
    {
        "line": 42,
        "fullcodeline": "if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)"
    },
    {
        "line": 59,
        "fullcodeline": "if (ret == FAIL"
    },
    {
        "line": 71,
        "fullcodeline": "if (ret_type != NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "if (equal_arrow && **arg == '{')"
    },
    {
        "line": 96,
        "fullcodeline": "if (default_args.ga_len > 0)"
    },
    {
        "line": 105,
        "fullcodeline": "if (ret == FAIL)"
    },
    {
        "line": 108,
        "fullcodeline": "if (!equal_arrow)"
    },
    {
        "line": 8,
        "fullcodeline": "&& (evalarg->eval_flags & EVAL_EVALUATE);"
    },
    {
        "line": 40,
        "fullcodeline": "types_optional ? &argtypes : NULL, types_optional, evalarg,"
    },
    {
        "line": 51,
        "fullcodeline": "pnewargs = &newargs;"
    },
    {
        "line": 56,
        "fullcodeline": "types_optional ? &argtypes : NULL, types_optional, evalarg,"
    },
    {
        "line": 60,
        "fullcodeline": "|| (s = skip_arrow(*arg, equal_arrow, &ret_type,"
    },
    {
        "line": 65,
        "fullcodeline": "ga_clear_strings(&newargs);"
    },
    {
        "line": 73,
        "fullcodeline": "ret_type = vim_strsave(ret_type);"
    },
    {
        "line": 74,
        "fullcodeline": "tofree2 = ret_type;"
    },
    {
        "line": 79,
        "fullcodeline": "eval_lavars_used = &eval_lavars;"
    },
    {
        "line": 89,
        "fullcodeline": "SOURCING_LNUM = start_lnum;  // used for where lambda is defined"
    },
    {
        "line": 98,
        "fullcodeline": "emsg(_(e_cannot_use_default_values_in_lambda));"
    },
    {
        "line": 110,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 116,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 122,
        "fullcodeline": "int\t    flags = FC_LAMBDA;"
    },
    {
        "line": 125,
        "fullcodeline": "char_u\t    *name = get_lambda_name();"
    },
    {
        "line": 127,
        "fullcodeline": "fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);"
    },
    {
        "line": 130,
        "fullcodeline": "fp->uf_def_status = UF_NOT_COMPILED;"
    },
    {
        "line": 131,
        "fullcodeline": "pt = ALLOC_CLEAR_ONE(partial_T);"
    },
    {
        "line": 135,
        "fullcodeline": "ga_init2(&newlines, sizeof(char_u *), 1);"
    },
    {
        "line": 140,
        "fullcodeline": "line_end = vim_strchr(start, '\\n');"
    },
    {
        "line": 145,
        "fullcodeline": "len = 7 + (int)(line_end - start) + 1;"
    },
    {
        "line": 146,
        "fullcodeline": "p = alloc(len);"
    },
    {
        "line": 149,
        "fullcodeline": "((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;"
    },
    {
        "line": 150,
        "fullcodeline": "STRCPY(p, \"return \");"
    },
    {
        "line": 151,
        "fullcodeline": "vim_strncpy(p + 7, start, line_end - start);"
    },
    {
        "line": 174,
        "fullcodeline": "fp->uf_refcount = 1;"
    },
    {
        "line": 175,
        "fullcodeline": "set_ufunc_name(fp, name);"
    },
    {
        "line": 176,
        "fullcodeline": "fp->uf_args = newargs;"
    },
    {
        "line": 177,
        "fullcodeline": "ga_init(&fp->uf_def_args);"
    },
    {
        "line": 194,
        "fullcodeline": "fp->uf_lines = newlines;"
    },
    {
        "line": 210,
        "fullcodeline": "fp->uf_varargs = !vim9script || varargs;"
    },
    {
        "line": 211,
        "fullcodeline": "fp->uf_flags = flags;"
    },
    {
        "line": 212,
        "fullcodeline": "fp->uf_calls = 0;"
    },
    {
        "line": 213,
        "fullcodeline": "fp->uf_script_ctx = current_sctx;"
    },
    {
        "line": 215,
        "fullcodeline": "fp->uf_script_ctx.sc_lnum += start_lnum;"
    },
    {
        "line": 217,
        "fullcodeline": "function_using_block_scopes(fp, evalarg->eval_cstack);"
    },
    {
        "line": 219,
        "fullcodeline": "pt->pt_func = fp;"
    },
    {
        "line": 220,
        "fullcodeline": "pt->pt_refcount = 1;"
    },
    {
        "line": 221,
        "fullcodeline": "rettv->vval.v_partial = pt;"
    },
    {
        "line": 222,
        "fullcodeline": "rettv->v_type = VAR_PARTIAL;"
    },
    {
        "line": 224,
        "fullcodeline": "hash_add(&func_hashtab, UF2HIKEY(fp));"
    },
    {
        "line": 231,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 241,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 46,
        "fullcodeline": "return called_emsg == called_emsg_start ? NOTDONE : FAIL;"
    },
    {
        "line": 53,
        "fullcodeline": "pnewargs = NULL;"
    },
    {
        "line": 66,
        "fullcodeline": "return white_error ? FAIL : NOTDONE;"
    },
    {
        "line": 86,
        "fullcodeline": "if (evalarg == NULL)"
    },
    {
        "line": 90,
        "fullcodeline": "if (lambda_function_body(arg, rettv, evalarg, pnewargs,"
    },
    {
        "line": 111,
        "fullcodeline": "if (**arg != '}')"
    },
    {
        "line": 128,
        "fullcodeline": "if (fp == NULL)"
    },
    {
        "line": 132,
        "fullcodeline": "if (pt == NULL)"
    },
    {
        "line": 136,
        "fullcodeline": "if (ga_grow(&newlines, 1) == FAIL)"
    },
    {
        "line": 141,
        "fullcodeline": "if (line_end == NULL || line_end > end)"
    },
    {
        "line": 147,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 153,
        "fullcodeline": "if (line_end != end)"
    },
    {
        "line": 170,
        "fullcodeline": "if (strstr((char *)p + 7, \"a:\") == NULL)"
    },
    {
        "line": 195,
        "fullcodeline": "if (current_funccal != NULL && eval_lavars)"
    },
    {
        "line": 242,
        "fullcodeline": "if (fp != NULL)"
    },
    {
        "line": 45,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 64,
        "fullcodeline": "ga_clear_strings(&argtypes);"
    },
    {
        "line": 113,
        "fullcodeline": "semsg(_(e_expected_right_curly_str), *arg);"
    },
    {
        "line": 142,
        "fullcodeline": "line_end = end;"
    },
    {
        "line": 172,
        "fullcodeline": "flags |= FC_NOARGS;"
    },
    {
        "line": 197,
        "fullcodeline": "flags |= FC_CLOSURE;"
    },
    {
        "line": 207,
        "fullcodeline": "flags |= FC_SANDBOX;"
    },
    {
        "line": 243,
        "fullcodeline": "vim_free(fp->uf_arg_types);"
    },
    {
        "line": 61,
        "fullcodeline": "equal_arrow || vim9script ? &white_error : NULL)) == NULL)"
    },
    {
        "line": 91,
        "fullcodeline": "types_optional ? &argtypes : NULL, varargs,"
    },
    {
        "line": 157,
        "fullcodeline": "while (*line_end == '\\n')"
    },
    {
        "line": 180,
        "fullcodeline": "if (parse_argument_types(fp, &argtypes,"
    },
    {
        "line": 183,
        "fullcodeline": "if (ret_type != NULL)"
    },
    {
        "line": 198,
        "fullcodeline": "if (register_closure(fp) == FAIL)"
    },
    {
        "line": 161,
        "fullcodeline": "start = line_end + 1;"
    },
    {
        "line": 162,
        "fullcodeline": "line_end = vim_strchr(start, '\\n');"
    },
    {
        "line": 165,
        "fullcodeline": "((char_u **)(newlines.ga_data))[newlines.ga_len++] ="
    },
    {
        "line": 185,
        "fullcodeline": "fp->uf_ret_type = parse_type(&ret_type,"
    },
    {
        "line": 159,
        "fullcodeline": "if (ga_grow(&newlines, 1) == FAIL)"
    },
    {
        "line": 163,
        "fullcodeline": "if (line_end == NULL)"
    },
    {
        "line": 166,
        "fullcodeline": "vim_strnsave(start, line_end - start);"
    },
    {
        "line": 181,
        "fullcodeline": "vim9script && varargs) == FAIL)"
    },
    {
        "line": 187,
        "fullcodeline": "if (fp->uf_ret_type == NULL)"
    },
    {
        "line": 191,
        "fullcodeline": "fp->uf_ret_type = &t_unknown;"
    },
    {
        "line": 164,
        "fullcodeline": "line_end = end;"
    }
]