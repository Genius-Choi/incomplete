[
    {
        "line": 3,
        "fullcodeline": "garray_T\t*gap = &evalarg->eval_ga;"
    },
    {
        "line": 24,
        "fullcodeline": "++evalarg->eval_break_count;"
    },
    {
        "line": 48,
        "fullcodeline": "evalarg->eval_using_cmdline = FALSE;"
    },
    {
        "line": 6,
        "fullcodeline": "if (arg != NULL)"
    },
    {
        "line": 16,
        "fullcodeline": "if (evalarg->eval_cookie != NULL)"
    },
    {
        "line": 21,
        "fullcodeline": "if (line == NULL)"
    },
    {
        "line": 49,
        "fullcodeline": "return skipwhite(line);"
    },
    {
        "line": 17,
        "fullcodeline": "line = evalarg->eval_getline(0, evalarg->eval_cookie, 0,"
    },
    {
        "line": 25,
        "fullcodeline": "if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)"
    },
    {
        "line": 27,
        "fullcodeline": "char_u *p = skipwhite(line);"
    },
    {
        "line": 8,
        "fullcodeline": "if (*arg == NL)"
    },
    {
        "line": 20,
        "fullcodeline": "line = next_line_from_context(evalarg->eval_cctx, TRUE);"
    },
    {
        "line": 31,
        "fullcodeline": "if (*p == NUL || vim9_comment_start(p))"
    },
    {
        "line": 34,
        "fullcodeline": "line = vim_strsave((char_u *)\"\");"
    },
    {
        "line": 40,
        "fullcodeline": "else if (evalarg->eval_cookie != NULL)"
    },
    {
        "line": 9,
        "fullcodeline": "return newline_skip_comments(arg);"
    }
]