[
    {
        "line": 9,
        "fullcodeline": "int\t\tvim9script = in_vim9script();"
    },
    {
        "line": 10,
        "fullcodeline": "garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;"
    },
    {
        "line": 11,
        "fullcodeline": "garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\tevaluate = evalarg == NULL"
    },
    {
        "line": 30,
        "fullcodeline": "*arg = skipwhite(*arg);"
    },
    {
        "line": 31,
        "fullcodeline": "res = eval1(arg, &rettv, evalarg);"
    },
    {
        "line": 32,
        "fullcodeline": "*end = *arg;"
    },
    {
        "line": 16,
        "fullcodeline": "if (vim9script && evaluate"
    },
    {
        "line": 28,
        "fullcodeline": "if (evalarg != NULL)"
    },
    {
        "line": 33,
        "fullcodeline": "if (evalarg != NULL)"
    },
    {
        "line": 36,
        "fullcodeline": "if (vim9script && evaluate"
    },
    {
        "line": 14,
        "fullcodeline": "? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);"
    },
    {
        "line": 17,
        "fullcodeline": "&& (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))"
    },
    {
        "line": 19,
        "fullcodeline": "ga_init2(gap, sizeof(char_u *), 10);"
    },
    {
        "line": 23,
        "fullcodeline": "ga_init2(freegap, sizeof(char_u *), 10);"
    },
    {
        "line": 29,
        "fullcodeline": "evalarg->eval_flags &= ~EVAL_EVALUATE;"
    },
    {
        "line": 34,
        "fullcodeline": "evalarg->eval_flags = save_flags;"
    },
    {
        "line": 37,
        "fullcodeline": "&& (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))"
    },
    {
        "line": 21,
        "fullcodeline": "if (ga_grow(gap, 1) == OK)"
    },
    {
        "line": 39,
        "fullcodeline": "if (evalarg->eval_ga.ga_len == 1)"
    },
    {
        "line": 22,
        "fullcodeline": "++gap->ga_len;"
    },
    {
        "line": 42,
        "fullcodeline": "ga_clear(gap);"
    },
    {
        "line": 43,
        "fullcodeline": "gap->ga_itemsize = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "size_t\t    endoff = STRLEN(*arg);"
    },
    {
        "line": 51,
        "fullcodeline": "*((char_u **)gap->ga_data) = *start;"
    },
    {
        "line": 52,
        "fullcodeline": "p = ga_concat_strings(gap, \" \");"
    },
    {
        "line": 75,
        "fullcodeline": "gap->ga_itemsize = 0;"
    },
    {
        "line": 78,
        "fullcodeline": "*start = p;"
    },
    {
        "line": 79,
        "fullcodeline": "vim_free(evalarg->eval_tofree_lambda);"
    },
    {
        "line": 80,
        "fullcodeline": "evalarg->eval_tofree_lambda = p;"
    },
    {
        "line": 82,
        "fullcodeline": "*end = *start + STRLEN(*start) - endoff;"
    },
    {
        "line": 55,
        "fullcodeline": "if (evalarg->eval_cookie != NULL)"
    },
    {
        "line": 76,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 58,
        "fullcodeline": "*((char_u **)gap->ga_data) = NULL;"
    },
    {
        "line": 61,
        "fullcodeline": "vim_free(evalarg->eval_tofree);"
    },
    {
        "line": 64,
        "fullcodeline": "((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;"
    },
    {
        "line": 65,
        "fullcodeline": "ga_clear_strings(gap);"
    },
    {
        "line": 69,
        "fullcodeline": "ga_clear(gap);"
    },
    {
        "line": 72,
        "fullcodeline": "ga_clear_strings(freegap);"
    },
    {
        "line": 63,
        "fullcodeline": "((char_u **)gap->ga_data)[gap->ga_len - 1];"
    }
]