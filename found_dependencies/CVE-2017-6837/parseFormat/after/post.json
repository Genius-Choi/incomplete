[
    {
        "line": 3,
        "fullcodeline": "Track *track = getTrack();"
    },
    {
        "line": 6,
        "fullcodeline": "readU16(&formatTag);"
    },
    {
        "line": 8,
        "fullcodeline": "readU16(&channelCount);"
    },
    {
        "line": 10,
        "fullcodeline": "readU32(&sampleRate);"
    },
    {
        "line": 12,
        "fullcodeline": "readU32(&averageBytesPerSecond);"
    },
    {
        "line": 14,
        "fullcodeline": "readU16(&blockAlign);"
    },
    {
        "line": 22,
        "fullcodeline": "track->f.channelCount = channelCount;"
    },
    {
        "line": 23,
        "fullcodeline": "track->f.sampleRate = sampleRate;"
    },
    {
        "line": 24,
        "fullcodeline": "track->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;"
    },
    {
        "line": 27,
        "fullcodeline": "track->f.compressionType = AF_COMPRESSION_NONE;"
    },
    {
        "line": 28,
        "fullcodeline": "track->f.framesPerPacket = 1;"
    },
    {
        "line": 274,
        "fullcodeline": "_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);"
    },
    {
        "line": 16,
        "fullcodeline": "if (!channelCount)"
    },
    {
        "line": 271,
        "fullcodeline": "if (track->f.isUncompressed())"
    },
    {
        "line": 18,
        "fullcodeline": "_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");"
    },
    {
        "line": 56,
        "fullcodeline": "track->f.sampleWidth = 16;"
    },
    {
        "line": 57,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 58,
        "fullcodeline": "track->f.byteOrder = _AF_BYTEORDER_NATIVE;"
    },
    {
        "line": 59,
        "fullcodeline": "track->f.compressionType = AF_COMPRESSION_G711_ULAW;"
    },
    {
        "line": 60,
        "fullcodeline": "track->f.bytesPerPacket = track->f.channelCount;"
    },
    {
        "line": 65,
        "fullcodeline": "track->f.sampleWidth = 16;"
    },
    {
        "line": 66,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 67,
        "fullcodeline": "track->f.byteOrder = _AF_BYTEORDER_NATIVE;"
    },
    {
        "line": 68,
        "fullcodeline": "track->f.compressionType = AF_COMPRESSION_G711_ALAW;"
    },
    {
        "line": 69,
        "fullcodeline": "track->f.bytesPerPacket = track->f.channelCount;"
    },
    {
        "line": 251,
        "fullcodeline": "_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);"
    },
    {
        "line": 256,
        "fullcodeline": "_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");"
    },
    {
        "line": 261,
        "fullcodeline": "_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");"
    },
    {
        "line": 266,
        "fullcodeline": "_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);"
    },
    {
        "line": 272,
        "fullcodeline": "track->f.computeBytesPerPacketPCM();"
    },
    {
        "line": 35,
        "fullcodeline": "readU16(&bitsPerSample);"
    },
    {
        "line": 37,
        "fullcodeline": "track->f.sampleWidth = bitsPerSample;"
    },
    {
        "line": 75,
        "fullcodeline": "readU16(&bitsPerSample);"
    },
    {
        "line": 103,
        "fullcodeline": "readU16(&bitsPerSample);"
    },
    {
        "line": 104,
        "fullcodeline": "readU16(&extraByteCount);"
    },
    {
        "line": 105,
        "fullcodeline": "readU16(&samplesPerBlock);"
    },
    {
        "line": 106,
        "fullcodeline": "readU16(&numCoefficients);"
    },
    {
        "line": 109,
        "fullcodeline": "assert(numCoefficients >= 7 && numCoefficients <= 255);"
    },
    {
        "line": 117,
        "fullcodeline": "m_msadpcmNumCoefficients = numCoefficients;"
    },
    {
        "line": 125,
        "fullcodeline": "track->f.sampleWidth = 16;"
    },
    {
        "line": 126,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 127,
        "fullcodeline": "track->f.compressionType = AF_COMPRESSION_MS_ADPCM;"
    },
    {
        "line": 128,
        "fullcodeline": "track->f.byteOrder = _AF_BYTEORDER_NATIVE;"
    },
    {
        "line": 130,
        "fullcodeline": "track->f.framesPerPacket = samplesPerBlock;"
    },
    {
        "line": 131,
        "fullcodeline": "track->f.bytesPerPacket = blockAlign;"
    },
    {
        "line": 134,
        "fullcodeline": "AUpvlist pv = AUpvnew(2);"
    },
    {
        "line": 135,
        "fullcodeline": "AUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);"
    },
    {
        "line": 136,
        "fullcodeline": "AUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);"
    },
    {
        "line": 137,
        "fullcodeline": "long l = m_msadpcmNumCoefficients;"
    },
    {
        "line": 138,
        "fullcodeline": "AUpvsetval(pv, 0, &l);"
    },
    {
        "line": 140,
        "fullcodeline": "AUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);"
    },
    {
        "line": 141,
        "fullcodeline": "AUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);"
    },
    {
        "line": 142,
        "fullcodeline": "void *v = m_msadpcmCoefficients;"
    },
    {
        "line": 143,
        "fullcodeline": "AUpvsetval(pv, 1, &v);"
    },
    {
        "line": 145,
        "fullcodeline": "track->f.compressionParams = pv;"
    },
    {
        "line": 153,
        "fullcodeline": "readU16(&bitsPerSample);"
    },
    {
        "line": 154,
        "fullcodeline": "readU16(&extraByteCount);"
    },
    {
        "line": 155,
        "fullcodeline": "readU16(&samplesPerBlock);"
    },
    {
        "line": 163,
        "fullcodeline": "int bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;"
    },
    {
        "line": 170,
        "fullcodeline": "track->f.sampleWidth = 16;"
    },
    {
        "line": 171,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 172,
        "fullcodeline": "track->f.compressionType = AF_COMPRESSION_IMA;"
    },
    {
        "line": 173,
        "fullcodeline": "track->f.byteOrder = _AF_BYTEORDER_NATIVE;"
    },
    {
        "line": 175,
        "fullcodeline": "initIMACompressionParams();"
    },
    {
        "line": 177,
        "fullcodeline": "track->f.framesPerPacket = samplesPerBlock;"
    },
    {
        "line": 178,
        "fullcodeline": "track->f.bytesPerPacket = blockAlign;"
    },
    {
        "line": 185,
        "fullcodeline": "readU16(&bitsPerSample);"
    },
    {
        "line": 187,
        "fullcodeline": "readU16(&extraByteCount);"
    },
    {
        "line": 189,
        "fullcodeline": "readU16(&reserved);"
    },
    {
        "line": 191,
        "fullcodeline": "readU32(&channelMask);"
    },
    {
        "line": 193,
        "fullcodeline": "readUUID(&subformat);"
    },
    {
        "line": 39,
        "fullcodeline": "if (bitsPerSample == 0 || bitsPerSample > 32)"
    },
    {
        "line": 47,
        "fullcodeline": "if (bitsPerSample <= 8)"
    },
    {
        "line": 77,
        "fullcodeline": "if (bitsPerSample == 64)"
    },
    {
        "line": 95,
        "fullcodeline": "if (track->f.channelCount != 1 &&"
    },
    {
        "line": 110,
        "fullcodeline": "if (numCoefficients < 7 || numCoefficients > 255)"
    },
    {
        "line": 119,
        "fullcodeline": "for (int i=0; i<m_msadpcmNumCoefficients; i++)"
    },
    {
        "line": 157,
        "fullcodeline": "if (bitsPerSample != 4)"
    },
    {
        "line": 164,
        "fullcodeline": "if (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)"
    },
    {
        "line": 194,
        "fullcodeline": "if (subformat == _af_wave_guid_pcm)"
    },
    {
        "line": 41,
        "fullcodeline": "_af_error(AF_BAD_WIDTH,"
    },
    {
        "line": 48,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_UNSIGNED;"
    },
    {
        "line": 79,
        "fullcodeline": "track->f.sampleWidth = 64;"
    },
    {
        "line": 80,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_DOUBLE;"
    },
    {
        "line": 96,
        "fullcodeline": "track->f.channelCount != 2)"
    },
    {
        "line": 98,
        "fullcodeline": "_af_error(AF_BAD_CHANNELS,"
    },
    {
        "line": 112,
        "fullcodeline": "_af_error(AF_BAD_HEADER,"
    },
    {
        "line": 159,
        "fullcodeline": "_af_error(AF_BAD_NOT_IMPLEMENTED,"
    },
    {
        "line": 166,
        "fullcodeline": "_af_error(AF_BAD_CODEC_CONFIG,"
    },
    {
        "line": 196,
        "fullcodeline": "track->f.sampleWidth = bitsPerSample;"
    },
    {
        "line": 50,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 84,
        "fullcodeline": "track->f.sampleWidth = 32;"
    },
    {
        "line": 85,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_FLOAT;"
    },
    {
        "line": 198,
        "fullcodeline": "if (bitsPerSample == 0 || bitsPerSample > 32)"
    },
    {
        "line": 207,
        "fullcodeline": "if (reserved <= bitsPerSample &&"
    },
    {
        "line": 211,
        "fullcodeline": "if (bitsPerSample <= 8)"
    },
    {
        "line": 200,
        "fullcodeline": "_af_error(AF_BAD_WIDTH,"
    },
    {
        "line": 208,
        "fullcodeline": "(reserved + 7) / 8 == (bitsPerSample + 7) / 8)"
    },
    {
        "line": 209,
        "fullcodeline": "track->f.sampleWidth = reserved;"
    },
    {
        "line": 212,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_UNSIGNED;"
    },
    {
        "line": 216,
        "fullcodeline": "else if (subformat == _af_wave_guid_ieee_float)"
    },
    {
        "line": 214,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 218,
        "fullcodeline": "if (bitsPerSample == 64)"
    },
    {
        "line": 220,
        "fullcodeline": "track->f.sampleWidth = 64;"
    },
    {
        "line": 221,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_DOUBLE;"
    },
    {
        "line": 229,
        "fullcodeline": "else if (subformat == _af_wave_guid_alaw ||"
    },
    {
        "line": 225,
        "fullcodeline": "track->f.sampleWidth = 32;"
    },
    {
        "line": 226,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_FLOAT;"
    },
    {
        "line": 230,
        "fullcodeline": "subformat == _af_wave_guid_ulaw)"
    },
    {
        "line": 232,
        "fullcodeline": "track->f.compressionType = subformat == _af_wave_guid_alaw ?"
    },
    {
        "line": 234,
        "fullcodeline": "track->f.sampleWidth = 16;"
    },
    {
        "line": 235,
        "fullcodeline": "track->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;"
    },
    {
        "line": 236,
        "fullcodeline": "track->f.byteOrder = _AF_BYTEORDER_NATIVE;"
    },
    {
        "line": 237,
        "fullcodeline": "track->f.bytesPerPacket = channelCount;"
    },
    {
        "line": 241,
        "fullcodeline": "_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());"
    }
]