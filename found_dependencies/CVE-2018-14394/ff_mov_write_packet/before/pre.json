[
    {
        "line": 3,
        "fullcodeline": "MOVMuxContext *mov = s->priv_data;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *pb = s->pb;"
    },
    {
        "line": 5,
        "fullcodeline": "MOVTrack *trk = &mov->tracks[pkt->stream_index];"
    },
    {
        "line": 6,
        "fullcodeline": "AVCodecParameters *par = trk->par;"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned int samples_in_chunk = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int size = pkt->size, ret = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "uint8_t *reformatted_data = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "ret = check_pkt(s, pkt);"
    },
    {
        "line": 164,
        "fullcodeline": "trk->cluster[trk->entry].dts              = pkt->dts;"
    },
    {
        "line": 223,
        "fullcodeline": "trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;"
    },
    {
        "line": 224,
        "fullcodeline": "trk->last_sample_is_subtitle_end = 0;"
    },
    {
        "line": 232,
        "fullcodeline": "trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;"
    },
    {
        "line": 233,
        "fullcodeline": "trk->cluster[trk->entry].flags = 0;"
    },
    {
        "line": 262,
        "fullcodeline": "trk->entry++;"
    },
    {
        "line": 12,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 15,
        "fullcodeline": "if (mov->flags & FF_MOV_FLAG_FRAGMENT) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (par->codec_id == AV_CODEC_ID_AMR_NB) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (trk->entry >= trk->cluster_capacity) {"
    },
    {
        "line": 159,
        "fullcodeline": "trk->cluster[trk->entry].pos              = avio_tell(pb) - size;"
    },
    {
        "line": 200,
        "fullcodeline": "if (trk->start_dts == AV_NOPTS_VALUE) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (pkt->pts == AV_NOPTS_VALUE) {"
    },
    {
        "line": 230,
        "fullcodeline": "if (pkt->dts != pkt->pts)"
    },
    {
        "line": 234,
        "fullcodeline": "if (trk->start_cts == AV_NOPTS_VALUE)"
    },
    {
        "line": 236,
        "fullcodeline": "if (trk->end_pts == AV_NOPTS_VALUE)"
    },
    {
        "line": 244,
        "fullcodeline": "if (par->codec_id == AV_CODEC_ID_VC1) {"
    },
    {
        "line": 258,
        "fullcodeline": "if (pkt->flags & AV_PKT_FLAG_DISPOSABLE) {"
    },
    {
        "line": 41,
        "fullcodeline": "static const uint16_t packed_size[16] ="
    },
    {
        "line": 43,
        "fullcodeline": "int len = 0;"
    },
    {
        "line": 62,
        "fullcodeline": "if (trk->vos_len == 0 && par->extradata_size > 0 &&"
    },
    {
        "line": 64,
        "fullcodeline": "(par->codec_id != AV_CODEC_ID_DNXHD)) {"
    },
    {
        "line": 65,
        "fullcodeline": "trk->vos_len  = par->extradata_size;"
    },
    {
        "line": 66,
        "fullcodeline": "trk->vos_data = av_malloc(trk->vos_len);"
    },
    {
        "line": 71,
        "fullcodeline": "memcpy(trk->vos_data, par->extradata, trk->vos_len);"
    },
    {
        "line": 74,
        "fullcodeline": "if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&"
    },
    {
        "line": 75,
        "fullcodeline": "(AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {"
    },
    {
        "line": 82,
        "fullcodeline": "av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");"
    },
    {
        "line": 84,
        "fullcodeline": "if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {"
    },
    {
        "line": 137,
        "fullcodeline": "if ((par->codec_id == AV_CODEC_ID_DNXHD ||"
    },
    {
        "line": 138,
        "fullcodeline": "par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {"
    },
    {
        "line": 140,
        "fullcodeline": "trk->vos_len  = size;"
    },
    {
        "line": 141,
        "fullcodeline": "trk->vos_data = av_malloc(size);"
    },
    {
        "line": 146,
        "fullcodeline": "memcpy(trk->vos_data, pkt->data, size);"
    },
    {
        "line": 150,
        "fullcodeline": "unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);"
    },
    {
        "line": 156,
        "fullcodeline": "trk->cluster_capacity = new_capacity;"
    },
    {
        "line": 166,
        "fullcodeline": "if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {"
    },
    {
        "line": 191,
        "fullcodeline": "if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&"
    },
    {
        "line": 192,
        "fullcodeline": "s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {"
    },
    {
        "line": 198,
        "fullcodeline": "trk->cluster[trk->entry].dts = trk->start_dts = 0;"
    },
    {
        "line": 201,
        "fullcodeline": "trk->start_dts = pkt->dts;"
    },
    {
        "line": 227,
        "fullcodeline": "av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");"
    },
    {
        "line": 228,
        "fullcodeline": "pkt->pts = pkt->dts;"
    },
    {
        "line": 231,
        "fullcodeline": "trk->flags |= MOV_TRACK_CTTS;"
    },
    {
        "line": 235,
        "fullcodeline": "trk->start_cts = pkt->pts - pkt->dts;"
    },
    {
        "line": 237,
        "fullcodeline": "trk->end_pts = trk->cluster[trk->entry].dts +"
    },
    {
        "line": 245,
        "fullcodeline": "mov_parse_vc1_frame(pkt, trk);"
    },
    {
        "line": 259,
        "fullcodeline": "trk->cluster[trk->entry].flags |= MOV_DISPOSABLE_SAMPLE;"
    },
    {
        "line": 266,
        "fullcodeline": "if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)"
    },
    {
        "line": 267,
        "fullcodeline": "ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,"
    },
    {
        "line": 42,
        "fullcodeline": "{13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};"
    },
    {
        "line": 49,
        "fullcodeline": "if (samples_in_chunk > 1) {"
    },
    {
        "line": 63,
        "fullcodeline": "!TAG_IS_AVCI(trk->tag) &&"
    },
    {
        "line": 67,
        "fullcodeline": "if (!trk->vos_data) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (!trk->vos_data) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (av_reallocp_array(&trk->cluster, new_capacity,"
    },
    {
        "line": 167,
        "fullcodeline": "if (!trk->frag_discont) {"
    },
    {
        "line": 240,
        "fullcodeline": "trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +"
    },
    {
        "line": 17,
        "fullcodeline": "if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {"
    },
    {
        "line": 29,
        "fullcodeline": "pb = trk->mdat_buf;"
    },
    {
        "line": 45,
        "fullcodeline": "while (len < size && samples_in_chunk < 100) {"
    },
    {
        "line": 46,
        "fullcodeline": "len += packed_size[(pkt->data[len] >> 3) & 0x0F];"
    },
    {
        "line": 47,
        "fullcodeline": "samples_in_chunk++;"
    },
    {
        "line": 68,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    },
    {
        "line": 88,
        "fullcodeline": "ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,"
    },
    {
        "line": 90,
        "fullcodeline": "avio_write(pb, reformatted_data, size);"
    },
    {
        "line": 143,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    },
    {
        "line": 153,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    },
    {
        "line": 172,
        "fullcodeline": "trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;"
    },
    {
        "line": 246,
        "fullcodeline": "} else if (pkt->flags & AV_PKT_FLAG_KEY) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (mov->frag_interleave && mov->fragments > 0) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (!trk->mdat_buf) {"
    },
    {
        "line": 35,
        "fullcodeline": "pb = mov->mdat_buf;"
    },
    {
        "line": 51,
        "fullcodeline": "return -1;"
    },
    {
        "line": 53,
        "fullcodeline": "} else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||"
    },
    {
        "line": 54,
        "fullcodeline": "par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {"
    },
    {
        "line": 55,
        "fullcodeline": "samples_in_chunk = trk->par->frame_size;"
    },
    {
        "line": 80,
        "fullcodeline": "return -1;"
    },
    {
        "line": 102,
        "fullcodeline": "} else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&"
    },
    {
        "line": 103,
        "fullcodeline": "(AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {"
    },
    {
        "line": 185,
        "fullcodeline": "trk->frag_start = pkt->dts - trk->start_dts;"
    },
    {
        "line": 186,
        "fullcodeline": "trk->end_pts = AV_NOPTS_VALUE;"
    },
    {
        "line": 187,
        "fullcodeline": "trk->frag_discont = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "if (!mov->mdat_buf) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {"
    },
    {
        "line": 178,
        "fullcodeline": "if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||"
    },
    {
        "line": 179,
        "fullcodeline": "mov->mode == MODE_ISM)"
    },
    {
        "line": 180,
        "fullcodeline": "pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;"
    },
    {
        "line": 255,
        "fullcodeline": "if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)"
    },
    {
        "line": 93,
        "fullcodeline": "size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);"
    },
    {
        "line": 106,
        "fullcodeline": "ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);"
    },
    {
        "line": 107,
        "fullcodeline": "avio_write(pb, reformatted_data, size);"
    },
    {
        "line": 247,
        "fullcodeline": "if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&"
    },
    {
        "line": 248,
        "fullcodeline": "trk->entry > 0) { // force sync sample for the first key frame"
    },
    {
        "line": 249,
        "fullcodeline": "mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);"
    },
    {
        "line": 19,
        "fullcodeline": "if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {"
    },
    {
        "line": 26,
        "fullcodeline": "if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)"
    },
    {
        "line": 57,
        "fullcodeline": "samples_in_chunk = size / trk->sample_size;"
    },
    {
        "line": 94,
        "fullcodeline": "if (size < 0) {"
    },
    {
        "line": 99,
        "fullcodeline": "size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);"
    },
    {
        "line": 109,
        "fullcodeline": "size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);"
    },
    {
        "line": 250,
        "fullcodeline": "if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)"
    },
    {
        "line": 253,
        "fullcodeline": "trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;"
    },
    {
        "line": 32,
        "fullcodeline": "if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)"
    },
    {
        "line": 59,
        "fullcodeline": "samples_in_chunk = 1;"
    },
    {
        "line": 95,
        "fullcodeline": "ret = size;"
    },
    {
        "line": 133,
        "fullcodeline": "avio_write(pb, pkt->data, size);"
    },
    {
        "line": 251,
        "fullcodeline": "trk->flags |= MOV_TRACK_STPS;"
    },
    {
        "line": 20,
        "fullcodeline": "if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)"
    },
    {
        "line": 122,
        "fullcodeline": "if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {"
    },
    {
        "line": 123,
        "fullcodeline": "int nal_size_length = (par->extradata[4] & 0x3) + 1;"
    },
    {
        "line": 124,
        "fullcodeline": "ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);"
    },
    {
        "line": 126,
        "fullcodeline": "ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);"
    }
]