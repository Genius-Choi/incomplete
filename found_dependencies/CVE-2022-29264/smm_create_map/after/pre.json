[
    {
        "line": 6,
        "fullcodeline": "unsigned int ss_size = params->per_cpu_save_state_size, stub_size;"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned int smm_entry_offset = params->smm_main_entry_offset;"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned int seg_count = 0, segments = 0, available;"
    },
    {
        "line": 9,
        "fullcodeline": "unsigned int cpus_in_segment = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "unsigned int base = smbase;"
    },
    {
        "line": 17,
        "fullcodeline": "stub_size = rmodule_memory_size(&smm_stub);"
    },
    {
        "line": 19,
        "fullcodeline": "available = 0xFFFF - smm_entry_offset - ss_size - stub_size;"
    },
    {
        "line": 12,
        "fullcodeline": "if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (available > 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (sizeof(cpus) / sizeof(struct cpu_smm_info) < num_cpus) {"
    },
    {
        "line": 41,
        "fullcodeline": "for (i = 0; i < num_cpus; i++) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (CONFIG_DEFAULT_CONSOLE_LOGLEVEL >= BIOS_DEBUG) {"
    },
    {
        "line": 13,
        "fullcodeline": "printk(BIOS_ERR, \"%s: unable to get SMM module size\\n\", __func__);"
    },
    {
        "line": 21,
        "fullcodeline": "cpus_in_segment = available / ss_size;"
    },
    {
        "line": 23,
        "fullcodeline": "segments = num_cpus / cpus_in_segment + 1;"
    },
    {
        "line": 24,
        "fullcodeline": "printk(BIOS_DEBUG,"
    },
    {
        "line": 26,
        "fullcodeline": "printk(BIOS_DEBUG,"
    },
    {
        "line": 43,
        "fullcodeline": "cpus[i].entry = base + smm_entry_offset;"
    },
    {
        "line": 48,
        "fullcodeline": "base -= ss_size;"
    },
    {
        "line": 49,
        "fullcodeline": "seg_count++;"
    },
    {
        "line": 57,
        "fullcodeline": "seg_count = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "printk(BIOS_ERR, \"%s: not enough space in SMM to setup all CPUs\\n\", __func__);"
    },
    {
        "line": 30,
        "fullcodeline": "printk(BIOS_ERR, \"    save state & stub size need to be reduced\\n\");"
    },
    {
        "line": 50,
        "fullcodeline": "if (seg_count >= cpus_in_segment) {"
    },
    {
        "line": 58,
        "fullcodeline": "for (i = 0; i < num_cpus; i++) {"
    },
    {
        "line": 44,
        "fullcodeline": "cpus[i].ss_start = cpus[i].entry + (smm_entry_offset - ss_size);"
    },
    {
        "line": 51,
        "fullcodeline": "base -= smm_entry_offset;"
    },
    {
        "line": 52,
        "fullcodeline": "seg_count = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "printk(BIOS_DEBUG, \"CPU 0x%x\\n\", i);"
    },
    {
        "line": 60,
        "fullcodeline": "printk(BIOS_DEBUG,"
    },
    {
        "line": 63,
        "fullcodeline": "printk(BIOS_DEBUG,"
    },
    {
        "line": 66,
        "fullcodeline": "seg_count++;"
    },
    {
        "line": 67,
        "fullcodeline": "if (seg_count >= cpus_in_segment) {"
    },
    {
        "line": 68,
        "fullcodeline": "printk(BIOS_DEBUG,"
    },
    {
        "line": 70,
        "fullcodeline": "seg_count = 0;"
    }
]