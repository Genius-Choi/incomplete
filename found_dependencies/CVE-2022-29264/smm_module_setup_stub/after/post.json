[
    {
        "line": 16,
        "fullcodeline": "base = smbase;"
    },
    {
        "line": 17,
        "fullcodeline": "size = smm_size;"
    },
    {
        "line": 32,
        "fullcodeline": "total_save_state_size = params->per_cpu_save_state_size *"
    },
    {
        "line": 41,
        "fullcodeline": "size -= total_save_state_size;"
    },
    {
        "line": 58,
        "fullcodeline": "smm_stub_loc = NULL;"
    },
    {
        "line": 59,
        "fullcodeline": "smm_stub_size = rmodule_memory_size(&smm_stub);"
    },
    {
        "line": 60,
        "fullcodeline": "stub_entry_offset = rmodule_entry_offset(&smm_stub);"
    },
    {
        "line": 63,
        "fullcodeline": "smm_stub_loc = &base[params->smm_main_entry_offset];"
    },
    {
        "line": 75,
        "fullcodeline": "size = params->num_concurrent_stacks * params->per_cpu_stack_size;"
    },
    {
        "line": 76,
        "fullcodeline": "stacks_top = smm_stub_place_stacks((char *)params->smram_start, size, params);"
    },
    {
        "line": 83,
        "fullcodeline": "params->stack_top = stacks_top;"
    },
    {
        "line": 96,
        "fullcodeline": "stub_params = rmodule_parameters(&smm_stub);"
    },
    {
        "line": 97,
        "fullcodeline": "stub_params->stack_top = (uintptr_t)stacks_top;"
    },
    {
        "line": 98,
        "fullcodeline": "stub_params->stack_size = params->per_cpu_stack_size;"
    },
    {
        "line": 99,
        "fullcodeline": "stub_params->c_handler = (uintptr_t)params->handler;"
    },
    {
        "line": 100,
        "fullcodeline": "stub_params->c_handler_arg = (uintptr_t)params->handler_arg;"
    },
    {
        "line": 101,
        "fullcodeline": "stub_params->fxsave_area = (uintptr_t)fxsave_area;"
    },
    {
        "line": 102,
        "fullcodeline": "stub_params->fxsave_area_size = FXSAVE_SIZE;"
    },
    {
        "line": 103,
        "fullcodeline": "stub_params->runtime.smbase = (uintptr_t)smbase;"
    },
    {
        "line": 104,
        "fullcodeline": "stub_params->runtime.smm_size = smm_size;"
    },
    {
        "line": 105,
        "fullcodeline": "stub_params->runtime.save_state_size = params->per_cpu_save_state_size;"
    },
    {
        "line": 106,
        "fullcodeline": "stub_params->runtime.num_cpus = params->num_concurrent_stacks;"
    },
    {
        "line": 108,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: stack_end = 0x%x\\n\","
    },
    {
        "line": 110,
        "fullcodeline": "printk(BIOS_DEBUG,"
    },
    {
        "line": 112,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: stack_size = 0x%x\\n\","
    },
    {
        "line": 114,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: runtime.smbase = 0x%x\\n\","
    },
    {
        "line": 116,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: runtime.start32_offset = 0x%x\\n\", __func__,"
    },
    {
        "line": 118,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: runtime.smm_size = 0x%zx\\n\","
    },
    {
        "line": 120,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: per_cpu_save_state_size = 0x%x\\n\","
    },
    {
        "line": 122,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: num_cpus = 0x%x\\n\", __func__,"
    },
    {
        "line": 124,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: total_save_state_size = 0x%x\\n\","
    },
    {
        "line": 127,
        "fullcodeline": "total_size_all = stub_params->stack_size +"
    },
    {
        "line": 130,
        "fullcodeline": "printk(BIOS_DEBUG, \"%s: total_size_all = 0x%x\\n\", __func__,"
    },
    {
        "line": 138,
        "fullcodeline": "params->runtime = &stub_params->runtime;"
    },
    {
        "line": 140,
        "fullcodeline": "printk(BIOS_DEBUG, \"SMM Module: stub loaded at %p. Will call %p(%p)\\n\","
    },
    {
        "line": 20,
        "fullcodeline": "if (params->num_concurrent_stacks > CONFIG_MAX_CPUS) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (rmodule_parse(&_binary_smmstub_start, &smm_stub)) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (total_save_state_size > size) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (size <= params->smm_main_entry_offset) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (params->per_cpu_stack_size <= SMM_MINIMUM_STACK_SIZE ||"
    },
    {
        "line": 66,
        "fullcodeline": "if (smm_stub_size > (size - params->smm_main_entry_offset)) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (stacks_top == NULL) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (rmodule_load(smm_stub_loc, &smm_stub)) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (!smm_stub_place_staggered_entry_points(base, params, &smm_stub)) {"
    },
    {
        "line": 125,
        "fullcodeline": "__func__, (stub_params->runtime.save_state_size *"
    },
    {
        "line": 134,
        "fullcodeline": "for (i = 0; i < params->num_concurrent_stacks; i++)"
    },
    {
        "line": 135,
        "fullcodeline": "stub_params->runtime.apic_id_to_cpu[i] = i;"
    },
    {
        "line": 21,
        "fullcodeline": "printk(BIOS_ERR, \"%s: not enough stacks\\n\", __func__);"
    },
    {
        "line": 27,
        "fullcodeline": "printk(BIOS_ERR, \"%s: unable to parse smm stub\\n\", __func__);"
    },
    {
        "line": 35,
        "fullcodeline": "printk(BIOS_ERR,"
    },
    {
        "line": 45,
        "fullcodeline": "printk(BIOS_ERR, \"%s: encroachment over SMM entry point\\n\", __func__);"
    },
    {
        "line": 46,
        "fullcodeline": "printk(BIOS_ERR, \"%s: state save size: %zx : smm_entry_offset -> %x\\n\","
    },
    {
        "line": 53,
        "fullcodeline": "(params->per_cpu_stack_size & 3) != 0) {"
    },
    {
        "line": 54,
        "fullcodeline": "printk(BIOS_ERR, \"%s: need minimum stack size\\n\", __func__);"
    },
    {
        "line": 67,
        "fullcodeline": "printk(BIOS_ERR, \"%s: stub is too big to fit\\n\", __func__);"
    },
    {
        "line": 78,
        "fullcodeline": "printk(BIOS_ERR, \"%s: not enough space for stacks\\n\", __func__);"
    },
    {
        "line": 79,
        "fullcodeline": "printk(BIOS_ERR, \"%s: ....need -> %p : available -> %zx\\n\", __func__,"
    },
    {
        "line": 86,
        "fullcodeline": "printk(BIOS_ERR, \"%s: load module failed\\n\", __func__);"
    },
    {
        "line": 91,
        "fullcodeline": "printk(BIOS_ERR, \"%s: staggered entry points failed\\n\", __func__);"
    },
    {
        "line": 128,
        "fullcodeline": "(stub_params->runtime.save_state_size *"
    },
    {
        "line": 22,
        "fullcodeline": "return -1;"
    },
    {
        "line": 28,
        "fullcodeline": "return -1;"
    },
    {
        "line": 38,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "return -1;"
    },
    {
        "line": 55,
        "fullcodeline": "return -1;"
    },
    {
        "line": 68,
        "fullcodeline": "return -1;"
    },
    {
        "line": 81,
        "fullcodeline": "return -1;"
    },
    {
        "line": 87,
        "fullcodeline": "return -1;"
    },
    {
        "line": 92,
        "fullcodeline": "return -1;"
    }
]