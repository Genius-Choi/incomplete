[
    {
        "line": 4,
        "fullcodeline": "int\t\tgot_tab = FALSE;"
    },
    {
        "line": 5,
        "fullcodeline": "long\tnum_spaces = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "long\tstart_col = 0;\t\t// For start of white-space string"
    },
    {
        "line": 11,
        "fullcodeline": "long\tstart_vcol = 0;\t\t// For start of white-space string"
    },
    {
        "line": 14,
        "fullcodeline": "char_u\t*new_line = (char_u *)1; // init to non-NULL"
    },
    {
        "line": 24,
        "fullcodeline": "linenr_T\tfirst_line = 0;\t\t// first changed line"
    },
    {
        "line": 25,
        "fullcodeline": "linenr_T\tlast_line = 0;\t\t// last changed line"
    },
    {
        "line": 27,
        "fullcodeline": "save_list = curwin->w_p_list;"
    },
    {
        "line": 28,
        "fullcodeline": "curwin->w_p_list = 0;\t    // don't want list mode here"
    },
    {
        "line": 48,
        "fullcodeline": "ptr = eap->arg;"
    },
    {
        "line": 49,
        "fullcodeline": "new_ts = getdigits(&ptr);"
    },
    {
        "line": 50,
        "fullcodeline": "if (new_ts < 0 && *eap->arg == '-')"
    },
    {
        "line": 60,
        "fullcodeline": "if (new_ts == 0)"
    },
    {
        "line": 63,
        "fullcodeline": "for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)"
    },
    {
        "line": 181,
        "fullcodeline": "if (curbuf->b_p_ts != new_ts)"
    },
    {
        "line": 184,
        "fullcodeline": "if (first_line != 0)"
    },
    {
        "line": 52,
        "fullcodeline": "emsg(_(e_argument_must_be_positive));"
    },
    {
        "line": 55,
        "fullcodeline": "if (new_ts < 0 || new_ts > TABSTOP_MAX)"
    },
    {
        "line": 61,
        "fullcodeline": "new_ts = curbuf->b_p_ts;"
    },
    {
        "line": 65,
        "fullcodeline": "ptr = ml_get(lnum);"
    },
    {
        "line": 66,
        "fullcodeline": "col = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "vcol = 0;"
    },
    {
        "line": 68,
        "fullcodeline": "did_undo = FALSE;"
    },
    {
        "line": 182,
        "fullcodeline": "redraw_curbuf_later(NOT_VALID);"
    },
    {
        "line": 57,
        "fullcodeline": "semsg(_(e_invalid_argument_str), eap->arg);"
    },
    {
        "line": 161,
        "fullcodeline": "if (new_line == NULL)\t\t    // out of memory"
    },
    {
        "line": 166,
        "fullcodeline": "emsg(_(e_interrupted));"
    },
    {
        "line": 155,
        "fullcodeline": "vcol += chartabsize(ptr + col, (colnr_T)vcol);"
    },
    {
        "line": 71,
        "fullcodeline": "if (VIM_ISWHITE(ptr[col]))"
    },
    {
        "line": 153,
        "fullcodeline": "if (ptr[col] == NUL)"
    },
    {
        "line": 157,
        "fullcodeline": "col += (*mb_ptr2len)(ptr + col);"
    },
    {
        "line": 79,
        "fullcodeline": "if (ptr[col] == ' ')"
    },
    {
        "line": 150,
        "fullcodeline": "got_tab = FALSE;"
    },
    {
        "line": 151,
        "fullcodeline": "num_spaces = 0;"
    },
    {
        "line": 159,
        "fullcodeline": "++col;"
    },
    {
        "line": 73,
        "fullcodeline": "if (!got_tab && num_spaces == 0)"
    },
    {
        "line": 76,
        "fullcodeline": "start_vcol = vcol;"
    },
    {
        "line": 77,
        "fullcodeline": "start_col = col;"
    },
    {
        "line": 80,
        "fullcodeline": "num_spaces++;"
    },
    {
        "line": 86,
        "fullcodeline": "if (got_tab || (eap->forceit && num_spaces > 1))"
    },
    {
        "line": 82,
        "fullcodeline": "got_tab = TRUE;"
    },
    {
        "line": 91,
        "fullcodeline": "len = num_spaces = vcol - start_vcol;"
    },
    {
        "line": 92,
        "fullcodeline": "num_tabs = 0;"
    },
    {
        "line": 93,
        "fullcodeline": "if (!curbuf->b_p_et)"
    },
    {
        "line": 103,
        "fullcodeline": "temp = new_ts - (start_vcol % new_ts);"
    },
    {
        "line": 109,
        "fullcodeline": "num_tabs += num_spaces / new_ts;"
    },
    {
        "line": 110,
        "fullcodeline": "num_spaces -= (num_spaces / new_ts) * new_ts;"
    },
    {
        "line": 113,
        "fullcodeline": "if (curbuf->b_p_et || got_tab ||"
    },
    {
        "line": 114,
        "fullcodeline": "(num_spaces + num_tabs < len))"
    },
    {
        "line": 128,
        "fullcodeline": "len = num_spaces + num_tabs;"
    },
    {
        "line": 129,
        "fullcodeline": "old_len = (long)STRLEN(ptr);"
    },
    {
        "line": 130,
        "fullcodeline": "new_line = alloc(old_len - col + start_col + len + 1);"
    },
    {
        "line": 145,
        "fullcodeline": "last_line = lnum;"
    },
    {
        "line": 146,
        "fullcodeline": "ptr = new_line;"
    },
    {
        "line": 147,
        "fullcodeline": "col = start_col + len;"
    },
    {
        "line": 104,
        "fullcodeline": "if (num_spaces >= temp)"
    },
    {
        "line": 116,
        "fullcodeline": "if (did_undo == FALSE)"
    },
    {
        "line": 131,
        "fullcodeline": "if (new_line == NULL)"
    },
    {
        "line": 133,
        "fullcodeline": "if (start_col > 0)"
    },
    {
        "line": 136,
        "fullcodeline": "ptr + col, (size_t)(old_len - col + 1));"
    },
    {
        "line": 138,
        "fullcodeline": "for (col = 0; col < len; col++)"
    },
    {
        "line": 139,
        "fullcodeline": "ptr[col] = (col < num_tabs) ? '\\t' : ' ';"
    },
    {
        "line": 140,
        "fullcodeline": "if (ml_replace(lnum, new_line, FALSE) == OK)"
    },
    {
        "line": 143,
        "fullcodeline": "if (first_line == 0)"
    },
    {
        "line": 106,
        "fullcodeline": "num_spaces -= temp;"
    },
    {
        "line": 107,
        "fullcodeline": "num_tabs++;"
    },
    {
        "line": 118,
        "fullcodeline": "did_undo = TRUE;"
    },
    {
        "line": 134,
        "fullcodeline": "mch_memmove(new_line, ptr, (size_t)start_col);"
    },
    {
        "line": 142,
        "fullcodeline": "new_line = curbuf->b_ml.ml_line_ptr;"
    },
    {
        "line": 144,
        "fullcodeline": "first_line = lnum;"
    },
    {
        "line": 119,
        "fullcodeline": "if (u_save((linenr_T)(lnum - 1),"
    },
    {
        "line": 122,
        "fullcodeline": "new_line = NULL;\t// flag out-of-memory"
    },
    {
        "line": 120,
        "fullcodeline": "(linenr_T)(lnum + 1)) == FAIL)"
    }
]