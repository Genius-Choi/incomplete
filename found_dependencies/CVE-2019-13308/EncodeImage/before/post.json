[
    {
        "line": 77,
        "fullcodeline": "assert(image != (Image *) NULL);"
    },
    {
        "line": 78,
        "fullcodeline": "one=1;"
    },
    {
        "line": 79,
        "fullcodeline": "packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));"
    },
    {
        "line": 80,
        "fullcodeline": "hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));"
    },
    {
        "line": 81,
        "fullcodeline": "hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));"
    },
    {
        "line": 82,
        "fullcodeline": "hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,"
    },
    {
        "line": 101,
        "fullcodeline": "(void) memset(packet,0,256*sizeof(*packet));"
    },
    {
        "line": 102,
        "fullcodeline": "(void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));"
    },
    {
        "line": 103,
        "fullcodeline": "(void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));"
    },
    {
        "line": 104,
        "fullcodeline": "(void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));"
    },
    {
        "line": 105,
        "fullcodeline": "number_bits=data_size;"
    },
    {
        "line": 106,
        "fullcodeline": "max_code=MaxCode(number_bits);"
    },
    {
        "line": 107,
        "fullcodeline": "clear_code=((short) one << (data_size-1));"
    },
    {
        "line": 108,
        "fullcodeline": "end_of_information_code=clear_code+1;"
    },
    {
        "line": 109,
        "fullcodeline": "free_code=clear_code+2;"
    },
    {
        "line": 110,
        "fullcodeline": "length=0;"
    },
    {
        "line": 111,
        "fullcodeline": "datum=0;"
    },
    {
        "line": 112,
        "fullcodeline": "bits=0;"
    },
    {
        "line": 113,
        "fullcodeline": "GIFOutputCode(clear_code);"
    },
    {
        "line": 117,
        "fullcodeline": "offset=0;"
    },
    {
        "line": 118,
        "fullcodeline": "pass=0;"
    },
    {
        "line": 119,
        "fullcodeline": "waiting_code=0;"
    },
    {
        "line": 246,
        "fullcodeline": "GIFOutputCode(waiting_code);"
    },
    {
        "line": 247,
        "fullcodeline": "GIFOutputCode(end_of_information_code);"
    },
    {
        "line": 272,
        "fullcodeline": "hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);"
    },
    {
        "line": 273,
        "fullcodeline": "hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);"
    },
    {
        "line": 274,
        "fullcodeline": "hash_code=(short *) RelinquishMagickMemory(hash_code);"
    },
    {
        "line": 275,
        "fullcodeline": "packet=(unsigned char *) RelinquishMagickMemory(packet);"
    },
    {
        "line": 84,
        "fullcodeline": "if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||"
    },
    {
        "line": 120,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 248,
        "fullcodeline": "if (bits > 0)"
    },
    {
        "line": 264,
        "fullcodeline": "if (length > 0)"
    },
    {
        "line": 86,
        "fullcodeline": "(hash_suffix == (unsigned char *) NULL))"
    },
    {
        "line": 128,
        "fullcodeline": "p=GetVirtualPixels(image,0,offset,image->columns,1,exception);"
    },
    {
        "line": 253,
        "fullcodeline": "packet[length++]=(unsigned char) (datum & 0xff);"
    },
    {
        "line": 266,
        "fullcodeline": "(void) WriteBlobByte(image,(unsigned char) length);"
    },
    {
        "line": 267,
        "fullcodeline": "(void) WriteBlob(image,length,packet);"
    },
    {
        "line": 85,
        "fullcodeline": "(hash_prefix == (short *) NULL) ||"
    },
    {
        "line": 88,
        "fullcodeline": "if (packet != (unsigned char *) NULL)"
    },
    {
        "line": 90,
        "fullcodeline": "if (hash_code != (short *) NULL)"
    },
    {
        "line": 92,
        "fullcodeline": "if (hash_prefix != (short *) NULL)"
    },
    {
        "line": 94,
        "fullcodeline": "if (hash_suffix != (unsigned char *) NULL)"
    },
    {
        "line": 129,
        "fullcodeline": "if (p == (const Quantum *) NULL)"
    },
    {
        "line": 131,
        "fullcodeline": "if (y == 0)"
    },
    {
        "line": 136,
        "fullcodeline": "for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 200,
        "fullcodeline": "if (image_info->interlace == NoInterlace)"
    },
    {
        "line": 254,
        "fullcodeline": "if (length >= 254)"
    },
    {
        "line": 89,
        "fullcodeline": "packet=(unsigned char *) RelinquishMagickMemory(packet);"
    },
    {
        "line": 91,
        "fullcodeline": "hash_code=(short *) RelinquishMagickMemory(hash_code);"
    },
    {
        "line": 93,
        "fullcodeline": "hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);"
    },
    {
        "line": 95,
        "fullcodeline": "hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);"
    },
    {
        "line": 133,
        "fullcodeline": "waiting_code=(short) GetPixelIndex(image,p);"
    },
    {
        "line": 134,
        "fullcodeline": "p+=GetPixelChannels(image);"
    },
    {
        "line": 141,
        "fullcodeline": "index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);"
    },
    {
        "line": 142,
        "fullcodeline": "p+=GetPixelChannels(image);"
    },
    {
        "line": 143,
        "fullcodeline": "k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);"
    },
    {
        "line": 146,
        "fullcodeline": "next_pixel=MagickFalse;"
    },
    {
        "line": 147,
        "fullcodeline": "displacement=1;"
    },
    {
        "line": 176,
        "fullcodeline": "GIFOutputCode(waiting_code);"
    },
    {
        "line": 198,
        "fullcodeline": "waiting_code=(short) index;"
    },
    {
        "line": 201,
        "fullcodeline": "offset++;"
    },
    {
        "line": 256,
        "fullcodeline": "(void) WriteBlobByte(image,(unsigned char) length);"
    },
    {
        "line": 257,
        "fullcodeline": "(void) WriteBlob(image,length,packet);"
    },
    {
        "line": 258,
        "fullcodeline": "length=0;"
    },
    {
        "line": 144,
        "fullcodeline": "if (k >= MaxHashTable)"
    },
    {
        "line": 148,
        "fullcodeline": "if (hash_code[k] > 0)"
    },
    {
        "line": 177,
        "fullcodeline": "if (free_code < MaxGIFTable)"
    },
    {
        "line": 145,
        "fullcodeline": "k-=MaxHashTable;"
    },
    {
        "line": 179,
        "fullcodeline": "hash_code[k]=(short) free_code++;"
    },
    {
        "line": 180,
        "fullcodeline": "hash_prefix[k]=waiting_code;"
    },
    {
        "line": 181,
        "fullcodeline": "hash_suffix[k]=(unsigned char) index;"
    },
    {
        "line": 150,
        "fullcodeline": "if ((hash_prefix[k] == waiting_code) &&"
    },
    {
        "line": 156,
        "fullcodeline": "if (k != 0)"
    },
    {
        "line": 173,
        "fullcodeline": "if (next_pixel != MagickFalse)"
    },
    {
        "line": 193,
        "fullcodeline": "free_code=clear_code+2;"
    },
    {
        "line": 194,
        "fullcodeline": "GIFOutputCode(clear_code);"
    },
    {
        "line": 195,
        "fullcodeline": "number_bits=data_size;"
    },
    {
        "line": 196,
        "fullcodeline": "max_code=MaxCode(number_bits);"
    },
    {
        "line": 151,
        "fullcodeline": "(hash_suffix[k] == (unsigned char) index))"
    },
    {
        "line": 153,
        "fullcodeline": "waiting_code=hash_code[k];"
    },
    {
        "line": 157,
        "fullcodeline": "displacement=MaxHashTable-k;"
    },
    {
        "line": 160,
        "fullcodeline": "k-=displacement;"
    },
    {
        "line": 188,
        "fullcodeline": "for (k=0; k < MaxHashTable; k++)"
    },
    {
        "line": 189,
        "fullcodeline": "hash_code[k]=0;"
    },
    {
        "line": 208,
        "fullcodeline": "offset+=8;"
    },
    {
        "line": 218,
        "fullcodeline": "offset+=8;"
    },
    {
        "line": 228,
        "fullcodeline": "offset+=4;"
    },
    {
        "line": 238,
        "fullcodeline": "offset+=2;"
    },
    {
        "line": 161,
        "fullcodeline": "if (k < 0)"
    },
    {
        "line": 163,
        "fullcodeline": "if (hash_code[k] == 0)"
    },
    {
        "line": 165,
        "fullcodeline": "if ((hash_prefix[k] == waiting_code) &&"
    },
    {
        "line": 209,
        "fullcodeline": "if (offset >= (ssize_t) image->rows)"
    },
    {
        "line": 219,
        "fullcodeline": "if (offset >= (ssize_t) image->rows)"
    },
    {
        "line": 229,
        "fullcodeline": "if (offset >= (ssize_t) image->rows)"
    },
    {
        "line": 162,
        "fullcodeline": "k+=MaxHashTable;"
    },
    {
        "line": 166,
        "fullcodeline": "(hash_suffix[k] == (unsigned char) index))"
    },
    {
        "line": 168,
        "fullcodeline": "waiting_code=hash_code[k];"
    },
    {
        "line": 169,
        "fullcodeline": "next_pixel=MagickTrue;"
    },
    {
        "line": 211,
        "fullcodeline": "pass++;"
    },
    {
        "line": 212,
        "fullcodeline": "offset=4;"
    },
    {
        "line": 221,
        "fullcodeline": "pass++;"
    },
    {
        "line": 222,
        "fullcodeline": "offset=2;"
    },
    {
        "line": 231,
        "fullcodeline": "pass++;"
    },
    {
        "line": 232,
        "fullcodeline": "offset=1;"
    }
]