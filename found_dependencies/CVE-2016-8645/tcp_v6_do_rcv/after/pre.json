[
    {
        "line": 3,
        "fullcodeline": "struct ipv6_pinfo *np = inet6_sk(sk);"
    },
    {
        "line": 5,
        "fullcodeline": "struct sk_buff *opt_skb = NULL;"
    },
    {
        "line": 89,
        "fullcodeline": "tcp_v6_send_reset(sk, skb);"
    },
    {
        "line": 96,
        "fullcodeline": "TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);"
    },
    {
        "line": 97,
        "fullcodeline": "TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);"
    },
    {
        "line": 109,
        "fullcodeline": "tp = tcp_sk(sk);"
    },
    {
        "line": 15,
        "fullcodeline": "if (skb->protocol == htons(ETH_P_IP))"
    },
    {
        "line": 18,
        "fullcodeline": "if (tcp_filter(sk, skb))"
    },
    {
        "line": 42,
        "fullcodeline": "if (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */"
    },
    {
        "line": 61,
        "fullcodeline": "if (tcp_checksum_complete(skb))"
    },
    {
        "line": 64,
        "fullcodeline": "if (sk->sk_state == TCP_LISTEN) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (tcp_rcv_state_process(sk, skb))"
    },
    {
        "line": 40,
        "fullcodeline": "opt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));"
    },
    {
        "line": 43,
        "fullcodeline": "struct dst_entry *dst = sk->sk_rx_dst;"
    },
    {
        "line": 45,
        "fullcodeline": "sock_rps_save_rxhash(sk, skb);"
    },
    {
        "line": 46,
        "fullcodeline": "sk_mark_napi_id(sk, skb);"
    },
    {
        "line": 55,
        "fullcodeline": "tcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);"
    },
    {
        "line": 65,
        "fullcodeline": "struct sock *nsk = tcp_v6_cookie_check(sk, skb);"
    },
    {
        "line": 110,
        "fullcodeline": "if (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&"
    },
    {
        "line": 111,
        "fullcodeline": "!((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {"
    },
    {
        "line": 16,
        "fullcodeline": "return tcp_v4_do_rcv(sk, skb);"
    },
    {
        "line": 67,
        "fullcodeline": "if (!nsk)"
    },
    {
        "line": 70,
        "fullcodeline": "if (nsk != sk) {"
    },
    {
        "line": 80,
        "fullcodeline": "sock_rps_save_rxhash(sk, skb);"
    },
    {
        "line": 120,
        "fullcodeline": "if (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {"
    },
    {
        "line": 71,
        "fullcodeline": "sock_rps_save_rxhash(nsk, skb);"
    },
    {
        "line": 72,
        "fullcodeline": "sk_mark_napi_id(nsk, skb);"
    },
    {
        "line": 121,
        "fullcodeline": "skb_set_owner_r(opt_skb, sk);"
    },
    {
        "line": 122,
        "fullcodeline": "tcp_v6_restore_cb(opt_skb);"
    },
    {
        "line": 123,
        "fullcodeline": "opt_skb = xchg(&np->pktoptions, opt_skb);"
    },
    {
        "line": 73,
        "fullcodeline": "if (tcp_child_process(sk, nsk, skb))"
    },
    {
        "line": 113,
        "fullcodeline": "np->mcast_oif = tcp_v6_iif(opt_skb);"
    },
    {
        "line": 117,
        "fullcodeline": "np->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));"
    },
    {
        "line": 119,
        "fullcodeline": "np->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));"
    },
    {
        "line": 126,
        "fullcodeline": "opt_skb = xchg(&np->pktoptions, NULL);"
    },
    {
        "line": 48,
        "fullcodeline": "if (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||"
    },
    {
        "line": 49,
        "fullcodeline": "dst->ops->check(dst, np->rx_dst_cookie) == NULL) {"
    },
    {
        "line": 51,
        "fullcodeline": "sk->sk_rx_dst = NULL;"
    },
    {
        "line": 115,
        "fullcodeline": "np->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;"
    }
]