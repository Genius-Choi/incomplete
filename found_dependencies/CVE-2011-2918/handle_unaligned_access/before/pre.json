[
    {
        "line": 15,
        "fullcodeline": "rm = regs->regs[index];"
    },
    {
        "line": 30,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 145,
        "fullcodeline": "ret = handle_unaligned_ins(instruction, regs, ma);"
    },
    {
        "line": 11,
        "fullcodeline": "if (instruction_size(instruction) != 2)"
    },
    {
        "line": 14,
        "fullcodeline": "index = (instruction>>8)&15;\t/* 0x0F00 */"
    },
    {
        "line": 31,
        "fullcodeline": "switch (instruction&0xF000) {"
    },
    {
        "line": 146,
        "fullcodeline": "if (ret==0)"
    },
    {
        "line": 25,
        "fullcodeline": "unaligned_fixups_notify(current, instruction, regs);"
    },
    {
        "line": 26,
        "fullcodeline": "perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,"
    },
    {
        "line": 128,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 134,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 12,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 33,
        "fullcodeline": "if (instruction==0x000B) {"
    },
    {
        "line": 93,
        "fullcodeline": "switch (instruction&0x0F00) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (ret==0)"
    },
    {
        "line": 135,
        "fullcodeline": "if (ret==0) {"
    },
    {
        "line": 147,
        "fullcodeline": "regs->pc += instruction_size(instruction);"
    },
    {
        "line": 35,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 66,
        "fullcodeline": "if ((instruction&0x00FF)==0x002B) {"
    },
    {
        "line": 68,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 101,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 114,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 36,
        "fullcodeline": "if (ret==0)"
    },
    {
        "line": 69,
        "fullcodeline": "if (ret==0)"
    },
    {
        "line": 102,
        "fullcodeline": "if (ret==0) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (ret==0) {"
    },
    {
        "line": 130,
        "fullcodeline": "regs->pc += SH_PC_12BIT_OFFSET(instruction);"
    },
    {
        "line": 137,
        "fullcodeline": "regs->pc += SH_PC_12BIT_OFFSET(instruction);"
    },
    {
        "line": 39,
        "fullcodeline": "else if ((instruction&0x00FF)==0x0023) {"
    },
    {
        "line": 41,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 72,
        "fullcodeline": "else if ((instruction&0x00FF)==0x000B) {"
    },
    {
        "line": 74,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 108,
        "fullcodeline": "regs->pc += SH_PC_8BIT_OFFSET(instruction);"
    },
    {
        "line": 121,
        "fullcodeline": "regs->pc += SH_PC_8BIT_OFFSET(instruction);"
    },
    {
        "line": 42,
        "fullcodeline": "if (ret==0)"
    },
    {
        "line": 75,
        "fullcodeline": "if (ret==0) {"
    },
    {
        "line": 45,
        "fullcodeline": "else if ((instruction&0x00FF)==0x0003) {"
    },
    {
        "line": 47,
        "fullcodeline": "ret = handle_delayslot(regs, instruction, ma);"
    },
    {
        "line": 48,
        "fullcodeline": "if (ret==0) {"
    }
]