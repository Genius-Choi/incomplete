[
    {
        "line": 11,
        "fullcodeline": "error = generate_and_check_address(regs, opcode,"
    },
    {
        "line": 17,
        "fullcodeline": "perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);"
    },
    {
        "line": 19,
        "fullcodeline": "srcreg = (opcode >> 4) & 0x3f;"
    },
    {
        "line": 13,
        "fullcodeline": "if (error < 0) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (user_mode(regs)) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {"
    },
    {
        "line": 38,
        "fullcodeline": "printk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\","
    },
    {
        "line": 24,
        "fullcodeline": "return -1;"
    },
    {
        "line": 39,
        "fullcodeline": "width_shift, (unsigned long) regs->pc);"
    },
    {
        "line": 44,
        "fullcodeline": "return -1; /* fault */"
    },
    {
        "line": 52,
        "fullcodeline": "misaligned_kernel_word_store(address, val);"
    },
    {
        "line": 64,
        "fullcodeline": "printk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\","
    },
    {
        "line": 29,
        "fullcodeline": "*(__u16 *) &buffer = (__u16) regs->regs[srcreg];"
    },
    {
        "line": 32,
        "fullcodeline": "*(__u32 *) &buffer = (__u32) regs->regs[srcreg];"
    },
    {
        "line": 65,
        "fullcodeline": "width_shift, (unsigned long) regs->pc);"
    }
]