[
    {
        "line": 9,
        "fullcodeline": "perf_sample_data_init(&data, 0);"
    },
    {
        "line": 11,
        "fullcodeline": "cpuc = &__get_cpu_var(cpu_hw_events);"
    },
    {
        "line": 21,
        "fullcodeline": "apic_write(APIC_LVTPC, APIC_DM_NMI);"
    },
    {
        "line": 23,
        "fullcodeline": "intel_pmu_disable_all();"
    },
    {
        "line": 24,
        "fullcodeline": "handled = intel_pmu_drain_bts_buffer();"
    },
    {
        "line": 25,
        "fullcodeline": "status = intel_pmu_get_status();"
    },
    {
        "line": 31,
        "fullcodeline": "loops = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "intel_pmu_ack_status(status);"
    },
    {
        "line": 41,
        "fullcodeline": "inc_irq_stat(apic_perf_irqs);"
    },
    {
        "line": 53,
        "fullcodeline": "for_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {"
    },
    {
        "line": 73,
        "fullcodeline": "status = intel_pmu_get_status();"
    },
    {
        "line": 26,
        "fullcodeline": "if (!status) {"
    },
    {
        "line": 54,
        "fullcodeline": "struct perf_event *event = cpuc->events[bit];"
    },
    {
        "line": 56,
        "fullcodeline": "handled++;"
    },
    {
        "line": 64,
        "fullcodeline": "data.period = event->hw.last_period;"
    },
    {
        "line": 27,
        "fullcodeline": "intel_pmu_enable_all(0);"
    },
    {
        "line": 34,
        "fullcodeline": "if (++loops > 100) {"
    },
    {
        "line": 49,
        "fullcodeline": "handled++;"
    },
    {
        "line": 50,
        "fullcodeline": "x86_pmu.drain_pebs(regs);"
    },
    {
        "line": 66,
        "fullcodeline": "if (perf_event_overflow(event, 1, &data, regs))"
    },
    {
        "line": 58,
        "fullcodeline": "if (!test_bit(bit, cpuc->active_mask))"
    },
    {
        "line": 61,
        "fullcodeline": "if (!intel_pmu_save_and_restart(event))"
    }
]