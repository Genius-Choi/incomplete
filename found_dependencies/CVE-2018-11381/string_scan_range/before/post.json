[
    {
        "line": 3,
        "fullcodeline": "ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];"
    },
    {
        "line": 4,
        "fullcodeline": "ut64 str_start, needle = from;"
    },
    {
        "line": 5,
        "fullcodeline": "int count = 0, i, rc, runes;"
    },
    {
        "line": 6,
        "fullcodeline": "int str_type = R_STRING_TYPE_DETECT;"
    },
    {
        "line": 15,
        "fullcodeline": "ut8 *buf = calloc (to - from, 1);"
    },
    {
        "line": 19,
        "fullcodeline": "r_buf_read_at (bf->buf, from, buf, to - from);"
    },
    {
        "line": 155,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 8,
        "fullcodeline": "if (type == -1) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (from >= to) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (!buf || !min) {"
    },
    {
        "line": 21,
        "fullcodeline": "while (needle < to) {"
    },
    {
        "line": 9,
        "fullcodeline": "type = R_STRING_TYPE_DETECT;"
    },
    {
        "line": 12,
        "fullcodeline": "eprintf (\"Invalid range to find strings 0x%llx .. 0x%llx\\n\", from, to);"
    },
    {
        "line": 22,
        "fullcodeline": "rc = r_utf8_decode (buf + needle - from, to - needle, NULL);"
    },
    {
        "line": 43,
        "fullcodeline": "runes = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "str_start = needle;"
    },
    {
        "line": 103,
        "fullcodeline": "tmp[i++] = '\\0';"
    },
    {
        "line": 13,
        "fullcodeline": "return -1;"
    },
    {
        "line": 17,
        "fullcodeline": "return -1;"
    },
    {
        "line": 23,
        "fullcodeline": "if (!rc) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (type == R_STRING_TYPE_DETECT) {"
    },
    {
        "line": 47,
        "fullcodeline": "for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (runes >= min) {"
    },
    {
        "line": 24,
        "fullcodeline": "needle++;"
    },
    {
        "line": 28,
        "fullcodeline": "char *w = (char *)buf + needle + rc - from;"
    },
    {
        "line": 48,
        "fullcodeline": "RRune r = {0};"
    },
    {
        "line": 73,
        "fullcodeline": "needle += rc;"
    },
    {
        "line": 118,
        "fullcodeline": "RBinString *bs = R_NEW0 (RBinString);"
    },
    {
        "line": 122,
        "fullcodeline": "bs->type = str_type;"
    },
    {
        "line": 123,
        "fullcodeline": "bs->length = runes;"
    },
    {
        "line": 124,
        "fullcodeline": "bs->size = needle - str_start;"
    },
    {
        "line": 125,
        "fullcodeline": "bs->ordinal = count++;"
    },
    {
        "line": 145,
        "fullcodeline": "bs->paddr = bs->vaddr = str_start;"
    },
    {
        "line": 146,
        "fullcodeline": "bs->string = r_str_ndup ((const char *)tmp, i);"
    },
    {
        "line": 29,
        "fullcodeline": "if ((to - needle) > 5) {"
    },
    {
        "line": 41,
        "fullcodeline": "str_type = type;"
    },
    {
        "line": 50,
        "fullcodeline": "if (str_type == R_STRING_TYPE_WIDE32) {"
    },
    {
        "line": 68,
        "fullcodeline": "if (!rc) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (r_isprint (r) && r != '\\\\') {"
    },
    {
        "line": 106,
        "fullcodeline": "if (str_type == R_STRING_TYPE_ASCII) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (!bs) {"
    },
    {
        "line": 30,
        "fullcodeline": "bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];"
    },
    {
        "line": 51,
        "fullcodeline": "rc = r_utf32le_decode (buf + needle - from, to - needle, &r);"
    },
    {
        "line": 69,
        "fullcodeline": "needle++;"
    },
    {
        "line": 81,
        "fullcodeline": "rc = r_utf8_encode (&tmp[i], r);"
    },
    {
        "line": 82,
        "fullcodeline": "runes++;"
    },
    {
        "line": 148,
        "fullcodeline": "r_list_append (list, bs);"
    },
    {
        "line": 38,
        "fullcodeline": "str_type = R_STRING_TYPE_ASCII;"
    },
    {
        "line": 76,
        "fullcodeline": "if (str_type == R_STRING_TYPE_WIDE32) {"
    },
    {
        "line": 109,
        "fullcodeline": "for (j = 0; j < i; j++) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (str_start -from> 1) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (str_start -from> 3) {"
    },
    {
        "line": 150,
        "fullcodeline": "print_string (bs, bf);"
    },
    {
        "line": 151,
        "fullcodeline": "r_bin_string_free (bs);"
    },
    {
        "line": 32,
        "fullcodeline": "str_type = R_STRING_TYPE_WIDE32;"
    },
    {
        "line": 53,
        "fullcodeline": "rc = 4;"
    },
    {
        "line": 55,
        "fullcodeline": "} else if (str_type == R_STRING_TYPE_WIDE) {"
    },
    {
        "line": 84,
        "fullcodeline": "} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {"
    },
    {
        "line": 110,
        "fullcodeline": "char ch = tmp[j];"
    },
    {
        "line": 130,
        "fullcodeline": "const ut8 *p = buf + str_start - 2 - from;"
    },
    {
        "line": 138,
        "fullcodeline": "const ut8 *p = buf + str_start - 4 - from;"
    },
    {
        "line": 34,
        "fullcodeline": "bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];"
    },
    {
        "line": 35,
        "fullcodeline": "str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;"
    },
    {
        "line": 56,
        "fullcodeline": "rc = r_utf16le_decode (buf + needle - from, to - needle, &r);"
    },
    {
        "line": 77,
        "fullcodeline": "if (r == 0xff) {"
    },
    {
        "line": 95,
        "fullcodeline": "rc = 2;"
    },
    {
        "line": 96,
        "fullcodeline": "runes++;"
    },
    {
        "line": 111,
        "fullcodeline": "if (ch != '\\n' && ch != '\\r' && ch != '\\t') {"
    },
    {
        "line": 131,
        "fullcodeline": "if (p[0] == 0xff && p[1] == 0xfe) {"
    },
    {
        "line": 139,
        "fullcodeline": "if (p[0] == 0xff && p[1] == 0xfe) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (rc == 1) {"
    },
    {
        "line": 61,
        "fullcodeline": "rc = r_utf8_decode (buf + needle - from, to - needle, &r);"
    },
    {
        "line": 78,
        "fullcodeline": "r = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "if ((i + 32) < sizeof (tmp) && r < 93) {"
    },
    {
        "line": 132,
        "fullcodeline": "str_start -= 2; // \\xff\\xfe"
    },
    {
        "line": 140,
        "fullcodeline": "str_start -= 4; // \\xff\\xfe\\x00\\x00"
    },
    {
        "line": 58,
        "fullcodeline": "rc = 2;"
    },
    {
        "line": 62,
        "fullcodeline": "if (rc > 1) {"
    },
    {
        "line": 86,
        "fullcodeline": "tmp[i + 0] = '\\\\';"
    },
    {
        "line": 112,
        "fullcodeline": "if (!IS_PRINTABLE (tmp[j])) {"
    },
    {
        "line": 63,
        "fullcodeline": "str_type = R_STRING_TYPE_UTF8;"
    },
    {
        "line": 87,
        "fullcodeline": "tmp[i + 1] = \"       abtnvfr             e  \""
    }
]