[
    {
        "line": 7,
        "fullcodeline": "for (i = 0; i < insn_cnt; i++, insn++) {"
    },
    {
        "line": 8,
        "fullcodeline": "if (BPF_CLASS(insn->code) == BPF_LDX &&"
    },
    {
        "line": 14,
        "fullcodeline": "if (BPF_CLASS(insn->code) == BPF_STX &&"
    },
    {
        "line": 21,
        "fullcodeline": "if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {"
    },
    {
        "line": 9,
        "fullcodeline": "(BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {"
    },
    {
        "line": 10,
        "fullcodeline": "verbose(\"BPF_LDX uses reserved fields\\n\");"
    },
    {
        "line": 15,
        "fullcodeline": "((BPF_MODE(insn->code) != BPF_MEM &&"
    },
    {
        "line": 17,
        "fullcodeline": "verbose(\"BPF_STX uses reserved fields\\n\");"
    },
    {
        "line": 41,
        "fullcodeline": "f = fdget(insn->imm);"
    },
    {
        "line": 42,
        "fullcodeline": "map = __bpf_map_get(f);"
    },
    {
        "line": 50,
        "fullcodeline": "insn[0].imm = (u32) (unsigned long) map;"
    },
    {
        "line": 51,
        "fullcodeline": "insn[1].imm = ((u64) (unsigned long) map) >> 32;"
    },
    {
        "line": 70,
        "fullcodeline": "map = bpf_map_inc(map, false);"
    },
    {
        "line": 75,
        "fullcodeline": "env->used_maps[env->used_map_cnt++] = map;"
    },
    {
        "line": 77,
        "fullcodeline": "fdput(f);"
    },
    {
        "line": 79,
        "fullcodeline": "insn++;"
    },
    {
        "line": 80,
        "fullcodeline": "i++;"
    },
    {
        "line": 11,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 16,
        "fullcodeline": "BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {"
    },
    {
        "line": 18,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 25,
        "fullcodeline": "if (i == insn_cnt - 1 || insn[1].code != 0 ||"
    },
    {
        "line": 32,
        "fullcodeline": "if (insn->src_reg == 0)"
    },
    {
        "line": 36,
        "fullcodeline": "if (insn->src_reg != BPF_PSEUDO_MAP_FD) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (IS_ERR(map)) {"
    },
    {
        "line": 54,
        "fullcodeline": "for (j = 0; j < env->used_map_cnt; j++)"
    },
    {
        "line": 60,
        "fullcodeline": "if (env->used_map_cnt >= MAX_USED_MAPS) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (IS_ERR(map)) {"
    },
    {
        "line": 27,
        "fullcodeline": "insn[1].off != 0) {"
    },
    {
        "line": 28,
        "fullcodeline": "verbose(\"invalid bpf_ld_imm64 insn\\n\");"
    },
    {
        "line": 37,
        "fullcodeline": "verbose(\"unrecognized bpf_ld_imm64 insn\\n\");"
    },
    {
        "line": 44,
        "fullcodeline": "verbose(\"fd %d is not pointing to valid bpf_map\\n\","
    },
    {
        "line": 55,
        "fullcodeline": "if (env->used_maps[j] == map) {"
    },
    {
        "line": 61,
        "fullcodeline": "fdput(f);"
    },
    {
        "line": 72,
        "fullcodeline": "fdput(f);"
    },
    {
        "line": 26,
        "fullcodeline": "insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||"
    },
    {
        "line": 29,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 38,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 46,
        "fullcodeline": "return PTR_ERR(map);"
    },
    {
        "line": 56,
        "fullcodeline": "fdput(f);"
    },
    {
        "line": 62,
        "fullcodeline": "return -E2BIG;"
    },
    {
        "line": 73,
        "fullcodeline": "return PTR_ERR(map);"
    }
]