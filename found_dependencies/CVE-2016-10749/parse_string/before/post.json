[
    {
        "line": 3,
        "fullcodeline": "const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;"
    },
    {
        "line": 8,
        "fullcodeline": "out=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */"
    },
    {
        "line": 10,
        "fullcodeline": "item->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */"
    },
    {
        "line": 11,
        "fullcodeline": "item->type=cJSON_String;"
    },
    {
        "line": 13,
        "fullcodeline": "ptr=str+1;ptr2=out;"
    },
    {
        "line": 57,
        "fullcodeline": "*ptr2=0;"
    },
    {
        "line": 4,
        "fullcodeline": "if (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */"
    },
    {
        "line": 6,
        "fullcodeline": "while (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t/* Skip escaped quotes. */"
    },
    {
        "line": 9,
        "fullcodeline": "if (!out) return 0;"
    },
    {
        "line": 14,
        "fullcodeline": "while (ptr < end_ptr)"
    },
    {
        "line": 58,
        "fullcodeline": "if (*ptr=='\\\"') ptr++;"
    },
    {
        "line": 16,
        "fullcodeline": "if (*ptr!='\\\\') *ptr2++=*ptr++;"
    },
    {
        "line": 19,
        "fullcodeline": "ptr++;"
    },
    {
        "line": 54,
        "fullcodeline": "ptr++;"
    },
    {
        "line": 22,
        "fullcodeline": "case 'b': *ptr2++='\\b';\tbreak;"
    },
    {
        "line": 23,
        "fullcodeline": "case 'f': *ptr2++='\\f';\tbreak;"
    },
    {
        "line": 24,
        "fullcodeline": "case 'n': *ptr2++='\\n';\tbreak;"
    },
    {
        "line": 25,
        "fullcodeline": "case 'r': *ptr2++='\\r';\tbreak;"
    },
    {
        "line": 26,
        "fullcodeline": "case 't': *ptr2++='\\t';\tbreak;"
    },
    {
        "line": 28,
        "fullcodeline": "uc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */"
    },
    {
        "line": 42,
        "fullcodeline": "len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;"
    },
    {
        "line": 50,
        "fullcodeline": "ptr2+=len;"
    },
    {
        "line": 52,
        "fullcodeline": "default:  *ptr2++=*ptr; break;"
    },
    {
        "line": 29,
        "fullcodeline": "if (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */"
    },
    {
        "line": 31,
        "fullcodeline": "if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */"
    },
    {
        "line": 33,
        "fullcodeline": "if (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/"
    },
    {
        "line": 37,
        "fullcodeline": "uc2=parse_hex4(ptr+3);ptr+=6;"
    },
    {
        "line": 39,
        "fullcodeline": "uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));"
    },
    {
        "line": 45,
        "fullcodeline": "case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;"
    },
    {
        "line": 46,
        "fullcodeline": "case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;"
    },
    {
        "line": 47,
        "fullcodeline": "case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;"
    },
    {
        "line": 48,
        "fullcodeline": "case 1: *--ptr2 =(uc | firstByteMark[len]);"
    },
    {
        "line": 35,
        "fullcodeline": "if (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */"
    },
    {
        "line": 36,
        "fullcodeline": "if (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */"
    },
    {
        "line": 38,
        "fullcodeline": "if (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */"
    }
]