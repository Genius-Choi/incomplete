[
    {
        "line": 5,
        "fullcodeline": "unsigned long ifargs[4];"
    },
    {
        "line": 8,
        "fullcodeline": "int fd = -1, ctlfd = -1, unixfd = -1;"
    },
    {
        "line": 9,
        "fullcodeline": "int use_vnet = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "const char *bridge = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "char iface[IFNAMSIZ];"
    },
    {
        "line": 17,
        "fullcodeline": "int ret = EXIT_SUCCESS;"
    },
    {
        "line": 54,
        "fullcodeline": "QSIMPLEQ_INIT(&acl_list);"
    },
    {
        "line": 66,
        "fullcodeline": "access_allowed = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "access_denied = 0;"
    },
    {
        "line": 68,
        "fullcodeline": "QSIMPLEQ_FOREACH(acl_rule, &acl_list, entry) {"
    },
    {
        "line": 96,
        "fullcodeline": "ctlfd = socket(AF_INET, SOCK_STREAM, 0);"
    },
    {
        "line": 104,
        "fullcodeline": "fd = open(\"/dev/net/tun\", O_RDWR);"
    },
    {
        "line": 113,
        "fullcodeline": "prep_ifreq(&ifr, \"tap%d\");"
    },
    {
        "line": 114,
        "fullcodeline": "ifr.ifr_flags = IFF_TAP|IFF_NO_PI;"
    },
    {
        "line": 126,
        "fullcodeline": "snprintf(iface, sizeof(iface), \"%s\", ifr.ifr_name);"
    },
    {
        "line": 129,
        "fullcodeline": "prep_ifreq(&ifr, bridge);"
    },
    {
        "line": 138,
        "fullcodeline": "mtu = ifr.ifr_mtu;"
    },
    {
        "line": 141,
        "fullcodeline": "prep_ifreq(&ifr, iface);"
    },
    {
        "line": 142,
        "fullcodeline": "ifr.ifr_mtu = mtu;"
    },
    {
        "line": 160,
        "fullcodeline": "ifr.ifr_hwaddr.sa_data[0] = 0xFE;"
    },
    {
        "line": 169,
        "fullcodeline": "prep_ifreq(&ifr, bridge);"
    },
    {
        "line": 170,
        "fullcodeline": "ifindex = if_nametoindex(iface);"
    },
    {
        "line": 172,
        "fullcodeline": "ifargs[0] = BRCTL_ADD_IF;"
    },
    {
        "line": 173,
        "fullcodeline": "ifargs[1] = ifindex;"
    },
    {
        "line": 174,
        "fullcodeline": "ifargs[2] = 0;"
    },
    {
        "line": 175,
        "fullcodeline": "ifargs[3] = 0;"
    },
    {
        "line": 176,
        "fullcodeline": "ifr.ifr_data = (void *)ifargs;"
    },
    {
        "line": 177,
        "fullcodeline": "ret = ioctl(ctlfd, SIOCDEVPRIVATE, &ifr);"
    },
    {
        "line": 190,
        "fullcodeline": "prep_ifreq(&ifr, iface);"
    },
    {
        "line": 198,
        "fullcodeline": "ifr.ifr_flags |= IFF_UP;"
    },
    {
        "line": 31,
        "fullcodeline": "for (index = 1; index < argc; index++) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (bridge == NULL || unixfd == -1) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (strlen(bridge) >= IFNAMSIZ) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (parse_acl_file(DEFAULT_ACL_FILE, &acl_list) == -1) {"
    },
    {
        "line": 89,
        "fullcodeline": "if ((access_allowed == 0) || (access_denied == 1)) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (ctlfd == -1) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (fd == -1) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (use_vnet && has_vnet_hdr(fd)) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (ioctl(fd, TUNSETIFF, &ifr) == -1) {"
    },
    {
        "line": 130,
        "fullcodeline": "if (ioctl(ctlfd, SIOCGIFMTU, &ifr) == -1) {"
    },
    {
        "line": 143,
        "fullcodeline": "if (ioctl(ctlfd, SIOCSIFMTU, &ifr) == -1) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (ioctl(ctlfd, SIOCGIFHWADDR, &ifr) < 0) {"
    },
    {
        "line": 161,
        "fullcodeline": "if (ioctl(ctlfd, SIOCSIFHWADDR, &ifr) < 0) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (ret == -1) {"
    },
    {
        "line": 191,
        "fullcodeline": "if (ioctl(ctlfd, SIOCGIFFLAGS, &ifr) == -1) {"
    },
    {
        "line": 199,
        "fullcodeline": "if (ioctl(ctlfd, SIOCSIFFLAGS, &ifr) == -1) {"
    },
    {
        "line": 207,
        "fullcodeline": "if (send_fd(unixfd, fd) == -1) {"
    },
    {
        "line": 219,
        "fullcodeline": "if (fd >= 0) {"
    },
    {
        "line": 222,
        "fullcodeline": "if (ctlfd >= 0) {"
    },
    {
        "line": 225,
        "fullcodeline": "while ((acl_rule = QSIMPLEQ_FIRST(&acl_list)) != NULL) {"
    },
    {
        "line": 45,
        "fullcodeline": "usage();"
    },
    {
        "line": 49,
        "fullcodeline": "fprintf(stderr, \"name `%s' too long: %zu\\n\", bridge, strlen(bridge));"
    },
    {
        "line": 56,
        "fullcodeline": "fprintf(stderr, \"failed to parse default acl file `%s'\\n\","
    },
    {
        "line": 58,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 90,
        "fullcodeline": "fprintf(stderr, \"access denied by acl file\\n\");"
    },
    {
        "line": 91,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 98,
        "fullcodeline": "fprintf(stderr, \"failed to open control socket: %s\\n\", strerror(errno));"
    },
    {
        "line": 99,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 106,
        "fullcodeline": "fprintf(stderr, \"failed to open /dev/net/tun: %s\\n\", strerror(errno));"
    },
    {
        "line": 107,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 116,
        "fullcodeline": "ifr.ifr_flags |= IFF_VNET_HDR;"
    },
    {
        "line": 120,
        "fullcodeline": "fprintf(stderr, \"failed to create tun device: %s\\n\", strerror(errno));"
    },
    {
        "line": 121,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 131,
        "fullcodeline": "fprintf(stderr, \"failed to get mtu of bridge `%s': %s\\n\","
    },
    {
        "line": 133,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 144,
        "fullcodeline": "fprintf(stderr, \"failed to set mtu of device `%s' to %d: %s\\n\","
    },
    {
        "line": 146,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 155,
        "fullcodeline": "fprintf(stderr, \"failed to get MAC address of device `%s': %s\\n\","
    },
    {
        "line": 157,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 162,
        "fullcodeline": "fprintf(stderr, \"failed to set MAC address of device `%s': %s\\n\","
    },
    {
        "line": 164,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 183,
        "fullcodeline": "fprintf(stderr, \"failed to add interface `%s' to bridge `%s': %s\\n\","
    },
    {
        "line": 185,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 192,
        "fullcodeline": "fprintf(stderr, \"failed to get interface flags for `%s': %s\\n\","
    },
    {
        "line": 194,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 200,
        "fullcodeline": "fprintf(stderr, \"failed to bring up interface `%s': %s\\n\","
    },
    {
        "line": 202,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 208,
        "fullcodeline": "fprintf(stderr, \"failed to write fd to unix socket: %s\\n\","
    },
    {
        "line": 210,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 220,
        "fullcodeline": "close(fd);"
    },
    {
        "line": 223,
        "fullcodeline": "close(ctlfd);"
    },
    {
        "line": 226,
        "fullcodeline": "QSIMPLEQ_REMOVE_HEAD(&acl_list, entry);"
    },
    {
        "line": 227,
        "fullcodeline": "g_free(acl_rule);"
    },
    {
        "line": 32,
        "fullcodeline": "if (strcmp(argv[index], \"--use-vnet\") == 0) {"
    },
    {
        "line": 71,
        "fullcodeline": "access_allowed = 1;"
    },
    {
        "line": 79,
        "fullcodeline": "access_denied = 1;"
    },
    {
        "line": 132,
        "fullcodeline": "bridge, strerror(errno));"
    },
    {
        "line": 145,
        "fullcodeline": "iface, mtu, strerror(errno));"
    },
    {
        "line": 156,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 163,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 184,
        "fullcodeline": "iface, bridge, strerror(errno));"
    },
    {
        "line": 193,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 201,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 209,
        "fullcodeline": "strerror(errno));"
    },
    {
        "line": 33,
        "fullcodeline": "use_vnet = 1;"
    },
    {
        "line": 74,
        "fullcodeline": "if (strcmp(bridge, acl_rule->iface) == 0) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (strcmp(bridge, acl_rule->iface) == 0) {"
    },
    {
        "line": 75,
        "fullcodeline": "access_allowed = 1;"
    },
    {
        "line": 83,
        "fullcodeline": "access_denied = 1;"
    },
    {
        "line": 34,
        "fullcodeline": "} else if (strncmp(argv[index], \"--br=\", 5) == 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "} else if (strncmp(argv[index], \"--fd=\", 5) == 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "unixfd = atoi(&argv[index][5]);"
    },
    {
        "line": 39,
        "fullcodeline": "usage();"
    }
]