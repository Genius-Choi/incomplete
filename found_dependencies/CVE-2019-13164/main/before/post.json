[
    {
        "line": 5,
        "fullcodeline": "unsigned long ifargs[4];"
    },
    {
        "line": 8,
        "fullcodeline": "int fd = -1, ctlfd = -1, unixfd = -1;"
    },
    {
        "line": 9,
        "fullcodeline": "int use_vnet = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "const char *bridge = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "char iface[IFNAMSIZ];"
    },
    {
        "line": 17,
        "fullcodeline": "int ret = EXIT_SUCCESS;"
    },
    {
        "line": 50,
        "fullcodeline": "QSIMPLEQ_INIT(&acl_list);"
    },
    {
        "line": 62,
        "fullcodeline": "access_allowed = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "access_denied = 0;"
    },
    {
        "line": 64,
        "fullcodeline": "QSIMPLEQ_FOREACH(acl_rule, &acl_list, entry) {"
    },
    {
        "line": 92,
        "fullcodeline": "ctlfd = socket(AF_INET, SOCK_STREAM, 0);"
    },
    {
        "line": 100,
        "fullcodeline": "fd = open(\"/dev/net/tun\", O_RDWR);"
    },
    {
        "line": 109,
        "fullcodeline": "prep_ifreq(&ifr, \"tap%d\");"
    },
    {
        "line": 110,
        "fullcodeline": "ifr.ifr_flags = IFF_TAP|IFF_NO_PI;"
    },
    {
        "line": 122,
        "fullcodeline": "snprintf(iface, sizeof(iface), \"%s\", ifr.ifr_name);"
    },
    {
        "line": 125,
        "fullcodeline": "prep_ifreq(&ifr, bridge);"
    },
    {
        "line": 134,
        "fullcodeline": "mtu = ifr.ifr_mtu;"
    },
    {
        "line": 137,
        "fullcodeline": "prep_ifreq(&ifr, iface);"
    },
    {
        "line": 138,
        "fullcodeline": "ifr.ifr_mtu = mtu;"
    },
    {
        "line": 156,
        "fullcodeline": "ifr.ifr_hwaddr.sa_data[0] = 0xFE;"
    },
    {
        "line": 165,
        "fullcodeline": "prep_ifreq(&ifr, bridge);"
    },
    {
        "line": 166,
        "fullcodeline": "ifindex = if_nametoindex(iface);"
    },
    {
        "line": 168,
        "fullcodeline": "ifargs[0] = BRCTL_ADD_IF;"
    },
    {
        "line": 169,
        "fullcodeline": "ifargs[1] = ifindex;"
    },
    {
        "line": 170,
        "fullcodeline": "ifargs[2] = 0;"
    },
    {
        "line": 171,
        "fullcodeline": "ifargs[3] = 0;"
    },
    {
        "line": 172,
        "fullcodeline": "ifr.ifr_data = (void *)ifargs;"
    },
    {
        "line": 173,
        "fullcodeline": "ret = ioctl(ctlfd, SIOCDEVPRIVATE, &ifr);"
    },
    {
        "line": 186,
        "fullcodeline": "prep_ifreq(&ifr, iface);"
    },
    {
        "line": 194,
        "fullcodeline": "ifr.ifr_flags |= IFF_UP;"
    },
    {
        "line": 31,
        "fullcodeline": "for (index = 1; index < argc; index++) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (bridge == NULL || unixfd == -1) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (parse_acl_file(DEFAULT_ACL_FILE, &acl_list) == -1) {"
    },
    {
        "line": 85,
        "fullcodeline": "if ((access_allowed == 0) || (access_denied == 1)) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (ctlfd == -1) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (fd == -1) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (use_vnet && has_vnet_hdr(fd)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (ioctl(fd, TUNSETIFF, &ifr) == -1) {"
    },
    {
        "line": 126,
        "fullcodeline": "if (ioctl(ctlfd, SIOCGIFMTU, &ifr) == -1) {"
    },
    {
        "line": 139,
        "fullcodeline": "if (ioctl(ctlfd, SIOCSIFMTU, &ifr) == -1) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (ioctl(ctlfd, SIOCGIFHWADDR, &ifr) < 0) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (ioctl(ctlfd, SIOCSIFHWADDR, &ifr) < 0) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (ret == -1) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (ioctl(ctlfd, SIOCGIFFLAGS, &ifr) == -1) {"
    },
    {
        "line": 195,
        "fullcodeline": "if (ioctl(ctlfd, SIOCSIFFLAGS, &ifr) == -1) {"
    },
    {
        "line": 203,
        "fullcodeline": "if (send_fd(unixfd, fd) == -1) {"
    },
    {
        "line": 215,
        "fullcodeline": "if (fd >= 0) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (ctlfd >= 0) {"
    },
    {
        "line": 221,
        "fullcodeline": "while ((acl_rule = QSIMPLEQ_FIRST(&acl_list)) != NULL) {"
    },
    {
        "line": 45,
        "fullcodeline": "usage();"
    },
    {
        "line": 52,
        "fullcodeline": "fprintf(stderr, \"failed to parse default acl file `%s'\\n\","
    },
    {
        "line": 54,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 86,
        "fullcodeline": "fprintf(stderr, \"access denied by acl file\\n\");"
    },
    {
        "line": 87,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 94,
        "fullcodeline": "fprintf(stderr, \"failed to open control socket: %s\\n\", strerror(errno));"
    },
    {
        "line": 95,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 102,
        "fullcodeline": "fprintf(stderr, \"failed to open /dev/net/tun: %s\\n\", strerror(errno));"
    },
    {
        "line": 103,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 112,
        "fullcodeline": "ifr.ifr_flags |= IFF_VNET_HDR;"
    },
    {
        "line": 116,
        "fullcodeline": "fprintf(stderr, \"failed to create tun device: %s\\n\", strerror(errno));"
    },
    {
        "line": 117,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 127,
        "fullcodeline": "fprintf(stderr, \"failed to get mtu of bridge `%s': %s\\n\","
    },
    {
        "line": 129,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 140,
        "fullcodeline": "fprintf(stderr, \"failed to set mtu of device `%s' to %d: %s\\n\","
    },
    {
        "line": 142,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 151,
        "fullcodeline": "fprintf(stderr, \"failed to get MAC address of device `%s': %s\\n\","
    },
    {
        "line": 153,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 158,
        "fullcodeline": "fprintf(stderr, \"failed to set MAC address of device `%s': %s\\n\","
    },
    {
        "line": 160,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 179,
        "fullcodeline": "fprintf(stderr, \"failed to add interface `%s' to bridge `%s': %s\\n\","
    },
    {
        "line": 181,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 188,
        "fullcodeline": "fprintf(stderr, \"failed to get interface flags for `%s': %s\\n\","
    },
    {
        "line": 190,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 196,
        "fullcodeline": "fprintf(stderr, \"failed to bring up interface `%s': %s\\n\","
    },
    {
        "line": 198,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 204,
        "fullcodeline": "fprintf(stderr, \"failed to write fd to unix socket: %s\\n\","
    },
    {
        "line": 206,
        "fullcodeline": "ret = EXIT_FAILURE;"
    },
    {
        "line": 216,
        "fullcodeline": "close(fd);"
    },
    {
        "line": 219,
        "fullcodeline": "close(ctlfd);"
    },
    {
        "line": 222,
        "fullcodeline": "QSIMPLEQ_REMOVE_HEAD(&acl_list, entry);"
    },
    {
        "line": 223,
        "fullcodeline": "g_free(acl_rule);"
    },
    {
        "line": 32,
        "fullcodeline": "if (strcmp(argv[index], \"--use-vnet\") == 0) {"
    },
    {
        "line": 67,
        "fullcodeline": "access_allowed = 1;"
    },
    {
        "line": 75,
        "fullcodeline": "access_denied = 1;"
    },
    {
        "line": 128,
        "fullcodeline": "bridge, strerror(errno));"
    },
    {
        "line": 141,
        "fullcodeline": "iface, mtu, strerror(errno));"
    },
    {
        "line": 152,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 159,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 180,
        "fullcodeline": "iface, bridge, strerror(errno));"
    },
    {
        "line": 189,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 197,
        "fullcodeline": "iface, strerror(errno));"
    },
    {
        "line": 205,
        "fullcodeline": "strerror(errno));"
    },
    {
        "line": 33,
        "fullcodeline": "use_vnet = 1;"
    },
    {
        "line": 70,
        "fullcodeline": "if (strcmp(bridge, acl_rule->iface) == 0) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (strcmp(bridge, acl_rule->iface) == 0) {"
    },
    {
        "line": 71,
        "fullcodeline": "access_allowed = 1;"
    },
    {
        "line": 79,
        "fullcodeline": "access_denied = 1;"
    },
    {
        "line": 34,
        "fullcodeline": "} else if (strncmp(argv[index], \"--br=\", 5) == 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "} else if (strncmp(argv[index], \"--fd=\", 5) == 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "unixfd = atoi(&argv[index][5]);"
    },
    {
        "line": 39,
        "fullcodeline": "usage();"
    }
]