[
    {
        "line": 8,
        "fullcodeline": "PySocketSockObject *sock = GET_SOCKET(self);"
    },
    {
        "line": 9,
        "fullcodeline": "_PyTime_t timeout, deadline = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "timeout = GET_SOCKET_TIMEOUT(sock);"
    },
    {
        "line": 39,
        "fullcodeline": "sockstate = PySSL_select(sock, 1, timeout);"
    },
    {
        "line": 12,
        "fullcodeline": "if (sock != NULL) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (b->len > INT_MAX) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (sock != NULL) {"
    },
    {
        "line": 35,
        "fullcodeline": "has_timeout = (timeout > 0);"
    },
    {
        "line": 40,
        "fullcodeline": "if (sockstate == SOCKET_HAS_TIMED_OUT) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (len <= 0)"
    },
    {
        "line": 94,
        "fullcodeline": "return PyLong_FromLong(len);"
    },
    {
        "line": 18,
        "fullcodeline": "Py_INCREF(sock);"
    },
    {
        "line": 22,
        "fullcodeline": "PyErr_Format(PyExc_OverflowError,"
    },
    {
        "line": 29,
        "fullcodeline": "nonblocking = (sock->sock_timeout >= 0);"
    },
    {
        "line": 30,
        "fullcodeline": "BIO_set_nbio(SSL_get_rbio(self->ssl), nonblocking);"
    },
    {
        "line": 37,
        "fullcodeline": "deadline = _PyTime_GetMonotonicClock() + timeout;"
    },
    {
        "line": 56,
        "fullcodeline": "len = SSL_write(self->ssl, b->buf, (int)b->len);"
    },
    {
        "line": 57,
        "fullcodeline": "err = _PySSL_errno(len <= 0, self->ssl, len);"
    },
    {
        "line": 86,
        "fullcodeline": "} while (err.ssl == SSL_ERROR_WANT_READ ||"
    },
    {
        "line": 87,
        "fullcodeline": "err.ssl == SSL_ERROR_WANT_WRITE);"
    },
    {
        "line": 92,
        "fullcodeline": "if (PySSL_ChainExceptions(self) < 0)"
    },
    {
        "line": 13,
        "fullcodeline": "if (((PyObject*)sock) == Py_None) {"
    },
    {
        "line": 31,
        "fullcodeline": "BIO_set_nbio(SSL_get_wbio(self->ssl), nonblocking);"
    },
    {
        "line": 67,
        "fullcodeline": "if (err.ssl == SSL_ERROR_WANT_READ) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (sockstate == SOCKET_HAS_TIMED_OUT) {"
    },
    {
        "line": 91,
        "fullcodeline": "return PySSL_SetError(self, len, __FILE__, __LINE__);"
    },
    {
        "line": 14,
        "fullcodeline": "_setSSLError(\"Underlying socket connection gone\","
    },
    {
        "line": 44,
        "fullcodeline": "} else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {"
    },
    {
        "line": 65,
        "fullcodeline": "timeout = deadline - _PyTime_GetMonotonicClock();"
    },
    {
        "line": 68,
        "fullcodeline": "sockstate = PySSL_select(sock, 0, timeout);"
    },
    {
        "line": 69,
        "fullcodeline": "} else if (err.ssl == SSL_ERROR_WANT_WRITE) {"
    },
    {
        "line": 79,
        "fullcodeline": "} else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {"
    },
    {
        "line": 48,
        "fullcodeline": "} else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {"
    },
    {
        "line": 70,
        "fullcodeline": "sockstate = PySSL_select(sock, 1, timeout);"
    },
    {
        "line": 72,
        "fullcodeline": "sockstate = SOCKET_OPERATION_OK;"
    },
    {
        "line": 83,
        "fullcodeline": "} else if (sockstate == SOCKET_IS_NONBLOCKING) {"
    }
]