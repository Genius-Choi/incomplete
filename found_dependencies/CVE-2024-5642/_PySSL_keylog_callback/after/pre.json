[
    {
        "line": 4,
        "fullcodeline": "PySSLSocket *ssl_obj = NULL;  /* ssl._SSLSocket, borrowed ref */"
    },
    {
        "line": 6,
        "fullcodeline": "static PyThread_type_lock *lock = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "threadstate = PyGILState_Ensure();"
    },
    {
        "line": 10,
        "fullcodeline": "ssl_obj = (PySSLSocket *)SSL_get_app_data(ssl);"
    },
    {
        "line": 11,
        "fullcodeline": "assert(PySSLSocket_Check(ssl_obj));"
    },
    {
        "line": 33,
        "fullcodeline": "PyThread_acquire_lock(lock, 1);"
    },
    {
        "line": 34,
        "fullcodeline": "res = BIO_printf(ssl_obj->ctx->keylog_bio, \"%s\\n\", line);"
    },
    {
        "line": 35,
        "fullcodeline": "e = errno;"
    },
    {
        "line": 12,
        "fullcodeline": "if (ssl_obj->ctx->keylog_bio == NULL) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (lock == NULL) {"
    },
    {
        "line": 36,
        "fullcodeline": "(void)BIO_flush(ssl_obj->ctx->keylog_bio);"
    },
    {
        "line": 23,
        "fullcodeline": "lock = PyThread_allocate_lock();"
    },
    {
        "line": 40,
        "fullcodeline": "if (res == -1) {"
    },
    {
        "line": 42,
        "fullcodeline": "PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError,"
    },
    {
        "line": 24,
        "fullcodeline": "if (lock == NULL) {"
    },
    {
        "line": 25,
        "fullcodeline": "PyErr_SetString(PyExc_MemoryError, \"Unable to allocate lock\");"
    }
]