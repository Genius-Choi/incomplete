[
    {
        "line": 7,
        "fullcodeline": "int64 cross_count_total = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int64 max_cross_count = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "TF_RETURN_IF_ERROR(context->allocate_output("
    },
    {
        "line": 20,
        "fullcodeline": "TF_RETURN_IF_ERROR(context->allocate_output("
    },
    {
        "line": 22,
        "fullcodeline": "TF_RETURN_IF_ERROR(context->allocate_output(2, TensorShape({2}), shape_out));"
    },
    {
        "line": 25,
        "fullcodeline": "auto shape_vec = (*shape_out)->vec<int64>();"
    },
    {
        "line": 26,
        "fullcodeline": "shape_vec(0) = batch_size;"
    },
    {
        "line": 27,
        "fullcodeline": "shape_vec(1) = max_cross_count;"
    },
    {
        "line": 9,
        "fullcodeline": "for (int64 b = 0; b < batch_size; b++) {"
    },
    {
        "line": 29,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 11,
        "fullcodeline": "(*output_start_indices)[b] = cross_count_total;"
    },
    {
        "line": 12,
        "fullcodeline": "const auto cross_count = CrossCountByBatchIndex(columns, b);"
    },
    {
        "line": 13,
        "fullcodeline": "max_cross_count = std::max(max_cross_count, cross_count);"
    },
    {
        "line": 14,
        "fullcodeline": "cross_count_total += cross_count;"
    },
    {
        "line": 19,
        "fullcodeline": "0, TensorShape({cross_count_total, 2}), indices_out));"
    },
    {
        "line": 21,
        "fullcodeline": "1, TensorShape({cross_count_total}), values_out));"
    }
]