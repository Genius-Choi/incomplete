[
    {
        "line": 5,
        "fullcodeline": "path = cleanup_path(path)"
    },
    {
        "line": 10,
        "fullcodeline": "raw_data = pad.db.load_raw_data(path, cls=OrderedDict, alt=alt, fallback=False)"
    },
    {
        "line": 11,
        "fullcodeline": "raw_data_fallback = None"
    },
    {
        "line": 20,
        "fullcodeline": "id = posixpath.basename(path)"
    },
    {
        "line": 24,
        "fullcodeline": "record = None"
    },
    {
        "line": 25,
        "fullcodeline": "exists = raw_data is not None or raw_data_fallback is not None"
    },
    {
        "line": 3,
        "fullcodeline": "if not _is_valid_path(path):"
    },
    {
        "line": 7,
        "fullcodeline": "if alt != PRIMARY_ALT and not pad.db.config.is_valid_alternative(alt):"
    },
    {
        "line": 12,
        "fullcodeline": "if alt != PRIMARY_ALT:"
    },
    {
        "line": 21,
        "fullcodeline": "if not is_valid_id(id):"
    },
    {
        "line": 26,
        "fullcodeline": "if raw_data is None:"
    },
    {
        "line": 29,
        "fullcodeline": "if is_attachment is None:"
    },
    {
        "line": 56,
        "fullcodeline": "for key in implied_keys:"
    },
    {
        "line": 61,
        "fullcodeline": "return EditorSession("
    },
    {
        "line": 4,
        "fullcodeline": "raise BadEdit(\"Invalid path\")"
    },
    {
        "line": 8,
        "fullcodeline": "raise BadEdit(\"Attempted to edit an invalid alternative (%s)\" % alt)"
    },
    {
        "line": 13,
        "fullcodeline": "raw_data_fallback = pad.db.load_raw_data(path, cls=OrderedDict)"
    },
    {
        "line": 14,
        "fullcodeline": "all_data = OrderedDict()"
    },
    {
        "line": 15,
        "fullcodeline": "all_data.update(raw_data_fallback or ())"
    },
    {
        "line": 16,
        "fullcodeline": "all_data.update(raw_data or ())"
    },
    {
        "line": 18,
        "fullcodeline": "all_data = raw_data"
    },
    {
        "line": 22,
        "fullcodeline": "raise BadEdit(\"Invalid ID\")"
    },
    {
        "line": 27,
        "fullcodeline": "raw_data = OrderedDict()"
    },
    {
        "line": 46,
        "fullcodeline": "datamodel = pad.db.get_datamodel_for_raw_data(all_data, pad)"
    },
    {
        "line": 54,
        "fullcodeline": "record = pad.instance_from_data(dict(all_data), datamodel)"
    },
    {
        "line": 64,
        "fullcodeline": "str(path),"
    },
    {
        "line": 30,
        "fullcodeline": "if not exists:"
    },
    {
        "line": 34,
        "fullcodeline": "elif bool(all_data.get(\"_attachment_for\")) != is_attachment:"
    },
    {
        "line": 42,
        "fullcodeline": "if datamodel is not None:"
    },
    {
        "line": 48,
        "fullcodeline": "if datamodel is None:"
    },
    {
        "line": 57,
        "fullcodeline": "raw_data.pop(key, None)"
    },
    {
        "line": 31,
        "fullcodeline": "is_attachment = False"
    },
    {
        "line": 33,
        "fullcodeline": "is_attachment = bool(all_data.get(\"_attachment_for\"))"
    },
    {
        "line": 35,
        "fullcodeline": "raise BadEdit("
    },
    {
        "line": 43,
        "fullcodeline": "raise BadEdit("
    },
    {
        "line": 49,
        "fullcodeline": "datamodel = pad.db.get_implied_datamodel(path, is_attachment, pad)"
    },
    {
        "line": 50,
        "fullcodeline": "elif isinstance(datamodel, str):"
    },
    {
        "line": 59,
        "fullcodeline": "raw_data_fallback.pop(key, None)"
    },
    {
        "line": 36,
        "fullcodeline": "\"The attachment flag passed is conflicting with the \""
    }
]