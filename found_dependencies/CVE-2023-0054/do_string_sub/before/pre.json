[
    {
        "line": 17,
        "fullcodeline": "char_u\t*zero_width = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "save_cpo = p_cpo;"
    },
    {
        "line": 21,
        "fullcodeline": "p_cpo = empty_option;"
    },
    {
        "line": 23,
        "fullcodeline": "ga_init2(&ga, 1, 200);"
    },
    {
        "line": 25,
        "fullcodeline": "do_all = (flags[0] == 'g');"
    },
    {
        "line": 27,
        "fullcodeline": "regmatch.rm_ic = p_ic;"
    },
    {
        "line": 28,
        "fullcodeline": "regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);"
    },
    {
        "line": 87,
        "fullcodeline": "ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);"
    },
    {
        "line": 88,
        "fullcodeline": "ga_clear(&ga);"
    },
    {
        "line": 29,
        "fullcodeline": "if (regmatch.regprog != NULL)"
    },
    {
        "line": 89,
        "fullcodeline": "if (p_cpo == empty_option)"
    },
    {
        "line": 31,
        "fullcodeline": "tail = str;"
    },
    {
        "line": 32,
        "fullcodeline": "end = str + STRLEN(str);"
    },
    {
        "line": 84,
        "fullcodeline": "vim_regfree(regmatch.regprog);"
    },
    {
        "line": 90,
        "fullcodeline": "p_cpo = save_cpo;"
    },
    {
        "line": 33,
        "fullcodeline": "while (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))"
    },
    {
        "line": 81,
        "fullcodeline": "if (ga.ga_data != NULL)"
    },
    {
        "line": 98,
        "fullcodeline": "free_string_option(save_cpo);"
    },
    {
        "line": 58,
        "fullcodeline": "sublen = vim_regsub(&regmatch, sub, expr, tail, 0, REGSUB_MAGIC);"
    },
    {
        "line": 67,
        "fullcodeline": "i = (int)(regmatch.startp[0] - tail);"
    },
    {
        "line": 68,
        "fullcodeline": "mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);"
    },
    {
        "line": 70,
        "fullcodeline": "(void)vim_regsub(&regmatch, sub, expr,"
    },
    {
        "line": 73,
        "fullcodeline": "ga.ga_len += i + sublen - 1;"
    },
    {
        "line": 74,
        "fullcodeline": "tail = regmatch.endp[0];"
    },
    {
        "line": 82,
        "fullcodeline": "STRCPY((char *)ga.ga_data + ga.ga_len, tail);"
    },
    {
        "line": 96,
        "fullcodeline": "if (*p_cpo == NUL)"
    },
    {
        "line": 36,
        "fullcodeline": "if (regmatch.startp[0] == regmatch.endp[0])"
    },
    {
        "line": 59,
        "fullcodeline": "if (ga_grow(&ga, (int)((end - tail) + sublen -"
    },
    {
        "line": 75,
        "fullcodeline": "if (*tail == NUL)"
    },
    {
        "line": 77,
        "fullcodeline": "if (!do_all)"
    },
    {
        "line": 97,
        "fullcodeline": "set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);"
    },
    {
        "line": 48,
        "fullcodeline": "zero_width = regmatch.startp[0];"
    },
    {
        "line": 62,
        "fullcodeline": "ga_clear(&ga);"
    },
    {
        "line": 71,
        "fullcodeline": "(char_u *)ga.ga_data + ga.ga_len + i, sublen,"
    },
    {
        "line": 72,
        "fullcodeline": "REGSUB_COPY | REGSUB_MAGIC);"
    },
    {
        "line": 38,
        "fullcodeline": "if (zero_width == regmatch.startp[0])"
    },
    {
        "line": 41,
        "fullcodeline": "i = mb_ptr2len(tail);"
    },
    {
        "line": 42,
        "fullcodeline": "mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,"
    },
    {
        "line": 44,
        "fullcodeline": "ga.ga_len += i;"
    },
    {
        "line": 45,
        "fullcodeline": "tail += i;"
    },
    {
        "line": 60,
        "fullcodeline": "(regmatch.endp[0] - regmatch.startp[0]))) == FAIL)"
    }
]