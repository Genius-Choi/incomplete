[
    {
        "line": 6,
        "fullcodeline": "struct request *flush_rq = fq->flush_rq;"
    },
    {
        "line": 22,
        "fullcodeline": "fq->flush_pending_idx ^= 1;"
    },
    {
        "line": 24,
        "fullcodeline": "blk_rq_init(q, flush_rq);"
    },
    {
        "line": 42,
        "fullcodeline": "flush_rq->cmd_type = REQ_TYPE_FS;"
    },
    {
        "line": 43,
        "fullcodeline": "flush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;"
    },
    {
        "line": 44,
        "fullcodeline": "flush_rq->rq_disk = first_rq->rq_disk;"
    },
    {
        "line": 45,
        "fullcodeline": "flush_rq->end_io = flush_end_io;"
    },
    {
        "line": 9,
        "fullcodeline": "if (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))"
    },
    {
        "line": 13,
        "fullcodeline": "if (!list_empty(&fq->flush_data_in_flight) &&"
    },
    {
        "line": 47,
        "fullcodeline": "return blk_flush_queue_rq(flush_rq, false);"
    },
    {
        "line": 14,
        "fullcodeline": "time_before(jiffies,"
    },
    {
        "line": 36,
        "fullcodeline": "fq->orig_rq = first_rq;"
    },
    {
        "line": 38,
        "fullcodeline": "hctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);"
    },
    {
        "line": 39,
        "fullcodeline": "blk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);"
    },
    {
        "line": 15,
        "fullcodeline": "fq->flush_pending_since + FLUSH_PENDING_TIMEOUT))"
    }
]