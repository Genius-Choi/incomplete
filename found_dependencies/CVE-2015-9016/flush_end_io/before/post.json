[
    {
        "line": 3,
        "fullcodeline": "struct request_queue *q = flush_rq->q;"
    },
    {
        "line": 5,
        "fullcodeline": "bool queued = false;"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned long flags = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "struct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);"
    },
    {
        "line": 16,
        "fullcodeline": "BUG_ON(fq->flush_pending_idx == fq->flush_running_idx);"
    },
    {
        "line": 19,
        "fullcodeline": "fq->flush_running_idx ^= 1;"
    },
    {
        "line": 25,
        "fullcodeline": "list_for_each_entry_safe(rq, n, running, flush.list) {"
    },
    {
        "line": 47,
        "fullcodeline": "fq->flush_queue_delayed = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "if (!q->mq_ops)"
    },
    {
        "line": 26,
        "fullcodeline": "unsigned int seq = blk_flush_cur_seq(rq);"
    },
    {
        "line": 28,
        "fullcodeline": "BUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);"
    },
    {
        "line": 29,
        "fullcodeline": "queued |= blk_flush_complete_seq(rq, fq, seq, error);"
    },
    {
        "line": 43,
        "fullcodeline": "if (queued || fq->flush_queue_delayed) {"
    },
    {
        "line": 11,
        "fullcodeline": "spin_lock_irqsave(&fq->mq_flush_lock, flags);"
    },
    {
        "line": 12,
        "fullcodeline": "flush_rq->tag = -1;"
    },
    {
        "line": 22,
        "fullcodeline": "elv_completed_request(q, flush_rq);"
    },
    {
        "line": 44,
        "fullcodeline": "WARN_ON(q->mq_ops);"
    },
    {
        "line": 45,
        "fullcodeline": "blk_run_queue_async(q);"
    },
    {
        "line": 49,
        "fullcodeline": "spin_unlock_irqrestore(&fq->mq_flush_lock, flags);"
    }
]