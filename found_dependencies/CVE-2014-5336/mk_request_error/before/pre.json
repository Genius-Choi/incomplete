[
    {
        "line": 4,
        "fullcodeline": "mk_ptr_t message, *page = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "mk_header_set_http_status(sr, http_status);"
    },
    {
        "line": 50,
        "fullcodeline": "mk_ptr_reset(&message);"
    },
    {
        "line": 117,
        "fullcodeline": "sr->headers.location = NULL;"
    },
    {
        "line": 118,
        "fullcodeline": "sr->headers.cgi = SH_NOCGI;"
    },
    {
        "line": 129,
        "fullcodeline": "mk_header_send(cs->socket, cs, sr);"
    },
    {
        "line": 140,
        "fullcodeline": "mk_server_cork_flag(cs->socket, TCP_CORK_OFF);"
    },
    {
        "line": 15,
        "fullcodeline": "if (http_status != MK_CLIENT_LENGTH_REQUIRED &&"
    },
    {
        "line": 120,
        "fullcodeline": "sr->headers.last_modified = -1;"
    },
    {
        "line": 122,
        "fullcodeline": "if (!page) {"
    },
    {
        "line": 17,
        "fullcodeline": "http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {"
    },
    {
        "line": 20,
        "fullcodeline": "mk_list_foreach(head, &sr->host_conf->error_pages) {"
    },
    {
        "line": 54,
        "fullcodeline": "page = mk_request_set_default_page(\"Bad Request\","
    },
    {
        "line": 60,
        "fullcodeline": "page = mk_request_set_default_page(\"Forbidden\","
    },
    {
        "line": 68,
        "fullcodeline": "page = mk_request_set_default_page(\"Not Found\","
    },
    {
        "line": 77,
        "fullcodeline": "page = mk_request_set_default_page(\"Entity too large\","
    },
    {
        "line": 84,
        "fullcodeline": "page = mk_request_set_default_page(\"Method Not Allowed\","
    },
    {
        "line": 94,
        "fullcodeline": "page = mk_request_set_default_page(\"Method Not Implemented\","
    },
    {
        "line": 100,
        "fullcodeline": "page = mk_request_set_default_page(\"Internal Server Error\","
    },
    {
        "line": 106,
        "fullcodeline": "mk_ptr_reset(&message);"
    },
    {
        "line": 107,
        "fullcodeline": "page = mk_request_set_default_page(\"HTTP Version Not Supported\","
    },
    {
        "line": 135,
        "fullcodeline": "mk_ptr_free(page);"
    },
    {
        "line": 16,
        "fullcodeline": "http_status != MK_CLIENT_BAD_REQUEST &&"
    },
    {
        "line": 27,
        "fullcodeline": "ret = mk_file_get_info(entry->real_path, &finfo);"
    },
    {
        "line": 33,
        "fullcodeline": "fd = open(entry->real_path, config->open_flags);"
    },
    {
        "line": 38,
        "fullcodeline": "sr->fd_file = fd;"
    },
    {
        "line": 39,
        "fullcodeline": "sr->bytes_to_send = finfo.size;"
    },
    {
        "line": 40,
        "fullcodeline": "sr->headers.content_length = finfo.size;"
    },
    {
        "line": 41,
        "fullcodeline": "sr->headers.real_length    = finfo.size;"
    },
    {
        "line": 43,
        "fullcodeline": "memcpy(&sr->file_info, &finfo, sizeof(struct file_info));"
    },
    {
        "line": 45,
        "fullcodeline": "mk_header_send(cs->socket, cs, sr);"
    },
    {
        "line": 132,
        "fullcodeline": "if (sr->method != MK_HTTP_METHOD_HEAD)"
    },
    {
        "line": 22,
        "fullcodeline": "if (entry->status != http_status) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (ret == -1) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (fd == -1) {"
    },
    {
        "line": 46,
        "fullcodeline": "return mk_http_send_file(cs, sr);"
    },
    {
        "line": 133,
        "fullcodeline": "mk_socket_send(cs->socket, page->data, page->len);"
    }
]