[
    {
        "line": 10,
        "fullcodeline": "struct iovec iov[BLOCKIF_IOV_MAX + 2];"
    },
    {
        "line": 11,
        "fullcodeline": "uint16_t idx, flags[BLOCKIF_IOV_MAX + 2];"
    },
    {
        "line": 13,
        "fullcodeline": "n = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);"
    },
    {
        "line": 23,
        "fullcodeline": "assert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2);"
    },
    {
        "line": 26,
        "fullcodeline": "assert((flags[0] & VRING_DESC_F_WRITE) == 0);"
    },
    {
        "line": 27,
        "fullcodeline": "assert(iov[0].iov_len == sizeof(struct virtio_blk_hdr));"
    },
    {
        "line": 29,
        "fullcodeline": "memcpy(&io->io_req.br_iov, &iov[1],"
    },
    {
        "line": 31,
        "fullcodeline": "io->io_req.br_iovcnt = n - 2;"
    },
    {
        "line": 32,
        "fullcodeline": "io->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE);"
    },
    {
        "line": 34,
        "fullcodeline": "assert(iov[n].iov_len == 1);"
    },
    {
        "line": 35,
        "fullcodeline": "assert(flags[n] & VRING_DESC_F_WRITE);"
    },
    {
        "line": 42,
        "fullcodeline": "type = vbh->vbh_type & ~VBH_FLAG_BARRIER;"
    },
    {
        "line": 43,
        "fullcodeline": "expectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD);"
    },
    {
        "line": 44,
        "fullcodeline": "iolen = 0;"
    },
    {
        "line": 55,
        "fullcodeline": "io->io_req.br_resid = iolen;"
    },
    {
        "line": 57,
        "fullcodeline": "DPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\","
    },
    {
        "line": 95,
        "fullcodeline": "assert(err == 0);"
    },
    {
        "line": 30,
        "fullcodeline": "sizeof(struct iovec) * ((size_t)n - 2));"
    },
    {
        "line": 45,
        "fullcodeline": "for (i = 1; i < n; i++) {"
    },
    {
        "line": 52,
        "fullcodeline": "assert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro);"
    },
    {
        "line": 53,
        "fullcodeline": "iolen += iov[i].iov_len;"
    },
    {
        "line": 62,
        "fullcodeline": "err = blockif_read(sc->bc, &io->io_req);"
    },
    {
        "line": 65,
        "fullcodeline": "err = blockif_write(sc->bc, &io->io_req);"
    },
    {
        "line": 70,
        "fullcodeline": "assert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes));"
    },
    {
        "line": 71,
        "fullcodeline": "assert(n == 2);"
    },
    {
        "line": 73,
        "fullcodeline": "io->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;"
    },
    {
        "line": 74,
        "fullcodeline": "io->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE;"
    },
    {
        "line": 75,
        "fullcodeline": "err = blockif_delete(sc->bc, &io->io_req);"
    },
    {
        "line": 79,
        "fullcodeline": "err = blockif_flush(sc->bc, &io->io_req);"
    },
    {
        "line": 84,
        "fullcodeline": "memset(iov[1].iov_base, 0, iov[1].iov_len);"
    },
    {
        "line": 85,
        "fullcodeline": "strncpy(iov[1].iov_base, sc->vbsc_ident,"
    },
    {
        "line": 88,
        "fullcodeline": "pci_vtblk_done_locked(&io->io_req, 0);"
    },
    {
        "line": 92,
        "fullcodeline": "pci_vtblk_done_locked(&io->io_req, EOPNOTSUPP);"
    },
    {
        "line": 33,
        "fullcodeline": "io->io_status = iov[--n].iov_base;"
    },
    {
        "line": 58,
        "fullcodeline": "print_vbh_op(type), iolen, i - 1));"
    },
    {
        "line": 86,
        "fullcodeline": "MIN(iov[1].iov_len, sizeof(sc->vbsc_ident)));"
    }
]