[
    {
        "line": 4,
        "fullcodeline": "struct dentry *dir = nd->path.dentry;"
    },
    {
        "line": 5,
        "fullcodeline": "kuid_t dir_uid = dir->d_inode->i_uid;"
    },
    {
        "line": 6,
        "fullcodeline": "umode_t dir_mode = dir->d_inode->i_mode;"
    },
    {
        "line": 7,
        "fullcodeline": "int open_flag = op->open_flag;"
    },
    {
        "line": 8,
        "fullcodeline": "bool will_truncate = (open_flag & O_TRUNC) != 0;"
    },
    {
        "line": 9,
        "fullcodeline": "bool got_write = false;"
    },
    {
        "line": 10,
        "fullcodeline": "int acc_mode = op->acc_mode;"
    },
    {
        "line": 16,
        "fullcodeline": "nd->flags &= ~LOOKUP_PARENT;"
    },
    {
        "line": 17,
        "fullcodeline": "nd->flags |= op->intent;"
    },
    {
        "line": 70,
        "fullcodeline": "error = lookup_open(nd, &path, file, op, got_write);"
    },
    {
        "line": 107,
        "fullcodeline": "error = follow_managed(&path, nd);"
    },
    {
        "line": 114,
        "fullcodeline": "audit_inode(nd->name, path.dentry, 0);"
    },
    {
        "line": 121,
        "fullcodeline": "seq = 0;\t/* out of RCU mode, so the value doesn't matter */"
    },
    {
        "line": 122,
        "fullcodeline": "inode = d_backing_inode(path.dentry);"
    },
    {
        "line": 124,
        "fullcodeline": "error = step_into(nd, &path, 0, inode, seq);"
    },
    {
        "line": 129,
        "fullcodeline": "error = complete_walk(nd);"
    },
    {
        "line": 132,
        "fullcodeline": "audit_inode(nd->name, nd->path.dentry, 0);"
    },
    {
        "line": 142,
        "fullcodeline": "error = -ENOTDIR;"
    },
    {
        "line": 155,
        "fullcodeline": "error = may_open(&nd->path, acc_mode, open_flag);"
    },
    {
        "line": 159,
        "fullcodeline": "error = vfs_open(&nd->path, file);"
    },
    {
        "line": 163,
        "fullcodeline": "error = ima_file_check(file, op->acc_mode);"
    },
    {
        "line": 19,
        "fullcodeline": "if (nd->last_type != LAST_NORM) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (open_flag & O_CREAT)"
    },
    {
        "line": 71,
        "fullcodeline": "if (open_flag & O_CREAT)"
    },
    {
        "line": 79,
        "fullcodeline": "if (file->f_mode & FMODE_OPENED) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (file->f_mode & FMODE_CREATED) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (unlikely(error))"
    },
    {
        "line": 133,
        "fullcodeline": "if (open_flag & O_CREAT) {"
    },
    {
        "line": 158,
        "fullcodeline": "BUG_ON(file->f_mode & FMODE_OPENED); /* once it's opened, it's opened */"
    },
    {
        "line": 20,
        "fullcodeline": "error = handle_dots(nd, nd->last_type);"
    },
    {
        "line": 26,
        "fullcodeline": "if (!(open_flag & O_CREAT)) {"
    },
    {
        "line": 30,
        "fullcodeline": "error = lookup_fast(nd, &path, &inode, &seq);"
    },
    {
        "line": 57,
        "fullcodeline": "error = mnt_want_write(nd->path.mnt);"
    },
    {
        "line": 67,
        "fullcodeline": "inode_lock(dir->d_inode);"
    },
    {
        "line": 90,
        "fullcodeline": "open_flag &= ~O_TRUNC;"
    },
    {
        "line": 91,
        "fullcodeline": "will_truncate = false;"
    },
    {
        "line": 92,
        "fullcodeline": "acc_mode = 0;"
    },
    {
        "line": 93,
        "fullcodeline": "path_to_nameidata(&path, nd);"
    },
    {
        "line": 108,
        "fullcodeline": "if (unlikely(error < 0))"
    },
    {
        "line": 116,
        "fullcodeline": "if (unlikely((open_flag & (O_EXCL | O_CREAT)) == (O_EXCL | O_CREAT))) {"
    },
    {
        "line": 134,
        "fullcodeline": "error = -EISDIR;"
    },
    {
        "line": 137,
        "fullcodeline": "error = may_create_in_sticky(dir_mode, dir_uid,"
    },
    {
        "line": 143,
        "fullcodeline": "if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))"
    },
    {
        "line": 145,
        "fullcodeline": "if (!d_is_reg(nd->path.dentry))"
    },
    {
        "line": 146,
        "fullcodeline": "will_truncate = false;"
    },
    {
        "line": 149,
        "fullcodeline": "error = mnt_want_write(nd->path.mnt);"
    },
    {
        "line": 164,
        "fullcodeline": "if (!error && will_truncate)"
    },
    {
        "line": 165,
        "fullcodeline": "error = handle_truncate(file);"
    },
    {
        "line": 167,
        "fullcodeline": "if (unlikely(error > 0)) {"
    },
    {
        "line": 169,
        "fullcodeline": "error = -EINVAL;"
    },
    {
        "line": 21,
        "fullcodeline": "if (unlikely(error))"
    },
    {
        "line": 34,
        "fullcodeline": "if (error < 0)"
    },
    {
        "line": 37,
        "fullcodeline": "BUG_ON(nd->inode != dir->d_inode);"
    },
    {
        "line": 38,
        "fullcodeline": "BUG_ON(nd->flags & LOOKUP_RCU);"
    },
    {
        "line": 46,
        "fullcodeline": "error = complete_walk(nd);"
    },
    {
        "line": 50,
        "fullcodeline": "audit_inode(nd->name, dir, AUDIT_INODE_PARENT);"
    },
    {
        "line": 69,
        "fullcodeline": "inode_lock_shared(dir->d_inode);"
    },
    {
        "line": 118,
        "fullcodeline": "return -EEXIST;"
    },
    {
        "line": 135,
        "fullcodeline": "if (d_is_dir(nd->path.dentry))"
    },
    {
        "line": 139,
        "fullcodeline": "if (unlikely(error))"
    },
    {
        "line": 28,
        "fullcodeline": "nd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;"
    },
    {
        "line": 31,
        "fullcodeline": "if (likely(error > 0))"
    },
    {
        "line": 59,
        "fullcodeline": "got_write = true;"
    },
    {
        "line": 80,
        "fullcodeline": "if ((file->f_mode & FMODE_CREATED) ||"
    },
    {
        "line": 81,
        "fullcodeline": "!S_ISREG(file_inode(file)->i_mode))"
    },
    {
        "line": 82,
        "fullcodeline": "will_truncate = false;"
    },
    {
        "line": 138,
        "fullcodeline": "d_backing_inode(nd->path.dentry));"
    },
    {
        "line": 53,
        "fullcodeline": "return -EISDIR;"
    }
]