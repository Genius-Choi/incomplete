[
    {
        "line": 6,
        "fullcodeline": "struct match_attr *res = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "struct strbuf pattern = STRBUF_INIT;"
    },
    {
        "line": 10,
        "fullcodeline": "cp = line + strspn(line, blank);"
    },
    {
        "line": 13,
        "fullcodeline": "name = cp;"
    },
    {
        "line": 47,
        "fullcodeline": "states += strspn(states, blank);"
    },
    {
        "line": 56,
        "fullcodeline": "res = xcalloc(1, st_add3(sizeof(*res),"
    },
    {
        "line": 75,
        "fullcodeline": "res->is_macro = is_macro;"
    },
    {
        "line": 76,
        "fullcodeline": "res->num_attr = num_attr;"
    },
    {
        "line": 83,
        "fullcodeline": "strbuf_release(&pattern);"
    },
    {
        "line": 87,
        "fullcodeline": "strbuf_release(&pattern);"
    },
    {
        "line": 88,
        "fullcodeline": "free(res);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!*cp || *cp == '#')"
    },
    {
        "line": 15,
        "fullcodeline": "if (strlen(line) >= ATTR_MAX_LINE_LENGTH) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (*cp == '\"' && !unquote_c_style(&pattern, name, &states)) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (strlen(ATTRIBUTE_MACRO_PREFIX) < namelen &&"
    },
    {
        "line": 50,
        "fullcodeline": "for (cp = states, num_attr = 0; *cp; num_attr++) {"
    },
    {
        "line": 79,
        "fullcodeline": "for (cp = states, i = 0; *cp; i++) {"
    },
    {
        "line": 16,
        "fullcodeline": "warning(_(\"ignoring overly long attributes line %d\"), lineno);"
    },
    {
        "line": 21,
        "fullcodeline": "name = pattern.buf;"
    },
    {
        "line": 22,
        "fullcodeline": "namelen = pattern.len;"
    },
    {
        "line": 29,
        "fullcodeline": "starts_with(name, ATTRIBUTE_MACRO_PREFIX)) {"
    },
    {
        "line": 35,
        "fullcodeline": "is_macro = 1;"
    },
    {
        "line": 36,
        "fullcodeline": "name += strlen(ATTRIBUTE_MACRO_PREFIX);"
    },
    {
        "line": 37,
        "fullcodeline": "name += strspn(name, blank);"
    },
    {
        "line": 38,
        "fullcodeline": "namelen = strcspn(name, blank);"
    },
    {
        "line": 51,
        "fullcodeline": "cp = parse_attr(src, lineno, cp, NULL);"
    },
    {
        "line": 60,
        "fullcodeline": "res->u.attr = git_attr_internal(name, namelen);"
    },
    {
        "line": 80,
        "fullcodeline": "cp = parse_attr(src, lineno, cp, &(res->state[i]));"
    },
    {
        "line": 24,
        "fullcodeline": "namelen = strcspn(name, blank);"
    },
    {
        "line": 25,
        "fullcodeline": "states = name + namelen;"
    },
    {
        "line": 30,
        "fullcodeline": "if (!(flags & READ_ATTR_MACRO_OK)) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (!attr_name_valid(name, namelen)) {"
    },
    {
        "line": 45,
        "fullcodeline": "is_macro = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "if (!cp)"
    },
    {
        "line": 57,
        "fullcodeline": "st_mult(sizeof(struct attr_state), num_attr),"
    },
    {
        "line": 58,
        "fullcodeline": "is_macro ? 0 : namelen + 1));"
    },
    {
        "line": 63,
        "fullcodeline": "memcpy(p, name, namelen);"
    },
    {
        "line": 64,
        "fullcodeline": "res->u.pat.pattern = p;"
    },
    {
        "line": 65,
        "fullcodeline": "parse_path_pattern(&res->u.pat.pattern,"
    },
    {
        "line": 31,
        "fullcodeline": "fprintf_ln(stderr, _(\"%s not allowed: %s:%d\"),"
    },
    {
        "line": 40,
        "fullcodeline": "report_invalid_attr(name, namelen, src, lineno);"
    },
    {
        "line": 69,
        "fullcodeline": "if (res->u.pat.flags & PATTERN_FLAG_NEGATIVE) {"
    },
    {
        "line": 70,
        "fullcodeline": "warning(_(\"Negative patterns are ignored in git attributes\\n\""
    }
]