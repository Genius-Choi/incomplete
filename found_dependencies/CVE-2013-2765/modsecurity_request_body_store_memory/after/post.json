[
    {
        "line": 4,
        "fullcodeline": "*error_msg = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "if ((msr->msc_reqbody_spilltodisk)"
    },
    {
        "line": 59,
        "fullcodeline": "bucket_offset = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "bucket_left = length;"
    },
    {
        "line": 120,
        "fullcodeline": "msr->msc_reqbody_length += length;"
    },
    {
        "line": 9,
        "fullcodeline": "&& (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned int disklen = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "msr_log(msr, 4, \"Input filter: Request too large to store in memory, switching to disk.\");"
    },
    {
        "line": 23,
        "fullcodeline": "msr->msc_reqbody_storage = MSC_REQBODY_DISK;"
    },
    {
        "line": 44,
        "fullcodeline": "msr->msc_reqbody_chunks = NULL;"
    },
    {
        "line": 45,
        "fullcodeline": "apr_pool_clear(msr->msc_reqbody_mp);"
    },
    {
        "line": 47,
        "fullcodeline": "msr_log(msr, 4, \"Input filter: Wrote %u bytes from memory to disk.\", disklen);"
    },
    {
        "line": 70,
        "fullcodeline": "while(bucket_left > 0) {"
    },
    {
        "line": 8,
        "fullcodeline": "&& (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_ON)"
    },
    {
        "line": 24,
        "fullcodeline": "if (modsecurity_request_body_start_init(msr, error_msg) < 0) return -1;"
    },
    {
        "line": 28,
        "fullcodeline": "for(i = 0; i < msr->msc_reqbody_chunks->nelts; i++) {"
    },
    {
        "line": 50,
        "fullcodeline": "return modsecurity_request_body_store_disk(msr, data, length, error_msg);"
    },
    {
        "line": 29,
        "fullcodeline": "disklen += chunks[i]->length;"
    },
    {
        "line": 35,
        "fullcodeline": "free(chunks[i]->data);"
    },
    {
        "line": 36,
        "fullcodeline": "chunks[i]->data = NULL;"
    },
    {
        "line": 72,
        "fullcodeline": "if (msr->msc_reqbody_chunk_current == NULL) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (bucket_left < (CHUNK_CAPACITY - msr->msc_reqbody_chunk_current->length)) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (modsecurity_request_body_store_disk(msr, chunks[i]->data, chunks[i]->length, error_msg) < 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "msr->msc_reqbody_chunk_current = (msc_data_chunk *)"
    },
    {
        "line": 81,
        "fullcodeline": "msr->msc_reqbody_chunk_current->data = malloc(CHUNK_CAPACITY);"
    },
    {
        "line": 88,
        "fullcodeline": "msr->msc_reqbody_chunk_current->length = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "msr->msc_reqbody_chunk_current->is_permanent = 1;"
    },
    {
        "line": 91,
        "fullcodeline": "*(const msc_data_chunk **)apr_array_push(msr->msc_reqbody_chunks)"
    },
    {
        "line": 97,
        "fullcodeline": "memcpy(msr->msc_reqbody_chunk_current->data +"
    },
    {
        "line": 99,
        "fullcodeline": "msr->msc_reqbody_chunk_current->length += bucket_left;"
    },
    {
        "line": 100,
        "fullcodeline": "bucket_left = 0;"
    },
    {
        "line": 75,
        "fullcodeline": "if (msr->msc_reqbody_chunk_current == NULL) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (msr->msc_reqbody_chunk_current->data == NULL) {"
    },
    {
        "line": 98,
        "fullcodeline": "msr->msc_reqbody_chunk_current->length, data + bucket_offset, bucket_left);"
    },
    {
        "line": 103,
        "fullcodeline": "unsigned long int copy_length = CHUNK_CAPACITY -"
    },
    {
        "line": 106,
        "fullcodeline": "memcpy(msr->msc_reqbody_chunk_current->data +"
    },
    {
        "line": 108,
        "fullcodeline": "bucket_offset += copy_length;"
    },
    {
        "line": 109,
        "fullcodeline": "bucket_left -= copy_length;"
    },
    {
        "line": 110,
        "fullcodeline": "msr->msc_reqbody_chunk_current->length += copy_length;"
    },
    {
        "line": 116,
        "fullcodeline": "msr->msc_reqbody_chunk_current = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "return -1;"
    },
    {
        "line": 74,
        "fullcodeline": "apr_pcalloc(msr->msc_reqbody_mp, sizeof(msc_data_chunk));"
    },
    {
        "line": 76,
        "fullcodeline": "*error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %lu bytes \""
    },
    {
        "line": 83,
        "fullcodeline": "*error_msg = apr_psprintf(msr->mp, \"Input filter: Failed to allocate %d bytes \""
    },
    {
        "line": 107,
        "fullcodeline": "msr->msc_reqbody_chunk_current->length, data + bucket_offset, copy_length);"
    },
    {
        "line": 78,
        "fullcodeline": "return -1;"
    },
    {
        "line": 85,
        "fullcodeline": "return -1;"
    }
]