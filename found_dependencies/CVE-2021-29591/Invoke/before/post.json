[
    {
        "line": 7,
        "fullcodeline": "TfLiteStatus status = kTfLiteOk;"
    },
    {
        "line": 15,
        "fullcodeline": "TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"Invoke\");"
    },
    {
        "line": 2,
        "fullcodeline": "if (!consistent_) {"
    },
    {
        "line": 8,
        "fullcodeline": "if (state_ == kStateUninvokable) {"
    },
    {
        "line": 22,
        "fullcodeline": "execution_plan_index < execution_plan_.size(); execution_plan_index++) {"
    },
    {
        "line": 3,
        "fullcodeline": "ReportError(\"Invoke called on model that is not consistent.\");"
    },
    {
        "line": 9,
        "fullcodeline": "ReportError(\"Invoke called on model that is not ready.\");"
    },
    {
        "line": 21,
        "fullcodeline": "for (int execution_plan_index = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "int node_index = execution_plan_[execution_plan_index];"
    },
    {
        "line": 33,
        "fullcodeline": "const char* op_name = nullptr;"
    },
    {
        "line": 35,
        "fullcodeline": "TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);"
    },
    {
        "line": 75,
        "fullcodeline": "EnsureTensorsVectorCapacity();"
    },
    {
        "line": 76,
        "fullcodeline": "tensor_resized_since_op_invoke_ = false;"
    },
    {
        "line": 23,
        "fullcodeline": "if (execution_plan_index == next_execution_plan_index_to_prepare_) {"
    },
    {
        "line": 37,
        "fullcodeline": "for (int i = 0; i < node.inputs->size; ++i) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (check_cancelled_func_ != nullptr &&"
    },
    {
        "line": 77,
        "fullcodeline": "if (OpInvoke(registration, &node) != kTfLiteOk) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (tensor_resized_since_op_invoke_ &&"
    },
    {
        "line": 11,
        "fullcodeline": "} else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {"
    },
    {
        "line": 25,
        "fullcodeline": "TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >="
    },
    {
        "line": 34,
        "fullcodeline": "if (profiler_) op_name = GetTFLiteOpName(registration);"
    },
    {
        "line": 70,
        "fullcodeline": "check_cancelled_func_(cancellation_data_)) {"
    },
    {
        "line": 71,
        "fullcodeline": "ReportError(\"Client requested cancel during Invoke()\");"
    },
    {
        "line": 85,
        "fullcodeline": "HasDynamicTensor(context_, node.outputs)) {"
    },
    {
        "line": 86,
        "fullcodeline": "next_execution_plan_index_to_prepare_ = execution_plan_index + 1;"
    },
    {
        "line": 12,
        "fullcodeline": "ReportError(\"Non-persistent memory is not available.\");"
    },
    {
        "line": 39,
        "fullcodeline": "if (tensor_index == kTfLiteOptionalTensor) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (tensor->delegate && tensor->delegate != node.delegate &&"
    },
    {
        "line": 47,
        "fullcodeline": "if (tensor->data.raw == nullptr && tensor->bytes > 0) {"
    },
    {
        "line": 78,
        "fullcodeline": "return ReportOpError(&context_, node, registration, node_index,"
    },
    {
        "line": 91,
        "fullcodeline": "if (next_execution_plan_index_to_plan_allocation_ >"
    },
    {
        "line": 45,
        "fullcodeline": "TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));"
    },
    {
        "line": 93,
        "fullcodeline": "next_execution_plan_index_to_plan_allocation_ ="
    },
    {
        "line": 48,
        "fullcodeline": "if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 &&"
    },
    {
        "line": 49,
        "fullcodeline": "tensor->dims->size != 1) {"
    },
    {
        "line": 96,
        "fullcodeline": "TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter("
    },
    {
        "line": 63,
        "fullcodeline": "ReportError(\"Input tensor %d lacks data\", tensor_index);"
    },
    {
        "line": 97,
        "fullcodeline": "next_execution_plan_index_to_plan_allocation_ - 1));"
    }
]