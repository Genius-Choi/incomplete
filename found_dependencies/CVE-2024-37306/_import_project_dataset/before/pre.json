[
    {
        "line": 2,
        "fullcodeline": "format_desc = {f.DISPLAY_NAME: f"
    },
    {
        "line": 10,
        "fullcodeline": "rq_id = rq_id_template.format(db_obj.pk, request.user)"
    },
    {
        "line": 12,
        "fullcodeline": "queue = django_rq.get_queue(settings.CVAT_QUEUES.IMPORT_DATA.value)"
    },
    {
        "line": 13,
        "fullcodeline": "rq_job = queue.fetch_job(rq_id)"
    },
    {
        "line": 83,
        "fullcodeline": "serializer = RqIdSerializer(data={'rq_id': rq_id})"
    },
    {
        "line": 84,
        "fullcodeline": "serializer.is_valid(raise_exception=True)"
    },
    {
        "line": 4,
        "fullcodeline": "if format_desc is None:"
    },
    {
        "line": 15,
        "fullcodeline": "if not rq_job or rq_job.is_finished or rq_job.is_failed:"
    },
    {
        "line": 86,
        "fullcodeline": "return Response(serializer.data, status=status.HTTP_202_ACCEPTED)"
    },
    {
        "line": 22,
        "fullcodeline": "location = location_conf.get('location') if location_conf else None"
    },
    {
        "line": 23,
        "fullcodeline": "db_storage = None"
    },
    {
        "line": 56,
        "fullcodeline": "func = import_resource_with_clean_up_after"
    },
    {
        "line": 57,
        "fullcodeline": "func_args = (rq_func, filename, db_obj.pk, format_name, conv_mask_to_poly)"
    },
    {
        "line": 63,
        "fullcodeline": "user_id = request.user.id"
    },
    {
        "line": 5,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 7,
        "fullcodeline": "elif not format_desc.ENABLED:"
    },
    {
        "line": 16,
        "fullcodeline": "if rq_job and (rq_job.is_finished or rq_job.is_failed):"
    },
    {
        "line": 65,
        "fullcodeline": "with get_rq_lock_by_user(queue, user_id):"
    },
    {
        "line": 81,
        "fullcodeline": "return Response(status=status.HTTP_409_CONFLICT, data='Import job already exists')"
    },
    {
        "line": 25,
        "fullcodeline": "if not filename and location != Location.CLOUD_STORAGE:"
    },
    {
        "line": 26,
        "fullcodeline": "serializer = DatasetFileSerializer(data=request.data)"
    },
    {
        "line": 60,
        "fullcodeline": "func_args = (db_storage, key, func) + func_args"
    },
    {
        "line": 61,
        "fullcodeline": "func = import_resource_from_cloud_storage"
    },
    {
        "line": 6,
        "fullcodeline": "\"Unknown input format '{}'\".format(format_name))"
    },
    {
        "line": 8,
        "fullcodeline": "return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)"
    },
    {
        "line": 37,
        "fullcodeline": "elif location == Location.CLOUD_STORAGE:"
    },
    {
        "line": 28,
        "fullcodeline": "dataset_file = serializer.validated_data['dataset_file']"
    },
    {
        "line": 38,
        "fullcodeline": "assert filename, 'The filename was not specified'"
    },
    {
        "line": 45,
        "fullcodeline": "db_storage = get_cloud_storage_for_import_or_export("
    },
    {
        "line": 49,
        "fullcodeline": "key = filename"
    },
    {
        "line": 66,
        "fullcodeline": "rq_job = queue.enqueue_call("
    },
    {
        "line": 29,
        "fullcodeline": "with NamedTemporaryFile("
    },
    {
        "line": 50,
        "fullcodeline": "with NamedTemporaryFile("
    },
    {
        "line": 74,
        "fullcodeline": "depends_on=define_dependent_job(queue, user_id, rq_id=rq_id),"
    },
    {
        "line": 40,
        "fullcodeline": "storage_id = location_conf['storage_id']"
    },
    {
        "line": 70,
        "fullcodeline": "meta={"
    },
    {
        "line": 75,
        "fullcodeline": "result_ttl=settings.IMPORT_CACHE_SUCCESS_TTL.total_seconds(),"
    },
    {
        "line": 76,
        "fullcodeline": "failure_ttl=settings.IMPORT_CACHE_FAILED_TTL.total_seconds()"
    },
    {
        "line": 3,
        "fullcodeline": "for f in dm.views.get_import_formats()}.get(format_name)"
    },
    {
        "line": 33,
        "fullcodeline": "filename = tf.name"
    },
    {
        "line": 54,
        "fullcodeline": "filename = tf.name"
    },
    {
        "line": 72,
        "fullcodeline": "**get_rq_job_meta(request=request, db_obj=db_obj),"
    },
    {
        "line": 30,
        "fullcodeline": "prefix='cvat_{}'.format(db_obj.pk),"
    },
    {
        "line": 34,
        "fullcodeline": "for chunk in dataset_file.chunks():"
    },
    {
        "line": 51,
        "fullcodeline": "prefix='cvat_{}'.format(db_obj.pk),"
    },
    {
        "line": 42,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 43,
        "fullcodeline": "'Cloud storage location was selected as the source,'"
    }
]