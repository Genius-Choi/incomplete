[
    {
        "line": 15,
        "fullcodeline": "format_desc = {f.DISPLAY_NAME: f"
    },
    {
        "line": 23,
        "fullcodeline": "instance_update_time = timezone.localtime(db_instance.updated_date)"
    },
    {
        "line": 28,
        "fullcodeline": "queue = django_rq.get_queue(settings.CVAT_QUEUES.EXPORT_DATA.value)"
    },
    {
        "line": 29,
        "fullcodeline": "rq_job = queue.fetch_job(rq_id)"
    },
    {
        "line": 44,
        "fullcodeline": "location = location_conf.get('location')"
    },
    {
        "line": 50,
        "fullcodeline": "cache_ttl = dm.views.get_export_cache_ttl(db_instance)"
    },
    {
        "line": 52,
        "fullcodeline": "instance_timestamp = datetime.strftime(instance_update_time, \"%Y_%m_%d_%H_%M_%S\")"
    },
    {
        "line": 53,
        "fullcodeline": "is_annotation_file = rq_id.startswith('export:annotations')"
    },
    {
        "line": 55,
        "fullcodeline": "REQUEST_TIMEOUT = 60"
    },
    {
        "line": 154,
        "fullcodeline": "user_id = request.user.id"
    },
    {
        "line": 156,
        "fullcodeline": "func = callback if location == Location.LOCAL else export_resource_to_cloud_storage"
    },
    {
        "line": 157,
        "fullcodeline": "func_args = (db_instance.id, format_name, server_address)"
    },
    {
        "line": 11,
        "fullcodeline": "if action not in {\"\", \"download\"}:"
    },
    {
        "line": 17,
        "fullcodeline": "if format_desc is None:"
    },
    {
        "line": 24,
        "fullcodeline": "if isinstance(db_instance, Project):"
    },
    {
        "line": 45,
        "fullcodeline": "if location not in Location.list():"
    },
    {
        "line": 181,
        "fullcodeline": "with get_rq_lock_by_user(queue, user_id):"
    },
    {
        "line": 193,
        "fullcodeline": "format_name=format_name, cloud_storage=db_storage, save_images=not is_annotation_file)"
    },
    {
        "line": 195,
        "fullcodeline": "return Response(status=status.HTTP_202_ACCEPTED)"
    },
    {
        "line": 12,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 25,
        "fullcodeline": "tasks_update = list(map(lambda db_task: timezone.localtime(db_task.updated_date), db_instance.tasks.all()))"
    },
    {
        "line": 26,
        "fullcodeline": "instance_update_time = max(tasks_update + [instance_update_time])"
    },
    {
        "line": 32,
        "fullcodeline": "rq_request = rq_job.meta.get('request', None)"
    },
    {
        "line": 33,
        "fullcodeline": "request_time = rq_request.get('timestamp', None) if rq_request else None"
    },
    {
        "line": 65,
        "fullcodeline": "file_path = rq_job.return_value()"
    },
    {
        "line": 150,
        "fullcodeline": "server_address += request.get_host()"
    },
    {
        "line": 167,
        "fullcodeline": "db_storage = get_cloud_storage_for_import_or_export("
    },
    {
        "line": 170,
        "fullcodeline": "filename_pattern = build_annotations_file_name("
    },
    {
        "line": 177,
        "fullcodeline": "func_args = (db_storage, filename, filename_pattern, callback) + func_args"
    },
    {
        "line": 179,
        "fullcodeline": "db_storage = None"
    },
    {
        "line": 18,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 20,
        "fullcodeline": "elif not format_desc.ENABLED:"
    },
    {
        "line": 46,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 58,
        "fullcodeline": "if location != Location.LOCAL:"
    },
    {
        "line": 67,
        "fullcodeline": "if not file_path:"
    },
    {
        "line": 73,
        "fullcodeline": "with dm.util.get_export_cache_lock(file_path, ttl=REQUEST_TIMEOUT):"
    },
    {
        "line": 34,
        "fullcodeline": "if request_time is None or request_time < instance_update_time:"
    },
    {
        "line": 40,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 42,
        "fullcodeline": "rq_job = None"
    },
    {
        "line": 47,
        "fullcodeline": "f\"Unexpected location {location} specified for the request\""
    },
    {
        "line": 62,
        "fullcodeline": "if not rq_job or not rq_job.is_finished:"
    },
    {
        "line": 149,
        "fullcodeline": "server_address = request.scheme + '://'"
    },
    {
        "line": 152,
        "fullcodeline": "server_address = None"
    },
    {
        "line": 161,
        "fullcodeline": "storage_id = location_conf['storage_id']"
    },
    {
        "line": 186,
        "fullcodeline": "meta=get_rq_job_meta(request=request, db_obj=db_instance),"
    },
    {
        "line": 187,
        "fullcodeline": "depends_on=define_dependent_job(queue, user_id, rq_id=rq_id),"
    },
    {
        "line": 188,
        "fullcodeline": "result_ttl=cache_ttl.total_seconds(),"
    },
    {
        "line": 189,
        "fullcodeline": "failure_ttl=cache_ttl.total_seconds(),"
    },
    {
        "line": 21,
        "fullcodeline": "return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)"
    },
    {
        "line": 59,
        "fullcodeline": "return Response('Action \"download\" is only supported for a local export location',"
    },
    {
        "line": 63,
        "fullcodeline": "return Response('Export has not finished', status=status.HTTP_400_BAD_REQUEST)"
    },
    {
        "line": 68,
        "fullcodeline": "return Response("
    },
    {
        "line": 80,
        "fullcodeline": "filename = filename or \\"
    },
    {
        "line": 90,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 96,
        "fullcodeline": "if location == Location.CLOUD_STORAGE:"
    },
    {
        "line": 172,
        "fullcodeline": "identifier=db_instance.name if isinstance(db_instance, (Task, Project)) else db_instance.id,"
    },
    {
        "line": 91,
        "fullcodeline": "return sendfile(request, file_path, attachment=True, attachment_filename=filename)"
    },
    {
        "line": 126,
        "fullcodeline": "exc_info = rq_job.meta.get('formatted_exception', str(rq_job.exc_info))"
    },
    {
        "line": 74,
        "fullcodeline": "if not osp.exists(file_path):"
    },
    {
        "line": 81,
        "fullcodeline": "build_annotations_file_name("
    },
    {
        "line": 98,
        "fullcodeline": "return Response(status=status.HTTP_200_OK)"
    },
    {
        "line": 100,
        "fullcodeline": "elif location == Location.LOCAL:"
    },
    {
        "line": 128,
        "fullcodeline": "return Response(exc_info, status=status.HTTP_500_INTERNAL_SERVER_ERROR)"
    },
    {
        "line": 129,
        "fullcodeline": "elif rq_job.is_deferred and rq_id not in queue.deferred_job_registry.get_job_ids():"
    },
    {
        "line": 163,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 75,
        "fullcodeline": "return Response("
    },
    {
        "line": 101,
        "fullcodeline": "file_path = rq_job.return_value()"
    },
    {
        "line": 143,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 164,
        "fullcodeline": "'Cloud storage location was selected as the destination,'"
    },
    {
        "line": 16,
        "fullcodeline": "for f in dm.views.get_export_formats()}.get(format_name)"
    },
    {
        "line": 83,
        "fullcodeline": "identifier=db_instance.name if isinstance(db_instance, (Task, Project)) else db_instance.id,"
    },
    {
        "line": 87,
        "fullcodeline": "extension=osp.splitext(file_path)[1]"
    },
    {
        "line": 103,
        "fullcodeline": "if not file_path:"
    },
    {
        "line": 109,
        "fullcodeline": "with dm.util.get_export_cache_lock(file_path, ttl=REQUEST_TIMEOUT):"
    },
    {
        "line": 124,
        "fullcodeline": "raise NotImplementedError(f\"Export to {location} location is not implemented yet\")"
    },
    {
        "line": 146,
        "fullcodeline": "return Response(status=status.HTTP_202_ACCEPTED)"
    },
    {
        "line": 104,
        "fullcodeline": "return Response("
    },
    {
        "line": 110,
        "fullcodeline": "if osp.exists(file_path):"
    },
    {
        "line": 121,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 115,
        "fullcodeline": "return Response(status=status.HTTP_201_CREATED)"
    }
]