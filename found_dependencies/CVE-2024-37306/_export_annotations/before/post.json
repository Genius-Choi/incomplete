[
    {
        "line": 15,
        "fullcodeline": "format_desc = {f.DISPLAY_NAME: f"
    },
    {
        "line": 23,
        "fullcodeline": "queue = django_rq.get_queue(settings.CVAT_QUEUES.EXPORT_DATA.value)"
    },
    {
        "line": 24,
        "fullcodeline": "rq_job = queue.fetch_job(rq_id)"
    },
    {
        "line": 26,
        "fullcodeline": "location = location_conf.get('location')"
    },
    {
        "line": 32,
        "fullcodeline": "cache_ttl = dm.views.get_export_cache_ttl(db_instance)"
    },
    {
        "line": 33,
        "fullcodeline": "instance_update_time = timezone.localtime(db_instance.updated_date)"
    },
    {
        "line": 38,
        "fullcodeline": "instance_timestamp = datetime.strftime(instance_update_time, \"%Y_%m_%d_%H_%M_%S\")"
    },
    {
        "line": 39,
        "fullcodeline": "is_annotation_file = rq_id.startswith('export:annotations')"
    },
    {
        "line": 136,
        "fullcodeline": "func = callback if location == Location.LOCAL else export_resource_to_cloud_storage"
    },
    {
        "line": 137,
        "fullcodeline": "func_args = (db_instance.id, format_name, server_address)"
    },
    {
        "line": 172,
        "fullcodeline": "handle_dataset_export(db_instance,"
    },
    {
        "line": 11,
        "fullcodeline": "if action not in {\"\", \"download\"}:"
    },
    {
        "line": 17,
        "fullcodeline": "if format_desc is None:"
    },
    {
        "line": 27,
        "fullcodeline": "if location not in Location.list():"
    },
    {
        "line": 34,
        "fullcodeline": "if isinstance(db_instance, Project):"
    },
    {
        "line": 139,
        "fullcodeline": "if location == Location.CLOUD_STORAGE:"
    },
    {
        "line": 161,
        "fullcodeline": "with get_rq_lock_by_user(queue, user_id):"
    },
    {
        "line": 173,
        "fullcodeline": "format_name=format_name, cloud_storage=db_storage, save_images=not is_annotation_file)"
    },
    {
        "line": 12,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 18,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 28,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 35,
        "fullcodeline": "tasks_update = list(map(lambda db_task: timezone.localtime(db_task.updated_date), db_instance.tasks.all()))"
    },
    {
        "line": 36,
        "fullcodeline": "instance_update_time = max(tasks_update + [instance_update_time])"
    },
    {
        "line": 42,
        "fullcodeline": "rq_request = rq_job.meta.get('request', None)"
    },
    {
        "line": 43,
        "fullcodeline": "request_time = rq_request.get('timestamp', None) if rq_request else None"
    },
    {
        "line": 130,
        "fullcodeline": "server_address += request.get_host()"
    },
    {
        "line": 147,
        "fullcodeline": "db_storage = get_cloud_storage_for_import_or_export("
    },
    {
        "line": 150,
        "fullcodeline": "filename_pattern = build_annotations_file_name("
    },
    {
        "line": 157,
        "fullcodeline": "func_args = (db_storage, filename, filename_pattern, callback) + func_args"
    },
    {
        "line": 159,
        "fullcodeline": "db_storage = None"
    },
    {
        "line": 20,
        "fullcodeline": "elif not format_desc.ENABLED:"
    },
    {
        "line": 44,
        "fullcodeline": "if request_time is None or request_time < instance_update_time:"
    },
    {
        "line": 162,
        "fullcodeline": "queue.enqueue_call("
    },
    {
        "line": 29,
        "fullcodeline": "f\"Unexpected location {location} specified for the request\""
    },
    {
        "line": 50,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 51,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 129,
        "fullcodeline": "server_address = request.scheme + '://'"
    },
    {
        "line": 132,
        "fullcodeline": "server_address = None"
    },
    {
        "line": 141,
        "fullcodeline": "storage_id = location_conf['storage_id']"
    },
    {
        "line": 152,
        "fullcodeline": "identifier=db_instance.name if isinstance(db_instance, (Task, Project)) else db_instance.id,"
    },
    {
        "line": 166,
        "fullcodeline": "meta=get_rq_job_meta(request=request, db_obj=db_instance),"
    },
    {
        "line": 167,
        "fullcodeline": "depends_on=define_dependent_job(queue, user_id, rq_id=rq_id),"
    },
    {
        "line": 168,
        "fullcodeline": "result_ttl=cache_ttl.total_seconds(),"
    },
    {
        "line": 169,
        "fullcodeline": "failure_ttl=cache_ttl.total_seconds(),"
    },
    {
        "line": 143,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 54,
        "fullcodeline": "if location == Location.CLOUD_STORAGE:"
    },
    {
        "line": 55,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 106,
        "fullcodeline": "exc_info = rq_job.meta.get('formatted_exception', str(rq_job.exc_info))"
    },
    {
        "line": 107,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 144,
        "fullcodeline": "'Cloud storage location was selected as the destination,'"
    },
    {
        "line": 16,
        "fullcodeline": "for f in dm.views.get_export_formats()}.get(format_name)"
    },
    {
        "line": 58,
        "fullcodeline": "elif location == Location.LOCAL:"
    },
    {
        "line": 108,
        "fullcodeline": "return Response(exc_info, status=status.HTTP_500_INTERNAL_SERVER_ERROR)"
    },
    {
        "line": 109,
        "fullcodeline": "elif rq_job.is_deferred and rq_id not in queue.deferred_job_registry.get_job_ids():"
    },
    {
        "line": 59,
        "fullcodeline": "file_path = rq_job.return_value()"
    },
    {
        "line": 104,
        "fullcodeline": "raise NotImplementedError(f\"Export to {location} location is not implemented yet\")"
    },
    {
        "line": 123,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 124,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 61,
        "fullcodeline": "if not file_path:"
    },
    {
        "line": 67,
        "fullcodeline": "with dm.util.get_export_cache_lock("
    },
    {
        "line": 62,
        "fullcodeline": "return Response("
    },
    {
        "line": 70,
        "fullcodeline": "if action == \"download\":"
    },
    {
        "line": 77,
        "fullcodeline": "filename = filename or \\"
    },
    {
        "line": 87,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 71,
        "fullcodeline": "if not osp.exists(file_path):"
    },
    {
        "line": 88,
        "fullcodeline": "return sendfile(request, file_path, attachment=True, attachment_filename=filename)"
    },
    {
        "line": 90,
        "fullcodeline": "if osp.exists(file_path):"
    },
    {
        "line": 78,
        "fullcodeline": "build_annotations_file_name("
    },
    {
        "line": 93,
        "fullcodeline": "os.utime(file_path, None)"
    },
    {
        "line": 101,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 102,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 72,
        "fullcodeline": "return Response("
    },
    {
        "line": 80,
        "fullcodeline": "identifier=db_instance.name if isinstance(db_instance, (Task, Project)) else db_instance.id,"
    },
    {
        "line": 84,
        "fullcodeline": "extension=osp.splitext(file_path)[1]"
    }
]