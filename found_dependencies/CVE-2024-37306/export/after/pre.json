[
    {
        "line": 2,
        "fullcodeline": "action = request.query_params.get('action', None)"
    },
    {
        "line": 3,
        "fullcodeline": "filename = request.query_params.get('filename', None)"
    },
    {
        "line": 24,
        "fullcodeline": "use_settings = to_bool(use_target_storage_conf)"
    },
    {
        "line": 25,
        "fullcodeline": "obj = db_instance if use_settings else request.query_params"
    },
    {
        "line": 26,
        "fullcodeline": "location_conf = get_location_configuration("
    },
    {
        "line": 32,
        "fullcodeline": "last_instance_update_time = timezone.localtime(db_instance.updated_date)"
    },
    {
        "line": 34,
        "fullcodeline": "queue = django_rq.get_queue(queue_name)"
    },
    {
        "line": 35,
        "fullcodeline": "rq_id = f\"export:{obj_type}.id{db_instance.pk}-by-{request.user}\""
    },
    {
        "line": 36,
        "fullcodeline": "rq_job = queue.fetch_job(rq_id)"
    },
    {
        "line": 48,
        "fullcodeline": "timestamp = datetime.strftime(last_instance_update_time, \"%Y_%m_%d_%H_%M_%S\")"
    },
    {
        "line": 49,
        "fullcodeline": "location = location_conf.get('location')"
    },
    {
        "line": 95,
        "fullcodeline": "ttl = dm.views.PROJECT_CACHE_TTL.total_seconds()"
    },
    {
        "line": 96,
        "fullcodeline": "user_id = request.user.id"
    },
    {
        "line": 98,
        "fullcodeline": "func = _create_backup if location == Location.LOCAL else export_resource_to_cloud_storage"
    },
    {
        "line": 99,
        "fullcodeline": "func_args = (db_instance, Exporter, '{}_backup.zip'.format(obj_type), logger, cache_ttl)"
    },
    {
        "line": 5,
        "fullcodeline": "if action not in (None, 'download'):"
    },
    {
        "line": 9,
        "fullcodeline": "if isinstance(db_instance, Task):"
    },
    {
        "line": 51,
        "fullcodeline": "if action == \"download\":"
    },
    {
        "line": 119,
        "fullcodeline": "with get_rq_lock_by_user(queue, user_id):"
    },
    {
        "line": 129,
        "fullcodeline": "return Response(status=status.HTTP_202_ACCEPTED)"
    },
    {
        "line": 6,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 10,
        "fullcodeline": "obj_type = 'task'"
    },
    {
        "line": 11,
        "fullcodeline": "logger = slogger.task[db_instance.pk]"
    },
    {
        "line": 12,
        "fullcodeline": "Exporter = TaskExporter"
    },
    {
        "line": 13,
        "fullcodeline": "cache_ttl = TASK_CACHE_TTL"
    },
    {
        "line": 14,
        "fullcodeline": "use_target_storage_conf = request.query_params.get('use_default_location', True)"
    },
    {
        "line": 39,
        "fullcodeline": "rq_request = rq_job.meta.get('request', None)"
    },
    {
        "line": 40,
        "fullcodeline": "request_time = rq_request.get(\"timestamp\", None) if rq_request else None"
    },
    {
        "line": 58,
        "fullcodeline": "file_path = rq_job.return_value()"
    },
    {
        "line": 66,
        "fullcodeline": "filename = filename or build_backup_file_name("
    },
    {
        "line": 109,
        "fullcodeline": "db_storage = get_cloud_storage_for_import_or_export("
    },
    {
        "line": 112,
        "fullcodeline": "filename_pattern = build_backup_file_name("
    },
    {
        "line": 117,
        "fullcodeline": "func_args = (db_storage, filename, filename_pattern, _create_backup) + func_args"
    },
    {
        "line": 15,
        "fullcodeline": "elif isinstance(db_instance, Project):"
    },
    {
        "line": 41,
        "fullcodeline": "if request_time is None or request_time < last_instance_update_time:"
    },
    {
        "line": 52,
        "fullcodeline": "if location != Location.LOCAL:"
    },
    {
        "line": 60,
        "fullcodeline": "if not file_path:"
    },
    {
        "line": 74,
        "fullcodeline": "return sendfile(request, file_path, attachment=True,"
    },
    {
        "line": 16,
        "fullcodeline": "obj_type = 'project'"
    },
    {
        "line": 17,
        "fullcodeline": "logger = slogger.project[db_instance.pk]"
    },
    {
        "line": 18,
        "fullcodeline": "Exporter = ProjectExporter"
    },
    {
        "line": 19,
        "fullcodeline": "cache_ttl = PROJECT_CACHE_TTL"
    },
    {
        "line": 20,
        "fullcodeline": "use_target_storage_conf = request.query_params.get('use_default_location', True)"
    },
    {
        "line": 22,
        "fullcodeline": "raise Exception("
    },
    {
        "line": 44,
        "fullcodeline": "rq_job.cancel(enqueue_dependents=settings.ONE_RUNNING_JOB_IN_QUEUE_PER_USER)"
    },
    {
        "line": 45,
        "fullcodeline": "rq_job.delete()"
    },
    {
        "line": 46,
        "fullcodeline": "rq_job = None"
    },
    {
        "line": 55,
        "fullcodeline": "if not rq_job or not rq_job.is_finished:"
    },
    {
        "line": 103,
        "fullcodeline": "storage_id = location_conf['storage_id']"
    },
    {
        "line": 124,
        "fullcodeline": "meta=get_rq_job_meta(request=request, db_obj=db_instance),"
    },
    {
        "line": 125,
        "fullcodeline": "depends_on=define_dependent_job(queue, user_id, rq_id=rq_id),"
    },
    {
        "line": 53,
        "fullcodeline": "return Response('Action \"download\" is only supported for a local backup location', status=status.HTTP_400_BAD_REQUEST)"
    },
    {
        "line": 56,
        "fullcodeline": "return Response('Backup has not finished', status=status.HTTP_400_BAD_REQUEST)"
    },
    {
        "line": 61,
        "fullcodeline": "return Response('A result for exporting job was not found for finished RQ job', status=status.HTTP_500_INTERNAL_SERVER_ERROR)"
    },
    {
        "line": 79,
        "fullcodeline": "if location == Location.LOCAL:"
    },
    {
        "line": 88,
        "fullcodeline": "exc_info = rq_job.meta.get('formatted_exception', str(rq_job.exc_info))"
    },
    {
        "line": 23,
        "fullcodeline": "\"Unexpected type of db_instance: {}\".format(type(db_instance)))"
    },
    {
        "line": 63,
        "fullcodeline": "elif not os.path.exists(file_path):"
    },
    {
        "line": 64,
        "fullcodeline": "return Response('The result file does not exist in export cache', status=status.HTTP_500_INTERNAL_SERVER_ERROR)"
    },
    {
        "line": 70,
        "fullcodeline": "extension=os.path.splitext(file_path)[1]"
    },
    {
        "line": 80,
        "fullcodeline": "return Response(status=status.HTTP_201_CREATED)"
    },
    {
        "line": 82,
        "fullcodeline": "elif location == Location.CLOUD_STORAGE:"
    },
    {
        "line": 90,
        "fullcodeline": "return Response(exc_info,"
    },
    {
        "line": 93,
        "fullcodeline": "return Response(status=status.HTTP_202_ACCEPTED)"
    },
    {
        "line": 105,
        "fullcodeline": "raise serializers.ValidationError("
    },
    {
        "line": 106,
        "fullcodeline": "'Cloud storage location was selected as the destination,'"
    },
    {
        "line": 84,
        "fullcodeline": "return Response(status=status.HTTP_200_OK)"
    }
]