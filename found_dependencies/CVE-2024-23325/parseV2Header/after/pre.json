[
    {
        "line": 2,
        "fullcodeline": "const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];"
    },
    {
        "line": 3,
        "fullcodeline": "uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];"
    },
    {
        "line": 4,
        "fullcodeline": "uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];"
    },
    {
        "line": 5,
        "fullcodeline": "size_t hdr_addr_len = (upper_byte << 8) + lower_byte;"
    },
    {
        "line": 93,
        "fullcodeline": "ENVOY_LOG(debug, \"Unsupported command or address family or transport\");"
    },
    {
        "line": 7,
        "fullcodeline": "if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {"
    },
    {
        "line": 17,
        "fullcodeline": "if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {"
    },
    {
        "line": 10,
        "fullcodeline": "proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});"
    },
    {
        "line": 18,
        "fullcodeline": "uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];"
    },
    {
        "line": 19,
        "fullcodeline": "if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||"
    },
    {
        "line": 20,
        "fullcodeline": "((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {"
    },
    {
        "line": 29,
        "fullcodeline": "v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);"
    },
    {
        "line": 56,
        "fullcodeline": "} else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {"
    },
    {
        "line": 64,
        "fullcodeline": "v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);"
    }
]