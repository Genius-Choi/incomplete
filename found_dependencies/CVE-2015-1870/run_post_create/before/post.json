[
    {
        "line": 22,
        "fullcodeline": "int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);"
    },
    {
        "line": 24,
        "fullcodeline": "char *dup_of_dir = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "struct strbuf *cmd_output = strbuf_new();"
    },
    {
        "line": 27,
        "fullcodeline": "bool child_is_post_create = 1; /* else it is a notify child */"
    },
    {
        "line": 73,
        "fullcodeline": "int status = 0;"
    },
    {
        "line": 101,
        "fullcodeline": "const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);"
    },
    {
        "line": 104,
        "fullcodeline": "struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);"
    },
    {
        "line": 110,
        "fullcodeline": "char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);"
    },
    {
        "line": 111,
        "fullcodeline": "unsigned long count = strtoul(count_str, NULL, 10);"
    },
    {
        "line": 160,
        "fullcodeline": "dd_sanitize_mode_and_owner(dd);"
    },
    {
        "line": 162,
        "fullcodeline": "dd_close(dd);"
    },
    {
        "line": 176,
        "fullcodeline": "child_pid = spawn_event_handler_child("
    },
    {
        "line": 182,
        "fullcodeline": "xmove_fd(fd, child_stdout_fd);"
    },
    {
        "line": 183,
        "fullcodeline": "child_is_post_create = 0;"
    },
    {
        "line": 184,
        "fullcodeline": "strbuf_clear(cmd_output);"
    },
    {
        "line": 185,
        "fullcodeline": "free(dup_of_dir);"
    },
    {
        "line": 186,
        "fullcodeline": "dup_of_dir = NULL;"
    },
    {
        "line": 190,
        "fullcodeline": "log_warning(\"Deleting problem directory '%s'\", dirname);"
    },
    {
        "line": 191,
        "fullcodeline": "delete_dump_dir(dirname);"
    },
    {
        "line": 194,
        "fullcodeline": "strbuf_free(cmd_output);"
    },
    {
        "line": 195,
        "fullcodeline": "free(dup_of_dir);"
    },
    {
        "line": 196,
        "fullcodeline": "close(child_stdout_fd);"
    },
    {
        "line": 4,
        "fullcodeline": "if (!dir_is_in_dump_location(dirname))"
    },
    {
        "line": 10,
        "fullcodeline": "if (!dump_dir_accessible_by_uid(dirname, client_uid))"
    },
    {
        "line": 74,
        "fullcodeline": "if (safe_waitpid(child_pid, &status, 0) <= 0)"
    },
    {
        "line": 79,
        "fullcodeline": "if (!child_is_post_create)"
    },
    {
        "line": 84,
        "fullcodeline": "if (status != 0)"
    },
    {
        "line": 105,
        "fullcodeline": "if (!dd)"
    },
    {
        "line": 116,
        "fullcodeline": "if ((status != 0 && dup_of_dir) || count == 0)"
    },
    {
        "line": 164,
        "fullcodeline": "if (!dup_of_dir)"
    },
    {
        "line": 7,
        "fullcodeline": "error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);"
    },
    {
        "line": 17,
        "fullcodeline": "error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dirname, (long)client_uid);"
    },
    {
        "line": 35,
        "fullcodeline": "char buf[250]; /* usually we get one line, no need to have big buf */"
    },
    {
        "line": 36,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);"
    },
    {
        "line": 40,
        "fullcodeline": "buf[r] = '\\0';"
    },
    {
        "line": 43,
        "fullcodeline": "char *raw = buf;"
    },
    {
        "line": 67,
        "fullcodeline": "strbuf_append_str(cmd_output, raw);"
    },
    {
        "line": 76,
        "fullcodeline": "perror_msg(\"waitpid(%d)\", child_pid);"
    },
    {
        "line": 118,
        "fullcodeline": "count++;"
    },
    {
        "line": 119,
        "fullcodeline": "char new_count_str[sizeof(long)*3 + 2];"
    },
    {
        "line": 120,
        "fullcodeline": "sprintf(new_count_str, \"%lu\", count);"
    },
    {
        "line": 121,
        "fullcodeline": "dd_save_text(dd, FILENAME_COUNT, new_count_str);"
    },
    {
        "line": 165,
        "fullcodeline": "log_notice(\"New problem directory %s, processing\", work_dir);"
    },
    {
        "line": 178,
        "fullcodeline": "(dup_of_dir ? \"notify-dup\" : \"notify\"),"
    },
    {
        "line": 12,
        "fullcodeline": "if (errno == ENOTDIR)"
    },
    {
        "line": 38,
        "fullcodeline": "if (r <= 0)"
    },
    {
        "line": 45,
        "fullcodeline": "while ((newline = strchr(raw, '\\n')) != NULL)"
    },
    {
        "line": 86,
        "fullcodeline": "if (WIFSIGNALED(status))"
    },
    {
        "line": 93,
        "fullcodeline": "if (!dup_of_dir)"
    },
    {
        "line": 128,
        "fullcodeline": "if (strcmp(dd->dd_dirname, dirname) != 0)"
    },
    {
        "line": 168,
        "fullcodeline": "log_warning(\"Deleting problem directory %s (dup of %s)\","
    },
    {
        "line": 171,
        "fullcodeline": "delete_dump_dir(dirname);"
    },
    {
        "line": 14,
        "fullcodeline": "error_msg(\"Path '%s' isn't problem directory\", dirname);"
    },
    {
        "line": 47,
        "fullcodeline": "*newline = '\\0';"
    },
    {
        "line": 48,
        "fullcodeline": "strbuf_append_str(cmd_output, raw);"
    },
    {
        "line": 49,
        "fullcodeline": "char *msg = cmd_output->buf;"
    },
    {
        "line": 52,
        "fullcodeline": "log(\"%s\", msg);"
    },
    {
        "line": 61,
        "fullcodeline": "strbuf_clear(cmd_output);"
    },
    {
        "line": 63,
        "fullcodeline": "raw = newline + 1;"
    },
    {
        "line": 88,
        "fullcodeline": "log(\"'post-create' on '%s' killed by signal %d\","
    },
    {
        "line": 95,
        "fullcodeline": "log(\"'post-create' on '%s' exited with %d\","
    },
    {
        "line": 131,
        "fullcodeline": "struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);"
    },
    {
        "line": 132,
        "fullcodeline": "char *last_ocr = NULL;"
    },
    {
        "line": 153,
        "fullcodeline": "dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);"
    },
    {
        "line": 155,
        "fullcodeline": "free(last_ocr);"
    },
    {
        "line": 169,
        "fullcodeline": "strrchr(dirname, '/') + 1,"
    },
    {
        "line": 170,
        "fullcodeline": "strrchr(dup_of_dir, '/') + 1);"
    },
    {
        "line": 54,
        "fullcodeline": "if (child_is_post_create"
    },
    {
        "line": 89,
        "fullcodeline": "dirname, WTERMSIG(status));"
    },
    {
        "line": 96,
        "fullcodeline": "dirname, WEXITSTATUS(status));"
    },
    {
        "line": 146,
        "fullcodeline": "if (!last_ocr)"
    },
    {
        "line": 55,
        "fullcodeline": "&& prefixcmp(msg, \"DUP_OF_DIR: \") == 0"
    },
    {
        "line": 57,
        "fullcodeline": "free(dup_of_dir);"
    },
    {
        "line": 58,
        "fullcodeline": "dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));"
    },
    {
        "line": 137,
        "fullcodeline": "last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,"
    },
    {
        "line": 139,
        "fullcodeline": "dd_close(new_dd);"
    },
    {
        "line": 148,
        "fullcodeline": "log(\"Using current time for the last occurrence file which may be incorrect.\");"
    },
    {
        "line": 149,
        "fullcodeline": "time_t t = time(NULL);"
    },
    {
        "line": 150,
        "fullcodeline": "last_ocr = xasprintf(\"%lu\", (long)t);"
    },
    {
        "line": 143,
        "fullcodeline": "error_msg(\"Can't read the last occurrence file from the new dump directory.\");"
    },
    {
        "line": 138,
        "fullcodeline": "DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);"
    }
]