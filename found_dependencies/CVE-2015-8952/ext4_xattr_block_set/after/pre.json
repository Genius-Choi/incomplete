[
    {
        "line": 5,
        "fullcodeline": "struct super_block *sb = inode->i_sb;"
    },
    {
        "line": 6,
        "fullcodeline": "struct buffer_head *new_bh = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "struct ext4_xattr_search *s = &bs->s;"
    },
    {
        "line": 8,
        "fullcodeline": "struct mb2_cache_entry *ce = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int error = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "struct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);"
    },
    {
        "line": 82,
        "fullcodeline": "error = ext4_xattr_set_entry(i, s);"
    },
    {
        "line": 207,
        "fullcodeline": "error = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "if (i->value && i->value_len > sb->s_blocksize)"
    },
    {
        "line": 83,
        "fullcodeline": "if (error == -EFSCORRUPTED)"
    },
    {
        "line": 205,
        "fullcodeline": "if (bs->bh && bs->bh != new_bh)"
    },
    {
        "line": 219,
        "fullcodeline": "dquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));"
    },
    {
        "line": 17,
        "fullcodeline": "BUFFER_TRACE(bs->bh, \"get_write_access\");"
    },
    {
        "line": 18,
        "fullcodeline": "error = ext4_journal_get_write_access(handle, bs->bh);"
    },
    {
        "line": 21,
        "fullcodeline": "lock_buffer(bs->bh);"
    },
    {
        "line": 87,
        "fullcodeline": "if (!IS_LAST_ENTRY(s->first))"
    },
    {
        "line": 91,
        "fullcodeline": "if (!IS_LAST_ENTRY(s->first)) {"
    },
    {
        "line": 92,
        "fullcodeline": "new_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);"
    },
    {
        "line": 202,
        "fullcodeline": "EXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;"
    },
    {
        "line": 206,
        "fullcodeline": "ext4_xattr_release_block(handle, inode, bs->bh);"
    },
    {
        "line": 213,
        "fullcodeline": "if (!(bs->bh && s->base == bs->bh->b_data))"
    },
    {
        "line": 224,
        "fullcodeline": "EXT4_I(inode)->i_file_acl);"
    },
    {
        "line": 15,
        "fullcodeline": "return -ENOSPC;"
    },
    {
        "line": 69,
        "fullcodeline": "s->base = kzalloc(sb->s_blocksize, GFP_NOFS);"
    },
    {
        "line": 71,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 77,
        "fullcodeline": "s->first = ENTRY(header(s->base)+1);"
    },
    {
        "line": 78,
        "fullcodeline": "s->here = ENTRY(header(s->base)+1);"
    },
    {
        "line": 79,
        "fullcodeline": "s->end = s->base + sb->s_blocksize;"
    },
    {
        "line": 88,
        "fullcodeline": "ext4_xattr_rehash(header(s->base), s->here);"
    },
    {
        "line": 23,
        "fullcodeline": "if (header(s->base)->h_refcount == cpu_to_le32(1)) {"
    },
    {
        "line": 24,
        "fullcodeline": "__u32 hash = le32_to_cpu(BHDR(bs->bh)->h_hash);"
    },
    {
        "line": 31,
        "fullcodeline": "mb2_cache_entry_delete_block(ext4_mb_cache, hash,"
    },
    {
        "line": 33,
        "fullcodeline": "ea_bdebug(bs->bh, \"modifying in-place\");"
    },
    {
        "line": 34,
        "fullcodeline": "error = ext4_xattr_set_entry(i, s);"
    },
    {
        "line": 42,
        "fullcodeline": "unlock_buffer(bs->bh);"
    },
    {
        "line": 72,
        "fullcodeline": "if (s->base == NULL)"
    },
    {
        "line": 74,
        "fullcodeline": "header(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);"
    },
    {
        "line": 75,
        "fullcodeline": "header(s->base)->h_blocks = cpu_to_le32(1);"
    },
    {
        "line": 76,
        "fullcodeline": "header(s->base)->h_refcount = cpu_to_le32(1);"
    },
    {
        "line": 145,
        "fullcodeline": "mb2_cache_entry_touch(ext4_mb_cache, ce);"
    },
    {
        "line": 146,
        "fullcodeline": "mb2_cache_entry_put(ext4_mb_cache, ce);"
    },
    {
        "line": 147,
        "fullcodeline": "ce = NULL;"
    },
    {
        "line": 35,
        "fullcodeline": "if (!error) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (error == -EFSCORRUPTED)"
    },
    {
        "line": 45,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 53,
        "fullcodeline": "int offset = (char *)s->here - bs->bh->b_data;"
    },
    {
        "line": 55,
        "fullcodeline": "unlock_buffer(bs->bh);"
    },
    {
        "line": 56,
        "fullcodeline": "ea_bdebug(bs->bh, \"cloning\");"
    },
    {
        "line": 57,
        "fullcodeline": "s->base = kmalloc(bs->bh->b_size, GFP_NOFS);"
    },
    {
        "line": 58,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 61,
        "fullcodeline": "memcpy(s->base, BHDR(bs->bh), bs->bh->b_size);"
    },
    {
        "line": 62,
        "fullcodeline": "s->first = ENTRY(header(s->base)+1);"
    },
    {
        "line": 64,
        "fullcodeline": "s->here = ENTRY(s->base + offset);"
    },
    {
        "line": 65,
        "fullcodeline": "s->end = s->base + bs->bh->b_size;"
    },
    {
        "line": 95,
        "fullcodeline": "if (new_bh == bs->bh)"
    },
    {
        "line": 39,
        "fullcodeline": "ext4_xattr_cache_insert(ext4_mb_cache,"
    },
    {
        "line": 46,
        "fullcodeline": "error = ext4_handle_dirty_xattr_block(handle,"
    },
    {
        "line": 59,
        "fullcodeline": "if (s->base == NULL)"
    },
    {
        "line": 63,
        "fullcodeline": "header(s->base)->h_refcount = cpu_to_le32(1);"
    },
    {
        "line": 96,
        "fullcodeline": "ea_bdebug(new_bh, \"keeping\");"
    },
    {
        "line": 148,
        "fullcodeline": "} else if (bs->bh && s->base == bs->bh->b_data) {"
    },
    {
        "line": 100,
        "fullcodeline": "error = dquot_alloc_block(inode,"
    },
    {
        "line": 104,
        "fullcodeline": "BUFFER_TRACE(new_bh, \"get_write_access\");"
    },
    {
        "line": 105,
        "fullcodeline": "error = ext4_journal_get_write_access(handle,"
    },
    {
        "line": 109,
        "fullcodeline": "lock_buffer(new_bh);"
    },
    {
        "line": 135,
        "fullcodeline": "le32_add_cpu(&BHDR(new_bh)->h_refcount, 1);"
    },
    {
        "line": 136,
        "fullcodeline": "ea_bdebug(new_bh, \"reusing; refcount now=%d\","
    },
    {
        "line": 138,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 139,
        "fullcodeline": "error = ext4_handle_dirty_xattr_block(handle,"
    },
    {
        "line": 150,
        "fullcodeline": "ea_bdebug(bs->bh, \"keeping this block\");"
    },
    {
        "line": 151,
        "fullcodeline": "new_bh = bs->bh;"
    },
    {
        "line": 152,
        "fullcodeline": "get_bh(new_bh);"
    },
    {
        "line": 36,
        "fullcodeline": "if (!IS_LAST_ENTRY(s->first))"
    },
    {
        "line": 120,
        "fullcodeline": "if (hlist_bl_unhashed(&ce->e_hash_list)) {"
    },
    {
        "line": 137,
        "fullcodeline": "le32_to_cpu(BHDR(new_bh)->h_refcount));"
    },
    {
        "line": 157,
        "fullcodeline": "goal = ext4_group_first_block_no(sb,"
    },
    {
        "line": 164,
        "fullcodeline": "block = ext4_new_meta_blocks(handle, inode, goal, 0,"
    },
    {
        "line": 172,
        "fullcodeline": "ea_idebug(inode, \"creating block %llu\","
    },
    {
        "line": 175,
        "fullcodeline": "new_bh = sb_getblk(sb, block);"
    },
    {
        "line": 183,
        "fullcodeline": "lock_buffer(new_bh);"
    },
    {
        "line": 190,
        "fullcodeline": "memcpy(new_bh->b_data, s->base, new_bh->b_size);"
    },
    {
        "line": 191,
        "fullcodeline": "set_buffer_uptodate(new_bh);"
    },
    {
        "line": 192,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 193,
        "fullcodeline": "ext4_xattr_cache_insert(ext4_mb_cache, new_bh);"
    },
    {
        "line": 194,
        "fullcodeline": "error = ext4_handle_dirty_xattr_block(handle,"
    },
    {
        "line": 37,
        "fullcodeline": "ext4_xattr_rehash(header(s->base),"
    },
    {
        "line": 101,
        "fullcodeline": "EXT4_C2B(EXT4_SB(sb), 1));"
    },
    {
        "line": 125,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 126,
        "fullcodeline": "dquot_free_block(inode,"
    },
    {
        "line": 130,
        "fullcodeline": "mb2_cache_entry_put(ext4_mb_cache, ce);"
    },
    {
        "line": 131,
        "fullcodeline": "ce = NULL;"
    },
    {
        "line": 132,
        "fullcodeline": "new_bh = NULL;"
    },
    {
        "line": 184,
        "fullcodeline": "error = ext4_journal_get_create_access(handle, new_bh);"
    },
    {
        "line": 127,
        "fullcodeline": "EXT4_C2B(EXT4_SB(sb),"
    },
    {
        "line": 161,
        "fullcodeline": "if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))"
    },
    {
        "line": 162,
        "fullcodeline": "goal = goal & EXT4_MAX_BLOCK_FILE_PHYS;"
    },
    {
        "line": 169,
        "fullcodeline": "if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))"
    },
    {
        "line": 176,
        "fullcodeline": "if (unlikely(!new_bh)) {"
    },
    {
        "line": 177,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 179,
        "fullcodeline": "ext4_free_blocks(handle, inode, NULL, block, 1,"
    },
    {
        "line": 186,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 187,
        "fullcodeline": "error = -EIO;"
    },
    {
        "line": 158,
        "fullcodeline": "EXT4_I(inode)->i_block_group);"
    },
    {
        "line": 170,
        "fullcodeline": "BUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);"
    }
]