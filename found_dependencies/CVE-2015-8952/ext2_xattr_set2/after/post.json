[
    {
        "line": 4,
        "fullcodeline": "struct super_block *sb = inode->i_sb;"
    },
    {
        "line": 5,
        "fullcodeline": "struct buffer_head *new_bh = NULL;"
    },
    {
        "line": 70,
        "fullcodeline": "EXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;"
    },
    {
        "line": 71,
        "fullcodeline": "inode->i_ctime = CURRENT_TIME_SEC;"
    },
    {
        "line": 87,
        "fullcodeline": "error = 0;"
    },
    {
        "line": 124,
        "fullcodeline": "brelse(new_bh);"
    },
    {
        "line": 72,
        "fullcodeline": "if (IS_SYNC(inode)) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (old_bh && old_bh != new_bh) {"
    },
    {
        "line": 7,
        "fullcodeline": "struct mb2_cache *ext2_mb_cache = EXT2_SB(sb)->s_mb_cache;"
    },
    {
        "line": 10,
        "fullcodeline": "new_bh = ext2_xattr_cache_find(inode, header);"
    },
    {
        "line": 60,
        "fullcodeline": "mark_buffer_dirty(new_bh);"
    },
    {
        "line": 73,
        "fullcodeline": "error = sync_inode_metadata(inode, 1);"
    },
    {
        "line": 93,
        "fullcodeline": "lock_buffer(old_bh);"
    },
    {
        "line": 120,
        "fullcodeline": "unlock_buffer(old_bh);"
    },
    {
        "line": 61,
        "fullcodeline": "if (IS_SYNC(inode)) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (error && error != -ENOSPC) {"
    },
    {
        "line": 85,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 94,
        "fullcodeline": "if (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {"
    },
    {
        "line": 29,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 62,
        "fullcodeline": "sync_dirty_buffer(new_bh);"
    },
    {
        "line": 63,
        "fullcodeline": "error = -EIO;"
    },
    {
        "line": 95,
        "fullcodeline": "__u32 hash = le32_to_cpu(HDR(old_bh)->h_hash);"
    },
    {
        "line": 101,
        "fullcodeline": "mb2_cache_entry_delete_block(ext2_mb_cache,"
    },
    {
        "line": 104,
        "fullcodeline": "ea_bdebug(old_bh, \"freeing\");"
    },
    {
        "line": 105,
        "fullcodeline": "ext2_free_blocks(inode, old_bh->b_blocknr, 1);"
    },
    {
        "line": 106,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 109,
        "fullcodeline": "get_bh(old_bh);"
    },
    {
        "line": 110,
        "fullcodeline": "bforget(old_bh);"
    },
    {
        "line": 13,
        "fullcodeline": "if (new_bh == old_bh) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (buffer_req(new_bh) && !buffer_uptodate(new_bh))"
    },
    {
        "line": 78,
        "fullcodeline": "if (new_bh && new_bh != old_bh) {"
    },
    {
        "line": 113,
        "fullcodeline": "le32_add_cpu(&HDR(old_bh)->h_refcount, -1);"
    },
    {
        "line": 114,
        "fullcodeline": "dquot_free_block_nodirty(inode, 1);"
    },
    {
        "line": 115,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 116,
        "fullcodeline": "mark_buffer_dirty(old_bh);"
    },
    {
        "line": 117,
        "fullcodeline": "ea_bdebug(old_bh, \"refcount now=%d\","
    },
    {
        "line": 14,
        "fullcodeline": "ea_bdebug(new_bh, \"keeping this block\");"
    },
    {
        "line": 30,
        "fullcodeline": "} else if (old_bh && header == HDR(old_bh)) {"
    },
    {
        "line": 79,
        "fullcodeline": "dquot_free_block_nodirty(inode, 1);"
    },
    {
        "line": 80,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 118,
        "fullcodeline": "le32_to_cpu(HDR(old_bh)->h_refcount));"
    },
    {
        "line": 18,
        "fullcodeline": "ea_bdebug(new_bh, \"reusing block\");"
    },
    {
        "line": 20,
        "fullcodeline": "error = dquot_alloc_block(inode, 1);"
    },
    {
        "line": 25,
        "fullcodeline": "le32_add_cpu(&HDR(new_bh)->h_refcount, 1);"
    },
    {
        "line": 26,
        "fullcodeline": "ea_bdebug(new_bh, \"refcount now=%d\","
    },
    {
        "line": 33,
        "fullcodeline": "new_bh = old_bh;"
    },
    {
        "line": 34,
        "fullcodeline": "get_bh(new_bh);"
    },
    {
        "line": 35,
        "fullcodeline": "ext2_xattr_cache_insert(ext2_mb_cache, new_bh);"
    },
    {
        "line": 27,
        "fullcodeline": "le32_to_cpu(HDR(new_bh)->h_refcount));"
    },
    {
        "line": 38,
        "fullcodeline": "ext2_fsblk_t goal = ext2_group_first_block_no(sb,"
    },
    {
        "line": 40,
        "fullcodeline": "int block = ext2_new_block(inode, goal, &error);"
    },
    {
        "line": 43,
        "fullcodeline": "ea_idebug(inode, \"creating block %d\", block);"
    },
    {
        "line": 45,
        "fullcodeline": "new_bh = sb_getblk(sb, block);"
    },
    {
        "line": 52,
        "fullcodeline": "lock_buffer(new_bh);"
    },
    {
        "line": 53,
        "fullcodeline": "memcpy(new_bh->b_data, header, new_bh->b_size);"
    },
    {
        "line": 54,
        "fullcodeline": "set_buffer_uptodate(new_bh);"
    },
    {
        "line": 55,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 56,
        "fullcodeline": "ext2_xattr_cache_insert(ext2_mb_cache, new_bh);"
    },
    {
        "line": 58,
        "fullcodeline": "ext2_xattr_update_super_block(sb);"
    },
    {
        "line": 22,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 46,
        "fullcodeline": "if (unlikely(!new_bh)) {"
    },
    {
        "line": 47,
        "fullcodeline": "ext2_free_blocks(inode, block, 1);"
    },
    {
        "line": 48,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 49,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 39,
        "fullcodeline": "EXT2_I(inode)->i_block_group);"
    }
]