[
    {
        "line": 4,
        "fullcodeline": "struct super_block *sb = inode->i_sb;"
    },
    {
        "line": 5,
        "fullcodeline": "struct buffer_head *new_bh = NULL;"
    },
    {
        "line": 69,
        "fullcodeline": "EXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;"
    },
    {
        "line": 70,
        "fullcodeline": "inode->i_ctime = CURRENT_TIME_SEC;"
    },
    {
        "line": 86,
        "fullcodeline": "error = 0;"
    },
    {
        "line": 123,
        "fullcodeline": "brelse(new_bh);"
    },
    {
        "line": 71,
        "fullcodeline": "if (IS_SYNC(inode)) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (old_bh && old_bh != new_bh) {"
    },
    {
        "line": 9,
        "fullcodeline": "new_bh = ext2_xattr_cache_find(inode, header);"
    },
    {
        "line": 59,
        "fullcodeline": "mark_buffer_dirty(new_bh);"
    },
    {
        "line": 72,
        "fullcodeline": "error = sync_inode_metadata(inode, 1);"
    },
    {
        "line": 94,
        "fullcodeline": "ce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,"
    },
    {
        "line": 96,
        "fullcodeline": "lock_buffer(old_bh);"
    },
    {
        "line": 119,
        "fullcodeline": "unlock_buffer(old_bh);"
    },
    {
        "line": 60,
        "fullcodeline": "if (IS_SYNC(inode)) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (error && error != -ENOSPC) {"
    },
    {
        "line": 84,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 97,
        "fullcodeline": "if (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {"
    },
    {
        "line": 28,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 61,
        "fullcodeline": "sync_dirty_buffer(new_bh);"
    },
    {
        "line": 62,
        "fullcodeline": "error = -EIO;"
    },
    {
        "line": 101,
        "fullcodeline": "ea_bdebug(old_bh, \"freeing\");"
    },
    {
        "line": 102,
        "fullcodeline": "ext2_free_blocks(inode, old_bh->b_blocknr, 1);"
    },
    {
        "line": 103,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 106,
        "fullcodeline": "get_bh(old_bh);"
    },
    {
        "line": 107,
        "fullcodeline": "bforget(old_bh);"
    },
    {
        "line": 12,
        "fullcodeline": "if (new_bh == old_bh) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (buffer_req(new_bh) && !buffer_uptodate(new_bh))"
    },
    {
        "line": 77,
        "fullcodeline": "if (new_bh && new_bh != old_bh) {"
    },
    {
        "line": 110,
        "fullcodeline": "le32_add_cpu(&HDR(old_bh)->h_refcount, -1);"
    },
    {
        "line": 113,
        "fullcodeline": "dquot_free_block_nodirty(inode, 1);"
    },
    {
        "line": 114,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 115,
        "fullcodeline": "mark_buffer_dirty(old_bh);"
    },
    {
        "line": 116,
        "fullcodeline": "ea_bdebug(old_bh, \"refcount now=%d\","
    },
    {
        "line": 13,
        "fullcodeline": "ea_bdebug(new_bh, \"keeping this block\");"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (old_bh && header == HDR(old_bh)) {"
    },
    {
        "line": 78,
        "fullcodeline": "dquot_free_block_nodirty(inode, 1);"
    },
    {
        "line": 79,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 100,
        "fullcodeline": "mb_cache_entry_free(ce);"
    },
    {
        "line": 117,
        "fullcodeline": "le32_to_cpu(HDR(old_bh)->h_refcount));"
    },
    {
        "line": 17,
        "fullcodeline": "ea_bdebug(new_bh, \"reusing block\");"
    },
    {
        "line": 19,
        "fullcodeline": "error = dquot_alloc_block(inode, 1);"
    },
    {
        "line": 24,
        "fullcodeline": "le32_add_cpu(&HDR(new_bh)->h_refcount, 1);"
    },
    {
        "line": 25,
        "fullcodeline": "ea_bdebug(new_bh, \"refcount now=%d\","
    },
    {
        "line": 32,
        "fullcodeline": "new_bh = old_bh;"
    },
    {
        "line": 33,
        "fullcodeline": "get_bh(new_bh);"
    },
    {
        "line": 34,
        "fullcodeline": "ext2_xattr_cache_insert(new_bh);"
    },
    {
        "line": 112,
        "fullcodeline": "mb_cache_entry_release(ce);"
    },
    {
        "line": 26,
        "fullcodeline": "le32_to_cpu(HDR(new_bh)->h_refcount));"
    },
    {
        "line": 37,
        "fullcodeline": "ext2_fsblk_t goal = ext2_group_first_block_no(sb,"
    },
    {
        "line": 39,
        "fullcodeline": "int block = ext2_new_block(inode, goal, &error);"
    },
    {
        "line": 42,
        "fullcodeline": "ea_idebug(inode, \"creating block %d\", block);"
    },
    {
        "line": 44,
        "fullcodeline": "new_bh = sb_getblk(sb, block);"
    },
    {
        "line": 51,
        "fullcodeline": "lock_buffer(new_bh);"
    },
    {
        "line": 52,
        "fullcodeline": "memcpy(new_bh->b_data, header, new_bh->b_size);"
    },
    {
        "line": 53,
        "fullcodeline": "set_buffer_uptodate(new_bh);"
    },
    {
        "line": 54,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 55,
        "fullcodeline": "ext2_xattr_cache_insert(new_bh);"
    },
    {
        "line": 57,
        "fullcodeline": "ext2_xattr_update_super_block(sb);"
    },
    {
        "line": 21,
        "fullcodeline": "unlock_buffer(new_bh);"
    },
    {
        "line": 45,
        "fullcodeline": "if (unlikely(!new_bh)) {"
    },
    {
        "line": 46,
        "fullcodeline": "ext2_free_blocks(inode, block, 1);"
    },
    {
        "line": 47,
        "fullcodeline": "mark_inode_dirty(inode);"
    },
    {
        "line": 48,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 38,
        "fullcodeline": "EXT2_I(inode)->i_block_group);"
    }
]