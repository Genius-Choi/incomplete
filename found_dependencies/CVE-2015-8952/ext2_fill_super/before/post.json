[
    {
        "line": 8,
        "fullcodeline": "unsigned long sb_block = get_sb_block(&data);"
    },
    {
        "line": 10,
        "fullcodeline": "unsigned long offset = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "long ret = -EINVAL;"
    },
    {
        "line": 13,
        "fullcodeline": "int blocksize = BLOCK_SIZE;"
    },
    {
        "line": 19,
        "fullcodeline": "err = -ENOMEM;"
    },
    {
        "line": 20,
        "fullcodeline": "sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);"
    },
    {
        "line": 24,
        "fullcodeline": "sbi->s_blockgroup_lock ="
    },
    {
        "line": 30,
        "fullcodeline": "sb->s_fs_info = sbi;"
    },
    {
        "line": 31,
        "fullcodeline": "sbi->s_sb_block = sb_block;"
    },
    {
        "line": 33,
        "fullcodeline": "spin_lock_init(&sbi->s_lock);"
    },
    {
        "line": 42,
        "fullcodeline": "blocksize = sb_min_blocksize(sb, BLOCK_SIZE);"
    },
    {
        "line": 67,
        "fullcodeline": "es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);"
    },
    {
        "line": 68,
        "fullcodeline": "sbi->s_es = es;"
    },
    {
        "line": 69,
        "fullcodeline": "sb->s_magic = le16_to_cpu(es->s_magic);"
    },
    {
        "line": 75,
        "fullcodeline": "def_mount_opts = le32_to_cpu(es->s_default_mount_opts);"
    },
    {
        "line": 98,
        "fullcodeline": "sbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));"
    },
    {
        "line": 99,
        "fullcodeline": "sbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));"
    },
    {
        "line": 101,
        "fullcodeline": "set_opt(sbi->s_mount_opt, RESERVATION);"
    },
    {
        "line": 106,
        "fullcodeline": "sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |"
    },
    {
        "line": 109,
        "fullcodeline": "sb->s_iflags |= SB_I_CGROUPWB;"
    },
    {
        "line": 123,
        "fullcodeline": "features = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);"
    },
    {
        "line": 138,
        "fullcodeline": "blocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);"
    },
    {
        "line": 179,
        "fullcodeline": "sb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);"
    },
    {
        "line": 180,
        "fullcodeline": "sb->s_max_links = EXT2_LINK_MAX;"
    },
    {
        "line": 198,
        "fullcodeline": "sbi->s_frag_size = EXT2_MIN_FRAG_SIZE <<"
    },
    {
        "line": 202,
        "fullcodeline": "sbi->s_frags_per_block = sb->s_blocksize / sbi->s_frag_size;"
    },
    {
        "line": 204,
        "fullcodeline": "sbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);"
    },
    {
        "line": 205,
        "fullcodeline": "sbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);"
    },
    {
        "line": 206,
        "fullcodeline": "sbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);"
    },
    {
        "line": 210,
        "fullcodeline": "sbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);"
    },
    {
        "line": 213,
        "fullcodeline": "sbi->s_itb_per_group = sbi->s_inodes_per_group /"
    },
    {
        "line": 215,
        "fullcodeline": "sbi->s_desc_per_block = sb->s_blocksize /"
    },
    {
        "line": 217,
        "fullcodeline": "sbi->s_sbh = bh;"
    },
    {
        "line": 218,
        "fullcodeline": "sbi->s_mount_state = le16_to_cpu(es->s_state);"
    },
    {
        "line": 219,
        "fullcodeline": "sbi->s_addr_per_block_bits ="
    },
    {
        "line": 221,
        "fullcodeline": "sbi->s_desc_per_block_bits ="
    },
    {
        "line": 262,
        "fullcodeline": "sbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -"
    },
    {
        "line": 265,
        "fullcodeline": "db_count = (sbi->s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /"
    },
    {
        "line": 267,
        "fullcodeline": "sbi->s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);"
    },
    {
        "line": 272,
        "fullcodeline": "bgl_lock_init(sbi->s_blockgroup_lock);"
    },
    {
        "line": 273,
        "fullcodeline": "sbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);"
    },
    {
        "line": 293,
        "fullcodeline": "sbi->s_gdb_count = db_count;"
    },
    {
        "line": 294,
        "fullcodeline": "get_random_bytes(&sbi->s_next_generation, sizeof(u32));"
    },
    {
        "line": 295,
        "fullcodeline": "spin_lock_init(&sbi->s_next_gen_lock);"
    },
    {
        "line": 298,
        "fullcodeline": "spin_lock_init(&sbi->s_rsv_window_lock);"
    },
    {
        "line": 299,
        "fullcodeline": "sbi->s_rsv_window_root = RB_ROOT;"
    },
    {
        "line": 306,
        "fullcodeline": "sbi->s_rsv_window_head.rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;"
    },
    {
        "line": 307,
        "fullcodeline": "sbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;"
    },
    {
        "line": 308,
        "fullcodeline": "sbi->s_rsv_window_head.rsv_alloc_hit = 0;"
    },
    {
        "line": 309,
        "fullcodeline": "sbi->s_rsv_window_head.rsv_goal_size = 0;"
    },
    {
        "line": 310,
        "fullcodeline": "ext2_rsv_window_add(sb, &sbi->s_rsv_window_head);"
    },
    {
        "line": 312,
        "fullcodeline": "err = percpu_counter_init(&sbi->s_freeblocks_counter,"
    },
    {
        "line": 329,
        "fullcodeline": "sb->s_op = &ext2_sops;"
    },
    {
        "line": 330,
        "fullcodeline": "sb->s_export_op = &ext2_export_ops;"
    },
    {
        "line": 331,
        "fullcodeline": "sb->s_xattr = ext2_xattr_handlers;"
    },
    {
        "line": 339,
        "fullcodeline": "root = ext2_iget(sb, EXT2_ROOT_INO);"
    },
    {
        "line": 350,
        "fullcodeline": "sb->s_root = d_make_root(root);"
    },
    {
        "line": 361,
        "fullcodeline": "ext2_write_super(sb);"
    },
    {
        "line": 371,
        "fullcodeline": "percpu_counter_destroy(&sbi->s_freeblocks_counter);"
    },
    {
        "line": 372,
        "fullcodeline": "percpu_counter_destroy(&sbi->s_freeinodes_counter);"
    },
    {
        "line": 373,
        "fullcodeline": "percpu_counter_destroy(&sbi->s_dirs_counter);"
    },
    {
        "line": 378,
        "fullcodeline": "kfree(sbi->s_group_desc);"
    },
    {
        "line": 379,
        "fullcodeline": "kfree(sbi->s_debts);"
    },
    {
        "line": 381,
        "fullcodeline": "brelse(bh);"
    },
    {
        "line": 383,
        "fullcodeline": "sb->s_fs_info = NULL;"
    },
    {
        "line": 384,
        "fullcodeline": "kfree(sbi->s_blockgroup_lock);"
    },
    {
        "line": 385,
        "fullcodeline": "kfree(sbi);"
    },
    {
        "line": 21,
        "fullcodeline": "if (!sbi)"
    },
    {
        "line": 25,
        "fullcodeline": "kzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);"
    },
    {
        "line": 26,
        "fullcodeline": "if (!sbi->s_blockgroup_lock) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (!blocksize) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (blocksize != BLOCK_SIZE) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (!(bh = sb_bread(sb, logic_sb_block))) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (sb->s_magic != EXT2_SUPER_MAGIC)"
    },
    {
        "line": 76,
        "fullcodeline": "if (def_mount_opts & EXT2_DEFM_DEBUG)"
    },
    {
        "line": 78,
        "fullcodeline": "if (def_mount_opts & EXT2_DEFM_BSDGROUPS)"
    },
    {
        "line": 80,
        "fullcodeline": "if (def_mount_opts & EXT2_DEFM_UID16)"
    },
    {
        "line": 91,
        "fullcodeline": "if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)"
    },
    {
        "line": 103,
        "fullcodeline": "if (!parse_options((char *) data, sb))"
    },
    {
        "line": 111,
        "fullcodeline": "if (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&"
    },
    {
        "line": 130,
        "fullcodeline": "if (!(sb->s_flags & MS_RDONLY) &&"
    },
    {
        "line": 140,
        "fullcodeline": "if (sbi->s_mount_opt & EXT2_MOUNT_DAX) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (sb->s_blocksize != blocksize) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {"
    },
    {
        "line": 200,
        "fullcodeline": "if (sbi->s_frag_size == 0)"
    },
    {
        "line": 208,
        "fullcodeline": "if (EXT2_INODE_SIZE(sb) == 0)"
    },
    {
        "line": 211,
        "fullcodeline": "if (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)"
    },
    {
        "line": 220,
        "fullcodeline": "ilog2 (EXT2_ADDR_PER_BLOCK(sb));"
    },
    {
        "line": 222,
        "fullcodeline": "ilog2 (EXT2_DESC_PER_BLOCK(sb));"
    },
    {
        "line": 224,
        "fullcodeline": "if (sb->s_magic != EXT2_SUPER_MAGIC)"
    },
    {
        "line": 227,
        "fullcodeline": "if (sb->s_blocksize != bh->b_size) {"
    },
    {
        "line": 233,
        "fullcodeline": "if (sb->s_blocksize != sbi->s_frag_size) {"
    },
    {
        "line": 241,
        "fullcodeline": "if (sbi->s_blocks_per_group > sb->s_blocksize * 8) {"
    },
    {
        "line": 247,
        "fullcodeline": "if (sbi->s_frags_per_group > sb->s_blocksize * 8) {"
    },
    {
        "line": 253,
        "fullcodeline": "if (sbi->s_inodes_per_group > sb->s_blocksize * 8) {"
    },
    {
        "line": 260,
        "fullcodeline": "if (EXT2_BLOCKS_PER_GROUP(sb) == 0)"
    },
    {
        "line": 268,
        "fullcodeline": "if (sbi->s_group_desc == NULL) {"
    },
    {
        "line": 274,
        "fullcodeline": "if (!sbi->s_debts) {"
    },
    {
        "line": 278,
        "fullcodeline": "for (i = 0; i < db_count; i++) {"
    },
    {
        "line": 289,
        "fullcodeline": "if (!ext2_check_descriptors (sb)) {"
    },
    {
        "line": 314,
        "fullcodeline": "if (!err) {"
    },
    {
        "line": 318,
        "fullcodeline": "if (!err) {"
    },
    {
        "line": 340,
        "fullcodeline": "if (IS_ERR(root)) {"
    },
    {
        "line": 344,
        "fullcodeline": "if (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {"
    },
    {
        "line": 351,
        "fullcodeline": "if (!sb->s_root) {"
    },
    {
        "line": 356,
        "fullcodeline": "if (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))"
    },
    {
        "line": 359,
        "fullcodeline": "if (ext2_setup_super (sb, es, sb->s_flags & MS_RDONLY))"
    },
    {
        "line": 365,
        "fullcodeline": "if (!silent)"
    },
    {
        "line": 375,
        "fullcodeline": "for (i = 0; i < db_count; i++)"
    },
    {
        "line": 376,
        "fullcodeline": "brelse(sbi->s_group_desc[i]);"
    },
    {
        "line": 27,
        "fullcodeline": "kfree(sbi);"
    },
    {
        "line": 44,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: unable to set blocksize\");"
    },
    {
        "line": 53,
        "fullcodeline": "logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;"
    },
    {
        "line": 54,
        "fullcodeline": "offset = (sb_block*BLOCK_SIZE) % blocksize;"
    },
    {
        "line": 60,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: unable to read superblock\");"
    },
    {
        "line": 77,
        "fullcodeline": "set_opt(sbi->s_mount_opt, DEBUG);"
    },
    {
        "line": 79,
        "fullcodeline": "set_opt(sbi->s_mount_opt, GRPID);"
    },
    {
        "line": 81,
        "fullcodeline": "set_opt(sbi->s_mount_opt, NO_UID32);"
    },
    {
        "line": 92,
        "fullcodeline": "set_opt(sbi->s_mount_opt, ERRORS_PANIC);"
    },
    {
        "line": 107,
        "fullcodeline": "((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?"
    },
    {
        "line": 112,
        "fullcodeline": "(EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||"
    },
    {
        "line": 115,
        "fullcodeline": "ext2_msg(sb, KERN_WARNING,"
    },
    {
        "line": 125,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,\t\"error: couldn't mount because of \""
    },
    {
        "line": 131,
        "fullcodeline": "(features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){"
    },
    {
        "line": 132,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: couldn't mount RDWR because of \""
    },
    {
        "line": 155,
        "fullcodeline": "brelse(bh);"
    },
    {
        "line": 163,
        "fullcodeline": "logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;"
    },
    {
        "line": 164,
        "fullcodeline": "offset = (sb_block*BLOCK_SIZE) % blocksize;"
    },
    {
        "line": 165,
        "fullcodeline": "bh = sb_bread(sb, logic_sb_block);"
    },
    {
        "line": 171,
        "fullcodeline": "es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);"
    },
    {
        "line": 172,
        "fullcodeline": "sbi->s_es = es;"
    },
    {
        "line": 183,
        "fullcodeline": "sbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;"
    },
    {
        "line": 184,
        "fullcodeline": "sbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;"
    },
    {
        "line": 199,
        "fullcodeline": "le32_to_cpu(es->s_log_frag_size);"
    },
    {
        "line": 234,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 242,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 248,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 254,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 266,
        "fullcodeline": "EXT2_DESC_PER_BLOCK(sb);"
    },
    {
        "line": 269,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: not enough memory\");"
    },
    {
        "line": 275,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: not enough memory\");"
    },
    {
        "line": 279,
        "fullcodeline": "block = descriptor_loc(sb, logic_sb_block, i);"
    },
    {
        "line": 280,
        "fullcodeline": "sbi->s_group_desc[i] = sb_bread(sb, block);"
    },
    {
        "line": 290,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"group descriptors corrupted\");"
    },
    {
        "line": 313,
        "fullcodeline": "ext2_count_free_blocks(sb), GFP_KERNEL);"
    },
    {
        "line": 315,
        "fullcodeline": "err = percpu_counter_init(&sbi->s_freeinodes_counter,"
    },
    {
        "line": 319,
        "fullcodeline": "err = percpu_counter_init(&sbi->s_dirs_counter,"
    },
    {
        "line": 323,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: insufficient memory\");"
    },
    {
        "line": 341,
        "fullcodeline": "ret = PTR_ERR(root);"
    },
    {
        "line": 345,
        "fullcodeline": "iput(root);"
    },
    {
        "line": 346,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");"
    },
    {
        "line": 352,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: get root inode failed\");"
    },
    {
        "line": 353,
        "fullcodeline": "ret = -ENOMEM;"
    },
    {
        "line": 357,
        "fullcodeline": "ext2_msg(sb, KERN_WARNING,"
    },
    {
        "line": 360,
        "fullcodeline": "sb->s_flags |= MS_RDONLY;"
    },
    {
        "line": 366,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 56,
        "fullcodeline": "logic_sb_block = sb_block;"
    },
    {
        "line": 114,
        "fullcodeline": "EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))"
    },
    {
        "line": 127,
        "fullcodeline": "le32_to_cpu(features));"
    },
    {
        "line": 134,
        "fullcodeline": "le32_to_cpu(features));"
    },
    {
        "line": 141,
        "fullcodeline": "if (blocksize != PAGE_SIZE) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (!sb_set_blocksize(sb, blocksize)) {"
    },
    {
        "line": 166,
        "fullcodeline": "if(!bh) {"
    },
    {
        "line": 173,
        "fullcodeline": "if (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {"
    },
    {
        "line": 186,
        "fullcodeline": "sbi->s_inode_size = le16_to_cpu(es->s_inode_size);"
    },
    {
        "line": 187,
        "fullcodeline": "sbi->s_first_ino = le32_to_cpu(es->s_first_ino);"
    },
    {
        "line": 228,
        "fullcodeline": "if (!silent)"
    },
    {
        "line": 264,
        "fullcodeline": "/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;"
    },
    {
        "line": 281,
        "fullcodeline": "if (!sbi->s_group_desc[i]) {"
    },
    {
        "line": 93,
        "fullcodeline": "else if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_CONTINUE)"
    },
    {
        "line": 113,
        "fullcodeline": "EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||"
    },
    {
        "line": 142,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 147,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 158,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 167,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: couldn't read\""
    },
    {
        "line": 174,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: magic mismatch\");"
    },
    {
        "line": 188,
        "fullcodeline": "if ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||"
    },
    {
        "line": 229,
        "fullcodeline": "ext2_msg(sb, KERN_ERR, \"error: unsupported blocksize\");"
    },
    {
        "line": 284,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 316,
        "fullcodeline": "ext2_count_free_inodes(sb), GFP_KERNEL);"
    },
    {
        "line": 320,
        "fullcodeline": "ext2_count_dirs(sb), GFP_KERNEL);"
    },
    {
        "line": 94,
        "fullcodeline": "set_opt(sbi->s_mount_opt, ERRORS_CONT);"
    },
    {
        "line": 190,
        "fullcodeline": "(sbi->s_inode_size > blocksize)) {"
    },
    {
        "line": 191,
        "fullcodeline": "ext2_msg(sb, KERN_ERR,"
    },
    {
        "line": 263,
        "fullcodeline": "le32_to_cpu(es->s_first_data_block) - 1)"
    },
    {
        "line": 282,
        "fullcodeline": "for (j = 0; j < i; j++)"
    },
    {
        "line": 96,
        "fullcodeline": "set_opt(sbi->s_mount_opt, ERRORS_RO);"
    },
    {
        "line": 189,
        "fullcodeline": "!is_power_of_2(sbi->s_inode_size) ||"
    }
]