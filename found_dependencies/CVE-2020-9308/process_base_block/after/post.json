[
    {
        "line": 4,
        "fullcodeline": "const size_t SMALLEST_RAR5_BLOCK_SIZE = 3;"
    },
    {
        "line": 6,
        "fullcodeline": "struct rar5* rar = get_context(a);"
    },
    {
        "line": 8,
        "fullcodeline": "size_t raw_hdr_size = 0, hdr_size_len, hdr_size;"
    },
    {
        "line": 9,
        "fullcodeline": "size_t header_id = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "size_t header_flags = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "ret = skip_unprocessed_bytes(a);"
    },
    {
        "line": 35,
        "fullcodeline": "hdr_size = raw_hdr_size + hdr_size_len;"
    },
    {
        "line": 63,
        "fullcodeline": "computed_crc = (uint32_t) crc32(0, p, (int) hdr_size);"
    },
    {
        "line": 82,
        "fullcodeline": "rar->generic.split_after = (header_flags & HFL_SPLIT_AFTER) > 0;"
    },
    {
        "line": 83,
        "fullcodeline": "rar->generic.split_before = (header_flags & HFL_SPLIT_BEFORE) > 0;"
    },
    {
        "line": 84,
        "fullcodeline": "rar->generic.size = (int)hdr_size;"
    },
    {
        "line": 85,
        "fullcodeline": "rar->generic.last_header_id = (int)header_id;"
    },
    {
        "line": 86,
        "fullcodeline": "rar->main.endarc = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "if(ret != ARCHIVE_OK)"
    },
    {
        "line": 26,
        "fullcodeline": "if(!read_u32(a, &hdr_crc)) {"
    },
    {
        "line": 31,
        "fullcodeline": "if(!read_var_sized(a, &raw_hdr_size, &hdr_size_len)) {"
    },
    {
        "line": 38,
        "fullcodeline": "if(hdr_size > (2 * 1024 * 1024)) {"
    },
    {
        "line": 46,
        "fullcodeline": "if(raw_hdr_size == 0 || hdr_size_len == 0 ||"
    },
    {
        "line": 58,
        "fullcodeline": "if(!read_ahead(a, hdr_size, &p)) {"
    },
    {
        "line": 64,
        "fullcodeline": "if(computed_crc != hdr_crc) {"
    },
    {
        "line": 72,
        "fullcodeline": "if(ARCHIVE_OK != consume(a, hdr_size_len)) {"
    },
    {
        "line": 76,
        "fullcodeline": "if(!read_var_sized(a, &header_id, NULL))"
    },
    {
        "line": 79,
        "fullcodeline": "if(!read_var_sized(a, &header_flags, NULL))"
    },
    {
        "line": 39,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
    },
    {
        "line": 47,
        "fullcodeline": "hdr_size < SMALLEST_RAR5_BLOCK_SIZE)"
    },
    {
        "line": 49,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
    },
    {
        "line": 65,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
    },
    {
        "line": 91,
        "fullcodeline": "ret = process_head_main(a, rar, entry, header_flags);"
    },
    {
        "line": 101,
        "fullcodeline": "ret = process_head_service(a, rar, entry, header_flags);"
    },
    {
        "line": 104,
        "fullcodeline": "ret = process_head_file(a, rar, entry, header_flags);"
    },
    {
        "line": 107,
        "fullcodeline": "archive_set_error(&a->archive,"
    },
    {
        "line": 112,
        "fullcodeline": "rar->main.endarc = 1;"
    },
    {
        "line": 96,
        "fullcodeline": "if(ret == ARCHIVE_OK)"
    },
    {
        "line": 144,
        "fullcodeline": "if((header_flags & HFL_SKIP_IF_UNKNOWN) == 0) {"
    },
    {
        "line": 122,
        "fullcodeline": "ret = scan_for_signature(a);"
    },
    {
        "line": 145,
        "fullcodeline": "archive_set_error(&a->archive,"
    },
    {
        "line": 123,
        "fullcodeline": "if(ret == ARCHIVE_FATAL) {"
    },
    {
        "line": 134,
        "fullcodeline": "rar->vol.expected_vol_no ="
    },
    {
        "line": 126,
        "fullcodeline": "if(rar->vol.expected_vol_no =="
    },
    {
        "line": 135,
        "fullcodeline": "rar->main.vol_no + 1;"
    },
    {
        "line": 128,
        "fullcodeline": "archive_set_error(&a->archive,"
    }
]