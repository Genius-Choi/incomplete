[
    {
        "line": 4,
        "fullcodeline": "struct rar5* rar = get_context(a);"
    },
    {
        "line": 6,
        "fullcodeline": "size_t raw_hdr_size = 0, hdr_size_len, hdr_size;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t header_id = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t header_flags = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "ret = skip_unprocessed_bytes(a);"
    },
    {
        "line": 41,
        "fullcodeline": "hdr_size = raw_hdr_size + hdr_size_len;"
    },
    {
        "line": 50,
        "fullcodeline": "computed_crc = (uint32_t) crc32(0, p, (int) hdr_size);"
    },
    {
        "line": 69,
        "fullcodeline": "rar->generic.split_after = (header_flags & HFL_SPLIT_AFTER) > 0;"
    },
    {
        "line": 70,
        "fullcodeline": "rar->generic.split_before = (header_flags & HFL_SPLIT_BEFORE) > 0;"
    },
    {
        "line": 71,
        "fullcodeline": "rar->generic.size = (int)hdr_size;"
    },
    {
        "line": 72,
        "fullcodeline": "rar->generic.last_header_id = (int)header_id;"
    },
    {
        "line": 73,
        "fullcodeline": "rar->main.endarc = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "if(ret != ARCHIVE_OK)"
    },
    {
        "line": 24,
        "fullcodeline": "if(!read_u32(a, &hdr_crc)) {"
    },
    {
        "line": 29,
        "fullcodeline": "if(!read_var_sized(a, &raw_hdr_size, &hdr_size_len)) {"
    },
    {
        "line": 34,
        "fullcodeline": "if(raw_hdr_size > (2 * 1024 * 1024)) {"
    },
    {
        "line": 45,
        "fullcodeline": "if(!read_ahead(a, hdr_size, &p)) {"
    },
    {
        "line": 51,
        "fullcodeline": "if(computed_crc != hdr_crc) {"
    },
    {
        "line": 59,
        "fullcodeline": "if(ARCHIVE_OK != consume(a, hdr_size_len)) {"
    },
    {
        "line": 63,
        "fullcodeline": "if(!read_var_sized(a, &header_id, NULL))"
    },
    {
        "line": 66,
        "fullcodeline": "if(!read_var_sized(a, &header_flags, NULL))"
    },
    {
        "line": 35,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
    },
    {
        "line": 52,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,"
    },
    {
        "line": 78,
        "fullcodeline": "ret = process_head_main(a, rar, entry, header_flags);"
    },
    {
        "line": 88,
        "fullcodeline": "ret = process_head_service(a, rar, entry, header_flags);"
    },
    {
        "line": 91,
        "fullcodeline": "ret = process_head_file(a, rar, entry, header_flags);"
    },
    {
        "line": 94,
        "fullcodeline": "archive_set_error(&a->archive,"
    },
    {
        "line": 99,
        "fullcodeline": "rar->main.endarc = 1;"
    },
    {
        "line": 83,
        "fullcodeline": "if(ret == ARCHIVE_OK)"
    },
    {
        "line": 131,
        "fullcodeline": "if((header_flags & HFL_SKIP_IF_UNKNOWN) == 0) {"
    },
    {
        "line": 109,
        "fullcodeline": "ret = scan_for_signature(a);"
    },
    {
        "line": 132,
        "fullcodeline": "archive_set_error(&a->archive,"
    },
    {
        "line": 110,
        "fullcodeline": "if(ret == ARCHIVE_FATAL) {"
    },
    {
        "line": 121,
        "fullcodeline": "rar->vol.expected_vol_no ="
    },
    {
        "line": 113,
        "fullcodeline": "if(rar->vol.expected_vol_no =="
    },
    {
        "line": 122,
        "fullcodeline": "rar->main.vol_no + 1;"
    },
    {
        "line": 115,
        "fullcodeline": "archive_set_error(&a->archive,"
    }
]