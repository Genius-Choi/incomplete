[
    {
        "line": 3,
        "fullcodeline": "wchar ArcName[NM];"
    },
    {
        "line": 4,
        "fullcodeline": "wcsncpyz(ArcName,Name,ASIZE(ArcName));"
    },
    {
        "line": 6,
        "fullcodeline": "wchar *Num=GetVolNumPart(ArcName);"
    },
    {
        "line": 15,
        "fullcodeline": "wchar FirstVolName[NM];"
    },
    {
        "line": 16,
        "fullcodeline": "*FirstVolName=0;"
    },
    {
        "line": 18,
        "fullcodeline": "int64 RecFileSize=0;"
    },
    {
        "line": 21,
        "fullcodeline": "VolFind.SetMask(ArcName);"
    },
    {
        "line": 23,
        "fullcodeline": "uint FoundRecVolumes=0;"
    },
    {
        "line": 99,
        "fullcodeline": "MissingVolumes=0;"
    },
    {
        "line": 128,
        "fullcodeline": "uiMsg(UIMSG_RECVOLMISSING,MissingVolumes);"
    },
    {
        "line": 146,
        "fullcodeline": "uint64 MaxVolSize=0;"
    },
    {
        "line": 188,
        "fullcodeline": "int64 ProcessedSize=0;"
    },
    {
        "line": 189,
        "fullcodeline": "int LastPercent=-1;"
    },
    {
        "line": 194,
        "fullcodeline": "MissingVolumes=0;"
    },
    {
        "line": 196,
        "fullcodeline": "ValidFlags=new bool[TotalCount];"
    },
    {
        "line": 205,
        "fullcodeline": "RecBufferSize=TotalBufferSize/MissingVolumes;"
    },
    {
        "line": 212,
        "fullcodeline": "uint *Data=new uint[TotalCount];"
    },
    {
        "line": 222,
        "fullcodeline": "RealReadBuffer=new byte[RecBufferSize+SSE_ALIGNMENT];"
    },
    {
        "line": 223,
        "fullcodeline": "byte *ReadBuf=(byte *)ALIGN_VALUE(RealReadBuffer,SSE_ALIGNMENT);"
    },
    {
        "line": 7,
        "fullcodeline": "if (Num==ArcName)"
    },
    {
        "line": 10,
        "fullcodeline": "Num--;"
    },
    {
        "line": 11,
        "fullcodeline": "if (Num==ArcName)"
    },
    {
        "line": 13,
        "fullcodeline": "wcsncpyz(Num,L\"*.*\",ASIZE(ArcName)-(Num-ArcName));"
    },
    {
        "line": 24,
        "fullcodeline": "while (VolFind.Next(&fd))"
    },
    {
        "line": 94,
        "fullcodeline": "if (FoundRecVolumes==0)"
    },
    {
        "line": 100,
        "fullcodeline": "for (uint I=0;I<TotalCount;I++)"
    },
    {
        "line": 130,
        "fullcodeline": "if (MissingVolumes==0)"
    },
    {
        "line": 136,
        "fullcodeline": "if (MissingVolumes>FoundRecVolumes)"
    },
    {
        "line": 147,
        "fullcodeline": "for (uint I=0;I<DataCount;I++)"
    },
    {
        "line": 197,
        "fullcodeline": "for (uint I=0;I<TotalCount;I++)"
    },
    {
        "line": 276,
        "fullcodeline": "for (uint I=0;I<TotalCount;I++)"
    },
    {
        "line": 9,
        "fullcodeline": "while (Num>ArcName && IsDigit(*(Num-1)))"
    },
    {
        "line": 28,
        "fullcodeline": "Archive *Vol=new Archive(Cmd);"
    },
    {
        "line": 29,
        "fullcodeline": "int ItemPos=-1;"
    },
    {
        "line": 92,
        "fullcodeline": "if (!Silent || FoundRecVolumes!=0)"
    },
    {
        "line": 93,
        "fullcodeline": "uiMsg(UIMSG_RECVOLFOUND,FoundRecVolumes);"
    },
    {
        "line": 102,
        "fullcodeline": "RecVolItem *Item=&RecItems[I];"
    },
    {
        "line": 138,
        "fullcodeline": "uiMsg(UIERROR_RECVOLFOUND,FoundRecVolumes); // Intentionally not displayed in console mode."
    },
    {
        "line": 149,
        "fullcodeline": "RecVolItem *Item=&RecItems[I];"
    },
    {
        "line": 184,
        "fullcodeline": "NextVolumeName(FirstVolName,ASIZE(FirstVolName),false);"
    },
    {
        "line": 199,
        "fullcodeline": "ValidFlags[I]=RecItems[I].f!=NULL && !RecItems[I].New;"
    },
    {
        "line": 206,
        "fullcodeline": "if ((RecBufferSize&1)==1) // Must be even for our RS16 codec."
    },
    {
        "line": 207,
        "fullcodeline": "RecBufferSize--;"
    },
    {
        "line": 215,
        "fullcodeline": "if (!RS.Init(DataCount,RecCount,ValidFlags))"
    },
    {
        "line": 229,
        "fullcodeline": "int MaxRead=0;"
    },
    {
        "line": 267,
        "fullcodeline": "int CurPercent=ToPercent(ProcessedSize,RecFileSize);"
    },
    {
        "line": 273,
        "fullcodeline": "ProcessedSize+=MaxRead;"
    },
    {
        "line": 277,
        "fullcodeline": "if (RecItems[I].f!=NULL)"
    },
    {
        "line": 285,
        "fullcodeline": "if (!Silent && !Cmd->DisableDone)"
    },
    {
        "line": 30,
        "fullcodeline": "if (Vol->WOpen(fd.Name))"
    },
    {
        "line": 79,
        "fullcodeline": "if (ItemPos==-1)"
    },
    {
        "line": 103,
        "fullcodeline": "if (Item->f!=NULL)"
    },
    {
        "line": 150,
        "fullcodeline": "if (Item->FileSize>MaxVolSize)"
    },
    {
        "line": 167,
        "fullcodeline": "if ((Item->New=(Item->f==NULL))) // Additional parentheses to avoid GCC warning."
    },
    {
        "line": 230,
        "fullcodeline": "for (uint I=0,J=DataCount;I<DataCount;I++)"
    },
    {
        "line": 255,
        "fullcodeline": "if (MaxRead==0)"
    },
    {
        "line": 258,
        "fullcodeline": "for (uint I=0,J=0;I<DataCount;I++)"
    },
    {
        "line": 105,
        "fullcodeline": "uiMsg(UIMSG_STRING,Item->Name);"
    },
    {
        "line": 108,
        "fullcodeline": "CalcFileSum(Item->f,&RevCRC,NULL,Cmd->Threads,INT64NDF,CALCFSUM_CURPOS);"
    },
    {
        "line": 109,
        "fullcodeline": "Item->Valid=RevCRC==Item->CRC;"
    },
    {
        "line": 124,
        "fullcodeline": "if (I<DataCount && (Item->f==NULL || !Item->Valid))"
    },
    {
        "line": 125,
        "fullcodeline": "MissingVolumes++;"
    },
    {
        "line": 151,
        "fullcodeline": "MaxVolSize=Item->FileSize;"
    },
    {
        "line": 152,
        "fullcodeline": "if (Item->f!=NULL && !Item->Valid)"
    },
    {
        "line": 154,
        "fullcodeline": "Item->f->Close();"
    },
    {
        "line": 156,
        "fullcodeline": "wchar NewName[NM];"
    },
    {
        "line": 157,
        "fullcodeline": "wcscpy(NewName,Item->Name);"
    },
    {
        "line": 158,
        "fullcodeline": "wcscat(NewName,L\".bad\");"
    },
    {
        "line": 160,
        "fullcodeline": "uiMsg(UIMSG_BADARCHIVE,Item->Name);"
    },
    {
        "line": 161,
        "fullcodeline": "uiMsg(UIMSG_RENAMING,Item->Name,NewName);"
    },
    {
        "line": 162,
        "fullcodeline": "RenameFile(Item->Name,NewName);"
    },
    {
        "line": 164,
        "fullcodeline": "Item->f=NULL;"
    },
    {
        "line": 169,
        "fullcodeline": "wcsncpyz(Item->Name,FirstVolName,ASIZE(Item->Name));"
    },
    {
        "line": 170,
        "fullcodeline": "uiMsg(UIMSG_CREATING,Item->Name);"
    },
    {
        "line": 171,
        "fullcodeline": "uiMsg(UIEVENT_NEWARCHIVE,Item->Name);"
    },
    {
        "line": 172,
        "fullcodeline": "File *NewVol=new File;"
    },
    {
        "line": 180,
        "fullcodeline": "NewVol->Prealloc(Item->FileSize);"
    },
    {
        "line": 181,
        "fullcodeline": "Item->f=NewVol;"
    },
    {
        "line": 182,
        "fullcodeline": "Item->New=true;"
    },
    {
        "line": 200,
        "fullcodeline": "if (I<DataCount && !ValidFlags[I])"
    },
    {
        "line": 201,
        "fullcodeline": "MissingVolumes++;"
    },
    {
        "line": 232,
        "fullcodeline": "uint VolNum=I;"
    },
    {
        "line": 239,
        "fullcodeline": "RecVolItem *Item=RecItems+VolNum;"
    },
    {
        "line": 241,
        "fullcodeline": "byte *B=&ReadBuf[0];"
    },
    {
        "line": 242,
        "fullcodeline": "int ReadSize=0;"
    },
    {
        "line": 252,
        "fullcodeline": "uint DataToProcess=(uint)Min(RecBufferSize,MaxVolSize-ProcessedSize);"
    },
    {
        "line": 253,
        "fullcodeline": "ProcessRS(Cmd,I,B,DataToProcess,false);"
    },
    {
        "line": 259,
        "fullcodeline": "if (!ValidFlags[I])"
    },
    {
        "line": 268,
        "fullcodeline": "if (!Cmd->DisablePercentage && CurPercent!=LastPercent)"
    },
    {
        "line": 270,
        "fullcodeline": "uiProcessProgress(\"RV\",ProcessedSize,RecFileSize);"
    },
    {
        "line": 271,
        "fullcodeline": "LastPercent=CurPercent;"
    },
    {
        "line": 32,
        "fullcodeline": "if (CmpExt(fd.Name,L\"rev\"))"
    },
    {
        "line": 110,
        "fullcodeline": "if (!Item->Valid)"
    },
    {
        "line": 233,
        "fullcodeline": "if (!ValidFlags[I]) // If next RAR volume is missing or invalid."
    },
    {
        "line": 245,
        "fullcodeline": "if (ReadSize!=RecBufferSize)"
    },
    {
        "line": 247,
        "fullcodeline": "if (ReadSize>MaxRead)"
    },
    {
        "line": 261,
        "fullcodeline": "RecVolItem *Item=RecItems+I;"
    },
    {
        "line": 262,
        "fullcodeline": "size_t WriteSize=(size_t)Min(MaxRead,Item->FileSize);"
    },
    {
        "line": 263,
        "fullcodeline": "Item->f->Write(Buf+(J++)*RecBufferSize,WriteSize);"
    },
    {
        "line": 264,
        "fullcodeline": "Item->FileSize-=WriteSize;"
    },
    {
        "line": 34,
        "fullcodeline": "uint RecNum=ReadHeader(Vol,FoundRecVolumes==0);"
    },
    {
        "line": 112,
        "fullcodeline": "uiMsg(UIMSG_CHECKSUM,Item->Name);"
    },
    {
        "line": 174,
        "fullcodeline": "if (!FileCreate(Cmd,NewVol,Item->Name,ASIZE(Item->Name),&UserReject))"
    },
    {
        "line": 178,
        "fullcodeline": "ErrHandler.Exit(UserReject ? RARX_USERBREAK:RARX_CREATE);"
    },
    {
        "line": 237,
        "fullcodeline": "VolNum=J++; // Use next valid REV volume data instead of RAR."
    },
    {
        "line": 243,
        "fullcodeline": "if (Item->f!=NULL && !Item->New)"
    },
    {
        "line": 244,
        "fullcodeline": "ReadSize=Item->f->Read(B,RecBufferSize);"
    },
    {
        "line": 248,
        "fullcodeline": "MaxRead=ReadSize;"
    },
    {
        "line": 35,
        "fullcodeline": "if (RecNum!=0)"
    },
    {
        "line": 82,
        "fullcodeline": "if ((uint)ItemPos<RecItems.Size()) // Check if found more REV than needed."
    },
    {
        "line": 85,
        "fullcodeline": "RecVolItem *Item=RecItems+ItemPos;"
    },
    {
        "line": 86,
        "fullcodeline": "Item->f=Vol;"
    },
    {
        "line": 87,
        "fullcodeline": "Item->New=false;"
    },
    {
        "line": 88,
        "fullcodeline": "wcsncpyz(Item->Name,fd.Name,ASIZE(Item->Name));"
    },
    {
        "line": 116,
        "fullcodeline": "if (I>=DataCount)"
    },
    {
        "line": 235,
        "fullcodeline": "while (!ValidFlags[J]) // Find next valid REV volume."
    },
    {
        "line": 236,
        "fullcodeline": "J++;"
    },
    {
        "line": 246,
        "fullcodeline": "memset(B+ReadSize,0,RecBufferSize-ReadSize);"
    },
    {
        "line": 40,
        "fullcodeline": "ItemPos=RecNum;"
    },
    {
        "line": 41,
        "fullcodeline": "FoundRecVolumes++;"
    },
    {
        "line": 119,
        "fullcodeline": "Item->f=NULL;"
    },
    {
        "line": 120,
        "fullcodeline": "FoundRecVolumes--;"
    },
    {
        "line": 177,
        "fullcodeline": "ErrHandler.CreateErrorMsg(Item->Name);"
    },
    {
        "line": 37,
        "fullcodeline": "if (FoundRecVolumes==0)"
    },
    {
        "line": 45,
        "fullcodeline": "if (Vol->IsArchive(true) && (Vol->SFXSize>0 || CmpExt(fd.Name,L\"rar\")))"
    },
    {
        "line": 54,
        "fullcodeline": "Vol->QOpenUnload();"
    },
    {
        "line": 56,
        "fullcodeline": "Vol->Seek(0,SEEK_SET);"
    },
    {
        "line": 60,
        "fullcodeline": "wchar *Num=GetVolNumPart(fd.Name);"
    },
    {
        "line": 61,
        "fullcodeline": "uint VolNum=0;"
    },
    {
        "line": 66,
        "fullcodeline": "size_t CurSize=RecItems.Size();"
    },
    {
        "line": 73,
        "fullcodeline": "ItemPos=VolNum-1;"
    },
    {
        "line": 38,
        "fullcodeline": "RecFileSize=Vol->FileLength();"
    },
    {
        "line": 63,
        "fullcodeline": "VolNum+=(*Num-'0')*K;"
    },
    {
        "line": 67,
        "fullcodeline": "if (VolNum>CurSize)"
    },
    {
        "line": 75,
        "fullcodeline": "if (*FirstVolName==0)"
    },
    {
        "line": 47,
        "fullcodeline": "if (!Vol->Volume && !Vol->BrokenHeader)"
    },
    {
        "line": 49,
        "fullcodeline": "uiMsg(UIERROR_NOTVOLUME,ArcName);"
    },
    {
        "line": 62,
        "fullcodeline": "for (uint K=1;Num>=fd.Name && IsDigit(*Num);K*=10,Num--)"
    },
    {
        "line": 64,
        "fullcodeline": "if (VolNum==0 || VolNum>MaxVolumes)"
    },
    {
        "line": 69,
        "fullcodeline": "RecItems.Alloc(VolNum);"
    },
    {
        "line": 76,
        "fullcodeline": "VolNameToFirstName(fd.Name,FirstVolName,ASIZE(FirstVolName),true);"
    },
    {
        "line": 70,
        "fullcodeline": "for (size_t I=CurSize;I<VolNum;I++)"
    }
]