[
    {
        "line": 3,
        "fullcodeline": "RawRead Raw(this);"
    },
    {
        "line": 5,
        "fullcodeline": "bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD5;"
    },
    {
        "line": 46,
        "fullcodeline": "const size_t FirstReadSize=7; // Smallest possible block size."
    },
    {
        "line": 53,
        "fullcodeline": "ShortBlock.Reset();"
    },
    {
        "line": 54,
        "fullcodeline": "ShortBlock.HeadCRC=Raw.Get4();"
    },
    {
        "line": 55,
        "fullcodeline": "uint SizeBytes=Raw.GetVSize(4);"
    },
    {
        "line": 56,
        "fullcodeline": "uint64 BlockSize=Raw.GetV();"
    },
    {
        "line": 64,
        "fullcodeline": "int SizeToRead=int(BlockSize);"
    },
    {
        "line": 65,
        "fullcodeline": "SizeToRead-=FirstReadSize-SizeBytes-4; // Adjust overread size bytes if any."
    },
    {
        "line": 66,
        "fullcodeline": "uint HeaderSize=4+SizeBytes+(uint)BlockSize;"
    },
    {
        "line": 74,
        "fullcodeline": "Raw.Read(SizeToRead);"
    },
    {
        "line": 82,
        "fullcodeline": "uint HeaderCRC=Raw.GetCRC50();"
    },
    {
        "line": 84,
        "fullcodeline": "ShortBlock.HeaderType=(HEADER_TYPE)Raw.GetV();"
    },
    {
        "line": 85,
        "fullcodeline": "ShortBlock.Flags=(uint)Raw.GetV();"
    },
    {
        "line": 86,
        "fullcodeline": "ShortBlock.SkipIfUnknown=(ShortBlock.Flags & HFL_SKIPIFUNKNOWN)!=0;"
    },
    {
        "line": 87,
        "fullcodeline": "ShortBlock.HeadSize=HeaderSize;"
    },
    {
        "line": 89,
        "fullcodeline": "CurHeaderType=ShortBlock.HeaderType;"
    },
    {
        "line": 107,
        "fullcodeline": "uint64 ExtraSize=0;"
    },
    {
        "line": 118,
        "fullcodeline": "uint64 DataSize=0;"
    },
    {
        "line": 122,
        "fullcodeline": "NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);"
    },
    {
        "line": 47,
        "fullcodeline": "if (Raw.Read(FirstReadSize)<FirstReadSize)"
    },
    {
        "line": 76,
        "fullcodeline": "if (Raw.Size()<HeaderSize)"
    },
    {
        "line": 91,
        "fullcodeline": "bool BadCRC=(ShortBlock.HeadCRC!=HeaderCRC);"
    },
    {
        "line": 124,
        "fullcodeline": "NextBlockPos=SafeAdd(NextBlockPos,DataSize,0);"
    },
    {
        "line": 322,
        "fullcodeline": "return Raw.Size();"
    },
    {
        "line": 13,
        "fullcodeline": "byte HeadersInitV[SIZE_INITV];"
    },
    {
        "line": 39,
        "fullcodeline": "Raw.SetCrypt(&HeadersCrypt);"
    },
    {
        "line": 58,
        "fullcodeline": "if (BlockSize==0 || SizeBytes==0)"
    },
    {
        "line": 68,
        "fullcodeline": "if (SizeToRead<0 || HeaderSize<SIZEOF_SHORTBLOCKHEAD5)"
    },
    {
        "line": 96,
        "fullcodeline": "BrokenHeader=true;"
    },
    {
        "line": 97,
        "fullcodeline": "ErrHandler.SetErrorCode(RARX_CRC);"
    },
    {
        "line": 108,
        "fullcodeline": "if ((ShortBlock.Flags & HFL_EXTRA)!=0)"
    },
    {
        "line": 110,
        "fullcodeline": "ExtraSize=Raw.GetV();"
    },
    {
        "line": 119,
        "fullcodeline": "if ((ShortBlock.Flags & HFL_DATA)!=0)"
    },
    {
        "line": 120,
        "fullcodeline": "DataSize=Raw.GetV();"
    },
    {
        "line": 14,
        "fullcodeline": "if (Read(HeadersInitV,SIZE_INITV)!=SIZE_INITV)"
    },
    {
        "line": 111,
        "fullcodeline": "if (ExtraSize>=ShortBlock.HeadSize)"
    },
    {
        "line": 131,
        "fullcodeline": "uint CryptVersion=(uint)Raw.GetV();"
    },
    {
        "line": 137,
        "fullcodeline": "uint EncFlags=(uint)Raw.GetV();"
    },
    {
        "line": 139,
        "fullcodeline": "CryptHead.Lg2Count=Raw.Get1();"
    },
    {
        "line": 145,
        "fullcodeline": "Raw.GetB(CryptHead.Salt,SIZE_SALT50);"
    },
    {
        "line": 167,
        "fullcodeline": "MainHead.Reset();"
    },
    {
        "line": 169,
        "fullcodeline": "uint ArcFlags=(uint)Raw.GetV();"
    },
    {
        "line": 171,
        "fullcodeline": "Volume=(ArcFlags & MHFL_VOLUME)!=0;"
    },
    {
        "line": 172,
        "fullcodeline": "Solid=(ArcFlags & MHFL_SOLID)!=0;"
    },
    {
        "line": 173,
        "fullcodeline": "Locked=(ArcFlags & MHFL_LOCK)!=0;"
    },
    {
        "line": 174,
        "fullcodeline": "Protected=(ArcFlags & MHFL_PROTECT)!=0;"
    },
    {
        "line": 175,
        "fullcodeline": "Signed=false;"
    },
    {
        "line": 176,
        "fullcodeline": "NewNumbering=true;"
    },
    {
        "line": 182,
        "fullcodeline": "FirstVolume=Volume && VolNumber==0;"
    },
    {
        "line": 209,
        "fullcodeline": "FileHeader *hd=ShortBlock.HeaderType==HEAD_FILE ? &FileHead:&SubHead;"
    },
    {
        "line": 210,
        "fullcodeline": "hd->Reset();"
    },
    {
        "line": 213,
        "fullcodeline": "bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;"
    },
    {
        "line": 215,
        "fullcodeline": "hd->LargeFile=true;"
    },
    {
        "line": 217,
        "fullcodeline": "hd->PackSize=DataSize;"
    },
    {
        "line": 218,
        "fullcodeline": "hd->FileFlags=(uint)Raw.GetV();"
    },
    {
        "line": 219,
        "fullcodeline": "hd->UnpSize=Raw.GetV();"
    },
    {
        "line": 221,
        "fullcodeline": "hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;"
    },
    {
        "line": 225,
        "fullcodeline": "hd->MaxSize=Max(hd->PackSize,hd->UnpSize);"
    },
    {
        "line": 226,
        "fullcodeline": "hd->FileAttr=(uint)Raw.GetV();"
    },
    {
        "line": 230,
        "fullcodeline": "hd->FileHash.Type=HASH_NONE;"
    },
    {
        "line": 237,
        "fullcodeline": "hd->RedirType=FSREDIR_NONE;"
    },
    {
        "line": 239,
        "fullcodeline": "uint CompInfo=(uint)Raw.GetV();"
    },
    {
        "line": 240,
        "fullcodeline": "hd->Method=(CompInfo>>7) & 7;"
    },
    {
        "line": 246,
        "fullcodeline": "hd->UnpVer=(CompInfo & 0x3f) + 50;"
    },
    {
        "line": 248,
        "fullcodeline": "hd->HostOS=(byte)Raw.GetV();"
    },
    {
        "line": 249,
        "fullcodeline": "size_t NameSize=(size_t)Raw.GetV();"
    },
    {
        "line": 250,
        "fullcodeline": "hd->Inherited=(ShortBlock.Flags & HFL_INHERITED)!=0;"
    },
    {
        "line": 252,
        "fullcodeline": "hd->HSType=HSYS_UNKNOWN;"
    },
    {
        "line": 259,
        "fullcodeline": "hd->SplitBefore=(hd->Flags & HFL_SPLITBEFORE)!=0;"
    },
    {
        "line": 260,
        "fullcodeline": "hd->SplitAfter=(hd->Flags & HFL_SPLITAFTER)!=0;"
    },
    {
        "line": 261,
        "fullcodeline": "hd->SubBlock=(hd->Flags & HFL_CHILD)!=0;"
    },
    {
        "line": 262,
        "fullcodeline": "hd->Solid=FileBlock && (CompInfo & FCI_SOLID)!=0;"
    },
    {
        "line": 264,
        "fullcodeline": "hd->WinSize=hd->Dir ? 0:size_t(0x20000)<<((CompInfo>>10)&0xf);"
    },
    {
        "line": 266,
        "fullcodeline": "hd->CryptMethod=hd->Encrypted ? CRYPT_RAR50:CRYPT_NONE;"
    },
    {
        "line": 268,
        "fullcodeline": "char FileName[NM*4];"
    },
    {
        "line": 269,
        "fullcodeline": "size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);"
    },
    {
        "line": 270,
        "fullcodeline": "Raw.GetB((byte *)FileName,ReadNameSize);"
    },
    {
        "line": 271,
        "fullcodeline": "FileName[ReadNameSize]=0;"
    },
    {
        "line": 273,
        "fullcodeline": "UtfToWide(FileName,hd->FileName,ASIZE(hd->FileName));"
    },
    {
        "line": 313,
        "fullcodeline": "uint ArcFlags=(uint)Raw.GetV();"
    },
    {
        "line": 16,
        "fullcodeline": "UnexpEndArcMsg();"
    },
    {
        "line": 24,
        "fullcodeline": "byte PswCheck[SIZE_PSWCHECK];"
    },
    {
        "line": 25,
        "fullcodeline": "HeadersCrypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,NULL,PswCheck);"
    },
    {
        "line": 101,
        "fullcodeline": "uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);"
    },
    {
        "line": 102,
        "fullcodeline": "FailedHeaderDecryption=true;"
    },
    {
        "line": 132,
        "fullcodeline": "if (CryptVersion>CRYPT_VERSION)"
    },
    {
        "line": 138,
        "fullcodeline": "CryptHead.UsePswCheck=(EncFlags & CHFL_CRYPT_PSWCHECK)!=0;"
    },
    {
        "line": 140,
        "fullcodeline": "if (CryptHead.Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)"
    },
    {
        "line": 184,
        "fullcodeline": "if (ExtraSize!=0)"
    },
    {
        "line": 253,
        "fullcodeline": "if (hd->HostOS==HOST5_UNIX)"
    },
    {
        "line": 263,
        "fullcodeline": "hd->Dir=(hd->FileFlags & FHFL_DIRECTORY)!=0;"
    },
    {
        "line": 277,
        "fullcodeline": "if (ExtraSize!=0)"
    },
    {
        "line": 314,
        "fullcodeline": "EndArcHead.NextVolume=(ArcFlags & EHFL_NEXTVOLUME)!=0;"
    },
    {
        "line": 27,
        "fullcodeline": "if (CryptHead.UsePswCheck && memcmp(PswCheck,CryptHead.PswCheck,SIZE_PSWCHECK)!=0)"
    },
    {
        "line": 148,
        "fullcodeline": "Raw.GetB(CryptHead.PswCheck,SIZE_PSWCHECK);"
    },
    {
        "line": 150,
        "fullcodeline": "byte csum[SIZE_PSWCHECK_CSUM];"
    },
    {
        "line": 151,
        "fullcodeline": "Raw.GetB(csum,SIZE_PSWCHECK_CSUM);"
    },
    {
        "line": 154,
        "fullcodeline": "sha256_init(&ctx);"
    },
    {
        "line": 155,
        "fullcodeline": "sha256_process(&ctx, CryptHead.PswCheck, SIZE_PSWCHECK);"
    },
    {
        "line": 157,
        "fullcodeline": "byte Digest[SHA256_DIGEST_SIZE];"
    },
    {
        "line": 158,
        "fullcodeline": "sha256_done(&ctx, Digest);"
    },
    {
        "line": 178,
        "fullcodeline": "if ((ArcFlags & MHFL_VOLNUMBER)!=0)"
    },
    {
        "line": 179,
        "fullcodeline": "VolNumber=(uint)Raw.GetV();"
    },
    {
        "line": 185,
        "fullcodeline": "ProcessExtra50(&Raw,(size_t)ExtraSize,&MainHead);"
    },
    {
        "line": 223,
        "fullcodeline": "hd->UnpSize=INT64NDF;"
    },
    {
        "line": 227,
        "fullcodeline": "if ((hd->FileFlags & FHFL_UTIME)!=0)"
    },
    {
        "line": 228,
        "fullcodeline": "hd->mtime.SetUnix((time_t)Raw.Get4());"
    },
    {
        "line": 231,
        "fullcodeline": "if ((hd->FileFlags & FHFL_CRC32)!=0)"
    },
    {
        "line": 233,
        "fullcodeline": "hd->FileHash.Type=HASH_CRC32;"
    },
    {
        "line": 254,
        "fullcodeline": "hd->HSType=HSYS_UNIX;"
    },
    {
        "line": 278,
        "fullcodeline": "ProcessExtra50(&Raw,(size_t)ExtraSize,hd);"
    },
    {
        "line": 283,
        "fullcodeline": "ConvertNameCase(hd->FileName);"
    },
    {
        "line": 285,
        "fullcodeline": "ConvertFileHeader(hd);"
    },
    {
        "line": 288,
        "fullcodeline": "if (!FileBlock && hd->CmpName(SUBHEAD_TYPE_CMT))"
    },
    {
        "line": 289,
        "fullcodeline": "MainComment=true;"
    },
    {
        "line": 307,
        "fullcodeline": "uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);"
    },
    {
        "line": 31,
        "fullcodeline": "uiMsg(UIWAIT_BADPSW,FileName);"
    },
    {
        "line": 33,
        "fullcodeline": "Cmd->Password.Clean();"
    },
    {
        "line": 160,
        "fullcodeline": "CryptHead.UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;"
    },
    {
        "line": 181,
        "fullcodeline": "VolNumber=0;"
    },
    {
        "line": 234,
        "fullcodeline": "hd->FileHash.CRC32=Raw.Get4();"
    },
    {
        "line": 256,
        "fullcodeline": "if (hd->HostOS==HOST5_WINDOWS)"
    },
    {
        "line": 257,
        "fullcodeline": "hd->HSType=HSYS_WINDOWS;"
    }
]