[
    {
        "line": 4,
        "fullcodeline": "union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;"
    },
    {
        "line": 5,
        "fullcodeline": "char\tline[TOSHIBA_LINE_LENGTH];"
    },
    {
        "line": 8,
        "fullcodeline": "char\tchannel[10], direction[10];"
    },
    {
        "line": 27,
        "fullcodeline": "num_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\","
    },
    {
        "line": 59,
        "fullcodeline": "num_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);"
    },
    {
        "line": 66,
        "fullcodeline": "phdr->rec_type = REC_TYPE_PACKET;"
    },
    {
        "line": 95,
        "fullcodeline": "ws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);"
    },
    {
        "line": 96,
        "fullcodeline": "pd = ws_buffer_start_ptr(buf);"
    },
    {
        "line": 100,
        "fullcodeline": "hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);"
    },
    {
        "line": 16,
        "fullcodeline": "if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {"
    },
    {
        "line": 67,
        "fullcodeline": "phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;"
    },
    {
        "line": 69,
        "fullcodeline": "phdr->ts.nsecs = csec * 10000000;"
    },
    {
        "line": 102,
        "fullcodeline": "for (i = 0; i < hex_lines; i++) {"
    },
    {
        "line": 17,
        "fullcodeline": "*err = file_error(fh, err_info);"
    },
    {
        "line": 55,
        "fullcodeline": "line[16] = '\\0';"
    },
    {
        "line": 57,
        "fullcodeline": "} while (strcmp(line, \"OFFSET 0001-0203\") != 0);"
    },
    {
        "line": 88,
        "fullcodeline": "phdr->pkt_encap = WTAP_ENCAP_ETHERNET;"
    },
    {
        "line": 18,
        "fullcodeline": "if (*err == 0) {"
    },
    {
        "line": 32,
        "fullcodeline": "*err_info = g_strdup(\"toshiba: record header isn't valid\");"
    },
    {
        "line": 46,
        "fullcodeline": "if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {"
    },
    {
        "line": 62,
        "fullcodeline": "*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");"
    },
    {
        "line": 68,
        "fullcodeline": "phdr->ts.secs = hr * 3600 + min * 60 + sec;"
    },
    {
        "line": 76,
        "fullcodeline": "pseudo_header->isdn.uton = (direction[0] == 'T');"
    },
    {
        "line": 83,
        "fullcodeline": "pseudo_header->isdn.uton = (direction[0] == 'T');"
    },
    {
        "line": 90,
        "fullcodeline": "pseudo_header->eth.fcs_len = -1;"
    },
    {
        "line": 19,
        "fullcodeline": "*err = WTAP_ERR_SHORT_READ;"
    },
    {
        "line": 47,
        "fullcodeline": "*err = file_error(fh, err_info);"
    },
    {
        "line": 78,
        "fullcodeline": "strtol(&channel[1], NULL, 10);"
    },
    {
        "line": 103,
        "fullcodeline": "if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {"
    },
    {
        "line": 104,
        "fullcodeline": "*err = file_error(fh, err_info);"
    },
    {
        "line": 110,
        "fullcodeline": "if (!parse_single_hex_dump_line(line, pd, i * 16)) {"
    },
    {
        "line": 112,
        "fullcodeline": "*err_info = g_strdup(\"toshiba: hex dump not valid\");"
    }
]