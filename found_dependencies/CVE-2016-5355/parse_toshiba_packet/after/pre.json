[
    {
        "line": 4,
        "fullcodeline": "union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;"
    },
    {
        "line": 5,
        "fullcodeline": "char\tline[TOSHIBA_LINE_LENGTH];"
    },
    {
        "line": 9,
        "fullcodeline": "char\tchannel[10], direction[10];"
    },
    {
        "line": 28,
        "fullcodeline": "num_items_scanned = sscanf(line, \"%9d] %2d:%2d:%2d.%9d %9s %9s\","
    },
    {
        "line": 60,
        "fullcodeline": "num_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);"
    },
    {
        "line": 77,
        "fullcodeline": "phdr->rec_type = REC_TYPE_PACKET;"
    },
    {
        "line": 106,
        "fullcodeline": "ws_buffer_assure_space(buf, pkt_len);"
    },
    {
        "line": 107,
        "fullcodeline": "pd = ws_buffer_start_ptr(buf);"
    },
    {
        "line": 111,
        "fullcodeline": "hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);"
    },
    {
        "line": 17,
        "fullcodeline": "if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (pkt_len > WTAP_MAX_PACKET_SIZE) {"
    },
    {
        "line": 78,
        "fullcodeline": "phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;"
    },
    {
        "line": 80,
        "fullcodeline": "phdr->ts.nsecs = csec * 10000000;"
    },
    {
        "line": 113,
        "fullcodeline": "for (i = 0; i < hex_lines; i++) {"
    },
    {
        "line": 18,
        "fullcodeline": "*err = file_error(fh, err_info);"
    },
    {
        "line": 56,
        "fullcodeline": "line[16] = '\\0';"
    },
    {
        "line": 58,
        "fullcodeline": "} while (strcmp(line, \"OFFSET 0001-0203\") != 0);"
    },
    {
        "line": 99,
        "fullcodeline": "phdr->pkt_encap = WTAP_ENCAP_ETHERNET;"
    },
    {
        "line": 19,
        "fullcodeline": "if (*err == 0) {"
    },
    {
        "line": 33,
        "fullcodeline": "*err_info = g_strdup(\"toshiba: record header isn't valid\");"
    },
    {
        "line": 47,
        "fullcodeline": "if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {"
    },
    {
        "line": 63,
        "fullcodeline": "*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");"
    },
    {
        "line": 72,
        "fullcodeline": "*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\","
    },
    {
        "line": 79,
        "fullcodeline": "phdr->ts.secs = hr * 3600 + min * 60 + sec;"
    },
    {
        "line": 87,
        "fullcodeline": "pseudo_header->isdn.uton = (direction[0] == 'T');"
    },
    {
        "line": 94,
        "fullcodeline": "pseudo_header->isdn.uton = (direction[0] == 'T');"
    },
    {
        "line": 101,
        "fullcodeline": "pseudo_header->eth.fcs_len = -1;"
    },
    {
        "line": 20,
        "fullcodeline": "*err = WTAP_ERR_SHORT_READ;"
    },
    {
        "line": 48,
        "fullcodeline": "*err = file_error(fh, err_info);"
    },
    {
        "line": 89,
        "fullcodeline": "strtol(&channel[1], NULL, 10);"
    },
    {
        "line": 114,
        "fullcodeline": "if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {"
    },
    {
        "line": 115,
        "fullcodeline": "*err = file_error(fh, err_info);"
    },
    {
        "line": 121,
        "fullcodeline": "if (!parse_single_hex_dump_line(line, pd, i * 16)) {"
    },
    {
        "line": 123,
        "fullcodeline": "*err_info = g_strdup(\"toshiba: hex dump not valid\");"
    }
]