[
    {
        "line": 5,
        "fullcodeline": "struct sigaction oldact[3];"
    },
    {
        "line": 6,
        "fullcodeline": "int status = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "retval = pam_open_session (pamh, 0);"
    },
    {
        "line": 19,
        "fullcodeline": "memset(oldact, 0, sizeof(oldact));"
    },
    {
        "line": 21,
        "fullcodeline": "child = fork ();"
    },
    {
        "line": 39,
        "fullcodeline": "sigfillset (&ourset);"
    },
    {
        "line": 118,
        "fullcodeline": "cleanup_pam (PAM_SUCCESS);"
    },
    {
        "line": 10,
        "fullcodeline": "if (is_pam_failure(retval))"
    },
    {
        "line": 22,
        "fullcodeline": "if (child == (pid_t) -1)"
    },
    {
        "line": 29,
        "fullcodeline": "if (child == 0)"
    },
    {
        "line": 40,
        "fullcodeline": "if (sigprocmask (SIG_BLOCK, &ourset, NULL))"
    },
    {
        "line": 45,
        "fullcodeline": "if (!caught_signal)"
    },
    {
        "line": 74,
        "fullcodeline": "if (!caught_signal)"
    },
    {
        "line": 112,
        "fullcodeline": "if (caught_signal && child != (pid_t)-1)"
    },
    {
        "line": 12,
        "fullcodeline": "cleanup_pam (retval);"
    },
    {
        "line": 13,
        "fullcodeline": "errx (EXIT_FAILURE, _(\"cannot open session: %s\"),"
    },
    {
        "line": 24,
        "fullcodeline": "cleanup_pam (PAM_ABORT);"
    },
    {
        "line": 25,
        "fullcodeline": "err (EXIT_FAILURE, _(\"cannot create child process\"));"
    },
    {
        "line": 36,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 43,
        "fullcodeline": "caught_signal = true;"
    },
    {
        "line": 48,
        "fullcodeline": "action.sa_handler = su_catch_sig;"
    },
    {
        "line": 50,
        "fullcodeline": "action.sa_flags = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "sigemptyset (&ourset);"
    },
    {
        "line": 114,
        "fullcodeline": "fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));"
    },
    {
        "line": 115,
        "fullcodeline": "kill (child, SIGTERM);"
    },
    {
        "line": 14,
        "fullcodeline": "pam_strerror (pamh, retval));"
    },
    {
        "line": 17,
        "fullcodeline": "_pam_session_opened = 1;"
    },
    {
        "line": 37,
        "fullcodeline": "warn (_(\"cannot change directory to %s\"), \"/\");"
    },
    {
        "line": 42,
        "fullcodeline": "warn (_(\"cannot block signals\"));"
    },
    {
        "line": 52,
        "fullcodeline": "if (!same_session)"
    },
    {
        "line": 110,
        "fullcodeline": "status = 1;"
    },
    {
        "line": 122,
        "fullcodeline": "if (child != (pid_t)-1)"
    },
    {
        "line": 60,
        "fullcodeline": "if (!caught_signal && (sigaddset(&ourset, SIGTERM)"
    },
    {
        "line": 65,
        "fullcodeline": "caught_signal = true;"
    },
    {
        "line": 67,
        "fullcodeline": "if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])"
    },
    {
        "line": 71,
        "fullcodeline": "caught_signal = true;"
    },
    {
        "line": 79,
        "fullcodeline": "pid = waitpid (child, &status, WUNTRACED);"
    },
    {
        "line": 90,
        "fullcodeline": "if (pid != (pid_t)-1)"
    },
    {
        "line": 102,
        "fullcodeline": "child = (pid_t) -1;"
    },
    {
        "line": 125,
        "fullcodeline": "kill (child, SIGKILL);"
    },
    {
        "line": 148,
        "fullcodeline": "caught_signal = SIGKILL;"
    },
    {
        "line": 63,
        "fullcodeline": "|| sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {"
    },
    {
        "line": 64,
        "fullcodeline": "warn (_(\"cannot set signal handler\"));"
    },
    {
        "line": 68,
        "fullcodeline": "|| sigaction(SIGQUIT, &action, &oldact[2])))"
    },
    {
        "line": 70,
        "fullcodeline": "warn (_(\"cannot set signal handler\"));"
    },
    {
        "line": 92,
        "fullcodeline": "if (WIFSIGNALED (status))"
    },
    {
        "line": 126,
        "fullcodeline": "fprintf (stderr, _(\" ...killed.\\n\"));"
    },
    {
        "line": 54,
        "fullcodeline": "if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))"
    },
    {
        "line": 57,
        "fullcodeline": "caught_signal = true;"
    },
    {
        "line": 62,
        "fullcodeline": "|| sigaction(SIGTERM, &action, &oldact[0])"
    },
    {
        "line": 81,
        "fullcodeline": "if (pid != (pid_t)-1 && WIFSTOPPED (status))"
    },
    {
        "line": 83,
        "fullcodeline": "kill (getpid (), SIGSTOP);"
    },
    {
        "line": 85,
        "fullcodeline": "kill (pid, SIGCONT);"
    },
    {
        "line": 94,
        "fullcodeline": "fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),"
    },
    {
        "line": 96,
        "fullcodeline": "status = WTERMSIG (status) + 128;"
    },
    {
        "line": 56,
        "fullcodeline": "warn (_(\"cannot set signal handler\"));"
    },
    {
        "line": 61,
        "fullcodeline": "|| sigaddset(&ourset, SIGALRM)"
    },
    {
        "line": 99,
        "fullcodeline": "status = WEXITSTATUS (status);"
    },
    {
        "line": 105,
        "fullcodeline": "status = caught_signal + 128;"
    },
    {
        "line": 95,
        "fullcodeline": "WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");"
    },
    {
        "line": 107,
        "fullcodeline": "status = 1;"
    }
]