[
    {
        "line": 3,
        "fullcodeline": "auto result = make_uniq<CSVSniffFunctionData>();"
    },
    {
        "line": 4,
        "fullcodeline": "auto &config = DBConfig::GetConfig(context);"
    },
    {
        "line": 8,
        "fullcodeline": "result->path = input.inputs[0].ToString();"
    },
    {
        "line": 9,
        "fullcodeline": "auto it = input.named_parameters.find(\"auto_detect\");"
    },
    {
        "line": 17,
        "fullcodeline": "result->options.FromNamedParameters(input.named_parameters, context);"
    },
    {
        "line": 20,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 21,
        "fullcodeline": "names.emplace_back(\"Delimiter\");"
    },
    {
        "line": 23,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 24,
        "fullcodeline": "names.emplace_back(\"Quote\");"
    },
    {
        "line": 26,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 27,
        "fullcodeline": "names.emplace_back(\"Escape\");"
    },
    {
        "line": 29,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 30,
        "fullcodeline": "names.emplace_back(\"NewLineDelimiter\");"
    },
    {
        "line": 32,
        "fullcodeline": "return_types.emplace_back(LogicalType::UINTEGER);"
    },
    {
        "line": 33,
        "fullcodeline": "names.emplace_back(\"SkipRows\");"
    },
    {
        "line": 35,
        "fullcodeline": "return_types.emplace_back(LogicalType::BOOLEAN);"
    },
    {
        "line": 36,
        "fullcodeline": "names.emplace_back(\"HasHeader\");"
    },
    {
        "line": 38,
        "fullcodeline": "child_list_t<LogicalType> struct_children {{\"name\", LogicalType::VARCHAR}, {\"type\", LogicalType::VARCHAR}};"
    },
    {
        "line": 39,
        "fullcodeline": "auto list_child = LogicalType::STRUCT(struct_children);"
    },
    {
        "line": 40,
        "fullcodeline": "return_types.emplace_back(LogicalType::LIST(list_child));"
    },
    {
        "line": 41,
        "fullcodeline": "names.emplace_back(\"Columns\");"
    },
    {
        "line": 43,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 44,
        "fullcodeline": "names.emplace_back(\"DateFormat\");"
    },
    {
        "line": 46,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 47,
        "fullcodeline": "names.emplace_back(\"TimestampFormat\");"
    },
    {
        "line": 49,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 50,
        "fullcodeline": "names.emplace_back(\"UserArguments\");"
    },
    {
        "line": 52,
        "fullcodeline": "return_types.emplace_back(LogicalType::VARCHAR);"
    },
    {
        "line": 53,
        "fullcodeline": "names.emplace_back(\"Prompt\");"
    },
    {
        "line": 10,
        "fullcodeline": "if (it != input.named_parameters.end()) {"
    },
    {
        "line": 54,
        "fullcodeline": "return std::move(result);"
    },
    {
        "line": 15,
        "fullcodeline": "input.named_parameters.erase(\"auto_detect\");"
    },
    {
        "line": 6,
        "fullcodeline": "throw PermissionException(\"sniff_csv is disabled through configuration\");"
    },
    {
        "line": 11,
        "fullcodeline": "if (!it->second.GetValue<bool>()) {"
    },
    {
        "line": 12,
        "fullcodeline": "throw InvalidInputException(\"sniff_csv function does not accept auto_detect variable set to false\");"
    }
]