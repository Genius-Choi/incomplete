[
    {
        "line": 3,
        "fullcodeline": "if (clock_private_info->clock_id == 0) {"
    },
    {
        "line": 4,
        "fullcodeline": "debug(2, \"Follow_Up received before announcement -- discarded.\");"
    },
    {
        "line": 6,
        "fullcodeline": "clock_private_info->announcements_without_followups = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "if ((recv_len >= 0) && ((size_t)recv_len >= sizeof(struct ptp_follow_up_message))) {"
    },
    {
        "line": 9,
        "fullcodeline": "struct ptp_follow_up_message *msg = (struct ptp_follow_up_message *)buf;"
    },
    {
        "line": 10,
        "fullcodeline": "uint16_t seconds_hi = nctohs(&msg->follow_up.preciseOriginTimestamp[0]);"
    },
    {
        "line": 11,
        "fullcodeline": "uint32_t seconds_low = nctohl(&msg->follow_up.preciseOriginTimestamp[2]);"
    },
    {
        "line": 12,
        "fullcodeline": "uint32_t nanoseconds = nctohl(&msg->follow_up.preciseOriginTimestamp[6]);"
    },
    {
        "line": 13,
        "fullcodeline": "uint64_t preciseOriginTimestamp = seconds_hi;"
    },
    {
        "line": 14,
        "fullcodeline": "preciseOriginTimestamp = preciseOriginTimestamp << 32;"
    },
    {
        "line": 15,
        "fullcodeline": "preciseOriginTimestamp = preciseOriginTimestamp + seconds_low;"
    },
    {
        "line": 16,
        "fullcodeline": "preciseOriginTimestamp = preciseOriginTimestamp * 1000000000L;"
    },
    {
        "line": 17,
        "fullcodeline": "preciseOriginTimestamp = preciseOriginTimestamp + nanoseconds;"
    },
    {
        "line": 20,
        "fullcodeline": "int grandmasterClockIsStopped = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "clock_private_info->previous_preciseOriginTimestamp = preciseOriginTimestamp;"
    },
    {
        "line": 67,
        "fullcodeline": "int64_t correction_field = ntoh64(msg->header.correctionField);"
    },
    {
        "line": 72,
        "fullcodeline": "correction_field = correction_field / 65536; // might be signed"
    },
    {
        "line": 73,
        "fullcodeline": "uint64_t correctedPreciseOriginTimestamp = preciseOriginTimestamp + correction_field;"
    },
    {
        "line": 80,
        "fullcodeline": "clock_private_info->announcements_without_followups = 0; // we've seen a followup"
    },
    {
        "line": 84,
        "fullcodeline": "uint64_t offset = correctedPreciseOriginTimestamp - reception_time;"
    },
    {
        "line": 86,
        "fullcodeline": "int64_t jitter = 0;"
    },
    {
        "line": 88,
        "fullcodeline": "int64_t time_since_previous_offset = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "uint64_t smoothed_offset = offset;"
    },
    {
        "line": 219,
        "fullcodeline": "clock_private_info->previous_offset_grandmaster = clock_private_info->grandmasterIdentity;"
    },
    {
        "line": 224,
        "fullcodeline": "uint8_t *lastGmPhaseChange = tlv + 16;"
    },
    {
        "line": 225,
        "fullcodeline": "uint64_t lpt = nctoh64(lastGmPhaseChange + 4);"
    },
    {
        "line": 226,
        "fullcodeline": "uint64_t last_tlv_clock = nctoh64((uint8_t *)buf + 86);"
    },
    {
        "line": 227,
        "fullcodeline": "uint64_t huh = offset - lpt;"
    },
    {
        "line": 228,
        "fullcodeline": "debug_print_buffer(2, buf, (size_t)recv_len);"
    },
    {
        "line": 21,
        "fullcodeline": "if ((clock_private_info->previous_preciseOriginTimestamp == preciseOriginTimestamp) &&"
    },
    {
        "line": 75,
        "fullcodeline": "if (clock_private_info->follow_up_number < 100)"
    },
    {
        "line": 98,
        "fullcodeline": "if (clock_private_info->previous_offset_grandmaster !="
    },
    {
        "line": 122,
        "fullcodeline": "if (reset_clock_smoothing == 0) {"
    },
    {
        "line": 239,
        "fullcodeline": "debug(1, \"Follow_Up message is too small to be valid.\");"
    },
    {
        "line": 22,
        "fullcodeline": "(clock_private_info->clock_id == clock_private_info->grandmasterIdentity)) {"
    },
    {
        "line": 23,
        "fullcodeline": "clock_private_info->identical_previous_preciseOriginTimestamp_count++;"
    },
    {
        "line": 24,
        "fullcodeline": "grandmasterClockIsStopped = 1;"
    },
    {
        "line": 76,
        "fullcodeline": "clock_private_info->follow_up_number++;"
    },
    {
        "line": 100,
        "fullcodeline": "clock_private_info->previous_offset_time = 0;"
    },
    {
        "line": 139,
        "fullcodeline": "const int64_t clamping_limit = -2500000; // nanoseconds"
    },
    {
        "line": 141,
        "fullcodeline": "int64_t mastership_time = reception_time - clock_private_info->mastership_start_time;"
    },
    {
        "line": 187,
        "fullcodeline": "int64_t delta = smoothed_offset - offset;"
    },
    {
        "line": 208,
        "fullcodeline": "clock_private_info->previous_offset = smoothed_offset;"
    },
    {
        "line": 209,
        "fullcodeline": "clock_private_info->previous_offset_time = reception_time;"
    },
    {
        "line": 25,
        "fullcodeline": "if (clock_private_info->identical_previous_preciseOriginTimestamp_count == 8 * 60) {"
    },
    {
        "line": 48,
        "fullcodeline": "clock_private_info->identical_previous_preciseOriginTimestamp_count = 0;"
    },
    {
        "line": 124,
        "fullcodeline": "if (clock_private_info->previous_offset_time != 0) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (clock_private_info->mastership_start_time == 0)"
    },
    {
        "line": 147,
        "fullcodeline": "if (clock_private_info->previous_offset_time != 0) {"
    },
    {
        "line": 212,
        "fullcodeline": "reset_clock_smoothing = 0;"
    },
    {
        "line": 213,
        "fullcodeline": "clock_private_info->mastership_start_time = 0;"
    },
    {
        "line": 214,
        "fullcodeline": "clock_private_info->previous_offset = 0;"
    },
    {
        "line": 215,
        "fullcodeline": "clock_private_info->previous_offset_time ="
    },
    {
        "line": 26,
        "fullcodeline": "int64_t duration_of_mastership ="
    },
    {
        "line": 33,
        "fullcodeline": "int64_t wait_limit = 62;"
    },
    {
        "line": 34,
        "fullcodeline": "wait_limit = wait_limit * 1000000000;"
    },
    {
        "line": 125,
        "fullcodeline": "time_since_previous_offset = reception_time - clock_private_info->previous_offset_time;"
    },
    {
        "line": 126,
        "fullcodeline": "jitter = offset - clock_private_info->previous_offset;"
    },
    {
        "line": 143,
        "fullcodeline": "mastership_time = 0;"
    },
    {
        "line": 201,
        "fullcodeline": "update_master_clock_info(clock_private_info->grandmasterIdentity,"
    },
    {
        "line": 27,
        "fullcodeline": "reception_time - clock_private_info->mastership_start_time;"
    },
    {
        "line": 28,
        "fullcodeline": "if (clock_private_info->mastership_start_time == 0)"
    },
    {
        "line": 36,
        "fullcodeline": "if ((duration_of_mastership <= wait_limit) &&"
    },
    {
        "line": 148,
        "fullcodeline": "if (jitter < 0) {"
    },
    {
        "line": 181,
        "fullcodeline": "smoothed_offset = offset;"
    },
    {
        "line": 183,
        "fullcodeline": "clock_private_info->mastership_start_time ="
    },
    {
        "line": 202,
        "fullcodeline": "(const char *)&clock_private_info->ip, reception_time,"
    },
    {
        "line": 205,
        "fullcodeline": "update_master_clock_info(0, NULL, 0, 0, 0); // the SMI may have obsolete stuff in it"
    },
    {
        "line": 29,
        "fullcodeline": "duration_of_mastership = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "(clock_private_info->clock_id == clock_private_info->grandmasterIdentity)) {"
    },
    {
        "line": 42,
        "fullcodeline": "send_awakening_announcement_sequence("
    },
    {
        "line": 149,
        "fullcodeline": "int64_t clamped_jitter = jitter;"
    },
    {
        "line": 158,
        "fullcodeline": "smoothed_offset = clock_private_info->previous_offset;"
    },
    {
        "line": 150,
        "fullcodeline": "if (clamped_jitter < clamping_limit) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (mastership_time > 1000000000)"
    },
    {
        "line": 151,
        "fullcodeline": "clamped_jitter = clamping_limit; // 0 means ignore a clamped value completely"
    },
    {
        "line": 160,
        "fullcodeline": "smoothed_offset += clamped_jitter / 256; // later, if jitter is negative"
    },
    {
        "line": 161,
        "fullcodeline": "} else if (mastership_time < 1000000000) {   // at the beginning"
    },
    {
        "line": 162,
        "fullcodeline": "smoothed_offset ="
    },
    {
        "line": 163,
        "fullcodeline": "clock_private_info->previous_offset +"
    },
    {
        "line": 167,
        "fullcodeline": "smoothed_offset ="
    },
    {
        "line": 164,
        "fullcodeline": "jitter /"
    },
    {
        "line": 168,
        "fullcodeline": "clock_private_info->previous_offset + jitter / 16; // later, if jitter is positive"
    }
]