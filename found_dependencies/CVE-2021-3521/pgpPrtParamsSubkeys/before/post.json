[
    {
        "line": 5,
        "fullcodeline": "const uint8_t *p = pkts;"
    },
    {
        "line": 6,
        "fullcodeline": "const uint8_t *pend = pkts + pktlen;"
    },
    {
        "line": 7,
        "fullcodeline": "pgpDigParams *digps = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "int count = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "int alloced = 10;"
    },
    {
        "line": 13,
        "fullcodeline": "digps = xmalloc(alloced * sizeof(*digps));"
    },
    {
        "line": 43,
        "fullcodeline": "rc = (p == pend) ? 0 : -1;"
    },
    {
        "line": 15,
        "fullcodeline": "while (p < pend) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (rc == 0) {"
    },
    {
        "line": 19,
        "fullcodeline": "p += (pkt.body - pkt.head) + pkt.blen;"
    },
    {
        "line": 46,
        "fullcodeline": "*subkeys = xrealloc(digps, count * sizeof(*digps));"
    },
    {
        "line": 47,
        "fullcodeline": "*subkeysCount = count;"
    },
    {
        "line": 16,
        "fullcodeline": "if (decodePkt(p, (pend - p), &pkt))"
    },
    {
        "line": 21,
        "fullcodeline": "if (pkt.tag == PGPTAG_PUBLIC_SUBKEY) {"
    },
    {
        "line": 51,
        "fullcodeline": "free(digps);"
    },
    {
        "line": 27,
        "fullcodeline": "digps[count] = pgpDigParamsNew(PGPTAG_PUBLIC_SUBKEY);"
    },
    {
        "line": 29,
        "fullcodeline": "digps[count]->userid = xstrdup(mainkey->userid);"
    },
    {
        "line": 40,
        "fullcodeline": "count++;"
    },
    {
        "line": 49,
        "fullcodeline": "for (i = 0; i < count; i++)"
    },
    {
        "line": 50,
        "fullcodeline": "pgpDigParamsFree(digps[i]);"
    },
    {
        "line": 22,
        "fullcodeline": "if (count == alloced) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (getKeyID(pkt.body, pkt.blen, digps[count]->signid)) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (pgpPrtKey(pkt.tag, pkt.body, pkt.blen, digps[count])) {"
    },
    {
        "line": 23,
        "fullcodeline": "alloced <<= 1;"
    },
    {
        "line": 24,
        "fullcodeline": "digps = xrealloc(digps, alloced * sizeof(*digps));"
    },
    {
        "line": 32,
        "fullcodeline": "pgpDigParamsFree(digps[count]);"
    },
    {
        "line": 37,
        "fullcodeline": "pgpDigParamsFree(digps[count]);"
    }
]