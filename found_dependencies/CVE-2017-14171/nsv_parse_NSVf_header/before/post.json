[
    {
        "line": 3,
        "fullcodeline": "NSVContext *nsv = s->priv_data;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *pb = s->pb;"
    },
    {
        "line": 12,
        "fullcodeline": "nsv->state = NSV_UNSYNC; /* in case we fail */"
    },
    {
        "line": 14,
        "fullcodeline": "size = avio_rl32(pb);"
    },
    {
        "line": 17,
        "fullcodeline": "nsv->NSVf_end = size;"
    },
    {
        "line": 19,
        "fullcodeline": "file_size = (uint32_t)avio_rl32(pb);"
    },
    {
        "line": 20,
        "fullcodeline": "av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);"
    },
    {
        "line": 21,
        "fullcodeline": "av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);"
    },
    {
        "line": 23,
        "fullcodeline": "nsv->duration = duration = avio_rl32(pb); /* in ms */"
    },
    {
        "line": 27,
        "fullcodeline": "strings_size = avio_rl32(pb);"
    },
    {
        "line": 28,
        "fullcodeline": "table_entries = avio_rl32(pb);"
    },
    {
        "line": 29,
        "fullcodeline": "table_entries_used = avio_rl32(pb);"
    },
    {
        "line": 30,
        "fullcodeline": "av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\","
    },
    {
        "line": 99,
        "fullcodeline": "avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */"
    },
    {
        "line": 103,
        "fullcodeline": "nsv->state = NSV_HAS_READ_NSVF;"
    },
    {
        "line": 15,
        "fullcodeline": "if (size < 28)"
    },
    {
        "line": 32,
        "fullcodeline": "if (avio_feof(pb))"
    },
    {
        "line": 37,
        "fullcodeline": "if (strings_size > 0) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (avio_feof(pb))"
    },
    {
        "line": 74,
        "fullcodeline": "if (table_entries_used > 0) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (avio_feof(pb))"
    },
    {
        "line": 43,
        "fullcodeline": "p = strings = av_mallocz((size_t)strings_size + 1);"
    },
    {
        "line": 46,
        "fullcodeline": "endp = strings + strings_size;"
    },
    {
        "line": 47,
        "fullcodeline": "avio_read(pb, strings, strings_size);"
    },
    {
        "line": 67,
        "fullcodeline": "av_free(strings);"
    },
    {
        "line": 76,
        "fullcodeline": "nsv->index_entries = table_entries_used;"
    },
    {
        "line": 79,
        "fullcodeline": "nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));"
    },
    {
        "line": 16,
        "fullcodeline": "return -1;"
    },
    {
        "line": 33,
        "fullcodeline": "return -1;"
    },
    {
        "line": 44,
        "fullcodeline": "if (!p)"
    },
    {
        "line": 48,
        "fullcodeline": "while (p < endp) {"
    },
    {
        "line": 70,
        "fullcodeline": "return -1;"
    },
    {
        "line": 77,
        "fullcodeline": "if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))"
    },
    {
        "line": 80,
        "fullcodeline": "if (!nsv->nsvs_file_offset)"
    },
    {
        "line": 83,
        "fullcodeline": "for(i=0;i<table_entries_used;i++)"
    },
    {
        "line": 84,
        "fullcodeline": "nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;"
    },
    {
        "line": 86,
        "fullcodeline": "if(table_entries > table_entries_used &&"
    },
    {
        "line": 102,
        "fullcodeline": "return -1;"
    },
    {
        "line": 53,
        "fullcodeline": "token = p;"
    },
    {
        "line": 54,
        "fullcodeline": "p = strchr(p, '=');"
    },
    {
        "line": 57,
        "fullcodeline": "*p++ = '\\0';"
    },
    {
        "line": 59,
        "fullcodeline": "value = p;"
    },
    {
        "line": 60,
        "fullcodeline": "p = strchr(p, quote);"
    },
    {
        "line": 63,
        "fullcodeline": "*p++ = '\\0';"
    },
    {
        "line": 64,
        "fullcodeline": "av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);"
    },
    {
        "line": 65,
        "fullcodeline": "av_dict_set(&s->metadata, token, value, 0);"
    },
    {
        "line": 87,
        "fullcodeline": "avio_rl32(pb) == MKTAG('T','O','C','2')) {"
    },
    {
        "line": 88,
        "fullcodeline": "nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));"
    },
    {
        "line": 45,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 49,
        "fullcodeline": "while (*p == ' ')"
    },
    {
        "line": 50,
        "fullcodeline": "p++; /* strip out spaces */"
    },
    {
        "line": 51,
        "fullcodeline": "if (p >= endp-2)"
    },
    {
        "line": 55,
        "fullcodeline": "if (!p || p >= endp-2)"
    },
    {
        "line": 61,
        "fullcodeline": "if (!p || p >= endp)"
    },
    {
        "line": 78,
        "fullcodeline": "return -1;"
    },
    {
        "line": 81,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 89,
        "fullcodeline": "if (!nsv->nsvs_timestamps)"
    },
    {
        "line": 91,
        "fullcodeline": "for(i=0;i<table_entries_used;i++) {"
    },
    {
        "line": 58,
        "fullcodeline": "quote = *p++;"
    },
    {
        "line": 92,
        "fullcodeline": "nsv->nsvs_timestamps[i] = avio_rl32(pb);"
    },
    {
        "line": 90,
        "fullcodeline": "return AVERROR(ENOMEM);"
    }
]