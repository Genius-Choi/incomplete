[
    {
        "line": 11,
        "fullcodeline": "h2o_iovec_t *http2_origin_frame = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "long ssl_options = SSL_OP_ALL;"
    },
    {
        "line": 13,
        "fullcodeline": "int use_neverbleed = 1, use_picotls = 1; /* enabled by default */"
    },
    {
        "line": 14,
        "fullcodeline": "ptls_cipher_suite_t **cipher_suite_tls13 = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "} ech = {NULL};"
    },
    {
        "line": 154,
        "fullcodeline": "*ocsp_stapling = (struct listener_ssl_ocsp_stapling_t){"
    },
    {
        "line": 236,
        "fullcodeline": "memset(ssl_config, 0, sizeof(*ssl_config));"
    },
    {
        "line": 237,
        "fullcodeline": "h2o_vector_reserve(NULL, &listener->ssl, listener->ssl.size + 1);"
    },
    {
        "line": 238,
        "fullcodeline": "listener->ssl.entries[listener->ssl.size++] = ssl_config;"
    },
    {
        "line": 242,
        "fullcodeline": "ssl_config->http2_origin_frame = http2_origin_frame;"
    },
    {
        "line": 243,
        "fullcodeline": "ssl_config->identities = h2o_mem_alloc(sizeof(*ssl_config->identities) * (num_parsed_identities + 1));"
    },
    {
        "line": 386,
        "fullcodeline": "ssl_config->identities[num_parsed_identities].certificate_file = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!listener_is_new) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (ssl_node == NULL)"
    },
    {
        "line": 89,
        "fullcodeline": "if (cipher_preference_node != NULL) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (neverbleed_node != NULL && (use_neverbleed = (int)h2o_configurator_get_one_of(cmd, *neverbleed_node, \"off,on\")) == -1)"
    },
    {
        "line": 103,
        "fullcodeline": "if (http2_origin_frame_node != NULL) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (min_version != NULL) {"
    },
    {
        "line": 143,
        "fullcodeline": "if (max_version != NULL) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (ocsp_update_cmd != NULL)"
    },
    {
        "line": 161,
        "fullcodeline": "if (ocsp_max_failures_node != NULL) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (ocsp_update_interval_node != NULL) {"
    },
    {
        "line": 173,
        "fullcodeline": "if (ctx->hostconf != NULL) {"
    },
    {
        "line": 217,
        "fullcodeline": "if (ech_node != NULL) {"
    },
    {
        "line": 239,
        "fullcodeline": "if (ctx->hostconf != NULL) {"
    },
    {
        "line": 246,
        "fullcodeline": "for (size_t identity_index = 0; identity_index < num_parsed_identities; ++identity_index) {"
    },
    {
        "line": 389,
        "fullcodeline": "if (cc_node != NULL) {"
    },
    {
        "line": 411,
        "fullcodeline": "if (initcwnd_node != NULL) {"
    },
    {
        "line": 426,
        "fullcodeline": "return -1;"
    },
    {
        "line": 36,
        "fullcodeline": "if (h2o_configurator_parse_mapping(cmd, *ssl_node, NULL,"
    },
    {
        "line": 46,
        "fullcodeline": "if (identity_node != NULL) {"
    },
    {
        "line": 126,
        "fullcodeline": "MAP(\"sslv2\", 0);"
    },
    {
        "line": 127,
        "fullcodeline": "MAP(\"sslv3\", SSL_OP_NO_SSLv2);"
    },
    {
        "line": 128,
        "fullcodeline": "MAP(\"tlsv1\", SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);"
    },
    {
        "line": 129,
        "fullcodeline": "MAP(\"tlsv1.1\", SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);"
    },
    {
        "line": 137,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *min_version, \"unknown protocol version: %s\", (*min_version)->data.scalar);"
    },
    {
        "line": 240,
        "fullcodeline": "listener_setup_ssl_add_host(ssl_config, ctx->hostconf->authority.hostport);"
    },
    {
        "line": 248,
        "fullcodeline": "struct listener_ssl_parsed_identity_t *parsed = &parsed_identities[identity_index];"
    },
    {
        "line": 249,
        "fullcodeline": "struct listener_ssl_identity_t *identity = &ssl_config->identities[identity_index];"
    },
    {
        "line": 250,
        "fullcodeline": "*identity = (struct listener_ssl_identity_t){"
    },
    {
        "line": 260,
        "fullcodeline": "identity->ossl = SSL_CTX_new(SSLv23_server_method());"
    },
    {
        "line": 261,
        "fullcodeline": "SSL_CTX_set_options(identity->ossl, ssl_options);"
    },
    {
        "line": 273,
        "fullcodeline": "setup_ecc_key(identity->ossl);"
    },
    {
        "line": 304,
        "fullcodeline": "SSL_CTX_set_tlsext_status_cb(identity->ossl, on_staple_ocsp_ossl);"
    },
    {
        "line": 305,
        "fullcodeline": "SSL_CTX_set_tlsext_status_arg(identity->ossl, identity);"
    },
    {
        "line": 21,
        "fullcodeline": "if (listener->ssl.size != 0 && ssl_node == NULL) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (listener->ssl.size == 0 && ssl_node != NULL) {"
    },
    {
        "line": 56,
        "fullcodeline": "parsed_identities = alloca(sizeof(*parsed_identities) * (*identity_node)->data.sequence.size);"
    },
    {
        "line": 57,
        "fullcodeline": "num_parsed_identities = (*identity_node)->data.sequence.size;"
    },
    {
        "line": 90,
        "fullcodeline": "switch (h2o_configurator_get_one_of(cmd, *cipher_preference_node, \"client,server\")) {"
    },
    {
        "line": 102,
        "fullcodeline": "return -1;"
    },
    {
        "line": 141,
        "fullcodeline": "ssl_options |= SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3;"
    },
    {
        "line": 144,
        "fullcodeline": "if (strcasecmp((*max_version)->data.scalar, \"tlsv1.3\") < 0) {"
    },
    {
        "line": 162,
        "fullcodeline": "if (h2o_configurator_scanf(cmd, *ocsp_max_failures_node, \"%u\", &ocsp_stapling->max_failures) != 0)"
    },
    {
        "line": 168,
        "fullcodeline": "if (ocsp_stapling->interval == 0)"
    },
    {
        "line": 174,
        "fullcodeline": "for (size_t i = 0; i != listener->ssl.size; ++i) {"
    },
    {
        "line": 207,
        "fullcodeline": "if (cipher_suite_tls13_node != NULL &&"
    },
    {
        "line": 218,
        "fullcodeline": "if (!use_picotls) {"
    },
    {
        "line": 222,
        "fullcodeline": "if (listener->ssl.size != 0) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (on_config_ech(cmd, *ech_node, &ech.create_opener, &ech.retry_configs) != 0)"
    },
    {
        "line": 274,
        "fullcodeline": "if (cipher_suite != NULL && SSL_CTX_set_cipher_list(identity->ossl, (*cipher_suite)->data.scalar) != 1) {"
    },
    {
        "line": 279,
        "fullcodeline": "if (dh_file != NULL) {"
    },
    {
        "line": 310,
        "fullcodeline": "if (load_ssl_identity(cmd, identity->ossl, &identity->cert_chain_pem, &raw_pubkey, use_neverbleed, parsed,"
    },
    {
        "line": 334,
        "fullcodeline": "if (identity == ssl_config->identities) {"
    },
    {
        "line": 351,
        "fullcodeline": "if (ocsp_stapling != NULL && (identity->ptls.ctx == NULL || !identity->ptls.ctx->use_raw_public_keys)) {"
    },
    {
        "line": 390,
        "fullcodeline": "if (listener->quic.ctx == NULL) {"
    },
    {
        "line": 412,
        "fullcodeline": "if (listener->quic.ctx == NULL) {"
    },
    {
        "line": 22,
        "fullcodeline": "h2o_configurator_errprintf(cmd, listen_node, \"cannot accept HTTP; already defined to accept HTTPS\");"
    },
    {
        "line": 26,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ssl_node, \"cannot accept HTTPS; already defined to accept HTTP\");"
    },
    {
        "line": 45,
        "fullcodeline": "return -1;"
    },
    {
        "line": 47,
        "fullcodeline": "if (certificate_file != NULL || key_file != NULL) {"
    },
    {
        "line": 52,
        "fullcodeline": "if ((*identity_node)->data.sequence.size == 0) {"
    },
    {
        "line": 58,
        "fullcodeline": "for (size_t src_index = 0; src_index != (*identity_node)->data.sequence.size; ++src_index) {"
    },
    {
        "line": 82,
        "fullcodeline": "num_parsed_identities = 1;"
    },
    {
        "line": 83,
        "fullcodeline": "parsed_identities[0].certificate_file = certificate_file;"
    },
    {
        "line": 84,
        "fullcodeline": "parsed_identities[0].key_file = key_file;"
    },
    {
        "line": 92,
        "fullcodeline": "ssl_options &= ~SSL_OP_CIPHER_SERVER_PREFERENCE;"
    },
    {
        "line": 95,
        "fullcodeline": "ssl_options |= SSL_OP_CIPHER_SERVER_PREFERENCE;"
    },
    {
        "line": 115,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *http2_origin_frame_node,"
    },
    {
        "line": 148,
        "fullcodeline": "use_picotls = 0;"
    },
    {
        "line": 155,
        "fullcodeline": ".interval = 4 * 60 * 60, /* default update interval of 4 hours */"
    },
    {
        "line": 156,
        "fullcodeline": ".max_failures = 3,       /* by default, permit 3 consecutive failures before temporary disabling OCSP stapling */"
    },
    {
        "line": 157,
        "fullcodeline": ".cmd = \"share/h2o/fetch-ocsp-response\","
    },
    {
        "line": 160,
        "fullcodeline": "ocsp_stapling->cmd = h2o_strdup(NULL, (*ocsp_update_cmd)->data.scalar, SIZE_MAX).base;"
    },
    {
        "line": 169,
        "fullcodeline": "ocsp_stapling = NULL;"
    },
    {
        "line": 180,
        "fullcodeline": "listener_setup_ssl_add_host(ssl_config, ctx->hostconf->authority.hostport);"
    },
    {
        "line": 199,
        "fullcodeline": "use_neverbleed = 0;"
    },
    {
        "line": 208,
        "fullcodeline": "(cipher_suite_tls13 = parse_tls13_ciphers(cmd, *cipher_suite_tls13_node, listener->quic.ctx != NULL)) == NULL)"
    },
    {
        "line": 210,
        "fullcodeline": "} else if (listener->quic.ctx != NULL) {"
    },
    {
        "line": 219,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ech_node, \"ECH requires use of TLS 1.3\");"
    },
    {
        "line": 223,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ech_node, \"only the first `ssl` node for each address may have `ech` configured\");"
    },
    {
        "line": 228,
        "fullcodeline": "} else if (listener->ssl.size != 0 && listener->ssl.entries[0]->identities[0].ptls.ctx != NULL) {"
    },
    {
        "line": 275,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *cipher_suite, \"failed to setup SSL cipher suite\\n\");"
    },
    {
        "line": 276,
        "fullcodeline": "ERR_print_errors_cb(on_openssl_print_errors, stderr);"
    },
    {
        "line": 280,
        "fullcodeline": "BIO *bio = BIO_new_file((*dh_file)->data.scalar, \"r\");"
    },
    {
        "line": 286,
        "fullcodeline": "DH *dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);"
    },
    {
        "line": 287,
        "fullcodeline": "BIO_free(bio);"
    },
    {
        "line": 293,
        "fullcodeline": "SSL_CTX_set_tmp_dh(identity->ossl, dh);"
    },
    {
        "line": 294,
        "fullcodeline": "SSL_CTX_set_options(identity->ossl, SSL_OP_SINGLE_DH_USE);"
    },
    {
        "line": 295,
        "fullcodeline": "DH_free(dh);"
    },
    {
        "line": 315,
        "fullcodeline": "const char *errstr = listener_setup_ssl_picotls(listener, identity, raw_pubkey, cipher_suite_tls13,"
    },
    {
        "line": 352,
        "fullcodeline": "identity->ocsp_stapling = ocsp_stapling;"
    },
    {
        "line": 392,
        "fullcodeline": "ssl_config->cc.tcp = h2o_strdup(NULL, (*cc_node)->data.scalar, SIZE_MAX);"
    },
    {
        "line": 23,
        "fullcodeline": "return -1;"
    },
    {
        "line": 27,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *identity_node,"
    },
    {
        "line": 53,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *identity_node, \"at least one identity must be specified\");"
    },
    {
        "line": 69,
        "fullcodeline": "size_t dst_index = (src_index + 1) % (*identity_node)->data.sequence.size;"
    },
    {
        "line": 76,
        "fullcodeline": "if (certificate_file == NULL || key_file == NULL) {"
    },
    {
        "line": 98,
        "fullcodeline": "return -1;"
    },
    {
        "line": 106,
        "fullcodeline": "if ((http2_origin_frame = build_http2_origin_frame(cmd, http2_origin_frame_node, 1)) == NULL)"
    },
    {
        "line": 110,
        "fullcodeline": "if ((http2_origin_frame = build_http2_origin_frame(cmd, (*http2_origin_frame_node)->data.sequence.elements,"
    },
    {
        "line": 117,
        "fullcodeline": "return -1;"
    },
    {
        "line": 177,
        "fullcodeline": "if (!ssl_identity_is_equal(ssl_config, parsed_identities, num_parsed_identities))"
    },
    {
        "line": 211,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ssl_node, \"QUIC support requires TLS 1.3 using picotls\");"
    },
    {
        "line": 229,
        "fullcodeline": "ptls_context_t *base = listener->ssl.entries[0]->identities[0].ptls.ctx;"
    },
    {
        "line": 281,
        "fullcodeline": "if (bio == NULL) {"
    },
    {
        "line": 288,
        "fullcodeline": "if (dh == NULL) {"
    },
    {
        "line": 318,
        "fullcodeline": "if (errstr != NULL) {"
    },
    {
        "line": 326,
        "fullcodeline": "if (listener->quic.ctx != NULL && listener->quic.ctx->tls == NULL)"
    },
    {
        "line": 336,
        "fullcodeline": "if (listener->ssl.size == 1) {"
    },
    {
        "line": 342,
        "fullcodeline": "if (identity->ptls.ctx != NULL)"
    },
    {
        "line": 346,
        "fullcodeline": "SSL_CTX_free(identity->ossl);"
    },
    {
        "line": 347,
        "fullcodeline": "identity->ossl = NULL;"
    },
    {
        "line": 419,
        "fullcodeline": "listener->quic.ctx->initcwnd_packets = initcwnd_packets;"
    },
    {
        "line": 50,
        "fullcodeline": "return -1;"
    },
    {
        "line": 54,
        "fullcodeline": "return -1;"
    },
    {
        "line": 60,
        "fullcodeline": "if (src->type != YOML_TYPE_MAPPING) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (h2o_configurator_parse_mapping(cmd, src, \"certificate-file:s,key-file:s\", NULL,"
    },
    {
        "line": 77,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ssl_node, \"cannot find mandatory attribute: %s\","
    },
    {
        "line": 253,
        "fullcodeline": ".dynamic ="
    },
    {
        "line": 282,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *dh_file, \"failed to load dhparam file:%s\\n\", (*dh_file)->data.scalar);"
    },
    {
        "line": 283,
        "fullcodeline": "ERR_print_errors_cb(on_openssl_print_errors, stderr);"
    },
    {
        "line": 289,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *dh_file, \"failed to load dhparam file:%s\\n\", (*dh_file)->data.scalar);"
    },
    {
        "line": 290,
        "fullcodeline": "ERR_print_errors_cb(on_openssl_print_errors, stderr);"
    },
    {
        "line": 316,
        "fullcodeline": "!!(ssl_options & SSL_OP_CIPHER_SERVER_PREFERENCE), use_neverbleed,"
    },
    {
        "line": 324,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ssl_node, \"%s; TLS 1.3 will be disabled\", errstr);"
    },
    {
        "line": 328,
        "fullcodeline": "} else if (raw_pubkey.base != NULL) {"
    },
    {
        "line": 338,
        "fullcodeline": "SSL_CTX_set_tlsext_servername_callback(ossl, on_sni_callback);"
    },
    {
        "line": 339,
        "fullcodeline": "SSL_CTX_set_tlsext_servername_arg(ossl, listener);"
    },
    {
        "line": 343,
        "fullcodeline": "h2o_socket_ssl_set_picotls_context(identity->ossl, identity->ptls.ctx);"
    },
    {
        "line": 396,
        "fullcodeline": "for (cand = quicly_cc_all_types; *cand != NULL; ++cand)"
    },
    {
        "line": 399,
        "fullcodeline": "if (*cand != NULL) {"
    },
    {
        "line": 61,
        "fullcodeline": "h2o_configurator_errprintf(cmd, src, \"elements of `identity` must be a mapping\");"
    },
    {
        "line": 78,
        "fullcodeline": "certificate_file == NULL ? \"certificate-file\" : \"key-file\");"
    },
    {
        "line": 79,
        "fullcodeline": "return -1;"
    },
    {
        "line": 107,
        "fullcodeline": "return -1;"
    },
    {
        "line": 112,
        "fullcodeline": "return -1;"
    },
    {
        "line": 254,
        "fullcodeline": "{"
    },
    {
        "line": 320,
        "fullcodeline": "if (identity != ssl_config->identities || listener->quic.ctx != NULL) {"
    },
    {
        "line": 329,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->certificate_file, \"raw public key can only be used with TLS 1.3 or QUIC\");"
    },
    {
        "line": 356,
        "fullcodeline": "h2o_multithread_create_thread(&tid, NULL, ocsp_updater_thread, identity);"
    },
    {
        "line": 364,
        "fullcodeline": "fprintf(stderr, \"[OCSP Stapling] testing for certificate file:%s\\n\", identity->certificate_file);"
    },
    {
        "line": 397,
        "fullcodeline": "if (strcasecmp((*cand)->name, (*cc_node)->data.scalar) == 0)"
    },
    {
        "line": 402,
        "fullcodeline": "ssl_config->cc.quic = *cand;"
    },
    {
        "line": 62,
        "fullcodeline": "return -1;"
    },
    {
        "line": 73,
        "fullcodeline": "return -1;"
    },
    {
        "line": 251,
        "fullcodeline": ".certificate_file = h2o_strdup(NULL, (*parsed->certificate_file)->data.scalar, SIZE_MAX).base,"
    },
    {
        "line": 252,
        "fullcodeline": ".key_file = h2o_strdup(NULL, (*parsed->key_file)->data.scalar, SIZE_MAX).base,"
    },
    {
        "line": 321,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *ssl_node, \"%s\", errstr);"
    },
    {
        "line": 365,
        "fullcodeline": "switch (get_ocsp_response(ocsp_stapling->cmd, identity->cert_chain_pem, &respbuf)) {"
    },
    {
        "line": 404,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *cc_node, \"specified congestion controller is unknown or unsupported for QUIC\");"
    },
    {
        "line": 255,
        "fullcodeline": ".mutex = PTHREAD_MUTEX_INITIALIZER,"
    },
    {
        "line": 367,
        "fullcodeline": "h2o_buffer_dispose(&respbuf);"
    },
    {
        "line": 368,
        "fullcodeline": "fprintf(stderr, \"[OCSP Stapling] stapling works for file:%s\\n\", identity->certificate_file);"
    },
    {
        "line": 371,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->certificate_file, \"[OCSP Stapling] temporary failed for file:%s\\n\","
    },
    {
        "line": 375,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->certificate_file,"
    }
]