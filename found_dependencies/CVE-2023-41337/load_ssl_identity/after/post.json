[
    {
        "line": 5,
        "fullcodeline": "*cert_chain_pem = h2o_iovec_init(NULL, 0);"
    },
    {
        "line": 6,
        "fullcodeline": "*raw_pubkey = (ptls_iovec_t){};"
    },
    {
        "line": 10,
        "fullcodeline": "if (ptls_load_pem_objects((*parsed->certificate_file)->data.scalar, \"PUBLIC KEY\", raw_pubkey, 1, &raw_pubkey_count) != 0 ||"
    },
    {
        "line": 54,
        "fullcodeline": "if (client_ca_file != NULL) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (raw_pubkey_count == 0) {"
    },
    {
        "line": 11,
        "fullcodeline": "raw_pubkey_count == 0) {"
    },
    {
        "line": 29,
        "fullcodeline": "char errbuf[NEVERBLEED_ERRBUF_SIZE];"
    },
    {
        "line": 55,
        "fullcodeline": "SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);"
    },
    {
        "line": 63,
        "fullcodeline": "X509_VERIFY_PARAM *vpm = X509_STORE_get0_param(SSL_CTX_get_cert_store(ssl_ctx));"
    },
    {
        "line": 64,
        "fullcodeline": "int ret = X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_PARTIAL_CHAIN);"
    },
    {
        "line": 65,
        "fullcodeline": "assert(ret == 1);"
    },
    {
        "line": 70,
        "fullcodeline": "uint8_t session_ctx[SSL_MAX_SID_CTX_LENGTH];"
    },
    {
        "line": 72,
        "fullcodeline": "H2O_BUILD_ASSERT(sizeof(session_ctx) == SHA256_DIGEST_LENGTH);"
    },
    {
        "line": 73,
        "fullcodeline": "int ret = X509_digest(SSL_CTX_get0_certificate(ssl_ctx), EVP_sha256(), session_ctx, &session_ctx_len);"
    },
    {
        "line": 74,
        "fullcodeline": "assert(ret == 1);"
    },
    {
        "line": 75,
        "fullcodeline": "assert(session_ctx_len == sizeof(session_ctx));"
    },
    {
        "line": 76,
        "fullcodeline": "ret = SSL_CTX_set_session_id_context(ssl_ctx, session_ctx, sizeof(session_ctx));"
    },
    {
        "line": 77,
        "fullcodeline": "assert(ret == 1);"
    },
    {
        "line": 13,
        "fullcodeline": "if (SSL_CTX_use_certificate_chain_file(ssl_ctx, (*parsed->certificate_file)->data.scalar) != 1) {"
    },
    {
        "line": 19,
        "fullcodeline": "if ((*cert_chain_pem = h2o_file_read((*parsed->certificate_file)->data.scalar)).base == NULL) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (neverbleed == NULL) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (neverbleed_load_private_key_file(neverbleed, ssl_ctx, (*parsed->key_file)->data.scalar, errbuf) != 1) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (SSL_CTX_load_verify_locations(ssl_ctx, (*client_ca_file)->data.scalar, NULL) != 1) {"
    },
    {
        "line": 14,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->certificate_file, \"failed to load certificate file:%s\\n\","
    },
    {
        "line": 16,
        "fullcodeline": "ERR_print_errors_cb(on_openssl_print_errors, stderr);"
    },
    {
        "line": 20,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->certificate_file, \"failed to load certificate file:%s:%s\","
    },
    {
        "line": 31,
        "fullcodeline": "neverbleed_post_fork_cb = on_neverbleed_fork;"
    },
    {
        "line": 37,
        "fullcodeline": "neverbleed_transaction_cb = async_nb_transaction;"
    },
    {
        "line": 40,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->key_file, \"failed to load private key file:%s:%s\\n\","
    },
    {
        "line": 45,
        "fullcodeline": "if (SSL_CTX_use_PrivateKey_file(ssl_ctx, (*parsed->key_file)->data.scalar, SSL_FILETYPE_PEM) != 1) {"
    },
    {
        "line": 57,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *client_ca_file, \"failed to load client CA file:%s\\n\", (*client_ca_file)->data.scalar);"
    },
    {
        "line": 58,
        "fullcodeline": "ERR_print_errors_cb(on_openssl_print_errors, stderr);"
    },
    {
        "line": 17,
        "fullcodeline": "return -1;"
    },
    {
        "line": 21,
        "fullcodeline": "(*parsed->certificate_file)->data.scalar, strerror(errno));"
    },
    {
        "line": 22,
        "fullcodeline": "return -1;"
    },
    {
        "line": 33,
        "fullcodeline": "if (neverbleed_init(neverbleed, errbuf) != 0) {"
    },
    {
        "line": 42,
        "fullcodeline": "return -1;"
    },
    {
        "line": 46,
        "fullcodeline": "h2o_configurator_errprintf(cmd, *parsed->key_file, \"failed to load private key file:%s\\n\","
    },
    {
        "line": 48,
        "fullcodeline": "ERR_print_errors_cb(on_openssl_print_errors, stderr);"
    },
    {
        "line": 59,
        "fullcodeline": "return -1;"
    },
    {
        "line": 34,
        "fullcodeline": "fprintf(stderr, \"%s\\n\", errbuf);"
    },
    {
        "line": 35,
        "fullcodeline": "abort();"
    },
    {
        "line": 49,
        "fullcodeline": "return -1;"
    }
]