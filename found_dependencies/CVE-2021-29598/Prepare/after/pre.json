[
    {
        "line": 2,
        "fullcodeline": "const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);"
    },
    {
        "line": 3,
        "fullcodeline": "OpData* op_data = reinterpret_cast<OpData*>(node->user_data);"
    },
    {
        "line": 4,
        "fullcodeline": "int scratch_tensor_index = op_data->scratch_tensor_index;"
    },
    {
        "line": 7,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);"
    },
    {
        "line": 8,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);"
    },
    {
        "line": 11,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));"
    },
    {
        "line": 13,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,"
    },
    {
        "line": 16,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 19,
        "fullcodeline": "TF_LITE_ENSURE(context,"
    },
    {
        "line": 24,
        "fullcodeline": "const int rank = params->rank;"
    },
    {
        "line": 25,
        "fullcodeline": "const int batch_size = input->dims->data[0];"
    },
    {
        "line": 26,
        "fullcodeline": "const int num_filters = weights_feature->dims->data[0];"
    },
    {
        "line": 27,
        "fullcodeline": "TF_LITE_ENSURE(context, rank != 0);"
    },
    {
        "line": 28,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);"
    },
    {
        "line": 29,
        "fullcodeline": "const int num_units = num_filters / rank;"
    },
    {
        "line": 30,
        "fullcodeline": "const int memory_size = weights_time->dims->data[1];"
    },
    {
        "line": 31,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, input->dims->data[1],"
    },
    {
        "line": 33,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);"
    },
    {
        "line": 35,
        "fullcodeline": "const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);"
    },
    {
        "line": 41,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));"
    },
    {
        "line": 43,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 47,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);"
    },
    {
        "line": 48,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);"
    },
    {
        "line": 49,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),"
    },
    {
        "line": 53,
        "fullcodeline": "TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);"
    },
    {
        "line": 54,
        "fullcodeline": "output_size_array->data[0] = batch_size;"
    },
    {
        "line": 55,
        "fullcodeline": "output_size_array->data[1] = num_units;"
    },
    {
        "line": 56,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 60,
        "fullcodeline": "const bool is_hybrid_op = IsHybridOp(input, weights_feature);"
    },
    {
        "line": 61,
        "fullcodeline": "const bool is_full_integer = input->type == kTfLiteInt8;"
    },
    {
        "line": 64,
        "fullcodeline": "TfLiteIntArrayFree(node->temporaries);"
    },
    {
        "line": 72,
        "fullcodeline": "node->temporaries->data[0] = scratch_tensor_index;"
    },
    {
        "line": 74,
        "fullcodeline": "TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);"
    },
    {
        "line": 75,
        "fullcodeline": "scratch_size_array->data[0] = batch_size;"
    },
    {
        "line": 76,
        "fullcodeline": "scratch_size_array->data[1] = num_filters;"
    },
    {
        "line": 79,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 89,
        "fullcodeline": "scratch_tensor->allocation_type = kTfLiteArenaRw;"
    },
    {
        "line": 90,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,"
    },
    {
        "line": 17,
        "fullcodeline": "context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));"
    },
    {
        "line": 20,
        "fullcodeline": "input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);"
    },
    {
        "line": 44,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensor, &output));"
    },
    {
        "line": 50,
        "fullcodeline": "memory_size * num_filters);"
    },
    {
        "line": 57,
        "fullcodeline": "context->ResizeTensor(context, output, output_size_array));"
    },
    {
        "line": 80,
        "fullcodeline": "context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));"
    },
    {
        "line": 37,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);"
    },
    {
        "line": 66,
        "fullcodeline": "node->temporaries = TfLiteIntArrayCreate(6);"
    },
    {
        "line": 85,
        "fullcodeline": "scratch_tensor->type = kTfLiteInt32;"
    },
    {
        "line": 94,
        "fullcodeline": "op_data->compute_row_sums = true;"
    },
    {
        "line": 97,
        "fullcodeline": "node->temporaries->data[1] = scratch_tensor_index + 1;"
    },
    {
        "line": 99,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,"
    },
    {
        "line": 101,
        "fullcodeline": "input_quantized->type = weights_feature->type;"
    },
    {
        "line": 102,
        "fullcodeline": "input_quantized->allocation_type = kTfLiteArenaRw;"
    },
    {
        "line": 110,
        "fullcodeline": "node->temporaries->data[2] = scratch_tensor_index + 2;"
    },
    {
        "line": 112,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,"
    },
    {
        "line": 114,
        "fullcodeline": "scaling_factors->type = kTfLiteFloat32;"
    },
    {
        "line": 115,
        "fullcodeline": "scaling_factors->allocation_type = kTfLiteArenaRw;"
    },
    {
        "line": 116,
        "fullcodeline": "int scaling_dims[1] = {batch_size};"
    },
    {
        "line": 126,
        "fullcodeline": "node->temporaries->data[3] = scratch_tensor_index + 3;"
    },
    {
        "line": 128,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,"
    },
    {
        "line": 130,
        "fullcodeline": "float_weights_time->type = kTfLiteFloat32;"
    },
    {
        "line": 132,
        "fullcodeline": "float_weights_time->allocation_type = kTfLiteArenaRwPersistent;"
    },
    {
        "line": 141,
        "fullcodeline": "node->temporaries->data[4] = scratch_tensor_index + 4;"
    },
    {
        "line": 143,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 145,
        "fullcodeline": "zero_points->type = kTfLiteFloat32;"
    },
    {
        "line": 146,
        "fullcodeline": "zero_points->allocation_type = kTfLiteArenaRw;"
    },
    {
        "line": 147,
        "fullcodeline": "int zero_points_dims[1] = {batch_size};"
    },
    {
        "line": 155,
        "fullcodeline": "node->temporaries->data[5] = scratch_tensor_index + 5;"
    },
    {
        "line": 157,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 159,
        "fullcodeline": "row_sums->type = kTfLiteFloat32;"
    },
    {
        "line": 160,
        "fullcodeline": "row_sums->allocation_type = kTfLiteArenaRwPersistent;"
    },
    {
        "line": 161,
        "fullcodeline": "int row_sums_dims[1] = {num_filters};"
    },
    {
        "line": 171,
        "fullcodeline": "TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);"
    },
    {
        "line": 172,
        "fullcodeline": "output_temp_size_array->data[0] = num_units;"
    },
    {
        "line": 173,
        "fullcodeline": "output_temp_size_array->data[1] = batch_size;"
    },
    {
        "line": 174,
        "fullcodeline": "node->temporaries->data[1] = scratch_tensor_index + 1;"
    },
    {
        "line": 176,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 178,
        "fullcodeline": "output_temp->type = kTfLiteInt32;"
    },
    {
        "line": 179,
        "fullcodeline": "output_temp->allocation_type = kTfLiteArenaRw;"
    },
    {
        "line": 180,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,"
    },
    {
        "line": 184,
        "fullcodeline": "auto* input_params ="
    },
    {
        "line": 186,
        "fullcodeline": "auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>("
    },
    {
        "line": 188,
        "fullcodeline": "auto* state_params ="
    },
    {
        "line": 190,
        "fullcodeline": "auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>("
    },
    {
        "line": 192,
        "fullcodeline": "auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>("
    },
    {
        "line": 194,
        "fullcodeline": "const double effective_scale_1 = input_params->scale->data[0] *"
    },
    {
        "line": 197,
        "fullcodeline": "const double effective_scale_2 = state_params->scale->data[0] *"
    },
    {
        "line": 200,
        "fullcodeline": "QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,"
    },
    {
        "line": 202,
        "fullcodeline": "QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,"
    },
    {
        "line": 87,
        "fullcodeline": "scratch_tensor->type = kTfLiteFloat32;"
    },
    {
        "line": 103,
        "fullcodeline": "if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {"
    },
    {
        "line": 144,
        "fullcodeline": "context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));"
    },
    {
        "line": 148,
        "fullcodeline": "if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {"
    },
    {
        "line": 158,
        "fullcodeline": "GetTemporarySafe(context, node, /*index=*/5, &row_sums));"
    },
    {
        "line": 162,
        "fullcodeline": "if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {"
    },
    {
        "line": 177,
        "fullcodeline": "context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));"
    },
    {
        "line": 185,
        "fullcodeline": "reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);"
    },
    {
        "line": 189,
        "fullcodeline": "reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);"
    },
    {
        "line": 104,
        "fullcodeline": "TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);"
    },
    {
        "line": 105,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,"
    },
    {
        "line": 118,
        "fullcodeline": "TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);"
    },
    {
        "line": 119,
        "fullcodeline": "scaling_factors_size->data[0] = batch_size;"
    },
    {
        "line": 120,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,"
    },
    {
        "line": 134,
        "fullcodeline": "TfLiteIntArray* float_weights_time_size ="
    },
    {
        "line": 136,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 149,
        "fullcodeline": "TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);"
    },
    {
        "line": 150,
        "fullcodeline": "zero_points_size->data[0] = zero_points_dims[0];"
    },
    {
        "line": 151,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,"
    },
    {
        "line": 163,
        "fullcodeline": "TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);"
    },
    {
        "line": 164,
        "fullcodeline": "row_sums_size->data[0] = row_sums_dims[0];"
    },
    {
        "line": 165,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 68,
        "fullcodeline": "node->temporaries = TfLiteIntArrayCreate(2);"
    },
    {
        "line": 135,
        "fullcodeline": "TfLiteIntArrayCopy(weights_time->dims);"
    },
    {
        "line": 137,
        "fullcodeline": "context->ResizeTensor(context, float_weights_time,"
    },
    {
        "line": 166,
        "fullcodeline": "context, context->ResizeTensor(context, row_sums, row_sums_size));"
    },
    {
        "line": 70,
        "fullcodeline": "node->temporaries = TfLiteIntArrayCreate(1);"
    }
]