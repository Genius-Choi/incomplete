[
    {
        "line": 5,
        "fullcodeline": "cleanup_free char *base_path = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *old_cwd = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int event_fd = -1;"
    },
    {
        "line": 10,
        "fullcodeline": "int child_wait_fd = -1;"
    },
    {
        "line": 18,
        "fullcodeline": "real_uid = getuid ();"
    },
    {
        "line": 19,
        "fullcodeline": "real_gid = getgid ();"
    },
    {
        "line": 22,
        "fullcodeline": "acquire_privs ();"
    },
    {
        "line": 31,
        "fullcodeline": "read_overflowids ();"
    },
    {
        "line": 33,
        "fullcodeline": "argv0 = argv[0];"
    },
    {
        "line": 38,
        "fullcodeline": "argv++;"
    },
    {
        "line": 39,
        "fullcodeline": "argc--;"
    },
    {
        "line": 44,
        "fullcodeline": "parse_args (&argc, &argv);"
    },
    {
        "line": 76,
        "fullcodeline": "__debug__ ((\"Creating root mount point\\n\"));"
    },
    {
        "line": 94,
        "fullcodeline": "proc_fd = open (\"/proc\", O_RDONLY | O_PATH);"
    },
    {
        "line": 100,
        "fullcodeline": "base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);"
    },
    {
        "line": 109,
        "fullcodeline": "__debug__ ((\"creating new namespace\\n\"));"
    },
    {
        "line": 119,
        "fullcodeline": "block_sigchild ();"
    },
    {
        "line": 121,
        "fullcodeline": "clone_flags = SIGCHLD | CLONE_NEWNS;"
    },
    {
        "line": 147,
        "fullcodeline": "child_wait_fd = eventfd (0, EFD_CLOEXEC);"
    },
    {
        "line": 151,
        "fullcodeline": "pid = raw_clone (clone_flags, NULL);"
    },
    {
        "line": 165,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 166,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 229,
        "fullcodeline": "res = read (child_wait_fd, &val, 8);"
    },
    {
        "line": 230,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 236,
        "fullcodeline": "switch_to_user_with_privs ();"
    },
    {
        "line": 241,
        "fullcodeline": "ns_uid = opt_sandbox_uid;"
    },
    {
        "line": 242,
        "fullcodeline": "ns_gid = opt_sandbox_gid;"
    },
    {
        "line": 263,
        "fullcodeline": "old_umask = umask (0);"
    },
    {
        "line": 266,
        "fullcodeline": "resolve_symlinks_in_ops ();"
    },
    {
        "line": 278,
        "fullcodeline": "old_cwd = get_current_dir_name ();"
    },
    {
        "line": 383,
        "fullcodeline": "drop_privs ();"
    },
    {
        "line": 414,
        "fullcodeline": "umask (old_umask);"
    },
    {
        "line": 416,
        "fullcodeline": "new_cwd = \"/\";"
    },
    {
        "line": 436,
        "fullcodeline": "xsetenv (\"PWD\", new_cwd, 1);"
    },
    {
        "line": 437,
        "fullcodeline": "free (old_cwd);"
    },
    {
        "line": 439,
        "fullcodeline": "__debug__ ((\"forking for child\\n\"));"
    },
    {
        "line": 475,
        "fullcodeline": "__debug__ ((\"launch executable %s\\n\", argv[0]));"
    },
    {
        "line": 484,
        "fullcodeline": "unblock_sigchild ();"
    },
    {
        "line": 25,
        "fullcodeline": "if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)"
    },
    {
        "line": 35,
        "fullcodeline": "if (isatty (1))"
    },
    {
        "line": 41,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 48,
        "fullcodeline": "if (!is_privileged && getuid () != 0)"
    },
    {
        "line": 51,
        "fullcodeline": "if (opt_unshare_user_try &&"
    },
    {
        "line": 73,
        "fullcodeline": "if (argc == 0)"
    },
    {
        "line": 78,
        "fullcodeline": "if (opt_sandbox_uid == -1)"
    },
    {
        "line": 80,
        "fullcodeline": "if (opt_sandbox_gid == -1)"
    },
    {
        "line": 83,
        "fullcodeline": "if (!opt_unshare_user && opt_sandbox_uid != real_uid)"
    },
    {
        "line": 86,
        "fullcodeline": "if (!opt_unshare_user && opt_sandbox_gid != real_gid)"
    },
    {
        "line": 89,
        "fullcodeline": "if (!opt_unshare_uts && opt_sandbox_hostname != NULL)"
    },
    {
        "line": 95,
        "fullcodeline": "if (proc_fd == -1)"
    },
    {
        "line": 101,
        "fullcodeline": "if (mkdir (base_path, 0755) && errno != EEXIST)"
    },
    {
        "line": 148,
        "fullcodeline": "if (child_wait_fd == -1)"
    },
    {
        "line": 152,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 168,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 225,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 238,
        "fullcodeline": "if (opt_unshare_net && loopback_setup () != 0)"
    },
    {
        "line": 243,
        "fullcodeline": "if (!is_privileged && opt_unshare_user)"
    },
    {
        "line": 271,
        "fullcodeline": "if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)"
    },
    {
        "line": 275,
        "fullcodeline": "if (mount (\"\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)"
    },
    {
        "line": 282,
        "fullcodeline": "if (chdir (base_path) != 0)"
    },
    {
        "line": 290,
        "fullcodeline": "if (mkdir (\"newroot\", 0755))"
    },
    {
        "line": 293,
        "fullcodeline": "if (mkdir (\"oldroot\", 0755))"
    },
    {
        "line": 296,
        "fullcodeline": "if (pivot_root (base_path, \"oldroot\"))"
    },
    {
        "line": 299,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 353,
        "fullcodeline": "if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)"
    },
    {
        "line": 356,
        "fullcodeline": "if (umount2 (\"oldroot\", MNT_DETACH))"
    },
    {
        "line": 359,
        "fullcodeline": "if (opt_unshare_user &&"
    },
    {
        "line": 375,
        "fullcodeline": "if (chdir (\"/newroot\") != 0)"
    },
    {
        "line": 377,
        "fullcodeline": "if (chroot (\"/newroot\") != 0)"
    },
    {
        "line": 379,
        "fullcodeline": "if (chdir (\"/\") != 0)"
    },
    {
        "line": 385,
        "fullcodeline": "if (opt_block_fd != -1)"
    },
    {
        "line": 392,
        "fullcodeline": "if (opt_seccomp_fd != -1)"
    },
    {
        "line": 441,
        "fullcodeline": "if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)"
    },
    {
        "line": 477,
        "fullcodeline": "if (proc_fd != -1)"
    },
    {
        "line": 480,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 486,
        "fullcodeline": "if (setsid () == (pid_t) -1)"
    },
    {
        "line": 489,
        "fullcodeline": "if (label_exec (opt_exec_label) == -1)"
    },
    {
        "line": 492,
        "fullcodeline": "if (execvp (argv[0], argv) == -1)"
    },
    {
        "line": 26,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");"
    },
    {
        "line": 36,
        "fullcodeline": "host_tty_dev = ttyname (1);"
    },
    {
        "line": 42,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 49,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 52,
        "fullcodeline": "stat (\"/proc/self/ns/user\", &sbuf) == 0)"
    },
    {
        "line": 54,
        "fullcodeline": "bool disabled = FALSE;"
    },
    {
        "line": 74,
        "fullcodeline": "usage (EXIT_FAILURE, stderr);"
    },
    {
        "line": 79,
        "fullcodeline": "opt_sandbox_uid = real_uid;"
    },
    {
        "line": 81,
        "fullcodeline": "opt_sandbox_gid = real_gid;"
    },
    {
        "line": 84,
        "fullcodeline": "die (\"Specifying --uid requires --unshare-user\");"
    },
    {
        "line": 87,
        "fullcodeline": "die (\"Specifying --gid requires --unshare-user\");"
    },
    {
        "line": 90,
        "fullcodeline": "die (\"Specifying --hostname requires --unshare-uts\");"
    },
    {
        "line": 96,
        "fullcodeline": "die_with_error (\"Can't open /proc\");"
    },
    {
        "line": 103,
        "fullcodeline": "free (base_path);"
    },
    {
        "line": 104,
        "fullcodeline": "base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);"
    },
    {
        "line": 113,
        "fullcodeline": "event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);"
    },
    {
        "line": 123,
        "fullcodeline": "clone_flags |= CLONE_NEWUSER;"
    },
    {
        "line": 125,
        "fullcodeline": "clone_flags |= CLONE_NEWPID;"
    },
    {
        "line": 127,
        "fullcodeline": "clone_flags |= CLONE_NEWNET;"
    },
    {
        "line": 129,
        "fullcodeline": "clone_flags |= CLONE_NEWIPC;"
    },
    {
        "line": 131,
        "fullcodeline": "clone_flags |= CLONE_NEWUTS;"
    },
    {
        "line": 141,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 149,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 162,
        "fullcodeline": "die_with_error (\"Creating new namespace failed\");"
    },
    {
        "line": 190,
        "fullcodeline": "drop_privs ();"
    },
    {
        "line": 193,
        "fullcodeline": "val = 1;"
    },
    {
        "line": 194,
        "fullcodeline": "res = write (child_wait_fd, &val, 8);"
    },
    {
        "line": 196,
        "fullcodeline": "close (child_wait_fd);"
    },
    {
        "line": 207,
        "fullcodeline": "monitor_child (event_fd);"
    },
    {
        "line": 208,
        "fullcodeline": "exit (0); /* Should not be reached, but better safe... */"
    },
    {
        "line": 226,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 239,
        "fullcodeline": "die (\"Can't create loopback device\");"
    },
    {
        "line": 258,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 272,
        "fullcodeline": "die_with_error (\"Failed to make / slave\");"
    },
    {
        "line": 276,
        "fullcodeline": "die_with_error (\"Failed to mount tmpfs\");"
    },
    {
        "line": 283,
        "fullcodeline": "die_with_error (\"chdir base_path\");"
    },
    {
        "line": 291,
        "fullcodeline": "die_with_error (\"Creating newroot failed\");"
    },
    {
        "line": 294,
        "fullcodeline": "die_with_error (\"Creating oldroot failed\");"
    },
    {
        "line": 297,
        "fullcodeline": "die_with_error (\"pivot_root\");"
    },
    {
        "line": 300,
        "fullcodeline": "die_with_error (\"chdir / (base path)\");"
    },
    {
        "line": 305,
        "fullcodeline": "int privsep_sockets[2];"
    },
    {
        "line": 310,
        "fullcodeline": "child = fork ();"
    },
    {
        "line": 354,
        "fullcodeline": "die_with_error (\"Failed to make old root rprivate\");"
    },
    {
        "line": 357,
        "fullcodeline": "die_with_error (\"unmount old root\");"
    },
    {
        "line": 360,
        "fullcodeline": "(ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))"
    },
    {
        "line": 369,
        "fullcodeline": "write_uid_gid_map (opt_sandbox_uid, ns_uid,"
    },
    {
        "line": 376,
        "fullcodeline": "die_with_error (\"chdir newroot\");"
    },
    {
        "line": 378,
        "fullcodeline": "die_with_error (\"chroot /newroot\");"
    },
    {
        "line": 380,
        "fullcodeline": "die_with_error (\"chdir /\");"
    },
    {
        "line": 387,
        "fullcodeline": "char b[1];"
    },
    {
        "line": 388,
        "fullcodeline": "read (opt_block_fd, b, 1);"
    },
    {
        "line": 389,
        "fullcodeline": "close (opt_block_fd);"
    },
    {
        "line": 394,
        "fullcodeline": "cleanup_free char *seccomp_data = NULL;"
    },
    {
        "line": 398,
        "fullcodeline": "seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);"
    },
    {
        "line": 405,
        "fullcodeline": "prog.len = seccomp_len / 8;"
    },
    {
        "line": 406,
        "fullcodeline": "prog.filter = (struct sock_filter *) seccomp_data;"
    },
    {
        "line": 408,
        "fullcodeline": "close (opt_seccomp_fd);"
    },
    {
        "line": 421,
        "fullcodeline": "new_cwd = opt_chdir_path;"
    },
    {
        "line": 449,
        "fullcodeline": "pid = fork ();"
    },
    {
        "line": 478,
        "fullcodeline": "close (proc_fd);"
    },
    {
        "line": 481,
        "fullcodeline": "close (opt_sync_fd);"
    },
    {
        "line": 487,
        "fullcodeline": "die_with_error (\"setsid\");"
    },
    {
        "line": 490,
        "fullcodeline": "die_with_error (\"label_exec %s\", argv[0]);"
    },
    {
        "line": 493,
        "fullcodeline": "die_with_error (\"execvp %s\", argv[0]);"
    },
    {
        "line": 57,
        "fullcodeline": "if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)"
    },
    {
        "line": 69,
        "fullcodeline": "if (!disabled)"
    },
    {
        "line": 105,
        "fullcodeline": "if (mkdir (base_path, 0755) && errno != EEXIST)"
    },
    {
        "line": 114,
        "fullcodeline": "if (event_fd == -1)"
    },
    {
        "line": 134,
        "fullcodeline": "if (stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 144,
        "fullcodeline": "if (!stat (\"/proc/self/ns/cgroup\", &sbuf))"
    },
    {
        "line": 172,
        "fullcodeline": "if (is_privileged && opt_unshare_user)"
    },
    {
        "line": 198,
        "fullcodeline": "if (opt_info_fd != -1)"
    },
    {
        "line": 260,
        "fullcodeline": "-1, TRUE, FALSE);"
    },
    {
        "line": 307,
        "fullcodeline": "if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)"
    },
    {
        "line": 311,
        "fullcodeline": "if (child == -1)"
    },
    {
        "line": 314,
        "fullcodeline": "if (child == 0)"
    },
    {
        "line": 349,
        "fullcodeline": "setup_newroot (opt_unshare_pid, -1);"
    },
    {
        "line": 366,
        "fullcodeline": "if (unshare (CLONE_NEWUSER))"
    },
    {
        "line": 371,
        "fullcodeline": "-1, FALSE, FALSE);"
    },
    {
        "line": 399,
        "fullcodeline": "if (seccomp_data == NULL)"
    },
    {
        "line": 402,
        "fullcodeline": "if (seccomp_len % 8 != 0)"
    },
    {
        "line": 410,
        "fullcodeline": "if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)"
    },
    {
        "line": 419,
        "fullcodeline": "if (chdir (opt_chdir_path))"
    },
    {
        "line": 450,
        "fullcodeline": "if (pid == -1)"
    },
    {
        "line": 453,
        "fullcodeline": "if (pid != 0)"
    },
    {
        "line": 59,
        "fullcodeline": "cleanup_free char *enable = NULL;"
    },
    {
        "line": 60,
        "fullcodeline": "enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");"
    },
    {
        "line": 70,
        "fullcodeline": "opt_unshare_user = TRUE;"
    },
    {
        "line": 106,
        "fullcodeline": "die_with_error (\"Creating root mountpoint failed\");"
    },
    {
        "line": 115,
        "fullcodeline": "die_with_error (\"eventfd()\");"
    },
    {
        "line": 145,
        "fullcodeline": "clone_flags |= CLONE_NEWCGROUP;"
    },
    {
        "line": 182,
        "fullcodeline": "write_uid_gid_map (ns_uid, real_uid,"
    },
    {
        "line": 200,
        "fullcodeline": "cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);"
    },
    {
        "line": 201,
        "fullcodeline": "size_t len = strlen (output);"
    },
    {
        "line": 204,
        "fullcodeline": "close (opt_info_fd);"
    },
    {
        "line": 254,
        "fullcodeline": "ns_uid = 0;"
    },
    {
        "line": 255,
        "fullcodeline": "ns_gid = 0;"
    },
    {
        "line": 308,
        "fullcodeline": "die_with_error (\"Can't create privsep socket\");"
    },
    {
        "line": 312,
        "fullcodeline": "die_with_error (\"Can't fork unprivileged helper\");"
    },
    {
        "line": 317,
        "fullcodeline": "drop_privs ();"
    },
    {
        "line": 318,
        "fullcodeline": "close (privsep_sockets[0]);"
    },
    {
        "line": 319,
        "fullcodeline": "setup_newroot (opt_unshare_pid, privsep_sockets[1]);"
    },
    {
        "line": 320,
        "fullcodeline": "exit (0);"
    },
    {
        "line": 367,
        "fullcodeline": "die_with_error (\"unshare user ns\");"
    },
    {
        "line": 400,
        "fullcodeline": "die_with_error (\"Can't read seccomp data\");"
    },
    {
        "line": 403,
        "fullcodeline": "die (\"Invalid seccomp data, must be multiple of 8\");"
    },
    {
        "line": 411,
        "fullcodeline": "die_with_error (\"prctl(PR_SET_SECCOMP)\");"
    },
    {
        "line": 420,
        "fullcodeline": "die_with_error (\"Can't chdir to %s\", opt_chdir_path);"
    },
    {
        "line": 423,
        "fullcodeline": "else if (chdir (old_cwd) == 0)"
    },
    {
        "line": 451,
        "fullcodeline": "die_with_error (\"Can't fork for pid 1\");"
    },
    {
        "line": 61,
        "fullcodeline": "if (enable != NULL && enable[0] == 'N')"
    },
    {
        "line": 136,
        "fullcodeline": "if (errno == ENOENT)"
    },
    {
        "line": 156,
        "fullcodeline": "if (errno == EINVAL)"
    },
    {
        "line": 202,
        "fullcodeline": "if (write (opt_info_fd, output, len) != len)"
    },
    {
        "line": 325,
        "fullcodeline": "uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */"
    },
    {
        "line": 328,
        "fullcodeline": "cleanup_fd int unpriv_socket = -1;"
    },
    {
        "line": 330,
        "fullcodeline": "unpriv_socket = privsep_sockets[0];"
    },
    {
        "line": 331,
        "fullcodeline": "close (privsep_sockets[1]);"
    },
    {
        "line": 343,
        "fullcodeline": "waitpid (child, &status, 0);"
    },
    {
        "line": 426,
        "fullcodeline": "new_cwd = old_cwd;"
    },
    {
        "line": 461,
        "fullcodeline": "int dont_close[3];"
    },
    {
        "line": 462,
        "fullcodeline": "int j = 0;"
    },
    {
        "line": 467,
        "fullcodeline": "dont_close[j++] = -1;"
    },
    {
        "line": 468,
        "fullcodeline": "fdwalk (proc_fd, close_extra_fds, dont_close);"
    },
    {
        "line": 471,
        "fullcodeline": "return do_init (event_fd, pid);"
    },
    {
        "line": 62,
        "fullcodeline": "disabled = TRUE;"
    },
    {
        "line": 137,
        "fullcodeline": "die (\"Cannot create new cgroup namespace because the kernel does not support it\");"
    },
    {
        "line": 157,
        "fullcodeline": "die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");"
    },
    {
        "line": 203,
        "fullcodeline": "die_with_error (\"Write to info_fd\");"
    },
    {
        "line": 341,
        "fullcodeline": "while (op != PRIV_SEP_OP_DONE);"
    },
    {
        "line": 431,
        "fullcodeline": "const char *home = getenv (\"HOME\");"
    },
    {
        "line": 463,
        "fullcodeline": "if (event_fd != -1)"
    },
    {
        "line": 465,
        "fullcodeline": "if (opt_sync_fd != -1)"
    },
    {
        "line": 139,
        "fullcodeline": "die_with_error (\"stat on /proc/self/ns/cgroup failed\");"
    },
    {
        "line": 335,
        "fullcodeline": "op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),"
    },
    {
        "line": 337,
        "fullcodeline": "privileged_op (-1, op, flags, arg1, arg2);"
    },
    {
        "line": 432,
        "fullcodeline": "if (home != NULL &&"
    },
    {
        "line": 464,
        "fullcodeline": "dont_close[j++] = event_fd;"
    },
    {
        "line": 466,
        "fullcodeline": "dont_close[j++] = opt_sync_fd;"
    },
    {
        "line": 158,
        "fullcodeline": "else if (errno == EPERM && !is_privileged)"
    },
    {
        "line": 338,
        "fullcodeline": "if (write (unpriv_socket, buffer, 1) != 1)"
    },
    {
        "line": 433,
        "fullcodeline": "chdir (home) == 0)"
    },
    {
        "line": 434,
        "fullcodeline": "new_cwd = home;"
    },
    {
        "line": 159,
        "fullcodeline": "die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");"
    },
    {
        "line": 339,
        "fullcodeline": "die (\"Can't write to op_socket\");"
    }
]