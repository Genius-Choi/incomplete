[
    {
        "line": 9,
        "fullcodeline": "prepare_to_copy(orig);"
    },
    {
        "line": 11,
        "fullcodeline": "tsk = alloc_task_struct();"
    },
    {
        "line": 15,
        "fullcodeline": "ti = alloc_thread_info(tsk);"
    },
    {
        "line": 21,
        "fullcodeline": "err = arch_dup_task_struct(tsk, orig);"
    },
    {
        "line": 25,
        "fullcodeline": "tsk->stack = ti;"
    },
    {
        "line": 27,
        "fullcodeline": "err = prop_local_init_single(&tsk->dirties);"
    },
    {
        "line": 31,
        "fullcodeline": "setup_thread_stack(tsk, orig);"
    },
    {
        "line": 32,
        "fullcodeline": "clear_user_return_notifier(tsk);"
    },
    {
        "line": 33,
        "fullcodeline": "clear_tsk_need_resched(tsk);"
    },
    {
        "line": 34,
        "fullcodeline": "stackend = end_of_stack(tsk);"
    },
    {
        "line": 35,
        "fullcodeline": "*stackend = STACK_END_MAGIC;\t/* for overflow detection */"
    },
    {
        "line": 42,
        "fullcodeline": "atomic_set(&tsk->usage,2);"
    },
    {
        "line": 43,
        "fullcodeline": "atomic_set(&tsk->fs_excl, 0);"
    },
    {
        "line": 47,
        "fullcodeline": "tsk->splice_pipe = NULL;"
    },
    {
        "line": 49,
        "fullcodeline": "account_kernel_stack(ti, 1);"
    },
    {
        "line": 54,
        "fullcodeline": "free_thread_info(ti);"
    },
    {
        "line": 55,
        "fullcodeline": "free_task_struct(tsk);"
    },
    {
        "line": 12,
        "fullcodeline": "if (!tsk)"
    },
    {
        "line": 16,
        "fullcodeline": "if (!ti) {"
    },
    {
        "line": 17,
        "fullcodeline": "free_task_struct(tsk);"
    }
]