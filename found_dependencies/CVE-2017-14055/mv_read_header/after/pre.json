[
    {
        "line": 3,
        "fullcodeline": "MvContext *mv = avctx->priv_data;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *pb = avctx->pb;"
    },
    {
        "line": 5,
        "fullcodeline": "AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning"
    },
    {
        "line": 9,
        "fullcodeline": "avio_skip(pb, 4);"
    },
    {
        "line": 11,
        "fullcodeline": "version = avio_rb16(pb);"
    },
    {
        "line": 12,
        "fullcodeline": "if (version == 2) {"
    },
    {
        "line": 15,
        "fullcodeline": "avio_skip(pb, 22);"
    },
    {
        "line": 19,
        "fullcodeline": "ast = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 23,
        "fullcodeline": "vst = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 26,
        "fullcodeline": "avpriv_set_pts_info(vst, 64, 1, 15);"
    },
    {
        "line": 28,
        "fullcodeline": "vst->avg_frame_rate    = av_inv_q(vst->time_base);"
    },
    {
        "line": 29,
        "fullcodeline": "vst->nb_frames         = avio_rb32(pb);"
    },
    {
        "line": 30,
        "fullcodeline": "v = avio_rb32(pb);"
    },
    {
        "line": 46,
        "fullcodeline": "avio_skip(pb, 12);"
    },
    {
        "line": 49,
        "fullcodeline": "ast->nb_frames          = vst->nb_frames;"
    },
    {
        "line": 50,
        "fullcodeline": "ast->codecpar->sample_rate = avio_rb32(pb);"
    },
    {
        "line": 55,
        "fullcodeline": "avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);"
    },
    {
        "line": 59,
        "fullcodeline": "v = avio_rb32(pb);"
    },
    {
        "line": 66,
        "fullcodeline": "avio_skip(pb, 12);"
    },
    {
        "line": 67,
        "fullcodeline": "var_read_metadata(avctx, \"title\", 0x80);"
    },
    {
        "line": 69,
        "fullcodeline": "avio_skip(pb, 0x80);"
    },
    {
        "line": 71,
        "fullcodeline": "timestamp = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!ast)"
    },
    {
        "line": 24,
        "fullcodeline": "if (!vst)"
    },
    {
        "line": 44,
        "fullcodeline": "vst->codecpar->width     = avio_rb32(pb);"
    },
    {
        "line": 45,
        "fullcodeline": "vst->codecpar->height    = avio_rb32(pb);"
    },
    {
        "line": 51,
        "fullcodeline": "if (ast->codecpar->sample_rate <= 0) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (v == AUDIO_FORMAT_SIGNED) {"
    },
    {
        "line": 72,
        "fullcodeline": "for (i = 0; i < vst->nb_frames; i++) {"
    },
    {
        "line": 33,
        "fullcodeline": "vst->codecpar->codec_id = AV_CODEC_ID_MVC1;"
    },
    {
        "line": 36,
        "fullcodeline": "vst->codecpar->format = AV_PIX_FMT_ARGB;"
    },
    {
        "line": 37,
        "fullcodeline": "vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;"
    },
    {
        "line": 40,
        "fullcodeline": "avpriv_request_sample(avctx, \"Video compression %i\", v);"
    },
    {
        "line": 56,
        "fullcodeline": "if (set_channels(avctx, ast, avio_rb32(pb)) < 0)"
    },
    {
        "line": 73,
        "fullcodeline": "uint32_t pos   = avio_rb32(pb);"
    },
    {
        "line": 74,
        "fullcodeline": "uint32_t asize = avio_rb32(pb);"
    },
    {
        "line": 75,
        "fullcodeline": "uint32_t vsize = avio_rb32(pb);"
    },
    {
        "line": 78,
        "fullcodeline": "avio_skip(pb, 8);"
    },
    {
        "line": 79,
        "fullcodeline": "av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);"
    },
    {
        "line": 80,
        "fullcodeline": "av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);"
    },
    {
        "line": 81,
        "fullcodeline": "timestamp += asize / (ast->codecpar->channels * 2);"
    },
    {
        "line": 21,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 25,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 63,
        "fullcodeline": "avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);"
    },
    {
        "line": 76,
        "fullcodeline": "if (avio_feof(pb))"
    },
    {
        "line": 83,
        "fullcodeline": "} else if (!version && avio_rb16(pb) == 3) {"
    },
    {
        "line": 84,
        "fullcodeline": "avio_skip(pb, 4);"
    },
    {
        "line": 86,
        "fullcodeline": "if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)"
    },
    {
        "line": 129,
        "fullcodeline": "read_index(pb, ast);"
    },
    {
        "line": 93,
        "fullcodeline": "ast = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 120,
        "fullcodeline": "vst = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 94,
        "fullcodeline": "if (!ast)"
    },
    {
        "line": 121,
        "fullcodeline": "if (!vst)"
    },
    {
        "line": 97,
        "fullcodeline": "if ((read_table(avctx, ast, parse_audio_var)) < 0)"
    },
    {
        "line": 99,
        "fullcodeline": "if (mv->acompression == 100 &&"
    },
    {
        "line": 101,
        "fullcodeline": "ast->codecpar->bits_per_coded_sample == 16) {"
    },
    {
        "line": 124,
        "fullcodeline": "if ((ret = read_table(avctx, vst, parse_video_var))<0)"
    },
    {
        "line": 95,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 100,
        "fullcodeline": "mv->aformat == AUDIO_FORMAT_SIGNED &&"
    },
    {
        "line": 104,
        "fullcodeline": "avpriv_request_sample(avctx,"
    },
    {
        "line": 108,
        "fullcodeline": "ast->codecpar->codec_id = AV_CODEC_ID_NONE;"
    },
    {
        "line": 122,
        "fullcodeline": "return AVERROR(ENOMEM);"
    }
]