[
    {
        "line": 3,
        "fullcodeline": "MvContext *mv = avctx->priv_data;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *pb = avctx->pb;"
    },
    {
        "line": 5,
        "fullcodeline": "AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning"
    },
    {
        "line": 9,
        "fullcodeline": "avio_skip(pb, 4);"
    },
    {
        "line": 11,
        "fullcodeline": "version = avio_rb16(pb);"
    },
    {
        "line": 12,
        "fullcodeline": "if (version == 2) {"
    },
    {
        "line": 15,
        "fullcodeline": "avio_skip(pb, 22);"
    },
    {
        "line": 19,
        "fullcodeline": "ast = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 23,
        "fullcodeline": "vst = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 26,
        "fullcodeline": "avpriv_set_pts_info(vst, 64, 1, 15);"
    },
    {
        "line": 27,
        "fullcodeline": "vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;"
    },
    {
        "line": 28,
        "fullcodeline": "vst->avg_frame_rate    = av_inv_q(vst->time_base);"
    },
    {
        "line": 29,
        "fullcodeline": "vst->nb_frames         = avio_rb32(pb);"
    },
    {
        "line": 30,
        "fullcodeline": "v = avio_rb32(pb);"
    },
    {
        "line": 43,
        "fullcodeline": "vst->codecpar->codec_tag = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "vst->codecpar->width     = avio_rb32(pb);"
    },
    {
        "line": 45,
        "fullcodeline": "vst->codecpar->height    = avio_rb32(pb);"
    },
    {
        "line": 46,
        "fullcodeline": "avio_skip(pb, 12);"
    },
    {
        "line": 48,
        "fullcodeline": "ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;"
    },
    {
        "line": 49,
        "fullcodeline": "ast->nb_frames          = vst->nb_frames;"
    },
    {
        "line": 50,
        "fullcodeline": "ast->codecpar->sample_rate = avio_rb32(pb);"
    },
    {
        "line": 55,
        "fullcodeline": "avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);"
    },
    {
        "line": 59,
        "fullcodeline": "v = avio_rb32(pb);"
    },
    {
        "line": 66,
        "fullcodeline": "avio_skip(pb, 12);"
    },
    {
        "line": 67,
        "fullcodeline": "var_read_metadata(avctx, \"title\", 0x80);"
    },
    {
        "line": 68,
        "fullcodeline": "var_read_metadata(avctx, \"comment\", 0x100);"
    },
    {
        "line": 69,
        "fullcodeline": "avio_skip(pb, 0x80);"
    },
    {
        "line": 71,
        "fullcodeline": "timestamp = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!ast)"
    },
    {
        "line": 24,
        "fullcodeline": "if (!vst)"
    },
    {
        "line": 51,
        "fullcodeline": "if (ast->codecpar->sample_rate <= 0) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (set_channels(avctx, ast, avio_rb32(pb)) < 0)"
    },
    {
        "line": 60,
        "fullcodeline": "if (v == AUDIO_FORMAT_SIGNED) {"
    },
    {
        "line": 72,
        "fullcodeline": "for (i = 0; i < vst->nb_frames; i++) {"
    },
    {
        "line": 33,
        "fullcodeline": "vst->codecpar->codec_id = AV_CODEC_ID_MVC1;"
    },
    {
        "line": 36,
        "fullcodeline": "vst->codecpar->format = AV_PIX_FMT_ARGB;"
    },
    {
        "line": 37,
        "fullcodeline": "vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;"
    },
    {
        "line": 40,
        "fullcodeline": "avpriv_request_sample(avctx, \"Video compression %i\", v);"
    },
    {
        "line": 52,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);"
    },
    {
        "line": 61,
        "fullcodeline": "ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;"
    },
    {
        "line": 73,
        "fullcodeline": "uint32_t pos   = avio_rb32(pb);"
    },
    {
        "line": 74,
        "fullcodeline": "uint32_t asize = avio_rb32(pb);"
    },
    {
        "line": 75,
        "fullcodeline": "uint32_t vsize = avio_rb32(pb);"
    },
    {
        "line": 76,
        "fullcodeline": "avio_skip(pb, 8);"
    },
    {
        "line": 77,
        "fullcodeline": "av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);"
    },
    {
        "line": 78,
        "fullcodeline": "av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);"
    },
    {
        "line": 79,
        "fullcodeline": "timestamp += asize / (ast->codecpar->channels * 2);"
    },
    {
        "line": 81,
        "fullcodeline": "} else if (!version && avio_rb16(pb) == 3) {"
    },
    {
        "line": 21,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 25,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 63,
        "fullcodeline": "avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);"
    },
    {
        "line": 82,
        "fullcodeline": "avio_skip(pb, 4);"
    },
    {
        "line": 84,
        "fullcodeline": "if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)"
    },
    {
        "line": 87,
        "fullcodeline": "if (mv->nb_audio_tracks > 1) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (mv->nb_video_tracks > 1) {"
    },
    {
        "line": 132,
        "fullcodeline": "avpriv_request_sample(avctx, \"Version %i\", version);"
    },
    {
        "line": 88,
        "fullcodeline": "avpriv_request_sample(avctx, \"Multiple audio streams support\");"
    },
    {
        "line": 115,
        "fullcodeline": "avpriv_request_sample(avctx, \"Multiple video streams support\");"
    },
    {
        "line": 127,
        "fullcodeline": "read_index(pb, ast);"
    },
    {
        "line": 130,
        "fullcodeline": "read_index(pb, vst);"
    },
    {
        "line": 91,
        "fullcodeline": "ast = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 94,
        "fullcodeline": "ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;"
    },
    {
        "line": 118,
        "fullcodeline": "vst = avformat_new_stream(avctx, NULL);"
    },
    {
        "line": 121,
        "fullcodeline": "vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;"
    },
    {
        "line": 92,
        "fullcodeline": "if (!ast)"
    },
    {
        "line": 95,
        "fullcodeline": "if ((read_table(avctx, ast, parse_audio_var)) < 0)"
    },
    {
        "line": 97,
        "fullcodeline": "if (mv->acompression == 100 &&"
    },
    {
        "line": 108,
        "fullcodeline": "if (ast->codecpar->channels <= 0) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (!vst)"
    },
    {
        "line": 122,
        "fullcodeline": "if ((ret = read_table(avctx, vst, parse_video_var))<0)"
    },
    {
        "line": 99,
        "fullcodeline": "ast->codecpar->bits_per_coded_sample == 16) {"
    },
    {
        "line": 100,
        "fullcodeline": "ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;"
    },
    {
        "line": 109,
        "fullcodeline": "av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");"
    },
    {
        "line": 93,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 98,
        "fullcodeline": "mv->aformat == AUDIO_FORMAT_SIGNED &&"
    },
    {
        "line": 102,
        "fullcodeline": "avpriv_request_sample(avctx,"
    },
    {
        "line": 106,
        "fullcodeline": "ast->codecpar->codec_id = AV_CODEC_ID_NONE;"
    },
    {
        "line": 120,
        "fullcodeline": "return AVERROR(ENOMEM);"
    }
]