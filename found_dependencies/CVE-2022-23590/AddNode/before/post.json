[
    {
        "line": 3,
        "fullcodeline": "status->Update(ops_.LookUp(node_def.op(), &op_reg_data));"
    },
    {
        "line": 8,
        "fullcodeline": "status->Update("
    },
    {
        "line": 15,
        "fullcodeline": "Node::NodeClass node_class = op_reg_data->is_function_op"
    },
    {
        "line": 31,
        "fullcodeline": "Node* node = AllocateNode(std::make_shared<NodeProperties>("
    },
    {
        "line": 4,
        "fullcodeline": "if (!status->ok()) return nullptr;"
    },
    {
        "line": 9,
        "fullcodeline": "InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));"
    },
    {
        "line": 10,
        "fullcodeline": "if (!status->ok()) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (op_reg_data->type_ctor != nullptr) {"
    },
    {
        "line": 11,
        "fullcodeline": "*status = AttachDef(*status, node_def);"
    },
    {
        "line": 17,
        "fullcodeline": ": Node::GetNodeClassForOp(node_def.op());"
    },
    {
        "line": 20,
        "fullcodeline": "VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();"
    },
    {
        "line": 21,
        "fullcodeline": "const auto ctor_type ="
    },
    {
        "line": 23,
        "fullcodeline": "const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();"
    },
    {
        "line": 22,
        "fullcodeline": "full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);"
    },
    {
        "line": 24,
        "fullcodeline": "if (ctor_typedef.type_id() != TFT_UNSET) {"
    },
    {
        "line": 28,
        "fullcodeline": "VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();"
    },
    {
        "line": 25,
        "fullcodeline": "*(node_def.mutable_experimental_type()) = ctor_typedef;"
    },
    {
        "line": 32,
        "fullcodeline": "&op_reg_data->op_def, std::move(node_def),"
    }
]