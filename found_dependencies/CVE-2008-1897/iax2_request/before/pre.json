[
    {
        "line": 12,
        "fullcodeline": "memset(&pds, 0, sizeof(pds));"
    },
    {
        "line": 13,
        "fullcodeline": "tmpstr = ast_strdupa(data);"
    },
    {
        "line": 14,
        "fullcodeline": "parse_dial_string(tmpstr, &pds);"
    },
    {
        "line": 21,
        "fullcodeline": "memset(&cai, 0, sizeof(cai));"
    },
    {
        "line": 22,
        "fullcodeline": "cai.capability = iax2_capability;"
    },
    {
        "line": 24,
        "fullcodeline": "ast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);"
    },
    {
        "line": 35,
        "fullcodeline": "callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
    },
    {
        "line": 43,
        "fullcodeline": "ast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);"
    },
    {
        "line": 49,
        "fullcodeline": "iaxs[callno]->maxtime = cai.maxtime;"
    },
    {
        "line": 53,
        "fullcodeline": "c = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);"
    },
    {
        "line": 16,
        "fullcodeline": "if (ast_strlen_zero(pds.peer)) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (create_addr(pds.peer, NULL, &sin, &cai)) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (callno < 1) {"
    },
    {
        "line": 17,
        "fullcodeline": "ast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);"
    },
    {
        "line": 28,
        "fullcodeline": "*cause = AST_CAUSE_UNREGISTERED;"
    },
    {
        "line": 33,
        "fullcodeline": "sin.sin_port = htons(atoi(pds.port));"
    },
    {
        "line": 38,
        "fullcodeline": "*cause = AST_CAUSE_CONGESTION;"
    },
    {
        "line": 51,
        "fullcodeline": "ast_string_field_set(iaxs[callno], host, pds.peer);"
    },
    {
        "line": 73,
        "fullcodeline": "c->readformat = ast_best_codec(c->nativeformats);"
    },
    {
        "line": 74,
        "fullcodeline": "c->writeformat = c->readformat;"
    },
    {
        "line": 59,
        "fullcodeline": "if (c->nativeformats & format)"
    },
    {
        "line": 46,
        "fullcodeline": "if ((new_callno = make_trunk(callno, 1)) != -1)"
    },
    {
        "line": 47,
        "fullcodeline": "callno = new_callno;"
    },
    {
        "line": 60,
        "fullcodeline": "c->nativeformats &= format;"
    },
    {
        "line": 62,
        "fullcodeline": "native = c->nativeformats;"
    },
    {
        "line": 63,
        "fullcodeline": "fmt = format;"
    },
    {
        "line": 64,
        "fullcodeline": "res = ast_translator_best_choice(&fmt, &native);"
    },
    {
        "line": 71,
        "fullcodeline": "c->nativeformats = native;"
    },
    {
        "line": 66,
        "fullcodeline": "ast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\","
    },
    {
        "line": 67,
        "fullcodeline": "ast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);"
    }
]