[
    {
        "line": 3,
        "fullcodeline": "Packet *rp = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "Frag *first = RB_MIN(IP_FRAGMENTS, &tracker->fragment_tree);"
    },
    {
        "line": 24,
        "fullcodeline": "Frag *frag = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "size_t len = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "RB_FOREACH_FROM(frag, IP_FRAGMENTS, first) {"
    },
    {
        "line": 39,
        "fullcodeline": "rp = PacketDefragPktSetup(p, NULL, 0, IPV4_GET_IPPROTO(p));"
    },
    {
        "line": 43,
        "fullcodeline": "PKT_SET_SRC(rp, PKT_SRC_DEFRAG);"
    },
    {
        "line": 44,
        "fullcodeline": "rp->flags |= PKT_REBUILT_FRAGMENT;"
    },
    {
        "line": 45,
        "fullcodeline": "rp->datalink = tracker->datalink;"
    },
    {
        "line": 47,
        "fullcodeline": "int fragmentable_offset = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "uint16_t fragmentable_len = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "uint16_t hlen = 0;"
    },
    {
        "line": 50,
        "fullcodeline": "int ip_hdr_offset = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {"
    },
    {
        "line": 104,
        "fullcodeline": "rp->ip4h = (IPV4Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);"
    },
    {
        "line": 105,
        "fullcodeline": "uint16_t old = rp->ip4h->ip_len + rp->ip4h->ip_off;"
    },
    {
        "line": 107,
        "fullcodeline": "rp->ip4h->ip_len = htons(fragmentable_len + hlen);"
    },
    {
        "line": 108,
        "fullcodeline": "rp->ip4h->ip_off = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "SET_PKT_LEN(rp, ip_hdr_offset + hlen + fragmentable_len);"
    },
    {
        "line": 113,
        "fullcodeline": "tracker->remove = 1;"
    },
    {
        "line": 119,
        "fullcodeline": "tracker->remove = 1;"
    },
    {
        "line": 6,
        "fullcodeline": "if (!tracker->seen_last) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (first == NULL) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (rp == NULL) {"
    },
    {
        "line": 106,
        "fullcodeline": "DEBUG_VALIDATE_BUG_ON(hlen > UINT16_MAX - fragmentable_len);"
    },
    {
        "line": 109,
        "fullcodeline": "rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum,"
    },
    {
        "line": 121,
        "fullcodeline": "if (rp != NULL)"
    },
    {
        "line": 27,
        "fullcodeline": "if (frag->offset > len) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (frag->ltrim >= frag->data_len)"
    },
    {
        "line": 60,
        "fullcodeline": "if (frag->offset == 0) {"
    },
    {
        "line": 65,
        "fullcodeline": "hlen = frag->hlen;"
    },
    {
        "line": 66,
        "fullcodeline": "ip_hdr_offset = frag->ip_hdr_offset;"
    },
    {
        "line": 72,
        "fullcodeline": "fragmentable_len = frag->data_len;"
    },
    {
        "line": 14,
        "fullcodeline": "} else if (first->offset != 0) {"
    },
    {
        "line": 75,
        "fullcodeline": "int pkt_end = fragmentable_offset + frag->offset + frag->data_len;"
    },
    {
        "line": 62,
        "fullcodeline": "if (PacketCopyData(rp, frag->pkt, frag->len) == -1)"
    },
    {
        "line": 87,
        "fullcodeline": "if (frag->offset > UINT16_MAX - frag->data_len) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (frag->offset + frag->data_len > fragmentable_len)"
    },
    {
        "line": 76,
        "fullcodeline": "if (pkt_end > (int)MAX_PAYLOAD_SIZE) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (PacketCopyDataOffset(rp,"
    },
    {
        "line": 84,
        "fullcodeline": "frag->data_len - frag->ltrim) == -1) {"
    },
    {
        "line": 93,
        "fullcodeline": "fragmentable_len = frag->offset + frag->data_len;"
    },
    {
        "line": 17,
        "fullcodeline": "} else if (first->len < sizeof(IPV4Hdr)) {"
    }
]