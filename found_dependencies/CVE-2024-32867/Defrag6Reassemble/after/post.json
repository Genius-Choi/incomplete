[
    {
        "line": 3,
        "fullcodeline": "Packet *rp = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "Frag *first = RB_MIN(IP_FRAGMENTS, &tracker->fragment_tree);"
    },
    {
        "line": 23,
        "fullcodeline": "size_t len = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "Frag *frag = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "RB_FOREACH_FROM(frag, IP_FRAGMENTS, first) {"
    },
    {
        "line": 50,
        "fullcodeline": "rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h,"
    },
    {
        "line": 55,
        "fullcodeline": "PKT_SET_SRC(rp, PKT_SRC_DEFRAG);"
    },
    {
        "line": 56,
        "fullcodeline": "rp->flags |= PKT_REBUILT_FRAGMENT;"
    },
    {
        "line": 57,
        "fullcodeline": "rp->datalink = tracker->datalink;"
    },
    {
        "line": 59,
        "fullcodeline": "uint16_t unfragmentable_len = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "int fragmentable_offset = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "uint16_t fragmentable_len = 0;"
    },
    {
        "line": 62,
        "fullcodeline": "int ip_hdr_offset = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "uint8_t next_hdr = 0;"
    },
    {
        "line": 66,
        "fullcodeline": "uint16_t prev_offset = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "bool more_frags = 1;"
    },
    {
        "line": 69,
        "fullcodeline": "RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {"
    },
    {
        "line": 129,
        "fullcodeline": "rp->ip6h = (IPV6Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);"
    },
    {
        "line": 130,
        "fullcodeline": "DEBUG_VALIDATE_BUG_ON(unfragmentable_len > UINT16_MAX - fragmentable_len);"
    },
    {
        "line": 131,
        "fullcodeline": "rp->ip6h->s_ip6_plen = htons(fragmentable_len + unfragmentable_len);"
    },
    {
        "line": 138,
        "fullcodeline": "SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) +"
    },
    {
        "line": 141,
        "fullcodeline": "tracker->remove = 1;"
    },
    {
        "line": 142,
        "fullcodeline": "DefragTrackerFreeFrags(tracker);"
    },
    {
        "line": 147,
        "fullcodeline": "tracker->remove = 1;"
    },
    {
        "line": 148,
        "fullcodeline": "DefragTrackerFreeFrags(tracker);"
    },
    {
        "line": 6,
        "fullcodeline": "if (!tracker->seen_last)"
    },
    {
        "line": 11,
        "fullcodeline": "if (first == NULL) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (rp == NULL) {"
    },
    {
        "line": 125,
        "fullcodeline": "more_frags = frag->more_frags;"
    },
    {
        "line": 126,
        "fullcodeline": "prev_offset = frag->offset;"
    },
    {
        "line": 136,
        "fullcodeline": "if (unfragmentable_len == 0)"
    },
    {
        "line": 149,
        "fullcodeline": "if (rp != NULL)"
    },
    {
        "line": 30,
        "fullcodeline": "if (frag == first) {"
    },
    {
        "line": 51,
        "fullcodeline": "IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);"
    },
    {
        "line": 70,
        "fullcodeline": "if (!more_frags && frag->offset > prev_offset) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (frag->data_len - frag->ltrim <= 0)"
    },
    {
        "line": 77,
        "fullcodeline": "if (frag->offset == 0) {"
    },
    {
        "line": 137,
        "fullcodeline": "rp->ip6h->s_ip6_nxt = next_hdr;"
    },
    {
        "line": 150,
        "fullcodeline": "PacketFreeOrRelease(rp);"
    },
    {
        "line": 34,
        "fullcodeline": "len = frag->data_len;"
    },
    {
        "line": 78,
        "fullcodeline": "IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt +"
    },
    {
        "line": 80,
        "fullcodeline": "next_hdr = frag_hdr->ip6fh_nxt;"
    },
    {
        "line": 91,
        "fullcodeline": "ip_hdr_offset = frag->ip_hdr_offset;"
    },
    {
        "line": 96,
        "fullcodeline": "fragmentable_offset = frag->frag_hdr_offset;"
    },
    {
        "line": 97,
        "fullcodeline": "fragmentable_len = frag->data_len;"
    },
    {
        "line": 101,
        "fullcodeline": "DEBUG_VALIDATE_BUG_ON(fragmentable_offset < ip_hdr_offset + IPV6_HEADER_LEN);"
    },
    {
        "line": 102,
        "fullcodeline": "DEBUG_VALIDATE_BUG_ON("
    },
    {
        "line": 104,
        "fullcodeline": "unfragmentable_len = (uint16_t)(fragmentable_offset - ip_hdr_offset - IPV6_HEADER_LEN);"
    },
    {
        "line": 13,
        "fullcodeline": "} else if (first->offset != 0) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (frag->offset != 0) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (PacketCopyData(rp, frag->pkt, frag->frag_hdr_offset) == -1)"
    },
    {
        "line": 87,
        "fullcodeline": "if (PacketCopyDataOffset(rp, frag->frag_hdr_offset,"
    },
    {
        "line": 103,
        "fullcodeline": "fragmentable_offset - ip_hdr_offset - IPV6_HEADER_LEN > UINT16_MAX);"
    },
    {
        "line": 105,
        "fullcodeline": "if (unfragmentable_len >= fragmentable_offset)"
    },
    {
        "line": 37,
        "fullcodeline": "if (frag->offset > len) {"
    },
    {
        "line": 89,
        "fullcodeline": "frag->data_len) == -1)"
    },
    {
        "line": 109,
        "fullcodeline": "if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,"
    },
    {
        "line": 113,
        "fullcodeline": "if (frag->offset + frag->data_len > fragmentable_len)"
    },
    {
        "line": 88,
        "fullcodeline": "frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),"
    },
    {
        "line": 111,
        "fullcodeline": "frag->data_len - frag->ltrim) == -1)"
    },
    {
        "line": 114,
        "fullcodeline": "fragmentable_len = frag->offset + frag->data_len;"
    },
    {
        "line": 16,
        "fullcodeline": "} else if (first->len < sizeof(IPV6Hdr)) {"
    },
    {
        "line": 43,
        "fullcodeline": "len += frag->data_len;"
    },
    {
        "line": 110,
        "fullcodeline": "frag->pkt + frag->data_offset + frag->ltrim,"
    }
]