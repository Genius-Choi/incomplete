[
    {
        "line": 3,
        "fullcodeline": "Packet *r = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "uint16_t ltrim = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "uint8_t hlen = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "uint16_t frag_hdr_offset = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int af = tracker->af;"
    },
    {
        "line": 34,
        "fullcodeline": "uint32_t ip6_nh_set_offset = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "uint8_t ip6_nh_set_value = 0;"
    },
    {
        "line": 98,
        "fullcodeline": "tracker->timeout = SCTIME_FROM_SECS(SCTIME_SECS(p->ts) + tracker->host_timeout);"
    },
    {
        "line": 101,
        "fullcodeline": "bool overlap = false;"
    },
    {
        "line": 102,
        "fullcodeline": "ltrim = 0;"
    },
    {
        "line": 314,
        "fullcodeline": "SCMutexLock(&defrag_context->frag_pool_lock);"
    },
    {
        "line": 315,
        "fullcodeline": "Frag *new = PoolGet(defrag_context->frag_pool);"
    },
    {
        "line": 316,
        "fullcodeline": "SCMutexUnlock(&defrag_context->frag_pool_lock);"
    },
    {
        "line": 325,
        "fullcodeline": "new->pkt = SCMalloc(GET_PKT_LEN(p));"
    },
    {
        "line": 337,
        "fullcodeline": "memcpy(new->pkt, GET_PKT_DATA(p) + ltrim, GET_PKT_LEN(p) - ltrim);"
    },
    {
        "line": 338,
        "fullcodeline": "new->len = (GET_PKT_LEN(p) - ltrim);"
    },
    {
        "line": 350,
        "fullcodeline": "new->hlen = hlen;"
    },
    {
        "line": 351,
        "fullcodeline": "new->offset = frag_offset + ltrim;"
    },
    {
        "line": 352,
        "fullcodeline": "new->data_offset = data_offset;"
    },
    {
        "line": 353,
        "fullcodeline": "new->data_len = data_len - ltrim;"
    },
    {
        "line": 354,
        "fullcodeline": "new->ip_hdr_offset = ip_hdr_offset;"
    },
    {
        "line": 355,
        "fullcodeline": "new->frag_hdr_offset = frag_hdr_offset;"
    },
    {
        "line": 356,
        "fullcodeline": "new->more_frags = more_frags;"
    },
    {
        "line": 41,
        "fullcodeline": "if (tracker->af == AF_INET) {"
    },
    {
        "line": 307,
        "fullcodeline": "if (ltrim > data_len) {"
    },
    {
        "line": 317,
        "fullcodeline": "if (new == NULL) {"
    },
    {
        "line": 326,
        "fullcodeline": "if (new->pkt == NULL) {"
    },
    {
        "line": 42,
        "fullcodeline": "more_frags = IPV4_GET_MF(p);"
    },
    {
        "line": 43,
        "fullcodeline": "frag_offset = (uint16_t)(IPV4_GET_IPOFFSET(p) << 3);"
    },
    {
        "line": 44,
        "fullcodeline": "hlen = IPV4_GET_HLEN(p);"
    },
    {
        "line": 45,
        "fullcodeline": "data_offset = (uint16_t)((uint8_t *)p->ip4h + hlen - GET_PKT_DATA(p));"
    },
    {
        "line": 46,
        "fullcodeline": "data_len = IPV4_GET_IPLEN(p) - hlen;"
    },
    {
        "line": 47,
        "fullcodeline": "frag_end = frag_offset + data_len;"
    },
    {
        "line": 48,
        "fullcodeline": "ip_hdr_offset = (uint16_t)((uint8_t *)p->ip4h - GET_PKT_DATA(p));"
    },
    {
        "line": 104,
        "fullcodeline": "if (!RB_EMPTY(&tracker->fragment_tree)) {"
    },
    {
        "line": 105,
        "fullcodeline": "Frag key = {"
    },
    {
        "line": 108,
        "fullcodeline": "next = RB_NFIND(IP_FRAGMENTS, &tracker->fragment_tree, &key);"
    },
    {
        "line": 327,
        "fullcodeline": "SCMutexLock(&defrag_context->frag_pool_lock);"
    },
    {
        "line": 342,
        "fullcodeline": "if (ip6_nh_set_offset > 0 && frag_offset == 0 && ltrim == 0) {"
    },
    {
        "line": 361,
        "fullcodeline": "tracker->datalink = p->datalink;"
    },
    {
        "line": 367,
        "fullcodeline": "tracker->seen_last = 1;"
    },
    {
        "line": 52,
        "fullcodeline": "if (IPV4_HEADER_LEN + frag_offset + data_len > IPV4_MAXPACKET_LEN) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (next == NULL) {"
    },
    {
        "line": 119,
        "fullcodeline": "while (prev != NULL) {"
    },
    {
        "line": 318,
        "fullcodeline": "if (af == AF_INET) {"
    },
    {
        "line": 330,
        "fullcodeline": "if (af == AF_INET) {"
    },
    {
        "line": 343,
        "fullcodeline": "if (new->len > ip6_nh_set_offset) {"
    },
    {
        "line": 371,
        "fullcodeline": "if (tracker->af == AF_INET) {"
    },
    {
        "line": 53,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE);"
    },
    {
        "line": 57,
        "fullcodeline": "else if (tracker->af == AF_INET6) {"
    },
    {
        "line": 110,
        "fullcodeline": "prev = RB_MIN(IP_FRAGMENTS, &tracker->fragment_tree);"
    },
    {
        "line": 111,
        "fullcodeline": "next = IP_FRAGMENTS_RB_NEXT(prev);"
    },
    {
        "line": 286,
        "fullcodeline": "prev = next;"
    },
    {
        "line": 319,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV4_FRAG_IGNORED);"
    },
    {
        "line": 331,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV4_FRAG_IGNORED);"
    },
    {
        "line": 344,
        "fullcodeline": "SCLogDebug(\"updating frag to have 'correct' nh value: %u -> %u\","
    },
    {
        "line": 372,
        "fullcodeline": "r = Defrag4Reassemble(tv, tracker, p);"
    },
    {
        "line": 410,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV4_FRAG_OVERLAP);"
    },
    {
        "line": 59,
        "fullcodeline": "frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);"
    },
    {
        "line": 60,
        "fullcodeline": "data_offset = p->ip6eh.fh_data_offset;"
    },
    {
        "line": 61,
        "fullcodeline": "data_len = p->ip6eh.fh_data_len;"
    },
    {
        "line": 62,
        "fullcodeline": "frag_end = frag_offset + data_len;"
    },
    {
        "line": 63,
        "fullcodeline": "ip_hdr_offset = (uint16_t)((uint8_t *)p->ip6h - GET_PKT_DATA(p));"
    },
    {
        "line": 64,
        "fullcodeline": "frag_hdr_offset = p->ip6eh.fh_header_offset;"
    },
    {
        "line": 66,
        "fullcodeline": "SCLogDebug(\"mf %s frag_offset %u data_offset %u, data_len %u, \""
    },
    {
        "line": 106,
        "fullcodeline": ".offset = frag_offset - 1,"
    },
    {
        "line": 113,
        "fullcodeline": "prev = IP_FRAGMENTS_RB_PREV(next);"
    },
    {
        "line": 287,
        "fullcodeline": "if (next != NULL) {"
    },
    {
        "line": 296,
        "fullcodeline": "if (prev->skip || prev->ltrim >= prev->data_len) {"
    },
    {
        "line": 321,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV6_FRAG_IGNORED);"
    },
    {
        "line": 333,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV6_FRAG_IGNORED);"
    },
    {
        "line": 413,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV6_FRAG_OVERLAP);"
    },
    {
        "line": 58,
        "fullcodeline": "more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);"
    },
    {
        "line": 72,
        "fullcodeline": "if (ip_hdr_offset + IPV6_HEADER_LEN < frag_hdr_offset) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (frag_offset + data_len > IPV6_MAXPACKET) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (prev == NULL) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (frag_offset < prev->offset + prev->data_len && prev->offset < frag_end) {"
    },
    {
        "line": 124,
        "fullcodeline": "overlap = true;"
    },
    {
        "line": 288,
        "fullcodeline": "next = IP_FRAGMENTS_RB_NEXT(next);"
    },
    {
        "line": 297,
        "fullcodeline": "RB_REMOVE(IP_FRAGMENTS, &tracker->fragment_tree, prev);"
    },
    {
        "line": 298,
        "fullcodeline": "DefragFragReset(prev);"
    },
    {
        "line": 299,
        "fullcodeline": "SCMutexLock(&defrag_context->frag_pool_lock);"
    },
    {
        "line": 300,
        "fullcodeline": "PoolReturn(defrag_context->frag_pool, prev);"
    },
    {
        "line": 301,
        "fullcodeline": "SCMutexUnlock(&defrag_context->frag_pool_lock);"
    },
    {
        "line": 373,
        "fullcodeline": "if (r != NULL && tv != NULL && dtv != NULL) {"
    },
    {
        "line": 374,
        "fullcodeline": "StatsIncr(tv, dtv->counter_defrag_ipv4_reassembled);"
    },
    {
        "line": 387,
        "fullcodeline": "else if (tracker->af == AF_INET6) {"
    },
    {
        "line": 80,
        "fullcodeline": "ip6_nh_set_offset = p->ip6eh.fh_prev_hdr_offset;"
    },
    {
        "line": 81,
        "fullcodeline": "ip6_nh_set_value = IPV6_EXTHDR_GET_FH_NH(p);"
    },
    {
        "line": 82,
        "fullcodeline": "SCLogDebug(\"offset %d, value %u\", ip6_nh_set_offset, ip6_nh_set_value);"
    },
    {
        "line": 88,
        "fullcodeline": "ENGINE_SET_EVENT(p, IPV6_FRAG_PKT_TOO_LARGE);"
    },
    {
        "line": 115,
        "fullcodeline": "prev = next;"
    },
    {
        "line": 116,
        "fullcodeline": "next = IP_FRAGMENTS_RB_NEXT(prev);"
    },
    {
        "line": 129,
        "fullcodeline": "if (frag_offset < prev->offset + prev->data_len) {"
    },
    {
        "line": 193,
        "fullcodeline": "if (frag_offset + ltrim < prev->offset + prev->ltrim &&"
    },
    {
        "line": 204,
        "fullcodeline": "if (frag_offset + ltrim <= prev->offset + prev->ltrim &&"
    },
    {
        "line": 213,
        "fullcodeline": "if (frag_offset + ltrim >= prev->offset + ltrim &&"
    },
    {
        "line": 220,
        "fullcodeline": "if (frag_offset + ltrim < prev->offset + ltrim &&"
    },
    {
        "line": 242,
        "fullcodeline": "if (frag_offset + ltrim == prev->offset + ltrim &&"
    },
    {
        "line": 249,
        "fullcodeline": "if (frag_offset < prev->offset + prev->data_len) {"
    },
    {
        "line": 261,
        "fullcodeline": "if ((frag_offset >= prev->offset) &&"
    },
    {
        "line": 265,
        "fullcodeline": "if (frag_offset < prev->offset) {"
    },
    {
        "line": 268,
        "fullcodeline": "if (frag_offset < prev->offset + prev->data_len) {"
    },
    {
        "line": 274,
        "fullcodeline": "if (frag_offset <= prev->offset) {"
    },
    {
        "line": 388,
        "fullcodeline": "r = Defrag6Reassemble(tv, tracker, p);"
    },
    {
        "line": 74,
        "fullcodeline": "(uint32_t)(frag_hdr_offset - (ip_hdr_offset + IPV6_HEADER_LEN)));"
    },
    {
        "line": 180,
        "fullcodeline": "if (prev->offset + prev->ltrim < frag_offset + ltrim &&"
    },
    {
        "line": 181,
        "fullcodeline": "prev->offset + prev->data_len > frag_offset + ltrim) {"
    },
    {
        "line": 182,
        "fullcodeline": "ltrim += prev->offset + prev->data_len - frag_offset;"
    },
    {
        "line": 194,
        "fullcodeline": "frag_end > prev->offset + prev->ltrim) {"
    },
    {
        "line": 195,
        "fullcodeline": "prev->ltrim += frag_end - (prev->offset + prev->ltrim);"
    },
    {
        "line": 205,
        "fullcodeline": "frag_end >= prev->offset + prev->data_len) {"
    },
    {
        "line": 206,
        "fullcodeline": "prev->skip = 1;"
    },
    {
        "line": 214,
        "fullcodeline": "frag_end <= prev->offset + prev->data_len) {"
    },
    {
        "line": 221,
        "fullcodeline": "frag_end > prev->offset + prev->data_len) {"
    },
    {
        "line": 222,
        "fullcodeline": "prev->skip = 1;"
    },
    {
        "line": 233,
        "fullcodeline": "if (frag_offset + ltrim > prev->offset + prev->ltrim &&"
    },
    {
        "line": 234,
        "fullcodeline": "frag_offset + ltrim < prev->offset + prev->data_len) {"
    },
    {
        "line": 235,
        "fullcodeline": "ltrim += prev->offset + prev->data_len - frag_offset;"
    },
    {
        "line": 243,
        "fullcodeline": "frag_end > prev->offset + prev->data_len) {"
    },
    {
        "line": 244,
        "fullcodeline": "ltrim += prev->offset + prev->data_len - frag_offset;"
    },
    {
        "line": 262,
        "fullcodeline": "(frag_end <= prev->offset + prev->data_len)) {"
    },
    {
        "line": 269,
        "fullcodeline": "ltrim = prev->offset + prev->data_len - frag_offset;"
    },
    {
        "line": 375,
        "fullcodeline": "if (DecodeIPV4(tv, dtv, r, (void *)r->ip4h,"
    },
    {
        "line": 378,
        "fullcodeline": "UNSET_TUNNEL_PKT(r);"
    },
    {
        "line": 379,
        "fullcodeline": "r->root = NULL;"
    },
    {
        "line": 381,
        "fullcodeline": "r = NULL;"
    },
    {
        "line": 130,
        "fullcodeline": "if (prev->offset <= frag_offset) {"
    },
    {
        "line": 250,
        "fullcodeline": "if (frag_offset >= prev->offset) {"
    },
    {
        "line": 275,
        "fullcodeline": "if (frag_end > prev->offset) {"
    },
    {
        "line": 376,
        "fullcodeline": "IPV4_GET_IPLEN(r)) != TM_ECODE_OK) {"
    },
    {
        "line": 383,
        "fullcodeline": "PacketDefragPktSetupParent(p);"
    },
    {
        "line": 389,
        "fullcodeline": "if (r != NULL && tv != NULL && dtv != NULL) {"
    },
    {
        "line": 390,
        "fullcodeline": "StatsIncr(tv, dtv->counter_defrag_ipv6_reassembled);"
    },
    {
        "line": 135,
        "fullcodeline": "uint16_t prev_end = prev->offset + prev->data_len;"
    },
    {
        "line": 141,
        "fullcodeline": "ltrim = prev_end - frag_offset;"
    },
    {
        "line": 158,
        "fullcodeline": "if (frag_offset <= prev->offset && frag_end > prev->offset + prev->ltrim) {"
    },
    {
        "line": 159,
        "fullcodeline": "uint16_t prev_ltrim = frag_end - prev->offset;"
    },
    {
        "line": 165,
        "fullcodeline": "if ((next != NULL) && (frag_end > next->offset)) {"
    },
    {
        "line": 251,
        "fullcodeline": "ltrim = prev->offset + prev->data_len - frag_offset;"
    },
    {
        "line": 253,
        "fullcodeline": "if ((frag_offset < prev->offset) &&"
    },
    {
        "line": 254,
        "fullcodeline": "(frag_end >= prev->offset + prev->data_len)) {"
    },
    {
        "line": 255,
        "fullcodeline": "prev->skip = 1;"
    },
    {
        "line": 276,
        "fullcodeline": "prev->ltrim = frag_end - prev->offset;"
    },
    {
        "line": 136,
        "fullcodeline": "if (prev_end > frag_end) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (prev_ltrim > prev->ltrim) {"
    },
    {
        "line": 166,
        "fullcodeline": "next->ltrim = frag_end - next->offset;"
    },
    {
        "line": 391,
        "fullcodeline": "if (DecodeIPV6(tv, dtv, r, (uint8_t *)r->ip6h,"
    },
    {
        "line": 395,
        "fullcodeline": "UNSET_TUNNEL_PKT(r);"
    },
    {
        "line": 396,
        "fullcodeline": "r->root = NULL;"
    },
    {
        "line": 398,
        "fullcodeline": "r = NULL;"
    },
    {
        "line": 143,
        "fullcodeline": "if ((next != NULL) && (frag_end > next->offset)) {"
    },
    {
        "line": 161,
        "fullcodeline": "prev->ltrim = prev_ltrim;"
    },
    {
        "line": 400,
        "fullcodeline": "PacketDefragPktSetupParent(p);"
    },
    {
        "line": 144,
        "fullcodeline": "next->ltrim = frag_end - next->offset;"
    },
    {
        "line": 392,
        "fullcodeline": "IPV6_GET_PLEN(r) + IPV6_HEADER_LEN)"
    }
]