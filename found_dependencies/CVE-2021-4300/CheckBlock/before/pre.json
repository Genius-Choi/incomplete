[
    {
        "line": 74,
        "fullcodeline": "set<uint256> uniqueTx;"
    },
    {
        "line": 81,
        "fullcodeline": "unsigned int nSigOps = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)"
    },
    {
        "line": 28,
        "fullcodeline": "for (unsigned int i = 1; i < vtx.size(); i++)"
    },
    {
        "line": 70,
        "fullcodeline": "if(hashMerkleRoot != BuildMerkleTree())"
    },
    {
        "line": 86,
        "fullcodeline": "if (nSigOps > MAX_BLOCK_SIGOPS)"
    },
    {
        "line": 22,
        "fullcodeline": "if (GetBlockTime() > FutureDrift(GetAdjustedTime()))"
    },
    {
        "line": 26,
        "fullcodeline": "if (vtx.empty() || !vtx[0].IsCoinBase())"
    },
    {
        "line": 29,
        "fullcodeline": "if (vtx[i].IsCoinBase())"
    },
    {
        "line": 33,
        "fullcodeline": "if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))"
    },
    {
        "line": 78,
        "fullcodeline": "if(uniqueTx.size() != vtx.size())"
    },
    {
        "line": 8,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : size limits failed\"));"
    },
    {
        "line": 23,
        "fullcodeline": "return error(\"CheckBlock() : block timestamp too far in the future\");"
    },
    {
        "line": 27,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));"
    },
    {
        "line": 34,
        "fullcodeline": "return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));"
    },
    {
        "line": 45,
        "fullcodeline": "for (unsigned int i = 2; i < vtx.size(); i++)"
    },
    {
        "line": 71,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));"
    },
    {
        "line": 79,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));"
    },
    {
        "line": 87,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));"
    },
    {
        "line": 13,
        "fullcodeline": "if(!CheckProofOfWork(GetHashPoW(), nBits))"
    },
    {
        "line": 30,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : more than one coinbase\"));"
    },
    {
        "line": 39,
        "fullcodeline": "if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())"
    },
    {
        "line": 43,
        "fullcodeline": "if (vtx.empty() || !vtx[1].IsCoinStake())"
    },
    {
        "line": 46,
        "fullcodeline": "if (vtx[i].IsCoinStake())"
    },
    {
        "line": 14,
        "fullcodeline": "return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));"
    },
    {
        "line": 18,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));"
    },
    {
        "line": 40,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));"
    },
    {
        "line": 44,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));"
    },
    {
        "line": 55,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));"
    },
    {
        "line": 47,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : more than one coinstake\"));"
    }
]