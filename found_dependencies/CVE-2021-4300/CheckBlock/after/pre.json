[
    {
        "line": 82,
        "fullcodeline": "set<uint256> uniqueTx;"
    },
    {
        "line": 89,
        "fullcodeline": "unsigned int nSigOps = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)"
    },
    {
        "line": 18,
        "fullcodeline": "for(i = 1; i < vtx.size(); i++) {"
    },
    {
        "line": 78,
        "fullcodeline": "if(hashMerkleRoot != BuildMerkleTree())"
    },
    {
        "line": 94,
        "fullcodeline": "if (nSigOps > MAX_BLOCK_SIGOPS)"
    },
    {
        "line": 12,
        "fullcodeline": "if (GetBlockTime() > FutureDrift(GetAdjustedTime()))"
    },
    {
        "line": 16,
        "fullcodeline": "if (vtx.empty() || !vtx[0].IsCoinBase())"
    },
    {
        "line": 24,
        "fullcodeline": "if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))"
    },
    {
        "line": 86,
        "fullcodeline": "if(uniqueTx.size() != vtx.size())"
    },
    {
        "line": 9,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : size limits failed\"));"
    },
    {
        "line": 13,
        "fullcodeline": "return error(\"CheckBlock() : block timestamp too far in the future\");"
    },
    {
        "line": 17,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));"
    },
    {
        "line": 19,
        "fullcodeline": "if(vtx[i].IsCoinBase())"
    },
    {
        "line": 25,
        "fullcodeline": "return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));"
    },
    {
        "line": 36,
        "fullcodeline": "for(i = 2; i < vtx.size(); i++) {"
    },
    {
        "line": 79,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));"
    },
    {
        "line": 87,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));"
    },
    {
        "line": 95,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));"
    },
    {
        "line": 30,
        "fullcodeline": "if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())"
    },
    {
        "line": 34,
        "fullcodeline": "if (vtx.empty() || !vtx[1].IsCoinStake())"
    },
    {
        "line": 52,
        "fullcodeline": "for(i = 1; i < vtx.size(); i++) {"
    },
    {
        "line": 20,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : more than one coin base\")));"
    },
    {
        "line": 31,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));"
    },
    {
        "line": 35,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));"
    },
    {
        "line": 37,
        "fullcodeline": "if(vtx[i].IsCoinStake())"
    },
    {
        "line": 47,
        "fullcodeline": "return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));"
    },
    {
        "line": 58,
        "fullcodeline": "if(!CheckProofOfWork(GetHashPoW(), nBits))"
    },
    {
        "line": 59,
        "fullcodeline": "return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));"
    },
    {
        "line": 63,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));"
    },
    {
        "line": 38,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : more than one coin stake\")));"
    },
    {
        "line": 53,
        "fullcodeline": "if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))"
    },
    {
        "line": 54,
        "fullcodeline": "return(DoS(100, error(\"CheckBlock() : rogue coin stake\")));"
    }
]