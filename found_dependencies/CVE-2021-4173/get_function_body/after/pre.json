[
    {
        "line": 7,
        "fullcodeline": "linenr_T\tsourcing_lnum_top = SOURCING_LNUM;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tsaved_wait_return = need_wait_return;"
    },
    {
        "line": 10,
        "fullcodeline": "char_u\t*line_arg = line_arg_in;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tvim9_function = eap->cmdidx == CMD_def"
    },
    {
        "line": 14,
        "fullcodeline": "char\tnesting_def[MAX_FUNC_NESTING];"
    },
    {
        "line": 15,
        "fullcodeline": "char\tnesting_inline[MAX_FUNC_NESTING];"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tnesting = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "int\t\tindent = 2;"
    },
    {
        "line": 19,
        "fullcodeline": "char_u\t*skip_until = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "int\t\tret = FAIL;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tis_heredoc = FALSE;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\theredoc_concat_len = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "char_u\t*heredoc_trimmed = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "ga_init2(&heredoc_ga, 1, 500);"
    },
    {
        "line": 30,
        "fullcodeline": "sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);"
    },
    {
        "line": 40,
        "fullcodeline": "nesting_def[0] = vim9_function;"
    },
    {
        "line": 41,
        "fullcodeline": "nesting_inline[0] = eap->cmdidx == CMD_block;"
    },
    {
        "line": 42,
        "fullcodeline": "getline_options = vim9_function"
    },
    {
        "line": 421,
        "fullcodeline": "vim_free(skip_until);"
    },
    {
        "line": 422,
        "fullcodeline": "vim_free(heredoc_trimmed);"
    },
    {
        "line": 423,
        "fullcodeline": "vim_free(heredoc_ga.ga_data);"
    },
    {
        "line": 424,
        "fullcodeline": "need_wait_return |= saved_wait_return;"
    },
    {
        "line": 31,
        "fullcodeline": "if (SOURCING_LNUM < sourcing_lnum_off)"
    },
    {
        "line": 417,
        "fullcodeline": "if (!did_emsg)"
    },
    {
        "line": 12,
        "fullcodeline": "|| eap->cmdidx == CMD_block;"
    },
    {
        "line": 33,
        "fullcodeline": "sourcing_lnum_off -= SOURCING_LNUM;"
    },
    {
        "line": 55,
        "fullcodeline": "need_wait_return = FALSE;"
    },
    {
        "line": 100,
        "fullcodeline": "sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);"
    },
    {
        "line": 404,
        "fullcodeline": "((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;"
    },
    {
        "line": 418,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 34,
        "fullcodeline": "if (ga_grow(newlines, sourcing_lnum_off) == FAIL)"
    },
    {
        "line": 36,
        "fullcodeline": "while (sourcing_lnum_off-- > 0)"
    },
    {
        "line": 37,
        "fullcodeline": "((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;"
    },
    {
        "line": 57,
        "fullcodeline": "if (line_arg != NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "if (theline == NULL)"
    },
    {
        "line": 101,
        "fullcodeline": "if (SOURCING_LNUM < sourcing_lnum_off)"
    },
    {
        "line": 106,
        "fullcodeline": "if (skip_until != NULL)"
    },
    {
        "line": 384,
        "fullcodeline": "if (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)"
    },
    {
        "line": 387,
        "fullcodeline": "if (heredoc_concat_len > 0)"
    },
    {
        "line": 402,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 408,
        "fullcodeline": "while (sourcing_lnum_off-- > 0)"
    },
    {
        "line": 409,
        "fullcodeline": "((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;"
    },
    {
        "line": 412,
        "fullcodeline": "if (line_arg != NULL && *line_arg == NUL)"
    },
    {
        "line": 52,
        "fullcodeline": "msg_scroll = TRUE;"
    },
    {
        "line": 53,
        "fullcodeline": "saved_wait_return = FALSE;"
    },
    {
        "line": 60,
        "fullcodeline": "theline = line_arg;"
    },
    {
        "line": 61,
        "fullcodeline": "p = vim_strchr(theline, '\\n');"
    },
    {
        "line": 83,
        "fullcodeline": "lines_left = Rows - 1;"
    },
    {
        "line": 87,
        "fullcodeline": "SOURCING_LNUM = sourcing_lnum_top;"
    },
    {
        "line": 102,
        "fullcodeline": "sourcing_lnum_off -= SOURCING_LNUM;"
    },
    {
        "line": 391,
        "fullcodeline": "ga_concat(&heredoc_ga, theline);"
    },
    {
        "line": 392,
        "fullcodeline": "ga_concat(&heredoc_ga, (char_u *)\"\\n\");"
    },
    {
        "line": 393,
        "fullcodeline": "p = vim_strsave((char_u *)\"\");"
    },
    {
        "line": 413,
        "fullcodeline": "line_arg = NULL;"
    },
    {
        "line": 62,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 79,
        "fullcodeline": "vim_free(*line_to_free);"
    },
    {
        "line": 80,
        "fullcodeline": "*line_to_free = theline;"
    },
    {
        "line": 88,
        "fullcodeline": "if (skip_until != NULL)"
    },
    {
        "line": 104,
        "fullcodeline": "sourcing_lnum_off = 0;"
    },
    {
        "line": 112,
        "fullcodeline": "if (heredoc_trimmed == NULL"
    },
    {
        "line": 229,
        "fullcodeline": "c = *p;"
    },
    {
        "line": 293,
        "fullcodeline": "p = skip_range(p, FALSE, NULL);"
    },
    {
        "line": 310,
        "fullcodeline": "arg = skipwhite(skiptowhite(p));"
    },
    {
        "line": 351,
        "fullcodeline": "arg = skipwhite(skiptowhite(p));"
    },
    {
        "line": 400,
        "fullcodeline": "p = vim_strsave(theline);"
    },
    {
        "line": 63,
        "fullcodeline": "line_arg += STRLEN(line_arg);"
    },
    {
        "line": 72,
        "fullcodeline": "if (eap->getline == NULL)"
    },
    {
        "line": 77,
        "fullcodeline": "if (*eap->cmdlinep == *line_to_free)"
    },
    {
        "line": 89,
        "fullcodeline": "semsg(_(e_missing_heredoc_end_marker_str), skip_until);"
    },
    {
        "line": 114,
        "fullcodeline": "|| STRNCMP(theline, heredoc_trimmed,"
    },
    {
        "line": 154,
        "fullcodeline": "for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)"
    },
    {
        "line": 159,
        "fullcodeline": "if (nesting_inline[nesting]"
    },
    {
        "line": 218,
        "fullcodeline": "if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))"
    },
    {
        "line": 230,
        "fullcodeline": "if (is_function_cmd(&p)"
    },
    {
        "line": 252,
        "fullcodeline": "if (nesting_def[nesting] ? *p != '#' : *p != '\"')"
    },
    {
        "line": 294,
        "fullcodeline": "if (!vim9_function"
    },
    {
        "line": 311,
        "fullcodeline": "if (arg[0] == '<' && arg[1] =='<'"
    },
    {
        "line": 352,
        "fullcodeline": "if (*arg == '[')"
    },
    {
        "line": 354,
        "fullcodeline": "if (arg != NULL)"
    },
    {
        "line": 66,
        "fullcodeline": "*p = NUL;"
    },
    {
        "line": 67,
        "fullcodeline": "line_arg = p + 1;"
    },
    {
        "line": 73,
        "fullcodeline": "theline = getcmdline(':', 0L, indent, getline_options);"
    },
    {
        "line": 78,
        "fullcodeline": "*eap->cmdlinep = theline;"
    },
    {
        "line": 113,
        "fullcodeline": "|| (is_heredoc && skipwhite(theline) == theline)"
    },
    {
        "line": 117,
        "fullcodeline": "if (heredoc_trimmed == NULL)"
    },
    {
        "line": 124,
        "fullcodeline": "if (STRCMP(p, skip_until) == 0)"
    },
    {
        "line": 160,
        "fullcodeline": "? *p == '}'"
    },
    {
        "line": 161,
        "fullcodeline": ": (checkforcmd(&p, nesting_def[nesting]"
    },
    {
        "line": 219,
        "fullcodeline": "indent -= 2;"
    },
    {
        "line": 231,
        "fullcodeline": "|| (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))"
    },
    {
        "line": 235,
        "fullcodeline": "p += eval_fname_script(p);"
    },
    {
        "line": 236,
        "fullcodeline": "vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,"
    },
    {
        "line": 255,
        "fullcodeline": "end = p + STRLEN(p) - 1;"
    },
    {
        "line": 295,
        "fullcodeline": "&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))"
    },
    {
        "line": 307,
        "fullcodeline": "skip_until = vim_strsave((char_u *)\".\");"
    },
    {
        "line": 312,
        "fullcodeline": "&& ((p[0] == 'p' && p[1] == 'y'"
    },
    {
        "line": 329,
        "fullcodeline": "p = skipwhite(arg + 2);"
    },
    {
        "line": 341,
        "fullcodeline": "getline_options = GETLINE_NONE;"
    },
    {
        "line": 342,
        "fullcodeline": "is_heredoc = TRUE;"
    },
    {
        "line": 353,
        "fullcodeline": "arg = vim_strchr(arg, ']');"
    },
    {
        "line": 356,
        "fullcodeline": "int found = (eap->cmdidx == CMD_def && arg[0] == '='"
    },
    {
        "line": 75,
        "fullcodeline": "theline = eap->getline(':', eap->cookie, indent,"
    },
    {
        "line": 115,
        "fullcodeline": "STRLEN(heredoc_trimmed)) == 0)"
    },
    {
        "line": 118,
        "fullcodeline": "p = theline;"
    },
    {
        "line": 126,
        "fullcodeline": "VIM_CLEAR(skip_until);"
    },
    {
        "line": 127,
        "fullcodeline": "VIM_CLEAR(heredoc_trimmed);"
    },
    {
        "line": 128,
        "fullcodeline": "getline_options = vim9_function"
    },
    {
        "line": 130,
        "fullcodeline": "is_heredoc = FALSE;"
    },
    {
        "line": 163,
        "fullcodeline": "&& *p != ':'))"
    },
    {
        "line": 165,
        "fullcodeline": "if (nesting-- == 0)"
    },
    {
        "line": 233,
        "fullcodeline": "if (*p == '!')"
    },
    {
        "line": 238,
        "fullcodeline": "if (*skipwhite(p) == '(')"
    },
    {
        "line": 256,
        "fullcodeline": "while (end > p && VIM_ISWHITE(*end))"
    },
    {
        "line": 257,
        "fullcodeline": "--end;"
    },
    {
        "line": 258,
        "fullcodeline": "if (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))"
    },
    {
        "line": 301,
        "fullcodeline": "|| (p[0] == 'i'"
    },
    {
        "line": 324,
        "fullcodeline": "|| (p[0] == 'm' && p[1] == 'z'"
    },
    {
        "line": 330,
        "fullcodeline": "if (STRNCMP(p, \"trim\", 4) == 0)"
    },
    {
        "line": 337,
        "fullcodeline": "if (*p == NUL)"
    },
    {
        "line": 343,
        "fullcodeline": "if (eap->cmdidx == CMD_def)"
    },
    {
        "line": 359,
        "fullcodeline": "if (!found)"
    },
    {
        "line": 362,
        "fullcodeline": "if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'"
    },
    {
        "line": 91,
        "fullcodeline": "emsg(_(e_missing_end_block));"
    },
    {
        "line": 132,
        "fullcodeline": "if (heredoc_concat_len > 0)"
    },
    {
        "line": 167,
        "fullcodeline": "char_u *nextcmd = NULL;"
    },
    {
        "line": 220,
        "fullcodeline": "else if (STRNCMP(p, \"if\", 2) == 0"
    },
    {
        "line": 234,
        "fullcodeline": "p = skipwhite(p + 1);"
    },
    {
        "line": 263,
        "fullcodeline": "--end;"
    },
    {
        "line": 266,
        "fullcodeline": "is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';"
    },
    {
        "line": 296,
        "fullcodeline": "|| (p[0] == 'c'"
    },
    {
        "line": 302,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'"
    },
    {
        "line": 322,
        "fullcodeline": "|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'"
    },
    {
        "line": 325,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || p[2] == 's'))"
    },
    {
        "line": 333,
        "fullcodeline": "p = skipwhite(p + 4);"
    },
    {
        "line": 334,
        "fullcodeline": "heredoc_trimmed = vim_strnsave(theline,"
    },
    {
        "line": 338,
        "fullcodeline": "skip_until = vim_strsave((char_u *)\".\");"
    },
    {
        "line": 344,
        "fullcodeline": "heredoc_concat_len = newlines->ga_len + 1;"
    },
    {
        "line": 357,
        "fullcodeline": "&& arg[1] == '<' && arg[2] =='<');"
    },
    {
        "line": 361,
        "fullcodeline": "arg = skipwhite(skiptowhite(arg));"
    },
    {
        "line": 368,
        "fullcodeline": "p = skipwhite(arg + 3);"
    },
    {
        "line": 376,
        "fullcodeline": "skip_until = vim_strnsave(p, skiptowhite(p) - p);"
    },
    {
        "line": 377,
        "fullcodeline": "getline_options = GETLINE_NONE;"
    },
    {
        "line": 378,
        "fullcodeline": "is_heredoc = TRUE;"
    },
    {
        "line": 136,
        "fullcodeline": "ga_concat(&heredoc_ga, theline);"
    },
    {
        "line": 137,
        "fullcodeline": "vim_free(((char_u **)(newlines->ga_data))["
    },
    {
        "line": 139,
        "fullcodeline": "((char_u **)(newlines->ga_data))["
    },
    {
        "line": 141,
        "fullcodeline": "ga_init(&heredoc_ga);"
    },
    {
        "line": 142,
        "fullcodeline": "heredoc_concat_len = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "theline += STRLEN(theline);  // skip the \"EOF\""
    },
    {
        "line": 169,
        "fullcodeline": "if (*p == '|' || *p == '}')"
    },
    {
        "line": 185,
        "fullcodeline": "if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)"
    },
    {
        "line": 223,
        "fullcodeline": "|| STRNCMP(p, \"try\", 3) == 0)"
    },
    {
        "line": 224,
        "fullcodeline": "indent += 2;"
    },
    {
        "line": 240,
        "fullcodeline": "if (nesting == MAX_FUNC_NESTING - 1)"
    },
    {
        "line": 264,
        "fullcodeline": "while (end > p && VIM_ISWHITE(*end))"
    },
    {
        "line": 265,
        "fullcodeline": "--end;"
    },
    {
        "line": 267,
        "fullcodeline": "if (!is_block)"
    },
    {
        "line": 297,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'"
    },
    {
        "line": 320,
        "fullcodeline": "|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'"
    },
    {
        "line": 323,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))"
    },
    {
        "line": 340,
        "fullcodeline": "skip_until = vim_strnsave(p, skiptowhite(p) - p);"
    },
    {
        "line": 363,
        "fullcodeline": "&& (checkforcmd(&p, \"let\", 2)"
    },
    {
        "line": 369,
        "fullcodeline": "if (STRNCMP(p, \"trim\", 4) == 0)"
    },
    {
        "line": 92,
        "fullcodeline": "else if (eap->cmdidx == CMD_def)"
    },
    {
        "line": 120,
        "fullcodeline": "p = skipwhite(theline) == theline"
    },
    {
        "line": 170,
        "fullcodeline": "nextcmd = p + 1;"
    },
    {
        "line": 190,
        "fullcodeline": "eap->nextcmd = nextcmd;"
    },
    {
        "line": 210,
        "fullcodeline": "if (checkforcmd(&p, \"endfunction\", 4) && *p != ':')"
    },
    {
        "line": 222,
        "fullcodeline": "|| STRNCMP(p, \"for\", 3) == 0"
    },
    {
        "line": 241,
        "fullcodeline": "emsg(_(e_function_nesting_too_deep));"
    },
    {
        "line": 269,
        "fullcodeline": "char_u *s = p;"
    },
    {
        "line": 273,
        "fullcodeline": "is_block = checkforcmd_noparen(&s, \"autocmd\", 2)"
    },
    {
        "line": 303,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2])"
    },
    {
        "line": 318,
        "fullcodeline": "|| (p[0] == 't' && p[1] == 'c'"
    },
    {
        "line": 321,
        "fullcodeline": "&& !ASCII_ISALPHA(p[3]))"
    },
    {
        "line": 335,
        "fullcodeline": "skipwhite(theline) - theline);"
    },
    {
        "line": 366,
        "fullcodeline": "|| checkforcmd(&p, \"const\", 5))))"
    },
    {
        "line": 372,
        "fullcodeline": "p = skipwhite(p + 4);"
    },
    {
        "line": 373,
        "fullcodeline": "heredoc_trimmed = vim_strnsave(theline,"
    },
    {
        "line": 93,
        "fullcodeline": "emsg(_(e_missing_enddef));"
    },
    {
        "line": 123,
        "fullcodeline": "p = theline + STRLEN(heredoc_trimmed);"
    },
    {
        "line": 138,
        "fullcodeline": "heredoc_concat_len - 1]);"
    },
    {
        "line": 191,
        "fullcodeline": "if (*line_to_free != NULL"
    },
    {
        "line": 211,
        "fullcodeline": "emsg(_(e_mismatched_endfunction));"
    },
    {
        "line": 213,
        "fullcodeline": "else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))"
    },
    {
        "line": 221,
        "fullcodeline": "|| STRNCMP(p, \"wh\", 2) == 0"
    },
    {
        "line": 244,
        "fullcodeline": "++nesting;"
    },
    {
        "line": 245,
        "fullcodeline": "nesting_def[nesting] = (c == 'd');"
    },
    {
        "line": 246,
        "fullcodeline": "nesting_inline[nesting] = FALSE;"
    },
    {
        "line": 247,
        "fullcodeline": "indent += 2;"
    },
    {
        "line": 279,
        "fullcodeline": "if (nesting == MAX_FUNC_NESTING - 1)"
    },
    {
        "line": 298,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'"
    },
    {
        "line": 304,
        "fullcodeline": "|| (p[2] == 's'"
    },
    {
        "line": 316,
        "fullcodeline": "|| (p[0] == 'p' && p[1] == 'e'"
    },
    {
        "line": 319,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))"
    },
    {
        "line": 365,
        "fullcodeline": "|| checkforcmd(&p, \"final\", 5)"
    },
    {
        "line": 95,
        "fullcodeline": "emsg(_(\"E126: Missing :endfunction\"));"
    },
    {
        "line": 121,
        "fullcodeline": "? theline : theline + STRLEN(heredoc_trimmed);"
    },
    {
        "line": 171,
        "fullcodeline": "else if (line_arg != NULL && *skipwhite(line_arg) != NUL)"
    },
    {
        "line": 192,
        "fullcodeline": "&& *eap->cmdlinep != *line_to_free)"
    },
    {
        "line": 194,
        "fullcodeline": "vim_free(*eap->cmdlinep);"
    },
    {
        "line": 195,
        "fullcodeline": "*eap->cmdlinep = *line_to_free;"
    },
    {
        "line": 196,
        "fullcodeline": "*line_to_free = NULL;"
    },
    {
        "line": 214,
        "fullcodeline": "emsg(_(e_mismatched_enddef));"
    },
    {
        "line": 274,
        "fullcodeline": "|| checkforcmd_noparen(&s, \"command\", 3);"
    },
    {
        "line": 280,
        "fullcodeline": "emsg(_(e_function_nesting_too_deep));"
    },
    {
        "line": 305,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[3])"
    },
    {
        "line": 313,
        "fullcodeline": "&& (!ASCII_ISALNUM(p[2]) || p[2] == 't'"
    },
    {
        "line": 317,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))"
    },
    {
        "line": 364,
        "fullcodeline": "|| checkforcmd(&p, \"var\", 3)"
    },
    {
        "line": 374,
        "fullcodeline": "skipwhite(theline) - theline);"
    },
    {
        "line": 172,
        "fullcodeline": "nextcmd = line_arg;"
    },
    {
        "line": 283,
        "fullcodeline": "++nesting;"
    },
    {
        "line": 284,
        "fullcodeline": "nesting_def[nesting] = TRUE;"
    },
    {
        "line": 285,
        "fullcodeline": "nesting_inline[nesting] = TRUE;"
    },
    {
        "line": 286,
        "fullcodeline": "indent += 2;"
    },
    {
        "line": 299,
        "fullcodeline": "&& (STRNCMP(&p[3], \"nge\", 3) != 0"
    },
    {
        "line": 306,
        "fullcodeline": "|| p[3] == 'e'))))))))"
    },
    {
        "line": 314,
        "fullcodeline": "|| ((p[2] == '3' || p[2] == 'x')"
    },
    {
        "line": 300,
        "fullcodeline": "|| !ASCII_ISALPHA(p[6])))))))"
    },
    {
        "line": 315,
        "fullcodeline": "&& !ASCII_ISALPHA(p[3]))))"
    },
    {
        "line": 173,
        "fullcodeline": "else if (*p != NUL && *p != (vim9_function ? '#' : '\"')"
    },
    {
        "line": 174,
        "fullcodeline": "&& (vim9_function || p_verbose > 0))"
    },
    {
        "line": 176,
        "fullcodeline": "SOURCING_LNUM = sourcing_lnum_top"
    },
    {
        "line": 178,
        "fullcodeline": "if (eap->cmdidx == CMD_def)"
    },
    {
        "line": 179,
        "fullcodeline": "semsg(_(e_text_found_after_enddef_str), p);"
    },
    {
        "line": 181,
        "fullcodeline": "give_warning2((char_u *)"
    },
    {
        "line": 182,
        "fullcodeline": "_(\"W22: Text found after :endfunction: %s\"),"
    }
]