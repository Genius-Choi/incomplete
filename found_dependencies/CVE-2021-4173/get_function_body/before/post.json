[
    {
        "line": 7,
        "fullcodeline": "linenr_T\tsourcing_lnum_top = SOURCING_LNUM;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tsaved_wait_return = need_wait_return;"
    },
    {
        "line": 10,
        "fullcodeline": "char_u\t*line_arg = line_arg_in;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tvim9_function = eap->cmdidx == CMD_def"
    },
    {
        "line": 14,
        "fullcodeline": "char\tnesting_def[MAX_FUNC_NESTING];"
    },
    {
        "line": 15,
        "fullcodeline": "char\tnesting_inline[MAX_FUNC_NESTING];"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tnesting = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "int\t\tindent = 2;"
    },
    {
        "line": 19,
        "fullcodeline": "char_u\t*skip_until = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "int\t\tret = FAIL;"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tis_heredoc = FALSE;"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\theredoc_concat_len = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "char_u\t*heredoc_trimmed = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "ga_init2(&heredoc_ga, 1, 500);"
    },
    {
        "line": 30,
        "fullcodeline": "sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);"
    },
    {
        "line": 40,
        "fullcodeline": "nesting_def[0] = vim9_function;"
    },
    {
        "line": 41,
        "fullcodeline": "nesting_inline[0] = eap->cmdidx == CMD_block;"
    },
    {
        "line": 42,
        "fullcodeline": "getline_options = vim9_function"
    },
    {
        "line": 418,
        "fullcodeline": "vim_free(skip_until);"
    },
    {
        "line": 419,
        "fullcodeline": "vim_free(heredoc_trimmed);"
    },
    {
        "line": 420,
        "fullcodeline": "vim_free(heredoc_ga.ga_data);"
    },
    {
        "line": 421,
        "fullcodeline": "need_wait_return |= saved_wait_return;"
    },
    {
        "line": 31,
        "fullcodeline": "if (SOURCING_LNUM < sourcing_lnum_off)"
    },
    {
        "line": 414,
        "fullcodeline": "if (!did_emsg)"
    },
    {
        "line": 12,
        "fullcodeline": "|| eap->cmdidx == CMD_block;"
    },
    {
        "line": 33,
        "fullcodeline": "sourcing_lnum_off -= SOURCING_LNUM;"
    },
    {
        "line": 55,
        "fullcodeline": "need_wait_return = FALSE;"
    },
    {
        "line": 98,
        "fullcodeline": "sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);"
    },
    {
        "line": 401,
        "fullcodeline": "((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;"
    },
    {
        "line": 415,
        "fullcodeline": "ret = OK;"
    },
    {
        "line": 34,
        "fullcodeline": "if (ga_grow(newlines, sourcing_lnum_off) == FAIL)"
    },
    {
        "line": 36,
        "fullcodeline": "while (sourcing_lnum_off-- > 0)"
    },
    {
        "line": 37,
        "fullcodeline": "((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;"
    },
    {
        "line": 57,
        "fullcodeline": "if (line_arg != NULL)"
    },
    {
        "line": 82,
        "fullcodeline": "if (theline == NULL)"
    },
    {
        "line": 99,
        "fullcodeline": "if (SOURCING_LNUM < sourcing_lnum_off)"
    },
    {
        "line": 104,
        "fullcodeline": "if (skip_until != NULL)"
    },
    {
        "line": 381,
        "fullcodeline": "if (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)"
    },
    {
        "line": 384,
        "fullcodeline": "if (heredoc_concat_len > 0)"
    },
    {
        "line": 399,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 405,
        "fullcodeline": "while (sourcing_lnum_off-- > 0)"
    },
    {
        "line": 406,
        "fullcodeline": "((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;"
    },
    {
        "line": 409,
        "fullcodeline": "if (line_arg != NULL && *line_arg == NUL)"
    },
    {
        "line": 52,
        "fullcodeline": "msg_scroll = TRUE;"
    },
    {
        "line": 53,
        "fullcodeline": "saved_wait_return = FALSE;"
    },
    {
        "line": 60,
        "fullcodeline": "theline = line_arg;"
    },
    {
        "line": 61,
        "fullcodeline": "p = vim_strchr(theline, '\\n');"
    },
    {
        "line": 81,
        "fullcodeline": "lines_left = Rows - 1;"
    },
    {
        "line": 85,
        "fullcodeline": "SOURCING_LNUM = sourcing_lnum_top;"
    },
    {
        "line": 100,
        "fullcodeline": "sourcing_lnum_off -= SOURCING_LNUM;"
    },
    {
        "line": 388,
        "fullcodeline": "ga_concat(&heredoc_ga, theline);"
    },
    {
        "line": 389,
        "fullcodeline": "ga_concat(&heredoc_ga, (char_u *)\"\\n\");"
    },
    {
        "line": 390,
        "fullcodeline": "p = vim_strsave((char_u *)\"\");"
    },
    {
        "line": 410,
        "fullcodeline": "line_arg = NULL;"
    },
    {
        "line": 62,
        "fullcodeline": "if (p == NULL)"
    },
    {
        "line": 72,
        "fullcodeline": "vim_free(*line_to_free);"
    },
    {
        "line": 78,
        "fullcodeline": "*line_to_free = theline;"
    },
    {
        "line": 86,
        "fullcodeline": "if (skip_until != NULL)"
    },
    {
        "line": 102,
        "fullcodeline": "sourcing_lnum_off = 0;"
    },
    {
        "line": 110,
        "fullcodeline": "if (heredoc_trimmed == NULL"
    },
    {
        "line": 226,
        "fullcodeline": "c = *p;"
    },
    {
        "line": 290,
        "fullcodeline": "p = skip_range(p, FALSE, NULL);"
    },
    {
        "line": 307,
        "fullcodeline": "arg = skipwhite(skiptowhite(p));"
    },
    {
        "line": 348,
        "fullcodeline": "arg = skipwhite(skiptowhite(p));"
    },
    {
        "line": 397,
        "fullcodeline": "p = vim_strsave(theline);"
    },
    {
        "line": 63,
        "fullcodeline": "line_arg += STRLEN(line_arg);"
    },
    {
        "line": 73,
        "fullcodeline": "if (eap->getline == NULL)"
    },
    {
        "line": 87,
        "fullcodeline": "semsg(_(e_missing_heredoc_end_marker_str), skip_until);"
    },
    {
        "line": 112,
        "fullcodeline": "|| STRNCMP(theline, heredoc_trimmed,"
    },
    {
        "line": 152,
        "fullcodeline": "for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)"
    },
    {
        "line": 157,
        "fullcodeline": "if (nesting_inline[nesting]"
    },
    {
        "line": 215,
        "fullcodeline": "if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))"
    },
    {
        "line": 227,
        "fullcodeline": "if (is_function_cmd(&p)"
    },
    {
        "line": 249,
        "fullcodeline": "if (nesting_def[nesting] ? *p != '#' : *p != '\"')"
    },
    {
        "line": 291,
        "fullcodeline": "if (!vim9_function"
    },
    {
        "line": 308,
        "fullcodeline": "if (arg[0] == '<' && arg[1] =='<'"
    },
    {
        "line": 349,
        "fullcodeline": "if (*arg == '[')"
    },
    {
        "line": 351,
        "fullcodeline": "if (arg != NULL)"
    },
    {
        "line": 66,
        "fullcodeline": "*p = NUL;"
    },
    {
        "line": 67,
        "fullcodeline": "line_arg = p + 1;"
    },
    {
        "line": 74,
        "fullcodeline": "theline = getcmdline(':', 0L, indent, getline_options);"
    },
    {
        "line": 111,
        "fullcodeline": "|| (is_heredoc && skipwhite(theline) == theline)"
    },
    {
        "line": 115,
        "fullcodeline": "if (heredoc_trimmed == NULL)"
    },
    {
        "line": 122,
        "fullcodeline": "if (STRCMP(p, skip_until) == 0)"
    },
    {
        "line": 158,
        "fullcodeline": "? *p == '}'"
    },
    {
        "line": 159,
        "fullcodeline": ": (checkforcmd(&p, nesting_def[nesting]"
    },
    {
        "line": 216,
        "fullcodeline": "indent -= 2;"
    },
    {
        "line": 228,
        "fullcodeline": "|| (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))"
    },
    {
        "line": 232,
        "fullcodeline": "p += eval_fname_script(p);"
    },
    {
        "line": 233,
        "fullcodeline": "vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,"
    },
    {
        "line": 252,
        "fullcodeline": "end = p + STRLEN(p) - 1;"
    },
    {
        "line": 292,
        "fullcodeline": "&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))"
    },
    {
        "line": 304,
        "fullcodeline": "skip_until = vim_strsave((char_u *)\".\");"
    },
    {
        "line": 309,
        "fullcodeline": "&& ((p[0] == 'p' && p[1] == 'y'"
    },
    {
        "line": 326,
        "fullcodeline": "p = skipwhite(arg + 2);"
    },
    {
        "line": 338,
        "fullcodeline": "getline_options = GETLINE_NONE;"
    },
    {
        "line": 339,
        "fullcodeline": "is_heredoc = TRUE;"
    },
    {
        "line": 350,
        "fullcodeline": "arg = vim_strchr(arg, ']');"
    },
    {
        "line": 353,
        "fullcodeline": "int found = (eap->cmdidx == CMD_def && arg[0] == '='"
    },
    {
        "line": 76,
        "fullcodeline": "theline = eap->getline(':', eap->cookie, indent,"
    },
    {
        "line": 113,
        "fullcodeline": "STRLEN(heredoc_trimmed)) == 0)"
    },
    {
        "line": 116,
        "fullcodeline": "p = theline;"
    },
    {
        "line": 124,
        "fullcodeline": "VIM_CLEAR(skip_until);"
    },
    {
        "line": 125,
        "fullcodeline": "VIM_CLEAR(heredoc_trimmed);"
    },
    {
        "line": 126,
        "fullcodeline": "getline_options = vim9_function"
    },
    {
        "line": 128,
        "fullcodeline": "is_heredoc = FALSE;"
    },
    {
        "line": 161,
        "fullcodeline": "&& *p != ':'))"
    },
    {
        "line": 163,
        "fullcodeline": "if (nesting-- == 0)"
    },
    {
        "line": 230,
        "fullcodeline": "if (*p == '!')"
    },
    {
        "line": 235,
        "fullcodeline": "if (*skipwhite(p) == '(')"
    },
    {
        "line": 253,
        "fullcodeline": "while (end > p && VIM_ISWHITE(*end))"
    },
    {
        "line": 254,
        "fullcodeline": "--end;"
    },
    {
        "line": 255,
        "fullcodeline": "if (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))"
    },
    {
        "line": 298,
        "fullcodeline": "|| (p[0] == 'i'"
    },
    {
        "line": 321,
        "fullcodeline": "|| (p[0] == 'm' && p[1] == 'z'"
    },
    {
        "line": 327,
        "fullcodeline": "if (STRNCMP(p, \"trim\", 4) == 0)"
    },
    {
        "line": 334,
        "fullcodeline": "if (*p == NUL)"
    },
    {
        "line": 340,
        "fullcodeline": "if (eap->cmdidx == CMD_def)"
    },
    {
        "line": 356,
        "fullcodeline": "if (!found)"
    },
    {
        "line": 359,
        "fullcodeline": "if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'"
    },
    {
        "line": 89,
        "fullcodeline": "emsg(_(e_missing_end_block));"
    },
    {
        "line": 130,
        "fullcodeline": "if (heredoc_concat_len > 0)"
    },
    {
        "line": 165,
        "fullcodeline": "char_u *nextcmd = NULL;"
    },
    {
        "line": 217,
        "fullcodeline": "else if (STRNCMP(p, \"if\", 2) == 0"
    },
    {
        "line": 231,
        "fullcodeline": "p = skipwhite(p + 1);"
    },
    {
        "line": 260,
        "fullcodeline": "--end;"
    },
    {
        "line": 263,
        "fullcodeline": "is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';"
    },
    {
        "line": 293,
        "fullcodeline": "|| (p[0] == 'c'"
    },
    {
        "line": 299,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'"
    },
    {
        "line": 319,
        "fullcodeline": "|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'"
    },
    {
        "line": 322,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || p[2] == 's'))"
    },
    {
        "line": 330,
        "fullcodeline": "p = skipwhite(p + 4);"
    },
    {
        "line": 331,
        "fullcodeline": "heredoc_trimmed = vim_strnsave(theline,"
    },
    {
        "line": 335,
        "fullcodeline": "skip_until = vim_strsave((char_u *)\".\");"
    },
    {
        "line": 341,
        "fullcodeline": "heredoc_concat_len = newlines->ga_len + 1;"
    },
    {
        "line": 354,
        "fullcodeline": "&& arg[1] == '<' && arg[2] =='<');"
    },
    {
        "line": 358,
        "fullcodeline": "arg = skipwhite(skiptowhite(arg));"
    },
    {
        "line": 365,
        "fullcodeline": "p = skipwhite(arg + 3);"
    },
    {
        "line": 373,
        "fullcodeline": "skip_until = vim_strnsave(p, skiptowhite(p) - p);"
    },
    {
        "line": 374,
        "fullcodeline": "getline_options = GETLINE_NONE;"
    },
    {
        "line": 375,
        "fullcodeline": "is_heredoc = TRUE;"
    },
    {
        "line": 134,
        "fullcodeline": "ga_concat(&heredoc_ga, theline);"
    },
    {
        "line": 137,
        "fullcodeline": "((char_u **)(newlines->ga_data))["
    },
    {
        "line": 139,
        "fullcodeline": "ga_init(&heredoc_ga);"
    },
    {
        "line": 140,
        "fullcodeline": "heredoc_concat_len = 0;"
    },
    {
        "line": 141,
        "fullcodeline": "theline += STRLEN(theline);  // skip the \"EOF\""
    },
    {
        "line": 167,
        "fullcodeline": "if (*p == '|' || *p == '}')"
    },
    {
        "line": 183,
        "fullcodeline": "if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)"
    },
    {
        "line": 220,
        "fullcodeline": "|| STRNCMP(p, \"try\", 3) == 0)"
    },
    {
        "line": 221,
        "fullcodeline": "indent += 2;"
    },
    {
        "line": 237,
        "fullcodeline": "if (nesting == MAX_FUNC_NESTING - 1)"
    },
    {
        "line": 261,
        "fullcodeline": "while (end > p && VIM_ISWHITE(*end))"
    },
    {
        "line": 262,
        "fullcodeline": "--end;"
    },
    {
        "line": 264,
        "fullcodeline": "if (!is_block)"
    },
    {
        "line": 294,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'"
    },
    {
        "line": 317,
        "fullcodeline": "|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'"
    },
    {
        "line": 320,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))"
    },
    {
        "line": 337,
        "fullcodeline": "skip_until = vim_strnsave(p, skiptowhite(p) - p);"
    },
    {
        "line": 360,
        "fullcodeline": "&& (checkforcmd(&p, \"let\", 2)"
    },
    {
        "line": 366,
        "fullcodeline": "if (STRNCMP(p, \"trim\", 4) == 0)"
    },
    {
        "line": 90,
        "fullcodeline": "else if (eap->cmdidx == CMD_def)"
    },
    {
        "line": 118,
        "fullcodeline": "p = skipwhite(theline) == theline"
    },
    {
        "line": 168,
        "fullcodeline": "nextcmd = p + 1;"
    },
    {
        "line": 188,
        "fullcodeline": "eap->nextcmd = nextcmd;"
    },
    {
        "line": 207,
        "fullcodeline": "if (checkforcmd(&p, \"endfunction\", 4) && *p != ':')"
    },
    {
        "line": 219,
        "fullcodeline": "|| STRNCMP(p, \"for\", 3) == 0"
    },
    {
        "line": 238,
        "fullcodeline": "emsg(_(e_function_nesting_too_deep));"
    },
    {
        "line": 266,
        "fullcodeline": "char_u *s = p;"
    },
    {
        "line": 270,
        "fullcodeline": "is_block = checkforcmd_noparen(&s, \"autocmd\", 2)"
    },
    {
        "line": 300,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2])"
    },
    {
        "line": 315,
        "fullcodeline": "|| (p[0] == 't' && p[1] == 'c'"
    },
    {
        "line": 318,
        "fullcodeline": "&& !ASCII_ISALPHA(p[3]))"
    },
    {
        "line": 332,
        "fullcodeline": "skipwhite(theline) - theline);"
    },
    {
        "line": 363,
        "fullcodeline": "|| checkforcmd(&p, \"const\", 5))))"
    },
    {
        "line": 369,
        "fullcodeline": "p = skipwhite(p + 4);"
    },
    {
        "line": 370,
        "fullcodeline": "heredoc_trimmed = vim_strnsave(theline,"
    },
    {
        "line": 91,
        "fullcodeline": "emsg(_(e_missing_enddef));"
    },
    {
        "line": 121,
        "fullcodeline": "p = theline + STRLEN(heredoc_trimmed);"
    },
    {
        "line": 135,
        "fullcodeline": "vim_free(((char_u **)(newlines->ga_data))["
    },
    {
        "line": 136,
        "fullcodeline": "heredoc_concat_len - 1]);"
    },
    {
        "line": 138,
        "fullcodeline": "heredoc_concat_len - 1] = heredoc_ga.ga_data;"
    },
    {
        "line": 189,
        "fullcodeline": "if (*line_to_free != NULL)"
    },
    {
        "line": 208,
        "fullcodeline": "emsg(_(e_mismatched_endfunction));"
    },
    {
        "line": 210,
        "fullcodeline": "else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))"
    },
    {
        "line": 218,
        "fullcodeline": "|| STRNCMP(p, \"wh\", 2) == 0"
    },
    {
        "line": 241,
        "fullcodeline": "++nesting;"
    },
    {
        "line": 242,
        "fullcodeline": "nesting_def[nesting] = (c == 'd');"
    },
    {
        "line": 243,
        "fullcodeline": "nesting_inline[nesting] = FALSE;"
    },
    {
        "line": 244,
        "fullcodeline": "indent += 2;"
    },
    {
        "line": 276,
        "fullcodeline": "if (nesting == MAX_FUNC_NESTING - 1)"
    },
    {
        "line": 295,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'"
    },
    {
        "line": 301,
        "fullcodeline": "|| (p[2] == 's'"
    },
    {
        "line": 313,
        "fullcodeline": "|| (p[0] == 'p' && p[1] == 'e'"
    },
    {
        "line": 316,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))"
    },
    {
        "line": 362,
        "fullcodeline": "|| checkforcmd(&p, \"final\", 5)"
    },
    {
        "line": 93,
        "fullcodeline": "emsg(_(\"E126: Missing :endfunction\"));"
    },
    {
        "line": 119,
        "fullcodeline": "? theline : theline + STRLEN(heredoc_trimmed);"
    },
    {
        "line": 169,
        "fullcodeline": "else if (line_arg != NULL && *skipwhite(line_arg) != NUL)"
    },
    {
        "line": 192,
        "fullcodeline": "*eap->cmdlinep = *line_to_free;"
    },
    {
        "line": 193,
        "fullcodeline": "*line_to_free = NULL;"
    },
    {
        "line": 211,
        "fullcodeline": "emsg(_(e_mismatched_enddef));"
    },
    {
        "line": 271,
        "fullcodeline": "|| checkforcmd_noparen(&s, \"command\", 3);"
    },
    {
        "line": 277,
        "fullcodeline": "emsg(_(e_function_nesting_too_deep));"
    },
    {
        "line": 302,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[3])"
    },
    {
        "line": 310,
        "fullcodeline": "&& (!ASCII_ISALNUM(p[2]) || p[2] == 't'"
    },
    {
        "line": 314,
        "fullcodeline": "&& (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))"
    },
    {
        "line": 361,
        "fullcodeline": "|| checkforcmd(&p, \"var\", 3)"
    },
    {
        "line": 371,
        "fullcodeline": "skipwhite(theline) - theline);"
    },
    {
        "line": 170,
        "fullcodeline": "nextcmd = line_arg;"
    },
    {
        "line": 280,
        "fullcodeline": "++nesting;"
    },
    {
        "line": 281,
        "fullcodeline": "nesting_def[nesting] = TRUE;"
    },
    {
        "line": 282,
        "fullcodeline": "nesting_inline[nesting] = TRUE;"
    },
    {
        "line": 283,
        "fullcodeline": "indent += 2;"
    },
    {
        "line": 296,
        "fullcodeline": "&& (STRNCMP(&p[3], \"nge\", 3) != 0"
    },
    {
        "line": 303,
        "fullcodeline": "|| p[3] == 'e'))))))))"
    },
    {
        "line": 311,
        "fullcodeline": "|| ((p[2] == '3' || p[2] == 'x')"
    },
    {
        "line": 297,
        "fullcodeline": "|| !ASCII_ISALPHA(p[6])))))))"
    },
    {
        "line": 312,
        "fullcodeline": "&& !ASCII_ISALPHA(p[3]))))"
    },
    {
        "line": 171,
        "fullcodeline": "else if (*p != NUL && *p != (vim9_function ? '#' : '\"')"
    },
    {
        "line": 172,
        "fullcodeline": "&& (vim9_function || p_verbose > 0))"
    },
    {
        "line": 174,
        "fullcodeline": "SOURCING_LNUM = sourcing_lnum_top"
    },
    {
        "line": 176,
        "fullcodeline": "if (eap->cmdidx == CMD_def)"
    },
    {
        "line": 177,
        "fullcodeline": "semsg(_(e_text_found_after_enddef_str), p);"
    },
    {
        "line": 179,
        "fullcodeline": "give_warning2((char_u *)"
    },
    {
        "line": 180,
        "fullcodeline": "_(\"W22: Text found after :endfunction: %s\"),"
    }
]