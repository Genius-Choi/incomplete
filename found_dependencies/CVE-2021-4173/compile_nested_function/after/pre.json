[
    {
        "line": 3,
        "fullcodeline": "int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';"
    },
    {
        "line": 4,
        "fullcodeline": "char_u\t*name_start = eap->arg;"
    },
    {
        "line": 5,
        "fullcodeline": "char_u\t*name_end = to_name_end(eap->arg, TRUE);"
    },
    {
        "line": 10,
        "fullcodeline": "int\t\tr = FAIL;"
    },
    {
        "line": 49,
        "fullcodeline": "eap->arg = name_end;"
    },
    {
        "line": 50,
        "fullcodeline": "fill_exarg_from_cctx(eap, cctx);"
    },
    {
        "line": 52,
        "fullcodeline": "eap->forceit = FALSE;"
    },
    {
        "line": 54,
        "fullcodeline": "lambda_name = vim_strsave(get_lambda_name());"
    },
    {
        "line": 59,
        "fullcodeline": "off = is_global ? 2 : 0;"
    },
    {
        "line": 60,
        "fullcodeline": "func_name = vim_strnsave(name_start + off, name_end - name_start - off);"
    },
    {
        "line": 67,
        "fullcodeline": "ufunc = define_function(eap, lambda_name, line_to_free);"
    },
    {
        "line": 89,
        "fullcodeline": "compile_type = COMPILE_TYPE(ufunc);"
    },
    {
        "line": 19,
        "fullcodeline": "if (*name_start == '/')"
    },
    {
        "line": 46,
        "fullcodeline": "if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)"
    },
    {
        "line": 55,
        "fullcodeline": "if (lambda_name == NULL)"
    },
    {
        "line": 61,
        "fullcodeline": "if (func_name == NULL)"
    },
    {
        "line": 69,
        "fullcodeline": "if (ufunc == NULL)"
    },
    {
        "line": 132,
        "fullcodeline": "return r == FAIL ? NULL : (char_u *)\"\";"
    },
    {
        "line": 15,
        "fullcodeline": "emsg(_(e_cannot_use_bang_with_nested_def));"
    },
    {
        "line": 21,
        "fullcodeline": "name_end = skip_regexp(name_start + 1, '/', TRUE);"
    },
    {
        "line": 24,
        "fullcodeline": "set_nextcmd(eap, name_end);"
    },
    {
        "line": 26,
        "fullcodeline": "if (name_end == name_start || *skipwhite(name_end) != '(')"
    },
    {
        "line": 41,
        "fullcodeline": "if (name_start[1] == ':' && !is_global)"
    },
    {
        "line": 63,
        "fullcodeline": "r = FAIL;"
    },
    {
        "line": 71,
        "fullcodeline": "r = eap->skip ? OK : FAIL;"
    },
    {
        "line": 76,
        "fullcodeline": "if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)"
    },
    {
        "line": 78,
        "fullcodeline": "int block_depth = cctx->ctx_ufunc->uf_block_depth;"
    },
    {
        "line": 96,
        "fullcodeline": "if (func_needs_compiling(ufunc, compile_type)"
    },
    {
        "line": 97,
        "fullcodeline": "&& compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)"
    },
    {
        "line": 112,
        "fullcodeline": "r = generate_NEWFUNC(cctx, lambda_name, func_name);"
    },
    {
        "line": 113,
        "fullcodeline": "func_name = NULL;"
    },
    {
        "line": 114,
        "fullcodeline": "lambda_name = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "if (*name_end == '/')"
    },
    {
        "line": 37,
        "fullcodeline": "return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;"
    },
    {
        "line": 43,
        "fullcodeline": "semsg(_(e_namespace_not_supported_str), name_start);"
    },
    {
        "line": 81,
        "fullcodeline": "if (ufunc->uf_block_ids != NULL)"
    },
    {
        "line": 119,
        "fullcodeline": "lvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,"
    },
    {
        "line": 126,
        "fullcodeline": "r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);"
    },
    {
        "line": 23,
        "fullcodeline": "++name_end;"
    },
    {
        "line": 28,
        "fullcodeline": "if (!ends_excmd2(name_start, name_end))"
    },
    {
        "line": 35,
        "fullcodeline": "if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)"
    },
    {
        "line": 83,
        "fullcodeline": "mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,"
    },
    {
        "line": 85,
        "fullcodeline": "ufunc->uf_block_depth = block_depth;"
    },
    {
        "line": 122,
        "fullcodeline": "if (lvar == NULL)"
    },
    {
        "line": 124,
        "fullcodeline": "if (generate_FUNCREF(cctx, ufunc) == FAIL)"
    },
    {
        "line": 30,
        "fullcodeline": "semsg(_(e_invalid_command_str), eap->cmd);"
    },
    {
        "line": 84,
        "fullcodeline": "sizeof(int) * block_depth);"
    }
]