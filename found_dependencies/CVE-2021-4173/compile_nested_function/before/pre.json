[
    {
        "line": 3,
        "fullcodeline": "int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';"
    },
    {
        "line": 4,
        "fullcodeline": "char_u\t*name_start = eap->arg;"
    },
    {
        "line": 5,
        "fullcodeline": "char_u\t*name_end = to_name_end(eap->arg, TRUE);"
    },
    {
        "line": 8,
        "fullcodeline": "int\t\tr = FAIL;"
    },
    {
        "line": 47,
        "fullcodeline": "eap->arg = name_end;"
    },
    {
        "line": 48,
        "fullcodeline": "fill_exarg_from_cctx(eap, cctx);"
    },
    {
        "line": 50,
        "fullcodeline": "eap->forceit = FALSE;"
    },
    {
        "line": 52,
        "fullcodeline": "lambda_name = vim_strsave(get_lambda_name());"
    },
    {
        "line": 55,
        "fullcodeline": "ufunc = define_function(eap, lambda_name);"
    },
    {
        "line": 77,
        "fullcodeline": "compile_type = COMPILE_TYPE(ufunc);"
    },
    {
        "line": 17,
        "fullcodeline": "if (*name_start == '/')"
    },
    {
        "line": 44,
        "fullcodeline": "if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)"
    },
    {
        "line": 53,
        "fullcodeline": "if (lambda_name == NULL)"
    },
    {
        "line": 57,
        "fullcodeline": "if (ufunc == NULL)"
    },
    {
        "line": 126,
        "fullcodeline": "return r == FAIL ? NULL : (char_u *)\"\";"
    },
    {
        "line": 13,
        "fullcodeline": "emsg(_(e_cannot_use_bang_with_nested_def));"
    },
    {
        "line": 19,
        "fullcodeline": "name_end = skip_regexp(name_start + 1, '/', TRUE);"
    },
    {
        "line": 22,
        "fullcodeline": "set_nextcmd(eap, name_end);"
    },
    {
        "line": 24,
        "fullcodeline": "if (name_end == name_start || *skipwhite(name_end) != '(')"
    },
    {
        "line": 39,
        "fullcodeline": "if (name_start[1] == ':' && !is_global)"
    },
    {
        "line": 59,
        "fullcodeline": "r = eap->skip ? OK : FAIL;"
    },
    {
        "line": 64,
        "fullcodeline": "if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)"
    },
    {
        "line": 66,
        "fullcodeline": "int block_depth = cctx->ctx_ufunc->uf_block_depth;"
    },
    {
        "line": 84,
        "fullcodeline": "if (func_needs_compiling(ufunc, compile_type)"
    },
    {
        "line": 85,
        "fullcodeline": "&& compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)"
    },
    {
        "line": 100,
        "fullcodeline": "char_u *func_name = vim_strnsave(name_start + 2,"
    },
    {
        "line": 20,
        "fullcodeline": "if (*name_end == '/')"
    },
    {
        "line": 35,
        "fullcodeline": "return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;"
    },
    {
        "line": 41,
        "fullcodeline": "semsg(_(e_namespace_not_supported_str), name_start);"
    },
    {
        "line": 69,
        "fullcodeline": "if (ufunc->uf_block_ids != NULL)"
    },
    {
        "line": 103,
        "fullcodeline": "if (func_name == NULL)"
    },
    {
        "line": 114,
        "fullcodeline": "lvar_T\t*lvar = reserve_local(cctx, name_start, name_end - name_start,"
    },
    {
        "line": 121,
        "fullcodeline": "r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);"
    },
    {
        "line": 21,
        "fullcodeline": "++name_end;"
    },
    {
        "line": 26,
        "fullcodeline": "if (!ends_excmd2(name_start, name_end))"
    },
    {
        "line": 33,
        "fullcodeline": "if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)"
    },
    {
        "line": 71,
        "fullcodeline": "mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,"
    },
    {
        "line": 73,
        "fullcodeline": "ufunc->uf_block_depth = block_depth;"
    },
    {
        "line": 101,
        "fullcodeline": "name_end - name_start - 2);"
    },
    {
        "line": 104,
        "fullcodeline": "r = FAIL;"
    },
    {
        "line": 117,
        "fullcodeline": "if (lvar == NULL)"
    },
    {
        "line": 119,
        "fullcodeline": "if (generate_FUNCREF(cctx, ufunc) == FAIL)"
    },
    {
        "line": 28,
        "fullcodeline": "semsg(_(e_invalid_command_str), eap->cmd);"
    },
    {
        "line": 72,
        "fullcodeline": "sizeof(int) * block_depth);"
    },
    {
        "line": 107,
        "fullcodeline": "r = generate_NEWFUNC(cctx, lambda_name, func_name);"
    },
    {
        "line": 108,
        "fullcodeline": "lambda_name = NULL;"
    }
]