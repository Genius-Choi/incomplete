[
    {
        "line": 7,
        "fullcodeline": "Attr *attr = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "File *file = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int rtf_size = 0, html_size = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "memset (&body, '\\0', sizeof (MessageBody));"
    },
    {
        "line": 14,
        "fullcodeline": "g_flags = flags;"
    },
    {
        "line": 17,
        "fullcodeline": "d = geti32(input_file);"
    },
    {
        "line": 25,
        "fullcodeline": "key = geti16(input_file);"
    },
    {
        "line": 26,
        "fullcodeline": "debug_print (\"TNEF Key: %hx\\n\", key);"
    },
    {
        "line": 18,
        "fullcodeline": "if (d != TNEF_SIGNATURE)"
    },
    {
        "line": 29,
        "fullcodeline": "while ( data_left( input_file ) )"
    },
    {
        "line": 108,
        "fullcodeline": "if (flags & SAVEBODY)"
    },
    {
        "line": 142,
        "fullcodeline": "if (rtf_size > 0)"
    },
    {
        "line": 147,
        "fullcodeline": "if (html_size > 0)"
    },
    {
        "line": 20,
        "fullcodeline": "fprintf (stdout, \"Seems not to be a TNEF file\\n\");"
    },
    {
        "line": 31,
        "fullcodeline": "attr = read_object( input_file );"
    },
    {
        "line": 96,
        "fullcodeline": "attr_free (attr);"
    },
    {
        "line": 97,
        "fullcodeline": "XFREE (attr);"
    },
    {
        "line": 102,
        "fullcodeline": "file_write (file, directory);"
    },
    {
        "line": 103,
        "fullcodeline": "file_free (file);"
    },
    {
        "line": 104,
        "fullcodeline": "XFREE (file);"
    },
    {
        "line": 110,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "int all_flag = 0;"
    },
    {
        "line": 139,
        "fullcodeline": "free_bodies(body.text_body, 1);"
    },
    {
        "line": 140,
        "fullcodeline": "XFREE(body.text_body);"
    },
    {
        "line": 144,
        "fullcodeline": "free_bodies(body.rtf_bodies, rtf_size);"
    },
    {
        "line": 145,
        "fullcodeline": "XFREE(body.rtf_bodies);"
    },
    {
        "line": 149,
        "fullcodeline": "free_bodies(body.html_bodies, html_size);"
    },
    {
        "line": 150,
        "fullcodeline": "XFREE(body.html_bodies);"
    },
    {
        "line": 33,
        "fullcodeline": "if ( attr == NULL ) break;"
    },
    {
        "line": 36,
        "fullcodeline": "if (attr->name == attATTACHRENDDATA)"
    },
    {
        "line": 112,
        "fullcodeline": "if (strcmp (body_pref, \"all\") == 0)"
    },
    {
        "line": 118,
        "fullcodeline": "for (; i < 3; i++)"
    },
    {
        "line": 88,
        "fullcodeline": "file_add_attr (file, attr);"
    },
    {
        "line": 91,
        "fullcodeline": "fprintf (stderr, \"Invalid lvl type on attribute: %d\\n\","
    },
    {
        "line": 114,
        "fullcodeline": "all_flag = 1;"
    },
    {
        "line": 115,
        "fullcodeline": "body_pref = \"rht\";"
    },
    {
        "line": 120,
        "fullcodeline": "File **files"
    },
    {
        "line": 53,
        "fullcodeline": "if (attr->name == attBODY)"
    },
    {
        "line": 121,
        "fullcodeline": "= get_body_files (body_filename, body_pref[i], &body);"
    },
    {
        "line": 40,
        "fullcodeline": "file_write (file, directory);"
    },
    {
        "line": 41,
        "fullcodeline": "file_free (file);"
    },
    {
        "line": 55,
        "fullcodeline": "body.text_body = get_text_data (attr);"
    },
    {
        "line": 124,
        "fullcodeline": "int j = 0;"
    },
    {
        "line": 131,
        "fullcodeline": "XFREE(files);"
    },
    {
        "line": 45,
        "fullcodeline": "file = CHECKED_XCALLOC (File, 1);"
    },
    {
        "line": 125,
        "fullcodeline": "for (; files[j]; j++)"
    },
    {
        "line": 132,
        "fullcodeline": "if (!all_flag) break;"
    },
    {
        "line": 57,
        "fullcodeline": "else if (attr->name == attMAPIPROPS)"
    },
    {
        "line": 127,
        "fullcodeline": "file_write(files[j], directory);"
    },
    {
        "line": 128,
        "fullcodeline": "file_free (files[j]);"
    },
    {
        "line": 129,
        "fullcodeline": "XFREE(files[j]);"
    },
    {
        "line": 59,
        "fullcodeline": "MAPI_Attr **mapi_attrs"
    },
    {
        "line": 60,
        "fullcodeline": "= mapi_attr_read (attr->len, attr->buf);"
    },
    {
        "line": 82,
        "fullcodeline": "mapi_attr_free_list (mapi_attrs);"
    },
    {
        "line": 83,
        "fullcodeline": "XFREE (mapi_attrs);"
    },
    {
        "line": 64,
        "fullcodeline": "for (i = 0; mapi_attrs[i]; i++)"
    },
    {
        "line": 66,
        "fullcodeline": "MAPI_Attr *a = mapi_attrs[i];"
    },
    {
        "line": 68,
        "fullcodeline": "if (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)"
    },
    {
        "line": 70,
        "fullcodeline": "body.html_bodies = get_html_data (a);"
    },
    {
        "line": 71,
        "fullcodeline": "html_size = a->num_values;"
    },
    {
        "line": 73,
        "fullcodeline": "else if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)"
    },
    {
        "line": 75,
        "fullcodeline": "body.rtf_bodies = get_rtf_data (a);"
    },
    {
        "line": 76,
        "fullcodeline": "rtf_size = a->num_values;"
    }
]