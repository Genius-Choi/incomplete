[
    {
        "line": 3,
        "fullcodeline": "const struct cred *cred = current_cred(), *tcred;"
    },
    {
        "line": 13,
        "fullcodeline": "int dumpable = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "rcu_read_lock();"
    },
    {
        "line": 18,
        "fullcodeline": "tcred = __task_cred(task);"
    },
    {
        "line": 28,
        "fullcodeline": "rcu_read_unlock();"
    },
    {
        "line": 31,
        "fullcodeline": "rcu_read_unlock();"
    },
    {
        "line": 32,
        "fullcodeline": "smp_rmb();"
    },
    {
        "line": 35,
        "fullcodeline": "rcu_read_lock();"
    },
    {
        "line": 40,
        "fullcodeline": "rcu_read_unlock();"
    },
    {
        "line": 15,
        "fullcodeline": "if (task == current)"
    },
    {
        "line": 19,
        "fullcodeline": "if (uid_eq(cred->uid, tcred->euid) &&"
    },
    {
        "line": 26,
        "fullcodeline": "if (ptrace_has_cap(tcred->user_ns, mode))"
    },
    {
        "line": 29,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 36,
        "fullcodeline": "if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {"
    },
    {
        "line": 42,
        "fullcodeline": "return security_ptrace_access_check(task, mode);"
    },
    {
        "line": 24,
        "fullcodeline": "gid_eq(cred->gid, tcred->gid))"
    },
    {
        "line": 34,
        "fullcodeline": "dumpable = get_dumpable(task->mm);"
    },
    {
        "line": 37,
        "fullcodeline": "rcu_read_unlock();"
    },
    {
        "line": 23,
        "fullcodeline": "gid_eq(cred->gid, tcred->sgid) &&"
    },
    {
        "line": 38,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 22,
        "fullcodeline": "gid_eq(cred->gid, tcred->egid) &&"
    },
    {
        "line": 21,
        "fullcodeline": "uid_eq(cred->uid, tcred->uid)  &&"
    },
    {
        "line": 20,
        "fullcodeline": "uid_eq(cred->uid, tcred->suid) &&"
    }
]