[
    {
        "line": 24,
        "fullcodeline": "sk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);"
    },
    {
        "line": 28,
        "fullcodeline": "self = irda_sk(sk);"
    },
    {
        "line": 29,
        "fullcodeline": "pr_debug(\"%s() : self is %p\\n\", __func__, self);"
    },
    {
        "line": 77,
        "fullcodeline": "self->nslots = DISCOVERY_DEFAULT_SLOTS;"
    },
    {
        "line": 78,
        "fullcodeline": "self->daddr = DEV_ADDR_ANY;\t/* Until we get connected */"
    },
    {
        "line": 7,
        "fullcodeline": "if (protocol < 0 || protocol > SK_PROTOCOL_MAX)"
    },
    {
        "line": 10,
        "fullcodeline": "if (net != &init_net)"
    },
    {
        "line": 25,
        "fullcodeline": "if (sk == NULL)"
    },
    {
        "line": 74,
        "fullcodeline": "self->ckey = irlmp_register_client(0, NULL, NULL, NULL);"
    },
    {
        "line": 76,
        "fullcodeline": "self->rx_flow = self->tx_flow = FLOW_START;"
    },
    {
        "line": 35,
        "fullcodeline": "sock->ops = &irda_stream_ops;"
    },
    {
        "line": 36,
        "fullcodeline": "self->max_sdu_size_rx = TTP_SAR_DISABLE;"
    },
    {
        "line": 39,
        "fullcodeline": "sock->ops = &irda_seqpacket_ops;"
    },
    {
        "line": 8,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 11,
        "fullcodeline": "return -EAFNOSUPPORT;"
    },
    {
        "line": 20,
        "fullcodeline": "return -ESOCKTNOSUPPORT;"
    },
    {
        "line": 26,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 65,
        "fullcodeline": "return -ESOCKTNOSUPPORT;"
    },
    {
        "line": 54,
        "fullcodeline": "sock->ops = &irda_dgram_ops;"
    },
    {
        "line": 60,
        "fullcodeline": "return -ESOCKTNOSUPPORT;"
    }
]