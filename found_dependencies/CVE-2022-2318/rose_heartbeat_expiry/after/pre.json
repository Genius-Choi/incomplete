[
    {
        "line": 3,
        "fullcodeline": "struct sock *sk = from_timer(sk, t, sk_timer);"
    },
    {
        "line": 4,
        "fullcodeline": "struct rose_sock *rose = rose_sk(sk);"
    },
    {
        "line": 6,
        "fullcodeline": "bh_lock_sock(sk);"
    },
    {
        "line": 36,
        "fullcodeline": "rose_start_heartbeat(sk);"
    },
    {
        "line": 37,
        "fullcodeline": "bh_unlock_sock(sk);"
    },
    {
        "line": 11,
        "fullcodeline": "if (sock_flag(sk, SOCK_DESTROY) ||"
    },
    {
        "line": 12,
        "fullcodeline": "(sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {"
    },
    {
        "line": 13,
        "fullcodeline": "bh_unlock_sock(sk);"
    },
    {
        "line": 14,
        "fullcodeline": "rose_destroy_socket(sk);"
    },
    {
        "line": 15,
        "fullcodeline": "sock_put(sk);"
    },
    {
        "line": 24,
        "fullcodeline": "if (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&"
    },
    {
        "line": 25,
        "fullcodeline": "(rose->condition & ROSE_COND_OWN_RX_BUSY)) {"
    },
    {
        "line": 26,
        "fullcodeline": "rose->condition &= ~ROSE_COND_OWN_RX_BUSY;"
    },
    {
        "line": 29,
        "fullcodeline": "rose_write_internal(sk, ROSE_RR);"
    },
    {
        "line": 30,
        "fullcodeline": "rose_stop_timer(sk);\t/* HB */"
    },
    {
        "line": 27,
        "fullcodeline": "rose->condition &= ~ROSE_COND_ACK_PENDING;"
    }
]