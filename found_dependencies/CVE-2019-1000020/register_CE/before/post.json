[
    {
        "line": 11,
        "fullcodeline": "offset = ((uint64_t)location) * (uint64_t)iso9660->logical_block_size;"
    },
    {
        "line": 25,
        "fullcodeline": "heap = &(iso9660->read_ce_req);"
    },
    {
        "line": 54,
        "fullcodeline": "hole = heap->cnt++;"
    },
    {
        "line": 67,
        "fullcodeline": "heap->reqs[0].offset = offset;"
    },
    {
        "line": 68,
        "fullcodeline": "heap->reqs[0].file = file;"
    },
    {
        "line": 12,
        "fullcodeline": "if (((file->mode & AE_IFMT) == AE_IFREG &&"
    },
    {
        "line": 26,
        "fullcodeline": "if (heap->cnt >= heap->allocated) {"
    },
    {
        "line": 55,
        "fullcodeline": "while (hole > 0) {"
    },
    {
        "line": 17,
        "fullcodeline": "offset + file->ce_offset + file->ce_size"
    },
    {
        "line": 19,
        "fullcodeline": "archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,"
    },
    {
        "line": 38,
        "fullcodeline": "p = calloc(new_size, sizeof(p[0]));"
    },
    {
        "line": 47,
        "fullcodeline": "heap->reqs = p;"
    },
    {
        "line": 48,
        "fullcodeline": "heap->allocated = new_size;"
    },
    {
        "line": 56,
        "fullcodeline": "parent = (hole - 1)/2;"
    },
    {
        "line": 65,
        "fullcodeline": "hole = parent;"
    },
    {
        "line": 15,
        "fullcodeline": "(((uint64_t)file->ce_offset) + file->ce_size)"
    },
    {
        "line": 29,
        "fullcodeline": "if (heap->allocated < 16)"
    },
    {
        "line": 34,
        "fullcodeline": "if (new_size <= heap->allocated) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (p == NULL) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (heap->reqs != NULL) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (offset >= parent_offset) {"
    },
    {
        "line": 14,
        "fullcodeline": "offset < iso9660->current_position ||"
    },
    {
        "line": 16,
        "fullcodeline": "> (uint64_t)iso9660->logical_block_size ||"
    },
    {
        "line": 30,
        "fullcodeline": "new_size = 16;"
    },
    {
        "line": 35,
        "fullcodeline": "archive_set_error(&a->archive, ENOMEM, \"Out of memory\");"
    },
    {
        "line": 40,
        "fullcodeline": "archive_set_error(&a->archive, ENOMEM, \"Out of memory\");"
    },
    {
        "line": 44,
        "fullcodeline": "memcpy(p, heap->reqs, heap->cnt * sizeof(*p));"
    },
    {
        "line": 45,
        "fullcodeline": "free(heap->reqs);"
    },
    {
        "line": 59,
        "fullcodeline": "heap->reqs[hole].offset = offset;"
    },
    {
        "line": 60,
        "fullcodeline": "heap->reqs[hole].file = file;"
    },
    {
        "line": 13,
        "fullcodeline": "offset >= file->offset) ||"
    },
    {
        "line": 32,
        "fullcodeline": "new_size = heap->allocated * 2;"
    }
]