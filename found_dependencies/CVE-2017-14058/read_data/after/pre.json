[
    {
        "line": 3,
        "fullcodeline": "struct playlist *v = opaque;"
    },
    {
        "line": 4,
        "fullcodeline": "HLSContext *c = v->parent->priv_data;"
    },
    {
        "line": 6,
        "fullcodeline": "int just_opened = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "int reload_count = 0;"
    },
    {
        "line": 99,
        "fullcodeline": "ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);"
    },
    {
        "line": 109,
        "fullcodeline": "ff_format_io_close(v->parent, &v->input);"
    },
    {
        "line": 110,
        "fullcodeline": "v->cur_seq_no++;"
    },
    {
        "line": 112,
        "fullcodeline": "c->cur_seq_no = v->cur_seq_no;"
    },
    {
        "line": 10,
        "fullcodeline": "if (!v->needed)"
    },
    {
        "line": 13,
        "fullcodeline": "if (!v->input) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (v->init_sec_buf_read_offset < v->init_sec_data_len) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (ret > 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "reload_interval = default_reload_interval(v);"
    },
    {
        "line": 39,
        "fullcodeline": "reload_count++;"
    },
    {
        "line": 72,
        "fullcodeline": "seg = current_segment(v);"
    },
    {
        "line": 75,
        "fullcodeline": "ret = update_init_section(v, seg);"
    },
    {
        "line": 79,
        "fullcodeline": "ret = open_input(c, v, seg);"
    },
    {
        "line": 88,
        "fullcodeline": "just_opened = 1;"
    },
    {
        "line": 93,
        "fullcodeline": "int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);"
    },
    {
        "line": 94,
        "fullcodeline": "memcpy(buf, v->init_sec_buf, copy_size);"
    },
    {
        "line": 19,
        "fullcodeline": "if (v->ctx && v->ctx->nb_streams) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (!v->needed) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (reload_count > c->max_reload)"
    },
    {
        "line": 42,
        "fullcodeline": "if (!v->finished &&"
    },
    {
        "line": 54,
        "fullcodeline": "if (v->cur_seq_no < v->start_seq_no) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 20,
        "fullcodeline": "v->needed = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\","
    },
    {
        "line": 43,
        "fullcodeline": "av_gettime_relative() - v->last_load_time >= reload_interval) {"
    },
    {
        "line": 52,
        "fullcodeline": "reload_interval = v->target_duration / 2;"
    },
    {
        "line": 55,
        "fullcodeline": "av_log(NULL, AV_LOG_WARNING,"
    },
    {
        "line": 58,
        "fullcodeline": "v->cur_seq_no = v->start_seq_no;"
    },
    {
        "line": 83,
        "fullcodeline": "av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\","
    },
    {
        "line": 85,
        "fullcodeline": "v->cur_seq_no += 1;"
    },
    {
        "line": 101,
        "fullcodeline": "if (just_opened && v->is_id3_timestamped != 0) {"
    },
    {
        "line": 104,
        "fullcodeline": "intercept_id3(v, buf, buf_size, &ret);"
    },
    {
        "line": 21,
        "fullcodeline": "for (i = 0; i < v->n_main_streams; i++) {"
    },
    {
        "line": 44,
        "fullcodeline": "if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {"
    },
    {
        "line": 57,
        "fullcodeline": "v->start_seq_no - v->cur_seq_no);"
    },
    {
        "line": 63,
        "fullcodeline": "while (av_gettime_relative() - v->last_load_time < reload_interval) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (ff_check_interrupt(c->interrupt_callback))"
    },
    {
        "line": 66,
        "fullcodeline": "av_usleep(100*1000);"
    },
    {
        "line": 22,
        "fullcodeline": "if (v->main_streams[i]->discard < AVDISCARD_ALL) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (ff_check_interrupt(c->interrupt_callback))"
    },
    {
        "line": 23,
        "fullcodeline": "v->needed = 1;"
    }
]