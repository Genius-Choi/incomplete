[
    {
        "line": 4,
        "fullcodeline": "struct hstate *h = hstate_vma(vma);"
    },
    {
        "line": 14,
        "fullcodeline": "address = address & huge_page_mask(h);"
    },
    {
        "line": 15,
        "fullcodeline": "pgoff = vma_hugecache_offset(h, vma, address);"
    },
    {
        "line": 16,
        "fullcodeline": "mapping = (struct address_space *)page_private(page);"
    },
    {
        "line": 23,
        "fullcodeline": "mutex_lock(&mapping->i_mmap_mutex);"
    },
    {
        "line": 24,
        "fullcodeline": "vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {"
    },
    {
        "line": 41,
        "fullcodeline": "mutex_unlock(&mapping->i_mmap_mutex);"
    },
    {
        "line": 26,
        "fullcodeline": "if (iter_vma == vma)"
    },
    {
        "line": 36,
        "fullcodeline": "if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))"
    },
    {
        "line": 37,
        "fullcodeline": "__unmap_hugepage_range(iter_vma,"
    },
    {
        "line": 38,
        "fullcodeline": "address, address + huge_page_size(h),"
    }
]