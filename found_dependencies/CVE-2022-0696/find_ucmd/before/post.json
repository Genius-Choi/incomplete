[
    {
        "line": 8,
        "fullcodeline": "int\t\tlen = (int)(p - eap->cmd);"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tj, k, matchlen = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\tfound = FALSE;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tpossible = FALSE;"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,"
    },
    {
        "line": 106,
        "fullcodeline": "if (found || possible)"
    },
    {
        "line": 93,
        "fullcodeline": "gap = &ucmds;"
    },
    {
        "line": 28,
        "fullcodeline": "for (j = 0; j < gap->ga_len; ++j)"
    },
    {
        "line": 91,
        "fullcodeline": "if (j < gap->ga_len || gap == &ucmds)"
    },
    {
        "line": 99,
        "fullcodeline": "if (xp != NULL)"
    },
    {
        "line": 107,
        "fullcodeline": "return p + (matchlen - len);"
    },
    {
        "line": 30,
        "fullcodeline": "uc = USER_CMD_GA(gap, j);"
    },
    {
        "line": 31,
        "fullcodeline": "cp = eap->cmd;"
    },
    {
        "line": 32,
        "fullcodeline": "np = uc->uc_name;"
    },
    {
        "line": 33,
        "fullcodeline": "k = 0;"
    },
    {
        "line": 100,
        "fullcodeline": "xp->xp_context = EXPAND_UNSUCCESSFUL;"
    },
    {
        "line": 34,
        "fullcodeline": "while (k < len && *np != NUL && *cp++ == *np++)"
    },
    {
        "line": 35,
        "fullcodeline": "k++;"
    },
    {
        "line": 36,
        "fullcodeline": "if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))"
    },
    {
        "line": 41,
        "fullcodeline": "if (k == len && found && *np != NUL)"
    },
    {
        "line": 48,
        "fullcodeline": "if (!found || (k == len && *np == NUL))"
    },
    {
        "line": 45,
        "fullcodeline": "amb_local = TRUE;"
    },
    {
        "line": 62,
        "fullcodeline": "eap->argt = (long)uc->uc_argt;"
    },
    {
        "line": 63,
        "fullcodeline": "eap->useridx = j;"
    },
    {
        "line": 64,
        "fullcodeline": "eap->addr_type = uc->uc_addr_type;"
    },
    {
        "line": 78,
        "fullcodeline": "matchlen = k;"
    },
    {
        "line": 43,
        "fullcodeline": "if (gap == &ucmds)"
    },
    {
        "line": 53,
        "fullcodeline": "if (k == len)"
    },
    {
        "line": 58,
        "fullcodeline": "if (gap == &ucmds)"
    },
    {
        "line": 66,
        "fullcodeline": "if (complp != NULL)"
    },
    {
        "line": 79,
        "fullcodeline": "if (k == len && *np == NUL)"
    },
    {
        "line": 54,
        "fullcodeline": "found = TRUE;"
    },
    {
        "line": 59,
        "fullcodeline": "eap->cmdidx = CMD_USER;"
    },
    {
        "line": 67,
        "fullcodeline": "*complp = uc->uc_compl;"
    },
    {
        "line": 83,
        "fullcodeline": "amb_local = FALSE;"
    },
    {
        "line": 56,
        "fullcodeline": "possible = TRUE;"
    },
    {
        "line": 61,
        "fullcodeline": "eap->cmdidx = CMD_USER_BUF;"
    },
    {
        "line": 81,
        "fullcodeline": "if (full != NULL)"
    },
    {
        "line": 82,
        "fullcodeline": "*full = TRUE;"
    }
]