[
    {
        "line": 9,
        "fullcodeline": "const int output_size = max_output_size.scalar<int>()();"
    },
    {
        "line": 10,
        "fullcodeline": "OP_REQUIRES(context, output_size >= 0,"
    },
    {
        "line": 13,
        "fullcodeline": "std::vector<T> scores_data(num_boxes);"
    },
    {
        "line": 14,
        "fullcodeline": "std::copy_n(scores.flat<T>().data(), num_boxes, scores_data.begin());"
    },
    {
        "line": 23,
        "fullcodeline": "auto cmp = [](const Candidate bs_i, const Candidate bs_j) {"
    },
    {
        "line": 28,
        "fullcodeline": "candidate_priority_queue(cmp);"
    },
    {
        "line": 35,
        "fullcodeline": "T scale = static_cast<T>(0.0);"
    },
    {
        "line": 36,
        "fullcodeline": "bool is_soft_nms = soft_nms_sigma > static_cast<T>(0.0);"
    },
    {
        "line": 41,
        "fullcodeline": "auto suppress_weight = [similarity_threshold, scale,"
    },
    {
        "line": 49,
        "fullcodeline": "std::vector<T> selected_scores;"
    },
    {
        "line": 110,
        "fullcodeline": "int num_valid_outputs = selected.size();"
    },
    {
        "line": 120,
        "fullcodeline": "Tensor* output_indices = nullptr;"
    },
    {
        "line": 121,
        "fullcodeline": "TensorShape output_shape({static_cast<int>(selected.size())});"
    },
    {
        "line": 122,
        "fullcodeline": "OP_REQUIRES_OK(context,"
    },
    {
        "line": 124,
        "fullcodeline": "TTypes<int, 1>::Tensor output_indices_data = output_indices->tensor<int, 1>();"
    },
    {
        "line": 125,
        "fullcodeline": "std::copy_n(selected.begin(), selected.size(), output_indices_data.data());"
    },
    {
        "line": 11,
        "fullcodeline": "errors::InvalidArgument(\"output size must be non-negative\"));"
    },
    {
        "line": 29,
        "fullcodeline": "for (int i = 0; i < scores_data.size(); ++i) {"
    },
    {
        "line": 54,
        "fullcodeline": "while (selected.size() < output_size && !candidate_priority_queue.empty()) {"
    },
    {
        "line": 123,
        "fullcodeline": "context->allocate_output(0, output_shape, &output_indices));"
    },
    {
        "line": 38,
        "fullcodeline": "scale = static_cast<T>(-0.5) / soft_nms_sigma;"
    },
    {
        "line": 55,
        "fullcodeline": "next_candidate = candidate_priority_queue.top();"
    },
    {
        "line": 56,
        "fullcodeline": "original_score = next_candidate.score;"
    },
    {
        "line": 57,
        "fullcodeline": "candidate_priority_queue.pop();"
    },
    {
        "line": 67,
        "fullcodeline": "bool should_hard_suppress = false;"
    },
    {
        "line": 93,
        "fullcodeline": "next_candidate.suppress_begin_index = selected.size();"
    },
    {
        "line": 112,
        "fullcodeline": "selected.resize(output_size, 0);"
    },
    {
        "line": 113,
        "fullcodeline": "selected_scores.resize(output_size, static_cast<T>(0));"
    },
    {
        "line": 116,
        "fullcodeline": "*ptr_num_valid_outputs = num_valid_outputs;"
    },
    {
        "line": 128,
        "fullcodeline": "Tensor* output_scores = nullptr;"
    },
    {
        "line": 129,
        "fullcodeline": "OP_REQUIRES_OK(context,"
    },
    {
        "line": 131,
        "fullcodeline": "typename TTypes<T, 1>::Tensor output_scores_data ="
    },
    {
        "line": 133,
        "fullcodeline": "std::copy_n(selected_scores.begin(), selected_scores.size(),"
    },
    {
        "line": 30,
        "fullcodeline": "if (scores_data[i] > score_threshold) {"
    },
    {
        "line": 69,
        "fullcodeline": "j >= next_candidate.suppress_begin_index; --j) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (!should_hard_suppress) {"
    },
    {
        "line": 130,
        "fullcodeline": "context->allocate_output(1, output_shape, &output_scores));"
    },
    {
        "line": 132,
        "fullcodeline": "output_scores->tensor<T, 1>();"
    },
    {
        "line": 134,
        "fullcodeline": "output_scores_data.data());"
    },
    {
        "line": 31,
        "fullcodeline": "candidate_priority_queue.emplace(Candidate({i, scores_data[i], 0}));"
    },
    {
        "line": 68,
        "fullcodeline": "for (int j = static_cast<int>(selected.size()) - 1;"
    },
    {
        "line": 70,
        "fullcodeline": "similarity = similarity_fn(next_candidate.box_index, selected[j]);"
    },
    {
        "line": 72,
        "fullcodeline": "next_candidate.score *= suppress_weight(static_cast<T>(similarity));"
    },
    {
        "line": 75,
        "fullcodeline": "if (!is_soft_nms && static_cast<T>(similarity) > similarity_threshold) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (next_candidate.score <= score_threshold) break;"
    },
    {
        "line": 96,
        "fullcodeline": "if (next_candidate.score == original_score) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (next_candidate.score > score_threshold) {"
    },
    {
        "line": 76,
        "fullcodeline": "should_hard_suppress = true;"
    },
    {
        "line": 98,
        "fullcodeline": "selected.push_back(next_candidate.box_index);"
    },
    {
        "line": 99,
        "fullcodeline": "selected_scores.push_back(next_candidate.score);"
    },
    {
        "line": 105,
        "fullcodeline": "candidate_priority_queue.push(next_candidate);"
    }
]