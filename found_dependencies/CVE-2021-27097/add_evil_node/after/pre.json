[
    {
        "line": 23,
        "fullcodeline": "hdr = input_data[0:0x28]"
    },
    {
        "line": 25,
        "fullcodeline": "offset = 0"
    },
    {
        "line": 26,
        "fullcodeline": "magic = struct.unpack('>I', hdr[offset:offset + 4])[0]"
    },
    {
        "line": 30,
        "fullcodeline": "offset += 4"
    },
    {
        "line": 35,
        "fullcodeline": "rsv_map = input_data[off_mem_rsvmap:off_dt_struct]"
    },
    {
        "line": 36,
        "fullcodeline": "dt_struct = input_data[off_dt_struct:off_dt_struct + size_dt_struct]"
    },
    {
        "line": 37,
        "fullcodeline": "dt_strings = input_data[off_dt_strings:off_dt_strings + size_dt_strings]"
    },
    {
        "line": 43,
        "fullcodeline": "val = hashlib.sha1()"
    },
    {
        "line": 44,
        "fullcodeline": "val.update(kernel_content)"
    },
    {
        "line": 45,
        "fullcodeline": "hash_digest = val.digest()"
    },
    {
        "line": 55,
        "fullcodeline": "size_dt_strings = len(dt_strings)"
    },
    {
        "line": 56,
        "fullcodeline": "size_dt_struct = len(dt_struct)"
    },
    {
        "line": 57,
        "fullcodeline": "totalsize = 0x28 + len(rsv_map) + size_dt_struct + size_dt_strings"
    },
    {
        "line": 58,
        "fullcodeline": "off_mem_rsvmap = 0x28"
    },
    {
        "line": 59,
        "fullcodeline": "off_dt_struct = off_mem_rsvmap + len(rsv_map)"
    },
    {
        "line": 60,
        "fullcodeline": "off_dt_strings = off_dt_struct + len(dt_struct)"
    },
    {
        "line": 62,
        "fullcodeline": "header = struct.pack('>IIIIIIIIII', MAGIC, totalsize, off_dt_struct,"
    },
    {
        "line": 13,
        "fullcodeline": "if attack == 'fakeroot':"
    },
    {
        "line": 20,
        "fullcodeline": "with open(in_fname, 'rb') as fin:"
    },
    {
        "line": 27,
        "fullcodeline": "if magic != MAGIC:"
    },
    {
        "line": 31,
        "fullcodeline": "(totalsize, off_dt_struct, off_dt_strings, off_mem_rsvmap, version,"
    },
    {
        "line": 39,
        "fullcodeline": "with open(kernel_fname, 'rb') as kernel_file:"
    },
    {
        "line": 47,
        "fullcodeline": "if attack == FAKE_ROOT_ATTACK:"
    },
    {
        "line": 67,
        "fullcodeline": "with open(out_fname, 'wb') as output_file:"
    },
    {
        "line": 14,
        "fullcodeline": "attack = FAKE_ROOT_ATTACK"
    },
    {
        "line": 28,
        "fullcodeline": "raise ValueError('Wrong magic!')"
    },
    {
        "line": 33,
        "fullcodeline": "size_dt_struct) = struct.unpack('>IIIIIIIII', hdr[offset:offset + 36])"
    },
    {
        "line": 48,
        "fullcodeline": "dt_struct = fake_root_node_attack(dt_struct, dt_strings, kernel_content,"
    },
    {
        "line": 15,
        "fullcodeline": "elif attack == 'kernel@':"
    },
    {
        "line": 21,
        "fullcodeline": "input_data = fin.read()"
    },
    {
        "line": 40,
        "fullcodeline": "kernel_content = kernel_file.read()"
    },
    {
        "line": 50,
        "fullcodeline": "elif attack == KERNEL_AT:"
    },
    {
        "line": 68,
        "fullcodeline": "output_file.write(header)"
    },
    {
        "line": 69,
        "fullcodeline": "output_file.write(rsv_map)"
    },
    {
        "line": 70,
        "fullcodeline": "output_file.write(dt_struct)"
    },
    {
        "line": 71,
        "fullcodeline": "output_file.write(dt_strings)"
    },
    {
        "line": 16,
        "fullcodeline": "attack = KERNEL_AT"
    },
    {
        "line": 18,
        "fullcodeline": "raise ValueError('Unknown attack name!')"
    },
    {
        "line": 51,
        "fullcodeline": "dt_struct = kernel_at_attack(dt_struct, dt_strings, kernel_content,"
    }
]