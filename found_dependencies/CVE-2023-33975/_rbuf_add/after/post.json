[
    {
        "line": 9,
        "fullcodeline": "const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);"
    },
    {
        "line": 10,
        "fullcodeline": "const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);"
    },
    {
        "line": 11,
        "fullcodeline": "uint8_t *data = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */"
    },
    {
        "line": 18,
        "fullcodeline": "assert(_valid_offset(pkt, offset));"
    },
    {
        "line": 48,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_gc();"
    },
    {
        "line": 210,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 19,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 95,
        "fullcodeline": "if ((offset + frag_size) > entry.super->datagram_size) {"
    },
    {
        "line": 103,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 20,
        "fullcodeline": "data = _6lo_frag_payload(pkt);"
    },
    {
        "line": 21,
        "fullcodeline": "frag_size = _6lo_frag_size(pkt, offset, data);"
    },
    {
        "line": 27,
        "fullcodeline": "datagram_size = sixlowpan_frag_datagram_size(pkt->data);"
    },
    {
        "line": 28,
        "fullcodeline": "datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);"
    },
    {
        "line": 54,
        "fullcodeline": "(entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 56,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");"
    },
    {
        "line": 71,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 96,
        "fullcodeline": "DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");"
    },
    {
        "line": 98,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 99,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 105,
        "fullcodeline": "DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");"
    },
    {
        "line": 107,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 110,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 117,
        "fullcodeline": "DEBUG(\"6lo rbuf: add fragment data\\n\");"
    },
    {
        "line": 118,
        "fullcodeline": "entry.super->current_size += (uint16_t)frag_size;"
    },
    {
        "line": 200,
        "fullcodeline": "memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,"
    },
    {
        "line": 22,
        "fullcodeline": "if (frag_size == 0) {"
    },
    {
        "line": 53,
        "fullcodeline": "sixlowpan_frag_n_is(pkt->data) &&"
    },
    {
        "line": 57,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (offset == 0) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||"
    },
    {
        "line": 206,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 207,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 23,
        "fullcodeline": "DEBUG(\"6lo rbuf: integer underflow detected.\\n\");"
    },
    {
        "line": 24,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 30,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 52,
        "fullcodeline": "(offset > 0) &&"
    },
    {
        "line": 59,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");"
    },
    {
        "line": 60,
        "fullcodeline": "gnrc_sixlowpan_frag_vrb_rm(entry.vrb);"
    },
    {
        "line": 62,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 65,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");"
    },
    {
        "line": 66,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 73,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");"
    },
    {
        "line": 74,
        "fullcodeline": "entry.super->current_size += (uint16_t)frag_size;"
    },
    {
        "line": 80,
        "fullcodeline": "res = RBUF_ADD_FORWARDED;"
    },
    {
        "line": 84,
        "fullcodeline": "else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 188,
        "fullcodeline": "IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {"
    },
    {
        "line": 194,
        "fullcodeline": "res = _rbuf_resize_for_reassembly(entry.rbuf);"
    },
    {
        "line": 31,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 32,
        "fullcodeline": "sixlowpan_sfr_rfrag_t *rfrag = pkt->data;"
    },
    {
        "line": 34,
        "fullcodeline": "data = _6lo_sfr_payload(pkt);"
    },
    {
        "line": 35,
        "fullcodeline": "frag_size = _6lo_sfr_frag_size(pkt);"
    },
    {
        "line": 38,
        "fullcodeline": "datagram_size = _6lo_sfr_datagram_size(pkt, offset);"
    },
    {
        "line": 75,
        "fullcodeline": "if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,"
    },
    {
        "line": 87,
        "fullcodeline": "DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");"
    },
    {
        "line": 88,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 120,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&"
    },
    {
        "line": 195,
        "fullcodeline": "if (res == RBUF_ADD_ERROR) {"
    },
    {
        "line": 43,
        "fullcodeline": "assert(data != NULL);"
    },
    {
        "line": 44,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 77,
        "fullcodeline": "DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");"
    },
    {
        "line": 121,
        "fullcodeline": "sixlowpan_iphc_is(data)) {"
    },
    {
        "line": 122,
        "fullcodeline": "DEBUG(\"6lo rbuf: detected IPHC header.\\n\");"
    },
    {
        "line": 123,
        "fullcodeline": "gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);"
    },
    {
        "line": 196,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 125,
        "fullcodeline": "if (frag_hdr == NULL) {"
    },
    {
        "line": 126,
        "fullcodeline": "DEBUG(\"6lo rbuf: unable to mark fragment header. \""
    },
    {
        "line": 129,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 130,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    },
    {
        "line": 144,
        "fullcodeline": "else if (data[0] == SIXLOWPAN_UNCOMP) {"
    },
    {
        "line": 134,
        "fullcodeline": "DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");"
    },
    {
        "line": 136,
        "fullcodeline": "gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);"
    },
    {
        "line": 145,
        "fullcodeline": "DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");"
    },
    {
        "line": 146,
        "fullcodeline": "data++;"
    },
    {
        "line": 138,
        "fullcodeline": "if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {"
    },
    {
        "line": 147,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 139,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 151,
        "fullcodeline": "(entry.super->current_size == frag_size)) {"
    },
    {
        "line": 153,
        "fullcodeline": "gnrc_pktsnip_t tmp = {"
    },
    {
        "line": 150,
        "fullcodeline": "sixlowpan_frag_1_is(pkt->data) &&"
    },
    {
        "line": 159,
        "fullcodeline": "if (_check_hdr(&tmp, page) &&"
    },
    {
        "line": 160,
        "fullcodeline": "(vrbe = gnrc_sixlowpan_frag_vrb_from_route("
    },
    {
        "line": 164,
        "fullcodeline": "_adapt_hdr(&tmp, page);"
    },
    {
        "line": 168,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 154,
        "fullcodeline": ".data = data,"
    },
    {
        "line": 155,
        "fullcodeline": ".size = frag_size,"
    },
    {
        "line": 156,
        "fullcodeline": ".users = 1,"
    },
    {
        "line": 165,
        "fullcodeline": "return _forward_uncomp(pkt, rbuf, vrbe, page);"
    },
    {
        "line": 169,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 170,
        "fullcodeline": "entry.super->datagram_size--;"
    },
    {
        "line": 162,
        "fullcodeline": "gnrc_netif_hdr_get_netif(netif_hdr),"
    },
    {
        "line": 174,
        "fullcodeline": "if (frag_size > entry.super->datagram_size) {"
    },
    {
        "line": 175,
        "fullcodeline": "DEBUG_PUTS("
    },
    {
        "line": 180,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 181,
        "fullcodeline": "gnrc_sixlowpan_frag_rb_remove(entry.rbuf);"
    }
]