[
    {
        "line": 9,
        "fullcodeline": "const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);"
    },
    {
        "line": 10,
        "fullcodeline": "const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);"
    },
    {
        "line": 11,
        "fullcodeline": "uint8_t *data = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */"
    },
    {
        "line": 18,
        "fullcodeline": "assert(_valid_offset(pkt, offset));"
    },
    {
        "line": 91,
        "fullcodeline": "entry.rbuf = &rbuf[res];"
    },
    {
        "line": 19,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {"
    },
    {
        "line": 95,
        "fullcodeline": "if ((offset + frag_size) > entry.super->datagram_size) {"
    },
    {
        "line": 103,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 20,
        "fullcodeline": "data = _6lo_frag_payload(pkt);"
    },
    {
        "line": 21,
        "fullcodeline": "frag_size = _6lo_frag_size(pkt, offset, data);"
    },
    {
        "line": 27,
        "fullcodeline": "datagram_size = sixlowpan_frag_datagram_size(pkt->data);"
    },
    {
        "line": 28,
        "fullcodeline": "datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);"
    },
    {
        "line": 51,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 54,
        "fullcodeline": "(entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 71,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 97,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 106,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 118,
        "fullcodeline": "entry.super->current_size += (uint16_t)frag_size;"
    },
    {
        "line": 22,
        "fullcodeline": "if (frag_size == 0) {"
    },
    {
        "line": 53,
        "fullcodeline": "sixlowpan_frag_n_is(pkt->data) &&"
    },
    {
        "line": 57,
        "fullcodeline": "switch (_check_fragments(entry.super, frag_size, offset)) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (_rbuf_update_ints(entry.super, offset, frag_size)) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (offset == 0) {"
    },
    {
        "line": 192,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 194,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 23,
        "fullcodeline": "DEBUG(\"6lo rbuf: integer underflow detected.\\n\");"
    },
    {
        "line": 24,
        "fullcodeline": "gnrc_pktbuf_release(pkt);"
    },
    {
        "line": 30,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 52,
        "fullcodeline": "(offset > 0) &&"
    },
    {
        "line": 80,
        "fullcodeline": "res = RBUF_ADD_FORWARDED;"
    },
    {
        "line": 174,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||"
    },
    {
        "line": 175,
        "fullcodeline": "IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {"
    },
    {
        "line": 181,
        "fullcodeline": "res = _rbuf_resize_for_reassembly(entry.rbuf);"
    },
    {
        "line": 31,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 34,
        "fullcodeline": "data = _6lo_sfr_payload(pkt);"
    },
    {
        "line": 35,
        "fullcodeline": "frag_size = _6lo_sfr_frag_size(pkt);"
    },
    {
        "line": 38,
        "fullcodeline": "datagram_size = _6lo_sfr_datagram_size(pkt, offset);"
    },
    {
        "line": 39,
        "fullcodeline": "datagram_tag = rfrag->base.tag;"
    },
    {
        "line": 84,
        "fullcodeline": "else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,"
    },
    {
        "line": 182,
        "fullcodeline": "if (res == RBUF_ADD_ERROR) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,"
    },
    {
        "line": 120,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&"
    },
    {
        "line": 121,
        "fullcodeline": "sixlowpan_iphc_is(data)) {"
    },
    {
        "line": 123,
        "fullcodeline": "gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);"
    },
    {
        "line": 43,
        "fullcodeline": "assert(data != NULL);"
    },
    {
        "line": 128,
        "fullcodeline": "gnrc_pktbuf_release(entry.rbuf->pkt);"
    },
    {
        "line": 144,
        "fullcodeline": "else if (data[0] == SIXLOWPAN_UNCOMP) {"
    },
    {
        "line": 136,
        "fullcodeline": "gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);"
    },
    {
        "line": 146,
        "fullcodeline": "data++;"
    },
    {
        "line": 139,
        "fullcodeline": "res = RBUF_ADD_ERROR;"
    },
    {
        "line": 147,
        "fullcodeline": "if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&"
    },
    {
        "line": 151,
        "fullcodeline": "(entry.super->current_size == frag_size)) {"
    },
    {
        "line": 153,
        "fullcodeline": "gnrc_pktsnip_t tmp = {"
    },
    {
        "line": 150,
        "fullcodeline": "sixlowpan_frag_1_is(pkt->data) &&"
    },
    {
        "line": 159,
        "fullcodeline": "if (_check_hdr(&tmp, page) &&"
    },
    {
        "line": 160,
        "fullcodeline": "(vrbe = gnrc_sixlowpan_frag_vrb_from_route("
    },
    {
        "line": 164,
        "fullcodeline": "_adapt_hdr(&tmp, page);"
    },
    {
        "line": 168,
        "fullcodeline": "else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&"
    },
    {
        "line": 154,
        "fullcodeline": ".data = data,"
    },
    {
        "line": 155,
        "fullcodeline": ".size = frag_size,"
    },
    {
        "line": 156,
        "fullcodeline": ".users = 1,"
    },
    {
        "line": 165,
        "fullcodeline": "return _forward_uncomp(pkt, rbuf, vrbe, page);"
    },
    {
        "line": 169,
        "fullcodeline": "sixlowpan_sfr_rfrag_is(pkt->data)) {"
    },
    {
        "line": 162,
        "fullcodeline": "gnrc_netif_hdr_get_netif(netif_hdr),"
    }
]