[
    {
        "line": 7,
        "fullcodeline": "int\t\tevaluate = evalarg != NULL"
    },
    {
        "line": 9,
        "fullcodeline": "typval_T\tbase = *rettv;"
    },
    {
        "line": 12,
        "fullcodeline": "rettv->v_type = VAR_UNKNOWN;"
    },
    {
        "line": 14,
        "fullcodeline": "if (**arg == '{')"
    },
    {
        "line": 35,
        "fullcodeline": "if (ret != OK)"
    },
    {
        "line": 8,
        "fullcodeline": "&& (evalarg->eval_flags & EVAL_EVALUATE);"
    },
    {
        "line": 17,
        "fullcodeline": "ret = get_lambda_tv(arg, rettv, FALSE, evalarg);"
    },
    {
        "line": 22,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 23,
        "fullcodeline": "ret = eval1(arg, rettv, evalarg);"
    },
    {
        "line": 24,
        "fullcodeline": "*arg = skipwhite_and_linebreak(*arg, evalarg);"
    },
    {
        "line": 25,
        "fullcodeline": "if (**arg == ')')"
    },
    {
        "line": 37,
        "fullcodeline": "else if (**arg != '(')"
    },
    {
        "line": 27,
        "fullcodeline": "++*arg;"
    },
    {
        "line": 47,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 31,
        "fullcodeline": "emsg(_(e_missing_closing_paren));"
    },
    {
        "line": 32,
        "fullcodeline": "ret = FAIL;"
    },
    {
        "line": 50,
        "fullcodeline": "ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);"
    },
    {
        "line": 42,
        "fullcodeline": "emsg(_(e_no_white_space_allowed_before_parenthesis));"
    },
    {
        "line": 44,
        "fullcodeline": "semsg(_(e_missing_parenthesis_str), \"lambda\");"
    }
]