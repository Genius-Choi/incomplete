[
    {
        "line": 6,
        "fullcodeline": "const auto old_lec = epoch_by_pg[ps];"
    },
    {
        "line": 11,
        "fullcodeline": "epoch_by_pg[ps] = last_epoch_clean;"
    },
    {
        "line": 3,
        "fullcodeline": "if (epoch_by_pg.size() <= ps) {"
    },
    {
        "line": 7,
        "fullcodeline": "if (old_lec >= last_epoch_clean) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (last_epoch_clean < floor) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (ps != next_missing) {"
    },
    {
        "line": 25,
        "fullcodeline": "for (; next_missing < epoch_by_pg.size(); next_missing++) {"
    },
    {
        "line": 4,
        "fullcodeline": "epoch_by_pg.resize(ps + 1, 0);"
    },
    {
        "line": 13,
        "fullcodeline": "floor = last_epoch_clean;"
    },
    {
        "line": 26,
        "fullcodeline": "if (epoch_by_pg[next_missing] == 0) {"
    },
    {
        "line": 14,
        "fullcodeline": "} else if (last_epoch_clean > floor) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (old_lec == floor) {"
    },
    {
        "line": 17,
        "fullcodeline": "auto new_floor = std::min_element(std::begin(epoch_by_pg),"
    },
    {
        "line": 18,
        "fullcodeline": "std::end(epoch_by_pg));"
    }
]