[
    {
        "line": 7,
        "fullcodeline": "struct sctp_chunk *chunk = arg;"
    },
    {
        "line": 11,
        "fullcodeline": "struct sctp_ulpevent *ev, *ai_ev = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "int error = 0;"
    },
    {
        "line": 54,
        "fullcodeline": "new_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,"
    },
    {
        "line": 102,
        "fullcodeline": "error = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);"
    },
    {
        "line": 143,
        "fullcodeline": "repl = sctp_make_cookie_ack(new_asoc, chunk);"
    },
    {
        "line": 153,
        "fullcodeline": "ev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,"
    },
    {
        "line": 177,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));"
    },
    {
        "line": 178,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,"
    },
    {
        "line": 180,
        "fullcodeline": "SCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);"
    },
    {
        "line": 181,
        "fullcodeline": "SCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);"
    },
    {
        "line": 182,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());"
    },
    {
        "line": 189,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));"
    },
    {
        "line": 192,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));"
    },
    {
        "line": 202,
        "fullcodeline": "sctp_ulpevent_free(ev);"
    },
    {
        "line": 204,
        "fullcodeline": "sctp_chunk_free(repl);"
    },
    {
        "line": 206,
        "fullcodeline": "sctp_association_free(new_asoc);"
    },
    {
        "line": 19,
        "fullcodeline": "if (ep == sctp_sk(net->sctp.ctl_sock)->ep) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))"
    },
    {
        "line": 37,
        "fullcodeline": "if (!sctp_sstate(sk, LISTENING) ||"
    },
    {
        "line": 46,
        "fullcodeline": "if (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -"
    },
    {
        "line": 63,
        "fullcodeline": "if (!new_asoc) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (!sctp_process_init(new_asoc, chunk,"
    },
    {
        "line": 144,
        "fullcodeline": "if (!repl)"
    },
    {
        "line": 157,
        "fullcodeline": "if (!ev)"
    },
    {
        "line": 179,
        "fullcodeline": "SCTP_STATE(SCTP_STATE_ESTABLISHED));"
    },
    {
        "line": 20,
        "fullcodeline": "SCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);"
    },
    {
        "line": 38,
        "fullcodeline": "(sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))"
    },
    {
        "line": 124,
        "fullcodeline": "auth.skb = chunk->auth_chunk;"
    },
    {
        "line": 125,
        "fullcodeline": "auth.asoc = chunk->asoc;"
    },
    {
        "line": 126,
        "fullcodeline": "auth.sctp_hdr = chunk->sctp_hdr;"
    },
    {
        "line": 127,
        "fullcodeline": "auth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,"
    },
    {
        "line": 129,
        "fullcodeline": "skb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));"
    },
    {
        "line": 130,
        "fullcodeline": "auth.transport = chunk->transport;"
    },
    {
        "line": 132,
        "fullcodeline": "ret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);"
    },
    {
        "line": 135,
        "fullcodeline": "kfree_skb(chunk->auth_chunk);"
    },
    {
        "line": 166,
        "fullcodeline": "ai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,"
    },
    {
        "line": 185,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,"
    },
    {
        "line": 196,
        "fullcodeline": "sctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,"
    },
    {
        "line": 21,
        "fullcodeline": "return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 30,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 39,
        "fullcodeline": "return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 117,
        "fullcodeline": "if (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (ret != SCTP_IERROR_NO_ERROR) {"
    },
    {
        "line": 168,
        "fullcodeline": "if (!ai_ev)"
    },
    {
        "line": 186,
        "fullcodeline": "SCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));"
    },
    {
        "line": 197,
        "fullcodeline": "SCTP_ULPEVENT(ai_ev));"
    },
    {
        "line": 68,
        "fullcodeline": "case -SCTP_IERROR_NOMEM:"
    },
    {
        "line": 71,
        "fullcodeline": "case -SCTP_IERROR_STALE_COOKIE:"
    },
    {
        "line": 72,
        "fullcodeline": "sctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,"
    },
    {
        "line": 76,
        "fullcodeline": "case -SCTP_IERROR_BAD_SIG:"
    },
    {
        "line": 118,
        "fullcodeline": "kfree_skb(chunk->auth_chunk);"
    },
    {
        "line": 119,
        "fullcodeline": "sctp_association_free(new_asoc);"
    },
    {
        "line": 138,
        "fullcodeline": "sctp_association_free(new_asoc);"
    },
    {
        "line": 74,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 78,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 120,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    },
    {
        "line": 139,
        "fullcodeline": "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);"
    }
]