[
    {
        "line": 3,
        "fullcodeline": "bool indices_has_only_positive_elements = true;"
    },
    {
        "line": 4,
        "fullcodeline": "const auto* indices_values = GetTensorData<IndicesT>(indices);"
    },
    {
        "line": 5,
        "fullcodeline": "const size_t num_indices = indices->bytes / sizeof(IndicesT);"
    },
    {
        "line": 12,
        "fullcodeline": "TF_LITE_ENSURE(context, indices_has_only_positive_elements);"
    },
    {
        "line": 6,
        "fullcodeline": "for (size_t i = 0; i < num_indices; i++) {"
    },
    {
        "line": 30,
        "fullcodeline": "TF_LITE_KERNEL_LOG(context,"
    },
    {
        "line": 7,
        "fullcodeline": "if (indices_values[i] < 0) {"
    },
    {
        "line": 16,
        "fullcodeline": "return GatherNd<float, IndicesT>(context, params, indices, output);"
    },
    {
        "line": 18,
        "fullcodeline": "return GatherNd<uint8_t, IndicesT>(context, params, indices, output);"
    },
    {
        "line": 20,
        "fullcodeline": "return GatherNd<int8_t, IndicesT>(context, params, indices, output);"
    },
    {
        "line": 22,
        "fullcodeline": "return GatherNd<int16_t, IndicesT>(context, params, indices, output);"
    },
    {
        "line": 24,
        "fullcodeline": "return GatherNd<int32_t, IndicesT>(context, params, indices, output);"
    },
    {
        "line": 26,
        "fullcodeline": "return GatherNd<int64_t, IndicesT>(context, params, indices, output);"
    },
    {
        "line": 28,
        "fullcodeline": "return GatherNdString<IndicesT>(params, indices, output);"
    },
    {
        "line": 32,
        "fullcodeline": "TfLiteTypeGetName(params->type));"
    },
    {
        "line": 8,
        "fullcodeline": "indices_has_only_positive_elements = false;"
    }
]