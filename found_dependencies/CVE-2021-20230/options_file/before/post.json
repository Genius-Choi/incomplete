[
    {
        "line": 4,
        "fullcodeline": "char line_text[CONFLINELEN], *errstr;"
    },
    {
        "line": 5,
        "fullcodeline": "char config_line[CONFLINELEN], *config_opt, *config_arg;"
    },
    {
        "line": 6,
        "fullcodeline": "int i, line_number=0;"
    },
    {
        "line": 12,
        "fullcodeline": "s_log(LOG_NOTICE, \"Reading configuration from %s %s\","
    },
    {
        "line": 105,
        "fullcodeline": "file_close(df);"
    },
    {
        "line": 13,
        "fullcodeline": "type==CONF_FD ? \"descriptor\" : \"file\", path);"
    },
    {
        "line": 15,
        "fullcodeline": "if(type==CONF_FD) { /* file descriptor */"
    },
    {
        "line": 26,
        "fullcodeline": "if(!df) {"
    },
    {
        "line": 33,
        "fullcodeline": "while(file_getline(df, line_text, CONFLINELEN)>=0) {"
    },
    {
        "line": 16,
        "fullcodeline": "fd=(int)strtol(path, &tmp_str, 10);"
    },
    {
        "line": 22,
        "fullcodeline": "df=file_fdopen(fd);"
    },
    {
        "line": 27,
        "fullcodeline": "s_log(LOG_ERR, \"Cannot open configuration file\");"
    },
    {
        "line": 34,
        "fullcodeline": "memcpy(config_line, line_text, CONFLINELEN);"
    },
    {
        "line": 35,
        "fullcodeline": "++line_number;"
    },
    {
        "line": 36,
        "fullcodeline": "config_opt=config_line;"
    },
    {
        "line": 79,
        "fullcodeline": "config_arg=strchr(config_line, '=');"
    },
    {
        "line": 86,
        "fullcodeline": "*config_arg++='\\0'; /* split into option name and argument value */"
    },
    {
        "line": 92,
        "fullcodeline": "errstr=option_not_found;"
    },
    {
        "line": 17,
        "fullcodeline": "if(tmp_str==path || *tmp_str) { /* not a number */"
    },
    {
        "line": 25,
        "fullcodeline": "df=file_open(path, FILE_MODE_READ);"
    },
    {
        "line": 28,
        "fullcodeline": "if(type!=CONF_RELOAD)"
    },
    {
        "line": 37,
        "fullcodeline": "if(line_number==1) {"
    },
    {
        "line": 48,
        "fullcodeline": "while(isspace((unsigned char)*config_opt))"
    },
    {
        "line": 49,
        "fullcodeline": "++config_opt; /* remove initial whitespaces */"
    },
    {
        "line": 50,
        "fullcodeline": "for(i=(int)strlen(config_opt)-1; i>=0 && isspace((unsigned char)config_opt[i]); --i)"
    },
    {
        "line": 51,
        "fullcodeline": "config_opt[i]='\\0'; /* remove trailing whitespaces */"
    },
    {
        "line": 52,
        "fullcodeline": "if(config_opt[0]=='\\0' || config_opt[0]=='#' || config_opt[0]==';') /* empty or comment */"
    },
    {
        "line": 55,
        "fullcodeline": "if(config_opt[0]=='[' && config_opt[strlen(config_opt)-1]==']') { /* new section */"
    },
    {
        "line": 80,
        "fullcodeline": "if(!config_arg) {"
    },
    {
        "line": 87,
        "fullcodeline": "for(i=(int)strlen(config_opt)-1; i>=0 && isspace((unsigned char)config_opt[i]); --i)"
    },
    {
        "line": 88,
        "fullcodeline": "config_opt[i]='\\0'; /* remove trailing whitespaces */"
    },
    {
        "line": 90,
        "fullcodeline": "++config_arg; /* remove initial whitespaces */"
    },
    {
        "line": 96,
        "fullcodeline": "if(errstr==option_not_found)"
    },
    {
        "line": 18,
        "fullcodeline": "s_log(LOG_ERR, \"Invalid file descriptor number\");"
    },
    {
        "line": 19,
        "fullcodeline": "print_syntax();"
    },
    {
        "line": 29,
        "fullcodeline": "print_syntax();"
    },
    {
        "line": 71,
        "fullcodeline": "++config_opt;"
    },
    {
        "line": 72,
        "fullcodeline": "config_opt[strlen(config_opt)-1]='\\0';"
    },
    {
        "line": 73,
        "fullcodeline": "(*section_ptr)->servname=str_dup_detached(config_opt);"
    },
    {
        "line": 74,
        "fullcodeline": "(*section_ptr)->session=NULL;"
    },
    {
        "line": 75,
        "fullcodeline": "parse_service_option(CMD_SET_COPY, section_ptr, NULL, NULL);"
    },
    {
        "line": 81,
        "fullcodeline": "s_log(LOG_ERR, \"%s:%d: \\\"%s\\\": No '=' found\","
    },
    {
        "line": 83,
        "fullcodeline": "file_close(df);"
    },
    {
        "line": 95,
        "fullcodeline": "errstr=parse_global_option(CMD_SET_VALUE, config_opt, config_arg);"
    },
    {
        "line": 97,
        "fullcodeline": "errstr=parse_service_option(CMD_SET_VALUE, section_ptr, config_opt, config_arg);"
    },
    {
        "line": 99,
        "fullcodeline": "s_log(LOG_ERR, \"%s:%d: \\\"%s\\\": %s\","
    },
    {
        "line": 101,
        "fullcodeline": "file_close(df);"
    },
    {
        "line": 38,
        "fullcodeline": "if(config_opt[0]==(char)0xef &&"
    },
    {
        "line": 56,
        "fullcodeline": "if(init_section(0, section_ptr)) {"
    },
    {
        "line": 65,
        "fullcodeline": "new_section->next=NULL;"
    },
    {
        "line": 66,
        "fullcodeline": "(*section_ptr)->next=new_section;"
    },
    {
        "line": 67,
        "fullcodeline": "*section_ptr=new_section;"
    },
    {
        "line": 40,
        "fullcodeline": "config_opt[2]==(char)0xbf) {"
    },
    {
        "line": 41,
        "fullcodeline": "s_log(LOG_NOTICE, \"UTF-8 byte order mark detected\");"
    },
    {
        "line": 42,
        "fullcodeline": "config_opt+=3;"
    },
    {
        "line": 57,
        "fullcodeline": "file_close(df);"
    },
    {
        "line": 39,
        "fullcodeline": "config_opt[1]==(char)0xbb &&"
    },
    {
        "line": 44,
        "fullcodeline": "s_log(LOG_NOTICE, \"UTF-8 byte order mark not detected\");"
    }
]