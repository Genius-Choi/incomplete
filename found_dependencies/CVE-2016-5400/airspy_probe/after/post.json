[
    {
        "line": 6,
        "fullcodeline": "u8 u8tmp, buf[BUF_SIZE];"
    },
    {
        "line": 8,
        "fullcodeline": "s = kzalloc(sizeof(struct airspy), GFP_KERNEL);"
    },
    {
        "line": 14,
        "fullcodeline": "mutex_init(&s->v4l2_lock);"
    },
    {
        "line": 15,
        "fullcodeline": "mutex_init(&s->vb_queue_lock);"
    },
    {
        "line": 16,
        "fullcodeline": "spin_lock_init(&s->queued_bufs_lock);"
    },
    {
        "line": 17,
        "fullcodeline": "INIT_LIST_HEAD(&s->queued_bufs);"
    },
    {
        "line": 18,
        "fullcodeline": "s->dev = &intf->dev;"
    },
    {
        "line": 19,
        "fullcodeline": "s->udev = interface_to_usbdev(intf);"
    },
    {
        "line": 26,
        "fullcodeline": "ret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);"
    },
    {
        "line": 35,
        "fullcodeline": "buf[BUF_SIZE - 1] = '\\0';"
    },
    {
        "line": 37,
        "fullcodeline": "dev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);"
    },
    {
        "line": 38,
        "fullcodeline": "dev_info(s->dev, \"Firmware version: %s\\n\", buf);"
    },
    {
        "line": 41,
        "fullcodeline": "s->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;"
    },
    {
        "line": 42,
        "fullcodeline": "s->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;"
    },
    {
        "line": 43,
        "fullcodeline": "s->vb_queue.drv_priv = s;"
    },
    {
        "line": 45,
        "fullcodeline": "s->vb_queue.ops = &airspy_vb2_ops;"
    },
    {
        "line": 46,
        "fullcodeline": "s->vb_queue.mem_ops = &vb2_vmalloc_memops;"
    },
    {
        "line": 47,
        "fullcodeline": "s->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;"
    },
    {
        "line": 48,
        "fullcodeline": "ret = vb2_queue_init(&s->vb_queue);"
    },
    {
        "line": 55,
        "fullcodeline": "s->vdev = airspy_template;"
    },
    {
        "line": 56,
        "fullcodeline": "s->vdev.queue = &s->vb_queue;"
    },
    {
        "line": 57,
        "fullcodeline": "s->vdev.queue->lock = &s->vb_queue_lock;"
    },
    {
        "line": 58,
        "fullcodeline": "video_set_drvdata(&s->vdev, s);"
    },
    {
        "line": 61,
        "fullcodeline": "s->v4l2_dev.release = airspy_video_release;"
    },
    {
        "line": 62,
        "fullcodeline": "ret = v4l2_device_register(&intf->dev, &s->v4l2_dev);"
    },
    {
        "line": 69,
        "fullcodeline": "v4l2_ctrl_handler_init(&s->hdl, 5);"
    },
    {
        "line": 70,
        "fullcodeline": "s->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,"
    },
    {
        "line": 72,
        "fullcodeline": "s->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,"
    },
    {
        "line": 74,
        "fullcodeline": "v4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);"
    },
    {
        "line": 75,
        "fullcodeline": "s->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,"
    },
    {
        "line": 77,
        "fullcodeline": "s->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,"
    },
    {
        "line": 79,
        "fullcodeline": "v4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);"
    },
    {
        "line": 80,
        "fullcodeline": "s->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,"
    },
    {
        "line": 88,
        "fullcodeline": "v4l2_ctrl_handler_setup(&s->hdl);"
    },
    {
        "line": 90,
        "fullcodeline": "s->v4l2_dev.ctrl_handler = &s->hdl;"
    },
    {
        "line": 91,
        "fullcodeline": "s->vdev.v4l2_dev = &s->v4l2_dev;"
    },
    {
        "line": 92,
        "fullcodeline": "s->vdev.lock = &s->v4l2_lock;"
    },
    {
        "line": 94,
        "fullcodeline": "ret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);"
    },
    {
        "line": 100,
        "fullcodeline": "dev_info(s->dev, \"Registered as %s\\n\","
    },
    {
        "line": 102,
        "fullcodeline": "dev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");"
    },
    {
        "line": 106,
        "fullcodeline": "v4l2_ctrl_handler_free(&s->hdl);"
    },
    {
        "line": 107,
        "fullcodeline": "v4l2_device_unregister(&s->v4l2_dev);"
    },
    {
        "line": 109,
        "fullcodeline": "kfree(s);"
    },
    {
        "line": 9,
        "fullcodeline": "if (s == NULL) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (ret == 0)"
    },
    {
        "line": 101,
        "fullcodeline": "video_device_node_name(&s->vdev));"
    },
    {
        "line": 10,
        "fullcodeline": "dev_err(&intf->dev, \"Could not allocate memory for state\\n\");"
    },
    {
        "line": 28,
        "fullcodeline": "ret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,"
    },
    {
        "line": 31,
        "fullcodeline": "dev_err(s->dev, \"Could not detect board\\n\");"
    },
    {
        "line": 50,
        "fullcodeline": "dev_err(s->dev, \"Could not initialize vb2 queue\\n\");"
    },
    {
        "line": 64,
        "fullcodeline": "dev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);"
    },
    {
        "line": 84,
        "fullcodeline": "dev_err(s->dev, \"Could not initialize controls\\n\");"
    },
    {
        "line": 96,
        "fullcodeline": "dev_err(s->dev, \"Failed to register as video device (%d)\\n\","
    },
    {
        "line": 11,
        "fullcodeline": "return -ENOMEM;"
    }
]