[
    {
        "line": 3,
        "fullcodeline": "char buf[2048];"
    },
    {
        "line": 5,
        "fullcodeline": "int endofheaders = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "int chunked = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "int content_length = -1;"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned int chunksize = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "unsigned int bytestocopy = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned int header_buf_len = 2048;"
    },
    {
        "line": 13,
        "fullcodeline": "unsigned int header_buf_used = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "unsigned int content_buf_len = 2048;"
    },
    {
        "line": 16,
        "fullcodeline": "unsigned int content_buf_used = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "char chunksize_buf[32];"
    },
    {
        "line": 20,
        "fullcodeline": "header_buf = malloc(header_buf_len);"
    },
    {
        "line": 21,
        "fullcodeline": "content_buf = malloc(content_buf_len);"
    },
    {
        "line": 22,
        "fullcodeline": "chunksize_buf[0] = '\\0';"
    },
    {
        "line": 23,
        "fullcodeline": "chunksize_buf_index = 0;"
    },
    {
        "line": 215,
        "fullcodeline": "free(header_buf); header_buf = NULL;"
    },
    {
        "line": 216,
        "fullcodeline": "*size = content_buf_used;"
    },
    {
        "line": 25,
        "fullcodeline": "while((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)"
    },
    {
        "line": 217,
        "fullcodeline": "if(content_buf_used == 0)"
    },
    {
        "line": 220,
        "fullcodeline": "content_buf = NULL;"
    },
    {
        "line": 27,
        "fullcodeline": "if(endofheaders == 0)"
    },
    {
        "line": 206,
        "fullcodeline": "if(content_length > 0 && (int)content_buf_used >= content_length)"
    },
    {
        "line": 30,
        "fullcodeline": "int linestart=0;"
    },
    {
        "line": 31,
        "fullcodeline": "int colon=0;"
    },
    {
        "line": 32,
        "fullcodeline": "int valuestart=0;"
    },
    {
        "line": 37,
        "fullcodeline": "memcpy(header_buf + header_buf_used, buf, n);"
    },
    {
        "line": 38,
        "fullcodeline": "header_buf_used += n;"
    },
    {
        "line": 41,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 108,
        "fullcodeline": "n = header_buf_used - endofheaders;"
    },
    {
        "line": 109,
        "fullcodeline": "memcpy(buf, header_buf + endofheaders, n);"
    },
    {
        "line": 33,
        "fullcodeline": "if(header_buf_used + n > header_buf_len) {"
    },
    {
        "line": 42,
        "fullcodeline": "while(i < ((int)header_buf_used-1) && (endofheaders == 0)) {"
    },
    {
        "line": 62,
        "fullcodeline": "if(endofheaders == 0)"
    },
    {
        "line": 65,
        "fullcodeline": "for(i = 0; i < endofheaders - 1; i++) {"
    },
    {
        "line": 34,
        "fullcodeline": "header_buf = realloc(header_buf, header_buf_used + n);"
    },
    {
        "line": 35,
        "fullcodeline": "header_buf_len = header_buf_used + n;"
    },
    {
        "line": 60,
        "fullcodeline": "i++;"
    },
    {
        "line": 117,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 43,
        "fullcodeline": "if(header_buf[i] == '\\r') {"
    },
    {
        "line": 66,
        "fullcodeline": "if(colon <= linestart && header_buf[i]==':')"
    },
    {
        "line": 118,
        "fullcodeline": "while(i < n)"
    },
    {
        "line": 201,
        "fullcodeline": "memcpy(content_buf + content_buf_used, buf, n);"
    },
    {
        "line": 202,
        "fullcodeline": "content_buf_used += n;"
    },
    {
        "line": 44,
        "fullcodeline": "i++;"
    },
    {
        "line": 68,
        "fullcodeline": "colon = i;"
    },
    {
        "line": 72,
        "fullcodeline": "valuestart = i + 1;"
    },
    {
        "line": 166,
        "fullcodeline": "bytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);"
    },
    {
        "line": 177,
        "fullcodeline": "memcpy(content_buf + content_buf_used, buf + i, bytestocopy);"
    },
    {
        "line": 178,
        "fullcodeline": "content_buf_used += bytestocopy;"
    },
    {
        "line": 179,
        "fullcodeline": "i += bytestocopy;"
    },
    {
        "line": 180,
        "fullcodeline": "chunksize -= bytestocopy;"
    },
    {
        "line": 186,
        "fullcodeline": "if(content_length > 0"
    },
    {
        "line": 191,
        "fullcodeline": "if(content_buf_used + n > content_buf_len)"
    },
    {
        "line": 45,
        "fullcodeline": "if(header_buf[i] == '\\n') {"
    },
    {
        "line": 69,
        "fullcodeline": "while(i < (endofheaders-1)"
    },
    {
        "line": 71,
        "fullcodeline": "i++;"
    },
    {
        "line": 120,
        "fullcodeline": "if(chunksize == 0)"
    },
    {
        "line": 167,
        "fullcodeline": "if((content_buf_used + bytestocopy) > content_buf_len)"
    },
    {
        "line": 187,
        "fullcodeline": "&& (int)(content_buf_used + n) > content_length) {"
    },
    {
        "line": 189,
        "fullcodeline": "n = content_length - content_buf_used;"
    },
    {
        "line": 198,
        "fullcodeline": "content_buf = (char *)realloc((void *)content_buf,"
    },
    {
        "line": 46,
        "fullcodeline": "i++;"
    },
    {
        "line": 54,
        "fullcodeline": "} else if(header_buf[i] == '\\n') {"
    },
    {
        "line": 70,
        "fullcodeline": "&& (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))"
    },
    {
        "line": 75,
        "fullcodeline": "else if(header_buf[i]=='\\r' || header_buf[i]=='\\n')"
    },
    {
        "line": 174,
        "fullcodeline": "content_buf = (char *)realloc((void *)content_buf,"
    },
    {
        "line": 193,
        "fullcodeline": "if(content_length >= (int)(content_buf_used + n)) {"
    },
    {
        "line": 47,
        "fullcodeline": "if(i < (int)header_buf_used && header_buf[i] == '\\r') {"
    },
    {
        "line": 55,
        "fullcodeline": "i++;"
    },
    {
        "line": 102,
        "fullcodeline": "linestart = i;"
    },
    {
        "line": 103,
        "fullcodeline": "colon = linestart;"
    },
    {
        "line": 104,
        "fullcodeline": "valuestart = 0;"
    },
    {
        "line": 123,
        "fullcodeline": "if(chunksize_buf_index == 0) {"
    },
    {
        "line": 128,
        "fullcodeline": "while(i<n && isxdigit(buf[i])"
    },
    {
        "line": 135,
        "fullcodeline": "while(i<n && buf[i] != '\\r' && buf[i] != '\\n')"
    },
    {
        "line": 136,
        "fullcodeline": "i++; /* discarding chunk-extension */"
    },
    {
        "line": 137,
        "fullcodeline": "if(i<n && buf[i] == '\\r') i++;"
    },
    {
        "line": 138,
        "fullcodeline": "if(i<n && buf[i] == '\\n') {"
    },
    {
        "line": 157,
        "fullcodeline": "if(chunksize == 0)"
    },
    {
        "line": 169,
        "fullcodeline": "if(content_length >= (int)(content_buf_used + bytestocopy)) {"
    },
    {
        "line": 194,
        "fullcodeline": "content_buf_len = content_length;"
    },
    {
        "line": 48,
        "fullcodeline": "i++;"
    },
    {
        "line": 56,
        "fullcodeline": "if(header_buf[i] == '\\n') {"
    },
    {
        "line": 77,
        "fullcodeline": "if(colon > linestart && valuestart > colon)"
    },
    {
        "line": 100,
        "fullcodeline": "while(header_buf[i]=='\\r' || header_buf[i] == '\\n')"
    },
    {
        "line": 101,
        "fullcodeline": "i++;"
    },
    {
        "line": 129,
        "fullcodeline": "&& chunksize_buf_index < (sizeof(chunksize_buf)-1))"
    },
    {
        "line": 131,
        "fullcodeline": "chunksize_buf[chunksize_buf_index++] = buf[i];"
    },
    {
        "line": 132,
        "fullcodeline": "chunksize_buf[chunksize_buf_index] = '\\0';"
    },
    {
        "line": 133,
        "fullcodeline": "i++;"
    },
    {
        "line": 147,
        "fullcodeline": "chunksize_buf[0] = '\\0';"
    },
    {
        "line": 148,
        "fullcodeline": "chunksize_buf_index = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "i++;"
    },
    {
        "line": 170,
        "fullcodeline": "content_buf_len = content_length;"
    },
    {
        "line": 196,
        "fullcodeline": "content_buf_len = content_buf_used + n;"
    },
    {
        "line": 49,
        "fullcodeline": "if(i < (int)header_buf_used && header_buf[i] == '\\n') {"
    },
    {
        "line": 57,
        "fullcodeline": "endofheaders = i+1;"
    },
    {
        "line": 125,
        "fullcodeline": "if(i<n && buf[i] == '\\r') i++;"
    },
    {
        "line": 126,
        "fullcodeline": "if(i<n && buf[i] == '\\n') i++;"
    },
    {
        "line": 140,
        "fullcodeline": "for(j = 0; j < chunksize_buf_index; j++) {"
    },
    {
        "line": 172,
        "fullcodeline": "content_buf_len = content_buf_used + bytestocopy;"
    },
    {
        "line": 50,
        "fullcodeline": "endofheaders = i+1;"
    },
    {
        "line": 84,
        "fullcodeline": "if(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))"
    },
    {
        "line": 86,
        "fullcodeline": "content_length = atoi(header_buf+valuestart);"
    },
    {
        "line": 141,
        "fullcodeline": "if(chunksize_buf[j] >= '0'"
    },
    {
        "line": 142,
        "fullcodeline": "&& chunksize_buf[j] <= '9')"
    },
    {
        "line": 143,
        "fullcodeline": "chunksize = (chunksize << 4) + (chunksize_buf[j] - '0');"
    },
    {
        "line": 91,
        "fullcodeline": "else if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)"
    },
    {
        "line": 145,
        "fullcodeline": "chunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);"
    },
    {
        "line": 92,
        "fullcodeline": "&& 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))"
    },
    {
        "line": 97,
        "fullcodeline": "chunked = 1;"
    }
]