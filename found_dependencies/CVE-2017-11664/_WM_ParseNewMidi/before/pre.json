[
    {
        "line": 8,
        "fullcodeline": "uint32_t end_of_tracks = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "uint32_t divisions = 96;"
    },
    {
        "line": 12,
        "fullcodeline": "uint32_t tempo = 500000;"
    },
    {
        "line": 13,
        "fullcodeline": "float samples_per_delta_f = 0.0;"
    },
    {
        "line": 15,
        "fullcodeline": "uint32_t sample_count = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "float sample_count_f = 0.0;"
    },
    {
        "line": 17,
        "fullcodeline": "float sample_remainder = 0.0;"
    },
    {
        "line": 18,
        "fullcodeline": "uint8_t *sysex_store = NULL;"
    },
    {
        "line": 23,
        "fullcodeline": "uint32_t smallest_delta = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "uint32_t subtract_delta = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "uint32_t setup_ret = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "midi_data += 4;"
    },
    {
        "line": 50,
        "fullcodeline": "midi_size -= 4;"
    },
    {
        "line": 55,
        "fullcodeline": "tmp_val = *midi_data++ << 24;"
    },
    {
        "line": 56,
        "fullcodeline": "tmp_val |= *midi_data++ << 16;"
    },
    {
        "line": 57,
        "fullcodeline": "tmp_val |= *midi_data++ << 8;"
    },
    {
        "line": 58,
        "fullcodeline": "tmp_val |= *midi_data++;"
    },
    {
        "line": 59,
        "fullcodeline": "midi_size -= 4;"
    },
    {
        "line": 68,
        "fullcodeline": "tmp_val = *midi_data++ << 8;"
    },
    {
        "line": 69,
        "fullcodeline": "tmp_val |= *midi_data++;"
    },
    {
        "line": 70,
        "fullcodeline": "midi_size -= 2;"
    },
    {
        "line": 75,
        "fullcodeline": "midi_type = tmp_val;"
    },
    {
        "line": 80,
        "fullcodeline": "tmp_val = *midi_data++ << 8;"
    },
    {
        "line": 81,
        "fullcodeline": "tmp_val |= *midi_data++;"
    },
    {
        "line": 82,
        "fullcodeline": "midi_size -= 2;"
    },
    {
        "line": 87,
        "fullcodeline": "no_tracks = tmp_val;"
    },
    {
        "line": 100,
        "fullcodeline": "divisions = *midi_data++ << 8;"
    },
    {
        "line": 101,
        "fullcodeline": "divisions |= *midi_data++;"
    },
    {
        "line": 102,
        "fullcodeline": "midi_size -= 2;"
    },
    {
        "line": 108,
        "fullcodeline": "samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);"
    },
    {
        "line": 110,
        "fullcodeline": "mdi = _WM_initMDI();"
    },
    {
        "line": 111,
        "fullcodeline": "_WM_midi_setup_divisions(mdi,divisions);"
    },
    {
        "line": 113,
        "fullcodeline": "tracks = malloc(sizeof(uint8_t *) * no_tracks);"
    },
    {
        "line": 114,
        "fullcodeline": "track_delta = malloc(sizeof(uint32_t) * no_tracks);"
    },
    {
        "line": 115,
        "fullcodeline": "track_end = malloc(sizeof(uint8_t) * no_tracks);"
    },
    {
        "line": 116,
        "fullcodeline": "running_event = malloc(sizeof(uint8_t) * no_tracks);"
    },
    {
        "line": 118,
        "fullcodeline": "smallest_delta = 0xffffffff;"
    },
    {
        "line": 177,
        "fullcodeline": "subtract_delta = smallest_delta;"
    },
    {
        "line": 178,
        "fullcodeline": "sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);"
    },
    {
        "line": 179,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 180,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 182,
        "fullcodeline": "mdi->events[mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 183,
        "fullcodeline": "mdi->extra_info.approx_total_samples += sample_count;"
    },
    {
        "line": 324,
        "fullcodeline": "mdi->current_event = &mdi->events[0];"
    },
    {
        "line": 325,
        "fullcodeline": "mdi->samples_to_mix = 0;"
    },
    {
        "line": 326,
        "fullcodeline": "mdi->note = NULL;"
    },
    {
        "line": 328,
        "fullcodeline": "_WM_ResetToStart(mdi);"
    },
    {
        "line": 31,
        "fullcodeline": "if (midi_size < 14) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (memcmp(midi_data, \"MThd\", 4)) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (tmp_val > 2) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (tmp_val < 1) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (divisions & 0x00008000) {"
    },
    {
        "line": 119,
        "fullcodeline": "for (i = 0; i < no_tracks; i++) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (midi_type == 1) {"
    },
    {
        "line": 316,
        "fullcodeline": "if ((mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width,"
    },
    {
        "line": 32,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);"
    },
    {
        "line": 36,
        "fullcodeline": "if (!memcmp(midi_data, \"RIFF\", 4)) {"
    },
    {
        "line": 41,
        "fullcodeline": "midi_data += 20;"
    },
    {
        "line": 42,
        "fullcodeline": "midi_size -= 20;"
    },
    {
        "line": 46,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MIDI, NULL, 0);"
    },
    {
        "line": 61,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, NULL, 0);"
    },
    {
        "line": 72,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);"
    },
    {
        "line": 92,
        "fullcodeline": "if ((midi_type == 0) && (no_tracks > 1)) {"
    },
    {
        "line": 104,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);"
    },
    {
        "line": 128,
        "fullcodeline": "midi_data += 4;"
    },
    {
        "line": 129,
        "fullcodeline": "midi_size -= 4;"
    },
    {
        "line": 131,
        "fullcodeline": "track_size = *midi_data++ << 24;"
    },
    {
        "line": 132,
        "fullcodeline": "track_size |= *midi_data++ << 16;"
    },
    {
        "line": 133,
        "fullcodeline": "track_size |= *midi_data++ << 8;"
    },
    {
        "line": 134,
        "fullcodeline": "track_size |= *midi_data++;"
    },
    {
        "line": 135,
        "fullcodeline": "midi_size -= 4;"
    },
    {
        "line": 150,
        "fullcodeline": "tracks[i] = midi_data;"
    },
    {
        "line": 151,
        "fullcodeline": "midi_data += track_size;"
    },
    {
        "line": 152,
        "fullcodeline": "midi_size -= track_size;"
    },
    {
        "line": 153,
        "fullcodeline": "track_end[i] = 0;"
    },
    {
        "line": 154,
        "fullcodeline": "running_event[i] = 0;"
    },
    {
        "line": 155,
        "fullcodeline": "track_delta[i] = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);"
    },
    {
        "line": 162,
        "fullcodeline": "tracks[i]++;"
    },
    {
        "line": 319,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);"
    },
    {
        "line": 37,
        "fullcodeline": "if (midi_size < 34) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (midi_size < 8) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (midi_size < track_size) {"
    },
    {
        "line": 140,
        "fullcodeline": "if (track_size < 3) {"
    },
    {
        "line": 164,
        "fullcodeline": "if (midi_type == 1 ) {"
    },
    {
        "line": 190,
        "fullcodeline": "while (end_of_tracks != no_tracks) {"
    },
    {
        "line": 263,
        "fullcodeline": "sample_remainder = 0.0;"
    },
    {
        "line": 124,
        "fullcodeline": "if (memcmp(midi_data, \"MTrk\", 4) != 0) {"
    },
    {
        "line": 144,
        "fullcodeline": "if ((midi_data[track_size - 3] != 0xFF)"
    },
    {
        "line": 146,
        "fullcodeline": "|| (midi_data[track_size - 1] != 0x00)) {"
    },
    {
        "line": 158,
        "fullcodeline": "track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);"
    },
    {
        "line": 159,
        "fullcodeline": "tracks[i]++;"
    },
    {
        "line": 191,
        "fullcodeline": "smallest_delta = 0;"
    },
    {
        "line": 249,
        "fullcodeline": "subtract_delta = smallest_delta;"
    },
    {
        "line": 250,
        "fullcodeline": "sample_count_f = (((float) smallest_delta * samples_per_delta_f)"
    },
    {
        "line": 252,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 253,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 264,
        "fullcodeline": "for (i = 0; i < no_tracks; i++) {"
    },
    {
        "line": 145,
        "fullcodeline": "|| (midi_data[track_size - 2] != 0x2F)"
    },
    {
        "line": 165,
        "fullcodeline": "if (track_delta[i] < smallest_delta) {"
    },
    {
        "line": 192,
        "fullcodeline": "for (i = 0; i < no_tracks; i++) {"
    },
    {
        "line": 261,
        "fullcodeline": "mdi->is_type2 = 1;"
    },
    {
        "line": 265,
        "fullcodeline": "running_event[i] = 0;"
    },
    {
        "line": 166,
        "fullcodeline": "smallest_delta = track_delta[i];"
    },
    {
        "line": 173,
        "fullcodeline": "if (i == 0) smallest_delta = track_delta[i];"
    },
    {
        "line": 312,
        "fullcodeline": "} while (track_end[i] == 0);"
    },
    {
        "line": 242,
        "fullcodeline": "} while (!track_delta[i]);"
    },
    {
        "line": 243,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > track_delta[i])) {"
    },
    {
        "line": 255,
        "fullcodeline": "mdi->events[mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 267,
        "fullcodeline": "setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);"
    },
    {
        "line": 291,
        "fullcodeline": "tracks[i] += setup_ret;"
    },
    {
        "line": 293,
        "fullcodeline": "track_delta[i] = 0;"
    },
    {
        "line": 300,
        "fullcodeline": "track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);"
    },
    {
        "line": 301,
        "fullcodeline": "tracks[i]++;"
    },
    {
        "line": 303,
        "fullcodeline": "sample_count_f = (((float) track_delta[i] * samples_per_delta_f)"
    },
    {
        "line": 305,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 306,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 310,
        "fullcodeline": "smallest_delta = track_delta[i]; /* Added just to keep Xcode happy */"
    },
    {
        "line": 196,
        "fullcodeline": "track_delta[i] -= subtract_delta;"
    },
    {
        "line": 206,
        "fullcodeline": "setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);"
    },
    {
        "line": 232,
        "fullcodeline": "tracks[i] += setup_ret;"
    },
    {
        "line": 240,
        "fullcodeline": "track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);"
    },
    {
        "line": 241,
        "fullcodeline": "tracks[i]++;"
    },
    {
        "line": 244,
        "fullcodeline": "smallest_delta = track_delta[i];"
    },
    {
        "line": 268,
        "fullcodeline": "if (setup_ret == 0) {"
    },
    {
        "line": 271,
        "fullcodeline": "if (tracks[i][0] > 0x7f) {"
    },
    {
        "line": 207,
        "fullcodeline": "if (setup_ret == 0) {"
    },
    {
        "line": 210,
        "fullcodeline": "if (tracks[i][0] > 0x7f) {"
    },
    {
        "line": 272,
        "fullcodeline": "if (tracks[i][0] < 0xf0) {"
    },
    {
        "line": 307,
        "fullcodeline": "mdi->events[mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 198,
        "fullcodeline": "if ((!smallest_delta)"
    },
    {
        "line": 211,
        "fullcodeline": "if (tracks[i][0] < 0xf0) {"
    },
    {
        "line": 274,
        "fullcodeline": "running_event[i] = tracks[i][0];"
    },
    {
        "line": 296,
        "fullcodeline": "track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);"
    },
    {
        "line": 297,
        "fullcodeline": "tracks[i]++;"
    },
    {
        "line": 199,
        "fullcodeline": "|| (smallest_delta > track_delta[i])) {"
    },
    {
        "line": 200,
        "fullcodeline": "smallest_delta = track_delta[i];"
    },
    {
        "line": 213,
        "fullcodeline": "running_event[i] = tracks[i][0];"
    },
    {
        "line": 236,
        "fullcodeline": "track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);"
    },
    {
        "line": 237,
        "fullcodeline": "tracks[i]++;"
    },
    {
        "line": 275,
        "fullcodeline": "} else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {"
    },
    {
        "line": 277,
        "fullcodeline": "running_event[i] = 0;"
    },
    {
        "line": 214,
        "fullcodeline": "} else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {"
    },
    {
        "line": 216,
        "fullcodeline": "running_event[i] = 0;"
    },
    {
        "line": 278,
        "fullcodeline": "} else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {"
    },
    {
        "line": 280,
        "fullcodeline": "track_end[i] = 1;"
    },
    {
        "line": 217,
        "fullcodeline": "} else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {"
    },
    {
        "line": 219,
        "fullcodeline": "end_of_tracks++;"
    },
    {
        "line": 220,
        "fullcodeline": "track_end[i] = 1;"
    },
    {
        "line": 221,
        "fullcodeline": "tracks[i] += 3;"
    },
    {
        "line": 282,
        "fullcodeline": "} else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {"
    },
    {
        "line": 284,
        "fullcodeline": "tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];"
    },
    {
        "line": 288,
        "fullcodeline": "samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);"
    },
    {
        "line": 223,
        "fullcodeline": "} else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {"
    },
    {
        "line": 225,
        "fullcodeline": "tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];"
    },
    {
        "line": 229,
        "fullcodeline": "samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);"
    },
    {
        "line": 285,
        "fullcodeline": "if (!tempo)"
    },
    {
        "line": 226,
        "fullcodeline": "if (!tempo)"
    },
    {
        "line": 286,
        "fullcodeline": "tempo = 500000;"
    },
    {
        "line": 227,
        "fullcodeline": "tempo = 500000;"
    }
]