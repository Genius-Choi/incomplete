[
    {
        "line": 2,
        "fullcodeline": "uint32_t hmi_tmp = 0;"
    },
    {
        "line": 3,
        "fullcodeline": "uint8_t *hmi_base = hmi_data;"
    },
    {
        "line": 4,
        "fullcodeline": "uint16_t hmi_bpm = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "uint16_t hmi_division = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "uint32_t hmi_track_cnt = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "uint32_t *hmi_track_offset = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "uint32_t i = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "uint32_t j = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "uint8_t *hmi_addr = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "uint32_t *hmi_track_header_length = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "struct _mdi *hmi_mdi = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "uint32_t tempo_f = 5000000.0;"
    },
    {
        "line": 16,
        "fullcodeline": "uint32_t *hmi_track_end = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "uint8_t hmi_tracks_ended = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "uint8_t *hmi_running_event = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "uint32_t setup_ret = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "uint32_t *hmi_delta = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "uint32_t smallest_delta = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "uint32_t subtract_delta = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "uint32_t sample_count = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "float sample_count_f = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "float sample_remainder = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "float samples_per_delta_f = 0.0;"
    },
    {
        "line": 37,
        "fullcodeline": "UNUSED(hmi_size);"
    },
    {
        "line": 45,
        "fullcodeline": "hmi_bpm = hmi_data[212];"
    },
    {
        "line": 47,
        "fullcodeline": "hmi_division = 60;"
    },
    {
        "line": 49,
        "fullcodeline": "hmi_track_cnt = hmi_data[228];"
    },
    {
        "line": 51,
        "fullcodeline": "hmi_mdi = _WM_initMDI();"
    },
    {
        "line": 53,
        "fullcodeline": "_WM_midi_setup_divisions(hmi_mdi, hmi_division);"
    },
    {
        "line": 60,
        "fullcodeline": "samples_per_delta_f = _WM_GetSamplesPerTick(hmi_division, (uint32_t)tempo_f);"
    },
    {
        "line": 62,
        "fullcodeline": "_WM_midi_setup_tempo(hmi_mdi, (uint32_t)tempo_f);"
    },
    {
        "line": 64,
        "fullcodeline": "hmi_track_offset = (uint32_t *)malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 65,
        "fullcodeline": "hmi_track_header_length = malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 66,
        "fullcodeline": "hmi_track_end = malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 67,
        "fullcodeline": "hmi_delta = malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 68,
        "fullcodeline": "note = malloc(sizeof(struct _note) * 128 * hmi_track_cnt);"
    },
    {
        "line": 69,
        "fullcodeline": "hmi_running_event = malloc(sizeof(uint8_t) * 128 * hmi_track_cnt);"
    },
    {
        "line": 71,
        "fullcodeline": "hmi_data += 370;"
    },
    {
        "line": 73,
        "fullcodeline": "smallest_delta = 0xffffffff;"
    },
    {
        "line": 136,
        "fullcodeline": "subtract_delta = smallest_delta;"
    },
    {
        "line": 137,
        "fullcodeline": "sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);"
    },
    {
        "line": 139,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 140,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 142,
        "fullcodeline": "hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 143,
        "fullcodeline": "hmi_mdi->extra_info.approx_total_samples += sample_count;"
    },
    {
        "line": 296,
        "fullcodeline": "hmi_mdi->extra_info.current_sample = 0;"
    },
    {
        "line": 298,
        "fullcodeline": "hmi_mdi->samples_to_mix = 0;"
    },
    {
        "line": 299,
        "fullcodeline": "hmi_mdi->note = NULL;"
    },
    {
        "line": 301,
        "fullcodeline": "_WM_ResetToStart(hmi_mdi);"
    },
    {
        "line": 304,
        "fullcodeline": "free(hmi_track_offset);"
    },
    {
        "line": 305,
        "fullcodeline": "free(hmi_track_header_length);"
    },
    {
        "line": 306,
        "fullcodeline": "free(hmi_track_end);"
    },
    {
        "line": 307,
        "fullcodeline": "free(hmi_delta);"
    },
    {
        "line": 308,
        "fullcodeline": "free(note);"
    },
    {
        "line": 309,
        "fullcodeline": "free(hmi_running_event);"
    },
    {
        "line": 312,
        "fullcodeline": "_WM_freeMDI(hmi_mdi);"
    },
    {
        "line": 39,
        "fullcodeline": "if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {"
    },
    {
        "line": 55,
        "fullcodeline": "if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (hmi_size < (370 + (hmi_track_cnt * 17))) {"
    },
    {
        "line": 82,
        "fullcodeline": "for (i = 0; i < hmi_track_cnt; i++) {"
    },
    {
        "line": 145,
        "fullcodeline": "while (hmi_tracks_ended < hmi_track_cnt) {"
    },
    {
        "line": 291,
        "fullcodeline": "if ((hmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {"
    },
    {
        "line": 40,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);"
    },
    {
        "line": 56,
        "fullcodeline": "tempo_f = (float) (60000000 / hmi_bpm) + 0.5f;"
    },
    {
        "line": 76,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);"
    },
    {
        "line": 84,
        "fullcodeline": "hmi_track_offset[i] += (*hmi_data++ << 8);"
    },
    {
        "line": 85,
        "fullcodeline": "hmi_track_offset[i] += (*hmi_data++ << 16);"
    },
    {
        "line": 86,
        "fullcodeline": "hmi_track_offset[i] += (*hmi_data++ << 24);"
    },
    {
        "line": 93,
        "fullcodeline": "hmi_addr = hmi_base + hmi_track_offset[i];"
    },
    {
        "line": 100,
        "fullcodeline": "hmi_track_header_length[i] = hmi_addr[0x57];"
    },
    {
        "line": 101,
        "fullcodeline": "hmi_track_header_length[i] += (hmi_addr[0x58] << 8);"
    },
    {
        "line": 102,
        "fullcodeline": "hmi_track_header_length[i] += (hmi_addr[0x59] << 16);"
    },
    {
        "line": 103,
        "fullcodeline": "hmi_track_header_length[i] += (hmi_addr[0x5a] << 24);"
    },
    {
        "line": 105,
        "fullcodeline": "hmi_addr += hmi_track_header_length[i];"
    },
    {
        "line": 106,
        "fullcodeline": "hmi_track_offset[i] += hmi_track_header_length[i];"
    },
    {
        "line": 109,
        "fullcodeline": "hmi_delta[i] = 0;"
    },
    {
        "line": 117,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);"
    },
    {
        "line": 118,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 119,
        "fullcodeline": "hmi_addr++;"
    },
    {
        "line": 126,
        "fullcodeline": "hmi_track_end[i] = 0;"
    },
    {
        "line": 127,
        "fullcodeline": "hmi_running_event[i] = 0;"
    },
    {
        "line": 146,
        "fullcodeline": "smallest_delta = 0;"
    },
    {
        "line": 281,
        "fullcodeline": "subtract_delta = smallest_delta;"
    },
    {
        "line": 282,
        "fullcodeline": "sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);"
    },
    {
        "line": 284,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 285,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 287,
        "fullcodeline": "hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 288,
        "fullcodeline": "hmi_mdi->extra_info.approx_total_samples += sample_count;"
    },
    {
        "line": 292,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);"
    },
    {
        "line": 58,
        "fullcodeline": "tempo_f = (float) (60000000 / hmi_bpm);"
    },
    {
        "line": 88,
        "fullcodeline": "if (hmi_size < (hmi_track_offset[i] + 0x5a + 4)) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (memcmp(hmi_addr, \"HMI-MIDITRACK\", 13)) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (*hmi_addr > 0x7f) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (hmi_delta[i] < smallest_delta) {"
    },
    {
        "line": 129,
        "fullcodeline": "for (j = 0; j < 128; j++) {"
    },
    {
        "line": 147,
        "fullcodeline": "for (i = 0; i < hmi_track_cnt; i++) {"
    },
    {
        "line": 83,
        "fullcodeline": "hmi_track_offset[i] = *hmi_data++;"
    },
    {
        "line": 89,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);"
    },
    {
        "line": 96,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);"
    },
    {
        "line": 123,
        "fullcodeline": "smallest_delta = hmi_delta[i];"
    },
    {
        "line": 130,
        "fullcodeline": "hmi_tmp = (128 * i) + j;"
    },
    {
        "line": 131,
        "fullcodeline": "note[hmi_tmp].length = 0;"
    },
    {
        "line": 132,
        "fullcodeline": "note[hmi_tmp].channel = 0;"
    },
    {
        "line": 276,
        "fullcodeline": "hmi_tmp = 0;"
    },
    {
        "line": 277,
        "fullcodeline": "UNUSED(hmi_tmp);"
    },
    {
        "line": 115,
        "fullcodeline": "} while (*hmi_addr > 0x7f);"
    },
    {
        "line": 151,
        "fullcodeline": "for (j = 0; j < 128; j++) {"
    },
    {
        "line": 270,
        "fullcodeline": "} while (!hmi_delta[i]);"
    },
    {
        "line": 271,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {"
    },
    {
        "line": 112,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);"
    },
    {
        "line": 113,
        "fullcodeline": "hmi_addr++;"
    },
    {
        "line": 114,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 152,
        "fullcodeline": "hmi_tmp = (128 * i) + j;"
    },
    {
        "line": 166,
        "fullcodeline": "hmi_delta[i] -= subtract_delta;"
    },
    {
        "line": 176,
        "fullcodeline": "hmi_data = hmi_base + hmi_track_offset[i];"
    },
    {
        "line": 177,
        "fullcodeline": "hmi_delta[i] = 0;"
    },
    {
        "line": 267,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 268,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 269,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 272,
        "fullcodeline": "smallest_delta = hmi_delta[i];"
    },
    {
        "line": 179,
        "fullcodeline": "if (hmi_data[0] == 0xfe) {"
    },
    {
        "line": 260,
        "fullcodeline": "if (*hmi_data > 0x7f) {"
    },
    {
        "line": 154,
        "fullcodeline": "note[hmi_tmp].length -= subtract_delta;"
    },
    {
        "line": 189,
        "fullcodeline": "hmi_data += 4;"
    },
    {
        "line": 190,
        "fullcodeline": "hmi_track_offset[i] += 4;"
    },
    {
        "line": 168,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (hmi_data[1] == 0x10) {"
    },
    {
        "line": 265,
        "fullcodeline": "} while (*hmi_data > 0x7F);"
    },
    {
        "line": 169,
        "fullcodeline": "smallest_delta = hmi_delta[i];"
    },
    {
        "line": 182,
        "fullcodeline": "hmi_tmp = (hmi_data[4] + 5);"
    },
    {
        "line": 183,
        "fullcodeline": "hmi_data += hmi_tmp;"
    },
    {
        "line": 184,
        "fullcodeline": "hmi_track_offset[i] += hmi_tmp;"
    },
    {
        "line": 192,
        "fullcodeline": "if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,hmi_running_event[i])) == 0) {"
    },
    {
        "line": 195,
        "fullcodeline": "if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {"
    },
    {
        "line": 209,
        "fullcodeline": "if ((*hmi_data == 0xF0) || (*hmi_data == 0xF7)) {"
    },
    {
        "line": 218,
        "fullcodeline": "if ((hmi_running_event[i] & 0xf0) == 0x90) {"
    },
    {
        "line": 262,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 263,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 264,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 156,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {"
    },
    {
        "line": 160,
        "fullcodeline": "_WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);"
    },
    {
        "line": 196,
        "fullcodeline": "hmi_track_end[i] = 1;"
    },
    {
        "line": 197,
        "fullcodeline": "hmi_tracks_ended++;"
    },
    {
        "line": 211,
        "fullcodeline": "hmi_running_event[i] = 0;"
    },
    {
        "line": 225,
        "fullcodeline": "hmi_tmp += (i * 128);"
    },
    {
        "line": 227,
        "fullcodeline": "note[hmi_tmp].channel = hmi_running_event[i] & 0xf;"
    },
    {
        "line": 229,
        "fullcodeline": "hmi_data += setup_ret;"
    },
    {
        "line": 230,
        "fullcodeline": "hmi_track_offset[i] += setup_ret;"
    },
    {
        "line": 232,
        "fullcodeline": "note[hmi_tmp].length = 0;"
    },
    {
        "line": 240,
        "fullcodeline": "note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 241,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 242,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 157,
        "fullcodeline": "smallest_delta = note[hmi_tmp].length;"
    },
    {
        "line": 185,
        "fullcodeline": "} else if (hmi_data[1] == 0x15) {"
    },
    {
        "line": 198,
        "fullcodeline": "for(j = 0; j < 128; j++) {"
    },
    {
        "line": 220,
        "fullcodeline": "if (*hmi_data > 127) {"
    },
    {
        "line": 233,
        "fullcodeline": "if (*hmi_data > 0x7f) {"
    },
    {
        "line": 253,
        "fullcodeline": "hmi_data += setup_ret;"
    },
    {
        "line": 254,
        "fullcodeline": "hmi_track_offset[i] += setup_ret;"
    },
    {
        "line": 186,
        "fullcodeline": "hmi_data += 4;"
    },
    {
        "line": 187,
        "fullcodeline": "hmi_track_offset[i] += 4;"
    },
    {
        "line": 199,
        "fullcodeline": "hmi_tmp = (128 * i) + j;"
    },
    {
        "line": 212,
        "fullcodeline": "} else if (*hmi_data < 0xF0) {"
    },
    {
        "line": 221,
        "fullcodeline": "hmi_tmp = hmi_data[1];"
    },
    {
        "line": 223,
        "fullcodeline": "hmi_tmp = *hmi_data;"
    },
    {
        "line": 238,
        "fullcodeline": "} while (*hmi_data > 0x7F);"
    },
    {
        "line": 245,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {"
    },
    {
        "line": 249,
        "fullcodeline": "_WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);"
    },
    {
        "line": 201,
        "fullcodeline": "_WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);"
    },
    {
        "line": 202,
        "fullcodeline": "note[hmi_tmp].length = 0;"
    },
    {
        "line": 214,
        "fullcodeline": "if (*hmi_data >= 0x80) {"
    },
    {
        "line": 235,
        "fullcodeline": "note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 236,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 237,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 246,
        "fullcodeline": "smallest_delta = note[hmi_tmp].length;"
    },
    {
        "line": 215,
        "fullcodeline": "hmi_running_event[i] = *hmi_data;"
    }
]