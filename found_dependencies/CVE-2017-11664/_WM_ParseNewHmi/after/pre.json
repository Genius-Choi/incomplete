[
    {
        "line": 2,
        "fullcodeline": "uint32_t hmi_tmp = 0;"
    },
    {
        "line": 3,
        "fullcodeline": "uint8_t *hmi_base = hmi_data;"
    },
    {
        "line": 5,
        "fullcodeline": "uint16_t hmi_bpm = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "uint16_t hmi_division = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "uint32_t hmi_track_cnt = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "uint32_t *hmi_track_offset = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "uint32_t i = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "uint32_t j = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "uint8_t *hmi_addr = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "uint32_t *hmi_track_header_length = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "struct _mdi *hmi_mdi = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "uint32_t tempo_f = 5000000.0;"
    },
    {
        "line": 16,
        "fullcodeline": "uint32_t *hmi_track_end = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "uint8_t hmi_tracks_ended = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "uint8_t *hmi_running_event = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "uint32_t setup_ret = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "uint32_t *hmi_delta = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "uint32_t smallest_delta = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "uint32_t subtract_delta = 0;"
    },
    {
        "line": 25,
        "fullcodeline": "uint32_t sample_count = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "float sample_count_f = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "float sample_remainder = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "float samples_per_delta_f = 0.0;"
    },
    {
        "line": 43,
        "fullcodeline": "hmi_bpm = hmi_data[212];"
    },
    {
        "line": 45,
        "fullcodeline": "hmi_division = 60;"
    },
    {
        "line": 47,
        "fullcodeline": "hmi_track_cnt = hmi_data[228];"
    },
    {
        "line": 49,
        "fullcodeline": "hmi_mdi = _WM_initMDI();"
    },
    {
        "line": 51,
        "fullcodeline": "_WM_midi_setup_divisions(hmi_mdi, hmi_division);"
    },
    {
        "line": 58,
        "fullcodeline": "samples_per_delta_f = _WM_GetSamplesPerTick(hmi_division, (uint32_t)tempo_f);"
    },
    {
        "line": 60,
        "fullcodeline": "_WM_midi_setup_tempo(hmi_mdi, (uint32_t)tempo_f);"
    },
    {
        "line": 62,
        "fullcodeline": "hmi_track_offset = (uint32_t *)malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 63,
        "fullcodeline": "hmi_track_header_length = malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 64,
        "fullcodeline": "hmi_track_end = malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 65,
        "fullcodeline": "hmi_delta = malloc(sizeof(uint32_t) * hmi_track_cnt);"
    },
    {
        "line": 66,
        "fullcodeline": "note = malloc(sizeof(struct _note) * 128 * hmi_track_cnt);"
    },
    {
        "line": 67,
        "fullcodeline": "hmi_running_event = malloc(sizeof(uint8_t) * 128 * hmi_track_cnt);"
    },
    {
        "line": 69,
        "fullcodeline": "hmi_data += 370;"
    },
    {
        "line": 71,
        "fullcodeline": "smallest_delta = 0xffffffff;"
    },
    {
        "line": 78,
        "fullcodeline": "hmi_track_offset[0] = *hmi_data; // To keep Xcode happy"
    },
    {
        "line": 134,
        "fullcodeline": "subtract_delta = smallest_delta;"
    },
    {
        "line": 135,
        "fullcodeline": "sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);"
    },
    {
        "line": 137,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 138,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 140,
        "fullcodeline": "hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 141,
        "fullcodeline": "hmi_mdi->extra_info.approx_total_samples += sample_count;"
    },
    {
        "line": 325,
        "fullcodeline": "hmi_mdi->current_event = &hmi_mdi->events[0];"
    },
    {
        "line": 326,
        "fullcodeline": "hmi_mdi->samples_to_mix = 0;"
    },
    {
        "line": 327,
        "fullcodeline": "hmi_mdi->note = NULL;"
    },
    {
        "line": 329,
        "fullcodeline": "_WM_ResetToStart(hmi_mdi);"
    },
    {
        "line": 37,
        "fullcodeline": "if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {"
    },
    {
        "line": 53,
        "fullcodeline": "if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (hmi_size < (370 + (hmi_track_cnt * 17))) {"
    },
    {
        "line": 80,
        "fullcodeline": "for (i = 0; i < hmi_track_cnt; i++) {"
    },
    {
        "line": 143,
        "fullcodeline": "while (hmi_tracks_ended < hmi_track_cnt) {"
    },
    {
        "line": 319,
        "fullcodeline": "if ((hmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {"
    },
    {
        "line": 38,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);"
    },
    {
        "line": 54,
        "fullcodeline": "tempo_f = (float) (60000000 / hmi_bpm) + 0.5f;"
    },
    {
        "line": 81,
        "fullcodeline": "hmi_track_offset[i] = *hmi_data++;"
    },
    {
        "line": 82,
        "fullcodeline": "hmi_track_offset[i] += (*hmi_data++ << 8);"
    },
    {
        "line": 83,
        "fullcodeline": "hmi_track_offset[i] += (*hmi_data++ << 16);"
    },
    {
        "line": 84,
        "fullcodeline": "hmi_track_offset[i] += (*hmi_data++ << 24);"
    },
    {
        "line": 91,
        "fullcodeline": "hmi_addr = hmi_base + hmi_track_offset[i];"
    },
    {
        "line": 98,
        "fullcodeline": "hmi_track_header_length[i] = hmi_addr[0x57];"
    },
    {
        "line": 99,
        "fullcodeline": "hmi_track_header_length[i] += (hmi_addr[0x58] << 8);"
    },
    {
        "line": 100,
        "fullcodeline": "hmi_track_header_length[i] += (hmi_addr[0x59] << 16);"
    },
    {
        "line": 101,
        "fullcodeline": "hmi_track_header_length[i] += (hmi_addr[0x5a] << 24);"
    },
    {
        "line": 103,
        "fullcodeline": "hmi_addr += hmi_track_header_length[i];"
    },
    {
        "line": 104,
        "fullcodeline": "hmi_track_offset[i] += hmi_track_header_length[i];"
    },
    {
        "line": 107,
        "fullcodeline": "hmi_delta[i] = 0;"
    },
    {
        "line": 115,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);"
    },
    {
        "line": 116,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 124,
        "fullcodeline": "hmi_track_end[i] = 0;"
    },
    {
        "line": 125,
        "fullcodeline": "hmi_running_event[i] = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "smallest_delta = 0;"
    },
    {
        "line": 309,
        "fullcodeline": "subtract_delta = smallest_delta;"
    },
    {
        "line": 310,
        "fullcodeline": "sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);"
    },
    {
        "line": 312,
        "fullcodeline": "sample_count = (uint32_t) sample_count_f;"
    },
    {
        "line": 313,
        "fullcodeline": "sample_remainder = sample_count_f - (float) sample_count;"
    },
    {
        "line": 320,
        "fullcodeline": "_WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);"
    },
    {
        "line": 56,
        "fullcodeline": "tempo_f = (float) (60000000 / hmi_bpm);"
    },
    {
        "line": 86,
        "fullcodeline": "if (hmi_size < (hmi_track_offset[i] + 0x5a + 4)) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (memcmp(hmi_addr, \"HMI-MIDITRACK\", 13)) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (*hmi_addr > 0x7f) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (hmi_delta[i] < smallest_delta) {"
    },
    {
        "line": 127,
        "fullcodeline": "for (j = 0; j < 128; j++) {"
    },
    {
        "line": 145,
        "fullcodeline": "for (i = 0; i < hmi_track_cnt; i++) {"
    },
    {
        "line": 121,
        "fullcodeline": "smallest_delta = hmi_delta[i];"
    },
    {
        "line": 304,
        "fullcodeline": "hmi_tmp = 0;"
    },
    {
        "line": 113,
        "fullcodeline": "} while (*hmi_addr > 0x7f);"
    },
    {
        "line": 149,
        "fullcodeline": "for (j = 0; j < 128; j++) {"
    },
    {
        "line": 298,
        "fullcodeline": "} while (!hmi_delta[i]);"
    },
    {
        "line": 299,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {"
    },
    {
        "line": 315,
        "fullcodeline": "hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;"
    },
    {
        "line": 110,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);"
    },
    {
        "line": 111,
        "fullcodeline": "hmi_addr++;"
    },
    {
        "line": 112,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 128,
        "fullcodeline": "hmi_tmp = (128 * i) + j;"
    },
    {
        "line": 164,
        "fullcodeline": "hmi_delta[i] -= subtract_delta;"
    },
    {
        "line": 174,
        "fullcodeline": "hmi_data = hmi_base + hmi_track_offset[i];"
    },
    {
        "line": 175,
        "fullcodeline": "hmi_delta[i] = 0;"
    },
    {
        "line": 180,
        "fullcodeline": "data_siz = hmi_size - hmi_track_offset[i];"
    },
    {
        "line": 294,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 297,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 300,
        "fullcodeline": "smallest_delta = hmi_delta[i];"
    },
    {
        "line": 176,
        "fullcodeline": "if (hmi_track_offset[i] >= hmi_size) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (hmi_data[0] == 0xfe) {"
    },
    {
        "line": 281,
        "fullcodeline": "if (data_siz && *hmi_data > 0x7f) {"
    },
    {
        "line": 290,
        "fullcodeline": "if (!data_siz) {"
    },
    {
        "line": 150,
        "fullcodeline": "hmi_tmp = (128 * i) + j;"
    },
    {
        "line": 152,
        "fullcodeline": "note[hmi_tmp].length -= subtract_delta;"
    },
    {
        "line": 196,
        "fullcodeline": "hmi_data += 4;"
    },
    {
        "line": 197,
        "fullcodeline": "hmi_track_offset[i] += 4;"
    },
    {
        "line": 202,
        "fullcodeline": "data_siz -= hmi_tmp;"
    },
    {
        "line": 166,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {"
    },
    {
        "line": 184,
        "fullcodeline": "if (hmi_data[1] == 0x10) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (hmi_tmp > data_siz) {"
    },
    {
        "line": 288,
        "fullcodeline": "} while (*hmi_data > 0x7F);"
    },
    {
        "line": 167,
        "fullcodeline": "smallest_delta = hmi_delta[i];"
    },
    {
        "line": 185,
        "fullcodeline": "hmi_tmp = (hmi_data[4] + 5);"
    },
    {
        "line": 186,
        "fullcodeline": "hmi_data += hmi_tmp;"
    },
    {
        "line": 187,
        "fullcodeline": "hmi_track_offset[i] += hmi_tmp;"
    },
    {
        "line": 188,
        "fullcodeline": "hmi_tmp += 4;"
    },
    {
        "line": 284,
        "fullcodeline": "hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 285,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 286,
        "fullcodeline": "data_siz--;"
    },
    {
        "line": 287,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 154,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {"
    },
    {
        "line": 158,
        "fullcodeline": "_WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);"
    },
    {
        "line": 204,
        "fullcodeline": "if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,data_siz,hmi_running_event[i])) == 0) {"
    },
    {
        "line": 207,
        "fullcodeline": "if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {"
    },
    {
        "line": 208,
        "fullcodeline": "hmi_track_end[i] = 1;"
    },
    {
        "line": 209,
        "fullcodeline": "hmi_tracks_ended++;"
    },
    {
        "line": 221,
        "fullcodeline": "if ((*hmi_data == 0xF0) || (*hmi_data == 0xF7)) {"
    },
    {
        "line": 223,
        "fullcodeline": "hmi_running_event[i] = 0;"
    },
    {
        "line": 230,
        "fullcodeline": "if ((hmi_running_event[i] & 0xf0) == 0x90) {"
    },
    {
        "line": 239,
        "fullcodeline": "note[hmi_tmp].channel = hmi_running_event[i] & 0xf;"
    },
    {
        "line": 241,
        "fullcodeline": "hmi_data += setup_ret;"
    },
    {
        "line": 242,
        "fullcodeline": "hmi_track_offset[i] += setup_ret;"
    },
    {
        "line": 243,
        "fullcodeline": "data_siz -= setup_ret;"
    },
    {
        "line": 245,
        "fullcodeline": "note[hmi_tmp].length = 0;"
    },
    {
        "line": 259,
        "fullcodeline": "note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 260,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 261,
        "fullcodeline": "data_siz--;"
    },
    {
        "line": 262,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 283,
        "fullcodeline": "if (!data_siz) break;"
    },
    {
        "line": 155,
        "fullcodeline": "smallest_delta = note[hmi_tmp].length;"
    },
    {
        "line": 189,
        "fullcodeline": "} else if (hmi_data[1] == 0x15) {"
    },
    {
        "line": 210,
        "fullcodeline": "for(j = 0; j < 128; j++) {"
    },
    {
        "line": 232,
        "fullcodeline": "if (*hmi_data > 127) {"
    },
    {
        "line": 237,
        "fullcodeline": "hmi_tmp += (i * 128);"
    },
    {
        "line": 246,
        "fullcodeline": "if (data_siz && *hmi_data > 0x7f) {"
    },
    {
        "line": 255,
        "fullcodeline": "if (!data_siz) {"
    },
    {
        "line": 273,
        "fullcodeline": "hmi_data += setup_ret;"
    },
    {
        "line": 274,
        "fullcodeline": "hmi_track_offset[i] += setup_ret;"
    },
    {
        "line": 275,
        "fullcodeline": "data_siz -= setup_ret;"
    },
    {
        "line": 190,
        "fullcodeline": "hmi_data += 4;"
    },
    {
        "line": 191,
        "fullcodeline": "hmi_track_offset[i] += 4;"
    },
    {
        "line": 192,
        "fullcodeline": "hmi_tmp = 8;"
    },
    {
        "line": 224,
        "fullcodeline": "} else if (*hmi_data < 0xF0) {"
    },
    {
        "line": 233,
        "fullcodeline": "hmi_tmp = hmi_data[1];"
    },
    {
        "line": 194,
        "fullcodeline": "hmi_tmp = 4;"
    },
    {
        "line": 235,
        "fullcodeline": "hmi_tmp = *hmi_data;"
    },
    {
        "line": 253,
        "fullcodeline": "} while (*hmi_data > 0x7F);"
    },
    {
        "line": 265,
        "fullcodeline": "if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {"
    },
    {
        "line": 269,
        "fullcodeline": "_WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);"
    },
    {
        "line": 211,
        "fullcodeline": "hmi_tmp = (128 * i) + j;"
    },
    {
        "line": 213,
        "fullcodeline": "_WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);"
    },
    {
        "line": 226,
        "fullcodeline": "if (*hmi_data >= 0x80) {"
    },
    {
        "line": 249,
        "fullcodeline": "note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);"
    },
    {
        "line": 250,
        "fullcodeline": "hmi_data++;"
    },
    {
        "line": 251,
        "fullcodeline": "data_siz--;"
    },
    {
        "line": 252,
        "fullcodeline": "hmi_track_offset[i]++;"
    },
    {
        "line": 266,
        "fullcodeline": "smallest_delta = note[hmi_tmp].length;"
    },
    {
        "line": 227,
        "fullcodeline": "hmi_running_event[i] = *hmi_data;"
    },
    {
        "line": 248,
        "fullcodeline": "if (!data_siz) break;"
    }
]