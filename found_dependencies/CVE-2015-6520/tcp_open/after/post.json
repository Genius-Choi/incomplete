[
    {
        "line": 3,
        "fullcodeline": "struct tcp_sock_t *this = calloc(1, sizeof *this);"
    },
    {
        "line": 10,
        "fullcodeline": "this->sd = -1;"
    },
    {
        "line": 11,
        "fullcodeline": "this->sd = socket(AF_INET, SOCK_STREAM, 0);"
    },
    {
        "line": 19,
        "fullcodeline": "memset(&addr, 0, sizeof addr);"
    },
    {
        "line": 20,
        "fullcodeline": "addr.sin_family = AF_INET;"
    },
    {
        "line": 21,
        "fullcodeline": "addr.sin_port = htons(port);"
    },
    {
        "line": 22,
        "fullcodeline": "addr.sin_addr.s_addr = htonl(0x7F000001);"
    },
    {
        "line": 4,
        "fullcodeline": "if (this == NULL) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (this->sd < 0) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (bind(this->sd,"
    },
    {
        "line": 35,
        "fullcodeline": "if (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (this != NULL) {"
    },
    {
        "line": 5,
        "fullcodeline": "ERR(\"IPv4: callocing this failed\");"
    },
    {
        "line": 13,
        "fullcodeline": "ERR(\"IPv4 socket open failed\");"
    },
    {
        "line": 36,
        "fullcodeline": "ERR(\"IPv4 listen failed on socket\");"
    },
    {
        "line": 47,
        "fullcodeline": "free(this);"
    },
    {
        "line": 26,
        "fullcodeline": "(struct sockaddr *)&addr,"
    },
    {
        "line": 28,
        "fullcodeline": "if (g_options.only_desired_port == 1)"
    },
    {
        "line": 44,
        "fullcodeline": "if (this->sd != -1) {"
    },
    {
        "line": 29,
        "fullcodeline": "ERR(\"IPv4 bind on port failed. \""
    },
    {
        "line": 45,
        "fullcodeline": "close(this->sd);"
    }
]