[
    {
        "line": 13,
        "fullcodeline": "uint16_t desired_port = g_options.desired_port;"
    },
    {
        "line": 30,
        "fullcodeline": "uint16_t real_port = tcp_port_number_get(tcp_socket);"
    },
    {
        "line": 37,
        "fullcodeline": "printf(\"%u|\", real_port);"
    },
    {
        "line": 38,
        "fullcodeline": "fflush(stdout);"
    },
    {
        "line": 5,
        "fullcodeline": "if (g_options.noprinter_mode == 0) {"
    },
    {
        "line": 15,
        "fullcodeline": "while ((tcp_socket = tcp_open(desired_port)) == NULL &&"
    },
    {
        "line": 27,
        "fullcodeline": "if (tcp_socket == NULL)"
    },
    {
        "line": 31,
        "fullcodeline": "if (desired_port != 0 && g_options.only_desired_port == 1 &&"
    },
    {
        "line": 42,
        "fullcodeline": "if (!g_options.nofork_mode && (pid = fork()) > 0) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (usb_can_callback(usb_sock))"
    },
    {
        "line": 84,
        "fullcodeline": "if (tcp_socket!= NULL)"
    },
    {
        "line": 87,
        "fullcodeline": "if (usb_sock != NULL)"
    },
    {
        "line": 6,
        "fullcodeline": "usb_sock = usb_open();"
    },
    {
        "line": 16,
        "fullcodeline": "g_options.only_desired_port == 0) {"
    },
    {
        "line": 18,
        "fullcodeline": "desired_port ++;"
    },
    {
        "line": 32,
        "fullcodeline": "desired_port != real_port) {"
    },
    {
        "line": 33,
        "fullcodeline": "ERR(\"Received port number did not match requested port number.\""
    },
    {
        "line": 43,
        "fullcodeline": "printf(\"%u|\", pid);"
    },
    {
        "line": 49,
        "fullcodeline": "usb_register_callback(usb_sock);"
    },
    {
        "line": 52,
        "fullcodeline": "struct service_thread_param *args = calloc(1, sizeof(*args));"
    },
    {
        "line": 58,
        "fullcodeline": "args->usb_sock = usb_sock;"
    },
    {
        "line": 59,
        "fullcodeline": "args->tcp = tcp_conn_accept(tcp_socket);"
    },
    {
        "line": 65,
        "fullcodeline": "int status = pthread_create(&args->thread_handle, NULL,"
    },
    {
        "line": 85,
        "fullcodeline": "tcp_close(tcp_socket);"
    },
    {
        "line": 88,
        "fullcodeline": "usb_close(usb_sock);"
    },
    {
        "line": 7,
        "fullcodeline": "if (usb_sock == NULL)"
    },
    {
        "line": 10,
        "fullcodeline": "usb_sock = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "if (desired_port == 1 || desired_port == 0)"
    },
    {
        "line": 53,
        "fullcodeline": "if (args == NULL) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (args->tcp == NULL) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (args != NULL) {"
    },
    {
        "line": 25,
        "fullcodeline": "desired_port = 49152;"
    },
    {
        "line": 54,
        "fullcodeline": "ERR(\"Failed to alloc space for thread args\");"
    },
    {
        "line": 61,
        "fullcodeline": "ERR(\"Failed to open tcp connection\");"
    },
    {
        "line": 68,
        "fullcodeline": "ERR(\"Failed to spawn thread, error %d\", status);"
    },
    {
        "line": 78,
        "fullcodeline": "free(args);"
    },
    {
        "line": 76,
        "fullcodeline": "if (args->tcp != NULL)"
    },
    {
        "line": 77,
        "fullcodeline": "tcp_conn_close(args->tcp);"
    }
]