[
    {
        "line": 5,
        "fullcodeline": "char buf[OGS_ADDRSTRLEN];"
    },
    {
        "line": 7,
        "fullcodeline": "sgwu_sess_t *sess = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "ogs_pkbuf_t *pkbuf = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "ogs_gtp_header_t *gtp_h = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "ogs_assert(fd != INVALID_SOCKET);"
    },
    {
        "line": 20,
        "fullcodeline": "pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN);"
    },
    {
        "line": 21,
        "fullcodeline": "ogs_assert(pkbuf);"
    },
    {
        "line": 22,
        "fullcodeline": "ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN);"
    },
    {
        "line": 24,
        "fullcodeline": "size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);"
    },
    {
        "line": 31,
        "fullcodeline": "ogs_pkbuf_trim(pkbuf, size);"
    },
    {
        "line": 33,
        "fullcodeline": "ogs_assert(pkbuf);"
    },
    {
        "line": 34,
        "fullcodeline": "ogs_assert(pkbuf->len);"
    },
    {
        "line": 36,
        "fullcodeline": "gtp_h = (ogs_gtp_header_t *)pkbuf->data;"
    },
    {
        "line": 65,
        "fullcodeline": "teid = be32toh(gtp_h->teid);"
    },
    {
        "line": 67,
        "fullcodeline": "ogs_debug(\"[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]\","
    },
    {
        "line": 70,
        "fullcodeline": "qfi = 0;"
    },
    {
        "line": 95,
        "fullcodeline": "len = ogs_gtpu_header_len(pkbuf);"
    },
    {
        "line": 107,
        "fullcodeline": "ogs_assert(ogs_pkbuf_pull(pkbuf, len));"
    },
    {
        "line": 211,
        "fullcodeline": "ogs_pkbuf_free(pkbuf);"
    },
    {
        "line": 25,
        "fullcodeline": "if (size <= 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (gtp_h->version != OGS_GTP_VERSION_1) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {"
    },
    {
        "line": 68,
        "fullcodeline": "gtp_h->type, OGS_ADDR(&from, buf), teid);"
    },
    {
        "line": 71,
        "fullcodeline": "if (gtp_h->flags & OGS_GTPU_FLAGS_E) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (len < 0) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (gtp_h->type != OGS_GTPU_MSGTYPE_END_MARKER &&"
    },
    {
        "line": 109,
        "fullcodeline": "if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {"
    },
    {
        "line": 26,
        "fullcodeline": "ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,"
    },
    {
        "line": 38,
        "fullcodeline": "ogs_error(\"[DROP] Invalid GTPU version [%d]\", gtp_h->version);"
    },
    {
        "line": 39,
        "fullcodeline": "ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);"
    },
    {
        "line": 46,
        "fullcodeline": "ogs_debug(\"[RECV] Echo Request from [%s]\", OGS_ADDR(&from, buf));"
    },
    {
        "line": 47,
        "fullcodeline": "echo_rsp = ogs_gtp_handle_echo_req(pkbuf);"
    },
    {
        "line": 48,
        "fullcodeline": "ogs_expect(echo_rsp);"
    },
    {
        "line": 80,
        "fullcodeline": "ogs_gtp_extension_header_t *extension_header ="
    },
    {
        "line": 82,
        "fullcodeline": "ogs_assert(extension_header);"
    },
    {
        "line": 97,
        "fullcodeline": "ogs_error(\"[DROP] Cannot decode GTPU packet\");"
    },
    {
        "line": 98,
        "fullcodeline": "ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);"
    },
    {
        "line": 102,
        "fullcodeline": "pkbuf->len <= len) {"
    },
    {
        "line": 103,
        "fullcodeline": "ogs_error(\"[DROP] Small GTPU packet(type:%d len:%d)\", gtp_h->type, len);"
    },
    {
        "line": 104,
        "fullcodeline": "ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);"
    },
    {
        "line": 81,
        "fullcodeline": "(ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);"
    },
    {
        "line": 83,
        "fullcodeline": "if (extension_header->type =="
    },
    {
        "line": 53,
        "fullcodeline": "ogs_debug(\"[SEND] Echo Response to [%s]\", OGS_ADDR(&from, buf));"
    },
    {
        "line": 55,
        "fullcodeline": "sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);"
    },
    {
        "line": 60,
        "fullcodeline": "ogs_pkbuf_free(echo_rsp);"
    },
    {
        "line": 112,
        "fullcodeline": "} else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (sent < 0 || sent != echo_rsp->len) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (extension_header->pdu_type =="
    },
    {
        "line": 113,
        "fullcodeline": "ogs_pfcp_far_t *far = NULL;"
    },
    {
        "line": 115,
        "fullcodeline": "far = ogs_pfcp_far_find_by_error_indication(pkbuf);"
    },
    {
        "line": 57,
        "fullcodeline": "ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,"
    },
    {
        "line": 87,
        "fullcodeline": "ogs_debug(\"   QFI [0x%x]\","
    },
    {
        "line": 89,
        "fullcodeline": "qfi = extension_header->qos_flow_identifier;"
    },
    {
        "line": 117,
        "fullcodeline": "ogs_assert(true =="
    },
    {
        "line": 133,
        "fullcodeline": "} else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {"
    },
    {
        "line": 130,
        "fullcodeline": "ogs_error(\"[DROP] Cannot find FAR by Error-Indication\");"
    },
    {
        "line": 131,
        "fullcodeline": "ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);"
    },
    {
        "line": 134,
        "fullcodeline": "struct ip *ip_h = NULL;"
    },
    {
        "line": 135,
        "fullcodeline": "ogs_pfcp_object_t *pfcp_object = NULL;"
    },
    {
        "line": 136,
        "fullcodeline": "ogs_pfcp_sess_t *pfcp_sess = NULL;"
    },
    {
        "line": 137,
        "fullcodeline": "ogs_pfcp_pdr_t *pdr = NULL;"
    },
    {
        "line": 139,
        "fullcodeline": "ip_h = (struct ip *)pkbuf->data;"
    },
    {
        "line": 140,
        "fullcodeline": "ogs_assert(ip_h);"
    },
    {
        "line": 142,
        "fullcodeline": "pfcp_object = ogs_pfcp_object_find_by_teid(teid);"
    },
    {
        "line": 190,
        "fullcodeline": "ogs_assert(pdr);"
    },
    {
        "line": 191,
        "fullcodeline": "ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));"
    },
    {
        "line": 118,
        "fullcodeline": "ogs_pfcp_up_handle_error_indication(far, &report));"
    },
    {
        "line": 121,
        "fullcodeline": "ogs_assert(far->sess);"
    },
    {
        "line": 122,
        "fullcodeline": "sess = SGWU_SESS(far->sess);"
    },
    {
        "line": 123,
        "fullcodeline": "ogs_assert(sess);"
    },
    {
        "line": 125,
        "fullcodeline": "ogs_assert(OGS_OK =="
    },
    {
        "line": 143,
        "fullcodeline": "if (!pfcp_object) {"
    },
    {
        "line": 206,
        "fullcodeline": "ogs_error(\"[DROP] Invalid GTPU Type [%d]\", gtp_h->type);"
    },
    {
        "line": 207,
        "fullcodeline": "ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);"
    },
    {
        "line": 150,
        "fullcodeline": "pdr = (ogs_pfcp_pdr_t *)pfcp_object;"
    },
    {
        "line": 151,
        "fullcodeline": "ogs_assert(pdr);"
    },
    {
        "line": 154,
        "fullcodeline": "pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;"
    },
    {
        "line": 155,
        "fullcodeline": "ogs_assert(pfcp_sess);"
    },
    {
        "line": 157,
        "fullcodeline": "ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {"
    },
    {
        "line": 186,
        "fullcodeline": "ogs_fatal(\"Unknown type [%d]\", pfcp_object->type);"
    },
    {
        "line": 187,
        "fullcodeline": "ogs_assert_if_reached();"
    },
    {
        "line": 194,
        "fullcodeline": "ogs_assert(pdr->sess);"
    },
    {
        "line": 195,
        "fullcodeline": "ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);"
    },
    {
        "line": 196,
        "fullcodeline": "sess = SGWU_SESS(pdr->sess);"
    },
    {
        "line": 197,
        "fullcodeline": "ogs_assert(sess);"
    },
    {
        "line": 199,
        "fullcodeline": "report.downlink_data.pdr_id = pdr->id;"
    },
    {
        "line": 200,
        "fullcodeline": "report.downlink_data.qfi = qfi; /* for 5GC */"
    },
    {
        "line": 202,
        "fullcodeline": "ogs_assert(OGS_OK =="
    },
    {
        "line": 126,
        "fullcodeline": "sgwu_pfcp_send_session_report_request(sess, &report));"
    },
    {
        "line": 159,
        "fullcodeline": "if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&"
    },
    {
        "line": 164,
        "fullcodeline": "if (teid != pdr->f_teid.teid)"
    },
    {
        "line": 168,
        "fullcodeline": "if (qfi && pdr->qfi != qfi)"
    },
    {
        "line": 172,
        "fullcodeline": "if (ogs_list_first(&pdr->rule_list) &&"
    },
    {
        "line": 203,
        "fullcodeline": "sgwu_pfcp_send_session_report_request(sess, &report));"
    },
    {
        "line": 160,
        "fullcodeline": "pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)"
    },
    {
        "line": 173,
        "fullcodeline": "ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)"
    }
]