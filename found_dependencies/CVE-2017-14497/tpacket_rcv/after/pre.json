[
    {
        "line": 8,
        "fullcodeline": "u8 *skb_head = skb->data;"
    },
    {
        "line": 9,
        "fullcodeline": "int skb_len = skb->len;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned long status = TP_STATUS_USER;"
    },
    {
        "line": 13,
        "fullcodeline": "struct sk_buff *copy_skb = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "bool is_drop_n_account = false;"
    },
    {
        "line": 17,
        "fullcodeline": "bool do_vnet = false;"
    },
    {
        "line": 23,
        "fullcodeline": "BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);"
    },
    {
        "line": 24,
        "fullcodeline": "BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);"
    },
    {
        "line": 29,
        "fullcodeline": "sk = pt->af_packet_priv;"
    },
    {
        "line": 30,
        "fullcodeline": "po = pkt_sk(sk);"
    },
    {
        "line": 44,
        "fullcodeline": "snaplen = skb->len;"
    },
    {
        "line": 46,
        "fullcodeline": "res = run_filter(skb, sk, snaplen);"
    },
    {
        "line": 107,
        "fullcodeline": "spin_lock(&sk->sk_receive_queue.lock);"
    },
    {
        "line": 108,
        "fullcodeline": "h.raw = packet_current_rx_frame(po, skb,"
    },
    {
        "line": 123,
        "fullcodeline": "po->stats.stats1.tp_packets++;"
    },
    {
        "line": 128,
        "fullcodeline": "spin_unlock(&sk->sk_receive_queue.lock);"
    },
    {
        "line": 139,
        "fullcodeline": "skb_copy_bits(skb, 0, h.raw + macoff, snaplen);"
    },
    {
        "line": 144,
        "fullcodeline": "status |= ts_status;"
    },
    {
        "line": 192,
        "fullcodeline": "sll = h.raw + TPACKET_ALIGN(hdrlen);"
    },
    {
        "line": 193,
        "fullcodeline": "sll->sll_halen = dev_parse_header(skb, sll->sll_addr);"
    },
    {
        "line": 194,
        "fullcodeline": "sll->sll_family = AF_PACKET;"
    },
    {
        "line": 195,
        "fullcodeline": "sll->sll_hatype = dev->type;"
    },
    {
        "line": 196,
        "fullcodeline": "sll->sll_protocol = skb->protocol;"
    },
    {
        "line": 197,
        "fullcodeline": "sll->sll_pkttype = skb->pkt_type;"
    },
    {
        "line": 203,
        "fullcodeline": "smp_mb();"
    },
    {
        "line": 238,
        "fullcodeline": "is_drop_n_account = true;"
    },
    {
        "line": 239,
        "fullcodeline": "po->stats.stats1.tp_drops++;"
    },
    {
        "line": 240,
        "fullcodeline": "spin_unlock(&sk->sk_receive_queue.lock);"
    },
    {
        "line": 242,
        "fullcodeline": "sk->sk_data_ready(sk);"
    },
    {
        "line": 243,
        "fullcodeline": "kfree_skb(copy_skb);"
    },
    {
        "line": 26,
        "fullcodeline": "if (skb->pkt_type == PACKET_LOOPBACK)"
    },
    {
        "line": 32,
        "fullcodeline": "if (!net_eq(dev_net(dev), sock_net(sk)))"
    },
    {
        "line": 47,
        "fullcodeline": "if (!res)"
    },
    {
        "line": 50,
        "fullcodeline": "if (skb->ip_summed == CHECKSUM_PARTIAL)"
    },
    {
        "line": 57,
        "fullcodeline": "if (snaplen > res)"
    },
    {
        "line": 60,
        "fullcodeline": "if (sk->sk_type == SOCK_DGRAM) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (po->tp_version <= TPACKET_V2) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (!h.raw)"
    },
    {
        "line": 112,
        "fullcodeline": "if (po->tp_version <= TPACKET_V2) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))"
    },
    {
        "line": 198,
        "fullcodeline": "if (unlikely(po->origdev))"
    },
    {
        "line": 218,
        "fullcodeline": "if (po->tp_version <= TPACKET_V2) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (skb_head != skb->data && skb_shared(skb)) {"
    },
    {
        "line": 231,
        "fullcodeline": "if (!is_drop_n_account)"
    },
    {
        "line": 51,
        "fullcodeline": "status |= TP_STATUS_CSUMNOTREADY;"
    },
    {
        "line": 58,
        "fullcodeline": "snaplen = res;"
    },
    {
        "line": 61,
        "fullcodeline": "macoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +"
    },
    {
        "line": 109,
        "fullcodeline": "TP_STATUS_KERNEL, (macoff+snaplen));"
    },
    {
        "line": 113,
        "fullcodeline": "packet_increment_rx_head(po, &po->rx_ring);"
    },
    {
        "line": 125,
        "fullcodeline": "status |= TP_STATUS_COPY;"
    },
    {
        "line": 126,
        "fullcodeline": "__skb_queue_tail(&sk->sk_receive_queue, copy_skb);"
    },
    {
        "line": 142,
        "fullcodeline": "getnstimeofday(&ts);"
    },
    {
        "line": 148,
        "fullcodeline": "h.h1->tp_len = skb->len;"
    },
    {
        "line": 149,
        "fullcodeline": "h.h1->tp_snaplen = snaplen;"
    },
    {
        "line": 150,
        "fullcodeline": "h.h1->tp_mac = macoff;"
    },
    {
        "line": 151,
        "fullcodeline": "h.h1->tp_net = netoff;"
    },
    {
        "line": 152,
        "fullcodeline": "h.h1->tp_sec = ts.tv_sec;"
    },
    {
        "line": 153,
        "fullcodeline": "h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;"
    },
    {
        "line": 154,
        "fullcodeline": "hdrlen = sizeof(*h.h1);"
    },
    {
        "line": 157,
        "fullcodeline": "h.h2->tp_len = skb->len;"
    },
    {
        "line": 158,
        "fullcodeline": "h.h2->tp_snaplen = snaplen;"
    },
    {
        "line": 159,
        "fullcodeline": "h.h2->tp_mac = macoff;"
    },
    {
        "line": 160,
        "fullcodeline": "h.h2->tp_net = netoff;"
    },
    {
        "line": 161,
        "fullcodeline": "h.h2->tp_sec = ts.tv_sec;"
    },
    {
        "line": 162,
        "fullcodeline": "h.h2->tp_nsec = ts.tv_nsec;"
    },
    {
        "line": 171,
        "fullcodeline": "memset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));"
    },
    {
        "line": 172,
        "fullcodeline": "hdrlen = sizeof(*h.h2);"
    },
    {
        "line": 178,
        "fullcodeline": "h.h3->tp_status |= status;"
    },
    {
        "line": 179,
        "fullcodeline": "h.h3->tp_len = skb->len;"
    },
    {
        "line": 180,
        "fullcodeline": "h.h3->tp_snaplen = snaplen;"
    },
    {
        "line": 181,
        "fullcodeline": "h.h3->tp_mac = macoff;"
    },
    {
        "line": 182,
        "fullcodeline": "h.h3->tp_net = netoff;"
    },
    {
        "line": 183,
        "fullcodeline": "h.h3->tp_sec  = ts.tv_sec;"
    },
    {
        "line": 184,
        "fullcodeline": "h.h3->tp_nsec = ts.tv_nsec;"
    },
    {
        "line": 185,
        "fullcodeline": "memset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));"
    },
    {
        "line": 186,
        "fullcodeline": "hdrlen = sizeof(*h.h3);"
    },
    {
        "line": 189,
        "fullcodeline": "BUG();"
    },
    {
        "line": 199,
        "fullcodeline": "sll->sll_ifindex = orig_dev->ifindex;"
    },
    {
        "line": 219,
        "fullcodeline": "__packet_set_status(po, h.raw, status);"
    },
    {
        "line": 220,
        "fullcodeline": "sk->sk_data_ready(sk);"
    },
    {
        "line": 227,
        "fullcodeline": "skb->data = skb_head;"
    },
    {
        "line": 228,
        "fullcodeline": "skb->len = skb_len;"
    },
    {
        "line": 232,
        "fullcodeline": "consume_skb(skb);"
    },
    {
        "line": 36,
        "fullcodeline": "if (sk->sk_type != SOCK_DGRAM)"
    },
    {
        "line": 64,
        "fullcodeline": "unsigned int maclen = skb_network_offset(skb);"
    },
    {
        "line": 65,
        "fullcodeline": "netoff = TPACKET_ALIGN(po->tp_hdrlen +"
    },
    {
        "line": 72,
        "fullcodeline": "macoff = netoff - maclen;"
    },
    {
        "line": 75,
        "fullcodeline": "if (macoff + snaplen > po->rx_ring.frame_size) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (virtio_net_hdr_from_skb(skb, h.raw + macoff -"
    },
    {
        "line": 163,
        "fullcodeline": "if (skb_vlan_tag_present(skb)) {"
    },
    {
        "line": 201,
        "fullcodeline": "sll->sll_ifindex = dev->ifindex;"
    },
    {
        "line": 222,
        "fullcodeline": "prb_clear_blk_fill_status(&po->rx_ring);"
    },
    {
        "line": 234,
        "fullcodeline": "kfree_skb(skb);"
    },
    {
        "line": 37,
        "fullcodeline": "skb_push(skb, skb->data - skb_mac_header(skb));"
    },
    {
        "line": 52,
        "fullcodeline": "else if (skb->pkt_type != PACKET_OUTGOING &&"
    },
    {
        "line": 87,
        "fullcodeline": "snaplen = po->rx_ring.frame_size - macoff;"
    },
    {
        "line": 93,
        "fullcodeline": "} else if (unlikely(macoff + snaplen >"
    },
    {
        "line": 121,
        "fullcodeline": "status |= TP_STATUS_LOSING;"
    },
    {
        "line": 134,
        "fullcodeline": "spin_lock(&sk->sk_receive_queue.lock);"
    },
    {
        "line": 164,
        "fullcodeline": "h.h2->tp_vlan_tci = skb_vlan_tag_get(skb);"
    },
    {
        "line": 165,
        "fullcodeline": "h.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);"
    },
    {
        "line": 166,
        "fullcodeline": "status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;"
    },
    {
        "line": 53,
        "fullcodeline": "(skb->ip_summed == CHECKSUM_COMPLETE ||"
    },
    {
        "line": 55,
        "fullcodeline": "status |= TP_STATUS_CSUM_VALID;"
    },
    {
        "line": 69,
        "fullcodeline": "netoff += sizeof(struct virtio_net_hdr);"
    },
    {
        "line": 70,
        "fullcodeline": "do_vnet = true;"
    },
    {
        "line": 76,
        "fullcodeline": "if (po->copy_thresh &&"
    },
    {
        "line": 88,
        "fullcodeline": "if ((int)snaplen < 0) {"
    },
    {
        "line": 97,
        "fullcodeline": "nval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;"
    },
    {
        "line": 98,
        "fullcodeline": "pr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\","
    },
    {
        "line": 100,
        "fullcodeline": "snaplen = nval;"
    },
    {
        "line": 132,
        "fullcodeline": "sizeof(struct virtio_net_hdr),"
    },
    {
        "line": 168,
        "fullcodeline": "h.h2->tp_vlan_tci = 0;"
    },
    {
        "line": 169,
        "fullcodeline": "h.h2->tp_vlan_tpid = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "else if (skb->pkt_type == PACKET_OUTGOING) {"
    },
    {
        "line": 54,
        "fullcodeline": "skb_csum_unnecessary(skb)))"
    },
    {
        "line": 77,
        "fullcodeline": "atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {"
    },
    {
        "line": 89,
        "fullcodeline": "snaplen = 0;"
    },
    {
        "line": 90,
        "fullcodeline": "do_vnet = false;"
    },
    {
        "line": 101,
        "fullcodeline": "if (unlikely((int)snaplen < 0)) {"
    },
    {
        "line": 40,
        "fullcodeline": "skb_pull(skb, skb_network_offset(skb));"
    },
    {
        "line": 66,
        "fullcodeline": "(maclen < 16 ? 16 : maclen)) +"
    },
    {
        "line": 78,
        "fullcodeline": "if (skb_shared(skb)) {"
    },
    {
        "line": 94,
        "fullcodeline": "GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {"
    },
    {
        "line": 102,
        "fullcodeline": "snaplen = 0;"
    },
    {
        "line": 103,
        "fullcodeline": "macoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;"
    },
    {
        "line": 104,
        "fullcodeline": "do_vnet = false;"
    },
    {
        "line": 79,
        "fullcodeline": "copy_skb = skb_clone(skb, GFP_ATOMIC);"
    },
    {
        "line": 85,
        "fullcodeline": "skb_set_owner_r(copy_skb, sk);"
    },
    {
        "line": 81,
        "fullcodeline": "copy_skb = skb_get(skb);"
    },
    {
        "line": 82,
        "fullcodeline": "skb_head = skb->data;"
    }
]