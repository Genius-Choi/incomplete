[
    {
        "line": 3,
        "fullcodeline": "int\t\t\t copyback = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "action = PF_PASS;"
    },
    {
        "line": 10,
        "fullcodeline": "if (pd->dir == (*stp)->direction) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (copyback && pd->hdrlen > 0) {"
    },
    {
        "line": 13,
        "fullcodeline": "psrc = PF_PEER_SRC;"
    },
    {
        "line": 14,
        "fullcodeline": "pdst = PF_PEER_DST;"
    },
    {
        "line": 74,
        "fullcodeline": "(*stp)->expire = getuptime();"
    },
    {
        "line": 89,
        "fullcodeline": "(*stp)->expire = getuptime();"
    },
    {
        "line": 108,
        "fullcodeline": "afto = pd->af != nk->af;"
    },
    {
        "line": 109,
        "fullcodeline": "sidx = afto ? pd->didx : pd->sidx;"
    },
    {
        "line": 110,
        "fullcodeline": "didx = afto ? pd->sidx : pd->didx;"
    },
    {
        "line": 137,
        "fullcodeline": "pd->m->m_pkthdr.ph_rtableid = nk->rdomain;"
    },
    {
        "line": 138,
        "fullcodeline": "copyback = 1;"
    },
    {
        "line": 142,
        "fullcodeline": "m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);"
    },
    {
        "line": 18,
        "fullcodeline": "psrc = PF_PEER_DST;"
    },
    {
        "line": 19,
        "fullcodeline": "pdst = PF_PEER_SRC;"
    },
    {
        "line": 24,
        "fullcodeline": "if ((action = pf_synproxy(pd, stp, reason)) != PF_PASS)"
    },
    {
        "line": 26,
        "fullcodeline": "if ((pd->hdr.tcp.th_flags & (TH_SYN|TH_ACK)) == TH_SYN) {"
    },
    {
        "line": 57,
        "fullcodeline": "if ((*stp)->state_flags & PFSTATE_SLOPPY) {"
    },
    {
        "line": 68,
        "fullcodeline": "if (src->state < PFUDPS_SINGLE)"
    },
    {
        "line": 70,
        "fullcodeline": "if (dst->state == PFUDPS_SINGLE)"
    },
    {
        "line": 75,
        "fullcodeline": "if (src->state == PFUDPS_MULTIPLE &&"
    },
    {
        "line": 83,
        "fullcodeline": "if (src->state < PFOTHERS_SINGLE)"
    },
    {
        "line": 85,
        "fullcodeline": "if (dst->state == PFOTHERS_SINGLE)"
    },
    {
        "line": 90,
        "fullcodeline": "if (src->state == PFOTHERS_MULTIPLE &&"
    },
    {
        "line": 103,
        "fullcodeline": "if (PF_REVERSED_KEY((*stp)->key, pd->af))"
    },
    {
        "line": 121,
        "fullcodeline": "if (!afto)"
    },
    {
        "line": 124,
        "fullcodeline": "if (pd->sport != NULL)"
    },
    {
        "line": 127,
        "fullcodeline": "if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||"
    },
    {
        "line": 131,
        "fullcodeline": "if (!afto)"
    },
    {
        "line": 134,
        "fullcodeline": "if (pd->dport != NULL)"
    },
    {
        "line": 69,
        "fullcodeline": "pf_set_protostate(*stp, psrc, PFUDPS_SINGLE);"
    },
    {
        "line": 71,
        "fullcodeline": "pf_set_protostate(*stp, pdst, PFUDPS_MULTIPLE);"
    },
    {
        "line": 76,
        "fullcodeline": "dst->state == PFUDPS_MULTIPLE)"
    },
    {
        "line": 77,
        "fullcodeline": "(*stp)->timeout = PFTM_UDP_MULTIPLE;"
    },
    {
        "line": 84,
        "fullcodeline": "pf_set_protostate(*stp, psrc, PFOTHERS_SINGLE);"
    },
    {
        "line": 86,
        "fullcodeline": "pf_set_protostate(*stp, pdst, PFOTHERS_MULTIPLE);"
    },
    {
        "line": 91,
        "fullcodeline": "dst->state == PFOTHERS_MULTIPLE)"
    },
    {
        "line": 92,
        "fullcodeline": "(*stp)->timeout = PFTM_OTHER_MULTIPLE;"
    },
    {
        "line": 122,
        "fullcodeline": "pf_translate_a(pd, pd->src, &nk->addr[sidx]);"
    },
    {
        "line": 125,
        "fullcodeline": "pf_patch_16(pd, pd->sport, nk->port[sidx]);"
    },
    {
        "line": 128,
        "fullcodeline": "pd->rdomain != nk->rdomain)"
    },
    {
        "line": 129,
        "fullcodeline": "pd->destchg = 1;"
    },
    {
        "line": 132,
        "fullcodeline": "pf_translate_a(pd, pd->dst, &nk->addr[didx]);"
    },
    {
        "line": 135,
        "fullcodeline": "pf_patch_16(pd, pd->dport, nk->port[didx]);"
    },
    {
        "line": 28,
        "fullcodeline": "if (dst->state >= TCPS_FIN_WAIT_2 &&"
    },
    {
        "line": 58,
        "fullcodeline": "if (pf_tcp_track_sloppy(pd, stp, reason) == PF_DROP)"
    },
    {
        "line": 79,
        "fullcodeline": "(*stp)->timeout = PFTM_UDP_SINGLE;"
    },
    {
        "line": 94,
        "fullcodeline": "(*stp)->timeout = PFTM_OTHER_SINGLE;"
    },
    {
        "line": 29,
        "fullcodeline": "src->state >= TCPS_FIN_WAIT_2) {"
    },
    {
        "line": 37,
        "fullcodeline": "(*stp)->timeout = PFTM_PURGE;"
    },
    {
        "line": 38,
        "fullcodeline": "pf_state_unref(*stp);"
    },
    {
        "line": 39,
        "fullcodeline": "*stp = NULL;"
    },
    {
        "line": 40,
        "fullcodeline": "pf_mbuf_link_inpcb(pd->m, inp);"
    },
    {
        "line": 61,
        "fullcodeline": "if (pf_tcp_track_full(pd, stp, reason, &copyback,"
    },
    {
        "line": 30,
        "fullcodeline": "if (pf_status.debug >= LOG_NOTICE) {"
    },
    {
        "line": 31,
        "fullcodeline": "log(LOG_NOTICE, \"pf: state reuse \");"
    },
    {
        "line": 32,
        "fullcodeline": "pf_print_state(*stp);"
    },
    {
        "line": 33,
        "fullcodeline": "pf_print_flags(pd->hdr.tcp.th_flags);"
    },
    {
        "line": 34,
        "fullcodeline": "addlog(\"\\n\");"
    },
    {
        "line": 42,
        "fullcodeline": "} else if (dst->state >= TCPS_ESTABLISHED &&"
    },
    {
        "line": 62,
        "fullcodeline": "PF_REVERSED_KEY((*stp)->key, pd->af)) == PF_DROP)"
    },
    {
        "line": 43,
        "fullcodeline": "src->state >= TCPS_ESTABLISHED) {"
    },
    {
        "line": 52,
        "fullcodeline": "pf_send_challenge_ack(pd, *stp, src, dst);"
    }
]