[
    {
        "line": 3,
        "fullcodeline": "int\t\t\t copyback = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "struct inpcb\t\t*inp = pd->m->m_pkthdr.pf.inp;"
    },
    {
        "line": 9,
        "fullcodeline": "action = PF_PASS;"
    },
    {
        "line": 10,
        "fullcodeline": "if (pd->dir == (*stp)->direction) {"
    },
    {
        "line": 99,
        "fullcodeline": "if ((*stp)->key[PF_SK_WIRE] != (*stp)->key[PF_SK_STACK]) {"
    },
    {
        "line": 11,
        "fullcodeline": "src = &(*stp)->src;"
    },
    {
        "line": 12,
        "fullcodeline": "dst = &(*stp)->dst;"
    },
    {
        "line": 13,
        "fullcodeline": "psrc = PF_PEER_SRC;"
    },
    {
        "line": 14,
        "fullcodeline": "pdst = PF_PEER_DST;"
    },
    {
        "line": 74,
        "fullcodeline": "(*stp)->expire = getuptime();"
    },
    {
        "line": 89,
        "fullcodeline": "(*stp)->expire = getuptime();"
    },
    {
        "line": 138,
        "fullcodeline": "copyback = 1;"
    },
    {
        "line": 141,
        "fullcodeline": "if (copyback && pd->hdrlen > 0) {"
    },
    {
        "line": 142,
        "fullcodeline": "m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);"
    },
    {
        "line": 16,
        "fullcodeline": "src = &(*stp)->dst;"
    },
    {
        "line": 17,
        "fullcodeline": "dst = &(*stp)->src;"
    },
    {
        "line": 18,
        "fullcodeline": "psrc = PF_PEER_DST;"
    },
    {
        "line": 19,
        "fullcodeline": "pdst = PF_PEER_SRC;"
    },
    {
        "line": 24,
        "fullcodeline": "if ((action = pf_synproxy(pd, stp, reason)) != PF_PASS)"
    },
    {
        "line": 57,
        "fullcodeline": "if ((*stp)->state_flags & PFSTATE_SLOPPY) {"
    },
    {
        "line": 68,
        "fullcodeline": "if (src->state < PFUDPS_SINGLE)"
    },
    {
        "line": 70,
        "fullcodeline": "if (dst->state == PFUDPS_SINGLE)"
    },
    {
        "line": 83,
        "fullcodeline": "if (src->state < PFOTHERS_SINGLE)"
    },
    {
        "line": 85,
        "fullcodeline": "if (dst->state == PFOTHERS_SINGLE)"
    },
    {
        "line": 103,
        "fullcodeline": "if (PF_REVERSED_KEY((*stp)->key, pd->af))"
    },
    {
        "line": 108,
        "fullcodeline": "afto = pd->af != nk->af;"
    },
    {
        "line": 121,
        "fullcodeline": "if (!afto)"
    },
    {
        "line": 124,
        "fullcodeline": "if (pd->sport != NULL)"
    },
    {
        "line": 134,
        "fullcodeline": "if (pd->dport != NULL)"
    },
    {
        "line": 26,
        "fullcodeline": "if ((pd->hdr.tcp.th_flags & (TH_SYN|TH_ACK)) == TH_SYN) {"
    },
    {
        "line": 69,
        "fullcodeline": "pf_set_protostate(*stp, psrc, PFUDPS_SINGLE);"
    },
    {
        "line": 71,
        "fullcodeline": "pf_set_protostate(*stp, pdst, PFUDPS_MULTIPLE);"
    },
    {
        "line": 75,
        "fullcodeline": "if (src->state == PFUDPS_MULTIPLE &&"
    },
    {
        "line": 76,
        "fullcodeline": "dst->state == PFUDPS_MULTIPLE)"
    },
    {
        "line": 77,
        "fullcodeline": "pf_update_state_timeout(*stp, PFTM_UDP_MULTIPLE);"
    },
    {
        "line": 84,
        "fullcodeline": "pf_set_protostate(*stp, psrc, PFOTHERS_SINGLE);"
    },
    {
        "line": 86,
        "fullcodeline": "pf_set_protostate(*stp, pdst, PFOTHERS_MULTIPLE);"
    },
    {
        "line": 90,
        "fullcodeline": "if (src->state == PFOTHERS_MULTIPLE &&"
    },
    {
        "line": 91,
        "fullcodeline": "dst->state == PFOTHERS_MULTIPLE)"
    },
    {
        "line": 92,
        "fullcodeline": "pf_update_state_timeout(*stp, PFTM_OTHER_MULTIPLE);"
    },
    {
        "line": 104,
        "fullcodeline": "nk = (*stp)->key[pd->sidx];"
    },
    {
        "line": 122,
        "fullcodeline": "pf_translate_a(pd, pd->src, &nk->addr[sidx]);"
    },
    {
        "line": 125,
        "fullcodeline": "pf_patch_16(pd, pd->sport, nk->port[sidx]);"
    },
    {
        "line": 127,
        "fullcodeline": "if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||"
    },
    {
        "line": 128,
        "fullcodeline": "pd->rdomain != nk->rdomain)"
    },
    {
        "line": 129,
        "fullcodeline": "pd->destchg = 1;"
    },
    {
        "line": 132,
        "fullcodeline": "pf_translate_a(pd, pd->dst, &nk->addr[didx]);"
    },
    {
        "line": 135,
        "fullcodeline": "pf_patch_16(pd, pd->dport, nk->port[didx]);"
    },
    {
        "line": 58,
        "fullcodeline": "if (pf_tcp_track_sloppy(pd, stp, reason) == PF_DROP)"
    },
    {
        "line": 79,
        "fullcodeline": "pf_update_state_timeout(*stp, PFTM_UDP_SINGLE);"
    },
    {
        "line": 94,
        "fullcodeline": "pf_update_state_timeout(*stp, PFTM_OTHER_SINGLE);"
    },
    {
        "line": 106,
        "fullcodeline": "nk = (*stp)->key[pd->didx];"
    },
    {
        "line": 28,
        "fullcodeline": "if (dst->state >= TCPS_FIN_WAIT_2 &&"
    },
    {
        "line": 29,
        "fullcodeline": "src->state >= TCPS_FIN_WAIT_2) {"
    },
    {
        "line": 37,
        "fullcodeline": "pf_update_state_timeout(*stp, PFTM_PURGE);"
    },
    {
        "line": 61,
        "fullcodeline": "if (pf_tcp_track_full(pd, stp, reason, &copyback,"
    },
    {
        "line": 30,
        "fullcodeline": "if (pf_status.debug >= LOG_NOTICE) {"
    },
    {
        "line": 32,
        "fullcodeline": "pf_print_state(*stp);"
    },
    {
        "line": 62,
        "fullcodeline": "PF_REVERSED_KEY((*stp)->key, pd->af)) == PF_DROP)"
    },
    {
        "line": 42,
        "fullcodeline": "} else if (dst->state >= TCPS_ESTABLISHED &&"
    },
    {
        "line": 43,
        "fullcodeline": "src->state >= TCPS_ESTABLISHED) {"
    }
]