[
    {
        "line": 3,
        "fullcodeline": "int\t\t\t bad = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "sn->conn++;"
    },
    {
        "line": 10,
        "fullcodeline": "(*stp)->src.tcp_est = 1;"
    },
    {
        "line": 11,
        "fullcodeline": "pf_add_threshold(&sn->conn_rate);"
    },
    {
        "line": 94,
        "fullcodeline": "(*stp)->timeout = PFTM_PURGE;"
    },
    {
        "line": 95,
        "fullcodeline": "pf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);"
    },
    {
        "line": 6,
        "fullcodeline": "if ((sn = pf_get_src_node((*stp), PF_SN_NONE)) == NULL)"
    },
    {
        "line": 13,
        "fullcodeline": "if ((*stp)->rule.ptr->max_src_conn &&"
    },
    {
        "line": 19,
        "fullcodeline": "if ((*stp)->rule.ptr->max_src_conn_rate.limit &&"
    },
    {
        "line": 25,
        "fullcodeline": "if (!bad)"
    },
    {
        "line": 14,
        "fullcodeline": "(*stp)->rule.ptr->max_src_conn < sn->conn) {"
    },
    {
        "line": 16,
        "fullcodeline": "bad++;"
    },
    {
        "line": 20,
        "fullcodeline": "pf_check_threshold(&sn->conn_rate)) {"
    },
    {
        "line": 22,
        "fullcodeline": "bad++;"
    },
    {
        "line": 30,
        "fullcodeline": "u_int32_t\tkilled = 0;"
    },
    {
        "line": 40,
        "fullcodeline": "memset(&p, 0, sizeof(p));"
    },
    {
        "line": 41,
        "fullcodeline": "p.pfra_af = (*stp)->key[PF_SK_WIRE]->af;"
    },
    {
        "line": 55,
        "fullcodeline": "pfr_insert_kentry((*stp)->rule.ptr->overload_tbl,"
    },
    {
        "line": 33,
        "fullcodeline": "if (pf_status.debug >= LOG_NOTICE) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (pf_status.debug >= LOG_NOTICE)"
    },
    {
        "line": 34,
        "fullcodeline": "log(LOG_NOTICE,"
    },
    {
        "line": 36,
        "fullcodeline": "pf_print_host(&sn->addr, 0,"
    },
    {
        "line": 44,
        "fullcodeline": "p.pfra_net = 32;"
    },
    {
        "line": 64,
        "fullcodeline": "RBT_FOREACH(st, pf_state_tree_id, &tree_id) {"
    },
    {
        "line": 90,
        "fullcodeline": "addlog(\"\\n\");"
    },
    {
        "line": 86,
        "fullcodeline": "if (pf_status.debug >= LOG_NOTICE)"
    },
    {
        "line": 71,
        "fullcodeline": "if (sk->af =="
    },
    {
        "line": 87,
        "fullcodeline": "addlog(\", %u states killed\", killed);"
    },
    {
        "line": 77,
        "fullcodeline": "((*stp)->rule.ptr->flush &"
    },
    {
        "line": 80,
        "fullcodeline": "st->timeout = PFTM_PURGE;"
    },
    {
        "line": 81,
        "fullcodeline": "pf_set_protostate(st, PF_PEER_BOTH,"
    },
    {
        "line": 83,
        "fullcodeline": "killed++;"
    },
    {
        "line": 73,
        "fullcodeline": "(((*stp)->direction == PF_OUT &&"
    },
    {
        "line": 79,
        "fullcodeline": "(*stp)->rule.ptr == st->rule.ptr)) {"
    },
    {
        "line": 75,
        "fullcodeline": "((*stp)->direction == PF_IN &&"
    },
    {
        "line": 74,
        "fullcodeline": "PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||"
    },
    {
        "line": 76,
        "fullcodeline": "PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&"
    }
]