[
    {
        "line": 4,
        "fullcodeline": "struct vfio_pci_device *vdev = device_data;"
    },
    {
        "line": 7,
        "fullcodeline": "if (cmd == VFIO_DEVICE_GET_INFO) {"
    },
    {
        "line": 424,
        "fullcodeline": "return -ENOTTY;"
    },
    {
        "line": 18,
        "fullcodeline": "info.flags = VFIO_DEVICE_FLAGS_PCI;"
    },
    {
        "line": 23,
        "fullcodeline": "info.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;"
    },
    {
        "line": 24,
        "fullcodeline": "info.num_irqs = VFIO_PCI_NUM_IRQS;"
    },
    {
        "line": 15,
        "fullcodeline": "if (info.argsz < minsz)"
    },
    {
        "line": 21,
        "fullcodeline": "info.flags |= VFIO_DEVICE_FLAGS_RESET;"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {"
    },
    {
        "line": 13,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 16,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 30,
        "fullcodeline": "struct pci_dev *pdev = vdev->pdev;"
    },
    {
        "line": 32,
        "fullcodeline": "struct vfio_info_cap caps = { .buf = NULL, .size = 0 };"
    },
    {
        "line": 40,
        "fullcodeline": "if (info.argsz < minsz)"
    },
    {
        "line": 45,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 46,
        "fullcodeline": "info.size = pdev->cfg_size;"
    },
    {
        "line": 47,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ |"
    },
    {
        "line": 50,
        "fullcodeline": "case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:"
    },
    {
        "line": 51,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 52,
        "fullcodeline": "info.size = pci_resource_len(pdev, info.index);"
    },
    {
        "line": 58,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ |"
    },
    {
        "line": 104,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 105,
        "fullcodeline": "info.size = 0xc0000;"
    },
    {
        "line": 106,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ |"
    },
    {
        "line": 115,
        "fullcodeline": "i = info.index - VFIO_PCI_NUM_REGIONS;"
    },
    {
        "line": 117,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 121,
        "fullcodeline": "ret = region_type_cap(vdev, &caps,"
    },
    {
        "line": 129,
        "fullcodeline": "info.flags |= VFIO_REGION_INFO_FLAG_CAPS;"
    },
    {
        "line": 144,
        "fullcodeline": "kfree(caps.buf);"
    },
    {
        "line": 150,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {"
    },
    {
        "line": 38,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 41,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 53,
        "fullcodeline": "if (!info.size) {"
    },
    {
        "line": 75,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 76,
        "fullcodeline": "info.flags = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "info.size = pci_resource_len(pdev, info.index);"
    },
    {
        "line": 90,
        "fullcodeline": "io = pci_map_rom(pdev, &size);"
    },
    {
        "line": 95,
        "fullcodeline": "pci_unmap_rom(pdev, io);"
    },
    {
        "line": 97,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ;"
    },
    {
        "line": 101,
        "fullcodeline": "if (!vdev->has_vga)"
    },
    {
        "line": 111,
        "fullcodeline": "if (info.index >="
    },
    {
        "line": 130,
        "fullcodeline": "if (info.argsz < sizeof(info) + caps.size) {"
    },
    {
        "line": 173,
        "fullcodeline": "info.flags = VFIO_IRQ_INFO_EVENTFD;"
    },
    {
        "line": 175,
        "fullcodeline": "info.count = vfio_pci_get_irq_count(vdev, info.index);"
    },
    {
        "line": 54,
        "fullcodeline": "info.flags = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "info.flags |= VFIO_REGION_INFO_FLAG_MMAP;"
    },
    {
        "line": 80,
        "fullcodeline": "if (!info.size) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (!io || !size) {"
    },
    {
        "line": 112,
        "fullcodeline": "VFIO_PCI_NUM_REGIONS + vdev->num_regions)"
    },
    {
        "line": 131,
        "fullcodeline": "info.argsz = sizeof(info) + caps.size;"
    },
    {
        "line": 132,
        "fullcodeline": "info.cap_offset = 0;"
    },
    {
        "line": 158,
        "fullcodeline": "if (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)"
    },
    {
        "line": 177,
        "fullcodeline": "if (info.index == VFIO_PCI_INTX_IRQ_INDEX)"
    },
    {
        "line": 62,
        "fullcodeline": "if (info.index == vdev->msix_bar) {"
    },
    {
        "line": 92,
        "fullcodeline": "info.size = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 113,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 134,
        "fullcodeline": "vfio_info_cap_shift(&caps, sizeof(info));"
    },
    {
        "line": 162,
        "fullcodeline": "case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:"
    },
    {
        "line": 178,
        "fullcodeline": "info.flags |= (VFIO_IRQ_INFO_MASKABLE |"
    },
    {
        "line": 186,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_SET_IRQS) {"
    },
    {
        "line": 63,
        "fullcodeline": "ret = msix_sparse_mmap_cap(vdev, &caps);"
    },
    {
        "line": 82,
        "fullcodeline": "if (pdev->resource[PCI_ROM_RESOURCE].flags &"
    },
    {
        "line": 156,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 159,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 166,
        "fullcodeline": "if (pci_is_pcie(vdev->pdev))"
    },
    {
        "line": 170,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 181,
        "fullcodeline": "info.flags |= VFIO_IRQ_INFO_NORESIZE;"
    },
    {
        "line": 189,
        "fullcodeline": "u8 *data = NULL;"
    },
    {
        "line": 190,
        "fullcodeline": "int max, ret = 0;"
    },
    {
        "line": 203,
        "fullcodeline": "max = vfio_pci_get_irq_count(vdev, hdr.index);"
    },
    {
        "line": 231,
        "fullcodeline": "mutex_lock(&vdev->igate);"
    },
    {
        "line": 233,
        "fullcodeline": "ret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,"
    },
    {
        "line": 236,
        "fullcodeline": "mutex_unlock(&vdev->igate);"
    },
    {
        "line": 237,
        "fullcodeline": "kfree(data);"
    },
    {
        "line": 84,
        "fullcodeline": "info.size = 0x20000;"
    },
    {
        "line": 138,
        "fullcodeline": "kfree(caps.buf);"
    },
    {
        "line": 197,
        "fullcodeline": "if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||"
    },
    {
        "line": 204,
        "fullcodeline": "if (hdr.start >= max || hdr.start + hdr.count > max)"
    },
    {
        "line": 207,
        "fullcodeline": "switch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {"
    },
    {
        "line": 139,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 199,
        "fullcodeline": "hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |"
    },
    {
        "line": 209,
        "fullcodeline": "size = 0;"
    },
    {
        "line": 241,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_RESET) {"
    },
    {
        "line": 195,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 198,
        "fullcodeline": "hdr.count >= (U32_MAX - hdr.start) ||"
    },
    {
        "line": 201,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 205,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 218,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 222,
        "fullcodeline": "if (hdr.argsz - minsz < hdr.count * size)"
    },
    {
        "line": 227,
        "fullcodeline": "if (IS_ERR(data))"
    },
    {
        "line": 242,
        "fullcodeline": "return vdev->reset_works ?"
    },
    {
        "line": 223,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 228,
        "fullcodeline": "return PTR_ERR(data);"
    },
    {
        "line": 243,
        "fullcodeline": "pci_try_reset_function(vdev->pdev) : -EINVAL;"
    },
    {
        "line": 245,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {"
    },
    {
        "line": 247,
        "fullcodeline": "struct vfio_pci_fill_info fill = { 0 };"
    },
    {
        "line": 248,
        "fullcodeline": "struct vfio_pci_dependent_device *devices = NULL;"
    },
    {
        "line": 249,
        "fullcodeline": "bool slot = false;"
    },
    {
        "line": 250,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 260,
        "fullcodeline": "hdr.flags = 0;"
    },
    {
        "line": 269,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 275,
        "fullcodeline": "WARN_ON(!fill.max); /* Should always be at least one */"
    },
    {
        "line": 287,
        "fullcodeline": "devices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);"
    },
    {
        "line": 291,
        "fullcodeline": "fill.devices = devices;"
    },
    {
        "line": 293,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 315,
        "fullcodeline": "kfree(devices);"
    },
    {
        "line": 257,
        "fullcodeline": "if (hdr.argsz < minsz)"
    },
    {
        "line": 263,
        "fullcodeline": "if (!pci_probe_reset_slot(vdev->pdev->slot))"
    },
    {
        "line": 281,
        "fullcodeline": "if (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {"
    },
    {
        "line": 288,
        "fullcodeline": "if (!devices)"
    },
    {
        "line": 302,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 309,
        "fullcodeline": "if (!ret) {"
    },
    {
        "line": 264,
        "fullcodeline": "slot = true;"
    },
    {
        "line": 282,
        "fullcodeline": "ret = -ENOSPC;"
    },
    {
        "line": 283,
        "fullcodeline": "hdr.count = fill.max;"
    },
    {
        "line": 303,
        "fullcodeline": "hdr.count = fill.cur;"
    },
    {
        "line": 307,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 318,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {"
    },
    {
        "line": 255,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 258,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 289,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 323,
        "fullcodeline": "bool slot = false;"
    },
    {
        "line": 324,
        "fullcodeline": "int i, count = 0, ret = 0;"
    },
    {
        "line": 346,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 356,
        "fullcodeline": "group_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);"
    },
    {
        "line": 357,
        "fullcodeline": "groups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);"
    },
    {
        "line": 395,
        "fullcodeline": "kfree(group_fds);"
    },
    {
        "line": 401,
        "fullcodeline": "info.count = hdr.count;"
    },
    {
        "line": 402,
        "fullcodeline": "info.groups = groups;"
    },
    {
        "line": 408,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 420,
        "fullcodeline": "kfree(groups);"
    },
    {
        "line": 312,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 331,
        "fullcodeline": "if (hdr.argsz < minsz || hdr.flags)"
    },
    {
        "line": 335,
        "fullcodeline": "if (!pci_probe_reset_slot(vdev->pdev->slot))"
    },
    {
        "line": 353,
        "fullcodeline": "if (!hdr.count || hdr.count > count)"
    },
    {
        "line": 358,
        "fullcodeline": "if (!group_fds || !groups) {"
    },
    {
        "line": 376,
        "fullcodeline": "for (i = 0; i < hdr.count; i++) {"
    },
    {
        "line": 411,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 417,
        "fullcodeline": "for (i--; i >= 0; i--)"
    },
    {
        "line": 336,
        "fullcodeline": "slot = true;"
    },
    {
        "line": 359,
        "fullcodeline": "kfree(group_fds);"
    },
    {
        "line": 360,
        "fullcodeline": "kfree(groups);"
    },
    {
        "line": 366,
        "fullcodeline": "kfree(group_fds);"
    },
    {
        "line": 367,
        "fullcodeline": "kfree(groups);"
    },
    {
        "line": 378,
        "fullcodeline": "struct fd f = fdget(group_fds[i]);"
    },
    {
        "line": 384,
        "fullcodeline": "group = vfio_group_get_external_user(f.file);"
    },
    {
        "line": 385,
        "fullcodeline": "fdput(f);"
    },
    {
        "line": 391,
        "fullcodeline": "groups[i].group = group;"
    },
    {
        "line": 392,
        "fullcodeline": "groups[i].id = vfio_external_user_iommu_id(group);"
    },
    {
        "line": 413,
        "fullcodeline": "ret = slot ? pci_try_reset_slot(vdev->pdev->slot) :"
    },
    {
        "line": 266,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 329,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 332,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 354,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 361,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 368,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 379,
        "fullcodeline": "if (!f.file) {"
    },
    {
        "line": 386,
        "fullcodeline": "if (IS_ERR(group)) {"
    },
    {
        "line": 380,
        "fullcodeline": "ret = -EBADF;"
    },
    {
        "line": 387,
        "fullcodeline": "ret = PTR_ERR(group);"
    },
    {
        "line": 414,
        "fullcodeline": "pci_try_reset_bus(vdev->pdev->bus);"
    },
    {
        "line": 338,
        "fullcodeline": "return -ENODEV;"
    }
]