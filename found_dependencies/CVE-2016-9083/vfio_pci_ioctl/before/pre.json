[
    {
        "line": 4,
        "fullcodeline": "struct vfio_pci_device *vdev = device_data;"
    },
    {
        "line": 7,
        "fullcodeline": "if (cmd == VFIO_DEVICE_GET_INFO) {"
    },
    {
        "line": 415,
        "fullcodeline": "return -ENOTTY;"
    },
    {
        "line": 18,
        "fullcodeline": "info.flags = VFIO_DEVICE_FLAGS_PCI;"
    },
    {
        "line": 21,
        "fullcodeline": "info.flags |= VFIO_DEVICE_FLAGS_RESET;"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {"
    },
    {
        "line": 13,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 16,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 30,
        "fullcodeline": "struct pci_dev *pdev = vdev->pdev;"
    },
    {
        "line": 32,
        "fullcodeline": "struct vfio_info_cap caps = { .buf = NULL, .size = 0 };"
    },
    {
        "line": 47,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ |"
    },
    {
        "line": 50,
        "fullcodeline": "case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:"
    },
    {
        "line": 52,
        "fullcodeline": "info.size = pci_resource_len(pdev, info.index);"
    },
    {
        "line": 58,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ |"
    },
    {
        "line": 106,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ |"
    },
    {
        "line": 119,
        "fullcodeline": "info.flags = vdev->region[i].flags;"
    },
    {
        "line": 121,
        "fullcodeline": "ret = region_type_cap(vdev, &caps,"
    },
    {
        "line": 129,
        "fullcodeline": "info.flags |= VFIO_REGION_INFO_FLAG_CAPS;"
    },
    {
        "line": 150,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {"
    },
    {
        "line": 38,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 41,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 45,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 51,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 76,
        "fullcodeline": "info.flags = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "info.size = pci_resource_len(pdev, info.index);"
    },
    {
        "line": 90,
        "fullcodeline": "io = pci_map_rom(pdev, &size);"
    },
    {
        "line": 97,
        "fullcodeline": "info.flags = VFIO_REGION_INFO_FLAG_READ;"
    },
    {
        "line": 104,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 111,
        "fullcodeline": "if (info.index >="
    },
    {
        "line": 115,
        "fullcodeline": "i = info.index - VFIO_PCI_NUM_REGIONS;"
    },
    {
        "line": 117,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 173,
        "fullcodeline": "info.flags = VFIO_IRQ_INFO_EVENTFD;"
    },
    {
        "line": 54,
        "fullcodeline": "info.flags = 0;"
    },
    {
        "line": 61,
        "fullcodeline": "info.flags |= VFIO_REGION_INFO_FLAG_MMAP;"
    },
    {
        "line": 75,
        "fullcodeline": "info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);"
    },
    {
        "line": 175,
        "fullcodeline": "info.count = vfio_pci_get_irq_count(vdev, info.index);"
    },
    {
        "line": 62,
        "fullcodeline": "if (info.index == vdev->msix_bar) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (!io || !size) {"
    },
    {
        "line": 102,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 113,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 158,
        "fullcodeline": "if (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)"
    },
    {
        "line": 162,
        "fullcodeline": "case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:"
    },
    {
        "line": 186,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_SET_IRQS) {"
    },
    {
        "line": 63,
        "fullcodeline": "ret = msix_sparse_mmap_cap(vdev, &caps);"
    },
    {
        "line": 82,
        "fullcodeline": "if (pdev->resource[PCI_ROM_RESOURCE].flags &"
    },
    {
        "line": 156,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 159,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 166,
        "fullcodeline": "if (pci_is_pcie(vdev->pdev))"
    },
    {
        "line": 170,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 178,
        "fullcodeline": "info.flags |= (VFIO_IRQ_INFO_MASKABLE |"
    },
    {
        "line": 181,
        "fullcodeline": "info.flags |= VFIO_IRQ_INFO_NORESIZE;"
    },
    {
        "line": 188,
        "fullcodeline": "u8 *data = NULL;"
    },
    {
        "line": 222,
        "fullcodeline": "mutex_lock(&vdev->igate);"
    },
    {
        "line": 224,
        "fullcodeline": "ret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,"
    },
    {
        "line": 139,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 196,
        "fullcodeline": "if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||"
    },
    {
        "line": 197,
        "fullcodeline": "hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |"
    },
    {
        "line": 201,
        "fullcodeline": "if (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {"
    },
    {
        "line": 203,
        "fullcodeline": "int max = vfio_pci_get_irq_count(vdev, hdr.index);"
    },
    {
        "line": 232,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_RESET) {"
    },
    {
        "line": 194,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 199,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 205,
        "fullcodeline": "if (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)"
    },
    {
        "line": 218,
        "fullcodeline": "if (IS_ERR(data))"
    },
    {
        "line": 206,
        "fullcodeline": "size = sizeof(uint8_t);"
    },
    {
        "line": 212,
        "fullcodeline": "if (hdr.argsz - minsz < hdr.count * size ||"
    },
    {
        "line": 213,
        "fullcodeline": "hdr.start >= max || hdr.start + hdr.count > max)"
    },
    {
        "line": 233,
        "fullcodeline": "return vdev->reset_works ?"
    },
    {
        "line": 214,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 219,
        "fullcodeline": "return PTR_ERR(data);"
    },
    {
        "line": 234,
        "fullcodeline": "pci_try_reset_function(vdev->pdev) : -EINVAL;"
    },
    {
        "line": 236,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {"
    },
    {
        "line": 207,
        "fullcodeline": "else if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)"
    },
    {
        "line": 238,
        "fullcodeline": "struct vfio_pci_fill_info fill = { 0 };"
    },
    {
        "line": 239,
        "fullcodeline": "struct vfio_pci_dependent_device *devices = NULL;"
    },
    {
        "line": 240,
        "fullcodeline": "bool slot = false;"
    },
    {
        "line": 260,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 278,
        "fullcodeline": "devices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);"
    },
    {
        "line": 282,
        "fullcodeline": "fill.devices = devices;"
    },
    {
        "line": 284,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 208,
        "fullcodeline": "size = sizeof(int32_t);"
    },
    {
        "line": 266,
        "fullcodeline": "WARN_ON(!fill.max); /* Should always be at least one */"
    },
    {
        "line": 279,
        "fullcodeline": "if (!devices)"
    },
    {
        "line": 293,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 300,
        "fullcodeline": "if (!ret) {"
    },
    {
        "line": 254,
        "fullcodeline": "if (!pci_probe_reset_slot(vdev->pdev->slot))"
    },
    {
        "line": 255,
        "fullcodeline": "slot = true;"
    },
    {
        "line": 273,
        "fullcodeline": "ret = -ENOSPC;"
    },
    {
        "line": 298,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 309,
        "fullcodeline": "} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {"
    },
    {
        "line": 210,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 246,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 249,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 272,
        "fullcodeline": "if (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {"
    },
    {
        "line": 280,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 314,
        "fullcodeline": "bool slot = false;"
    },
    {
        "line": 315,
        "fullcodeline": "int i, count = 0, ret = 0;"
    },
    {
        "line": 337,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 347,
        "fullcodeline": "group_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);"
    },
    {
        "line": 348,
        "fullcodeline": "groups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);"
    },
    {
        "line": 392,
        "fullcodeline": "info.count = hdr.count;"
    },
    {
        "line": 393,
        "fullcodeline": "info.groups = groups;"
    },
    {
        "line": 399,
        "fullcodeline": "ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,"
    },
    {
        "line": 256,
        "fullcodeline": "else if (pci_probe_reset_bus(vdev->pdev->bus))"
    },
    {
        "line": 303,
        "fullcodeline": "ret = -EFAULT;"
    },
    {
        "line": 367,
        "fullcodeline": "for (i = 0; i < hdr.count; i++) {"
    },
    {
        "line": 402,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 408,
        "fullcodeline": "for (i--; i >= 0; i--)"
    },
    {
        "line": 322,
        "fullcodeline": "if (hdr.argsz < minsz || hdr.flags)"
    },
    {
        "line": 326,
        "fullcodeline": "if (!pci_probe_reset_slot(vdev->pdev->slot))"
    },
    {
        "line": 327,
        "fullcodeline": "slot = true;"
    },
    {
        "line": 344,
        "fullcodeline": "if (!hdr.count || hdr.count > count)"
    },
    {
        "line": 349,
        "fullcodeline": "if (!group_fds || !groups) {"
    },
    {
        "line": 369,
        "fullcodeline": "struct fd f = fdget(group_fds[i]);"
    },
    {
        "line": 375,
        "fullcodeline": "group = vfio_group_get_external_user(f.file);"
    },
    {
        "line": 404,
        "fullcodeline": "ret = slot ? pci_try_reset_slot(vdev->pdev->slot) :"
    },
    {
        "line": 257,
        "fullcodeline": "return -ENODEV;"
    },
    {
        "line": 320,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 323,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 345,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 352,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 359,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 370,
        "fullcodeline": "if (!f.file) {"
    },
    {
        "line": 377,
        "fullcodeline": "if (IS_ERR(group)) {"
    },
    {
        "line": 383,
        "fullcodeline": "groups[i].id = vfio_external_user_iommu_id(group);"
    },
    {
        "line": 328,
        "fullcodeline": "else if (pci_probe_reset_bus(vdev->pdev->bus))"
    },
    {
        "line": 371,
        "fullcodeline": "ret = -EBADF;"
    },
    {
        "line": 378,
        "fullcodeline": "ret = PTR_ERR(group);"
    },
    {
        "line": 405,
        "fullcodeline": "pci_try_reset_bus(vdev->pdev->bus);"
    },
    {
        "line": 329,
        "fullcodeline": "return -ENODEV;"
    }
]