[
    {
        "line": 8,
        "fullcodeline": "const int num_dims = num_spatial_dims + 2;"
    },
    {
        "line": 21,
        "fullcodeline": "int batch_dim = GetTensorBatchDimIndex(num_dims, data_format);"
    },
    {
        "line": 22,
        "fullcodeline": "dims->batch_size = input_shape.dim_size(batch_dim);"
    },
    {
        "line": 31,
        "fullcodeline": "int feature_dim = GetTensorFeatureDimIndex(num_dims, data_format);"
    },
    {
        "line": 32,
        "fullcodeline": "dims->in_depth = input_shape.dim_size(feature_dim);"
    },
    {
        "line": 41,
        "fullcodeline": "dims->out_depth = filter_shape.dim_size(num_dims - 1);"
    },
    {
        "line": 46,
        "fullcodeline": "dims->spatial_dims.resize(num_spatial_dims);"
    },
    {
        "line": 9,
        "fullcodeline": "if (input_shape.dims() != num_dims) {"
    },
    {
        "line": 13,
        "fullcodeline": "if (filter_shape.dims() != num_dims) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (out_backprop_shape.dims() != num_dims) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (dims->batch_size != out_backprop_shape.dim_size(batch_dim)) {"
    },
    {
        "line": 35,
        "fullcodeline": "VLOG(2) << \"input vs filter_in depth \" << dims->in_depth << \" \""
    },
    {
        "line": 36,
        "fullcodeline": "<< filter_shape.dim_size(num_dims - 2);"
    },
    {
        "line": 47,
        "fullcodeline": "for (int i = 0; i < num_spatial_dims; ++i) {"
    },
    {
        "line": 59,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 37,
        "fullcodeline": "if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (dims->out_depth != out_backprop_shape.dim_size(feature_dim)) {"
    },
    {
        "line": 48,
        "fullcodeline": "int image_dim = GetTensorSpatialDimIndex(num_dims, data_format, i);"
    },
    {
        "line": 49,
        "fullcodeline": "int64 padding_before = -1, padding_after = -1;"
    },
    {
        "line": 10,
        "fullcodeline": "return errors::InvalidArgument(label, \": input must be \", num_dims,"
    },
    {
        "line": 14,
        "fullcodeline": "return errors::InvalidArgument(label, \": filter must be \", num_dims,"
    },
    {
        "line": 18,
        "fullcodeline": "return errors::InvalidArgument(label, \": out_backprop must be \", num_dims,"
    },
    {
        "line": 24,
        "fullcodeline": "return errors::InvalidArgument("
    },
    {
        "line": 38,
        "fullcodeline": "return errors::InvalidArgument("
    },
    {
        "line": 43,
        "fullcodeline": "return errors::InvalidArgument("
    },
    {
        "line": 50,
        "fullcodeline": "if (padding == EXPLICIT) {"
    },
    {
        "line": 54,
        "fullcodeline": "TF_RETURN_IF_ERROR(ConvBackpropExtractAndVerifyDimension("
    },
    {
        "line": 27,
        "fullcodeline": "\", outbackprop batch: \", out_backprop_shape.dim_size(batch_dim),"
    },
    {
        "line": 51,
        "fullcodeline": "padding_before = explicit_paddings[2 * image_dim];"
    },
    {
        "line": 52,
        "fullcodeline": "padding_after = explicit_paddings[2 * image_dim + 1];"
    }
]