[
    {
        "line": 6,
        "fullcodeline": "OPJ_BYTE * l_current_data = 00;"
    },
    {
        "line": 8,
        "fullcodeline": "opj_tcp_t * l_tcp = 00;"
    },
    {
        "line": 13,
        "fullcodeline": "assert(p_j2k != 00);"
    },
    {
        "line": 14,
        "fullcodeline": "assert(p_manager != 00);"
    },
    {
        "line": 15,
        "fullcodeline": "assert(p_stream != 00);"
    },
    {
        "line": 19,
        "fullcodeline": "l_mco_size = 5 + l_tcp->m_nb_mcc_records;"
    },
    {
        "line": 33,
        "fullcodeline": "l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;"
    },
    {
        "line": 36,
        "fullcodeline": "opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */"
    },
    {
        "line": 37,
        "fullcodeline": "l_current_data += 2;"
    },
    {
        "line": 39,
        "fullcodeline": "opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */"
    },
    {
        "line": 40,
        "fullcodeline": "l_current_data += 2;"
    },
    {
        "line": 42,
        "fullcodeline": "opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one tranform stage*/"
    },
    {
        "line": 43,
        "fullcodeline": "++l_current_data;"
    },
    {
        "line": 45,
        "fullcodeline": "l_mcc_record = l_tcp->m_mcc_records;"
    },
    {
        "line": 20,
        "fullcodeline": "if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {"
    },
    {
        "line": 46,
        "fullcodeline": "for (i=0;i<l_tcp->m_nb_mcc_records;++i) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {"
    },
    {
        "line": 22,
        "fullcodeline": "OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);"
    },
    {
        "line": 30,
        "fullcodeline": "p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;"
    },
    {
        "line": 31,
        "fullcodeline": "p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;"
    },
    {
        "line": 47,
        "fullcodeline": "opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/"
    },
    {
        "line": 48,
        "fullcodeline": "++l_current_data;"
    },
    {
        "line": 49,
        "fullcodeline": "++l_mcc_record;"
    },
    {
        "line": 23,
        "fullcodeline": "if (! new_header_tile_data) {"
    },
    {
        "line": 24,
        "fullcodeline": "opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);"
    },
    {
        "line": 25,
        "fullcodeline": "p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");"
    }
]