[
    {
        "line": 30,
        "fullcodeline": "assert(image_info != (const ImageInfo *) NULL);"
    },
    {
        "line": 31,
        "fullcodeline": "assert(image_info->signature == MagickCoreSignature);"
    },
    {
        "line": 32,
        "fullcodeline": "assert(images != (Image *) NULL);"
    },
    {
        "line": 33,
        "fullcodeline": "assert(images->signature == MagickCoreSignature);"
    },
    {
        "line": 36,
        "fullcodeline": "assert(exception != (ExceptionInfo *) NULL);"
    },
    {
        "line": 37,
        "fullcodeline": "write_info=CloneImageInfo(image_info);"
    },
    {
        "line": 38,
        "fullcodeline": "*write_info->magick='\\0';"
    },
    {
        "line": 39,
        "fullcodeline": "images=GetFirstImageInList(images);"
    },
    {
        "line": 43,
        "fullcodeline": "(void) CopyMagickString(write_info->filename,images->filename,MagickPathExtent);"
    },
    {
        "line": 44,
        "fullcodeline": "sans_exception=AcquireExceptionInfo();"
    },
    {
        "line": 45,
        "fullcodeline": "(void) SetImageInfo(write_info,(unsigned int) GetImageListLength(images),"
    },
    {
        "line": 47,
        "fullcodeline": "sans_exception=DestroyExceptionInfo(sans_exception);"
    },
    {
        "line": 50,
        "fullcodeline": "p=images;"
    },
    {
        "line": 76,
        "fullcodeline": "status=MagickTrue;"
    },
    {
        "line": 77,
        "fullcodeline": "progress_monitor=(MagickProgressMonitor) NULL;"
    },
    {
        "line": 78,
        "fullcodeline": "progress=0;"
    },
    {
        "line": 79,
        "fullcodeline": "number_images=GetImageListLength(images);"
    },
    {
        "line": 97,
        "fullcodeline": "write_info=DestroyImageInfo(write_info);"
    },
    {
        "line": 34,
        "fullcodeline": "if (images->debug != MagickFalse)"
    },
    {
        "line": 40,
        "fullcodeline": "if (filename != (const char *) NULL)"
    },
    {
        "line": 48,
        "fullcodeline": "if (*write_info->magick == '\\0')"
    },
    {
        "line": 51,
        "fullcodeline": "for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))"
    },
    {
        "line": 80,
        "fullcodeline": "for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))"
    },
    {
        "line": 98,
        "fullcodeline": "return(status != 0 ? MagickTrue : MagickFalse);"
    },
    {
        "line": 35,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);"
    },
    {
        "line": 49,
        "fullcodeline": "(void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);"
    },
    {
        "line": 56,
        "fullcodeline": "next=GetNextImageInList(p);"
    },
    {
        "line": 85,
        "fullcodeline": "status&=WriteImage(write_info,p,exception);"
    },
    {
        "line": 41,
        "fullcodeline": "for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))"
    },
    {
        "line": 42,
        "fullcodeline": "(void) CopyMagickString(p->filename,filename,MagickPathExtent);"
    },
    {
        "line": 57,
        "fullcodeline": "if (next == (Image *) NULL)"
    },
    {
        "line": 59,
        "fullcodeline": "if (p->scene >= next->scene)"
    },
    {
        "line": 82,
        "fullcodeline": "if (number_images != 1)"
    },
    {
        "line": 86,
        "fullcodeline": "if (number_images != 1)"
    },
    {
        "line": 88,
        "fullcodeline": "if (write_info->adjoin != MagickFalse)"
    },
    {
        "line": 90,
        "fullcodeline": "if (number_images != 1)"
    },
    {
        "line": 67,
        "fullcodeline": "i=(ssize_t) images->scene;"
    },
    {
        "line": 83,
        "fullcodeline": "progress_monitor=SetImageProgressMonitor(p,(MagickProgressMonitor) NULL,"
    },
    {
        "line": 87,
        "fullcodeline": "(void) SetImageProgressMonitor(p,progress_monitor,p->client_data);"
    },
    {
        "line": 92,
        "fullcodeline": "proceed=SetImageProgress(p,WriteImageTag,progress++,number_images);"
    },
    {
        "line": 68,
        "fullcodeline": "for (p=images; p != (Image *) NULL; p=GetNextImageInList(p))"
    },
    {
        "line": 69,
        "fullcodeline": "p->scene=(size_t) i++;"
    },
    {
        "line": 93,
        "fullcodeline": "if (proceed == MagickFalse)"
    }
]