[
    {
        "line": 3,
        "fullcodeline": "int marker = 0, last_marker = M_PSEUDO, comment_correction=1;"
    },
    {
        "line": 9,
        "fullcodeline": "for(section=0;;section++) {"
    },
    {
        "line": 38,
        "fullcodeline": "fpos = ImageInfo->infile->tell();"
    },
    {
        "line": 58,
        "fullcodeline": "itemlen = (lh << 8) | ll;"
    },
    {
        "line": 65,
        "fullcodeline": "sn = exif_file_sections_add(ImageInfo, marker, itemlen+1, nullptr);"
    },
    {
        "line": 67,
        "fullcodeline": "Data = ImageInfo->file.list[sn].data;"
    },
    {
        "line": 70,
        "fullcodeline": "Data[0] = (unsigned char)lh;"
    },
    {
        "line": 71,
        "fullcodeline": "Data[1] = (unsigned char)ll;"
    },
    {
        "line": 73,
        "fullcodeline": "String str = ImageInfo->infile->read(itemlen-2);"
    },
    {
        "line": 74,
        "fullcodeline": "got = str.length();"
    },
    {
        "line": 81,
        "fullcodeline": "memcpy(Data+2, str.c_str(), got);"
    },
    {
        "line": 156,
        "fullcodeline": "last_marker = marker;"
    },
    {
        "line": 14,
        "fullcodeline": "if (last_marker==M_COM && comment_correction) {"
    },
    {
        "line": 30,
        "fullcodeline": "} while (marker == 0xff);"
    },
    {
        "line": 31,
        "fullcodeline": "if (last_marker==M_COM && !comment_correction) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (last_marker==M_COM && comment_correction)"
    },
    {
        "line": 40,
        "fullcodeline": "if (marker == 0xff) {"
    },
    {
        "line": 48,
        "fullcodeline": "if ((lh = ImageInfo->infile->getc()) == EOF) {"
    },
    {
        "line": 53,
        "fullcodeline": "if ((ll = ImageInfo->infile->getc()) == EOF) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (itemlen < 2) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (sn == -1) return 0;"
    },
    {
        "line": 75,
        "fullcodeline": "if (got != itemlen-2) {"
    },
    {
        "line": 15,
        "fullcodeline": "comment_correction = 2;"
    },
    {
        "line": 32,
        "fullcodeline": "raise_notice(\"Image has corrupt COM section: some software set \""
    },
    {
        "line": 107,
        "fullcodeline": "exif_process_COM(ImageInfo, (char *)Data, itemlen);"
    },
    {
        "line": 120,
        "fullcodeline": "exif_process_APP12(ImageInfo, (char *)Data, itemlen);"
    },
    {
        "line": 141,
        "fullcodeline": "exif_process_SOFn(Data, marker, &sof_info);"
    },
    {
        "line": 142,
        "fullcodeline": "ImageInfo->Width  = sof_info.width;"
    },
    {
        "line": 143,
        "fullcodeline": "ImageInfo->Height = sof_info.height;"
    },
    {
        "line": 18,
        "fullcodeline": "if ((marker = ImageInfo->infile->getc()) == EOF) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (last_marker==M_COM && comment_correction>0) {"
    },
    {
        "line": 78,
        "fullcodeline": "got, got, itemlen-2, itemlen-2);"
    },
    {
        "line": 104,
        "fullcodeline": "return (ImageInfo->sections_found&(~FOUND_COMPUTED)) ? 1 : 0;"
    },
    {
        "line": 111,
        "fullcodeline": "if (!(ImageInfo->sections_found&FOUND_IFD0)) {"
    },
    {
        "line": 137,
        "fullcodeline": "if ((itemlen - 2) < 6) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (sof_info.num_components == 3) {"
    },
    {
        "line": 19,
        "fullcodeline": "raise_warning(\"File structure corrupted\");"
    },
    {
        "line": 87,
        "fullcodeline": "fpos = ImageInfo->infile->tell();"
    },
    {
        "line": 88,
        "fullcodeline": "size = ImageInfo->FileSize - fpos;"
    },
    {
        "line": 89,
        "fullcodeline": "sn = exif_file_sections_add(ImageInfo, M_PSEUDO, size, nullptr);"
    },
    {
        "line": 91,
        "fullcodeline": "Data = ImageInfo->file.list[sn].data;"
    },
    {
        "line": 92,
        "fullcodeline": "str = ImageInfo->infile->read(size);"
    },
    {
        "line": 93,
        "fullcodeline": "got = str.length();"
    },
    {
        "line": 115,
        "fullcodeline": "exif_process_APP1(ImageInfo, (char *)Data, itemlen, fpos);"
    },
    {
        "line": 145,
        "fullcodeline": "ImageInfo->IsColor = 1;"
    },
    {
        "line": 23,
        "fullcodeline": "if (marker!=0xFF) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (got != size) {"
    },
    {
        "line": 98,
        "fullcodeline": "memcpy(Data, str.c_str(), got);"
    },
    {
        "line": 147,
        "fullcodeline": "ImageInfo->IsColor = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "marker = 0xff;"
    },
    {
        "line": 25,
        "fullcodeline": "comment_correction--;"
    },
    {
        "line": 90,
        "fullcodeline": "if (sn == -1) return 0;"
    },
    {
        "line": 27,
        "fullcodeline": "last_marker = M_PSEUDO; /* stop skipping 0 for M_COM */"
    }
]