[
    {
        "line": 3,
        "fullcodeline": "DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space"
    },
    {
        "line": 4,
        "fullcodeline": "long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?"
    },
    {
        "line": 5,
        "fullcodeline": "long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?"
    },
    {
        "line": 6,
        "fullcodeline": "Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;"
    },
    {
        "line": 7,
        "fullcodeline": "uint32_t      length = getLong((byte*)&pBox->length, bigEndian);"
    },
    {
        "line": 8,
        "fullcodeline": "uint32_t      count  = sizeof (Jp2BoxHeader);"
    },
    {
        "line": 9,
        "fullcodeline": "char*         p      = (char*) boxBuf.pData_;"
    },
    {
        "line": 10,
        "fullcodeline": "bool          bWroteColor = false ;"
    },
    {
        "line": 67,
        "fullcodeline": "outBuf.alloc(outlen);"
    },
    {
        "line": 68,
        "fullcodeline": "::memcpy(outBuf.pData_,output.pData_,outlen);"
    },
    {
        "line": 69,
        "fullcodeline": "pBox   = (Jp2BoxHeader*) outBuf.pData_;"
    },
    {
        "line": 70,
        "fullcodeline": "ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);"
    },
    {
        "line": 71,
        "fullcodeline": "ul2Data((byte*)&pBox->length,outlen,bigEndian);"
    },
    {
        "line": 12,
        "fullcodeline": "while ( count < length || !bWroteColor ) {"
    },
    {
        "line": 13,
        "fullcodeline": "Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;"
    },
    {
        "line": 16,
        "fullcodeline": "Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));"
    },
    {
        "line": 17,
        "fullcodeline": "Jp2BoxHeader   newBox =  subBox;"
    },
    {
        "line": 34,
        "fullcodeline": "uint32_t newlen = subBox.length;"
    },
    {
        "line": 62,
        "fullcodeline": "outlen += newlen;"
    },
    {
        "line": 63,
        "fullcodeline": "inlen  += subBox.length;"
    },
    {
        "line": 19,
        "fullcodeline": "if ( count < length ) {"
    },
    {
        "line": 35,
        "fullcodeline": "if ( newBox.type == kJp2BoxTypeColorHeader ) {"
    },
    {
        "line": 20,
        "fullcodeline": "subBox.length = getLong((byte*)&subBox.length, bigEndian);"
    },
    {
        "line": 21,
        "fullcodeline": "subBox.type   = getLong((byte*)&subBox.type  , bigEndian);"
    },
    {
        "line": 25,
        "fullcodeline": "enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 26,
        "fullcodeline": "count        += subBox.length;"
    },
    {
        "line": 27,
        "fullcodeline": "newBox.type   = subBox.type;"
    },
    {
        "line": 36,
        "fullcodeline": "bWroteColor = true ;"
    },
    {
        "line": 29,
        "fullcodeline": "subBox.length=0;"
    },
    {
        "line": 30,
        "fullcodeline": "newBox.type = kJp2BoxTypeColorHeader;"
    },
    {
        "line": 31,
        "fullcodeline": "count = length;"
    },
    {
        "line": 37,
        "fullcodeline": "if ( ! iccProfileDefined() ) {"
    },
    {
        "line": 58,
        "fullcodeline": "enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 59,
        "fullcodeline": "::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);"
    },
    {
        "line": 38,
        "fullcodeline": "const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";"
    },
    {
        "line": 39,
        "fullcodeline": "uint32_t    psize = 15;"
    },
    {
        "line": 40,
        "fullcodeline": "newlen            = sizeof(newBox) + psize ;"
    },
    {
        "line": 41,
        "fullcodeline": "enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 42,
        "fullcodeline": "ul2Data((byte*)&newBox.length,psize      ,bigEndian);"
    },
    {
        "line": 43,
        "fullcodeline": "ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);"
    },
    {
        "line": 44,
        "fullcodeline": "::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));"
    },
    {
        "line": 45,
        "fullcodeline": "::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );"
    },
    {
        "line": 47,
        "fullcodeline": "const char* pad   = \"\\x02\\x00\\x00\";"
    },
    {
        "line": 48,
        "fullcodeline": "uint32_t    psize = 3;"
    },
    {
        "line": 49,
        "fullcodeline": "newlen            = sizeof(newBox) + psize + iccProfile_.size_;"
    },
    {
        "line": 50,
        "fullcodeline": "enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);"
    },
    {
        "line": 51,
        "fullcodeline": "ul2Data((byte*)&newBox.length,newlen,bigEndian);"
    },
    {
        "line": 52,
        "fullcodeline": "ul2Data((byte*)&newBox.type,newBox.type,bigEndian);"
    },
    {
        "line": 53,
        "fullcodeline": "::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );"
    },
    {
        "line": 54,
        "fullcodeline": "::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );"
    },
    {
        "line": 55,
        "fullcodeline": "::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);"
    }
]