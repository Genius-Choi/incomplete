[
    {
        "line": 13,
        "fullcodeline": "int\t\tno = -1;"
    },
    {
        "line": 14,
        "fullcodeline": "fptr_T\tfunc_all = (fptr_T)NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "fptr_T\tfunc_one = (fptr_T)NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "linenr_T\tclnum = 0;\t// init for GCC"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\tlen = 0;\t// init for GCC"
    },
    {
        "line": 22,
        "fullcodeline": "int\t\tcopy = flags & REGSUB_COPY;"
    },
    {
        "line": 40,
        "fullcodeline": "src = source;"
    },
    {
        "line": 41,
        "fullcodeline": "dst = dest;"
    },
    {
        "line": 25,
        "fullcodeline": "if ((source == NULL && expr == NULL) || dest == NULL)"
    },
    {
        "line": 30,
        "fullcodeline": "if (prog_magic_wrong())"
    },
    {
        "line": 46,
        "fullcodeline": "if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))"
    },
    {
        "line": 486,
        "fullcodeline": "return (int)((dst - dest) + 1);"
    },
    {
        "line": 27,
        "fullcodeline": "iemsg(e_null_argument);"
    },
    {
        "line": 483,
        "fullcodeline": "*dst = NUL;"
    },
    {
        "line": 188,
        "fullcodeline": "while ((c = *src++) != NUL)"
    },
    {
        "line": 190,
        "fullcodeline": "if (c == '&' && (flags & REGSUB_MAGIC))"
    },
    {
        "line": 221,
        "fullcodeline": "if (no < 0)\t      // Ordinary character."
    },
    {
        "line": 191,
        "fullcodeline": "no = 0;"
    },
    {
        "line": 335,
        "fullcodeline": "dst++;"
    },
    {
        "line": 223,
        "fullcodeline": "if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)"
    },
    {
        "line": 245,
        "fullcodeline": "if (c == '\\\\' && *src != NUL)"
    },
    {
        "line": 279,
        "fullcodeline": "if (func_one != (fptr_T)NULL)"
    },
    {
        "line": 479,
        "fullcodeline": "no = -1;"
    },
    {
        "line": 192,
        "fullcodeline": "else if (c == '\\\\' && *src != NUL)"
    },
    {
        "line": 281,
        "fullcodeline": "func_one = (fptr_T)(func_one(&cc, c));"
    },
    {
        "line": 290,
        "fullcodeline": "int totlen = mb_ptr2len(src - 1);"
    },
    {
        "line": 291,
        "fullcodeline": "int charlen = mb_char2len(cc);"
    },
    {
        "line": 302,
        "fullcodeline": "dst += charlen - 1;"
    },
    {
        "line": 324,
        "fullcodeline": "src += totlen - 1;"
    },
    {
        "line": 362,
        "fullcodeline": "if (s != NULL)"
    },
    {
        "line": 194,
        "fullcodeline": "if (*src == '&' && !(flags & REGSUB_MAGIC))"
    },
    {
        "line": 233,
        "fullcodeline": "*dst++ = c;"
    },
    {
        "line": 250,
        "fullcodeline": "case 'r':\tc = CAR;\t++src;\tbreak;"
    },
    {
        "line": 251,
        "fullcodeline": "case 'n':\tc = NL;\t\t++src;\tbreak;"
    },
    {
        "line": 252,
        "fullcodeline": "case 't':\tc = TAB;\t++src;\tbreak;"
    },
    {
        "line": 255,
        "fullcodeline": "case 'b':\tc = Ctrl_H;\t++src;\tbreak;"
    },
    {
        "line": 282,
        "fullcodeline": "else if (func_all != (fptr_T)NULL)"
    },
    {
        "line": 300,
        "fullcodeline": "mb_char2bytes(cc, dst);"
    },
    {
        "line": 305,
        "fullcodeline": "int clen = utf_ptr2len(src - 1);"
    },
    {
        "line": 342,
        "fullcodeline": "if (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)"
    },
    {
        "line": 196,
        "fullcodeline": "++src;"
    },
    {
        "line": 197,
        "fullcodeline": "no = 0;"
    },
    {
        "line": 228,
        "fullcodeline": "if (dst + 3 > dest + destlen)"
    },
    {
        "line": 239,
        "fullcodeline": "dst += 3;"
    },
    {
        "line": 240,
        "fullcodeline": "src += 2;"
    },
    {
        "line": 259,
        "fullcodeline": "default:\tif (flags & REGSUB_BACKSLASH)"
    },
    {
        "line": 276,
        "fullcodeline": "c = mb_ptr2char(src - 1);"
    },
    {
        "line": 284,
        "fullcodeline": "func_all = (fptr_T)(func_all(&cc, c));"
    },
    {
        "line": 295,
        "fullcodeline": "if (dst + charlen > dest + destlen)"
    },
    {
        "line": 309,
        "fullcodeline": "if (clen < totlen)"
    },
    {
        "line": 333,
        "fullcodeline": "*dst = cc;"
    },
    {
        "line": 343,
        "fullcodeline": "s = NULL;"
    },
    {
        "line": 357,
        "fullcodeline": "if (rex.reg_match->endp[no] == NULL)"
    },
    {
        "line": 230,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 234,
        "fullcodeline": "*dst++ = *src++;"
    },
    {
        "line": 235,
        "fullcodeline": "*dst++ = *src++;"
    },
    {
        "line": 270,
        "fullcodeline": "++dst;"
    },
    {
        "line": 272,
        "fullcodeline": "c = *src++;"
    },
    {
        "line": 286,
        "fullcodeline": "cc = c;"
    },
    {
        "line": 297,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 321,
        "fullcodeline": "dst += totlen - clen;"
    },
    {
        "line": 328,
        "fullcodeline": "if (dst + 1 > dest + destlen)"
    },
    {
        "line": 346,
        "fullcodeline": "s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;"
    },
    {
        "line": 358,
        "fullcodeline": "s = NULL;"
    },
    {
        "line": 366,
        "fullcodeline": "if (len == 0)"
    },
    {
        "line": 199,
        "fullcodeline": "else if ('0' <= *src && *src <= '9')"
    },
    {
        "line": 330,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 347,
        "fullcodeline": "if (rex.reg_mmatch->endpos[no].lnum == clnum)"
    },
    {
        "line": 360,
        "fullcodeline": "len = (int)(rex.reg_match->endp[no] - s);"
    },
    {
        "line": 201,
        "fullcodeline": "no = *src++ - '0';"
    },
    {
        "line": 268,
        "fullcodeline": "*dst = '\\\\';"
    },
    {
        "line": 318,
        "fullcodeline": "mch_memmove(dst + 1, src - 1 + clen,"
    },
    {
        "line": 348,
        "fullcodeline": "len = rex.reg_mmatch->endpos[no].col"
    },
    {
        "line": 263,
        "fullcodeline": "if (dst + 1 > dest + destlen)"
    },
    {
        "line": 313,
        "fullcodeline": "if (dst + totlen - clen > dest + destlen)"
    },
    {
        "line": 319,
        "fullcodeline": "(size_t)(totlen - clen));"
    },
    {
        "line": 351,
        "fullcodeline": "len = (int)STRLEN(s);"
    },
    {
        "line": 381,
        "fullcodeline": "++dst;"
    },
    {
        "line": 382,
        "fullcodeline": "s = reg_getline(++clnum);"
    },
    {
        "line": 391,
        "fullcodeline": "else if (*s == NUL) // we hit NUL."
    },
    {
        "line": 203,
        "fullcodeline": "else if (vim_strchr((char_u *)\"uUlLeE\", *src))"
    },
    {
        "line": 265,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 315,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 370,
        "fullcodeline": "if (rex.reg_mmatch->endpos[no].lnum == clnum)"
    },
    {
        "line": 383,
        "fullcodeline": "if (rex.reg_mmatch->endpos[no].lnum == clnum)"
    },
    {
        "line": 379,
        "fullcodeline": "*dst = CAR;"
    },
    {
        "line": 384,
        "fullcodeline": "len = rex.reg_mmatch->endpos[no].col;"
    },
    {
        "line": 474,
        "fullcodeline": "++s;"
    },
    {
        "line": 475,
        "fullcodeline": "--len;"
    },
    {
        "line": 374,
        "fullcodeline": "if (dst + 1 > dest + destlen)"
    },
    {
        "line": 386,
        "fullcodeline": "len = (int)STRLEN(s);"
    },
    {
        "line": 394,
        "fullcodeline": "iemsg(e_damaged_match_string);"
    },
    {
        "line": 399,
        "fullcodeline": "if ((flags & REGSUB_BACKSLASH)"
    },
    {
        "line": 205,
        "fullcodeline": "switch (*src++)"
    },
    {
        "line": 207,
        "fullcodeline": "case 'u':   func_one = (fptr_T)do_upper;"
    },
    {
        "line": 209,
        "fullcodeline": "case 'U':   func_all = (fptr_T)do_Upper;"
    },
    {
        "line": 211,
        "fullcodeline": "case 'l':   func_one = (fptr_T)do_lower;"
    },
    {
        "line": 213,
        "fullcodeline": "case 'L':   func_all = (fptr_T)do_Lower;"
    },
    {
        "line": 216,
        "fullcodeline": "case 'E':   func_one = func_all = (fptr_T)NULL;"
    },
    {
        "line": 376,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 400,
        "fullcodeline": "&& (*s == CAR || *s == '\\\\'))"
    },
    {
        "line": 418,
        "fullcodeline": "dst += 2;"
    },
    {
        "line": 471,
        "fullcodeline": "dst++;"
    },
    {
        "line": 415,
        "fullcodeline": "dst[0] = '\\\\';"
    },
    {
        "line": 416,
        "fullcodeline": "dst[1] = *s;"
    },
    {
        "line": 427,
        "fullcodeline": "if (func_one != (fptr_T)NULL)"
    },
    {
        "line": 410,
        "fullcodeline": "if (dst + 2 > dest + destlen)"
    },
    {
        "line": 423,
        "fullcodeline": "c = mb_ptr2char(s);"
    },
    {
        "line": 429,
        "fullcodeline": "func_one = (fptr_T)(func_one(&cc, c));"
    },
    {
        "line": 448,
        "fullcodeline": "s += l;"
    },
    {
        "line": 449,
        "fullcodeline": "len -= l;"
    },
    {
        "line": 450,
        "fullcodeline": "charlen = mb_char2len(cc);"
    },
    {
        "line": 460,
        "fullcodeline": "dst += charlen - 1;"
    },
    {
        "line": 412,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 425,
        "fullcodeline": "c = *s;"
    },
    {
        "line": 430,
        "fullcodeline": "else if (func_all != (fptr_T)NULL)"
    },
    {
        "line": 444,
        "fullcodeline": "l = utf_ptr2len(s) - 1;"
    },
    {
        "line": 458,
        "fullcodeline": "mb_char2bytes(cc, dst);"
    },
    {
        "line": 432,
        "fullcodeline": "func_all = (fptr_T)(func_all(&cc, c));"
    },
    {
        "line": 446,
        "fullcodeline": "l = mb_ptr2len(s) - 1;"
    },
    {
        "line": 453,
        "fullcodeline": "if (dst + charlen > dest + destlen)"
    },
    {
        "line": 469,
        "fullcodeline": "*dst = cc;"
    },
    {
        "line": 434,
        "fullcodeline": "cc = c;"
    },
    {
        "line": 455,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    },
    {
        "line": 464,
        "fullcodeline": "if (dst + 1 > dest + destlen)"
    },
    {
        "line": 466,
        "fullcodeline": "iemsg(\"vim_regsub_both(): not enough space\");"
    }
]