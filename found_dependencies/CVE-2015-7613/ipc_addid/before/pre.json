[
    {
        "line": 6,
        "fullcodeline": "int next_id = ids->next_id;"
    },
    {
        "line": 14,
        "fullcodeline": "idr_preload(GFP_KERNEL);"
    },
    {
        "line": 16,
        "fullcodeline": "spin_lock_init(&new->lock);"
    },
    {
        "line": 17,
        "fullcodeline": "new->deleted = false;"
    },
    {
        "line": 19,
        "fullcodeline": "spin_lock(&new->lock);"
    },
    {
        "line": 21,
        "fullcodeline": "id = idr_alloc(&ids->ipcs_idr, new,"
    },
    {
        "line": 33,
        "fullcodeline": "current_euid_egid(&euid, &egid);"
    },
    {
        "line": 8,
        "fullcodeline": "if (size > IPCMNI)"
    },
    {
        "line": 11,
        "fullcodeline": "if (ids->in_use >= size)"
    },
    {
        "line": 25,
        "fullcodeline": "if (id < 0) {"
    },
    {
        "line": 34,
        "fullcodeline": "new->cuid = new->uid = euid;"
    },
    {
        "line": 35,
        "fullcodeline": "new->gid = new->cgid = egid;"
    },
    {
        "line": 37,
        "fullcodeline": "if (next_id < 0) {"
    },
    {
        "line": 46,
        "fullcodeline": "new->id = ipc_buildid(id, new->seq);"
    },
    {
        "line": 9,
        "fullcodeline": "size = IPCMNI;"
    },
    {
        "line": 38,
        "fullcodeline": "new->seq = ids->seq++;"
    },
    {
        "line": 12,
        "fullcodeline": "return -ENOSPC;"
    },
    {
        "line": 22,
        "fullcodeline": "(next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,"
    },
    {
        "line": 39,
        "fullcodeline": "if (ids->seq > IPCID_SEQ_MAX)"
    },
    {
        "line": 42,
        "fullcodeline": "new->seq = ipcid_to_seqx(next_id);"
    },
    {
        "line": 43,
        "fullcodeline": "ids->next_id = -1;"
    }
]