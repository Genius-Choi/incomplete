[
    {
        "line": 3,
        "fullcodeline": "struct rq *rq = cpu_rq(cpu);"
    },
    {
        "line": 7,
        "fullcodeline": "bool done = true;"
    },
    {
        "line": 9,
        "fullcodeline": "rq_lock_irqsave(rq, &rf);"
    },
    {
        "line": 10,
        "fullcodeline": "update_rq_clock(rq);"
    },
    {
        "line": 16,
        "fullcodeline": "for_each_leaf_cfs_rq(rq, cfs_rq) {"
    },
    {
        "line": 36,
        "fullcodeline": "curr_class = rq->curr->sched_class;"
    },
    {
        "line": 37,
        "fullcodeline": "update_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);"
    },
    {
        "line": 38,
        "fullcodeline": "update_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);"
    },
    {
        "line": 39,
        "fullcodeline": "update_irq_load_avg(rq, 0);"
    },
    {
        "line": 49,
        "fullcodeline": "rq_unlock_irqrestore(rq, &rf);"
    },
    {
        "line": 27,
        "fullcodeline": "se = cfs_rq->tg->se[cpu];"
    },
    {
        "line": 41,
        "fullcodeline": "if (others_have_blocked(rq))"
    },
    {
        "line": 20,
        "fullcodeline": "if (throttled_hierarchy(cfs_rq))"
    },
    {
        "line": 23,
        "fullcodeline": "if (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))"
    },
    {
        "line": 28,
        "fullcodeline": "if (se && !skip_blocked_update(se))"
    },
    {
        "line": 32,
        "fullcodeline": "if (cfs_rq_has_blocked(cfs_rq))"
    },
    {
        "line": 42,
        "fullcodeline": "done = false;"
    },
    {
        "line": 24,
        "fullcodeline": "update_tg_load_avg(cfs_rq, 0);"
    },
    {
        "line": 29,
        "fullcodeline": "update_load_avg(cfs_rq_of(se), se, 0);"
    },
    {
        "line": 33,
        "fullcodeline": "done = false;"
    }
]