[
    {
        "line": 4,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 5,
        "fullcodeline": "struct irda_sock *self = irda_sk(sk);"
    },
    {
        "line": 6,
        "fullcodeline": "int noblock = flags & MSG_DONTWAIT;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t copied = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "IRDA_DEBUG(3, \"%s()\\n\", __func__);"
    },
    {
        "line": 24,
        "fullcodeline": "target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);"
    },
    {
        "line": 25,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, noblock);"
    },
    {
        "line": 13,
        "fullcodeline": "if ((err = sock_error(sk)) < 0)"
    },
    {
        "line": 16,
        "fullcodeline": "if (sock->flags & __SO_ACCEPTCON)"
    },
    {
        "line": 19,
        "fullcodeline": "err =-EOPNOTSUPP;"
    },
    {
        "line": 20,
        "fullcodeline": "if (flags & MSG_OOB)"
    },
    {
        "line": 106,
        "fullcodeline": "if (self->rx_flow == FLOW_STOP) {"
    },
    {
        "line": 29,
        "fullcodeline": "struct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);"
    },
    {
        "line": 75,
        "fullcodeline": "copied += chunk;"
    },
    {
        "line": 17,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 21,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 31,
        "fullcodeline": "if (skb == NULL) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {"
    },
    {
        "line": 32,
        "fullcodeline": "DEFINE_WAIT(wait);"
    },
    {
        "line": 38,
        "fullcodeline": "prepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);"
    },
    {
        "line": 43,
        "fullcodeline": "err = sock_error(sk);"
    },
    {
        "line": 58,
        "fullcodeline": "finish_wait(sk_sleep(sk), &wait);"
    },
    {
        "line": 79,
        "fullcodeline": "if (!(flags & MSG_PEEK)) {"
    },
    {
        "line": 80,
        "fullcodeline": "skb_pull(skb, chunk);"
    },
    {
        "line": 107,
        "fullcodeline": "if ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (copied >= target)"
    },
    {
        "line": 62,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 71,
        "fullcodeline": "if (copied == 0)"
    },
    {
        "line": 92,
        "fullcodeline": "IRDA_DEBUG(0, \"%s() questionable!?\\n\", __func__);"
    },
    {
        "line": 72,
        "fullcodeline": "copied = -EFAULT;"
    },
    {
        "line": 84,
        "fullcodeline": "IRDA_DEBUG(1, \"%s(), back on q!\\n\","
    },
    {
        "line": 46,
        "fullcodeline": "else if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 49,
        "fullcodeline": "err = -EAGAIN;"
    },
    {
        "line": 50,
        "fullcodeline": "else if (signal_pending(current))"
    },
    {
        "line": 51,
        "fullcodeline": "err = sock_intr_errno(timeo);"
    },
    {
        "line": 52,
        "fullcodeline": "else if (sk->sk_state != TCP_ESTABLISHED)"
    },
    {
        "line": 53,
        "fullcodeline": "err = -ENOTCONN;"
    },
    {
        "line": 54,
        "fullcodeline": "else if (skb_peek(&sk->sk_receive_queue) == NULL)"
    }
]