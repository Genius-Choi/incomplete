[
    {
        "line": 9,
        "fullcodeline": "int\t\tslen = 0;\t// init for GCC"
    },
    {
        "line": 12,
        "fullcodeline": "int\t\tretval = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "char_u\tkey_name[2];"
    },
    {
        "line": 16,
        "fullcodeline": "char_u\t*modifiers_start = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "char_u\tstring[MAX_KEY_CODE_LEN + 1];"
    },
    {
        "line": 21,
        "fullcodeline": "int\t\tidx = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "cpo_koffset = (vim_strchr(p_cpo, CPO_KOFFSET) != NULL);"
    },
    {
        "line": 40,
        "fullcodeline": "for (offset = 0; offset < max_offset; ++offset)"
    },
    {
        "line": 31,
        "fullcodeline": "gather_termleader();"
    },
    {
        "line": 72,
        "fullcodeline": "i = *tp;"
    },
    {
        "line": 85,
        "fullcodeline": "key_name[0] = NUL;\t// no key name found yet"
    },
    {
        "line": 86,
        "fullcodeline": "key_name[1] = NUL;\t// no key name found yet"
    },
    {
        "line": 87,
        "fullcodeline": "modifiers = 0;\t\t// no modifiers yet"
    },
    {
        "line": 562,
        "fullcodeline": "key = handle_x_keys(TERMCAP2KEY(key_name[0], key_name[1]));"
    },
    {
        "line": 567,
        "fullcodeline": "new_slen = modifiers2keycode(modifiers, &key, string);"
    },
    {
        "line": 570,
        "fullcodeline": "key_name[0] = KEY2TERMCAP0(key);"
    },
    {
        "line": 571,
        "fullcodeline": "key_name[1] = KEY2TERMCAP1(key);"
    },
    {
        "line": 42,
        "fullcodeline": "if (buf == NULL)"
    },
    {
        "line": 61,
        "fullcodeline": "if (*tp == K_SPECIAL)"
    },
    {
        "line": 73,
        "fullcodeline": "for (p = termleader; *p && *p != i; ++p)"
    },
    {
        "line": 75,
        "fullcodeline": "if (*p == NUL)"
    },
    {
        "line": 82,
        "fullcodeline": "if (*tp == ESC && !p_ek && (State & MODE_INSERT))"
    },
    {
        "line": 107,
        "fullcodeline": "int  mouse_index_found = -1;"
    },
    {
        "line": 340,
        "fullcodeline": "if (key_name[0] == NUL)"
    },
    {
        "line": 377,
        "fullcodeline": "if (key_name[0] == KS_MOUSE"
    },
    {
        "line": 572,
        "fullcodeline": "if (key_name[0] == KS_KEY)"
    },
    {
        "line": 593,
        "fullcodeline": "if (put_string_in_typebuf(offset, slen, string, new_slen,"
    },
    {
        "line": 596,
        "fullcodeline": "return retval == 0 ? (len + new_slen - slen + offset) : retval;"
    },
    {
        "line": 46,
        "fullcodeline": "tp = typebuf.tb_buf + typebuf.tb_off + offset;"
    },
    {
        "line": 47,
        "fullcodeline": "len = typebuf.tb_len - offset;\t// length of the input"
    },
    {
        "line": 63,
        "fullcodeline": "offset += 2;\t// there are always 2 extra characters"
    },
    {
        "line": 109,
        "fullcodeline": "for (idx = 0; idx < tc_len; ++idx)"
    },
    {
        "line": 262,
        "fullcodeline": "if (idx == tc_len && mouse_index_found >= 0)"
    },
    {
        "line": 397,
        "fullcodeline": "|| key_name[0] == KS_SGR_MOUSE_RELEASE)"
    },
    {
        "line": 44,
        "fullcodeline": "if (offset >= typebuf.tb_len)"
    },
    {
        "line": 53,
        "fullcodeline": "tp = buf + offset;"
    },
    {
        "line": 54,
        "fullcodeline": "len = *buflen - offset;"
    },
    {
        "line": 118,
        "fullcodeline": "modifiers_start = NULL;"
    },
    {
        "line": 396,
        "fullcodeline": "|| key_name[0] == KS_SGR_MOUSE"
    },
    {
        "line": 399,
        "fullcodeline": "if (check_termcode_mouse(tp, &slen, key_name, modifiers_start, idx,"
    },
    {
        "line": 595,
        "fullcodeline": "return -1;"
    },
    {
        "line": 51,
        "fullcodeline": "if (offset >= *buflen)"
    },
    {
        "line": 119,
        "fullcodeline": "if (cpo_koffset && offset && len < slen)"
    },
    {
        "line": 121,
        "fullcodeline": "if (STRNCMP(termcodes[idx].code, tp,"
    },
    {
        "line": 209,
        "fullcodeline": "if (termcodes[idx].modlen > 0 && mouse_index_found < 0)"
    },
    {
        "line": 400,
        "fullcodeline": "&modifiers) == -1)"
    },
    {
        "line": 576,
        "fullcodeline": "new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);"
    },
    {
        "line": 580,
        "fullcodeline": "else if (new_slen == 0 && key_name[0] == KS_EXTRA"
    },
    {
        "line": 124,
        "fullcodeline": "int\t    looks_like_mouse_start = FALSE;"
    },
    {
        "line": 213,
        "fullcodeline": "modslen = termcodes[idx].modlen;"
    },
    {
        "line": 216,
        "fullcodeline": "at_code = termcodes[idx].code[modslen] == '@';"
    },
    {
        "line": 401,
        "fullcodeline": "return -1;"
    },
    {
        "line": 578,
        "fullcodeline": "string[new_slen++] = key_name[1];"
    },
    {
        "line": 581,
        "fullcodeline": "&& key_name[1] == KE_IGNORE)"
    },
    {
        "line": 585,
        "fullcodeline": "retval = KEYLEN_REMOVED;"
    },
    {
        "line": 122,
        "fullcodeline": "(size_t)(slen > len ? len : slen)) == 0)"
    },
    {
        "line": 126,
        "fullcodeline": "if (len < slen)\t\t// got a partial sequence"
    },
    {
        "line": 135,
        "fullcodeline": "if (termcodes[idx].name[0] == 'K'"
    },
    {
        "line": 148,
        "fullcodeline": "if (slen == 2 && len > 2"
    },
    {
        "line": 214,
        "fullcodeline": "if (cpo_koffset && offset && len < modslen)"
    },
    {
        "line": 217,
        "fullcodeline": "if (STRNCMP(termcodes[idx].code, tp,"
    },
    {
        "line": 589,
        "fullcodeline": "string[new_slen++] = K_SPECIAL;"
    },
    {
        "line": 590,
        "fullcodeline": "string[new_slen++] = key_name[0];"
    },
    {
        "line": 591,
        "fullcodeline": "string[new_slen++] = key_name[1];"
    },
    {
        "line": 150,
        "fullcodeline": "&& termcodes[idx].code[1] == '[')"
    },
    {
        "line": 256,
        "fullcodeline": "key_name[0] = termcodes[idx].name[0];"
    },
    {
        "line": 257,
        "fullcodeline": "key_name[1] = termcodes[idx].name[1];"
    },
    {
        "line": 127,
        "fullcodeline": "return -1;\t\t// need to get more chars"
    },
    {
        "line": 138,
        "fullcodeline": "for (j = idx + 1; j < tc_len; ++j)"
    },
    {
        "line": 149,
        "fullcodeline": "&& termcodes[idx].code[0] == ESC"
    },
    {
        "line": 155,
        "fullcodeline": "if (!isdigit(tp[2]))"
    },
    {
        "line": 190,
        "fullcodeline": "if (mouse_index_found < 0)"
    },
    {
        "line": 195,
        "fullcodeline": "key_name[0] = termcodes[idx].name[0];"
    },
    {
        "line": 196,
        "fullcodeline": "key_name[1] = termcodes[idx].name[1];"
    },
    {
        "line": 218,
        "fullcodeline": "(size_t)(modslen > len ? len : modslen)) == 0)"
    },
    {
        "line": 222,
        "fullcodeline": "if (len <= modslen)\t// got a partial sequence"
    },
    {
        "line": 225,
        "fullcodeline": "if (tp[modslen] == termcodes[idx].code[slen - 1])"
    },
    {
        "line": 139,
        "fullcodeline": "if (termcodes[j].len == slen &&"
    },
    {
        "line": 159,
        "fullcodeline": "looks_like_mouse_start = TRUE;"
    },
    {
        "line": 191,
        "fullcodeline": "mouse_index_found = idx;"
    },
    {
        "line": 227,
        "fullcodeline": "slen = modslen + 1;"
    },
    {
        "line": 140,
        "fullcodeline": "STRNCMP(termcodes[idx].code,"
    },
    {
        "line": 143,
        "fullcodeline": "idx = j;"
    },
    {
        "line": 223,
        "fullcodeline": "return -1;\t\t// need to get more chars"
    },
    {
        "line": 161,
        "fullcodeline": "else if (termcodes[idx].name[0] == KS_DEC_MOUSE)"
    },
    {
        "line": 228,
        "fullcodeline": "else if (tp[modslen] != ';' && modslen == slen - 3)"
    },
    {
        "line": 163,
        "fullcodeline": "char_u  *nr = tp + 2;"
    },
    {
        "line": 164,
        "fullcodeline": "int\t    count = 0;"
    },
    {
        "line": 183,
        "fullcodeline": "if (count < 4)"
    },
    {
        "line": 173,
        "fullcodeline": "++count;"
    },
    {
        "line": 174,
        "fullcodeline": "(void)getdigits(&nr);"
    },
    {
        "line": 179,
        "fullcodeline": "++nr;"
    },
    {
        "line": 231,
        "fullcodeline": "else if (at_code && tp[modslen] != '1')"
    },
    {
        "line": 175,
        "fullcodeline": "if (nr >= tp + len)"
    },
    {
        "line": 177,
        "fullcodeline": "if (*nr != ';')"
    },
    {
        "line": 180,
        "fullcodeline": "if (nr >= tp + len)"
    },
    {
        "line": 242,
        "fullcodeline": "++j;"
    },
    {
        "line": 248,
        "fullcodeline": "modifiers_start = tp + slen - 2;"
    },
    {
        "line": 251,
        "fullcodeline": "n = atoi((char *)modifiers_start);"
    },
    {
        "line": 252,
        "fullcodeline": "modifiers |= decode_modifiers(n);"
    },
    {
        "line": 254,
        "fullcodeline": "slen = j;"
    },
    {
        "line": 176,
        "fullcodeline": "return -1;\t// partial sequence"
    },
    {
        "line": 181,
        "fullcodeline": "return -1;\t// partial sequence"
    },
    {
        "line": 239,
        "fullcodeline": "for (j = slen - 2; j < len && (isdigit(tp[j])"
    },
    {
        "line": 240,
        "fullcodeline": "|| tp[j] == '-' || tp[j] == ';'); ++j)"
    },
    {
        "line": 243,
        "fullcodeline": "if (len < j)\t// got a partial sequence"
    },
    {
        "line": 245,
        "fullcodeline": "if (tp[j - 1] != termcodes[idx].code[slen - 1])"
    },
    {
        "line": 244,
        "fullcodeline": "return -1;\t// need to get more chars"
    }
]