[
    {
        "line": 2,
        "fullcodeline": "char str[R_FLAG_NAME_SIZE];"
    },
    {
        "line": 3,
        "fullcodeline": "RList *entries = r_bin_get_entries (r->bin);"
    },
    {
        "line": 5,
        "fullcodeline": "RBinAddr *entry = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "ut64 baddr = r_bin_get_baddr (r->bin);"
    },
    {
        "line": 21,
        "fullcodeline": "r_list_foreach (entries, iter, entry) {"
    },
    {
        "line": 9,
        "fullcodeline": "if (IS_MODE_RAD (mode)) {"
    },
    {
        "line": 22,
        "fullcodeline": "ut64 paddr = entry->paddr;"
    },
    {
        "line": 23,
        "fullcodeline": "ut64 haddr = UT64_MAX;"
    },
    {
        "line": 49,
        "fullcodeline": "ut64 at = rva (r->bin, paddr, entry->vaddr, va);"
    },
    {
        "line": 50,
        "fullcodeline": "const char *type = r_bin_entry_type_string (entry->type);"
    },
    {
        "line": 110,
        "fullcodeline": "i++;"
    },
    {
        "line": 112,
        "fullcodeline": "if (IS_MODE_SET (mode)) {"
    },
    {
        "line": 10,
        "fullcodeline": "r_cons_printf (\"fs symbols\\n\");"
    },
    {
        "line": 24,
        "fullcodeline": "if (mode != R_CORE_BIN_SET) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (!type) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (IS_MODE_SET (mode)) {"
    },
    {
        "line": 47,
        "fullcodeline": "haddr = entry->haddr;"
    },
    {
        "line": 52,
        "fullcodeline": "type = \"unknown\";"
    },
    {
        "line": 55,
        "fullcodeline": "r_flag_space_set (r->flags, \"symbols\");"
    },
    {
        "line": 65,
        "fullcodeline": "r_flag_set (r->flags, str, at, 1);"
    },
    {
        "line": 11,
        "fullcodeline": "} else if (IS_MODE_JSON (mode)) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (r->io->va && entry->paddr == entry->vaddr) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (entry->type == R_BIN_ENTRY_TYPE_INIT) {"
    },
    {
        "line": 114,
        "fullcodeline": "ut64 at = rva (r->bin, entry->paddr, entry->vaddr, va);"
    },
    {
        "line": 115,
        "fullcodeline": "r_core_seek (r, at, 0);"
    },
    {
        "line": 117,
        "fullcodeline": "} else if (IS_MODE_JSON (mode)) {"
    },
    {
        "line": 12,
        "fullcodeline": "r_cons_printf (\"[\");"
    },
    {
        "line": 40,
        "fullcodeline": "RIOMap *map = r_io_map_get (r->io, entry->vaddr);"
    },
    {
        "line": 57,
        "fullcodeline": "snprintf (str, R_FLAG_NAME_SIZE, \"entry%i.init\", i);"
    },
    {
        "line": 66,
        "fullcodeline": "} else if (IS_MODE_SIMPLE (mode)) {"
    },
    {
        "line": 118,
        "fullcodeline": "r_cons_printf (\"]\");"
    },
    {
        "line": 119,
        "fullcodeline": "r_cons_newline ();"
    },
    {
        "line": 26,
        "fullcodeline": "if (entry->type == R_BIN_ENTRY_TYPE_PROGRAM) {"
    },
    {
        "line": 13,
        "fullcodeline": "} else if (IS_MODE_NORMAL (mode)) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (entry->type != R_BIN_ENTRY_TYPE_PROGRAM) {"
    },
    {
        "line": 42,
        "fullcodeline": "paddr = entry->vaddr - map->itv.addr + map->delta;"
    },
    {
        "line": 58,
        "fullcodeline": "} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {"
    },
    {
        "line": 120,
        "fullcodeline": "} else if (IS_MODE_NORMAL (mode)) {"
    },
    {
        "line": 59,
        "fullcodeline": "snprintf (str, R_FLAG_NAME_SIZE, \"entry%i.fini\", i);"
    },
    {
        "line": 68,
        "fullcodeline": "} else if (IS_MODE_JSON (mode)) {"
    },
    {
        "line": 121,
        "fullcodeline": "r_cons_printf (\"\\n%i entrypoints\\n\", i);"
    },
    {
        "line": 15,
        "fullcodeline": "r_cons_printf (\"[Constructors]\\n\");"
    },
    {
        "line": 60,
        "fullcodeline": "} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {"
    },
    {
        "line": 17,
        "fullcodeline": "r_cons_printf (\"[Entrypoints]\\n\");"
    },
    {
        "line": 61,
        "fullcodeline": "snprintf (str, R_FLAG_NAME_SIZE, \"entry%i.preinit\", i);"
    },
    {
        "line": 76,
        "fullcodeline": "} else if (IS_MODE_RAD (mode)) {"
    },
    {
        "line": 63,
        "fullcodeline": "snprintf (str, R_FLAG_NAME_SIZE, \"entry%i\", i);"
    },
    {
        "line": 77,
        "fullcodeline": "char *name = NULL;"
    },
    {
        "line": 89,
        "fullcodeline": "r_cons_printf (\"s %s\\n\", name);"
    },
    {
        "line": 90,
        "fullcodeline": "free (name);"
    },
    {
        "line": 78,
        "fullcodeline": "if (entry->type == R_BIN_ENTRY_TYPE_INIT) {"
    },
    {
        "line": 79,
        "fullcodeline": "name = r_str_newf (\"entry%i.init\", i);"
    },
    {
        "line": 98,
        "fullcodeline": "if (haddr == UT64_MAX) {"
    },
    {
        "line": 80,
        "fullcodeline": "} else if (entry->type == R_BIN_ENTRY_TYPE_FINI) {"
    },
    {
        "line": 81,
        "fullcodeline": "name = r_str_newf (\"entry%i.fini\", i);"
    },
    {
        "line": 82,
        "fullcodeline": "} else if (entry->type == R_BIN_ENTRY_TYPE_PREINIT) {"
    },
    {
        "line": 83,
        "fullcodeline": "name = r_str_newf (\"entry%i.preinit\", i);"
    },
    {
        "line": 85,
        "fullcodeline": "name = r_str_newf (\"entry%i\", i);"
    }
]