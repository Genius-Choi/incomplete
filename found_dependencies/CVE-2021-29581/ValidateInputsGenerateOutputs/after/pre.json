[
    {
        "line": 5,
        "fullcodeline": "Status status = ctx->input(\"inputs\", inputs);"
    },
    {
        "line": 7,
        "fullcodeline": "status = ctx->input(\"sequence_length\", seq_len);"
    },
    {
        "line": 10,
        "fullcodeline": "const TensorShape& inputs_shape = (*inputs)->shape();"
    },
    {
        "line": 19,
        "fullcodeline": "const int64 max_time = inputs_shape.dim_size(0);"
    },
    {
        "line": 20,
        "fullcodeline": "const int64 batch_size = inputs_shape.dim_size(1);"
    },
    {
        "line": 45,
        "fullcodeline": "Status s = ctx->allocate_output("
    },
    {
        "line": 49,
        "fullcodeline": "s = ctx->output_list(\"decoded_indices\", decoded_indices);"
    },
    {
        "line": 51,
        "fullcodeline": "s = ctx->output_list(\"decoded_values\", decoded_values);"
    },
    {
        "line": 53,
        "fullcodeline": "s = ctx->output_list(\"decoded_shape\", decoded_shape);"
    },
    {
        "line": 6,
        "fullcodeline": "if (!status.ok()) return status;"
    },
    {
        "line": 22,
        "fullcodeline": "if (max_time == 0) {"
    },
    {
        "line": 36,
        "fullcodeline": "auto seq_len_t = (*seq_len)->vec<int32>();"
    },
    {
        "line": 38,
        "fullcodeline": "for (int b = 0; b < batch_size; ++b) {"
    },
    {
        "line": 56,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 8,
        "fullcodeline": "if (!status.ok()) return status;"
    },
    {
        "line": 12,
        "fullcodeline": "if (inputs_shape.dims() != 3) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (inputs_shape.num_elements() == 0) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (!(batch_size == (*seq_len)->dim_size(0))) {"
    },
    {
        "line": 46,
        "fullcodeline": "\"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);"
    },
    {
        "line": 47,
        "fullcodeline": "if (!s.ok()) return s;"
    },
    {
        "line": 50,
        "fullcodeline": "if (!s.ok()) return s;"
    },
    {
        "line": 52,
        "fullcodeline": "if (!s.ok()) return s;"
    },
    {
        "line": 54,
        "fullcodeline": "if (!s.ok()) return s;"
    },
    {
        "line": 13,
        "fullcodeline": "return errors::InvalidArgument(\"inputs is not a 3-Tensor\");"
    },
    {
        "line": 16,
        "fullcodeline": "return errors::InvalidArgument(\"inputs must not be empty\");"
    },
    {
        "line": 23,
        "fullcodeline": "return errors::InvalidArgument(\"max_time is 0\");"
    },
    {
        "line": 26,
        "fullcodeline": "return errors::InvalidArgument(\"sequence_length is not a vector\");"
    },
    {
        "line": 30,
        "fullcodeline": "return errors::FailedPrecondition("
    },
    {
        "line": 32,
        "fullcodeline": "\"len(sequence_length):  \", (*seq_len)->dim_size(0),"
    },
    {
        "line": 39,
        "fullcodeline": "if (!(seq_len_t(b) <= max_time)) {"
    },
    {
        "line": 40,
        "fullcodeline": "return errors::FailedPrecondition(\"sequence_length(\", b,"
    }
]