[
    {
        "line": 11,
        "fullcodeline": "int\t\t\t\tcount = 0, trunc_8to4 ;"
    },
    {
        "line": 13,
        "fullcodeline": "trunc_8to4 = SF_FALSE ;"
    },
    {
        "line": 15,
        "fullcodeline": "va_start (argptr, format) ;"
    },
    {
        "line": 220,
        "fullcodeline": "va_end (argptr) ;"
    },
    {
        "line": 17,
        "fullcodeline": "while ((c = *format++))"
    },
    {
        "line": 23,
        "fullcodeline": "psf->rwf_endian = SF_ENDIAN_LITTLE ;"
    },
    {
        "line": 27,
        "fullcodeline": "psf->rwf_endian = SF_ENDIAN_BIG ;"
    },
    {
        "line": 31,
        "fullcodeline": "trunc_8to4 = SF_TRUE ;"
    },
    {
        "line": 35,
        "fullcodeline": "trunc_8to4 = SF_FALSE ;"
    },
    {
        "line": 40,
        "fullcodeline": "header_put_marker (psf, data) ;"
    },
    {
        "line": 41,
        "fullcodeline": "count += 4 ;"
    },
    {
        "line": 46,
        "fullcodeline": "header_put_byte (psf, data) ;"
    },
    {
        "line": 47,
        "fullcodeline": "count += 1 ;"
    },
    {
        "line": 58,
        "fullcodeline": "count += 2 ;"
    },
    {
        "line": 69,
        "fullcodeline": "count += 3 ;"
    },
    {
        "line": 80,
        "fullcodeline": "count += 4 ;"
    },
    {
        "line": 84,
        "fullcodeline": "countdata = va_arg (argptr, sf_count_t) ;"
    },
    {
        "line": 112,
        "fullcodeline": "psf->headindex += 4 ;"
    },
    {
        "line": 113,
        "fullcodeline": "count += 4 ;"
    },
    {
        "line": 122,
        "fullcodeline": "psf->headindex += 8 ;"
    },
    {
        "line": 123,
        "fullcodeline": "count += 8 ;"
    },
    {
        "line": 129,
        "fullcodeline": "size = strlen (strptr) + 1 ;"
    },
    {
        "line": 130,
        "fullcodeline": "size += (size & 1) ;"
    },
    {
        "line": 135,
        "fullcodeline": "memcpy (&(psf->header [psf->headindex]), strptr, size) ;"
    },
    {
        "line": 136,
        "fullcodeline": "psf->headindex += size ;"
    },
    {
        "line": 137,
        "fullcodeline": "psf->header [psf->headindex - 1] = 0 ;"
    },
    {
        "line": 138,
        "fullcodeline": "count += 4 + size ;"
    },
    {
        "line": 147,
        "fullcodeline": "size = strlen (strptr) ;"
    },
    {
        "line": 152,
        "fullcodeline": "memcpy (&(psf->header [psf->headindex]), strptr, size + 1) ;"
    },
    {
        "line": 153,
        "fullcodeline": "size += (size & 1) ;"
    },
    {
        "line": 154,
        "fullcodeline": "psf->headindex += size ;"
    },
    {
        "line": 155,
        "fullcodeline": "psf->header [psf->headindex] = 0 ;"
    },
    {
        "line": 156,
        "fullcodeline": "count += 4 + size ;"
    },
    {
        "line": 163,
        "fullcodeline": "size = strlen (strptr) ;"
    },
    {
        "line": 164,
        "fullcodeline": "size = (size & 1) ? size : size + 1 ;"
    },
    {
        "line": 165,
        "fullcodeline": "size = (size > 254) ? 254 : size ;"
    },
    {
        "line": 166,
        "fullcodeline": "header_put_byte (psf, size) ;"
    },
    {
        "line": 167,
        "fullcodeline": "memcpy (&(psf->header [psf->headindex]), strptr, size) ;"
    },
    {
        "line": 168,
        "fullcodeline": "psf->headindex += size ;"
    },
    {
        "line": 169,
        "fullcodeline": "count += 1 + size ;"
    },
    {
        "line": 174,
        "fullcodeline": "size\t= va_arg (argptr, size_t) ;"
    },
    {
        "line": 183,
        "fullcodeline": "size = va_arg (argptr, size_t) ;"
    },
    {
        "line": 184,
        "fullcodeline": "count += size ;"
    },
    {
        "line": 194,
        "fullcodeline": "memcpy (&(psf->header [psf->headindex]), bindata, 16) ;"
    },
    {
        "line": 195,
        "fullcodeline": "psf->headindex += 16 ;"
    },
    {
        "line": 196,
        "fullcodeline": "count += 16 ;"
    },
    {
        "line": 200,
        "fullcodeline": "size = va_arg (argptr, size_t) ;"
    },
    {
        "line": 201,
        "fullcodeline": "psf->headindex += size ;"
    },
    {
        "line": 202,
        "fullcodeline": "count += size ;"
    },
    {
        "line": 206,
        "fullcodeline": "size = va_arg (argptr, size_t) ;"
    },
    {
        "line": 214,
        "fullcodeline": "psf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;"
    },
    {
        "line": 215,
        "fullcodeline": "psf->error = SFE_INTERNAL ;"
    },
    {
        "line": 52,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 63,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 74,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 85,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)"
    },
    {
        "line": 108,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 118,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 131,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 148,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 175,
        "fullcodeline": "if (psf->headindex + size < sizeof (psf->header))"
    },
    {
        "line": 207,
        "fullcodeline": "if (size < sizeof (psf->header))"
    },
    {
        "line": 53,
        "fullcodeline": "{\theader_put_be_short (psf, data) ;"
    },
    {
        "line": 64,
        "fullcodeline": "{\theader_put_be_3byte (psf, data) ;"
    },
    {
        "line": 75,
        "fullcodeline": "{\theader_put_be_int (psf, data) ;"
    },
    {
        "line": 86,
        "fullcodeline": "{\theader_put_be_8byte (psf, countdata) ;"
    },
    {
        "line": 87,
        "fullcodeline": "count += 8 ;"
    },
    {
        "line": 109,
        "fullcodeline": "float32_be_write (floatdata, psf->header + psf->headindex) ;"
    },
    {
        "line": 119,
        "fullcodeline": "double64_be_write (doubledata, psf->header + psf->headindex) ;"
    },
    {
        "line": 132,
        "fullcodeline": "header_put_be_int (psf, size) ;"
    },
    {
        "line": 149,
        "fullcodeline": "header_put_be_int (psf, size) ;"
    },
    {
        "line": 176,
        "fullcodeline": "{\tmemcpy (&(psf->header [psf->headindex]), bindata, size) ;"
    },
    {
        "line": 177,
        "fullcodeline": "psf->headindex += size ;"
    },
    {
        "line": 178,
        "fullcodeline": "count += size ;"
    },
    {
        "line": 186,
        "fullcodeline": "{\tpsf->header [psf->headindex] = 0 ;"
    },
    {
        "line": 187,
        "fullcodeline": "psf->headindex ++ ;"
    },
    {
        "line": 188,
        "fullcodeline": "size -- ;"
    },
    {
        "line": 208,
        "fullcodeline": "{\tpsf->headindex = size ;"
    },
    {
        "line": 209,
        "fullcodeline": "count = 0 ;"
    },
    {
        "line": 56,
        "fullcodeline": "{\theader_put_le_short (psf, data) ;"
    },
    {
        "line": 67,
        "fullcodeline": "{\theader_put_le_3byte (psf, data) ;"
    },
    {
        "line": 78,
        "fullcodeline": "{\theader_put_le_int (psf, data) ;"
    },
    {
        "line": 111,
        "fullcodeline": "float32_le_write (floatdata, psf->header + psf->headindex) ;"
    },
    {
        "line": 121,
        "fullcodeline": "double64_le_write (doubledata, psf->header + psf->headindex) ;"
    },
    {
        "line": 134,
        "fullcodeline": "header_put_le_int (psf, size) ;"
    },
    {
        "line": 151,
        "fullcodeline": "header_put_le_int (psf, size) ;"
    },
    {
        "line": 89,
        "fullcodeline": "else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)"
    },
    {
        "line": 90,
        "fullcodeline": "{\theader_put_le_8byte (psf, countdata) ;"
    },
    {
        "line": 91,
        "fullcodeline": "count += 8 ;"
    },
    {
        "line": 93,
        "fullcodeline": "else if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)"
    },
    {
        "line": 94,
        "fullcodeline": "{\tlongdata = countdata & 0xFFFFFFFF ;"
    },
    {
        "line": 95,
        "fullcodeline": "header_put_be_int (psf, longdata) ;"
    },
    {
        "line": 96,
        "fullcodeline": "count += 4 ;"
    },
    {
        "line": 98,
        "fullcodeline": "else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)"
    },
    {
        "line": 99,
        "fullcodeline": "{\tlongdata = countdata & 0xFFFFFFFF ;"
    },
    {
        "line": 100,
        "fullcodeline": "header_put_le_int (psf, longdata) ;"
    },
    {
        "line": 101,
        "fullcodeline": "count += 4 ;"
    }
]