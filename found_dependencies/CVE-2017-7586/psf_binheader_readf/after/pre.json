[
    {
        "line": 4,
        "fullcodeline": "unsigned char\t*ucptr, sixteen_bytes [16] ;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t\t\t\tbyte_count = 0, count = 0 ;"
    },
    {
        "line": 16,
        "fullcodeline": "va_start (argptr, format) ;"
    },
    {
        "line": 13,
        "fullcodeline": "if (! format)"
    },
    {
        "line": 18,
        "fullcodeline": "while ((c = *format++))"
    },
    {
        "line": 14,
        "fullcodeline": "return psf_ftell (psf) ;"
    },
    {
        "line": 20,
        "fullcodeline": "if (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))"
    },
    {
        "line": 25,
        "fullcodeline": "psf->rwf_endian = SF_ENDIAN_LITTLE ;"
    },
    {
        "line": 29,
        "fullcodeline": "psf->rwf_endian = SF_ENDIAN_BIG ;"
    },
    {
        "line": 34,
        "fullcodeline": "*intptr = 0 ;"
    },
    {
        "line": 35,
        "fullcodeline": "ucptr = (unsigned char*) intptr ;"
    },
    {
        "line": 36,
        "fullcodeline": "byte_count += header_read (psf, ucptr, sizeof (int)) ;"
    },
    {
        "line": 42,
        "fullcodeline": "*intptr = 0 ;"
    },
    {
        "line": 44,
        "fullcodeline": "byte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;"
    },
    {
        "line": 55,
        "fullcodeline": "*charptr = 0 ;"
    },
    {
        "line": 56,
        "fullcodeline": "byte_count += header_read (psf, charptr, sizeof (char)) ;"
    },
    {
        "line": 61,
        "fullcodeline": "*shortptr = 0 ;"
    },
    {
        "line": 62,
        "fullcodeline": "ucptr = (unsigned char*) shortptr ;"
    },
    {
        "line": 63,
        "fullcodeline": "byte_count += header_read (psf, ucptr, sizeof (short)) ;"
    },
    {
        "line": 73,
        "fullcodeline": "byte_count += header_read (psf, sixteen_bytes, 3) ;"
    },
    {
        "line": 82,
        "fullcodeline": "*intptr = 0 ;"
    },
    {
        "line": 83,
        "fullcodeline": "ucptr = (unsigned char*) intptr ;"
    },
    {
        "line": 84,
        "fullcodeline": "byte_count += header_read (psf, ucptr, sizeof (int)) ;"
    },
    {
        "line": 94,
        "fullcodeline": "byte_count += header_read (psf, sixteen_bytes, 8) ;"
    },
    {
        "line": 104,
        "fullcodeline": "*floatptr = 0.0 ;"
    },
    {
        "line": 105,
        "fullcodeline": "byte_count += header_read (psf, floatptr, sizeof (float)) ;"
    },
    {
        "line": 114,
        "fullcodeline": "*doubleptr = 0.0 ;"
    },
    {
        "line": 115,
        "fullcodeline": "byte_count += header_read (psf, doubleptr, sizeof (double)) ;"
    },
    {
        "line": 123,
        "fullcodeline": "psf_log_printf (psf, \"Format conversion 's' not implemented yet.\\n\") ;"
    },
    {
        "line": 137,
        "fullcodeline": "count = va_arg (argptr, size_t) ;"
    },
    {
        "line": 138,
        "fullcodeline": "memset (charptr, 0, count) ;"
    },
    {
        "line": 139,
        "fullcodeline": "byte_count += header_read (psf, charptr, count) ;"
    },
    {
        "line": 144,
        "fullcodeline": "count = va_arg (argptr, size_t) ;"
    },
    {
        "line": 145,
        "fullcodeline": "memset (charptr, 0, count) ;"
    },
    {
        "line": 150,
        "fullcodeline": "byte_count += header_gets (psf, charptr, count) ;"
    },
    {
        "line": 154,
        "fullcodeline": "psf_log_printf (psf, \"Format conversion 'z' not implemented yet.\\n\") ;"
    },
    {
        "line": 166,
        "fullcodeline": "count = va_arg (argptr, size_t) ;"
    },
    {
        "line": 167,
        "fullcodeline": "header_seek (psf, count, SEEK_SET) ;"
    },
    {
        "line": 168,
        "fullcodeline": "byte_count = count ;"
    },
    {
        "line": 172,
        "fullcodeline": "count = va_arg (argptr, size_t) ;"
    },
    {
        "line": 173,
        "fullcodeline": "header_seek (psf, count, SEEK_CUR) ;"
    },
    {
        "line": 174,
        "fullcodeline": "byte_count += count ;"
    },
    {
        "line": 178,
        "fullcodeline": "psf_log_printf (psf, \"*** Invalid format specifier `%c'\\n\", c) ;"
    },
    {
        "line": 179,
        "fullcodeline": "psf->error = SFE_INTERNAL ;"
    },
    {
        "line": 37,
        "fullcodeline": "*intptr = GET_MARKER (ucptr) ;"
    },
    {
        "line": 46,
        "fullcodeline": "intdata = 0 ;"
    },
    {
        "line": 64,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 74,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 85,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 95,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 106,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 116,
        "fullcodeline": "if (psf->rwf_endian == SF_ENDIAN_BIG)"
    },
    {
        "line": 47,
        "fullcodeline": "for (k = 0 ; k < 16 ; k++)"
    },
    {
        "line": 48,
        "fullcodeline": "intdata ^= sixteen_bytes [k] << k ;"
    },
    {
        "line": 96,
        "fullcodeline": "countdata = psf_get_be64 (sixteen_bytes, 0) ;"
    },
    {
        "line": 147,
        "fullcodeline": "if (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))"
    },
    {
        "line": 65,
        "fullcodeline": "*shortptr = GET_BE_SHORT (ucptr) ;"
    },
    {
        "line": 75,
        "fullcodeline": "*intptr = GET_BE_3BYTE (sixteen_bytes) ;"
    },
    {
        "line": 86,
        "fullcodeline": "*intptr = psf_get_be32 (ucptr, 0) ;"
    },
    {
        "line": 98,
        "fullcodeline": "countdata = psf_get_le64 (sixteen_bytes, 0) ;"
    },
    {
        "line": 107,
        "fullcodeline": "*floatptr = float32_be_read ((unsigned char*) floatptr) ;"
    },
    {
        "line": 117,
        "fullcodeline": "*doubleptr = double64_be_read ((unsigned char*) doubleptr) ;"
    },
    {
        "line": 67,
        "fullcodeline": "*shortptr = GET_LE_SHORT (ucptr) ;"
    },
    {
        "line": 77,
        "fullcodeline": "*intptr = GET_LE_3BYTE (sixteen_bytes) ;"
    },
    {
        "line": 88,
        "fullcodeline": "*intptr = psf_get_le32 (ucptr, 0) ;"
    },
    {
        "line": 109,
        "fullcodeline": "*floatptr = float32_le_read ((unsigned char*) floatptr) ;"
    },
    {
        "line": 119,
        "fullcodeline": "*doubleptr = double64_le_read ((unsigned char*) doubleptr) ;"
    }
]