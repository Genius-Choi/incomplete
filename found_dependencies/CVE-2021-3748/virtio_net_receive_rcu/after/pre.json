[
    {
        "line": 4,
        "fullcodeline": "VirtIONet *n = qemu_get_nic_opaque(nc);"
    },
    {
        "line": 5,
        "fullcodeline": "VirtIONetQueue *q = virtio_net_get_subqueue(nc);"
    },
    {
        "line": 6,
        "fullcodeline": "VirtIODevice *vdev = VIRTIO_DEVICE(n);"
    },
    {
        "line": 7,
        "fullcodeline": "VirtQueueElement *elems[VIRTQUEUE_MAX_SIZE];"
    },
    {
        "line": 8,
        "fullcodeline": "size_t lens[VIRTQUEUE_MAX_SIZE];"
    },
    {
        "line": 9,
        "fullcodeline": "struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned mhdr_cnt = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "offset = i = 0;"
    },
    {
        "line": 130,
        "fullcodeline": "virtqueue_flush(q->rx_vq, i);"
    },
    {
        "line": 15,
        "fullcodeline": "if (!virtio_net_can_receive(nc)) {"
    },
    {
        "line": 37,
        "fullcodeline": "while (offset < size) {"
    },
    {
        "line": 124,
        "fullcodeline": "for (j = 0; j < i; j++) {"
    },
    {
        "line": 136,
        "fullcodeline": "for (j = 0; j < i; j++) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (!no_rss && n->rss_data.enabled && n->rss_data.enabled_software_rss) {"
    },
    {
        "line": 20,
        "fullcodeline": "int index = virtio_net_process_rss(nc, buf, size);"
    },
    {
        "line": 28,
        "fullcodeline": "if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (!receive_filter(n, buf, size))"
    },
    {
        "line": 42,
        "fullcodeline": "total = 0;"
    },
    {
        "line": 50,
        "fullcodeline": "elem = virtqueue_pop(q->rx_vq, sizeof(VirtQueueElement));"
    },
    {
        "line": 74,
        "fullcodeline": "sg = elem->in_sg;"
    },
    {
        "line": 98,
        "fullcodeline": "len = iov_from_buf(sg, elem->in_num, guest_offset,"
    },
    {
        "line": 100,
        "fullcodeline": "total += len;"
    },
    {
        "line": 101,
        "fullcodeline": "offset += len;"
    },
    {
        "line": 114,
        "fullcodeline": "i++;"
    },
    {
        "line": 118,
        "fullcodeline": "virtio_stw_p(vdev, &mhdr.num_buffers, i);"
    },
    {
        "line": 126,
        "fullcodeline": "virtqueue_fill(q->rx_vq, elems[j], lens[j], j);"
    },
    {
        "line": 127,
        "fullcodeline": "g_free(elems[j]);"
    },
    {
        "line": 16,
        "fullcodeline": "return -1;"
    },
    {
        "line": 21,
        "fullcodeline": "if (index >= 0) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (i == VIRTQUEUE_MAX_SIZE) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (!elem) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (elem->in_num < 1) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (i == 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "NetClientState *nc2 = qemu_get_subqueue(n->nic, index);"
    },
    {
        "line": 46,
        "fullcodeline": "err = size;"
    },
    {
        "line": 61,
        "fullcodeline": "err = -1;"
    },
    {
        "line": 68,
        "fullcodeline": "virtqueue_detach_element(q->rx_vq, elem, 0);"
    },
    {
        "line": 70,
        "fullcodeline": "err = -1;"
    },
    {
        "line": 84,
        "fullcodeline": "receive_header(n, sg, elem->in_num, buf, size);"
    },
    {
        "line": 90,
        "fullcodeline": "offset = n->host_hdr_len;"
    },
    {
        "line": 91,
        "fullcodeline": "total += n->guest_hdr_len;"
    },
    {
        "line": 92,
        "fullcodeline": "guest_offset = n->guest_hdr_len;"
    },
    {
        "line": 99,
        "fullcodeline": "buf + offset, size - offset);"
    },
    {
        "line": 105,
        "fullcodeline": "if (!n->mergeable_rx_bufs && offset < size) {"
    },
    {
        "line": 106,
        "fullcodeline": "virtqueue_unpop(q->rx_vq, elem, total);"
    },
    {
        "line": 108,
        "fullcodeline": "err = size;"
    },
    {
        "line": 23,
        "fullcodeline": "return virtio_net_receive_rcu(nc2, buf, size, true);"
    },
    {
        "line": 76,
        "fullcodeline": "assert(offset == 0);"
    },
    {
        "line": 94,
        "fullcodeline": "guest_offset = 0;"
    },
    {
        "line": 86,
        "fullcodeline": "offset = sizeof(mhdr);"
    },
    {
        "line": 87,
        "fullcodeline": "iov_from_buf(sg, elem->in_num, offset,"
    },
    {
        "line": 88,
        "fullcodeline": "buf + offset, n->host_hdr_len - sizeof(mhdr));"
    }
]