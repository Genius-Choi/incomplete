[
    {
        "line": 24,
        "fullcodeline": "sh.sh_len = CDF_TOLE4(shp->sh_len);"
    },
    {
        "line": 30,
        "fullcodeline": "sh.sh_properties = CDF_TOLE4(shp->sh_properties);"
    },
    {
        "line": 34,
        "fullcodeline": "DPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,"
    },
    {
        "line": 49,
        "fullcodeline": "*info = inp;"
    },
    {
        "line": 50,
        "fullcodeline": "inp += *count;"
    },
    {
        "line": 51,
        "fullcodeline": "*count += sh.sh_properties;"
    },
    {
        "line": 16,
        "fullcodeline": "if (offs > UINT32_MAX / 4) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)"
    },
    {
        "line": 26,
        "fullcodeline": "if (sh.sh_len > CDF_SHLEN_LIMIT) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (sh.sh_properties > CDF_PROP_LIMIT)"
    },
    {
        "line": 47,
        "fullcodeline": "if (inp == NULL)"
    },
    {
        "line": 57,
        "fullcodeline": "if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)"
    },
    {
        "line": 59,
        "fullcodeline": "for (i = 0; i < sh.sh_properties; i++) {"
    },
    {
        "line": 196,
        "fullcodeline": "return -1;"
    },
    {
        "line": 39,
        "fullcodeline": "*maxcount += sh.sh_properties;"
    },
    {
        "line": 60,
        "fullcodeline": "size_t tail = (i << 1) + 1;"
    },
    {
        "line": 64,
        "fullcodeline": "size_t ofs = CDF_GETUINT32(p, tail);"
    },
    {
        "line": 65,
        "fullcodeline": "q = (const uint8_t *)(const void *)"
    },
    {
        "line": 72,
        "fullcodeline": "inp[i].pi_id = CDF_GETUINT32(p, i << 1);"
    },
    {
        "line": 73,
        "fullcodeline": "inp[i].pi_type = CDF_GETUINT32(q, 0);"
    },
    {
        "line": 87,
        "fullcodeline": "o4 = o * sizeof(uint32_t);"
    },
    {
        "line": 37,
        "fullcodeline": "if (*maxcount > CDF_PROP_LIMIT)"
    },
    {
        "line": 43,
        "fullcodeline": "*maxcount = sh.sh_properties;"
    },
    {
        "line": 61,
        "fullcodeline": "if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),"
    },
    {
        "line": 68,
        "fullcodeline": "if (q > e) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))"
    },
    {
        "line": 90,
        "fullcodeline": "switch (inp[i].pi_type & CDF_TYPEMASK) {"
    },
    {
        "line": 62,
        "fullcodeline": "__LINE__) == -1)"
    },
    {
        "line": 77,
        "fullcodeline": "nelements = CDF_GETUINT32(q, 1);"
    },
    {
        "line": 82,
        "fullcodeline": "o = 2;"
    },
    {
        "line": 97,
        "fullcodeline": "(void)memcpy(&s16, &q[o4], sizeof(s16));"
    },
    {
        "line": 98,
        "fullcodeline": "inp[i].pi_s16 = CDF_TOLE2(s16);"
    },
    {
        "line": 103,
        "fullcodeline": "(void)memcpy(&s32, &q[o4], sizeof(s32));"
    },
    {
        "line": 104,
        "fullcodeline": "inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);"
    },
    {
        "line": 110,
        "fullcodeline": "(void)memcpy(&u32, &q[o4], sizeof(u32));"
    },
    {
        "line": 111,
        "fullcodeline": "inp[i].pi_u32 = CDF_TOLE4(u32);"
    },
    {
        "line": 116,
        "fullcodeline": "(void)memcpy(&s64, &q[o4], sizeof(s64));"
    },
    {
        "line": 117,
        "fullcodeline": "inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);"
    },
    {
        "line": 122,
        "fullcodeline": "(void)memcpy(&u64, &q[o4], sizeof(u64));"
    },
    {
        "line": 123,
        "fullcodeline": "inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);"
    },
    {
        "line": 128,
        "fullcodeline": "(void)memcpy(&u32, &q[o4], sizeof(u32));"
    },
    {
        "line": 129,
        "fullcodeline": "u32 = CDF_TOLE4(u32);"
    },
    {
        "line": 130,
        "fullcodeline": "memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));"
    },
    {
        "line": 135,
        "fullcodeline": "(void)memcpy(&u64, &q[o4], sizeof(u64));"
    },
    {
        "line": 136,
        "fullcodeline": "u64 = CDF_TOLE8((uint64_t)u64);"
    },
    {
        "line": 137,
        "fullcodeline": "memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));"
    },
    {
        "line": 174,
        "fullcodeline": "i--;"
    },
    {
        "line": 179,
        "fullcodeline": "(void)memcpy(&tp, &q[o4], sizeof(tp));"
    },
    {
        "line": 180,
        "fullcodeline": "inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);"
    },
    {
        "line": 188,
        "fullcodeline": "DPRINTF((\"Don't know how to deal with %x\\n\","
    },
    {
        "line": 66,
        "fullcodeline": "((const char *)(const void *)p + ofs"
    },
    {
        "line": 69,
        "fullcodeline": "DPRINTF((\"Ran of the end %p > %p\\n\", q, e));"
    },
    {
        "line": 78,
        "fullcodeline": "if (nelements == 0) {"
    },
    {
        "line": 84,
        "fullcodeline": "nelements = 1;"
    },
    {
        "line": 85,
        "fullcodeline": "o = 1;"
    },
    {
        "line": 95,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 101,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 108,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 114,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 120,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 126,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 133,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 141,
        "fullcodeline": "if (nelements > 1) {"
    },
    {
        "line": 156,
        "fullcodeline": "for (j = 0; j < nelements && i < sh.sh_properties;"
    },
    {
        "line": 157,
        "fullcodeline": "j++, i++)"
    },
    {
        "line": 177,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 183,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 67,
        "fullcodeline": "- 2 * sizeof(uint32_t));"
    },
    {
        "line": 142,
        "fullcodeline": "size_t nelem = inp - *info;"
    },
    {
        "line": 146,
        "fullcodeline": "*maxcount += nelements;"
    },
    {
        "line": 151,
        "fullcodeline": "*info = inp;"
    },
    {
        "line": 152,
        "fullcodeline": "inp = *info + nelem;"
    },
    {
        "line": 159,
        "fullcodeline": "uint32_t l = CDF_GETUINT32(q, o);"
    },
    {
        "line": 160,
        "fullcodeline": "inp[i].pi_str.s_len = l;"
    },
    {
        "line": 161,
        "fullcodeline": "inp[i].pi_str.s_buf = (const char *)"
    },
    {
        "line": 169,
        "fullcodeline": "o += l >> 1;"
    },
    {
        "line": 172,
        "fullcodeline": "o4 = o * sizeof(uint32_t);"
    },
    {
        "line": 143,
        "fullcodeline": "if (*maxcount > CDF_PROP_LIMIT"
    },
    {
        "line": 149,
        "fullcodeline": "if (inp == NULL)"
    },
    {
        "line": 167,
        "fullcodeline": "if (l & 1)"
    },
    {
        "line": 170,
        "fullcodeline": "if (q + o >= e)"
    },
    {
        "line": 144,
        "fullcodeline": "|| nelements > CDF_PROP_LIMIT)"
    },
    {
        "line": 162,
        "fullcodeline": "(const void *)(&q[o4 + sizeof(l)]);"
    },
    {
        "line": 168,
        "fullcodeline": "l++;"
    }
]