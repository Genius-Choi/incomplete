[
    {
        "line": 6,
        "fullcodeline": "unsigned char ujpg_mrk[ 64 ];"
    },
    {
        "line": 8,
        "fullcodeline": "write_byte_bill(Billing::HEADER, true, 24); // for the fixed header"
    },
    {
        "line": 10,
        "fullcodeline": "str_out->call_size_callback(max_file_size);"
    },
    {
        "line": 11,
        "fullcodeline": "uint32_t compressed_header_size = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "write_byte_bill(Billing::HEADER, true, 4);"
    },
    {
        "line": 17,
        "fullcodeline": "compressed_header_size = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 22,
        "fullcodeline": "bool pending_header_reads = false;"
    },
    {
        "line": 75,
        "fullcodeline": "grbgdata = EOI; // if we don't have any garbage, assume FFD9 EOI"
    },
    {
        "line": 77,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 3 ) ;"
    },
    {
        "line": 98,
        "fullcodeline": "bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;"
    },
    {
        "line": 106,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 3 );"
    },
    {
        "line": 132,
        "fullcodeline": "std::vector<ThreadHandoff> thread_handoff;"
    },
    {
        "line": 228,
        "fullcodeline": "write_byte_bill(Billing::HEADER,"
    },
    {
        "line": 232,
        "fullcodeline": "ReadFull(str_in, ujpg_mrk, 3 ) ;"
    },
    {
        "line": 233,
        "fullcodeline": "write_byte_bill(Billing::HEADER, true, 3);"
    },
    {
        "line": 235,
        "fullcodeline": "write_byte_bill(Billing::DELIMITERS, true, 4 * NUM_THREADS); // trailing vpx_encode bits"
    },
    {
        "line": 236,
        "fullcodeline": "write_byte_bill(Billing::HEADER, true, 4); //trailing size"
    },
    {
        "line": 242,
        "fullcodeline": "colldata.signal_worker_should_begin();"
    },
    {
        "line": 243,
        "fullcodeline": "g_decoder->initialize(str_in, thread_handoff);"
    },
    {
        "line": 244,
        "fullcodeline": "colldata.start_decoder(g_decoder);"
    },
    {
        "line": 12,
        "fullcodeline": "if (ReadFull(str_in, ujpg_mrk, 4) != 4) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (header_reader == NULL) {"
    },
    {
        "line": 79,
        "fullcodeline": "if ( memcmp( ujpg_mrk, \"HDR\", 3 ) == 0 ) {"
    },
    {
        "line": 100,
        "fullcodeline": "if ( !setup_imginfo_jpg(memory_optimized_image) )"
    },
    {
        "line": 108,
        "fullcodeline": "if ( memcmp( ujpg_mrk, \"P0D\", 3 ) == 0 ) {"
    },
    {
        "line": 134,
        "fullcodeline": "while ( ReadFull(header_reader, ujpg_mrk, 3 ) == 3 ) {"
    },
    {
        "line": 224,
        "fullcodeline": "if (!pending_header_reads) {"
    },
    {
        "line": 230,
        "fullcodeline": "2 + hdrs + prefix_grbs + grbs);"
    },
    {
        "line": 238,
        "fullcodeline": "if (memcmp(ujpg_mrk, \"CMP\", 3) != 0) {"
    },
    {
        "line": 19,
        "fullcodeline": "always_assert(false && \"Only support images < 128 megs\");"
    },
    {
        "line": 24,
        "fullcodeline": "std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);"
    },
    {
        "line": 25,
        "fullcodeline": "IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());"
    },
    {
        "line": 26,
        "fullcodeline": "header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));"
    },
    {
        "line": 68,
        "fullcodeline": "write_byte_bill(Billing::HEADER,"
    },
    {
        "line": 81,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4 );"
    },
    {
        "line": 82,
        "fullcodeline": "hdrs = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 83,
        "fullcodeline": "hdrdata = (unsigned char*) aligned_alloc(hdrs);"
    },
    {
        "line": 84,
        "fullcodeline": "memset(hdrdata, 0, hdrs);"
    },
    {
        "line": 91,
        "fullcodeline": "ReadFull(header_reader, hdrdata, hdrs );"
    },
    {
        "line": 110,
        "fullcodeline": "header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );"
    },
    {
        "line": 225,
        "fullcodeline": "delete header_reader;"
    },
    {
        "line": 226,
        "fullcodeline": "header_reader = NULL;"
    },
    {
        "line": 239,
        "fullcodeline": "always_assert(false && \"CMP must be present (uncompressed) in the file or CNT continue marker\");"
    },
    {
        "line": 70,
        "fullcodeline": "compressed_header_buffer.size());"
    },
    {
        "line": 72,
        "fullcodeline": "always_assert(compressed_header_size == 0 && \"Special concatenation requires 0 size header\");"
    },
    {
        "line": 85,
        "fullcodeline": "if ( hdrdata == NULL ) {"
    },
    {
        "line": 94,
        "fullcodeline": "fprintf( stderr, \"HDR marker not found\" );"
    },
    {
        "line": 95,
        "fullcodeline": "errorlevel.store(2);"
    },
    {
        "line": 136,
        "fullcodeline": "if ( memcmp( ujpg_mrk, \"CRS\", 3 ) == 0 ) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (ujgversion == 1) {"
    },
    {
        "line": 86,
        "fullcodeline": "fprintf( stderr, MEM_ERRMSG );"
    },
    {
        "line": 87,
        "fullcodeline": "errorlevel.store(2);"
    },
    {
        "line": 112,
        "fullcodeline": "else if ( memcmp( ujpg_mrk, \"PAD\", 3 ) == 0 ) {"
    },
    {
        "line": 137,
        "fullcodeline": "rst_cnt_set = true;"
    },
    {
        "line": 138,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4);"
    },
    {
        "line": 139,
        "fullcodeline": "rst_cnt.resize(LEtoUint32(ujpg_mrk));"
    },
    {
        "line": 29,
        "fullcodeline": "JpegAllocator<uint8_t> no_free_allocator;"
    },
    {
        "line": 31,
        "fullcodeline": "no_free_allocator.setup_memory_subsystem(32 * 1024 * 1024,"
    },
    {
        "line": 41,
        "fullcodeline": "JpegError> uncompressed_header_buffer("
    },
    {
        "line": 50,
        "fullcodeline": "zlib_hdrs = compressed_header_buffer.size();"
    },
    {
        "line": 51,
        "fullcodeline": "header_reader->SwapIn(uncompressed_header_buffer.first, 0);"
    },
    {
        "line": 114,
        "fullcodeline": "header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );"
    },
    {
        "line": 140,
        "fullcodeline": "for (size_t i = 0; i < rst_cnt.size(); ++i) {"
    },
    {
        "line": 42,
        "fullcodeline": "ZlibDecoderDecompressionReader::Decompress(compressed_header_buffer.data(),"
    },
    {
        "line": 55,
        "fullcodeline": "JpegError> uncompressed_header_buffer("
    },
    {
        "line": 64,
        "fullcodeline": "zlib_hdrs = compressed_header_buffer.size();"
    },
    {
        "line": 65,
        "fullcodeline": "header_reader->SwapIn(uncompressed_header_buffer.first, 0);"
    },
    {
        "line": 115,
        "fullcodeline": "if (!(padbit == 0 || padbit == 1 ||padbit == -1)) {"
    },
    {
        "line": 123,
        "fullcodeline": "if (padbit == 1) {"
    },
    {
        "line": 128,
        "fullcodeline": "fprintf( stderr, \"PAD marker not found\" );"
    },
    {
        "line": 129,
        "fullcodeline": "errorlevel.store(2);"
    },
    {
        "line": 141,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4);"
    },
    {
        "line": 142,
        "fullcodeline": "rst_cnt.at(i) = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 144,
        "fullcodeline": "} else if ( memcmp( ujpg_mrk, \"HHX\", 2 ) == 0 ) { // only look at first two bytes"
    },
    {
        "line": 43,
        "fullcodeline": "compressed_header_buffer.size(),"
    },
    {
        "line": 45,
        "fullcodeline": "max_file_size + 2048));"
    },
    {
        "line": 47,
        "fullcodeline": "always_assert(false && \"Data not properly zlib coded\");"
    },
    {
        "line": 56,
        "fullcodeline": "Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),"
    },
    {
        "line": 124,
        "fullcodeline": "padbit = 0x7f; // all 6 bits set"
    },
    {
        "line": 145,
        "fullcodeline": "size_t to_alloc = ThreadHandoff::get_remaining_data_size_from_two_bytes(ujpg_mrk + 1) + 2;"
    },
    {
        "line": 57,
        "fullcodeline": "compressed_header_buffer.size(),"
    },
    {
        "line": 59,
        "fullcodeline": "((size_t)max_file_size) * 2 + 128 * 1024 * 1024));"
    },
    {
        "line": 61,
        "fullcodeline": "always_assert(false && \"Data not properly zlib coded\");"
    },
    {
        "line": 116,
        "fullcodeline": "while (write(2,"
    },
    {
        "line": 119,
        "fullcodeline": "&& errno == EINTR) {"
    },
    {
        "line": 147,
        "fullcodeline": "std::vector<unsigned char> data(to_alloc);"
    },
    {
        "line": 148,
        "fullcodeline": "data[0] = ujpg_mrk[1];"
    },
    {
        "line": 149,
        "fullcodeline": "data[1] = ujpg_mrk[2];"
    },
    {
        "line": 150,
        "fullcodeline": "ReadFull(header_reader, &data[2], to_alloc - 2);"
    },
    {
        "line": 151,
        "fullcodeline": "thread_handoff = ThreadHandoff::deserialize(&data[0], to_alloc);"
    },
    {
        "line": 153,
        "fullcodeline": "} else if ( memcmp( ujpg_mrk, \"FRS\", 3 ) == 0 ) {"
    },
    {
        "line": 155,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4);"
    },
    {
        "line": 156,
        "fullcodeline": "scnc = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 158,
        "fullcodeline": "rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);"
    },
    {
        "line": 160,
        "fullcodeline": "ReadFull(header_reader, rst_err.data(), scnc );"
    },
    {
        "line": 118,
        "fullcodeline": "strlen(\"Legacy Padbit must be 0, 1 or -1\\n\")) < 0"
    },
    {
        "line": 162,
        "fullcodeline": "else if ( memcmp( ujpg_mrk, \"GRB\", 3 ) == 0 ) {"
    },
    {
        "line": 164,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4);"
    },
    {
        "line": 165,
        "fullcodeline": "grbs = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 166,
        "fullcodeline": "grbgdata = aligned_alloc(grbs);"
    },
    {
        "line": 167,
        "fullcodeline": "memset(grbgdata, 0, sizeof(grbs));"
    },
    {
        "line": 174,
        "fullcodeline": "ReadFull(header_reader, grbgdata, grbs );"
    },
    {
        "line": 168,
        "fullcodeline": "if ( grbgdata == NULL ) {"
    },
    {
        "line": 169,
        "fullcodeline": "fprintf( stderr, MEM_ERRMSG );"
    },
    {
        "line": 170,
        "fullcodeline": "errorlevel.store(2);"
    },
    {
        "line": 176,
        "fullcodeline": "else if ( memcmp( ujpg_mrk, \"PGR\", 3 ) == 0 || memcmp( ujpg_mrk, \"PGE\", 3 ) == 0 ) {"
    },
    {
        "line": 182,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4);"
    },
    {
        "line": 183,
        "fullcodeline": "prefix_grbs = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 184,
        "fullcodeline": "prefix_grbgdata = aligned_alloc(prefix_grbs);"
    },
    {
        "line": 185,
        "fullcodeline": "memset(prefix_grbgdata, 0, sizeof(prefix_grbs));"
    },
    {
        "line": 192,
        "fullcodeline": "ReadFull(header_reader, prefix_grbgdata, prefix_grbs );"
    },
    {
        "line": 178,
        "fullcodeline": "if (ujpg_mrk[2] == 'E') {"
    },
    {
        "line": 186,
        "fullcodeline": "if ( prefix_grbgdata == NULL ) {"
    },
    {
        "line": 180,
        "fullcodeline": "embedded_jpeg = true;"
    },
    {
        "line": 187,
        "fullcodeline": "fprintf( stderr, MEM_ERRMSG );"
    },
    {
        "line": 188,
        "fullcodeline": "errorlevel.store(2);"
    },
    {
        "line": 194,
        "fullcodeline": "else if ( memcmp( ujpg_mrk, \"SIZ\", 3 ) == 0 ) {"
    },
    {
        "line": 196,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 4);"
    },
    {
        "line": 197,
        "fullcodeline": "max_file_size = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 199,
        "fullcodeline": "else if ( memcmp( ujpg_mrk, \"EEE\", 3) == 0) {"
    },
    {
        "line": 200,
        "fullcodeline": "ReadFull(header_reader, ujpg_mrk, 28);"
    },
    {
        "line": 201,
        "fullcodeline": "max_cmp = LEtoUint32(ujpg_mrk);"
    },
    {
        "line": 202,
        "fullcodeline": "max_bpos = LEtoUint32(ujpg_mrk + 4);"
    },
    {
        "line": 203,
        "fullcodeline": "max_sah = LEtoUint32(ujpg_mrk + 8);"
    },
    {
        "line": 204,
        "fullcodeline": "max_dpos[0] = LEtoUint32(ujpg_mrk + 12);"
    },
    {
        "line": 205,
        "fullcodeline": "max_dpos[1] = LEtoUint32(ujpg_mrk + 16);"
    },
    {
        "line": 206,
        "fullcodeline": "max_dpos[2] = LEtoUint32(ujpg_mrk + 20);"
    },
    {
        "line": 207,
        "fullcodeline": "max_dpos[3] = LEtoUint32(ujpg_mrk + 24);"
    },
    {
        "line": 208,
        "fullcodeline": "early_eof_encountered = true;"
    },
    {
        "line": 209,
        "fullcodeline": "colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);"
    },
    {
        "line": 212,
        "fullcodeline": "if (memcmp(ujpg_mrk, \"CNT\", 3) == 0 ) {"
    },
    {
        "line": 213,
        "fullcodeline": "pending_header_reads = true;"
    },
    {
        "line": 215,
        "fullcodeline": "} else if (memcmp(ujpg_mrk, \"CMP\", 3) == 0 ) {"
    },
    {
        "line": 218,
        "fullcodeline": "fprintf( stderr, \"unknown data found\" );"
    },
    {
        "line": 219,
        "fullcodeline": "errorlevel.store(2);"
    }
]