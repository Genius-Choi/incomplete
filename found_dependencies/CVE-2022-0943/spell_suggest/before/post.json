[
    {
        "line": 5,
        "fullcodeline": "char_u\twcopy[MAXWLEN + 2];"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tselected = count;"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tbadlen = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tmsg_scroll_save = msg_scroll;"
    },
    {
        "line": 75,
        "fullcodeline": "need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);"
    },
    {
        "line": 78,
        "fullcodeline": "line = vim_strsave(ml_get_curline());"
    },
    {
        "line": 88,
        "fullcodeline": "spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,"
    },
    {
        "line": 240,
        "fullcodeline": "spell_find_cleanup(&sug);"
    },
    {
        "line": 242,
        "fullcodeline": "vim_free(line);"
    },
    {
        "line": 243,
        "fullcodeline": "curwin->w_p_spell = wo_spell_save;"
    },
    {
        "line": 25,
        "fullcodeline": "if (*curwin->w_s->b_p_spl == NUL)"
    },
    {
        "line": 79,
        "fullcodeline": "if (line == NULL)"
    },
    {
        "line": 84,
        "fullcodeline": "if (sps_limit > (int)Rows - 2)"
    },
    {
        "line": 91,
        "fullcodeline": "if (sug.su_ga.ga_len == 0)"
    },
    {
        "line": 190,
        "fullcodeline": "if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)"
    },
    {
        "line": 21,
        "fullcodeline": "did_set_spelllang(curwin);"
    },
    {
        "line": 22,
        "fullcodeline": "curwin->w_p_spell = TRUE;"
    },
    {
        "line": 27,
        "fullcodeline": "emsg(_(e_spell_checking_is_not_possible));"
    },
    {
        "line": 40,
        "fullcodeline": "badlen = (int)curwin->w_cursor.col - (int)VIsual.col;"
    },
    {
        "line": 45,
        "fullcodeline": "++badlen;"
    },
    {
        "line": 46,
        "fullcodeline": "end_visual_mode();"
    },
    {
        "line": 85,
        "fullcodeline": "limit = (int)Rows - 2;"
    },
    {
        "line": 92,
        "fullcodeline": "msg(_(\"Sorry, no suggestions\"));"
    },
    {
        "line": 193,
        "fullcodeline": "VIM_CLEAR(repl_from);"
    },
    {
        "line": 194,
        "fullcodeline": "VIM_CLEAR(repl_to);"
    },
    {
        "line": 196,
        "fullcodeline": "stp = &SUG(sug.su_ga, selected - 1);"
    },
    {
        "line": 215,
        "fullcodeline": "p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);"
    },
    {
        "line": 41,
        "fullcodeline": "if (badlen < 0)"
    },
    {
        "line": 87,
        "fullcodeline": "limit = sps_limit;"
    },
    {
        "line": 197,
        "fullcodeline": "if (sug.su_badlen > stp->st_orglen)"
    },
    {
        "line": 216,
        "fullcodeline": "if (p != NULL)"
    },
    {
        "line": 238,
        "fullcodeline": "curwin->w_cursor = prev_cursor;"
    },
    {
        "line": 37,
        "fullcodeline": "vim_beep(BO_SPELL);"
    },
    {
        "line": 42,
        "fullcodeline": "badlen = -badlen;"
    },
    {
        "line": 49,
        "fullcodeline": "else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0"
    },
    {
        "line": 93,
        "fullcodeline": "else if (count > 0)"
    },
    {
        "line": 201,
        "fullcodeline": "repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);"
    },
    {
        "line": 202,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,"
    },
    {
        "line": 205,
        "fullcodeline": "repl_to = vim_strsave(IObuff);"
    },
    {
        "line": 218,
        "fullcodeline": "c = (int)(sug.su_badptr - line);"
    },
    {
        "line": 219,
        "fullcodeline": "mch_memmove(p, line, c);"
    },
    {
        "line": 220,
        "fullcodeline": "STRCPY(p + c, stp->st_word);"
    },
    {
        "line": 221,
        "fullcodeline": "STRCAT(p, sug.su_badptr + stp->st_orglen);"
    },
    {
        "line": 224,
        "fullcodeline": "ResetRedobuff();"
    },
    {
        "line": 225,
        "fullcodeline": "AppendToRedobuff((char_u *)\"ciw\");"
    },
    {
        "line": 226,
        "fullcodeline": "AppendToRedobuffLit(p + c,"
    },
    {
        "line": 228,
        "fullcodeline": "AppendCharToRedobuff(ESC);"
    },
    {
        "line": 231,
        "fullcodeline": "ml_replace(curwin->w_cursor.lnum, p, FALSE);"
    },
    {
        "line": 232,
        "fullcodeline": "curwin->w_cursor.col = c;"
    },
    {
        "line": 234,
        "fullcodeline": "changed_bytes(curwin->w_cursor.lnum, c);"
    },
    {
        "line": 50,
        "fullcodeline": "|| curwin->w_cursor.col > prev_cursor.col)"
    },
    {
        "line": 54,
        "fullcodeline": "curwin->w_cursor = prev_cursor;"
    },
    {
        "line": 55,
        "fullcodeline": "line = ml_get_curline();"
    },
    {
        "line": 56,
        "fullcodeline": "p = line + curwin->w_cursor.col;"
    },
    {
        "line": 69,
        "fullcodeline": "curwin->w_cursor.col = (colnr_T)(p - line);"
    },
    {
        "line": 203,
        "fullcodeline": "sug.su_badlen - stp->st_orglen,"
    },
    {
        "line": 204,
        "fullcodeline": "sug.su_badptr + stp->st_orglen);"
    },
    {
        "line": 210,
        "fullcodeline": "repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);"
    },
    {
        "line": 211,
        "fullcodeline": "repl_to = vim_strsave(stp->st_word);"
    },
    {
        "line": 227,
        "fullcodeline": "stp->st_wordlen + sug.su_badlen - stp->st_orglen);"
    },
    {
        "line": 58,
        "fullcodeline": "while (p > line && spell_iswordp_nmw(p, curwin))"
    },
    {
        "line": 59,
        "fullcodeline": "MB_PTR_BACK(line, p);"
    },
    {
        "line": 61,
        "fullcodeline": "while (*p != NUL && !spell_iswordp_nmw(p, curwin))"
    },
    {
        "line": 62,
        "fullcodeline": "MB_PTR_ADV(p);"
    },
    {
        "line": 64,
        "fullcodeline": "if (!spell_iswordp_nmw(p, curwin))\t\t// No word found."
    },
    {
        "line": 95,
        "fullcodeline": "if (count > sug.su_ga.ga_len)"
    },
    {
        "line": 108,
        "fullcodeline": "msg_start();"
    },
    {
        "line": 109,
        "fullcodeline": "msg_row = Rows - 1;\t// for when 'cmdheight' > 1"
    },
    {
        "line": 110,
        "fullcodeline": "lines_left = Rows;\t// avoid more prompt"
    },
    {
        "line": 111,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),"
    },
    {
        "line": 122,
        "fullcodeline": "msg_puts((char *)IObuff);"
    },
    {
        "line": 123,
        "fullcodeline": "msg_clr_eos();"
    },
    {
        "line": 124,
        "fullcodeline": "msg_putchar('\\n');"
    },
    {
        "line": 126,
        "fullcodeline": "msg_scroll = TRUE;"
    },
    {
        "line": 182,
        "fullcodeline": "selected = prompt_for_number(&mouse_used);"
    },
    {
        "line": 185,
        "fullcodeline": "lines_left = Rows;\t\t// avoid more prompt"
    },
    {
        "line": 187,
        "fullcodeline": "msg_scroll = msg_scroll_save;"
    },
    {
        "line": 66,
        "fullcodeline": "beep_flush();"
    },
    {
        "line": 96,
        "fullcodeline": "smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);"
    },
    {
        "line": 127,
        "fullcodeline": "for (i = 0; i < sug.su_ga.ga_len; ++i)"
    },
    {
        "line": 129,
        "fullcodeline": "stp = &SUG(sug.su_ga, i);"
    },
    {
        "line": 133,
        "fullcodeline": "vim_strncpy(wcopy, stp->st_word, MAXWLEN);"
    },
    {
        "line": 138,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);"
    },
    {
        "line": 143,
        "fullcodeline": "msg_puts((char *)IObuff);"
    },
    {
        "line": 145,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);"
    },
    {
        "line": 146,
        "fullcodeline": "msg_puts((char *)IObuff);"
    },
    {
        "line": 174,
        "fullcodeline": "msg_putchar('\\n');"
    },
    {
        "line": 184,
        "fullcodeline": "selected -= lines_left;"
    },
    {
        "line": 134,
        "fullcodeline": "if (sug.su_badlen > stp->st_orglen)"
    },
    {
        "line": 149,
        "fullcodeline": "if (sug.su_badlen < stp->st_orglen)"
    },
    {
        "line": 156,
        "fullcodeline": "if (p_verbose > 0)"
    },
    {
        "line": 135,
        "fullcodeline": "vim_strncpy(wcopy + stp->st_wordlen,"
    },
    {
        "line": 151,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),"
    },
    {
        "line": 153,
        "fullcodeline": "msg_puts((char *)IObuff);"
    },
    {
        "line": 171,
        "fullcodeline": "msg_advance(30);"
    },
    {
        "line": 172,
        "fullcodeline": "msg_puts((char *)IObuff);"
    },
    {
        "line": 136,
        "fullcodeline": "sug.su_badptr + stp->st_orglen,"
    },
    {
        "line": 137,
        "fullcodeline": "sug.su_badlen - stp->st_orglen);"
    },
    {
        "line": 159,
        "fullcodeline": "if (sps_flags & (SPS_DOUBLE | SPS_BEST))"
    },
    {
        "line": 160,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\","
    },
    {
        "line": 161,
        "fullcodeline": "stp->st_salscore ? \"s \" : \"\","
    },
    {
        "line": 164,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\","
    }
]