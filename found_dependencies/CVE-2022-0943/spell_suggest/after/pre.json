[
    {
        "line": 4,
        "fullcodeline": "pos_T\tprev_cursor = curwin->w_cursor;"
    },
    {
        "line": 5,
        "fullcodeline": "char_u\twcopy[MAXWLEN + 2];"
    },
    {
        "line": 14,
        "fullcodeline": "int\t\tselected = count;"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\tbadlen = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "int\t\tmsg_scroll_save = msg_scroll;"
    },
    {
        "line": 17,
        "fullcodeline": "int\t\two_spell_save = curwin->w_p_spell;"
    },
    {
        "line": 79,
        "fullcodeline": "need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);"
    },
    {
        "line": 82,
        "fullcodeline": "line = vim_strsave(ml_get_curline());"
    },
    {
        "line": 92,
        "fullcodeline": "spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,"
    },
    {
        "line": 19,
        "fullcodeline": "if (!curwin->w_p_spell)"
    },
    {
        "line": 25,
        "fullcodeline": "if (*curwin->w_s->b_p_spl == NUL)"
    },
    {
        "line": 83,
        "fullcodeline": "if (line == NULL)"
    },
    {
        "line": 88,
        "fullcodeline": "if (sps_limit > (int)Rows - 2)"
    },
    {
        "line": 95,
        "fullcodeline": "if (sug.su_ga.ga_len == 0)"
    },
    {
        "line": 21,
        "fullcodeline": "did_set_spelllang(curwin);"
    },
    {
        "line": 22,
        "fullcodeline": "curwin->w_p_spell = TRUE;"
    },
    {
        "line": 27,
        "fullcodeline": "emsg(_(e_spell_checking_is_not_possible));"
    },
    {
        "line": 40,
        "fullcodeline": "badlen = (int)curwin->w_cursor.col - (int)VIsual.col;"
    },
    {
        "line": 45,
        "fullcodeline": "++badlen;"
    },
    {
        "line": 48,
        "fullcodeline": "line = ml_get_curline();"
    },
    {
        "line": 89,
        "fullcodeline": "limit = (int)Rows - 2;"
    },
    {
        "line": 194,
        "fullcodeline": "if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)"
    },
    {
        "line": 200,
        "fullcodeline": "stp = &SUG(sug.su_ga, selected - 1);"
    },
    {
        "line": 219,
        "fullcodeline": "p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);"
    },
    {
        "line": 35,
        "fullcodeline": "if (curwin->w_cursor.lnum != VIsual.lnum)"
    },
    {
        "line": 41,
        "fullcodeline": "if (badlen < 0)"
    },
    {
        "line": 49,
        "fullcodeline": "if (badlen > STRLEN(line) - curwin->w_cursor.col)"
    },
    {
        "line": 91,
        "fullcodeline": "limit = sps_limit;"
    },
    {
        "line": 96,
        "fullcodeline": "msg(_(\"Sorry, no suggestions\"));"
    },
    {
        "line": 201,
        "fullcodeline": "if (sug.su_badlen > stp->st_orglen)"
    },
    {
        "line": 220,
        "fullcodeline": "if (p != NULL)"
    },
    {
        "line": 37,
        "fullcodeline": "vim_beep(BO_SPELL);"
    },
    {
        "line": 42,
        "fullcodeline": "badlen = -badlen;"
    },
    {
        "line": 50,
        "fullcodeline": "badlen = STRLEN(line) - curwin->w_cursor.col;"
    },
    {
        "line": 97,
        "fullcodeline": "else if (count > 0)"
    },
    {
        "line": 206,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,"
    },
    {
        "line": 222,
        "fullcodeline": "c = (int)(sug.su_badptr - line);"
    },
    {
        "line": 223,
        "fullcodeline": "mch_memmove(p, line, c);"
    },
    {
        "line": 225,
        "fullcodeline": "STRCAT(p, sug.su_badptr + stp->st_orglen);"
    },
    {
        "line": 232,
        "fullcodeline": "AppendCharToRedobuff(ESC);"
    },
    {
        "line": 235,
        "fullcodeline": "ml_replace(curwin->w_cursor.lnum, p, FALSE);"
    },
    {
        "line": 44,
        "fullcodeline": "curwin->w_cursor.col = VIsual.col;"
    },
    {
        "line": 53,
        "fullcodeline": "else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0"
    },
    {
        "line": 54,
        "fullcodeline": "|| curwin->w_cursor.col > prev_cursor.col)"
    },
    {
        "line": 58,
        "fullcodeline": "curwin->w_cursor = prev_cursor;"
    },
    {
        "line": 59,
        "fullcodeline": "line = ml_get_curline();"
    },
    {
        "line": 60,
        "fullcodeline": "p = line + curwin->w_cursor.col;"
    },
    {
        "line": 73,
        "fullcodeline": "curwin->w_cursor.col = (colnr_T)(p - line);"
    },
    {
        "line": 205,
        "fullcodeline": "repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);"
    },
    {
        "line": 207,
        "fullcodeline": "sug.su_badlen - stp->st_orglen,"
    },
    {
        "line": 209,
        "fullcodeline": "repl_to = vim_strsave(IObuff);"
    },
    {
        "line": 231,
        "fullcodeline": "stp->st_wordlen + sug.su_badlen - stp->st_orglen);"
    },
    {
        "line": 63,
        "fullcodeline": "MB_PTR_BACK(line, p);"
    },
    {
        "line": 66,
        "fullcodeline": "MB_PTR_ADV(p);"
    },
    {
        "line": 99,
        "fullcodeline": "if (count > sug.su_ga.ga_len)"
    },
    {
        "line": 113,
        "fullcodeline": "msg_row = Rows - 1;\t// for when 'cmdheight' > 1"
    },
    {
        "line": 114,
        "fullcodeline": "lines_left = Rows;\t// avoid more prompt"
    },
    {
        "line": 115,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),"
    },
    {
        "line": 186,
        "fullcodeline": "selected = prompt_for_number(&mouse_used);"
    },
    {
        "line": 214,
        "fullcodeline": "repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);"
    },
    {
        "line": 215,
        "fullcodeline": "repl_to = vim_strsave(stp->st_word);"
    },
    {
        "line": 62,
        "fullcodeline": "while (p > line && spell_iswordp_nmw(p, curwin))"
    },
    {
        "line": 65,
        "fullcodeline": "while (*p != NUL && !spell_iswordp_nmw(p, curwin))"
    },
    {
        "line": 68,
        "fullcodeline": "if (!spell_iswordp_nmw(p, curwin))\t\t// No word found."
    },
    {
        "line": 131,
        "fullcodeline": "for (i = 0; i < sug.su_ga.ga_len; ++i)"
    },
    {
        "line": 100,
        "fullcodeline": "smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);"
    },
    {
        "line": 133,
        "fullcodeline": "stp = &SUG(sug.su_ga, i);"
    },
    {
        "line": 137,
        "fullcodeline": "vim_strncpy(wcopy, stp->st_word, MAXWLEN);"
    },
    {
        "line": 142,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);"
    },
    {
        "line": 149,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);"
    },
    {
        "line": 188,
        "fullcodeline": "selected -= lines_left;"
    },
    {
        "line": 138,
        "fullcodeline": "if (sug.su_badlen > stp->st_orglen)"
    },
    {
        "line": 153,
        "fullcodeline": "if (sug.su_badlen < stp->st_orglen)"
    },
    {
        "line": 160,
        "fullcodeline": "if (p_verbose > 0)"
    },
    {
        "line": 155,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),"
    },
    {
        "line": 141,
        "fullcodeline": "sug.su_badlen - stp->st_orglen);"
    },
    {
        "line": 163,
        "fullcodeline": "if (sps_flags & (SPS_DOUBLE | SPS_BEST))"
    },
    {
        "line": 164,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\","
    },
    {
        "line": 168,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\","
    }
]