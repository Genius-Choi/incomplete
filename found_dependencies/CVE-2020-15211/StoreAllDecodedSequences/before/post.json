[
    {
        "line": 5,
        "fullcodeline": "const int32_t batch_size = sequences.size();"
    },
    {
        "line": 6,
        "fullcodeline": "std::vector<int32_t> num_entries(top_paths, 0);"
    },
    {
        "line": 16,
        "fullcodeline": "for (int p = 0; p < top_paths; ++p) {"
    },
    {
        "line": 10,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);"
    },
    {
        "line": 17,
        "fullcodeline": "const int32_t p_num = num_entries[p];"
    },
    {
        "line": 20,
        "fullcodeline": "TfLiteTensor* indices = GetOutput(context, node, p);"
    },
    {
        "line": 21,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));"
    },
    {
        "line": 23,
        "fullcodeline": "TfLiteTensor* values = GetOutput(context, node, p + top_paths);"
    },
    {
        "line": 24,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));"
    },
    {
        "line": 26,
        "fullcodeline": "TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);"
    },
    {
        "line": 27,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));"
    },
    {
        "line": 29,
        "fullcodeline": "int32_t max_decoded = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "int32_t offset = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "int32_t* indices_data = GetTensorData<int32_t>(indices);"
    },
    {
        "line": 33,
        "fullcodeline": "int32_t* values_data = GetTensorData<int32_t>(values);"
    },
    {
        "line": 34,
        "fullcodeline": "int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);"
    },
    {
        "line": 47,
        "fullcodeline": "decoded_shape_data[0] = batch_size;"
    },
    {
        "line": 48,
        "fullcodeline": "decoded_shape_data[1] = max_decoded;"
    },
    {
        "line": 11,
        "fullcodeline": "for (int p = 0; p < top_paths; ++p) {"
    },
    {
        "line": 35,
        "fullcodeline": "for (int b = 0; b < batch_size; ++b) {"
    },
    {
        "line": 12,
        "fullcodeline": "num_entries[p] += batch_s[p].size();"
    },
    {
        "line": 37,
        "fullcodeline": "int32_t num_decoded = p_batch.size();"
    },
    {
        "line": 38,
        "fullcodeline": "max_decoded = std::max(max_decoded, num_decoded);"
    },
    {
        "line": 40,
        "fullcodeline": "std::copy_n(p_batch.begin(), num_decoded, values_data + offset);"
    },
    {
        "line": 41,
        "fullcodeline": "for (int32_t t = 0; t < num_decoded; ++t, ++offset) {"
    },
    {
        "line": 42,
        "fullcodeline": "indices_data[offset * 2] = b;"
    },
    {
        "line": 43,
        "fullcodeline": "indices_data[offset * 2 + 1] = t;"
    }
]