[
    {
        "line": 6,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 10,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 17,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 21,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 25,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 29,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 34,
        "fullcodeline": "const int num_classes = op_data->num_classes;"
    },
    {
        "line": 35,
        "fullcodeline": "const int max_categories_per_anchor = op_data->max_classes_per_detection;"
    },
    {
        "line": 39,
        "fullcodeline": "int label_offset = num_classes_with_background - num_classes;"
    },
    {
        "line": 40,
        "fullcodeline": "TF_LITE_ENSURE(context, (max_categories_per_anchor > 0));"
    },
    {
        "line": 41,
        "fullcodeline": "const int num_categories_per_anchor ="
    },
    {
        "line": 44,
        "fullcodeline": "max_scores.resize(num_boxes);"
    },
    {
        "line": 46,
        "fullcodeline": "sorted_class_indices.resize(num_boxes * num_classes);"
    },
    {
        "line": 57,
        "fullcodeline": "TF_LITE_ENSURE_STATUS(NonMaxSuppressionSingleClassHelper("
    },
    {
        "line": 60,
        "fullcodeline": "int output_box_index = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "GetTensorData<float>(num_detections)[0] = output_box_index;"
    },
    {
        "line": 7,
        "fullcodeline": "GetInputSafe(context, node, kInputTensorBoxEncodings,"
    },
    {
        "line": 11,
        "fullcodeline": "GetInputSafe(context, node, kInputTensorClassPredictions,"
    },
    {
        "line": 18,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensorDetectionBoxes,"
    },
    {
        "line": 22,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensorDetectionClasses,"
    },
    {
        "line": 26,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensorDetectionScores,"
    },
    {
        "line": 30,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensorNumDetections,"
    },
    {
        "line": 42,
        "fullcodeline": "std::min(max_categories_per_anchor, num_classes);"
    },
    {
        "line": 47,
        "fullcodeline": "for (int row = 0; row < num_boxes; row++) {"
    },
    {
        "line": 48,
        "fullcodeline": "const float* box_scores ="
    },
    {
        "line": 50,
        "fullcodeline": "int* class_indices = sorted_class_indices.data() + row * num_classes;"
    },
    {
        "line": 51,
        "fullcodeline": "DecreasingPartialArgSort(box_scores, num_classes, num_categories_per_anchor,"
    },
    {
        "line": 53,
        "fullcodeline": "max_scores[row] = box_scores[class_indices[0]];"
    },
    {
        "line": 62,
        "fullcodeline": "const float* box_scores ="
    },
    {
        "line": 64,
        "fullcodeline": "const int* class_indices ="
    },
    {
        "line": 49,
        "fullcodeline": "scores + row * num_classes_with_background + label_offset;"
    },
    {
        "line": 63,
        "fullcodeline": "scores + selected_index * num_classes_with_background + label_offset;"
    },
    {
        "line": 65,
        "fullcodeline": "sorted_class_indices.data() + selected_index * num_classes;"
    },
    {
        "line": 67,
        "fullcodeline": "for (int col = 0; col < num_categories_per_anchor; ++col) {"
    },
    {
        "line": 68,
        "fullcodeline": "int box_offset = num_categories_per_anchor * output_box_index + col;"
    },
    {
        "line": 74,
        "fullcodeline": "GetTensorData<float>(detection_classes)[box_offset] = class_indices[col];"
    },
    {
        "line": 76,
        "fullcodeline": "GetTensorData<float>(detection_scores)[box_offset] ="
    },
    {
        "line": 78,
        "fullcodeline": "output_box_index++;"
    },
    {
        "line": 70,
        "fullcodeline": "ReInterpretTensor<BoxCornerEncoding*>(detection_boxes)[box_offset] ="
    },
    {
        "line": 71,
        "fullcodeline": "ReInterpretTensor<const BoxCornerEncoding*>("
    }
]