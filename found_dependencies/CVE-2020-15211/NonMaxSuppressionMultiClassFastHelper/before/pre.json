[
    {
        "line": 5,
        "fullcodeline": "const TfLiteTensor* input_box_encodings ="
    },
    {
        "line": 7,
        "fullcodeline": "const TfLiteTensor* input_class_predictions ="
    },
    {
        "line": 9,
        "fullcodeline": "const TfLiteTensor* decoded_boxes ="
    },
    {
        "line": 12,
        "fullcodeline": "TfLiteTensor* detection_boxes ="
    },
    {
        "line": 14,
        "fullcodeline": "TfLiteTensor* detection_classes ="
    },
    {
        "line": 16,
        "fullcodeline": "TfLiteTensor* detection_scores ="
    },
    {
        "line": 18,
        "fullcodeline": "TfLiteTensor* num_detections ="
    },
    {
        "line": 21,
        "fullcodeline": "const int num_boxes = input_box_encodings->dims->data[1];"
    },
    {
        "line": 22,
        "fullcodeline": "const int num_classes = op_data->num_classes;"
    },
    {
        "line": 23,
        "fullcodeline": "const int max_categories_per_anchor = op_data->max_classes_per_detection;"
    },
    {
        "line": 24,
        "fullcodeline": "const int num_classes_with_background ="
    },
    {
        "line": 27,
        "fullcodeline": "int label_offset = num_classes_with_background - num_classes;"
    },
    {
        "line": 28,
        "fullcodeline": "TF_LITE_ENSURE(context, (max_categories_per_anchor > 0));"
    },
    {
        "line": 29,
        "fullcodeline": "const int num_categories_per_anchor ="
    },
    {
        "line": 32,
        "fullcodeline": "max_scores.resize(num_boxes);"
    },
    {
        "line": 34,
        "fullcodeline": "sorted_class_indices.resize(num_boxes * num_classes);"
    },
    {
        "line": 45,
        "fullcodeline": "TF_LITE_ENSURE_STATUS(NonMaxSuppressionSingleClassHelper("
    },
    {
        "line": 48,
        "fullcodeline": "int output_box_index = 0;"
    },
    {
        "line": 69,
        "fullcodeline": "GetTensorData<float>(num_detections)[0] = output_box_index;"
    },
    {
        "line": 6,
        "fullcodeline": "GetInput(context, node, kInputTensorBoxEncodings);"
    },
    {
        "line": 8,
        "fullcodeline": "GetInput(context, node, kInputTensorClassPredictions);"
    },
    {
        "line": 13,
        "fullcodeline": "GetOutput(context, node, kOutputTensorDetectionBoxes);"
    },
    {
        "line": 15,
        "fullcodeline": "GetOutput(context, node, kOutputTensorDetectionClasses);"
    },
    {
        "line": 17,
        "fullcodeline": "GetOutput(context, node, kOutputTensorDetectionScores);"
    },
    {
        "line": 19,
        "fullcodeline": "GetOutput(context, node, kOutputTensorNumDetections);"
    },
    {
        "line": 30,
        "fullcodeline": "std::min(max_categories_per_anchor, num_classes);"
    },
    {
        "line": 35,
        "fullcodeline": "for (int row = 0; row < num_boxes; row++) {"
    },
    {
        "line": 36,
        "fullcodeline": "const float* box_scores ="
    },
    {
        "line": 38,
        "fullcodeline": "int* class_indices = sorted_class_indices.data() + row * num_classes;"
    },
    {
        "line": 39,
        "fullcodeline": "DecreasingPartialArgSort(box_scores, num_classes, num_categories_per_anchor,"
    },
    {
        "line": 41,
        "fullcodeline": "max_scores[row] = box_scores[class_indices[0]];"
    },
    {
        "line": 50,
        "fullcodeline": "const float* box_scores ="
    },
    {
        "line": 52,
        "fullcodeline": "const int* class_indices ="
    },
    {
        "line": 37,
        "fullcodeline": "scores + row * num_classes_with_background + label_offset;"
    },
    {
        "line": 51,
        "fullcodeline": "scores + selected_index * num_classes_with_background + label_offset;"
    },
    {
        "line": 53,
        "fullcodeline": "sorted_class_indices.data() + selected_index * num_classes;"
    },
    {
        "line": 55,
        "fullcodeline": "for (int col = 0; col < num_categories_per_anchor; ++col) {"
    },
    {
        "line": 56,
        "fullcodeline": "int box_offset = num_categories_per_anchor * output_box_index + col;"
    },
    {
        "line": 58,
        "fullcodeline": "ReInterpretTensor<BoxCornerEncoding*>(detection_boxes)[box_offset] ="
    },
    {
        "line": 62,
        "fullcodeline": "GetTensorData<float>(detection_classes)[box_offset] = class_indices[col];"
    },
    {
        "line": 64,
        "fullcodeline": "GetTensorData<float>(detection_scores)[box_offset] ="
    },
    {
        "line": 66,
        "fullcodeline": "output_box_index++;"
    },
    {
        "line": 59,
        "fullcodeline": "ReInterpretTensor<const BoxCornerEncoding*>("
    }
]