[
    {
        "line": 2,
        "fullcodeline": "const TfLiteTensor* indices = GetInput(context, node, kIndicesTensor);"
    },
    {
        "line": 3,
        "fullcodeline": "const TfLiteTensor* output_shape ="
    },
    {
        "line": 5,
        "fullcodeline": "const TfLiteTensor* values = GetInput(context, node, kValueInputTensor);"
    },
    {
        "line": 6,
        "fullcodeline": "const TfLiteTensor* default_value ="
    },
    {
        "line": 8,
        "fullcodeline": "TfLiteTensor* output = GetOutput(context, node, kOutputTensor);"
    },
    {
        "line": 15,
        "fullcodeline": "const int num_indices = SizeOfDimension(indices, 0);"
    },
    {
        "line": 16,
        "fullcodeline": "const bool value_is_scalar = NumDimensions(values) == 0;"
    },
    {
        "line": 17,
        "fullcodeline": "std::vector<std::vector<TI>> indices_vector;"
    },
    {
        "line": 18,
        "fullcodeline": "indices_vector.reserve(num_indices);"
    },
    {
        "line": 19,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetIndicesVector<TI>(context, indices, num_indices,"
    },
    {
        "line": 21,
        "fullcodeline": "reference_ops::SparseToDense(indices_vector, GetTensorData<T>(values),"
    },
    {
        "line": 4,
        "fullcodeline": "GetInput(context, node, kOutputShapeTensor);"
    },
    {
        "line": 7,
        "fullcodeline": "GetInput(context, node, kDefaultValueTensor);"
    },
    {
        "line": 10,
        "fullcodeline": "if (IsDynamicTensor(output)) {"
    },
    {
        "line": 22,
        "fullcodeline": "*GetTensorData<T>(default_value),"
    },
    {
        "line": 23,
        "fullcodeline": "value_is_scalar, GetTensorShape(output),"
    },
    {
        "line": 24,
        "fullcodeline": "GetTensorData<T>(output));"
    },
    {
        "line": 11,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 12,
        "fullcodeline": "ResizeOutputShape(context, output_shape, output));"
    }
]