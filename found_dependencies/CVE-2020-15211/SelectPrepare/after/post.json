[
    {
        "line": 2,
        "fullcodeline": "OpData* data = reinterpret_cast<OpData*>(node->user_data);"
    },
    {
        "line": 4,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);"
    },
    {
        "line": 5,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);"
    },
    {
        "line": 8,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensorCondition,"
    },
    {
        "line": 11,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 14,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 17,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 21,
        "fullcodeline": "TF_LITE_ENSURE_TYPES_EQ(context, input_condition->type, kTfLiteBool);"
    },
    {
        "line": 22,
        "fullcodeline": "TF_LITE_ENSURE_TYPES_EQ(context, input_x->type, input_y->type);"
    },
    {
        "line": 23,
        "fullcodeline": "output->type = input_x->type;"
    },
    {
        "line": 25,
        "fullcodeline": "bool same_shape = HaveSameShapes(input_condition, input_x) &&"
    },
    {
        "line": 12,
        "fullcodeline": "GetInputSafe(context, node, kInputTensorX, &input_x));"
    },
    {
        "line": 15,
        "fullcodeline": "GetInputSafe(context, node, kInputTensorY, &input_y));"
    },
    {
        "line": 18,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensor, &output));"
    },
    {
        "line": 28,
        "fullcodeline": "if (!same_shape) {"
    },
    {
        "line": 59,
        "fullcodeline": "return context->ResizeTensor(context, output, output_size);"
    },
    {
        "line": 26,
        "fullcodeline": "HaveSameShapes(input_x, input_y);"
    },
    {
        "line": 56,
        "fullcodeline": "output_size = TfLiteIntArrayCopy(input_x->dims);"
    },
    {
        "line": 31,
        "fullcodeline": "bool is_input_condition_scalar = NumDimensions(input_condition) == 0;"
    },
    {
        "line": 32,
        "fullcodeline": "bool has_rank_one_input_condition ="
    },
    {
        "line": 35,
        "fullcodeline": "data->has_low_rank_input_condition ="
    },
    {
        "line": 37,
        "fullcodeline": "TF_LITE_ENSURE(context, data->has_low_rank_input_condition);"
    },
    {
        "line": 39,
        "fullcodeline": "output_size = TfLiteIntArrayCopy(input_x->dims);"
    },
    {
        "line": 42,
        "fullcodeline": "TF_LITE_ENSURE(context, HaveSameShapes(input_x, input_y));"
    },
    {
        "line": 46,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast("
    },
    {
        "line": 49,
        "fullcodeline": "data->requires_broadcast = true;"
    },
    {
        "line": 33,
        "fullcodeline": "NumDimensions(input_condition) == 1 &&"
    },
    {
        "line": 36,
        "fullcodeline": "is_input_condition_scalar || has_rank_one_input_condition;"
    },
    {
        "line": 34,
        "fullcodeline": "SizeOfDimension(input_condition, 0) == SizeOfDimension(input_x, 0);"
    }
]