[
    {
        "line": 5,
        "fullcodeline": "const TfLiteTensor* input_box_encodings ="
    },
    {
        "line": 10,
        "fullcodeline": "const float non_max_suppression_score_threshold ="
    },
    {
        "line": 12,
        "fullcodeline": "const float intersection_over_union_threshold ="
    },
    {
        "line": 15,
        "fullcodeline": "TF_LITE_ENSURE(context, (max_detections >= 0));"
    },
    {
        "line": 18,
        "fullcodeline": "TF_LITE_ENSURE(context, (intersection_over_union_threshold > 0.0f) &&"
    },
    {
        "line": 21,
        "fullcodeline": "TF_LITE_ENSURE(context, ValidateBoxes(decoded_boxes, num_boxes));"
    },
    {
        "line": 28,
        "fullcodeline": "SelectDetectionsAboveScoreThreshold("
    },
    {
        "line": 31,
        "fullcodeline": "int num_scores_kept = keep_scores.size();"
    },
    {
        "line": 33,
        "fullcodeline": "sorted_indices.resize(num_scores_kept);"
    },
    {
        "line": 34,
        "fullcodeline": "DecreasingPartialArgSort(keep_scores.data(), num_scores_kept, num_scores_kept,"
    },
    {
        "line": 36,
        "fullcodeline": "const int num_boxes_kept = num_scores_kept;"
    },
    {
        "line": 37,
        "fullcodeline": "const int output_size = std::min(num_boxes_kept, max_detections);"
    },
    {
        "line": 38,
        "fullcodeline": "selected->clear();"
    },
    {
        "line": 41,
        "fullcodeline": "TF_LITE_ENSURE(context, (active_candidate->dims->data[0]) == num_boxes);"
    },
    {
        "line": 42,
        "fullcodeline": "int num_active_candidate = num_boxes_kept;"
    },
    {
        "line": 6,
        "fullcodeline": "GetInput(context, node, kInputTensorBoxEncodings);"
    },
    {
        "line": 35,
        "fullcodeline": "sorted_indices.data());"
    },
    {
        "line": 44,
        "fullcodeline": "for (int row = 0; row < num_boxes_kept; row++) {"
    },
    {
        "line": 48,
        "fullcodeline": "for (int i = 0; i < num_boxes_kept; ++i) {"
    },
    {
        "line": 19,
        "fullcodeline": "(intersection_over_union_threshold <= 1.0f));"
    },
    {
        "line": 45,
        "fullcodeline": "active_box_candidate[row] = 1;"
    },
    {
        "line": 49,
        "fullcodeline": "if (num_active_candidate == 0 || selected->size() >= output_size) break;"
    },
    {
        "line": 50,
        "fullcodeline": "if (active_box_candidate[i] == 1) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (int j = i + 1; j < num_boxes_kept; ++j) {"
    },
    {
        "line": 51,
        "fullcodeline": "selected->push_back(keep_indices[sorted_indices[i]]);"
    },
    {
        "line": 52,
        "fullcodeline": "active_box_candidate[i] = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "num_active_candidate--;"
    },
    {
        "line": 58,
        "fullcodeline": "if (active_box_candidate[j] == 1) {"
    },
    {
        "line": 59,
        "fullcodeline": "float intersection_over_union = ComputeIntersectionOverUnion("
    },
    {
        "line": 63,
        "fullcodeline": "if (intersection_over_union > intersection_over_union_threshold) {"
    },
    {
        "line": 64,
        "fullcodeline": "active_box_candidate[j] = 0;"
    },
    {
        "line": 65,
        "fullcodeline": "num_active_candidate--;"
    }
]