[
    {
        "line": 3,
        "fullcodeline": "std::vector<GetLengthType> results;"
    },
    {
        "line": 5,
        "fullcodeline": "retval.startOrder = target.startOrder;"
    },
    {
        "line": 6,
        "fullcodeline": "retval.startRow = target.startRow;"
    },
    {
        "line": 9,
        "fullcodeline": "const bool hasSearchTarget = target.mode != GetLengthTarget::NoTarget;"
    },
    {
        "line": 10,
        "fullcodeline": "const bool adjustSamplePos = (adjustMode & eAdjustSamplePositions) == eAdjustSamplePositions;"
    },
    {
        "line": 12,
        "fullcodeline": "SEQUENCEINDEX sequence = target.sequence;"
    },
    {
        "line": 14,
        "fullcodeline": "const ModSequence &orderList = Order(sequence);"
    },
    {
        "line": 16,
        "fullcodeline": "GetLengthMemory memory(*this);"
    },
    {
        "line": 17,
        "fullcodeline": "CSoundFile::PlayState &playState = *memory.state;"
    },
    {
        "line": 19,
        "fullcodeline": "RowVisitor visitedRows(*this, sequence);"
    },
    {
        "line": 21,
        "fullcodeline": "playState.m_nNextRow = playState.m_nRow = target.startRow;"
    },
    {
        "line": 22,
        "fullcodeline": "playState.m_nNextOrder = playState.m_nCurrentOrder = target.startOrder;"
    },
    {
        "line": 25,
        "fullcodeline": "std::bitset<MAX_EFFECTS> forbiddenCommands;"
    },
    {
        "line": 26,
        "fullcodeline": "std::bitset<MAX_VOLCMDS> forbiddenVolCommands;"
    },
    {
        "line": 61,
        "fullcodeline": "uint32 oldTickDuration = 0;"
    },
    {
        "line": 1008,
        "fullcodeline": "retval.duration = memory.elapsedTime;"
    },
    {
        "line": 1009,
        "fullcodeline": "results.push_back(retval);"
    },
    {
        "line": 13,
        "fullcodeline": "if(sequence >= Order.GetNumSequences()) sequence = Order.GetCurrentSequenceIndex();"
    },
    {
        "line": 1003,
        "fullcodeline": "if(retval.targetReached || target.mode == GetLengthTarget::NoTarget)"
    },
    {
        "line": 1012,
        "fullcodeline": "if(adjustMode & eAdjust)"
    },
    {
        "line": 30,
        "fullcodeline": "forbiddenCommands.set(CMD_ARPEGGIO);             forbiddenCommands.set(CMD_PORTAMENTOUP);"
    },
    {
        "line": 31,
        "fullcodeline": "forbiddenCommands.set(CMD_PORTAMENTODOWN);       forbiddenCommands.set(CMD_XFINEPORTAUPDOWN);"
    },
    {
        "line": 32,
        "fullcodeline": "forbiddenCommands.set(CMD_NOTESLIDEUP);          forbiddenCommands.set(CMD_NOTESLIDEUPRETRIG);"
    },
    {
        "line": 33,
        "fullcodeline": "forbiddenCommands.set(CMD_NOTESLIDEDOWN);        forbiddenCommands.set(CMD_NOTESLIDEDOWNRETRIG);"
    },
    {
        "line": 34,
        "fullcodeline": "forbiddenVolCommands.set(VOLCMD_PORTAUP);        forbiddenVolCommands.set(VOLCMD_PORTADOWN);"
    },
    {
        "line": 72,
        "fullcodeline": "uint32 rowDelay = 0, tickDelay = 0;"
    },
    {
        "line": 73,
        "fullcodeline": "playState.m_nRow = playState.m_nNextRow;"
    },
    {
        "line": 74,
        "fullcodeline": "playState.m_nCurrentOrder = playState.m_nNextOrder;"
    },
    {
        "line": 88,
        "fullcodeline": "playState.m_nPattern = playState.m_nCurrentOrder < orderList.size() ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();"
    },
    {
        "line": 89,
        "fullcodeline": "bool positionJumpOnThisRow = false;"
    },
    {
        "line": 90,
        "fullcodeline": "bool patternBreakOnThisRow = false;"
    },
    {
        "line": 91,
        "fullcodeline": "bool patternLoopEndedOnThisRow = false, patternLoopStartedOnThisRow = false;"
    },
    {
        "line": 198,
        "fullcodeline": "retval.endOrder = playState.m_nCurrentOrder;"
    },
    {
        "line": 199,
        "fullcodeline": "retval.endRow = playState.m_nRow;"
    },
    {
        "line": 202,
        "fullcodeline": "playState.m_nNextRow = playState.m_nRow + 1;"
    },
    {
        "line": 219,
        "fullcodeline": "ModChannel *pChn = playState.Chn;"
    },
    {
        "line": 222,
        "fullcodeline": "const ModCommand *p = Patterns[playState.m_nPattern].GetpModCommand(playState.m_nRow, 0);"
    },
    {
        "line": 280,
        "fullcodeline": "const uint32 numTicks = (playState.m_nMusicSpeed + tickDelay) * rowDelay;"
    },
    {
        "line": 281,
        "fullcodeline": "const uint32 nonRowTicks = numTicks - rowDelay;"
    },
    {
        "line": 694,
        "fullcodeline": "playState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;"
    },
    {
        "line": 700,
        "fullcodeline": "const uint32 tickDuration = GetTickDuration(playState);"
    },
    {
        "line": 701,
        "fullcodeline": "const uint32 rowDuration = tickDuration * numTicks;"
    },
    {
        "line": 702,
        "fullcodeline": "memory.elapsedTime += static_cast<double>(rowDuration) / static_cast<double>(m_MixerSettings.gdwMixingFreq);"
    },
    {
        "line": 703,
        "fullcodeline": "playState.m_lTotalSampleCount += rowDuration;"
    },
    {
        "line": 930,
        "fullcodeline": "oldTickDuration = tickDuration;"
    },
    {
        "line": 1005,
        "fullcodeline": "retval.lastOrder = playState.m_nCurrentOrder;"
    },
    {
        "line": 1006,
        "fullcodeline": "retval.lastRow = playState.m_nRow;"
    },
    {
        "line": 1075,
        "fullcodeline": "visitedSongRows.Set(visitedRows);"
    },
    {
        "line": 37,
        "fullcodeline": "for(CHANNELINDEX i = 0; i < GetNumChannels(); i++)"
    },
    {
        "line": 41,
        "fullcodeline": "if(target.mode == GetLengthTarget::SeekPosition && target.pos.order < orderList.size())"
    },
    {
        "line": 66,
        "fullcodeline": "if(target.mode == GetLengthTarget::SeekSeconds && memory.elapsedTime >= target.time)"
    },
    {
        "line": 76,
        "fullcodeline": "if(orderList.IsValidPat(playState.m_nCurrentOrder) && playState.m_nRow >= Patterns[orderList[playState.m_nCurrentOrder]].GetNumRows())"
    },
    {
        "line": 93,
        "fullcodeline": "if(!Patterns.IsValidPat(playState.m_nPattern) && playState.m_nPattern != orderList.GetInvalidPatIndex() && target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order)"
    },
    {
        "line": 100,
        "fullcodeline": "while(playState.m_nPattern >= Patterns.Size())"
    },
    {
        "line": 137,
        "fullcodeline": "if(playState.m_nNextOrder == ORDERINDEX_INVALID)"
    },
    {
        "line": 144,
        "fullcodeline": "if(!Patterns.IsValidPat(playState.m_nPattern))"
    },
    {
        "line": 169,
        "fullcodeline": "if(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())"
    },
    {
        "line": 173,
        "fullcodeline": "if(target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order && playState.m_nRow == target.pos.row)"
    },
    {
        "line": 179,
        "fullcodeline": "if(visitedRows.IsVisited(playState.m_nCurrentOrder, playState.m_nRow, true))"
    },
    {
        "line": 205,
        "fullcodeline": "if(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())"
    },
    {
        "line": 210,
        "fullcodeline": "if(!playState.m_nRow)"
    },
    {
        "line": 223,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, p++)"
    },
    {
        "line": 279,
        "fullcodeline": "if(rowDelay == 0) rowDelay = 1;"
    },
    {
        "line": 283,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++) if(!pChn->rowCommand.IsEmpty())"
    },
    {
        "line": 689,
        "fullcodeline": "if(GetType() == MOD_TYPE_XM && playState.m_nMusicSpeed == uint16_max)"
    },
    {
        "line": 695,
        "fullcodeline": "if(Patterns[playState.m_nPattern].GetOverrideSignature())"
    },
    {
        "line": 936,
        "fullcodeline": "if(patternLoopEndedOnThisRow"
    },
    {
        "line": 994,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)"
    },
    {
        "line": 1014,
        "fullcodeline": "if(retval.targetReached || target.mode == GetLengthTarget::NoTarget)"
    },
    {
        "line": 1071,
        "fullcodeline": "if(sequence != Order.GetCurrentSequenceIndex())"
    },
    {
        "line": 44,
        "fullcodeline": "const PATTERNINDEX seekPat = orderList[target.pos.order];"
    },
    {
        "line": 68,
        "fullcodeline": "retval.targetReached = true;"
    },
    {
        "line": 78,
        "fullcodeline": "playState.m_nRow = 0;"
    },
    {
        "line": 84,
        "fullcodeline": "playState.m_nCurrentOrder = ++playState.m_nNextOrder;"
    },
    {
        "line": 96,
        "fullcodeline": "retval.targetReached = true;"
    },
    {
        "line": 113,
        "fullcodeline": "playState.m_nPattern = (playState.m_nCurrentOrder < orderList.size()) ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();"
    },
    {
        "line": 114,
        "fullcodeline": "playState.m_nNextOrder = playState.m_nCurrentOrder;"
    },
    {
        "line": 165,
        "fullcodeline": "playState.m_nNextOrder = playState.m_nCurrentOrder + 1;"
    },
    {
        "line": 170,
        "fullcodeline": "playState.m_nRow = 0;"
    },
    {
        "line": 175,
        "fullcodeline": "retval.targetReached = true;"
    },
    {
        "line": 207,
        "fullcodeline": "playState.m_nRow = 0;"
    },
    {
        "line": 238,
        "fullcodeline": "pChn[nChn].rowCommand = *p;"
    },
    {
        "line": 697,
        "fullcodeline": "playState.m_nCurrentRowsPerBeat = Patterns[playState.m_nPattern].GetRowsPerBeat();"
    },
    {
        "line": 708,
        "fullcodeline": "pChn = playState.Chn;"
    },
    {
        "line": 938,
        "fullcodeline": "&& (!m_playBehaviour[kITPatternLoopWithJumps] || !positionJumpOnThisRow))"
    },
    {
        "line": 944,
        "fullcodeline": "pChn = playState.Chn;"
    },
    {
        "line": 1017,
        "fullcodeline": "m_PlayState = std::move(playState);"
    },
    {
        "line": 1018,
        "fullcodeline": "m_PlayState.m_nNextRow = m_PlayState.m_nRow;"
    },
    {
        "line": 1019,
        "fullcodeline": "m_PlayState.m_nFrameDelay = m_PlayState.m_nPatternDelay = 0;"
    },
    {
        "line": 1020,
        "fullcodeline": "m_PlayState.m_nTickCount = Util::MaxValueOfType(m_PlayState.m_nTickCount) - 1;"
    },
    {
        "line": 1021,
        "fullcodeline": "m_PlayState.m_bPositionChanged = true;"
    },
    {
        "line": 1036,
        "fullcodeline": "std::bitset<MAX_MIXPLUGINS> plugSetProgram;"
    },
    {
        "line": 1073,
        "fullcodeline": "Order.SetSequence(sequence);"
    },
    {
        "line": 45,
        "fullcodeline": "if(Patterns.IsValidPat(seekPat) && Patterns[seekPat].IsValidRow(target.pos.row))"
    },
    {
        "line": 103,
        "fullcodeline": "if((playState.m_nPattern == orderList.GetInvalidPatIndex()) || (playState.m_nCurrentOrder >= orderList.size()))"
    },
    {
        "line": 115,
        "fullcodeline": "if((!Patterns.IsValidPat(playState.m_nPattern)) && visitedRows.IsVisited(playState.m_nCurrentOrder, 0, true))"
    },
    {
        "line": 147,
        "fullcodeline": "if(playState.m_nCurrentOrder == orderList.GetRestartPos())"
    },
    {
        "line": 181,
        "fullcodeline": "if(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))"
    },
    {
        "line": 212,
        "fullcodeline": "for(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)"
    },
    {
        "line": 225,
        "fullcodeline": "if(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels"
    },
    {
        "line": 227,
        "fullcodeline": "if(p->IsPcNote())"
    },
    {
        "line": 287,
        "fullcodeline": "ModCommand::COMMAND command = pChn->rowCommand.command;"
    },
    {
        "line": 288,
        "fullcodeline": "ModCommand::PARAM param = pChn->rowCommand.param;"
    },
    {
        "line": 289,
        "fullcodeline": "ModCommand::NOTE note = pChn->rowCommand.note;"
    },
    {
        "line": 709,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++)"
    },
    {
        "line": 937,
        "fullcodeline": "&& (!m_playBehaviour[kFT2PatternLoopWithJumps] || !(positionJumpOnThisRow || patternBreakOnThisRow))"
    },
    {
        "line": 945,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)"
    },
    {
        "line": 975,
        "fullcodeline": "if(GetType() == MOD_TYPE_IT)"
    },
    {
        "line": 996,
        "fullcodeline": "if(memory.chnSettings[nChn].ticksToRender != GetLengthMemory::IGNORE_CHANNEL)"
    },
    {
        "line": 1022,
        "fullcodeline": "for(CHANNELINDEX n = 0; n < GetNumChannels(); n++)"
    },
    {
        "line": 1052,
        "fullcodeline": "if(plugSetProgram.any())"
    },
    {
        "line": 39,
        "fullcodeline": "if(ChnSettings[i].dwFlags[CHN_MUTE]) memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;"
    },
    {
        "line": 47,
        "fullcodeline": "const ModCommand *m = Patterns[seekPat].GetRow(target.pos.row);"
    },
    {
        "line": 81,
        "fullcodeline": "playState.m_nRow = playState.m_nNextPatStartRow;"
    },
    {
        "line": 82,
        "fullcodeline": "playState.m_nNextPatStartRow = 0;"
    },
    {
        "line": 214,
        "fullcodeline": "memory.chnSettings[chn].patLoop = memory.elapsedTime;"
    },
    {
        "line": 215,
        "fullcodeline": "memory.chnSettings[chn].patLoopSmp = playState.m_lTotalSampleCount;"
    },
    {
        "line": 235,
        "fullcodeline": "pChn[nChn].rowCommand.Clear();"
    },
    {
        "line": 242,
        "fullcodeline": "SetSpeed(playState, p->param);"
    },
    {
        "line": 285,
        "fullcodeline": "if(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels"
    },
    {
        "line": 297,
        "fullcodeline": "if (pChn->rowCommand.IsNote()) pChn->nLastNote = note;"
    },
    {
        "line": 300,
        "fullcodeline": "if(pChn->rowCommand.IsNote() || pChn->rowCommand.instr)"
    },
    {
        "line": 488,
        "fullcodeline": "if (!(adjustMode & eAdjust)) continue;"
    },
    {
        "line": 714,
        "fullcodeline": "uint32 startTick = 0;"
    },
    {
        "line": 715,
        "fullcodeline": "const ModCommand &m = pChn->rowCommand;"
    },
    {
        "line": 716,
        "fullcodeline": "uint32 paramHi = m.param >> 4, paramLo = m.param & 0x0F;"
    },
    {
        "line": 717,
        "fullcodeline": "bool porta = m.command == CMD_TONEPORTAMENTO || m.command == CMD_TONEPORTAVOL || m.volcmd == VOLCMD_TONEPORTAMENTO;"
    },
    {
        "line": 718,
        "fullcodeline": "bool stopNote = patternLoopStartedOnThisRow;\t// It's too much trouble to keep those pattern loops in sync..."
    },
    {
        "line": 947,
        "fullcodeline": "ModCommand::COMMAND command = pChn->rowCommand.command;"
    },
    {
        "line": 948,
        "fullcodeline": "ModCommand::PARAM param = pChn->rowCommand.param;"
    },
    {
        "line": 959,
        "fullcodeline": "memory.elapsedTime += (memory.elapsedTime - i.first) * (double)(i.second - 1);"
    },
    {
        "line": 978,
        "fullcodeline": "pChn = playState.Chn;"
    },
    {
        "line": 998,
        "fullcodeline": "memory.RenderChannel(nChn, oldTickDuration);"
    },
    {
        "line": 1039,
        "fullcodeline": "PLUGINDEX plug = param.first.first - 1;"
    },
    {
        "line": 1040,
        "fullcodeline": "IMixPlugin *plugin = m_MixPlugins[plug].pMixPlugin;"
    },
    {
        "line": 1063,
        "fullcodeline": "} else if(adjustMode != eAdjustOnSuccess)"
    },
    {
        "line": 48,
        "fullcodeline": "for(CHANNELINDEX i = 0; i < GetNumChannels(); i++, m++)"
    },
    {
        "line": 105,
        "fullcodeline": "if(playState.m_nCurrentOrder == orderList.GetRestartPos())"
    },
    {
        "line": 111,
        "fullcodeline": "playState.m_nCurrentOrder++;"
    },
    {
        "line": 117,
        "fullcodeline": "if(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))"
    },
    {
        "line": 149,
        "fullcodeline": "if(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))"
    },
    {
        "line": 188,
        "fullcodeline": "retval.duration = memory.elapsedTime;"
    },
    {
        "line": 189,
        "fullcodeline": "results.push_back(retval);"
    },
    {
        "line": 190,
        "fullcodeline": "retval.startRow = playState.m_nRow;"
    },
    {
        "line": 191,
        "fullcodeline": "retval.startOrder = playState.m_nNextOrder;"
    },
    {
        "line": 192,
        "fullcodeline": "memory.Reset();"
    },
    {
        "line": 193,
        "fullcodeline": "playState.m_nNextRow = playState.m_nRow;"
    },
    {
        "line": 230,
        "fullcodeline": "if((adjustMode & eAdjust) && p->instr > 0 && p->instr <= MAX_MIXPLUGINS)"
    },
    {
        "line": 254,
        "fullcodeline": "if((p->param & 0xF0) == 0x60)"
    },
    {
        "line": 271,
        "fullcodeline": "if((p->param & 0xF0) == 0xE0)"
    },
    {
        "line": 293,
        "fullcodeline": "pChn->nNewIns = pChn->rowCommand.instr;"
    },
    {
        "line": 294,
        "fullcodeline": "pChn->nLastNote = NOTE_NONE;"
    },
    {
        "line": 295,
        "fullcodeline": "memory.chnSettings[nChn].vol = 0xFF;"
    },
    {
        "line": 302,
        "fullcodeline": "SAMPLEINDEX smp = 0;"
    },
    {
        "line": 326,
        "fullcodeline": "memory.chnSettings[nChn].vol = pChn->rowCommand.vol;"
    },
    {
        "line": 339,
        "fullcodeline": "positionJumpOnThisRow = true;"
    },
    {
        "line": 340,
        "fullcodeline": "playState.m_nNextOrder = static_cast<ORDERINDEX>(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn));"
    },
    {
        "line": 341,
        "fullcodeline": "playState.m_nNextPatStartRow = 0;  // FT2 E60 bug"
    },
    {
        "line": 527,
        "fullcodeline": "memory.chnSettings[nChn].vol = param;"
    },
    {
        "line": 573,
        "fullcodeline": "Limit(playState.m_nGlobalVolume, 0, 256);"
    },
    {
        "line": 595,
        "fullcodeline": "Panning(pChn, param, Pan8bit);"
    },
    {
        "line": 616,
        "fullcodeline": "param = 0;"
    },
    {
        "line": 619,
        "fullcodeline": "Vibrato(pChn, param);"
    },
    {
        "line": 622,
        "fullcodeline": "FineVibrato(pChn, param);"
    },
    {
        "line": 625,
        "fullcodeline": "Tremolo(pChn, param);"
    },
    {
        "line": 628,
        "fullcodeline": "Panbrello(pChn, param);"
    },
    {
        "line": 635,
        "fullcodeline": "Panning(pChn, pChn->rowCommand.vol, Pan6bit);"
    },
    {
        "line": 646,
        "fullcodeline": "Vibrato(pChn, pChn->rowCommand.vol);"
    },
    {
        "line": 711,
        "fullcodeline": "if(memory.chnSettings[nChn].ticksToRender == GetLengthMemory::IGNORE_CHANNEL)"
    },
    {
        "line": 721,
        "fullcodeline": "if(m.IsNote())"
    },
    {
        "line": 788,
        "fullcodeline": "if(m.note == NOTE_KEYOFF || m.note == NOTE_NOTECUT || (m.note == NOTE_FADE && GetNumInstruments())"
    },
    {
        "line": 795,
        "fullcodeline": "if(m.command == CMD_VOLUME)"
    },
    {
        "line": 803,
        "fullcodeline": "if(pChn->pModSample && !stopNote)"
    },
    {
        "line": 949,
        "fullcodeline": "if((command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF)"
    },
    {
        "line": 960,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)"
    },
    {
        "line": 979,
        "fullcodeline": "for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)"
    },
    {
        "line": 1024,
        "fullcodeline": "if(m_PlayState.Chn[n].nLastNote != NOTE_NONE)"
    },
    {
        "line": 1028,
        "fullcodeline": "if(memory.chnSettings[n].vol != 0xFF && !adjustSamplePos)"
    },
    {
        "line": 1041,
        "fullcodeline": "if(plugin != nullptr)"
    },
    {
        "line": 1054,
        "fullcodeline": "for(PLUGINDEX i = 0; i < MAX_MIXPLUGINS; i++)"
    },
    {
        "line": 1066,
        "fullcodeline": "m_PlayState.m_nMusicSpeed = m_nDefaultSpeed;"
    },
    {
        "line": 1067,
        "fullcodeline": "m_PlayState.m_nMusicTempo = m_nDefaultTempo;"
    },
    {
        "line": 1068,
        "fullcodeline": "m_PlayState.m_nGlobalVolume = m_nDefaultGlobalVolume;"
    },
    {
        "line": 232,
        "fullcodeline": "memory.plugParams[std::make_pair(p->instr, p->GetValueVolCol())] = p->GetValueEffectCol();"
    },
    {
        "line": 257,
        "fullcodeline": "tickDelay += (p->param & 0x0F);"
    },
    {
        "line": 274,
        "fullcodeline": "rowDelay = 1 + (p->param & 0x0F);"
    },
    {
        "line": 303,
        "fullcodeline": "if(GetNumInstruments())"
    },
    {
        "line": 317,
        "fullcodeline": "if(smp > 0 && smp <= GetNumSamples() && Samples[smp].uFlags[CHN_PANNING])"
    },
    {
        "line": 330,
        "fullcodeline": "if(pChn->rowCommand.vol != 0)"
    },
    {
        "line": 344,
        "fullcodeline": "if(!patternBreakOnThisRow || (GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))"
    },
    {
        "line": 347,
        "fullcodeline": "if (adjustMode & eAdjust)"
    },
    {
        "line": 356,
        "fullcodeline": "ROWINDEX row = PatternBreak(playState, nChn, param);"
    },
    {
        "line": 376,
        "fullcodeline": "if(!m_playBehaviour[kMODVBlankTiming])"
    },
    {
        "line": 411,
        "fullcodeline": "switch(param & 0xF0)"
    },
    {
        "line": 457,
        "fullcodeline": "switch(param & 0xF0)"
    },
    {
        "line": 483,
        "fullcodeline": "if(((param & 0xF0) == 0xA0) && !m_playBehaviour[kFT2RestrictXCommand]) pChn->nOldHiOffset = param & 0x0F;"
    },
    {
        "line": 531,
        "fullcodeline": "if(!(GetType() & GLOBALVOL_7BIT_FORMATS) && param < 128) param *= 2;"
    },
    {
        "line": 533,
        "fullcodeline": "if(param <= 128)"
    },
    {
        "line": 551,
        "fullcodeline": "if (((param & 0x0F) == 0x0F) && (param & 0xF0))"
    },
    {
        "line": 576,
        "fullcodeline": "if (param <= 64) pChn->nGlobalVol = param;"
    },
    {
        "line": 581,
        "fullcodeline": "int32 volume = pChn->nGlobalVol;"
    },
    {
        "line": 590,
        "fullcodeline": "Limit(volume, 0, 64);"
    },
    {
        "line": 591,
        "fullcodeline": "pChn->nGlobalVol = volume;"
    },
    {
        "line": 598,
        "fullcodeline": "if(param < 0x10)"
    },
    {
        "line": 608,
        "fullcodeline": "if((param & 0xF0) == 0x80)"
    },
    {
        "line": 656,
        "fullcodeline": "if(adjustMode & eAdjust)"
    },
    {
        "line": 667,
        "fullcodeline": "if(adjustMode & eAdjust)"
    },
    {
        "line": 678,
        "fullcodeline": "if(adjustMode & eAdjust)"
    },
    {
        "line": 720,
        "fullcodeline": "if(m.instr) pChn->proTrackerOffset = 0;"
    },
    {
        "line": 728,
        "fullcodeline": "int32 setPan = pChn->nPan;"
    },
    {
        "line": 729,
        "fullcodeline": "pChn->nNewNote = pChn->nLastNote;"
    },
    {
        "line": 731,
        "fullcodeline": "NoteChange(pChn, m.note, porta);"
    },
    {
        "line": 732,
        "fullcodeline": "memory.chnSettings[nChn].incChanged = true;"
    },
    {
        "line": 790,
        "fullcodeline": "|| (m.command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks))"
    },
    {
        "line": 792,
        "fullcodeline": "stopNote = true;"
    },
    {
        "line": 797,
        "fullcodeline": "pChn->nVolume = m.param * 4;"
    },
    {
        "line": 831,
        "fullcodeline": "pChn->Stop();"
    },
    {
        "line": 832,
        "fullcodeline": "memory.chnSettings[nChn].ticksToRender = 0;"
    },
    {
        "line": 950,
        "fullcodeline": "|| (command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F))"
    },
    {
        "line": 952,
        "fullcodeline": "const double start = memory.chnSettings[nChn].patLoop;"
    },
    {
        "line": 954,
        "fullcodeline": "startTimes[start] = mpt::lcm(startTimes[start], 1 + (param & 0x0F));"
    },
    {
        "line": 1026,
        "fullcodeline": "m_PlayState.Chn[n].nNewNote = m_PlayState.Chn[n].nLastNote;"
    },
    {
        "line": 1030,
        "fullcodeline": "m_PlayState.Chn[n].nVolume = std::min(memory.chnSettings[n].vol, uint8(64)) * 4;"
    },
    {
        "line": 1049,
        "fullcodeline": "plugin->SetParameter(param.first.second, param.second / PlugParamValue(ModCommand::maxColumnValue));"
    },
    {
        "line": 50,
        "fullcodeline": "if(m->note == NOTE_NOTECUT || m->note == NOTE_KEYOFF || (m->note == NOTE_FADE && GetNumInstruments())"
    },
    {
        "line": 108,
        "fullcodeline": "playState.m_nCurrentOrder = orderList.GetRestartPos();"
    },
    {
        "line": 124,
        "fullcodeline": "retval.duration = memory.elapsedTime;"
    },
    {
        "line": 125,
        "fullcodeline": "results.push_back(retval);"
    },
    {
        "line": 126,
        "fullcodeline": "retval.startRow = playState.m_nRow;"
    },
    {
        "line": 127,
        "fullcodeline": "retval.startOrder = playState.m_nNextOrder;"
    },
    {
        "line": 128,
        "fullcodeline": "memory.Reset();"
    },
    {
        "line": 130,
        "fullcodeline": "playState.m_nCurrentOrder = playState.m_nNextOrder;"
    },
    {
        "line": 131,
        "fullcodeline": "playState.m_nPattern = orderList[playState.m_nCurrentOrder];"
    },
    {
        "line": 132,
        "fullcodeline": "playState.m_nNextRow = playState.m_nRow;"
    },
    {
        "line": 156,
        "fullcodeline": "retval.duration = memory.elapsedTime;"
    },
    {
        "line": 157,
        "fullcodeline": "results.push_back(retval);"
    },
    {
        "line": 158,
        "fullcodeline": "retval.startRow = playState.m_nRow;"
    },
    {
        "line": 159,
        "fullcodeline": "retval.startOrder = playState.m_nNextOrder;"
    },
    {
        "line": 160,
        "fullcodeline": "memory.Reset();"
    },
    {
        "line": 161,
        "fullcodeline": "playState.m_nNextRow = playState.m_nRow;"
    },
    {
        "line": 249,
        "fullcodeline": "if(p->param != 0) SetSpeed(playState, p->param);"
    },
    {
        "line": 319,
        "fullcodeline": "pChn->nPan = Samples[smp].nPan;"
    },
    {
        "line": 331,
        "fullcodeline": "pChn->nOldVolParam = pChn->rowCommand.vol;"
    },
    {
        "line": 345,
        "fullcodeline": "playState.m_nNextRow = 0;"
    },
    {
        "line": 349,
        "fullcodeline": "pChn->nPatternLoopCount = 0;"
    },
    {
        "line": 350,
        "fullcodeline": "pChn->nPatternLoop = 0;"
    },
    {
        "line": 357,
        "fullcodeline": "if(row != ROWINDEX_INVALID)"
    },
    {
        "line": 378,
        "fullcodeline": "TEMPO tempo(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn), 0);"
    },
    {
        "line": 401,
        "fullcodeline": "TEMPO tempoMin = GetModSpecifications().GetTempoMin(), tempoMax = GetModSpecifications().GetTempoMax();"
    },
    {
        "line": 406,
        "fullcodeline": "Limit(playState.m_nMusicTempo, tempoMin, tempoMax);"
    },
    {
        "line": 422,
        "fullcodeline": "pChn->nOldHiOffset = param & 0x0F;"
    },
    {
        "line": 451,
        "fullcodeline": "pChn->nActiveMacro = param & 0x0F;"
    },
    {
        "line": 476,
        "fullcodeline": "pChn->nActiveMacro = param & 0x0F;"
    },
    {
        "line": 499,
        "fullcodeline": "pChn->nOldPortaUp = param;"
    },
    {
        "line": 509,
        "fullcodeline": "pChn->nOldPortaDown = param;"
    },
    {
        "line": 514,
        "fullcodeline": "if (param) pChn->nPortamentoSlide = param << 2;"
    },
    {
        "line": 518,
        "fullcodeline": "if (param) pChn->oldOffset = param << 8;"
    },
    {
        "line": 523,
        "fullcodeline": "if (param) pChn->nOldVolumeSlide = param;"
    },
    {
        "line": 535,
        "fullcodeline": "playState.m_nGlobalVolume = param * 2;"
    },
    {
        "line": 553,
        "fullcodeline": "param >>= 4;"
    },
    {
        "line": 555,
        "fullcodeline": "playState.m_nGlobalVolume += param << 1;"
    },
    {
        "line": 582,
        "fullcodeline": "if((param & 0x0F) == 0x0F && (param & 0xF0))"
    },
    {
        "line": 610,
        "fullcodeline": "Panning(pChn, (param & 0x0F), Pan4bit);"
    },
    {
        "line": 615,
        "fullcodeline": "if (param) pChn->nOldVolumeSlide = param;"
    },
    {
        "line": 641,
        "fullcodeline": "pChn->nVibratoSpeed = pChn->rowCommand.vol & 0x0F;"
    },
    {
        "line": 658,
        "fullcodeline": "uint32 vibTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;"
    },
    {
        "line": 659,
        "fullcodeline": "uint32 inc = pChn->nVibratoSpeed * vibTicks;"
    },
    {
        "line": 662,
        "fullcodeline": "pChn->nVibratoPos += static_cast<uint8>(inc);"
    },
    {
        "line": 669,
        "fullcodeline": "uint32 tremTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;"
    },
    {
        "line": 670,
        "fullcodeline": "uint32 inc = pChn->nTremoloSpeed * tremTicks;"
    },
    {
        "line": 673,
        "fullcodeline": "pChn->nTremoloPos += static_cast<uint8>(inc);"
    },
    {
        "line": 681,
        "fullcodeline": "pChn->nPanbrelloPos += static_cast<uint8>(pChn->nPanbrelloSpeed * (numTicks - 1));"
    },
    {
        "line": 682,
        "fullcodeline": "ProcessPanbrello(pChn);"
    },
    {
        "line": 723,
        "fullcodeline": "if(porta && memory.chnSettings[nChn].incChanged)"
    },
    {
        "line": 730,
        "fullcodeline": "if(pChn->nNewIns != 0) InstrumentChange(pChn, pChn->nNewIns, porta);"
    },
    {
        "line": 734,
        "fullcodeline": "if((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xD0 && paramLo < numTicks)"
    },
    {
        "line": 741,
        "fullcodeline": "if(rowDelay > 1 && startTick != 0 && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))"
    },
    {
        "line": 745,
        "fullcodeline": "if(!porta) memory.chnSettings[nChn].ticksToRender = 0;"
    },
    {
        "line": 748,
        "fullcodeline": "if(m.command == CMD_PANNING8"
    },
    {
        "line": 755,
        "fullcodeline": "if(m.command == CMD_OFFSET)"
    },
    {
        "line": 789,
        "fullcodeline": "|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xC0 && paramLo < numTicks)"
    },
    {
        "line": 806,
        "fullcodeline": "if(m.command < MAX_EFFECTS)"
    },
    {
        "line": 823,
        "fullcodeline": "if(m.volcmd < forbiddenVolCommands.size() && forbiddenVolCommands[m.volcmd])"
    },
    {
        "line": 889,
        "fullcodeline": "pChn->isFirstTick = true;"
    },
    {
        "line": 953,
        "fullcodeline": "if(!startTimes[start]) startTimes[start] = 1;"
    },
    {
        "line": 962,
        "fullcodeline": "if(memory.chnSettings[nChn].patLoop == i.first)"
    },
    {
        "line": 981,
        "fullcodeline": "if((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))"
    },
    {
        "line": 1043,
        "fullcodeline": "if(!plugSetProgram[plug])"
    },
    {
        "line": 51,
        "fullcodeline": "|| (m->IsNote() && !m->IsPortamento()))"
    },
    {
        "line": 53,
        "fullcodeline": "memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;"
    },
    {
        "line": 258,
        "fullcodeline": "} else if((p->param & 0xF0) == 0xE0 && !rowDelay)"
    },
    {
        "line": 306,
        "fullcodeline": "if(pChn->nNewIns <= GetNumInstruments() && (pIns = Instruments[pChn->nNewIns]) != nullptr)"
    },
    {
        "line": 315,
        "fullcodeline": "smp = pChn->nNewIns;"
    },
    {
        "line": 359,
        "fullcodeline": "patternBreakOnThisRow = true;"
    },
    {
        "line": 360,
        "fullcodeline": "playState.m_nNextRow = row;"
    },
    {
        "line": 379,
        "fullcodeline": "if ((adjustMode & eAdjust) && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))"
    },
    {
        "line": 384,
        "fullcodeline": "if (tempo.GetInt() >= 0x20) playState.m_nMusicTempo = tempo;"
    },
    {
        "line": 414,
        "fullcodeline": "if(param <= 0x91)"
    },
    {
        "line": 427,
        "fullcodeline": "if (param & 0x0F)"
    },
    {
        "line": 461,
        "fullcodeline": "if (param & 0x0F)"
    },
    {
        "line": 497,
        "fullcodeline": "if(!m_playBehaviour[kFT2PortaUpDownMemory])"
    },
    {
        "line": 507,
        "fullcodeline": "if(!m_playBehaviour[kFT2PortaUpDownMemory])"
    },
    {
        "line": 554,
        "fullcodeline": "if (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;"
    },
    {
        "line": 580,
        "fullcodeline": "if (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;"
    },
    {
        "line": 583,
        "fullcodeline": "volume += (param >> 4);\t\t// Fine Up"
    },
    {
        "line": 601,
        "fullcodeline": "for(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)"
    },
    {
        "line": 643,
        "fullcodeline": "Vibrato(pChn, pChn->rowCommand.vol << 4);"
    },
    {
        "line": 726,
        "fullcodeline": "pChn->increment = GetChannelIncrement(pChn, pChn->nPeriod, 0);"
    },
    {
        "line": 736,
        "fullcodeline": "startTick = paramLo;"
    },
    {
        "line": 743,
        "fullcodeline": "startTick += (playState.m_nMusicSpeed + tickDelay) * (rowDelay - 1);"
    },
    {
        "line": 750,
        "fullcodeline": "|| m.volcmd == VOLCMD_PANNING)"
    },
    {
        "line": 752,
        "fullcodeline": "pChn->nPan = setPan;"
    },
    {
        "line": 757,
        "fullcodeline": "bool isExtended = false;"
    },
    {
        "line": 758,
        "fullcodeline": "SmpLength offset = CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn, &isExtended);"
    },
    {
        "line": 765,
        "fullcodeline": "SampleOffset(*pChn, offset);"
    },
    {
        "line": 798,
        "fullcodeline": "} else if(m.volcmd == VOLCMD_VOLUME)"
    },
    {
        "line": 825,
        "fullcodeline": "stopNote = true;"
    },
    {
        "line": 835,
        "fullcodeline": "if(oldTickDuration != tickDuration && oldTickDuration != 0)"
    },
    {
        "line": 964,
        "fullcodeline": "playState.m_lTotalSampleCount += (playState.m_lTotalSampleCount - memory.chnSettings[nChn].patLoopSmp) * (i.second - 1);"
    },
    {
        "line": 983,
        "fullcodeline": "memory.chnSettings[nChn].patLoop = memory.elapsedTime;"
    },
    {
        "line": 984,
        "fullcodeline": "memory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;"
    },
    {
        "line": 1046,
        "fullcodeline": "plugSetProgram.set(plug);"
    },
    {
        "line": 1047,
        "fullcodeline": "plugin->BeginSetProgram();"
    },
    {
        "line": 1058,
        "fullcodeline": "m_MixPlugins[i].pMixPlugin->EndSetProgram();"
    },
    {
        "line": 362,
        "fullcodeline": "if(!positionJumpOnThisRow)"
    },
    {
        "line": 366,
        "fullcodeline": "if(adjustMode & eAdjust)"
    },
    {
        "line": 404,
        "fullcodeline": "tempoMax.Set(255);"
    },
    {
        "line": 416,
        "fullcodeline": "pChn->dwFlags.set(CHN_SURROUND, param == 0x91);"
    },
    {
        "line": 429,
        "fullcodeline": "patternLoopEndedOnThisRow = true;"
    },
    {
        "line": 463,
        "fullcodeline": "playState.m_nNextPatStartRow = memory.chnSettings[nChn].patLoopStart; // FT2 E60 bug"
    },
    {
        "line": 464,
        "fullcodeline": "patternLoopEndedOnThisRow = true;"
    },
    {
        "line": 498,
        "fullcodeline": "pChn->nOldPortaDown = param;"
    },
    {
        "line": 508,
        "fullcodeline": "pChn->nOldPortaUp = param;"
    },
    {
        "line": 536,
        "fullcodeline": "} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))"
    },
    {
        "line": 546,
        "fullcodeline": "if (param) pChn->nOldGlobalVolSlide = param; else param = pChn->nOldGlobalVolSlide;"
    },
    {
        "line": 556,
        "fullcodeline": "} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))"
    },
    {
        "line": 603,
        "fullcodeline": "playState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));"
    },
    {
        "line": 661,
        "fullcodeline": "inc *= 4;"
    },
    {
        "line": 672,
        "fullcodeline": "inc *= 4;"
    },
    {
        "line": 749,
        "fullcodeline": "|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && paramHi == 0x8)"
    },
    {
        "line": 759,
        "fullcodeline": "if(!isExtended)"
    },
    {
        "line": 800,
        "fullcodeline": "pChn->nVolume = m.vol * 4;"
    },
    {
        "line": 837,
        "fullcodeline": "memory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far"
    },
    {
        "line": 892,
        "fullcodeline": "case VOLCMD_FINEVOLUP:\t\tFineVolumeUp(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;"
    },
    {
        "line": 893,
        "fullcodeline": "case VOLCMD_FINEVOLDOWN:\tFineVolumeDown(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;"
    },
    {
        "line": 920,
        "fullcodeline": "uint32 portaTick = memory.chnSettings[nChn].ticksToRender + startTick + 1;"
    },
    {
        "line": 921,
        "fullcodeline": "memory.chnSettings[nChn].ticksToRender += numTicks;"
    },
    {
        "line": 922,
        "fullcodeline": "memory.RenderChannel(nChn, tickDuration, portaTick);"
    },
    {
        "line": 965,
        "fullcodeline": "if(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))"
    },
    {
        "line": 261,
        "fullcodeline": "if(!(GetType() & MOD_TYPE_S3M) || (p->param & 0x0F) != 0)"
    },
    {
        "line": 310,
        "fullcodeline": "if(ModCommand::IsNote(note))"
    },
    {
        "line": 364,
        "fullcodeline": "playState.m_nNextOrder = playState.m_nCurrentOrder + 1;"
    },
    {
        "line": 368,
        "fullcodeline": "pChn->nPatternLoopCount = 0;"
    },
    {
        "line": 369,
        "fullcodeline": "pChn->nPatternLoop = 0;"
    },
    {
        "line": 381,
        "fullcodeline": "if (tempo.GetInt()) pChn->nOldTempo = static_cast<uint8>(tempo.GetInt()); else tempo.Set(pChn->nOldTempo);"
    },
    {
        "line": 388,
        "fullcodeline": "TEMPO tempoDiff((tempo.GetInt() & 0x0F) * nonRowTicks, 0);"
    },
    {
        "line": 432,
        "fullcodeline": "CHANNELINDEX firstChn = nChn, lastChn = nChn;"
    },
    {
        "line": 445,
        "fullcodeline": "patternLoopStartedOnThisRow = true;"
    },
    {
        "line": 467,
        "fullcodeline": "patternLoopStartedOnThisRow = true;"
    },
    {
        "line": 468,
        "fullcodeline": "memory.chnSettings[nChn].patLoop = memory.elapsedTime;"
    },
    {
        "line": 469,
        "fullcodeline": "memory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;"
    },
    {
        "line": 470,
        "fullcodeline": "memory.chnSettings[nChn].patLoopStart = playState.m_nRow;"
    },
    {
        "line": 538,
        "fullcodeline": "playState.m_nGlobalVolume = 256;"
    },
    {
        "line": 549,
        "fullcodeline": "if (param) playState.Chn[0].nOldGlobalVolSlide = param; else param = playState.Chn[0].nOldGlobalVolSlide;"
    },
    {
        "line": 558,
        "fullcodeline": "param = (param & 0x0F) << 1;"
    },
    {
        "line": 560,
        "fullcodeline": "playState.m_nGlobalVolume -= param;"
    },
    {
        "line": 584,
        "fullcodeline": "else if((param & 0xF0) == 0xF0 && (param & 0x0F))"
    },
    {
        "line": 737,
        "fullcodeline": "} else if(m.command == CMD_DELAYCUT && paramHi < numTicks)"
    },
    {
        "line": 761,
        "fullcodeline": "offset <<= 8;"
    },
    {
        "line": 763,
        "fullcodeline": "offset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;"
    },
    {
        "line": 766,
        "fullcodeline": "} else if(m.command == CMD_OFFSETPERCENTAGE)"
    },
    {
        "line": 810,
        "fullcodeline": "stopNote = true;"
    },
    {
        "line": 845,
        "fullcodeline": "if(m.param || (GetType() != MOD_TYPE_MOD))"
    },
    {
        "line": 856,
        "fullcodeline": "if((m.param & 0x0F) || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))"
    },
    {
        "line": 868,
        "fullcodeline": "if(m.param == 0x9E)"
    },
    {
        "line": 899,
        "fullcodeline": "ModCommand::VOL vol = m.vol;"
    },
    {
        "line": 925,
        "fullcodeline": "memory.chnSettings[nChn].ticksToRender += (numTicks - startTick);"
    },
    {
        "line": 967,
        "fullcodeline": "memory.chnSettings[nChn].patLoop = memory.elapsedTime;"
    },
    {
        "line": 968,
        "fullcodeline": "memory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;"
    },
    {
        "line": 969,
        "fullcodeline": "memory.chnSettings[nChn].patLoopStart = playState.m_nRow + 1;"
    },
    {
        "line": 265,
        "fullcodeline": "rowDelay = 1 + (p->param & 0x0F);"
    },
    {
        "line": 309,
        "fullcodeline": "pChn->nPan = pIns->nPan;"
    },
    {
        "line": 311,
        "fullcodeline": "smp = pIns->Keyboard[note - NOTE_MIN];"
    },
    {
        "line": 389,
        "fullcodeline": "if ((tempo.GetInt() & 0xF0) == 0x10)"
    },
    {
        "line": 433,
        "fullcodeline": "if(GetType() == MOD_TYPE_S3M)"
    },
    {
        "line": 439,
        "fullcodeline": "for(CHANNELINDEX c = firstChn; c <= lastChn; c++)"
    },
    {
        "line": 559,
        "fullcodeline": "if (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;"
    },
    {
        "line": 585,
        "fullcodeline": "volume -= (param & 0x0F);\t// Fine Down"
    },
    {
        "line": 739,
        "fullcodeline": "startTick = paramHi;"
    },
    {
        "line": 762,
        "fullcodeline": "if(offset == 0) offset = pChn->oldOffset;"
    },
    {
        "line": 768,
        "fullcodeline": "SampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, m.param, 255));"
    },
    {
        "line": 858,
        "fullcodeline": "pChn->isFirstTick = true;"
    },
    {
        "line": 871,
        "fullcodeline": "memory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far"
    },
    {
        "line": 872,
        "fullcodeline": "pChn->dwFlags.reset(CHN_PINGPONGFLAG);"
    },
    {
        "line": 900,
        "fullcodeline": "if(vol == 0 && m_playBehaviour[kITVolColMemory])"
    },
    {
        "line": 906,
        "fullcodeline": "if(m.volcmd == VOLCMD_VOLSLIDEUP)"
    },
    {
        "line": 908,
        "fullcodeline": "for(uint32 i = 0; i < numTicks; i++)"
    },
    {
        "line": 391,
        "fullcodeline": "playState.m_nMusicTempo += tempoDiff;"
    },
    {
        "line": 436,
        "fullcodeline": "firstChn = 0;"
    },
    {
        "line": 437,
        "fullcodeline": "lastChn = GetNumChannels() - 1;"
    },
    {
        "line": 441,
        "fullcodeline": "memory.chnSettings[c].patLoop = memory.elapsedTime;"
    },
    {
        "line": 442,
        "fullcodeline": "memory.chnSettings[c].patLoopSmp = playState.m_lTotalSampleCount;"
    },
    {
        "line": 443,
        "fullcodeline": "memory.chnSettings[c].patLoopStart = playState.m_nRow;"
    },
    {
        "line": 561,
        "fullcodeline": "} else if (param & 0xF0)"
    },
    {
        "line": 811,
        "fullcodeline": "} else if(m.command == CMD_MODCMDEX)"
    },
    {
        "line": 847,
        "fullcodeline": "for(uint32 i = 0; i < numTicks; i++)"
    },
    {
        "line": 859,
        "fullcodeline": "switch(m.param & 0xF0)"
    },
    {
        "line": 902,
        "fullcodeline": "vol = pChn->nOldVolParam;"
    },
    {
        "line": 907,
        "fullcodeline": "vol <<= 4;"
    },
    {
        "line": 910,
        "fullcodeline": "pChn->isFirstTick = (i == 0);"
    },
    {
        "line": 911,
        "fullcodeline": "VolumeSlide(pChn, vol);"
    },
    {
        "line": 563,
        "fullcodeline": "param >>= 4;"
    },
    {
        "line": 564,
        "fullcodeline": "param <<= 1;"
    },
    {
        "line": 566,
        "fullcodeline": "playState.m_nGlobalVolume += param * nonRowTicks;"
    },
    {
        "line": 586,
        "fullcodeline": "else if(param & 0x0F)\t\t\t// Down"
    },
    {
        "line": 769,
        "fullcodeline": "} else if(m.command == CMD_REVERSEOFFSET && pChn->pModSample != nullptr)"
    },
    {
        "line": 849,
        "fullcodeline": "pChn->isFirstTick = (i == 0);"
    },
    {
        "line": 850,
        "fullcodeline": "VolumeSlide(pChn, m.param);"
    },
    {
        "line": 861,
        "fullcodeline": "case 0xA0: FineVolumeUp(pChn, m.param & 0x0F, false); break;"
    },
    {
        "line": 862,
        "fullcodeline": "case 0xB0: FineVolumeDown(pChn, m.param & 0x0F, false); break;"
    },
    {
        "line": 873,
        "fullcodeline": "} else if(m.param == 0x9F)"
    },
    {
        "line": 903,
        "fullcodeline": "if(vol == 0)"
    },
    {
        "line": 394,
        "fullcodeline": "if(tempoDiff < playState.m_nMusicTempo)"
    },
    {
        "line": 565,
        "fullcodeline": "if (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;"
    },
    {
        "line": 569,
        "fullcodeline": "param = (param & 0x0F) << 1;"
    },
    {
        "line": 571,
        "fullcodeline": "playState.m_nGlobalVolume -= param * nonRowTicks;"
    },
    {
        "line": 587,
        "fullcodeline": "volume -= (param & 0x0F) * nonRowTicks;"
    },
    {
        "line": 771,
        "fullcodeline": "memory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far"
    },
    {
        "line": 772,
        "fullcodeline": "ReverseSampleOffset(*pChn, m.param);"
    },
    {
        "line": 773,
        "fullcodeline": "startTick = playState.m_nMusicSpeed - 1;"
    },
    {
        "line": 814,
        "fullcodeline": "switch(m.param & 0xF0)"
    },
    {
        "line": 876,
        "fullcodeline": "memory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far"
    },
    {
        "line": 877,
        "fullcodeline": "pChn->dwFlags.set(CHN_PINGPONGFLAG);"
    },
    {
        "line": 395,
        "fullcodeline": "playState.m_nMusicTempo -= tempoDiff;"
    },
    {
        "line": 570,
        "fullcodeline": "if (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;"
    },
    {
        "line": 589,
        "fullcodeline": "volume += ((param & 0xF0) >> 4) * nonRowTicks;"
    },
    {
        "line": 818,
        "fullcodeline": "stopNote = true;"
    },
    {
        "line": 878,
        "fullcodeline": "if(!pChn->position.GetInt() && pChn->nLength && (m.IsNote() || !pChn->dwFlags[CHN_LOOP]))"
    },
    {
        "line": 397,
        "fullcodeline": "playState.m_nMusicTempo.Set(0);"
    },
    {
        "line": 774,
        "fullcodeline": "} else if(m.volcmd == VOLCMD_OFFSET)"
    },
    {
        "line": 880,
        "fullcodeline": "pChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);"
    },
    {
        "line": 882,
        "fullcodeline": "} else if((m.param & 0xF0) == 0x70)"
    },
    {
        "line": 776,
        "fullcodeline": "if(m.vol <= CountOf(pChn->pModSample->cues) && pChn->pModSample != nullptr)"
    },
    {
        "line": 783,
        "fullcodeline": "SampleOffset(*pChn, offset);"
    },
    {
        "line": 779,
        "fullcodeline": "if(m.vol == 0)"
    },
    {
        "line": 780,
        "fullcodeline": "offset = pChn->oldOffset;"
    },
    {
        "line": 782,
        "fullcodeline": "offset = pChn->oldOffset = pChn->pModSample->cues[m.vol - 1];"
    }
]