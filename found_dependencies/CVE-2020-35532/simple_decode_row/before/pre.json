[
    {
        "line": 4,
        "fullcodeline": "x3f_directory_entry_header_t *DEH = &DE->header;"
    },
    {
        "line": 5,
        "fullcodeline": "x3f_image_data_t *ID = &DEH->data_subsection.image_data;"
    },
    {
        "line": 6,
        "fullcodeline": "x3f_huffman_t *HUF = ID->huffman;"
    },
    {
        "line": 8,
        "fullcodeline": "uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);"
    },
    {
        "line": 10,
        "fullcodeline": "uint16_t c[3] = {0, 0, 0};"
    },
    {
        "line": 39,
        "fullcodeline": "for (col = 0; col < ID->columns; col++)"
    },
    {
        "line": 18,
        "fullcodeline": "mask = 0x0ff;"
    },
    {
        "line": 21,
        "fullcodeline": "mask = 0x1ff;"
    },
    {
        "line": 24,
        "fullcodeline": "mask = 0x3ff;"
    },
    {
        "line": 27,
        "fullcodeline": "mask = 0x7ff;"
    },
    {
        "line": 30,
        "fullcodeline": "mask = 0xfff;"
    },
    {
        "line": 33,
        "fullcodeline": "mask = 0;"
    },
    {
        "line": 42,
        "fullcodeline": "uint32_t val = data[col];"
    },
    {
        "line": 44,
        "fullcodeline": "for (color = 0; color < 3; color++)"
    },
    {
        "line": 47,
        "fullcodeline": "c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);"
    },
    {
        "line": 53,
        "fullcodeline": "c_fix = (int16_t)c[color] > 0 ? c[color] : 0;"
    },
    {
        "line": 58,
        "fullcodeline": "c_fix = (int8_t)c[color] > 0 ? c[color] : 0;"
    },
    {
        "line": 55,
        "fullcodeline": "HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;"
    },
    {
        "line": 60,
        "fullcodeline": "HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;"
    }
]