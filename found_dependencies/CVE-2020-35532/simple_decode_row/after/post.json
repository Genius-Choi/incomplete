[
    {
        "line": 4,
        "fullcodeline": "x3f_directory_entry_header_t *DEH = &DE->header;"
    },
    {
        "line": 6,
        "fullcodeline": "x3f_huffman_t *HUF = ID->huffman;"
    },
    {
        "line": 10,
        "fullcodeline": "uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);"
    },
    {
        "line": 12,
        "fullcodeline": "uint16_t c[3] = {0, 0, 0};"
    },
    {
        "line": 15,
        "fullcodeline": "uint32_t mask = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))"
    },
    {
        "line": 41,
        "fullcodeline": "for (col = 0; col < ID->columns; col++)"
    },
    {
        "line": 20,
        "fullcodeline": "mask = 0x0ff;"
    },
    {
        "line": 23,
        "fullcodeline": "mask = 0x1ff;"
    },
    {
        "line": 26,
        "fullcodeline": "mask = 0x3ff;"
    },
    {
        "line": 29,
        "fullcodeline": "mask = 0x7ff;"
    },
    {
        "line": 32,
        "fullcodeline": "mask = 0xfff;"
    },
    {
        "line": 35,
        "fullcodeline": "mask = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "uint32_t val = data[col];"
    },
    {
        "line": 46,
        "fullcodeline": "for (color = 0; color < 3; color++)"
    },
    {
        "line": 49,
        "fullcodeline": "c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);"
    },
    {
        "line": 55,
        "fullcodeline": "c_fix = (int16_t)c[color] > 0 ? c[color] : 0;"
    },
    {
        "line": 57,
        "fullcodeline": "HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;"
    },
    {
        "line": 60,
        "fullcodeline": "c_fix = (int8_t)c[color] > 0 ? c[color] : 0;"
    },
    {
        "line": 62,
        "fullcodeline": "HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;"
    }
]