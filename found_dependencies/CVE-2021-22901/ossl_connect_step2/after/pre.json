[
    {
        "line": 5,
        "fullcodeline": "struct ssl_connect_data *connssl = &conn->ssl[sockindex];"
    },
    {
        "line": 6,
        "fullcodeline": "struct ssl_backend_data *backend = connssl->backend;"
    },
    {
        "line": 7,
        "fullcodeline": "DEBUGASSERT(ssl_connect_2 == connssl->connecting_state"
    },
    {
        "line": 11,
        "fullcodeline": "ERR_clear_error();"
    },
    {
        "line": 13,
        "fullcodeline": "err = SSL_connect(backend->handle);"
    },
    {
        "line": 15,
        "fullcodeline": "if(Curl_tls_keylog_enabled()) {"
    },
    {
        "line": 26,
        "fullcodeline": "if(1 != err) {"
    },
    {
        "line": 9,
        "fullcodeline": "|| ssl_connect_2_writing == connssl->connecting_state);"
    },
    {
        "line": 19,
        "fullcodeline": "ossl_log_tls12_secret(backend->handle, &backend->keylog_done);"
    },
    {
        "line": 27,
        "fullcodeline": "int detail = SSL_get_error(backend->handle, err);"
    },
    {
        "line": 8,
        "fullcodeline": "|| ssl_connect_2_reading == connssl->connecting_state"
    },
    {
        "line": 29,
        "fullcodeline": "if(SSL_ERROR_WANT_READ == detail) {"
    },
    {
        "line": 33,
        "fullcodeline": "if(SSL_ERROR_WANT_WRITE == detail) {"
    },
    {
        "line": 125,
        "fullcodeline": "connssl->connecting_state = ssl_connect_3;"
    },
    {
        "line": 30,
        "fullcodeline": "connssl->connecting_state = ssl_connect_2_reading;"
    },
    {
        "line": 129,
        "fullcodeline": "SSL_get_version(backend->handle),"
    },
    {
        "line": 130,
        "fullcodeline": "SSL_get_cipher(backend->handle));"
    },
    {
        "line": 46,
        "fullcodeline": "char error_buffer[256]=\"\";"
    },
    {
        "line": 57,
        "fullcodeline": "errdetail = ERR_get_error();"
    },
    {
        "line": 60,
        "fullcodeline": "lib = ERR_GET_LIB(errdetail);"
    },
    {
        "line": 61,
        "fullcodeline": "reason = ERR_GET_REASON(errdetail);"
    },
    {
        "line": 63,
        "fullcodeline": "if((lib == ERR_LIB_SSL) &&"
    },
    {
        "line": 64,
        "fullcodeline": "((reason == SSL_R_CERTIFICATE_VERIFY_FAILED) ||"
    },
    {
        "line": 66,
        "fullcodeline": "result = CURLE_PEER_FAILED_VERIFICATION;"
    },
    {
        "line": 68,
        "fullcodeline": "lerr = SSL_get_verify_result(backend->handle);"
    },
    {
        "line": 104,
        "fullcodeline": "if(CURLE_SSL_CONNECT_ERROR == result && errdetail == 0) {"
    },
    {
        "line": 108,
        "fullcodeline": "int sockerr = SOCKERRNO;"
    },
    {
        "line": 65,
        "fullcodeline": "(reason == SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED))) {"
    },
    {
        "line": 69,
        "fullcodeline": "if(lerr != X509_V_OK) {"
    },
    {
        "line": 94,
        "fullcodeline": "result = CURLE_SSL_CONNECT_ERROR;"
    },
    {
        "line": 95,
        "fullcodeline": "ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));"
    },
    {
        "line": 107,
        "fullcodeline": "char extramsg[80]=\"\";"
    },
    {
        "line": 109,
        "fullcodeline": "if(sockerr && detail == SSL_ERROR_SYSCALL)"
    },
    {
        "line": 70,
        "fullcodeline": "SSL_SET_OPTION_LVALUE(certverifyresult) = lerr;"
    },
    {
        "line": 71,
        "fullcodeline": "msnprintf(error_buffer, sizeof(error_buffer),"
    },
    {
        "line": 73,
        "fullcodeline": "X509_verify_cert_error_string(lerr));"
    },
    {
        "line": 78,
        "fullcodeline": "strcpy(error_buffer, \"SSL certificate verification failed\");"
    }
]