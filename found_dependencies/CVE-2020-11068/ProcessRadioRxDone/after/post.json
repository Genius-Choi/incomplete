[
    {
        "line": 7,
        "fullcodeline": "LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;"
    },
    {
        "line": 16,
        "fullcodeline": "uint8_t pktHeaderLen = 0;"
    },
    {
        "line": 18,
        "fullcodeline": "uint32_t downLinkCounter = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "uint8_t multicast = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "AddressIdentifier_t addrID = UNICAST_DEV_ADDR;"
    },
    {
        "line": 24,
        "fullcodeline": "MacCtx.McpsConfirm.AckReceived = false;"
    },
    {
        "line": 25,
        "fullcodeline": "MacCtx.McpsIndication.Rssi = rssi;"
    },
    {
        "line": 26,
        "fullcodeline": "MacCtx.McpsIndication.Snr = snr;"
    },
    {
        "line": 28,
        "fullcodeline": "MacCtx.McpsIndication.Port = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "MacCtx.McpsIndication.Multicast = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "MacCtx.McpsIndication.FramePending = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "MacCtx.McpsIndication.Buffer = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "MacCtx.McpsIndication.BufferSize = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "MacCtx.McpsIndication.RxData = false;"
    },
    {
        "line": 34,
        "fullcodeline": "MacCtx.McpsIndication.AckReceived = false;"
    },
    {
        "line": 35,
        "fullcodeline": "MacCtx.McpsIndication.DownLinkCounter = 0;"
    },
    {
        "line": 36,
        "fullcodeline": "MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;"
    },
    {
        "line": 37,
        "fullcodeline": "MacCtx.McpsIndication.DevAddress = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "MacCtx.McpsIndication.DeviceTimeAnsReceived = false;"
    },
    {
        "line": 40,
        "fullcodeline": "Radio.Sleep( );"
    },
    {
        "line": 67,
        "fullcodeline": "macHdr.Value = payload[pktHeaderLen++];"
    },
    {
        "line": 404,
        "fullcodeline": "MacCtx.MacFlags.Bits.MacDone = 1;"
    },
    {
        "line": 406,
        "fullcodeline": "UpdateRxSlotIdleState( );"
    },
    {
        "line": 44,
        "fullcodeline": "if( LoRaMacClassBRxBeacon( payload, size ) == true )"
    },
    {
        "line": 51,
        "fullcodeline": "if( MacCtx.NvmCtx->DeviceClass == CLASS_B )"
    },
    {
        "line": 390,
        "fullcodeline": "if( MacCtx.NodeAckRequested == true )"
    },
    {
        "line": 46,
        "fullcodeline": "MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;"
    },
    {
        "line": 47,
        "fullcodeline": "MacCtx.MlmeIndication.BeaconInfo.Snr = snr;"
    },
    {
        "line": 79,
        "fullcodeline": "macMsgJoinAccept.Buffer = payload;"
    },
    {
        "line": 80,
        "fullcodeline": "macMsgJoinAccept.BufSize = size;"
    },
    {
        "line": 89,
        "fullcodeline": "macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );"
    },
    {
        "line": 142,
        "fullcodeline": "MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;"
    },
    {
        "line": 148,
        "fullcodeline": "getPhy.Attribute = PHY_MAX_PAYLOAD;"
    },
    {
        "line": 149,
        "fullcodeline": "phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );"
    },
    {
        "line": 157,
        "fullcodeline": "macMsgData.Buffer = payload;"
    },
    {
        "line": 158,
        "fullcodeline": "macMsgData.BufSize = size;"
    },
    {
        "line": 160,
        "fullcodeline": "macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;"
    },
    {
        "line": 181,
        "fullcodeline": "multicast = 0;"
    },
    {
        "line": 182,
        "fullcodeline": "downLinkCounter = 0;"
    },
    {
        "line": 211,
        "fullcodeline": "getPhy.Attribute = PHY_MAX_FCNT_GAP;"
    },
    {
        "line": 212,
        "fullcodeline": "phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );"
    },
    {
        "line": 215,
        "fullcodeline": "macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, MacCtx.NvmCtx->Version, phyParam.Value, &fCntID, &downLinkCounter );"
    },
    {
        "line": 242,
        "fullcodeline": "macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );"
    },
    {
        "line": 260,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;"
    },
    {
        "line": 261,
        "fullcodeline": "MacCtx.McpsIndication.Multicast = multicast;"
    },
    {
        "line": 263,
        "fullcodeline": "MacCtx.McpsIndication.Buffer = NULL;"
    },
    {
        "line": 264,
        "fullcodeline": "MacCtx.McpsIndication.BufferSize = 0;"
    },
    {
        "line": 265,
        "fullcodeline": "MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;"
    },
    {
        "line": 266,
        "fullcodeline": "MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;"
    },
    {
        "line": 268,
        "fullcodeline": "MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;"
    },
    {
        "line": 269,
        "fullcodeline": "MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;"
    },
    {
        "line": 301,
        "fullcodeline": "RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );"
    },
    {
        "line": 370,
        "fullcodeline": "MacCtx.MacFlags.Bits.McpsInd = 1;"
    },
    {
        "line": 374,
        "fullcodeline": "memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );"
    },
    {
        "line": 376,
        "fullcodeline": "MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;"
    },
    {
        "line": 377,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;"
    },
    {
        "line": 378,
        "fullcodeline": "MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;"
    },
    {
        "line": 379,
        "fullcodeline": "MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;"
    },
    {
        "line": 381,
        "fullcodeline": "MacCtx.MacFlags.Bits.McpsInd = 1;"
    },
    {
        "line": 384,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 385,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 53,
        "fullcodeline": "if( LoRaMacClassBIsPingExpected( ) == true )"
    },
    {
        "line": 73,
        "fullcodeline": "if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )"
    },
    {
        "line": 83,
        "fullcodeline": "if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE )"
    },
    {
        "line": 91,
        "fullcodeline": "if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )"
    },
    {
        "line": 150,
        "fullcodeline": "if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||"
    },
    {
        "line": 162,
        "fullcodeline": "if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )"
    },
    {
        "line": 173,
        "fullcodeline": "if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )"
    },
    {
        "line": 183,
        "fullcodeline": "for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )"
    },
    {
        "line": 201,
        "fullcodeline": "if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||"
    },
    {
        "line": 216,
        "fullcodeline": "if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )"
    },
    {
        "line": 243,
        "fullcodeline": "if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )"
    },
    {
        "line": 272,
        "fullcodeline": "if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||"
    },
    {
        "line": 279,
        "fullcodeline": "if( multicast == 1 )"
    },
    {
        "line": 392,
        "fullcodeline": "if( MacCtx.McpsConfirm.AckReceived == true )"
    },
    {
        "line": 55,
        "fullcodeline": "LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );"
    },
    {
        "line": 56,
        "fullcodeline": "LoRaMacClassBPingSlotTimerEvent( NULL );"
    },
    {
        "line": 57,
        "fullcodeline": "MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;"
    },
    {
        "line": 75,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 76,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 85,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 86,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 95,
        "fullcodeline": "MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );"
    },
    {
        "line": 96,
        "fullcodeline": "MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );"
    },
    {
        "line": 99,
        "fullcodeline": "MacCtx.NvmCtx->DevAddr = macMsgJoinAccept.DevAddr;"
    },
    {
        "line": 107,
        "fullcodeline": "MacCtx.NvmCtx->MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;"
    },
    {
        "line": 112,
        "fullcodeline": "MacCtx.NvmCtx->MacParams.ReceiveDelay1 *= 1000;"
    },
    {
        "line": 113,
        "fullcodeline": "MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;"
    },
    {
        "line": 115,
        "fullcodeline": "MacCtx.NvmCtx->Version.Fields.Minor = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "applyCFList.Payload = macMsgJoinAccept.CFList;"
    },
    {
        "line": 120,
        "fullcodeline": "applyCFList.Size = size - 17;"
    },
    {
        "line": 122,
        "fullcodeline": "RegionApplyCFList( MacCtx.NvmCtx->Region, &applyCFList );"
    },
    {
        "line": 124,
        "fullcodeline": "MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_OTAA;"
    },
    {
        "line": 151,
        "fullcodeline": "( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )"
    },
    {
        "line": 153,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 154,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 164,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 165,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 175,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 176,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 205,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 206,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 237,
        "fullcodeline": "MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;"
    },
    {
        "line": 238,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 255,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 273,
        "fullcodeline": "( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )"
    },
    {
        "line": 275,
        "fullcodeline": "MacCtx.NvmCtx->AdrAckCounter = 0;"
    },
    {
        "line": 281,
        "fullcodeline": "MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;"
    },
    {
        "line": 363,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    },
    {
        "line": 364,
        "fullcodeline": "PrepareRxDoneAbort( );"
    },
    {
        "line": 394,
        "fullcodeline": "OnAckTimeoutTimerEvent( NULL );"
    },
    {
        "line": 399,
        "fullcodeline": "if( MacCtx.NvmCtx->DeviceClass == CLASS_C )"
    },
    {
        "line": 108,
        "fullcodeline": "if( MacCtx.NvmCtx->MacParams.ReceiveDelay1 == 0 )"
    },
    {
        "line": 127,
        "fullcodeline": "if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )"
    },
    {
        "line": 185,
        "fullcodeline": "if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&"
    },
    {
        "line": 203,
        "fullcodeline": "( macMsgData.FHDR.FCtrl.Bits.AdrAckReq == true ) ) )"
    },
    {
        "line": 218,
        "fullcodeline": "if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )"
    },
    {
        "line": 245,
        "fullcodeline": "if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )"
    },
    {
        "line": 314,
        "fullcodeline": "ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );"
    },
    {
        "line": 315,
        "fullcodeline": "MacCtx.McpsIndication.Port = macMsgData.FPort;"
    },
    {
        "line": 316,
        "fullcodeline": "MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;"
    },
    {
        "line": 317,
        "fullcodeline": "MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;"
    },
    {
        "line": 318,
        "fullcodeline": "MacCtx.McpsIndication.RxData = true;"
    },
    {
        "line": 330,
        "fullcodeline": "ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );"
    },
    {
        "line": 331,
        "fullcodeline": "MacCtx.McpsIndication.Port = macMsgData.FPort;"
    },
    {
        "line": 343,
        "fullcodeline": "ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );"
    },
    {
        "line": 344,
        "fullcodeline": "MacCtx.McpsIndication.Port = macMsgData.FPort;"
    },
    {
        "line": 356,
        "fullcodeline": "MacCtx.McpsIndication.Port = macMsgData.FPort;"
    },
    {
        "line": 357,
        "fullcodeline": "MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;"
    },
    {
        "line": 358,
        "fullcodeline": "MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;"
    },
    {
        "line": 359,
        "fullcodeline": "MacCtx.McpsIndication.RxData = true;"
    },
    {
        "line": 401,
        "fullcodeline": "OnAckTimeoutTimerEvent( NULL );"
    },
    {
        "line": 59,
        "fullcodeline": "else if( LoRaMacClassBIsMulticastExpected( ) == true )"
    },
    {
        "line": 110,
        "fullcodeline": "MacCtx.NvmCtx->MacParams.ReceiveDelay1 = 1;"
    },
    {
        "line": 129,
        "fullcodeline": "LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );"
    },
    {
        "line": 135,
        "fullcodeline": "if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )"
    },
    {
        "line": 186,
        "fullcodeline": "( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true ) )"
    },
    {
        "line": 188,
        "fullcodeline": "multicast = 1;"
    },
    {
        "line": 191,
        "fullcodeline": "address = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address;"
    },
    {
        "line": 202,
        "fullcodeline": "( macMsgData.FHDR.FCtrl.Bits.Ack == true ) ||"
    },
    {
        "line": 221,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;"
    },
    {
        "line": 248,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;"
    },
    {
        "line": 285,
        "fullcodeline": "if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )"
    },
    {
        "line": 61,
        "fullcodeline": "LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );"
    },
    {
        "line": 62,
        "fullcodeline": "LoRaMacClassBMulticastSlotTimerEvent( NULL );"
    },
    {
        "line": 63,
        "fullcodeline": "MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;"
    },
    {
        "line": 137,
        "fullcodeline": "LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );"
    },
    {
        "line": 192,
        "fullcodeline": "if( MacCtx.NvmCtx->DeviceClass == CLASS_C )"
    },
    {
        "line": 222,
        "fullcodeline": "if( ( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx.NvmCtx->LastRxMic == macMsgData.MIC ) )"
    },
    {
        "line": 253,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;"
    },
    {
        "line": 287,
        "fullcodeline": "MacCtx.NvmCtx->SrvAckRequested = true;"
    },
    {
        "line": 292,
        "fullcodeline": "MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;"
    },
    {
        "line": 194,
        "fullcodeline": "MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;"
    },
    {
        "line": 224,
        "fullcodeline": "MacCtx.NvmCtx->SrvAckRequested = true;"
    },
    {
        "line": 227,
        "fullcodeline": "else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )"
    },
    {
        "line": 288,
        "fullcodeline": "if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )"
    },
    {
        "line": 296,
        "fullcodeline": "MacCtx.NvmCtx->SrvAckRequested = false;"
    },
    {
        "line": 297,
        "fullcodeline": "MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;"
    },
    {
        "line": 230,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;"
    },
    {
        "line": 290,
        "fullcodeline": "MacCtx.NvmCtx->LastRxMic = macMsgData.MIC;"
    },
    {
        "line": 235,
        "fullcodeline": "MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;"
    }
]