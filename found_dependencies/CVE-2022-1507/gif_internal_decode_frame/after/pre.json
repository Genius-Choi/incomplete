[
    {
        "line": 5,
        "fullcodeline": "unsigned int index = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned int *frame_data = 0;\t// Set to 0 for no warnings"
    },
    {
        "line": 14,
        "fullcodeline": "unsigned int return_value = 0;"
    },
    {
        "line": 41,
        "fullcodeline": "gif_data = gif->gif_data + gif->frames[frame].frame_pointer;"
    },
    {
        "line": 42,
        "fullcodeline": "gif_end = gif->gif_data + gif->buffer_size;"
    },
    {
        "line": 43,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 54,
        "fullcodeline": "save_buffer_position = gif->buffer_position;"
    },
    {
        "line": 55,
        "fullcodeline": "gif->buffer_position = gif_data - gif->gif_data;"
    },
    {
        "line": 61,
        "fullcodeline": "gif_data = (gif->gif_data + gif->buffer_position);"
    },
    {
        "line": 62,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 90,
        "fullcodeline": "offset_x = gif_data[1] | (gif_data[2] << 8);"
    },
    {
        "line": 91,
        "fullcodeline": "offset_y = gif_data[3] | (gif_data[4] << 8);"
    },
    {
        "line": 92,
        "fullcodeline": "width = gif_data[5] | (gif_data[6] << 8);"
    },
    {
        "line": 93,
        "fullcodeline": "height = gif_data[7] | (gif_data[8] << 8);"
    },
    {
        "line": 105,
        "fullcodeline": "flags = gif_data[9];"
    },
    {
        "line": 106,
        "fullcodeline": "colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);"
    },
    {
        "line": 112,
        "fullcodeline": "gif_data += 10;"
    },
    {
        "line": 113,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 163,
        "fullcodeline": "frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);"
    },
    {
        "line": 20,
        "fullcodeline": "if (gif->frames == NULL) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (gif->frames[frame].display == false) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (frame > gif->frame_count_partial) {"
    },
    {
        "line": 58,
        "fullcodeline": "if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (gif_data[0] != GIF_IMAGE_SEPARATOR) {"
    },
    {
        "line": 107,
        "fullcodeline": "interlace = flags & GIF_INTERLACE_MASK;"
    },
    {
        "line": 116,
        "fullcodeline": "if (flags & GIF_COLOUR_TABLE_MASK) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (gif_bytes < 1) {"
    },
    {
        "line": 156,
        "fullcodeline": "if (gif_data[0] == GIF_TRAILER) {"
    },
    {
        "line": 164,
        "fullcodeline": "if (!frame_data) {"
    },
    {
        "line": 35,
        "fullcodeline": "if ((!clear_image) &&"
    },
    {
        "line": 36,
        "fullcodeline": "((int)frame == gif->decoded_frame)) {"
    },
    {
        "line": 68,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 87,
        "fullcodeline": "return_value = GIF_DATA_ERROR;"
    },
    {
        "line": 98,
        "fullcodeline": "if ((offset_x + width > gif->width) ||"
    },
    {
        "line": 99,
        "fullcodeline": "(offset_y + height > gif->height)) {"
    },
    {
        "line": 100,
        "fullcodeline": "return_value = GIF_DATA_ERROR;"
    },
    {
        "line": 121,
        "fullcodeline": "colour_table = gif->local_colour_table;"
    },
    {
        "line": 144,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 151,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 157,
        "fullcodeline": "return_value = GIF_OK;"
    },
    {
        "line": 247,
        "fullcodeline": "gif->buffer_position = (gif_data - gif->gif_data) + 1;"
    },
    {
        "line": 250,
        "fullcodeline": "res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,"
    },
    {
        "line": 331,
        "fullcodeline": "gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);"
    },
    {
        "line": 122,
        "fullcodeline": "if (!clear_image) {"
    },
    {
        "line": 146,
        "fullcodeline": "colour_table = gif->global_colour_table;"
    },
    {
        "line": 177,
        "fullcodeline": "if (gif_bytes < 2) {"
    },
    {
        "line": 253,
        "fullcodeline": "if (res != LZW_OK) {"
    },
    {
        "line": 258,
        "fullcodeline": "for (y = 0; y < height; y++) {"
    },
    {
        "line": 118,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 178,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 185,
        "fullcodeline": "if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {"
    },
    {
        "line": 186,
        "fullcodeline": "return_value = GIF_OK;"
    },
    {
        "line": 194,
        "fullcodeline": "if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {"
    },
    {
        "line": 264,
        "fullcodeline": "frame_scanline = frame_data + offset_x + (decode_y * gif->width);"
    },
    {
        "line": 270,
        "fullcodeline": "x = width;"
    },
    {
        "line": 323,
        "fullcodeline": "gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);"
    },
    {
        "line": 117,
        "fullcodeline": "if (gif_bytes < (int)(3 * colour_table_size)) {"
    },
    {
        "line": 123,
        "fullcodeline": "for (index = 0; index < colour_table_size; index++) {"
    },
    {
        "line": 142,
        "fullcodeline": "gif_data += 3 * colour_table_size;"
    },
    {
        "line": 197,
        "fullcodeline": "gif->width * gif->height * sizeof(int));"
    },
    {
        "line": 254,
        "fullcodeline": "return gif_error_from_lzw(res);"
    },
    {
        "line": 271,
        "fullcodeline": "while (x > 0) {"
    },
    {
        "line": 325,
        "fullcodeline": "gif->frames[frame].opaque = false;"
    },
    {
        "line": 139,
        "fullcodeline": "gif_data += 3;"
    },
    {
        "line": 260,
        "fullcodeline": "decode_y = gif_interlaced_line(height, y) + offset_y;"
    },
    {
        "line": 272,
        "fullcodeline": "burst_bytes = (stack_pos - stack_base);"
    },
    {
        "line": 304,
        "fullcodeline": "for (y = 0; y < height; y++) {"
    },
    {
        "line": 203,
        "fullcodeline": "} else if ((frame != 0) &&"
    },
    {
        "line": 204,
        "fullcodeline": "(gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {"
    },
    {
        "line": 205,
        "fullcodeline": "return_value = gif_internal_decode_frame(gif,"
    },
    {
        "line": 262,
        "fullcodeline": "decode_y = y + offset_y;"
    },
    {
        "line": 273,
        "fullcodeline": "if (burst_bytes > 0) {"
    },
    {
        "line": 305,
        "fullcodeline": "frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);"
    },
    {
        "line": 208,
        "fullcodeline": "if (return_value != GIF_OK) {"
    },
    {
        "line": 277,
        "fullcodeline": "x -= burst_bytes;"
    },
    {
        "line": 206,
        "fullcodeline": "(frame - 1),"
    },
    {
        "line": 274,
        "fullcodeline": "if (burst_bytes > x) {"
    },
    {
        "line": 288,
        "fullcodeline": "res = lzw_decode(gif->lzw_ctx, &stack_pos);"
    },
    {
        "line": 212,
        "fullcodeline": "} else if ((frame != 0) &&"
    },
    {
        "line": 213,
        "fullcodeline": "(gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {"
    },
    {
        "line": 219,
        "fullcodeline": "int last_undisposed_frame = frame - 2;"
    },
    {
        "line": 275,
        "fullcodeline": "burst_bytes = x;"
    },
    {
        "line": 278,
        "fullcodeline": "while (burst_bytes-- > 0) {"
    },
    {
        "line": 279,
        "fullcodeline": "colour = *--stack_pos;"
    },
    {
        "line": 289,
        "fullcodeline": "if (res != LZW_OK) {"
    },
    {
        "line": 309,
        "fullcodeline": "width * 4);"
    },
    {
        "line": 226,
        "fullcodeline": "if (last_undisposed_frame == -1) {"
    },
    {
        "line": 313,
        "fullcodeline": "width * 4);"
    },
    {
        "line": 220,
        "fullcodeline": "while ((last_undisposed_frame >= 0) &&"
    },
    {
        "line": 221,
        "fullcodeline": "(gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {"
    },
    {
        "line": 222,
        "fullcodeline": "last_undisposed_frame--;"
    },
    {
        "line": 280,
        "fullcodeline": "if (((gif->frames[frame].transparency) &&"
    },
    {
        "line": 282,
        "fullcodeline": "(!gif->frames[frame].transparency)) {"
    },
    {
        "line": 283,
        "fullcodeline": "*frame_scanline = colour_table[colour];"
    },
    {
        "line": 291,
        "fullcodeline": "if (res == LZW_OK_EOD) {"
    },
    {
        "line": 232,
        "fullcodeline": "gif->width * gif->height * sizeof(int));"
    },
    {
        "line": 234,
        "fullcodeline": "return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);"
    },
    {
        "line": 240,
        "fullcodeline": "frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);"
    },
    {
        "line": 281,
        "fullcodeline": "(colour != gif->frames[frame].transparency_index)) ||"
    },
    {
        "line": 292,
        "fullcodeline": "return_value = GIF_OK;"
    },
    {
        "line": 235,
        "fullcodeline": "if (return_value != GIF_OK) {"
    },
    {
        "line": 241,
        "fullcodeline": "if (!frame_data) {"
    },
    {
        "line": 294,
        "fullcodeline": "return_value = gif_error_from_lzw(res);"
    }
]