[
    {
        "line": 5,
        "fullcodeline": "unsigned int index = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned int *frame_data = 0;\t// Set to 0 for no warnings"
    },
    {
        "line": 14,
        "fullcodeline": "unsigned int return_value = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "gif_data = gif->gif_data + gif->frames[frame].frame_pointer;"
    },
    {
        "line": 36,
        "fullcodeline": "gif_end = gif->gif_data + gif->buffer_size;"
    },
    {
        "line": 37,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 48,
        "fullcodeline": "save_buffer_position = gif->buffer_position;"
    },
    {
        "line": 49,
        "fullcodeline": "gif->buffer_position = gif_data - gif->gif_data;"
    },
    {
        "line": 55,
        "fullcodeline": "gif_data = (gif->gif_data + gif->buffer_position);"
    },
    {
        "line": 56,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 84,
        "fullcodeline": "offset_x = gif_data[1] | (gif_data[2] << 8);"
    },
    {
        "line": 85,
        "fullcodeline": "offset_y = gif_data[3] | (gif_data[4] << 8);"
    },
    {
        "line": 86,
        "fullcodeline": "width = gif_data[5] | (gif_data[6] << 8);"
    },
    {
        "line": 87,
        "fullcodeline": "height = gif_data[7] | (gif_data[8] << 8);"
    },
    {
        "line": 99,
        "fullcodeline": "flags = gif_data[9];"
    },
    {
        "line": 100,
        "fullcodeline": "colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);"
    },
    {
        "line": 106,
        "fullcodeline": "gif_data += 10;"
    },
    {
        "line": 107,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 157,
        "fullcodeline": "frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);"
    },
    {
        "line": 19,
        "fullcodeline": "if (gif->frames[frame].display == false) {"
    },
    {
        "line": 24,
        "fullcodeline": "if (frame > gif->frame_count_partial) {"
    },
    {
        "line": 52,
        "fullcodeline": "if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (gif_data[0] != GIF_IMAGE_SEPARATOR) {"
    },
    {
        "line": 101,
        "fullcodeline": "interlace = flags & GIF_INTERLACE_MASK;"
    },
    {
        "line": 110,
        "fullcodeline": "if (flags & GIF_COLOUR_TABLE_MASK) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (gif_bytes < 1) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (gif_data[0] == GIF_TRAILER) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (!frame_data) {"
    },
    {
        "line": 29,
        "fullcodeline": "if ((!clear_image) &&"
    },
    {
        "line": 30,
        "fullcodeline": "((int)frame == gif->decoded_frame)) {"
    },
    {
        "line": 62,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 81,
        "fullcodeline": "return_value = GIF_DATA_ERROR;"
    },
    {
        "line": 92,
        "fullcodeline": "if ((offset_x + width > gif->width) ||"
    },
    {
        "line": 93,
        "fullcodeline": "(offset_y + height > gif->height)) {"
    },
    {
        "line": 94,
        "fullcodeline": "return_value = GIF_DATA_ERROR;"
    },
    {
        "line": 115,
        "fullcodeline": "colour_table = gif->local_colour_table;"
    },
    {
        "line": 138,
        "fullcodeline": "gif_bytes = (gif_end - gif_data);"
    },
    {
        "line": 145,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 151,
        "fullcodeline": "return_value = GIF_OK;"
    },
    {
        "line": 241,
        "fullcodeline": "gif->buffer_position = (gif_data - gif->gif_data) + 1;"
    },
    {
        "line": 244,
        "fullcodeline": "res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,"
    },
    {
        "line": 325,
        "fullcodeline": "gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);"
    },
    {
        "line": 116,
        "fullcodeline": "if (!clear_image) {"
    },
    {
        "line": 140,
        "fullcodeline": "colour_table = gif->global_colour_table;"
    },
    {
        "line": 171,
        "fullcodeline": "if (gif_bytes < 2) {"
    },
    {
        "line": 247,
        "fullcodeline": "if (res != LZW_OK) {"
    },
    {
        "line": 252,
        "fullcodeline": "for (y = 0; y < height; y++) {"
    },
    {
        "line": 112,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 172,
        "fullcodeline": "return_value = GIF_INSUFFICIENT_FRAME_DATA;"
    },
    {
        "line": 179,
        "fullcodeline": "if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {"
    },
    {
        "line": 180,
        "fullcodeline": "return_value = GIF_OK;"
    },
    {
        "line": 188,
        "fullcodeline": "if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {"
    },
    {
        "line": 258,
        "fullcodeline": "frame_scanline = frame_data + offset_x + (decode_y * gif->width);"
    },
    {
        "line": 264,
        "fullcodeline": "x = width;"
    },
    {
        "line": 317,
        "fullcodeline": "gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);"
    },
    {
        "line": 111,
        "fullcodeline": "if (gif_bytes < (int)(3 * colour_table_size)) {"
    },
    {
        "line": 117,
        "fullcodeline": "for (index = 0; index < colour_table_size; index++) {"
    },
    {
        "line": 136,
        "fullcodeline": "gif_data += 3 * colour_table_size;"
    },
    {
        "line": 191,
        "fullcodeline": "gif->width * gif->height * sizeof(int));"
    },
    {
        "line": 248,
        "fullcodeline": "return gif_error_from_lzw(res);"
    },
    {
        "line": 265,
        "fullcodeline": "while (x > 0) {"
    },
    {
        "line": 319,
        "fullcodeline": "gif->frames[frame].opaque = false;"
    },
    {
        "line": 133,
        "fullcodeline": "gif_data += 3;"
    },
    {
        "line": 254,
        "fullcodeline": "decode_y = gif_interlaced_line(height, y) + offset_y;"
    },
    {
        "line": 266,
        "fullcodeline": "burst_bytes = (stack_pos - stack_base);"
    },
    {
        "line": 298,
        "fullcodeline": "for (y = 0; y < height; y++) {"
    },
    {
        "line": 197,
        "fullcodeline": "} else if ((frame != 0) &&"
    },
    {
        "line": 198,
        "fullcodeline": "(gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {"
    },
    {
        "line": 199,
        "fullcodeline": "return_value = gif_internal_decode_frame(gif,"
    },
    {
        "line": 256,
        "fullcodeline": "decode_y = y + offset_y;"
    },
    {
        "line": 267,
        "fullcodeline": "if (burst_bytes > 0) {"
    },
    {
        "line": 299,
        "fullcodeline": "frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);"
    },
    {
        "line": 202,
        "fullcodeline": "if (return_value != GIF_OK) {"
    },
    {
        "line": 271,
        "fullcodeline": "x -= burst_bytes;"
    },
    {
        "line": 200,
        "fullcodeline": "(frame - 1),"
    },
    {
        "line": 268,
        "fullcodeline": "if (burst_bytes > x) {"
    },
    {
        "line": 282,
        "fullcodeline": "res = lzw_decode(gif->lzw_ctx, &stack_pos);"
    },
    {
        "line": 206,
        "fullcodeline": "} else if ((frame != 0) &&"
    },
    {
        "line": 207,
        "fullcodeline": "(gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {"
    },
    {
        "line": 213,
        "fullcodeline": "int last_undisposed_frame = frame - 2;"
    },
    {
        "line": 269,
        "fullcodeline": "burst_bytes = x;"
    },
    {
        "line": 272,
        "fullcodeline": "while (burst_bytes-- > 0) {"
    },
    {
        "line": 273,
        "fullcodeline": "colour = *--stack_pos;"
    },
    {
        "line": 283,
        "fullcodeline": "if (res != LZW_OK) {"
    },
    {
        "line": 303,
        "fullcodeline": "width * 4);"
    },
    {
        "line": 220,
        "fullcodeline": "if (last_undisposed_frame == -1) {"
    },
    {
        "line": 307,
        "fullcodeline": "width * 4);"
    },
    {
        "line": 214,
        "fullcodeline": "while ((last_undisposed_frame >= 0) &&"
    },
    {
        "line": 215,
        "fullcodeline": "(gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {"
    },
    {
        "line": 216,
        "fullcodeline": "last_undisposed_frame--;"
    },
    {
        "line": 274,
        "fullcodeline": "if (((gif->frames[frame].transparency) &&"
    },
    {
        "line": 276,
        "fullcodeline": "(!gif->frames[frame].transparency)) {"
    },
    {
        "line": 277,
        "fullcodeline": "*frame_scanline = colour_table[colour];"
    },
    {
        "line": 285,
        "fullcodeline": "if (res == LZW_OK_EOD) {"
    },
    {
        "line": 226,
        "fullcodeline": "gif->width * gif->height * sizeof(int));"
    },
    {
        "line": 228,
        "fullcodeline": "return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);"
    },
    {
        "line": 234,
        "fullcodeline": "frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);"
    },
    {
        "line": 275,
        "fullcodeline": "(colour != gif->frames[frame].transparency_index)) ||"
    },
    {
        "line": 286,
        "fullcodeline": "return_value = GIF_OK;"
    },
    {
        "line": 229,
        "fullcodeline": "if (return_value != GIF_OK) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (!frame_data) {"
    },
    {
        "line": 288,
        "fullcodeline": "return_value = gif_error_from_lzw(res);"
    }
]