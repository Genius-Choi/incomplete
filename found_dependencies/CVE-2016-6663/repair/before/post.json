[
    {
        "line": 3,
        "fullcodeline": "int error=0;"
    },
    {
        "line": 4,
        "fullcodeline": "uint local_testflag=param.testflag;"
    },
    {
        "line": 5,
        "fullcodeline": "bool optimize_done= !do_optimize, statistics_done=0;"
    },
    {
        "line": 6,
        "fullcodeline": "const char *old_proc_info=thd->proc_info;"
    },
    {
        "line": 7,
        "fullcodeline": "char fixed_name[FN_REFLEN];"
    },
    {
        "line": 10,
        "fullcodeline": "DBUG_ENTER(\"ha_myisam::repair\");"
    },
    {
        "line": 14,
        "fullcodeline": "param.using_global_keycache = 1;"
    },
    {
        "line": 15,
        "fullcodeline": "param.thd= thd;"
    },
    {
        "line": 16,
        "fullcodeline": "param.tmpdir= &mysql_tmpdir_list;"
    },
    {
        "line": 17,
        "fullcodeline": "param.out_flag= 0;"
    },
    {
        "line": 18,
        "fullcodeline": "strmov(fixed_name,file->filename);"
    },
    {
        "line": 21,
        "fullcodeline": "ha_release_temporary_latches(thd);"
    },
    {
        "line": 111,
        "fullcodeline": "thd_proc_info(thd, \"Saving state\");"
    },
    {
        "line": 149,
        "fullcodeline": "thd_proc_info(thd, old_proc_info);"
    },
    {
        "line": 152,
        "fullcodeline": "DBUG_RETURN(error ? HA_ADMIN_FAILED :"
    },
    {
        "line": 24,
        "fullcodeline": "if (! thd->locked_tables_mode &&"
    },
    {
        "line": 31,
        "fullcodeline": "if (!do_optimize ||"
    },
    {
        "line": 90,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 112,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 150,
        "fullcodeline": "if (! thd->locked_tables_mode)"
    },
    {
        "line": 25,
        "fullcodeline": "mi_lock_database(file, table->s->tmp_table ? F_EXTRA_LCK : F_WRLCK))"
    },
    {
        "line": 27,
        "fullcodeline": "mi_check_print_error(&param,ER(ER_CANT_LOCK),my_errno);"
    },
    {
        "line": 32,
        "fullcodeline": "((file->state->del || share->state.split != file->state->records) &&"
    },
    {
        "line": 36,
        "fullcodeline": "ulonglong key_map= ((local_testflag & T_CREATE_MISSING_KEYS) ?"
    },
    {
        "line": 39,
        "fullcodeline": "uint testflag=param.testflag;"
    },
    {
        "line": 87,
        "fullcodeline": "param.testflag=testflag;"
    },
    {
        "line": 88,
        "fullcodeline": "optimize_done=1;"
    },
    {
        "line": 133,
        "fullcodeline": "info(HA_STATUS_NO_LOCK | HA_STATUS_TIME | HA_STATUS_VARIABLE |"
    },
    {
        "line": 151,
        "fullcodeline": "mi_lock_database(file,F_UNLCK);"
    },
    {
        "line": 153,
        "fullcodeline": "!optimize_done ? HA_ADMIN_ALREADY_DONE : HA_ADMIN_OK);"
    },
    {
        "line": 33,
        "fullcodeline": "(!(param.testflag & T_QUICK) ||"
    },
    {
        "line": 52,
        "fullcodeline": "if (mi_test_if_sort_rep(file,file->state->records,key_map,0) &&"
    },
    {
        "line": 92,
        "fullcodeline": "if ((local_testflag & T_SORT_INDEX) &&"
    },
    {
        "line": 99,
        "fullcodeline": "if (!statistics_done && (local_testflag & T_STATISTICS))"
    },
    {
        "line": 114,
        "fullcodeline": "if ((share->state.changed & STATE_CHANGED) || mi_is_crashed(file))"
    },
    {
        "line": 124,
        "fullcodeline": "if (file->state != &file->s->state.state)"
    },
    {
        "line": 135,
        "fullcodeline": "if (rows != file->state->records && ! (param.testflag & T_VERY_SILENT))"
    },
    {
        "line": 146,
        "fullcodeline": "file->update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;"
    },
    {
        "line": 147,
        "fullcodeline": "update_state_info(&param, file, 0);"
    },
    {
        "line": 34,
        "fullcodeline": "!(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))))"
    },
    {
        "line": 53,
        "fullcodeline": "(local_testflag & T_REP_BY_SORT))"
    },
    {
        "line": 55,
        "fullcodeline": "local_testflag|= T_STATISTICS;"
    },
    {
        "line": 56,
        "fullcodeline": "param.testflag|= T_STATISTICS;\t\t// We get this for free"
    },
    {
        "line": 57,
        "fullcodeline": "statistics_done=1;"
    },
    {
        "line": 93,
        "fullcodeline": "(share->state.changed & STATE_NOT_SORTED_PAGES))"
    },
    {
        "line": 95,
        "fullcodeline": "optimize_done=1;"
    },
    {
        "line": 96,
        "fullcodeline": "thd_proc_info(thd, \"Sorting index\");"
    },
    {
        "line": 97,
        "fullcodeline": "error=mi_sort_index(&param,file,fixed_name);"
    },
    {
        "line": 116,
        "fullcodeline": "share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |"
    },
    {
        "line": 118,
        "fullcodeline": "file->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;"
    },
    {
        "line": 127,
        "fullcodeline": "update_auto_increment_key(&param, file, 1);"
    },
    {
        "line": 129,
        "fullcodeline": "error = update_state_info(&param, file,"
    },
    {
        "line": 137,
        "fullcodeline": "char llbuff[22],llbuff2[22];"
    },
    {
        "line": 138,
        "fullcodeline": "mi_check_print_warning(&param,\"Number of rows changed from %s to %s\","
    },
    {
        "line": 58,
        "fullcodeline": "if (THDVAR(thd, repair_threads)>1)"
    },
    {
        "line": 78,
        "fullcodeline": "thd_proc_info(thd, \"Repair with keycache\");"
    },
    {
        "line": 79,
        "fullcodeline": "param.testflag &= ~T_REP_BY_SORT;"
    },
    {
        "line": 80,
        "fullcodeline": "error=  mi_repair(&param, file, fixed_name,"
    },
    {
        "line": 101,
        "fullcodeline": "if (share->state.changed & STATE_NOT_ANALYZED)"
    },
    {
        "line": 139,
        "fullcodeline": "llstr(rows,llbuff),"
    },
    {
        "line": 140,
        "fullcodeline": "llstr(file->state->records,llbuff2));"
    },
    {
        "line": 60,
        "fullcodeline": "char buf[40];"
    },
    {
        "line": 62,
        "fullcodeline": "my_snprintf(buf, 40, \"Repair with %d threads\", my_count_bits(key_map));"
    },
    {
        "line": 63,
        "fullcodeline": "thd_proc_info(thd, buf);"
    },
    {
        "line": 64,
        "fullcodeline": "error = mi_repair_parallel(&param, file, fixed_name,"
    },
    {
        "line": 66,
        "fullcodeline": "thd_proc_info(thd, \"Repair done\"); // to reset proc_info, as"
    },
    {
        "line": 103,
        "fullcodeline": "optimize_done=1;"
    },
    {
        "line": 104,
        "fullcodeline": "thd_proc_info(thd, \"Analyzing\");"
    },
    {
        "line": 105,
        "fullcodeline": "error = chk_key(&param, file);"
    },
    {
        "line": 130,
        "fullcodeline": "UPDATE_TIME | UPDATE_OPEN_COUNT |"
    },
    {
        "line": 71,
        "fullcodeline": "thd_proc_info(thd, \"Repair by sorting\");"
    },
    {
        "line": 72,
        "fullcodeline": "error = mi_repair_by_sort(&param, file, fixed_name,"
    },
    {
        "line": 81,
        "fullcodeline": "param.testflag & T_QUICK);"
    },
    {
        "line": 108,
        "fullcodeline": "local_testflag&= ~T_STATISTICS;\t\t// Don't update statistics"
    },
    {
        "line": 131,
        "fullcodeline": "(local_testflag &"
    },
    {
        "line": 65,
        "fullcodeline": "param.testflag & T_QUICK);"
    },
    {
        "line": 73,
        "fullcodeline": "param.testflag & T_QUICK);"
    }
]