[
    {
        "line": 3,
        "fullcodeline": "int error=0;"
    },
    {
        "line": 4,
        "fullcodeline": "uint local_testflag=param.testflag;"
    },
    {
        "line": 5,
        "fullcodeline": "bool optimize_done= !do_optimize, statistics_done=0;"
    },
    {
        "line": 6,
        "fullcodeline": "const char *old_proc_info=thd->proc_info;"
    },
    {
        "line": 7,
        "fullcodeline": "char fixed_name[FN_REFLEN];"
    },
    {
        "line": 8,
        "fullcodeline": "MYISAM_SHARE* share = file->s;"
    },
    {
        "line": 9,
        "fullcodeline": "ha_rows rows= file->state->records;"
    },
    {
        "line": 10,
        "fullcodeline": "DBUG_ENTER(\"ha_myisam::repair\");"
    },
    {
        "line": 12,
        "fullcodeline": "param.db_name=    table->s->db.str;"
    },
    {
        "line": 13,
        "fullcodeline": "param.table_name= table->alias;"
    },
    {
        "line": 14,
        "fullcodeline": "param.using_global_keycache = 1;"
    },
    {
        "line": 15,
        "fullcodeline": "param.thd= thd;"
    },
    {
        "line": 16,
        "fullcodeline": "param.tmpdir= &mysql_tmpdir_list;"
    },
    {
        "line": 17,
        "fullcodeline": "param.out_flag= 0;"
    },
    {
        "line": 18,
        "fullcodeline": "strmov(fixed_name,file->filename);"
    },
    {
        "line": 21,
        "fullcodeline": "ha_release_temporary_latches(thd);"
    },
    {
        "line": 127,
        "fullcodeline": "thd_proc_info(thd, \"Saving state\");"
    },
    {
        "line": 165,
        "fullcodeline": "thd_proc_info(thd, old_proc_info);"
    },
    {
        "line": 168,
        "fullcodeline": "DBUG_RETURN(error ? HA_ADMIN_FAILED :"
    },
    {
        "line": 24,
        "fullcodeline": "if (! thd->locked_tables_mode &&"
    },
    {
        "line": 31,
        "fullcodeline": "if (!do_optimize ||"
    },
    {
        "line": 102,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 128,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 166,
        "fullcodeline": "if (! thd->locked_tables_mode)"
    },
    {
        "line": 25,
        "fullcodeline": "mi_lock_database(file, table->s->tmp_table ? F_EXTRA_LCK : F_WRLCK))"
    },
    {
        "line": 27,
        "fullcodeline": "mi_check_print_error(&param,ER(ER_CANT_LOCK),my_errno);"
    },
    {
        "line": 32,
        "fullcodeline": "((file->state->del || share->state.split != file->state->records) &&"
    },
    {
        "line": 36,
        "fullcodeline": "ulonglong key_map= ((local_testflag & T_CREATE_MISSING_KEYS) ?"
    },
    {
        "line": 39,
        "fullcodeline": "uint testflag=param.testflag;"
    },
    {
        "line": 99,
        "fullcodeline": "param.testflag=testflag;"
    },
    {
        "line": 100,
        "fullcodeline": "optimize_done=1;"
    },
    {
        "line": 149,
        "fullcodeline": "info(HA_STATUS_NO_LOCK | HA_STATUS_TIME | HA_STATUS_VARIABLE |"
    },
    {
        "line": 167,
        "fullcodeline": "mi_lock_database(file,F_UNLCK);"
    },
    {
        "line": 169,
        "fullcodeline": "!optimize_done ? HA_ADMIN_ALREADY_DONE : HA_ADMIN_OK);"
    },
    {
        "line": 33,
        "fullcodeline": "(!(param.testflag & T_QUICK) ||"
    },
    {
        "line": 52,
        "fullcodeline": "if (mi_test_if_sort_rep(file,file->state->records,key_map,0) &&"
    },
    {
        "line": 104,
        "fullcodeline": "if ((local_testflag & T_SORT_INDEX) &&"
    },
    {
        "line": 115,
        "fullcodeline": "if (!statistics_done && (local_testflag & T_STATISTICS))"
    },
    {
        "line": 130,
        "fullcodeline": "if ((share->state.changed & STATE_CHANGED) || mi_is_crashed(file))"
    },
    {
        "line": 140,
        "fullcodeline": "if (file->state != &file->s->state.state)"
    },
    {
        "line": 151,
        "fullcodeline": "if (rows != file->state->records && ! (param.testflag & T_VERY_SILENT))"
    },
    {
        "line": 162,
        "fullcodeline": "file->update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;"
    },
    {
        "line": 163,
        "fullcodeline": "update_state_info(&param, file, 0);"
    },
    {
        "line": 34,
        "fullcodeline": "!(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))))"
    },
    {
        "line": 37,
        "fullcodeline": "mi_get_mask_all_keys_active(share->base.keys) :"
    },
    {
        "line": 53,
        "fullcodeline": "(local_testflag & T_REP_BY_SORT))"
    },
    {
        "line": 55,
        "fullcodeline": "local_testflag|= T_STATISTICS;"
    },
    {
        "line": 56,
        "fullcodeline": "param.testflag|= T_STATISTICS;\t\t// We get this for free"
    },
    {
        "line": 57,
        "fullcodeline": "statistics_done=1;"
    },
    {
        "line": 105,
        "fullcodeline": "(share->state.changed & STATE_NOT_SORTED_PAGES))"
    },
    {
        "line": 107,
        "fullcodeline": "optimize_done=1;"
    },
    {
        "line": 108,
        "fullcodeline": "thd_proc_info(thd, \"Sorting index\");"
    },
    {
        "line": 113,
        "fullcodeline": "error=mi_sort_index(&param,file,fixed_name, TRUE);"
    },
    {
        "line": 132,
        "fullcodeline": "share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |"
    },
    {
        "line": 134,
        "fullcodeline": "file->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;"
    },
    {
        "line": 141,
        "fullcodeline": "file->s->state.state = *file->state;"
    },
    {
        "line": 143,
        "fullcodeline": "update_auto_increment_key(&param, file, 1);"
    },
    {
        "line": 145,
        "fullcodeline": "error = update_state_info(&param, file,"
    },
    {
        "line": 153,
        "fullcodeline": "char llbuff[22],llbuff2[22];"
    },
    {
        "line": 154,
        "fullcodeline": "mi_check_print_warning(&param,\"Number of rows changed from %s to %s\","
    },
    {
        "line": 58,
        "fullcodeline": "if (THDVAR(thd, repair_threads)>1)"
    },
    {
        "line": 86,
        "fullcodeline": "thd_proc_info(thd, \"Repair with keycache\");"
    },
    {
        "line": 87,
        "fullcodeline": "param.testflag &= ~T_REP_BY_SORT;"
    },
    {
        "line": 92,
        "fullcodeline": "error=  mi_repair(&param, file, fixed_name,"
    },
    {
        "line": 117,
        "fullcodeline": "if (share->state.changed & STATE_NOT_ANALYZED)"
    },
    {
        "line": 155,
        "fullcodeline": "llstr(rows,llbuff),"
    },
    {
        "line": 156,
        "fullcodeline": "llstr(file->state->records,llbuff2));"
    },
    {
        "line": 60,
        "fullcodeline": "char buf[40];"
    },
    {
        "line": 62,
        "fullcodeline": "my_snprintf(buf, 40, \"Repair with %d threads\", my_count_bits(key_map));"
    },
    {
        "line": 63,
        "fullcodeline": "thd_proc_info(thd, buf);"
    },
    {
        "line": 68,
        "fullcodeline": "error = mi_repair_parallel(&param, file, fixed_name,"
    },
    {
        "line": 70,
        "fullcodeline": "thd_proc_info(thd, \"Repair done\"); // to reset proc_info, as"
    },
    {
        "line": 119,
        "fullcodeline": "optimize_done=1;"
    },
    {
        "line": 120,
        "fullcodeline": "thd_proc_info(thd, \"Analyzing\");"
    },
    {
        "line": 121,
        "fullcodeline": "error = chk_key(&param, file);"
    },
    {
        "line": 146,
        "fullcodeline": "UPDATE_TIME | UPDATE_OPEN_COUNT |"
    },
    {
        "line": 75,
        "fullcodeline": "thd_proc_info(thd, \"Repair by sorting\");"
    },
    {
        "line": 80,
        "fullcodeline": "error = mi_repair_by_sort(&param, file, fixed_name,"
    },
    {
        "line": 93,
        "fullcodeline": "param.testflag & T_QUICK, TRUE);"
    },
    {
        "line": 124,
        "fullcodeline": "local_testflag&= ~T_STATISTICS;\t\t// Don't update statistics"
    },
    {
        "line": 147,
        "fullcodeline": "(local_testflag &"
    },
    {
        "line": 69,
        "fullcodeline": "param.testflag & T_QUICK, TRUE);"
    },
    {
        "line": 81,
        "fullcodeline": "param.testflag & T_QUICK, TRUE);"
    }
]