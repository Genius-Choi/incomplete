[
    {
        "line": 7,
        "fullcodeline": "my_off_t index_pos[HA_MAX_POSSIBLE_KEY];"
    },
    {
        "line": 10,
        "fullcodeline": "MYISAM_SHARE *share=info->s;"
    },
    {
        "line": 12,
        "fullcodeline": "DBUG_ENTER(\"mi_sort_index\");"
    },
    {
        "line": 24,
        "fullcodeline": "fn_format(param->temp_filename,name,\"\", MI_NAME_IEXT,2+4+32);"
    },
    {
        "line": 58,
        "fullcodeline": "flush_key_blocks(share->key_cache,share->kfile, FLUSH_IGNORE_CHANGED);"
    },
    {
        "line": 60,
        "fullcodeline": "share->state.version=(ulong) time((time_t*) 0);"
    },
    {
        "line": 61,
        "fullcodeline": "old_state= share->state;\t\t\t/* save state if not stored */"
    },
    {
        "line": 62,
        "fullcodeline": "r_locks=   share->r_locks;"
    },
    {
        "line": 63,
        "fullcodeline": "w_locks=   share->w_locks;"
    },
    {
        "line": 64,
        "fullcodeline": "old_lock=  info->lock_type;"
    },
    {
        "line": 67,
        "fullcodeline": "share->r_locks= share->w_locks= share->tot_locks= 0;"
    },
    {
        "line": 68,
        "fullcodeline": "(void) _mi_writeinfo(info,WRITEINFO_UPDATE_KEYFILE);"
    },
    {
        "line": 69,
        "fullcodeline": "(void) mysql_file_close(share->kfile, MYF(MY_WME));"
    },
    {
        "line": 70,
        "fullcodeline": "share->kfile = -1;"
    },
    {
        "line": 71,
        "fullcodeline": "(void) mysql_file_close(new_file, MYF(MY_WME));"
    },
    {
        "line": 76,
        "fullcodeline": "info->lock_type= F_UNLCK;\t\t\t/* Force mi_readinfo to lock */"
    },
    {
        "line": 77,
        "fullcodeline": "_mi_readinfo(info,F_WRLCK,0);\t\t\t/* Will lock the table */"
    },
    {
        "line": 78,
        "fullcodeline": "info->lock_type=  old_lock;"
    },
    {
        "line": 79,
        "fullcodeline": "share->r_locks=   r_locks;"
    },
    {
        "line": 80,
        "fullcodeline": "share->w_locks=   w_locks;"
    },
    {
        "line": 81,
        "fullcodeline": "share->tot_locks= r_locks+w_locks;"
    },
    {
        "line": 82,
        "fullcodeline": "share->state=     old_state;\t\t\t/* Restore old state */"
    },
    {
        "line": 84,
        "fullcodeline": "info->state->key_file_length=param->new_file_pos;"
    },
    {
        "line": 85,
        "fullcodeline": "info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);"
    },
    {
        "line": 91,
        "fullcodeline": "info->s->state.changed&= ~STATE_NOT_SORTED_PAGES;"
    },
    {
        "line": 92,
        "fullcodeline": "DBUG_RETURN(0);"
    },
    {
        "line": 95,
        "fullcodeline": "(void) mysql_file_close(new_file, MYF(MY_WME));"
    },
    {
        "line": 97,
        "fullcodeline": "(void) mysql_file_delete(mi_key_file_datatmp,"
    },
    {
        "line": 99,
        "fullcodeline": "DBUG_RETURN(-1);"
    },
    {
        "line": 15,
        "fullcodeline": "for (key= 0,keyinfo= &share->keyinfo[0]; key < share->base.keys ;"
    },
    {
        "line": 16,
        "fullcodeline": "key++,keyinfo++)"
    },
    {
        "line": 20,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 25,
        "fullcodeline": "if ((new_file= mysql_file_create(mi_key_file_datatmp,"
    },
    {
        "line": 35,
        "fullcodeline": "if (filecopy(param, new_file,share->kfile,0L,"
    },
    {
        "line": 40,
        "fullcodeline": "for (key= 0,keyinfo= &share->keyinfo[0]; key < share->base.keys ;"
    },
    {
        "line": 41,
        "fullcodeline": "key++,keyinfo++)"
    },
    {
        "line": 72,
        "fullcodeline": "if (change_to_newfile(share->index_file_name, MI_NAME_IEXT, INDEX_TMP_EXT,"
    },
    {
        "line": 86,
        "fullcodeline": "for (key=0 ; key < info->s->base.keys ; key++)"
    },
    {
        "line": 87,
        "fullcodeline": "info->s->state.key_root[key]=index_pos[key];"
    },
    {
        "line": 88,
        "fullcodeline": "for (key=0 ; key < info->s->state.header.max_block_size_index ; key++)"
    },
    {
        "line": 89,
        "fullcodeline": "info->s->state.key_del[key]=  HA_OFFSET_ERROR;"
    },
    {
        "line": 17,
        "fullcodeline": "if (keyinfo->key_alg == HA_KEY_ALG_RTREE)"
    },
    {
        "line": 21,
        "fullcodeline": "printf(\"- Sorting index for MyISAM-table '%s'\\n\",name);"
    },
    {
        "line": 31,
        "fullcodeline": "mi_check_print_error(param,\"Can't create new tempfile: '%s'\","
    },
    {
        "line": 33,
        "fullcodeline": "DBUG_RETURN(-1);"
    },
    {
        "line": 74,
        "fullcodeline": "mi_open_keyfile(share))"
    },
    {
        "line": 98,
        "fullcodeline": "param->temp_filename, MYF(MY_WME));"
    },
    {
        "line": 18,
        "fullcodeline": "DBUG_RETURN(0);"
    },
    {
        "line": 43,
        "fullcodeline": "if (! mi_is_key_active(info->s->state.key_map, key))"
    },
    {
        "line": 46,
        "fullcodeline": "if (share->state.key_root[key] != HA_OFFSET_ERROR)"
    },
    {
        "line": 73,
        "fullcodeline": "no_copy_stat ? MYF(MY_REDEL_NO_COPY_STAT) : MYF(0)) ||"
    },
    {
        "line": 26,
        "fullcodeline": "fn_format(param->temp_filename,"
    },
    {
        "line": 29,
        "fullcodeline": "0, param->tmpfile_createflag, MYF(0))) <= 0)"
    },
    {
        "line": 48,
        "fullcodeline": "index_pos[key]=param->new_file_pos;\t/* Write first block here */"
    },
    {
        "line": 28,
        "fullcodeline": "\"\", INDEX_TMP_EXT, 2+4),"
    },
    {
        "line": 49,
        "fullcodeline": "if (sort_one_index(param,info,keyinfo,share->state.key_root[key],"
    },
    {
        "line": 54,
        "fullcodeline": "index_pos[key]= HA_OFFSET_ERROR;\t\t/* No blocks */"
    }
]