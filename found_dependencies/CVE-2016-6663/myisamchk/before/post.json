[
    {
        "line": 4,
        "fullcodeline": "int rep_quick= param->testflag & (T_QUICK | T_FORCE_UNIQUENESS);"
    },
    {
        "line": 7,
        "fullcodeline": "char llbuff[22],llbuff2[22];"
    },
    {
        "line": 8,
        "fullcodeline": "my_bool state_updated=0;"
    },
    {
        "line": 10,
        "fullcodeline": "DBUG_ENTER(\"myisamchk\");"
    },
    {
        "line": 12,
        "fullcodeline": "param->out_flag=error=param->warning_printed=param->error_printed="
    },
    {
        "line": 14,
        "fullcodeline": "datafile=0;"
    },
    {
        "line": 15,
        "fullcodeline": "param->isam_file_name=filename;\t\t/* For error messages */"
    },
    {
        "line": 62,
        "fullcodeline": "share=info->s;"
    },
    {
        "line": 63,
        "fullcodeline": "share->options&= ~HA_OPTION_READ_ONLY_DATA; /* We are modifing it */"
    },
    {
        "line": 64,
        "fullcodeline": "share->tot_locks-= share->r_locks;"
    },
    {
        "line": 65,
        "fullcodeline": "share->r_locks=0;"
    },
    {
        "line": 354,
        "fullcodeline": "mi_lock_database(info, F_UNLCK);"
    },
    {
        "line": 370,
        "fullcodeline": "(void) fflush(stdout); (void) fflush(stderr);"
    },
    {
        "line": 393,
        "fullcodeline": "(void) fflush(stderr);"
    },
    {
        "line": 394,
        "fullcodeline": "DBUG_RETURN(error);"
    },
    {
        "line": 16,
        "fullcodeline": "if (!(info=mi_open(filename,"
    },
    {
        "line": 72,
        "fullcodeline": "if (param->testflag & (T_FAST | T_CHECK_ONLY_CHANGED))"
    },
    {
        "line": 111,
        "fullcodeline": "if ((param->testflag & (T_REP_ANY | T_STATISTICS |"
    },
    {
        "line": 149,
        "fullcodeline": "if (param->testflag & T_DESCRIPT)"
    },
    {
        "line": 336,
        "fullcodeline": "if ((param->testflag & T_AUTO_INC) ||"
    },
    {
        "line": 341,
        "fullcodeline": "if (!(param->testflag & T_DESCRIPT))"
    },
    {
        "line": 356,
        "fullcodeline": "if (mi_close(info))"
    },
    {
        "line": 361,
        "fullcodeline": "if (error == 0)"
    },
    {
        "line": 26,
        "fullcodeline": "param->error_printed=1;"
    },
    {
        "line": 60,
        "fullcodeline": "DBUG_RETURN(1);"
    },
    {
        "line": 74,
        "fullcodeline": "my_bool need_to_check= mi_is_crashed(info) || share->state.open_count != 0;"
    },
    {
        "line": 113,
        "fullcodeline": "(((param->testflag & T_UNPACK) &&"
    },
    {
        "line": 136,
        "fullcodeline": "recreate=1;"
    },
    {
        "line": 144,
        "fullcodeline": "share=info->s;"
    },
    {
        "line": 145,
        "fullcodeline": "share->tot_locks-= share->r_locks;"
    },
    {
        "line": 146,
        "fullcodeline": "share->r_locks=0;"
    },
    {
        "line": 151,
        "fullcodeline": "param->total_files++;"
    },
    {
        "line": 152,
        "fullcodeline": "param->total_records+=info->state->records;"
    },
    {
        "line": 153,
        "fullcodeline": "param->total_deleted+=info->state->del;"
    },
    {
        "line": 154,
        "fullcodeline": "descript(param, info, filename);"
    },
    {
        "line": 337,
        "fullcodeline": "((param->testflag & T_REP_ANY) && info->s->base.auto_key))"
    },
    {
        "line": 338,
        "fullcodeline": "update_auto_increment_key(param, info,"
    },
    {
        "line": 351,
        "fullcodeline": "(void) lock_file(param, share->kfile,0L,F_UNLCK,\"indexfile\",filename);"
    },
    {
        "line": 352,
        "fullcodeline": "info->update&= ~HA_STATE_CHANGED;"
    },
    {
        "line": 358,
        "fullcodeline": "mi_check_print_error(param,\"%d when closing MyISAM-table '%s'\",my_errno,filename);"
    },
    {
        "line": 359,
        "fullcodeline": "DBUG_RETURN(1);"
    },
    {
        "line": 76,
        "fullcodeline": "if ((param->testflag & (T_REP_ANY | T_SORT_RECORDS)) &&"
    },
    {
        "line": 94,
        "fullcodeline": "if ((param->testflag & T_CHECK_ONLY_CHANGED) &&"
    },
    {
        "line": 98,
        "fullcodeline": "if (!need_to_check)"
    },
    {
        "line": 125,
        "fullcodeline": "myisam_block_size != MI_KEY_BLOCK_LENGTH))"
    },
    {
        "line": 129,
        "fullcodeline": "if (recreate_table(param, &info,filename))"
    },
    {
        "line": 137,
        "fullcodeline": "if (!(param->testflag & T_REP_ANY))"
    },
    {
        "line": 179,
        "fullcodeline": "mi_lock_database(info, F_EXTRA_LCK);"
    },
    {
        "line": 180,
        "fullcodeline": "datafile=info->dfile;"
    },
    {
        "line": 339,
        "fullcodeline": "(my_bool) !test(param->testflag & T_AUTO_INC));"
    },
    {
        "line": 343,
        "fullcodeline": "if (info->update & HA_STATE_CHANGED && ! (param->testflag & T_READONLY))"
    },
    {
        "line": 363,
        "fullcodeline": "if (param->out_flag & O_NEW_DATA)"
    },
    {
        "line": 367,
        "fullcodeline": "if (param->out_flag & O_NEW_INDEX)"
    },
    {
        "line": 373,
        "fullcodeline": "if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))"
    },
    {
        "line": 13,
        "fullcodeline": "recreate=0;"
    },
    {
        "line": 17,
        "fullcodeline": "(param->testflag & (T_DESCRIPT | T_READONLY)) ?"
    },
    {
        "line": 19,
        "fullcodeline": "HA_OPEN_FOR_REPAIR |"
    },
    {
        "line": 29,
        "fullcodeline": "mi_check_print_error(param,\"'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair\",filename);"
    },
    {
        "line": 32,
        "fullcodeline": "mi_check_print_error(param,\"'%s' is not a MyISAM-table\",filename);"
    },
    {
        "line": 35,
        "fullcodeline": "mi_check_print_error(param,\"'%s' is marked as crashed\",filename);"
    },
    {
        "line": 38,
        "fullcodeline": "mi_check_print_error(param,\"'%s' is marked as crashed after last repair\",filename);"
    },
    {
        "line": 41,
        "fullcodeline": "mi_check_print_error(param,\"'%s' is an old type of MyISAM-table\", filename);"
    },
    {
        "line": 44,
        "fullcodeline": "mi_check_print_error(param,\"Couldn't read complete header from '%s'\", filename);"
    },
    {
        "line": 47,
        "fullcodeline": "mi_check_print_error(param,\"'%s' is locked. Use -w to wait until unlocked\",filename);"
    },
    {
        "line": 50,
        "fullcodeline": "mi_check_print_error(param,\"File '%s' doesn't exist\",filename);"
    },
    {
        "line": 53,
        "fullcodeline": "mi_check_print_error(param,\"You don't have permission to use '%s'\",filename);"
    },
    {
        "line": 56,
        "fullcodeline": "mi_check_print_error(param,\"%d when opening MyISAM-table '%s'\","
    },
    {
        "line": 77,
        "fullcodeline": "((share->state.changed & (STATE_CHANGED | STATE_CRASHED |"
    },
    {
        "line": 80,
        "fullcodeline": "need_to_check=1;"
    },
    {
        "line": 95,
        "fullcodeline": "(share->state.changed & (STATE_CHANGED | STATE_CRASHED |"
    },
    {
        "line": 97,
        "fullcodeline": "need_to_check=1;"
    },
    {
        "line": 108,
        "fullcodeline": "DBUG_RETURN(0);"
    },
    {
        "line": 123,
        "fullcodeline": "(set_collation &&"
    },
    {
        "line": 128,
        "fullcodeline": "param->language= set_collation->number;"
    },
    {
        "line": 131,
        "fullcodeline": "(void) fprintf(stderr,"
    },
    {
        "line": 139,
        "fullcodeline": "param->testflag|=T_REP_BY_SORT;\t\t/* if only STATISTICS */"
    },
    {
        "line": 142,
        "fullcodeline": "rep_quick|=T_QUICK;"
    },
    {
        "line": 158,
        "fullcodeline": "if (!stopwords_inited++)"
    },
    {
        "line": 161,
        "fullcodeline": "if (!(param->testflag & T_READONLY))"
    },
    {
        "line": 165,
        "fullcodeline": "if (info->lock_type == F_RDLCK)"
    },
    {
        "line": 167,
        "fullcodeline": "if (_mi_readinfo(info,lock_type,0))"
    },
    {
        "line": 182,
        "fullcodeline": "if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))"
    },
    {
        "line": 344,
        "fullcodeline": "error|=update_state_info(param, info,"
    },
    {
        "line": 364,
        "fullcodeline": "error|=change_to_newfile(filename,MI_NAME_DEXT,DATA_TMP_EXT,"
    },
    {
        "line": 368,
        "fullcodeline": "error|=change_to_newfile(filename, MI_NAME_IEXT, INDEX_TMP_EXT, MYF(0));"
    },
    {
        "line": 375,
        "fullcodeline": "(void) fprintf(stderr,"
    },
    {
        "line": 388,
        "fullcodeline": "else if (param->warning_printed &&"
    },
    {
        "line": 20,
        "fullcodeline": "((param->testflag & T_WAIT_FOREVER) ?"
    },
    {
        "line": 79,
        "fullcodeline": "!(param->testflag & T_CHECK_ONLY_CHANGED))))"
    },
    {
        "line": 84,
        "fullcodeline": "if ((param->testflag & T_STATISTICS) &&"
    },
    {
        "line": 87,
        "fullcodeline": "if ((param->testflag & T_SORT_INDEX) &&"
    },
    {
        "line": 90,
        "fullcodeline": "if ((param->testflag & T_REP_BY_SORT) &&"
    },
    {
        "line": 100,
        "fullcodeline": "if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)"
    },
    {
        "line": 102,
        "fullcodeline": "if (mi_close(info))"
    },
    {
        "line": 134,
        "fullcodeline": "return(-1);"
    },
    {
        "line": 140,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 159,
        "fullcodeline": "ft_init_stopwords();"
    },
    {
        "line": 162,
        "fullcodeline": "lock_type = F_WRLCK;\t\t\t/* table is changed */"
    },
    {
        "line": 166,
        "fullcodeline": "info->lock_type=F_UNLCK;\t\t\t/* Read only table */"
    },
    {
        "line": 169,
        "fullcodeline": "mi_check_print_error(param,\"Can't lock indexfile of '%s', error: %d\","
    },
    {
        "line": 171,
        "fullcodeline": "param->error_printed=0;"
    },
    {
        "line": 378,
        "fullcodeline": "if (param->testflag & T_REP_ANY)"
    },
    {
        "line": 389,
        "fullcodeline": "! (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX |"
    },
    {
        "line": 391,
        "fullcodeline": "(void) fprintf(stderr, \"MyISAM-table '%s' is usable but should be fixed\\n\","
    },
    {
        "line": 22,
        "fullcodeline": "(param->testflag & T_DESCRIPT) ?"
    },
    {
        "line": 85,
        "fullcodeline": "(share->state.changed & STATE_NOT_ANALYZED))"
    },
    {
        "line": 86,
        "fullcodeline": "need_to_check=1;"
    },
    {
        "line": 88,
        "fullcodeline": "(share->state.changed & STATE_NOT_SORTED_PAGES))"
    },
    {
        "line": 89,
        "fullcodeline": "need_to_check=1;"
    },
    {
        "line": 91,
        "fullcodeline": "(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))"
    },
    {
        "line": 92,
        "fullcodeline": "need_to_check=1;"
    },
    {
        "line": 101,
        "fullcodeline": "printf(\"MyISAM file: %s is already checked\\n\",filename);"
    },
    {
        "line": 104,
        "fullcodeline": "mi_check_print_error(param,\"%d when closing MyISAM-table '%s'\","
    },
    {
        "line": 106,
        "fullcodeline": "DBUG_RETURN(1);"
    },
    {
        "line": 121,
        "fullcodeline": "test_if_almost_full(info) ||"
    },
    {
        "line": 141,
        "fullcodeline": "printf(\"- '%s' has old table-format. Recreating index\\n\",filename);"
    },
    {
        "line": 164,
        "fullcodeline": "lock_type= F_RDLCK;"
    },
    {
        "line": 184,
        "fullcodeline": "if (param->testflag & T_REP_ANY)"
    },
    {
        "line": 192,
        "fullcodeline": "if (rep_quick && chk_del(param, info, param->testflag & ~T_VERBOSE))"
    },
    {
        "line": 206,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 224,
        "fullcodeline": "if (!error && param->testflag & T_SORT_RECORDS)"
    },
    {
        "line": 266,
        "fullcodeline": "if (!error && param->testflag & T_SORT_INDEX)"
    },
    {
        "line": 268,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 345,
        "fullcodeline": "UPDATE_OPEN_COUNT |"
    },
    {
        "line": 365,
        "fullcodeline": "((param->testflag & T_BACKUP_DATA) ?"
    },
    {
        "line": 379,
        "fullcodeline": "(void) fprintf(stderr,"
    },
    {
        "line": 382,
        "fullcodeline": "else if (!(param->error_printed & 2) &&"
    },
    {
        "line": 119,
        "fullcodeline": "mi_is_any_intersect_keys_active(param->keys_in_use, share->base.keys,"
    },
    {
        "line": 186,
        "fullcodeline": "ulonglong tmp=share->state.key_map;"
    },
    {
        "line": 187,
        "fullcodeline": "mi_copy_keys_active(share->state.key_map, share->base.keys,"
    },
    {
        "line": 267,
        "fullcodeline": "error=mi_sort_index(param,info,filename);"
    },
    {
        "line": 269,
        "fullcodeline": "share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |"
    },
    {
        "line": 274,
        "fullcodeline": "else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))"
    },
    {
        "line": 346,
        "fullcodeline": "(((param->testflag & T_REP_ANY) ?"
    },
    {
        "line": 366,
        "fullcodeline": "MYF(MY_REDEL_MAKE_BACKUP) : MYF(0)));"
    },
    {
        "line": 383,
        "fullcodeline": "!(param->testflag & T_FORCE_CREATE))"
    },
    {
        "line": 384,
        "fullcodeline": "(void) fprintf(stderr,"
    },
    {
        "line": 117,
        "fullcodeline": "mi_uint2korr(share->state.header.base_info_length) !="
    },
    {
        "line": 189,
        "fullcodeline": "if (tmp != share->state.key_map)"
    },
    {
        "line": 194,
        "fullcodeline": "if (param->testflag & T_FORCE_CREATE)"
    },
    {
        "line": 208,
        "fullcodeline": "if ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&"
    },
    {
        "line": 231,
        "fullcodeline": "if (param->out_flag & O_NEW_DATA)"
    },
    {
        "line": 241,
        "fullcodeline": "if (! error)"
    },
    {
        "line": 272,
        "fullcodeline": "mi_mark_crashed(info);"
    },
    {
        "line": 282,
        "fullcodeline": "error =chk_status(param,info);"
    },
    {
        "line": 283,
        "fullcodeline": "mi_intersect_keys_active(share->state.key_map, param->keys_in_use);"
    },
    {
        "line": 284,
        "fullcodeline": "error =chk_size(param,info);"
    },
    {
        "line": 349,
        "fullcodeline": "((param->testflag & T_SORT_RECORDS) ?"
    },
    {
        "line": 115,
        "fullcodeline": "mi_uint2korr(share->state.header.state_info_length) !="
    },
    {
        "line": 190,
        "fullcodeline": "info->update|=HA_STATE_CHANGED;"
    },
    {
        "line": 196,
        "fullcodeline": "rep_quick=0;"
    },
    {
        "line": 197,
        "fullcodeline": "mi_check_print_info(param,\"Creating new data file\\n\");"
    },
    {
        "line": 211,
        "fullcodeline": "mi_test_if_sort_rep(info, info->state->records,"
    },
    {
        "line": 219,
        "fullcodeline": "state_updated=1;"
    },
    {
        "line": 233,
        "fullcodeline": "(void) my_close(info->dfile,MYF(MY_WME)); /* Close new file */"
    },
    {
        "line": 234,
        "fullcodeline": "error|=change_to_newfile(filename, MI_NAME_DEXT, DATA_TMP_EXT, MYF(0));"
    },
    {
        "line": 237,
        "fullcodeline": "param->out_flag&= ~O_NEW_DATA; /* We are using new datafile */"
    },
    {
        "line": 238,
        "fullcodeline": "param->read_cache.file=info->dfile;"
    },
    {
        "line": 248,
        "fullcodeline": "my_bool update_index=1;"
    },
    {
        "line": 253,
        "fullcodeline": "error=mi_sort_records(param,info,filename,param->opt_sort_key,"
    },
    {
        "line": 257,
        "fullcodeline": "datafile=info->dfile;\t/* This is now locked */"
    },
    {
        "line": 276,
        "fullcodeline": "if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)"
    },
    {
        "line": 278,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 285,
        "fullcodeline": "if (!error || !(param->testflag & (T_FAST | T_FORCE_CREATE)))"
    },
    {
        "line": 287,
        "fullcodeline": "if ((!error || (!(param->testflag & (T_FAST | T_FORCE_CREATE)) &&"
    },
    {
        "line": 298,
        "fullcodeline": "if ((!rep_quick && !error) ||"
    },
    {
        "line": 320,
        "fullcodeline": "if (!error)"
    },
    {
        "line": 348,
        "fullcodeline": "(state_updated ? UPDATE_STAT : 0) |"
    },
    {
        "line": 114,
        "fullcodeline": "share->data_file_type == COMPRESSED_RECORD) ||"
    },
    {
        "line": 201,
        "fullcodeline": "error=1;"
    },
    {
        "line": 202,
        "fullcodeline": "mi_check_print_error(param,"
    },
    {
        "line": 209,
        "fullcodeline": "(mi_is_any_key_active(share->state.key_map) ||"
    },
    {
        "line": 215,
        "fullcodeline": "if (param->testflag & T_REP_BY_SORT)"
    },
    {
        "line": 235,
        "fullcodeline": "if (mi_open_datafile(info,info->s, NULL, -1))"
    },
    {
        "line": 249,
        "fullcodeline": "for (key=0 ; key < share->base.keys; key++)"
    },
    {
        "line": 258,
        "fullcodeline": "if (!error && !update_index)"
    },
    {
        "line": 277,
        "fullcodeline": "printf(\"Checking MyISAM file: %s\\n\",filename);"
    },
    {
        "line": 279,
        "fullcodeline": "printf(\"Data records: %7s   Deleted blocks: %7s\\n\","
    },
    {
        "line": 286,
        "fullcodeline": "error|=chk_del(param, info,param->testflag);"
    },
    {
        "line": 290,
        "fullcodeline": "error|=chk_key(param, info);"
    },
    {
        "line": 299,
        "fullcodeline": "!(param->testflag & (T_FAST | T_FORCE_CREATE)))"
    },
    {
        "line": 304,
        "fullcodeline": "(void) init_io_cache(&param->read_cache,datafile,"
    },
    {
        "line": 312,
        "fullcodeline": "lock_memory(param);"
    },
    {
        "line": 317,
        "fullcodeline": "error|=flush_blocks(param, share->key_cache, share->kfile);"
    },
    {
        "line": 318,
        "fullcodeline": "(void) end_io_cache(&param->read_cache);"
    },
    {
        "line": 325,
        "fullcodeline": "share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |"
    },
    {
        "line": 210,
        "fullcodeline": "(rep_quick && !param->keys_in_use && !recreate)) &&"
    },
    {
        "line": 216,
        "fullcodeline": "error=mi_repair_by_sort(param,info,filename,rep_quick);"
    },
    {
        "line": 221,
        "fullcodeline": "else if (param->testflag & T_REP_ANY)"
    },
    {
        "line": 236,
        "fullcodeline": "error=1;"
    },
    {
        "line": 250,
        "fullcodeline": "if (share->keyinfo[key].flag & (HA_BINARY_PACK_KEY|HA_FULLTEXT))"
    },
    {
        "line": 255,
        "fullcodeline": "(my_bool) !(param->testflag & T_REP),"
    },
    {
        "line": 262,
        "fullcodeline": "error=mi_repair_by_sort(param,info,filename,1);"
    },
    {
        "line": 280,
        "fullcodeline": "llstr(info->state->records,llbuff),"
    },
    {
        "line": 281,
        "fullcodeline": "llstr(info->state->del,llbuff2));"
    },
    {
        "line": 288,
        "fullcodeline": "!param->start_check_pos)))"
    },
    {
        "line": 291,
        "fullcodeline": "if (!error && (param->testflag & (T_STATISTICS | T_AUTO_INC)))"
    },
    {
        "line": 301,
        "fullcodeline": "if (param->testflag & (T_EXTEND | T_MEDIUM))"
    },
    {
        "line": 313,
        "fullcodeline": "if ((info->s->options & (HA_OPTION_PACK_RECORD |"
    },
    {
        "line": 322,
        "fullcodeline": "if ((share->state.changed & STATE_CHANGED) &&"
    },
    {
        "line": 218,
        "fullcodeline": "error=mi_repair_parallel(param,info,filename,rep_quick);"
    },
    {
        "line": 222,
        "fullcodeline": "error=mi_repair(param, info,filename,rep_quick);"
    },
    {
        "line": 251,
        "fullcodeline": "update_index=0;"
    },
    {
        "line": 292,
        "fullcodeline": "error=update_state_info(param, info,"
    },
    {
        "line": 302,
        "fullcodeline": "(void) init_key_cache(dflt_key_cache,opt_key_cache_block_size,"
    },
    {
        "line": 305,
        "fullcodeline": "(uint) param->read_buffer_length,"
    },
    {
        "line": 307,
        "fullcodeline": "(param->start_check_pos ?"
    },
    {
        "line": 311,
        "fullcodeline": "MYF(MY_WME));"
    },
    {
        "line": 315,
        "fullcodeline": "(param->testflag & (T_EXTEND | T_MEDIUM)))"
    },
    {
        "line": 316,
        "fullcodeline": "error|=chk_data_link(param, info, param->testflag & T_EXTEND);"
    },
    {
        "line": 323,
        "fullcodeline": "(param->testflag & T_UPDATE_STATE))"
    },
    {
        "line": 324,
        "fullcodeline": "info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;"
    },
    {
        "line": 328,
        "fullcodeline": "else if (!mi_is_crashed(info) &&"
    },
    {
        "line": 261,
        "fullcodeline": "puts(\"Table had a compressed index;  We must now recreate the index\");"
    },
    {
        "line": 329,
        "fullcodeline": "(param->testflag & T_UPDATE_STATE))"
    },
    {
        "line": 331,
        "fullcodeline": "mi_mark_crashed(info);"
    },
    {
        "line": 332,
        "fullcodeline": "info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;"
    },
    {
        "line": 293,
        "fullcodeline": "((param->testflag & T_STATISTICS) ?"
    },
    {
        "line": 295,
        "fullcodeline": "((param->testflag & T_AUTO_INC) ?"
    }
]