[
    {
        "line": 10,
        "fullcodeline": "MI_SORT_PARAM *sort_param=0;"
    },
    {
        "line": 11,
        "fullcodeline": "MYISAM_SHARE *share=info->s;"
    },
    {
        "line": 14,
        "fullcodeline": "char llbuff[22];"
    },
    {
        "line": 22,
        "fullcodeline": "DBUG_ENTER(\"mi_repair_parallel\");"
    },
    {
        "line": 24,
        "fullcodeline": "start_records=info->state->records;"
    },
    {
        "line": 25,
        "fullcodeline": "got_error=1;"
    },
    {
        "line": 26,
        "fullcodeline": "new_file= -1;"
    },
    {
        "line": 27,
        "fullcodeline": "new_header_length=(param->testflag & T_UNPACK) ? 0 :"
    },
    {
        "line": 34,
        "fullcodeline": "param->testflag|=T_REP; /* for easy checking */"
    },
    {
        "line": 67,
        "fullcodeline": "DBUG_PRINT(\"info\", (\"is quick repair: %d\", rep_quick));"
    },
    {
        "line": 68,
        "fullcodeline": "bzero((char*)&sort_info,sizeof(sort_info));"
    },
    {
        "line": 70,
        "fullcodeline": "mysql_mutex_init(mi_key_mutex_MI_SORT_INFO_mutex,"
    },
    {
        "line": 72,
        "fullcodeline": "mysql_cond_init(mi_key_cond_MI_SORT_INFO_cond, &sort_info.cond, 0);"
    },
    {
        "line": 73,
        "fullcodeline": "mysql_mutex_init(mi_key_mutex_MI_CHECK_print_msg,"
    },
    {
        "line": 75,
        "fullcodeline": "param->need_print_msg_lock= 1;"
    },
    {
        "line": 93,
        "fullcodeline": "sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks;"
    },
    {
        "line": 94,
        "fullcodeline": "info->opt_flag|=WRITE_CACHE_USED;"
    },
    {
        "line": 95,
        "fullcodeline": "info->rec_cache.file=info->dfile;         /* for sort_delete_record */"
    },
    {
        "line": 124,
        "fullcodeline": "info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);"
    },
    {
        "line": 127,
        "fullcodeline": "mi_drop_all_indexes(param, info, FALSE);"
    },
    {
        "line": 128,
        "fullcodeline": "key_map= share->state.key_map;"
    },
    {
        "line": 135,
        "fullcodeline": "sort_info.info=info;"
    },
    {
        "line": 136,
        "fullcodeline": "sort_info.param = param;"
    },
    {
        "line": 138,
        "fullcodeline": "set_data_file_type(&sort_info, share);"
    },
    {
        "line": 139,
        "fullcodeline": "sort_info.dupp=0;"
    },
    {
        "line": 140,
        "fullcodeline": "sort_info.buff=0;"
    },
    {
        "line": 141,
        "fullcodeline": "param->read_cache.end_of_file=sort_info.filelength="
    },
    {
        "line": 162,
        "fullcodeline": "sort_info.max_records="
    },
    {
        "line": 166,
        "fullcodeline": "del=info->state->del;"
    },
    {
        "line": 167,
        "fullcodeline": "param->glob_crc=0;"
    },
    {
        "line": 169,
        "fullcodeline": "max_pack_reclength= share->base.pack_reclength;"
    },
    {
        "line": 180,
        "fullcodeline": "total_key_length=0;"
    },
    {
        "line": 181,
        "fullcodeline": "rec_per_key_part= param->rec_per_key_part;"
    },
    {
        "line": 182,
        "fullcodeline": "info->state->records=info->state->del=share->state.split=0;"
    },
    {
        "line": 183,
        "fullcodeline": "info->state->empty=0;"
    },
    {
        "line": 259,
        "fullcodeline": "sort_info.total_keys=i;"
    },
    {
        "line": 260,
        "fullcodeline": "sort_param[0].master= 1;"
    },
    {
        "line": 261,
        "fullcodeline": "sort_param[0].fix_datafile= (my_bool)(! rep_quick);"
    },
    {
        "line": 262,
        "fullcodeline": "sort_param[0].calc_checksum= test(param->testflag & T_CALC_CHECKSUM);"
    },
    {
        "line": 267,
        "fullcodeline": "sort_info.got_error=0;"
    },
    {
        "line": 268,
        "fullcodeline": "mysql_mutex_lock(&sort_info.mutex);"
    },
    {
        "line": 286,
        "fullcodeline": "(void) pthread_attr_init(&thr_attr);"
    },
    {
        "line": 287,
        "fullcodeline": "(void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);"
    },
    {
        "line": 332,
        "fullcodeline": "(void) pthread_attr_destroy(&thr_attr);"
    },
    {
        "line": 337,
        "fullcodeline": "mysql_mutex_unlock(&sort_info.mutex);"
    },
    {
        "line": 344,
        "fullcodeline": "got_error=1;\t\t\t\t/* Assume the following may go wrong */"
    },
    {
        "line": 423,
        "fullcodeline": "got_error=0;"
    },
    {
        "line": 429,
        "fullcodeline": "got_error|= flush_blocks(param, share->key_cache, share->kfile);"
    },
    {
        "line": 435,
        "fullcodeline": "(void) end_io_cache(&info->rec_cache);"
    },
    {
        "line": 479,
        "fullcodeline": "share->state.changed|=STATE_NOT_SORTED_PAGES;"
    },
    {
        "line": 481,
        "fullcodeline": "mysql_cond_destroy(&sort_info.cond);"
    },
    {
        "line": 482,
        "fullcodeline": "mysql_mutex_destroy(&sort_info.mutex);"
    },
    {
        "line": 483,
        "fullcodeline": "mysql_mutex_destroy(&param->print_msg_mutex);"
    },
    {
        "line": 484,
        "fullcodeline": "param->need_print_msg_lock= 0;"
    },
    {
        "line": 486,
        "fullcodeline": "my_free(sort_info.ft_buf);"
    },
    {
        "line": 487,
        "fullcodeline": "my_free(sort_info.key_block);"
    },
    {
        "line": 488,
        "fullcodeline": "my_free(sort_param);"
    },
    {
        "line": 489,
        "fullcodeline": "my_free(sort_info.buff);"
    },
    {
        "line": 490,
        "fullcodeline": "(void) end_io_cache(&param->read_cache);"
    },
    {
        "line": 491,
        "fullcodeline": "info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);"
    },
    {
        "line": 497,
        "fullcodeline": "DBUG_RETURN(got_error);"
    },
    {
        "line": 29,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 36,
        "fullcodeline": "if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))"
    },
    {
        "line": 77,
        "fullcodeline": "if (!(sort_info.key_block="
    },
    {
        "line": 97,
        "fullcodeline": "if (!rep_quick)"
    },
    {
        "line": 129,
        "fullcodeline": "if (param->testflag & T_CREATE_MISSING_KEYS)"
    },
    {
        "line": 144,
        "fullcodeline": "if (share->data_file_type == DYNAMIC_RECORD)"
    },
    {
        "line": 163,
        "fullcodeline": "((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records + 1:"
    },
    {
        "line": 170,
        "fullcodeline": "if (share->options & HA_OPTION_COMPRESS_RECORD)"
    },
    {
        "line": 172,
        "fullcodeline": "if (!(sort_param=(MI_SORT_PARAM *)"
    },
    {
        "line": 185,
        "fullcodeline": "for (i=key=0, istep=1 ; key < share->base.keys ;"
    },
    {
        "line": 186,
        "fullcodeline": "rec_per_key_part+=sort_param[i].keyinfo->keysegs, i+=istep, key++)"
    },
    {
        "line": 264,
        "fullcodeline": "if (!ftparser_alloc_param(info))"
    },
    {
        "line": 276,
        "fullcodeline": "if (i > 1)"
    },
    {
        "line": 289,
        "fullcodeline": "for (i=0 ; i < sort_info.total_keys ; i++)"
    },
    {
        "line": 336,
        "fullcodeline": "mysql_cond_wait(&sort_info.cond, &sort_info.mutex);"
    },
    {
        "line": 339,
        "fullcodeline": "if ((got_error= thr_write_keys(sort_param)))"
    },
    {
        "line": 382,
        "fullcodeline": "if (rep_quick && del+sort_info.dupp != info->state->del)"
    },
    {
        "line": 391,
        "fullcodeline": "if (rep_quick & T_FORCE_UNIQUENESS)"
    },
    {
        "line": 407,
        "fullcodeline": "if (param->testflag & T_CALC_CHECKSUM)"
    },
    {
        "line": 410,
        "fullcodeline": "if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))"
    },
    {
        "line": 414,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 425,
        "fullcodeline": "if (&share->state.state != info->state)"
    },
    {
        "line": 442,
        "fullcodeline": "if (!rep_quick)"
    },
    {
        "line": 444,
        "fullcodeline": "if (!got_error)"
    },
    {
        "line": 492,
        "fullcodeline": "if (!got_error && (param->testflag & T_UNPACK))"
    },
    {
        "line": 31,
        "fullcodeline": "printf(\"- parallel recovering (with sort) MyISAM-table '%s'\\n\",name);"
    },
    {
        "line": 32,
        "fullcodeline": "printf(\"Data records: %s\\n\", llstr(start_records,llbuff));"
    },
    {
        "line": 37,
        "fullcodeline": "param->testflag|=T_CALC_CHECKSUM;"
    },
    {
        "line": 83,
        "fullcodeline": "(!rep_quick &&"
    },
    {
        "line": 120,
        "fullcodeline": "share->state.dellink= HA_OFFSET_ERROR;"
    },
    {
        "line": 121,
        "fullcodeline": "info->rec_cache.file=new_file;"
    },
    {
        "line": 132,
        "fullcodeline": "key_map= ~key_map;"
    },
    {
        "line": 142,
        "fullcodeline": "mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0));"
    },
    {
        "line": 145,
        "fullcodeline": "rec_length=max(share->base.min_pack_length+1,share->base.min_block_length);"
    },
    {
        "line": 164,
        "fullcodeline": "(ha_rows) (sort_info.filelength/rec_length+1));"
    },
    {
        "line": 171,
        "fullcodeline": "set_if_bigger(max_pack_reclength, share->max_pack_length);"
    },
    {
        "line": 177,
        "fullcodeline": "mi_check_print_error(param,\"Not enough memory for key!\");"
    },
    {
        "line": 188,
        "fullcodeline": "sort_param[i].key=key;"
    },
    {
        "line": 189,
        "fullcodeline": "sort_param[i].keyinfo=share->keyinfo+key;"
    },
    {
        "line": 190,
        "fullcodeline": "sort_param[i].seg=sort_param[i].keyinfo->seg;"
    },
    {
        "line": 205,
        "fullcodeline": "istep=1;"
    },
    {
        "line": 218,
        "fullcodeline": "sort_param[i].key_cmp=sort_key_cmp;"
    },
    {
        "line": 219,
        "fullcodeline": "sort_param[i].lock_in_memory=lock_memory;"
    },
    {
        "line": 220,
        "fullcodeline": "sort_param[i].tmpdir=param->tmpdir;"
    },
    {
        "line": 221,
        "fullcodeline": "sort_param[i].sort_info=&sort_info;"
    },
    {
        "line": 222,
        "fullcodeline": "sort_param[i].master=0;"
    },
    {
        "line": 223,
        "fullcodeline": "sort_param[i].fix_datafile=0;"
    },
    {
        "line": 224,
        "fullcodeline": "sort_param[i].calc_checksum= 0;"
    },
    {
        "line": 226,
        "fullcodeline": "sort_param[i].filepos=new_header_length;"
    },
    {
        "line": 227,
        "fullcodeline": "sort_param[i].max_pos=sort_param[i].pos=share->pack.header_length;"
    },
    {
        "line": 229,
        "fullcodeline": "sort_param[i].record= (((uchar *)(sort_param+share->base.keys))+"
    },
    {
        "line": 237,
        "fullcodeline": "sort_param[i].key_length=share->rec_reflength;"
    },
    {
        "line": 249,
        "fullcodeline": "total_key_length+=sort_param[i].key_length;"
    },
    {
        "line": 299,
        "fullcodeline": "sort_param[i].read_cache= ((rep_quick || !i) ? param->read_cache :"
    },
    {
        "line": 301,
        "fullcodeline": "DBUG_PRINT(\"io_cache_share\", (\"thread: %u  read_cache: 0x%lx\","
    },
    {
        "line": 310,
        "fullcodeline": "sort_param[i].sortbuff_size="
    },
    {
        "line": 341,
        "fullcodeline": "param->retry_repair=1;"
    },
    {
        "line": 364,
        "fullcodeline": "share->state.state.data_file_length= info->state->data_file_length="
    },
    {
        "line": 367,
        "fullcodeline": "share->state.version=(ulong) time((time_t*) 0);"
    },
    {
        "line": 373,
        "fullcodeline": "mysql_file_close(info->dfile, MYF(0));"
    },
    {
        "line": 374,
        "fullcodeline": "info->dfile=new_file;"
    },
    {
        "line": 376,
        "fullcodeline": "share->data_file_type=sort_info.new_data_file_type;"
    },
    {
        "line": 377,
        "fullcodeline": "share->pack.header_length=(ulong) new_header_length;"
    },
    {
        "line": 384,
        "fullcodeline": "mi_check_print_error(param,\"Couldn't fix table with quick recovery: Found wrong number of deleted records\");"
    },
    {
        "line": 385,
        "fullcodeline": "mi_check_print_error(param,\"Run recovery again without -q\");"
    },
    {
        "line": 386,
        "fullcodeline": "param->retry_repair=1;"
    },
    {
        "line": 387,
        "fullcodeline": "param->testflag|=T_RETRY_WITHOUT_QUICK;"
    },
    {
        "line": 393,
        "fullcodeline": "my_off_t skr=info->state->data_file_length+"
    },
    {
        "line": 408,
        "fullcodeline": "info->state->checksum=param->glob_crc;"
    },
    {
        "line": 411,
        "fullcodeline": "mi_check_print_warning(param,"
    },
    {
        "line": 426,
        "fullcodeline": "memcpy(&share->state.state, info->state, sizeof(*info->state));"
    },
    {
        "line": 443,
        "fullcodeline": "(void) end_io_cache(&new_data_cache);"
    },
    {
        "line": 475,
        "fullcodeline": "mi_mark_crashed_on_repair(info);"
    },
    {
        "line": 494,
        "fullcodeline": "share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;"
    },
    {
        "line": 495,
        "fullcodeline": "share->pack.header_length=0;"
    },
    {
        "line": 80,
        "fullcodeline": "init_io_cache(&param->read_cache, info->dfile,"
    },
    {
        "line": 84,
        "fullcodeline": "(init_io_cache(&info->rec_cache, info->dfile,"
    },
    {
        "line": 100,
        "fullcodeline": "if ((new_file= mysql_file_create(mi_key_file_datatmp,"
    },
    {
        "line": 111,
        "fullcodeline": "if (new_header_length &&"
    },
    {
        "line": 115,
        "fullcodeline": "if (param->testflag & T_UNPACK)"
    },
    {
        "line": 195,
        "fullcodeline": "if (! mi_is_key_active(key_map, key))"
    },
    {
        "line": 206,
        "fullcodeline": "if ((!(param->testflag & T_SILENT)))"
    },
    {
        "line": 208,
        "fullcodeline": "if (sort_param[i].keyinfo->flag & HA_FULLTEXT)"
    },
    {
        "line": 231,
        "fullcodeline": "if (!mi_alloc_rec_buff(info, -1, &sort_param[i].rec_buff))"
    },
    {
        "line": 238,
        "fullcodeline": "for (keyseg=sort_param[i].seg; keyseg->type != HA_KEYTYPE_END;"
    },
    {
        "line": 239,
        "fullcodeline": "keyseg++)"
    },
    {
        "line": 251,
        "fullcodeline": "if (sort_param[i].keyinfo->flag & HA_FULLTEXT)"
    },
    {
        "line": 284,
        "fullcodeline": "io_share.total_threads= 0; /* share not used */"
    },
    {
        "line": 312,
        "fullcodeline": "param->sort_buffer_length/sort_info.total_keys;"
    },
    {
        "line": 316,
        "fullcodeline": "if ((error= mysql_thread_create(mi_key_thread_find_all_keys,"
    },
    {
        "line": 353,
        "fullcodeline": "if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache))"
    },
    {
        "line": 355,
        "fullcodeline": "if (param->testflag & T_SAFE_REPAIR)"
    },
    {
        "line": 380,
        "fullcodeline": "info->state->data_file_length=sort_param->max_pos;"
    },
    {
        "line": 401,
        "fullcodeline": "if (skr != sort_info.filelength)"
    },
    {
        "line": 416,
        "fullcodeline": "if (start_records != info->state->records)"
    },
    {
        "line": 447,
        "fullcodeline": "if (new_file >= 0)"
    },
    {
        "line": 464,
        "fullcodeline": "if (! param->error_printed)"
    },
    {
        "line": 466,
        "fullcodeline": "if (new_file >= 0)"
    },
    {
        "line": 81,
        "fullcodeline": "(uint) param->read_buffer_length,"
    },
    {
        "line": 82,
        "fullcodeline": "READ_CACHE, share->pack.header_length, 1, MYF(MY_WME)) ||"
    },
    {
        "line": 88,
        "fullcodeline": "init_io_cache(&new_data_cache, -1,"
    },
    {
        "line": 107,
        "fullcodeline": "mi_check_print_error(param,\"Can't create new tempfile: '%s'\","
    },
    {
        "line": 112,
        "fullcodeline": "filecopy(param, new_file,info->dfile,0L,new_header_length,"
    },
    {
        "line": 117,
        "fullcodeline": "share->options&= ~HA_OPTION_COMPRESS_RECORD;"
    },
    {
        "line": 118,
        "fullcodeline": "mi_int2store(share->state.header.options,share->options);"
    },
    {
        "line": 146,
        "fullcodeline": "else if (share->data_file_type == COMPRESSED_RECORD)"
    },
    {
        "line": 173,
        "fullcodeline": "my_malloc((uint) share->base.keys *"
    },
    {
        "line": 198,
        "fullcodeline": "memcpy((char*) rec_per_key_part,"
    },
    {
        "line": 202,
        "fullcodeline": "istep=0;"
    },
    {
        "line": 207,
        "fullcodeline": "printf (\"- Fixing index %d\\n\",key+1);"
    },
    {
        "line": 210,
        "fullcodeline": "sort_param[i].key_read=sort_ft_key_read;"
    },
    {
        "line": 211,
        "fullcodeline": "sort_param[i].key_write=sort_ft_key_write;"
    },
    {
        "line": 230,
        "fullcodeline": "(max_pack_reclength * i));"
    },
    {
        "line": 233,
        "fullcodeline": "mi_check_print_error(param,\"Not enough memory!\");"
    },
    {
        "line": 241,
        "fullcodeline": "sort_param[i].key_length+=keyseg->length;"
    },
    {
        "line": 253,
        "fullcodeline": "uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*"
    },
    {
        "line": 255,
        "fullcodeline": "sort_param[i].key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;"
    },
    {
        "line": 256,
        "fullcodeline": "init_alloc_root(&sort_param[i].wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);"
    },
    {
        "line": 279,
        "fullcodeline": "init_io_cache_share(&param->read_cache, &io_share, NULL, i);"
    },
    {
        "line": 321,
        "fullcodeline": "mi_check_print_error(param,\"Cannot start a repair thread (errno= %d)\","
    },
    {
        "line": 326,
        "fullcodeline": "DBUG_PRINT(\"error\", (\"Cannot start a repair thread\"));"
    },
    {
        "line": 327,
        "fullcodeline": "sort_info.got_error=1;"
    },
    {
        "line": 394,
        "fullcodeline": "(share->options & HA_OPTION_COMPRESS_RECORD ?"
    },
    {
        "line": 417,
        "fullcodeline": "printf(\"Data records: %s\\n\", llstr(info->state->records,llbuff));"
    },
    {
        "line": 419,
        "fullcodeline": "mi_check_print_warning(param,"
    },
    {
        "line": 449,
        "fullcodeline": "myf flags= 0;"
    },
    {
        "line": 454,
        "fullcodeline": "mysql_file_close(new_file, MYF(0));"
    },
    {
        "line": 455,
        "fullcodeline": "info->dfile=new_file= -1;"
    },
    {
        "line": 465,
        "fullcodeline": "mi_check_print_error(param,\"%d when fixing table\",my_errno);"
    },
    {
        "line": 468,
        "fullcodeline": "(void) mysql_file_close(new_file, MYF(0));"
    },
    {
        "line": 469,
        "fullcodeline": "(void) mysql_file_delete(mi_key_file_datatmp,"
    },
    {
        "line": 477,
        "fullcodeline": "else if (key_map == share->state.key_map)"
    },
    {
        "line": 78,
        "fullcodeline": "alloc_key_blocks(param, (uint) param->sort_key_blocks,"
    },
    {
        "line": 85,
        "fullcodeline": "(uint) param->write_buffer_length,"
    },
    {
        "line": 87,
        "fullcodeline": "MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw) ||"
    },
    {
        "line": 89,
        "fullcodeline": "(uint) param->write_buffer_length,"
    },
    {
        "line": 91,
        "fullcodeline": "MYF(MY_WME | MY_DONT_CHECK_FILESIZE)))))"
    },
    {
        "line": 147,
        "fullcodeline": "rec_length=share->base.min_block_length;"
    },
    {
        "line": 175,
        "fullcodeline": "MYF(MY_ZEROFILL))))"
    },
    {
        "line": 199,
        "fullcodeline": "(char*) (share->state.rec_per_key_part+"
    },
    {
        "line": 201,
        "fullcodeline": "sort_param[i].keyinfo->keysegs*sizeof(*rec_per_key_part));"
    },
    {
        "line": 215,
        "fullcodeline": "sort_param[i].key_read=sort_key_read;"
    },
    {
        "line": 216,
        "fullcodeline": "sort_param[i].key_write=sort_key_write;"
    },
    {
        "line": 242,
        "fullcodeline": "if (keyseg->flag & HA_SPACE_PACK)"
    },
    {
        "line": 244,
        "fullcodeline": "if (keyseg->flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART))"
    },
    {
        "line": 246,
        "fullcodeline": "if (keyseg->flag & HA_NULL_PART)"
    },
    {
        "line": 281,
        "fullcodeline": "init_io_cache_share(&new_data_cache, &io_share, &info->rec_cache, i);"
    },
    {
        "line": 302,
        "fullcodeline": "i, (long) &sort_param[i].read_cache));"
    },
    {
        "line": 319,
        "fullcodeline": "(void *) (sort_param+i))))"
    },
    {
        "line": 330,
        "fullcodeline": "sort_info.threads_running++;"
    },
    {
        "line": 358,
        "fullcodeline": "if (info->state->records+1 < start_records)"
    },
    {
        "line": 402,
        "fullcodeline": "if (mysql_file_chsize(info->dfile, skr, 0, MYF(0)))"
    },
    {
        "line": 421,
        "fullcodeline": "llstr(sort_info.dupp,llbuff));"
    },
    {
        "line": 450,
        "fullcodeline": "if (param->testflag & T_BACKUP_DATA)"
    },
    {
        "line": 456,
        "fullcodeline": "if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,"
    },
    {
        "line": 471,
        "fullcodeline": "if (info->dfile == new_file) /* Retry with key cache */"
    },
    {
        "line": 478,
        "fullcodeline": "share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS;"
    },
    {
        "line": 101,
        "fullcodeline": "fn_format(param->temp_filename,"
    },
    {
        "line": 105,
        "fullcodeline": "MYF(0))) < 0)"
    },
    {
        "line": 149,
        "fullcodeline": "rec_length=share->base.pack_reclength;"
    },
    {
        "line": 174,
        "fullcodeline": "(sizeof(MI_SORT_PARAM) + max_pack_reclength),"
    },
    {
        "line": 243,
        "fullcodeline": "sort_param[i].key_length+=get_pack_length(keyseg->length);"
    },
    {
        "line": 245,
        "fullcodeline": "sort_param[i].key_length+=2 + test(keyseg->length >= 127);"
    },
    {
        "line": 247,
        "fullcodeline": "sort_param[i].key_length++;"
    },
    {
        "line": 325,
        "fullcodeline": "remove_io_thread(&sort_param[i].read_cache);"
    },
    {
        "line": 360,
        "fullcodeline": "info->state->records=start_records;"
    },
    {
        "line": 403,
        "fullcodeline": "mi_check_print_warning(param,"
    },
    {
        "line": 451,
        "fullcodeline": "flags |= MY_REDEL_MAKE_BACKUP;"
    },
    {
        "line": 453,
        "fullcodeline": "flags |= MY_REDEL_NO_COPY_STAT;"
    },
    {
        "line": 458,
        "fullcodeline": "mi_open_datafile(info,share,name,-1))"
    },
    {
        "line": 459,
        "fullcodeline": "got_error=1;"
    },
    {
        "line": 470,
        "fullcodeline": "param->temp_filename, MYF(MY_WME));"
    },
    {
        "line": 200,
        "fullcodeline": "(uint) (rec_per_key_part - param->rec_per_key_part)),"
    },
    {
        "line": 472,
        "fullcodeline": "if (unlikely(mi_open_datafile(info, share, name, -1)))"
    },
    {
        "line": 473,
        "fullcodeline": "param->retry_repair= 0; /* Safety */"
    }
]