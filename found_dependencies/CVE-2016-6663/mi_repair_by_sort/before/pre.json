[
    {
        "line": 11,
        "fullcodeline": "MYISAM_SHARE *share=info->s;"
    },
    {
        "line": 14,
        "fullcodeline": "char llbuff[22];"
    },
    {
        "line": 17,
        "fullcodeline": "DBUG_ENTER(\"mi_repair_by_sort\");"
    },
    {
        "line": 19,
        "fullcodeline": "start_records=info->state->records;"
    },
    {
        "line": 20,
        "fullcodeline": "got_error=1;"
    },
    {
        "line": 21,
        "fullcodeline": "new_file= -1;"
    },
    {
        "line": 22,
        "fullcodeline": "new_header_length=(param->testflag & T_UNPACK) ? 0 :"
    },
    {
        "line": 29,
        "fullcodeline": "param->testflag|=T_REP; /* for easy checking */"
    },
    {
        "line": 34,
        "fullcodeline": "bzero((char*)&sort_info,sizeof(sort_info));"
    },
    {
        "line": 35,
        "fullcodeline": "bzero((char *)&sort_param, sizeof(sort_param));"
    },
    {
        "line": 49,
        "fullcodeline": "sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks;"
    },
    {
        "line": 50,
        "fullcodeline": "info->opt_flag|=WRITE_CACHE_USED;"
    },
    {
        "line": 51,
        "fullcodeline": "info->rec_cache.file=info->dfile;\t\t/* for sort_delete_record */"
    },
    {
        "line": 86,
        "fullcodeline": "info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);"
    },
    {
        "line": 89,
        "fullcodeline": "mi_drop_all_indexes(param, info, FALSE);"
    },
    {
        "line": 90,
        "fullcodeline": "key_map= share->state.key_map;"
    },
    {
        "line": 97,
        "fullcodeline": "sort_info.info=info;"
    },
    {
        "line": 98,
        "fullcodeline": "sort_info.param = param;"
    },
    {
        "line": 100,
        "fullcodeline": "set_data_file_type(&sort_info, share);"
    },
    {
        "line": 101,
        "fullcodeline": "sort_param.filepos=new_header_length;"
    },
    {
        "line": 102,
        "fullcodeline": "sort_info.dupp=0;"
    },
    {
        "line": 103,
        "fullcodeline": "sort_info.buff=0;"
    },
    {
        "line": 104,
        "fullcodeline": "param->read_cache.end_of_file=sort_info.filelength="
    },
    {
        "line": 107,
        "fullcodeline": "sort_param.wordlist=NULL;"
    },
    {
        "line": 108,
        "fullcodeline": "init_alloc_root(&sort_param.wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);"
    },
    {
        "line": 116,
        "fullcodeline": "sort_info.max_records="
    },
    {
        "line": 119,
        "fullcodeline": "sort_param.key_cmp=sort_key_cmp;"
    },
    {
        "line": 120,
        "fullcodeline": "sort_param.lock_in_memory=lock_memory;"
    },
    {
        "line": 121,
        "fullcodeline": "sort_param.tmpdir=param->tmpdir;"
    },
    {
        "line": 122,
        "fullcodeline": "sort_param.sort_info=&sort_info;"
    },
    {
        "line": 123,
        "fullcodeline": "sort_param.fix_datafile= (my_bool) (! rep_quick);"
    },
    {
        "line": 124,
        "fullcodeline": "sort_param.master =1;"
    },
    {
        "line": 126,
        "fullcodeline": "del=info->state->del;"
    },
    {
        "line": 127,
        "fullcodeline": "param->glob_crc=0;"
    },
    {
        "line": 131,
        "fullcodeline": "rec_per_key_part= param->rec_per_key_part;"
    },
    {
        "line": 316,
        "fullcodeline": "got_error=0;"
    },
    {
        "line": 322,
        "fullcodeline": "got_error|= flush_blocks(param, share->key_cache, share->kfile);"
    },
    {
        "line": 323,
        "fullcodeline": "(void) end_io_cache(&info->rec_cache);"
    },
    {
        "line": 355,
        "fullcodeline": "share->state.changed|=STATE_NOT_SORTED_PAGES;"
    },
    {
        "line": 357,
        "fullcodeline": "my_free(mi_get_rec_buff_ptr(info, sort_param.rec_buff));"
    },
    {
        "line": 358,
        "fullcodeline": "my_free(mi_get_rec_buff_ptr(info, sort_param.record));"
    },
    {
        "line": 359,
        "fullcodeline": "my_free(sort_info.key_block);"
    },
    {
        "line": 360,
        "fullcodeline": "my_free(sort_info.ft_buf);"
    },
    {
        "line": 361,
        "fullcodeline": "my_free(sort_info.buff);"
    },
    {
        "line": 362,
        "fullcodeline": "(void) end_io_cache(&param->read_cache);"
    },
    {
        "line": 363,
        "fullcodeline": "info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);"
    },
    {
        "line": 369,
        "fullcodeline": "DBUG_RETURN(got_error);"
    },
    {
        "line": 24,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 31,
        "fullcodeline": "if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))"
    },
    {
        "line": 36,
        "fullcodeline": "if (!(sort_info.key_block="
    },
    {
        "line": 53,
        "fullcodeline": "if (!mi_alloc_rec_buff(info, -1, &sort_param.record) ||"
    },
    {
        "line": 59,
        "fullcodeline": "if (!rep_quick)"
    },
    {
        "line": 91,
        "fullcodeline": "if (param->testflag & T_CREATE_MISSING_KEYS)"
    },
    {
        "line": 110,
        "fullcodeline": "if (share->data_file_type == DYNAMIC_RECORD)"
    },
    {
        "line": 117,
        "fullcodeline": "((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records :"
    },
    {
        "line": 128,
        "fullcodeline": "if (param->testflag & T_CALC_CHECKSUM)"
    },
    {
        "line": 132,
        "fullcodeline": "for (sort_param.key=0 ; sort_param.key < share->base.keys ;"
    },
    {
        "line": 133,
        "fullcodeline": "rec_per_key_part+=sort_param.keyinfo->keysegs, sort_param.key++)"
    },
    {
        "line": 268,
        "fullcodeline": "if (param->testflag & T_WRITE_LOOP)"
    },
    {
        "line": 273,
        "fullcodeline": "if (rep_quick && del+sort_info.dupp != info->state->del)"
    },
    {
        "line": 283,
        "fullcodeline": "if (rep_quick & T_FORCE_UNIQUENESS)"
    },
    {
        "line": 299,
        "fullcodeline": "if (param->testflag & T_CALC_CHECKSUM)"
    },
    {
        "line": 302,
        "fullcodeline": "if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))"
    },
    {
        "line": 307,
        "fullcodeline": "if (!(param->testflag & T_SILENT))"
    },
    {
        "line": 318,
        "fullcodeline": "if (&share->state.state != info->state)"
    },
    {
        "line": 324,
        "fullcodeline": "if (!got_error)"
    },
    {
        "line": 364,
        "fullcodeline": "if (!got_error && (param->testflag & T_UNPACK))"
    },
    {
        "line": 26,
        "fullcodeline": "printf(\"- recovering (with sort) MyISAM-table '%s'\\n\",name);"
    },
    {
        "line": 27,
        "fullcodeline": "printf(\"Data records: %s\\n\", llstr(start_records,llbuff));"
    },
    {
        "line": 32,
        "fullcodeline": "param->testflag|=T_CALC_CHECKSUM;"
    },
    {
        "line": 43,
        "fullcodeline": "(! rep_quick &&"
    },
    {
        "line": 54,
        "fullcodeline": "!mi_alloc_rec_buff(info, -1, &sort_param.rec_buff))"
    },
    {
        "line": 56,
        "fullcodeline": "mi_check_print_error(param, \"Not enough memory for extra record\");"
    },
    {
        "line": 82,
        "fullcodeline": "share->state.dellink= HA_OFFSET_ERROR;"
    },
    {
        "line": 83,
        "fullcodeline": "info->rec_cache.file=new_file;"
    },
    {
        "line": 94,
        "fullcodeline": "key_map= ~key_map;"
    },
    {
        "line": 105,
        "fullcodeline": "mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0));"
    },
    {
        "line": 111,
        "fullcodeline": "length=max(share->base.min_pack_length+1,share->base.min_block_length);"
    },
    {
        "line": 118,
        "fullcodeline": "(ha_rows) (sort_info.filelength/length+1));"
    },
    {
        "line": 129,
        "fullcodeline": "sort_param.calc_checksum= 1;"
    },
    {
        "line": 135,
        "fullcodeline": "sort_param.read_cache=param->read_cache;"
    },
    {
        "line": 136,
        "fullcodeline": "sort_param.keyinfo=share->keyinfo+sort_param.key;"
    },
    {
        "line": 137,
        "fullcodeline": "sort_param.seg=sort_param.keyinfo->seg;"
    },
    {
        "line": 156,
        "fullcodeline": "sort_param.max_pos=sort_param.pos=share->pack.header_length;"
    },
    {
        "line": 157,
        "fullcodeline": "keyseg=sort_param.seg;"
    },
    {
        "line": 158,
        "fullcodeline": "bzero((char*) sort_param.unique,sizeof(sort_param.unique));"
    },
    {
        "line": 159,
        "fullcodeline": "sort_param.key_length=share->rec_reflength;"
    },
    {
        "line": 170,
        "fullcodeline": "info->state->records=info->state->del=share->state.split=0;"
    },
    {
        "line": 171,
        "fullcodeline": "info->state->empty=0;"
    },
    {
        "line": 221,
        "fullcodeline": "sort_param.calc_checksum= 0;"
    },
    {
        "line": 222,
        "fullcodeline": "free_root(&sort_param.wordroot, MYF(0));"
    },
    {
        "line": 225,
        "fullcodeline": "sort_info.max_records= (ha_rows) info->state->records;"
    },
    {
        "line": 233,
        "fullcodeline": "mi_set_key_active(share->state.key_map, sort_param.key);"
    },
    {
        "line": 234,
        "fullcodeline": "DBUG_PRINT(\"repair\", (\"set enabled index #: %u\", sort_param.key));"
    },
    {
        "line": 263,
        "fullcodeline": "param->read_cache.file=info->dfile;\t\t/* re-init read cache */"
    },
    {
        "line": 264,
        "fullcodeline": "reinit_io_cache(&param->read_cache,READ_CACHE,share->pack.header_length,"
    },
    {
        "line": 270,
        "fullcodeline": "(void) fputs(\"          \\r\",stdout); (void) fflush(stdout);"
    },
    {
        "line": 275,
        "fullcodeline": "mi_check_print_error(param,\"Couldn't fix table with quick recovery: Found wrong number of deleted records\");"
    },
    {
        "line": 276,
        "fullcodeline": "mi_check_print_error(param,\"Run recovery again without -q\");"
    },
    {
        "line": 277,
        "fullcodeline": "got_error=1;"
    },
    {
        "line": 278,
        "fullcodeline": "param->retry_repair=1;"
    },
    {
        "line": 279,
        "fullcodeline": "param->testflag|=T_RETRY_WITHOUT_QUICK;"
    },
    {
        "line": 285,
        "fullcodeline": "my_off_t skr=info->state->data_file_length+"
    },
    {
        "line": 300,
        "fullcodeline": "info->state->checksum=param->glob_crc;"
    },
    {
        "line": 303,
        "fullcodeline": "mi_check_print_warning(param,"
    },
    {
        "line": 319,
        "fullcodeline": "memcpy( &share->state.state, info->state, sizeof(*info->state));"
    },
    {
        "line": 351,
        "fullcodeline": "mi_mark_crashed_on_repair(info);"
    },
    {
        "line": 366,
        "fullcodeline": "share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;"
    },
    {
        "line": 367,
        "fullcodeline": "share->pack.header_length=0;"
    },
    {
        "line": 40,
        "fullcodeline": "|| init_io_cache(&param->read_cache,info->dfile,"
    },
    {
        "line": 44,
        "fullcodeline": "init_io_cache(&info->rec_cache,info->dfile,"
    },
    {
        "line": 62,
        "fullcodeline": "if ((new_file= mysql_file_create(mi_key_file_datatmp,"
    },
    {
        "line": 73,
        "fullcodeline": "if (new_header_length &&"
    },
    {
        "line": 77,
        "fullcodeline": "if (param->testflag & T_UNPACK)"
    },
    {
        "line": 142,
        "fullcodeline": "if (! mi_is_key_active(key_map, sort_param.key))"
    },
    {
        "line": 154,
        "fullcodeline": "if ((!(param->testflag & T_SILENT)))"
    },
    {
        "line": 160,
        "fullcodeline": "for (i=0 ; keyseg[i].type != HA_KEYTYPE_END; i++)"
    },
    {
        "line": 173,
        "fullcodeline": "if (sort_param.keyinfo->flag & HA_FULLTEXT)"
    },
    {
        "line": 213,
        "fullcodeline": "if (_create_index_by_sort(&sort_param,"
    },
    {
        "line": 227,
        "fullcodeline": "if (param->testflag & T_STATISTICS)"
    },
    {
        "line": 293,
        "fullcodeline": "if (skr != sort_info.filelength)"
    },
    {
        "line": 309,
        "fullcodeline": "if (start_records != info->state->records)"
    },
    {
        "line": 327,
        "fullcodeline": "if (new_file >= 0)"
    },
    {
        "line": 340,
        "fullcodeline": "if (! param->error_printed)"
    },
    {
        "line": 342,
        "fullcodeline": "if (new_file >= 0)"
    },
    {
        "line": 41,
        "fullcodeline": "(uint) param->read_buffer_length,"
    },
    {
        "line": 42,
        "fullcodeline": "READ_CACHE,share->pack.header_length,1,MYF(MY_WME)) ||"
    },
    {
        "line": 45,
        "fullcodeline": "(uint) param->write_buffer_length,"
    },
    {
        "line": 47,
        "fullcodeline": "MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw)))"
    },
    {
        "line": 69,
        "fullcodeline": "mi_check_print_error(param,\"Can't create new tempfile: '%s'\","
    },
    {
        "line": 74,
        "fullcodeline": "filecopy(param, new_file,info->dfile,0L,new_header_length,"
    },
    {
        "line": 79,
        "fullcodeline": "share->options&= ~HA_OPTION_COMPRESS_RECORD;"
    },
    {
        "line": 80,
        "fullcodeline": "mi_int2store(share->state.header.options,share->options);"
    },
    {
        "line": 112,
        "fullcodeline": "else if (share->data_file_type == COMPRESSED_RECORD)"
    },
    {
        "line": 145,
        "fullcodeline": "memcpy((char*) rec_per_key_part,"
    },
    {
        "line": 149,
        "fullcodeline": "DBUG_PRINT(\"repair\", (\"skipping seemingly disabled index #: %u\","
    },
    {
        "line": 155,
        "fullcodeline": "printf (\"- Fixing index %d\\n\",sort_param.key+1);"
    },
    {
        "line": 162,
        "fullcodeline": "sort_param.key_length+=keyseg[i].length;"
    },
    {
        "line": 175,
        "fullcodeline": "uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*"
    },
    {
        "line": 177,
        "fullcodeline": "sort_param.key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;"
    },
    {
        "line": 204,
        "fullcodeline": "sort_param.key_read=sort_ft_key_read;"
    },
    {
        "line": 205,
        "fullcodeline": "sort_param.key_write=sort_ft_key_write;"
    },
    {
        "line": 214,
        "fullcodeline": "(my_bool) (!(param->testflag & T_VERBOSE)),"
    },
    {
        "line": 217,
        "fullcodeline": "param->retry_repair=1;"
    },
    {
        "line": 228,
        "fullcodeline": "update_key_parts(sort_param.keyinfo, rec_per_key_part, sort_param.unique,"
    },
    {
        "line": 238,
        "fullcodeline": "param->read_cache.end_of_file=sort_param.filepos;"
    },
    {
        "line": 250,
        "fullcodeline": "share->state.state.data_file_length = info->state->data_file_length="
    },
    {
        "line": 253,
        "fullcodeline": "share->state.version=(ulong) time((time_t*) 0);"
    },
    {
        "line": 254,
        "fullcodeline": "mysql_file_close(info->dfile, MYF(0));"
    },
    {
        "line": 255,
        "fullcodeline": "info->dfile=new_file;"
    },
    {
        "line": 256,
        "fullcodeline": "share->data_file_type=sort_info.new_data_file_type;"
    },
    {
        "line": 257,
        "fullcodeline": "share->pack.header_length=(ulong) new_header_length;"
    },
    {
        "line": 258,
        "fullcodeline": "sort_param.fix_datafile=0;"
    },
    {
        "line": 286,
        "fullcodeline": "(share->options & HA_OPTION_COMPRESS_RECORD ?"
    },
    {
        "line": 310,
        "fullcodeline": "printf(\"Data records: %s\\n\", llstr(info->state->records,llbuff));"
    },
    {
        "line": 312,
        "fullcodeline": "mi_check_print_warning(param,"
    },
    {
        "line": 329,
        "fullcodeline": "mysql_file_close(new_file, MYF(0));"
    },
    {
        "line": 330,
        "fullcodeline": "info->dfile=new_file= -1;"
    },
    {
        "line": 341,
        "fullcodeline": "mi_check_print_error(param,\"%d when fixing table\",my_errno);"
    },
    {
        "line": 344,
        "fullcodeline": "(void) mysql_file_close(new_file, MYF(0));"
    },
    {
        "line": 345,
        "fullcodeline": "(void) mysql_file_delete(mi_key_file_datatmp,"
    },
    {
        "line": 353,
        "fullcodeline": "else if (key_map == share->state.key_map)"
    },
    {
        "line": 37,
        "fullcodeline": "alloc_key_blocks(param,"
    },
    {
        "line": 113,
        "fullcodeline": "length=share->base.min_block_length;"
    },
    {
        "line": 146,
        "fullcodeline": "(char*) (share->state.rec_per_key_part +"
    },
    {
        "line": 148,
        "fullcodeline": "sort_param.keyinfo->keysegs*sizeof(*rec_per_key_part));"
    },
    {
        "line": 163,
        "fullcodeline": "if (keyseg[i].flag & HA_SPACE_PACK)"
    },
    {
        "line": 165,
        "fullcodeline": "if (keyseg[i].flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART))"
    },
    {
        "line": 167,
        "fullcodeline": "if (keyseg[i].flag & HA_NULL_PART)"
    },
    {
        "line": 182,
        "fullcodeline": "if (sort_param.keyinfo->parser == &ft_default_parser)"
    },
    {
        "line": 209,
        "fullcodeline": "sort_param.key_read=sort_key_read;"
    },
    {
        "line": 210,
        "fullcodeline": "sort_param.key_write=sort_key_write;"
    },
    {
        "line": 229,
        "fullcodeline": "param->stats_method == MI_STATS_METHOD_IGNORE_NULLS?"
    },
    {
        "line": 231,
        "fullcodeline": "(ulonglong) info->state->records);"
    },
    {
        "line": 239,
        "fullcodeline": "if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache))"
    },
    {
        "line": 241,
        "fullcodeline": "if (param->testflag & T_SAFE_REPAIR)"
    },
    {
        "line": 261,
        "fullcodeline": "info->state->data_file_length=sort_param.max_pos;"
    },
    {
        "line": 294,
        "fullcodeline": "if (mysql_file_chsize(info->dfile, skr, 0, MYF(0)))"
    },
    {
        "line": 314,
        "fullcodeline": "llstr(sort_info.dupp,llbuff));"
    },
    {
        "line": 331,
        "fullcodeline": "if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,"
    },
    {
        "line": 347,
        "fullcodeline": "if (info->dfile == new_file) /* Retry with key cache */"
    },
    {
        "line": 354,
        "fullcodeline": "share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS;"
    },
    {
        "line": 38,
        "fullcodeline": "(uint) param->sort_key_blocks,"
    },
    {
        "line": 63,
        "fullcodeline": "fn_format(param->temp_filename,"
    },
    {
        "line": 67,
        "fullcodeline": "MYF(0))) < 0)"
    },
    {
        "line": 115,
        "fullcodeline": "length=share->base.pack_reclength;"
    },
    {
        "line": 164,
        "fullcodeline": "sort_param.key_length+=get_pack_length(keyseg[i].length);"
    },
    {
        "line": 166,
        "fullcodeline": "sort_param.key_length+=2 + test(keyseg[i].length >= 127);"
    },
    {
        "line": 168,
        "fullcodeline": "sort_param.key_length++;"
    },
    {
        "line": 189,
        "fullcodeline": "sort_info.max_records="
    },
    {
        "line": 295,
        "fullcodeline": "mi_check_print_warning(param,"
    },
    {
        "line": 334,
        "fullcodeline": "mi_open_datafile(info,share,name,-1))"
    },
    {
        "line": 335,
        "fullcodeline": "got_error=1;"
    },
    {
        "line": 346,
        "fullcodeline": "param->temp_filename, MYF(MY_WME));"
    },
    {
        "line": 147,
        "fullcodeline": "(uint) (rec_per_key_part - param->rec_per_key_part)),"
    },
    {
        "line": 190,
        "fullcodeline": "(ha_rows) (sort_info.filelength/ft_min_word_len+1);"
    },
    {
        "line": 199,
        "fullcodeline": "sort_info.max_records= 10 *"
    },
    {
        "line": 244,
        "fullcodeline": "if (info->state->records+1 < start_records)"
    },
    {
        "line": 332,
        "fullcodeline": "(param->testflag & T_BACKUP_DATA ?"
    },
    {
        "line": 348,
        "fullcodeline": "if (unlikely(mi_open_datafile(info, share, name, -1)))"
    },
    {
        "line": 246,
        "fullcodeline": "info->state->records=start_records;"
    },
    {
        "line": 333,
        "fullcodeline": "MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||"
    },
    {
        "line": 349,
        "fullcodeline": "param->retry_repair= 0; /* Safety */"
    },
    {
        "line": 200,
        "fullcodeline": "max(param->sort_buffer_length, MIN_SORT_BUFFER) /"
    }
]