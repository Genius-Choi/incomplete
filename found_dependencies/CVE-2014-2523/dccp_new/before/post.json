[
    {
        "line": 4,
        "fullcodeline": "struct net *net = nf_ct_net(ct);"
    },
    {
        "line": 10,
        "fullcodeline": "dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);"
    },
    {
        "line": 11,
        "fullcodeline": "BUG_ON(dh == NULL);"
    },
    {
        "line": 28,
        "fullcodeline": "ct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;"
    },
    {
        "line": 29,
        "fullcodeline": "ct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;"
    },
    {
        "line": 30,
        "fullcodeline": "ct->proto.dccp.state = CT_DCCP_NONE;"
    },
    {
        "line": 31,
        "fullcodeline": "ct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;"
    },
    {
        "line": 32,
        "fullcodeline": "ct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;"
    },
    {
        "line": 33,
        "fullcodeline": "ct->proto.dccp.handshake_seq = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "if (LOG_INVALID(net, IPPROTO_DCCP))"
    },
    {
        "line": 16,
        "fullcodeline": "dn = dccp_pernet(net);"
    },
    {
        "line": 24,
        "fullcodeline": "msg = \"nf_ct_dccp: invalid state transition \";"
    },
    {
        "line": 38,
        "fullcodeline": "nf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,"
    },
    {
        "line": 17,
        "fullcodeline": "if (dn->dccp_loose == 0) {"
    },
    {
        "line": 18,
        "fullcodeline": "msg = \"nf_ct_dccp: not picking up existing connection \";"
    }
]