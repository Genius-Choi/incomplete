[
    {
        "line": 7,
        "fullcodeline": "unsigned char IV[16];"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned char iv_key[48];"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char buffer[64], buffer2[32];"
    },
    {
        "line": 13,
        "fullcodeline": "unsigned char ipad[64], opad[64];"
    },
    {
        "line": 14,
        "fullcodeline": "int reached_eof = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "memset(digest, 0, 32);"
    },
    {
        "line": 112,
        "fullcodeline": "memcpy(digest, IV, 16);"
    },
    {
        "line": 122,
        "fullcodeline": "aes_set_key(&aes_ctx, digest, 256);"
    },
    {
        "line": 128,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 129,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 137,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 138,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 292,
        "fullcodeline": "head = buffer + 48;"
    },
    {
        "line": 293,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 398,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 399,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 400,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 401,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 402,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 17,
        "fullcodeline": "if ((bytes_read = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !="
    },
    {
        "line": 31,
        "fullcodeline": "if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&"
    },
    {
        "line": 44,
        "fullcodeline": "if (aeshdr.version == 0)"
    },
    {
        "line": 60,
        "fullcodeline": "if (aeshdr.version >= 0x02)"
    },
    {
        "line": 97,
        "fullcodeline": "if ((bytes_read = fread(IV, 1, 16, infp)) != 16)"
    },
    {
        "line": 113,
        "fullcodeline": "for (i = 0; i < 8192; i++)"
    },
    {
        "line": 131,
        "fullcodeline": "for (i = 0; i < 32; i++)"
    },
    {
        "line": 143,
        "fullcodeline": "if (aeshdr.version >= 0x01)"
    },
    {
        "line": 243,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 48, infp)) < 48)"
    },
    {
        "line": 295,
        "fullcodeline": "while(!reached_eof)"
    },
    {
        "line": 405,
        "fullcodeline": "if (aeshdr.version == 0x00)"
    },
    {
        "line": 432,
        "fullcodeline": "if (memcmp(digest, buffer2, 32))"
    },
    {
        "line": 451,
        "fullcodeline": "if (fflush(outfp))"
    },
    {
        "line": 34,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 50,
        "fullcodeline": "aeshdr.last_block_size = (aeshdr.last_block_size & 0x0F);"
    },
    {
        "line": 115,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 116,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 117,
        "fullcodeline": "sha256_update(&sha_ctx, passwd, passlen);"
    },
    {
        "line": 118,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 133,
        "fullcodeline": "ipad[i] ^= digest[i];"
    },
    {
        "line": 134,
        "fullcodeline": "opad[i] ^= digest[i];"
    },
    {
        "line": 179,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 180,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 181,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 182,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 183,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 211,
        "fullcodeline": "memcpy(IV, iv_key, 16);"
    },
    {
        "line": 214,
        "fullcodeline": "aes_set_key(&aes_ctx, iv_key+16, 256);"
    },
    {
        "line": 221,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 222,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 231,
        "fullcodeline": "memset_secure(iv_key, 0, 48);"
    },
    {
        "line": 233,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 234,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 407,
        "fullcodeline": "memcpy(buffer2, tail, 16);"
    },
    {
        "line": 408,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 413,
        "fullcodeline": "memcpy(buffer2+16, tail, 16);"
    },
    {
        "line": 453,
        "fullcodeline": "fprintf(stderr, \"Error: Could not flush output file buffer\\n\");"
    },
    {
        "line": 20,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 28,
        "fullcodeline": "return -1;"
    },
    {
        "line": 32,
        "fullcodeline": "aeshdr.aes[2] == 'S'))"
    },
    {
        "line": 40,
        "fullcodeline": "return -1;"
    },
    {
        "line": 99,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 107,
        "fullcodeline": "return -1;"
    },
    {
        "line": 145,
        "fullcodeline": "for (i = 0; i < 48; i += 16)"
    },
    {
        "line": 185,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 32, infp)) != 32)"
    },
    {
        "line": 198,
        "fullcodeline": "if (memcmp(digest, buffer, 32))"
    },
    {
        "line": 224,
        "fullcodeline": "for (i = 0; i < 32; i++)"
    },
    {
        "line": 245,
        "fullcodeline": "if (!feof(infp))"
    },
    {
        "line": 298,
        "fullcodeline": "if (head == (buffer + 64))"
    },
    {
        "line": 303,
        "fullcodeline": "if ((bytes_read = fread(head, 1, 16, infp)) < 16)"
    },
    {
        "line": 349,
        "fullcodeline": "if ((bytes_read > 0) || (aeshdr.version == 0x00))"
    },
    {
        "line": 409,
        "fullcodeline": "if (tail == (buffer + 64))"
    },
    {
        "line": 417,
        "fullcodeline": "memcpy(buffer2, tail+1, 15);"
    },
    {
        "line": 418,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 423,
        "fullcodeline": "memcpy(buffer2+15, tail, 16);"
    },
    {
        "line": 424,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 429,
        "fullcodeline": "memcpy(buffer2+31, tail, 1);"
    },
    {
        "line": 434,
        "fullcodeline": "if (aeshdr.version == 0x00)"
    },
    {
        "line": 447,
        "fullcodeline": "return -1;"
    },
    {
        "line": 454,
        "fullcodeline": "return -1;"
    },
    {
        "line": 22,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short\\n\");"
    },
    {
        "line": 52,
        "fullcodeline": "else if (aeshdr.version > 0x02)"
    },
    {
        "line": 77,
        "fullcodeline": "i = j = (((int)buffer[0]) << 8) | (int)buffer[1];"
    },
    {
        "line": 101,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short\\n\");"
    },
    {
        "line": 160,
        "fullcodeline": "memcpy(buffer2, buffer, 16);"
    },
    {
        "line": 162,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 16);"
    },
    {
        "line": 163,
        "fullcodeline": "aes_decrypt(&aes_ctx, buffer, buffer);"
    },
    {
        "line": 175,
        "fullcodeline": "memcpy(IV, buffer2, 16);"
    },
    {
        "line": 200,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 226,
        "fullcodeline": "ipad[i] ^= iv_key[i + 16];"
    },
    {
        "line": 227,
        "fullcodeline": "opad[i] ^= iv_key[i + 16];"
    },
    {
        "line": 247,
        "fullcodeline": "perror(\"Error reading input file ring:\");"
    },
    {
        "line": 300,
        "fullcodeline": "head = buffer;"
    },
    {
        "line": 357,
        "fullcodeline": "memcpy(buffer2, tail, 16);"
    },
    {
        "line": 359,
        "fullcodeline": "sha256_update(&sha_ctx, tail, 16);"
    },
    {
        "line": 360,
        "fullcodeline": "aes_decrypt(&aes_ctx, tail, tail);"
    },
    {
        "line": 372,
        "fullcodeline": "memcpy(IV, buffer2, 16);"
    },
    {
        "line": 378,
        "fullcodeline": "n = ((!reached_eof) ||"
    },
    {
        "line": 389,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 411,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 419,
        "fullcodeline": "if (tail == (buffer + 64))"
    },
    {
        "line": 425,
        "fullcodeline": "if (tail == (buffer + 64))"
    },
    {
        "line": 436,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 26,
        "fullcodeline": "perror(\"Error reading the file header:\");"
    },
    {
        "line": 54,
        "fullcodeline": "fprintf(stderr, \"Error: Unsupported AES file version: %d\\n\","
    },
    {
        "line": 64,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 2, infp)) != 2)"
    },
    {
        "line": 78,
        "fullcodeline": "while (i--)"
    },
    {
        "line": 105,
        "fullcodeline": "perror(\"Error reading the initialization vector:\");"
    },
    {
        "line": 147,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 16, infp)) != 16)"
    },
    {
        "line": 169,
        "fullcodeline": "for (j = 0; j < 16; j++)"
    },
    {
        "line": 187,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 195,
        "fullcodeline": "return -1;"
    },
    {
        "line": 203,
        "fullcodeline": "return -1;"
    },
    {
        "line": 248,
        "fullcodeline": "return -1;"
    },
    {
        "line": 289,
        "fullcodeline": "reached_eof = 1;"
    },
    {
        "line": 305,
        "fullcodeline": "if (!feof(infp))"
    },
    {
        "line": 352,
        "fullcodeline": "if (bytes_read > 0)"
    },
    {
        "line": 366,
        "fullcodeline": "for (i = 0; i < 16; i++)"
    },
    {
        "line": 382,
        "fullcodeline": "if ((i = fwrite(tail, 1, n, outfp)) != n)"
    },
    {
        "line": 390,
        "fullcodeline": "if (tail == (buffer+64))"
    },
    {
        "line": 421,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 427,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 442,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 56,
        "fullcodeline": "return -1;"
    },
    {
        "line": 171,
        "fullcodeline": "iv_key[i + j] = (buffer[j] ^ IV[j]);"
    },
    {
        "line": 189,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short\\n\");"
    },
    {
        "line": 257,
        "fullcodeline": "if ((aeshdr.version == 0x00 && bytes_read != 32) ||"
    },
    {
        "line": 307,
        "fullcodeline": "perror(\"Error reading input file:\");"
    },
    {
        "line": 354,
        "fullcodeline": "head += 16;"
    },
    {
        "line": 368,
        "fullcodeline": "tail[i] ^= IV[i];"
    },
    {
        "line": 384,
        "fullcodeline": "perror(\"Error writing decrypted block:\");"
    },
    {
        "line": 392,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 66,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 74,
        "fullcodeline": "return -1;"
    },
    {
        "line": 80,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 1, infp)) != 1)"
    },
    {
        "line": 149,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 157,
        "fullcodeline": "return -1;"
    },
    {
        "line": 193,
        "fullcodeline": "perror(\"Error reading input file digest:\");"
    },
    {
        "line": 258,
        "fullcodeline": "(aeshdr.version >= 0x01 && bytes_read != 33))"
    },
    {
        "line": 260,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is corrupt (1:%u)\\n\","
    },
    {
        "line": 308,
        "fullcodeline": "return -1;"
    },
    {
        "line": 340,
        "fullcodeline": "reached_eof = 1;"
    },
    {
        "line": 379,
        "fullcodeline": "(aeshdr.last_block_size == 0)) ? 16 : aeshdr.last_block_size;"
    },
    {
        "line": 385,
        "fullcodeline": "return -1;"
    },
    {
        "line": 68,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short\\n\");"
    },
    {
        "line": 151,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short\\n\");"
    },
    {
        "line": 261,
        "fullcodeline": "(unsigned) bytes_read);"
    },
    {
        "line": 262,
        "fullcodeline": "return -1;"
    },
    {
        "line": 313,
        "fullcodeline": "if ((aeshdr.version == 0x00 && bytes_read > 0) ||"
    },
    {
        "line": 327,
        "fullcodeline": "if (aeshdr.version >= 0x01)"
    },
    {
        "line": 72,
        "fullcodeline": "perror(\"Error reading the file extensions:\");"
    },
    {
        "line": 82,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 90,
        "fullcodeline": "return -1;"
    },
    {
        "line": 155,
        "fullcodeline": "perror(\"Error reading input file IV and key:\");"
    },
    {
        "line": 271,
        "fullcodeline": "if (aeshdr.version >= 0x01)"
    },
    {
        "line": 283,
        "fullcodeline": "if (aeshdr.last_block_size != 0)"
    },
    {
        "line": 314,
        "fullcodeline": "(aeshdr.version >= 0x01 && bytes_read != 1))"
    },
    {
        "line": 316,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is corrupt (3:%u)\\n\","
    },
    {
        "line": 84,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short\\n\");"
    },
    {
        "line": 277,
        "fullcodeline": "aeshdr.last_block_size = (buffer[0] & 0x0F);"
    },
    {
        "line": 285,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is corrupt (2)\\n\");"
    },
    {
        "line": 317,
        "fullcodeline": "(unsigned) bytes_read);"
    },
    {
        "line": 318,
        "fullcodeline": "return -1;"
    },
    {
        "line": 329,
        "fullcodeline": "if ((tail + 16) < (buffer + 64))"
    },
    {
        "line": 88,
        "fullcodeline": "perror(\"Error reading the file extensions:\");"
    },
    {
        "line": 286,
        "fullcodeline": "return -1;"
    },
    {
        "line": 331,
        "fullcodeline": "aeshdr.last_block_size = (tail[16] & 0x0F);"
    },
    {
        "line": 335,
        "fullcodeline": "aeshdr.last_block_size = (buffer[0] & 0x0F);"
    }
]