[
    {
        "line": 7,
        "fullcodeline": "unsigned char IV[16];"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned char iv_key[48];"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char buffer[64], buffer2[32];"
    },
    {
        "line": 13,
        "fullcodeline": "unsigned char ipad[64], opad[64];"
    },
    {
        "line": 14,
        "fullcodeline": "int reached_eof = 0;"
    },
    {
        "line": 106,
        "fullcodeline": "memset(digest, 0, 32);"
    },
    {
        "line": 107,
        "fullcodeline": "memcpy(digest, IV, 16);"
    },
    {
        "line": 120,
        "fullcodeline": "aes_set_key(&aes_ctx, digest, 256);"
    },
    {
        "line": 126,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 127,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 135,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 136,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 288,
        "fullcodeline": "head = buffer + 48;"
    },
    {
        "line": 289,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 394,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 395,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 396,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 397,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 398,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 17,
        "fullcodeline": "if ((bytes_read = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !="
    },
    {
        "line": 31,
        "fullcodeline": "if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&"
    },
    {
        "line": 39,
        "fullcodeline": "if (aeshdr.version == 0)"
    },
    {
        "line": 55,
        "fullcodeline": "if (aeshdr.version >= 0x02)"
    },
    {
        "line": 92,
        "fullcodeline": "if ((bytes_read = fread(IV, 1, 16, infp)) != 16)"
    },
    {
        "line": 108,
        "fullcodeline": "for(i=0; i<8192; i++)"
    },
    {
        "line": 129,
        "fullcodeline": "for(i=0; i<32; i++)"
    },
    {
        "line": 141,
        "fullcodeline": "if (aeshdr.version >= 0x01)"
    },
    {
        "line": 239,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 48, infp)) < 48)"
    },
    {
        "line": 291,
        "fullcodeline": "while(!reached_eof)"
    },
    {
        "line": 401,
        "fullcodeline": "if (aeshdr.version == 0x00)"
    },
    {
        "line": 428,
        "fullcodeline": "if (memcmp(digest, buffer2, 32))"
    },
    {
        "line": 443,
        "fullcodeline": "if (fflush(outfp))"
    },
    {
        "line": 34,
        "fullcodeline": "fprintf(stderr, \"Error: Bad file header (not aescrypt file or is corrupted? [%x, %x, %x])\\n\", aeshdr.aes[0], aeshdr.aes[1], aeshdr.aes[2]);"
    },
    {
        "line": 45,
        "fullcodeline": "aeshdr.last_block_size = (aeshdr.last_block_size & 0x0F);"
    },
    {
        "line": 110,
        "fullcodeline": "sha256_starts(  &sha_ctx);"
    },
    {
        "line": 111,
        "fullcodeline": "sha256_update(  &sha_ctx, digest, 32);"
    },
    {
        "line": 112,
        "fullcodeline": "sha256_update(  &sha_ctx,"
    },
    {
        "line": 115,
        "fullcodeline": "sha256_finish(  &sha_ctx,"
    },
    {
        "line": 131,
        "fullcodeline": "ipad[i] ^= digest[i];"
    },
    {
        "line": 132,
        "fullcodeline": "opad[i] ^= digest[i];"
    },
    {
        "line": 177,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 178,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 179,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 180,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 181,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 207,
        "fullcodeline": "memcpy(IV, iv_key, 16);"
    },
    {
        "line": 210,
        "fullcodeline": "aes_set_key(&aes_ctx, iv_key+16, 256);"
    },
    {
        "line": 217,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 218,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 227,
        "fullcodeline": "memset_secure(iv_key, 0, 48);"
    },
    {
        "line": 229,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 230,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 403,
        "fullcodeline": "memcpy(buffer2, tail, 16);"
    },
    {
        "line": 404,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 409,
        "fullcodeline": "memcpy(buffer2+16, tail, 16);"
    },
    {
        "line": 445,
        "fullcodeline": "fprintf(stderr, \"Error: Could not flush output file buffer\\n\");"
    },
    {
        "line": 20,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 28,
        "fullcodeline": "return -1;"
    },
    {
        "line": 32,
        "fullcodeline": "aeshdr.aes[2] == 'S'))"
    },
    {
        "line": 35,
        "fullcodeline": "return -1;"
    },
    {
        "line": 94,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 102,
        "fullcodeline": "return -1;"
    },
    {
        "line": 143,
        "fullcodeline": "for(i=0; i<48; i+=16)"
    },
    {
        "line": 183,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 32, infp)) != 32)"
    },
    {
        "line": 196,
        "fullcodeline": "if (memcmp(digest, buffer, 32))"
    },
    {
        "line": 220,
        "fullcodeline": "for(i=0; i<32; i++)"
    },
    {
        "line": 241,
        "fullcodeline": "if (!feof(infp))"
    },
    {
        "line": 294,
        "fullcodeline": "if (head == (buffer + 64))"
    },
    {
        "line": 299,
        "fullcodeline": "if ((bytes_read = fread(head, 1, 16, infp)) < 16)"
    },
    {
        "line": 345,
        "fullcodeline": "if ((bytes_read > 0) || (aeshdr.version == 0x00))"
    },
    {
        "line": 405,
        "fullcodeline": "if (tail == (buffer + 64))"
    },
    {
        "line": 413,
        "fullcodeline": "memcpy(buffer2, tail+1, 15);"
    },
    {
        "line": 414,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 419,
        "fullcodeline": "memcpy(buffer2+15, tail, 16);"
    },
    {
        "line": 420,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 425,
        "fullcodeline": "memcpy(buffer2+31, tail, 1);"
    },
    {
        "line": 430,
        "fullcodeline": "if (aeshdr.version == 0x00)"
    },
    {
        "line": 439,
        "fullcodeline": "return -1;"
    },
    {
        "line": 446,
        "fullcodeline": "return -1;"
    },
    {
        "line": 22,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short.\\n\");"
    },
    {
        "line": 47,
        "fullcodeline": "else if (aeshdr.version > 0x02)"
    },
    {
        "line": 72,
        "fullcodeline": "i = j = (((int)buffer[0]) << 8) | (int)buffer[1];"
    },
    {
        "line": 96,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short.\\n\");"
    },
    {
        "line": 158,
        "fullcodeline": "memcpy(buffer2, buffer, 16);"
    },
    {
        "line": 160,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 16);"
    },
    {
        "line": 161,
        "fullcodeline": "aes_decrypt(&aes_ctx, buffer, buffer);"
    },
    {
        "line": 173,
        "fullcodeline": "memcpy(IV, buffer2, 16);"
    },
    {
        "line": 198,
        "fullcodeline": "fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");"
    },
    {
        "line": 222,
        "fullcodeline": "ipad[i] ^= iv_key[i+16];"
    },
    {
        "line": 223,
        "fullcodeline": "opad[i] ^= iv_key[i+16];"
    },
    {
        "line": 243,
        "fullcodeline": "perror(\"Error reading input file ring:\");"
    },
    {
        "line": 296,
        "fullcodeline": "head = buffer;"
    },
    {
        "line": 353,
        "fullcodeline": "memcpy(buffer2, tail, 16);"
    },
    {
        "line": 355,
        "fullcodeline": "sha256_update(&sha_ctx, tail, 16);"
    },
    {
        "line": 356,
        "fullcodeline": "aes_decrypt(&aes_ctx, tail, tail);"
    },
    {
        "line": 368,
        "fullcodeline": "memcpy(IV, buffer2, 16);"
    },
    {
        "line": 374,
        "fullcodeline": "n = ((!reached_eof) ||"
    },
    {
        "line": 385,
        "fullcodeline": "tail += 16;"
    },
    {
        "line": 407,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 415,
        "fullcodeline": "if (tail == (buffer + 64))"
    },
    {
        "line": 421,
        "fullcodeline": "if (tail == (buffer + 64))"
    },
    {
        "line": 432,
        "fullcodeline": "fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");"
    },
    {
        "line": 26,
        "fullcodeline": "perror(\"Error reading the file header:\");"
    },
    {
        "line": 49,
        "fullcodeline": "fprintf(stderr, \"Error: Unsupported AES file version: %d\\n\","
    },
    {
        "line": 59,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 2, infp)) != 2)"
    },
    {
        "line": 73,
        "fullcodeline": "while (i--)"
    },
    {
        "line": 100,
        "fullcodeline": "perror(\"Error reading the initialization vector:\");"
    },
    {
        "line": 145,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 16, infp)) != 16)"
    },
    {
        "line": 167,
        "fullcodeline": "for(j=0; j<16; j++)"
    },
    {
        "line": 185,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 193,
        "fullcodeline": "return -1;"
    },
    {
        "line": 199,
        "fullcodeline": "return -1;"
    },
    {
        "line": 244,
        "fullcodeline": "return -1;"
    },
    {
        "line": 285,
        "fullcodeline": "reached_eof = 1;"
    },
    {
        "line": 301,
        "fullcodeline": "if (!feof(infp))"
    },
    {
        "line": 348,
        "fullcodeline": "if (bytes_read > 0)"
    },
    {
        "line": 362,
        "fullcodeline": "for(i=0; i<16; i++)"
    },
    {
        "line": 378,
        "fullcodeline": "if ((i = fwrite(tail, 1, n, outfp)) != n)"
    },
    {
        "line": 386,
        "fullcodeline": "if (tail == (buffer+64))"
    },
    {
        "line": 417,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 423,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 436,
        "fullcodeline": "fprintf(stderr, \"Error: Message has been altered and should not be trusted\\n\");"
    },
    {
        "line": 51,
        "fullcodeline": "return -1;"
    },
    {
        "line": 169,
        "fullcodeline": "iv_key[i+j] = (buffer[j] ^ IV[j]);"
    },
    {
        "line": 187,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short.\\n\");"
    },
    {
        "line": 253,
        "fullcodeline": "if ((aeshdr.version == 0x00 && bytes_read != 32) ||"
    },
    {
        "line": 303,
        "fullcodeline": "perror(\"Error reading input file:\");"
    },
    {
        "line": 350,
        "fullcodeline": "head += 16;"
    },
    {
        "line": 364,
        "fullcodeline": "tail[i] ^= IV[i];"
    },
    {
        "line": 380,
        "fullcodeline": "perror(\"Error writing decrypted block:\");"
    },
    {
        "line": 388,
        "fullcodeline": "tail = buffer;"
    },
    {
        "line": 61,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 69,
        "fullcodeline": "return -1;"
    },
    {
        "line": 75,
        "fullcodeline": "if ((bytes_read = fread(buffer, 1, 1, infp)) != 1)"
    },
    {
        "line": 147,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 155,
        "fullcodeline": "return -1;"
    },
    {
        "line": 191,
        "fullcodeline": "perror(\"Error reading input file digest:\");"
    },
    {
        "line": 254,
        "fullcodeline": "(aeshdr.version >= 0x01 && bytes_read != 33))"
    },
    {
        "line": 256,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is corrupt (1:%u).\\n\","
    },
    {
        "line": 304,
        "fullcodeline": "return -1;"
    },
    {
        "line": 336,
        "fullcodeline": "reached_eof = 1;"
    },
    {
        "line": 375,
        "fullcodeline": "(aeshdr.last_block_size == 0)) ? 16 : aeshdr.last_block_size;"
    },
    {
        "line": 381,
        "fullcodeline": "return -1;"
    },
    {
        "line": 63,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short.\\n\");"
    },
    {
        "line": 149,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short.\\n\");"
    },
    {
        "line": 257,
        "fullcodeline": "(unsigned) bytes_read);"
    },
    {
        "line": 258,
        "fullcodeline": "return -1;"
    },
    {
        "line": 309,
        "fullcodeline": "if ((aeshdr.version == 0x00 && bytes_read > 0) ||"
    },
    {
        "line": 323,
        "fullcodeline": "if (aeshdr.version >= 0x01)"
    },
    {
        "line": 67,
        "fullcodeline": "perror(\"Error reading the file extensions:\");"
    },
    {
        "line": 77,
        "fullcodeline": "if (feof(infp))"
    },
    {
        "line": 85,
        "fullcodeline": "return -1;"
    },
    {
        "line": 153,
        "fullcodeline": "perror(\"Error reading input file IV and key:\");"
    },
    {
        "line": 267,
        "fullcodeline": "if (aeshdr.version >= 0x01)"
    },
    {
        "line": 279,
        "fullcodeline": "if (aeshdr.last_block_size != 0)"
    },
    {
        "line": 310,
        "fullcodeline": "(aeshdr.version >= 0x01 && bytes_read != 1))"
    },
    {
        "line": 312,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is corrupt (3:%u).\\n\","
    },
    {
        "line": 79,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is too short.\\n\");"
    },
    {
        "line": 273,
        "fullcodeline": "aeshdr.last_block_size = (buffer[0] & 0x0F);"
    },
    {
        "line": 281,
        "fullcodeline": "fprintf(stderr, \"Error: Input file is corrupt (2).\\n\");"
    },
    {
        "line": 313,
        "fullcodeline": "(unsigned) bytes_read);"
    },
    {
        "line": 314,
        "fullcodeline": "return -1;"
    },
    {
        "line": 325,
        "fullcodeline": "if ((tail + 16) < (buffer + 64))"
    },
    {
        "line": 83,
        "fullcodeline": "perror(\"Error reading the file extensions:\");"
    },
    {
        "line": 282,
        "fullcodeline": "return -1;"
    },
    {
        "line": 327,
        "fullcodeline": "aeshdr.last_block_size = (tail[16] & 0x0F);"
    },
    {
        "line": 331,
        "fullcodeline": "aeshdr.last_block_size = (buffer[0] & 0x0F);"
    }
]