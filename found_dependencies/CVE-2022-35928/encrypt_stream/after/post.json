[
    {
        "line": 7,
        "fullcodeline": "unsigned char IV[16];"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned char iv_key[48];"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char buffer[32];"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned char ipad[64], opad[64];"
    },
    {
        "line": 16,
        "fullcodeline": "unsigned char tag_buffer[256];"
    },
    {
        "line": 39,
        "fullcodeline": "memset(iv_key, 0, 48);"
    },
    {
        "line": 63,
        "fullcodeline": "buffer[0] = 'A';"
    },
    {
        "line": 64,
        "fullcodeline": "buffer[1] = 'E';"
    },
    {
        "line": 65,
        "fullcodeline": "buffer[2] = 'S';"
    },
    {
        "line": 66,
        "fullcodeline": "buffer[3] = (unsigned char) 0x02;   /* Version 2 */"
    },
    {
        "line": 67,
        "fullcodeline": "buffer[4] = '\\0';                   /* Reserved for version 0 */"
    },
    {
        "line": 76,
        "fullcodeline": "j = 11 +                      /* \"CREATED-BY\\0\" */"
    },
    {
        "line": 116,
        "fullcodeline": "buffer[0] = '\\0';"
    },
    {
        "line": 117,
        "fullcodeline": "buffer[1] = (unsigned char) 128;"
    },
    {
        "line": 124,
        "fullcodeline": "memset(tag_buffer, 0, 128);"
    },
    {
        "line": 133,
        "fullcodeline": "buffer[0] = '\\0';"
    },
    {
        "line": 134,
        "fullcodeline": "buffer[1] = '\\0';"
    },
    {
        "line": 146,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 147,
        "fullcodeline": "current_time = time(NULL);"
    },
    {
        "line": 148,
        "fullcodeline": "sha256_update(&sha_ctx, (unsigned char *) &time, sizeof(current_time));"
    },
    {
        "line": 149,
        "fullcodeline": "process_id = getpid();"
    },
    {
        "line": 150,
        "fullcodeline": "sha256_update(&sha_ctx, (unsigned char *) &process_id, sizeof(process_id));"
    },
    {
        "line": 163,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 165,
        "fullcodeline": "memcpy(IV, digest, 16);"
    },
    {
        "line": 168,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 178,
        "fullcodeline": "memset(digest, 0, 32);"
    },
    {
        "line": 179,
        "fullcodeline": "memcpy(digest, IV, 16);"
    },
    {
        "line": 189,
        "fullcodeline": "aes_set_key(&aes_ctx, digest, 256);"
    },
    {
        "line": 196,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 197,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 205,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 206,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 247,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 248,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 249,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 250,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 251,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 263,
        "fullcodeline": "memcpy(IV, iv_key, 16);"
    },
    {
        "line": 266,
        "fullcodeline": "aes_set_key(&aes_ctx, iv_key+16, 256);"
    },
    {
        "line": 273,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 274,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 283,
        "fullcodeline": "memset_secure(iv_key, 0, 48);"
    },
    {
        "line": 285,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 286,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 289,
        "fullcodeline": "aeshdr.last_block_size = 0;"
    },
    {
        "line": 330,
        "fullcodeline": "buffer[0] = (char) (aeshdr.last_block_size & 0x0F);"
    },
    {
        "line": 338,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 339,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 340,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 341,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 342,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 24,
        "fullcodeline": "if ((aesrand = aesrandom_open()) == NULL)"
    },
    {
        "line": 40,
        "fullcodeline": "for (i = 0; i < 48; i += 16)"
    },
    {
        "line": 68,
        "fullcodeline": "if (fwrite(buffer, 1, 5, outfp) != 5)"
    },
    {
        "line": 85,
        "fullcodeline": "if (j < 256)"
    },
    {
        "line": 118,
        "fullcodeline": "if (fwrite(buffer, 1, 2, outfp) != 2)"
    },
    {
        "line": 125,
        "fullcodeline": "if (fwrite(tag_buffer, 1, 128, outfp) != 128)"
    },
    {
        "line": 135,
        "fullcodeline": "if (fwrite(buffer, 1, 2, outfp) != 2)"
    },
    {
        "line": 152,
        "fullcodeline": "for (i=0; i<256; i++)"
    },
    {
        "line": 171,
        "fullcodeline": "if (fwrite(IV, 1, 16, outfp) != 16)"
    },
    {
        "line": 180,
        "fullcodeline": "for (i = 0; i < 8192; i++)"
    },
    {
        "line": 199,
        "fullcodeline": "for (i = 0; i < 32; i++)"
    },
    {
        "line": 212,
        "fullcodeline": "for (i = 0; i < 48; i += 16)"
    },
    {
        "line": 253,
        "fullcodeline": "if (fwrite(digest, 1, 32, outfp) != 32)"
    },
    {
        "line": 276,
        "fullcodeline": "for (i = 0; i < 32; i++)"
    },
    {
        "line": 291,
        "fullcodeline": "while ((bytes_read = fread(buffer, 1, 16, infp)) > 0)"
    },
    {
        "line": 323,
        "fullcodeline": "if (ferror(infp))"
    },
    {
        "line": 331,
        "fullcodeline": "if (fwrite(buffer, 1, 1, outfp) != 1)"
    },
    {
        "line": 343,
        "fullcodeline": "if (fwrite(digest, 1, 32, outfp) != 32)"
    },
    {
        "line": 350,
        "fullcodeline": "if (fflush(outfp))"
    },
    {
        "line": 26,
        "fullcodeline": "perror(\"Error open random:\");"
    },
    {
        "line": 42,
        "fullcodeline": "memset(buffer, 0, 32);"
    },
    {
        "line": 43,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 55,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 56,
        "fullcodeline": "memcpy(iv_key + i, digest, 16);"
    },
    {
        "line": 70,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write out header data\\n\");"
    },
    {
        "line": 71,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 79,
        "fullcodeline": "strlen(PACKAGE_VERSION);  /* Program version ID */"
    },
    {
        "line": 87,
        "fullcodeline": "buffer[0] = '\\0';"
    },
    {
        "line": 88,
        "fullcodeline": "buffer[1] = (unsigned char) (j & 0xff);"
    },
    {
        "line": 96,
        "fullcodeline": "strncpy((char *)tag_buffer, \"CREATED_BY\", 255);"
    },
    {
        "line": 97,
        "fullcodeline": "tag_buffer[255] = '\\0';"
    },
    {
        "line": 105,
        "fullcodeline": "sprintf((char *)tag_buffer, \"%s %s\", PACKAGE_NAME, PACKAGE_VERSION);"
    },
    {
        "line": 106,
        "fullcodeline": "j = strlen((char *)tag_buffer);"
    },
    {
        "line": 120,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (4)\\n\");"
    },
    {
        "line": 121,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 127,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (5)\\n\");"
    },
    {
        "line": 128,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 137,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (6)\\n\");"
    },
    {
        "line": 138,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 160,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 32);"
    },
    {
        "line": 173,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write out initialization vector\\n\");"
    },
    {
        "line": 182,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 183,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 184,
        "fullcodeline": "sha256_update(&sha_ctx, passwd, (unsigned long) passlen);"
    },
    {
        "line": 185,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 201,
        "fullcodeline": "ipad[i] ^= digest[i];"
    },
    {
        "line": 202,
        "fullcodeline": "opad[i] ^= digest[i];"
    },
    {
        "line": 218,
        "fullcodeline": "memcpy(buffer, iv_key+i, 16);"
    },
    {
        "line": 230,
        "fullcodeline": "aes_encrypt(&aes_ctx, buffer, buffer);"
    },
    {
        "line": 233,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 16);"
    },
    {
        "line": 243,
        "fullcodeline": "memcpy(IV, buffer, 16);"
    },
    {
        "line": 255,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write iv_key HMAC\\n\");"
    },
    {
        "line": 278,
        "fullcodeline": "ipad[i] ^= iv_key[i+16];"
    },
    {
        "line": 279,
        "fullcodeline": "opad[i] ^= iv_key[i+16];"
    },
    {
        "line": 303,
        "fullcodeline": "aes_encrypt(&aes_ctx, buffer, buffer);"
    },
    {
        "line": 306,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 16);"
    },
    {
        "line": 316,
        "fullcodeline": "memcpy(IV, buffer, 16);"
    },
    {
        "line": 319,
        "fullcodeline": "aeshdr.last_block_size = bytes_read;"
    },
    {
        "line": 325,
        "fullcodeline": "fprintf(stderr, \"Error: Couldn't read input file\\n\");"
    },
    {
        "line": 333,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write the file size modulo\\n\");"
    },
    {
        "line": 345,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write the file HMAC\\n\");"
    },
    {
        "line": 352,
        "fullcodeline": "fprintf(stderr, \"Error: Could not flush output file buffer\\n\");"
    },
    {
        "line": 27,
        "fullcodeline": "return -1;"
    },
    {
        "line": 44,
        "fullcodeline": "for (j = 0; j < 256; j++)"
    },
    {
        "line": 72,
        "fullcodeline": "return -1;"
    },
    {
        "line": 89,
        "fullcodeline": "if (fwrite(buffer, 1, 2, outfp) != 2)"
    },
    {
        "line": 98,
        "fullcodeline": "if (fwrite(tag_buffer, 1, 11, outfp) != 11)"
    },
    {
        "line": 107,
        "fullcodeline": "if (fwrite(tag_buffer, 1, j, outfp) != j)"
    },
    {
        "line": 122,
        "fullcodeline": "return -1;"
    },
    {
        "line": 129,
        "fullcodeline": "return -1;"
    },
    {
        "line": 139,
        "fullcodeline": "return -1;"
    },
    {
        "line": 154,
        "fullcodeline": "if (aesrandom_read(aesrand, buffer, 32) != 32)"
    },
    {
        "line": 174,
        "fullcodeline": "return -1;"
    },
    {
        "line": 224,
        "fullcodeline": "for (j = 0; j < 16; j++)"
    },
    {
        "line": 236,
        "fullcodeline": "if (fwrite(buffer, 1, 16, outfp) != 16)"
    },
    {
        "line": 256,
        "fullcodeline": "return -1;"
    },
    {
        "line": 297,
        "fullcodeline": "for (i = 0; i < 16; i++)"
    },
    {
        "line": 309,
        "fullcodeline": "if (fwrite(buffer, 1, 16, outfp) != 16)"
    },
    {
        "line": 326,
        "fullcodeline": "return -1;"
    },
    {
        "line": 334,
        "fullcodeline": "return -1;"
    },
    {
        "line": 346,
        "fullcodeline": "return -1;"
    },
    {
        "line": 353,
        "fullcodeline": "return -1;"
    },
    {
        "line": 53,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 32);"
    },
    {
        "line": 77,
        "fullcodeline": "strlen(PACKAGE_NAME) +    /* Program name */"
    },
    {
        "line": 91,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (1)\\n\");"
    },
    {
        "line": 92,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 100,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (2)\\n\");"
    },
    {
        "line": 101,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 109,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (3)\\n\");"
    },
    {
        "line": 110,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 156,
        "fullcodeline": "fprintf(stderr, \"Error: Couldn't read from /dev/random\\n\");"
    },
    {
        "line": 157,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 226,
        "fullcodeline": "buffer[j] ^= IV[j];"
    },
    {
        "line": 238,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write iv_key data\\n\");"
    },
    {
        "line": 299,
        "fullcodeline": "buffer[i] ^= IV[i];"
    },
    {
        "line": 311,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write to output file\\n\");"
    },
    {
        "line": 46,
        "fullcodeline": "if ((bytes_read = aesrandom_read(aesrand, buffer, 32)) != 32)"
    },
    {
        "line": 93,
        "fullcodeline": "return -1;"
    },
    {
        "line": 102,
        "fullcodeline": "return -1;"
    },
    {
        "line": 111,
        "fullcodeline": "return -1;"
    },
    {
        "line": 158,
        "fullcodeline": "return -1;"
    },
    {
        "line": 239,
        "fullcodeline": "return -1;"
    },
    {
        "line": 312,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "fprintf(stderr, \"Error: Couldn't read from random : %u\\n\","
    },
    {
        "line": 50,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 49,
        "fullcodeline": "(unsigned) bytes_read);"
    },
    {
        "line": 51,
        "fullcodeline": "return -1;"
    }
]