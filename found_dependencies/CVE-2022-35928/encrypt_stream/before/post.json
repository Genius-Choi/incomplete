[
    {
        "line": 7,
        "fullcodeline": "unsigned char IV[16];"
    },
    {
        "line": 8,
        "fullcodeline": "unsigned char iv_key[48];"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char buffer[32];"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned char ipad[64], opad[64];"
    },
    {
        "line": 16,
        "fullcodeline": "unsigned char tag_buffer[256];"
    },
    {
        "line": 39,
        "fullcodeline": "memset(iv_key, 0, 48);"
    },
    {
        "line": 63,
        "fullcodeline": "buffer[0] = 'A';"
    },
    {
        "line": 64,
        "fullcodeline": "buffer[1] = 'E';"
    },
    {
        "line": 65,
        "fullcodeline": "buffer[2] = 'S';"
    },
    {
        "line": 66,
        "fullcodeline": "buffer[3] = (unsigned char) 0x02;   /* Version 2 */"
    },
    {
        "line": 67,
        "fullcodeline": "buffer[4] = '\\0';                   /* Reserved for version 0 */"
    },
    {
        "line": 76,
        "fullcodeline": "j = 11 +                      /* \"CREATED-BY\\0\" */"
    },
    {
        "line": 116,
        "fullcodeline": "buffer[0] = '\\0';"
    },
    {
        "line": 117,
        "fullcodeline": "buffer[1] = (unsigned char) 128;"
    },
    {
        "line": 124,
        "fullcodeline": "memset(tag_buffer, 0, 128);"
    },
    {
        "line": 133,
        "fullcodeline": "buffer[0] = '\\0';"
    },
    {
        "line": 134,
        "fullcodeline": "buffer[1] = '\\0';"
    },
    {
        "line": 146,
        "fullcodeline": "sha256_starts(  &sha_ctx);"
    },
    {
        "line": 147,
        "fullcodeline": "current_time = time(NULL);"
    },
    {
        "line": 148,
        "fullcodeline": "sha256_update(  &sha_ctx, (unsigned char *)&time, sizeof(current_time));"
    },
    {
        "line": 149,
        "fullcodeline": "process_id = getpid();"
    },
    {
        "line": 150,
        "fullcodeline": "sha256_update(  &sha_ctx, (unsigned char *)&process_id, sizeof(process_id));"
    },
    {
        "line": 165,
        "fullcodeline": "sha256_finish(  &sha_ctx, digest);"
    },
    {
        "line": 167,
        "fullcodeline": "memcpy(IV, digest, 16);"
    },
    {
        "line": 170,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 180,
        "fullcodeline": "memset(digest, 0, 32);"
    },
    {
        "line": 181,
        "fullcodeline": "memcpy(digest, IV, 16);"
    },
    {
        "line": 194,
        "fullcodeline": "aes_set_key(&aes_ctx, digest, 256);"
    },
    {
        "line": 201,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 202,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 210,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 211,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 252,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 253,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 254,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 255,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 256,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 268,
        "fullcodeline": "memcpy(IV, iv_key, 16);"
    },
    {
        "line": 271,
        "fullcodeline": "aes_set_key(&aes_ctx, iv_key+16, 256);"
    },
    {
        "line": 278,
        "fullcodeline": "memset(ipad, 0x36, 64);"
    },
    {
        "line": 279,
        "fullcodeline": "memset(opad, 0x5C, 64);"
    },
    {
        "line": 288,
        "fullcodeline": "memset_secure(iv_key, 0, 48);"
    },
    {
        "line": 290,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 291,
        "fullcodeline": "sha256_update(&sha_ctx, ipad, 64);"
    },
    {
        "line": 294,
        "fullcodeline": "aeshdr.last_block_size = 0;"
    },
    {
        "line": 335,
        "fullcodeline": "buffer[0] = (char) (aeshdr.last_block_size & 0x0F);"
    },
    {
        "line": 343,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 344,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 345,
        "fullcodeline": "sha256_update(&sha_ctx, opad, 64);"
    },
    {
        "line": 346,
        "fullcodeline": "sha256_update(&sha_ctx, digest, 32);"
    },
    {
        "line": 347,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 24,
        "fullcodeline": "if ((aesrand = aesrandom_open()) == NULL)"
    },
    {
        "line": 40,
        "fullcodeline": "for (i=0; i<48; i+=16)"
    },
    {
        "line": 68,
        "fullcodeline": "if (fwrite(buffer, 1, 5, outfp) != 5)"
    },
    {
        "line": 85,
        "fullcodeline": "if (j < 256)"
    },
    {
        "line": 118,
        "fullcodeline": "if (fwrite(buffer, 1, 2, outfp) != 2)"
    },
    {
        "line": 125,
        "fullcodeline": "if (fwrite(tag_buffer, 1, 128, outfp) != 128)"
    },
    {
        "line": 135,
        "fullcodeline": "if (fwrite(buffer, 1, 2, outfp) != 2)"
    },
    {
        "line": 152,
        "fullcodeline": "for (i=0; i<256; i++)"
    },
    {
        "line": 173,
        "fullcodeline": "if (fwrite(IV, 1, 16, outfp) != 16)"
    },
    {
        "line": 182,
        "fullcodeline": "for(i=0; i<8192; i++)"
    },
    {
        "line": 204,
        "fullcodeline": "for(i=0; i<32; i++)"
    },
    {
        "line": 217,
        "fullcodeline": "for(i=0; i<48; i+=16)"
    },
    {
        "line": 258,
        "fullcodeline": "if (fwrite(digest, 1, 32, outfp) != 32)"
    },
    {
        "line": 281,
        "fullcodeline": "for(i=0; i<32; i++)"
    },
    {
        "line": 296,
        "fullcodeline": "while ((bytes_read = fread(buffer, 1, 16, infp)) > 0)"
    },
    {
        "line": 328,
        "fullcodeline": "if (ferror(infp))"
    },
    {
        "line": 336,
        "fullcodeline": "if (fwrite(buffer, 1, 1, outfp) != 1)"
    },
    {
        "line": 348,
        "fullcodeline": "if (fwrite(digest, 1, 32, outfp) != 32)"
    },
    {
        "line": 355,
        "fullcodeline": "if (fflush(outfp))"
    },
    {
        "line": 26,
        "fullcodeline": "perror(\"Error open random:\");"
    },
    {
        "line": 42,
        "fullcodeline": "memset(buffer, 0, 32);"
    },
    {
        "line": 43,
        "fullcodeline": "sha256_starts(&sha_ctx);"
    },
    {
        "line": 55,
        "fullcodeline": "sha256_finish(&sha_ctx, digest);"
    },
    {
        "line": 56,
        "fullcodeline": "memcpy(iv_key+i, digest, 16);"
    },
    {
        "line": 70,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write out header data\\n\");"
    },
    {
        "line": 71,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 79,
        "fullcodeline": "strlen(PACKAGE_VERSION);  /* Program version ID */"
    },
    {
        "line": 87,
        "fullcodeline": "buffer[0] = '\\0';"
    },
    {
        "line": 88,
        "fullcodeline": "buffer[1] = (unsigned char) (j & 0xff);"
    },
    {
        "line": 96,
        "fullcodeline": "strncpy((char *)tag_buffer, \"CREATED_BY\", 255);"
    },
    {
        "line": 97,
        "fullcodeline": "tag_buffer[255] = '\\0';"
    },
    {
        "line": 105,
        "fullcodeline": "sprintf((char *)tag_buffer, \"%s %s\", PACKAGE_NAME, PACKAGE_VERSION);"
    },
    {
        "line": 106,
        "fullcodeline": "j = strlen((char *)tag_buffer);"
    },
    {
        "line": 120,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (4)\\n\");"
    },
    {
        "line": 121,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 127,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (5)\\n\");"
    },
    {
        "line": 128,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 137,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (6)\\n\");"
    },
    {
        "line": 138,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 160,
        "fullcodeline": "sha256_update(  &sha_ctx,"
    },
    {
        "line": 175,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write out initialization vector\\n\");"
    },
    {
        "line": 184,
        "fullcodeline": "sha256_starts(  &sha_ctx);"
    },
    {
        "line": 185,
        "fullcodeline": "sha256_update(  &sha_ctx, digest, 32);"
    },
    {
        "line": 186,
        "fullcodeline": "sha256_update(  &sha_ctx,"
    },
    {
        "line": 189,
        "fullcodeline": "sha256_finish(  &sha_ctx,"
    },
    {
        "line": 206,
        "fullcodeline": "ipad[i] ^= digest[i];"
    },
    {
        "line": 207,
        "fullcodeline": "opad[i] ^= digest[i];"
    },
    {
        "line": 223,
        "fullcodeline": "memcpy(buffer, iv_key+i, 16);"
    },
    {
        "line": 235,
        "fullcodeline": "aes_encrypt(&aes_ctx, buffer, buffer);"
    },
    {
        "line": 238,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 16);"
    },
    {
        "line": 248,
        "fullcodeline": "memcpy(IV, buffer, 16);"
    },
    {
        "line": 260,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write iv_key HMAC\\n\");"
    },
    {
        "line": 283,
        "fullcodeline": "ipad[i] ^= iv_key[i+16];"
    },
    {
        "line": 284,
        "fullcodeline": "opad[i] ^= iv_key[i+16];"
    },
    {
        "line": 308,
        "fullcodeline": "aes_encrypt(&aes_ctx, buffer, buffer);"
    },
    {
        "line": 311,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 16);"
    },
    {
        "line": 321,
        "fullcodeline": "memcpy(IV, buffer, 16);"
    },
    {
        "line": 324,
        "fullcodeline": "aeshdr.last_block_size = bytes_read;"
    },
    {
        "line": 330,
        "fullcodeline": "fprintf(stderr, \"Error: Couldn't read input file\\n\");"
    },
    {
        "line": 338,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write the file size modulo\\n\");"
    },
    {
        "line": 350,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write the file HMAC\\n\");"
    },
    {
        "line": 357,
        "fullcodeline": "fprintf(stderr, \"Error: Could not flush output file buffer\\n\");"
    },
    {
        "line": 27,
        "fullcodeline": "return -1;"
    },
    {
        "line": 44,
        "fullcodeline": "for(j=0; j<256; j++)"
    },
    {
        "line": 72,
        "fullcodeline": "return -1;"
    },
    {
        "line": 89,
        "fullcodeline": "if (fwrite(buffer, 1, 2, outfp) != 2)"
    },
    {
        "line": 98,
        "fullcodeline": "if (fwrite(tag_buffer, 1, 11, outfp) != 11)"
    },
    {
        "line": 107,
        "fullcodeline": "if (fwrite(tag_buffer, 1, j, outfp) != j)"
    },
    {
        "line": 122,
        "fullcodeline": "return -1;"
    },
    {
        "line": 129,
        "fullcodeline": "return -1;"
    },
    {
        "line": 139,
        "fullcodeline": "return -1;"
    },
    {
        "line": 154,
        "fullcodeline": "if (aesrandom_read(aesrand, buffer, 32) != 32)"
    },
    {
        "line": 176,
        "fullcodeline": "return -1;"
    },
    {
        "line": 188,
        "fullcodeline": "(unsigned long)passlen);"
    },
    {
        "line": 229,
        "fullcodeline": "for(j=0; j<16; j++)"
    },
    {
        "line": 241,
        "fullcodeline": "if (fwrite(buffer, 1, 16, outfp) != 16)"
    },
    {
        "line": 261,
        "fullcodeline": "return -1;"
    },
    {
        "line": 302,
        "fullcodeline": "for(i=0; i<16; i++)"
    },
    {
        "line": 314,
        "fullcodeline": "if (fwrite(buffer, 1, 16, outfp) != 16)"
    },
    {
        "line": 331,
        "fullcodeline": "return -1;"
    },
    {
        "line": 339,
        "fullcodeline": "return -1;"
    },
    {
        "line": 351,
        "fullcodeline": "return -1;"
    },
    {
        "line": 358,
        "fullcodeline": "return -1;"
    },
    {
        "line": 53,
        "fullcodeline": "sha256_update(&sha_ctx, buffer, 32);"
    },
    {
        "line": 77,
        "fullcodeline": "strlen(PACKAGE_NAME) +    /* Program name */"
    },
    {
        "line": 91,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (1)\\n\");"
    },
    {
        "line": 92,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 100,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (2)\\n\");"
    },
    {
        "line": 101,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 109,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write tag to AES file (3)\\n\");"
    },
    {
        "line": 110,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 156,
        "fullcodeline": "fprintf(stderr, \"Error: Couldn't read from /dev/random\\n\");"
    },
    {
        "line": 157,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 231,
        "fullcodeline": "buffer[j] ^= IV[j];"
    },
    {
        "line": 243,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write iv_key data\\n\");"
    },
    {
        "line": 304,
        "fullcodeline": "buffer[i] ^= IV[i];"
    },
    {
        "line": 316,
        "fullcodeline": "fprintf(stderr, \"Error: Could not write to output file\\n\");"
    },
    {
        "line": 46,
        "fullcodeline": "if ((bytes_read = aesrandom_read(aesrand, buffer, 32)) != 32)"
    },
    {
        "line": 93,
        "fullcodeline": "return -1;"
    },
    {
        "line": 102,
        "fullcodeline": "return -1;"
    },
    {
        "line": 111,
        "fullcodeline": "return -1;"
    },
    {
        "line": 158,
        "fullcodeline": "return -1;"
    },
    {
        "line": 244,
        "fullcodeline": "return -1;"
    },
    {
        "line": 317,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "fprintf(stderr, \"Error: Couldn't read from random : %u\\n\","
    },
    {
        "line": 50,
        "fullcodeline": "aesrandom_close(aesrand);"
    },
    {
        "line": 49,
        "fullcodeline": "(unsigned) bytes_read);"
    },
    {
        "line": 51,
        "fullcodeline": "return -1;"
    }
]