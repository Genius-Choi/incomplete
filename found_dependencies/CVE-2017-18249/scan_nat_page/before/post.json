[
    {
        "line": 4,
        "fullcodeline": "struct f2fs_nm_info *nm_i = NM_I(sbi);"
    },
    {
        "line": 5,
        "fullcodeline": "struct f2fs_nat_block *nat_blk = page_address(nat_page);"
    },
    {
        "line": 7,
        "fullcodeline": "unsigned int nat_ofs = NAT_BLOCK_OFFSET(start_nid);"
    },
    {
        "line": 13,
        "fullcodeline": "__set_bit_le(nat_ofs, nm_i->nat_block_bitmap);"
    },
    {
        "line": 15,
        "fullcodeline": "i = start_nid % NAT_ENTRY_PER_BLOCK;"
    },
    {
        "line": 10,
        "fullcodeline": "if (test_bit_le(nat_ofs, nm_i->nat_block_bitmap))"
    },
    {
        "line": 17,
        "fullcodeline": "for (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {"
    },
    {
        "line": 18,
        "fullcodeline": "bool freed = false;"
    },
    {
        "line": 23,
        "fullcodeline": "blk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);"
    },
    {
        "line": 24,
        "fullcodeline": "f2fs_bug_on(sbi, blk_addr == NEW_ADDR);"
    },
    {
        "line": 27,
        "fullcodeline": "spin_lock(&NM_I(sbi)->nid_list_lock);"
    },
    {
        "line": 28,
        "fullcodeline": "update_free_nid_bitmap(sbi, start_nid, freed, true);"
    },
    {
        "line": 29,
        "fullcodeline": "spin_unlock(&NM_I(sbi)->nid_list_lock);"
    },
    {
        "line": 20,
        "fullcodeline": "if (unlikely(start_nid >= nm_i->max_nid))"
    },
    {
        "line": 25,
        "fullcodeline": "if (blk_addr == NULL_ADDR)"
    },
    {
        "line": 26,
        "fullcodeline": "freed = add_free_nid(sbi, start_nid, true);"
    }
]