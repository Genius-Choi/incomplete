[
    {
        "line": 2,
        "fullcodeline": "int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;"
    },
    {
        "line": 4,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 13,
        "fullcodeline": "auto cleanup = gtl::MakeCleanup([&decode]() {"
    },
    {
        "line": 24,
        "fullcodeline": "const int width = static_cast<int>(decode.width);"
    },
    {
        "line": 25,
        "fullcodeline": "const int height = static_cast<int>(decode.height);"
    },
    {
        "line": 26,
        "fullcodeline": "const int64_t total_size ="
    },
    {
        "line": 36,
        "fullcodeline": "Tensor* output = nullptr;"
    },
    {
        "line": 5,
        "fullcodeline": "context, png::CommonInitDecode(input, channels_, channel_bits, &decode),"
    },
    {
        "line": 6,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));"
    },
    {
        "line": 27,
        "fullcodeline": "static_cast<int64_t>(width) * static_cast<int64_t>(height);"
    },
    {
        "line": 28,
        "fullcodeline": "if (width != static_cast<int64_t>(decode.width) || width <= 0 ||"
    },
    {
        "line": 39,
        "fullcodeline": "if (op_type_ == \"DecodeGif\") {"
    },
    {
        "line": 51,
        "fullcodeline": "if (op_type_ == \"DecodeBmp\") {"
    },
    {
        "line": 68,
        "fullcodeline": "if (data_type_ == DataType::DT_UINT8) {"
    },
    {
        "line": 30,
        "fullcodeline": "height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {"
    },
    {
        "line": 31,
        "fullcodeline": "OP_REQUIRES(context, false,"
    },
    {
        "line": 40,
        "fullcodeline": "OP_REQUIRES_OK("
    },
    {
        "line": 57,
        "fullcodeline": "OP_REQUIRES(context, false,"
    },
    {
        "line": 69,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 32,
        "fullcodeline": "errors::InvalidArgument(\"PNG size too large for int: \","
    },
    {
        "line": 42,
        "fullcodeline": "context->allocate_output("
    },
    {
        "line": 45,
        "fullcodeline": "OP_REQUIRES_OK("
    },
    {
        "line": 58,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 71,
        "fullcodeline": "png::CommonFinishDecode("
    },
    {
        "line": 74,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));"
    },
    {
        "line": 43,
        "fullcodeline": "0, TensorShape({1, height, width, decode.channels}), &output));"
    },
    {
        "line": 47,
        "fullcodeline": "context->allocate_output("
    },
    {
        "line": 61,
        "fullcodeline": "} else if (op_type_ == \"DecodeAndCropJpeg\") {"
    },
    {
        "line": 72,
        "fullcodeline": "reinterpret_cast<png_bytep>(output->flat<uint8>().data()),"
    },
    {
        "line": 73,
        "fullcodeline": "decode.channels * width * sizeof(uint8), &decode),"
    },
    {
        "line": 75,
        "fullcodeline": "} else if (data_type_ == DataType::DT_UINT16) {"
    },
    {
        "line": 29,
        "fullcodeline": "width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||"
    },
    {
        "line": 48,
        "fullcodeline": "0, TensorShape({height, width, decode.channels}), &output));"
    },
    {
        "line": 62,
        "fullcodeline": "OP_REQUIRES(context, false,"
    },
    {
        "line": 63,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 78,
        "fullcodeline": "png::CommonFinishDecode("
    },
    {
        "line": 81,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));"
    },
    {
        "line": 80,
        "fullcodeline": "decode.channels * width * sizeof(uint16), &decode),"
    },
    {
        "line": 79,
        "fullcodeline": "reinterpret_cast<png_bytep>(output->flat<uint16>().data()),"
    },
    {
        "line": 88,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 97,
        "fullcodeline": "const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();"
    },
    {
        "line": 100,
        "fullcodeline": "float scale = 1. / std::numeric_limits<uint16>::max();"
    },
    {
        "line": 87,
        "fullcodeline": "new uint16[height * width * decode.channels]);"
    },
    {
        "line": 90,
        "fullcodeline": "png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),"
    },
    {
        "line": 93,
        "fullcodeline": "errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));"
    },
    {
        "line": 98,
        "fullcodeline": "TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,"
    },
    {
        "line": 102,
        "fullcodeline": "output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;"
    },
    {
        "line": 91,
        "fullcodeline": "decode.channels * width * sizeof(uint16),"
    }
]