[
    {
        "line": 3,
        "fullcodeline": "uint8_t b[192];"
    },
    {
        "line": 6,
        "fullcodeline": "int n, pat, chan, smp, rows, todo = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "slurp_read(fp, b, 3);"
    },
    {
        "line": 16,
        "fullcodeline": "n = slurp_getc(fp);"
    },
    {
        "line": 17,
        "fullcodeline": "sprintf(song->tracker_id, \"MultiTracker %d.%d\", n >> 4, n & 0xf);"
    },
    {
        "line": 18,
        "fullcodeline": "slurp_read(fp, song->title, 20);"
    },
    {
        "line": 19,
        "fullcodeline": "song->title[20] = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "slurp_read(fp, &ntrk, 2);"
    },
    {
        "line": 21,
        "fullcodeline": "ntrk = bswapLE16(ntrk);"
    },
    {
        "line": 22,
        "fullcodeline": "npat = slurp_getc(fp);"
    },
    {
        "line": 23,
        "fullcodeline": "nord = slurp_getc(fp) + 1;"
    },
    {
        "line": 25,
        "fullcodeline": "slurp_read(fp, &comment_len, 2);"
    },
    {
        "line": 26,
        "fullcodeline": "comment_len = bswapLE16(comment_len);"
    },
    {
        "line": 28,
        "fullcodeline": "nsmp = slurp_getc(fp);"
    },
    {
        "line": 29,
        "fullcodeline": "slurp_getc(fp); /* attribute byte (unused) */"
    },
    {
        "line": 30,
        "fullcodeline": "rows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */"
    },
    {
        "line": 33,
        "fullcodeline": "rows = MIN(rows, 64);"
    },
    {
        "line": 34,
        "fullcodeline": "nchan = slurp_getc(fp);"
    },
    {
        "line": 96,
        "fullcodeline": "slurp_read(fp, song->orderlist, 128);"
    },
    {
        "line": 97,
        "fullcodeline": "memset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);"
    },
    {
        "line": 100,
        "fullcodeline": "trackdata = mem_calloc(ntrk, sizeof(song_note_t *));"
    },
    {
        "line": 150,
        "fullcodeline": "free(trackdata);"
    },
    {
        "line": 152,
        "fullcodeline": "read_lined_message(song->message, fp, comment_len, 40);"
    },
    {
        "line": 170,
        "fullcodeline": "song->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;"
    },
    {
        "line": 14,
        "fullcodeline": "if (memcmp(b, \"MTM\", 3) != 0)"
    },
    {
        "line": 31,
        "fullcodeline": "if (rows != 64)"
    },
    {
        "line": 36,
        "fullcodeline": "if (slurp_eof(fp)) {"
    },
    {
        "line": 40,
        "fullcodeline": "for (n = 0; n < 32; n++) {"
    },
    {
        "line": 46,
        "fullcodeline": "for (n = nchan; n < MAX_CHANNELS; n++)"
    },
    {
        "line": 47,
        "fullcodeline": "song->channels[n].flags = CHN_MUTE;"
    },
    {
        "line": 50,
        "fullcodeline": "if (nsmp > MAX_SAMPLES) {"
    },
    {
        "line": 53,
        "fullcodeline": "for (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {"
    },
    {
        "line": 101,
        "fullcodeline": "for (n = 0; n < ntrk; n++) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (npat >= MAX_PATTERNS) {"
    },
    {
        "line": 111,
        "fullcodeline": "for (pat = 0; pat <= npat; pat++) {"
    },
    {
        "line": 148,
        "fullcodeline": "for (n = 0; n < ntrk; n++)"
    },
    {
        "line": 149,
        "fullcodeline": "free(trackdata[n]);"
    },
    {
        "line": 155,
        "fullcodeline": "if (!(lflags & LOAD_NOSAMPLES)) {"
    },
    {
        "line": 176,
        "fullcodeline": "if (todo & 64)"
    },
    {
        "line": 178,
        "fullcodeline": "if (todo & 16)"
    },
    {
        "line": 32,
        "fullcodeline": "todo |= 64;"
    },
    {
        "line": 41,
        "fullcodeline": "int pan = slurp_getc(fp) & 0xf;"
    },
    {
        "line": 42,
        "fullcodeline": "pan = SHORT_PANNING(pan);"
    },
    {
        "line": 43,
        "fullcodeline": "pan *= 4; //mphack"
    },
    {
        "line": 44,
        "fullcodeline": "song->channels[n].panning = pan;"
    },
    {
        "line": 51,
        "fullcodeline": "log_appendf(4, \" Warning: Too many samples\");"
    },
    {
        "line": 61,
        "fullcodeline": "char name[23];"
    },
    {
        "line": 62,
        "fullcodeline": "slurp_read(fp, name, 22);"
    },
    {
        "line": 63,
        "fullcodeline": "name[22] = '\\0';"
    },
    {
        "line": 64,
        "fullcodeline": "strcpy(sample->name, name);"
    },
    {
        "line": 65,
        "fullcodeline": "slurp_read(fp, &tmplong, 4);"
    },
    {
        "line": 66,
        "fullcodeline": "sample->length = bswapLE32(tmplong);"
    },
    {
        "line": 67,
        "fullcodeline": "slurp_read(fp, &tmplong, 4);"
    },
    {
        "line": 68,
        "fullcodeline": "sample->loop_start = bswapLE32(tmplong);"
    },
    {
        "line": 69,
        "fullcodeline": "slurp_read(fp, &tmplong, 4);"
    },
    {
        "line": 70,
        "fullcodeline": "sample->loop_end = bswapLE32(tmplong);"
    },
    {
        "line": 78,
        "fullcodeline": "song->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));"
    },
    {
        "line": 79,
        "fullcodeline": "sample->volume = slurp_getc(fp);"
    },
    {
        "line": 80,
        "fullcodeline": "sample->volume *= 4; //mphack"
    },
    {
        "line": 81,
        "fullcodeline": "sample->global_volume = 64;"
    },
    {
        "line": 89,
        "fullcodeline": "song->samples[n].vib_type = 0;"
    },
    {
        "line": 90,
        "fullcodeline": "song->samples[n].vib_rate = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "song->samples[n].vib_depth = 0;"
    },
    {
        "line": 92,
        "fullcodeline": "song->samples[n].vib_speed = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "slurp_read(fp, b, 3 * rows);"
    },
    {
        "line": 103,
        "fullcodeline": "trackdata[n] = mem_calloc(rows, sizeof(song_note_t));"
    },
    {
        "line": 104,
        "fullcodeline": "mtm_unpack_track(b, trackdata[n], rows);"
    },
    {
        "line": 109,
        "fullcodeline": "log_appendf(4, \" Warning: Too many patterns\");"
    },
    {
        "line": 118,
        "fullcodeline": "song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));"
    },
    {
        "line": 119,
        "fullcodeline": "song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;"
    },
    {
        "line": 120,
        "fullcodeline": "tracknote = trackdata[n];"
    },
    {
        "line": 177,
        "fullcodeline": "log_appendf(2, \" TODO: test this file with other players (beats per track != 64)\");"
    },
    {
        "line": 179,
        "fullcodeline": "log_appendf(2, \" TODO: double check 16 bit sample loading\");"
    },
    {
        "line": 54,
        "fullcodeline": "if (n > MAX_SAMPLES) {"
    },
    {
        "line": 71,
        "fullcodeline": "if ((sample->loop_end - sample->loop_start) > 2) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (slurp_getc(fp) & 1) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (pat >= MAX_PATTERNS) {"
    },
    {
        "line": 121,
        "fullcodeline": "for (chan = 0; chan < 32; chan++) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (rows < 32) {"
    },
    {
        "line": 156,
        "fullcodeline": "for (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {"
    },
    {
        "line": 55,
        "fullcodeline": "slurp_seek(fp, 37, SEEK_CUR);"
    },
    {
        "line": 72,
        "fullcodeline": "sample->flags |= CHN_LOOP;"
    },
    {
        "line": 83,
        "fullcodeline": "todo |= 16;"
    },
    {
        "line": 84,
        "fullcodeline": "sample->flags |= CHN_16BIT;"
    },
    {
        "line": 85,
        "fullcodeline": "sample->length >>= 1;"
    },
    {
        "line": 86,
        "fullcodeline": "sample->loop_start >>= 1;"
    },
    {
        "line": 87,
        "fullcodeline": "sample->loop_end >>= 1;"
    },
    {
        "line": 114,
        "fullcodeline": "slurp_seek(fp, 64, SEEK_CUR);"
    },
    {
        "line": 122,
        "fullcodeline": "slurp_read(fp, &tmp, 2);"
    },
    {
        "line": 123,
        "fullcodeline": "tmp = bswapLE16(tmp);"
    },
    {
        "line": 132,
        "fullcodeline": "note = song->patterns[pat] + chan;"
    },
    {
        "line": 133,
        "fullcodeline": "tracknote = trackdata[tmp - 1];"
    },
    {
        "line": 140,
        "fullcodeline": "note = song->patterns[pat] + 64 * (rows - 1);"
    },
    {
        "line": 143,
        "fullcodeline": "note->effect = FX_PATTERNBREAK;"
    },
    {
        "line": 161,
        "fullcodeline": "ssize = csf_read_sample(song->samples + smp,"
    },
    {
        "line": 165,
        "fullcodeline": "slurp_seek(fp, ssize, SEEK_CUR);"
    },
    {
        "line": 75,
        "fullcodeline": "sample->loop_start = 0;"
    },
    {
        "line": 76,
        "fullcodeline": "sample->loop_end = 0;"
    },
    {
        "line": 124,
        "fullcodeline": "if (tmp == 0) {"
    },
    {
        "line": 134,
        "fullcodeline": "for (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)"
    },
    {
        "line": 141,
        "fullcodeline": "while (note->effect || note->param)"
    },
    {
        "line": 142,
        "fullcodeline": "note++;"
    },
    {
        "line": 159,
        "fullcodeline": "if (song->samples[smp].length == 0)"
    },
    {
        "line": 162,
        "fullcodeline": "(SF_LE | SF_PCMU | SF_M"
    },
    {
        "line": 164,
        "fullcodeline": "fp->data + fp->pos, fp->length - fp->pos);"
    },
    {
        "line": 163,
        "fullcodeline": "| ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),"
    },
    {
        "line": 126,
        "fullcodeline": "} else if (tmp > ntrk) {"
    },
    {
        "line": 129,
        "fullcodeline": "free(trackdata);"
    },
    {
        "line": 127,
        "fullcodeline": "for (n = 0; n < ntrk; n++)"
    },
    {
        "line": 128,
        "fullcodeline": "free(trackdata[n]);"
    }
]