[
    {
        "line": 2,
        "fullcodeline": "auto* params ="
    },
    {
        "line": 4,
        "fullcodeline": "int axis = params->axis;"
    },
    {
        "line": 10,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));"
    },
    {
        "line": 11,
        "fullcodeline": "TfLiteType input_type = t0->type;"
    },
    {
        "line": 13,
        "fullcodeline": "TF_LITE_ENSURE(context, axis >= 0);"
    },
    {
        "line": 14,
        "fullcodeline": "TF_LITE_ENSURE(context, axis < t0->dims->size);"
    },
    {
        "line": 16,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);"
    },
    {
        "line": 17,
        "fullcodeline": "TF_LITE_ENSURE(context,"
    },
    {
        "line": 44,
        "fullcodeline": "TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);"
    },
    {
        "line": 50,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));"
    },
    {
        "line": 51,
        "fullcodeline": "TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);"
    },
    {
        "line": 3,
        "fullcodeline": "reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);"
    },
    {
        "line": 12,
        "fullcodeline": "if (axis < 0) axis += t0->dims->size;"
    },
    {
        "line": 18,
        "fullcodeline": "input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||"
    },
    {
        "line": 26,
        "fullcodeline": "for (int i = 1; i < num_inputs; ++i) {"
    },
    {
        "line": 45,
        "fullcodeline": "for (int d = 0; d < t0->dims->size; ++d) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (input_type == kTfLiteInt8) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (input_type == kTfLiteInt16) {"
    },
    {
        "line": 75,
        "fullcodeline": "return context->ResizeTensor(context, output, output_size);"
    },
    {
        "line": 21,
        "fullcodeline": "input_type == kTfLiteBool);"
    },
    {
        "line": 28,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));"
    },
    {
        "line": 29,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);"
    },
    {
        "line": 30,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, t->type, input_type);"
    },
    {
        "line": 46,
        "fullcodeline": "output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];"
    },
    {
        "line": 56,
        "fullcodeline": "VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);"
    },
    {
        "line": 72,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);"
    },
    {
        "line": 20,
        "fullcodeline": "input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||"
    },
    {
        "line": 31,
        "fullcodeline": "for (int d = 0; d < t0->dims->size; ++d) {"
    },
    {
        "line": 57,
        "fullcodeline": "for (int i = 0; i < node->inputs->size; ++i) {"
    },
    {
        "line": 68,
        "fullcodeline": "for (int i = 0; i < node->inputs->size; ++i) {"
    },
    {
        "line": 59,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));"
    },
    {
        "line": 60,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);"
    },
    {
        "line": 61,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, t->params.zero_point,"
    },
    {
        "line": 69,
        "fullcodeline": "const TfLiteTensor* t = GetInput(context, node, i);"
    },
    {
        "line": 70,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);"
    },
    {
        "line": 19,
        "fullcodeline": "input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||"
    },
    {
        "line": 32,
        "fullcodeline": "if (d == axis) {"
    },
    {
        "line": 34,
        "fullcodeline": "TF_LITE_ENSURE(context, t->dims->data[axis] >= 0);"
    },
    {
        "line": 35,
        "fullcodeline": "TF_LITE_ENSURE(context, t->dims->data[axis] <="
    },
    {
        "line": 37,
        "fullcodeline": "sum_axis += t->dims->data[axis];"
    },
    {
        "line": 39,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);"
    },
    {
        "line": 36,
        "fullcodeline": "std::numeric_limits<int>::max() - sum_axis);"
    }
]