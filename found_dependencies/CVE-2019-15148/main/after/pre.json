[
    {
        "line": 3,
        "fullcodeline": "int32_t ret = GPMF_OK;"
    },
    {
        "line": 4,
        "fullcodeline": "GPMF_stream metadata_stream, *ms = &metadata_stream;"
    },
    {
        "line": 6,
        "fullcodeline": "uint32_t *payload = NULL; //buffer to store GPMF samples from the MP4."
    },
    {
        "line": 16,
        "fullcodeline": "size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);"
    },
    {
        "line": 25,
        "fullcodeline": "metadatalength = GetDuration(mp4);"
    },
    {
        "line": 10,
        "fullcodeline": "if (argc != 2)"
    },
    {
        "line": 17,
        "fullcodeline": "if (mp4 == 0)"
    },
    {
        "line": 12,
        "fullcodeline": "printf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);"
    },
    {
        "line": 29,
        "fullcodeline": "uint32_t index, payloads = GetNumberPayloads(mp4);"
    },
    {
        "line": 13,
        "fullcodeline": "return -1;"
    },
    {
        "line": 20,
        "fullcodeline": "return -1;"
    },
    {
        "line": 33,
        "fullcodeline": "if (payloads == 1) // Printf the contents of the single payload"
    },
    {
        "line": 64,
        "fullcodeline": "for (index = 0; index < payloads; index++)"
    },
    {
        "line": 211,
        "fullcodeline": "while (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 35,
        "fullcodeline": "uint32_t payloadsize = GetPayloadSize(mp4,0);"
    },
    {
        "line": 36,
        "fullcodeline": "payload = GetPayload(mp4, payload, 0);"
    },
    {
        "line": 40,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 45,
        "fullcodeline": "ret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS); // optional"
    },
    {
        "line": 52,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 57,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 66,
        "fullcodeline": "uint32_t payloadsize = GetPayloadSize(mp4, index);"
    },
    {
        "line": 67,
        "fullcodeline": "double in = 0.0, out = 0.0; //times"
    },
    {
        "line": 68,
        "fullcodeline": "payload = GetPayload(mp4, payload, index);"
    },
    {
        "line": 72,
        "fullcodeline": "ret = GetPayloadTime(mp4, index, &in, &out);"
    },
    {
        "line": 76,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 37,
        "fullcodeline": "if(payload == NULL)"
    },
    {
        "line": 41,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 46,
        "fullcodeline": "if (GPMF_OK != ret)"
    },
    {
        "line": 56,
        "fullcodeline": "} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));"
    },
    {
        "line": 69,
        "fullcodeline": "if (payload == NULL)"
    },
    {
        "line": 73,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 77,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 81,
        "fullcodeline": "if (index == 0) // show first payload"
    },
    {
        "line": 151,
        "fullcodeline": "if (index == 0) // show first payload"
    },
    {
        "line": 213,
        "fullcodeline": "if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream"
    },
    {
        "line": 55,
        "fullcodeline": "PrintGPMF(ms);  // printf current GPMF KLV"
    },
    {
        "line": 83,
        "fullcodeline": "ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);"
    },
    {
        "line": 142,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 203,
        "fullcodeline": "GPMF_ResetState(ms);"
    },
    {
        "line": 215,
        "fullcodeline": "double in = 0.0, out = 0.0;"
    },
    {
        "line": 216,
        "fullcodeline": "uint32_t fourcc = GPMF_Key(ms);"
    },
    {
        "line": 217,
        "fullcodeline": "double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);"
    },
    {
        "line": 84,
        "fullcodeline": "while (GPMF_OK == ret)"
    },
    {
        "line": 218,
        "fullcodeline": "printf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);"
    },
    {
        "line": 86,
        "fullcodeline": "ret = GPMF_SeekToSamples(ms);"
    },
    {
        "line": 153,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPS5\"), GPMF_RECURSE_LEVELS) || //GoPro Hero5/6/7 GPS"
    },
    {
        "line": 154,
        "fullcodeline": "GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPRI\"), GPMF_RECURSE_LEVELS))   //GoPro Karma GPS"
    },
    {
        "line": 156,
        "fullcodeline": "uint32_t key = GPMF_Key(ms);"
    },
    {
        "line": 157,
        "fullcodeline": "uint32_t samples = GPMF_Repeat(ms);"
    },
    {
        "line": 158,
        "fullcodeline": "uint32_t elements = GPMF_ElementsInStruct(ms);"
    },
    {
        "line": 159,
        "fullcodeline": "uint32_t buffersize = samples * elements * sizeof(double);"
    },
    {
        "line": 161,
        "fullcodeline": "double *ptr, *tmpbuffer = malloc(buffersize);"
    },
    {
        "line": 162,
        "fullcodeline": "char units[10][6] = { \"\" };"
    },
    {
        "line": 163,
        "fullcodeline": "uint32_t unit_samples = 1;"
    },
    {
        "line": 87,
        "fullcodeline": "if (GPMF_OK == ret) //find the last FOURCC within the stream"
    },
    {
        "line": 167,
        "fullcodeline": "if (tmpbuffer && samples)"
    },
    {
        "line": 89,
        "fullcodeline": "uint32_t key = GPMF_Key(ms);"
    },
    {
        "line": 90,
        "fullcodeline": "GPMF_SampleType type = GPMF_Type(ms);"
    },
    {
        "line": 91,
        "fullcodeline": "uint32_t elements = GPMF_ElementsInStruct(ms);"
    },
    {
        "line": 93,
        "fullcodeline": "uint32_t samples = GPMF_PayloadSampleCount(ms);"
    },
    {
        "line": 132,
        "fullcodeline": "ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);"
    },
    {
        "line": 172,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 189,
        "fullcodeline": "GPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);  //Output scaled data as floats"
    },
    {
        "line": 191,
        "fullcodeline": "ptr = tmpbuffer;"
    },
    {
        "line": 192,
        "fullcodeline": "for (i = 0; i < samples; i++)"
    },
    {
        "line": 136,
        "fullcodeline": "if (ret == GPMF_ERROR_BAD_STRUCTURE) // some payload element was corrupt, skip to the next valid GPMF KLV at the previous level."
    },
    {
        "line": 173,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||"
    },
    {
        "line": 174,
        "fullcodeline": "GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 176,
        "fullcodeline": "char *data = (char *)GPMF_RawData(&find_stream);"
    },
    {
        "line": 177,
        "fullcodeline": "int ssize = GPMF_StructSize(&find_stream);"
    },
    {
        "line": 178,
        "fullcodeline": "unit_samples = GPMF_Repeat(&find_stream);"
    },
    {
        "line": 97,
        "fullcodeline": "printf(\"  STRM of %c%c%c%c \", PRINTF_4CC(key));"
    },
    {
        "line": 99,
        "fullcodeline": "if (type == GPMF_TYPE_COMPLEX)"
    },
    {
        "line": 126,
        "fullcodeline": "if (elements > 1)"
    },
    {
        "line": 138,
        "fullcodeline": "ret = GPMF_Next(ms, GPMF_CURRENT_LEVEL); // this will be the next stream if any more are present."
    },
    {
        "line": 180,
        "fullcodeline": "for (i = 0; i < unit_samples; i++)"
    },
    {
        "line": 194,
        "fullcodeline": "printf(\"%c%c%c%c \", PRINTF_4CC(key));"
    },
    {
        "line": 195,
        "fullcodeline": "for (j = 0; j < elements; j++)"
    },
    {
        "line": 102,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 124,
        "fullcodeline": "printf(\"with %d sample%s \", samples, samples > 1 ? \"s\" : \"\");"
    },
    {
        "line": 182,
        "fullcodeline": "memcpy(units[i], data, ssize);"
    },
    {
        "line": 183,
        "fullcodeline": "units[i][ssize] = 0;"
    },
    {
        "line": 184,
        "fullcodeline": "data += ssize;"
    },
    {
        "line": 104,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 196,
        "fullcodeline": "printf(\"%.3f%s, \", *ptr++, units[j%unit_samples]);"
    },
    {
        "line": 107,
        "fullcodeline": "char *data = (char *)GPMF_RawData(&find_stream);"
    },
    {
        "line": 108,
        "fullcodeline": "int size = GPMF_RawDataSize(&find_stream);"
    },
    {
        "line": 106,
        "fullcodeline": "char tmp[64];"
    },
    {
        "line": 110,
        "fullcodeline": "if (size < sizeof(tmp))"
    },
    {
        "line": 112,
        "fullcodeline": "memcpy(tmp, data, size);"
    },
    {
        "line": 113,
        "fullcodeline": "tmp[size] = 0;"
    }
]