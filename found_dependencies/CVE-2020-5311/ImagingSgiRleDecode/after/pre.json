[
    {
        "line": 6,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "c = (SGISTATE*)state->context;"
    },
    {
        "line": 11,
        "fullcodeline": "_imaging_seek_pyFd(state->fd, 0L, SEEK_END);"
    },
    {
        "line": 12,
        "fullcodeline": "c->bufsize = _imaging_tell_pyFd(state->fd);"
    },
    {
        "line": 13,
        "fullcodeline": "c->bufsize -= SGI_HEADER_SIZE;"
    },
    {
        "line": 14,
        "fullcodeline": "ptr = malloc(sizeof(UINT8) * c->bufsize);"
    },
    {
        "line": 18,
        "fullcodeline": "_imaging_seek_pyFd(state->fd, SGI_HEADER_SIZE, SEEK_SET);"
    },
    {
        "line": 19,
        "fullcodeline": "_imaging_read_pyFd(state->fd, (char*)ptr, c->bufsize);"
    },
    {
        "line": 23,
        "fullcodeline": "state->count = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "state->y = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "state->buffer = NULL;"
    },
    {
        "line": 41,
        "fullcodeline": "state->buffer = calloc(im->xsize * im->bands, sizeof(UINT8) * 2);"
    },
    {
        "line": 42,
        "fullcodeline": "c->tablen = im->bands * im->ysize;"
    },
    {
        "line": 43,
        "fullcodeline": "c->starttab = calloc(c->tablen, sizeof(UINT32));"
    },
    {
        "line": 44,
        "fullcodeline": "c->lengthtab = calloc(c->tablen, sizeof(UINT32));"
    },
    {
        "line": 58,
        "fullcodeline": "state->count += c->tablen * sizeof(UINT32) * 2;"
    },
    {
        "line": 96,
        "fullcodeline": "c->bufsize++;"
    },
    {
        "line": 15,
        "fullcodeline": "if (!ptr) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (state->ystep < 0) {"
    },
    {
        "line": 52,
        "fullcodeline": "for (c->tabindex = 0, c->bufindex = 0; c->tabindex < c->tablen; c->tabindex++, c->bufindex+=4)"
    },
    {
        "line": 53,
        "fullcodeline": "read4B(&c->starttab[c->tabindex], &ptr[c->bufindex]);"
    },
    {
        "line": 55,
        "fullcodeline": "for (c->tabindex = 0, c->bufindex = c->tablen * sizeof(UINT32); c->tabindex < c->tablen; c->tabindex++, c->bufindex+=4)"
    },
    {
        "line": 56,
        "fullcodeline": "read4B(&c->lengthtab[c->tabindex], &ptr[c->bufindex]);"
    },
    {
        "line": 61,
        "fullcodeline": "for (c->rowno = 0; c->rowno < im->ysize; c->rowno++, state->y += state->ystep)"
    },
    {
        "line": 103,
        "fullcodeline": "if (err != 0){"
    },
    {
        "line": 106,
        "fullcodeline": "return state->count - c->bufsize;"
    },
    {
        "line": 26,
        "fullcodeline": "state->y = im->ysize - 1;"
    },
    {
        "line": 31,
        "fullcodeline": "if (im->xsize > INT_MAX / im->bands ||"
    },
    {
        "line": 32,
        "fullcodeline": "im->ysize > INT_MAX / im->bands) {"
    },
    {
        "line": 33,
        "fullcodeline": "err = IMAGING_CODEC_MEMORY;"
    },
    {
        "line": 45,
        "fullcodeline": "if (!state->buffer ||"
    },
    {
        "line": 47,
        "fullcodeline": "!c->lengthtab) {"
    },
    {
        "line": 48,
        "fullcodeline": "err = IMAGING_CODEC_MEMORY;"
    },
    {
        "line": 92,
        "fullcodeline": "state->shuffle((UINT8*)im->image[state->y], state->buffer, im->xsize);"
    },
    {
        "line": 28,
        "fullcodeline": "state->ystep = 1;"
    },
    {
        "line": 46,
        "fullcodeline": "!c->starttab ||"
    },
    {
        "line": 63,
        "fullcodeline": "for (c->channo = 0; c->channo < im->bands; c->channo++)"
    },
    {
        "line": 65,
        "fullcodeline": "c->rleoffset = c->starttab[c->rowno + c->channo * im->ysize];"
    },
    {
        "line": 66,
        "fullcodeline": "c->rlelength = c->lengthtab[c->rowno + c->channo * im->ysize];"
    },
    {
        "line": 67,
        "fullcodeline": "c->rleoffset -= SGI_HEADER_SIZE;"
    },
    {
        "line": 88,
        "fullcodeline": "state->count += c->rlelength;"
    },
    {
        "line": 69,
        "fullcodeline": "if (c->rleoffset + c->rlelength > c->bufsize) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (status == -1) {"
    },
    {
        "line": 76,
        "fullcodeline": "status = expandrow(&state->buffer[c->channo], &ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);"
    },
    {
        "line": 71,
        "fullcodeline": "return -1;"
    },
    {
        "line": 79,
        "fullcodeline": "status = expandrow2(&state->buffer[c->channo * 2], &ptr[c->rleoffset], c->rlelength, im->bands, im->xsize);"
    },
    {
        "line": 83,
        "fullcodeline": "return -1;"
    }
]