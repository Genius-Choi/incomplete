[
    {
        "line": 2,
        "fullcodeline": "@requests_count +=1"
    },
    {
        "line": 4,
        "fullcodeline": "env = req.env"
    },
    {
        "line": 5,
        "fullcodeline": "client = req.io"
    },
    {
        "line": 9,
        "fullcodeline": "normalize_env env, req"
    },
    {
        "line": 11,
        "fullcodeline": "env[PUMA_SOCKET] = client"
    },
    {
        "line": 17,
        "fullcodeline": "env[HIJACK_P] = true"
    },
    {
        "line": 18,
        "fullcodeline": "env[HIJACK] = req"
    },
    {
        "line": 20,
        "fullcodeline": "body = req.body"
    },
    {
        "line": 22,
        "fullcodeline": "head = env[REQUEST_METHOD] == HEAD"
    },
    {
        "line": 24,
        "fullcodeline": "env[RACK_INPUT] = body"
    },
    {
        "line": 52,
        "fullcodeline": "after_reply = env[RACK_AFTER_REPLY] = []"
    },
    {
        "line": 7,
        "fullcodeline": "return false if closed_socket?(client)"
    },
    {
        "line": 13,
        "fullcodeline": "if env[HTTPS_KEY] && client.peercert"
    },
    {
        "line": 25,
        "fullcodeline": "env[RACK_URL_SCHEME] = default_server_port(env) == PORT_443 ? HTTPS : HTTP"
    },
    {
        "line": 14,
        "fullcodeline": "env[PUMA_PEERCERT] = client.peercert"
    },
    {
        "line": 28,
        "fullcodeline": "env[EARLY_HINTS] = lambda { |headers|"
    },
    {
        "line": 85,
        "fullcodeline": "content_length = nil"
    },
    {
        "line": 92,
        "fullcodeline": "cork_socket client"
    },
    {
        "line": 94,
        "fullcodeline": "line_ending = LINE_END"
    },
    {
        "line": 133,
        "fullcodeline": "response_hijack = nil"
    },
    {
        "line": 181,
        "fullcodeline": "lines << line_ending"
    },
    {
        "line": 183,
        "fullcodeline": "fast_write client, lines.to_s"
    },
    {
        "line": 97,
        "fullcodeline": "http_11 = if env[HTTP_VERSION] == HTTP_11"
    },
    {
        "line": 56,
        "fullcodeline": "status, headers, res_body = @app.call(env)"
    },
    {
        "line": 62,
        "fullcodeline": "status = status.to_i"
    },
    {
        "line": 88,
        "fullcodeline": "if res_body.kind_of? Array and res_body.size == 1"
    },
    {
        "line": 89,
        "fullcodeline": "content_length = res_body[0].bytesize"
    },
    {
        "line": 98,
        "fullcodeline": "allow_chunked = true"
    },
    {
        "line": 99,
        "fullcodeline": "keep_alive = env.fetch(HTTP_CONNECTION, \"\").downcase != CLOSE"
    },
    {
        "line": 116,
        "fullcodeline": "allow_chunked = false"
    },
    {
        "line": 117,
        "fullcodeline": "keep_alive = env.fetch(HTTP_CONNECTION, \"\").downcase == KEEP_ALIVE"
    },
    {
        "line": 115,
        "fullcodeline": "else"
    },
    {
        "line": 158,
        "fullcodeline": "lines << CONNECTION_KEEP_ALIVE"
    },
    {
        "line": 168,
        "fullcodeline": "lines << line_ending"
    },
    {
        "line": 169,
        "fullcodeline": "fast_write client, lines.to_s"
    },
    {
        "line": 174,
        "fullcodeline": "lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending"
    },
    {
        "line": 186,
        "fullcodeline": "response_hijack.call client"
    },
    {
        "line": 191,
        "fullcodeline": "res_body.each do |part|"
    },
    {
        "line": 64,
        "fullcodeline": "if status == -1"
    },
    {
        "line": 73,
        "fullcodeline": "@events.unknown_error self, e, \"Rack app\""
    },
    {
        "line": 75,
        "fullcodeline": "status = 503"
    },
    {
        "line": 76,
        "fullcodeline": "headers = {}"
    },
    {
        "line": 77,
        "fullcodeline": "res_body = [\"Request was internally terminated early\\n\"]"
    },
    {
        "line": 80,
        "fullcodeline": "@events.unknown_error self, e, \"Rack app\", env"
    },
    {
        "line": 82,
        "fullcodeline": "status, headers, res_body = lowlevel_error(e, env)"
    },
    {
        "line": 106,
        "fullcodeline": "if status == 200"
    },
    {
        "line": 122,
        "fullcodeline": "if status == 200"
    },
    {
        "line": 164,
        "fullcodeline": "if content_length and status != 204"
    },
    {
        "line": 60,
        "fullcodeline": "headers.reject! { |_k, v| CRLF_REGEX =~ v.to_s }"
    },
    {
        "line": 107,
        "fullcodeline": "lines << HTTP_11_200"
    },
    {
        "line": 109,
        "fullcodeline": "lines.append \"HTTP/1.1 \", status.to_s, \" \","
    },
    {
        "line": 123,
        "fullcodeline": "lines << HTTP_10_200"
    },
    {
        "line": 125,
        "fullcodeline": "lines.append \"HTTP/1.0 \", status.to_s, \" \","
    },
    {
        "line": 159,
        "fullcodeline": "elsif http_11 && !keep_alive"
    },
    {
        "line": 160,
        "fullcodeline": "lines << CONNECTION_CLOSE"
    },
    {
        "line": 165,
        "fullcodeline": "lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending"
    },
    {
        "line": 176,
        "fullcodeline": "elsif !response_hijack and allow_chunked"
    },
    {
        "line": 177,
        "fullcodeline": "lines << TRANSFER_ENCODING_CHUNKED"
    },
    {
        "line": 206,
        "fullcodeline": "fast_write client, CLOSE_CHUNKED"
    },
    {
        "line": 72,
        "fullcodeline": "@events.log \"Detected force shutdown of a thread, returning 503\""
    },
    {
        "line": 110,
        "fullcodeline": "fetch_status_code(status), line_ending"
    },
    {
        "line": 126,
        "fullcodeline": "fetch_status_code(status), line_ending"
    },
    {
        "line": 65,
        "fullcodeline": "unless headers.empty? and res_body == []"
    },
    {
        "line": 112,
        "fullcodeline": "no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]"
    },
    {
        "line": 128,
        "fullcodeline": "no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]"
    },
    {
        "line": 66,
        "fullcodeline": "raise \"async response must have empty headers and body\""
    }
]