[
    {
        "line": 3,
        "fullcodeline": "txSlot* instance = fxConstructTypedArray(the);"
    },
    {
        "line": 4,
        "fullcodeline": "txSlot* dispatch = instance->next;"
    },
    {
        "line": 5,
        "fullcodeline": "txSlot* view = dispatch->next;"
    },
    {
        "line": 6,
        "fullcodeline": "txSlot* buffer = view->next;"
    },
    {
        "line": 7,
        "fullcodeline": "txSlot* data = C_NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "if ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {"
    },
    {
        "line": 105,
        "fullcodeline": "txInteger length = fxArgToByteLength(the, 0, 0);"
    },
    {
        "line": 108,
        "fullcodeline": "length <<= shift;"
    },
    {
        "line": 109,
        "fullcodeline": "mxPush(mxArrayBufferConstructor);"
    },
    {
        "line": 110,
        "fullcodeline": "mxNew();"
    },
    {
        "line": 111,
        "fullcodeline": "mxPushInteger(length);"
    },
    {
        "line": 112,
        "fullcodeline": "mxRunCount(1);"
    },
    {
        "line": 113,
        "fullcodeline": "mxPullSlot(buffer);"
    },
    {
        "line": 114,
        "fullcodeline": "view->value.dataView.offset = 0;"
    },
    {
        "line": 115,
        "fullcodeline": "view->value.dataView.size = length;"
    },
    {
        "line": 13,
        "fullcodeline": "txInteger offset = fxArgToByteLength(the, 1, 0);"
    },
    {
        "line": 18,
        "fullcodeline": "size = fxArgToByteLength(the, 2, -1);"
    },
    {
        "line": 19,
        "fullcodeline": "info = fxGetBufferInfo(the, mxArgv(0));"
    },
    {
        "line": 36,
        "fullcodeline": "view->value.dataView.offset = offset;"
    },
    {
        "line": 37,
        "fullcodeline": "view->value.dataView.size = size;"
    },
    {
        "line": 38,
        "fullcodeline": "buffer->kind = XS_REFERENCE_KIND;"
    },
    {
        "line": 106,
        "fullcodeline": "if (length & (((1 << shift) - 1) << (32 - shift)))"
    },
    {
        "line": 16,
        "fullcodeline": "if (offset & ((1 << shift) - 1))"
    },
    {
        "line": 20,
        "fullcodeline": "if (size >= 0) {"
    },
    {
        "line": 107,
        "fullcodeline": "mxRangeError(\"out of range byteLength\");"
    },
    {
        "line": 11,
        "fullcodeline": "slot = mxArgv(0)->value.reference->next;"
    },
    {
        "line": 17,
        "fullcodeline": "mxRangeError(\"invalid byteOffset %ld\", offset);"
    },
    {
        "line": 21,
        "fullcodeline": "txInteger delta = size << shift;"
    },
    {
        "line": 22,
        "fullcodeline": "txInteger end = offset + delta;"
    },
    {
        "line": 25,
        "fullcodeline": "size = delta;"
    },
    {
        "line": 41,
        "fullcodeline": "else if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) {"
    },
    {
        "line": 23,
        "fullcodeline": "if ((info->value.bufferInfo.length < end) || (end < offset))"
    },
    {
        "line": 30,
        "fullcodeline": "size = info->value.bufferInfo.length - offset;"
    },
    {
        "line": 39,
        "fullcodeline": "buffer->value.reference = mxArgv(0)->value.reference;"
    },
    {
        "line": 42,
        "fullcodeline": "txSlot* sourceDispatch = slot;"
    },
    {
        "line": 43,
        "fullcodeline": "txSlot* sourceView = sourceDispatch->next;"
    },
    {
        "line": 44,
        "fullcodeline": "txSlot* sourceBuffer = sourceView->next;"
    },
    {
        "line": 46,
        "fullcodeline": "txInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;"
    },
    {
        "line": 50,
        "fullcodeline": "txInteger offset = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "txInteger size = sourceLength << shift;"
    },
    {
        "line": 53,
        "fullcodeline": "mxPushUninitialized();"
    },
    {
        "line": 55,
        "fullcodeline": "mxPush(mxArrayBufferConstructor);"
    },
    {
        "line": 65,
        "fullcodeline": "mxPushUndefined();"
    },
    {
        "line": 66,
        "fullcodeline": "mxPushUninitialized();"
    },
    {
        "line": 67,
        "fullcodeline": "mxPushUninitialized();"
    },
    {
        "line": 69,
        "fullcodeline": "sourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift;"
    },
    {
        "line": 70,
        "fullcodeline": "size = sourceLength << shift;"
    },
    {
        "line": 71,
        "fullcodeline": "mxPushInteger(size);"
    },
    {
        "line": 72,
        "fullcodeline": "mxRunCount(1);"
    },
    {
        "line": 73,
        "fullcodeline": "mxPullSlot(buffer);"
    },
    {
        "line": 74,
        "fullcodeline": "sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;"
    },
    {
        "line": 75,
        "fullcodeline": "size = sourceLength << shift;"
    },
    {
        "line": 77,
        "fullcodeline": "data = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);"
    },
    {
        "line": 78,
        "fullcodeline": "view->value.dataView.offset = offset;"
    },
    {
        "line": 79,
        "fullcodeline": "view->value.dataView.size = size;"
    },
    {
        "line": 24,
        "fullcodeline": "mxRangeError(\"out of range length %ld\", size);"
    },
    {
        "line": 28,
        "fullcodeline": "if (info->value.bufferInfo.length & ((1 << shift) - 1))"
    },
    {
        "line": 31,
        "fullcodeline": "if (size < 0)"
    },
    {
        "line": 33,
        "fullcodeline": "if (info->value.bufferInfo.maxLength >= 0)"
    },
    {
        "line": 57,
        "fullcodeline": "if (sourceData->kind == XS_ARRAY_BUFFER_KIND) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (dispatch == sourceDispatch)"
    },
    {
        "line": 101,
        "fullcodeline": "fx_TypedArray_from_object(the, instance, C_NULL, C_NULL);"
    },
    {
        "line": 29,
        "fullcodeline": "mxRangeError(\"invalid byteLength %ld\", info->value.bufferInfo.length);"
    },
    {
        "line": 32,
        "fullcodeline": "mxRangeError(\"out of range byteLength %ld\", size);"
    },
    {
        "line": 34,
        "fullcodeline": "size = -1;"
    },
    {
        "line": 58,
        "fullcodeline": "mxPushSlot(sourceBuffer);"
    },
    {
        "line": 59,
        "fullcodeline": "mxGetID(mxID(_constructor));"
    },
    {
        "line": 60,
        "fullcodeline": "fxToSpeciesConstructor(the, &mxArrayBufferConstructor);"
    },
    {
        "line": 81,
        "fullcodeline": "c_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size);"
    },
    {
        "line": 63,
        "fullcodeline": "mxPush(mxArrayBufferConstructor);"
    },
    {
        "line": 83,
        "fullcodeline": "txBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)"
    },
    {
        "line": 85,
        "fullcodeline": "txBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)"
    },
    {
        "line": 89,
        "fullcodeline": "mxPushUndefined();"
    },
    {
        "line": 97,
        "fullcodeline": "mxPop();"
    },
    {
        "line": 87,
        "fullcodeline": "if (contentType != sourceContentType)"
    },
    {
        "line": 90,
        "fullcodeline": "while (offset < size) {"
    },
    {
        "line": 84,
        "fullcodeline": "|| (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);"
    },
    {
        "line": 86,
        "fullcodeline": "|| (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);"
    },
    {
        "line": 88,
        "fullcodeline": "mxTypeError(\"incompatible content type\");"
    },
    {
        "line": 91,
        "fullcodeline": "(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);"
    },
    {
        "line": 92,
        "fullcodeline": "(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);"
    },
    {
        "line": 93,
        "fullcodeline": "(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);"
    },
    {
        "line": 94,
        "fullcodeline": "sourceOffset += sourceDelta;"
    },
    {
        "line": 95,
        "fullcodeline": "offset += 1 << shift;"
    }
]