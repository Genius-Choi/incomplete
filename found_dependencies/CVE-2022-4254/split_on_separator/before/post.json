[
    {
        "line": 6,
        "fullcodeline": "const char *substr_end = str;"
    },
    {
        "line": 7,
        "fullcodeline": "const char *substr_begin = str;"
    },
    {
        "line": 8,
        "fullcodeline": "const char *sep_pos = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "char **list = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "int num_strings = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "TALLOC_CTX *tmp_ctx = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "tmp_ctx = talloc_new(NULL);"
    },
    {
        "line": 81,
        "fullcodeline": "list[num_strings] = NULL;"
    },
    {
        "line": 87,
        "fullcodeline": "*_list = talloc_steal(mem_ctx, list);"
    },
    {
        "line": 88,
        "fullcodeline": "ret = EOK;"
    },
    {
        "line": 90,
        "fullcodeline": "talloc_free(tmp_ctx);"
    },
    {
        "line": 14,
        "fullcodeline": "if (str == NULL || *str == '\\0' || _list == NULL) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (tmp_ctx == NULL) {"
    },
    {
        "line": 71,
        "fullcodeline": "} while (*sep_pos != '\\0');"
    },
    {
        "line": 73,
        "fullcodeline": "if (list == NULL) {"
    },
    {
        "line": 24,
        "fullcodeline": "substr_len = 0;"
    },
    {
        "line": 38,
        "fullcodeline": "sep_pos = substr_end;"
    },
    {
        "line": 84,
        "fullcodeline": "*size = num_strings;"
    },
    {
        "line": 27,
        "fullcodeline": "if (sep_pos != NULL) {"
    },
    {
        "line": 33,
        "fullcodeline": "while (*substr_end != sep && *substr_end != '\\0') {"
    },
    {
        "line": 55,
        "fullcodeline": "if (skip_empty == false || substr_len > 0) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (list == NULL) {"
    },
    {
        "line": 28,
        "fullcodeline": "substr_end = sep_pos + 1;"
    },
    {
        "line": 29,
        "fullcodeline": "substr_begin = sep_pos + 1;"
    },
    {
        "line": 34,
        "fullcodeline": "substr_end++;"
    },
    {
        "line": 35,
        "fullcodeline": "substr_len++;"
    },
    {
        "line": 63,
        "fullcodeline": "list[num_strings] = talloc_strndup(list, substr_begin, substr_len);"
    },
    {
        "line": 68,
        "fullcodeline": "num_strings++;"
    },
    {
        "line": 77,
        "fullcodeline": "ret = ENOMEM;"
    },
    {
        "line": 42,
        "fullcodeline": "while (isspace(*substr_begin) && substr_begin < substr_end) {"
    },
    {
        "line": 48,
        "fullcodeline": "while (substr_end - 1 > substr_begin && isspace(*(substr_end-1))) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (list == NULL) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (list[num_strings] == NULL) {"
    },
    {
        "line": 43,
        "fullcodeline": "substr_begin++;"
    },
    {
        "line": 44,
        "fullcodeline": "substr_len--;"
    },
    {
        "line": 49,
        "fullcodeline": "substr_end--;"
    },
    {
        "line": 50,
        "fullcodeline": "substr_len--;"
    },
    {
        "line": 58,
        "fullcodeline": "ret = ENOMEM;"
    },
    {
        "line": 65,
        "fullcodeline": "ret = ENOMEM;"
    }
]