[
    {
        "line": 7,
        "fullcodeline": "sigemptyset(&sigm);"
    },
    {
        "line": 8,
        "fullcodeline": "sigaddset(&sigm, SIGTERM);"
    },
    {
        "line": 9,
        "fullcodeline": "sigprocmask(SIG_BLOCK, &sigm, &sigm_old);"
    },
    {
        "line": 11,
        "fullcodeline": "pid = fork();"
    },
    {
        "line": 12,
        "fullcodeline": "if ( pid < 0 ) {"
    },
    {
        "line": 13,
        "fullcodeline": "sigprocmask(SIG_SETMASK, &sigm_old, NULL);"
    },
    {
        "line": 14,
        "fullcodeline": "fd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));"
    },
    {
        "line": 15,
        "fullcodeline": "return -1;"
    },
    {
        "line": 21,
        "fullcodeline": "sigprocmask(SIG_SETMASK, &sigm_old, NULL);"
    },
    {
        "line": 27,
        "fullcodeline": "term_apply(STI);"
    },
    {
        "line": 25,
        "fullcodeline": "} while ( r < 0 && errno == EINTR );"
    },
    {
        "line": 29,
        "fullcodeline": "if ( WIFEXITED(status) ) {"
    },
    {
        "line": 44,
        "fullcodeline": "char cmd[512];"
    },
    {
        "line": 47,
        "fullcodeline": "term_remove(STI);"
    },
    {
        "line": 49,
        "fullcodeline": "term_erase(fd);"
    },
    {
        "line": 51,
        "fullcodeline": "fl = fcntl(fd, F_GETFL);"
    },
    {
        "line": 52,
        "fullcodeline": "fl &= ~O_NONBLOCK;"
    },
    {
        "line": 53,
        "fullcodeline": "fcntl(fd, F_SETFL, fl);"
    },
    {
        "line": 55,
        "fullcodeline": "close(STI);"
    },
    {
        "line": 56,
        "fullcodeline": "close(STO);"
    },
    {
        "line": 57,
        "fullcodeline": "dup2(fd, STI);"
    },
    {
        "line": 58,
        "fullcodeline": "dup2(fd, STO);"
    },
    {
        "line": 80,
        "fullcodeline": "fd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);"
    },
    {
        "line": 81,
        "fullcodeline": "establish_child_signal_handlers();"
    },
    {
        "line": 82,
        "fullcodeline": "sigprocmask(SIG_SETMASK, &sigm_old, NULL);"
    },
    {
        "line": 83,
        "fullcodeline": "execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);"
    },
    {
        "line": 84,
        "fullcodeline": "exit(42);"
    },
    {
        "line": 24,
        "fullcodeline": "r = waitpid(pid, &status, 0);"
    },
    {
        "line": 30,
        "fullcodeline": "fd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\","
    },
    {
        "line": 66,
        "fullcodeline": "strcpy(cmd, EXEC);"
    },
    {
        "line": 67,
        "fullcodeline": "c = &cmd[sizeof(EXEC)- 1];"
    },
    {
        "line": 68,
        "fullcodeline": "ce = cmd + sizeof(cmd) - 1;"
    },
    {
        "line": 69,
        "fullcodeline": "va_start(vls, fd);"
    },
    {
        "line": 76,
        "fullcodeline": "va_end(vls);"
    },
    {
        "line": 77,
        "fullcodeline": "*c = '\\0';"
    },
    {
        "line": 31,
        "fullcodeline": "WEXITSTATUS(status));"
    },
    {
        "line": 32,
        "fullcodeline": "return WEXITSTATUS(status);"
    },
    {
        "line": 33,
        "fullcodeline": "} else if ( WIFSIGNALED(status) ) {"
    },
    {
        "line": 71,
        "fullcodeline": "n = strlen(s);"
    },
    {
        "line": 73,
        "fullcodeline": "memcpy(c, s, n); c += n;"
    },
    {
        "line": 74,
        "fullcodeline": "*c++ = ' ';"
    },
    {
        "line": 34,
        "fullcodeline": "fd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\","
    },
    {
        "line": 72,
        "fullcodeline": "if ( c + n + 1 >= ce ) break;"
    },
    {
        "line": 35,
        "fullcodeline": "WTERMSIG(status));"
    },
    {
        "line": 36,
        "fullcodeline": "return -1;"
    },
    {
        "line": 38,
        "fullcodeline": "fd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);"
    },
    {
        "line": 39,
        "fullcodeline": "return -1;"
    }
]