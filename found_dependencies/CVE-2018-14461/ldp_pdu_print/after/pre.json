[
    {
        "line": 11,
        "fullcodeline": "ldp_com_header = (const struct ldp_common_header *)pptr;"
    },
    {
        "line": 12,
        "fullcodeline": "ND_TCHECK(*ldp_com_header);"
    },
    {
        "line": 24,
        "fullcodeline": "pdu_len = EXTRACT_16BITS(&ldp_com_header->pdu_length);"
    },
    {
        "line": 46,
        "fullcodeline": "tptr = pptr + sizeof(const struct ldp_common_header);"
    },
    {
        "line": 47,
        "fullcodeline": "tlen = pdu_len - (sizeof(const struct ldp_common_header)-4);\t/* Type & Length fields not included */"
    },
    {
        "line": 17,
        "fullcodeline": "if (EXTRACT_16BITS(&ldp_com_header->version) != LDP_VERSION) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (pdu_len < sizeof(const struct ldp_common_header)-4) {"
    },
    {
        "line": 35,
        "fullcodeline": "ND_PRINT((ndo, \"%sLDP, Label-Space-ID: %s:%u, pdu-length: %u\","
    },
    {
        "line": 42,
        "fullcodeline": "if (ndo->ndo_vflag < 1)"
    },
    {
        "line": 49,
        "fullcodeline": "while(tlen>0) {"
    },
    {
        "line": 128,
        "fullcodeline": "return pdu_len+4;"
    },
    {
        "line": 18,
        "fullcodeline": "ND_PRINT((ndo, \"%sLDP version %u packet not supported\","
    },
    {
        "line": 51,
        "fullcodeline": "ND_TCHECK2(*tptr, sizeof(struct ldp_msg_header));"
    },
    {
        "line": 53,
        "fullcodeline": "ldp_msg_header = (const struct ldp_msg_header *)tptr;"
    },
    {
        "line": 54,
        "fullcodeline": "msg_len=EXTRACT_16BITS(ldp_msg_header->length);"
    },
    {
        "line": 55,
        "fullcodeline": "msg_type=LDP_MASK_MSG_TYPE(EXTRACT_16BITS(ldp_msg_header->type));"
    },
    {
        "line": 80,
        "fullcodeline": "msg_tptr=tptr+sizeof(struct ldp_msg_header);"
    },
    {
        "line": 81,
        "fullcodeline": "msg_tlen=msg_len-(sizeof(struct ldp_msg_header)-4); /* Type & Length fields not included */"
    },
    {
        "line": 84,
        "fullcodeline": "ND_TCHECK2(*tptr, msg_len);"
    },
    {
        "line": 85,
        "fullcodeline": "hexdump=FALSE;"
    },
    {
        "line": 125,
        "fullcodeline": "tptr += msg_len+4;"
    },
    {
        "line": 126,
        "fullcodeline": "tlen -= msg_len+4;"
    },
    {
        "line": 130,
        "fullcodeline": "ND_PRINT((ndo, \"%s\", tstr));"
    },
    {
        "line": 27,
        "fullcodeline": "ND_PRINT((ndo, \"%sLDP, pdu-length: %u (too short, < %u)\","
    },
    {
        "line": 37,
        "fullcodeline": "ipaddr_string(ndo, &ldp_com_header->lsr_id),"
    },
    {
        "line": 38,
        "fullcodeline": "EXTRACT_16BITS(&ldp_com_header->label_space),"
    },
    {
        "line": 57,
        "fullcodeline": "if (msg_len < sizeof(struct ldp_msg_header)-4) {"
    },
    {
        "line": 71,
        "fullcodeline": "ND_PRINT((ndo, \"\\n\\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]\","
    },
    {
        "line": 36,
        "fullcodeline": "(ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\","
    },
    {
        "line": 121,
        "fullcodeline": "if (ndo->ndo_vflag > 1 || hexdump==TRUE)"
    },
    {
        "line": 122,
        "fullcodeline": "print_unknown_data(ndo, tptr+sizeof(struct ldp_msg_header), \"\\n\\t  \","
    },
    {
        "line": 19,
        "fullcodeline": "(ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\","
    },
    {
        "line": 20,
        "fullcodeline": "EXTRACT_16BITS(&ldp_com_header->version)));"
    },
    {
        "line": 30,
        "fullcodeline": "(u_int)(sizeof(const struct ldp_common_header)-4)));"
    },
    {
        "line": 60,
        "fullcodeline": "ND_PRINT((ndo, \"\\n\\t  %s Message (0x%04x), length: %u (too short, < %u)\","
    },
    {
        "line": 72,
        "fullcodeline": "tok2str(ldp_msg_values,"
    },
    {
        "line": 77,
        "fullcodeline": "EXTRACT_32BITS(&ldp_msg_header->id),"
    },
    {
        "line": 97,
        "fullcodeline": "while(msg_tlen >= 4) {"
    },
    {
        "line": 116,
        "fullcodeline": "if (ndo->ndo_vflag <= 1)"
    },
    {
        "line": 28,
        "fullcodeline": "(ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\","
    },
    {
        "line": 98,
        "fullcodeline": "processed = ldp_tlv_print(ndo, msg_tptr, msg_tlen);"
    },
    {
        "line": 101,
        "fullcodeline": "msg_tlen-=processed;"
    },
    {
        "line": 102,
        "fullcodeline": "msg_tptr+=processed;"
    },
    {
        "line": 117,
        "fullcodeline": "print_unknown_data(ndo, msg_tptr, \"\\n\\t  \", msg_tlen);"
    },
    {
        "line": 61,
        "fullcodeline": "tok2str(ldp_msg_values,"
    },
    {
        "line": 66,
        "fullcodeline": "(u_int)(sizeof(struct ldp_msg_header)-4)));"
    },
    {
        "line": 78,
        "fullcodeline": "LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_msg_header->type)) ? \"continue processing\" : \"ignore\"));"
    },
    {
        "line": 99,
        "fullcodeline": "if (processed == 0)"
    }
]