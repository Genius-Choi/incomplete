[
    {
        "line": 13,
        "fullcodeline": "const int num_values = PySequence_Size(py_list);"
    },
    {
        "line": 5,
        "fullcodeline": "if (!PySequence_Check(py_list)) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;"
    },
    {
        "line": 32,
        "fullcodeline": "if (type == TF_ATTR_STRING) {"
    },
    {
        "line": 6,
        "fullcodeline": "TF_SetStatus("
    },
    {
        "line": 33,
        "fullcodeline": "std::unique_ptr<const void*[]> values(new const void*[num_values]);"
    },
    {
        "line": 34,
        "fullcodeline": "std::unique_ptr<size_t[]> lengths(new size_t[num_values]);"
    },
    {
        "line": 42,
        "fullcodeline": "TFE_OpSetAttrStringList(op, key, values.get(), lengths.get(), num_values);"
    },
    {
        "line": 8,
        "fullcodeline": "tensorflow::strings::StrCat(\"Expecting sequence value for attr \", key,"
    },
    {
        "line": 35,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 37,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 39,
        "fullcodeline": "values[i] = value.data();"
    },
    {
        "line": 40,
        "fullcodeline": "lengths[i] = value.size();"
    },
    {
        "line": 43,
        "fullcodeline": "} else if (type == TF_ATTR_INT) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (!ParseStringValue(key, py_value.get(), status, &value)) return false;"
    },
    {
        "line": 44,
        "fullcodeline": "PARSE_LIST(int64_t, ParseInt64Value);"
    },
    {
        "line": 45,
        "fullcodeline": "TFE_OpSetAttrIntList(op, key, values.get(), num_values);"
    },
    {
        "line": 46,
        "fullcodeline": "} else if (type == TF_ATTR_FLOAT) {"
    },
    {
        "line": 47,
        "fullcodeline": "PARSE_LIST(float, ParseFloatValue);"
    },
    {
        "line": 48,
        "fullcodeline": "TFE_OpSetAttrFloatList(op, key, values.get(), num_values);"
    },
    {
        "line": 49,
        "fullcodeline": "} else if (type == TF_ATTR_BOOL) {"
    },
    {
        "line": 50,
        "fullcodeline": "PARSE_LIST(unsigned char, ParseBoolValue);"
    },
    {
        "line": 51,
        "fullcodeline": "TFE_OpSetAttrBoolList(op, key, values.get(), num_values);"
    },
    {
        "line": 52,
        "fullcodeline": "} else if (type == TF_ATTR_TYPE) {"
    },
    {
        "line": 53,
        "fullcodeline": "PARSE_LIST(int, ParseTypeValue);"
    },
    {
        "line": 54,
        "fullcodeline": "TFE_OpSetAttrTypeList(op, key,"
    },
    {
        "line": 55,
        "fullcodeline": "reinterpret_cast<const TF_DataType*>(values.get()),"
    },
    {
        "line": 57,
        "fullcodeline": "} else if (type == TF_ATTR_SHAPE) {"
    },
    {
        "line": 60,
        "fullcodeline": "int total_dims = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "std::unique_ptr<int64_t[]> buffer(new int64_t[total_dims]);"
    },
    {
        "line": 83,
        "fullcodeline": "std::unique_ptr<const int64_t*[]> dims(new const int64_t*[num_values]);"
    },
    {
        "line": 84,
        "fullcodeline": "std::unique_ptr<int[]> num_dims(new int[num_values]);"
    },
    {
        "line": 85,
        "fullcodeline": "int64_t* offset = buffer.get();"
    },
    {
        "line": 113,
        "fullcodeline": "TFE_OpSetAttrShapeList(op, key, dims.get(), num_dims.get(), num_values,"
    },
    {
        "line": 61,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 86,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (!status->status.ok()) return false;"
    },
    {
        "line": 62,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 87,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 116,
        "fullcodeline": "} else if (type == TF_ATTR_FUNC) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (py_value.get() != Py_None) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (py_value.get() == Py_None) {"
    },
    {
        "line": 117,
        "fullcodeline": "std::unique_ptr<const TFE_Op*[]> funcs(new const TFE_Op*[num_values]);"
    },
    {
        "line": 148,
        "fullcodeline": "TFE_OpSetAttrFunctionList(op, key, funcs.get(), num_values);"
    },
    {
        "line": 73,
        "fullcodeline": "const auto size = TensorShapeNumDims(py_value.get());"
    },
    {
        "line": 89,
        "fullcodeline": "dims[i] = nullptr;"
    },
    {
        "line": 90,
        "fullcodeline": "num_dims[i] = -1;"
    },
    {
        "line": 118,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (!status->status.ok()) return false;"
    },
    {
        "line": 151,
        "fullcodeline": "TF_SetStatus(status, TF_UNIMPLEMENTED,"
    },
    {
        "line": 64,
        "fullcodeline": "if (!PySequence_Check(py_value.get())) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (size >= 0) {"
    },
    {
        "line": 92,
        "fullcodeline": "const auto size = TensorShapeNumDims(py_value.get());"
    },
    {
        "line": 98,
        "fullcodeline": "dims[i] = offset;"
    },
    {
        "line": 99,
        "fullcodeline": "num_dims[i] = size;"
    },
    {
        "line": 119,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 145,
        "fullcodeline": "funcs[i] = TFE_NewOp(ctx, func_name.data(), status);"
    },
    {
        "line": 152,
        "fullcodeline": "tensorflow::strings::StrCat(\"Attr \", key,"
    },
    {
        "line": 65,
        "fullcodeline": "TF_SetStatus("
    },
    {
        "line": 75,
        "fullcodeline": "total_dims += size;"
    },
    {
        "line": 93,
        "fullcodeline": "if (size == -1) {"
    },
    {
        "line": 100,
        "fullcodeline": "for (int j = 0; j < size; ++j) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (!ParseStringValue(key, py_value.get(), status, &func_name)) {"
    },
    {
        "line": 146,
        "fullcodeline": "if (!status->status.ok()) return false;"
    },
    {
        "line": 67,
        "fullcodeline": "tensorflow::strings::StrCat("
    },
    {
        "line": 94,
        "fullcodeline": "dims[i] = nullptr;"
    },
    {
        "line": 95,
        "fullcodeline": "num_dims[i] = -1;"
    },
    {
        "line": 101,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr inner_py_value("
    },
    {
        "line": 109,
        "fullcodeline": "++offset;"
    },
    {
        "line": 130,
        "fullcodeline": "PyObject* name_attr = PyObject_GetAttrString(py_value.get(), \"name\");"
    },
    {
        "line": 102,
        "fullcodeline": "PySequence_ITEM(py_value.get(), j));"
    },
    {
        "line": 103,
        "fullcodeline": "if (inner_py_value.get() == Py_None) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (name_attr == nullptr ||"
    },
    {
        "line": 104,
        "fullcodeline": "*offset = -1;"
    },
    {
        "line": 132,
        "fullcodeline": "!ParseStringValue(key, name_attr, status, &func_name)) {"
    },
    {
        "line": 133,
        "fullcodeline": "TF_SetStatus("
    },
    {
        "line": 135,
        "fullcodeline": "tensorflow::strings::StrCat("
    },
    {
        "line": 105,
        "fullcodeline": "} else if (!ParseDimensionValue(key, inner_py_value.get(), status,"
    },
    {
        "line": 137,
        "fullcodeline": "py_value.get()->ob_type->tp_name,"
    }
]