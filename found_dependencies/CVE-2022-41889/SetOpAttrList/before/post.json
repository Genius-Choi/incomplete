[
    {
        "line": 13,
        "fullcodeline": "const int num_values = PySequence_Size(py_list);"
    },
    {
        "line": 5,
        "fullcodeline": "if (!PySequence_Check(py_list)) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (attr_list_sizes != nullptr) (*attr_list_sizes)[key] = num_values;"
    },
    {
        "line": 23,
        "fullcodeline": "if (type == TF_ATTR_STRING) {"
    },
    {
        "line": 6,
        "fullcodeline": "TF_SetStatus("
    },
    {
        "line": 24,
        "fullcodeline": "std::unique_ptr<const void*[]> values(new const void*[num_values]);"
    },
    {
        "line": 25,
        "fullcodeline": "std::unique_ptr<size_t[]> lengths(new size_t[num_values]);"
    },
    {
        "line": 33,
        "fullcodeline": "TFE_OpSetAttrStringList(op, key, values.get(), lengths.get(), num_values);"
    },
    {
        "line": 8,
        "fullcodeline": "tensorflow::strings::StrCat(\"Expecting sequence value for attr \", key,"
    },
    {
        "line": 26,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 28,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 30,
        "fullcodeline": "values[i] = value.data();"
    },
    {
        "line": 31,
        "fullcodeline": "lengths[i] = value.size();"
    },
    {
        "line": 34,
        "fullcodeline": "} else if (type == TF_ATTR_INT) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (!ParseStringValue(key, py_value.get(), status, &value)) return false;"
    },
    {
        "line": 35,
        "fullcodeline": "PARSE_LIST(int64_t, ParseInt64Value);"
    },
    {
        "line": 36,
        "fullcodeline": "TFE_OpSetAttrIntList(op, key, values.get(), num_values);"
    },
    {
        "line": 37,
        "fullcodeline": "} else if (type == TF_ATTR_FLOAT) {"
    },
    {
        "line": 38,
        "fullcodeline": "PARSE_LIST(float, ParseFloatValue);"
    },
    {
        "line": 39,
        "fullcodeline": "TFE_OpSetAttrFloatList(op, key, values.get(), num_values);"
    },
    {
        "line": 40,
        "fullcodeline": "} else if (type == TF_ATTR_BOOL) {"
    },
    {
        "line": 41,
        "fullcodeline": "PARSE_LIST(unsigned char, ParseBoolValue);"
    },
    {
        "line": 42,
        "fullcodeline": "TFE_OpSetAttrBoolList(op, key, values.get(), num_values);"
    },
    {
        "line": 43,
        "fullcodeline": "} else if (type == TF_ATTR_TYPE) {"
    },
    {
        "line": 44,
        "fullcodeline": "PARSE_LIST(int, ParseTypeValue);"
    },
    {
        "line": 45,
        "fullcodeline": "TFE_OpSetAttrTypeList(op, key,"
    },
    {
        "line": 46,
        "fullcodeline": "reinterpret_cast<const TF_DataType*>(values.get()),"
    },
    {
        "line": 48,
        "fullcodeline": "} else if (type == TF_ATTR_SHAPE) {"
    },
    {
        "line": 51,
        "fullcodeline": "int total_dims = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "std::unique_ptr<int64_t[]> buffer(new int64_t[total_dims]);"
    },
    {
        "line": 74,
        "fullcodeline": "std::unique_ptr<const int64_t*[]> dims(new const int64_t*[num_values]);"
    },
    {
        "line": 75,
        "fullcodeline": "std::unique_ptr<int[]> num_dims(new int[num_values]);"
    },
    {
        "line": 76,
        "fullcodeline": "int64_t* offset = buffer.get();"
    },
    {
        "line": 104,
        "fullcodeline": "TFE_OpSetAttrShapeList(op, key, dims.get(), num_dims.get(), num_values,"
    },
    {
        "line": 52,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 77,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 106,
        "fullcodeline": "if (!status->status.ok()) return false;"
    },
    {
        "line": 53,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 78,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 107,
        "fullcodeline": "} else if (type == TF_ATTR_FUNC) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (py_value.get() != Py_None) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (py_value.get() == Py_None) {"
    },
    {
        "line": 108,
        "fullcodeline": "std::unique_ptr<const TFE_Op*[]> funcs(new const TFE_Op*[num_values]);"
    },
    {
        "line": 139,
        "fullcodeline": "TFE_OpSetAttrFunctionList(op, key, funcs.get(), num_values);"
    },
    {
        "line": 64,
        "fullcodeline": "const auto size = TensorShapeNumDims(py_value.get());"
    },
    {
        "line": 80,
        "fullcodeline": "dims[i] = nullptr;"
    },
    {
        "line": 81,
        "fullcodeline": "num_dims[i] = -1;"
    },
    {
        "line": 109,
        "fullcodeline": "for (int i = 0; i < num_values; ++i) {"
    },
    {
        "line": 140,
        "fullcodeline": "if (!status->status.ok()) return false;"
    },
    {
        "line": 142,
        "fullcodeline": "TF_SetStatus(status, TF_UNIMPLEMENTED,"
    },
    {
        "line": 55,
        "fullcodeline": "if (!PySequence_Check(py_value.get())) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (size >= 0) {"
    },
    {
        "line": 83,
        "fullcodeline": "const auto size = TensorShapeNumDims(py_value.get());"
    },
    {
        "line": 89,
        "fullcodeline": "dims[i] = offset;"
    },
    {
        "line": 90,
        "fullcodeline": "num_dims[i] = size;"
    },
    {
        "line": 110,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr py_value(PySequence_ITEM(py_list, i));"
    },
    {
        "line": 136,
        "fullcodeline": "funcs[i] = TFE_NewOp(ctx, func_name.data(), status);"
    },
    {
        "line": 143,
        "fullcodeline": "tensorflow::strings::StrCat(\"Attr \", key,"
    },
    {
        "line": 56,
        "fullcodeline": "TF_SetStatus("
    },
    {
        "line": 66,
        "fullcodeline": "total_dims += size;"
    },
    {
        "line": 84,
        "fullcodeline": "if (size == -1) {"
    },
    {
        "line": 91,
        "fullcodeline": "for (int j = 0; j < size; ++j) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (!ParseStringValue(key, py_value.get(), status, &func_name)) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (!status->status.ok()) return false;"
    },
    {
        "line": 58,
        "fullcodeline": "tensorflow::strings::StrCat("
    },
    {
        "line": 85,
        "fullcodeline": "dims[i] = nullptr;"
    },
    {
        "line": 86,
        "fullcodeline": "num_dims[i] = -1;"
    },
    {
        "line": 92,
        "fullcodeline": "tensorflow::Safe_PyObjectPtr inner_py_value("
    },
    {
        "line": 100,
        "fullcodeline": "++offset;"
    },
    {
        "line": 121,
        "fullcodeline": "PyObject* name_attr = PyObject_GetAttrString(py_value.get(), \"name\");"
    },
    {
        "line": 93,
        "fullcodeline": "PySequence_ITEM(py_value.get(), j));"
    },
    {
        "line": 94,
        "fullcodeline": "if (inner_py_value.get() == Py_None) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (name_attr == nullptr ||"
    },
    {
        "line": 95,
        "fullcodeline": "*offset = -1;"
    },
    {
        "line": 123,
        "fullcodeline": "!ParseStringValue(key, name_attr, status, &func_name)) {"
    },
    {
        "line": 124,
        "fullcodeline": "TF_SetStatus("
    },
    {
        "line": 126,
        "fullcodeline": "tensorflow::strings::StrCat("
    },
    {
        "line": 96,
        "fullcodeline": "} else if (!ParseDimensionValue(key, inner_py_value.get(), status,"
    },
    {
        "line": 128,
        "fullcodeline": "py_value.get()->ob_type->tp_name,"
    }
]