[
    {
        "line": 4,
        "fullcodeline": "struct mm_struct *mm = vma->vm_mm;"
    },
    {
        "line": 6,
        "fullcodeline": "int error = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "address &= PAGE_MASK;"
    },
    {
        "line": 13,
        "fullcodeline": "prev = vma->vm_prev;"
    },
    {
        "line": 30,
        "fullcodeline": "anon_vma_lock_write(vma->anon_vma);"
    },
    {
        "line": 69,
        "fullcodeline": "anon_vma_unlock_write(vma->anon_vma);"
    },
    {
        "line": 70,
        "fullcodeline": "khugepaged_enter_vma_merge(vma, vma->vm_flags);"
    },
    {
        "line": 71,
        "fullcodeline": "validate_mm(mm);"
    },
    {
        "line": 9,
        "fullcodeline": "if (address < mmap_min_addr)"
    },
    {
        "line": 15,
        "fullcodeline": "if (prev && !(prev->vm_flags & VM_GROWSDOWN) &&"
    },
    {
        "line": 22,
        "fullcodeline": "if (unlikely(anon_vma_prepare(vma)))"
    },
    {
        "line": 33,
        "fullcodeline": "if (address < vma->vm_start) {"
    },
    {
        "line": 16,
        "fullcodeline": "(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {"
    },
    {
        "line": 36,
        "fullcodeline": "size = vma->vm_end - address;"
    },
    {
        "line": 37,
        "fullcodeline": "grow = (vma->vm_start - address) >> PAGE_SHIFT;"
    },
    {
        "line": 39,
        "fullcodeline": "error = -ENOMEM;"
    },
    {
        "line": 10,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 17,
        "fullcodeline": "if (address - prev->vm_end < stack_guard_gap)"
    },
    {
        "line": 23,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 40,
        "fullcodeline": "if (grow <= vma->vm_pgoff) {"
    },
    {
        "line": 41,
        "fullcodeline": "error = acct_stack_growth(vma, size, grow);"
    },
    {
        "line": 18,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 42,
        "fullcodeline": "if (!error) {"
    },
    {
        "line": 54,
        "fullcodeline": "spin_lock(&mm->page_table_lock);"
    },
    {
        "line": 57,
        "fullcodeline": "vm_stat_account(mm, vma->vm_flags, grow);"
    },
    {
        "line": 58,
        "fullcodeline": "anon_vma_interval_tree_pre_update_vma(vma);"
    },
    {
        "line": 59,
        "fullcodeline": "vma->vm_start = address;"
    },
    {
        "line": 60,
        "fullcodeline": "vma->vm_pgoff -= grow;"
    },
    {
        "line": 61,
        "fullcodeline": "anon_vma_interval_tree_post_update_vma(vma);"
    },
    {
        "line": 62,
        "fullcodeline": "vma_gap_update(vma);"
    },
    {
        "line": 63,
        "fullcodeline": "spin_unlock(&mm->page_table_lock);"
    },
    {
        "line": 65,
        "fullcodeline": "perf_event_mmap(vma);"
    },
    {
        "line": 55,
        "fullcodeline": "if (vma->vm_flags & VM_LOCKED)"
    },
    {
        "line": 56,
        "fullcodeline": "mm->locked_vm += grow;"
    }
]