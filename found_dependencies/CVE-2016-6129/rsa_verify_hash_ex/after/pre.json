[
    {
        "line": 11,
        "fullcodeline": "LTC_ARGCHK(hash  != NULL);"
    },
    {
        "line": 12,
        "fullcodeline": "LTC_ARGCHK(sig   != NULL);"
    },
    {
        "line": 13,
        "fullcodeline": "LTC_ARGCHK(stat  != NULL);"
    },
    {
        "line": 14,
        "fullcodeline": "LTC_ARGCHK(key   != NULL);"
    },
    {
        "line": 17,
        "fullcodeline": "*stat = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "modulus_bitlen = mp_count_bits( (key->N));"
    },
    {
        "line": 37,
        "fullcodeline": "modulus_bytelen = mp_unsigned_bin_size( (key->N));"
    },
    {
        "line": 43,
        "fullcodeline": "tmpbuf = XMALLOC(siglen);"
    },
    {
        "line": 49,
        "fullcodeline": "x = siglen;"
    },
    {
        "line": 21,
        "fullcodeline": "if ((padding != LTC_PKCS_1_V1_5) &&"
    },
    {
        "line": 26,
        "fullcodeline": "if (padding == LTC_PKCS_1_PSS) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (modulus_bytelen != siglen) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (tmpbuf == NULL) {"
    },
    {
        "line": 50,
        "fullcodeline": "if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (x != siglen) {"
    },
    {
        "line": 22,
        "fullcodeline": "(padding != LTC_PKCS_1_PSS)) {"
    },
    {
        "line": 28,
        "fullcodeline": "if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {"
    },
    {
        "line": 76,
        "fullcodeline": "ltc_asn1_list digestinfo[2], siginfo[2];"
    },
    {
        "line": 85,
        "fullcodeline": "outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;"
    },
    {
        "line": 86,
        "fullcodeline": "out    = XMALLOC(outlen);"
    },
    {
        "line": 106,
        "fullcodeline": "LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));"
    },
    {
        "line": 107,
        "fullcodeline": "LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);"
    },
    {
        "line": 108,
        "fullcodeline": "LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);"
    },
    {
        "line": 109,
        "fullcodeline": "LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);"
    },
    {
        "line": 64,
        "fullcodeline": "if(modulus_bitlen%8 == 1){"
    },
    {
        "line": 65,
        "fullcodeline": "err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);"
    },
    {
        "line": 74,
        "fullcodeline": "unsigned long outlen, loid[16], reallen;"
    },
    {
        "line": 79,
        "fullcodeline": "if (hash_descriptor[hash_idx].OIDlen == 0) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (out == NULL) {"
    },
    {
        "line": 92,
        "fullcodeline": "if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {"
    },
    {
        "line": 111,
        "fullcodeline": "if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {"
    },
    {
        "line": 68,
        "fullcodeline": "err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);"
    },
    {
        "line": 80,
        "fullcodeline": "err = CRYPT_INVALID_ARG;"
    },
    {
        "line": 88,
        "fullcodeline": "err = CRYPT_MEM;"
    },
    {
        "line": 116,
        "fullcodeline": "if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {"
    },
    {
        "line": 122,
        "fullcodeline": "if ((reallen == outlen) &&"
    },
    {
        "line": 126,
        "fullcodeline": "(XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {"
    },
    {
        "line": 125,
        "fullcodeline": "(siginfo[1].size == hashlen) &&"
    },
    {
        "line": 124,
        "fullcodeline": "(XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&"
    },
    {
        "line": 123,
        "fullcodeline": "(digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&"
    }
]