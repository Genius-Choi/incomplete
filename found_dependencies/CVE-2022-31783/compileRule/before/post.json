[
    {
        "line": 10,
        "fullcodeline": "TranslationTableCharacterAttributes after = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "TranslationTableCharacterAttributes before = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "noback = nofor = nocross = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "opcode = getOpcode(file, &token);"
    },
    {
        "line": 15,
        "fullcodeline": "if (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */"
    },
    {
        "line": 16,
        "fullcodeline": "if (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */"
    },
    {
        "line": 17,
        "fullcodeline": "if (file->lineNumber == 1 &&"
    },
    {
        "line": 18,
        "fullcodeline": "(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||"
    },
    {
        "line": 58,
        "fullcodeline": "noback = 1;"
    },
    {
        "line": 65,
        "fullcodeline": "nofor = 1;"
    },
    {
        "line": 19,
        "fullcodeline": "eqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {"
    },
    {
        "line": 43,
        "fullcodeline": "compileError(file, \"Macro feature is disabled.\");"
    },
    {
        "line": 68,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 71,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 74,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 77,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 80,
        "fullcodeline": "return compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);"
    },
    {
        "line": 82,
        "fullcodeline": "return compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);"
    },
    {
        "line": 84,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 87,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 90,
        "fullcodeline": "return compileCharDef("
    },
    {
        "line": 93,
        "fullcodeline": "return compileGrouping(file, noback, nofor, table, displayTable);"
    },
    {
        "line": 95,
        "fullcodeline": "if (!displayTable) return 1;  // ignore"
    },
    {
        "line": 96,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 97,
        "fullcodeline": "if (!getRuleDotsPattern(file, &ruleDots)) return 0;"
    },
    {
        "line": 98,
        "fullcodeline": "if (ruleChars.length != 1 || ruleDots.length != 1) {"
    },
    {
        "line": 102,
        "fullcodeline": "return putCharDotsMapping("
    },
    {
        "line": 196,
        "fullcodeline": "compileError(file, \"opcode %s not defined.\","
    },
    {
        "line": 203,
        "fullcodeline": "if (!table) return 1;"
    },
    {
        "line": 21,
        "fullcodeline": "compileHyphenation(file, &token, table);"
    },
    {
        "line": 49,
        "fullcodeline": "if (!getToken(file, &token, \"include file name\")) return 0;"
    },
    {
        "line": 50,
        "fullcodeline": "if (!parseChars(file, &includedFile, &token)) return 0;"
    },
    {
        "line": 51,
        "fullcodeline": "return includeFile(file, &includedFile, table, displayTable);"
    },
    {
        "line": 55,
        "fullcodeline": "compileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));"
    },
    {
        "line": 62,
        "fullcodeline": "compileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));"
    },
    {
        "line": 99,
        "fullcodeline": "compileError(file, \"Exactly one character and one cell are required.\");"
    },
    {
        "line": 192,
        "fullcodeline": "if (opcode == CTO_UpLow) {"
    },
    {
        "line": 197,
        "fullcodeline": "_lou_showString(token.chars, token.length, 0));"
    },
    {
        "line": 206,
        "fullcodeline": "compileWarning(file,"
    },
    {
        "line": 542,
        "fullcodeline": "char *s = malloc(sizeof(char) * (emphClass.length + 1));"
    },
    {
        "line": 544,
        "fullcodeline": "s[k++] = '\\0';"
    },
    {
        "line": 614,
        "fullcodeline": "(*table)->emphClassNames[i] = s;"
    },
    {
        "line": 615,
        "fullcodeline": "(*table)->emphClasses[i] = (EmphasisClass){ emph_1"
    },
    {
        "line": 972,
        "fullcodeline": "(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;"
    },
    {
        "line": 982,
        "fullcodeline": "(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;"
    },
    {
        "line": 1022,
        "fullcodeline": "nocross = 1;"
    },
    {
        "line": 1025,
        "fullcodeline": "(*table)->syllables = 1;"
    },
    {
        "line": 1077,
        "fullcodeline": "int len = dots.length;"
    },
    {
        "line": 1134,
        "fullcodeline": "scratchPad.length = ruleChars.length - 1;"
    },
    {
        "line": 1168,
        "fullcodeline": "(*table)->corrections = 1;"
    },
    {
        "line": 1228,
        "fullcodeline": "compileWarning(file, \"class is deprecated, use attribute instead\");"
    },
    {
        "line": 1361,
        "fullcodeline": "const CharacterClass *mode = findCharacterClass(&token, *table);"
    },
    {
        "line": 1381,
        "fullcodeline": "TranslationTableCharacter *character ="
    },
    {
        "line": 1400,
        "fullcodeline": "putChar(file, token.chars[0], table, &basechar);"
    },
    {
        "line": 1417,
        "fullcodeline": "character->basechar = basechar;"
    },
    {
        "line": 1418,
        "fullcodeline": "character->mode = mode->attribute;"
    },
    {
        "line": 1419,
        "fullcodeline": "character->sourceFile = file->sourceFile;"
    },
    {
        "line": 1420,
        "fullcodeline": "character->sourceLine = file->lineNumber;"
    },
    {
        "line": 1425,
        "fullcodeline": "before |= CTC_EmpMatch;"
    },
    {
        "line": 1428,
        "fullcodeline": "after |= CTC_EmpMatch;"
    },
    {
        "line": 1457,
        "fullcodeline": "compileError(file, \"unimplemented opcode.\");"
    },
    {
        "line": 193,
        "fullcodeline": "compileError(file, \"The uplow opcode is deprecated.\");"
    },
    {
        "line": 216,
        "fullcodeline": "(*table)->undefined = ruleOffset;"
    },
    {
        "line": 220,
        "fullcodeline": "int ok = 0;"
    },
    {
        "line": 221,
        "fullcodeline": "widechar *patterns = NULL;"
    },
    {
        "line": 227,
        "fullcodeline": "size_t patternsByteSize = sizeof(*patterns) * 27720;"
    },
    {
        "line": 228,
        "fullcodeline": "patterns = (widechar *)malloc(patternsByteSize);"
    },
    {
        "line": 230,
        "fullcodeline": "memset(patterns, 0xffff, patternsByteSize);"
    },
    {
        "line": 231,
        "fullcodeline": "noback = 1;"
    },
    {
        "line": 232,
        "fullcodeline": "getCharacters(file, &ptn_before);"
    },
    {
        "line": 233,
        "fullcodeline": "getRuleCharsText(file, &ruleChars);"
    },
    {
        "line": 234,
        "fullcodeline": "getCharacters(file, &ptn_after);"
    },
    {
        "line": 235,
        "fullcodeline": "getRuleDotsPattern(file, &ruleDots);"
    },
    {
        "line": 246,
        "fullcodeline": "mrk = patterns[0] = len + 1;"
    },
    {
        "line": 247,
        "fullcodeline": "_lou_pattern_reverse(&patterns[1]);"
    },
    {
        "line": 255,
        "fullcodeline": "len += mrk;"
    },
    {
        "line": 262,
        "fullcodeline": "memcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));"
    },
    {
        "line": 263,
        "fullcodeline": "rule->patterns = patternsOffset;"
    },
    {
        "line": 264,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 266,
        "fullcodeline": "free(patterns);"
    },
    {
        "line": 271,
        "fullcodeline": "int ok = 0;"
    },
    {
        "line": 272,
        "fullcodeline": "widechar *patterns = NULL;"
    },
    {
        "line": 278,
        "fullcodeline": "size_t patternsByteSize = sizeof(*patterns) * 27720;"
    },
    {
        "line": 279,
        "fullcodeline": "patterns = (widechar *)malloc(patternsByteSize);"
    },
    {
        "line": 281,
        "fullcodeline": "memset(patterns, 0xffff, patternsByteSize);"
    },
    {
        "line": 282,
        "fullcodeline": "nofor = 1;"
    },
    {
        "line": 283,
        "fullcodeline": "getCharacters(file, &ptn_before);"
    },
    {
        "line": 284,
        "fullcodeline": "getRuleCharsText(file, &ruleChars);"
    },
    {
        "line": 285,
        "fullcodeline": "getCharacters(file, &ptn_after);"
    },
    {
        "line": 286,
        "fullcodeline": "getRuleDotsPattern(file, &ruleDots);"
    },
    {
        "line": 297,
        "fullcodeline": "mrk = patterns[0] = len + 1;"
    },
    {
        "line": 298,
        "fullcodeline": "_lou_pattern_reverse(&patterns[1]);"
    },
    {
        "line": 306,
        "fullcodeline": "len += mrk;"
    },
    {
        "line": 313,
        "fullcodeline": "memcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));"
    },
    {
        "line": 314,
        "fullcodeline": "rule->patterns = patternOffset;"
    },
    {
        "line": 315,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 317,
        "fullcodeline": "free(patterns);"
    },
    {
        "line": 537,
        "fullcodeline": "if (!getToken(file, &emphClass, \"emphasis class\")) {"
    },
    {
        "line": 543,
        "fullcodeline": "for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];"
    },
    {
        "line": 545,
        "fullcodeline": "for (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)"
    },
    {
        "line": 552,
        "fullcodeline": "if (i == MAX_EMPH_CLASSES) {"
    },
    {
        "line": 631,
        "fullcodeline": "char *s = malloc(sizeof(char) * (emphClass.length + 1));"
    },
    {
        "line": 634,
        "fullcodeline": "s[k++] = '\\0';"
    },
    {
        "line": 643,
        "fullcodeline": "int ok = 0;"
    },
    {
        "line": 827,
        "fullcodeline": "free(s);"
    },
    {
        "line": 836,
        "fullcodeline": "(*table)->letterSign = ruleOffset;"
    },
    {
        "line": 840,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 841,
        "fullcodeline": "if (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {"
    },
    {
        "line": 845,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++)"
    },
    {
        "line": 850,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 851,
        "fullcodeline": "if (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {"
    },
    {
        "line": 855,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++)"
    },
    {
        "line": 859,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 860,
        "fullcodeline": "if (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {"
    },
    {
        "line": 864,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++)"
    },
    {
        "line": 874,
        "fullcodeline": "(*table)->numberSign = ruleOffset;"
    },
    {
        "line": 879,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 880,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 893,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 894,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 906,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 907,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 924,
        "fullcodeline": "(*table)->noContractSign = ruleOffset;"
    },
    {
        "line": 928,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 929,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 941,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 942,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 953,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 954,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 965,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 966,
        "fullcodeline": "if (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {"
    },
    {
        "line": 970,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++)"
    },
    {
        "line": 976,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 978,
        "fullcodeline": "(*table)->seqAfterExpressionLength < ruleChars.length;"
    },
    {
        "line": 979,
        "fullcodeline": "(*table)->seqAfterExpressionLength++)"
    },
    {
        "line": 986,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 987,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 1004,
        "fullcodeline": "(*table)->begComp = ruleOffset;"
    },
    {
        "line": 1013,
        "fullcodeline": "(*table)->endComp = ruleOffset;"
    },
    {
        "line": 1047,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 1048,
        "fullcodeline": "if (!getRuleDotsPattern(file, &ruleDots)) return 0;"
    },
    {
        "line": 1049,
        "fullcodeline": "if (ruleDots.length == 0)"
    },
    {
        "line": 1062,
        "fullcodeline": "if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,"
    },
    {
        "line": 1074,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 1076,
        "fullcodeline": "if (!getToken(file, &dots, \"dots,dots operand\")) return 0;"
    },
    {
        "line": 1078,
        "fullcodeline": "for (int k = 0; k < len - 1; k++) {"
    },
    {
        "line": 1127,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 1128,
        "fullcodeline": "if (ruleChars.chars[0] != '@') {"
    },
    {
        "line": 1132,
        "fullcodeline": "for (int k = 1; k < ruleChars.length; k++)"
    },
    {
        "line": 1135,
        "fullcodeline": "if (!parseDots(file, &ruleDots, &scratchPad)) return 0;"
    },
    {
        "line": 1136,
        "fullcodeline": "return addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,"
    },
    {
        "line": 1140,
        "fullcodeline": "ruleChars.length = 1;"
    },
    {
        "line": 1141,
        "fullcodeline": "ruleChars.chars[0] = 'a';"
    },
    {
        "line": 1145,
        "fullcodeline": "(*table)->capsNoCont = ruleOffset;"
    },
    {
        "line": 1149,
        "fullcodeline": "if (getRuleCharsText(file, &ruleChars)) {"
    },
    {
        "line": 1161,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++)"
    },
    {
        "line": 1162,
        "fullcodeline": "putChar(file, ruleChars.chars[k], table, NULL);"
    },
    {
        "line": 1163,
        "fullcodeline": "for (int k = 0; k < ruleDots.length; k++)"
    },
    {
        "line": 1164,
        "fullcodeline": "putChar(file, ruleDots.chars[k], table, NULL);"
    },
    {
        "line": 1165,
        "fullcodeline": "return addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,"
    },
    {
        "line": 1171,
        "fullcodeline": "if ((*table)->numPasses < 2) (*table)->numPasses = 2;"
    },
    {
        "line": 1174,
        "fullcodeline": "if ((*table)->numPasses < 3) (*table)->numPasses = 3;"
    },
    {
        "line": 1177,
        "fullcodeline": "if ((*table)->numPasses < 4) (*table)->numPasses = 4;"
    },
    {
        "line": 1180,
        "fullcodeline": "if (!(nofor || noback)) {"
    },
    {
        "line": 1185,
        "fullcodeline": "return compilePassOpcode(file, opcode, noback, nofor, table);"
    },
    {
        "line": 1190,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 1194,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 1202,
        "fullcodeline": "return addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,"
    },
    {
        "line": 1205,
        "fullcodeline": "ruleChars.length = 0;"
    },
    {
        "line": 1252,
        "fullcodeline": "TranslationTableCharacterAttributes attribute = 0;"
    },
    {
        "line": 1333,
        "fullcodeline": "attributes = &after;"
    },
    {
        "line": 1336,
        "fullcodeline": "attributes = &before;"
    },
    {
        "line": 1346,
        "fullcodeline": "*attributes |= class->attribute;"
    },
    {
        "line": 1350,
        "fullcodeline": "if (nofor || noback) {"
    },
    {
        "line": 1353,
        "fullcodeline": "if (!getToken(file, &token, \"attribute name\")) {"
    },
    {
        "line": 1358,
        "fullcodeline": "if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {"
    },
    {
        "line": 1362,
        "fullcodeline": "if (!mode) {"
    },
    {
        "line": 1366,
        "fullcodeline": "if (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&"
    },
    {
        "line": 1373,
        "fullcodeline": "if (!getRuleCharsText(file, &token)) return 0;"
    },
    {
        "line": 1374,
        "fullcodeline": "if (token.length != 1) {"
    },
    {
        "line": 1382,
        "fullcodeline": "putChar(file, token.chars[0], table, &characterOffset);"
    },
    {
        "line": 1383,
        "fullcodeline": "if (!getRuleCharsText(file, &token)) return 0;"
    },
    {
        "line": 1384,
        "fullcodeline": "if (token.length != 1) {"
    },
    {
        "line": 1434,
        "fullcodeline": "return compileSwap(file, opcode, noback, nofor, table);"
    },
    {
        "line": 1439,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 1440,
        "fullcodeline": "if (!getRuleDotsPattern(file, &ruleDots)) return 0;"
    },
    {
        "line": 1441,
        "fullcodeline": "if (ruleChars.length != 1 || ruleDots.length < 1) {"
    },
    {
        "line": 1447,
        "fullcodeline": "return addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,"
    },
    {
        "line": 24,
        "fullcodeline": "while (_lou_getALine(file))"
    },
    {
        "line": 213,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"undefined character opcode\","
    },
    {
        "line": 229,
        "fullcodeline": "if (!patterns) _lou_outOfMemory();"
    },
    {
        "line": 236,
        "fullcodeline": "if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,"
    },
    {
        "line": 239,
        "fullcodeline": "if (ptn_before.chars[0] == '-' && ptn_before.length == 1)"
    },
    {
        "line": 245,
        "fullcodeline": "if (!len) goto CTO_Match_cleanup;"
    },
    {
        "line": 248,
        "fullcodeline": "if (ptn_after.chars[0] == '-' && ptn_after.length == 1)"
    },
    {
        "line": 254,
        "fullcodeline": "if (!len) goto CTO_Match_cleanup;"
    },
    {
        "line": 256,
        "fullcodeline": "if (!allocateSpaceInTranslationTable("
    },
    {
        "line": 280,
        "fullcodeline": "if (!patterns) _lou_outOfMemory();"
    },
    {
        "line": 287,
        "fullcodeline": "if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,"
    },
    {
        "line": 290,
        "fullcodeline": "if (ptn_before.chars[0] == '-' && ptn_before.length == 1)"
    },
    {
        "line": 296,
        "fullcodeline": "if (!len) goto CTO_BackMatch_cleanup;"
    },
    {
        "line": 299,
        "fullcodeline": "if (ptn_after.chars[0] == '-' && ptn_after.length == 1)"
    },
    {
        "line": 305,
        "fullcodeline": "if (!len) goto CTO_BackMatch_cleanup;"
    },
    {
        "line": 307,
        "fullcodeline": "if (!allocateSpaceInTranslationTable("
    },
    {
        "line": 538,
        "fullcodeline": "compileError(file, \"emphclass must be followed by a valid class name.\");"
    },
    {
        "line": 546,
        "fullcodeline": "if (strcmp(s, (*table)->emphClassNames[i]) == 0) {"
    },
    {
        "line": 553,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR,"
    },
    {
        "line": 555,
        "fullcodeline": "errorCount++;"
    },
    {
        "line": 556,
        "fullcodeline": "free(s);"
    },
    {
        "line": 629,
        "fullcodeline": "if (!getToken(file, &token, \"emphasis class\")) return 0;"
    },
    {
        "line": 630,
        "fullcodeline": "if (!parseChars(file, &emphClass, &token)) return 0;"
    },
    {
        "line": 633,
        "fullcodeline": "for (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];"
    },
    {
        "line": 635,
        "fullcodeline": "for (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)"
    },
    {
        "line": 637,
        "fullcodeline": "if (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {"
    },
    {
        "line": 833,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,"
    },
    {
        "line": 842,
        "fullcodeline": "compileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);"
    },
    {
        "line": 852,
        "fullcodeline": "compileError(file, \"More than %d characters\", LETSIGNSIZE);"
    },
    {
        "line": 861,
        "fullcodeline": "compileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);"
    },
    {
        "line": 871,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,"
    },
    {
        "line": 881,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 887,
        "fullcodeline": "c->attributes |= CTC_NumericMode;"
    },
    {
        "line": 888,
        "fullcodeline": "(*table)->usesNumericMode = 1;"
    },
    {
        "line": 895,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 900,
        "fullcodeline": "c->attributes |= CTC_MidEndNumericMode;"
    },
    {
        "line": 901,
        "fullcodeline": "(*table)->usesNumericMode = 1;"
    },
    {
        "line": 908,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 913,
        "fullcodeline": "c->attributes |= CTC_NumericNoContract;"
    },
    {
        "line": 914,
        "fullcodeline": "(*table)->usesNumericMode = 1;"
    },
    {
        "line": 921,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,"
    },
    {
        "line": 930,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 935,
        "fullcodeline": "c->attributes |= CTC_SeqDelimiter;"
    },
    {
        "line": 936,
        "fullcodeline": "(*table)->usesSequences = 1;"
    },
    {
        "line": 943,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 948,
        "fullcodeline": "c->attributes |= CTC_SeqBefore;"
    },
    {
        "line": 955,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 960,
        "fullcodeline": "c->attributes |= CTC_SeqAfter;"
    },
    {
        "line": 967,
        "fullcodeline": "compileError(file, \"More than %d characters\", SEQPATTERNSIZE);"
    },
    {
        "line": 977,
        "fullcodeline": "for ((*table)->seqAfterExpressionLength = 0;"
    },
    {
        "line": 988,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 993,
        "fullcodeline": "c->attributes |= CTC_CapsMode;"
    },
    {
        "line": 994,
        "fullcodeline": "(*table)->hasCapsModeChars = 1;"
    },
    {
        "line": 1001,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,"
    },
    {
        "line": 1010,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,"
    },
    {
        "line": 1018,
        "fullcodeline": "compileError("
    },
    {
        "line": 1065,
        "fullcodeline": "if (nocross) r->nocross = 1;"
    },
    {
        "line": 1112,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) return 0;"
    },
    {
        "line": 1113,
        "fullcodeline": "if (ruleChars.length != 1) {"
    },
    {
        "line": 1117,
        "fullcodeline": "if (nofor || noback) {"
    },
    {
        "line": 1120,
        "fullcodeline": "if (!getRuleDotsPattern(file, &ruleDots)) return 0;"
    },
    {
        "line": 1121,
        "fullcodeline": "if (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,"
    },
    {
        "line": 1129,
        "fullcodeline": "compileError(file, \"The operand must begin with an at sign (@)\");"
    },
    {
        "line": 1142,
        "fullcodeline": "if (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,"
    },
    {
        "line": 1181,
        "fullcodeline": "compileError(file, \"%s or %s must be specified.\","
    },
    {
        "line": 1195,
        "fullcodeline": "TranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 1206,
        "fullcodeline": "if (!getToken(file, &token, \"multiple braille indicators\") ||"
    },
    {
        "line": 1209,
        "fullcodeline": "while (getToken(file, &token, \"multind opcodes\")) {"
    },
    {
        "line": 1223,
        "fullcodeline": "return addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,"
    },
    {
        "line": 1230,
        "fullcodeline": "if (nofor || noback) {"
    },
    {
        "line": 1234,
        "fullcodeline": "if ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||"
    },
    {
        "line": 1240,
        "fullcodeline": "if (opcode == CTO_Class)"
    },
    {
        "line": 1244,
        "fullcodeline": "if (!getToken(file, &token, \"attribute name\")) {"
    },
    {
        "line": 1248,
        "fullcodeline": "if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {"
    },
    {
        "line": 1254,
        "fullcodeline": "int attrNumber = -1;"
    },
    {
        "line": 1303,
        "fullcodeline": "if (!getCharacters(file, &characters)) return 0;"
    },
    {
        "line": 1304,
        "fullcodeline": "for (int i = 0; i < characters.length; i++) {"
    },
    {
        "line": 1341,
        "fullcodeline": "if (!getToken(file, &token, \"attribute name\")) return 0;"
    },
    {
        "line": 1342,
        "fullcodeline": "if (!(class = findCharacterClass(&token, *table))) {"
    },
    {
        "line": 1351,
        "fullcodeline": "compileWarning(file, \"nofor and noback not allowed before base\");"
    },
    {
        "line": 1354,
        "fullcodeline": "compileError("
    },
    {
        "line": 1363,
        "fullcodeline": "mode = addCharacterClass(file, token.chars, token.length, *table, 1);"
    },
    {
        "line": 1367,
        "fullcodeline": "mode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {"
    },
    {
        "line": 1368,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 1375,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 1385,
        "fullcodeline": "compileError(file, \"Exactly one base character is required.\");"
    },
    {
        "line": 1392,
        "fullcodeline": "_lou_logMessage(LOU_LOG_DEBUG,"
    },
    {
        "line": 1397,
        "fullcodeline": "character->definitionRule = 0;"
    },
    {
        "line": 1442,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 110,
        "fullcodeline": "const Macro *m = macros->head;"
    },
    {
        "line": 189,
        "fullcodeline": "macros = macros->tail;"
    },
    {
        "line": 240,
        "fullcodeline": "len = _lou_pattern_compile("
    },
    {
        "line": 249,
        "fullcodeline": "len = _lou_pattern_compile("
    },
    {
        "line": 291,
        "fullcodeline": "len = _lou_pattern_compile("
    },
    {
        "line": 300,
        "fullcodeline": "len = _lou_pattern_compile("
    },
    {
        "line": 359,
        "fullcodeline": "mode = CTC_UpperCase;"
    },
    {
        "line": 360,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 361,
        "fullcodeline": "opcode += (CTO_ModeLetter - CTO_CapsLetter);"
    },
    {
        "line": 368,
        "fullcodeline": "const CharacterClass *characterClass = findCharacterClass(&token, *table);"
    },
    {
        "line": 374,
        "fullcodeline": "mode = characterClass->attribute;"
    },
    {
        "line": 399,
        "fullcodeline": "(*table)->modes[i] = (EmphasisClass){ plain_text, mode,"
    },
    {
        "line": 547,
        "fullcodeline": "_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);"
    },
    {
        "line": 548,
        "fullcodeline": "warningCount++;"
    },
    {
        "line": 549,
        "fullcodeline": "free(s);"
    },
    {
        "line": 580,
        "fullcodeline": "if (strcmp(s, \"italic\") != 0) {"
    },
    {
        "line": 591,
        "fullcodeline": "if (strcmp(s, \"underline\") != 0) {"
    },
    {
        "line": 603,
        "fullcodeline": "if (strcmp(s, \"bold\") != 0) {"
    },
    {
        "line": 617,
        "fullcodeline": "0, 0x1 << i, i };"
    },
    {
        "line": 636,
        "fullcodeline": "if (strcmp(s, (*table)->emphClassNames[i]) == 0) break;"
    },
    {
        "line": 638,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);"
    },
    {
        "line": 639,
        "fullcodeline": "errorCount++;"
    },
    {
        "line": 640,
        "fullcodeline": "free(s);"
    },
    {
        "line": 882,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 896,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 909,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 931,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 944,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 956,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 989,
        "fullcodeline": "if (!c) {"
    },
    {
        "line": 1019,
        "fullcodeline": "file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));"
    },
    {
        "line": 1052,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 1079,
        "fullcodeline": "if (dots.chars[k] == ',') {"
    },
    {
        "line": 1114,
        "fullcodeline": "compileError(file, \"first operand must be 1 character\");"
    },
    {
        "line": 1118,
        "fullcodeline": "compileWarning(file, \"nofor and noback not allowed on comp6 rules\");"
    },
    {
        "line": 1133,
        "fullcodeline": "scratchPad.chars[k - 1] = ruleChars.chars[k];"
    },
    {
        "line": 1150,
        "fullcodeline": "if (atEndOfLine(file))"
    },
    {
        "line": 1182,
        "fullcodeline": "_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));"
    },
    {
        "line": 1196,
        "fullcodeline": "if (!(c && (c->definitionRule || c->basechar))) {"
    },
    {
        "line": 1207,
        "fullcodeline": "!parseDots(file, &cells, &token))"
    },
    {
        "line": 1210,
        "fullcodeline": "opcode = getOpcode(file, &token);"
    },
    {
        "line": 1220,
        "fullcodeline": "ruleChars.chars[ruleChars.length++] = (widechar)opcode;"
    },
    {
        "line": 1231,
        "fullcodeline": "compileWarning("
    },
    {
        "line": 1235,
        "fullcodeline": "(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {"
    },
    {
        "line": 1236,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 1241,
        "fullcodeline": "(*table)->usesAttributeOrClass = 2;"
    },
    {
        "line": 1245,
        "fullcodeline": "compileError(file, \"Expected %s\", \"attribute name\");"
    },
    {
        "line": 1269,
        "fullcodeline": "if (attrNumber >= 0) {"
    },
    {
        "line": 1307,
        "fullcodeline": "TranslationTableCharacter *character ="
    },
    {
        "line": 1310,
        "fullcodeline": "character->attributes |= attribute;"
    },
    {
        "line": 1343,
        "fullcodeline": "compileError(file, \"attribute not defined\");"
    },
    {
        "line": 1364,
        "fullcodeline": "if (!mode) return 0;"
    },
    {
        "line": 1396,
        "fullcodeline": "printSource(file, prevRule->sourceFile, prevRule->sourceLine));"
    },
    {
        "line": 1404,
        "fullcodeline": "if (character->basechar == basechar &&"
    },
    {
        "line": 111,
        "fullcodeline": "if (token.length == strlen(m->name) &&"
    },
    {
        "line": 243,
        "fullcodeline": "len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,"
    },
    {
        "line": 252,
        "fullcodeline": "len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,"
    },
    {
        "line": 257,
        "fullcodeline": "file, &patternsOffset, len * sizeof(widechar), table))"
    },
    {
        "line": 294,
        "fullcodeline": "len = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,"
    },
    {
        "line": 303,
        "fullcodeline": "len = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,"
    },
    {
        "line": 308,
        "fullcodeline": "file, &patternOffset, len * sizeof(widechar), table))"
    },
    {
        "line": 364,
        "fullcodeline": "if (!getToken(file, &token, \"attribute name\")) return 0;"
    },
    {
        "line": 365,
        "fullcodeline": "if (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {"
    },
    {
        "line": 369,
        "fullcodeline": "if (!characterClass) {"
    },
    {
        "line": 375,
        "fullcodeline": "if (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&"
    },
    {
        "line": 384,
        "fullcodeline": "if (mode == CTC_UpperCase)"
    },
    {
        "line": 411,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;"
    },
    {
        "line": 466,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;"
    },
    {
        "line": 477,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;"
    },
    {
        "line": 489,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;"
    },
    {
        "line": 501,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;"
    },
    {
        "line": 513,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;"
    },
    {
        "line": 517,
        "fullcodeline": "return (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] ="
    },
    {
        "line": 581,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR,"
    },
    {
        "line": 585,
        "fullcodeline": "errorCount++;"
    },
    {
        "line": 586,
        "fullcodeline": "free(s);"
    },
    {
        "line": 592,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR,"
    },
    {
        "line": 597,
        "fullcodeline": "errorCount++;"
    },
    {
        "line": 598,
        "fullcodeline": "free(s);"
    },
    {
        "line": 604,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR,"
    },
    {
        "line": 608,
        "fullcodeline": "errorCount++;"
    },
    {
        "line": 609,
        "fullcodeline": "free(s);"
    },
    {
        "line": 653,
        "fullcodeline": "(*table)->emphRules[i][letterOffset] = ruleOffset;"
    },
    {
        "line": 654,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 665,
        "fullcodeline": "(*table)->emphRules[i][begWordOffset] = ruleOffset;"
    },
    {
        "line": 666,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 677,
        "fullcodeline": "(*table)->emphRules[i][endWordOffset] = ruleOffset;"
    },
    {
        "line": 678,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 699,
        "fullcodeline": "(*table)->emphRules[i][begOffset] = ruleOffset;"
    },
    {
        "line": 700,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 720,
        "fullcodeline": "(*table)->emphRules[i][endOffset] = ruleOffset;"
    },
    {
        "line": 721,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 733,
        "fullcodeline": "(*table)->emphRules[i][begPhraseOffset] = ruleOffset;"
    },
    {
        "line": 734,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 738,
        "fullcodeline": "switch (compileBeforeAfter(file)) {"
    },
    {
        "line": 779,
        "fullcodeline": "if (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))"
    },
    {
        "line": 792,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 813,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 883,
        "fullcodeline": "compileError(file, \"Numeric mode character undefined: %s\","
    },
    {
        "line": 897,
        "fullcodeline": "compileError(file, \"Midendnumeric mode character undefined\");"
    },
    {
        "line": 910,
        "fullcodeline": "compileError(file, \"Numeric no contraction character undefined\");"
    },
    {
        "line": 932,
        "fullcodeline": "compileError(file, \"Sequence delimiter character undefined\");"
    },
    {
        "line": 945,
        "fullcodeline": "compileError(file, \"Sequence before character undefined\");"
    },
    {
        "line": 957,
        "fullcodeline": "compileError(file, \"Sequence after character undefined\");"
    },
    {
        "line": 990,
        "fullcodeline": "compileError(file, \"Capital mode character undefined\");"
    },
    {
        "line": 1053,
        "fullcodeline": "TranslationTableCharacter *c ="
    },
    {
        "line": 1080,
        "fullcodeline": "dots.length = k;"
    },
    {
        "line": 1082,
        "fullcodeline": "ruleDots.chars[ruleDots.length++] = ',';"
    },
    {
        "line": 1083,
        "fullcodeline": "k++;"
    },
    {
        "line": 1151,
        "fullcodeline": "ruleDots.length = ruleDots.chars[0] = 0;"
    },
    {
        "line": 1197,
        "fullcodeline": "compileError(file, \"Character %s is not defined\","
    },
    {
        "line": 1211,
        "fullcodeline": "if (opcode == CTO_None) {"
    },
    {
        "line": 1216,
        "fullcodeline": "if (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {"
    },
    {
        "line": 1221,
        "fullcodeline": "if (atEndOfLine(file)) break;"
    },
    {
        "line": 1243,
        "fullcodeline": "(*table)->usesAttributeOrClass = 1;"
    },
    {
        "line": 1266,
        "fullcodeline": "attrNumber = token.chars[0] - '0';"
    },
    {
        "line": 1286,
        "fullcodeline": "attribute = (*table)->numberedAttributes[attrNumber];"
    },
    {
        "line": 1308,
        "fullcodeline": "putChar(file, characters.chars[i], table, NULL);"
    },
    {
        "line": 1339,
        "fullcodeline": "if (!allocateCharacterClasses(*table)) return 0;"
    },
    {
        "line": 1405,
        "fullcodeline": "character->mode == mode->attribute) {"
    },
    {
        "line": 1406,
        "fullcodeline": "_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\","
    },
    {
        "line": 112,
        "fullcodeline": "eqasc2uni((unsigned char *)m->name, token.chars, token.length)) {"
    },
    {
        "line": 118,
        "fullcodeline": "memset(&tmpFile, 0, sizeof(tmpFile));"
    },
    {
        "line": 119,
        "fullcodeline": "tmpFile.fileName = file->fileName;"
    },
    {
        "line": 120,
        "fullcodeline": "tmpFile.sourceFile = file->sourceFile;"
    },
    {
        "line": 121,
        "fullcodeline": "tmpFile.lineNumber = file->lineNumber;"
    },
    {
        "line": 122,
        "fullcodeline": "tmpFile.encoding = noEncoding;"
    },
    {
        "line": 123,
        "fullcodeline": "tmpFile.status = 0;"
    },
    {
        "line": 124,
        "fullcodeline": "tmpFile.linepos = 0;"
    },
    {
        "line": 125,
        "fullcodeline": "tmpFile.linelen = 0;"
    },
    {
        "line": 126,
        "fullcodeline": "int argument_count = 0;"
    },
    {
        "line": 127,
        "fullcodeline": "CharsString *arguments ="
    },
    {
        "line": 139,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 140,
        "fullcodeline": "int subst = 0;"
    },
    {
        "line": 141,
        "fullcodeline": "int next = subst < m->substitution_count ? m->substitutions[2 * subst]"
    },
    {
        "line": 370,
        "fullcodeline": "characterClass ="
    },
    {
        "line": 376,
        "fullcodeline": "mode <= CTC_LitDigit) {"
    },
    {
        "line": 377,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 385,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 407,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"first word capital sign\","
    },
    {
        "line": 416,
        "fullcodeline": "switch (compileBeforeAfter(file)) {"
    },
    {
        "line": 463,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"first letter capital sign\","
    },
    {
        "line": 474,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"last letter capital sign\","
    },
    {
        "line": 485,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"single letter capital sign\","
    },
    {
        "line": 497,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"capital word\","
    },
    {
        "line": 509,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"capital word stop\","
    },
    {
        "line": 518,
        "fullcodeline": "compileNumber(file);"
    },
    {
        "line": 649,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"single letter\","
    },
    {
        "line": 661,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"word\","
    },
    {
        "line": 673,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"word stop\","
    },
    {
        "line": 695,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"first letter\","
    },
    {
        "line": 704,
        "fullcodeline": "if ((*table)->emphRules[i][endWordOffset] ||"
    },
    {
        "line": 716,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"last letter\","
    },
    {
        "line": 729,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"first word\","
    },
    {
        "line": 774,
        "fullcodeline": "compileError(file, \"Invalid lastword indicator location.\");"
    },
    {
        "line": 780,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 783,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) break;"
    },
    {
        "line": 786,
        "fullcodeline": "for (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)"
    },
    {
        "line": 788,
        "fullcodeline": "if (len + ruleChars.length > EMPHMODECHARSSIZE) {"
    },
    {
        "line": 793,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 804,
        "fullcodeline": "if (!getRuleCharsText(file, &ruleChars)) break;"
    },
    {
        "line": 807,
        "fullcodeline": "for (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)"
    },
    {
        "line": 809,
        "fullcodeline": "if (len + ruleChars.length > NOEMPHCHARSSIZE) {"
    },
    {
        "line": 814,
        "fullcodeline": "for (int k = 0; k < ruleChars.length; k++) {"
    },
    {
        "line": 884,
        "fullcodeline": "_lou_showString(&ruleChars.chars[k], 1, 0));"
    },
    {
        "line": 1054,
        "fullcodeline": "getChar(ruleChars.chars[k], *table, NULL);"
    },
    {
        "line": 1055,
        "fullcodeline": "if (!(c && (c->definitionRule || c->basechar))) {"
    },
    {
        "line": 1081,
        "fullcodeline": "if (!parseDots(file, &ruleDots, &dots)) return 0;"
    },
    {
        "line": 1084,
        "fullcodeline": "if (k == len - 1 && dots.chars[k] == '=') {"
    },
    {
        "line": 1104,
        "fullcodeline": "return addRule(file, opcode, &ruleChars, &ruleDots, after, before,"
    },
    {
        "line": 1153,
        "fullcodeline": "getRuleDotsText(file, &ruleDots);"
    },
    {
        "line": 1198,
        "fullcodeline": "_lou_showString(&ruleChars.chars[k], 1, 0));"
    },
    {
        "line": 1212,
        "fullcodeline": "compileError(file, \"opcode %s not defined.\","
    },
    {
        "line": 1217,
        "fullcodeline": "compileError(file, \"Not a braille indicator opcode.\");"
    },
    {
        "line": 1270,
        "fullcodeline": "if (opcode == CTO_Class) {"
    },
    {
        "line": 1276,
        "fullcodeline": "if (token.length > 1 || attrNumber > 7) {"
    },
    {
        "line": 1288,
        "fullcodeline": "const CharacterClass *namedAttr = findCharacterClass(&token, *table);"
    },
    {
        "line": 1297,
        "fullcodeline": "attribute = namedAttr->attribute;"
    },
    {
        "line": 1409,
        "fullcodeline": "_lou_logMessage(LOU_LOG_DEBUG,"
    },
    {
        "line": 113,
        "fullcodeline": "if (!inScopeMacros) {"
    },
    {
        "line": 128,
        "fullcodeline": "malloc(m->argument_count * sizeof(CharsString));"
    },
    {
        "line": 129,
        "fullcodeline": "while (argument_count < m->argument_count) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (argument_count < m->argument_count) {"
    },
    {
        "line": 371,
        "fullcodeline": "addCharacterClass(file, token.chars, token.length, *table, 1);"
    },
    {
        "line": 372,
        "fullcodeline": "if (!characterClass) return 0;"
    },
    {
        "line": 400,
        "fullcodeline": "0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };"
    },
    {
        "line": 431,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] ="
    },
    {
        "line": 449,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] ="
    },
    {
        "line": 453,
        "fullcodeline": "compileError(file, \"Invalid lastword indicator location.\");"
    },
    {
        "line": 686,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 707,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 752,
        "fullcodeline": "(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;"
    },
    {
        "line": 753,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 769,
        "fullcodeline": "(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;"
    },
    {
        "line": 770,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 789,
        "fullcodeline": "compileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);"
    },
    {
        "line": 799,
        "fullcodeline": "emphmodechars[len++] = ruleChars.chars[k];"
    },
    {
        "line": 810,
        "fullcodeline": "compileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);"
    },
    {
        "line": 820,
        "fullcodeline": "noemphchars[len++] = ruleChars.chars[k];"
    },
    {
        "line": 1056,
        "fullcodeline": "compileError(file, \"Character %s is not defined\","
    },
    {
        "line": 1154,
        "fullcodeline": "if (ruleDots.chars[0] == '#')"
    },
    {
        "line": 1213,
        "fullcodeline": "_lou_showString(token.chars, token.length, 0));"
    },
    {
        "line": 1271,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 1277,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 1284,
        "fullcodeline": "(*table)->numberedAttributes[attrNumber] ="
    },
    {
        "line": 1289,
        "fullcodeline": "if (!namedAttr) {"
    },
    {
        "line": 1298,
        "fullcodeline": "if (attribute == CTC_UpperCase || attribute == CTC_LowerCase)"
    },
    {
        "line": 1319,
        "fullcodeline": "if (defRule->dotslen == 1) {"
    },
    {
        "line": 1413,
        "fullcodeline": "printSource("
    },
    {
        "line": 114,
        "fullcodeline": "compileError(file, \"Calling macros only allowed in table files.\");"
    },
    {
        "line": 136,
        "fullcodeline": "compileError(file, \"Expected %d arguments\", m->argument_count);"
    },
    {
        "line": 387,
        "fullcodeline": "for (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {"
    },
    {
        "line": 392,
        "fullcodeline": "if (i == MAX_MODES) {"
    },
    {
        "line": 406,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];"
    },
    {
        "line": 408,
        "fullcodeline": "CTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,"
    },
    {
        "line": 427,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"capital sign before last word\","
    },
    {
        "line": 445,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"capital sign after last word\","
    },
    {
        "line": 462,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];"
    },
    {
        "line": 464,
        "fullcodeline": "CTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))"
    },
    {
        "line": 473,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];"
    },
    {
        "line": 475,
        "fullcodeline": "CTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))"
    },
    {
        "line": 484,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];"
    },
    {
        "line": 486,
        "fullcodeline": "CTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,"
    },
    {
        "line": 496,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];"
    },
    {
        "line": 498,
        "fullcodeline": "CTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,"
    },
    {
        "line": 508,
        "fullcodeline": "(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];"
    },
    {
        "line": 510,
        "fullcodeline": "CTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,"
    },
    {
        "line": 650,
        "fullcodeline": "CTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,"
    },
    {
        "line": 662,
        "fullcodeline": "CTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,"
    },
    {
        "line": 674,
        "fullcodeline": "CTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,"
    },
    {
        "line": 696,
        "fullcodeline": "CTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,"
    },
    {
        "line": 717,
        "fullcodeline": "CTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,"
    },
    {
        "line": 730,
        "fullcodeline": "CTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,"
    },
    {
        "line": 748,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"last word before\","
    },
    {
        "line": 765,
        "fullcodeline": "if (!compileBrailleIndicator(file, \"last word after\","
    },
    {
        "line": 794,
        "fullcodeline": "if (!getChar(ruleChars.chars[k], *table, NULL)) {"
    },
    {
        "line": 815,
        "fullcodeline": "if (!getChar(ruleChars.chars[k], *table, NULL)) {"
    },
    {
        "line": 1057,
        "fullcodeline": "_lou_showString(&ruleChars.chars[k], 1, 0));"
    },
    {
        "line": 1087,
        "fullcodeline": "for (int l = 0; l < ruleChars.length; l++) {"
    },
    {
        "line": 1098,
        "fullcodeline": "x.length = 0;"
    },
    {
        "line": 1155,
        "fullcodeline": "ruleDots.length = ruleDots.chars[0] = 0;"
    },
    {
        "line": 1285,
        "fullcodeline": "getNextNumberedAttribute(*table);"
    },
    {
        "line": 1291,
        "fullcodeline": "namedAttr = addCharacterClass("
    },
    {
        "line": 1299,
        "fullcodeline": "attribute |= CTC_Letter;"
    },
    {
        "line": 1320,
        "fullcodeline": "TranslationTableCharacter *dots ="
    },
    {
        "line": 130,
        "fullcodeline": "if (getToken(file, &token, \"macro argument\"))"
    },
    {
        "line": 144,
        "fullcodeline": "while (i < next) {"
    },
    {
        "line": 166,
        "fullcodeline": "if (subst < m->substitution_count) {"
    },
    {
        "line": 393,
        "fullcodeline": "compileError(file, \"Max number of modes (%i) reached\", MAX_MODES);"
    },
    {
        "line": 419,
        "fullcodeline": "compileError("
    },
    {
        "line": 437,
        "fullcodeline": "compileError("
    },
    {
        "line": 741,
        "fullcodeline": "compileError(file, \"last word after already defined.\");"
    },
    {
        "line": 758,
        "fullcodeline": "compileError(file, \"last word before already defined.\");"
    },
    {
        "line": 795,
        "fullcodeline": "compileError(file, \"Emphasis mode character undefined\");"
    },
    {
        "line": 796,
        "fullcodeline": "ok = 0;"
    },
    {
        "line": 816,
        "fullcodeline": "compileError(file, \"Character undefined\");"
    },
    {
        "line": 817,
        "fullcodeline": "ok = 0;"
    },
    {
        "line": 1088,
        "fullcodeline": "TranslationTableCharacter *c ="
    },
    {
        "line": 1099,
        "fullcodeline": "while (k < len) x.chars[x.length++] = dots.chars[k++];"
    },
    {
        "line": 1100,
        "fullcodeline": "if (parseDots(file, &y, &x))"
    },
    {
        "line": 1293,
        "fullcodeline": "if (!namedAttr) return 0;"
    },
    {
        "line": 1321,
        "fullcodeline": "getDots(defRule->charsdots[defRule->charslen], *table);"
    },
    {
        "line": 131,
        "fullcodeline": "arguments[argument_count++] = token;"
    },
    {
        "line": 167,
        "fullcodeline": "CharsString arg ="
    },
    {
        "line": 171,
        "fullcodeline": "subst++;"
    },
    {
        "line": 172,
        "fullcodeline": "next = subst < m->substitution_count"
    },
    {
        "line": 388,
        "fullcodeline": "if ((*table)->modes[i].mode == mode) {"
    },
    {
        "line": 418,
        "fullcodeline": "if ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {"
    },
    {
        "line": 425,
        "fullcodeline": "ruleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]"
    },
    {
        "line": 428,
        "fullcodeline": "CTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,"
    },
    {
        "line": 435,
        "fullcodeline": "if ((*table)->emphRules[MAX_EMPH_CLASSES + i]"
    },
    {
        "line": 443,
        "fullcodeline": "ruleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]"
    },
    {
        "line": 446,
        "fullcodeline": "CTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,"
    },
    {
        "line": 749,
        "fullcodeline": "CTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),"
    },
    {
        "line": 766,
        "fullcodeline": "CTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),"
    },
    {
        "line": 1089,
        "fullcodeline": "getChar(ruleChars.chars[l], *table, NULL);"
    },
    {
        "line": 1090,
        "fullcodeline": "if (!(c && (c->definitionRule || c->basechar))) {"
    },
    {
        "line": 1156,
        "fullcodeline": "else if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')"
    },
    {
        "line": 1322,
        "fullcodeline": "if (dots) dots->attributes |= attribute;"
    },
    {
        "line": 146,
        "fullcodeline": "if (c == '\\n') {"
    },
    {
        "line": 169,
        "fullcodeline": "for (int j = 0; j < arg.length; j++)"
    },
    {
        "line": 1091,
        "fullcodeline": "compileError(file, \"Character %s is not defined\","
    },
    {
        "line": 1101,
        "fullcodeline": "for (int l = 0; l < y.length; l++)"
    },
    {
        "line": 1157,
        "fullcodeline": "memmove(&ruleDots.chars[0], &ruleDots.chars[1],"
    },
    {
        "line": 145,
        "fullcodeline": "widechar c = m->definition[i++];"
    },
    {
        "line": 155,
        "fullcodeline": "tmpFile.linepos = 0;"
    },
    {
        "line": 156,
        "fullcodeline": "tmpFile.linelen = 0;"
    },
    {
        "line": 168,
        "fullcodeline": "arguments[m->substitutions[2 * subst + 1] - 1];"
    },
    {
        "line": 176,
        "fullcodeline": "if (!compileRule("
    },
    {
        "line": 1092,
        "fullcodeline": "_lou_showString(&ruleChars.chars[l], 1, 0));"
    },
    {
        "line": 1158,
        "fullcodeline": "ruleDots.length-- * CHARSIZE);"
    },
    {
        "line": 147,
        "fullcodeline": "if (!compileRule(&tmpFile, table, displayTable,"
    },
    {
        "line": 170,
        "fullcodeline": "tmpFile.line[tmpFile.linelen++] = arg.chars[j];"
    },
    {
        "line": 173,
        "fullcodeline": "? m->substitutions[2 * subst]"
    },
    {
        "line": 178,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR,"
    },
    {
        "line": 1102,
        "fullcodeline": "ruleDots.chars[ruleDots.length++] = y.chars[l];"
    },
    {
        "line": 149,
        "fullcodeline": "_lou_logMessage(LOU_LOG_ERROR,"
    },
    {
        "line": 157,
        "fullcodeline": "} else if (tmpFile.linelen >= MAXSTRING) {"
    },
    {
        "line": 180,
        "fullcodeline": "_lou_showString("
    },
    {
        "line": 151,
        "fullcodeline": "_lou_showString("
    },
    {
        "line": 158,
        "fullcodeline": "compileError(file,"
    },
    {
        "line": 164,
        "fullcodeline": "tmpFile.line[tmpFile.linelen++] = c;"
    }
]