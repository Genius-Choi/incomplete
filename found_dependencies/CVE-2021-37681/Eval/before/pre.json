[
    {
        "line": 2,
        "fullcodeline": "auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);"
    },
    {
        "line": 3,
        "fullcodeline": "OpData* op_data = reinterpret_cast<OpData*>(node->user_data);"
    },
    {
        "line": 6,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));"
    },
    {
        "line": 8,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,"
    },
    {
        "line": 11,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 13,
        "fullcodeline": "const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);"
    },
    {
        "line": 16,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 19,
        "fullcodeline": "TfLiteTensor* state = GetVariableInput(context, node, kStateTensor);"
    },
    {
        "line": 21,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 12,
        "fullcodeline": "context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));"
    },
    {
        "line": 17,
        "fullcodeline": "GetTemporarySafe(context, node, /*index=*/0, &scratch));"
    },
    {
        "line": 22,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensor, &output));"
    },
    {
        "line": 26,
        "fullcodeline": "reference_ops::EvalFloatSVDF("
    },
    {
        "line": 97,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 102,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActRelu);"
    },
    {
        "line": 120,
        "fullcodeline": "TfLiteTypeGetName(weights_feature->type));"
    },
    {
        "line": 27,
        "fullcodeline": "params, GetTensorShape(input), GetTensorData<float>(input),"
    },
    {
        "line": 28,
        "fullcodeline": "GetTensorShape(weights_feature),"
    },
    {
        "line": 29,
        "fullcodeline": "GetTensorData<float>(weights_feature), GetTensorShape(weights_time),"
    },
    {
        "line": 30,
        "fullcodeline": "GetTensorData<float>(weights_time), GetTensorShape(bias),"
    },
    {
        "line": 31,
        "fullcodeline": "GetTensorData<float>(bias), GetTensorData<float>(scratch),"
    },
    {
        "line": 32,
        "fullcodeline": "GetTensorData<float>(state), GetTensorShape(output),"
    },
    {
        "line": 33,
        "fullcodeline": "GetTensorData<float>(output));"
    },
    {
        "line": 38,
        "fullcodeline": "if (input->type == kTfLiteFloat32) {"
    },
    {
        "line": 98,
        "fullcodeline": "context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));"
    },
    {
        "line": 105,
        "fullcodeline": "params, GetTensorShape(input), GetTensorData<int8_t>(input),"
    },
    {
        "line": 106,
        "fullcodeline": "GetTensorShape(weights_feature),"
    },
    {
        "line": 107,
        "fullcodeline": "GetTensorData<int8_t>(weights_feature), GetTensorShape(weights_time),"
    },
    {
        "line": 108,
        "fullcodeline": "GetTensorData<int16_t>(weights_time), GetTensorShape(bias),"
    },
    {
        "line": 109,
        "fullcodeline": "GetTensorData<int32_t>(bias), GetTensorData<int16_t>(state),"
    },
    {
        "line": 110,
        "fullcodeline": "GetTensorShape(output), GetTensorData<int8_t>(output),"
    },
    {
        "line": 111,
        "fullcodeline": "GetTensorData<int32_t>(scratch), GetTensorData<int32_t>(output_temp),"
    },
    {
        "line": 40,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,"
    },
    {
        "line": 43,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,"
    },
    {
        "line": 46,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,"
    },
    {
        "line": 49,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/4,"
    },
    {
        "line": 72,
        "fullcodeline": "int32_t* zero_points_ptr = nullptr;"
    },
    {
        "line": 73,
        "fullcodeline": "int32_t* row_sums_ptr = nullptr;"
    },
    {
        "line": 53,
        "fullcodeline": "context, GetTemporarySafe(context, node, /*index=*/5, &row_sums));"
    },
    {
        "line": 74,
        "fullcodeline": "if (params->asymmetric_quantize_inputs && row_sums != nullptr) {"
    },
    {
        "line": 80,
        "fullcodeline": "params, GetTensorShape(input), GetTensorData<float>(input),"
    },
    {
        "line": 81,
        "fullcodeline": "GetTensorShape(weights_feature),"
    },
    {
        "line": 82,
        "fullcodeline": "GetTensorData<int8_t>(weights_feature),"
    },
    {
        "line": 83,
        "fullcodeline": "weights_feature->params.scale, GetTensorShape(float_weights_time),"
    },
    {
        "line": 84,
        "fullcodeline": "GetTensorData<float>(float_weights_time), GetTensorShape(bias),"
    },
    {
        "line": 85,
        "fullcodeline": "GetTensorData<float>(bias), GetTensorData<float>(scratch),"
    },
    {
        "line": 86,
        "fullcodeline": "GetTensorData<float>(scaling_factors),"
    },
    {
        "line": 87,
        "fullcodeline": "GetTensorData<int8_t>(input_quantized), GetTensorData<float>(state),"
    },
    {
        "line": 88,
        "fullcodeline": "GetTensorShape(output), GetTensorData<float>(output),"
    },
    {
        "line": 61,
        "fullcodeline": "const float dequantization_scale = weights_time->params.scale;"
    },
    {
        "line": 62,
        "fullcodeline": "const int8_t* weights_time_ptr = GetTensorData<int8_t>(weights_time);"
    },
    {
        "line": 75,
        "fullcodeline": "zero_points_ptr = GetTensorData<int32_t>(zero_points);"
    },
    {
        "line": 76,
        "fullcodeline": "row_sums_ptr = GetTensorData<int32_t>(row_sums);"
    },
    {
        "line": 64,
        "fullcodeline": "GetTensorData<float>(float_weights_time);"
    },
    {
        "line": 65,
        "fullcodeline": "for (int i = 0; i < NumElements(float_weights_time); ++i) {"
    },
    {
        "line": 67,
        "fullcodeline": "weights_time_ptr[i] * dequantization_scale;"
    }
]