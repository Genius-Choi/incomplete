[
    {
        "line": 7,
        "fullcodeline": "int retval=0;"
    },
    {
        "line": 9,
        "fullcodeline": "iw_tmpsample alphasamp = 0.0;"
    },
    {
        "line": 10,
        "fullcodeline": "iw_tmpsample *inpix_tofree = NULL; // Used if we need a separate temp buffer for input samples"
    },
    {
        "line": 11,
        "fullcodeline": "iw_tmpsample *outpix_tofree = NULL; // Used if we need a separate temp buffer for output samples"
    },
    {
        "line": 13,
        "fullcodeline": "int using_errdiffdither = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "double tmpbkgdalpha=0.0;"
    },
    {
        "line": 18,
        "fullcodeline": "int alt_bkgd = 0; // Nonzero if we should use bkgd2 for this sample"
    },
    {
        "line": 19,
        "fullcodeline": "struct iw_resize_settings *rs = NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "iw_tmpsample *in_pix = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "iw_tmpsample *out_pix = NULL;"
    },
    {
        "line": 29,
        "fullcodeline": "num_in_pix = ctx->intermed_canvas_width;"
    },
    {
        "line": 30,
        "fullcodeline": "num_out_pix = ctx->img2.width;"
    },
    {
        "line": 32,
        "fullcodeline": "int_ci = &ctx->intermed_ci[intermed_channel];"
    },
    {
        "line": 33,
        "fullcodeline": "output_channel = int_ci->corresponding_output_channel;"
    },
    {
        "line": 34,
        "fullcodeline": "out_ci = &ctx->img2_ci[output_channel];"
    },
    {
        "line": 35,
        "fullcodeline": "is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);"
    },
    {
        "line": 36,
        "fullcodeline": "bkgd_has_transparency = iw_bkgd_has_transparency(ctx);"
    },
    {
        "line": 38,
        "fullcodeline": "inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));"
    },
    {
        "line": 39,
        "fullcodeline": "in_pix = inpix_tofree;"
    },
    {
        "line": 42,
        "fullcodeline": "outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));"
    },
    {
        "line": 44,
        "fullcodeline": "out_pix = outpix_tofree;"
    },
    {
        "line": 58,
        "fullcodeline": "ditherfamily = out_ci->ditherfamily;"
    },
    {
        "line": 59,
        "fullcodeline": "dithersubtype = out_ci->dithersubtype;"
    },
    {
        "line": 82,
        "fullcodeline": "rs=&ctx->resize_settings[IW_DIMENSION_H];"
    },
    {
        "line": 200,
        "fullcodeline": "retval=1;"
    },
    {
        "line": 43,
        "fullcodeline": "if(!outpix_tofree) goto done;"
    },
    {
        "line": 47,
        "fullcodeline": "if(ctx->nearest_color_table && !is_alpha_channel &&"
    },
    {
        "line": 60,
        "fullcodeline": "if(ditherfamily==IW_DITHERFAMILY_RANDOM) {"
    },
    {
        "line": 73,
        "fullcodeline": "if(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {"
    },
    {
        "line": 86,
        "fullcodeline": "if(!rs->rrctx) {"
    },
    {
        "line": 92,
        "fullcodeline": "for(j=0;j<ctx->intermed_canvas_height;j++) {"
    },
    {
        "line": 203,
        "fullcodeline": "if(rs && rs->disable_rrctx_cache && rs->rrctx) {"
    },
    {
        "line": 49,
        "fullcodeline": "out_ci->color_count==0)"
    },
    {
        "line": 51,
        "fullcodeline": "out_ci->use_nearest_color_table = 1;"
    },
    {
        "line": 74,
        "fullcodeline": "using_errdiffdither = 1;"
    },
    {
        "line": 87,
        "fullcodeline": "rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,"
    },
    {
        "line": 109,
        "fullcodeline": "iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);"
    },
    {
        "line": 206,
        "fullcodeline": "iwpvt_resize_rows_done(rs->rrctx);"
    },
    {
        "line": 207,
        "fullcodeline": "rs->rrctx = NULL;"
    },
    {
        "line": 209,
        "fullcodeline": "if(inpix_tofree) iw_free(ctx,inpix_tofree);"
    },
    {
        "line": 210,
        "fullcodeline": "if(outpix_tofree) iw_free(ctx,outpix_tofree);"
    },
    {
        "line": 48,
        "fullcodeline": "out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&"
    },
    {
        "line": 54,
        "fullcodeline": "out_ci->use_nearest_color_table = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "if(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)"
    },
    {
        "line": 75,
        "fullcodeline": "for(i=0;i<ctx->img2.width;i++) {"
    },
    {
        "line": 89,
        "fullcodeline": "if(!rs->rrctx) goto done;"
    },
    {
        "line": 115,
        "fullcodeline": "if(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {"
    },
    {
        "line": 123,
        "fullcodeline": "if(output_channel == -1) {"
    },
    {
        "line": 130,
        "fullcodeline": "for(z=0;z<ctx->img2.width;z++) {"
    },
    {
        "line": 65,
        "fullcodeline": "iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);"
    },
    {
        "line": 112,
        "fullcodeline": "clamp_output_samples(ctx,out_pix,num_out_pix);"
    },
    {
        "line": 138,
        "fullcodeline": "tmpsamp = out_pix[i];"
    },
    {
        "line": 68,
        "fullcodeline": "iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);"
    },
    {
        "line": 76,
        "fullcodeline": "for(k=0;k<IW_DITHER_MAXROWS;k++) {"
    },
    {
        "line": 98,
        "fullcodeline": "for(i=0;i<num_in_pix;i++) {"
    },
    {
        "line": 116,
        "fullcodeline": "for(i=0;i<num_out_pix;i++) {"
    },
    {
        "line": 133,
        "fullcodeline": "if(using_errdiffdither && (j%2))"
    },
    {
        "line": 175,
        "fullcodeline": "if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)"
    },
    {
        "line": 186,
        "fullcodeline": "for(i=0;i<ctx->img2.width;i++) {"
    },
    {
        "line": 77,
        "fullcodeline": "ctx->dither_errors[k][i] = 0.0;"
    },
    {
        "line": 99,
        "fullcodeline": "inpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];"
    },
    {
        "line": 103,
        "fullcodeline": "for(i=0;i<num_in_pix;i++) {"
    },
    {
        "line": 117,
        "fullcodeline": "ctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];"
    },
    {
        "line": 134,
        "fullcodeline": "i=ctx->img2.width-1-z;"
    },
    {
        "line": 141,
        "fullcodeline": "alt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !="
    },
    {
        "line": 146,
        "fullcodeline": "tmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;"
    },
    {
        "line": 151,
        "fullcodeline": "alphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];"
    },
    {
        "line": 176,
        "fullcodeline": "put_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);"
    },
    {
        "line": 192,
        "fullcodeline": "ctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;"
    },
    {
        "line": 104,
        "fullcodeline": "inpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];"
    },
    {
        "line": 136,
        "fullcodeline": "i=z;"
    },
    {
        "line": 153,
        "fullcodeline": "if(alphasamp!=0.0) {"
    },
    {
        "line": 157,
        "fullcodeline": "if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {"
    },
    {
        "line": 178,
        "fullcodeline": "put_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);"
    },
    {
        "line": 188,
        "fullcodeline": "for(k=0;k<IW_DITHER_MAXROWS-1;k++) {"
    },
    {
        "line": 142,
        "fullcodeline": "(((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);"
    },
    {
        "line": 154,
        "fullcodeline": "tmpsamp /= alphasamp;"
    },
    {
        "line": 160,
        "fullcodeline": "bkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;"
    },
    {
        "line": 170,
        "fullcodeline": "else if(is_alpha_channel && bkgd_has_transparency) {"
    },
    {
        "line": 189,
        "fullcodeline": "ctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];"
    },
    {
        "line": 172,
        "fullcodeline": "tmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);"
    },
    {
        "line": 163,
        "fullcodeline": "tmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);"
    },
    {
        "line": 166,
        "fullcodeline": "tmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);"
    }
]