[
    {
        "line": 3,
        "fullcodeline": "mux_splicer.init(spin_workers_);"
    },
    {
        "line": 85,
        "fullcodeline": "TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us();"
    },
    {
        "line": 89,
        "fullcodeline": "colldata->worker_update_coefficient_position_progress( 64 );"
    },
    {
        "line": 90,
        "fullcodeline": "colldata->worker_update_bit_progress( 16 );"
    },
    {
        "line": 91,
        "fullcodeline": "write_byte_bill(Billing::DELIMITERS, true, mux_reader_.getOverhead());"
    },
    {
        "line": 8,
        "fullcodeline": "if ( thread_state_[0] == nullptr || thread_state_[0]->context_[0].isNil() ) {"
    },
    {
        "line": 86,
        "fullcodeline": "for (int component = 0; component < colldata->get_num_components(); ++component) {"
    },
    {
        "line": 10,
        "fullcodeline": "BlockBasedImagePerChannel<false> framebuffer;"
    },
    {
        "line": 11,
        "fullcodeline": "framebuffer.memset(0);"
    },
    {
        "line": 19,
        "fullcodeline": "size_t num_threads_needed = initialize_decoder_state(colldata,"
    },
    {
        "line": 49,
        "fullcodeline": "flush();"
    },
    {
        "line": 87,
        "fullcodeline": "colldata->worker_mark_cmp_finished((BlockType)component);"
    },
    {
        "line": 12,
        "fullcodeline": "for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) {"
    },
    {
        "line": 16,
        "fullcodeline": "for (size_t i = 0; i < all_framebuffers.size(); ++i) {"
    },
    {
        "line": 23,
        "fullcodeline": "for (size_t i = 0;i < num_threads_needed; ++i) {"
    },
    {
        "line": 26,
        "fullcodeline": "for (size_t i = 0;i < num_threads_needed; ++i) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (num_threads_needed > NUM_THREADS || num_threads_needed == 0) {"
    },
    {
        "line": 37,
        "fullcodeline": "for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {"
    },
    {
        "line": 50,
        "fullcodeline": "for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) {"
    },
    {
        "line": 67,
        "fullcodeline": "virtual_thread_id_ += 1; // first time's a charm"
    },
    {
        "line": 13,
        "fullcodeline": "framebuffer[i] = &colldata->full_component_write((BlockType)i);"
    },
    {
        "line": 17,
        "fullcodeline": "all_framebuffers[i] = framebuffer;"
    },
    {
        "line": 24,
        "fullcodeline": "map_logical_thread_to_physical_thread(i, i);"
    },
    {
        "line": 27,
        "fullcodeline": "initialize_thread_id(i, i, framebuffer);"
    },
    {
        "line": 38,
        "fullcodeline": "unsigned int cur_spin_worker = thread_id;"
    },
    {
        "line": 39,
        "fullcodeline": "spin_workers_[cur_spin_worker].work"
    },
    {
        "line": 47,
        "fullcodeline": "spin_workers_[cur_spin_worker].activate_work();"
    },
    {
        "line": 51,
        "fullcodeline": "unsigned int cur_spin_worker = thread_id;"
    },
    {
        "line": 52,
        "fullcodeline": "TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us();"
    },
    {
        "line": 53,
        "fullcodeline": "spin_workers_[cur_spin_worker].main_wait_for_done();"
    },
    {
        "line": 54,
        "fullcodeline": "TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us();"
    },
    {
        "line": 58,
        "fullcodeline": "if (virtual_thread_id_ != -1) {"
    },
    {
        "line": 68,
        "fullcodeline": "for (unsigned int thread_id = virtual_thread_id_; thread_id < NUM_THREADS; ++thread_id, ++virtual_thread_id_) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (!do_threading_) {"
    },
    {
        "line": 40,
        "fullcodeline": "= std::bind(worker_thread,"
    },
    {
        "line": 59,
        "fullcodeline": "TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();"
    },
    {
        "line": 60,
        "fullcodeline": "CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata);"
    },
    {
        "line": 64,
        "fullcodeline": "TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();"
    },
    {
        "line": 69,
        "fullcodeline": "BlockBasedImagePerChannel<false> framebuffer;"
    },
    {
        "line": 70,
        "fullcodeline": "framebuffer.memset(0);"
    },
    {
        "line": 75,
        "fullcodeline": "initialize_thread_id(thread_id, 0, framebuffer);"
    },
    {
        "line": 76,
        "fullcodeline": "thread_state_[0]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer));"
    },
    {
        "line": 77,
        "fullcodeline": "TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us();"
    },
    {
        "line": 82,
        "fullcodeline": "TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us();"
    },
    {
        "line": 45,
        "fullcodeline": "getWorker(cur_spin_worker),"
    },
    {
        "line": 61,
        "fullcodeline": "if (ret == CODING_PARTIAL) {"
    },
    {
        "line": 71,
        "fullcodeline": "for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) {"
    },
    {
        "line": 79,
        "fullcodeline": "if ((ret = thread_state_[0]->vp8_decode_thread(0, colldata)) == CODING_PARTIAL) {"
    },
    {
        "line": 72,
        "fullcodeline": "framebuffer[i] = &colldata->full_component_write((BlockType)i);"
    }
]