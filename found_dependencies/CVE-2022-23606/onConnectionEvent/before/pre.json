[
    {
        "line": 3,
        "fullcodeline": "if (client.state() == ActiveClient::State::CONNECTING) {"
    },
    {
        "line": 13,
        "fullcodeline": "if (event == Network::ConnectionEvent::RemoteClose ||"
    },
    {
        "line": 4,
        "fullcodeline": "ASSERT(connecting_stream_capacity_ >= client.effectiveConcurrentStreamLimit());"
    },
    {
        "line": 5,
        "fullcodeline": "connecting_stream_capacity_ -= client.effectiveConcurrentStreamLimit();"
    },
    {
        "line": 9,
        "fullcodeline": "client.connect_timer_->disableTimer();"
    },
    {
        "line": 10,
        "fullcodeline": "client.connect_timer_.reset();"
    },
    {
        "line": 14,
        "fullcodeline": "event == Network::ConnectionEvent::LocalClose) {"
    },
    {
        "line": 15,
        "fullcodeline": "state_.decrConnectingAndConnectedStreamCapacity(client.currentUnusedCapacity());"
    },
    {
        "line": 17,
        "fullcodeline": "client.remaining_streams_ = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "ENVOY_CONN_LOG(debug, \"client disconnected, failure reason: {}\", client, failure_reason);"
    },
    {
        "line": 21,
        "fullcodeline": "Envoy::Upstream::reportUpstreamCxDestroy(host_, event);"
    },
    {
        "line": 22,
        "fullcodeline": "const bool incomplete_stream = client.closingWithIncompleteStream();"
    },
    {
        "line": 57,
        "fullcodeline": "client.releaseResources();"
    },
    {
        "line": 69,
        "fullcodeline": "dispatcher_.deferredDelete(client.removeFromList(owningList(client.state())));"
    },
    {
        "line": 71,
        "fullcodeline": "checkForIdleAndCloseIdleConnsIfDraining();"
    },
    {
        "line": 73,
        "fullcodeline": "client.setState(ActiveClient::State::CLOSED);"
    },
    {
        "line": 27,
        "fullcodeline": "if (client.state() == ActiveClient::State::CONNECTING) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (!pending_streams_.empty()) {"
    },
    {
        "line": 24,
        "fullcodeline": "Envoy::Upstream::reportUpstreamCxDestroyActiveRequest(host_, event);"
    },
    {
        "line": 28,
        "fullcodeline": "host_->cluster().stats().upstream_cx_connect_fail_.inc();"
    },
    {
        "line": 29,
        "fullcodeline": "host_->stats().cx_connect_fail_.inc();"
    },
    {
        "line": 46,
        "fullcodeline": "purgePendingStreams(client.real_host_description_, failure_reason, reason);"
    },
    {
        "line": 65,
        "fullcodeline": "client.connection_duration_timer_->disableTimer();"
    },
    {
        "line": 66,
        "fullcodeline": "client.connection_duration_timer_.reset();"
    },
    {
        "line": 77,
        "fullcodeline": "tryCreateNewConnections();"
    },
    {
        "line": 48,
        "fullcodeline": "if (!is_draining_for_deletion_) {"
    },
    {
        "line": 80,
        "fullcodeline": "client.conn_connect_ms_->complete();"
    },
    {
        "line": 81,
        "fullcodeline": "client.conn_connect_ms_.reset();"
    },
    {
        "line": 84,
        "fullcodeline": "transitionActiveClientState(client, streams_available ? ActiveClient::State::READY"
    },
    {
        "line": 88,
        "fullcodeline": "const absl::optional<std::chrono::milliseconds> max_connection_duration ="
    },
    {
        "line": 33,
        "fullcodeline": "reason = ConnectionPool::PoolFailureReason::Timeout;"
    },
    {
        "line": 82,
        "fullcodeline": "ASSERT(client.state() == ActiveClient::State::CONNECTING);"
    },
    {
        "line": 83,
        "fullcodeline": "bool streams_available = client.currentUnusedCapacity() > 0;"
    },
    {
        "line": 89,
        "fullcodeline": "client.parent_.host()->cluster().maxConnectionDuration();"
    },
    {
        "line": 90,
        "fullcodeline": "if (max_connection_duration.has_value()) {"
    },
    {
        "line": 91,
        "fullcodeline": "client.connection_duration_timer_ = client.parent_.dispatcher().createTimer("
    },
    {
        "line": 93,
        "fullcodeline": "client.connection_duration_timer_->enableTimer(max_connection_duration.value());"
    },
    {
        "line": 34,
        "fullcodeline": "} else if (event == Network::ConnectionEvent::RemoteClose) {"
    },
    {
        "line": 35,
        "fullcodeline": "reason = ConnectionPool::PoolFailureReason::RemoteConnectionFailure;"
    },
    {
        "line": 37,
        "fullcodeline": "reason = ConnectionPool::PoolFailureReason::LocalConnectionFailure;"
    }
]