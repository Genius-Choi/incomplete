[
    {
        "line": 3,
        "fullcodeline": "const char *fmt = luaL_checkstring(L, 1);"
    },
    {
        "line": 5,
        "fullcodeline": "const char *data = luaL_checklstring(L, 2, &ld);"
    },
    {
        "line": 6,
        "fullcodeline": "size_t pos = luaL_optinteger(L, 3, 1) - 1;"
    },
    {
        "line": 7,
        "fullcodeline": "int n = 0;  /* number of results */"
    },
    {
        "line": 8,
        "fullcodeline": "defaultoptions(&h);"
    },
    {
        "line": 65,
        "fullcodeline": "lua_pushinteger(L, pos + 1);  /* next position */"
    },
    {
        "line": 66,
        "fullcodeline": "return n + 1;"
    },
    {
        "line": 10,
        "fullcodeline": "int opt = *fmt++;"
    },
    {
        "line": 11,
        "fullcodeline": "size_t size = optsize(L, opt, &fmt);"
    },
    {
        "line": 12,
        "fullcodeline": "pos += gettoalign(pos, &h, opt, size);"
    },
    {
        "line": 13,
        "fullcodeline": "luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");"
    },
    {
        "line": 15,
        "fullcodeline": "luaL_checkstack(L, 2, \"too many results\");"
    },
    {
        "line": 63,
        "fullcodeline": "pos += size;"
    },
    {
        "line": 61,
        "fullcodeline": "default: controloptions(L, opt, &fmt, &h);"
    },
    {
        "line": 19,
        "fullcodeline": "int issigned = islower(opt);"
    },
    {
        "line": 20,
        "fullcodeline": "lua_Number res = getinteger(data+pos, h.endian, issigned, size);"
    },
    {
        "line": 21,
        "fullcodeline": "lua_pushnumber(L, res); n++;"
    },
    {
        "line": 29,
        "fullcodeline": "memcpy(&f, data+pos, size);"
    },
    {
        "line": 30,
        "fullcodeline": "correctbytes((char *)&f, sizeof(f), h.endian);"
    },
    {
        "line": 31,
        "fullcodeline": "lua_pushnumber(L, f); n++;"
    },
    {
        "line": 36,
        "fullcodeline": "memcpy(&d, data+pos, size);"
    },
    {
        "line": 37,
        "fullcodeline": "correctbytes((char *)&d, sizeof(d), h.endian);"
    },
    {
        "line": 38,
        "fullcodeline": "lua_pushnumber(L, d); n++;"
    },
    {
        "line": 50,
        "fullcodeline": "lua_pushlstring(L, data+pos, size); n++;"
    },
    {
        "line": 54,
        "fullcodeline": "const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);"
    },
    {
        "line": 57,
        "fullcodeline": "size = (e - (data+pos)) + 1;"
    },
    {
        "line": 58,
        "fullcodeline": "lua_pushlstring(L, data+pos, size - 1); n++;"
    },
    {
        "line": 42,
        "fullcodeline": "if (size == 0) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (e == NULL)"
    },
    {
        "line": 45,
        "fullcodeline": "size = lua_tonumber(L, -1);"
    },
    {
        "line": 46,
        "fullcodeline": "lua_pop(L, 1); n--;"
    },
    {
        "line": 47,
        "fullcodeline": "luaL_argcheck(L, size <= ld && pos <= ld - size,"
    },
    {
        "line": 56,
        "fullcodeline": "luaL_error(L, \"unfinished string in data\");"
    },
    {
        "line": 43,
        "fullcodeline": "if (n == 0 || !lua_isnumber(L, -1))"
    },
    {
        "line": 44,
        "fullcodeline": "luaL_error(L, \"format 'c0' needs a previous size\");"
    }
]