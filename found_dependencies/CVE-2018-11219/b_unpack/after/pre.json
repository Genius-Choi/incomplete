[
    {
        "line": 3,
        "fullcodeline": "const char *fmt = luaL_checkstring(L, 1);"
    },
    {
        "line": 5,
        "fullcodeline": "const char *data = luaL_checklstring(L, 2, &ld);"
    },
    {
        "line": 6,
        "fullcodeline": "size_t pos = luaL_optinteger(L, 3, 1);"
    },
    {
        "line": 7,
        "fullcodeline": "luaL_argcheck(L, pos > 0, 3, \"offset must be 1 or greater\");"
    },
    {
        "line": 8,
        "fullcodeline": "pos--; /* Lua indexes are 1-based, but here we want 0-based for C"
    },
    {
        "line": 10,
        "fullcodeline": "int n = 0;  /* number of results */"
    },
    {
        "line": 11,
        "fullcodeline": "defaultoptions(&h);"
    },
    {
        "line": 69,
        "fullcodeline": "lua_pushinteger(L, pos + 1);  /* next position */"
    },
    {
        "line": 70,
        "fullcodeline": "return n + 1;"
    },
    {
        "line": 13,
        "fullcodeline": "int opt = *fmt++;"
    },
    {
        "line": 14,
        "fullcodeline": "size_t size = optsize(L, opt, &fmt);"
    },
    {
        "line": 15,
        "fullcodeline": "pos += gettoalign(pos, &h, opt, size);"
    },
    {
        "line": 16,
        "fullcodeline": "luaL_argcheck(L, size <= ld && pos <= ld - size,"
    },
    {
        "line": 19,
        "fullcodeline": "luaL_checkstack(L, 2, \"too many results\");"
    },
    {
        "line": 67,
        "fullcodeline": "pos += size;"
    },
    {
        "line": 65,
        "fullcodeline": "default: controloptions(L, opt, &fmt, &h);"
    },
    {
        "line": 23,
        "fullcodeline": "int issigned = islower(opt);"
    },
    {
        "line": 24,
        "fullcodeline": "lua_Number res = getinteger(data+pos, h.endian, issigned, size);"
    },
    {
        "line": 25,
        "fullcodeline": "lua_pushnumber(L, res); n++;"
    },
    {
        "line": 33,
        "fullcodeline": "memcpy(&f, data+pos, size);"
    },
    {
        "line": 34,
        "fullcodeline": "correctbytes((char *)&f, sizeof(f), h.endian);"
    },
    {
        "line": 35,
        "fullcodeline": "lua_pushnumber(L, f); n++;"
    },
    {
        "line": 40,
        "fullcodeline": "memcpy(&d, data+pos, size);"
    },
    {
        "line": 41,
        "fullcodeline": "correctbytes((char *)&d, sizeof(d), h.endian);"
    },
    {
        "line": 42,
        "fullcodeline": "lua_pushnumber(L, d); n++;"
    },
    {
        "line": 54,
        "fullcodeline": "lua_pushlstring(L, data+pos, size); n++;"
    },
    {
        "line": 58,
        "fullcodeline": "const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);"
    },
    {
        "line": 61,
        "fullcodeline": "size = (e - (data+pos)) + 1;"
    },
    {
        "line": 62,
        "fullcodeline": "lua_pushlstring(L, data+pos, size - 1); n++;"
    },
    {
        "line": 46,
        "fullcodeline": "if (size == 0) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (e == NULL)"
    },
    {
        "line": 49,
        "fullcodeline": "size = lua_tonumber(L, -1);"
    },
    {
        "line": 50,
        "fullcodeline": "lua_pop(L, 1); n--;"
    },
    {
        "line": 51,
        "fullcodeline": "luaL_argcheck(L, size <= ld && pos <= ld - size,"
    },
    {
        "line": 60,
        "fullcodeline": "luaL_error(L, \"unfinished string in data\");"
    },
    {
        "line": 47,
        "fullcodeline": "if (n == 0 || !lua_isnumber(L, -1))"
    },
    {
        "line": 48,
        "fullcodeline": "luaL_error(L, \"format 'c0' needs a previous size\");"
    }
]