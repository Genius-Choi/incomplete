[
    {
        "line": 2,
        "fullcodeline": "core::RefCountPtr<Var> v;"
    },
    {
        "line": 3,
        "fullcodeline": "OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));"
    },
    {
        "line": 4,
        "fullcodeline": "Tensor* params = v->tensor();"
    },
    {
        "line": 5,
        "fullcodeline": "const Tensor& indices = c->input(1);"
    },
    {
        "line": 6,
        "fullcodeline": "const Tensor& updates = c->input(2);"
    },
    {
        "line": 9,
        "fullcodeline": "OP_REQUIRES(c,"
    },
    {
        "line": 20,
        "fullcodeline": "const int64_t N_big = indices.NumElements();"
    },
    {
        "line": 21,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 27,
        "fullcodeline": "const Index N = static_cast<Index>(N_big);"
    },
    {
        "line": 28,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 10,
        "fullcodeline": "updates.dims() == 0 ||"
    },
    {
        "line": 12,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 22,
        "fullcodeline": "c, N_big <= std::numeric_limits<Index>::max(),"
    },
    {
        "line": 23,
        "fullcodeline": "errors::InvalidArgument(\"indices has too many elements for \","
    },
    {
        "line": 29,
        "fullcodeline": "c, params->dim_size(0) <= std::numeric_limits<Index>::max(),"
    },
    {
        "line": 30,
        "fullcodeline": "errors::InvalidArgument(\"params.shape[0] too large for \","
    },
    {
        "line": 36,
        "fullcodeline": "if (isCPUDevice<Device>() && op == tensorflow::scatter_op::UpdateOp::DIV) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (N > 0) {"
    },
    {
        "line": 11,
        "fullcodeline": "updates.dims() == indices.dims() + params->dims() - 1,"
    },
    {
        "line": 15,
        "fullcodeline": "\"updates.shape \", updates.shape().DebugString(),"
    },
    {
        "line": 16,
        "fullcodeline": "\", indices.shape \", indices.shape().DebugString(),"
    },
    {
        "line": 17,
        "fullcodeline": "\", params.shape \", params->shape().DebugString()));"
    },
    {
        "line": 24,
        "fullcodeline": "DataTypeString(DataTypeToEnum<Index>::v()),"
    },
    {
        "line": 26,
        "fullcodeline": "std::numeric_limits<Index>::max()));"
    },
    {
        "line": 31,
        "fullcodeline": "DataTypeString(DataTypeToEnum<Index>::v()),"
    },
    {
        "line": 32,
        "fullcodeline": "\" indexing: \", params->dim_size(0), \" > \","
    },
    {
        "line": 33,
        "fullcodeline": "std::numeric_limits<Index>::max()));"
    },
    {
        "line": 37,
        "fullcodeline": "OP_REQUIRES(c, ValidateInput<T>(updates),"
    },
    {
        "line": 42,
        "fullcodeline": "auto indices_flat = indices.flat<Index>();"
    },
    {
        "line": 43,
        "fullcodeline": "auto params_flat = params->flat_outer_dims<T>();"
    },
    {
        "line": 38,
        "fullcodeline": "errors::InvalidArgument(\"updates must not contain 0\"));"
    },
    {
        "line": 44,
        "fullcodeline": "if (TensorShapeUtils::IsScalar(updates.shape())) {"
    },
    {
        "line": 45,
        "fullcodeline": "const auto update = updates.scalar<T>();"
    },
    {
        "line": 47,
        "fullcodeline": "functor::ScatterScalarFunctor<Device, T, Index, op> functor;"
    },
    {
        "line": 48,
        "fullcodeline": "const Index bad_i = functor(c, c->template eigen_device<Device>(),"
    },
    {
        "line": 50,
        "fullcodeline": "OP_REQUIRES(c, bad_i < 0,"
    },
    {
        "line": 51,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 56,
        "fullcodeline": "int64_t num_updates = updates.NumElements();"
    },
    {
        "line": 57,
        "fullcodeline": "OP_REQUIRES("
    },
    {
        "line": 63,
        "fullcodeline": "auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});"
    },
    {
        "line": 65,
        "fullcodeline": "functor::ScatterFunctor<Device, T, Index, op> functor;"
    },
    {
        "line": 66,
        "fullcodeline": "const Index bad_i = functor(c, c->template eigen_device<Device>(),"
    },
    {
        "line": 68,
        "fullcodeline": "OP_REQUIRES(c, bad_i < 0,"
    },
    {
        "line": 52,
        "fullcodeline": "\"indices\", SliceDebugString(indices.shape(), bad_i),"
    },
    {
        "line": 53,
        "fullcodeline": "\" = \", indices_flat(bad_i), \" is not in [0, \","
    },
    {
        "line": 54,
        "fullcodeline": "params->dim_size(0), \")\"));"
    },
    {
        "line": 58,
        "fullcodeline": "c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),"
    },
    {
        "line": 59,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 69,
        "fullcodeline": "errors::InvalidArgument("
    },
    {
        "line": 60,
        "fullcodeline": "\"The shape of indices (\", indices.shape().DebugString(),"
    },
    {
        "line": 62,
        "fullcodeline": "updates.shape().DebugString(), \")\"));"
    },
    {
        "line": 70,
        "fullcodeline": "\"indices\", SliceDebugString(indices.shape(), bad_i),"
    },
    {
        "line": 71,
        "fullcodeline": "\" = \", indices_flat(bad_i), \" is not in [0, \","
    },
    {
        "line": 72,
        "fullcodeline": "params->dim_size(0), \")\"));"
    }
]