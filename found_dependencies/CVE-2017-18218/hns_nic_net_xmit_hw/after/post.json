[
    {
        "line": 5,
        "fullcodeline": "struct hns_nic_priv *priv = netdev_priv(ndev);"
    },
    {
        "line": 6,
        "fullcodeline": "struct hnae_ring *ring = ring_data->ring;"
    },
    {
        "line": 7,
        "fullcodeline": "struct device *dev = ring_to_dev(ring);"
    },
    {
        "line": 29,
        "fullcodeline": "seg_num = skb_shinfo(skb)->nr_frags + 1;"
    },
    {
        "line": 30,
        "fullcodeline": "next_to_use = ring->next_to_use;"
    },
    {
        "line": 33,
        "fullcodeline": "size = skb_headlen(skb);"
    },
    {
        "line": 34,
        "fullcodeline": "dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);"
    },
    {
        "line": 40,
        "fullcodeline": "priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,"
    },
    {
        "line": 59,
        "fullcodeline": "dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);"
    },
    {
        "line": 60,
        "fullcodeline": "netdev_tx_sent_queue(dev_queue, skb->len);"
    },
    {
        "line": 62,
        "fullcodeline": "netif_trans_update(ndev);"
    },
    {
        "line": 63,
        "fullcodeline": "ndev->stats.tx_bytes += skb->len;"
    },
    {
        "line": 66,
        "fullcodeline": "wmb(); /* commit all data before submit */"
    },
    {
        "line": 67,
        "fullcodeline": "assert(skb->queue_mapping < priv->ae_handle->q_num);"
    },
    {
        "line": 68,
        "fullcodeline": "hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);"
    },
    {
        "line": 70,
        "fullcodeline": "ring->stats.tx_bytes += skb->len;"
    },
    {
        "line": 92,
        "fullcodeline": "dev_kfree_skb_any(skb);"
    },
    {
        "line": 97,
        "fullcodeline": "netif_stop_subqueue(ndev, skb->queue_mapping);"
    },
    {
        "line": 103,
        "fullcodeline": "smp_mb();"
    },
    {
        "line": 16,
        "fullcodeline": "switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (dma_mapping_error(dev, dma)) {"
    },
    {
        "line": 44,
        "fullcodeline": "for (i = 1; i < seg_num; i++) {"
    },
    {
        "line": 76,
        "fullcodeline": "while (ring->next_to_use != next_to_use) {"
    },
    {
        "line": 17,
        "fullcodeline": "case -EBUSY:"
    },
    {
        "line": 20,
        "fullcodeline": "case -ENOMEM:"
    },
    {
        "line": 22,
        "fullcodeline": "netdev_err(ndev, \"no memory to xmit!\\n\");"
    },
    {
        "line": 36,
        "fullcodeline": "netdev_err(ndev, \"TX head DMA map failed\\n\");"
    },
    {
        "line": 46,
        "fullcodeline": "size = skb_frag_size(frag);"
    },
    {
        "line": 47,
        "fullcodeline": "dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);"
    },
    {
        "line": 53,
        "fullcodeline": "priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,"
    },
    {
        "line": 77,
        "fullcodeline": "unfill_desc(ring);"
    },
    {
        "line": 48,
        "fullcodeline": "if (dma_mapping_error(dev, dma)) {"
    },
    {
        "line": 54,
        "fullcodeline": "seg_num - 1 == i ? 1 : 0, buf_num,"
    },
    {
        "line": 78,
        "fullcodeline": "if (ring->next_to_use != next_to_use)"
    },
    {
        "line": 49,
        "fullcodeline": "netdev_err(ndev, \"TX frag(%d) DMA map failed\\n\", i);"
    },
    {
        "line": 79,
        "fullcodeline": "dma_unmap_page(dev,"
    },
    {
        "line": 45,
        "fullcodeline": "frag = &skb_shinfo(skb)->frags[i - 1];"
    },
    {
        "line": 84,
        "fullcodeline": "dma_unmap_single(dev,"
    }
]