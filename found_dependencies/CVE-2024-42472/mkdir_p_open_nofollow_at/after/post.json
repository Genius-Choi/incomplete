[
    {
        "line": 8,
        "fullcodeline": "glnx_autofd int parent_fd = -1;"
    },
    {
        "line": 21,
        "fullcodeline": "g_autofree char *subdir_dirname = g_path_get_dirname (subdir);"
    },
    {
        "line": 40,
        "fullcodeline": "g_autofree char *subdir_basename = g_path_get_basename (subdir);"
    },
    {
        "line": 55,
        "fullcodeline": "int fd = openat (parent_fd, subdir_basename, O_PATH | O_NONBLOCK | O_DIRECTORY | O_CLOEXEC | O_NOCTTY | O_NOFOLLOW);"
    },
    {
        "line": 75,
        "fullcodeline": "*out_fd = fd;"
    },
    {
        "line": 10,
        "fullcodeline": "if (g_path_is_absolute (subdir))"
    },
    {
        "line": 23,
        "fullcodeline": "if (strcmp (subdir_dirname, \".\") == 0)"
    },
    {
        "line": 42,
        "fullcodeline": "if (strcmp (subdir_basename, \".\") == 0)"
    },
    {
        "line": 52,
        "fullcodeline": "if (!glnx_shutil_mkdir_p_at (parent_fd, subdir_basename, mode, NULL, error))"
    },
    {
        "line": 56,
        "fullcodeline": "if (fd == -1)"
    },
    {
        "line": 12,
        "fullcodeline": "const char *skipped_prefix = subdir;"
    },
    {
        "line": 17,
        "fullcodeline": "g_warning (\"--persist=\\\"%s\\\" is deprecated, treating it as --persist=\\\"%s\\\"\", subdir, skipped_prefix);"
    },
    {
        "line": 18,
        "fullcodeline": "subdir = skipped_prefix;"
    },
    {
        "line": 44,
        "fullcodeline": "*out_fd = glnx_steal_fd (&parent_fd);"
    },
    {
        "line": 58,
        "fullcodeline": "int saved_errno = errno;"
    },
    {
        "line": 14,
        "fullcodeline": "while (*skipped_prefix == '/')"
    },
    {
        "line": 15,
        "fullcodeline": "skipped_prefix++;"
    },
    {
        "line": 26,
        "fullcodeline": "if (!glnx_opendirat (base_fd, basedir, TRUE, &parent_fd, error))"
    },
    {
        "line": 67,
        "fullcodeline": "if (saved_errno == ENOTDIR &&"
    },
    {
        "line": 72,
        "fullcodeline": "return glnx_throw_errno_prefix (error, \"openat(%s)\", subdir_basename);"
    },
    {
        "line": 29,
        "fullcodeline": "else if (strcmp (subdir_dirname, \"..\") == 0)"
    },
    {
        "line": 47,
        "fullcodeline": "else if (strcmp (subdir_basename, \"..\") == 0)"
    },
    {
        "line": 69,
        "fullcodeline": "S_ISLNK (stat_buf.st_mode))"
    },
    {
        "line": 68,
        "fullcodeline": "fstatat (parent_fd, subdir_basename, &stat_buf, AT_SYMLINK_NOFOLLOW) == 0 &&"
    },
    {
        "line": 70,
        "fullcodeline": "return glnx_throw (error, \"Symbolic link \\\"%s\\\" not allowed to avoid sandbox escape\", subdir_basename);"
    },
    {
        "line": 31,
        "fullcodeline": "return glnx_throw (error, \"'..' not supported in --persist paths\");"
    },
    {
        "line": 49,
        "fullcodeline": "return glnx_throw (error, \"'..' not supported in --persist paths\");"
    },
    {
        "line": 35,
        "fullcodeline": "if (!mkdir_p_open_nofollow_at (base_fd, basedir, mode,"
    }
]