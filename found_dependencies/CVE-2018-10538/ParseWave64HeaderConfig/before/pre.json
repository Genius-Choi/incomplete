[
    {
        "line": 3,
        "fullcodeline": "int64_t total_samples = 0, infilesize;"
    },
    {
        "line": 9,
        "fullcodeline": "infilesize = DoGetFileSize (infile);"
    },
    {
        "line": 10,
        "fullcodeline": "memcpy (&filehdr, fourcc, 4);"
    },
    {
        "line": 25,
        "fullcodeline": "WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);"
    },
    {
        "line": 12,
        "fullcodeline": "if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||"
    },
    {
        "line": 14,
        "fullcodeline": "memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {"
    },
    {
        "line": 15,
        "fullcodeline": "error_line (\"%s is not a valid .W64 file!\", infilename);"
    },
    {
        "line": 27,
        "fullcodeline": "if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&"
    },
    {
        "line": 28,
        "fullcodeline": "filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {"
    },
    {
        "line": 49,
        "fullcodeline": "WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);"
    },
    {
        "line": 50,
        "fullcodeline": "chunk_header.ckSize -= sizeof (chunk_header);"
    },
    {
        "line": 215,
        "fullcodeline": "if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {"
    },
    {
        "line": 13,
        "fullcodeline": "bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||"
    },
    {
        "line": 216,
        "fullcodeline": "error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 38,
        "fullcodeline": "if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||"
    },
    {
        "line": 39,
        "fullcodeline": "bcount != sizeof (Wave64ChunkHeader)) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {"
    },
    {
        "line": 56,
        "fullcodeline": "int supported = TRUE, format;"
    },
    {
        "line": 58,
        "fullcodeline": "chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;"
    },
    {
        "line": 72,
        "fullcodeline": "WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);"
    },
    {
        "line": 93,
        "fullcodeline": "format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?"
    },
    {
        "line": 96,
        "fullcodeline": "config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?"
    },
    {
        "line": 18,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 19,
        "fullcodeline": "!WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (chunk_header.ckSize < 40) {"
    },
    {
        "line": 20,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 60,
        "fullcodeline": "if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||"
    },
    {
        "line": 62,
        "fullcodeline": "bcount != chunk_header.ckSize) {"
    },
    {
        "line": 75,
        "fullcodeline": "error_line (\"format tag size = %d\", chunk_header.ckSize);"
    },
    {
        "line": 76,
        "fullcodeline": "error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\","
    },
    {
        "line": 78,
        "fullcodeline": "error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\","
    },
    {
        "line": 90,
        "fullcodeline": "if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)"
    },
    {
        "line": 91,
        "fullcodeline": "config->qmode |= QMODE_ADOBE_MODE;"
    },
    {
        "line": 99,
        "fullcodeline": "if (format != 1 && format != 3)"
    },
    {
        "line": 100,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 102,
        "fullcodeline": "if (format == 3 && config->bits_per_sample != 32)"
    },
    {
        "line": 103,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 105,
        "fullcodeline": "if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||"
    },
    {
        "line": 108,
        "fullcodeline": "WaveHeader.BlockAlign % WaveHeader.NumChannels)"
    },
    {
        "line": 109,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 111,
        "fullcodeline": "if (config->bits_per_sample < 1 || config->bits_per_sample > 32)"
    },
    {
        "line": 112,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 137,
        "fullcodeline": "config->float_norm_exp = 127;"
    },
    {
        "line": 43,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 44,
        "fullcodeline": "!WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {"
    },
    {
        "line": 61,
        "fullcodeline": "!DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||"
    },
    {
        "line": 81,
        "fullcodeline": "if (chunk_header.ckSize > 16)"
    },
    {
        "line": 85,
        "fullcodeline": "if (chunk_header.ckSize > 20)"
    },
    {
        "line": 107,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||"
    },
    {
        "line": 147,
        "fullcodeline": "if (config->float_norm_exp == 127)"
    },
    {
        "line": 154,
        "fullcodeline": "else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop"
    },
    {
        "line": 188,
        "fullcodeline": "config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;"
    },
    {
        "line": 189,
        "fullcodeline": "config->num_channels = WaveHeader.NumChannels;"
    },
    {
        "line": 190,
        "fullcodeline": "config->sample_rate = WaveHeader.SampleRate;"
    },
    {
        "line": 45,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 82,
        "fullcodeline": "error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,"
    },
    {
        "line": 86,
        "fullcodeline": "error_line (\"ChannelMask = %x, SubFormat = %d\","
    },
    {
        "line": 106,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||"
    },
    {
        "line": 120,
        "fullcodeline": "if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {"
    },
    {
        "line": 129,
        "fullcodeline": "else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {"
    },
    {
        "line": 156,
        "fullcodeline": "if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk"
    },
    {
        "line": 194,
        "fullcodeline": "int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;"
    },
    {
        "line": 195,
        "fullcodeline": "char *buff = malloc (bytes_to_copy);"
    },
    {
        "line": 66,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 67,
        "fullcodeline": "!WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (WaveHeader.NumChannels <= 2)"
    },
    {
        "line": 138,
        "fullcodeline": "else if ((config->qmode & QMODE_ADOBE_MODE) &&"
    },
    {
        "line": 139,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {"
    },
    {
        "line": 150,
        "fullcodeline": "error_line (\"data format: %d-bit integers stored in %d byte(s)\","
    },
    {
        "line": 161,
        "fullcodeline": "if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {"
    },
    {
        "line": 162,
        "fullcodeline": "config->qmode |= QMODE_IGNORE_LENGTH;"
    },
    {
        "line": 68,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 122,
        "fullcodeline": "config->channel_mask = 0x5 - WaveHeader.NumChannels;"
    },
    {
        "line": 140,
        "fullcodeline": "if (WaveHeader.BitsPerSample == 24)"
    },
    {
        "line": 151,
        "fullcodeline": "config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);"
    },
    {
        "line": 164,
        "fullcodeline": "if (infilesize && DoGetFilePosition (infile) != -1)"
    },
    {
        "line": 175,
        "fullcodeline": "total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;"
    },
    {
        "line": 198,
        "fullcodeline": "error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\","
    },
    {
        "line": 202,
        "fullcodeline": "if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||"
    },
    {
        "line": 204,
        "fullcodeline": "(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 141,
        "fullcodeline": "config->float_norm_exp = 127 + 23;"
    },
    {
        "line": 165,
        "fullcodeline": "total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;"
    },
    {
        "line": 177,
        "fullcodeline": "if (!total_samples) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (total_samples > MAX_WAVPACK_SAMPLES) {"
    },
    {
        "line": 203,
        "fullcodeline": "bcount != bytes_to_copy ||"
    },
    {
        "line": 205,
        "fullcodeline": "!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {"
    },
    {
        "line": 206,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 123,
        "fullcodeline": "else if (WaveHeader.NumChannels <= 18)"
    },
    {
        "line": 134,
        "fullcodeline": "config->channel_mask = WaveHeader.ChannelMask;"
    },
    {
        "line": 167,
        "fullcodeline": "total_samples = -1;"
    },
    {
        "line": 170,
        "fullcodeline": "if (infilesize && infilesize - chunk_header.ckSize > 16777216) {"
    },
    {
        "line": 124,
        "fullcodeline": "config->channel_mask = (1 << WaveHeader.NumChannels) - 1;"
    },
    {
        "line": 142,
        "fullcodeline": "else if (WaveHeader.BitsPerSample == 32)"
    },
    {
        "line": 126,
        "fullcodeline": "config->channel_mask = 0x3ffff;"
    },
    {
        "line": 143,
        "fullcodeline": "config->float_norm_exp = 127 + 15;"
    }
]