[
    {
        "line": 13,
        "fullcodeline": "char ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];"
    },
    {
        "line": 14,
        "fullcodeline": "char **patterns = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "size_t n, npatterns = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "struct timeval tv[2];"
    },
    {
        "line": 25,
        "fullcodeline": "setimes = targisdir = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "mask = umask(0);"
    },
    {
        "line": 33,
        "fullcodeline": "targ = *argv;"
    },
    {
        "line": 37,
        "fullcodeline": "(void) atomicio(vwrite, remout, \"\", 1);"
    },
    {
        "line": 313,
        "fullcodeline": "free(patterns);"
    },
    {
        "line": 22,
        "fullcodeline": "if (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))"
    },
    {
        "line": 27,
        "fullcodeline": "if (!pflag)"
    },
    {
        "line": 29,
        "fullcodeline": "if (argc != 1) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))"
    },
    {
        "line": 40,
        "fullcodeline": "if (src != NULL && !iamrecursive && !Tflag) {"
    },
    {
        "line": 48,
        "fullcodeline": "for (first = 1;; first = 0) {"
    },
    {
        "line": 311,
        "fullcodeline": "for (n = 0; n < npatterns; n++)"
    },
    {
        "line": 312,
        "fullcodeline": "free(patterns[n]);"
    },
    {
        "line": 316,
        "fullcodeline": "for (n = 0; n < npatterns; n++)"
    },
    {
        "line": 317,
        "fullcodeline": "free(patterns[n]);"
    },
    {
        "line": 23,
        "fullcodeline": "SCREWUP(\"Unexpected off_t/time_t size\");"
    },
    {
        "line": 28,
        "fullcodeline": "(void) umask(mask);"
    },
    {
        "line": 30,
        "fullcodeline": "run_err(\"ambiguous target\");"
    },
    {
        "line": 35,
        "fullcodeline": "verifydir(targ);"
    },
    {
        "line": 39,
        "fullcodeline": "targisdir = 1;"
    },
    {
        "line": 49,
        "fullcodeline": "cp = buf;"
    },
    {
        "line": 59,
        "fullcodeline": "*cp = 0;"
    },
    {
        "line": 82,
        "fullcodeline": "cp = buf;"
    },
    {
        "line": 127,
        "fullcodeline": "mode = 0;"
    },
    {
        "line": 140,
        "fullcodeline": "ull = strtoull(cp, &cp, 10);"
    },
    {
        "line": 145,
        "fullcodeline": "size = (off_t)ull;"
    },
    {
        "line": 176,
        "fullcodeline": "curfile = cp;"
    },
    {
        "line": 177,
        "fullcodeline": "exists = stat(np, &stb) == 0;"
    },
    {
        "line": 209,
        "fullcodeline": "omode = mode;"
    },
    {
        "line": 210,
        "fullcodeline": "mode |= S_IWUSR;"
    },
    {
        "line": 215,
        "fullcodeline": "(void) atomicio(vwrite, remout, \"\", 1);"
    },
    {
        "line": 220,
        "fullcodeline": "cp = bp->buf;"
    },
    {
        "line": 221,
        "fullcodeline": "wrerr = 0;"
    },
    {
        "line": 228,
        "fullcodeline": "statbytes = 0;"
    },
    {
        "line": 231,
        "fullcodeline": "set_nonblock(remin);"
    },
    {
        "line": 264,
        "fullcodeline": "unset_nonblock(remin);"
    },
    {
        "line": 296,
        "fullcodeline": "(void) response();"
    },
    {
        "line": 45,
        "fullcodeline": "if (brace_expand(src, &patterns, &npatterns) != 0)"
    },
    {
        "line": 50,
        "fullcodeline": "if (atomicio(read, remin, cp, 1) != 1)"
    },
    {
        "line": 52,
        "fullcodeline": "if (*cp++ == '\\n')"
    },
    {
        "line": 58,
        "fullcodeline": "} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');"
    },
    {
        "line": 63,
        "fullcodeline": "if (buf[0] == '\\01' || buf[0] == '\\02') {"
    },
    {
        "line": 75,
        "fullcodeline": "if (buf[0] == 'E') {"
    },
    {
        "line": 79,
        "fullcodeline": "if (ch == '\\n')"
    },
    {
        "line": 83,
        "fullcodeline": "if (*cp == 'T') {"
    },
    {
        "line": 113,
        "fullcodeline": "if (*cp != 'C' && *cp != 'D') {"
    },
    {
        "line": 128,
        "fullcodeline": "for (++cp; cp < buf + 5; cp++) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (!pflag)"
    },
    {
        "line": 135,
        "fullcodeline": "if (*cp++ != ' ')"
    },
    {
        "line": 138,
        "fullcodeline": "if (!isdigit((unsigned char)*cp))"
    },
    {
        "line": 141,
        "fullcodeline": "if (!cp || *cp++ != ' ')"
    },
    {
        "line": 143,
        "fullcodeline": "if (TYPE_OVERFLOW(off_t, ull))"
    },
    {
        "line": 147,
        "fullcodeline": "if (*cp == '\\0' || strchr(cp, '/') != NULL ||"
    },
    {
        "line": 152,
        "fullcodeline": "if (npatterns > 0) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (buf[0] == 'D') {"
    },
    {
        "line": 211,
        "fullcodeline": "if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) == -1) {"
    },
    {
        "line": 216,
        "fullcodeline": "if ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {"
    },
    {
        "line": 232,
        "fullcodeline": "for (count = i = 0; i < size; i += bp->cnt) {"
    },
    {
        "line": 265,
        "fullcodeline": "if (count != 0 && !wrerr &&"
    },
    {
        "line": 270,
        "fullcodeline": "if (!wrerr && (!exists || S_ISREG(stb.st_mode)) &&"
    },
    {
        "line": 294,
        "fullcodeline": "if (close(ofd) == -1)"
    },
    {
        "line": 299,
        "fullcodeline": "if (setimes && !wrerr) {"
    },
    {
        "line": 307,
        "fullcodeline": "if (note_err(NULL) == 0)"
    },
    {
        "line": 46,
        "fullcodeline": "fatal(\"%s: could not expand pattern\", __func__);"
    },
    {
        "line": 53,
        "fullcodeline": "SCREWUP(\"unexpected <newline>\");"
    },
    {
        "line": 57,
        "fullcodeline": "*cp++ = ch;"
    },
    {
        "line": 61,
        "fullcodeline": "fmprintf(stderr, \"Sink: %s\", buf);"
    },
    {
        "line": 72,
        "fullcodeline": "++errs;"
    },
    {
        "line": 76,
        "fullcodeline": "(void) atomicio(vwrite, remout, \"\", 1);"
    },
    {
        "line": 80,
        "fullcodeline": "*--cp = 0;"
    },
    {
        "line": 84,
        "fullcodeline": "setimes++;"
    },
    {
        "line": 85,
        "fullcodeline": "cp++;"
    },
    {
        "line": 88,
        "fullcodeline": "ull = strtoull(cp, &cp, 10);"
    },
    {
        "line": 93,
        "fullcodeline": "mtime.tv_sec = ull;"
    },
    {
        "line": 94,
        "fullcodeline": "mtime.tv_usec = strtol(cp, &cp, 10);"
    },
    {
        "line": 100,
        "fullcodeline": "ull = strtoull(cp, &cp, 10);"
    },
    {
        "line": 105,
        "fullcodeline": "atime.tv_sec = ull;"
    },
    {
        "line": 106,
        "fullcodeline": "atime.tv_usec = strtol(cp, &cp, 10);"
    },
    {
        "line": 110,
        "fullcodeline": "(void) atomicio(vwrite, remout, \"\", 1);"
    },
    {
        "line": 125,
        "fullcodeline": "SCREWUP(\"expected control record\");"
    },
    {
        "line": 131,
        "fullcodeline": "mode = (mode << 3) | (*cp - '0');"
    },
    {
        "line": 134,
        "fullcodeline": "mode &= ~mask;"
    },
    {
        "line": 136,
        "fullcodeline": "SCREWUP(\"mode not delimited\");"
    },
    {
        "line": 139,
        "fullcodeline": "SCREWUP(\"size not present\");"
    },
    {
        "line": 142,
        "fullcodeline": "SCREWUP(\"size not delimited\");"
    },
    {
        "line": 144,
        "fullcodeline": "SCREWUP(\"size out of range\");"
    },
    {
        "line": 148,
        "fullcodeline": "strcmp(cp, \".\") == 0 || strcmp(cp, \"..\") == 0) {"
    },
    {
        "line": 149,
        "fullcodeline": "run_err(\"error: unexpected filename: %s\", cp);"
    },
    {
        "line": 165,
        "fullcodeline": "need = strlen(targ) + strlen(cp) + 250;"
    },
    {
        "line": 171,
        "fullcodeline": "(void) snprintf(namebuf, need, \"%s%s%s\", targ,"
    },
    {
        "line": 173,
        "fullcodeline": "np = namebuf;"
    },
    {
        "line": 179,
        "fullcodeline": "int mod_flag = pflag;"
    },
    {
        "line": 196,
        "fullcodeline": "vect[0] = xstrdup(np);"
    },
    {
        "line": 197,
        "fullcodeline": "sink(1, vect, src);"
    },
    {
        "line": 206,
        "fullcodeline": "free(vect[0]);"
    },
    {
        "line": 212,
        "fullcodeline": "bad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));"
    },
    {
        "line": 217,
        "fullcodeline": "(void) close(ofd);"
    },
    {
        "line": 230,
        "fullcodeline": "start_progress_meter(curfile, size, &statbytes);"
    },
    {
        "line": 233,
        "fullcodeline": "amt = bp->cnt;"
    },
    {
        "line": 236,
        "fullcodeline": "count += amt;"
    },
    {
        "line": 266,
        "fullcodeline": "atomicio(vwrite, ofd, bp->buf, count) != count) {"
    },
    {
        "line": 267,
        "fullcodeline": "note_err(\"%s: %s\", np, strerror(errno));"
    },
    {
        "line": 268,
        "fullcodeline": "wrerr = 1;"
    },
    {
        "line": 271,
        "fullcodeline": "ftruncate(ofd, size) != 0)"
    },
    {
        "line": 272,
        "fullcodeline": "note_err(\"%s: truncate: %s\", np, strerror(errno));"
    },
    {
        "line": 295,
        "fullcodeline": "note_err(np, \"%s: close: %s\", np, strerror(errno));"
    },
    {
        "line": 298,
        "fullcodeline": "stop_progress_meter();"
    },
    {
        "line": 300,
        "fullcodeline": "setimes = 0;"
    },
    {
        "line": 308,
        "fullcodeline": "(void) atomicio(vwrite, remout, \"\", 1);"
    },
    {
        "line": 55,
        "fullcodeline": "if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))"
    },
    {
        "line": 64,
        "fullcodeline": "if (iamremote == 0) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (buf[0] == '\\02')"
    },
    {
        "line": 89,
        "fullcodeline": "if (!cp || *cp++ != ' ')"
    },
    {
        "line": 91,
        "fullcodeline": "if (TYPE_OVERFLOW(time_t, ull))"
    },
    {
        "line": 95,
        "fullcodeline": "if (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||"
    },
    {
        "line": 98,
        "fullcodeline": "if (!isdigit((unsigned char)*cp))"
    },
    {
        "line": 101,
        "fullcodeline": "if (!cp || *cp++ != ' ')"
    },
    {
        "line": 103,
        "fullcodeline": "if (TYPE_OVERFLOW(time_t, ull))"
    },
    {
        "line": 107,
        "fullcodeline": "if (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||"
    },
    {
        "line": 129,
        "fullcodeline": "if (*cp < '0' || *cp > '7')"
    },
    {
        "line": 153,
        "fullcodeline": "for (n = 0; n < npatterns; n++) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (n >= npatterns)"
    },
    {
        "line": 166,
        "fullcodeline": "if (need > cursize) {"
    },
    {
        "line": 175,
        "fullcodeline": "np = targ;"
    },
    {
        "line": 180,
        "fullcodeline": "if (!iamrecursive)"
    },
    {
        "line": 234,
        "fullcodeline": "if (i + amt > size)"
    },
    {
        "line": 248,
        "fullcodeline": "} while (amt > 0);"
    },
    {
        "line": 250,
        "fullcodeline": "if (count == bp->cnt) {"
    },
    {
        "line": 274,
        "fullcodeline": "if (exists || omode != mode)"
    },
    {
        "line": 301,
        "fullcodeline": "if (utimes(np, tv) == -1) {"
    },
    {
        "line": 56,
        "fullcodeline": "SCREWUP(\"lost connection\");"
    },
    {
        "line": 65,
        "fullcodeline": "(void) snmprintf(visbuf, sizeof(visbuf),"
    },
    {
        "line": 67,
        "fullcodeline": "(void) atomicio(vwrite, STDERR_FILENO,"
    },
    {
        "line": 86,
        "fullcodeline": "if (!isdigit((unsigned char)*cp))"
    },
    {
        "line": 87,
        "fullcodeline": "SCREWUP(\"mtime.sec not present\");"
    },
    {
        "line": 90,
        "fullcodeline": "SCREWUP(\"mtime.sec not delimited\");"
    },
    {
        "line": 92,
        "fullcodeline": "setimes = 0;\t/* out of range */"
    },
    {
        "line": 96,
        "fullcodeline": "mtime.tv_usec > 999999)"
    },
    {
        "line": 97,
        "fullcodeline": "SCREWUP(\"mtime.usec not delimited\");"
    },
    {
        "line": 99,
        "fullcodeline": "SCREWUP(\"atime.sec not present\");"
    },
    {
        "line": 102,
        "fullcodeline": "SCREWUP(\"atime.sec not delimited\");"
    },
    {
        "line": 104,
        "fullcodeline": "setimes = 0;\t/* out of range */"
    },
    {
        "line": 108,
        "fullcodeline": "atime.tv_usec > 999999)"
    },
    {
        "line": 109,
        "fullcodeline": "SCREWUP(\"atime.usec not delimited\");"
    },
    {
        "line": 122,
        "fullcodeline": "run_err(\"%s\", cp);"
    },
    {
        "line": 130,
        "fullcodeline": "SCREWUP(\"bad mode\");"
    },
    {
        "line": 158,
        "fullcodeline": "SCREWUP(\"filename does not match request\");"
    },
    {
        "line": 168,
        "fullcodeline": "namebuf = xmalloc(need);"
    },
    {
        "line": 169,
        "fullcodeline": "cursize = need;"
    },
    {
        "line": 172,
        "fullcodeline": "strcmp(targ, \"/\") ? \"/\" : \"\", cp);"
    },
    {
        "line": 181,
        "fullcodeline": "SCREWUP(\"received directory without -r\");"
    },
    {
        "line": 199,
        "fullcodeline": "setimes = 0;"
    },
    {
        "line": 205,
        "fullcodeline": "(void) chmod(vect[0], mode);"
    },
    {
        "line": 235,
        "fullcodeline": "amt = size - i;"
    },
    {
        "line": 238,
        "fullcodeline": "j = atomicio6(read, remin, cp, amt,"
    },
    {
        "line": 246,
        "fullcodeline": "amt -= j;"
    },
    {
        "line": 247,
        "fullcodeline": "cp += j;"
    },
    {
        "line": 260,
        "fullcodeline": "count = 0;"
    },
    {
        "line": 261,
        "fullcodeline": "cp = bp->buf;"
    },
    {
        "line": 284,
        "fullcodeline": "if (!exists && omode != mode)"
    },
    {
        "line": 302,
        "fullcodeline": "note_err(\"%s: set times: %s\","
    },
    {
        "line": 154,
        "fullcodeline": "if (fnmatch(patterns[n], cp, 0) == 0)"
    },
    {
        "line": 183,
        "fullcodeline": "if (!S_ISDIR(stb.st_mode)) {"
    },
    {
        "line": 192,
        "fullcodeline": "mod_flag = 1;"
    },
    {
        "line": 200,
        "fullcodeline": "if (utimes(vect[0], tv) == -1)"
    },
    {
        "line": 240,
        "fullcodeline": "if (j == 0) {"
    },
    {
        "line": 252,
        "fullcodeline": "if (!wrerr) {"
    },
    {
        "line": 278,
        "fullcodeline": "if (chmod(np, omode)) {"
    },
    {
        "line": 303,
        "fullcodeline": "np, strerror(errno));"
    },
    {
        "line": 66,
        "fullcodeline": "NULL, \"%s\", buf + 1);"
    },
    {
        "line": 68,
        "fullcodeline": "visbuf, strlen(visbuf));"
    },
    {
        "line": 184,
        "fullcodeline": "errno = ENOTDIR;"
    },
    {
        "line": 188,
        "fullcodeline": "(void) chmod(np, mode);"
    },
    {
        "line": 193,
        "fullcodeline": "if (mkdir(np, mode | S_IRWXU) == -1)"
    },
    {
        "line": 201,
        "fullcodeline": "run_err(\"%s: set times: %s\","
    },
    {
        "line": 241,
        "fullcodeline": "run_err(\"%s\", j != EPIPE ?"
    },
    {
        "line": 280,
        "fullcodeline": "note_err(\"%s: set mode: %s\","
    },
    {
        "line": 288,
        "fullcodeline": "if (chmod(np, omode & ~mask)) {"
    },
    {
        "line": 202,
        "fullcodeline": "vect[0], strerror(errno));"
    },
    {
        "line": 253,
        "fullcodeline": "if (atomicio(vwrite, ofd, bp->buf,"
    },
    {
        "line": 281,
        "fullcodeline": "np, strerror(errno));"
    },
    {
        "line": 290,
        "fullcodeline": "note_err(\"%s: set mode: %s\","
    },
    {
        "line": 242,
        "fullcodeline": "strerror(errno) :"
    },
    {
        "line": 255,
        "fullcodeline": "note_err(\"%s: %s\", np,"
    },
    {
        "line": 257,
        "fullcodeline": "wrerr = 1;"
    },
    {
        "line": 291,
        "fullcodeline": "np, strerror(errno));"
    },
    {
        "line": 256,
        "fullcodeline": "strerror(errno));"
    }
]