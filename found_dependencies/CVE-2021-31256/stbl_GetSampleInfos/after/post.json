[
    {
        "line": 9,
        "fullcodeline": "(*offset) = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "(*chunkNumber) = (*descIndex) = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "(*descIndex) = ent->sampleDescriptionIndex;"
    },
    {
        "line": 103,
        "fullcodeline": "(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;"
    },
    {
        "line": 109,
        "fullcodeline": "offsetInChunk = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "if (!stbl || !sampleNumber) return GF_BAD_PARAM;"
    },
    {
        "line": 13,
        "fullcodeline": "if (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 15,
        "fullcodeline": "if (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (stbl->SampleToChunk->firstSampleInCurrentChunk &&"
    },
    {
        "line": 59,
        "fullcodeline": "for (; i < stbl->SampleToChunk->nb_entries; i++) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (! *chunkNumber)"
    },
    {
        "line": 111,
        "fullcodeline": "if (stbl->SampleSize && stbl->SampleSize->sampleSize) {"
    },
    {
        "line": 135,
        "fullcodeline": "if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (out_ent) (*out_ent) = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "(*descIndex) = ent->sampleDescriptionIndex;"
    },
    {
        "line": 19,
        "fullcodeline": "(*chunkNumber) = sampleNumber;"
    },
    {
        "line": 39,
        "fullcodeline": "(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {"
    },
    {
        "line": 43,
        "fullcodeline": "GetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);"
    },
    {
        "line": 60,
        "fullcodeline": "assert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);"
    },
    {
        "line": 68,
        "fullcodeline": "u32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;"
    },
    {
        "line": 69,
        "fullcodeline": "u32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;"
    },
    {
        "line": 82,
        "fullcodeline": "max_chunks_in_entry += 1;"
    },
    {
        "line": 83,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;"
    },
    {
        "line": 84,
        "fullcodeline": "stbl->SampleToChunk->currentChunk += max_chunks_in_entry;"
    },
    {
        "line": 104,
        "fullcodeline": "if (out_ent) *out_ent = ent;"
    },
    {
        "line": 112,
        "fullcodeline": "u32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;"
    },
    {
        "line": 113,
        "fullcodeline": "offsetInChunk += diff * stbl->SampleSize->sampleSize;"
    },
    {
        "line": 136,
        "fullcodeline": "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 138,
        "fullcodeline": "(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;"
    },
    {
        "line": 17,
        "fullcodeline": "if (!ent) return GF_BAD_PARAM;"
    },
    {
        "line": 21,
        "fullcodeline": "if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {"
    },
    {
        "line": 48,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "stbl->SampleToChunk->currentIndex = 0;"
    },
    {
        "line": 50,
        "fullcodeline": "stbl->SampleToChunk->currentChunk = 1;"
    },
    {
        "line": 51,
        "fullcodeline": "stbl->SampleToChunk->ghostNumber = 1;"
    },
    {
        "line": 52,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk = 1;"
    },
    {
        "line": 54,
        "fullcodeline": "GetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);"
    },
    {
        "line": 55,
        "fullcodeline": "k = stbl->SampleToChunk->currentChunk;"
    },
    {
        "line": 62,
        "fullcodeline": "if (k > stbl->SampleToChunk->ghostNumber) {"
    },
    {
        "line": 74,
        "fullcodeline": "(nb_chunks_for_sample <= max_chunks_in_entry)"
    },
    {
        "line": 87,
        "fullcodeline": "if (i+1 != stbl->SampleToChunk->nb_entries) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 140,
        "fullcodeline": "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 142,
        "fullcodeline": "(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;"
    },
    {
        "line": 20,
        "fullcodeline": "if (out_ent) *out_ent = ent;"
    },
    {
        "line": 22,
        "fullcodeline": "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 71,
        "fullcodeline": "nb_chunks_for_sample /= ent->samplesPerChunk;"
    },
    {
        "line": 75,
        "fullcodeline": "&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)"
    },
    {
        "line": 78,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;"
    },
    {
        "line": 79,
        "fullcodeline": "stbl->SampleToChunk->currentChunk += nb_chunks_for_sample;"
    },
    {
        "line": 90,
        "fullcodeline": "GetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);"
    },
    {
        "line": 92,
        "fullcodeline": "stbl->SampleToChunk->currentIndex = i+1;"
    },
    {
        "line": 93,
        "fullcodeline": "stbl->SampleToChunk->currentChunk = 1;"
    },
    {
        "line": 94,
        "fullcodeline": "k = 1;"
    },
    {
        "line": 114,
        "fullcodeline": "} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 16,
        "fullcodeline": "ent = &stbl->SampleToChunk->entries[sampleNumber-1];"
    },
    {
        "line": 23,
        "fullcodeline": "if (!stco->offsets) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 24,
        "fullcodeline": "if (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 28,
        "fullcodeline": "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 115,
        "fullcodeline": "offsetInChunk = stbl->r_last_offset_in_chunk;"
    },
    {
        "line": 29,
        "fullcodeline": "if (!co64->offsets) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 30,
        "fullcodeline": "if (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 26,
        "fullcodeline": "(*offset) = (u64) stco->offsets[sampleNumber - 1];"
    },
    {
        "line": 32,
        "fullcodeline": "(*offset) = co64->offsets[sampleNumber - 1];"
    },
    {
        "line": 88,
        "fullcodeline": "ent = &stbl->SampleToChunk->entries[i+1];"
    },
    {
        "line": 116,
        "fullcodeline": "} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {"
    },
    {
        "line": 117,
        "fullcodeline": "e = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);"
    },
    {
        "line": 119,
        "fullcodeline": "stbl->r_last_offset_in_chunk += size;"
    },
    {
        "line": 120,
        "fullcodeline": "stbl->r_last_sample_num = sampleNumber;"
    },
    {
        "line": 121,
        "fullcodeline": "offsetInChunk = stbl->r_last_offset_in_chunk;"
    },
    {
        "line": 129,
        "fullcodeline": "stbl->r_last_chunk_num = chunk_num;"
    },
    {
        "line": 130,
        "fullcodeline": "stbl->r_last_sample_num = sampleNumber;"
    },
    {
        "line": 131,
        "fullcodeline": "stbl->r_last_offset_in_chunk = offsetInChunk;"
    },
    {
        "line": 124,
        "fullcodeline": "for (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {"
    },
    {
        "line": 125,
        "fullcodeline": "e = stbl_GetSampleSize(stbl->SampleSize, i, &size);"
    },
    {
        "line": 127,
        "fullcodeline": "offsetInChunk += size;"
    }
]