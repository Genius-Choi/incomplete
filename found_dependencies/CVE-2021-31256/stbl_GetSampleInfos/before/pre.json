[
    {
        "line": 9,
        "fullcodeline": "(*offset) = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "(*chunkNumber) = (*descIndex) = 0;"
    },
    {
        "line": 101,
        "fullcodeline": "(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;"
    },
    {
        "line": 107,
        "fullcodeline": "offsetInChunk = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "if (!stbl || !sampleNumber) return GF_BAD_PARAM;"
    },
    {
        "line": 15,
        "fullcodeline": "if (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (stbl->SampleToChunk->firstSampleInCurrentChunk &&"
    },
    {
        "line": 57,
        "fullcodeline": "for (; i < stbl->SampleToChunk->nb_entries; i++) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (! *chunkNumber)"
    },
    {
        "line": 109,
        "fullcodeline": "if (stbl->SampleSize && stbl->SampleSize->sampleSize) {"
    },
    {
        "line": 133,
        "fullcodeline": "if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (out_ent) (*out_ent) = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "if (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 16,
        "fullcodeline": "ent = &stbl->SampleToChunk->entries[sampleNumber-1];"
    },
    {
        "line": 37,
        "fullcodeline": "(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {"
    },
    {
        "line": 39,
        "fullcodeline": "i = stbl->SampleToChunk->currentIndex;"
    },
    {
        "line": 40,
        "fullcodeline": "ent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];"
    },
    {
        "line": 41,
        "fullcodeline": "GetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);"
    },
    {
        "line": 42,
        "fullcodeline": "k = stbl->SampleToChunk->currentChunk;"
    },
    {
        "line": 66,
        "fullcodeline": "u32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;"
    },
    {
        "line": 67,
        "fullcodeline": "u32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;"
    },
    {
        "line": 80,
        "fullcodeline": "max_chunks_in_entry += 1;"
    },
    {
        "line": 81,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;"
    },
    {
        "line": 82,
        "fullcodeline": "stbl->SampleToChunk->currentChunk += max_chunks_in_entry;"
    },
    {
        "line": 110,
        "fullcodeline": "u32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;"
    },
    {
        "line": 111,
        "fullcodeline": "offsetInChunk += diff * stbl->SampleSize->sampleSize;"
    },
    {
        "line": 134,
        "fullcodeline": "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 17,
        "fullcodeline": "if (!ent) return GF_BAD_PARAM;"
    },
    {
        "line": 21,
        "fullcodeline": "if ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {"
    },
    {
        "line": 46,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "stbl->SampleToChunk->currentChunk = 1;"
    },
    {
        "line": 49,
        "fullcodeline": "stbl->SampleToChunk->ghostNumber = 1;"
    },
    {
        "line": 50,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk = 1;"
    },
    {
        "line": 51,
        "fullcodeline": "ent = &stbl->SampleToChunk->entries[0];"
    },
    {
        "line": 52,
        "fullcodeline": "GetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);"
    },
    {
        "line": 53,
        "fullcodeline": "k = stbl->SampleToChunk->currentChunk;"
    },
    {
        "line": 58,
        "fullcodeline": "assert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);"
    },
    {
        "line": 60,
        "fullcodeline": "if (k > stbl->SampleToChunk->ghostNumber) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (i+1 != stbl->SampleToChunk->nb_entries) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 138,
        "fullcodeline": "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 22,
        "fullcodeline": "stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 69,
        "fullcodeline": "nb_chunks_for_sample /= ent->samplesPerChunk;"
    },
    {
        "line": 72,
        "fullcodeline": "(nb_chunks_for_sample <= max_chunks_in_entry)"
    },
    {
        "line": 73,
        "fullcodeline": "&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)"
    },
    {
        "line": 76,
        "fullcodeline": "stbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;"
    },
    {
        "line": 77,
        "fullcodeline": "stbl->SampleToChunk->currentChunk += nb_chunks_for_sample;"
    },
    {
        "line": 86,
        "fullcodeline": "ent = &stbl->SampleToChunk->entries[i+1];"
    },
    {
        "line": 88,
        "fullcodeline": "GetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);"
    },
    {
        "line": 91,
        "fullcodeline": "stbl->SampleToChunk->currentChunk = 1;"
    },
    {
        "line": 92,
        "fullcodeline": "k = 1;"
    },
    {
        "line": 139,
        "fullcodeline": "if (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;"
    },
    {
        "line": 27,
        "fullcodeline": "co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;"
    },
    {
        "line": 112,
        "fullcodeline": "} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {"
    },
    {
        "line": 113,
        "fullcodeline": "offsetInChunk = stbl->r_last_offset_in_chunk;"
    },
    {
        "line": 114,
        "fullcodeline": "} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {"
    },
    {
        "line": 115,
        "fullcodeline": "e = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);"
    },
    {
        "line": 117,
        "fullcodeline": "stbl->r_last_offset_in_chunk += size;"
    },
    {
        "line": 119,
        "fullcodeline": "offsetInChunk = stbl->r_last_offset_in_chunk;"
    },
    {
        "line": 122,
        "fullcodeline": "for (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {"
    },
    {
        "line": 123,
        "fullcodeline": "e = stbl_GetSampleSize(stbl->SampleSize, i, &size);"
    },
    {
        "line": 125,
        "fullcodeline": "offsetInChunk += size;"
    }
]