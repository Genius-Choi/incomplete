[
    {
        "line": 2,
        "fullcodeline": "assert(c != NULL);"
    },
    {
        "line": 3,
        "fullcodeline": "LIBEVENT_THREAD *thr = c->thread;"
    },
    {
        "line": 4,
        "fullcodeline": "struct proxy_hook *hooks = thr->proxy_hooks;"
    },
    {
        "line": 5,
        "fullcodeline": "lua_State *L = thr->L;"
    },
    {
        "line": 6,
        "fullcodeline": "proxy_ctx_t *ctx = thr->proxy_ctx;"
    },
    {
        "line": 7,
        "fullcodeline": "mcp_parser_t pr = {0};"
    },
    {
        "line": 14,
        "fullcodeline": "int ret = process_request(&pr, command, cmdlen);"
    },
    {
        "line": 29,
        "fullcodeline": "struct proxy_hook *hook = &hooks[pr.command];"
    },
    {
        "line": 30,
        "fullcodeline": "int hook_ref = hook->lua_ref;"
    },
    {
        "line": 149,
        "fullcodeline": "WSTAT_L(c->thread);"
    },
    {
        "line": 152,
        "fullcodeline": "c->thread->stats.proxy_req_active++;"
    },
    {
        "line": 153,
        "fullcodeline": "active_reqs = c->thread->stats.proxy_req_active;"
    },
    {
        "line": 154,
        "fullcodeline": "WSTAT_UL(c->thread);"
    },
    {
        "line": 168,
        "fullcodeline": "lua_newthread(L);"
    },
    {
        "line": 169,
        "fullcodeline": "lua_State *Lc = lua_tothread(L, -1);"
    },
    {
        "line": 172,
        "fullcodeline": "lua_rawgeti(Lc, LUA_REGISTRYINDEX, hook_ref);"
    },
    {
        "line": 15,
        "fullcodeline": "if (ret != 0) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (c->tag && hook->tagged) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (!hook_ref) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (!multiget && pr.cmd_type == CMD_TYPE_GET && pr.has_space) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (cmdlen >= MCP_REQUEST_MAXLEN) {"
    },
    {
        "line": 174,
        "fullcodeline": "mcp_request_t *rq = mcp_new_request(Lc, &pr, command, cmdlen);"
    },
    {
        "line": 180,
        "fullcodeline": "if (rq->pr.vlen != 0) {"
    },
    {
        "line": 16,
        "fullcodeline": "WSTAT_INCR(c->thread, proxy_conn_errors, 1);"
    },
    {
        "line": 21,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"parsing request\");"
    },
    {
        "line": 35,
        "fullcodeline": "struct proxy_hook_tagged *pht = hook->tagged;"
    },
    {
        "line": 59,
        "fullcodeline": "c->proxy_coro_ref = 0;"
    },
    {
        "line": 71,
        "fullcodeline": "uint32_t keyoff = pr.tokens[pr.keytoken];"
    },
    {
        "line": 120,
        "fullcodeline": "memcpy(c->resp->wbuf, ENDSTR, ENDLEN);"
    },
    {
        "line": 129,
        "fullcodeline": "WSTAT_INCR(c->thread, proxy_conn_errors, 1);"
    },
    {
        "line": 134,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"request too long\");"
    },
    {
        "line": 139,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 157,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, \"active request limit reached\");"
    },
    {
        "line": 158,
        "fullcodeline": "WSTAT_DECR(c->thread, proxy_req_active, 1);"
    },
    {
        "line": 181,
        "fullcodeline": "c->item = NULL;"
    },
    {
        "line": 184,
        "fullcodeline": "bool oom = proxy_bufmem_checkadd(c->thread, 0);"
    },
    {
        "line": 198,
        "fullcodeline": "c->item_malloced = true;"
    },
    {
        "line": 199,
        "fullcodeline": "c->ritem = c->item;"
    },
    {
        "line": 200,
        "fullcodeline": "c->rlbytes = rq->pr.vlen;"
    },
    {
        "line": 201,
        "fullcodeline": "c->proxy_coro_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pops coroutine."
    },
    {
        "line": 203,
        "fullcodeline": "conn_set_state(c, conn_nread);"
    },
    {
        "line": 17,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 72,
        "fullcodeline": "while (pr.klen != 0) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (pr.vlen != 0) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (c->item == NULL) {"
    },
    {
        "line": 206,
        "fullcodeline": "conn_set_state(c, conn_new_cmd);"
    },
    {
        "line": 18,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 22,
        "fullcodeline": "if (ret == -2) {"
    },
    {
        "line": 41,
        "fullcodeline": "pht++;"
    },
    {
        "line": 53,
        "fullcodeline": "if (cmdlen > 1 && command[cmdlen-2] == '\\r') {"
    },
    {
        "line": 54,
        "fullcodeline": "command[cmdlen-2] = '\\0';"
    },
    {
        "line": 73,
        "fullcodeline": "char temp[KEY_MAX_LENGTH + MAX_CMD_PREFIX + 30];"
    },
    {
        "line": 74,
        "fullcodeline": "char *cur = temp;"
    },
    {
        "line": 108,
        "fullcodeline": "keyoff = _process_request_next_key(&pr);"
    },
    {
        "line": 111,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 130,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 160,
        "fullcodeline": "c->sbytes = pr.vlen;"
    },
    {
        "line": 188,
        "fullcodeline": "c->item = malloc(rq->pr.vlen);"
    },
    {
        "line": 192,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, \"out of memory\");"
    },
    {
        "line": 193,
        "fullcodeline": "WSTAT_DECR(c->thread, proxy_req_active, 1);"
    },
    {
        "line": 194,
        "fullcodeline": "c->sbytes = rq->pr.vlen;"
    },
    {
        "line": 37,
        "fullcodeline": "if (c->tag == pht->tag) {"
    },
    {
        "line": 56,
        "fullcodeline": "command[cmdlen-1] = '\\0';"
    },
    {
        "line": 78,
        "fullcodeline": "if (pr.tokens[pr.keytoken] > MAX_CMD_PREFIX) {"
    },
    {
        "line": 38,
        "fullcodeline": "hook_ref = pht->lua_ref;"
    },
    {
        "line": 83,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"malformed request\");"
    },
    {
        "line": 79,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 84,
        "fullcodeline": "} else if (pr.klen > KEY_MAX_LENGTH) {"
    },
    {
        "line": 89,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"key too long\");"
    },
    {
        "line": 92,
        "fullcodeline": "memcpy(cur, pr.request, pr.tokens[pr.keytoken]);"
    },
    {
        "line": 93,
        "fullcodeline": "cur += pr.tokens[pr.keytoken];"
    },
    {
        "line": 96,
        "fullcodeline": "memcpy(cur, &pr.request[keyoff], pr.klen);"
    },
    {
        "line": 97,
        "fullcodeline": "cur += pr.klen;"
    },
    {
        "line": 99,
        "fullcodeline": "memcpy(cur, \"\\r\\n\", 2);"
    },
    {
        "line": 100,
        "fullcodeline": "cur += 2;"
    },
    {
        "line": 102,
        "fullcodeline": "*cur = '\\0';"
    },
    {
        "line": 103,
        "fullcodeline": "P_DEBUG(\"%s: new multiget sub request: %s [%u/%u]\\n\", __func__, temp, keyoff, pr.klen);"
    },
    {
        "line": 104,
        "fullcodeline": "proxy_process_command(c, temp, cur - temp, PROCESS_MULTIGET);"
    },
    {
        "line": 85,
        "fullcodeline": "if (!resp_start(c)) {"
    }
]