[
    {
        "line": 2,
        "fullcodeline": "assert(c != NULL);"
    },
    {
        "line": 3,
        "fullcodeline": "LIBEVENT_THREAD *thr = c->thread;"
    },
    {
        "line": 4,
        "fullcodeline": "struct proxy_hook *hooks = thr->proxy_hooks;"
    },
    {
        "line": 5,
        "fullcodeline": "lua_State *L = thr->L;"
    },
    {
        "line": 6,
        "fullcodeline": "proxy_ctx_t *ctx = thr->proxy_ctx;"
    },
    {
        "line": 7,
        "fullcodeline": "mcp_parser_t pr = {0};"
    },
    {
        "line": 14,
        "fullcodeline": "int ret = process_request(&pr, command, cmdlen);"
    },
    {
        "line": 29,
        "fullcodeline": "struct proxy_hook *hook = &hooks[pr.command];"
    },
    {
        "line": 30,
        "fullcodeline": "int hook_ref = hook->lua_ref;"
    },
    {
        "line": 142,
        "fullcodeline": "uint64_t active_reqs = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "WSTAT_L(c->thread);"
    },
    {
        "line": 147,
        "fullcodeline": "active_reqs = c->thread->stats.proxy_req_active;"
    },
    {
        "line": 148,
        "fullcodeline": "WSTAT_UL(c->thread);"
    },
    {
        "line": 162,
        "fullcodeline": "lua_newthread(L);"
    },
    {
        "line": 163,
        "fullcodeline": "lua_State *Lc = lua_tothread(L, -1);"
    },
    {
        "line": 166,
        "fullcodeline": "lua_rawgeti(Lc, LUA_REGISTRYINDEX, hook_ref);"
    },
    {
        "line": 168,
        "fullcodeline": "mcp_request_t *rq = mcp_new_request(Lc, &pr, command, cmdlen);"
    },
    {
        "line": 169,
        "fullcodeline": "rq->ascii_multiget = multiget;"
    },
    {
        "line": 203,
        "fullcodeline": "proxy_run_coroutine(Lc, c->resp, NULL, c);"
    },
    {
        "line": 205,
        "fullcodeline": "lua_settop(L, 0); // clear anything remaining on the main thread."
    },
    {
        "line": 15,
        "fullcodeline": "if (ret != 0) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (c->tag && hook->tagged) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (!hook_ref) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (!multiget && pr.cmd_type == CMD_TYPE_GET && pr.has_space) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (cmdlen >= MCP_REQUEST_MAXLEN) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (active_reqs > ctx->active_req_limit) {"
    },
    {
        "line": 174,
        "fullcodeline": "if (rq->pr.vlen != 0) {"
    },
    {
        "line": 16,
        "fullcodeline": "WSTAT_INCR(c->thread, proxy_conn_errors, 1);"
    },
    {
        "line": 21,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"parsing request\");"
    },
    {
        "line": 35,
        "fullcodeline": "struct proxy_hook_tagged *pht = hook->tagged;"
    },
    {
        "line": 59,
        "fullcodeline": "c->proxy_coro_ref = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "process_command_ascii(c, command);"
    },
    {
        "line": 114,
        "fullcodeline": "memcpy(c->resp->wbuf, ENDSTR, ENDLEN);"
    },
    {
        "line": 115,
        "fullcodeline": "resp_add_iov(c->resp, c->resp->wbuf, ENDLEN);"
    },
    {
        "line": 123,
        "fullcodeline": "WSTAT_INCR(c->thread, proxy_conn_errors, 1);"
    },
    {
        "line": 128,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"request too long\");"
    },
    {
        "line": 129,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 134,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 151,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, \"active request limit reached\");"
    },
    {
        "line": 152,
        "fullcodeline": "WSTAT_DECR(c->thread, proxy_req_active, 1);"
    },
    {
        "line": 175,
        "fullcodeline": "c->item = NULL;"
    },
    {
        "line": 178,
        "fullcodeline": "bool oom = proxy_bufmem_checkadd(c->thread, 0);"
    },
    {
        "line": 192,
        "fullcodeline": "c->item_malloced = true;"
    },
    {
        "line": 193,
        "fullcodeline": "c->ritem = c->item;"
    },
    {
        "line": 194,
        "fullcodeline": "c->rlbytes = rq->pr.vlen;"
    },
    {
        "line": 195,
        "fullcodeline": "c->proxy_coro_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pops coroutine."
    },
    {
        "line": 197,
        "fullcodeline": "conn_set_state(c, conn_nread);"
    },
    {
        "line": 17,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (ret == -2) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (cmdlen > 1 && command[cmdlen-2] == '\\r') {"
    },
    {
        "line": 72,
        "fullcodeline": "while (pr.klen != 0) {"
    },
    {
        "line": 105,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 153,
        "fullcodeline": "if (pr.vlen != 0) {"
    },
    {
        "line": 181,
        "fullcodeline": "if (!oom) {"
    },
    {
        "line": 184,
        "fullcodeline": "if (c->item == NULL) {"
    },
    {
        "line": 200,
        "fullcodeline": "conn_set_state(c, conn_new_cmd);"
    },
    {
        "line": 18,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 24,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 41,
        "fullcodeline": "pht++;"
    },
    {
        "line": 54,
        "fullcodeline": "command[cmdlen-2] = '\\0';"
    },
    {
        "line": 73,
        "fullcodeline": "char temp[KEY_MAX_LENGTH + 30];"
    },
    {
        "line": 74,
        "fullcodeline": "char *cur = temp;"
    },
    {
        "line": 102,
        "fullcodeline": "keyoff = _process_request_next_key(&pr);"
    },
    {
        "line": 106,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 125,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 154,
        "fullcodeline": "c->sbytes = pr.vlen;"
    },
    {
        "line": 155,
        "fullcodeline": "conn_set_state(c, conn_swallow);"
    },
    {
        "line": 182,
        "fullcodeline": "c->item = malloc(rq->pr.vlen);"
    },
    {
        "line": 185,
        "fullcodeline": "lua_settop(L, 0);"
    },
    {
        "line": 186,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_SERVER_ERROR, \"out of memory\");"
    },
    {
        "line": 187,
        "fullcodeline": "WSTAT_DECR(c->thread, proxy_req_active, 1);"
    },
    {
        "line": 188,
        "fullcodeline": "c->sbytes = rq->pr.vlen;"
    },
    {
        "line": 189,
        "fullcodeline": "conn_set_state(c, conn_swallow);"
    },
    {
        "line": 37,
        "fullcodeline": "if (c->tag == pht->tag) {"
    },
    {
        "line": 56,
        "fullcodeline": "command[cmdlen-1] = '\\0';"
    },
    {
        "line": 78,
        "fullcodeline": "if (pr.klen > KEY_MAX_LENGTH) {"
    },
    {
        "line": 38,
        "fullcodeline": "hook_ref = pht->lua_ref;"
    },
    {
        "line": 83,
        "fullcodeline": "proxy_out_errstring(c->resp, PROXY_CLIENT_ERROR, \"key too long\");"
    },
    {
        "line": 79,
        "fullcodeline": "if (!resp_start(c)) {"
    },
    {
        "line": 86,
        "fullcodeline": "memcpy(cur, pr.request, pr.tokens[pr.keytoken]);"
    },
    {
        "line": 87,
        "fullcodeline": "cur += pr.tokens[pr.keytoken];"
    },
    {
        "line": 90,
        "fullcodeline": "memcpy(cur, &pr.request[keyoff], pr.klen);"
    },
    {
        "line": 91,
        "fullcodeline": "cur += pr.klen;"
    },
    {
        "line": 93,
        "fullcodeline": "memcpy(cur, \"\\r\\n\", 2);"
    },
    {
        "line": 94,
        "fullcodeline": "cur += 2;"
    },
    {
        "line": 96,
        "fullcodeline": "*cur = '\\0';"
    },
    {
        "line": 97,
        "fullcodeline": "P_DEBUG(\"%s: new multiget sub request: %s [%u/%u]\\n\", __func__, temp, keyoff, pr.klen);"
    },
    {
        "line": 98,
        "fullcodeline": "proxy_process_command(c, temp, cur - temp, PROCESS_MULTIGET);"
    },
    {
        "line": 80,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    }
]