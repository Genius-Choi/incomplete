[
    {
        "line": 4,
        "fullcodeline": "RandAddSeedPerfmon();"
    },
    {
        "line": 7,
        "fullcodeline": "if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)"
    },
    {
        "line": 17,
        "fullcodeline": "if (strCommand == \"version\")"
    },
    {
        "line": 6,
        "fullcodeline": "printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());"
    },
    {
        "line": 9,
        "fullcodeline": "printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");"
    },
    {
        "line": 27,
        "fullcodeline": "uint64 nNonce = 1;"
    },
    {
        "line": 28,
        "fullcodeline": "vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;"
    },
    {
        "line": 65,
        "fullcodeline": "pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);"
    },
    {
        "line": 67,
        "fullcodeline": "AddTimeData(pfrom->addr, nTime);"
    },
    {
        "line": 70,
        "fullcodeline": "pfrom->PushMessage(\"verack\");"
    },
    {
        "line": 71,
        "fullcodeline": "pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));"
    },
    {
        "line": 107,
        "fullcodeline": "long nRefHeight = 745000, nRefTime = 1438677830; // block #745000"
    },
    {
        "line": 108,
        "fullcodeline": "long nOurTime = GetAdjustedTime();"
    },
    {
        "line": 109,
        "fullcodeline": "long nHeightOffset = (nOurTime - nRefTime) / nTargetSpacingFour;"
    },
    {
        "line": 119,
        "fullcodeline": "static int nAskedForBlocks = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "pfrom->fSuccessfullyConnected = true;"
    },
    {
        "line": 145,
        "fullcodeline": "printf(\"received version message from %s, version %d, blocks=%d, us=%s, them=%s\\n\","
    },
    {
        "line": 148,
        "fullcodeline": "cPeerBlockCounts.input(pfrom->nStartingHeight);"
    },
    {
        "line": 44,
        "fullcodeline": "if (pfrom->fInbound && addrMe.IsRoutable())"
    },
    {
        "line": 73,
        "fullcodeline": "if (!pfrom->fInbound)"
    },
    {
        "line": 111,
        "fullcodeline": "if(pfrom->nStartingHeight > (nRefHeight + nHeightOffset + 10000)) {"
    },
    {
        "line": 146,
        "fullcodeline": "pfrom->addr.ToString().c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str());"
    },
    {
        "line": 31,
        "fullcodeline": "if((pfrom->nVersion > MAX_PROTOCOL_VERSION) || (pfrom->nVersion < MIN_PROTOCOL_VERSION)) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (!vRecv.empty())"
    },
    {
        "line": 38,
        "fullcodeline": "vRecv >> addrFrom >> nNonce;"
    },
    {
        "line": 39,
        "fullcodeline": "if (!vRecv.empty())"
    },
    {
        "line": 40,
        "fullcodeline": "vRecv >> pfrom->strSubVer;"
    },
    {
        "line": 41,
        "fullcodeline": "if (!vRecv.empty())"
    },
    {
        "line": 42,
        "fullcodeline": "vRecv >> pfrom->nStartingHeight;"
    },
    {
        "line": 46,
        "fullcodeline": "pfrom->addrLocal = addrMe;"
    },
    {
        "line": 47,
        "fullcodeline": "SeenLocal(addrMe);"
    },
    {
        "line": 51,
        "fullcodeline": "if (nNonce == nLocalHostNonce && nNonce > 1)"
    },
    {
        "line": 59,
        "fullcodeline": "if(addrFrom.IsRoutable() && addrMe.IsRoutable()) addrExternal = addrMe;"
    },
    {
        "line": 63,
        "fullcodeline": "pfrom->PushVersion();"
    },
    {
        "line": 120,
        "fullcodeline": "if (!pfrom->fClient && !pfrom->fOneShot &&"
    },
    {
        "line": 123,
        "fullcodeline": "(nAskedForBlocks < 1 || vNodes.size() <= 1))"
    },
    {
        "line": 126,
        "fullcodeline": "pfrom->PushGetBlocks(pindexBest, uint256(0));"
    },
    {
        "line": 152,
        "fullcodeline": "AskForPendingSyncCheckpoint(pfrom);"
    },
    {
        "line": 156,
        "fullcodeline": "else if (pfrom->nVersion == 0)"
    },
    {
        "line": 675,
        "fullcodeline": "if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")"
    },
    {
        "line": 32,
        "fullcodeline": "printf(\"peer %s reports incompatible version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);"
    },
    {
        "line": 53,
        "fullcodeline": "printf(\"connected to self at %s; disconnecting\\n\", pfrom->addr.ToString().c_str());"
    },
    {
        "line": 89,
        "fullcodeline": "if(pfrom->fOneShot || (nAddrSize < 1000)) {"
    },
    {
        "line": 113,
        "fullcodeline": "pfrom->addr.ToString().c_str(), pfrom->nStartingHeight, nRefHeight + nHeightOffset);"
    },
    {
        "line": 121,
        "fullcodeline": "(pfrom->nVersion < NOBLKS_VERSION_START ||"
    },
    {
        "line": 139,
        "fullcodeline": "if (!checkpointMessage.IsNull())"
    },
    {
        "line": 140,
        "fullcodeline": "checkpointMessage.RelayTo(pfrom);"
    },
    {
        "line": 76,
        "fullcodeline": "if (!fNoListen && !IsInitialBlockDownload())"
    },
    {
        "line": 78,
        "fullcodeline": "CAddress addr = GetLocalAddress(&pfrom->addr);"
    },
    {
        "line": 86,
        "fullcodeline": "nAddrSize = mapAddresses.size();"
    },
    {
        "line": 90,
        "fullcodeline": "pfrom->PushMessage(\"getaddr\");"
    },
    {
        "line": 91,
        "fullcodeline": "pfrom->fGetAddr = true;"
    },
    {
        "line": 94,
        "fullcodeline": "addrman.Good(pfrom->addr);"
    },
    {
        "line": 122,
        "fullcodeline": "pfrom->nVersion >= NOBLKS_VERSION_END) &&"
    },
    {
        "line": 79,
        "fullcodeline": "if (addr.IsRoutable())"
    },
    {
        "line": 88,
        "fullcodeline": "nAddrSize = addrman.size();"
    },
    {
        "line": 96,
        "fullcodeline": "if(!fBerkeleyAddrDB && ((CNetAddr)pfrom->addr == (CNetAddr)addrFrom)) {"
    },
    {
        "line": 97,
        "fullcodeline": "addrman.Add(addrFrom, addrFrom);"
    },
    {
        "line": 98,
        "fullcodeline": "addrman.Good(addrFrom);"
    },
    {
        "line": 164,
        "fullcodeline": "else if (strCommand == \"verack\")"
    },
    {
        "line": 80,
        "fullcodeline": "pfrom->PushAddress(addr);"
    },
    {
        "line": 166,
        "fullcodeline": "pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));"
    },
    {
        "line": 170,
        "fullcodeline": "else if (strCommand == \"addr\")"
    },
    {
        "line": 172,
        "fullcodeline": "vector<CAddress> vAddr;"
    },
    {
        "line": 173,
        "fullcodeline": "vRecv >> vAddr;"
    },
    {
        "line": 180,
        "fullcodeline": "int64 nNow = GetAdjustedTime();"
    },
    {
        "line": 181,
        "fullcodeline": "int64 nSince = nNow - 10 * 60;"
    },
    {
        "line": 175,
        "fullcodeline": "if(vAddr.size() > 1000) {"
    },
    {
        "line": 187,
        "fullcodeline": "adb.TxnBegin();"
    },
    {
        "line": 189,
        "fullcodeline": "BOOST_FOREACH(CAddress& addr, vAddr) {"
    },
    {
        "line": 251,
        "fullcodeline": "if(vAddr.size() < 1000)"
    },
    {
        "line": 259,
        "fullcodeline": "else if (strCommand == \"inv\")"
    },
    {
        "line": 177,
        "fullcodeline": "return(error(\"Address message size = %d\", vAddr.size()));"
    },
    {
        "line": 195,
        "fullcodeline": "ushort nPort = addr.GetPort();"
    },
    {
        "line": 202,
        "fullcodeline": "fReachable = IsReachable(addr);"
    },
    {
        "line": 207,
        "fullcodeline": "pfrom->AddAddressKnown(addr);"
    },
    {
        "line": 219,
        "fullcodeline": "vector<CAddress> vAddrOk;"
    },
    {
        "line": 221,
        "fullcodeline": "BOOST_FOREACH(CAddress& addr, vAddr) {"
    },
    {
        "line": 247,
        "fullcodeline": "addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);"
    },
    {
        "line": 261,
        "fullcodeline": "vector<CInv> vInv;"
    },
    {
        "line": 262,
        "fullcodeline": "vRecv >> vInv;"
    },
    {
        "line": 270,
        "fullcodeline": "unsigned int nLastBlock = (unsigned int)(-1);"
    },
    {
        "line": 227,
        "fullcodeline": "ushort nPort = addr.GetPort();"
    },
    {
        "line": 234,
        "fullcodeline": "fReachable = IsReachable(addr);"
    },
    {
        "line": 239,
        "fullcodeline": "pfrom->AddAddressKnown(addr);"
    },
    {
        "line": 271,
        "fullcodeline": "for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {"
    },
    {
        "line": 278,
        "fullcodeline": "for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)"
    },
    {
        "line": 199,
        "fullcodeline": "if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))"
    },
    {
        "line": 200,
        "fullcodeline": "addr.nTime = nNow - 5 * 24 * 60 * 60;"
    },
    {
        "line": 205,
        "fullcodeline": "AddAddress(addr, 2 * 60 * 60, &adb);"
    },
    {
        "line": 209,
        "fullcodeline": "if((addr.nTime > nSince) && !pfrom->fGetAddr &&"
    },
    {
        "line": 210,
        "fullcodeline": "(vAddr.size() <= 10) && addr.IsRoutable())"
    },
    {
        "line": 263,
        "fullcodeline": "if (vInv.size() > 50000)"
    },
    {
        "line": 280,
        "fullcodeline": "const CInv &inv = vInv[nInv];"
    },
    {
        "line": 284,
        "fullcodeline": "pfrom->AddInventoryKnown(inv);"
    },
    {
        "line": 286,
        "fullcodeline": "bool fAlreadyHave = AlreadyHave(txdb, inv);"
    },
    {
        "line": 310,
        "fullcodeline": "else if (strCommand == \"getdata\")"
    },
    {
        "line": 231,
        "fullcodeline": "if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))"
    },
    {
        "line": 232,
        "fullcodeline": "addr.nTime = nNow - 5 * 24 * 60 * 60;"
    },
    {
        "line": 237,
        "fullcodeline": "vAddrOk.push_back(addr);"
    },
    {
        "line": 241,
        "fullcodeline": "if((addr.nTime > nSince) && !pfrom->fGetAddr &&"
    },
    {
        "line": 242,
        "fullcodeline": "(vAddr.size() <= 10) && addr.IsRoutable())"
    },
    {
        "line": 266,
        "fullcodeline": "return error(\"message inv size() = %d\", vInv.size());"
    },
    {
        "line": 272,
        "fullcodeline": "if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {"
    },
    {
        "line": 312,
        "fullcodeline": "vector<CInv> vInv;"
    },
    {
        "line": 313,
        "fullcodeline": "vRecv >> vInv;"
    },
    {
        "line": 273,
        "fullcodeline": "nLastBlock = vInv.size() - 1 - nInv;"
    },
    {
        "line": 291,
        "fullcodeline": "pfrom->AskFor(inv);"
    },
    {
        "line": 320,
        "fullcodeline": "if (fDebugNet || (vInv.size() != 1))"
    },
    {
        "line": 288,
        "fullcodeline": "printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");"
    },
    {
        "line": 314,
        "fullcodeline": "if (vInv.size() > 50000)"
    },
    {
        "line": 370,
        "fullcodeline": "else if (strCommand == \"getblocks\")"
    },
    {
        "line": 317,
        "fullcodeline": "return error(\"message getdata size() = %d\", vInv.size());"
    },
    {
        "line": 321,
        "fullcodeline": "printf(\"received getdata (%d invsz)\\n\", vInv.size());"
    },
    {
        "line": 374,
        "fullcodeline": "vRecv >> locator >> hashStop;"
    },
    {
        "line": 377,
        "fullcodeline": "CBlockIndex* pindex = locator.GetBlockIndex();"
    },
    {
        "line": 382,
        "fullcodeline": "int nLimit = 1000;"
    },
    {
        "line": 383,
        "fullcodeline": "printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);"
    },
    {
        "line": 292,
        "fullcodeline": "else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {"
    },
    {
        "line": 293,
        "fullcodeline": "pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));"
    },
    {
        "line": 384,
        "fullcodeline": "for (; pindex; pindex = pindex->pnext)"
    },
    {
        "line": 381,
        "fullcodeline": "pindex = pindex->pnext;"
    },
    {
        "line": 391,
        "fullcodeline": "pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));"
    },
    {
        "line": 404,
        "fullcodeline": "else if (strCommand == \"getheaders\")"
    },
    {
        "line": 294,
        "fullcodeline": "} else if (nInv == nLastBlock) {"
    },
    {
        "line": 408,
        "fullcodeline": "vRecv >> locator >> hashStop;"
    },
    {
        "line": 427,
        "fullcodeline": "vector<CBlock> vHeaders;"
    },
    {
        "line": 428,
        "fullcodeline": "int nLimit = 2000;"
    },
    {
        "line": 436,
        "fullcodeline": "pfrom->PushMessage(\"headers\", vHeaders);"
    },
    {
        "line": 299,
        "fullcodeline": "pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));"
    },
    {
        "line": 386,
        "fullcodeline": "if (pindex->GetBlockHash() == hashStop)"
    },
    {
        "line": 392,
        "fullcodeline": "if (--nLimit <= 0)"
    },
    {
        "line": 396,
        "fullcodeline": "printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());"
    },
    {
        "line": 411,
        "fullcodeline": "if (locator.IsNull())"
    },
    {
        "line": 429,
        "fullcodeline": "printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());"
    },
    {
        "line": 430,
        "fullcodeline": "for (; pindex; pindex = pindex->pnext)"
    },
    {
        "line": 298,
        "fullcodeline": "std::vector<CInv> vGetData(1,inv);"
    },
    {
        "line": 388,
        "fullcodeline": "printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());"
    },
    {
        "line": 397,
        "fullcodeline": "pfrom->hashContinue = pindex->GetBlockHash();"
    },
    {
        "line": 414,
        "fullcodeline": "map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);"
    },
    {
        "line": 417,
        "fullcodeline": "pindex = (*mi).second;"
    },
    {
        "line": 432,
        "fullcodeline": "vHeaders.push_back(pindex->GetBlockHeader());"
    },
    {
        "line": 440,
        "fullcodeline": "else if (strCommand == \"tx\")"
    },
    {
        "line": 422,
        "fullcodeline": "pindex = locator.GetBlockIndex();"
    },
    {
        "line": 442,
        "fullcodeline": "vector<uint256> vWorkQueue;"
    },
    {
        "line": 443,
        "fullcodeline": "vector<uint256> vEraseQueue;"
    },
    {
        "line": 444,
        "fullcodeline": "CDataStream vMsg(vRecv);"
    },
    {
        "line": 447,
        "fullcodeline": "vRecv >> tx;"
    },
    {
        "line": 449,
        "fullcodeline": "CInv inv(MSG_TX, tx.GetHash());"
    },
    {
        "line": 450,
        "fullcodeline": "pfrom->AddInventoryKnown(inv);"
    },
    {
        "line": 453,
        "fullcodeline": "unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);"
    },
    {
        "line": 454,
        "fullcodeline": "unsigned int oldSize = vMsg.size();"
    },
    {
        "line": 461,
        "fullcodeline": "bool fMissingInputs = false;"
    },
    {
        "line": 301,
        "fullcodeline": "printf(\"force request: %s\\n\", inv.ToString().c_str());"
    },
    {
        "line": 415,
        "fullcodeline": "if (mi == mapBlockIndex.end())"
    },
    {
        "line": 433,
        "fullcodeline": "if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)"
    },
    {
        "line": 455,
        "fullcodeline": "if(nSize < oldSize) {"
    },
    {
        "line": 462,
        "fullcodeline": "if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))"
    },
    {
        "line": 424,
        "fullcodeline": "pindex = pindex->pnext;"
    },
    {
        "line": 456,
        "fullcodeline": "printf(\"truncating oversized transaction message %s (%u -> %u)\\n\","
    },
    {
        "line": 458,
        "fullcodeline": "vMsg.resize(nSize);"
    },
    {
        "line": 464,
        "fullcodeline": "SyncWithWallets(tx, NULL, true);"
    },
    {
        "line": 465,
        "fullcodeline": "RelayMessage(inv, vMsg);"
    },
    {
        "line": 466,
        "fullcodeline": "mapAlreadyAskedFor.erase(inv);"
    },
    {
        "line": 467,
        "fullcodeline": "vWorkQueue.push_back(inv.hash);"
    },
    {
        "line": 468,
        "fullcodeline": "vEraseQueue.push_back(inv.hash);"
    },
    {
        "line": 514,
        "fullcodeline": "if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);"
    },
    {
        "line": 518,
        "fullcodeline": "else if (strCommand == \"block\")"
    },
    {
        "line": 457,
        "fullcodeline": "tx.GetHash().ToString().c_str(), oldSize, nSize);"
    },
    {
        "line": 471,
        "fullcodeline": "for (unsigned int i = 0; i < vWorkQueue.size(); i++)"
    },
    {
        "line": 521,
        "fullcodeline": "vRecv >> block;"
    },
    {
        "line": 522,
        "fullcodeline": "uint256 hashBlock = block.GetHash();"
    },
    {
        "line": 523,
        "fullcodeline": "int nBlockHeight = block.GetBlockHeight();"
    },
    {
        "line": 529,
        "fullcodeline": "pfrom->AddInventoryKnown(inv);"
    },
    {
        "line": 526,
        "fullcodeline": "hashBlock.ToString().substr(0,20).c_str(), nBlockHeight);"
    },
    {
        "line": 531,
        "fullcodeline": "if(ProcessBlock(pfrom, &block))"
    },
    {
        "line": 475,
        "fullcodeline": "mi != mapOrphanTransactionsByPrev[hashPrev].end();"
    },
    {
        "line": 476,
        "fullcodeline": "++mi)"
    },
    {
        "line": 510,
        "fullcodeline": "unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);"
    },
    {
        "line": 535,
        "fullcodeline": "pfrom->Misbehaving(block.nDoS);"
    },
    {
        "line": 539,
        "fullcodeline": "else if (strCommand == \"getaddr\")"
    },
    {
        "line": 474,
        "fullcodeline": "for (map<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();"
    },
    {
        "line": 478,
        "fullcodeline": "const CDataStream& vMsg = *((*mi).second);"
    },
    {
        "line": 480,
        "fullcodeline": "CDataStream(vMsg) >> tx;"
    },
    {
        "line": 482,
        "fullcodeline": "bool fMissingInputs2 = false;"
    },
    {
        "line": 511,
        "fullcodeline": "if (nEvicted > 0)"
    },
    {
        "line": 481,
        "fullcodeline": "CInv inv(MSG_TX, tx.GetHash());"
    },
    {
        "line": 484,
        "fullcodeline": "if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))"
    },
    {
        "line": 542,
        "fullcodeline": "vector<CAddress> vAddr = addrman.GetAddr();"
    },
    {
        "line": 487,
        "fullcodeline": "SyncWithWallets(tx, NULL, true);"
    },
    {
        "line": 488,
        "fullcodeline": "RelayMessage(inv, vMsg);"
    },
    {
        "line": 489,
        "fullcodeline": "mapAlreadyAskedFor.erase(inv);"
    },
    {
        "line": 490,
        "fullcodeline": "vWorkQueue.push_back(inv.hash);"
    },
    {
        "line": 491,
        "fullcodeline": "vEraseQueue.push_back(inv.hash);"
    },
    {
        "line": 548,
        "fullcodeline": "else if (strCommand == \"checkorder\")"
    },
    {
        "line": 486,
        "fullcodeline": "printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());"
    },
    {
        "line": 551,
        "fullcodeline": "vRecv >> hashReply;"
    },
    {
        "line": 570,
        "fullcodeline": "scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;"
    },
    {
        "line": 571,
        "fullcodeline": "pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);"
    },
    {
        "line": 496,
        "fullcodeline": "vEraseQueue.push_back(inv.hash);"
    },
    {
        "line": 553,
        "fullcodeline": "if (!GetBoolArg(\"-allowreceivebyip\"))"
    },
    {
        "line": 565,
        "fullcodeline": "if (!mapReuseKey.count(pfrom->addr))"
    },
    {
        "line": 566,
        "fullcodeline": "pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);"
    },
    {
        "line": 575,
        "fullcodeline": "else if (strCommand == \"reply\")"
    },
    {
        "line": 497,
        "fullcodeline": "printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());"
    },
    {
        "line": 555,
        "fullcodeline": "pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));"
    },
    {
        "line": 578,
        "fullcodeline": "vRecv >> hashReply;"
    },
    {
        "line": 583,
        "fullcodeline": "map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);"
    },
    {
        "line": 584,
        "fullcodeline": "if (mi != pfrom->mapRequests.end())"
    },
    {
        "line": 590,
        "fullcodeline": "if (!tracker.IsNull())"
    },
    {
        "line": 595,
        "fullcodeline": "else if (strCommand == \"ping\")"
    },
    {
        "line": 586,
        "fullcodeline": "tracker = (*mi).second;"
    },
    {
        "line": 597,
        "fullcodeline": "if (pfrom->nVersion > BIP0031_VERSION)"
    },
    {
        "line": 599,
        "fullcodeline": "uint64 nonce = 0;"
    },
    {
        "line": 600,
        "fullcodeline": "vRecv >> nonce;"
    },
    {
        "line": 612,
        "fullcodeline": "pfrom->PushMessage(\"pong\", nonce);"
    },
    {
        "line": 617,
        "fullcodeline": "else if (strCommand == \"alert\")"
    },
    {
        "line": 626,
        "fullcodeline": "vRecv >> alert;"
    },
    {
        "line": 628,
        "fullcodeline": "if (alert.ProcessAlert())"
    },
    {
        "line": 645,
        "fullcodeline": "else if (strCommand == \"checkpoint\")"
    },
    {
        "line": 621,
        "fullcodeline": "pfrom->addr.ToString().c_str(), pfrom->nVersion);"
    },
    {
        "line": 631,
        "fullcodeline": "pfrom->setKnown.insert(alert.GetHash());"
    },
    {
        "line": 639,
        "fullcodeline": "pfrom->Misbehaving(20);"
    },
    {
        "line": 654,
        "fullcodeline": "vRecv >> checkpoint;"
    },
    {
        "line": 634,
        "fullcodeline": "BOOST_FOREACH(CNode* pnode, vNodes)"
    },
    {
        "line": 656,
        "fullcodeline": "if (checkpoint.ProcessSyncCheckpoint(pfrom))"
    },
    {
        "line": 649,
        "fullcodeline": "pfrom->addr.ToString().c_str(), pfrom->nVersion);"
    },
    {
        "line": 661,
        "fullcodeline": "BOOST_FOREACH(CNode* pnode, vNodes)"
    }
]