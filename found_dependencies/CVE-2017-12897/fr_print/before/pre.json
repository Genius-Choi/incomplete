[
    {
        "line": 10,
        "fullcodeline": "uint8_t flags[4];"
    },
    {
        "line": 12,
        "fullcodeline": "ret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length);"
    },
    {
        "line": 20,
        "fullcodeline": "ND_TCHECK(p[addr_len]);"
    },
    {
        "line": 52,
        "fullcodeline": "ND_TCHECK(p[addr_len+1]);"
    },
    {
        "line": 74,
        "fullcodeline": "ND_TCHECK(p[hdr_len - 1]);"
    },
    {
        "line": 77,
        "fullcodeline": "nlpid = p[hdr_len - 1];"
    },
    {
        "line": 81,
        "fullcodeline": "p += hdr_len;"
    },
    {
        "line": 82,
        "fullcodeline": "length -= hdr_len;"
    },
    {
        "line": 13,
        "fullcodeline": "if (ret == -1)"
    },
    {
        "line": 15,
        "fullcodeline": "if (ret == 0) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (length < addr_len + 1)"
    },
    {
        "line": 53,
        "fullcodeline": "if (length < addr_len + 2)"
    },
    {
        "line": 56,
        "fullcodeline": "if (p[addr_len + 1] == 0) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (length < hdr_len)"
    },
    {
        "line": 133,
        "fullcodeline": "ND_PRINT((ndo, \"[|fr]\"));"
    },
    {
        "line": 16,
        "fullcodeline": "ND_PRINT((ndo, \"Q.922, invalid address\"));"
    },
    {
        "line": 24,
        "fullcodeline": "if (p[addr_len] != LLC_UI && dlci != 0) {"
    },
    {
        "line": 63,
        "fullcodeline": "hdr_len = addr_len + 1 /* UI */ + 1 /* pad */ + 1 /* NLPID */;"
    },
    {
        "line": 80,
        "fullcodeline": "fr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);"
    },
    {
        "line": 61,
        "fullcodeline": "if (addr_len != 3)"
    },
    {
        "line": 71,
        "fullcodeline": "hdr_len = addr_len + 1 /* UI */ + 1 /* NLPID */;"
    },
    {
        "line": 96,
        "fullcodeline": "isoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1); /* OSI printers need the NLPID field */"
    },
    {
        "line": 123,
        "fullcodeline": "if (!ndo->ndo_eflag)"
    },
    {
        "line": 30,
        "fullcodeline": "if (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) {"
    },
    {
        "line": 69,
        "fullcodeline": "if (addr_len == 3)"
    },
    {
        "line": 100,
        "fullcodeline": "if (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {"
    },
    {
        "line": 124,
        "fullcodeline": "fr_hdr_print(ndo, length + hdr_len, addr_len,"
    },
    {
        "line": 32,
        "fullcodeline": "ND_PRINT((ndo, \"UI %02x! \", p[addr_len]));"
    },
    {
        "line": 34,
        "fullcodeline": "extracted_ethertype = EXTRACT_16BITS(p+addr_len);"
    },
    {
        "line": 62,
        "fullcodeline": "ND_PRINT((ndo, \"Pad! \"));"
    },
    {
        "line": 102,
        "fullcodeline": "if (!ndo->ndo_eflag)"
    },
    {
        "line": 70,
        "fullcodeline": "ND_PRINT((ndo, \"No pad! \"));"
    },
    {
        "line": 103,
        "fullcodeline": "fr_hdr_print(ndo, length + hdr_len, hdr_len,"
    },
    {
        "line": 37,
        "fullcodeline": "fr_hdr_print(ndo, length, addr_len, dlci,"
    },
    {
        "line": 40,
        "fullcodeline": "if (ethertype_print(ndo, extracted_ethertype,"
    },
    {
        "line": 106,
        "fullcodeline": "ND_DEFAULTPRINT(p - hdr_len, length + hdr_len);"
    },
    {
        "line": 42,
        "fullcodeline": "length-addr_len-ETHERTYPE_LEN,"
    },
    {
        "line": 43,
        "fullcodeline": "ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN,"
    },
    {
        "line": 46,
        "fullcodeline": "ND_PRINT((ndo, \"UI %02x! \", p[addr_len]));"
    },
    {
        "line": 48,
        "fullcodeline": "return addr_len + 2;"
    }
]