[
    {
        "line": 4,
        "fullcodeline": "struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;"
    },
    {
        "line": 8,
        "fullcodeline": "memset(&temp, 0u, sizeof(struct filter_node));"
    },
    {
        "line": 10,
        "fullcodeline": "temp.fdev = f->dev;"
    },
    {
        "line": 25,
        "fullcodeline": "temp.priority = f->priority;"
    },
    {
        "line": 26,
        "fullcodeline": "temp.tos = ipv4_hdr->tos;"
    },
    {
        "line": 13,
        "fullcodeline": "if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {"
    },
    {
        "line": 27,
        "fullcodeline": "return ipfilter_apply_filter(f, &temp);"
    },
    {
        "line": 23,
        "fullcodeline": "temp.proto = ipv4_hdr->proto;"
    },
    {
        "line": 14,
        "fullcodeline": "if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {"
    },
    {
        "line": 15,
        "fullcodeline": "trans = (struct pico_trans *) f->transport_hdr;"
    },
    {
        "line": 16,
        "fullcodeline": "temp.out_port = short_be(trans->dport);"
    },
    {
        "line": 17,
        "fullcodeline": "temp.in_port = short_be(trans->sport);"
    },
    {
        "line": 18,
        "fullcodeline": "} else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {"
    },
    {
        "line": 19,
        "fullcodeline": "icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;"
    },
    {
        "line": 20,
        "fullcodeline": "if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)"
    }
]