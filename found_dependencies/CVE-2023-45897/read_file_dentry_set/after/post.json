[
    {
        "line": 5,
        "fullcodeline": "struct exfat_inode *node = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "bool need_delete = false;"
    },
    {
        "line": 10,
        "fullcodeline": "ret = exfat_de_iter_get(iter, 0, &file_de);"
    },
    {
        "line": 16,
        "fullcodeline": "checksum = file_calc_checksum(iter);"
    },
    {
        "line": 34,
        "fullcodeline": "ret = exfat_de_iter_get(iter, 1, &stream_de);"
    },
    {
        "line": 43,
        "fullcodeline": "*new_node = NULL;"
    },
    {
        "line": 44,
        "fullcodeline": "node = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));"
    },
    {
        "line": 66,
        "fullcodeline": "ret = check_name_dentry_set(iter, node);"
    },
    {
        "line": 81,
        "fullcodeline": "node->first_clus = le32_to_cpu(stream_de->stream_start_clu);"
    },
    {
        "line": 82,
        "fullcodeline": "node->is_contiguous ="
    },
    {
        "line": 84,
        "fullcodeline": "node->size = le64_to_cpu(stream_de->stream_size);"
    },
    {
        "line": 101,
        "fullcodeline": "*skip_dentries = (file_de->file_num_ext + 1);"
    },
    {
        "line": 102,
        "fullcodeline": "*new_node = node;"
    },
    {
        "line": 118,
        "fullcodeline": "*skip_dentries = i;"
    },
    {
        "line": 119,
        "fullcodeline": "*new_node = NULL;"
    },
    {
        "line": 120,
        "fullcodeline": "exfat_free_inode(node);"
    },
    {
        "line": 11,
        "fullcodeline": "if (ret || file_de->type != EXFAT_FILE) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (checksum != le16_to_cpu(file_de->file_checksum)) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (file_de->file_num_ext < 2) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (ret || stream_de->type != EXFAT_STREAM) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (!node)"
    },
    {
        "line": 48,
        "fullcodeline": "for (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {"
    },
    {
        "line": 83,
        "fullcodeline": "((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);"
    },
    {
        "line": 86,
        "fullcodeline": "if (node->size < le64_to_cpu(stream_de->stream_valid_size)) {"
    },
    {
        "line": 109,
        "fullcodeline": "for (i = 1; i < *skip_dentries; i++) {"
    },
    {
        "line": 121,
        "fullcodeline": "return need_delete ? 1 : -EINVAL;"
    },
    {
        "line": 12,
        "fullcodeline": "exfat_err(\"failed to get file dentry\\n\");"
    },
    {
        "line": 21,
        "fullcodeline": "*skip_dentries = 1;"
    },
    {
        "line": 30,
        "fullcodeline": "*skip_dentries = 1;"
    },
    {
        "line": 39,
        "fullcodeline": "*skip_dentries = 2;"
    },
    {
        "line": 49,
        "fullcodeline": "ret = exfat_de_iter_get(iter, i, &dentry);"
    },
    {
        "line": 61,
        "fullcodeline": "memcpy(node->name +"
    },
    {
        "line": 68,
        "fullcodeline": "*skip_dentries = file_de->file_num_ext + 1;"
    },
    {
        "line": 73,
        "fullcodeline": "ret = handle_dot_dotdot_filename(iter, dentry,"
    },
    {
        "line": 87,
        "fullcodeline": "*skip_dentries = file_de->file_num_ext + 1;"
    },
    {
        "line": 106,
        "fullcodeline": "exfat_de_iter_get_dirty(iter, 0, &dentry);"
    },
    {
        "line": 107,
        "fullcodeline": "dentry->type &= EXFAT_DELETE;"
    },
    {
        "line": 110,
        "fullcodeline": "exfat_de_iter_get(iter, i, &dentry);"
    },
    {
        "line": 13,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 18,
        "fullcodeline": "if (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,"
    },
    {
        "line": 26,
        "fullcodeline": "if (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,"
    },
    {
        "line": 36,
        "fullcodeline": "if (repair_file_ask(iter, NULL, ER_DE_STREAM,"
    },
    {
        "line": 46,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 50,
        "fullcodeline": "if (ret || dentry->type != EXFAT_NAME) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (dentry->type == EXFAT_FILE)"
    },
    {
        "line": 20,
        "fullcodeline": "need_delete = true;"
    },
    {
        "line": 29,
        "fullcodeline": "need_delete = true;"
    },
    {
        "line": 38,
        "fullcodeline": "need_delete = true;"
    },
    {
        "line": 57,
        "fullcodeline": "*skip_dentries = i + 1;"
    },
    {
        "line": 62,
        "fullcodeline": "(i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,"
    },
    {
        "line": 76,
        "fullcodeline": "*skip_dentries = file_de->file_num_ext + 1;"
    },
    {
        "line": 92,
        "fullcodeline": "exfat_de_iter_get_dirty(iter, 1, &stream_de);"
    },
    {
        "line": 93,
        "fullcodeline": "stream_de->stream_valid_size ="
    },
    {
        "line": 114,
        "fullcodeline": "exfat_de_iter_get_dirty(iter, i, &dentry);"
    },
    {
        "line": 115,
        "fullcodeline": "dentry->type &= EXFAT_DELETE;"
    },
    {
        "line": 51,
        "fullcodeline": "if (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,"
    },
    {
        "line": 96,
        "fullcodeline": "*skip_dentries = file_de->file_num_ext + 1;"
    },
    {
        "line": 53,
        "fullcodeline": "exfat_de_iter_get_dirty(iter, 0, &file_de);"
    },
    {
        "line": 54,
        "fullcodeline": "file_de->file_num_ext = i - 1;"
    }
]