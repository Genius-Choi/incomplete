[
    {
        "line": 5,
        "fullcodeline": "static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);"
    },
    {
        "line": 11,
        "fullcodeline": "bundle = ofpact_put_BUNDLE(ofpacts);"
    },
    {
        "line": 13,
        "fullcodeline": "bundle->n_slaves = ntohs(nab->n_slaves);"
    },
    {
        "line": 14,
        "fullcodeline": "bundle->basis = ntohs(nab->basis);"
    },
    {
        "line": 15,
        "fullcodeline": "bundle->fields = ntohs(nab->fields);"
    },
    {
        "line": 16,
        "fullcodeline": "bundle->algorithm = ntohs(nab->algorithm);"
    },
    {
        "line": 17,
        "fullcodeline": "slave_type = ntohl(nab->slave_type);"
    },
    {
        "line": 18,
        "fullcodeline": "slaves_size = ntohs(nab->len) - sizeof *nab;"
    },
    {
        "line": 20,
        "fullcodeline": "error = OFPERR_OFPBAC_BAD_ARGUMENT;"
    },
    {
        "line": 75,
        "fullcodeline": "ofpact_finish_BUNDLE(ofpacts, &bundle);"
    },
    {
        "line": 21,
        "fullcodeline": "if (!flow_hash_fields_valid(bundle->fields)) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (!is_all_zeros(nab->zero, sizeof nab->zero)) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (slaves_size < bundle->n_slaves * sizeof(ovs_be16)) {"
    },
    {
        "line": 69,
        "fullcodeline": "for (i = 0; i < bundle->n_slaves; i++) {"
    },
    {
        "line": 76,
        "fullcodeline": "if (!error) {"
    },
    {
        "line": 22,
        "fullcodeline": "VLOG_WARN_RL(&rl, \"unsupported fields %d\", (int) bundle->fields);"
    },
    {
        "line": 35,
        "fullcodeline": "VLOG_WARN_RL(&rl, \"reserved field is nonzero\");"
    },
    {
        "line": 36,
        "fullcodeline": "error = OFPERR_OFPBAC_BAD_ARGUMENT;"
    },
    {
        "line": 40,
        "fullcodeline": "bundle->dst.ofs = nxm_decode_ofs(nab->ofs_nbits);"
    },
    {
        "line": 41,
        "fullcodeline": "bundle->dst.n_bits = nxm_decode_n_bits(nab->ofs_nbits);"
    },
    {
        "line": 42,
        "fullcodeline": "error = mf_vl_mff_mf_from_nxm_header(ntohl(nab->dst), vl_mff_map,"
    },
    {
        "line": 66,
        "fullcodeline": "error = OFPERR_OFPBAC_BAD_LEN;"
    },
    {
        "line": 70,
        "fullcodeline": "ofp_port_t ofp_port = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));"
    },
    {
        "line": 71,
        "fullcodeline": "ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);"
    },
    {
        "line": 72,
        "fullcodeline": "bundle = ofpacts->header;"
    },
    {
        "line": 77,
        "fullcodeline": "error = bundle_check(bundle, OFPP_MAX, NULL);"
    },
    {
        "line": 48,
        "fullcodeline": "if (bundle->dst.n_bits < 16) {"
    },
    {
        "line": 23,
        "fullcodeline": "} else if (bundle->n_slaves > BUNDLE_MAX_SLAVES) {"
    },
    {
        "line": 49,
        "fullcodeline": "VLOG_WARN_RL(&rl, \"bundle_load action requires at least 16 bit \""
    },
    {
        "line": 51,
        "fullcodeline": "error = OFPERR_OFPBAC_BAD_ARGUMENT;"
    },
    {
        "line": 54,
        "fullcodeline": "if (nab->ofs_nbits || nab->dst) {"
    },
    {
        "line": 24,
        "fullcodeline": "VLOG_WARN_RL(&rl, \"too many slaves\");"
    },
    {
        "line": 55,
        "fullcodeline": "VLOG_WARN_RL(&rl, \"bundle action has nonzero reserved fields\");"
    },
    {
        "line": 56,
        "fullcodeline": "error = OFPERR_OFPBAC_BAD_ARGUMENT;"
    },
    {
        "line": 25,
        "fullcodeline": "} else if (bundle->algorithm != NX_BD_ALG_HRW"
    },
    {
        "line": 26,
        "fullcodeline": "&& bundle->algorithm != NX_BD_ALG_ACTIVE_BACKUP) {"
    },
    {
        "line": 27,
        "fullcodeline": "VLOG_WARN_RL(&rl, \"unsupported algorithm %d\", (int) bundle->algorithm);"
    },
    {
        "line": 28,
        "fullcodeline": "} else if (slave_type != mf_nxm_header(MFF_IN_PORT)) {"
    },
    {
        "line": 31,
        "fullcodeline": "error = 0;"
    }
]