[
    {
        "line": 8,
        "fullcodeline": "char_u\t\t*after_p = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\t\thad_ctrl_v_cr = FALSE;"
    },
    {
        "line": 232,
        "fullcodeline": "changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);"
    },
    {
        "line": 11,
        "fullcodeline": "if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)"
    },
    {
        "line": 14,
        "fullcodeline": "if (c == REPLACE_CR_NCHAR)"
    },
    {
        "line": 28,
        "fullcodeline": "if (u_save((linenr_T)(oap->start.lnum - 1),"
    },
    {
        "line": 16,
        "fullcodeline": "had_ctrl_v_cr = TRUE;"
    },
    {
        "line": 17,
        "fullcodeline": "c = CAR;"
    },
    {
        "line": 26,
        "fullcodeline": "mb_adjust_opend(oap);"
    },
    {
        "line": 37,
        "fullcodeline": "bd.is_MAX = (curwin->w_curswant == MAXCOL);"
    },
    {
        "line": 234,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)"
    },
    {
        "line": 29,
        "fullcodeline": "(linenr_T)(oap->end.lnum + 1)) == FAIL)"
    },
    {
        "line": 38,
        "fullcodeline": "for ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)"
    },
    {
        "line": 19,
        "fullcodeline": "else if (c == REPLACE_NL_NCHAR)"
    },
    {
        "line": 41,
        "fullcodeline": "block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);"
    },
    {
        "line": 64,
        "fullcodeline": "n += (bd.endspaces"
    },
    {
        "line": 68,
        "fullcodeline": "numc = oap->end_vcol - oap->start_vcol + 1;"
    },
    {
        "line": 85,
        "fullcodeline": "num_chars = numc;"
    },
    {
        "line": 86,
        "fullcodeline": "numc *= (*mb_char2len)(c);"
    },
    {
        "line": 88,
        "fullcodeline": "n += numc - bd.textlen;"
    },
    {
        "line": 90,
        "fullcodeline": "oldp = ml_get_curline();"
    },
    {
        "line": 91,
        "fullcodeline": "oldlen = STRLEN(oldp);"
    },
    {
        "line": 92,
        "fullcodeline": "newp = alloc(oldlen + 1 + n);"
    },
    {
        "line": 95,
        "fullcodeline": "vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));"
    },
    {
        "line": 97,
        "fullcodeline": "mch_memmove(newp, oldp, (size_t)bd.textcol);"
    },
    {
        "line": 98,
        "fullcodeline": "oldp += bd.textcol + bd.textlen;"
    },
    {
        "line": 130,
        "fullcodeline": "ml_replace(curwin->w_cursor.lnum, newp, FALSE);"
    },
    {
        "line": 145,
        "fullcodeline": "if (oap->motion_type == MLINE)"
    },
    {
        "line": 156,
        "fullcodeline": "while (LTOREQ_POS(curwin->w_cursor, oap->end))"
    },
    {
        "line": 21,
        "fullcodeline": "had_ctrl_v_cr = TRUE;"
    },
    {
        "line": 22,
        "fullcodeline": "c = NL;"
    },
    {
        "line": 42,
        "fullcodeline": "if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))"
    },
    {
        "line": 69,
        "fullcodeline": "if (bd.is_short && (!virtual_op || bd.is_MAX))"
    },
    {
        "line": 93,
        "fullcodeline": "if (newp == NULL)"
    },
    {
        "line": 131,
        "fullcodeline": "if (after_p != NULL)"
    },
    {
        "line": 147,
        "fullcodeline": "oap->start.col = 0;"
    },
    {
        "line": 148,
        "fullcodeline": "curwin->w_cursor.col = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));"
    },
    {
        "line": 158,
        "fullcodeline": "int done = FALSE;"
    },
    {
        "line": 160,
        "fullcodeline": "n = gchar_cursor();"
    },
    {
        "line": 50,
        "fullcodeline": "if (virtual_op && bd.is_short && *bd.textstart == NUL)"
    },
    {
        "line": 54,
        "fullcodeline": "vpos.lnum = curwin->w_cursor.lnum;"
    },
    {
        "line": 55,
        "fullcodeline": "getvpos(&vpos, oap->start_vcol);"
    },
    {
        "line": 56,
        "fullcodeline": "bd.startspaces += vpos.coladd;"
    },
    {
        "line": 57,
        "fullcodeline": "n = bd.startspaces;"
    },
    {
        "line": 66,
        "fullcodeline": "&& bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;"
    },
    {
        "line": 70,
        "fullcodeline": "numc -= (oap->end_vcol - bd.end_vcol) + 1;"
    },
    {
        "line": 74,
        "fullcodeline": "if ((*mb_char2cells)(c) > 1)"
    },
    {
        "line": 81,
        "fullcodeline": "numc = numc / 2;"
    },
    {
        "line": 104,
        "fullcodeline": "if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))"
    },
    {
        "line": 133,
        "fullcodeline": "ml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);"
    },
    {
        "line": 134,
        "fullcodeline": "appended_lines_mark(curwin->w_cursor.lnum, 1L);"
    },
    {
        "line": 135,
        "fullcodeline": "oap->end.lnum++;"
    },
    {
        "line": 136,
        "fullcodeline": "vim_free(after_p);"
    },
    {
        "line": 161,
        "fullcodeline": "if (n != NUL)"
    },
    {
        "line": 61,
        "fullcodeline": "n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);"
    },
    {
        "line": 114,
        "fullcodeline": "if (!bd.is_short)"
    },
    {
        "line": 125,
        "fullcodeline": "after_p = alloc(oldlen + 1 + n - STRLEN(newp));"
    },
    {
        "line": 151,
        "fullcodeline": "--oap->end.col;"
    },
    {
        "line": 163,
        "fullcodeline": "int new_byte_len = (*mb_char2len)(c);"
    },
    {
        "line": 164,
        "fullcodeline": "int old_byte_len = mb_ptr2len(ml_get_cursor());"
    },
    {
        "line": 200,
        "fullcodeline": "if (!done && virtual_op && curwin->w_cursor.lnum == oap->end.lnum)"
    },
    {
        "line": 202,
        "fullcodeline": "int virtcols = oap->end.coladd;"
    },
    {
        "line": 212,
        "fullcodeline": "curwin->w_cursor.col -= (virtcols + 1);"
    },
    {
        "line": 225,
        "fullcodeline": "if (inc_cursor() == -1)"
    },
    {
        "line": 65,
        "fullcodeline": "&& !bd.is_oneChar"
    },
    {
        "line": 76,
        "fullcodeline": "if ((numc & 1) && !bd.is_short)"
    },
    {
        "line": 78,
        "fullcodeline": "++bd.endspaces;"
    },
    {
        "line": 79,
        "fullcodeline": "++n;"
    },
    {
        "line": 108,
        "fullcodeline": "n = (int)STRLEN(newp);"
    },
    {
        "line": 126,
        "fullcodeline": "if (after_p != NULL)"
    },
    {
        "line": 154,
        "fullcodeline": "dec(&(oap->end));"
    },
    {
        "line": 204,
        "fullcodeline": "if (curwin->w_cursor.lnum == oap->start.lnum"
    },
    {
        "line": 213,
        "fullcodeline": "for (; virtcols >= 0; virtcols--)"
    },
    {
        "line": 110,
        "fullcodeline": "n += (*mb_char2bytes)(c, newp + n);"
    },
    {
        "line": 113,
        "fullcodeline": "vim_memset(newp + STRLEN(newp), c, (size_t)numc);"
    },
    {
        "line": 127,
        "fullcodeline": "STRMOVE(after_p, oldp);"
    },
    {
        "line": 166,
        "fullcodeline": "if (new_byte_len > 1 || old_byte_len > 1)"
    },
    {
        "line": 172,
        "fullcodeline": "replace_character(c);"
    },
    {
        "line": 173,
        "fullcodeline": "done = TRUE;"
    },
    {
        "line": 206,
        "fullcodeline": "virtcols -= oap->start.coladd;"
    },
    {
        "line": 211,
        "fullcodeline": "coladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);"
    },
    {
        "line": 109,
        "fullcodeline": "while (--num_chars >= 0)"
    },
    {
        "line": 117,
        "fullcodeline": "vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);"
    },
    {
        "line": 119,
        "fullcodeline": "STRMOVE(newp + STRLEN(newp), oldp);"
    },
    {
        "line": 170,
        "fullcodeline": "if (curwin->w_cursor.lnum == oap->end.lnum)"
    },
    {
        "line": 205,
        "fullcodeline": "&& oap->start.col == oap->end.col && oap->start.coladd)"
    },
    {
        "line": 171,
        "fullcodeline": "oap->end.col += new_byte_len - old_byte_len;"
    },
    {
        "line": 177,
        "fullcodeline": "if (n == TAB)"
    },
    {
        "line": 193,
        "fullcodeline": "if (gchar_cursor() != NUL)"
    },
    {
        "line": 215,
        "fullcodeline": "if ((*mb_char2len)(c) > 1)"
    },
    {
        "line": 216,
        "fullcodeline": "replace_character(c);"
    },
    {
        "line": 219,
        "fullcodeline": "if (inc(&curwin->w_cursor) == -1)"
    },
    {
        "line": 179,
        "fullcodeline": "int end_vcol = 0;"
    },
    {
        "line": 195,
        "fullcodeline": "PBYTE(curwin->w_cursor, c);"
    },
    {
        "line": 196,
        "fullcodeline": "done = TRUE;"
    },
    {
        "line": 218,
        "fullcodeline": "PBYTE(curwin->w_cursor, c);"
    },
    {
        "line": 181,
        "fullcodeline": "if (curwin->w_cursor.lnum == oap->end.lnum)"
    },
    {
        "line": 189,
        "fullcodeline": "if (curwin->w_cursor.lnum == oap->end.lnum)"
    },
    {
        "line": 185,
        "fullcodeline": "end_vcol = getviscol2(oap->end.col,"
    },
    {
        "line": 190,
        "fullcodeline": "getvpos(&oap->end, end_vcol);"
    }
]