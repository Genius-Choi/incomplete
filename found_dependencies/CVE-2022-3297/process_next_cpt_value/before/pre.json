[
    {
        "line": 6,
        "fullcodeline": "int\t    compl_type = -1;"
    },
    {
        "line": 7,
        "fullcodeline": "int\t    status = INS_COMPL_CPT_OK;"
    },
    {
        "line": 9,
        "fullcodeline": "st->found_all = FALSE;"
    },
    {
        "line": 112,
        "fullcodeline": "*compl_type_arg = compl_type;"
    },
    {
        "line": 11,
        "fullcodeline": "while (*st->e_cpt == ',' || *st->e_cpt == ' ')"
    },
    {
        "line": 12,
        "fullcodeline": "st->e_cpt++;"
    },
    {
        "line": 14,
        "fullcodeline": "if (*st->e_cpt == '.' && !curbuf->b_scanned)"
    },
    {
        "line": 16,
        "fullcodeline": "st->ins_buf = curbuf;"
    },
    {
        "line": 17,
        "fullcodeline": "st->first_match_pos = *start_match_pos;"
    },
    {
        "line": 29,
        "fullcodeline": "st->last_match_pos = st->first_match_pos;"
    },
    {
        "line": 30,
        "fullcodeline": "compl_type = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "st->set_match_pos = TRUE;"
    },
    {
        "line": 20,
        "fullcodeline": "if (ctrl_x_mode_normal() && dec(&st->first_match_pos) < 0)"
    },
    {
        "line": 25,
        "fullcodeline": "st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count;"
    },
    {
        "line": 26,
        "fullcodeline": "st->first_match_pos.col ="
    },
    {
        "line": 36,
        "fullcodeline": "else if (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL"
    },
    {
        "line": 27,
        "fullcodeline": "(colnr_T)STRLEN(ml_get(st->first_match_pos.lnum));"
    },
    {
        "line": 37,
        "fullcodeline": "&& (st->ins_buf = ins_compl_next_buf(st->ins_buf, *st->e_cpt)) != curbuf)"
    },
    {
        "line": 60,
        "fullcodeline": "msg_hist_off = TRUE;\t// reset in msg_trunc_attr()"
    },
    {
        "line": 61,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),"
    },
    {
        "line": 67,
        "fullcodeline": "(void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));"
    },
    {
        "line": 40,
        "fullcodeline": "if (st->ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer"
    },
    {
        "line": 62,
        "fullcodeline": "st->ins_buf->b_fname == NULL"
    },
    {
        "line": 42,
        "fullcodeline": "compl_started = TRUE;"
    },
    {
        "line": 43,
        "fullcodeline": "st->first_match_pos.col = st->last_match_pos.col = 0;"
    },
    {
        "line": 44,
        "fullcodeline": "st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count + 1;"
    },
    {
        "line": 45,
        "fullcodeline": "st->last_match_pos.lnum = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "compl_type = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "? buf_spname(st->ins_buf)"
    },
    {
        "line": 64,
        "fullcodeline": ": st->ins_buf->b_sfname == NULL"
    },
    {
        "line": 69,
        "fullcodeline": "else if (*st->e_cpt == NUL)"
    },
    {
        "line": 50,
        "fullcodeline": "st->found_all = TRUE;"
    },
    {
        "line": 56,
        "fullcodeline": "compl_type = CTRL_X_DICTIONARY;"
    },
    {
        "line": 57,
        "fullcodeline": "st->dict = st->ins_buf->b_fname;"
    },
    {
        "line": 58,
        "fullcodeline": "st->dict_f = DICT_EXACT;"
    },
    {
        "line": 70,
        "fullcodeline": "status = INS_COMPL_CPT_END;"
    },
    {
        "line": 51,
        "fullcodeline": "if (st->ins_buf->b_fname == NULL)"
    },
    {
        "line": 104,
        "fullcodeline": "(void)copy_option_part(&st->e_cpt, IObuff, IOSIZE, \",\");"
    },
    {
        "line": 106,
        "fullcodeline": "st->found_all = TRUE;"
    },
    {
        "line": 53,
        "fullcodeline": "status = INS_COMPL_CPT_CONT;"
    },
    {
        "line": 73,
        "fullcodeline": "if (ctrl_x_mode_line_or_eval())"
    },
    {
        "line": 107,
        "fullcodeline": "if (compl_type == -1)"
    },
    {
        "line": 74,
        "fullcodeline": "compl_type = -1;"
    },
    {
        "line": 108,
        "fullcodeline": "status = INS_COMPL_CPT_CONT;"
    },
    {
        "line": 75,
        "fullcodeline": "else if (*st->e_cpt == 'k' || *st->e_cpt == 's')"
    },
    {
        "line": 77,
        "fullcodeline": "if (*st->e_cpt == 'k')"
    },
    {
        "line": 81,
        "fullcodeline": "if (*++st->e_cpt != ',' && *st->e_cpt != NUL)"
    },
    {
        "line": 78,
        "fullcodeline": "compl_type = CTRL_X_DICTIONARY;"
    },
    {
        "line": 83,
        "fullcodeline": "st->dict = st->e_cpt;"
    },
    {
        "line": 84,
        "fullcodeline": "st->dict_f = DICT_FIRST;"
    },
    {
        "line": 93,
        "fullcodeline": "else if (*st->e_cpt == ']' || *st->e_cpt == 't')"
    },
    {
        "line": 80,
        "fullcodeline": "compl_type = CTRL_X_THESAURUS;"
    },
    {
        "line": 95,
        "fullcodeline": "msg_hist_off = TRUE;\t// reset in msg_trunc_attr()"
    },
    {
        "line": 96,
        "fullcodeline": "compl_type = CTRL_X_TAGS;"
    },
    {
        "line": 97,
        "fullcodeline": "vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning tags.\"));"
    },
    {
        "line": 98,
        "fullcodeline": "(void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));"
    },
    {
        "line": 101,
        "fullcodeline": "compl_type = -1;"
    }
]