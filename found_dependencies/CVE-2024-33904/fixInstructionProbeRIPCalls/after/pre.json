[
    {
        "line": 5,
        "fullcodeline": "uint64_t currentAddress = (uint64_t)m_pSource;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t lastAsmNewline = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "size_t      currentDestinationOffset = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "const auto RANDOMDIR = \"/tmp/hypr/\" + g_pTokenManager->getRandomUUID();"
    },
    {
        "line": 77,
        "fullcodeline": "std::filesystem::permissions(RANDOMDIR, std::filesystem::perms::owner_all, std::filesystem::perm_options::replace);"
    },
    {
        "line": 80,
        "fullcodeline": "ofs << assemblyBuilder;"
    },
    {
        "line": 82,
        "fullcodeline": "std::string ret = execAndGet(std::string{\"cc -x assembler -c \" + RANDOMDIR + \"/.hookcode.asm -o \" + RANDOMDIR + \"/.hookbinary.o 2>&1 && objcopy -O binary -j .text \" +"
    },
    {
        "line": 85,
        "fullcodeline": "Debug::log(LOG, \"[functionhook] assembler returned:\\n{}\", ret);"
    },
    {
        "line": 93,
        "fullcodeline": "returns = {std::vector<char>(std::istreambuf_iterator<char>(ifs), {})};"
    },
    {
        "line": 13,
        "fullcodeline": "std::string code = probe.assembly.substr(lastAsmNewline, probe.assembly.find(\"\\n\", lastAsmNewline) - lastAsmNewline);"
    },
    {
        "line": 68,
        "fullcodeline": "lastAsmNewline = probe.assembly.find(\"\\n\", lastAsmNewline) + 1;"
    },
    {
        "line": 69,
        "fullcodeline": "currentAddress += len;"
    },
    {
        "line": 74,
        "fullcodeline": "if (!std::filesystem::create_directory(RANDOMDIR))"
    },
    {
        "line": 86,
        "fullcodeline": "if (!std::filesystem::exists(RANDOMDIR + \"/.hookbinary2.o\")) {"
    },
    {
        "line": 14,
        "fullcodeline": "if (code.contains(\"%rip\")) {"
    },
    {
        "line": 15,
        "fullcodeline": "CVarList       tokens{code, 0, 's'};"
    },
    {
        "line": 16,
        "fullcodeline": "size_t         plusPresent  = tokens[1][0] == '+' ? 1 : 0;"
    },
    {
        "line": 17,
        "fullcodeline": "size_t         minusPresent = tokens[1][0] == '-' ? 1 : 0;"
    },
    {
        "line": 18,
        "fullcodeline": "std::string    addr         = tokens[1].substr((plusPresent || minusPresent), tokens[1].find(\"(%rip)\") - (plusPresent || minusPresent));"
    },
    {
        "line": 19,
        "fullcodeline": "const uint64_t OFFSET       = (minusPresent ? -1 : 1) * configStringToInt(addr);"
    },
    {
        "line": 22,
        "fullcodeline": "const uint64_t DESTINATION = currentAddress + OFFSET + len;"
    },
    {
        "line": 20,
        "fullcodeline": "if (OFFSET == 0)"
    },
    {
        "line": 24,
        "fullcodeline": "if (code.starts_with(\"call\")) {"
    },
    {
        "line": 26,
        "fullcodeline": "assemblyBuilder += std::format(\"pushq %rax\\nmovabs $0x{:x}, %rax\\ncallq *%rax\\npopq %rax\\n\", DESTINATION);"
    },
    {
        "line": 27,
        "fullcodeline": "currentDestinationOffset += 14;"
    },
    {
        "line": 46,
        "fullcodeline": "} else if (code.contains(\"invalid\")) {"
    },
    {
        "line": 47,
        "fullcodeline": "std::vector<uint8_t> bytes;"
    },
    {
        "line": 48,
        "fullcodeline": "bytes.resize(len);"
    },
    {
        "line": 49,
        "fullcodeline": "memcpy(bytes.data(), (std::byte*)currentAddress, len);"
    },
    {
        "line": 28,
        "fullcodeline": "} else if (code.starts_with(\"lea\")) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (len == 4 && bytes[0] == 0xF3 && bytes[1] == 0x0F && bytes[2] == 0x1E && bytes[3] == 0xFA) {"
    },
    {
        "line": 64,
        "fullcodeline": "assemblyBuilder += code + \"\\n\";"
    },
    {
        "line": 65,
        "fullcodeline": "currentDestinationOffset += len;"
    },
    {
        "line": 30,
        "fullcodeline": "assemblyBuilder += std::format(\"movabs $0x{:x}, {}\\n\", DESTINATION, tokens[2]);"
    },
    {
        "line": 31,
        "fullcodeline": "currentDestinationOffset += 10;"
    },
    {
        "line": 52,
        "fullcodeline": "assemblyBuilder += \"endbr64\\n\";"
    },
    {
        "line": 53,
        "fullcodeline": "currentDestinationOffset += 4;"
    },
    {
        "line": 33,
        "fullcodeline": "auto ADDREND   = code.find(\"(%rip)\");"
    },
    {
        "line": 34,
        "fullcodeline": "auto ADDRSTART = (code.substr(0, ADDREND).find_last_of(' '));"
    },
    {
        "line": 39,
        "fullcodeline": "const uint64_t PREDICTEDRIP = (uint64_t)m_pTrampolineAddr + currentDestinationOffset + len;"
    },
    {
        "line": 40,
        "fullcodeline": "const bool     POSITIVE     = DESTINATION > PREDICTEDRIP;"
    },
    {
        "line": 41,
        "fullcodeline": "const uint64_t NEWRIPOFFSET = POSITIVE ? DESTINATION - PREDICTEDRIP : PREDICTEDRIP - DESTINATION;"
    },
    {
        "line": 43,
        "fullcodeline": "assemblyBuilder += std::format(\"{} {}0x{:x}{}\\n\", code.substr(0, ADDRSTART), POSITIVE ? '+' : '-', NEWRIPOFFSET, code.substr(ADDREND));"
    },
    {
        "line": 44,
        "fullcodeline": "currentDestinationOffset += len;"
    },
    {
        "line": 60,
        "fullcodeline": "Debug::log(ERR, \"[functionhook] unknown bytes: {}\", strBytes);"
    },
    {
        "line": 36,
        "fullcodeline": "if (ADDREND == std::string::npos || ADDRSTART == std::string::npos)"
    },
    {
        "line": 58,
        "fullcodeline": "strBytes += std::format(\"{:x} \", b);"
    }
]