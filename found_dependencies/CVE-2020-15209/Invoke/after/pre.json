[
    {
        "line": 7,
        "fullcodeline": "TfLiteStatus status = kTfLiteOk;"
    },
    {
        "line": 2,
        "fullcodeline": "if (!consistent_) {"
    },
    {
        "line": 8,
        "fullcodeline": "if (state_ == kStateUninvokable) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (should_apply_nnapi_delegate_ && !applied_nnapi_delegate_) {"
    },
    {
        "line": 28,
        "fullcodeline": "execution_plan_index < execution_plan_.size(); execution_plan_index++) {"
    },
    {
        "line": 3,
        "fullcodeline": "ReportError(\"Invoke called on model that is not consistent.\");"
    },
    {
        "line": 18,
        "fullcodeline": "TF_LITE_ENSURE_OK(&context_, ModifyGraphWithDelegate(NnApiDelegate()));"
    },
    {
        "line": 27,
        "fullcodeline": "for (int execution_plan_index = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "int node_index = execution_plan_[execution_plan_index];"
    },
    {
        "line": 35,
        "fullcodeline": "TfLiteNode& node = nodes_and_registration_[node_index].first;"
    },
    {
        "line": 36,
        "fullcodeline": "const TfLiteRegistration& registration ="
    },
    {
        "line": 39,
        "fullcodeline": "const char* op_name = nullptr;"
    },
    {
        "line": 41,
        "fullcodeline": "TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);"
    },
    {
        "line": 79,
        "fullcodeline": "tensor_resized_since_op_invoke_ = false;"
    },
    {
        "line": 29,
        "fullcodeline": "if (execution_plan_index == next_execution_plan_index_to_prepare_) {"
    },
    {
        "line": 47,
        "fullcodeline": "for (int i = 0; i < node.inputs->size; ++i) {"
    },
    {
        "line": 11,
        "fullcodeline": "} else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {"
    },
    {
        "line": 31,
        "fullcodeline": "TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >="
    },
    {
        "line": 40,
        "fullcodeline": "if (profiler_) op_name = GetTFLiteOpName(registration);"
    },
    {
        "line": 48,
        "fullcodeline": "int tensor_index = node.inputs->data[i];"
    },
    {
        "line": 52,
        "fullcodeline": "TfLiteTensor* tensor = &tensors_[tensor_index];"
    },
    {
        "line": 72,
        "fullcodeline": "if (check_cancelled_func_ != nullptr &&"
    },
    {
        "line": 73,
        "fullcodeline": "check_cancelled_func_(cancellation_data_)) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (OpInvoke(registration, &node) != kTfLiteOk) {"
    },
    {
        "line": 88,
        "fullcodeline": "HasDynamicTensor(context_, node.outputs)) {"
    },
    {
        "line": 89,
        "fullcodeline": "next_execution_plan_index_to_prepare_ = execution_plan_index + 1;"
    },
    {
        "line": 49,
        "fullcodeline": "if (tensor_index == kTfLiteOptionalTensor) {"
    },
    {
        "line": 81,
        "fullcodeline": "return ReportOpError(&context_, node, registration, node_index,"
    },
    {
        "line": 94,
        "fullcodeline": "if (next_execution_plan_index_to_plan_allocation_ >"
    },
    {
        "line": 53,
        "fullcodeline": "if (tensor->delegate && tensor->delegate != node.delegate &&"
    },
    {
        "line": 57,
        "fullcodeline": "if (tensor->data.raw == nullptr && tensor->bytes > 0) {"
    },
    {
        "line": 96,
        "fullcodeline": "next_execution_plan_index_to_plan_allocation_ ="
    },
    {
        "line": 55,
        "fullcodeline": "TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));"
    },
    {
        "line": 58,
        "fullcodeline": "if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1) {"
    },
    {
        "line": 99,
        "fullcodeline": "TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter("
    },
    {
        "line": 100,
        "fullcodeline": "next_execution_plan_index_to_plan_allocation_ - 1));"
    }
]