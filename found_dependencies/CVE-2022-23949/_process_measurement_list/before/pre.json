[
    {
        "line": 3,
        "fullcodeline": "failure = Failure(Component.IMA)"
    },
    {
        "line": 4,
        "fullcodeline": "running_hash = agentAttestState.get_pcr_state(config.IMA_PCR, hash_alg)"
    },
    {
        "line": 5,
        "fullcodeline": "found_pcr = (pcrval is None)"
    },
    {
        "line": 6,
        "fullcodeline": "errors = {}"
    },
    {
        "line": 7,
        "fullcodeline": "pcrval_bytes = b''"
    },
    {
        "line": 20,
        "fullcodeline": "ima_log_hash_alg = Hash.SHA1"
    },
    {
        "line": 44,
        "fullcodeline": "ima_validator = ima_ast.Validator("
    },
    {
        "line": 8,
        "fullcodeline": "if pcrval is not None:"
    },
    {
        "line": 11,
        "fullcodeline": "if lists is not None:"
    },
    {
        "line": 21,
        "fullcodeline": "if allow_list is not None:"
    },
    {
        "line": 29,
        "fullcodeline": "if boot_aggregates and allow_list:"
    },
    {
        "line": 37,
        "fullcodeline": "is_valid, compiled_regex, err_msg = config.valid_exclude_list(exclude_list)"
    },
    {
        "line": 38,
        "fullcodeline": "if not is_valid:"
    },
    {
        "line": 56,
        "fullcodeline": "if not found_pcr and len(lines) <= 2:"
    },
    {
        "line": 59,
        "fullcodeline": "for linenum, line in enumerate(lines):"
    },
    {
        "line": 95,
        "fullcodeline": "if not found_pcr:"
    },
    {
        "line": 100,
        "fullcodeline": "if sum(errors.values()) > 0:"
    },
    {
        "line": 105,
        "fullcodeline": "return codecs.encode(running_hash, 'hex').decode('utf-8'), failure"
    },
    {
        "line": 9,
        "fullcodeline": "pcrval_bytes = codecs.decode(pcrval.encode('utf-8'), 'hex')"
    },
    {
        "line": 14,
        "fullcodeline": "allow_list = lists['allowlist']"
    },
    {
        "line": 15,
        "fullcodeline": "exclude_list = lists['exclude']"
    },
    {
        "line": 17,
        "fullcodeline": "allow_list = None"
    },
    {
        "line": 18,
        "fullcodeline": "exclude_list = None"
    },
    {
        "line": 41,
        "fullcodeline": "err_msg += \" Exclude list will be ignored.\""
    },
    {
        "line": 42,
        "fullcodeline": "logger.error(err_msg)"
    },
    {
        "line": 57,
        "fullcodeline": "found_pcr = (running_hash == pcrval_bytes)"
    },
    {
        "line": 96,
        "fullcodeline": "logger.error(f\"IMA measurement list does not match TPM PCR {pcrval}\")"
    },
    {
        "line": 97,
        "fullcodeline": "failure.add_event(\"pcr_mismatch\", f\"IMA measurement list does not match TPM PCR {pcrval}\", True)"
    },
    {
        "line": 101,
        "fullcodeline": "error_msg = \"IMA ERRORS: Some entries couldn't be validated. Number of failures in modes: \""
    },
    {
        "line": 102,
        "fullcodeline": "error_msg += \", \".join([f'{k.__name__ } {v}' for k, v in errors.items()])"
    },
    {
        "line": 103,
        "fullcodeline": "logger.error(error_msg + \".\")"
    },
    {
        "line": 12,
        "fullcodeline": "if isinstance(lists, str):"
    },
    {
        "line": 30,
        "fullcodeline": "if 'boot_aggregate' not in allow_list['hashes'] :"
    },
    {
        "line": 32,
        "fullcodeline": "for alg in boot_aggregates.keys() :"
    },
    {
        "line": 45,
        "fullcodeline": "{ima_ast.ImaSig: functools.partial(_validate_ima_sig, compiled_regex, ima_keyrings, allow_list),"
    },
    {
        "line": 60,
        "fullcodeline": "line = line.strip()"
    },
    {
        "line": 13,
        "fullcodeline": "lists = json.loads(lists)"
    },
    {
        "line": 23,
        "fullcodeline": "ima_log_hash_alg = Hash(allow_list[\"ima\"][\"log_hash_alg\"])"
    },
    {
        "line": 31,
        "fullcodeline": "allow_list['hashes']['boot_aggregate'] = []"
    },
    {
        "line": 46,
        "fullcodeline": "ima_ast.ImaNg: functools.partial(_validate_ima_ng, compiled_regex, allow_list),"
    },
    {
        "line": 47,
        "fullcodeline": "ima_ast.Ima: functools.partial(_validate_ima_ng, compiled_regex, allow_list),"
    },
    {
        "line": 48,
        "fullcodeline": "ima_ast.ImaBuf: functools.partial(_validate_ima_buf, compiled_regex, allow_list, ima_keyrings),"
    },
    {
        "line": 61,
        "fullcodeline": "if line == '':"
    },
    {
        "line": 65,
        "fullcodeline": "entry = ima_ast.Entry(line, ima_validator, ima_hash_alg=ima_log_hash_alg, pcr_hash_alg=hash_alg)"
    },
    {
        "line": 68,
        "fullcodeline": "running_hash = hash_alg.hash(running_hash + entry.pcr_template_hash)"
    },
    {
        "line": 70,
        "fullcodeline": "validation_failure = entry.invalid()"
    },
    {
        "line": 25,
        "fullcodeline": "logger.warning(\"Specified IMA log hash algorithm %s is not a valid algorithm! Defaulting to SHA1.\","
    },
    {
        "line": 33,
        "fullcodeline": "for val in boot_aggregates[alg] :"
    },
    {
        "line": 76,
        "fullcodeline": "if not found_pcr:"
    },
    {
        "line": 86,
        "fullcodeline": "if m2w is not None and (type(entry.mode) in [ima_ast.Ima, ima_ast.ImaNg, ima_ast.ImaSig]):"
    },
    {
        "line": 73,
        "fullcodeline": "failure.merge(validation_failure)"
    },
    {
        "line": 74,
        "fullcodeline": "errors[type(entry.mode)] = errors.get(type(entry.mode), 0) + 1"
    },
    {
        "line": 78,
        "fullcodeline": "found_pcr = (running_hash == pcrval_bytes)"
    },
    {
        "line": 87,
        "fullcodeline": "hash_value = codecs.encode(entry.mode.digest.bytes, \"hex\")"
    },
    {
        "line": 88,
        "fullcodeline": "path = entry.mode.path.name"
    },
    {
        "line": 89,
        "fullcodeline": "m2w.write(f\"{hash_value} {path}\\n\")"
    },
    {
        "line": 91,
        "fullcodeline": "failure.add_event(\"entry\", f\"Line was not parsable into a valid IMA entry: {line}\", True, [\"parser\"])"
    },
    {
        "line": 92,
        "fullcodeline": "logger.error(f\"Line was not parsable into a valid IMA entry: {line}\")"
    },
    {
        "line": 34,
        "fullcodeline": "if val not in allow_list['hashes']['boot_aggregate'] :"
    },
    {
        "line": 80,
        "fullcodeline": "logger.debug('Found match at linenum %s' % (linenum + 1))"
    },
    {
        "line": 83,
        "fullcodeline": "agentAttestState.update_ima_attestation(int(entry.pcr), running_hash, linenum + 1)"
    },
    {
        "line": 35,
        "fullcodeline": "allow_list['hashes']['boot_aggregate'].append(val)"
    }
]