[
    {
        "line": 4,
        "fullcodeline": "struct net *net = dev_net(skb->dev);"
    },
    {
        "line": 5,
        "fullcodeline": "struct inet6_dev *idev = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "struct ipv6hdr *hdr = ipv6_hdr(skb);"
    },
    {
        "line": 9,
        "fullcodeline": "const struct in6_addr *saddr = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "struct sockcm_cookie sockc_unused = {0};"
    },
    {
        "line": 16,
        "fullcodeline": "int iif = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "int addr_type = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "u32 mark = IP6_REPLY_MARK(net, skb->mark);"
    },
    {
        "line": 32,
        "fullcodeline": "addr_type = ipv6_addr_type(&hdr->daddr);"
    },
    {
        "line": 52,
        "fullcodeline": "addr_type = ipv6_addr_type(&hdr->saddr);"
    },
    {
        "line": 84,
        "fullcodeline": "mip6_addr_swap(skb);"
    },
    {
        "line": 86,
        "fullcodeline": "memset(&fl6, 0, sizeof(fl6));"
    },
    {
        "line": 87,
        "fullcodeline": "fl6.flowi6_proto = IPPROTO_ICMPV6;"
    },
    {
        "line": 88,
        "fullcodeline": "fl6.daddr = hdr->saddr;"
    },
    {
        "line": 93,
        "fullcodeline": "fl6.flowi6_mark = mark;"
    },
    {
        "line": 94,
        "fullcodeline": "fl6.flowi6_oif = iif;"
    },
    {
        "line": 95,
        "fullcodeline": "fl6.fl6_icmp_type = type;"
    },
    {
        "line": 96,
        "fullcodeline": "fl6.fl6_icmp_code = code;"
    },
    {
        "line": 97,
        "fullcodeline": "security_skb_classify_flow(skb, flowi6_to_flowi(&fl6));"
    },
    {
        "line": 99,
        "fullcodeline": "sk = icmpv6_xmit_lock(net);"
    },
    {
        "line": 102,
        "fullcodeline": "sk->sk_mark = mark;"
    },
    {
        "line": 103,
        "fullcodeline": "np = inet6_sk(sk);"
    },
    {
        "line": 108,
        "fullcodeline": "tmp_hdr.icmp6_type = type;"
    },
    {
        "line": 109,
        "fullcodeline": "tmp_hdr.icmp6_code = code;"
    },
    {
        "line": 110,
        "fullcodeline": "tmp_hdr.icmp6_cksum = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "tmp_hdr.icmp6_pointer = htonl(info);"
    },
    {
        "line": 118,
        "fullcodeline": "ipc6.tclass = np->tclass;"
    },
    {
        "line": 119,
        "fullcodeline": "fl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);"
    },
    {
        "line": 121,
        "fullcodeline": "dst = icmpv6_route_lookup(net, skb, sk, &fl6);"
    },
    {
        "line": 125,
        "fullcodeline": "ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);"
    },
    {
        "line": 126,
        "fullcodeline": "ipc6.dontfrag = np->dontfrag;"
    },
    {
        "line": 127,
        "fullcodeline": "ipc6.opt = NULL;"
    },
    {
        "line": 129,
        "fullcodeline": "msg.skb = skb;"
    },
    {
        "line": 130,
        "fullcodeline": "msg.offset = skb_network_offset(skb);"
    },
    {
        "line": 131,
        "fullcodeline": "msg.type = type;"
    },
    {
        "line": 133,
        "fullcodeline": "len = skb->len - msg.offset;"
    },
    {
        "line": 141,
        "fullcodeline": "rcu_read_lock();"
    },
    {
        "line": 142,
        "fullcodeline": "idev = __in6_dev_get(skb->dev);"
    },
    {
        "line": 144,
        "fullcodeline": "err = ip6_append_data(sk, icmpv6_getfrag, &msg,"
    },
    {
        "line": 156,
        "fullcodeline": "rcu_read_unlock();"
    },
    {
        "line": 158,
        "fullcodeline": "dst_release(dst);"
    },
    {
        "line": 160,
        "fullcodeline": "icmpv6_xmit_unlock(sk);"
    },
    {
        "line": 22,
        "fullcodeline": "if ((u8 *)hdr < skb->head ||"
    },
    {
        "line": 34,
        "fullcodeline": "if (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||"
    },
    {
        "line": 42,
        "fullcodeline": "if (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (__ipv6_addr_needs_scope_id(addr_type))"
    },
    {
        "line": 69,
        "fullcodeline": "if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (is_ineligible(skb)) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (!sk)"
    },
    {
        "line": 105,
        "fullcodeline": "if (!icmpv6_xrlim_allow(sk, type, &fl6))"
    },
    {
        "line": 113,
        "fullcodeline": "if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))"
    },
    {
        "line": 122,
        "fullcodeline": "if (IS_ERR(dst))"
    },
    {
        "line": 135,
        "fullcodeline": "if (len < 0) {"
    },
    {
        "line": 23,
        "fullcodeline": "(skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))"
    },
    {
        "line": 35,
        "fullcodeline": "ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))"
    },
    {
        "line": 36,
        "fullcodeline": "saddr = &hdr->daddr;"
    },
    {
        "line": 49,
        "fullcodeline": "saddr = NULL;"
    },
    {
        "line": 70,
        "fullcodeline": "net_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\","
    },
    {
        "line": 79,
        "fullcodeline": "net_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\","
    },
    {
        "line": 90,
        "fullcodeline": "saddr = force_saddr;"
    },
    {
        "line": 114,
        "fullcodeline": "fl6.flowi6_oif = np->mcast_oif;"
    },
    {
        "line": 136,
        "fullcodeline": "net_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\","
    },
    {
        "line": 145,
        "fullcodeline": "len + sizeof(struct icmp6hdr),"
    },
    {
        "line": 147,
        "fullcodeline": "&ipc6, &fl6, (struct rt6_info *)dst,"
    },
    {
        "line": 150,
        "fullcodeline": "ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);"
    },
    {
        "line": 151,
        "fullcodeline": "ip6_flush_pending_frames(sk);"
    },
    {
        "line": 43,
        "fullcodeline": "if (type != ICMPV6_PKT_TOOBIG &&"
    },
    {
        "line": 61,
        "fullcodeline": "iif = l3mdev_master_ifindex(skb_dst(skb)->dev);"
    },
    {
        "line": 153,
        "fullcodeline": "err = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,"
    },
    {
        "line": 44,
        "fullcodeline": "!(type == ICMPV6_PARAMPROB &&"
    },
    {
        "line": 115,
        "fullcodeline": "else if (!fl6.flowi6_oif)"
    },
    {
        "line": 116,
        "fullcodeline": "fl6.flowi6_oif = np->ucast_oif;"
    },
    {
        "line": 154,
        "fullcodeline": "len + sizeof(struct icmp6hdr));"
    },
    {
        "line": 46,
        "fullcodeline": "(opt_unrec(skb, info))))"
    },
    {
        "line": 45,
        "fullcodeline": "code == ICMPV6_UNK_OPTION &&"
    }
]