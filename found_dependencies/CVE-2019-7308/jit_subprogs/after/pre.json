[
    {
        "line": 3,
        "fullcodeline": "struct bpf_prog *prog = env->prog, **func, *tmp;"
    },
    {
        "line": 4,
        "fullcodeline": "int i, j, subprog_start, subprog_end = 0, len, subprog;"
    },
    {
        "line": 38,
        "fullcodeline": "err = bpf_prog_alloc_jited_linfo(prog);"
    },
    {
        "line": 42,
        "fullcodeline": "err = -ENOMEM;"
    },
    {
        "line": 43,
        "fullcodeline": "func = kcalloc(env->subprog_cnt, sizeof(prog), GFP_KERNEL);"
    },
    {
        "line": 146,
        "fullcodeline": "prog->jited = 1;"
    },
    {
        "line": 147,
        "fullcodeline": "prog->bpf_func = func[0]->bpf_func;"
    },
    {
        "line": 159,
        "fullcodeline": "prog->jit_requested = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "if (env->subprog_cnt <= 1)"
    },
    {
        "line": 12,
        "fullcodeline": "for (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (!func)"
    },
    {
        "line": 47,
        "fullcodeline": "for (i = 0; i < env->subprog_cnt; i++) {"
    },
    {
        "line": 88,
        "fullcodeline": "for (i = 0; i < env->subprog_cnt; i++) {"
    },
    {
        "line": 114,
        "fullcodeline": "for (i = 0; i < env->subprog_cnt; i++) {"
    },
    {
        "line": 128,
        "fullcodeline": "for (i = 0; i < env->subprog_cnt; i++) {"
    },
    {
        "line": 137,
        "fullcodeline": "for (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {"
    },
    {
        "line": 153,
        "fullcodeline": "for (i = 0; i < env->subprog_cnt; i++)"
    },
    {
        "line": 160,
        "fullcodeline": "for (i = 0, insn = prog->insnsi; i < prog->len; i++, insn++) {"
    },
    {
        "line": 20,
        "fullcodeline": "subprog = find_subprog(env, i + insn->imm + 1);"
    },
    {
        "line": 29,
        "fullcodeline": "insn->off = subprog;"
    },
    {
        "line": 35,
        "fullcodeline": "insn->imm = 1;"
    },
    {
        "line": 48,
        "fullcodeline": "subprog_start = subprog_end;"
    },
    {
        "line": 49,
        "fullcodeline": "subprog_end = env->subprog_info[i + 1].start;"
    },
    {
        "line": 51,
        "fullcodeline": "len = subprog_end - subprog_start;"
    },
    {
        "line": 52,
        "fullcodeline": "func[i] = bpf_prog_alloc(bpf_prog_size(len), GFP_USER);"
    },
    {
        "line": 55,
        "fullcodeline": "memcpy(func[i]->insnsi, &prog->insnsi[subprog_start],"
    },
    {
        "line": 57,
        "fullcodeline": "func[i]->type = prog->type;"
    },
    {
        "line": 58,
        "fullcodeline": "func[i]->len = len;"
    },
    {
        "line": 61,
        "fullcodeline": "func[i]->is_func = 1;"
    },
    {
        "line": 72,
        "fullcodeline": "func[i]->jit_requested = 1;"
    },
    {
        "line": 77,
        "fullcodeline": "func[i] = bpf_int_jit_compile(func[i]);"
    },
    {
        "line": 89,
        "fullcodeline": "insn = func[i]->insnsi;"
    },
    {
        "line": 115,
        "fullcodeline": "old_bpf_func = func[i]->bpf_func;"
    },
    {
        "line": 116,
        "fullcodeline": "tmp = bpf_int_jit_compile(func[i]);"
    },
    {
        "line": 129,
        "fullcodeline": "bpf_prog_lock_ro(func[i]);"
    },
    {
        "line": 130,
        "fullcodeline": "bpf_prog_kallsyms_add(func[i]);"
    },
    {
        "line": 141,
        "fullcodeline": "insn->off = env->insn_aux_data[i].call_imm;"
    },
    {
        "line": 142,
        "fullcodeline": "subprog = find_subprog(env, i + insn->off + 1);"
    },
    {
        "line": 143,
        "fullcodeline": "insn->imm = subprog;"
    },
    {
        "line": 164,
        "fullcodeline": "insn->off = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "insn->imm = env->insn_aux_data[i].call_imm;"
    },
    {
        "line": 13,
        "fullcodeline": "if (insn->code != (BPF_JMP | BPF_CALL) ||"
    },
    {
        "line": 21,
        "fullcodeline": "if (subprog < 0) {"
    },
    {
        "line": 53,
        "fullcodeline": "if (!func[i])"
    },
    {
        "line": 56,
        "fullcodeline": "len * sizeof(struct bpf_insn));"
    },
    {
        "line": 59,
        "fullcodeline": "if (bpf_prog_calc_tag(func[i]))"
    },
    {
        "line": 78,
        "fullcodeline": "if (!func[i]->jited) {"
    },
    {
        "line": 90,
        "fullcodeline": "for (j = 0; j < func[i]->len; j++, insn++) {"
    },
    {
        "line": 155,
        "fullcodeline": "bpf_jit_free(func[i]);"
    },
    {
        "line": 14,
        "fullcodeline": "insn->src_reg != BPF_PSEUDO_CALL)"
    },
    {
        "line": 79,
        "fullcodeline": "err = -ENOTSUPP;"
    },
    {
        "line": 95,
        "fullcodeline": "insn->imm = (u64 (*)(u64, u64, u64, u64, u64))"
    },
    {
        "line": 117,
        "fullcodeline": "if (tmp != func[i] || func[i]->bpf_func != old_bpf_func) {"
    },
    {
        "line": 118,
        "fullcodeline": "verbose(env, \"JIT doesn't support bpf-to-bpf calls\\n\");"
    },
    {
        "line": 119,
        "fullcodeline": "err = -ENOTSUPP;"
    },
    {
        "line": 138,
        "fullcodeline": "if (insn->code != (BPF_JMP | BPF_CALL) ||"
    },
    {
        "line": 139,
        "fullcodeline": "insn->src_reg != BPF_PSEUDO_CALL)"
    },
    {
        "line": 161,
        "fullcodeline": "if (insn->code != (BPF_JMP | BPF_CALL) ||"
    },
    {
        "line": 162,
        "fullcodeline": "insn->src_reg != BPF_PSEUDO_CALL)"
    },
    {
        "line": 24,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 91,
        "fullcodeline": "if (insn->code != (BPF_JMP | BPF_CALL) ||"
    },
    {
        "line": 92,
        "fullcodeline": "insn->src_reg != BPF_PSEUDO_CALL)"
    }
]