[
    {
        "line": 7,
        "fullcodeline": "int insn_processed = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "bool do_print_state = false;"
    },
    {
        "line": 10,
        "fullcodeline": "env->prev_linfo = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "state = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);"
    },
    {
        "line": 15,
        "fullcodeline": "state->curframe = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "state->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);"
    },
    {
        "line": 21,
        "fullcodeline": "env->cur_state = state;"
    },
    {
        "line": 22,
        "fullcodeline": "init_func_state(env, state->frame[0],"
    },
    {
        "line": 330,
        "fullcodeline": "verbose(env, \"processed %d insns (limit %d), stack depth \","
    },
    {
        "line": 339,
        "fullcodeline": "verbose(env, \"\\n\");"
    },
    {
        "line": 13,
        "fullcodeline": "if (!state)"
    },
    {
        "line": 17,
        "fullcodeline": "if (!state->frame[0]) {"
    },
    {
        "line": 332,
        "fullcodeline": "for (i = 0; i < env->subprog_cnt; i++) {"
    },
    {
        "line": 18,
        "fullcodeline": "kfree(state);"
    },
    {
        "line": 38,
        "fullcodeline": "insn = &insns[env->insn_idx];"
    },
    {
        "line": 39,
        "fullcodeline": "class = BPF_CLASS(insn->code);"
    },
    {
        "line": 48,
        "fullcodeline": "err = is_state_visited(env, env->insn_idx);"
    },
    {
        "line": 97,
        "fullcodeline": "regs = cur_regs(env);"
    },
    {
        "line": 98,
        "fullcodeline": "env->insn_aux_data[env->insn_idx].seen = true;"
    },
    {
        "line": 327,
        "fullcodeline": "env->insn_idx++;"
    },
    {
        "line": 335,
        "fullcodeline": "verbose(env, \"%d\", depth);"
    },
    {
        "line": 14,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 19,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 32,
        "fullcodeline": "if (env->insn_idx >= insn_cnt) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 51,
        "fullcodeline": "if (err == 1) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (signal_pending(current))"
    },
    {
        "line": 66,
        "fullcodeline": "if (need_resched())"
    },
    {
        "line": 69,
        "fullcodeline": "if (env->log.level > 1 || (env->log.level && do_print_state)) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (class == BPF_ALU || class == BPF_ALU64) {"
    },
    {
        "line": 336,
        "fullcodeline": "if (i + 1 < env->subprog_cnt)"
    },
    {
        "line": 33,
        "fullcodeline": "verbose(env, \"invalid insn idx %d insn_cnt %d\\n\","
    },
    {
        "line": 42,
        "fullcodeline": "verbose(env,"
    },
    {
        "line": 67,
        "fullcodeline": "cond_resched();"
    },
    {
        "line": 75,
        "fullcodeline": "print_verifier_state(env, state->frame[state->curframe]);"
    },
    {
        "line": 76,
        "fullcodeline": "do_print_state = false;"
    },
    {
        "line": 80,
        "fullcodeline": "const struct bpf_insn_cbs cbs = {"
    },
    {
        "line": 85,
        "fullcodeline": "verbose_linfo(env, env->insn_idx, \"; \");"
    },
    {
        "line": 86,
        "fullcodeline": "verbose(env, \"%d: \", env->insn_idx);"
    },
    {
        "line": 87,
        "fullcodeline": "print_bpf_insn(&cbs, insn, env->allow_ptr_leaks);"
    },
    {
        "line": 91,
        "fullcodeline": "err = bpf_prog_offload_verify_insn(env, env->insn_idx,"
    },
    {
        "line": 101,
        "fullcodeline": "err = check_alu_op(env, insn);"
    },
    {
        "line": 337,
        "fullcodeline": "verbose(env, \"+\");"
    },
    {
        "line": 35,
        "fullcodeline": "return -EFAULT;"
    },
    {
        "line": 45,
        "fullcodeline": "return -E2BIG;"
    },
    {
        "line": 64,
        "fullcodeline": "return -EAGAIN;"
    },
    {
        "line": 70,
        "fullcodeline": "if (env->log.level > 1)"
    },
    {
        "line": 71,
        "fullcodeline": "verbose(env, \"%d:\", env->insn_idx);"
    },
    {
        "line": 105,
        "fullcodeline": "} else if (class == BPF_LDX) {"
    },
    {
        "line": 73,
        "fullcodeline": "verbose(env, \"\\nfrom %d to %d:\","
    },
    {
        "line": 81,
        "fullcodeline": ".cb_print\t= verbose,"
    },
    {
        "line": 82,
        "fullcodeline": ".private_data\t= env,"
    },
    {
        "line": 111,
        "fullcodeline": "err = check_reg_arg(env, insn->src_reg, SRC_OP);"
    },
    {
        "line": 115,
        "fullcodeline": "err = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);"
    },
    {
        "line": 124,
        "fullcodeline": "err = check_mem_access(env, env->insn_idx, insn->src_reg,"
    },
    {
        "line": 55,
        "fullcodeline": "verbose(env, \"\\nfrom %d to %d: safe\\n\","
    },
    {
        "line": 132,
        "fullcodeline": "if (*prev_src_type == NOT_INIT) {"
    },
    {
        "line": 58,
        "fullcodeline": "verbose(env, \"%d: safe\\n\", env->insn_idx);"
    },
    {
        "line": 125,
        "fullcodeline": "insn->off, BPF_SIZE(insn->code),"
    },
    {
        "line": 137,
        "fullcodeline": "*prev_src_type = src_reg_type;"
    },
    {
        "line": 151,
        "fullcodeline": "} else if (class == BPF_STX) {"
    },
    {
        "line": 163,
        "fullcodeline": "err = check_reg_arg(env, insn->src_reg, SRC_OP);"
    },
    {
        "line": 167,
        "fullcodeline": "err = check_reg_arg(env, insn->dst_reg, SRC_OP);"
    },
    {
        "line": 174,
        "fullcodeline": "err = check_mem_access(env, env->insn_idx, insn->dst_reg,"
    },
    {
        "line": 139,
        "fullcodeline": "} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (BPF_MODE(insn->code) == BPF_XADD) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (*prev_dst_type == NOT_INIT) {"
    },
    {
        "line": 147,
        "fullcodeline": "verbose(env, \"same insn cannot be used with different pointers\\n\");"
    },
    {
        "line": 155,
        "fullcodeline": "err = check_xadd(env, env->insn_idx, insn);"
    },
    {
        "line": 158,
        "fullcodeline": "env->insn_idx++;"
    },
    {
        "line": 175,
        "fullcodeline": "insn->off, BPF_SIZE(insn->code),"
    },
    {
        "line": 183,
        "fullcodeline": "*prev_dst_type = dst_reg_type;"
    },
    {
        "line": 189,
        "fullcodeline": "} else if (class == BPF_ST) {"
    },
    {
        "line": 148,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 196,
        "fullcodeline": "err = check_reg_arg(env, insn->dst_reg, SRC_OP);"
    },
    {
        "line": 208,
        "fullcodeline": "err = check_mem_access(env, env->insn_idx, insn->dst_reg,"
    },
    {
        "line": 184,
        "fullcodeline": "} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (BPF_MODE(insn->code) != BPF_MEM ||"
    },
    {
        "line": 200,
        "fullcodeline": "if (is_ctx_reg(env, insn->dst_reg)) {"
    },
    {
        "line": 185,
        "fullcodeline": "verbose(env, \"same insn cannot be used with different pointers\\n\");"
    },
    {
        "line": 191,
        "fullcodeline": "insn->src_reg != BPF_REG_0) {"
    },
    {
        "line": 192,
        "fullcodeline": "verbose(env, \"BPF_ST uses reserved fields\\n\");"
    },
    {
        "line": 201,
        "fullcodeline": "verbose(env, \"BPF_ST stores into R%d %s is not allowed\\n\","
    },
    {
        "line": 209,
        "fullcodeline": "insn->off, BPF_SIZE(insn->code),"
    },
    {
        "line": 210,
        "fullcodeline": "BPF_WRITE, -1, false);"
    },
    {
        "line": 214,
        "fullcodeline": "} else if (class == BPF_JMP) {"
    },
    {
        "line": 186,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 193,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 204,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 215,
        "fullcodeline": "u8 opcode = BPF_OP(insn->code);"
    },
    {
        "line": 217,
        "fullcodeline": "if (opcode == BPF_CALL) {"
    },
    {
        "line": 203,
        "fullcodeline": "reg_type_str[reg_state(env, insn->dst_reg)->type]);"
    },
    {
        "line": 303,
        "fullcodeline": "} else if (class == BPF_LD) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (BPF_SRC(insn->code) != BPF_K ||"
    },
    {
        "line": 227,
        "fullcodeline": "if (insn->src_reg == BPF_PSEUDO_CALL)"
    },
    {
        "line": 304,
        "fullcodeline": "u8 mode = BPF_MODE(insn->code);"
    },
    {
        "line": 222,
        "fullcodeline": "insn->dst_reg != BPF_REG_0) {"
    },
    {
        "line": 223,
        "fullcodeline": "verbose(env, \"BPF_CALL uses reserved fields\\n\");"
    },
    {
        "line": 228,
        "fullcodeline": "err = check_func_call(env, insn, &env->insn_idx);"
    },
    {
        "line": 234,
        "fullcodeline": "} else if (opcode == BPF_JA) {"
    },
    {
        "line": 306,
        "fullcodeline": "if (mode == BPF_ABS || mode == BPF_IND) {"
    },
    {
        "line": 323,
        "fullcodeline": "verbose(env, \"unknown insn class %d\\n\", class);"
    },
    {
        "line": 220,
        "fullcodeline": "(insn->src_reg != BPF_REG_0 &&"
    },
    {
        "line": 224,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 230,
        "fullcodeline": "err = check_helper_call(env, insn->imm, env->insn_idx);"
    },
    {
        "line": 243,
        "fullcodeline": "env->insn_idx += insn->off + 1;"
    },
    {
        "line": 307,
        "fullcodeline": "err = check_ld_abs(env, insn);"
    },
    {
        "line": 324,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 219,
        "fullcodeline": "insn->off != 0 ||"
    },
    {
        "line": 221,
        "fullcodeline": "insn->src_reg != BPF_PSEUDO_CALL) ||"
    },
    {
        "line": 235,
        "fullcodeline": "if (BPF_SRC(insn->code) != BPF_K ||"
    },
    {
        "line": 238,
        "fullcodeline": "insn->dst_reg != BPF_REG_0) {"
    },
    {
        "line": 239,
        "fullcodeline": "verbose(env, \"BPF_JA uses reserved fields\\n\");"
    },
    {
        "line": 246,
        "fullcodeline": "} else if (opcode == BPF_EXIT) {"
    },
    {
        "line": 311,
        "fullcodeline": "} else if (mode == BPF_IMM) {"
    },
    {
        "line": 237,
        "fullcodeline": "insn->src_reg != BPF_REG_0 ||"
    },
    {
        "line": 240,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 265,
        "fullcodeline": "err = check_reference_leak(env);"
    },
    {
        "line": 275,
        "fullcodeline": "err = check_reg_arg(env, BPF_REG_0, SRC_OP);"
    },
    {
        "line": 284,
        "fullcodeline": "err = check_return_code(env);"
    },
    {
        "line": 288,
        "fullcodeline": "err = pop_stack(env, &env->prev_insn_idx,"
    },
    {
        "line": 312,
        "fullcodeline": "err = check_ld_imm(env, insn);"
    },
    {
        "line": 316,
        "fullcodeline": "env->insn_idx++;"
    },
    {
        "line": 317,
        "fullcodeline": "env->insn_aux_data[env->insn_idx].seen = true;"
    },
    {
        "line": 236,
        "fullcodeline": "insn->imm != 0 ||"
    },
    {
        "line": 247,
        "fullcodeline": "if (BPF_SRC(insn->code) != BPF_K ||"
    },
    {
        "line": 279,
        "fullcodeline": "if (is_pointer_value(env, BPF_REG_0)) {"
    },
    {
        "line": 290,
        "fullcodeline": "if (err < 0) {"
    },
    {
        "line": 299,
        "fullcodeline": "err = check_cond_jmp_op(env, insn, &env->insn_idx);"
    },
    {
        "line": 319,
        "fullcodeline": "verbose(env, \"invalid BPF_LD mode\\n\");"
    },
    {
        "line": 250,
        "fullcodeline": "insn->dst_reg != BPF_REG_0) {"
    },
    {
        "line": 251,
        "fullcodeline": "verbose(env, \"BPF_EXIT uses reserved fields\\n\");"
    },
    {
        "line": 257,
        "fullcodeline": "env->prev_insn_idx = env->insn_idx;"
    },
    {
        "line": 258,
        "fullcodeline": "err = prepare_func_exit(env, &env->insn_idx);"
    },
    {
        "line": 261,
        "fullcodeline": "do_print_state = true;"
    },
    {
        "line": 280,
        "fullcodeline": "verbose(env, \"R0 leaks addr as return value\\n\");"
    },
    {
        "line": 320,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 249,
        "fullcodeline": "insn->src_reg != BPF_REG_0 ||"
    },
    {
        "line": 252,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 281,
        "fullcodeline": "return -EACCES;"
    },
    {
        "line": 291,
        "fullcodeline": "if (err != -ENOENT)"
    },
    {
        "line": 295,
        "fullcodeline": "do_print_state = true;"
    },
    {
        "line": 248,
        "fullcodeline": "insn->imm != 0 ||"
    }
]