[
    {
        "line": 4,
        "fullcodeline": "struct sctp_transport *transport = (struct sctp_transport *) peer;"
    },
    {
        "line": 5,
        "fullcodeline": "struct sctp_association *asoc = transport->asoc;"
    },
    {
        "line": 7,
        "fullcodeline": "struct net *net = sock_net(sk);"
    },
    {
        "line": 11,
        "fullcodeline": "bh_lock_sock(sk);"
    },
    {
        "line": 28,
        "fullcodeline": "error = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,"
    },
    {
        "line": 38,
        "fullcodeline": "bh_unlock_sock(sk);"
    },
    {
        "line": 39,
        "fullcodeline": "sctp_transport_put(transport);"
    },
    {
        "line": 12,
        "fullcodeline": "if (sock_owned_by_user(sk)) {"
    },
    {
        "line": 13,
        "fullcodeline": "pr_debug(\"%s: sock is busy\\n\", __func__);"
    },
    {
        "line": 29,
        "fullcodeline": "SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),"
    },
    {
        "line": 35,
        "fullcodeline": "sk->sk_err = -error;"
    },
    {
        "line": 16,
        "fullcodeline": "if (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))"
    },
    {
        "line": 17,
        "fullcodeline": "sctp_transport_hold(transport);"
    }
]