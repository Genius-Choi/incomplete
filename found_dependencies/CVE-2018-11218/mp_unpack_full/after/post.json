[
    {
        "line": 6,
        "fullcodeline": "int decode_all = (!limit && !offset);"
    },
    {
        "line": 8,
        "fullcodeline": "s = luaL_checklstring(L,1,&len); /* if no match, exits */"
    },
    {
        "line": 20,
        "fullcodeline": "mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);"
    },
    {
        "line": 10,
        "fullcodeline": "if (offset < 0 || limit < 0) /* requesting negative off or lim is invalid */"
    },
    {
        "line": 24,
        "fullcodeline": "for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (!decode_all) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (decode_all) limit = INT_MAX;"
    },
    {
        "line": 25,
        "fullcodeline": "mp_decode_to_lua_type(L,&c);"
    },
    {
        "line": 38,
        "fullcodeline": "int offset = len - c.left;"
    },
    {
        "line": 40,
        "fullcodeline": "luaL_checkstack(L, 1, \"in function mp_unpack_full\");"
    },
    {
        "line": 43,
        "fullcodeline": "lua_pushinteger(L, c.left == 0 ? -1 : offset);"
    },
    {
        "line": 50,
        "fullcodeline": "lua_insert(L, 2);"
    },
    {
        "line": 51,
        "fullcodeline": "cnt += 1; /* increase return count by one to make room for offset */"
    },
    {
        "line": 11,
        "fullcodeline": "return luaL_error(L,"
    },
    {
        "line": 27,
        "fullcodeline": "if (c.err == MP_CUR_ERROR_EOF) {"
    },
    {
        "line": 14,
        "fullcodeline": "else if (offset > len)"
    },
    {
        "line": 28,
        "fullcodeline": "return luaL_error(L,\"Missing bytes in input.\");"
    },
    {
        "line": 15,
        "fullcodeline": "return luaL_error(L,"
    },
    {
        "line": 29,
        "fullcodeline": "} else if (c.err == MP_CUR_ERROR_BADFMT) {"
    },
    {
        "line": 30,
        "fullcodeline": "return luaL_error(L,\"Bad data format in input.\");"
    }
]