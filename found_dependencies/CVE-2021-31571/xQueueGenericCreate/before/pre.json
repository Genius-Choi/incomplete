[
    {
        "line": 9,
        "fullcodeline": "configASSERT( uxQueueLength > ( UBaseType_t ) 0 );"
    },
    {
        "line": 14,
        "fullcodeline": "xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */"
    },
    {
        "line": 17,
        "fullcodeline": "configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );"
    },
    {
        "line": 28,
        "fullcodeline": "pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */"
    },
    {
        "line": 30,
        "fullcodeline": "if( pxNewQueue != NULL )"
    },
    {
        "line": 34,
        "fullcodeline": "pucQueueStorage = ( uint8_t * ) pxNewQueue;"
    },
    {
        "line": 35,
        "fullcodeline": "pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */"
    },
    {
        "line": 46,
        "fullcodeline": "prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );"
    },
    {
        "line": 50,
        "fullcodeline": "traceQUEUE_CREATE_FAILED( ucQueueType );"
    },
    {
        "line": 51,
        "fullcodeline": "mtCOVERAGE_TEST_MARKER();"
    }
]