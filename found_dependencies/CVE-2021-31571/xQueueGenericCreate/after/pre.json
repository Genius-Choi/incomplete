[
    {
        "line": 9,
        "fullcodeline": "configASSERT( uxQueueLength > ( UBaseType_t ) 0 );"
    },
    {
        "line": 14,
        "fullcodeline": "xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */"
    },
    {
        "line": 17,
        "fullcodeline": "configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );"
    },
    {
        "line": 20,
        "fullcodeline": "configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );"
    },
    {
        "line": 31,
        "fullcodeline": "pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */"
    },
    {
        "line": 33,
        "fullcodeline": "if( pxNewQueue != NULL )"
    },
    {
        "line": 37,
        "fullcodeline": "pucQueueStorage = ( uint8_t * ) pxNewQueue;"
    },
    {
        "line": 38,
        "fullcodeline": "pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */"
    },
    {
        "line": 49,
        "fullcodeline": "prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );"
    },
    {
        "line": 53,
        "fullcodeline": "traceQUEUE_CREATE_FAILED( ucQueueType );"
    },
    {
        "line": 54,
        "fullcodeline": "mtCOVERAGE_TEST_MARKER();"
    }
]