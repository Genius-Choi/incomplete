[
    {
        "line": 7,
        "fullcodeline": "char_u  *orig_cmd = eap->cmd;"
    },
    {
        "line": 8,
        "fullcodeline": "char_u  *cmd_start = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t    did_plus_cmd = FALSE;"
    },
    {
        "line": 11,
        "fullcodeline": "int\t    starts_with_colon = FALSE;"
    },
    {
        "line": 12,
        "fullcodeline": "int\t    vim9script = in_vim9script();"
    },
    {
        "line": 13,
        "fullcodeline": "int\t    has_visual_range = FALSE;"
    },
    {
        "line": 15,
        "fullcodeline": "CLEAR_POINTER(cmod);"
    },
    {
        "line": 16,
        "fullcodeline": "cmod->cmod_flags = sticky_cmdmod_flags;"
    },
    {
        "line": 18,
        "fullcodeline": "if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)"
    },
    {
        "line": 23,
        "fullcodeline": "eap->cmd += 5;"
    },
    {
        "line": 24,
        "fullcodeline": "cmd_start = eap->cmd;"
    },
    {
        "line": 25,
        "fullcodeline": "has_visual_range = TRUE;"
    },
    {
        "line": 75,
        "fullcodeline": "p = skip_range(eap->cmd, TRUE, NULL);"
    },
    {
        "line": 31,
        "fullcodeline": "while (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')"
    },
    {
        "line": 39,
        "fullcodeline": "if (*eap->cmd == NUL && exmode_active"
    },
    {
        "line": 51,
        "fullcodeline": "if (comment_start(eap->cmd, starts_with_colon))"
    },
    {
        "line": 64,
        "fullcodeline": "if (*eap->cmd == NUL)"
    },
    {
        "line": 326,
        "fullcodeline": "if (eap->cmd > cmd_start)"
    },
    {
        "line": 35,
        "fullcodeline": "++eap->cmd;"
    },
    {
        "line": 42,
        "fullcodeline": "&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)"
    },
    {
        "line": 44,
        "fullcodeline": "eap->cmd = (char_u *)\"+\";"
    },
    {
        "line": 45,
        "fullcodeline": "did_plus_cmd = TRUE;"
    },
    {
        "line": 91,
        "fullcodeline": "n = skipwhite(s);"
    },
    {
        "line": 102,
        "fullcodeline": "cmod->cmod_split |= WSP_ABOVE;"
    },
    {
        "line": 119,
        "fullcodeline": "cmod->cmod_split |= WSP_BOT;"
    },
    {
        "line": 146,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPJUMPS;"
    },
    {
        "line": 203,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 204,
        "fullcodeline": "cmod->cmod_flags |= CMOD_HIDE;"
    },
    {
        "line": 226,
        "fullcodeline": "cmod->cmod_split |= WSP_ABOVE;"
    },
    {
        "line": 236,
        "fullcodeline": "cmod->cmod_flags |= CMOD_NOSWAPFILE;"
    },
    {
        "line": 241,
        "fullcodeline": "cmod->cmod_split |= WSP_BELOW;"
    },
    {
        "line": 251,
        "fullcodeline": "cmod->cmod_flags |= CMOD_SILENT;"
    },
    {
        "line": 284,
        "fullcodeline": "cmod->cmod_split |= WSP_TOP;"
    },
    {
        "line": 289,
        "fullcodeline": "cmod->cmod_flags |= CMOD_UNSILENT;"
    },
    {
        "line": 318,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 33,
        "fullcodeline": "if (*eap->cmd == ':')"
    },
    {
        "line": 40,
        "fullcodeline": "&& (getline_equal(eap->getline, eap->cookie, getexmodeline)"
    },
    {
        "line": 46,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 54,
        "fullcodeline": "if (eap->nextcmd == NULL)"
    },
    {
        "line": 60,
        "fullcodeline": "if (vim9script && has_cmdmod(cmod, FALSE))"
    },
    {
        "line": 89,
        "fullcodeline": "for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)"
    },
    {
        "line": 92,
        "fullcodeline": "if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')"
    },
    {
        "line": 100,
        "fullcodeline": "case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))"
    },
    {
        "line": 105,
        "fullcodeline": "case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))"
    },
    {
        "line": 110,
        "fullcodeline": "if (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))"
    },
    {
        "line": 117,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))"
    },
    {
        "line": 122,
        "fullcodeline": "case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))"
    },
    {
        "line": 129,
        "fullcodeline": "case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))"
    },
    {
        "line": 134,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))"
    },
    {
        "line": 139,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))"
    },
    {
        "line": 144,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))"
    },
    {
        "line": 152,
        "fullcodeline": "char_u  *nulp = NULL;"
    },
    {
        "line": 153,
        "fullcodeline": "int\t    c = 0;"
    },
    {
        "line": 195,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 200,
        "fullcodeline": "case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)"
    },
    {
        "line": 207,
        "fullcodeline": "case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))"
    },
    {
        "line": 212,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))"
    },
    {
        "line": 224,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))"
    },
    {
        "line": 229,
        "fullcodeline": "case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))"
    },
    {
        "line": 234,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))"
    },
    {
        "line": 239,
        "fullcodeline": "case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))"
    },
    {
        "line": 244,
        "fullcodeline": "case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))"
    },
    {
        "line": 249,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))"
    },
    {
        "line": 252,
        "fullcodeline": "if (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))"
    },
    {
        "line": 260,
        "fullcodeline": "case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))"
    },
    {
        "line": 282,
        "fullcodeline": "if (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))"
    },
    {
        "line": 287,
        "fullcodeline": "case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))"
    },
    {
        "line": 292,
        "fullcodeline": "case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))"
    },
    {
        "line": 297,
        "fullcodeline": "if (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))"
    },
    {
        "line": 308,
        "fullcodeline": "if (!checkforcmd_noparen(&p, \"verbose\", 4))"
    },
    {
        "line": 310,
        "fullcodeline": "if (vim_isdigit(*eap->cmd))"
    },
    {
        "line": 34,
        "fullcodeline": "starts_with_colon = TRUE;"
    },
    {
        "line": 41,
        "fullcodeline": "|| getline_equal(eap->getline, eap->cookie, getexline))"
    },
    {
        "line": 47,
        "fullcodeline": "ex_pressedreturn = TRUE;"
    },
    {
        "line": 56,
        "fullcodeline": "eap->nextcmd = vim_strchr(eap->cmd, '\\n');"
    },
    {
        "line": 61,
        "fullcodeline": "*errormsg = _(e_command_modifier_without_command);"
    },
    {
        "line": 93,
        "fullcodeline": "|| *s == '[')"
    },
    {
        "line": 107,
        "fullcodeline": "cmod->cmod_split |= WSP_BELOW;"
    },
    {
        "line": 131,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPMARKS;"
    },
    {
        "line": 136,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPALT;"
    },
    {
        "line": 141,
        "fullcodeline": "cmod->cmod_flags |= CMOD_KEEPPATTERNS;"
    },
    {
        "line": 155,
        "fullcodeline": "if (!checkforcmd_noparen(&p, \"filter\", 4)"
    },
    {
        "line": 165,
        "fullcodeline": "if (*p == '!')"
    },
    {
        "line": 183,
        "fullcodeline": "if (p == NULL || *p == NUL)"
    },
    {
        "line": 185,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 201,
        "fullcodeline": "|| *p == NUL || ends_excmd(*p))"
    },
    {
        "line": 209,
        "fullcodeline": "cmod->cmod_flags |= CMOD_LOCKMARKS;"
    },
    {
        "line": 220,
        "fullcodeline": "cmod->cmod_flags |= CMOD_LEGACY;"
    },
    {
        "line": 231,
        "fullcodeline": "cmod->cmod_flags |= CMOD_NOAUTOCMD;"
    },
    {
        "line": 246,
        "fullcodeline": "cmod->cmod_flags |= CMOD_SANDBOX;"
    },
    {
        "line": 255,
        "fullcodeline": "eap->cmd = skipwhite(eap->cmd + 1);"
    },
    {
        "line": 256,
        "fullcodeline": "cmod->cmod_flags |= CMOD_ERRSILENT;"
    },
    {
        "line": 279,
        "fullcodeline": "eap->cmd = p;"
    },
    {
        "line": 294,
        "fullcodeline": "cmod->cmod_split |= WSP_VERT;"
    },
    {
        "line": 305,
        "fullcodeline": "cmod->cmod_flags |= CMOD_VIM9CMD;"
    },
    {
        "line": 312,
        "fullcodeline": "cmod->cmod_verbose = atoi((char *)eap->cmd);"
    },
    {
        "line": 334,
        "fullcodeline": "size_t len = STRLEN(cmd_start);"
    },
    {
        "line": 338,
        "fullcodeline": "mch_memmove(orig_cmd, cmd_start, len);"
    },
    {
        "line": 57,
        "fullcodeline": "if (eap->nextcmd != NULL)"
    },
    {
        "line": 157,
        "fullcodeline": "|| (ends_excmd(*p)"
    },
    {
        "line": 167,
        "fullcodeline": "cmod->cmod_filter_force = TRUE;"
    },
    {
        "line": 168,
        "fullcodeline": "p = skipwhite(p + 1);"
    },
    {
        "line": 178,
        "fullcodeline": "p = skip_vimgrep_pat(p, NULL, NULL);"
    },
    {
        "line": 187,
        "fullcodeline": "cmod->cmod_filter_regmatch.regprog ="
    },
    {
        "line": 214,
        "fullcodeline": "if (ends_excmd2(p, eap->cmd))"
    },
    {
        "line": 262,
        "fullcodeline": "if (!skip_only)"
    },
    {
        "line": 299,
        "fullcodeline": "if (ends_excmd2(p, eap->cmd))"
    },
    {
        "line": 313,
        "fullcodeline": "if (cmod->cmod_verbose == 0)"
    },
    {
        "line": 317,
        "fullcodeline": "cmod->cmod_verbose = 1;"
    },
    {
        "line": 344,
        "fullcodeline": "eap->cmd -= 5;"
    },
    {
        "line": 58,
        "fullcodeline": "++eap->nextcmd;"
    },
    {
        "line": 69,
        "fullcodeline": "if (vim9script && has_cmdmod(cmod, FALSE))"
    },
    {
        "line": 156,
        "fullcodeline": "|| *p == NUL"
    },
    {
        "line": 169,
        "fullcodeline": "if (*p == NUL || ends_excmd(*p))"
    },
    {
        "line": 181,
        "fullcodeline": "p = skip_vimgrep_pat_ext(p, &reg_pat, NULL,"
    },
    {
        "line": 188,
        "fullcodeline": "vim_regcomp(reg_pat, RE_MAGIC);"
    },
    {
        "line": 189,
        "fullcodeline": "if (cmod->cmod_filter_regmatch.regprog == NULL)"
    },
    {
        "line": 192,
        "fullcodeline": "if (nulp != NULL)"
    },
    {
        "line": 264,
        "fullcodeline": "long tabnr = get_address(eap, &eap->cmd,"
    },
    {
        "line": 314,
        "fullcodeline": "cmod->cmod_verbose = -1;"
    },
    {
        "line": 343,
        "fullcodeline": "mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);"
    },
    {
        "line": 345,
        "fullcodeline": "mch_memmove(eap->cmd - 1, \":'<,'>\", 6);"
    },
    {
        "line": 70,
        "fullcodeline": "*errormsg = _(e_command_modifier_without_command);"
    },
    {
        "line": 193,
        "fullcodeline": "*nulp = c;"
    },
    {
        "line": 217,
        "fullcodeline": "_(e_legacy_must_be_followed_by_command);"
    },
    {
        "line": 267,
        "fullcodeline": "if (tabnr == MAXLNUM)"
    },
    {
        "line": 302,
        "fullcodeline": "_(e_vim9cmd_must_be_followed_by_command);"
    },
    {
        "line": 268,
        "fullcodeline": "cmod->cmod_tab = tabpage_index(curtab) + 1;"
    },
    {
        "line": 276,
        "fullcodeline": "cmod->cmod_tab = tabnr + 1;"
    },
    {
        "line": 271,
        "fullcodeline": "if (tabnr < 0 || tabnr > LAST_TAB_NR)"
    },
    {
        "line": 273,
        "fullcodeline": "*errormsg = _(e_invalid_range);"
    }
]