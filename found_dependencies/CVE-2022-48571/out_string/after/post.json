[
    {
        "line": 3,
        "fullcodeline": "assert(c != NULL);"
    },
    {
        "line": 4,
        "fullcodeline": "mc_resp *resp = c->resp;"
    },
    {
        "line": 11,
        "fullcodeline": "resp_reset(resp);"
    },
    {
        "line": 28,
        "fullcodeline": "len = strlen(str);"
    },
    {
        "line": 35,
        "fullcodeline": "memcpy(resp->wbuf, str, len);"
    },
    {
        "line": 36,
        "fullcodeline": "memcpy(resp->wbuf + len, \"\\r\\n\", 2);"
    },
    {
        "line": 37,
        "fullcodeline": "resp_add_iov(resp, resp->wbuf, len + 2);"
    },
    {
        "line": 39,
        "fullcodeline": "conn_set_state(c, conn_new_cmd);"
    },
    {
        "line": 23,
        "fullcodeline": "if (settings.verbose > 1)"
    },
    {
        "line": 29,
        "fullcodeline": "if ((len + 2) > WRITE_BUFFER_SIZE) {"
    },
    {
        "line": 16,
        "fullcodeline": "resp->skip = true;"
    },
    {
        "line": 19,
        "fullcodeline": "conn_set_state(c, conn_new_cmd);"
    },
    {
        "line": 24,
        "fullcodeline": "fprintf(stderr, \">%d %s\\n\", c->sfd, str);"
    },
    {
        "line": 31,
        "fullcodeline": "str = \"SERVER_ERROR output line too long\";"
    },
    {
        "line": 32,
        "fullcodeline": "len = strlen(str);"
    },
    {
        "line": 17,
        "fullcodeline": "if (settings.verbose > 1)"
    },
    {
        "line": 18,
        "fullcodeline": "fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);"
    }
]