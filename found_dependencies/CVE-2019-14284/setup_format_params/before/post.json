[
    {
        "line": 10,
        "fullcodeline": "} *here = (struct fparm *)floppy_track_buffer;"
    },
    {
        "line": 12,
        "fullcodeline": "raw_cmd = &default_raw_cmd;"
    },
    {
        "line": 13,
        "fullcodeline": "raw_cmd->track = track;"
    },
    {
        "line": 15,
        "fullcodeline": "raw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |"
    },
    {
        "line": 17,
        "fullcodeline": "raw_cmd->rate = _floppy->rate & 0x43;"
    },
    {
        "line": 18,
        "fullcodeline": "raw_cmd->cmd_count = NR_F;"
    },
    {
        "line": 19,
        "fullcodeline": "COMMAND = FM_MODE(_floppy, FD_FORMAT);"
    },
    {
        "line": 20,
        "fullcodeline": "DR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);"
    },
    {
        "line": 21,
        "fullcodeline": "F_SIZECODE = FD_SIZECODE(_floppy);"
    },
    {
        "line": 22,
        "fullcodeline": "F_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;"
    },
    {
        "line": 23,
        "fullcodeline": "F_GAP = _floppy->fmt_gap;"
    },
    {
        "line": 24,
        "fullcodeline": "F_FILL = FD_FILL_BYTE;"
    },
    {
        "line": 26,
        "fullcodeline": "raw_cmd->kernel_data = floppy_track_buffer;"
    },
    {
        "line": 27,
        "fullcodeline": "raw_cmd->length = 4 * F_SECT_PER_TRACK;"
    },
    {
        "line": 30,
        "fullcodeline": "head_shift = (F_SECT_PER_TRACK + 5) / 6;"
    },
    {
        "line": 33,
        "fullcodeline": "track_shift = 2 * head_shift + 3;"
    },
    {
        "line": 36,
        "fullcodeline": "n = (track_shift * format_req.track + head_shift * format_req.head)"
    },
    {
        "line": 40,
        "fullcodeline": "il = 1;"
    },
    {
        "line": 41,
        "fullcodeline": "if (_floppy->fmt_gap < 0x22)"
    },
    {
        "line": 45,
        "fullcodeline": "for (count = 0; count < F_SECT_PER_TRACK; ++count) {"
    },
    {
        "line": 52,
        "fullcodeline": "for (count = 1; count <= F_SECT_PER_TRACK; ++count) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (_floppy->stretch & FD_SECTBASEMASK) {"
    },
    {
        "line": 42,
        "fullcodeline": "il++;"
    },
    {
        "line": 46,
        "fullcodeline": "here[count].track = format_req.track;"
    },
    {
        "line": 47,
        "fullcodeline": "here[count].head = format_req.head;"
    },
    {
        "line": 48,
        "fullcodeline": "here[count].sect = 0;"
    },
    {
        "line": 49,
        "fullcodeline": "here[count].size = F_SIZECODE;"
    },
    {
        "line": 53,
        "fullcodeline": "here[n].sect = count;"
    },
    {
        "line": 54,
        "fullcodeline": "n = (n + il) % F_SECT_PER_TRACK;"
    },
    {
        "line": 65,
        "fullcodeline": "for (count = 0; count < F_SECT_PER_TRACK; count++)"
    },
    {
        "line": 66,
        "fullcodeline": "here[count].sect += FD_SECTBASE(_floppy) - 1;"
    },
    {
        "line": 56,
        "fullcodeline": "++n;"
    },
    {
        "line": 57,
        "fullcodeline": "if (n >= F_SECT_PER_TRACK) {"
    },
    {
        "line": 58,
        "fullcodeline": "n -= F_SECT_PER_TRACK;"
    },
    {
        "line": 60,
        "fullcodeline": "++n;"
    }
]