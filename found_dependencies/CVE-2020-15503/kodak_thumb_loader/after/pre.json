[
    {
        "line": 3,
        "fullcodeline": "INT64 est_datasize ="
    },
    {
        "line": 18,
        "fullcodeline": "ushort s_height = S.height, s_width = S.width, s_iwidth = S.iwidth,"
    },
    {
        "line": 19,
        "fullcodeline": "s_iheight = S.iheight;"
    },
    {
        "line": 20,
        "fullcodeline": "ushort s_flags = libraw_internal_data.unpacker_data.load_flags;"
    },
    {
        "line": 22,
        "fullcodeline": "int s_colors = P1.colors;"
    },
    {
        "line": 23,
        "fullcodeline": "unsigned s_filters = P1.filters;"
    },
    {
        "line": 24,
        "fullcodeline": "ushort(*s_image)[4] = imgdata.image;"
    },
    {
        "line": 26,
        "fullcodeline": "S.height = T.theight;"
    },
    {
        "line": 27,
        "fullcodeline": "S.width = T.twidth;"
    },
    {
        "line": 36,
        "fullcodeline": "imgdata.image ="
    },
    {
        "line": 38,
        "fullcodeline": "merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 40,
        "fullcodeline": "ID.input->seek(ID.toffset, SEEK_SET);"
    },
    {
        "line": 97,
        "fullcodeline": "int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] ="
    },
    {
        "line": 99,
        "fullcodeline": "merror(t_hist, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 101,
        "fullcodeline": "float out[3], out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},"
    },
    {
        "line": 123,
        "fullcodeline": "int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] ="
    },
    {
        "line": 128,
        "fullcodeline": "ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);"
    },
    {
        "line": 129,
        "fullcodeline": "merror(t_curve, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 130,
        "fullcodeline": "memmove(t_curve, C.curve, sizeof(C.curve));"
    },
    {
        "line": 151,
        "fullcodeline": "libraw_internal_data.output_data.histogram = save_hist;"
    },
    {
        "line": 156,
        "fullcodeline": "int s_flip = imgdata.sizes.flip;"
    },
    {
        "line": 168,
        "fullcodeline": "T.thumb = (char *)calloc(S.width * S.height, P1.colors);"
    },
    {
        "line": 169,
        "fullcodeline": "merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 188,
        "fullcodeline": "memmove(C.curve, t_curve, sizeof(C.curve));"
    },
    {
        "line": 4,
        "fullcodeline": "T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?"
    },
    {
        "line": 5,
        "fullcodeline": "if (ID.toffset < 0)"
    },
    {
        "line": 72,
        "fullcodeline": "float scale_mul[4];"
    },
    {
        "line": 82,
        "fullcodeline": "size_t size = S.height * S.width;"
    },
    {
        "line": 105,
        "fullcodeline": "for (img = imgdata.image[0], row = 0; row < S.height; row++)"
    },
    {
        "line": 133,
        "fullcodeline": "int perc, val, total, t_white = 0x2000, c;"
    },
    {
        "line": 135,
        "fullcodeline": "perc = S.width * S.height * 0.01; /* 99th percentile white level */"
    },
    {
        "line": 157,
        "fullcodeline": "if (imgdata.params.raw_processing_options &"
    },
    {
        "line": 170,
        "fullcodeline": "T.tlength = S.width * S.height * P1.colors;"
    },
    {
        "line": 174,
        "fullcodeline": "int soff = flip_index(0, 0);"
    },
    {
        "line": 175,
        "fullcodeline": "int cstep = flip_index(0, 1) - soff;"
    },
    {
        "line": 176,
        "fullcodeline": "int rstep = flip_index(1, 0) - flip_index(0, S.width);"
    },
    {
        "line": 8,
        "fullcodeline": "if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)"
    },
    {
        "line": 11,
        "fullcodeline": "if(INT64(T.theight) * INT64(T.twidth) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB)"
    },
    {
        "line": 14,
        "fullcodeline": "if (INT64(T.theight) * INT64(T.twidth) < 64ULL)"
    },
    {
        "line": 32,
        "fullcodeline": "S.height += S.height & 1;"
    },
    {
        "line": 33,
        "fullcodeline": "S.width += S.width & 1;"
    },
    {
        "line": 37,
        "fullcodeline": "(ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));"
    },
    {
        "line": 74,
        "fullcodeline": "for (dmax = DBL_MAX, c = 0; c < 3; c++)"
    },
    {
        "line": 78,
        "fullcodeline": "for (c = 0; c < 3; c++)"
    },
    {
        "line": 83,
        "fullcodeline": "for (unsigned i = 0; i < size * 4; i++)"
    },
    {
        "line": 98,
        "fullcodeline": "(int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);"
    },
    {
        "line": 102,
        "fullcodeline": "{-0.111855984, 1.73688626, -0.625030339, 0},"
    },
    {
        "line": 103,
        "fullcodeline": "{-0.0379119813, -0.891268849, 1.92918086, 0}};"
    },
    {
        "line": 106,
        "fullcodeline": "for (col = 0; col < S.width; col++, img += 4)"
    },
    {
        "line": 148,
        "fullcodeline": "gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);"
    },
    {
        "line": 164,
        "fullcodeline": "SWAP(S.height, S.width);"
    },
    {
        "line": 178,
        "fullcodeline": "for (int row = 0; row < S.height; row++, soff += rstep)"
    },
    {
        "line": 75,
        "fullcodeline": "if (dmax > C.pre_mul[c])"
    },
    {
        "line": 79,
        "fullcodeline": "scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;"
    },
    {
        "line": 85,
        "fullcodeline": "val = imgdata.image[0][i];"
    },
    {
        "line": 88,
        "fullcodeline": "val *= scale_mul[i & 3];"
    },
    {
        "line": 89,
        "fullcodeline": "imgdata.image[0][i] = CLIP(val);"
    },
    {
        "line": 108,
        "fullcodeline": "out[0] = out[1] = out[2] = 0;"
    },
    {
        "line": 137,
        "fullcodeline": "perc /= 2;"
    },
    {
        "line": 138,
        "fullcodeline": "if (!((O.highlight & ~2) || O.no_auto_bright))"
    },
    {
        "line": 76,
        "fullcodeline": "dmax = C.pre_mul[c];"
    },
    {
        "line": 86,
        "fullcodeline": "if (!val)"
    },
    {
        "line": 110,
        "fullcodeline": "for (c = 0; c < 3; c++)"
    },
    {
        "line": 116,
        "fullcodeline": "for (c = 0; c < 3; c++)"
    },
    {
        "line": 117,
        "fullcodeline": "img[c] = CLIP((int)out[c]);"
    },
    {
        "line": 118,
        "fullcodeline": "for (c = 0; c < P1.colors; c++)"
    },
    {
        "line": 139,
        "fullcodeline": "for (t_white = c = 0; c < P1.colors; c++)"
    },
    {
        "line": 181,
        "fullcodeline": "for (int col = 0; col < S.width; col++, soff += cstep)"
    },
    {
        "line": 180,
        "fullcodeline": "char *ppm = T.thumb + row * S.width * P1.colors;"
    },
    {
        "line": 182,
        "fullcodeline": "for (int c = 0; c < P1.colors; c++)"
    },
    {
        "line": 112,
        "fullcodeline": "out[0] += out_cam[0][c] * img[c];"
    },
    {
        "line": 113,
        "fullcodeline": "out[1] += out_cam[1][c] * img[c];"
    },
    {
        "line": 114,
        "fullcodeline": "out[2] += out_cam[2][c] * img[c];"
    },
    {
        "line": 119,
        "fullcodeline": "t_hist[c][img[c] >> 3]++;"
    },
    {
        "line": 145,
        "fullcodeline": "if (t_white < val)"
    },
    {
        "line": 184,
        "fullcodeline": "imgdata.color.curve[imgdata.image[soff][c]] >> 8;"
    },
    {
        "line": 141,
        "fullcodeline": "for (val = 0x2000, total = 0; --val > 32;)"
    },
    {
        "line": 146,
        "fullcodeline": "t_white = val;"
    },
    {
        "line": 142,
        "fullcodeline": "if ((total += libraw_internal_data.output_data.histogram[c][val]) >"
    },
    {
        "line": 183,
        "fullcodeline": "ppm[col * P1.colors + c] ="
    }
]