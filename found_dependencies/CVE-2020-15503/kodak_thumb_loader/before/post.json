[
    {
        "line": 3,
        "fullcodeline": "INT64 est_datasize ="
    },
    {
        "line": 15,
        "fullcodeline": "libraw_internal_data.unpacker_data.load_flags = 12;"
    },
    {
        "line": 18,
        "fullcodeline": "ushort(*s_image)[4] = imgdata.image;"
    },
    {
        "line": 20,
        "fullcodeline": "S.height = T.theight;"
    },
    {
        "line": 21,
        "fullcodeline": "S.width = T.twidth;"
    },
    {
        "line": 22,
        "fullcodeline": "P1.filters = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "imgdata.image ="
    },
    {
        "line": 32,
        "fullcodeline": "merror(imgdata.image, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 34,
        "fullcodeline": "ID.input->seek(ID.toffset, SEEK_SET);"
    },
    {
        "line": 91,
        "fullcodeline": "int(*t_hist)[LIBRAW_HISTOGRAM_SIZE] ="
    },
    {
        "line": 93,
        "fullcodeline": "merror(t_hist, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 95,
        "fullcodeline": "float out[3], out_cam[3][4] = {{2.81761312, -1.98369181, 0.166078627, 0},"
    },
    {
        "line": 117,
        "fullcodeline": "int(*save_hist)[LIBRAW_HISTOGRAM_SIZE] ="
    },
    {
        "line": 119,
        "fullcodeline": "libraw_internal_data.output_data.histogram = t_hist;"
    },
    {
        "line": 122,
        "fullcodeline": "ushort *t_curve = (ushort *)calloc(sizeof(C.curve), 1);"
    },
    {
        "line": 123,
        "fullcodeline": "merror(t_curve, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 124,
        "fullcodeline": "memmove(t_curve, C.curve, sizeof(C.curve));"
    },
    {
        "line": 125,
        "fullcodeline": "memset(C.curve, 0, sizeof(C.curve));"
    },
    {
        "line": 145,
        "fullcodeline": "libraw_internal_data.output_data.histogram = save_hist;"
    },
    {
        "line": 146,
        "fullcodeline": "free(t_hist);"
    },
    {
        "line": 155,
        "fullcodeline": "S.iheight = S.height;"
    },
    {
        "line": 156,
        "fullcodeline": "S.iwidth = S.width;"
    },
    {
        "line": 162,
        "fullcodeline": "T.thumb = (char *)calloc(S.width * S.height, P1.colors);"
    },
    {
        "line": 163,
        "fullcodeline": "merror(T.thumb, \"LibRaw::kodak_thumb_loader()\");"
    },
    {
        "line": 164,
        "fullcodeline": "T.tlength = S.width * S.height * P1.colors;"
    },
    {
        "line": 182,
        "fullcodeline": "memmove(C.curve, t_curve, sizeof(C.curve));"
    },
    {
        "line": 183,
        "fullcodeline": "free(t_curve);"
    },
    {
        "line": 186,
        "fullcodeline": "free(imgdata.image);"
    },
    {
        "line": 187,
        "fullcodeline": "imgdata.image = s_image;"
    },
    {
        "line": 193,
        "fullcodeline": "T.twidth = S.width;"
    },
    {
        "line": 194,
        "fullcodeline": "S.width = s_width;"
    },
    {
        "line": 196,
        "fullcodeline": "S.iwidth = s_iwidth;"
    },
    {
        "line": 197,
        "fullcodeline": "S.iheight = s_iheight;"
    },
    {
        "line": 199,
        "fullcodeline": "T.theight = S.height;"
    },
    {
        "line": 200,
        "fullcodeline": "S.height = s_height;"
    },
    {
        "line": 202,
        "fullcodeline": "T.tcolors = P1.colors;"
    },
    {
        "line": 203,
        "fullcodeline": "P1.colors = s_colors;"
    },
    {
        "line": 205,
        "fullcodeline": "P1.filters = s_filters;"
    },
    {
        "line": 206,
        "fullcodeline": "libraw_internal_data.unpacker_data.load_flags = s_flags;"
    },
    {
        "line": 4,
        "fullcodeline": "T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?"
    },
    {
        "line": 5,
        "fullcodeline": "if (ID.toffset < 0)"
    },
    {
        "line": 8,
        "fullcodeline": "if (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)"
    },
    {
        "line": 24,
        "fullcodeline": "if (thumb_load_raw == &LibRaw::kodak_ycbcr_load_raw)"
    },
    {
        "line": 31,
        "fullcodeline": "(ushort(*)[4])calloc(S.iheight * S.iwidth, sizeof(*imgdata.image));"
    },
    {
        "line": 66,
        "fullcodeline": "float scale_mul[4];"
    },
    {
        "line": 74,
        "fullcodeline": "scale_mul[3] = scale_mul[1];"
    },
    {
        "line": 76,
        "fullcodeline": "size_t size = S.height * S.width;"
    },
    {
        "line": 92,
        "fullcodeline": "(int(*)[LIBRAW_HISTOGRAM_SIZE])calloc(sizeof(*t_hist), 4);"
    },
    {
        "line": 99,
        "fullcodeline": "for (img = imgdata.image[0], row = 0; row < S.height; row++)"
    },
    {
        "line": 127,
        "fullcodeline": "int perc, val, total, t_white = 0x2000, c;"
    },
    {
        "line": 129,
        "fullcodeline": "perc = S.width * S.height * 0.01; /* 99th percentile white level */"
    },
    {
        "line": 142,
        "fullcodeline": "gamma_curve(O.gamm[0], O.gamm[1], 2, (t_white << 3) / O.bright);"
    },
    {
        "line": 151,
        "fullcodeline": "if (imgdata.params.raw_processing_options &"
    },
    {
        "line": 157,
        "fullcodeline": "if (S.flip & 4)"
    },
    {
        "line": 168,
        "fullcodeline": "int soff = flip_index(0, 0);"
    },
    {
        "line": 169,
        "fullcodeline": "int cstep = flip_index(0, 1) - soff;"
    },
    {
        "line": 170,
        "fullcodeline": "int rstep = flip_index(1, 0) - flip_index(0, S.width);"
    },
    {
        "line": 189,
        "fullcodeline": "if (imgdata.params.raw_processing_options &"
    },
    {
        "line": 26,
        "fullcodeline": "S.height += S.height & 1;"
    },
    {
        "line": 27,
        "fullcodeline": "S.width += S.width & 1;"
    },
    {
        "line": 68,
        "fullcodeline": "for (dmax = DBL_MAX, c = 0; c < 3; c++)"
    },
    {
        "line": 72,
        "fullcodeline": "for (c = 0; c < 3; c++)"
    },
    {
        "line": 73,
        "fullcodeline": "scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;"
    },
    {
        "line": 77,
        "fullcodeline": "for (unsigned i = 0; i < size * 4; i++)"
    },
    {
        "line": 96,
        "fullcodeline": "{-0.111855984, 1.73688626, -0.625030339, 0},"
    },
    {
        "line": 97,
        "fullcodeline": "{-0.0379119813, -0.891268849, 1.92918086, 0}};"
    },
    {
        "line": 100,
        "fullcodeline": "for (col = 0; col < S.width; col++, img += 4)"
    },
    {
        "line": 132,
        "fullcodeline": "if (!((O.highlight & ~2) || O.no_auto_bright))"
    },
    {
        "line": 153,
        "fullcodeline": "imgdata.sizes.flip = 0;"
    },
    {
        "line": 158,
        "fullcodeline": "SWAP(S.height, S.width);"
    },
    {
        "line": 172,
        "fullcodeline": "for (int row = 0; row < S.height; row++, soff += rstep)"
    },
    {
        "line": 191,
        "fullcodeline": "imgdata.sizes.flip = s_flip;"
    },
    {
        "line": 42,
        "fullcodeline": "free(imgdata.image);"
    },
    {
        "line": 43,
        "fullcodeline": "imgdata.image = s_image;"
    },
    {
        "line": 45,
        "fullcodeline": "T.twidth = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "S.width = s_width;"
    },
    {
        "line": 48,
        "fullcodeline": "S.iwidth = s_iwidth;"
    },
    {
        "line": 49,
        "fullcodeline": "S.iheight = s_iheight;"
    },
    {
        "line": 51,
        "fullcodeline": "T.theight = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "S.height = s_height;"
    },
    {
        "line": 54,
        "fullcodeline": "T.tcolors = 0;"
    },
    {
        "line": 55,
        "fullcodeline": "P1.colors = s_colors;"
    },
    {
        "line": 57,
        "fullcodeline": "P1.filters = s_filters;"
    },
    {
        "line": 58,
        "fullcodeline": "T.tlength = 0;"
    },
    {
        "line": 59,
        "fullcodeline": "libraw_internal_data.unpacker_data.load_flags = s_flags;"
    },
    {
        "line": 69,
        "fullcodeline": "if (dmax > C.pre_mul[c])"
    },
    {
        "line": 79,
        "fullcodeline": "val = imgdata.image[0][i];"
    },
    {
        "line": 82,
        "fullcodeline": "val *= scale_mul[i & 3];"
    },
    {
        "line": 83,
        "fullcodeline": "imgdata.image[0][i] = CLIP(val);"
    },
    {
        "line": 102,
        "fullcodeline": "out[0] = out[1] = out[2] = 0;"
    },
    {
        "line": 131,
        "fullcodeline": "perc /= 2;"
    },
    {
        "line": 174,
        "fullcodeline": "char *ppm = T.thumb + row * S.width * P1.colors;"
    },
    {
        "line": 70,
        "fullcodeline": "dmax = C.pre_mul[c];"
    },
    {
        "line": 80,
        "fullcodeline": "if (!val)"
    },
    {
        "line": 104,
        "fullcodeline": "for (c = 0; c < 3; c++)"
    },
    {
        "line": 110,
        "fullcodeline": "for (c = 0; c < 3; c++)"
    },
    {
        "line": 111,
        "fullcodeline": "img[c] = CLIP((int)out[c]);"
    },
    {
        "line": 112,
        "fullcodeline": "for (c = 0; c < P1.colors; c++)"
    },
    {
        "line": 133,
        "fullcodeline": "for (t_white = c = 0; c < P1.colors; c++)"
    },
    {
        "line": 175,
        "fullcodeline": "for (int col = 0; col < S.width; col++, soff += cstep)"
    },
    {
        "line": 106,
        "fullcodeline": "out[0] += out_cam[0][c] * img[c];"
    },
    {
        "line": 107,
        "fullcodeline": "out[1] += out_cam[1][c] * img[c];"
    },
    {
        "line": 108,
        "fullcodeline": "out[2] += out_cam[2][c] * img[c];"
    },
    {
        "line": 176,
        "fullcodeline": "for (int c = 0; c < P1.colors; c++)"
    },
    {
        "line": 177,
        "fullcodeline": "ppm[col * P1.colors + c] ="
    },
    {
        "line": 113,
        "fullcodeline": "t_hist[c][img[c] >> 3]++;"
    },
    {
        "line": 135,
        "fullcodeline": "for (val = 0x2000, total = 0; --val > 32;)"
    },
    {
        "line": 139,
        "fullcodeline": "if (t_white < val)"
    },
    {
        "line": 178,
        "fullcodeline": "imgdata.color.curve[imgdata.image[soff][c]] >> 8;"
    },
    {
        "line": 136,
        "fullcodeline": "if ((total += libraw_internal_data.output_data.histogram[c][val]) >"
    },
    {
        "line": 140,
        "fullcodeline": "t_white = val;"
    }
]