[
    {
        "line": 30,
        "fullcodeline": "int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;"
    },
    {
        "line": 31,
        "fullcodeline": "int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;"
    },
    {
        "line": 33,
        "fullcodeline": "if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&"
    },
    {
        "line": 328,
        "fullcodeline": "EXCEPTION_HANDLER(err);"
    },
    {
        "line": 34,
        "fullcodeline": "load_raw == &LibRaw::broadcom_load_raw) // RPi"
    },
    {
        "line": 41,
        "fullcodeline": "kodak_thumb_loader();"
    },
    {
        "line": 42,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 43,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 72,
        "fullcodeline": "ID.input->seek(ID.toffset, SEEK_SET);"
    },
    {
        "line": 73,
        "fullcodeline": "if (write_thumb == &LibRaw::jpeg_thumb)"
    },
    {
        "line": 75,
        "fullcodeline": "THUMB_SIZE_CHECKTNZ(T.tlength);"
    },
    {
        "line": 79,
        "fullcodeline": "T.thumb = (char *)malloc(T.tlength);"
    },
    {
        "line": 80,
        "fullcodeline": "merror(T.thumb, \"jpeg_thumb()\");"
    },
    {
        "line": 81,
        "fullcodeline": "ID.input->read(T.thumb, 1, T.tlength);"
    },
    {
        "line": 82,
        "fullcodeline": "unsigned char *tthumb = (unsigned char *)T.thumb;"
    },
    {
        "line": 83,
        "fullcodeline": "tthumb[0] = 0xff;"
    },
    {
        "line": 84,
        "fullcodeline": "tthumb[1] = 0xd8;"
    },
    {
        "line": 117,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_JPEG;"
    },
    {
        "line": 118,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 91,
        "fullcodeline": "cinfo.err = jpeg_std_error(&jerr.pub);"
    },
    {
        "line": 92,
        "fullcodeline": "jerr.pub.error_exit = jpegErrorExit;"
    },
    {
        "line": 106,
        "fullcodeline": "jpeg_create_decompress(&cinfo);"
    },
    {
        "line": 107,
        "fullcodeline": "jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);"
    },
    {
        "line": 108,
        "fullcodeline": "int rc = jpeg_read_header(&cinfo, TRUE);"
    },
    {
        "line": 111,
        "fullcodeline": "T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)"
    },
    {
        "line": 114,
        "fullcodeline": "jpeg_destroy_decompress(&cinfo);"
    },
    {
        "line": 64,
        "fullcodeline": "if (INT64(ID.toffset) + INT64(T.tlength) < 1)"
    },
    {
        "line": 67,
        "fullcodeline": "if (INT64(ID.toffset) + INT64(T.tlength) >"
    },
    {
        "line": 109,
        "fullcodeline": "if (rc != 1)"
    },
    {
        "line": 121,
        "fullcodeline": "else if (write_thumb == &LibRaw::layer_thumb)"
    },
    {
        "line": 68,
        "fullcodeline": "ID.input->size() + THUMB_READ_BEYOND)"
    },
    {
        "line": 98,
        "fullcodeline": "jpeg_destroy_decompress(&cinfo);"
    },
    {
        "line": 99,
        "fullcodeline": "T.tcolors = 3;"
    },
    {
        "line": 100,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;"
    },
    {
        "line": 101,
        "fullcodeline": "ID.input->seek(ID.toffset, SEEK_SET);"
    },
    {
        "line": 102,
        "fullcodeline": "ID.input->read(T.thumb, 1, T.tlength);"
    },
    {
        "line": 103,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 123,
        "fullcodeline": "int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;"
    },
    {
        "line": 129,
        "fullcodeline": "int tlength = T.twidth * T.theight;"
    },
    {
        "line": 132,
        "fullcodeline": "T.thumb = (char *)calloc(colors, tlength);"
    },
    {
        "line": 133,
        "fullcodeline": "merror(T.thumb, \"layer_thumb()\");"
    },
    {
        "line": 134,
        "fullcodeline": "unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);"
    },
    {
        "line": 135,
        "fullcodeline": "merror(tbuf, \"layer_thumb()\");"
    },
    {
        "line": 136,
        "fullcodeline": "ID.input->read(tbuf, colors, T.tlength);"
    },
    {
        "line": 160,
        "fullcodeline": "T.tcolors = colors;"
    },
    {
        "line": 161,
        "fullcodeline": "T.tlength = colors * tlength;"
    },
    {
        "line": 162,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 163,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 124,
        "fullcodeline": "if (colors != 1 && colors != 3)"
    },
    {
        "line": 137,
        "fullcodeline": "if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&"
    },
    {
        "line": 138,
        "fullcodeline": "colors == 3) // GRB order"
    },
    {
        "line": 159,
        "fullcodeline": "free(tbuf);"
    },
    {
        "line": 166,
        "fullcodeline": "else if (write_thumb == &LibRaw::rollei_thumb)"
    },
    {
        "line": 139,
        "fullcodeline": "for (int i = 0; i < tlength; i++)"
    },
    {
        "line": 170,
        "fullcodeline": "int tlength = T.twidth * T.theight;"
    },
    {
        "line": 173,
        "fullcodeline": "T.tcolors = 3;"
    },
    {
        "line": 174,
        "fullcodeline": "T.thumb = (char *)calloc(T.tcolors, tlength);"
    },
    {
        "line": 175,
        "fullcodeline": "merror(T.thumb, \"layer_thumb()\");"
    },
    {
        "line": 176,
        "fullcodeline": "unsigned short *tbuf = (unsigned short *)calloc(2, tlength);"
    },
    {
        "line": 177,
        "fullcodeline": "merror(tbuf, \"layer_thumb()\");"
    },
    {
        "line": 178,
        "fullcodeline": "read_shorts(tbuf, tlength);"
    },
    {
        "line": 185,
        "fullcodeline": "free(tbuf);"
    },
    {
        "line": 186,
        "fullcodeline": "T.tlength = T.tcolors * tlength;"
    },
    {
        "line": 187,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 188,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 141,
        "fullcodeline": "T.thumb[i * 3] = tbuf[i + tlength];"
    },
    {
        "line": 142,
        "fullcodeline": "T.thumb[i * 3 + 1] = tbuf[i];"
    },
    {
        "line": 143,
        "fullcodeline": "T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];"
    },
    {
        "line": 145,
        "fullcodeline": "else if (colors == 3) // RGB or 1-channel"
    },
    {
        "line": 179,
        "fullcodeline": "for (i = 0; i < tlength; i++)"
    },
    {
        "line": 127,
        "fullcodeline": "THUMB_SIZE_CHECKWH(T.twidth, T.theight);"
    },
    {
        "line": 181,
        "fullcodeline": "T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;"
    },
    {
        "line": 182,
        "fullcodeline": "T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;"
    },
    {
        "line": 183,
        "fullcodeline": "T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;"
    },
    {
        "line": 191,
        "fullcodeline": "else if (write_thumb == &LibRaw::ppm_thumb)"
    },
    {
        "line": 146,
        "fullcodeline": "for (int i = 0; i < tlength; i++)"
    },
    {
        "line": 197,
        "fullcodeline": "int t_length = T.twidth * T.theight * t_colors;"
    },
    {
        "line": 254,
        "fullcodeline": "THUMB_SIZE_CHECKTNZ(T.tlength);"
    },
    {
        "line": 256,
        "fullcodeline": "T.thumb = (char *)malloc(T.tlength);"
    },
    {
        "line": 259,
        "fullcodeline": "merror(T.thumb, \"ppm_thumb()\");"
    },
    {
        "line": 261,
        "fullcodeline": "ID.input->read(T.thumb, 1, T.tlength);"
    },
    {
        "line": 263,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 264,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 148,
        "fullcodeline": "T.thumb[i * 3] = tbuf[i];"
    },
    {
        "line": 149,
        "fullcodeline": "T.thumb[i * 3 + 1] = tbuf[i + tlength];"
    },
    {
        "line": 150,
        "fullcodeline": "T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];"
    },
    {
        "line": 152,
        "fullcodeline": "else if (colors == 1)"
    },
    {
        "line": 193,
        "fullcodeline": "if (t_bytesps > 1)"
    },
    {
        "line": 199,
        "fullcodeline": "if (T.tlength &&"
    },
    {
        "line": 249,
        "fullcodeline": "if (!T.tlength)"
    },
    {
        "line": 257,
        "fullcodeline": "if (!T.tcolors)"
    },
    {
        "line": 154,
        "fullcodeline": "free(T.thumb);"
    },
    {
        "line": 155,
        "fullcodeline": "T.thumb = (char *)tbuf;"
    },
    {
        "line": 156,
        "fullcodeline": "tbuf = 0;"
    },
    {
        "line": 169,
        "fullcodeline": "THUMB_SIZE_CHECKWH(T.twidth, T.theight);"
    },
    {
        "line": 200,
        "fullcodeline": "(int)T.tlength < t_length) // try to find tiff ifd with needed offset"
    },
    {
        "line": 202,
        "fullcodeline": "int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);"
    },
    {
        "line": 250,
        "fullcodeline": "T.tlength = t_length;"
    },
    {
        "line": 252,
        "fullcodeline": "free(T.thumb);"
    },
    {
        "line": 258,
        "fullcodeline": "T.tcolors = t_colors;"
    },
    {
        "line": 267,
        "fullcodeline": "else if (write_thumb == &LibRaw::ppm16_thumb)"
    },
    {
        "line": 203,
        "fullcodeline": "if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&"
    },
    {
        "line": 272,
        "fullcodeline": "int o_bps = (imgdata.params.raw_processing_options &"
    },
    {
        "line": 276,
        "fullcodeline": "int o_length = T.twidth * T.theight * t_colors * o_bps;"
    },
    {
        "line": 277,
        "fullcodeline": "int i_length = T.twidth * T.theight * t_colors * 2;"
    },
    {
        "line": 280,
        "fullcodeline": "THUMB_SIZE_CHECKTNZ(o_length);"
    },
    {
        "line": 281,
        "fullcodeline": "THUMB_SIZE_CHECKTNZ(i_length);"
    },
    {
        "line": 282,
        "fullcodeline": "THUMB_SIZE_CHECKTNZ(T.tlength);"
    },
    {
        "line": 284,
        "fullcodeline": "ushort *t_thumb = (ushort *)calloc(i_length, 1);"
    },
    {
        "line": 285,
        "fullcodeline": "ID.input->read(t_thumb, 1, i_length);"
    },
    {
        "line": 307,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 207,
        "fullcodeline": "unsigned total_size = 0;"
    },
    {
        "line": 217,
        "fullcodeline": "T.tlength = total_size;"
    },
    {
        "line": 218,
        "fullcodeline": "THUMB_SIZE_CHECKTNZ(T.tlength);"
    },
    {
        "line": 221,
        "fullcodeline": "T.thumb = (char *)malloc(T.tlength);"
    },
    {
        "line": 222,
        "fullcodeline": "merror(T.thumb, \"ppm_thumb()\");"
    },
    {
        "line": 224,
        "fullcodeline": "char *dest = T.thumb;"
    },
    {
        "line": 225,
        "fullcodeline": "INT64 pos = ID.input->tell();"
    },
    {
        "line": 242,
        "fullcodeline": "ID.input->seek(pos, SEEK_SET);"
    },
    {
        "line": 243,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 244,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 269,
        "fullcodeline": "if (t_bytesps > 2)"
    },
    {
        "line": 278,
        "fullcodeline": "if (!T.tlength)"
    },
    {
        "line": 286,
        "fullcodeline": "if ((libraw_internal_data.unpacker_data.order == 0x4949) =="
    },
    {
        "line": 292,
        "fullcodeline": "if ((imgdata.params.raw_processing_options &"
    },
    {
        "line": 196,
        "fullcodeline": "THUMB_SIZE_CHECKWH(T.twidth, T.theight);"
    },
    {
        "line": 208,
        "fullcodeline": "for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)"
    },
    {
        "line": 209,
        "fullcodeline": "total_size += tiff_ifd[pifd].strip_byte_counts[i];"
    },
    {
        "line": 210,
        "fullcodeline": "if (total_size != (unsigned)t_length) // recalculate colors"
    },
    {
        "line": 227,
        "fullcodeline": "for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&"
    },
    {
        "line": 229,
        "fullcodeline": "i++)"
    },
    {
        "line": 279,
        "fullcodeline": "T.tlength = o_length;"
    },
    {
        "line": 287,
        "fullcodeline": "(ntohs(0x1234) == 0x1234))"
    },
    {
        "line": 288,
        "fullcodeline": "swab((char *)t_thumb, (char *)t_thumb, i_length);"
    },
    {
        "line": 295,
        "fullcodeline": "T.thumb = (char *)t_thumb;"
    },
    {
        "line": 296,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP16;"
    },
    {
        "line": 228,
        "fullcodeline": "i < tiff_ifd[pifd].strip_offsets_count;"
    },
    {
        "line": 231,
        "fullcodeline": "int remain = T.tlength;"
    },
    {
        "line": 300,
        "fullcodeline": "T.thumb = (char *)malloc(o_length);"
    },
    {
        "line": 301,
        "fullcodeline": "merror(T.thumb, \"ppm_thumb()\");"
    },
    {
        "line": 304,
        "fullcodeline": "free(t_thumb);"
    },
    {
        "line": 305,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 212,
        "fullcodeline": "if (total_size == T.twidth * T.tlength * 3)"
    },
    {
        "line": 234,
        "fullcodeline": "if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)"
    },
    {
        "line": 302,
        "fullcodeline": "for (int i = 0; i < o_length; i++)"
    },
    {
        "line": 303,
        "fullcodeline": "T.thumb[i] = t_thumb[i] >> 8;"
    },
    {
        "line": 213,
        "fullcodeline": "T.tcolors = 3;"
    },
    {
        "line": 236,
        "fullcodeline": "ID.input->seek(off, SEEK_SET);"
    },
    {
        "line": 237,
        "fullcodeline": "ID.input->read(dest, sz, 1);"
    },
    {
        "line": 238,
        "fullcodeline": "remain -= sz;"
    },
    {
        "line": 239,
        "fullcodeline": "dest += sz;"
    },
    {
        "line": 214,
        "fullcodeline": "else if (total_size == T.twidth * T.tlength)"
    },
    {
        "line": 215,
        "fullcodeline": "T.tcolors = 1;"
    }
]