[
    {
        "line": 11,
        "fullcodeline": "int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;"
    },
    {
        "line": 12,
        "fullcodeline": "int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;"
    },
    {
        "line": 14,
        "fullcodeline": "if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&"
    },
    {
        "line": 295,
        "fullcodeline": "EXCEPTION_HANDLER(err);"
    },
    {
        "line": 15,
        "fullcodeline": "load_raw == &LibRaw::broadcom_load_raw) // RPi"
    },
    {
        "line": 22,
        "fullcodeline": "kodak_thumb_loader();"
    },
    {
        "line": 23,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 24,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 52,
        "fullcodeline": "ID.input->seek(ID.toffset, SEEK_SET);"
    },
    {
        "line": 53,
        "fullcodeline": "if (write_thumb == &LibRaw::jpeg_thumb)"
    },
    {
        "line": 57,
        "fullcodeline": "T.thumb = (char *)malloc(T.tlength);"
    },
    {
        "line": 58,
        "fullcodeline": "merror(T.thumb, \"jpeg_thumb()\");"
    },
    {
        "line": 59,
        "fullcodeline": "ID.input->read(T.thumb, 1, T.tlength);"
    },
    {
        "line": 60,
        "fullcodeline": "unsigned char *tthumb = (unsigned char *)T.thumb;"
    },
    {
        "line": 61,
        "fullcodeline": "tthumb[0] = 0xff;"
    },
    {
        "line": 62,
        "fullcodeline": "tthumb[1] = 0xd8;"
    },
    {
        "line": 95,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_JPEG;"
    },
    {
        "line": 96,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 69,
        "fullcodeline": "cinfo.err = jpeg_std_error(&jerr.pub);"
    },
    {
        "line": 70,
        "fullcodeline": "jerr.pub.error_exit = jpegErrorExit;"
    },
    {
        "line": 84,
        "fullcodeline": "jpeg_create_decompress(&cinfo);"
    },
    {
        "line": 85,
        "fullcodeline": "jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);"
    },
    {
        "line": 86,
        "fullcodeline": "int rc = jpeg_read_header(&cinfo, TRUE);"
    },
    {
        "line": 89,
        "fullcodeline": "T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)"
    },
    {
        "line": 92,
        "fullcodeline": "jpeg_destroy_decompress(&cinfo);"
    },
    {
        "line": 44,
        "fullcodeline": "if (INT64(ID.toffset) + INT64(T.tlength) < 1)"
    },
    {
        "line": 47,
        "fullcodeline": "if (INT64(ID.toffset) + INT64(T.tlength) >"
    },
    {
        "line": 87,
        "fullcodeline": "if (rc != 1)"
    },
    {
        "line": 99,
        "fullcodeline": "else if (write_thumb == &LibRaw::layer_thumb)"
    },
    {
        "line": 48,
        "fullcodeline": "ID.input->size() + THUMB_READ_BEYOND)"
    },
    {
        "line": 76,
        "fullcodeline": "jpeg_destroy_decompress(&cinfo);"
    },
    {
        "line": 77,
        "fullcodeline": "T.tcolors = 3;"
    },
    {
        "line": 78,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;"
    },
    {
        "line": 79,
        "fullcodeline": "ID.input->seek(ID.toffset, SEEK_SET);"
    },
    {
        "line": 80,
        "fullcodeline": "ID.input->read(T.thumb, 1, T.tlength);"
    },
    {
        "line": 81,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 101,
        "fullcodeline": "int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;"
    },
    {
        "line": 105,
        "fullcodeline": "int tlength = T.twidth * T.theight;"
    },
    {
        "line": 108,
        "fullcodeline": "T.thumb = (char *)calloc(colors, tlength);"
    },
    {
        "line": 109,
        "fullcodeline": "merror(T.thumb, \"layer_thumb()\");"
    },
    {
        "line": 110,
        "fullcodeline": "unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);"
    },
    {
        "line": 111,
        "fullcodeline": "merror(tbuf, \"layer_thumb()\");"
    },
    {
        "line": 112,
        "fullcodeline": "ID.input->read(tbuf, colors, T.tlength);"
    },
    {
        "line": 136,
        "fullcodeline": "T.tcolors = colors;"
    },
    {
        "line": 137,
        "fullcodeline": "T.tlength = colors * tlength;"
    },
    {
        "line": 138,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 139,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 102,
        "fullcodeline": "if (colors != 1 && colors != 3)"
    },
    {
        "line": 113,
        "fullcodeline": "if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&"
    },
    {
        "line": 114,
        "fullcodeline": "colors == 3) // GRB order"
    },
    {
        "line": 135,
        "fullcodeline": "free(tbuf);"
    },
    {
        "line": 142,
        "fullcodeline": "else if (write_thumb == &LibRaw::rollei_thumb)"
    },
    {
        "line": 115,
        "fullcodeline": "for (int i = 0; i < tlength; i++)"
    },
    {
        "line": 145,
        "fullcodeline": "int tlength = T.twidth * T.theight;"
    },
    {
        "line": 148,
        "fullcodeline": "T.tcolors = 3;"
    },
    {
        "line": 149,
        "fullcodeline": "T.thumb = (char *)calloc(T.tcolors, tlength);"
    },
    {
        "line": 150,
        "fullcodeline": "merror(T.thumb, \"layer_thumb()\");"
    },
    {
        "line": 151,
        "fullcodeline": "unsigned short *tbuf = (unsigned short *)calloc(2, tlength);"
    },
    {
        "line": 152,
        "fullcodeline": "merror(tbuf, \"layer_thumb()\");"
    },
    {
        "line": 153,
        "fullcodeline": "read_shorts(tbuf, tlength);"
    },
    {
        "line": 160,
        "fullcodeline": "free(tbuf);"
    },
    {
        "line": 161,
        "fullcodeline": "T.tlength = T.tcolors * tlength;"
    },
    {
        "line": 162,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 163,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 117,
        "fullcodeline": "T.thumb[i * 3] = tbuf[i + tlength];"
    },
    {
        "line": 118,
        "fullcodeline": "T.thumb[i * 3 + 1] = tbuf[i];"
    },
    {
        "line": 119,
        "fullcodeline": "T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];"
    },
    {
        "line": 121,
        "fullcodeline": "else if (colors == 3) // RGB or 1-channel"
    },
    {
        "line": 154,
        "fullcodeline": "for (i = 0; i < tlength; i++)"
    },
    {
        "line": 156,
        "fullcodeline": "T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;"
    },
    {
        "line": 157,
        "fullcodeline": "T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;"
    },
    {
        "line": 158,
        "fullcodeline": "T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;"
    },
    {
        "line": 166,
        "fullcodeline": "else if (write_thumb == &LibRaw::ppm_thumb)"
    },
    {
        "line": 122,
        "fullcodeline": "for (int i = 0; i < tlength; i++)"
    },
    {
        "line": 171,
        "fullcodeline": "int t_length = T.twidth * T.theight * t_colors;"
    },
    {
        "line": 227,
        "fullcodeline": "T.thumb = (char *)malloc(T.tlength);"
    },
    {
        "line": 230,
        "fullcodeline": "merror(T.thumb, \"ppm_thumb()\");"
    },
    {
        "line": 232,
        "fullcodeline": "ID.input->read(T.thumb, 1, T.tlength);"
    },
    {
        "line": 234,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 235,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 124,
        "fullcodeline": "T.thumb[i * 3] = tbuf[i];"
    },
    {
        "line": 125,
        "fullcodeline": "T.thumb[i * 3 + 1] = tbuf[i + tlength];"
    },
    {
        "line": 126,
        "fullcodeline": "T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];"
    },
    {
        "line": 128,
        "fullcodeline": "else if (colors == 1)"
    },
    {
        "line": 168,
        "fullcodeline": "if (t_bytesps > 1)"
    },
    {
        "line": 173,
        "fullcodeline": "if (T.tlength &&"
    },
    {
        "line": 222,
        "fullcodeline": "if (!T.tlength)"
    },
    {
        "line": 228,
        "fullcodeline": "if (!T.tcolors)"
    },
    {
        "line": 130,
        "fullcodeline": "free(T.thumb);"
    },
    {
        "line": 131,
        "fullcodeline": "T.thumb = (char *)tbuf;"
    },
    {
        "line": 132,
        "fullcodeline": "tbuf = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "(int)T.tlength < t_length) // try to find tiff ifd with needed offset"
    },
    {
        "line": 176,
        "fullcodeline": "int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);"
    },
    {
        "line": 223,
        "fullcodeline": "T.tlength = t_length;"
    },
    {
        "line": 225,
        "fullcodeline": "free(T.thumb);"
    },
    {
        "line": 229,
        "fullcodeline": "T.tcolors = t_colors;"
    },
    {
        "line": 238,
        "fullcodeline": "else if (write_thumb == &LibRaw::ppm16_thumb)"
    },
    {
        "line": 177,
        "fullcodeline": "if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&"
    },
    {
        "line": 243,
        "fullcodeline": "int o_bps = (imgdata.params.raw_processing_options &"
    },
    {
        "line": 247,
        "fullcodeline": "int o_length = T.twidth * T.theight * t_colors * o_bps;"
    },
    {
        "line": 248,
        "fullcodeline": "int i_length = T.twidth * T.theight * t_colors * 2;"
    },
    {
        "line": 251,
        "fullcodeline": "ushort *t_thumb = (ushort *)calloc(i_length, 1);"
    },
    {
        "line": 252,
        "fullcodeline": "ID.input->read(t_thumb, 1, i_length);"
    },
    {
        "line": 274,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 181,
        "fullcodeline": "unsigned total_size = 0;"
    },
    {
        "line": 191,
        "fullcodeline": "T.tlength = total_size;"
    },
    {
        "line": 194,
        "fullcodeline": "T.thumb = (char *)malloc(T.tlength);"
    },
    {
        "line": 195,
        "fullcodeline": "merror(T.thumb, \"ppm_thumb()\");"
    },
    {
        "line": 197,
        "fullcodeline": "char *dest = T.thumb;"
    },
    {
        "line": 198,
        "fullcodeline": "INT64 pos = ID.input->tell();"
    },
    {
        "line": 215,
        "fullcodeline": "ID.input->seek(pos, SEEK_SET);"
    },
    {
        "line": 216,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 217,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);"
    },
    {
        "line": 240,
        "fullcodeline": "if (t_bytesps > 2)"
    },
    {
        "line": 249,
        "fullcodeline": "if (!T.tlength)"
    },
    {
        "line": 253,
        "fullcodeline": "if ((libraw_internal_data.unpacker_data.order == 0x4949) =="
    },
    {
        "line": 259,
        "fullcodeline": "if ((imgdata.params.raw_processing_options &"
    },
    {
        "line": 182,
        "fullcodeline": "for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)"
    },
    {
        "line": 183,
        "fullcodeline": "total_size += tiff_ifd[pifd].strip_byte_counts[i];"
    },
    {
        "line": 184,
        "fullcodeline": "if (total_size != (unsigned)t_length) // recalculate colors"
    },
    {
        "line": 200,
        "fullcodeline": "for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&"
    },
    {
        "line": 202,
        "fullcodeline": "i++)"
    },
    {
        "line": 250,
        "fullcodeline": "T.tlength = o_length;"
    },
    {
        "line": 254,
        "fullcodeline": "(ntohs(0x1234) == 0x1234))"
    },
    {
        "line": 255,
        "fullcodeline": "swab((char *)t_thumb, (char *)t_thumb, i_length);"
    },
    {
        "line": 262,
        "fullcodeline": "T.thumb = (char *)t_thumb;"
    },
    {
        "line": 263,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP16;"
    },
    {
        "line": 201,
        "fullcodeline": "i < tiff_ifd[pifd].strip_offsets_count;"
    },
    {
        "line": 204,
        "fullcodeline": "int remain = T.tlength;"
    },
    {
        "line": 267,
        "fullcodeline": "T.thumb = (char *)malloc(o_length);"
    },
    {
        "line": 268,
        "fullcodeline": "merror(T.thumb, \"ppm_thumb()\");"
    },
    {
        "line": 271,
        "fullcodeline": "free(t_thumb);"
    },
    {
        "line": 272,
        "fullcodeline": "T.tformat = LIBRAW_THUMBNAIL_BITMAP;"
    },
    {
        "line": 186,
        "fullcodeline": "if (total_size == T.twidth * T.tlength * 3)"
    },
    {
        "line": 207,
        "fullcodeline": "if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)"
    },
    {
        "line": 269,
        "fullcodeline": "for (int i = 0; i < o_length; i++)"
    },
    {
        "line": 270,
        "fullcodeline": "T.thumb[i] = t_thumb[i] >> 8;"
    },
    {
        "line": 187,
        "fullcodeline": "T.tcolors = 3;"
    },
    {
        "line": 209,
        "fullcodeline": "ID.input->seek(off, SEEK_SET);"
    },
    {
        "line": 210,
        "fullcodeline": "ID.input->read(dest, sz, 1);"
    },
    {
        "line": 211,
        "fullcodeline": "remain -= sz;"
    },
    {
        "line": 212,
        "fullcodeline": "dest += sz;"
    },
    {
        "line": 188,
        "fullcodeline": "else if (total_size == T.twidth * T.tlength)"
    },
    {
        "line": 189,
        "fullcodeline": "T.tcolors = 1;"
    }
]