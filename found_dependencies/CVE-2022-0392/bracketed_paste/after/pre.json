[
    {
        "line": 4,
        "fullcodeline": "char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];"
    },
    {
        "line": 5,
        "fullcodeline": "int\t\tidx = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "char_u\t*end = find_termcode((char_u *)\"PE\");"
    },
    {
        "line": 7,
        "fullcodeline": "int\t\tret_char = -1;"
    },
    {
        "line": 8,
        "fullcodeline": "int\t\tsave_allow_keys = allow_keys;"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tsave_paste = p_paste;"
    },
    {
        "line": 14,
        "fullcodeline": "++no_mapping;"
    },
    {
        "line": 15,
        "fullcodeline": "allow_keys = 0;"
    },
    {
        "line": 91,
        "fullcodeline": "--no_mapping;"
    },
    {
        "line": 92,
        "fullcodeline": "allow_keys = save_allow_keys;"
    },
    {
        "line": 12,
        "fullcodeline": "if (end != NULL && STRLEN(end) >= NUMBUFLEN)"
    },
    {
        "line": 16,
        "fullcodeline": "if (!p_paste)"
    },
    {
        "line": 93,
        "fullcodeline": "if (!save_paste)"
    },
    {
        "line": 13,
        "fullcodeline": "end = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "set_option_value((char_u *)\"paste\", TRUE, NULL, 0);"
    },
    {
        "line": 38,
        "fullcodeline": "buf[idx] = NUL;"
    },
    {
        "line": 88,
        "fullcodeline": "idx = 0;"
    },
    {
        "line": 94,
        "fullcodeline": "set_option_value((char_u *)\"paste\", FALSE, NULL, 0);"
    },
    {
        "line": 24,
        "fullcodeline": "if (end == NULL && vpeekc() == NUL)"
    },
    {
        "line": 27,
        "fullcodeline": "c = vgetc();"
    },
    {
        "line": 28,
        "fullcodeline": "while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);"
    },
    {
        "line": 29,
        "fullcodeline": "if (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))"
    },
    {
        "line": 39,
        "fullcodeline": "if (end != NULL && STRNCMP(buf, end, idx) == 0)"
    },
    {
        "line": 45,
        "fullcodeline": "if (!drop)"
    },
    {
        "line": 35,
        "fullcodeline": "idx += (*mb_char2bytes)(c, buf + idx);"
    },
    {
        "line": 37,
        "fullcodeline": "buf[idx++] = c;"
    },
    {
        "line": 41,
        "fullcodeline": "if (end[idx] == NUL)"
    },
    {
        "line": 50,
        "fullcodeline": "put_on_cmdline(buf, idx, TRUE);"
    },
    {
        "line": 55,
        "fullcodeline": "if (gap != NULL && ga_grow(gap, idx + 1) == OK)"
    },
    {
        "line": 64,
        "fullcodeline": "if (stop_arrow() == OK)"
    },
    {
        "line": 78,
        "fullcodeline": "if (ret_char == -1)"
    },
    {
        "line": 57,
        "fullcodeline": "mch_memmove((char *)gap->ga_data + gap->ga_len,"
    },
    {
        "line": 59,
        "fullcodeline": "gap->ga_len += idx;"
    },
    {
        "line": 66,
        "fullcodeline": "c = buf[0];"
    },
    {
        "line": 67,
        "fullcodeline": "if (idx == 1 && (c == CAR || c == K_KENTER || c == NL))"
    },
    {
        "line": 68,
        "fullcodeline": "ins_eol(c);"
    },
    {
        "line": 81,
        "fullcodeline": "ret_char = (*mb_ptr2char)(buf);"
    },
    {
        "line": 71,
        "fullcodeline": "ins_char_bytes(buf, idx);"
    },
    {
        "line": 72,
        "fullcodeline": "AppendToRedobuffLit(buf, idx);"
    },
    {
        "line": 83,
        "fullcodeline": "ret_char = buf[0];"
    }
]