[
    {
        "line": 3,
        "fullcodeline": "const struct io_op_def *def = &io_op_defs[req->opcode];"
    },
    {
        "line": 4,
        "fullcodeline": "struct io_ring_ctx *ctx = req->ctx;"
    },
    {
        "line": 6,
        "fullcodeline": "io_req_init_async(req);"
    },
    {
        "line": 8,
        "fullcodeline": "if (req->flags & REQ_F_ISREG) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (!(req->work.flags & IO_WQ_WORK_FILES) &&"
    },
    {
        "line": 28,
        "fullcodeline": "if (!(req->work.flags & IO_WQ_WORK_MM) &&"
    },
    {
        "line": 48,
        "fullcodeline": "if (!(req->work.flags & IO_WQ_WORK_CREDS)) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (!(req->work.flags & IO_WQ_WORK_FS) &&"
    },
    {
        "line": 17,
        "fullcodeline": "!(req->flags & REQ_F_NO_FILE_TABLE)) {"
    },
    {
        "line": 18,
        "fullcodeline": "req->work.identity->files = get_files_struct(current);"
    },
    {
        "line": 19,
        "fullcodeline": "get_nsproxy(current->nsproxy);"
    },
    {
        "line": 20,
        "fullcodeline": "req->work.identity->nsproxy = current->nsproxy;"
    },
    {
        "line": 21,
        "fullcodeline": "req->flags |= REQ_F_INFLIGHT;"
    },
    {
        "line": 23,
        "fullcodeline": "spin_lock_irq(&ctx->inflight_lock);"
    },
    {
        "line": 24,
        "fullcodeline": "list_add(&req->inflight_entry, &ctx->inflight_list);"
    },
    {
        "line": 25,
        "fullcodeline": "spin_unlock_irq(&ctx->inflight_lock);"
    },
    {
        "line": 26,
        "fullcodeline": "req->work.flags |= IO_WQ_WORK_FILES;"
    },
    {
        "line": 29,
        "fullcodeline": "(def->work_flags & IO_WQ_WORK_MM)) {"
    },
    {
        "line": 30,
        "fullcodeline": "mmgrab(current->mm);"
    },
    {
        "line": 31,
        "fullcodeline": "req->work.identity->mm = current->mm;"
    },
    {
        "line": 32,
        "fullcodeline": "req->work.flags |= IO_WQ_WORK_MM;"
    },
    {
        "line": 49,
        "fullcodeline": "req->work.identity->creds = get_current_cred();"
    },
    {
        "line": 50,
        "fullcodeline": "req->work.flags |= IO_WQ_WORK_CREDS;"
    },
    {
        "line": 53,
        "fullcodeline": "(def->work_flags & IO_WQ_WORK_FS)) {"
    },
    {
        "line": 54,
        "fullcodeline": "spin_lock(&current->fs->lock);"
    },
    {
        "line": 62,
        "fullcodeline": "spin_unlock(&current->fs->lock);"
    },
    {
        "line": 65,
        "fullcodeline": "req->work.identity->fsize = rlimit(RLIMIT_FSIZE);"
    },
    {
        "line": 9,
        "fullcodeline": "if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))"
    },
    {
        "line": 16,
        "fullcodeline": "(io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&"
    },
    {
        "line": 55,
        "fullcodeline": "if (!current->fs->in_exec) {"
    },
    {
        "line": 67,
        "fullcodeline": "req->work.identity->fsize = RLIM_INFINITY;"
    },
    {
        "line": 10,
        "fullcodeline": "io_wq_hash_work(&req->work, file_inode(req->file));"
    },
    {
        "line": 56,
        "fullcodeline": "req->work.identity->fs = current->fs;"
    },
    {
        "line": 57,
        "fullcodeline": "req->work.identity->fs->users++;"
    },
    {
        "line": 58,
        "fullcodeline": "req->work.flags |= IO_WQ_WORK_FS;"
    },
    {
        "line": 13,
        "fullcodeline": "req->work.flags |= IO_WQ_WORK_UNBOUND;"
    },
    {
        "line": 60,
        "fullcodeline": "req->work.flags |= IO_WQ_WORK_CANCEL;"
    }
]