[
    {
        "line": 5,
        "fullcodeline": "unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;"
    },
    {
        "line": 6,
        "fullcodeline": "struct mschmd_file *fi, *link = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "chm->files         = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "chm->sysfiles      = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "chm->chunk_cache   = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "chm->sec0.base.chm = chm;"
    },
    {
        "line": 15,
        "fullcodeline": "chm->sec0.base.id  = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "chm->sec1.base.chm = chm;"
    },
    {
        "line": 17,
        "fullcodeline": "chm->sec1.base.id  = 1;"
    },
    {
        "line": 18,
        "fullcodeline": "chm->sec1.content  = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "chm->sec1.control  = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "chm->sec1.spaninfo = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "chm->sec1.rtable   = NULL;"
    },
    {
        "line": 39,
        "fullcodeline": "chm->version   = EndGetI32(&buf[chmhead_Version]);"
    },
    {
        "line": 40,
        "fullcodeline": "chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);"
    },
    {
        "line": 41,
        "fullcodeline": "chm->language  = EndGetI32(&buf[chmhead_LanguageID]);"
    },
    {
        "line": 84,
        "fullcodeline": "chm->dir_offset = sys->tell(fh);"
    },
    {
        "line": 85,
        "fullcodeline": "chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);"
    },
    {
        "line": 86,
        "fullcodeline": "chm->density    = EndGetI32(&buf[chmhs1_Density]);"
    },
    {
        "line": 87,
        "fullcodeline": "chm->depth      = EndGetI32(&buf[chmhs1_Depth]);"
    },
    {
        "line": 88,
        "fullcodeline": "chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);"
    },
    {
        "line": 89,
        "fullcodeline": "chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);"
    },
    {
        "line": 90,
        "fullcodeline": "chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);"
    },
    {
        "line": 91,
        "fullcodeline": "chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);"
    },
    {
        "line": 155,
        "fullcodeline": "num_chunks = chm->last_pmgl - x + 1;"
    },
    {
        "line": 162,
        "fullcodeline": "errors = 0;"
    },
    {
        "line": 255,
        "fullcodeline": "sys->free(chunk);"
    },
    {
        "line": 24,
        "fullcodeline": "if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {"
    },
    {
        "line": 42,
        "fullcodeline": "if (chm->version > 3) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||"
    },
    {
        "line": 62,
        "fullcodeline": "if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (chm->version < 3) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (chm->sec0.offset > chm->length) {"
    },
    {
        "line": 106,
        "fullcodeline": "if (chm->chunk_size < (pmgl_Entries + 2)) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (chm->num_chunks == 0) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (chm->num_chunks > 100000) {"
    },
    {
        "line": 123,
        "fullcodeline": "if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {"
    },
    {
        "line": 129,
        "fullcodeline": "if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {"
    },
    {
        "line": 132,
        "fullcodeline": "if (chm->first_pmgl != 0) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (chm->first_pmgl > chm->last_pmgl) {"
    },
    {
        "line": 139,
        "fullcodeline": "if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (!entire) {"
    },
    {
        "line": 150,
        "fullcodeline": "if ((x = chm->first_pmgl) != 0) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {"
    },
    {
        "line": 163,
        "fullcodeline": "while (num_chunks--) {"
    },
    {
        "line": 256,
        "fullcodeline": "return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;"
    },
    {
        "line": 35,
        "fullcodeline": "D((\"incorrect GUIDs\"))"
    },
    {
        "line": 43,
        "fullcodeline": "sys->message(fh, \"WARNING; CHM version > 3\");"
    },
    {
        "line": 56,
        "fullcodeline": "read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))"
    },
    {
        "line": 95,
        "fullcodeline": "chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);"
    },
    {
        "line": 100,
        "fullcodeline": "D((\"content section begins after file has ended\"))"
    },
    {
        "line": 107,
        "fullcodeline": "D((\"chunk size not large enough\"))"
    },
    {
        "line": 111,
        "fullcodeline": "D((\"no chunks\"))"
    },
    {
        "line": 120,
        "fullcodeline": "D((\"more than 100,000 chunks\"))"
    },
    {
        "line": 124,
        "fullcodeline": "D((\"chunks larger than entire file\"))"
    },
    {
        "line": 130,
        "fullcodeline": "sys->message(fh, \"WARNING; chunk size is not a power of two\");"
    },
    {
        "line": 133,
        "fullcodeline": "sys->message(fh, \"WARNING; first PMGL chunk is not zero\");"
    },
    {
        "line": 136,
        "fullcodeline": "D((\"first pmgl chunk is after last pmgl chunk\"))"
    },
    {
        "line": 140,
        "fullcodeline": "D((\"index_root outside valid range\"))"
    },
    {
        "line": 184,
        "fullcodeline": "num_entries = EndGetI16(end);"
    },
    {
        "line": 55,
        "fullcodeline": "read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||"
    },
    {
        "line": 151,
        "fullcodeline": "if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {"
    },
    {
        "line": 171,
        "fullcodeline": "if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;"
    },
    {
        "line": 173,
        "fullcodeline": "if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {"
    },
    {
        "line": 176,
        "fullcodeline": "if (EndGetI32(&chunk[pmgl_QuickRefSize]) >"
    },
    {
        "line": 186,
        "fullcodeline": "while (num_entries--) {"
    },
    {
        "line": 249,
        "fullcodeline": "if (num_entries >= 0) {"
    },
    {
        "line": 166,
        "fullcodeline": "sys->free(chunk);"
    },
    {
        "line": 174,
        "fullcodeline": "sys->message(fh, \"WARNING; PMGL quickref area is too small\");"
    },
    {
        "line": 177,
        "fullcodeline": "((int)chm->chunk_size - pmgl_Entries))"
    },
    {
        "line": 179,
        "fullcodeline": "sys->message(fh, \"WARNING; PMGL quickref area is too large\");"
    },
    {
        "line": 187,
        "fullcodeline": "READ_ENCINT(name_len);"
    },
    {
        "line": 189,
        "fullcodeline": "name = p; p += name_len;"
    },
    {
        "line": 190,
        "fullcodeline": "READ_ENCINT(section);"
    },
    {
        "line": 191,
        "fullcodeline": "READ_ENCINT(offset);"
    },
    {
        "line": 192,
        "fullcodeline": "READ_ENCINT(length);"
    },
    {
        "line": 211,
        "fullcodeline": "fi->next     = NULL;"
    },
    {
        "line": 212,
        "fullcodeline": "fi->filename = (char *) &fi[1];"
    },
    {
        "line": 213,
        "fullcodeline": "fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)"
    },
    {
        "line": 215,
        "fullcodeline": "fi->offset   = offset;"
    },
    {
        "line": 216,
        "fullcodeline": "fi->length   = length;"
    },
    {
        "line": 217,
        "fullcodeline": "sys->copy(name, fi->filename, (size_t) name_len);"
    },
    {
        "line": 218,
        "fullcodeline": "fi->filename[name_len] = '\\0';"
    },
    {
        "line": 250,
        "fullcodeline": "D((\"chunk ended before all entries could be read\"))"
    },
    {
        "line": 251,
        "fullcodeline": "errors++;"
    },
    {
        "line": 183,
        "fullcodeline": "end = &chunk[chm->chunk_size - 2];"
    },
    {
        "line": 188,
        "fullcodeline": "if (name_len > (unsigned int) (end - p)) goto chunk_end;"
    },
    {
        "line": 197,
        "fullcodeline": "if ((offset == 0) && (length == 0)) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (section > 1) {"
    },
    {
        "line": 206,
        "fullcodeline": "if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {"
    },
    {
        "line": 220,
        "fullcodeline": "if (name[0] == ':' && name[1] == ':') {"
    },
    {
        "line": 202,
        "fullcodeline": "sys->message(fh, \"invalid section number '%u'.\", section);"
    },
    {
        "line": 207,
        "fullcodeline": "sys->free(chunk);"
    },
    {
        "line": 214,
        "fullcodeline": ": (struct mschmd_section *) (&chm->sec1));"
    },
    {
        "line": 236,
        "fullcodeline": "fi->next = chm->sysfiles;"
    },
    {
        "line": 237,
        "fullcodeline": "chm->sysfiles = fi;"
    },
    {
        "line": 198,
        "fullcodeline": "if ((name_len > 0) && (name[name_len-1] == '/')) continue;"
    },
    {
        "line": 222,
        "fullcodeline": "if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {"
    },
    {
        "line": 242,
        "fullcodeline": "link = fi;"
    },
    {
        "line": 223,
        "fullcodeline": "if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {"
    },
    {
        "line": 241,
        "fullcodeline": "if (link) link->next = fi; else chm->files = fi;"
    },
    {
        "line": 224,
        "fullcodeline": "chm->sec1.content = fi;"
    },
    {
        "line": 226,
        "fullcodeline": "else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {"
    },
    {
        "line": 227,
        "fullcodeline": "chm->sec1.control = fi;"
    },
    {
        "line": 229,
        "fullcodeline": "else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {"
    },
    {
        "line": 230,
        "fullcodeline": "chm->sec1.spaninfo = fi;"
    },
    {
        "line": 232,
        "fullcodeline": "else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {"
    },
    {
        "line": 233,
        "fullcodeline": "chm->sec1.rtable = fi;"
    }
]