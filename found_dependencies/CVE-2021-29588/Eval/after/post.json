[
    {
        "line": 4,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 7,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 10,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 12,
        "fullcodeline": "const TfLiteTensor* bias ="
    },
    {
        "line": 17,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 19,
        "fullcodeline": "OpData* data = reinterpret_cast<OpData*>(node->user_data);"
    },
    {
        "line": 20,
        "fullcodeline": "TfLiteTensor* col2im = data->has_col2im"
    },
    {
        "line": 23,
        "fullcodeline": "TfLiteTensor* transposed_weights ="
    },
    {
        "line": 27,
        "fullcodeline": "const auto* params ="
    },
    {
        "line": 31,
        "fullcodeline": "TF_LITE_ENSURE(context, params->stride_height > 0);"
    },
    {
        "line": 32,
        "fullcodeline": "TF_LITE_ENSURE(context, params->stride_width > 0);"
    },
    {
        "line": 44,
        "fullcodeline": "const int width = SizeOfDimension(output, 2);"
    },
    {
        "line": 45,
        "fullcodeline": "const int height = SizeOfDimension(output, 1);"
    },
    {
        "line": 46,
        "fullcodeline": "const int filter_width = SizeOfDimension(weights, 2);"
    },
    {
        "line": 47,
        "fullcodeline": "const int filter_height = SizeOfDimension(weights, 1);"
    },
    {
        "line": 50,
        "fullcodeline": "data->padding = ComputePaddingHeightWidth("
    },
    {
        "line": 5,
        "fullcodeline": "context, GetInputSafe(context, node, kOutputShapeTensor, &output_shape));"
    },
    {
        "line": 8,
        "fullcodeline": "GetInputSafe(context, node, kWeightsTensor, &weights));"
    },
    {
        "line": 11,
        "fullcodeline": "GetInputSafe(context, node, kDataInputTensor, &input));"
    },
    {
        "line": 13,
        "fullcodeline": "(NumInputs(node) == 4)"
    },
    {
        "line": 18,
        "fullcodeline": "GetOutputSafe(context, node, kOutputTensor, &output));"
    },
    {
        "line": 24,
        "fullcodeline": "data->weights_are_transposed"
    },
    {
        "line": 28,
        "fullcodeline": "reinterpret_cast<TfLiteTransposeConvParams*>(node->builtin_data);"
    },
    {
        "line": 35,
        "fullcodeline": "if (IsDynamicTensor(output)) {"
    },
    {
        "line": 38,
        "fullcodeline": "if (data->has_col2im && IsDynamicTensor(col2im)) {"
    },
    {
        "line": 14,
        "fullcodeline": "? GetOptionalInputTensor(context, node, kBiasTensor)"
    },
    {
        "line": 21,
        "fullcodeline": "? GetTemporary(context, node, data->col2im_index)"
    },
    {
        "line": 25,
        "fullcodeline": "? GetTemporary(context, node, data->transposed_weights_index)"
    },
    {
        "line": 36,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, ResizeTensor(context, output_shape, output));"
    },
    {
        "line": 39,
        "fullcodeline": "TF_LITE_ENSURE_OK(context, ResizeCol2ImTensor(context, output_shape,"
    },
    {
        "line": 122,
        "fullcodeline": "context->ReportError(context, \"Type '%s' is not currently supported.\","
    },
    {
        "line": 64,
        "fullcodeline": "EvalFloat<kernel_type>(context, params, data, input, weights, bias,"
    },
    {
        "line": 70,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 82,
        "fullcodeline": "EvalQuantized<kernel_type>(context, params, data, input, weights,"
    },
    {
        "line": 89,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 99,
        "fullcodeline": "EvalQuantizedPerChannel<kernel_type>(context, params, data, input,"
    },
    {
        "line": 106,
        "fullcodeline": "TF_LITE_ENSURE_OK("
    },
    {
        "line": 116,
        "fullcodeline": "EvalQuantizedPerChannel16x8(context, params, data, input, weights,"
    },
    {
        "line": 123,
        "fullcodeline": "TfLiteTypeGetName(input->type));"
    },
    {
        "line": 71,
        "fullcodeline": "context, GetTemporarySafe(context, node, data->scratch_tensor_index,"
    },
    {
        "line": 73,
        "fullcodeline": "if (IsDynamicTensor(scratch_buffer)) {"
    },
    {
        "line": 90,
        "fullcodeline": "context, GetTemporarySafe(context, node, data->scratch_tensor_index,"
    },
    {
        "line": 92,
        "fullcodeline": "if (IsDynamicTensor(scratch_buffer)) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (data->weights_are_transposed && !IsConstantTensor(weights)) {"
    },
    {
        "line": 107,
        "fullcodeline": "context, GetTemporarySafe(context, node, data->scratch_tensor_index,"
    },
    {
        "line": 109,
        "fullcodeline": "if (IsDynamicTensor(scratch_buffer)) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (data->weights_are_transposed && !IsConstantTensor(weights)) {"
    },
    {
        "line": 74,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 93,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 97,
        "fullcodeline": "ResizeAndTransposeWeights(context, weights, transposed_weights);"
    },
    {
        "line": 110,
        "fullcodeline": "TF_LITE_ENSURE_OK(context,"
    },
    {
        "line": 114,
        "fullcodeline": "ResizeAndTransposeWeights(context, weights, transposed_weights);"
    },
    {
        "line": 60,
        "fullcodeline": "if (!IsConstantTensor(weights)) {"
    },
    {
        "line": 75,
        "fullcodeline": "ResizeTensor(context, output_shape, scratch_buffer));"
    },
    {
        "line": 78,
        "fullcodeline": "if (!IsConstantTensor(weights)) {"
    },
    {
        "line": 94,
        "fullcodeline": "ResizeTensor(context, output_shape, scratch_buffer));"
    },
    {
        "line": 111,
        "fullcodeline": "ResizeTensor(context, output_shape, scratch_buffer));"
    },
    {
        "line": 61,
        "fullcodeline": "ResizeAndTransposeWeights(context, weights, transposed_weights);"
    },
    {
        "line": 79,
        "fullcodeline": "ResizeAndTransposeWeights(context, weights, transposed_weights);"
    }
]