[
    {
        "line": 4,
        "fullcodeline": "struct ndpi_packet_struct *packet = &flow->packet;"
    },
    {
        "line": 5,
        "fullcodeline": "u_int num_found = 0, i;"
    },
    {
        "line": 6,
        "fullcodeline": "char buffer[64] = { '\\0' }, rdnSeqBuf[1024] = { '\\0' };"
    },
    {
        "line": 7,
        "fullcodeline": "u_int rdn_len = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "for(i = p_offset; i < certificate_len; i++) {"
    },
    {
        "line": 245,
        "fullcodeline": "if(flow->protos.stun_ssl.ssl.subjectDN && flow->protos.stun_ssl.ssl.issuerDN"
    },
    {
        "line": 243,
        "fullcodeline": "if(rdn_len) flow->protos.stun_ssl.ssl.subjectDN = ndpi_strdup(rdnSeqBuf);"
    },
    {
        "line": 246,
        "fullcodeline": "&& (!strcmp(flow->protos.stun_ssl.ssl.subjectDN, flow->protos.stun_ssl.ssl.issuerDN)))"
    },
    {
        "line": 247,
        "fullcodeline": "NDPI_SET_BIT(flow->risk, NDPI_TLS_SELFSIGNED_CERTIFICATE);"
    },
    {
        "line": 19,
        "fullcodeline": "if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03)) {"
    },
    {
        "line": 21,
        "fullcodeline": "int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"CN\");"
    },
    {
        "line": 22,
        "fullcodeline": "if(rc == -1) break;"
    },
    {
        "line": 27,
        "fullcodeline": "} else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x06)) {"
    },
    {
        "line": 29,
        "fullcodeline": "int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"C\");"
    },
    {
        "line": 30,
        "fullcodeline": "if(rc == -1) break;"
    },
    {
        "line": 35,
        "fullcodeline": "} else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x07)) {"
    },
    {
        "line": 37,
        "fullcodeline": "int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"L\");"
    },
    {
        "line": 38,
        "fullcodeline": "if(rc == -1) break;"
    },
    {
        "line": 43,
        "fullcodeline": "} else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x08)) {"
    },
    {
        "line": 45,
        "fullcodeline": "int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"ST\");"
    },
    {
        "line": 46,
        "fullcodeline": "if(rc == -1) break;"
    },
    {
        "line": 51,
        "fullcodeline": "} else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0a)) {"
    },
    {
        "line": 53,
        "fullcodeline": "int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"O\");"
    },
    {
        "line": 54,
        "fullcodeline": "if(rc == -1) break;"
    },
    {
        "line": 60,
        "fullcodeline": "} else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0b)) {"
    },
    {
        "line": 62,
        "fullcodeline": "int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"OU\");"
    },
    {
        "line": 63,
        "fullcodeline": "if(rc == -1) break;"
    },
    {
        "line": 68,
        "fullcodeline": "} else if((packet->payload[i] == 0x30) && (packet->payload[i+1] == 0x1e) && (packet->payload[i+2] == 0x17)) {"
    },
    {
        "line": 70,
        "fullcodeline": "u_int8_t len = packet->payload[i+3];"
    },
    {
        "line": 71,
        "fullcodeline": "u_int offset = i+4;"
    },
    {
        "line": 73,
        "fullcodeline": "if(num_found == 0) {"
    },
    {
        "line": 84,
        "fullcodeline": "if((offset+len) < packet->payload_packet_len) {"
    },
    {
        "line": 74,
        "fullcodeline": "num_found++;"
    },
    {
        "line": 81,
        "fullcodeline": "rdn_len = 0; /* Reset buffer */"
    },
    {
        "line": 85,
        "fullcodeline": "char utcDate[32];"
    },
    {
        "line": 112,
        "fullcodeline": "offset += len;"
    },
    {
        "line": 153,
        "fullcodeline": "} else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x1d) && (packet->payload[i+2] == 0x11)) {"
    },
    {
        "line": 95,
        "fullcodeline": "if(len < (sizeof(utcDate)-1)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if((offset+1) < packet->payload_packet_len) {"
    },
    {
        "line": 155,
        "fullcodeline": "u_int8_t matched_name = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "i += 3 /* skip the initial patten 55 1D 11 */;"
    },
    {
        "line": 162,
        "fullcodeline": "i++; /* skip the first type, 0x04 == BIT STRING, and jump to it's length */"
    },
    {
        "line": 80,
        "fullcodeline": "if(rdn_len) flow->protos.stun_ssl.ssl.issuerDN = ndpi_strdup(rdnSeqBuf);"
    },
    {
        "line": 97,
        "fullcodeline": "utc.tm_isdst = -1; /* Not set by strptime */"
    },
    {
        "line": 99,
        "fullcodeline": "strncpy(utcDate, (const char*)&packet->payload[i+4], len);"
    },
    {
        "line": 100,
        "fullcodeline": "utcDate[len] = '\\0';"
    },
    {
        "line": 115,
        "fullcodeline": "len = packet->payload[offset+1];"
    },
    {
        "line": 117,
        "fullcodeline": "offset += 2;"
    },
    {
        "line": 163,
        "fullcodeline": "if(i < packet->payload_packet_len) {"
    },
    {
        "line": 103,
        "fullcodeline": "if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {"
    },
    {
        "line": 119,
        "fullcodeline": "if((offset+len) < packet->payload_packet_len) {"
    },
    {
        "line": 164,
        "fullcodeline": "i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip BIT STRING length */"
    },
    {
        "line": 104,
        "fullcodeline": "flow->protos.stun_ssl.ssl.notBefore = timegm(&utc);"
    },
    {
        "line": 120,
        "fullcodeline": "u_int32_t time_sec = flow->packet.current_time_ms / 1000;"
    },
    {
        "line": 165,
        "fullcodeline": "if(i < packet->payload_packet_len) {"
    },
    {
        "line": 129,
        "fullcodeline": "if(len < (sizeof(utcDate)-1)) {"
    },
    {
        "line": 147,
        "fullcodeline": "if((time_sec < flow->protos.stun_ssl.ssl.notBefore)"
    },
    {
        "line": 166,
        "fullcodeline": "i += 2; /* skip the second type, 0x30 == SEQUENCE, and jump to it's length */"
    },
    {
        "line": 131,
        "fullcodeline": "utc.tm_isdst = -1; /* Not set by strptime */"
    },
    {
        "line": 133,
        "fullcodeline": "strncpy(utcDate, (const char*)&packet->payload[offset], len);"
    },
    {
        "line": 134,
        "fullcodeline": "utcDate[len] = '\\0';"
    },
    {
        "line": 148,
        "fullcodeline": "|| (time_sec > flow->protos.stun_ssl.ssl.notAfter))"
    },
    {
        "line": 149,
        "fullcodeline": "NDPI_SET_BIT(flow->risk, NDPI_TLS_CERTIFICATE_EXPIRED); /* Certificate expired */"
    },
    {
        "line": 167,
        "fullcodeline": "if(i < packet->payload_packet_len) {"
    },
    {
        "line": 137,
        "fullcodeline": "if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {"
    },
    {
        "line": 168,
        "fullcodeline": "i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip SEQUENCE length */"
    },
    {
        "line": 169,
        "fullcodeline": "i++;"
    },
    {
        "line": 138,
        "fullcodeline": "flow->protos.stun_ssl.ssl.notAfter = timegm(&utc);"
    },
    {
        "line": 171,
        "fullcodeline": "while(i < packet->payload_packet_len) {"
    },
    {
        "line": 235,
        "fullcodeline": "if(!matched_name)"
    },
    {
        "line": 236,
        "fullcodeline": "NDPI_SET_BIT(flow->risk, NDPI_TLS_CERTIFICATE_MISMATCH); /* Certificate mismatch */"
    },
    {
        "line": 172,
        "fullcodeline": "if(packet->payload[i] == 0x82) {"
    },
    {
        "line": 173,
        "fullcodeline": "if((i < (packet->payload_packet_len - 1))"
    },
    {
        "line": 174,
        "fullcodeline": "&& ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {"
    },
    {
        "line": 175,
        "fullcodeline": "u_int8_t len = packet->payload[i + 1];"
    },
    {
        "line": 176,
        "fullcodeline": "char dNSName[256];"
    },
    {
        "line": 178,
        "fullcodeline": "i += 2;"
    },
    {
        "line": 185,
        "fullcodeline": "strncpy(dNSName, (const char*)&packet->payload[i], len);"
    },
    {
        "line": 186,
        "fullcodeline": "dNSName[len] = '\\0';"
    },
    {
        "line": 188,
        "fullcodeline": "cleanupServerName(dNSName, len);"
    },
    {
        "line": 223,
        "fullcodeline": "i += len;"
    },
    {
        "line": 182,
        "fullcodeline": "if(len == 0 /* Looks something went wrong */)"
    },
    {
        "line": 193,
        "fullcodeline": "if(matched_name == 0) {"
    },
    {
        "line": 200,
        "fullcodeline": "if(flow->protos.stun_ssl.ssl.server_names == NULL)"
    },
    {
        "line": 219,
        "fullcodeline": "if(!flow->l4.tcp.tls.subprotocol_detected)"
    },
    {
        "line": 201,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names = ndpi_strdup(dNSName),"
    },
    {
        "line": 194,
        "fullcodeline": "if((dNSName[0] == '*') && strstr(flow->protos.stun_ssl.ssl.client_requested_server_name, &dNSName[1]))"
    },
    {
        "line": 202,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names_len = strlen(dNSName);"
    },
    {
        "line": 204,
        "fullcodeline": "u_int16_t dNSName_len = strlen(dNSName);"
    },
    {
        "line": 205,
        "fullcodeline": "u_int16_t newstr_len = flow->protos.stun_ssl.ssl.server_names_len + dNSName_len + 1;"
    },
    {
        "line": 206,
        "fullcodeline": "char *newstr = (char*)ndpi_realloc(flow->protos.stun_ssl.ssl.server_names,"
    },
    {
        "line": 220,
        "fullcodeline": "if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))"
    },
    {
        "line": 195,
        "fullcodeline": "matched_name = 1;"
    },
    {
        "line": 221,
        "fullcodeline": "flow->l4.tcp.tls.subprotocol_detected = 1;"
    },
    {
        "line": 210,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names = newstr;"
    },
    {
        "line": 211,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names[flow->protos.stun_ssl.ssl.server_names_len] = ',';"
    },
    {
        "line": 212,
        "fullcodeline": "strncpy(&flow->protos.stun_ssl.ssl.server_names[flow->protos.stun_ssl.ssl.server_names_len+1],"
    },
    {
        "line": 214,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names[newstr_len] = '\\0';"
    },
    {
        "line": 215,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names_len = newstr_len;"
    },
    {
        "line": 196,
        "fullcodeline": "else if(strcmp(flow->protos.stun_ssl.ssl.client_requested_server_name, dNSName) == 0)"
    },
    {
        "line": 207,
        "fullcodeline": "flow->protos.stun_ssl.ssl.server_names_len+1, newstr_len+1);"
    },
    {
        "line": 213,
        "fullcodeline": "dNSName, dNSName_len+1);"
    },
    {
        "line": 197,
        "fullcodeline": "matched_name = 1;"
    }
]