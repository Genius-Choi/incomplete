[
    {
        "line": 27,
        "fullcodeline": "clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);"
    },
    {
        "line": 28,
        "fullcodeline": "clone_info->fill=draw_info->stroke;"
    },
    {
        "line": 34,
        "fullcodeline": "clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;"
    },
    {
        "line": 35,
        "fullcodeline": "clone_info->stroke_width=0.0;"
    },
    {
        "line": 36,
        "fullcodeline": "clone_info->fill_rule=NonZeroRule;"
    },
    {
        "line": 37,
        "fullcodeline": "status=MagickTrue;"
    },
    {
        "line": 54,
        "fullcodeline": "clone_info=DestroyDrawInfo(clone_info);"
    },
    {
        "line": 24,
        "fullcodeline": "if (image->debug != MagickFalse)"
    },
    {
        "line": 29,
        "fullcodeline": "if (clone_info->fill_pattern != (Image *) NULL)"
    },
    {
        "line": 31,
        "fullcodeline": "if (clone_info->stroke_pattern != (Image *) NULL)"
    },
    {
        "line": 38,
        "fullcodeline": "for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)"
    },
    {
        "line": 55,
        "fullcodeline": "if (image->debug != MagickFalse)"
    },
    {
        "line": 58,
        "fullcodeline": "return(status != 0 ? MagickTrue : MagickFalse);"
    },
    {
        "line": 25,
        "fullcodeline": "(void) LogMagickEvent(DrawEvent,GetMagickModule(),"
    },
    {
        "line": 30,
        "fullcodeline": "clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);"
    },
    {
        "line": 32,
        "fullcodeline": "clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,"
    },
    {
        "line": 40,
        "fullcodeline": "stroke_polygon=TraceStrokePolygon(draw_info,p);"
    },
    {
        "line": 41,
        "fullcodeline": "status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);"
    },
    {
        "line": 44,
        "fullcodeline": "stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);"
    },
    {
        "line": 45,
        "fullcodeline": "q=p+p->coordinates-1;"
    },
    {
        "line": 46,
        "fullcodeline": "closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?"
    },
    {
        "line": 56,
        "fullcodeline": "(void) LogMagickEvent(DrawEvent,GetMagickModule(),"
    },
    {
        "line": 42,
        "fullcodeline": "if (status == 0)"
    },
    {
        "line": 48,
        "fullcodeline": "if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))"
    },
    {
        "line": 50,
        "fullcodeline": "DrawRoundLinecap(image,draw_info,p,exception);"
    },
    {
        "line": 51,
        "fullcodeline": "DrawRoundLinecap(image,draw_info,q,exception);"
    }
]