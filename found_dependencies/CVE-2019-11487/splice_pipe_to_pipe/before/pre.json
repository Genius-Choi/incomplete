[
    {
        "line": 6,
        "fullcodeline": "int ret = 0, nbuf;"
    },
    {
        "line": 7,
        "fullcodeline": "bool input_wakeup = false;"
    },
    {
        "line": 11,
        "fullcodeline": "ret = ipipe_prep(ipipe, flags);"
    },
    {
        "line": 15,
        "fullcodeline": "ret = opipe_prep(opipe, flags);"
    },
    {
        "line": 24,
        "fullcodeline": "pipe_double_lock(ipipe, opipe);"
    },
    {
        "line": 98,
        "fullcodeline": "pipe_unlock(ipipe);"
    },
    {
        "line": 99,
        "fullcodeline": "pipe_unlock(opipe);"
    },
    {
        "line": 104,
        "fullcodeline": "if (ret > 0)"
    },
    {
        "line": 61,
        "fullcodeline": "ibuf = ipipe->bufs + ipipe->curbuf;"
    },
    {
        "line": 62,
        "fullcodeline": "nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);"
    },
    {
        "line": 63,
        "fullcodeline": "obuf = opipe->bufs + nbuf;"
    },
    {
        "line": 94,
        "fullcodeline": "ret += obuf->len;"
    },
    {
        "line": 95,
        "fullcodeline": "len -= obuf->len;"
    },
    {
        "line": 27,
        "fullcodeline": "if (!opipe->readers) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (!ipipe->nrbufs && !ipipe->writers)"
    },
    {
        "line": 41,
        "fullcodeline": "if (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (len >= ibuf->len) {"
    },
    {
        "line": 28,
        "fullcodeline": "send_sig(SIGPIPE, current, 0);"
    },
    {
        "line": 56,
        "fullcodeline": "pipe_unlock(ipipe);"
    },
    {
        "line": 57,
        "fullcodeline": "pipe_unlock(opipe);"
    },
    {
        "line": 69,
        "fullcodeline": "*obuf = *ibuf;"
    },
    {
        "line": 70,
        "fullcodeline": "ibuf->ops = NULL;"
    },
    {
        "line": 71,
        "fullcodeline": "opipe->nrbufs++;"
    },
    {
        "line": 72,
        "fullcodeline": "ipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);"
    },
    {
        "line": 73,
        "fullcodeline": "ipipe->nrbufs--;"
    },
    {
        "line": 74,
        "fullcodeline": "input_wakeup = true;"
    },
    {
        "line": 29,
        "fullcodeline": "if (!ret)"
    },
    {
        "line": 46,
        "fullcodeline": "if (flags & SPLICE_F_NONBLOCK) {"
    },
    {
        "line": 80,
        "fullcodeline": "pipe_buf_get(ipipe, ibuf);"
    },
    {
        "line": 81,
        "fullcodeline": "*obuf = *ibuf;"
    },
    {
        "line": 87,
        "fullcodeline": "obuf->flags &= ~PIPE_BUF_FLAG_GIFT;"
    },
    {
        "line": 89,
        "fullcodeline": "obuf->len = len;"
    },
    {
        "line": 90,
        "fullcodeline": "opipe->nrbufs++;"
    },
    {
        "line": 91,
        "fullcodeline": "ibuf->offset += obuf->len;"
    },
    {
        "line": 92,
        "fullcodeline": "ibuf->len -= obuf->len;"
    },
    {
        "line": 30,
        "fullcodeline": "ret = -EPIPE;"
    },
    {
        "line": 47,
        "fullcodeline": "ret = -EAGAIN;"
    }
]