[
    {
        "line": 4,
        "fullcodeline": "assert(!in_generator); /* this function is processing headers (before generators get assigned), not trailers */"
    },
    {
        "line": 6,
        "fullcodeline": "struct st_h2o_http3_server_conn_t *conn = get_conn(stream);"
    },
    {
        "line": 8,
        "fullcodeline": "int header_exists_map = 0, ret;"
    },
    {
        "line": 9,
        "fullcodeline": "uint8_t header_ack[H2O_HPACK_ENCODE_INT_MAX_LENGTH];"
    },
    {
        "line": 24,
        "fullcodeline": "stream->recvbuf.handle_input = handle_input_expect_data;"
    },
    {
        "line": 40,
        "fullcodeline": "h2o_probe_log_request(&stream->req, stream->quic->stream_id);"
    },
    {
        "line": 42,
        "fullcodeline": "int is_connect = h2o_memis(stream->req.input.method.base, stream->req.input.method.len, H2O_STRLIT(\"CONNECT\"));"
    },
    {
        "line": 45,
        "fullcodeline": "int expected_map = H2O_HPACK_PARSE_HEADERS_METHOD_EXISTS | H2O_HPACK_PARSE_HEADERS_AUTHORITY_EXISTS;"
    },
    {
        "line": 63,
        "fullcodeline": "assert(!h2o_linklist_is_linked(&stream->scheduler.link));"
    },
    {
        "line": 88,
        "fullcodeline": "set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK, 0);"
    },
    {
        "line": 13,
        "fullcodeline": "if ((ret = h2o_http3_read_frame(&frame, 0, H2O_HTTP3_STREAM_TYPE_REQUEST, src, src_end, err_desc)) != 0)"
    },
    {
        "line": 15,
        "fullcodeline": "if (frame.type != H2O_HTTP3_FRAME_TYPE_HEADERS) {"
    },
    {
        "line": 27,
        "fullcodeline": "if ((ret = h2o_qpack_parse_request(&stream->req.pool, get_conn(stream)->h3.qpack.dec, stream->quic->stream_id,"
    },
    {
        "line": 34,
        "fullcodeline": "if (header_ack_len != 0)"
    },
    {
        "line": 37,
        "fullcodeline": "if (stream->req.input.scheme == NULL)"
    },
    {
        "line": 46,
        "fullcodeline": "if (!is_connect)"
    },
    {
        "line": 48,
        "fullcodeline": "if (header_exists_map != expected_map) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (ret == H2O_HTTP2_ERROR_INVALID_HEADER_CHAR)"
    },
    {
        "line": 58,
        "fullcodeline": "if (stream->req.content_length != SIZE_MAX && stream->req.content_length > conn->super.ctx->globalconf->max_request_entity_size)"
    },
    {
        "line": 64,
        "fullcodeline": "if (!stream->received_priority_update) {"
    },
    {
        "line": 32,
        "fullcodeline": "ret != H2O_HTTP2_ERROR_INVALID_HEADER_CHAR)"
    },
    {
        "line": 35,
        "fullcodeline": "h2o_http3_send_qpack_header_ack(&conn->h3, header_ack, header_ack_len);"
    },
    {
        "line": 38,
        "fullcodeline": "stream->req.input.scheme = &H2O_URL_SCHEME_HTTPS;"
    },
    {
        "line": 47,
        "fullcodeline": "expected_map |= H2O_HPACK_PARSE_HEADERS_SCHEME_EXISTS | H2O_HPACK_PARSE_HEADERS_PATH_EXISTS;"
    },
    {
        "line": 49,
        "fullcodeline": "shutdown_stream(stream, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, 0);"
    },
    {
        "line": 77,
        "fullcodeline": "set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_SEND_HEADERS, 0);"
    },
    {
        "line": 79,
        "fullcodeline": "stream->tunnel->tunnel = NULL;"
    },
    {
        "line": 80,
        "fullcodeline": "stream->tunnel->stream = stream;"
    },
    {
        "line": 81,
        "fullcodeline": "stream->tunnel->up.is_inflight = 0;"
    },
    {
        "line": 82,
        "fullcodeline": "stream->tunnel->up.delayed_write = (h2o_timer_t){.cb = tunnel_write_delayed};"
    },
    {
        "line": 83,
        "fullcodeline": "h2o_process_request(&stream->req);"
    },
    {
        "line": 55,
        "fullcodeline": "return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, \"Invalid Request\", *err_desc, err_desc);"
    },
    {
        "line": 59,
        "fullcodeline": "return handle_input_expect_headers_send_http_error(stream, h2o_send_error_413, \"Request Entity Too Large\","
    },
    {
        "line": 66,
        "fullcodeline": "if ((index = h2o_find_header(&stream->req.headers, H2O_TOKEN_PRIORITY, -1)) != -1) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (stream->req.content_length != SIZE_MAX)"
    },
    {
        "line": 68,
        "fullcodeline": "h2o_absprio_parse_priority(value->base, value->len, &stream->scheduler.priority);"
    },
    {
        "line": 75,
        "fullcodeline": "return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, \"Invalid Request\","
    }
]