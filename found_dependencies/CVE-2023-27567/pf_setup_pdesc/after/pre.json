[
    {
        "line": 4,
        "fullcodeline": "memset(pd, 0, sizeof(*pd));"
    },
    {
        "line": 5,
        "fullcodeline": "pd->dir = dir;"
    },
    {
        "line": 6,
        "fullcodeline": "pd->kif = kif;\t\t/* kif is NULL when called by pflog */"
    },
    {
        "line": 7,
        "fullcodeline": "pd->m = m;"
    },
    {
        "line": 8,
        "fullcodeline": "pd->sidx = (dir == PF_IN) ? 0 : 1;"
    },
    {
        "line": 9,
        "fullcodeline": "pd->didx = (dir == PF_IN) ? 1 : 0;"
    },
    {
        "line": 10,
        "fullcodeline": "pd->af = pd->naf = af;"
    },
    {
        "line": 11,
        "fullcodeline": "pd->rdomain = rtable_l2(pd->m->m_pkthdr.ph_rtableid);"
    },
    {
        "line": 89,
        "fullcodeline": "pf_addrcpy(&pd->nsaddr, pd->src, pd->af);"
    },
    {
        "line": 90,
        "fullcodeline": "pf_addrcpy(&pd->ndaddr, pd->dst, pd->af);"
    },
    {
        "line": 188,
        "fullcodeline": "pd->hash = pf_pkt_hash(pd->af, pd->proto,"
    },
    {
        "line": 85,
        "fullcodeline": "panic(\"pf_setup_pdesc called with illegal af %u\", pd->af);"
    },
    {
        "line": 184,
        "fullcodeline": "pd->osport = pd->nsport = *pd->sport;"
    },
    {
        "line": 186,
        "fullcodeline": "pd->odport = pd->ndport = *pd->dport;"
    },
    {
        "line": 32,
        "fullcodeline": "pd->src = (struct pf_addr *)&h->ip_src;"
    },
    {
        "line": 33,
        "fullcodeline": "pd->dst = (struct pf_addr *)&h->ip_dst;"
    },
    {
        "line": 34,
        "fullcodeline": "pd->tot_len = ntohs(h->ip_len);"
    },
    {
        "line": 94,
        "fullcodeline": "struct tcphdr\t*th = &pd->hdr.tcp;"
    },
    {
        "line": 113,
        "fullcodeline": "struct udphdr\t*uh = &pd->hdr.udp;"
    },
    {
        "line": 134,
        "fullcodeline": "pd->hdrlen = ICMP_MINLEN;"
    },
    {
        "line": 18,
        "fullcodeline": "if (pd->m->m_pkthdr.len < (int)sizeof(struct ip)) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (pf_walk_header(pd, h, reason) != PF_PASS)"
    },
    {
        "line": 35,
        "fullcodeline": "pd->tos = h->ip_tos & ~IPTOS_ECN_MASK;"
    },
    {
        "line": 37,
        "fullcodeline": "pd->virtual_proto = (h->ip_off & htons(IP_MF | IP_OFFMASK)) ?"
    },
    {
        "line": 106,
        "fullcodeline": "pd->p_len = pd->tot_len - pd->off - (th->th_off << 2);"
    },
    {
        "line": 19,
        "fullcodeline": "REASON_SET(reason, PFRES_SHORT);"
    },
    {
        "line": 24,
        "fullcodeline": "if (pd->m->m_pkthdr.len < ntohs(h->ip_len)) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (!pf_pull_hdr(pd->m, pd->off, th, sizeof(*th),"
    },
    {
        "line": 100,
        "fullcodeline": "if (th->th_dport == 0 ||"
    },
    {
        "line": 102,
        "fullcodeline": "(th->th_off << 2) < sizeof(struct tcphdr)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (!pf_pull_hdr(pd->m, pd->off, uh, sizeof(*uh),"
    },
    {
        "line": 119,
        "fullcodeline": "if (uh->uh_dport == 0 ||"
    },
    {
        "line": 121,
        "fullcodeline": "ntohs(uh->uh_ulen) < sizeof(struct udphdr)) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (!pf_pull_hdr(pd->m, pd->off, &pd->hdr.icmp, ICMP_MINLEN,"
    },
    {
        "line": 101,
        "fullcodeline": "pd->off + (th->th_off << 2) > pd->tot_len ||"
    },
    {
        "line": 120,
        "fullcodeline": "pd->off + ntohs(uh->uh_ulen) > pd->tot_len ||"
    }
]