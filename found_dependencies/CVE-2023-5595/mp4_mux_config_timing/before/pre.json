[
    {
        "line": 7,
        "fullcodeline": "GF_List *services = gf_list_new();"
    },
    {
        "line": 12,
        "fullcodeline": "count = gf_list_count(ctx->tracks);"
    },
    {
        "line": 14,
        "fullcodeline": "blocking_refs = GF_FALSE;"
    },
    {
        "line": 15,
        "fullcodeline": "has_ready = GF_FALSE;"
    },
    {
        "line": 185,
        "fullcodeline": "ctx->config_retry_start = 0;"
    },
    {
        "line": 3,
        "fullcodeline": "if ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign) {"
    },
    {
        "line": 17,
        "fullcodeline": "for (i=0; i<gf_list_count(services);i++) {"
    },
    {
        "line": 24,
        "fullcodeline": "for (i=0; i<count; i++) {"
    },
    {
        "line": 160,
        "fullcodeline": "for (i=0; i<gf_list_count(services); i++) {"
    },
    {
        "line": 186,
        "fullcodeline": "for (i=0; i<gf_list_count(services); i++) {"
    },
    {
        "line": 193,
        "fullcodeline": "for (i=0; i<count; i++) {"
    },
    {
        "line": 4,
        "fullcodeline": "ctx->config_timing = GF_FALSE;"
    },
    {
        "line": 19,
        "fullcodeline": "si->nb_non_sparse = si->nb_non_sparse_ready = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "si->nb_sparse = si->nb_sparse_ready = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "TrackWriter *tkw = gf_list_get(ctx->tracks, i);"
    },
    {
        "line": 30,
        "fullcodeline": "struct _service_info *si = get_service_info(services, tkw);"
    },
    {
        "line": 42,
        "fullcodeline": "pck = gf_filter_pid_get_packet(tkw->ipid);"
    },
    {
        "line": 133,
        "fullcodeline": "ts = gf_filter_pck_get_dts(pck);"
    },
    {
        "line": 139,
        "fullcodeline": "dts_min = gf_timestamp_rescale(ts, tkw->src_timescale, 1000000);"
    },
    {
        "line": 156,
        "fullcodeline": "tkw->ts_shift = ts;"
    },
    {
        "line": 157,
        "fullcodeline": "tkw->si_min_ts_plus_one = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "struct _service_info *si = gf_list_get(services, i);"
    },
    {
        "line": 187,
        "fullcodeline": "struct _service_info *si = gf_list_get(services, i);"
    },
    {
        "line": 194,
        "fullcodeline": "TrackWriter *tkw = gf_list_get(ctx->tracks, i);"
    },
    {
        "line": 195,
        "fullcodeline": "struct _service_info *si = get_service_info(services, tkw);"
    },
    {
        "line": 202,
        "fullcodeline": "mp4_mux_update_init_edit(ctx, tkw, si->first_ts_min, ((count==1) && (tkw->stream_type == GF_STREAM_TEXT)) ? GF_TRUE : GF_FALSE);"
    },
    {
        "line": 18,
        "fullcodeline": "struct _service_info *si = gf_list_get(services, i);"
    },
    {
        "line": 44,
        "fullcodeline": "if (!tkw->track_num) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (!pck) {"
    },
    {
        "line": 130,
        "fullcodeline": "if (gf_list_find(ctx->tracks, tkw) != i) {"
    },
    {
        "line": 134,
        "fullcodeline": "if (ts==GF_FILTER_NO_TS)"
    },
    {
        "line": 136,
        "fullcodeline": "if (ts==GF_FILTER_NO_TS)"
    },
    {
        "line": 141,
        "fullcodeline": "if (si->first_ts_min > dts_min) {"
    },
    {
        "line": 188,
        "fullcodeline": "if (si->first_ts_min==(u64)-1)"
    },
    {
        "line": 34,
        "fullcodeline": "dts_min = gf_timestamp_rescale(tkw->ts_shift, tkw->src_timescale, 1000000);"
    },
    {
        "line": 50,
        "fullcodeline": "tkw->ts_shift = 0;"
    },
    {
        "line": 89,
        "fullcodeline": "si->nb_non_sparse++;"
    },
    {
        "line": 125,
        "fullcodeline": "tkw->ts_shift = 0;"
    },
    {
        "line": 126,
        "fullcodeline": "tkw->si_min_ts_plus_one = 1;"
    },
    {
        "line": 135,
        "fullcodeline": "ts = gf_filter_pck_get_cts(pck);"
    },
    {
        "line": 137,
        "fullcodeline": "ts=0;"
    },
    {
        "line": 142,
        "fullcodeline": "si->first_ts_min = (u64) dts_min;"
    },
    {
        "line": 143,
        "fullcodeline": "has_ready = GF_TRUE;"
    },
    {
        "line": 149,
        "fullcodeline": "si->nb_non_sparse_ready++;"
    },
    {
        "line": 152,
        "fullcodeline": "si->nb_sparse_ready++;"
    },
    {
        "line": 189,
        "fullcodeline": "si->first_ts_min = 0;"
    },
    {
        "line": 197,
        "fullcodeline": "tkw->si_min_ts_plus_one = si->first_ts_min + 1;"
    },
    {
        "line": 36,
        "fullcodeline": "if (si->first_ts_min > dts_min) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (gf_filter_pid_is_eos(tkw->ipid)) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (gf_filter_pck_is_blocking_ref(pck))"
    },
    {
        "line": 98,
        "fullcodeline": "if (gf_filter_pid_is_eos(tkw->ipid)) {"
    },
    {
        "line": 37,
        "fullcodeline": "si->first_ts_min = (u64) dts_min;"
    },
    {
        "line": 46,
        "fullcodeline": "GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID has no input packet and configuration not known after 10 retries, aborting initial timing sync\\n\"));"
    },
    {
        "line": 56,
        "fullcodeline": "blocking_refs = GF_TRUE;"
    },
    {
        "line": 58,
        "fullcodeline": "GF_FilterSAPType sap = gf_filter_pck_get_sap(pck);"
    },
    {
        "line": 59,
        "fullcodeline": "Bool seek = gf_filter_pck_get_seek_flag(pck);"
    },
    {
        "line": 74,
        "fullcodeline": "ts = gf_filter_pck_get_dts(pck);"
    },
    {
        "line": 75,
        "fullcodeline": "if (ts==GF_FILTER_NO_TS)"
    },
    {
        "line": 77,
        "fullcodeline": "if (ts==GF_FILTER_NO_TS)"
    },
    {
        "line": 80,
        "fullcodeline": "if (gf_timestamp_less(ts, tkw->src_timescale, (ctx->wait_dts_plus_one-1), ctx->wait_dts_timescale)) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (tkw->cenc_state==CENC_NEED_SETUP)"
    },
    {
        "line": 102,
        "fullcodeline": "if (!tkw->nb_samples) {"
    },
    {
        "line": 177,
        "fullcodeline": "else if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (seek || !sap) {"
    },
    {
        "line": 61,
        "fullcodeline": "gf_filter_pid_drop_packet(tkw->ipid);"
    },
    {
        "line": 76,
        "fullcodeline": "ts = gf_filter_pck_get_cts(pck);"
    },
    {
        "line": 78,
        "fullcodeline": "ts=0;"
    },
    {
        "line": 81,
        "fullcodeline": "gf_filter_pid_drop_packet(tkw->ipid);"
    },
    {
        "line": 100,
        "fullcodeline": "mp4_mux_cenc_update(ctx, tkw, NULL, CENC_CONFIG, 0, 0);"
    },
    {
        "line": 112,
        "fullcodeline": "tkw->dgl_copy = NULL;"
    },
    {
        "line": 117,
        "fullcodeline": "si->nb_non_sparse_ready++;"
    },
    {
        "line": 120,
        "fullcodeline": "si->nb_sparse_ready++;"
    },
    {
        "line": 64,
        "fullcodeline": "tkw->wait_sap = GF_FALSE;"
    },
    {
        "line": 104,
        "fullcodeline": "const GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);"
    },
    {
        "line": 66,
        "fullcodeline": "if (!ctx->wait_dts_plus_one) {"
    },
    {
        "line": 106,
        "fullcodeline": "gf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);"
    },
    {
        "line": 67,
        "fullcodeline": "ctx->wait_dts_plus_one = 1 + gf_filter_pck_get_dts(pck);"
    },
    {
        "line": 68,
        "fullcodeline": "ctx->wait_dts_timescale = tkw->src_timescale;"
    }
]