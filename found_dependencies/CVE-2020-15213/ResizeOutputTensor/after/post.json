[
    {
        "line": 8,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);"
    },
    {
        "line": 9,
        "fullcodeline": "int previous_segment_id = -1;"
    },
    {
        "line": 21,
        "fullcodeline": "const int max_index = previous_segment_id;"
    },
    {
        "line": 23,
        "fullcodeline": "const int data_rank = NumDimensions(data);"
    },
    {
        "line": 24,
        "fullcodeline": "TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));"
    },
    {
        "line": 25,
        "fullcodeline": "output_shape->data[0] = max_index + 1;"
    },
    {
        "line": 10,
        "fullcodeline": "for (int i = 0; i < segment_id_size; i++) {"
    },
    {
        "line": 26,
        "fullcodeline": "for (int i = 1; i < data_rank; ++i) {"
    },
    {
        "line": 29,
        "fullcodeline": "return context->ResizeTensor(context, output, output_shape);"
    },
    {
        "line": 11,
        "fullcodeline": "const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];"
    },
    {
        "line": 18,
        "fullcodeline": "previous_segment_id = current_segment_id;"
    },
    {
        "line": 12,
        "fullcodeline": "if (i == 0) {"
    },
    {
        "line": 13,
        "fullcodeline": "TF_LITE_ENSURE_EQ(context, current_segment_id, 0);"
    },
    {
        "line": 15,
        "fullcodeline": "int delta = current_segment_id - previous_segment_id;"
    },
    {
        "line": 16,
        "fullcodeline": "TF_LITE_ENSURE(context, delta == 0 || delta == 1);"
    }
]