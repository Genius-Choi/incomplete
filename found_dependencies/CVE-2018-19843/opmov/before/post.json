[
    {
        "line": 2,
        "fullcodeline": "int l = 0;"
    },
    {
        "line": 3,
        "fullcodeline": "st64 offset = 0;"
    },
    {
        "line": 4,
        "fullcodeline": "int mod = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "int base = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "int rex = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "ut64 immediate = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "if (op->operands[1].type & OT_CONSTANT) {"
    },
    {
        "line": 15,
        "fullcodeline": "immediate = op->operands[1].immediate * op->operands[1].sign;"
    },
    {
        "line": 12,
        "fullcodeline": "if (op->operands[1].immediate == -1) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (op->operands[0].type & OT_GPREG && !(op->operands[0].type & OT_MEMORY)) {"
    },
    {
        "line": 206,
        "fullcodeline": "} else if (op->operands[1].type & OT_REGALL &&"
    },
    {
        "line": 10,
        "fullcodeline": "return -1;"
    },
    {
        "line": 13,
        "fullcodeline": "return -1;"
    },
    {
        "line": 17,
        "fullcodeline": "if (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (op->operands[0].type & OT_WORD) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (op->operands[0].type & OT_BYTE) {"
    },
    {
        "line": 207,
        "fullcodeline": "!(op->operands[1].type & OT_MEMORY)) {"
    },
    {
        "line": 247,
        "fullcodeline": "offset = op->operands[0].offset * op->operands[0].offset_sign;"
    },
    {
        "line": 32,
        "fullcodeline": "data[l++] = 0xb0 | op->operands[0].reg;"
    },
    {
        "line": 33,
        "fullcodeline": "data[l++] = immediate;"
    },
    {
        "line": 57,
        "fullcodeline": "} else if (op->operands[0].type & OT_MEMORY) {"
    },
    {
        "line": 208,
        "fullcodeline": "if (op->operands[0].type & OT_CONSTANT) {"
    },
    {
        "line": 211,
        "fullcodeline": "if (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG &&"
    },
    {
        "line": 216,
        "fullcodeline": "if (op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_REGTYPE) {"
    },
    {
        "line": 223,
        "fullcodeline": "if (a->bits == 64) {"
    },
    {
        "line": 248,
        "fullcodeline": "if (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 257,
        "fullcodeline": "if (op->operands[0].scale[0] > 1) {"
    },
    {
        "line": 270,
        "fullcodeline": "if (!(op->operands[0].type & OT_MEMORY)) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (!(op->operands[1].type & OT_CONSTANT) && op->operands[1].extended) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (a->bits > 16) {"
    },
    {
        "line": 44,
        "fullcodeline": "data[l++] = immediate;"
    },
    {
        "line": 45,
        "fullcodeline": "data[l++] = immediate >> 8;"
    },
    {
        "line": 66,
        "fullcodeline": "int dest_bits = 8 * ((op->operands[0].dest_size & ALL_SIZE) >> OPSIZE_SHIFT);"
    },
    {
        "line": 67,
        "fullcodeline": "int reg_bits = 8 * ((op->operands[0].reg_size & ALL_SIZE) >> OPSIZE_SHIFT);"
    },
    {
        "line": 68,
        "fullcodeline": "int offset = op->operands[0].offset * op->operands[0].offset_sign;"
    },
    {
        "line": 71,
        "fullcodeline": "bool use_aso = false;"
    },
    {
        "line": 77,
        "fullcodeline": "bool use_oso = false;"
    },
    {
        "line": 82,
        "fullcodeline": "bool rip_rel = op->operands[0].regs[0] == X86R_RIP;"
    },
    {
        "line": 85,
        "fullcodeline": "int rex = 1 << 6;"
    },
    {
        "line": 86,
        "fullcodeline": "bool use_rex = false;"
    },
    {
        "line": 105,
        "fullcodeline": "int modrm = 0;"
    },
    {
        "line": 107,
        "fullcodeline": "int reg = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "bool use_sib = false;"
    },
    {
        "line": 183,
        "fullcodeline": "data[l++] = opcode;"
    },
    {
        "line": 184,
        "fullcodeline": "data[l++] = modrm;"
    },
    {
        "line": 212,
        "fullcodeline": "op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 249,
        "fullcodeline": "data[l++] = 0x8c;"
    },
    {
        "line": 258,
        "fullcodeline": "data[l++] = op->operands[1].reg << 3 | 4;"
    },
    {
        "line": 259,
        "fullcodeline": "data[l++] = getsib (op->operands[0].scale[0]) << 6 |"
    },
    {
        "line": 262,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 263,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 264,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 265,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 275,
        "fullcodeline": "mod = 0x3;"
    },
    {
        "line": 276,
        "fullcodeline": "data[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].reg;"
    },
    {
        "line": 311,
        "fullcodeline": "} else if (op->operands[1].type & OT_MEMORY) {"
    },
    {
        "line": 19,
        "fullcodeline": "data[l++] = 0x49;"
    },
    {
        "line": 28,
        "fullcodeline": "data[l++] = 0x66;"
    },
    {
        "line": 35,
        "fullcodeline": "if (a->bits == 64 &&"
    },
    {
        "line": 46,
        "fullcodeline": "if (!(op->operands[0].type & OT_WORD)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (a->bits == 64 && immediate > UT32_MAX) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (reg_bits < a->bits) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (dest_bits == 16) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (dest_bits == 64) {\t\t\t//W field"
    },
    {
        "line": 98,
        "fullcodeline": "if (dest_bits == 8) {"
    },
    {
        "line": 112,
        "fullcodeline": "if (offset == 0) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (reg_bits == 16) {"
    },
    {
        "line": 189,
        "fullcodeline": "if (mod == 1) {"
    },
    {
        "line": 202,
        "fullcodeline": "for (byte = 0; byte < dest_bits && byte < 32; byte += 8) {"
    },
    {
        "line": 209,
        "fullcodeline": "return -1;"
    },
    {
        "line": 213,
        "fullcodeline": "return -1;"
    },
    {
        "line": 217,
        "fullcodeline": "if (!((op->operands[0].type & ALL_SIZE) &"
    },
    {
        "line": 230,
        "fullcodeline": "if (op->operands[1].type & OT_QWORD) {"
    },
    {
        "line": 236,
        "fullcodeline": "if (op->operands[1].type & OT_QWORD &&"
    },
    {
        "line": 240,
        "fullcodeline": "if (op->operands[1].type & OT_DWORD &&"
    },
    {
        "line": 254,
        "fullcodeline": "data[l++] = (op->operands[0].type & OT_BYTE) ? 0x88 : 0x89;"
    },
    {
        "line": 271,
        "fullcodeline": "if (op->operands[0].reg == X86R_UNDEFINED ||"
    },
    {
        "line": 315,
        "fullcodeline": "offset = op->operands[1].offset * op->operands[1].offset_sign;"
    },
    {
        "line": 21,
        "fullcodeline": "data[l++] = 0x48;"
    },
    {
        "line": 24,
        "fullcodeline": "data[l++] = 0x41;"
    },
    {
        "line": 38,
        "fullcodeline": "immediate < UT32_MAX) {"
    },
    {
        "line": 39,
        "fullcodeline": "data[l++] = 0xc7;"
    },
    {
        "line": 40,
        "fullcodeline": "data[l++] = 0xc0 | op->operands[0].reg;"
    },
    {
        "line": 47,
        "fullcodeline": "data[l++] = immediate >> 16;"
    },
    {
        "line": 48,
        "fullcodeline": "data[l++] = immediate >> 24;"
    },
    {
        "line": 51,
        "fullcodeline": "data[l++] = immediate >> 32;"
    },
    {
        "line": 52,
        "fullcodeline": "data[l++] = immediate >> 40;"
    },
    {
        "line": 53,
        "fullcodeline": "data[l++] = immediate >> 48;"
    },
    {
        "line": 54,
        "fullcodeline": "data[l++] = immediate >> 56;"
    },
    {
        "line": 73,
        "fullcodeline": "use_aso = true;"
    },
    {
        "line": 79,
        "fullcodeline": "use_oso = true;"
    },
    {
        "line": 88,
        "fullcodeline": "use_rex = true;"
    },
    {
        "line": 89,
        "fullcodeline": "rex |= 1 << 3;"
    },
    {
        "line": 92,
        "fullcodeline": "use_rex = true;"
    },
    {
        "line": 93,
        "fullcodeline": "rex |= 1;"
    },
    {
        "line": 99,
        "fullcodeline": "opcode = 0xc6;"
    },
    {
        "line": 113,
        "fullcodeline": "mod = 0;"
    },
    {
        "line": 139,
        "fullcodeline": "modrm = (mod << 6) | (reg << 3) | rm;"
    },
    {
        "line": 175,
        "fullcodeline": "data[l++] = 0x67;"
    },
    {
        "line": 178,
        "fullcodeline": "data[l++] = 0x66;"
    },
    {
        "line": 181,
        "fullcodeline": "data[l++] = rex;"
    },
    {
        "line": 186,
        "fullcodeline": "data[l++] = sib;"
    },
    {
        "line": 190,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 203,
        "fullcodeline": "data[l++] = (immediate >> byte);"
    },
    {
        "line": 225,
        "fullcodeline": "rex = 1;"
    },
    {
        "line": 228,
        "fullcodeline": "rex += 4;"
    },
    {
        "line": 237,
        "fullcodeline": "op->operands[0].type & OT_QWORD) {"
    },
    {
        "line": 238,
        "fullcodeline": "data[l++] = 0x48 | rex;"
    },
    {
        "line": 241,
        "fullcodeline": "op->operands[0].type & OT_DWORD) {"
    },
    {
        "line": 242,
        "fullcodeline": "data[l++] = 0x40 | rex;"
    },
    {
        "line": 251,
        "fullcodeline": "if (op->operands[0].type & OT_WORD) {"
    },
    {
        "line": 272,
        "fullcodeline": "op->operands[1].reg == X86R_UNDEFINED) {"
    },
    {
        "line": 277,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_UNDEFINED) {"
    },
    {
        "line": 312,
        "fullcodeline": "if (op->operands[0].type & OT_MEMORY) {"
    },
    {
        "line": 316,
        "fullcodeline": "if (op->operands[0].reg == X86R_EAX && op->operands[1].regs[0] == X86R_UNDEFINED) {"
    },
    {
        "line": 337,
        "fullcodeline": "if (op->operands[0].type & OT_BYTE && a->bits == 64 && op->operands[1].regs[0]) {"
    },
    {
        "line": 348,
        "fullcodeline": "if (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {"
    },
    {
        "line": 362,
        "fullcodeline": "if (a->bits == 64) {"
    },
    {
        "line": 381,
        "fullcodeline": "if (op->operands[0].type & OT_WORD) {"
    },
    {
        "line": 390,
        "fullcodeline": "if (op->operands[1].regs[0] == X86R_UNDEFINED) {"
    },
    {
        "line": 36,
        "fullcodeline": "((op->operands[0].type & OT_QWORD) |"
    },
    {
        "line": 42,
        "fullcodeline": "data[l++] = 0xb8 | op->operands[0].reg;"
    },
    {
        "line": 59,
        "fullcodeline": "if (op->operands[0].type & OT_GPREG) {"
    },
    {
        "line": 101,
        "fullcodeline": "opcode = 0xc7;"
    },
    {
        "line": 121,
        "fullcodeline": "if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {"
    },
    {
        "line": 154,
        "fullcodeline": "int scale = getsib(op->operands[0].scale[1]);"
    },
    {
        "line": 218,
        "fullcodeline": "(op->operands[1].type & ALL_SIZE))) {"
    },
    {
        "line": 219,
        "fullcodeline": "return -1;"
    },
    {
        "line": 231,
        "fullcodeline": "if (!(op->operands[0].type & OT_QWORD)) {"
    },
    {
        "line": 245,
        "fullcodeline": "data[l++] = 0x45;"
    },
    {
        "line": 252,
        "fullcodeline": "data[l++] = 0x66;"
    },
    {
        "line": 260,
        "fullcodeline": "op->operands[0].regs[0] << 3 | 5;"
    },
    {
        "line": 273,
        "fullcodeline": "return -1;"
    },
    {
        "line": 278,
        "fullcodeline": "data[l++] = op->operands[1].reg << 3 | 0x5;"
    },
    {
        "line": 279,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 280,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 281,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 282,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 325,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 326,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 327,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 328,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 353,
        "fullcodeline": "data[l++] = 0x8b;"
    },
    {
        "line": 354,
        "fullcodeline": "data[l++] = op->operands[0].reg << 3 | 0x5;"
    },
    {
        "line": 355,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 356,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 357,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 358,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 382,
        "fullcodeline": "data[l++] = 0x66;"
    },
    {
        "line": 383,
        "fullcodeline": "data[l++] = op->operands[1].type & OT_BYTE ? 0x8a : 0x8b;"
    },
    {
        "line": 397,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 398,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 399,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 400,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 37,
        "fullcodeline": "(op->operands[1].type & OT_QWORD)) &&"
    },
    {
        "line": 114,
        "fullcodeline": "} else if (offset < 128 && offset > -129) {"
    },
    {
        "line": 122,
        "fullcodeline": "rm = B0000;"
    },
    {
        "line": 148,
        "fullcodeline": "if (rm == 5 && mod == 0) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (index != -1) {"
    },
    {
        "line": 191,
        "fullcodeline": "} else if (reg_bits == 16 && mod == 2) {"
    },
    {
        "line": 232,
        "fullcodeline": "data[l++] = 0x67;"
    },
    {
        "line": 233,
        "fullcodeline": "data[l++] = 0x48;"
    },
    {
        "line": 313,
        "fullcodeline": "return -1;"
    },
    {
        "line": 317,
        "fullcodeline": "if (a->bits == 64) {"
    },
    {
        "line": 320,
        "fullcodeline": "if (op->operands[0].type & OT_BYTE) {"
    },
    {
        "line": 329,
        "fullcodeline": "if (a->bits == 64) {"
    },
    {
        "line": 338,
        "fullcodeline": "if (op->operands[1].regs[0] >= X86R_R8 &&"
    },
    {
        "line": 345,
        "fullcodeline": "return -1;"
    },
    {
        "line": 349,
        "fullcodeline": "if (op->operands[1].scale[0] == 0) {"
    },
    {
        "line": 363,
        "fullcodeline": "if (op->operands[0].type & OT_QWORD) {"
    },
    {
        "line": 375,
        "fullcodeline": "if (op->operands[1].type & OT_QWORD &&"
    },
    {
        "line": 385,
        "fullcodeline": "data[l++] = (op->operands[1].type & OT_BYTE ||"
    },
    {
        "line": 391,
        "fullcodeline": "if (a->bits == 64) {"
    },
    {
        "line": 115,
        "fullcodeline": "mod = 1;"
    },
    {
        "line": 149,
        "fullcodeline": "mod = 1;"
    },
    {
        "line": 156,
        "fullcodeline": "use_sib = true;"
    },
    {
        "line": 157,
        "fullcodeline": "sib = (scale << 6) | (index << 3) | rm;"
    },
    {
        "line": 163,
        "fullcodeline": "rm = B0100;"
    },
    {
        "line": 166,
        "fullcodeline": "modrm = (B0000 << 6) | (reg << 3) | B0101;"
    },
    {
        "line": 167,
        "fullcodeline": "sib = (scale << 6) | (B0100 << 3) | B0101;"
    },
    {
        "line": 192,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 193,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 284,
        "fullcodeline": "if (op->operands[0].type & OT_MEMORY) {"
    },
    {
        "line": 318,
        "fullcodeline": "data[l++] = 0x48;"
    },
    {
        "line": 321,
        "fullcodeline": "data[l++] = 0xa0;"
    },
    {
        "line": 330,
        "fullcodeline": "data[l++] = offset >> 32;"
    },
    {
        "line": 331,
        "fullcodeline": "data[l++] = offset >> 40;"
    },
    {
        "line": 332,
        "fullcodeline": "data[l++] = offset >> 48;"
    },
    {
        "line": 333,
        "fullcodeline": "data[l++] = offset >> 54;"
    },
    {
        "line": 339,
        "fullcodeline": "op->operands[0].reg < 4) {"
    },
    {
        "line": 340,
        "fullcodeline": "data[l++] = 0x41;"
    },
    {
        "line": 341,
        "fullcodeline": "data[l++] = 0x8a;"
    },
    {
        "line": 342,
        "fullcodeline": "data[l++] = op->operands[0].reg << 3 | (op->operands[1].regs[0] - 8);"
    },
    {
        "line": 352,
        "fullcodeline": "data[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0]];"
    },
    {
        "line": 376,
        "fullcodeline": "op->operands[0].type & OT_QWORD) {"
    },
    {
        "line": 377,
        "fullcodeline": "data[l++] = 0x48;"
    },
    {
        "line": 392,
        "fullcodeline": "data[l++] = op->operands[0].reg << 3 | 0x4;"
    },
    {
        "line": 393,
        "fullcodeline": "data[l++] = 0x25;"
    },
    {
        "line": 402,
        "fullcodeline": "if (op->operands[1].scale[0] > 1) {"
    },
    {
        "line": 421,
        "fullcodeline": "if (op->operands[1].regs[1] != X86R_UNDEFINED) {"
    },
    {
        "line": 427,
        "fullcodeline": "if (offset || op->operands[1].regs[0] == X86R_EBP) {"
    },
    {
        "line": 433,
        "fullcodeline": "if (a->bits == 64 && offset && op->operands[0].type & OT_QWORD) {"
    },
    {
        "line": 455,
        "fullcodeline": "if (op->operands[1].regs[0] == X86R_ESP) {"
    },
    {
        "line": 458,
        "fullcodeline": "if (mod >= 0x2) {"
    },
    {
        "line": 62,
        "fullcodeline": "return -1;"
    },
    {
        "line": 117,
        "fullcodeline": "mod = 2;"
    },
    {
        "line": 123,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {"
    },
    {
        "line": 145,
        "fullcodeline": "rm = op->operands[0].regs[0];"
    },
    {
        "line": 169,
        "fullcodeline": "modrm = (mod << 6) | (reg << 3) | rm;"
    },
    {
        "line": 296,
        "fullcodeline": "data[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].regs[0];"
    },
    {
        "line": 323,
        "fullcodeline": "data[l++] = 0xa1;"
    },
    {
        "line": 350,
        "fullcodeline": "return -1;"
    },
    {
        "line": 364,
        "fullcodeline": "if (!(op->operands[1].type & OT_QWORD)) {"
    },
    {
        "line": 395,
        "fullcodeline": "data[l++] = op->operands[0].reg << 3 | 0x5;"
    },
    {
        "line": 403,
        "fullcodeline": "data[l++] = op->operands[0].reg << 3 | 4;"
    },
    {
        "line": 422,
        "fullcodeline": "data[l++] = op->operands[0].reg << 3 | 0x4;"
    },
    {
        "line": 423,
        "fullcodeline": "data[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];"
    },
    {
        "line": 428,
        "fullcodeline": "mod = 0x2;"
    },
    {
        "line": 456,
        "fullcodeline": "data[l++] = 0x24;"
    },
    {
        "line": 459,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 124,
        "fullcodeline": "rm = B0001;"
    },
    {
        "line": 158,
        "fullcodeline": "} else if (rm == 4) {"
    },
    {
        "line": 194,
        "fullcodeline": "} else if (mod == 2 || rip_rel) {"
    },
    {
        "line": 285,
        "fullcodeline": "if (op->operands[0].regs[1] != X86R_UNDEFINED) {"
    },
    {
        "line": 293,
        "fullcodeline": "if (op->operands[0].regs[0] == X86R_EBP) {"
    },
    {
        "line": 297,
        "fullcodeline": "if (op->operands[0].regs[0] == X86R_ESP) {"
    },
    {
        "line": 303,
        "fullcodeline": "if (mod == 2) {"
    },
    {
        "line": 368,
        "fullcodeline": "data[l++] = 0x48;"
    },
    {
        "line": 370,
        "fullcodeline": "} else if (op->operands[1].type & OT_DWORD) {"
    },
    {
        "line": 386,
        "fullcodeline": "op->operands[0].type & OT_BYTE) ?"
    },
    {
        "line": 405,
        "fullcodeline": "if (op->operands[1].scale[0] >= 2) {"
    },
    {
        "line": 413,
        "fullcodeline": "if (offset || base) {"
    },
    {
        "line": 429,
        "fullcodeline": "if (op->operands[1].offset > 127) {"
    },
    {
        "line": 434,
        "fullcodeline": "if (op->operands[1].regs[0] == X86R_RIP) {"
    },
    {
        "line": 443,
        "fullcodeline": "if (op->operands[1].offset > 127) {"
    },
    {
        "line": 460,
        "fullcodeline": "if (op->operands[1].offset > 128 || op->operands[1].regs[0] == X86R_EIP) {"
    },
    {
        "line": 60,
        "fullcodeline": "((Opcode *)op)->operands[0].dest_size = op->operands[0].reg_size;"
    },
    {
        "line": 159,
        "fullcodeline": "use_sib = true;"
    },
    {
        "line": 160,
        "fullcodeline": "sib = 0x24;"
    },
    {
        "line": 195,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 196,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 197,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 198,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 286,
        "fullcodeline": "data[l++] = op->operands[1].reg << 3 | 0x4;"
    },
    {
        "line": 287,
        "fullcodeline": "data[l++] = op->operands[0].regs[1] << 3 | op->operands[0].regs[0];"
    },
    {
        "line": 291,
        "fullcodeline": "mod = (offset > 128 || offset < -129) ? 0x2 : 0x1;"
    },
    {
        "line": 294,
        "fullcodeline": "mod = 0x2;"
    },
    {
        "line": 298,
        "fullcodeline": "data[l++] = 0x24;"
    },
    {
        "line": 301,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 305,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 306,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 307,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 365,
        "fullcodeline": "if (op->operands[1].regs[0] != -1) {"
    },
    {
        "line": 371,
        "fullcodeline": "data[l++] = 0x44;"
    },
    {
        "line": 406,
        "fullcodeline": "base = 5;"
    },
    {
        "line": 409,
        "fullcodeline": "data[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | base;"
    },
    {
        "line": 414,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 415,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 416,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 417,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 430,
        "fullcodeline": "mod = 0x4;"
    },
    {
        "line": 435,
        "fullcodeline": "data[l++] = 0x5;"
    },
    {
        "line": 444,
        "fullcodeline": "mod = 0x1;"
    },
    {
        "line": 447,
        "fullcodeline": "if (op->operands[1].regs[0] == X86R_EIP && (op->operands[0].type & OT_DWORD)) {"
    },
    {
        "line": 461,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 462,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 463,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 465,
        "fullcodeline": "} else if (a->bits == 64 && (offset || op->operands[1].regs[0] == X86R_RIP)) {"
    },
    {
        "line": 125,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {"
    },
    {
        "line": 366,
        "fullcodeline": "data[l++] = 0x67;"
    },
    {
        "line": 411,
        "fullcodeline": "data[l++] = getsib (op->operands[1].scale[0]) << 3 | op->operands[1].regs[0];"
    },
    {
        "line": 448,
        "fullcodeline": "data[l++] = 0x0d;"
    },
    {
        "line": 466,
        "fullcodeline": "data[l++] = offset;"
    },
    {
        "line": 126,
        "fullcodeline": "rm = B0010;"
    },
    {
        "line": 372,
        "fullcodeline": "} else if (!(op->operands[1].type & OT_QWORD)) {"
    },
    {
        "line": 437,
        "fullcodeline": "if (op->operands[1].offset > 127) {"
    },
    {
        "line": 467,
        "fullcodeline": "if (op->operands[1].offset > 127 || op->operands[1].regs[0] == X86R_RIP) {"
    },
    {
        "line": 373,
        "fullcodeline": "data[l++] = 0x67;"
    },
    {
        "line": 438,
        "fullcodeline": "data[l++] = 0x80 | op->operands[0].reg << 3 | op->operands[1].regs[0];"
    },
    {
        "line": 449,
        "fullcodeline": "} else if (op->operands[1].regs[0] == X86R_RIP && (op->operands[0].type & OT_QWORD)) {"
    },
    {
        "line": 468,
        "fullcodeline": "data[l++] = offset >> 8;"
    },
    {
        "line": 469,
        "fullcodeline": "data[l++] = offset >> 16;"
    },
    {
        "line": 470,
        "fullcodeline": "data[l++] = offset >> 24;"
    },
    {
        "line": 127,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {"
    },
    {
        "line": 440,
        "fullcodeline": "data[l++] = 0x40 | op->operands[1].regs[0];"
    },
    {
        "line": 450,
        "fullcodeline": "data[l++] = 0x05;"
    },
    {
        "line": 128,
        "fullcodeline": "rm = B0011;"
    },
    {
        "line": 452,
        "fullcodeline": "data[l++] = mod << 5 | op->operands[0].reg << 3 | op->operands[1].regs[0];"
    },
    {
        "line": 129,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {"
    },
    {
        "line": 130,
        "fullcodeline": "rm = B0100;"
    },
    {
        "line": 131,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {"
    },
    {
        "line": 132,
        "fullcodeline": "rm = B0101;"
    },
    {
        "line": 133,
        "fullcodeline": "} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {"
    },
    {
        "line": 134,
        "fullcodeline": "rm = B0111;"
    },
    {
        "line": 137,
        "fullcodeline": "return -1;"
    }
]