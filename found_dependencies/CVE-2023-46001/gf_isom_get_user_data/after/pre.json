[
    {
        "line": 28,
        "fullcodeline": "i=0;"
    },
    {
        "line": 88,
        "fullcodeline": "bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);"
    },
    {
        "line": 89,
        "fullcodeline": "i=0;"
    },
    {
        "line": 126,
        "fullcodeline": "gf_bs_get_content(bs, userData, userDataSize);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!movie || !movie->moov) return GF_BAD_PARAM;"
    },
    {
        "line": 21,
        "fullcodeline": "if (!udta) return GF_BAD_PARAM;"
    },
    {
        "line": 23,
        "fullcodeline": "if (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "if (!userData || !userDataSize || *userData) return GF_BAD_PARAM;"
    },
    {
        "line": 29,
        "fullcodeline": "while ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {"
    },
    {
        "line": 90,
        "fullcodeline": "while ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {"
    },
    {
        "line": 14,
        "fullcodeline": "trak = gf_isom_get_track_from_file(movie, trackNumber);"
    },
    {
        "line": 16,
        "fullcodeline": "udta = trak->udta;"
    },
    {
        "line": 39,
        "fullcodeline": "ptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);"
    },
    {
        "line": 110,
        "fullcodeline": "s = data_size+8;"
    },
    {
        "line": 113,
        "fullcodeline": "gf_bs_write_u32(bs, s);"
    },
    {
        "line": 114,
        "fullcodeline": "gf_bs_write_u32(bs, type);"
    },
    {
        "line": 15,
        "fullcodeline": "if (!trak) return GF_BAD_PARAM;"
    },
    {
        "line": 19,
        "fullcodeline": "udta = movie->moov->udta;"
    },
    {
        "line": 38,
        "fullcodeline": "if (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;"
    },
    {
        "line": 41,
        "fullcodeline": "if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;"
    },
    {
        "line": 115,
        "fullcodeline": "if (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);"
    },
    {
        "line": 30,
        "fullcodeline": "if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && UUID && !memcmp(map->uuid, UUID, 16)) goto found;"
    },
    {
        "line": 47,
        "fullcodeline": "*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);"
    },
    {
        "line": 94,
        "fullcodeline": "type = ptr->original_4cc;"
    },
    {
        "line": 95,
        "fullcodeline": "data_size = ptr->dataSize;"
    },
    {
        "line": 96,
        "fullcodeline": "data = ptr->data;"
    },
    {
        "line": 117,
        "fullcodeline": "gf_bs_write_data(bs, data, data_size);"
    },
    {
        "line": 42,
        "fullcodeline": "if (!ptr->dataSize) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (!*userData) return GF_OUT_OF_MEM;"
    },
    {
        "line": 49,
        "fullcodeline": "memcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);"
    },
    {
        "line": 31,
        "fullcodeline": "else if (map->boxType == UserDataType) goto found;"
    },
    {
        "line": 52,
        "fullcodeline": "} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {"
    },
    {
        "line": 97,
        "fullcodeline": "} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {"
    },
    {
        "line": 53,
        "fullcodeline": "GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;"
    },
    {
        "line": 59,
        "fullcodeline": "*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);"
    },
    {
        "line": 98,
        "fullcodeline": "GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;"
    },
    {
        "line": 99,
        "fullcodeline": "type = p_uuid->type;"
    },
    {
        "line": 100,
        "fullcodeline": "data_size = p_uuid->dataSize;"
    },
    {
        "line": 101,
        "fullcodeline": "data = p_uuid->data;"
    },
    {
        "line": 120,
        "fullcodeline": "gf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);"
    },
    {
        "line": 54,
        "fullcodeline": "if (!p_uuid->dataSize) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (!*userData) return GF_OUT_OF_MEM;"
    },
    {
        "line": 61,
        "fullcodeline": "memcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);"
    },
    {
        "line": 65,
        "fullcodeline": "char *str = NULL;"
    },
    {
        "line": 104,
        "fullcodeline": "gf_isom_box_write((GF_Box *)ptr, bs);"
    },
    {
        "line": 69,
        "fullcodeline": "str = ((GF_NameBox *)ptr)->string;"
    },
    {
        "line": 72,
        "fullcodeline": "str = ((GF_KindBox *)ptr)->value;"
    },
    {
        "line": 76,
        "fullcodeline": "u32 len = (u32) strlen(str) + 1;"
    },
    {
        "line": 77,
        "fullcodeline": "*userData = (char *)gf_malloc(sizeof(char) * len);"
    },
    {
        "line": 78,
        "fullcodeline": "if (!*userData) return GF_OUT_OF_MEM;"
    },
    {
        "line": 79,
        "fullcodeline": "memcpy(*userData, str, sizeof(char)*len);"
    }
]