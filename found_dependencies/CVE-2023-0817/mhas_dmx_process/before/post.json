[
    {
        "line": 3,
        "fullcodeline": "GF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);"
    },
    {
        "line": 7,
        "fullcodeline": "Bool final_flush=GF_FALSE;"
    },
    {
        "line": 9,
        "fullcodeline": "u64 cts = GF_FILTER_NO_TS;"
    },
    {
        "line": 10,
        "fullcodeline": "u32 au_start = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "u32 consumed = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "u32 nb_trunc_samples = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "Bool trunc_from_begin = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "Bool has_cfg = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "in_pck = gf_filter_pid_get_packet(ctx->ipid);"
    },
    {
        "line": 39,
        "fullcodeline": "prev_pck_size = ctx->mhas_buffer_size;"
    },
    {
        "line": 79,
        "fullcodeline": "remain = ctx->mhas_buffer_size;"
    },
    {
        "line": 80,
        "fullcodeline": "start = ctx->mhas_buffer;"
    },
    {
        "line": 107,
        "fullcodeline": "gf_bs_reassign_buffer(ctx->bs, start, remain);"
    },
    {
        "line": 108,
        "fullcodeline": "ctx->buffer_too_small = GF_FALSE;"
    },
    {
        "line": 339,
        "fullcodeline": "ctx->mhas_buffer_size = remain;"
    },
    {
        "line": 20,
        "fullcodeline": "if (ctx->opid && !ctx->is_playing)"
    },
    {
        "line": 24,
        "fullcodeline": "if (!in_pck) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (ctx->timescale && in_pck) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (cts == GF_FILTER_NO_TS) {"
    },
    {
        "line": 88,
        "fullcodeline": "while (ctx->nosync && (remain>3)) {"
    },
    {
        "line": 111,
        "fullcodeline": "while (remain > consumed) {"
    },
    {
        "line": 333,
        "fullcodeline": "if (remain < ctx->mhas_buffer_size) {"
    },
    {
        "line": 343,
        "fullcodeline": "if (!ctx->mhas_buffer_size) {"
    },
    {
        "line": 18,
        "fullcodeline": "mhas_dmx_check_dur(filter, ctx);"
    },
    {
        "line": 41,
        "fullcodeline": "in_pck = NULL;"
    },
    {
        "line": 44,
        "fullcodeline": "u8 *data = (u8 *) gf_filter_pck_get_data(in_pck, &pck_size);"
    },
    {
        "line": 62,
        "fullcodeline": "memcpy(ctx->mhas_buffer + ctx->mhas_buffer_size, data, pck_size);"
    },
    {
        "line": 63,
        "fullcodeline": "ctx->mhas_buffer_size += pck_size;"
    },
    {
        "line": 68,
        "fullcodeline": "cts = gf_filter_pck_get_cts(in_pck);"
    },
    {
        "line": 76,
        "fullcodeline": "prev_pck_size = 0;"
    },
    {
        "line": 83,
        "fullcodeline": "start += ctx->resume_from - 1;"
    },
    {
        "line": 84,
        "fullcodeline": "remain -= ctx->resume_from - 1;"
    },
    {
        "line": 85,
        "fullcodeline": "ctx->resume_from = 0;"
    },
    {
        "line": 90,
        "fullcodeline": "u8 *hdr_start = memchr(start, 0xC0, remain);"
    },
    {
        "line": 100,
        "fullcodeline": "GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] not sync, skipping byte\\n\"));"
    },
    {
        "line": 101,
        "fullcodeline": "start++;"
    },
    {
        "line": 102,
        "fullcodeline": "remain--;"
    },
    {
        "line": 113,
        "fullcodeline": "Bool mhas_sap = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "mhas_type = (u32) gf_mpegh_escaped_value(ctx->bs, 3, 8, 8);"
    },
    {
        "line": 122,
        "fullcodeline": "mhas_label = (u32) gf_mpegh_escaped_value(ctx->bs, 2, 8, 32);"
    },
    {
        "line": 123,
        "fullcodeline": "mhas_size = (u32) gf_mpegh_escaped_value(ctx->bs, 11, 24, 24);"
    },
    {
        "line": 148,
        "fullcodeline": "pay_start = (u32) gf_bs_get_position(ctx->bs);"
    },
    {
        "line": 156,
        "fullcodeline": "ctx->is_sync = GF_TRUE;"
    },
    {
        "line": 223,
        "fullcodeline": "gf_bs_align(ctx->bs);"
    },
    {
        "line": 224,
        "fullcodeline": "parse_end = (u32) gf_bs_get_position(ctx->bs) - pay_start;"
    },
    {
        "line": 226,
        "fullcodeline": "gf_bs_skip_bytes(ctx->bs, mhas_size - parse_end);"
    },
    {
        "line": 326,
        "fullcodeline": "assert(remain>=consumed);"
    },
    {
        "line": 327,
        "fullcodeline": "remain -= consumed;"
    },
    {
        "line": 328,
        "fullcodeline": "start += consumed;"
    },
    {
        "line": 334,
        "fullcodeline": "memmove(ctx->mhas_buffer, start, remain);"
    },
    {
        "line": 341,
        "fullcodeline": "ctx->mhas_buffer_size = 0;"
    },
    {
        "line": 345,
        "fullcodeline": "ctx->src_pck = NULL;"
    },
    {
        "line": 349,
        "fullcodeline": "gf_filter_pid_drop_packet(ctx->ipid);"
    },
    {
        "line": 25,
        "fullcodeline": "if (gf_filter_pid_is_eos(ctx->ipid)) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (ctx->byte_offset != GF_FILTER_NO_BO) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (ctx->mhas_buffer_size + pck_size > ctx->mhas_buffer_alloc) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (!ctx->cts && (cts != GF_FILTER_NO_TS))"
    },
    {
        "line": 91,
        "fullcodeline": "if (!hdr_start) {"
    },
    {
        "line": 95,
        "fullcodeline": "if ((hdr_start[1]==0x01) && (hdr_start[2]==0xA5)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (!ctx->is_playing && ctx->opid) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (mhas_type>18) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (mhas_size > gf_bs_available(ctx->bs)) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (mhas_type==2) {"
    },
    {
        "line": 230,
        "fullcodeline": "if (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {"
    },
    {
        "line": 236,
        "fullcodeline": "if ((mhas_type==2) && ctx->opid) {"
    },
    {
        "line": 336,
        "fullcodeline": "if (ctx->byte_offset != GF_FILTER_NO_BO)"
    },
    {
        "line": 33,
        "fullcodeline": "final_flush = GF_TRUE;"
    },
    {
        "line": 47,
        "fullcodeline": "u64 byte_offset = gf_filter_pck_get_byte_offset(in_pck);"
    },
    {
        "line": 59,
        "fullcodeline": "ctx->mhas_buffer_alloc = ctx->mhas_buffer_size + pck_size;"
    },
    {
        "line": 60,
        "fullcodeline": "ctx->mhas_buffer = gf_realloc(ctx->mhas_buffer, ctx->mhas_buffer_alloc);"
    },
    {
        "line": 71,
        "fullcodeline": "ctx->cts = cts;"
    },
    {
        "line": 92,
        "fullcodeline": "remain=0;"
    },
    {
        "line": 96,
        "fullcodeline": "GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] Sync found !\\n\"));"
    },
    {
        "line": 97,
        "fullcodeline": "ctx->nosync = GF_FALSE;"
    },
    {
        "line": 116,
        "fullcodeline": "ctx->resume_from = 1;"
    },
    {
        "line": 117,
        "fullcodeline": "consumed = 0;"
    },
    {
        "line": 130,
        "fullcodeline": "ctx->nb_unknown_pck++;"
    },
    {
        "line": 160,
        "fullcodeline": "mhas_sap = gf_bs_peek_bits(ctx->bs, 1, 0);"
    },
    {
        "line": 161,
        "fullcodeline": "ctx->nb_unknown_pck = 0;"
    },
    {
        "line": 231,
        "fullcodeline": "ctx->cts = cts;"
    },
    {
        "line": 232,
        "fullcodeline": "cts = GF_FILTER_NO_TS;"
    },
    {
        "line": 238,
        "fullcodeline": "u64 pck_dur = ctx->frame_len;"
    },
    {
        "line": 270,
        "fullcodeline": "dst = gf_filter_pck_new_alloc(ctx->opid, au_size, &output);"
    },
    {
        "line": 274,
        "fullcodeline": "memcpy(output, start + au_start, au_size);"
    },
    {
        "line": 281,
        "fullcodeline": "gf_filter_pck_set_dts(dst, ctx->cts);"
    },
    {
        "line": 282,
        "fullcodeline": "gf_filter_pck_set_cts(dst, ctx->cts);"
    },
    {
        "line": 283,
        "fullcodeline": "gf_filter_pck_set_duration(dst, (u32) pck_dur);"
    },
    {
        "line": 290,
        "fullcodeline": "gf_filter_pck_send(dst);"
    },
    {
        "line": 292,
        "fullcodeline": "au_start += au_size;"
    },
    {
        "line": 293,
        "fullcodeline": "consumed = au_start;"
    },
    {
        "line": 294,
        "fullcodeline": "ctx->nb_frames ++;"
    },
    {
        "line": 296,
        "fullcodeline": "mhas_dmx_update_cts(ctx);"
    },
    {
        "line": 297,
        "fullcodeline": "has_cfg = 0;"
    },
    {
        "line": 337,
        "fullcodeline": "ctx->byte_offset += ctx->mhas_buffer_size - remain;"
    },
    {
        "line": 344,
        "fullcodeline": "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);"
    },
    {
        "line": 26,
        "fullcodeline": "if (!ctx->mhas_buffer_size) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (!ctx->mhas_buffer_size) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (ctx->nb_unknown_pck > ctx->pcksync) {"
    },
    {
        "line": 271,
        "fullcodeline": "if (!dst) break;"
    },
    {
        "line": 275,
        "fullcodeline": "if (!has_cfg)"
    },
    {
        "line": 284,
        "fullcodeline": "if (ctx->byte_offset != GF_FILTER_NO_BO) {"
    },
    {
        "line": 315,
        "fullcodeline": "if (remain==consumed)"
    },
    {
        "line": 318,
        "fullcodeline": "if (gf_filter_pid_would_block(ctx->opid)) {"
    },
    {
        "line": 30,
        "fullcodeline": "ctx->src_pck = NULL;"
    },
    {
        "line": 34,
        "fullcodeline": "} else if (!ctx->resume_from) {"
    },
    {
        "line": 49,
        "fullcodeline": "ctx->byte_offset = byte_offset;"
    },
    {
        "line": 132,
        "fullcodeline": "GF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] %d packets of unknown type, considering sync was lost\\n\"));"
    },
    {
        "line": 133,
        "fullcodeline": "ctx->is_sync = GF_FALSE;"
    },
    {
        "line": 134,
        "fullcodeline": "consumed = 0;"
    },
    {
        "line": 135,
        "fullcodeline": "ctx->nosync = GF_TRUE;"
    },
    {
        "line": 136,
        "fullcodeline": "ctx->nb_unknown_pck = 0;"
    },
    {
        "line": 139,
        "fullcodeline": "} else if (!mhas_size) {"
    },
    {
        "line": 164,
        "fullcodeline": "else if (mhas_type==1) {"
    },
    {
        "line": 243,
        "fullcodeline": "au_start = pay_start;"
    },
    {
        "line": 244,
        "fullcodeline": "au_size = mhas_size;"
    },
    {
        "line": 262,
        "fullcodeline": "nb_trunc_samples = 0;"
    },
    {
        "line": 266,
        "fullcodeline": "pck_dur *= ctx->timescale;"
    },
    {
        "line": 267,
        "fullcodeline": "pck_dur /= ctx->sample_rate;"
    },
    {
        "line": 272,
        "fullcodeline": "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst);"
    },
    {
        "line": 276,
        "fullcodeline": "mhas_sap = 0;"
    },
    {
        "line": 279,
        "fullcodeline": "gf_filter_pck_set_sap(dst, GF_FILTER_SAP_1);"
    },
    {
        "line": 285,
        "fullcodeline": "u64 offset = (u64) (start - ctx->mhas_buffer);"
    },
    {
        "line": 286,
        "fullcodeline": "offset += ctx->byte_offset + au_start;"
    },
    {
        "line": 287,
        "fullcodeline": "gf_filter_pck_set_byte_offset(dst, offset);"
    },
    {
        "line": 300,
        "fullcodeline": "u64 next_pos = (u64) (start + au_start - ctx->mhas_buffer);"
    },
    {
        "line": 319,
        "fullcodeline": "ctx->resume_from = 1;"
    },
    {
        "line": 320,
        "fullcodeline": "final_flush = GF_FALSE;"
    },
    {
        "line": 140,
        "fullcodeline": "GF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] MHAS packet with 0 payload size, considering sync was lost\\n\"));"
    },
    {
        "line": 141,
        "fullcodeline": "ctx->is_sync = GF_FALSE;"
    },
    {
        "line": 142,
        "fullcodeline": "consumed = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "ctx->nosync = GF_TRUE;"
    },
    {
        "line": 144,
        "fullcodeline": "ctx->nb_unknown_pck = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "s32 CICPspeakerLayoutIdx = -1;"
    },
    {
        "line": 166,
        "fullcodeline": "s32 numSpeakers = -1;"
    },
    {
        "line": 167,
        "fullcodeline": "u32 sr = 0;"
    },
    {
        "line": 169,
        "fullcodeline": "u32 pl = gf_bs_read_u8(ctx->bs);"
    },
    {
        "line": 170,
        "fullcodeline": "u32 idx = gf_bs_read_int(ctx->bs, 5);"
    },
    {
        "line": 176,
        "fullcodeline": "ctx->nb_unknown_pck = 0;"
    },
    {
        "line": 177,
        "fullcodeline": "idx = gf_bs_read_int(ctx->bs, 3);"
    },
    {
        "line": 180,
        "fullcodeline": "gf_bs_read_int(ctx->bs, 1);"
    },
    {
        "line": 181,
        "fullcodeline": "gf_bs_read_int(ctx->bs, 1);"
    },
    {
        "line": 184,
        "fullcodeline": "u32 speakerLayoutType = gf_bs_read_int(ctx->bs, 2);"
    },
    {
        "line": 192,
        "fullcodeline": "mhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);"
    },
    {
        "line": 194,
        "fullcodeline": "has_cfg = GF_TRUE;"
    },
    {
        "line": 246,
        "fullcodeline": "au_size = (u32) gf_bs_get_position(ctx->bs) - au_start;"
    },
    {
        "line": 302,
        "fullcodeline": "if (prev_pck_size <= next_pos) {"
    },
    {
        "line": 28,
        "fullcodeline": "gf_filter_pid_set_eos(ctx->opid);"
    },
    {
        "line": 29,
        "fullcodeline": "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);"
    },
    {
        "line": 50,
        "fullcodeline": "} else if (ctx->byte_offset + ctx->mhas_buffer_size != byte_offset) {"
    },
    {
        "line": 171,
        "fullcodeline": "if (idx==0x1f)"
    },
    {
        "line": 178,
        "fullcodeline": "if ((idx==0) || (idx==2) ) frame_len = 768;"
    },
    {
        "line": 185,
        "fullcodeline": "if (speakerLayoutType == 0) {"
    },
    {
        "line": 303,
        "fullcodeline": "prev_pck_size = 0;"
    },
    {
        "line": 305,
        "fullcodeline": "ctx->src_pck = in_pck;"
    },
    {
        "line": 51,
        "fullcodeline": "ctx->byte_offset = GF_FILTER_NO_BO;"
    },
    {
        "line": 172,
        "fullcodeline": "sr = gf_bs_read_int(ctx->bs, 24);"
    },
    {
        "line": 186,
        "fullcodeline": "CICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);"
    },
    {
        "line": 197,
        "fullcodeline": "else if (mhas_type==17) {"
    },
    {
        "line": 251,
        "fullcodeline": "if (!ctx->nb_frames) {"
    },
    {
        "line": 260,
        "fullcodeline": "pck_dur -= nb_trunc_samples;"
    },
    {
        "line": 309,
        "fullcodeline": "if (ctx->timescale && (cts != GF_FILTER_NO_TS) ) {"
    },
    {
        "line": 52,
        "fullcodeline": "if ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->mhas_buffer_size) ) {"
    },
    {
        "line": 179,
        "fullcodeline": "else frame_len = 1024;"
    },
    {
        "line": 188,
        "fullcodeline": "numSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;"
    },
    {
        "line": 198,
        "fullcodeline": "Bool isActive = gf_bs_read_int(ctx->bs, 1);"
    },
    {
        "line": 199,
        "fullcodeline": "/*Bool ati_reserved = */gf_bs_read_int(ctx->bs, 1);"
    },
    {
        "line": 200,
        "fullcodeline": "trunc_from_begin = gf_bs_read_int(ctx->bs, 1);"
    },
    {
        "line": 201,
        "fullcodeline": "nb_trunc_samples = gf_bs_read_int(ctx->bs, 13);"
    },
    {
        "line": 252,
        "fullcodeline": "s64 offset = trunc_from_begin;"
    },
    {
        "line": 257,
        "fullcodeline": "gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DELAY , &PROP_LONGSINT( -offset));"
    },
    {
        "line": 304,
        "fullcodeline": "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);"
    },
    {
        "line": 307,
        "fullcodeline": "gf_filter_pck_ref_props(&ctx->src_pck);"
    },
    {
        "line": 310,
        "fullcodeline": "ctx->cts = cts;"
    },
    {
        "line": 311,
        "fullcodeline": "cts = GF_FILTER_NO_TS;"
    },
    {
        "line": 53,
        "fullcodeline": "ctx->byte_offset = byte_offset - ctx->mhas_buffer_size;"
    },
    {
        "line": 173,
        "fullcodeline": "else if (sr < nb_usac_sr) {"
    },
    {
        "line": 202,
        "fullcodeline": "if (!isActive) {"
    },
    {
        "line": 203,
        "fullcodeline": "nb_trunc_samples = 0;"
    },
    {
        "line": 207,
        "fullcodeline": "else if ((mhas_type==6) || (mhas_type==7)) {"
    },
    {
        "line": 254,
        "fullcodeline": "offset *= ctx->timescale;"
    },
    {
        "line": 255,
        "fullcodeline": "offset /= ctx->sample_rate;"
    },
    {
        "line": 208,
        "fullcodeline": "ctx->nb_unknown_pck = 0;"
    }
]