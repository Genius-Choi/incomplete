[
    {
        "line": 6,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "ext4_io_end_t *io = ext4_inode_aio(inode);"
    },
    {
        "line": 10,
        "fullcodeline": "ext_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical \""
    },
    {
        "line": 14,
        "fullcodeline": "ext4_ext_show_leaf(inode, path);"
    },
    {
        "line": 16,
        "fullcodeline": "trace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,"
    },
    {
        "line": 72,
        "fullcodeline": "ret = ext4_ext_convert_to_initialized(handle, inode, map, path);"
    },
    {
        "line": 81,
        "fullcodeline": "map->m_flags |= EXT4_MAP_NEW;"
    },
    {
        "line": 114,
        "fullcodeline": "map->m_flags |= EXT4_MAP_MAPPED;"
    },
    {
        "line": 124,
        "fullcodeline": "ext4_ext_show_leaf(inode, path);"
    },
    {
        "line": 125,
        "fullcodeline": "map->m_pblk = newblock;"
    },
    {
        "line": 126,
        "fullcodeline": "map->m_len = allocated;"
    },
    {
        "line": 12,
        "fullcodeline": "inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,"
    },
    {
        "line": 20,
        "fullcodeline": "if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {"
    },
    {
        "line": 39,
        "fullcodeline": "if ((flags & EXT4_GET_BLOCKS_CONVERT)) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (flags & EXT4_GET_BLOCKS_UNINIT_EXT)"
    },
    {
        "line": 59,
        "fullcodeline": "if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (ret >= 0)"
    },
    {
        "line": 76,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (allocated > map->m_len) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {"
    },
    {
        "line": 115,
        "fullcodeline": "if ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (allocated > map->m_len)"
    },
    {
        "line": 132,
        "fullcodeline": "return err ? err : allocated;"
    },
    {
        "line": 21,
        "fullcodeline": "ret = ext4_split_unwritten_extents(handle, inode, map,"
    },
    {
        "line": 40,
        "fullcodeline": "ret = ext4_convert_unwritten_extents_endio(handle, inode, map,"
    },
    {
        "line": 67,
        "fullcodeline": "map->m_flags |= EXT4_MAP_UNWRITTEN;"
    },
    {
        "line": 74,
        "fullcodeline": "ext4_update_inode_fsync_trans(handle, inode, 1);"
    },
    {
        "line": 77,
        "fullcodeline": "err = ret;"
    },
    {
        "line": 90,
        "fullcodeline": "unmap_underlying_metadata_blocks(inode->i_sb->s_bdev,"
    },
    {
        "line": 93,
        "fullcodeline": "allocated = map->m_len;"
    },
    {
        "line": 105,
        "fullcodeline": "reserved_clusters = get_reserved_cluster_alloc(inode,"
    },
    {
        "line": 116,
        "fullcodeline": "err = check_eofblocks_fl(handle, inode, map->m_lblk, path,"
    },
    {
        "line": 123,
        "fullcodeline": "allocated = map->m_len;"
    },
    {
        "line": 129,
        "fullcodeline": "ext4_ext_drop_refs(path);"
    },
    {
        "line": 130,
        "fullcodeline": "kfree(path);"
    },
    {
        "line": 23,
        "fullcodeline": "if (ret <= 0)"
    },
    {
        "line": 34,
        "fullcodeline": "if (ext4_should_dioread_nolock(inode))"
    },
    {
        "line": 42,
        "fullcodeline": "if (ret >= 0) {"
    },
    {
        "line": 80,
        "fullcodeline": "allocated = ret;"
    },
    {
        "line": 91,
        "fullcodeline": "newblock + map->m_len,"
    },
    {
        "line": 92,
        "fullcodeline": "allocated - map->m_len);"
    },
    {
        "line": 118,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 31,
        "fullcodeline": "ext4_set_io_unwritten_flag(inode, io);"
    },
    {
        "line": 35,
        "fullcodeline": "map->m_flags |= EXT4_MAP_UNINIT;"
    },
    {
        "line": 43,
        "fullcodeline": "ext4_update_inode_fsync_trans(handle, inode, 1);"
    },
    {
        "line": 44,
        "fullcodeline": "err = check_eofblocks_fl(handle, inode, map->m_lblk,"
    },
    {
        "line": 108,
        "fullcodeline": "ext4_da_update_reserve_space(inode,"
    },
    {
        "line": 33,
        "fullcodeline": "ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);"
    },
    {
        "line": 47,
        "fullcodeline": "err = ret;"
    }
]