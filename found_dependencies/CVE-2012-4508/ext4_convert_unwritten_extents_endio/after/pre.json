[
    {
        "line": 10,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "depth = ext_depth(inode);"
    },
    {
        "line": 13,
        "fullcodeline": "ex = path[depth].p_ext;"
    },
    {
        "line": 14,
        "fullcodeline": "ee_block = le32_to_cpu(ex->ee_block);"
    },
    {
        "line": 15,
        "fullcodeline": "ee_len = ext4_ext_get_actual_len(ex);"
    },
    {
        "line": 17,
        "fullcodeline": "ext_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\""
    },
    {
        "line": 37,
        "fullcodeline": "err = ext4_ext_get_access(handle, inode, path + depth);"
    },
    {
        "line": 41,
        "fullcodeline": "ext4_ext_mark_initialized(ex);"
    },
    {
        "line": 46,
        "fullcodeline": "ext4_ext_try_to_merge(handle, inode, path, ex);"
    },
    {
        "line": 49,
        "fullcodeline": "err = ext4_ext_dirty(handle, inode, path + path->p_depth);"
    },
    {
        "line": 51,
        "fullcodeline": "ext4_ext_show_leaf(inode, path);"
    },
    {
        "line": 22,
        "fullcodeline": "if (ee_block != map->m_lblk || ee_len > map->m_len) {"
    },
    {
        "line": 23,
        "fullcodeline": "err = ext4_split_unwritten_extents(handle, inode, map, path,"
    },
    {
        "line": 27,
        "fullcodeline": "ext4_ext_drop_refs(path);"
    },
    {
        "line": 28,
        "fullcodeline": "path = ext4_ext_find_extent(inode, map->m_lblk, path);"
    },
    {
        "line": 33,
        "fullcodeline": "depth = ext_depth(inode);"
    },
    {
        "line": 34,
        "fullcodeline": "ex = path[depth].p_ext;"
    },
    {
        "line": 25,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 29,
        "fullcodeline": "if (IS_ERR(path)) {"
    },
    {
        "line": 30,
        "fullcodeline": "err = PTR_ERR(path);"
    }
]