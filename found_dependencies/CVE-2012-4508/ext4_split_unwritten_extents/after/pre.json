[
    {
        "line": 11,
        "fullcodeline": "int split_flag = 0, depth;"
    },
    {
        "line": 13,
        "fullcodeline": "ext_debug(\"ext4_split_unwritten_extents: inode %lu, logical\""
    },
    {
        "line": 17,
        "fullcodeline": "eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>"
    },
    {
        "line": 25,
        "fullcodeline": "depth = ext_depth(inode);"
    },
    {
        "line": 26,
        "fullcodeline": "ex = path[depth].p_ext;"
    },
    {
        "line": 27,
        "fullcodeline": "ee_block = le32_to_cpu(ex->ee_block);"
    },
    {
        "line": 28,
        "fullcodeline": "ee_len = ext4_ext_get_actual_len(ex);"
    },
    {
        "line": 30,
        "fullcodeline": "split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;"
    },
    {
        "line": 31,
        "fullcodeline": "split_flag |= EXT4_EXT_MARK_UNINIT2;"
    },
    {
        "line": 34,
        "fullcodeline": "flags |= EXT4_GET_BLOCKS_PRE_IO;"
    },
    {
        "line": 19,
        "fullcodeline": "if (eof_block < map->m_lblk + map->m_len)"
    },
    {
        "line": 32,
        "fullcodeline": "if (flags & EXT4_GET_BLOCKS_CONVERT)"
    },
    {
        "line": 35,
        "fullcodeline": "return ext4_split_extent(handle, inode, path, map, split_flag, flags);"
    },
    {
        "line": 20,
        "fullcodeline": "eof_block = map->m_lblk + map->m_len;"
    },
    {
        "line": 33,
        "fullcodeline": "split_flag |= EXT4_EXT_DATA_VALID2;"
    }
]