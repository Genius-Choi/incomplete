[
    {
        "line": 5,
        "fullcodeline": "if (client->serverPort==-1)"
    },
    {
        "line": 7,
        "fullcodeline": "if (!ReadFromRFBServer(client, (char *)&msg, 1))"
    },
    {
        "line": 6,
        "fullcodeline": "client->vncRec->readTimestamp = TRUE;"
    },
    {
        "line": 52,
        "fullcodeline": "msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);"
    },
    {
        "line": 497,
        "fullcodeline": "client->Bell(client);"
    },
    {
        "line": 510,
        "fullcodeline": "msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);"
    },
    {
        "line": 517,
        "fullcodeline": "buffer = malloc((uint64_t)msg.sct.length+1);"
    },
    {
        "line": 524,
        "fullcodeline": "buffer[msg.sct.length] = 0;"
    },
    {
        "line": 529,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 536,
        "fullcodeline": "char *buffer=NULL;"
    },
    {
        "line": 540,
        "fullcodeline": "msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);"
    },
    {
        "line": 581,
        "fullcodeline": "SetClient2Server(client, rfbXvp);"
    },
    {
        "line": 585,
        "fullcodeline": "SetServer2Client(client, rfbXvp);"
    },
    {
        "line": 598,
        "fullcodeline": "client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);"
    },
    {
        "line": 599,
        "fullcodeline": "client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);"
    },
    {
        "line": 600,
        "fullcodeline": "client->updateRect.x = client->updateRect.y = 0;"
    },
    {
        "line": 601,
        "fullcodeline": "client->updateRect.w = client->width;"
    },
    {
        "line": 602,
        "fullcodeline": "client->updateRect.h = client->height;"
    },
    {
        "line": 606,
        "fullcodeline": "SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);"
    },
    {
        "line": 607,
        "fullcodeline": "rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);"
    },
    {
        "line": 616,
        "fullcodeline": "client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);"
    },
    {
        "line": 617,
        "fullcodeline": "client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);"
    },
    {
        "line": 618,
        "fullcodeline": "client->updateRect.x = client->updateRect.y = 0;"
    },
    {
        "line": 619,
        "fullcodeline": "client->updateRect.w = client->width;"
    },
    {
        "line": 620,
        "fullcodeline": "client->updateRect.h = client->height;"
    },
    {
        "line": 623,
        "fullcodeline": "SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);"
    },
    {
        "line": 624,
        "fullcodeline": "rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);"
    },
    {
        "line": 630,
        "fullcodeline": "rfbBool handled = FALSE;"
    },
    {
        "line": 48,
        "fullcodeline": "if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,"
    },
    {
        "line": 54,
        "fullcodeline": "for (i = 0; i < msg.fu.nRects; i++) {"
    },
    {
        "line": 486,
        "fullcodeline": "if (!SendIncrementalFramebufferUpdateRequest(client))"
    },
    {
        "line": 506,
        "fullcodeline": "if (!ReadFromRFBServer(client, ((char *)&msg) + 1,"
    },
    {
        "line": 512,
        "fullcodeline": "if (msg.sct.length > 1<<20) {"
    },
    {
        "line": 519,
        "fullcodeline": "if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {"
    },
    {
        "line": 537,
        "fullcodeline": "if (!ReadFromRFBServer(client, ((char *)&msg) + 1,"
    },
    {
        "line": 577,
        "fullcodeline": "if (!ReadFromRFBServer(client, ((char *)&msg) + 1,"
    },
    {
        "line": 595,
        "fullcodeline": "if (!ReadFromRFBServer(client, ((char *)&msg) + 1,"
    },
    {
        "line": 603,
        "fullcodeline": "if (!client->MallocFrameBuffer(client))"
    },
    {
        "line": 613,
        "fullcodeline": "if (!ReadFromRFBServer(client, ((char *)&msg) + 1,"
    },
    {
        "line": 621,
        "fullcodeline": "if (!client->MallocFrameBuffer(client))"
    },
    {
        "line": 633,
        "fullcodeline": "for(e = rfbClientExtensions; !handled && e; e = e->next)"
    },
    {
        "line": 637,
        "fullcodeline": "if(!handled) {"
    },
    {
        "line": 58,
        "fullcodeline": "rect.encoding = rfbClientSwap32IfLE(rect.encoding);"
    },
    {
        "line": 62,
        "fullcodeline": "rect.r.x = rfbClientSwap16IfLE(rect.r.x);"
    },
    {
        "line": 63,
        "fullcodeline": "rect.r.y = rfbClientSwap16IfLE(rect.r.y);"
    },
    {
        "line": 64,
        "fullcodeline": "rect.r.w = rfbClientSwap16IfLE(rect.r.w);"
    },
    {
        "line": 65,
        "fullcodeline": "rect.r.h = rfbClientSwap16IfLE(rect.r.h);"
    },
    {
        "line": 481,
        "fullcodeline": "client->SoftCursorUnlockScreen(client);"
    },
    {
        "line": 483,
        "fullcodeline": "client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);"
    },
    {
        "line": 490,
        "fullcodeline": "client->FinishedFrameBufferUpdate(client);"
    },
    {
        "line": 513,
        "fullcodeline": "rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);"
    },
    {
        "line": 520,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 527,
        "fullcodeline": "client->GotXCutText(client, buffer, msg.sct.length);"
    },
    {
        "line": 543,
        "fullcodeline": "rfbClientLog(\"Received TextChat Open\\n\");"
    },
    {
        "line": 548,
        "fullcodeline": "rfbClientLog(\"Received TextChat Close\\n\");"
    },
    {
        "line": 553,
        "fullcodeline": "rfbClientLog(\"Received TextChat Finished\\n\");"
    },
    {
        "line": 558,
        "fullcodeline": "buffer=malloc(msg.tc.length+1);"
    },
    {
        "line": 565,
        "fullcodeline": "buffer[msg.tc.length]=0;"
    },
    {
        "line": 566,
        "fullcodeline": "rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);"
    },
    {
        "line": 569,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 588,
        "fullcodeline": "client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);"
    },
    {
        "line": 634,
        "fullcodeline": "if(e->handleMessage && e->handleMessage(client, &msg))"
    },
    {
        "line": 638,
        "fullcodeline": "char buffer[256];"
    },
    {
        "line": 639,
        "fullcodeline": "rfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);"
    },
    {
        "line": 640,
        "fullcodeline": "ReadFromRFBServer(client, buffer, 256);"
    },
    {
        "line": 49,
        "fullcodeline": "sz_rfbFramebufferUpdateMsg - 1))"
    },
    {
        "line": 55,
        "fullcodeline": "if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))"
    },
    {
        "line": 59,
        "fullcodeline": "if (rect.encoding == rfbEncodingLastRect)"
    },
    {
        "line": 68,
        "fullcodeline": "if (rect.encoding == rfbEncodingXCursor ||"
    },
    {
        "line": 79,
        "fullcodeline": "if (rect.encoding == rfbEncodingPointerPos) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (rect.encoding == rfbEncodingKeyboardLedState) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (rect.encoding == rfbEncodingNewFBSize) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (rect.encoding == rfbEncodingSupportedMessages) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (rect.encoding == rfbEncodingSupportedEncodings) {"
    },
    {
        "line": 153,
        "fullcodeline": "if (rect.encoding == rfbEncodingServerIdentity) {"
    },
    {
        "line": 168,
        "fullcodeline": "if (rect.encoding != rfbEncodingUltraZip)"
    },
    {
        "line": 507,
        "fullcodeline": "sz_rfbServerCutTextMsg - 1))"
    },
    {
        "line": 538,
        "fullcodeline": "sz_rfbTextChatMsg- 1))"
    },
    {
        "line": 544,
        "fullcodeline": "if (client->HandleTextChat!=NULL)"
    },
    {
        "line": 549,
        "fullcodeline": "if (client->HandleTextChat!=NULL)"
    },
    {
        "line": 554,
        "fullcodeline": "if (client->HandleTextChat!=NULL)"
    },
    {
        "line": 559,
        "fullcodeline": "if (!ReadFromRFBServer(client, buffer, msg.tc.length))"
    },
    {
        "line": 567,
        "fullcodeline": "if (client->HandleTextChat!=NULL)"
    },
    {
        "line": 578,
        "fullcodeline": "sz_rfbXvpMsg -1))"
    },
    {
        "line": 596,
        "fullcodeline": "sz_rfbResizeFrameBufferMsg -1))"
    },
    {
        "line": 614,
        "fullcodeline": "sz_rfbPalmVNCReSizeFrameBufferMsg -1))"
    },
    {
        "line": 635,
        "fullcodeline": "handled = TRUE;"
    },
    {
        "line": 69,
        "fullcodeline": "rect.encoding == rfbEncodingRichCursor) {"
    },
    {
        "line": 88,
        "fullcodeline": "client->KeyboardLedStateEnabled = 1;"
    },
    {
        "line": 92,
        "fullcodeline": "client->CurrentKeyboardLedState = rect.r.x;"
    },
    {
        "line": 97,
        "fullcodeline": "client->width = rect.r.w;"
    },
    {
        "line": 98,
        "fullcodeline": "client->height = rect.r.h;"
    },
    {
        "line": 99,
        "fullcodeline": "client->updateRect.x = client->updateRect.y = 0;"
    },
    {
        "line": 100,
        "fullcodeline": "client->updateRect.w = client->width;"
    },
    {
        "line": 101,
        "fullcodeline": "client->updateRect.h = client->height;"
    },
    {
        "line": 104,
        "fullcodeline": "SendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);"
    },
    {
        "line": 105,
        "fullcodeline": "rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);"
    },
    {
        "line": 118,
        "fullcodeline": "rfbClientLog(\"client2server supported messages (bit flags)\\n\");"
    },
    {
        "line": 126,
        "fullcodeline": "rfbClientLog(\"server2client supported messages (bit flags)\\n\");"
    },
    {
        "line": 139,
        "fullcodeline": "buffer = malloc(rect.r.w);"
    },
    {
        "line": 148,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 155,
        "fullcodeline": "buffer = malloc(rect.r.w+1);"
    },
    {
        "line": 161,
        "fullcodeline": "buffer[rect.r.w]=0; /* null terminate, just in case */"
    },
    {
        "line": 162,
        "fullcodeline": "rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);"
    },
    {
        "line": 163,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 190,
        "fullcodeline": "client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);"
    },
    {
        "line": 545,
        "fullcodeline": "client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);"
    },
    {
        "line": 550,
        "fullcodeline": "client->HandleTextChat(client, (int)rfbTextChatClose, NULL);"
    },
    {
        "line": 555,
        "fullcodeline": "client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);"
    },
    {
        "line": 561,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 568,
        "fullcodeline": "client->HandleTextChat(client, (int)msg.tc.length, buffer);"
    },
    {
        "line": 71,
        "fullcodeline": "if (!HandleCursorShape(client,"
    },
    {
        "line": 80,
        "fullcodeline": "if (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (client->HandleKeyboardLedState!=NULL)"
    },
    {
        "line": 102,
        "fullcodeline": "if (!client->MallocFrameBuffer(client))"
    },
    {
        "line": 112,
        "fullcodeline": "if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))"
    },
    {
        "line": 119,
        "fullcodeline": "for (loop=0;loop<32;loop+=8)"
    },
    {
        "line": 120,
        "fullcodeline": "rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,"
    },
    {
        "line": 127,
        "fullcodeline": "for (loop=0;loop<32;loop+=8)"
    },
    {
        "line": 128,
        "fullcodeline": "rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,"
    },
    {
        "line": 140,
        "fullcodeline": "if (!ReadFromRFBServer(client, buffer, rect.r.w))"
    },
    {
        "line": 156,
        "fullcodeline": "if (!ReadFromRFBServer(client, buffer, rect.r.w))"
    },
    {
        "line": 170,
        "fullcodeline": "if ((rect.r.x + rect.r.w > client->width) ||"
    },
    {
        "line": 196,
        "fullcodeline": "int y=rect.r.y, h=rect.r.h;"
    },
    {
        "line": 198,
        "fullcodeline": "bytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;"
    },
    {
        "line": 202,
        "fullcodeline": "linesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;"
    },
    {
        "line": 228,
        "fullcodeline": "cr.srcX = rfbClientSwap16IfLE(cr.srcX);"
    },
    {
        "line": 229,
        "fullcodeline": "cr.srcY = rfbClientSwap16IfLE(cr.srcY);"
    },
    {
        "line": 234,
        "fullcodeline": "client->SoftCursorLockArea(client,"
    },
    {
        "line": 237,
        "fullcodeline": "client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,"
    },
    {
        "line": 465,
        "fullcodeline": "rfbBool handled = FALSE;"
    },
    {
        "line": 90,
        "fullcodeline": "client->HandleKeyboardLedState(client, rect.r.x, 0);"
    },
    {
        "line": 142,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 158,
        "fullcodeline": "free(buffer);"
    },
    {
        "line": 171,
        "fullcodeline": "(rect.r.y + rect.r.h > client->height))"
    },
    {
        "line": 173,
        "fullcodeline": "rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\","
    },
    {
        "line": 204,
        "fullcodeline": "while (linesToRead && h > 0) {"
    },
    {
        "line": 225,
        "fullcodeline": "if (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))"
    },
    {
        "line": 468,
        "fullcodeline": "for(e = rfbClientExtensions; !handled && e; e = e->next)"
    },
    {
        "line": 472,
        "fullcodeline": "if(!handled) {"
    },
    {
        "line": 121,
        "fullcodeline": "client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],"
    },
    {
        "line": 122,
        "fullcodeline": "client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],"
    },
    {
        "line": 123,
        "fullcodeline": "client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],"
    },
    {
        "line": 124,
        "fullcodeline": "client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);"
    },
    {
        "line": 129,
        "fullcodeline": "client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],"
    },
    {
        "line": 130,
        "fullcodeline": "client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],"
    },
    {
        "line": 131,
        "fullcodeline": "client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],"
    },
    {
        "line": 132,
        "fullcodeline": "client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);"
    },
    {
        "line": 211,
        "fullcodeline": "client->GotBitmap(client, (uint8_t *)client->buffer,"
    },
    {
        "line": 214,
        "fullcodeline": "h -= linesToRead;"
    },
    {
        "line": 215,
        "fullcodeline": "y += linesToRead;"
    },
    {
        "line": 469,
        "fullcodeline": "if(e->handleEncoding && e->handleEncoding(client, &rect))"
    },
    {
        "line": 473,
        "fullcodeline": "rfbClientLog(\"Unknown rect encoding %d\\n\","
    },
    {
        "line": 205,
        "fullcodeline": "if (linesToRead > h)"
    },
    {
        "line": 208,
        "fullcodeline": "if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))"
    },
    {
        "line": 247,
        "fullcodeline": "if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 251,
        "fullcodeline": "if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 255,
        "fullcodeline": "if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 266,
        "fullcodeline": "if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 270,
        "fullcodeline": "if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 274,
        "fullcodeline": "if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 285,
        "fullcodeline": "if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 289,
        "fullcodeline": "if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 293,
        "fullcodeline": "if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 304,
        "fullcodeline": "if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 308,
        "fullcodeline": "if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 312,
        "fullcodeline": "if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 322,
        "fullcodeline": "if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 326,
        "fullcodeline": "if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 330,
        "fullcodeline": "if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))"
    },
    {
        "line": 341,
        "fullcodeline": "if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))"
    },
    {
        "line": 345,
        "fullcodeline": "if (client->si.format.greenMax > 0x1F) {"
    },
    {
        "line": 354,
        "fullcodeline": "uint32_t maxColor ="
    },
    {
        "line": 470,
        "fullcodeline": "handled = TRUE;"
    },
    {
        "line": 474,
        "fullcodeline": "(int)rect.encoding);"
    },
    {
        "line": 206,
        "fullcodeline": "linesToRead = h;"
    },
    {
        "line": 355,
        "fullcodeline": "(client->format.redMax << client->format.redShift) |"
    },
    {
        "line": 358,
        "fullcodeline": "if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||"
    },
    {
        "line": 346,
        "fullcodeline": "if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))"
    },
    {
        "line": 359,
        "fullcodeline": "(!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {"
    },
    {
        "line": 349,
        "fullcodeline": "if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))"
    },
    {
        "line": 360,
        "fullcodeline": "if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))"
    },
    {
        "line": 362,
        "fullcodeline": "} else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {"
    },
    {
        "line": 363,
        "fullcodeline": "if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))"
    },
    {
        "line": 365,
        "fullcodeline": "} else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {"
    },
    {
        "line": 366,
        "fullcodeline": "if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,"
    },
    {
        "line": 369,
        "fullcodeline": "} else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,"
    }
]