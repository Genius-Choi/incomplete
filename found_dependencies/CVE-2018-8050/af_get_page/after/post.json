[
    {
        "line": 3,
        "fullcodeline": "uint32_t arg=0;"
    },
    {
        "line": 4,
        "fullcodeline": "size_t page_len=0;"
    },
    {
        "line": 13,
        "fullcodeline": "int r = af_get_page_raw(af,pagenum,&arg,0,&page_len);"
    },
    {
        "line": 34,
        "fullcodeline": "uint32_t pageflag = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "if((arg & AF_PAGE_COMPRESSED)==0){"
    },
    {
        "line": 141,
        "fullcodeline": "if(data && (af->image_pagesize > af->image_sectorsize)){"
    },
    {
        "line": 40,
        "fullcodeline": "int ret = af_get_page_raw(af,pagenum,&pageflag,data,bytes);"
    },
    {
        "line": 142,
        "fullcodeline": "const int SECTOR_SIZE = af->image_sectorsize;\t// for ease of typing"
    },
    {
        "line": 143,
        "fullcodeline": "size_t bytes_left_in_sector = (SECTOR_SIZE - (*bytes % SECTOR_SIZE)) % SECTOR_SIZE;"
    },
    {
        "line": 147,
        "fullcodeline": "size_t end_of_data = *bytes + bytes_left_in_sector;"
    },
    {
        "line": 19,
        "fullcodeline": "if(data && (af->openmode & AF_BADBLOCK_FILL) && errno == ENOENT)"
    },
    {
        "line": 36,
        "fullcodeline": "if(data==0){\t\t\t// if no data provided, just return size of the segment if requested"
    },
    {
        "line": 41,
        "fullcodeline": "if(*bytes > page_len) *bytes = page_len; // we only read this much"
    },
    {
        "line": 42,
        "fullcodeline": "if(ret!=0) return ret;\t\t// some error happened?"
    },
    {
        "line": 46,
        "fullcodeline": "unsigned char *compressed_data = (unsigned char *)malloc(page_len);"
    },
    {
        "line": 47,
        "fullcodeline": "size_t compressed_data_len = page_len;"
    },
    {
        "line": 66,
        "fullcodeline": "int res = -1;\t\t\t// 0 is success"
    },
    {
        "line": 67,
        "fullcodeline": "bool free_data = false;"
    },
    {
        "line": 132,
        "fullcodeline": "free(compressed_data);\t\t// don't need this one anymore"
    },
    {
        "line": 133,
        "fullcodeline": "af->pages_decompressed++;"
    },
    {
        "line": 144,
        "fullcodeline": "for(size_t i=0;i<bytes_left_in_sector;i++){"
    },
    {
        "line": 150,
        "fullcodeline": "for(size_t i = end_of_data; i <= af->image_pagesize-SECTOR_SIZE; i+=SECTOR_SIZE){"
    },
    {
        "line": 27,
        "fullcodeline": "r = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "if(compressed_data==0){"
    },
    {
        "line": 53,
        "fullcodeline": "if(af_get_page_raw(af,pagenum,&pageflag,compressed_data,&compressed_data_len)){"
    },
    {
        "line": 59,
        "fullcodeline": "if(af->image_pagesize <= 0 || af->image_pagesize > 16*1024*1024)"
    },
    {
        "line": 68,
        "fullcodeline": "if(data==0){"
    },
    {
        "line": 74,
        "fullcodeline": "switch((pageflag & AF_PAGE_COMP_ALG_MASK)){"
    },
    {
        "line": 134,
        "fullcodeline": "if(res!=Z_OK) return -1;"
    },
    {
        "line": 145,
        "fullcodeline": "data[*bytes + i] = 0;"
    },
    {
        "line": 151,
        "fullcodeline": "memcpy(data+i,af->badflag,SECTOR_SIZE);"
    },
    {
        "line": 152,
        "fullcodeline": "af->bytes_memcpy += SECTOR_SIZE;"
    },
    {
        "line": 21,
        "fullcodeline": "for(size_t i = 0;i <= af->image_pagesize - af->image_sectorsize;"
    },
    {
        "line": 22,
        "fullcodeline": "i+= af->image_sectorsize){"
    },
    {
        "line": 54,
        "fullcodeline": "free(compressed_data);"
    },
    {
        "line": 69,
        "fullcodeline": "data = (unsigned char *)malloc(af->image_pagesize);"
    },
    {
        "line": 70,
        "fullcodeline": "free_data = true;"
    },
    {
        "line": 71,
        "fullcodeline": "*bytes = af->image_pagesize; // I can hold this much"
    },
    {
        "line": 80,
        "fullcodeline": "memset(data,0,af->image_pagesize);"
    },
    {
        "line": 81,
        "fullcodeline": "*bytes = ntohl(*(long *)compressed_data);"
    },
    {
        "line": 82,
        "fullcodeline": "res = 0;\t\t\t// not very hard to decompress with the ZERO compressor."
    },
    {
        "line": 86,
        "fullcodeline": "res = uncompress(data,(uLongf *)bytes,compressed_data,compressed_data_len);"
    },
    {
        "line": 123,
        "fullcodeline": "(*af->error_reporter)(\"Unknown compression algorithm 0x%d\","
    },
    {
        "line": 129,
        "fullcodeline": "free(data);"
    },
    {
        "line": 130,
        "fullcodeline": "data = 0;\t\t\t// restore the way it was"
    },
    {
        "line": 23,
        "fullcodeline": "memcpy(data+i,af->badflag,af->image_sectorsize);"
    },
    {
        "line": 24,
        "fullcodeline": "af->bytes_memcpy += af->image_sectorsize;"
    },
    {
        "line": 37,
        "fullcodeline": "if(bytes) *bytes = page_len;\t// set the number of bytes in the page if requested"
    },
    {
        "line": 49,
        "fullcodeline": "return -2;\t\t\t// memory error"
    },
    {
        "line": 55,
        "fullcodeline": "return -3;\t\t\t// read error"
    },
    {
        "line": 60,
        "fullcodeline": "return -1;"
    },
    {
        "line": 76,
        "fullcodeline": "if(compressed_data_len != 4){"
    },
    {
        "line": 124,
        "fullcodeline": "pageflag & AF_PAGE_COMP_ALG_MASK);"
    },
    {
        "line": 77,
        "fullcodeline": "(*af->error_reporter)(\"ALG_ZERO compressed data is %d bytes, expected 4.\",compressed_data_len);"
    },
    {
        "line": 103,
        "fullcodeline": "(*af->error_reporter)(\"uncompress returned an invalid value in get_segment\");"
    }
]