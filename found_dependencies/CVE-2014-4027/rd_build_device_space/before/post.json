[
    {
        "line": 3,
        "fullcodeline": "u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;"
    },
    {
        "line": 4,
        "fullcodeline": "u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /"
    },
    {
        "line": 20,
        "fullcodeline": "total_sg_needed = rd_dev->rd_page_count;"
    },
    {
        "line": 22,
        "fullcodeline": "sg_tables = (total_sg_needed / max_sg_per_table) + 1;"
    },
    {
        "line": 24,
        "fullcodeline": "sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);"
    },
    {
        "line": 31,
        "fullcodeline": "rd_dev->sg_table_array = sg_table;"
    },
    {
        "line": 32,
        "fullcodeline": "rd_dev->sg_table_count = sg_tables;"
    },
    {
        "line": 69,
        "fullcodeline": "pr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\""
    },
    {
        "line": 10,
        "fullcodeline": "if (rd_dev->rd_page_count <= 0) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (rd_dev->rd_flags & RDF_NULLIO)"
    },
    {
        "line": 25,
        "fullcodeline": "if (!sg_table) {"
    },
    {
        "line": 11,
        "fullcodeline": "pr_err(\"Illegal page count: %u for Ramdisk device\\n\","
    },
    {
        "line": 26,
        "fullcodeline": "pr_err(\"Unable to allocate memory for Ramdisk\""
    },
    {
        "line": 35,
        "fullcodeline": "sg_per_table = (total_sg_needed > max_sg_per_table) ?"
    },
    {
        "line": 38,
        "fullcodeline": "sg = kzalloc(sg_per_table * sizeof(struct scatterlist),"
    },
    {
        "line": 46,
        "fullcodeline": "sg_init_table(sg, sg_per_table);"
    },
    {
        "line": 48,
        "fullcodeline": "sg_table[i].sg_table = sg;"
    },
    {
        "line": 49,
        "fullcodeline": "sg_table[i].rd_sg_count = sg_per_table;"
    },
    {
        "line": 50,
        "fullcodeline": "sg_table[i].page_start_offset = page_offset;"
    },
    {
        "line": 51,
        "fullcodeline": "sg_table[i++].page_end_offset = (page_offset + sg_per_table)"
    },
    {
        "line": 65,
        "fullcodeline": "page_offset += sg_per_table;"
    },
    {
        "line": 66,
        "fullcodeline": "total_sg_needed -= sg_per_table;"
    },
    {
        "line": 13,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 28,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 40,
        "fullcodeline": "if (!sg) {"
    },
    {
        "line": 54,
        "fullcodeline": "for (j = 0; j < sg_per_table; j++) {"
    },
    {
        "line": 41,
        "fullcodeline": "pr_err(\"Unable to allocate scatterlist array\""
    },
    {
        "line": 55,
        "fullcodeline": "pg = alloc_pages(GFP_KERNEL, 0);"
    },
    {
        "line": 61,
        "fullcodeline": "sg_assign_page(&sg[j], pg);"
    },
    {
        "line": 62,
        "fullcodeline": "sg[j].length = PAGE_SIZE;"
    },
    {
        "line": 43,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 56,
        "fullcodeline": "if (!pg) {"
    },
    {
        "line": 57,
        "fullcodeline": "pr_err(\"Unable to allocate scatterlist\""
    },
    {
        "line": 59,
        "fullcodeline": "return -ENOMEM;"
    }
]