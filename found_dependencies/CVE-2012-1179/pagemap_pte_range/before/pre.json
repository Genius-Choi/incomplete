[
    {
        "line": 5,
        "fullcodeline": "struct pagemapread *pm = walk->private;"
    },
    {
        "line": 7,
        "fullcodeline": "int err = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "split_huge_page_pmd(walk->mm, pmd);"
    },
    {
        "line": 12,
        "fullcodeline": "vma = find_vma(walk->mm, addr);"
    },
    {
        "line": 13,
        "fullcodeline": "for (; addr != end; addr += PAGE_SIZE) {"
    },
    {
        "line": 14,
        "fullcodeline": "u64 pfn = PM_NOT_PRESENT;"
    },
    {
        "line": 30,
        "fullcodeline": "err = add_to_pagemap(addr, pfn, pm);"
    },
    {
        "line": 18,
        "fullcodeline": "if (vma && (addr >= vma->vm_end))"
    },
    {
        "line": 23,
        "fullcodeline": "if (vma && (vma->vm_start <= addr) &&"
    },
    {
        "line": 19,
        "fullcodeline": "vma = find_vma(walk->mm, addr);"
    },
    {
        "line": 24,
        "fullcodeline": "!is_vm_hugetlb_page(vma)) {"
    },
    {
        "line": 25,
        "fullcodeline": "pte = pte_offset_map(pmd, addr);"
    },
    {
        "line": 26,
        "fullcodeline": "pfn = pte_to_pagemap_entry(*pte);"
    },
    {
        "line": 28,
        "fullcodeline": "pte_unmap(pte);"
    }
]