[
    {
        "line": 4,
        "fullcodeline": "struct mem_size_stats *mss = walk->private;"
    },
    {
        "line": 5,
        "fullcodeline": "struct vm_area_struct *vma = mss->vma;"
    },
    {
        "line": 9,
        "fullcodeline": "spin_lock(&walk->mm->page_table_lock);"
    },
    {
        "line": 32,
        "fullcodeline": "pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);"
    },
    {
        "line": 10,
        "fullcodeline": "if (pmd_trans_huge(*pmd)) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (pmd_trans_unstable(pmd))"
    },
    {
        "line": 33,
        "fullcodeline": "for (; addr != end; pte++, addr += PAGE_SIZE)"
    },
    {
        "line": 34,
        "fullcodeline": "smaps_pte_entry(*pte, addr, PAGE_SIZE, walk);"
    },
    {
        "line": 35,
        "fullcodeline": "pte_unmap_unlock(pte - 1, ptl);"
    },
    {
        "line": 11,
        "fullcodeline": "if (pmd_trans_splitting(*pmd)) {"
    },
    {
        "line": 13,
        "fullcodeline": "wait_split_huge_page(vma->anon_vma, pmd);"
    },
    {
        "line": 15,
        "fullcodeline": "smaps_pte_entry(*(pte_t *)pmd, addr,"
    },
    {
        "line": 17,
        "fullcodeline": "spin_unlock(&walk->mm->page_table_lock);"
    },
    {
        "line": 18,
        "fullcodeline": "mss->anonymous_thp += HPAGE_PMD_SIZE;"
    }
]