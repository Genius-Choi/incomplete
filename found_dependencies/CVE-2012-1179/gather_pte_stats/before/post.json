[
    {
        "line": 9,
        "fullcodeline": "md = walk->private;"
    },
    {
        "line": 30,
        "fullcodeline": "orig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);"
    },
    {
        "line": 38,
        "fullcodeline": "pte_unmap_unlock(orig_pte, ptl);"
    },
    {
        "line": 32,
        "fullcodeline": "struct page *page = can_gather_numa_stats(*pte, md->vma, addr);"
    },
    {
        "line": 35,
        "fullcodeline": "gather_stats(page, md, pte_dirty(*pte), 1);"
    },
    {
        "line": 37,
        "fullcodeline": "} while (pte++, addr += PAGE_SIZE, addr != end);"
    },
    {
        "line": 12,
        "fullcodeline": "if (pmd_trans_splitting(*pmd)) {"
    },
    {
        "line": 27,
        "fullcodeline": "spin_unlock(&walk->mm->page_table_lock);"
    },
    {
        "line": 33,
        "fullcodeline": "if (!page)"
    },
    {
        "line": 13,
        "fullcodeline": "spin_unlock(&walk->mm->page_table_lock);"
    },
    {
        "line": 14,
        "fullcodeline": "wait_split_huge_page(md->vma->anon_vma, pmd);"
    },
    {
        "line": 19,
        "fullcodeline": "page = can_gather_numa_stats(huge_pte, md->vma, addr);"
    },
    {
        "line": 23,
        "fullcodeline": "spin_unlock(&walk->mm->page_table_lock);"
    },
    {
        "line": 16,
        "fullcodeline": "pte_t huge_pte = *(pte_t *)pmd;"
    },
    {
        "line": 21,
        "fullcodeline": "gather_stats(page, md, pte_dirty(huge_pte),"
    },
    {
        "line": 22,
        "fullcodeline": "HPAGE_PMD_SIZE/PAGE_SIZE);"
    }
]