[
    {
        "line": 4,
        "fullcodeline": "VLOG(4) << \"generating TRAILERS for stream=\" << stream;"
    },
    {
        "line": 5,
        "fullcodeline": "std::vector<compress::Header> allHeaders;"
    },
    {
        "line": 6,
        "fullcodeline": "CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);"
    },
    {
        "line": 9,
        "fullcodeline": "auto out = encodeHeaders(trailers, allHeaders, &size);"
    },
    {
        "line": 11,
        "fullcodeline": "IOBufQueue queue(IOBufQueue::cacheChainLength());"
    },
    {
        "line": 12,
        "fullcodeline": "queue.append(std::move(out));"
    },
    {
        "line": 13,
        "fullcodeline": "auto maxFrameSize = maxSendFrameSize();"
    },
    {
        "line": 14,
        "fullcodeline": "if (queue.chainLength() > 0) {"
    },
    {
        "line": 15,
        "fullcodeline": "folly::Optional<http2::PriorityUpdate> pri;"
    },
    {
        "line": 16,
        "fullcodeline": "auto remainingFrameSize = maxFrameSize;"
    },
    {
        "line": 17,
        "fullcodeline": "auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));"
    },
    {
        "line": 18,
        "fullcodeline": "bool endHeaders = queue.chainLength() == 0;"
    },
    {
        "line": 19,
        "fullcodeline": "generateHeaderCallbackWrapper(stream,"
    },
    {
        "line": 21,
        "fullcodeline": "http2::writeHeaders(writeBuf,"
    },
    {
        "line": 29,
        "fullcodeline": "if (!endHeaders) {"
    },
    {
        "line": 22,
        "fullcodeline": "std::move(chunk),"
    },
    {
        "line": 30,
        "fullcodeline": "generateContinuation(writeBuf, queue, stream, maxFrameSize);"
    }
]