[
    {
        "line": 8,
        "fullcodeline": "srcChars += srcStart;"
    },
    {
        "line": 17,
        "fullcodeline": "int32_t oldLength = length();"
    },
    {
        "line": 25,
        "fullcodeline": "const UChar* oldArray = getArrayStart();"
    },
    {
        "line": 2,
        "fullcodeline": "if(!isWritable() || srcLength == 0 || srcChars == NULL) {"
    },
    {
        "line": 10,
        "fullcodeline": "if(srcLength < 0) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (uprv_add32_overflow(oldLength, srcLength, &newLength)) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (isBufferWritable() &&"
    },
    {
        "line": 28,
        "fullcodeline": "srcChars < oldArray + oldLength) {"
    },
    {
        "line": 30,
        "fullcodeline": "UnicodeString copy(srcChars, srcLength);"
    },
    {
        "line": 39,
        "fullcodeline": "if((newLength <= getCapacity() && isBufferWritable()) ||"
    },
    {
        "line": 40,
        "fullcodeline": "cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {"
    },
    {
        "line": 41,
        "fullcodeline": "UChar *newArray = getArrayStart();"
    },
    {
        "line": 27,
        "fullcodeline": "oldArray < srcChars + srcLength &&"
    },
    {
        "line": 31,
        "fullcodeline": "if (copy.isBogus()) {"
    },
    {
        "line": 35,
        "fullcodeline": "return doAppend(copy.getArrayStart(), 0, srcLength);"
    },
    {
        "line": 49,
        "fullcodeline": "if(srcChars != newArray + oldLength) {"
    },
    {
        "line": 12,
        "fullcodeline": "if((srcLength = u_strlen(srcChars)) == 0) {"
    }
]