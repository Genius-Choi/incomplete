[
    {
        "line": 8,
        "fullcodeline": "srcChars += srcStart;"
    },
    {
        "line": 17,
        "fullcodeline": "int32_t oldLength = length();"
    },
    {
        "line": 18,
        "fullcodeline": "int32_t newLength = oldLength + srcLength;"
    },
    {
        "line": 21,
        "fullcodeline": "const UChar* oldArray = getArrayStart();"
    },
    {
        "line": 2,
        "fullcodeline": "if(!isWritable() || srcLength == 0 || srcChars == NULL) {"
    },
    {
        "line": 10,
        "fullcodeline": "if(srcLength < 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (isBufferWritable() &&"
    },
    {
        "line": 35,
        "fullcodeline": "if((newLength <= getCapacity() && isBufferWritable()) ||"
    },
    {
        "line": 24,
        "fullcodeline": "srcChars < oldArray + oldLength) {"
    },
    {
        "line": 26,
        "fullcodeline": "UnicodeString copy(srcChars, srcLength);"
    },
    {
        "line": 36,
        "fullcodeline": "cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {"
    },
    {
        "line": 37,
        "fullcodeline": "UChar *newArray = getArrayStart();"
    },
    {
        "line": 48,
        "fullcodeline": "setLength(newLength);"
    },
    {
        "line": 12,
        "fullcodeline": "if((srcLength = u_strlen(srcChars)) == 0) {"
    },
    {
        "line": 23,
        "fullcodeline": "oldArray < srcChars + srcLength &&"
    },
    {
        "line": 27,
        "fullcodeline": "if (copy.isBogus()) {"
    },
    {
        "line": 31,
        "fullcodeline": "return doAppend(copy.getArrayStart(), 0, srcLength);"
    },
    {
        "line": 45,
        "fullcodeline": "if(srcChars != newArray + oldLength) {"
    },
    {
        "line": 28,
        "fullcodeline": "setToBogus();"
    },
    {
        "line": 46,
        "fullcodeline": "us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);"
    }
]