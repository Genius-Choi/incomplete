[
    {
        "line": 3,
        "fullcodeline": "bool blockEnd = false;"
    },
    {
        "line": 7,
        "fullcodeline": "CRYPTOPP_ASSERT(m_reader.BitsBuffered() == 0);"
    },
    {
        "line": 24,
        "fullcodeline": "static const unsigned int lengthStarts[] = {"
    },
    {
        "line": 27,
        "fullcodeline": "static const unsigned int lengthExtraBits[] = {"
    },
    {
        "line": 30,
        "fullcodeline": "static const unsigned int distanceStarts[] = {"
    },
    {
        "line": 34,
        "fullcodeline": "static const unsigned int distanceExtraBits[] = {"
    },
    {
        "line": 39,
        "fullcodeline": "const HuffmanDecoder& literalDecoder = GetLiteralDecoder();"
    },
    {
        "line": 40,
        "fullcodeline": "const HuffmanDecoder& distanceDecoder = GetDistanceDecoder();"
    },
    {
        "line": 8,
        "fullcodeline": "while (!m_inQueue.IsEmpty() && !blockEnd)"
    },
    {
        "line": 11,
        "fullcodeline": "const byte *block = m_inQueue.Spy(size);"
    },
    {
        "line": 12,
        "fullcodeline": "size = UnsignedMin(m_storedLen, size);"
    },
    {
        "line": 13,
        "fullcodeline": "CRYPTOPP_ASSERT(size <= 0xffff);"
    },
    {
        "line": 15,
        "fullcodeline": "OutputString(block, size);"
    },
    {
        "line": 16,
        "fullcodeline": "m_inQueue.Skip(size);"
    },
    {
        "line": 17,
        "fullcodeline": "m_storedLen = m_storedLen - (word16)size;"
    },
    {
        "line": 99,
        "fullcodeline": "CRYPTOPP_ASSERT(0);"
    },
    {
        "line": 106,
        "fullcodeline": "FlushOutput();"
    },
    {
        "line": 107,
        "fullcodeline": "m_reader.SkipBits(m_reader.BitsBuffered()%8);"
    },
    {
        "line": 116,
        "fullcodeline": "m_state = POST_STREAM;"
    },
    {
        "line": 18,
        "fullcodeline": "if (m_storedLen == 0)"
    },
    {
        "line": 108,
        "fullcodeline": "if (m_reader.BitsBuffered())"
    },
    {
        "line": 119,
        "fullcodeline": "m_state = WAIT_HEADER;"
    },
    {
        "line": 19,
        "fullcodeline": "blockEnd = true;"
    },
    {
        "line": 111,
        "fullcodeline": "SecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);"
    },
    {
        "line": 114,
        "fullcodeline": "m_inQueue.Unget(buffer, buffer.size());"
    },
    {
        "line": 47,
        "fullcodeline": "if (!literalDecoder.Decode(m_reader, m_literal))"
    },
    {
        "line": 52,
        "fullcodeline": "if (m_literal < 256)"
    },
    {
        "line": 112,
        "fullcodeline": "for (unsigned int i=0; i<buffer.size(); i++)"
    },
    {
        "line": 113,
        "fullcodeline": "buffer[i] = (byte)m_reader.GetBits(8);"
    },
    {
        "line": 49,
        "fullcodeline": "m_nextDecode = LITERAL;"
    },
    {
        "line": 53,
        "fullcodeline": "OutputByte((byte)m_literal);"
    },
    {
        "line": 54,
        "fullcodeline": "else if (m_literal == 256)\t// end of block"
    },
    {
        "line": 56,
        "fullcodeline": "blockEnd = true;"
    },
    {
        "line": 65,
        "fullcodeline": "bits = lengthExtraBits[m_literal-257];"
    },
    {
        "line": 71,
        "fullcodeline": "m_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];"
    },
    {
        "line": 80,
        "fullcodeline": "CRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits));"
    },
    {
        "line": 83,
        "fullcodeline": "bits = distanceExtraBits[m_distance];"
    },
    {
        "line": 90,
        "fullcodeline": "CRYPTOPP_ASSERT(m_distance < COUNTOF(distanceStarts));"
    },
    {
        "line": 93,
        "fullcodeline": "m_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];"
    },
    {
        "line": 94,
        "fullcodeline": "OutputPast(m_literal, m_distance);"
    },
    {
        "line": 61,
        "fullcodeline": "if (m_literal > 285)"
    },
    {
        "line": 66,
        "fullcodeline": "if (!m_reader.FillBuffer(bits))"
    },
    {
        "line": 73,
        "fullcodeline": "if (!distanceDecoder.Decode(m_reader, m_distance))"
    },
    {
        "line": 81,
        "fullcodeline": "if (m_distance >= COUNTOF(distanceExtraBits))"
    },
    {
        "line": 84,
        "fullcodeline": "if (!m_reader.FillBuffer(bits))"
    },
    {
        "line": 91,
        "fullcodeline": "if (m_distance >= COUNTOF(distanceStarts))"
    },
    {
        "line": 68,
        "fullcodeline": "m_nextDecode = LENGTH_BITS;"
    },
    {
        "line": 75,
        "fullcodeline": "m_nextDecode = DISTANCE;"
    },
    {
        "line": 86,
        "fullcodeline": "m_nextDecode = DISTANCE_BITS;"
    },
    {
        "line": 62,
        "fullcodeline": "throw BadBlockErr();"
    },
    {
        "line": 82,
        "fullcodeline": "throw BadDistanceErr();"
    },
    {
        "line": 92,
        "fullcodeline": "throw BadDistanceErr();"
    }
]