[
    {
        "line": 4,
        "fullcodeline": "struct usb_8dev_priv *priv = netdev_priv(netdev);"
    },
    {
        "line": 5,
        "fullcodeline": "struct net_device_stats *stats = &netdev->stats;"
    },
    {
        "line": 6,
        "fullcodeline": "struct can_frame *cf = (struct can_frame *) skb->data;"
    },
    {
        "line": 9,
        "fullcodeline": "struct usb_8dev_tx_urb_context *context = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "urb = usb_alloc_urb(0, GFP_ATOMIC);"
    },
    {
        "line": 22,
        "fullcodeline": "buf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,"
    },
    {
        "line": 29,
        "fullcodeline": "memset(buf, 0, size);"
    },
    {
        "line": 31,
        "fullcodeline": "msg = (struct usb_8dev_tx_msg *)buf;"
    },
    {
        "line": 32,
        "fullcodeline": "msg->begin = USB_8DEV_DATA_START;"
    },
    {
        "line": 33,
        "fullcodeline": "msg->flags = 0x00;"
    },
    {
        "line": 41,
        "fullcodeline": "msg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);"
    },
    {
        "line": 42,
        "fullcodeline": "msg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);"
    },
    {
        "line": 43,
        "fullcodeline": "memcpy(msg->data, cf->data, cf->len);"
    },
    {
        "line": 44,
        "fullcodeline": "msg->end = USB_8DEV_DATA_END;"
    },
    {
        "line": 59,
        "fullcodeline": "context->priv = priv;"
    },
    {
        "line": 60,
        "fullcodeline": "context->echo_index = i;"
    },
    {
        "line": 62,
        "fullcodeline": "usb_fill_bulk_urb(urb, priv->udev,"
    },
    {
        "line": 65,
        "fullcodeline": "urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;"
    },
    {
        "line": 66,
        "fullcodeline": "usb_anchor_urb(urb, &priv->tx_submitted);"
    },
    {
        "line": 68,
        "fullcodeline": "can_put_echo_skb(skb, netdev, context->echo_index, 0);"
    },
    {
        "line": 70,
        "fullcodeline": "atomic_inc(&priv->active_tx_urbs);"
    },
    {
        "line": 72,
        "fullcodeline": "err = usb_submit_urb(urb, GFP_ATOMIC);"
    },
    {
        "line": 82,
        "fullcodeline": "usb_free_urb(urb);"
    },
    {
        "line": 87,
        "fullcodeline": "usb_free_coherent(priv->udev, size, buf, urb->transfer_dma);"
    },
    {
        "line": 88,
        "fullcodeline": "usb_free_urb(urb);"
    },
    {
        "line": 90,
        "fullcodeline": "netdev_warn(netdev, \"couldn't find free context\");"
    },
    {
        "line": 95,
        "fullcodeline": "can_free_echo_skb(netdev, context->echo_index, NULL);"
    },
    {
        "line": 97,
        "fullcodeline": "usb_unanchor_urb(urb);"
    },
    {
        "line": 98,
        "fullcodeline": "usb_free_coherent(priv->udev, size, buf, urb->transfer_dma);"
    },
    {
        "line": 100,
        "fullcodeline": "atomic_dec(&priv->active_tx_urbs);"
    },
    {
        "line": 108,
        "fullcodeline": "usb_free_urb(urb);"
    },
    {
        "line": 111,
        "fullcodeline": "dev_kfree_skb(skb);"
    },
    {
        "line": 112,
        "fullcodeline": "stats->tx_dropped++;"
    },
    {
        "line": 14,
        "fullcodeline": "if (can_dropped_invalid_skb(netdev, skb))"
    },
    {
        "line": 19,
        "fullcodeline": "if (!urb)"
    },
    {
        "line": 24,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (cf->can_id & CAN_RTR_FLAG)"
    },
    {
        "line": 38,
        "fullcodeline": "if (cf->can_id & CAN_EFF_FLAG)"
    },
    {
        "line": 46,
        "fullcodeline": "for (i = 0; i < MAX_TX_URBS; i++) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (!context)"
    },
    {
        "line": 63,
        "fullcodeline": "usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),"
    },
    {
        "line": 73,
        "fullcodeline": "if (unlikely(err))"
    },
    {
        "line": 102,
        "fullcodeline": "if (err == -ENODEV)"
    },
    {
        "line": 25,
        "fullcodeline": "netdev_err(netdev, \"No memory left for USB buffer\\n\");"
    },
    {
        "line": 36,
        "fullcodeline": "msg->flags |= USB_8DEV_RTR;"
    },
    {
        "line": 39,
        "fullcodeline": "msg->flags |= USB_8DEV_EXTID;"
    },
    {
        "line": 103,
        "fullcodeline": "netif_device_detach(netdev);"
    },
    {
        "line": 47,
        "fullcodeline": "if (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {"
    },
    {
        "line": 105,
        "fullcodeline": "netdev_warn(netdev, \"failed tx_urb %d\\n\", err);"
    },
    {
        "line": 48,
        "fullcodeline": "context = &priv->tx_contexts[i];"
    },
    {
        "line": 75,
        "fullcodeline": "else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)"
    },
    {
        "line": 77,
        "fullcodeline": "netif_stop_queue(netdev);"
    }
]