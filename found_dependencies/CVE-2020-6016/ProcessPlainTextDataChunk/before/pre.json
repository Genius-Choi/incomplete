[
    {
        "line": 69,
        "fullcodeline": "const SteamNetworkingMicroseconds usecNow = ctx.m_usecNow;"
    },
    {
        "line": 70,
        "fullcodeline": "const int64 nPktNum = ctx.m_nPktNum;"
    },
    {
        "line": 71,
        "fullcodeline": "bool bInhibitMarkReceived = false;"
    },
    {
        "line": 73,
        "fullcodeline": "const int nLogLevelPacketDecode = m_connectionConfig.m_LogLevel_PacketDecode.Get();"
    },
    {
        "line": 74,
        "fullcodeline": "SpewVerboseGroup( nLogLevelPacketDecode, \"[%s] decode pkt %lld\\n\", GetDescription(), (long long)nPktNum );"
    },
    {
        "line": 77,
        "fullcodeline": "const byte *pDecode = (const byte *)ctx.m_pPlainText;"
    },
    {
        "line": 78,
        "fullcodeline": "const byte *pEnd = pDecode + ctx.m_cbPlainText;"
    },
    {
        "line": 79,
        "fullcodeline": "int64 nCurMsgNum = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "int64 nDecodeReliablePos = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "while ( pDecode < pEnd )"
    },
    {
        "line": 84,
        "fullcodeline": "uint8 nFrameType = *pDecode;"
    },
    {
        "line": 85,
        "fullcodeline": "++pDecode;"
    },
    {
        "line": 86,
        "fullcodeline": "if ( ( nFrameType & 0xc0 ) == 0x00 )"
    },
    {
        "line": 642,
        "fullcodeline": "bool bScheduleAck = nDecodeReliablePos > 0;"
    },
    {
        "line": 643,
        "fullcodeline": "SNP_RecordReceivedPktNum( nPktNum, usecNow, bScheduleAck );"
    },
    {
        "line": 145,
        "fullcodeline": "uint32 nOffset = 0;"
    },
    {
        "line": 152,
        "fullcodeline": "READ_SEGMENT_DATA_SIZE( unreliable )"
    },
    {
        "line": 153,
        "fullcodeline": "Assert( cbSegmentSize > 0 ); // !TEST! Bogus assert, zero byte messages are OK.  Remove after testing"
    },
    {
        "line": 156,
        "fullcodeline": "bool bLastSegmentInMessage = ( nFrameType & 0x20 ) != 0;"
    },
    {
        "line": 157,
        "fullcodeline": "SNP_ReceiveUnreliableSegment( nCurMsgNum, nOffset, pSegmentData, cbSegmentSize, bLastSegmentInMessage, usecNow );"
    },
    {
        "line": 94,
        "fullcodeline": "if ( nCurMsgNum == 0 )"
    },
    {
        "line": 139,
        "fullcodeline": "if ( nCurMsgNum > m_receiverState.m_nHighestSeenMsgNum )"
    },
    {
        "line": 146,
        "fullcodeline": "if ( nFrameType & 0x08 )"
    },
    {
        "line": 97,
        "fullcodeline": "static const char szUnreliableMsgNumOffset[] = \"unreliable msgnum\";"
    },
    {
        "line": 111,
        "fullcodeline": "Assert( ( nCurMsgNum & nMask ) == nLowerBits );"
    },
    {
        "line": 140,
        "fullcodeline": "m_receiverState.m_nHighestSeenMsgNum = nCurMsgNum;"
    },
    {
        "line": 147,
        "fullcodeline": "READ_VARINT( nOffset, \"unreliable data offset\" );"
    },
    {
        "line": 159,
        "fullcodeline": "else if ( ( nFrameType & 0xe0 ) == 0x40 )"
    },
    {
        "line": 99,
        "fullcodeline": "if ( nFrameType & 0x10 )"
    },
    {
        "line": 113,
        "fullcodeline": "if ( nCurMsgNum <= 0 )"
    },
    {
        "line": 118,
        "fullcodeline": "if ( std::abs( nCurMsgNum - m_receiverState.m_nHighestSeenMsgNum ) > (nMask>>2) )"
    },
    {
        "line": 223,
        "fullcodeline": "READ_SEGMENT_DATA_SIZE( reliable )"
    },
    {
        "line": 238,
        "fullcodeline": "nDecodeReliablePos += cbSegmentSize;"
    },
    {
        "line": 101,
        "fullcodeline": "READ_32BITU( nLowerBits, szUnreliableMsgNumOffset );"
    },
    {
        "line": 102,
        "fullcodeline": "nMask = 0xffffffff;"
    },
    {
        "line": 103,
        "fullcodeline": "nCurMsgNum = NearestWithSameLowerBits( (int32)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );"
    },
    {
        "line": 115,
        "fullcodeline": "DECODE_ERROR( \"SNP decode unreliable msgnum underflow.  %llx mod %llx, highest seen %llx\","
    },
    {
        "line": 121,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"Sender sent abs unreliable message number using %llx mod %llx, highest seen %llx\\n\","
    },
    {
        "line": 128,
        "fullcodeline": "if ( nFrameType & 0x10 )"
    },
    {
        "line": 167,
        "fullcodeline": "if ( nDecodeReliablePos == 0 )"
    },
    {
        "line": 226,
        "fullcodeline": "if ( !SNP_ReceiveReliableSegment( nPktNum, nDecodeReliablePos, pSegmentData, cbSegmentSize, usecNow ) )"
    },
    {
        "line": 242,
        "fullcodeline": "if ( nCurMsgNum > 0 )"
    },
    {
        "line": 107,
        "fullcodeline": "READ_16BITU( nLowerBits, szUnreliableMsgNumOffset );"
    },
    {
        "line": 108,
        "fullcodeline": "nMask = 0xffff;"
    },
    {
        "line": 109,
        "fullcodeline": "nCurMsgNum = NearestWithSameLowerBits( (int16)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );"
    },
    {
        "line": 122,
        "fullcodeline": "(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_receiverState.m_nHighestSeenMsgNum );"
    },
    {
        "line": 131,
        "fullcodeline": "READ_VARINT( nMsgNumOffset, \"unreliable msgnum offset\" );"
    },
    {
        "line": 132,
        "fullcodeline": "nCurMsgNum += nMsgNumOffset;"
    },
    {
        "line": 171,
        "fullcodeline": "static const char szFirstReliableStreamPos[] = \"first reliable streampos\";"
    },
    {
        "line": 182,
        "fullcodeline": "int64 nExpectNextStreamPos = m_receiverState.m_nReliableStreamPos + len( m_receiverState.m_bufReliableStream );"
    },
    {
        "line": 185,
        "fullcodeline": "nDecodeReliablePos = ( nExpectNextStreamPos & ~nMask ) + nOffset;"
    },
    {
        "line": 234,
        "fullcodeline": "bInhibitMarkReceived = true;"
    },
    {
        "line": 243,
        "fullcodeline": "++nCurMsgNum;"
    },
    {
        "line": 245,
        "fullcodeline": "else if ( ( nFrameType & 0xfc ) == 0x80 )"
    },
    {
        "line": 136,
        "fullcodeline": "++nCurMsgNum;"
    },
    {
        "line": 173,
        "fullcodeline": "switch ( nFrameType & (3<<3) )"
    },
    {
        "line": 186,
        "fullcodeline": "if ( nDecodeReliablePos + (nMask>>1) < nExpectNextStreamPos )"
    },
    {
        "line": 193,
        "fullcodeline": "if ( nDecodeReliablePos <= 0 )"
    },
    {
        "line": 198,
        "fullcodeline": "if ( std::abs( nDecodeReliablePos - nExpectNextStreamPos ) > (nMask>>2) )"
    },
    {
        "line": 208,
        "fullcodeline": "static const char szOtherReliableStreamPos[] = \"reliable streampos offset\";"
    },
    {
        "line": 217,
        "fullcodeline": "nDecodeReliablePos += nOffset;"
    },
    {
        "line": 228,
        "fullcodeline": "if ( !BStateIsActive() )"
    },
    {
        "line": 251,
        "fullcodeline": "int64 nOffset = 0;"
    },
    {
        "line": 252,
        "fullcodeline": "static const char szStopWaitingOffset[] = \"stop_waiting offset\";"
    },
    {
        "line": 264,
        "fullcodeline": "++nOffset;"
    },
    {
        "line": 265,
        "fullcodeline": "int64 nMinPktNumToSendAcks = nPktNum-nOffset;"
    },
    {
        "line": 282,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld stop waiting: %lld (was %lld)\","
    },
    {
        "line": 286,
        "fullcodeline": "m_receiverState.m_nMinPktNumToSendAcks = nMinPktNumToSendAcks;"
    },
    {
        "line": 287,
        "fullcodeline": "m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks = nPktNum;"
    },
    {
        "line": 291,
        "fullcodeline": "auto h = m_receiverState.m_mapPacketGaps.begin();"
    },
    {
        "line": 175,
        "fullcodeline": "case 0<<3: READ_24BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<24)-1; break;"
    },
    {
        "line": 176,
        "fullcodeline": "case 1<<3: READ_32BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<32)-1; break;"
    },
    {
        "line": 177,
        "fullcodeline": "case 2<<3: READ_48BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<48)-1; break;"
    },
    {
        "line": 178,
        "fullcodeline": "default: DECODE_ERROR( \"Reserved reliable stream pos size\" );"
    },
    {
        "line": 188,
        "fullcodeline": "nDecodeReliablePos += nMask+1;"
    },
    {
        "line": 189,
        "fullcodeline": "Assert( ( nDecodeReliablePos & nMask ) == nOffset );"
    },
    {
        "line": 190,
        "fullcodeline": "Assert( nExpectNextStreamPos < nDecodeReliablePos );"
    },
    {
        "line": 191,
        "fullcodeline": "Assert( nExpectNextStreamPos + (nMask>>1) >= nDecodeReliablePos );"
    },
    {
        "line": 195,
        "fullcodeline": "DECODE_ERROR( \"SNP decode first reliable stream pos underflow.  %llx mod %llx, expected next %llx\","
    },
    {
        "line": 201,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"Sender sent reliable stream pos using %llx mod %llx, expected next %llx\\n\","
    },
    {
        "line": 210,
        "fullcodeline": "switch ( nFrameType & (3<<3) )"
    },
    {
        "line": 253,
        "fullcodeline": "switch ( nFrameType & 3 )"
    },
    {
        "line": 260,
        "fullcodeline": "if ( nOffset >= nPktNum )"
    },
    {
        "line": 266,
        "fullcodeline": "if ( nMinPktNumToSendAcks == m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 268,
        "fullcodeline": "if ( nMinPktNumToSendAcks < m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 292,
        "fullcodeline": "while ( h->first <= m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 202,
        "fullcodeline": "(unsigned long long)nOffset, (unsigned long long)( nMask+1 ), (unsigned long long)nExpectNextStreamPos );"
    },
    {
        "line": 212,
        "fullcodeline": "case 0<<3: nOffset = 0; break;"
    },
    {
        "line": 213,
        "fullcodeline": "case 1<<3: READ_8BITU( nOffset, szOtherReliableStreamPos ); break;"
    },
    {
        "line": 214,
        "fullcodeline": "case 2<<3: READ_16BITU( nOffset, szOtherReliableStreamPos ); break;"
    },
    {
        "line": 215,
        "fullcodeline": "default: READ_32BITU( nOffset, szOtherReliableStreamPos ); break;"
    },
    {
        "line": 255,
        "fullcodeline": "case 0: READ_8BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 256,
        "fullcodeline": "case 1: READ_16BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 257,
        "fullcodeline": "case 2: READ_24BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 258,
        "fullcodeline": "case 3: READ_64BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 262,
        "fullcodeline": "DECODE_ERROR( \"stop_waiting pktNum %llu offset %llu\", nPktNum, nOffset );"
    },
    {
        "line": 318,
        "fullcodeline": "h = m_receiverState.m_mapPacketGaps.erase(h);"
    },
    {
        "line": 321,
        "fullcodeline": "else if ( ( nFrameType & 0xf0 ) == 0x90 )"
    },
    {
        "line": 271,
        "fullcodeline": "if ( nPktNum >= m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks )"
    },
    {
        "line": 294,
        "fullcodeline": "if ( h->second.m_nEnd > m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 304,
        "fullcodeline": "if ( m_receiverState.m_itPendingAck == h )"
    },
    {
        "line": 308,
        "fullcodeline": "if ( m_receiverState.m_itPendingNack == h )"
    },
    {
        "line": 378,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld latest recv %lld\\n\","
    },
    {
        "line": 385,
        "fullcodeline": "Assert( !m_senderState.m_mapInFlightPacketsByPktNum.empty() );"
    },
    {
        "line": 386,
        "fullcodeline": "auto inFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.upper_bound( nLatestRecvSeqNum );"
    },
    {
        "line": 387,
        "fullcodeline": "--inFlightPkt;"
    },
    {
        "line": 388,
        "fullcodeline": "Assert( inFlightPkt->first <= nLatestRecvSeqNum );"
    },
    {
        "line": 443,
        "fullcodeline": "int nBlocks = nFrameType&7;"
    },
    {
        "line": 465,
        "fullcodeline": "bool bAckedReliableRange = false;"
    },
    {
        "line": 466,
        "fullcodeline": "int64 nPktNumAckEnd = nLatestRecvSeqNum+1;"
    },
    {
        "line": 273,
        "fullcodeline": "DECODE_ERROR( \"SNP stop waiting reduced %lld (pkt %lld) -> %lld (pkt %lld)\","
    },
    {
        "line": 299,
        "fullcodeline": "const_cast<int64 &>( h->first ) = m_receiverState.m_nMinPktNumToSendAcks;"
    },
    {
        "line": 305,
        "fullcodeline": "++m_receiverState.m_itPendingAck;"
    },
    {
        "line": 311,
        "fullcodeline": "AssertMsg( false, \"Expiring packet gap, which had pending NACK\" );"
    },
    {
        "line": 314,
        "fullcodeline": "++m_receiverState.m_itPendingNack;"
    },
    {
        "line": 341,
        "fullcodeline": "static const char szAckLatestPktNum[] = \"ack latest pktnum\";"
    },
    {
        "line": 355,
        "fullcodeline": "Assert( ( nLatestRecvSeqNum & nMask ) == nLowerBits );"
    },
    {
        "line": 380,
        "fullcodeline": "(long long)nPktNum, (long long)nLatestRecvSeqNum"
    },
    {
        "line": 393,
        "fullcodeline": "READ_16BITU( nPackedDelay, \"ack delay\" );"
    },
    {
        "line": 444,
        "fullcodeline": "if ( nBlocks == 7 )"
    },
    {
        "line": 450,
        "fullcodeline": "if ( nBlocks > 0 )"
    },
    {
        "line": 467,
        "fullcodeline": "while ( nBlocks >= 0 )"
    },
    {
        "line": 612,
        "fullcodeline": "if ( nLatestRecvSeqNum > m_senderState.m_nMinPktWaitingOnAck )"
    },
    {
        "line": 622,
        "fullcodeline": "DECODE_ERROR( \"Invalid SNP frame lead byte 0x%02x\", nFrameType );"
    },
    {
        "line": 343,
        "fullcodeline": "if ( nFrameType & 0x40 )"
    },
    {
        "line": 358,
        "fullcodeline": "if ( nLatestRecvSeqNum < 0 )"
    },
    {
        "line": 363,
        "fullcodeline": "if ( std::abs( nLatestRecvSeqNum - m_statsEndToEnd.m_nNextSendSequenceNumber ) > (nMask>>2) )"
    },
    {
        "line": 369,
        "fullcodeline": "if ( nLatestRecvSeqNum >= m_statsEndToEnd.m_nNextSendSequenceNumber )"
    },
    {
        "line": 394,
        "fullcodeline": "if ( nPackedDelay != 0xffff && inFlightPkt->first == nLatestRecvSeqNum && inFlightPkt->second.m_pTransport == ctx.m_pTransport )"
    },
    {
        "line": 445,
        "fullcodeline": "READ_8BITU( nBlocks, \"ack num blocks\" );"
    },
    {
        "line": 457,
        "fullcodeline": "SteamNetworkingMicroseconds usecDelay = 250*1000 / nBlocks;"
    },
    {
        "line": 458,
        "fullcodeline": "QueueFlushAllAcks( usecNow + usecDelay );"
    },
    {
        "line": 528,
        "fullcodeline": "Assert( nPktNumAckBegin >= 0 );"
    },
    {
        "line": 574,
        "fullcodeline": "Assert( nPktNumNackBegin >= 0 );"
    },
    {
        "line": 585,
        "fullcodeline": "nPktNumAckEnd = nPktNumNackBegin;"
    },
    {
        "line": 586,
        "fullcodeline": "--nBlocks;"
    },
    {
        "line": 593,
        "fullcodeline": "m_senderState.RemoveAckedReliableMessageFromUnackedList();"
    },
    {
        "line": 614,
        "fullcodeline": "SpewVerboseGroup( nLogLevelPacketDecode, \"[%s]   updating min_waiting_on_ack %lld -> %lld\\n\","
    },
    {
        "line": 617,
        "fullcodeline": "m_senderState.m_nMinPktWaitingOnAck = nLatestRecvSeqNum;"
    },
    {
        "line": 345,
        "fullcodeline": "READ_32BITU( nLowerBits, szAckLatestPktNum );"
    },
    {
        "line": 346,
        "fullcodeline": "nMask = 0xffffffff;"
    },
    {
        "line": 347,
        "fullcodeline": "nLatestRecvSeqNum = NearestWithSameLowerBits( (int32)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );"
    },
    {
        "line": 360,
        "fullcodeline": "DECODE_ERROR( \"SNP decode ack latest pktnum underflow.  %llx mod %llx, next send %llx\","
    },
    {
        "line": 366,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"Sender sent abs latest recv pkt number using %llx mod %llx, next send %llx\\n\","
    },
    {
        "line": 371,
        "fullcodeline": "DECODE_ERROR( \"SNP decode ack latest pktnum %lld (%llx mod %llx), but next outoing packet is %lld (%llx).\","
    },
    {
        "line": 396,
        "fullcodeline": "SteamNetworkingMicroseconds usecDelay = SteamNetworkingMicroseconds( nPackedDelay ) << k_nAckDelayPrecisionShift;"
    },
    {
        "line": 397,
        "fullcodeline": "SteamNetworkingMicroseconds usecElapsed = usecNow - inFlightPkt->second.m_usecWhenSent;"
    },
    {
        "line": 398,
        "fullcodeline": "Assert( usecElapsed >= 0 );"
    },
    {
        "line": 401,
        "fullcodeline": "int msPing = ( usecElapsed - usecDelay ) / 1000;"
    },
    {
        "line": 473,
        "fullcodeline": "if ( nBlocks == 0 )"
    },
    {
        "line": 529,
        "fullcodeline": "while ( inFlightPkt->first >= nPktNumAckBegin )"
    },
    {
        "line": 570,
        "fullcodeline": "if ( nPktNumAckBegin <= m_statsEndToEnd.m_pktNumInFlight && m_statsEndToEnd.m_pktNumInFlight < nPktNumAckEnd )"
    },
    {
        "line": 575,
        "fullcodeline": "while ( inFlightPkt->first >= nPktNumNackBegin )"
    },
    {
        "line": 596,
        "fullcodeline": "if ( nLogLevelPacketDecode >= k_ESteamNetworkingSocketsDebugOutputType_Debug )"
    },
    {
        "line": 351,
        "fullcodeline": "READ_16BITU( nLowerBits, szAckLatestPktNum );"
    },
    {
        "line": 352,
        "fullcodeline": "nMask = 0xffff;"
    },
    {
        "line": 353,
        "fullcodeline": "nLatestRecvSeqNum = NearestWithSameLowerBits( (int16)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );"
    },
    {
        "line": 367,
        "fullcodeline": "(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber );"
    },
    {
        "line": 411,
        "fullcodeline": "if ( msPing < -1 || msPing > 2000 )"
    },
    {
        "line": 480,
        "fullcodeline": "nPktNumAckBegin = m_senderState.m_nMinPktWaitingOnAck;"
    },
    {
        "line": 481,
        "fullcodeline": "nPktNumNackBegin = nPktNumAckBegin;"
    },
    {
        "line": 482,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld ack last block ack begin %lld\\n\","
    },
    {
        "line": 531,
        "fullcodeline": "Assert( inFlightPkt->first < nPktNumAckEnd );"
    },
    {
        "line": 564,
        "fullcodeline": "inFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.erase( inFlightPkt );"
    },
    {
        "line": 565,
        "fullcodeline": "--inFlightPkt;"
    },
    {
        "line": 566,
        "fullcodeline": "m_senderState.MaybeCheckInFlightPacketMap();"
    },
    {
        "line": 571,
        "fullcodeline": "m_statsEndToEnd.InFlightPktAck( usecNow );"
    },
    {
        "line": 577,
        "fullcodeline": "Assert( inFlightPkt->first < nPktNumAckEnd );"
    },
    {
        "line": 578,
        "fullcodeline": "SNP_SenderProcessPacketNack( inFlightPkt->first, inFlightPkt->second, \"NACK\" );"
    },
    {
        "line": 581,
        "fullcodeline": "--inFlightPkt;"
    },
    {
        "line": 599,
        "fullcodeline": "int64 nPeerReliablePos = m_senderState.m_nReliableStreamPos;"
    },
    {
        "line": 605,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld peer reliable pos = %lld\\n\","
    },
    {
        "line": 416,
        "fullcodeline": "SpewMsgGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %lluusec INVALID ping %lldusec\\n\","
    },
    {
        "line": 477,
        "fullcodeline": "if ( nPktNumAckEnd <= m_senderState.m_nMinPktWaitingOnAck )"
    },
    {
        "line": 484,
        "fullcodeline": "(long long)nPktNum, (long long)nPktNumAckBegin );"
    },
    {
        "line": 489,
        "fullcodeline": "READ_8BITU( nBlockHeader, \"ack block header\" );"
    },
    {
        "line": 492,
        "fullcodeline": "int64 numAcks = ( nBlockHeader>> 4 ) & 7;"
    },
    {
        "line": 501,
        "fullcodeline": "nPktNumAckBegin = nPktNumAckEnd - numAcks;"
    },
    {
        "line": 506,
        "fullcodeline": "int64 numNacks = nBlockHeader & 7;"
    },
    {
        "line": 515,
        "fullcodeline": "nPktNumNackBegin = nPktNumAckBegin - numNacks;"
    },
    {
        "line": 519,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld nack [%lld,%lld) ack [%lld,%lld)\\n\","
    },
    {
        "line": 560,
        "fullcodeline": "if ( inFlightPkt == m_senderState.m_itNextInFlightPacketToTimeout )"
    },
    {
        "line": 600,
        "fullcodeline": "if ( !m_senderState.m_listInFlightReliableRange.empty() )"
    },
    {
        "line": 602,
        "fullcodeline": "if ( !m_senderState.m_listReadyRetryReliableRange.empty() )"
    },
    {
        "line": 607,
        "fullcodeline": "(long long)nPktNum, (long long)nPeerReliablePos );"
    },
    {
        "line": 418,
        "fullcodeline": "(long long)nPktNum, (long long)nLatestRecvSeqNum,"
    },
    {
        "line": 419,
        "fullcodeline": "(unsigned long long)usecDelay,"
    },
    {
        "line": 420,
        "fullcodeline": "(long long)usecElapsed"
    },
    {
        "line": 428,
        "fullcodeline": "ProcessSNPPing( msPing, ctx );"
    },
    {
        "line": 431,
        "fullcodeline": "SpewVerboseGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %.1fms elapsed %.1fms ping %dms\\n\","
    },
    {
        "line": 493,
        "fullcodeline": "if ( nBlockHeader & 0x80 )"
    },
    {
        "line": 502,
        "fullcodeline": "if ( nPktNumAckBegin < 0 )"
    },
    {
        "line": 507,
        "fullcodeline": "if ( nBlockHeader & 0x08)"
    },
    {
        "line": 516,
        "fullcodeline": "if ( nPktNumNackBegin < 0 )"
    },
    {
        "line": 521,
        "fullcodeline": "(long long)nPktNum,"
    },
    {
        "line": 522,
        "fullcodeline": "(long long)nPktNumNackBegin, (long long)( nPktNumNackBegin + numNacks ),"
    },
    {
        "line": 523,
        "fullcodeline": "(long long)nPktNumAckBegin, (long long)( nPktNumAckBegin + numAcks )"
    },
    {
        "line": 561,
        "fullcodeline": "++m_senderState.m_itNextInFlightPacketToTimeout;"
    },
    {
        "line": 601,
        "fullcodeline": "nPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listInFlightReliableRange.begin()->first.m_nBegin );"
    },
    {
        "line": 603,
        "fullcodeline": "nPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listReadyRetryReliableRange.begin()->first.m_nBegin );"
    },
    {
        "line": 426,
        "fullcodeline": "if ( msPing < 0 )"
    },
    {
        "line": 433,
        "fullcodeline": "(long long)nPktNum, (long long)nLatestRecvSeqNum,"
    },
    {
        "line": 434,
        "fullcodeline": "(float)(usecDelay * 1e-3 ),"
    },
    {
        "line": 435,
        "fullcodeline": "(float)(usecElapsed * 1e-3 ),"
    },
    {
        "line": 496,
        "fullcodeline": "READ_VARINT( nUpperBits, \"ack count upper bits\" );"
    },
    {
        "line": 499,
        "fullcodeline": "numAcks |= nUpperBits<<3;"
    },
    {
        "line": 503,
        "fullcodeline": "DECODE_ERROR( \"Ack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckEnd, (long long)numAcks );"
    },
    {
        "line": 510,
        "fullcodeline": "READ_VARINT( nUpperBits, \"nack count upper bits\" );"
    },
    {
        "line": 513,
        "fullcodeline": "numNacks |= nUpperBits<<3;"
    },
    {
        "line": 517,
        "fullcodeline": "DECODE_ERROR( \"Nack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckBegin, (long long)numAcks );"
    },
    {
        "line": 538,
        "fullcodeline": "if ( m_senderState.m_listInFlightReliableRange.erase( relRange ) == 0 )"
    },
    {
        "line": 427,
        "fullcodeline": "msPing = 0;"
    },
    {
        "line": 497,
        "fullcodeline": "if ( nUpperBits > 100000 )"
    },
    {
        "line": 511,
        "fullcodeline": "if ( nUpperBits > 100000 )"
    },
    {
        "line": 498,
        "fullcodeline": "DECODE_ERROR( \"Ack count of %llu<<3 is crazy\", (unsigned long long)nUpperBits );"
    },
    {
        "line": 512,
        "fullcodeline": "DECODE_ERROR( \"Nack count of %llu<<3 is crazy\", nUpperBits );"
    },
    {
        "line": 540,
        "fullcodeline": "if ( m_senderState.m_listReadyRetryReliableRange.erase( relRange ) > 0 )"
    },
    {
        "line": 553,
        "fullcodeline": "bAckedReliableRange = true;"
    },
    {
        "line": 554,
        "fullcodeline": "Assert( m_senderState.m_listReadyRetryReliableRange.count( relRange ) == 0 );"
    },
    {
        "line": 545,
        "fullcodeline": "m_senderState.m_cbPendingReliable -= int( relRange.length() );"
    },
    {
        "line": 546,
        "fullcodeline": "Assert( m_senderState.m_cbPendingReliable >= 0 );"
    },
    {
        "line": 548,
        "fullcodeline": "bAckedReliableRange = true;"
    }
]