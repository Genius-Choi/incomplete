[
    {
        "line": 69,
        "fullcodeline": "const SteamNetworkingMicroseconds usecNow = ctx.m_usecNow;"
    },
    {
        "line": 70,
        "fullcodeline": "const int64 nPktNum = ctx.m_nPktNum;"
    },
    {
        "line": 71,
        "fullcodeline": "bool bInhibitMarkReceived = false;"
    },
    {
        "line": 73,
        "fullcodeline": "const int nLogLevelPacketDecode = m_connectionConfig.m_LogLevel_PacketDecode.Get();"
    },
    {
        "line": 74,
        "fullcodeline": "SpewVerboseGroup( nLogLevelPacketDecode, \"[%s] decode pkt %lld\\n\", GetDescription(), (long long)nPktNum );"
    },
    {
        "line": 77,
        "fullcodeline": "const byte *pDecode = (const byte *)ctx.m_pPlainText;"
    },
    {
        "line": 78,
        "fullcodeline": "const byte *pEnd = pDecode + ctx.m_cbPlainText;"
    },
    {
        "line": 79,
        "fullcodeline": "int64 nCurMsgNum = 0;"
    },
    {
        "line": 80,
        "fullcodeline": "int64 nDecodeReliablePos = 0;"
    },
    {
        "line": 665,
        "fullcodeline": "m_statsEndToEnd.TrackProcessSequencedPacket( nPktNum, usecNow, usecTimeSinceLast );"
    },
    {
        "line": 81,
        "fullcodeline": "while ( pDecode < pEnd )"
    },
    {
        "line": 85,
        "fullcodeline": "++pDecode;"
    },
    {
        "line": 86,
        "fullcodeline": "if ( ( nFrameType & 0xc0 ) == 0x00 )"
    },
    {
        "line": 654,
        "fullcodeline": "bool bScheduleAck = nDecodeReliablePos > 0;"
    },
    {
        "line": 655,
        "fullcodeline": "SNP_RecordReceivedPktNum( nPktNum, usecNow, bScheduleAck );"
    },
    {
        "line": 145,
        "fullcodeline": "uint32 nOffset = 0;"
    },
    {
        "line": 152,
        "fullcodeline": "READ_SEGMENT_DATA_SIZE( unreliable )"
    },
    {
        "line": 94,
        "fullcodeline": "if ( nCurMsgNum == 0 )"
    },
    {
        "line": 139,
        "fullcodeline": "if ( nCurMsgNum > m_receiverState.m_nHighestSeenMsgNum )"
    },
    {
        "line": 146,
        "fullcodeline": "if ( nFrameType & 0x08 )"
    },
    {
        "line": 156,
        "fullcodeline": "if ( (int64)nOffset + cbSegmentSize > k_cbMaxUnreliableMsgSizeRecv || cbSegmentSize > k_cbMaxUnreliableSegmentSizeRecv )"
    },
    {
        "line": 97,
        "fullcodeline": "static const char szUnreliableMsgNumOffset[] = \"unreliable msgnum\";"
    },
    {
        "line": 111,
        "fullcodeline": "Assert( ( nCurMsgNum & nMask ) == nLowerBits );"
    },
    {
        "line": 140,
        "fullcodeline": "m_receiverState.m_nHighestSeenMsgNum = nCurMsgNum;"
    },
    {
        "line": 147,
        "fullcodeline": "READ_VARINT( nOffset, \"unreliable data offset\" );"
    },
    {
        "line": 160,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"[%s] Ignoring unreliable segment with invalid offset %u size %d\\n\","
    },
    {
        "line": 171,
        "fullcodeline": "else if ( ( nFrameType & 0xe0 ) == 0x40 )"
    },
    {
        "line": 99,
        "fullcodeline": "if ( nFrameType & 0x10 )"
    },
    {
        "line": 113,
        "fullcodeline": "if ( nCurMsgNum <= 0 )"
    },
    {
        "line": 118,
        "fullcodeline": "if ( std::abs( nCurMsgNum - m_receiverState.m_nHighestSeenMsgNum ) > (nMask>>2) )"
    },
    {
        "line": 167,
        "fullcodeline": "bool bLastSegmentInMessage = ( nFrameType & 0x20 ) != 0;"
    },
    {
        "line": 168,
        "fullcodeline": "SNP_ReceiveUnreliableSegment( nCurMsgNum, nOffset, pSegmentData, cbSegmentSize, bLastSegmentInMessage, usecNow );"
    },
    {
        "line": 235,
        "fullcodeline": "READ_SEGMENT_DATA_SIZE( reliable )"
    },
    {
        "line": 250,
        "fullcodeline": "nDecodeReliablePos += cbSegmentSize;"
    },
    {
        "line": 101,
        "fullcodeline": "READ_32BITU( nLowerBits, szUnreliableMsgNumOffset );"
    },
    {
        "line": 102,
        "fullcodeline": "nMask = 0xffffffff;"
    },
    {
        "line": 103,
        "fullcodeline": "nCurMsgNum = NearestWithSameLowerBits( (int32)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );"
    },
    {
        "line": 115,
        "fullcodeline": "DECODE_ERROR( \"SNP decode unreliable msgnum underflow.  %llx mod %llx, highest seen %llx\","
    },
    {
        "line": 121,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"Sender sent abs unreliable message number using %llx mod %llx, highest seen %llx\\n\","
    },
    {
        "line": 128,
        "fullcodeline": "if ( nFrameType & 0x10 )"
    },
    {
        "line": 179,
        "fullcodeline": "if ( nDecodeReliablePos == 0 )"
    },
    {
        "line": 238,
        "fullcodeline": "if ( !SNP_ReceiveReliableSegment( nPktNum, nDecodeReliablePos, pSegmentData, cbSegmentSize, usecNow ) )"
    },
    {
        "line": 254,
        "fullcodeline": "if ( nCurMsgNum > 0 )"
    },
    {
        "line": 107,
        "fullcodeline": "READ_16BITU( nLowerBits, szUnreliableMsgNumOffset );"
    },
    {
        "line": 108,
        "fullcodeline": "nMask = 0xffff;"
    },
    {
        "line": 109,
        "fullcodeline": "nCurMsgNum = NearestWithSameLowerBits( (int16)nLowerBits, m_receiverState.m_nHighestSeenMsgNum );"
    },
    {
        "line": 122,
        "fullcodeline": "(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_receiverState.m_nHighestSeenMsgNum );"
    },
    {
        "line": 131,
        "fullcodeline": "READ_VARINT( nMsgNumOffset, \"unreliable msgnum offset\" );"
    },
    {
        "line": 132,
        "fullcodeline": "nCurMsgNum += nMsgNumOffset;"
    },
    {
        "line": 183,
        "fullcodeline": "static const char szFirstReliableStreamPos[] = \"first reliable streampos\";"
    },
    {
        "line": 194,
        "fullcodeline": "int64 nExpectNextStreamPos = m_receiverState.m_nReliableStreamPos + len( m_receiverState.m_bufReliableStream );"
    },
    {
        "line": 197,
        "fullcodeline": "nDecodeReliablePos = ( nExpectNextStreamPos & ~nMask ) + nOffset;"
    },
    {
        "line": 246,
        "fullcodeline": "bInhibitMarkReceived = true;"
    },
    {
        "line": 255,
        "fullcodeline": "++nCurMsgNum;"
    },
    {
        "line": 257,
        "fullcodeline": "else if ( ( nFrameType & 0xfc ) == 0x80 )"
    },
    {
        "line": 136,
        "fullcodeline": "++nCurMsgNum;"
    },
    {
        "line": 185,
        "fullcodeline": "switch ( nFrameType & (3<<3) )"
    },
    {
        "line": 198,
        "fullcodeline": "if ( nDecodeReliablePos + (nMask>>1) < nExpectNextStreamPos )"
    },
    {
        "line": 205,
        "fullcodeline": "if ( nDecodeReliablePos <= 0 )"
    },
    {
        "line": 210,
        "fullcodeline": "if ( std::abs( nDecodeReliablePos - nExpectNextStreamPos ) > (nMask>>2) )"
    },
    {
        "line": 220,
        "fullcodeline": "static const char szOtherReliableStreamPos[] = \"reliable streampos offset\";"
    },
    {
        "line": 229,
        "fullcodeline": "nDecodeReliablePos += nOffset;"
    },
    {
        "line": 240,
        "fullcodeline": "if ( !BStateIsActive() )"
    },
    {
        "line": 263,
        "fullcodeline": "int64 nOffset = 0;"
    },
    {
        "line": 264,
        "fullcodeline": "static const char szStopWaitingOffset[] = \"stop_waiting offset\";"
    },
    {
        "line": 276,
        "fullcodeline": "++nOffset;"
    },
    {
        "line": 277,
        "fullcodeline": "int64 nMinPktNumToSendAcks = nPktNum-nOffset;"
    },
    {
        "line": 294,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld stop waiting: %lld (was %lld)\","
    },
    {
        "line": 298,
        "fullcodeline": "m_receiverState.m_nMinPktNumToSendAcks = nMinPktNumToSendAcks;"
    },
    {
        "line": 299,
        "fullcodeline": "m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks = nPktNum;"
    },
    {
        "line": 303,
        "fullcodeline": "auto h = m_receiverState.m_mapPacketGaps.begin();"
    },
    {
        "line": 187,
        "fullcodeline": "case 0<<3: READ_24BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<24)-1; break;"
    },
    {
        "line": 188,
        "fullcodeline": "case 1<<3: READ_32BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<32)-1; break;"
    },
    {
        "line": 189,
        "fullcodeline": "case 2<<3: READ_48BITU( nOffset, szFirstReliableStreamPos ); nMask = (1ll<<48)-1; break;"
    },
    {
        "line": 190,
        "fullcodeline": "default: DECODE_ERROR( \"Reserved reliable stream pos size\" );"
    },
    {
        "line": 200,
        "fullcodeline": "nDecodeReliablePos += nMask+1;"
    },
    {
        "line": 201,
        "fullcodeline": "Assert( ( nDecodeReliablePos & nMask ) == nOffset );"
    },
    {
        "line": 202,
        "fullcodeline": "Assert( nExpectNextStreamPos < nDecodeReliablePos );"
    },
    {
        "line": 203,
        "fullcodeline": "Assert( nExpectNextStreamPos + (nMask>>1) >= nDecodeReliablePos );"
    },
    {
        "line": 207,
        "fullcodeline": "DECODE_ERROR( \"SNP decode first reliable stream pos underflow.  %llx mod %llx, expected next %llx\","
    },
    {
        "line": 213,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"Sender sent reliable stream pos using %llx mod %llx, expected next %llx\\n\","
    },
    {
        "line": 222,
        "fullcodeline": "switch ( nFrameType & (3<<3) )"
    },
    {
        "line": 265,
        "fullcodeline": "switch ( nFrameType & 3 )"
    },
    {
        "line": 272,
        "fullcodeline": "if ( nOffset >= nPktNum )"
    },
    {
        "line": 278,
        "fullcodeline": "if ( nMinPktNumToSendAcks == m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 280,
        "fullcodeline": "if ( nMinPktNumToSendAcks < m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 296,
        "fullcodeline": "(long long)nPktNum,"
    },
    {
        "line": 297,
        "fullcodeline": "(long long)nMinPktNumToSendAcks, (long long)m_receiverState.m_nMinPktNumToSendAcks );"
    },
    {
        "line": 304,
        "fullcodeline": "while ( h->first <= m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 214,
        "fullcodeline": "(unsigned long long)nOffset, (unsigned long long)( nMask+1 ), (unsigned long long)nExpectNextStreamPos );"
    },
    {
        "line": 224,
        "fullcodeline": "case 0<<3: nOffset = 0; break;"
    },
    {
        "line": 225,
        "fullcodeline": "case 1<<3: READ_8BITU( nOffset, szOtherReliableStreamPos ); break;"
    },
    {
        "line": 226,
        "fullcodeline": "case 2<<3: READ_16BITU( nOffset, szOtherReliableStreamPos ); break;"
    },
    {
        "line": 227,
        "fullcodeline": "default: READ_32BITU( nOffset, szOtherReliableStreamPos ); break;"
    },
    {
        "line": 267,
        "fullcodeline": "case 0: READ_8BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 268,
        "fullcodeline": "case 1: READ_16BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 269,
        "fullcodeline": "case 2: READ_24BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 270,
        "fullcodeline": "case 3: READ_64BITU( nOffset, szStopWaitingOffset ); break;"
    },
    {
        "line": 274,
        "fullcodeline": "DECODE_ERROR( \"stop_waiting pktNum %llu offset %llu\", nPktNum, nOffset );"
    },
    {
        "line": 330,
        "fullcodeline": "h = m_receiverState.m_mapPacketGaps.erase(h);"
    },
    {
        "line": 333,
        "fullcodeline": "else if ( ( nFrameType & 0xf0 ) == 0x90 )"
    },
    {
        "line": 283,
        "fullcodeline": "if ( nPktNum >= m_receiverState.m_nPktNumUpdatedMinPktNumToSendAcks )"
    },
    {
        "line": 306,
        "fullcodeline": "if ( h->second.m_nEnd > m_receiverState.m_nMinPktNumToSendAcks )"
    },
    {
        "line": 316,
        "fullcodeline": "if ( m_receiverState.m_itPendingAck == h )"
    },
    {
        "line": 320,
        "fullcodeline": "if ( m_receiverState.m_itPendingNack == h )"
    },
    {
        "line": 390,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld latest recv %lld\\n\","
    },
    {
        "line": 397,
        "fullcodeline": "Assert( !m_senderState.m_mapInFlightPacketsByPktNum.empty() );"
    },
    {
        "line": 398,
        "fullcodeline": "auto inFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.upper_bound( nLatestRecvSeqNum );"
    },
    {
        "line": 399,
        "fullcodeline": "--inFlightPkt;"
    },
    {
        "line": 400,
        "fullcodeline": "Assert( inFlightPkt->first <= nLatestRecvSeqNum );"
    },
    {
        "line": 455,
        "fullcodeline": "int nBlocks = nFrameType&7;"
    },
    {
        "line": 477,
        "fullcodeline": "bool bAckedReliableRange = false;"
    },
    {
        "line": 478,
        "fullcodeline": "int64 nPktNumAckEnd = nLatestRecvSeqNum+1;"
    },
    {
        "line": 285,
        "fullcodeline": "DECODE_ERROR( \"SNP stop waiting reduced %lld (pkt %lld) -> %lld (pkt %lld)\","
    },
    {
        "line": 311,
        "fullcodeline": "const_cast<int64 &>( h->first ) = m_receiverState.m_nMinPktNumToSendAcks;"
    },
    {
        "line": 317,
        "fullcodeline": "++m_receiverState.m_itPendingAck;"
    },
    {
        "line": 323,
        "fullcodeline": "AssertMsg( false, \"Expiring packet gap, which had pending NACK\" );"
    },
    {
        "line": 326,
        "fullcodeline": "++m_receiverState.m_itPendingNack;"
    },
    {
        "line": 353,
        "fullcodeline": "static const char szAckLatestPktNum[] = \"ack latest pktnum\";"
    },
    {
        "line": 367,
        "fullcodeline": "Assert( ( nLatestRecvSeqNum & nMask ) == nLowerBits );"
    },
    {
        "line": 392,
        "fullcodeline": "(long long)nPktNum, (long long)nLatestRecvSeqNum"
    },
    {
        "line": 405,
        "fullcodeline": "READ_16BITU( nPackedDelay, \"ack delay\" );"
    },
    {
        "line": 456,
        "fullcodeline": "if ( nBlocks == 7 )"
    },
    {
        "line": 462,
        "fullcodeline": "if ( nBlocks > 0 )"
    },
    {
        "line": 479,
        "fullcodeline": "while ( nBlocks >= 0 )"
    },
    {
        "line": 624,
        "fullcodeline": "if ( nLatestRecvSeqNum > m_senderState.m_nMinPktWaitingOnAck )"
    },
    {
        "line": 634,
        "fullcodeline": "DECODE_ERROR( \"Invalid SNP frame lead byte 0x%02x\", nFrameType );"
    },
    {
        "line": 355,
        "fullcodeline": "if ( nFrameType & 0x40 )"
    },
    {
        "line": 370,
        "fullcodeline": "if ( nLatestRecvSeqNum < 0 )"
    },
    {
        "line": 375,
        "fullcodeline": "if ( std::abs( nLatestRecvSeqNum - m_statsEndToEnd.m_nNextSendSequenceNumber ) > (nMask>>2) )"
    },
    {
        "line": 381,
        "fullcodeline": "if ( nLatestRecvSeqNum >= m_statsEndToEnd.m_nNextSendSequenceNumber )"
    },
    {
        "line": 406,
        "fullcodeline": "if ( nPackedDelay != 0xffff && inFlightPkt->first == nLatestRecvSeqNum && inFlightPkt->second.m_pTransport == ctx.m_pTransport )"
    },
    {
        "line": 457,
        "fullcodeline": "READ_8BITU( nBlocks, \"ack num blocks\" );"
    },
    {
        "line": 469,
        "fullcodeline": "SteamNetworkingMicroseconds usecDelay = 250*1000 / nBlocks;"
    },
    {
        "line": 470,
        "fullcodeline": "QueueFlushAllAcks( usecNow + usecDelay );"
    },
    {
        "line": 540,
        "fullcodeline": "Assert( nPktNumAckBegin >= 0 );"
    },
    {
        "line": 586,
        "fullcodeline": "Assert( nPktNumNackBegin >= 0 );"
    },
    {
        "line": 597,
        "fullcodeline": "nPktNumAckEnd = nPktNumNackBegin;"
    },
    {
        "line": 598,
        "fullcodeline": "--nBlocks;"
    },
    {
        "line": 605,
        "fullcodeline": "m_senderState.RemoveAckedReliableMessageFromUnackedList();"
    },
    {
        "line": 626,
        "fullcodeline": "SpewVerboseGroup( nLogLevelPacketDecode, \"[%s]   updating min_waiting_on_ack %lld -> %lld\\n\","
    },
    {
        "line": 629,
        "fullcodeline": "m_senderState.m_nMinPktWaitingOnAck = nLatestRecvSeqNum;"
    },
    {
        "line": 357,
        "fullcodeline": "READ_32BITU( nLowerBits, szAckLatestPktNum );"
    },
    {
        "line": 358,
        "fullcodeline": "nMask = 0xffffffff;"
    },
    {
        "line": 359,
        "fullcodeline": "nLatestRecvSeqNum = NearestWithSameLowerBits( (int32)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );"
    },
    {
        "line": 372,
        "fullcodeline": "DECODE_ERROR( \"SNP decode ack latest pktnum underflow.  %llx mod %llx, next send %llx\","
    },
    {
        "line": 378,
        "fullcodeline": "SpewWarningRateLimited( usecNow, \"Sender sent abs latest recv pkt number using %llx mod %llx, next send %llx\\n\","
    },
    {
        "line": 383,
        "fullcodeline": "DECODE_ERROR( \"SNP decode ack latest pktnum %lld (%llx mod %llx), but next outoing packet is %lld (%llx).\","
    },
    {
        "line": 408,
        "fullcodeline": "SteamNetworkingMicroseconds usecDelay = SteamNetworkingMicroseconds( nPackedDelay ) << k_nAckDelayPrecisionShift;"
    },
    {
        "line": 409,
        "fullcodeline": "SteamNetworkingMicroseconds usecElapsed = usecNow - inFlightPkt->second.m_usecWhenSent;"
    },
    {
        "line": 410,
        "fullcodeline": "Assert( usecElapsed >= 0 );"
    },
    {
        "line": 413,
        "fullcodeline": "int msPing = ( usecElapsed - usecDelay ) / 1000;"
    },
    {
        "line": 485,
        "fullcodeline": "if ( nBlocks == 0 )"
    },
    {
        "line": 541,
        "fullcodeline": "while ( inFlightPkt->first >= nPktNumAckBegin )"
    },
    {
        "line": 582,
        "fullcodeline": "if ( nPktNumAckBegin <= m_statsEndToEnd.m_pktNumInFlight && m_statsEndToEnd.m_pktNumInFlight < nPktNumAckEnd )"
    },
    {
        "line": 587,
        "fullcodeline": "while ( inFlightPkt->first >= nPktNumNackBegin )"
    },
    {
        "line": 608,
        "fullcodeline": "if ( nLogLevelPacketDecode >= k_ESteamNetworkingSocketsDebugOutputType_Debug )"
    },
    {
        "line": 628,
        "fullcodeline": "(long long)m_senderState.m_nMinPktWaitingOnAck, (long long)nLatestRecvSeqNum );"
    },
    {
        "line": 363,
        "fullcodeline": "READ_16BITU( nLowerBits, szAckLatestPktNum );"
    },
    {
        "line": 364,
        "fullcodeline": "nMask = 0xffff;"
    },
    {
        "line": 365,
        "fullcodeline": "nLatestRecvSeqNum = NearestWithSameLowerBits( (int16)nLowerBits, m_statsEndToEnd.m_nNextSendSequenceNumber );"
    },
    {
        "line": 379,
        "fullcodeline": "(unsigned long long)nLowerBits, (unsigned long long)( nMask+1 ), (unsigned long long)m_statsEndToEnd.m_nNextSendSequenceNumber );"
    },
    {
        "line": 423,
        "fullcodeline": "if ( msPing < -1 || msPing > 2000 )"
    },
    {
        "line": 492,
        "fullcodeline": "nPktNumAckBegin = m_senderState.m_nMinPktWaitingOnAck;"
    },
    {
        "line": 493,
        "fullcodeline": "nPktNumNackBegin = nPktNumAckBegin;"
    },
    {
        "line": 494,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld ack last block ack begin %lld\\n\","
    },
    {
        "line": 543,
        "fullcodeline": "Assert( inFlightPkt->first < nPktNumAckEnd );"
    },
    {
        "line": 576,
        "fullcodeline": "inFlightPkt = m_senderState.m_mapInFlightPacketsByPktNum.erase( inFlightPkt );"
    },
    {
        "line": 577,
        "fullcodeline": "--inFlightPkt;"
    },
    {
        "line": 578,
        "fullcodeline": "m_senderState.MaybeCheckInFlightPacketMap();"
    },
    {
        "line": 583,
        "fullcodeline": "m_statsEndToEnd.InFlightPktAck( usecNow );"
    },
    {
        "line": 589,
        "fullcodeline": "Assert( inFlightPkt->first < nPktNumAckEnd );"
    },
    {
        "line": 590,
        "fullcodeline": "SNP_SenderProcessPacketNack( inFlightPkt->first, inFlightPkt->second, \"NACK\" );"
    },
    {
        "line": 593,
        "fullcodeline": "--inFlightPkt;"
    },
    {
        "line": 611,
        "fullcodeline": "int64 nPeerReliablePos = m_senderState.m_nReliableStreamPos;"
    },
    {
        "line": 617,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld peer reliable pos = %lld\\n\","
    },
    {
        "line": 428,
        "fullcodeline": "SpewMsgGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %lluusec INVALID ping %lldusec\\n\","
    },
    {
        "line": 489,
        "fullcodeline": "if ( nPktNumAckEnd <= m_senderState.m_nMinPktWaitingOnAck )"
    },
    {
        "line": 496,
        "fullcodeline": "(long long)nPktNum, (long long)nPktNumAckBegin );"
    },
    {
        "line": 501,
        "fullcodeline": "READ_8BITU( nBlockHeader, \"ack block header\" );"
    },
    {
        "line": 504,
        "fullcodeline": "int64 numAcks = ( nBlockHeader>> 4 ) & 7;"
    },
    {
        "line": 513,
        "fullcodeline": "nPktNumAckBegin = nPktNumAckEnd - numAcks;"
    },
    {
        "line": 518,
        "fullcodeline": "int64 numNacks = nBlockHeader & 7;"
    },
    {
        "line": 527,
        "fullcodeline": "nPktNumNackBegin = nPktNumAckBegin - numNacks;"
    },
    {
        "line": 531,
        "fullcodeline": "SpewDebugGroup( nLogLevelPacketDecode, \"[%s]   decode pkt %lld nack [%lld,%lld) ack [%lld,%lld)\\n\","
    },
    {
        "line": 572,
        "fullcodeline": "if ( inFlightPkt == m_senderState.m_itNextInFlightPacketToTimeout )"
    },
    {
        "line": 612,
        "fullcodeline": "if ( !m_senderState.m_listInFlightReliableRange.empty() )"
    },
    {
        "line": 614,
        "fullcodeline": "if ( !m_senderState.m_listReadyRetryReliableRange.empty() )"
    },
    {
        "line": 619,
        "fullcodeline": "(long long)nPktNum, (long long)nPeerReliablePos );"
    },
    {
        "line": 430,
        "fullcodeline": "(long long)nPktNum, (long long)nLatestRecvSeqNum,"
    },
    {
        "line": 431,
        "fullcodeline": "(unsigned long long)usecDelay,"
    },
    {
        "line": 432,
        "fullcodeline": "(long long)usecElapsed"
    },
    {
        "line": 440,
        "fullcodeline": "ProcessSNPPing( msPing, ctx );"
    },
    {
        "line": 443,
        "fullcodeline": "SpewVerboseGroup( m_connectionConfig.m_LogLevel_AckRTT.Get(), \"[%s] decode pkt %lld latest recv %lld delay %.1fms elapsed %.1fms ping %dms\\n\","
    },
    {
        "line": 505,
        "fullcodeline": "if ( nBlockHeader & 0x80 )"
    },
    {
        "line": 514,
        "fullcodeline": "if ( nPktNumAckBegin < 0 )"
    },
    {
        "line": 519,
        "fullcodeline": "if ( nBlockHeader & 0x08)"
    },
    {
        "line": 528,
        "fullcodeline": "if ( nPktNumNackBegin < 0 )"
    },
    {
        "line": 533,
        "fullcodeline": "(long long)nPktNum,"
    },
    {
        "line": 534,
        "fullcodeline": "(long long)nPktNumNackBegin, (long long)( nPktNumNackBegin + numNacks ),"
    },
    {
        "line": 535,
        "fullcodeline": "(long long)nPktNumAckBegin, (long long)( nPktNumAckBegin + numAcks )"
    },
    {
        "line": 573,
        "fullcodeline": "++m_senderState.m_itNextInFlightPacketToTimeout;"
    },
    {
        "line": 613,
        "fullcodeline": "nPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listInFlightReliableRange.begin()->first.m_nBegin );"
    },
    {
        "line": 615,
        "fullcodeline": "nPeerReliablePos = std::min( nPeerReliablePos, m_senderState.m_listReadyRetryReliableRange.begin()->first.m_nBegin );"
    },
    {
        "line": 438,
        "fullcodeline": "if ( msPing < 0 )"
    },
    {
        "line": 445,
        "fullcodeline": "(long long)nPktNum, (long long)nLatestRecvSeqNum,"
    },
    {
        "line": 446,
        "fullcodeline": "(float)(usecDelay * 1e-3 ),"
    },
    {
        "line": 447,
        "fullcodeline": "(float)(usecElapsed * 1e-3 ),"
    },
    {
        "line": 508,
        "fullcodeline": "READ_VARINT( nUpperBits, \"ack count upper bits\" );"
    },
    {
        "line": 511,
        "fullcodeline": "numAcks |= nUpperBits<<3;"
    },
    {
        "line": 515,
        "fullcodeline": "DECODE_ERROR( \"Ack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckEnd, (long long)numAcks );"
    },
    {
        "line": 522,
        "fullcodeline": "READ_VARINT( nUpperBits, \"nack count upper bits\" );"
    },
    {
        "line": 525,
        "fullcodeline": "numNacks |= nUpperBits<<3;"
    },
    {
        "line": 529,
        "fullcodeline": "DECODE_ERROR( \"Nack range underflow, end=%lld, num=%lld\", (long long)nPktNumAckBegin, (long long)numAcks );"
    },
    {
        "line": 550,
        "fullcodeline": "if ( m_senderState.m_listInFlightReliableRange.erase( relRange ) == 0 )"
    },
    {
        "line": 439,
        "fullcodeline": "msPing = 0;"
    },
    {
        "line": 509,
        "fullcodeline": "if ( nUpperBits > 100000 )"
    },
    {
        "line": 523,
        "fullcodeline": "if ( nUpperBits > 100000 )"
    },
    {
        "line": 510,
        "fullcodeline": "DECODE_ERROR( \"Ack count of %llu<<3 is crazy\", (unsigned long long)nUpperBits );"
    },
    {
        "line": 524,
        "fullcodeline": "DECODE_ERROR( \"Nack count of %llu<<3 is crazy\", nUpperBits );"
    },
    {
        "line": 552,
        "fullcodeline": "if ( m_senderState.m_listReadyRetryReliableRange.erase( relRange ) > 0 )"
    },
    {
        "line": 565,
        "fullcodeline": "bAckedReliableRange = true;"
    },
    {
        "line": 566,
        "fullcodeline": "Assert( m_senderState.m_listReadyRetryReliableRange.count( relRange ) == 0 );"
    },
    {
        "line": 557,
        "fullcodeline": "m_senderState.m_cbPendingReliable -= int( relRange.length() );"
    },
    {
        "line": 558,
        "fullcodeline": "Assert( m_senderState.m_cbPendingReliable >= 0 );"
    },
    {
        "line": 560,
        "fullcodeline": "bAckedReliableRange = true;"
    }
]