[
    {
        "line": 25,
        "fullcodeline": "assert(image_info != (const ImageInfo *) NULL);"
    },
    {
        "line": 26,
        "fullcodeline": "assert(image_info->signature == MagickCoreSignature);"
    },
    {
        "line": 30,
        "fullcodeline": "assert(exception != (ExceptionInfo *) NULL);"
    },
    {
        "line": 31,
        "fullcodeline": "assert(exception->signature == MagickCoreSignature);"
    },
    {
        "line": 32,
        "fullcodeline": "image=AcquireImage(image_info,exception);"
    },
    {
        "line": 33,
        "fullcodeline": "status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);"
    },
    {
        "line": 39,
        "fullcodeline": "image->depth=1;"
    },
    {
        "line": 40,
        "fullcodeline": "image->endian=MSBEndian;"
    },
    {
        "line": 42,
        "fullcodeline": "image->columns=(size_t) ReadBlobLSBShort(image);"
    },
    {
        "line": 44,
        "fullcodeline": "image->rows=(size_t) ReadBlobLSBShort(image);"
    },
    {
        "line": 52,
        "fullcodeline": "status=SetImageExtent(image,image->columns,image->rows,exception);"
    },
    {
        "line": 58,
        "fullcodeline": "SetImageColorspace(image,GRAYColorspace,exception);"
    },
    {
        "line": 59,
        "fullcodeline": "quantum_info=AcquireQuantumInfo(image_info,image);"
    },
    {
        "line": 62,
        "fullcodeline": "length=GetQuantumExtent(image,quantum_info,GrayQuantum);"
    },
    {
        "line": 87,
        "fullcodeline": "SetQuantumImageType(image,GrayQuantum);"
    },
    {
        "line": 27,
        "fullcodeline": "if (image_info->debug != MagickFalse)"
    },
    {
        "line": 34,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 41,
        "fullcodeline": "(void) ReadBlobLSBShort(image);"
    },
    {
        "line": 43,
        "fullcodeline": "(void) ReadBlobLSBShort(image);"
    },
    {
        "line": 47,
        "fullcodeline": "if (image_info->ping != MagickFalse)"
    },
    {
        "line": 53,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 60,
        "fullcodeline": "if (quantum_info == (QuantumInfo *) NULL)"
    },
    {
        "line": 63,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 88,
        "fullcodeline": "quantum_info=DestroyQuantumInfo(quantum_info);"
    },
    {
        "line": 92,
        "fullcodeline": "(void) CloseBlob(image);"
    },
    {
        "line": 93,
        "fullcodeline": "return(GetFirstImageInList(image));"
    },
    {
        "line": 28,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\","
    },
    {
        "line": 36,
        "fullcodeline": "image=DestroyImageList(image);"
    },
    {
        "line": 45,
        "fullcodeline": "if ((image->columns == 0) || (image->rows == 0))"
    },
    {
        "line": 46,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 61,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 68,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 71,
        "fullcodeline": "pixels=(const unsigned char *) ReadBlobStream(image,length,"
    },
    {
        "line": 89,
        "fullcodeline": "if (EOFBlob(image) != MagickFalse)"
    },
    {
        "line": 90,
        "fullcodeline": "ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\","
    },
    {
        "line": 37,
        "fullcodeline": "return((Image *) NULL);"
    },
    {
        "line": 49,
        "fullcodeline": "(void) CloseBlob(image);"
    },
    {
        "line": 50,
        "fullcodeline": "return(GetFirstImageInList(image));"
    },
    {
        "line": 54,
        "fullcodeline": "return(DestroyImageList(image));"
    },
    {
        "line": 73,
        "fullcodeline": "if (count != (ssize_t) length)"
    },
    {
        "line": 78,
        "fullcodeline": "(void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,"
    },
    {
        "line": 82,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 84,
        "fullcodeline": "if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)"
    },
    {
        "line": 75,
        "fullcodeline": "quantum_info=DestroyQuantumInfo(quantum_info);"
    },
    {
        "line": 76,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");"
    },
    {
        "line": 80,
        "fullcodeline": "pixels=(const unsigned char *) ReadBlobStream(image,(size_t) (-(ssize_t)"
    },
    {
        "line": 72,
        "fullcodeline": "GetQuantumPixels(quantum_info),&count);"
    },
    {
        "line": 81,
        "fullcodeline": "length) & 0x01,GetQuantumPixels(quantum_info),&count);"
    }
]