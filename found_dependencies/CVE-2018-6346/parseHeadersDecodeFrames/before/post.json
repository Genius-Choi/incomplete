[
    {
        "line": 7,
        "fullcodeline": "Cursor headerCursor(curHeaderBlock_.front());"
    },
    {
        "line": 8,
        "fullcodeline": "bool isReq = false;"
    },
    {
        "line": 17,
        "fullcodeline": "decodeInfo_.init(isReq, parsingDownstreamTrailers_);"
    },
    {
        "line": 32,
        "fullcodeline": "headerCodec_.decodeStreaming("
    },
    {
        "line": 34,
        "fullcodeline": "msg = std::move(decodeInfo_.msg);"
    },
    {
        "line": 36,
        "fullcodeline": "auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });"
    },
    {
        "line": 33,
        "fullcodeline": "headerCursor, curHeaderBlock_.chainLength(), this);"
    },
    {
        "line": 38,
        "fullcodeline": "if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (decodeInfo_.parsingError != \"\") {"
    },
    {
        "line": 76,
        "fullcodeline": "return folly::Optional<ErrorCode>();"
    },
    {
        "line": 10,
        "fullcodeline": "isReq = true;"
    },
    {
        "line": 27,
        "fullcodeline": "decodeInfo_.msg->setHTTP2Priority("
    },
    {
        "line": 39,
        "fullcodeline": "static const std::string decodeErrorMessage ="
    },
    {
        "line": 60,
        "fullcodeline": "LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream"
    },
    {
        "line": 62,
        "fullcodeline": "VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);"
    },
    {
        "line": 63,
        "fullcodeline": "HTTPException err(HTTPException::Direction::INGRESS,"
    },
    {
        "line": 71,
        "fullcodeline": "err.setHttpStatusCode(400);"
    },
    {
        "line": 72,
        "fullcodeline": "callback_->onError(curHeader_.stream, err, true);"
    },
    {
        "line": 19,
        "fullcodeline": "if (curHeader_.stream == priority->streamDependency) {"
    },
    {
        "line": 28,
        "fullcodeline": "std::make_tuple(priority->streamDependency,"
    },
    {
        "line": 43,
        "fullcodeline": "if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {"
    },
    {
        "line": 64,
        "fullcodeline": "folly::to<std::string>(\"HTTP2Codec stream error: \","
    },
    {
        "line": 20,
        "fullcodeline": "streamError(folly::to<string>(\"Circular dependency for txn=\","
    },
    {
        "line": 44,
        "fullcodeline": "LOG(ERROR) << decodeErrorMessage << curHeader_.stream"
    },
    {
        "line": 46,
        "fullcodeline": "VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);"
    },
    {
        "line": 53,
        "fullcodeline": "msg->dumpMessage(3);"
    },
    {
        "line": 12,
        "fullcodeline": "isReq = isRequest(curHeader_.stream);"
    },
    {
        "line": 48,
        "fullcodeline": "LOG(ERROR) << decodeErrorMessage << curHeader_.stream;"
    },
    {
        "line": 14,
        "fullcodeline": "isReq = transportDirection_ == TransportDirection::DOWNSTREAM;"
    }
]