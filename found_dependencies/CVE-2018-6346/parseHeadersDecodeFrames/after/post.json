[
    {
        "line": 7,
        "fullcodeline": "Cursor headerCursor(curHeaderBlock_.front());"
    },
    {
        "line": 8,
        "fullcodeline": "bool isReq = false;"
    },
    {
        "line": 26,
        "fullcodeline": "decodeInfo_.init(isReq, parsingDownstreamTrailers_);"
    },
    {
        "line": 34,
        "fullcodeline": "headerCodec_.decodeStreaming("
    },
    {
        "line": 36,
        "fullcodeline": "msg = std::move(decodeInfo_.msg);"
    },
    {
        "line": 38,
        "fullcodeline": "auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });"
    },
    {
        "line": 18,
        "fullcodeline": "if (priority && (curHeader_.stream == priority->streamDependency)) {"
    },
    {
        "line": 35,
        "fullcodeline": "headerCursor, curHeaderBlock_.chainLength(), this);"
    },
    {
        "line": 40,
        "fullcodeline": "if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {"
    },
    {
        "line": 61,
        "fullcodeline": "if (decodeInfo_.parsingError != \"\") {"
    },
    {
        "line": 78,
        "fullcodeline": "return folly::Optional<ErrorCode>();"
    },
    {
        "line": 10,
        "fullcodeline": "isReq = true;"
    },
    {
        "line": 19,
        "fullcodeline": "streamError("
    },
    {
        "line": 28,
        "fullcodeline": "decodeInfo_.msg->setHTTP2Priority("
    },
    {
        "line": 41,
        "fullcodeline": "static const std::string decodeErrorMessage ="
    },
    {
        "line": 62,
        "fullcodeline": "LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream"
    },
    {
        "line": 64,
        "fullcodeline": "VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);"
    },
    {
        "line": 65,
        "fullcodeline": "HTTPException err(HTTPException::Direction::INGRESS,"
    },
    {
        "line": 73,
        "fullcodeline": "err.setHttpStatusCode(400);"
    },
    {
        "line": 74,
        "fullcodeline": "callback_->onError(curHeader_.stream, err, true);"
    },
    {
        "line": 20,
        "fullcodeline": "folly::to<string>(\"Circular dependency for txn=\", curHeader_.stream),"
    },
    {
        "line": 29,
        "fullcodeline": "std::make_tuple(priority->streamDependency,"
    },
    {
        "line": 45,
        "fullcodeline": "if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {"
    },
    {
        "line": 66,
        "fullcodeline": "folly::to<std::string>(\"HTTP2Codec stream error: \","
    },
    {
        "line": 46,
        "fullcodeline": "LOG(ERROR) << decodeErrorMessage << curHeader_.stream"
    },
    {
        "line": 48,
        "fullcodeline": "VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);"
    },
    {
        "line": 55,
        "fullcodeline": "msg->dumpMessage(3);"
    },
    {
        "line": 12,
        "fullcodeline": "isReq = isRequest(curHeader_.stream);"
    },
    {
        "line": 50,
        "fullcodeline": "LOG(ERROR) << decodeErrorMessage << curHeader_.stream;"
    },
    {
        "line": 14,
        "fullcodeline": "isReq = transportDirection_ == TransportDirection::DOWNSTREAM;"
    }
]