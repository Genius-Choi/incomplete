[
    {
        "line": 4,
        "fullcodeline": "struct inode *inode = file_inode(file);"
    },
    {
        "line": 5,
        "fullcodeline": "handle_t *handle = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "loff_t new_size = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "struct address_space *mapping = inode->i_mapping;"
    },
    {
        "line": 15,
        "fullcodeline": "unsigned int blkbits = inode->i_blkbits;"
    },
    {
        "line": 17,
        "fullcodeline": "trace_ext4_zero_range(inode, offset, len, mode);"
    },
    {
        "line": 46,
        "fullcodeline": "start = round_up(offset, 1 << blkbits);"
    },
    {
        "line": 47,
        "fullcodeline": "end = round_down((offset + len), 1 << blkbits);"
    },
    {
        "line": 51,
        "fullcodeline": "partial_begin = offset & ((1 << blkbits) - 1);"
    },
    {
        "line": 52,
        "fullcodeline": "partial_end = (offset + len) & ((1 << blkbits) - 1);"
    },
    {
        "line": 54,
        "fullcodeline": "lblk = start >> blkbits;"
    },
    {
        "line": 55,
        "fullcodeline": "max_blocks = (end >> blkbits);"
    },
    {
        "line": 61,
        "fullcodeline": "flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |"
    },
    {
        "line": 67,
        "fullcodeline": "mutex_lock(&inode->i_mutex);"
    },
    {
        "line": 126,
        "fullcodeline": "credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;"
    },
    {
        "line": 129,
        "fullcodeline": "handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);"
    },
    {
        "line": 136,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 147,
        "fullcodeline": "ext4_mark_inode_dirty(handle, inode);"
    },
    {
        "line": 150,
        "fullcodeline": "ret = ext4_zero_partial_blocks(handle, inode, offset, len);"
    },
    {
        "line": 157,
        "fullcodeline": "ext4_inode_resume_unlocked_dio(inode);"
    },
    {
        "line": 19,
        "fullcodeline": "if (!S_ISREG(inode->i_mode))"
    },
    {
        "line": 23,
        "fullcodeline": "if (ext4_should_journal_data(inode)) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (max_blocks < lblk)"
    },
    {
        "line": 64,
        "fullcodeline": "if (mode & FALLOC_FL_KEEP_SIZE)"
    },
    {
        "line": 91,
        "fullcodeline": "if (max_blocks > 0) {"
    },
    {
        "line": 127,
        "fullcodeline": "if (ext4_should_journal_data(inode))"
    },
    {
        "line": 130,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (file->f_flags & O_SYNC)"
    },
    {
        "line": 24,
        "fullcodeline": "ret = ext4_force_commit(inode->i_sb);"
    },
    {
        "line": 34,
        "fullcodeline": "ret = filemap_write_and_wait_range(mapping, offset,"
    },
    {
        "line": 49,
        "fullcodeline": "if (start < offset || end > offset + len)"
    },
    {
        "line": 57,
        "fullcodeline": "max_blocks = 0;"
    },
    {
        "line": 65,
        "fullcodeline": "flags |= EXT4_GET_BLOCKS_KEEP_SIZE;"
    },
    {
        "line": 72,
        "fullcodeline": "if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {"
    },
    {
        "line": 73,
        "fullcodeline": "ret = -EOPNOTSUPP;"
    },
    {
        "line": 77,
        "fullcodeline": "if (!(mode & FALLOC_FL_KEEP_SIZE) &&"
    },
    {
        "line": 78,
        "fullcodeline": "offset + len > i_size_read(inode)) {"
    },
    {
        "line": 79,
        "fullcodeline": "new_size = offset + len;"
    },
    {
        "line": 80,
        "fullcodeline": "ret = inode_newsize_ok(inode, new_size);"
    },
    {
        "line": 94,
        "fullcodeline": "truncate_pagecache_range(inode, start, end - 1);"
    },
    {
        "line": 95,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 98,
        "fullcodeline": "ext4_inode_block_unlocked_dio(inode);"
    },
    {
        "line": 99,
        "fullcodeline": "inode_dio_wait(inode);"
    },
    {
        "line": 101,
        "fullcodeline": "ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,"
    },
    {
        "line": 115,
        "fullcodeline": "ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);"
    },
    {
        "line": 119,
        "fullcodeline": "if (!partial_begin && !partial_end)"
    },
    {
        "line": 128,
        "fullcodeline": "credits += 2;"
    },
    {
        "line": 131,
        "fullcodeline": "ret = PTR_ERR(handle);"
    },
    {
        "line": 132,
        "fullcodeline": "ext4_std_error(inode->i_sb, ret);"
    },
    {
        "line": 138,
        "fullcodeline": "ext4_update_inode_size(inode, new_size);"
    },
    {
        "line": 153,
        "fullcodeline": "ext4_handle_sync(handle);"
    },
    {
        "line": 20,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 50,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 59,
        "fullcodeline": "max_blocks -= lblk;"
    },
    {
        "line": 35,
        "fullcodeline": "offset + len - 1);"
    },
    {
        "line": 88,
        "fullcodeline": "max_blocks += 1;"
    },
    {
        "line": 144,
        "fullcodeline": "if ((offset + len) > i_size_read(inode))"
    },
    {
        "line": 145,
        "fullcodeline": "ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);"
    }
]