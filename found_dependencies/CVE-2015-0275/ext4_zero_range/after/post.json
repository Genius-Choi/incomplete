[
    {
        "line": 4,
        "fullcodeline": "struct inode *inode = file_inode(file);"
    },
    {
        "line": 5,
        "fullcodeline": "handle_t *handle = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "loff_t new_size = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "struct address_space *mapping = inode->i_mapping;"
    },
    {
        "line": 15,
        "fullcodeline": "unsigned int blkbits = inode->i_blkbits;"
    },
    {
        "line": 17,
        "fullcodeline": "trace_ext4_zero_range(inode, offset, len, mode);"
    },
    {
        "line": 46,
        "fullcodeline": "start = round_up(offset, 1 << blkbits);"
    },
    {
        "line": 47,
        "fullcodeline": "end = round_down((offset + len), 1 << blkbits);"
    },
    {
        "line": 51,
        "fullcodeline": "partial_begin = offset & ((1 << blkbits) - 1);"
    },
    {
        "line": 52,
        "fullcodeline": "partial_end = (offset + len) & ((1 << blkbits) - 1);"
    },
    {
        "line": 54,
        "fullcodeline": "lblk = start >> blkbits;"
    },
    {
        "line": 55,
        "fullcodeline": "max_blocks = (end >> blkbits);"
    },
    {
        "line": 61,
        "fullcodeline": "mutex_lock(&inode->i_mutex);"
    },
    {
        "line": 79,
        "fullcodeline": "flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;"
    },
    {
        "line": 133,
        "fullcodeline": "credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;"
    },
    {
        "line": 136,
        "fullcodeline": "handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);"
    },
    {
        "line": 143,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 154,
        "fullcodeline": "ext4_mark_inode_dirty(handle, inode);"
    },
    {
        "line": 157,
        "fullcodeline": "ret = ext4_zero_partial_blocks(handle, inode, offset, len);"
    },
    {
        "line": 162,
        "fullcodeline": "ext4_journal_stop(handle);"
    },
    {
        "line": 164,
        "fullcodeline": "ext4_inode_resume_unlocked_dio(inode);"
    },
    {
        "line": 166,
        "fullcodeline": "mutex_unlock(&inode->i_mutex);"
    },
    {
        "line": 19,
        "fullcodeline": "if (!S_ISREG(inode->i_mode))"
    },
    {
        "line": 23,
        "fullcodeline": "if (ext4_should_journal_data(inode)) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (start < offset || end > offset + len)"
    },
    {
        "line": 56,
        "fullcodeline": "if (max_blocks < lblk)"
    },
    {
        "line": 66,
        "fullcodeline": "if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (!(mode & FALLOC_FL_KEEP_SIZE) &&"
    },
    {
        "line": 80,
        "fullcodeline": "if (mode & FALLOC_FL_KEEP_SIZE)"
    },
    {
        "line": 84,
        "fullcodeline": "if (partial_begin || partial_end) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (max_blocks > 0) {"
    },
    {
        "line": 126,
        "fullcodeline": "if (!partial_begin && !partial_end)"
    },
    {
        "line": 134,
        "fullcodeline": "if (ext4_should_journal_data(inode))"
    },
    {
        "line": 137,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (file->f_flags & O_SYNC)"
    },
    {
        "line": 24,
        "fullcodeline": "ret = ext4_force_commit(inode->i_sb);"
    },
    {
        "line": 34,
        "fullcodeline": "ret = filemap_write_and_wait_range(mapping, offset,"
    },
    {
        "line": 57,
        "fullcodeline": "max_blocks = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "ret = -EOPNOTSUPP;"
    },
    {
        "line": 72,
        "fullcodeline": "offset + len > i_size_read(inode)) {"
    },
    {
        "line": 73,
        "fullcodeline": "new_size = offset + len;"
    },
    {
        "line": 74,
        "fullcodeline": "ret = inode_newsize_ok(inode, new_size);"
    },
    {
        "line": 81,
        "fullcodeline": "flags |= EXT4_GET_BLOCKS_KEEP_SIZE;"
    },
    {
        "line": 85,
        "fullcodeline": "ret = ext4_alloc_file_blocks(file,"
    },
    {
        "line": 97,
        "fullcodeline": "flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |"
    },
    {
        "line": 101,
        "fullcodeline": "truncate_pagecache_range(inode, start, end - 1);"
    },
    {
        "line": 102,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 105,
        "fullcodeline": "ext4_inode_block_unlocked_dio(inode);"
    },
    {
        "line": 106,
        "fullcodeline": "inode_dio_wait(inode);"
    },
    {
        "line": 108,
        "fullcodeline": "ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,"
    },
    {
        "line": 122,
        "fullcodeline": "ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);"
    },
    {
        "line": 135,
        "fullcodeline": "credits += 2;"
    },
    {
        "line": 138,
        "fullcodeline": "ret = PTR_ERR(handle);"
    },
    {
        "line": 139,
        "fullcodeline": "ext4_std_error(inode->i_sb, ret);"
    },
    {
        "line": 145,
        "fullcodeline": "ext4_update_inode_size(inode, new_size);"
    },
    {
        "line": 160,
        "fullcodeline": "ext4_handle_sync(handle);"
    },
    {
        "line": 20,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 50,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 59,
        "fullcodeline": "max_blocks -= lblk;"
    },
    {
        "line": 35,
        "fullcodeline": "offset + len - 1);"
    },
    {
        "line": 86,
        "fullcodeline": "round_down(offset, 1 << blkbits) >> blkbits,"
    },
    {
        "line": 87,
        "fullcodeline": "(round_up((offset + len), 1 << blkbits) -"
    },
    {
        "line": 151,
        "fullcodeline": "if ((offset + len) > i_size_read(inode))"
    },
    {
        "line": 152,
        "fullcodeline": "ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);"
    },
    {
        "line": 88,
        "fullcodeline": "round_down(offset, 1 << blkbits)) >> blkbits,"
    }
]