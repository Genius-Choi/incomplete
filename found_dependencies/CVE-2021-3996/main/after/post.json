[
    {
        "line": 3,
        "fullcodeline": "struct libmnt_table *tb = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "char **tabfiles = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "int direction = MNT_ITER_FORWARD;"
    },
    {
        "line": 6,
        "fullcodeline": "int verify = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "int c, rc = -1, timeout = -1;"
    },
    {
        "line": 8,
        "fullcodeline": "int ntabfiles = 0, tabtype = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "char *outarg = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "int force_tree = 0, istree = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "struct libscols_table *table = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "static const struct option longopts[] = {"
    },
    {
        "line": 71,
        "fullcodeline": "static const ul_excl_t excl[] = {\t/* rows and cols in ASCII order */"
    },
    {
        "line": 83,
        "fullcodeline": "int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;"
    },
    {
        "line": 85,
        "fullcodeline": "setlocale(LC_ALL, \"\");"
    },
    {
        "line": 86,
        "fullcodeline": "bindtextdomain(PACKAGE, LOCALEDIR);"
    },
    {
        "line": 87,
        "fullcodeline": "textdomain(PACKAGE);"
    },
    {
        "line": 88,
        "fullcodeline": "close_stdout_atexit();"
    },
    {
        "line": 91,
        "fullcodeline": "flags |= FL_TREE;"
    },
    {
        "line": 324,
        "fullcodeline": "mnt_init_debug(0);"
    },
    {
        "line": 326,
        "fullcodeline": "tb = parse_tabfiles(tabfiles, ntabfiles, tabtype);"
    },
    {
        "line": 333,
        "fullcodeline": "istree = tab_is_tree(tb);"
    },
    {
        "line": 363,
        "fullcodeline": "scols_init_debug(0);"
    },
    {
        "line": 364,
        "fullcodeline": "table = scols_new_table();"
    },
    {
        "line": 369,
        "fullcodeline": "scols_table_enable_raw(table,        !!(flags & FL_RAW));"
    },
    {
        "line": 370,
        "fullcodeline": "scols_table_enable_export(table,     !!(flags & FL_EXPORT));"
    },
    {
        "line": 371,
        "fullcodeline": "scols_table_enable_json(table,       !!(flags & FL_JSON));"
    },
    {
        "line": 372,
        "fullcodeline": "scols_table_enable_ascii(table,      !!(flags & FL_ASCII));"
    },
    {
        "line": 373,
        "fullcodeline": "scols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS));"
    },
    {
        "line": 465,
        "fullcodeline": "scols_unref_table(table);"
    },
    {
        "line": 467,
        "fullcodeline": "mnt_unref_table(tb);"
    },
    {
        "line": 468,
        "fullcodeline": "mnt_unref_cache(cache);"
    },
    {
        "line": 470,
        "fullcodeline": "free(tabfiles);"
    },
    {
        "line": 93,
        "fullcodeline": "while ((c = getopt_long(argc, argv,"
    },
    {
        "line": 257,
        "fullcodeline": "if (!ncolumns && (flags & FL_DF)) {"
    },
    {
        "line": 268,
        "fullcodeline": "if (!ncolumns) {"
    },
    {
        "line": 278,
        "fullcodeline": "if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),"
    },
    {
        "line": 282,
        "fullcodeline": "if (!tabtype)"
    },
    {
        "line": 285,
        "fullcodeline": "if ((flags & FL_POLL) && ntabfiles > 1)"
    },
    {
        "line": 288,
        "fullcodeline": "if (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))"
    },
    {
        "line": 293,
        "fullcodeline": "if (optind < argc)"
    },
    {
        "line": 295,
        "fullcodeline": "if (optind < argc)"
    },
    {
        "line": 298,
        "fullcodeline": "if ((flags & FL_SUBMOUNTS) && is_listall_mode())"
    },
    {
        "line": 302,
        "fullcodeline": "if (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY)"
    },
    {
        "line": 308,
        "fullcodeline": "if (!(flags & FL_NOSWAPMATCH) &&"
    },
    {
        "line": 327,
        "fullcodeline": "if (!tb)"
    },
    {
        "line": 330,
        "fullcodeline": "if (tabtype == TABTYPE_MTAB && tab_is_kernel(tb))"
    },
    {
        "line": 334,
        "fullcodeline": "if (istree && force_tree)"
    },
    {
        "line": 337,
        "fullcodeline": "if ((flags & FL_TREE) && (ntabfiles > 1 || !istree))"
    },
    {
        "line": 340,
        "fullcodeline": "if (!(flags & FL_NOCACHE)) {"
    },
    {
        "line": 352,
        "fullcodeline": "if (flags & FL_UNIQ)"
    },
    {
        "line": 365,
        "fullcodeline": "if (!table) {"
    },
    {
        "line": 375,
        "fullcodeline": "if (flags & FL_JSON)"
    },
    {
        "line": 378,
        "fullcodeline": "for (i = 0; i < ncolumns; i++) {"
    },
    {
        "line": 433,
        "fullcodeline": "if (flags & FL_POLL) {"
    },
    {
        "line": 462,
        "fullcodeline": "if (!rc && !(flags & FL_POLL))"
    },
    {
        "line": 474,
        "fullcodeline": "return rc ? EXIT_FAILURE : EXIT_SUCCESS;"
    },
    {
        "line": 26,
        "fullcodeline": "{ \"all\",\t    no_argument,       NULL, 'A'\t\t },"
    },
    {
        "line": 27,
        "fullcodeline": "{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },"
    },
    {
        "line": 28,
        "fullcodeline": "{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },"
    },
    {
        "line": 29,
        "fullcodeline": "{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },"
    },
    {
        "line": 30,
        "fullcodeline": "{ \"direction\",\t    required_argument, NULL, 'd'\t\t },"
    },
    {
        "line": 31,
        "fullcodeline": "{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },"
    },
    {
        "line": 32,
        "fullcodeline": "{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },"
    },
    {
        "line": 33,
        "fullcodeline": "{ \"first-only\",\t    no_argument,       NULL, 'f'\t\t },"
    },
    {
        "line": 34,
        "fullcodeline": "{ \"fstab\",\t    no_argument,       NULL, 's'\t\t },"
    },
    {
        "line": 35,
        "fullcodeline": "{ \"help\",\t    no_argument,       NULL, 'h'\t\t },"
    },
    {
        "line": 36,
        "fullcodeline": "{ \"invert\",\t    no_argument,       NULL, 'i'\t\t },"
    },
    {
        "line": 37,
        "fullcodeline": "{ \"json\",\t    no_argument,       NULL, 'J'\t\t },"
    },
    {
        "line": 38,
        "fullcodeline": "{ \"kernel\",\t    no_argument,       NULL, 'k'\t\t },"
    },
    {
        "line": 39,
        "fullcodeline": "{ \"list\",\t    no_argument,       NULL, 'l'\t\t },"
    },
    {
        "line": 40,
        "fullcodeline": "{ \"mountpoint\",\t    required_argument, NULL, 'M'\t\t },"
    },
    {
        "line": 41,
        "fullcodeline": "{ \"mtab\",\t    no_argument,       NULL, 'm'\t\t },"
    },
    {
        "line": 42,
        "fullcodeline": "{ \"noheadings\",\t    no_argument,       NULL, 'n'\t\t },"
    },
    {
        "line": 43,
        "fullcodeline": "{ \"notruncate\",\t    no_argument,       NULL, 'u'\t\t },"
    },
    {
        "line": 44,
        "fullcodeline": "{ \"options\",\t    required_argument, NULL, 'O'\t\t },"
    },
    {
        "line": 45,
        "fullcodeline": "{ \"output\",\t    required_argument, NULL, 'o'\t\t },"
    },
    {
        "line": 46,
        "fullcodeline": "{ \"output-all\",\t    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL },"
    },
    {
        "line": 47,
        "fullcodeline": "{ \"poll\",\t    optional_argument, NULL, 'p'\t\t },"
    },
    {
        "line": 48,
        "fullcodeline": "{ \"pairs\",\t    no_argument,       NULL, 'P'\t\t },"
    },
    {
        "line": 49,
        "fullcodeline": "{ \"raw\",\t    no_argument,       NULL, 'r'\t\t },"
    },
    {
        "line": 50,
        "fullcodeline": "{ \"types\",\t    required_argument, NULL, 't'\t\t },"
    },
    {
        "line": 51,
        "fullcodeline": "{ \"nocanonicalize\", no_argument,       NULL, 'C'\t\t },"
    },
    {
        "line": 52,
        "fullcodeline": "{ \"nofsroot\",\t    no_argument,       NULL, 'v'\t\t },"
    },
    {
        "line": 53,
        "fullcodeline": "{ \"submounts\",\t    no_argument,       NULL, 'R'\t\t },"
    },
    {
        "line": 54,
        "fullcodeline": "{ \"source\",\t    required_argument, NULL, 'S'\t\t },"
    },
    {
        "line": 55,
        "fullcodeline": "{ \"tab-file\",\t    required_argument, NULL, 'F'\t\t },"
    },
    {
        "line": 56,
        "fullcodeline": "{ \"task\",\t    required_argument, NULL, 'N'\t\t },"
    },
    {
        "line": 57,
        "fullcodeline": "{ \"target\",\t    required_argument, NULL, 'T'\t\t },"
    },
    {
        "line": 58,
        "fullcodeline": "{ \"timeout\",\t    required_argument, NULL, 'w'\t\t },"
    },
    {
        "line": 59,
        "fullcodeline": "{ \"uniq\",\t    no_argument,       NULL, 'U'\t\t },"
    },
    {
        "line": 60,
        "fullcodeline": "{ \"verify\",\t    no_argument,       NULL, 'x'\t\t },"
    },
    {
        "line": 61,
        "fullcodeline": "{ \"version\",\t    no_argument,       NULL, 'V'\t\t },"
    },
    {
        "line": 62,
        "fullcodeline": "{ \"verbose\",\t    no_argument,       NULL, FINDMNT_OPT_VERBOSE },"
    },
    {
        "line": 63,
        "fullcodeline": "{ \"tree\",\t    no_argument,       NULL, FINDMNT_OPT_TREE\t },"
    },
    {
        "line": 64,
        "fullcodeline": "{ \"real\",\t    no_argument,       NULL, FINDMNT_OPT_REAL\t },"
    },
    {
        "line": 65,
        "fullcodeline": "{ \"pseudo\",\t    no_argument,       NULL, FINDMNT_OPT_PSEUDO\t },"
    },
    {
        "line": 66,
        "fullcodeline": "{ \"vfs-all\",\t    no_argument,       NULL, FINDMNT_OPT_VFS_ALL },"
    },
    {
        "line": 67,
        "fullcodeline": "{ \"shadowed\",       no_argument,       NULL, FINDMNT_OPT_SHADOWED },"
    },
    {
        "line": 68,
        "fullcodeline": "{ NULL, 0, NULL, 0 }"
    },
    {
        "line": 72,
        "fullcodeline": "{ 'C', 'c'},\t\t\t/* [no]canonicalize */"
    },
    {
        "line": 73,
        "fullcodeline": "{ 'C', 'e' },\t\t\t/* nocanonicalize, evaluate */"
    },
    {
        "line": 74,
        "fullcodeline": "{ 'J', 'P', 'r','x' },\t\t/* json,pairs,raw,verify */"
    },
    {
        "line": 75,
        "fullcodeline": "{ 'M', 'T' },\t\t\t/* mountpoint, target */"
    },
    {
        "line": 76,
        "fullcodeline": "{ 'N','k','m','s' },\t\t/* task,kernel,mtab,fstab */"
    },
    {
        "line": 77,
        "fullcodeline": "{ 'P','l','r','x' },\t\t/* pairs,list,raw,verify */"
    },
    {
        "line": 78,
        "fullcodeline": "{ 'p','x' },\t\t\t/* poll,verify */"
    },
    {
        "line": 79,
        "fullcodeline": "{ 'm','p','s' },\t\t/* mtab,poll,fstab */"
    },
    {
        "line": 80,
        "fullcodeline": "{ FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL },"
    },
    {
        "line": 81,
        "fullcodeline": "{ 0 }"
    },
    {
        "line": 95,
        "fullcodeline": "longopts, NULL)) != -1) {"
    },
    {
        "line": 97,
        "fullcodeline": "err_exclusive_options(c, longopts, excl, excl_st);"
    },
    {
        "line": 258,
        "fullcodeline": "add_column(columns, ncolumns++, COL_SOURCE);"
    },
    {
        "line": 259,
        "fullcodeline": "add_column(columns, ncolumns++, COL_FSTYPE);"
    },
    {
        "line": 260,
        "fullcodeline": "add_column(columns, ncolumns++, COL_SIZE);"
    },
    {
        "line": 261,
        "fullcodeline": "add_column(columns, ncolumns++, COL_USED);"
    },
    {
        "line": 262,
        "fullcodeline": "add_column(columns, ncolumns++, COL_AVAIL);"
    },
    {
        "line": 263,
        "fullcodeline": "add_column(columns, ncolumns++, COL_USEPERC);"
    },
    {
        "line": 264,
        "fullcodeline": "add_column(columns, ncolumns++, COL_TARGET);"
    },
    {
        "line": 272,
        "fullcodeline": "add_column(columns, ncolumns++, COL_TARGET);"
    },
    {
        "line": 273,
        "fullcodeline": "add_column(columns, ncolumns++, COL_SOURCE);"
    },
    {
        "line": 274,
        "fullcodeline": "add_column(columns, ncolumns++, COL_FSTYPE);"
    },
    {
        "line": 275,
        "fullcodeline": "add_column(columns, ncolumns++, COL_OPTIONS);"
    },
    {
        "line": 283,
        "fullcodeline": "tabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL;"
    },
    {
        "line": 286,
        "fullcodeline": "errx(EXIT_FAILURE, _(\"--poll accepts only one file, but more specified by --tab-file\"));"
    },
    {
        "line": 289,
        "fullcodeline": "errx(EXIT_FAILURE, _("
    },
    {
        "line": 294,
        "fullcodeline": "set_source_match(argv[optind++]);\t/* dev/tag/mountpoint/maj:min */"
    },
    {
        "line": 296,
        "fullcodeline": "set_match(COL_TARGET, argv[optind++]);\t/* mountpoint */"
    },
    {
        "line": 300,
        "fullcodeline": "flags &= ~FL_SUBMOUNTS;"
    },
    {
        "line": 306,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 309,
        "fullcodeline": "!get_match(COL_TARGET) && get_match(COL_SOURCE)) {"
    },
    {
        "line": 314,
        "fullcodeline": "const char *x = get_match(COL_SOURCE);"
    },
    {
        "line": 331,
        "fullcodeline": "tabtype = TABTYPE_KERNEL;"
    },
    {
        "line": 335,
        "fullcodeline": "flags |= FL_TREE;"
    },
    {
        "line": 338,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 341,
        "fullcodeline": "cache = mnt_new_cache();"
    },
    {
        "line": 346,
        "fullcodeline": "mnt_table_set_cache(tb, cache);"
    },
    {
        "line": 353,
        "fullcodeline": "mnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp);"
    },
    {
        "line": 356,
        "fullcodeline": "rc = verify_table(tb);"
    },
    {
        "line": 366,
        "fullcodeline": "warn(_(\"failed to allocate output table\"));"
    },
    {
        "line": 376,
        "fullcodeline": "scols_table_set_name(table, \"filesystems\");"
    },
    {
        "line": 380,
        "fullcodeline": "int fl = get_column_flags(i);"
    },
    {
        "line": 381,
        "fullcodeline": "int id = get_column_id(i);"
    },
    {
        "line": 391,
        "fullcodeline": "cl = scols_table_new_column(table, get_column_name(i),"
    },
    {
        "line": 435,
        "fullcodeline": "rc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction);"
    },
    {
        "line": 463,
        "fullcodeline": "scols_print_table(table);"
    },
    {
        "line": 269,
        "fullcodeline": "if (flags & FL_POLL)"
    },
    {
        "line": 305,
        "fullcodeline": "|| get_match(COL_MAJMIN)))"
    },
    {
        "line": 316,
        "fullcodeline": "if (!strncmp(x, \"LABEL=\", 6) || !strncmp(x, \"UUID=\", 5) ||"
    },
    {
        "line": 342,
        "fullcodeline": "if (!cache) {"
    },
    {
        "line": 348,
        "fullcodeline": "if (tabtype != TABTYPE_KERNEL)"
    },
    {
        "line": 383,
        "fullcodeline": "if (!(flags & FL_TREE))"
    },
    {
        "line": 386,
        "fullcodeline": "if (!(flags & FL_POLL) && is_tabdiff_column(id)) {"
    },
    {
        "line": 393,
        "fullcodeline": "if (!cl)\t{"
    },
    {
        "line": 398,
        "fullcodeline": "if (fl & SCOLS_FL_WRAP) {"
    },
    {
        "line": 405,
        "fullcodeline": "if (flags & FL_JSON) {"
    },
    {
        "line": 101,
        "fullcodeline": "flags |= FL_ALL;"
    },
    {
        "line": 104,
        "fullcodeline": "flags |= FL_ASCII;"
    },
    {
        "line": 107,
        "fullcodeline": "flags |= FL_BYTES;"
    },
    {
        "line": 110,
        "fullcodeline": "flags |= FL_NOCACHE;"
    },
    {
        "line": 113,
        "fullcodeline": "flags |= FL_CANONICALIZE;"
    },
    {
        "line": 116,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 117,
        "fullcodeline": "flags |= FL_DF;"
    },
    {
        "line": 129,
        "fullcodeline": "flags |= FL_EVALUATE;"
    },
    {
        "line": 132,
        "fullcodeline": "flags |= FL_INVERT;"
    },
    {
        "line": 135,
        "fullcodeline": "flags |= FL_JSON;"
    },
    {
        "line": 138,
        "fullcodeline": "flags |= FL_FIRSTONLY;"
    },
    {
        "line": 141,
        "fullcodeline": "tabfiles = append_tabfile(tabfiles, &ntabfiles, optarg);"
    },
    {
        "line": 144,
        "fullcodeline": "disable_columns_truncate();"
    },
    {
        "line": 147,
        "fullcodeline": "outarg = optarg;"
    },
    {
        "line": 157,
        "fullcodeline": "set_match(COL_OPTIONS, optarg);"
    },
    {
        "line": 167,
        "fullcodeline": "flags |= FL_POLL;"
    },
    {
        "line": 168,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 171,
        "fullcodeline": "flags |= FL_EXPORT;"
    },
    {
        "line": 172,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 175,
        "fullcodeline": "tabtype = TABTYPE_MTAB;"
    },
    {
        "line": 176,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 179,
        "fullcodeline": "tabtype = TABTYPE_FSTAB;"
    },
    {
        "line": 180,
        "fullcodeline": "flags &= ~FL_TREE;"
    },
    {
        "line": 183,
        "fullcodeline": "tabtype = TABTYPE_KERNEL;"
    },
    {
        "line": 186,
        "fullcodeline": "set_match(COL_FSTYPE, optarg);"
    },
    {
        "line": 189,
        "fullcodeline": "flags &= ~FL_TREE;\t/* disable the default */"
    },
    {
        "line": 190,
        "fullcodeline": "flags |= FL_RAW;\t/* enable raw */"
    },
    {
        "line": 193,
        "fullcodeline": "flags &= ~FL_TREE;\t/* disable the default */"
    },
    {
        "line": 196,
        "fullcodeline": "flags |= FL_NOHEADINGS;"
    },
    {
        "line": 199,
        "fullcodeline": "tabtype = TABTYPE_KERNEL;"
    },
    {
        "line": 200,
        "fullcodeline": "tabfiles = append_pid_tabfile(tabfiles, &ntabfiles,"
    },
    {
        "line": 205,
        "fullcodeline": "flags |= FL_NOFSROOT;"
    },
    {
        "line": 208,
        "fullcodeline": "flags |= FL_SUBMOUNTS;"
    },
    {
        "line": 211,
        "fullcodeline": "set_source_match(optarg);"
    },
    {
        "line": 212,
        "fullcodeline": "flags |= FL_NOSWAPMATCH;"
    },
    {
        "line": 215,
        "fullcodeline": "flags |= FL_STRICTTARGET;"
    },
    {
        "line": 218,
        "fullcodeline": "set_match(COL_TARGET, optarg);"
    },
    {
        "line": 219,
        "fullcodeline": "flags |= FL_NOSWAPMATCH;"
    },
    {
        "line": 222,
        "fullcodeline": "flags |= FL_UNIQ;"
    },
    {
        "line": 225,
        "fullcodeline": "timeout = strtos32_or_err(optarg, _(\"invalid timeout argument\"));"
    },
    {
        "line": 228,
        "fullcodeline": "verify = 1;"
    },
    {
        "line": 231,
        "fullcodeline": "flags |= FL_VERBOSE;"
    },
    {
        "line": 234,
        "fullcodeline": "force_tree = 1;"
    },
    {
        "line": 237,
        "fullcodeline": "flags |= FL_PSEUDO;"
    },
    {
        "line": 240,
        "fullcodeline": "flags |= FL_REAL;"
    },
    {
        "line": 243,
        "fullcodeline": "flags |= FL_VFS_ALL;"
    },
    {
        "line": 246,
        "fullcodeline": "flags |= FL_SHADOWED;"
    },
    {
        "line": 249,
        "fullcodeline": "usage();"
    },
    {
        "line": 251,
        "fullcodeline": "print_version(EXIT_SUCCESS);"
    },
    {
        "line": 253,
        "fullcodeline": "errtryhelp(EXIT_FAILURE);"
    },
    {
        "line": 270,
        "fullcodeline": "add_column(columns, ncolumns++, COL_ACTION);"
    },
    {
        "line": 304,
        "fullcodeline": "|| get_match(COL_SOURCE)"
    },
    {
        "line": 317,
        "fullcodeline": "!strncmp(x, \"PARTLABEL=\", 10) || !strncmp(x, \"PARTUUID=\", 9))"
    },
    {
        "line": 318,
        "fullcodeline": "flags |= FL_NOSWAPMATCH;"
    },
    {
        "line": 343,
        "fullcodeline": "warn(_(\"failed to initialize libmount cache\"));"
    },
    {
        "line": 349,
        "fullcodeline": "cache_set_targets(cache);"
    },
    {
        "line": 384,
        "fullcodeline": "fl &= ~SCOLS_FL_TREE;"
    },
    {
        "line": 387,
        "fullcodeline": "warnx(_(\"%s column is requested, but --poll \""
    },
    {
        "line": 392,
        "fullcodeline": "get_column_whint(i), fl);"
    },
    {
        "line": 394,
        "fullcodeline": "warn(_(\"failed to allocate output column\"));"
    },
    {
        "line": 399,
        "fullcodeline": "scols_column_set_wrapfunc(cl,"
    },
    {
        "line": 403,
        "fullcodeline": "scols_column_set_safechars(cl, \"\\n\");"
    },
    {
        "line": 437,
        "fullcodeline": "} else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (!strcmp(optarg, \"forward\"))"
    },
    {
        "line": 150,
        "fullcodeline": "for (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) {"
    },
    {
        "line": 303,
        "fullcodeline": "|| get_match(COL_TARGET)"
    },
    {
        "line": 388,
        "fullcodeline": "\"is not enabled\"), get_column_name(i));"
    },
    {
        "line": 439,
        "fullcodeline": "rc = create_treenode(table, tb, NULL, NULL);"
    },
    {
        "line": 121,
        "fullcodeline": "direction = MNT_ITER_FORWARD;"
    },
    {
        "line": 153,
        "fullcodeline": "columns[ncolumns] = ncolumns;"
    },
    {
        "line": 161,
        "fullcodeline": "nactions = string_to_idarray(optarg,"
    },
    {
        "line": 201,
        "fullcodeline": "strtou32_or_err(optarg,"
    },
    {
        "line": 418,
        "fullcodeline": "scols_column_set_json_type(cl, SCOLS_JSON_NUMBER);"
    },
    {
        "line": 442,
        "fullcodeline": "rc = add_matching_lines(tb, table, direction);"
    },
    {
        "line": 151,
        "fullcodeline": "if (is_tabdiff_column(ncolumns))"
    },
    {
        "line": 164,
        "fullcodeline": "if (nactions < 0)"
    },
    {
        "line": 202,
        "fullcodeline": "_(\"invalid TID argument\")));"
    },
    {
        "line": 410,
        "fullcodeline": "if (!(flags & FL_BYTES))"
    },
    {
        "line": 421,
        "fullcodeline": "if (fl & SCOLS_FL_WRAP)"
    },
    {
        "line": 444,
        "fullcodeline": "if (rc != 0"
    },
    {
        "line": 122,
        "fullcodeline": "else if (!strcmp(optarg, \"backward\"))"
    },
    {
        "line": 162,
        "fullcodeline": "actions, ARRAY_SIZE(actions),"
    },
    {
        "line": 165,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 422,
        "fullcodeline": "scols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);"
    },
    {
        "line": 448,
        "fullcodeline": "&& get_match(COL_TARGET)) {"
    },
    {
        "line": 454,
        "fullcodeline": "enable_extra_target_match(tb);"
    },
    {
        "line": 455,
        "fullcodeline": "rc = add_matching_lines(tb, table, direction);"
    },
    {
        "line": 123,
        "fullcodeline": "direction = MNT_ITER_BACKWARD;"
    },
    {
        "line": 424,
        "fullcodeline": "scols_column_set_json_type(cl, SCOLS_JSON_STRING);"
    },
    {
        "line": 447,
        "fullcodeline": "&& !(flags & FL_STRICTTARGET)"
    },
    {
        "line": 125,
        "fullcodeline": "errx(EXIT_FAILURE,"
    },
    {
        "line": 446,
        "fullcodeline": "&& (flags & FL_NOSWAPMATCH)"
    },
    {
        "line": 126,
        "fullcodeline": "_(\"unknown direction '%s'\"), optarg);"
    },
    {
        "line": 445,
        "fullcodeline": "&& tabtype == TABTYPE_KERNEL"
    }
]