[
    {
        "line": 2,
        "fullcodeline": "{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;"
    },
    {
        "line": 3,
        "fullcodeline": "const FLAC__Frame *frame = pflac->frame ;"
    },
    {
        "line": 4,
        "fullcodeline": "const int32_t* const *buffer = pflac->wbuffer ;"
    },
    {
        "line": 5,
        "fullcodeline": "unsigned i = 0, j, offset, channels, len ;"
    },
    {
        "line": 29,
        "fullcodeline": "channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;"
    },
    {
        "line": 48,
        "fullcodeline": "len = SF_MIN (pflac->len, frame->header.blocksize) ;"
    },
    {
        "line": 162,
        "fullcodeline": "offset = i * channels ;"
    },
    {
        "line": 163,
        "fullcodeline": "pflac->pos += i * channels ;"
    },
    {
        "line": 20,
        "fullcodeline": "if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)"
    },
    {
        "line": 26,
        "fullcodeline": "if (frame->header.channels > FLAC__MAX_CHANNELS)"
    },
    {
        "line": 31,
        "fullcodeline": "if (pflac->ptr == NULL)"
    },
    {
        "line": 50,
        "fullcodeline": "if (pflac->remain % channels != 0)"
    },
    {
        "line": 8,
        "fullcodeline": "{\tpsf_log_printf (psf, \"Error: FLAC frame changed from %d to %d channels\\n\""
    },
    {
        "line": 11,
        "fullcodeline": "psf->error = SFE_FLAC_CHANNEL_COUNT_CHANGED ;"
    },
    {
        "line": 21,
        "fullcodeline": "{\tpsf_log_printf (psf, \"Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;"
    },
    {
        "line": 22,
        "fullcodeline": "psf->error = SFE_INTERNAL ;"
    },
    {
        "line": 27,
        "fullcodeline": "psf_log_printf (psf, \"Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\\n\", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;"
    },
    {
        "line": 43,
        "fullcodeline": "pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;"
    },
    {
        "line": 51,
        "fullcodeline": "{\tpsf_log_printf (psf, \"Error: pflac->remain %u    channels %u\\n\", pflac->remain, channels) ;"
    },
    {
        "line": 36,
        "fullcodeline": "for (i = 0 ; i < channels ; i++)"
    },
    {
        "line": 57,
        "fullcodeline": "{\tshort *retpcm = (short*) pflac->ptr ;"
    },
    {
        "line": 58,
        "fullcodeline": "int shift = 16 - frame->header.bits_per_sample ;"
    },
    {
        "line": 97,
        "fullcodeline": "{\tint *retpcm = (int*) pflac->ptr ;"
    },
    {
        "line": 98,
        "fullcodeline": "int shift = 32 - frame->header.bits_per_sample ;"
    },
    {
        "line": 117,
        "fullcodeline": "{\tfloat *retpcm = (float*) pflac->ptr ;"
    },
    {
        "line": 118,
        "fullcodeline": "float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;"
    },
    {
        "line": 138,
        "fullcodeline": "{\tdouble *retpcm = (double*) pflac->ptr ;"
    },
    {
        "line": 139,
        "fullcodeline": "double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;"
    },
    {
        "line": 41,
        "fullcodeline": "memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;"
    },
    {
        "line": 59,
        "fullcodeline": "if (shift < 0)"
    },
    {
        "line": 99,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 120,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 141,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 38,
        "fullcodeline": "if (pflac->rbuffer [i] == NULL)"
    },
    {
        "line": 60,
        "fullcodeline": "{\tshift = abs (shift) ;"
    },
    {
        "line": 100,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 110,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 111,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 121,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 131,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 132,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 142,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 152,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 153,
        "fullcodeline": "pflac->bufferpos++ ;"
    },
    {
        "line": 39,
        "fullcodeline": "pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;"
    },
    {
        "line": 61,
        "fullcodeline": "for (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 102,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 105,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 108,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 109,
        "fullcodeline": "retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;"
    },
    {
        "line": 123,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 126,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 129,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 130,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;"
    },
    {
        "line": 144,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 147,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 150,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 151,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;"
    },
    {
        "line": 62,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 72,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 73,
        "fullcodeline": "pflac->bufferpos ++ ;"
    },
    {
        "line": 77,
        "fullcodeline": "{\tfor (i = 0 ; i < len && pflac->remain > 0 ; i++)"
    },
    {
        "line": 64,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 67,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 70,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 71,
        "fullcodeline": "retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;"
    },
    {
        "line": 78,
        "fullcodeline": "{\toffset = pflac->pos + i * channels ;"
    },
    {
        "line": 89,
        "fullcodeline": "pflac->remain -= channels ;"
    },
    {
        "line": 90,
        "fullcodeline": "pflac->bufferpos ++ ;"
    },
    {
        "line": 80,
        "fullcodeline": "if (pflac->bufferpos >= frame->header.blocksize)"
    },
    {
        "line": 83,
        "fullcodeline": "if (offset + channels > pflac->len)"
    },
    {
        "line": 86,
        "fullcodeline": "for (j = 0 ; j < channels ; j++)"
    },
    {
        "line": 87,
        "fullcodeline": "retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;"
    }
]