[
    {
        "line": 7,
        "fullcodeline": "COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)"
    },
    {
        "line": 9,
        "fullcodeline": "fi->seek(0, SEEK_SET);"
    },
    {
        "line": 10,
        "fullcodeline": "fi->readx(u.buf, sizeof(u.buf));"
    },
    {
        "line": 11,
        "fullcodeline": "fi->seek(0, SEEK_SET);"
    },
    {
        "line": 12,
        "fullcodeline": "Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;"
    },
    {
        "line": 30,
        "fullcodeline": "Elf32_Phdr const *phdr = phdri;"
    },
    {
        "line": 31,
        "fullcodeline": "note_size = 0;"
    },
    {
        "line": 393,
        "fullcodeline": "assert(exetype == 1);"
    },
    {
        "line": 394,
        "fullcodeline": "exetype = 0;"
    },
    {
        "line": 397,
        "fullcodeline": "opt->o_unix.blocksize = blocksize = file_size;"
    },
    {
        "line": 15,
        "fullcodeline": "if (checkEhdr(ehdr) != 0)"
    },
    {
        "line": 19,
        "fullcodeline": "if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr"
    },
    {
        "line": 32,
        "fullcodeline": "for (unsigned j=0; j < e_phnum; ++phdr, ++j) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0"
    },
    {
        "line": 100,
        "fullcodeline": "if (osabi0!=ei_osabi) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {"
    },
    {
        "line": 391,
        "fullcodeline": "if (!super::canPack())"
    },
    {
        "line": 20,
        "fullcodeline": "throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");"
    },
    {
        "line": 24,
        "fullcodeline": "throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");"
    },
    {
        "line": 37,
        "fullcodeline": "unsigned const p_type = get_te32(&phdr->p_type);"
    },
    {
        "line": 38,
        "fullcodeline": "unsigned const p_offset = get_te32(&phdr->p_offset);"
    },
    {
        "line": 88,
        "fullcodeline": "||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE."
    },
    {
        "line": 89,
        "fullcodeline": "unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);"
    },
    {
        "line": 120,
        "fullcodeline": "alloc_file_image(file_image, file_size);"
    },
    {
        "line": 121,
        "fullcodeline": "fi->seek(0, SEEK_SET);"
    },
    {
        "line": 122,
        "fullcodeline": "fi->readx(file_image, file_size);"
    },
    {
        "line": 123,
        "fullcodeline": "memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));"
    },
    {
        "line": 124,
        "fullcodeline": "phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!"
    },
    {
        "line": 125,
        "fullcodeline": "shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!"
    },
    {
        "line": 127,
        "fullcodeline": "sec_strndx = NULL;"
    },
    {
        "line": 128,
        "fullcodeline": "shstrtab = NULL;"
    },
    {
        "line": 169,
        "fullcodeline": "Elf32_Phdr const *pload_x0(0);  // first eXecutable PT_LOAD"
    },
    {
        "line": 170,
        "fullcodeline": "phdr= phdri;"
    },
    {
        "line": 185,
        "fullcodeline": "dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);"
    },
    {
        "line": 186,
        "fullcodeline": "dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);"
    },
    {
        "line": 33,
        "fullcodeline": "if (j >= 14) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD"
    },
    {
        "line": 59,
        "fullcodeline": "if (PT_NOTE32 == p_type) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (Elf32_Ehdr::EM_ARM==e_machine"
    },
    {
        "line": 171,
        "fullcodeline": "for (int j= e_phnum; --j>=0; ++phdr)"
    },
    {
        "line": 188,
        "fullcodeline": "if (opt->o_unix.force_pie"
    },
    {
        "line": 34,
        "fullcodeline": "throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");"
    },
    {
        "line": 40,
        "fullcodeline": "exetype = 1;"
    },
    {
        "line": 41,
        "fullcodeline": "load_va = get_te32(&phdr->p_vaddr);  // class data member"
    },
    {
        "line": 46,
        "fullcodeline": "unsigned const off = ~page_mask & (unsigned)load_va;"
    },
    {
        "line": 57,
        "fullcodeline": "hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));"
    },
    {
        "line": 60,
        "fullcodeline": "unsigned const x = get_te32(&phdr->p_memsz);"
    },
    {
        "line": 91,
        "fullcodeline": "&&   (EF_ARM_EABI_VER5==arm_eabi"
    },
    {
        "line": 94,
        "fullcodeline": "ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;"
    },
    {
        "line": 130,
        "fullcodeline": "unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);"
    },
    {
        "line": 146,
        "fullcodeline": "sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);"
    },
    {
        "line": 172,
        "fullcodeline": "if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {"
    },
    {
        "line": 192,
        "fullcodeline": "||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),"
    },
    {
        "line": 194,
        "fullcodeline": "is_pie = true;"
    },
    {
        "line": 48,
        "fullcodeline": "if (off && off == p_offset) { // specific hint"
    },
    {
        "line": 53,
        "fullcodeline": "if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr"
    },
    {
        "line": 61,
        "fullcodeline": "if ( sizeof(elfout.notes) < x  // beware overflow of note_size"
    },
    {
        "line": 66,
        "fullcodeline": "if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic."
    },
    {
        "line": 92,
        "fullcodeline": "||  EF_ARM_EABI_VER4==arm_eabi ) ) {"
    },
    {
        "line": 173,
        "fullcodeline": "dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);"
    },
    {
        "line": 190,
        "fullcodeline": "||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),"
    },
    {
        "line": 193,
        "fullcodeline": "(int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {"
    },
    {
        "line": 49,
        "fullcodeline": "throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");"
    },
    {
        "line": 54,
        "fullcodeline": "throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");"
    },
    {
        "line": 62,
        "fullcodeline": "||  (sizeof(elfout.notes) < (note_size += x)) ) {"
    },
    {
        "line": 63,
        "fullcodeline": "throwCantPack(\"PT_NOTEs too big; try '--force-execve'\");"
    },
    {
        "line": 72,
        "fullcodeline": "memset(&note, 0, sizeof(note));"
    },
    {
        "line": 73,
        "fullcodeline": "fi->seek(p_offset, SEEK_SET);"
    },
    {
        "line": 74,
        "fullcodeline": "fi->readx(&note, sizeof(note));"
    },
    {
        "line": 75,
        "fullcodeline": "fi->seek(0, SEEK_SET);"
    },
    {
        "line": 137,
        "fullcodeline": "sec_strndx = &shdri[e_shstrndx];"
    },
    {
        "line": 138,
        "fullcodeline": "unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);"
    },
    {
        "line": 144,
        "fullcodeline": "shstrtab = (char const *)(sh_offset + file_image);"
    },
    {
        "line": 148,
        "fullcodeline": "unsigned const sh_link = get_te32(&sec_dynsym->sh_link);"
    },
    {
        "line": 153,
        "fullcodeline": "sec_dynstr = &shdri[sh_link];"
    },
    {
        "line": 157,
        "fullcodeline": "unsigned const sh_name = get_te32(&sec_strndx->sh_name);"
    },
    {
        "line": 189,
        "fullcodeline": "||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)"
    },
    {
        "line": 191,
        "fullcodeline": "(int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))"
    },
    {
        "line": 76,
        "fullcodeline": "if (4==get_te32(&note.nhdr.descsz)"
    },
    {
        "line": 132,
        "fullcodeline": "if (e_shnum <= e_shstrndx) {"
    },
    {
        "line": 139,
        "fullcodeline": "if ((u32_t)file_size <= sh_offset) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (e_shnum <= sh_link) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)"
    },
    {
        "line": 176,
        "fullcodeline": "else if (PT_LOAD32==get_te32(&phdr->p_type)) {"
    },
    {
        "line": 80,
        "fullcodeline": "&&  0==strcmp(osabi_note, (char const *)&note.name[0])"
    },
    {
        "line": 82,
        "fullcodeline": "osabi0 = ei_osabi;  // Specified by PT_NOTE."
    },
    {
        "line": 133,
        "fullcodeline": "char msg[40]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 135,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 140,
        "fullcodeline": "char msg[50]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 142,
        "fullcodeline": "throwCantPack(msg);"
    },
    {
        "line": 150,
        "fullcodeline": "char msg[50]; snprintf(msg, sizeof(msg),"
    },
    {
        "line": 161,
        "fullcodeline": "|| (sh_name"
    },
    {
        "line": 164,
        "fullcodeline": "throwCantPack(\"bad e_shstrtab\");"
    },
    {
        "line": 182,
        "fullcodeline": "check_pt_load(phdr);"
    },
    {
        "line": 79,
        "fullcodeline": "&&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)"
    },
    {
        "line": 159,
        "fullcodeline": "|| (u32_t)file_size <= (sizeof(\".shstrtab\")"
    },
    {
        "line": 162,
        "fullcodeline": "&& 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))"
    },
    {
        "line": 177,
        "fullcodeline": "if (!pload_x0"
    },
    {
        "line": 77,
        "fullcodeline": "&&  1==get_te32(&note.nhdr.type)"
    },
    {
        "line": 178,
        "fullcodeline": "&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)"
    },
    {
        "line": 180,
        "fullcodeline": "pload_x0 = phdr;"
    },
    {
        "line": 160,
        "fullcodeline": "+ sh_name + (shstrtab - (const char *)&file_image[0]))"
    }
]