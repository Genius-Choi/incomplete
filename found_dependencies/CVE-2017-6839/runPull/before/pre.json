[
    {
        "line": 3,
        "fullcodeline": "AFframecount framesToRead = m_outChunk->frameCount;"
    },
    {
        "line": 4,
        "fullcodeline": "AFframecount framesRead = 0;"
    },
    {
        "line": 6,
        "fullcodeline": "assert(framesToRead % m_framesPerPacket == 0);"
    },
    {
        "line": 7,
        "fullcodeline": "int blockCount = framesToRead / m_framesPerPacket;"
    },
    {
        "line": 10,
        "fullcodeline": "ssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);"
    },
    {
        "line": 11,
        "fullcodeline": "int blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;"
    },
    {
        "line": 22,
        "fullcodeline": "m_track->nextfframe += framesRead;"
    },
    {
        "line": 24,
        "fullcodeline": "assert(tell() == m_track->fpos_next_frame);"
    },
    {
        "line": 29,
        "fullcodeline": "m_outChunk->frameCount = framesRead;"
    },
    {
        "line": 14,
        "fullcodeline": "for (int i=0; i<blocksRead; i++)"
    },
    {
        "line": 26,
        "fullcodeline": "if (framesRead < framesToRead)"
    },
    {
        "line": 16,
        "fullcodeline": "decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,"
    },
    {
        "line": 19,
        "fullcodeline": "framesRead += m_framesPerPacket;"
    },
    {
        "line": 27,
        "fullcodeline": "reportReadError(framesRead, framesToRead);"
    },
    {
        "line": 17,
        "fullcodeline": "static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);"
    }
]