[
    {
        "line": 23,
        "fullcodeline": "char const *type = fio_cli_get_line_type(parser, line);"
    },
    {
        "line": 74,
        "fullcodeline": "fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\","
    },
    {
        "line": 78,
        "fullcodeline": "fprintf(stderr, \"\\n%s\\n\","
    },
    {
        "line": 83,
        "fullcodeline": "char const **pos = parser->names;"
    },
    {
        "line": 175,
        "fullcodeline": "fprintf(stderr, \"\\nUse any of the following input formats:\\n\""
    },
    {
        "line": 180,
        "fullcodeline": "fio_cli_end();"
    },
    {
        "line": 181,
        "fullcodeline": "exit(0);"
    },
    {
        "line": 4,
        "fullcodeline": "if (!line || !arg.len) {"
    },
    {
        "line": 24,
        "fullcodeline": "switch ((size_t)type) {"
    },
    {
        "line": 50,
        "fullcodeline": "cstr_s n = {.data = line};"
    },
    {
        "line": 67,
        "fullcodeline": "if (value && parser->pos < parser->argc &&"
    },
    {
        "line": 75,
        "fullcodeline": "(int)arg.len, arg.data, arg.len ? \"with value\" : \"\","
    },
    {
        "line": 76,
        "fullcodeline": "value ? (value[0] ? value : \"(empty)\") : \"(null)\");"
    },
    {
        "line": 79,
        "fullcodeline": "parser->description ? parser->description"
    },
    {
        "line": 12,
        "fullcodeline": "cstr_s n = {.len = ++parser->unnamed_count};"
    },
    {
        "line": 13,
        "fullcodeline": "fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);"
    },
    {
        "line": 29,
        "fullcodeline": "value = \"1\";"
    },
    {
        "line": 51,
        "fullcodeline": "while (n.data[0] == '-') {"
    },
    {
        "line": 68,
        "fullcodeline": "value == parser->argv[parser->pos + 1])"
    },
    {
        "line": 69,
        "fullcodeline": "++parser->pos;"
    },
    {
        "line": 94,
        "fullcodeline": "type = (char *)FIO_CLI_STRING__TYPE_I;"
    },
    {
        "line": 111,
        "fullcodeline": "int alias_count = 0;"
    },
    {
        "line": 112,
        "fullcodeline": "int first_len = 0;"
    },
    {
        "line": 113,
        "fullcodeline": "size_t tmp = 0;"
    },
    {
        "line": 114,
        "fullcodeline": "char const *const p = *pos;"
    },
    {
        "line": 140,
        "fullcodeline": "tmp = first_len;"
    },
    {
        "line": 173,
        "fullcodeline": "++pos;"
    },
    {
        "line": 5,
        "fullcodeline": "if (!value) {"
    },
    {
        "line": 8,
        "fullcodeline": "if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||"
    },
    {
        "line": 14,
        "fullcodeline": "if (parser->unnamed_max >= 0 &&"
    },
    {
        "line": 26,
        "fullcodeline": "if (value && value != parser->argv[parser->pos + 1]) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (!value)"
    },
    {
        "line": 43,
        "fullcodeline": "if (!value[0])"
    },
    {
        "line": 55,
        "fullcodeline": "fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);"
    },
    {
        "line": 59,
        "fullcodeline": "n.data += n.len;"
    },
    {
        "line": 60,
        "fullcodeline": "n.len = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "switch ((intptr_t)*pos) {"
    },
    {
        "line": 95,
        "fullcodeline": "switch ((intptr_t)pos[1]) {"
    },
    {
        "line": 115,
        "fullcodeline": "while (p[tmp] == '-') {"
    },
    {
        "line": 126,
        "fullcodeline": "switch ((size_t)type) {"
    },
    {
        "line": 141,
        "fullcodeline": "while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {"
    },
    {
        "line": 144,
        "fullcodeline": "while (p[tmp] == '-') {"
    },
    {
        "line": 9,
        "fullcodeline": "!strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {"
    },
    {
        "line": 15,
        "fullcodeline": "parser->unnamed_count > parser->unnamed_max) {"
    },
    {
        "line": 16,
        "fullcodeline": "arg.len = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "char const *tmp = value;"
    },
    {
        "line": 34,
        "fullcodeline": "fio_atol((char **)&tmp);"
    },
    {
        "line": 52,
        "fullcodeline": "while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {"
    },
    {
        "line": 56,
        "fullcodeline": "while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {"
    },
    {
        "line": 91,
        "fullcodeline": "++pos;"
    },
    {
        "line": 97,
        "fullcodeline": "fprintf(stderr, \"%s\\n\", pos[0]);"
    },
    {
        "line": 98,
        "fullcodeline": "pos += 2;"
    },
    {
        "line": 101,
        "fullcodeline": "fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);"
    },
    {
        "line": 102,
        "fullcodeline": "pos += 2;"
    },
    {
        "line": 108,
        "fullcodeline": "type = pos[1];"
    },
    {
        "line": 121,
        "fullcodeline": "++alias_count;"
    },
    {
        "line": 128,
        "fullcodeline": "fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,"
    },
    {
        "line": 132,
        "fullcodeline": "fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);"
    },
    {
        "line": 135,
        "fullcodeline": "fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,"
    },
    {
        "line": 142,
        "fullcodeline": "++tmp;"
    },
    {
        "line": 145,
        "fullcodeline": "const size_t start = tmp;"
    },
    {
        "line": 149,
        "fullcodeline": "int padding = first_len - (tmp - start);"
    },
    {
        "line": 53,
        "fullcodeline": "++n.len;"
    },
    {
        "line": 57,
        "fullcodeline": "++n.len;"
    },
    {
        "line": 116,
        "fullcodeline": "while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {"
    },
    {
        "line": 122,
        "fullcodeline": "while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {"
    },
    {
        "line": 129,
        "fullcodeline": "p, p + tmp);"
    },
    {
        "line": 136,
        "fullcodeline": "p, p + tmp);"
    },
    {
        "line": 146,
        "fullcodeline": "while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {"
    },
    {
        "line": 150,
        "fullcodeline": "if (padding < 0)"
    },
    {
        "line": 152,
        "fullcodeline": "switch ((size_t)type) {"
    },
    {
        "line": 119,
        "fullcodeline": "++tmp;"
    },
    {
        "line": 123,
        "fullcodeline": "++tmp;"
    },
    {
        "line": 147,
        "fullcodeline": "++tmp;"
    },
    {
        "line": 151,
        "fullcodeline": "padding = 0;"
    },
    {
        "line": 154,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 160,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 165,
        "fullcodeline": "fprintf(stderr,"
    },
    {
        "line": 117,
        "fullcodeline": "if (!alias_count)"
    },
    {
        "line": 157,
        "fullcodeline": "(int)(tmp - start), p + start, padding, \"\", first_len, p);"
    },
    {
        "line": 162,
        "fullcodeline": "(int)(tmp - start), p + start, padding, \"\", first_len, p);"
    },
    {
        "line": 168,
        "fullcodeline": "(int)(tmp - start), p + start, padding, \"\", first_len, p);"
    },
    {
        "line": 118,
        "fullcodeline": "++first_len;"
    }
]