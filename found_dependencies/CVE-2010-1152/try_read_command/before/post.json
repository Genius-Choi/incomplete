[
    {
        "line": 2,
        "fullcodeline": "assert(c != NULL);"
    },
    {
        "line": 3,
        "fullcodeline": "assert(c->rcurr <= (c->rbuf + c->rsize));"
    },
    {
        "line": 4,
        "fullcodeline": "assert(c->rbytes > 0);"
    },
    {
        "line": 6,
        "fullcodeline": "if (c->protocol == negotiating_prot || c->transport == udp_transport)  {"
    },
    {
        "line": 19,
        "fullcodeline": "if (c->protocol == binary_prot) {"
    },
    {
        "line": 7,
        "fullcodeline": "if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {"
    },
    {
        "line": 13,
        "fullcodeline": "if (settings.verbose > 1) {"
    },
    {
        "line": 21,
        "fullcodeline": "if (c->rbytes < sizeof(c->binary_header)) {"
    },
    {
        "line": 90,
        "fullcodeline": "el = memchr(c->rcurr, '\\n', c->rbytes);"
    },
    {
        "line": 110,
        "fullcodeline": "cont = el + 1;"
    },
    {
        "line": 114,
        "fullcodeline": "*el = '\\0';"
    },
    {
        "line": 116,
        "fullcodeline": "assert(cont <= (c->rcurr + c->rbytes));"
    },
    {
        "line": 118,
        "fullcodeline": "process_command(c, c->rcurr);"
    },
    {
        "line": 120,
        "fullcodeline": "c->rbytes -= (cont - c->rcurr);"
    },
    {
        "line": 121,
        "fullcodeline": "c->rcurr = cont;"
    },
    {
        "line": 123,
        "fullcodeline": "assert(c->rcurr <= (c->rbuf + c->rsize));"
    },
    {
        "line": 8,
        "fullcodeline": "c->protocol = binary_prot;"
    },
    {
        "line": 14,
        "fullcodeline": "fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,"
    },
    {
        "line": 87,
        "fullcodeline": "if (c->rbytes == 0)"
    },
    {
        "line": 91,
        "fullcodeline": "if (!el) {"
    },
    {
        "line": 111,
        "fullcodeline": "if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"
    },
    {
        "line": 10,
        "fullcodeline": "c->protocol = ascii_prot;"
    },
    {
        "line": 15,
        "fullcodeline": "prot_text(c->protocol));"
    },
    {
        "line": 36,
        "fullcodeline": "req = (protocol_binary_request_header*)c->rcurr;"
    },
    {
        "line": 52,
        "fullcodeline": "c->binary_header.request.keylen = ntohs(req->request.keylen);"
    },
    {
        "line": 53,
        "fullcodeline": "c->binary_header.request.bodylen = ntohl(req->request.bodylen);"
    },
    {
        "line": 54,
        "fullcodeline": "c->binary_header.request.cas = ntohll(req->request.cas);"
    },
    {
        "line": 65,
        "fullcodeline": "c->msgcurr = 0;"
    },
    {
        "line": 66,
        "fullcodeline": "c->msgused = 0;"
    },
    {
        "line": 67,
        "fullcodeline": "c->iovused = 0;"
    },
    {
        "line": 77,
        "fullcodeline": "c->cas = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "dispatch_bin_command(c);"
    },
    {
        "line": 81,
        "fullcodeline": "c->rbytes -= sizeof(c->binary_header);"
    },
    {
        "line": 82,
        "fullcodeline": "c->rcurr += sizeof(c->binary_header);"
    },
    {
        "line": 112,
        "fullcodeline": "el--;"
    },
    {
        "line": 38,
        "fullcodeline": "if (settings.verbose > 1) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {"
    },
    {
        "line": 68,
        "fullcodeline": "if (add_msghdr(c) != 0) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (c->rbytes > 1024) {"
    },
    {
        "line": 41,
        "fullcodeline": "fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);"
    },
    {
        "line": 48,
        "fullcodeline": "fprintf(stderr, \"\\n\");"
    },
    {
        "line": 61,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 69,
        "fullcodeline": "out_string(c, \"SERVER_ERROR out of memory\");"
    },
    {
        "line": 97,
        "fullcodeline": "char *ptr = c->rcurr;"
    },
    {
        "line": 42,
        "fullcodeline": "for (ii = 0; ii < sizeof(req->bytes); ++ii) {"
    },
    {
        "line": 62,
        "fullcodeline": "return -1;"
    },
    {
        "line": 98,
        "fullcodeline": "while (*ptr == ' ') { /* ignore leading whitespaces */"
    },
    {
        "line": 102,
        "fullcodeline": "if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {"
    },
    {
        "line": 46,
        "fullcodeline": "fprintf(stderr, \" 0x%02x\", req->bytes[ii]);"
    },
    {
        "line": 58,
        "fullcodeline": "fprintf(stderr, \"Invalid magic:  %x\\n\","
    },
    {
        "line": 99,
        "fullcodeline": "++ptr;"
    },
    {
        "line": 103,
        "fullcodeline": "conn_set_state(c, conn_closing);"
    },
    {
        "line": 43,
        "fullcodeline": "if (ii % 4 == 0) {"
    },
    {
        "line": 44,
        "fullcodeline": "fprintf(stderr, \"\\n<%d   \", c->sfd);"
    }
]