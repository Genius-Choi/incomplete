[
    {
        "line": 10,
        "fullcodeline": "RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);"
    },
    {
        "line": 36,
        "fullcodeline": "get_decoder_info(&decoder_info);"
    },
    {
        "line": 50,
        "fullcodeline": "imgdata.rawdata.raw_image = 0;"
    },
    {
        "line": 51,
        "fullcodeline": "imgdata.rawdata.color4_image = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "imgdata.rawdata.color3_image = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "imgdata.rawdata.float_image = 0;"
    },
    {
        "line": 54,
        "fullcodeline": "imgdata.rawdata.float3_image = 0;"
    },
    {
        "line": 165,
        "fullcodeline": "S.iwidth = save_iwidth;"
    },
    {
        "line": 166,
        "fullcodeline": "S.iheight = save_iheight;"
    },
    {
        "line": 167,
        "fullcodeline": "IO.shrink = save_shrink;"
    },
    {
        "line": 176,
        "fullcodeline": "C.black += i;"
    },
    {
        "line": 181,
        "fullcodeline": "memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));"
    },
    {
        "line": 184,
        "fullcodeline": "SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);"
    },
    {
        "line": 185,
        "fullcodeline": "RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);"
    },
    {
        "line": 14,
        "fullcodeline": "if(!load_raw)"
    },
    {
        "line": 95,
        "fullcodeline": "if(!raw_was_read()) //RawSpeed failed or not run"
    },
    {
        "line": 172,
        "fullcodeline": "for(c=0;c<3;c++)"
    },
    {
        "line": 174,
        "fullcodeline": "for (c=0;c<4;c++)"
    },
    {
        "line": 175,
        "fullcodeline": "C.cblack[c] -= i;"
    },
    {
        "line": 190,
        "fullcodeline": "EXCEPTION_HANDLER(err);"
    },
    {
        "line": 21,
        "fullcodeline": "imgdata.image = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "imgdata.rawdata.raw_alloc = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "libraw_internal_data.internal_data.meta_data ="
    },
    {
        "line": 32,
        "fullcodeline": "merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");"
    },
    {
        "line": 98,
        "fullcodeline": "int zero_rawimage = 0;"
    },
    {
        "line": 128,
        "fullcodeline": "ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);"
    },
    {
        "line": 162,
        "fullcodeline": "crop_masked_pixels(); // calculate black levels"
    },
    {
        "line": 173,
        "fullcodeline": "if (i > C.cblack[c]) i = C.cblack[c];"
    },
    {
        "line": 31,
        "fullcodeline": "(char *) malloc (libraw_internal_data.unpacker_data.meta_length);"
    },
    {
        "line": 44,
        "fullcodeline": "if(rwidth < S.width + S.left_margin)"
    },
    {
        "line": 46,
        "fullcodeline": "if(rheight < S.height + S.top_margin)"
    },
    {
        "line": 99,
        "fullcodeline": "if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)"
    },
    {
        "line": 131,
        "fullcodeline": "if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))"
    },
    {
        "line": 136,
        "fullcodeline": "if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))"
    },
    {
        "line": 138,
        "fullcodeline": "if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)"
    },
    {
        "line": 132,
        "fullcodeline": "C.maximum=65535;"
    },
    {
        "line": 135,
        "fullcodeline": "imgdata.rawdata.raw_image = 0;"
    },
    {
        "line": 137,
        "fullcodeline": "C.maximum = m_save;"
    },
    {
        "line": 104,
        "fullcodeline": "else if(imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image"
    },
    {
        "line": 143,
        "fullcodeline": "else if (!(imgdata.idata.filters || P1.colors == 1) ) // legacy decoder, ownalloc handled above"
    },
    {
        "line": 106,
        "fullcodeline": "imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]));"
    },
    {
        "line": 107,
        "fullcodeline": "imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;"
    },
    {
        "line": 146,
        "fullcodeline": "imgdata.rawdata.raw_alloc = imgdata.image;"
    },
    {
        "line": 147,
        "fullcodeline": "imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;"
    },
    {
        "line": 148,
        "fullcodeline": "imgdata.image = 0;"
    },
    {
        "line": 116,
        "fullcodeline": "IO.shrink = 0;"
    },
    {
        "line": 120,
        "fullcodeline": "imgdata.rawdata.raw_alloc = 0;"
    },
    {
        "line": 121,
        "fullcodeline": "imgdata.image = (ushort (*)[4]) calloc(unsigned(S.raw_width)*unsigned(S.raw_height),sizeof(*imgdata.image));"
    },
    {
        "line": 151,
        "fullcodeline": "if(!(libraw_internal_data.unpacker_data.load_flags & 256))"
    },
    {
        "line": 109,
        "fullcodeline": "S.raw_pitch = S.raw_width*2; // Bayer case, not set before"
    },
    {
        "line": 122,
        "fullcodeline": "if(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))"
    },
    {
        "line": 153,
        "fullcodeline": "S.raw_width = S.width;"
    },
    {
        "line": 154,
        "fullcodeline": "S.left_margin = 0;"
    },
    {
        "line": 156,
        "fullcodeline": "S.top_margin = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "S.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;"
    },
    {
        "line": 124,
        "fullcodeline": "imgdata.rawdata.raw_image = (ushort*) imgdata.image ;"
    },
    {
        "line": 125,
        "fullcodeline": "zero_rawimage = 1;"
    }
]