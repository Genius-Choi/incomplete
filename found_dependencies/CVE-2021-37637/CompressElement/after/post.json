[
    {
        "line": 5,
        "fullcodeline": "std::vector<TensorProto> non_memcpy_components;"
    },
    {
        "line": 6,
        "fullcodeline": "int64 total_size = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "uncompressed.resize_uninitialized(total_size);"
    },
    {
        "line": 25,
        "fullcodeline": "char* position = uncompressed.mdata();"
    },
    {
        "line": 26,
        "fullcodeline": "int non_memcpy_component_index = 0;"
    },
    {
        "line": 45,
        "fullcodeline": "DCHECK_EQ(position, uncompressed.mdata() + total_size);"
    },
    {
        "line": 51,
        "fullcodeline": "VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \""
    },
    {
        "line": 47,
        "fullcodeline": "if (!port::Snappy_Compress(uncompressed.mdata(), total_size,"
    },
    {
        "line": 53,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 28,
        "fullcodeline": "CompressedComponentMetadata* metadata ="
    },
    {
        "line": 30,
        "fullcodeline": "metadata->set_dtype(component.dtype());"
    },
    {
        "line": 31,
        "fullcodeline": "component.shape().AsProto(metadata->mutable_tensor_shape());"
    },
    {
        "line": 43,
        "fullcodeline": "position += metadata->tensor_size_bytes();"
    },
    {
        "line": 52,
        "fullcodeline": "<< out->data().size() << \" bytes\";"
    },
    {
        "line": 8,
        "fullcodeline": "if (DataTypeCanUseMemcpy(component.dtype())) {"
    },
    {
        "line": 29,
        "fullcodeline": "out->mutable_component_metadata()->Add();"
    },
    {
        "line": 32,
        "fullcodeline": "if (DataTypeCanUseMemcpy(component.dtype())) {"
    },
    {
        "line": 48,
        "fullcodeline": "out->mutable_data())) {"
    },
    {
        "line": 49,
        "fullcodeline": "return errors::Internal(\"Failed to compress using snappy.\");"
    },
    {
        "line": 9,
        "fullcodeline": "const TensorBuffer* buffer = DMAHelper::buffer(&component);"
    },
    {
        "line": 33,
        "fullcodeline": "const TensorBuffer* buffer = DMAHelper::buffer(&component);"
    },
    {
        "line": 14,
        "fullcodeline": "non_memcpy_components.emplace_back();"
    },
    {
        "line": 15,
        "fullcodeline": "component.AsProtoTensorContent(&non_memcpy_components.back());"
    },
    {
        "line": 16,
        "fullcodeline": "total_size += non_memcpy_components.back().ByteSizeLong();"
    },
    {
        "line": 39,
        "fullcodeline": "TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];"
    },
    {
        "line": 40,
        "fullcodeline": "proto.SerializeToArray(position, proto.ByteSizeLong());"
    },
    {
        "line": 41,
        "fullcodeline": "metadata->set_tensor_size_bytes(proto.ByteSizeLong());"
    },
    {
        "line": 11,
        "fullcodeline": "total_size += buffer->size();"
    },
    {
        "line": 35,
        "fullcodeline": "memcpy(position, buffer->data(), buffer->size());"
    },
    {
        "line": 36,
        "fullcodeline": "metadata->set_tensor_size_bytes(buffer->size());"
    }
]