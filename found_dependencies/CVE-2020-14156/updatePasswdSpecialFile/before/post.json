[
    {
        "line": 6,
        "fullcodeline": "size_t bytesWritten = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t inBytesLen = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t isUsrFound = false;"
    },
    {
        "line": 9,
        "fullcodeline": "const EVP_CIPHER* cipher = EVP_aes_128_cbc();"
    },
    {
        "line": 10,
        "fullcodeline": "std::vector<uint8_t> dataBuf;"
    },
    {
        "line": 26,
        "fullcodeline": "std::vector<uint8_t> inBytes(inBytesLen);"
    },
    {
        "line": 69,
        "fullcodeline": "std::array<uint8_t, maxKeySize> keyBuff;"
    },
    {
        "line": 70,
        "fullcodeline": "std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);"
    },
    {
        "line": 76,
        "fullcodeline": "keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());"
    },
    {
        "line": 82,
        "fullcodeline": "keyFile.close();"
    },
    {
        "line": 85,
        "fullcodeline": "struct stat st = {};"
    },
    {
        "line": 93,
        "fullcodeline": "std::string pwdFile(passwdFileName);"
    },
    {
        "line": 94,
        "fullcodeline": "std::vector<char> tempFileName(pwdFile.begin(), pwdFile.end());"
    },
    {
        "line": 95,
        "fullcodeline": "std::vector<char> fileTemplate = {'_', '_', 'X', 'X', 'X',"
    },
    {
        "line": 97,
        "fullcodeline": "tempFileName.insert(tempFileName.end(), fileTemplate.begin(),"
    },
    {
        "line": 99,
        "fullcodeline": "int fd = mkstemp((char*)tempFileName.data());"
    },
    {
        "line": 106,
        "fullcodeline": "std::string strTempFileName(tempFileName.data());"
    },
    {
        "line": 110,
        "fullcodeline": "phosphor::user::File temp(fd, strTempFileName, \"w\", true);"
    },
    {
        "line": 125,
        "fullcodeline": "const EVP_MD* digest = EVP_sha256();"
    },
    {
        "line": 126,
        "fullcodeline": "size_t hashLen = EVP_MD_block_size(digest);"
    },
    {
        "line": 127,
        "fullcodeline": "std::vector<uint8_t> hash(hashLen);"
    },
    {
        "line": 128,
        "fullcodeline": "size_t ivLen = EVP_CIPHER_iv_length(cipher);"
    },
    {
        "line": 129,
        "fullcodeline": "std::vector<uint8_t> iv(ivLen);"
    },
    {
        "line": 130,
        "fullcodeline": "std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;"
    },
    {
        "line": 131,
        "fullcodeline": "size_t keyLen = key.size();"
    },
    {
        "line": 132,
        "fullcodeline": "std::array<uint8_t, EVP_MAX_MD_SIZE> mac;"
    },
    {
        "line": 133,
        "fullcodeline": "size_t macLen = mac.size();"
    },
    {
        "line": 158,
        "fullcodeline": "std::vector<uint8_t> outBytes(inBytesLen + EVP_MAX_BLOCK_LENGTH);"
    },
    {
        "line": 159,
        "fullcodeline": "size_t outBytesLen = 0;"
    },
    {
        "line": 172,
        "fullcodeline": "OPENSSL_cleanse(key.data(), keyLen);"
    },
    {
        "line": 175,
        "fullcodeline": "MetaPassStruct metaData = {META_PASSWD_SIG, {0, 0}, 0, 0, 0, 0, 0};"
    },
    {
        "line": 176,
        "fullcodeline": "metaData.hashSize = hashLen;"
    },
    {
        "line": 177,
        "fullcodeline": "metaData.ivSize = ivLen;"
    },
    {
        "line": 178,
        "fullcodeline": "metaData.dataSize = bytesWritten;"
    },
    {
        "line": 179,
        "fullcodeline": "metaData.padSize = outBytesLen - bytesWritten;"
    },
    {
        "line": 180,
        "fullcodeline": "metaData.macSize = macLen;"
    },
    {
        "line": 219,
        "fullcodeline": "OPENSSL_cleanse(iv.data(), ivLen);"
    },
    {
        "line": 14,
        "fullcodeline": "if (readPasswdFileData(dataBuf) != 0)"
    },
    {
        "line": 20,
        "fullcodeline": "if (dataBuf.size() != 0)"
    },
    {
        "line": 27,
        "fullcodeline": "if (inBytesLen != 0)"
    },
    {
        "line": 62,
        "fullcodeline": "if (!isUsrFound)"
    },
    {
        "line": 71,
        "fullcodeline": "if (!keyFile.good())"
    },
    {
        "line": 77,
        "fullcodeline": "if (keyFile.fail())"
    },
    {
        "line": 86,
        "fullcodeline": "if (stat(passwdFileName, &st) != 0)"
    },
    {
        "line": 98,
        "fullcodeline": "fileTemplate.end());"
    },
    {
        "line": 100,
        "fullcodeline": "if (fd == -1)"
    },
    {
        "line": 111,
        "fullcodeline": "if ((temp)() == NULL)"
    },
    {
        "line": 119,
        "fullcodeline": "if (fchmod(fileno((temp)()), st.st_mode) < 0)"
    },
    {
        "line": 137,
        "fullcodeline": "if (RAND_bytes(hash.data(), hashLen) != 1)"
    },
    {
        "line": 142,
        "fullcodeline": "if (NULL == HMAC(digest, keyBuff.data(), keyBuff.size(), hash.data(),"
    },
    {
        "line": 151,
        "fullcodeline": "if (RAND_bytes(iv.data(), ivLen) != 1)"
    },
    {
        "line": 160,
        "fullcodeline": "if (inBytesLen != 0)"
    },
    {
        "line": 182,
        "fullcodeline": "if (fwrite(&metaData, 1, sizeof(metaData), (temp)()) != sizeof(metaData))"
    },
    {
        "line": 188,
        "fullcodeline": "if (fwrite(&hash[0], 1, hashLen, (temp)()) != hashLen)"
    },
    {
        "line": 194,
        "fullcodeline": "if (fwrite(&iv[0], 1, ivLen, (temp)()) != ivLen)"
    },
    {
        "line": 200,
        "fullcodeline": "if (fwrite(&outBytes[0], 1, outBytesLen, (temp)()) != outBytesLen)"
    },
    {
        "line": 206,
        "fullcodeline": "if (fwrite(&mac[0], 1, macLen, (temp)()) != macLen)"
    },
    {
        "line": 212,
        "fullcodeline": "if (fflush((temp)()))"
    },
    {
        "line": 222,
        "fullcodeline": "if (std::rename(strTempFileName.data(), passwdFileName) != 0)"
    },
    {
        "line": 16,
        "fullcodeline": "log<level::DEBUG>(\"Error in reading the encrypted pass file\");"
    },
    {
        "line": 22,
        "fullcodeline": "inBytesLen ="
    },
    {
        "line": 29,
        "fullcodeline": "char* outPtr = reinterpret_cast<char*>(dataBuf.data());"
    },
    {
        "line": 30,
        "fullcodeline": "char* nToken = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);"
    },
    {
        "line": 60,
        "fullcodeline": "inBytesLen = bytesWritten;"
    },
    {
        "line": 64,
        "fullcodeline": "log<level::DEBUG>(\"User doesn't exist\");"
    },
    {
        "line": 73,
        "fullcodeline": "log<level::DEBUG>(\"Error in opening encryption key file\");"
    },
    {
        "line": 79,
        "fullcodeline": "log<level::DEBUG>(\"Error in reading encryption key file\");"
    },
    {
        "line": 88,
        "fullcodeline": "log<level::DEBUG>(\"Error in getting password file fstat()\");"
    },
    {
        "line": 102,
        "fullcodeline": "log<level::DEBUG>(\"Error creating temp file\");"
    },
    {
        "line": 113,
        "fullcodeline": "close(fd);"
    },
    {
        "line": 114,
        "fullcodeline": "log<level::DEBUG>(\"Error creating temp file\");"
    },
    {
        "line": 121,
        "fullcodeline": "log<level::DEBUG>(\"Error setting fchmod for temp file\");"
    },
    {
        "line": 139,
        "fullcodeline": "log<level::DEBUG>(\"Hash genertion failed, bailing out\");"
    },
    {
        "line": 146,
        "fullcodeline": "log<level::DEBUG>(\"Failed to create MAC for authentication\");"
    },
    {
        "line": 153,
        "fullcodeline": "log<level::DEBUG>(\"UV genertion failed, bailing out\");"
    },
    {
        "line": 170,
        "fullcodeline": "outBytes[outBytesLen] = 0;"
    },
    {
        "line": 184,
        "fullcodeline": "log<level::DEBUG>(\"Error in writing meta data\");"
    },
    {
        "line": 190,
        "fullcodeline": "log<level::DEBUG>(\"Error in writing hash data\");"
    },
    {
        "line": 196,
        "fullcodeline": "log<level::DEBUG>(\"Error in writing IV data\");"
    },
    {
        "line": 202,
        "fullcodeline": "log<level::DEBUG>(\"Error in writing encrypted data\");"
    },
    {
        "line": 208,
        "fullcodeline": "log<level::DEBUG>(\"Error in writing MAC data\");"
    },
    {
        "line": 214,
        "fullcodeline": "log<level::DEBUG>("
    },
    {
        "line": 224,
        "fullcodeline": "log<level::DEBUG>(\"Failed to rename tmp file to ipmi-pass\");"
    },
    {
        "line": 17,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 23,
        "fullcodeline": "dataBuf.size() + newUserName.size() + EVP_CIPHER_block_size(cipher);"
    },
    {
        "line": 32,
        "fullcodeline": "while (linePtr != NULL)"
    },
    {
        "line": 74,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 80,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 89,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 103,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 115,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 122,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 140,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 143,
        "fullcodeline": "hashLen, key.data(),"
    },
    {
        "line": 144,
        "fullcodeline": "reinterpret_cast<unsigned int*>(&keyLen)))"
    },
    {
        "line": 147,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 154,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 162,
        "fullcodeline": "if (encryptDecryptData(true, EVP_aes_128_cbc(), key.data(), keyLen,"
    },
    {
        "line": 185,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 191,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 197,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 203,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 209,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 216,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 225,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 34,
        "fullcodeline": "size_t userEPos = 0;"
    },
    {
        "line": 36,
        "fullcodeline": "std::string lineStr(linePtr);"
    },
    {
        "line": 58,
        "fullcodeline": "linePtr = strtok_r(NULL, \"\\n\", &nToken);"
    },
    {
        "line": 167,
        "fullcodeline": "log<level::DEBUG>(\"Error while encrypting the data\");"
    },
    {
        "line": 37,
        "fullcodeline": "if ((userEPos = lineStr.find(\":\")) != std::string::npos)"
    },
    {
        "line": 163,
        "fullcodeline": "iv.data(), ivLen, inBytes.data(), inBytesLen,"
    },
    {
        "line": 164,
        "fullcodeline": "mac.data(), &macLen, outBytes.data(),"
    },
    {
        "line": 168,
        "fullcodeline": "return -EIO;"
    },
    {
        "line": 39,
        "fullcodeline": "if (userName.compare(lineStr.substr(0, userEPos)) == 0)"
    },
    {
        "line": 41,
        "fullcodeline": "isUsrFound = true;"
    },
    {
        "line": 42,
        "fullcodeline": "if (!newUserName.empty())"
    },
    {
        "line": 53,
        "fullcodeline": "bytesWritten += std::snprintf("
    },
    {
        "line": 44,
        "fullcodeline": "bytesWritten += std::snprintf("
    },
    {
        "line": 54,
        "fullcodeline": "reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,"
    },
    {
        "line": 55,
        "fullcodeline": "(inBytesLen - bytesWritten), \"%s\\n\", lineStr.data());"
    },
    {
        "line": 45,
        "fullcodeline": "reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,"
    },
    {
        "line": 46,
        "fullcodeline": "(inBytesLen - bytesWritten), \"%s%s\\n\","
    },
    {
        "line": 47,
        "fullcodeline": "newUserName.c_str(),"
    },
    {
        "line": 48,
        "fullcodeline": "lineStr.substr(userEPos, lineStr.size()).data());"
    }
]