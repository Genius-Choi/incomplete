[
    {
        "line": 3,
        "fullcodeline": "mp4object *mp4 = (mp4object *)handle;"
    },
    {
        "line": 6,
        "fullcodeline": "GPMF_stream metadata_stream, *ms = &metadata_stream;"
    },
    {
        "line": 7,
        "fullcodeline": "uint32_t teststart = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "double rate = 0.0;"
    },
    {
        "line": 18,
        "fullcodeline": "payload = GetPayload(handle, NULL, teststart);"
    },
    {
        "line": 19,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, teststart);"
    },
    {
        "line": 20,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 4,
        "fullcodeline": "if (mp4 == NULL) return 0.0;"
    },
    {
        "line": 15,
        "fullcodeline": "if (mp4->indexcount < 1)"
    },
    {
        "line": 22,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 26,
        "fullcodeline": "uint64_t minimumtimestamp = 0;"
    },
    {
        "line": 27,
        "fullcodeline": "uint64_t starttimestamp = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "uint64_t endtimestamp = 0;"
    },
    {
        "line": 29,
        "fullcodeline": "uint32_t startsamples = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "uint32_t endsamples = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "double intercept = 0.0;"
    },
    {
        "line": 35,
        "fullcodeline": "while (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 43,
        "fullcodeline": "if (ret == GPMF_OK && payload)"
    },
    {
        "line": 37,
        "fullcodeline": "teststart++;"
    },
    {
        "line": 38,
        "fullcodeline": "payload = GetPayload(handle, payload, teststart); // second last payload"
    },
    {
        "line": 39,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, teststart);"
    },
    {
        "line": 40,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 45,
        "fullcodeline": "uint32_t samples = GPMF_PayloadSampleCount(ms);"
    },
    {
        "line": 47,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 51,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 69,
        "fullcodeline": "testend = mp4->indexcount;"
    },
    {
        "line": 78,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 48,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 52,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 76,
        "fullcodeline": "} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));"
    },
    {
        "line": 79,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 94,
        "fullcodeline": "if (starttimestamp != 0)"
    },
    {
        "line": 127,
        "fullcodeline": "if (rate == 0.0) //Timestamps didn't help weren't available"
    },
    {
        "line": 49,
        "fullcodeline": "startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;"
    },
    {
        "line": 53,
        "fullcodeline": "starttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));"
    },
    {
        "line": 58,
        "fullcodeline": "GPMF_Init(&any_stream, payload, payloadsize);"
    },
    {
        "line": 60,
        "fullcodeline": "minimumtimestamp = starttimestamp;"
    },
    {
        "line": 72,
        "fullcodeline": "testend--;// last payload with the fourcc needed"
    },
    {
        "line": 73,
        "fullcodeline": "payload = GetPayload(handle, payload, testend);"
    },
    {
        "line": 74,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, testend);"
    },
    {
        "line": 80,
        "fullcodeline": "endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));"
    },
    {
        "line": 96,
        "fullcodeline": "uint32_t last_samples = GPMF_PayloadSampleCount(ms);"
    },
    {
        "line": 97,
        "fullcodeline": "uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;"
    },
    {
        "line": 98,
        "fullcodeline": "double time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10."
    },
    {
        "line": 100,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 246,
        "fullcodeline": "uint32_t endpayload = mp4->indexcount;"
    },
    {
        "line": 61,
        "fullcodeline": "while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 75,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 101,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 63,
        "fullcodeline": "uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));"
    },
    {
        "line": 84,
        "fullcodeline": "for (i = teststart; i <= testend; i++)"
    },
    {
        "line": 102,
        "fullcodeline": "endtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));"
    },
    {
        "line": 106,
        "fullcodeline": "double approxrate = 0.0;"
    },
    {
        "line": 123,
        "fullcodeline": "intercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;"
    },
    {
        "line": 129,
        "fullcodeline": "if (!(flags & GPMF_SAMPLE_RATE_PRECISE))"
    },
    {
        "line": 249,
        "fullcodeline": "endpayload--;// last payload with the fourcc needed"
    },
    {
        "line": 250,
        "fullcodeline": "payload = GetPayload(handle, payload, endpayload);"
    },
    {
        "line": 251,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, endpayload);"
    },
    {
        "line": 252,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 253,
        "fullcodeline": "} while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));"
    },
    {
        "line": 255,
        "fullcodeline": "if (endpayload > 0 && ret == GPMF_OK)"
    },
    {
        "line": 257,
        "fullcodeline": "uint32_t totalsamples = endsamples - startsamples;"
    },
    {
        "line": 258,
        "fullcodeline": "float timo = 0.0;"
    },
    {
        "line": 260,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream);"
    },
    {
        "line": 265,
        "fullcodeline": "first = -intercept / rate - timo;"
    },
    {
        "line": 266,
        "fullcodeline": "last = first + (double)totalsamples / rate;"
    },
    {
        "line": 64,
        "fullcodeline": "if (timestamp < minimumtimestamp)"
    },
    {
        "line": 86,
        "fullcodeline": "payload = GetPayload(handle,payload, i); // second last payload"
    },
    {
        "line": 87,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, i);"
    },
    {
        "line": 107,
        "fullcodeline": "if (endsamples > startsamples)"
    },
    {
        "line": 110,
        "fullcodeline": "if (approxrate == 0.0)"
    },
    {
        "line": 114,
        "fullcodeline": "while (time_stamp_scale >= 1)"
    },
    {
        "line": 122,
        "fullcodeline": "if (time_stamp_scale < 1.0) rate = 0.0;"
    },
    {
        "line": 131,
        "fullcodeline": "if (endsamples > startsamples)"
    },
    {
        "line": 134,
        "fullcodeline": "if (rate == 0.0)"
    },
    {
        "line": 138,
        "fullcodeline": "if (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))"
    },
    {
        "line": 143,
        "fullcodeline": "uint32_t payloadpos = 0, payloadcount = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;"
    },
    {
        "line": 145,
        "fullcodeline": "uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);"
    },
    {
        "line": 146,
        "fullcodeline": "memset(repeatarray, 0, mp4->indexcount * 4 + 4);"
    },
    {
        "line": 148,
        "fullcodeline": "samples = 0;"
    },
    {
        "line": 65,
        "fullcodeline": "minimumtimestamp = timestamp;"
    },
    {
        "line": 88,
        "fullcodeline": "if (GPMF_OK == GPMF_Init(ms, payload, payloadsize))"
    },
    {
        "line": 108,
        "fullcodeline": "approxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 111,
        "fullcodeline": "approxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 116,
        "fullcodeline": "rate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);"
    },
    {
        "line": 120,
        "fullcodeline": "time_stamp_scale *= 0.1;"
    },
    {
        "line": 132,
        "fullcodeline": "rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 135,
        "fullcodeline": "rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 139,
        "fullcodeline": "intercept = (double)-in * rate;"
    },
    {
        "line": 150,
        "fullcodeline": "for (payloadpos = teststart; payloadpos <= testend; payloadpos++)"
    },
    {
        "line": 261,
        "fullcodeline": "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))"
    },
    {
        "line": 262,
        "fullcodeline": "GPMF_FormattedData(&find_stream, &timo, 4, 0, 1);"
    },
    {
        "line": 152,
        "fullcodeline": "payload = GetPayload(handle, payload, payloadpos); // second last payload"
    },
    {
        "line": 153,
        "fullcodeline": "payloadsize = GetPayloadSize(handle, payloadpos);"
    },
    {
        "line": 154,
        "fullcodeline": "ret = GPMF_Init(ms, payload, payloadsize);"
    },
    {
        "line": 212,
        "fullcodeline": "meanY /= (double)payloadcount;"
    },
    {
        "line": 213,
        "fullcodeline": "meanX /= (double)payloadcount;"
    },
    {
        "line": 225,
        "fullcodeline": "slope = top / bot;"
    },
    {
        "line": 226,
        "fullcodeline": "rate = slope;"
    },
    {
        "line": 229,
        "fullcodeline": "intercept = meanY - slope * meanX;"
    },
    {
        "line": 89,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 117,
        "fullcodeline": "if (rate*0.9 < approxrate && approxrate < rate*1.1)"
    },
    {
        "line": 156,
        "fullcodeline": "if (ret != GPMF_OK)"
    },
    {
        "line": 159,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))"
    },
    {
        "line": 215,
        "fullcodeline": "for (payloadpos = teststart; payloadpos <= testend; payloadpos++)"
    },
    {
        "line": 237,
        "fullcodeline": "rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);"
    },
    {
        "line": 90,
        "fullcodeline": "endsamples += GPMF_PayloadSampleCount(ms);"
    },
    {
        "line": 162,
        "fullcodeline": "GPMF_CopyState(ms, &find_stream2);"
    },
    {
        "line": 164,
        "fullcodeline": "payloadcount++;"
    },
    {
        "line": 166,
        "fullcodeline": "if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats"
    },
    {
        "line": 203,
        "fullcodeline": "repeatarray[payloadpos] = 0;"
    },
    {
        "line": 218,
        "fullcodeline": "if (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))"
    },
    {
        "line": 220,
        "fullcodeline": "top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);"
    },
    {
        "line": 221,
        "fullcodeline": "bot += ((double)out - meanX)*((double)out - meanX);"
    },
    {
        "line": 186,
        "fullcodeline": "uint32_t repeat = GPMF_PayloadSampleCount(ms);"
    },
    {
        "line": 187,
        "fullcodeline": "samples += repeat;"
    },
    {
        "line": 177,
        "fullcodeline": "repeatarray[payloadpos] = samples;"
    },
    {
        "line": 178,
        "fullcodeline": "meanY += (double)samples;"
    },
    {
        "line": 175,
        "fullcodeline": "} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));"
    },
    {
        "line": 180,
        "fullcodeline": "if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))"
    },
    {
        "line": 193,
        "fullcodeline": "repeatarray[payloadpos] = samples;"
    },
    {
        "line": 194,
        "fullcodeline": "meanY += (double)samples;"
    },
    {
        "line": 174,
        "fullcodeline": "samples++;"
    },
    {
        "line": 181,
        "fullcodeline": "meanX += out;"
    },
    {
        "line": 196,
        "fullcodeline": "if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))"
    },
    {
        "line": 197,
        "fullcodeline": "meanX += out;"
    }
]