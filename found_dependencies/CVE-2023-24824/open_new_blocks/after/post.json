[
    {
        "line": 4,
        "fullcodeline": "cmark_list *data = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "bool maybe_lazy = S_type(parser->current) == CMARK_NODE_PARAGRAPH;"
    },
    {
        "line": 6,
        "fullcodeline": "cmark_node_type cont_type = S_type(*container);"
    },
    {
        "line": 7,
        "fullcodeline": "bufsize_t matched = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int lev = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "while (cont_type != CMARK_NODE_CODE_BLOCK &&"
    },
    {
        "line": 15,
        "fullcodeline": "cont_type != CMARK_NODE_HTML_BLOCK) {"
    },
    {
        "line": 17,
        "fullcodeline": "S_find_first_nonspace(parser, input);"
    },
    {
        "line": 18,
        "fullcodeline": "indented = parser->indent >= CODE_INDENT;"
    },
    {
        "line": 212,
        "fullcodeline": "cont_type = S_type(*container);"
    },
    {
        "line": 213,
        "fullcodeline": "maybe_lazy = false;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!indented && peek_at(input, parser->first_nonspace) == '>') {"
    },
    {
        "line": 207,
        "fullcodeline": "if (accepts_lines(S_type(*container))) {"
    },
    {
        "line": 22,
        "fullcodeline": "bufsize_t blockquote_startpos = parser->first_nonspace;"
    },
    {
        "line": 24,
        "fullcodeline": "S_advance_offset(parser, input,"
    },
    {
        "line": 30,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_BLOCK_QUOTE,"
    },
    {
        "line": 25,
        "fullcodeline": "parser->first_nonspace + 1 - parser->offset, false);"
    },
    {
        "line": 27,
        "fullcodeline": "if (S_is_space_or_tab(peek_at(input, parser->offset))) {"
    },
    {
        "line": 28,
        "fullcodeline": "S_advance_offset(parser, input, 1, true);"
    },
    {
        "line": 31,
        "fullcodeline": "blockquote_startpos + 1);"
    },
    {
        "line": 33,
        "fullcodeline": "} else if (!indented && (matched = scan_atx_heading_start("
    },
    {
        "line": 36,
        "fullcodeline": "int level = 0;"
    },
    {
        "line": 37,
        "fullcodeline": "bufsize_t heading_startpos = parser->first_nonspace;"
    },
    {
        "line": 39,
        "fullcodeline": "S_advance_offset(parser, input,"
    },
    {
        "line": 42,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_HEADING,"
    },
    {
        "line": 45,
        "fullcodeline": "hashpos = cmark_chunk_strchr(input, '#', parser->first_nonspace);"
    },
    {
        "line": 52,
        "fullcodeline": "(*container)->as.heading.level = level;"
    },
    {
        "line": 53,
        "fullcodeline": "(*container)->as.heading.setext = false;"
    },
    {
        "line": 54,
        "fullcodeline": "(*container)->internal_offset = matched;"
    },
    {
        "line": 40,
        "fullcodeline": "parser->first_nonspace + matched - parser->offset,"
    },
    {
        "line": 47,
        "fullcodeline": "while (peek_at(input, hashpos) == '#') {"
    },
    {
        "line": 43,
        "fullcodeline": "heading_startpos + 1);"
    },
    {
        "line": 48,
        "fullcodeline": "level++;"
    },
    {
        "line": 49,
        "fullcodeline": "hashpos++;"
    },
    {
        "line": 56,
        "fullcodeline": "} else if (!indented && (matched = scan_open_code_fence("
    },
    {
        "line": 58,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_CODE_BLOCK,"
    },
    {
        "line": 60,
        "fullcodeline": "(*container)->as.code.fenced = true;"
    },
    {
        "line": 61,
        "fullcodeline": "(*container)->as.code.fence_char = peek_at(input, parser->first_nonspace);"
    },
    {
        "line": 62,
        "fullcodeline": "(*container)->as.code.fence_length = (matched > 255) ? 255 : (uint8_t)matched;"
    },
    {
        "line": 63,
        "fullcodeline": "(*container)->as.code.fence_offset ="
    },
    {
        "line": 65,
        "fullcodeline": "(*container)->as.code.info = cmark_chunk_literal(\"\");"
    },
    {
        "line": 66,
        "fullcodeline": "S_advance_offset(parser, input,"
    },
    {
        "line": 64,
        "fullcodeline": "(int8_t)(parser->first_nonspace - parser->offset);"
    },
    {
        "line": 67,
        "fullcodeline": "parser->first_nonspace + matched - parser->offset,"
    },
    {
        "line": 59,
        "fullcodeline": "parser->first_nonspace + 1);"
    },
    {
        "line": 70,
        "fullcodeline": "} else if (!indented && ((matched = scan_html_block_start("
    },
    {
        "line": 75,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_HTML_BLOCK,"
    },
    {
        "line": 77,
        "fullcodeline": "(*container)->as.html_block_type = matched;"
    },
    {
        "line": 72,
        "fullcodeline": "(cont_type != CMARK_NODE_PARAGRAPH &&"
    },
    {
        "line": 73,
        "fullcodeline": "(matched = scan_html_block_start_7("
    },
    {
        "line": 76,
        "fullcodeline": "parser->first_nonspace + 1);"
    },
    {
        "line": 80,
        "fullcodeline": "} else if (!indented && cont_type == CMARK_NODE_PARAGRAPH &&"
    },
    {
        "line": 81,
        "fullcodeline": "(lev ="
    },
    {
        "line": 84,
        "fullcodeline": "has_content = resolve_reference_link_definitions(parser, *container);"
    },
    {
        "line": 82,
        "fullcodeline": "scan_setext_heading_line(input, parser->first_nonspace))) {"
    },
    {
        "line": 87,
        "fullcodeline": "cmark_node_set_type(*container, CMARK_NODE_HEADING);"
    },
    {
        "line": 88,
        "fullcodeline": "decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);"
    },
    {
        "line": 89,
        "fullcodeline": "incr_open_block_count(parser, CMARK_NODE_HEADING);"
    },
    {
        "line": 90,
        "fullcodeline": "(*container)->as.heading.level = lev;"
    },
    {
        "line": 91,
        "fullcodeline": "(*container)->as.heading.setext = true;"
    },
    {
        "line": 92,
        "fullcodeline": "S_advance_offset(parser, input, input->len - 1 - parser->offset, false);"
    },
    {
        "line": 94,
        "fullcodeline": "} else if (!indented &&"
    },
    {
        "line": 97,
        "fullcodeline": "(matched = S_scan_thematic_break(parser, input, parser->first_nonspace))) {"
    },
    {
        "line": 99,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_THEMATIC_BREAK,"
    },
    {
        "line": 101,
        "fullcodeline": "S_advance_offset(parser, input, input->len - 1 - parser->offset, false);"
    },
    {
        "line": 96,
        "fullcodeline": "(parser->thematic_break_kill_pos <= parser->first_nonspace) &&"
    },
    {
        "line": 95,
        "fullcodeline": "!(cont_type == CMARK_NODE_PARAGRAPH && !all_matched) &&"
    },
    {
        "line": 100,
        "fullcodeline": "parser->first_nonspace + 1);"
    },
    {
        "line": 102,
        "fullcodeline": "} else if (!indented &&"
    },
    {
        "line": 104,
        "fullcodeline": "(matched = scan_footnote_definition(input, parser->first_nonspace))) {"
    },
    {
        "line": 105,
        "fullcodeline": "cmark_chunk c = cmark_chunk_dup(input, parser->first_nonspace + 2, matched - 2);"
    },
    {
        "line": 106,
        "fullcodeline": "cmark_chunk_to_cstr(parser->mem, &c);"
    },
    {
        "line": 110,
        "fullcodeline": "--c.len;"
    },
    {
        "line": 112,
        "fullcodeline": "S_advance_offset(parser, input, parser->first_nonspace + matched - parser->offset, false);"
    },
    {
        "line": 113,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_FOOTNOTE_DEFINITION, parser->first_nonspace + matched + 1);"
    },
    {
        "line": 114,
        "fullcodeline": "(*container)->as.literal = c;"
    },
    {
        "line": 116,
        "fullcodeline": "(*container)->internal_offset = matched;"
    },
    {
        "line": 103,
        "fullcodeline": "parser->options & CMARK_OPT_FOOTNOTES &&"
    },
    {
        "line": 108,
        "fullcodeline": "while (c.data[c.len - 1] != ']')"
    },
    {
        "line": 109,
        "fullcodeline": "--c.len;"
    },
    {
        "line": 117,
        "fullcodeline": "} else if ((!indented || cont_type == CMARK_NODE_LIST) &&"
    },
    {
        "line": 119,
        "fullcodeline": "(matched = parse_list_marker("
    },
    {
        "line": 125,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 128,
        "fullcodeline": "S_advance_offset(parser, input,"
    },
    {
        "line": 132,
        "fullcodeline": "save_partially_consumed_tab = parser->partially_consumed_tab;"
    },
    {
        "line": 133,
        "fullcodeline": "save_offset = parser->offset;"
    },
    {
        "line": 134,
        "fullcodeline": "save_column = parser->column;"
    },
    {
        "line": 141,
        "fullcodeline": "i = parser->column - save_column;"
    },
    {
        "line": 159,
        "fullcodeline": "data->marker_offset = parser->indent;"
    },
    {
        "line": 170,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_ITEM,"
    },
    {
        "line": 173,
        "fullcodeline": "memcpy(&((*container)->as.list), data, sizeof(*data));"
    },
    {
        "line": 174,
        "fullcodeline": "parser->mem->free(data);"
    },
    {
        "line": 118,
        "fullcodeline": "parser->indent < 4 &&"
    },
    {
        "line": 129,
        "fullcodeline": "parser->first_nonspace + matched - parser->offset,"
    },
    {
        "line": 136,
        "fullcodeline": "while (parser->column - save_column <= 5 &&"
    },
    {
        "line": 142,
        "fullcodeline": "if (i >= 5 || i < 1 ||"
    },
    {
        "line": 161,
        "fullcodeline": "if (cont_type != CMARK_NODE_LIST ||"
    },
    {
        "line": 121,
        "fullcodeline": "(*container)->type == CMARK_NODE_PARAGRAPH, &data))) {"
    },
    {
        "line": 137,
        "fullcodeline": "S_is_space_or_tab(peek_at(input, parser->offset))) {"
    },
    {
        "line": 138,
        "fullcodeline": "S_advance_offset(parser, input, 1, true);"
    },
    {
        "line": 144,
        "fullcodeline": "S_is_line_end_char(peek_at(input, parser->offset))) {"
    },
    {
        "line": 145,
        "fullcodeline": "data->padding = matched + 1;"
    },
    {
        "line": 146,
        "fullcodeline": "parser->offset = save_offset;"
    },
    {
        "line": 147,
        "fullcodeline": "parser->column = save_column;"
    },
    {
        "line": 148,
        "fullcodeline": "parser->partially_consumed_tab = save_partially_consumed_tab;"
    },
    {
        "line": 162,
        "fullcodeline": "!lists_match(&((*container)->as.list), data)) {"
    },
    {
        "line": 163,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_LIST,"
    },
    {
        "line": 166,
        "fullcodeline": "memcpy(&((*container)->as.list), data, sizeof(*data));"
    },
    {
        "line": 171,
        "fullcodeline": "parser->first_nonspace + 1);"
    },
    {
        "line": 175,
        "fullcodeline": "} else if (indented && !maybe_lazy && !parser->blank) {"
    },
    {
        "line": 149,
        "fullcodeline": "if (i > 0) {"
    },
    {
        "line": 153,
        "fullcodeline": "data->padding = matched + i;"
    },
    {
        "line": 176,
        "fullcodeline": "S_advance_offset(parser, input, CODE_INDENT, true);"
    },
    {
        "line": 177,
        "fullcodeline": "*container = add_child(parser, *container, CMARK_NODE_CODE_BLOCK,"
    },
    {
        "line": 179,
        "fullcodeline": "(*container)->as.code.fenced = false;"
    },
    {
        "line": 180,
        "fullcodeline": "(*container)->as.code.fence_char = 0;"
    },
    {
        "line": 181,
        "fullcodeline": "(*container)->as.code.fence_length = 0;"
    },
    {
        "line": 182,
        "fullcodeline": "(*container)->as.code.fence_offset = 0;"
    },
    {
        "line": 183,
        "fullcodeline": "(*container)->as.code.info = cmark_chunk_literal(\"\");"
    },
    {
        "line": 150,
        "fullcodeline": "S_advance_offset(parser, input, 1, true);"
    },
    {
        "line": 164,
        "fullcodeline": "parser->first_nonspace + 1);"
    },
    {
        "line": 186,
        "fullcodeline": "cmark_node *new_container = NULL;"
    },
    {
        "line": 178,
        "fullcodeline": "parser->offset + 1);"
    },
    {
        "line": 188,
        "fullcodeline": "for (tmp = parser->syntax_extensions; tmp; tmp=tmp->next) {"
    },
    {
        "line": 202,
        "fullcodeline": "if (!new_container) {"
    },
    {
        "line": 189,
        "fullcodeline": "cmark_syntax_extension *ext = (cmark_syntax_extension *) tmp->data;"
    },
    {
        "line": 192,
        "fullcodeline": "new_container = ext->try_opening_block("
    },
    {
        "line": 196,
        "fullcodeline": "*container = new_container;"
    }
]