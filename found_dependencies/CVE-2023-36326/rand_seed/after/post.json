[
    {
        "line": 2,
        "fullcodeline": "ctx_t *ctx = core_get();"
    },
    {
        "line": 3,
        "fullcodeline": "size_t len = (RLC_RAND_SIZE - 1) / 2;"
    },
    {
        "line": 15,
        "fullcodeline": "ctx->rand[0] = 0x0;"
    },
    {
        "line": 37,
        "fullcodeline": "ctx->counter = ctx->seeded = 1;"
    },
    {
        "line": 5,
        "fullcodeline": "if (size <= 0) {"
    },
    {
        "line": 10,
        "fullcodeline": "if (sizeof(int) > 4 && size > (1 << 32)) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (ctx->seeded == 0) {"
    },
    {
        "line": 6,
        "fullcodeline": "RLC_THROW(ERR_NO_VALID);"
    },
    {
        "line": 11,
        "fullcodeline": "RLC_THROW(ERR_NO_VALID);"
    },
    {
        "line": 18,
        "fullcodeline": "rand_hash(ctx->rand + 1, len, buf, size);"
    },
    {
        "line": 20,
        "fullcodeline": "rand_hash(ctx->rand + 1 + len, len, ctx->rand, len + 1);"
    },
    {
        "line": 23,
        "fullcodeline": "int tmp_size = 1 + len + size;"
    },
    {
        "line": 24,
        "fullcodeline": "uint8_t* tmp = RLC_ALLOCA(uint8_t, tmp_size);"
    },
    {
        "line": 29,
        "fullcodeline": "tmp[0] = 1;"
    },
    {
        "line": 30,
        "fullcodeline": "memcpy(tmp + 1, ctx->rand + 1, len);"
    },
    {
        "line": 31,
        "fullcodeline": "memcpy(tmp + 1 + len, buf, size);"
    },
    {
        "line": 32,
        "fullcodeline": "rand_hash(ctx->rand + 1, len, tmp, tmp_size);"
    },
    {
        "line": 34,
        "fullcodeline": "rand_hash(ctx->rand + 1 + len, len, ctx->rand, len + 1);"
    },
    {
        "line": 35,
        "fullcodeline": "RLC_FREE(tmp);"
    },
    {
        "line": 25,
        "fullcodeline": "if (tmp == NULL) {"
    },
    {
        "line": 26,
        "fullcodeline": "RLC_THROW(ERR_NO_MEMORY);"
    }
]