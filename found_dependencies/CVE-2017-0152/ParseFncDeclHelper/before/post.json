[
    {
        "line": 3,
        "fullcodeline": "ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();"
    },
    {
        "line": 5,
        "fullcodeline": "ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;"
    },
    {
        "line": 6,
        "fullcodeline": "ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;"
    },
    {
        "line": 7,
        "fullcodeline": "int32* pAstSizeSave = m_pCurrentAstSize;"
    },
    {
        "line": 9,
        "fullcodeline": "bool fDeclaration = (flags & fFncDeclaration) != 0;"
    },
    {
        "line": 10,
        "fullcodeline": "bool fLambda = (flags & fFncLambda) != 0;"
    },
    {
        "line": 11,
        "fullcodeline": "bool fAsync = (flags & fFncAsync) != 0;"
    },
    {
        "line": 12,
        "fullcodeline": "bool fModule = (flags & fFncModule) != 0;"
    },
    {
        "line": 13,
        "fullcodeline": "bool fDeferred = false;"
    },
    {
        "line": 15,
        "fullcodeline": "ParseNodePtr *lastNodeRef = nullptr;"
    },
    {
        "line": 16,
        "fullcodeline": "bool fFunctionInBlock = false;"
    },
    {
        "line": 26,
        "fullcodeline": "m_pscan->Capture(&beginNameHint);"
    },
    {
        "line": 28,
        "fullcodeline": "ParseNodePtr pnodeFncExprScope = nullptr;"
    },
    {
        "line": 29,
        "fullcodeline": "Scope *fncExprScope = nullptr;"
    },
    {
        "line": 41,
        "fullcodeline": "*pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);"
    },
    {
        "line": 60,
        "fullcodeline": "bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());"
    },
    {
        "line": 62,
        "fullcodeline": "bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);"
    },
    {
        "line": 83,
        "fullcodeline": "bool topLevelStmt ="
    },
    {
        "line": 88,
        "fullcodeline": "pstmtSave = m_pstmtCur;"
    },
    {
        "line": 89,
        "fullcodeline": "SetCurrentStatement(nullptr);"
    },
    {
        "line": 92,
        "fullcodeline": "bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;"
    },
    {
        "line": 100,
        "fullcodeline": "Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());"
    },
    {
        "line": 103,
        "fullcodeline": "m_pscan->Capture(&beginFormals);"
    },
    {
        "line": 104,
        "fullcodeline": "BOOL fWasAlreadyStrictMode = IsStrictMode();"
    },
    {
        "line": 112,
        "fullcodeline": "uint uDeferSave = m_grfscr & fscrDeferFncParse;"
    },
    {
        "line": 128,
        "fullcodeline": "this->m_inFIB = fFunctionInBlock || this->m_inFIB;"
    },
    {
        "line": 130,
        "fullcodeline": "bool isTopLevelDeferredFunc = false;"
    },
    {
        "line": 137,
        "fullcodeline": "} flag(this);"
    },
    {
        "line": 139,
        "fullcodeline": "bool doParallel = false;"
    },
    {
        "line": 140,
        "fullcodeline": "bool parallelJobStarted = false;"
    },
    {
        "line": 597,
        "fullcodeline": "AnalysisAssert(pnodeFnc);"
    },
    {
        "line": 604,
        "fullcodeline": "Assert(nullptr == m_pstmtCur);"
    },
    {
        "line": 605,
        "fullcodeline": "SetCurrentStatement(pstmtSave);"
    },
    {
        "line": 615,
        "fullcodeline": "m_inFIB = saveInFIB;"
    },
    {
        "line": 617,
        "fullcodeline": "m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);"
    },
    {
        "line": 618,
        "fullcodeline": "m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);"
    },
    {
        "line": 30,
        "fullcodeline": "if (!fDeclaration)"
    },
    {
        "line": 51,
        "fullcodeline": "if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())"
    },
    {
        "line": 64,
        "fullcodeline": "if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())"
    },
    {
        "line": 69,
        "fullcodeline": "if (fncExprScope && !*pHasName)"
    },
    {
        "line": 84,
        "fullcodeline": "buildAST &&"
    },
    {
        "line": 94,
        "fullcodeline": "if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)"
    },
    {
        "line": 113,
        "fullcodeline": "if ((!fDeclaration && m_ppnodeExprScope) ||"
    },
    {
        "line": 219,
        "fullcodeline": "if (!doParallel)"
    },
    {
        "line": 598,
        "fullcodeline": "if (pnodeFnc->sxFnc.GetAsmjsMode())"
    },
    {
        "line": 611,
        "fullcodeline": "if (!m_stoppedDeferredParse)"
    },
    {
        "line": 645,
        "fullcodeline": "if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())"
    },
    {
        "line": 19,
        "fullcodeline": "fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&"
    },
    {
        "line": 32,
        "fullcodeline": "pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);"
    },
    {
        "line": 38,
        "fullcodeline": "this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);"
    },
    {
        "line": 48,
        "fullcodeline": "this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);"
    },
    {
        "line": 55,
        "fullcodeline": "Error(ERRsyntax, pnodeFnc);"
    },
    {
        "line": 66,
        "fullcodeline": "CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);"
    },
    {
        "line": 71,
        "fullcodeline": "FinishParseBlock(pnodeFncExprScope);"
    },
    {
        "line": 72,
        "fullcodeline": "m_nextBlockId--;"
    },
    {
        "line": 73,
        "fullcodeline": "Adelete(&m_nodeAllocator, fncExprScope);"
    },
    {
        "line": 74,
        "fullcodeline": "fncExprScope = nullptr;"
    },
    {
        "line": 75,
        "fullcodeline": "pnodeFncExprScope = nullptr;"
    },
    {
        "line": 79,
        "fullcodeline": "pnodeFnc->sxFnc.scope = fncExprScope;"
    },
    {
        "line": 86,
        "fullcodeline": "(this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);"
    },
    {
        "line": 97,
        "fullcodeline": "isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;"
    },
    {
        "line": 109,
        "fullcodeline": "CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);"
    },
    {
        "line": 115,
        "fullcodeline": "(flags & (fFncNoName | fFncLambda)))"
    },
    {
        "line": 124,
        "fullcodeline": "m_grfscr &= ~fscrDeferFncParse;"
    },
    {
        "line": 143,
        "fullcodeline": "bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;"
    },
    {
        "line": 145,
        "fullcodeline": "BOOL isDeferredFnc = IsDeferredFnc();"
    },
    {
        "line": 146,
        "fullcodeline": "AnalysisAssert(isDeferredFnc || pnodeFnc);"
    },
    {
        "line": 148,
        "fullcodeline": "isTopLevelDeferredFunc ="
    },
    {
        "line": 177,
        "fullcodeline": "isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc &&"
    },
    {
        "line": 223,
        "fullcodeline": "ParseNodePtr pnodeRealFnc = pnodeFnc;"
    },
    {
        "line": 232,
        "fullcodeline": "AnalysisAssert(pnodeFnc);"
    },
    {
        "line": 233,
        "fullcodeline": "ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);"
    },
    {
        "line": 234,
        "fullcodeline": "AnalysisAssert(pnodeBlock != nullptr);"
    },
    {
        "line": 235,
        "fullcodeline": "pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;"
    },
    {
        "line": 238,
        "fullcodeline": "ParseNodePtr *ppnodeScopeSave = nullptr;"
    },
    {
        "line": 239,
        "fullcodeline": "ParseNodePtr *ppnodeExprScopeSave = nullptr;"
    },
    {
        "line": 241,
        "fullcodeline": "ppnodeScopeSave = m_ppnodeScope;"
    },
    {
        "line": 251,
        "fullcodeline": "ppnodeExprScopeSave = m_ppnodeExprScope;"
    },
    {
        "line": 252,
        "fullcodeline": "m_ppnodeExprScope = nullptr;"
    },
    {
        "line": 266,
        "fullcodeline": "ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);"
    },
    {
        "line": 271,
        "fullcodeline": "*m_ppnodeScope = pnodeInnerBlock;"
    },
    {
        "line": 272,
        "fullcodeline": "pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;"
    },
    {
        "line": 276,
        "fullcodeline": "pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;"
    },
    {
        "line": 294,
        "fullcodeline": "bool strictModeTurnedOn = false;"
    },
    {
        "line": 316,
        "fullcodeline": "Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;"
    },
    {
        "line": 516,
        "fullcodeline": "Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);"
    },
    {
        "line": 517,
        "fullcodeline": "m_ppnodeExprScope = ppnodeExprScopeSave;"
    },
    {
        "line": 520,
        "fullcodeline": "Assert(nullptr == *m_ppnodeScope);"
    },
    {
        "line": 521,
        "fullcodeline": "m_ppnodeScope = ppnodeScopeSave;"
    },
    {
        "line": 600,
        "fullcodeline": "m_InAsmMode = false;"
    },
    {
        "line": 609,
        "fullcodeline": "FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);"
    },
    {
        "line": 613,
        "fullcodeline": "m_grfscr |= uDeferSave;"
    },
    {
        "line": 623,
        "fullcodeline": "Assert(pnodeFnc == m_currentNodeFunc);"
    },
    {
        "line": 625,
        "fullcodeline": "m_currentNodeFunc = pnodeFncSave;"
    },
    {
        "line": 626,
        "fullcodeline": "m_pCurrentAstSize = pAstSizeSave;"
    },
    {
        "line": 647,
        "fullcodeline": "GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);"
    },
    {
        "line": 85,
        "fullcodeline": "!fFunctionInBlock &&"
    },
    {
        "line": 149,
        "fullcodeline": "(!fLambda"
    },
    {
        "line": 180,
        "fullcodeline": "if (!fLambda &&"
    },
    {
        "line": 254,
        "fullcodeline": "if (!skipFormals)"
    },
    {
        "line": 296,
        "fullcodeline": "if (isTopLevelDeferredFunc &&"
    },
    {
        "line": 317,
        "fullcodeline": "if (paramScope != nullptr)"
    },
    {
        "line": 347,
        "fullcodeline": "if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()"
    },
    {
        "line": 356,
        "fullcodeline": "if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())"
    },
    {
        "line": 365,
        "fullcodeline": "if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))"
    },
    {
        "line": 509,
        "fullcodeline": "if (!fModule && (m_token.tk == tkLCurly || !fLambda))"
    },
    {
        "line": 528,
        "fullcodeline": "if (IsStrictMode() || strictModeTurnedOn)"
    },
    {
        "line": 628,
        "fullcodeline": "if (!fLambda)"
    },
    {
        "line": 636,
        "fullcodeline": "Assert(pnodeFnc == m_currentNodeDeferredFunc);"
    },
    {
        "line": 642,
        "fullcodeline": "m_currentNodeDeferredFunc = pnodeFncSave;"
    },
    {
        "line": 20,
        "fullcodeline": "(GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||"
    },
    {
        "line": 155,
        "fullcodeline": "&& !fModule"
    },
    {
        "line": 160,
        "fullcodeline": "pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));"
    },
    {
        "line": 161,
        "fullcodeline": "pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);"
    },
    {
        "line": 173,
        "fullcodeline": "isTopLevelDeferredFunc = false;"
    },
    {
        "line": 178,
        "fullcodeline": "(!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));"
    },
    {
        "line": 186,
        "fullcodeline": "!(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))"
    },
    {
        "line": 188,
        "fullcodeline": "doParallel = DoParallelParse(pnodeFnc);"
    },
    {
        "line": 229,
        "fullcodeline": "pnodeFnc = CreateDummyFuncNode(fDeclaration);"
    },
    {
        "line": 246,
        "fullcodeline": "pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;"
    },
    {
        "line": 256,
        "fullcodeline": "bool fLambdaParamsSave = m_reparsingLambdaParams;"
    },
    {
        "line": 261,
        "fullcodeline": "this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);"
    },
    {
        "line": 262,
        "fullcodeline": "m_reparsingLambdaParams = fLambdaParamsSave;"
    },
    {
        "line": 304,
        "fullcodeline": "!PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||"
    },
    {
        "line": 348,
        "fullcodeline": "&& (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))"
    },
    {
        "line": 358,
        "fullcodeline": "paramScope->ForEachSymbol([this](Symbol* paramSym)"
    },
    {
        "line": 367,
        "fullcodeline": "AssertMsg(!fLambda, \"Deferring function parsing of a function does not handle lambda syntax\");"
    },
    {
        "line": 368,
        "fullcodeline": "fDeferred = true;"
    },
    {
        "line": 370,
        "fullcodeline": "this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);"
    },
    {
        "line": 506,
        "fullcodeline": "FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);"
    },
    {
        "line": 511,
        "fullcodeline": "this->AddArgumentsNodeToVars(pnodeFnc);"
    },
    {
        "line": 525,
        "fullcodeline": "FinishParseBlock(pnodeBlock, *pNeedScanRCurly);"
    },
    {
        "line": 530,
        "fullcodeline": "this->m_fUseStrictMode = TRUE; // Now we know this function is in strict mode"
    },
    {
        "line": 573,
        "fullcodeline": "this->m_fUseStrictMode = oldStrictMode;"
    },
    {
        "line": 574,
        "fullcodeline": "CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);"
    },
    {
        "line": 579,
        "fullcodeline": "AnalysisAssert(pnodeFnc);"
    },
    {
        "line": 580,
        "fullcodeline": "pnodeFnc->sxFnc.pnodeVars = nullptr;"
    },
    {
        "line": 585,
        "fullcodeline": "pnodeFnc = pnodeRealFnc;"
    },
    {
        "line": 586,
        "fullcodeline": "m_currentNodeFunc = pnodeRealFnc;"
    },
    {
        "line": 591,
        "fullcodeline": "pnodeFnc->ichLim = m_pscan->IchLimTok();"
    },
    {
        "line": 592,
        "fullcodeline": "pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();"
    },
    {
        "line": 630,
        "fullcodeline": "Assert(pnodeFnc == m_currentNodeNonLambdaFunc);"
    },
    {
        "line": 631,
        "fullcodeline": "m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;"
    },
    {
        "line": 637,
        "fullcodeline": "if (!fLambda)"
    },
    {
        "line": 21,
        "fullcodeline": "GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);"
    },
    {
        "line": 153,
        "fullcodeline": "&& !m_InAsmMode"
    },
    {
        "line": 185,
        "fullcodeline": "!(pnodeFncSave && m_currDeferredStub) &&"
    },
    {
        "line": 302,
        "fullcodeline": "PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&"
    },
    {
        "line": 305,
        "fullcodeline": "PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)"
    },
    {
        "line": 310,
        "fullcodeline": "if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))"
    },
    {
        "line": 398,
        "fullcodeline": "AnalysisAssert(pnodeFnc);"
    },
    {
        "line": 401,
        "fullcodeline": "Assert(*m_ppnodeVar == nullptr);"
    },
    {
        "line": 404,
        "fullcodeline": "pnodeFnc->sxFnc.pnodeVars = nullptr;"
    },
    {
        "line": 405,
        "fullcodeline": "m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;"
    },
    {
        "line": 448,
        "fullcodeline": "m_ppnodeExprScope = nullptr;"
    },
    {
        "line": 532,
        "fullcodeline": "if (!fWasAlreadyStrictMode)"
    },
    {
        "line": 639,
        "fullcodeline": "Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);"
    },
    {
        "line": 640,
        "fullcodeline": "m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;"
    },
    {
        "line": 152,
        "fullcodeline": "&& (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))"
    },
    {
        "line": 171,
        "fullcodeline": "pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);"
    },
    {
        "line": 184,
        "fullcodeline": "!this->m_doingFastScan &&"
    },
    {
        "line": 259,
        "fullcodeline": "m_reparsingLambdaParams = true;"
    },
    {
        "line": 300,
        "fullcodeline": "m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&"
    },
    {
        "line": 312,
        "fullcodeline": "isTopLevelDeferredFunc = false;"
    },
    {
        "line": 374,
        "fullcodeline": "if (m_token.tk == tkRParen) // This might be false due to error recovery or lambda."
    },
    {
        "line": 407,
        "fullcodeline": "if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())"
    },
    {
        "line": 537,
        "fullcodeline": "m_pscan->Capture(&afterFnc);"
    },
    {
        "line": 560,
        "fullcodeline": "m_pscan->SeekToForcingPid(beginFormals);"
    },
    {
        "line": 561,
        "fullcodeline": "CheckStrictFormalParameters();"
    },
    {
        "line": 562,
        "fullcodeline": "m_pscan->SeekTo(afterFnc);"
    },
    {
        "line": 183,
        "fullcodeline": "!this->IsBackgroundParser() &&"
    },
    {
        "line": 298,
        "fullcodeline": "pnodeFnc->sxFnc.IsNested() &&"
    },
    {
        "line": 376,
        "fullcodeline": "m_pscan->Scan();"
    },
    {
        "line": 381,
        "fullcodeline": "BOOL hadNewLine = m_pscan->FHadNewLine();"
    },
    {
        "line": 388,
        "fullcodeline": "ChkCurTok(tkDArrow, ERRnoDArrow);"
    },
    {
        "line": 409,
        "fullcodeline": "OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(\"The param and body scope of the function %s cannot be merged\\n\"), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(\"Anonymous function\"));"
    },
    {
        "line": 416,
        "fullcodeline": "paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {"
    },
    {
        "line": 452,
        "fullcodeline": "DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;"
    },
    {
        "line": 496,
        "fullcodeline": "m_currDeferredStub = saveCurrentStub;"
    },
    {
        "line": 567,
        "fullcodeline": "if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)"
    },
    {
        "line": 182,
        "fullcodeline": "!isLikelyIIFE &&"
    },
    {
        "line": 297,
        "fullcodeline": "!(this->m_grfscr & fscrEvalCode) &&"
    },
    {
        "line": 436,
        "fullcodeline": "if (!fLambda)"
    },
    {
        "line": 487,
        "fullcodeline": "if (m_token.tk != tkLCurly && fLambda)"
    },
    {
        "line": 500,
        "fullcodeline": "this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);"
    },
    {
        "line": 542,
        "fullcodeline": "m_pscan->SeekTo(beginNameHint);"
    },
    {
        "line": 543,
        "fullcodeline": "m_pscan->Scan();"
    },
    {
        "line": 555,
        "fullcodeline": "CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));"
    },
    {
        "line": 569,
        "fullcodeline": "CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);"
    },
    {
        "line": 181,
        "fullcodeline": "!isDeferredFnc &&"
    },
    {
        "line": 441,
        "fullcodeline": "ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);"
    },
    {
        "line": 442,
        "fullcodeline": "Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);"
    },
    {
        "line": 456,
        "fullcodeline": "m_currDeferredStub = nullptr;"
    },
    {
        "line": 489,
        "fullcodeline": "ParseExpressionLambdaBody<true>(pnodeFnc);"
    },
    {
        "line": 490,
        "fullcodeline": "*pNeedScanRCurly = false;"
    },
    {
        "line": 544,
        "fullcodeline": "if (pnodeFnc->sxFnc.IsGenerator())"
    },
    {
        "line": 551,
        "fullcodeline": "if (m_token.IsReservedWord())"
    },
    {
        "line": 494,
        "fullcodeline": "this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);"
    },
    {
        "line": 546,
        "fullcodeline": "Assert(m_token.tk == tkStar);"
    },
    {
        "line": 547,
        "fullcodeline": "Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());"
    },
    {
        "line": 548,
        "fullcodeline": "Assert(!(flags & fFncClassMember));"
    },
    {
        "line": 549,
        "fullcodeline": "m_pscan->Scan();"
    },
    {
        "line": 458,
        "fullcodeline": "else if (pnodeFncSave && m_currDeferredStub)"
    },
    {
        "line": 466,
        "fullcodeline": "if (pnodeFncSave->sxFnc.nestedCount == 1)"
    },
    {
        "line": 471,
        "fullcodeline": "if (m_prevSiblingDeferredStub == nullptr)"
    },
    {
        "line": 476,
        "fullcodeline": "if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)"
    },
    {
        "line": 468,
        "fullcodeline": "m_prevSiblingDeferredStub = nullptr;"
    },
    {
        "line": 473,
        "fullcodeline": "m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));"
    },
    {
        "line": 478,
        "fullcodeline": "m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;"
    },
    {
        "line": 479,
        "fullcodeline": "m_prevSiblingDeferredStub = nullptr;"
    },
    {
        "line": 483,
        "fullcodeline": "m_currDeferredStub = nullptr;"
    }
]