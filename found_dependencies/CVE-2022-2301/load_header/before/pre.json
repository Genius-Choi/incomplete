[
    {
        "line": 3,
        "fullcodeline": "XwdHeader *h = &loader->header;"
    },
    {
        "line": 5,
        "fullcodeline": "const guint32 *p = (const guint32 *) &in;"
    },
    {
        "line": 10,
        "fullcodeline": "h->header_size = g_ntohl (*(p++));"
    },
    {
        "line": 11,
        "fullcodeline": "h->file_version = g_ntohl (*(p++));"
    },
    {
        "line": 13,
        "fullcodeline": "h->pixmap_depth = g_ntohl (*(p++));"
    },
    {
        "line": 14,
        "fullcodeline": "h->pixmap_width = g_ntohl (*(p++));"
    },
    {
        "line": 15,
        "fullcodeline": "h->pixmap_height = g_ntohl (*(p++));"
    },
    {
        "line": 21,
        "fullcodeline": "h->bits_per_pixel = g_ntohl (*(p++));"
    },
    {
        "line": 22,
        "fullcodeline": "h->bytes_per_line = g_ntohl (*(p++));"
    },
    {
        "line": 27,
        "fullcodeline": "h->bits_per_rgb = g_ntohl (*(p++));"
    },
    {
        "line": 29,
        "fullcodeline": "h->n_colors = g_ntohl (*(p++));"
    },
    {
        "line": 50,
        "fullcodeline": "loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);"
    },
    {
        "line": 7,
        "fullcodeline": "if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))"
    },
    {
        "line": 12,
        "fullcodeline": "h->pixmap_format = g_ntohl (*(p++));"
    },
    {
        "line": 16,
        "fullcodeline": "h->x_offset = g_ntohl (*(p++));"
    },
    {
        "line": 17,
        "fullcodeline": "h->byte_order = g_ntohl (*(p++));"
    },
    {
        "line": 18,
        "fullcodeline": "h->bitmap_unit = g_ntohl (*(p++));"
    },
    {
        "line": 19,
        "fullcodeline": "h->bitmap_bit_order = g_ntohl (*(p++));"
    },
    {
        "line": 20,
        "fullcodeline": "h->bitmap_pad = g_ntohl (*(p++));"
    },
    {
        "line": 23,
        "fullcodeline": "h->visual_class = g_ntohl (*(p++));"
    },
    {
        "line": 24,
        "fullcodeline": "h->red_mask = g_ntohl (*(p++));"
    },
    {
        "line": 25,
        "fullcodeline": "h->green_mask = g_ntohl (*(p++));"
    },
    {
        "line": 26,
        "fullcodeline": "h->blue_mask = g_ntohl (*(p++));"
    },
    {
        "line": 28,
        "fullcodeline": "h->color_map_entries = g_ntohl (*(p++));"
    },
    {
        "line": 30,
        "fullcodeline": "h->window_width = g_ntohl (*(p++));"
    },
    {
        "line": 31,
        "fullcodeline": "h->window_height = g_ntohl (*(p++));"
    },
    {
        "line": 32,
        "fullcodeline": "h->window_x = g_ntohl (*(p++));"
    },
    {
        "line": 33,
        "fullcodeline": "h->window_y = g_ntohl (*(p++));"
    },
    {
        "line": 34,
        "fullcodeline": "h->window_border_width = g_ntohl (*(p++));"
    },
    {
        "line": 39,
        "fullcodeline": "ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));"
    },
    {
        "line": 40,
        "fullcodeline": "ASSERT_HEADER (h->file_version == 7);"
    },
    {
        "line": 41,
        "fullcodeline": "ASSERT_HEADER (h->pixmap_depth == 24);"
    },
    {
        "line": 45,
        "fullcodeline": "ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);"
    },
    {
        "line": 47,
        "fullcodeline": "ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));"
    },
    {
        "line": 48,
        "fullcodeline": "ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);"
    },
    {
        "line": 51,
        "fullcodeline": "if (!loader->file_data)"
    },
    {
        "line": 54,
        "fullcodeline": "ASSERT_HEADER (loader->file_data_len >= h->header_size"
    },
    {
        "line": 59,
        "fullcodeline": "+ h->header_size + h->n_colors * sizeof (XwdColor);"
    },
    {
        "line": 56,
        "fullcodeline": "+ h->pixmap_height * h->bytes_per_line);"
    },
    {
        "line": 55,
        "fullcodeline": "+ h->n_colors * sizeof (XwdColor)"
    }
]