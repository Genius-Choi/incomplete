[
    {
        "line": 13,
        "fullcodeline": "guint offset = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "const guint8 dot1x_header[] = {"
    },
    {
        "line": 21,
        "fullcodeline": "const guint8 bt_dot1x_header[] = {"
    },
    {
        "line": 28,
        "fullcodeline": "const guint8 tdls_header[] = {"
    },
    {
        "line": 43,
        "fullcodeline": "AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapScanForKeys\");"
    },
    {
        "line": 46,
        "fullcodeline": "offset = mac_header_len;"
    },
    {
        "line": 237,
        "fullcodeline": "AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");"
    },
    {
        "line": 49,
        "fullcodeline": "if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {"
    },
    {
        "line": 51,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 54,
        "fullcodeline": "offset+=8;"
    },
    {
        "line": 63,
        "fullcodeline": "bodyLength=pntoh16(data+offset+2);"
    },
    {
        "line": 70,
        "fullcodeline": "offset+=4;"
    },
    {
        "line": 72,
        "fullcodeline": "pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);"
    },
    {
        "line": 84,
        "fullcodeline": "offset+=1;"
    },
    {
        "line": 87,
        "fullcodeline": "sa = AirPDcapGetSaPtr(ctx, &id);"
    },
    {
        "line": 113,
        "fullcodeline": "memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);"
    },
    {
        "line": 116,
        "fullcodeline": "sa = AirPDcapGetSaPtr(ctx, &id);"
    },
    {
        "line": 135,
        "fullcodeline": "sta_sa = AirPDcapGetSaPtr(ctx, &id);"
    },
    {
        "line": 57,
        "fullcodeline": "if (data[offset+1]!=3) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */"
    },
    {
        "line": 76,
        "fullcodeline": "pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */"
    },
    {
        "line": 88,
        "fullcodeline": "if (sa == NULL){"
    },
    {
        "line": 94,
        "fullcodeline": "if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)"
    },
    {
        "line": 97,
        "fullcodeline": "if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||"
    },
    {
        "line": 117,
        "fullcodeline": "if (sa == NULL){"
    },
    {
        "line": 124,
        "fullcodeline": "if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (sta_sa == NULL){"
    },
    {
        "line": 141,
        "fullcodeline": "return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));"
    },
    {
        "line": 58,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not EAPOL-Key\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 65,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 77,
        "fullcodeline": "pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */"
    },
    {
        "line": 79,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not valid key descriptor type\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 89,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"No SA for BSSID found\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 98,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Message too short for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 106,
        "fullcodeline": "AIRPDCAP_EAP_SEC(data[offset]) != 1){"
    },
    {
        "line": 108,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Key bitfields not correct for Group Key\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 125,
        "fullcodeline": "memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);"
    },
    {
        "line": 129,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 143,
        "fullcodeline": "} else if (memcmp(data+offset, tdls_header, 10) == 0) {"
    },
    {
        "line": 105,
        "fullcodeline": "AIRPDCAP_EAP_MIC(data[offset]) != 1 ||"
    },
    {
        "line": 131,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"SA not found\", AIRPDCAP_DEBUG_LEVEL_5);"
    },
    {
        "line": 146,
        "fullcodeline": "guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;"
    },
    {
        "line": 147,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Authentication: TDLS Action Frame\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 150,
        "fullcodeline": "offset+=10;"
    },
    {
        "line": 153,
        "fullcodeline": "action = data[offset];"
    },
    {
        "line": 160,
        "fullcodeline": "offset++;"
    },
    {
        "line": 161,
        "fullcodeline": "status=pntoh16(data+offset);"
    },
    {
        "line": 168,
        "fullcodeline": "offset+=5;"
    },
    {
        "line": 196,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Found RSNE/Fast BSS/Timeout Interval/Link IEs\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 199,
        "fullcodeline": "initiator = &data[offset_link + 8];"
    },
    {
        "line": 200,
        "fullcodeline": "responder = &data[offset_link + 14];"
    },
    {
        "line": 210,
        "fullcodeline": "sa = AirPDcapGetSaPtr(ctx, &id);"
    },
    {
        "line": 104,
        "fullcodeline": "AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||"
    },
    {
        "line": 154,
        "fullcodeline": "if (action!=1 && action!=2) {"
    },
    {
        "line": 162,
        "fullcodeline": "if (status!=0) {"
    },
    {
        "line": 172,
        "fullcodeline": "while(offset < (tot_len - 2)) {"
    },
    {
        "line": 189,
        "fullcodeline": "if (offset_rsne == 0 || offset_fte == 0 ||"
    },
    {
        "line": 202,
        "fullcodeline": "if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {"
    },
    {
        "line": 211,
        "fullcodeline": "if (sa == NULL){"
    },
    {
        "line": 228,
        "fullcodeline": "if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)"
    },
    {
        "line": 234,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Skipping: not an EAPOL packet\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 155,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Not Response nor confirm\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 163,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"TDLS setup not successfull\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 186,
        "fullcodeline": "offset += data[offset + 1] + 2;"
    },
    {
        "line": 190,
        "fullcodeline": "offset_timeout == 0 || offset_link == 0)"
    },
    {
        "line": 192,
        "fullcodeline": "AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"Cannot Find all necessary IEs\", AIRPDCAP_DEBUG_LEVEL_3);"
    },
    {
        "line": 203,
        "fullcodeline": "memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);"
    },
    {
        "line": 204,
        "fullcodeline": "memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);"
    },
    {
        "line": 230,
        "fullcodeline": "AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapScanForKeys\");"
    },
    {
        "line": 173,
        "fullcodeline": "if (data[offset] == 48) {"
    },
    {
        "line": 183,
        "fullcodeline": "if (tot_len < offset + data[offset + 1] + 2) {"
    },
    {
        "line": 206,
        "fullcodeline": "memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);"
    },
    {
        "line": 207,
        "fullcodeline": "memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);"
    },
    {
        "line": 216,
        "fullcodeline": "if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {"
    },
    {
        "line": 174,
        "fullcodeline": "offset_rsne = offset;"
    },
    {
        "line": 221,
        "fullcodeline": "AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);"
    },
    {
        "line": 222,
        "fullcodeline": "memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));"
    },
    {
        "line": 223,
        "fullcodeline": "sa->next=tmp_sa;"
    },
    {
        "line": 224,
        "fullcodeline": "sa->validKey = FALSE;"
    },
    {
        "line": 175,
        "fullcodeline": "} else if (data[offset] == 55) {"
    },
    {
        "line": 176,
        "fullcodeline": "offset_fte = offset;"
    },
    {
        "line": 177,
        "fullcodeline": "} else if (data[offset] == 56) {"
    },
    {
        "line": 178,
        "fullcodeline": "offset_timeout = offset;"
    },
    {
        "line": 179,
        "fullcodeline": "} else if (data[offset] == 101) {"
    },
    {
        "line": 180,
        "fullcodeline": "offset_link = offset;"
    }
]