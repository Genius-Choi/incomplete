[
    {
        "line": 11,
        "fullcodeline": "dev = alloc_netdev(sizeof(*ai), \"\", ether_setup);"
    },
    {
        "line": 17,
        "fullcodeline": "ai = dev->ml_priv = netdev_priv(dev);"
    },
    {
        "line": 18,
        "fullcodeline": "ai->wifidev = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "ai->flags = 1 << FLAG_RADIO_DOWN;"
    },
    {
        "line": 20,
        "fullcodeline": "ai->jobs = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "ai->dev = dev;"
    },
    {
        "line": 29,
        "fullcodeline": "ai->pci = pci;"
    },
    {
        "line": 31,
        "fullcodeline": "ai->tfm = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "add_airo_dev(ai);"
    },
    {
        "line": 36,
        "fullcodeline": "airo_networks_initialize (ai);"
    },
    {
        "line": 45,
        "fullcodeline": "dev->wireless_handlers = &airo_handler_def;"
    },
    {
        "line": 46,
        "fullcodeline": "ai->wireless_data.spy_data = &ai->spy_data;"
    },
    {
        "line": 47,
        "fullcodeline": "dev->wireless_data = &ai->wireless_data;"
    },
    {
        "line": 48,
        "fullcodeline": "dev->irq = irq;"
    },
    {
        "line": 49,
        "fullcodeline": "dev->base_addr = port;"
    },
    {
        "line": 51,
        "fullcodeline": "SET_NETDEV_DEV(dev, dmdev);"
    },
    {
        "line": 53,
        "fullcodeline": "reset_card (dev, 1);"
    },
    {
        "line": 82,
        "fullcodeline": "strcpy(dev->name, \"eth%d\");"
    },
    {
        "line": 88,
        "fullcodeline": "ai->wifidev = init_wifidev(ai, dev);"
    },
    {
        "line": 92,
        "fullcodeline": "rc = readCapabilityRid(ai, &cap_rid, 1);"
    },
    {
        "line": 98,
        "fullcodeline": "ai->wep_capable = (cap_rid.softCap & cpu_to_le16(0x02)) ? 1 : 0;"
    },
    {
        "line": 99,
        "fullcodeline": "ai->max_wep_idx = (cap_rid.softCap & cpu_to_le16(0x80)) ? 3 : 0;"
    },
    {
        "line": 101,
        "fullcodeline": "airo_print_info(dev->name, \"Firmware version %x.%x.%02d\","
    },
    {
        "line": 126,
        "fullcodeline": "set_bit(FLAG_REGISTERED,&ai->flags);"
    },
    {
        "line": 127,
        "fullcodeline": "airo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);"
    },
    {
        "line": 140,
        "fullcodeline": "unregister_netdev(ai->wifidev);"
    },
    {
        "line": 141,
        "fullcodeline": "free_netdev(ai->wifidev);"
    },
    {
        "line": 143,
        "fullcodeline": "unregister_netdev(dev);"
    },
    {
        "line": 155,
        "fullcodeline": "airo_networks_free(ai);"
    },
    {
        "line": 12,
        "fullcodeline": "if (!dev) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (pci && (pci->device == 0x5000 || pci->device == 0xa504)) {"
    },
    {
        "line": 34,
        "fullcodeline": "if (airo_networks_allocate (ai))"
    },
    {
        "line": 41,
        "fullcodeline": "if (test_bit(FLAG_MPI,&ai->flags))"
    },
    {
        "line": 56,
        "fullcodeline": "if (!is_pcmcia) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (test_bit(FLAG_MPI,&ai->flags)) {"
    },
    {
        "line": 83,
        "fullcodeline": "rc = register_netdev(dev);"
    },
    {
        "line": 89,
        "fullcodeline": "if (!ai->wifidev)"
    },
    {
        "line": 102,
        "fullcodeline": "((le16_to_cpu(cap_rid.softVer) >> 8) & 0xF),"
    },
    {
        "line": 103,
        "fullcodeline": "(le16_to_cpu(cap_rid.softVer) & 0xFF),"
    },
    {
        "line": 104,
        "fullcodeline": "le16_to_cpu(cap_rid.softSubVer));"
    },
    {
        "line": 130,
        "fullcodeline": "if (probe && !test_bit(FLAG_MPI,&ai->flags))"
    },
    {
        "line": 145,
        "fullcodeline": "if (test_bit(FLAG_MPI,&ai->flags) && pci) {"
    },
    {
        "line": 13,
        "fullcodeline": "airo_print_err(\"\", \"Couldn't alloc_etherdev\");"
    },
    {
        "line": 24,
        "fullcodeline": "set_bit(FLAG_MPI, &ai->flags);"
    },
    {
        "line": 42,
        "fullcodeline": "dev->netdev_ops = &mpi_netdev_ops;"
    },
    {
        "line": 85,
        "fullcodeline": "airo_print_err(dev->name, \"Couldn't register_netdev\");"
    },
    {
        "line": 108,
        "fullcodeline": "if (le16_to_cpu(cap_rid.softVer) > 0x530"
    },
    {
        "line": 109,
        "fullcodeline": "|| (le16_to_cpu(cap_rid.softVer) == 0x530"
    },
    {
        "line": 113,
        "fullcodeline": "set_bit(FLAG_WPA_CAPABLE, &ai->flags);"
    },
    {
        "line": 114,
        "fullcodeline": "ai->bssListFirst = RID_WPA_BSSLISTFIRST;"
    },
    {
        "line": 115,
        "fullcodeline": "ai->bssListNext = RID_WPA_BSSLISTNEXT;"
    },
    {
        "line": 116,
        "fullcodeline": "ai->bssListRidLen = sizeof(BSSListRid);"
    },
    {
        "line": 134,
        "fullcodeline": "if (setup_proc_entry(dev, dev->ml_priv) < 0)"
    },
    {
        "line": 146,
        "fullcodeline": "pci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);"
    },
    {
        "line": 147,
        "fullcodeline": "iounmap(ai->pciaux);"
    },
    {
        "line": 148,
        "fullcodeline": "iounmap(ai->pcimem);"
    },
    {
        "line": 149,
        "fullcodeline": "mpi_unmap_card(ai->pci);"
    },
    {
        "line": 153,
        "fullcodeline": "release_region( dev->base_addr, 64 );"
    },
    {
        "line": 44,
        "fullcodeline": "dev->netdev_ops = &airo_netdev_ops;"
    },
    {
        "line": 65,
        "fullcodeline": "if (mpi_map_card(ai, pci)) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (setup_card(ai, dev->dev_addr, 1) != SUCCESS) {"
    },
    {
        "line": 94,
        "fullcodeline": "rc = -EIO;"
    },
    {
        "line": 110,
        "fullcodeline": "&& le16_to_cpu(cap_rid.softSubVer) >= 17)) {"
    },
    {
        "line": 121,
        "fullcodeline": "ai->bssListFirst = RID_BSSLISTFIRST;"
    },
    {
        "line": 122,
        "fullcodeline": "ai->bssListNext = RID_BSSLISTNEXT;"
    },
    {
        "line": 123,
        "fullcodeline": "ai->bssListRidLen = sizeof(BSSListRid) - sizeof(BSSListRidExtra);"
    },
    {
        "line": 131,
        "fullcodeline": "for( i = 0; i < MAX_FIDS; i++ )"
    },
    {
        "line": 57,
        "fullcodeline": "if (!request_region(dev->base_addr, 64, DRV_NAME)) {"
    },
    {
        "line": 59,
        "fullcodeline": "airo_print_err(dev->name, \"Couldn't request region\");"
    },
    {
        "line": 73,
        "fullcodeline": "airo_print_err(dev->name, \"MAC could not be enabled\" );"
    },
    {
        "line": 77,
        "fullcodeline": "} else if (!test_bit(FLAG_MPI,&ai->flags)) {"
    },
    {
        "line": 132,
        "fullcodeline": "ai->fids[i] = transmit_allocate(ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);"
    },
    {
        "line": 58,
        "fullcodeline": "rc = -EBUSY;"
    },
    {
        "line": 74,
        "fullcodeline": "rc = -EIO;"
    },
    {
        "line": 78,
        "fullcodeline": "ai->bap_read = fast_bap_read;"
    },
    {
        "line": 79,
        "fullcodeline": "set_bit(FLAG_FLASHING, &ai->flags);"
    }
]