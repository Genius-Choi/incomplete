[
    {
        "line": 3,
        "fullcodeline": "struct bonding *bond = netdev_priv(bond_dev);"
    },
    {
        "line": 4,
        "fullcodeline": "const struct net_device_ops *slave_ops = slave_dev->netdev_ops;"
    },
    {
        "line": 5,
        "fullcodeline": "struct slave *new_slave = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int res = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "call_netdevice_notifiers(NETDEV_JOIN, slave_dev);"
    },
    {
        "line": 118,
        "fullcodeline": "new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);"
    },
    {
        "line": 128,
        "fullcodeline": "new_slave->queue_id = 0;"
    },
    {
        "line": 131,
        "fullcodeline": "new_slave->original_mtu = slave_dev->mtu;"
    },
    {
        "line": 132,
        "fullcodeline": "res = dev_set_mtu(slave_dev, bond->dev->mtu);"
    },
    {
        "line": 143,
        "fullcodeline": "memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);"
    },
    {
        "line": 159,
        "fullcodeline": "res = netdev_set_bond_master(slave_dev, bond_dev);"
    },
    {
        "line": 166,
        "fullcodeline": "res = dev_open(slave_dev);"
    },
    {
        "line": 172,
        "fullcodeline": "new_slave->bond = bond;"
    },
    {
        "line": 173,
        "fullcodeline": "new_slave->dev = slave_dev;"
    },
    {
        "line": 174,
        "fullcodeline": "slave_dev->priv_flags |= IFF_BONDING;"
    },
    {
        "line": 219,
        "fullcodeline": "bond_add_vlans_on_slave(bond, slave_dev);"
    },
    {
        "line": 221,
        "fullcodeline": "write_lock_bh(&bond->lock);"
    },
    {
        "line": 223,
        "fullcodeline": "bond_attach_slave(bond, new_slave);"
    },
    {
        "line": 225,
        "fullcodeline": "new_slave->delay = 0;"
    },
    {
        "line": 226,
        "fullcodeline": "new_slave->link_failure_count = 0;"
    },
    {
        "line": 228,
        "fullcodeline": "write_unlock_bh(&bond->lock);"
    },
    {
        "line": 230,
        "fullcodeline": "bond_compute_features(bond);"
    },
    {
        "line": 232,
        "fullcodeline": "read_lock(&bond->lock);"
    },
    {
        "line": 234,
        "fullcodeline": "new_slave->last_arp_rx = jiffies;"
    },
    {
        "line": 294,
        "fullcodeline": "write_lock_bh(&bond->curr_slave_lock);"
    },
    {
        "line": 345,
        "fullcodeline": "bond_set_carrier(bond);"
    },
    {
        "line": 363,
        "fullcodeline": "res = bond_create_slave_symlinks(bond_dev, slave_dev);"
    },
    {
        "line": 367,
        "fullcodeline": "res = netdev_rx_handler_register(slave_dev, bond_handle_frame,"
    },
    {
        "line": 384,
        "fullcodeline": "bond_destroy_slave_symlinks(bond_dev, slave_dev);"
    },
    {
        "line": 387,
        "fullcodeline": "dev_close(slave_dev);"
    },
    {
        "line": 390,
        "fullcodeline": "netdev_set_bond_master(slave_dev, NULL);"
    },
    {
        "line": 404,
        "fullcodeline": "dev_set_mtu(slave_dev, new_slave->original_mtu);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL &&"
    },
    {
        "line": 18,
        "fullcodeline": "if (slave_dev->flags & IFF_SLAVE) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {"
    },
    {
        "line": 46,
        "fullcodeline": "if ((slave_dev->flags & IFF_UP)) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (bond->slave_cnt == 0) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (slave_ops->ndo_set_mac_address == NULL) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (is_zero_ether_addr(bond->dev->dev_addr))"
    },
    {
        "line": 119,
        "fullcodeline": "if (!new_slave) {"
    },
    {
        "line": 145,
        "fullcodeline": "if (!bond->params.fail_over_mac) {"
    },
    {
        "line": 176,
        "fullcodeline": "if (bond_is_lb(bond)) {"
    },
    {
        "line": 212,
        "fullcodeline": "if (bond->params.mode == BOND_MODE_8023AD) {"
    },
    {
        "line": 236,
        "fullcodeline": "if (bond->params.miimon && !bond->params.use_carrier) {"
    },
    {
        "line": 286,
        "fullcodeline": "if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {"
    },
    {
        "line": 12,
        "fullcodeline": "slave_ops->ndo_do_ioctl == NULL) {"
    },
    {
        "line": 13,
        "fullcodeline": "pr_warning(\"%s: Warning: no link monitoring support for %s\\n\","
    },
    {
        "line": 19,
        "fullcodeline": "pr_debug(\"Error, Device was already enslaved\\n\");"
    },
    {
        "line": 26,
        "fullcodeline": "pr_debug(\"%s: NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);"
    },
    {
        "line": 49,
        "fullcodeline": "res = -EPERM;"
    },
    {
        "line": 114,
        "fullcodeline": "memcpy(bond->dev->dev_addr, slave_dev->dev_addr,"
    },
    {
        "line": 120,
        "fullcodeline": "res = -ENOMEM;"
    },
    {
        "line": 134,
        "fullcodeline": "pr_debug(\"Error %d calling dev_set_mtu\\n\", res);"
    },
    {
        "line": 150,
        "fullcodeline": "memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);"
    },
    {
        "line": 151,
        "fullcodeline": "addr.sa_family = slave_dev->type;"
    },
    {
        "line": 152,
        "fullcodeline": "res = dev_set_mac_address(slave_dev, &addr);"
    },
    {
        "line": 161,
        "fullcodeline": "pr_debug(\"Error %d calling netdev_set_bond_master\\n\", res);"
    },
    {
        "line": 168,
        "fullcodeline": "pr_debug(\"Opening slave %s failed\\n\", slave_dev->name);"
    },
    {
        "line": 180,
        "fullcodeline": "res = bond_alb_init_slave(bond, new_slave);"
    },
    {
        "line": 190,
        "fullcodeline": "if (!USES_PRIMARY(bond->params.mode)) {"
    },
    {
        "line": 205,
        "fullcodeline": "netif_addr_lock_bh(bond_dev);"
    },
    {
        "line": 207,
        "fullcodeline": "netdev_for_each_mc_addr(ha, bond_dev)"
    },
    {
        "line": 208,
        "fullcodeline": "dev_mc_add(slave_dev, ha->addr);"
    },
    {
        "line": 209,
        "fullcodeline": "netif_addr_unlock_bh(bond_dev);"
    },
    {
        "line": 214,
        "fullcodeline": "u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;"
    },
    {
        "line": 216,
        "fullcodeline": "dev_mc_add(slave_dev, lacpdu_multicast);"
    },
    {
        "line": 237,
        "fullcodeline": "link_reporting = bond_check_dev_link(bond, slave_dev, 1);"
    },
    {
        "line": 259,
        "fullcodeline": "if (!bond->params.miimon ||"
    },
    {
        "line": 260,
        "fullcodeline": "(bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) {"
    },
    {
        "line": 269,
        "fullcodeline": "new_slave->jiffies = jiffies;"
    },
    {
        "line": 275,
        "fullcodeline": "if (bond_update_speed_duplex(new_slave) &&"
    },
    {
        "line": 276,
        "fullcodeline": "(new_slave->link != BOND_LINK_DOWN)) {"
    },
    {
        "line": 277,
        "fullcodeline": "pr_warning(\"%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\\n\","
    },
    {
        "line": 298,
        "fullcodeline": "bond_set_slave_inactive_flags(new_slave);"
    },
    {
        "line": 299,
        "fullcodeline": "bond_select_active_slave(bond);"
    },
    {
        "line": 306,
        "fullcodeline": "bond_set_slave_inactive_flags(new_slave);"
    },
    {
        "line": 319,
        "fullcodeline": "bond_3ad_bind_slave(new_slave);"
    },
    {
        "line": 323,
        "fullcodeline": "bond_set_active_slave(new_slave);"
    },
    {
        "line": 324,
        "fullcodeline": "bond_set_slave_inactive_flags(new_slave);"
    },
    {
        "line": 325,
        "fullcodeline": "bond_select_active_slave(bond);"
    },
    {
        "line": 331,
        "fullcodeline": "bond_set_active_slave(new_slave);"
    },
    {
        "line": 370,
        "fullcodeline": "pr_debug(\"Error %d calling netdev_rx_handler_register\\n\", res);"
    },
    {
        "line": 376,
        "fullcodeline": "bond_is_active_slave(new_slave) ? \"n active\" : \" backup\","
    },
    {
        "line": 398,
        "fullcodeline": "memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);"
    },
    {
        "line": 399,
        "fullcodeline": "addr.sa_family = slave_dev->type;"
    },
    {
        "line": 400,
        "fullcodeline": "dev_set_mac_address(slave_dev, &addr);"
    },
    {
        "line": 20,
        "fullcodeline": "return -EBUSY;"
    },
    {
        "line": 27,
        "fullcodeline": "if (bond_vlan_used(bond)) {"
    },
    {
        "line": 37,
        "fullcodeline": "pr_debug(\"%s: ! NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);"
    },
    {
        "line": 61,
        "fullcodeline": "if (bond_dev->type != slave_dev->type) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (bond->slave_cnt == 0) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (bond_dev->flags & IFF_PROMISC) {"
    },
    {
        "line": 199,
        "fullcodeline": "if (bond_dev->flags & IFF_ALLMULTI) {"
    },
    {
        "line": 272,
        "fullcodeline": "new_slave->link  = BOND_LINK_DOWN;"
    },
    {
        "line": 280,
        "fullcodeline": "if (bond->params.mode == BOND_MODE_8023AD) {"
    },
    {
        "line": 308,
        "fullcodeline": "if (bond->slave_cnt == 1) {"
    },
    {
        "line": 337,
        "fullcodeline": "if (!bond->curr_active_slave)"
    },
    {
        "line": 62,
        "fullcodeline": "pr_debug(\"%s: change device type from %d to %d\\n\","
    },
    {
        "line": 66,
        "fullcodeline": "res = netdev_bonding_change(bond_dev,"
    },
    {
        "line": 77,
        "fullcodeline": "dev_uc_flush(bond_dev);"
    },
    {
        "line": 78,
        "fullcodeline": "dev_mc_flush(bond_dev);"
    },
    {
        "line": 85,
        "fullcodeline": "netdev_bonding_change(bond_dev,"
    },
    {
        "line": 88,
        "fullcodeline": "} else if (bond_dev->type != slave_dev->type) {"
    },
    {
        "line": 98,
        "fullcodeline": "pr_warning(\"%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.\","
    },
    {
        "line": 100,
        "fullcodeline": "bond->params.fail_over_mac = BOND_FOM_ACTIVE;"
    },
    {
        "line": 154,
        "fullcodeline": "pr_debug(\"Error %d calling set_mac_address\\n\", res);"
    },
    {
        "line": 193,
        "fullcodeline": "res = dev_set_promiscuity(slave_dev, 1);"
    },
    {
        "line": 200,
        "fullcodeline": "res = dev_set_allmulti(slave_dev, 1);"
    },
    {
        "line": 239,
        "fullcodeline": "if ((link_reporting == -1) && !bond->params.arp_interval) {"
    },
    {
        "line": 249,
        "fullcodeline": "pr_warning(\"%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\\n\","
    },
    {
        "line": 263,
        "fullcodeline": "new_slave->link  = BOND_LINK_BACK;"
    },
    {
        "line": 264,
        "fullcodeline": "new_slave->delay = bond->params.updelay;"
    },
    {
        "line": 281,
        "fullcodeline": "pr_warning(\"%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\\n\","
    },
    {
        "line": 288,
        "fullcodeline": "if (strcmp(bond->params.primary, new_slave->dev->name) == 0) {"
    },
    {
        "line": 289,
        "fullcodeline": "bond->primary_slave = new_slave;"
    },
    {
        "line": 290,
        "fullcodeline": "bond->force_primary = true;"
    },
    {
        "line": 313,
        "fullcodeline": "bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL);"
    },
    {
        "line": 338,
        "fullcodeline": "bond->curr_active_slave = new_slave;"
    },
    {
        "line": 30,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 32,
        "fullcodeline": "pr_warning(\"%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\\n\","
    },
    {
        "line": 68,
        "fullcodeline": "res = notifier_to_errno(res);"
    },
    {
        "line": 80,
        "fullcodeline": "if (slave_dev->type != ARPHRD_ETHER)"
    },
    {
        "line": 92,
        "fullcodeline": "res = -EINVAL;"
    },
    {
        "line": 267,
        "fullcodeline": "new_slave->link  = BOND_LINK_UP;"
    },
    {
        "line": 72,
        "fullcodeline": "res = -EBUSY;"
    },
    {
        "line": 81,
        "fullcodeline": "bond_setup_by_slave(bond_dev, slave_dev);"
    },
    {
        "line": 101,
        "fullcodeline": "} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {"
    },
    {
        "line": 309,
        "fullcodeline": "SLAVE_AD_INFO(new_slave).id = 1;"
    },
    {
        "line": 83,
        "fullcodeline": "ether_setup(bond_dev);"
    },
    {
        "line": 104,
        "fullcodeline": "res = -EOPNOTSUPP;"
    },
    {
        "line": 251,
        "fullcodeline": "} else if (link_reporting == -1) {"
    },
    {
        "line": 253,
        "fullcodeline": "pr_warning(\"%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\\n\","
    },
    {
        "line": 315,
        "fullcodeline": "SLAVE_AD_INFO(new_slave).id ="
    },
    {
        "line": 316,
        "fullcodeline": "SLAVE_AD_INFO(new_slave->prev).id + 1;"
    }
]