[
    {
        "line": 3,
        "fullcodeline": "struct bonding *bond = netdev_priv(bond_dev);"
    },
    {
        "line": 4,
        "fullcodeline": "const struct net_device_ops *slave_ops = slave_dev->netdev_ops;"
    },
    {
        "line": 5,
        "fullcodeline": "struct slave *new_slave = NULL;"
    },
    {
        "line": 9,
        "fullcodeline": "int res = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "call_netdevice_notifiers(NETDEV_JOIN, slave_dev);"
    },
    {
        "line": 120,
        "fullcodeline": "new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);"
    },
    {
        "line": 130,
        "fullcodeline": "new_slave->queue_id = 0;"
    },
    {
        "line": 133,
        "fullcodeline": "new_slave->original_mtu = slave_dev->mtu;"
    },
    {
        "line": 134,
        "fullcodeline": "res = dev_set_mtu(slave_dev, bond->dev->mtu);"
    },
    {
        "line": 145,
        "fullcodeline": "memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);"
    },
    {
        "line": 161,
        "fullcodeline": "res = netdev_set_bond_master(slave_dev, bond_dev);"
    },
    {
        "line": 168,
        "fullcodeline": "res = dev_open(slave_dev);"
    },
    {
        "line": 174,
        "fullcodeline": "new_slave->bond = bond;"
    },
    {
        "line": 175,
        "fullcodeline": "new_slave->dev = slave_dev;"
    },
    {
        "line": 176,
        "fullcodeline": "slave_dev->priv_flags |= IFF_BONDING;"
    },
    {
        "line": 221,
        "fullcodeline": "bond_add_vlans_on_slave(bond, slave_dev);"
    },
    {
        "line": 223,
        "fullcodeline": "write_lock_bh(&bond->lock);"
    },
    {
        "line": 225,
        "fullcodeline": "bond_attach_slave(bond, new_slave);"
    },
    {
        "line": 227,
        "fullcodeline": "new_slave->delay = 0;"
    },
    {
        "line": 228,
        "fullcodeline": "new_slave->link_failure_count = 0;"
    },
    {
        "line": 230,
        "fullcodeline": "write_unlock_bh(&bond->lock);"
    },
    {
        "line": 232,
        "fullcodeline": "bond_compute_features(bond);"
    },
    {
        "line": 234,
        "fullcodeline": "read_lock(&bond->lock);"
    },
    {
        "line": 236,
        "fullcodeline": "new_slave->last_arp_rx = jiffies;"
    },
    {
        "line": 296,
        "fullcodeline": "write_lock_bh(&bond->curr_slave_lock);"
    },
    {
        "line": 345,
        "fullcodeline": "write_unlock_bh(&bond->curr_slave_lock);"
    },
    {
        "line": 347,
        "fullcodeline": "bond_set_carrier(bond);"
    },
    {
        "line": 363,
        "fullcodeline": "read_unlock(&bond->lock);"
    },
    {
        "line": 365,
        "fullcodeline": "res = bond_create_slave_symlinks(bond_dev, slave_dev);"
    },
    {
        "line": 369,
        "fullcodeline": "res = netdev_rx_handler_register(slave_dev, bond_handle_frame,"
    },
    {
        "line": 376,
        "fullcodeline": "pr_info(\"%s: enslaving %s as a%s interface with a%s link.\\n\","
    },
    {
        "line": 386,
        "fullcodeline": "bond_destroy_slave_symlinks(bond_dev, slave_dev);"
    },
    {
        "line": 389,
        "fullcodeline": "dev_close(slave_dev);"
    },
    {
        "line": 392,
        "fullcodeline": "netdev_set_bond_master(slave_dev, NULL);"
    },
    {
        "line": 406,
        "fullcodeline": "dev_set_mtu(slave_dev, new_slave->original_mtu);"
    },
    {
        "line": 409,
        "fullcodeline": "kfree(new_slave);"
    },
    {
        "line": 412,
        "fullcodeline": "bond_compute_features(bond);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL &&"
    },
    {
        "line": 18,
        "fullcodeline": "if (slave_dev->flags & IFF_SLAVE) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {"
    },
    {
        "line": 46,
        "fullcodeline": "if ((slave_dev->flags & IFF_UP)) {"
    },
    {
        "line": 60,
        "fullcodeline": "if (bond->slave_cnt == 0) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (slave_ops->ndo_set_mac_address == NULL) {"
    },
    {
        "line": 121,
        "fullcodeline": "if (!new_slave) {"
    },
    {
        "line": 147,
        "fullcodeline": "if (!bond->params.fail_over_mac) {"
    },
    {
        "line": 178,
        "fullcodeline": "if (bond_is_lb(bond)) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (!USES_PRIMARY(bond->params.mode)) {"
    },
    {
        "line": 214,
        "fullcodeline": "if (bond->params.mode == BOND_MODE_8023AD) {"
    },
    {
        "line": 238,
        "fullcodeline": "if (bond->params.miimon && !bond->params.use_carrier) {"
    },
    {
        "line": 261,
        "fullcodeline": "if (!bond->params.miimon ||"
    },
    {
        "line": 277,
        "fullcodeline": "if (bond_update_speed_duplex(new_slave) &&"
    },
    {
        "line": 288,
        "fullcodeline": "if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {"
    },
    {
        "line": 378,
        "fullcodeline": "bond_is_active_slave(new_slave) ? \"n active\" : \" backup\","
    },
    {
        "line": 379,
        "fullcodeline": "new_slave->link != BOND_LINK_DOWN ? \"n up\" : \" down\");"
    },
    {
        "line": 395,
        "fullcodeline": "if (!bond->params.fail_over_mac) {"
    },
    {
        "line": 12,
        "fullcodeline": "slave_ops->ndo_do_ioctl == NULL) {"
    },
    {
        "line": 13,
        "fullcodeline": "pr_warning(\"%s: Warning: no link monitoring support for %s\\n\","
    },
    {
        "line": 19,
        "fullcodeline": "pr_debug(\"Error, Device was already enslaved\\n\");"
    },
    {
        "line": 26,
        "fullcodeline": "pr_debug(\"%s: NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);"
    },
    {
        "line": 47,
        "fullcodeline": "pr_err(\"%s is up. This may be due to an out of date ifenslave.\\n\","
    },
    {
        "line": 49,
        "fullcodeline": "res = -EPERM;"
    },
    {
        "line": 116,
        "fullcodeline": "memcpy(bond->dev->dev_addr, slave_dev->dev_addr,"
    },
    {
        "line": 122,
        "fullcodeline": "res = -ENOMEM;"
    },
    {
        "line": 136,
        "fullcodeline": "pr_debug(\"Error %d calling dev_set_mtu\\n\", res);"
    },
    {
        "line": 152,
        "fullcodeline": "memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);"
    },
    {
        "line": 153,
        "fullcodeline": "addr.sa_family = slave_dev->type;"
    },
    {
        "line": 154,
        "fullcodeline": "res = dev_set_mac_address(slave_dev, &addr);"
    },
    {
        "line": 163,
        "fullcodeline": "pr_debug(\"Error %d calling netdev_set_bond_master\\n\", res);"
    },
    {
        "line": 170,
        "fullcodeline": "pr_debug(\"Opening slave %s failed\\n\", slave_dev->name);"
    },
    {
        "line": 182,
        "fullcodeline": "res = bond_alb_init_slave(bond, new_slave);"
    },
    {
        "line": 207,
        "fullcodeline": "netif_addr_lock_bh(bond_dev);"
    },
    {
        "line": 209,
        "fullcodeline": "netdev_for_each_mc_addr(ha, bond_dev)"
    },
    {
        "line": 210,
        "fullcodeline": "dev_mc_add(slave_dev, ha->addr);"
    },
    {
        "line": 211,
        "fullcodeline": "netif_addr_unlock_bh(bond_dev);"
    },
    {
        "line": 216,
        "fullcodeline": "u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;"
    },
    {
        "line": 218,
        "fullcodeline": "dev_mc_add(slave_dev, lacpdu_multicast);"
    },
    {
        "line": 239,
        "fullcodeline": "link_reporting = bond_check_dev_link(bond, slave_dev, 1);"
    },
    {
        "line": 262,
        "fullcodeline": "(bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) {"
    },
    {
        "line": 271,
        "fullcodeline": "new_slave->jiffies = jiffies;"
    },
    {
        "line": 278,
        "fullcodeline": "(new_slave->link != BOND_LINK_DOWN)) {"
    },
    {
        "line": 279,
        "fullcodeline": "pr_warning(\"%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\\n\","
    },
    {
        "line": 300,
        "fullcodeline": "bond_set_slave_inactive_flags(new_slave);"
    },
    {
        "line": 301,
        "fullcodeline": "bond_select_active_slave(bond);"
    },
    {
        "line": 308,
        "fullcodeline": "bond_set_slave_inactive_flags(new_slave);"
    },
    {
        "line": 321,
        "fullcodeline": "bond_3ad_bind_slave(new_slave);"
    },
    {
        "line": 325,
        "fullcodeline": "bond_set_active_slave(new_slave);"
    },
    {
        "line": 326,
        "fullcodeline": "bond_set_slave_inactive_flags(new_slave);"
    },
    {
        "line": 327,
        "fullcodeline": "bond_select_active_slave(bond);"
    },
    {
        "line": 330,
        "fullcodeline": "pr_debug(\"This slave is always active in trunk mode\\n\");"
    },
    {
        "line": 333,
        "fullcodeline": "bond_set_active_slave(new_slave);"
    },
    {
        "line": 372,
        "fullcodeline": "pr_debug(\"Error %d calling netdev_rx_handler_register\\n\", res);"
    },
    {
        "line": 400,
        "fullcodeline": "memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);"
    },
    {
        "line": 401,
        "fullcodeline": "addr.sa_family = slave_dev->type;"
    },
    {
        "line": 402,
        "fullcodeline": "dev_set_mac_address(slave_dev, &addr);"
    },
    {
        "line": 20,
        "fullcodeline": "return -EBUSY;"
    },
    {
        "line": 27,
        "fullcodeline": "if (bond_vlan_used(bond)) {"
    },
    {
        "line": 37,
        "fullcodeline": "pr_debug(\"%s: ! NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);"
    },
    {
        "line": 61,
        "fullcodeline": "if (bond_dev->type != slave_dev->type) {"
    },
    {
        "line": 99,
        "fullcodeline": "if (bond->slave_cnt == 0) {"
    },
    {
        "line": 194,
        "fullcodeline": "if (bond_dev->flags & IFF_PROMISC) {"
    },
    {
        "line": 201,
        "fullcodeline": "if (bond_dev->flags & IFF_ALLMULTI) {"
    },
    {
        "line": 241,
        "fullcodeline": "if ((link_reporting == -1) && !bond->params.arp_interval) {"
    },
    {
        "line": 273,
        "fullcodeline": "pr_debug(\"Initial state of slave_dev is BOND_LINK_DOWN\\n\");"
    },
    {
        "line": 274,
        "fullcodeline": "new_slave->link  = BOND_LINK_DOWN;"
    },
    {
        "line": 282,
        "fullcodeline": "if (bond->params.mode == BOND_MODE_8023AD) {"
    },
    {
        "line": 290,
        "fullcodeline": "if (strcmp(bond->params.primary, new_slave->dev->name) == 0) {"
    },
    {
        "line": 310,
        "fullcodeline": "if (bond->slave_cnt == 1) {"
    },
    {
        "line": 339,
        "fullcodeline": "if (!bond->curr_active_slave)"
    },
    {
        "line": 28,
        "fullcodeline": "pr_err(\"%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\\n\","
    },
    {
        "line": 62,
        "fullcodeline": "pr_debug(\"%s: change device type from %d to %d\\n\","
    },
    {
        "line": 66,
        "fullcodeline": "res = netdev_bonding_change(bond_dev,"
    },
    {
        "line": 68,
        "fullcodeline": "res = notifier_to_errno(res);"
    },
    {
        "line": 77,
        "fullcodeline": "dev_uc_flush(bond_dev);"
    },
    {
        "line": 78,
        "fullcodeline": "dev_mc_flush(bond_dev);"
    },
    {
        "line": 87,
        "fullcodeline": "netdev_bonding_change(bond_dev,"
    },
    {
        "line": 90,
        "fullcodeline": "} else if (bond_dev->type != slave_dev->type) {"
    },
    {
        "line": 100,
        "fullcodeline": "pr_warning(\"%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.\","
    },
    {
        "line": 102,
        "fullcodeline": "bond->params.fail_over_mac = BOND_FOM_ACTIVE;"
    },
    {
        "line": 156,
        "fullcodeline": "pr_debug(\"Error %d calling set_mac_address\\n\", res);"
    },
    {
        "line": 195,
        "fullcodeline": "res = dev_set_promiscuity(slave_dev, 1);"
    },
    {
        "line": 202,
        "fullcodeline": "res = dev_set_allmulti(slave_dev, 1);"
    },
    {
        "line": 251,
        "fullcodeline": "pr_warning(\"%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\\n\","
    },
    {
        "line": 264,
        "fullcodeline": "pr_debug(\"Initial state of slave_dev is BOND_LINK_BACK\\n\");"
    },
    {
        "line": 265,
        "fullcodeline": "new_slave->link  = BOND_LINK_BACK;"
    },
    {
        "line": 283,
        "fullcodeline": "pr_warning(\"%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\\n\","
    },
    {
        "line": 291,
        "fullcodeline": "bond->primary_slave = new_slave;"
    },
    {
        "line": 292,
        "fullcodeline": "bond->force_primary = true;"
    },
    {
        "line": 311,
        "fullcodeline": "SLAVE_AD_INFO(new_slave).id = 1;"
    },
    {
        "line": 315,
        "fullcodeline": "bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL);"
    },
    {
        "line": 340,
        "fullcodeline": "bond->curr_active_slave = new_slave;"
    },
    {
        "line": 30,
        "fullcodeline": "return -EPERM;"
    },
    {
        "line": 32,
        "fullcodeline": "pr_warning(\"%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\\n\","
    },
    {
        "line": 80,
        "fullcodeline": "if (slave_dev->type != ARPHRD_ETHER)"
    },
    {
        "line": 91,
        "fullcodeline": "pr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\","
    },
    {
        "line": 94,
        "fullcodeline": "res = -EINVAL;"
    },
    {
        "line": 268,
        "fullcodeline": "pr_debug(\"Initial state of slave_dev is BOND_LINK_UP\\n\");"
    },
    {
        "line": 269,
        "fullcodeline": "new_slave->link  = BOND_LINK_UP;"
    },
    {
        "line": 317,
        "fullcodeline": "SLAVE_AD_INFO(new_slave).id ="
    },
    {
        "line": 70,
        "fullcodeline": "pr_err(\"%s: refused to change device type\\n\","
    },
    {
        "line": 72,
        "fullcodeline": "res = -EBUSY;"
    },
    {
        "line": 81,
        "fullcodeline": "bond_setup_by_slave(bond_dev, slave_dev);"
    },
    {
        "line": 103,
        "fullcodeline": "} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {"
    },
    {
        "line": 253,
        "fullcodeline": "} else if (link_reporting == -1) {"
    },
    {
        "line": 318,
        "fullcodeline": "SLAVE_AD_INFO(new_slave->prev).id + 1;"
    },
    {
        "line": 83,
        "fullcodeline": "ether_setup(bond_dev);"
    },
    {
        "line": 84,
        "fullcodeline": "bond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;"
    },
    {
        "line": 104,
        "fullcodeline": "pr_err(\"%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\\n\","
    },
    {
        "line": 106,
        "fullcodeline": "res = -EOPNOTSUPP;"
    },
    {
        "line": 255,
        "fullcodeline": "pr_warning(\"%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\\n\","
    }
]