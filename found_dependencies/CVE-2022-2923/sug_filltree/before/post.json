[
    {
        "line": 6,
        "fullcodeline": "idx_T\tarridx[MAXWLEN];"
    },
    {
        "line": 7,
        "fullcodeline": "int\t\tcuri[MAXWLEN];"
    },
    {
        "line": 8,
        "fullcodeline": "char_u\ttword[MAXWLEN];"
    },
    {
        "line": 9,
        "fullcodeline": "char_u\ttsalword[MAXWLEN];"
    },
    {
        "line": 12,
        "fullcodeline": "unsigned\twords_done = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "int\t\twordcount[MAXWLEN];"
    },
    {
        "line": 16,
        "fullcodeline": "spin->si_foldroot = wordtree_alloc(spin);"
    },
    {
        "line": 21,
        "fullcodeline": "spin->si_sugtree = TRUE;"
    },
    {
        "line": 27,
        "fullcodeline": "byts = slang->sl_fbyts;"
    },
    {
        "line": 28,
        "fullcodeline": "idxs = slang->sl_fidxs;"
    },
    {
        "line": 30,
        "fullcodeline": "arridx[0] = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "curi[0] = 1;"
    },
    {
        "line": 32,
        "fullcodeline": "wordcount[0] = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "depth = 0;"
    },
    {
        "line": 94,
        "fullcodeline": "smsg(_(\"Total number of words: %d\"), words_done);"
    },
    {
        "line": 17,
        "fullcodeline": "if (spin->si_foldroot == NULL)"
    },
    {
        "line": 35,
        "fullcodeline": "while (depth >= 0 && !got_int)"
    },
    {
        "line": 37,
        "fullcodeline": "if (curi[depth] > byts[arridx[depth]])"
    },
    {
        "line": 40,
        "fullcodeline": "idxs[arridx[depth]] = wordcount[depth];"
    },
    {
        "line": 44,
        "fullcodeline": "--depth;"
    },
    {
        "line": 45,
        "fullcodeline": "line_breakcheck();"
    },
    {
        "line": 41,
        "fullcodeline": "if (depth > 0)"
    },
    {
        "line": 51,
        "fullcodeline": "n = arridx[depth] + curi[depth];"
    },
    {
        "line": 52,
        "fullcodeline": "++curi[depth];"
    },
    {
        "line": 54,
        "fullcodeline": "c = byts[n];"
    },
    {
        "line": 42,
        "fullcodeline": "wordcount[depth - 1] += wordcount[depth];"
    },
    {
        "line": 55,
        "fullcodeline": "if (c == 0)"
    },
    {
        "line": 58,
        "fullcodeline": "tword[depth] = NUL;"
    },
    {
        "line": 59,
        "fullcodeline": "spell_soundfold(slang, tword, TRUE, tsalword);"
    },
    {
        "line": 68,
        "fullcodeline": "++words_done;"
    },
    {
        "line": 69,
        "fullcodeline": "++wordcount[depth];"
    },
    {
        "line": 73,
        "fullcodeline": "spin->si_blocks_cnt = 0;"
    },
    {
        "line": 63,
        "fullcodeline": "if (tree_add_word(spin, tsalword, spin->si_foldroot,"
    },
    {
        "line": 77,
        "fullcodeline": "while (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)"
    },
    {
        "line": 86,
        "fullcodeline": "tword[depth++] = c;"
    },
    {
        "line": 87,
        "fullcodeline": "arridx[depth] = idxs[n];"
    },
    {
        "line": 88,
        "fullcodeline": "curi[depth] = 1;"
    },
    {
        "line": 89,
        "fullcodeline": "wordcount[depth] = 0;"
    },
    {
        "line": 79,
        "fullcodeline": "++n;"
    },
    {
        "line": 80,
        "fullcodeline": "++curi[depth];"
    },
    {
        "line": 64,
        "fullcodeline": "words_done >> 16, words_done & 0xffff,"
    }
]