[
    {
        "line": 12,
        "fullcodeline": "size_t Data_Buf_Size = 1024;"
    },
    {
        "line": 13,
        "fullcodeline": "char Buf[1024];"
    },
    {
        "line": 14,
        "fullcodeline": "int Timeout = -1;"
    },
    {
        "line": 16,
        "fullcodeline": "parse_status_t status = PARSE_OK;"
    },
    {
        "line": 17,
        "fullcodeline": "int ok_on_close = FALSE;"
    },
    {
        "line": 18,
        "fullcodeline": "size_t entity_offset = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "int num_read = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "int ret_code = HTTP_OK;"
    },
    {
        "line": 35,
        "fullcodeline": "parser->position = POS_ENTITY;"
    },
    {
        "line": 22,
        "fullcodeline": "if (Instr && Instr->IsVirtualFile) {"
    },
    {
        "line": 113,
        "fullcodeline": "} while (parser->position != POS_COMPLETE ||"
    },
    {
        "line": 116,
        "fullcodeline": "if (Instr && Instr->IsVirtualFile) {"
    },
    {
        "line": 23,
        "fullcodeline": "Fp = (virtualDirCallback.open) (filename, UPNP_WRITE);"
    },
    {
        "line": 96,
        "fullcodeline": "memcpy(Buf,"
    },
    {
        "line": 99,
        "fullcodeline": "entity_offset += Data_Buf_Size;"
    },
    {
        "line": 114,
        "fullcodeline": "entity_offset != parser->msg.entity.length);"
    },
    {
        "line": 117,
        "fullcodeline": "virtualDirCallback.close(Fp);"
    },
    {
        "line": 24,
        "fullcodeline": "if (Fp == NULL)"
    },
    {
        "line": 38,
        "fullcodeline": "if (parser->position != POS_COMPLETE)"
    },
    {
        "line": 40,
        "fullcodeline": "if (status == PARSE_INCOMPLETE_ENTITY) {"
    },
    {
        "line": 51,
        "fullcodeline": "while (entity_offset + Data_Buf_Size > parser->msg.entity.length &&"
    },
    {
        "line": 92,
        "fullcodeline": "if ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (Instr && Instr->IsVirtualFile) {"
    },
    {
        "line": 119,
        "fullcodeline": "fclose(Fp);"
    },
    {
        "line": 39,
        "fullcodeline": "status = parser_parse_entity(parser);"
    },
    {
        "line": 42,
        "fullcodeline": "ok_on_close = TRUE;"
    },
    {
        "line": 52,
        "fullcodeline": "parser->position != POS_COMPLETE) {"
    },
    {
        "line": 53,
        "fullcodeline": "num_read = sock_read(info, Buf, sizeof(Buf), &Timeout);"
    },
    {
        "line": 93,
        "fullcodeline": "Data_Buf_Size ="
    },
    {
        "line": 101,
        "fullcodeline": "int n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);"
    },
    {
        "line": 54,
        "fullcodeline": "if (num_read > 0) {"
    },
    {
        "line": 94,
        "fullcodeline": "parser->msg.entity.length - entity_offset;"
    },
    {
        "line": 97,
        "fullcodeline": "&parser->msg.msg.buf[parser->entity_start_position + entity_offset],"
    },
    {
        "line": 102,
        "fullcodeline": "if (n < 0) {"
    },
    {
        "line": 107,
        "fullcodeline": "size_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);"
    },
    {
        "line": 43,
        "fullcodeline": "} else if ((status != PARSE_SUCCESS)"
    },
    {
        "line": 64,
        "fullcodeline": "status = parser_parse_entity(parser);"
    },
    {
        "line": 103,
        "fullcodeline": "ret_code = HTTP_INTERNAL_SERVER_ERROR;"
    },
    {
        "line": 108,
        "fullcodeline": "if (n != Data_Buf_Size) {"
    },
    {
        "line": 45,
        "fullcodeline": "&& (status != PARSE_INCOMPLETE)) {"
    },
    {
        "line": 47,
        "fullcodeline": "ret_code = HTTP_BAD_REQUEST;"
    },
    {
        "line": 56,
        "fullcodeline": "if (membuffer_append(&parser->msg.msg,"
    },
    {
        "line": 65,
        "fullcodeline": "if (status == PARSE_INCOMPLETE_ENTITY) {"
    },
    {
        "line": 109,
        "fullcodeline": "ret_code = HTTP_INTERNAL_SERVER_ERROR;"
    },
    {
        "line": 44,
        "fullcodeline": "&& (status != PARSE_CONTINUE_1)"
    },
    {
        "line": 59,
        "fullcodeline": "parser->http_error_code ="
    },
    {
        "line": 61,
        "fullcodeline": "ret_code = HTTP_INTERNAL_SERVER_ERROR;"
    },
    {
        "line": 67,
        "fullcodeline": "ok_on_close = TRUE;"
    },
    {
        "line": 74,
        "fullcodeline": "} else if (num_read == 0) {"
    },
    {
        "line": 57,
        "fullcodeline": "Buf, (size_t)num_read) != 0) {"
    },
    {
        "line": 68,
        "fullcodeline": "} else if ((status != PARSE_SUCCESS)"
    },
    {
        "line": 88,
        "fullcodeline": "ret_code = HTTP_SERVICE_UNAVAILABLE;"
    },
    {
        "line": 70,
        "fullcodeline": "&& (status != PARSE_INCOMPLETE)) {"
    },
    {
        "line": 71,
        "fullcodeline": "ret_code = HTTP_BAD_REQUEST;"
    },
    {
        "line": 76,
        "fullcodeline": "UpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,"
    },
    {
        "line": 79,
        "fullcodeline": "print_http_headers(&parser->msg);"
    },
    {
        "line": 80,
        "fullcodeline": "parser->position = POS_COMPLETE;"
    },
    {
        "line": 69,
        "fullcodeline": "&& (status != PARSE_CONTINUE_1)"
    },
    {
        "line": 83,
        "fullcodeline": "parser->http_error_code = HTTP_BAD_REQUEST;"
    },
    {
        "line": 84,
        "fullcodeline": "ret_code = HTTP_BAD_REQUEST;"
    }
]