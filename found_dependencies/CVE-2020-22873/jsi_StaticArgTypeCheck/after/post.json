[
    {
        "line": 2,
        "fullcodeline": "Assert(index>0);"
    },
    {
        "line": 6,
        "fullcodeline": "int ai = index-1+func->callflags.bits.addargs;"
    },
    {
        "line": 28,
        "fullcodeline": "rc = JSI_OK;"
    },
    {
        "line": 4,
        "fullcodeline": "if (interp->typeCheck.parse==0 && interp->typeCheck.all==0)"
    },
    {
        "line": 7,
        "fullcodeline": "if (func->argnames == NULL || ai>=func->argnames->count || ai<0)"
    },
    {
        "line": 10,
        "fullcodeline": "if (typ <= 0)"
    },
    {
        "line": 12,
        "fullcodeline": "if (index == 0 && func && func->type == FC_BUILDIN &&"
    },
    {
        "line": 15,
        "fullcodeline": "if ((typ&JSI_TT_ANY)) return JSI_OK;"
    },
    {
        "line": 16,
        "fullcodeline": "if (index == 0 && atyp == JSI_VT_UNDEF) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (atyp == JSI_VT_UNDEF)"
    },
    {
        "line": 29,
        "fullcodeline": "if (typ&JSI_TT_UNDEFINED && atyp == JSI_TT_UNDEFINED) return rc;"
    },
    {
        "line": 30,
        "fullcodeline": "if (typ&JSI_TT_NUMBER && atyp==JSI_TT_NUMBER) return rc;"
    },
    {
        "line": 31,
        "fullcodeline": "if (typ&JSI_TT_STRING && atyp==JSI_TT_STRING) return rc;"
    },
    {
        "line": 32,
        "fullcodeline": "if (typ&JSI_TT_BOOLEAN && atyp==JSI_TT_BOOLEAN)  return rc;"
    },
    {
        "line": 33,
        "fullcodeline": "if (typ&JSI_TT_ARRAY && atyp==JSI_TT_ARRAY)   return rc;"
    },
    {
        "line": 34,
        "fullcodeline": "if (typ&JSI_TT_FUNCTION && atyp==JSI_TT_FUNCTION) return rc;"
    },
    {
        "line": 35,
        "fullcodeline": "if (typ&JSI_TT_REGEXP && atyp==JSI_TT_REGEXP) return rc;"
    },
    {
        "line": 36,
        "fullcodeline": "if (typ&JSI_TT_USEROBJ && atyp==JSI_TT_USEROBJ) return rc;"
    },
    {
        "line": 37,
        "fullcodeline": "if (typ&JSI_TT_ITEROBJ && atyp==JSI_TT_ITEROBJ) return rc;"
    },
    {
        "line": 38,
        "fullcodeline": "if (typ&JSI_TT_OBJECT && atyp==JSI_TT_OBJECT) return rc;"
    },
    {
        "line": 39,
        "fullcodeline": "if (typ&JSI_TT_NULL && atyp==JSI_TT_NULL) return rc;"
    },
    {
        "line": 42,
        "fullcodeline": "Jsi_DString dStr = {};"
    },
    {
        "line": 43,
        "fullcodeline": "const char *exp = jsi_typeName(interp, typ, &dStr);"
    },
    {
        "line": 44,
        "fullcodeline": "const char *vtyp = jsi_TypeName(interp, (Jsi_ttype)atyp);"
    },
    {
        "line": 45,
        "fullcodeline": "char idxBuf[JSI_MAX_NUMBER_STRING*2];"
    },
    {
        "line": 46,
        "fullcodeline": "idxBuf[0] = 0;"
    },
    {
        "line": 53,
        "fullcodeline": "jsi_TypeMismatch(interp);"
    },
    {
        "line": 54,
        "fullcodeline": "Jsi_DString fStr = {};"
    },
    {
        "line": 55,
        "fullcodeline": "rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\","
    },
    {
        "line": 57,
        "fullcodeline": "Jsi_DSFree(&fStr);"
    },
    {
        "line": 58,
        "fullcodeline": "Jsi_DSFree(&dStr);"
    },
    {
        "line": 13,
        "fullcodeline": "interp->typeCheck.all==0) // Normally do not check return types for builtins."
    },
    {
        "line": 47,
        "fullcodeline": "if (index>0)"
    },
    {
        "line": 17,
        "fullcodeline": "if (!(typ&JSI_TT_VOID))"
    },
    {
        "line": 48,
        "fullcodeline": "snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);"
    },
    {
        "line": 50,
        "fullcodeline": "interp->parseLine = line;"
    },
    {
        "line": 52,
        "fullcodeline": "rc = JSI_ERROR;"
    },
    {
        "line": 56,
        "fullcodeline": "p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, NULL));"
    }
]