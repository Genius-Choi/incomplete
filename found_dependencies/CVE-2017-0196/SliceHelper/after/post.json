[
    {
        "line": 3,
        "fullcodeline": "SparseArraySegment<T>* headSeg = (SparseArraySegment<T>*)pArr->head;"
    },
    {
        "line": 4,
        "fullcodeline": "SparseArraySegment<T>* pnewHeadSeg = (SparseArraySegment<T>*)pnewArr->head;"
    },
    {
        "line": 7,
        "fullcodeline": "js_memcpy_s(pnewHeadSeg->elements, sizeof(T) * newLen, headSeg->elements + start, sizeof(T) * newLen);"
    },
    {
        "line": 8,
        "fullcodeline": "pnewHeadSeg->length = newLen;"
    },
    {
        "line": 10,
        "fullcodeline": "Assert(pnewHeadSeg->length <= pnewHeadSeg->size);"
    },
    {
        "line": 12,
        "fullcodeline": "if (!pArr->HasNoMissingValues())"
    },
    {
        "line": 14,
        "fullcodeline": "for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)"
    },
    {
        "line": 18,
        "fullcodeline": "if (pArr->IsMissingItem(i + start))"
    },
    {
        "line": 21,
        "fullcodeline": "pnewArr->SetHasNoMissingValues(false);"
    },
    {
        "line": 22,
        "fullcodeline": "if (pArr->DirectGetItemAtFull(i + start, &element))"
    },
    {
        "line": 24,
        "fullcodeline": "pnewArr->SetItem(i, element, PropertyOperation_None);"
    }
]