[
    {
        "line": 20,
        "fullcodeline": "int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;"
    },
    {
        "line": 29,
        "fullcodeline": "out_size = 10 + 8 + max_input_expansion + in_len;"
    },
    {
        "line": 30,
        "fullcodeline": "out_buf = flb_malloc(out_size);"
    },
    {
        "line": 39,
        "fullcodeline": "memset(&strm, '\\0', sizeof(strm));"
    },
    {
        "line": 40,
        "fullcodeline": "strm.zalloc    = Z_NULL;"
    },
    {
        "line": 41,
        "fullcodeline": "strm.zfree     = Z_NULL;"
    },
    {
        "line": 42,
        "fullcodeline": "strm.opaque    = Z_NULL;"
    },
    {
        "line": 43,
        "fullcodeline": "strm.next_in   = in_data;"
    },
    {
        "line": 44,
        "fullcodeline": "strm.avail_in  = in_len;"
    },
    {
        "line": 45,
        "fullcodeline": "strm.total_out = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "deflateInit2(&strm, Z_DEFAULT_COMPRESSION,"
    },
    {
        "line": 58,
        "fullcodeline": "gzip_header(out_buf);"
    },
    {
        "line": 61,
        "fullcodeline": "pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;"
    },
    {
        "line": 63,
        "fullcodeline": "flush = Z_NO_FLUSH;"
    },
    {
        "line": 86,
        "fullcodeline": "*out_len = strm.total_out;"
    },
    {
        "line": 89,
        "fullcodeline": "footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;"
    },
    {
        "line": 90,
        "fullcodeline": "pb = (uint8_t *) out_buf + footer_start;"
    },
    {
        "line": 92,
        "fullcodeline": "crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);"
    },
    {
        "line": 93,
        "fullcodeline": "*pb++ = crc & 0xFF;"
    },
    {
        "line": 94,
        "fullcodeline": "*pb++ = (crc >> 8) & 0xFF;"
    },
    {
        "line": 95,
        "fullcodeline": "*pb++ = (crc >> 16) & 0xFF;"
    },
    {
        "line": 96,
        "fullcodeline": "*pb++ = (crc >> 24) & 0xFF;"
    },
    {
        "line": 97,
        "fullcodeline": "*pb++ = in_len & 0xFF;"
    },
    {
        "line": 98,
        "fullcodeline": "*pb++ = (in_len >> 8) & 0xFF;"
    },
    {
        "line": 99,
        "fullcodeline": "*pb++ = (in_len >> 16) & 0xFF;"
    },
    {
        "line": 100,
        "fullcodeline": "*pb++ = (in_len >> 24) & 0xFF;"
    },
    {
        "line": 103,
        "fullcodeline": "*out_len += FLB_GZIP_HEADER_OFFSET + 8;"
    },
    {
        "line": 104,
        "fullcodeline": "*out_data = out_buf;"
    },
    {
        "line": 32,
        "fullcodeline": "if (!out_buf) {"
    },
    {
        "line": 49,
        "fullcodeline": "Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);"
    },
    {
        "line": 82,
        "fullcodeline": "if (deflateEnd(&strm) != Z_OK) {"
    },
    {
        "line": 33,
        "fullcodeline": "flb_errno();"
    },
    {
        "line": 34,
        "fullcodeline": "flb_error(\"[gzip] could not allocate outgoing buffer\");"
    },
    {
        "line": 65,
        "fullcodeline": "strm.next_out  = pb + strm.total_out;"
    },
    {
        "line": 66,
        "fullcodeline": "strm.avail_out = out_size - (pb - (uint8_t *) out_buf);"
    },
    {
        "line": 72,
        "fullcodeline": "status = deflate(&strm, flush);"
    },
    {
        "line": 83,
        "fullcodeline": "flb_free(out_buf);"
    },
    {
        "line": 35,
        "fullcodeline": "return -1;"
    },
    {
        "line": 68,
        "fullcodeline": "if (strm.avail_in == 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (status == Z_STREAM_END) {"
    },
    {
        "line": 84,
        "fullcodeline": "return -1;"
    },
    {
        "line": 69,
        "fullcodeline": "flush = Z_FINISH;"
    },
    {
        "line": 76,
        "fullcodeline": "else if (status != Z_OK) {"
    },
    {
        "line": 77,
        "fullcodeline": "deflateEnd(&strm);"
    },
    {
        "line": 78,
        "fullcodeline": "return -1;"
    }
]