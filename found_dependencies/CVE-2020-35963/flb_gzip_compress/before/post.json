[
    {
        "line": 13,
        "fullcodeline": "out_size = in_len + 32;"
    },
    {
        "line": 14,
        "fullcodeline": "out_buf = flb_malloc(out_size);"
    },
    {
        "line": 22,
        "fullcodeline": "memset(&strm, '\\0', sizeof(strm));"
    },
    {
        "line": 23,
        "fullcodeline": "strm.zalloc    = Z_NULL;"
    },
    {
        "line": 24,
        "fullcodeline": "strm.zfree     = Z_NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "strm.opaque    = Z_NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "strm.next_in   = in_data;"
    },
    {
        "line": 27,
        "fullcodeline": "strm.avail_in  = in_len;"
    },
    {
        "line": 28,
        "fullcodeline": "strm.total_out = 0;"
    },
    {
        "line": 31,
        "fullcodeline": "deflateInit2(&strm, Z_DEFAULT_COMPRESSION,"
    },
    {
        "line": 41,
        "fullcodeline": "gzip_header(out_buf);"
    },
    {
        "line": 44,
        "fullcodeline": "pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;"
    },
    {
        "line": 46,
        "fullcodeline": "flush = Z_NO_FLUSH;"
    },
    {
        "line": 69,
        "fullcodeline": "*out_len = strm.total_out;"
    },
    {
        "line": 72,
        "fullcodeline": "footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;"
    },
    {
        "line": 73,
        "fullcodeline": "pb = (uint8_t *) out_buf + footer_start;"
    },
    {
        "line": 75,
        "fullcodeline": "crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);"
    },
    {
        "line": 76,
        "fullcodeline": "*pb++ = crc & 0xFF;"
    },
    {
        "line": 77,
        "fullcodeline": "*pb++ = (crc >> 8) & 0xFF;"
    },
    {
        "line": 78,
        "fullcodeline": "*pb++ = (crc >> 16) & 0xFF;"
    },
    {
        "line": 79,
        "fullcodeline": "*pb++ = (crc >> 24) & 0xFF;"
    },
    {
        "line": 80,
        "fullcodeline": "*pb++ = in_len & 0xFF;"
    },
    {
        "line": 81,
        "fullcodeline": "*pb++ = (in_len >> 8) & 0xFF;"
    },
    {
        "line": 82,
        "fullcodeline": "*pb++ = (in_len >> 16) & 0xFF;"
    },
    {
        "line": 83,
        "fullcodeline": "*pb++ = (in_len >> 24) & 0xFF;"
    },
    {
        "line": 86,
        "fullcodeline": "*out_len += FLB_GZIP_HEADER_OFFSET + 8;"
    },
    {
        "line": 87,
        "fullcodeline": "*out_data = out_buf;"
    },
    {
        "line": 15,
        "fullcodeline": "if (!out_buf) {"
    },
    {
        "line": 32,
        "fullcodeline": "Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);"
    },
    {
        "line": 65,
        "fullcodeline": "if (deflateEnd(&strm) != Z_OK) {"
    },
    {
        "line": 16,
        "fullcodeline": "flb_errno();"
    },
    {
        "line": 17,
        "fullcodeline": "flb_error(\"[gzip] could not allocate outgoing buffer\");"
    },
    {
        "line": 48,
        "fullcodeline": "strm.next_out  = pb + strm.total_out;"
    },
    {
        "line": 49,
        "fullcodeline": "strm.avail_out = out_size - (pb - (uint8_t *) out_buf);"
    },
    {
        "line": 55,
        "fullcodeline": "status = deflate(&strm, flush);"
    },
    {
        "line": 66,
        "fullcodeline": "flb_free(out_buf);"
    },
    {
        "line": 18,
        "fullcodeline": "return -1;"
    },
    {
        "line": 51,
        "fullcodeline": "if (strm.avail_in == 0) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (status == Z_STREAM_END) {"
    },
    {
        "line": 67,
        "fullcodeline": "return -1;"
    },
    {
        "line": 52,
        "fullcodeline": "flush = Z_FINISH;"
    },
    {
        "line": 59,
        "fullcodeline": "else if (status != Z_OK) {"
    },
    {
        "line": 60,
        "fullcodeline": "deflateEnd(&strm);"
    },
    {
        "line": 61,
        "fullcodeline": "return -1;"
    }
]