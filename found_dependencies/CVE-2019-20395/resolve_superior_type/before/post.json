[
    {
        "line": 8,
        "fullcodeline": "if (!mod_name) {"
    },
    {
        "line": 25,
        "fullcodeline": "if (!mod_name && parent) {"
    },
    {
        "line": 84,
        "fullcodeline": "for (i = 0; i < module->tpdf_size; i++) {"
    },
    {
        "line": 92,
        "fullcodeline": "for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {"
    },
    {
        "line": 107,
        "fullcodeline": "if (match->type.base == LY_TYPE_LEAFREF) {"
    },
    {
        "line": 105,
        "fullcodeline": "*ret = match;"
    },
    {
        "line": 10,
        "fullcodeline": "for (i = 1; i < LY_DATA_TYPE_COUNT; i++) {"
    },
    {
        "line": 77,
        "fullcodeline": "module = lyp_get_module(module, NULL, 0, mod_name, 0, 0);"
    },
    {
        "line": 85,
        "fullcodeline": "if (!strcmp(module->tpdf[i].name, name) && module->tpdf[i].type.base > 0) {"
    },
    {
        "line": 93,
        "fullcodeline": "for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) {"
    },
    {
        "line": 19,
        "fullcodeline": "if (!strcmp(mod_name, module->name)) {"
    },
    {
        "line": 73,
        "fullcodeline": "parent = lys_parent(parent);"
    },
    {
        "line": 78,
        "fullcodeline": "if (!module) {"
    },
    {
        "line": 86,
        "fullcodeline": "match = &module->tpdf[i];"
    },
    {
        "line": 110,
        "fullcodeline": "assert(match);"
    },
    {
        "line": 11,
        "fullcodeline": "if (!strcmp(ly_types[i]->name, name)) {"
    },
    {
        "line": 21,
        "fullcodeline": "mod_name = NULL;"
    },
    {
        "line": 66,
        "fullcodeline": "for (i = 0; i < tpdf_size; i++) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (!strcmp(module->inc[i].submodule->tpdf[j].name, name) && module->inc[i].submodule->tpdf[j].type.base > 0) {"
    },
    {
        "line": 62,
        "fullcodeline": "parent = lys_parent(parent);"
    },
    {
        "line": 79,
        "fullcodeline": "return -1;"
    },
    {
        "line": 95,
        "fullcodeline": "match = &module->inc[i].submodule->tpdf[j];"
    },
    {
        "line": 67,
        "fullcodeline": "if (!strcmp(tpdf[i].name, name) && tpdf[i].type.base > 0) {"
    },
    {
        "line": 13,
        "fullcodeline": "*ret = ly_types[i];"
    },
    {
        "line": 30,
        "fullcodeline": "tpdf_size = ((struct lys_node_container *)parent)->tpdf_size;"
    },
    {
        "line": 31,
        "fullcodeline": "tpdf = ((struct lys_node_container *)parent)->tpdf;"
    },
    {
        "line": 35,
        "fullcodeline": "tpdf_size = ((struct lys_node_list *)parent)->tpdf_size;"
    },
    {
        "line": 36,
        "fullcodeline": "tpdf = ((struct lys_node_list *)parent)->tpdf;"
    },
    {
        "line": 40,
        "fullcodeline": "tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size;"
    },
    {
        "line": 41,
        "fullcodeline": "tpdf = ((struct lys_node_grp *)parent)->tpdf;"
    },
    {
        "line": 46,
        "fullcodeline": "tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size;"
    },
    {
        "line": 47,
        "fullcodeline": "tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;"
    },
    {
        "line": 51,
        "fullcodeline": "tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size;"
    },
    {
        "line": 52,
        "fullcodeline": "tpdf = ((struct lys_node_notif *)parent)->tpdf;"
    },
    {
        "line": 57,
        "fullcodeline": "tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size;"
    },
    {
        "line": 58,
        "fullcodeline": "tpdf = ((struct lys_node_inout *)parent)->tpdf;"
    },
    {
        "line": 68,
        "fullcodeline": "match = &tpdf[i];"
    }
]