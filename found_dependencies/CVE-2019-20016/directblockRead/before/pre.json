[
    {
        "line": 4,
        "fullcodeline": "char buf[4], *name, *value;"
    },
    {
        "line": 13,
        "fullcodeline": "UNUSED(offset);"
    },
    {
        "line": 14,
        "fullcodeline": "UNUSED(block_size);"
    },
    {
        "line": 15,
        "fullcodeline": "UNUSED(block_offset);"
    },
    {
        "line": 33,
        "fullcodeline": "size = (fractalheap->maximum_heap_size + 7) / 8;"
    },
    {
        "line": 40,
        "fullcodeline": "offset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);"
    },
    {
        "line": 18,
        "fullcodeline": "if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {"
    },
    {
        "line": 34,
        "fullcodeline": "block_offset = readValue(reader, size);"
    },
    {
        "line": 41,
        "fullcodeline": "if (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)"
    },
    {
        "line": 19,
        "fullcodeline": "log(\"cannot read signature of fractal heap indirect block\\n\");"
    },
    {
        "line": 24,
        "fullcodeline": "if (fgetc(reader->fhd) != 0) {"
    },
    {
        "line": 30,
        "fullcodeline": "if (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)"
    },
    {
        "line": 42,
        "fullcodeline": "length_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);"
    },
    {
        "line": 64,
        "fullcodeline": "typeandversion = (uint8_t) fgetc(reader->fhd);"
    },
    {
        "line": 65,
        "fullcodeline": "offset = readValue(reader, offset_size);"
    },
    {
        "line": 66,
        "fullcodeline": "length = readValue(reader, length_size);"
    },
    {
        "line": 37,
        "fullcodeline": "if (fseek(reader->fhd, 4, SEEK_CUR))"
    },
    {
        "line": 44,
        "fullcodeline": "length_size = ceilf(log2f(fractalheap->maximum_size) / 8);"
    },
    {
        "line": 73,
        "fullcodeline": "if (typeandversion == 3) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (offset > 0x10000000 || length > 0x10000000)"
    },
    {
        "line": 89,
        "fullcodeline": "name[length]=0;"
    },
    {
        "line": 97,
        "fullcodeline": "len = (int) readValue(reader, 2);"
    },
    {
        "line": 104,
        "fullcodeline": "unknown = readValue(reader, 6);"
    },
    {
        "line": 130,
        "fullcodeline": "log(\" %s = %s\\n\", name, value);"
    },
    {
        "line": 132,
        "fullcodeline": "attr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));"
    },
    {
        "line": 133,
        "fullcodeline": "attr->name = name;"
    },
    {
        "line": 134,
        "fullcodeline": "attr->value = value;"
    },
    {
        "line": 135,
        "fullcodeline": "attr->next = dataobject->attributes;"
    },
    {
        "line": 136,
        "fullcodeline": "dataobject->attributes = attr;"
    },
    {
        "line": 105,
        "fullcodeline": "if (unknown == 0x000000020200)"
    },
    {
        "line": 78,
        "fullcodeline": "if (readValue(reader, 5) != 0x0000040008) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (!(name = malloc(length+1)))"
    },
    {
        "line": 85,
        "fullcodeline": "if (fread(name, 1, length, reader->fhd) != length) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (readValue(reader, 4) != 0x00000013) {"
    },
    {
        "line": 98,
        "fullcodeline": "if (len > 0x1000 || len < 0) {"
    },
    {
        "line": 106,
        "fullcodeline": "value = NULL;"
    },
    {
        "line": 138,
        "fullcodeline": "} else if (typeandversion == 1) {"
    },
    {
        "line": 148,
        "fullcodeline": "len = fgetc(reader->fhd);"
    },
    {
        "line": 159,
        "fullcodeline": "name[len] = 0;"
    },
    {
        "line": 161,
        "fullcodeline": "heap_header_address = readValue(reader,"
    },
    {
        "line": 166,
        "fullcodeline": "dir = malloc(sizeof(struct DIR));"
    },
    {
        "line": 171,
        "fullcodeline": "memset(dir, 0, sizeof(*dir));"
    },
    {
        "line": 173,
        "fullcodeline": "dir->next = dataobject->directory;"
    },
    {
        "line": 174,
        "fullcodeline": "dataobject->directory = dir;"
    },
    {
        "line": 176,
        "fullcodeline": "store = ftell(reader->fhd);"
    },
    {
        "line": 182,
        "fullcodeline": "err = dataobjectRead(reader, &dir->dataobject, name);"
    },
    {
        "line": 107,
        "fullcodeline": "else if (unknown == 0x000000020000) {"
    },
    {
        "line": 142,
        "fullcodeline": "unknown = readValue(reader, 6);"
    },
    {
        "line": 149,
        "fullcodeline": "if (len < 0)"
    },
    {
        "line": 151,
        "fullcodeline": "assert(len < 0x100);"
    },
    {
        "line": 167,
        "fullcodeline": "if (!dir) {"
    },
    {
        "line": 177,
        "fullcodeline": "if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (store < 0) {"
    },
    {
        "line": 117,
        "fullcodeline": "value[len] = 0;"
    },
    {
        "line": 153,
        "fullcodeline": "if (!(name = malloc(len + 1)))"
    },
    {
        "line": 155,
        "fullcodeline": "if (fread(name, 1, len, reader->fhd) != len) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (fseek(reader->fhd, store, SEEK_SET) < 0)"
    },
    {
        "line": 193,
        "fullcodeline": "} else if (typeandversion != 0) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (!(value = malloc(len + 1))) {"
    },
    {
        "line": 112,
        "fullcodeline": "if (fread(value, 1, len, reader->fhd) != len) {"
    },
    {
        "line": 123,
        "fullcodeline": "strcpy(value, \"\");"
    },
    {
        "line": 119,
        "fullcodeline": "if (!(value = malloc(5))) {"
    }
]