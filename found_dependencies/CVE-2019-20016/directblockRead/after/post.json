[
    {
        "line": 4,
        "fullcodeline": "char buf[4], *name, *value;"
    },
    {
        "line": 13,
        "fullcodeline": "UNUSED(offset);"
    },
    {
        "line": 14,
        "fullcodeline": "UNUSED(block_size);"
    },
    {
        "line": 15,
        "fullcodeline": "UNUSED(block_offset);"
    },
    {
        "line": 38,
        "fullcodeline": "size = (fractalheap->maximum_heap_size + 7) / 8;"
    },
    {
        "line": 39,
        "fullcodeline": "block_offset = readValue(reader, size);"
    },
    {
        "line": 45,
        "fullcodeline": "offset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);"
    },
    {
        "line": 207,
        "fullcodeline": "reader->recursive_counter--;"
    },
    {
        "line": 17,
        "fullcodeline": "if(reader->recursive_counter >= 10)"
    },
    {
        "line": 23,
        "fullcodeline": "if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {"
    },
    {
        "line": 29,
        "fullcodeline": "if (fgetc(reader->fhd) != 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)"
    },
    {
        "line": 41,
        "fullcodeline": "if (fractalheap->flags & 2)"
    },
    {
        "line": 46,
        "fullcodeline": "if (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)"
    },
    {
        "line": 205,
        "fullcodeline": "} while (typeandversion != 0);"
    },
    {
        "line": 24,
        "fullcodeline": "log(\"cannot read signature of fractal heap indirect block\\n\");"
    },
    {
        "line": 30,
        "fullcodeline": "log(\"object FHDB must have version 0\\n\");"
    },
    {
        "line": 47,
        "fullcodeline": "length_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);"
    },
    {
        "line": 69,
        "fullcodeline": "typeandversion = (uint8_t) fgetc(reader->fhd);"
    },
    {
        "line": 70,
        "fullcodeline": "offset = readValue(reader, offset_size);"
    },
    {
        "line": 71,
        "fullcodeline": "length = readValue(reader, length_size);"
    },
    {
        "line": 20,
        "fullcodeline": "reader->recursive_counter++;"
    },
    {
        "line": 42,
        "fullcodeline": "if (fseek(reader->fhd, 4, SEEK_CUR))"
    },
    {
        "line": 49,
        "fullcodeline": "length_size = ceilf(log2f(fractalheap->maximum_size) / 8);"
    },
    {
        "line": 72,
        "fullcodeline": "if (offset > 0x10000000 || length > 0x10000000)"
    },
    {
        "line": 78,
        "fullcodeline": "if (typeandversion == 3) {"
    },
    {
        "line": 94,
        "fullcodeline": "name[length]=0;"
    },
    {
        "line": 102,
        "fullcodeline": "len = (int) readValue(reader, 2);"
    },
    {
        "line": 109,
        "fullcodeline": "unknown = readValue(reader, 6);"
    },
    {
        "line": 135,
        "fullcodeline": "log(\" %s = %s\\n\", name, value);"
    },
    {
        "line": 138,
        "fullcodeline": "attr->name = name;"
    },
    {
        "line": 139,
        "fullcodeline": "attr->value = value;"
    },
    {
        "line": 140,
        "fullcodeline": "attr->next = dataobject->attributes;"
    },
    {
        "line": 141,
        "fullcodeline": "dataobject->attributes = attr;"
    },
    {
        "line": 83,
        "fullcodeline": "if (readValue(reader, 5) != 0x0000040008) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (!(name = malloc(length+1)))"
    },
    {
        "line": 90,
        "fullcodeline": "if (fread(name, 1, length, reader->fhd) != length) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (readValue(reader, 4) != 0x00000013) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (len > 0x1000 || len < 0) {"
    },
    {
        "line": 110,
        "fullcodeline": "if (unknown == 0x000000020200)"
    },
    {
        "line": 84,
        "fullcodeline": "log(\"FHDB type 3 unsupported values\");"
    },
    {
        "line": 91,
        "fullcodeline": "free(name);"
    },
    {
        "line": 97,
        "fullcodeline": "log(\"FHDB type 3 unsupported values\");"
    },
    {
        "line": 98,
        "fullcodeline": "free(name);"
    },
    {
        "line": 104,
        "fullcodeline": "free(name);"
    },
    {
        "line": 111,
        "fullcodeline": "value = NULL;"
    },
    {
        "line": 143,
        "fullcodeline": "} else if (typeandversion == 1) {"
    },
    {
        "line": 147,
        "fullcodeline": "unknown = readValue(reader, 6);"
    },
    {
        "line": 153,
        "fullcodeline": "len = fgetc(reader->fhd);"
    },
    {
        "line": 156,
        "fullcodeline": "assert(len < 0x100);"
    },
    {
        "line": 164,
        "fullcodeline": "name[len] = 0;"
    },
    {
        "line": 166,
        "fullcodeline": "heap_header_address = readValue(reader,"
    },
    {
        "line": 176,
        "fullcodeline": "memset(dir, 0, sizeof(*dir));"
    },
    {
        "line": 178,
        "fullcodeline": "dir->next = dataobject->directory;"
    },
    {
        "line": 179,
        "fullcodeline": "dataobject->directory = dir;"
    },
    {
        "line": 181,
        "fullcodeline": "store = ftell(reader->fhd);"
    },
    {
        "line": 187,
        "fullcodeline": "err = dataobjectRead(reader, &dir->dataobject, name);"
    },
    {
        "line": 112,
        "fullcodeline": "else if (unknown == 0x000000020000) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (len < 0)"
    },
    {
        "line": 158,
        "fullcodeline": "if (!(name = malloc(len + 1)))"
    },
    {
        "line": 160,
        "fullcodeline": "if (fread(name, 1, len, reader->fhd) != len) {"
    },
    {
        "line": 172,
        "fullcodeline": "if (!dir) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (fseek(reader->fhd, heap_header_address, SEEK_SET)) {"
    },
    {
        "line": 192,
        "fullcodeline": "if (store < 0) {"
    },
    {
        "line": 195,
        "fullcodeline": "if (fseek(reader->fhd, store, SEEK_SET) < 0)"
    },
    {
        "line": 122,
        "fullcodeline": "value[len] = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "log(\"FHDB type 1 unsupported values\\n\");"
    },
    {
        "line": 161,
        "fullcodeline": "free(name);"
    },
    {
        "line": 173,
        "fullcodeline": "free(name);"
    },
    {
        "line": 183,
        "fullcodeline": "free(name);"
    },
    {
        "line": 198,
        "fullcodeline": "} else if (typeandversion != 0) {"
    },
    {
        "line": 113,
        "fullcodeline": "if (!(value = malloc(len + 1))) {"
    },
    {
        "line": 117,
        "fullcodeline": "if (fread(value, 1, len, reader->fhd) != len) {"
    },
    {
        "line": 200,
        "fullcodeline": "log(\"fractal head unknown type %d\\n\", typeandversion);"
    },
    {
        "line": 114,
        "fullcodeline": "free(name);"
    },
    {
        "line": 118,
        "fullcodeline": "free(value);"
    },
    {
        "line": 119,
        "fullcodeline": "free(name);"
    },
    {
        "line": 123,
        "fullcodeline": "} else if (unknown == 0x20000020000) {"
    },
    {
        "line": 128,
        "fullcodeline": "strcpy(value, \"\");"
    },
    {
        "line": 124,
        "fullcodeline": "if (!(value = malloc(5))) {"
    },
    {
        "line": 131,
        "fullcodeline": "free(name);"
    },
    {
        "line": 125,
        "fullcodeline": "free(name);"
    }
]