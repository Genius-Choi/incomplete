[
    {
        "line": 29,
        "fullcodeline": "efi_clear_bootdev();"
    },
    {
        "line": 31,
        "fullcodeline": "image_addr = buffer;"
    },
    {
        "line": 32,
        "fullcodeline": "image_size = buffer_size;"
    },
    {
        "line": 34,
        "fullcodeline": "ret = efi_dp_from_name(dev, devnr, path, &device, &image);"
    },
    {
        "line": 8,
        "fullcodeline": "if (buffer + buffer_size >= image_addr &&"
    },
    {
        "line": 13,
        "fullcodeline": "if (efi_check_pe(buffer, buffer_size, NULL) != EFI_SUCCESS) {"
    },
    {
        "line": 35,
        "fullcodeline": "if (ret == EFI_SUCCESS) {"
    },
    {
        "line": 9,
        "fullcodeline": "image_addr + image_size >= buffer)"
    },
    {
        "line": 10,
        "fullcodeline": "efi_clear_bootdev();"
    },
    {
        "line": 36,
        "fullcodeline": "bootefi_device_path = device;"
    },
    {
        "line": 44,
        "fullcodeline": "bootefi_image_path = image;"
    },
    {
        "line": 46,
        "fullcodeline": "efi_clear_bootdev();"
    },
    {
        "line": 39,
        "fullcodeline": "struct efi_device_path *image_tmp = image;"
    },
    {
        "line": 41,
        "fullcodeline": "efi_dp_split_file_path(image, &device, &image);"
    },
    {
        "line": 42,
        "fullcodeline": "efi_free_pool(image_tmp);"
    }
]