[
    {
        "line": 10,
        "fullcodeline": "assert("
    },
    {
        "line": 14,
        "fullcodeline": "CodeGenerationSettings codeGenOpts{};"
    },
    {
        "line": 15,
        "fullcodeline": "codeGenOpts.unlimitedRegisters = false;"
    },
    {
        "line": 16,
        "fullcodeline": "codeGenOpts.instrumentIR = compileFlags.instrumentIR;"
    },
    {
        "line": 21,
        "fullcodeline": "optSettings.staticBuiltins = compileFlags.staticBuiltins.hasValue()"
    },
    {
        "line": 25,
        "fullcodeline": "auto context = std::make_shared<Context>(codeGenOpts, optSettings);"
    },
    {
        "line": 26,
        "fullcodeline": "std::unique_ptr<SimpleDiagHandlerRAII> outputManager;"
    },
    {
        "line": 35,
        "fullcodeline": "auto getErrorString = [&outputManager]() {"
    },
    {
        "line": 42,
        "fullcodeline": "context->getSourceErrorManager().setWarningStatus("
    },
    {
        "line": 45,
        "fullcodeline": "context->setStrictMode(compileFlags.strict);"
    },
    {
        "line": 46,
        "fullcodeline": "context->setEnableEval(true);"
    },
    {
        "line": 47,
        "fullcodeline": "context->setPreemptiveFunctionCompilationThreshold("
    },
    {
        "line": 49,
        "fullcodeline": "context->setPreemptiveFileCompilationThreshold("
    },
    {
        "line": 56,
        "fullcodeline": "context->setGeneratorEnabled(compileFlags.enableGenerator);"
    },
    {
        "line": 57,
        "fullcodeline": "context->setDebugInfoSetting("
    },
    {
        "line": 59,
        "fullcodeline": "context->setEmitAsyncBreakCheck(compileFlags.emitAsyncBreakCheck);"
    },
    {
        "line": 71,
        "fullcodeline": "bool isLargeFile ="
    },
    {
        "line": 73,
        "fullcodeline": "int fileBufId = context->getSourceErrorManager().addNewSourceBuffer("
    },
    {
        "line": 82,
        "fullcodeline": "auto parserMode = parser::FullParse;"
    },
    {
        "line": 83,
        "fullcodeline": "bool useStaticBuiltinDetected = false;"
    },
    {
        "line": 92,
        "fullcodeline": "sem::SemContext semCtx{};"
    },
    {
        "line": 93,
        "fullcodeline": "parser::JSParser parser(*context, fileBufId, parserMode);"
    },
    {
        "line": 94,
        "fullcodeline": "auto parsed = parser.parse();"
    },
    {
        "line": 109,
        "fullcodeline": "Module M(context);"
    },
    {
        "line": 110,
        "fullcodeline": "hermes::generateIRFromESTree(parsed.getValue(), &M, declFileList, scopeChain);"
    },
    {
        "line": 118,
        "fullcodeline": "BytecodeGenerationOptions opts{compileFlags.format};"
    },
    {
        "line": 119,
        "fullcodeline": "opts.optimizationEnabled = !!runOptimizationPasses;"
    },
    {
        "line": 120,
        "fullcodeline": "opts.staticBuiltinsEnabled ="
    },
    {
        "line": 122,
        "fullcodeline": "opts.verifyIR = compileFlags.verifyIR;"
    },
    {
        "line": 11,
        "fullcodeline": "buffer->data()[buffer->size()] == 0 &&"
    },
    {
        "line": 52,
        "fullcodeline": "if (compileFlags.lazy && !runOptimizationPasses) {"
    },
    {
        "line": 58,
        "fullcodeline": "compileFlags.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING);"
    },
    {
        "line": 72,
        "fullcodeline": "buffer->size() >= context->getPreemptiveFileCompilationThreshold();"
    },
    {
        "line": 75,
        "fullcodeline": "if (sourceMap != nullptr) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (context->isLazyCompilation() && isLargeFile) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (parserMode != parser::LazyParse) {"
    },
    {
        "line": 123,
        "fullcodeline": "auto bytecode = createBCProviderFromSrc("
    },
    {
        "line": 125,
        "fullcodeline": "bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());"
    },
    {
        "line": 22,
        "fullcodeline": "? compileFlags.staticBuiltins.getValue()"
    },
    {
        "line": 28,
        "fullcodeline": "context->getSourceErrorManager().setDiagHandler(diagHandler, diagContext);"
    },
    {
        "line": 53,
        "fullcodeline": "context->setLazyCompilation(true);"
    },
    {
        "line": 64,
        "fullcodeline": "auto libBuffer = llvh::MemoryBuffer::getMemBuffer(libhermes);"
    },
    {
        "line": 65,
        "fullcodeline": "parser::JSParser libParser(*context, std::move(libBuffer));"
    },
    {
        "line": 66,
        "fullcodeline": "auto libParsed = libParser.parse();"
    },
    {
        "line": 67,
        "fullcodeline": "assert(libParsed && \"Libhermes failed to parse\");"
    },
    {
        "line": 68,
        "fullcodeline": "declFileList.push_back(libParsed.getValue());"
    },
    {
        "line": 74,
        "fullcodeline": "std::make_unique<HermesLLVMMemoryBuffer>(std::move(buffer), sourceURL));"
    },
    {
        "line": 76,
        "fullcodeline": "auto sourceMapTranslator ="
    },
    {
        "line": 78,
        "fullcodeline": "context->getSourceErrorManager().setTranslator(sourceMapTranslator);"
    },
    {
        "line": 79,
        "fullcodeline": "sourceMapTranslator->addSourceMap(fileBufId, std::move(sourceMap));"
    },
    {
        "line": 89,
        "fullcodeline": "parserMode = parser::LazyParse;"
    },
    {
        "line": 95,
        "fullcodeline": "if (!parsed || !hermes::sem::validateAST(*context, semCtx, *parsed)) {"
    },
    {
        "line": 101,
        "fullcodeline": "useStaticBuiltinDetected = parser.getUseStaticBuiltin();"
    },
    {
        "line": 106,
        "fullcodeline": "context->setStaticBuiltinOptimization(useStaticBuiltinDetected);"
    },
    {
        "line": 111,
        "fullcodeline": "if (context->getSourceErrorManager().getErrorCount() > 0) {"
    },
    {
        "line": 116,
        "fullcodeline": "runOptimizationPasses(M);"
    },
    {
        "line": 124,
        "fullcodeline": "hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts));"
    },
    {
        "line": 30,
        "fullcodeline": "outputManager.reset("
    },
    {
        "line": 77,
        "fullcodeline": "std::make_shared<SourceMapTranslator>(context->getSourceErrorManager());"
    },
    {
        "line": 85,
        "fullcodeline": "if (!parser::JSParser::preParseBuffer("
    },
    {
        "line": 31,
        "fullcodeline": "new SimpleDiagHandlerRAII(context->getSourceErrorManager()));"
    }
]