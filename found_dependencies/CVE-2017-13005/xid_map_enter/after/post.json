[
    {
        "line": 4,
        "fullcodeline": "const struct ip *ip = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "const struct ip6_hdr *ip6 = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "UNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));"
    },
    {
        "line": 39,
        "fullcodeline": "xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);"
    },
    {
        "line": 42,
        "fullcodeline": "xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);"
    },
    {
        "line": 8,
        "fullcodeline": "if (!ND_TTEST(rp->rm_call.cb_vers))"
    },
    {
        "line": 10,
        "fullcodeline": "switch (IP_V((const struct ip *)bp)) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (++xid_map_next >= XIDMAPSIZE)"
    },
    {
        "line": 37,
        "fullcodeline": "if (!ND_TTEST(rp->rm_call.cb_proc))"
    },
    {
        "line": 40,
        "fullcodeline": "if (!ND_TTEST(rp->rm_call.cb_vers))"
    },
    {
        "line": 12,
        "fullcodeline": "ip = (const struct ip *)bp;"
    },
    {
        "line": 15,
        "fullcodeline": "ip6 = (const struct ip6_hdr *)bp;"
    },
    {
        "line": 24,
        "fullcodeline": "xid_map_next = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "xmep->ipver = 4;"
    },
    {
        "line": 29,
        "fullcodeline": "UNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));"
    },
    {
        "line": 30,
        "fullcodeline": "UNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));"
    },
    {
        "line": 33,
        "fullcodeline": "xmep->ipver = 6;"
    },
    {
        "line": 34,
        "fullcodeline": "UNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));"
    },
    {
        "line": 35,
        "fullcodeline": "UNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));"
    }
]