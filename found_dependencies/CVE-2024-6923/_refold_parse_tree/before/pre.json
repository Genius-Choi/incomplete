[
    {
        "line": 6,
        "fullcodeline": "maxlen = policy.max_line_length or sys.maxsize"
    },
    {
        "line": 7,
        "fullcodeline": "encoding = 'utf-8' if policy.utf8 else 'us-ascii'"
    },
    {
        "line": 8,
        "fullcodeline": "lines = ['']  # Folded lines to be output"
    },
    {
        "line": 9,
        "fullcodeline": "leading_whitespace = ''  # When we have whitespace between two encoded"
    },
    {
        "line": 12,
        "fullcodeline": "last_ew = None  # Points to the last encoded character if there's an ew on"
    },
    {
        "line": 14,
        "fullcodeline": "last_charset = None"
    },
    {
        "line": 15,
        "fullcodeline": "wrap_as_ew_blocked = 0"
    },
    {
        "line": 16,
        "fullcodeline": "want_encoding = False  # This is set to True if we need to encode this part"
    },
    {
        "line": 17,
        "fullcodeline": "end_ew_not_allowed = Terminal('', 'wrap_as_ew_blocked')"
    },
    {
        "line": 18,
        "fullcodeline": "parts = list(parse_tree)"
    },
    {
        "line": 141,
        "fullcodeline": "return policy.linesep.join(lines) + policy.linesep"
    },
    {
        "line": 20,
        "fullcodeline": "part = parts.pop(0)"
    },
    {
        "line": 24,
        "fullcodeline": "tstr = str(part)"
    },
    {
        "line": 100,
        "fullcodeline": "leading_whitespace = ''"
    },
    {
        "line": 134,
        "fullcodeline": "newline = _steal_trailing_WSP_if_exists(lines)"
    },
    {
        "line": 21,
        "fullcodeline": "if part is end_ew_not_allowed:"
    },
    {
        "line": 25,
        "fullcodeline": "if part.token_type == 'ptext' and set(tstr) & SPECIALS:"
    },
    {
        "line": 41,
        "fullcodeline": "if part.token_type == 'mime-parameters':"
    },
    {
        "line": 46,
        "fullcodeline": "if want_encoding and not wrap_as_ew_blocked:"
    },
    {
        "line": 93,
        "fullcodeline": "if len(tstr) <= maxlen - len(lines[-1]):"
    },
    {
        "line": 101,
        "fullcodeline": "if (part.syntactic_break and"
    },
    {
        "line": 119,
        "fullcodeline": "if not hasattr(part, 'encode'):"
    },
    {
        "line": 127,
        "fullcodeline": "if part.as_ew_allowed and not wrap_as_ew_blocked:"
    },
    {
        "line": 135,
        "fullcodeline": "if newline or part.startswith_fws():"
    },
    {
        "line": 22,
        "fullcodeline": "wrap_as_ew_blocked -= 1"
    },
    {
        "line": 27,
        "fullcodeline": "want_encoding = True"
    },
    {
        "line": 29,
        "fullcodeline": "tstr.encode(encoding)"
    },
    {
        "line": 30,
        "fullcodeline": "charset = encoding"
    },
    {
        "line": 43,
        "fullcodeline": "_fold_mime_parameters(part, lines, maxlen, encoding)"
    },
    {
        "line": 94,
        "fullcodeline": "lines[-1] += tstr"
    },
    {
        "line": 102,
        "fullcodeline": "len(tstr) + 1 <= maxlen):"
    },
    {
        "line": 103,
        "fullcodeline": "newline = _steal_trailing_WSP_if_exists(lines)"
    },
    {
        "line": 121,
        "fullcodeline": "newparts = list(part)"
    },
    {
        "line": 125,
        "fullcodeline": "parts = newparts + parts"
    },
    {
        "line": 130,
        "fullcodeline": "parts.insert(0, part)"
    },
    {
        "line": 131,
        "fullcodeline": "want_encoding = True"
    },
    {
        "line": 136,
        "fullcodeline": "lines.append(newline + tstr)"
    },
    {
        "line": 139,
        "fullcodeline": "lines[-1] += tstr"
    },
    {
        "line": 47,
        "fullcodeline": "if not part.as_ew_allowed:"
    },
    {
        "line": 65,
        "fullcodeline": "if not hasattr(part, 'encode'):"
    },
    {
        "line": 104,
        "fullcodeline": "if newline or part.startswith_fws():"
    },
    {
        "line": 122,
        "fullcodeline": "if not part.as_ew_allowed:"
    },
    {
        "line": 39,
        "fullcodeline": "want_encoding = True"
    },
    {
        "line": 48,
        "fullcodeline": "want_encoding = False"
    },
    {
        "line": 49,
        "fullcodeline": "last_ew = None"
    },
    {
        "line": 67,
        "fullcodeline": "parts = list(part) + parts"
    },
    {
        "line": 68,
        "fullcodeline": "want_encoding = False"
    },
    {
        "line": 109,
        "fullcodeline": "lines.append(newline + tstr)"
    },
    {
        "line": 111,
        "fullcodeline": "whitespace_accumulator = []"
    },
    {
        "line": 116,
        "fullcodeline": "leading_whitespace = ''.join(whitespace_accumulator)"
    },
    {
        "line": 117,
        "fullcodeline": "last_ew = None"
    },
    {
        "line": 123,
        "fullcodeline": "wrap_as_ew_blocked += 1"
    },
    {
        "line": 124,
        "fullcodeline": "newparts.append(end_ew_not_allowed)"
    },
    {
        "line": 32,
        "fullcodeline": "if any(isinstance(x, errors.UndecodableBytesDefect)"
    },
    {
        "line": 112,
        "fullcodeline": "for char in lines[-1]:"
    },
    {
        "line": 34,
        "fullcodeline": "charset = 'unknown-8bit'"
    },
    {
        "line": 38,
        "fullcodeline": "charset = 'utf-8'"
    },
    {
        "line": 51,
        "fullcodeline": "encoded_part = part.fold(policy=policy)[:-len(policy.linesep)]"
    },
    {
        "line": 78,
        "fullcodeline": "last_ew = _fold_as_ew(tstr, lines, maxlen, last_ew,"
    },
    {
        "line": 82,
        "fullcodeline": "leading_whitespace = ''"
    },
    {
        "line": 83,
        "fullcodeline": "last_charset = charset"
    },
    {
        "line": 84,
        "fullcodeline": "want_encoding = False"
    },
    {
        "line": 89,
        "fullcodeline": "last_ew = None"
    },
    {
        "line": 90,
        "fullcodeline": "want_encoding = False"
    },
    {
        "line": 52,
        "fullcodeline": "if policy.linesep not in encoded_part:"
    },
    {
        "line": 73,
        "fullcodeline": "if (last_ew is not None and"
    },
    {
        "line": 115,
        "fullcodeline": "whitespace_accumulator.append(char)"
    },
    {
        "line": 59,
        "fullcodeline": "lines[-1] += encoded_part"
    },
    {
        "line": 74,
        "fullcodeline": "charset != last_charset and"
    },
    {
        "line": 77,
        "fullcodeline": "last_ew = None"
    },
    {
        "line": 113,
        "fullcodeline": "if char not in WSP:"
    },
    {
        "line": 54,
        "fullcodeline": "if len(encoded_part) > maxlen - len(lines[-1]):"
    },
    {
        "line": 56,
        "fullcodeline": "newline = _steal_trailing_WSP_if_exists(lines)"
    },
    {
        "line": 58,
        "fullcodeline": "lines.append(newline)"
    }
]