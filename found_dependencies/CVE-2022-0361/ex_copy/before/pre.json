[
    {
        "line": 6,
        "fullcodeline": "count = line2 - line1 + 1;"
    },
    {
        "line": 28,
        "fullcodeline": "curwin->w_cursor.lnum = n;"
    },
    {
        "line": 50,
        "fullcodeline": "appended_lines_mark(n, count);"
    },
    {
        "line": 7,
        "fullcodeline": "if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)"
    },
    {
        "line": 25,
        "fullcodeline": "if (u_save(n, n + 1) == FAIL)"
    },
    {
        "line": 29,
        "fullcodeline": "while (line1 <= line2)"
    },
    {
        "line": 9,
        "fullcodeline": "curbuf->b_op_start.lnum = n + 1;"
    },
    {
        "line": 10,
        "fullcodeline": "curbuf->b_op_end.lnum = n + count;"
    },
    {
        "line": 11,
        "fullcodeline": "curbuf->b_op_start.col = curbuf->b_op_end.col = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "p = vim_strsave(ml_get(line1));"
    },
    {
        "line": 42,
        "fullcodeline": "++line1;"
    },
    {
        "line": 47,
        "fullcodeline": "++curwin->w_cursor.lnum;"
    },
    {
        "line": 34,
        "fullcodeline": "if (p != NULL)"
    },
    {
        "line": 40,
        "fullcodeline": "if (line1 == n)"
    },
    {
        "line": 43,
        "fullcodeline": "if (curwin->w_cursor.lnum < line1)"
    },
    {
        "line": 45,
        "fullcodeline": "if (curwin->w_cursor.lnum < line2)"
    },
    {
        "line": 36,
        "fullcodeline": "ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);"
    },
    {
        "line": 41,
        "fullcodeline": "line1 = curwin->w_cursor.lnum;"
    },
    {
        "line": 44,
        "fullcodeline": "++line1;"
    },
    {
        "line": 46,
        "fullcodeline": "++line2;"
    }
]