[
    {
        "line": 2,
        "fullcodeline": "bool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");"
    },
    {
        "line": 3,
        "fullcodeline": "bool emu_lazy = r_config_get_b (core->config, \"emu.lazy\");"
    },
    {
        "line": 4,
        "fullcodeline": "bool gp_fixed = r_config_get_b (core->config, \"anal.gpfixed\");"
    },
    {
        "line": 5,
        "fullcodeline": "RAnalEsil *ESIL = core->anal->esil;"
    },
    {
        "line": 6,
        "fullcodeline": "ut64 refptr = 0LL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *pcname = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "RAnalOp op = {0};"
    },
    {
        "line": 9,
        "fullcodeline": "ut8 *buf = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "bool end_address_set = false;"
    },
    {
        "line": 12,
        "fullcodeline": "int minopsize = 4; // XXX this depends on asm->mininstrsize"
    },
    {
        "line": 13,
        "fullcodeline": "bool archIsArm = false;"
    },
    {
        "line": 14,
        "fullcodeline": "ut64 addr = core->offset;"
    },
    {
        "line": 15,
        "fullcodeline": "ut64 start = addr;"
    },
    {
        "line": 16,
        "fullcodeline": "ut64 end = 0LL;"
    },
    {
        "line": 23,
        "fullcodeline": "mycore = core;"
    },
    {
        "line": 47,
        "fullcodeline": "RAnalFunction *fcn = NULL;"
    },
    {
        "line": 71,
        "fullcodeline": "iend = end - start;"
    },
    {
        "line": 79,
        "fullcodeline": "buf = malloc ((size_t)iend + 2);"
    },
    {
        "line": 84,
        "fullcodeline": "esilbreak_last_read = UT64_MAX;"
    },
    {
        "line": 85,
        "fullcodeline": "r_io_read_at (core->io, start, buf, iend + 1);"
    },
    {
        "line": 96,
        "fullcodeline": "const char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);"
    },
    {
        "line": 101,
        "fullcodeline": "char *spname = strdup (kspname);"
    },
    {
        "line": 102,
        "fullcodeline": "EsilBreakCtx ctx = {"
    },
    {
        "line": 110,
        "fullcodeline": "ESIL->user = &ctx;"
    },
    {
        "line": 119,
        "fullcodeline": "const char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);"
    },
    {
        "line": 124,
        "fullcodeline": "pcname = strdup (kpcname);"
    },
    {
        "line": 125,
        "fullcodeline": "esil_anal_stop = false;"
    },
    {
        "line": 126,
        "fullcodeline": "r_cons_break_push (cccb, core);"
    },
    {
        "line": 128,
        "fullcodeline": "int arch = -1;"
    },
    {
        "line": 138,
        "fullcodeline": "ut64 gp = r_config_get_i (core->config, \"anal.gp\");"
    },
    {
        "line": 139,
        "fullcodeline": "const char *gp_reg = NULL;"
    },
    {
        "line": 145,
        "fullcodeline": "r_reg_arena_push (core->anal->reg);"
    },
    {
        "line": 147,
        "fullcodeline": "IterCtx ictx = { start, end, fcn, NULL };"
    },
    {
        "line": 148,
        "fullcodeline": "size_t i = addr - start;"
    },
    {
        "line": 18,
        "fullcodeline": "if (esil_anal_stop || r_cons_is_breaked ()) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (iend < 0) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (iend > MAX_SCAN_SIZE) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (!ESIL) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (R_STR_ISEMPTY (kspname)) {"
    },
    {
        "line": 114,
        "fullcodeline": "if (fcn && fcn->reg_save_area) {"
    },
    {
        "line": 451,
        "fullcodeline": "} while (get_next_i (&ictx, &i));"
    },
    {
        "line": 24,
        "fullcodeline": "if (!strcmp (str, \"?\")) {"
    },
    {
        "line": 33,
        "fullcodeline": "const char *expr = r_str_trim_head_ro (target);"
    },
    {
        "line": 48,
        "fullcodeline": "if (!strcmp (str, \"f\")) {"
    },
    {
        "line": 49,
        "fullcodeline": "fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);"
    },
    {
        "line": 87,
        "fullcodeline": "r_core_cmd0 (core, \"aei\");"
    },
    {
        "line": 88,
        "fullcodeline": "ESIL = core->anal->esil;"
    },
    {
        "line": 93,
        "fullcodeline": "r_core_cmd0 (core, \"aeim\");"
    },
    {
        "line": 94,
        "fullcodeline": "ESIL = core->anal->esil;"
    },
    {
        "line": 106,
        "fullcodeline": "r_reg_getv (core->anal->reg, spname)"
    },
    {
        "line": 115,
        "fullcodeline": "r_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);"
    },
    {
        "line": 120,
        "fullcodeline": "if (!kpcname || !*kpcname) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (!strcmp (core->anal->cur->arch, \"arm\")) {"
    },
    {
        "line": 135,
        "fullcodeline": "archIsArm = true;"
    },
    {
        "line": 140,
        "fullcodeline": "if (!strcmp (core->anal->cur->arch, \"mips\")) {"
    },
    {
        "line": 141,
        "fullcodeline": "gp_reg = \"gp\";"
    },
    {
        "line": 142,
        "fullcodeline": "arch = R2_ARCH_MIPS;"
    },
    {
        "line": 154,
        "fullcodeline": "cur = start + i;"
    },
    {
        "line": 196,
        "fullcodeline": "r_core_seek_arch_bits (core, cur);"
    },
    {
        "line": 197,
        "fullcodeline": "int opalign = core->anal->pcalign;"
    },
    {
        "line": 202,
        "fullcodeline": "r_anal_op_fini (&op);"
    },
    {
        "line": 203,
        "fullcodeline": "r_asm_set_pc (core->rasm, cur);"
    },
    {
        "line": 204,
        "fullcodeline": "i_old = i;"
    },
    {
        "line": 255,
        "fullcodeline": "const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);"
    },
    {
        "line": 276,
        "fullcodeline": "const char *esilstr = R_STRBUF_SAFEGET (&op.esil);"
    },
    {
        "line": 277,
        "fullcodeline": "i += op.size - 1;"
    },
    {
        "line": 281,
        "fullcodeline": "r_anal_esil_set_pc (ESIL, cur);"
    },
    {
        "line": 282,
        "fullcodeline": "r_reg_setv (core->anal->reg, pcname, cur + op.size);"
    },
    {
        "line": 437,
        "fullcodeline": "r_anal_esil_stack_free (ESIL);"
    },
    {
        "line": 44,
        "fullcodeline": "ntarget = UT64_MAX;"
    },
    {
        "line": 45,
        "fullcodeline": "refptr = 0LL;"
    },
    {
        "line": 59,
        "fullcodeline": "if (str[0] == ' ') {"
    },
    {
        "line": 198,
        "fullcodeline": "if (opalign > 0) {"
    },
    {
        "line": 205,
        "fullcodeline": "if (i > iend) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (op.size < 1) {"
    },
    {
        "line": 256,
        "fullcodeline": "if (!sn) {"
    },
    {
        "line": 259,
        "fullcodeline": "if (sn && op.type == R_ANAL_OP_TYPE_SWI) {"
    },
    {
        "line": 278,
        "fullcodeline": "if (R_STR_ISEMPTY (esilstr)) {"
    },
    {
        "line": 283,
        "fullcodeline": "if (gp_fixed && gp_reg) {"
    },
    {
        "line": 286,
        "fullcodeline": "(void)r_anal_esil_parse (ESIL, esilstr);"
    },
    {
        "line": 448,
        "fullcodeline": "if (i >= iend) {"
    },
    {
        "line": 35,
        "fullcodeline": "refptr = ntarget = r_num_math (core->num, expr);"
    },
    {
        "line": 51,
        "fullcodeline": "start = r_anal_function_min_addr (fcn);"
    },
    {
        "line": 52,
        "fullcodeline": "addr = fcn->addr;"
    },
    {
        "line": 53,
        "fullcodeline": "end = r_anal_function_max_addr (fcn);"
    },
    {
        "line": 54,
        "fullcodeline": "end_address_set = true;"
    },
    {
        "line": 60,
        "fullcodeline": "end = addr + r_num_math (core->num, str + 1);"
    },
    {
        "line": 131,
        "fullcodeline": "case 64: arch = R2_ARCH_ARM64; break;"
    },
    {
        "line": 132,
        "fullcodeline": "case 32: arch = R2_ARCH_ARM32; break;"
    },
    {
        "line": 133,
        "fullcodeline": "case 16: arch = R2_ARCH_THUMB; break;"
    },
    {
        "line": 155,
        "fullcodeline": "if (!r_io_is_valid_offset (core->io, cur, 0)) {"
    },
    {
        "line": 199,
        "fullcodeline": "cur -= (cur % opalign);"
    },
    {
        "line": 208,
        "fullcodeline": "if (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {"
    },
    {
        "line": 209,
        "fullcodeline": "i += minopsize - 1; //   XXX dupe in op.size below"
    },
    {
        "line": 211,
        "fullcodeline": "if (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {"
    },
    {
        "line": 213,
        "fullcodeline": "r_anal_op_fini (&op);"
    },
    {
        "line": 219,
        "fullcodeline": "i += minopsize - 1;"
    },
    {
        "line": 261,
        "fullcodeline": "r_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);"
    },
    {
        "line": 262,
        "fullcodeline": "int snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);"
    },
    {
        "line": 263,
        "fullcodeline": "RSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);"
    },
    {
        "line": 273,
        "fullcodeline": "r_flag_space_set (core->flags, NULL);"
    },
    {
        "line": 284,
        "fullcodeline": "r_reg_setv (core->anal->reg, gp_reg, gp);"
    },
    {
        "line": 439,
        "fullcodeline": "if (!r_anal_get_block_at (core->anal, cur)) {"
    },
    {
        "line": 36,
        "fullcodeline": "if (!refptr) {"
    },
    {
        "line": 40,
        "fullcodeline": "ntarget = UT64_MAX;"
    },
    {
        "line": 41,
        "fullcodeline": "refptr = 0LL;"
    },
    {
        "line": 62,
        "fullcodeline": "RIOMap *map = r_io_map_get_at (core->io, addr);"
    },
    {
        "line": 223,
        "fullcodeline": "if (op.type & R_ANAL_OP_TYPE_REP) {"
    },
    {
        "line": 227,
        "fullcodeline": "switch (op.type & R_ANAL_OP_TYPE_MASK) {"
    },
    {
        "line": 293,
        "fullcodeline": "if (core->anal->cur && arch == R2_ARCH_ARM64) {"
    },
    {
        "line": 312,
        "fullcodeline": "if (core->anal->cur && archIsArm) {"
    },
    {
        "line": 363,
        "fullcodeline": "ut64 dst = esilbreak_last_read;"
    },
    {
        "line": 372,
        "fullcodeline": "dst = esilbreak_last_data;"
    },
    {
        "line": 385,
        "fullcodeline": "ut64 dst = op.jump;"
    },
    {
        "line": 395,
        "fullcodeline": "ut64 dst = op.jump;"
    },
    {
        "line": 412,
        "fullcodeline": "ut64 dst = core->anal->esil->jump_target;"
    },
    {
        "line": 441,
        "fullcodeline": "for (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {"
    },
    {
        "line": 37,
        "fullcodeline": "ntarget = refptr = addr;"
    },
    {
        "line": 224,
        "fullcodeline": "i += op.size - 1;"
    },
    {
        "line": 246,
        "fullcodeline": "i += op.size - 1;"
    },
    {
        "line": 251,
        "fullcodeline": "i += op.size - 1;"
    },
    {
        "line": 266,
        "fullcodeline": "r_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);"
    },
    {
        "line": 307,
        "fullcodeline": "add_string_ref (core, op.addr, op.ptr);"
    },
    {
        "line": 314,
        "fullcodeline": "ut64 dst = ESIL->cur;"
    },
    {
        "line": 364,
        "fullcodeline": "if (dst != UT64_MAX && CHECKREF (dst)) {"
    },
    {
        "line": 373,
        "fullcodeline": "if (dst != UT64_MAX && CHECKREF (dst)) {"
    },
    {
        "line": 386,
        "fullcodeline": "if (CHECKREF (dst)) {"
    },
    {
        "line": 396,
        "fullcodeline": "if (CHECKREF (dst)) {"
    },
    {
        "line": 416,
        "fullcodeline": "if (CHECKREF (dst)) {"
    },
    {
        "line": 64,
        "fullcodeline": "end = r_io_map_end (map);"
    },
    {
        "line": 271,
        "fullcodeline": "r_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);"
    },
    {
        "line": 294,
        "fullcodeline": "if (CHECKREF (ESIL->cur)) {"
    },
    {
        "line": 315,
        "fullcodeline": "if ((target && dst == ntarget) || !target) {"
    },
    {
        "line": 400,
        "fullcodeline": "ESIL->old = cur + op.size;"
    },
    {
        "line": 401,
        "fullcodeline": "getpcfromstack (core, ESIL);"
    },
    {
        "line": 413,
        "fullcodeline": "if (dst == 0 || dst == UT64_MAX) {"
    },
    {
        "line": 414,
        "fullcodeline": "dst = r_reg_getv (core->anal->reg, pcname);"
    },
    {
        "line": 442,
        "fullcodeline": "if (r_anal_get_function_at (core->anal, start + fcn_i)) {"
    },
    {
        "line": 66,
        "fullcodeline": "end = addr + core->blocksize;"
    },
    {
        "line": 295,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);"
    },
    {
        "line": 297,
        "fullcodeline": "} else if ((target && op.ptr == ntarget) || !target) {"
    },
    {
        "line": 322,
        "fullcodeline": "add_string_ref (core, op.addr, dst);"
    },
    {
        "line": 365,
        "fullcodeline": "if (myvalid (mycore->io, dst)) {"
    },
    {
        "line": 374,
        "fullcodeline": "if (myvalid (mycore->io, dst)) {"
    },
    {
        "line": 387,
        "fullcodeline": "if (myvalid (core->io, dst)) {"
    },
    {
        "line": 397,
        "fullcodeline": "if (myvalid (core->io, dst)) {"
    },
    {
        "line": 417,
        "fullcodeline": "if (myvalid (core->io, dst)) {"
    },
    {
        "line": 443,
        "fullcodeline": "i = fcn_i - 1;"
    },
    {
        "line": 316,
        "fullcodeline": "if (CHECKREF (dst)) {"
    },
    {
        "line": 324,
        "fullcodeline": "} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {"
    },
    {
        "line": 325,
        "fullcodeline": "ut64 dst = ESIL->cur;"
    },
    {
        "line": 366,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);"
    },
    {
        "line": 375,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);"
    },
    {
        "line": 388,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);"
    },
    {
        "line": 398,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);"
    },
    {
        "line": 418,
        "fullcodeline": "RAnalRefType ref ="
    },
    {
        "line": 422,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, ref);"
    },
    {
        "line": 423,
        "fullcodeline": "r_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);"
    },
    {
        "line": 298,
        "fullcodeline": "if (CHECKREF (ESIL->cur)) {"
    },
    {
        "line": 317,
        "fullcodeline": "int type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA;"
    },
    {
        "line": 318,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, type);"
    },
    {
        "line": 335,
        "fullcodeline": "if ((target && dst == ntarget) || !target) {"
    },
    {
        "line": 326,
        "fullcodeline": "if (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {"
    },
    {
        "line": 329,
        "fullcodeline": "if (!strcmp (op.src[0]->reg->name, \"sp\")) {"
    },
    {
        "line": 332,
        "fullcodeline": "if (!strcmp (op.src[0]->reg->name, \"zero\")) {"
    },
    {
        "line": 368,
        "fullcodeline": "add_string_ref (core, op.addr, dst);"
    },
    {
        "line": 377,
        "fullcodeline": "add_string_ref (core, op.addr, dst);"
    },
    {
        "line": 419,
        "fullcodeline": "(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL"
    },
    {
        "line": 299,
        "fullcodeline": "if (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {"
    },
    {
        "line": 300,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);"
    },
    {
        "line": 336,
        "fullcodeline": "if (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {"
    },
    {
        "line": 302,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);"
    },
    {
        "line": 339,
        "fullcodeline": "if (CHECKREF (dst) || CHECKREF (cur)) {"
    },
    {
        "line": 340,
        "fullcodeline": "r_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);"
    },
    {
        "line": 344,
        "fullcodeline": "if ((f = r_core_flag_get_by_spaces (core->flags, dst))) {"
    },
    {
        "line": 342,
        "fullcodeline": "add_string_ref (core, op.addr, dst);"
    },
    {
        "line": 345,
        "fullcodeline": "r_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);"
    },
    {
        "line": 346,
        "fullcodeline": "} else if ((str = is_string_at (mycore, dst, NULL))) {"
    },
    {
        "line": 347,
        "fullcodeline": "char *str2 = r_str_newf (\"esilref: '%s'\", str);"
    },
    {
        "line": 351,
        "fullcodeline": "r_str_replace_char (str2, '%', '&');"
    },
    {
        "line": 352,
        "fullcodeline": "r_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);"
    }
]