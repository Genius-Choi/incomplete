[
    {
        "line": 10,
        "fullcodeline": "results->clear();"
    },
    {
        "line": 22,
        "fullcodeline": "std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);"
    },
    {
        "line": 27,
        "fullcodeline": "int matching_index = GetFirstGlobbingEntry(dirs);"
    },
    {
        "line": 62,
        "fullcodeline": "expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);"
    },
    {
        "line": 4,
        "fullcodeline": "if (fs == nullptr || env == nullptr || results == nullptr) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (pattern.empty()) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (matching_index == dirs.size()) {"
    },
    {
        "line": 69,
        "fullcodeline": "while (!expand_queue.empty()) {"
    },
    {
        "line": 143,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 70,
        "fullcodeline": "next_expand_queue.clear();"
    },
    {
        "line": 74,
        "fullcodeline": "auto handle_level = [&fs, &results, &dirs, &expand_queue,"
    },
    {
        "line": 137,
        "fullcodeline": "ForEach(0, expand_queue.size(), handle_level);"
    },
    {
        "line": 140,
        "fullcodeline": "std::swap(expand_queue, next_expand_queue);"
    },
    {
        "line": 5,
        "fullcodeline": "return Status(tensorflow::error::INVALID_ARGUMENT,"
    },
    {
        "line": 12,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 32,
        "fullcodeline": "if (fs->FileExists(pattern).ok()) {"
    },
    {
        "line": 35,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 33,
        "fullcodeline": "results->emplace_back(pattern);"
    }
]