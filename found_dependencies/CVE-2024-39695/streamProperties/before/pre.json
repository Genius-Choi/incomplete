[
    {
        "line": 2,
        "fullcodeline": "DataBuf streamTypedBuf = io_->read(GUID);"
    },
    {
        "line": 5,
        "fullcodeline": "auto stream = static_cast<streamTypeInfo>(0);"
    },
    {
        "line": 7,
        "fullcodeline": "auto tag_stream_type = GUIDReferenceTags.find(GUIDTag(streamTypedBuf.data()));"
    },
    {
        "line": 8,
        "fullcodeline": "if (tag_stream_type != GUIDReferenceTags.end()) {"
    },
    {
        "line": 14,
        "fullcodeline": "io_->seek(io_->tell() + GUID, BasicIo::beg);  // ignore Error Correction Type"
    },
    {
        "line": 16,
        "fullcodeline": "uint64_t time_offset = readQWORDTag(io_);"
    },
    {
        "line": 22,
        "fullcodeline": "auto specific_data_length = readDWORDTag(io_);"
    },
    {
        "line": 23,
        "fullcodeline": "auto correction_data_length = readDWORDTag(io_);"
    },
    {
        "line": 25,
        "fullcodeline": "io_->seek(io_->tell() + WORD /*Flags*/ + DWORD /*Reserved*/ + specific_data_length + correction_data_length,"
    },
    {
        "line": 9,
        "fullcodeline": "if (tag_stream_type->second == \"Audio_Media\")"
    },
    {
        "line": 17,
        "fullcodeline": "if (stream == streamTypeInfo::Video)"
    },
    {
        "line": 10,
        "fullcodeline": "stream = streamTypeInfo::Audio;"
    },
    {
        "line": 18,
        "fullcodeline": "xmpData()[\"Xmp.video.TimeOffset\"] = time_offset;"
    },
    {
        "line": 11,
        "fullcodeline": "else if (tag_stream_type->second == \"Video_Media\")"
    },
    {
        "line": 19,
        "fullcodeline": "else if (stream == streamTypeInfo::Audio)"
    },
    {
        "line": 12,
        "fullcodeline": "stream = streamTypeInfo::Video;"
    },
    {
        "line": 20,
        "fullcodeline": "xmpData()[\"Xmp.audio.TimeOffset\"] = time_offset;"
    }
]