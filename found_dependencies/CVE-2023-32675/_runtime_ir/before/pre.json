[
    {
        "line": 5,
        "fullcodeline": "internal_functions = [f for f in runtime_functions if _is_internal(f)]"
    },
    {
        "line": 7,
        "fullcodeline": "external_functions = [f for f in runtime_functions if not _is_internal(f)]"
    },
    {
        "line": 8,
        "fullcodeline": "default_function = next((f for f in external_functions if _is_default_func(f)), None)"
    },
    {
        "line": 11,
        "fullcodeline": "regular_functions = [f for f in external_functions if not _is_default_func(f)]"
    },
    {
        "line": 12,
        "fullcodeline": "payables = [f for f in regular_functions if _is_payable(f)]"
    },
    {
        "line": 13,
        "fullcodeline": "nonpayables = [f for f in regular_functions if not _is_payable(f)]"
    },
    {
        "line": 17,
        "fullcodeline": "internal_functions_map: Dict[str, IRnode] = {}"
    },
    {
        "line": 33,
        "fullcodeline": "default_is_nonpayable = default_function is None or not _is_payable(default_function)"
    },
    {
        "line": 37,
        "fullcodeline": "batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable"
    },
    {
        "line": 38,
        "fullcodeline": "skip_nonpayable_check = batch_payable_check"
    },
    {
        "line": 40,
        "fullcodeline": "selector_section = [\"seq\"]"
    },
    {
        "line": 66,
        "fullcodeline": "close_selector_section = [\"goto\", \"fallback\"]"
    },
    {
        "line": 68,
        "fullcodeline": "runtime = ["
    },
    {
        "line": 79,
        "fullcodeline": "runtime.extend(internal_functions_map.values())"
    },
    {
        "line": 19,
        "fullcodeline": "for func_ast in internal_functions:"
    },
    {
        "line": 26,
        "fullcodeline": "if len(external_functions) == 0:"
    },
    {
        "line": 42,
        "fullcodeline": "for func_ast in payables:"
    },
    {
        "line": 49,
        "fullcodeline": "for func_ast in nonpayables:"
    },
    {
        "line": 81,
        "fullcodeline": "return runtime, internal_functions_map"
    },
    {
        "line": 28,
        "fullcodeline": "runtime = [\"seq\"] + list(internal_functions_map.values())"
    },
    {
        "line": 47,
        "fullcodeline": "selector_section.append([\"assert\", [\"iszero\", \"callvalue\"]])"
    },
    {
        "line": 54,
        "fullcodeline": "fallback_ir = generate_ir_for_function("
    },
    {
        "line": 58,
        "fullcodeline": "fallback_ir = IRnode.from_list("
    },
    {
        "line": 72,
        "fullcodeline": "[\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],"
    },
    {
        "line": 73,
        "fullcodeline": "[\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],"
    },
    {
        "line": 75,
        "fullcodeline": "[\"label\", \"fallback\", [\"var_list\"], fallback_ir],"
    },
    {
        "line": 20,
        "fullcodeline": "func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)"
    },
    {
        "line": 21,
        "fullcodeline": "internal_functions_map[func_ast.name] = func_ir"
    },
    {
        "line": 29,
        "fullcodeline": "return runtime, internal_functions_map"
    },
    {
        "line": 43,
        "fullcodeline": "func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)"
    },
    {
        "line": 44,
        "fullcodeline": "selector_section.append(func_ir)"
    },
    {
        "line": 50,
        "fullcodeline": "func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, skip_nonpayable_check)"
    },
    {
        "line": 51,
        "fullcodeline": "selector_section.append(func_ir)"
    },
    {
        "line": 59,
        "fullcodeline": "[\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\""
    }
]