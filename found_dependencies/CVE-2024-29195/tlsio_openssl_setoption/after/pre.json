[
    {
        "line": 5,
        "fullcodeline": "if (tls_io == NULL || optionName == NULL)"
    },
    {
        "line": 7,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 11,
        "fullcodeline": "TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;"
    },
    {
        "line": 13,
        "fullcodeline": "if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)"
    },
    {
        "line": 15,
        "fullcodeline": "const char* cert = (const char*)value;"
    },
    {
        "line": 26,
        "fullcodeline": "len = strlen(cert);"
    },
    {
        "line": 27,
        "fullcodeline": "size_t malloc_size = safe_add_size_t(len, 1);"
    },
    {
        "line": 18,
        "fullcodeline": "if (tls_io_instance->certificate != NULL)"
    },
    {
        "line": 28,
        "fullcodeline": "if (malloc_size == SIZE_MAX ||"
    },
    {
        "line": 41,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 22,
        "fullcodeline": "tls_io_instance->certificate = NULL;"
    },
    {
        "line": 29,
        "fullcodeline": "(tls_io_instance->certificate = malloc(malloc_size)) == NULL)"
    },
    {
        "line": 31,
        "fullcodeline": "LogError(\"malloc failure, size:%zu\", malloc_size);"
    },
    {
        "line": 32,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 43,
        "fullcodeline": "result = add_certificate_to_store(tls_io_instance, cert);"
    },
    {
        "line": 46,
        "fullcodeline": "else if (strcmp(OPTION_OPENSSL_CIPHER_SUITE, optionName) == 0)"
    },
    {
        "line": 36,
        "fullcodeline": "strcpy(tls_io_instance->certificate, cert);"
    },
    {
        "line": 37,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "if (tls_io_instance->cipher_list != NULL)"
    },
    {
        "line": 56,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->cipher_list, value) != 0)"
    },
    {
        "line": 52,
        "fullcodeline": "tls_io_instance->cipher_list = NULL;"
    },
    {
        "line": 58,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 59,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 66,
        "fullcodeline": "else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)"
    },
    {
        "line": 63,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 68,
        "fullcodeline": "if (tls_io_instance->x509_certificate != NULL)"
    },
    {
        "line": 70,
        "fullcodeline": "LogError(\"unable to set x509 options more than once\");"
    },
    {
        "line": 71,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 87,
        "fullcodeline": "else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)"
    },
    {
        "line": 76,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->x509_certificate, value) != 0)"
    },
    {
        "line": 89,
        "fullcodeline": "if (tls_io_instance->x509_private_key != NULL)"
    },
    {
        "line": 78,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 79,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 91,
        "fullcodeline": "LogError(\"unable to set more than once x509 options\");"
    },
    {
        "line": 92,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 109,
        "fullcodeline": "else if (strcmp(OPTION_OPENSSL_ENGINE, optionName) == 0)"
    },
    {
        "line": 83,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "ENGINE_load_builtin_engines();"
    },
    {
        "line": 97,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->x509_private_key, value) != 0)"
    },
    {
        "line": 113,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->engine_id, value) != 0)"
    },
    {
        "line": 99,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 100,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 115,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 116,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 124,
        "fullcodeline": "else if (strcmp(OPTION_OPENSSL_PRIVATE_KEY_TYPE, optionName) == 0)"
    },
    {
        "line": 104,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 120,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 126,
        "fullcodeline": "const OPTION_OPENSSL_KEY_TYPE type = *(const OPTION_OPENSSL_KEY_TYPE*)value;"
    },
    {
        "line": 131,
        "fullcodeline": "tls_io_instance->x509_private_key_type = type;"
    },
    {
        "line": 132,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 136,
        "fullcodeline": "LogError(\"Unknown x509PrivatekeyType type %d\", type);"
    },
    {
        "line": 137,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 140,
        "fullcodeline": "else if (strcmp(\"tls_validation_callback\", optionName) == 0)"
    },
    {
        "line": 146,
        "fullcodeline": "tls_io_instance->tls_validation_callback = (TLS_CERTIFICATE_VALIDATION_CALLBACK)value;"
    },
    {
        "line": 156,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 151,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 153,
        "fullcodeline": "SSL_CTX_set_cert_verify_callback(tls_io_instance->ssl_context, tls_io_instance->tls_validation_callback, tls_io_instance->tls_validation_callback_data);"
    },
    {
        "line": 158,
        "fullcodeline": "else if (strcmp(\"tls_validation_callback_data\", optionName) == 0)"
    },
    {
        "line": 160,
        "fullcodeline": "tls_io_instance->tls_validation_callback_data = (void*)value;"
    },
    {
        "line": 167,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 162,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 164,
        "fullcodeline": "SSL_CTX_set_cert_verify_callback(tls_io_instance->ssl_context, tls_io_instance->tls_validation_callback, tls_io_instance->tls_validation_callback_data);"
    },
    {
        "line": 169,
        "fullcodeline": "else if (strcmp(OPTION_TLS_VERSION, optionName) == 0)"
    },
    {
        "line": 171,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 173,
        "fullcodeline": "LogError(\"Unable to set the tls version after the tls connection is established\");"
    },
    {
        "line": 174,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 199,
        "fullcodeline": "else if (strcmp(optionName, OPTION_UNDERLYING_IO_OPTIONS) == 0)"
    },
    {
        "line": 178,
        "fullcodeline": "const int version_option = *(const int*)value;"
    },
    {
        "line": 196,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 179,
        "fullcodeline": "if (version_option == 0 || version_option == 10)"
    },
    {
        "line": 201,
        "fullcodeline": "if (OptionHandler_FeedOptions((OPTIONHANDLER_HANDLE)value, (void*)tls_io_instance->underlying_io) != OPTIONHANDLER_OK)"
    },
    {
        "line": 181,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_0;"
    },
    {
        "line": 203,
        "fullcodeline": "LogError(\"failed feeding options to underlying I/O instance\");"
    },
    {
        "line": 204,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 211,
        "fullcodeline": "else if (strcmp(optionName, OPTION_SET_TLS_RENEGOTIATION) == 0)"
    },
    {
        "line": 208,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 214,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 183,
        "fullcodeline": "else if (version_option == 11)"
    },
    {
        "line": 185,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_1;"
    },
    {
        "line": 216,
        "fullcodeline": "else if (strcmp(\"ignore_host_name_check\", optionName) == 0)"
    },
    {
        "line": 218,
        "fullcodeline": "bool* server_name_check = (bool*)value;"
    },
    {
        "line": 219,
        "fullcodeline": "tls_io_instance->ignore_host_name_check = *server_name_check;"
    },
    {
        "line": 220,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 187,
        "fullcodeline": "else if (version_option == 12)"
    },
    {
        "line": 189,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_2;"
    },
    {
        "line": 224,
        "fullcodeline": "if (tls_io_instance->underlying_io == NULL)"
    },
    {
        "line": 193,
        "fullcodeline": "LogInfo(\"Value of TLS version option %d is not found shall default to version 1.2\", version_option);"
    },
    {
        "line": 194,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_2;"
    },
    {
        "line": 226,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 230,
        "fullcodeline": "result = xio_setoption(tls_io_instance->underlying_io, optionName, value);"
    }
]