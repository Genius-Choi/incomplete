[
    {
        "line": 5,
        "fullcodeline": "if (tls_io == NULL || optionName == NULL)"
    },
    {
        "line": 7,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 11,
        "fullcodeline": "TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;"
    },
    {
        "line": 13,
        "fullcodeline": "if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)"
    },
    {
        "line": 15,
        "fullcodeline": "const char* cert = (const char*)value;"
    },
    {
        "line": 26,
        "fullcodeline": "len = strlen(cert);"
    },
    {
        "line": 27,
        "fullcodeline": "tls_io_instance->certificate = malloc(len + 1);"
    },
    {
        "line": 18,
        "fullcodeline": "if (tls_io_instance->certificate != NULL)"
    },
    {
        "line": 28,
        "fullcodeline": "if (tls_io_instance->certificate == NULL)"
    },
    {
        "line": 39,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 22,
        "fullcodeline": "tls_io_instance->certificate = NULL;"
    },
    {
        "line": 30,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 41,
        "fullcodeline": "result = add_certificate_to_store(tls_io_instance, cert);"
    },
    {
        "line": 44,
        "fullcodeline": "else if (strcmp(OPTION_OPENSSL_CIPHER_SUITE, optionName) == 0)"
    },
    {
        "line": 34,
        "fullcodeline": "strcpy(tls_io_instance->certificate, cert);"
    },
    {
        "line": 35,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 46,
        "fullcodeline": "if (tls_io_instance->cipher_list != NULL)"
    },
    {
        "line": 54,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->cipher_list, value) != 0)"
    },
    {
        "line": 50,
        "fullcodeline": "tls_io_instance->cipher_list = NULL;"
    },
    {
        "line": 56,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 57,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 64,
        "fullcodeline": "else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)"
    },
    {
        "line": 61,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 66,
        "fullcodeline": "if (tls_io_instance->x509_certificate != NULL)"
    },
    {
        "line": 68,
        "fullcodeline": "LogError(\"unable to set x509 options more than once\");"
    },
    {
        "line": 69,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 85,
        "fullcodeline": "else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)"
    },
    {
        "line": 74,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->x509_certificate, value) != 0)"
    },
    {
        "line": 87,
        "fullcodeline": "if (tls_io_instance->x509_private_key != NULL)"
    },
    {
        "line": 76,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 77,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 89,
        "fullcodeline": "LogError(\"unable to set more than once x509 options\");"
    },
    {
        "line": 90,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 107,
        "fullcodeline": "else if (strcmp(OPTION_OPENSSL_ENGINE, optionName) == 0)"
    },
    {
        "line": 81,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 109,
        "fullcodeline": "ENGINE_load_builtin_engines();"
    },
    {
        "line": 95,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->x509_private_key, value) != 0)"
    },
    {
        "line": 111,
        "fullcodeline": "if (mallocAndStrcpy_s((char**)&tls_io_instance->engine_id, value) != 0)"
    },
    {
        "line": 97,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 98,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 113,
        "fullcodeline": "LogError(\"unable to mallocAndStrcpy_s %s\", optionName);"
    },
    {
        "line": 114,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 122,
        "fullcodeline": "else if (strcmp(OPTION_OPENSSL_PRIVATE_KEY_TYPE, optionName) == 0)"
    },
    {
        "line": 102,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 118,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 124,
        "fullcodeline": "const OPTION_OPENSSL_KEY_TYPE type = *(const OPTION_OPENSSL_KEY_TYPE*)value;"
    },
    {
        "line": 129,
        "fullcodeline": "tls_io_instance->x509_private_key_type = type;"
    },
    {
        "line": 130,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 134,
        "fullcodeline": "LogError(\"Unknown x509PrivatekeyType type %d\", type);"
    },
    {
        "line": 135,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 138,
        "fullcodeline": "else if (strcmp(\"tls_validation_callback\", optionName) == 0)"
    },
    {
        "line": 144,
        "fullcodeline": "tls_io_instance->tls_validation_callback = (TLS_CERTIFICATE_VALIDATION_CALLBACK)value;"
    },
    {
        "line": 154,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 151,
        "fullcodeline": "SSL_CTX_set_cert_verify_callback(tls_io_instance->ssl_context, tls_io_instance->tls_validation_callback, tls_io_instance->tls_validation_callback_data);"
    },
    {
        "line": 156,
        "fullcodeline": "else if (strcmp(\"tls_validation_callback_data\", optionName) == 0)"
    },
    {
        "line": 158,
        "fullcodeline": "tls_io_instance->tls_validation_callback_data = (void*)value;"
    },
    {
        "line": 165,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 160,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 162,
        "fullcodeline": "SSL_CTX_set_cert_verify_callback(tls_io_instance->ssl_context, tls_io_instance->tls_validation_callback, tls_io_instance->tls_validation_callback_data);"
    },
    {
        "line": 167,
        "fullcodeline": "else if (strcmp(OPTION_TLS_VERSION, optionName) == 0)"
    },
    {
        "line": 169,
        "fullcodeline": "if (tls_io_instance->ssl_context != NULL)"
    },
    {
        "line": 171,
        "fullcodeline": "LogError(\"Unable to set the tls version after the tls connection is established\");"
    },
    {
        "line": 172,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 197,
        "fullcodeline": "else if (strcmp(optionName, OPTION_UNDERLYING_IO_OPTIONS) == 0)"
    },
    {
        "line": 176,
        "fullcodeline": "const int version_option = *(const int*)value;"
    },
    {
        "line": 194,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 177,
        "fullcodeline": "if (version_option == 0 || version_option == 10)"
    },
    {
        "line": 199,
        "fullcodeline": "if (OptionHandler_FeedOptions((OPTIONHANDLER_HANDLE)value, (void*)tls_io_instance->underlying_io) != OPTIONHANDLER_OK)"
    },
    {
        "line": 179,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_0;"
    },
    {
        "line": 201,
        "fullcodeline": "LogError(\"failed feeding options to underlying I/O instance\");"
    },
    {
        "line": 202,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 209,
        "fullcodeline": "else if (strcmp(optionName, OPTION_SET_TLS_RENEGOTIATION) == 0)"
    },
    {
        "line": 206,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 212,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 181,
        "fullcodeline": "else if (version_option == 11)"
    },
    {
        "line": 183,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_1;"
    },
    {
        "line": 214,
        "fullcodeline": "else if (strcmp(\"ignore_host_name_check\", optionName) == 0)"
    },
    {
        "line": 216,
        "fullcodeline": "bool* server_name_check = (bool*)value;"
    },
    {
        "line": 217,
        "fullcodeline": "tls_io_instance->ignore_host_name_check = *server_name_check;"
    },
    {
        "line": 218,
        "fullcodeline": "result = 0;"
    },
    {
        "line": 185,
        "fullcodeline": "else if (version_option == 12)"
    },
    {
        "line": 187,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_2;"
    },
    {
        "line": 222,
        "fullcodeline": "if (tls_io_instance->underlying_io == NULL)"
    },
    {
        "line": 191,
        "fullcodeline": "LogInfo(\"Value of TLS version option %d is not found shall default to version 1.2\", version_option);"
    },
    {
        "line": 192,
        "fullcodeline": "tls_io_instance->tls_version = VERSION_1_2;"
    },
    {
        "line": 224,
        "fullcodeline": "result = MU_FAILURE;"
    },
    {
        "line": 228,
        "fullcodeline": "result = xio_setoption(tls_io_instance->underlying_io, optionName, value);"
    }
]