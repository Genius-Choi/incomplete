[
    {
        "line": 8,
        "fullcodeline": "int\t\tcount = 0;\t// extra spaces to replace a cut TAB"
    },
    {
        "line": 9,
        "fullcodeline": "int\t\tspaces = 0;\t// non-zero if cutting a TAB"
    },
    {
        "line": 15,
        "fullcodeline": "int\t\toldstate = State;"
    },
    {
        "line": 17,
        "fullcodeline": "State = INSERT;\t\t// don't want REPLACE for State"
    },
    {
        "line": 18,
        "fullcodeline": "s_len = (unsigned)STRLEN(s);"
    },
    {
        "line": 133,
        "fullcodeline": "changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);"
    },
    {
        "line": 135,
        "fullcodeline": "State = oldstate;"
    },
    {
        "line": 20,
        "fullcodeline": "for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)"
    },
    {
        "line": 22,
        "fullcodeline": "block_prep(oap, bdp, lnum, TRUE);"
    },
    {
        "line": 26,
        "fullcodeline": "oldp = ml_get(lnum);"
    },
    {
        "line": 79,
        "fullcodeline": "newp = alloc(STRLEN(oldp) + spaces + s_len"
    },
    {
        "line": 86,
        "fullcodeline": "mch_memmove(newp, oldp, (size_t)offset);"
    },
    {
        "line": 87,
        "fullcodeline": "oldp += offset;"
    },
    {
        "line": 90,
        "fullcodeline": "vim_memset(newp + offset, ' ', (size_t)spaces);"
    },
    {
        "line": 91,
        "fullcodeline": "startcol = offset + spaces;"
    },
    {
        "line": 94,
        "fullcodeline": "mch_memmove(newp + startcol, s, (size_t)s_len);"
    },
    {
        "line": 95,
        "fullcodeline": "offset += s_len;"
    },
    {
        "line": 116,
        "fullcodeline": "STRMOVE(newp + offset, oldp);"
    },
    {
        "line": 118,
        "fullcodeline": "ml_replace(lnum, newp, FALSE);"
    },
    {
        "line": 23,
        "fullcodeline": "if (bdp->is_short && b_insert)"
    },
    {
        "line": 56,
        "fullcodeline": "if (has_mbyte && spaces > 0)"
    },
    {
        "line": 75,
        "fullcodeline": "if (spaces < 0)  // can happen when the cursor was moved"
    },
    {
        "line": 82,
        "fullcodeline": "if (newp == NULL)"
    },
    {
        "line": 97,
        "fullcodeline": "if (spaces > 0 && !bdp->is_short)"
    },
    {
        "line": 114,
        "fullcodeline": "if (spaces > 0)"
    },
    {
        "line": 124,
        "fullcodeline": "if (lnum == oap->end.lnum)"
    },
    {
        "line": 30,
        "fullcodeline": "ts_val = bdp->start_char_vcols;"
    },
    {
        "line": 31,
        "fullcodeline": "spaces = bdp->startspaces;"
    },
    {
        "line": 34,
        "fullcodeline": "offset = bdp->textcol;"
    },
    {
        "line": 76,
        "fullcodeline": "spaces = 0;"
    },
    {
        "line": 115,
        "fullcodeline": "offset += count;"
    },
    {
        "line": 122,
        "fullcodeline": "inserted_bytes(lnum, startcol, s_len);"
    },
    {
        "line": 128,
        "fullcodeline": "curbuf->b_op_end.lnum = oap->end.lnum;"
    },
    {
        "line": 129,
        "fullcodeline": "curbuf->b_op_end.col = offset;"
    },
    {
        "line": 32,
        "fullcodeline": "if (spaces != 0)"
    },
    {
        "line": 38,
        "fullcodeline": "ts_val = bdp->end_char_vcols;"
    },
    {
        "line": 99,
        "fullcodeline": "if (*oldp == TAB)"
    },
    {
        "line": 33,
        "fullcodeline": "count = ts_val - 1; // we're cutting a TAB"
    },
    {
        "line": 39,
        "fullcodeline": "if (!bdp->is_short) // spaces = padding after block"
    },
    {
        "line": 63,
        "fullcodeline": "off = (*mb_head_off)(oldp, oldp + offset + spaces);"
    },
    {
        "line": 64,
        "fullcodeline": "spaces -= off;"
    },
    {
        "line": 65,
        "fullcodeline": "count -= off;"
    },
    {
        "line": 102,
        "fullcodeline": "vim_memset(newp + offset + spaces, ' ',"
    },
    {
        "line": 105,
        "fullcodeline": "oldp++;"
    },
    {
        "line": 107,
        "fullcodeline": "count++;"
    },
    {
        "line": 41,
        "fullcodeline": "spaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);"
    },
    {
        "line": 44,
        "fullcodeline": "offset = bdp->textcol + bdp->textlen - (spaces != 0);"
    },
    {
        "line": 71,
        "fullcodeline": "off = (*mb_head_off)(oldp, oldp + offset);"
    },
    {
        "line": 72,
        "fullcodeline": "offset -= off;"
    },
    {
        "line": 80,
        "fullcodeline": "+ (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)"
    },
    {
        "line": 103,
        "fullcodeline": "(size_t)(ts_val - spaces));"
    },
    {
        "line": 111,
        "fullcodeline": "count = spaces;"
    },
    {
        "line": 42,
        "fullcodeline": "if (spaces != 0)"
    },
    {
        "line": 51,
        "fullcodeline": "count = spaces;"
    },
    {
        "line": 52,
        "fullcodeline": "offset = bdp->textcol + bdp->textlen;"
    },
    {
        "line": 43,
        "fullcodeline": "count = ts_val - 1; // we're cutting a TAB"
    },
    {
        "line": 49,
        "fullcodeline": "if (!bdp->is_MAX)"
    },
    {
        "line": 50,
        "fullcodeline": "spaces = (oap->end_vcol - bdp->end_vcol) + 1;"
    }
]