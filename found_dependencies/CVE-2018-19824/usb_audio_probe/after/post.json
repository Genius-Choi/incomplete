[
    {
        "line": 4,
        "fullcodeline": "struct usb_device *dev = interface_to_usbdev(intf);"
    },
    {
        "line": 5,
        "fullcodeline": "const struct snd_usb_audio_quirk *quirk ="
    },
    {
        "line": 15,
        "fullcodeline": "id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),"
    },
    {
        "line": 22,
        "fullcodeline": "err = snd_usb_apply_boot_quirk(dev, intf, quirk, id);"
    },
    {
        "line": 31,
        "fullcodeline": "chip = NULL;"
    },
    {
        "line": 32,
        "fullcodeline": "mutex_lock(&register_mutex);"
    },
    {
        "line": 75,
        "fullcodeline": "dev_set_drvdata(&dev->dev, chip);"
    },
    {
        "line": 85,
        "fullcodeline": "chip->txfr_quirk = 0;"
    },
    {
        "line": 86,
        "fullcodeline": "err = 1; /* continue */"
    },
    {
        "line": 105,
        "fullcodeline": "err = snd_card_register(chip->card);"
    },
    {
        "line": 109,
        "fullcodeline": "usb_chip[chip->index] = chip;"
    },
    {
        "line": 110,
        "fullcodeline": "chip->num_interfaces++;"
    },
    {
        "line": 111,
        "fullcodeline": "usb_set_intfdata(intf, chip);"
    },
    {
        "line": 112,
        "fullcodeline": "atomic_dec(&chip->active);"
    },
    {
        "line": 113,
        "fullcodeline": "mutex_unlock(&register_mutex);"
    },
    {
        "line": 125,
        "fullcodeline": "mutex_unlock(&register_mutex);"
    },
    {
        "line": 6,
        "fullcodeline": "(const struct snd_usb_audio_quirk *)usb_id->driver_info;"
    },
    {
        "line": 17,
        "fullcodeline": "if (get_alias_id(dev, &id))"
    },
    {
        "line": 19,
        "fullcodeline": "if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)"
    },
    {
        "line": 23,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 33,
        "fullcodeline": "for (i = 0; i < SNDRV_CARDS; i++) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (! chip) {"
    },
    {
        "line": 82,
        "fullcodeline": "if (!chip->ctrl_intf)"
    },
    {
        "line": 87,
        "fullcodeline": "if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (err > 0) {"
    },
    {
        "line": 106,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 14,
        "fullcodeline": "ifnum = get_iface_desc(alts)->bInterfaceNumber;"
    },
    {
        "line": 18,
        "fullcodeline": "quirk = get_alias_quirk(dev, id);"
    },
    {
        "line": 83,
        "fullcodeline": "chip->ctrl_intf = alts;"
    },
    {
        "line": 89,
        "fullcodeline": "err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);"
    },
    {
        "line": 96,
        "fullcodeline": "err = snd_usb_create_streams(chip, ifnum);"
    },
    {
        "line": 99,
        "fullcodeline": "err = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);"
    },
    {
        "line": 121,
        "fullcodeline": "atomic_dec(&chip->active);"
    },
    {
        "line": 20,
        "fullcodeline": "return -ENXIO;"
    },
    {
        "line": 34,
        "fullcodeline": "if (usb_chip[i] && usb_chip[i]->dev == dev) {"
    },
    {
        "line": 49,
        "fullcodeline": "for (i = 0; i < SNDRV_CARDS; i++)"
    },
    {
        "line": 69,
        "fullcodeline": "if (!chip) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 97,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 100,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 122,
        "fullcodeline": "if (!chip->num_interfaces)"
    },
    {
        "line": 40,
        "fullcodeline": "chip = usb_chip[i];"
    },
    {
        "line": 41,
        "fullcodeline": "atomic_inc(&chip->active); /* avoid autopm */"
    },
    {
        "line": 50,
        "fullcodeline": "if (!usb_chip[i] &&"
    },
    {
        "line": 70,
        "fullcodeline": "dev_err(&dev->dev, \"no available usb audio device\\n\");"
    },
    {
        "line": 71,
        "fullcodeline": "err = -ENODEV;"
    },
    {
        "line": 123,
        "fullcodeline": "snd_card_free(chip->card);"
    },
    {
        "line": 52,
        "fullcodeline": "(pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {"
    },
    {
        "line": 36,
        "fullcodeline": "dev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");"
    },
    {
        "line": 37,
        "fullcodeline": "err = -EIO;"
    },
    {
        "line": 51,
        "fullcodeline": "(vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&"
    },
    {
        "line": 54,
        "fullcodeline": "err = snd_usb_audio_create(intf, dev, i, quirk,"
    },
    {
        "line": 58,
        "fullcodeline": "chip->pm_intf = intf;"
    },
    {
        "line": 56,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 60,
        "fullcodeline": "} else if (vid[i] != -1 || pid[i] != -1) {"
    },
    {
        "line": 61,
        "fullcodeline": "dev_info(&dev->dev,"
    },
    {
        "line": 65,
        "fullcodeline": "err = -ENOENT;"
    },
    {
        "line": 63,
        "fullcodeline": "USB_ID_VENDOR(id),"
    },
    {
        "line": 64,
        "fullcodeline": "USB_ID_PRODUCT(id));"
    }
]