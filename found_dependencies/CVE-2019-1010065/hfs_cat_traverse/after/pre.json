[
    {
        "line": 4,
        "fullcodeline": "TSK_FS_INFO *fs = &(hfs->fs_info);"
    },
    {
        "line": 9,
        "fullcodeline": "uint8_t is_done = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "tsk_error_reset();"
    },
    {
        "line": 13,
        "fullcodeline": "nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);"
    },
    {
        "line": 18,
        "fullcodeline": "cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);"
    },
    {
        "line": 38,
        "fullcodeline": "is_done = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "if ((node = (char *) tsk_malloc(nodesize)) == NULL)"
    },
    {
        "line": 24,
        "fullcodeline": "if (cur_node == 0) {"
    },
    {
        "line": 39,
        "fullcodeline": "while (is_done == 0) {"
    },
    {
        "line": 56,
        "fullcodeline": "cur_off = cur_node * nodesize;"
    },
    {
        "line": 57,
        "fullcodeline": "cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,"
    },
    {
        "line": 79,
        "fullcodeline": "node_desc = (hfs_btree_node *) node;"
    },
    {
        "line": 80,
        "fullcodeline": "num_rec = tsk_getu16(fs->endian, node_desc->num_rec);"
    },
    {
        "line": 46,
        "fullcodeline": "if (cur_node > tsk_getu32(fs->endian,"
    },
    {
        "line": 59,
        "fullcodeline": "if (cnt != nodesize) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (nodesize < sizeof(hfs_btree_node)) {"
    },
    {
        "line": 87,
        "fullcodeline": "if (num_rec == 0) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {"
    },
    {
        "line": 98,
        "fullcodeline": "uint32_t next_node = 0;"
    },
    {
        "line": 199,
        "fullcodeline": "cur_node = next_node;"
    },
    {
        "line": 101,
        "fullcodeline": "for (rec = 0; rec < num_rec; ++rec) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (next_node == 0) {"
    },
    {
        "line": 191,
        "fullcodeline": "if (next_node == cur_node) {"
    },
    {
        "line": 62,
        "fullcodeline": "tsk_error_set_errno(TSK_ERR_FS_READ);"
    },
    {
        "line": 108,
        "fullcodeline": "rec_off ="
    },
    {
        "line": 121,
        "fullcodeline": "key = (hfs_btree_key_cat *) & node[rec_off];"
    },
    {
        "line": 123,
        "fullcodeline": "keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);"
    },
    {
        "line": 145,
        "fullcodeline": "retval ="
    },
    {
        "line": 203,
        "fullcodeline": "else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {"
    },
    {
        "line": 109,
        "fullcodeline": "tsk_getu16(fs->endian,"
    },
    {
        "line": 111,
        "fullcodeline": "if (rec_off > nodesize) {"
    },
    {
        "line": 124,
        "fullcodeline": "if ((keylen) > nodesize) {"
    },
    {
        "line": 146,
        "fullcodeline": "a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,"
    },
    {
        "line": 148,
        "fullcodeline": "if (retval == HFS_BTREE_CB_ERR) {"
    },
    {
        "line": 176,
        "fullcodeline": "if (retval == HFS_BTREE_CB_IDX_EQGT) {"
    },
    {
        "line": 206,
        "fullcodeline": "for (rec = 0; rec < num_rec; ++rec) {"
    },
    {
        "line": 264,
        "fullcodeline": "if (is_done == 0) {"
    },
    {
        "line": 213,
        "fullcodeline": "rec_off ="
    },
    {
        "line": 225,
        "fullcodeline": "key = (hfs_btree_key_cat *) & node[rec_off];"
    },
    {
        "line": 227,
        "fullcodeline": "keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);"
    },
    {
        "line": 247,
        "fullcodeline": "retval ="
    },
    {
        "line": 265,
        "fullcodeline": "cur_node = tsk_getu32(fs->endian, node_desc->flink);"
    },
    {
        "line": 110,
        "fullcodeline": "&node[nodesize - (rec + 1) * 2]);"
    },
    {
        "line": 214,
        "fullcodeline": "tsk_getu16(fs->endian,"
    },
    {
        "line": 216,
        "fullcodeline": "if (rec_off > nodesize) {"
    },
    {
        "line": 228,
        "fullcodeline": "if ((keylen) > nodesize) {"
    },
    {
        "line": 248,
        "fullcodeline": "a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,"
    },
    {
        "line": 250,
        "fullcodeline": "if (retval == HFS_BTREE_CB_LEAF_STOP) {"
    },
    {
        "line": 266,
        "fullcodeline": "if (cur_node == 0) {"
    },
    {
        "line": 156,
        "fullcodeline": "else if ((retval == HFS_BTREE_CB_IDX_LT)"
    },
    {
        "line": 157,
        "fullcodeline": "|| (next_node == 0)) {"
    },
    {
        "line": 159,
        "fullcodeline": "int keylen ="
    },
    {
        "line": 171,
        "fullcodeline": "idx_rec ="
    },
    {
        "line": 174,
        "fullcodeline": "next_node = tsk_getu32(fs->endian, idx_rec->childNode);"
    },
    {
        "line": 251,
        "fullcodeline": "is_done = 1;"
    },
    {
        "line": 267,
        "fullcodeline": "is_done = 1;"
    },
    {
        "line": 162,
        "fullcodeline": "if (rec_off + keylen > nodesize) {"
    },
    {
        "line": 160,
        "fullcodeline": "2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,"
    },
    {
        "line": 215,
        "fullcodeline": "&node[nodesize - (rec + 1) * 2]);"
    },
    {
        "line": 254,
        "fullcodeline": "else if (retval == HFS_BTREE_CB_ERR) {"
    }
]