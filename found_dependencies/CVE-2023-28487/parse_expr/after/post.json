[
    {
        "line": 3,
        "fullcodeline": "bool or = false, not = false;"
    },
    {
        "line": 7,
        "fullcodeline": "debug_decl(parse_expr, SUDO_DEBUG_UTIL);"
    },
    {
        "line": 123,
        "fullcodeline": "debug_return_int(av - argv);"
    },
    {
        "line": 9,
        "fullcodeline": "for (av = argv; *av != NULL; av++) {"
    },
    {
        "line": 90,
        "fullcodeline": "sn->type = type;"
    },
    {
        "line": 91,
        "fullcodeline": "sn->or = or;"
    },
    {
        "line": 92,
        "fullcodeline": "sn->negated = not;"
    },
    {
        "line": 113,
        "fullcodeline": "not = or = false; /* reset state */"
    },
    {
        "line": 114,
        "fullcodeline": "STAILQ_INSERT_TAIL(head, sn, entries);"
    },
    {
        "line": 117,
        "fullcodeline": "sudo_fatalx(\"%s\", U_(\"unmatched '(' in expression\"));"
    },
    {
        "line": 119,
        "fullcodeline": "sudo_fatalx(\"%s\", U_(\"illegal trailing \\\"or\\\"\"));"
    },
    {
        "line": 121,
        "fullcodeline": "sudo_fatalx(\"%s\", U_(\"illegal trailing \\\"!\\\"\"));"
    },
    {
        "line": 88,
        "fullcodeline": "if ((sn = calloc(1, sizeof(*sn))) == NULL)"
    },
    {
        "line": 93,
        "fullcodeline": "if (type == ST_EXPR) {"
    },
    {
        "line": 18,
        "fullcodeline": "or = true;"
    },
    {
        "line": 23,
        "fullcodeline": "not = true;"
    },
    {
        "line": 38,
        "fullcodeline": "type = ST_FROMDATE;"
    },
    {
        "line": 43,
        "fullcodeline": "type = ST_RUNASGROUP;"
    },
    {
        "line": 48,
        "fullcodeline": "type = ST_HOST;"
    },
    {
        "line": 53,
        "fullcodeline": "type = ST_RUNASUSER;"
    },
    {
        "line": 68,
        "fullcodeline": "type = ST_USER;"
    },
    {
        "line": 73,
        "fullcodeline": "type = ST_EXPR;"
    },
    {
        "line": 80,
        "fullcodeline": "debug_return_int(av - argv + 1);"
    },
    {
        "line": 83,
        "fullcodeline": "sudo_fatalx(U_(\"unknown search term \\\"%s\\\"\"), *av);"
    },
    {
        "line": 89,
        "fullcodeline": "sudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));"
    },
    {
        "line": 94,
        "fullcodeline": "STAILQ_INIT(&sn->u.expr);"
    },
    {
        "line": 95,
        "fullcodeline": "av += parse_expr(&sn->u.expr, av + 1, true);"
    },
    {
        "line": 12,
        "fullcodeline": "if (strncmp(*av, \"and\", strlen(*av)) != 0)"
    },
    {
        "line": 16,
        "fullcodeline": "if (strncmp(*av, \"or\", strlen(*av)) != 0)"
    },
    {
        "line": 21,
        "fullcodeline": "if (av[0][1] != '\\0')"
    },
    {
        "line": 26,
        "fullcodeline": "if (av[0][1] == '\\0')"
    },
    {
        "line": 28,
        "fullcodeline": "if (strncmp(*av, \"cwd\", strlen(*av)) == 0)"
    },
    {
        "line": 36,
        "fullcodeline": "if (strncmp(*av, \"fromdate\", strlen(*av)) != 0)"
    },
    {
        "line": 41,
        "fullcodeline": "if (strncmp(*av, \"group\", strlen(*av)) != 0)"
    },
    {
        "line": 46,
        "fullcodeline": "if (strncmp(*av, \"host\", strlen(*av)) != 0)"
    },
    {
        "line": 51,
        "fullcodeline": "if (strncmp(*av, \"runas\", strlen(*av)) != 0)"
    },
    {
        "line": 56,
        "fullcodeline": "if (av[0][1] == '\\0')"
    },
    {
        "line": 58,
        "fullcodeline": "if (strncmp(*av, \"todate\", strlen(*av)) == 0)"
    },
    {
        "line": 66,
        "fullcodeline": "if (strncmp(*av, \"user\", strlen(*av)) != 0)"
    },
    {
        "line": 71,
        "fullcodeline": "if (av[0][1] != '\\0')"
    },
    {
        "line": 76,
        "fullcodeline": "if (av[0][1] != '\\0')"
    },
    {
        "line": 78,
        "fullcodeline": "if (!sub_expr)"
    },
    {
        "line": 27,
        "fullcodeline": "sudo_fatalx(U_(\"ambiguous expression \\\"%s\\\"\"), *av);"
    },
    {
        "line": 29,
        "fullcodeline": "type = ST_CWD;"
    },
    {
        "line": 57,
        "fullcodeline": "sudo_fatalx(U_(\"ambiguous expression \\\"%s\\\"\"), *av);"
    },
    {
        "line": 59,
        "fullcodeline": "type = ST_TODATE;"
    },
    {
        "line": 79,
        "fullcodeline": "sudo_fatalx(\"%s\", U_(\"unmatched ')' in expression\"));"
    },
    {
        "line": 97,
        "fullcodeline": "if (*(++av) == NULL)"
    },
    {
        "line": 99,
        "fullcodeline": "if (type == ST_PATTERN) {"
    },
    {
        "line": 98,
        "fullcodeline": "sudo_fatalx(U_(\"%s requires an argument\"), av[-1]);"
    },
    {
        "line": 30,
        "fullcodeline": "else if (strncmp(*av, \"command\", strlen(*av)) == 0)"
    },
    {
        "line": 60,
        "fullcodeline": "else if (strncmp(*av, \"tty\", strlen(*av)) == 0)"
    },
    {
        "line": 100,
        "fullcodeline": "if (!sudo_regex_compile(&sn->u.cmdre, *av, &errstr)) {"
    },
    {
        "line": 31,
        "fullcodeline": "type = ST_PATTERN;"
    },
    {
        "line": 61,
        "fullcodeline": "type = ST_TTY;"
    },
    {
        "line": 101,
        "fullcodeline": "sudo_fatalx(U_(\"invalid regular expression \\\"%s\\\": %s\"),"
    },
    {
        "line": 104,
        "fullcodeline": "} else if (type == ST_TODATE || type == ST_FROMDATE) {"
    },
    {
        "line": 102,
        "fullcodeline": "*av, U_(errstr));"
    },
    {
        "line": 105,
        "fullcodeline": "sn->u.tstamp.tv_sec = get_date(*av);"
    },
    {
        "line": 106,
        "fullcodeline": "sn->u.tstamp.tv_nsec = 0;"
    },
    {
        "line": 107,
        "fullcodeline": "if (sn->u.tstamp.tv_sec == -1)"
    },
    {
        "line": 110,
        "fullcodeline": "sn->u.ptr = *av;"
    },
    {
        "line": 108,
        "fullcodeline": "sudo_fatalx(U_(\"could not parse date \\\"%s\\\"\"), *av);"
    }
]