[
    {
        "line": 5,
        "fullcodeline": "struct sock *sk = sock->sk;"
    },
    {
        "line": 6,
        "fullcodeline": "struct tcp_splice_state tss = {"
    },
    {
        "line": 15,
        "fullcodeline": "sock_rps_record_flow(sk);"
    },
    {
        "line": 22,
        "fullcodeline": "ret = spliced = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 26,
        "fullcodeline": "timeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);"
    },
    {
        "line": 19,
        "fullcodeline": "if (unlikely(*ppos))"
    },
    {
        "line": 28,
        "fullcodeline": "ret = __tcp_splice_read(sk, &tss);"
    },
    {
        "line": 68,
        "fullcodeline": "tss.len -= ret;"
    },
    {
        "line": 69,
        "fullcodeline": "spliced += ret;"
    },
    {
        "line": 73,
        "fullcodeline": "release_sock(sk);"
    },
    {
        "line": 74,
        "fullcodeline": "lock_sock(sk);"
    },
    {
        "line": 7,
        "fullcodeline": ".pipe = pipe,"
    },
    {
        "line": 8,
        "fullcodeline": ".len = len,"
    },
    {
        "line": 9,
        "fullcodeline": ".flags = flags,"
    },
    {
        "line": 20,
        "fullcodeline": "return -ESPIPE;"
    },
    {
        "line": 29,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 71,
        "fullcodeline": "if (!timeo)"
    },
    {
        "line": 76,
        "fullcodeline": "if (sk->sk_err || sk->sk_state == TCP_CLOSE ||"
    },
    {
        "line": 78,
        "fullcodeline": "signal_pending(current))"
    },
    {
        "line": 77,
        "fullcodeline": "(sk->sk_shutdown & RCV_SHUTDOWN) ||"
    },
    {
        "line": 31,
        "fullcodeline": "else if (!ret) {"
    },
    {
        "line": 61,
        "fullcodeline": "sk_wait_data(sk, &timeo, NULL);"
    },
    {
        "line": 34,
        "fullcodeline": "if (sock_flag(sk, SOCK_DONE))"
    },
    {
        "line": 40,
        "fullcodeline": "if (sk->sk_shutdown & RCV_SHUTDOWN)"
    },
    {
        "line": 42,
        "fullcodeline": "if (sk->sk_state == TCP_CLOSE) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (!timeo) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (signal_pending(current)) {"
    },
    {
        "line": 37,
        "fullcodeline": "ret = sock_error(sk);"
    },
    {
        "line": 52,
        "fullcodeline": "ret = -EAGAIN;"
    },
    {
        "line": 59,
        "fullcodeline": "if (!skb_queue_empty(&sk->sk_receive_queue))"
    },
    {
        "line": 63,
        "fullcodeline": "ret = sock_intr_errno(timeo);"
    },
    {
        "line": 47,
        "fullcodeline": "if (!sock_flag(sk, SOCK_DONE))"
    },
    {
        "line": 48,
        "fullcodeline": "ret = -ENOTCONN;"
    }
]