[
    {
        "line": 5,
        "fullcodeline": "vips_tracked_init();"
    },
    {
        "line": 11,
        "fullcodeline": "size += 16;"
    },
    {
        "line": 27,
        "fullcodeline": "g_mutex_lock( vips_tracked_mutex );"
    },
    {
        "line": 29,
        "fullcodeline": "*((size_t *)buf) = size;"
    },
    {
        "line": 30,
        "fullcodeline": "buf = (void *) ((char *)buf + 16);"
    },
    {
        "line": 32,
        "fullcodeline": "vips_tracked_mem += size;"
    },
    {
        "line": 35,
        "fullcodeline": "vips_tracked_allocs += 1;"
    },
    {
        "line": 41,
        "fullcodeline": "g_mutex_unlock( vips_tracked_mutex );"
    },
    {
        "line": 43,
        "fullcodeline": "VIPS_GATE_MALLOC( size );"
    },
    {
        "line": 13,
        "fullcodeline": "if( !(buf = g_try_malloc0( size )) ) {"
    },
    {
        "line": 33,
        "fullcodeline": "if( vips_tracked_mem > vips_tracked_mem_highwater )"
    },
    {
        "line": 18,
        "fullcodeline": "vips_error( \"vips_tracked\","
    },
    {
        "line": 21,
        "fullcodeline": "g_warning( _( \"out of memory --- size == %dMB\" ),"
    },
    {
        "line": 34,
        "fullcodeline": "vips_tracked_mem_highwater = vips_tracked_mem;"
    },
    {
        "line": 19,
        "fullcodeline": "_( \"out of memory --- size == %dMB\" ),"
    },
    {
        "line": 20,
        "fullcodeline": "(int) (size / (1024.0 * 1024.0))  );"
    },
    {
        "line": 22,
        "fullcodeline": "(int) (size / (1024.0 * 1024.0))  );"
    }
]