[
    {
        "line": 3,
        "fullcodeline": "struct perf_event *event = info;"
    },
    {
        "line": 4,
        "fullcodeline": "struct perf_event_context *ctx = event->ctx;"
    },
    {
        "line": 5,
        "fullcodeline": "struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);"
    },
    {
        "line": 17,
        "fullcodeline": "raw_spin_lock(&ctx->lock);"
    },
    {
        "line": 14,
        "fullcodeline": "if (ctx->task && cpuctx->task_ctx != ctx)"
    },
    {
        "line": 23,
        "fullcodeline": "if (event->state >= PERF_EVENT_STATE_INACTIVE) {"
    },
    {
        "line": 24,
        "fullcodeline": "update_context_time(ctx);"
    },
    {
        "line": 25,
        "fullcodeline": "update_cgrp_time_from_event(event);"
    },
    {
        "line": 26,
        "fullcodeline": "update_group_times(event);"
    },
    {
        "line": 31,
        "fullcodeline": "event->state = PERF_EVENT_STATE_OFF;"
    },
    {
        "line": 15,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 27,
        "fullcodeline": "if (event == event->group_leader)"
    },
    {
        "line": 28,
        "fullcodeline": "group_sched_out(event, cpuctx, ctx);"
    },
    {
        "line": 30,
        "fullcodeline": "event_sched_out(event, cpuctx, ctx);"
    }
]