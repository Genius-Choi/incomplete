[
    {
        "line": 120,
        "fullcodeline": "assert(image_info != (const ImageInfo *) NULL);"
    },
    {
        "line": 121,
        "fullcodeline": "assert(image_info->signature == MagickCoreSignature);"
    },
    {
        "line": 125,
        "fullcodeline": "assert(exception != (ExceptionInfo *) NULL);"
    },
    {
        "line": 126,
        "fullcodeline": "assert(exception->signature == MagickCoreSignature);"
    },
    {
        "line": 127,
        "fullcodeline": "image=AcquireImage(image_info,exception);"
    },
    {
        "line": 128,
        "fullcodeline": "status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);"
    },
    {
        "line": 137,
        "fullcodeline": "count=ReadBlob(image,1,&viff_info.identifier);"
    },
    {
        "line": 122,
        "fullcodeline": "if (image_info->debug != MagickFalse)"
    },
    {
        "line": 129,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 645,
        "fullcodeline": "} while ((count != 0) && (viff_info.identifier == 0xab));"
    },
    {
        "line": 646,
        "fullcodeline": "(void) CloseBlob(image);"
    },
    {
        "line": 649,
        "fullcodeline": "return(GetFirstImageInList(image));"
    },
    {
        "line": 123,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\","
    },
    {
        "line": 131,
        "fullcodeline": "image=DestroyImageList(image);"
    },
    {
        "line": 154,
        "fullcodeline": "count=ReadBlob(image,512,(unsigned char *) viff_info.comment);"
    },
    {
        "line": 157,
        "fullcodeline": "viff_info.comment[511]='\\0';"
    },
    {
        "line": 165,
        "fullcodeline": "viff_info.rows=ReadBlobLong(image);"
    },
    {
        "line": 166,
        "fullcodeline": "viff_info.columns=ReadBlobLong(image);"
    },
    {
        "line": 170,
        "fullcodeline": "viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);"
    },
    {
        "line": 172,
        "fullcodeline": "viff_info.location_type=ReadBlobLong(image);"
    },
    {
        "line": 174,
        "fullcodeline": "viff_info.number_of_images=ReadBlobLong(image);"
    },
    {
        "line": 175,
        "fullcodeline": "viff_info.number_data_bands=ReadBlobLong(image);"
    },
    {
        "line": 176,
        "fullcodeline": "viff_info.data_storage_type=ReadBlobLong(image);"
    },
    {
        "line": 177,
        "fullcodeline": "viff_info.data_encode_scheme=ReadBlobLong(image);"
    },
    {
        "line": 178,
        "fullcodeline": "viff_info.map_scheme=ReadBlobLong(image);"
    },
    {
        "line": 179,
        "fullcodeline": "viff_info.map_storage_type=ReadBlobLong(image);"
    },
    {
        "line": 180,
        "fullcodeline": "viff_info.map_rows=ReadBlobLong(image);"
    },
    {
        "line": 181,
        "fullcodeline": "viff_info.map_columns=ReadBlobLong(image);"
    },
    {
        "line": 185,
        "fullcodeline": "viff_info.color_space_model=ReadBlobLong(image);"
    },
    {
        "line": 190,
        "fullcodeline": "number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;"
    },
    {
        "line": 197,
        "fullcodeline": "image->columns=viff_info.rows;"
    },
    {
        "line": 198,
        "fullcodeline": "image->rows=viff_info.columns;"
    },
    {
        "line": 199,
        "fullcodeline": "image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :"
    },
    {
        "line": 201,
        "fullcodeline": "image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :"
    },
    {
        "line": 203,
        "fullcodeline": "status=SetImageExtent(image,image->columns,image->rows,exception);"
    },
    {
        "line": 390,
        "fullcodeline": "pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax("
    },
    {
        "line": 397,
        "fullcodeline": "lsb_first=1;"
    },
    {
        "line": 416,
        "fullcodeline": "min_value=0.0;"
    },
    {
        "line": 417,
        "fullcodeline": "scale_factor=1.0;"
    },
    {
        "line": 467,
        "fullcodeline": "p=(unsigned char *) pixels;"
    },
    {
        "line": 493,
        "fullcodeline": "p=(unsigned char *) pixels;"
    },
    {
        "line": 627,
        "fullcodeline": "count=ReadBlob(image,1,&viff_info.identifier);"
    },
    {
        "line": 132,
        "fullcodeline": "return((Image *) NULL);"
    },
    {
        "line": 148,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);"
    },
    {
        "line": 149,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);"
    },
    {
        "line": 150,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);"
    },
    {
        "line": 151,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.machine_dependency),"
    },
    {
        "line": 153,
        "fullcodeline": "(void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);"
    },
    {
        "line": 167,
        "fullcodeline": "viff_info.subrows=ReadBlobLong(image);"
    },
    {
        "line": 168,
        "fullcodeline": "viff_info.x_offset=ReadBlobSignedLong(image);"
    },
    {
        "line": 169,
        "fullcodeline": "viff_info.y_offset=ReadBlobSignedLong(image);"
    },
    {
        "line": 173,
        "fullcodeline": "viff_info.location_dimension=ReadBlobLong(image);"
    },
    {
        "line": 182,
        "fullcodeline": "viff_info.map_subrows=ReadBlobLong(image);"
    },
    {
        "line": 183,
        "fullcodeline": "viff_info.map_enable=ReadBlobLong(image);"
    },
    {
        "line": 184,
        "fullcodeline": "viff_info.maps_per_cycle=ReadBlobLong(image);"
    },
    {
        "line": 186,
        "fullcodeline": "for (i=0; i < 420; i++)"
    },
    {
        "line": 188,
        "fullcodeline": "if (EOFBlob(image) != MagickFalse)"
    },
    {
        "line": 191,
        "fullcodeline": "if (number_pixels > GetBlobSize(image))"
    },
    {
        "line": 193,
        "fullcodeline": "if (number_pixels != (size_t) number_pixels)"
    },
    {
        "line": 195,
        "fullcodeline": "if (number_pixels == 0)"
    },
    {
        "line": 204,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 206,
        "fullcodeline": "(void) SetImageBackgroundColor(image,exception);"
    },
    {
        "line": 236,
        "fullcodeline": "if (viff_info.map_rows == 0)"
    },
    {
        "line": 355,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_TYP_BIT)"
    },
    {
        "line": 376,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_TYP_BIT)"
    },
    {
        "line": 392,
        "fullcodeline": "if (pixels == (unsigned char *) NULL)"
    },
    {
        "line": 394,
        "fullcodeline": "(void) memset(pixels,0,MagickMax(number_pixels,max_packets)*"
    },
    {
        "line": 396,
        "fullcodeline": "count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);"
    },
    {
        "line": 418,
        "fullcodeline": "if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&"
    },
    {
        "line": 468,
        "fullcodeline": "for (i=0; i < (ssize_t) max_packets; i++)"
    },
    {
        "line": 613,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 615,
        "fullcodeline": "if (EOFBlob(image) != MagickFalse)"
    },
    {
        "line": 624,
        "fullcodeline": "if (image_info->number_scenes != 0)"
    },
    {
        "line": 628,
        "fullcodeline": "if ((count == 1) && (viff_info.identifier == 0xab))"
    },
    {
        "line": 648,
        "fullcodeline": "return(DestroyImageList(image));"
    },
    {
        "line": 143,
        "fullcodeline": "if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))"
    },
    {
        "line": 144,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");"
    },
    {
        "line": 156,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 158,
        "fullcodeline": "if (strlen(viff_info.comment) > 4)"
    },
    {
        "line": 160,
        "fullcodeline": "if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||"
    },
    {
        "line": 161,
        "fullcodeline": "(viff_info.machine_dependency == VFF_DEP_NSORDER))"
    },
    {
        "line": 162,
        "fullcodeline": "image->endian=LSBEndian;"
    },
    {
        "line": 171,
        "fullcodeline": "viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);"
    },
    {
        "line": 187,
        "fullcodeline": "(void) ReadBlobByte(image);"
    },
    {
        "line": 189,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");"
    },
    {
        "line": 192,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
    },
    {
        "line": 194,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 196,
        "fullcodeline": "ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");"
    },
    {
        "line": 210,
        "fullcodeline": "if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))"
    },
    {
        "line": 211,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 212,
        "fullcodeline": "if ((viff_info.data_storage_type != VFF_TYP_BIT) &&"
    },
    {
        "line": 217,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_DOUBLE))"
    },
    {
        "line": 218,
        "fullcodeline": "ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");"
    },
    {
        "line": 220,
        "fullcodeline": "ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");"
    },
    {
        "line": 221,
        "fullcodeline": "if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&"
    },
    {
        "line": 226,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))"
    },
    {
        "line": 227,
        "fullcodeline": "ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");"
    },
    {
        "line": 228,
        "fullcodeline": "if ((viff_info.color_space_model != VFF_CM_NONE) &&"
    },
    {
        "line": 230,
        "fullcodeline": "(viff_info.color_space_model != VFF_CM_genericRGB))"
    },
    {
        "line": 231,
        "fullcodeline": "ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");"
    },
    {
        "line": 233,
        "fullcodeline": "ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");"
    },
    {
        "line": 235,
        "fullcodeline": "ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");"
    },
    {
        "line": 237,
        "fullcodeline": "viff_info.map_scheme=VFF_MS_NONE;"
    },
    {
        "line": 350,
        "fullcodeline": "ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");"
    },
    {
        "line": 352,
        "fullcodeline": "if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))"
    },
    {
        "line": 360,
        "fullcodeline": "image->colors=2;"
    },
    {
        "line": 363,
        "fullcodeline": "image->colorspace=GRAYColorspace;"
    },
    {
        "line": 370,
        "fullcodeline": "case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;"
    },
    {
        "line": 371,
        "fullcodeline": "case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;"
    },
    {
        "line": 372,
        "fullcodeline": "case VFF_TYP_FLOAT: bytes_per_pixel=4; break;"
    },
    {
        "line": 373,
        "fullcodeline": "case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;"
    },
    {
        "line": 374,
        "fullcodeline": "default: bytes_per_pixel=1; break;"
    },
    {
        "line": 380,
        "fullcodeline": "max_packets=((image->columns+7UL) >> 3UL)*image->rows;"
    },
    {
        "line": 388,
        "fullcodeline": "if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))"
    },
    {
        "line": 389,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 393,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 399,
        "fullcodeline": "((viff_info.machine_dependency != VFF_DEP_DECORDER) &&"
    },
    {
        "line": 419,
        "fullcodeline": "(viff_info.map_scheme == VFF_MS_NONE))"
    },
    {
        "line": 435,
        "fullcodeline": "max_value=value;"
    },
    {
        "line": 436,
        "fullcodeline": "min_value=value;"
    },
    {
        "line": 487,
        "fullcodeline": "*p=(unsigned char) ((Quantum) value);"
    },
    {
        "line": 612,
        "fullcodeline": "pixels=(unsigned char *) RelinquishMagickMemory(pixels);"
    },
    {
        "line": 617,
        "fullcodeline": "ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\","
    },
    {
        "line": 633,
        "fullcodeline": "AcquireNextImage(image_info,image,exception);"
    },
    {
        "line": 639,
        "fullcodeline": "image=SyncNextImageInList(image);"
    },
    {
        "line": 640,
        "fullcodeline": "status=SetImageProgress(image,LoadImagesTag,TellBlob(image),"
    },
    {
        "line": 159,
        "fullcodeline": "(void) SetImageProperty(image,\"comment\",viff_info.comment,exception);"
    },
    {
        "line": 164,
        "fullcodeline": "image->endian=MSBEndian;"
    },
    {
        "line": 205,
        "fullcodeline": "return(DestroyImageList(image));"
    },
    {
        "line": 216,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_FLOAT) &&"
    },
    {
        "line": 225,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&"
    },
    {
        "line": 229,
        "fullcodeline": "(viff_info.color_space_model != VFF_CM_ntscRGB) &&"
    },
    {
        "line": 278,
        "fullcodeline": "image->colors=viff_info.map_columns;"
    },
    {
        "line": 288,
        "fullcodeline": "viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,"
    },
    {
        "line": 297,
        "fullcodeline": "lsb_first=1;"
    },
    {
        "line": 353,
        "fullcodeline": "if (image->scene >= (image_info->scene+image_info->number_scenes-1))"
    },
    {
        "line": 361,
        "fullcodeline": "if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)"
    },
    {
        "line": 378,
        "fullcodeline": "if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)"
    },
    {
        "line": 386,
        "fullcodeline": "max_packets=(size_t) (number_pixels*viff_info.number_data_bands);"
    },
    {
        "line": 391,
        "fullcodeline": "number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));"
    },
    {
        "line": 400,
        "fullcodeline": "(viff_info.machine_dependency != VFF_DEP_NSORDER)))"
    },
    {
        "line": 437,
        "fullcodeline": "for (i=0; i < (ssize_t) max_packets; i++)"
    },
    {
        "line": 478,
        "fullcodeline": "if (viff_info.map_scheme == VFF_MS_NONE)"
    },
    {
        "line": 499,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 614,
        "fullcodeline": "(void) SyncImage(image,exception);"
    },
    {
        "line": 625,
        "fullcodeline": "if (image->scene >= (image_info->scene+image_info->number_scenes-1))"
    },
    {
        "line": 642,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 215,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_4_BYTE) &&"
    },
    {
        "line": 224,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&"
    },
    {
        "line": 242,
        "fullcodeline": "if (viff_info.number_data_bands < 3)"
    },
    {
        "line": 281,
        "fullcodeline": "if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)"
    },
    {
        "line": 290,
        "fullcodeline": "if (viff_colormap == (unsigned char *) NULL)"
    },
    {
        "line": 295,
        "fullcodeline": "count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,"
    },
    {
        "line": 318,
        "fullcodeline": "for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)"
    },
    {
        "line": 362,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 379,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 384,
        "fullcodeline": "if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)"
    },
    {
        "line": 429,
        "fullcodeline": "case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;"
    },
    {
        "line": 430,
        "fullcodeline": "case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;"
    },
    {
        "line": 431,
        "fullcodeline": "case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;"
    },
    {
        "line": 432,
        "fullcodeline": "case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;"
    },
    {
        "line": 433,
        "fullcodeline": "default: value=1.0*pixels[0]; break;"
    },
    {
        "line": 453,
        "fullcodeline": "if ((min_value == 0) && (max_value == 0))"
    },
    {
        "line": 454,
        "fullcodeline": "scale_factor=0;"
    },
    {
        "line": 472,
        "fullcodeline": "case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;"
    },
    {
        "line": 473,
        "fullcodeline": "case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;"
    },
    {
        "line": 474,
        "fullcodeline": "case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;"
    },
    {
        "line": 475,
        "fullcodeline": "case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;"
    },
    {
        "line": 476,
        "fullcodeline": "default: value=1.0*pixels[i]; break;"
    },
    {
        "line": 480,
        "fullcodeline": "value=(value-min_value)*scale_factor;"
    },
    {
        "line": 501,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 544,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 634,
        "fullcodeline": "if (GetNextImageInList(image) == (Image *) NULL)"
    },
    {
        "line": 636,
        "fullcodeline": "status=MagickFalse;"
    },
    {
        "line": 641,
        "fullcodeline": "GetBlobSize(image));"
    },
    {
        "line": 214,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_2_BYTE) &&"
    },
    {
        "line": 223,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&"
    },
    {
        "line": 254,
        "fullcodeline": "status=AcquireImageColormap(image,image->colors,exception);"
    },
    {
        "line": 271,
        "fullcodeline": "case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;"
    },
    {
        "line": 272,
        "fullcodeline": "case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;"
    },
    {
        "line": 273,
        "fullcodeline": "case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;"
    },
    {
        "line": 274,
        "fullcodeline": "case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;"
    },
    {
        "line": 275,
        "fullcodeline": "case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;"
    },
    {
        "line": 276,
        "fullcodeline": "default: bytes_per_pixel=1; break;"
    },
    {
        "line": 279,
        "fullcodeline": "if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))"
    },
    {
        "line": 280,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
    },
    {
        "line": 282,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 283,
        "fullcodeline": "if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))"
    },
    {
        "line": 284,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
    },
    {
        "line": 286,
        "fullcodeline": "(viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))"
    },
    {
        "line": 287,
        "fullcodeline": "ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
    },
    {
        "line": 291,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 299,
        "fullcodeline": "((viff_info.machine_dependency != VFF_DEP_DECORDER) &&"
    },
    {
        "line": 346,
        "fullcodeline": "viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);"
    },
    {
        "line": 385,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 405,
        "fullcodeline": "MSBOrderShort(pixels,bytes_per_pixel*max_packets);"
    },
    {
        "line": 411,
        "fullcodeline": "MSBOrderLong(pixels,bytes_per_pixel*max_packets);"
    },
    {
        "line": 447,
        "fullcodeline": "if (value > max_value)"
    },
    {
        "line": 481,
        "fullcodeline": "if (value > QuantumRange)"
    },
    {
        "line": 502,
        "fullcodeline": "if (q == (Quantum *) NULL)"
    },
    {
        "line": 504,
        "fullcodeline": "for (x=0; x < (ssize_t) (image->columns-7); x+=8)"
    },
    {
        "line": 532,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 534,
        "fullcodeline": "if (image->previous == (Image *) NULL)"
    },
    {
        "line": 213,
        "fullcodeline": "(viff_info.data_storage_type != VFF_TYP_1_BYTE) &&"
    },
    {
        "line": 222,
        "fullcodeline": "(viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&"
    },
    {
        "line": 247,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_TYP_BIT)"
    },
    {
        "line": 255,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 289,
        "fullcodeline": "viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));"
    },
    {
        "line": 300,
        "fullcodeline": "(viff_info.machine_dependency != VFF_DEP_NSORDER)))"
    },
    {
        "line": 328,
        "fullcodeline": "if (i < (ssize_t) image->colors)"
    },
    {
        "line": 441,
        "fullcodeline": "case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;"
    },
    {
        "line": 442,
        "fullcodeline": "case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;"
    },
    {
        "line": 443,
        "fullcodeline": "case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;"
    },
    {
        "line": 444,
        "fullcodeline": "case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;"
    },
    {
        "line": 445,
        "fullcodeline": "default: value=1.0*pixels[i]; break;"
    },
    {
        "line": 448,
        "fullcodeline": "max_value=value;"
    },
    {
        "line": 456,
        "fullcodeline": "if (min_value == max_value)"
    },
    {
        "line": 482,
        "fullcodeline": "value=QuantumRange;"
    },
    {
        "line": 516,
        "fullcodeline": "p++;"
    },
    {
        "line": 518,
        "fullcodeline": "if ((image->columns % 8) != 0)"
    },
    {
        "line": 530,
        "fullcodeline": "p++;"
    },
    {
        "line": 536,
        "fullcodeline": "status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,"
    },
    {
        "line": 545,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 570,
        "fullcodeline": "number_pixels=(MagickSizeType) image->columns*image->rows;"
    },
    {
        "line": 248,
        "fullcodeline": "image->colors=2;"
    },
    {
        "line": 256,
        "fullcodeline": "ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 322,
        "fullcodeline": "case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;"
    },
    {
        "line": 323,
        "fullcodeline": "case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;"
    },
    {
        "line": 324,
        "fullcodeline": "case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;"
    },
    {
        "line": 325,
        "fullcodeline": "case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;"
    },
    {
        "line": 326,
        "fullcodeline": "default: value=1.0*viff_colormap[i]; break;"
    },
    {
        "line": 458,
        "fullcodeline": "scale_factor=(double) QuantumRange/min_value;"
    },
    {
        "line": 459,
        "fullcodeline": "min_value=0;"
    },
    {
        "line": 506,
        "fullcodeline": "for (bit=0; bit < 8; bit++)"
    },
    {
        "line": 520,
        "fullcodeline": "for (bit=0; bit < (int) (image->columns % 8); bit++)"
    },
    {
        "line": 538,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 547,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 571,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 305,
        "fullcodeline": "MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*"
    },
    {
        "line": 312,
        "fullcodeline": "MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*"
    },
    {
        "line": 450,
        "fullcodeline": "if (value < min_value)"
    },
    {
        "line": 462,
        "fullcodeline": "scale_factor=(double) QuantumRange/(max_value-min_value);"
    },
    {
        "line": 484,
        "fullcodeline": "if (value < 0)"
    },
    {
        "line": 508,
        "fullcodeline": "quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);"
    },
    {
        "line": 509,
        "fullcodeline": "SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 510,
        "fullcodeline": "SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 511,
        "fullcodeline": "SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 514,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 522,
        "fullcodeline": "quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);"
    },
    {
        "line": 523,
        "fullcodeline": "SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 524,
        "fullcodeline": "SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 525,
        "fullcodeline": "SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);"
    },
    {
        "line": 528,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 548,
        "fullcodeline": "if (q == (Quantum *) NULL)"
    },
    {
        "line": 550,
        "fullcodeline": "for (x=0; x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 555,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 557,
        "fullcodeline": "if (image->previous == (Image *) NULL)"
    },
    {
        "line": 573,
        "fullcodeline": "q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 250,
        "fullcodeline": "if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)"
    },
    {
        "line": 331,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 333,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 335,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 338,
        "fullcodeline": "if (i < (ssize_t) (2*image->colors))"
    },
    {
        "line": 451,
        "fullcodeline": "min_value=value;"
    },
    {
        "line": 485,
        "fullcodeline": "value=0;"
    },
    {
        "line": 512,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 526,
        "fullcodeline": "if (image->storage_class == PseudoClass)"
    },
    {
        "line": 552,
        "fullcodeline": "SetPixelIndex(image,*p++,q);"
    },
    {
        "line": 553,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 559,
        "fullcodeline": "status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,"
    },
    {
        "line": 574,
        "fullcodeline": "if (q == (Quantum *) NULL)"
    },
    {
        "line": 576,
        "fullcodeline": "for (x=0; x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 601,
        "fullcodeline": "if (SyncAuthenticPixels(image,exception) == MagickFalse)"
    },
    {
        "line": 603,
        "fullcodeline": "if (image->previous == (Image *) NULL)"
    },
    {
        "line": 251,
        "fullcodeline": "image->colors=256UL;"
    },
    {
        "line": 513,
        "fullcodeline": "SetPixelIndex(image,(Quantum) quantum,q);"
    },
    {
        "line": 527,
        "fullcodeline": "SetPixelIndex(image,(Quantum) quantum,q);"
    },
    {
        "line": 561,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 578,
        "fullcodeline": "SetPixelRed(image,ScaleCharToQuantum(*p),q);"
    },
    {
        "line": 579,
        "fullcodeline": "SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);"
    },
    {
        "line": 580,
        "fullcodeline": "SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);"
    },
    {
        "line": 596,
        "fullcodeline": "SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?"
    },
    {
        "line": 598,
        "fullcodeline": "p++;"
    },
    {
        "line": 599,
        "fullcodeline": "q+=GetPixelChannels(image);"
    },
    {
        "line": 605,
        "fullcodeline": "status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,"
    },
    {
        "line": 253,
        "fullcodeline": "image->colors=image->depth <= 8 ? 256UL : 65536UL;"
    },
    {
        "line": 581,
        "fullcodeline": "if (image->colors != 0)"
    },
    {
        "line": 607,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 340,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 342,
        "fullcodeline": "if (i < (ssize_t) (3*image->colors))"
    },
    {
        "line": 586,
        "fullcodeline": "index=(ssize_t) GetPixelRed(image,q);"
    },
    {
        "line": 587,
        "fullcodeline": "SetPixelRed(image,ClampToQuantum(image->colormap["
    },
    {
        "line": 589,
        "fullcodeline": "index=(ssize_t) GetPixelGreen(image,q);"
    },
    {
        "line": 590,
        "fullcodeline": "SetPixelGreen(image,ClampToQuantum(image->colormap["
    },
    {
        "line": 592,
        "fullcodeline": "index=(ssize_t) GetPixelBlue(image,q);"
    },
    {
        "line": 593,
        "fullcodeline": "SetPixelBlue(image,ClampToQuantum(image->colormap["
    },
    {
        "line": 597,
        "fullcodeline": "ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);"
    },
    {
        "line": 339,
        "fullcodeline": "image->colormap[i % image->colors].green=(MagickRealType)"
    },
    {
        "line": 344,
        "fullcodeline": "ScaleCharToQuantum((unsigned char) value);"
    },
    {
        "line": 343,
        "fullcodeline": "image->colormap[i % image->colors].blue=(MagickRealType)"
    },
    {
        "line": 588,
        "fullcodeline": "ConstrainColormapIndex(image,index,exception)].red),q);"
    },
    {
        "line": 591,
        "fullcodeline": "ConstrainColormapIndex(image,index,exception)].green),q);"
    },
    {
        "line": 594,
        "fullcodeline": "ConstrainColormapIndex(image,index,exception)].blue),q);"
    }
]