[
    {
        "line": 7,
        "fullcodeline": "INT64 save = ftell(ifp);"
    },
    {
        "line": 8,
        "fullcodeline": "INT64 offset ="
    },
    {
        "line": 12,
        "fullcodeline": "INT64 decrypt_len = offset >> 2; /* master key offset value is the next"
    },
    {
        "line": 23,
        "fullcodeline": "srf_buf = (uchar *)malloc(len);"
    },
    {
        "line": 24,
        "fullcodeline": "fread(srf_buf, len, 1, ifp);"
    },
    {
        "line": 26,
        "fullcodeline": "offset += srf_buf[offset] << 2;"
    },
    {
        "line": 42,
        "fullcodeline": "CHECKBUFFER_SGET4(offset);"
    },
    {
        "line": 45,
        "fullcodeline": "MasterKey = ((unsigned)srf_buf[offset] << 24) |"
    },
    {
        "line": 51,
        "fullcodeline": "srf_offset = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "CHECKBUFFER_SGET2(srf_offset);"
    },
    {
        "line": 53,
        "fullcodeline": "entries = sget2(srf_buf + srf_offset);"
    },
    {
        "line": 56,
        "fullcodeline": "offset = srf_offset + 2;"
    },
    {
        "line": 57,
        "fullcodeline": "CHECKBUFFER_SGET4(offset);"
    },
    {
        "line": 59,
        "fullcodeline": "srf_offset = sget4(srf_buf + offset + 12 * entries) -"
    },
    {
        "line": 68,
        "fullcodeline": "CHECKBUFFER_SGET2(srf_offset);"
    },
    {
        "line": 69,
        "fullcodeline": "entries = sget2(srf_buf + srf_offset);"
    },
    {
        "line": 72,
        "fullcodeline": "offset = srf_offset + 2;"
    },
    {
        "line": 73,
        "fullcodeline": "tag_offset = offset;"
    },
    {
        "line": 86,
        "fullcodeline": "offset = tag_offset;"
    },
    {
        "line": 89,
        "fullcodeline": "CHECKBUFFER_SGET4(offset);"
    },
    {
        "line": 90,
        "fullcodeline": "srf_offset ="
    },
    {
        "line": 96,
        "fullcodeline": "CHECKBUFFER_SGET2(srf_offset);"
    },
    {
        "line": 97,
        "fullcodeline": "entries = sget2(srf_buf + srf_offset);"
    },
    {
        "line": 100,
        "fullcodeline": "offset = srf_offset + 2;"
    },
    {
        "line": 101,
        "fullcodeline": "tag_offset = offset;"
    },
    {
        "line": 147,
        "fullcodeline": "fseek(ifp, save, SEEK_SET);"
    },
    {
        "line": 4,
        "fullcodeline": "if ((len > 0xfffff) || (len == 0))"
    },
    {
        "line": 9,
        "fullcodeline": "0x0310c0 - save; /* for non-DNG this value normally is 0x8ddc */"
    },
    {
        "line": 54,
        "fullcodeline": "if (entries > 1000)"
    },
    {
        "line": 64,
        "fullcodeline": "if (srf_offset < 0 || decrypt_len < srf_offset / 4)"
    },
    {
        "line": 66,
        "fullcodeline": "sony_decrypt((unsigned *)(srf_buf + srf_offset), decrypt_len - srf_offset / 4,"
    },
    {
        "line": 70,
        "fullcodeline": "if (entries > 1000)"
    },
    {
        "line": 91,
        "fullcodeline": "sget4(srf_buf + offset) - save; /* SRFn ends with SRFn+1 position */"
    },
    {
        "line": 94,
        "fullcodeline": "sony_decrypt((unsigned *)(srf_buf + srf_offset), decrypt_len - srf_offset / 4,"
    },
    {
        "line": 98,
        "fullcodeline": "if (entries > 1000)"
    },
    {
        "line": 10,
        "fullcodeline": "if (len < offset || offset < 0)"
    },
    {
        "line": 92,
        "fullcodeline": "if (srf_offset < 0 || decrypt_len < srf_offset / 4)"
    },
    {
        "line": 47,
        "fullcodeline": "((unsigned)srf_buf[offset + 2] << 8) |"
    },
    {
        "line": 46,
        "fullcodeline": "((unsigned)srf_buf[offset + 1] << 16) |"
    },
    {
        "line": 76,
        "fullcodeline": "if (tiff_sget (save, srf_buf, len,"
    },
    {
        "line": 104,
        "fullcodeline": "if (tiff_sget (save, srf_buf, len,"
    },
    {
        "line": 79,
        "fullcodeline": "if (tag_id == 0x0000) {"
    },
    {
        "line": 58,
        "fullcodeline": "CHECKBUFFER_SGET4(offset + 12 * entries);"
    },
    {
        "line": 80,
        "fullcodeline": "SRF2Key = sget4(srf_buf + tag_dataoffset);"
    },
    {
        "line": 107,
        "fullcodeline": "if ((tag_id >= 0x00c0) && (tag_id <= 0x00ce)) {"
    },
    {
        "line": 108,
        "fullcodeline": "i = (tag_id - 0x00c0) % 3;"
    },
    {
        "line": 110,
        "fullcodeline": "icWBC[Sony_SRF_wb_list[nWB]][i] = sget4(srf_buf + tag_dataoffset);"
    },
    {
        "line": 109,
        "fullcodeline": "nWB = (tag_id - 0x00c0) / 3;"
    },
    {
        "line": 81,
        "fullcodeline": "} else if (tag_id == 0x0001) {"
    },
    {
        "line": 115,
        "fullcodeline": "} else if ((tag_id >= 0x00d0) && (tag_id <= 0x00d2)) {"
    },
    {
        "line": 116,
        "fullcodeline": "i = (tag_id - 0x00d0) % 3;"
    },
    {
        "line": 117,
        "fullcodeline": "cam_mul[i] = sget4(srf_buf + tag_dataoffset);"
    },
    {
        "line": 82,
        "fullcodeline": "RawDataKey = sget4(srf_buf + tag_dataoffset);"
    },
    {
        "line": 129,
        "fullcodeline": "ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);"
    },
    {
        "line": 132,
        "fullcodeline": "ilm.MaxAp4MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);"
    },
    {
        "line": 135,
        "fullcodeline": "ilm.MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);"
    },
    {
        "line": 138,
        "fullcodeline": "ilm.MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);"
    }
]