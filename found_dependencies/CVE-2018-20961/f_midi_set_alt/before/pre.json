[
    {
        "line": 3,
        "fullcodeline": "struct f_midi *midi = func_to_midi(f);"
    },
    {
        "line": 11,
        "fullcodeline": "err = f_midi_start_ep(midi, f, midi->in_ep);"
    },
    {
        "line": 15,
        "fullcodeline": "err = f_midi_start_ep(midi, f, midi->out_ep);"
    },
    {
        "line": 8,
        "fullcodeline": "if (intf != midi->ms_id)"
    },
    {
        "line": 20,
        "fullcodeline": "while (kfifo_avail(&midi->in_req_fifo)) {"
    },
    {
        "line": 34,
        "fullcodeline": "for (i = 0; i < midi->qlen && err == 0; i++) {"
    },
    {
        "line": 21,
        "fullcodeline": "struct usb_request *req ="
    },
    {
        "line": 27,
        "fullcodeline": "req->length = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "req->complete = f_midi_complete;"
    },
    {
        "line": 30,
        "fullcodeline": "kfifo_put(&midi->in_req_fifo, req);"
    },
    {
        "line": 35,
        "fullcodeline": "struct usb_request *req ="
    },
    {
        "line": 41,
        "fullcodeline": "req->complete = f_midi_complete;"
    },
    {
        "line": 42,
        "fullcodeline": "err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);"
    },
    {
        "line": 22,
        "fullcodeline": "midi_alloc_ep_req(midi->in_ep, midi->buflen);"
    },
    {
        "line": 24,
        "fullcodeline": "if (req == NULL)"
    },
    {
        "line": 36,
        "fullcodeline": "midi_alloc_ep_req(midi->out_ep, midi->buflen);"
    },
    {
        "line": 38,
        "fullcodeline": "if (req == NULL)"
    },
    {
        "line": 44,
        "fullcodeline": "ERROR(midi, \"%s: couldn't enqueue request: %d\\n\","
    },
    {
        "line": 25,
        "fullcodeline": "return -ENOMEM;"
    },
    {
        "line": 39,
        "fullcodeline": "return -ENOMEM;"
    }
]