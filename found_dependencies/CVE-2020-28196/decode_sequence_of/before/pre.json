[
    {
        "line": 6,
        "fullcodeline": "void *seq = NULL, *elem, *newseq;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t clen, count = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "*seq_out = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "*count_out = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "*seq_out = seq;"
    },
    {
        "line": 35,
        "fullcodeline": "*count_out = count;"
    },
    {
        "line": 39,
        "fullcodeline": "free_sequence_of(elemtype, seq, count);"
    },
    {
        "line": 13,
        "fullcodeline": "while (len > 0) {"
    },
    {
        "line": 14,
        "fullcodeline": "ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);"
    },
    {
        "line": 21,
        "fullcodeline": "newseq = realloc(seq, (count + 1) * elemtype->size);"
    },
    {
        "line": 26,
        "fullcodeline": "seq = newseq;"
    },
    {
        "line": 27,
        "fullcodeline": "elem = (char *)seq + count * elemtype->size;"
    },
    {
        "line": 28,
        "fullcodeline": "memset(elem, 0, elemtype->size);"
    },
    {
        "line": 29,
        "fullcodeline": "ret = decode_atype(&t, contents, clen, elemtype, elem);"
    },
    {
        "line": 32,
        "fullcodeline": "count++;"
    },
    {
        "line": 17,
        "fullcodeline": "if (!check_atype_tag(elemtype, &t)) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (newseq == NULL) {"
    },
    {
        "line": 18,
        "fullcodeline": "ret = ASN1_BAD_ID;"
    },
    {
        "line": 23,
        "fullcodeline": "ret = ENOMEM;"
    }
]