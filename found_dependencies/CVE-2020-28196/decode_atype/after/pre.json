[
    {
        "line": 8,
        "fullcodeline": "const struct fn_info *fn = a->tinfo;"
    },
    {
        "line": 9,
        "fullcodeline": "assert(fn->dec != NULL);"
    },
    {
        "line": 13,
        "fullcodeline": "return decode_sequence(asn1, len, a->tinfo, val);"
    },
    {
        "line": 15,
        "fullcodeline": "const struct ptr_info *ptrinfo = a->tinfo;"
    },
    {
        "line": 16,
        "fullcodeline": "void *ptr = LOADPTR(val, ptrinfo);"
    },
    {
        "line": 30,
        "fullcodeline": "const struct offset_info *off = a->tinfo;"
    },
    {
        "line": 36,
        "fullcodeline": "const struct optional_info *opt = a->tinfo;"
    },
    {
        "line": 40,
        "fullcodeline": "const struct counted_info *counted = a->tinfo;"
    },
    {
        "line": 41,
        "fullcodeline": "void *dataptr = (char *)val + counted->dataoff;"
    },
    {
        "line": 44,
        "fullcodeline": "ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);"
    },
    {
        "line": 50,
        "fullcodeline": "const struct tagged_info *tag = a->tinfo;"
    },
    {
        "line": 52,
        "fullcodeline": "const taginfo *tp = t;"
    },
    {
        "line": 68,
        "fullcodeline": "ret = k5_asn1_decode_bool(asn1, len, &intval);"
    },
    {
        "line": 75,
        "fullcodeline": "ret = k5_asn1_decode_int(asn1, len, &intval);"
    },
    {
        "line": 82,
        "fullcodeline": "ret = k5_asn1_decode_uint(asn1, len, &intval);"
    },
    {
        "line": 88,
        "fullcodeline": "const struct immediate_info *imm = a->tinfo;"
    },
    {
        "line": 90,
        "fullcodeline": "ret = k5_asn1_decode_int(asn1, len, &intval);"
    },
    {
        "line": 100,
        "fullcodeline": "assert(a->type != atype_nullterm_sequence_of);"
    },
    {
        "line": 101,
        "fullcodeline": "assert(a->type != atype_nonempty_nullterm_sequence_of);"
    },
    {
        "line": 102,
        "fullcodeline": "assert(a->type > atype_min);"
    },
    {
        "line": 103,
        "fullcodeline": "assert(a->type < atype_max);"
    },
    {
        "line": 10,
        "fullcodeline": "return fn->dec(t, asn1, len, val);"
    },
    {
        "line": 17,
        "fullcodeline": "assert(ptrinfo->basetype != NULL);"
    },
    {
        "line": 18,
        "fullcodeline": "if (ptr != NULL) {"
    },
    {
        "line": 31,
        "fullcodeline": "assert(off->basetype != NULL);"
    },
    {
        "line": 32,
        "fullcodeline": "return decode_atype(t, asn1, len, off->basetype,"
    },
    {
        "line": 37,
        "fullcodeline": "return decode_atype(t, asn1, len, opt->basetype, val);"
    },
    {
        "line": 43,
        "fullcodeline": "assert(counted->basetype != NULL);"
    },
    {
        "line": 47,
        "fullcodeline": "return store_count(count, counted, val);"
    },
    {
        "line": 64,
        "fullcodeline": "return decode_atype(tp, asn1, len, tag->basetype, val);"
    },
    {
        "line": 71,
        "fullcodeline": "return store_int(intval, a->size, val);"
    },
    {
        "line": 78,
        "fullcodeline": "return store_int(intval, a->size, val);"
    },
    {
        "line": 85,
        "fullcodeline": "return store_uint(intval, a->size, val);"
    },
    {
        "line": 56,
        "fullcodeline": "ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);"
    },
    {
        "line": 60,
        "fullcodeline": "tp = &inner_tag;"
    },
    {
        "line": 93,
        "fullcodeline": "if (intval != imm->val && imm->err != 0)"
    },
    {
        "line": 20,
        "fullcodeline": "return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);"
    },
    {
        "line": 22,
        "fullcodeline": "ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);"
    },
    {
        "line": 61,
        "fullcodeline": "if (!check_atype_tag(tag->basetype, tp))"
    }
]