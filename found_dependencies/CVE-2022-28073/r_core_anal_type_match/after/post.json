[
    {
        "line": 4,
        "fullcodeline": "RAnalOp aop = {0};"
    },
    {
        "line": 5,
        "fullcodeline": "bool resolved = false;"
    },
    {
        "line": 7,
        "fullcodeline": "r_return_if_fail (core && core->anal && fcn);"
    },
    {
        "line": 14,
        "fullcodeline": "RAnal *anal = core->anal;"
    },
    {
        "line": 15,
        "fullcodeline": "Sdb *TDB = anal->sdb_types;"
    },
    {
        "line": 16,
        "fullcodeline": "bool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");"
    },
    {
        "line": 17,
        "fullcodeline": "int ret, bsize = R_MAX (64, core->blocksize);"
    },
    {
        "line": 18,
        "fullcodeline": "const int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);"
    },
    {
        "line": 19,
        "fullcodeline": "const int minopcode = R_MAX (1, mininstrsz);"
    },
    {
        "line": 20,
        "fullcodeline": "int cur_idx , prev_idx = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "RConfigHold *hc = r_config_hold_new (core->config);"
    },
    {
        "line": 25,
        "fullcodeline": "RDebugTrace *dt = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "RAnalEsilTrace *et = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "ut8 *buf = malloc (bsize);"
    },
    {
        "line": 40,
        "fullcodeline": "ht_pp_free (etracedb->ht);"
    },
    {
        "line": 41,
        "fullcodeline": "etracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);"
    },
    {
        "line": 42,
        "fullcodeline": "etracedb->ht->opt = opt;"
    },
    {
        "line": 45,
        "fullcodeline": "ht_pp_free (dtrace->ht);"
    },
    {
        "line": 46,
        "fullcodeline": "dtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);"
    },
    {
        "line": 47,
        "fullcodeline": "dtrace->ht->opt = opt;"
    },
    {
        "line": 49,
        "fullcodeline": "char *fcn_name = NULL;"
    },
    {
        "line": 50,
        "fullcodeline": "char *ret_type = NULL;"
    },
    {
        "line": 51,
        "fullcodeline": "bool str_flag = false;"
    },
    {
        "line": 52,
        "fullcodeline": "bool prop = false;"
    },
    {
        "line": 53,
        "fullcodeline": "bool prev_var = false;"
    },
    {
        "line": 54,
        "fullcodeline": "char prev_type[256] = {0};"
    },
    {
        "line": 55,
        "fullcodeline": "const char *prev_dest = NULL;"
    },
    {
        "line": 56,
        "fullcodeline": "char *ret_reg = NULL;"
    },
    {
        "line": 57,
        "fullcodeline": "const char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);"
    },
    {
        "line": 62,
        "fullcodeline": "char *pc = strdup (_pc);"
    },
    {
        "line": 63,
        "fullcodeline": "r_cons_break_push (NULL, NULL);"
    },
    {
        "line": 64,
        "fullcodeline": "r_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address"
    },
    {
        "line": 65,
        "fullcodeline": "r_list_foreach (fcn->bbs, it, bb) {"
    },
    {
        "line": 314,
        "fullcodeline": "RList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);"
    },
    {
        "line": 317,
        "fullcodeline": "r_list_foreach (list, iter, rvar) {"
    },
    {
        "line": 330,
        "fullcodeline": "r_list_free (list);"
    },
    {
        "line": 332,
        "fullcodeline": "R_FREE (ret_reg);"
    },
    {
        "line": 333,
        "fullcodeline": "R_FREE (ret_type);"
    },
    {
        "line": 334,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 335,
        "fullcodeline": "r_cons_break_pop();"
    },
    {
        "line": 336,
        "fullcodeline": "anal_emul_restore (core, hc, dt, et);"
    },
    {
        "line": 337,
        "fullcodeline": "free (pc);"
    },
    {
        "line": 22,
        "fullcodeline": "if (!hc) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (!anal_emul_init (core, hc, &dt, &et) || !fcn) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (!buf) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (!_pc) {"
    },
    {
        "line": 66,
        "fullcodeline": "ut64 addr = bb->addr;"
    },
    {
        "line": 67,
        "fullcodeline": "int i = 0;"
    },
    {
        "line": 68,
        "fullcodeline": "RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);"
    },
    {
        "line": 73,
        "fullcodeline": "r_reg_set_value (core->dbg->reg, r, addr);"
    },
    {
        "line": 318,
        "fullcodeline": "RAnalVar *lvar = r_anal_var_get_dst_var (rvar);"
    },
    {
        "line": 319,
        "fullcodeline": "RRegItem *i = r_reg_index_get (anal->reg, rvar->delta);"
    },
    {
        "line": 10,
        "fullcodeline": "eprintf (\"Please run aeim\\n\");"
    },
    {
        "line": 28,
        "fullcodeline": "anal_emul_restore (core, hc, dt, et);"
    },
    {
        "line": 33,
        "fullcodeline": "anal_emul_restore (core, hc, dt, et);"
    },
    {
        "line": 59,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 69,
        "fullcodeline": "if (!r) {"
    },
    {
        "line": 320,
        "fullcodeline": "if (!i) {"
    },
    {
        "line": 70,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 81,
        "fullcodeline": "ut64 pcval = r_reg_getv (anal->reg, pc);"
    },
    {
        "line": 88,
        "fullcodeline": "ret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);"
    },
    {
        "line": 111,
        "fullcodeline": "bool userfnc = false;"
    },
    {
        "line": 113,
        "fullcodeline": "cur_idx = sdb_num_get (trace, \"idx\", 0);"
    },
    {
        "line": 114,
        "fullcodeline": "RAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);"
    },
    {
        "line": 115,
        "fullcodeline": "RAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); // | _VAL ?"
    },
    {
        "line": 116,
        "fullcodeline": "ut32 type = aop.type & R_ANAL_OP_TYPE_MASK;"
    },
    {
        "line": 272,
        "fullcodeline": "prev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);"
    },
    {
        "line": 273,
        "fullcodeline": "str_flag = false;"
    },
    {
        "line": 274,
        "fullcodeline": "prop = false;"
    },
    {
        "line": 275,
        "fullcodeline": "prev_dest = NULL;"
    },
    {
        "line": 306,
        "fullcodeline": "i += ret;"
    },
    {
        "line": 307,
        "fullcodeline": "addr += ret;"
    },
    {
        "line": 308,
        "fullcodeline": "r_anal_op_free (next_op);"
    },
    {
        "line": 309,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 325,
        "fullcodeline": "__var_retype (anal, rvar, NULL, lvar->type, false, false);"
    },
    {
        "line": 327,
        "fullcodeline": "__var_retype (anal, lvar, NULL, rvar->type, false, false);"
    },
    {
        "line": 75,
        "fullcodeline": "if (r_cons_is_breaked ()) {"
    },
    {
        "line": 78,
        "fullcodeline": "if (i >= (bsize - 32)) {"
    },
    {
        "line": 82,
        "fullcodeline": "if ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (!i) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (ret <= 0) {"
    },
    {
        "line": 96,
        "fullcodeline": "if (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (r_anal_op_nonlinear (aop.type)) {   // skip the instr"
    },
    {
        "line": 117,
        "fullcodeline": "if (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {"
    },
    {
        "line": 79,
        "fullcodeline": "i = 0;"
    },
    {
        "line": 86,
        "fullcodeline": "r_io_read_at (core->io, addr, buf, bsize);"
    },
    {
        "line": 90,
        "fullcodeline": "i += minopcode;"
    },
    {
        "line": 91,
        "fullcodeline": "addr += minopcode;"
    },
    {
        "line": 92,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 97,
        "fullcodeline": "r_anal_op_fini (&aop);"
    },
    {
        "line": 102,
        "fullcodeline": "RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);"
    },
    {
        "line": 107,
        "fullcodeline": "r_reg_set_value (core->dbg->reg, r, addr + ret);"
    },
    {
        "line": 118,
        "fullcodeline": "char *full_name = NULL;"
    },
    {
        "line": 217,
        "fullcodeline": "bool sign = false;"
    },
    {
        "line": 299,
        "fullcodeline": "const char *query = sdb_fmt (\"%d.reg.write\", cur_idx);"
    },
    {
        "line": 300,
        "fullcodeline": "prev_dest = sdb_const_get (trace, query, 0);"
    },
    {
        "line": 103,
        "fullcodeline": "if (!r) {"
    },
    {
        "line": 109,
        "fullcodeline": "r_core_esil_step (core, UT64_MAX, NULL, NULL, false);"
    },
    {
        "line": 120,
        "fullcodeline": "if (aop.type == R_ANAL_OP_TYPE_CALL) {"
    },
    {
        "line": 218,
        "fullcodeline": "if ((type == R_ANAL_OP_TYPE_CMP) && next_op) {"
    },
    {
        "line": 227,
        "fullcodeline": "if (sign || aop.sign) {"
    },
    {
        "line": 232,
        "fullcodeline": "if (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {"
    },
    {
        "line": 243,
        "fullcodeline": "if (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)"
    },
    {
        "line": 280,
        "fullcodeline": "if (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {"
    },
    {
        "line": 296,
        "fullcodeline": "if (var && str_flag) {"
    },
    {
        "line": 104,
        "fullcodeline": "free (buf);"
    },
    {
        "line": 121,
        "fullcodeline": "RAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);"
    },
    {
        "line": 143,
        "fullcodeline": "const char* Cc = r_anal_cc_func (anal, fcn_name);"
    },
    {
        "line": 174,
        "fullcodeline": "free (fcn_name);"
    },
    {
        "line": 176,
        "fullcodeline": "} else if (!resolved && ret_type && ret_reg) {"
    },
    {
        "line": 228,
        "fullcodeline": "__var_retype (anal, var, NULL, \"signed\", false, true);"
    },
    {
        "line": 233,
        "fullcodeline": "char reg[REGNAME_SIZE] = {0};"
    },
    {
        "line": 234,
        "fullcodeline": "get_src_regname (core, addr, reg, sizeof (reg));"
    },
    {
        "line": 235,
        "fullcodeline": "bool match = strstr (prev_dest, reg) != NULL;"
    },
    {
        "line": 244,
        "fullcodeline": "&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {"
    },
    {
        "line": 245,
        "fullcodeline": "bool jmp = false;"
    },
    {
        "line": 246,
        "fullcodeline": "RAnalOp *jmp_op = {0};"
    },
    {
        "line": 247,
        "fullcodeline": "ut64 jmp_addr = next_op->jump;"
    },
    {
        "line": 248,
        "fullcodeline": "RAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);"
    },
    {
        "line": 265,
        "fullcodeline": "RAnalVarConstraint constr = {"
    },
    {
        "line": 269,
        "fullcodeline": "r_anal_var_add_constraint (var, &constr);"
    },
    {
        "line": 297,
        "fullcodeline": "__var_retype (anal, var, NULL, \"const char *\", false, false);"
    },
    {
        "line": 302,
        "fullcodeline": "strncpy (prev_type, var->type, sizeof (prev_type) - 1);"
    },
    {
        "line": 303,
        "fullcodeline": "prop = true;"
    },
    {
        "line": 134,
        "fullcodeline": "if (r_type_func_exist (TDB, full_name)) {"
    },
    {
        "line": 139,
        "fullcodeline": "if (!fcn_name) {"
    },
    {
        "line": 144,
        "fullcodeline": "if (Cc && r_anal_cc_exist (anal, Cc)) {"
    },
    {
        "line": 161,
        "fullcodeline": "if (!strcmp (fcn_name, \"__stack_chk_fail\")) {"
    },
    {
        "line": 178,
        "fullcodeline": "char src[REGNAME_SIZE] = {0};"
    },
    {
        "line": 179,
        "fullcodeline": "const char *query = sdb_fmt (\"%d.reg.write\", cur_idx);"
    },
    {
        "line": 180,
        "fullcodeline": "const char *cur_dest = sdb_const_get (trace, query, 0);"
    },
    {
        "line": 181,
        "fullcodeline": "get_src_regname (core, aop.addr, src, sizeof (src));"
    },
    {
        "line": 236,
        "fullcodeline": "if (str_flag && match) {"
    },
    {
        "line": 239,
        "fullcodeline": "if (prop && match && prev_var) {"
    },
    {
        "line": 251,
        "fullcodeline": "for (i = 0; i < MAX_INSTR ; i++) {"
    },
    {
        "line": 281,
        "fullcodeline": "if (type == R_ANAL_OP_TYPE_LOAD) {"
    },
    {
        "line": 123,
        "fullcodeline": "full_name = fcn_call->name;"
    },
    {
        "line": 124,
        "fullcodeline": "callee_addr = fcn_call->addr;"
    },
    {
        "line": 126,
        "fullcodeline": "} else if (aop.ptr != UT64_MAX) {"
    },
    {
        "line": 135,
        "fullcodeline": "fcn_name = strdup (full_name);"
    },
    {
        "line": 140,
        "fullcodeline": "fcn_name = strdup (full_name);"
    },
    {
        "line": 141,
        "fullcodeline": "userfnc = true;"
    },
    {
        "line": 145,
        "fullcodeline": "char *cc = strdup (Cc);"
    },
    {
        "line": 146,
        "fullcodeline": "type_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);"
    },
    {
        "line": 147,
        "fullcodeline": "prev_idx = cur_idx;"
    },
    {
        "line": 148,
        "fullcodeline": "R_FREE (ret_type);"
    },
    {
        "line": 149,
        "fullcodeline": "const char *rt = r_type_func_ret (TDB, fcn_name);"
    },
    {
        "line": 153,
        "fullcodeline": "R_FREE (ret_reg);"
    },
    {
        "line": 154,
        "fullcodeline": "const char *rr = r_anal_cc_ret (anal, cc);"
    },
    {
        "line": 158,
        "fullcodeline": "resolved = false;"
    },
    {
        "line": 159,
        "fullcodeline": "free (cc);"
    },
    {
        "line": 162,
        "fullcodeline": "const char *query = sdb_fmt (\"%d.addr\", cur_idx - 1);"
    },
    {
        "line": 163,
        "fullcodeline": "ut64 mov_addr = sdb_num_get (trace, query, 0);"
    },
    {
        "line": 164,
        "fullcodeline": "RAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);"
    },
    {
        "line": 172,
        "fullcodeline": "r_anal_op_free (mop);"
    },
    {
        "line": 182,
        "fullcodeline": "if (ret_reg && *src && strstr (ret_reg, src)) {"
    },
    {
        "line": 220,
        "fullcodeline": "sign = true;"
    },
    {
        "line": 237,
        "fullcodeline": "__var_retype (anal, var, NULL, \"const char *\", false, false);"
    },
    {
        "line": 240,
        "fullcodeline": "__var_retype (anal, var, NULL, prev_type, false, false);"
    },
    {
        "line": 252,
        "fullcodeline": "jmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);"
    },
    {
        "line": 262,
        "fullcodeline": "jmp_addr += jmp_op->size;"
    },
    {
        "line": 263,
        "fullcodeline": "r_anal_op_free (jmp_op);"
    },
    {
        "line": 282,
        "fullcodeline": "ut8 buf[256] = {0};"
    },
    {
        "line": 283,
        "fullcodeline": "r_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);"
    },
    {
        "line": 284,
        "fullcodeline": "ut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);"
    },
    {
        "line": 127,
        "fullcodeline": "RFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);"
    },
    {
        "line": 137,
        "fullcodeline": "fcn_name = r_type_func_guess (TDB, full_name);"
    },
    {
        "line": 223,
        "fullcodeline": "__var_retype (anal, var, NULL, \"unsigned\", false, true);"
    },
    {
        "line": 253,
        "fullcodeline": "if (!jmp_op) {"
    },
    {
        "line": 256,
        "fullcodeline": "if ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))"
    },
    {
        "line": 266,
        "fullcodeline": ".cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,"
    },
    {
        "line": 267,
        "fullcodeline": ".val = aop.val"
    },
    {
        "line": 285,
        "fullcodeline": "if (ptr && ptr != UT64_MAX) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (flag && flag->realname) {"
    },
    {
        "line": 151,
        "fullcodeline": "ret_type = strdup (rt);"
    },
    {
        "line": 156,
        "fullcodeline": "ret_reg = strdup (rr);"
    },
    {
        "line": 166,
        "fullcodeline": "RAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);"
    },
    {
        "line": 167,
        "fullcodeline": "ut32 type = mop->type & R_ANAL_OP_TYPE_MASK;"
    },
    {
        "line": 183,
        "fullcodeline": "if (var && aop.direction == R_ANAL_OP_DIR_WRITE) {"
    },
    {
        "line": 257,
        "fullcodeline": "|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {"
    },
    {
        "line": 258,
        "fullcodeline": "jmp = true;"
    },
    {
        "line": 259,
        "fullcodeline": "r_anal_op_free (jmp_op);"
    },
    {
        "line": 286,
        "fullcodeline": "RFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);"
    },
    {
        "line": 291,
        "fullcodeline": "} else if (r_flag_exist_at (core->flags, \"str\", 3, aop.ptr)) {"
    },
    {
        "line": 129,
        "fullcodeline": "full_name = flag->realname;"
    },
    {
        "line": 130,
        "fullcodeline": "callee_addr = aop.ptr;"
    },
    {
        "line": 168,
        "fullcodeline": "if (type == R_ANAL_OP_TYPE_MOV) {"
    },
    {
        "line": 184,
        "fullcodeline": "__var_retype (anal, var, NULL, ret_type, false, false);"
    },
    {
        "line": 185,
        "fullcodeline": "resolved = true;"
    },
    {
        "line": 292,
        "fullcodeline": "str_flag = true;"
    },
    {
        "line": 169,
        "fullcodeline": "__var_rename (anal, mopvar, \"canary\", addr);"
    },
    {
        "line": 193,
        "fullcodeline": "char *foo = strdup (cur_dest);"
    },
    {
        "line": 194,
        "fullcodeline": "char *tmp = strchr (foo, ',');"
    },
    {
        "line": 212,
        "fullcodeline": "free (foo);"
    },
    {
        "line": 288,
        "fullcodeline": "str_flag = true;"
    },
    {
        "line": 186,
        "fullcodeline": "} else if (type == R_ANAL_OP_TYPE_MOV) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {"
    },
    {
        "line": 187,
        "fullcodeline": "R_FREE (ret_reg);"
    },
    {
        "line": 196,
        "fullcodeline": "*tmp++ = '\\0';"
    },
    {
        "line": 199,
        "fullcodeline": "resolved = true;"
    },
    {
        "line": 189,
        "fullcodeline": "ret_reg = strdup (cur_dest);"
    },
    {
        "line": 200,
        "fullcodeline": "} else if (type == R_ANAL_OP_TYPE_MOV &&"
    },
    {
        "line": 201,
        "fullcodeline": "(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){"
    },
    {
        "line": 205,
        "fullcodeline": "char nsrc[REGNAME_SIZE] = {0};"
    },
    {
        "line": 206,
        "fullcodeline": "get_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));"
    },
    {
        "line": 207,
        "fullcodeline": "if (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&"
    },
    {
        "line": 208,
        "fullcodeline": "aop.direction == R_ANAL_OP_DIR_READ) {"
    },
    {
        "line": 209,
        "fullcodeline": "__var_retype (anal, var, NULL, ret_type, true, false);"
    }
]