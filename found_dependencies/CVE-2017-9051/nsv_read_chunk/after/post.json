[
    {
        "line": 3,
        "fullcodeline": "NSVContext *nsv = s->priv_data;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *pb = s->pb;"
    },
    {
        "line": 5,
        "fullcodeline": "AVStream *st[2] = {NULL, NULL};"
    },
    {
        "line": 8,
        "fullcodeline": "int i, err = 0;"
    },
    {
        "line": 33,
        "fullcodeline": "auxcount = avio_r8(pb);"
    },
    {
        "line": 34,
        "fullcodeline": "vsize = avio_rl16(pb);"
    },
    {
        "line": 35,
        "fullcodeline": "asize = avio_rl16(pb);"
    },
    {
        "line": 36,
        "fullcodeline": "vsize = (vsize << 4) | (auxcount >> 4);"
    },
    {
        "line": 37,
        "fullcodeline": "auxcount &= 0x0f;"
    },
    {
        "line": 125,
        "fullcodeline": "nsv->state = NSV_UNSYNC;"
    },
    {
        "line": 22,
        "fullcodeline": "for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)"
    },
    {
        "line": 23,
        "fullcodeline": "err = nsv_resync(s);"
    },
    {
        "line": 24,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 26,
        "fullcodeline": "if (nsv->state == NSV_FOUND_NSVS)"
    },
    {
        "line": 28,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 30,
        "fullcodeline": "if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)"
    },
    {
        "line": 41,
        "fullcodeline": "for (i = 0; i < auxcount; i++) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (!vsize && !asize) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (s->nb_streams > 0)"
    },
    {
        "line": 59,
        "fullcodeline": "if (s->nb_streams > 1)"
    },
    {
        "line": 62,
        "fullcodeline": "if (vsize && st[NSV_ST_VIDEO]) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (asize && st[NSV_ST_AUDIO]) {"
    },
    {
        "line": 27,
        "fullcodeline": "err = nsv_parse_NSVs_header(s);"
    },
    {
        "line": 43,
        "fullcodeline": "auxsize = avio_rl16(pb);"
    },
    {
        "line": 44,
        "fullcodeline": "auxtag = avio_rl32(pb);"
    },
    {
        "line": 45,
        "fullcodeline": "avio_skip(pb, auxsize);"
    },
    {
        "line": 46,
        "fullcodeline": "vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */"
    },
    {
        "line": 52,
        "fullcodeline": "nsv->state = NSV_UNSYNC;"
    },
    {
        "line": 68,
        "fullcodeline": "pkt->dts = nst->frame_offset;"
    },
    {
        "line": 69,
        "fullcodeline": "pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */"
    },
    {
        "line": 113,
        "fullcodeline": "pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */"
    },
    {
        "line": 122,
        "fullcodeline": "nst->frame_offset++;"
    },
    {
        "line": 20,
        "fullcodeline": "return -1;"
    },
    {
        "line": 31,
        "fullcodeline": "return -1;"
    },
    {
        "line": 50,
        "fullcodeline": "return -1;"
    },
    {
        "line": 65,
        "fullcodeline": "if ((ret = av_get_packet(pb, pkt, vsize)) < 0)"
    },
    {
        "line": 82,
        "fullcodeline": "if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {"
    },
    {
        "line": 110,
        "fullcodeline": "if ((ret = av_get_packet(pb, pkt, asize)) < 0)"
    },
    {
        "line": 114,
        "fullcodeline": "if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {"
    },
    {
        "line": 86,
        "fullcodeline": "bps = avio_r8(pb);"
    },
    {
        "line": 87,
        "fullcodeline": "channels = avio_r8(pb);"
    },
    {
        "line": 88,
        "fullcodeline": "samplerate = avio_rl16(pb);"
    },
    {
        "line": 91,
        "fullcodeline": "asize-=4;"
    },
    {
        "line": 116,
        "fullcodeline": "pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);"
    },
    {
        "line": 117,
        "fullcodeline": "pkt->dts *= (int64_t)1000        * nsv->framerate.den;"
    },
    {
        "line": 118,
        "fullcodeline": "pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;"
    },
    {
        "line": 89,
        "fullcodeline": "if (!channels || !samplerate)"
    },
    {
        "line": 95,
        "fullcodeline": "st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */"
    },
    {
        "line": 99,
        "fullcodeline": "bps /= channels; // ???"
    },
    {
        "line": 102,
        "fullcodeline": "samplerate /= 4;/* UGH ??? XXX */"
    },
    {
        "line": 103,
        "fullcodeline": "channels = 1;"
    },
    {
        "line": 104,
        "fullcodeline": "st[NSV_ST_AUDIO]->codecpar->channels = channels;"
    },
    {
        "line": 105,
        "fullcodeline": "st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;"
    },
    {
        "line": 96,
        "fullcodeline": "if (bps != 16) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (bps == 8)"
    },
    {
        "line": 101,
        "fullcodeline": "st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;"
    }
]