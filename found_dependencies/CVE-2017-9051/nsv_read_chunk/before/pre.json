[
    {
        "line": 3,
        "fullcodeline": "NSVContext *nsv = s->priv_data;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *pb = s->pb;"
    },
    {
        "line": 5,
        "fullcodeline": "AVStream *st[2] = {NULL, NULL};"
    },
    {
        "line": 8,
        "fullcodeline": "int i, err = 0;"
    },
    {
        "line": 32,
        "fullcodeline": "auxcount = avio_r8(pb);"
    },
    {
        "line": 33,
        "fullcodeline": "vsize = avio_rl16(pb);"
    },
    {
        "line": 34,
        "fullcodeline": "asize = avio_rl16(pb);"
    },
    {
        "line": 35,
        "fullcodeline": "vsize = (vsize << 4) | (auxcount >> 4);"
    },
    {
        "line": 36,
        "fullcodeline": "auxcount &= 0x0f;"
    },
    {
        "line": 14,
        "fullcodeline": "if (nsv->ahead[0].data || nsv->ahead[1].data)"
    },
    {
        "line": 21,
        "fullcodeline": "for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)"
    },
    {
        "line": 22,
        "fullcodeline": "err = nsv_resync(s);"
    },
    {
        "line": 23,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 25,
        "fullcodeline": "if (nsv->state == NSV_FOUND_NSVS)"
    },
    {
        "line": 27,
        "fullcodeline": "if (err < 0)"
    },
    {
        "line": 40,
        "fullcodeline": "for (i = 0; i < auxcount; i++) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (s->nb_streams > 0)"
    },
    {
        "line": 61,
        "fullcodeline": "if (vsize && st[NSV_ST_VIDEO]) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (asize && st[NSV_ST_AUDIO]) {"
    },
    {
        "line": 26,
        "fullcodeline": "err = nsv_parse_NSVs_header(s);"
    },
    {
        "line": 29,
        "fullcodeline": "if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)"
    },
    {
        "line": 42,
        "fullcodeline": "auxsize = avio_rl16(pb);"
    },
    {
        "line": 43,
        "fullcodeline": "auxtag = avio_rl32(pb);"
    },
    {
        "line": 44,
        "fullcodeline": "avio_skip(pb, auxsize);"
    },
    {
        "line": 45,
        "fullcodeline": "vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */"
    },
    {
        "line": 50,
        "fullcodeline": "if (!vsize && !asize) {"
    },
    {
        "line": 51,
        "fullcodeline": "nsv->state = NSV_UNSYNC;"
    },
    {
        "line": 62,
        "fullcodeline": "nst = st[NSV_ST_VIDEO]->priv_data;"
    },
    {
        "line": 63,
        "fullcodeline": "pkt = &nsv->ahead[NSV_ST_VIDEO];"
    },
    {
        "line": 64,
        "fullcodeline": "av_get_packet(pb, pkt, vsize);"
    },
    {
        "line": 65,
        "fullcodeline": "pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;"
    },
    {
        "line": 66,
        "fullcodeline": "pkt->dts = nst->frame_offset;"
    },
    {
        "line": 67,
        "fullcodeline": "pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */"
    },
    {
        "line": 73,
        "fullcodeline": "((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;"
    },
    {
        "line": 76,
        "fullcodeline": "nst = st[NSV_ST_AUDIO]->priv_data;"
    },
    {
        "line": 77,
        "fullcodeline": "pkt = &nsv->ahead[NSV_ST_AUDIO];"
    },
    {
        "line": 108,
        "fullcodeline": "av_get_packet(pb, pkt, asize);"
    },
    {
        "line": 19,
        "fullcodeline": "return -1;"
    },
    {
        "line": 30,
        "fullcodeline": "return -1;"
    },
    {
        "line": 49,
        "fullcodeline": "return -1;"
    },
    {
        "line": 80,
        "fullcodeline": "if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {"
    },
    {
        "line": 84,
        "fullcodeline": "bps = avio_r8(pb);"
    },
    {
        "line": 85,
        "fullcodeline": "channels = avio_r8(pb);"
    },
    {
        "line": 86,
        "fullcodeline": "samplerate = avio_rl16(pb);"
    },
    {
        "line": 89,
        "fullcodeline": "asize-=4;"
    },
    {
        "line": 110,
        "fullcodeline": "pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */"
    },
    {
        "line": 111,
        "fullcodeline": "if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {"
    },
    {
        "line": 113,
        "fullcodeline": "pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);"
    },
    {
        "line": 114,
        "fullcodeline": "pkt->dts *= (int64_t)1000        * nsv->framerate.den;"
    },
    {
        "line": 115,
        "fullcodeline": "pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;"
    },
    {
        "line": 87,
        "fullcodeline": "if (!channels || !samplerate)"
    },
    {
        "line": 93,
        "fullcodeline": "st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */"
    },
    {
        "line": 97,
        "fullcodeline": "bps /= channels; // ???"
    },
    {
        "line": 100,
        "fullcodeline": "samplerate /= 4;/* UGH ??? XXX */"
    },
    {
        "line": 101,
        "fullcodeline": "channels = 1;"
    },
    {
        "line": 94,
        "fullcodeline": "if (bps != 16) {"
    },
    {
        "line": 99,
        "fullcodeline": "st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;"
    }
]