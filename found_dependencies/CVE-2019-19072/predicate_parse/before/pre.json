[
    {
        "line": 7,
        "fullcodeline": "const char *ptr = str;"
    },
    {
        "line": 8,
        "fullcodeline": "char *inverts = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "int invert = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "int ret = -ENOMEM;"
    },
    {
        "line": 14,
        "fullcodeline": "int N = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "nr_preds += 2; /* For TRUE and FALSE */"
    },
    {
        "line": 19,
        "fullcodeline": "op_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);"
    },
    {
        "line": 22,
        "fullcodeline": "prog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);"
    },
    {
        "line": 27,
        "fullcodeline": "inverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);"
    },
    {
        "line": 33,
        "fullcodeline": "top = op_stack;"
    },
    {
        "line": 34,
        "fullcodeline": "prog = prog_stack;"
    },
    {
        "line": 35,
        "fullcodeline": "*top = 0;"
    },
    {
        "line": 147,
        "fullcodeline": "prog[N-1].when_to_branch = false;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!op_stack)"
    },
    {
        "line": 23,
        "fullcodeline": "if (!prog_stack) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (!inverts) {"
    },
    {
        "line": 129,
        "fullcodeline": "if (top != op_stack) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (!N) {"
    },
    {
        "line": 157,
        "fullcodeline": "for (i = 0; i < N; i++) {"
    },
    {
        "line": 178,
        "fullcodeline": "return ERR_PTR(ret);"
    },
    {
        "line": 39,
        "fullcodeline": "const char *next = ptr++;"
    },
    {
        "line": 62,
        "fullcodeline": "inverts[N] = invert;\t\t\t\t/* #4 */"
    },
    {
        "line": 65,
        "fullcodeline": "len = parse_pred(next, data, ptr - str, pe, &prog[N].pred);"
    },
    {
        "line": 70,
        "fullcodeline": "ptr = next + len;"
    },
    {
        "line": 72,
        "fullcodeline": "N++;"
    },
    {
        "line": 74,
        "fullcodeline": "ret = -1;"
    },
    {
        "line": 131,
        "fullcodeline": "parse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);"
    },
    {
        "line": 137,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 138,
        "fullcodeline": "parse_error(pe, FILT_ERR_NO_FILTER, ptr - str);"
    },
    {
        "line": 150,
        "fullcodeline": "for (i = N-1 ; i--; ) {"
    },
    {
        "line": 158,
        "fullcodeline": "invert = inverts[i] ^ prog[i].when_to_branch;"
    },
    {
        "line": 21,
        "fullcodeline": "return ERR_PTR(-ENOMEM);"
    },
    {
        "line": 24,
        "fullcodeline": "parse_error(pe, -ENOMEM, 0);"
    },
    {
        "line": 29,
        "fullcodeline": "parse_error(pe, -ENOMEM, 0);"
    },
    {
        "line": 41,
        "fullcodeline": "if (isspace(*next))"
    },
    {
        "line": 57,
        "fullcodeline": "if (N >= nr_preds) {"
    },
    {
        "line": 63,
        "fullcodeline": "prog[N].target = N-1;"
    },
    {
        "line": 66,
        "fullcodeline": "if (len < 0) {"
    },
    {
        "line": 146,
        "fullcodeline": "prog[N-1].target = N;"
    },
    {
        "line": 53,
        "fullcodeline": "invert = !invert;"
    },
    {
        "line": 67,
        "fullcodeline": "ret = len;"
    },
    {
        "line": 76,
        "fullcodeline": "next = ptr++;"
    },
    {
        "line": 98,
        "fullcodeline": "invert = *top & INVERT;"
    },
    {
        "line": 125,
        "fullcodeline": "top--;\t\t\t\t\t/* #12 */"
    },
    {
        "line": 161,
        "fullcodeline": "if (WARN_ON(prog[i].target <= i)) {"
    },
    {
        "line": 162,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 174,
        "fullcodeline": "for (i = 0; prog_stack[i].pred; i++)"
    },
    {
        "line": 58,
        "fullcodeline": "parse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);"
    },
    {
        "line": 77,
        "fullcodeline": "if (isspace(*next))"
    },
    {
        "line": 100,
        "fullcodeline": "if (*top & PROCESS_AND) {\t\t/* #7 */"
    },
    {
        "line": 104,
        "fullcodeline": "if (*next == '&') {\t\t\t/* #8 */"
    },
    {
        "line": 108,
        "fullcodeline": "if (*top & PROCESS_OR) {\t\t/* #9 */"
    },
    {
        "line": 112,
        "fullcodeline": "if (*next == '|') {\t\t\t/* #10 */"
    },
    {
        "line": 116,
        "fullcodeline": "if (!*next)\t\t\t\t/* #11 */"
    },
    {
        "line": 119,
        "fullcodeline": "if (top == op_stack) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (top - op_stack > nr_parens)"
    },
    {
        "line": 48,
        "fullcodeline": "*(++top) = invert;"
    },
    {
        "line": 51,
        "fullcodeline": "if (!is_not(next))"
    },
    {
        "line": 101,
        "fullcodeline": "update_preds(prog, N - 1, invert);"
    },
    {
        "line": 102,
        "fullcodeline": "*top &= ~PROCESS_AND;"
    },
    {
        "line": 105,
        "fullcodeline": "*top |= PROCESS_AND;"
    },
    {
        "line": 109,
        "fullcodeline": "update_preds(prog, N - 1, !invert);"
    },
    {
        "line": 110,
        "fullcodeline": "*top &= ~PROCESS_OR;"
    },
    {
        "line": 113,
        "fullcodeline": "*top |= PROCESS_OR;"
    },
    {
        "line": 120,
        "fullcodeline": "ret = -1;"
    },
    {
        "line": 122,
        "fullcodeline": "parse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);"
    },
    {
        "line": 47,
        "fullcodeline": "return ERR_PTR(-EINVAL);"
    },
    {
        "line": 87,
        "fullcodeline": "if (next[1] == next[0]) {"
    },
    {
        "line": 94,
        "fullcodeline": "next - str);"
    },
    {
        "line": 88,
        "fullcodeline": "ptr++;"
    }
]