[
    {
        "line": 7,
        "fullcodeline": "const char *ptr = str;"
    },
    {
        "line": 8,
        "fullcodeline": "char *inverts = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "int invert = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "int ret = -ENOMEM;"
    },
    {
        "line": 14,
        "fullcodeline": "int N = 0;"
    },
    {
        "line": 17,
        "fullcodeline": "nr_preds += 2; /* For TRUE and FALSE */"
    },
    {
        "line": 19,
        "fullcodeline": "op_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);"
    },
    {
        "line": 22,
        "fullcodeline": "prog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);"
    },
    {
        "line": 27,
        "fullcodeline": "inverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);"
    },
    {
        "line": 33,
        "fullcodeline": "top = op_stack;"
    },
    {
        "line": 34,
        "fullcodeline": "prog = prog_stack;"
    },
    {
        "line": 35,
        "fullcodeline": "*top = 0;"
    },
    {
        "line": 149,
        "fullcodeline": "prog[N-1].when_to_branch = false;"
    },
    {
        "line": 20,
        "fullcodeline": "if (!op_stack)"
    },
    {
        "line": 23,
        "fullcodeline": "if (!prog_stack) {"
    },
    {
        "line": 28,
        "fullcodeline": "if (!inverts) {"
    },
    {
        "line": 131,
        "fullcodeline": "if (top != op_stack) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (!N) {"
    },
    {
        "line": 159,
        "fullcodeline": "for (i = 0; i < N; i++) {"
    },
    {
        "line": 180,
        "fullcodeline": "return ERR_PTR(ret);"
    },
    {
        "line": 39,
        "fullcodeline": "const char *next = ptr++;"
    },
    {
        "line": 64,
        "fullcodeline": "inverts[N] = invert;\t\t\t\t/* #4 */"
    },
    {
        "line": 67,
        "fullcodeline": "len = parse_pred(next, data, ptr - str, pe, &prog[N].pred);"
    },
    {
        "line": 72,
        "fullcodeline": "ptr = next + len;"
    },
    {
        "line": 74,
        "fullcodeline": "N++;"
    },
    {
        "line": 76,
        "fullcodeline": "ret = -1;"
    },
    {
        "line": 133,
        "fullcodeline": "parse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);"
    },
    {
        "line": 139,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 140,
        "fullcodeline": "parse_error(pe, FILT_ERR_NO_FILTER, ptr - str);"
    },
    {
        "line": 152,
        "fullcodeline": "for (i = N-1 ; i--; ) {"
    },
    {
        "line": 160,
        "fullcodeline": "invert = inverts[i] ^ prog[i].when_to_branch;"
    },
    {
        "line": 21,
        "fullcodeline": "return ERR_PTR(-ENOMEM);"
    },
    {
        "line": 24,
        "fullcodeline": "parse_error(pe, -ENOMEM, 0);"
    },
    {
        "line": 29,
        "fullcodeline": "parse_error(pe, -ENOMEM, 0);"
    },
    {
        "line": 41,
        "fullcodeline": "if (isspace(*next))"
    },
    {
        "line": 59,
        "fullcodeline": "if (N >= nr_preds) {"
    },
    {
        "line": 65,
        "fullcodeline": "prog[N].target = N-1;"
    },
    {
        "line": 68,
        "fullcodeline": "if (len < 0) {"
    },
    {
        "line": 148,
        "fullcodeline": "prog[N-1].target = N;"
    },
    {
        "line": 55,
        "fullcodeline": "invert = !invert;"
    },
    {
        "line": 69,
        "fullcodeline": "ret = len;"
    },
    {
        "line": 78,
        "fullcodeline": "next = ptr++;"
    },
    {
        "line": 100,
        "fullcodeline": "invert = *top & INVERT;"
    },
    {
        "line": 127,
        "fullcodeline": "top--;\t\t\t\t\t/* #12 */"
    },
    {
        "line": 163,
        "fullcodeline": "if (WARN_ON(prog[i].target <= i)) {"
    },
    {
        "line": 164,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 176,
        "fullcodeline": "for (i = 0; prog_stack[i].pred; i++)"
    },
    {
        "line": 60,
        "fullcodeline": "parse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);"
    },
    {
        "line": 79,
        "fullcodeline": "if (isspace(*next))"
    },
    {
        "line": 102,
        "fullcodeline": "if (*top & PROCESS_AND) {\t\t/* #7 */"
    },
    {
        "line": 106,
        "fullcodeline": "if (*next == '&') {\t\t\t/* #8 */"
    },
    {
        "line": 110,
        "fullcodeline": "if (*top & PROCESS_OR) {\t\t/* #9 */"
    },
    {
        "line": 114,
        "fullcodeline": "if (*next == '|') {\t\t\t/* #10 */"
    },
    {
        "line": 118,
        "fullcodeline": "if (!*next)\t\t\t\t/* #11 */"
    },
    {
        "line": 121,
        "fullcodeline": "if (top == op_stack) {"
    },
    {
        "line": 46,
        "fullcodeline": "if (top - op_stack > nr_parens) {"
    },
    {
        "line": 47,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 50,
        "fullcodeline": "*(++top) = invert;"
    },
    {
        "line": 53,
        "fullcodeline": "if (!is_not(next))"
    },
    {
        "line": 103,
        "fullcodeline": "update_preds(prog, N - 1, invert);"
    },
    {
        "line": 104,
        "fullcodeline": "*top &= ~PROCESS_AND;"
    },
    {
        "line": 107,
        "fullcodeline": "*top |= PROCESS_AND;"
    },
    {
        "line": 111,
        "fullcodeline": "update_preds(prog, N - 1, !invert);"
    },
    {
        "line": 112,
        "fullcodeline": "*top &= ~PROCESS_OR;"
    },
    {
        "line": 115,
        "fullcodeline": "*top |= PROCESS_OR;"
    },
    {
        "line": 122,
        "fullcodeline": "ret = -1;"
    },
    {
        "line": 124,
        "fullcodeline": "parse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);"
    },
    {
        "line": 89,
        "fullcodeline": "if (next[1] == next[0]) {"
    },
    {
        "line": 96,
        "fullcodeline": "next - str);"
    },
    {
        "line": 90,
        "fullcodeline": "ptr++;"
    }
]