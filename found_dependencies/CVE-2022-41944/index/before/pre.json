[
    {
        "line": 3,
        "fullcodeline": "if params[:username] && !params[:recent]"
    },
    {
        "line": 11,
        "fullcodeline": "guardian.ensure_can_see_notifications!(user)"
    },
    {
        "line": 13,
        "fullcodeline": "if notification_types = params[:filter_by_types]&.split(\",\").presence"
    },
    {
        "line": 4,
        "fullcodeline": "user_record = User.find_by(username: params[:username].to_s)"
    },
    {
        "line": 7,
        "fullcodeline": "else"
    },
    {
        "line": 14,
        "fullcodeline": "notification_types.map! do |type|"
    },
    {
        "line": 22,
        "fullcodeline": "limit = (params[:limit] || 15).to_i"
    },
    {
        "line": 25,
        "fullcodeline": "include_reviewables = false"
    },
    {
        "line": 52,
        "fullcodeline": "json = {"
    },
    {
        "line": 64,
        "fullcodeline": "offset = params[:offset].to_i"
    },
    {
        "line": 66,
        "fullcodeline": "notifications = Notification.where(user_id: user.id)"
    },
    {
        "line": 75,
        "fullcodeline": "total_rows = notifications.dup.count"
    },
    {
        "line": 76,
        "fullcodeline": "notifications = notifications.offset(offset).limit(60)"
    },
    {
        "line": 5,
        "fullcodeline": "raise Discourse::NotFound if !user_record"
    },
    {
        "line": 23,
        "fullcodeline": "limit = 50 if limit > 50"
    },
    {
        "line": 34,
        "fullcodeline": "if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)"
    },
    {
        "line": 62,
        "fullcodeline": "render_json_dump(json)"
    },
    {
        "line": 71,
        "fullcodeline": "notifications = notifications.where(read: true) if params[:filter] == \"read\""
    },
    {
        "line": 73,
        "fullcodeline": "notifications = notifications.where(read: false) if params[:filter] == \"unread\""
    },
    {
        "line": 77,
        "fullcodeline": "render_json_dump(notifications: serialize_data(notifications, NotificationSerializer),"
    },
    {
        "line": 27,
        "fullcodeline": "notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types)"
    },
    {
        "line": 29,
        "fullcodeline": "include_reviewables = notification_types.blank? && guardian.can_see_review_queue?"
    },
    {
        "line": 31,
        "fullcodeline": "notifications = Notification.recent_report(current_user, limit, notification_types)"
    },
    {
        "line": 41,
        "fullcodeline": "if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables"
    },
    {
        "line": 43,
        "fullcodeline": "Scheduler::Defer.later \"bump last seen reviewable for user\" do"
    },
    {
        "line": 53,
        "fullcodeline": "notifications: serialize_data(notifications, NotificationSerializer),"
    },
    {
        "line": 54,
        "fullcodeline": "seen_notification_id: current_user.seen_notification_id"
    },
    {
        "line": 57,
        "fullcodeline": "json[:pending_reviewables] = Reviewable.basic_serializers_for_list("
    },
    {
        "line": 80,
        "fullcodeline": "load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]))"
    },
    {
        "line": 58,
        "fullcodeline": "Reviewable.user_menu_list_for(current_user),"
    }
]