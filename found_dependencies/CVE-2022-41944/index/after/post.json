[
    {
        "line": 3,
        "fullcodeline": "if params[:username] && !params[:recent]"
    },
    {
        "line": 11,
        "fullcodeline": "guardian.ensure_can_see_notifications!(user)"
    },
    {
        "line": 4,
        "fullcodeline": "user_record = User.find_by(username: params[:username].to_s)"
    },
    {
        "line": 7,
        "fullcodeline": "else"
    },
    {
        "line": 14,
        "fullcodeline": "notification_types.map! do |type|"
    },
    {
        "line": 21,
        "fullcodeline": "if params[:recent].present?"
    },
    {
        "line": 25,
        "fullcodeline": "include_reviewables = false"
    },
    {
        "line": 52,
        "fullcodeline": "notifications = filter_inaccessible_notifications(notifications)"
    },
    {
        "line": 54,
        "fullcodeline": "json = {"
    },
    {
        "line": 68,
        "fullcodeline": "notifications = Notification.where(user_id: user.id)"
    },
    {
        "line": 78,
        "fullcodeline": "notifications = notifications.offset(offset).limit(60)"
    },
    {
        "line": 79,
        "fullcodeline": "notifications = filter_inaccessible_notifications(notifications)"
    },
    {
        "line": 5,
        "fullcodeline": "raise Discourse::NotFound if !user_record"
    },
    {
        "line": 13,
        "fullcodeline": "if notification_types = params[:filter_by_types]&.split(\",\").presence"
    },
    {
        "line": 23,
        "fullcodeline": "limit = 50 if limit > 50"
    },
    {
        "line": 34,
        "fullcodeline": "if notifications.present? && !(params.has_key?(:silent) || @readonly_mode)"
    },
    {
        "line": 41,
        "fullcodeline": "if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables"
    },
    {
        "line": 64,
        "fullcodeline": "render_json_dump(json)"
    },
    {
        "line": 73,
        "fullcodeline": "notifications = notifications.where(read: true) if params[:filter] == \"read\""
    },
    {
        "line": 75,
        "fullcodeline": "notifications = notifications.where(read: false) if params[:filter] == \"unread\""
    },
    {
        "line": 80,
        "fullcodeline": "render_json_dump(notifications: serialize_data(notifications, NotificationSerializer),"
    },
    {
        "line": 22,
        "fullcodeline": "limit = (params[:limit] || 15).to_i"
    },
    {
        "line": 27,
        "fullcodeline": "notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types)"
    },
    {
        "line": 29,
        "fullcodeline": "include_reviewables = notification_types.blank? && guardian.can_see_review_queue?"
    },
    {
        "line": 31,
        "fullcodeline": "notifications = Notification.recent_report(current_user, limit, notification_types)"
    },
    {
        "line": 43,
        "fullcodeline": "Scheduler::Defer.later \"bump last seen reviewable for user\" do"
    },
    {
        "line": 55,
        "fullcodeline": "notifications: serialize_data(notifications, NotificationSerializer),"
    },
    {
        "line": 77,
        "fullcodeline": "total_rows = notifications.dup.count"
    },
    {
        "line": 83,
        "fullcodeline": "load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]))"
    },
    {
        "line": 59,
        "fullcodeline": "json[:pending_reviewables] = Reviewable.basic_serializers_for_list("
    },
    {
        "line": 60,
        "fullcodeline": "Reviewable.user_menu_list_for(current_user),"
    }
]