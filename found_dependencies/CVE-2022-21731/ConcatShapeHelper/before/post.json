[
    {
        "line": 4,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));"
    },
    {
        "line": 5,
        "fullcodeline": "const Tensor* concat_dim_t = c->input_tensor(dim_index);"
    },
    {
        "line": 48,
        "fullcodeline": "const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;"
    },
    {
        "line": 53,
        "fullcodeline": "ShapeHandle input = c->input(end_value_index - 1);"
    },
    {
        "line": 54,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));"
    },
    {
        "line": 55,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));"
    },
    {
        "line": 56,
        "fullcodeline": "DimensionHandle output_middle = c->Dim(input, concat_dim);"
    },
    {
        "line": 82,
        "fullcodeline": "TF_RETURN_IF_ERROR("
    },
    {
        "line": 84,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));"
    },
    {
        "line": 85,
        "fullcodeline": "c->set_output(0, s);"
    },
    {
        "line": 6,
        "fullcodeline": "if (concat_dim_t == nullptr) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (concat_dim_t->dtype() == DT_INT32) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (concat_dim == -1) {"
    },
    {
        "line": 63,
        "fullcodeline": "for (int i = end_value_index - 2; i >= start_value_index; --i) {"
    },
    {
        "line": 83,
        "fullcodeline": "c->Concatenate(output_before, c->Vector(output_middle), &s));"
    },
    {
        "line": 86,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 31,
        "fullcodeline": "std::vector<DimensionHandle> dims;"
    },
    {
        "line": 32,
        "fullcodeline": "dims.reserve(rank);"
    },
    {
        "line": 34,
        "fullcodeline": "c->set_output(0, c->MakeShape(dims));"
    },
    {
        "line": 42,
        "fullcodeline": "concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));"
    },
    {
        "line": 58,
        "fullcodeline": "output_after = c->Scalar();  // no dimensions."
    },
    {
        "line": 66,
        "fullcodeline": "input = c->input(i);"
    },
    {
        "line": 67,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));"
    },
    {
        "line": 68,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));"
    },
    {
        "line": 69,
        "fullcodeline": "DimensionHandle middle = c->Dim(input, concat_dim);"
    },
    {
        "line": 76,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));"
    },
    {
        "line": 77,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));"
    },
    {
        "line": 78,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));"
    },
    {
        "line": 12,
        "fullcodeline": "for (int i = start_value_index; i < end_value_index; ++i) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (rank == InferenceContext::kUnknownRank) {"
    },
    {
        "line": 33,
        "fullcodeline": "for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());"
    },
    {
        "line": 35,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 44,
        "fullcodeline": "concat_dim = concat_dim_t->flat<int64_t>()(0);"
    },
    {
        "line": 60,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));"
    },
    {
        "line": 70,
        "fullcodeline": "if (concat_dim == -1) {"
    },
    {
        "line": 19,
        "fullcodeline": "c->set_output(0, c->UnknownShape());"
    },
    {
        "line": 71,
        "fullcodeline": "after = c->Scalar();"
    },
    {
        "line": 13,
        "fullcodeline": "if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));"
    },
    {
        "line": 14,
        "fullcodeline": "if (rank != InferenceContext::kUnknownRank) {"
    },
    {
        "line": 20,
        "fullcodeline": "return Status::OK();"
    },
    {
        "line": 73,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));"
    },
    {
        "line": 21,
        "fullcodeline": "} else if (rank == 0) {"
    },
    {
        "line": 22,
        "fullcodeline": "return errors::InvalidArgument("
    },
    {
        "line": 25,
        "fullcodeline": "for (int i = start_value_index; i < end_value_index; ++i) {"
    },
    {
        "line": 27,
        "fullcodeline": "TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));"
    }
]