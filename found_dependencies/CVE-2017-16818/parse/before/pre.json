[
    {
        "line": 2,
        "fullcodeline": "static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";"
    },
    {
        "line": 3,
        "fullcodeline": "static const regex rx_wild(str_wild,"
    },
    {
        "line": 6,
        "fullcodeline": "static const char str_no_wild[]"
    },
    {
        "line": 8,
        "fullcodeline": "static const regex rx_no_wild(str_no_wild,"
    },
    {
        "line": 4,
        "fullcodeline": "sizeof(str_wild) - 1,"
    },
    {
        "line": 5,
        "fullcodeline": "ECMAScript | optimize);"
    },
    {
        "line": 9,
        "fullcodeline": "sizeof(str_no_wild) - 1,"
    },
    {
        "line": 10,
        "fullcodeline": "ECMAScript | optimize);"
    },
    {
        "line": 14,
        "fullcodeline": "if ((s == \"*\") && wildcards) {"
    },
    {
        "line": 15,
        "fullcodeline": "return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");"
    },
    {
        "line": 16,
        "fullcodeline": "} else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {"
    },
    {
        "line": 35,
        "fullcodeline": "a.region = match[3];"
    },
    {
        "line": 36,
        "fullcodeline": "a.account = match[4];"
    },
    {
        "line": 37,
        "fullcodeline": "a.resource = match[5];"
    },
    {
        "line": 17,
        "fullcodeline": "ceph_assert(match.size() == 6);"
    },
    {
        "line": 21,
        "fullcodeline": "auto p = to_partition(match[1], wildcards);"
    },
    {
        "line": 25,
        "fullcodeline": "a.partition = *p;"
    },
    {
        "line": 28,
        "fullcodeline": "auto s = to_service(match[2], wildcards);"
    },
    {
        "line": 32,
        "fullcodeline": "a.service = *s;"
    }
]