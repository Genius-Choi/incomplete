[
    {
        "line": 20,
        "fullcodeline": "tmp_cp = cp + 2;"
    },
    {
        "line": 21,
        "fullcodeline": "tmp_olen = optlen - 2;"
    },
    {
        "line": 22,
        "fullcodeline": "tcpstat_inc(tcps_sack_rcv_opts);"
    },
    {
        "line": 7,
        "fullcodeline": "if (!tp->sack_enable)"
    },
    {
        "line": 10,
        "fullcodeline": "if ((th->th_flags & TH_ACK) == 0)"
    },
    {
        "line": 13,
        "fullcodeline": "if (SEQ_LT(th->th_ack, tp->snd_una) ||"
    },
    {
        "line": 17,
        "fullcodeline": "if (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)"
    },
    {
        "line": 23,
        "fullcodeline": "if (tp->snd_numholes < 0)"
    },
    {
        "line": 25,
        "fullcodeline": "if (tp->t_maxseg == 0)"
    },
    {
        "line": 27,
        "fullcodeline": "while (tmp_olen > 0) {"
    },
    {
        "line": 14,
        "fullcodeline": "SEQ_GT(th->th_ack, tp->snd_max))"
    },
    {
        "line": 24,
        "fullcodeline": "tp->snd_numholes = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "panic(\"tcp_sack_option\"); /* Should never happen */"
    },
    {
        "line": 30,
        "fullcodeline": "memcpy(&sack.start, tmp_cp, sizeof(tcp_seq));"
    },
    {
        "line": 31,
        "fullcodeline": "sack.start = ntohl(sack.start);"
    },
    {
        "line": 32,
        "fullcodeline": "memcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));"
    },
    {
        "line": 33,
        "fullcodeline": "sack.end = ntohl(sack.end);"
    },
    {
        "line": 34,
        "fullcodeline": "tmp_olen -= TCPOLEN_SACK;"
    },
    {
        "line": 35,
        "fullcodeline": "tmp_cp += TCPOLEN_SACK;"
    },
    {
        "line": 71,
        "fullcodeline": "p = cur = tp->snd_holes;"
    },
    {
        "line": 36,
        "fullcodeline": "if (SEQ_LEQ(sack.end, sack.start))"
    },
    {
        "line": 38,
        "fullcodeline": "if (SEQ_LEQ(sack.end, tp->snd_una))"
    },
    {
        "line": 40,
        "fullcodeline": "if (SEQ_GT(th->th_ack, tp->snd_una)) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (SEQ_GT(sack.end, tp->snd_max))"
    },
    {
        "line": 46,
        "fullcodeline": "if (tp->snd_holes == NULL) { /* first hole */"
    },
    {
        "line": 152,
        "fullcodeline": "if (SEQ_LT(tp->rcv_lastsack, sack.start)) {"
    },
    {
        "line": 47,
        "fullcodeline": "tp->snd_holes = (struct sackhole *)"
    },
    {
        "line": 53,
        "fullcodeline": "cur = tp->snd_holes;"
    },
    {
        "line": 54,
        "fullcodeline": "cur->start = th->th_ack;"
    },
    {
        "line": 55,
        "fullcodeline": "cur->end = sack.start;"
    },
    {
        "line": 56,
        "fullcodeline": "cur->rxmit = cur->start;"
    },
    {
        "line": 57,
        "fullcodeline": "cur->next = NULL;"
    },
    {
        "line": 58,
        "fullcodeline": "tp->snd_numholes = 1;"
    },
    {
        "line": 59,
        "fullcodeline": "tp->rcv_lastsack = sack.end;"
    },
    {
        "line": 64,
        "fullcodeline": "cur->dups = min(tcprexmtthresh,"
    },
    {
        "line": 159,
        "fullcodeline": "temp = (struct sackhole *)"
    },
    {
        "line": 163,
        "fullcodeline": "temp->start = tp->rcv_lastsack;"
    },
    {
        "line": 164,
        "fullcodeline": "temp->end = sack.start;"
    },
    {
        "line": 165,
        "fullcodeline": "temp->dups = min(tcprexmtthresh,"
    },
    {
        "line": 169,
        "fullcodeline": "temp->rxmit = temp->start;"
    },
    {
        "line": 170,
        "fullcodeline": "temp->next = 0;"
    },
    {
        "line": 171,
        "fullcodeline": "p->next = temp;"
    },
    {
        "line": 172,
        "fullcodeline": "tp->rcv_lastsack = sack.end;"
    },
    {
        "line": 173,
        "fullcodeline": "tp->snd_numholes++;"
    },
    {
        "line": 41,
        "fullcodeline": "if (SEQ_LT(sack.start, th->th_ack))"
    },
    {
        "line": 49,
        "fullcodeline": "if (tp->snd_holes == NULL) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (cur->dups < 1)"
    },
    {
        "line": 73,
        "fullcodeline": "if (SEQ_LEQ(sack.end, cur->start))"
    },
    {
        "line": 76,
        "fullcodeline": "if (SEQ_GEQ(sack.start, cur->end)) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (SEQ_LEQ(sack.start, cur->start)) {"
    },
    {
        "line": 111,
        "fullcodeline": "if (SEQ_GEQ(sack.end, cur->end)) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (SEQ_LT(cur->start, sack.start) &&"
    },
    {
        "line": 157,
        "fullcodeline": "if (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)"
    },
    {
        "line": 161,
        "fullcodeline": "if (temp == NULL)"
    },
    {
        "line": 167,
        "fullcodeline": "if (temp->dups < 1)"
    },
    {
        "line": 48,
        "fullcodeline": "pool_get(&sackhl_pool, PR_NOWAIT);"
    },
    {
        "line": 65,
        "fullcodeline": "((sack.end - cur->end)/tp->t_maxseg));"
    },
    {
        "line": 67,
        "fullcodeline": "cur->dups = 1;"
    },
    {
        "line": 78,
        "fullcodeline": "cur->dups++;"
    },
    {
        "line": 82,
        "fullcodeline": "p = cur;"
    },
    {
        "line": 83,
        "fullcodeline": "cur = cur->next;"
    },
    {
        "line": 104,
        "fullcodeline": "cur->start = sack.end;"
    },
    {
        "line": 105,
        "fullcodeline": "cur->rxmit = SEQ_MAX(cur->rxmit, cur->start);"
    },
    {
        "line": 106,
        "fullcodeline": "p = cur;"
    },
    {
        "line": 107,
        "fullcodeline": "cur = cur->next;"
    },
    {
        "line": 112,
        "fullcodeline": "cur->end = sack.start;"
    },
    {
        "line": 113,
        "fullcodeline": "cur->rxmit = SEQ_MIN(cur->rxmit, cur->end);"
    },
    {
        "line": 114,
        "fullcodeline": "cur->dups++;"
    },
    {
        "line": 118,
        "fullcodeline": "p = cur;"
    },
    {
        "line": 119,
        "fullcodeline": "cur = cur->next;"
    },
    {
        "line": 123,
        "fullcodeline": "SEQ_GT(cur->end, sack.end)) {"
    },
    {
        "line": 130,
        "fullcodeline": "temp = (struct sackhole *)"
    },
    {
        "line": 134,
        "fullcodeline": "temp->next = cur->next;"
    },
    {
        "line": 135,
        "fullcodeline": "temp->start = sack.end;"
    },
    {
        "line": 136,
        "fullcodeline": "temp->end = cur->end;"
    },
    {
        "line": 137,
        "fullcodeline": "temp->dups = cur->dups;"
    },
    {
        "line": 138,
        "fullcodeline": "temp->rxmit = SEQ_MAX(cur->rxmit, temp->start);"
    },
    {
        "line": 139,
        "fullcodeline": "cur->end = sack.start;"
    },
    {
        "line": 140,
        "fullcodeline": "cur->rxmit = SEQ_MIN(cur->rxmit, cur->end);"
    },
    {
        "line": 141,
        "fullcodeline": "cur->dups++;"
    },
    {
        "line": 145,
        "fullcodeline": "cur->next = temp;"
    },
    {
        "line": 146,
        "fullcodeline": "p = temp;"
    },
    {
        "line": 147,
        "fullcodeline": "cur = p->next;"
    },
    {
        "line": 148,
        "fullcodeline": "tp->snd_numholes++;"
    },
    {
        "line": 160,
        "fullcodeline": "pool_get(&sackhl_pool, PR_NOWAIT);"
    },
    {
        "line": 166,
        "fullcodeline": "((sack.end - sack.start)/tp->t_maxseg));"
    },
    {
        "line": 168,
        "fullcodeline": "temp->dups = 1;"
    },
    {
        "line": 79,
        "fullcodeline": "if (((sack.end - cur->end)/tp->t_maxseg) >="
    },
    {
        "line": 88,
        "fullcodeline": "if (SEQ_GEQ(sack.end, cur->end)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (((sack.end - cur->end)/tp->t_maxseg) >="
    },
    {
        "line": 128,
        "fullcodeline": "if (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)"
    },
    {
        "line": 132,
        "fullcodeline": "if (temp == NULL)"
    },
    {
        "line": 142,
        "fullcodeline": "if (((sack.end - cur->end)/tp->t_maxseg) >="
    },
    {
        "line": 81,
        "fullcodeline": "cur->dups = tcprexmtthresh;"
    },
    {
        "line": 100,
        "fullcodeline": "tp->snd_numholes--;"
    },
    {
        "line": 117,
        "fullcodeline": "cur->dups = tcprexmtthresh;"
    },
    {
        "line": 131,
        "fullcodeline": "pool_get(&sackhl_pool, PR_NOWAIT);"
    },
    {
        "line": 144,
        "fullcodeline": "cur->dups = tcprexmtthresh;"
    },
    {
        "line": 90,
        "fullcodeline": "if (p != cur) {"
    },
    {
        "line": 91,
        "fullcodeline": "p->next = cur->next;"
    },
    {
        "line": 92,
        "fullcodeline": "pool_put(&sackhl_pool, cur);"
    },
    {
        "line": 93,
        "fullcodeline": "cur = p->next;"
    },
    {
        "line": 95,
        "fullcodeline": "cur = cur->next;"
    },
    {
        "line": 96,
        "fullcodeline": "pool_put(&sackhl_pool, p);"
    },
    {
        "line": 97,
        "fullcodeline": "p = cur;"
    },
    {
        "line": 98,
        "fullcodeline": "tp->snd_holes = p;"
    }
]