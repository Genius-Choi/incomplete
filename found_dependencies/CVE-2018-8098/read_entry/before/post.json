[
    {
        "line": 12,
        "fullcodeline": "git_index_entry entry = {{0}};"
    },
    {
        "line": 13,
        "fullcodeline": "bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;"
    },
    {
        "line": 14,
        "fullcodeline": "char *tmp_path = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "memcpy(&source, buffer, sizeof(struct entry_short));"
    },
    {
        "line": 22,
        "fullcodeline": "entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);"
    },
    {
        "line": 23,
        "fullcodeline": "entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);"
    },
    {
        "line": 24,
        "fullcodeline": "entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);"
    },
    {
        "line": 25,
        "fullcodeline": "entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);"
    },
    {
        "line": 26,
        "fullcodeline": "entry.dev = ntohl(source.dev);"
    },
    {
        "line": 27,
        "fullcodeline": "entry.ino = ntohl(source.ino);"
    },
    {
        "line": 28,
        "fullcodeline": "entry.mode = ntohl(source.mode);"
    },
    {
        "line": 29,
        "fullcodeline": "entry.uid = ntohl(source.uid);"
    },
    {
        "line": 30,
        "fullcodeline": "entry.gid = ntohl(source.gid);"
    },
    {
        "line": 31,
        "fullcodeline": "entry.file_size = ntohl(source.file_size);"
    },
    {
        "line": 32,
        "fullcodeline": "git_oid_cpy(&entry.id, &source.oid);"
    },
    {
        "line": 33,
        "fullcodeline": "entry.flags = ntohs(source.flags);"
    },
    {
        "line": 101,
        "fullcodeline": "git__free(tmp_path);"
    },
    {
        "line": 102,
        "fullcodeline": "*out_size = entry_size;"
    },
    {
        "line": 16,
        "fullcodeline": "if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)"
    },
    {
        "line": 49,
        "fullcodeline": "if (!compressed) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (entry_size == 0)"
    },
    {
        "line": 93,
        "fullcodeline": "if (INDEX_FOOTER_SIZE + entry_size > buffer_size)"
    },
    {
        "line": 96,
        "fullcodeline": "if (index_entry_dup(out, index, &entry) < 0) {"
    },
    {
        "line": 50,
        "fullcodeline": "path_length = entry.flags & GIT_IDXENTRY_NAMEMASK;"
    },
    {
        "line": 64,
        "fullcodeline": "entry_size = index_entry_size(path_length, 0, entry.flags);"
    },
    {
        "line": 65,
        "fullcodeline": "entry.path = (char *)path_ptr;"
    },
    {
        "line": 97,
        "fullcodeline": "git__free(tmp_path);"
    },
    {
        "line": 17,
        "fullcodeline": "return -1;"
    },
    {
        "line": 54,
        "fullcodeline": "if (path_length == 0xFFF) {"
    },
    {
        "line": 70,
        "fullcodeline": "strip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);"
    },
    {
        "line": 71,
        "fullcodeline": "last_len = strlen(last);"
    },
    {
        "line": 76,
        "fullcodeline": "prefix_len = last_len - strip_len;"
    },
    {
        "line": 77,
        "fullcodeline": "suffix_len = strlen(path_ptr + varint_len);"
    },
    {
        "line": 79,
        "fullcodeline": "GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);"
    },
    {
        "line": 80,
        "fullcodeline": "GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);"
    },
    {
        "line": 81,
        "fullcodeline": "tmp_path = git__malloc(path_len);"
    },
    {
        "line": 82,
        "fullcodeline": "GITERR_CHECK_ALLOC(tmp_path);"
    },
    {
        "line": 84,
        "fullcodeline": "memcpy(tmp_path, last, prefix_len);"
    },
    {
        "line": 85,
        "fullcodeline": "memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);"
    },
    {
        "line": 86,
        "fullcodeline": "entry_size = index_entry_size(suffix_len, varint_len, entry.flags);"
    },
    {
        "line": 87,
        "fullcodeline": "entry.path = tmp_path;"
    },
    {
        "line": 91,
        "fullcodeline": "return -1;"
    },
    {
        "line": 94,
        "fullcodeline": "return -1;"
    },
    {
        "line": 98,
        "fullcodeline": "return -1;"
    },
    {
        "line": 57,
        "fullcodeline": "path_end = memchr(path_ptr, '\\0', buffer_size);"
    },
    {
        "line": 61,
        "fullcodeline": "path_length = path_end - path_ptr;"
    },
    {
        "line": 73,
        "fullcodeline": "if (varint_len == 0 || last_len < strip_len)"
    },
    {
        "line": 58,
        "fullcodeline": "if (path_end == NULL)"
    },
    {
        "line": 74,
        "fullcodeline": "return index_error_invalid(\"incorrect prefix length\");"
    },
    {
        "line": 59,
        "fullcodeline": "return -1;"
    }
]