[
    {
        "line": 2,
        "fullcodeline": "(void)argc;"
    },
    {
        "line": 4,
        "fullcodeline": "const char *usage = \"Usage: seatd-launch [options] [--] command\\n\""
    },
    {
        "line": 12,
        "fullcodeline": "char *sockpath = NULL;"
    },
    {
        "line": 36,
        "fullcodeline": "char **command = &argv[optind];"
    },
    {
        "line": 38,
        "fullcodeline": "char sockbuf[256];"
    },
    {
        "line": 44,
        "fullcodeline": "int fds[2];"
    },
    {
        "line": 50,
        "fullcodeline": "pid_t seatd_child = fork();"
    },
    {
        "line": 73,
        "fullcodeline": "close(fds[1]);"
    },
    {
        "line": 76,
        "fullcodeline": "char buf[1] = {0};"
    },
    {
        "line": 112,
        "fullcodeline": "close(fds[0]);"
    },
    {
        "line": 114,
        "fullcodeline": "uid_t uid = getuid();"
    },
    {
        "line": 115,
        "fullcodeline": "gid_t gid = getgid();"
    },
    {
        "line": 137,
        "fullcodeline": "pid_t child = fork();"
    },
    {
        "line": 148,
        "fullcodeline": "int status = 0;"
    },
    {
        "line": 172,
        "fullcodeline": "kill(seatd_child, SIGTERM);"
    },
    {
        "line": 13,
        "fullcodeline": "while ((c = getopt(argc, argv, \"vhs:\")) != -1) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (optind >= argc) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (sockpath == NULL) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (pipe(fds) == -1) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (seatd_child == -1) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (chown(sockpath, uid, gid) == -1) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (chmod(sockpath, 0700) == -1) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (setgid(gid) == -1) {"
    },
    {
        "line": 132,
        "fullcodeline": "if (setuid(uid) == -1) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (child == -1) {"
    },
    {
        "line": 159,
        "fullcodeline": "if (kill(seatd_child, SIGTERM) != 0) {"
    },
    {
        "line": 163,
        "fullcodeline": "if (WIFEXITED(status)) {"
    },
    {
        "line": 33,
        "fullcodeline": "fprintf(stderr, \"A command must be specified\\n\\n%s\", usage);"
    },
    {
        "line": 40,
        "fullcodeline": "sprintf(sockbuf, \"/tmp/seatd.%d.sock\", getpid());"
    },
    {
        "line": 41,
        "fullcodeline": "sockpath = sockbuf;"
    },
    {
        "line": 46,
        "fullcodeline": "perror(\"Could not create pipe\");"
    },
    {
        "line": 52,
        "fullcodeline": "perror(\"Could not fork seatd process\");"
    },
    {
        "line": 78,
        "fullcodeline": "pid_t p = waitpid(seatd_child, NULL, WNOHANG);"
    },
    {
        "line": 87,
        "fullcodeline": "struct pollfd fd = {"
    },
    {
        "line": 119,
        "fullcodeline": "perror(\"Could not chown seatd socket\");"
    },
    {
        "line": 123,
        "fullcodeline": "perror(\"Could not chmod socket\");"
    },
    {
        "line": 129,
        "fullcodeline": "perror(\"Could not set gid to drop privileges\");"
    },
    {
        "line": 133,
        "fullcodeline": "perror(\"Could not set uid to drop privileges\");"
    },
    {
        "line": 139,
        "fullcodeline": "perror(\"Could not fork target process\");"
    },
    {
        "line": 150,
        "fullcodeline": "pid_t p = waitpid(child, &status, 0);"
    },
    {
        "line": 160,
        "fullcodeline": "perror(\"Could not kill seatd\");"
    },
    {
        "line": 79,
        "fullcodeline": "if (p == seatd_child) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (poll(&fd, 1, 1000) == -1) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (fd.revents & POLLIN) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (p == child) {"
    },
    {
        "line": 164,
        "fullcodeline": "return WEXITSTATUS(status);"
    },
    {
        "line": 16,
        "fullcodeline": "sockpath = optarg;"
    },
    {
        "line": 19,
        "fullcodeline": "printf(\"seatd-launch version %s\\n\", SEATD_VERSION);"
    },
    {
        "line": 22,
        "fullcodeline": "printf(\"%s\", usage);"
    },
    {
        "line": 25,
        "fullcodeline": "fprintf(stderr, \"Try '%s -h' for more information.\\n\", argv[0]);"
    },
    {
        "line": 28,
        "fullcodeline": "abort();"
    },
    {
        "line": 54,
        "fullcodeline": "} else if (seatd_child == 0) {"
    },
    {
        "line": 80,
        "fullcodeline": "fprintf(stderr, \"seatd exited prematurely\\n\");"
    },
    {
        "line": 103,
        "fullcodeline": "ssize_t n = read(fds[0], buf, 1);"
    },
    {
        "line": 141,
        "fullcodeline": "} else if (child == 0) {"
    },
    {
        "line": 165,
        "fullcodeline": "} else if (WIFSIGNALED(status)) {"
    },
    {
        "line": 55,
        "fullcodeline": "close(fds[0]);"
    },
    {
        "line": 57,
        "fullcodeline": "char pipebuf[16] = {0};"
    },
    {
        "line": 58,
        "fullcodeline": "snprintf(pipebuf, sizeof pipebuf, \"%d\", fds[1]);"
    },
    {
        "line": 60,
        "fullcodeline": "char *env[2] = {NULL, NULL};"
    },
    {
        "line": 61,
        "fullcodeline": "char loglevelbuf[32] = {0};"
    },
    {
        "line": 62,
        "fullcodeline": "char *cur_loglevel = getenv(\"SEATD_LOGLEVEL\");"
    },
    {
        "line": 68,
        "fullcodeline": "char *command[] = {\"seatd\", \"-n\", pipebuf, \"-s\", sockpath, NULL};"
    },
    {
        "line": 69,
        "fullcodeline": "execve(SEATD_INSTALLPATH, command, env);"
    },
    {
        "line": 70,
        "fullcodeline": "perror(\"Could not start seatd\");"
    },
    {
        "line": 71,
        "fullcodeline": "_exit(1);"
    },
    {
        "line": 88,
        "fullcodeline": ".fd = fds[0],"
    },
    {
        "line": 89,
        "fullcodeline": ".events = POLLIN,"
    },
    {
        "line": 94,
        "fullcodeline": "if (errno == EAGAIN || errno == EINTR) {"
    },
    {
        "line": 104,
        "fullcodeline": "if (n == -1 && errno != EINTR) {"
    },
    {
        "line": 142,
        "fullcodeline": "setenv(\"SEATD_SOCK\", sockpath, 1);"
    },
    {
        "line": 143,
        "fullcodeline": "execvp(command[0], command);"
    },
    {
        "line": 144,
        "fullcodeline": "perror(\"Could not start target\");"
    },
    {
        "line": 145,
        "fullcodeline": "_exit(1);"
    },
    {
        "line": 63,
        "fullcodeline": "if (cur_loglevel != NULL) {"
    },
    {
        "line": 82,
        "fullcodeline": "} else if (p == -1 && (errno != EINTR && errno != ECHILD)) {"
    },
    {
        "line": 105,
        "fullcodeline": "perror(\"Could not read from pipe\");"
    },
    {
        "line": 153,
        "fullcodeline": "} else if (p == -1 && errno != EINTR) {"
    },
    {
        "line": 166,
        "fullcodeline": "return 128 + WTERMSIG(status);"
    },
    {
        "line": 168,
        "fullcodeline": "abort(); // unreachable"
    },
    {
        "line": 64,
        "fullcodeline": "snprintf(loglevelbuf, sizeof loglevelbuf, \"SEATD_LOGLEVEL=%s\", cur_loglevel);"
    },
    {
        "line": 65,
        "fullcodeline": "env[0] = loglevelbuf;"
    },
    {
        "line": 83,
        "fullcodeline": "perror(\"Could not wait for seatd process\");"
    },
    {
        "line": 97,
        "fullcodeline": "perror(\"Could not poll notification fd\");"
    },
    {
        "line": 154,
        "fullcodeline": "perror(\"Could not wait for target process\");"
    },
    {
        "line": 107,
        "fullcodeline": "} else if (n > 0) {"
    }
]