[
    {
        "line": 3,
        "fullcodeline": "struct super_block *sb = inode->i_sb;"
    },
    {
        "line": 7,
        "fullcodeline": "ext4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "int ret = 0, depth, split_flag = 0;"
    },
    {
        "line": 28,
        "fullcodeline": "trace_ext4_insert_range(inode, offset, len);"
    },
    {
        "line": 30,
        "fullcodeline": "offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);"
    },
    {
        "line": 31,
        "fullcodeline": "len_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);"
    },
    {
        "line": 44,
        "fullcodeline": "ioffset = round_down(offset, PAGE_SIZE);"
    },
    {
        "line": 47,
        "fullcodeline": "ret = filemap_write_and_wait_range(inode->i_mapping, ioffset,"
    },
    {
        "line": 53,
        "fullcodeline": "mutex_lock(&inode->i_mutex);"
    },
    {
        "line": 74,
        "fullcodeline": "ext4_inode_block_unlocked_dio(inode);"
    },
    {
        "line": 75,
        "fullcodeline": "inode_dio_wait(inode);"
    },
    {
        "line": 81,
        "fullcodeline": "down_write(&EXT4_I(inode)->i_mmap_sem);"
    },
    {
        "line": 82,
        "fullcodeline": "truncate_pagecache(inode, ioffset);"
    },
    {
        "line": 84,
        "fullcodeline": "credits = ext4_writepage_trans_blocks(inode);"
    },
    {
        "line": 85,
        "fullcodeline": "handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);"
    },
    {
        "line": 92,
        "fullcodeline": "inode->i_size += len;"
    },
    {
        "line": 94,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 95,
        "fullcodeline": "ret = ext4_mark_inode_dirty(handle, inode);"
    },
    {
        "line": 99,
        "fullcodeline": "down_write(&EXT4_I(inode)->i_data_sem);"
    },
    {
        "line": 100,
        "fullcodeline": "ext4_discard_preallocations(inode);"
    },
    {
        "line": 102,
        "fullcodeline": "path = ext4_find_extent(inode, offset_lblk, NULL, 0);"
    },
    {
        "line": 109,
        "fullcodeline": "extent = path[depth].p_ext;"
    },
    {
        "line": 138,
        "fullcodeline": "ret = ext4_es_remove_extent(inode, offset_lblk,"
    },
    {
        "line": 149,
        "fullcodeline": "ret = ext4_ext_shift_extents(inode, handle,"
    },
    {
        "line": 161,
        "fullcodeline": "ext4_inode_resume_unlocked_dio(inode);"
    },
    {
        "line": 17,
        "fullcodeline": "if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))"
    },
    {
        "line": 34,
        "fullcodeline": "if (ext4_should_journal_data(inode)) {"
    },
    {
        "line": 86,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 103,
        "fullcodeline": "if (IS_ERR(path)) {"
    },
    {
        "line": 108,
        "fullcodeline": "depth = ext_depth(inode);"
    },
    {
        "line": 154,
        "fullcodeline": "if (IS_SYNC(inode))"
    },
    {
        "line": 21,
        "fullcodeline": "if (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||"
    },
    {
        "line": 22,
        "fullcodeline": "len & (EXT4_CLUSTER_SIZE(sb) - 1))"
    },
    {
        "line": 25,
        "fullcodeline": "if (!S_ISREG(inode->i_mode))"
    },
    {
        "line": 35,
        "fullcodeline": "ret = ext4_force_commit(inode->i_sb);"
    },
    {
        "line": 56,
        "fullcodeline": "if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {"
    },
    {
        "line": 57,
        "fullcodeline": "ret = -EOPNOTSUPP;"
    },
    {
        "line": 63,
        "fullcodeline": "ret = -EFBIG;"
    },
    {
        "line": 68,
        "fullcodeline": "if (offset >= i_size_read(inode)) {"
    },
    {
        "line": 69,
        "fullcodeline": "ret = -EINVAL;"
    },
    {
        "line": 87,
        "fullcodeline": "ret = PTR_ERR(handle);"
    },
    {
        "line": 93,
        "fullcodeline": "EXT4_I(inode)->i_disksize += len;"
    },
    {
        "line": 111,
        "fullcodeline": "ee_start_lblk = le32_to_cpu(extent->ee_block);"
    },
    {
        "line": 112,
        "fullcodeline": "ee_len = ext4_ext_get_actual_len(extent);"
    },
    {
        "line": 130,
        "fullcodeline": "ext4_ext_drop_refs(path);"
    },
    {
        "line": 139,
        "fullcodeline": "EXT_MAX_BLOCKS - offset_lblk);"
    },
    {
        "line": 155,
        "fullcodeline": "ext4_handle_sync(handle);"
    },
    {
        "line": 18,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 23,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 26,
        "fullcodeline": "return -EOPNOTSUPP;"
    },
    {
        "line": 132,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 150,
        "fullcodeline": "ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk,"
    },
    {
        "line": 153,
        "fullcodeline": "up_write(&EXT4_I(inode)->i_data_sem);"
    },
    {
        "line": 160,
        "fullcodeline": "up_write(&EXT4_I(inode)->i_mmap_sem);"
    },
    {
        "line": 118,
        "fullcodeline": "if ((offset_lblk > ee_start_lblk) &&"
    },
    {
        "line": 119,
        "fullcodeline": "(offset_lblk < (ee_start_lblk + ee_len))) {"
    },
    {
        "line": 123,
        "fullcodeline": "ret = ext4_split_extent_at(handle, inode, &path,"
    },
    {
        "line": 104,
        "fullcodeline": "up_write(&EXT4_I(inode)->i_data_sem);"
    },
    {
        "line": 141,
        "fullcodeline": "up_write(&EXT4_I(inode)->i_data_sem);"
    },
    {
        "line": 121,
        "fullcodeline": "split_flag = EXT4_EXT_MARK_UNWRIT1 |"
    },
    {
        "line": 125,
        "fullcodeline": "EXT4_EX_NOCACHE |"
    },
    {
        "line": 133,
        "fullcodeline": "up_write(&EXT4_I(inode)->i_data_sem);"
    }
]