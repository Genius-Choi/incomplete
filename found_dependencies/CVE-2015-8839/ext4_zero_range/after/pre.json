[
    {
        "line": 4,
        "fullcodeline": "struct inode *inode = file_inode(file);"
    },
    {
        "line": 5,
        "fullcodeline": "handle_t *handle = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "loff_t new_size = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "int ret = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "unsigned int blkbits = inode->i_blkbits;"
    },
    {
        "line": 16,
        "fullcodeline": "trace_ext4_zero_range(inode, offset, len, mode);"
    },
    {
        "line": 34,
        "fullcodeline": "start = round_up(offset, 1 << blkbits);"
    },
    {
        "line": 35,
        "fullcodeline": "end = round_down((offset + len), 1 << blkbits);"
    },
    {
        "line": 39,
        "fullcodeline": "partial_begin = offset & ((1 << blkbits) - 1);"
    },
    {
        "line": 40,
        "fullcodeline": "partial_end = (offset + len) & ((1 << blkbits) - 1);"
    },
    {
        "line": 42,
        "fullcodeline": "lblk = start >> blkbits;"
    },
    {
        "line": 43,
        "fullcodeline": "max_blocks = (end >> blkbits);"
    },
    {
        "line": 49,
        "fullcodeline": "mutex_lock(&inode->i_mutex);"
    },
    {
        "line": 67,
        "fullcodeline": "flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;"
    },
    {
        "line": 114,
        "fullcodeline": "credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;"
    },
    {
        "line": 117,
        "fullcodeline": "handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);"
    },
    {
        "line": 124,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 135,
        "fullcodeline": "ext4_mark_inode_dirty(handle, inode);"
    },
    {
        "line": 138,
        "fullcodeline": "ret = ext4_zero_partial_blocks(handle, inode, offset, len);"
    },
    {
        "line": 145,
        "fullcodeline": "ext4_inode_resume_unlocked_dio(inode);"
    },
    {
        "line": 18,
        "fullcodeline": "if (!S_ISREG(inode->i_mode))"
    },
    {
        "line": 22,
        "fullcodeline": "if (ext4_should_journal_data(inode)) {"
    },
    {
        "line": 44,
        "fullcodeline": "if (max_blocks < lblk)"
    },
    {
        "line": 68,
        "fullcodeline": "if (mode & FALLOC_FL_KEEP_SIZE)"
    },
    {
        "line": 72,
        "fullcodeline": "if (partial_begin || partial_end) {"
    },
    {
        "line": 84,
        "fullcodeline": "if (max_blocks > 0) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (ext4_should_journal_data(inode))"
    },
    {
        "line": 118,
        "fullcodeline": "if (IS_ERR(handle)) {"
    },
    {
        "line": 140,
        "fullcodeline": "if (file->f_flags & O_SYNC)"
    },
    {
        "line": 23,
        "fullcodeline": "ret = ext4_force_commit(inode->i_sb);"
    },
    {
        "line": 37,
        "fullcodeline": "if (start < offset || end > offset + len)"
    },
    {
        "line": 45,
        "fullcodeline": "max_blocks = 0;"
    },
    {
        "line": 54,
        "fullcodeline": "if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {"
    },
    {
        "line": 55,
        "fullcodeline": "ret = -EOPNOTSUPP;"
    },
    {
        "line": 59,
        "fullcodeline": "if (!(mode & FALLOC_FL_KEEP_SIZE) &&"
    },
    {
        "line": 60,
        "fullcodeline": "offset + len > i_size_read(inode)) {"
    },
    {
        "line": 61,
        "fullcodeline": "new_size = offset + len;"
    },
    {
        "line": 62,
        "fullcodeline": "ret = inode_newsize_ok(inode, new_size);"
    },
    {
        "line": 69,
        "fullcodeline": "flags |= EXT4_GET_BLOCKS_KEEP_SIZE;"
    },
    {
        "line": 73,
        "fullcodeline": "ret = ext4_alloc_file_blocks(file,"
    },
    {
        "line": 85,
        "fullcodeline": "flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |"
    },
    {
        "line": 89,
        "fullcodeline": "ext4_inode_block_unlocked_dio(inode);"
    },
    {
        "line": 90,
        "fullcodeline": "inode_dio_wait(inode);"
    },
    {
        "line": 96,
        "fullcodeline": "down_write(&EXT4_I(inode)->i_mmap_sem);"
    },
    {
        "line": 98,
        "fullcodeline": "truncate_pagecache_range(inode, start, end - 1);"
    },
    {
        "line": 99,
        "fullcodeline": "inode->i_mtime = inode->i_ctime = ext4_current_time(inode);"
    },
    {
        "line": 101,
        "fullcodeline": "ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,"
    },
    {
        "line": 107,
        "fullcodeline": "if (!partial_begin && !partial_end)"
    },
    {
        "line": 116,
        "fullcodeline": "credits += 2;"
    },
    {
        "line": 119,
        "fullcodeline": "ret = PTR_ERR(handle);"
    },
    {
        "line": 120,
        "fullcodeline": "ext4_std_error(inode->i_sb, ret);"
    },
    {
        "line": 126,
        "fullcodeline": "ext4_update_inode_size(inode, new_size);"
    },
    {
        "line": 141,
        "fullcodeline": "ext4_handle_sync(handle);"
    },
    {
        "line": 19,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 38,
        "fullcodeline": "return -EINVAL;"
    },
    {
        "line": 47,
        "fullcodeline": "max_blocks -= lblk;"
    },
    {
        "line": 74,
        "fullcodeline": "round_down(offset, 1 << blkbits) >> blkbits,"
    },
    {
        "line": 75,
        "fullcodeline": "(round_up((offset + len), 1 << blkbits) -"
    },
    {
        "line": 103,
        "fullcodeline": "up_write(&EXT4_I(inode)->i_mmap_sem);"
    },
    {
        "line": 132,
        "fullcodeline": "if ((offset + len) > i_size_read(inode))"
    },
    {
        "line": 133,
        "fullcodeline": "ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);"
    },
    {
        "line": 76,
        "fullcodeline": "round_down(offset, 1 << blkbits)) >> blkbits,"
    }
]