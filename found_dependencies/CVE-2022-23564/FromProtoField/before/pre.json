[
    {
        "line": 3,
        "fullcodeline": "CHECK_GT(n, 0);"
    },
    {
        "line": 4,
        "fullcodeline": "Buffer<Variant>* buf = new Buffer<Variant>(a, n);"
    },
    {
        "line": 5,
        "fullcodeline": "Variant* data = buf->template base<Variant>();"
    },
    {
        "line": 10,
        "fullcodeline": "const int64_t in_n = ProtoHelper<Variant>::NumElements(in);"
    },
    {
        "line": 6,
        "fullcodeline": "if (data == nullptr) {"
    },
    {
        "line": 11,
        "fullcodeline": "if (in_n <= 0) {"
    },
    {
        "line": 7,
        "fullcodeline": "buf->Unref();"
    },
    {
        "line": 18,
        "fullcodeline": "const int64_t real_n = n < in_n ? n : in_n;"
    },
    {
        "line": 19,
        "fullcodeline": "for (int64_t i = 0; i < real_n; ++i) {"
    },
    {
        "line": 30,
        "fullcodeline": "for (int64_t i = in_n; i < n; ++i) {"
    },
    {
        "line": 20,
        "fullcodeline": "data[i] = in.variant_val(i);"
    },
    {
        "line": 21,
        "fullcodeline": "if (!DecodeUnaryVariant(&data[i])) {"
    },
    {
        "line": 22,
        "fullcodeline": "LOG(ERROR) << \"Could not decode variant with type_name: \\\"\""
    },
    {
        "line": 23,
        "fullcodeline": "<< data[i].TypeName()"
    }
]