[
    {
        "line": 3,
        "fullcodeline": "register TIFFDirectory *td = &tif->tif_dir;"
    },
    {
        "line": 15,
        "fullcodeline": "bytecount = td->td_stripbytecount[0];"
    },
    {
        "line": 16,
        "fullcodeline": "offset = td->td_stripoffset[0];"
    },
    {
        "line": 17,
        "fullcodeline": "assert(td->td_planarconfig == PLANARCONFIG_CONTIG);"
    },
    {
        "line": 23,
        "fullcodeline": "rowblockbytes = TIFFVTileSize64(tif, rowblock);"
    },
    {
        "line": 45,
        "fullcodeline": "nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);"
    },
    {
        "line": 49,
        "fullcodeline": "newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),"
    },
    {
        "line": 51,
        "fullcodeline": "newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),"
    },
    {
        "line": 80,
        "fullcodeline": "TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);"
    },
    {
        "line": 18,
        "fullcodeline": "if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&"
    },
    {
        "line": 28,
        "fullcodeline": "if (rowblockbytes > STRIP_SIZE_DEFAULT) {"
    },
    {
        "line": 43,
        "fullcodeline": "if (rowsperstrip >= td->td_rowsperstrip)"
    },
    {
        "line": 46,
        "fullcodeline": "if( nstrips == 0 )"
    },
    {
        "line": 68,
        "fullcodeline": "for (strip = 0; strip < nstrips; strip++) {"
    },
    {
        "line": 79,
        "fullcodeline": "td->td_stripsperimage = td->td_nstrips = nstrips;"
    },
    {
        "line": 19,
        "fullcodeline": "(!isUpSampled(tif)))"
    },
    {
        "line": 20,
        "fullcodeline": "rowblock = td->td_ycbcrsubsampling[1];"
    },
    {
        "line": 29,
        "fullcodeline": "stripbytes = rowblockbytes;"
    },
    {
        "line": 30,
        "fullcodeline": "rowsperstrip = rowblock;"
    },
    {
        "line": 53,
        "fullcodeline": "if (newcounts == NULL || newoffsets == NULL) {"
    },
    {
        "line": 71,
        "fullcodeline": "newcounts[strip] = stripbytes;"
    },
    {
        "line": 72,
        "fullcodeline": "newoffsets[strip] = stripbytes ? offset : 0;"
    },
    {
        "line": 73,
        "fullcodeline": "offset += stripbytes;"
    },
    {
        "line": 74,
        "fullcodeline": "bytecount -= stripbytes;"
    },
    {
        "line": 22,
        "fullcodeline": "rowblock = 1;"
    },
    {
        "line": 58,
        "fullcodeline": "if (newcounts != NULL)"
    },
    {
        "line": 60,
        "fullcodeline": "if (newoffsets != NULL)"
    },
    {
        "line": 69,
        "fullcodeline": "if (stripbytes > bytecount)"
    },
    {
        "line": 31,
        "fullcodeline": "} else if (rowblockbytes > 0 ) {"
    },
    {
        "line": 70,
        "fullcodeline": "stripbytes = bytecount;"
    },
    {
        "line": 33,
        "fullcodeline": "rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);"
    },
    {
        "line": 34,
        "fullcodeline": "rowsperstrip = rowblocksperstrip * rowblock;"
    },
    {
        "line": 35,
        "fullcodeline": "stripbytes = rowblocksperstrip * rowblockbytes;"
    }
]