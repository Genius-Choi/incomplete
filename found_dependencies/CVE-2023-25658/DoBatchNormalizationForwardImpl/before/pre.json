[
    {
        "line": 15,
        "fullcodeline": "CudnnTensorDescriptor x_descriptor(x_desc, ToCudnnDataType(input_data_type));"
    },
    {
        "line": 16,
        "fullcodeline": "CudnnTensorDescriptor scale_offset_descriptor("
    },
    {
        "line": 18,
        "fullcodeline": "cudnnBatchNormMode_t mode = CUDNN_BATCHNORM_SPATIAL;"
    },
    {
        "line": 22,
        "fullcodeline": "float one = 1.0;"
    },
    {
        "line": 23,
        "fullcodeline": "float zero = 0.0;"
    },
    {
        "line": 24,
        "fullcodeline": "auto cudnn = cudnn_->GetHandle(parent_, stream);"
    },
    {
        "line": 26,
        "fullcodeline": "DeviceMemory<uint8_t> workspace;"
    },
    {
        "line": 27,
        "fullcodeline": "DeviceMemory<uint8_t> reserve_space;"
    },
    {
        "line": 65,
        "fullcodeline": "auto check_no_side_input_or_activation = [&]() -> tsl::Status {"
    },
    {
        "line": 17,
        "fullcodeline": "scale_offset_desc, ToCudnnDataType(scale_data_type));"
    },
    {
        "line": 19,
        "fullcodeline": "if (BatchnormSpatialPersistentEnabled() && is_training) {"
    },
    {
        "line": 146,
        "fullcodeline": "return ::tsl::OkStatus();"
    },
    {
        "line": 20,
        "fullcodeline": "mode = CUDNN_BATCHNORM_SPATIAL_PERSISTENT;"
    },
    {
        "line": 79,
        "fullcodeline": "CHECK_EQ(batch_mean->is_null(), batch_var->is_null())"
    },
    {
        "line": 96,
        "fullcodeline": "bool called = false;"
    },
    {
        "line": 84,
        "fullcodeline": "if (!batch_mean->is_null() && !batch_var->is_null()) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (!called) {"
    },
    {
        "line": 138,
        "fullcodeline": "const void* maybe_inv_var = estimated_variance.opaque();"
    },
    {
        "line": 139,
        "fullcodeline": "TF_RETURN_IF_ERROR(check_no_side_input_or_activation());"
    },
    {
        "line": 140,
        "fullcodeline": "RETURN_IF_CUDNN_ERROR(cudnnBatchNormalizationForwardInference("
    },
    {
        "line": 89,
        "fullcodeline": "batch_mean_opaque = batch_mean->opaque();"
    },
    {
        "line": 90,
        "fullcodeline": "batch_var_opaque = batch_var->opaque();"
    },
    {
        "line": 129,
        "fullcodeline": "TF_RETURN_IF_ERROR(check_no_side_input_or_activation());"
    },
    {
        "line": 130,
        "fullcodeline": "RETURN_IF_CUDNN_ERROR(cudnnBatchNormalizationForwardTraining("
    },
    {
        "line": 85,
        "fullcodeline": "if (exponential_average_factor == 1.0) {"
    },
    {
        "line": 92,
        "fullcodeline": "batch_mean_opaque = nullptr;"
    },
    {
        "line": 93,
        "fullcodeline": "batch_var_opaque = nullptr;"
    },
    {
        "line": 141,
        "fullcodeline": "cudnn.handle(), mode, &one, &zero, x_descriptor.handle(), x.opaque(),"
    },
    {
        "line": 142,
        "fullcodeline": "x_descriptor.handle(), y->opaque(), scale_offset_descriptor.handle(),"
    },
    {
        "line": 143,
        "fullcodeline": "scale.opaque(), offset.opaque(), estimated_mean.opaque(), maybe_inv_var,"
    },
    {
        "line": 86,
        "fullcodeline": "stream->ThenMemZero(batch_mean, batch_mean->size());"
    },
    {
        "line": 87,
        "fullcodeline": "stream->ThenMemZero(batch_var, batch_var->size());"
    },
    {
        "line": 131,
        "fullcodeline": "cudnn.handle(), mode, &one, &zero, x_descriptor.handle(), x.opaque(),"
    },
    {
        "line": 132,
        "fullcodeline": "x_descriptor.handle(), y->opaque(), scale_offset_descriptor.handle(),"
    },
    {
        "line": 133,
        "fullcodeline": "scale.opaque(), offset.opaque(), exponential_average_factor,"
    },
    {
        "line": 134,
        "fullcodeline": "batch_mean_opaque, batch_var_opaque, epsilon, saved_mean->opaque(),"
    },
    {
        "line": 135,
        "fullcodeline": "saved_inv_var->opaque()));"
    }
]