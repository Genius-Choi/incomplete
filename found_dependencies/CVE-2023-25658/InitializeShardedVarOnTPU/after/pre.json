[
    {
        "line": 5,
        "fullcodeline": "std::unique_ptr<Graph> init_graph(new Graph(OpRegistry::Global()));"
    },
    {
        "line": 6,
        "fullcodeline": "int num_cores = ndefs.size();"
    },
    {
        "line": 7,
        "fullcodeline": "string cpu_device = \"/device:CPU:0\";"
    },
    {
        "line": 17,
        "fullcodeline": "init_const_ndef.set_name(\"initial_value\");"
    },
    {
        "line": 18,
        "fullcodeline": "init_const_ndef.set_op(\"Const\");"
    },
    {
        "line": 19,
        "fullcodeline": "init_const_ndef.set_device(cpu_device);"
    },
    {
        "line": 20,
        "fullcodeline": "AddNodeAttr(\"dtype\", var->tensor()->dtype(), &init_const_ndef);"
    },
    {
        "line": 21,
        "fullcodeline": "AddNodeAttr(\"value\", *var->tensor(), &init_const_ndef);"
    },
    {
        "line": 22,
        "fullcodeline": "TF_ASSIGN_OR_RETURN(Node * init_const, init_graph->AddNode(init_const_ndef));"
    },
    {
        "line": 23,
        "fullcodeline": "init_const->set_assigned_device_name(cpu_device);"
    },
    {
        "line": 25,
        "fullcodeline": "Node* assign_value_node = init_const;"
    },
    {
        "line": 89,
        "fullcodeline": "session_options.env = ctx->env();"
    },
    {
        "line": 90,
        "fullcodeline": "optimization_options.session_handle = ctx->session_handle();"
    },
    {
        "line": 91,
        "fullcodeline": "optimization_options.session_options = &session_options;"
    },
    {
        "line": 92,
        "fullcodeline": "optimization_options.flib_def = flib_def_.get();"
    },
    {
        "line": 93,
        "fullcodeline": "optimization_options.graph = nullptr;"
    },
    {
        "line": 94,
        "fullcodeline": "optimization_options.device_set = nullptr;"
    },
    {
        "line": 96,
        "fullcodeline": "optimization_options.partition_graphs = &subgraphs;"
    },
    {
        "line": 97,
        "fullcodeline": "TF_RETURN_IF_ERROR(PartitionHelper(device_set_, optimization_options,"
    },
    {
        "line": 100,
        "fullcodeline": "std::vector<DeviceAndFHandle> functions;"
    },
    {
        "line": 101,
        "fullcodeline": "std::vector<std::string> function_names;"
    },
    {
        "line": 117,
        "fullcodeline": "FunctionLibraryRuntime::Options opts(ctx->step_id());"
    },
    {
        "line": 122,
        "fullcodeline": "std::function<void(std::function<void()>)> runner ="
    },
    {
        "line": 124,
        "fullcodeline": "opts.runner = &runner;"
    },
    {
        "line": 126,
        "fullcodeline": "opts.step_container = ctx->step_container();"
    },
    {
        "line": 127,
        "fullcodeline": "opts.cancellation_manager = ctx->cancellation_manager();"
    },
    {
        "line": 128,
        "fullcodeline": "opts.stats_collector = ctx->stats_collector();"
    },
    {
        "line": 129,
        "fullcodeline": "opts.source_device = local_device_name_;"
    },
    {
        "line": 130,
        "fullcodeline": "opts.run_all_kernels_inline = ctx->run_all_kernels_inline();"
    },
    {
        "line": 133,
        "fullcodeline": "TF_RETURN_IF_ERROR(ctx->input_list(\"args\", &arguments));"
    },
    {
        "line": 135,
        "fullcodeline": "PrivateIntraProcessRendezvous rendez(device_mgr_);"
    },
    {
        "line": 136,
        "fullcodeline": "opts.rendezvous = &rendez;"
    },
    {
        "line": 138,
        "fullcodeline": "BlockingCounter bcount(functions.size());"
    },
    {
        "line": 139,
        "fullcodeline": "std::vector<Status> statuses(functions.size());"
    },
    {
        "line": 159,
        "fullcodeline": "bcount.Wait();"
    },
    {
        "line": 165,
        "fullcodeline": "TF_RETURN_IF_ERROR(status_group.as_summary_status());"
    },
    {
        "line": 10,
        "fullcodeline": "for (int i = 0; i < num_cores; i++) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (split_dim >= 0) {"
    },
    {
        "line": 69,
        "fullcodeline": "for (int i = 0; i < num_cores; i++) {"
    },
    {
        "line": 140,
        "fullcodeline": "for (int i = 0; i < functions.size(); i++) {"
    },
    {
        "line": 167,
        "fullcodeline": "for (int i = 0; i < functions.size(); i++) {"
    },
    {
        "line": 171,
        "fullcodeline": "return OkStatus();"
    },
    {
        "line": 11,
        "fullcodeline": "TF_ASSIGN_OR_RETURN(Node * init_handle, init_graph->AddNode(ndefs[i]));"
    },
    {
        "line": 12,
        "fullcodeline": "init_handle->set_assigned_device_name(tpu_devices[i]);"
    },
    {
        "line": 13,
        "fullcodeline": "init_handles.push_back(init_handle);"
    },
    {
        "line": 36,
        "fullcodeline": "split_dim_def.set_name(\"initial_value_split_dim\");"
    },
    {
        "line": 37,
        "fullcodeline": "split_dim_def.set_op(\"Const\");"
    },
    {
        "line": 38,
        "fullcodeline": "split_dim_def.set_device(cpu_device);"
    },
    {
        "line": 39,
        "fullcodeline": "AddNodeAttr(\"dtype\", DT_INT32, &split_dim_def);"
    },
    {
        "line": 41,
        "fullcodeline": "tensor_proto.set_dtype(DT_INT32);"
    },
    {
        "line": 42,
        "fullcodeline": "tensor_proto.add_int_val(split_dim);"
    },
    {
        "line": 43,
        "fullcodeline": "TensorShape shape({});"
    },
    {
        "line": 44,
        "fullcodeline": "shape.AsProto(tensor_proto.mutable_tensor_shape());"
    },
    {
        "line": 45,
        "fullcodeline": "AddNodeAttr(\"value\", tensor_proto, &split_dim_def);"
    },
    {
        "line": 46,
        "fullcodeline": "TF_ASSIGN_OR_RETURN(Node * split_dim_node,"
    },
    {
        "line": 48,
        "fullcodeline": "split_dim_node->set_assigned_device_name(cpu_device);"
    },
    {
        "line": 52,
        "fullcodeline": "int split_num = ndefs.size();"
    },
    {
        "line": 53,
        "fullcodeline": "split_def.set_name(\"initial_value_split\");"
    },
    {
        "line": 54,
        "fullcodeline": "split_def.set_op(\"Split\");"
    },
    {
        "line": 55,
        "fullcodeline": "split_def.set_device(cpu_device);"
    },
    {
        "line": 56,
        "fullcodeline": "AddNodeAttr(\"num_split\", split_num, &split_def);"
    },
    {
        "line": 57,
        "fullcodeline": "AddNodeAttr(\"T\", var->tensor()->dtype(), &split_def);"
    },
    {
        "line": 58,
        "fullcodeline": "split_def.add_input(absl::StrCat(split_dim_node->name(), \":0\"));"
    },
    {
        "line": 59,
        "fullcodeline": "split_def.add_input(absl::StrCat(init_const->name(), \":0\"));"
    },
    {
        "line": 60,
        "fullcodeline": "TF_ASSIGN_OR_RETURN(Node * split_node, init_graph->AddNode(split_def));"
    },
    {
        "line": 61,
        "fullcodeline": "split_node->set_assigned_device_name(cpu_device);"
    },
    {
        "line": 63,
        "fullcodeline": "init_graph->AddEdge(split_dim_node, 0, split_node, 0);"
    },
    {
        "line": 64,
        "fullcodeline": "init_graph->AddEdge(init_const, 0, split_node, 1);"
    },
    {
        "line": 66,
        "fullcodeline": "assign_value_node = split_node;"
    },
    {
        "line": 71,
        "fullcodeline": "assign_node_def.set_name(absl::StrCat(\"Assign_\", i));"
    },
    {
        "line": 72,
        "fullcodeline": "assign_node_def.set_op(\"AssignVariableOp\");"
    },
    {
        "line": 73,
        "fullcodeline": "assign_node_def.set_device(tpu_devices[i]);"
    },
    {
        "line": 74,
        "fullcodeline": "AddNodeAttr(\"dtype\", var->tensor()->dtype(), &assign_node_def);"
    },
    {
        "line": 75,
        "fullcodeline": "TF_ASSIGN_OR_RETURN(Node * init_assign,"
    },
    {
        "line": 77,
        "fullcodeline": "init_assign->set_assigned_device_name(tpu_devices[i]);"
    },
    {
        "line": 79,
        "fullcodeline": "init_graph->AddEdge(init_handles[i], 0, init_assign, 0);"
    },
    {
        "line": 98,
        "fullcodeline": "init_graph.get(), &subgraphs));"
    },
    {
        "line": 103,
        "fullcodeline": "string target = pair.first;"
    },
    {
        "line": 105,
        "fullcodeline": "TF_RETURN_IF_ERROR("
    },
    {
        "line": 107,
        "fullcodeline": "Graph* subgraph = pair.second.get();"
    },
    {
        "line": 108,
        "fullcodeline": "string function_name = flib_def_->UniqueFunctionName("
    },
    {
        "line": 110,
        "fullcodeline": "function_names.push_back(function_name);"
    },
    {
        "line": 112,
        "fullcodeline": "TF_RETURN_IF_ERROR(InstantiatePartition(*subgraph, function_name, target,"
    },
    {
        "line": 114,
        "fullcodeline": "functions.push_back(DeviceAndFHandle{.device = target, .handle = handle});"
    },
    {
        "line": 141,
        "fullcodeline": "const DeviceAndFHandle& entry = functions[i];"
    },
    {
        "line": 142,
        "fullcodeline": "const string& target_device = entry.device;"
    },
    {
        "line": 143,
        "fullcodeline": "FHandle handle = entry.handle;"
    },
    {
        "line": 145,
        "fullcodeline": "TF_RETURN_IF_ERROR("
    },
    {
        "line": 147,
        "fullcodeline": "std::vector<Tensor> dummy_args;"
    },
    {
        "line": 148,
        "fullcodeline": "std::vector<Tensor>* dummy_rets = new std::vector<Tensor>;"
    },
    {
        "line": 150,
        "fullcodeline": "profiler::TraceMe trace_me("
    },
    {
        "line": 152,
        "fullcodeline": "library_runtime_->Run(opts, handle, dummy_args, dummy_rets,"
    },
    {
        "line": 163,
        "fullcodeline": "status_group.Update(status);"
    },
    {
        "line": 168,
        "fullcodeline": "TF_RETURN_IF_ERROR(flib_def_->RemoveFunction(function_names[i]));"
    },
    {
        "line": 169,
        "fullcodeline": "TF_RETURN_IF_ERROR(library_runtime_->ReleaseHandle(functions[i].handle));"
    },
    {
        "line": 47,
        "fullcodeline": "init_graph->AddNode(split_dim_def));"
    },
    {
        "line": 76,
        "fullcodeline": "init_graph->AddNode(assign_node_def));"
    },
    {
        "line": 80,
        "fullcodeline": "if (split_dim >= 0) {"
    },
    {
        "line": 106,
        "fullcodeline": "library_runtime_->device_mgr()->LookupDevice(target, &device));"
    },
    {
        "line": 146,
        "fullcodeline": "ShouldUseRemoteExecutionForFn(target_device, &(opts.remote_execution)));"
    },
    {
        "line": 81,
        "fullcodeline": "init_graph->AddEdge(assign_value_node, i, init_assign, 1);"
    },
    {
        "line": 109,
        "fullcodeline": "strings::StrCat(func_.name(), \"_hash_\", pair.first));"
    },
    {
        "line": 83,
        "fullcodeline": "init_graph->AddEdge(assign_value_node, 0, init_assign, 1);"
    }
]