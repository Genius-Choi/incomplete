[
    {
        "line": 8,
        "fullcodeline": "reader = xmlNewTextReaderFilename(path);"
    },
    {
        "line": 18,
        "fullcodeline": "rngvalidctx = xmlRelaxNGNewValidCtxt(schema);"
    },
    {
        "line": 24,
        "fullcodeline": "xmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,"
    },
    {
        "line": 33,
        "fullcodeline": "xmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,"
    },
    {
        "line": 9,
        "fullcodeline": "if (reader == NULL)"
    },
    {
        "line": 12,
        "fullcodeline": "error = xmlTextReaderRelaxNGSetSchema(reader, schema);"
    },
    {
        "line": 19,
        "fullcodeline": "if (rngvalidctx == NULL) {"
    },
    {
        "line": 27,
        "fullcodeline": "error = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);"
    },
    {
        "line": 14,
        "fullcodeline": "error = pr_val_err(\"Couldn't set Relax NG schema.\");"
    },
    {
        "line": 20,
        "fullcodeline": "error = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");"
    },
    {
        "line": 29,
        "fullcodeline": "error = pr_val_err(\"Invalid XML document\");"
    },
    {
        "line": 36,
        "fullcodeline": "while ((read = xmlTextReaderRead(reader)) == 1) {"
    },
    {
        "line": 42,
        "fullcodeline": "error = cb(reader, arg);"
    },
    {
        "line": 48,
        "fullcodeline": "error = pr_val_err(\"Error parsing XML document.\");"
    },
    {
        "line": 52,
        "fullcodeline": "if (xmlTextReaderIsValid(reader) <= 0) {"
    },
    {
        "line": 53,
        "fullcodeline": "error = pr_val_err(\"XML document isn't valid.\");"
    },
    {
        "line": 10,
        "fullcodeline": "return pr_val_err(\"Couldn't get XML '%s' file.\", path);"
    },
    {
        "line": 37,
        "fullcodeline": "if (xmlTextReaderIsValid(reader) <= 0) {"
    },
    {
        "line": 38,
        "fullcodeline": "error = pr_val_err(\"XML document isn't valid.\");"
    }
]