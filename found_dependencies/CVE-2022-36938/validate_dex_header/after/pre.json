[
    {
        "line": 4,
        "fullcodeline": "always_assert_log(sizeof(dex_header) <= dexsize,"
    },
    {
        "line": 8,
        "fullcodeline": "bool supported = false;"
    },
    {
        "line": 26,
        "fullcodeline": "always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\","
    },
    {
        "line": 28,
        "fullcodeline": "always_assert_log("
    },
    {
        "line": 34,
        "fullcodeline": "auto str_ids_off = (uint64_t)dh->string_ids_off;"
    },
    {
        "line": 35,
        "fullcodeline": "auto str_ids_limit ="
    },
    {
        "line": 37,
        "fullcodeline": "always_assert_log(str_ids_off < dexsize, \"string_ids_off out of range\");"
    },
    {
        "line": 38,
        "fullcodeline": "always_assert_log(str_ids_limit <= dexsize, \"invalid string_ids_size\");"
    },
    {
        "line": 40,
        "fullcodeline": "auto type_ids_off = (uint64_t)dh->type_ids_off;"
    },
    {
        "line": 41,
        "fullcodeline": "auto type_ids_limit = type_ids_off + dh->type_ids_size * sizeof(dex_type_id);"
    },
    {
        "line": 42,
        "fullcodeline": "always_assert_log(type_ids_off < dexsize, \"type_ids_off out of range\");"
    },
    {
        "line": 43,
        "fullcodeline": "always_assert_log(type_ids_limit <= dexsize, \"invalid type_ids_size\");"
    },
    {
        "line": 45,
        "fullcodeline": "auto proto_ids_off = (uint64_t)dh->proto_ids_off;"
    },
    {
        "line": 46,
        "fullcodeline": "auto proto_ids_limit ="
    },
    {
        "line": 48,
        "fullcodeline": "always_assert_log(proto_ids_off < dexsize, \"proto_ids_off out of range\");"
    },
    {
        "line": 49,
        "fullcodeline": "always_assert_log(proto_ids_limit <= dexsize, \"invalid proto_ids_size\");"
    },
    {
        "line": 51,
        "fullcodeline": "auto field_ids_off = (uint64_t)dh->field_ids_off;"
    },
    {
        "line": 52,
        "fullcodeline": "auto field_ids_limit ="
    },
    {
        "line": 54,
        "fullcodeline": "always_assert_log(field_ids_off < dexsize, \"field_ids_off out of range\");"
    },
    {
        "line": 55,
        "fullcodeline": "always_assert_log(field_ids_limit <= dexsize, \"invalid field_ids_size\");"
    },
    {
        "line": 57,
        "fullcodeline": "auto meth_ids_off = (uint64_t)dh->method_ids_off;"
    },
    {
        "line": 58,
        "fullcodeline": "auto meth_ids_limit ="
    },
    {
        "line": 60,
        "fullcodeline": "always_assert_log(meth_ids_off < dexsize, \"method_ids_off out of range\");"
    },
    {
        "line": 61,
        "fullcodeline": "always_assert_log(meth_ids_limit <= dexsize, \"invalid method_ids_size\");"
    },
    {
        "line": 63,
        "fullcodeline": "auto cls_defs_off = (uint64_t)dh->class_defs_off;"
    },
    {
        "line": 64,
        "fullcodeline": "auto cls_defs_limit ="
    },
    {
        "line": 66,
        "fullcodeline": "always_assert_log(cls_defs_off < dexsize, \"class_defs_off out of range\");"
    },
    {
        "line": 67,
        "fullcodeline": "always_assert_log(cls_defs_limit <= dexsize, \"invalid class_defs_size\");"
    },
    {
        "line": 7,
        "fullcodeline": "sizeof(dex_header));"
    },
    {
        "line": 29,
        "fullcodeline": "dh->file_size == dexsize,"
    },
    {
        "line": 36,
        "fullcodeline": "str_ids_off + dh->string_ids_size * sizeof(dex_string_id);"
    },
    {
        "line": 47,
        "fullcodeline": "proto_ids_off + dh->proto_ids_size * sizeof(dex_proto_id);"
    },
    {
        "line": 53,
        "fullcodeline": "field_ids_off + dh->field_ids_size * sizeof(dex_field_id);"
    },
    {
        "line": 59,
        "fullcodeline": "meth_ids_off + dh->method_ids_size * sizeof(dex_method_id);"
    },
    {
        "line": 65,
        "fullcodeline": "cls_defs_off + dh->class_defs_size * sizeof(dex_class_def);"
    },
    {
        "line": 11,
        "fullcodeline": "supported = supported ||"
    },
    {
        "line": 15,
        "fullcodeline": "supported = supported ||"
    },
    {
        "line": 19,
        "fullcodeline": "supported = supported ||"
    },
    {
        "line": 23,
        "fullcodeline": "not_reached_log(\"Unrecognized support_dex_version %d\\n\","
    },
    {
        "line": 12,
        "fullcodeline": "!memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));"
    },
    {
        "line": 16,
        "fullcodeline": "!memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));"
    },
    {
        "line": 20,
        "fullcodeline": "!memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));"
    }
]