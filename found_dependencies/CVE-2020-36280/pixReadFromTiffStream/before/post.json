[
    {
        "line": 14,
        "fullcodeline": "PROCNAME(\"pixReadFromTiffStream\");"
    },
    {
        "line": 19,
        "fullcodeline": "read_oriented = 0;"
    },
    {
        "line": 26,
        "fullcodeline": "TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);"
    },
    {
        "line": 49,
        "fullcodeline": "TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);"
    },
    {
        "line": 56,
        "fullcodeline": "TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);"
    },
    {
        "line": 57,
        "fullcodeline": "TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);"
    },
    {
        "line": 75,
        "fullcodeline": "TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);"
    },
    {
        "line": 76,
        "fullcodeline": "TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);"
    },
    {
        "line": 92,
        "fullcodeline": "tiffbpl = TIFFScanlineSize(tif);"
    },
    {
        "line": 93,
        "fullcodeline": "packedbpl = (bps * spp * w + 7) / 8;"
    },
    {
        "line": 94,
        "fullcodeline": "halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;"
    },
    {
        "line": 109,
        "fullcodeline": "pixSetInputFormat(pix, IFF_TIFF);"
    },
    {
        "line": 110,
        "fullcodeline": "data = (l_uint8 *)pixGetData(pix);"
    },
    {
        "line": 111,
        "fullcodeline": "wpl = pixGetWpl(pix);"
    },
    {
        "line": 112,
        "fullcodeline": "bpl = 4 * wpl;"
    },
    {
        "line": 196,
        "fullcodeline": "comptype = getTiffCompressedFormat(tiffcomp);"
    },
    {
        "line": 197,
        "fullcodeline": "pixSetInputFormat(pix, comptype);"
    },
    {
        "line": 260,
        "fullcodeline": "text = NULL;"
    },
    {
        "line": 261,
        "fullcodeline": "TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);"
    },
    {
        "line": 16,
        "fullcodeline": "if (!tif)"
    },
    {
        "line": 27,
        "fullcodeline": "if (sample_fmt != SAMPLEFORMAT_UINT) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (TIFFIsTiled(tif)) {"
    },
    {
        "line": 50,
        "fullcodeline": "if (tiffcomp == COMPRESSION_OJPEG) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {"
    },
    {
        "line": 62,
        "fullcodeline": "if (spp == 2 && bps != 8) {"
    },
    {
        "line": 66,
        "fullcodeline": "if (spp == 1)"
    },
    {
        "line": 77,
        "fullcodeline": "if (w > MaxTiffWidth) {"
    },
    {
        "line": 81,
        "fullcodeline": "if (h > MaxTiffHeight) {"
    },
    {
        "line": 100,
        "fullcodeline": "if (tiffbpl != packedbpl && !halfsize) {"
    },
    {
        "line": 107,
        "fullcodeline": "if ((pix = pixCreate(w, h, d)) == NULL)"
    },
    {
        "line": 114,
        "fullcodeline": "if (spp == 1) {"
    },
    {
        "line": 190,
        "fullcodeline": "if (getTiffStreamResolution(tif, &xres, &yres) == 0) {"
    },
    {
        "line": 199,
        "fullcodeline": "if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {"
    },
    {
        "line": 245,
        "fullcodeline": "if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {"
    },
    {
        "line": 28,
        "fullcodeline": "L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);"
    },
    {
        "line": 38,
        "fullcodeline": "L_ERROR(\"tiled format is not supported\\n\", procName);"
    },
    {
        "line": 51,
        "fullcodeline": "L_ERROR(\"old style jpeg format is not supported\\n\", procName);"
    },
    {
        "line": 59,
        "fullcodeline": "L_ERROR(\"invalid bps = %d\\n\", procName, bps);"
    },
    {
        "line": 63,
        "fullcodeline": "L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);"
    },
    {
        "line": 67,
        "fullcodeline": "d = bps;"
    },
    {
        "line": 78,
        "fullcodeline": "L_ERROR(\"width = %d pixels; too large\\n\", procName, w);"
    },
    {
        "line": 82,
        "fullcodeline": "L_ERROR(\"height = %d pixels; too large\\n\", procName, h);"
    },
    {
        "line": 101,
        "fullcodeline": "L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \""
    },
    {
        "line": 115,
        "fullcodeline": "linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));"
    },
    {
        "line": 129,
        "fullcodeline": "LEPT_FREE(linebuf);"
    },
    {
        "line": 191,
        "fullcodeline": "pixSetXRes(pix, xres);"
    },
    {
        "line": 192,
        "fullcodeline": "pixSetYRes(pix, yres);"
    },
    {
        "line": 212,
        "fullcodeline": "ncolors = 1 << bps;"
    },
    {
        "line": 262,
        "fullcodeline": "if (text) pixSetText(pix, text);"
    },
    {
        "line": 17,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);"
    },
    {
        "line": 108,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);"
    },
    {
        "line": 116,
        "fullcodeline": "for (i = 0; i < h; i++) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (bps <= 8)"
    },
    {
        "line": 204,
        "fullcodeline": "if (bps > 8) {"
    },
    {
        "line": 208,
        "fullcodeline": "if ((cmap = pixcmapCreate(bps)) == NULL) {"
    },
    {
        "line": 213,
        "fullcodeline": "for (i = 0; i < ncolors; i++)"
    },
    {
        "line": 214,
        "fullcodeline": "pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,"
    },
    {
        "line": 216,
        "fullcodeline": "if (pixSetColormap(pix, cmap)) {"
    },
    {
        "line": 222,
        "fullcodeline": "if (bps == 1) {"
    },
    {
        "line": 246,
        "fullcodeline": "if (orientation >= 1 && orientation <= 8) {"
    },
    {
        "line": 68,
        "fullcodeline": "else if (spp == 2)  /* gray plus alpha */"
    },
    {
        "line": 122,
        "fullcodeline": "memcpy(data, linebuf, tiffbpl);"
    },
    {
        "line": 123,
        "fullcodeline": "data += bpl;"
    },
    {
        "line": 126,
        "fullcodeline": "pixEndianByteSwap(pix);"
    },
    {
        "line": 130,
        "fullcodeline": "} else if (spp == 2 && bps == 8) {  /* gray plus alpha */"
    },
    {
        "line": 205,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 209,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 215,
        "fullcodeline": "bluemap[i] >> 8);"
    },
    {
        "line": 217,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 223,
        "fullcodeline": "pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);"
    },
    {
        "line": 224,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 225,
        "fullcodeline": "pix = pix1;"
    },
    {
        "line": 228,
        "fullcodeline": "if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {"
    },
    {
        "line": 240,
        "fullcodeline": "if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||"
    },
    {
        "line": 69,
        "fullcodeline": "d = 32;  /* will convert to RGBA */"
    },
    {
        "line": 117,
        "fullcodeline": "if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {"
    },
    {
        "line": 128,
        "fullcodeline": "pixEndianTwoByteSwap(pix);"
    },
    {
        "line": 131,
        "fullcodeline": "L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);"
    },
    {
        "line": 132,
        "fullcodeline": "pixSetSpp(pix, 4);"
    },
    {
        "line": 133,
        "fullcodeline": "linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));"
    },
    {
        "line": 134,
        "fullcodeline": "pixdata = pixGetData(pix);"
    },
    {
        "line": 152,
        "fullcodeline": "LEPT_FREE(linebuf);"
    },
    {
        "line": 206,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);"
    },
    {
        "line": 210,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);"
    },
    {
        "line": 218,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);"
    },
    {
        "line": 241,
        "fullcodeline": "(d == 8 && photometry == PHOTOMETRIC_MINISWHITE))"
    },
    {
        "line": 242,
        "fullcodeline": "pixInvert(pix, pix);"
    },
    {
        "line": 118,
        "fullcodeline": "LEPT_FREE(linebuf);"
    },
    {
        "line": 119,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 135,
        "fullcodeline": "for (i = 0; i < h; i++) {"
    },
    {
        "line": 170,
        "fullcodeline": "line = pixGetData(pix);"
    },
    {
        "line": 187,
        "fullcodeline": "LEPT_FREE(tiffdata);"
    },
    {
        "line": 231,
        "fullcodeline": "if (tiffcomp == COMPRESSION_CCITTFAX3 ||"
    },
    {
        "line": 250,
        "fullcodeline": "if (transform->vflip) pixFlipTB(pix, pix);"
    },
    {
        "line": 251,
        "fullcodeline": "if (transform->hflip) pixFlipLR(pix, pix);"
    },
    {
        "line": 253,
        "fullcodeline": "PIX *oldpix = pix;"
    },
    {
        "line": 254,
        "fullcodeline": "pix = pixRotate90(oldpix, transform->rotate);"
    },
    {
        "line": 255,
        "fullcodeline": "pixDestroy(&oldpix);"
    },
    {
        "line": 70,
        "fullcodeline": "else if (spp == 3 || spp == 4)"
    },
    {
        "line": 120,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);"
    },
    {
        "line": 141,
        "fullcodeline": "rowptr = linebuf;"
    },
    {
        "line": 142,
        "fullcodeline": "ppixel = pixdata + i * wpl;"
    },
    {
        "line": 154,
        "fullcodeline": "if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,"
    },
    {
        "line": 160,
        "fullcodeline": "if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,"
    },
    {
        "line": 169,
        "fullcodeline": "if (spp == 4) pixSetSpp(pix, 4);"
    },
    {
        "line": 171,
        "fullcodeline": "for (i = 0; i < h; i++, line += wpl) {"
    },
    {
        "line": 234,
        "fullcodeline": "tiffcomp == COMPRESSION_CCITTRLEW) {"
    },
    {
        "line": 235,
        "fullcodeline": "photometry = PHOTOMETRIC_MINISWHITE;"
    },
    {
        "line": 71,
        "fullcodeline": "d = 32;"
    },
    {
        "line": 136,
        "fullcodeline": "if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {"
    },
    {
        "line": 143,
        "fullcodeline": "for (j = k = 0; j < w; j++) {"
    },
    {
        "line": 156,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 162,
        "fullcodeline": "LEPT_FREE(tiffdata);"
    },
    {
        "line": 163,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 233,
        "fullcodeline": "tiffcomp == COMPRESSION_CCITTRLE ||"
    },
    {
        "line": 237,
        "fullcodeline": "photometry = PHOTOMETRIC_MINISBLACK;"
    },
    {
        "line": 248,
        "fullcodeline": "&tiff_partial_orientation_transforms[orientation - 1] :"
    },
    {
        "line": 249,
        "fullcodeline": "&tiff_orientation_transforms[orientation - 1];"
    },
    {
        "line": 137,
        "fullcodeline": "LEPT_FREE(linebuf);"
    },
    {
        "line": 138,
        "fullcodeline": "pixDestroy(&pix);"
    },
    {
        "line": 145,
        "fullcodeline": "SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);"
    },
    {
        "line": 146,
        "fullcodeline": "SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);"
    },
    {
        "line": 147,
        "fullcodeline": "SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);"
    },
    {
        "line": 148,
        "fullcodeline": "SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);"
    },
    {
        "line": 149,
        "fullcodeline": "ppixel++;"
    },
    {
        "line": 157,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);"
    },
    {
        "line": 164,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);"
    },
    {
        "line": 166,
        "fullcodeline": "read_oriented = 1;"
    },
    {
        "line": 172,
        "fullcodeline": "for (j = 0, ppixel = line; j < w; j++) {"
    },
    {
        "line": 232,
        "fullcodeline": "tiffcomp == COMPRESSION_CCITTFAX4 ||"
    },
    {
        "line": 73,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);"
    },
    {
        "line": 139,
        "fullcodeline": "return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);"
    },
    {
        "line": 174,
        "fullcodeline": "tiffword = tiffdata[i * w + j];"
    },
    {
        "line": 175,
        "fullcodeline": "rval = TIFFGetR(tiffword);"
    },
    {
        "line": 176,
        "fullcodeline": "gval = TIFFGetG(tiffword);"
    },
    {
        "line": 177,
        "fullcodeline": "bval = TIFFGetB(tiffword);"
    },
    {
        "line": 184,
        "fullcodeline": "ppixel++;"
    },
    {
        "line": 178,
        "fullcodeline": "if (spp == 3) {"
    },
    {
        "line": 179,
        "fullcodeline": "composeRGBPixel(rval, gval, bval, ppixel);"
    },
    {
        "line": 181,
        "fullcodeline": "aval = TIFFGetA(tiffword);"
    },
    {
        "line": 182,
        "fullcodeline": "composeRGBAPixel(rval, gval, bval, aval, ppixel);"
    }
]