[
    {
        "line": 2,
        "fullcodeline": "if @partial_part_left > 0"
    },
    {
        "line": 31,
        "fullcodeline": "while !io.eof?"
    },
    {
        "line": 25,
        "fullcodeline": "io = StringIO.new(chunk)"
    },
    {
        "line": 27,
        "fullcodeline": "io = StringIO.new(@prev_chunk+chunk)"
    },
    {
        "line": 28,
        "fullcodeline": "@prev_chunk = \"\""
    },
    {
        "line": 32,
        "fullcodeline": "line = io.gets"
    },
    {
        "line": 3,
        "fullcodeline": "if @partial_part_left <= chunk.size"
    },
    {
        "line": 33,
        "fullcodeline": "if line.end_with?(CHUNK_VALID_ENDING)"
    },
    {
        "line": 7,
        "fullcodeline": "chunk = chunk[@partial_part_left..-1]"
    },
    {
        "line": 8,
        "fullcodeline": "@partial_part_left = 0"
    },
    {
        "line": 19,
        "fullcodeline": "@partial_part_left -= chunk.size"
    },
    {
        "line": 36,
        "fullcodeline": "chunk_hex = line.strip[/\\A[^;]+/]"
    },
    {
        "line": 40,
        "fullcodeline": "len = chunk_hex.to_i(16)"
    },
    {
        "line": 64,
        "fullcodeline": "len += 2"
    },
    {
        "line": 66,
        "fullcodeline": "part = io.read(len)"
    },
    {
        "line": 73,
        "fullcodeline": "got = part.size"
    },
    {
        "line": 4,
        "fullcodeline": "if @partial_part_left > 2"
    },
    {
        "line": 10,
        "fullcodeline": "if @partial_part_left > 2"
    },
    {
        "line": 37,
        "fullcodeline": "if CHUNK_SIZE_INVALID.match? chunk_hex"
    },
    {
        "line": 41,
        "fullcodeline": "if len == 0"
    },
    {
        "line": 68,
        "fullcodeline": "unless part"
    },
    {
        "line": 5,
        "fullcodeline": "write_chunk(chunk[0..(@partial_part_left-3)]) # skip the \\r\\n"
    },
    {
        "line": 44,
        "fullcodeline": "rest = io.read"
    },
    {
        "line": 69,
        "fullcodeline": "@partial_part_left = len"
    },
    {
        "line": 76,
        "fullcodeline": "when got == len"
    },
    {
        "line": 11,
        "fullcodeline": "if @partial_part_left == chunk.size + 1"
    },
    {
        "line": 45,
        "fullcodeline": "if rest.bytesize < CHUNK_VALID_ENDING_SIZE"
    },
    {
        "line": 13,
        "fullcodeline": "write_chunk(chunk[0..(@partial_part_left-3)])"
    },
    {
        "line": 16,
        "fullcodeline": "write_chunk(chunk)"
    },
    {
        "line": 57,
        "fullcodeline": "@buffer = rest[start_of_rest..-1]"
    },
    {
        "line": 78,
        "fullcodeline": "if part.end_with? CHUNK_VALID_ENDING"
    },
    {
        "line": 83,
        "fullcodeline": "when got <= len - 2"
    },
    {
        "line": 47,
        "fullcodeline": "@partial_part_left = CHUNK_VALID_ENDING_SIZE - rest.bytesize"
    },
    {
        "line": 51,
        "fullcodeline": "start_of_rest = if rest.start_with?(CHUNK_VALID_ENDING)"
    },
    {
        "line": 79,
        "fullcodeline": "write_chunk(part[0..-3]) # to skip the ending \\r\\n"
    },
    {
        "line": 84,
        "fullcodeline": "write_chunk(part)"
    },
    {
        "line": 85,
        "fullcodeline": "@partial_part_left = len - part.size"
    },
    {
        "line": 52,
        "fullcodeline": "CHUNK_VALID_ENDING_SIZE"
    },
    {
        "line": 53,
        "fullcodeline": "else # we have started a trailer section, which we do not support. skip it!"
    },
    {
        "line": 86,
        "fullcodeline": "when got == len - 1 # edge where we get just \\r but not \\n"
    },
    {
        "line": 87,
        "fullcodeline": "write_chunk(part[0..-2])"
    },
    {
        "line": 88,
        "fullcodeline": "@partial_part_left = len - part.size"
    },
    {
        "line": 54,
        "fullcodeline": "rest.index(CHUNK_VALID_ENDING*2) + CHUNK_VALID_ENDING_SIZE*2"
    }
]