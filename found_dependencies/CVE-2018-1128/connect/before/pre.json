[
    {
        "line": 3,
        "fullcodeline": "bool got_bad_auth = false;"
    },
    {
        "line": 5,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect \" << connect_seq << dendl;"
    },
    {
        "line": 6,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 8,
        "fullcodeline": "__u32 cseq = connect_seq;"
    },
    {
        "line": 9,
        "fullcodeline": "__u32 gseq = msgr->get_global_seq();"
    },
    {
        "line": 12,
        "fullcodeline": "join_reader();"
    },
    {
        "line": 14,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 16,
        "fullcodeline": "char tag = -1;"
    },
    {
        "line": 17,
        "fullcodeline": "int rc = -1;"
    },
    {
        "line": 19,
        "fullcodeline": "struct iovec msgvec[2];"
    },
    {
        "line": 21,
        "fullcodeline": "char banner[strlen(CEPH_BANNER) + 1];  // extra byte makes coverity happy"
    },
    {
        "line": 24,
        "fullcodeline": "AuthAuthorizer *authorizer = NULL;"
    },
    {
        "line": 26,
        "fullcodeline": "const md_config_t *conf = msgr->cct->_conf;"
    },
    {
        "line": 33,
        "fullcodeline": "sd = ::socket(peer_addr.get_family(), SOCK_STREAM, 0);"
    },
    {
        "line": 40,
        "fullcodeline": "recv_reset();"
    },
    {
        "line": 42,
        "fullcodeline": "set_socket_options();"
    },
    {
        "line": 57,
        "fullcodeline": "ldout(msgr->cct,10) << \"connecting to \" << peer_addr << dendl;"
    },
    {
        "line": 58,
        "fullcodeline": "rc = ::connect(sd, peer_addr.get_sockaddr(), peer_addr.get_sockaddr_len());"
    },
    {
        "line": 72,
        "fullcodeline": "rc = tcp_read((char*)&banner, strlen(CEPH_BANNER));"
    },
    {
        "line": 82,
        "fullcodeline": "memset(&msg, 0, sizeof(msg));"
    },
    {
        "line": 83,
        "fullcodeline": "msgvec[0].iov_base = banner;"
    },
    {
        "line": 84,
        "fullcodeline": "msgvec[0].iov_len = strlen(CEPH_BANNER);"
    },
    {
        "line": 85,
        "fullcodeline": "msg.msg_iov = msgvec;"
    },
    {
        "line": 86,
        "fullcodeline": "msg.msg_iovlen = 1;"
    },
    {
        "line": 87,
        "fullcodeline": "msglen = msgvec[0].iov_len;"
    },
    {
        "line": 88,
        "fullcodeline": "rc = do_sendmsg(&msg, msglen);"
    },
    {
        "line": 104,
        "fullcodeline": "rc = tcp_read(addrbl.c_str(), addrbl.length());"
    },
    {
        "line": 119,
        "fullcodeline": "port = peer_addr_for_me.get_port();"
    },
    {
        "line": 121,
        "fullcodeline": "ldout(msgr->cct,20) << \"connect read peer addr \" << paddr << \" on socket \" << sd << dendl;"
    },
    {
        "line": 135,
        "fullcodeline": "ldout(msgr->cct,20) << \"connect peer addr for me is \" << peer_addr_for_me << dendl;"
    },
    {
        "line": 137,
        "fullcodeline": "msgr->learned_addr(peer_addr_for_me);"
    },
    {
        "line": 139,
        "fullcodeline": "::encode(msgr->my_inst.addr, myaddrbl, 0);  // legacy"
    },
    {
        "line": 141,
        "fullcodeline": "memset(&msg, 0, sizeof(msg));"
    },
    {
        "line": 142,
        "fullcodeline": "msgvec[0].iov_base = myaddrbl.c_str();"
    },
    {
        "line": 143,
        "fullcodeline": "msgvec[0].iov_len = myaddrbl.length();"
    },
    {
        "line": 144,
        "fullcodeline": "msg.msg_iov = msgvec;"
    },
    {
        "line": 145,
        "fullcodeline": "msg.msg_iovlen = 1;"
    },
    {
        "line": 146,
        "fullcodeline": "msglen = msgvec[0].iov_len;"
    },
    {
        "line": 147,
        "fullcodeline": "rc = do_sendmsg(&msg, msglen);"
    },
    {
        "line": 152,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect sent my addr \" << msgr->my_inst.addr << dendl;"
    },
    {
        "line": 29,
        "fullcodeline": "if (sd >= 0)"
    },
    {
        "line": 34,
        "fullcodeline": "if (sd < 0) {"
    },
    {
        "line": 45,
        "fullcodeline": "entity_addr_t addr2bind = msgr->get_myaddr();"
    },
    {
        "line": 59,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 77,
        "fullcodeline": "if (memcmp(banner, CEPH_BANNER, strlen(CEPH_BANNER))) {"
    },
    {
        "line": 89,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 99,
        "fullcodeline": "int wirelen = sizeof(__u32) * 2 + sizeof(ceph_sockaddr_storage);"
    },
    {
        "line": 100,
        "fullcodeline": "bufferptr p(wirelen * 2);"
    },
    {
        "line": 102,
        "fullcodeline": "addrbl.push_back(std::move(p));"
    },
    {
        "line": 105,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 122,
        "fullcodeline": "if (peer_addr != paddr) {"
    },
    {
        "line": 148,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 35,
        "fullcodeline": "rc = -errno;"
    },
    {
        "line": 36,
        "fullcodeline": "lderr(msgr->cct) << \"connect couldn't create socket \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 46,
        "fullcodeline": "if (msgr->cct->_conf->ms_bind_before_connect && (!addr2bind.is_blank_ip())) {"
    },
    {
        "line": 60,
        "fullcodeline": "int stored_errno = errno;"
    },
    {
        "line": 61,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect error \" << peer_addr"
    },
    {
        "line": 74,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect couldn't read banner, \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 78,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect protocol error (bad banner) on peer \" << peer_addr << dendl;"
    },
    {
        "line": 90,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect couldn't write my banner, \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 106,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect couldn't read peer addrs, \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 110,
        "fullcodeline": "bufferlist::iterator p = addrbl.begin();"
    },
    {
        "line": 111,
        "fullcodeline": "::decode(paddr, p);"
    },
    {
        "line": 112,
        "fullcodeline": "::decode(peer_addr_for_me, p);"
    },
    {
        "line": 149,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect couldn't write my addr, \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 157,
        "fullcodeline": "authorizer = msgr->get_authorizer(peer_type, false);"
    },
    {
        "line": 161,
        "fullcodeline": "connect.features = policy.features_supported;"
    },
    {
        "line": 162,
        "fullcodeline": "connect.host_type = msgr->get_myinst().name.type();"
    },
    {
        "line": 163,
        "fullcodeline": "connect.global_seq = gseq;"
    },
    {
        "line": 164,
        "fullcodeline": "connect.connect_seq = cseq;"
    },
    {
        "line": 165,
        "fullcodeline": "connect.protocol_version = msgr->get_proto_version(peer_type, true);"
    },
    {
        "line": 166,
        "fullcodeline": "connect.authorizer_protocol = authorizer ? authorizer->protocol : 0;"
    },
    {
        "line": 167,
        "fullcodeline": "connect.authorizer_len = authorizer ? authorizer->bl.length() : 0;"
    },
    {
        "line": 171,
        "fullcodeline": "connect.flags = 0;"
    },
    {
        "line": 174,
        "fullcodeline": "memset(&msg, 0, sizeof(msg));"
    },
    {
        "line": 175,
        "fullcodeline": "msgvec[0].iov_base = (char*)&connect;"
    },
    {
        "line": 176,
        "fullcodeline": "msgvec[0].iov_len = sizeof(connect);"
    },
    {
        "line": 177,
        "fullcodeline": "msg.msg_iov = msgvec;"
    },
    {
        "line": 178,
        "fullcodeline": "msg.msg_iovlen = 1;"
    },
    {
        "line": 179,
        "fullcodeline": "msglen = msgvec[0].iov_len;"
    },
    {
        "line": 187,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect sending gseq=\" << gseq << \" cseq=\" << cseq"
    },
    {
        "line": 189,
        "fullcodeline": "rc = do_sendmsg(&msg, msglen);"
    },
    {
        "line": 195,
        "fullcodeline": "ldout(msgr->cct,20) << \"connect wrote (self +) cseq, waiting for reply\" << dendl;"
    },
    {
        "line": 197,
        "fullcodeline": "rc = tcp_read((char*)&reply, sizeof(reply));"
    },
    {
        "line": 203,
        "fullcodeline": "ldout(msgr->cct,20) << \"connect got reply tag \" << (int)reply.tag"
    },
    {
        "line": 211,
        "fullcodeline": "authorizer_reply.clear();"
    },
    {
        "line": 239,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 370,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect got bad tag \" << (int)tag << dendl;"
    },
    {
        "line": 376,
        "fullcodeline": "ldout(msgr->cct, 10) << \" sleep for \" << msgr->cct->_conf->ms_inject_internal_delays << dendl;"
    },
    {
        "line": 378,
        "fullcodeline": "t.set_from_double(msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 47,
        "fullcodeline": "addr2bind.set_port(0);"
    },
    {
        "line": 48,
        "fullcodeline": "int r = ::bind(sd , addr2bind.get_sockaddr(), addr2bind.get_sockaddr_len());"
    },
    {
        "line": 63,
        "fullcodeline": "if (stored_errno == ECONNREFUSED) {"
    },
    {
        "line": 115,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect couldn't decode peer addrs: \" << e.what()"
    },
    {
        "line": 123,
        "fullcodeline": "if (paddr.is_blank_ip() &&"
    },
    {
        "line": 190,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 198,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 240,
        "fullcodeline": "if (state != STATE_CONNECTING) {"
    },
    {
        "line": 245,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_FEATURES) {"
    },
    {
        "line": 253,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_BADPROTOVER) {"
    },
    {
        "line": 259,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_BADAUTHORIZER) {"
    },
    {
        "line": 269,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_RESETSESSION) {"
    },
    {
        "line": 276,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_RETRY_GLOBAL) {"
    },
    {
        "line": 283,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_RETRY_SESSION) {"
    },
    {
        "line": 292,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_WAIT) {"
    },
    {
        "line": 298,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_READY ||"
    },
    {
        "line": 49,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 62,
        "fullcodeline": "<< \", \" << cpp_strerror(stored_errno) << dendl;"
    },
    {
        "line": 64,
        "fullcodeline": "ldout(msgr->cct, 2) << \"connection refused!\" << dendl;"
    },
    {
        "line": 125,
        "fullcodeline": "peer_addr.get_nonce() == paddr.get_nonce()) {"
    },
    {
        "line": 126,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect claims to be \""
    },
    {
        "line": 169,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect.authorizer_len=\" << connect.authorizer_len"
    },
    {
        "line": 173,
        "fullcodeline": "connect.flags |= CEPH_MSG_CONNECT_LOSSY;  // this is fyi, actually, server decides!"
    },
    {
        "line": 181,
        "fullcodeline": "msgvec[1].iov_base = authorizer->bl.c_str();"
    },
    {
        "line": 182,
        "fullcodeline": "msgvec[1].iov_len = authorizer->bl.length();"
    },
    {
        "line": 183,
        "fullcodeline": "msg.msg_iovlen++;"
    },
    {
        "line": 184,
        "fullcodeline": "msglen += msgvec[1].iov_len;"
    },
    {
        "line": 191,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect couldn't write gseq, cseq, \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 199,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect read reply \" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 214,
        "fullcodeline": "ldout(msgr->cct,10) << \"reply.authorizer_len=\" << reply.authorizer_len << dendl;"
    },
    {
        "line": 215,
        "fullcodeline": "bufferptr bp = buffer::create(reply.authorizer_len);"
    },
    {
        "line": 216,
        "fullcodeline": "rc = tcp_read(bp.c_str(), reply.authorizer_len);"
    },
    {
        "line": 221,
        "fullcodeline": "authorizer_reply.push_back(bp);"
    },
    {
        "line": 225,
        "fullcodeline": "bufferlist::iterator iter = authorizer_reply.begin();"
    },
    {
        "line": 233,
        "fullcodeline": "ldout(msgr->cct, 10) << \" sleep for \" << msgr->cct->_conf->ms_inject_internal_delays << dendl;"
    },
    {
        "line": 235,
        "fullcodeline": "t.set_from_double(msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 236,
        "fullcodeline": "t.sleep();"
    },
    {
        "line": 246,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect protocol feature mismatch, my \" << std::hex"
    },
    {
        "line": 254,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect protocol version mismatch, my \" << connect.protocol_version"
    },
    {
        "line": 260,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect got BADAUTHORIZER\" << dendl;"
    },
    {
        "line": 263,
        "fullcodeline": "got_bad_auth = true;"
    },
    {
        "line": 264,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 266,
        "fullcodeline": "authorizer = msgr->get_authorizer(peer_type, true);  // try harder"
    },
    {
        "line": 270,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect got RESETSESSION\" << dendl;"
    },
    {
        "line": 271,
        "fullcodeline": "was_session_reset();"
    },
    {
        "line": 272,
        "fullcodeline": "cseq = 0;"
    },
    {
        "line": 273,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 277,
        "fullcodeline": "gseq = msgr->get_global_seq(reply.global_seq);"
    },
    {
        "line": 278,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect got RETRY_GLOBAL \" << reply.global_seq"
    },
    {
        "line": 280,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 284,
        "fullcodeline": "assert(reply.connect_seq > connect_seq);"
    },
    {
        "line": 285,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect got RETRY_SESSION \" << connect_seq"
    },
    {
        "line": 287,
        "fullcodeline": "cseq = connect_seq = reply.connect_seq;"
    },
    {
        "line": 288,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 294,
        "fullcodeline": "state = STATE_WAIT;"
    },
    {
        "line": 299,
        "fullcodeline": "reply.tag == CEPH_MSGR_TAG_SEQ) {"
    },
    {
        "line": 300,
        "fullcodeline": "uint64_t feat_missing = policy.features_required & ~(uint64_t)reply.features;"
    },
    {
        "line": 332,
        "fullcodeline": "peer_global_seq = reply.global_seq;"
    },
    {
        "line": 333,
        "fullcodeline": "policy.lossy = reply.flags & CEPH_MSG_CONNECT_LOSSY;"
    },
    {
        "line": 334,
        "fullcodeline": "state = STATE_OPEN;"
    },
    {
        "line": 335,
        "fullcodeline": "connect_seq = cseq + 1;"
    },
    {
        "line": 336,
        "fullcodeline": "assert(connect_seq == reply.connect_seq);"
    },
    {
        "line": 337,
        "fullcodeline": "backoff = utime_t();"
    },
    {
        "line": 338,
        "fullcodeline": "connection_state->set_features((uint64_t)reply.features & (uint64_t)connect.features);"
    },
    {
        "line": 339,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect success \" << connect_seq << \", lossy = \" << policy.lossy"
    },
    {
        "line": 357,
        "fullcodeline": "msgr->dispatch_queue.queue_connect(connection_state.get());"
    },
    {
        "line": 358,
        "fullcodeline": "msgr->ms_deliver_handle_fast_connect(connection_state.get());"
    },
    {
        "line": 364,
        "fullcodeline": "maybe_start_delay_thread();"
    },
    {
        "line": 365,
        "fullcodeline": "delete authorizer;"
    },
    {
        "line": 387,
        "fullcodeline": "ldout(msgr->cct,3) << \"connect fault, but state = \" << get_state_name()"
    },
    {
        "line": 50,
        "fullcodeline": "ldout(msgr->cct,2) << \"client bind error \" << \", \" << cpp_strerror(errno) << dendl;"
    },
    {
        "line": 65,
        "fullcodeline": "msgr->dispatch_queue.queue_refused(connection_state.get());"
    },
    {
        "line": 124,
        "fullcodeline": "peer_addr.get_port() == paddr.get_port() &&"
    },
    {
        "line": 129,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect claims to be \""
    },
    {
        "line": 217,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 226,
        "fullcodeline": "if (!authorizer->verify_reply(iter)) {"
    },
    {
        "line": 241,
        "fullcodeline": "ldout(msgr->cct,0) << \"connect got RESETSESSION but no longer connecting\" << dendl;"
    },
    {
        "line": 293,
        "fullcodeline": "ldout(msgr->cct,3) << \"connect got WAIT (connection race)\" << dendl;"
    },
    {
        "line": 306,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_SEQ) {"
    },
    {
        "line": 346,
        "fullcodeline": "if (authorizer != NULL) {"
    },
    {
        "line": 360,
        "fullcodeline": "if (!reader_running) {"
    },
    {
        "line": 218,
        "fullcodeline": "ldout(msgr->cct,10) << \"connect couldn't read connect authorizer_reply\" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 227,
        "fullcodeline": "ldout(msgr->cct,0) << \"failed verifying authorize reply\" << dendl;"
    },
    {
        "line": 302,
        "fullcodeline": "ldout(msgr->cct,1) << \"missing required features \" << std::hex << feat_missing << std::dec << dendl;"
    },
    {
        "line": 307,
        "fullcodeline": "ldout(msgr->cct,10) << \"got CEPH_MSGR_TAG_SEQ, reading acked_seq and writing in_seq\" << dendl;"
    },
    {
        "line": 308,
        "fullcodeline": "uint64_t newly_acked_seq = 0;"
    },
    {
        "line": 309,
        "fullcodeline": "rc = tcp_read((char*)&newly_acked_seq, sizeof(newly_acked_seq));"
    },
    {
        "line": 314,
        "fullcodeline": "ldout(msgr->cct,2) << \" got newly_acked_seq \" << newly_acked_seq"
    },
    {
        "line": 340,
        "fullcodeline": "<< \", features \" << connection_state->get_features() << dendl;"
    },
    {
        "line": 347,
        "fullcodeline": "session_security.reset("
    },
    {
        "line": 361,
        "fullcodeline": "ldout(msgr->cct,20) << \"connect starting reader\" << dendl;"
    },
    {
        "line": 362,
        "fullcodeline": "start_reader();"
    },
    {
        "line": 248,
        "fullcodeline": "<< \" missing \" << (reply.features & ~policy.features_supported)"
    },
    {
        "line": 310,
        "fullcodeline": "if (rc < 0) {"
    },
    {
        "line": 316,
        "fullcodeline": "while (newly_acked_seq > out_seq) {"
    },
    {
        "line": 325,
        "fullcodeline": "if (tcp_write((char*)&in_seq, sizeof(in_seq)) < 0) {"
    },
    {
        "line": 348,
        "fullcodeline": "get_auth_session_handler(msgr->cct,"
    },
    {
        "line": 354,
        "fullcodeline": "session_security.reset();"
    },
    {
        "line": 311,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect read error on newly_acked_seq\" << cpp_strerror(rc) << dendl;"
    },
    {
        "line": 317,
        "fullcodeline": "Message *m = _get_next_outgoing();"
    },
    {
        "line": 318,
        "fullcodeline": "assert(m);"
    },
    {
        "line": 319,
        "fullcodeline": "ldout(msgr->cct,2) << \" discarding previously sent \" << m->get_seq()"
    },
    {
        "line": 321,
        "fullcodeline": "assert(m->get_seq() <= newly_acked_seq);"
    },
    {
        "line": 322,
        "fullcodeline": "m->put();"
    },
    {
        "line": 323,
        "fullcodeline": "++out_seq;"
    },
    {
        "line": 326,
        "fullcodeline": "ldout(msgr->cct,2) << \"connect write error on in_seq\" << dendl;"
    },
    {
        "line": 351,
        "fullcodeline": "connection_state->get_features()));"
    }
]