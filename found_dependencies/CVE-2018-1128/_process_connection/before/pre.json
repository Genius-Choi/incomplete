[
    {
        "line": 3,
        "fullcodeline": "ssize_t r = 0;"
    },
    {
        "line": 531,
        "fullcodeline": "ldout(async_msgr->cct, 10) << \"accept fault after register\" << dendl;"
    },
    {
        "line": 535,
        "fullcodeline": "return -1;"
    },
    {
        "line": 37,
        "fullcodeline": "opts.priority = async_msgr->get_socket_priority();"
    },
    {
        "line": 38,
        "fullcodeline": "opts.connect_bind_addr = msgr->get_myaddr();"
    },
    {
        "line": 39,
        "fullcodeline": "r = worker->connect(get_peer_addr(), opts, &cs);"
    },
    {
        "line": 44,
        "fullcodeline": "state = STATE_CONNECTING_RE;"
    },
    {
        "line": 50,
        "fullcodeline": "r = cs.is_connected();"
    },
    {
        "line": 66,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect successfully, ready to send banner\" << dendl;"
    },
    {
        "line": 69,
        "fullcodeline": "bl.append(CEPH_BANNER, strlen(CEPH_BANNER));"
    },
    {
        "line": 70,
        "fullcodeline": "r = try_send(bl);"
    },
    {
        "line": 91,
        "fullcodeline": "unsigned banner_len = strlen(CEPH_BANNER);"
    },
    {
        "line": 92,
        "fullcodeline": "unsigned need_len = banner_len + sizeof(ceph_entity_addr)*2;"
    },
    {
        "line": 93,
        "fullcodeline": "r = read_until(need_len, state_buffer);"
    },
    {
        "line": 108,
        "fullcodeline": "bl.append(state_buffer+banner_len, sizeof(ceph_entity_addr)*2);"
    },
    {
        "line": 109,
        "fullcodeline": "bufferlist::iterator p = bl.begin();"
    },
    {
        "line": 117,
        "fullcodeline": "ldout(async_msgr->cct, 20) << __func__ <<  \" connect read peer addr \""
    },
    {
        "line": 132,
        "fullcodeline": "ldout(async_msgr->cct, 20) << __func__ << \" connect peer addr for me is \" << peer_addr_for_me << dendl;"
    },
    {
        "line": 133,
        "fullcodeline": "lock.unlock();"
    },
    {
        "line": 134,
        "fullcodeline": "async_msgr->learned_addr(peer_addr_for_me);"
    },
    {
        "line": 146,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 153,
        "fullcodeline": "::encode(async_msgr->get_myaddr(), myaddrbl, 0); // legacy"
    },
    {
        "line": 154,
        "fullcodeline": "r = try_send(myaddrbl);"
    },
    {
        "line": 181,
        "fullcodeline": "connect_msg.features = policy.features_supported;"
    },
    {
        "line": 182,
        "fullcodeline": "connect_msg.host_type = async_msgr->get_myinst().name.type();"
    },
    {
        "line": 183,
        "fullcodeline": "connect_msg.global_seq = global_seq;"
    },
    {
        "line": 184,
        "fullcodeline": "connect_msg.connect_seq = connect_seq;"
    },
    {
        "line": 185,
        "fullcodeline": "connect_msg.protocol_version = async_msgr->get_proto_version(peer_type, true);"
    },
    {
        "line": 186,
        "fullcodeline": "connect_msg.authorizer_protocol = authorizer ? authorizer->protocol : 0;"
    },
    {
        "line": 187,
        "fullcodeline": "connect_msg.authorizer_len = authorizer ? authorizer->bl.length() : 0;"
    },
    {
        "line": 192,
        "fullcodeline": "connect_msg.flags = 0;"
    },
    {
        "line": 195,
        "fullcodeline": "bl.append((char*)&connect_msg, sizeof(connect_msg));"
    },
    {
        "line": 199,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect sending gseq=\" << global_seq << \" cseq=\""
    },
    {
        "line": 202,
        "fullcodeline": "r = try_send(bl);"
    },
    {
        "line": 221,
        "fullcodeline": "r = read_until(sizeof(connect_reply), state_buffer);"
    },
    {
        "line": 229,
        "fullcodeline": "connect_reply = *((ceph_msg_connect_reply*)state_buffer);"
    },
    {
        "line": 262,
        "fullcodeline": "r = handle_connect_reply(connect_msg, connect_reply);"
    },
    {
        "line": 275,
        "fullcodeline": "r = read_until(sizeof(newly_acked_seq), state_buffer);"
    },
    {
        "line": 283,
        "fullcodeline": "newly_acked_seq = *((uint64_t*)state_buffer);"
    },
    {
        "line": 284,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" got newly_acked_seq \" << newly_acked_seq"
    },
    {
        "line": 298,
        "fullcodeline": "uint64_t s = in_seq;"
    },
    {
        "line": 299,
        "fullcodeline": "bl.append((char*)&s, sizeof(s));"
    },
    {
        "line": 300,
        "fullcodeline": "r = try_send(bl);"
    },
    {
        "line": 317,
        "fullcodeline": "peer_global_seq = connect_reply.global_seq;"
    },
    {
        "line": 318,
        "fullcodeline": "policy.lossy = connect_reply.flags & CEPH_MSG_CONNECT_LOSSY;"
    },
    {
        "line": 320,
        "fullcodeline": "once_ready = true;"
    },
    {
        "line": 321,
        "fullcodeline": "connect_seq += 1;"
    },
    {
        "line": 323,
        "fullcodeline": "backoff = utime_t();"
    },
    {
        "line": 344,
        "fullcodeline": "dispatch_queue->queue_connect(this);"
    },
    {
        "line": 354,
        "fullcodeline": "write_lock.lock();"
    },
    {
        "line": 368,
        "fullcodeline": "bl.append(CEPH_BANNER, strlen(CEPH_BANNER));"
    },
    {
        "line": 370,
        "fullcodeline": "::encode(async_msgr->get_myaddr(), bl, 0); // legacy"
    },
    {
        "line": 372,
        "fullcodeline": "::encode(socket_addr, bl, 0); // legacy"
    },
    {
        "line": 373,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" sd=\" << cs.fd() << \" \" << socket_addr << dendl;"
    },
    {
        "line": 375,
        "fullcodeline": "r = try_send(bl);"
    },
    {
        "line": 396,
        "fullcodeline": "r = read_until(strlen(CEPH_BANNER) + sizeof(ceph_entity_addr), state_buffer);"
    },
    {
        "line": 410,
        "fullcodeline": "addr_bl.append(state_buffer+strlen(CEPH_BANNER), sizeof(ceph_entity_addr));"
    },
    {
        "line": 416,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept peer addr is \" << peer_addr << dendl;"
    },
    {
        "line": 426,
        "fullcodeline": "state = STATE_ACCEPTING_WAIT_CONNECT_MSG;"
    },
    {
        "line": 432,
        "fullcodeline": "r = read_until(sizeof(connect_msg), state_buffer);"
    },
    {
        "line": 462,
        "fullcodeline": "ldout(async_msgr->cct, 20) << __func__ << \" accept got peer connect_seq \""
    },
    {
        "line": 465,
        "fullcodeline": "set_peer_type(connect_msg.host_type);"
    },
    {
        "line": 466,
        "fullcodeline": "policy = async_msgr->get_policy(connect_msg.host_type);"
    },
    {
        "line": 472,
        "fullcodeline": "r = handle_connect_msg(connect_msg, authorizer_buf, authorizer_reply);"
    },
    {
        "line": 484,
        "fullcodeline": "r = read_until(sizeof(newly_acked_seq), state_buffer);"
    },
    {
        "line": 492,
        "fullcodeline": "newly_acked_seq = *((uint64_t*)state_buffer);"
    },
    {
        "line": 495,
        "fullcodeline": "state = STATE_ACCEPTING_READY;"
    },
    {
        "line": 512,
        "fullcodeline": "write_lock.lock();"
    },
    {
        "line": 8,
        "fullcodeline": "std::lock_guard<std::mutex> l(write_lock);"
    },
    {
        "line": 19,
        "fullcodeline": "assert(!policy.server);"
    },
    {
        "line": 29,
        "fullcodeline": "global_seq = async_msgr->get_global_seq();"
    },
    {
        "line": 43,
        "fullcodeline": "center->create_file_event(cs.fd(), EVENT_READABLE, read_handler);"
    },
    {
        "line": 51,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 65,
        "fullcodeline": "center->delete_file_event(cs.fd(), EVENT_WRITABLE);"
    },
    {
        "line": 71,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 101,
        "fullcodeline": "if (memcmp(state_buffer, CEPH_BANNER, banner_len)) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (peer_addr != paddr) {"
    },
    {
        "line": 135,
        "fullcodeline": "if (async_msgr->cct->_conf->ms_inject_internal_delays"
    },
    {
        "line": 147,
        "fullcodeline": "if (state != STATE_CONNECTING_WAIT_BANNER_AND_IDENTIFY) {"
    },
    {
        "line": 155,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 203,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 222,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 231,
        "fullcodeline": "ldout(async_msgr->cct, 20) << __func__ << \" connect got reply tag \" << (int)connect_reply.tag"
    },
    {
        "line": 267,
        "fullcodeline": "assert(state != STATE_CONNECTING_WAIT_CONNECT_REPLY_AUTH);"
    },
    {
        "line": 276,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 301,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 322,
        "fullcodeline": "assert(connect_seq == connect_reply.connect_seq);"
    },
    {
        "line": 324,
        "fullcodeline": "set_features((uint64_t)connect_reply.features & (uint64_t)connect_msg.features);"
    },
    {
        "line": 325,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect success \" << connect_seq"
    },
    {
        "line": 331,
        "fullcodeline": "if (authorizer != NULL) {"
    },
    {
        "line": 350,
        "fullcodeline": "last_tick_id = center->create_time_event(inactive_timeout_us, tick_handler);"
    },
    {
        "line": 366,
        "fullcodeline": "center->create_file_event(cs.fd(), EVENT_READABLE, read_handler);"
    },
    {
        "line": 371,
        "fullcodeline": "port = async_msgr->get_myaddr().get_port();"
    },
    {
        "line": 376,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 397,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 404,
        "fullcodeline": "if (memcmp(state_buffer, CEPH_BANNER, strlen(CEPH_BANNER))) {"
    },
    {
        "line": 412,
        "fullcodeline": "bufferlist::iterator ti = addr_bl.begin();"
    },
    {
        "line": 413,
        "fullcodeline": "::decode(peer_addr, ti);"
    },
    {
        "line": 417,
        "fullcodeline": "if (peer_addr.is_blank_ip()) {"
    },
    {
        "line": 433,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 467,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept of host_type \" << connect_msg.host_type"
    },
    {
        "line": 477,
        "fullcodeline": "assert(state != STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH);"
    },
    {
        "line": 485,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 493,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" accept get newly_acked_seq \" << newly_acked_seq << dendl;"
    },
    {
        "line": 501,
        "fullcodeline": "ldout(async_msgr->cct, 20) << __func__ << \" accept done\" << dendl;"
    },
    {
        "line": 510,
        "fullcodeline": "last_tick_id = center->create_time_event(inactive_timeout_us, tick_handler);"
    },
    {
        "line": 523,
        "fullcodeline": "lderr(async_msgr->cct) << __func__ << \" bad state: \" << state << dendl;"
    },
    {
        "line": 9,
        "fullcodeline": "if (!outcoming_bl.length()) {"
    },
    {
        "line": 12,
        "fullcodeline": "state_after_send = STATE_NONE;"
    },
    {
        "line": 32,
        "fullcodeline": "center->delete_file_event(cs.fd(), EVENT_READABLE|EVENT_WRITABLE);"
    },
    {
        "line": 33,
        "fullcodeline": "cs.close();"
    },
    {
        "line": 52,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" reconnect failed \" << dendl;"
    },
    {
        "line": 111,
        "fullcodeline": "::decode(paddr, p);"
    },
    {
        "line": 112,
        "fullcodeline": "::decode(peer_addr_for_me, p);"
    },
    {
        "line": 118,
        "fullcodeline": "<< paddr << \" on socket \" << cs.fd() << dendl;"
    },
    {
        "line": 148,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" state changed while learned_addr, mark_down or \""
    },
    {
        "line": 177,
        "fullcodeline": "authorizer = async_msgr->get_authorizer(peer_type, false);"
    },
    {
        "line": 189,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ <<  \" connect_msg.authorizer_len=\""
    },
    {
        "line": 194,
        "fullcodeline": "connect_msg.flags |= CEPH_MSG_CONNECT_LOSSY;  // this is fyi, actually, server decides!"
    },
    {
        "line": 197,
        "fullcodeline": "bl.append(authorizer->bl.c_str(), authorizer->bl.length());"
    },
    {
        "line": 245,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" reply.authorizer_len=\" << connect_reply.authorizer_len << dendl;"
    },
    {
        "line": 247,
        "fullcodeline": "r = read_until(connect_reply.authorizer_len, state_buffer);"
    },
    {
        "line": 255,
        "fullcodeline": "authorizer_reply.append(state_buffer, connect_reply.authorizer_len);"
    },
    {
        "line": 256,
        "fullcodeline": "bufferlist::iterator iter = authorizer_reply.begin();"
    },
    {
        "line": 349,
        "fullcodeline": "center->delete_time_event(last_tick_id);"
    },
    {
        "line": 419,
        "fullcodeline": "int port = peer_addr.get_port();"
    },
    {
        "line": 420,
        "fullcodeline": "peer_addr.u = socket_addr.u;"
    },
    {
        "line": 421,
        "fullcodeline": "peer_addr.set_port(port);"
    },
    {
        "line": 453,
        "fullcodeline": "r = read_until(connect_msg.authorizer_len, authorizer_buf.c_str());"
    },
    {
        "line": 486,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read ack seq failed\" << dendl;"
    },
    {
        "line": 509,
        "fullcodeline": "center->delete_time_event(last_tick_id);"
    },
    {
        "line": 73,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect write banner done: \""
    },
    {
        "line": 95,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read banner and identify addresses failed\" << dendl;"
    },
    {
        "line": 102,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" connect protocol error (bad banner) on peer \""
    },
    {
        "line": 120,
        "fullcodeline": "if (paddr.is_blank_ip() && peer_addr.get_port() == paddr.get_port() &&"
    },
    {
        "line": 137,
        "fullcodeline": "if (rand() % async_msgr->cct->_conf->ms_inject_socket_failures == 0) {"
    },
    {
        "line": 157,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect sent my addr \""
    },
    {
        "line": 205,
        "fullcodeline": "ldout(async_msgr->cct,20) << __func__ << \" connect wrote (self +) cseq, waiting for reply\" << dendl;"
    },
    {
        "line": 223,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read connect reply failed\" << dendl;"
    },
    {
        "line": 246,
        "fullcodeline": "assert(connect_reply.authorizer_len < 4096);"
    },
    {
        "line": 248,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 277,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read connect ack seq failed\" << dendl;"
    },
    {
        "line": 303,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" send in_seq done \" << dendl;"
    },
    {
        "line": 333,
        "fullcodeline": "get_auth_session_handler(async_msgr->cct,"
    },
    {
        "line": 343,
        "fullcodeline": "assert(delay_state->ready());"
    },
    {
        "line": 378,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" write banner and addr done: \""
    },
    {
        "line": 398,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read peer banner and addr failed\" << dendl;"
    },
    {
        "line": 405,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" accept peer sent bad banner '\" << state_buffer"
    },
    {
        "line": 422,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept peer addr is really \" << peer_addr"
    },
    {
        "line": 434,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read connect msg failed\" << dendl;"
    },
    {
        "line": 454,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 506,
        "fullcodeline": "assert(delay_state->ready());"
    },
    {
        "line": 53,
        "fullcodeline": "if (r == -ECONNREFUSED) {"
    },
    {
        "line": 97,
        "fullcodeline": "} else if (r > 0) {"
    },
    {
        "line": 114,
        "fullcodeline": "lderr(async_msgr->cct) << __func__ <<  \" decode peer addr failed \" << dendl;"
    },
    {
        "line": 121,
        "fullcodeline": "peer_addr.get_nonce() == paddr.get_nonce()) {"
    },
    {
        "line": 122,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ <<  \" connect claims to be \" << paddr"
    },
    {
        "line": 138,
        "fullcodeline": "ldout(msgr->cct, 10) << __func__ << \" sleep for \""
    },
    {
        "line": 141,
        "fullcodeline": "t.set_from_double(async_msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 142,
        "fullcodeline": "t.sleep();"
    },
    {
        "line": 158,
        "fullcodeline": "<< async_msgr->get_myaddr() << dendl;"
    },
    {
        "line": 159,
        "fullcodeline": "} else if (r > 0) {"
    },
    {
        "line": 206,
        "fullcodeline": "} else if (r > 0) {"
    },
    {
        "line": 257,
        "fullcodeline": "if (authorizer && !authorizer->verify_reply(iter)) {"
    },
    {
        "line": 450,
        "fullcodeline": "if (!authorizer_buf.length())"
    },
    {
        "line": 451,
        "fullcodeline": "authorizer_buf.push_back(buffer::create(connect_msg.authorizer_len));"
    },
    {
        "line": 54,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" connection refused!\" << dendl;"
    },
    {
        "line": 249,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read connect reply authorizer failed\" << dendl;"
    },
    {
        "line": 258,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" failed verifying authorize reply\" << dendl;"
    },
    {
        "line": 455,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" read connect authorizer failed\" << dendl;"
    },
    {
        "line": 59,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" nonblock connect inprogress\" << dendl;"
    },
    {
        "line": 78,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect wait for write banner: \""
    },
    {
        "line": 126,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect claims to be \""
    },
    {
        "line": 162,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" connect send my addr done: \""
    },
    {
        "line": 209,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" continue send reply \" << dendl;"
    },
    {
        "line": 307,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" continue send in_seq \" << dendl;"
    },
    {
        "line": 383,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" wait for write banner and addr: \""
    },
    {
        "line": 60,
        "fullcodeline": "if (async_msgr->get_stack()->nonblock_connect_need_writable_event())"
    },
    {
        "line": 163,
        "fullcodeline": "<< async_msgr->get_myaddr() << dendl;"
    },
    {
        "line": 165,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" connect couldn't write my addr, \""
    },
    {
        "line": 211,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" connect couldn't send reply \""
    },
    {
        "line": 61,
        "fullcodeline": "center->create_file_event(cs.fd(), EVENT_WRITABLE, read_handler);"
    },
    {
        "line": 166,
        "fullcodeline": "<< cpp_strerror(r) << dendl;"
    },
    {
        "line": 212,
        "fullcodeline": "<< cpp_strerror(r) << dendl;"
    }
]