[
    {
        "line": 4,
        "fullcodeline": "ssize_t r = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "memset(&reply, 0, sizeof(reply));"
    },
    {
        "line": 9,
        "fullcodeline": "reply.protocol_version = async_msgr->get_proto_version(peer_type, false);"
    },
    {
        "line": 12,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept my proto \" << reply.protocol_version"
    },
    {
        "line": 46,
        "fullcodeline": "uint64_t feat_missing = policy.features_required & ~(uint64_t)connect.features;"
    },
    {
        "line": 53,
        "fullcodeline": "lock.unlock();"
    },
    {
        "line": 65,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept setting up session_security.\" << dendl;"
    },
    {
        "line": 68,
        "fullcodeline": "AsyncConnectionRef existing = async_msgr->lookup_conn(peer_addr);"
    },
    {
        "line": 70,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 72,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 210,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept replacing \" << existing << dendl;"
    },
    {
        "line": 212,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 316,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 319,
        "fullcodeline": "connect_seq = connect.connect_seq + 1;"
    },
    {
        "line": 320,
        "fullcodeline": "peer_global_seq = connect.global_seq;"
    },
    {
        "line": 321,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept success, connect_seq = \""
    },
    {
        "line": 340,
        "fullcodeline": "reply.global_seq = async_msgr->get_global_seq();"
    },
    {
        "line": 341,
        "fullcodeline": "reply.connect_seq = connect_seq;"
    },
    {
        "line": 342,
        "fullcodeline": "reply.flags = 0;"
    },
    {
        "line": 343,
        "fullcodeline": "reply.authorizer_len = authorizer_reply.length();"
    },
    {
        "line": 347,
        "fullcodeline": "set_features((uint64_t)reply.features & (uint64_t)connect.features);"
    },
    {
        "line": 348,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept features \" << get_features() << dendl;"
    },
    {
        "line": 350,
        "fullcodeline": "session_security.reset("
    },
    {
        "line": 354,
        "fullcodeline": "reply_bl.append((char*)&reply, sizeof(reply));"
    },
    {
        "line": 364,
        "fullcodeline": "lock.unlock();"
    },
    {
        "line": 367,
        "fullcodeline": "r = async_msgr->accept_conn(this);"
    },
    {
        "line": 369,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 371,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 372,
        "fullcodeline": "replacing = false;"
    },
    {
        "line": 384,
        "fullcodeline": "r = try_send(reply_bl);"
    },
    {
        "line": 389,
        "fullcodeline": "dispatch_queue->queue_accept(this);"
    },
    {
        "line": 390,
        "fullcodeline": "async_msgr->ms_deliver_handle_fast_accept(this);"
    },
    {
        "line": 391,
        "fullcodeline": "once_ready = true;"
    },
    {
        "line": 404,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept fault after register\" << dendl;"
    },
    {
        "line": 405,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 408,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" failed to accept.\" << dendl;"
    },
    {
        "line": 14,
        "fullcodeline": "if (connect.protocol_version != reply.protocol_version) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (connect.authorizer_protocol == CEPH_AUTH_CEPHX) {"
    },
    {
        "line": 56,
        "fullcodeline": "if (!async_msgr->verify_authorizer(this, peer_type, connect.authorizer_protocol, authorizer_bl,"
    },
    {
        "line": 73,
        "fullcodeline": "if (state != STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (existing == this)"
    },
    {
        "line": 327,
        "fullcodeline": "if ((connect.features & CEPH_FEATURE_RECONNECT_SEQ) && !is_reset_from_peer) {"
    },
    {
        "line": 351,
        "fullcodeline": "get_auth_session_handler(async_msgr->cct, connect.authorizer_protocol,"
    },
    {
        "line": 359,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_SEQ) {"
    },
    {
        "line": 373,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 378,
        "fullcodeline": "if (state != STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH) {"
    },
    {
        "line": 385,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 393,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 409,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" peer missing required features \""
    },
    {
        "line": 57,
        "fullcodeline": "authorizer_reply, authorizer_valid, session_key) || !authorizer_valid) {"
    },
    {
        "line": 58,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 59,
        "fullcodeline": "ldout(async_msgr->cct,0) << __func__ << \": got bad authorizer\" << dendl;"
    },
    {
        "line": 60,
        "fullcodeline": "session_security.reset();"
    },
    {
        "line": 74,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" state changed while accept, it must be mark_down\" << dendl;"
    },
    {
        "line": 75,
        "fullcodeline": "assert(state == STATE_CLOSED);"
    },
    {
        "line": 80,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 84,
        "fullcodeline": "existing->lock.lock();  // skip lockdep check (we are locking a second AsyncConnection here)"
    },
    {
        "line": 124,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept connect_seq \" << connect.connect_seq"
    },
    {
        "line": 180,
        "fullcodeline": "assert(connect.connect_seq > existing->connect_seq);"
    },
    {
        "line": 181,
        "fullcodeline": "assert(connect.global_seq >= existing->peer_global_seq);"
    },
    {
        "line": 192,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept peer sent cseq \" << connect.connect_seq"
    },
    {
        "line": 215,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" replacing on lossy channel, failing existing\" << dendl;"
    },
    {
        "line": 216,
        "fullcodeline": "existing->_stop();"
    },
    {
        "line": 217,
        "fullcodeline": "existing->dispatch_queue->queue_reset(existing.get());"
    },
    {
        "line": 328,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_SEQ;"
    },
    {
        "line": 329,
        "fullcodeline": "next_state = STATE_ACCEPTING_WAIT_SEQ;"
    },
    {
        "line": 345,
        "fullcodeline": "reply.flags = reply.flags | CEPH_MSG_CONNECT_LOSSY;"
    },
    {
        "line": 357,
        "fullcodeline": "reply_bl.append(authorizer_reply.c_str(), authorizer_reply.length());"
    },
    {
        "line": 360,
        "fullcodeline": "uint64_t s = in_seq;"
    },
    {
        "line": 361,
        "fullcodeline": "reply_bl.append((char*)&s, sizeof(s));"
    },
    {
        "line": 374,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" existing race replacing process for addr=\" << peer_addr"
    },
    {
        "line": 379,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" state changed while accept_conn, it must be mark_down\" << dendl;"
    },
    {
        "line": 380,
        "fullcodeline": "assert(state == STATE_CLOSED || state == STATE_NONE);"
    },
    {
        "line": 394,
        "fullcodeline": "state = next_state;"
    },
    {
        "line": 395,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" accept write reply msg done\" << dendl;"
    },
    {
        "line": 15,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_BADPROTOVER, connect, reply, authorizer_reply);"
    },
    {
        "line": 19,
        "fullcodeline": "if (peer_type == CEPH_ENTITY_TYPE_OSD ||"
    },
    {
        "line": 50,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_FEATURES, connect, reply, authorizer_reply);"
    },
    {
        "line": 61,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_BADAUTHORIZER, connect, reply, authorizer_reply);"
    },
    {
        "line": 86,
        "fullcodeline": "if (existing->state == STATE_CLOSED) {"
    },
    {
        "line": 104,
        "fullcodeline": "if (connect.global_seq < existing->peer_global_seq) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (connect.connect_seq == 0 && existing->connect_seq > 0) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (connect.connect_seq < existing->connect_seq) {"
    },
    {
        "line": 147,
        "fullcodeline": "if (connect.connect_seq == existing->connect_seq) {"
    },
    {
        "line": 182,
        "fullcodeline": "if (policy.resetcheck &&   // RESETSESSION only used by servers; peers do not reset each other"
    },
    {
        "line": 219,
        "fullcodeline": "assert(can_write == WriteStatus::NOWRITE);"
    },
    {
        "line": 220,
        "fullcodeline": "existing->write_lock.lock();"
    },
    {
        "line": 228,
        "fullcodeline": "center->delete_file_event(cs.fd(), EVENT_READABLE|EVENT_WRITABLE);"
    },
    {
        "line": 234,
        "fullcodeline": "existing->reset_recv_state();"
    },
    {
        "line": 236,
        "fullcodeline": "auto temp_cs = std::move(cs);"
    },
    {
        "line": 237,
        "fullcodeline": "EventCenter *new_center = center;"
    },
    {
        "line": 238,
        "fullcodeline": "Worker *new_worker = worker;"
    },
    {
        "line": 241,
        "fullcodeline": "_stop();"
    },
    {
        "line": 243,
        "fullcodeline": "dispatch_queue->queue_reset(this);"
    },
    {
        "line": 244,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" stop myself to swap existing\" << dendl;"
    },
    {
        "line": 246,
        "fullcodeline": "existing->replacing = true;"
    },
    {
        "line": 247,
        "fullcodeline": "existing->state_offset = 0;"
    },
    {
        "line": 249,
        "fullcodeline": "existing->state = STATE_NONE;"
    },
    {
        "line": 251,
        "fullcodeline": "existing->recv_start = existing->recv_end = 0;"
    },
    {
        "line": 253,
        "fullcodeline": "assert(recv_start == recv_end);"
    },
    {
        "line": 255,
        "fullcodeline": "auto deactivate_existing = std::bind("
    },
    {
        "line": 310,
        "fullcodeline": "existing->center->submit_to("
    },
    {
        "line": 312,
        "fullcodeline": "existing->write_lock.unlock();"
    },
    {
        "line": 313,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 331,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_READY;"
    },
    {
        "line": 332,
        "fullcodeline": "next_state = STATE_ACCEPTING_READY;"
    },
    {
        "line": 333,
        "fullcodeline": "discard_requeued_up_to(0);"
    },
    {
        "line": 334,
        "fullcodeline": "is_reset_from_peer = false;"
    },
    {
        "line": 335,
        "fullcodeline": "in_seq = 0;"
    },
    {
        "line": 397,
        "fullcodeline": "state = STATE_WAIT_SEND;"
    },
    {
        "line": 398,
        "fullcodeline": "state_after_send = next_state;"
    },
    {
        "line": 21,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MGR) {"
    },
    {
        "line": 87,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" existing already closed.\" << dendl;"
    },
    {
        "line": 88,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 89,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 94,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" existing racing replace happened while replacing.\""
    },
    {
        "line": 96,
        "fullcodeline": "reply.global_seq = existing->peer_global_seq;"
    },
    {
        "line": 97,
        "fullcodeline": "r = _reply_accept(CEPH_MSGR_TAG_RETRY_GLOBAL, connect, reply, authorizer_reply);"
    },
    {
        "line": 98,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 105,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept existing \" << existing"
    },
    {
        "line": 108,
        "fullcodeline": "reply.global_seq = existing->peer_global_seq;  // so we can send it below.."
    },
    {
        "line": 109,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 118,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept replacing existing (lossy) channel (new one lossy=\""
    },
    {
        "line": 120,
        "fullcodeline": "existing->was_session_reset();"
    },
    {
        "line": 126,
        "fullcodeline": "<< get_state_name(existing->state) << dendl;"
    },
    {
        "line": 129,
        "fullcodeline": "ldout(async_msgr->cct,0) << __func__ << \" accept peer reset, then tried to connect to us, replacing\" << dendl;"
    },
    {
        "line": 131,
        "fullcodeline": "is_reset_from_peer = true;"
    },
    {
        "line": 139,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept existing \" << existing << \".cseq \""
    },
    {
        "line": 142,
        "fullcodeline": "reply.connect_seq = existing->connect_seq + 1;"
    },
    {
        "line": 143,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 183,
        "fullcodeline": "existing->connect_seq == 0) {"
    },
    {
        "line": 184,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept we reset (peer sent cseq \""
    },
    {
        "line": 187,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 196,
        "fullcodeline": "else if (!replacing && connect.connect_seq > 0) {"
    },
    {
        "line": 311,
        "fullcodeline": "existing->center->get_id(), std::move(deactivate_existing), true);"
    },
    {
        "line": 20,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MDS ||"
    },
    {
        "line": 27,
        "fullcodeline": "if (async_msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 99,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 110,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RETRY_GLOBAL, connect, reply, authorizer_reply);"
    },
    {
        "line": 112,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept existing \" << existing"
    },
    {
        "line": 144,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RETRY_SESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 152,
        "fullcodeline": "if (existing->state == STATE_OPEN ||"
    },
    {
        "line": 163,
        "fullcodeline": "if (peer_addr < async_msgr->get_myaddr() || existing->policy.server) {"
    },
    {
        "line": 188,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RESETSESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 198,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept we reset (peer sent cseq \""
    },
    {
        "line": 225,
        "fullcodeline": "existing->is_reset_from_peer = true;"
    },
    {
        "line": 231,
        "fullcodeline": "existing->delay_state->flush();"
    },
    {
        "line": 232,
        "fullcodeline": "assert(!delay_state);"
    },
    {
        "line": 308,
        "fullcodeline": "}, std::move(temp_cs));"
    },
    {
        "line": 24,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring MSG_AUTH feature bit for cluster\" << dendl;"
    },
    {
        "line": 25,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 28,
        "fullcodeline": "async_msgr->cct->_conf->cephx_cluster_require_version >= 2) {"
    },
    {
        "line": 29,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring cephx v2 feature bit for cluster\" << dendl;"
    },
    {
        "line": 30,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 38,
        "fullcodeline": "if (async_msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 95,
        "fullcodeline": "<< \" existing_state=\" << get_state_name(existing->state) << dendl;"
    },
    {
        "line": 133,
        "fullcodeline": "existing->was_session_reset(); // this resets out_queue, msg_ and connect_seq #'s"
    },
    {
        "line": 153,
        "fullcodeline": "existing->state == STATE_STANDBY) {"
    },
    {
        "line": 154,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept connection race, existing \" << existing"
    },
    {
        "line": 157,
        "fullcodeline": "reply.connect_seq = existing->connect_seq + 1;"
    },
    {
        "line": 158,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 165,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept connection race, existing \" << existing"
    },
    {
        "line": 200,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RESETSESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 203,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept new session\" << dendl;"
    },
    {
        "line": 204,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 35,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring MSG_AUTH feature bit for service\" << dendl;"
    },
    {
        "line": 36,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 39,
        "fullcodeline": "async_msgr->cct->_conf->cephx_service_require_version >= 2) {"
    },
    {
        "line": 40,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring cephx v2 feature bit for service\" << dendl;"
    },
    {
        "line": 41,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 159,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RETRY_SESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 171,
        "fullcodeline": "ldout(async_msgr->cct,10) << __func__ << \" accept connection race, existing \""
    },
    {
        "line": 174,
        "fullcodeline": "assert(peer_addr > async_msgr->get_myaddr());"
    },
    {
        "line": 175,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 176,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_WAIT, connect, reply, authorizer_reply);"
    }
]