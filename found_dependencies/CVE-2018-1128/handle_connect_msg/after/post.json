[
    {
        "line": 4,
        "fullcodeline": "ssize_t r = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "memset(&reply, 0, sizeof(reply));"
    },
    {
        "line": 9,
        "fullcodeline": "reply.protocol_version = async_msgr->get_proto_version(peer_type, false);"
    },
    {
        "line": 12,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept my proto \" << reply.protocol_version"
    },
    {
        "line": 46,
        "fullcodeline": "uint64_t feat_missing = policy.features_required & ~(uint64_t)connect.features;"
    },
    {
        "line": 53,
        "fullcodeline": "lock.unlock();"
    },
    {
        "line": 56,
        "fullcodeline": "bool need_challenge = HAVE_FEATURE(connect.features, CEPHX_V2);"
    },
    {
        "line": 57,
        "fullcodeline": "bool had_challenge = (bool)authorizer_challenge;"
    },
    {
        "line": 79,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept setting up session_security.\" << dendl;"
    },
    {
        "line": 82,
        "fullcodeline": "AsyncConnectionRef existing = async_msgr->lookup_conn(peer_addr);"
    },
    {
        "line": 84,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 86,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 224,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept replacing \" << existing << dendl;"
    },
    {
        "line": 226,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 332,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 335,
        "fullcodeline": "connect_seq = connect.connect_seq + 1;"
    },
    {
        "line": 336,
        "fullcodeline": "peer_global_seq = connect.global_seq;"
    },
    {
        "line": 337,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept success, connect_seq = \""
    },
    {
        "line": 356,
        "fullcodeline": "reply.global_seq = async_msgr->get_global_seq();"
    },
    {
        "line": 357,
        "fullcodeline": "reply.connect_seq = connect_seq;"
    },
    {
        "line": 358,
        "fullcodeline": "reply.flags = 0;"
    },
    {
        "line": 359,
        "fullcodeline": "reply.authorizer_len = authorizer_reply.length();"
    },
    {
        "line": 363,
        "fullcodeline": "set_features((uint64_t)reply.features & (uint64_t)connect.features);"
    },
    {
        "line": 364,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept features \" << get_features() << dendl;"
    },
    {
        "line": 366,
        "fullcodeline": "session_security.reset("
    },
    {
        "line": 370,
        "fullcodeline": "reply_bl.append((char*)&reply, sizeof(reply));"
    },
    {
        "line": 380,
        "fullcodeline": "lock.unlock();"
    },
    {
        "line": 383,
        "fullcodeline": "r = async_msgr->accept_conn(this);"
    },
    {
        "line": 385,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 387,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 388,
        "fullcodeline": "replacing = false;"
    },
    {
        "line": 400,
        "fullcodeline": "r = try_send(reply_bl);"
    },
    {
        "line": 405,
        "fullcodeline": "dispatch_queue->queue_accept(this);"
    },
    {
        "line": 406,
        "fullcodeline": "async_msgr->ms_deliver_handle_fast_accept(this);"
    },
    {
        "line": 407,
        "fullcodeline": "once_ready = true;"
    },
    {
        "line": 420,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept fault after register\" << dendl;"
    },
    {
        "line": 421,
        "fullcodeline": "inject_delay();"
    },
    {
        "line": 424,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" failed to accept.\" << dendl;"
    },
    {
        "line": 14,
        "fullcodeline": "if (connect.protocol_version != reply.protocol_version) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (connect.authorizer_protocol == CEPH_AUTH_CEPHX) {"
    },
    {
        "line": 58,
        "fullcodeline": "if (!async_msgr->verify_authorizer("
    },
    {
        "line": 87,
        "fullcodeline": "if (state != STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH) {"
    },
    {
        "line": 93,
        "fullcodeline": "if (existing == this)"
    },
    {
        "line": 343,
        "fullcodeline": "if ((connect.features & CEPH_FEATURE_RECONNECT_SEQ) && !is_reset_from_peer) {"
    },
    {
        "line": 367,
        "fullcodeline": "get_auth_session_handler(async_msgr->cct, connect.authorizer_protocol,"
    },
    {
        "line": 375,
        "fullcodeline": "if (reply.tag == CEPH_MSGR_TAG_SEQ) {"
    },
    {
        "line": 389,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 394,
        "fullcodeline": "if (state != STATE_ACCEPTING_WAIT_CONNECT_MSG_AUTH) {"
    },
    {
        "line": 401,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 409,
        "fullcodeline": "if (r == 0) {"
    },
    {
        "line": 425,
        "fullcodeline": "return -1;"
    },
    {
        "line": 48,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" peer missing required features \""
    },
    {
        "line": 62,
        "fullcodeline": "!authorizer_valid) {"
    },
    {
        "line": 63,
        "fullcodeline": "lock.lock();"
    },
    {
        "line": 74,
        "fullcodeline": "session_security.reset();"
    },
    {
        "line": 88,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" state changed while accept, it must be mark_down\" << dendl;"
    },
    {
        "line": 89,
        "fullcodeline": "assert(state == STATE_CLOSED);"
    },
    {
        "line": 94,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 98,
        "fullcodeline": "existing->lock.lock();  // skip lockdep check (we are locking a second AsyncConnection here)"
    },
    {
        "line": 138,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept connect_seq \" << connect.connect_seq"
    },
    {
        "line": 194,
        "fullcodeline": "assert(connect.connect_seq > existing->connect_seq);"
    },
    {
        "line": 195,
        "fullcodeline": "assert(connect.global_seq >= existing->peer_global_seq);"
    },
    {
        "line": 206,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept peer sent cseq \" << connect.connect_seq"
    },
    {
        "line": 229,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" replacing on lossy channel, failing existing\" << dendl;"
    },
    {
        "line": 230,
        "fullcodeline": "existing->_stop();"
    },
    {
        "line": 231,
        "fullcodeline": "existing->dispatch_queue->queue_reset(existing.get());"
    },
    {
        "line": 344,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_SEQ;"
    },
    {
        "line": 345,
        "fullcodeline": "next_state = STATE_ACCEPTING_WAIT_SEQ;"
    },
    {
        "line": 361,
        "fullcodeline": "reply.flags = reply.flags | CEPH_MSG_CONNECT_LOSSY;"
    },
    {
        "line": 373,
        "fullcodeline": "reply_bl.append(authorizer_reply.c_str(), authorizer_reply.length());"
    },
    {
        "line": 376,
        "fullcodeline": "uint64_t s = in_seq;"
    },
    {
        "line": 377,
        "fullcodeline": "reply_bl.append((char*)&s, sizeof(s));"
    },
    {
        "line": 390,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" existing race replacing process for addr=\" << peer_addr"
    },
    {
        "line": 395,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" state changed while accept_conn, it must be mark_down\" << dendl;"
    },
    {
        "line": 396,
        "fullcodeline": "assert(state == STATE_CLOSED || state == STATE_NONE);"
    },
    {
        "line": 410,
        "fullcodeline": "state = next_state;"
    },
    {
        "line": 411,
        "fullcodeline": "ldout(async_msgr->cct, 2) << __func__ << \" accept write reply msg done\" << dendl;"
    },
    {
        "line": 15,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_BADPROTOVER, connect, reply, authorizer_reply);"
    },
    {
        "line": 19,
        "fullcodeline": "if (peer_type == CEPH_ENTITY_TYPE_OSD ||"
    },
    {
        "line": 50,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_FEATURES, connect, reply, authorizer_reply);"
    },
    {
        "line": 65,
        "fullcodeline": "if (need_challenge && !had_challenge && authorizer_challenge) {"
    },
    {
        "line": 75,
        "fullcodeline": "return _reply_accept(tag, connect, reply, authorizer_reply);"
    },
    {
        "line": 100,
        "fullcodeline": "if (existing->state == STATE_CLOSED) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (connect.global_seq < existing->peer_global_seq) {"
    },
    {
        "line": 142,
        "fullcodeline": "if (connect.connect_seq == 0 && existing->connect_seq > 0) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (connect.connect_seq < existing->connect_seq) {"
    },
    {
        "line": 161,
        "fullcodeline": "if (connect.connect_seq == existing->connect_seq) {"
    },
    {
        "line": 196,
        "fullcodeline": "if (policy.resetcheck &&   // RESETSESSION only used by servers; peers do not reset each other"
    },
    {
        "line": 233,
        "fullcodeline": "assert(can_write == WriteStatus::NOWRITE);"
    },
    {
        "line": 234,
        "fullcodeline": "existing->write_lock.lock();"
    },
    {
        "line": 242,
        "fullcodeline": "center->delete_file_event(cs.fd(), EVENT_READABLE|EVENT_WRITABLE);"
    },
    {
        "line": 248,
        "fullcodeline": "existing->reset_recv_state();"
    },
    {
        "line": 250,
        "fullcodeline": "auto temp_cs = std::move(cs);"
    },
    {
        "line": 251,
        "fullcodeline": "EventCenter *new_center = center;"
    },
    {
        "line": 252,
        "fullcodeline": "Worker *new_worker = worker;"
    },
    {
        "line": 255,
        "fullcodeline": "_stop();"
    },
    {
        "line": 257,
        "fullcodeline": "dispatch_queue->queue_reset(this);"
    },
    {
        "line": 258,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" stop myself to swap existing\" << dendl;"
    },
    {
        "line": 260,
        "fullcodeline": "existing->replacing = true;"
    },
    {
        "line": 261,
        "fullcodeline": "existing->state_offset = 0;"
    },
    {
        "line": 263,
        "fullcodeline": "existing->state = STATE_NONE;"
    },
    {
        "line": 265,
        "fullcodeline": "existing->recv_start = existing->recv_end = 0;"
    },
    {
        "line": 267,
        "fullcodeline": "assert(recv_start == recv_end);"
    },
    {
        "line": 269,
        "fullcodeline": "existing->authorizer_challenge.reset();"
    },
    {
        "line": 271,
        "fullcodeline": "auto deactivate_existing = std::bind("
    },
    {
        "line": 326,
        "fullcodeline": "existing->center->submit_to("
    },
    {
        "line": 328,
        "fullcodeline": "existing->write_lock.unlock();"
    },
    {
        "line": 329,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 347,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_READY;"
    },
    {
        "line": 348,
        "fullcodeline": "next_state = STATE_ACCEPTING_READY;"
    },
    {
        "line": 349,
        "fullcodeline": "discard_requeued_up_to(0);"
    },
    {
        "line": 350,
        "fullcodeline": "is_reset_from_peer = false;"
    },
    {
        "line": 351,
        "fullcodeline": "in_seq = 0;"
    },
    {
        "line": 413,
        "fullcodeline": "state = STATE_WAIT_SEND;"
    },
    {
        "line": 414,
        "fullcodeline": "state_after_send = next_state;"
    },
    {
        "line": 21,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MGR) {"
    },
    {
        "line": 61,
        "fullcodeline": "need_challenge ? &authorizer_challenge : nullptr) ||"
    },
    {
        "line": 66,
        "fullcodeline": "ldout(async_msgr->cct,0) << __func__ << \": challenging authorizer\""
    },
    {
        "line": 68,
        "fullcodeline": "assert(authorizer_reply.length());"
    },
    {
        "line": 69,
        "fullcodeline": "tag = CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER;"
    },
    {
        "line": 101,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" existing already closed.\" << dendl;"
    },
    {
        "line": 102,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 103,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 108,
        "fullcodeline": "ldout(async_msgr->cct, 1) << __func__ << \" existing racing replace happened while replacing.\""
    },
    {
        "line": 110,
        "fullcodeline": "reply.global_seq = existing->peer_global_seq;"
    },
    {
        "line": 111,
        "fullcodeline": "r = _reply_accept(CEPH_MSGR_TAG_RETRY_GLOBAL, connect, reply, authorizer_reply);"
    },
    {
        "line": 112,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 119,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept existing \" << existing"
    },
    {
        "line": 122,
        "fullcodeline": "reply.global_seq = existing->peer_global_seq;  // so we can send it below.."
    },
    {
        "line": 123,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 132,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept replacing existing (lossy) channel (new one lossy=\""
    },
    {
        "line": 134,
        "fullcodeline": "existing->was_session_reset();"
    },
    {
        "line": 140,
        "fullcodeline": "<< get_state_name(existing->state) << dendl;"
    },
    {
        "line": 143,
        "fullcodeline": "ldout(async_msgr->cct,0) << __func__ << \" accept peer reset, then tried to connect to us, replacing\" << dendl;"
    },
    {
        "line": 145,
        "fullcodeline": "is_reset_from_peer = true;"
    },
    {
        "line": 153,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept existing \" << existing << \".cseq \""
    },
    {
        "line": 156,
        "fullcodeline": "reply.connect_seq = existing->connect_seq + 1;"
    },
    {
        "line": 157,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 197,
        "fullcodeline": "existing->connect_seq == 0) {"
    },
    {
        "line": 198,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept we reset (peer sent cseq \""
    },
    {
        "line": 201,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 210,
        "fullcodeline": "else if (!replacing && connect.connect_seq > 0) {"
    },
    {
        "line": 327,
        "fullcodeline": "existing->center->get_id(), std::move(deactivate_existing), true);"
    },
    {
        "line": 20,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MDS ||"
    },
    {
        "line": 27,
        "fullcodeline": "if (async_msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 71,
        "fullcodeline": "ldout(async_msgr->cct,0) << __func__ << \": got bad authorizer\" << dendl;"
    },
    {
        "line": 72,
        "fullcodeline": "tag = CEPH_MSGR_TAG_BADAUTHORIZER;"
    },
    {
        "line": 113,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 124,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RETRY_GLOBAL, connect, reply, authorizer_reply);"
    },
    {
        "line": 126,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept existing \" << existing"
    },
    {
        "line": 158,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RETRY_SESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 166,
        "fullcodeline": "if (existing->state == STATE_OPEN ||"
    },
    {
        "line": 177,
        "fullcodeline": "if (peer_addr < async_msgr->get_myaddr() || existing->policy.server) {"
    },
    {
        "line": 202,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RESETSESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 212,
        "fullcodeline": "ldout(async_msgr->cct, 0) << __func__ << \" accept we reset (peer sent cseq \""
    },
    {
        "line": 239,
        "fullcodeline": "existing->is_reset_from_peer = true;"
    },
    {
        "line": 245,
        "fullcodeline": "existing->delay_state->flush();"
    },
    {
        "line": 246,
        "fullcodeline": "assert(!delay_state);"
    },
    {
        "line": 324,
        "fullcodeline": "}, std::move(temp_cs));"
    },
    {
        "line": 24,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring MSG_AUTH feature bit for cluster\" << dendl;"
    },
    {
        "line": 25,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 28,
        "fullcodeline": "async_msgr->cct->_conf->cephx_cluster_require_version >= 2) {"
    },
    {
        "line": 29,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring cephx v2 feature bit for cluster\" << dendl;"
    },
    {
        "line": 30,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 38,
        "fullcodeline": "if (async_msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 109,
        "fullcodeline": "<< \" existing_state=\" << get_state_name(existing->state) << dendl;"
    },
    {
        "line": 147,
        "fullcodeline": "existing->was_session_reset(); // this resets out_queue, msg_ and connect_seq #'s"
    },
    {
        "line": 167,
        "fullcodeline": "existing->state == STATE_STANDBY) {"
    },
    {
        "line": 168,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept connection race, existing \" << existing"
    },
    {
        "line": 171,
        "fullcodeline": "reply.connect_seq = existing->connect_seq + 1;"
    },
    {
        "line": 172,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 179,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept connection race, existing \" << existing"
    },
    {
        "line": 214,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RESETSESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 217,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" accept new session\" << dendl;"
    },
    {
        "line": 218,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 35,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring MSG_AUTH feature bit for service\" << dendl;"
    },
    {
        "line": 36,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 39,
        "fullcodeline": "async_msgr->cct->_conf->cephx_service_require_version >= 2) {"
    },
    {
        "line": 40,
        "fullcodeline": "ldout(async_msgr->cct, 10) << __func__ << \" using cephx, requiring cephx v2 feature bit for service\" << dendl;"
    },
    {
        "line": 41,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 173,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_RETRY_SESSION, connect, reply, authorizer_reply);"
    },
    {
        "line": 185,
        "fullcodeline": "ldout(async_msgr->cct,10) << __func__ << \" accept connection race, existing \""
    },
    {
        "line": 188,
        "fullcodeline": "assert(peer_addr > async_msgr->get_myaddr());"
    },
    {
        "line": 189,
        "fullcodeline": "existing->lock.unlock();"
    },
    {
        "line": 190,
        "fullcodeline": "return _reply_accept(CEPH_MSGR_TAG_WAIT, connect, reply, authorizer_reply);"
    }
]