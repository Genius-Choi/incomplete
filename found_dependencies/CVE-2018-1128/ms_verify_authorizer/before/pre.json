[
    {
        "line": 5,
        "fullcodeline": "Mutex::Locker l(mds_lock);"
    },
    {
        "line": 30,
        "fullcodeline": "RotatingKeyRing *keys = monc->rotating_secrets.get();"
    },
    {
        "line": 9,
        "fullcodeline": "if (beacon.get_want_state() == CEPH_MDS_STATE_DNE)"
    },
    {
        "line": 20,
        "fullcodeline": "if (!authorize_handler) {"
    },
    {
        "line": 15,
        "fullcodeline": "authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);"
    },
    {
        "line": 18,
        "fullcodeline": "authorize_handler = authorize_handler_service_registry->get_handler(protocol);"
    },
    {
        "line": 48,
        "fullcodeline": "Session *s = NULL;"
    },
    {
        "line": 21,
        "fullcodeline": "dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;"
    },
    {
        "line": 32,
        "fullcodeline": "is_valid = authorize_handler->verify_authorizer("
    },
    {
        "line": 37,
        "fullcodeline": "dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;"
    },
    {
        "line": 42,
        "fullcodeline": "entity_name_t n(con->get_peer_type(), global_id);"
    },
    {
        "line": 58,
        "fullcodeline": "if (!s) {"
    },
    {
        "line": 52,
        "fullcodeline": "s = mds_rank->sessionmap.get_session(n);"
    },
    {
        "line": 59,
        "fullcodeline": "s = new Session;"
    },
    {
        "line": 63,
        "fullcodeline": "dout(10) << \" new session \" << s << \" for \" << s->info.inst << \" con \" << con << dendl;"
    },
    {
        "line": 64,
        "fullcodeline": "con->set_priv(s);"
    },
    {
        "line": 61,
        "fullcodeline": "s->info.inst.addr = con->get_peer_addr();"
    },
    {
        "line": 67,
        "fullcodeline": "dout(10) << \" existing session \" << s << \" for \" << s->info.inst << \" existing con \" << s->connection"
    },
    {
        "line": 90,
        "fullcodeline": "bufferlist::iterator p = caps_info.caps.begin();"
    },
    {
        "line": 69,
        "fullcodeline": "con->set_priv(s->get());"
    },
    {
        "line": 93,
        "fullcodeline": "::decode(auth_cap_str, p);"
    },
    {
        "line": 95,
        "fullcodeline": "dout(10) << __func__ << \": parsing auth_cap_str='\" << auth_cap_str << \"'\" << dendl;"
    },
    {
        "line": 97,
        "fullcodeline": "if (!s->auth_caps.parse(g_ceph_context, auth_cap_str, &errstr)) {"
    },
    {
        "line": 98,
        "fullcodeline": "dout(1) << __func__ << \": auth cap parse error: \" << errstr.str()"
    },
    {
        "line": 108,
        "fullcodeline": "dout(1) << __func__ << \": cannot decode auth caps bl of length \" << caps_info.caps.length() << dendl;"
    },
    {
        "line": 100,
        "fullcodeline": "clog->warn() << name << \" mds cap '\" << auth_cap_str"
    },
    {
        "line": 101,
        "fullcodeline": "<< \"' does not parse: \" << errstr.str();"
    }
]