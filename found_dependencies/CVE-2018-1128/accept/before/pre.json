[
    {
        "line": 3,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept\" << dendl;"
    },
    {
        "line": 7,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 14,
        "fullcodeline": "char banner[strlen(CEPH_BANNER)+1];"
    },
    {
        "line": 18,
        "fullcodeline": "Pipe *existing = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "bool replaced = false;"
    },
    {
        "line": 27,
        "fullcodeline": "bool is_reset_from_peer = false;"
    },
    {
        "line": 33,
        "fullcodeline": "int reply_tag = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "uint64_t existing_seq = -1;"
    },
    {
        "line": 37,
        "fullcodeline": "uint64_t newly_acked_seq = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "recv_reset();"
    },
    {
        "line": 41,
        "fullcodeline": "set_socket_options();"
    },
    {
        "line": 44,
        "fullcodeline": "r = tcp_write(CEPH_BANNER, strlen(CEPH_BANNER));"
    },
    {
        "line": 51,
        "fullcodeline": "::encode(msgr->my_inst.addr, addrs, 0);  // legacy"
    },
    {
        "line": 53,
        "fullcodeline": "port = msgr->my_inst.addr.get_port();"
    },
    {
        "line": 57,
        "fullcodeline": "len = sizeof(ss);"
    },
    {
        "line": 58,
        "fullcodeline": "r = ::getpeername(sd, (sockaddr*)&ss, &len);"
    },
    {
        "line": 63,
        "fullcodeline": "socket_addr.set_sockaddr((sockaddr*)&ss);"
    },
    {
        "line": 64,
        "fullcodeline": "::encode(socket_addr, addrs, 0);  // legacy"
    },
    {
        "line": 66,
        "fullcodeline": "r = tcp_write(addrs.c_str(), addrs.length());"
    },
    {
        "line": 72,
        "fullcodeline": "ldout(msgr->cct,1) << \"accept sd=\" << sd << \" \" << socket_addr << dendl;"
    },
    {
        "line": 97,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept peer addr is \" << peer_addr << dendl;"
    },
    {
        "line": 399,
        "fullcodeline": "assert(existing->pipe_lock.is_locked());"
    },
    {
        "line": 406,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept replacing \" << existing << dendl;"
    },
    {
        "line": 407,
        "fullcodeline": "existing->stop();"
    },
    {
        "line": 408,
        "fullcodeline": "existing->unregister_pipe();"
    },
    {
        "line": 409,
        "fullcodeline": "replaced = true;"
    },
    {
        "line": 454,
        "fullcodeline": "existing->stop_and_wait();"
    },
    {
        "line": 455,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 459,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 460,
        "fullcodeline": "connect_seq = connect.connect_seq + 1;"
    },
    {
        "line": 461,
        "fullcodeline": "peer_global_seq = connect.global_seq;"
    },
    {
        "line": 462,
        "fullcodeline": "assert(state == STATE_ACCEPTING);"
    },
    {
        "line": 463,
        "fullcodeline": "state = STATE_OPEN;"
    },
    {
        "line": 464,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept success, connect_seq = \" << connect_seq << \", sending READY\" << dendl;"
    },
    {
        "line": 467,
        "fullcodeline": "reply.tag = (reply_tag ? reply_tag : CEPH_MSGR_TAG_READY);"
    },
    {
        "line": 468,
        "fullcodeline": "reply.features = policy.features_supported;"
    },
    {
        "line": 469,
        "fullcodeline": "reply.global_seq = msgr->get_global_seq();"
    },
    {
        "line": 470,
        "fullcodeline": "reply.connect_seq = connect_seq;"
    },
    {
        "line": 471,
        "fullcodeline": "reply.flags = 0;"
    },
    {
        "line": 472,
        "fullcodeline": "reply.authorizer_len = authorizer_reply.length();"
    },
    {
        "line": 476,
        "fullcodeline": "connection_state->set_features((uint64_t)reply.features & (uint64_t)connect.features);"
    },
    {
        "line": 477,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept features \" << connection_state->get_features() << dendl;"
    },
    {
        "line": 479,
        "fullcodeline": "session_security.reset("
    },
    {
        "line": 486,
        "fullcodeline": "msgr->dispatch_queue.queue_accept(connection_state.get());"
    },
    {
        "line": 487,
        "fullcodeline": "msgr->ms_deliver_handle_fast_accept(connection_state.get());"
    },
    {
        "line": 492,
        "fullcodeline": "removed = msgr->accepting_pipes.erase(this);"
    },
    {
        "line": 493,
        "fullcodeline": "assert(removed == 1);"
    },
    {
        "line": 494,
        "fullcodeline": "register_pipe();"
    },
    {
        "line": 495,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 496,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 498,
        "fullcodeline": "r = tcp_write((char*)&reply, sizeof(reply));"
    },
    {
        "line": 521,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 522,
        "fullcodeline": "discard_requeued_up_to(newly_acked_seq);"
    },
    {
        "line": 527,
        "fullcodeline": "ldout(msgr->cct,20) << \"accept done\" << dendl;"
    },
    {
        "line": 529,
        "fullcodeline": "maybe_start_delay_thread();"
    },
    {
        "line": 534,
        "fullcodeline": "ldout(msgr->cct, 10) << \"accept fault after register\" << dendl;"
    },
    {
        "line": 4,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 5,
        "fullcodeline": "assert(state == STATE_ACCEPTING);"
    },
    {
        "line": 75,
        "fullcodeline": "if (tcp_read(banner, strlen(CEPH_BANNER)) < 0) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (memcmp(banner, CEPH_BANNER, strlen(CEPH_BANNER))) {"
    },
    {
        "line": 85,
        "fullcodeline": "bufferptr tp(sizeof(ceph_entity_addr));"
    },
    {
        "line": 86,
        "fullcodeline": "addrbl.push_back(std::move(tp));"
    },
    {
        "line": 88,
        "fullcodeline": "if (tcp_read(addrbl.c_str(), addrbl.length()) < 0) {"
    },
    {
        "line": 93,
        "fullcodeline": "bufferlist::iterator ti = addrbl.begin();"
    },
    {
        "line": 94,
        "fullcodeline": "::decode(peer_addr, ti);"
    },
    {
        "line": 98,
        "fullcodeline": "if (peer_addr.is_blank_ip()) {"
    },
    {
        "line": 400,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 402,
        "fullcodeline": "if ((connect.features & CEPH_FEATURE_RECONNECT_SEQ) && !is_reset_from_peer) {"
    },
    {
        "line": 480,
        "fullcodeline": "get_auth_session_handler(msgr->cct,"
    },
    {
        "line": 499,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 510,
        "fullcodeline": "if (reply_tag == CEPH_MSGR_TAG_SEQ) {"
    },
    {
        "line": 523,
        "fullcodeline": "if (state != STATE_CLOSED) {"
    },
    {
        "line": 545,
        "fullcodeline": "if (state != STATE_CLOSED) {"
    },
    {
        "line": 560,
        "fullcodeline": "return -1;"
    },
    {
        "line": 565,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 577,
        "fullcodeline": "return -1;"
    },
    {
        "line": 46,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't write banner\" << dendl;"
    },
    {
        "line": 60,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept failed to getpeername \" << cpp_strerror(errno) << dendl;"
    },
    {
        "line": 68,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't write my+peer addr\" << dendl;"
    },
    {
        "line": 76,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read banner\" << dendl;"
    },
    {
        "line": 80,
        "fullcodeline": "banner[strlen(CEPH_BANNER)] = 0;"
    },
    {
        "line": 81,
        "fullcodeline": "ldout(msgr->cct,1) << \"accept peer sent bad banner '\" << banner << \"' (should be '\" << CEPH_BANNER << \"')\" << dendl;"
    },
    {
        "line": 89,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read peer_addr\" << dendl;"
    },
    {
        "line": 100,
        "fullcodeline": "int port = peer_addr.get_port();"
    },
    {
        "line": 101,
        "fullcodeline": "peer_addr.u = socket_addr.u;"
    },
    {
        "line": 102,
        "fullcodeline": "peer_addr.set_port(port);"
    },
    {
        "line": 103,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept peer addr is really \" << peer_addr"
    },
    {
        "line": 114,
        "fullcodeline": "authorizer.clear();"
    },
    {
        "line": 125,
        "fullcodeline": "ldout(msgr->cct,20) << \"accept got peer connect_seq \" << connect.connect_seq"
    },
    {
        "line": 129,
        "fullcodeline": "msgr->lock.Lock();   // FIXME"
    },
    {
        "line": 130,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 138,
        "fullcodeline": "set_peer_type(connect.host_type);"
    },
    {
        "line": 139,
        "fullcodeline": "policy = msgr->get_policy(connect.host_type);"
    },
    {
        "line": 140,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept of host_type \" << connect.host_type"
    },
    {
        "line": 147,
        "fullcodeline": "memset(&reply, 0, sizeof(reply));"
    },
    {
        "line": 148,
        "fullcodeline": "reply.protocol_version = msgr->get_proto_version(peer_type, false);"
    },
    {
        "line": 149,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 152,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept my proto \" << reply.protocol_version"
    },
    {
        "line": 188,
        "fullcodeline": "feat_missing = policy.features_required & ~(uint64_t)connect.features;"
    },
    {
        "line": 197,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 213,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept:  setting up session_security.\" << dendl;"
    },
    {
        "line": 216,
        "fullcodeline": "msgr->lock.Lock();"
    },
    {
        "line": 217,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 224,
        "fullcodeline": "existing = msgr->_lookup_pipe(peer_addr);"
    },
    {
        "line": 372,
        "fullcodeline": "ceph_abort();"
    },
    {
        "line": 375,
        "fullcodeline": "assert(existing->pipe_lock.is_locked());"
    },
    {
        "line": 377,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RETRY_SESSION;"
    },
    {
        "line": 378,
        "fullcodeline": "reply.connect_seq = existing->connect_seq + 1;"
    },
    {
        "line": 379,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 380,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 385,
        "fullcodeline": "reply.features = ((uint64_t)connect.features & policy.features_supported) | policy.features_required;"
    },
    {
        "line": 386,
        "fullcodeline": "reply.authorizer_len = authorizer_reply.length();"
    },
    {
        "line": 387,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 388,
        "fullcodeline": "r = tcp_write((char*)&reply, sizeof(reply));"
    },
    {
        "line": 403,
        "fullcodeline": "reply_tag = CEPH_MSGR_TAG_SEQ;"
    },
    {
        "line": 404,
        "fullcodeline": "existing_seq = existing->in_seq;"
    },
    {
        "line": 413,
        "fullcodeline": "assert(existing->connection_state);"
    },
    {
        "line": 474,
        "fullcodeline": "reply.flags = reply.flags | CEPH_MSG_CONNECT_LOSSY;"
    },
    {
        "line": 483,
        "fullcodeline": "connection_state->get_features()));"
    },
    {
        "line": 504,
        "fullcodeline": "r = tcp_write(authorizer_reply.c_str(), authorizer_reply.length());"
    },
    {
        "line": 524,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept starting writer, state \" << get_state_name() << dendl;"
    },
    {
        "line": 525,
        "fullcodeline": "start_writer();"
    },
    {
        "line": 537,
        "fullcodeline": "ldout(msgr->cct, 10) << \" sleep for \" << msgr->cct->_conf->ms_inject_internal_delays << dendl;"
    },
    {
        "line": 539,
        "fullcodeline": "t.set_from_double(msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 546,
        "fullcodeline": "bool queued = is_queued();"
    },
    {
        "line": 570,
        "fullcodeline": "t.set_from_double(msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 109,
        "fullcodeline": "if (tcp_read((char*)&connect, sizeof(connect)) < 0) {"
    },
    {
        "line": 133,
        "fullcodeline": "if (state != STATE_ACCEPTING) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (connect.protocol_version != reply.protocol_version) {"
    },
    {
        "line": 160,
        "fullcodeline": "if (connect.authorizer_protocol == CEPH_AUTH_CEPHX) {"
    },
    {
        "line": 199,
        "fullcodeline": "if (!msgr->verify_authorizer(connection_state.get(), peer_type, connect.authorizer_protocol, authorizer,"
    },
    {
        "line": 220,
        "fullcodeline": "if (state != STATE_ACCEPTING)"
    },
    {
        "line": 376,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 384,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 414,
        "fullcodeline": "if (existing->connection_state->clear_pipe(existing))"
    },
    {
        "line": 418,
        "fullcodeline": "msgr->dispatch_queue.queue_reset(connection_state.get());"
    },
    {
        "line": 423,
        "fullcodeline": "connection_state = existing->connection_state;"
    },
    {
        "line": 426,
        "fullcodeline": "connection_state->reset_pipe(this);"
    },
    {
        "line": 436,
        "fullcodeline": "uint64_t replaced_conn_id = conn_id;"
    },
    {
        "line": 437,
        "fullcodeline": "conn_id = existing->conn_id;"
    },
    {
        "line": 438,
        "fullcodeline": "existing->conn_id = replaced_conn_id;"
    },
    {
        "line": 442,
        "fullcodeline": "in_seq = is_reset_from_peer ? 0 : existing->in_seq;"
    },
    {
        "line": 443,
        "fullcodeline": "in_seq_acked = in_seq;"
    },
    {
        "line": 446,
        "fullcodeline": "existing->requeue_sent();"
    },
    {
        "line": 447,
        "fullcodeline": "out_seq = existing->out_seq;"
    },
    {
        "line": 448,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept re-queuing on out_seq \" << out_seq << \" in_seq \" << in_seq << dendl;"
    },
    {
        "line": 505,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 511,
        "fullcodeline": "if (tcp_write((char*)&existing_seq, sizeof(existing_seq)) < 0) {"
    },
    {
        "line": 515,
        "fullcodeline": "if (tcp_read((char*)&newly_acked_seq, sizeof(newly_acked_seq)) < 0) {"
    },
    {
        "line": 547,
        "fullcodeline": "ldout(msgr->cct, 10) << \"  queued = \" << (int)queued << dendl;"
    },
    {
        "line": 568,
        "fullcodeline": "ldout(msgr->cct, 10) << \" sleep for \" << msgr->cct->_conf->ms_inject_internal_delays << dendl;"
    },
    {
        "line": 110,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read connect\" << dendl;"
    },
    {
        "line": 116,
        "fullcodeline": "bp = buffer::create(connect.authorizer_len);"
    },
    {
        "line": 121,
        "fullcodeline": "authorizer.push_back(std::move(bp));"
    },
    {
        "line": 122,
        "fullcodeline": "authorizer_reply.clear();"
    },
    {
        "line": 155,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_BADPROTOVER;"
    },
    {
        "line": 190,
        "fullcodeline": "ldout(msgr->cct,1) << \"peer missing required features \" << std::hex << feat_missing << std::dec << dendl;"
    },
    {
        "line": 191,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_FEATURES;"
    },
    {
        "line": 201,
        "fullcodeline": "!authorizer_valid) {"
    },
    {
        "line": 202,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept: got bad authorizer\" << dendl;"
    },
    {
        "line": 203,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 206,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_BADAUTHORIZER;"
    },
    {
        "line": 207,
        "fullcodeline": "session_security.reset();"
    },
    {
        "line": 226,
        "fullcodeline": "existing->pipe_lock.Lock(true);  // skip lockdep check (we are locking a second Pipe here)"
    },
    {
        "line": 271,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept connect_seq \" << connect.connect_seq"
    },
    {
        "line": 342,
        "fullcodeline": "assert(connect.connect_seq > existing->connect_seq);"
    },
    {
        "line": 343,
        "fullcodeline": "assert(connect.global_seq >= existing->peer_global_seq);"
    },
    {
        "line": 356,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept peer sent cseq \" << connect.connect_seq"
    },
    {
        "line": 392,
        "fullcodeline": "r = tcp_write(authorizer_reply.c_str(), authorizer_reply.length());"
    },
    {
        "line": 415,
        "fullcodeline": "msgr->dispatch_queue.queue_reset(existing->connection_state.get());"
    },
    {
        "line": 450,
        "fullcodeline": "p != existing->out_q.end();"
    },
    {
        "line": 451,
        "fullcodeline": "++p)"
    },
    {
        "line": 452,
        "fullcodeline": "out_q[p->first].splice(out_q[p->first].begin(), p->second);"
    },
    {
        "line": 512,
        "fullcodeline": "ldout(msgr->cct,2) << \"accept write error on in_seq\" << dendl;"
    },
    {
        "line": 516,
        "fullcodeline": "ldout(msgr->cct,2) << \"accept read error on newly_acked_seq\" << dendl;"
    },
    {
        "line": 117,
        "fullcodeline": "if (tcp_read(bp.c_str(), connect.authorizer_len) < 0) {"
    },
    {
        "line": 161,
        "fullcodeline": "if (peer_type == CEPH_ENTITY_TYPE_OSD ||"
    },
    {
        "line": 204,
        "fullcodeline": "if (state != STATE_ACCEPTING)"
    },
    {
        "line": 251,
        "fullcodeline": "if (connect.global_seq < existing->peer_global_seq) {"
    },
    {
        "line": 275,
        "fullcodeline": "if (connect.connect_seq == 0 && existing->connect_seq > 0) {"
    },
    {
        "line": 284,
        "fullcodeline": "if (connect.connect_seq < existing->connect_seq) {"
    },
    {
        "line": 291,
        "fullcodeline": "if (connect.connect_seq == existing->connect_seq) {"
    },
    {
        "line": 344,
        "fullcodeline": "if (policy.resetcheck &&   // RESETSESSION only used by servers; peers do not reset each other"
    },
    {
        "line": 429,
        "fullcodeline": "existing->delay_thread->steal_for_pipe(this);"
    },
    {
        "line": 430,
        "fullcodeline": "delay_thread = existing->delay_thread;"
    },
    {
        "line": 431,
        "fullcodeline": "existing->delay_thread = NULL;"
    },
    {
        "line": 432,
        "fullcodeline": "delay_thread->flush();"
    },
    {
        "line": 449,
        "fullcodeline": "for (map<int, list<Message*> >::iterator p = existing->out_q.begin();"
    },
    {
        "line": 118,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read connect authorizer\" << dendl;"
    },
    {
        "line": 163,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MGR) {"
    },
    {
        "line": 239,
        "fullcodeline": "existing->get();"
    },
    {
        "line": 240,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 241,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 242,
        "fullcodeline": "existing->notify_on_dispatch_done = true;"
    },
    {
        "line": 245,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 246,
        "fullcodeline": "existing->put();"
    },
    {
        "line": 247,
        "fullcodeline": "existing = nullptr;"
    },
    {
        "line": 252,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept existing \" << existing << \".gseq \" << existing->peer_global_seq"
    },
    {
        "line": 254,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RETRY_GLOBAL;"
    },
    {
        "line": 255,
        "fullcodeline": "reply.global_seq = existing->peer_global_seq;  // so we can send it below.."
    },
    {
        "line": 256,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 257,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 265,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept replacing existing (lossy) channel (new one lossy=\""
    },
    {
        "line": 267,
        "fullcodeline": "existing->was_session_reset();"
    },
    {
        "line": 273,
        "fullcodeline": "<< \" state \" << existing->get_state_name() << dendl;"
    },
    {
        "line": 276,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept peer reset, then tried to connect to us, replacing\" << dendl;"
    },
    {
        "line": 278,
        "fullcodeline": "is_reset_from_peer = true;"
    },
    {
        "line": 286,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept existing \" << existing << \".cseq \" << existing->connect_seq"
    },
    {
        "line": 345,
        "fullcodeline": "existing->connect_seq == 0) {"
    },
    {
        "line": 346,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept we reset (peer sent cseq \" << connect.connect_seq"
    },
    {
        "line": 349,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RESETSESSION;"
    },
    {
        "line": 350,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 351,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 360,
        "fullcodeline": "else if (connect.connect_seq > 0) {"
    },
    {
        "line": 162,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MDS ||"
    },
    {
        "line": 164,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_signatures ||"
    },
    {
        "line": 169,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 244,
        "fullcodeline": "existing->cond.Wait(existing->pipe_lock);"
    },
    {
        "line": 260,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept existing \" << existing << \".gseq \" << existing->peer_global_seq"
    },
    {
        "line": 296,
        "fullcodeline": "if (existing->state == STATE_OPEN ||"
    },
    {
        "line": 306,
        "fullcodeline": "if (peer_addr < msgr->my_inst.addr ||"
    },
    {
        "line": 362,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept we reset (peer sent cseq \" << connect.connect_seq << \"), sending RESETSESSION\" << dendl;"
    },
    {
        "line": 363,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 364,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RESETSESSION;"
    },
    {
        "line": 166,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring MSG_AUTH feature bit for cluster\" << dendl;"
    },
    {
        "line": 167,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 170,
        "fullcodeline": "msgr->cct->_conf->cephx_cluster_require_version >= 2) {"
    },
    {
        "line": 171,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring cephx v2 feature bit for cluster\" << dendl;"
    },
    {
        "line": 172,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 175,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_signatures ||"
    },
    {
        "line": 180,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 280,
        "fullcodeline": "existing->was_session_reset(); // this resets out_queue, msg_ and connect_seq #'s"
    },
    {
        "line": 297,
        "fullcodeline": "existing->state == STATE_STANDBY) {"
    },
    {
        "line": 298,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept connection race, existing \" << existing"
    },
    {
        "line": 309,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept connection race, existing \" << existing << \".cseq \" << existing->connect_seq"
    },
    {
        "line": 318,
        "fullcodeline": "assert(existing->state == STATE_CONNECTING ||"
    },
    {
        "line": 368,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept new session\" << dendl;"
    },
    {
        "line": 369,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 177,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring MSG_AUTH feature bit for service\" << dendl;"
    },
    {
        "line": 178,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 181,
        "fullcodeline": "msgr->cct->_conf->cephx_service_require_version >= 2) {"
    },
    {
        "line": 182,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring cephx v2 feature bit for cluster\" << dendl;"
    },
    {
        "line": 183,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 311,
        "fullcodeline": "if (!(existing->state == STATE_CONNECTING ||"
    },
    {
        "line": 323,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept connection race, existing \" << existing << \".cseq \" << existing->connect_seq"
    },
    {
        "line": 325,
        "fullcodeline": "assert(peer_addr > msgr->my_inst.addr);"
    },
    {
        "line": 332,
        "fullcodeline": "assert(existing->state == STATE_CONNECTING);"
    },
    {
        "line": 334,
        "fullcodeline": "existing->_send_keepalive();"
    },
    {
        "line": 335,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_WAIT;"
    },
    {
        "line": 336,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 337,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 313,
        "fullcodeline": "lderr(msgr->cct) << \"accept race bad state, would replace, existing=\""
    },
    {
        "line": 319,
        "fullcodeline": "existing->state == STATE_WAIT);"
    },
    {
        "line": 326,
        "fullcodeline": "if (!(existing->state == STATE_CONNECTING))"
    },
    {
        "line": 312,
        "fullcodeline": "existing->state == STATE_WAIT))"
    },
    {
        "line": 327,
        "fullcodeline": "lderr(msgr->cct) << \"accept race bad state, would send wait, existing=\""
    },
    {
        "line": 314,
        "fullcodeline": "<< existing->get_state_name()"
    },
    {
        "line": 328,
        "fullcodeline": "<< existing->get_state_name()"
    }
]