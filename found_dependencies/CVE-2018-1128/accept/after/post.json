[
    {
        "line": 3,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept\" << dendl;"
    },
    {
        "line": 4,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 5,
        "fullcodeline": "assert(state == STATE_ACCEPTING);"
    },
    {
        "line": 7,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 14,
        "fullcodeline": "char banner[strlen(CEPH_BANNER)+1];"
    },
    {
        "line": 18,
        "fullcodeline": "Pipe *existing = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "bool replaced = false;"
    },
    {
        "line": 27,
        "fullcodeline": "bool is_reset_from_peer = false;"
    },
    {
        "line": 33,
        "fullcodeline": "int reply_tag = 0;"
    },
    {
        "line": 34,
        "fullcodeline": "uint64_t existing_seq = -1;"
    },
    {
        "line": 37,
        "fullcodeline": "uint64_t newly_acked_seq = 0;"
    },
    {
        "line": 39,
        "fullcodeline": "bool need_challenge = false;"
    },
    {
        "line": 40,
        "fullcodeline": "bool had_challenge = false;"
    },
    {
        "line": 41,
        "fullcodeline": "std::unique_ptr<AuthAuthorizerChallenge> authorizer_challenge;"
    },
    {
        "line": 43,
        "fullcodeline": "recv_reset();"
    },
    {
        "line": 45,
        "fullcodeline": "set_socket_options();"
    },
    {
        "line": 48,
        "fullcodeline": "r = tcp_write(CEPH_BANNER, strlen(CEPH_BANNER));"
    },
    {
        "line": 55,
        "fullcodeline": "::encode(msgr->my_inst.addr, addrs, 0);  // legacy"
    },
    {
        "line": 57,
        "fullcodeline": "port = msgr->my_inst.addr.get_port();"
    },
    {
        "line": 62,
        "fullcodeline": "r = ::getpeername(sd, (sockaddr*)&ss, &len);"
    },
    {
        "line": 67,
        "fullcodeline": "socket_addr.set_sockaddr((sockaddr*)&ss);"
    },
    {
        "line": 68,
        "fullcodeline": "::encode(socket_addr, addrs, 0);  // legacy"
    },
    {
        "line": 70,
        "fullcodeline": "r = tcp_write(addrs.c_str(), addrs.length());"
    },
    {
        "line": 76,
        "fullcodeline": "ldout(msgr->cct,1) << \"accept sd=\" << sd << \" \" << socket_addr << dendl;"
    },
    {
        "line": 101,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept peer addr is \" << peer_addr << dendl;"
    },
    {
        "line": 416,
        "fullcodeline": "assert(existing->pipe_lock.is_locked());"
    },
    {
        "line": 417,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 423,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept replacing \" << existing << dendl;"
    },
    {
        "line": 424,
        "fullcodeline": "existing->stop();"
    },
    {
        "line": 425,
        "fullcodeline": "existing->unregister_pipe();"
    },
    {
        "line": 426,
        "fullcodeline": "replaced = true;"
    },
    {
        "line": 471,
        "fullcodeline": "existing->stop_and_wait();"
    },
    {
        "line": 472,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 476,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 477,
        "fullcodeline": "connect_seq = connect.connect_seq + 1;"
    },
    {
        "line": 478,
        "fullcodeline": "peer_global_seq = connect.global_seq;"
    },
    {
        "line": 479,
        "fullcodeline": "assert(state == STATE_ACCEPTING);"
    },
    {
        "line": 480,
        "fullcodeline": "state = STATE_OPEN;"
    },
    {
        "line": 481,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept success, connect_seq = \" << connect_seq << \", sending READY\" << dendl;"
    },
    {
        "line": 484,
        "fullcodeline": "reply.tag = (reply_tag ? reply_tag : CEPH_MSGR_TAG_READY);"
    },
    {
        "line": 485,
        "fullcodeline": "reply.features = policy.features_supported;"
    },
    {
        "line": 486,
        "fullcodeline": "reply.global_seq = msgr->get_global_seq();"
    },
    {
        "line": 487,
        "fullcodeline": "reply.connect_seq = connect_seq;"
    },
    {
        "line": 488,
        "fullcodeline": "reply.flags = 0;"
    },
    {
        "line": 489,
        "fullcodeline": "reply.authorizer_len = authorizer_reply.length();"
    },
    {
        "line": 493,
        "fullcodeline": "connection_state->set_features((uint64_t)reply.features & (uint64_t)connect.features);"
    },
    {
        "line": 494,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept features \" << connection_state->get_features() << dendl;"
    },
    {
        "line": 496,
        "fullcodeline": "session_security.reset("
    },
    {
        "line": 503,
        "fullcodeline": "msgr->dispatch_queue.queue_accept(connection_state.get());"
    },
    {
        "line": 504,
        "fullcodeline": "msgr->ms_deliver_handle_fast_accept(connection_state.get());"
    },
    {
        "line": 509,
        "fullcodeline": "removed = msgr->accepting_pipes.erase(this);"
    },
    {
        "line": 510,
        "fullcodeline": "assert(removed == 1);"
    },
    {
        "line": 511,
        "fullcodeline": "register_pipe();"
    },
    {
        "line": 512,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 513,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 515,
        "fullcodeline": "r = tcp_write((char*)&reply, sizeof(reply));"
    },
    {
        "line": 538,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 539,
        "fullcodeline": "discard_requeued_up_to(newly_acked_seq);"
    },
    {
        "line": 544,
        "fullcodeline": "ldout(msgr->cct,20) << \"accept done\" << dendl;"
    },
    {
        "line": 546,
        "fullcodeline": "maybe_start_delay_thread();"
    },
    {
        "line": 551,
        "fullcodeline": "ldout(msgr->cct, 10) << \"accept fault after register\" << dendl;"
    },
    {
        "line": 561,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 580,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 582,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 591,
        "fullcodeline": "state = STATE_CLOSED;"
    },
    {
        "line": 592,
        "fullcodeline": "state_closed = true;"
    },
    {
        "line": 593,
        "fullcodeline": "fault();"
    },
    {
        "line": 49,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 63,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 71,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (tcp_read(banner, strlen(CEPH_BANNER)) < 0) {"
    },
    {
        "line": 83,
        "fullcodeline": "if (memcmp(banner, CEPH_BANNER, strlen(CEPH_BANNER))) {"
    },
    {
        "line": 90,
        "fullcodeline": "addrbl.push_back(std::move(tp));"
    },
    {
        "line": 92,
        "fullcodeline": "if (tcp_read(addrbl.c_str(), addrbl.length()) < 0) {"
    },
    {
        "line": 97,
        "fullcodeline": "bufferlist::iterator ti = addrbl.begin();"
    },
    {
        "line": 98,
        "fullcodeline": "::decode(peer_addr, ti);"
    },
    {
        "line": 102,
        "fullcodeline": "if (peer_addr.is_blank_ip()) {"
    },
    {
        "line": 419,
        "fullcodeline": "if ((connect.features & CEPH_FEATURE_RECONNECT_SEQ) && !is_reset_from_peer) {"
    },
    {
        "line": 497,
        "fullcodeline": "get_auth_session_handler(msgr->cct,"
    },
    {
        "line": 516,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 527,
        "fullcodeline": "if (reply_tag == CEPH_MSGR_TAG_SEQ) {"
    },
    {
        "line": 540,
        "fullcodeline": "if (state != STATE_CLOSED) {"
    },
    {
        "line": 562,
        "fullcodeline": "if (state != STATE_CLOSED) {"
    },
    {
        "line": 577,
        "fullcodeline": "return -1;"
    },
    {
        "line": 594,
        "fullcodeline": "return -1;"
    },
    {
        "line": 50,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't write banner\" << dendl;"
    },
    {
        "line": 64,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept failed to getpeername \" << cpp_strerror(errno) << dendl;"
    },
    {
        "line": 72,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't write my+peer addr\" << dendl;"
    },
    {
        "line": 80,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read banner\" << dendl;"
    },
    {
        "line": 84,
        "fullcodeline": "banner[strlen(CEPH_BANNER)] = 0;"
    },
    {
        "line": 85,
        "fullcodeline": "ldout(msgr->cct,1) << \"accept peer sent bad banner '\" << banner << \"' (should be '\" << CEPH_BANNER << \"')\" << dendl;"
    },
    {
        "line": 93,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read peer_addr\" << dendl;"
    },
    {
        "line": 104,
        "fullcodeline": "int port = peer_addr.get_port();"
    },
    {
        "line": 105,
        "fullcodeline": "peer_addr.u = socket_addr.u;"
    },
    {
        "line": 106,
        "fullcodeline": "peer_addr.set_port(port);"
    },
    {
        "line": 107,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept peer addr is really \" << peer_addr"
    },
    {
        "line": 118,
        "fullcodeline": "authorizer.clear();"
    },
    {
        "line": 129,
        "fullcodeline": "ldout(msgr->cct,20) << \"accept got peer connect_seq \" << connect.connect_seq"
    },
    {
        "line": 133,
        "fullcodeline": "msgr->lock.Lock();   // FIXME"
    },
    {
        "line": 134,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 143,
        "fullcodeline": "policy = msgr->get_policy(connect.host_type);"
    },
    {
        "line": 144,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept of host_type \" << connect.host_type"
    },
    {
        "line": 151,
        "fullcodeline": "memset(&reply, 0, sizeof(reply));"
    },
    {
        "line": 152,
        "fullcodeline": "reply.protocol_version = msgr->get_proto_version(peer_type, false);"
    },
    {
        "line": 153,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 156,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept my proto \" << reply.protocol_version"
    },
    {
        "line": 192,
        "fullcodeline": "feat_missing = policy.features_required & ~(uint64_t)connect.features;"
    },
    {
        "line": 201,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 203,
        "fullcodeline": "need_challenge = HAVE_FEATURE(connect.features, CEPHX_V2);"
    },
    {
        "line": 204,
        "fullcodeline": "had_challenge = (bool)authorizer_challenge;"
    },
    {
        "line": 205,
        "fullcodeline": "authorizer_reply.clear();"
    },
    {
        "line": 230,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept:  setting up session_security.\" << dendl;"
    },
    {
        "line": 233,
        "fullcodeline": "msgr->lock.Lock();"
    },
    {
        "line": 234,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 241,
        "fullcodeline": "existing = msgr->_lookup_pipe(peer_addr);"
    },
    {
        "line": 392,
        "fullcodeline": "assert(existing->pipe_lock.is_locked());"
    },
    {
        "line": 393,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 394,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RETRY_SESSION;"
    },
    {
        "line": 395,
        "fullcodeline": "reply.connect_seq = existing->connect_seq + 1;"
    },
    {
        "line": 396,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 397,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 401,
        "fullcodeline": "assert(pipe_lock.is_locked());"
    },
    {
        "line": 402,
        "fullcodeline": "reply.features = ((uint64_t)connect.features & policy.features_supported) | policy.features_required;"
    },
    {
        "line": 403,
        "fullcodeline": "reply.authorizer_len = authorizer_reply.length();"
    },
    {
        "line": 404,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 405,
        "fullcodeline": "r = tcp_write((char*)&reply, sizeof(reply));"
    },
    {
        "line": 420,
        "fullcodeline": "reply_tag = CEPH_MSGR_TAG_SEQ;"
    },
    {
        "line": 421,
        "fullcodeline": "existing_seq = existing->in_seq;"
    },
    {
        "line": 430,
        "fullcodeline": "assert(existing->connection_state);"
    },
    {
        "line": 491,
        "fullcodeline": "reply.flags = reply.flags | CEPH_MSG_CONNECT_LOSSY;"
    },
    {
        "line": 500,
        "fullcodeline": "connection_state->get_features()));"
    },
    {
        "line": 521,
        "fullcodeline": "r = tcp_write(authorizer_reply.c_str(), authorizer_reply.length());"
    },
    {
        "line": 541,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept starting writer, state \" << get_state_name() << dendl;"
    },
    {
        "line": 542,
        "fullcodeline": "start_writer();"
    },
    {
        "line": 554,
        "fullcodeline": "ldout(msgr->cct, 10) << \" sleep for \" << msgr->cct->_conf->ms_inject_internal_delays << dendl;"
    },
    {
        "line": 556,
        "fullcodeline": "t.set_from_double(msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 557,
        "fullcodeline": "t.sleep();"
    },
    {
        "line": 563,
        "fullcodeline": "bool queued = is_queued();"
    },
    {
        "line": 564,
        "fullcodeline": "ldout(msgr->cct, 10) << \"  queued = \" << (int)queued << dendl;"
    },
    {
        "line": 573,
        "fullcodeline": "fault();"
    },
    {
        "line": 585,
        "fullcodeline": "ldout(msgr->cct, 10) << \" sleep for \" << msgr->cct->_conf->ms_inject_internal_delays << dendl;"
    },
    {
        "line": 587,
        "fullcodeline": "t.set_from_double(msgr->cct->_conf->ms_inject_internal_delays);"
    },
    {
        "line": 588,
        "fullcodeline": "t.sleep();"
    },
    {
        "line": 113,
        "fullcodeline": "if (tcp_read((char*)&connect, sizeof(connect)) < 0) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (state != STATE_ACCEPTING) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (connect.protocol_version != reply.protocol_version) {"
    },
    {
        "line": 164,
        "fullcodeline": "if (connect.authorizer_protocol == CEPH_AUTH_CEPHX) {"
    },
    {
        "line": 206,
        "fullcodeline": "if (!msgr->verify_authorizer("
    },
    {
        "line": 237,
        "fullcodeline": "if (state != STATE_ACCEPTING)"
    },
    {
        "line": 406,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 431,
        "fullcodeline": "if (existing->connection_state->clear_pipe(existing))"
    },
    {
        "line": 435,
        "fullcodeline": "msgr->dispatch_queue.queue_reset(connection_state.get());"
    },
    {
        "line": 440,
        "fullcodeline": "connection_state = existing->connection_state;"
    },
    {
        "line": 443,
        "fullcodeline": "connection_state->reset_pipe(this);"
    },
    {
        "line": 453,
        "fullcodeline": "uint64_t replaced_conn_id = conn_id;"
    },
    {
        "line": 454,
        "fullcodeline": "conn_id = existing->conn_id;"
    },
    {
        "line": 455,
        "fullcodeline": "existing->conn_id = replaced_conn_id;"
    },
    {
        "line": 459,
        "fullcodeline": "in_seq = is_reset_from_peer ? 0 : existing->in_seq;"
    },
    {
        "line": 460,
        "fullcodeline": "in_seq_acked = in_seq;"
    },
    {
        "line": 463,
        "fullcodeline": "existing->requeue_sent();"
    },
    {
        "line": 464,
        "fullcodeline": "out_seq = existing->out_seq;"
    },
    {
        "line": 465,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept re-queuing on out_seq \" << out_seq << \" in_seq \" << in_seq << dendl;"
    },
    {
        "line": 522,
        "fullcodeline": "if (r < 0) {"
    },
    {
        "line": 528,
        "fullcodeline": "if (tcp_write((char*)&existing_seq, sizeof(existing_seq)) < 0) {"
    },
    {
        "line": 532,
        "fullcodeline": "if (tcp_read((char*)&newly_acked_seq, sizeof(newly_acked_seq)) < 0) {"
    },
    {
        "line": 574,
        "fullcodeline": "if (queued || replaced)"
    },
    {
        "line": 114,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read connect\" << dendl;"
    },
    {
        "line": 120,
        "fullcodeline": "bp = buffer::create(connect.authorizer_len);"
    },
    {
        "line": 125,
        "fullcodeline": "authorizer.push_back(std::move(bp));"
    },
    {
        "line": 126,
        "fullcodeline": "authorizer_reply.clear();"
    },
    {
        "line": 159,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_BADPROTOVER;"
    },
    {
        "line": 194,
        "fullcodeline": "ldout(msgr->cct,1) << \"peer missing required features \" << std::hex << feat_missing << std::dec << dendl;"
    },
    {
        "line": 195,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_FEATURES;"
    },
    {
        "line": 210,
        "fullcodeline": "!authorizer_valid) {"
    },
    {
        "line": 211,
        "fullcodeline": "pipe_lock.Lock();"
    },
    {
        "line": 224,
        "fullcodeline": "session_security.reset();"
    },
    {
        "line": 243,
        "fullcodeline": "existing->pipe_lock.Lock(true);  // skip lockdep check (we are locking a second Pipe here)"
    },
    {
        "line": 288,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept connect_seq \" << connect.connect_seq"
    },
    {
        "line": 359,
        "fullcodeline": "assert(connect.connect_seq > existing->connect_seq);"
    },
    {
        "line": 360,
        "fullcodeline": "assert(connect.global_seq >= existing->peer_global_seq);"
    },
    {
        "line": 373,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept peer sent cseq \" << connect.connect_seq"
    },
    {
        "line": 409,
        "fullcodeline": "r = tcp_write(authorizer_reply.c_str(), authorizer_reply.length());"
    },
    {
        "line": 432,
        "fullcodeline": "msgr->dispatch_queue.queue_reset(existing->connection_state.get());"
    },
    {
        "line": 467,
        "fullcodeline": "p != existing->out_q.end();"
    },
    {
        "line": 468,
        "fullcodeline": "++p)"
    },
    {
        "line": 469,
        "fullcodeline": "out_q[p->first].splice(out_q[p->first].begin(), p->second);"
    },
    {
        "line": 529,
        "fullcodeline": "ldout(msgr->cct,2) << \"accept write error on in_seq\" << dendl;"
    },
    {
        "line": 533,
        "fullcodeline": "ldout(msgr->cct,2) << \"accept read error on newly_acked_seq\" << dendl;"
    },
    {
        "line": 566,
        "fullcodeline": "state = policy.server ? STATE_STANDBY : STATE_CONNECTING;"
    },
    {
        "line": 575,
        "fullcodeline": "start_writer();"
    },
    {
        "line": 121,
        "fullcodeline": "if (tcp_read(bp.c_str(), connect.authorizer_len) < 0) {"
    },
    {
        "line": 165,
        "fullcodeline": "if (peer_type == CEPH_ENTITY_TYPE_OSD ||"
    },
    {
        "line": 212,
        "fullcodeline": "if (state != STATE_ACCEPTING)"
    },
    {
        "line": 214,
        "fullcodeline": "if (!had_challenge && need_challenge && authorizer_challenge) {"
    },
    {
        "line": 268,
        "fullcodeline": "if (connect.global_seq < existing->peer_global_seq) {"
    },
    {
        "line": 292,
        "fullcodeline": "if (connect.connect_seq == 0 && existing->connect_seq > 0) {"
    },
    {
        "line": 301,
        "fullcodeline": "if (connect.connect_seq < existing->connect_seq) {"
    },
    {
        "line": 308,
        "fullcodeline": "if (connect.connect_seq == existing->connect_seq) {"
    },
    {
        "line": 361,
        "fullcodeline": "if (policy.resetcheck &&   // RESETSESSION only used by servers; peers do not reset each other"
    },
    {
        "line": 410,
        "fullcodeline": "if (r < 0)"
    },
    {
        "line": 446,
        "fullcodeline": "existing->delay_thread->steal_for_pipe(this);"
    },
    {
        "line": 447,
        "fullcodeline": "delay_thread = existing->delay_thread;"
    },
    {
        "line": 448,
        "fullcodeline": "existing->delay_thread = NULL;"
    },
    {
        "line": 449,
        "fullcodeline": "delay_thread->flush();"
    },
    {
        "line": 466,
        "fullcodeline": "for (map<int, list<Message*> >::iterator p = existing->out_q.begin();"
    },
    {
        "line": 122,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept couldn't read connect authorizer\" << dendl;"
    },
    {
        "line": 167,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MGR) {"
    },
    {
        "line": 207,
        "fullcodeline": "connection_state.get(), peer_type, connect.authorizer_protocol, authorizer,"
    },
    {
        "line": 209,
        "fullcodeline": "need_challenge ? &authorizer_challenge : nullptr) ||"
    },
    {
        "line": 215,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept: challenging authorizer \""
    },
    {
        "line": 218,
        "fullcodeline": "assert(authorizer_reply.length());"
    },
    {
        "line": 219,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER;"
    },
    {
        "line": 256,
        "fullcodeline": "existing->get();"
    },
    {
        "line": 257,
        "fullcodeline": "pipe_lock.Unlock();"
    },
    {
        "line": 258,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 259,
        "fullcodeline": "existing->notify_on_dispatch_done = true;"
    },
    {
        "line": 262,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 263,
        "fullcodeline": "existing->put();"
    },
    {
        "line": 264,
        "fullcodeline": "existing = nullptr;"
    },
    {
        "line": 269,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept existing \" << existing << \".gseq \" << existing->peer_global_seq"
    },
    {
        "line": 271,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RETRY_GLOBAL;"
    },
    {
        "line": 272,
        "fullcodeline": "reply.global_seq = existing->peer_global_seq;  // so we can send it below.."
    },
    {
        "line": 273,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 274,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 282,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept replacing existing (lossy) channel (new one lossy=\""
    },
    {
        "line": 284,
        "fullcodeline": "existing->was_session_reset();"
    },
    {
        "line": 290,
        "fullcodeline": "<< \" state \" << existing->get_state_name() << dendl;"
    },
    {
        "line": 293,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept peer reset, then tried to connect to us, replacing\" << dendl;"
    },
    {
        "line": 295,
        "fullcodeline": "is_reset_from_peer = true;"
    },
    {
        "line": 303,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept existing \" << existing << \".cseq \" << existing->connect_seq"
    },
    {
        "line": 362,
        "fullcodeline": "existing->connect_seq == 0) {"
    },
    {
        "line": 363,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept we reset (peer sent cseq \" << connect.connect_seq"
    },
    {
        "line": 366,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RESETSESSION;"
    },
    {
        "line": 367,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 368,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 377,
        "fullcodeline": "else if (connect.connect_seq > 0) {"
    },
    {
        "line": 166,
        "fullcodeline": "peer_type == CEPH_ENTITY_TYPE_MDS ||"
    },
    {
        "line": 168,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_signatures ||"
    },
    {
        "line": 173,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 221,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept: got bad authorizer\" << dendl;"
    },
    {
        "line": 222,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_BADAUTHORIZER;"
    },
    {
        "line": 261,
        "fullcodeline": "existing->cond.Wait(existing->pipe_lock);"
    },
    {
        "line": 277,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept existing \" << existing << \".gseq \" << existing->peer_global_seq"
    },
    {
        "line": 313,
        "fullcodeline": "if (existing->state == STATE_OPEN ||"
    },
    {
        "line": 323,
        "fullcodeline": "if (peer_addr < msgr->my_inst.addr ||"
    },
    {
        "line": 379,
        "fullcodeline": "ldout(msgr->cct,0) << \"accept we reset (peer sent cseq \" << connect.connect_seq << \"), sending RESETSESSION\" << dendl;"
    },
    {
        "line": 380,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 381,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_RESETSESSION;"
    },
    {
        "line": 568,
        "fullcodeline": "state = STATE_STANDBY;"
    },
    {
        "line": 170,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring MSG_AUTH feature bit for cluster\" << dendl;"
    },
    {
        "line": 171,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 174,
        "fullcodeline": "msgr->cct->_conf->cephx_cluster_require_version >= 2) {"
    },
    {
        "line": 175,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring cephx v2 feature bit for cluster\" << dendl;"
    },
    {
        "line": 176,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 179,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_signatures ||"
    },
    {
        "line": 184,
        "fullcodeline": "if (msgr->cct->_conf->cephx_require_version >= 2 ||"
    },
    {
        "line": 297,
        "fullcodeline": "existing->was_session_reset(); // this resets out_queue, msg_ and connect_seq #'s"
    },
    {
        "line": 314,
        "fullcodeline": "existing->state == STATE_STANDBY) {"
    },
    {
        "line": 315,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept connection race, existing \" << existing"
    },
    {
        "line": 326,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept connection race, existing \" << existing << \".cseq \" << existing->connect_seq"
    },
    {
        "line": 335,
        "fullcodeline": "assert(existing->state == STATE_CONNECTING ||"
    },
    {
        "line": 385,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept new session\" << dendl;"
    },
    {
        "line": 386,
        "fullcodeline": "existing = NULL;"
    },
    {
        "line": 570,
        "fullcodeline": "state = STATE_CLOSED;"
    },
    {
        "line": 571,
        "fullcodeline": "state_closed = true;"
    },
    {
        "line": 181,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring MSG_AUTH feature bit for service\" << dendl;"
    },
    {
        "line": 182,
        "fullcodeline": "policy.features_required |= CEPH_FEATURE_MSG_AUTH;"
    },
    {
        "line": 185,
        "fullcodeline": "msgr->cct->_conf->cephx_service_require_version >= 2) {"
    },
    {
        "line": 186,
        "fullcodeline": "ldout(msgr->cct,10) << \"using cephx, requiring cephx v2 feature bit for cluster\" << dendl;"
    },
    {
        "line": 187,
        "fullcodeline": "policy.features_required |= CEPH_FEATUREMASK_CEPHX_V2;"
    },
    {
        "line": 216,
        "fullcodeline": "<< authorizer_reply.length()"
    },
    {
        "line": 328,
        "fullcodeline": "if (!(existing->state == STATE_CONNECTING ||"
    },
    {
        "line": 340,
        "fullcodeline": "ldout(msgr->cct,10) << \"accept connection race, existing \" << existing << \".cseq \" << existing->connect_seq"
    },
    {
        "line": 342,
        "fullcodeline": "assert(peer_addr > msgr->my_inst.addr);"
    },
    {
        "line": 349,
        "fullcodeline": "assert(existing->state == STATE_CONNECTING);"
    },
    {
        "line": 351,
        "fullcodeline": "existing->_send_keepalive();"
    },
    {
        "line": 352,
        "fullcodeline": "reply.tag = CEPH_MSGR_TAG_WAIT;"
    },
    {
        "line": 353,
        "fullcodeline": "existing->pipe_lock.Unlock();"
    },
    {
        "line": 354,
        "fullcodeline": "msgr->lock.Unlock();"
    },
    {
        "line": 330,
        "fullcodeline": "lderr(msgr->cct) << \"accept race bad state, would replace, existing=\""
    },
    {
        "line": 336,
        "fullcodeline": "existing->state == STATE_WAIT);"
    },
    {
        "line": 343,
        "fullcodeline": "if (!(existing->state == STATE_CONNECTING))"
    },
    {
        "line": 329,
        "fullcodeline": "existing->state == STATE_WAIT))"
    },
    {
        "line": 344,
        "fullcodeline": "lderr(msgr->cct) << \"accept race bad state, would send wait, existing=\""
    },
    {
        "line": 331,
        "fullcodeline": "<< existing->get_state_name()"
    },
    {
        "line": 345,
        "fullcodeline": "<< existing->get_state_name()"
    }
]