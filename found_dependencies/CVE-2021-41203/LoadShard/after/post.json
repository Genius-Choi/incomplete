[
    {
        "line": 2,
        "fullcodeline": "CHECK_LT(shard, sss_.size());"
    },
    {
        "line": 9,
        "fullcodeline": "VLOG(1) << \"Reading meta data from file \" << fname << \"...\";"
    },
    {
        "line": 11,
        "fullcodeline": "Status s = open_function_(fname, &table);"
    },
    {
        "line": 17,
        "fullcodeline": "sss_[shard].reset(table);"
    },
    {
        "line": 26,
        "fullcodeline": "status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,"
    },
    {
        "line": 3,
        "fullcodeline": "if (sss_[shard] || !status_.ok()) {"
    },
    {
        "line": 12,
        "fullcodeline": "if (!s.ok()) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (!(table->Get(kSavedTensorSlicesKey, &value) &&"
    },
    {
        "line": 29,
        "fullcodeline": "if (!status_.ok()) return;"
    },
    {
        "line": 13,
        "fullcodeline": "status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \","
    },
    {
        "line": 20,
        "fullcodeline": "status_ = errors::Internal("
    },
    {
        "line": 32,
        "fullcodeline": "status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);"
    },
    {
        "line": 19,
        "fullcodeline": "ParseProtoUnlimited(&sts, value))) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (!status_.ok()) return;"
    },
    {
        "line": 14,
        "fullcodeline": "s.ToString());"
    },
    {
        "line": 36,
        "fullcodeline": "status_ = TensorSlice::BuildTensorSlice(tsp, &ss_slice);"
    },
    {
        "line": 38,
        "fullcodeline": "status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,"
    },
    {
        "line": 37,
        "fullcodeline": "if (!status_.ok()) return;"
    },
    {
        "line": 40,
        "fullcodeline": "if (!status_.ok()) return;"
    }
]