[
    {
        "line": 3,
        "fullcodeline": "AVFilterLink *inlink = ctx->inputs[0];"
    },
    {
        "line": 4,
        "fullcodeline": "AVFilterLink *outlink = ctx->outputs[0];"
    },
    {
        "line": 5,
        "fullcodeline": "ShowSpectrumContext *s = ctx->priv;"
    },
    {
        "line": 9,
        "fullcodeline": "FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);"
    },
    {
        "line": 37,
        "fullcodeline": "if (ff_outlink_get_status(inlink) == AVERROR_EOF &&"
    },
    {
        "line": 62,
        "fullcodeline": "if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {"
    },
    {
        "line": 14,
        "fullcodeline": "ret = ff_inlink_consume_samples(inlink, s->hop_size, s->hop_size, &fin);"
    },
    {
        "line": 54,
        "fullcodeline": "s->outpicref->pts += av_rescale_q(s->consumed, inlink->time_base, outlink->time_base);"
    },
    {
        "line": 55,
        "fullcodeline": "pts = s->outpicref->pts;"
    },
    {
        "line": 69,
        "fullcodeline": "if (ff_inlink_queued_samples(inlink) >= s->hop_size) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 39,
        "fullcodeline": "s->xpos > 0 && s->outpicref) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (s->orientation == VERTICAL) {"
    },
    {
        "line": 56,
        "fullcodeline": "ret = ff_filter_frame(outlink, s->outpicref);"
    },
    {
        "line": 63,
        "fullcodeline": "if (status == AVERROR_EOF) {"
    },
    {
        "line": 18,
        "fullcodeline": "s->consumed += fin->nb_samples;"
    },
    {
        "line": 19,
        "fullcodeline": "ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);"
    },
    {
        "line": 30,
        "fullcodeline": "ret = plot_spectrum_column(inlink, fin);"
    },
    {
        "line": 38,
        "fullcodeline": "s->sliding == FULLFRAME &&"
    },
    {
        "line": 21,
        "fullcodeline": "if (s->data == D_MAGNITUDE)"
    },
    {
        "line": 24,
        "fullcodeline": "if (s->data == D_PHASE)"
    },
    {
        "line": 27,
        "fullcodeline": "if (s->data == D_UPHASE)"
    },
    {
        "line": 32,
        "fullcodeline": "if (ret <= 0)"
    },
    {
        "line": 42,
        "fullcodeline": "for (int i = 0; i < outlink->h; i++) {"
    },
    {
        "line": 22,
        "fullcodeline": "ff_filter_execute(ctx, calc_channel_magnitudes, NULL, NULL, s->nb_display_channels);"
    },
    {
        "line": 25,
        "fullcodeline": "ff_filter_execute(ctx, calc_channel_phases, NULL, NULL, s->nb_display_channels);"
    },
    {
        "line": 28,
        "fullcodeline": "ff_filter_execute(ctx, calc_channel_uphases, NULL, NULL, s->nb_display_channels);"
    },
    {
        "line": 48,
        "fullcodeline": "for (int i = s->xpos; i < outlink->h; i++) {"
    },
    {
        "line": 43,
        "fullcodeline": "memset(s->outpicref->data[0] + i * s->outpicref->linesize[0] + s->xpos,   0, outlink->w - s->xpos);"
    },
    {
        "line": 44,
        "fullcodeline": "memset(s->outpicref->data[1] + i * s->outpicref->linesize[1] + s->xpos, 128, outlink->w - s->xpos);"
    },
    {
        "line": 45,
        "fullcodeline": "memset(s->outpicref->data[2] + i * s->outpicref->linesize[2] + s->xpos, 128, outlink->w - s->xpos);"
    },
    {
        "line": 49,
        "fullcodeline": "memset(s->outpicref->data[0] + i * s->outpicref->linesize[0],   0, outlink->w);"
    },
    {
        "line": 50,
        "fullcodeline": "memset(s->outpicref->data[1] + i * s->outpicref->linesize[1], 128, outlink->w);"
    },
    {
        "line": 51,
        "fullcodeline": "memset(s->outpicref->data[2] + i * s->outpicref->linesize[2], 128, outlink->w);"
    }
]