[
    {
        "line": 31,
        "fullcodeline": "assert(image_info != (const ImageInfo *) NULL);"
    },
    {
        "line": 32,
        "fullcodeline": "assert(image_info->signature == MagickCoreSignature);"
    },
    {
        "line": 33,
        "fullcodeline": "assert(image != (Image *) NULL);"
    },
    {
        "line": 34,
        "fullcodeline": "assert(image->signature == MagickCoreSignature);"
    },
    {
        "line": 37,
        "fullcodeline": "assert(exception != (ExceptionInfo *) NULL);"
    },
    {
        "line": 38,
        "fullcodeline": "assert(exception->signature == MagickCoreSignature);"
    },
    {
        "line": 39,
        "fullcodeline": "status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);"
    },
    {
        "line": 42,
        "fullcodeline": "(void) TransformImageColorspace(image,sRGBColorspace,exception);"
    },
    {
        "line": 48,
        "fullcodeline": "depth=GetImageQuantumDepth(image,MagickTrue);"
    },
    {
        "line": 49,
        "fullcodeline": "packet_size=(size_t) (depth/8);"
    },
    {
        "line": 50,
        "fullcodeline": "pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*"
    },
    {
        "line": 52,
        "fullcodeline": "packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);"
    },
    {
        "line": 53,
        "fullcodeline": "colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*"
    },
    {
        "line": 61,
        "fullcodeline": "q=colormap;"
    },
    {
        "line": 62,
        "fullcodeline": "q=colormap;"
    },
    {
        "line": 80,
        "fullcodeline": "(void) WriteBlob(image,packet_size*image->colors,colormap);"
    },
    {
        "line": 81,
        "fullcodeline": "colormap=(unsigned char *) RelinquishMagickMemory(colormap);"
    },
    {
        "line": 100,
        "fullcodeline": "pixels=(unsigned char *) RelinquishMagickMemory(pixels);"
    },
    {
        "line": 101,
        "fullcodeline": "(void) CloseBlob(image);"
    },
    {
        "line": 35,
        "fullcodeline": "if (image->debug != MagickFalse)"
    },
    {
        "line": 40,
        "fullcodeline": "if (status == MagickFalse)"
    },
    {
        "line": 46,
        "fullcodeline": "if (IsPaletteImage(image) == MagickFalse)"
    },
    {
        "line": 55,
        "fullcodeline": "if ((pixels == (unsigned char *) NULL) ||"
    },
    {
        "line": 63,
        "fullcodeline": "if (image->colors <= 256)"
    },
    {
        "line": 85,
        "fullcodeline": "for (y=0; y < (ssize_t) image->rows; y++)"
    },
    {
        "line": 36,
        "fullcodeline": "(void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);"
    },
    {
        "line": 47,
        "fullcodeline": "(void) SetImageType(image,PaletteType,exception);"
    },
    {
        "line": 56,
        "fullcodeline": "(colormap == (unsigned char *) NULL))"
    },
    {
        "line": 57,
        "fullcodeline": "ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
    },
    {
        "line": 87,
        "fullcodeline": "p=GetVirtualPixels(image,0,y,image->columns,1,exception);"
    },
    {
        "line": 90,
        "fullcodeline": "q=pixels;"
    },
    {
        "line": 98,
        "fullcodeline": "(void) WriteBlob(image,(size_t) (q-pixels),pixels);"
    },
    {
        "line": 64,
        "fullcodeline": "for (i=0; i < (ssize_t) image->colors; i++)"
    },
    {
        "line": 88,
        "fullcodeline": "if (p == (const Quantum *) NULL)"
    },
    {
        "line": 91,
        "fullcodeline": "for (x=0; x < (ssize_t) image->columns; x++)"
    },
    {
        "line": 66,
        "fullcodeline": "*q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);"
    },
    {
        "line": 67,
        "fullcodeline": "*q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);"
    },
    {
        "line": 68,
        "fullcodeline": "*q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);"
    },
    {
        "line": 71,
        "fullcodeline": "for (i=0; i < (ssize_t) image->colors; i++)"
    },
    {
        "line": 95,
        "fullcodeline": "*q++=(unsigned char) GetPixelIndex(image,p);"
    },
    {
        "line": 96,
        "fullcodeline": "p+=GetPixelChannels(image);"
    },
    {
        "line": 73,
        "fullcodeline": "*q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);"
    },
    {
        "line": 74,
        "fullcodeline": "*q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);"
    },
    {
        "line": 75,
        "fullcodeline": "*q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);"
    },
    {
        "line": 76,
        "fullcodeline": "*q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;"
    },
    {
        "line": 77,
        "fullcodeline": "*q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);"
    },
    {
        "line": 78,
        "fullcodeline": "*q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);"
    },
    {
        "line": 93,
        "fullcodeline": "if (image->colors > 256)"
    },
    {
        "line": 94,
        "fullcodeline": "*q++=(unsigned char) ((size_t) GetPixelIndex(image,p) >> 8);"
    }
]