[
    {
        "line": 3,
        "fullcodeline": "int64_t total_samples = 0, infilesize;"
    },
    {
        "line": 7,
        "fullcodeline": "int format_chunk = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "CLEAR (WaveHeader);"
    },
    {
        "line": 11,
        "fullcodeline": "infilesize = DoGetFileSize (infile);"
    },
    {
        "line": 12,
        "fullcodeline": "memcpy (&filehdr, fourcc, 4);"
    },
    {
        "line": 27,
        "fullcodeline": "WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);"
    },
    {
        "line": 14,
        "fullcodeline": "if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||"
    },
    {
        "line": 16,
        "fullcodeline": "memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {"
    },
    {
        "line": 17,
        "fullcodeline": "error_line (\"%s is not a valid .W64 file!\", infilename);"
    },
    {
        "line": 29,
        "fullcodeline": "if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&"
    },
    {
        "line": 30,
        "fullcodeline": "filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {"
    },
    {
        "line": 51,
        "fullcodeline": "WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);"
    },
    {
        "line": 52,
        "fullcodeline": "chunk_header.ckSize -= sizeof (chunk_header);"
    },
    {
        "line": 229,
        "fullcodeline": "if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {"
    },
    {
        "line": 15,
        "fullcodeline": "bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||"
    },
    {
        "line": 230,
        "fullcodeline": "error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 40,
        "fullcodeline": "if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||"
    },
    {
        "line": 41,
        "fullcodeline": "bcount != sizeof (Wave64ChunkHeader)) {"
    },
    {
        "line": 57,
        "fullcodeline": "if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {"
    },
    {
        "line": 58,
        "fullcodeline": "int supported = TRUE, format;"
    },
    {
        "line": 65,
        "fullcodeline": "chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;"
    },
    {
        "line": 79,
        "fullcodeline": "WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);"
    },
    {
        "line": 100,
        "fullcodeline": "format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?"
    },
    {
        "line": 103,
        "fullcodeline": "config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?"
    },
    {
        "line": 20,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 21,
        "fullcodeline": "!WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {"
    },
    {
        "line": 126,
        "fullcodeline": "if (chunk_header.ckSize < 40) {"
    },
    {
        "line": 22,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 67,
        "fullcodeline": "if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||"
    },
    {
        "line": 69,
        "fullcodeline": "bcount != chunk_header.ckSize) {"
    },
    {
        "line": 82,
        "fullcodeline": "error_line (\"format tag size = %d\", chunk_header.ckSize);"
    },
    {
        "line": 83,
        "fullcodeline": "error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\","
    },
    {
        "line": 85,
        "fullcodeline": "error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\","
    },
    {
        "line": 97,
        "fullcodeline": "if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)"
    },
    {
        "line": 98,
        "fullcodeline": "config->qmode |= QMODE_ADOBE_MODE;"
    },
    {
        "line": 106,
        "fullcodeline": "if (format != 1 && format != 3)"
    },
    {
        "line": 107,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 109,
        "fullcodeline": "if (format == 3 && config->bits_per_sample != 32)"
    },
    {
        "line": 110,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 112,
        "fullcodeline": "if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||"
    },
    {
        "line": 115,
        "fullcodeline": "WaveHeader.BlockAlign % WaveHeader.NumChannels)"
    },
    {
        "line": 116,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 118,
        "fullcodeline": "if (config->bits_per_sample < 1 || config->bits_per_sample > 32)"
    },
    {
        "line": 119,
        "fullcodeline": "supported = FALSE;"
    },
    {
        "line": 144,
        "fullcodeline": "config->float_norm_exp = 127;"
    },
    {
        "line": 45,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 46,
        "fullcodeline": "!WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {"
    },
    {
        "line": 68,
        "fullcodeline": "!DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||"
    },
    {
        "line": 88,
        "fullcodeline": "if (chunk_header.ckSize > 16)"
    },
    {
        "line": 92,
        "fullcodeline": "if (chunk_header.ckSize > 20)"
    },
    {
        "line": 114,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||"
    },
    {
        "line": 154,
        "fullcodeline": "if (config->float_norm_exp == 127)"
    },
    {
        "line": 161,
        "fullcodeline": "else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop"
    },
    {
        "line": 195,
        "fullcodeline": "config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;"
    },
    {
        "line": 196,
        "fullcodeline": "config->num_channels = WaveHeader.NumChannels;"
    },
    {
        "line": 197,
        "fullcodeline": "config->sample_rate = WaveHeader.SampleRate;"
    },
    {
        "line": 47,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 89,
        "fullcodeline": "error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,"
    },
    {
        "line": 93,
        "fullcodeline": "error_line (\"ChannelMask = %x, SubFormat = %d\","
    },
    {
        "line": 113,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||"
    },
    {
        "line": 127,
        "fullcodeline": "if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {"
    },
    {
        "line": 136,
        "fullcodeline": "else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {"
    },
    {
        "line": 163,
        "fullcodeline": "if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk"
    },
    {
        "line": 201,
        "fullcodeline": "int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;"
    },
    {
        "line": 209,
        "fullcodeline": "buff = malloc (bytes_to_copy);"
    },
    {
        "line": 73,
        "fullcodeline": "else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 74,
        "fullcodeline": "!WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {"
    },
    {
        "line": 128,
        "fullcodeline": "if (WaveHeader.NumChannels <= 2)"
    },
    {
        "line": 145,
        "fullcodeline": "else if ((config->qmode & QMODE_ADOBE_MODE) &&"
    },
    {
        "line": 146,
        "fullcodeline": "WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {"
    },
    {
        "line": 157,
        "fullcodeline": "error_line (\"data format: %d-bit integers stored in %d byte(s)\","
    },
    {
        "line": 168,
        "fullcodeline": "if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {"
    },
    {
        "line": 169,
        "fullcodeline": "config->qmode |= QMODE_IGNORE_LENGTH;"
    },
    {
        "line": 75,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 129,
        "fullcodeline": "config->channel_mask = 0x5 - WaveHeader.NumChannels;"
    },
    {
        "line": 147,
        "fullcodeline": "if (WaveHeader.BitsPerSample == 24)"
    },
    {
        "line": 158,
        "fullcodeline": "config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);"
    },
    {
        "line": 171,
        "fullcodeline": "if (infilesize && DoGetFilePosition (infile) != -1)"
    },
    {
        "line": 182,
        "fullcodeline": "total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;"
    },
    {
        "line": 204,
        "fullcodeline": "if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {"
    },
    {
        "line": 212,
        "fullcodeline": "error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\","
    },
    {
        "line": 216,
        "fullcodeline": "if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||"
    },
    {
        "line": 218,
        "fullcodeline": "(!(config->qmode & QMODE_NO_STORE_WRAPPER) &&"
    },
    {
        "line": 148,
        "fullcodeline": "config->float_norm_exp = 127 + 23;"
    },
    {
        "line": 172,
        "fullcodeline": "total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;"
    },
    {
        "line": 184,
        "fullcodeline": "if (!total_samples) {"
    },
    {
        "line": 189,
        "fullcodeline": "if (total_samples > MAX_WAVPACK_SAMPLES) {"
    },
    {
        "line": 217,
        "fullcodeline": "bcount != bytes_to_copy ||"
    },
    {
        "line": 219,
        "fullcodeline": "!WavpackAddWrapper (wpc, buff, bytes_to_copy))) {"
    },
    {
        "line": 220,
        "fullcodeline": "error_line (\"%s\", WavpackGetErrorMessage (wpc));"
    },
    {
        "line": 130,
        "fullcodeline": "else if (WaveHeader.NumChannels <= 18)"
    },
    {
        "line": 141,
        "fullcodeline": "config->channel_mask = WaveHeader.ChannelMask;"
    },
    {
        "line": 174,
        "fullcodeline": "total_samples = -1;"
    },
    {
        "line": 177,
        "fullcodeline": "if (infilesize && infilesize - chunk_header.ckSize > 16777216) {"
    },
    {
        "line": 131,
        "fullcodeline": "config->channel_mask = (1 << WaveHeader.NumChannels) - 1;"
    },
    {
        "line": 149,
        "fullcodeline": "else if (WaveHeader.BitsPerSample == 32)"
    },
    {
        "line": 133,
        "fullcodeline": "config->channel_mask = 0x3ffff;"
    },
    {
        "line": 150,
        "fullcodeline": "config->float_norm_exp = 127 + 15;"
    }
]