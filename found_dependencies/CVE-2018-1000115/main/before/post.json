[
    {
        "line": 3,
        "fullcodeline": "bool lock_memory = false;"
    },
    {
        "line": 4,
        "fullcodeline": "bool do_daemonize = false;"
    },
    {
        "line": 5,
        "fullcodeline": "bool preallocate = false;"
    },
    {
        "line": 6,
        "fullcodeline": "int maxcore = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "char *username = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "char *pid_file = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "char unit = '\\0';"
    },
    {
        "line": 13,
        "fullcodeline": "int size_max = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "int retval = EXIT_SUCCESS;"
    },
    {
        "line": 16,
        "fullcodeline": "static int *l_socket = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "static int *u_socket = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "bool protocol_specified = false;"
    },
    {
        "line": 21,
        "fullcodeline": "bool tcp_specified = false;"
    },
    {
        "line": 22,
        "fullcodeline": "bool udp_specified = false;"
    },
    {
        "line": 23,
        "fullcodeline": "bool start_lru_maintainer = true;"
    },
    {
        "line": 24,
        "fullcodeline": "bool start_lru_crawler = true;"
    },
    {
        "line": 25,
        "fullcodeline": "bool start_assoc_maint = true;"
    },
    {
        "line": 26,
        "fullcodeline": "enum hashfunc_type hash_type = MURMUR3_HASH;"
    },
    {
        "line": 28,
        "fullcodeline": "uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];"
    },
    {
        "line": 29,
        "fullcodeline": "bool use_slab_sizes = false;"
    },
    {
        "line": 30,
        "fullcodeline": "char *slab_sizes_unparsed = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "bool slab_chunk_size_changed = false;"
    },
    {
        "line": 96,
        "fullcodeline": "char *const subopts_tokens[] = {"
    },
    {
        "line": 160,
        "fullcodeline": "signal(SIGINT, sig_handler);"
    },
    {
        "line": 161,
        "fullcodeline": "signal(SIGTERM, sig_handler);"
    },
    {
        "line": 164,
        "fullcodeline": "settings_init();"
    },
    {
        "line": 186,
        "fullcodeline": "init_lru_maintainer();"
    },
    {
        "line": 189,
        "fullcodeline": "setbuf(stderr, NULL);"
    },
    {
        "line": 191,
        "fullcodeline": "char *shortopts ="
    },
    {
        "line": 1084,
        "fullcodeline": "main_base = event_init();"
    },
    {
        "line": 1088,
        "fullcodeline": "logger_init();"
    },
    {
        "line": 1089,
        "fullcodeline": "stats_init();"
    },
    {
        "line": 1090,
        "fullcodeline": "assoc_init(settings.hashpower_init);"
    },
    {
        "line": 1091,
        "fullcodeline": "conn_init();"
    },
    {
        "line": 1092,
        "fullcodeline": "slabs_init(settings.maxbytes, settings.factor, preallocate,"
    },
    {
        "line": 1135,
        "fullcodeline": "memcached_thread_init(settings.num_threads, NULL);"
    },
    {
        "line": 1136,
        "fullcodeline": "init_lru_crawler(NULL);"
    },
    {
        "line": 1170,
        "fullcodeline": "clock_handler(0, 0, 0);"
    },
    {
        "line": 1235,
        "fullcodeline": "usleep(1000);"
    },
    {
        "line": 1251,
        "fullcodeline": "uriencode_init();"
    },
    {
        "line": 1258,
        "fullcodeline": "stop_assoc_maintenance_thread();"
    },
    {
        "line": 1272,
        "fullcodeline": "event_base_free(main_base);"
    },
    {
        "line": 155,
        "fullcodeline": "if (!sanitycheck()) {"
    },
    {
        "line": 264,
        "fullcodeline": "while (-1 != (c = getopt(argc, argv, shortopts))) {"
    },
    {
        "line": 870,
        "fullcodeline": "if (settings.item_size_max < 1024) {"
    },
    {
        "line": 874,
        "fullcodeline": "if (settings.item_size_max > (settings.maxbytes / 2)) {"
    },
    {
        "line": 878,
        "fullcodeline": "if (settings.item_size_max > (1024 * 1024 * 1024)) {"
    },
    {
        "line": 882,
        "fullcodeline": "if (settings.item_size_max > 1024 * 1024) {"
    },
    {
        "line": 889,
        "fullcodeline": "if (settings.slab_chunk_size_max > settings.item_size_max) {"
    },
    {
        "line": 895,
        "fullcodeline": "if (settings.item_size_max % settings.slab_chunk_size_max != 0) {"
    },
    {
        "line": 901,
        "fullcodeline": "if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {"
    },
    {
        "line": 935,
        "fullcodeline": "if (slab_sizes_unparsed != NULL) {"
    },
    {
        "line": 943,
        "fullcodeline": "if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {"
    },
    {
        "line": 948,
        "fullcodeline": "if (settings.temp_lru && !start_lru_maintainer) {"
    },
    {
        "line": 953,
        "fullcodeline": "if (hash_init(hash_type) != 0) {"
    },
    {
        "line": 962,
        "fullcodeline": "if (settings.inter != NULL && strchr(settings.inter, ',')) {"
    },
    {
        "line": 979,
        "fullcodeline": "if (tcp_specified && settings.port != 0 && !udp_specified) {"
    },
    {
        "line": 985,
        "fullcodeline": "if (maxcore != 0) {"
    },
    {
        "line": 1016,
        "fullcodeline": "if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {"
    },
    {
        "line": 1029,
        "fullcodeline": "if (getuid() == 0 || geteuid() == 0) {"
    },
    {
        "line": 1093,
        "fullcodeline": "use_slab_sizes ? slab_sizes : NULL);"
    },
    {
        "line": 1125,
        "fullcodeline": "if (sigignore(SIGPIPE) == -1) {"
    },
    {
        "line": 1139,
        "fullcodeline": "if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {"
    },
    {
        "line": 1142,
        "fullcodeline": "if (start_lru_crawler && start_item_crawler_thread() != 0) {"
    },
    {
        "line": 1154,
        "fullcodeline": "if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {"
    },
    {
        "line": 1160,
        "fullcodeline": "if (settings.slab_reassign &&"
    },
    {
        "line": 1165,
        "fullcodeline": "if (settings.idle_timeout && start_conn_timeout_thread() == -1) {"
    },
    {
        "line": 1173,
        "fullcodeline": "if (settings.socketpath != NULL) {"
    },
    {
        "line": 1182,
        "fullcodeline": "if (settings.socketpath == NULL) {"
    },
    {
        "line": 1236,
        "fullcodeline": "if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {"
    },
    {
        "line": 1241,
        "fullcodeline": "if (pid_file != NULL) {"
    },
    {
        "line": 1254,
        "fullcodeline": "if (event_base_loop(main_base, 0) != 0) {"
    },
    {
        "line": 871,
        "fullcodeline": "fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");"
    },
    {
        "line": 872,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 875,
        "fullcodeline": "fprintf(stderr, \"Cannot set item size limit higher than 1/2 of memory max.\\n\");"
    },
    {
        "line": 876,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 879,
        "fullcodeline": "fprintf(stderr, \"Cannot set item size limit higher than a gigabyte.\\n\");"
    },
    {
        "line": 880,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 890,
        "fullcodeline": "fprintf(stderr, \"slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\\n\","
    },
    {
        "line": 892,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 896,
        "fullcodeline": "fprintf(stderr, \"-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\\n\","
    },
    {
        "line": 898,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 902,
        "fullcodeline": "fprintf(stderr, \"slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\\n\","
    },
    {
        "line": 904,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 944,
        "fullcodeline": "fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");"
    },
    {
        "line": 945,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 949,
        "fullcodeline": "fprintf(stderr, \"temporary_ttl requires lru_maintainer to be enabled\\n\");"
    },
    {
        "line": 950,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 954,
        "fullcodeline": "fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");"
    },
    {
        "line": 955,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 963,
        "fullcodeline": "settings.num_threads_per_udp = 1;"
    },
    {
        "line": 980,
        "fullcodeline": "settings.udpport = settings.port;"
    },
    {
        "line": 1017,
        "fullcodeline": "fprintf(stderr, \"failed to getrlimit number of files\\n\");"
    },
    {
        "line": 1018,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1046,
        "fullcodeline": "init_sasl();"
    },
    {
        "line": 1070,
        "fullcodeline": "fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");"
    },
    {
        "line": 1126,
        "fullcodeline": "perror(\"failed to ignore SIGPIPE; sigaction\");"
    },
    {
        "line": 1127,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1140,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1143,
        "fullcodeline": "fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");"
    },
    {
        "line": 1144,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1156,
        "fullcodeline": "fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");"
    },
    {
        "line": 1161,
        "fullcodeline": "start_slab_maintenance_thread() == -1) {"
    },
    {
        "line": 1162,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1166,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1174,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 1183,
        "fullcodeline": "const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");"
    },
    {
        "line": 1184,
        "fullcodeline": "char *temp_portnumber_filename = NULL;"
    },
    {
        "line": 1186,
        "fullcodeline": "FILE *portnumber_file = NULL;"
    },
    {
        "line": 1202,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 1217,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 1237,
        "fullcodeline": "fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");"
    },
    {
        "line": 1238,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1242,
        "fullcodeline": "save_pid(pid_file);"
    },
    {
        "line": 1247,
        "fullcodeline": "drop_privileges();"
    },
    {
        "line": 1255,
        "fullcodeline": "retval = EXIT_FAILURE;"
    },
    {
        "line": 1262,
        "fullcodeline": "remove_pidfile(pid_file);"
    },
    {
        "line": 1265,
        "fullcodeline": "free(settings.inter);"
    },
    {
        "line": 1267,
        "fullcodeline": "free(l_socket);"
    },
    {
        "line": 1269,
        "fullcodeline": "free(u_socket);"
    },
    {
        "line": 97,
        "fullcodeline": "[MAXCONNS_FAST] = \"maxconns_fast\","
    },
    {
        "line": 98,
        "fullcodeline": "[HASHPOWER_INIT] = \"hashpower\","
    },
    {
        "line": 99,
        "fullcodeline": "[NO_HASHEXPAND] = \"no_hashexpand\","
    },
    {
        "line": 100,
        "fullcodeline": "[SLAB_REASSIGN] = \"slab_reassign\","
    },
    {
        "line": 101,
        "fullcodeline": "[SLAB_AUTOMOVE] = \"slab_automove\","
    },
    {
        "line": 102,
        "fullcodeline": "[SLAB_AUTOMOVE_RATIO] = \"slab_automove_ratio\","
    },
    {
        "line": 103,
        "fullcodeline": "[SLAB_AUTOMOVE_WINDOW] = \"slab_automove_window\","
    },
    {
        "line": 104,
        "fullcodeline": "[TAIL_REPAIR_TIME] = \"tail_repair_time\","
    },
    {
        "line": 105,
        "fullcodeline": "[HASH_ALGORITHM] = \"hash_algorithm\","
    },
    {
        "line": 106,
        "fullcodeline": "[LRU_CRAWLER] = \"lru_crawler\","
    },
    {
        "line": 107,
        "fullcodeline": "[LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\","
    },
    {
        "line": 108,
        "fullcodeline": "[LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\","
    },
    {
        "line": 109,
        "fullcodeline": "[LRU_MAINTAINER] = \"lru_maintainer\","
    },
    {
        "line": 110,
        "fullcodeline": "[HOT_LRU_PCT] = \"hot_lru_pct\","
    },
    {
        "line": 111,
        "fullcodeline": "[WARM_LRU_PCT] = \"warm_lru_pct\","
    },
    {
        "line": 112,
        "fullcodeline": "[HOT_MAX_FACTOR] = \"hot_max_factor\","
    },
    {
        "line": 113,
        "fullcodeline": "[WARM_MAX_FACTOR] = \"warm_max_factor\","
    },
    {
        "line": 114,
        "fullcodeline": "[TEMPORARY_TTL] = \"temporary_ttl\","
    },
    {
        "line": 115,
        "fullcodeline": "[IDLE_TIMEOUT] = \"idle_timeout\","
    },
    {
        "line": 116,
        "fullcodeline": "[WATCHER_LOGBUF_SIZE] = \"watcher_logbuf_size\","
    },
    {
        "line": 117,
        "fullcodeline": "[WORKER_LOGBUF_SIZE] = \"worker_logbuf_size\","
    },
    {
        "line": 118,
        "fullcodeline": "[SLAB_SIZES] = \"slab_sizes\","
    },
    {
        "line": 119,
        "fullcodeline": "[SLAB_CHUNK_MAX] = \"slab_chunk_max\","
    },
    {
        "line": 120,
        "fullcodeline": "[TRACK_SIZES] = \"track_sizes\","
    },
    {
        "line": 121,
        "fullcodeline": "[NO_INLINE_ASCII_RESP] = \"no_inline_ascii_resp\","
    },
    {
        "line": 122,
        "fullcodeline": "[MODERN] = \"modern\","
    },
    {
        "line": 123,
        "fullcodeline": "[NO_MODERN] = \"no_modern\","
    },
    {
        "line": 124,
        "fullcodeline": "[NO_CHUNKED_ITEMS] = \"no_chunked_items\","
    },
    {
        "line": 125,
        "fullcodeline": "[NO_SLAB_REASSIGN] = \"no_slab_reassign\","
    },
    {
        "line": 126,
        "fullcodeline": "[NO_SLAB_AUTOMOVE] = \"no_slab_automove\","
    },
    {
        "line": 127,
        "fullcodeline": "[NO_MAXCONNS_FAST] = \"no_maxconns_fast\","
    },
    {
        "line": 128,
        "fullcodeline": "[INLINE_ASCII_RESP] = \"inline_ascii_resp\","
    },
    {
        "line": 129,
        "fullcodeline": "[NO_LRU_CRAWLER] = \"no_lru_crawler\","
    },
    {
        "line": 130,
        "fullcodeline": "[NO_LRU_MAINTAINER] = \"no_lru_maintainer\","
    },
    {
        "line": 131,
        "fullcodeline": "[NO_DROP_PRIVILEGES] = \"no_drop_privileges\","
    },
    {
        "line": 883,
        "fullcodeline": "if (!slab_chunk_size_changed) {"
    },
    {
        "line": 936,
        "fullcodeline": "if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {"
    },
    {
        "line": 965,
        "fullcodeline": "settings.num_threads_per_udp = settings.num_threads;"
    },
    {
        "line": 969,
        "fullcodeline": "if (!protocol_specified) {"
    },
    {
        "line": 991,
        "fullcodeline": "if (getrlimit(RLIMIT_CORE, &rlim) == 0) {"
    },
    {
        "line": 1005,
        "fullcodeline": "if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {"
    },
    {
        "line": 1020,
        "fullcodeline": "rlim.rlim_cur = settings.maxconns;"
    },
    {
        "line": 1021,
        "fullcodeline": "rlim.rlim_max = settings.maxconns;"
    },
    {
        "line": 1030,
        "fullcodeline": "if (username == 0 || *username == '\\0') {"
    },
    {
        "line": 1034,
        "fullcodeline": "if ((pw = getpwnam(username)) == 0) {"
    },
    {
        "line": 1038,
        "fullcodeline": "if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {"
    },
    {
        "line": 1052,
        "fullcodeline": "if (sigignore(SIGHUP) == -1) {"
    },
    {
        "line": 1055,
        "fullcodeline": "if (daemonize(maxcore, settings.verbose) == -1) {"
    },
    {
        "line": 1175,
        "fullcodeline": "if (server_socket_unix(settings.socketpath,settings.access)) {"
    },
    {
        "line": 1188,
        "fullcodeline": "if (portnumber_filename != NULL) {"
    },
    {
        "line": 1203,
        "fullcodeline": "if (settings.port && server_sockets(settings.port, tcp_transport,"
    },
    {
        "line": 1218,
        "fullcodeline": "if (settings.udpport && server_sockets(settings.udpport, udp_transport,"
    },
    {
        "line": 269,
        "fullcodeline": "settings.shutdown_command = true;"
    },
    {
        "line": 274,
        "fullcodeline": "settings.access= strtol(optarg,NULL,8);"
    },
    {
        "line": 278,
        "fullcodeline": "settings.udpport = atoi(optarg);"
    },
    {
        "line": 279,
        "fullcodeline": "udp_specified = true;"
    },
    {
        "line": 282,
        "fullcodeline": "settings.port = atoi(optarg);"
    },
    {
        "line": 283,
        "fullcodeline": "tcp_specified = true;"
    },
    {
        "line": 286,
        "fullcodeline": "settings.socketpath = optarg;"
    },
    {
        "line": 289,
        "fullcodeline": "settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;"
    },
    {
        "line": 292,
        "fullcodeline": "settings.evict_to_free = 0;"
    },
    {
        "line": 295,
        "fullcodeline": "settings.maxconns = atoi(optarg);"
    },
    {
        "line": 302,
        "fullcodeline": "usage();"
    },
    {
        "line": 303,
        "fullcodeline": "exit(EXIT_SUCCESS);"
    },
    {
        "line": 305,
        "fullcodeline": "usage_license();"
    },
    {
        "line": 306,
        "fullcodeline": "exit(EXIT_SUCCESS);"
    },
    {
        "line": 309,
        "fullcodeline": "exit(EXIT_SUCCESS);"
    },
    {
        "line": 311,
        "fullcodeline": "lock_memory = true;"
    },
    {
        "line": 335,
        "fullcodeline": "do_daemonize = true;"
    },
    {
        "line": 338,
        "fullcodeline": "maxcore = 1;"
    },
    {
        "line": 341,
        "fullcodeline": "settings.reqs_per_event = atoi(optarg);"
    },
    {
        "line": 348,
        "fullcodeline": "username = optarg;"
    },
    {
        "line": 351,
        "fullcodeline": "pid_file = optarg;"
    },
    {
        "line": 354,
        "fullcodeline": "settings.factor = atof(optarg);"
    },
    {
        "line": 361,
        "fullcodeline": "settings.chunk_size = atoi(optarg);"
    },
    {
        "line": 368,
        "fullcodeline": "settings.num_threads = atoi(optarg);"
    },
    {
        "line": 389,
        "fullcodeline": "settings.prefix_delimiter = optarg[0];"
    },
    {
        "line": 390,
        "fullcodeline": "settings.detail_enabled = 1;"
    },
    {
        "line": 402,
        "fullcodeline": "settings.use_cas = false;"
    },
    {
        "line": 405,
        "fullcodeline": "settings.backlog = atoi(optarg);"
    },
    {
        "line": 408,
        "fullcodeline": "protocol_specified = true;"
    },
    {
        "line": 422,
        "fullcodeline": "buf = strdup(optarg);"
    },
    {
        "line": 423,
        "fullcodeline": "unit = buf[strlen(buf)-1];"
    },
    {
        "line": 436,
        "fullcodeline": "free(buf);"
    },
    {
        "line": 440,
        "fullcodeline": "fprintf(stderr, \"This server is not built with SASL support.\\n\");"
    },
    {
        "line": 441,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 443,
        "fullcodeline": "settings.sasl = true;"
    },
    {
        "line": 446,
        "fullcodeline": "settings.flush_enabled = false;"
    },
    {
        "line": 449,
        "fullcodeline": "settings.dump_enabled = false;"
    },
    {
        "line": 452,
        "fullcodeline": "subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */"
    },
    {
        "line": 862,
        "fullcodeline": "free(subopts_orig);"
    },
    {
        "line": 865,
        "fullcodeline": "fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);"
    },
    {
        "line": 885,
        "fullcodeline": "settings.slab_chunk_size_max = settings.slab_page_size / 2;"
    },
    {
        "line": 937,
        "fullcodeline": "use_slab_sizes = true;"
    },
    {
        "line": 970,
        "fullcodeline": "settings.binding_protocol = binary_prot;"
    },
    {
        "line": 981,
        "fullcodeline": "} else if (udp_specified && settings.udpport != 0 && !tcp_specified) {"
    },
    {
        "line": 992,
        "fullcodeline": "rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;"
    },
    {
        "line": 1006,
        "fullcodeline": "fprintf(stderr, \"failed to ensure corefile creation\\n\");"
    },
    {
        "line": 1007,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1022,
        "fullcodeline": "if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {"
    },
    {
        "line": 1031,
        "fullcodeline": "fprintf(stderr, \"can't run as root without the -u switch\\n\");"
    },
    {
        "line": 1032,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 1035,
        "fullcodeline": "fprintf(stderr, \"can't find the user %s to switch to\\n\", username);"
    },
    {
        "line": 1036,
        "fullcodeline": "exit(EX_NOUSER);"
    },
    {
        "line": 1039,
        "fullcodeline": "fprintf(stderr, \"failed to assume identity of user %s\\n\", username);"
    },
    {
        "line": 1040,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1053,
        "fullcodeline": "perror(\"Failed to ignore SIGHUP\");"
    },
    {
        "line": 1056,
        "fullcodeline": "fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");"
    },
    {
        "line": 1057,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1176,
        "fullcodeline": "vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);"
    },
    {
        "line": 1177,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1189,
        "fullcodeline": "len = strlen(portnumber_filename)+4+1;"
    },
    {
        "line": 1190,
        "fullcodeline": "temp_portnumber_filename = malloc(len);"
    },
    {
        "line": 1191,
        "fullcodeline": "snprintf(temp_portnumber_filename,"
    },
    {
        "line": 1195,
        "fullcodeline": "portnumber_file = fopen(temp_portnumber_filename, \"a\");"
    },
    {
        "line": 1205,
        "fullcodeline": "vperror(\"failed to listen on TCP port %d\", settings.port);"
    },
    {
        "line": 1206,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1220,
        "fullcodeline": "vperror(\"failed to listen on UDP port %d\", settings.udpport);"
    },
    {
        "line": 1221,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1225,
        "fullcodeline": "fclose(portnumber_file);"
    },
    {
        "line": 1226,
        "fullcodeline": "rename(temp_portnumber_filename, portnumber_filename);"
    },
    {
        "line": 1229,
        "fullcodeline": "free(temp_portnumber_filename);"
    },
    {
        "line": 296,
        "fullcodeline": "if (settings.maxconns <= 0) {"
    },
    {
        "line": 317,
        "fullcodeline": "if (settings.inter != NULL) {"
    },
    {
        "line": 342,
        "fullcodeline": "if (settings.reqs_per_event == 0) {"
    },
    {
        "line": 355,
        "fullcodeline": "if (settings.factor <= 1.0) {"
    },
    {
        "line": 362,
        "fullcodeline": "if (settings.chunk_size == 0) {"
    },
    {
        "line": 369,
        "fullcodeline": "if (settings.num_threads <= 0) {"
    },
    {
        "line": 377,
        "fullcodeline": "if (settings.num_threads > 64) {"
    },
    {
        "line": 385,
        "fullcodeline": "if (! optarg || ! optarg[0]) {"
    },
    {
        "line": 393,
        "fullcodeline": "if (enable_large_pages() == 0) {"
    },
    {
        "line": 409,
        "fullcodeline": "if (strcmp(optarg, \"auto\") == 0) {"
    },
    {
        "line": 424,
        "fullcodeline": "if (unit == 'k' || unit == 'm' ||"
    },
    {
        "line": 454,
        "fullcodeline": "while (*subopts != '\\0') {"
    },
    {
        "line": 939,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 982,
        "fullcodeline": "settings.port = settings.udpport;"
    },
    {
        "line": 993,
        "fullcodeline": "if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {"
    },
    {
        "line": 1023,
        "fullcodeline": "fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");"
    },
    {
        "line": 1024,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1196,
        "fullcodeline": "if (portnumber_file == NULL) {"
    },
    {
        "line": 297,
        "fullcodeline": "fprintf(stderr, \"Maximum connections must be greater than 0\\n\");"
    },
    {
        "line": 321,
        "fullcodeline": "size_t len = strlen(settings.inter) + strlen(optarg) + 2;"
    },
    {
        "line": 322,
        "fullcodeline": "char *p = malloc(len);"
    },
    {
        "line": 327,
        "fullcodeline": "snprintf(p, len, \"%s,%s\", settings.inter, optarg);"
    },
    {
        "line": 328,
        "fullcodeline": "free(settings.inter);"
    },
    {
        "line": 329,
        "fullcodeline": "settings.inter = p;"
    },
    {
        "line": 343,
        "fullcodeline": "fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");"
    },
    {
        "line": 356,
        "fullcodeline": "fprintf(stderr, \"Factor must be greater than 1\\n\");"
    },
    {
        "line": 363,
        "fullcodeline": "fprintf(stderr, \"Chunk size must be greater than 0\\n\");"
    },
    {
        "line": 370,
        "fullcodeline": "fprintf(stderr, \"Number of threads must be greater than 0\\n\");"
    },
    {
        "line": 378,
        "fullcodeline": "fprintf(stderr, \"WARNING: Setting a high number of worker\""
    },
    {
        "line": 386,
        "fullcodeline": "fprintf(stderr, \"No delimiter specified\\n\");"
    },
    {
        "line": 394,
        "fullcodeline": "preallocate = true;"
    },
    {
        "line": 410,
        "fullcodeline": "settings.binding_protocol = negotiating_prot;"
    },
    {
        "line": 425,
        "fullcodeline": "unit == 'K' || unit == 'M') {"
    },
    {
        "line": 426,
        "fullcodeline": "buf[strlen(buf)-1] = '\\0';"
    },
    {
        "line": 427,
        "fullcodeline": "size_max = atoi(buf);"
    },
    {
        "line": 432,
        "fullcodeline": "settings.item_size_max = size_max;"
    },
    {
        "line": 972,
        "fullcodeline": "if (settings.binding_protocol != binary_prot) {"
    },
    {
        "line": 995,
        "fullcodeline": "rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;"
    },
    {
        "line": 996,
        "fullcodeline": "(void)setrlimit(RLIMIT_CORE, &rlim_new);"
    },
    {
        "line": 1197,
        "fullcodeline": "fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\","
    },
    {
        "line": 318,
        "fullcodeline": "if (strstr(settings.inter, optarg) != NULL) {"
    },
    {
        "line": 323,
        "fullcodeline": "if (p == NULL) {"
    },
    {
        "line": 331,
        "fullcodeline": "settings.inter= strdup(optarg);"
    },
    {
        "line": 396,
        "fullcodeline": "fprintf(stderr, \"Cannot enable large pages on this system\\n\""
    },
    {
        "line": 428,
        "fullcodeline": "if (unit == 'k' || unit == 'K')"
    },
    {
        "line": 430,
        "fullcodeline": "if (unit == 'm' || unit == 'M')"
    },
    {
        "line": 434,
        "fullcodeline": "settings.item_size_max = atoi(buf);"
    },
    {
        "line": 456,
        "fullcodeline": "switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {"
    },
    {
        "line": 973,
        "fullcodeline": "fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");"
    },
    {
        "line": 974,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 1198,
        "fullcodeline": "temp_portnumber_filename, strerror(errno));"
    },
    {
        "line": 324,
        "fullcodeline": "fprintf(stderr, \"Failed to allocate memory\\n\");"
    },
    {
        "line": 411,
        "fullcodeline": "} else if (strcmp(optarg, \"binary\") == 0) {"
    },
    {
        "line": 429,
        "fullcodeline": "size_max *= 1024;"
    },
    {
        "line": 431,
        "fullcodeline": "size_max *= 1024 * 1024;"
    },
    {
        "line": 458,
        "fullcodeline": "settings.maxconns_fast = true;"
    },
    {
        "line": 465,
        "fullcodeline": "settings.hashpower_init = atoi(subopts_value);"
    },
    {
        "line": 478,
        "fullcodeline": "start_assoc_maint = false;"
    },
    {
        "line": 481,
        "fullcodeline": "settings.slab_reassign = true;"
    },
    {
        "line": 488,
        "fullcodeline": "settings.slab_automove = atoi(subopts_value);"
    },
    {
        "line": 499,
        "fullcodeline": "settings.slab_automove_ratio = atof(subopts_value);"
    },
    {
        "line": 510,
        "fullcodeline": "settings.slab_automove_window = atoi(subopts_value);"
    },
    {
        "line": 521,
        "fullcodeline": "settings.tail_repair_time = atoi(subopts_value);"
    },
    {
        "line": 542,
        "fullcodeline": "start_lru_crawler = true;"
    },
    {
        "line": 549,
        "fullcodeline": "settings.lru_crawler_sleep = atoi(subopts_value);"
    },
    {
        "line": 564,
        "fullcodeline": "settings.lru_crawler_tocrawl = tocrawl;"
    },
    {
        "line": 567,
        "fullcodeline": "start_lru_maintainer = true;"
    },
    {
        "line": 568,
        "fullcodeline": "settings.lru_segmented = true;"
    },
    {
        "line": 575,
        "fullcodeline": "settings.hot_lru_pct = atoi(subopts_value);"
    },
    {
        "line": 586,
        "fullcodeline": "settings.warm_lru_pct = atoi(subopts_value);"
    },
    {
        "line": 597,
        "fullcodeline": "settings.hot_max_factor = atof(subopts_value);"
    },
    {
        "line": 608,
        "fullcodeline": "settings.warm_max_factor = atof(subopts_value);"
    },
    {
        "line": 619,
        "fullcodeline": "settings.temp_lru = true;"
    },
    {
        "line": 620,
        "fullcodeline": "settings.temporary_ttl = atoi(subopts_value);"
    },
    {
        "line": 627,
        "fullcodeline": "settings.idle_timeout = atoi(subopts_value);"
    },
    {
        "line": 638,
        "fullcodeline": "settings.logger_watcher_buf_size *= 1024; /* kilobytes */"
    },
    {
        "line": 649,
        "fullcodeline": "settings.logger_buf_size *= 1024; /* kilobytes */"
    },
    {
        "line": 651,
        "fullcodeline": "slab_sizes_unparsed = subopts_value;"
    },
    {
        "line": 660,
        "fullcodeline": "slab_chunk_size_changed = true;"
    },
    {
        "line": 663,
        "fullcodeline": "item_stats_sizes_init();"
    },
    {
        "line": 666,
        "fullcodeline": "settings.inline_ascii_response = false;"
    },
    {
        "line": 669,
        "fullcodeline": "settings.inline_ascii_response = true;"
    },
    {
        "line": 675,
        "fullcodeline": "settings.slab_reassign = false;"
    },
    {
        "line": 678,
        "fullcodeline": "settings.slab_automove = 0;"
    },
    {
        "line": 681,
        "fullcodeline": "settings.maxconns_fast = false;"
    },
    {
        "line": 684,
        "fullcodeline": "settings.lru_crawler = false;"
    },
    {
        "line": 685,
        "fullcodeline": "start_lru_crawler = false;"
    },
    {
        "line": 688,
        "fullcodeline": "start_lru_maintainer = false;"
    },
    {
        "line": 689,
        "fullcodeline": "settings.lru_segmented = false;"
    },
    {
        "line": 839,
        "fullcodeline": "settings.slab_reassign = false;"
    },
    {
        "line": 840,
        "fullcodeline": "settings.slab_automove = 0;"
    },
    {
        "line": 841,
        "fullcodeline": "settings.maxconns_fast = false;"
    },
    {
        "line": 842,
        "fullcodeline": "settings.inline_ascii_response = true;"
    },
    {
        "line": 843,
        "fullcodeline": "settings.lru_segmented = false;"
    },
    {
        "line": 844,
        "fullcodeline": "hash_type = JENKINS_HASH;"
    },
    {
        "line": 845,
        "fullcodeline": "start_lru_crawler = false;"
    },
    {
        "line": 846,
        "fullcodeline": "start_lru_maintainer = false;"
    },
    {
        "line": 849,
        "fullcodeline": "settings.drop_privileges = false;"
    },
    {
        "line": 857,
        "fullcodeline": "printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);"
    },
    {
        "line": 412,
        "fullcodeline": "settings.binding_protocol = binary_prot;"
    },
    {
        "line": 461,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 466,
        "fullcodeline": "if (settings.hashpower_init < 12) {"
    },
    {
        "line": 484,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 489,
        "fullcodeline": "if (settings.slab_automove < 0 || settings.slab_automove > 2) {"
    },
    {
        "line": 495,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 500,
        "fullcodeline": "if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {"
    },
    {
        "line": 506,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 511,
        "fullcodeline": "if (settings.slab_automove_window < 3) {"
    },
    {
        "line": 517,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 522,
        "fullcodeline": "if (settings.tail_repair_time < 10) {"
    },
    {
        "line": 528,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 532,
        "fullcodeline": "if (strcmp(subopts_value, \"jenkins\") == 0) {"
    },
    {
        "line": 545,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 550,
        "fullcodeline": "if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {"
    },
    {
        "line": 556,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 560,
        "fullcodeline": "if (!safe_strtoul(subopts_value, &tocrawl)) {"
    },
    {
        "line": 571,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 576,
        "fullcodeline": "if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {"
    },
    {
        "line": 582,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 587,
        "fullcodeline": "if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {"
    },
    {
        "line": 593,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 598,
        "fullcodeline": "if (settings.hot_max_factor <= 0) {"
    },
    {
        "line": 604,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 609,
        "fullcodeline": "if (settings.warm_max_factor <= 0) {"
    },
    {
        "line": 615,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 623,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 630,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 634,
        "fullcodeline": "if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {"
    },
    {
        "line": 641,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 645,
        "fullcodeline": "if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {"
    },
    {
        "line": 654,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 657,
        "fullcodeline": "if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {"
    },
    {
        "line": 836,
        "fullcodeline": "if (!slab_chunk_size_changed) {"
    },
    {
        "line": 462,
        "fullcodeline": "fprintf(stderr, \"Missing numeric argument for hashpower\\n\");"
    },
    {
        "line": 467,
        "fullcodeline": "fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\","
    },
    {
        "line": 485,
        "fullcodeline": "settings.slab_automove = 1;"
    },
    {
        "line": 490,
        "fullcodeline": "fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");"
    },
    {
        "line": 496,
        "fullcodeline": "fprintf(stderr, \"Missing slab_automove_ratio argument\\n\");"
    },
    {
        "line": 501,
        "fullcodeline": "fprintf(stderr, \"slab_automove_ratio must be > 0 and < 1\\n\");"
    },
    {
        "line": 507,
        "fullcodeline": "fprintf(stderr, \"Missing slab_automove_window argument\\n\");"
    },
    {
        "line": 512,
        "fullcodeline": "fprintf(stderr, \"slab_automove_window must be > 2\\n\");"
    },
    {
        "line": 518,
        "fullcodeline": "fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");"
    },
    {
        "line": 523,
        "fullcodeline": "fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");"
    },
    {
        "line": 529,
        "fullcodeline": "fprintf(stderr, \"Missing hash_algorithm argument\\n\");"
    },
    {
        "line": 533,
        "fullcodeline": "hash_type = JENKINS_HASH;"
    },
    {
        "line": 546,
        "fullcodeline": "fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");"
    },
    {
        "line": 551,
        "fullcodeline": "fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");"
    },
    {
        "line": 557,
        "fullcodeline": "fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");"
    },
    {
        "line": 561,
        "fullcodeline": "fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");"
    },
    {
        "line": 572,
        "fullcodeline": "fprintf(stderr, \"Missing hot_lru_pct argument\\n\");"
    },
    {
        "line": 577,
        "fullcodeline": "fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");"
    },
    {
        "line": 583,
        "fullcodeline": "fprintf(stderr, \"Missing warm_lru_pct argument\\n\");"
    },
    {
        "line": 588,
        "fullcodeline": "fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");"
    },
    {
        "line": 594,
        "fullcodeline": "fprintf(stderr, \"Missing hot_max_factor argument\\n\");"
    },
    {
        "line": 599,
        "fullcodeline": "fprintf(stderr, \"hot_max_factor must be > 0\\n\");"
    },
    {
        "line": 605,
        "fullcodeline": "fprintf(stderr, \"Missing warm_max_factor argument\\n\");"
    },
    {
        "line": 610,
        "fullcodeline": "fprintf(stderr, \"warm_max_factor must be > 0\\n\");"
    },
    {
        "line": 616,
        "fullcodeline": "fprintf(stderr, \"Missing temporary_ttl argument\\n\");"
    },
    {
        "line": 624,
        "fullcodeline": "fprintf(stderr, \"Missing numeric argument for idle_timeout\\n\");"
    },
    {
        "line": 631,
        "fullcodeline": "fprintf(stderr, \"Missing watcher_logbuf_size argument\\n\");"
    },
    {
        "line": 635,
        "fullcodeline": "fprintf(stderr, \"could not parse argument to watcher_logbuf_size\\n\");"
    },
    {
        "line": 642,
        "fullcodeline": "fprintf(stderr, \"Missing worker_logbuf_size argument\\n\");"
    },
    {
        "line": 646,
        "fullcodeline": "fprintf(stderr, \"could not parse argument to worker_logbuf_size\\n\");"
    },
    {
        "line": 655,
        "fullcodeline": "fprintf(stderr, \"Missing slab_chunk_max argument\\n\");"
    },
    {
        "line": 658,
        "fullcodeline": "fprintf(stderr, \"could not parse argument to slab_chunk_max\\n\");"
    },
    {
        "line": 413,
        "fullcodeline": "} else if (strcmp(optarg, \"ascii\") == 0) {"
    },
    {
        "line": 414,
        "fullcodeline": "settings.binding_protocol = ascii_prot;"
    },
    {
        "line": 470,
        "fullcodeline": "} else if (settings.hashpower_init > 32) {"
    },
    {
        "line": 534,
        "fullcodeline": "} else if (strcmp(subopts_value, \"murmur3\") == 0) {"
    },
    {
        "line": 416,
        "fullcodeline": "fprintf(stderr, \"Invalid value for binding protocol: %s\\n\""
    },
    {
        "line": 418,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 471,
        "fullcodeline": "fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\""
    },
    {
        "line": 535,
        "fullcodeline": "hash_type = MURMUR3_HASH;"
    },
    {
        "line": 537,
        "fullcodeline": "fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");"
    }
]