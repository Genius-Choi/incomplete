[
    {
        "line": 3,
        "fullcodeline": "bool lock_memory = false;"
    },
    {
        "line": 4,
        "fullcodeline": "bool do_daemonize = false;"
    },
    {
        "line": 5,
        "fullcodeline": "bool preallocate = false;"
    },
    {
        "line": 6,
        "fullcodeline": "int maxcore = 0;"
    },
    {
        "line": 7,
        "fullcodeline": "char *username = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "char *pid_file = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "char unit = '\\0';"
    },
    {
        "line": 13,
        "fullcodeline": "int size_max = 0;"
    },
    {
        "line": 14,
        "fullcodeline": "int retval = EXIT_SUCCESS;"
    },
    {
        "line": 16,
        "fullcodeline": "static int *l_socket = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "static int *u_socket = NULL;"
    },
    {
        "line": 20,
        "fullcodeline": "bool protocol_specified = false;"
    },
    {
        "line": 21,
        "fullcodeline": "bool tcp_specified = false;"
    },
    {
        "line": 22,
        "fullcodeline": "bool udp_specified = false;"
    },
    {
        "line": 23,
        "fullcodeline": "bool start_lru_maintainer = true;"
    },
    {
        "line": 24,
        "fullcodeline": "bool start_lru_crawler = true;"
    },
    {
        "line": 25,
        "fullcodeline": "bool start_assoc_maint = true;"
    },
    {
        "line": 26,
        "fullcodeline": "enum hashfunc_type hash_type = MURMUR3_HASH;"
    },
    {
        "line": 28,
        "fullcodeline": "uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];"
    },
    {
        "line": 29,
        "fullcodeline": "bool use_slab_sizes = false;"
    },
    {
        "line": 30,
        "fullcodeline": "char *slab_sizes_unparsed = NULL;"
    },
    {
        "line": 31,
        "fullcodeline": "bool slab_chunk_size_changed = false;"
    },
    {
        "line": 96,
        "fullcodeline": "char *const subopts_tokens[] = {"
    },
    {
        "line": 160,
        "fullcodeline": "signal(SIGINT, sig_handler);"
    },
    {
        "line": 161,
        "fullcodeline": "signal(SIGTERM, sig_handler);"
    },
    {
        "line": 189,
        "fullcodeline": "setbuf(stderr, NULL);"
    },
    {
        "line": 191,
        "fullcodeline": "char *shortopts ="
    },
    {
        "line": 1082,
        "fullcodeline": "main_base = event_init();"
    },
    {
        "line": 1133,
        "fullcodeline": "memcached_thread_init(settings.num_threads, NULL);"
    },
    {
        "line": 1134,
        "fullcodeline": "init_lru_crawler(NULL);"
    },
    {
        "line": 155,
        "fullcodeline": "if (!sanitycheck()) {"
    },
    {
        "line": 870,
        "fullcodeline": "if (settings.item_size_max < 1024) {"
    },
    {
        "line": 874,
        "fullcodeline": "if (settings.item_size_max > (settings.maxbytes / 2)) {"
    },
    {
        "line": 878,
        "fullcodeline": "if (settings.item_size_max > (1024 * 1024 * 1024)) {"
    },
    {
        "line": 882,
        "fullcodeline": "if (settings.item_size_max > 1024 * 1024) {"
    },
    {
        "line": 889,
        "fullcodeline": "if (settings.slab_chunk_size_max > settings.item_size_max) {"
    },
    {
        "line": 935,
        "fullcodeline": "if (slab_sizes_unparsed != NULL) {"
    },
    {
        "line": 983,
        "fullcodeline": "if (maxcore != 0) {"
    },
    {
        "line": 1171,
        "fullcodeline": "if (settings.socketpath != NULL) {"
    },
    {
        "line": 1180,
        "fullcodeline": "if (settings.socketpath == NULL) {"
    },
    {
        "line": 1239,
        "fullcodeline": "if (pid_file != NULL) {"
    },
    {
        "line": 264,
        "fullcodeline": "while (-1 != (c = getopt(argc, argv, shortopts))) {"
    },
    {
        "line": 871,
        "fullcodeline": "fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");"
    },
    {
        "line": 872,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 875,
        "fullcodeline": "fprintf(stderr, \"Cannot set item size limit higher than 1/2 of memory max.\\n\");"
    },
    {
        "line": 876,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 879,
        "fullcodeline": "fprintf(stderr, \"Cannot set item size limit higher than a gigabyte.\\n\");"
    },
    {
        "line": 880,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 890,
        "fullcodeline": "fprintf(stderr, \"slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\\n\","
    },
    {
        "line": 892,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 895,
        "fullcodeline": "if (settings.item_size_max % settings.slab_chunk_size_max != 0) {"
    },
    {
        "line": 896,
        "fullcodeline": "fprintf(stderr, \"-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\\n\","
    },
    {
        "line": 898,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 901,
        "fullcodeline": "if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {"
    },
    {
        "line": 902,
        "fullcodeline": "fprintf(stderr, \"slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\\n\","
    },
    {
        "line": 904,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 944,
        "fullcodeline": "fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");"
    },
    {
        "line": 945,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 948,
        "fullcodeline": "if (settings.temp_lru && !start_lru_maintainer) {"
    },
    {
        "line": 949,
        "fullcodeline": "fprintf(stderr, \"temporary_ttl requires lru_maintainer to be enabled\\n\");"
    },
    {
        "line": 950,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 953,
        "fullcodeline": "if (hash_init(hash_type) != 0) {"
    },
    {
        "line": 954,
        "fullcodeline": "fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");"
    },
    {
        "line": 955,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 962,
        "fullcodeline": "if (settings.inter != NULL && strchr(settings.inter, ',')) {"
    },
    {
        "line": 979,
        "fullcodeline": "if (udp_specified && settings.udpport != 0 && !tcp_specified) {"
    },
    {
        "line": 980,
        "fullcodeline": "settings.port = settings.udpport;"
    },
    {
        "line": 1014,
        "fullcodeline": "if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {"
    },
    {
        "line": 1015,
        "fullcodeline": "fprintf(stderr, \"failed to getrlimit number of files\\n\");"
    },
    {
        "line": 1016,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1027,
        "fullcodeline": "if (getuid() == 0 || geteuid() == 0) {"
    },
    {
        "line": 1068,
        "fullcodeline": "fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");"
    },
    {
        "line": 1123,
        "fullcodeline": "if (sigignore(SIGPIPE) == -1) {"
    },
    {
        "line": 1125,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1137,
        "fullcodeline": "if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {"
    },
    {
        "line": 1138,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1140,
        "fullcodeline": "if (start_lru_crawler && start_item_crawler_thread() != 0) {"
    },
    {
        "line": 1141,
        "fullcodeline": "fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");"
    },
    {
        "line": 1142,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1152,
        "fullcodeline": "if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {"
    },
    {
        "line": 1159,
        "fullcodeline": "start_slab_maintenance_thread() == -1) {"
    },
    {
        "line": 1160,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1163,
        "fullcodeline": "if (settings.idle_timeout && start_conn_timeout_thread() == -1) {"
    },
    {
        "line": 1164,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1172,
        "fullcodeline": "errno = 0;"
    },
    {
        "line": 1181,
        "fullcodeline": "const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");"
    },
    {
        "line": 1182,
        "fullcodeline": "char *temp_portnumber_filename = NULL;"
    },
    {
        "line": 1184,
        "fullcodeline": "FILE *portnumber_file = NULL;"
    },
    {
        "line": 1234,
        "fullcodeline": "if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {"
    },
    {
        "line": 1236,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1240,
        "fullcodeline": "save_pid(pid_file);"
    },
    {
        "line": 1252,
        "fullcodeline": "if (event_base_loop(main_base, 0) != 0) {"
    },
    {
        "line": 1253,
        "fullcodeline": "retval = EXIT_FAILURE;"
    },
    {
        "line": 97,
        "fullcodeline": "[MAXCONNS_FAST] = \"maxconns_fast\","
    },
    {
        "line": 98,
        "fullcodeline": "[HASHPOWER_INIT] = \"hashpower\","
    },
    {
        "line": 99,
        "fullcodeline": "[NO_HASHEXPAND] = \"no_hashexpand\","
    },
    {
        "line": 100,
        "fullcodeline": "[SLAB_REASSIGN] = \"slab_reassign\","
    },
    {
        "line": 101,
        "fullcodeline": "[SLAB_AUTOMOVE] = \"slab_automove\","
    },
    {
        "line": 102,
        "fullcodeline": "[SLAB_AUTOMOVE_RATIO] = \"slab_automove_ratio\","
    },
    {
        "line": 103,
        "fullcodeline": "[SLAB_AUTOMOVE_WINDOW] = \"slab_automove_window\","
    },
    {
        "line": 104,
        "fullcodeline": "[TAIL_REPAIR_TIME] = \"tail_repair_time\","
    },
    {
        "line": 105,
        "fullcodeline": "[HASH_ALGORITHM] = \"hash_algorithm\","
    },
    {
        "line": 106,
        "fullcodeline": "[LRU_CRAWLER] = \"lru_crawler\","
    },
    {
        "line": 107,
        "fullcodeline": "[LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\","
    },
    {
        "line": 108,
        "fullcodeline": "[LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\","
    },
    {
        "line": 109,
        "fullcodeline": "[LRU_MAINTAINER] = \"lru_maintainer\","
    },
    {
        "line": 110,
        "fullcodeline": "[HOT_LRU_PCT] = \"hot_lru_pct\","
    },
    {
        "line": 111,
        "fullcodeline": "[WARM_LRU_PCT] = \"warm_lru_pct\","
    },
    {
        "line": 112,
        "fullcodeline": "[HOT_MAX_FACTOR] = \"hot_max_factor\","
    },
    {
        "line": 113,
        "fullcodeline": "[WARM_MAX_FACTOR] = \"warm_max_factor\","
    },
    {
        "line": 114,
        "fullcodeline": "[TEMPORARY_TTL] = \"temporary_ttl\","
    },
    {
        "line": 115,
        "fullcodeline": "[IDLE_TIMEOUT] = \"idle_timeout\","
    },
    {
        "line": 116,
        "fullcodeline": "[WATCHER_LOGBUF_SIZE] = \"watcher_logbuf_size\","
    },
    {
        "line": 117,
        "fullcodeline": "[WORKER_LOGBUF_SIZE] = \"worker_logbuf_size\","
    },
    {
        "line": 118,
        "fullcodeline": "[SLAB_SIZES] = \"slab_sizes\","
    },
    {
        "line": 119,
        "fullcodeline": "[SLAB_CHUNK_MAX] = \"slab_chunk_max\","
    },
    {
        "line": 120,
        "fullcodeline": "[TRACK_SIZES] = \"track_sizes\","
    },
    {
        "line": 121,
        "fullcodeline": "[NO_INLINE_ASCII_RESP] = \"no_inline_ascii_resp\","
    },
    {
        "line": 122,
        "fullcodeline": "[MODERN] = \"modern\","
    },
    {
        "line": 123,
        "fullcodeline": "[NO_MODERN] = \"no_modern\","
    },
    {
        "line": 124,
        "fullcodeline": "[NO_CHUNKED_ITEMS] = \"no_chunked_items\","
    },
    {
        "line": 125,
        "fullcodeline": "[NO_SLAB_REASSIGN] = \"no_slab_reassign\","
    },
    {
        "line": 126,
        "fullcodeline": "[NO_SLAB_AUTOMOVE] = \"no_slab_automove\","
    },
    {
        "line": 127,
        "fullcodeline": "[NO_MAXCONNS_FAST] = \"no_maxconns_fast\","
    },
    {
        "line": 128,
        "fullcodeline": "[INLINE_ASCII_RESP] = \"inline_ascii_resp\","
    },
    {
        "line": 129,
        "fullcodeline": "[NO_LRU_CRAWLER] = \"no_lru_crawler\","
    },
    {
        "line": 130,
        "fullcodeline": "[NO_LRU_MAINTAINER] = \"no_lru_maintainer\","
    },
    {
        "line": 131,
        "fullcodeline": "[NO_DROP_PRIVILEGES] = \"no_drop_privileges\","
    },
    {
        "line": 936,
        "fullcodeline": "if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {"
    },
    {
        "line": 1018,
        "fullcodeline": "rlim.rlim_cur = settings.maxconns;"
    },
    {
        "line": 1019,
        "fullcodeline": "rlim.rlim_max = settings.maxconns;"
    },
    {
        "line": 1173,
        "fullcodeline": "if (server_socket_unix(settings.socketpath,settings.access)) {"
    },
    {
        "line": 1186,
        "fullcodeline": "if (portnumber_filename != NULL) {"
    },
    {
        "line": 1201,
        "fullcodeline": "if (settings.port && server_sockets(settings.port, tcp_transport,"
    },
    {
        "line": 1216,
        "fullcodeline": "if (settings.udpport && server_sockets(settings.udpport, udp_transport,"
    },
    {
        "line": 274,
        "fullcodeline": "settings.access= strtol(optarg,NULL,8);"
    },
    {
        "line": 278,
        "fullcodeline": "settings.udpport = atoi(optarg);"
    },
    {
        "line": 279,
        "fullcodeline": "udp_specified = true;"
    },
    {
        "line": 282,
        "fullcodeline": "settings.port = atoi(optarg);"
    },
    {
        "line": 283,
        "fullcodeline": "tcp_specified = true;"
    },
    {
        "line": 286,
        "fullcodeline": "settings.socketpath = optarg;"
    },
    {
        "line": 289,
        "fullcodeline": "settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;"
    },
    {
        "line": 295,
        "fullcodeline": "settings.maxconns = atoi(optarg);"
    },
    {
        "line": 303,
        "fullcodeline": "exit(EXIT_SUCCESS);"
    },
    {
        "line": 306,
        "fullcodeline": "exit(EXIT_SUCCESS);"
    },
    {
        "line": 309,
        "fullcodeline": "exit(EXIT_SUCCESS);"
    },
    {
        "line": 314,
        "fullcodeline": "settings.verbose++;"
    },
    {
        "line": 338,
        "fullcodeline": "maxcore = 1;"
    },
    {
        "line": 341,
        "fullcodeline": "settings.reqs_per_event = atoi(optarg);"
    },
    {
        "line": 348,
        "fullcodeline": "username = optarg;"
    },
    {
        "line": 351,
        "fullcodeline": "pid_file = optarg;"
    },
    {
        "line": 354,
        "fullcodeline": "settings.factor = atof(optarg);"
    },
    {
        "line": 361,
        "fullcodeline": "settings.chunk_size = atoi(optarg);"
    },
    {
        "line": 368,
        "fullcodeline": "settings.num_threads = atoi(optarg);"
    },
    {
        "line": 408,
        "fullcodeline": "protocol_specified = true;"
    },
    {
        "line": 422,
        "fullcodeline": "buf = strdup(optarg);"
    },
    {
        "line": 423,
        "fullcodeline": "unit = buf[strlen(buf)-1];"
    },
    {
        "line": 440,
        "fullcodeline": "fprintf(stderr, \"This server is not built with SASL support.\\n\");"
    },
    {
        "line": 441,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 452,
        "fullcodeline": "subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */"
    },
    {
        "line": 885,
        "fullcodeline": "settings.slab_chunk_size_max = settings.slab_page_size / 2;"
    },
    {
        "line": 989,
        "fullcodeline": "if (getrlimit(RLIMIT_CORE, &rlim) == 0) {"
    },
    {
        "line": 990,
        "fullcodeline": "rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;"
    },
    {
        "line": 1003,
        "fullcodeline": "if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {"
    },
    {
        "line": 1004,
        "fullcodeline": "fprintf(stderr, \"failed to ensure corefile creation\\n\");"
    },
    {
        "line": 1005,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1028,
        "fullcodeline": "if (username == 0 || *username == '\\0') {"
    },
    {
        "line": 1029,
        "fullcodeline": "fprintf(stderr, \"can't run as root without the -u switch\\n\");"
    },
    {
        "line": 1032,
        "fullcodeline": "if ((pw = getpwnam(username)) == 0) {"
    },
    {
        "line": 1033,
        "fullcodeline": "fprintf(stderr, \"can't find the user %s to switch to\\n\", username);"
    },
    {
        "line": 1034,
        "fullcodeline": "exit(EX_NOUSER);"
    },
    {
        "line": 1036,
        "fullcodeline": "if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {"
    },
    {
        "line": 1037,
        "fullcodeline": "fprintf(stderr, \"failed to assume identity of user %s\\n\", username);"
    },
    {
        "line": 1038,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1050,
        "fullcodeline": "if (sigignore(SIGHUP) == -1) {"
    },
    {
        "line": 1053,
        "fullcodeline": "if (daemonize(maxcore, settings.verbose) == -1) {"
    },
    {
        "line": 1054,
        "fullcodeline": "fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");"
    },
    {
        "line": 1055,
        "fullcodeline": "exit(EXIT_FAILURE);"
    },
    {
        "line": 1174,
        "fullcodeline": "vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);"
    },
    {
        "line": 1175,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1187,
        "fullcodeline": "len = strlen(portnumber_filename)+4+1;"
    },
    {
        "line": 1188,
        "fullcodeline": "temp_portnumber_filename = malloc(len);"
    },
    {
        "line": 1189,
        "fullcodeline": "snprintf(temp_portnumber_filename,"
    },
    {
        "line": 1193,
        "fullcodeline": "portnumber_file = fopen(temp_portnumber_filename, \"a\");"
    },
    {
        "line": 1204,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1224,
        "fullcodeline": "rename(temp_portnumber_filename, portnumber_filename);"
    },
    {
        "line": 296,
        "fullcodeline": "if (settings.maxconns <= 0) {"
    },
    {
        "line": 317,
        "fullcodeline": "if (settings.inter != NULL) {"
    },
    {
        "line": 355,
        "fullcodeline": "if (settings.factor <= 1.0) {"
    },
    {
        "line": 369,
        "fullcodeline": "if (settings.num_threads <= 0) {"
    },
    {
        "line": 377,
        "fullcodeline": "if (settings.num_threads > 64) {"
    },
    {
        "line": 405,
        "fullcodeline": "settings.backlog = atoi(optarg);"
    },
    {
        "line": 424,
        "fullcodeline": "if (unit == 'k' || unit == 'm' ||"
    },
    {
        "line": 454,
        "fullcodeline": "while (*subopts != '\\0') {"
    },
    {
        "line": 939,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 1020,
        "fullcodeline": "if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {"
    },
    {
        "line": 1021,
        "fullcodeline": "fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");"
    },
    {
        "line": 1022,
        "fullcodeline": "exit(EX_OSERR);"
    },
    {
        "line": 1194,
        "fullcodeline": "if (portnumber_file == NULL) {"
    },
    {
        "line": 321,
        "fullcodeline": "size_t len = strlen(settings.inter) + strlen(optarg) + 2;"
    },
    {
        "line": 322,
        "fullcodeline": "char *p = malloc(len);"
    },
    {
        "line": 327,
        "fullcodeline": "snprintf(p, len, \"%s,%s\", settings.inter, optarg);"
    },
    {
        "line": 329,
        "fullcodeline": "settings.inter = p;"
    },
    {
        "line": 378,
        "fullcodeline": "fprintf(stderr, \"WARNING: Setting a high number of worker\""
    },
    {
        "line": 385,
        "fullcodeline": "if (! optarg || ! optarg[0]) {"
    },
    {
        "line": 394,
        "fullcodeline": "preallocate = true;"
    },
    {
        "line": 409,
        "fullcodeline": "if (strcmp(optarg, \"auto\") == 0) {"
    },
    {
        "line": 410,
        "fullcodeline": "settings.binding_protocol = negotiating_prot;"
    },
    {
        "line": 425,
        "fullcodeline": "unit == 'K' || unit == 'M') {"
    },
    {
        "line": 426,
        "fullcodeline": "buf[strlen(buf)-1] = '\\0';"
    },
    {
        "line": 427,
        "fullcodeline": "size_max = atoi(buf);"
    },
    {
        "line": 432,
        "fullcodeline": "settings.item_size_max = size_max;"
    },
    {
        "line": 991,
        "fullcodeline": "if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {"
    },
    {
        "line": 993,
        "fullcodeline": "rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;"
    },
    {
        "line": 1195,
        "fullcodeline": "fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\","
    },
    {
        "line": 318,
        "fullcodeline": "if (strstr(settings.inter, optarg) != NULL) {"
    },
    {
        "line": 323,
        "fullcodeline": "if (p == NULL) {"
    },
    {
        "line": 331,
        "fullcodeline": "settings.inter= strdup(optarg);"
    },
    {
        "line": 428,
        "fullcodeline": "if (unit == 'k' || unit == 'K')"
    },
    {
        "line": 430,
        "fullcodeline": "if (unit == 'm' || unit == 'M')"
    },
    {
        "line": 434,
        "fullcodeline": "settings.item_size_max = atoi(buf);"
    },
    {
        "line": 456,
        "fullcodeline": "switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {"
    },
    {
        "line": 973,
        "fullcodeline": "fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");"
    },
    {
        "line": 974,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 994,
        "fullcodeline": "(void)setrlimit(RLIMIT_CORE, &rlim_new);"
    },
    {
        "line": 1196,
        "fullcodeline": "temp_portnumber_filename, strerror(errno));"
    },
    {
        "line": 429,
        "fullcodeline": "size_max *= 1024;"
    },
    {
        "line": 431,
        "fullcodeline": "size_max *= 1024 * 1024;"
    },
    {
        "line": 465,
        "fullcodeline": "settings.hashpower_init = atoi(subopts_value);"
    },
    {
        "line": 478,
        "fullcodeline": "start_assoc_maint = false;"
    },
    {
        "line": 481,
        "fullcodeline": "settings.slab_reassign = true;"
    },
    {
        "line": 488,
        "fullcodeline": "settings.slab_automove = atoi(subopts_value);"
    },
    {
        "line": 499,
        "fullcodeline": "settings.slab_automove_ratio = atof(subopts_value);"
    },
    {
        "line": 510,
        "fullcodeline": "settings.slab_automove_window = atoi(subopts_value);"
    },
    {
        "line": 521,
        "fullcodeline": "settings.tail_repair_time = atoi(subopts_value);"
    },
    {
        "line": 542,
        "fullcodeline": "start_lru_crawler = true;"
    },
    {
        "line": 549,
        "fullcodeline": "settings.lru_crawler_sleep = atoi(subopts_value);"
    },
    {
        "line": 567,
        "fullcodeline": "start_lru_maintainer = true;"
    },
    {
        "line": 575,
        "fullcodeline": "settings.hot_lru_pct = atoi(subopts_value);"
    },
    {
        "line": 586,
        "fullcodeline": "settings.warm_lru_pct = atoi(subopts_value);"
    },
    {
        "line": 597,
        "fullcodeline": "settings.hot_max_factor = atof(subopts_value);"
    },
    {
        "line": 608,
        "fullcodeline": "settings.warm_max_factor = atof(subopts_value);"
    },
    {
        "line": 619,
        "fullcodeline": "settings.temp_lru = true;"
    },
    {
        "line": 627,
        "fullcodeline": "settings.idle_timeout = atoi(subopts_value);"
    },
    {
        "line": 638,
        "fullcodeline": "settings.logger_watcher_buf_size *= 1024; /* kilobytes */"
    },
    {
        "line": 649,
        "fullcodeline": "settings.logger_buf_size *= 1024; /* kilobytes */"
    },
    {
        "line": 651,
        "fullcodeline": "slab_sizes_unparsed = subopts_value;"
    },
    {
        "line": 660,
        "fullcodeline": "slab_chunk_size_changed = true;"
    },
    {
        "line": 672,
        "fullcodeline": "settings.slab_chunk_size_max = settings.slab_page_size;"
    },
    {
        "line": 675,
        "fullcodeline": "settings.slab_reassign = false;"
    },
    {
        "line": 685,
        "fullcodeline": "start_lru_crawler = false;"
    },
    {
        "line": 688,
        "fullcodeline": "start_lru_maintainer = false;"
    },
    {
        "line": 839,
        "fullcodeline": "settings.slab_reassign = false;"
    },
    {
        "line": 844,
        "fullcodeline": "hash_type = JENKINS_HASH;"
    },
    {
        "line": 845,
        "fullcodeline": "start_lru_crawler = false;"
    },
    {
        "line": 846,
        "fullcodeline": "start_lru_maintainer = false;"
    },
    {
        "line": 411,
        "fullcodeline": "} else if (strcmp(optarg, \"binary\") == 0) {"
    },
    {
        "line": 412,
        "fullcodeline": "settings.binding_protocol = binary_prot;"
    },
    {
        "line": 461,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 466,
        "fullcodeline": "if (settings.hashpower_init < 12) {"
    },
    {
        "line": 484,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 495,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 506,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 517,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 528,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 545,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 556,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 571,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 582,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 593,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 604,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 615,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 620,
        "fullcodeline": "settings.temporary_ttl = atoi(subopts_value);"
    },
    {
        "line": 623,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 630,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 641,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 654,
        "fullcodeline": "if (subopts_value == NULL) {"
    },
    {
        "line": 836,
        "fullcodeline": "if (!slab_chunk_size_changed) {"
    },
    {
        "line": 489,
        "fullcodeline": "if (settings.slab_automove < 0 || settings.slab_automove > 2) {"
    },
    {
        "line": 500,
        "fullcodeline": "if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {"
    },
    {
        "line": 532,
        "fullcodeline": "if (strcmp(subopts_value, \"jenkins\") == 0) {"
    },
    {
        "line": 533,
        "fullcodeline": "hash_type = JENKINS_HASH;"
    },
    {
        "line": 550,
        "fullcodeline": "if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {"
    },
    {
        "line": 560,
        "fullcodeline": "if (!safe_strtoul(subopts_value, &tocrawl)) {"
    },
    {
        "line": 576,
        "fullcodeline": "if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {"
    },
    {
        "line": 587,
        "fullcodeline": "if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {"
    },
    {
        "line": 634,
        "fullcodeline": "if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {"
    },
    {
        "line": 645,
        "fullcodeline": "if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {"
    },
    {
        "line": 655,
        "fullcodeline": "fprintf(stderr, \"Missing slab_chunk_max argument\\n\");"
    },
    {
        "line": 657,
        "fullcodeline": "if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {"
    },
    {
        "line": 658,
        "fullcodeline": "fprintf(stderr, \"could not parse argument to slab_chunk_max\\n\");"
    },
    {
        "line": 837,
        "fullcodeline": "settings.slab_chunk_size_max = settings.slab_page_size;"
    },
    {
        "line": 413,
        "fullcodeline": "} else if (strcmp(optarg, \"ascii\") == 0) {"
    },
    {
        "line": 414,
        "fullcodeline": "settings.binding_protocol = ascii_prot;"
    },
    {
        "line": 470,
        "fullcodeline": "} else if (settings.hashpower_init > 32) {"
    },
    {
        "line": 416,
        "fullcodeline": "fprintf(stderr, \"Invalid value for binding protocol: %s\\n\""
    },
    {
        "line": 418,
        "fullcodeline": "exit(EX_USAGE);"
    },
    {
        "line": 534,
        "fullcodeline": "} else if (strcmp(subopts_value, \"murmur3\") == 0) {"
    },
    {
        "line": 535,
        "fullcodeline": "hash_type = MURMUR3_HASH;"
    }
]