[
    {
        "line": 5,
        "fullcodeline": "char callid[1024], xcallid[1024];"
    },
    {
        "line": 6,
        "fullcodeline": "u_char payload[MAX_SIP_PAYLOAD];"
    },
    {
        "line": 7,
        "fullcodeline": "bool newcall = false;"
    },
    {
        "line": 14,
        "fullcodeline": "memset(callid, 0, sizeof(callid));"
    },
    {
        "line": 15,
        "fullcodeline": "memset(xcallid, 0, sizeof(xcallid));"
    },
    {
        "line": 18,
        "fullcodeline": "memset(payload, 0, MAX_SIP_PAYLOAD);"
    },
    {
        "line": 19,
        "fullcodeline": "memcpy(payload, packet_payload(packet), packet_payloadlen(packet));"
    },
    {
        "line": 76,
        "fullcodeline": "msg->packet = packet;"
    },
    {
        "line": 89,
        "fullcodeline": "call_add_message(call, msg);"
    },
    {
        "line": 92,
        "fullcodeline": "call_msg_retrans_check(msg);"
    },
    {
        "line": 120,
        "fullcodeline": "calls.changed = true;"
    },
    {
        "line": 127,
        "fullcodeline": "msg_destroy(msg);"
    },
    {
        "line": 10,
        "fullcodeline": "if (packet->payload_len > MAX_SIP_PAYLOAD)"
    },
    {
        "line": 22,
        "fullcodeline": "if (!sip_get_callid((const char*) payload, callid))"
    },
    {
        "line": 26,
        "fullcodeline": "if (!(msg = msg_create()))"
    },
    {
        "line": 32,
        "fullcodeline": "if (!sip_get_msg_reqresp(msg, payload)) {"
    },
    {
        "line": 39,
        "fullcodeline": "if (!(call = sip_find_by_callid(callid))) {"
    },
    {
        "line": 79,
        "fullcodeline": "if (call_msg_count(call) == 0) {"
    },
    {
        "line": 94,
        "fullcodeline": "if (call_is_invite(call)) {"
    },
    {
        "line": 34,
        "fullcodeline": "msg_destroy(msg);"
    },
    {
        "line": 55,
        "fullcodeline": "sip_get_xcallid((const char*) payload, xcallid);"
    },
    {
        "line": 66,
        "fullcodeline": "htable_insert(calls.callids, call->callid, call);"
    },
    {
        "line": 69,
        "fullcodeline": "call->index = ++calls.last_index;"
    },
    {
        "line": 72,
        "fullcodeline": "newcall = true;"
    },
    {
        "line": 81,
        "fullcodeline": "sip_parse_msg_payload(msg, payload);"
    },
    {
        "line": 96,
        "fullcodeline": "sip_parse_msg_media(msg, payload);"
    },
    {
        "line": 98,
        "fullcodeline": "call_update_state(call, msg);"
    },
    {
        "line": 100,
        "fullcodeline": "sip_parse_extra_headers(msg, payload);"
    },
    {
        "line": 115,
        "fullcodeline": "vector_append(calls.list, call);"
    },
    {
        "line": 42,
        "fullcodeline": "if (!sip_check_match_expression((const char*) payload))"
    },
    {
        "line": 46,
        "fullcodeline": "if (calls.only_calls && msg->reqresp != SIP_METHOD_INVITE)"
    },
    {
        "line": 51,
        "fullcodeline": "if (calls.ignore_incomplete && msg->reqresp > SIP_METHOD_MESSAGE)"
    },
    {
        "line": 58,
        "fullcodeline": "if (calls.limit == sip_calls_count())"
    },
    {
        "line": 62,
        "fullcodeline": "if (!(call = call_create(callid, xcallid)))"
    },
    {
        "line": 83,
        "fullcodeline": "if (strlen(call->xcallid)) {"
    },
    {
        "line": 102,
        "fullcodeline": "if (call_is_active(call)) {"
    },
    {
        "line": 59,
        "fullcodeline": "sip_calls_rotate();"
    },
    {
        "line": 84,
        "fullcodeline": "call_add_xcall(sip_find_by_callid(call->xcallid), call);"
    },
    {
        "line": 103,
        "fullcodeline": "if (sip_call_is_active(call)) {"
    },
    {
        "line": 104,
        "fullcodeline": "vector_append(calls.active, call);"
    },
    {
        "line": 107,
        "fullcodeline": "if (sip_call_is_active(call)) {"
    },
    {
        "line": 108,
        "fullcodeline": "vector_remove(calls.active, call);"
    }
]