[
    {
        "line": 8,
        "fullcodeline": "parse_packet(data, &pkthdr);"
    },
    {
        "line": 5,
        "fullcodeline": "if (data_len < MT_HEADER_LEN){"
    },
    {
        "line": 11,
        "fullcodeline": "if (pkthdr.seskey != sessionkey) {"
    },
    {
        "line": 16,
        "fullcodeline": "if (pkthdr.ptype == MT_PTYPE_DATA) {"
    },
    {
        "line": 19,
        "fullcodeline": "int success = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "init_packet(&odata, MT_PTYPE_ACK, srcmac, dstmac, sessionkey, pkthdr.counter + (data_len - MT_HEADER_LEN));"
    },
    {
        "line": 23,
        "fullcodeline": "send_udp(&odata, 0);"
    },
    {
        "line": 35,
        "fullcodeline": "success = parse_control_packet(data + MT_HEADER_LEN, data_len - MT_HEADER_LEN, &cpkt);"
    },
    {
        "line": 6,
        "fullcodeline": "return -1;"
    },
    {
        "line": 12,
        "fullcodeline": "return -1;"
    },
    {
        "line": 27,
        "fullcodeline": "if (pkthdr.counter > incounter || (incounter - pkthdr.counter) > 65535) {"
    },
    {
        "line": 28,
        "fullcodeline": "incounter = pkthdr.counter;"
    },
    {
        "line": 74,
        "fullcodeline": "success = parse_control_packet(NULL, 0, &cpkt);"
    },
    {
        "line": 77,
        "fullcodeline": "else if (pkthdr.ptype == MT_PTYPE_ACK) {"
    },
    {
        "line": 40,
        "fullcodeline": "if (cpkt.cptype == MT_CPTYPE_PASSSALT) {"
    },
    {
        "line": 31,
        "fullcodeline": "return -1;"
    },
    {
        "line": 45,
        "fullcodeline": "memcpy(pass_salt, cpkt.data, 16);"
    },
    {
        "line": 46,
        "fullcodeline": "send_auth(username, password);"
    },
    {
        "line": 42,
        "fullcodeline": "if (cpkt.length != 16) {"
    },
    {
        "line": 82,
        "fullcodeline": "else if (pkthdr.ptype == MT_PTYPE_END) {"
    },
    {
        "line": 43,
        "fullcodeline": "fprintf(stderr, _(\"Invalid salt length: %d (instead of 16) received from server %s\\n\"), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));"
    },
    {
        "line": 51,
        "fullcodeline": "else if (cpkt.cptype == MT_CPTYPE_PLAINDATA) {"
    },
    {
        "line": 86,
        "fullcodeline": "init_packet(&odata, MT_PTYPE_END, srcmac, dstmac, pkthdr.seskey, 0);"
    },
    {
        "line": 87,
        "fullcodeline": "send_udp(&odata, 0);"
    },
    {
        "line": 94,
        "fullcodeline": "running = 0;"
    },
    {
        "line": 52,
        "fullcodeline": "fwrite((const void *)cpkt.data, 1, cpkt.length, stdout);"
    },
    {
        "line": 89,
        "fullcodeline": "if (!quiet_mode) {"
    },
    {
        "line": 96,
        "fullcodeline": "fprintf(stderr, _(\"Unhandeled packet type: %d received from server %s\\n\"), pkthdr.ptype, ether_ntoa((struct ether_addr *)dstmac));"
    },
    {
        "line": 90,
        "fullcodeline": "fprintf(stderr, _(\"Connection closed.\\n\"));"
    },
    {
        "line": 97,
        "fullcodeline": "return -1;"
    },
    {
        "line": 57,
        "fullcodeline": "else if (cpkt.cptype == MT_CPTYPE_END_AUTH) {"
    },
    {
        "line": 60,
        "fullcodeline": "terminal_mode = 1;"
    },
    {
        "line": 64,
        "fullcodeline": "raw_term();"
    },
    {
        "line": 66,
        "fullcodeline": "setvbuf(stdin,  (char*)NULL, _IONBF, 0);"
    },
    {
        "line": 69,
        "fullcodeline": "signal(SIGWINCH, sig_winch);"
    }
]