[
    {
        "line": 9,
        "fullcodeline": "struct lyd_node *ret, *parent, *key, *key_dup, *new_node = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "log_ctx = (ctx ? ctx : node->schema->module->ctx);"
    },
    {
        "line": 24,
        "fullcodeline": "ret = NULL;"
    },
    {
        "line": 25,
        "fullcodeline": "parent = NULL;"
    },
    {
        "line": 12,
        "fullcodeline": "if (!node) {"
    },
    {
        "line": 18,
        "fullcodeline": "if (ctx == node->schema->module->ctx) {"
    },
    {
        "line": 28,
        "fullcodeline": "for (elem = next = node; elem; elem = next) {"
    },
    {
        "line": 118,
        "fullcodeline": "if (options & LYD_DUP_OPT_WITH_PARENTS) {"
    },
    {
        "line": 21,
        "fullcodeline": "ctx = NULL;"
    },
    {
        "line": 65,
        "fullcodeline": "new_node = _lyd_dup_node(elem, schema, log_ctx, options);"
    },
    {
        "line": 119,
        "fullcodeline": "parent = ret;"
    },
    {
        "line": 66,
        "fullcodeline": "if (!new_node) {"
    },
    {
        "line": 70,
        "fullcodeline": "if (parent && lyd_insert(parent, new_node)) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (!ret) {"
    },
    {
        "line": 85,
        "fullcodeline": "if (elem->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {"
    },
    {
        "line": 90,
        "fullcodeline": "if (!next) {"
    },
    {
        "line": 101,
        "fullcodeline": "while (!next) {"
    },
    {
        "line": 120,
        "fullcodeline": "for (elem = node->parent; elem; elem = elem->parent) {"
    },
    {
        "line": 32,
        "fullcodeline": "schema = NULL;"
    },
    {
        "line": 75,
        "fullcodeline": "ret = new_node;"
    },
    {
        "line": 78,
        "fullcodeline": "if (!(options & LYD_DUP_OPT_RECURSIVE)) {"
    },
    {
        "line": 86,
        "fullcodeline": "next = NULL;"
    },
    {
        "line": 95,
        "fullcodeline": "next = elem->next;"
    },
    {
        "line": 103,
        "fullcodeline": "elem = elem->parent;"
    },
    {
        "line": 111,
        "fullcodeline": "parent = parent->parent;"
    },
    {
        "line": 113,
        "fullcodeline": "next = elem->next;"
    },
    {
        "line": 121,
        "fullcodeline": "new_node = lyd_dup(elem, options & LYD_DUP_OPT_NO_ATTR);"
    },
    {
        "line": 122,
        "fullcodeline": "LY_CHECK_ERR_GOTO(!new_node, LOGMEM(log_ctx), error);"
    },
    {
        "line": 152,
        "fullcodeline": "parent = new_node;"
    },
    {
        "line": 49,
        "fullcodeline": "if (!schema) {"
    },
    {
        "line": 61,
        "fullcodeline": "schema = elem->schema;"
    },
    {
        "line": 88,
        "fullcodeline": "next = elem->child;"
    },
    {
        "line": 91,
        "fullcodeline": "if (elem->parent == node->parent) {"
    },
    {
        "line": 97,
        "fullcodeline": "parent = new_node;"
    },
    {
        "line": 104,
        "fullcodeline": "if (elem->parent == node->parent) {"
    },
    {
        "line": 107,
        "fullcodeline": "if (!parent) {"
    },
    {
        "line": 125,
        "fullcodeline": "if (new_node->schema->nodetype == LYS_LIST) {"
    },
    {
        "line": 148,
        "fullcodeline": "if (lyd_insert(new_node, parent)) {"
    },
    {
        "line": 34,
        "fullcodeline": "trg_mod = lyp_get_module(parent->schema->module, NULL, 0, lyd_node_module(elem)->name,"
    },
    {
        "line": 42,
        "fullcodeline": "lys_getnext_data(trg_mod, parent->schema, elem->schema->name, strlen(elem->schema->name),"
    },
    {
        "line": 50,
        "fullcodeline": "yang_data_name = lyp_get_yang_data_template_name(elem);"
    },
    {
        "line": 126,
        "fullcodeline": "slist = (struct lys_node_list *)new_node->schema;"
    },
    {
        "line": 149,
        "fullcodeline": "ret = parent;"
    },
    {
        "line": 36,
        "fullcodeline": "if (!trg_mod) {"
    },
    {
        "line": 46,
        "fullcodeline": "schema = lyd_get_schema_inctx(elem, ctx);"
    },
    {
        "line": 127,
        "fullcodeline": "for (key = elem->child, i = 0; key && (i < slist->keys_size); ++i, key = key->next) {"
    },
    {
        "line": 141,
        "fullcodeline": "if (!key && (i < slist->keys_size)) {"
    },
    {
        "line": 35,
        "fullcodeline": "strlen(lyd_node_module(elem)->name), 1);"
    },
    {
        "line": 133,
        "fullcodeline": "key_dup = lyd_dup(key, options & LYD_DUP_OPT_NO_ATTR);"
    },
    {
        "line": 134,
        "fullcodeline": "LY_CHECK_ERR_GOTO(!key_dup, LOGMEM(log_ctx), error);"
    },
    {
        "line": 128,
        "fullcodeline": "if (key->schema != (struct lys_node *)slist->keys[i]) {"
    },
    {
        "line": 136,
        "fullcodeline": "if (lyd_insert(new_node, key_dup)) {"
    }
]