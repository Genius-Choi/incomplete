[
    {
        "line": 3,
        "fullcodeline": "bool found_unknown_shapes = false;"
    },
    {
        "line": 5,
        "fullcodeline": "const auto method = op_context.op_info.attr().find(\"method\");"
    },
    {
        "line": 18,
        "fullcodeline": "const int64_t num_boxes = op_context.op_info.inputs(1).shape().dim(0).size();"
    },
    {
        "line": 19,
        "fullcodeline": "const auto crop_shape = MaybeGetMinimumShape("
    },
    {
        "line": 21,
        "fullcodeline": "const int64_t crop_height = crop_shape.dim(1).size();"
    },
    {
        "line": 22,
        "fullcodeline": "const int64_t crop_width = crop_shape.dim(2).size();"
    },
    {
        "line": 23,
        "fullcodeline": "const int64_t output_elements = CalculateTensorElementCount("
    },
    {
        "line": 27,
        "fullcodeline": "const auto sub_cost = EIGEN_COST(scalar_difference_op<float>);"
    },
    {
        "line": 28,
        "fullcodeline": "const auto add_cost = EIGEN_COST(scalar_sum_op<float>);"
    },
    {
        "line": 29,
        "fullcodeline": "const auto mul_cost = EIGEN_COST(scalar_product_op<float>);"
    },
    {
        "line": 30,
        "fullcodeline": "auto div_cost = EIGEN_COST(scalar_div_cost<float>);"
    },
    {
        "line": 31,
        "fullcodeline": "const auto floor_cost = EIGEN_COST(scalar_floor_op<float>);"
    },
    {
        "line": 32,
        "fullcodeline": "const auto ceil_cost = EIGEN_COST(scalar_ceil_op<float>);"
    },
    {
        "line": 33,
        "fullcodeline": "auto round_cost = EIGEN_COST(scalar_round_op<float>);"
    },
    {
        "line": 34,
        "fullcodeline": "const auto cast_to_float_cost = Eigen::internal::functor_traits<"
    },
    {
        "line": 44,
        "fullcodeline": "int64_t crop_area = MultiplyWithoutOverflow(crop_height, crop_width);"
    },
    {
        "line": 49,
        "fullcodeline": "int64_t crop_volume = MultiplyWithoutOverflow(crop_area, num_boxes);"
    },
    {
        "line": 54,
        "fullcodeline": "int64_t crop_depth = MultiplyWithoutOverflow(crop_height, num_boxes);"
    },
    {
        "line": 61,
        "fullcodeline": "int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;"
    },
    {
        "line": 63,
        "fullcodeline": "ops += (mul_cost * 2 + sub_cost + add_cost) * crop_depth;"
    },
    {
        "line": 65,
        "fullcodeline": "ops += (mul_cost * 2 + sub_cost + add_cost) * crop_volume;"
    },
    {
        "line": 7,
        "fullcodeline": "if (method == op_context.op_info.attr().end() ||"
    },
    {
        "line": 45,
        "fullcodeline": "if (crop_area < 0)"
    },
    {
        "line": 50,
        "fullcodeline": "if (crop_volume < 0)"
    },
    {
        "line": 55,
        "fullcodeline": "if (crop_depth < 0)"
    },
    {
        "line": 82,
        "fullcodeline": "return PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,"
    },
    {
        "line": 8,
        "fullcodeline": "method->second.s() == \"bilinear\") {"
    },
    {
        "line": 20,
        "fullcodeline": "op_context.op_info.outputs(0).shape(), 4, &found_unknown_shapes);"
    },
    {
        "line": 24,
        "fullcodeline": "op_context.op_info.outputs(0), &found_unknown_shapes);"
    },
    {
        "line": 69,
        "fullcodeline": "ops += (floor_cost + ceil_cost + sub_cost) * crop_depth;"
    },
    {
        "line": 71,
        "fullcodeline": "ops += (floor_cost + ceil_cost + sub_cost) * crop_volume;"
    },
    {
        "line": 73,
        "fullcodeline": "ops +="
    },
    {
        "line": 46,
        "fullcodeline": "return errors::InvalidArgument(\"Cannot estimate cost, multiplying \","
    },
    {
        "line": 51,
        "fullcodeline": "return errors::InvalidArgument(\"Cannot estimate cost, multiplying \","
    },
    {
        "line": 56,
        "fullcodeline": "return errors::InvalidArgument(\"Cannot estimate cost, multiplying \","
    },
    {
        "line": 74,
        "fullcodeline": "(cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *"
    },
    {
        "line": 78,
        "fullcodeline": "ops += round_cost * 2 * crop_volume;"
    },
    {
        "line": 80,
        "fullcodeline": "ops += cast_to_float_cost * output_elements;"
    },
    {
        "line": 10,
        "fullcodeline": "} else if (method->second.s() == \"nearest\") {"
    },
    {
        "line": 13,
        "fullcodeline": "LOG(WARNING) << \"method attr in CropAndResize invalid; expected bilinear \""
    },
    {
        "line": 15,
        "fullcodeline": "return PredictCostOfAnUnknownOp(op_context, node_costs);"
    }
]