[
    {
        "line": 3,
        "fullcodeline": "Authctxt *authctxt = ssh->authctxt;"
    },
    {
        "line": 4,
        "fullcodeline": "struct passwd *pw = authctxt->pw;"
    },
    {
        "line": 6,
        "fullcodeline": "struct sshkey *key = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;"
    },
    {
        "line": 11,
        "fullcodeline": "int authenticated = 0;"
    },
    {
        "line": 12,
        "fullcodeline": "struct sshauthopt *authopts = NULL;"
    },
    {
        "line": 22,
        "fullcodeline": "pktype = sshkey_type_from_name(pkalg);"
    },
    {
        "line": 58,
        "fullcodeline": "key_s = format_key(key);"
    },
    {
        "line": 145,
        "fullcodeline": "debug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);"
    },
    {
        "line": 14,
        "fullcodeline": "if (!authctxt->valid) {"
    },
    {
        "line": 23,
        "fullcodeline": "if (pktype == KEY_UNSPEC) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (key == NULL) {"
    },
    {
        "line": 37,
        "fullcodeline": "if (key->type != pktype) {"
    },
    {
        "line": 48,
        "fullcodeline": "if (auth2_key_already_used(authctxt, key)) {"
    },
    {
        "line": 59,
        "fullcodeline": "if (sshkey_is_cert(key))"
    },
    {
        "line": 15,
        "fullcodeline": "debug2(\"%s: disabled because of invalid user\", __func__);"
    },
    {
        "line": 18,
        "fullcodeline": "if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||"
    },
    {
        "line": 20,
        "fullcodeline": "(r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)"
    },
    {
        "line": 21,
        "fullcodeline": "fatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));"
    },
    {
        "line": 25,
        "fullcodeline": "verbose(\"%s: unsupported public key algorithm: %s\","
    },
    {
        "line": 29,
        "fullcodeline": "if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {"
    },
    {
        "line": 30,
        "fullcodeline": "error(\"%s: could not parse key: %s\", __func__, ssh_err(r));"
    },
    {
        "line": 34,
        "fullcodeline": "error(\"%s: cannot decode key: %s\", __func__, pkalg);"
    },
    {
        "line": 38,
        "fullcodeline": "error(\"%s: type mismatch for decoded key \""
    },
    {
        "line": 42,
        "fullcodeline": "if (sshkey_type_plain(key->type) == KEY_RSA &&"
    },
    {
        "line": 43,
        "fullcodeline": "(ssh->compat & SSH_BUG_RSASIGMD5) != 0) {"
    },
    {
        "line": 52,
        "fullcodeline": "if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {"
    },
    {
        "line": 53,
        "fullcodeline": "logit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\","
    },
    {
        "line": 60,
        "fullcodeline": "ca_s = format_key(key->cert->signature_key);"
    },
    {
        "line": 63,
        "fullcodeline": "debug3(\"%s: have %s signature for %s%s%s\","
    },
    {
        "line": 84,
        "fullcodeline": "xasprintf(&userstyle, \"%s%s%s\", authctxt->user,"
    },
    {
        "line": 101,
        "fullcodeline": "authenticated = 0;"
    },
    {
        "line": 111,
        "fullcodeline": "auth2_record_key(authctxt, authenticated, key);"
    },
    {
        "line": 141,
        "fullcodeline": "if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {"
    },
    {
        "line": 142,
        "fullcodeline": "debug(\"%s: key options inconsistent with existing\", __func__);"
    },
    {
        "line": 143,
        "fullcodeline": "authenticated = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "(r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||"
    },
    {
        "line": 49,
        "fullcodeline": "logit(\"refusing previously-used %s key\", sshkey_type(key));"
    },
    {
        "line": 54,
        "fullcodeline": "__func__, sshkey_ssh_name(key));"
    },
    {
        "line": 70,
        "fullcodeline": "if ((b = sshbuf_new()) == NULL)"
    },
    {
        "line": 72,
        "fullcodeline": "if (ssh->compat & SSH_OLD_SESSIONID) {"
    },
    {
        "line": 113,
        "fullcodeline": "debug(\"%s: test pkalg %s pkblob %s%s%s\","
    },
    {
        "line": 65,
        "fullcodeline": "ca_s == NULL ? \"\" : \" CA \","
    },
    {
        "line": 66,
        "fullcodeline": "ca_s == NULL ? \"\" : ca_s);"
    },
    {
        "line": 67,
        "fullcodeline": "if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||"
    },
    {
        "line": 68,
        "fullcodeline": "(r = sshpkt_get_end(ssh)) != 0)"
    },
    {
        "line": 69,
        "fullcodeline": "fatal(\"%s: %s\", __func__, ssh_err(r));"
    },
    {
        "line": 71,
        "fullcodeline": "fatal(\"%s: sshbuf_new failed\", __func__);"
    },
    {
        "line": 87,
        "fullcodeline": "if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||"
    },
    {
        "line": 93,
        "fullcodeline": "(r = sshbuf_put_string(b, pkblob, blen)) != 0)"
    },
    {
        "line": 94,
        "fullcodeline": "fatal(\"%s: build packet failed: %s\","
    },
    {
        "line": 102,
        "fullcodeline": "if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&"
    },
    {
        "line": 103,
        "fullcodeline": "PRIVSEP(sshkey_verify(key, sig, slen,"
    },
    {
        "line": 107,
        "fullcodeline": "authenticated = 1;"
    },
    {
        "line": 92,
        "fullcodeline": "(r = sshbuf_put_cstring(b, pkalg) != 0) ||"
    },
    {
        "line": 95,
        "fullcodeline": "__func__, ssh_err(r));"
    },
    {
        "line": 115,
        "fullcodeline": "ca_s == NULL ? \"\" : \" CA \","
    },
    {
        "line": 116,
        "fullcodeline": "ca_s == NULL ? \"\" : ca_s);"
    },
    {
        "line": 118,
        "fullcodeline": "if ((r = sshpkt_get_end(ssh)) != 0)"
    },
    {
        "line": 119,
        "fullcodeline": "fatal(\"%s: %s\", __func__, ssh_err(r));"
    },
    {
        "line": 129,
        "fullcodeline": "if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {"
    },
    {
        "line": 73,
        "fullcodeline": "if ((r = sshbuf_put(b, session_id2,"
    },
    {
        "line": 75,
        "fullcodeline": "fatal(\"%s: sshbuf_put session id: %s\","
    },
    {
        "line": 91,
        "fullcodeline": "(r = sshbuf_put_u8(b, have_sig)) != 0 ||"
    },
    {
        "line": 76,
        "fullcodeline": "__func__, ssh_err(r));"
    },
    {
        "line": 78,
        "fullcodeline": "if ((r = sshbuf_put_string(b, session_id2,"
    },
    {
        "line": 80,
        "fullcodeline": "fatal(\"%s: sshbuf_put_string session id: %s\","
    },
    {
        "line": 90,
        "fullcodeline": "(r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||"
    },
    {
        "line": 104,
        "fullcodeline": "sshbuf_ptr(b), sshbuf_len(b),"
    },
    {
        "line": 130,
        "fullcodeline": "if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))"
    },
    {
        "line": 135,
        "fullcodeline": "(r = ssh_packet_write_wait(ssh)) != 0)"
    },
    {
        "line": 136,
        "fullcodeline": "fatal(\"%s: %s\", __func__, ssh_err(r));"
    },
    {
        "line": 81,
        "fullcodeline": "__func__, ssh_err(r));"
    },
    {
        "line": 89,
        "fullcodeline": "(r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||"
    },
    {
        "line": 134,
        "fullcodeline": "(r = sshpkt_send(ssh)) != 0 ||"
    },
    {
        "line": 88,
        "fullcodeline": "(r = sshbuf_put_cstring(b, userstyle)) != 0 ||"
    },
    {
        "line": 105,
        "fullcodeline": "(ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,"
    },
    {
        "line": 133,
        "fullcodeline": "(r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||"
    },
    {
        "line": 132,
        "fullcodeline": "(r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||"
    }
]