[
    {
        "line": 5,
        "fullcodeline": "static int extreme_val_warned = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];"
    },
    {
        "line": 11,
        "fullcodeline": "kstring_t *mem = (kstring_t*)&h->mem;"
    },
    {
        "line": 12,
        "fullcodeline": "fmt_aux_t fmt[MAX_N_FMT];"
    },
    {
        "line": 13,
        "fullcodeline": "mem->l = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "char *end = s->s + s->l;"
    },
    {
        "line": 23,
        "fullcodeline": "v->n_fmt = 0;"
    },
    {
        "line": 73,
        "fullcodeline": "int n_sample_ori = -1;"
    },
    {
        "line": 74,
        "fullcodeline": "r = q + 1;  // r: position in the format string"
    },
    {
        "line": 172,
        "fullcodeline": "n_sample_ori = -1;"
    },
    {
        "line": 173,
        "fullcodeline": "t = q + 1; m = 0;   // m: sample id"
    },
    {
        "line": 330,
        "fullcodeline": "kstring_t *str = &v->indiv;"
    },
    {
        "line": 3,
        "fullcodeline": "if ( !bcf_hdr_nsamples(h) ) return 0;"
    },
    {
        "line": 16,
        "fullcodeline": "if ( q>=end )"
    },
    {
        "line": 75,
        "fullcodeline": "l = 0, m = g = 1, v->n_sample = 0;  // m: max vector size, l: max field len, g: max number of alleles"
    },
    {
        "line": 76,
        "fullcodeline": "while ( r<end )"
    },
    {
        "line": 134,
        "fullcodeline": "for (j = 0; j < v->n_fmt; ++j) {"
    },
    {
        "line": 169,
        "fullcodeline": "for (j = 0; j < v->n_fmt; ++j)"
    },
    {
        "line": 174,
        "fullcodeline": "while ( t<end )"
    },
    {
        "line": 332,
        "fullcodeline": "if (v->n_sample > 0) {"
    },
    {
        "line": 24,
        "fullcodeline": "if ( p[0]=='.' && p[1]==0 ) // FORMAT field is empty \".\""
    },
    {
        "line": 31,
        "fullcodeline": "for (j = 0, t = kstrtok(p, \":\", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) {"
    },
    {
        "line": 40,
        "fullcodeline": "k = kh_get(vdict, d, t);"
    },
    {
        "line": 70,
        "fullcodeline": "v->n_fmt++;"
    },
    {
        "line": 91,
        "fullcodeline": "j = 0;  // j-th format field"
    },
    {
        "line": 92,
        "fullcodeline": "fmt_aux_t *f = fmt;"
    },
    {
        "line": 128,
        "fullcodeline": "v->n_sample++;"
    },
    {
        "line": 130,
        "fullcodeline": "r++;"
    },
    {
        "line": 135,
        "fullcodeline": "fmt_aux_t *f = &fmt[j];"
    },
    {
        "line": 167,
        "fullcodeline": "mem->l += v->n_sample * f->size;"
    },
    {
        "line": 189,
        "fullcodeline": "j = 0; // j-th format field, m-th sample"
    },
    {
        "line": 326,
        "fullcodeline": "m++; t++;"
    },
    {
        "line": 353,
        "fullcodeline": "if ( v->n_sample!=bcf_hdr_nsamples(h) )"
    },
    {
        "line": 20,
        "fullcodeline": "return -1;"
    },
    {
        "line": 26,
        "fullcodeline": "v->n_sample = bcf_hdr_nsamples(h);"
    },
    {
        "line": 32,
        "fullcodeline": "if (j >= MAX_N_FMT) {"
    },
    {
        "line": 41,
        "fullcodeline": "if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) {"
    },
    {
        "line": 66,
        "fullcodeline": "fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0;"
    },
    {
        "line": 68,
        "fullcodeline": "fmt[j].is_gt = !strcmp(t, \"GT\");"
    },
    {
        "line": 129,
        "fullcodeline": "if ( v->n_sample == bcf_hdr_nsamples(h) ) break;"
    },
    {
        "line": 136,
        "fullcodeline": "if ( !f->max_m ) f->max_m = 1;  // omitted trailing format field"
    },
    {
        "line": 137,
        "fullcodeline": "if ((f->y>>4&0xf) == BCF_HT_STR) {"
    },
    {
        "line": 157,
        "fullcodeline": "if (v->n_sample * (uint64_t)f->size > INT_MAX) {"
    },
    {
        "line": 187,
        "fullcodeline": "if ( m == bcf_hdr_nsamples(h) ) break;"
    },
    {
        "line": 190,
        "fullcodeline": "while ( t < end )"
    },
    {
        "line": 303,
        "fullcodeline": "for (; j < v->n_fmt; ++j) { // fill end-of-vector values"
    },
    {
        "line": 333,
        "fullcodeline": "for (i = 0; i < v->n_fmt; ++i) {"
    },
    {
        "line": 358,
        "fullcodeline": "return -1;"
    },
    {
        "line": 367,
        "fullcodeline": "return -1;"
    },
    {
        "line": 49,
        "fullcodeline": "kstring_t tmp = {0,0,0};"
    },
    {
        "line": 51,
        "fullcodeline": "ksprintf(&tmp, \"##FORMAT=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", t);"
    },
    {
        "line": 52,
        "fullcodeline": "bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);"
    },
    {
        "line": 54,
        "fullcodeline": "int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;"
    },
    {
        "line": 58,
        "fullcodeline": "k = kh_get(vdict, d, t);"
    },
    {
        "line": 59,
        "fullcodeline": "v->errcode = BCF_ERR_TAG_UNDEF;"
    },
    {
        "line": 67,
        "fullcodeline": "fmt[j].key = kh_val(d, k).id;"
    },
    {
        "line": 81,
        "fullcodeline": "n_sample_ori++;"
    },
    {
        "line": 125,
        "fullcodeline": "r++; l++;"
    },
    {
        "line": 138,
        "fullcodeline": "f->size = f->is_gt? f->max_g << 2 : f->max_l;"
    },
    {
        "line": 147,
        "fullcodeline": "if (align_mem(mem) < 0) {"
    },
    {
        "line": 162,
        "fullcodeline": "if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) {"
    },
    {
        "line": 179,
        "fullcodeline": "n_sample_ori++;"
    },
    {
        "line": 192,
        "fullcodeline": "fmt_aux_t *z = &fmt[j++];"
    },
    {
        "line": 304,
        "fullcodeline": "fmt_aux_t *z = &fmt[j];"
    },
    {
        "line": 334,
        "fullcodeline": "fmt_aux_t *z = &fmt[i];"
    },
    {
        "line": 335,
        "fullcodeline": "bcf_enc_int1(str, z->key);"
    },
    {
        "line": 36,
        "fullcodeline": "return -1;"
    },
    {
        "line": 55,
        "fullcodeline": "if (res < 0) bcf_hrec_destroy(hrec);"
    },
    {
        "line": 56,
        "fullcodeline": "if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);"
    },
    {
        "line": 124,
        "fullcodeline": "if ( r>=end ) break;"
    },
    {
        "line": 150,
        "fullcodeline": "return -1;"
    },
    {
        "line": 160,
        "fullcodeline": "return -1;"
    },
    {
        "line": 165,
        "fullcodeline": "return -1;"
    },
    {
        "line": 193,
        "fullcodeline": "if (!z->buf) {"
    },
    {
        "line": 199,
        "fullcodeline": "if ((z->y>>4&0xf) == BCF_HT_STR) {"
    },
    {
        "line": 287,
        "fullcodeline": "if (*t == '\\0') {"
    },
    {
        "line": 305,
        "fullcodeline": "if ((z->y>>4&0xf) == BCF_HT_STR) {"
    },
    {
        "line": 42,
        "fullcodeline": "if ( t[0]=='.' && t[1]==0 )"
    },
    {
        "line": 60,
        "fullcodeline": "if (res || k == kh_end(d)) {"
    },
    {
        "line": 82,
        "fullcodeline": "if ( !bit_array_test(h->keep_samples,n_sample_ori) )"
    },
    {
        "line": 96,
        "fullcodeline": "m++;"
    },
    {
        "line": 105,
        "fullcodeline": "*r = 0; // fall through"
    },
    {
        "line": 180,
        "fullcodeline": "if ( !bit_array_test(h->keep_samples,n_sample_ori) )"
    },
    {
        "line": 183,
        "fullcodeline": "t++;"
    },
    {
        "line": 336,
        "fullcodeline": "if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) {"
    },
    {
        "line": 337,
        "fullcodeline": "bcf_enc_size(str, z->size, BCF_BT_CHAR);"
    },
    {
        "line": 338,
        "fullcodeline": "kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str);"
    },
    {
        "line": 46,
        "fullcodeline": "return -1;"
    },
    {
        "line": 63,
        "fullcodeline": "return -1;"
    },
    {
        "line": 84,
        "fullcodeline": "while ( *r!='\\t' && r<end ) r++;"
    },
    {
        "line": 85,
        "fullcodeline": "if ( *r=='\\t' ) { *r = 0; r++; }"
    },
    {
        "line": 109,
        "fullcodeline": "if (f->max_m < m) f->max_m = m;"
    },
    {
        "line": 110,
        "fullcodeline": "if (f->max_l < l) f->max_l = l;"
    },
    {
        "line": 111,
        "fullcodeline": "if (f->is_gt && f->max_g < g) f->max_g = g;"
    },
    {
        "line": 112,
        "fullcodeline": "l = 0, m = g = 1;"
    },
    {
        "line": 113,
        "fullcodeline": "if ( *r==':' ) {"
    },
    {
        "line": 139,
        "fullcodeline": "} else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) {"
    },
    {
        "line": 140,
        "fullcodeline": "f->size = f->max_m << 2;"
    },
    {
        "line": 182,
        "fullcodeline": "while ( *t && t<end ) t++;"
    },
    {
        "line": 197,
        "fullcodeline": "return -1;"
    },
    {
        "line": 101,
        "fullcodeline": "if (f->is_gt) g++;"
    },
    {
        "line": 114,
        "fullcodeline": "j++; f++;"
    },
    {
        "line": 201,
        "fullcodeline": "int32_t is_phased = 0;"
    },
    {
        "line": 203,
        "fullcodeline": "uint32_t unreadable = 0;"
    },
    {
        "line": 204,
        "fullcodeline": "uint32_t max = 0;"
    },
    {
        "line": 205,
        "fullcodeline": "overflow = 0;"
    },
    {
        "line": 235,
        "fullcodeline": "} else if ((z->y>>4&0xf) == BCF_HT_INT) {"
    },
    {
        "line": 290,
        "fullcodeline": "else if (*t == ':') {"
    },
    {
        "line": 315,
        "fullcodeline": "} else if ((z->y>>4&0xf) == BCF_HT_INT) {"
    },
    {
        "line": 339,
        "fullcodeline": "} else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) {"
    },
    {
        "line": 115,
        "fullcodeline": "if ( j>=v->n_fmt ) {"
    },
    {
        "line": 145,
        "fullcodeline": "return -1;"
    },
    {
        "line": 206,
        "fullcodeline": "for (l = 0;; ++t) {"
    },
    {
        "line": 228,
        "fullcodeline": "if ( !l ) x[l++] = 0;   // An empty field, insert missing value"
    },
    {
        "line": 229,
        "fullcodeline": "for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;"
    },
    {
        "line": 291,
        "fullcodeline": "t++;"
    },
    {
        "line": 309,
        "fullcodeline": "for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;"
    },
    {
        "line": 317,
        "fullcodeline": "x[0] = bcf_int32_missing;"
    },
    {
        "line": 340,
        "fullcodeline": "bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2);"
    },
    {
        "line": 216,
        "fullcodeline": "is_phased = (*t == '|');"
    },
    {
        "line": 220,
        "fullcodeline": "if (overflow || max > (INT32_MAX >> 1) - 1) {"
    },
    {
        "line": 232,
        "fullcodeline": "for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t;"
    },
    {
        "line": 233,
        "fullcodeline": "for (; l < z->size; ++l) x[l] = 0;"
    },
    {
        "line": 237,
        "fullcodeline": "for (l = 0;; ++t) {"
    },
    {
        "line": 258,
        "fullcodeline": "if ( !l ) x[l++] = bcf_int32_missing;"
    },
    {
        "line": 259,
        "fullcodeline": "for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;"
    },
    {
        "line": 298,
        "fullcodeline": "v->errcode |= BCF_ERR_CHAR;"
    },
    {
        "line": 308,
        "fullcodeline": "if (z->size) x[0] = bcf_int32_missing;"
    },
    {
        "line": 313,
        "fullcodeline": "for (l = 1; l < z->size; ++l) x[l] = 0;"
    },
    {
        "line": 318,
        "fullcodeline": "for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;"
    },
    {
        "line": 342,
        "fullcodeline": "bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT);"
    },
    {
        "line": 119,
        "fullcodeline": "return -1;"
    },
    {
        "line": 202,
        "fullcodeline": "uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m);"
    },
    {
        "line": 207,
        "fullcodeline": "if (*t == '.') {"
    },
    {
        "line": 222,
        "fullcodeline": "return -1;"
    },
    {
        "line": 226,
        "fullcodeline": "return -1;"
    },
    {
        "line": 231,
        "fullcodeline": "char *x = (char*)z->buf + z->size * (size_t)m;"
    },
    {
        "line": 260,
        "fullcodeline": "} else if ((z->y>>4&0xf) == BCF_HT_REAL) {"
    },
    {
        "line": 294,
        "fullcodeline": "char buffer[8];"
    },
    {
        "line": 299,
        "fullcodeline": "return -1;"
    },
    {
        "line": 307,
        "fullcodeline": "int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);"
    },
    {
        "line": 311,
        "fullcodeline": "char *x = (char*)z->buf + z->size * (size_t)m;"
    },
    {
        "line": 312,
        "fullcodeline": "if ( z->size ) x[0] = '.';"
    },
    {
        "line": 319,
        "fullcodeline": "} else if ((z->y>>4&0xf) == BCF_HT_REAL) {"
    },
    {
        "line": 217,
        "fullcodeline": "if (*t != '|' && *t != '/') break;"
    },
    {
        "line": 236,
        "fullcodeline": "int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);"
    },
    {
        "line": 238,
        "fullcodeline": "if (*t == '.') {"
    },
    {
        "line": 256,
        "fullcodeline": "if (*t != ',') break;"
    },
    {
        "line": 261,
        "fullcodeline": "float *x = (float*)(z->buf + z->size * (size_t)m);"
    },
    {
        "line": 316,
        "fullcodeline": "int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);"
    },
    {
        "line": 320,
        "fullcodeline": "float *x = (float*)(z->buf + z->size * (size_t)m);"
    },
    {
        "line": 343,
        "fullcodeline": "if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample,"
    },
    {
        "line": 208,
        "fullcodeline": "++t, x[l++] = is_phased;"
    },
    {
        "line": 210,
        "fullcodeline": "char *tt = t;"
    },
    {
        "line": 211,
        "fullcodeline": "uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow);"
    },
    {
        "line": 214,
        "fullcodeline": "x[l++] = (val + 1) << 1 | is_phased;"
    },
    {
        "line": 262,
        "fullcodeline": "for (l = 0;; ++t) {"
    },
    {
        "line": 279,
        "fullcodeline": "if ( !l ) bcf_float_set_missing(x[l++]);    // An empty field, insert missing value"
    },
    {
        "line": 280,
        "fullcodeline": "for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);"
    },
    {
        "line": 322,
        "fullcodeline": "for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);"
    },
    {
        "line": 347,
        "fullcodeline": "return -1;"
    },
    {
        "line": 212,
        "fullcodeline": "unreadable |= tt == t;"
    },
    {
        "line": 213,
        "fullcodeline": "if (max < val) max = val;"
    },
    {
        "line": 239,
        "fullcodeline": "x[l++] = bcf_int32_missing, ++t; // ++t to skip \".\""
    },
    {
        "line": 241,
        "fullcodeline": "overflow = 0;"
    },
    {
        "line": 243,
        "fullcodeline": "long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);"
    },
    {
        "line": 253,
        "fullcodeline": "x[l++] = tmp_val;"
    },
    {
        "line": 254,
        "fullcodeline": "t = te;"
    },
    {
        "line": 284,
        "fullcodeline": "return -1;"
    },
    {
        "line": 277,
        "fullcodeline": "if (*t != ',') break;"
    },
    {
        "line": 244,
        "fullcodeline": "if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )"
    },
    {
        "line": 251,
        "fullcodeline": "tmp_val = bcf_int32_missing;"
    },
    {
        "line": 263,
        "fullcodeline": "if (*t == '.' && !isdigit_c(t[1])) {"
    },
    {
        "line": 246,
        "fullcodeline": "if ( !extreme_val_warned )"
    },
    {
        "line": 264,
        "fullcodeline": "bcf_float_set_missing(x[l++]), ++t; // ++t to skip \".\""
    },
    {
        "line": 266,
        "fullcodeline": "overflow = 0;"
    },
    {
        "line": 268,
        "fullcodeline": "float tmp_val = hts_str2dbl(t, &te, &overflow);"
    },
    {
        "line": 274,
        "fullcodeline": "x[l++] = tmp_val;"
    },
    {
        "line": 275,
        "fullcodeline": "t = te;"
    },
    {
        "line": 249,
        "fullcodeline": "extreme_val_warned = 1;"
    },
    {
        "line": 269,
        "fullcodeline": "if ( (te==t || overflow) && !extreme_val_warned )"
    },
    {
        "line": 272,
        "fullcodeline": "extreme_val_warned = 1;"
    }
]