[
    {
        "line": 4,
        "fullcodeline": "struct fuse_file *ff = file->private_data;"
    },
    {
        "line": 5,
        "fullcodeline": "struct fuse_conn *fc = ff->fc;"
    },
    {
        "line": 6,
        "fullcodeline": "struct fuse_ioctl_in inarg = {"
    },
    {
        "line": 13,
        "fullcodeline": "struct fuse_req *req = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "struct page **pages = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "struct page *iov_page = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "struct iovec *in_iov = NULL, *out_iov = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "unsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;"
    },
    {
        "line": 22,
        "fullcodeline": "BUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);"
    },
    {
        "line": 24,
        "fullcodeline": "err = -ENOMEM;"
    },
    {
        "line": 25,
        "fullcodeline": "pages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);"
    },
    {
        "line": 26,
        "fullcodeline": "iov_page = alloc_page(GFP_KERNEL);"
    },
    {
        "line": 52,
        "fullcodeline": "inarg.in_size = in_size = iov_length(in_iov, in_iovs);"
    },
    {
        "line": 53,
        "fullcodeline": "inarg.out_size = out_size = iov_length(out_iov, out_iovs);"
    },
    {
        "line": 59,
        "fullcodeline": "out_size = max_t(size_t, out_size, PAGE_SIZE);"
    },
    {
        "line": 60,
        "fullcodeline": "max_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);"
    },
    {
        "line": 63,
        "fullcodeline": "err = -ENOMEM;"
    },
    {
        "line": 73,
        "fullcodeline": "req = fuse_get_req(fc);"
    },
    {
        "line": 79,
        "fullcodeline": "memcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);"
    },
    {
        "line": 80,
        "fullcodeline": "req->num_pages = num_pages;"
    },
    {
        "line": 83,
        "fullcodeline": "req->in.h.opcode = FUSE_IOCTL;"
    },
    {
        "line": 84,
        "fullcodeline": "req->in.h.nodeid = ff->nodeid;"
    },
    {
        "line": 85,
        "fullcodeline": "req->in.numargs = 1;"
    },
    {
        "line": 86,
        "fullcodeline": "req->in.args[0].size = sizeof(inarg);"
    },
    {
        "line": 87,
        "fullcodeline": "req->in.args[0].value = &inarg;"
    },
    {
        "line": 99,
        "fullcodeline": "req->out.numargs = 2;"
    },
    {
        "line": 100,
        "fullcodeline": "req->out.args[0].size = sizeof(outarg);"
    },
    {
        "line": 101,
        "fullcodeline": "req->out.args[0].value = &outarg;"
    },
    {
        "line": 102,
        "fullcodeline": "req->out.args[1].size = out_size;"
    },
    {
        "line": 103,
        "fullcodeline": "req->out.argpages = 1;"
    },
    {
        "line": 104,
        "fullcodeline": "req->out.argvar = 1;"
    },
    {
        "line": 106,
        "fullcodeline": "fuse_request_send(fc, req);"
    },
    {
        "line": 107,
        "fullcodeline": "err = req->out.h.error;"
    },
    {
        "line": 108,
        "fullcodeline": "transferred = req->out.args[1].size;"
    },
    {
        "line": 109,
        "fullcodeline": "fuse_put_request(fc, req);"
    },
    {
        "line": 110,
        "fullcodeline": "req = NULL;"
    },
    {
        "line": 150,
        "fullcodeline": "err = -EIO;"
    },
    {
        "line": 154,
        "fullcodeline": "err = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);"
    },
    {
        "line": 162,
        "fullcodeline": "kfree(pages);"
    },
    {
        "line": 27,
        "fullcodeline": "if (!pages || !iov_page)"
    },
    {
        "line": 34,
        "fullcodeline": "if (!(flags & FUSE_IOCTL_UNRESTRICTED)) {"
    },
    {
        "line": 64,
        "fullcodeline": "if (max_pages > FUSE_MAX_PAGES_PER_REQ)"
    },
    {
        "line": 66,
        "fullcodeline": "while (num_pages < max_pages) {"
    },
    {
        "line": 74,
        "fullcodeline": "if (IS_ERR(req)) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (outarg.flags & FUSE_IOCTL_RETRY) {"
    },
    {
        "line": 151,
        "fullcodeline": "if (transferred > inarg.out_size)"
    },
    {
        "line": 161,
        "fullcodeline": "__free_page(pages[--num_pages]);"
    },
    {
        "line": 164,
        "fullcodeline": "return err ? err : outarg.result;"
    },
    {
        "line": 35,
        "fullcodeline": "struct iovec *iov = page_address(iov_page);"
    },
    {
        "line": 38,
        "fullcodeline": "iov->iov_len = _IOC_SIZE(cmd);"
    },
    {
        "line": 67,
        "fullcodeline": "pages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);"
    },
    {
        "line": 70,
        "fullcodeline": "num_pages++;"
    },
    {
        "line": 75,
        "fullcodeline": "err = PTR_ERR(req);"
    },
    {
        "line": 76,
        "fullcodeline": "req = NULL;"
    },
    {
        "line": 89,
        "fullcodeline": "req->in.numargs++;"
    },
    {
        "line": 90,
        "fullcodeline": "req->in.args[1].size = in_size;"
    },
    {
        "line": 91,
        "fullcodeline": "req->in.argpages = 1;"
    },
    {
        "line": 93,
        "fullcodeline": "err = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,"
    },
    {
        "line": 119,
        "fullcodeline": "err = -EIO;"
    },
    {
        "line": 123,
        "fullcodeline": "in_iovs = outarg.in_iovs;"
    },
    {
        "line": 124,
        "fullcodeline": "out_iovs = outarg.out_iovs;"
    },
    {
        "line": 130,
        "fullcodeline": "err = -ENOMEM;"
    },
    {
        "line": 136,
        "fullcodeline": "vaddr = kmap_atomic(pages[0], KM_USER0);"
    },
    {
        "line": 137,
        "fullcodeline": "err = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,"
    },
    {
        "line": 140,
        "fullcodeline": "kunmap_atomic(vaddr, KM_USER0);"
    },
    {
        "line": 144,
        "fullcodeline": "in_iov = page_address(iov_page);"
    },
    {
        "line": 145,
        "fullcodeline": "out_iov = in_iov + in_iovs;"
    },
    {
        "line": 157,
        "fullcodeline": "fuse_put_request(fc, req);"
    },
    {
        "line": 159,
        "fullcodeline": "__free_page(iov_page);"
    },
    {
        "line": 7,
        "fullcodeline": ".fh = ff->fh,"
    },
    {
        "line": 8,
        "fullcodeline": ".cmd = cmd,"
    },
    {
        "line": 9,
        "fullcodeline": ".arg = arg,"
    },
    {
        "line": 10,
        "fullcodeline": ".flags = flags"
    },
    {
        "line": 40,
        "fullcodeline": "if (_IOC_DIR(cmd) & _IOC_WRITE) {"
    },
    {
        "line": 45,
        "fullcodeline": "if (_IOC_DIR(cmd) & _IOC_READ) {"
    },
    {
        "line": 68,
        "fullcodeline": "if (!pages[num_pages])"
    },
    {
        "line": 120,
        "fullcodeline": "if (!(flags & FUSE_IOCTL_UNRESTRICTED))"
    },
    {
        "line": 131,
        "fullcodeline": "if (in_iovs > FUSE_IOCTL_MAX_IOV ||"
    },
    {
        "line": 41,
        "fullcodeline": "in_iov = iov;"
    },
    {
        "line": 42,
        "fullcodeline": "in_iovs = 1;"
    },
    {
        "line": 46,
        "fullcodeline": "out_iov = iov;"
    },
    {
        "line": 47,
        "fullcodeline": "out_iovs = 1;"
    },
    {
        "line": 133,
        "fullcodeline": "in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)"
    },
    {
        "line": 138,
        "fullcodeline": "transferred, in_iovs + out_iovs,"
    },
    {
        "line": 139,
        "fullcodeline": "(flags & FUSE_IOCTL_COMPAT) != 0);"
    },
    {
        "line": 132,
        "fullcodeline": "out_iovs > FUSE_IOCTL_MAX_IOV ||"
    }
]