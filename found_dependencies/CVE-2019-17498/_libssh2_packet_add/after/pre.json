[
    {
        "line": 4,
        "fullcodeline": "int rc = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "unsigned char *message = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "unsigned char *language = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t message_len = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t language_len = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "LIBSSH2_CHANNEL *channelp = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "size_t data_head = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char msg = data[0];"
    },
    {
        "line": 45,
        "fullcodeline": "if(session->packAdd_state == libssh2_NB_state_allocated) {"
    },
    {
        "line": 554,
        "fullcodeline": "if(session->packAdd_state == libssh2_NB_state_sent) {"
    },
    {
        "line": 15,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS,"
    },
    {
        "line": 29,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_allocated;"
    },
    {
        "line": 551,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_sent;"
    },
    {
        "line": 555,
        "fullcodeline": "LIBSSH2_PACKET *packetp ="
    },
    {
        "line": 570,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_sent1;"
    },
    {
        "line": 573,
        "fullcodeline": "if((msg == SSH_MSG_KEXINIT &&"
    },
    {
        "line": 575,
        "fullcodeline": "(session->packAdd_state == libssh2_NB_state_sent2)) {"
    },
    {
        "line": 593,
        "fullcodeline": "session->readPack_state = libssh2_NB_state_idle;"
    },
    {
        "line": 595,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_idle;"
    },
    {
        "line": 596,
        "fullcodeline": "session->fullpacket_state = libssh2_NB_state_idle;"
    },
    {
        "line": 598,
        "fullcodeline": "memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));"
    },
    {
        "line": 604,
        "fullcodeline": "rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);"
    },
    {
        "line": 17,
        "fullcodeline": "(int) msg, (int) datalen);"
    },
    {
        "line": 19,
        "fullcodeline": "if((macstate == LIBSSH2_MAC_INVALID) &&"
    },
    {
        "line": 556,
        "fullcodeline": "LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));"
    },
    {
        "line": 557,
        "fullcodeline": "if(!packetp) {"
    },
    {
        "line": 574,
        "fullcodeline": "!(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||"
    },
    {
        "line": 576,
        "fullcodeline": "if(session->packAdd_state == libssh2_NB_state_sent1) {"
    },
    {
        "line": 605,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 20,
        "fullcodeline": "(!session->macerror ||"
    },
    {
        "line": 25,
        "fullcodeline": "LIBSSH2_FREE(session, data);"
    },
    {
        "line": 80,
        "fullcodeline": "LIBSSH2_FREE(session, data);"
    },
    {
        "line": 81,
        "fullcodeline": "session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;"
    },
    {
        "line": 82,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_idle;"
    },
    {
        "line": 137,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS,"
    },
    {
        "line": 187,
        "fullcodeline": "data_head += 4;"
    },
    {
        "line": 199,
        "fullcodeline": "data_head += 9;"
    },
    {
        "line": 309,
        "fullcodeline": "channelp->read_avail += datalen - data_head;"
    },
    {
        "line": 311,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 460,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 558,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_ERROR_ALLOC,"
    },
    {
        "line": 582,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");"
    },
    {
        "line": 21,
        "fullcodeline": "LIBSSH2_MACERROR(session, (char *) data, datalen))) {"
    },
    {
        "line": 26,
        "fullcodeline": "return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,"
    },
    {
        "line": 57,
        "fullcodeline": "if(datalen >= 5) {"
    },
    {
        "line": 83,
        "fullcodeline": "return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,"
    },
    {
        "line": 91,
        "fullcodeline": "if(datalen >= 2) {"
    },
    {
        "line": 111,
        "fullcodeline": "if(datalen >= 2) {"
    },
    {
        "line": 151,
        "fullcodeline": "if(datalen >= 5) {"
    },
    {
        "line": 201,
        "fullcodeline": "if(datalen >= data_head)"
    },
    {
        "line": 206,
        "fullcodeline": "if(!channelp) {"
    },
    {
        "line": 269,
        "fullcodeline": "if(channelp->remote.packet_size < (datalen - data_head)) {"
    },
    {
        "line": 280,
        "fullcodeline": "if(channelp->remote.window_size <= channelp->read_avail) {"
    },
    {
        "line": 296,
        "fullcodeline": "if(channelp->read_avail + datalen - data_head >"
    },
    {
        "line": 353,
        "fullcodeline": "if(datalen >= 9) {"
    },
    {
        "line": 481,
        "fullcodeline": "if(datalen < 17)"
    },
    {
        "line": 512,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 58,
        "fullcodeline": "uint32_t reason = 0;"
    },
    {
        "line": 60,
        "fullcodeline": "buf.data = (unsigned char *)data;"
    },
    {
        "line": 61,
        "fullcodeline": "buf.dataptr = buf.data;"
    },
    {
        "line": 62,
        "fullcodeline": "buf.len = datalen;"
    },
    {
        "line": 63,
        "fullcodeline": "buf.dataptr++; /* advance past type */"
    },
    {
        "line": 65,
        "fullcodeline": "_libssh2_get_u32(&buf, &reason);"
    },
    {
        "line": 66,
        "fullcodeline": "_libssh2_get_string(&buf, &message, &message_len);"
    },
    {
        "line": 67,
        "fullcodeline": "_libssh2_get_string(&buf, &language, &language_len);"
    },
    {
        "line": 75,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS,"
    },
    {
        "line": 112,
        "fullcodeline": "int always_display = data[1];"
    },
    {
        "line": 154,
        "fullcodeline": "len = _libssh2_ntohu32(data + 1);"
    },
    {
        "line": 202,
        "fullcodeline": "channelp ="
    },
    {
        "line": 207,
        "fullcodeline": "_libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,"
    },
    {
        "line": 227,
        "fullcodeline": "if((channelp->remote.extended_data_ignore_mode =="
    },
    {
        "line": 229,
        "fullcodeline": "(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {"
    },
    {
        "line": 231,
        "fullcodeline": "LIBSSH2_FREE(session, data);"
    },
    {
        "line": 233,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 241,
        "fullcodeline": "channelp->remote.window_size -= datalen - data_head;"
    },
    {
        "line": 242,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 249,
        "fullcodeline": "session->packAdd_channelp = channelp;"
    },
    {
        "line": 253,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump1;"
    },
    {
        "line": 254,
        "fullcodeline": "rc = _libssh2_channel_receive_window_adjust(session->"
    },
    {
        "line": 274,
        "fullcodeline": "_libssh2_error(session,"
    },
    {
        "line": 278,
        "fullcodeline": "datalen = channelp->remote.packet_size + data_head;"
    },
    {
        "line": 285,
        "fullcodeline": "_libssh2_error(session,"
    },
    {
        "line": 298,
        "fullcodeline": "_libssh2_error(session,"
    },
    {
        "line": 302,
        "fullcodeline": "datalen = channelp->remote.window_size -"
    },
    {
        "line": 313,
        "fullcodeline": "(long)(datalen - data_head),"
    },
    {
        "line": 326,
        "fullcodeline": "channelp ="
    },
    {
        "line": 354,
        "fullcodeline": "uint32_t channel = _libssh2_ntohu32(data + 1);"
    },
    {
        "line": 355,
        "fullcodeline": "uint32_t len = _libssh2_ntohu32(data + 5);"
    },
    {
        "line": 356,
        "fullcodeline": "unsigned char want_reply = 1;"
    },
    {
        "line": 361,
        "fullcodeline": "_libssh2_debug(session,"
    },
    {
        "line": 451,
        "fullcodeline": "channelp ="
    },
    {
        "line": 114,
        "fullcodeline": "if(datalen >= 6) {"
    },
    {
        "line": 203,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 236,
        "fullcodeline": "if(channelp->read_avail + datalen - data_head >="
    },
    {
        "line": 245,
        "fullcodeline": "datalen - data_head,"
    },
    {
        "line": 258,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 327,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 333,
        "fullcodeline": "_libssh2_debug(session,"
    },
    {
        "line": 358,
        "fullcodeline": "if((len + 9) < datalen)"
    },
    {
        "line": 452,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 528,
        "fullcodeline": "uint32_t bytestoadd = _libssh2_ntohu32(data + 5);"
    },
    {
        "line": 70,
        "fullcodeline": "LIBSSH2_DISCONNECT(session, reason, (const char *)message,"
    },
    {
        "line": 93,
        "fullcodeline": "LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);"
    },
    {
        "line": 116,
        "fullcodeline": "buf.data = (unsigned char *)data;"
    },
    {
        "line": 117,
        "fullcodeline": "buf.dataptr = buf.data;"
    },
    {
        "line": 118,
        "fullcodeline": "buf.len = datalen;"
    },
    {
        "line": 119,
        "fullcodeline": "buf.dataptr += 2; /* advance past type & always display */"
    },
    {
        "line": 121,
        "fullcodeline": "_libssh2_get_string(&buf, &message, &message_len);"
    },
    {
        "line": 122,
        "fullcodeline": "_libssh2_get_string(&buf, &language, &language_len);"
    },
    {
        "line": 126,
        "fullcodeline": "LIBSSH2_DEBUG(session, always_display,"
    },
    {
        "line": 155,
        "fullcodeline": "if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {"
    },
    {
        "line": 156,
        "fullcodeline": "want_reply = data[5 + len];"
    },
    {
        "line": 157,
        "fullcodeline": "_libssh2_debug(session,"
    },
    {
        "line": 165,
        "fullcodeline": "static const unsigned char packet ="
    },
    {
        "line": 168,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump5;"
    },
    {
        "line": 169,
        "fullcodeline": "rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);"
    },
    {
        "line": 204,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 235,
        "fullcodeline": "(int) (datalen - 13));"
    },
    {
        "line": 238,
        "fullcodeline": "datalen = channelp->remote.window_size -"
    },
    {
        "line": 256,
        "fullcodeline": "datalen - 13,"
    },
    {
        "line": 328,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 359,
        "fullcodeline": "want_reply = data[len + 9];"
    },
    {
        "line": 366,
        "fullcodeline": "if(len == sizeof(\"exit-status\") - 1"
    },
    {
        "line": 368,
        "fullcodeline": "&& !memcmp(\"exit-status\", data + 9,"
    },
    {
        "line": 430,
        "fullcodeline": "unsigned char packet[5];"
    },
    {
        "line": 432,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump4;"
    },
    {
        "line": 433,
        "fullcodeline": "packet[0] = SSH_MSG_CHANNEL_FAILURE;"
    },
    {
        "line": 435,
        "fullcodeline": "rc = _libssh2_transport_send(session, packet, 5, NULL, 0);"
    },
    {
        "line": 453,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 530,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 97,
        "fullcodeline": "LIBSSH2_IGNORE(session, \"\", 0);"
    },
    {
        "line": 170,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 367,
        "fullcodeline": "&& (sizeof(\"exit-status\") - 1 + 9) <= datalen"
    },
    {
        "line": 372,
        "fullcodeline": "if(datalen >= 20)"
    },
    {
        "line": 376,
        "fullcodeline": "if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {"
    },
    {
        "line": 436,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 483,
        "fullcodeline": "else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&"
    },
    {
        "line": 487,
        "fullcodeline": "(memcmp(data + 5, \"forwarded-tcpip\","
    },
    {
        "line": 491,
        "fullcodeline": "memset(&session->packAdd_Qlstn_state, 0,"
    },
    {
        "line": 495,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump2;"
    },
    {
        "line": 496,
        "fullcodeline": "rc = packet_queue_listener(session, data, datalen,"
    },
    {
        "line": 531,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 533,
        "fullcodeline": "channelp->local.window_size += bytestoadd;"
    },
    {
        "line": 535,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 369,
        "fullcodeline": "sizeof(\"exit-status\") - 1)) {"
    },
    {
        "line": 373,
        "fullcodeline": "channelp ="
    },
    {
        "line": 377,
        "fullcodeline": "channelp->exit_status ="
    },
    {
        "line": 379,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 484,
        "fullcodeline": "((sizeof(\"forwarded-tcpip\") - 1) =="
    },
    {
        "line": 374,
        "fullcodeline": "_libssh2_channel_locate(session, channel);"
    },
    {
        "line": 378,
        "fullcodeline": "_libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));"
    },
    {
        "line": 388,
        "fullcodeline": "else if(len == sizeof(\"exit-signal\") - 1"
    },
    {
        "line": 390,
        "fullcodeline": "&& !memcmp(\"exit-signal\", data + 9,"
    },
    {
        "line": 485,
        "fullcodeline": "_libssh2_ntohu32(data + 1))"
    },
    {
        "line": 488,
        "fullcodeline": "sizeof(\"forwarded-tcpip\") - 1) == 0)) {"
    },
    {
        "line": 389,
        "fullcodeline": "&& (sizeof(\"exit-signal\") - 1 + 9) <= datalen"
    },
    {
        "line": 393,
        "fullcodeline": "if(datalen >= 20)"
    },
    {
        "line": 396,
        "fullcodeline": "if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {"
    },
    {
        "line": 499,
        "fullcodeline": "else if((datalen >= (sizeof(\"x11\") + 4)) &&"
    },
    {
        "line": 501,
        "fullcodeline": "(memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {"
    },
    {
        "line": 504,
        "fullcodeline": "memset(&session->packAdd_x11open_state, 0,"
    },
    {
        "line": 508,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump3;"
    },
    {
        "line": 509,
        "fullcodeline": "rc = packet_x11_open(session, data, datalen,"
    },
    {
        "line": 391,
        "fullcodeline": "sizeof(\"exit-signal\") - 1)) {"
    },
    {
        "line": 394,
        "fullcodeline": "channelp = _libssh2_channel_locate(session, channel);"
    },
    {
        "line": 398,
        "fullcodeline": "uint32_t namelen ="
    },
    {
        "line": 500,
        "fullcodeline": "((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&"
    },
    {
        "line": 399,
        "fullcodeline": "_libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));"
    },
    {
        "line": 401,
        "fullcodeline": "if(namelen <= UINT_MAX - 1) {"
    },
    {
        "line": 409,
        "fullcodeline": "if(!channelp->exit_signal)"
    },
    {
        "line": 402,
        "fullcodeline": "channelp->exit_signal ="
    },
    {
        "line": 410,
        "fullcodeline": "rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,"
    },
    {
        "line": 403,
        "fullcodeline": "LIBSSH2_ALLOC(session, namelen + 1);"
    },
    {
        "line": 406,
        "fullcodeline": "channelp->exit_signal = NULL;"
    },
    {
        "line": 414,
        "fullcodeline": "memcpy(channelp->exit_signal,"
    },
    {
        "line": 416,
        "fullcodeline": "channelp->exit_signal[namelen] = '\\0';"
    },
    {
        "line": 418,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    }
]