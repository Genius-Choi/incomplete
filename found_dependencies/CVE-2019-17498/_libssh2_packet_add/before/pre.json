[
    {
        "line": 4,
        "fullcodeline": "int rc = 0;"
    },
    {
        "line": 5,
        "fullcodeline": "char *message = NULL;"
    },
    {
        "line": 6,
        "fullcodeline": "char *language = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "size_t message_len = 0;"
    },
    {
        "line": 8,
        "fullcodeline": "size_t language_len = 0;"
    },
    {
        "line": 9,
        "fullcodeline": "LIBSSH2_CHANNEL *channelp = NULL;"
    },
    {
        "line": 10,
        "fullcodeline": "size_t data_head = 0;"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char msg = data[0];"
    },
    {
        "line": 45,
        "fullcodeline": "if(session->packAdd_state == libssh2_NB_state_allocated) {"
    },
    {
        "line": 564,
        "fullcodeline": "if(session->packAdd_state == libssh2_NB_state_sent) {"
    },
    {
        "line": 15,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS,"
    },
    {
        "line": 29,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_allocated;"
    },
    {
        "line": 561,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_sent;"
    },
    {
        "line": 565,
        "fullcodeline": "LIBSSH2_PACKET *packetp ="
    },
    {
        "line": 580,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_sent1;"
    },
    {
        "line": 583,
        "fullcodeline": "if((msg == SSH_MSG_KEXINIT &&"
    },
    {
        "line": 585,
        "fullcodeline": "(session->packAdd_state == libssh2_NB_state_sent2)) {"
    },
    {
        "line": 603,
        "fullcodeline": "session->readPack_state = libssh2_NB_state_idle;"
    },
    {
        "line": 605,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_idle;"
    },
    {
        "line": 606,
        "fullcodeline": "session->fullpacket_state = libssh2_NB_state_idle;"
    },
    {
        "line": 608,
        "fullcodeline": "memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));"
    },
    {
        "line": 614,
        "fullcodeline": "rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);"
    },
    {
        "line": 17,
        "fullcodeline": "(int) msg, (int) datalen);"
    },
    {
        "line": 19,
        "fullcodeline": "if((macstate == LIBSSH2_MAC_INVALID) &&"
    },
    {
        "line": 566,
        "fullcodeline": "LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));"
    },
    {
        "line": 567,
        "fullcodeline": "if(!packetp) {"
    },
    {
        "line": 584,
        "fullcodeline": "!(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||"
    },
    {
        "line": 586,
        "fullcodeline": "if(session->packAdd_state == libssh2_NB_state_sent1) {"
    },
    {
        "line": 615,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 20,
        "fullcodeline": "(!session->macerror ||"
    },
    {
        "line": 25,
        "fullcodeline": "LIBSSH2_FREE(session, data);"
    },
    {
        "line": 90,
        "fullcodeline": "LIBSSH2_FREE(session, data);"
    },
    {
        "line": 91,
        "fullcodeline": "session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;"
    },
    {
        "line": 92,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_idle;"
    },
    {
        "line": 147,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS,"
    },
    {
        "line": 197,
        "fullcodeline": "data_head += 4;"
    },
    {
        "line": 209,
        "fullcodeline": "data_head += 9;"
    },
    {
        "line": 319,
        "fullcodeline": "channelp->read_avail += datalen - data_head;"
    },
    {
        "line": 321,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 470,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 568,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_ERROR_ALLOC,"
    },
    {
        "line": 592,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");"
    },
    {
        "line": 21,
        "fullcodeline": "LIBSSH2_MACERROR(session, (char *) data, datalen))) {"
    },
    {
        "line": 26,
        "fullcodeline": "return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,"
    },
    {
        "line": 57,
        "fullcodeline": "if(datalen >= 5) {"
    },
    {
        "line": 93,
        "fullcodeline": "return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,"
    },
    {
        "line": 101,
        "fullcodeline": "if(datalen >= 2) {"
    },
    {
        "line": 121,
        "fullcodeline": "if(datalen >= 2) {"
    },
    {
        "line": 161,
        "fullcodeline": "if(datalen >= 5) {"
    },
    {
        "line": 211,
        "fullcodeline": "if(datalen >= data_head)"
    },
    {
        "line": 216,
        "fullcodeline": "if(!channelp) {"
    },
    {
        "line": 279,
        "fullcodeline": "if(channelp->remote.packet_size < (datalen - data_head)) {"
    },
    {
        "line": 290,
        "fullcodeline": "if(channelp->remote.window_size <= channelp->read_avail) {"
    },
    {
        "line": 306,
        "fullcodeline": "if(channelp->read_avail + datalen - data_head >"
    },
    {
        "line": 363,
        "fullcodeline": "if(datalen >= 9) {"
    },
    {
        "line": 491,
        "fullcodeline": "if(datalen < 17)"
    },
    {
        "line": 522,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 58,
        "fullcodeline": "size_t reason = _libssh2_ntohu32(data + 1);"
    },
    {
        "line": 85,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_TRANS,"
    },
    {
        "line": 122,
        "fullcodeline": "int always_display = data[1];"
    },
    {
        "line": 164,
        "fullcodeline": "len = _libssh2_ntohu32(data + 1);"
    },
    {
        "line": 212,
        "fullcodeline": "channelp ="
    },
    {
        "line": 217,
        "fullcodeline": "_libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,"
    },
    {
        "line": 237,
        "fullcodeline": "if((channelp->remote.extended_data_ignore_mode =="
    },
    {
        "line": 239,
        "fullcodeline": "(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {"
    },
    {
        "line": 241,
        "fullcodeline": "LIBSSH2_FREE(session, data);"
    },
    {
        "line": 243,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 251,
        "fullcodeline": "channelp->remote.window_size -= datalen - data_head;"
    },
    {
        "line": 252,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 259,
        "fullcodeline": "session->packAdd_channelp = channelp;"
    },
    {
        "line": 263,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump1;"
    },
    {
        "line": 264,
        "fullcodeline": "rc = _libssh2_channel_receive_window_adjust(session->"
    },
    {
        "line": 284,
        "fullcodeline": "_libssh2_error(session,"
    },
    {
        "line": 288,
        "fullcodeline": "datalen = channelp->remote.packet_size + data_head;"
    },
    {
        "line": 295,
        "fullcodeline": "_libssh2_error(session,"
    },
    {
        "line": 308,
        "fullcodeline": "_libssh2_error(session,"
    },
    {
        "line": 312,
        "fullcodeline": "datalen = channelp->remote.window_size -"
    },
    {
        "line": 323,
        "fullcodeline": "(long)(datalen - data_head),"
    },
    {
        "line": 336,
        "fullcodeline": "channelp ="
    },
    {
        "line": 364,
        "fullcodeline": "uint32_t channel = _libssh2_ntohu32(data + 1);"
    },
    {
        "line": 365,
        "fullcodeline": "uint32_t len = _libssh2_ntohu32(data + 5);"
    },
    {
        "line": 366,
        "fullcodeline": "unsigned char want_reply = 1;"
    },
    {
        "line": 371,
        "fullcodeline": "_libssh2_debug(session,"
    },
    {
        "line": 461,
        "fullcodeline": "channelp ="
    },
    {
        "line": 60,
        "fullcodeline": "if(datalen >= 9) {"
    },
    {
        "line": 124,
        "fullcodeline": "if(datalen >= 6) {"
    },
    {
        "line": 213,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 246,
        "fullcodeline": "if(channelp->read_avail + datalen - data_head >="
    },
    {
        "line": 255,
        "fullcodeline": "datalen - data_head,"
    },
    {
        "line": 268,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 337,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 343,
        "fullcodeline": "_libssh2_debug(session,"
    },
    {
        "line": 368,
        "fullcodeline": "if((len + 9) < datalen)"
    },
    {
        "line": 462,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 538,
        "fullcodeline": "uint32_t bytestoadd = _libssh2_ntohu32(data + 5);"
    },
    {
        "line": 61,
        "fullcodeline": "message_len = _libssh2_ntohu32(data + 5);"
    },
    {
        "line": 82,
        "fullcodeline": "LIBSSH2_DISCONNECT(session, reason, message,"
    },
    {
        "line": 103,
        "fullcodeline": "LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);"
    },
    {
        "line": 125,
        "fullcodeline": "message_len = _libssh2_ntohu32(data + 2);"
    },
    {
        "line": 139,
        "fullcodeline": "LIBSSH2_DEBUG(session, always_display, message,"
    },
    {
        "line": 166,
        "fullcodeline": "want_reply = data[5 + len];"
    },
    {
        "line": 167,
        "fullcodeline": "_libssh2_debug(session,"
    },
    {
        "line": 175,
        "fullcodeline": "static const unsigned char packet ="
    },
    {
        "line": 178,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump5;"
    },
    {
        "line": 179,
        "fullcodeline": "rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);"
    },
    {
        "line": 214,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 245,
        "fullcodeline": "(int) (datalen - 13));"
    },
    {
        "line": 248,
        "fullcodeline": "datalen = channelp->remote.window_size -"
    },
    {
        "line": 266,
        "fullcodeline": "datalen - 13,"
    },
    {
        "line": 338,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 369,
        "fullcodeline": "want_reply = data[len + 9];"
    },
    {
        "line": 376,
        "fullcodeline": "if(len == sizeof(\"exit-status\") - 1"
    },
    {
        "line": 378,
        "fullcodeline": "&& !memcmp(\"exit-status\", data + 9,"
    },
    {
        "line": 440,
        "fullcodeline": "unsigned char packet[5];"
    },
    {
        "line": 442,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump4;"
    },
    {
        "line": 443,
        "fullcodeline": "packet[0] = SSH_MSG_CHANNEL_FAILURE;"
    },
    {
        "line": 445,
        "fullcodeline": "rc = _libssh2_transport_send(session, packet, 5, NULL, 0);"
    },
    {
        "line": 463,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 540,
        "fullcodeline": "_libssh2_channel_locate(session,"
    },
    {
        "line": 63,
        "fullcodeline": "if(message_len < datalen-13) {"
    },
    {
        "line": 107,
        "fullcodeline": "LIBSSH2_IGNORE(session, \"\", 0);"
    },
    {
        "line": 127,
        "fullcodeline": "if(message_len <= (datalen - 10)) {"
    },
    {
        "line": 180,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 377,
        "fullcodeline": "&& (sizeof(\"exit-status\") - 1 + 9) <= datalen"
    },
    {
        "line": 382,
        "fullcodeline": "if(datalen >= 20)"
    },
    {
        "line": 386,
        "fullcodeline": "if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {"
    },
    {
        "line": 446,
        "fullcodeline": "if(rc == LIBSSH2_ERROR_EAGAIN)"
    },
    {
        "line": 493,
        "fullcodeline": "else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&"
    },
    {
        "line": 497,
        "fullcodeline": "(memcmp(data + 5, \"forwarded-tcpip\","
    },
    {
        "line": 501,
        "fullcodeline": "memset(&session->packAdd_Qlstn_state, 0,"
    },
    {
        "line": 505,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump2;"
    },
    {
        "line": 506,
        "fullcodeline": "rc = packet_queue_listener(session, data, datalen,"
    },
    {
        "line": 541,
        "fullcodeline": "_libssh2_ntohu32(data + 1));"
    },
    {
        "line": 543,
        "fullcodeline": "channelp->local.window_size += bytestoadd;"
    },
    {
        "line": 545,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 65,
        "fullcodeline": "message = (char *) data + 9;"
    },
    {
        "line": 67,
        "fullcodeline": "language_len ="
    },
    {
        "line": 69,
        "fullcodeline": "language = (char *) data + 9 + message_len + 4;"
    },
    {
        "line": 129,
        "fullcodeline": "message = (char *) data + 6;"
    },
    {
        "line": 130,
        "fullcodeline": "language_len = _libssh2_ntohu32(data + 6 +"
    },
    {
        "line": 379,
        "fullcodeline": "sizeof(\"exit-status\") - 1)) {"
    },
    {
        "line": 383,
        "fullcodeline": "channelp ="
    },
    {
        "line": 387,
        "fullcodeline": "channelp->exit_status ="
    },
    {
        "line": 389,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    },
    {
        "line": 494,
        "fullcodeline": "((sizeof(\"forwarded-tcpip\") - 1) =="
    },
    {
        "line": 68,
        "fullcodeline": "_libssh2_ntohu32(data + 9 + message_len);"
    },
    {
        "line": 71,
        "fullcodeline": "if(language_len > (datalen-13-message_len)) {"
    },
    {
        "line": 79,
        "fullcodeline": "message_len = 0;"
    },
    {
        "line": 133,
        "fullcodeline": "if(language_len <= (datalen - 10 - message_len))"
    },
    {
        "line": 384,
        "fullcodeline": "_libssh2_channel_locate(session, channel);"
    },
    {
        "line": 388,
        "fullcodeline": "_libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));"
    },
    {
        "line": 398,
        "fullcodeline": "else if(len == sizeof(\"exit-signal\") - 1"
    },
    {
        "line": 400,
        "fullcodeline": "&& !memcmp(\"exit-signal\", data + 9,"
    },
    {
        "line": 495,
        "fullcodeline": "_libssh2_ntohu32(data + 1))"
    },
    {
        "line": 498,
        "fullcodeline": "sizeof(\"forwarded-tcpip\") - 1) == 0)) {"
    },
    {
        "line": 73,
        "fullcodeline": "language = message = NULL;"
    },
    {
        "line": 74,
        "fullcodeline": "language_len = message_len = 0;"
    },
    {
        "line": 134,
        "fullcodeline": "language = (char *) data + 10 + message_len;"
    },
    {
        "line": 399,
        "fullcodeline": "&& (sizeof(\"exit-signal\") - 1 + 9) <= datalen"
    },
    {
        "line": 403,
        "fullcodeline": "if(datalen >= 20)"
    },
    {
        "line": 406,
        "fullcodeline": "if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {"
    },
    {
        "line": 509,
        "fullcodeline": "else if((datalen >= (sizeof(\"x11\") + 4)) &&"
    },
    {
        "line": 511,
        "fullcodeline": "(memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {"
    },
    {
        "line": 514,
        "fullcodeline": "memset(&session->packAdd_x11open_state, 0,"
    },
    {
        "line": 518,
        "fullcodeline": "session->packAdd_state = libssh2_NB_state_jump3;"
    },
    {
        "line": 519,
        "fullcodeline": "rc = packet_x11_open(session, data, datalen,"
    },
    {
        "line": 401,
        "fullcodeline": "sizeof(\"exit-signal\") - 1)) {"
    },
    {
        "line": 404,
        "fullcodeline": "channelp = _libssh2_channel_locate(session, channel);"
    },
    {
        "line": 408,
        "fullcodeline": "uint32_t namelen ="
    },
    {
        "line": 510,
        "fullcodeline": "((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&"
    },
    {
        "line": 409,
        "fullcodeline": "_libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));"
    },
    {
        "line": 411,
        "fullcodeline": "if(namelen <= UINT_MAX - 1) {"
    },
    {
        "line": 419,
        "fullcodeline": "if(!channelp->exit_signal)"
    },
    {
        "line": 412,
        "fullcodeline": "channelp->exit_signal ="
    },
    {
        "line": 420,
        "fullcodeline": "rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,"
    },
    {
        "line": 413,
        "fullcodeline": "LIBSSH2_ALLOC(session, namelen + 1);"
    },
    {
        "line": 416,
        "fullcodeline": "channelp->exit_signal = NULL;"
    },
    {
        "line": 424,
        "fullcodeline": "memcpy(channelp->exit_signal,"
    },
    {
        "line": 426,
        "fullcodeline": "channelp->exit_signal[namelen] = '\\0';"
    },
    {
        "line": 428,
        "fullcodeline": "_libssh2_debug(session, LIBSSH2_TRACE_CONN,"
    }
]