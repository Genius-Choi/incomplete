[
    {
        "line": 2,
        "fullcodeline": "assert(len>28); // size of largest string"
    },
    {
        "line": 104,
        "fullcodeline": "espruino_snprintf(str, len, \"?[%d]\", token);"
    },
    {
        "line": 4,
        "fullcodeline": "if (token>32 && token<128) {"
    },
    {
        "line": 27,
        "fullcodeline": "if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {"
    },
    {
        "line": 5,
        "fullcodeline": "assert(len>=4);"
    },
    {
        "line": 6,
        "fullcodeline": "str[0] = '\\'';"
    },
    {
        "line": 7,
        "fullcodeline": "str[1] = (char)token;"
    },
    {
        "line": 8,
        "fullcodeline": "str[2] = '\\'';"
    },
    {
        "line": 9,
        "fullcodeline": "str[3] = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "case LEX_EOF : strcpy(str, \"EOF\"); return;"
    },
    {
        "line": 16,
        "fullcodeline": "case LEX_ID : strcpy(str, \"ID\"); return;"
    },
    {
        "line": 17,
        "fullcodeline": "case LEX_INT : strcpy(str, \"INT\"); return;"
    },
    {
        "line": 18,
        "fullcodeline": "case LEX_FLOAT : strcpy(str, \"FLOAT\"); return;"
    },
    {
        "line": 19,
        "fullcodeline": "case LEX_STR : strcpy(str, \"STRING\"); return;"
    },
    {
        "line": 20,
        "fullcodeline": "case LEX_UNFINISHED_STR : strcpy(str, \"UNFINISHED STRING\"); return;"
    },
    {
        "line": 21,
        "fullcodeline": "case LEX_TEMPLATE_LITERAL : strcpy(str, \"TEMPLATE LITERAL\"); return;"
    },
    {
        "line": 22,
        "fullcodeline": "case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, \"UNFINISHED TEMPLATE LITERAL\"); return;"
    },
    {
        "line": 23,
        "fullcodeline": "case LEX_REGEX : strcpy(str, \"REGEX\"); return;"
    },
    {
        "line": 24,
        "fullcodeline": "case LEX_UNFINISHED_REGEX : strcpy(str, \"UNFINISHED REGEX\"); return;"
    },
    {
        "line": 25,
        "fullcodeline": "case LEX_UNFINISHED_COMMENT : strcpy(str, \"UNFINISHED COMMENT\"); return;"
    },
    {
        "line": 28,
        "fullcodeline": "const char tokenNames[] ="
    },
    {
        "line": 92,
        "fullcodeline": "unsigned int p = 0;"
    },
    {
        "line": 93,
        "fullcodeline": "int n = token-_LEX_OPERATOR_START;"
    },
    {
        "line": 99,
        "fullcodeline": "assert(n==0);"
    },
    {
        "line": 100,
        "fullcodeline": "strcpy(str, &tokenNames[p]);"
    },
    {
        "line": 94,
        "fullcodeline": "while (n>0 && p<sizeof(tokenNames)) {"
    },
    {
        "line": 96,
        "fullcodeline": "p++; // skip the zero"
    },
    {
        "line": 97,
        "fullcodeline": "n--; // next token"
    },
    {
        "line": 95,
        "fullcodeline": "while (tokenNames[p] && p<sizeof(tokenNames)) p++;"
    }
]