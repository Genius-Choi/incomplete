[
    {
        "line": 31,
        "fullcodeline": "(void) fnd;"
    },
    {
        "line": 32,
        "fullcodeline": "(void) evd;"
    },
    {
        "line": 2,
        "fullcodeline": "if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {"
    },
    {
        "line": 4,
        "fullcodeline": "while (c->recv.buf != NULL && c->recv.len > 0) {"
    },
    {
        "line": 5,
        "fullcodeline": "int n = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);"
    },
    {
        "line": 6,
        "fullcodeline": "bool is_chunked = n > 0 && mg_is_chunked(&hm);"
    },
    {
        "line": 7,
        "fullcodeline": "if (ev == MG_EV_CLOSE) {"
    },
    {
        "line": 15,
        "fullcodeline": "if (n < 0 && ev == MG_EV_READ) {"
    },
    {
        "line": 8,
        "fullcodeline": "hm.message.len = c->recv.len;"
    },
    {
        "line": 9,
        "fullcodeline": "hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);"
    },
    {
        "line": 16,
        "fullcodeline": "mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);"
    },
    {
        "line": 10,
        "fullcodeline": "} else if (is_chunked && n > 0) {"
    },
    {
        "line": 18,
        "fullcodeline": "} else if (n > 0 && (size_t) c->recv.len >= hm.message.len) {"
    },
    {
        "line": 11,
        "fullcodeline": "walkchunks(c, &hm, (size_t) n);"
    },
    {
        "line": 19,
        "fullcodeline": "mg_call(c, MG_EV_HTTP_MSG, &hm);"
    },
    {
        "line": 20,
        "fullcodeline": "mg_iobuf_del(&c->recv, 0, hm.message.len);"
    },
    {
        "line": 22,
        "fullcodeline": "if (n > 0 && !is_chunked) {"
    },
    {
        "line": 23,
        "fullcodeline": "hm.chunk ="
    },
    {
        "line": 25,
        "fullcodeline": "mg_call(c, MG_EV_HTTP_CHUNK, &hm);"
    },
    {
        "line": 24,
        "fullcodeline": "mg_str_n((char *) &c->recv.buf[n], c->recv.len - (size_t) n);"
    }
]