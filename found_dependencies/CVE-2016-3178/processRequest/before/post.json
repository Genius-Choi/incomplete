[
    {
        "line": 5,
        "fullcodeline": "unsigned char buf[2048];"
    },
    {
        "line": 8,
        "fullcodeline": "struct device * d = devlist;"
    },
    {
        "line": 9,
        "fullcodeline": "unsigned char rbuf[RESPONSE_BUFFER_SIZE];"
    },
    {
        "line": 11,
        "fullcodeline": "unsigned char nrep = 0;"
    },
    {
        "line": 13,
        "fullcodeline": "struct service * newserv = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "n = read(req->socket, buf, sizeof(buf));"
    },
    {
        "line": 27,
        "fullcodeline": "t = time(NULL);"
    },
    {
        "line": 28,
        "fullcodeline": "type = buf[0];"
    },
    {
        "line": 29,
        "fullcodeline": "p = buf + 1;"
    },
    {
        "line": 30,
        "fullcodeline": "DECODELENGTH_CHECKLIMIT(l, p, buf + n);"
    },
    {
        "line": 41,
        "fullcodeline": "syslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\","
    },
    {
        "line": 254,
        "fullcodeline": "close(req->socket);"
    },
    {
        "line": 255,
        "fullcodeline": "req->socket = -1;"
    },
    {
        "line": 17,
        "fullcodeline": "if(n<0) {"
    },
    {
        "line": 23,
        "fullcodeline": "if(n==0) {"
    },
    {
        "line": 31,
        "fullcodeline": "if(p+l > buf+n) {"
    },
    {
        "line": 36,
        "fullcodeline": "if(l == 0 && type != MINISSDPD_SEARCH_ALL"
    },
    {
        "line": 20,
        "fullcodeline": "syslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);"
    },
    {
        "line": 24,
        "fullcodeline": "syslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);"
    },
    {
        "line": 32,
        "fullcodeline": "syslog(LOG_WARNING, \"bad request (length encoding l=%u n=%u)\","
    },
    {
        "line": 37,
        "fullcodeline": "&& type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {"
    },
    {
        "line": 38,
        "fullcodeline": "syslog(LOG_WARNING, \"bad request (length=0, type=%d)\", type);"
    },
    {
        "line": 45,
        "fullcodeline": "rp = rbuf;"
    },
    {
        "line": 46,
        "fullcodeline": "CODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);"
    },
    {
        "line": 47,
        "fullcodeline": "memcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);"
    },
    {
        "line": 48,
        "fullcodeline": "rp += (sizeof(MINISSDPD_VERSION) - 1);"
    },
    {
        "line": 57,
        "fullcodeline": "rp = rbuf+1;"
    },
    {
        "line": 121,
        "fullcodeline": "rbuf[0] = nrep;"
    },
    {
        "line": 122,
        "fullcodeline": "syslog(LOG_DEBUG, \"(s=%d) response : %d device%s\","
    },
    {
        "line": 135,
        "fullcodeline": "memset(newserv, 0, sizeof(struct service));\t/* set pointers to NULL */"
    },
    {
        "line": 140,
        "fullcodeline": "newserv->st = malloc(l + 1);"
    },
    {
        "line": 145,
        "fullcodeline": "memcpy(newserv->st, p, l);"
    },
    {
        "line": 146,
        "fullcodeline": "newserv->st[l] = '\\0';"
    },
    {
        "line": 147,
        "fullcodeline": "p += l;"
    },
    {
        "line": 152,
        "fullcodeline": "DECODELENGTH_CHECKLIMIT(l, p, buf + n);"
    },
    {
        "line": 161,
        "fullcodeline": "syslog(LOG_INFO, \"usn='%.*s'\", l, p);"
    },
    {
        "line": 162,
        "fullcodeline": "newserv->usn = malloc(l + 1);"
    },
    {
        "line": 167,
        "fullcodeline": "memcpy(newserv->usn, p, l);"
    },
    {
        "line": 168,
        "fullcodeline": "newserv->usn[l] = '\\0';"
    },
    {
        "line": 169,
        "fullcodeline": "p += l;"
    },
    {
        "line": 170,
        "fullcodeline": "DECODELENGTH_CHECKLIMIT(l, p, buf + n);"
    },
    {
        "line": 179,
        "fullcodeline": "syslog(LOG_INFO, \"server='%.*s'\", l, p);"
    },
    {
        "line": 180,
        "fullcodeline": "newserv->server = malloc(l + 1);"
    },
    {
        "line": 185,
        "fullcodeline": "memcpy(newserv->server, p, l);"
    },
    {
        "line": 186,
        "fullcodeline": "newserv->server[l] = '\\0';"
    },
    {
        "line": 187,
        "fullcodeline": "p += l;"
    },
    {
        "line": 188,
        "fullcodeline": "DECODELENGTH_CHECKLIMIT(l, p, buf + n);"
    },
    {
        "line": 197,
        "fullcodeline": "syslog(LOG_INFO, \"location='%.*s'\", l, p);"
    },
    {
        "line": 198,
        "fullcodeline": "newserv->location = malloc(l + 1);"
    },
    {
        "line": 203,
        "fullcodeline": "memcpy(newserv->location, p, l);"
    },
    {
        "line": 204,
        "fullcodeline": "newserv->location[l] = '\\0';"
    },
    {
        "line": 224,
        "fullcodeline": "LIST_INSERT_HEAD(&servicelisthead, newserv, entries);"
    },
    {
        "line": 225,
        "fullcodeline": "sendNotifications(NOTIF_NEW, NULL, newserv);"
    },
    {
        "line": 226,
        "fullcodeline": "newserv = NULL;"
    },
    {
        "line": 229,
        "fullcodeline": "rbuf[0] = '\\0';"
    },
    {
        "line": 234,
        "fullcodeline": "req->is_notify = 1;"
    },
    {
        "line": 237,
        "fullcodeline": "syslog(LOG_WARNING, \"Unknown request type %d\", type);"
    },
    {
        "line": 238,
        "fullcodeline": "rbuf[0] = '\\0';"
    },
    {
        "line": 247,
        "fullcodeline": "free(newserv->st);"
    },
    {
        "line": 248,
        "fullcodeline": "free(newserv->usn);"
    },
    {
        "line": 249,
        "fullcodeline": "free(newserv->server);"
    },
    {
        "line": 250,
        "fullcodeline": "free(newserv->location);"
    },
    {
        "line": 251,
        "fullcodeline": "free(newserv);"
    },
    {
        "line": 252,
        "fullcodeline": "newserv = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)"
    },
    {
        "line": 33,
        "fullcodeline": "l, (unsigned)n);"
    },
    {
        "line": 49,
        "fullcodeline": "if(write_or_buffer(req, rbuf, rp - rbuf) < 0) {"
    },
    {
        "line": 58,
        "fullcodeline": "while(d && (nrep < 255)) {"
    },
    {
        "line": 93,
        "fullcodeline": "serv && (nrep < 255);"
    },
    {
        "line": 123,
        "fullcodeline": "req->socket, nrep, (nrep > 1) ? \"s\" : \"\");"
    },
    {
        "line": 124,
        "fullcodeline": "if(write_or_buffer(req, rbuf, rp - rbuf) < 0) {"
    },
    {
        "line": 131,
        "fullcodeline": "if(!newserv) {"
    },
    {
        "line": 136,
        "fullcodeline": "if(containsForbiddenChars(p, l)) {"
    },
    {
        "line": 141,
        "fullcodeline": "if(!newserv->st) {"
    },
    {
        "line": 148,
        "fullcodeline": "if(p >= buf + n) {"
    },
    {
        "line": 153,
        "fullcodeline": "if(p+l > buf+n) {"
    },
    {
        "line": 157,
        "fullcodeline": "if(containsForbiddenChars(p, l)) {"
    },
    {
        "line": 163,
        "fullcodeline": "if(!newserv->usn) {"
    },
    {
        "line": 171,
        "fullcodeline": "if(p+l > buf+n) {"
    },
    {
        "line": 175,
        "fullcodeline": "if(containsForbiddenChars(p, l)) {"
    },
    {
        "line": 181,
        "fullcodeline": "if(!newserv->server) {"
    },
    {
        "line": 189,
        "fullcodeline": "if(p+l > buf+n) {"
    },
    {
        "line": 193,
        "fullcodeline": "if(containsForbiddenChars(p, l)) {"
    },
    {
        "line": 199,
        "fullcodeline": "if(!newserv->location) {"
    },
    {
        "line": 230,
        "fullcodeline": "if(write_or_buffer(req, rbuf, 1) < 0) {"
    },
    {
        "line": 239,
        "fullcodeline": "if(write_or_buffer(req, rbuf, 1) < 0) {"
    },
    {
        "line": 50,
        "fullcodeline": "syslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);"
    },
    {
        "line": 89,
        "fullcodeline": "d = d->next;"
    },
    {
        "line": 125,
        "fullcodeline": "syslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);"
    },
    {
        "line": 132,
        "fullcodeline": "syslog(LOG_ERR, \"cannot allocate memory\");"
    },
    {
        "line": 137,
        "fullcodeline": "syslog(LOG_ERR, \"bad request (st contains forbidden chars)\");"
    },
    {
        "line": 142,
        "fullcodeline": "syslog(LOG_ERR, \"cannot allocate memory\");"
    },
    {
        "line": 149,
        "fullcodeline": "syslog(LOG_WARNING, \"bad request (missing usn)\");"
    },
    {
        "line": 154,
        "fullcodeline": "syslog(LOG_WARNING, \"bad request (length encoding)\");"
    },
    {
        "line": 158,
        "fullcodeline": "syslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");"
    },
    {
        "line": 164,
        "fullcodeline": "syslog(LOG_ERR, \"cannot allocate memory\");"
    },
    {
        "line": 172,
        "fullcodeline": "syslog(LOG_WARNING, \"bad request (length encoding)\");"
    },
    {
        "line": 176,
        "fullcodeline": "syslog(LOG_ERR, \"bad request (server contains forbidden chars)\");"
    },
    {
        "line": 182,
        "fullcodeline": "syslog(LOG_ERR, \"cannot allocate memory\");"
    },
    {
        "line": 190,
        "fullcodeline": "syslog(LOG_WARNING, \"bad request (length encoding)\");"
    },
    {
        "line": 194,
        "fullcodeline": "syslog(LOG_ERR, \"bad request (location contains forbidden chars)\");"
    },
    {
        "line": 200,
        "fullcodeline": "syslog(LOG_ERR, \"cannot allocate memory\");"
    },
    {
        "line": 231,
        "fullcodeline": "syslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);"
    },
    {
        "line": 240,
        "fullcodeline": "syslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);"
    },
    {
        "line": 59,
        "fullcodeline": "if(d->t < t) {"
    },
    {
        "line": 96,
        "fullcodeline": "if(strlen(serv->location) + strlen(serv->st)"
    },
    {
        "line": 99,
        "fullcodeline": "if( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))"
    },
    {
        "line": 209,
        "fullcodeline": "if(0 == strcmp(newserv->usn, serv->usn)"
    },
    {
        "line": 60,
        "fullcodeline": "syslog(LOG_INFO, \"outdated device\");"
    },
    {
        "line": 101,
        "fullcodeline": "||(type==MINISSDPD_SEARCH_ALL) ) {"
    },
    {
        "line": 106,
        "fullcodeline": "m = strlen(serv->location);"
    },
    {
        "line": 107,
        "fullcodeline": "CODELENGTH(m, rp);"
    },
    {
        "line": 108,
        "fullcodeline": "memcpy(rp, serv->location, m);"
    },
    {
        "line": 109,
        "fullcodeline": "rp += m;"
    },
    {
        "line": 110,
        "fullcodeline": "m = strlen(serv->st);"
    },
    {
        "line": 111,
        "fullcodeline": "CODELENGTH(m, rp);"
    },
    {
        "line": 112,
        "fullcodeline": "memcpy(rp, serv->st, m);"
    },
    {
        "line": 113,
        "fullcodeline": "rp += m;"
    },
    {
        "line": 114,
        "fullcodeline": "m = strlen(serv->usn);"
    },
    {
        "line": 115,
        "fullcodeline": "CODELENGTH(m, rp);"
    },
    {
        "line": 116,
        "fullcodeline": "memcpy(rp, serv->usn, m);"
    },
    {
        "line": 117,
        "fullcodeline": "rp += m;"
    },
    {
        "line": 118,
        "fullcodeline": "nrep++;"
    },
    {
        "line": 210,
        "fullcodeline": "&& 0 == strcmp(newserv->st, serv->st)) {"
    },
    {
        "line": 211,
        "fullcodeline": "syslog(LOG_INFO, \"Service already in the list. Updating...\");"
    },
    {
        "line": 212,
        "fullcodeline": "free(newserv->st);"
    },
    {
        "line": 213,
        "fullcodeline": "free(newserv->usn);"
    },
    {
        "line": 214,
        "fullcodeline": "free(serv->server);"
    },
    {
        "line": 215,
        "fullcodeline": "serv->server = newserv->server;"
    },
    {
        "line": 216,
        "fullcodeline": "free(serv->location);"
    },
    {
        "line": 217,
        "fullcodeline": "serv->location = newserv->location;"
    },
    {
        "line": 218,
        "fullcodeline": "free(newserv);"
    },
    {
        "line": 219,
        "fullcodeline": "newserv = NULL;"
    },
    {
        "line": 97,
        "fullcodeline": "+ strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))"
    },
    {
        "line": 100,
        "fullcodeline": "||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))"
    },
    {
        "line": 63,
        "fullcodeline": "if(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l"
    },
    {
        "line": 67,
        "fullcodeline": "if( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, l))"
    },
    {
        "line": 69,
        "fullcodeline": "||(type==MINISSDPD_SEARCH_ALL) ) {"
    },
    {
        "line": 75,
        "fullcodeline": "CODELENGTH(m, rp);"
    },
    {
        "line": 76,
        "fullcodeline": "memcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);"
    },
    {
        "line": 77,
        "fullcodeline": "rp += d->headers[HEADER_LOCATION].l;"
    },
    {
        "line": 79,
        "fullcodeline": "CODELENGTH(m, rp);"
    },
    {
        "line": 80,
        "fullcodeline": "memcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);"
    },
    {
        "line": 81,
        "fullcodeline": "rp += d->headers[HEADER_NT].l;"
    },
    {
        "line": 83,
        "fullcodeline": "CODELENGTH(m, rp);"
    },
    {
        "line": 84,
        "fullcodeline": "memcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);"
    },
    {
        "line": 85,
        "fullcodeline": "rp += d->headers[HEADER_USN].l;"
    },
    {
        "line": 86,
        "fullcodeline": "nrep++;"
    },
    {
        "line": 65,
        "fullcodeline": "+ (rp - rbuf) >= (int)sizeof(rbuf))"
    },
    {
        "line": 68,
        "fullcodeline": "||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))"
    }
]