[
    {
        "line": 5,
        "fullcodeline": "const struct k_clock *kc = timr->kclock;"
    },
    {
        "line": 13,
        "fullcodeline": "timr->it_interval = 0;"
    },
    {
        "line": 21,
        "fullcodeline": "timr->it_active = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "timr->it_requeue_pending = (timr->it_requeue_pending + 2) &"
    },
    {
        "line": 24,
        "fullcodeline": "timr->it_overrun_last = 0;"
    },
    {
        "line": 30,
        "fullcodeline": "timr->it_interval = timespec64_to_ktime(new_setting->it_interval);"
    },
    {
        "line": 31,
        "fullcodeline": "expires = timespec64_to_ktime(new_setting->it_value);"
    },
    {
        "line": 32,
        "fullcodeline": "sigev_none = timr->it_sigev_notify == SIGEV_NONE;"
    },
    {
        "line": 34,
        "fullcodeline": "kc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);"
    },
    {
        "line": 18,
        "fullcodeline": "if (kc->timer_try_to_cancel(timr) < 0)"
    },
    {
        "line": 35,
        "fullcodeline": "timr->it_active = !sigev_none;"
    },
    {
        "line": 10,
        "fullcodeline": "common_timer_get(timr, old_setting);"
    },
    {
        "line": 23,
        "fullcodeline": "~REQUEUE_PENDING;"
    },
    {
        "line": 27,
        "fullcodeline": "if (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)"
    }
]