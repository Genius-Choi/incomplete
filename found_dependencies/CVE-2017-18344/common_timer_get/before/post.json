[
    {
        "line": 3,
        "fullcodeline": "const struct k_clock *kc = timr->kclock;"
    },
    {
        "line": 8,
        "fullcodeline": "sig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;"
    },
    {
        "line": 9,
        "fullcodeline": "iv = timr->it_interval;"
    },
    {
        "line": 27,
        "fullcodeline": "kc->clock_get(timr->it_clock, &ts64);"
    },
    {
        "line": 28,
        "fullcodeline": "now = timespec64_to_ktime(ts64);"
    },
    {
        "line": 37,
        "fullcodeline": "remaining = kc->timer_remaining(timr, now);"
    },
    {
        "line": 34,
        "fullcodeline": "if (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))"
    },
    {
        "line": 39,
        "fullcodeline": "if (remaining <= 0) {"
    },
    {
        "line": 13,
        "fullcodeline": "cur_setting->it_interval = ktime_to_timespec64(iv);"
    },
    {
        "line": 35,
        "fullcodeline": "timr->it_overrun += kc->timer_forward(timr, now);"
    },
    {
        "line": 44,
        "fullcodeline": "if (!sig_none)"
    },
    {
        "line": 47,
        "fullcodeline": "cur_setting->it_value = ktime_to_timespec64(remaining);"
    },
    {
        "line": 14,
        "fullcodeline": "} else if (!timr->it_active) {"
    },
    {
        "line": 45,
        "fullcodeline": "cur_setting->it_value.tv_nsec = 1;"
    },
    {
        "line": 19,
        "fullcodeline": "if (!sig_none)"
    }
]