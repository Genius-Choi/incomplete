[
    {
        "line": 3,
        "fullcodeline": "hive_h *h = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "assert (sizeof (struct ntreg_header) == 0x1000);"
    },
    {
        "line": 8,
        "fullcodeline": "h = calloc (1, sizeof *h);"
    },
    {
        "line": 12,
        "fullcodeline": "h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;"
    },
    {
        "line": 14,
        "fullcodeline": "const char *debug = getenv (\"HIVEX_DEBUG\");"
    },
    {
        "line": 18,
        "fullcodeline": "DEBUG (2, \"created handle %p\", h);"
    },
    {
        "line": 20,
        "fullcodeline": "h->writable = !!(flags & HIVEX_OPEN_WRITE);"
    },
    {
        "line": 21,
        "fullcodeline": "h->filename = strdup (filename);"
    },
    {
        "line": 28,
        "fullcodeline": "h->fd = open (filename, O_RDONLY | O_BINARY);"
    },
    {
        "line": 33,
        "fullcodeline": "fcntl (h->fd, F_SETFD, FD_CLOEXEC);"
    },
    {
        "line": 40,
        "fullcodeline": "h->size = statbuf.st_size;"
    },
    {
        "line": 82,
        "fullcodeline": "uint32_t major_ver = le32toh (h->hdr->major_ver);"
    },
    {
        "line": 90,
        "fullcodeline": "h->bitmap = calloc (1 + h->size / 32, 1);"
    },
    {
        "line": 95,
        "fullcodeline": "uint32_t sum = header_checksum (h);"
    },
    {
        "line": 102,
        "fullcodeline": "h->last_modified = le64toh ((int64_t) h->hdr->last_modified);"
    },
    {
        "line": 129,
        "fullcodeline": "h->rootoffs = le32toh (h->hdr->offset) + 0x1000;"
    },
    {
        "line": 130,
        "fullcodeline": "h->endpages = le32toh (h->hdr->blocks) + 0x1000;"
    },
    {
        "line": 132,
        "fullcodeline": "DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);"
    },
    {
        "line": 137,
        "fullcodeline": "int seen_root_block = 0, bad_root_block = 0;"
    },
    {
        "line": 140,
        "fullcodeline": "size_t pages = 0;           /* Number of hbin pages read. */"
    },
    {
        "line": 141,
        "fullcodeline": "size_t smallest_page = SIZE_MAX, largest_page = 0;"
    },
    {
        "line": 142,
        "fullcodeline": "size_t blocks = 0;          /* Total number of blocks found. */"
    },
    {
        "line": 143,
        "fullcodeline": "size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;"
    },
    {
        "line": 144,
        "fullcodeline": "size_t used_blocks = 0;     /* Total number of used blocks found. */"
    },
    {
        "line": 145,
        "fullcodeline": "size_t used_size = 0;       /* Total size (bytes) of used blocks. */"
    },
    {
        "line": 261,
        "fullcodeline": "DEBUG (1, \"successfully read Windows Registry hive file:\\n\""
    },
    {
        "line": 273,
        "fullcodeline": "int err = errno;"
    },
    {
        "line": 9,
        "fullcodeline": "if (h == NULL)"
    },
    {
        "line": 15,
        "fullcodeline": "if (debug && STREQ (debug, \"1\"))"
    },
    {
        "line": 22,
        "fullcodeline": "if (h->filename == NULL)"
    },
    {
        "line": 30,
        "fullcodeline": "if (h->fd == -1)"
    },
    {
        "line": 37,
        "fullcodeline": "if (fstat (h->fd, &statbuf) == -1)"
    },
    {
        "line": 42,
        "fullcodeline": "if (h->size < 0x2000) {"
    },
    {
        "line": 49,
        "fullcodeline": "if (!h->writable) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (h->hdr->magic[0] != 'r' ||"
    },
    {
        "line": 83,
        "fullcodeline": "if (major_ver != 1) {"
    },
    {
        "line": 91,
        "fullcodeline": "if (h->bitmap == NULL)"
    },
    {
        "line": 96,
        "fullcodeline": "if (sum != le32toh (h->hdr->csum)) {"
    },
    {
        "line": 104,
        "fullcodeline": "if (h->msglvl >= 2) {"
    },
    {
        "line": 155,
        "fullcodeline": "for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {"
    },
    {
        "line": 251,
        "fullcodeline": "if (!seen_root_block) {"
    },
    {
        "line": 267,
        "fullcodeline": "blocks, smallest_block, blocks_bytes / blocks, largest_block,"
    },
    {
        "line": 16,
        "fullcodeline": "h->msglvl = 2;"
    },
    {
        "line": 50,
        "fullcodeline": "h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);"
    },
    {
        "line": 54,
        "fullcodeline": "DEBUG (2, \"mapped file at %p\", h->addr);"
    },
    {
        "line": 75,
        "fullcodeline": "h->hdr->magic[3] != 'f') {"
    },
    {
        "line": 105,
        "fullcodeline": "char *name = _hivex_windows_utf16_to_utf8 (h->hdr->name, 64);"
    },
    {
        "line": 126,
        "fullcodeline": "free (name);"
    },
    {
        "line": 159,
        "fullcodeline": "page = (struct ntreg_hbin_page *) ((char *) h->addr + off);"
    },
    {
        "line": 171,
        "fullcodeline": "size_t page_size = le32toh (page->page_size);"
    },
    {
        "line": 172,
        "fullcodeline": "DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);"
    },
    {
        "line": 173,
        "fullcodeline": "pages++;"
    },
    {
        "line": 275,
        "fullcodeline": "free (h->bitmap);"
    },
    {
        "line": 284,
        "fullcodeline": "free (h->filename);"
    },
    {
        "line": 51,
        "fullcodeline": "if (h->addr == MAP_FAILED)"
    },
    {
        "line": 56,
        "fullcodeline": "h->addr = malloc (h->size);"
    },
    {
        "line": 68,
        "fullcodeline": "h->fd = -1;"
    },
    {
        "line": 74,
        "fullcodeline": "h->hdr->magic[2] != 'g' ||"
    },
    {
        "line": 156,
        "fullcodeline": "if (off >= h->endpages)"
    },
    {
        "line": 160,
        "fullcodeline": "if (page->magic[0] != 'h' ||"
    },
    {
        "line": 174,
        "fullcodeline": "if (page_size < smallest_page) smallest_page = page_size;"
    },
    {
        "line": 175,
        "fullcodeline": "if (page_size > largest_page) largest_page = page_size;"
    },
    {
        "line": 177,
        "fullcodeline": "if (page_size <= sizeof (struct ntreg_hbin_page) ||"
    },
    {
        "line": 185,
        "fullcodeline": "if (off + page_size > h->size) {"
    },
    {
        "line": 197,
        "fullcodeline": "blkoff < off + page_size;"
    },
    {
        "line": 198,
        "fullcodeline": "blkoff += seg_len) {"
    },
    {
        "line": 282,
        "fullcodeline": "if (h->fd >= 0)"
    },
    {
        "line": 57,
        "fullcodeline": "if (h->addr == NULL)"
    },
    {
        "line": 60,
        "fullcodeline": "if (full_read (h->fd, h->addr, h->size) < h->size)"
    },
    {
        "line": 66,
        "fullcodeline": "if (close (h->fd) == -1)"
    },
    {
        "line": 73,
        "fullcodeline": "h->hdr->magic[1] != 'e' ||"
    },
    {
        "line": 163,
        "fullcodeline": "page->magic[3] != 'n') {"
    },
    {
        "line": 178,
        "fullcodeline": "(page_size & 0x0fff) != 0) {"
    },
    {
        "line": 196,
        "fullcodeline": "for (blkoff = off + 0x20;"
    },
    {
        "line": 199,
        "fullcodeline": "blocks++;"
    },
    {
        "line": 201,
        "fullcodeline": "int is_root = blkoff == h->rootoffs;"
    },
    {
        "line": 205,
        "fullcodeline": "block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);"
    },
    {
        "line": 207,
        "fullcodeline": "seg_len = block_len (h, blkoff, &used);"
    },
    {
        "line": 230,
        "fullcodeline": "blocks_bytes += seg_len;"
    },
    {
        "line": 276,
        "fullcodeline": "if (h->addr && h->size && h->addr != MAP_FAILED) {"
    },
    {
        "line": 283,
        "fullcodeline": "close (h->fd);"
    },
    {
        "line": 162,
        "fullcodeline": "page->magic[2] != 'i' ||"
    },
    {
        "line": 208,
        "fullcodeline": "if (seg_len <= 4 || (seg_len & 3) != 0) {"
    },
    {
        "line": 215,
        "fullcodeline": "if (h->msglvl >= 2) {"
    },
    {
        "line": 231,
        "fullcodeline": "if (seg_len < smallest_block) smallest_block = seg_len;"
    },
    {
        "line": 232,
        "fullcodeline": "if (seg_len > largest_block) largest_block = seg_len;"
    },
    {
        "line": 234,
        "fullcodeline": "if (is_root && !used)"
    },
    {
        "line": 277,
        "fullcodeline": "if (!h->writable)"
    },
    {
        "line": 161,
        "fullcodeline": "page->magic[1] != 'b' ||"
    },
    {
        "line": 203,
        "fullcodeline": "seen_root_block = 1;"
    },
    {
        "line": 216,
        "fullcodeline": "unsigned char *id = (unsigned char *) block->id;"
    },
    {
        "line": 217,
        "fullcodeline": "int id0 = id[0], id1 = id[1];"
    },
    {
        "line": 219,
        "fullcodeline": "fprintf (stderr, \"%s: %s: \""
    },
    {
        "line": 235,
        "fullcodeline": "bad_root_block = 1;"
    },
    {
        "line": 238,
        "fullcodeline": "used_blocks++;"
    },
    {
        "line": 239,
        "fullcodeline": "used_size += seg_len;"
    },
    {
        "line": 246,
        "fullcodeline": "BITMAP_SET (h->bitmap, blkoff);"
    },
    {
        "line": 278,
        "fullcodeline": "munmap (h->addr, h->size);"
    },
    {
        "line": 222,
        "fullcodeline": "used ? \"used\" : \"free\","
    },
    {
        "line": 224,
        "fullcodeline": "c_isprint (id0) ? id0 : '.',"
    },
    {
        "line": 225,
        "fullcodeline": "c_isprint (id1) ? id1 : '.',"
    },
    {
        "line": 242,
        "fullcodeline": "if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))"
    },
    {
        "line": 280,
        "fullcodeline": "free (h->addr);"
    },
    {
        "line": 243,
        "fullcodeline": "bad_root_block = 1;"
    }
]