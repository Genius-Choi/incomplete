[
    {
        "line": 11,
        "fullcodeline": "git_index_entry entry = {{0}};"
    },
    {
        "line": 12,
        "fullcodeline": "bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;"
    },
    {
        "line": 13,
        "fullcodeline": "char *tmp_path = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "memcpy(&source, buffer, sizeof(struct entry_short));"
    },
    {
        "line": 21,
        "fullcodeline": "entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);"
    },
    {
        "line": 22,
        "fullcodeline": "entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);"
    },
    {
        "line": 23,
        "fullcodeline": "entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);"
    },
    {
        "line": 24,
        "fullcodeline": "entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);"
    },
    {
        "line": 25,
        "fullcodeline": "entry.dev = ntohl(source.dev);"
    },
    {
        "line": 26,
        "fullcodeline": "entry.ino = ntohl(source.ino);"
    },
    {
        "line": 27,
        "fullcodeline": "entry.mode = ntohl(source.mode);"
    },
    {
        "line": 28,
        "fullcodeline": "entry.uid = ntohl(source.uid);"
    },
    {
        "line": 29,
        "fullcodeline": "entry.gid = ntohl(source.gid);"
    },
    {
        "line": 30,
        "fullcodeline": "entry.file_size = ntohl(source.file_size);"
    },
    {
        "line": 31,
        "fullcodeline": "git_oid_cpy(&entry.id, &source.oid);"
    },
    {
        "line": 32,
        "fullcodeline": "entry.flags = ntohs(source.flags);"
    },
    {
        "line": 96,
        "fullcodeline": "git__free(tmp_path);"
    },
    {
        "line": 15,
        "fullcodeline": "if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)"
    },
    {
        "line": 48,
        "fullcodeline": "if (!compressed) {"
    },
    {
        "line": 88,
        "fullcodeline": "if (INDEX_FOOTER_SIZE + entry_size > buffer_size)"
    },
    {
        "line": 91,
        "fullcodeline": "if (index_entry_dup(out, index, &entry) < 0) {"
    },
    {
        "line": 49,
        "fullcodeline": "path_length = entry.flags & GIT_IDXENTRY_NAMEMASK;"
    },
    {
        "line": 63,
        "fullcodeline": "entry_size = index_entry_size(path_length, 0, entry.flags);"
    },
    {
        "line": 64,
        "fullcodeline": "entry.path = (char *)path_ptr;"
    },
    {
        "line": 92,
        "fullcodeline": "git__free(tmp_path);"
    },
    {
        "line": 53,
        "fullcodeline": "if (path_length == 0xFFF) {"
    },
    {
        "line": 67,
        "fullcodeline": "size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,"
    },
    {
        "line": 69,
        "fullcodeline": "size_t last_len = strlen(last);"
    },
    {
        "line": 70,
        "fullcodeline": "size_t prefix_len = last_len - strip_len;"
    },
    {
        "line": 71,
        "fullcodeline": "size_t suffix_len = strlen(path_ptr + varint_len);"
    },
    {
        "line": 77,
        "fullcodeline": "GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);"
    },
    {
        "line": 78,
        "fullcodeline": "GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);"
    },
    {
        "line": 79,
        "fullcodeline": "tmp_path = git__malloc(path_len);"
    },
    {
        "line": 80,
        "fullcodeline": "GITERR_CHECK_ALLOC(tmp_path);"
    },
    {
        "line": 82,
        "fullcodeline": "memcpy(tmp_path, last, prefix_len);"
    },
    {
        "line": 83,
        "fullcodeline": "memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);"
    },
    {
        "line": 84,
        "fullcodeline": "entry_size = index_entry_size(suffix_len, varint_len, entry.flags);"
    },
    {
        "line": 85,
        "fullcodeline": "entry.path = tmp_path;"
    },
    {
        "line": 56,
        "fullcodeline": "path_end = memchr(path_ptr, '\\0', buffer_size);"
    },
    {
        "line": 60,
        "fullcodeline": "path_length = path_end - path_ptr;"
    },
    {
        "line": 74,
        "fullcodeline": "if (varint_len == 0)"
    },
    {
        "line": 57,
        "fullcodeline": "if (path_end == NULL)"
    },
    {
        "line": 75,
        "fullcodeline": "return index_error_invalid(\"incorrect prefix length\");"
    }
]