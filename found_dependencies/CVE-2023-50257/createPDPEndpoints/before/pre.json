[
    {
        "line": 3,
        "fullcodeline": "EPROSIMA_LOG_INFO(RTPS_PDP, \"Beginning\");"
    },
    {
        "line": 5,
        "fullcodeline": "const RTPSParticipantAttributes& pattr = mp_RTPSParticipant->getRTPSParticipantAttributes();"
    },
    {
        "line": 6,
        "fullcodeline": "const RTPSParticipantAllocationAttributes& allocation = pattr.allocation;"
    },
    {
        "line": 7,
        "fullcodeline": "const BuiltinAttributes& builtin_att = mp_builtin->m_att;"
    },
    {
        "line": 9,
        "fullcodeline": "auto endpoints = new fastdds::rtps::SimplePDPEndpoints();"
    },
    {
        "line": 10,
        "fullcodeline": "builtin_endpoints_.reset(endpoints);"
    },
    {
        "line": 14,
        "fullcodeline": "hatt.payloadMaxSize = builtin_att.readerPayloadSize;"
    },
    {
        "line": 15,
        "fullcodeline": "hatt.memoryPolicy = builtin_att.readerHistoryMemoryPolicy;"
    },
    {
        "line": 16,
        "fullcodeline": "hatt.initialReservedCaches = 25;"
    },
    {
        "line": 26,
        "fullcodeline": "PoolConfig reader_pool_cfg = PoolConfig::from_history_attributes(hatt);"
    },
    {
        "line": 27,
        "fullcodeline": "endpoints->reader.payload_pool_ = TopicPayloadPoolRegistry::get(\"DCPSParticipant\", reader_pool_cfg);"
    },
    {
        "line": 28,
        "fullcodeline": "endpoints->reader.payload_pool_->reserve_history(reader_pool_cfg, true);"
    },
    {
        "line": 30,
        "fullcodeline": "endpoints->reader.history_.reset(new ReaderHistory(hatt));"
    },
    {
        "line": 33,
        "fullcodeline": "ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;"
    },
    {
        "line": 34,
        "fullcodeline": "ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;"
    },
    {
        "line": 35,
        "fullcodeline": "ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;"
    },
    {
        "line": 36,
        "fullcodeline": "ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;"
    },
    {
        "line": 37,
        "fullcodeline": "ratt.endpoint.topicKind = WITH_KEY;"
    },
    {
        "line": 38,
        "fullcodeline": "ratt.endpoint.durabilityKind = TRANSIENT_LOCAL;"
    },
    {
        "line": 39,
        "fullcodeline": "ratt.endpoint.reliabilityKind = BEST_EFFORT;"
    },
    {
        "line": 40,
        "fullcodeline": "ratt.matched_writers_allocation = allocation.participants;"
    },
    {
        "line": 41,
        "fullcodeline": "mp_listener = new PDPListener(this);"
    },
    {
        "line": 42,
        "fullcodeline": "RTPSReader* reader = nullptr;"
    },
    {
        "line": 62,
        "fullcodeline": "hatt.payloadMaxSize = mp_builtin->m_att.writerPayloadSize;"
    },
    {
        "line": 63,
        "fullcodeline": "hatt.initialReservedCaches = 1;"
    },
    {
        "line": 64,
        "fullcodeline": "hatt.maximumReservedCaches = 1;"
    },
    {
        "line": 65,
        "fullcodeline": "hatt.memoryPolicy = mp_builtin->m_att.writerHistoryMemoryPolicy;"
    },
    {
        "line": 67,
        "fullcodeline": "PoolConfig writer_pool_cfg = PoolConfig::from_history_attributes(hatt);"
    },
    {
        "line": 68,
        "fullcodeline": "endpoints->writer.payload_pool_ = TopicPayloadPoolRegistry::get(\"DCPSParticipant\", writer_pool_cfg);"
    },
    {
        "line": 69,
        "fullcodeline": "endpoints->writer.payload_pool_->reserve_history(writer_pool_cfg, false);"
    },
    {
        "line": 71,
        "fullcodeline": "endpoints->writer.history_.reset(new WriterHistory(hatt));"
    },
    {
        "line": 75,
        "fullcodeline": "watt.endpoint.endpointKind = WRITER;"
    },
    {
        "line": 80,
        "fullcodeline": "watt.matched_readers_allocation = allocation.participants;"
    },
    {
        "line": 87,
        "fullcodeline": "RTPSWriter* wout = nullptr;"
    },
    {
        "line": 17,
        "fullcodeline": "if (allocation.participants.initial > 0)"
    },
    {
        "line": 21,
        "fullcodeline": "if (allocation.participants.maximum < std::numeric_limits<size_t>::max())"
    },
    {
        "line": 43,
        "fullcodeline": "if (mp_RTPSParticipant->createReader(&reader, ratt,"
    },
    {
        "line": 88,
        "fullcodeline": "if (mp_RTPSParticipant->createWriter(&wout, watt, endpoints->writer.payload_pool_, endpoints->writer.history_.get(),"
    },
    {
        "line": 19,
        "fullcodeline": "hatt.initialReservedCaches = (int32_t)allocation.participants.initial;"
    },
    {
        "line": 23,
        "fullcodeline": "hatt.maximumReservedCaches = (int32_t)allocation.participants.maximum;"
    },
    {
        "line": 44,
        "fullcodeline": "endpoints->reader.payload_pool_, endpoints->reader.history_.get(),"
    },
    {
        "line": 82,
        "fullcodeline": "if (pattr.throughputController.bytesPerPeriod != UINT32_MAX && pattr.throughputController.periodMillisecs != 0)"
    },
    {
        "line": 84,
        "fullcodeline": "watt.mode = ASYNCHRONOUS_WRITER;"
    },
    {
        "line": 92,
        "fullcodeline": "endpoints->writer.writer_ = dynamic_cast<StatelessWriter*>(wout);"
    },
    {
        "line": 54,
        "fullcodeline": "EPROSIMA_LOG_ERROR(RTPS_PDP, \"SimplePDP Reader creation failed\");"
    },
    {
        "line": 55,
        "fullcodeline": "delete mp_listener;"
    },
    {
        "line": 56,
        "fullcodeline": "mp_listener = nullptr;"
    },
    {
        "line": 57,
        "fullcodeline": "endpoints->reader.release();"
    },
    {
        "line": 96,
        "fullcodeline": "if (endpoints->writer.writer_ != nullptr)"
    },
    {
        "line": 98,
        "fullcodeline": "const NetworkFactory& network = mp_RTPSParticipant->network_factory();"
    },
    {
        "line": 102,
        "fullcodeline": "if (network.is_locator_remote_or_allowed(loc))"
    },
    {
        "line": 106,
        "fullcodeline": "fixed_locators.push_back(loc);"
    },
    {
        "line": 129,
        "fullcodeline": "network.transform_remote_locator(loc, local_locator,"
    },
    {
        "line": 140,
        "fullcodeline": "EPROSIMA_LOG_WARNING(RTPS_PDP, \"Ignoring initial peers locator \" << loc << \" : not allowed.\");"
    },
    {
        "line": 131,
        "fullcodeline": "if (loc != local_locator"
    },
    {
        "line": 133,
        "fullcodeline": "&& network.is_locator_allowed(local_locator))"
    },
    {
        "line": 135,
        "fullcodeline": "fixed_locators.push_back(local_locator);"
    },
    {
        "line": 132,
        "fullcodeline": "&& (loc.kind == LOCATOR_KIND_TCPv4 || loc.kind == LOCATOR_KIND_TCPv6)"
    }
]