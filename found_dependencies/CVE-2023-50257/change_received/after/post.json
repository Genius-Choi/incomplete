[
    {
        "line": 6,
        "fullcodeline": "if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))"
    },
    {
        "line": 8,
        "fullcodeline": "bool update_notified = true;"
    },
    {
        "line": 10,
        "fullcodeline": "decltype(matched_writers_)::iterator writer = matched_writers_.end();"
    },
    {
        "line": 11,
        "fullcodeline": "if ((EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind) ||"
    },
    {
        "line": 24,
        "fullcodeline": "if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)"
    },
    {
        "line": 34,
        "fullcodeline": "if (mp_history->received_change(change, 0))"
    },
    {
        "line": 12,
        "fullcodeline": "(m_trustedWriterEntityId == change->writerGUID.entityId))"
    },
    {
        "line": 14,
        "fullcodeline": "writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),"
    },
    {
        "line": 19,
        "fullcodeline": "bool is_matched = matched_writers_.end() != writer;"
    },
    {
        "line": 20,
        "fullcodeline": "update_notified = is_matched;"
    },
    {
        "line": 26,
        "fullcodeline": "assert(matched_writers_.end() != writer);"
    },
    {
        "line": 27,
        "fullcodeline": "change->reader_info.writer_ownership_strength = writer->ownership_strength;"
    },
    {
        "line": 37,
        "fullcodeline": "auto guid = change->writerGUID;"
    },
    {
        "line": 38,
        "fullcodeline": "auto seq = change->sequenceNumber;"
    },
    {
        "line": 41,
        "fullcodeline": "SequenceNumber_t previous_seq{ 0, 0 };"
    },
    {
        "line": 46,
        "fullcodeline": "++total_unread_;"
    },
    {
        "line": 48,
        "fullcodeline": "on_data_notify(guid, change->sourceTimestamp);"
    },
    {
        "line": 50,
        "fullcodeline": "auto listener = getListener();"
    },
    {
        "line": 74,
        "fullcodeline": "new_notification_cv_.notify_all();"
    },
    {
        "line": 77,
        "fullcodeline": "on_subscribe_throughput(payload_length);"
    },
    {
        "line": 31,
        "fullcodeline": "change->reader_info.writer_ownership_strength = std::numeric_limits<uint32_t>::max();"
    },
    {
        "line": 51,
        "fullcodeline": "if (listener != nullptr)"
    },
    {
        "line": 44,
        "fullcodeline": "previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);"
    },
    {
        "line": 66,
        "fullcodeline": "bool notify_single = false;"
    },
    {
        "line": 67,
        "fullcodeline": "listener->on_data_available(this, guid, seq, seq, notify_single);"
    },
    {
        "line": 53,
        "fullcodeline": "if (SequenceNumber_t{0, 0} != previous_seq)"
    },
    {
        "line": 55,
        "fullcodeline": "assert(previous_seq < seq);"
    },
    {
        "line": 56,
        "fullcodeline": "uint64_t tmp = (seq - previous_seq).to64long() - 1;"
    },
    {
        "line": 57,
        "fullcodeline": "int32_t lost_samples = tmp > static_cast<uint64_t>(std::numeric_limits<int32_t>::max()) ?"
    },
    {
        "line": 70,
        "fullcodeline": "listener->onNewCacheChangeAdded(this, change);"
    },
    {
        "line": 59,
        "fullcodeline": "if (0 < lost_samples) // There are lost samples."
    },
    {
        "line": 58,
        "fullcodeline": "std::numeric_limits<int32_t>::max() : static_cast<int32_t>(tmp);"
    },
    {
        "line": 61,
        "fullcodeline": "listener->on_sample_lost(this, lost_samples);"
    }
]