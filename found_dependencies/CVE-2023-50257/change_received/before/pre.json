[
    {
        "line": 6,
        "fullcodeline": "if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))"
    },
    {
        "line": 9,
        "fullcodeline": "if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)"
    },
    {
        "line": 24,
        "fullcodeline": "if (mp_history->received_change(change, 0))"
    },
    {
        "line": 11,
        "fullcodeline": "auto writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),"
    },
    {
        "line": 16,
        "fullcodeline": "assert(matched_writers_.end() != writer);"
    },
    {
        "line": 17,
        "fullcodeline": "change->reader_info.writer_ownership_strength = writer->ownership_strength;"
    },
    {
        "line": 26,
        "fullcodeline": "auto payload_length = change->serializedPayload.length;"
    },
    {
        "line": 27,
        "fullcodeline": "auto guid = change->writerGUID;"
    },
    {
        "line": 28,
        "fullcodeline": "auto seq = change->sequenceNumber;"
    },
    {
        "line": 30,
        "fullcodeline": "Time_t::now(change->reader_info.receptionTimestamp);"
    },
    {
        "line": 31,
        "fullcodeline": "SequenceNumber_t previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);"
    },
    {
        "line": 32,
        "fullcodeline": "++total_unread_;"
    },
    {
        "line": 34,
        "fullcodeline": "on_data_notify(guid, change->sourceTimestamp);"
    },
    {
        "line": 36,
        "fullcodeline": "auto listener = getListener();"
    },
    {
        "line": 60,
        "fullcodeline": "new_notification_cv_.notify_all();"
    },
    {
        "line": 63,
        "fullcodeline": "on_subscribe_throughput(payload_length);"
    },
    {
        "line": 21,
        "fullcodeline": "change->reader_info.writer_ownership_strength = std::numeric_limits<uint32_t>::max();"
    },
    {
        "line": 37,
        "fullcodeline": "if (listener != nullptr)"
    },
    {
        "line": 52,
        "fullcodeline": "bool notify_single = false;"
    },
    {
        "line": 53,
        "fullcodeline": "listener->on_data_available(this, guid, seq, seq, notify_single);"
    },
    {
        "line": 39,
        "fullcodeline": "if (SequenceNumber_t{0, 0} != previous_seq)"
    },
    {
        "line": 41,
        "fullcodeline": "assert(previous_seq < seq);"
    },
    {
        "line": 42,
        "fullcodeline": "uint64_t tmp = (seq - previous_seq).to64long() - 1;"
    },
    {
        "line": 43,
        "fullcodeline": "int32_t lost_samples = tmp > static_cast<uint64_t>(std::numeric_limits<int32_t>::max()) ?"
    },
    {
        "line": 56,
        "fullcodeline": "listener->onNewCacheChangeAdded(this, change);"
    },
    {
        "line": 45,
        "fullcodeline": "if (0 < lost_samples) // There are lost samples."
    },
    {
        "line": 44,
        "fullcodeline": "std::numeric_limits<int32_t>::max() : static_cast<int32_t>(tmp);"
    },
    {
        "line": 47,
        "fullcodeline": "listener->on_sample_lost(this, lost_samples);"
    }
]