[
    {
        "line": 3,
        "fullcodeline": "AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;"
    },
    {
        "line": 25,
        "fullcodeline": "ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);"
    },
    {
        "line": 13,
        "fullcodeline": "for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (*pix_fmt == AV_PIX_FMT_NONE) {"
    },
    {
        "line": 26,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 36,
        "fullcodeline": "if (ctx->internal->pool_internal && !ctx->pool)"
    },
    {
        "line": 40,
        "fullcodeline": "if (ctx->initial_pool_size > 0) {"
    },
    {
        "line": 18,
        "fullcodeline": "av_log(ctx, AV_LOG_ERROR,"
    },
    {
        "line": 31,
        "fullcodeline": "ret = ctx->internal->hw_type->frames_init(ctx);"
    },
    {
        "line": 37,
        "fullcodeline": "ctx->pool = ctx->internal->pool_internal;"
    },
    {
        "line": 41,
        "fullcodeline": "ret = hwframe_pool_prealloc(ref);"
    },
    {
        "line": 49,
        "fullcodeline": "ctx->internal->hw_type->frames_uninit(ctx);"
    },
    {
        "line": 14,
        "fullcodeline": "if (*pix_fmt == ctx->format)"
    },
    {
        "line": 20,
        "fullcodeline": "av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);"
    },
    {
        "line": 21,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 32,
        "fullcodeline": "if (ret < 0)"
    },
    {
        "line": 42,
        "fullcodeline": "if (ret < 0)"
    }
]