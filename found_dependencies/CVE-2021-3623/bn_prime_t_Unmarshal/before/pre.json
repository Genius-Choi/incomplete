[
    {
        "line": 3,
        "fullcodeline": "TPM_RC rc = TPM_RC_SUCCESS;"
    },
    {
        "line": 5,
        "fullcodeline": "UINT16 numbytes = 0;"
    },
    {
        "line": 15,
        "fullcodeline": "data->allocated = ARRAY_SIZE(data->d);"
    },
    {
        "line": 9,
        "fullcodeline": "if (rc == TPM_RC_SUCCESS) {"
    },
    {
        "line": 17,
        "fullcodeline": "if (rc == TPM_RC_SUCCESS) {"
    },
    {
        "line": 20,
        "fullcodeline": "if (rc == TPM_RC_SUCCESS) {"
    },
    {
        "line": 31,
        "fullcodeline": "if (rc == TPM_RC_SUCCESS) {"
    },
    {
        "line": 54,
        "fullcodeline": "if (rc == TPM_RC_SUCCESS && hdr.version >= 2) {"
    },
    {
        "line": 10,
        "fullcodeline": "rc = NV_HEADER_Unmarshal(&hdr, buffer, size,"
    },
    {
        "line": 18,
        "fullcodeline": "rc = UINT16_Unmarshal(&numbytes, buffer, size);"
    },
    {
        "line": 22,
        "fullcodeline": "data->size = (numbytes + sizeof(crypt_uword_t) - 1) / sizeof(crypt_word_t);"
    },
    {
        "line": 55,
        "fullcodeline": "BLOCK_SKIP_READ(skip_future_versions, FALSE, buffer, size,"
    },
    {
        "line": 23,
        "fullcodeline": "if (data->size > data->allocated) {"
    },
    {
        "line": 33,
        "fullcodeline": "i < numbytes && rc == TPM_RC_SUCCESS;"
    },
    {
        "line": 34,
        "fullcodeline": "i += sizeof(UINT32), idx += 1) {"
    },
    {
        "line": 24,
        "fullcodeline": "TPMLIB_LogTPM2Error(\"bn_prime_t: Require size larger %zu than \""
    },
    {
        "line": 27,
        "fullcodeline": "rc = TPM_RC_SIZE;"
    },
    {
        "line": 32,
        "fullcodeline": "for (i = 0, idx = 0;"
    },
    {
        "line": 35,
        "fullcodeline": "rc = UINT32_Unmarshal(&word, buffer, size);"
    },
    {
        "line": 26,
        "fullcodeline": "(size_t)data->size, (size_t)data->allocated);"
    }
]