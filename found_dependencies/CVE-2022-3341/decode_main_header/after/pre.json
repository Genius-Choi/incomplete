[
    {
        "line": 3,
        "fullcodeline": "AVFormatContext *s = nut->avf;"
    },
    {
        "line": 4,
        "fullcodeline": "AVIOContext *bc    = s->pb;"
    },
    {
        "line": 10,
        "fullcodeline": "length = get_packetheader(nut, bc, 1, MAIN_STARTCODE);"
    },
    {
        "line": 11,
        "fullcodeline": "end = length + avio_tell(bc);"
    },
    {
        "line": 13,
        "fullcodeline": "nut->version = ffio_read_varlen(bc);"
    },
    {
        "line": 23,
        "fullcodeline": "GET_V(stream_count, tmp > 0 && tmp <= NUT_MAX_STREAMS);"
    },
    {
        "line": 25,
        "fullcodeline": "nut->max_distance = ffio_read_varlen(bc);"
    },
    {
        "line": 31,
        "fullcodeline": "GET_V(nut->time_base_count, tmp > 0 && tmp < INT_MAX / sizeof(AVRational) && tmp < length/2);"
    },
    {
        "line": 32,
        "fullcodeline": "nut->time_base = av_malloc_array(nut->time_base_count, sizeof(AVRational));"
    },
    {
        "line": 47,
        "fullcodeline": "tmp_pts      = 0;"
    },
    {
        "line": 48,
        "fullcodeline": "tmp_mul      = 1;"
    },
    {
        "line": 49,
        "fullcodeline": "tmp_stream   = 0;"
    },
    {
        "line": 50,
        "fullcodeline": "tmp_head_idx = 0;"
    },
    {
        "line": 158,
        "fullcodeline": "nut->stream = av_calloc(stream_count, sizeof(StreamContext));"
    },
    {
        "line": 14,
        "fullcodeline": "if (nut->version < NUT_MIN_VERSION ||"
    },
    {
        "line": 20,
        "fullcodeline": "if (nut->version > 3)"
    },
    {
        "line": 26,
        "fullcodeline": "if (nut->max_distance > 65536) {"
    },
    {
        "line": 33,
        "fullcodeline": "if (!nut->time_base)"
    },
    {
        "line": 36,
        "fullcodeline": "for (i = 0; i < nut->time_base_count; i++) {"
    },
    {
        "line": 51,
        "fullcodeline": "for (i = 0; i < 256;) {"
    },
    {
        "line": 119,
        "fullcodeline": "av_assert0(nut->frame_code['N'].flags == FLAG_INVALID);"
    },
    {
        "line": 121,
        "fullcodeline": "if (end > avio_tell(bc) + 4) {"
    },
    {
        "line": 163,
        "fullcodeline": "for (i = 0; i < stream_count; i++) {"
    },
    {
        "line": 173,
        "fullcodeline": "for (i = 1; i < nut->header_count; i++) {"
    },
    {
        "line": 15,
        "fullcodeline": "nut->version > NUT_MAX_VERSION) {"
    },
    {
        "line": 16,
        "fullcodeline": "av_log(s, AV_LOG_ERROR, \"Version %d not supported.\\n\","
    },
    {
        "line": 27,
        "fullcodeline": "av_log(s, AV_LOG_DEBUG, \"max_distance %d\\n\", nut->max_distance);"
    },
    {
        "line": 37,
        "fullcodeline": "GET_V(nut->time_base[i].num, tmp > 0 && tmp < (1ULL << 31));"
    },
    {
        "line": 38,
        "fullcodeline": "GET_V(nut->time_base[i].den, tmp > 0 && tmp < (1ULL << 31));"
    },
    {
        "line": 52,
        "fullcodeline": "int tmp_flags  = ffio_read_varlen(bc);"
    },
    {
        "line": 53,
        "fullcodeline": "int tmp_fields = ffio_read_varlen(bc);"
    },
    {
        "line": 122,
        "fullcodeline": "int rem = 1024;"
    },
    {
        "line": 123,
        "fullcodeline": "GET_V(nut->header_count, tmp < 128U);"
    },
    {
        "line": 124,
        "fullcodeline": "nut->header_count++;"
    },
    {
        "line": 148,
        "fullcodeline": "if (nut->version > 3 && end > avio_tell(bc) + 4) {"
    },
    {
        "line": 152,
        "fullcodeline": "if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {"
    },
    {
        "line": 154,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 160,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    },
    {
        "line": 18,
        "fullcodeline": "return AVERROR(ENOSYS);"
    },
    {
        "line": 21,
        "fullcodeline": "nut->minor_version = ffio_read_varlen(bc);"
    },
    {
        "line": 34,
        "fullcodeline": "return AVERROR(ENOMEM);"
    },
    {
        "line": 55,
        "fullcodeline": "if (tmp_fields > 0)"
    },
    {
        "line": 57,
        "fullcodeline": "if (tmp_fields > 1)"
    },
    {
        "line": 59,
        "fullcodeline": "if (tmp_fields > 2)"
    },
    {
        "line": 61,
        "fullcodeline": "if (tmp_fields > 3)"
    },
    {
        "line": 65,
        "fullcodeline": "if (tmp_fields > 4)"
    },
    {
        "line": 69,
        "fullcodeline": "if (tmp_fields > 5)"
    },
    {
        "line": 73,
        "fullcodeline": "if (tmp_fields > 6)"
    },
    {
        "line": 75,
        "fullcodeline": "if (tmp_fields > 7)"
    },
    {
        "line": 92,
        "fullcodeline": "if (tmp_stream >= stream_count) {"
    },
    {
        "line": 104,
        "fullcodeline": "for (j = 0; j < count; j++, i++) {"
    },
    {
        "line": 125,
        "fullcodeline": "for (i = 1; i < nut->header_count; i++) {"
    },
    {
        "line": 144,
        "fullcodeline": "av_assert0(nut->header_len[0] == 0);"
    },
    {
        "line": 149,
        "fullcodeline": "nut->flags = ffio_read_varlen(bc);"
    },
    {
        "line": 39,
        "fullcodeline": "if (av_gcd(nut->time_base[i].num, nut->time_base[i].den) != 1) {"
    },
    {
        "line": 43,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 56,
        "fullcodeline": "tmp_pts = get_s(bc);"
    },
    {
        "line": 58,
        "fullcodeline": "tmp_mul = ffio_read_varlen(bc);"
    },
    {
        "line": 60,
        "fullcodeline": "tmp_stream = ffio_read_varlen(bc);"
    },
    {
        "line": 62,
        "fullcodeline": "tmp_size = ffio_read_varlen(bc);"
    },
    {
        "line": 66,
        "fullcodeline": "tmp_res = ffio_read_varlen(bc);"
    },
    {
        "line": 70,
        "fullcodeline": "count = ffio_read_varlen(bc);"
    },
    {
        "line": 74,
        "fullcodeline": "get_s(bc);"
    },
    {
        "line": 76,
        "fullcodeline": "tmp_head_idx = ffio_read_varlen(bc);"
    },
    {
        "line": 78,
        "fullcodeline": "while (tmp_fields-- > 8) {"
    },
    {
        "line": 84,
        "fullcodeline": "ffio_read_varlen(bc);"
    },
    {
        "line": 87,
        "fullcodeline": "if (count <= 0 || count > 256 - (i <= 'N') - i) {"
    },
    {
        "line": 89,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 95,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 98,
        "fullcodeline": "if (tmp_size < 0 || tmp_size > INT_MAX - count) {"
    },
    {
        "line": 100,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 127,
        "fullcodeline": "GET_V(nut->header_len[i], tmp > 0 && tmp < 256);"
    },
    {
        "line": 135,
        "fullcodeline": "rem -= nut->header_len[i];"
    },
    {
        "line": 136,
        "fullcodeline": "hdr = av_malloc(nut->header_len[i]);"
    },
    {
        "line": 141,
        "fullcodeline": "avio_read(bc, hdr, nut->header_len[i]);"
    },
    {
        "line": 142,
        "fullcodeline": "nut->header[i] = hdr;"
    },
    {
        "line": 164,
        "fullcodeline": "if (!avformat_new_stream(s, NULL)) {"
    },
    {
        "line": 165,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    },
    {
        "line": 64,
        "fullcodeline": "tmp_size = 0;"
    },
    {
        "line": 68,
        "fullcodeline": "tmp_res = 0;"
    },
    {
        "line": 72,
        "fullcodeline": "count = tmp_mul - (unsigned)tmp_size;"
    },
    {
        "line": 105,
        "fullcodeline": "if (i == 'N') {"
    },
    {
        "line": 128,
        "fullcodeline": "if (rem < nut->header_len[i]) {"
    },
    {
        "line": 137,
        "fullcodeline": "if (!hdr) {"
    },
    {
        "line": 81,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 107,
        "fullcodeline": "j--;"
    },
    {
        "line": 132,
        "fullcodeline": "ret = AVERROR_INVALIDDATA;"
    },
    {
        "line": 138,
        "fullcodeline": "ret = AVERROR(ENOMEM);"
    }
]