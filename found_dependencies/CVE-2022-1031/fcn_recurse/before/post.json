[
    {
        "line": 2,
        "fullcodeline": "char *bp_reg = NULL;"
    },
    {
        "line": 3,
        "fullcodeline": "char *sp_reg = NULL;"
    },
    {
        "line": 4,
        "fullcodeline": "char *op_dst = NULL;"
    },
    {
        "line": 5,
        "fullcodeline": "char *op_src = NULL;"
    },
    {
        "line": 13,
        "fullcodeline": "RAnalOp *op = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "char *movbasereg = NULL;"
    },
    {
        "line": 15,
        "fullcodeline": "const int addrbytes = anal->iob.io ? anal->iob.io->addrbytes : 1;"
    },
    {
        "line": 16,
        "fullcodeline": "char *last_reg_mov_lea_name = NULL;"
    },
    {
        "line": 17,
        "fullcodeline": "RAnalBlock *bb = NULL;"
    },
    {
        "line": 18,
        "fullcodeline": "RAnalBlock *bbg = NULL;"
    },
    {
        "line": 19,
        "fullcodeline": "int ret = R_ANAL_RET_END, skip_ret = 0;"
    },
    {
        "line": 20,
        "fullcodeline": "bool overlapped = false;"
    },
    {
        "line": 21,
        "fullcodeline": "int oplen, idx = 0;"
    },
    {
        "line": 22,
        "fullcodeline": "size_t lea_cnt = 0;"
    },
    {
        "line": 23,
        "fullcodeline": "size_t nop_prefix_cnt = 0;"
    },
    {
        "line": 24,
        "fullcodeline": "static ut64 cmpval = UT64_MAX; // inherited across functions, otherwise it breaks :?"
    },
    {
        "line": 32,
        "fullcodeline": "} delay = {"
    },
    {
        "line": 35,
        "fullcodeline": "bool arch_destroys_dst = does_arch_destroys_dst (anal->cur->arch);"
    },
    {
        "line": 36,
        "fullcodeline": "const bool is_arm = anal->cur->arch && !strncmp (anal->cur->arch, \"arm\", 3);"
    },
    {
        "line": 37,
        "fullcodeline": "const bool is_v850 = is_arm ? false: (anal->cur->arch && (!strncmp (anal->cur->arch, \"v850\", 4) || !strncmp (anal->coreb.cfgGet (anal->coreb.core, \"asm.cpu\"), \"v850\", 4)));"
    },
    {
        "line": 38,
        "fullcodeline": "const bool is_x86 = is_arm ? false: anal->cur->arch && !strncmp (anal->cur->arch, \"x86\", 3);"
    },
    {
        "line": 39,
        "fullcodeline": "const bool is_amd64 = is_x86 ? fcn->cc && !strcmp (fcn->cc, \"amd64\") : false;"
    },
    {
        "line": 40,
        "fullcodeline": "const bool is_dalvik = is_x86 ? false : anal->cur->arch && !strncmp (anal->cur->arch, \"dalvik\", 6);"
    },
    {
        "line": 41,
        "fullcodeline": "RRegItem *variadic_reg = NULL;"
    },
    {
        "line": 45,
        "fullcodeline": "bool has_variadic_reg = !!variadic_reg;"
    },
    {
        "line": 64,
        "fullcodeline": "RAnalFunction *fcn_at_addr = r_anal_get_function_at (anal, addr);"
    },
    {
        "line": 69,
        "fullcodeline": "RAnalBlock *existing_bb = bbget (anal, addr, anal->opt.jmpmid && is_x86);"
    },
    {
        "line": 91,
        "fullcodeline": "bb = fcn_append_basic_block (anal, fcn, addr);"
    },
    {
        "line": 93,
        "fullcodeline": "r_return_val_if_fail (bb, R_ANAL_RET_ERROR);"
    },
    {
        "line": 102,
        "fullcodeline": "static ut64 lea_jmptbl_ip = UT64_MAX;"
    },
    {
        "line": 103,
        "fullcodeline": "ut64 last_reg_mov_lea_val = UT64_MAX;"
    },
    {
        "line": 104,
        "fullcodeline": "bool last_is_reg_mov_lea = false;"
    },
    {
        "line": 105,
        "fullcodeline": "bool last_is_push = false;"
    },
    {
        "line": 106,
        "fullcodeline": "bool last_is_mov_lr_pc = false;"
    },
    {
        "line": 107,
        "fullcodeline": "ut64 last_push_addr = UT64_MAX;"
    },
    {
        "line": 112,
        "fullcodeline": "bool varset = has_vars (anal, addr); // Checks if var is already analyzed at given addr"
    },
    {
        "line": 114,
        "fullcodeline": "ut64 movdisp = UT64_MAX; // used by jmptbl when coded as \"mov Reg,[Reg*Scale+Disp]\""
    },
    {
        "line": 115,
        "fullcodeline": "ut64 movscale = 0;"
    },
    {
        "line": 116,
        "fullcodeline": "int maxlen = len * addrbytes;"
    },
    {
        "line": 138,
        "fullcodeline": "const bool has_stack_regs = _bp_reg && _sp_reg;"
    },
    {
        "line": 144,
        "fullcodeline": "op = r_anal_op_new ();"
    },
    {
        "line": 894,
        "fullcodeline": "free (op_src);"
    },
    {
        "line": 895,
        "fullcodeline": "free (op_dst);"
    },
    {
        "line": 896,
        "fullcodeline": "free (bp_reg);"
    },
    {
        "line": 897,
        "fullcodeline": "free (sp_reg);"
    },
    {
        "line": 902,
        "fullcodeline": "r_anal_op_free (op);"
    },
    {
        "line": 903,
        "fullcodeline": "R_FREE (last_reg_mov_lea_name);"
    },
    {
        "line": 907,
        "fullcodeline": "r_anal_block_update_hash (bb);"
    },
    {
        "line": 908,
        "fullcodeline": "r_anal_block_unref (bb);"
    },
    {
        "line": 909,
        "fullcodeline": "free (movbasereg);"
    },
    {
        "line": 6,
        "fullcodeline": "if (depth < 1) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (r_cons_is_breaked ()) {"
    },
    {
        "line": 55,
        "fullcodeline": "if (!anal->iob.is_valid_offset (anal->iob.io, addr, 0)) {"
    },
    {
        "line": 65,
        "fullcodeline": "if (fcn_at_addr && fcn_at_addr != fcn) {"
    },
    {
        "line": 95,
        "fullcodeline": "if (!anal->leaddrs) {"
    },
    {
        "line": 108,
        "fullcodeline": "if (anal->limit && addr + idx < anal->limit->from) {"
    },
    {
        "line": 130,
        "fullcodeline": "if ((maxlen - (addrbytes * idx)) > MAX_SCAN_SIZE) {"
    },
    {
        "line": 145,
        "fullcodeline": "while (addrbytes * idx < maxlen) {"
    },
    {
        "line": 898,
        "fullcodeline": "while (lea_cnt > 0) {"
    },
    {
        "line": 904,
        "fullcodeline": "if (bb && bb->size == 0) {"
    },
    {
        "line": 43,
        "fullcodeline": "variadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);"
    },
    {
        "line": 51,
        "fullcodeline": "r_sys_usleep (anal->sleep);"
    },
    {
        "line": 71,
        "fullcodeline": "bool existing_in_fcn = r_list_contains (existing_bb->fcns, fcn);"
    },
    {
        "line": 72,
        "fullcodeline": "existing_bb = r_anal_block_split (existing_bb, addr);"
    },
    {
        "line": 96,
        "fullcodeline": "anal->leaddrs = r_list_newf (free_leaddr_pair);"
    },
    {
        "line": 109,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 118,
        "fullcodeline": "bool skipAnalysis = false;"
    },
    {
        "line": 134,
        "fullcodeline": "maxlen = 0;"
    },
    {
        "line": 140,
        "fullcodeline": "bp_reg = strdup (_bp_reg);"
    },
    {
        "line": 141,
        "fullcodeline": "sp_reg = strdup (_sp_reg);"
    },
    {
        "line": 157,
        "fullcodeline": "ut8 buf[32]; // 32 bytes is enough to hold any instruction."
    },
    {
        "line": 158,
        "fullcodeline": "ut32 at_delta = addrbytes * idx;"
    },
    {
        "line": 159,
        "fullcodeline": "ut64 at = addr + at_delta;"
    },
    {
        "line": 160,
        "fullcodeline": "ut64 bytes_read = R_MIN (len - at_delta, sizeof (buf));"
    },
    {
        "line": 161,
        "fullcodeline": "ret = read_ahead (anal, at, buf, bytes_read);"
    },
    {
        "line": 173,
        "fullcodeline": "r_anal_op_fini (op);"
    },
    {
        "line": 182,
        "fullcodeline": "free (op_dst);"
    },
    {
        "line": 183,
        "fullcodeline": "op_dst = (op->dst && op->dst->reg && op->dst->reg->name)? strdup (op->dst->reg->name): NULL;"
    },
    {
        "line": 184,
        "fullcodeline": "free (op_src);"
    },
    {
        "line": 185,
        "fullcodeline": "op_src = (op->src[0] && op->src[0]->reg && op->src[0]->reg->name) ? strdup (op->src[0]->reg->name): NULL;"
    },
    {
        "line": 268,
        "fullcodeline": "idx += oplen;"
    },
    {
        "line": 269,
        "fullcodeline": "delay.un_idx = idx;"
    },
    {
        "line": 344,
        "fullcodeline": "analyze_retpoline (anal, op);"
    },
    {
        "line": 899,
        "fullcodeline": "r_list_delete (anal->leaddrs, r_list_tail (anal->leaddrs));"
    },
    {
        "line": 900,
        "fullcodeline": "lea_cnt--;"
    },
    {
        "line": 905,
        "fullcodeline": "r_anal_function_remove_block (fcn, bb);"
    },
    {
        "line": 56,
        "fullcodeline": "if (addr != UT64_MAX && !anal->iob.io->va) {"
    },
    {
        "line": 73,
        "fullcodeline": "if (!existing_in_fcn && existing_bb) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (!anal->leaddrs) {"
    },
    {
        "line": 119,
        "fullcodeline": "if (!strncmp (fcn->name, \"sym.\", 4)) {"
    },
    {
        "line": 146,
        "fullcodeline": "if (!last_is_reg_mov_lea) {"
    },
    {
        "line": 150,
        "fullcodeline": "if (anal->limit && anal->limit->to <= addr + idx) {"
    },
    {
        "line": 154,
        "fullcodeline": "if (r_cons_is_breaked ()) {"
    },
    {
        "line": 163,
        "fullcodeline": "if (ret < 0) {"
    },
    {
        "line": 167,
        "fullcodeline": "if (is_invalid_memory (anal, buf, bytes_read)) {"
    },
    {
        "line": 174,
        "fullcodeline": "if ((oplen = r_anal_op (anal, op, at, buf, bytes_read, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) < 1) {"
    },
    {
        "line": 187,
        "fullcodeline": "if (anal->opt.nopskip && fcn->addr == at) {"
    },
    {
        "line": 216,
        "fullcodeline": "if (idx > 0 && !overlapped) {"
    },
    {
        "line": 233,
        "fullcodeline": "if (!overlapped) {"
    },
    {
        "line": 270,
        "fullcodeline": "if (anal->opt.delay && op->delay > 0 && !delay.pending) {"
    },
    {
        "line": 286,
        "fullcodeline": "if (delay.cnt > 0) {"
    },
    {
        "line": 340,
        "fullcodeline": "if (op->ptr && op->ptr != UT64_MAX && op->ptr != UT32_MAX) {"
    },
    {
        "line": 345,
        "fullcodeline": "switch (op->type & R_ANAL_OP_TYPE_MASK) {"
    },
    {
        "line": 853,
        "fullcodeline": "if (has_stack_regs && arch_destroys_dst) {"
    },
    {
        "line": 866,
        "fullcodeline": "if (anal->opt.vars && !varset) {"
    },
    {
        "line": 870,
        "fullcodeline": "if (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {"
    },
    {
        "line": 873,
        "fullcodeline": "if (op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_RPUSH) {"
    },
    {
        "line": 876,
        "fullcodeline": "if (is_arm && op->type != R_ANAL_OP_TYPE_MOV) {"
    },
    {
        "line": 879,
        "fullcodeline": "if (has_variadic_reg && !fcn->is_variadic) {"
    },
    {
        "line": 80,
        "fullcodeline": "r_anal_block_unref (existing_bb);"
    },
    {
        "line": 98,
        "fullcodeline": "eprintf (\"Cannot create leaddr list\\n\");"
    },
    {
        "line": 99,
        "fullcodeline": "gotoBeach (R_ANAL_RET_ERROR);"
    },
    {
        "line": 127,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 132,
        "fullcodeline": "eprintf (\"Warning: Skipping large memory region.\\n\");"
    },
    {
        "line": 147,
        "fullcodeline": "free (last_reg_mov_lea_name);"
    },
    {
        "line": 148,
        "fullcodeline": "last_reg_mov_lea_name = NULL;"
    },
    {
        "line": 164,
        "fullcodeline": "eprintf (\"Failed to read\\n\");"
    },
    {
        "line": 180,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 188,
        "fullcodeline": "RFlagItem *fi = anal->flb.get_at (anal->flb.f, addr, false);"
    },
    {
        "line": 214,
        "fullcodeline": "r_anal_hint_set_bits (anal, op->jump, op->hint.new_bits);"
    },
    {
        "line": 217,
        "fullcodeline": "bbg = bbget (anal, at, anal->opt.jmpmid && is_x86);"
    },
    {
        "line": 234,
        "fullcodeline": "const ut64 newbbsize = bb->size + oplen;"
    },
    {
        "line": 238,
        "fullcodeline": "r_anal_bb_set_offset (bb, bb->ninstr++, at - bb->addr);"
    },
    {
        "line": 239,
        "fullcodeline": "r_anal_block_set_size (bb, newbbsize);"
    },
    {
        "line": 240,
        "fullcodeline": "fcn->ninstr++;"
    },
    {
        "line": 243,
        "fullcodeline": "const char *name = anal->coreb.getName (anal->coreb.core, at);"
    },
    {
        "line": 279,
        "fullcodeline": "delay.idx = idx - oplen;"
    },
    {
        "line": 280,
        "fullcodeline": "delay.cnt = op->delay;"
    },
    {
        "line": 281,
        "fullcodeline": "delay.pending = 1; // we need this in case the actual idx is zero..."
    },
    {
        "line": 282,
        "fullcodeline": "delay.adjust = !overlapped; // adjustment is required later to avoid double count"
    },
    {
        "line": 289,
        "fullcodeline": "delay.cnt--;"
    },
    {
        "line": 332,
        "fullcodeline": "bb->stackptr += op->stackptr;"
    },
    {
        "line": 335,
        "fullcodeline": "bb->stackptr = 0;"
    },
    {
        "line": 342,
        "fullcodeline": "r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);"
    },
    {
        "line": 348,
        "fullcodeline": "last_is_reg_mov_lea = false;"
    },
    {
        "line": 388,
        "fullcodeline": "last_is_reg_mov_lea = false;"
    },
    {
        "line": 504,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 506,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 554,
        "fullcodeline": "ret = r_anal_function_bb (anal, fcn, op->jump, depth);"
    },
    {
        "line": 628,
        "fullcodeline": "int saved_stack = fcn->stack;"
    },
    {
        "line": 630,
        "fullcodeline": "r_anal_function_bb (anal, fcn, op->jump, depth);"
    },
    {
        "line": 631,
        "fullcodeline": "fcn->stack = saved_stack;"
    },
    {
        "line": 632,
        "fullcodeline": "ret = r_anal_function_bb (anal, fcn, op->fail, depth);"
    },
    {
        "line": 633,
        "fullcodeline": "fcn->stack = saved_stack;"
    },
    {
        "line": 649,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_CALL);"
    },
    {
        "line": 662,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);"
    },
    {
        "line": 816,
        "fullcodeline": "last_is_push = true;"
    },
    {
        "line": 817,
        "fullcodeline": "last_push_addr = op->val;"
    },
    {
        "line": 868,
        "fullcodeline": "r_anal_extract_vars (anal, fcn, op);"
    },
    {
        "line": 871,
        "fullcodeline": "last_is_reg_mov_lea = false;"
    },
    {
        "line": 874,
        "fullcodeline": "last_is_push = false;"
    },
    {
        "line": 877,
        "fullcodeline": "last_is_mov_lr_pc = false;"
    },
    {
        "line": 880,
        "fullcodeline": "variadic_reg = r_reg_get (anal->reg, \"rax\", R_REG_TYPE_GPR);"
    },
    {
        "line": 881,
        "fullcodeline": "bool dst_is_variadic = op->dst && op->dst->reg"
    },
    {
        "line": 883,
        "fullcodeline": "bool op_is_cmp = (op->type == R_ANAL_OP_TYPE_CMP) || op->type == R_ANAL_OP_TYPE_ACMP;"
    },
    {
        "line": 74,
        "fullcodeline": "if (existing_bb->addr == fcn->addr) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (!strncmp (fcn->name + 4, \"imp.\", 4)) {"
    },
    {
        "line": 189,
        "fullcodeline": "if (!fi || strncmp (fi->name, \"sym.\", 4)) {"
    },
    {
        "line": 198,
        "fullcodeline": "switch (op->type & R_ANAL_OP_TYPE_MASK) {"
    },
    {
        "line": 218,
        "fullcodeline": "if (bbg && bbg != bb) {"
    },
    {
        "line": 235,
        "fullcodeline": "if (newbbsize > MAX_FCN_SIZE) {"
    },
    {
        "line": 290,
        "fullcodeline": "if (!delay.cnt) {"
    },
    {
        "line": 326,
        "fullcodeline": "if (R_ABS (op->stackptr) < R_ANAL_MAX_INCSTACK) {"
    },
    {
        "line": 355,
        "fullcodeline": "if (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)) {"
    },
    {
        "line": 359,
        "fullcodeline": "if (op->dst && op->dst->reg && op->dst->reg->name && op->val > 0 && op->val != UT64_MAX) {"
    },
    {
        "line": 367,
        "fullcodeline": "if (anal->opt.jmptbl && op->scale && op->ireg) {"
    },
    {
        "line": 377,
        "fullcodeline": "if (anal->opt.hpskip && regs_exist (op->src[0], op->dst) && !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {"
    },
    {
        "line": 415,
        "fullcodeline": "if (op->ptr != UT64_MAX) {"
    },
    {
        "line": 431,
        "fullcodeline": "if (has_stack_regs && op_is_set_bp (op_dst, op_src, bp_reg, sp_reg)     ) {"
    },
    {
        "line": 434,
        "fullcodeline": "if (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {"
    },
    {
        "line": 443,
        "fullcodeline": "if (anal->opt.hpskip && regs_exist (op->src[0], op->dst)"
    },
    {
        "line": 511,
        "fullcodeline": "if (op->jump == UT64_MAX) {"
    },
    {
        "line": 515,
        "fullcodeline": "RFlagItem *fi = anal->flb.get_at (anal->flb.f, op->jump, false);"
    },
    {
        "line": 520,
        "fullcodeline": "if (r_cons_is_breaked ()) {"
    },
    {
        "line": 526,
        "fullcodeline": "if (!anal->opt.jmpabove && (op->jump < fcn->addr)) {"
    },
    {
        "line": 529,
        "fullcodeline": "if (r_anal_noreturn_at (anal, op->jump)) {"
    },
    {
        "line": 533,
        "fullcodeline": "bool must_eob = true;"
    },
    {
        "line": 534,
        "fullcodeline": "RIOMap *map = anal->iob.map_get_at (anal->iob.io, addr);"
    },
    {
        "line": 549,
        "fullcodeline": "if (!overlapped) {"
    },
    {
        "line": 575,
        "fullcodeline": "if (op->val != UT64_MAX && op->val > 0) {"
    },
    {
        "line": 581,
        "fullcodeline": "ut64 val = (is_x86 || is_v850)? op->val : op->ptr;"
    },
    {
        "line": 598,
        "fullcodeline": "if (!overlapped) {"
    },
    {
        "line": 651,
        "fullcodeline": "if (r_anal_noreturn_at (anal, op->ptr)) {"
    },
    {
        "line": 664,
        "fullcodeline": "if (r_anal_noreturn_at (anal, op->jump)) {"
    },
    {
        "line": 674,
        "fullcodeline": "if (is_arm && last_is_mov_lr_pc) {"
    },
    {
        "line": 690,
        "fullcodeline": "if (anal->opt.ijmp && next_instruction_is_symbol (anal, op)) {"
    },
    {
        "line": 694,
        "fullcodeline": "if (anal->opt.jmptbl && lea_jmptbl_ip != op->addr) {"
    },
    {
        "line": 793,
        "fullcodeline": "if (lea_jmptbl_ip == op->addr) {"
    },
    {
        "line": 818,
        "fullcodeline": "if (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {"
    },
    {
        "line": 823,
        "fullcodeline": "if ((op->type & R_ANAL_OP_TYPE_REG) && last_is_reg_mov_lea && op->src[0] && op->src[0]->reg"
    },
    {
        "line": 833,
        "fullcodeline": "if (op->family == R_ANAL_OP_FAMILY_PRIV) {"
    },
    {
        "line": 836,
        "fullcodeline": "if (last_is_push && anal->opt.pushret) {"
    },
    {
        "line": 843,
        "fullcodeline": "if (!op->cond) {"
    },
    {
        "line": 855,
        "fullcodeline": "if (op_is_set_bp (op_dst, op_src, bp_reg, sp_reg) && op->src[1]) {"
    },
    {
        "line": 884,
        "fullcodeline": "if (dst_is_variadic && !op_is_cmp) {"
    },
    {
        "line": 76,
        "fullcodeline": "fcn_takeover_block_recursive (fcn, existing_bb);"
    },
    {
        "line": 121,
        "fullcodeline": "skipAnalysis = true;"
    },
    {
        "line": 202,
        "fullcodeline": "nop_prefix_cnt++;"
    },
    {
        "line": 219,
        "fullcodeline": "bb->jump = at;"
    },
    {
        "line": 227,
        "fullcodeline": "overlapped = true;"
    },
    {
        "line": 236,
        "fullcodeline": "gotoBeach (R_ANAL_RET_ERROR);"
    },
    {
        "line": 294,
        "fullcodeline": "delay.after = idx;"
    },
    {
        "line": 295,
        "fullcodeline": "idx = delay.idx;"
    },
    {
        "line": 302,
        "fullcodeline": "} else if (op->delay > 0 && delay.pending) {"
    },
    {
        "line": 327,
        "fullcodeline": "fcn->stack += op->stackptr;"
    },
    {
        "line": 350,
        "fullcodeline": "const char *esil = r_strbuf_get (&op->esil);"
    },
    {
        "line": 356,
        "fullcodeline": "fcn->bp_off = fcn->stack;"
    },
    {
        "line": 360,
        "fullcodeline": "free (last_reg_mov_lea_name);"
    },
    {
        "line": 368,
        "fullcodeline": "movdisp = op->disp;"
    },
    {
        "line": 369,
        "fullcodeline": "movscale = op->scale;"
    },
    {
        "line": 378,
        "fullcodeline": "skip_ret = skip_hp (anal, fcn, op, bb, addr, oplen, delay.un_idx, &idx);"
    },
    {
        "line": 416,
        "fullcodeline": "leaddr_pair *pair = R_NEW (leaddr_pair);"
    },
    {
        "line": 421,
        "fullcodeline": "pair->op_addr = op->addr;"
    },
    {
        "line": 422,
        "fullcodeline": "pair->leaddr = op->ptr; // XXX movdisp is dupped but seems to be trashed sometimes(?), better track leaddr separately"
    },
    {
        "line": 423,
        "fullcodeline": "pair->reg = op->reg"
    },
    {
        "line": 428,
        "fullcodeline": "lea_cnt++;"
    },
    {
        "line": 429,
        "fullcodeline": "r_list_append (anal->leaddrs, pair);"
    },
    {
        "line": 432,
        "fullcodeline": "fcn->bp_off = fcn->stack - op->src[0]->delta;"
    },
    {
        "line": 435,
        "fullcodeline": "free(last_reg_mov_lea_name);"
    },
    {
        "line": 444,
        "fullcodeline": "&& !strcmp (op->src[0]->reg->name, op->dst->reg->name)) {"
    },
    {
        "line": 445,
        "fullcodeline": "skip_ret = skip_hp (anal, fcn, op, bb, at, oplen, delay.un_idx, &idx);"
    },
    {
        "line": 454,
        "fullcodeline": "RAnalOp *jmp_aop = r_anal_op_new ();"
    },
    {
        "line": 455,
        "fullcodeline": "ut64 jmptbl_addr = op->ptr;"
    },
    {
        "line": 456,
        "fullcodeline": "ut64 casetbl_addr = op->ptr;"
    },
    {
        "line": 483,
        "fullcodeline": "r_anal_op_free (jmp_aop);"
    },
    {
        "line": 512,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 516,
        "fullcodeline": "if (fi && strstr (fi->name, \"imp.\")) {"
    },
    {
        "line": 521,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 524,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);"
    },
    {
        "line": 527,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 530,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 550,
        "fullcodeline": "bb->jump = op->jump;"
    },
    {
        "line": 551,
        "fullcodeline": "bb->fail = UT64_MAX;"
    },
    {
        "line": 558,
        "fullcodeline": "int diff = op->jump - op->addr;"
    },
    {
        "line": 577,
        "fullcodeline": "cmpval = op->val;"
    },
    {
        "line": 596,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CODE);"
    },
    {
        "line": 599,
        "fullcodeline": "bb->jump = op->jump;"
    },
    {
        "line": 600,
        "fullcodeline": "bb->fail = op->fail;"
    },
    {
        "line": 603,
        "fullcodeline": "bb->cond->type = op->cond;"
    },
    {
        "line": 652,
        "fullcodeline": "RAnalFunction *f = r_anal_get_function_at (anal, op->ptr);"
    },
    {
        "line": 656,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 665,
        "fullcodeline": "RAnalFunction *f = r_anal_get_function_at (anal, op->jump);"
    },
    {
        "line": 669,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 691,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 695,
        "fullcodeline": "ut8 buf[32]; // 32 bytes is enough to hold any instruction."
    },
    {
        "line": 794,
        "fullcodeline": "lea_jmptbl_ip = UT64_MAX;"
    },
    {
        "line": 797,
        "fullcodeline": "r_anal_function_bb (anal, fcn, op->jump, depth - 1);"
    },
    {
        "line": 798,
        "fullcodeline": "ret = r_anal_function_bb (anal, fcn, op->fail, depth - 1);"
    },
    {
        "line": 819,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);"
    },
    {
        "line": 824,
        "fullcodeline": "&& op->src[0]->reg->name && !strcmp (op->src[0]->reg->name, last_reg_mov_lea_name)) {"
    },
    {
        "line": 825,
        "fullcodeline": "last_is_push = true;"
    },
    {
        "line": 826,
        "fullcodeline": "last_push_addr = last_reg_mov_lea_val;"
    },
    {
        "line": 834,
        "fullcodeline": "fcn->type = R_ANAL_FCN_TYPE_INT;"
    },
    {
        "line": 837,
        "fullcodeline": "op->type = R_ANAL_OP_TYPE_JMP;"
    },
    {
        "line": 838,
        "fullcodeline": "op->jump = last_push_addr;"
    },
    {
        "line": 839,
        "fullcodeline": "bb->jump = op->jump;"
    },
    {
        "line": 840,
        "fullcodeline": "ret = r_anal_function_bb (anal, fcn, op->jump, depth - 1);"
    },
    {
        "line": 849,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 882,
        "fullcodeline": "&& variadic_reg && op->dst->reg->offset == variadic_reg->offset;"
    },
    {
        "line": 885,
        "fullcodeline": "has_variadic_reg = false;"
    },
    {
        "line": 190,
        "fullcodeline": "if ((addr + delay.un_idx - oplen) == fcn->addr) {"
    },
    {
        "line": 203,
        "fullcodeline": "if (nop_prefix_cnt > MAX_NOP_PREFIX_CNT) {"
    },
    {
        "line": 206,
        "fullcodeline": "if (r_anal_block_relocate (bb, at + op->size, bb->size)) {"
    },
    {
        "line": 220,
        "fullcodeline": "if (anal->opt.jmpmid && is_x86) {"
    },
    {
        "line": 245,
        "fullcodeline": "if (r_str_startswith (name, \"try.\") && r_str_endswith (name, \".from\")) {"
    },
    {
        "line": 319,
        "fullcodeline": "idx = delay.after;"
    },
    {
        "line": 320,
        "fullcodeline": "delay.pending = delay.after = delay.idx = delay.adjust = 0;"
    },
    {
        "line": 328,
        "fullcodeline": "if (fcn->stack > fcn->maxstack) {"
    },
    {
        "line": 351,
        "fullcodeline": "if (!r_str_cmp (esil, \"pc,lr,=\", -1)) {"
    },
    {
        "line": 361,
        "fullcodeline": "if ((last_reg_mov_lea_name = strdup (op->dst->reg->name))) {"
    },
    {
        "line": 370,
        "fullcodeline": "if (op->src[0] && op->src[0]->reg) {"
    },
    {
        "line": 379,
        "fullcodeline": "if (skip_ret == 1) {"
    },
    {
        "line": 382,
        "fullcodeline": "if (skip_ret == 2) {"
    },
    {
        "line": 417,
        "fullcodeline": "if (!pair) {"
    },
    {
        "line": 436,
        "fullcodeline": "if ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {"
    },
    {
        "line": 446,
        "fullcodeline": "if (skip_ret == 1) {"
    },
    {
        "line": 449,
        "fullcodeline": "if (skip_ret == 2) {"
    },
    {
        "line": 457,
        "fullcodeline": "if (is_delta_pointer_table (anal, fcn, op->addr, op->ptr, &jmptbl_addr, &casetbl_addr, jmp_aop)) {"
    },
    {
        "line": 488,
        "fullcodeline": "if (anal->iob.is_valid_offset (anal->iob.io, op->ptr, 0)) {"
    },
    {
        "line": 496,
        "fullcodeline": "if ((op->size + 4 <= bytes_read) && !memcmp (buf + op->size, \"\\x00\\x00\\x00\\x00\", 4)) {"
    },
    {
        "line": 517,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 536,
        "fullcodeline": "must_eob = ( ! r_io_map_contain (map, op->jump) );"
    },
    {
        "line": 539,
        "fullcodeline": "op->jump = UT64_MAX;"
    },
    {
        "line": 540,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 559,
        "fullcodeline": "if (tc < 0) {"
    },
    {
        "line": 583,
        "fullcodeline": "cmpval = val;"
    },
    {
        "line": 584,
        "fullcodeline": "bb->cmpval = cmpval;"
    },
    {
        "line": 585,
        "fullcodeline": "bb->cmpreg = op->reg;"
    },
    {
        "line": 586,
        "fullcodeline": "r_anal_cond_free (bb->cond);"
    },
    {
        "line": 587,
        "fullcodeline": "bb->cond = r_anal_cond_new_from_op (op);"
    },
    {
        "line": 606,
        "fullcodeline": "if (op->ptr != UT64_MAX) {"
    },
    {
        "line": 698,
        "fullcodeline": "if (op->ptr != UT64_MAX && op->ireg) { // direct jump"
    },
    {
        "line": 802,
        "fullcodeline": "if (r_anal_noreturn_at (anal, op->jump) || op->eob) {"
    },
    {
        "line": 827,
        "fullcodeline": "if (anal->iob.is_valid_offset (anal->iob.io, last_push_addr, 1)) {"
    },
    {
        "line": 856,
        "fullcodeline": "switch (op->type & R_ANAL_OP_TYPE_MASK) {"
    },
    {
        "line": 122,
        "fullcodeline": "} else if (strstr (fcn->name, \"field\")) {"
    },
    {
        "line": 204,
        "fullcodeline": "gotoBeach (R_ANAL_RET_ERROR);"
    },
    {
        "line": 207,
        "fullcodeline": "addr = at + op->size;"
    },
    {
        "line": 208,
        "fullcodeline": "fcn->addr = addr;"
    },
    {
        "line": 224,
        "fullcodeline": "RAnalBlock *split = r_anal_block_split (bbg, at);"
    },
    {
        "line": 225,
        "fullcodeline": "r_anal_block_unref (split);"
    },
    {
        "line": 246,
        "fullcodeline": "char *handle = strdup (name);"
    },
    {
        "line": 248,
        "fullcodeline": "ut64 from_addr = anal->coreb.numGet (anal->coreb.core, handle);"
    },
    {
        "line": 249,
        "fullcodeline": "handle = r_str_replace (handle, \".from\", \".catch\", 0);"
    },
    {
        "line": 250,
        "fullcodeline": "ut64 handle_addr = anal->coreb.numGet (anal->coreb.core, handle);"
    },
    {
        "line": 251,
        "fullcodeline": "bb->jump = at + oplen;"
    },
    {
        "line": 329,
        "fullcodeline": "fcn->maxstack = fcn->stack;"
    },
    {
        "line": 352,
        "fullcodeline": "last_is_mov_lr_pc = true;"
    },
    {
        "line": 362,
        "fullcodeline": "last_reg_mov_lea_val = op->val;"
    },
    {
        "line": 363,
        "fullcodeline": "last_is_reg_mov_lea = true;"
    },
    {
        "line": 371,
        "fullcodeline": "free (movbasereg);"
    },
    {
        "line": 372,
        "fullcodeline": "movbasereg = strdup (op->src[0]->reg->name);"
    },
    {
        "line": 383,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 418,
        "fullcodeline": "eprintf (\"Cannot create leaddr_pair\\n\");"
    },
    {
        "line": 419,
        "fullcodeline": "gotoBeach (R_ANAL_RET_ERROR);"
    },
    {
        "line": 424,
        "fullcodeline": "? strdup (op->reg)"
    },
    {
        "line": 425,
        "fullcodeline": ": op->dst && op->dst->reg"
    },
    {
        "line": 437,
        "fullcodeline": "last_reg_mov_lea_val = op->ptr;"
    },
    {
        "line": 438,
        "fullcodeline": "last_is_reg_mov_lea = true;"
    },
    {
        "line": 450,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 458,
        "fullcodeline": "ut64 table_size, default_case = 0;"
    },
    {
        "line": 459,
        "fullcodeline": "st64 case_shift = 0;"
    },
    {
        "line": 466,
        "fullcodeline": "ut64 addr = jmp_aop->addr;"
    },
    {
        "line": 467,
        "fullcodeline": "bool ready = false;"
    },
    {
        "line": 489,
        "fullcodeline": "r_meta_set (anal, R_META_TYPE_DATA, op->ptr, 4, \"\");"
    },
    {
        "line": 497,
        "fullcodeline": "r_anal_block_set_size (bb, bb->size - oplen);"
    },
    {
        "line": 498,
        "fullcodeline": "op->type = R_ANAL_OP_TYPE_RET;"
    },
    {
        "line": 499,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 560,
        "fullcodeline": "ut8 buf[32];"
    },
    {
        "line": 561,
        "fullcodeline": "(void)anal->iob.read_at (anal->iob.io, op->jump, (ut8 *) buf, sizeof (buf));"
    },
    {
        "line": 608,
        "fullcodeline": "table_size = cmpval + 1;"
    },
    {
        "line": 609,
        "fullcodeline": "default_case = op->fail; // is this really default case?"
    },
    {
        "line": 654,
        "fullcodeline": "f->is_noreturn = true;"
    },
    {
        "line": 667,
        "fullcodeline": "f->is_noreturn = true;"
    },
    {
        "line": 676,
        "fullcodeline": "} else if (is_v850 && anal->opt.jmptbl) {"
    },
    {
        "line": 700,
        "fullcodeline": "st64 case_shift = 0;"
    },
    {
        "line": 807,
        "fullcodeline": "if (op->type == R_ANAL_OP_TYPE_RJMP) {"
    },
    {
        "line": 828,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, last_push_addr, R_ANAL_REF_TYPE_DATA);"
    },
    {
        "line": 858,
        "fullcodeline": "fcn->bp_off = fcn->stack - op->src[1]->imm;"
    },
    {
        "line": 861,
        "fullcodeline": "fcn->bp_off = fcn->stack + op->src[1]->imm;"
    },
    {
        "line": 123,
        "fullcodeline": "skipAnalysis = true;"
    },
    {
        "line": 191,
        "fullcodeline": "if (r_anal_block_relocate (bb, bb->addr + oplen, bb->size - oplen)) {"
    },
    {
        "line": 252,
        "fullcodeline": "if (from_addr != bb->addr) {"
    },
    {
        "line": 310,
        "fullcodeline": "r_anal_block_set_size (bb, (ut64)addrbytes * (ut64)delay.after);"
    },
    {
        "line": 311,
        "fullcodeline": "fcn->ninstr--;"
    },
    {
        "line": 374,
        "fullcodeline": "R_FREE (movbasereg);"
    },
    {
        "line": 426,
        "fullcodeline": "? strdup (op->dst->reg->name)"
    },
    {
        "line": 468,
        "fullcodeline": "if (try_get_jmptbl_info (anal, fcn, addr, bb, &table_size, &default_case, &case_shift)) {"
    },
    {
        "line": 562,
        "fullcodeline": "if (r_anal_is_prelude (anal, buf, sizeof (buf))) {"
    },
    {
        "line": 610,
        "fullcodeline": "if (cmpval != UT64_MAX && default_case != UT64_MAX && (op->reg || op->ireg)) {"
    },
    {
        "line": 677,
        "fullcodeline": "int ptsz = cmpval? cmpval + 1: 4;"
    },
    {
        "line": 682,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 701,
        "fullcodeline": "if (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {"
    },
    {
        "line": 808,
        "fullcodeline": "gotoBeach (R_ANAL_RET_NOP);"
    },
    {
        "line": 192,
        "fullcodeline": "fcn->addr += oplen;"
    },
    {
        "line": 193,
        "fullcodeline": "idx = delay.un_idx;"
    },
    {
        "line": 253,
        "fullcodeline": "bb->fail = handle_addr;"
    },
    {
        "line": 254,
        "fullcodeline": "ret = r_anal_function_bb (anal, fcn, handle_addr, depth - 1);"
    },
    {
        "line": 259,
        "fullcodeline": "r_anal_block_unref (bb);"
    },
    {
        "line": 260,
        "fullcodeline": "bb = fcn_append_basic_block (anal, fcn, addr);"
    },
    {
        "line": 469,
        "fullcodeline": "ready = true;"
    },
    {
        "line": 475,
        "fullcodeline": "ret = casetbl_addr == op->ptr"
    },
    {
        "line": 563,
        "fullcodeline": "fcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);"
    },
    {
        "line": 565,
        "fullcodeline": "} else if (R_ABS (diff) > tc) {"
    },
    {
        "line": 624,
        "fullcodeline": "cmpval = UT64_MAX;"
    },
    {
        "line": 678,
        "fullcodeline": "if ((int)cmpval > 0) {"
    },
    {
        "line": 702,
        "fullcodeline": "bool case_table = false;"
    },
    {
        "line": 703,
        "fullcodeline": "RAnalOp *prev_op = r_anal_op_new ();"
    },
    {
        "line": 704,
        "fullcodeline": "anal->iob.read_at (anal->iob.io, op->addr - op->size, buf, sizeof (buf));"
    },
    {
        "line": 718,
        "fullcodeline": "r_anal_op_free (prev_op);"
    },
    {
        "line": 723,
        "fullcodeline": "} else if (op->ptr != UT64_MAX && op->reg) { // direct jump"
    },
    {
        "line": 810,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 887,
        "fullcodeline": "if (op->src[0] && op->src[0]->reg && (op->dst->reg == op->src[0]->reg) && dst_is_variadic) {"
    },
    {
        "line": 256,
        "fullcodeline": "if (bb->size == 0) {"
    },
    {
        "line": 261,
        "fullcodeline": "if (!bb) {"
    },
    {
        "line": 566,
        "fullcodeline": "(void) r_anal_xrefs_set (anal, op->addr, op->jump, R_ANAL_REF_TYPE_CALL);"
    },
    {
        "line": 567,
        "fullcodeline": "fcn_recurse (anal, fcn, op->jump, anal->opt.bb_max_size, depth - 1);"
    },
    {
        "line": 568,
        "fullcodeline": "gotoBeach (R_ANAL_RET_END);"
    },
    {
        "line": 619,
        "fullcodeline": "if (op->jump == op->ptr) {"
    },
    {
        "line": 679,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr,"
    },
    {
        "line": 705,
        "fullcodeline": "if (r_anal_op (anal, prev_op, op->addr - op->size, buf, sizeof (buf), R_ANAL_OP_MASK_VAL) > 0) {"
    },
    {
        "line": 719,
        "fullcodeline": "if (!case_table) {"
    },
    {
        "line": 725,
        "fullcodeline": "st64 case_shift = 0;"
    },
    {
        "line": 888,
        "fullcodeline": "fcn->is_variadic = true;"
    },
    {
        "line": 257,
        "fullcodeline": "r_anal_function_remove_block (fcn, bb);"
    },
    {
        "line": 262,
        "fullcodeline": "gotoBeach (R_ANAL_RET_ERROR);"
    },
    {
        "line": 470,
        "fullcodeline": "} else if (try_get_delta_jmptbl_info (anal, fcn, addr, op->addr, &table_size, &default_case, &case_shift)) {"
    },
    {
        "line": 476,
        "fullcodeline": "? try_walkthrough_jmptbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, op->ptr, 4, table_size, default_case, 4)"
    },
    {
        "line": 477,
        "fullcodeline": ": try_walkthrough_casetbl (anal, fcn, bb, depth, addr, case_shift, jmptbl_addr, casetbl_addr, op->ptr, 4, table_size, default_case, 4);"
    },
    {
        "line": 479,
        "fullcodeline": "lea_jmptbl_ip = addr;"
    },
    {
        "line": 613,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, 0, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);"
    },
    {
        "line": 620,
        "fullcodeline": "op->jump = UT64_MAX;"
    },
    {
        "line": 706,
        "fullcodeline": "bool prev_op_has_dst_name = prev_op->dst && prev_op->dst->reg && prev_op->dst->reg->name;"
    },
    {
        "line": 707,
        "fullcodeline": "bool op_has_src_name = op->src[0] && op->src[0]->reg && op->src[0]->reg->name;"
    },
    {
        "line": 708,
        "fullcodeline": "bool same_reg = (op->ireg && prev_op_has_dst_name && !strcmp (op->ireg, prev_op->dst->reg->name))"
    },
    {
        "line": 720,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);"
    },
    {
        "line": 726,
        "fullcodeline": "if (try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {"
    },
    {
        "line": 471,
        "fullcodeline": "ready = true;"
    },
    {
        "line": 615,
        "fullcodeline": "ret = walkthrough_arm_jmptbl_style (anal, fcn, bb, depth, op->addr, op->ptr, anal->bits >> 3, table_size, default_case, ret);"
    },
    {
        "line": 680,
        "fullcodeline": "0, op->addr + 2, op->addr + 2, 2, ptsz, 0, ret);"
    },
    {
        "line": 710,
        "fullcodeline": "if (prev_op->type == R_ANAL_OP_TYPE_MOV && prev_op->disp && prev_op->disp != UT64_MAX && same_reg) {"
    },
    {
        "line": 727,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, op->ptr, anal->bits >> 3, table_size, default_case, ret);"
    },
    {
        "line": 729,
        "fullcodeline": "} else if (movdisp != UT64_MAX) {"
    },
    {
        "line": 621,
        "fullcodeline": "} else if (op->fail == op->ptr) {"
    },
    {
        "line": 709,
        "fullcodeline": "|| (op_has_src_name && prev_op_has_dst_name && !strcmp (op->src[0]->reg->name, prev_op->dst->reg->name));"
    },
    {
        "line": 730,
        "fullcodeline": "st64 case_shift = 0;"
    },
    {
        "line": 732,
        "fullcodeline": "ut64 jmptbl_base = 0; //UT64_MAX;"
    },
    {
        "line": 733,
        "fullcodeline": "ut64 lea_op_off = UT64_MAX;"
    },
    {
        "line": 752,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, case_shift, jmptbl_base + movdisp, jmptbl_base, movscale, table_size, default_case, ret);"
    },
    {
        "line": 753,
        "fullcodeline": "cmpval = UT64_MAX;"
    },
    {
        "line": 622,
        "fullcodeline": "op->fail = UT64_MAX;"
    },
    {
        "line": 713,
        "fullcodeline": "if (try_walkthrough_casetbl (anal, fcn, bb, depth - 1, op->addr, case_shift, op->ptr, prev_op->disp, op->ptr, anal->bits >> 3, table_size, default_case, ret)) {"
    },
    {
        "line": 748,
        "fullcodeline": "if (!try_get_jmptbl_info (anal, fcn, op->addr, bb, &table_size, &default_case, &case_shift)) {"
    },
    {
        "line": 714,
        "fullcodeline": "ret = case_table = true;"
    },
    {
        "line": 738,
        "fullcodeline": "r_list_foreach_prev (anal->leaddrs, iter, pair) {"
    },
    {
        "line": 749,
        "fullcodeline": "table_size = cmpval + 1;"
    },
    {
        "line": 750,
        "fullcodeline": "default_case = -1;"
    },
    {
        "line": 739,
        "fullcodeline": "if (pair->op_addr >= op->addr) {"
    },
    {
        "line": 742,
        "fullcodeline": "if ((lea_op_off == UT64_MAX || lea_op_off > op->addr - pair->op_addr) && pair->reg && !strcmp (movbasereg, pair->reg)) {"
    },
    {
        "line": 765,
        "fullcodeline": "if (op->ptrsize == 1) { // TBB"
    },
    {
        "line": 778,
        "fullcodeline": "if (op->ptrsize == 2) { // LDRH on thumb/arm"
    },
    {
        "line": 743,
        "fullcodeline": "lea_op_off = op->addr - pair->op_addr;"
    },
    {
        "line": 744,
        "fullcodeline": "jmptbl_base = pair->leaddr;"
    },
    {
        "line": 766,
        "fullcodeline": "ut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);"
    },
    {
        "line": 767,
        "fullcodeline": "ut64 table_size = 0;"
    },
    {
        "line": 773,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,"
    },
    {
        "line": 776,
        "fullcodeline": "idx += table_size;"
    },
    {
        "line": 779,
        "fullcodeline": "ut64 pred_cmpval = try_get_cmpval_from_parents(anal, fcn, bb, op->ireg);"
    },
    {
        "line": 780,
        "fullcodeline": "int tablesize = 1;"
    },
    {
        "line": 786,
        "fullcodeline": "ret = try_walkthrough_jmptbl (anal, fcn, bb, depth - 1, op->addr, 0, op->addr + op->size,"
    },
    {
        "line": 789,
        "fullcodeline": "idx += (tablesize * 2);"
    },
    {
        "line": 768,
        "fullcodeline": "if (pred_cmpval != UT64_MAX) {"
    },
    {
        "line": 781,
        "fullcodeline": "if (pred_cmpval != UT64_MAX) {"
    },
    {
        "line": 769,
        "fullcodeline": "table_size += pred_cmpval;"
    },
    {
        "line": 774,
        "fullcodeline": "op->addr + 4, 1, table_size, UT64_MAX, ret);"
    },
    {
        "line": 782,
        "fullcodeline": "tablesize += pred_cmpval;"
    },
    {
        "line": 787,
        "fullcodeline": "op->addr + 4, 2, tablesize, UT64_MAX, ret);"
    },
    {
        "line": 771,
        "fullcodeline": "table_size += cmpval;"
    },
    {
        "line": 784,
        "fullcodeline": "tablesize += cmpval;"
    }
]