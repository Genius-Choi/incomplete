[
    {
        "line": 4,
        "fullcodeline": "VP8LBitReader* const br = &dec->br_;"
    },
    {
        "line": 5,
        "fullcodeline": "VP8LMetadata* const hdr = &dec->hdr_;"
    },
    {
        "line": 6,
        "fullcodeline": "uint32_t* huffman_image = NULL;"
    },
    {
        "line": 7,
        "fullcodeline": "HTreeGroup* htree_groups = NULL;"
    },
    {
        "line": 8,
        "fullcodeline": "HuffmanTables* huffman_tables = &hdr->huffman_tables_;"
    },
    {
        "line": 9,
        "fullcodeline": "int num_htree_groups = 1;"
    },
    {
        "line": 10,
        "fullcodeline": "int num_htree_groups_max = 1;"
    },
    {
        "line": 11,
        "fullcodeline": "const int max_alphabet_size ="
    },
    {
        "line": 13,
        "fullcodeline": "int* code_lengths = NULL;"
    },
    {
        "line": 14,
        "fullcodeline": "const int table_size = kTableSize[color_cache_bits];"
    },
    {
        "line": 15,
        "fullcodeline": "int* mapping = NULL;"
    },
    {
        "line": 16,
        "fullcodeline": "int ok = 0;"
    },
    {
        "line": 19,
        "fullcodeline": "assert(huffman_tables->root.start == NULL);"
    },
    {
        "line": 20,
        "fullcodeline": "assert(huffman_tables->curr_segment == NULL);"
    },
    {
        "line": 71,
        "fullcodeline": "code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,"
    },
    {
        "line": 73,
        "fullcodeline": "htree_groups = VP8LHtreeGroupsNew(num_htree_groups);"
    },
    {
        "line": 148,
        "fullcodeline": "ok = 1;"
    },
    {
        "line": 151,
        "fullcodeline": "hdr->huffman_image_ = huffman_image;"
    },
    {
        "line": 152,
        "fullcodeline": "hdr->num_htree_groups_ = num_htree_groups;"
    },
    {
        "line": 153,
        "fullcodeline": "hdr->htree_groups_ = htree_groups;"
    },
    {
        "line": 156,
        "fullcodeline": "WebPSafeFree(code_lengths);"
    },
    {
        "line": 157,
        "fullcodeline": "WebPSafeFree(mapping);"
    },
    {
        "line": 12,
        "fullcodeline": "kAlphabetSize[0] + ((color_cache_bits > 0) ? 1 << color_cache_bits : 0);"
    },
    {
        "line": 22,
        "fullcodeline": "if (allow_recursion && VP8LReadBits(br, 1)) {"
    },
    {
        "line": 75,
        "fullcodeline": "if (htree_groups == NULL || code_lengths == NULL ||"
    },
    {
        "line": 82,
        "fullcodeline": "for (i = 0; i < num_htree_groups_max; ++i) {"
    },
    {
        "line": 158,
        "fullcodeline": "if (!ok) {"
    },
    {
        "line": 24,
        "fullcodeline": "const int huffman_precision = VP8LReadBits(br, 3) + 2;"
    },
    {
        "line": 25,
        "fullcodeline": "const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);"
    },
    {
        "line": 26,
        "fullcodeline": "const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);"
    },
    {
        "line": 27,
        "fullcodeline": "const int huffman_pixs = huffman_xsize * huffman_ysize;"
    },
    {
        "line": 32,
        "fullcodeline": "hdr->huffman_subsample_bits_ = huffman_precision;"
    },
    {
        "line": 76,
        "fullcodeline": "!VP8LHuffmanTablesAllocate(num_htree_groups * table_size,"
    },
    {
        "line": 78,
        "fullcodeline": "VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);"
    },
    {
        "line": 159,
        "fullcodeline": "WebPSafeFree(huffman_image);"
    },
    {
        "line": 160,
        "fullcodeline": "VP8LHuffmanTablesDeallocate(huffman_tables);"
    },
    {
        "line": 161,
        "fullcodeline": "VP8LHtreeGroupsFree(htree_groups);"
    },
    {
        "line": 28,
        "fullcodeline": "if (!DecodeImageStream(huffman_xsize, huffman_ysize, /*is_level0=*/0, dec,"
    },
    {
        "line": 33,
        "fullcodeline": "for (i = 0; i < huffman_pixs; ++i) {"
    },
    {
        "line": 47,
        "fullcodeline": "if (num_htree_groups_max > 1000 || num_htree_groups_max > xsize * ysize) {"
    },
    {
        "line": 72,
        "fullcodeline": "sizeof(*code_lengths));"
    },
    {
        "line": 85,
        "fullcodeline": "if (mapping != NULL && mapping[i] == -1) {"
    },
    {
        "line": 35,
        "fullcodeline": "const int group = (huffman_image[i] >> 8) & 0xffff;"
    },
    {
        "line": 36,
        "fullcodeline": "huffman_image[i] = group;"
    },
    {
        "line": 50,
        "fullcodeline": "mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));"
    },
    {
        "line": 57,
        "fullcodeline": "memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));"
    },
    {
        "line": 37,
        "fullcodeline": "if (group >= num_htree_groups_max) {"
    },
    {
        "line": 51,
        "fullcodeline": "if (mapping == NULL) {"
    },
    {
        "line": 58,
        "fullcodeline": "for (num_htree_groups = 0, i = 0; i < huffman_pixs; ++i) {"
    },
    {
        "line": 65,
        "fullcodeline": "num_htree_groups = num_htree_groups_max;"
    },
    {
        "line": 86,
        "fullcodeline": "for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {"
    },
    {
        "line": 97,
        "fullcodeline": "HTreeGroup* const htree_group ="
    },
    {
        "line": 99,
        "fullcodeline": "HuffmanCode** const htrees = htree_group->htrees;"
    },
    {
        "line": 101,
        "fullcodeline": "int total_size = 0;"
    },
    {
        "line": 102,
        "fullcodeline": "int is_trivial_literal = 1;"
    },
    {
        "line": 103,
        "fullcodeline": "int max_bits = 0;"
    },
    {
        "line": 131,
        "fullcodeline": "htree_group->is_trivial_literal = is_trivial_literal;"
    },
    {
        "line": 132,
        "fullcodeline": "htree_group->is_trivial_code = 0;"
    },
    {
        "line": 143,
        "fullcodeline": "htree_group->use_packed_table ="
    },
    {
        "line": 38,
        "fullcodeline": "num_htree_groups_max = group + 1;"
    },
    {
        "line": 52,
        "fullcodeline": "VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);"
    },
    {
        "line": 60,
        "fullcodeline": "int* const mapped_group = &mapping[huffman_image[i]];"
    },
    {
        "line": 62,
        "fullcodeline": "huffman_image[i] = *mapped_group;"
    },
    {
        "line": 87,
        "fullcodeline": "int alphabet_size = kAlphabetSize[j];"
    },
    {
        "line": 104,
        "fullcodeline": "for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {"
    },
    {
        "line": 144,
        "fullcodeline": "!htree_group->is_trivial_code && (max_bits < HUFFMAN_PACKED_BITS);"
    },
    {
        "line": 61,
        "fullcodeline": "if (*mapped_group == -1) *mapped_group = num_htree_groups++;"
    },
    {
        "line": 88,
        "fullcodeline": "if (j == 0 && color_cache_bits > 0) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {"
    },
    {
        "line": 105,
        "fullcodeline": "int alphabet_size = kAlphabetSize[j];"
    },
    {
        "line": 109,
        "fullcodeline": "size ="
    },
    {
        "line": 111,
        "fullcodeline": "htrees[j] = huffman_tables->curr_segment->curr_table;"
    },
    {
        "line": 118,
        "fullcodeline": "total_size += htrees[j]->bits;"
    },
    {
        "line": 119,
        "fullcodeline": "huffman_tables->curr_segment->curr_table += size;"
    },
    {
        "line": 134,
        "fullcodeline": "const int red = htrees[RED][0].value;"
    },
    {
        "line": 135,
        "fullcodeline": "const int blue = htrees[BLUE][0].value;"
    },
    {
        "line": 136,
        "fullcodeline": "const int alpha = htrees[ALPHA][0].value;"
    },
    {
        "line": 137,
        "fullcodeline": "htree_group->literal_arb = ((uint32_t)alpha << 24) | (red << 16) | blue;"
    },
    {
        "line": 145,
        "fullcodeline": "if (htree_group->use_packed_table) BuildPackedTable(htree_group);"
    },
    {
        "line": 89,
        "fullcodeline": "alphabet_size += (1 << color_cache_bits);"
    },
    {
        "line": 98,
        "fullcodeline": "&htree_groups[(mapping == NULL) ? i : mapping[i]];"
    },
    {
        "line": 106,
        "fullcodeline": "if (j == 0 && color_cache_bits > 0) {"
    },
    {
        "line": 110,
        "fullcodeline": "ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_tables);"
    },
    {
        "line": 112,
        "fullcodeline": "if (size == 0) {"
    },
    {
        "line": 115,
        "fullcodeline": "if (is_trivial_literal && kLiteralMap[j] == 1) {"
    },
    {
        "line": 120,
        "fullcodeline": "if (j <= ALPHA) {"
    },
    {
        "line": 138,
        "fullcodeline": "if (total_size == 0 && htrees[GREEN][0].value < NUM_LITERAL_CODES) {"
    },
    {
        "line": 107,
        "fullcodeline": "alphabet_size += (1 << color_cache_bits);"
    },
    {
        "line": 116,
        "fullcodeline": "is_trivial_literal = (htrees[j]->bits == 0);"
    },
    {
        "line": 121,
        "fullcodeline": "int local_max_bits = code_lengths[0];"
    },
    {
        "line": 128,
        "fullcodeline": "max_bits += local_max_bits;"
    },
    {
        "line": 139,
        "fullcodeline": "htree_group->is_trivial_code = 1;"
    },
    {
        "line": 140,
        "fullcodeline": "htree_group->literal_arb |= htrees[GREEN][0].value << 8;"
    },
    {
        "line": 123,
        "fullcodeline": "for (k = 1; k < alphabet_size; ++k) {"
    },
    {
        "line": 124,
        "fullcodeline": "if (code_lengths[k] > local_max_bits) {"
    },
    {
        "line": 125,
        "fullcodeline": "local_max_bits = code_lengths[k];"
    }
]