[
    {
        "line": 8,
        "fullcodeline": "unsigned err_vec = GP_VECTOR;"
    },
    {
        "line": 9,
        "fullcodeline": "u32 err_code = 0;"
    },
    {
        "line": 10,
        "fullcodeline": "bool null_selector = !(selector & ~0x3); /* 0000-0003 are null */"
    },
    {
        "line": 14,
        "fullcodeline": "u32 base3 = 0;"
    },
    {
        "line": 16,
        "fullcodeline": "memset(&seg_desc, 0, sizeof seg_desc);"
    },
    {
        "line": 35,
        "fullcodeline": "rpl = selector & 3;"
    },
    {
        "line": 52,
        "fullcodeline": "ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);"
    },
    {
        "line": 56,
        "fullcodeline": "err_code = selector & 0xfffc;"
    },
    {
        "line": 57,
        "fullcodeline": "err_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :"
    },
    {
        "line": 72,
        "fullcodeline": "dpl = seg_desc.dpl;"
    },
    {
        "line": 154,
        "fullcodeline": "ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);"
    },
    {
        "line": 18,
        "fullcodeline": "if (ctxt->mode == X86EMUL_MODE_REAL) {"
    },
    {
        "line": 38,
        "fullcodeline": "if ((seg == VCPU_SREG_CS"
    },
    {
        "line": 46,
        "fullcodeline": "if (seg == VCPU_SREG_TR && (selector & (1 << 2)))"
    },
    {
        "line": 53,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 61,
        "fullcodeline": "if (seg <= VCPU_SREG_GS && !seg_desc.s) {"
    },
    {
        "line": 67,
        "fullcodeline": "if (!seg_desc.p) {"
    },
    {
        "line": 159,
        "fullcodeline": "return emulate_exception(ctxt, err_vec, err_code, true);"
    },
    {
        "line": 21,
        "fullcodeline": "ctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);"
    },
    {
        "line": 22,
        "fullcodeline": "set_desc_base(&seg_desc, selector << 4);"
    },
    {
        "line": 68,
        "fullcodeline": "err_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;"
    },
    {
        "line": 106,
        "fullcodeline": "selector = (selector & 0xfffc) | cpl;"
    },
    {
        "line": 111,
        "fullcodeline": "old_desc = seg_desc;"
    },
    {
        "line": 112,
        "fullcodeline": "seg_desc.type |= 2; /* busy */"
    },
    {
        "line": 113,
        "fullcodeline": "ret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,"
    },
    {
        "line": 156,
        "fullcodeline": "*desc = seg_desc;"
    },
    {
        "line": 41,
        "fullcodeline": "|| seg == VCPU_SREG_TR)"
    },
    {
        "line": 62,
        "fullcodeline": "if (transfer == X86_TRANSFER_CALL_JMP)"
    },
    {
        "line": 80,
        "fullcodeline": "if (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)"
    },
    {
        "line": 84,
        "fullcodeline": "if (!(seg_desc.type & 8))"
    },
    {
        "line": 87,
        "fullcodeline": "if (seg_desc.type & 4) {"
    },
    {
        "line": 97,
        "fullcodeline": "if (seg_desc.d && seg_desc.l) {"
    },
    {
        "line": 109,
        "fullcodeline": "if (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))"
    },
    {
        "line": 115,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 119,
        "fullcodeline": "if (seg_desc.s || seg_desc.type != 2)"
    },
    {
        "line": 128,
        "fullcodeline": "if ((seg_desc.type & 0xa) == 0x8 ||"
    },
    {
        "line": 137,
        "fullcodeline": "if (!(seg_desc.type & 1)) {"
    },
    {
        "line": 24,
        "fullcodeline": "} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {"
    },
    {
        "line": 39,
        "fullcodeline": "|| (seg == VCPU_SREG_SS"
    },
    {
        "line": 98,
        "fullcodeline": "u64 efer = 0;"
    },
    {
        "line": 100,
        "fullcodeline": "ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);"
    },
    {
        "line": 129,
        "fullcodeline": "(((seg_desc.type & 0xc) != 0xc) &&"
    },
    {
        "line": 138,
        "fullcodeline": "seg_desc.type |= 1;"
    },
    {
        "line": 139,
        "fullcodeline": "ret = write_segment_descriptor(ctxt, selector,"
    },
    {
        "line": 144,
        "fullcodeline": "} else if (ctxt->mode == X86EMUL_MODE_PROT64) {"
    },
    {
        "line": 26,
        "fullcodeline": "set_desc_base(&seg_desc, selector << 4);"
    },
    {
        "line": 27,
        "fullcodeline": "set_desc_limit(&seg_desc, 0xffff);"
    },
    {
        "line": 28,
        "fullcodeline": "seg_desc.type = 3;"
    },
    {
        "line": 29,
        "fullcodeline": "seg_desc.p = 1;"
    },
    {
        "line": 30,
        "fullcodeline": "seg_desc.s = 1;"
    },
    {
        "line": 31,
        "fullcodeline": "seg_desc.dpl = 3;"
    },
    {
        "line": 40,
        "fullcodeline": "&& (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))"
    },
    {
        "line": 89,
        "fullcodeline": "if (dpl > cpl)"
    },
    {
        "line": 101,
        "fullcodeline": "if (efer & EFER_LMA)"
    },
    {
        "line": 130,
        "fullcodeline": "(rpl > dpl && cpl > dpl)))"
    },
    {
        "line": 141,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 145,
        "fullcodeline": "ret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,"
    },
    {
        "line": 93,
        "fullcodeline": "if (rpl > cpl || dpl != cpl)"
    },
    {
        "line": 147,
        "fullcodeline": "if (ret != X86EMUL_CONTINUE)"
    },
    {
        "line": 149,
        "fullcodeline": "if (is_noncanonical_address(get_desc_base(&seg_desc) |"
    },
    {
        "line": 150,
        "fullcodeline": "((u64)base3 << 32)))"
    },
    {
        "line": 151,
        "fullcodeline": "return emulate_gp(ctxt, 0);"
    }
]