static int fpgamgr_set_cdratio_cdwidth(unsigned int cfg_width, u32 *rbf_data,
				       size_t rbf_size)
{
	unsigned int cd_ratio;
	bool encrypt, compress;

	/*
         * According to the bitstream specification,
	 * both encryption and compression status are
         * in location before offset 230 of the buffer.
         */
	if (rbf_size < MIN_BITSTREAM_SIZECHECK)
		return -EINVAL;

	encrypt = (rbf_data[ENCRYPTION_OFFSET] >> 2) & 3;
	encrypt = encrypt != 0;

	compress = (rbf_data[COMPRESSION_OFFSET] >> 1) & 1;
	compress = !compress;

	debug("FPGA: Header word %d = %08x.\n", 69, rbf_data[69]);
	debug("FPGA: Header word %d = %08x.\n", 229, rbf_data[229]);
	debug("FPGA: Read from rbf header: encrypt=%d compress=%d.\n", encrypt,
	     compress);

	/*
	 * from the register map description of cdratio in imgcfg_ctrl_02:
	 *  Normal Configuration    : 32bit Passive Parallel
	 *  Partial Reconfiguration : 16bit Passive Parallel
	 */

	/*
	 * cd ratio is dependent on cfg width and whether the bitstream
	 * is encrypted and/or compressed.
	 *
	 * | width | encr. | compr. | cd ratio |
	 * |  16   |   0   |   0    |     1    |
	 * |  16   |   0   |   1    |     4    |
	 * |  16   |   1   |   0    |     2    |
	 * |  16   |   1   |   1    |     4    |
	 * |  32   |   0   |   0    |     1    |
	 * |  32   |   0   |   1    |     8    |
	 * |  32   |   1   |   0    |     4    |
	 * |  32   |   1   |   1    |     8    |
	 */
	if (!compress && !encrypt) {
		cd_ratio = CDRATIO_x1;
	} else {
		if (compress)
			cd_ratio = CDRATIO_x4;
		else
			cd_ratio = CDRATIO_x2;

		/* if 32 bit, double the cd ratio (so register
		   field setting is incremented) */
		if (cfg_width == CFGWDTH_32)
			cd_ratio += 1;
	}

	fpgamgr_set_cfgwdth(cfg_width);
	fpgamgr_set_cd_ratio(cd_ratio);

	return 0;
}
