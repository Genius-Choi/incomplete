static int do_fsl_mc(struct cmd_tbl *cmdtp, int flag, int argc,
		     char *const argv[])
{
	int err = 0;
	if (argc < 3)
		goto usage;

	switch (argv[1][0]) {
	case 's': {
			char sub_cmd;
			u64 mc_fw_addr, mc_dpc_addr;
#ifdef CONFIG_SYS_LS_MC_DRAM_AIOP_IMG_OFFSET
			u64 aiop_fw_addr;
#endif

			sub_cmd = argv[2][0];

			switch (sub_cmd) {
			case 'm':
				if (argc < 5)
					goto usage;

				if (get_mc_boot_status() == 0) {
					printf("fsl-mc: MC is already booted");
					printf("\n");
					return err;
				}
				mc_fw_addr = simple_strtoull(argv[3], NULL, 16);
				mc_dpc_addr = simple_strtoull(argv[4], NULL,
							      16);

				if (!mc_init(mc_fw_addr, mc_dpc_addr))
					err = mc_init_object();
				break;

#ifdef CONFIG_SYS_LS_MC_DRAM_AIOP_IMG_OFFSET
			case 'a':
				if (argc < 4)
					goto usage;
				if (get_aiop_apply_status() == 0) {
					printf("fsl-mc: AIOP FW is already");
					printf(" applied\n");
					return err;
				}

				aiop_fw_addr = simple_strtoull(argv[3], NULL,
							       16);

				/* if SoC doesn't have AIOP, err = -ENODEV */
				err = load_mc_aiop_img(aiop_fw_addr);
				if (!err)
					printf("fsl-mc: AIOP FW applied\n");
				break;
#endif
			default:
				printf("Invalid option: %s\n", argv[2]);
				goto usage;

				break;
			}
		}
		break;

	case 'l': {
		/* lazyapply */
		u64 mc_dpl_addr;

		if (argc < 4)
			goto usage;

		if (get_dpl_apply_status() == 0) {
			printf("fsl-mc: DPL already applied\n");
			return err;
		}

		mc_dpl_addr = simple_strtoull(argv[3], NULL, 16);

		if (get_mc_boot_status() != 0) {
			printf("fsl-mc: Deploying data path layout ..");
			printf("ERROR (MC is not booted)\n");
			return -ENODEV;
		}

		/*
		 * We will do the actual dpaa exit and dpl apply
		 * later from announce_and_cleanup().
		 */
		mc_lazy_dpl_addr = mc_dpl_addr;
		break;
		}

	case 'a': {
		/* apply */
		char sub_cmd;
		u64 mc_apply_addr;

		if (argc < 4)
			goto usage;

		sub_cmd = argv[2][0];

		switch (sub_cmd) {
		case 'd':
		case 'D':
			if (get_dpl_apply_status() == 0) {
				printf("fsl-mc: DPL already applied\n");
				return err;
			}
			if (get_mc_boot_status() != 0) {
				printf("fsl-mc: Deploying data path layout ..");
				printf("ERROR (MC is not booted)\n");
				return -ENODEV;
			}

			mc_apply_addr = simple_strtoull(argv[3], NULL, 16);

			/* The user wants DPL applied now */
			if (!fsl_mc_ldpaa_exit(NULL))
				err = mc_apply_dpl(mc_apply_addr);
			break;

		case 's':
			if (!is_dpsparser_supported()) {
				printf("fsl-mc: apply spb command .. ");
				printf("ERROR: requires at least MC 10.12.0\n");
				return err;
			}
			if (get_mc_boot_status() != 0) {
				printf("fsl-mc: Deploying Soft Parser Blob...");
				printf("ERROR (MC is not booted)\n");
				return err;
			}

			mc_apply_addr = simple_strtoull(argv[3], NULL, 16);

			/* Apply spb (Soft Parser Blob) */
			err = mc_apply_spb(mc_apply_addr);
			break;

		default:
			printf("Invalid option: %s\n", argv[2]);
			goto usage;
		}
		break;
		}
	default:
		printf("Invalid option: %s\n", argv[1]);
		goto usage;
		break;
	}
	return err;
 usage:
	return CMD_RET_USAGE;
}
