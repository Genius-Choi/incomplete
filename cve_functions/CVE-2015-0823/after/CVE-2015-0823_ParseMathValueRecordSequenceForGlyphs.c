bool ParseMathValueRecordSequenceForGlyphs(const ots::OpenTypeFile *file,
                                           ots::Buffer* subtable,
                                           const uint8_t *data,
                                           const size_t length,
                                           const uint16_t num_glyphs) {
  // Check the header.
  uint16_t offset_coverage = 0;
  uint16_t sequence_count = 0;
  if (!subtable->ReadU16(&offset_coverage) ||
      !subtable->ReadU16(&sequence_count)) {
    return OTS_FAILURE();
  }

  const unsigned sequence_end = static_cast<unsigned>(2 * 2) +
      sequence_count * kMathValueRecordSize;
  if (sequence_end > std::numeric_limits<uint16_t>::max()) {
    return OTS_FAILURE();
  }

  // Check coverage table.
  if (offset_coverage < sequence_end || offset_coverage >= length) {
    return OTS_FAILURE();
  }
  if (!ots::ParseCoverageTable(file, data + offset_coverage,
                               length - offset_coverage,
                               num_glyphs, sequence_count)) {
    return OTS_FAILURE();
  }

  // Check sequence.
  for (unsigned i = 0; i < sequence_count; ++i) {
    if (!ParseMathValueRecord(file, subtable, data, length)) {
      return OTS_FAILURE();
    }
  }

  return true;
}
