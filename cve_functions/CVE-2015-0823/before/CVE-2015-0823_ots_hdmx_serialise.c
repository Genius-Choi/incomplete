bool ots_hdmx_serialise(OTSStream *out, OpenTypeFile *file) {
  OpenTypeHDMX * const hdmx = file->hdmx;

  const int16_t num_recs = static_cast<int16_t>(hdmx->records.size());
  if (hdmx->records.size() >
          static_cast<size_t>(std::numeric_limits<int16_t>::max()) ||
      !out->WriteU16(hdmx->version) ||
      !out->WriteS16(num_recs) ||
      !out->WriteS32(hdmx->size_device_record)) {
    return OTS_FAILURE_MSG("Failed to write hdmx header");
  }

  for (int16_t i = 0; i < num_recs; ++i) {
    const OpenTypeHDMXDeviceRecord& rec = hdmx->records[i];
    if (!out->Write(&rec.pixel_size, 1) ||
        !out->Write(&rec.max_width, 1) ||
        !out->Write(&rec.widths[0], rec.widths.size())) {
      return OTS_FAILURE_MSG("Failed to write hdmx record %d", i);
    }
    if ((hdmx->pad_len > 0) &&
        !out->Write((const uint8_t *)"\x00\x00\x00", hdmx->pad_len)) {
      return OTS_FAILURE_MSG("Failed to write hdmx padding of length %d", hdmx->pad_len);
    }
  }

  return true;
}
