bool ParseGlyphAssemblyTable(const ots::OpenTypeFile *file,
                             const uint8_t *data,
                             size_t length, const uint16_t num_glyphs) {
  ots::Buffer subtable(data, length);

  // Check the header.
  uint16_t part_count = 0;
  if (!ParseMathValueRecord(file, &subtable, data, length) ||
      !subtable.ReadU16(&part_count)) {
    return OTS_FAILURE();
  }

  const unsigned sequence_end = kMathValueRecordSize +
    static_cast<unsigned>(2) + part_count * kGlyphPartRecordSize;
  if (sequence_end > std::numeric_limits<uint16_t>::max()) {
    return OTS_FAILURE();
  }

  // Check the sequence of GlyphPartRecord.
  for (unsigned i = 0; i < part_count; ++i) {
    uint16_t glyph = 0;
    uint16_t part_flags = 0;
    if (!subtable.ReadU16(&glyph) ||
        !subtable.Skip(2 * 3) ||
        !subtable.ReadU16(&part_flags)) {
      return OTS_FAILURE();
    }
    if (glyph >= num_glyphs) {
      return OTS_FAILURE_MSG("bad glyph ID: %u", glyph);
    }
    if (part_flags & ~0x00000001) {
      return OTS_FAILURE_MSG("unknown part flag: %u", part_flags);
    }
  }

  return true;
}
