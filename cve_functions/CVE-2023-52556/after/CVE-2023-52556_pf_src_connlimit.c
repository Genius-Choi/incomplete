pf_src_connlimit(struct pf_state **stp)
{
	int			 bad = 0;
	struct pf_src_node	*sn;

	if ((sn = pf_get_src_node((*stp), PF_SN_NONE)) == NULL)
		return (0);

	sn->conn++;
	(*stp)->src.tcp_est = 1;
	pf_add_threshold(&sn->conn_rate);

	if ((*stp)->rule.ptr->max_src_conn &&
	    (*stp)->rule.ptr->max_src_conn < sn->conn) {
		pf_status.lcounters[LCNT_SRCCONN]++;
		bad++;
	}

	if ((*stp)->rule.ptr->max_src_conn_rate.limit &&
	    pf_check_threshold(&sn->conn_rate)) {
		pf_status.lcounters[LCNT_SRCCONNRATE]++;
		bad++;
	}

	if (!bad)
		return (0);

	if ((*stp)->rule.ptr->overload_tbl) {
		struct pfr_addr p;
		u_int32_t	killed = 0;

		pf_status.lcounters[LCNT_OVERLOAD_TABLE]++;
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE,
			    "pf: pf_src_connlimit: blocking address ");
			pf_print_host(&sn->addr, 0,
			    (*stp)->key[PF_SK_WIRE]->af);
		}

		memset(&p, 0, sizeof(p));
		p.pfra_af = (*stp)->key[PF_SK_WIRE]->af;
		switch ((*stp)->key[PF_SK_WIRE]->af) {
		case AF_INET:
			p.pfra_net = 32;
			p.pfra_ip4addr = sn->addr.v4;
			break;
#ifdef INET6
		case AF_INET6:
			p.pfra_net = 128;
			p.pfra_ip6addr = sn->addr.v6;
			break;
#endif /* INET6 */
		}

		pfr_insert_kentry((*stp)->rule.ptr->overload_tbl,
		    &p, gettime());

		/* kill existing states if that's required. */
		if ((*stp)->rule.ptr->flush) {
			struct pf_state_key *sk;
			struct pf_state *st;

			pf_status.lcounters[LCNT_OVERLOAD_FLUSH]++;
			RBT_FOREACH(st, pf_state_tree_id, &tree_id) {
				sk = st->key[PF_SK_WIRE];
				/*
				 * Kill states from this source.  (Only those
				 * from the same rule if PF_FLUSH_GLOBAL is not
				 * set)
				 */
				if (sk->af ==
				    (*stp)->key[PF_SK_WIRE]->af &&
				    (((*stp)->direction == PF_OUT &&
				    PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||
				    ((*stp)->direction == PF_IN &&
				    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&
				    ((*stp)->rule.ptr->flush &
				    PF_FLUSH_GLOBAL ||
				    (*stp)->rule.ptr == st->rule.ptr)) {
					pf_update_state_timeout(st, PFTM_PURGE);
					pf_set_protostate(st, PF_PEER_BOTH,
					    TCPS_CLOSED);
					killed++;
				}
			}
			if (pf_status.debug >= LOG_NOTICE)
				addlog(", %u states killed", killed);
		}
		if (pf_status.debug >= LOG_NOTICE)
			addlog("\n");
	}

	/* kill this state */
	pf_update_state_timeout(*stp, PFTM_PURGE);
	pf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);
	return (1);
}
