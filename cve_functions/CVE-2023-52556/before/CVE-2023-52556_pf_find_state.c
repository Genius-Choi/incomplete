pf_find_state(struct pf_pdesc *pd, struct pf_state_key_cmp *key,
    struct pf_state **stp)
{
	struct pf_state_key	*sk, *pkt_sk, *inp_sk;
	struct pf_state_item	*si;
	struct pf_state		*st = NULL;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;
	if (pf_status.debug >= LOG_DEBUG) {
		log(LOG_DEBUG, "pf: key search, %s on %s: ",
		    pd->dir == PF_OUT ? "out" : "in", pd->kif->pfik_name);
		pf_print_state_parts(NULL, (struct pf_state_key *)key, NULL);
		addlog("\n");
	}

	inp_sk = NULL;
	pkt_sk = NULL;
	sk = NULL;
	if (pd->dir == PF_OUT) {
		/* first if block deals with outbound forwarded packet */
		pkt_sk = pd->m->m_pkthdr.pf.statekey;

		if (!pf_state_key_isvalid(pkt_sk)) {
			pf_mbuf_unlink_state_key(pd->m);
			pkt_sk = NULL;
		}

		if (pkt_sk && pf_state_key_isvalid(pkt_sk->sk_reverse))
			sk = pkt_sk->sk_reverse;

		if (pkt_sk == NULL) {
			/* here we deal with local outbound packet */
			if (pd->m->m_pkthdr.pf.inp != NULL) {
				inp_sk = pd->m->m_pkthdr.pf.inp->inp_pf_sk;
				if (pf_state_key_isvalid(inp_sk))
					sk = inp_sk;
				else
					pf_inpcb_unlink_state_key(
					    pd->m->m_pkthdr.pf.inp);
			}
		}
	}

	if (sk == NULL) {
		if ((sk = RBT_FIND(pf_state_tree, &pf_statetbl,
		    (struct pf_state_key *)key)) == NULL)
			return (PF_DROP);
		if (pd->dir == PF_OUT && pkt_sk &&
		    pf_compare_state_keys(pkt_sk, sk, pd->kif, pd->dir) == 0)
			pf_state_key_link_reverse(sk, pkt_sk);
		else if (pd->dir == PF_OUT && pd->m->m_pkthdr.pf.inp &&
		    !pd->m->m_pkthdr.pf.inp->inp_pf_sk && !sk->sk_inp)
			pf_state_key_link_inpcb(sk, pd->m->m_pkthdr.pf.inp);
	}

	/* remove firewall data from outbound packet */
	if (pd->dir == PF_OUT)
		pf_pkt_addr_changed(pd->m);

	/* list is sorted, if-bound states before floating ones */
	TAILQ_FOREACH(si, &sk->sk_states, si_entry) {
		struct pf_state *sist = si->si_st;
		if (sist->timeout != PFTM_PURGE &&
		    (sist->kif == pfi_all || sist->kif == pd->kif) &&
		    ((sist->key[PF_SK_WIRE]->af == sist->key[PF_SK_STACK]->af &&
		      sk == (pd->dir == PF_IN ? sist->key[PF_SK_WIRE] :
		    sist->key[PF_SK_STACK])) ||
		    (sist->key[PF_SK_WIRE]->af != sist->key[PF_SK_STACK]->af
		    && pd->dir == PF_IN && (sk == sist->key[PF_SK_STACK] ||
		    sk == sist->key[PF_SK_WIRE])))) {
			st = sist;
			break;
		}
	}

	if (st == NULL)
		return (PF_DROP);
	if (ISSET(st->state_flags, PFSTATE_INP_UNLINKED))
		return (PF_DROP);

	if (st->rule.ptr->pktrate.limit && pd->dir == st->direction) {
		pf_add_threshold(&st->rule.ptr->pktrate);
		if (pf_check_threshold(&st->rule.ptr->pktrate))
			return (PF_DROP);
	}

	*stp = st;

	return (PF_MATCH);
}
