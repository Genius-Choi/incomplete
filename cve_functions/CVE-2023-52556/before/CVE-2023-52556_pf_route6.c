pf_route6(struct pf_pdesc *pd, struct pf_state *st)
{
	struct mbuf		*m0;
	struct sockaddr_in6	*dst, sin6;
	struct rtentry		*rt = NULL;
	struct ip6_hdr		*ip6;
	struct ifnet		*ifp = NULL;
	struct m_tag		*mtag;
	unsigned int		 rtableid;

	if (pd->m->m_pkthdr.pf.routed++ > 3) {
		m_freem(pd->m);
		pd->m = NULL;
		return;
	}

	if (st->rt == PF_DUPTO) {
		if ((m0 = m_dup_pkt(pd->m, max_linkhdr, M_NOWAIT)) == NULL)
			return;
	} else {
		if ((st->rt == PF_REPLYTO) == (st->direction == pd->dir))
			return;
		m0 = pd->m;
		pd->m = NULL;
	}

	if (m0->m_len < sizeof(struct ip6_hdr)) {
		DPFPRINTF(LOG_ERR,
		    "%s: m0->m_len < sizeof(struct ip6_hdr)", __func__);
		goto bad;
	}
	ip6 = mtod(m0, struct ip6_hdr *);

	if (pd->dir == PF_IN) {
		if (ip6->ip6_hlim <= IPV6_HLIMDEC) {
			if (st->rt != PF_DUPTO) {
				pf_send_icmp(m0, ICMP6_TIME_EXCEEDED,
				    ICMP6_TIME_EXCEED_TRANSIT, 0,
				    pd->af, st->rule.ptr, pd->rdomain);
			}
			goto bad;
		}
		ip6->ip6_hlim -= IPV6_HLIMDEC;
	}

	memset(&sin6, 0, sizeof(sin6));
	dst = &sin6;
	dst->sin6_family = AF_INET6;
	dst->sin6_len = sizeof(*dst);
	dst->sin6_addr = st->rt_addr.v6;
	rtableid = m0->m_pkthdr.ph_rtableid;

	rt = rtalloc_mpath(sin6tosa(dst), &ip6->ip6_src.s6_addr32[0],
	    rtableid);
	if (!rtisvalid(rt)) {
		if (st->rt != PF_DUPTO) {
			pf_send_icmp(m0, ICMP6_DST_UNREACH,
			    ICMP6_DST_UNREACH_NOROUTE, 0,
			    pd->af, st->rule.ptr, pd->rdomain);
		}
		ip6stat_inc(ip6s_noroute);
		goto bad;
	}

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		goto bad;

	/* A locally generated packet may have invalid source address. */
	if (IN6_IS_ADDR_LOOPBACK(&ip6->ip6_src) &&
	    (ifp->if_flags & IFF_LOOPBACK) == 0)
		ip6->ip6_src = ifatoia6(rt->rt_ifa)->ia_addr.sin6_addr;

	if (st->rt != PF_DUPTO && pd->dir == PF_IN) {
		if (pf_test(AF_INET6, PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip6_hdr)) {
			DPFPRINTF(LOG_ERR,
			    "%s: m0->m_len < sizeof(struct ip6_hdr)", __func__);
			goto bad;
		}
	}

	/*
	 * If packet has been reassembled by PF earlier, we have to
	 * use pf_refragment6() here to turn it back to fragments.
	 */
	if ((mtag = m_tag_find(m0, PACKET_TAG_PF_REASSEMBLED, NULL))) {
		(void) pf_refragment6(&m0, mtag, dst, ifp, rt);
		goto done;
	}

	if (if_output_tso(ifp, &m0, sin6tosa(dst), rt, ifp->if_mtu) ||
	    m0 == NULL)
		goto done;

	ip6stat_inc(ip6s_cantfrag);
	if (st->rt != PF_DUPTO)
		pf_send_icmp(m0, ICMP6_PACKET_TOO_BIG, 0,
		    ifp->if_mtu, pd->af, st->rule.ptr, pd->rdomain);
	goto bad;

done:
	if_put(ifp);
	rtfree(rt);
	return;

bad:
	m_freem(m0);
	goto done;
}
