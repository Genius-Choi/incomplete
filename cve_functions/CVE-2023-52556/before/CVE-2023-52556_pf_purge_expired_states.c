pf_purge_expired_states(const unsigned int limit, const unsigned int collect)
{
	/*
	 * this task/thread/context/whatever is the only thing that
	 * removes states from the pf_state_list, so the cur reference
	 * it holds between calls is guaranteed to still be in the
	 * list.
	 */
	static struct pf_state	*cur = NULL;

	struct pf_state		*head, *tail;
	struct pf_state		*st;
	SLIST_HEAD(pf_state_gcl, pf_state) gcl = SLIST_HEAD_INITIALIZER(gcl);
	time_t			 now;
	unsigned int		 scanned;
	unsigned int		 collected = 0;

	PF_ASSERT_UNLOCKED();

	rw_enter_read(&pf_state_list.pfs_rwl);

	mtx_enter(&pf_state_list.pfs_mtx);
	head = TAILQ_FIRST(&pf_state_list.pfs_list);
	tail = TAILQ_LAST(&pf_state_list.pfs_list, pf_state_queue);
	mtx_leave(&pf_state_list.pfs_mtx);

	if (head == NULL) {
		/* the list is empty */
		rw_exit_read(&pf_state_list.pfs_rwl);
		return (limit);
	}

	/* (re)start at the front of the list */
	if (cur == NULL)
		cur = head;

	now = getuptime();

	for (scanned = 0; scanned < limit; scanned++) {
		uint8_t stimeout = cur->timeout;
		unsigned int limited = 0;

		if ((stimeout == PFTM_UNLINKED) ||
		    (pf_state_expires(cur, stimeout) <= now)) {
			st = pf_state_ref(cur);
			SLIST_INSERT_HEAD(&gcl, st, gc_list);

			if (++collected >= collect)
				limited = 1;
		}

		/* don't iterate past the end of our view of the list */
		if (cur == tail) {
			cur = NULL;
			break;
		}

		cur = TAILQ_NEXT(cur, entry_list);

		/* don't spend too much time here. */
		if (ISSET(READ_ONCE(curcpu()->ci_schedstate.spc_schedflags),
		     SPCF_SHOULDYIELD) || limited)
			break;
	}

	rw_exit_read(&pf_state_list.pfs_rwl);

	if (SLIST_EMPTY(&gcl))
		return (scanned);

	rw_enter_write(&pf_state_list.pfs_rwl);
	PF_LOCK();
	PF_STATE_ENTER_WRITE();
	SLIST_FOREACH(st, &gcl, gc_list) {
		if (st->timeout != PFTM_UNLINKED)
			pf_remove_state(st);

		pf_free_state(st);
	}
	PF_STATE_EXIT_WRITE();
	PF_UNLOCK();
	rw_exit_write(&pf_state_list.pfs_rwl);

	while ((st = SLIST_FIRST(&gcl)) != NULL) {
		SLIST_REMOVE_HEAD(&gcl, gc_list);
		pf_state_unref(st);
	}

	return (scanned);
}
