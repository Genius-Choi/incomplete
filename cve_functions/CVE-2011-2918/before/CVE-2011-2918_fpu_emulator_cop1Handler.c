int fpu_emulator_cop1Handler(struct pt_regs *xcp, struct mips_fpu_struct *ctx,
	int has_fpu, void *__user *fault_addr)
{
	unsigned long oldepc, prevepc;
	mips_instruction insn;
	int sig = 0;

	oldepc = xcp->cp0_epc;
	do {
		prevepc = xcp->cp0_epc;

		if (!access_ok(VERIFY_READ, xcp->cp0_epc, sizeof(mips_instruction))) {
			MIPS_FPU_EMU_INC_STATS(errors);
			*fault_addr = (mips_instruction __user *)xcp->cp0_epc;
			return SIGBUS;
		}
		if (__get_user(insn, (mips_instruction __user *) xcp->cp0_epc)) {
			MIPS_FPU_EMU_INC_STATS(errors);
			*fault_addr = (mips_instruction __user *)xcp->cp0_epc;
			return SIGSEGV;
		}
		if (insn == 0)
			xcp->cp0_epc += 4;	/* skip nops */
		else {
			/*
			 * The 'ieee754_csr' is an alias of
			 * ctx->fcr31.  No need to copy ctx->fcr31 to
			 * ieee754_csr.  But ieee754_csr.rm is ieee
			 * library modes. (not mips rounding mode)
			 */
			/* convert to ieee library modes */
			ieee754_csr.rm = ieee_rm[ieee754_csr.rm];
			sig = cop1Emulate(xcp, ctx, fault_addr);
			/* revert to mips rounding mode */
			ieee754_csr.rm = mips_rm[ieee754_csr.rm];
		}

		if (has_fpu)
			break;
		if (sig)
			break;

		cond_resched();
	} while (xcp->cp0_epc > prevepc);

	/* SIGILL indicates a non-fpu instruction */
	if (sig == SIGILL && xcp->cp0_epc != oldepc)
		/* but if epc has advanced, then ignore it */
		sig = 0;

	return sig;
}
