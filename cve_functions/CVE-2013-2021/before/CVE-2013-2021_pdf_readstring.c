static char *pdf_readstring(const char *q0, int len, const char *key, unsigned *slen)
{
    char *s, *s0;
    const char *start, *q, *end;
    if (slen)
	*slen = 0;
    q = pdf_getdict(q0, &len, key);
    if (!q)
	return NULL;
    if (*q == '(') {
	int paren = 1;
	start = ++q;
	for (;paren > 0 && len > 0; q++,len--) {
	    switch (*q) {
		case '(':
		    paren++;
		    break;
		case ')':
		    paren--;
		    break;
		case '\\':
		    q++;
		    len--;
		    break;
		default:
		    break;
	    }
	}
	q--;
	len  = q - start;
	s0 = s = cli_malloc(len + 1);
	if (!s)
	    return NULL;
	end = start + len;
	for (q = start;q < end;q++) {
	    if (*q != '\\') {
		*s++ = *q;
	    } else {
		q++;
		switch (*q) {
		    case 'n':
			*s++ = '\n';
			break;
		    case 'r':
			*s++ = '\r';
			break;
		    case 't':
			*s++ = '\t';
			break;
		    case 'b':
			*s++ = '\b';
			break;
		    case 'f':
			*s++ = '\f';
			break;
		    case '(':/* fall-through */
		    case ')':/* fall-through */
		    case '\\':
			*s++ = *q;
			break;
		    case '\n':
			/* ignore */
			break;
		    case '\r':
			/* ignore */
			if (q+1 < end && q[1] == '\n')
			    q++;
			break;
		    case '0':
		    case '1':
		    case '2':
		    case '3':
		    case '4':
		    case '5':
		    case '6':
		    case '7':
		    case '8':
		    case '9':
			/* octal escape */
			if (q+2 < end)
			    q++;
			*s++ = 64*(q[0] - '0')+
			      8*(q[1] - '0')+
			        (q[2] - '0');
			break;
		    default:
			/* ignore */
			q--;
			break;
		}
	    }
	}
	*s++ = '\0';
	if (slen)
	    *slen = s - s0 - 1;
	return s0;
    }
    if (*q == '<') {
	start = ++q;
	q = memchr(q+1, '>', len);
	if (!q)
	    return NULL;
	s = cli_malloc((q - start)/2 + 1);
	cli_hex2str_to(start, s, q - start);
	s[(q-start)/2] = '\0';
	if (slen)
	    *slen = (q - start)/2;
	return s;
    }
    cli_dbgmsg("cli_pdf: %s is invalid string in dict\n", key);
    return NULL;
}
