static GF_Err txtin_process(GF_Filter *filter)
{
	GF_TXTIn *ctx = gf_filter_get_udta(filter);
	GF_FilterPacket *pck;
	GF_Err e;
	Bool start, end;
	pck = gf_filter_pid_get_packet(ctx->ipid);
	if (pck) ctx->is_loaded = GF_FALSE;

	if (!pck) {
		if (ctx->unframed) {
			if (gf_filter_pid_is_eos(ctx->ipid)) {
				if (ctx->end) {
#ifndef GPAC_DISABLE_VTT
					if (ctx->vttparser) {
						gf_webvtt_parser_flush(ctx->vttparser);
					}
					else
#endif
					if (!ctx->noflush) {
						gf_isom_text_reset(ctx->samp);
						txtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);
					}
					ctx->end = 0;
				}
				gf_filter_pid_set_eos(ctx->opid);
				return GF_EOS;
			}
		}
		if (!ctx->is_loaded)
			return GF_OK;
	}

	if (ctx->unframed) {
		if (ctx->simple_text) {
			e = ctx->text_process(filter, ctx, pck);
			gf_filter_pid_drop_packet(ctx->ipid);
			return e;
		}
		const u8 *data;
		u32 size;
		data = gf_filter_pck_get_data(pck, &size);
		e = GF_OK;
		if (data && size) {
			ctx->src = gf_file_temp(NULL);
			if (gf_fwrite(data, size, ctx->src) != size)
				e = GF_IO_ERR;
			gf_fseek(ctx->src, 0, SEEK_SET);
			//init state as parsing SRT payload
			ctx->state = 2;
			ctx->start = gf_filter_pck_get_cts(pck);
			ctx->end = ctx->start + gf_filter_pck_get_duration(pck);
			ctx->curLine = 0;

			if (!e)
				e = ctx->text_process(filter, ctx, pck);

			if (ctx->src) {
				gf_fclose(ctx->src);
				ctx->src = NULL;
			}
			if (e==GF_EOS) e = GF_OK;
		}
		gf_filter_pid_drop_packet(ctx->ipid);
		return e;
	}

	if (pck) {
		gf_filter_pck_get_framing(pck, &start, &end);
		if (!end) {
			gf_filter_pid_drop_packet(ctx->ipid);
			return GF_OK;
		}
		//file is loaded
		ctx->is_loaded = GF_TRUE;
	}

	e = ctx->text_process(filter, ctx, NULL);
	if (e==GF_EOS) {
		//keep input alive until end of stream, so that we keep getting called
		if (pck)
			gf_filter_pid_drop_packet(ctx->ipid);

		if (gf_filter_pid_is_eos(ctx->ipid))
			gf_filter_pid_set_eos(ctx->opid);
	}
	return e;
}
