static int ncrx_queue_payload(const char *payload, struct ncrx *ncrx,
		uint64_t now_real)
{
	struct ncrx_msg tmsg;
	struct ncrx_slot *slot;
	int new_msg = 0;

	if (parse_packet(payload, &tmsg))
		return -1;

	tmsg.rx_at_mono = ncrx->now_mono;
	tmsg.rx_at_real = now_real;
	ncrx->oos_history <<= 1;

	/* ack immediately if logging source is doing emergency transmissions */
	if (tmsg.emg) {
		ncrx->acked_seq = UINT64_MAX;
		ncrx->acked_at = 0;
	}

	/* get the matching slot and allocate a new message if empty */
	slot = get_seq_slot(&tmsg, ncrx);
	if (slot && !slot->msg) {
		slot->msg = copy_msg(&tmsg);
		new_msg = 1;
	}
	if (!slot || !slot->msg) {
		if (errno == ENOENT)
			return 0;
		if (errno == ERANGE)
			return queue_oos_msg(&tmsg, ncrx);
		return -1;
	}

	if (!new_msg && slot->msg->ncfrag_left) {
		struct ncrx_msg *msg = slot->msg;
		int off = tmsg.ncfrag_off;
		int i;

		for (i = 0; i < tmsg.ncfrag_len; i++) {
			if (msg->text[off + i])
				continue;
			msg->text[off + i] = tmsg.text[i];
			msg->ncfrag_left--;
		}
	}

	slot_maybe_complete(slot);

	return 0;
}
