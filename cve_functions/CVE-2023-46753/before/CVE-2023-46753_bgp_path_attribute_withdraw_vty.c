void bgp_path_attribute_withdraw_vty(struct vty *vty, struct peer *peer,
				     const char *withdraw_attrs, bool set)
{
	int i, num_attributes;
	char **attributes;
	afi_t afi;
	safi_t safi;

	/* If `no` command specified without arbitrary attributes,
	 * then flush all.
	 */
	if (!withdraw_attrs) {
		for (i = 1; i <= BGP_ATTR_MAX; i++)
			peer->withdraw_attrs[i] = false;
		goto withdraw_soft_clear;
	}

	if (withdraw_attrs) {
		frrstr_split(withdraw_attrs, " ", &attributes, &num_attributes);

		if (set)
			for (i = 1; i <= BGP_ATTR_MAX; i++)
				peer->withdraw_attrs[i] = false;

		for (i = 0; i < num_attributes; i++) {
			uint8_t attr_num = strtoul(attributes[i], NULL, 10);

			XFREE(MTYPE_TMP, attributes[i]);

			/* Some of the attributes, just can't be ignored. */
			if (attr_num == BGP_ATTR_ORIGIN ||
			    attr_num == BGP_ATTR_AS_PATH ||
			    attr_num == BGP_ATTR_NEXT_HOP ||
			    attr_num == BGP_ATTR_MULTI_EXIT_DISC ||
			    attr_num == BGP_ATTR_MP_REACH_NLRI ||
			    attr_num == BGP_ATTR_MP_UNREACH_NLRI ||
			    attr_num == BGP_ATTR_EXT_COMMUNITIES) {
				vty_out(vty,
					"%% Can't treat-as-withdraw path-attribute %s, ignoring.\n",
					lookup_msg(attr_str, attr_num, NULL));
				continue;
			}

			/* Ignore local-pref, originator-id, cluster-list only
			 * for eBGP.
			 */
			if (peer->sort != BGP_PEER_EBGP &&
			    (attr_num == BGP_ATTR_LOCAL_PREF ||
			     attr_num == BGP_ATTR_ORIGINATOR_ID ||
			     attr_num == BGP_ATTR_CLUSTER_LIST)) {
				vty_out(vty,
					"%% Can treat-as-withdraw path-attribute %s only for eBGP, ignoring.\n",
					lookup_msg(attr_str, attr_num, NULL));
				continue;
			}

			peer->withdraw_attrs[attr_num] = set;
		}
		XFREE(MTYPE_TMP, attributes);
	withdraw_soft_clear:
		/* Configuring path attributes to be treated as withdraw will
		 * trigger
		 * an inbound Route Refresh to ensure that the routing table
		 * is up to date.
		 */
		FOREACH_AFI_SAFI (afi, safi)
			peer_clear_soft(peer, afi, safi, BGP_CLEAR_SOFT_IN);
	}
}
