enum bgp_attr_parse_ret bgp_attr_prefix_sid(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	enum bgp_attr_parse_ret ret;

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID);

	uint8_t type;
	uint16_t length;
	size_t headersz = sizeof(type) + sizeof(length);
	size_t psid_parsed_length = 0;

	while (STREAM_READABLE(peer->curr) > 0
	       && psid_parsed_length < args->length) {

		if (STREAM_READABLE(peer->curr) < headersz) {
			flog_err(
				EC_BGP_ATTR_LEN,
				"Malformed Prefix SID attribute - insufficent data (need %zu for attribute header, have %zu remaining in UPDATE)",
				headersz, STREAM_READABLE(peer->curr));
			return bgp_attr_malformed(
				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
				args->total);
		}

		type = stream_getc(peer->curr);
		length = stream_getw(peer->curr);

		if (STREAM_READABLE(peer->curr) < length) {
			flog_err(
				EC_BGP_ATTR_LEN,
				"Malformed Prefix SID attribute - insufficient data (need %hu for attribute body, have %zu remaining in UPDATE)",
				length, STREAM_READABLE(peer->curr));
			return bgp_attr_malformed(args,
						  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
						  args->total);
		}

		ret = bgp_attr_psid_sub(type, length, args);

		if (ret != BGP_ATTR_PARSE_PROCEED)
			return ret;

		psid_parsed_length += length + headersz;

		if (psid_parsed_length > args->length) {
			flog_err(
				EC_BGP_ATTR_LEN,
				"Malformed Prefix SID attribute - TLV overflow by attribute (need %zu for TLV length, have %zu overflowed in UPDATE)",
				length + headersz, psid_parsed_length - (length + headersz));
			return bgp_attr_malformed(
				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
				args->total);
		}
	}

	return BGP_ATTR_PARSE_PROCEED;
}
