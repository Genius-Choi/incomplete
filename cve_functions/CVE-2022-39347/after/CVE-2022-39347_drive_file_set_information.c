BOOL drive_file_set_information(DRIVE_FILE* file, UINT32 FsInformationClass, UINT32 Length,
                                wStream* input)
{
	INT64 size;
	WCHAR* fullpath;
	ULARGE_INTEGER liCreationTime;
	ULARGE_INTEGER liLastAccessTime;
	ULARGE_INTEGER liLastWriteTime;
	ULARGE_INTEGER liChangeTime;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	FILETIME* pftCreationTime = NULL;
	FILETIME* pftLastAccessTime = NULL;
	FILETIME* pftLastWriteTime = NULL;
	UINT32 FileAttributes;
	UINT32 FileNameLength;
	LARGE_INTEGER liSize;
	UINT8 delete_pending;
	UINT8 ReplaceIfExists;
	DWORD attr;

	if (!file || !input)
		return FALSE;

	switch (FsInformationClass)
	{
		case FileBasicInformation:
			if (Stream_GetRemainingLength(input) < 36)
				return FALSE;

			/* http://msdn.microsoft.com/en-us/library/cc232094.aspx */
			Stream_Read_UINT64(input, liCreationTime.QuadPart);
			Stream_Read_UINT64(input, liLastAccessTime.QuadPart);
			Stream_Read_UINT64(input, liLastWriteTime.QuadPart);
			Stream_Read_UINT64(input, liChangeTime.QuadPart);
			Stream_Read_UINT32(input, FileAttributes);

			if (!PathFileExistsW(file->fullpath))
				return FALSE;

			if (file->file_handle == INVALID_HANDLE_VALUE)
			{
				WLog_ERR(TAG, "Unable to set file time %s (%" PRId32 ")", file->fullpath,
				         GetLastError());
				return FALSE;
			}

			if (liCreationTime.QuadPart != 0)
			{
				ftCreationTime.dwHighDateTime = liCreationTime.u.HighPart;
				ftCreationTime.dwLowDateTime = liCreationTime.u.LowPart;
				pftCreationTime = &ftCreationTime;
			}

			if (liLastAccessTime.QuadPart != 0)
			{
				ftLastAccessTime.dwHighDateTime = liLastAccessTime.u.HighPart;
				ftLastAccessTime.dwLowDateTime = liLastAccessTime.u.LowPart;
				pftLastAccessTime = &ftLastAccessTime;
			}

			if (liLastWriteTime.QuadPart != 0)
			{
				ftLastWriteTime.dwHighDateTime = liLastWriteTime.u.HighPart;
				ftLastWriteTime.dwLowDateTime = liLastWriteTime.u.LowPart;
				pftLastWriteTime = &ftLastWriteTime;
			}

			if (liChangeTime.QuadPart != 0 && liChangeTime.QuadPart > liLastWriteTime.QuadPart)
			{
				ftLastWriteTime.dwHighDateTime = liChangeTime.u.HighPart;
				ftLastWriteTime.dwLowDateTime = liChangeTime.u.LowPart;
				pftLastWriteTime = &ftLastWriteTime;
			}

			DEBUG_WSTR("SetFileTime %s", file->fullpath);

			SetFileAttributesW(file->fullpath, FileAttributes);
			if (!SetFileTime(file->file_handle, pftCreationTime, pftLastAccessTime,
			                 pftLastWriteTime))
			{
				WLog_ERR(TAG, "Unable to set file time to %s", file->fullpath);
				return FALSE;
			}

			break;

		case FileEndOfFileInformation:

		/* http://msdn.microsoft.com/en-us/library/cc232067.aspx */
		case FileAllocationInformation:
			if (Stream_GetRemainingLength(input) < 8)
				return FALSE;

			/* http://msdn.microsoft.com/en-us/library/cc232076.aspx */
			Stream_Read_INT64(input, size);

			if (file->file_handle == INVALID_HANDLE_VALUE)
			{
				WLog_ERR(TAG, "Unable to truncate %s to %" PRId64 " (%" PRId32 ")", file->fullpath,
				         size, GetLastError());
				return FALSE;
			}

			liSize.QuadPart = size;

			if (!SetFilePointerEx(file->file_handle, liSize, NULL, FILE_BEGIN))
			{
				WLog_ERR(TAG, "Unable to truncate %s to %d (%" PRId32 ")", file->fullpath, size,
				         GetLastError());
				return FALSE;
			}

			DEBUG_WSTR("Truncate %s", file->fullpath);

			if (SetEndOfFile(file->file_handle) == 0)
			{
				WLog_ERR(TAG, "Unable to truncate %s to %d (%" PRId32 ")", file->fullpath, size,
				         GetLastError());
				return FALSE;
			}

			break;

		case FileDispositionInformation:

			/* http://msdn.microsoft.com/en-us/library/cc232098.aspx */
			/* http://msdn.microsoft.com/en-us/library/cc241371.aspx */
			if (file->is_dir && !PathIsDirectoryEmptyW(file->fullpath))
				break; /* TODO: SetLastError ??? */

			if (Length)
			{
				if (Stream_GetRemainingLength(input) < 1)
					return FALSE;

				Stream_Read_UINT8(input, delete_pending);
			}
			else
				delete_pending = 1;

			if (delete_pending)
			{
				DEBUG_WSTR("SetDeletePending %s", file->fullpath);
				attr = GetFileAttributesW(file->fullpath);

				if (attr & FILE_ATTRIBUTE_READONLY)
				{
					SetLastError(ERROR_ACCESS_DENIED);
					return FALSE;
				}
			}

			file->delete_pending = delete_pending;
			break;

		case FileRenameInformation:
			if (Stream_GetRemainingLength(input) < 6)
				return FALSE;

			/* http://msdn.microsoft.com/en-us/library/cc232085.aspx */
			Stream_Read_UINT8(input, ReplaceIfExists);
			Stream_Seek_UINT8(input); /* RootDirectory */
			Stream_Read_UINT32(input, FileNameLength);

			if (Stream_GetRemainingLength(input) < FileNameLength)
				return FALSE;

			fullpath = drive_file_combine_fullpath(file->basepath, (WCHAR*)Stream_Pointer(input),
			                                       FileNameLength / sizeof(WCHAR));

			if (!fullpath)
				return FALSE;

#ifdef _WIN32

			if (file->file_handle != INVALID_HANDLE_VALUE)
			{
				CloseHandle(file->file_handle);
				file->file_handle = INVALID_HANDLE_VALUE;
			}

#endif
			DEBUG_WSTR("MoveFileExW %s", file->fullpath);

			if (MoveFileExW(file->fullpath, fullpath,
			                MOVEFILE_COPY_ALLOWED |
			                    (ReplaceIfExists ? MOVEFILE_REPLACE_EXISTING : 0)))
			{
				if (!drive_file_set_fullpath(file, fullpath))
					return FALSE;
			}
			else
			{
				free(fullpath);
				return FALSE;
			}

#ifdef _WIN32
			drive_file_init(file);
#endif
			break;

		default:
			return FALSE;
	}

	return TRUE;
}
