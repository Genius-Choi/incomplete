plinestart(pos)
	POSITION pos;
{
	LINENUM linenum = 0;
	int i;

	if (linenums == OPT_ONPLUS)
	{
		/*
		 * Get the line number and put it in the current line.
		 * {{ Note: since find_linenum calls forw_raw_line,
		 *    it may seek in the input file, requiring the caller 
		 *    of plinestart to re-seek if necessary. }}
		 * {{ Since forw_raw_line modifies linebuf, we must
		 *    do this first, before storing anything in linebuf. }}
		 */
		linenum = find_linenum(pos);
	}

	/*
	 * Display a status column if the -J option is set.
	 */
	if (status_col || status_line)
	{
		char c = posmark(pos);
		if (c != 0)
			line_mark_attr = AT_HILITE|AT_COLOR_MARK;
		else if (start_attnpos != NULL_POSITION &&
		         pos >= start_attnpos && pos <= end_attnpos)
			line_mark_attr = AT_HILITE|AT_COLOR_ATTN;
		if (status_col)
		{
			add_pfx(c ? c : ' ', line_mark_attr); /* column 0: status */
			while (linebuf.pfx_end < status_col_width)
				add_pfx(' ', AT_NORMAL);
		}
	}

	/*
	 * Display the line number at the start of each line
	 * if the -N option is set.
	 */
	if (linenums == OPT_ONPLUS)
	{
		char buf[INT_STRLEN_BOUND(linenum) + 2];
		int len;

		linenum = vlinenum(linenum);
		if (linenum == 0)
			len = 0;
		else
		{
			linenumtoa(linenum, buf);
			len = (int) strlen(buf);
		}
		for (i = 0; i < linenum_width - len; i++)
			add_pfx(' ', AT_NORMAL);
		for (i = 0; i < len; i++)
			add_pfx(buf[i], AT_BOLD|AT_COLOR_LINENUM);
		add_pfx(' ', AT_NORMAL);
	}
	end_column = linebuf.pfx_end;
}
