  void push(int32 a) {
    auto comparator = [this](int32 a, int32 b) { return compare_fun(a, b); };
    if (container_.size() <= k_) {
      container_.push_back(a);
      if (container_.size() == k_ + 1) {
        std::make_heap(container_.begin(), container_.end(), comparator);
        std::pop_heap(container_.begin(), container_.end(), comparator);
      }
    } else if (comparator(a, container_.front())) {
      // Due to how we defined comparator / compare_fun, container_.front()
      // contains the index of the smallest of the top-k elements seen so far.
      //
      // If control reaches this point, we know that the current index a
      // corresponds to an element which is bigger than the smallest of the
      // top-k elements seen so far.  Hence, we have to update the indices of
      // the top-k elements, by removing the index of the smallest top-k
      // element, adding a, and making sure container_[0:k] is still a heap.

      // Store index a into container_[k].
      container_.back() = a;

      // Swap container_[0] and container_[k], and rearrange elements from
      // container_[0,k) such that they are a heap according to comparator.  For
      // more info, see https://en.cppreference.com/w/cpp/algorithm/pop_heap.
      std::pop_heap(container_.begin(), container_.end(), comparator);
    }
  }
