DSCIOManager::dsc_populate_files_vector() {
    
    std::string start_of_search_path;
    switch (input_) {
        case XML: 
            start_of_search_path = "./incoming";
            file_extension_ = ".xml";
            break;
        case DAT:
            start_of_search_path = ".";
            file_extension_ = ".dat";
            break;
        default:
            // Should never get here!
            cerr << "Error: Unknown input source" << endl;
            exit(1);
            break;
    }
    
    bfs::path p_start (start_of_search_path);
    bfs::path::iterator path_it;

    // iterators for iterating over all the paths/files in the data directory
    bfs::recursive_directory_iterator it(p_start), end_it;
    try {
        if (bfs::exists(p_start)) {
            if (bfs::is_directory(p_start)) {
                BOOST_FOREACH( bfs::path const &p_search, make_pair(it, end_it) ) {                 
                    if ( p_search.string().find("done") == string::npos ) {
                        if ( ! bfs::is_directory(p_search) ) {
                            if ( p_search.extension() == file_extension_ ) {
                                if (! exclude_file(p_search, start_of_search_path) ) {
                                        file_vector_.push_back(p_search);                                   
                                }
                            }
                        }
                    }
                }
                sort(file_vector_.begin(), file_vector_.end());
            } else {
                cout << p_start << " exists, but is not a directory\n";
                exit(1);
            }
        } else {
            cout << p_start << " does not exist\n";
            exit(1);
        }
    }
    catch (const bfs::filesystem_error& ex) {
        cout << "FS Error: " << ex.what() << endl;
        exit(1);
    }
    catch (std::exception &e) {
        cerr << "Error creating file vector: " << e.what() << endl;
        exit(1);
    }
    
}
