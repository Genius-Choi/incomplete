int EpollSocket::start_event_loop() {
    int timeout_ms = 200;
    epoll_event *events = new epoll_event[_max_events];
    int ret = 0;

    _status = S_RUN;
    while (_status != S_STOP) {
        int fds_num = epoll_wait(_epollfd, events, _max_events, timeout_ms);
        if (fds_num == -1) {
            if (errno == EINTR) { /*The call was interrupted by a signal handler*/
                continue;
            }
            LOG_ERROR("epoll_wait error:%s", strerror(errno));
            ret = -1;
            break;
        }
        for (int i = 0; i < fds_num; i++) {
            this->handle_event(events[i]);
        }
        clear_idle_clients();

        pthread_mutex_lock(&_client_lock);
        if (_clients == 0 && _status == S_REJECT_CONN) {
            _status = S_STOP;
            LOG_INFO("client is empty and ready for stop server!");
        }
        pthread_mutex_unlock(&_client_lock);
    }
    LOG_INFO("epoll wait loop stop ...");
    if (events != NULL) {
        delete[] events;
        events = NULL;
    }
    return ret;
}
