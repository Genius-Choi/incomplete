int EpollSocket::clear_idle_clients() {
    if (_max_idle_sec <= 0) {
        return 0;
    }
    if (_eclients.empty()) {
        return 0;
    }
    time_t timeout_ts = time(NULL) - _max_idle_sec;

    std::vector<epoll_event> remove_evs;
    pthread_mutex_lock(&_client_lock);
    std::map<long long, EpollContext *>::iterator it = _eclients.begin();
    for (; it != _eclients.end(); it++) {
         //long long id = it->first;
         EpollContext *ctx = it->second;
         if (ctx->_last_interact_time <= timeout_ts && 
                 ctx->_ctx_status != CONTEXT_READING && ctx->_ctx_status != CONTEXT_WRITING) {
             LOG_DEBUG("find idle client fd:%d", ctx->fd);
             epoll_event e;
             memset(&e, 0, sizeof(e));
             e.data.ptr = ctx;
             remove_evs.push_back(e);
         } else {
             LOG_DEBUG("this client is using, skip it!");
         }
    }
    pthread_mutex_unlock(&_client_lock);

    int cnt = 0;
    for (size_t i = 0; i < remove_evs.size(); i++) {
        close_and_release(remove_evs[i]);
        cnt++;
    }
    if (cnt > 0) {
        LOG_INFO("find idle clients cnt:%d", cnt);
    }
    return cnt;
}
