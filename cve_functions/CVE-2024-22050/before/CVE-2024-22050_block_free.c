static inline void block_free(block_s *blk) {
  if (fio_atomic_sub(&blk->ref, 1))
    return;

  memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));
  fio_lock(&memory.lock);
  fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);

  blk = blk->parent;

  if (fio_atomic_sub(&blk->root_ref, 1)) {
    fio_unlock(&memory.lock);
    return;
  }
  // fio_unlock(&memory.lock);
  // return;

  /* remove all of the root block's children (slices) from the memory pool */
  for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {
    block_node_s *pos =
        (block_node_s *)((uintptr_t)blk + (i * FIO_MEMORY_BLOCK_SIZE));
    fio_ls_embd_remove(&pos->node);
  }

  fio_unlock(&memory.lock);
  sys_free(blk, FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION);
  FIO_LOG_DEBUG("memory allocator returned %p to the system", (void *)blk);
  FIO_MEMORY_ON_BLOCK_FREE();
}
