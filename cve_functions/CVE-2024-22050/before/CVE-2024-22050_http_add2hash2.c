int http_add2hash2(FIOBJ dest, char *name, size_t name_len, FIOBJ val,
                   uint8_t encoded) {
  if (!name)
    goto error;
  FIOBJ nested_ary = FIOBJ_INVALID;
  char *cut1;
  /* we can't start with an empty object name */
  while (name_len && name[0] == '[') {
    --name_len;
    ++name;
  }
  if (!name_len) {
    /* an empty name is an error */
    goto error;
  }
  uint32_t nesting = ((uint32_t)~0);
rebase:
  /* test for nesting level limit (limit at 32) */
  if (!nesting)
    goto error;
  /* start clearing away bits. */
  nesting >>= 1;
  /* since we might be rebasing, notice that "name" might be "name]" */
  cut1 = memchr(name, '[', name_len);
  if (!cut1)
    goto place_in_hash;
  /* simple case "name=" (the "=" was already removed) */
  if (cut1 == name) {
    /* an empty name is an error */
    goto error;
  }
  if (cut1 + 1 == name + name_len) {
    /* we have name[= ... autocorrect */
    name_len -= 1;
    goto place_in_array;
  }

  if (cut1[1] == ']') {
    /* Nested Array "name[]..." */

    /* Test for name[]= */
    if ((cut1 + 2) == name + name_len) {
      name_len -= 2;
      goto place_in_array;
    }

    /* Test for a nested Array format error */
    if (cut1[2] != '[' || cut1[3] == ']') { /* error, we can't parse this */
      goto error;
    }

    /* we have name[][key...= */

    /* ensure array exists and it's an array + set nested_ary */
    const size_t len = ((cut1[-1] == ']') ? (size_t)((cut1 - 1) - name)
                                          : (size_t)(cut1 - name));
    const uint64_t hash =
        fiobj_hash_string(name, len); /* hash the current name */
    nested_ary = fiobj_hash_get2(dest, hash);
    if (!nested_ary) {
      /* create a new nested array */
      FIOBJ key =
          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);
      nested_ary = fiobj_ary_new2(4);
      fiobj_hash_set(dest, key, nested_ary);
      fiobj_free(key);
    } else if (!FIOBJ_TYPE_IS(nested_ary, FIOBJ_T_ARRAY)) {
      /* convert existing object to an array - auto error correction */
      FIOBJ key =
          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);
      FIOBJ tmp = fiobj_ary_new2(4);
      fiobj_ary_push(tmp, nested_ary);
      nested_ary = tmp;
      fiobj_hash_set(dest, key, nested_ary);
      fiobj_free(key);
    }

    /* test if last object in the array is a hash - create hash if not */
    dest = fiobj_ary_index(nested_ary, -1);
    if (!dest || !FIOBJ_TYPE_IS(dest, FIOBJ_T_HASH)) {
      dest = fiobj_hash_new();
      fiobj_ary_push(nested_ary, dest);
    }

    /* rebase `name` to `key` and restart. */
    cut1 += 3; /* consume "[][" */
    name_len -= (size_t)(cut1 - name);
    name = cut1;
    goto rebase;

  } else {
    /* we have name[key]... */
    const size_t len = ((cut1[-1] == ']') ? (size_t)((cut1 - 1) - name)
                                          : (size_t)(cut1 - name));
    const uint64_t hash =
        fiobj_hash_string(name, len); /* hash the current name */
    FIOBJ tmp = fiobj_hash_get2(dest, hash);
    if (!tmp) {
      /* hash doesn't exist, create it */
      FIOBJ key =
          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);
      tmp = fiobj_hash_new();
      fiobj_hash_set(dest, key, tmp);
      fiobj_free(key);
    } else if (!FIOBJ_TYPE_IS(tmp, FIOBJ_T_HASH)) {
      /* type error, referencing an existing object that isn't a Hash */
      goto error;
    }
    dest = tmp;
    /* no rollback is possible once we enter the new nesting level... */
    nested_ary = FIOBJ_INVALID;
    /* rebase `name` to `key` and restart. */
    cut1 += 1; /* consume "[" */
    name_len -= (size_t)(cut1 - name);
    name = cut1;
    goto rebase;
  }

place_in_hash:
  if (name[name_len - 1] == ']')
    --name_len;
  {
    FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)
                        : fiobj_str_new(name, name_len);
    FIOBJ old = fiobj_hash_replace(dest, key, val);
    if (old) {
      if (nested_ary) {
        fiobj_hash_replace(dest, key, old);
        old = fiobj_hash_new();
        fiobj_hash_set(old, key, val);
        fiobj_ary_push(nested_ary, old);
      } else {
        if (!FIOBJ_TYPE_IS(old, FIOBJ_T_ARRAY)) {
          FIOBJ tmp = fiobj_ary_new2(4);
          fiobj_ary_push(tmp, old);
          old = tmp;
        }
        fiobj_ary_push(old, val);
        fiobj_hash_replace(dest, key, old);
      }
    }
    fiobj_free(key);
  }
  return 0;

place_in_array:
  if (name[name_len - 1] == ']')
    --name_len;
  {
    uint64_t hash = fiobj_hash_string(name, name_len);
    FIOBJ ary = fiobj_hash_get2(dest, hash);
    if (!ary) {
      FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)
                          : fiobj_str_new(name, name_len);
      ary = fiobj_ary_new2(4);
      fiobj_hash_set(dest, key, ary);
      fiobj_free(key);
    } else if (!FIOBJ_TYPE_IS(ary, FIOBJ_T_ARRAY)) {
      FIOBJ tmp = fiobj_ary_new2(4);
      fiobj_ary_push(tmp, ary);
      ary = tmp;
      FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)
                          : fiobj_str_new(name, name_len);
      fiobj_hash_replace(dest, key, ary);
      fiobj_free(key);
    }
    fiobj_ary_push(ary, val);
  }
  return 0;
error:
  fiobj_free(val);
  errno = EOPNOTSUPP;
  return -1;
}
