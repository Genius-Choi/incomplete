static int http1_http2websocket_client(http_s *h, websocket_settings_s *args) {
  http1pr_s *p = handle2pr(h);
  /* We're done with the HTTP stage, so we call the `on_finish` */
  if (p->p.settings->on_finish)
    p->p.settings->on_finish(p->p.settings);
  /* Copy the Websocket setting arguments to the HTTP settings `udata` */
  p->p.settings->udata = fio_malloc(sizeof(*args));
  ((websocket_settings_s *)(p->p.settings->udata))[0] = *args;
  /* Set callbacks */
  p->p.settings->on_finish = http1_websocket_client_on_hangup;   /* unknown */
  p->p.settings->on_upgrade = http1_websocket_client_on_upgrade; /* sucess */
  p->p.settings->on_response = http1_websocket_client_on_failed; /* failed */
  p->p.settings->on_request = http1_websocket_client_on_failed;  /* failed */
  /* Set headers */
  http_set_header(h, HTTP_HEADER_CONNECTION, fiobj_dup(HTTP_HVALUE_WS_UPGRADE));
  http_set_header(h, HTTP_HEADER_UPGRADE, fiobj_dup(HTTP_HVALUE_WEBSOCKET));
  http_set_header(h, HTTP_HVALUE_WS_SEC_VERSION,
                  fiobj_dup(HTTP_HVALUE_WS_VERSION));

  /* we don't set the Origin header since we're not a browser... should we? */
  // http_set_header(
  //     h, HTTP_HEADER_ORIGIN,
  //     fiobj_dup(fiobj_hash_get2(h->private_data.out_headers,
  //                               fiobj_obj2hash(HTTP_HEADER_HOST))));

  /* create nonce */
  uint64_t key[2]; /* 16 bytes */
  key[0] = (uintptr_t)h ^ (uint64_t)fio_last_tick().tv_sec;
  key[1] = (uintptr_t)args->udata ^ (uint64_t)fio_last_tick().tv_nsec;
  FIOBJ encoded = fiobj_str_buf(26); /* we need 24 really. */
  fio_str_info_s tmp = fiobj_obj2cstr(encoded);
  tmp.len = fio_base64_encode(tmp.data, (char *)key, 16);
  fiobj_str_resize(encoded, tmp.len);
  http_set_header(h, HTTP_HEADER_WS_SEC_CLIENT_KEY, encoded);
  http_finish(h);
  return 0;
}
