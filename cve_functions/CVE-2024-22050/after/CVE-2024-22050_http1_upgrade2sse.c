static int http1_upgrade2sse(http_s *h, http_sse_s *sse) {
  const intptr_t uuid = handle2pr(h)->p.uuid;
  /* send response */
  h->status = 200;
  http_set_header(h, HTTP_HEADER_CONTENT_TYPE, fiobj_dup(HTTP_HVALUE_SSE_MIME));
  http_set_header(h, HTTP_HEADER_CACHE_CONTROL,
                  fiobj_dup(HTTP_HVALUE_NO_CACHE));
  http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,
                  fiobj_str_new("identity", 8));
  handle2pr(h)->stop = 1;
  htt1p_finish(h); /* avoid the enforced content length in http_finish */

  /* switch protocol to SSE */
  http1_sse_fio_protocol_s *sse_pr = fio_malloc(sizeof(*sse_pr));
  if (!sse_pr)
    goto failed;
  *sse_pr = (http1_sse_fio_protocol_s){
      .p =
          {
              .on_ready = http1_sse_on_ready,
              .on_shutdown = http1_sse_on_shutdown,
              .on_close = http1_sse_on_close,
              .ping = http1_sse_ping,
          },
      .sse = fio_malloc(sizeof(*(sse_pr->sse))),
  };

  if (!sse_pr->sse)
    goto failed;

  http_sse_init(sse_pr->sse, uuid, &HTTP1_VTABLE, sse);
  fio_timeout_set(uuid, handle2pr(h)->p.settings->ws_timeout);
  if (sse->on_open)
    sse->on_open(&sse_pr->sse->sse);
  fio_attach(uuid, &sse_pr->p);
  return 0;

failed:
  fio_close(handle2pr(h)->p.uuid);
  if (sse->on_close)
    sse->on_close(sse);
  return -1;
  (void)sse;
}
