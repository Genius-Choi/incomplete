static inline block_s *block_new(void) {
  block_s *blk = NULL;

  fio_lock(&memory.lock);
  blk = (block_s *)fio_ls_embd_pop(&memory.available);
  if (blk) {
    blk = (block_s *)FIO_LS_EMBD_OBJ(block_node_s, node, blk);
    FIO_ASSERT(((uintptr_t)blk & FIO_MEMORY_BLOCK_MASK) == 0,
               "Memory allocator error! double `fio_free`?\n");
    block_init(blk); /* must be performed within lock */
    fio_unlock(&memory.lock);
    return blk;
  }
  /* collect memory from the system */
  blk = sys_alloc(FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION, 0);
  if (!blk) {
    fio_unlock(&memory.lock);
    return NULL;
  }
  FIO_LOG_DEBUG("memory allocator allocated %p from the system", (void *)blk);
  FIO_MEMORY_ON_BLOCK_ALLOC();
  block_init_root(blk, blk);
  /* the extra memory goes into the memory pool. initialize + linke-list. */
  block_node_s *tmp = (block_node_s *)blk;
  for (int i = 1; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {
    tmp = (block_node_s *)((uintptr_t)tmp + FIO_MEMORY_BLOCK_SIZE);
    block_init_root((block_s *)tmp, blk);
    fio_ls_embd_push(&memory.available, &tmp->node);
  }
  fio_unlock(&memory.lock);
  /* return the root block (which isn't in the memory pool). */
  return blk;
}
