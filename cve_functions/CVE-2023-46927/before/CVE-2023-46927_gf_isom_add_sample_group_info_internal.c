GF_Err gf_isom_add_sample_group_info_internal(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, u32 sgpd_flags, u32 *sampleGroupDescriptionIndex, Bool *is_traf_sgpd, Bool check_access, Bool *use_default, GF_SampleGroupDescriptionBox **out_sgdesc)
{
	GF_Err e;
	GF_TrackBox *trak=NULL;
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
	GF_TrackFragmentBox *traf=NULL;
#else
	void *traf=NULL;
#endif
	u32 trafID=0;
	GF_DefaultSampleGroupDescriptionEntry *entry=NULL;
	GF_SampleGroupDescriptionBox *sgdesc = NULL;
	Bool is_default = sgpd_flags & 0x80000000;

	if (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;

	if (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) {
		trak = gf_isom_get_track_from_file(movie, track);
		if (!trak) return GF_BAD_PARAM;
		trafID = trak->Header->trackID;
	}

	if (trafID) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
		if (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )
			return GF_BAD_PARAM;

		traf = gf_isom_get_traf(movie, trafID);
#else
		return GF_NOT_SUPPORTED;
#endif
	} else {
		if (check_access) {
			e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);
			if (e) return e;
		}

		trak = gf_isom_get_track_from_file(movie, track);
	}
	if (!trak) return GF_BAD_PARAM;

	//get sample group desc for this grouping type
	sgdesc = get_sgdp(trak->Media->information->sampleTable, traf, grouping_type, is_traf_sgpd);
	if (!sgdesc) return GF_OUT_OF_MEM;
	//first time we create the sample group description, set flags
	if (!gf_list_count(sgdesc->group_descriptions) && !traf) {
		if (sgpd_flags&1) sgdesc->flags |= 1;
		if (sgpd_flags&2) sgdesc->flags |= 2;
		if (sgpd_flags&0x40000000) sgdesc->version=3;
	}


	GF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
	u32 bytes;
	entry = sgpd_parse_entry(sgdesc, bs, data_size, data_size, &bytes);
	gf_bs_del(bs);
	if (!entry) return GF_NON_COMPLIANT_BITSTREAM;

	if (out_sgdesc) *out_sgdesc = sgdesc;


	//find the same entry
	u32 k;
	for (k=0; k<gf_list_count(sgdesc->group_descriptions); k++) {
		void *sgde_dst = gf_list_get(sgdesc->group_descriptions, k);
		if (gf_isom_is_identical_sgpd(entry, sgde_dst, sgdesc->grouping_type)) {
			if (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = k+1;
			sgpd_del_entry(sgdesc->grouping_type, entry);
			if (use_default) {
				u32 idx = k+1;
				if (is_traf_sgpd && *is_traf_sgpd) idx |= 0x10000;
				*use_default = (sgdesc->default_description_index==idx) ? GF_TRUE : GF_FALSE;
			}
			return GF_OK;
		}
	}

	if (traf && ! *is_traf_sgpd) {
		sgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);
		if (!sgdesc) return GF_OUT_OF_MEM;
	}
	if (out_sgdesc) *out_sgdesc = sgdesc;

	e = gf_list_add(sgdesc->group_descriptions, entry);
	if (e) {
		sgpd_del_entry(sgdesc->grouping_type, entry);
		return e;
	}

#if 0
	if (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {
		GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();
		GF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);
		e = gf_isom_oinf_read_entry(ptr, bs);
		gf_bs_del(bs);
		if (e) {
			gf_isom_oinf_del_entry(ptr);
			return e;
		}
		//not in track, create new sgdp
		if (traf && ! *is_traf_sgpd) {
			sgdesc  = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);
			if (!sgdesc) return GF_OUT_OF_MEM;
		}
		e = gf_list_add(sgdesc->group_descriptions, ptr);
		if (e) return e;
		entry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;
	} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {
		GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
		GF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);
		e = gf_isom_linf_read_entry(ptr, bs);
		gf_bs_del(bs);
		if (e) {
			gf_isom_linf_del_entry(ptr);
			return e;
		}

		if (traf && ! *is_traf_sgpd) {
			sgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);
			if (!sgdesc) return GF_OUT_OF_MEM;
		}

		e = gf_list_add(sgdesc->group_descriptions, ptr);
		if (e) return e;
		entry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;
	} else {
		u32 i, count=gf_list_count(sgdesc->group_descriptions);
		for (i=0; i<count; i++) {
			GF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);
			if ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {
				entry = ent;
				break;
			}
			entry=NULL;
		}
		if (!entry) {
			GF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);
			if (!entry) return GF_OUT_OF_MEM;
			entry->data = (u8*)gf_malloc(sizeof(char) * data_size);
			if (!entry->data) {
				gf_free(entry);
				return GF_OUT_OF_MEM;
			}
			entry->length = data_size;
			memcpy(entry->data, data, sizeof(char) * data_size);

			if (traf && ! *is_traf_sgpd) {
				sgdesc = get_sgdp(NULL, traf, grouping_type, is_traf_sgpd);
				if (!sgdesc) return GF_OUT_OF_MEM;
			}

			e = gf_list_add(sgdesc->group_descriptions, entry);
			if (e) {
				gf_free(entry->data);
				gf_free(entry);
				return e;
			}
		}
	}
#endif


	if (is_default && !sgdesc->default_description_index) {
		sgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);
		if (sgdesc->version < 2) sgdesc->version = 2;
		if (is_traf_sgpd && *is_traf_sgpd) {
			sgdesc->default_description_index |= 0x10000;
		}
	}
	u32 grp_idx =  1 + gf_list_find(sgdesc->group_descriptions, entry);
	if (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = grp_idx;
	if (use_default) {
		if (*is_traf_sgpd)
			grp_idx |= 0x10000;
		*use_default = (sgdesc->default_description_index==grp_idx) ? GF_TRUE : GF_FALSE;
	}
	return GF_OK;
}
