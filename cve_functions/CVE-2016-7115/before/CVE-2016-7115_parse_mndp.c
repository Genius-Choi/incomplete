struct mt_mndp_info *parse_mndp(const unsigned char *data, const int packet_len) {
	const unsigned char *p;
	static struct mt_mndp_info packet;
	struct mt_mndp_info *packetp = &packet;
	struct mt_mndp_hdr *mndp_hdr;

	/* Check for valid packet length */
	if (packet_len < 18) {
		return NULL;
	}

	bzero(packetp, sizeof(*packetp));

	mndp_hdr = (struct mt_mndp_hdr*)data;

	memcpy(&packetp->header, mndp_hdr, sizeof(struct mt_mndp_hdr));

	p = data + sizeof(struct mt_mndp_hdr);

	while(p + 4 < data + packet_len) {
		unsigned short type, len;

		memcpy(&type, p, 2);
		memcpy(&len, p + 2, 2);

		type = ntohs(type);
		len = ntohs(len);

		p += 4;

		/* Check if len is invalid */
		if (p + len > data + packet_len) {
		        fprintf(stderr, "%s: invalid data: "
				        "%p + %u > %p + %d\n",
					__func__, p, len, data, packet_len);
			break;
		}

		switch (type) {
			case MT_MNDPTYPE_ADDRESS:
				if (len >= ETH_ALEN) {
					memcpy(packetp->address, p, ETH_ALEN);
				}
				break;

			case MT_MNDPTYPE_IDENTITY:
				if (len >= MT_MNDP_MAX_STRING_SIZE) {
					len = MT_MNDP_MAX_STRING_SIZE - 1;
				}

				memcpy(packetp->identity, p, len);
				packetp->identity[len] = '\0';
				break;

			case MT_MNDPTYPE_PLATFORM:
				if (len >= MT_MNDP_MAX_STRING_SIZE) {
					len = MT_MNDP_MAX_STRING_SIZE - 1;
				}

				memcpy(packetp->platform, p, len);
				packetp->platform[len] = '\0';
				break;

			case MT_MNDPTYPE_VERSION:
				if (len >= MT_MNDP_MAX_STRING_SIZE) {
					len = MT_MNDP_MAX_STRING_SIZE - 1;
				}

				memcpy(packetp->version, p, len);
				packetp->version[len] = '\0';
				break;

			case MT_MNDPTYPE_TIMESTAMP:
				if (len >= 4) {
					memcpy(&packetp->uptime, p, 4);
					/* Seems like ping uptime is transmitted as little endian? */
					packetp->uptime = le32toh(packetp->uptime);
				}
				break;

			case MT_MNDPTYPE_HARDWARE:
				if (len >= MT_MNDP_MAX_STRING_SIZE) {
					len = MT_MNDP_MAX_STRING_SIZE - 1;
				}

				memcpy(packetp->hardware, p, len);
				packetp->hardware[len] = '\0';
				break;

			case MT_MNDPTYPE_SOFTID:
				if (len >= MT_MNDP_MAX_STRING_SIZE) {
					len = MT_MNDP_MAX_STRING_SIZE - 1;
				}

				memcpy(packetp->softid, p, len);
				packetp->softid[len] = '\0';
				break;

			case MT_MNDPTYPE_IFNAME:
				if (len >= MT_MNDP_MAX_STRING_SIZE) {
					len = MT_MNDP_MAX_STRING_SIZE - 1;
				}

				memcpy(packetp->ifname, p, len);
				packetp->ifname[len] = '\0';
				break;

			/*default:
				 Unhandled MNDP type
			*/
		}

		p += len;
	}

	return packetp;
}
