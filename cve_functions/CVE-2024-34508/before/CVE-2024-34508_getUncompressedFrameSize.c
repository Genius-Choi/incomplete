OFCondition DcmElement::getUncompressedFrameSize(DcmItem *dataset,
                                                 Uint32 &frameSize,
                                                 OFBool pixelDataIsUncompressed) const
{
    OFCondition result = EC_IllegalParameter;
    if (dataset != NULL)
    {
        Uint16 rows = 0;
        Uint16 cols = 0;
        Uint16 samplesPerPixel = 0;
        Uint16 bitsAllocated = 0;
        Sint32 numberOfFrames = 1;
        OFString photometricInterpretation;

        /* retrieve number of frames from dataset (may be absent) */
        (void) dataset->findAndGetSint32(DCM_NumberOfFrames, numberOfFrames);
        if (numberOfFrames < 1) numberOfFrames = 1;

        /* retrieve further values from dataset (and check them for validity and plausibility) */
        GET_AND_CHECK_UINT16_VALUE(DCM_Columns, cols)
        else if (cols == 0)
            DCMDATA_WARN("DcmElement: Dubious value (" << cols << ") for element Columns " << DCM_Columns);
        if (result.good())
        {
            GET_AND_CHECK_UINT16_VALUE(DCM_Rows, rows)
            else if (rows == 0)
                DCMDATA_WARN("DcmElement: Dubious value (" << rows << ") for element Rows " << DCM_Rows);
        }
        if (result.good())
        {
            GET_AND_CHECK_UINT16_VALUE(DCM_SamplesPerPixel, samplesPerPixel)
            else /* result.good() */
            {
                /* also need to check value of PhotometricInterpretation */
                if (dataset->findAndGetOFStringArray(DCM_PhotometricInterpretation, photometricInterpretation).good())
                {
                    if (photometricInterpretation.empty())
                        DCMDATA_WARN("DcmElement: No value for mandatory element PhotometricInterpretation " << DCM_PhotometricInterpretation);
                    else {
                        const OFBool isMono =   (photometricInterpretation == "MONOCHROME1") ||
                                                (photometricInterpretation == "MONOCHROME2");
                        const OFBool isColor1 = (photometricInterpretation == "PALETTE COLOR");
                        const OFBool isColor3 = (photometricInterpretation == "RGB") ||
                                                (photometricInterpretation == "HSV" /* retired */) ||
                                                (photometricInterpretation == "YBR_FULL") ||
                                                (photometricInterpretation == "YBR_FULL_422") ||
                                                (photometricInterpretation == "YBR_PARTIAL_422" /* retired */) ||
                                                (photometricInterpretation == "YBR_PARTIAL_420") ||
                                                (photometricInterpretation == "YBR_ICT") ||
                                                (photometricInterpretation == "YBR_RCT");
                        const OFBool isColor4 = (photometricInterpretation == "ARGB" /* retired */) ||
                                                (photometricInterpretation == "CMYK" /* retired */);
                        if (((isMono || isColor1) && (samplesPerPixel != 1)) || (isColor3 && (samplesPerPixel != 3)) || (isColor4 && (samplesPerPixel != 4)))

                        {
                            DCMDATA_WARN("DcmElement: Invalid value (" << samplesPerPixel << ") for element SamplesPerPixel " << DCM_SamplesPerPixel
                                << " when PhotometricInterpretation " << DCM_PhotometricInterpretation << " is " << photometricInterpretation);
                            result = EC_InvalidValue;
                        }
                        else if (!isMono && !isColor1 && !isColor3 && !isColor4)
                            DCMDATA_WARN("DcmElement: Unsupported value (" << photometricInterpretation << ") for element PhotometricInterpretation " << DCM_PhotometricInterpretation);
                    }
                }
                if (result.good() && (samplesPerPixel != 1) && (samplesPerPixel != 3))
                    DCMDATA_WARN("DcmElement: Dubious value (" << samplesPerPixel << ") for element SamplesPerPixel " << DCM_SamplesPerPixel);
            }
        }
        if (result.good())
        {
            GET_AND_CHECK_UINT16_VALUE(DCM_BitsAllocated, bitsAllocated)
            /* see PS3.3 Table C.7-11c: "Bits Allocated (0028,0100) shall be either 1, or a multiple of 8." */
            else if ((bitsAllocated == 0) || ((bitsAllocated > 1) && (bitsAllocated % 8 != 0)))
                DCMDATA_WARN("DcmElement: Dubious value (" << bitsAllocated << ") for element BitsAllocated " << DCM_BitsAllocated);
        }
        /* if all checks were passed... */
        if (result.good())
        {
            if (pixelDataIsUncompressed && (photometricInterpretation == "YBR_FULL_422"))
            {
              /* YBR_FULL_422 can exist in uncompressed format, but in many cases
               * images claiming to be YBR_FULL_422 are in fact formerly compressed
               * images in YBR_FULL color model where the decoder has failed to update
               * the photometric interpretation. We can keep these apart by checking
               * the size of the pixel data and the number of frames.
               */
               Uint32 pixelLen = 0;
               DcmElement *pixData = NULL;
               result = dataset->findAndGetElement(DCM_PixelData, pixData);
               if (result.good() && pixData && ((pixelLen = pixData->getLength()) > 0))
               {
                  const Uint32 v1 = rows * cols * 3;
                  const Uint32 v2 = (bitsAllocated / 8) * v1;
                  const Uint32 v3 = ((bitsAllocated % 8) * v1 + 7) / 8;

                  if (pixelLen >= (v2 + v3) * numberOfFrames)
                  {
                     /* the size of the pixel data indicates that no subsampling is present. We assume YBR_FULL. */
                     DCMDATA_WARN("DcmElement: PhotometricInterpretation probably incorrect, assuming YBR_FULL instead of YBR_FULL_422");
                  }
                  else
                  {
                     /* the size of the pixel data indicates subsampling is present. We assume YBR_FULL_422,
                      * which means that the frame size can be computed by setting samplesPerPixel to 2.
                      */
                     samplesPerPixel = 2;
                  }
               }
               else
                   DCMDATA_WARN("DcmElement: failed to compute size of PixelData element");
            }

            /* compute frame size (TODO: check for 32-bit integer overflow?) */
            if ((bitsAllocated % 8) == 0)
            {
                const Uint16 bytesAllocated = bitsAllocated / 8;
                frameSize = bytesAllocated * rows * cols * samplesPerPixel;
            }
            else
            {
                /* need to split calculation in order to avoid integer overflow for large pixel data */
                const Uint32 v1 = rows * cols * samplesPerPixel;
                const Uint32 v2 = (bitsAllocated / 8) * v1;
                const Uint32 v3 = ((bitsAllocated % 8) * v1 + 7) / 8;
            //  # old code: frameSize = (bitsAllocated * rows * cols * samplesPerPixel + 7) / 8;
                frameSize = v2 + v3;
            }
        } else {
            /* in case of error, return a frame size of 0 */
            frameSize = 0;
        }
    }
    return result;
}
