        auto newInfoFromCA = [&](const DerivationOutput::CAFloating outputHash) -> ValidPathInfo {
            auto st = get(outputStats, outputName);
            if (!st)
                throw BuildError(
                    "output path %1% without valid stats info",
                    actualPath);
            if (outputHash.method.getFileIngestionMethod() == FileIngestionMethod::Flat)
            {
                /* The output path should be a regular file without execute permission. */
                if (!S_ISREG(st->st_mode) || (st->st_mode & S_IXUSR) != 0)
                    throw BuildError(
                        "output path '%1%' should be a non-executable regular file "
                        "since recursive hashing is not enabled (one of outputHashMode={flat,text} is true)",
                        actualPath);
            }
            rewriteOutput(outputRewrites);
            /* FIXME optimize and deduplicate with addToStore */
            std::string oldHashPart { scratchPath->hashPart() };
            auto got = ({
                HashModuloSink caSink { outputHash.hashAlgo, oldHashPart };
                PosixSourceAccessor accessor;
                dumpPath(
                    accessor, CanonPath { actualPath },
                    caSink,
                    outputHash.method.getFileIngestionMethod());
                caSink.finish().first;
            });

            ValidPathInfo newInfo0 {
                worker.store,
                outputPathName(drv->name, outputName),
                ContentAddressWithReferences::fromParts(
                    outputHash.method,
                    std::move(got),
                    rewriteRefs()),
                Hash::dummy,
            };
            if (*scratchPath != newInfo0.path) {
                // If the path has some self-references, we need to rewrite
                // them.
                // (note that this doesn't invalidate the ca hash we calculated
                // above because it's computed *modulo the self-references*, so
                // it already takes this rewrite into account).
                rewriteOutput(
                    StringMap{{oldHashPart,
                               std::string(newInfo0.path.hashPart())}});
            }

            {
                PosixSourceAccessor accessor;
                HashResult narHashAndSize = hashPath(
                    accessor, CanonPath { actualPath },
                    FileIngestionMethod::Recursive, HashAlgorithm::SHA256);
                newInfo0.narHash = narHashAndSize.first;
                newInfo0.narSize = narHashAndSize.second;
            }

            assert(newInfo0.ca);
            return newInfo0;
        };
