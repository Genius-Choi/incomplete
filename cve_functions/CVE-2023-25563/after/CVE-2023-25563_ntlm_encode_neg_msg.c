int ntlm_encode_neg_msg(struct ntlm_ctx *ctx, uint32_t flags,
                        const char *domain, const char *workstation,
                        struct ntlm_buffer *message)
{
    struct wire_neg_msg *msg;
    struct ntlm_buffer buffer;
    size_t data_offs;
    size_t dom_len = 0;
    size_t wks_len = 0;
    int ret = 0;

    if (!ctx) return EINVAL;

    buffer.length = sizeof(struct wire_neg_msg);

    /* Strings MUST use OEM charset in negotiate message */
    if (flags & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED) {
        if (!domain) return EINVAL;
        dom_len = strlen(domain);
        buffer.length += dom_len;
    }
    if (flags & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) {
        if (!workstation) return EINVAL;
        wks_len = strlen(workstation);
        buffer.length += wks_len;
    }

    buffer.data = calloc(1, buffer.length);
    if (!buffer.data) return ENOMEM;

    msg = (struct wire_neg_msg *)buffer.data;
    data_offs = (char *)msg->payload - (char *)msg;

    ntlm_encode_header(&msg->header, NEGOTIATE_MESSAGE);

    msg->neg_flags = htole32(flags);

    if (dom_len) {
        ret = ntlm_encode_oem_str(&msg->domain_name, &buffer,
                                  &data_offs, domain, dom_len);
        if (ret) goto done;
    }

    if (wks_len) {
        ret = ntlm_encode_oem_str(&msg->workstation_name, &buffer,
                                  &data_offs, workstation, wks_len);
        if (ret) goto done;
    }

    if (flags & NTLMSSP_NEGOTIATE_VERSION) {
        ret = ntlm_encode_version(ctx, &buffer,
                                  (char *)&msg->version - (char *)msg);
        if (ret) goto done;
    }

done:
    if (ret) {
        safefree(buffer.data);
    } else {
        *message = buffer;
    }
    return ret;
}
