static int read_headers(void *obj)
{
	struct header_data *data = obj;
	size_t len = !ast_strlen_zero(data->header_name) ? strlen(data->header_name) : 0;
	pjsip_hdr *hdr = NULL;
	char *pj_hdr_string;
	int pj_hdr_string_len;
	char *p;
	char *pos;
	size_t plen, wlen = 0;
	struct hdr_list_entry *le;
	struct hdr_list *list;

	RAII_VAR(struct ast_datastore *, datastore,
			 ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),
			 ao2_cleanup);

	if (!datastore || !datastore->data) {
		ast_debug(1, "There was no datastore from which to read headers.\n");
		return -1;
	}

	list = datastore->data;
	pj_hdr_string = ast_alloca(data->len);
	AST_LIST_TRAVERSE(list, le, nextptr) {
		if (!len || pj_strnicmp2(&le->hdr->name, data->header_name, len) == 0) {
			/* Found matched header, append to buf */
			hdr = le->hdr;

			pj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);
			if (pj_hdr_string_len == -1) {
				ast_log(AST_LOG_ERROR,
					"Not enough buffer space in pjsip_hdr_print_on\n");
				return -1;
			}
			pj_hdr_string[pj_hdr_string_len] = '\0';
			p = strchr(pj_hdr_string, ':');
			if (!p) {
				ast_log(AST_LOG_WARNING,
					"A malformed header was returned from pjsip_hdr_print_on\n");
				continue;
			}

			pj_hdr_string[p - pj_hdr_string] = '\0';
			p = ast_strip(pj_hdr_string);
			plen = strlen(p);
			if (wlen + plen + 1 > data->len) {
				ast_log(AST_LOG_ERROR,
						"Buffer isn't big enough to hold header value.  %zu > %zu\n", plen + 1,
						data->len);
				return -1;
			}
			pos = strstr(data->buf, p);
			if (pos && pos[1] == ',') {
				if (pos == data->buf) {
					continue;
				} else if (pos[-1] == ',') {
					continue;
				}
			}
			ast_copy_string(data->buf + wlen, p, data->len - wlen);
			wlen += plen;
			ast_copy_string(data->buf + wlen, ",", data->len - wlen);
			wlen++;
		}
	}

	if (wlen == 0) {
		if (!len) {
			/* No headers at all on this channel */
			return 0;
		} else {
			ast_debug(1, "There was no header beginning with %s.\n", data->header_name);
			return -1;
		}
	} else {
		data->buf[wlen-1] = '\0';
	}
	return 0;
}
