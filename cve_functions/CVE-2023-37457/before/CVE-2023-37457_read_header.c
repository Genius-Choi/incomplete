static int read_header(void *obj)
{
	struct header_data *data = obj;
	size_t len = strlen(data->header_name);
	pjsip_hdr *hdr = NULL;
	char *pj_hdr_string;
	int pj_hdr_string_len;
	char *p;
	size_t plen;
	struct hdr_list_entry *le;
	struct hdr_list *list;
	int i = 1;
	RAII_VAR(struct ast_datastore *, datastore,
			 ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),
			 ao2_cleanup);

	if (!datastore || !datastore->data) {
		ast_debug(1, "There was no datastore from which to read headers.\n");
		return -1;
	}

	list = datastore->data;
	AST_LIST_TRAVERSE(list, le, nextptr) {
		if (data->header_name[len - 1] == '*') {
			if (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0 && i++ == data->header_number) {
				hdr = le->hdr;
				break;
			}
		} else {
			if (pj_stricmp2(&le->hdr->name, data->header_name) == 0 && i++ == data->header_number) {
				hdr = le->hdr;
				break;
			}
		}
	}

	if (!hdr) {
		ast_debug(1, "There was no header named %s.\n", data->header_name);
		return -1;
	}

	pj_hdr_string = ast_alloca(data->len);
	pj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);
	if (pj_hdr_string_len == -1) {
		ast_log(AST_LOG_ERROR,
			"Not enough buffer space in pjsip_hdr_print_on\n");
		return -1;
	}

	pj_hdr_string[pj_hdr_string_len] = '\0';

	p = strchr(pj_hdr_string, ':');
	if (!p) {
		ast_log(AST_LOG_ERROR,
				"A malformed header was returned from pjsip_hdr_print_on.\n");
		return -1;
	}

	++p;
	p = ast_strip(p);
	plen = strlen(p);
	if (plen + 1 > data->len) {
		ast_log(AST_LOG_ERROR,
				"Buffer isn't big enough to hold header value.  %zu > %zu\n", plen + 1,
				data->len);
		return -1;
	}

	ast_copy_string(data->buf, p, data->len);

	return 0;
}
