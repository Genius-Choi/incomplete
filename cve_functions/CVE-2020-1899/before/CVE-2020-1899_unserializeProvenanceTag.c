arrprov::Tag VariableUnserializer::unserializeProvenanceTag() {
  auto const finish = [&] (auto tag) -> arrprov::Tag {
    if (!RuntimeOption::EvalArrayProvenance) return {};
    return tag;
  };

  auto const read_filename = [&]() -> const StringData* {
    if (peek() == 't') {
      assertx(m_unitFilename);
      expectChar('t');
      return m_unitFilename;
    } else {
      expectChar('s');
      expectChar(':');
      return makeStaticString(unserializeString().get());
    }
  };

  if (type() != VariableUnserializer::Type::Internal) return {};
  if (peek() == 'p') {
    expectChar('p');
    expectChar(':');
    expectChar('i');
    expectChar(':');
    auto const line = static_cast<int>(readInt());
    expectChar(';');
    auto const filename = read_filename();
    expectChar(';');
    return finish(
      arrprov::Tag { filename, line }
    );
  } else if (peek() == 'P') {
    expectChar('P');
    expectChar(';');
    return finish(
      arrprov::Tag::RepoUnion()
    );
  } else if (peek() == 'r') {
    expectChar('r');
    expectChar(':');
    auto const filename = read_filename();
    expectChar(';');
    return finish(
      arrprov::Tag::TraitMerge(filename)
    );
  } else if (peek() == 'e') {
    expectChar('e');
    expectChar(':');
    auto const filename = read_filename();
    expectChar(';');
    return finish(
      arrprov::Tag::LargeEnum(filename)
    );
  } else {
    return {};
  }
}
