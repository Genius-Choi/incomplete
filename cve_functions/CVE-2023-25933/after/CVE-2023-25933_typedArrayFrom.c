typedArrayFrom(void *, Runtime &runtime, NativeArgs args) {
  auto source = args.getArgHandle(0);
  CallResult<bool> isConstructorRes = isConstructor(runtime, args.getThisArg());
  if (LLVM_UNLIKELY(isConstructorRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  // 1. Let C be the this value.
  if (!*isConstructorRes) {
    // 2. If IsConstructor(C) is false, throw a TypeError exception.
    return runtime.raiseTypeError(
        "Cannot invoke when the this is not a constructor");
  }
  auto C = Handle<Callable>::vmcast(runtime, args.getThisArg());
  // 3. If mapfn was supplied and mapfn is not undefined, then
  auto mapfn = Handle<Callable>::dyn_vmcast(args.getArgHandle(1));
  if (!mapfn) {
    // a. If IsCallable(mapfn) is false, throw a TypeError exception.
    if (args.getArgCount() >= 2 && !vmisa<Callable>(args.getArg(1))) {
      return runtime.raiseTypeError(
          "Second argument to TypedArray.from must be callable");
    }
    // b. Let mapping be true
  }
  // 4. Else, let mapping be false. (mapfn can act as a bool for mapping).
  // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
  auto T = args.getArgCount() >= 3 ? args.getArgHandle(2)
                                   : Runtime::getUndefinedValue();
  // 6. Let arrayLike be ? IterableToArrayLike(source).
  auto objRes = iterableToArrayLike(runtime, source);
  if (objRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto arrayLike = runtime.makeHandle<JSObject>(objRes.getValue());
  // 7. Let len be ? ToLength(? Get(arrayLike, "length")).
  auto propRes = JSObject::getNamed_RJS(
      arrayLike, runtime, Predefined::getSymbolID(Predefined::length));
  if (propRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto intRes = toLength(runtime, runtime.makeHandle(std::move(*propRes)));
  if (intRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  uint64_t len = intRes.getValue().getNumberAs<uint64_t>();
  // 8. Let targetObj be ? TypedArrayCreate(C, len).
  auto targetObj = typedArrayCreate(runtime, C, len);
  if (targetObj == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  // 9. Let k be 0.
  MutableHandle<> k(runtime, HermesValue::encodeNumberValue(0));
  // 10. Repeat, while k < len.
  for (; k->getNumberAs<uint64_t>() < len;
       k = HermesValue::encodeNumberValue(k->getNumberAs<uint64_t>() + 1)) {
    GCScopeMarkerRAII marker{runtime};
    // a - b. Get the value of the property at k.
    if ((propRes = JSObject::getComputed_RJS(arrayLike, runtime, k)) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    // c. If mapping is true, then
    if (mapfn) {
      // i. Let mappedValue be ? Call(mapfn, T, [kValue, k]).
      auto callRes = Callable::executeCall2(
          mapfn, runtime, T, propRes->get(), k.getHermesValue());
      if (callRes == ExecutionStatus::EXCEPTION) {
        return ExecutionStatus::EXCEPTION;
      }
      propRes = std::move(callRes);
    }
    // NOTE: The returned value is either the same as the getComputed call, or
    // the call to the mapfn, so either way it is the correct value.
    // d. Else, let mappedValue be kValue (already done by initializer).
    auto mappedValue = runtime.makeHandle(std::move(*propRes));
    // e. Perform ? Set(targetObj, Pk, mappedValue, true).
    if (JSObject::putComputed_RJS(*targetObj, runtime, k, mappedValue) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    // f. Increase k by 1. (In the loop increment).
  }
  // 11. Return targetObj.
  return targetObj->getHermesValue();
}
