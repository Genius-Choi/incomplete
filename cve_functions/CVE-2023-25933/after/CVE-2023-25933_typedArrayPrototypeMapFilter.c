typedArrayPrototypeMapFilter(void *ctx, Runtime &runtime, NativeArgs args) {
  GCScope gcScope{runtime};

  // Whether this call is "map" or "filter".
  bool map = static_cast<bool>(ctx);
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  JSTypedArrayBase::size_type len = self->getLength();
  auto callbackfn = args.dyncastArg<Callable>(0);
  if (!callbackfn) {
    return runtime.raiseTypeError("callbackfn must be a Callable");
  }
  auto thisArg = args.getArgHandle(1);
  // Can't use a vector since this could store an unbounded number of handles.
  auto arrRes = JSArray::create(runtime, len, 0);
  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto values = *arrRes;
  JSTypedArrayBase::size_type insert = 0;
  CallResult<HermesValue> res{ExecutionStatus::EXCEPTION};
  if (map) {
    if ((res = mapFilterLoop<true>(
             runtime, self, callbackfn, thisArg, values, insert, len)) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
  } else {
    if ((res = mapFilterLoop<false>(
             runtime, self, callbackfn, thisArg, values, insert, len)) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
  }
  insert = res->getNumberAs<JSTypedArrayBase::size_type>();
  // Now create a new TypedArray of the same kind and fill it with the values.
  auto result = JSTypedArrayBase::allocateSpecies(runtime, self, insert);
  if (result == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto TA = result.getValue();
  MutableHandle<> storage(runtime);
  auto marker = gcScope.createMarker();
  for (JSTypedArrayBase::size_type i = 0; i < insert; ++i) {
    storage = values->at(runtime, i).unboxToHV(runtime);
    if (JSObject::setOwnIndexed(TA, runtime, i, storage) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    gcScope.flushToMarker(marker);
  }
  return TA.getHermesValue();
}
