typedArrayPrototypeForEach(void *, Runtime &runtime, NativeArgs args) {
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  auto len = self->getLength();
  auto callbackfn = args.dyncastArg<Callable>(0);
  if (!callbackfn) {
    return runtime.raiseTypeError("callbackfn must be a Callable");
  }
  auto thisArg = args.getArgHandle(1);
  GCScope gcScope(runtime);
  auto marker = gcScope.createMarker();
  for (JSTypedArrayBase::size_type i = 0; i < len; ++i) {
    // The callback function can detach the TypedArray.
    if (!self->attached(runtime)) {
      return runtime.raiseTypeError("Detached the ArrayBuffer in the callback");
    }
    HermesValue val =
        JSObject::getOwnIndexed(createPseudoHandle(self.get()), runtime, i);
    if (Callable::executeCall3(
            callbackfn,
            runtime,
            thisArg,
            val,
            HermesValue::encodeNumberValue(i),
            self.getHermesValue()) == ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    gcScope.flushToMarker(marker);
  }
  return HermesValue::encodeUndefinedValue();
}
