typedArrayPrototypeSort(void *, Runtime &runtime, NativeArgs args) {
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  const JSTypedArrayBase::size_type len = self->getLength();

  // Null if not a callable compareFn.
  auto compareFn = Handle<Callable>::dyn_vmcast(args.getArgHandle(0));
  if (!args.getArg(0).isUndefined() && !compareFn) {
    return runtime.raiseTypeError("TypedArray sort argument must be callable");
  }

  // Use our custom sort routine. We can't use std::sort because it performs
  // optimizations that allow it to bypass calls to std::swap, but our swap
  // function is special, since it needs to use the internal Object functions.
  if (compareFn) {
    TypedArraySortModel<true> sm(runtime, self, compareFn);
    if (LLVM_UNLIKELY(quickSort(&sm, 0, len) == ExecutionStatus::EXCEPTION))
      return ExecutionStatus::EXCEPTION;
  } else {
    TypedArraySortModel<false> sm(runtime, self, compareFn);
    if (LLVM_UNLIKELY(quickSort(&sm, 0, len) == ExecutionStatus::EXCEPTION))
      return ExecutionStatus::EXCEPTION;
  }
  return self.getHermesValue();
}
