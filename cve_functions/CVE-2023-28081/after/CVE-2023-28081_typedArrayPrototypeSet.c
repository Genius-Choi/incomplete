typedArrayPrototypeSet(void *, Runtime &runtime, NativeArgs args) {
  if (JSTypedArrayBase::validateTypedArray(
          runtime, args.getThisHandle(), false) == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  // Default to zero if unspecified.
  auto offset = runtime.makeHandle(
      args.getArgCount() >= 2 ? args.getArg(1)
                              : HermesValue::encodeNumberValue(0));
  auto res = toIntegerOrInfinity(runtime, offset);
  if (res == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  double targetOffset = res->getNumber();
  // Offset check must come before the attached check.
  if (targetOffset < 0) {
    return runtime.raiseRangeError("Offset must not be negative if supplied");
  }
  if (!self->attached(runtime)) {
    return runtime.raiseTypeError(
        "TypedArray.prototype.set called on a detached TypedArray");
  }
  // Detect the type of the first argument to determine which version to call.
  auto arr = args.getArgHandle(0);
  if (auto typedarr = Handle<JSTypedArrayBase>::dyn_vmcast(arr)) {
    return typedArrayPrototypeSetTypedArray(
        runtime, self, typedarr, targetOffset);
  } else {
    return typedArrayPrototypeSetObject(runtime, self, arr, targetOffset);
  }
}
