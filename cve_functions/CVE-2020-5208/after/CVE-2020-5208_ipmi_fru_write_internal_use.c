ipmi_fru_write_internal_use(struct ipmi_intf * intf, uint8_t id, char * pFileName)
{
	struct fru_info fru;
	uint16_t size;
	uint16_t offset;
	int rc = 0;

	rc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);

	if(rc == 0)
	{
		uint8_t * frubuf;
		FILE * fp;
		uint32_t fileLength = 0;

		lprintf(LOG_DEBUG, "Internal Use Area Offset: %i", offset);
		printf(            "Internal Use Area Size  : %i\n", size);

		fp = fopen(pFileName, "r");

		if(fp)
		{
			/* Retrieve file length, check if it's fits the Eeprom Size */
			fseek(fp, 0 ,SEEK_END);
			fileLength = ftell(fp);

			lprintf(LOG_ERR, "File Size: %i", fileLength);
			lprintf(LOG_ERR, "Area Size: %i", size);
			if(fileLength != size)
			{
				lprintf(LOG_ERR, "File size does not fit Eeprom Size");
				fclose(fp);
				fp = NULL;
			}
			else
			{
				fseek(fp, 0 ,SEEK_SET);
			}
		}

		if(fp)
		{
			frubuf = malloc( size );
			if(frubuf)
			{
				uint16_t fru_read_size;
				fru_read_size = fread(frubuf, 1, size, fp);

				if(fru_read_size == size)
				{
					rc = write_fru_area(intf, &fru, id, 0, offset, size, frubuf);

					if(rc == 0)
					{
						lprintf(LOG_INFO, "Done\n");
					}
				}
				else
				{
					lprintf(LOG_ERR, "Unable to read file: %i\n", fru_read_size);
				}

				free_n(&frubuf);
			}
			fclose(fp);
			fp = NULL;
		}
	}
	else
	{
		lprintf(LOG_ERR, "Cannot access internal use area");
	}
	return 0;
}
