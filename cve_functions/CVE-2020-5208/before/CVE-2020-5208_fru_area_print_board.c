fru_area_print_board(struct ipmi_intf * intf, struct fru_info * fru,
			uint8_t id, uint32_t offset)
{
	char * fru_area;
	uint8_t * fru_data;
	uint32_t fru_len;
	uint32_t i;
	time_t ts;
	uint8_t tmp[2];

	fru_len = 0;

	/* read enough to check length field */
	if (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {
		fru_len = 8 * tmp[1];
	}

	if (fru_len <= 0) {
		return;
	}

	fru_data = malloc(fru_len);
	if (!fru_data) {
		lprintf(LOG_ERR, "ipmitool: malloc failure");
		return;
	}

	memset(fru_data, 0, fru_len);

	/* read in the full fru */
	if (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {
		free_n(&fru_data);
		return;
	}

	/*
	 * skip first three bytes which specify
	 * fru area version, fru area length
	 * and fru board language
	 */
	i = 3;

	ts = ipmi_fru2time_t(&fru_data[i]);
	printf(" Board Mfg Date        : %s\n", ipmi_timestamp_string(ts));
	i += 3;  /* skip mfg. date time */

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0) {
			printf(" Board Mfg             : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0) {
			printf(" Board Product         : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0) {
			printf(" Board Serial          : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0) {
			printf(" Board Part Number     : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0 && verbose > 0) {
			printf(" Board FRU ID          : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	/* read any extra fields */
	while ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {
		int j = i;
		fru_area = get_fru_area_str(fru_data, &i);
		if (fru_area) {
			if (strlen(fru_area) > 0) {
				printf(" Board Extra           : %s\n", fru_area);
			}
			free_n(&fru_area);
		}
		if (i == j)
			break;
	}

	free_n(&fru_data);
}
