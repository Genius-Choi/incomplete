static UINT32 libusb_udev_control_query_device_text(IUDEVICE* idev, UINT32 TextType,
                                                    UINT16 LocaleId, UINT8* BufferSize,
                                                    BYTE* Buffer)
{
	UDEVICE* pdev = (UDEVICE*)idev;
	LIBUSB_DEVICE_DESCRIPTOR* devDescriptor;
	const char strDesc[] = "Generic Usb String";
	char deviceLocation[25] = { 0 };
	BYTE bus_number;
	BYTE device_address;
	int ret = 0;
	size_t i, len;
	URBDRC_PLUGIN* urbdrc;
	WCHAR* text = (WCHAR*)Buffer;
	BYTE slen, locale;
	const UINT8 inSize = *BufferSize;

	*BufferSize = 0;
	if (!pdev || !pdev->devDescriptor || !pdev->urbdrc)
		return ERROR_INVALID_DATA;

	urbdrc = pdev->urbdrc;
	devDescriptor = pdev->devDescriptor;

	switch (TextType)
	{
		case DeviceTextDescription:
		{
			BYTE data[0x100] = { 0 };
			ret = libusb_get_string_descriptor(pdev->libusb_handle, devDescriptor->iProduct,
			                                   LocaleId, data, 0xFF);
			/* The returned data in the buffer is:
			 * 1 byte  length of following data
			 * 1 byte  descriptor type, must be 0x03 for strings
			 * n WCHAR unicode string (of length / 2 characters) including '\0'
			 */
			slen = data[0];
			locale = data[1];

			if ((ret <= 0) || (ret <= 4) || (slen <= 4) || (locale != LIBUSB_DT_STRING) ||
			    (ret > UINT8_MAX))
			{
				const char* msg = "SHORT_DESCRIPTOR";
				if (ret < 0)
					msg = libusb_error_name(ret);
				WLog_Print(urbdrc->log, WLOG_DEBUG,
				           "libusb_get_string_descriptor: "
				           "%s [%d], iProduct: %" PRIu8 "!",
				           msg, ret, devDescriptor->iProduct);

				len = MIN(sizeof(strDesc), inSize);
				for (i = 0; i < len; i++)
					text[i] = (WCHAR)strDesc[i];

				*BufferSize = (BYTE)(len * 2);
			}
			else
			{
				/* ret and slen should be equals, but you never know creativity
				 * of device manufacturers...
				 * So also check the string length returned as server side does
				 * not honor strings with multi '\0' characters well.
				 */
				const size_t rchar = _wcsnlen((WCHAR*)&data[2], sizeof(data) / 2);
				len = MIN((BYTE)ret, slen);
				len = MIN(len, inSize);
				len = MIN(len, rchar * 2 + sizeof(WCHAR));
				memcpy(Buffer, &data[2], len);

				/* Just as above, the returned WCHAR string should be '\0'
				 * terminated, but never trust hardware to conform to specs... */
				Buffer[len - 2] = '\0';
				Buffer[len - 1] = '\0';
				*BufferSize = (BYTE)len;
			}
		}
		break;

		case DeviceTextLocationInformation:
			bus_number = libusb_get_bus_number(pdev->libusb_dev);
			device_address = libusb_get_device_address(pdev->libusb_dev);
			sprintf_s(deviceLocation, sizeof(deviceLocation),
			          "Port_#%04" PRIu8 ".Hub_#%04" PRIu8 "", device_address, bus_number);

			len = strnlen(deviceLocation,
			              MIN(sizeof(deviceLocation), (inSize > 0) ? inSize - 1U : 0));
			for (i = 0; i < len; i++)
				text[i] = (WCHAR)deviceLocation[i];
			text[len++] = '\0';
			*BufferSize = (UINT8)(len * sizeof(WCHAR));
			break;

		default:
			WLog_Print(urbdrc->log, WLOG_DEBUG, "Query Text: unknown TextType %" PRIu32 "",
			           TextType);
			return ERROR_INVALID_DATA;
	}

	return S_OK;
}
