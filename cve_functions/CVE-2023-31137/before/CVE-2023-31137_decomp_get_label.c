js_string *decomp_get_label(js_string *compressed,
                            unsigned int compressed_offset) {
    js_string *ret; /* The string we return */
    int counter, cplace, cplace_save, dplace, limit;

    decomp_message("Performing sanity checks on compressed string...",5);

    /* Sanity checks */
    if(compressed == 0)
        return 0;
    if(compressed->unit_size != 1)
        return 0;
    if(compressed->unit_count > compressed->max_count)
        return 0;
    if(compressed_offset > compressed->unit_count)
        return 0;

    decomp_message("Compressed string is sane.  Initializing variables...",5);

    /* Initialize the variables */
    cplace = compressed_offset;
    cplace_save = cplace;
    dplace = 0;
    counter = 0;
    limit = 0;
    if((ret = js_create(MAX_DLABEL_LEN + 3,1)) == 0)
        return 0;

    decomp_message("Variables initalized.",5);

    /* Decompress and copy */
    do {
        if(cplace >= compressed->unit_count) {
            js_destroy(ret);
            return 0;
        }
        limit++;
        counter = *(compressed->string + cplace);
        /* We do not allow invalid length values */
        if(counter > 63 && counter < 0xC0) {
            decomp_message("Invalid length value in compressed string",4);
            js_destroy(ret);
            return 0;
            }
        else if(counter >= 0xC0) { /* Compression pointer */
            /* Make sure we have two bytes for the compression pointer */
            if(cplace + 1 >= compressed->unit_count) {
                decomp_message("Compression pointer isn't fitting",4);
                js_destroy(ret);
                return 0;
                }
            /* Get the compression pointer */
            cplace_save = cplace;
            cplace = ((counter & 0x3F) << 8);
            cplace |= *(compressed->string + cplace_save + 1);
            /* All compression labels must go backwards */
            if(cplace >= cplace_save) {
                decomp_message("Compressed pointer goes forward",4);
                js_destroy(ret);
                return 0;
                }
            /* All compression lables must start past the header */
            if(cplace < 12) {
                decomp_message("Compressed pointer points to header",4);
                js_destroy(ret);
                return 0;
                }
            }
        /* Normal length dlabel */
        else if(counter > 0 && counter <= 63) {
            counter++;
            if(dplace + counter >= ret->max_count) {
                decomp_message("Pointing past end of ret string",4);
                js_destroy(ret);
                return 0;
                }
            if(cplace + counter >= compressed->unit_count) {
                decomp_message("Pointing past end of compressed string",4);
                js_destroy(ret);
                return 0;
                }
            while(counter > 0) {
                *(ret->string + dplace) = *(compressed->string + cplace);
                ret->unit_count++;
                dplace++;
                cplace++;
                counter--;
                }
            counter = 100; /* So we don't break out of loop */
            }
        else if(counter == 0) {
            if(dplace + counter >= ret->max_count) {
                decomp_message("Pointing past end of the compressed string",4);
                js_destroy(ret);
                return 0;
                }
            *(ret->string + dplace) = 0;
            ret->unit_count++;
            }
        else { /* Should never happen */
            decomp_message("This, folks, should never happen",4);
            js_destroy(ret);
            return 0;
            }
        } while(counter > 0 && limit < 256);

    if(limit >= 256) {
        decomp_message("Limit exceeded when decompressing dlabel",4);
        js_destroy(ret);
        return 0;
        }

    /* Force core dump */
    /**(ret->string + 1000000) = 0;*/
    return ret;
    }
