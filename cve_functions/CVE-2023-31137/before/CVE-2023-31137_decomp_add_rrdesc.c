int decomp_add_rrdesc(js_string *desc) {
    int rtype, place, counter, fieldnum, subfieldnum;
    unsigned char c;
    rrdesc *new, *point;

    /* Sanity checks */
    if(js_has_sanity(desc) != JS_SUCCESS)
        return JS_ERROR;
    js_set_encode(desc,JS_US_ASCII); /* So js_atoi works */

    /* Determine where to place this record in the hash */
    if((new = js_alloc(1,sizeof(rrdesc))) == 0) {
        return JS_ERROR;
        }

    /* Set up the description.  This is a format where the description
       of each section of the RR is converted in to a single number */
    if((new->description = js_alloc(MAX_RR_SECTIONS,1)) == 0) {
        js_dealloc(new);
        return JS_ERROR;
        }
    /* Clear out the new->description array */
    for(counter = 0; counter < MAX_RR_SECTIONS - 1; counter++) {
        new->description[counter] = 0;
        }

    /* Initialize the "tocompress" field to uninitialized; this is
       a positive number under 127 because some versions of GCC on
       some architectures consider 'char' without 'unsigned' an
       unsigned value. */
    new->tocompress = 79;

    /* Now, parse the string describing the message */
    fieldnum = subfieldnum = 1;
    rtype = -1;
    for(counter = 0; counter < desc->unit_count ; counter++) {
        c = *(desc->string + counter);
        if(fieldnum == 1) { /* RR number field */
            if(subfieldnum == 1) /* Before first colon */ {
                if(c == ':') {
                    subfieldnum++;
                    }
                }
            else if(subfieldnum == 2) /* Number immediately after colon */ {
                if(rtype == -1) {
                    rtype = js_atoi(desc,counter);
                    if(rtype <= 0 || rtype > 65535) {
                        js_dealloc(new->description);
                        js_dealloc(new);
                        return JS_ERROR;
                        }
                    new->rr_num = rtype;
                    }
                if(c == '|') {
                    subfieldnum = 1;
                    fieldnum = 2;
                    }
                }
            }
        else if(fieldnum == 2) { /* RR name field */
            if(c == '|') {
                subfieldnum = 1;
                fieldnum = 3;
                }
            }
        else if(fieldnum == 3) { /* The description of the RRs themselves */
            /* Bounds check */
            if(subfieldnum > MAX_RR_SECTIONS - 2) {
                js_dealloc(new->description);
                js_dealloc(new);
                return JS_ERROR;
                }
            /* Process the RR subfield; this code only supports one-character
               labels (quick and dirty; but I want to get 1.0 out the door)
             */
            if(new->description[subfieldnum - 1] == 0) {
                if(c >= '1' && c <= '9') {
                    new->description[subfieldnum - 1] = c - '0';
                    }
                else if(c == 'D') {
                    new->description[subfieldnum - 1] = RRSUB_DLABEL;
                    }
                else if(c == 'T') {
                    new->description[subfieldnum - 1] = RRSUB_TEXT;
                    }
                else if(c == 'V') {
                    new->description[subfieldnum - 1] = RRSUB_VARIABLE;
                    }
                else { /* Unknown type */
                    js_dealloc(new->description);
                    js_dealloc(new);
                    return JS_ERROR;
                    }
                }
             else if(c != ';' && c != '|') { /* Multi-char description */
                 js_dealloc(new->description);
                 js_dealloc(new);
                 return JS_ERROR;
                 }
             else if(c == ';') {
                 /* Variable ('V') *must* be the last subfield */
                 if(new->description[subfieldnum - 1] == RRSUB_VARIABLE) {
                    js_dealloc(new->description);
                    js_dealloc(new);
                    return JS_ERROR;
                    }
                 subfieldnum++;
                 }
             else if(c == '|') {
                 subfieldnum = 1;
                 fieldnum = 4;
                 }
             else { /* Should never happen */
                 js_dealloc(new->description);
                 js_dealloc(new);
                 return JS_ERROR;
                 }
             }
         else if(fieldnum == 4) { /* Whether we can compress this field
                                     or not; currently ignored */
             if(c == 'C' && new->tocompress == 79) {
                new->tocompress = 1;
                }
             else if(c == 'N' && new->tocompress == 79) {
                new->tocompress = 0;
                }
             else if(c == '|' && new->tocompress != 79) {
                subfieldnum = 1;
                fieldnum = 5;
                }
             else { /* Invalid for field num */
                js_dealloc(new->description);
                js_dealloc(new);
                return -4;
                }
             }
         else if(fieldnum == 5) { /* Description of field; currently
                                     ignored */
             /* XXX: We really want something here which makes sure we
                     have at least three subfields and considers a colon
                     the start of a new RR */
             break;
             }
         }

     /* Now that the new field is set up, add the new element to the
        hash of rr descriptions */

     place = rtype % RR_HASH_SIZE;
     if(rr_formats == 0) {
        js_dealloc(new->description);
        js_dealloc(new);
        return JS_ERROR;
        }
     point = rr_formats[place];
     if(point == 0) {
         rr_formats[place] = new;
         }
     else {
         while(point->next != 0)
             point = point->next;
         point->next = new;
         }

     new->next = 0;

     /* OK, we're done (finally!) */
     return JS_SUCCESS;
     }
