int decomp_decompress_packet(js_string *compressed, js_string *uncompressed) {

    int answers; /* Number of answers */
    int type, rdlength; /* As per RFC1035  3.2.1 */
    int offset,length;
    js_string *rddata;

    /* Sanity checks */

    if(js_has_sanity(compressed) == JS_ERROR)
        return JS_ERROR;
    if(js_has_sanity(uncompressed) == JS_ERROR)
        return JS_ERROR;
    if(compressed->unit_size != 1 || uncompressed->unit_size != 1)
        return JS_ERROR;
    if(uncompressed->unit_count != 0)
        return JS_ERROR;

    /* Create the string for storing the rddata */
#ifndef AUTHONLY
    if((rddata = js_create(512,1)) == 0) {
        return JS_ERROR;
        }
#else
    if((rddata = js_create(4512,1)) == 0) {
        return JS_ERROR;
        }
#endif
    /* Read the header */

    answers = decomp_get_header(compressed,uncompressed);
    if(answers == -2) { /* No questions and no answers */
        js_destroy(rddata);
        return JS_SUCCESS;
        }
    else if(answers == JS_ERROR) {
        js_destroy(rddata);
        return JS_ERROR;
        }

    /* Process the question (if applicable) */
    if(answers <= -3) {
        answers = -2 - answers; /* So -3 becomes 1 answer, -4 becomes
                                   2 answers, etc. */
        length = 0;
        }
    else {
        length = decomp_get_question(compressed,uncompressed);
        if(length < 1) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        }

    offset = 12 + length;

    /* Process the answers */
    while(answers > 0) {
        length = decomp_append_dlabel(compressed,uncompressed,offset);
        if(length < 1) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += length;
        type = decomp_get_type_etc(compressed,uncompressed,offset);
        if(type == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += 8;
        rdlength = decomp_get_rdlength(compressed,offset);
        if(rdlength == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += 2;
        /* Hack: zero out the rddata string */
        rddata->unit_count = 0;
        if(decomp_get_rddata(compressed,rddata,offset,type,rdlength)
           != JS_SUCCESS) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        /* Add the decompressed rdlength */
        if(js_adduint16(uncompressed,rddata->unit_count) == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        /* And the decompressed rddata */
        if(js_append(rddata,uncompressed) == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += rdlength; /* The compressed rdlength */
        answers--;
        }

    js_destroy(rddata);
    return JS_SUCCESS;
    }
