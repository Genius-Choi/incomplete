static int rz_debug_gdb_reg_read(RzDebug *dbg, int type, ut8 *buf, int size) {
	RzDebugGdbCtx *ctx = dbg->plugin_data;
	int copy_size;
	int buflen = 0;
	check_connection(dbg);
	if (!ctx->desc) {
		return RZ_DEBUG_REASON_UNKNOWN;
	}
	gdbr_read_registers(ctx->desc);
	if (!ctx->desc || !ctx->desc->data) {
		return -1;
	}
	// read the len of the current area
	free(rz_reg_get_bytes(dbg->reg, type, &buflen));
	if (size < ctx->desc->data_len) {
		eprintf("rz_debug_gdb_reg_read: small buffer %d vs %d\n",
			(int)size, (int)ctx->desc->data_len);
		//	return -1;
	}
	copy_size = RZ_MIN(ctx->desc->data_len, size);
	buflen = RZ_MAX(ctx->desc->data_len, buflen);
	if (ctx->reg_buf) {
		// if (buf_size < copy_size) { //desc->data_len) {
		if (buflen > ctx->buf_size) { // copy_size) {
			ut8 *new_buf = realloc(ctx->reg_buf, buflen);
			if (!new_buf) {
				return -1;
			}
			ctx->reg_buf = new_buf;
			ctx->buf_size = buflen;
		}
	} else {
		ctx->reg_buf = calloc(buflen, 1);
		if (!ctx->reg_buf) {
			return -1;
		}
		ctx->buf_size = buflen;
	}
	memset((void *)(volatile void *)buf, 0, size);
	memcpy((void *)(volatile void *)buf, ctx->desc->data, RZ_MIN(copy_size, size));
	memset((void *)(volatile void *)ctx->reg_buf, 0, buflen);
	memcpy((void *)(volatile void *)ctx->reg_buf, ctx->desc->data, copy_size);
#if 0
	int i;
	//for(i=0;i<168;i++) {
	for(i=0;i<copy_size;i++) {
		if (!(i%16)) printf ("\n0x%08x  ", i);
		printf ("%02x ", buf[i]); //(ut8)desc->data[i]);
	}
	printf("\n");
#endif
	return ctx->desc->data_len;
}
