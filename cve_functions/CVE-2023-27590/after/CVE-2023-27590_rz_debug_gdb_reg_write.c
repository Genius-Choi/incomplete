static int rz_debug_gdb_reg_write(RzDebug *dbg, int type, const ut8 *buf, int size) {
	RzDebugGdbCtx *ctx = dbg->plugin_data;
	check_connection(dbg);
	if (!ctx->desc) {
		return RZ_DEBUG_REASON_UNKNOWN;
	}
	if (!ctx->reg_buf) {
		// we cannot write registers before we once read them
		return -1;
	}
	int buflen = 0;
	int bits = dbg->analysis->bits;
	const char *pcname = rz_reg_get_name(dbg->analysis->reg, RZ_REG_NAME_PC);
	RzRegItem *reg = rz_reg_get(dbg->analysis->reg, pcname, 0);
	if (reg) {
		if (dbg->analysis->bits != reg->size) {
			bits = reg->size;
		}
	}
	free(rz_reg_get_bytes(dbg->reg, type, &buflen));
	// some implementations of the gdb protocol are acting weird.
	// so winedbg is not able to write registers through the <G> packet
	// and also it does not return the whole gdb register profile after
	// calling <g>
	// so this workaround resizes the small register profile buffer
	// to the whole set and fills the rest with 0
	if (ctx->buf_size < buflen) {
		ut8 *new_buf = realloc(ctx->reg_buf, buflen * sizeof(ut8));
		if (!new_buf) {
			return -1;
		}
		ctx->reg_buf = new_buf;
		memset(new_buf + ctx->buf_size, 0, buflen - ctx->buf_size);
	}

	RzRegItem *current = NULL;
	// We default to little endian if there's no way to get the configuration,
	// since this was the behaviour prior to the change.
	RzRegArena *arena = dbg->reg->regset[type].arena;
	for (;;) {
		current = rz_reg_next_diff(dbg->reg, type, ctx->reg_buf, buflen, current, bits);
		if (!current) {
			break;
		}
		gdbr_write_reg(ctx->desc, current->name, (char *)arena->bytes + (current->offset / 8), current->size / 8);
	}
	return true;
}
