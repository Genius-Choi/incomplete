static void decode_phase(struct Flex * flex, char PhaseNo) {
  if (flex==NULL) return;
  verbprintf(3, "FLEX: Decoding phase %c\n", PhaseNo);

  uint32_t *phaseptr=NULL;

  switch (PhaseNo) {
    case 'A': phaseptr=flex->Data.PhaseA.buf; break;
    case 'B': phaseptr=flex->Data.PhaseB.buf; break;
    case 'C': phaseptr=flex->Data.PhaseC.buf; break;
    case 'D': phaseptr=flex->Data.PhaseD.buf; break;
  }

  for (unsigned int i = 0; i < PHASE_WORDS; i++) {
    int decode_error=bch3121_fix_errors(flex, &phaseptr[i], PhaseNo);

    if (decode_error) {
      verbprintf(3, "FLEX: Garbled message at block %u\n", i);

                        // If the previous frame was a short message then we need to Null out the Group Message pointer
                        // this issue and sugested resolution was presented by 'bertinholland'


      return;
    }

    /*Extract just the message bits*/
    phaseptr[i]&=0x1FFFFFL;
  }

  // Block information word is the first data word in frame
  uint32_t biw = phaseptr[0];

  // Nothing to see here, please move along
  if (biw == 0 || (biw & 0x1FFFFFL) == 0x1FFFFFL) {
    verbprintf(3, "FLEX: Nothing to see here, please move along\n");
    return;
  }

  // Address start address is bits 9-8, plus one for offset (to account for biw)
  unsigned int aoffset = ((biw >> 8) & 0x3L) + 1;
  // Vector start index is bits 15-10
  unsigned int voffset = (biw >> 10) & 0x3fL;
  if (voffset < aoffset) {
      verbprintf(3, "FLEX: Invalid biw");
      return;
  }
  // long addresses use double AW and VW, so there are anywhere between ceil(v-a/2) to v-a pages in this frame
  verbprintf(3, "FLEX: BlockInfoWord: (Phase %c) BIW:%08X AW %02u VW %02u (up to %u pages)\n", PhaseNo, biw, aoffset, voffset, voffset-aoffset);

  int flex_groupmessage = 0;
  int flex_groupbit = 0;

  // Iterate through pages and dispatch to appropriate handler
  for (unsigned int i = aoffset; i < voffset; i++) {
    verbprintf(3, "FLEX: Processing page offset #%u AW:%08X VW:%08X\n", i - aoffset + 1, phaseptr[i], phaseptr[voffset + i - aoffset]);
    if (phaseptr[i] == 0 ||
        (phaseptr[i] & 0x1FFFFFL) == 0x1FFFFFL) {
      verbprintf(3, "FLEX: Idle codewords, invalid address\n");
      continue;
    }
    /*********************
     * Parse AW
     */
    uint32_t aiw = phaseptr[i];
    flex->Decode.long_address = (aiw < 0x8001L) ||
      (aiw > 0x1E0000L && aiw < 0x1F0001L) ||
      (aiw > 0x1F7FFEL);

    flex->Decode.capcode = aiw - 0x8000L;  // if short address
    if (flex->Decode.long_address) {
      // Couldn't find spec on this, credit to PDW
      flex->Decode.capcode = phaseptr[i + 1] ^ 0x1FFFFFL;
      // 0x8000 or 32768 is 16b, use as upper part of 64b capcode
      flex->Decode.capcode = flex->Decode.capcode << 15;
      // add in 2068480 and first word, credit to PDW
      // NOTE per PDW: this is not number given (2067456) in the patent for FLEX
      flex->Decode.capcode += 2068480L + aiw;
    }
    if (flex->Decode.capcode > 4297068542LL || flex->Decode.capcode < 0) {
      // Invalid address (by spec, maximum address)
      verbprintf(3, "FLEX: Invalid address, capcode out of range %" PRId64 "\n", flex->Decode.capcode);
      continue;
    }
    verbprintf(3, "FLEX: CAPCODE:%016" PRIx64 " %" PRId64 "\n", flex->Decode.capcode, flex->Decode.capcode);

    flex_groupmessage = 0;
    flex_groupbit = 0;
          if ((flex->Decode.capcode >= 2029568) && (flex->Decode.capcode <= 2029583)) {
             flex_groupmessage = 1;
             flex_groupbit = flex->Decode.capcode - 2029568;
             if(flex_groupbit < 0) continue;
          }
    if (flex_groupmessage && flex->Decode.long_address) {
      // Invalid (by spec)
      verbprintf(3, "FLEX: Don't process group messages if a long address\n");
      return;
    }
    verbprintf(3, "FLEX: AIW %u: capcode:%" PRId64 " long:%d group:%d groupbit:%d\n", i, flex->Decode.capcode, flex->Decode.long_address, flex_groupmessage, flex_groupbit);

    /*********************
     * Parse VW
     */
    // Parse vector information word for address @ offset 'i'
    unsigned int j = voffset+i-aoffset;    // Start of vector field for address @ i
    uint32_t viw = phaseptr[j];
    flex->Decode.type = ((viw >> 4) & 0x7L);
    unsigned int mw1 = (viw >> 7) & 0x7FL;
    unsigned int len = (viw >> 14) & 0x7FL;
    unsigned int hdr;
    if (flex->Decode.long_address) {
      // the header is within the next VW
      hdr = j + 1;
      if (len >= 1) {
        // per PDW
        len--;
      }
    } else {  // if short address
      // the header is within the message
      hdr = mw1;
      mw1++;
      if (!flex_groupmessage && len >= 1) {
        // not in spec, possible decode issue, but this fixed repeatedly observed len issues
        len--;
      }
    }
    if (hdr >= PHASE_WORDS) {
      verbprintf(3, "FLEX: Invalid VIW\n");
      continue;
    }
    // get message fragment number (bits 11 and 12) from first header word
    // if frag != 3 then this is a continued message
    int frag = (int) (phaseptr[hdr] >> 11) & 0x3L;
    // which spec documents a cont flag? it is used to derive the K/F/C frag_flag
    int cont = (int) (phaseptr[hdr] >> 10) & 0x1L;;
    verbprintf(3, "FLEX: VIW %u: type:%d mw1:%u len:%u frag:%i\n", j, flex->Decode.type, mw1, len, frag);

    if (flex->Decode.type == FLEX_PAGETYPE_SHORT_INSTRUCTION)
                {
                    // if (flex_groupmessage == 1) continue;
                    unsigned int iAssignedFrame = (int)((viw >> 10) & 0x7f);  // Frame with groupmessage
                    int groupbit = (int)((viw >> 17) & 0x7f);    // Listen to this groupcode
                    
        ////////#############################################################################                 
        ////////#############################################################################                 
                    flex->GroupHandler.GroupCodes[groupbit][CAPCODES_INDEX]++;
                    int CapcodePlacement = flex->GroupHandler.GroupCodes[groupbit][CAPCODES_INDEX];
                    verbprintf(1, "FLEX: Found Short Instruction, Group bit: %i capcodes in group so far %i, adding Capcode: [%010" PRId64 "]\n", groupbit, CapcodePlacement, flex->Decode.capcode);

                    flex->GroupHandler.GroupCodes[groupbit][CapcodePlacement] = flex->Decode.capcode;
                    flex->GroupHandler.GroupFrame[groupbit] = iAssignedFrame;

        // Ok, so the cycle and frame can be used to make sure we haven't missed the message frame.
        // but the cycle is 0 - 15 and the frame is 0 - 127
        if(iAssignedFrame > flex->FIW.frameno)
        {
      flex->GroupHandler.GroupCycle[groupbit] = (int)flex->FIW.cycleno;
      verbprintf(4, "FLEX: Message frame is in this cycle: %i\n", flex->GroupHandler.GroupCycle[groupbit]);

        }
        else
        {
      if(flex->FIW.cycleno == 15)
                        {
        flex->GroupHandler.GroupCycle[groupbit] = 0;
      }
      else
      {
        flex->GroupHandler.GroupCycle[groupbit] = (int)flex->FIW.cycleno++;
          }
      verbprintf(4, "FLEX: Message frame is in the next cycle: %i\n", flex->GroupHandler.GroupCycle[groupbit]);
        }


                    // Nothing else to do with this word.. move on!!
                    continue;
                }

    // mw1 == 0, or anything less than the offset after all the VIW, is bad
    if (len < 1 || mw1 < (voffset + (voffset - aoffset)) || mw1 >= PHASE_WORDS) {
      verbprintf(3, "FLEX: Invalid VIW\n");
      continue;
    }
    // mw1 + len == 89 was observed, but still contained valid page, so truncate
    if ((mw1 + len) > PHASE_WORDS){
      len = PHASE_WORDS - mw1;
    }

    if (is_tone_page(flex))
      mw1 = len = 0;

    // Check if this is an alpha message
    if (is_alphanumeric_page(flex))
      parse_alphanumeric(flex, phaseptr, PhaseNo, mw1, len, frag, cont, flex_groupmessage, flex_groupbit);
    else if (is_numeric_page(flex))
      parse_numeric(flex, phaseptr, PhaseNo, j);
    else if (is_tone_page(flex))
      parse_tone_only(flex, phaseptr, PhaseNo, j); // parse_tone_only(flex, PhaseNo);
    else
      parse_unknown(flex, phaseptr, PhaseNo, mw1, len);

    // long addresses eat 2 aw and 2 vw, so skip the next aw-vw pair
    if (flex->Decode.long_address) {
      i++;
    }
  }
}
