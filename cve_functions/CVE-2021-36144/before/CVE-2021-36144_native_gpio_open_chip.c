native_gpio_open_chip(struct native_gpio_chip *chip, const char *name)
{
	struct gpiochip_info info;
	struct gpio_line *line;
	char path[64] = {0};
	int fd, rc, i;

	snprintf(path, sizeof(path), "/dev/%s", name);
	fd = open(path, O_RDWR);
	if (fd < 0) {
		WPRINTF(("Can't open gpio device: %s, error %s\n",
				path, strerror(errno)));
		return -1;
	}

	memset(&info, 0, sizeof(info));
	rc = ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info);
	if (rc < 0) {
		WPRINTF(("Can't ioctl gpio device: %s, error %s\n",
				path, strerror(errno)));
		goto fail;
	}

	chip->lines = calloc(1, info.lines * sizeof(*chip->lines));
	if (!chip->lines) {
		WPRINTF(("Alloc chip lines error, %s:%d, error %s\n",
				path, chip->ngpio, strerror(errno)));
		goto fail;
	}
	chip->fd = fd;
	chip->ngpio = info.lines;
	strncpy(chip->name, info.name, sizeof(chip->name) - 1);
	strncpy(chip->label, info.label, sizeof(chip->label) - 1);
	strncpy(chip->dev_name, name, sizeof(chip->dev_name) - 1);

	/* initialize all lines of the chip */
	for (i = 0; i < chip->ngpio; i++) {
		line = &chip->lines[i];
		line->offset = i;
		line->chip = chip;

		/*
		 * The line's fd and voffset will be initialized
		 * when virtual gpio line connects to the real line.
		 */
		line->fd = -1;
		line->voffset = -1;

		/* Set line state and name via ioctl*/
		native_gpio_update_line_info(line);
	}

	return 0;

fail:
	if (fd > 0)
		close(fd);
	chip->fd = -1;
	chip->ngpio = 0;
	return -1;
}
