native_gpio_open_line(struct gpio_line *line, unsigned int flags,
		unsigned int value)
{
	struct gpiohandle_request req;
	int rc;

	memset(&req, 0, sizeof(req));
	req.lineoffsets[0] = line->offset;
	req.lines = 1;
	strncpy(req.consumer_label, "acrn_dm", sizeof(req.consumer_label) - 1);
	if (flags) {

		/*
		 * before setting a new flag, it needs to try to close the fd
		 * that has been opened first, otherwise it will not be ioctl
		 * successfully.
		 */
		native_gpio_close_line(line);

		req.flags = flags;
		if (flags & GPIOHANDLE_REQUEST_OUTPUT)
			req.default_values[0] = value;
	}
	rc = ioctl(line->chip->fd, GPIO_GET_LINEHANDLE_IOCTL, &req);
	if (rc < 0) {
		WPRINTF(("ioctl GPIO_GET_LINEHANDLE_IOCTL error %s\n",
				strerror(errno)));
		return -1;
	}

	if (flags) {
		line->config = flags;
		if (flags & GPIOHANDLE_REQUEST_OUTPUT) {
			line->dir = 0;
			line->value = value;
		} else if (flags & GPIOHANDLE_REQUEST_INPUT)
			line->dir = 1;
	}

	line->fd = req.fd;
	return rc;
}
