virtio_console_open_backend(const char *path,
			    enum virtio_console_be_type be_type)
{
	int fd = -1;

	switch (be_type) {
	case VIRTIO_CONSOLE_BE_PTY:
		fd = posix_openpt(O_RDWR | O_NOCTTY);
		if (fd == -1)
			WPRINTF(("vtcon: posix_openpt failed, errno = %d\n",
				errno));
		else if (grantpt(fd) == -1 || unlockpt(fd) == -1) {
			WPRINTF(("vtcon: grant/unlock failed, errno = %d\n",
				errno));
			close(fd);
			fd = -1;
		}
		break;
	case VIRTIO_CONSOLE_BE_STDIO:
		if (stdio_in_use) {
			WPRINTF(("vtcon: stdio is used by other device\n"));
			break;
		}
		fd = STDIN_FILENO;
		stdio_in_use = true;
		break;
	case VIRTIO_CONSOLE_BE_TTY:
		fd = open(path, O_RDWR | O_NONBLOCK);
		if (fd < 0)
			WPRINTF(("vtcon: open failed: %s\n", path));
		else if (!isatty(fd)) {
			WPRINTF(("vtcon: not a tty: %s\n", path));
			close(fd);
			fd = -1;
		}
		break;
	case VIRTIO_CONSOLE_BE_FILE:
		fd = open(path, O_WRONLY|O_CREAT|O_APPEND|O_NONBLOCK, 0666);
		if (fd < 0)
			WPRINTF(("vtcon: open failed: %s\n", path));
		break;
	case VIRTIO_CONSOLE_BE_SOCKET:
		fd = socket(AF_UNIX, SOCK_STREAM, 0);
		if (fd < 0)
			WPRINTF(("vtcon: socket open failed \n"));
		break;
	default:
		WPRINTF(("not supported backend %d!\n", be_type));
	}

	return fd;
}
