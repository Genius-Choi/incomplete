vmei_rx_callback(int fd, enum ev_type type, void *param)
{
	struct vmei_host_client *hclient = param;
	struct virtio_mei *vmei = vmei_host_client_to_vmei(hclient);
	ssize_t ret;

	if (!vmei)
		return;

	if (!vmei_host_client_get(hclient)) {
		DPRINTF("RX: client has been released, ignore data.\n");
		return;
	}

	pthread_mutex_lock(&vmei->rx_mutex);
	if (vmei->status != VMEI_STS_READY) {
		HCL_DBG(hclient, "vmei is not ready %d\n", vmei->status);
		goto out;
	}

	if (hclient->recv_offset) {
		/* still has data in recv_buf, wait guest reading */
		HCL_DBG(hclient, "data in recv_buf, wait for UOS reading.\n");
		goto out;
	}

	/* read data from mei driver */
	ret = vmei_host_client_native_read(hclient);
	if (ret <= 0) {
		HCL_DBG(hclient, "RX: no data %zd\n", ret);
		goto out;
	}
	vmei->rx_need_sched = true;

	HCL_DBG(hclient, "RX: read %zd bytes from the FW\n", ret);

	/* wake up rx thread. */
	pthread_cond_signal(&vmei->rx_cond);

out:
	pthread_mutex_unlock(&vmei->rx_mutex);
	vmei_host_client_put(hclient);
}
