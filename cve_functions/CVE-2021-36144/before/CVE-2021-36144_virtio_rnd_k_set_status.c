virtio_rnd_k_set_status(void *base, uint64_t status)
{
	struct virtio_rnd *rnd;
	int nvq;
	struct msix_table_entry *mte;
	uint64_t msix_addr = 0;
	uint32_t msix_data = 0;
	int rc, i, j;

	rnd = base;
	nvq = rnd->base.vops->nvq;

	if (rnd->vbs_k.status == VIRTIO_DEV_INIT_SUCCESS &&
	    (status & VIRTIO_CONFIG_S_DRIVER_OK)) {
		/* time to kickoff VBS-K side */
		/* init vdev first */
		rc = virtio_rnd_kernel_dev_set(&rnd->vbs_k.dev,
					       rnd->base.vops->name,
					       rnd->base.dev->vmctx->vmid,
					       nvq,
					       rnd->base.negotiated_caps,
					       /*
						* currently we let VBS-K handle
						* kick register
						*/
					       rnd->base.dev->bar[0].addr + 16,
					       2);

		for (i = 0; i < nvq; i++) {
			if (rnd->vq.msix_idx != VIRTIO_MSI_NO_VECTOR) {
				j = rnd->vq.msix_idx;
				mte = &rnd->base.dev->msix.table[j];
				msix_addr = mte->addr;
				msix_data = mte->msg_data;
			}
			rc = virtio_rnd_kernel_vq_set(&rnd->vbs_k.vqs,
						      nvq, i,
						      rnd->vq.qsize,
						      rnd->vq.pfn,
						      rnd->vq.msix_idx,
						      msix_addr,
						      msix_data);
			if (rc < 0) {
				WPRINTF(("rnd_kernel_set_vq fail,i %d ret %d\n",
					 i, rc));
				return;
			}
		}
		rc = virtio_rnd_kernel_start(rnd);
		if (rc < 0) {
			WPRINTF(("virtio_rnd_kernel_start() failed\n"));
			rnd->vbs_k.status = VIRTIO_DEV_START_FAILED;
		} else {
			rnd->vbs_k.status = VIRTIO_DEV_STARTED;
		}
	}
}
