virtio_hyper_dmabuf_set_status(void *base, uint64_t status)
{
	struct virtio_hyper_dmabuf *hyper_dmabuf;
	int nvq;
	struct msix_table_entry *mte;
	uint64_t msix_addr = 0;
	uint32_t msix_data = 0;
	int rc, i, j;

	hyper_dmabuf = (struct virtio_hyper_dmabuf *) base;
	nvq = hyper_dmabuf->base.vops->nvq;

	if (kstatus == VIRTIO_DEV_INIT_SUCCESS &&
	    (status & VIRTIO_CONFIG_S_DRIVER_OK)) {
		/* time to kickoff VBS-K side */
		/* init vdev first */
		rc = virtio_hyper_dmabuf_k_dev_set(
				hyper_dmabuf->base.vops->name,
				hyper_dmabuf->base.dev->vmctx->vmid,
				nvq,
				hyper_dmabuf->base.negotiated_caps,
				/* currently we let VBS-K handle
				 * kick register
				 */
				hyper_dmabuf->base.dev->bar[0].addr + 16,
				2);

		for (i = 0; i < nvq; i++) {
			if (hyper_dmabuf->vq[i].msix_idx !=
					VIRTIO_MSI_NO_VECTOR) {
				j = hyper_dmabuf->vq[i].msix_idx;
				mte = &hyper_dmabuf->base.dev->msix.table[j];
				msix_addr = mte->addr;
				msix_data = mte->msg_data;
			}
			rc = virtio_hyper_dmabuf_k_vq_set(
				nvq, i,
				hyper_dmabuf->vq[i].qsize,
				hyper_dmabuf->vq[i].pfn,
				hyper_dmabuf->vq[i].msix_idx,
				msix_addr,
				msix_data);

			if (rc < 0) {
				WPRINTF("virtio_hyper_dmabuf:");
				WPRINTF("kernel_set_vq");
				WPRINTF("failed, i %d ret %d\n", i, rc);
				return;
			}
		}
		rc = virtio_hyper_dmabuf_k_start();
		if (rc < 0) {
			WPRINTF("virtio_hyper_dmabuf:");
			WPRINTF("kernel_start() failed\n");
			kstatus = VIRTIO_DEV_START_FAILED;
		} else {
			kstatus = VIRTIO_DEV_STARTED;
		}
	}
}
