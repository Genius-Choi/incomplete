virtio_net_tap_rx(struct virtio_net *net)
{
	struct iovec iov[VIRTIO_NET_MAXSEGS], *riov;
	struct virtio_vq_info *vq;
	void *vrx;
	int len, n;
	uint16_t idx;
	ssize_t ret;

	/*
	 * Should never be called without a valid tap fd
	 */
	if (net->tapfd == -1) {
		WPRINTF(("vtnet: tapfd == -1\n"));
		return;
	}

	/*
	 * But, will be called when the rx ring hasn't yet
	 * been set up or the guest is resetting the device.
	 */
	if (!net->rx_ready || net->resetting) {
		/*
		 * Drop the packet and try later.
		 */
		ret = read(net->tapfd, dummybuf, sizeof(dummybuf));
		(void)ret; /*avoid compiler warning*/

		return;
	}

	/*
	 * Check for available rx buffers
	 */
	vq = &net->queues[VIRTIO_NET_RXQ];
	if (!vq_has_descs(vq)) {
		/*
		 * Drop the packet and try later.  Interrupt on
		 * empty, if that's negotiated.
		 */
		ret = read(net->tapfd, dummybuf, sizeof(dummybuf));
		(void)ret; /*avoid compiler warning*/

		vq_endchains(vq, 1);
		return;
	}

	do {
		/*
		 * Get descriptor chain.
		 */
		n = vq_getchain(vq, &idx, iov, VIRTIO_NET_MAXSEGS, NULL);
		if (n < 1 || n > VIRTIO_NET_MAXSEGS) {
			WPRINTF(("vtnet: virtio_net_tap_rx: vq_getchain = %d\n", n));
			return;
		}
		/*
		 * Get a pointer to the rx header, and use the
		 * data immediately following it for the packet buffer.
		 */
		vrx = iov[0].iov_base;
		riov = rx_iov_trim(iov, &n, net->rx_vhdrlen);
		if (riov == NULL)
			return;

		len = readv(net->tapfd, riov, n);

		if (len < 0 && errno == EWOULDBLOCK) {
			/*
			 * No more packets, but still some avail ring
			 * entries.  Interrupt if needed/appropriate.
			 */
			vq_retchain(vq);
			vq_endchains(vq, 0);
			return;
		}

		/*
		 * The only valid field in the rx packet header is the
		 * number of buffers if merged rx bufs were negotiated.
		 */
		memset(vrx, 0, net->rx_vhdrlen);

		if (net->rx_merge) {
			struct virtio_net_rxhdr *vrxh;

			vrxh = vrx;
			vrxh->vrh_bufs = 1;
		}

		/*
		 * Release this chain and handle more chains.
		 */
		vq_relchain(vq, idx, len + net->rx_vhdrlen);
	} while (vq_has_descs(vq));

	/* Interrupt if needed, including for NOTIFY_ON_EMPTY. */
	vq_endchains(vq, 1);
}
