virtio_gpio_irq_proc(struct virtio_gpio *gpio, struct iovec *iov, uint16_t flag)
{
	struct virtio_gpio_irq_request *req;
	struct gpio_irq_chip *chip;
	struct gpio_irq_desc *desc;
	int len;

	req = iov[0].iov_base;
	len = iov[0].iov_len;
	if (len != sizeof(*req)) {
		WPRINTF(("virtio gpio, invalid req size %d\n", len));
		return;
	}

	if (req->pin >= gpio->nvline) {
		WPRINTF(("virtio gpio, invalid IRQ pin %d, ignore action %d\n",
			req->pin, req->action));
		return;
	}

	chip = &gpio->irq_chip;
	desc = &chip->descs[req->pin];
	switch (req->action) {
	case IRQ_ACTION_ENABLE:
		/*
		 * TODO: need to notify the FE driver
		 *       if gpio_irq_enable failure.
		 */
		gpio_irq_enable(gpio, req->pin, req->mode);

		/* print IRQ statistics */
		print_intr_statistics(chip);
		break;
	case IRQ_ACTION_DISABLE:
		gpio_irq_disable(chip, req->pin);


		/* print IRQ statistics */
		print_intr_statistics(chip);
		break;
	case IRQ_ACTION_ACK:
		/*
		 * For level trigger, we need to check the level value
		 * for next interrupt.
		 */
		gpio_irq_clear_intr(chip, req->pin);
		if (gpio_irq_has_pending_intr(desc))
			gpio_irq_generate_intr(gpio, req->pin);
		break;
	case IRQ_ACTION_MASK:
		desc->mask = true;
		break;
	case IRQ_ACTION_UNMASK:
		desc->mask = false;
		if (gpio_irq_has_pending_intr(desc))
			gpio_irq_generate_intr(gpio, req->pin);
		break;
	default:
		WPRINTF(("virtio gpio, unknown IRQ action %d\n", req->action));
	}
}
