static void *vmei_rx_thread(void *param)
{
	struct virtio_mei *vmei = param;
	struct virtio_vq_info *vq = &vmei->vqs[VMEI_RXQ];
	int err;

	/*
	 * Let us wait till the rx queue pointers get initialised &
	 * first tx signaled
	 */
	pthread_mutex_lock(&vmei->rx_mutex);

	while (vmei->status != VMEI_STST_DEINIT && !vq_ring_ready(vq)) {
		err = pthread_cond_wait(&vmei->rx_cond, &vmei->rx_mutex);
		if (err)
			goto out;
	}

	while (vmei->status != VMEI_STST_DEINIT) {
		/* note - rx mutex is locked here */
		while (!vmei->rx_need_sched || !vq_has_descs(vq)) {
			vq_clear_used_ring_flags(&vmei->base, vq);
			mb();
			if (vmei->rx_need_sched &&
			    vmei->status != VMEI_STS_RESET &&
			    vq_has_descs(vq))
				break;

			err = pthread_cond_wait(&vmei->rx_cond,
						&vmei->rx_mutex);
			if (err || vmei->status == VMEI_STST_DEINIT)
				goto out;
		}

		vq->used->flags |= VRING_USED_F_NO_NOTIFY;

		do {
			vmei->rx_need_sched = vmei_proc_rx(vmei, vq);
		} while (vmei->rx_need_sched && vq_has_descs(vq));

		/* at least one avail ring element has been processed */
		vq_endchains(vq, !vq_has_descs(vq));
	}

out:
	pthread_mutex_unlock(&vmei->rx_mutex);
	pthread_exit(NULL);
}
