static void *vmei_tx_thread(void *param)
{
	struct virtio_mei *vmei = param;
	struct timespec max_wait = {0, 0};
	int err, pending_cnt = 0;

	pthread_mutex_lock(&vmei->tx_mutex);

	while (vmei->status != VMEI_STST_DEINIT) {
		struct vmei_me_client *me;
		struct vmei_host_client *e;
		ssize_t len;
		int send_ready;

		if (pending_cnt == 0) {
			err = pthread_cond_wait(&vmei->tx_cond,
						&vmei->tx_mutex);
			if (err)
				goto out;
		} else {
			max_wait.tv_sec = time(NULL) + 2;
			max_wait.tv_nsec = 0;
			err = pthread_cond_timedwait(&vmei->tx_cond,
						     &vmei->tx_mutex,
						     &max_wait);
			if (err && err != ETIMEDOUT)
				goto out;

			pending_cnt = 0;
		}

		pthread_mutex_lock(&vmei->list_mutex);
		LIST_FOREACH(me, &vmei->active_clients, list) {
			pthread_mutex_lock(&me->list_mutex);
			LIST_FOREACH(e, &me->connections, list) {
				if (!vmei_host_ready_send_buffers(e))
					continue;

				len = vmei_host_client_native_write(e);
				if (len < 0 && len != -EAGAIN) {
					HCL_WARN(e, "TX:send failed %zd\n",
						 len);
					pthread_mutex_unlock(&me->list_mutex);
					goto unlock;
				}
				if (vmei->status == VMEI_STS_RESET) {
					pthread_mutex_unlock(&me->list_mutex);
					goto unlock;
				}

				send_ready = vmei_host_ready_send_buffers(e);
				pending_cnt += send_ready;
				if (!send_ready)
					vmei_hbm_flow_ctl_req(e);
			}
			pthread_mutex_unlock(&me->list_mutex);
		}
unlock:
		pthread_mutex_unlock(&vmei->list_mutex);
	}

out:
	pthread_mutex_unlock(&vmei->tx_mutex);
	pthread_exit(NULL);
}
