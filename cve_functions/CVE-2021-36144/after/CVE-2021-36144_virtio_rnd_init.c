virtio_rnd_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_rnd *rnd = NULL;
	int fd;
	pthread_mutexattr_t attr;
	int rc;
	char *opt;
	char *vbs_k_opt = NULL;
	enum VBS_K_STATUS kstat = VIRTIO_DEV_INITIAL;
	char tname[MAXCOMLEN + 1];

	while ((opt = strsep(&opts, ",")) != NULL) {
		/* vbs_k_opt should be kernel=on */
		vbs_k_opt = strsep(&opt, "=");
		DPRINTF(("vbs_k_opt is %s\n", vbs_k_opt));
		if (opt != NULL) {
			if (strncmp(opt, "on", 2) == 0)
				kstat = VIRTIO_DEV_PRE_INIT;
			WPRINTF(("virtio_rnd: VBS-K initializing..."));
		}
	}

	/*
	 * Should always be able to open /dev/random.
	 */
	fd = open("/dev/random", O_RDONLY);
	if (fd < 0) {
		WPRINTF(("virtio_rnd: open failed: /dev/random \n"));
		return -1;
	}

	rnd = calloc(1, sizeof(struct virtio_rnd));
	if (!rnd) {
		WPRINTF(("virtio_rnd: calloc returns NULL\n"));
		goto fail;
	}

	rnd->vbs_k.status = kstat;

	/* init mutex attribute properly */
	rc = pthread_mutexattr_init(&attr);
	if (rc)
		DPRINTF(("mutexattr init failed with erro %d!\n", rc));
	if (virtio_uses_msix()) {
		rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
		if (rc)
			DPRINTF(("virtio_msix: mutexattr_settype failed with "
				"error %d!\n", rc));
	} else {
		rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
		if (rc)
			DPRINTF(("virtio_intx: mutexattr_settype failed with "
				"error %d!\n", rc));
	}
	rc = pthread_mutex_init(&rnd->mtx, &attr);
	if (rc)
		DPRINTF(("mutex init failed with error %d!\n", rc));

	if (rnd->vbs_k.status == VIRTIO_DEV_PRE_INIT) {
		DPRINTF(("%s: VBS-K option detected!\n", __func__));
		virtio_linkup(&rnd->base, &virtio_rnd_ops_k,
			      rnd, dev, &rnd->vq, BACKEND_VBSK);
		rc = virtio_rnd_kernel_init(rnd);
		if (rc < 0) {
			WPRINTF(("virtio_rnd: VBS-K init failed,error %d!\n",
				 rc));
			rnd->vbs_k.status = VIRTIO_DEV_INIT_FAILED;
		} else {
			rnd->vbs_k.status = VIRTIO_DEV_INIT_SUCCESS;
		}
	}
	if (rnd->vbs_k.status == VIRTIO_DEV_INITIAL ||
	    rnd->vbs_k.status != VIRTIO_DEV_INIT_SUCCESS) {
		DPRINTF(("%s: fallback to VBS-U...\n", __func__));
		virtio_linkup(&rnd->base, &virtio_rnd_ops, rnd, dev, &rnd->vq, BACKEND_VBSU);
	}

	rnd->base.mtx = &rnd->mtx;

	rnd->vq.qsize = VIRTIO_RND_RINGSZ;

	/* keep /dev/random opened while emulating */
	rnd->fd = fd;

	/* initialize config space */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_RANDOM);
	pci_set_cfgdata16(dev, PCIR_VENDOR, VIRTIO_VENDOR);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_CRYPTO);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_ENTROPY);
	pci_set_cfgdata16(dev, PCIR_SUBVEND_0, VIRTIO_VENDOR);

	if (virtio_interrupt_init(&rnd->base, virtio_uses_msix())) {
		goto fail;
	}

	virtio_set_io_bar(&rnd->base, 0);

	rnd->in_progress = 0;
	pthread_mutex_init(&rnd->rx_mtx, NULL);
	pthread_cond_init(&rnd->rx_cond, NULL);
	pthread_create(&rnd->rx_tid, NULL, virtio_rnd_get_entropy,
		       (void *)rnd);
	snprintf(tname, sizeof(tname), "vtrnd-%d:%d tx", dev->slot,
		 dev->func);
	pthread_setname_np(rnd->rx_tid, tname);

	return 0;

fail:
	close(fd);
	if (rnd) {
		if (rnd->vbs_k.status == VIRTIO_DEV_INIT_SUCCESS) {
			/* VBS-K is in use */
			close(rnd->vbs_k.fd);
		}
		free(rnd);
	}
	return -1;
}
