virtio_rnd_get_entropy(void *param)
{
	struct virtio_rnd *rnd = param;
	struct virtio_vq_info *vq = &rnd->vq;
	struct iovec iov;
	uint16_t idx;
	ssize_t len;

	for (;;) {
		pthread_mutex_lock(&rnd->rx_mtx);
		rnd->in_progress = 0;

		/*
		 * Checking the avail ring here serves two purposes:
		 *  - avoid vring processing due to spurious wakeups
		 *  - catch missing notifications before acquiring rx_mtx
		 */
		while (!vq_has_descs(vq))
			pthread_cond_wait(&rnd->rx_cond, &rnd->rx_mtx);

		rnd->in_progress = 1;
		pthread_mutex_unlock(&rnd->rx_mtx);

		do {
			vq_getchain(vq, &idx, &iov, 1, NULL);
			len = read(rnd->fd, iov.iov_base, iov.iov_len);
			if (len <= 0) {
				vq_retchain(vq);
				vq_endchains(vq, 0);

				/* no data available */
				if (len == -1 && errno == EAGAIN)
					return NULL;
				break;
			}

			/* release this chain and handle more */
			vq_relchain(vq, idx, len);
		} while (vq_has_descs(vq));

		/* at least one avail ring element has been processed */
		vq_endchains(vq, 1);
	}
}
