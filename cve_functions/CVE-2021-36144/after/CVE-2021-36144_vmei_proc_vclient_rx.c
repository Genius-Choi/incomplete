vmei_proc_vclient_rx(struct vmei_host_client *hclient,
		     struct virtio_vq_info *vq)
{
	struct iovec iov[VMEI_RX_SEGS + 1];
	struct mei_msg_hdr *hdr;
	uint16_t idx = 0;
	int n, len;
	int buf_len;
	uint8_t *buf;
	bool complete = true;

	n = vq_getchain(vq, &idx, iov, VMEI_RX_SEGS, NULL);
	if (n != VMEI_RX_SEGS) {
		if (n == -1)
			pr_err("%s: fail to getchain!\n", __func__);
		else {
			pr_warn("%s: invalid chain, desc number %d!\n", __func__, n);
			vq_relchain(vq, idx, 0);
		}
		return;
	}

	len = hclient->recv_offset - hclient->recv_handled;
	HCL_DBG(hclient, "RX: DM->UOS: off=%d len=%d\n",
		hclient->recv_handled, len);

	buf_len = VMEI_BUF_SZ - sizeof(*hdr);
	hdr = (struct mei_msg_hdr *)iov[0].iov_base;
	buf = (uint8_t *)iov[0].iov_base + sizeof(*hdr);

	if (len > buf_len) {
		len = buf_len;
		complete = false;
	}

	mei_set_msg_hdr(hclient, hdr, len, complete);
	memcpy(buf, hclient->recv_buf + hclient->recv_handled, len);
	hclient->recv_handled += len;

	HCL_DBG(hclient, "RX: complete = %d DM->UOS:off=%d len=%d\n",
		complete, hclient->recv_handled, len);
	len += sizeof(struct mei_msg_hdr);

	if (complete) {
		hclient->recv_offset = 0;
		hclient->recv_handled = 0;
		if (hclient->host_addr) {
			hclient->recv_creds--;
			mevent_disable(hclient->rx_mevp);
		}
	}

	vq_relchain(vq, idx, len);
}
