vmei_start(struct virtio_mei *vmei, bool do_rescan)
{
	static struct vmei_host_client *hclient;
	const struct mei_client_properties props = {
		.protocol_name  = NULL_UUID_LE,
		.protocol_version = 0,
		.max_connections = 1,
		.fixed_address = 1,
		.single_recv_buf = 0,
		.max_msg_length = VMEI_BUF_SZ,
	};
	int pipefd[2];

	/* create HBM client (address 0) */
	if (do_rescan && !vmei->hbm_client)
		vmei->hbm_client = vmei_me_client_create(vmei, 0, &props);

	if (!vmei->hbm_client) {
		WPRINTF("hbm client creation failed\n");
		return -1;
	}

	/*
	 * create a dummy host client for the HBM client
	 * so that the HBM client will have rx/tx buffers
	 */
	hclient = vmei_host_client_create(vmei->hbm_client, 0);
	if (!hclient)
		goto hclient_failed;

	if (pipe2(pipefd, O_DIRECT) < 0)
		goto scan_failed;

	hclient->client_fd = pipefd[0];
	hclient->rx_mevp = mevent_add(hclient->client_fd, EVF_READ,
		      vmei_rx_callback, hclient, vmei_rx_teardown, hclient);
	vmei->hbm_fd = pipefd[1];

	if (do_rescan) {
		vmei_add_me_client(vmei->hbm_client);
		if (vmei_me_client_scan_list(vmei) < 0)
			goto scan_failed;
	}

	vmei_fixed_clients_connect(vmei);

	if (!do_rescan)
		vmei->config->hw_ready = 1;

	vmei_set_status(vmei, VMEI_STS_READY);

	return 0;

scan_failed:
	vmei_host_client_put(hclient);

hclient_failed:
	vmei_me_client_put(vmei->hbm_client);
	vmei->hbm_client = NULL;

	return -1;
}
