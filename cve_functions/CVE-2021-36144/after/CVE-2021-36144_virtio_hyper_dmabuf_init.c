virtio_hyper_dmabuf_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_hyper_dmabuf *hyper_dmabuf;

	kstatus = VIRTIO_DEV_PRE_INIT;
	pthread_mutexattr_t attr;
	int rc;

	hyper_dmabuf = calloc(1, sizeof(struct virtio_hyper_dmabuf));
	if (!hyper_dmabuf) {
		WPRINTF(("virtio_hdma: calloc returns NULL\n"));
		return -1;
	}

	/* init mutex attribute properly */
	rc = pthread_mutexattr_init(&attr);
	if (rc)
		DPRINTF("mutexattr init failed with erro %d!\n", rc);

	if (virtio_uses_msix()) {
		rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
		DPRINTF("virtio_msix: mutexattr_settype ");
		DPRINTF("failed with error %d!\n", rc);
	} else {
		rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
		DPRINTF("virtio_intx: mutexattr_settype ");
		DPRINTF("failed with error %d!\n", rc);
	}

	rc = pthread_mutex_init(&hyper_dmabuf->mtx, &attr);
	if (rc)
		DPRINTF("mutex init failed with error %d!\n", rc);

	virtio_linkup(&hyper_dmabuf->base,
		      &virtio_hyper_dmabuf_ops_k,
		      hyper_dmabuf,
		      dev,
		      hyper_dmabuf->vq,
		      BACKEND_VBSK);

	rc = virtio_hyper_dmabuf_k_init();
	if (rc < 0) {
		WPRINTF("virtio_hyper_dmabuf: VBS-K ");
		WPRINTF("init failed with error %d!\n", rc);
		kstatus = VIRTIO_DEV_INIT_FAILED;
	} else {
		kstatus = VIRTIO_DEV_INIT_SUCCESS;
	}

	hyper_dmabuf->base.mtx = &hyper_dmabuf->mtx;

	hyper_dmabuf->vq[0].qsize = HYPER_DMABUF_RINGSZ;
	hyper_dmabuf->vq[1].qsize = HYPER_DMABUF_RINGSZ;

	/* initialize config space */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_HYPERDMABUF);
	pci_set_cfgdata16(dev, PCIR_VENDOR, INTEL_VENDOR_ID);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_MEMORY);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_HYPERDMABUF);
	pci_set_cfgdata16(dev, PCIR_SUBVEND_0, INTEL_VENDOR_ID);

	if (virtio_interrupt_init(&hyper_dmabuf->base, virtio_uses_msix())) {
		if (hyper_dmabuf)
			free(hyper_dmabuf);
		return -1;
	}

	virtio_set_io_bar(&hyper_dmabuf->base, 0);

	return 0;
}
