virtio_gpio_proc(struct virtio_gpio *gpio, struct iovec *iov, int n)
{
	struct virtio_gpio_data *data;
	struct virtio_gpio_request *req;
	struct virtio_gpio_response *rsp;
	struct gpio_line *line;
	int i, len, rc;

	if (n == 1) { /* provide gpio names for front-end driver */
		data = iov[0].iov_base;
		len = iov[0].iov_len;
		if (len != gpio->nvline * sizeof(*data)) {
			WPRINTF(("virtio gpio, invalid virtual gpio %d\n", len));
			return 0;
		}

		for (i = 0; i < gpio->nvline; i++) {
			line = gpio->vlines[i];

			/*
			 * if the user provides the name of gpios in the
			 * command line paremeter, then provide it to UOS,
			 * otherwise provide the physical name of gpio to UOS.
			 */
			if (strnlen(line->vname, sizeof(line->vname)))
				strncpy(data[i].name, line->vname,
						sizeof(data[0].name) - 1);
			else if (strnlen(line->name, sizeof(line->name)))
				strncpy(data[i].name, line->name,
						sizeof(data[0].name) - 1);
		}
		rc = gpio->nvline;
	} else if (n == 2) { /* handle gpio operations requests */
		req = iov[0].iov_base;
		len = iov[0].iov_len;
		if (len != sizeof(*req)) {
			WPRINTF(("virtio gpio, invalid req size %d\n", len));
			return 0;
		}

		rsp = iov[1].iov_base;
		len = iov[1].iov_len;
		if (len != sizeof(*rsp)) {
			WPRINTF(("virtio gpio, invalid rsp size %d\n", len));
			return 0;
		}

		gpio_request_handler(gpio, req, rsp);
		rc = sizeof(*rsp);
	} else {
		WPRINTF(("virtio gpio: number of buffer error %d\n", n));
		rc = 0;
	}

	return rc;
}
