virtio_ipu_set_status(void *base, uint64_t status)
{

	struct virtio_ipu *ipu;
	int nvq;
	struct msix_table_entry *mte;
	uint64_t msix_addr = 0;
	uint32_t msix_data = 0;
	int rc, i, j;

	IPRINTF(LDBG, "set_status status:%ld\n", status);
	ipu = (struct virtio_ipu *) base;
	nvq = ipu->base.vops->nvq;
	if (ipu->vbs_k.ipu_kstatus == VIRTIO_DEV_INIT_SUCCESS &&
	    (status & VIRTIO_CONFIG_S_DRIVER_OK)) {
		/* time to kickoff VBS-K side */
		/* init vdev first */
		rc = virtio_ipu_k_dev_set(
				&ipu->vbs_k.ipu_kdev,
				ipu->base.vops->name,
				ipu->base.dev->vmctx->vmid,
				nvq,
				ipu->base.negotiated_caps,
				/* currently we let VBS-K handle
				 * kick register
				 */
				ipu->base.dev->bar[0].addr + 16,
				2);

		for (i = 0; i < nvq; i++) {
			if (ipu->vq[i].msix_idx !=
					VIRTIO_MSI_NO_VECTOR) {
				j = ipu->vq[i].msix_idx;
				mte = &ipu->base.dev->msix.table[j];
				msix_addr = mte->addr;
				msix_data = mte->msg_data;
			}
			rc = virtio_ipu_k_vq_set(
				&ipu->vbs_k.ipu_kvqs,
				nvq, i,
				ipu->vq[i].qsize,
				ipu->vq[i].pfn,
				ipu->vq[i].msix_idx,
				msix_addr,
				msix_data);

			if (rc < 0) {
				IPRINTF(LWRN, "kernel_set_vq failed");
				IPRINTF(LWRN, "i %d ret %d\n", i, rc);
				return;
			}
		}
		rc = virtio_ipu_k_start(ipu);
		if (rc < 0) {
			IPRINTF(LWRN, "kernel_start() failed\n");
			ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_START_FAILED;
		} else {
			ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_STARTED;
		}
	}
}
