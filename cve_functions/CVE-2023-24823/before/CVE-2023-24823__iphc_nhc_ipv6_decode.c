static size_t _iphc_nhc_ipv6_decode(gnrc_pktsnip_t *sixlo, size_t offset,
                                    const gnrc_sixlowpan_frag_rb_t *rbuf,
                                    size_t *prev_nh_offset,
                                    gnrc_pktsnip_t *ipv6,
                                    size_t *uncomp_hdr_len)
{
    uint8_t *payload = sixlo->data;
    uint8_t ipv6_nhc = payload[offset];

    switch (ipv6_nhc & NHC_IPV6_EXT_EID_MASK) {
        case NHC_IPV6_EXT_EID_HOPOPT:
        case NHC_IPV6_EXT_EID_RH:
        case NHC_IPV6_EXT_EID_FRAG:
        case NHC_IPV6_EXT_EID_DST:
        case NHC_IPV6_EXT_EID_MOB: {
            size_t tmp;
            tmp = _iphc_nhc_ipv6_ext_decode(sixlo, offset, prev_nh_offset,
                                            ipv6, uncomp_hdr_len);
            if (tmp == 0) {
                /* unable to parse IPHC header */
                return 0;
            }
            offset = tmp;
            break;
        }
        case NHC_IPV6_EXT_EID_IPV6: {
            gnrc_pktsnip_t *netif = gnrc_pktsnip_search_type(sixlo,
                                                             GNRC_NETTYPE_NETIF);
            ipv6_hdr_t *ipv6_hdr;
            uint16_t payload_len;
            size_t tmp;

            offset++;   /* move over NHC header */
            /* realloc size for uncompressed snip, if too small */
            if (ipv6->size < (*uncomp_hdr_len + sizeof(ipv6_hdr_t))) {
                if (gnrc_pktbuf_realloc_data(ipv6,
                                             *uncomp_hdr_len +
                                             sizeof(ipv6_hdr_t))) {
                    DEBUG("6lo iphc: unable to decode IPv6 encapsulated header "
                          "NHC (not enough buffer space)\n");
                    return 0;
                }
            }
            ipv6_hdr = (ipv6_hdr_t *)(((uint8_t *)ipv6->data) + *uncomp_hdr_len);
            tmp = _iphc_ipv6_decode(&payload[offset], netif->data,
                                    gnrc_netif_hdr_get_netif(netif->data),
                                    ipv6_hdr);
            if (tmp == 0) {
                /* unable to parse IPHC header */
                return 0;
            }
            ((uint8_t *)ipv6->data)[*prev_nh_offset] = PROTNUM_IPV6;
            if (payload[offset + IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {
                *prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);
            }
            else {
                /* signal end of next header compression to caller */
                *prev_nh_offset = 0;
            }
            offset += tmp;
            /* might be needed to be overwritten by IPv6 reassembly after the IPv6
             * packet was reassembled to get complete length */
            if (rbuf != NULL) {
                if (_is_rfrag(sixlo)) {
                    payload_len = (rbuf->super.datagram_size + *uncomp_hdr_len) -
                                  (sizeof(ipv6_hdr_t) - offset);
                }
                else {
                    payload_len = rbuf->super.datagram_size - *uncomp_hdr_len -
                                  sizeof(ipv6_hdr_t);
                }
            }
            else {
                payload_len = (sixlo->size + *uncomp_hdr_len) -
                              sizeof(ipv6_hdr_t) - offset;
            }
            ipv6_hdr->len = byteorder_htons(payload_len);
            *uncomp_hdr_len += sizeof(ipv6_hdr_t);
            break;
        }
        default:
            DEBUG("6lo iphc: unknown IPv6 extension header EID\n");
            break;
    }
    return offset;
}
