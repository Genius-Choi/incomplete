static size_t _iphc_nhc_udp_decode(gnrc_pktsnip_t *sixlo, size_t offset,
                                   const gnrc_sixlowpan_frag_rb_t *rbuf,
                                   size_t prev_nh_offset, gnrc_pktsnip_t *ipv6,
                                   size_t *uncomp_hdr_len)
{
    uint8_t *payload = sixlo->data;
    udp_hdr_t *udp_hdr;
    uint16_t payload_len;
    uint8_t udp_nhc = payload[offset++];
    uint8_t tmp;

    /* realloc size for uncompressed snip, if too small */
    if (ipv6->size < (*uncomp_hdr_len + sizeof(udp_hdr_t))) {
        if (gnrc_pktbuf_realloc_data(ipv6,
                                     *uncomp_hdr_len + sizeof(udp_hdr_t))) {
            DEBUG("6lo: unable to decode UDP NHC (not enough buffer space)\n");
            return 0;
        }
    }
    udp_hdr = (udp_hdr_t *)((uint8_t *)ipv6->data + *uncomp_hdr_len);
    network_uint16_t *src_port = &(udp_hdr->src_port);
    network_uint16_t *dst_port = &(udp_hdr->dst_port);

    switch (udp_nhc & NHC_UDP_PP_MASK) {

        case NHC_UDP_SD_INLINE:
            DEBUG("6lo iphc nhc: SD_INLINE\n");
            src_port->u8[0] = payload[offset++];
            src_port->u8[1] = payload[offset++];
            dst_port->u8[0] = payload[offset++];
            dst_port->u8[1] = payload[offset++];
            break;

        case NHC_UDP_S_INLINE:
            DEBUG("6lo iphc nhc: S_INLINE\n");
            src_port->u8[0] = payload[offset++];
            src_port->u8[1] = payload[offset++];
            *dst_port = byteorder_htons(payload[offset++] + NHC_UDP_8BIT_PORT);
            break;

        case NHC_UDP_D_INLINE:
            DEBUG("6lo iphc nhc: D_INLINE\n");
            *src_port = byteorder_htons(payload[offset++] + NHC_UDP_8BIT_PORT);
            dst_port->u8[0] = payload[offset++];
            dst_port->u8[1] = payload[offset++];
            break;

        case NHC_UDP_SD_ELIDED:
            DEBUG("6lo iphc nhc: SD_ELIDED\n");
            tmp = payload[offset++];
            *src_port = byteorder_htons((tmp >> 4) + NHC_UDP_4BIT_PORT);
            *dst_port = byteorder_htons((tmp & 0xf) + NHC_UDP_4BIT_PORT);
            break;

        default:
            break;
    }

    if ((udp_nhc & NHC_UDP_C_ELIDED) != 0) {
        DEBUG("6lo iphc nhc: unsupported elided checksum\n");
        return 0;
    }
    else {
        udp_hdr->checksum.u8[0] = payload[offset++];
        udp_hdr->checksum.u8[1] = payload[offset++];
    }

    /* might be needed to be overwritten by IPv6 reassembly after the IPv6
     * packet was reassembled to get complete length */
    if (rbuf != NULL) {
        if (_is_rfrag(sixlo)) {
            payload_len = rbuf->super.datagram_size + sizeof(udp_hdr_t) -
                          offset;
        }
        else {
            payload_len = rbuf->super.datagram_size - *uncomp_hdr_len;
        }
    }
    else {
        payload_len = sixlo->size + sizeof(udp_hdr_t) - offset;
    }
    udp_hdr->length = byteorder_htons(payload_len);
    *uncomp_hdr_len += sizeof(udp_hdr_t);
    ((uint8_t *)ipv6->data)[prev_nh_offset] = PROTNUM_UDP;

    return offset;
}
