static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,
                                    const gnrc_netif_hdr_t *netif_hdr,
                                    gnrc_netif_t *iface)
{
    assert(pkt != NULL);
    uint8_t *iphc_hdr;
    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;
    size_t dispatch_size = 0;
    uint16_t inline_pos = 0;
    uint8_t nh;

    dispatch = NULL;    /* use dispatch as temporary pointer for prev */
    /* determine maximum dispatch size and write protect all headers until
     * then because they will be removed */
    while ((ptr != NULL) && _compressible(ptr)) {
        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);

        if (tmp == NULL) {
            DEBUG("6lo iphc: unable to write protect compressible header\n");
            return NULL;
        }
        ptr = tmp;
        if (dispatch == NULL) {
            /* pkt was already write protected in gnrc_sixlowpan.c:_send so
             * we shouldn't do it again */
            pkt->next = ptr;    /* reset original packet */
        }
        else {
            dispatch->next = ptr;
        }
        dispatch_size += ptr->size;
        dispatch = ptr; /* use dispatch as temporary point for prev */
        ptr = ptr->next;
    }
    /* there should be at least one compressible header in `pkt`, otherwise this
     * function should not be called */
    assert(dispatch_size > 0);
    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,
                               GNRC_NETTYPE_SIXLOWPAN);

    if (dispatch == NULL) {
        DEBUG("6lo iphc: error allocating dispatch space\n");
        return NULL;
    }

    iphc_hdr = dispatch->data;
    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);

    if (inline_pos == 0) {
        DEBUG("6lo iphc: error encoding IPv6 header\n");
        gnrc_pktbuf_release(dispatch);
        return NULL;
    }

    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;
#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC
    while (_compressible_nh(nh)) {
        ssize_t local_pos = 0;
        if (pkt->next->next == NULL) {
            DEBUG("6lo iphc: packet next header missing data");
            gnrc_pktbuf_release(dispatch);
            return NULL;
        }
        switch (nh) {
            case PROTNUM_UDP:
                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);
                /* abort loop on next iteration */
                nh = PROTNUM_RESERVED;
                break;
            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */
                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,
                                                  &iphc_hdr[inline_pos], &nh);
                break;
            }
            case PROTNUM_IPV6_EXT_HOPOPT:
            case PROTNUM_IPV6_EXT_RH:
            case PROTNUM_IPV6_EXT_FRAG:
            case PROTNUM_IPV6_EXT_DST:
            case PROTNUM_IPV6_EXT_MOB:
                local_pos = _nhc_ipv6_ext_encode_snip(pkt,
                                                      &iphc_hdr[inline_pos],
                                                      &nh);
                if (local_pos == 0) {
                    /* abort loop, extension header is not compressible as
                     * length field is too large value */
                    nh = PROTNUM_RESERVED;
                }
                break;
            default:
                /* abort loop on next iteration */
                nh = PROTNUM_RESERVED;
                break;
        }
        if (local_pos < 0) {
            DEBUG("6lo iphc: error on compressing next header\n");
            gnrc_pktbuf_release(dispatch);
            return NULL;
        }
        inline_pos += local_pos;
    }
#endif

    /* shrink dispatch allocation to final size */
    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */
    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);

    /* remove IPv6 header */
    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);

    /* insert dispatch into packet */
    dispatch->next = pkt->next;
    pkt->next = dispatch;
    return pkt;
}
