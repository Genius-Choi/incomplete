static gnrc_pktsnip_t *_encode_frag_for_forwarding(gnrc_pktsnip_t *decoded_pkt,
                                                   gnrc_sixlowpan_frag_vrb_t *vrbe)
{
    gnrc_pktsnip_t *res;
    gnrc_netif_hdr_t *netif_hdr;

    /* mark IPv6 header to allow for next header compression */
    res = gnrc_pktbuf_mark(decoded_pkt, sizeof(ipv6_hdr_t), GNRC_NETTYPE_IPV6);
    if (res == NULL) {
        DEBUG("6lo iphc: unable to mark IPv6 header for forwarding\n");
        gnrc_pktbuf_release(decoded_pkt);
        return NULL;
    }
    res = gnrc_pktbuf_reverse_snips(decoded_pkt);
    if (res == NULL) {
        DEBUG("6lo iphc: unable to reverse packet for forwarding\n");
        /* decoded_pkt is released in gnrc_pktbuf_reverse_snips() */
        return NULL;
    }
    /* set netif header from VRB for correct encoding */
    netif_hdr = res->data;
    /* _iphc_encode only checks the destination address, so leave src
     * untouched */
    netif_hdr->dst_l2addr_len = vrbe->super.dst_len;
    gnrc_netif_hdr_set_dst_addr(netif_hdr, vrbe->super.dst,
                                vrbe->super.dst_len);
    gnrc_netif_hdr_set_netif(netif_hdr, vrbe->out_netif);
    decoded_pkt = res;
    if ((res = _iphc_encode(decoded_pkt, netif_hdr, vrbe->out_netif))) {
        return res;
    }
    else {
        DEBUG("6lo iphc: unable to compress packet for forwarding\n");
        gnrc_pktbuf_release(decoded_pkt);
        return NULL;
    }
}
