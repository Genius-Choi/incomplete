static int _epoll_wait(
    oe_fd_t* epoll_,
    struct oe_epoll_event* events,
    int maxevents,
    int timeout)
{
    int ret = -1;
    int retval;
    bool locked = false;
    epoll_t* epoll = _cast_epoll(epoll_);
    oe_host_fd_t host_epfd = -1;

    if (!epoll || !events || maxevents <= 0)
        OE_RAISE_ERRNO(OE_EINVAL);

    oe_errno = 0;

    if ((host_epfd = epoll_->ops.fd.get_host_fd(epoll_)) == -1)
        OE_RAISE_ERRNO(oe_errno);

    if (oe_syscall_epoll_wait_ocall(
            &retval, host_epfd, events, (unsigned int)maxevents, timeout) !=
        OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

    if (retval > 0)
    {
        if (retval > maxevents)
            OE_RAISE_ERRNO(OE_EINVAL);

        locked = true;
        oe_mutex_lock(&epoll->lock);

        for (int i = 0; i < retval; i++)
        {
            struct oe_epoll_event* const event = &events[i];
            const mapping_t* const mapping = _map_find(epoll, event->data.fd);

            if (mapping)
                event->data.u64 = mapping->event.data.u64;
            else
            {
                // fd has been deleted between the return of epoll_wait and the
                // acquisition of the lock.
                --retval;
                *event = events[retval];
                --i;
            }
        }
    }

    ret = (int)retval;

done:
    if (locked)
        oe_mutex_unlock(&epoll->lock);

    return ret;
}
