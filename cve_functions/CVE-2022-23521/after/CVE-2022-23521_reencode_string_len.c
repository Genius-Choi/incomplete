char *reencode_string_len(const char *in, size_t insz,
			  const char *out_encoding, const char *in_encoding,
			  size_t *outsz)
{
	iconv_t conv;
	char *out;
	const char *bom_str = NULL;
	size_t bom_len = 0;

	if (!in_encoding)
		return NULL;

	/* UTF-16LE-BOM is the same as UTF-16 for reading */
	if (same_utf_encoding("UTF-16LE-BOM", in_encoding))
		in_encoding = "UTF-16";

	/*
	 * For writing, UTF-16 iconv typically creates "UTF-16BE-BOM"
	 * Some users under Windows want the little endian version
	 *
	 * We handle UTF-16 and UTF-32 ourselves only if the platform does not
	 * provide a BOM (which we require), since we want to match the behavior
	 * of the system tools and libc as much as possible.
	 */
	if (same_utf_encoding("UTF-16LE-BOM", out_encoding)) {
		bom_str = utf16_le_bom;
		bom_len = sizeof(utf16_le_bom);
		out_encoding = "UTF-16LE";
	} else if (same_utf_encoding("UTF-16BE-BOM", out_encoding)) {
		bom_str = utf16_be_bom;
		bom_len = sizeof(utf16_be_bom);
		out_encoding = "UTF-16BE";
#ifdef ICONV_OMITS_BOM
	} else if (same_utf_encoding("UTF-16", out_encoding)) {
		bom_str = utf16_be_bom;
		bom_len = sizeof(utf16_be_bom);
		out_encoding = "UTF-16BE";
	} else if (same_utf_encoding("UTF-32", out_encoding)) {
		bom_str = utf32_be_bom;
		bom_len = sizeof(utf32_be_bom);
		out_encoding = "UTF-32BE";
#endif
	}

	conv = iconv_open(out_encoding, in_encoding);
	if (conv == (iconv_t) -1) {
		in_encoding = fallback_encoding(in_encoding);
		out_encoding = fallback_encoding(out_encoding);

		conv = iconv_open(out_encoding, in_encoding);
		if (conv == (iconv_t) -1)
			return NULL;
	}
	out = reencode_string_iconv(in, insz, conv, bom_len, outsz);
	iconv_close(conv);
	if (out && bom_str && bom_len)
		memcpy(out, bom_str, bom_len);
	return out;
}
