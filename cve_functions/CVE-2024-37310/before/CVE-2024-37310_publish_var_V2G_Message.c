static void publish_var_V2G_Message(v2g_connection* conn, bool is_req) {
    types::iso15118_charger::V2G_Messages v2gMessage;

    u_int8_t* tempbuff = conn->buffer;
    std::string msg_as_hex_string;
    for (int i = 0; ((tempbuff != NULL) && (i < conn->payload_len + V2GTP_HEADER_LENGTH)); i++) {
        char hex[4];
        snprintf(hex, 4, "%x", *tempbuff); // to hex
        if (std::string(hex).size() == 1)
            msg_as_hex_string += '0';
        msg_as_hex_string += hex;
        tempbuff++;
    }

    unsigned char* base64_buffer = NULL;
    size_t base64_buffer_len = 0;
    mbedtls_base64_encode(NULL, 0, &base64_buffer_len, conn->buffer, (size_t)conn->payload_len + V2GTP_HEADER_LENGTH);
    base64_buffer = static_cast<unsigned char*>(malloc(base64_buffer_len));
    if ((base64_buffer == NULL) || (mbedtls_base64_encode(base64_buffer, base64_buffer_len, &base64_buffer_len,
                                                          static_cast<unsigned char*>(conn->buffer),
                                                          (size_t)conn->payload_len + V2GTP_HEADER_LENGTH) != 0)) {
        dlog(DLOG_LEVEL_WARNING, "Unable to base64 encode EXI buffer");
    }

    v2gMessage.V2G_Message_EXI_Base64 = std::string(reinterpret_cast<char const*>(base64_buffer), base64_buffer_len);
    if (base64_buffer != NULL) {
        free(base64_buffer);
    }
    v2gMessage.V2G_Message_ID = get_V2G_Message_ID(conn->ctx->current_v2g_msg, conn->ctx->selected_protocol, is_req);
    v2gMessage.V2G_Message_EXI_Hex = msg_as_hex_string;
    conn->ctx->p_charger->publish_V2G_Messages(v2gMessage);
}
