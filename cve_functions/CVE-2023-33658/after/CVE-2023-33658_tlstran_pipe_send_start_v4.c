tlstran_pipe_send_start_v4(tlstran_pipe *p, nni_msg *msg, nni_aio *aio)
{
	nni_aio *txaio;
	nni_iov  iov[8];
	int      niov = 0;
	nni_msg  *tmsg;
	// qos default to 0 if the msg is not PUBLISH
	uint8_t  qos = 0;

	if (nni_msg_header_len(msg) <= 0 ||
	    nni_msg_get_type(msg) != CMD_PUBLISH) {
		goto send;
	}

	bool      is_sqlite = p->conf->sqlite.enable;
	int       qlen = 0, topic_len = 0;
	subinfo * tinfo = NULL, *info = NULL;
	nni_list *subinfol = p->npipe->subinfol;
	char *    topic    = nni_msg_get_pub_topic(msg, &topic_len);

	txaio = p->txaio;
	tinfo = nni_aio_get_prov_data(txaio);
	nni_aio_set_prov_data(txaio, NULL);

	// Recomposing for each msg
	// never modify the original msg
	NNI_LIST_FOREACH(subinfol, info) {
		if (tinfo != NULL && info != tinfo)
			continue;

		tinfo = NULL;

		char *sub_topic = info->topic;
		if (sub_topic[0] == '$') {
			if (0 == strncmp(sub_topic, "$share/", strlen("$share/"))) {
				sub_topic = strchr(sub_topic, '/');
				sub_topic++;
				sub_topic = strchr(sub_topic, '/');
				sub_topic++;
			}
		}
		if (false == topic_filtern(sub_topic, topic, topic_len))
			continue;
		if (niov > 4) {
			// donot send too many msgs at a time
			nni_aio_set_prov_data(txaio, info);
			break;
		}

		uint8_t * body, *header, qos_pac;
		uint8_t   var_extra[2], fixheader, tmp[4] = { 0 };
		int       len_offset = 0;
		uint32_t  pos        = 1;
		nni_pipe *pipe;
		uint16_t  pid;
		uint32_t  property_bytes = 0, property_len = 0;
		size_t    tlen, rlen, mlen, plength;

		pipe    = p->npipe;
		body    = nni_msg_body(msg);
		header  = nni_msg_header(msg);

		plength = 0;
		mlen    = nni_msg_len(msg);
		qos_pac = nni_msg_get_pub_qos(msg);
		NNI_GET16(body, tlen);

		if (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {
			// V5 to V4 shrink msg, remove property length
			// APP layer must give topic name even if topic
			// alias is set
			if (qos_pac > 0) {
				property_len = get_var_integer(
				    body + 4 + tlen, &property_bytes);

			} else {
				property_len = get_var_integer(
				    body + 2 + tlen, &property_bytes);
			}
			// V5 msg sent to V4 client
			// caculate property length and delete it

			plength = property_len + property_bytes;
		} else if (nni_msg_cmd_type(msg) == CMD_PUBLISH) {

			if (qos_pac == 0) {
				if (nni_msg_header_len(msg) > 0) {
					iov[niov].iov_buf = nni_msg_header(msg);
					iov[niov].iov_len = nni_msg_header_len(msg);
					niov++;
				}
				if (nni_msg_len(msg) > 0) {
					iov[niov].iov_buf = nni_msg_body(msg);
					iov[niov].iov_len = nni_msg_len(msg);
					niov++;
				}
				// save time & space for QoS 0 publish
				continue;
			}
		}

		qos = info->qos;
		log_trace("qos_pac %d sub %d\n", qos_pac, qos);
		fixheader = *header;
		// get final qos
		qos = qos_pac > qos ? qos : qos_pac;

		// alter qos according to sub qos
		if (qos_pac > qos) {
			if (qos == 1) {
				// set qos to 1
				fixheader = fixheader & 0xF9;
				fixheader = fixheader | 0x02;
			} else {
				// set qos to 0
				fixheader = fixheader & 0xF9;
				len_offset   = len_offset - 2;
			}
		}
		// copy remaining length
		rlen = put_var_integer(
		    tmp, get_var_integer(header, &pos) + len_offset - plength);
		*(p->qos_buf + qlen) = fixheader;
		//rlen : max 4 bytes
		memcpy(p->qos_buf+1+qlen, tmp, rlen);

		// 1st part of variable header: topic
		len_offset = 0;      // now use it to indicates the pid length
		// packet id
		if (qos > 0) {
			// set pid
			len_offset = 2;
			nni_msg *old;
			// to differ resend msg
			pid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);
			if (pid == 0) {
				// first time send this msg
				pid = nni_pipe_inc_packetid(pipe);
				// store msg for qos retrying
				nni_msg_clone(msg);
				if ((old = nni_qos_db_get(is_sqlite,
				         pipe->nano_qos_db, pipe->p_id,
				         pid)) != NULL) {
					// TODO packetid already exists.
					// do we need to replace old with new
					// one ? print warning to users
					log_error("packet id duplicates in "
					          "nano_qos_db");

					nni_qos_db_remove_msg(is_sqlite,
					    pipe->nano_qos_db, old);
				}
				old = msg;
				nni_qos_db_set(is_sqlite, pipe->nano_qos_db,
				    pipe->p_id, pid, old);
				nni_qos_db_remove_oldest(is_sqlite,
				    pipe->nano_qos_db,
				    p->conf->sqlite.disk_cache_size);
			}
			NNI_PUT16(var_extra, pid);
		} else if (qos_pac > 0) {
			len_offset += 2;
		}
		// fixed header
		iov[niov].iov_buf = p->qos_buf+qlen;
		iov[niov].iov_len = 1+rlen;
		niov++;
		qlen += rlen + 1;
		// topic + tlen
		iov[niov].iov_buf = body;
		iov[niov].iov_len = 2+tlen;
		niov++;
		// packet id if any
		if (qos > 0) {
			// copy packet id
			memcpy(p->qos_buf + 5 + qlen, var_extra, 2);
			iov[niov].iov_buf = p->qos_buf + 5 + qlen;
			iov[niov].iov_len = 2;
			niov++;
			qlen += 2;
		}
		// variable header + payload
		if (mlen > 0) {
			// determine if it needs to skip packet id field
			iov[niov].iov_buf =
			    body + 2 + tlen + len_offset + plength;
			iov[niov].iov_len =
			    mlen - 2 - len_offset - tlen - plength;
			niov++;
		}
	}

	nni_msg_alloc(&tmsg, 0);
	// apending directly
	for (int i = 0; i < niov; i++) {
		nni_msg_append(tmsg, iov[i].iov_buf, iov[i].iov_len);
	}
	// tls_common only send 1 iov each time
	// to avoid of racing we alloc a new msg for tls
	iov[0].iov_buf = nni_msg_body(tmsg);
	iov[0].iov_len = nni_msg_len(tmsg);
	nni_aio_set_msg(txaio, tmsg);
	nni_aio_set_iov(txaio, 1, iov);

	nng_stream_send(p->conn, txaio);
	return;

send:
	// have to alloc new msg due to TLS doesn't support scatter
	nni_msg_alloc(&tmsg, 0);
	txaio = p->txaio;
	niov  = 0;

	if (nni_msg_header_len(msg) > 0) {
		nni_msg_append(
		    tmsg, nni_msg_header(msg), nni_msg_header_len(msg));
	}
	if (nni_msg_len(msg) > 0) {
		nni_msg_append(tmsg, nni_msg_body(msg), nni_msg_len(msg));
	}
	iov[0].iov_buf = nni_msg_body(tmsg);
	iov[0].iov_len = nni_msg_len(tmsg);
	nni_aio_set_msg(txaio, tmsg);
	nni_aio_set_iov(txaio, 1, iov);
	nng_stream_send(p->conn, txaio);
}
