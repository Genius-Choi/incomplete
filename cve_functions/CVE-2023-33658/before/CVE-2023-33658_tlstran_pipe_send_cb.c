tlstran_pipe_send_cb(void *arg)
{
	tlstran_pipe *p = arg;
	int           rv;
	nni_aio *     aio;
	uint8_t *     header;
	uint8_t       flag = 0, cmd;
	size_t        n;
	nni_msg *     msg;
	nni_aio *     txaio = p->txaio;

	nni_mtx_lock(&p->mtx);
	aio = nni_list_first(&p->sendq);

	log_trace("############### tlstran_pipe_send_cb ################");

	if ((rv = nni_aio_result(txaio)) != 0) {
		log_warn(" send aio error %s", nng_strerror(rv));
		nni_pipe_bump_error(p->npipe, rv);
		nni_aio_list_remove(aio);
		nni_mtx_unlock(&p->mtx);
		nni_aio_finish_error(aio, rv);
		return;
	}

	n = nni_aio_count(txaio);
	nni_aio_iov_advance(txaio, n);
	log_trace("tls over tcp socket sent %ld bytes iov %ld", n,
	    nni_aio_iov_count(txaio));

	if (nni_aio_iov_count(txaio) > 0) {
		nng_stream_send(p->conn, txaio);
		nni_mtx_unlock(&p->mtx);
		return;
	}
	msg = nni_aio_get_msg(txaio);
	nni_aio_set_msg(txaio, NULL);
	if (msg != NULL) {
		nni_msg_free(msg);
	}
	msg = nni_aio_get_msg(aio);

	if (nni_aio_get_prov_data(txaio) != NULL) {
		// msgs left behind due to multiple topics matched
		if (p->tcp_cparam->pro_ver == 4)
			tlstran_pipe_send_start_v4(p, msg, txaio);
		else if (p->tcp_cparam->pro_ver == 5)
			tlstran_pipe_send_start_v5(p, msg, txaio);
		nni_mtx_unlock(&p->mtx);
		return;
	}

	nni_aio_list_remove(aio);
	tlstran_pipe_send_start(p);

	if (msg == NULL) {
		nni_mtx_unlock(&p->mtx);
		// msg is lost due to flow control
		nni_aio_set_msg(aio, NULL);
		nni_aio_finish_sync(aio, 0, 0);
		return;
	}

	n   = nni_msg_len(msg);
	cmd = nni_msg_cmd_type(msg);
	if (cmd == CMD_CONNACK) {
		header = nni_msg_header(msg);
		// parse result code TODO verify bug
		flag = header[3];
	}
	// nni_pipe_bump_tx(p->npipe, n);
	nni_mtx_unlock(&p->mtx);

	nni_aio_set_msg(aio, NULL);
	nni_msg_free(msg);
	if (cmd == CMD_CONNACK && flag != 0x00) {
		nni_aio_finish_error(aio, flag);
	} else if (cmd == CMD_DISCONNECT) {
		nni_aio_finish_error(aio, NNG_ECLOSED);
	} else {
		nni_aio_finish_sync(aio, 0, n);
	}
}
