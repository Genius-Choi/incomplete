wstran_pipe_send_start_v4(ws_pipe *p, nni_msg *msg, nni_aio *aio)
{
	nni_msg *smsg;
	int       niov;
	nni_iov   iov[8];
	nni_pipe *pipe = p->npipe;
	uint8_t   qos;


	if (nni_msg_get_type(msg) != CMD_PUBLISH)
		goto send;

	// never modify the original msg
	uint8_t *     body, *header, qos_pac;
	int           len_offset = 0;
	uint16_t      pid;
	uint32_t      prop_bytes = 0, property_len = 0;
	size_t        tlen, rlen, mlen, qlength, plength;
	bool          is_sqlite = p->conf->sqlite.enable;

	body    = nni_msg_body(msg);
	header  = nni_msg_header(msg);
	niov    = 0;
	qlength = 0;
	plength = 0;
	mlen    = nni_msg_len(msg);
	qos_pac = nni_msg_get_pub_qos(msg);
	NNI_GET16(body, tlen);

	subinfo *info, *tinfo=NULL;
	nni_msg_alloc(&smsg, 0);
	if (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {
		// V5 to V4 shrink msg, remove property length
		// APP layer must give topic name even if topic
		// alias is set
		if (qos_pac > 0) {
			property_len =
			    get_var_integer(body + 4 + tlen, &prop_bytes);

		} else {
			property_len =
			    get_var_integer(body + 2 + tlen, &prop_bytes);
		}
		plength       = property_len + prop_bytes;
	}

	NNI_LIST_FOREACH (p->npipe->subinfol, info) {
		if (tinfo != NULL && info != tinfo ) {
			continue;
		}
		tinfo = NULL;
		len_offset=0;
		char *sub_topic = info->topic;
		if (sub_topic[0] == '$') {
			if (0 == strncmp(sub_topic, "$share/", strlen("$share/"))) {
				sub_topic = strchr(sub_topic, '/');
				sub_topic++;
				sub_topic = strchr(sub_topic, '/');
				sub_topic++;
			}
		}
		if (topic_filtern(sub_topic, (char*)(body + 2), tlen)) {
			uint8_t  var_extra[2], fixheader, tmp[4] = { 0 };
			uint32_t pos = 1;
			qos          = info->qos;
			fixheader    = *header;

			// get final qos
			qos = qos_pac > qos ? qos : qos_pac;

			// alter qos according to sub qos
			if (qos_pac > qos) {
				if (qos == 1) {
					// set qos to 1
					fixheader = fixheader & 0xF9;
					fixheader = fixheader | 0x02;
				} else {
					// set qos to 0
					fixheader = fixheader & 0xF9;
					len_offset   = len_offset - 2;
				}
			}
			// fixed header + remaining length
			rlen = put_var_integer(tmp,
			    get_var_integer(header, &pos) + len_offset -
			        plength);
			*(p->qos_buf + qlength) = fixheader;
			// copy remaining length
			memcpy(p->qos_buf + qlength + 1, tmp, rlen);
			iov[niov].iov_buf = p->qos_buf + qlength;
			iov[niov].iov_len = rlen + 1;
			niov++;
			qlength += rlen + 1;
			// 1st part of variable header: topic + topic len
			iov[niov].iov_buf = body;
			iov[niov].iov_len = tlen+2;
			niov++;
			// len to indicate the offset in packet
			len_offset = 0;
			if (qos > 0) {
				// set pid
				len_offset = 2;
				nni_msg *old;
				// packetid in aio to differ resend msg
				// TODO replace it with set prov data
				pid = (uint16_t)(size_t) nni_aio_get_prov_data(aio);
				if (pid == 0) {
					// first time send this msg
					pid = nni_pipe_inc_packetid(pipe);
					// store msg for qos retrying
					nni_msg_clone(msg);
					if ((old = nni_qos_db_get(is_sqlite,
					         pipe->nano_qos_db, pipe->p_id,
					         pid)) != NULL) {
						// TODO packetid already
						// exists. we need to
						// replace old with new one
						// print warning to users
						nni_println("ERROR: packet id "
						            "duplicates in "
						            "nano_qos_db");
						nni_qos_db_remove_msg(
						    is_sqlite,
						    pipe->nano_qos_db, old);
					}
					old = msg;
					nni_qos_db_set(is_sqlite,
					    pipe->nano_qos_db, pipe->p_id, pid,
					    old);
					nni_qos_db_remove_oldest(is_sqlite,
					    pipe->nano_qos_db,
					    p->conf->sqlite.disk_cache_size);
				}
				NNI_PUT16(var_extra, pid);
				// copy packet id
				memcpy(p->qos_buf + qlength, var_extra, 2);
			} else if (qos_pac > 0) {
				//ignore the packet id of original packet
				len_offset += 2;
			}
			// 2nd part of variable header: pid
			iov[niov].iov_buf = p->qos_buf + qlength;
			iov[niov].iov_len = qos > 0 ? 2 : 0;
			niov++;
			qlength += qos > 0 ? 2 : 0;
			// body
			iov[niov].iov_buf = body + 2 + tlen + len_offset + plength;
			iov[niov].iov_len = mlen - 2 - len_offset - tlen - plength;
			niov++;
			// apending directly
			for (int i = 0; i < niov; i++) {
				nni_msg_append(
				    smsg, iov[i].iov_buf, iov[i].iov_len);
			}
			niov = 0;
		}
	}

	// duplicated msg is gonna be freed by http. so we free old one
	// here
	nni_msg_free(msg);
	msg = smsg;

// normal sending if it is not PUBLISH
send:
	nni_aio_set_msg(aio, msg);
	nni_aio_set_msg(p->txaio, msg);
	nni_aio_set_msg(aio, NULL);
	// verify connect
	// for websocket, cmd type is 0x00 for PUBLISH
	if (nni_msg_cmd_type(msg) == CMD_CONNACK) {
		uint8_t *header = nni_msg_header(msg);
		if (*(header + 3) != 0x00) {
			nni_pipe_close(p->npipe);
		}
	}
	nng_stream_send(p->ws, p->txaio);
}
