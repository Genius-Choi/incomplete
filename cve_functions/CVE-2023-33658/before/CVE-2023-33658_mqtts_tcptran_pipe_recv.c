mqtts_tcptran_pipe_recv(void *arg, nni_aio *aio)
{
	mqtts_tcptran_pipe *p = arg;
	int                 rv;

	if (nni_aio_begin(aio) != 0) {
		return;
	}
	nni_mtx_lock(&p->mtx);
	if ((rv = nni_aio_schedule(aio, mqtts_tcptran_pipe_recv_cancel, p)) !=
	    0) {
		nni_mtx_unlock(&p->mtx);
		nni_aio_finish_error(aio, rv);
		return;
	}
#ifdef NNG_HAVE_MQTT_BROKER
	if (p->connack != NULL) {
		nni_aio_set_msg(aio, p->connack);
		nni_msg_set_conn_param(p->connack, p->cparam);
		p->connack = NULL;
		nni_mtx_unlock(&p->mtx);
		nni_aio_finish(aio, 0, 0);
		return;
	}
#endif
	nni_list_append(&p->recvq, aio);
	if (nni_list_first(&p->recvq) == aio) {
		mqtts_tcptran_pipe_recv_start(p);
	}
	nni_mtx_unlock(&p->mtx);
}
