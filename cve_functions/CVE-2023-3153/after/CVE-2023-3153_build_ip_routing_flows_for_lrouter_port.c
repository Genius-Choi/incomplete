build_ip_routing_flows_for_lrouter_port(
        struct ovn_port *op, const struct hmap *ports, struct hmap *lflows)
{
    if (op->nbrp) {

        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {
            add_route(lflows, op->od, op, op->lrp_networks.ipv4_addrs[i].addr_s,
                      op->lrp_networks.ipv4_addrs[i].network_s,
                      op->lrp_networks.ipv4_addrs[i].plen, NULL, false, 0,
                      &op->nbrp->header_, false, ROUTE_PRIO_OFFSET_CONNECTED);
        }

        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {
            add_route(lflows, op->od, op, op->lrp_networks.ipv6_addrs[i].addr_s,
                      op->lrp_networks.ipv6_addrs[i].network_s,
                      op->lrp_networks.ipv6_addrs[i].plen, NULL, false, 0,
                      &op->nbrp->header_, false, ROUTE_PRIO_OFFSET_CONNECTED);
        }
    } else if (lsp_is_router(op->nbsp)) {
        struct ovn_port *peer = ovn_port_get_peer(ports, op);
        if (!peer || !peer->nbrp || !peer->lrp_networks.n_ipv4_addrs) {
            return;
        }

        for (int i = 0; i < op->od->n_router_ports; i++) {
            struct ovn_port *router_port = ovn_port_get_peer(
                    ports, op->od->router_ports[i]);
            if (!router_port || !router_port->nbrp || router_port == peer) {
                continue;
            }

            struct ovn_port_routable_addresses *ra = &router_port->routables;
            for (size_t j = 0; j < ra->n_addrs; j++) {
                struct lport_addresses *laddrs = &ra->laddrs[j];
                for (size_t k = 0; k < laddrs->n_ipv4_addrs; k++) {
                    add_route(lflows, peer->od, peer,
                              peer->lrp_networks.ipv4_addrs[0].addr_s,
                              laddrs->ipv4_addrs[k].network_s,
                              laddrs->ipv4_addrs[k].plen, NULL, false, 0,
                              &peer->nbrp->header_, false,
                              ROUTE_PRIO_OFFSET_CONNECTED);
                }
            }
        }
    }
}
