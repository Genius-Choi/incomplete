build_lrouter_flows_for_lb(struct ovn_northd_lb *lb, struct hmap *lflows,
                           const struct shash *meter_groups,
                           const struct chassis_features *features,
                           struct ds *match, struct ds *action)
{
    size_t index;

    if (!lb->n_nb_lr) {
        return;
    }

    for (size_t i = 0; i < lb->n_vips; i++) {
        struct ovn_lb_vip *lb_vip = &lb->vips[i];

        build_lrouter_nat_flows_for_lb(lb_vip, lb, &lb->vips_nb[i],
                                       lflows, match, action, meter_groups,
                                       features);

        if (!build_empty_lb_event_flow(lb_vip, lb, match, action)) {
            continue;
        }

        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {
            struct ovn_datapath *od = datapaths_array[index];

            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_DNAT,
                                      130, ds_cstr(match), ds_cstr(action),
                                      NULL,
                                      copp_meter_get(COPP_EVENT_ELB,
                                                     od->nbr->copp,
                                                     meter_groups),
                                      &lb->nlb->header_);
        }
    }

    if (lb->skip_snat) {
        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {
            struct ovn_datapath *od = datapaths_array[index];

            ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 120,
                          "flags.skip_snat_for_lb == 1 && ip", "next;");
        }
    }
}
