void build_lflows(struct lflow_input *input_data,
                  struct ovsdb_idl_txn *ovnsb_txn)
{
    struct hmap lflows;
    struct hmap mcast_groups;
    struct hmap igmp_groups;

    build_mcast_groups(input_data, input_data->datapaths, input_data->ports,
                       &mcast_groups, &igmp_groups);

    fast_hmap_size_for(&lflows, max_seen_lflow_size);

    build_lswitch_and_lrouter_flows(input_data->datapaths, input_data->ports,
                                    input_data->port_groups, &lflows,
                                    &mcast_groups, &igmp_groups,
                                    input_data->meter_groups, input_data->lbs,
                                    input_data->bfd_connections,
                                    input_data->features);

    if (parallelization_state == STATE_INIT_HASH_SIZES) {
        parallelization_state = STATE_USE_PARALLELIZATION;
    }

    /* Parallel build may result in a suboptimal hash. Resize the
     * hash to a correct size before doing lookups */

    hmap_expand(&lflows);

    if (hmap_count(&lflows) > max_seen_lflow_size) {
        max_seen_lflow_size = hmap_count(&lflows);
    }

    stopwatch_start(LFLOWS_DP_GROUPS_STOPWATCH_NAME, time_msec());
    /* Collecting all unique datapath groups. */
    struct hmap dp_groups = HMAP_INITIALIZER(&dp_groups);
    struct hmap single_dp_lflows;

    /* Single dp_flows will never grow bigger than lflows,
     * thus the two hmaps will remain the same size regardless
     * of how many elements we remove from lflows and add to
     * single_dp_lflows.
     * Note - lflows is always sized for at least 128 flows.
     */
    fast_hmap_size_for(&single_dp_lflows, max_seen_lflow_size);

    struct ovn_lflow *lflow;
    HMAP_FOR_EACH_SAFE (lflow, hmap_node, &lflows) {
        struct ovn_dp_group *dpg;
        uint32_t hash, n_ods;

        n_ods = bitmap_count1(lflow->dpg_bitmap, n_datapaths);

        ovs_assert(n_ods);

        if (n_ods == 1) {
            /* There is only one datapath, so it should be moved out of the
             * group to a single 'od'. */
            size_t index = bitmap_scan(lflow->dpg_bitmap, true, 0,
                                       n_datapaths);

            bitmap_set0(lflow->dpg_bitmap, index);
            lflow->od = datapaths_array[index];

            /* Logical flow should be re-hashed to allow lookups. */
            hash = hmap_node_hash(&lflow->hmap_node);
            /* Remove from lflows. */
            hmap_remove(&lflows, &lflow->hmap_node);
            hash = ovn_logical_flow_hash_datapath(&lflow->od->sb->header_.uuid,
                                                  hash);
            /* Add to single_dp_lflows. */
            hmap_insert_fast(&single_dp_lflows, &lflow->hmap_node, hash);
            continue;
        }

        hash = hash_int(n_ods, 0);
        dpg = ovn_dp_group_find(&dp_groups, lflow->dpg_bitmap, hash);
        if (!dpg) {
            dpg = xzalloc(sizeof *dpg);
            dpg->bitmap = bitmap_clone(lflow->dpg_bitmap, n_datapaths);
            hmap_insert(&dp_groups, &dpg->node, hash);
        }
        lflow->dpg = dpg;
    }

    /* Merge multiple and single dp hashes. */

    fast_hmap_merge(&lflows, &single_dp_lflows);

    hmap_destroy(&single_dp_lflows);

    stopwatch_stop(LFLOWS_DP_GROUPS_STOPWATCH_NAME, time_msec());
    stopwatch_start(LFLOWS_TO_SB_STOPWATCH_NAME, time_msec());

    /* Push changes to the Logical_Flow table to database. */
    const struct sbrec_logical_flow *sbflow;
    SBREC_LOGICAL_FLOW_TABLE_FOR_EACH_SAFE (sbflow,
                                     input_data->sbrec_logical_flow_table) {
        struct sbrec_logical_dp_group *dp_group = sbflow->logical_dp_group;
        struct ovn_datapath *logical_datapath_od = NULL;
        size_t i;

        /* Find one valid datapath to get the datapath type. */
        struct sbrec_datapath_binding *dp = sbflow->logical_datapath;
        if (dp) {
            logical_datapath_od = ovn_datapath_from_sbrec(
                                            input_data->datapaths, dp);
            if (logical_datapath_od
                && ovn_datapath_is_stale(logical_datapath_od)) {
                logical_datapath_od = NULL;
            }
        }
        for (i = 0; dp_group && i < dp_group->n_datapaths; i++) {
            logical_datapath_od = ovn_datapath_from_sbrec(
                             input_data->datapaths, dp_group->datapaths[i]);
            if (logical_datapath_od
                && !ovn_datapath_is_stale(logical_datapath_od)) {
                break;
            }
            logical_datapath_od = NULL;
        }

        if (!logical_datapath_od) {
            /* This lflow has no valid logical datapaths. */
            sbrec_logical_flow_delete(sbflow);
            continue;
        }

        enum ovn_pipeline pipeline
            = !strcmp(sbflow->pipeline, "ingress") ? P_IN : P_OUT;

        lflow = ovn_lflow_find(
            &lflows, dp_group ? NULL : logical_datapath_od,
            ovn_stage_build(ovn_datapath_get_type(logical_datapath_od),
                            pipeline, sbflow->table_id),
            sbflow->priority, sbflow->match, sbflow->actions,
            sbflow->controller_meter, sbflow->hash);
        if (lflow) {
            if (input_data->ovn_internal_version_changed) {
                const char *stage_name = smap_get_def(&sbflow->external_ids,
                                                  "stage-name", "");
                const char *stage_hint = smap_get_def(&sbflow->external_ids,
                                                  "stage-hint", "");
                const char *source = smap_get_def(&sbflow->external_ids,
                                                  "source", "");

                if (strcmp(stage_name, ovn_stage_to_str(lflow->stage))) {
                    sbrec_logical_flow_update_external_ids_setkey(sbflow,
                     "stage-name", ovn_stage_to_str(lflow->stage));
                }
                if (lflow->stage_hint) {
                    if (strcmp(stage_hint, lflow->stage_hint)) {
                        sbrec_logical_flow_update_external_ids_setkey(sbflow,
                        "stage-hint", lflow->stage_hint);
                    }
                }
                if (lflow->where) {
                    if (strcmp(source, lflow->where)) {
                        sbrec_logical_flow_update_external_ids_setkey(sbflow,
                        "source", lflow->where);
                    }
                }
            }

            /* This is a valid lflow.  Checking if the datapath group needs
             * updates. */
            bool update_dp_group = false;

            if ((!lflow->dpg && dp_group) || (lflow->dpg && !dp_group)) {
                /* Need to add or delete datapath group. */
                update_dp_group = true;
            } else if (!lflow->dpg && !dp_group) {
                /* No datapath group and not needed. */
            } else if (lflow->dpg->dp_group) {
                /* We know the datapath group in Sb that should be used. */
                if (lflow->dpg->dp_group != dp_group) {
                    /* Flow has different datapath group in the database.  */
                    update_dp_group = true;
                }
                /* Datapath group is already up to date. */
            } else {
                /* There is a datapath group and we need to perform
                 * a full comparison. */
                unsigned long *dpg_bitmap;
                struct ovn_datapath *od;

                dpg_bitmap = bitmap_allocate(n_datapaths);
                /* Check all logical datapaths from the group. */
                for (i = 0; i < dp_group->n_datapaths; i++) {
                    od = ovn_datapath_from_sbrec(
                            input_data->datapaths, dp_group->datapaths[i]);
                    if (!od || ovn_datapath_is_stale(od)) {
                        continue;
                    }
                    bitmap_set1(dpg_bitmap, od->index);
                }

                update_dp_group = !bitmap_equal(dpg_bitmap, lflow->dpg_bitmap,
                                                n_datapaths);
                bitmap_free(dpg_bitmap);
            }

            if (update_dp_group) {
                ovn_sb_set_lflow_logical_dp_group(ovnsb_txn, &dp_groups,
                                                  sbflow, lflow->dpg_bitmap);
            } else if (lflow->dpg && !lflow->dpg->dp_group) {
                /* Setting relation between unique datapath group and
                 * Sb DB datapath goup. */
                lflow->dpg->dp_group = dp_group;
            }

            /* This lflow updated.  Not needed anymore. */
            ovn_lflow_destroy(&lflows, lflow);
        } else {
            sbrec_logical_flow_delete(sbflow);
        }
    }

    HMAP_FOR_EACH_SAFE (lflow, hmap_node, &lflows) {
        const char *pipeline = ovn_stage_get_pipeline_name(lflow->stage);
        uint8_t table = ovn_stage_get_table(lflow->stage);

        sbflow = sbrec_logical_flow_insert(ovnsb_txn);
        if (lflow->od) {
            sbrec_logical_flow_set_logical_datapath(sbflow, lflow->od->sb);
        }
        ovn_sb_set_lflow_logical_dp_group(ovnsb_txn, &dp_groups,
                                          sbflow, lflow->dpg_bitmap);
        sbrec_logical_flow_set_pipeline(sbflow, pipeline);
        sbrec_logical_flow_set_table_id(sbflow, table);
        sbrec_logical_flow_set_priority(sbflow, lflow->priority);
        sbrec_logical_flow_set_match(sbflow, lflow->match);
        sbrec_logical_flow_set_actions(sbflow, lflow->actions);
        if (lflow->io_port) {
            struct smap tags = SMAP_INITIALIZER(&tags);
            smap_add(&tags, "in_out_port", lflow->io_port);
            sbrec_logical_flow_set_tags(sbflow, &tags);
            smap_destroy(&tags);
        }
        sbrec_logical_flow_set_controller_meter(sbflow, lflow->ctrl_meter);

        /* Trim the source locator lflow->where, which looks something like
         * "ovn/northd/northd.c:1234", down to just the part following the
         * last slash, e.g. "northd.c:1234". */
        const char *slash = strrchr(lflow->where, '/');
#if _WIN32
        const char *backslash = strrchr(lflow->where, '\\');
        if (!slash || backslash > slash) {
            slash = backslash;
        }
#endif
        const char *where = slash ? slash + 1 : lflow->where;

        struct smap ids = SMAP_INITIALIZER(&ids);
        smap_add(&ids, "stage-name", ovn_stage_to_str(lflow->stage));
        smap_add(&ids, "source", where);
        if (lflow->stage_hint) {
            smap_add(&ids, "stage-hint", lflow->stage_hint);
        }
        sbrec_logical_flow_set_external_ids(sbflow, &ids);
        smap_destroy(&ids);

        ovn_lflow_destroy(&lflows, lflow);
    }
    hmap_destroy(&lflows);

    stopwatch_stop(LFLOWS_TO_SB_STOPWATCH_NAME, time_msec());
    struct ovn_dp_group *dpg;
    HMAP_FOR_EACH_POP (dpg, node, &dp_groups) {
        bitmap_free(dpg->bitmap);
        free(dpg);
    }
    hmap_destroy(&dp_groups);

    /* Push changes to the Multicast_Group table to database. */
    const struct sbrec_multicast_group *sbmc;
    SBREC_MULTICAST_GROUP_TABLE_FOR_EACH_SAFE (sbmc,
                                input_data->sbrec_multicast_group_table) {
        struct ovn_datapath *od = ovn_datapath_from_sbrec(
                               input_data->datapaths, sbmc->datapath);

        if (!od || ovn_datapath_is_stale(od)) {
            sbrec_multicast_group_delete(sbmc);
            continue;
        }

        struct multicast_group group = { .name = sbmc->name,
                                         .key = sbmc->tunnel_key };
        struct ovn_multicast *mc = ovn_multicast_find(&mcast_groups,
                                                      od, &group);
        if (mc) {
            ovn_multicast_update_sbrec(mc, sbmc);
            ovn_multicast_destroy(&mcast_groups, mc);
        } else {
            sbrec_multicast_group_delete(sbmc);
        }
    }
    struct ovn_multicast *mc;
    HMAP_FOR_EACH_SAFE (mc, hmap_node, &mcast_groups) {
        if (!mc->datapath) {
            ovn_multicast_destroy(&mcast_groups, mc);
            continue;
        }
        sbmc = sbrec_multicast_group_insert(ovnsb_txn);
        sbrec_multicast_group_set_datapath(sbmc, mc->datapath->sb);
        sbrec_multicast_group_set_name(sbmc, mc->group->name);
        sbrec_multicast_group_set_tunnel_key(sbmc, mc->group->key);
        ovn_multicast_update_sbrec(mc, sbmc);
        ovn_multicast_destroy(&mcast_groups, mc);
    }

    struct ovn_igmp_group *igmp_group;

    HMAP_FOR_EACH_SAFE (igmp_group, hmap_node, &igmp_groups) {
        ovn_igmp_group_destroy(&igmp_groups, igmp_group);
    }

    hmap_destroy(&igmp_groups);
    hmap_destroy(&mcast_groups);
}
