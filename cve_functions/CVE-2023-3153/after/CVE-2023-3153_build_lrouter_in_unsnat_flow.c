build_lrouter_in_unsnat_flow(struct hmap *lflows, struct ovn_datapath *od,
                             const struct nbrec_nat *nat, struct ds *match,
                             struct ds *actions, bool distributed, bool is_v6,
                             struct ovn_port *l3dgw_port)
{
    /* Ingress UNSNAT table: It is for already established connections'
    * reverse traffic. i.e., SNAT has already been done in egress
    * pipeline and now the packet has entered the ingress pipeline as
    * part of a reply. We undo the SNAT here.
    *
    * Undoing SNAT has to happen before DNAT processing.  This is
    * because when the packet was DNATed in ingress pipeline, it did
    * not know about the possibility of eventual additional SNAT in
    * egress pipeline. */
    if (strcmp(nat->type, "snat") && strcmp(nat->type, "dnat_and_snat")) {
        return;
    }

    bool stateless = lrouter_dnat_and_snat_is_stateless(nat);
    if (od->is_gw_router) {
        ds_clear(match);
        ds_clear(actions);
        ds_put_format(match, "ip && ip%s.dst == %s",
                      is_v6 ? "6" : "4", nat->external_ip);
        if (stateless) {
            ds_put_format(actions, "next;");
        } else {
            ds_put_cstr(actions, "ct_snat;");
        }

        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,
                                90, ds_cstr(match), ds_cstr(actions),
                                &nat->header_);
    } else {
        /* Distributed router. */

        /* Traffic received on l3dgw_port is subject to NAT. */
        ds_clear(match);
        ds_clear(actions);
        ds_put_format(match, "ip && ip%s.dst == %s && inport == %s && "
                      "flags.loopback == 0", is_v6 ? "6" : "4",
                      nat->external_ip, l3dgw_port->json_key);
        if (!distributed && od->n_l3dgw_ports) {
            /* Flows for NAT rules that are centralized are only
            * programmed on the gateway chassis. */
            ds_put_format(match, " && is_chassis_resident(%s)",
                          l3dgw_port->cr_port->json_key);
        }

        if (stateless) {
            ds_put_format(actions, "next;");
        } else {
            ds_put_cstr(actions, "ct_snat_in_czone;");
        }

        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,
                                100, ds_cstr(match), ds_cstr(actions),
                                &nat->header_);

        if (!stateless) {
            ds_clear(match);
            ds_clear(actions);
            ds_put_format(match, "ip && ip%s.dst == %s && inport == %s && "
                          "flags.loopback == 1 && flags.use_snat_zone == 1",
                          is_v6 ? "6" : "4", nat->external_ip,
                          l3dgw_port->json_key);
            if (!distributed && od->n_l3dgw_ports) {
                /* Flows for NAT rules that are centralized are only
                * programmed on the gateway chassis. */
                ds_put_format(match, " && is_chassis_resident(%s)",
                            l3dgw_port->cr_port->json_key);
            }
            ds_put_cstr(actions, "ct_snat;");
            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,
                                    100, ds_cstr(match), ds_cstr(actions),
                                    &nat->header_);
        }
    }
}
