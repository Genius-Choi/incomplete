build_lrouter_lb_reachable_ips(struct ovn_datapath *od,
                               const struct ovn_northd_lb *lb)
{
    /* If configured to not reply to any neighbor requests for all VIPs
     * return early.
     */
    if (lb->neigh_mode == LB_NEIGH_RESPOND_NONE) {
        return;
    }

    /* If configured to reply to neighbor requests for all VIPs force them
     * all to be considered "reachable".
     */
    if (lb->neigh_mode == LB_NEIGH_RESPOND_ALL) {
        for (size_t i = 0; i < lb->n_vips; i++) {
            if (lb->vips[i].address_family == AF_INET) {
                sset_add(&od->lb_ips->ips_v4_reachable, lb->vips[i].vip_str);
            } else {
                sset_add(&od->lb_ips->ips_v6_reachable, lb->vips[i].vip_str);
            }
        }
        return;
    }

    /* Otherwise, a VIP is reachable if there's at least one router
     * subnet that includes it.
     */
    ovs_assert(lb->neigh_mode == LB_NEIGH_RESPOND_REACHABLE);
    for (size_t i = 0; i < lb->n_vips; i++) {
        if (lb->vips[i].address_family == AF_INET) {
            ovs_be32 vip_ip4 = in6_addr_get_mapped_ipv4(&lb->vips[i].vip);
            struct ovn_port *op;

            LIST_FOR_EACH (op, dp_node, &od->port_list) {
                if (lrouter_port_ipv4_reachable(op, vip_ip4)) {
                    sset_add(&od->lb_ips->ips_v4_reachable,
                             lb->vips[i].vip_str);
                    break;
                }
            }
        } else {
            struct ovn_port *op;

            LIST_FOR_EACH (op, dp_node, &od->port_list) {
                if (lrouter_port_ipv6_reachable(op, &lb->vips[i].vip)) {
                    sset_add(&od->lb_ips->ips_v6_reachable,
                             lb->vips[i].vip_str);
                    break;
                }
            }
        }
    }
}
