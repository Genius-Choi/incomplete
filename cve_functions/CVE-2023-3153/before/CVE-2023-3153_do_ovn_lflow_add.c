do_ovn_lflow_add(struct hmap *lflow_map, const struct ovn_datapath *od,
                 const unsigned long *dp_bitmap,
                 uint32_t hash, enum ovn_stage stage, uint16_t priority,
                 const char *match, const char *actions, const char *io_port,
                 const struct ovsdb_idl_row *stage_hint,
                 const char *where, const char *ctrl_meter)
    OVS_REQUIRES(fake_hash_mutex)
{

    struct ovn_lflow *old_lflow;
    struct ovn_lflow *lflow;

    old_lflow = ovn_lflow_find(lflow_map, NULL, stage, priority, match,
                               actions, ctrl_meter, hash);
    if (old_lflow) {
        ovn_dp_group_add_with_reference(old_lflow, od, dp_bitmap);
        return;
    }

    lflow = xmalloc(sizeof *lflow);
    /* While adding new logical flows we're not setting single datapath, but
     * collecting a group.  'od' will be updated later for all flows with only
     * one datapath in a group, so it could be hashed correctly. */
    ovn_lflow_init(lflow, NULL, stage, priority,
                   xstrdup(match), xstrdup(actions),
                   io_port ? xstrdup(io_port) : NULL,
                   nullable_xstrdup(ctrl_meter),
                   ovn_lflow_hint(stage_hint), where);

    ovn_dp_group_add_with_reference(lflow, od, dp_bitmap);

    if (parallelization_state != STATE_USE_PARALLELIZATION) {
        hmap_insert(lflow_map, &lflow->hmap_node, hash);
    } else {
        hmap_insert_fast(lflow_map, &lflow->hmap_node, hash);
        thread_lflow_counter++;
    }
}
