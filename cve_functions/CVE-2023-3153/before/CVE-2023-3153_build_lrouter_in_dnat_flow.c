build_lrouter_in_dnat_flow(struct hmap *lflows, struct ovn_datapath *od,
                           const struct nbrec_nat *nat, struct ds *match,
                           struct ds *actions, bool distributed,
                           int cidr_bits, bool is_v6,
                           struct ovn_port *l3dgw_port)
{
    /* Ingress DNAT table: Packets enter the pipeline with destination
    * IP address that needs to be DNATted from a external IP address
    * to a logical IP address. */
    if (!strcmp(nat->type, "dnat") || !strcmp(nat->type, "dnat_and_snat")) {
        bool stateless = lrouter_dnat_and_snat_is_stateless(nat);

        if (od->is_gw_router) {
            /* Packet when it goes from the initiator to destination.
             * We need to set flags.loopback because the router can
             * send the packet back through the same interface. */
            ds_clear(match);
            ds_put_format(match, "ip && ip%s.dst == %s",
                          is_v6 ? "6" : "4", nat->external_ip);
            ds_clear(actions);
            if (nat->allowed_ext_ips || nat->exempted_ext_ips) {
                lrouter_nat_add_ext_ip_match(od, lflows, match, nat,
                                             is_v6, true, cidr_bits);
            }

            if (!lport_addresses_is_empty(&od->dnat_force_snat_addrs)) {
                /* Indicate to the future tables that a DNAT has taken
                 * place and a force SNAT needs to be done in the
                 * Egress SNAT table. */
                ds_put_format(actions, "flags.force_snat_for_dnat = 1; ");
            }

            if (stateless) {
                ds_put_format(actions, "flags.loopback = 1; "
                              "ip%s.dst=%s; next;",
                              is_v6 ? "6" : "4", nat->logical_ip);
            } else {
                ds_put_format(actions, "flags.loopback = 1; ct_dnat(%s",
                              nat->logical_ip);

                if (nat->external_port_range[0]) {
                    ds_put_format(actions, ",%s", nat->external_port_range);
                }
                ds_put_format(actions, ");");
            }

            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DNAT, 100,
                                    ds_cstr(match), ds_cstr(actions),
                                    &nat->header_);
        } else {
            /* Distributed router. */

            /* Traffic received on l3dgw_port is subject to NAT. */
            ds_clear(match);
            ds_put_format(match, "ip && ip%s.dst == %s && inport == %s",
                          is_v6 ? "6" : "4", nat->external_ip,
                          l3dgw_port->json_key);
            if (!distributed && od->n_l3dgw_ports) {
                /* Flows for NAT rules that are centralized are only
                * programmed on the gateway chassis. */
                ds_put_format(match, " && is_chassis_resident(%s)",
                              l3dgw_port->cr_port->json_key);
            }
            ds_clear(actions);
            if (nat->allowed_ext_ips || nat->exempted_ext_ips) {
                lrouter_nat_add_ext_ip_match(od, lflows, match, nat,
                                             is_v6, true, cidr_bits);
            }

            if (!strcmp(nat->type, "dnat_and_snat") && stateless) {
                ds_put_format(actions, "ip%s.dst=%s; next;",
                              is_v6 ? "6" : "4", nat->logical_ip);
            } else {
                ds_put_format(actions, "ct_dnat_in_czone(%s", nat->logical_ip);
                if (nat->external_port_range[0]) {
                    ds_put_format(actions, ",%s", nat->external_port_range);
                }
                ds_put_format(actions, ");");
            }

            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DNAT, 100,
                                    ds_cstr(match), ds_cstr(actions),
                                    &nat->header_);
        }
    }
}
