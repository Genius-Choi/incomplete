ovnnb_db_run(struct northd_input *input_data,
             struct northd_data *data,
             struct ovsdb_idl_txn *ovnnb_txn,
             struct ovsdb_idl_txn *ovnsb_txn,
             struct ovsdb_idl_index *sbrec_chassis_by_name,
             struct ovsdb_idl_index *sbrec_chassis_by_hostname)
{
    if (!ovnsb_txn || !ovnnb_txn) {
        return;
    }
    stopwatch_start(BUILD_LFLOWS_CTX_STOPWATCH_NAME, time_msec());

    /* Sync ipsec configuration.
     * Copy nb_cfg from northbound to southbound database.
     * Also set up to update sb_cfg once our southbound transaction commits. */
    const struct nbrec_nb_global *nb = nbrec_nb_global_table_first(
                                       input_data->nbrec_nb_global_table);
    if (!nb) {
        nb = nbrec_nb_global_insert(ovnnb_txn);
    }

    const char *mac_addr_prefix = set_mac_prefix(smap_get(&nb->options,
                                                          "mac_prefix"));

    const char *monitor_mac = smap_get(&nb->options, "svc_monitor_mac");
    if (monitor_mac) {
        if (eth_addr_from_string(monitor_mac, &svc_monitor_mac_ea)) {
            snprintf(svc_monitor_mac, sizeof svc_monitor_mac,
                     ETH_ADDR_FMT, ETH_ADDR_ARGS(svc_monitor_mac_ea));
        } else {
            monitor_mac = NULL;
        }
    }

    struct smap options;
    smap_clone(&options, &nb->options);

    smap_replace(&options, "mac_prefix", mac_addr_prefix);

    if (!monitor_mac) {
        eth_addr_random(&svc_monitor_mac_ea);
        snprintf(svc_monitor_mac, sizeof svc_monitor_mac,
                 ETH_ADDR_FMT, ETH_ADDR_ARGS(svc_monitor_mac_ea));
        smap_replace(&options, "svc_monitor_mac", svc_monitor_mac);
    }

    char *max_tunid = xasprintf("%d", get_ovn_max_dp_key_local(input_data));
    smap_replace(&options, "max_tunid", max_tunid);
    free(max_tunid);

    char *ovn_internal_version = ovn_get_internal_version();
    if (!strcmp(ovn_internal_version,
                smap_get_def(&options, "northd_internal_version", ""))) {
        data->ovn_internal_version_changed = false;
    } else {
        smap_replace(&options, "northd_internal_version",
                     ovn_internal_version);
    }
    free(ovn_internal_version);

    if (!smap_equal(&nb->options, &options)) {
        nbrec_nb_global_verify_options(nb);
        nbrec_nb_global_set_options(nb, &options);
    }

    use_ct_inv_match = smap_get_bool(&nb->options,
                                     "use_ct_inv_match", true);

    /* deprecated, use --event instead */
    controller_event_en = smap_get_bool(&nb->options,
                                        "controller_event", false);
    check_lsp_is_up = !smap_get_bool(&nb->options,
                                     "ignore_lsp_down", true);
    default_acl_drop = smap_get_bool(&nb->options, "default_acl_drop", false);

    install_ls_lb_from_router = smap_get_bool(&nb->options,
                                              "install_ls_lb_from_router",
                                              false);

    build_chassis_features(input_data, &data->features);

    init_debug_config(nb);

    build_datapaths(input_data, ovnsb_txn, &data->datapaths, &data->lr_list);
    build_lbs(input_data, &data->datapaths, &data->lbs, &data->lb_groups);
    build_ports(input_data, ovnsb_txn, sbrec_chassis_by_name,
                sbrec_chassis_by_hostname,
                &data->datapaths, &data->ports);
    build_lb_port_related_data(&data->datapaths, &data->ports, &data->lbs,
                               &data->lb_groups, input_data, ovnsb_txn);
    build_lb_count_dps(&data->lbs);
    build_ipam(&data->datapaths, &data->ports);
    build_port_group_lswitches(input_data, &data->port_groups, &data->ports);
    build_lrouter_groups(&data->ports, &data->lr_list);
    build_ip_mcast(input_data, ovnsb_txn, &data->datapaths);
    build_meter_groups(input_data, &data->meter_groups);
    build_static_mac_binding_table(input_data, ovnsb_txn, &data->ports);
    stopwatch_stop(BUILD_LFLOWS_CTX_STOPWATCH_NAME, time_msec());
    stopwatch_start(CLEAR_LFLOWS_CTX_STOPWATCH_NAME, time_msec());
    ovn_update_ipv6_options(&data->ports);
    ovn_update_ipv6_prefix(&data->ports);

    sync_lbs(input_data, ovnsb_txn, &data->datapaths, &data->lbs);
    sync_port_groups(input_data, ovnsb_txn, &data->port_groups);
    sync_meters(input_data, ovnsb_txn, &data->meter_groups);
    sync_mirrors(input_data, ovnsb_txn);
    sync_dns_entries(input_data, ovnsb_txn, &data->datapaths);
    sync_template_vars(input_data, ovnsb_txn);

    cleanup_stale_fdb_entries(input_data, &data->datapaths);
    stopwatch_stop(CLEAR_LFLOWS_CTX_STOPWATCH_NAME, time_msec());

    /* Set up SB_Global (depends on chassis features). */
    const struct sbrec_sb_global *sb = sbrec_sb_global_table_first(
                                       input_data->sbrec_sb_global_table);
    if (!sb) {
        sb = sbrec_sb_global_insert(ovnsb_txn);
    }
    if (nb->ipsec != sb->ipsec) {
        sbrec_sb_global_set_ipsec(sb, nb->ipsec);
    }

    /* Inform ovn-controllers whether LB flows will use ct_mark (i.e., only
     * if all chassis support it).  If not explicitly present in the database
     * the default value to be used for this option is 'true'.
     */
    if (!data->features.ct_no_masked_label) {
        smap_replace(&options, "lb_hairpin_use_ct_mark", "false");
    } else {
        smap_remove(&options, "lb_hairpin_use_ct_mark");
    }
    if (!smap_equal(&sb->options, &options)) {
        sbrec_sb_global_set_options(sb, &options);
    }
    smap_destroy(&options);
}
