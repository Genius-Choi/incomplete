build_lbs(struct northd_input *input_data, struct hmap *datapaths,
          struct hmap *lbs, struct hmap *lb_groups)
{
    const struct nbrec_load_balancer_group *nbrec_lb_group;
    struct ovn_lb_group *lb_group;
    struct ovn_northd_lb *lb;

    hmap_init(lbs);
    hmap_init(lb_groups);

    const struct nbrec_load_balancer *nbrec_lb;
    NBREC_LOAD_BALANCER_TABLE_FOR_EACH (nbrec_lb,
                               input_data->nbrec_load_balancer_table) {
        struct ovn_northd_lb *lb_nb = ovn_northd_lb_create(nbrec_lb,
                                                           n_datapaths);
        hmap_insert(lbs, &lb_nb->hmap_node,
                    uuid_hash(&nbrec_lb->header_.uuid));
    }

    NBREC_LOAD_BALANCER_GROUP_TABLE_FOR_EACH (nbrec_lb_group,
                               input_data->nbrec_load_balancer_group_table) {
        lb_group = ovn_lb_group_create(nbrec_lb_group, lbs,
                                       hmap_count(datapaths));

        for (size_t i = 0; i < lb_group->n_lbs; i++) {
            build_lrouter_lb_ips(lb_group->lb_ips, lb_group->lbs[i]);
        }

        hmap_insert(lb_groups, &lb_group->hmap_node,
                    uuid_hash(&lb_group->uuid));
    }

    struct ovn_datapath *od;
    HMAP_FOR_EACH (od, key_node, datapaths) {
        if (!od->nbs) {
            continue;
        }

        for (size_t i = 0; i < od->nbs->n_load_balancer; i++) {
            const struct uuid *lb_uuid =
                &od->nbs->load_balancer[i]->header_.uuid;
            lb = ovn_northd_lb_find(lbs, lb_uuid);
            ovn_northd_lb_add_ls(lb, 1, &od);
        }

        for (size_t i = 0; i < od->nbs->n_load_balancer_group; i++) {
            nbrec_lb_group = od->nbs->load_balancer_group[i];
            lb_group = ovn_lb_group_find(lb_groups,
                                         &nbrec_lb_group->header_.uuid);
            ovn_lb_group_add_ls(lb_group, 1, &od);
        }
    }

    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {
        for (size_t j = 0; j < lb_group->n_lbs; j++) {
            ovn_northd_lb_add_ls(lb_group->lbs[j], lb_group->n_ls,
                                 lb_group->ls);
        }
    }

    HMAP_FOR_EACH (od, key_node, datapaths) {
        if (!od->nbr) {
            continue;
        }

        /* Checking load balancer groups first, starting from the largest one,
         * to more efficiently copy IP sets. */
        size_t largest_group = 0;

        for (size_t i = 1; i < od->nbr->n_load_balancer_group; i++) {
            if (od->nbr->load_balancer_group[i]->n_load_balancer >
                od->nbr->load_balancer_group[largest_group]->n_load_balancer) {
                largest_group = i;
            }
        }

        for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {
            size_t idx = (i + largest_group) % od->nbr->n_load_balancer_group;

            nbrec_lb_group = od->nbr->load_balancer_group[idx];
            lb_group = ovn_lb_group_find(lb_groups,
                                         &nbrec_lb_group->header_.uuid);
            ovn_lb_group_add_lr(lb_group, od);

            if (!od->lb_ips) {
                od->lb_ips = ovn_lb_ip_set_clone(lb_group->lb_ips);
            } else {
                for (size_t j = 0; j < lb_group->n_lbs; j++) {
                    build_lrouter_lb_ips(od->lb_ips, lb_group->lbs[j]);
                }
            }
        }

        if (!od->lb_ips) {
            od->lb_ips = ovn_lb_ip_set_create();
        }

        for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {
            const struct uuid *lb_uuid =
                &od->nbr->load_balancer[i]->header_.uuid;
            lb = ovn_northd_lb_find(lbs, lb_uuid);
            ovn_northd_lb_add_lr(lb, 1, &od);
            build_lrouter_lb_ips(od->lb_ips, lb);
        }
    }

    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {
        for (size_t j = 0; j < lb_group->n_lbs; j++) {
            ovn_northd_lb_add_lr(lb_group->lbs[j], lb_group->n_lr,
                                 lb_group->lr);
        }
    }
}
