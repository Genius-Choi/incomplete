cr_recv(struct Curl_easy *data, int sockindex,
            char *plainbuf, size_t plainlen, CURLcode *err)
{
  struct connectdata *conn = data->conn;
  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];
  struct ssl_backend_data *const backend = connssl->backend;
  struct rustls_client_session *const session = backend->session;
  curl_socket_t sockfd = conn->sock[sockindex];
  size_t n = 0;
  ssize_t tls_bytes_read = 0;
  size_t tls_bytes_processed = 0;
  size_t plain_bytes_copied = 0;
  rustls_result rresult = 0;
  char errorbuf[255];

  tls_bytes_read = sread(sockfd, backend->tlsbuf, TLSBUF_SIZE);
  if(tls_bytes_read == 0) {
    failf(data, "connection closed without TLS close_notify alert");
    *err = CURLE_READ_ERROR;
    return -1;
  }
  else if(tls_bytes_read < 0) {
    if(SOCKERRNO == EAGAIN || SOCKERRNO == EWOULDBLOCK) {
      infof(data, "sread: EAGAIN or EWOULDBLOCK\n");
      /* There is no data in the socket right now, but there could still be
         some data in the rustls session, so we need to read from it below. */
      tls_bytes_read = 0;
    }
    else {
      failf(data, "reading from socket: %s", strerror(SOCKERRNO));
      *err = CURLE_READ_ERROR;
      return -1;
    }
  }

  /*
  * Now pull those bytes from the buffer into ClientSession.
  */
  DEBUGASSERT(tls_bytes_read >= 0);
  while(tls_bytes_processed < (size_t)tls_bytes_read) {
    rresult = rustls_client_session_read_tls(session,
      backend->tlsbuf + tls_bytes_processed,
      tls_bytes_read - tls_bytes_processed,
      &n);
    if(rresult != RUSTLS_RESULT_OK) {
      failf(data, "error in rustls_client_session_read_tls");
      *err = CURLE_READ_ERROR;
      return -1;
    }
    else if(n == 0) {
      infof(data, "EOF from rustls_client_session_read_tls\n");
      break;
    }

    rresult = rustls_client_session_process_new_packets(session);
    if(rresult != RUSTLS_RESULT_OK) {
      rustls_error(rresult, errorbuf, sizeof(errorbuf), &n);
      failf(data, "%.*s", n, errorbuf);
      *err = map_error(rresult);
      return -1;
    }

    tls_bytes_processed += n;
    backend->data_pending = TRUE;
  }

  while(plain_bytes_copied < plainlen) {
    rresult = rustls_client_session_read(session,
      (uint8_t *)plainbuf + plain_bytes_copied,
      plainlen - plain_bytes_copied,
      &n);
    if(rresult == RUSTLS_RESULT_ALERT_CLOSE_NOTIFY) {
      *err = CURLE_OK;
      return 0;
    }
    else if(rresult != RUSTLS_RESULT_OK) {
      failf(data, "error in rustls_client_session_read");
      *err = CURLE_READ_ERROR;
      return -1;
    }
    else if(n == 0) {
      /* rustls returns 0 from client_session_read to mean "all currently
        available data has been read." If we bring in more ciphertext with
        read_tls, more plaintext will become available. So don't tell curl
        this is an EOF. Instead, say "come back later." */
      infof(data, "EOF from rustls_client_session_read\n");
      backend->data_pending = FALSE;
      break;
    }
    else {
      plain_bytes_copied += n;
    }
  }

  /* If we wrote out 0 plaintext bytes, it might just mean we haven't yet
     read a full TLS record. Return CURLE_AGAIN so curl doesn't treat this
     as EOF. */
  if(plain_bytes_copied == 0) {
    *err = CURLE_AGAIN;
    return -1;
  }

  return plain_bytes_copied;
}
