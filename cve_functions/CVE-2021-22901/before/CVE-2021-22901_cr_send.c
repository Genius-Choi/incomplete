cr_send(struct Curl_easy *data, int sockindex,
        const void *plainbuf, size_t plainlen, CURLcode *err)
{
  struct connectdata *conn = data->conn;
  struct ssl_connect_data *const connssl = &conn->ssl[sockindex];
  struct ssl_backend_data *const backend = connssl->backend;
  struct rustls_client_session *const session = backend->session;
  curl_socket_t sockfd = conn->sock[sockindex];
  ssize_t n = 0;
  size_t plainwritten = 0;
  size_t tlslen = 0;
  size_t tlswritten = 0;
  rustls_result rresult;

  if(plainlen > 0) {
    rresult = rustls_client_session_write(session,
                                          plainbuf, plainlen, &plainwritten);
    if(rresult != RUSTLS_RESULT_OK) {
      failf(data, "error in rustls_client_session_write");
      *err = CURLE_WRITE_ERROR;
      return -1;
    }
    else if(plainwritten == 0) {
      failf(data, "EOF in rustls_client_session_write");
      *err = CURLE_WRITE_ERROR;
      return -1;
    }
  }

  while(rustls_client_session_wants_write(session)) {
    rresult = rustls_client_session_write_tls(
      session, backend->tlsbuf, TLSBUF_SIZE, &tlslen);
    if(rresult != RUSTLS_RESULT_OK) {
      failf(data, "error in rustls_client_session_write_tls");
      *err = CURLE_WRITE_ERROR;
      return -1;
    }
    else if(tlslen == 0) {
      failf(data, "EOF in rustls_client_session_write_tls");
      *err = CURLE_WRITE_ERROR;
      return -1;
    }

    tlswritten = 0;

    while(tlswritten < tlslen) {
      n = swrite(sockfd, backend->tlsbuf + tlswritten, tlslen - tlswritten);
      if(n < 0) {
        if(SOCKERRNO == EAGAIN || SOCKERRNO == EWOULDBLOCK) {
          /* Since recv is called from poll, there should be room to
             write at least some bytes before hitting EAGAIN. */
          infof(data, "swrite: EAGAIN after %ld bytes\n", tlswritten);
          DEBUGASSERT(tlswritten > 0);
          break;
        }
        failf(data, "error in swrite");
        *err = CURLE_WRITE_ERROR;
        return -1;
      }
      if(n == 0) {
        failf(data, "EOF in swrite");
        *err = CURLE_WRITE_ERROR;
        return -1;
      }
      tlswritten += n;
    }

    DEBUGASSERT(tlswritten <= tlslen);
  }

  return plainwritten;
}
