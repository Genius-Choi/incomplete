static struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)
{
	struct nlattr *na, *ret;
	int aggr;

	aggr = (type == TASKSTATS_TYPE_PID)
			? TASKSTATS_TYPE_AGGR_PID
			: TASKSTATS_TYPE_AGGR_TGID;

	/*
	 * The taskstats structure is internally aligned on 8 byte
	 * boundaries but the layout of the aggregrate reply, with
	 * two NLA headers and the pid (each 4 bytes), actually
	 * force the entire structure to be unaligned. This causes
	 * the kernel to issue unaligned access warnings on some
	 * architectures like ia64. Unfortunately, some software out there
	 * doesn't properly unroll the NLA packet and assumes that the start
	 * of the taskstats structure will always be 20 bytes from the start
	 * of the netlink payload. Aligning the start of the taskstats
	 * structure breaks this software, which we don't want. So, for now
	 * the alignment only happens on architectures that require it
	 * and those users will have to update to fixed versions of those
	 * packages. Space is reserved in the packet only when needed.
	 * This ifdef should be removed in several years e.g. 2012 once
	 * we can be confident that fixed versions are installed on most
	 * systems. We add the padding before the aggregate since the
	 * aggregate is already a defined type.
	 */
#ifdef TASKSTATS_NEEDS_PADDING
	if (nla_put(skb, TASKSTATS_TYPE_NULL, 0, NULL) < 0)
		goto err;
#endif
	na = nla_nest_start(skb, aggr);
	if (!na)
		goto err;

	if (nla_put(skb, type, sizeof(pid), &pid) < 0)
		goto err;
	ret = nla_reserve(skb, TASKSTATS_TYPE_STATS, sizeof(struct taskstats));
	if (!ret)
		goto err;
	nla_nest_end(skb, na);

	return nla_data(ret);
err:
	return NULL;
}
