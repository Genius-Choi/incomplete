std::string Ztring::To_UTF8 () const
{
    #ifdef _UNICODE
        //Correction thanks to Andrew Jang
        // Don't use WideCharToMultiByte(), some characters are not well converted
        std::string ToReturn;
        ToReturn.reserve(size()); // more efficient

        const wchar_t* Z=c_str();

        while (*Z)
        {
            if (*Z < 0x80)
            {
                ToReturn += (char)(*(Z++));
                continue;
            }
            
            int32u wc; // must be unsigned.

            #if defined(_MSC_VER)
                #pragma warning(push)
                #pragma warning(disable:4127)
            #endif //defined(_MSC_VER)
            if (sizeof(wchar_t) == 2)
            #if defined(_MSC_VER)
                #pragma warning(pop)
            #endif //defined(_MSC_VER)
            {
                if (((*Z) & 0xFC00) == 0xD800)
                {
                    //UTF-16
                    wc =( (((int16u) *Z) & 0x3FF) + 0x40) << 10;
                    Z++;
                    wc |= (((int16u) *Z) & 0x3FF);
                }
                else
                wc = (int16u) *Z; // avoid a cast problem if wchar_t is signed.
            }
            else
                wc = *Z;

            int count;

            // refer to http://en.wikipedia.org/wiki/UTF-8#Description

            if (wc < 0x80)
                count = 1;
            else if (wc < 0x800)
                count = 2;
            else if (wc < 0x10000)
                count = 3;
            else if (wc < 0x200000)
                count = 4;
            else if (wc < 0x4000000)
                count = 5;
            else if (wc <= 0x7fffffff)
                count = 6;
            else
                break;  // bad character

            int64u utfbuf = 0; // 8 bytes
            char* utf8chars = (char*) &utfbuf;

            switch (count)
            {
            case 6:
                utf8chars[5] = 0x80 | (wc & 0x3f);
                wc = (wc >> 6) | 0x4000000;
                /* fallthrough */
            case 5:
                utf8chars[4] = 0x80 | (wc & 0x3f);
                wc = (wc >> 6) | 0x200000;
                /* fallthrough */
            case 4:
                utf8chars[3] = 0x80 | (wc & 0x3f);
                wc = (wc >> 6) | 0x10000;
                /* fallthrough */
            case 3:
                utf8chars[2] = 0x80 | (wc & 0x3f);
                wc = (wc >> 6) | 0x800;
                /* fallthrough */
            case 2:
                utf8chars[1] = 0x80 | (wc & 0x3f);
                wc = (wc >> 6) | 0xc0;
                /* fallthrough */
            case 1:
                utf8chars[0] = (char) wc;
            }

            ToReturn += utf8chars;

            ++Z;
        }

        return ToReturn;
    #else
        #ifdef ZENLIB_USEWX
            return wxConvUTF8.cWC2MB(wxConvCurrent->cMB2WC(c_str())).data();
        #else //ZENLIB_USEWX
            return c_str(); //Not implemented
        #endif //ZENLIB_USEWX
    #endif
}
