static int handle_NPP_Destroy(rpc_connection_t *connection)
{
  D(bug("handle_NPP_Destroy\n"));

  int error;
  PluginInstance *plugin;
  error = rpc_method_get_args(connection,
							  RPC_TYPE_NPW_PLUGIN_INSTANCE, &plugin,
							  RPC_TYPE_INVALID);

  if (error != RPC_ERROR_NO_ERROR) {
	npw_perror("NPP_Destroy() get args", error);
	return error;
  }

  NPSavedData *save_area = NULL;
  NPError ret = NPERR_NO_ERROR;
  /* Take a ref for the rpc_method_send_reply; otherwise the
   * rpc_connection_unref in g_NPP_Destroy_Now may cause a slight
   * nuisance. */
  rpc_connection_ref(connection);
  if (!rpc_method_in_invoke(connection)) {
	/* The plugin is not on the stack; it's safe to call this. */
	D(bug("NPP_Destroy is fine.\n"));
	ret = g_NPP_Destroy_Now(plugin, &save_area);
  } else {
	/* It is not safe to call NPP_Destroy right now. Delay it until we
	 * return to the event loop.
	 *
	 * NOTE: This means that the browser never sees the real return
	 * value of NPP_Destroy; the NPSavedData will be discarded, and any
	 * error code will be ignored. */
    D(bug("NPP_Destroy raced; delaying it to get a clean stack.\n"));
	delayed_destroys_add(plugin);
  }

  error = rpc_method_send_reply(connection,
								RPC_TYPE_INT32, ret,
								RPC_TYPE_NP_SAVED_DATA, save_area,
								RPC_TYPE_INVALID);
  if (save_area) {
    if (save_area->buf)
      NPN_MemFree(save_area->buf);
    NPN_MemFree(save_area);
  }

  rpc_connection_unref(connection);
  return error;
}
