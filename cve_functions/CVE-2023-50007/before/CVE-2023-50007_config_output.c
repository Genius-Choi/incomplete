static int config_output(AVFilterLink *outlink)
{
    AVFilterContext *ctx = outlink->src;
    AudioFWTDNContext *s = ctx->priv;

    switch (s->wavelet_type) {
    case SYM2:
        s->wavelet_length = 4;
        s->lp  = sym2_lp;
        s->hp  = sym2_hp;
        s->ilp = sym2_ilp;
        s->ihp = sym2_ihp;
        break;
    case SYM4:
        s->wavelet_length = 8;
        s->lp  = sym4_lp;
        s->hp  = sym4_hp;
        s->ilp = sym4_ilp;
        s->ihp = sym4_ihp;
        break;
    case RBIOR68:
        s->wavelet_length = 18;
        s->lp  = rbior68_lp;
        s->hp  = rbior68_hp;
        s->ilp = rbior68_ilp;
        s->ihp = rbior68_ihp;
        break;
    case DEB10:
        s->wavelet_length = 20;
        s->lp  = deb10_lp;
        s->hp  = deb10_hp;
        s->ilp = deb10_ilp;
        s->ihp = deb10_ihp;
        break;
    case SYM10:
        s->wavelet_length = 20;
        s->lp  = sym10_lp;
        s->hp  = sym10_hp;
        s->ilp = sym10_ilp;
        s->ihp = sym10_ihp;
        break;
    case COIF5:
        s->wavelet_length = 30;
        s->lp  = coif5_lp;
        s->hp  = coif5_hp;
        s->ilp = coif5_ilp;
        s->ihp = coif5_ihp;
        break;
    case BL3:
        s->wavelet_length = 42;
        s->lp  = bl3_lp;
        s->hp  = bl3_hp;
        s->ilp = bl3_ilp;
        s->ihp = bl3_ihp;
        break;
    default:
        av_assert0(0);
    }

    s->levels = FFMIN(s->levels, lrint(log(s->nb_samples / (s->wavelet_length - 1.0)) / M_LN2));
    av_log(ctx, AV_LOG_VERBOSE, "levels: %d\n", s->levels);
    s->filter_channel = filter_channel;

    s->stddev = ff_get_audio_buffer(outlink, MAX_LEVELS);
    s->new_stddev = ff_get_audio_buffer(outlink, MAX_LEVELS);
    s->filter = ff_get_audio_buffer(outlink, s->nb_samples);
    s->absmean = ff_get_audio_buffer(outlink, MAX_LEVELS);
    s->new_absmean = ff_get_audio_buffer(outlink, MAX_LEVELS);
    if (!s->stddev || !s->absmean || !s->filter ||
        !s->new_stddev || !s->new_absmean)
        return AVERROR(ENOMEM);

    s->channels = outlink->ch_layout.nb_channels;
    s->overlap_length = max_left_ext(s->wavelet_length, s->levels);
    s->prev_length = s->overlap_length;
    s->drop_samples = s->overlap_length;
    s->padd_samples = s->overlap_length;
    s->sn = 1;

    s->cp = av_calloc(s->channels, sizeof(*s->cp));
    if (!s->cp)
        return AVERROR(ENOMEM);

    for (int ch = 0; ch < s->channels; ch++) {
        ChannelParams *cp = &s->cp[ch];

        cp->output_coefs = av_calloc(s->levels + 1, sizeof(*cp->output_coefs));
        cp->filter_coefs = av_calloc(s->levels + 1, sizeof(*cp->filter_coefs));
        cp->output_length = av_calloc(s->levels + 1, sizeof(*cp->output_length));
        cp->filter_length = av_calloc(s->levels + 1, sizeof(*cp->filter_length));
        cp->buffer_length = next_pow2(s->wavelet_length);
        cp->buffer = av_calloc(cp->buffer_length, sizeof(*cp->buffer));
        cp->buffer2 = av_calloc(cp->buffer_length, sizeof(*cp->buffer2));
        cp->subbands_to_free = av_calloc(s->levels + 1, sizeof(*cp->subbands_to_free));
        cp->prev = av_calloc(s->prev_length, sizeof(*cp->prev));
        cp->overlap = av_calloc(s->overlap_length, sizeof(*cp->overlap));
        cp->max_left_ext = max_left_ext(s->wavelet_length, s->levels);
        cp->min_left_ext = min_left_ext(s->wavelet_length, s->levels);
        if (!cp->output_coefs || !cp->filter_coefs || !cp->output_length ||
            !cp->filter_length || !cp->subbands_to_free || !cp->prev || !cp->overlap ||
            !cp->buffer || !cp->buffer2)
            return AVERROR(ENOMEM);
    }

    return 0;
}
