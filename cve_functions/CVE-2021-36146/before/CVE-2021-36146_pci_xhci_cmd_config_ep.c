pci_xhci_cmd_config_ep(struct pci_xhci_vdev *xdev,
		       uint32_t slot,
		       struct xhci_trb *trb)
{
	struct xhci_input_dev_ctx *input_ctx;
	struct pci_xhci_dev_emu	*dev;
	struct xhci_dev_ctx	*dev_ctx;
	struct xhci_endp_ctx	*ep_ctx, *iep_ctx;
	uint32_t	cmderr;
	int		i;

	cmderr = XHCI_TRB_ERROR_SUCCESS;

	UPRINTF(LDBG, "config_ep slot %u\r\n", slot);

	dev = XHCI_SLOTDEV_PTR(xdev, slot);
	if (dev == NULL) {
		cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
		goto done;
	}

	if ((trb->dwTrb3 & XHCI_TRB_3_DCEP_BIT) != 0) {
		UPRINTF(LDBG, "config_ep - deconfigure ep slot %u\r\n", slot);
		if (dev->dev_ue->ue_stop != NULL)
			dev->dev_ue->ue_stop(dev->dev_instance);

		dev->dev_slotstate = XHCI_ST_ADDRESSED;

		dev->hci.hci_address = 0;
		dev_ctx = pci_xhci_get_dev_ctx(xdev, slot);
		if (!dev_ctx) {
			cmderr = XHCI_TRB_ERROR_TRB;
			goto done;
		}

		/* number of contexts */
		dev_ctx->ctx_slot.dwSctx0 =
			FIELD_REPLACE(dev_ctx->ctx_slot.dwSctx0, 1, 0x1F, 27);

		/* slot state */
		dev_ctx->ctx_slot.dwSctx3 =
			FIELD_REPLACE(dev_ctx->ctx_slot.dwSctx3,
				      XHCI_ST_SLCTX_ADDRESSED, 0x1F, 27);

		/* disable endpoints */
		for (i = 2; i < 32; i++)
			pci_xhci_disable_ep(dev, i);

		cmderr = XHCI_TRB_ERROR_SUCCESS;
		goto done;
	}

	if (dev->dev_slotstate < XHCI_ST_ADDRESSED) {
		UPRINTF(LWRN, "config_ep slotstate x%x != addressed\r\n",
			dev->dev_slotstate);
		cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
		goto done;
	}

	/* In addressed/configured state;
	 * for each drop endpoint ctx flag:
	 *   ep->state = DISABLED
	 * for each add endpoint ctx flag:
	 *   cp(ep-in, ep-out)
	 *   ep->state = RUNNING
	 * for each drop+add endpoint flag:
	 *   reset ep resources
	 *   cp(ep-in, ep-out)
	 *   ep->state = RUNNING
	 * if input->DisabledCtx[2-31] < 30: (at least 1 ep not disabled)
	 *   slot->state = configured
	 */

	input_ctx = XHCI_GADDR(xdev, trb->qwTrb0 & ~0xFUL);
	if (!input_ctx) {
		UPRINTF(LFTL, "Invalid gpa 0x%lx in configure endpoint!\r\n",
			trb->qwTrb0 & ~0xFUL);
		cmderr = XHCI_TRB_ERROR_TRB;
		goto done;
	}
	dev_ctx = dev->dev_ctx;
	UPRINTF(LDBG, "config_ep inputctx: D:x%08x A:x%08x 7:x%08x\r\n",
		input_ctx->ctx_input.dwInCtx0, input_ctx->ctx_input.dwInCtx1,
		input_ctx->ctx_input.dwInCtx7);

	for (i = 2; i <= 31; i++) {
		ep_ctx = &dev_ctx->ctx_ep[i];

		if (input_ctx->ctx_input.dwInCtx0 &
		    XHCI_INCTX_0_DROP_MASK(i)) {
			UPRINTF(LDBG, " config ep - dropping ep %d\r\n", i);
			pci_xhci_disable_ep(dev, i);
		}

		if (input_ctx->ctx_input.dwInCtx1 &
		    XHCI_INCTX_1_ADD_MASK(i)) {
			iep_ctx = &input_ctx->ctx_ep[i];

			UPRINTF(LDBG, " enable ep%d %08x %08x %016lx %08x\r\n",
				i, iep_ctx->dwEpCtx0, iep_ctx->dwEpCtx1,
				iep_ctx->qwEpCtx2, iep_ctx->dwEpCtx4);

			memcpy(ep_ctx, iep_ctx, sizeof(struct xhci_endp_ctx));

			if (pci_xhci_init_ep(dev, i, slot)) {
				cmderr = XHCI_TRB_ERROR_RESOURCE;
				goto error;
			}

			/* ep state */
			ep_ctx->dwEpCtx0 =
				FIELD_REPLACE(ep_ctx->dwEpCtx0,
					      XHCI_ST_EPCTX_RUNNING, 0x7, 0);
		}
	}

	/* slot state to configured */
	dev_ctx->ctx_slot.dwSctx3 =
		FIELD_REPLACE(dev_ctx->ctx_slot.dwSctx3,
			      XHCI_ST_SLCTX_CONFIGURED, 0x1F, 27);
	dev_ctx->ctx_slot.dwSctx0 =
		FIELD_COPY(dev_ctx->ctx_slot.dwSctx0,
			   input_ctx->ctx_slot.dwSctx0, 0x1F, 27);
	dev->dev_slotstate = XHCI_ST_CONFIGURED;

	UPRINTF(LDBG, "EP configured; slot %u [0]=0x%08x [1]=0x%08x"
			" [2]=0x%08x [3]=0x%08x\r\n", slot,
			dev_ctx->ctx_slot.dwSctx0,
			dev_ctx->ctx_slot.dwSctx1,
			dev_ctx->ctx_slot.dwSctx2,
			dev_ctx->ctx_slot.dwSctx3);

done:
	return cmderr;
error:
	for (; i >= 2; --i)
		pci_xhci_disable_ep(dev, i);
	return cmderr;
}
