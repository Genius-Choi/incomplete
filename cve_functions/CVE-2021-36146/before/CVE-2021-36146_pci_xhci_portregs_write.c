pci_xhci_portregs_write(struct pci_xhci_vdev *xdev,
			uint64_t offset,
			uint64_t value)
{
	struct xhci_trb		evtrb;
	struct pci_xhci_portregs *p;
	int port;
	uint32_t oldpls, newpls;

	if (xdev->portregs == NULL)
		return;

	port = (offset - XHCI_PORTREGS_PORT0) / XHCI_PORTREGS_SETSZ;
	offset = (offset - XHCI_PORTREGS_PORT0) % XHCI_PORTREGS_SETSZ;

	UPRINTF(LDBG, "portregs wr offset 0x%lx, port %u: 0x%lx\r\n",
		offset, port, value);

	if (port > XHCI_MAX_DEVS || port < 0) {
		UPRINTF(LWRN, "portregs_write to bad port %d\r\n", port);
		return;
	}

	p = XHCI_PORTREG_PTR(xdev, port);
	switch (offset) {
	case 0:
		/* port reset or warm reset */
		if (value & (XHCI_PS_PR | XHCI_PS_WPR)) {
			pci_xhci_reset_port(xdev, port, value & XHCI_PS_WPR);
			break;
		}

		if ((p->portsc & XHCI_PS_PP) == 0) {
			UPRINTF(LWRN, "portregs_write to unpowered "
				 "port %d\r\n", port);
			break;
		}

		/* Port status and control register  */
		oldpls = XHCI_PS_PLS_GET(p->portsc);
		newpls = XHCI_PS_PLS_GET(value);

		p->portsc &= XHCI_PS_PED | XHCI_PS_PLS_MASK |
			     XHCI_PS_SPEED_MASK | XHCI_PS_PIC_MASK;

		if (pci_xhci_is_vport_free(xdev, port) == true)
			p->portsc |= XHCI_PS_CCS;

		p->portsc |= (value &
			      ~(XHCI_PS_OCA |
				XHCI_PS_PR  |
				XHCI_PS_PED |
				XHCI_PS_PLS_MASK   |	/* link state */
				XHCI_PS_SPEED_MASK |
				XHCI_PS_PIC_MASK   |	/* port indicator */
				XHCI_PS_LWS | XHCI_PS_DR | XHCI_PS_WPR));

		/* clear control bits */
		p->portsc &= ~(value &
			       (XHCI_PS_CSC |
				XHCI_PS_PEC |
				XHCI_PS_WRC |
				XHCI_PS_OCC |
				XHCI_PS_PRC |
				XHCI_PS_PLC |
				XHCI_PS_CEC |
				XHCI_PS_CAS));

		/* port disable request; for USB3, don't care */
		if (value & XHCI_PS_PED)
			UPRINTF(LDBG, "Disable port %d request\r\n", port);

		if (!(value & XHCI_PS_LWS))
			break;

		UPRINTF(LDBG, "Port new PLS: %d\r\n", newpls);

		switch (newpls) {
		case UPS_PORT_LS_U0:
		case UPS_PORT_LS_U3:
			if (oldpls != newpls) {
				p->portsc &= ~XHCI_PS_PLS_MASK;
				p->portsc |= XHCI_PS_PLS_SET(newpls);

				/*
				 * TODO:
				 * Should check if this is exactly
				 * consistent with xHCI spec.
				 */
				if (newpls == 0)
					p->portsc |= XHCI_PS_PLC;

				if (oldpls != 0 && newpls == 0) {
					pci_xhci_set_evtrb(&evtrb, port,
					    XHCI_TRB_ERROR_SUCCESS,
					    XHCI_TRB_EVENT_PORT_STS_CHANGE);
					if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0)
						UPRINTF(LFTL, "Failed to inject port status change event!\r\n");
				}
			}
			break;
		case UPS_PORT_LS_RESUME:
			p->portsc &= ~XHCI_PS_PLS_MASK;
			p->portsc |= XHCI_PS_PLS_SET(newpls);
			break;
		default:
			UPRINTF(LWRN, "Unhandled change port %d PLS %u\r\n",
				 port, newpls);
			break;
		}
		break;
	case 4:
		/* Port power management status and control register  */
		p->portpmsc = value;
		break;
	case 8:
		/* Port link information register */
		UPRINTF(LDBG, "attempted write to PORTLI, port %d\r\n",
			port);
		break;
	case 12:
		/*
		 * Port hardware LPM control register.
		 * For USB3, this register is reserved.
		 */
		p->porthlpmc = value;
		break;
	}
}
