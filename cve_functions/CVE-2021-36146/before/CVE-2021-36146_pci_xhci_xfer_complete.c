pci_xhci_xfer_complete(struct pci_xhci_vdev *xdev, struct usb_xfer *xfer,
		uint32_t slot, uint32_t epid, int *do_intr)
{
	struct xhci_dev_ctx	*dev_ctx;
	struct xhci_endp_ctx	*ep_ctx;
	struct xhci_trb		*trb;
	struct xhci_block	*hcb;
	struct xhci_trb		evtrb;
	uint32_t trbflags;
	uint32_t edtla;
	uint32_t i;
	int  err = XHCI_TRB_ERROR_SUCCESS;
	int rem_len = 0;

	dev_ctx = pci_xhci_get_dev_ctx(xdev, slot);

	ep_ctx = &dev_ctx->ctx_ep[epid];

	/* err is used as completion code and sent to guest driver */
	switch (xfer->status) {
	case USB_ERR_STALLED:
		ep_ctx->dwEpCtx0 = (ep_ctx->dwEpCtx0 & ~0x7) |
			XHCI_ST_EPCTX_HALTED;
		err = XHCI_TRB_ERROR_STALL;
		break;
	case USB_ERR_SHORT_XFER:
		err = XHCI_TRB_ERROR_SHORT_PKT;
		break;
	case USB_ERR_TIMEOUT:
	case USB_ERR_IOERROR:
		err = XHCI_TRB_ERROR_XACT;
		break;
	case USB_ERR_BAD_BUFSIZE:
		err = XHCI_TRB_ERROR_BABBLE;
		break;
	case USB_ERR_NORMAL_COMPLETION:
		break;
	default:
		UPRINTF(LFTL, "unknown error %d\r\n", xfer->status);
	}

	*do_intr = 0;
	edtla = 0;

	/* go through list of TRBs and insert event(s) */
	for (i = (uint32_t)xfer->head; xfer->ndata > 0; ) {
		hcb = xfer->data[i].hcb;
		evtrb.qwTrb0 = hcb->trb_addr;
		trb = XHCI_GADDR(xdev, evtrb.qwTrb0);
		if (!trb) {
			UPRINTF(LFTL, "Invalid gpa 0x%lx when get the trb!\r\n",
				evtrb.qwTrb0);
			continue;
		}
		trbflags = trb->dwTrb3;

		UPRINTF(LDBG, "xfer[%d] done?%u:%d trb %x %016lx %x "
			 "(err %d) IOC?%d, type %d\r\n",
			 i, xfer->data[i].stat, xfer->data[i].blen,
			 XHCI_TRB_3_TYPE_GET(trbflags), evtrb.qwTrb0, trbflags,
			 err, trb->dwTrb3 & XHCI_TRB_3_IOC_BIT ? 1 : 0,
			 xfer->data[i].type);

		if (xfer->data[i].stat < USB_BLOCK_HANDLED) {
			xfer->head = (int)i;
			break;
		}

		xfer->data[i].stat = USB_BLOCK_FREE;
		xfer->ndata--;
		xfer->head = index_inc(xfer->head, xfer->max_blk_cnt);
		edtla += xfer->data[i].bdone;

		trb->dwTrb3 = (trb->dwTrb3 & ~0x1) | (hcb->ccs);
		if (xfer->data[i].type == USB_DATA_PART) {
			rem_len += xfer->data[i].blen;
			i = index_inc(i, xfer->max_blk_cnt);

			/* This 'continue' will delay the IOC behavior which
			 * could decrease the number of virtual interrupts.
			 * This could GREATLY improve the performance especially
			 * under ISOCH scenario.
			 */
			continue;
		} else
			rem_len += xfer->data[i].blen;

		if (err == XHCI_TRB_ERROR_SUCCESS && rem_len > 0)
			err = XHCI_TRB_ERROR_SHORT_PKT;

		/* When transfer success and IOC bit not set or
		 * transfer is short packet and ISP bit is not set.
		 * */
		if (((err == XHCI_TRB_ERROR_SUCCESS) &&
			!(trb->dwTrb3 & XHCI_TRB_3_IOC_BIT)) ||
			((err == XHCI_TRB_ERROR_SHORT_PKT) &&
			(!(trb->dwTrb3 & XHCI_TRB_3_ISP_BIT) &&
			!(trb->dwTrb3 & XHCI_TRB_3_IOC_BIT)))) {
			i = index_inc(i, xfer->max_blk_cnt);
			continue;
		}

		evtrb.dwTrb2 = XHCI_TRB_2_ERROR_SET(err) |
			XHCI_TRB_2_REM_SET(rem_len);

		evtrb.dwTrb3 = XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_TRANSFER) |
			XHCI_TRB_3_SLOT_SET(slot) | XHCI_TRB_3_EP_SET(epid);

		if (XHCI_TRB_3_TYPE_GET(trbflags) == XHCI_TRB_TYPE_EVENT_DATA) {
			UPRINTF(LDBG, "EVENT_DATA edtla %u\r\n", edtla);
			evtrb.qwTrb0 = trb->qwTrb0;
			evtrb.dwTrb2 = (edtla & 0xFFFFF) |
				 XHCI_TRB_2_ERROR_SET(err);
			evtrb.dwTrb3 |= XHCI_TRB_3_ED_BIT;
			edtla = 0;
		}

		*do_intr = 1;
		if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {
			UPRINTF(LFTL, "Failed to inject xfer complete event!\r\n");
			return err;
		}
		/* The xHC stop on the TRB in error.*/
		if (err != XHCI_TRB_ERROR_SUCCESS &&
			err != XHCI_TRB_ERROR_SHORT_PKT)
			break;

		i = index_inc(i, xfer->max_blk_cnt);
		rem_len = 0;
	}

	return err;
}
