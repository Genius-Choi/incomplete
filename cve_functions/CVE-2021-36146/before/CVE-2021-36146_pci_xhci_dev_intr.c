pci_xhci_dev_intr(struct usb_hci *hci, int epctx)
{
	struct pci_xhci_dev_emu *dev;
	struct xhci_dev_ctx	*dev_ctx;
	struct xhci_trb		evtrb;
	struct pci_xhci_vdev	*xdev;
	struct pci_xhci_portregs *p;
	struct xhci_endp_ctx	*ep_ctx;
	int	dir_in;
	int	epid;

	dir_in = epctx & 0x80;
	epid = epctx & ~0x80;

	/* HW endpoint contexts are 0-15; convert to epid based on dir */
	epid = (epid * 2) + (dir_in ? 1 : 0);
	if (epid >= XHCI_MAX_ENDPOINTS)
		return 0;

	dev = hci->dev;
	xdev = dev->xdev;

	/* check if device is ready; OS has to initialise it */
	if (xdev->rtsregs.erstba_p == NULL ||
	    (xdev->opregs.usbcmd & XHCI_CMD_RS) == 0 ||
	    dev->dev_ctx == NULL)
		return 0;

	p = XHCI_PORTREG_PTR(xdev, hci->hci_port);

	/* raise event if link U3 (suspended) state */
	if (XHCI_PS_PLS_GET(p->portsc) == 3) {
		p->portsc &= ~XHCI_PS_PLS_MASK;
		p->portsc |= XHCI_PS_PLS_SET(UPS_PORT_LS_RESUME);
		if ((p->portsc & XHCI_PS_PLC) != 0)
			return 0;

		p->portsc |= XHCI_PS_PLC;

		pci_xhci_set_evtrb(&evtrb, hci->hci_port,
				   XHCI_TRB_ERROR_SUCCESS,
				   XHCI_TRB_EVENT_PORT_STS_CHANGE);
		if (pci_xhci_insert_event(xdev, &evtrb, 0) != 0) {
			UPRINTF(LFTL, "Failed to inject port status change event!\r\n");
			return -ENAVAIL;
		}
	}

	dev_ctx = dev->dev_ctx;
	ep_ctx = &dev_ctx->ctx_ep[epid];
	if ((ep_ctx->dwEpCtx0 & 0x7) == XHCI_ST_EPCTX_DISABLED) {
		UPRINTF(LWRN, "device interrupt on disabled endpoint %d\r\n",
			 epid);
		return 0;
	}

	UPRINTF(LDBG, "device interrupt on endpoint %d\r\n", epid);

	pci_xhci_device_doorbell(xdev, hci->hci_port, epid, 0);

	return 0;
}
