pci_xhci_parse_opts(struct pci_xhci_vdev *xdev, char *opts)
{
	char *s, *t, *n, *tptr;
	int i, rc = 0;
	struct pci_xhci_option_elem *elem;
	int (*f)(struct pci_xhci_vdev *, char *);
	int elem_cnt;

	if (!opts) {
		rc = -1;
		goto errout;
	}

	/* allocate neccessary resources during parsing*/
	xdev->devices = calloc(XHCI_MAX_DEVS + 1, sizeof(*xdev->devices));
	xdev->slots = calloc(XHCI_MAX_SLOTS + 1, sizeof(*xdev->slots));
	xdev->portregs = calloc(XHCI_MAX_DEVS + 1, sizeof(*xdev->portregs));
	if (!xdev->devices || !xdev->slots || !xdev->portregs) {
		rc = -2;
		goto errout;
	}

	s = strdup(opts);
	UPRINTF(LDBG, "options: %s\r\n", s);

	elem = xhci_option_table;
	elem_cnt = sizeof(xhci_option_table) / sizeof(*elem);

	for (t = strtok_r(s, ",:", &tptr); t; t = strtok_r(NULL, ",:", &tptr)) {
		if (isdigit(t[0])) { /* bus-port */
			if (pci_xhci_parse_bus_port(xdev, t)) {
				rc = -3;
				goto errout;
			}
		} else {
			for (i = 0; i < elem_cnt; i++) {
				n = elem[i].parse_opt;
				f = elem[i].parse_fn;

				if (!n || !f)
					continue;

				if (!strncmp(t, n, strnlen(n, XHCI_OPT_MAX_LEN))) {
					f(xdev, t);
					break;
				}
			}

			if (i >= elem_cnt) {
				rc = -4;
				goto errout;
			}
		}
	}

	/* do not use the zero index element */
	for (i = 1; i <= XHCI_MAX_DEVS; i++)
		pci_xhci_init_port(xdev, i);

errout:
	if (rc) {
		if (xdev->devices) {
			for (i = 1; i <= XHCI_MAX_DEVS && xdev->devices[i]; i++)
				free(xdev->devices[i]);
			xdev->ndevices = 0;
			free(xdev->devices);
			xdev->devices = NULL;
		}
		if (xdev->slots) {
			free(xdev->slots);
			xdev->slots = NULL;
		}
		if (xdev->portregs) {
			free(xdev->portregs);
			xdev->portregs = NULL;
		}
		if (rc < -2 && s)
			free(s);
		UPRINTF(LFTL, "fail to parse xHCI options, rc=%d\r\n", rc);

		if (opts)
			pci_xhci_device_usage(opts);

		return rc;
	}

	free(s);
	return xdev->ndevices;
}
