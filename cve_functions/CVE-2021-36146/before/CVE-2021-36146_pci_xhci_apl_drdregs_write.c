pci_xhci_apl_drdregs_write(struct pci_xhci_vdev *xdev, uint64_t offset,
		uint64_t value)
{
	int rc = 0, fd;
	char *mstr;
	int msz = 0;
	uint32_t drdcfg1 = 0;
	struct pci_xhci_excap *excap;
	struct pci_xhci_excap_drd_apl *excap_drd;

	excap = xdev->excap_ptr;
	while (excap && excap->start != XHCI_APL_DRDCAP_BASE)
		excap++;

	if (!excap || !excap->data || excap->start != XHCI_APL_DRDCAP_BASE) {
		UPRINTF(LWRN, "drd extended capability can't be found\r\n");
		return -1;
	}

	excap_drd = excap->data;

	offset -= XHCI_APL_DRDREGS_BASE;
	if (offset != XHCI_DRD_MUX_CFG0) {
		UPRINTF(LWRN, "drd configuration register access failed.\r\n");
		return -1;
	}

	if (excap_drd->drdcfg0 == value) {
		UPRINTF(LDBG, "No mode switch action. Current drd: %s mode\r\n",
			excap_drd->drdcfg1 & XHCI_DRD_CFG1_HOST_MODE ?
			"host" : "device");
		return 0;
	}

	excap_drd->drdcfg0 = value;

	if (value & XHCI_DRD_CFG0_IDPIN_EN) {
		if ((value & XHCI_DRD_CFG0_IDPIN) == 0) {
			mstr = XHCI_NATIVE_DRD_HOST_MODE;
			msz = strlen(XHCI_NATIVE_DRD_HOST_MODE);
			drdcfg1 |= XHCI_DRD_CFG1_HOST_MODE;
		} else {
			mstr = XHCI_NATIVE_DRD_DEV_MODE;
			msz = strlen(XHCI_NATIVE_DRD_DEV_MODE);
			drdcfg1 &= ~XHCI_DRD_CFG1_HOST_MODE;
		}
	} else
		return 0;

	fd = open(XHCI_NATIVE_DRD_SWITCH_PATH, O_WRONLY);
	if (fd < 0) {
		UPRINTF(LWRN, "drd native interface open failed\r\n");
		return -1;
	}

	rc = write(fd, mstr, msz);
	close(fd);
	if (rc == msz)
		excap_drd->drdcfg1 = drdcfg1;
	else {
		UPRINTF(LWRN, "drd native interface write "
			"%s mode failed, drdcfg0: 0x%x, "
			"drdcfg1: 0x%x.\r\n",
			value & XHCI_DRD_CFG0_IDPIN ? "device" : "host",
			excap_drd->drdcfg0, excap_drd->drdcfg1);
		return -1;
	}
	return 0;
}
