pci_xhci_handle_transfer(struct pci_xhci_vdev *xdev,
			 struct pci_xhci_dev_emu *dev,
			 struct pci_xhci_dev_ep *devep,
			 struct xhci_endp_ctx *ep_ctx,
			 struct xhci_trb *trb,
			 uint32_t slot,
			 uint32_t epid,
			 uint64_t addr,
			 uint32_t ccs,
			 uint32_t streamid)
{
	struct xhci_trb		*setup_trb;
	struct usb_xfer		*xfer;
	struct xhci_block	hcb;
	struct usb_block	*xfer_block;
	struct usb_block	*prev_block;
	struct itimerspec	delay;
	uint64_t		val;
	uint32_t		trbflags;
	int			do_intr, err;
	int			do_retry;

	ep_ctx->dwEpCtx0 = FIELD_REPLACE(ep_ctx->dwEpCtx0,
					 XHCI_ST_EPCTX_RUNNING, 0x7, 0);

	xfer = devep->ep_xfer;
	pthread_mutex_lock(&devep->mtx);

	UPRINTF(LDBG, "handle_transfer slot %u\r\n", slot);

retry:
	err = 0;
	do_retry = 0;
	do_intr = 0;
	setup_trb = NULL;
	prev_block = NULL;

	while (1) {
		pci_xhci_dump_trb(trb);

		trbflags = trb->dwTrb3;

		if (XHCI_TRB_3_TYPE_GET(trbflags) != XHCI_TRB_TYPE_LINK &&
		    (trbflags & XHCI_TRB_3_CYCLE_BIT) !=
		    (ccs & XHCI_TRB_3_CYCLE_BIT)) {
			UPRINTF(LDBG, "Cycle-bit changed trbflags %x,"
					" ccs %x\r\n",
					trbflags & XHCI_TRB_3_CYCLE_BIT, ccs);
			break;
		}

		xfer_block = NULL;

		hcb.ccs = ccs;
		hcb.trb_addr = addr;
		hcb.streamid = streamid;

		switch (XHCI_TRB_3_TYPE_GET(trbflags)) {
		case XHCI_TRB_TYPE_LINK:
			if (trb->dwTrb3 & XHCI_TRB_3_TC_BIT) {
				ccs ^= 0x1;
				hcb.ccs = ccs;
			}

			xfer_block = usb_block_append(xfer, NULL, 0, &hcb,
					sizeof(hcb));
			if (!xfer_block) {
				err = XHCI_TRB_ERROR_STALL;
				goto errout;
			}
			xfer_block->stat = USB_BLOCK_FREE;
			break;

		case XHCI_TRB_TYPE_SETUP_STAGE:
			if ((trbflags & XHCI_TRB_3_IDT_BIT) == 0 ||
			    XHCI_TRB_2_BYTES_GET(trb->dwTrb2) != 8) {
				UPRINTF(LDBG, "invalid setup trb\r\n");
				err = XHCI_TRB_ERROR_TRB;
				goto errout;
			}
			setup_trb = trb;

			val = trb->qwTrb0;
			if (!xfer->ureq)
				xfer->ureq = malloc(
					sizeof(struct usb_device_request));
			if (!xfer->ureq) {
				err = XHCI_TRB_ERROR_STALL;
				goto errout;
			}
			memcpy(xfer->ureq, &val,
			       sizeof(struct usb_device_request));

			xfer_block = usb_block_append(xfer, NULL, 0, &hcb,
					sizeof(hcb));
			if (!xfer_block) {
				free(xfer->ureq);
				xfer->ureq = NULL;
				err = XHCI_TRB_ERROR_STALL;
				goto errout;
			}
			xfer_block->stat = USB_BLOCK_HANDLED;
			break;

		case XHCI_TRB_TYPE_ISOCH:
			/* According to xHCI spec 4.10.3.1 and 4.14.2.1, the
			 * condition for judging {under,over}run event is
			 * 'empty ring'. But it didn't define how long the
			 * 'empty' state takes to identify this scenario. As
			 * an experience value, 100 ms (100 ESIT) is used to
			 * decide whether the {under,over}run event should be
			 * reported to the Guest OS.
			 */
			delay.it_interval.tv_sec = 0;
			delay.it_interval.tv_nsec = 0;
			delay.it_value.tv_sec = 0;
			delay.it_value.tv_nsec = 100000000;
			if (acrn_timer_settime(&devep->isoc_timer, &delay)) {
				UPRINTF(LFTL, "isoc timer set time failed\n");
				goto errout;
			}
			/* fall through */

		case XHCI_TRB_TYPE_NORMAL:
			if (setup_trb != NULL) {
				UPRINTF(LWRN, "trb not supposed to be in "
					 "ctl scope\r\n");
				err = XHCI_TRB_ERROR_TRB;
				goto errout;
			}
			/* fall through */

		case XHCI_TRB_TYPE_DATA_STAGE:
			xfer_block = usb_block_append(xfer,
					(void *)(trbflags & XHCI_TRB_3_IDT_BIT ?
					&trb->qwTrb0 :
					XHCI_GADDR(xdev, trb->qwTrb0)),
					trb->dwTrb2 & 0x1FFFF, &hcb,
					sizeof(hcb));

			if (!xfer_block) {
				err = XHCI_TRB_ERROR_STALL;
				goto errout;
			}

			if (trb->dwTrb3 & XHCI_TRB_3_CHAIN_BIT)
				xfer_block->type = USB_DATA_PART;
			else
				xfer_block->type = USB_DATA_FULL;

			prev_block = xfer_block;
			break;

		case XHCI_TRB_TYPE_STATUS_STAGE:
			xfer_block = usb_block_append(xfer, NULL, 0, &hcb,
					sizeof(hcb));
			break;

		case XHCI_TRB_TYPE_NOOP:
			xfer_block = usb_block_append(xfer, NULL, 0, &hcb,
					sizeof(hcb));
			if (!xfer_block) {
				err = XHCI_TRB_ERROR_STALL;
				goto errout;
			}
			xfer_block->stat = USB_BLOCK_HANDLED;
			break;

		case XHCI_TRB_TYPE_EVENT_DATA:
			xfer_block = usb_block_append(xfer, NULL, 0, &hcb,
					sizeof(hcb));
			if (!xfer_block) {
				err = XHCI_TRB_ERROR_TRB;
				goto errout;
			}
			if ((epid > 1) && (trbflags & XHCI_TRB_3_IOC_BIT))
				xfer_block->stat = USB_BLOCK_HANDLED;

			if (prev_block && prev_block->type == USB_DATA_PART) {
				prev_block->type = USB_DATA_FULL;
				prev_block = NULL;
			}

			break;

		default:
			UPRINTF(LWRN, "handle xfer unexpected trb type "
				 "0x%x\r\n",
				 XHCI_TRB_3_TYPE_GET(trbflags));
			err = XHCI_TRB_ERROR_TRB;
			goto errout;
		}

		trb = pci_xhci_trb_next(xdev, trb, &addr);
		if (!trb) {
			UPRINTF(LDBG, "Get invalid trb in %s!\n", __func__);
			err = XHCI_TRB_ERROR_TRB;
			goto errout;
		}

		UPRINTF(LDBG, "next trb: 0x%lx\r\n", (uint64_t)trb);

		if (xfer_block) {
			/* FIXME:
			 * should add some code to process the scenario in
			 * which endpoint stop command is comming in the
			 * middle of many data transfers.
			 */
			pci_xhci_update_ep_ring(xdev, dev, devep, ep_ctx,
					streamid, addr, ccs);
		}

		if (trbflags & XHCI_TRB_3_BEI_BIT)
			continue;

		if (xdev->quirks & XHCI_QUIRK_INTEL_ISOCH_NO_BEI)
			continue;

		/* win10 needs it */
		if (XHCI_TRB_3_TYPE_GET(trbflags) == XHCI_TRB_TYPE_EVENT_DATA)
			continue;

		/* handle current batch that requires interrupt on complete */
		if (trbflags & XHCI_TRB_3_IOC_BIT) {
			UPRINTF(LDBG, "trb IOC bit set\r\n");
			do_retry = 1;
			break;
		}
	}

	UPRINTF(LDBG, "[%d]: xfer->ndata %u\r\n", __LINE__, xfer->ndata);

	if (xfer->ndata <= 0)
		goto errout;

	if (epid == 1) {
		err = USB_ERR_NOT_STARTED;
		if (dev->dev_ue->ue_request != NULL)
			err = dev->dev_ue->ue_request(dev->dev_instance, xfer);
		setup_trb = NULL;
	} else {
		/* handle data transfer */
		pci_xhci_try_usb_xfer(xdev, dev, devep, ep_ctx, slot, epid);
		err = XHCI_TRB_ERROR_SUCCESS;
		goto errout;
	}

	err = pci_xhci_xfer_complete(xdev, xfer, slot, epid, &do_intr);
	if (err != XHCI_TRB_ERROR_SUCCESS)
		do_retry = 0;

errout:
	if (err == XHCI_TRB_ERROR_EV_RING_FULL)
		UPRINTF(LDBG, "[%d]: event ring full\r\n", __LINE__);

	if (!do_retry)
		pthread_mutex_unlock(&devep->mtx);

	if (do_intr)
		pci_xhci_assert_interrupt(xdev);

	if (do_retry) {
		UPRINTF(LDBG, "[%d]: retry next TRBs\r\n", __LINE__);
		goto retry;
	}
	return err;
}
