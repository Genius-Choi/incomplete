pci_xhci_rtsregs_write(struct pci_xhci_vdev *xdev,
		       uint64_t offset,
		       uint64_t value)
{
	struct pci_xhci_rtsregs *rts;

	offset -= xdev->rtsoff;

	if (offset == 0) {
		UPRINTF(LWRN, "attempted write to MFINDEX\r\n");
		return;
	}

	UPRINTF(LDBG, "runtime regs write offset 0x%lx: 0x%lx\r\n",
		offset, value);

	offset -= 0x20;		/* start of intrreg */

	rts = &xdev->rtsregs;

	switch (offset) {
	case 0x00:
		if (value & XHCI_IMAN_INTR_PEND)
			rts->intrreg.iman &= ~XHCI_IMAN_INTR_PEND;
		rts->intrreg.iman = (value & XHCI_IMAN_INTR_ENA) |
			(rts->intrreg.iman & XHCI_IMAN_INTR_PEND);

		if (!(value & XHCI_IMAN_INTR_ENA))
			pci_xhci_deassert_interrupt(xdev);

		break;

	case 0x04:
		rts->intrreg.imod = value;
		break;

	case 0x08:
		rts->intrreg.erstsz = value & 0xFFFF;
		break;

	case 0x10:
		/* ERSTBA low bits */
		rts->intrreg.erstba = MASK_64_HI(xdev->rtsregs.intrreg.erstba) |
				      (value & ~0x3F);
		break;

	case 0x14:
		/* ERSTBA high bits */
		rts->intrreg.erstba = (value << 32) |
			MASK_64_LO(xdev->rtsregs.intrreg.erstba);

		rts->erstba_p = XHCI_GADDR(xdev, xdev->rtsregs.intrreg.erstba
				& ~0x3FUL);
		if (rts->erstba_p)
			UPRINTF(LDBG, "wr erstba erst (%p) ptr 0x%lx, sz %u\r\n",
				rts->erstba_p,
				rts->erstba_p->qwRingSegBase,
				rts->erstba_p->dwRingSegSize);
		else
			UPRINTF(LFTL, "Invalid gpa 0x%lx in write runtime register!\r\n",
				xdev->rtsregs.intrreg.erstba & ~0x3FUL);
		break;

	case 0x18:
		/* ERDP low bits */
		rts->intrreg.erdp =
			MASK_64_HI(xdev->rtsregs.intrreg.erdp) |
			(rts->intrreg.erdp & XHCI_ERDP_LO_BUSY) |
			(value & ~0xF);
		if (value & XHCI_ERDP_LO_BUSY) {
			rts->intrreg.erdp &= ~XHCI_ERDP_LO_BUSY;
			rts->intrreg.iman &= ~XHCI_IMAN_INTR_PEND;
		}

		rts->er_deq_seg = XHCI_ERDP_LO_SINDEX(value);
		break;

	case 0x1C:
		/* ERDP high bits */
		rts->intrreg.erdp = (value << 32) |
			MASK_64_LO(xdev->rtsregs.intrreg.erdp);
		break;

	default:
		UPRINTF(LWRN, "attempted write to RTS offset 0x%lx\r\n",
			offset);
		break;
	}
}
