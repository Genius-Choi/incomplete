pci_xhci_usbcmd_write(struct pci_xhci_vdev *xdev, uint32_t cmd)
{
	int i, j;
	struct pci_xhci_native_port *p;

	if (cmd & XHCI_CMD_RS) {
		xdev->opregs.usbcmd |= XHCI_CMD_RS;
		xdev->opregs.usbsts &= ~XHCI_STS_HCH;
		xdev->opregs.usbsts |= XHCI_STS_PCD;
	} else {
		xdev->opregs.usbcmd &= ~XHCI_CMD_RS;
		xdev->opregs.usbsts |= XHCI_STS_HCH;
		xdev->opregs.usbsts &= ~XHCI_STS_PCD;
	}

	/* start execution of schedule; stop when set to 0 */
	cmd |= xdev->opregs.usbcmd & XHCI_CMD_RS;

	if (cmd & XHCI_CMD_HCRST) {
		/* reset controller */
		pci_xhci_reset(xdev);
		cmd &= ~XHCI_CMD_HCRST;
	}

	if (cmd & XHCI_CMD_CSS) {
		/* TODO: should think about what happen if system S3 fail
		 * and under that situation, the vbdp_devs and se_dev_num
		 * should also need to be cleared
		 */
		xdev->vbdp_dev_num = 0;
		memset(xdev->vbdp_devs, 0, sizeof(xdev->vbdp_devs));

		for (i = 0; i < XHCI_MAX_VIRT_PORTS; ++i) {
			p = &xdev->native_ports[i];
			if (xdev->native_ports[i].state == VPORT_EMULATED) {
				/* save the device state before suspending */
				j = xdev->vbdp_dev_num;
				xdev->vbdp_devs[j].path = p->info.path;
				xdev->vbdp_devs[j].vport = p->vport;
				xdev->vbdp_devs[j].state = S3_VBDP_START;
				xdev->vbdp_dev_num++;

				/* clear PORTSC register */
				pci_xhci_init_port(xdev, p->vport);

				/* clear other information for this device*/
				p->vport = 0;
				p->state = VPORT_ASSIGNED;
				UPRINTF(LINF, "s3: save %d-%s state\r\n",
						p->info.path.bus,
						usb_dev_path(&p->info.path));
			}
		}
	}

	cmd &= ~(XHCI_CMD_CSS | XHCI_CMD_CRS);
	return cmd;
}
