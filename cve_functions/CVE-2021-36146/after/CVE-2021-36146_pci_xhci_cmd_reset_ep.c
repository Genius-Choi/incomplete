pci_xhci_cmd_reset_ep(struct pci_xhci_vdev *xdev,
		      uint32_t slot,
		      struct xhci_trb *trb)
{
	struct pci_xhci_dev_emu	*dev;
	struct pci_xhci_dev_ep	*devep;
	struct xhci_dev_ctx	*dev_ctx;
	struct xhci_endp_ctx	*ep_ctx;
	struct usb_xfer	*xfer;
	struct usb_dev_req	*r;
	uint32_t cmderr, epid;
	uint32_t type;
	int i;

	epid = XHCI_TRB_3_EP_GET(trb->dwTrb3);

	UPRINTF(LDBG, "reset ep %u: slot %u cmd_type: %02X\r\n", epid, slot,
			XHCI_TRB_3_TYPE_GET(trb->dwTrb3));

	cmderr = XHCI_TRB_ERROR_SUCCESS;

	type = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);

	dev = XHCI_SLOTDEV_PTR(xdev, slot);
	/* There have three scenarios the pointer will be NULL.
	 * 1.Enable slot command not received.
	 * 2.Enable slot command have been received but not receive
	 * address device command.
	 * 3.After received disable slot command.
	 * In scenario 1 and 3 the slot state should be Disabled.
	 * In scenario 2, the slot state should be Enabled.
	 * Fllow xHCI spec 4.6.8 and 4.6.9, for stop and reset endpoint
	 * command, when the slot state is Disabled the error code should
	 * be Slot Not Enabled Error, when the slot have been enabled by
	 * an Enable Slot Command the error code should be Context State Error.
	 * TODO: The dev_slotstate should move from pci_xhci_dev_emu to
	 * pci_xhci_vdev, and slot_allocated need to removed.
	 */

	if (!dev)
	{
		if (xdev->slot_allocated[slot] == true)
			cmderr = XHCI_TRB_ERROR_CONTEXT_STATE;
		else
			cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
		goto done;
	}


	if (type == XHCI_TRB_TYPE_STOP_EP &&
	   (trb->dwTrb3 & XHCI_TRB_3_SUSP_EP_BIT) != 0) {
		/* XXX suspend endpoint for 10ms */
	}

	if (epid < 1 || epid > 31) {
		UPRINTF(LDBG, "reset ep: invalid epid %u\r\n", epid);
		cmderr = XHCI_TRB_ERROR_TRB;
		goto done;
	}

	dev_ctx = dev->dev_ctx;
	ep_ctx = &dev_ctx->ctx_ep[epid];

	if (type == XHCI_TRB_TYPE_RESET_EP &&
			(ep_ctx->dwEpCtx0 & 0x7) != XHCI_ST_EPCTX_HALTED) {
		cmderr = XHCI_TRB_ERROR_CONTEXT_STATE;
		goto done;
	}

	devep = &dev->eps[epid];
	pthread_mutex_lock(&devep->mtx);

	xfer = devep->ep_xfer;
	for (i = 0; i < xfer->max_blk_cnt; ++i) {
		r = xfer->reqs[i];
		if (r && r->trn)
			/* let usb_dev_comp_req to free the memory */
			libusb_cancel_transfer(r->trn);
	}

	xfer->ndata = 0;
	xfer->head = 0;
	xfer->tail = 0;

	ep_ctx->dwEpCtx0 = (ep_ctx->dwEpCtx0 & ~0x7) | XHCI_ST_EPCTX_STOPPED;

	if (XHCI_EPCTX_0_MAXP_STREAMS_GET(ep_ctx->dwEpCtx0) == 0)
		ep_ctx->qwEpCtx2 = devep->ep_ringaddr | devep->ep_ccs;

	UPRINTF(LDBG, "reset ep[%u] %08x %08x %016lx %08x\r\n",
		epid, ep_ctx->dwEpCtx0, ep_ctx->dwEpCtx1, ep_ctx->qwEpCtx2,
		ep_ctx->dwEpCtx4);
	pthread_mutex_unlock(&devep->mtx);

done:
	return cmderr;
}
