httpAddrGetString(
    const http_addr_t *addr,		// I - Address to convert
    char              *s,		// I - String buffer
    size_t            slen)		// I - Length of string
{
  DEBUG_printf("httpAddrGetString(addr=%p, s=%p, slen=%u)", (void *)addr, (void *)s, (unsigned)slen);

  // Range check input...
  if (!addr || !s || slen <= 2)
  {
    if (s && slen >= 1)
      *s = '\0';

    return (NULL);
  }

#ifdef AF_LOCAL
  if (addr->addr.sa_family == AF_LOCAL)
  {
    if (addr->un.sun_path[0] == '/')
      cupsCopyString(s, addr->un.sun_path, (size_t)slen);
    else
      cupsCopyString(s, "localhost", (size_t)slen);
  }
  else
#endif // AF_LOCAL
  if (addr->addr.sa_family == AF_INET)
  {
    unsigned temp;			// Temporary address

    temp = ntohl(addr->ipv4.sin_addr.s_addr);

    snprintf(s, slen, "%d.%d.%d.%d", (temp >> 24) & 255, (temp >> 16) & 255, (temp >> 8) & 255, temp & 255);
  }
#ifdef AF_INET6
  else if (addr->addr.sa_family == AF_INET6)
  {
    char	*sptr,			// Pointer into string
		temps[64];		// Temporary string for address

    if (getnameinfo(&addr->addr, (socklen_t)httpAddrLength(addr), temps, sizeof(temps), NULL, 0, NI_NUMERICHOST))
    {
      // If we get an error back, then the address type is not supported
      // and we should zero out the buffer...
      s[0] = '\0';

      return (NULL);
    }
    else if ((sptr = strchr(temps, '%')) != NULL)
    {
      // Convert "%zone" to "+zone" to match URI form...
      *sptr = '+';
    }

    // Add "[v1." and "]" around IPv6 address to convert to URI form.
    snprintf(s, slen, "[v1.%s]", temps);
  }
#endif // AF_INET6
  else
  {
    cupsCopyString(s, "UNKNOWN", slen);
  }

  DEBUG_printf("1httpAddrGetString: returning \"%s\"...", s);

  return (s);
}
