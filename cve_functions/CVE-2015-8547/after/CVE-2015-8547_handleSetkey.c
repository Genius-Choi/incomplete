void CoreUserInputHandler::handleSetkey(const BufferInfo &bufferInfo, const QString &msg)
{
    QString bufname = bufferInfo.bufferName().isNull() ? "" : bufferInfo.bufferName();
#ifdef HAVE_QCA2
    if (!bufferInfo.isValid())
        return;

    if (!Cipher::neededFeaturesAvailable()) {
        emit displayMsg(Message::Error, typeByTarget(bufname), bufname, tr("Error: QCA provider plugin not found. It is usually provided by the qca-ossl plugin."));
        return;
    }

    QStringList parms = msg.split(' ', QString::SkipEmptyParts);

    if (parms.count() == 1 && !bufferInfo.bufferName().isEmpty() && bufferInfo.acceptsRegularMessages())
        parms.prepend(bufferInfo.bufferName());
    else if (parms.count() != 2) {
        emit displayMsg(Message::Info, typeByTarget(bufname), bufname,
            tr("[usage] /setkey <nick|channel> <key> sets the encryption key for nick or channel. "
               "/setkey <key> when in a channel or query buffer sets the key for it."));
        return;
    }

    QString target = parms.at(0);
    QByteArray key = parms.at(1).toLocal8Bit();
    network()->setCipherKey(target, key);

    emit displayMsg(Message::Info, typeByTarget(bufname), bufname, tr("The key for %1 has been set.").arg(target));
#else
    Q_UNUSED(msg)
    emit displayMsg(Message::Error, typeByTarget(bufname), bufname, tr("Error: Setting an encryption key requires Quassel to have been built "
                                                                "with support for the Qt Cryptographic Architecture (QCA) library. "
                                                                "Contact your distributor about a Quassel package with QCA "
                                                                "support, or rebuild Quassel with QCA present."));
#endif
}
