static GF_Err swf_place_obj(SWFReader *read, u32 revision)
{
	GF_Err e;
	u32 shape_id;
	u32 ID, bitsize;
	u32 clip_depth;
	GF_Matrix2D mat;
	GF_ColorMatrix cmat;
	DispShape *ds;
	char *name;
	u32 depth, type;
	Bool had_depth;
	/*SWF flags*/
	Bool has_clip_actions, has_clip, has_name, has_ratio, has_cmat, has_mat, has_id, has_move;

	name = NULL;
	clip_depth = 0;
	ID = 0;
	depth = 0;
	has_cmat = has_mat = has_move = 0;

	gf_cmx_init(&cmat);
	gf_mx2d_init(mat);
	/*place*/
	type = SWF_PLACE;

	/*SWF 1.0*/
	if (revision==0) {
		ID = swf_get_16(read);
		depth = swf_get_16(read);
		bitsize = 32;
		bitsize += swf_get_matrix(read, &mat);
		has_mat = 1;
		bitsize += swf_align(read);
		/*size exceeds matrix, parse col mat*/
		if (bitsize < read->size*8) {
			swf_get_colormatrix(read, &cmat);
			has_cmat = 1;
			swf_align(read);
		}
	}
	/*SWF 3.0*/
	else if (revision==1) {
		/*reserved*/
		has_clip_actions = swf_read_int(read, 1);
		has_clip = swf_read_int(read, 1);
		has_name = swf_read_int(read, 1);
		has_ratio = swf_read_int(read, 1);
		has_cmat = swf_read_int(read, 1);
		has_mat = swf_read_int(read, 1);
		has_id = swf_read_int(read, 1);
		has_move = swf_read_int(read, 1);

		depth = swf_get_16(read);
		if (has_id) ID = swf_get_16(read);
		if (has_mat) {
			swf_get_matrix(read, &mat);
			swf_align(read);
		}
		if (has_cmat) {
			swf_align(read);
			swf_get_colormatrix(read, &cmat);
			swf_align(read);
		}
		if (has_ratio) /*ratio = */swf_get_16(read);
		if (has_clip) clip_depth = swf_get_16(read);

		if (has_name) {
			name = swf_get_string(read);
			gf_free(name);
		}
		if (has_clip_actions) {
			swf_get_16(read);
			swf_get_16(read);
		}
		/*replace*/
		if (has_id && has_move) type = SWF_REPLACE;
		/*move*/
		else if (!has_id && has_move) type = SWF_MOVE;
		/*place*/
		else type = SWF_PLACE;
	}

	if (clip_depth) {
		swf_report(read, GF_NOT_SUPPORTED, "Clipping not supported - ignoring");
		return GF_OK;
	}

	/*1: check depth of display list*/
	had_depth = read->allocate_depth(read, depth);
	/*check validity*/
	if ((type==SWF_MOVE) && !had_depth) swf_report(read, GF_BAD_PARAM, "Accessing empty depth level %d", depth);

	ds = NULL;

	/*usual case: (re)place depth level*/
	switch (type) {
	case SWF_MOVE:
		ds = swf_get_depth_entry(read, depth, 0);
		shape_id = ds ? ds->char_id : 0;
		break;
	case SWF_REPLACE:
	case SWF_PLACE:
	default:
		shape_id = ID;
		break;
	}

	if (!shape_id) {
		swf_report(read, GF_BAD_PARAM, "%s unfound object (ID %d)", (type==SWF_MOVE) ? "Moving" : ((type==SWF_PLACE) ? "Placing" : "Replacing"), ID);
		return GF_OK;
	}
	/*restore prev matrix if needed*/
	if (type==SWF_REPLACE) {
		if (!ds) ds = swf_get_depth_entry(read, depth, 0);
		if (ds) {
			if (!has_mat) {
				memcpy(&mat, &ds->mat, sizeof(GF_Matrix2D));
				has_mat = 1;
			}
			if (!has_cmat) {
				memcpy(&cmat, &ds->cmat, sizeof(GF_ColorMatrix));
				has_cmat = 1;
			}
		}
	}

	/*check for identity matrices*/
	if (has_cmat && cmat.identity) has_cmat = 0;
	if (has_mat && swf_mat_is_identity(&mat)) has_mat = 0;

	/*store in display list*/
	ds = swf_get_depth_entry(read, depth, 1);
	e = read->place_obj(read, depth, shape_id, ds->char_id, type,
	                    has_mat ? &mat : NULL,
	                    has_cmat ? &cmat : NULL,
	                    swf_mat_is_identity(&ds->mat) ? NULL : &ds->mat,
	                    ds->cmat.identity ? NULL : &ds->cmat);

	/*remember matrices*/
	memcpy(&ds->mat, &mat, sizeof(GF_Matrix2D));
	memcpy(&ds->cmat, &cmat, sizeof(GF_ColorMatrix));
	ds->char_id = shape_id;

	if (e) swf_report(read, e, "Error %s object ID %d", (type==SWF_MOVE) ? "Moving" : ((type==SWF_PLACE) ? "Placing" : "Replacing"), shape_id);
	return GF_OK;
}
