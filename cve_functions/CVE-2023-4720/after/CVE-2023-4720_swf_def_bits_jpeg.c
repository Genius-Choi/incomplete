static GF_Err swf_def_bits_jpeg(SWFReader *read, u32 version)
{
	u32 ID;
	FILE *file = NULL;
	char szName[1024];
	u8 *buf;
	u32 skip = 0;
#ifndef GPAC_DISABLE_AV_PARSERS
	u32 AlphaPlaneSize = 0;
#endif
	u32 size = read->size;
	GF_Err e=GF_OK;

	ID = swf_get_16(read);
	size -= 2;
	if (version==3) {
		u32 offset = swf_get_32(read);
#ifndef GPAC_DISABLE_AV_PARSERS
		size -= 4;
		AlphaPlaneSize = size - offset;
#endif
		size = offset;
	}

	/*dump file*/
	if (read->localPath) {
		sprintf(szName, "%s/swf_jpeg_%d.jpg", read->localPath, ID);
	} else {
		sprintf(szName, "swf_jpeg_%d.jpg", ID);
	}

	if (version!=3)
		file = gf_fopen(szName, "wb");

	if (version==1 && read->jpeg_hdr_size) {
		/*remove JPEG EOI*/
		if (gf_fwrite(read->jpeg_hdr, read->jpeg_hdr_size-2, file)!=read->jpeg_hdr_size-2)
			return GF_IO_ERR;
		/*remove JPEG SOI*/
		swf_get_16(read);
		size-=2;
	}
	buf = gf_malloc(sizeof(u8)*size);
	if (!buf) return GF_OUT_OF_MEM;
	swf_read_data(read, (char *) buf, size);
	if (version==1) {
		if (gf_fwrite(buf, size, file)!=size)
			e = GF_IO_ERR;
	} else {
		u32 i;
		for (i=0; i<size; i++) {
			if ((i+4<size)
			        && (buf[i]==0xFF) && (buf[i+1]==0xD9)
			        && (buf[i+2]==0xFF) && (buf[i+3]==0xD8)
			   ) {
				memmove(buf+i, buf+i+4, sizeof(char)*(size-i-4));
				size -= 4;
				break;
			}
		}
		if ((buf[0]==0xFF) && (buf[1]==0xD8) && (buf[2]==0xFF) && (buf[3]==0xD8)) {
			skip = 2;
		}
		if (version==2) {
			if (gf_fwrite(buf+skip, size-skip, file) != size-skip) e = GF_IO_ERR;
		}
	}
	if (version!=3)
		gf_fclose(file);

	if (e) {
		gf_free(buf);
		return e;
	}

	if (version==3) {
#ifndef GPAC_DISABLE_AV_PARSERS
		char *dst, *raw;
		u32 codecid;
		u32 osize, w, h, j, pf;
		GF_BitStream *bs;

		/*decompress jpeg*/
		bs = gf_bs_new( (char *) buf+skip, size-skip, GF_BITSTREAM_READ);
		gf_img_parse(bs, &codecid, &w, &h, NULL, NULL);
		gf_bs_del(bs);

		osize = w*h*4;
		raw = gf_malloc(sizeof(char)*osize);
		if (!raw) {
			gf_free(buf);
			return GF_OUT_OF_MEM;
		}
		memset(raw, 0, sizeof(char)*osize);
		e = gf_img_jpeg_dec(buf+skip, size-skip, &w, &h, &pf, raw, &osize, 4);
		if (e != GF_OK) {
			swf_report(read, e, "Cannot decode JPEG image");
		}

		/*read alpha map and decompress it*/
		if (size<AlphaPlaneSize) buf = gf_realloc(buf, sizeof(u8)*AlphaPlaneSize);
		swf_read_data(read, (char *) buf, AlphaPlaneSize);

		osize = w*h;
		dst = gf_malloc(sizeof(char)*osize);
		uncompress((Bytef *) dst, (uLongf *) &osize, buf, AlphaPlaneSize);
		/*write alpha channel*/
		for (j=0; j<osize; j++) {
			raw[4*j + 3] = dst[j];
		}
		gf_free(dst);

		/*write png*/
		if (read->localPath) {
			sprintf(szName, "%s/swf_png_%d.png", read->localPath, ID);
		} else {
			sprintf(szName, "swf_png_%d.png", ID);
		}

		osize = w*h*4;
		buf = gf_realloc(buf, sizeof(char)*osize);
		gf_img_png_enc(raw, w, h, h*4, GF_PIXEL_RGBA, (char *)buf, &osize);

		file = gf_fopen(szName, "wb");
		if (gf_fwrite(buf, osize, file)!=osize) e = GF_IO_ERR;
		gf_fclose(file);

		gf_free(raw);
#endif //GPAC_DISABLE_AV_PARSERS
	}
	gf_free(buf);
	if (e) return e;

	return read->setup_image(read, ID, szName);
}
