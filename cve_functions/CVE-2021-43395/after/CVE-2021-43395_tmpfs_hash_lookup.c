tmpfs_hash_lookup(char *name, struct tmpnode *parent, uint_t hold,
	struct tmpnode **found)
{
	struct tdirent	*l;
	uint_t		hash;
	kmutex_t	*t_hmtx;
	struct tmpnode	*tnp;

	TMPFS_HASH(parent, name, hash);
	t_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];
	mutex_enter(t_hmtx);
	l = t_hashtable[T_HASH_INDEX(hash)];
	while (l) {
		if ((l->td_hash == hash) &&
		    (l->td_parent == parent) &&
		    (strcmp(l->td_name, name) == 0)) {
			/*
			 * We need to make sure that the tmpnode that
			 * we put a hold on is the same one that we pass back.
			 * Hence, temporary variable tnp is necessary.
			 */
			tnp = l->td_tmpnode;
			if (hold) {
				ASSERT(tnp);
				tmpnode_hold(tnp);
			}
			if (found)
				*found = tnp;
			mutex_exit(t_hmtx);
			return (l);
		} else {
			l = l->td_link;
		}
	}
	mutex_exit(t_hmtx);
	return (NULL);
}
