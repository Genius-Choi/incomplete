tdiraddentry(
	struct tmpnode	*dir,	/* target directory to make entry in */
	struct tmpnode	*tp,	/* new tmpnode */
	char		*name,
	enum de_op	op,
	struct tmpnode	*fromtp)
{
	struct tdirent *tdp, *tpdp;
	size_t		namelen, alloc_size;
	timestruc_t	now;

	/*
	 * Make sure the parent directory wasn't removed from
	 * underneath the caller.
	 */
	if (dir->tn_dir == NULL)
		return (ENOENT);

	/*
	 * Check that everything is on the same filesystem.
	 */
	if (tp->tn_vnode->v_vfsp != dir->tn_vnode->v_vfsp)
		return (EXDEV);

	/*
	 * Allocate and initialize directory entry
	 */
	namelen = strlen(name) + 1;
	alloc_size = namelen + sizeof (struct tdirent);
	tdp = tmp_memalloc(alloc_size, 0);
	if (tdp == NULL)
		return (ENOSPC);

	if ((op == DE_RENAME) && (tp->tn_type == VDIR))
		tdirfixdotdot(tp, fromtp, dir);

	dir->tn_size += alloc_size;
	dir->tn_dirents++;
	tdp->td_tmpnode = tp;
	tdp->td_parent = dir;

	/*
	 * The directory entry and its name were allocated sequentially.
	 */
	tdp->td_name = (char *)tdp + sizeof (struct tdirent);
	(void) strcpy(tdp->td_name, name);

	tmpfs_hash_in(tdp);

	/*
	 * Some utilities expect the size of a directory to remain
	 * somewhat static.  For example, a routine which unlinks
	 * files between calls to readdir(); the size of the
	 * directory changes from underneath it and so the real
	 * directory offset in bytes is invalid.  To circumvent
	 * this problem, we initialize a directory entry with an
	 * phony offset, and use this offset to determine end of
	 * file in tmp_readdir.
	 */
	tpdp = dir->tn_dir->td_prev;
	/*
	 * Install at first empty "slot" in directory list.
	 */
	while (tpdp->td_next != NULL && (tpdp->td_next->td_offset -
	    tpdp->td_offset) <= 1) {
		ASSERT(tpdp->td_next != tpdp);
		ASSERT(tpdp->td_prev != tpdp);
		ASSERT(tpdp->td_next->td_offset > tpdp->td_offset);
		tpdp = tpdp->td_next;
	}
	tdp->td_offset = tpdp->td_offset + 1;

	/*
	 * If we're at the end of the dirent list and the offset (which
	 * is necessarily the largest offset in this directory) is more
	 * than twice the number of dirents, that means the directory is
	 * 50% holes.  At this point we reset the slot pointer back to
	 * the beginning of the directory so we start using the holes.
	 * The idea is that if there are N dirents, there must also be
	 * N holes, so we can satisfy the next N creates by walking at
	 * most 2N entries; thus the average cost of a create is constant.
	 * Note that we use the first dirent's td_prev as the roving
	 * slot pointer; it's ugly, but it saves a word in every dirent.
	 */
	if (tpdp->td_next == NULL && tpdp->td_offset > 2 * dir->tn_dirents)
		dir->tn_dir->td_prev = dir->tn_dir->td_next;
	else
		dir->tn_dir->td_prev = tdp;

	ASSERT(tpdp->td_next != tpdp);
	ASSERT(tpdp->td_prev != tpdp);

	tdp->td_next = tpdp->td_next;
	if (tdp->td_next) {
		tdp->td_next->td_prev = tdp;
	}
	tdp->td_prev = tpdp;
	tpdp->td_next = tdp;

	ASSERT(tdp->td_next != tdp);
	ASSERT(tdp->td_prev != tdp);
	ASSERT(tpdp->td_next != tpdp);
	ASSERT(tpdp->td_prev != tpdp);

	gethrestime(&now);
	dir->tn_mtime = now;
	dir->tn_ctime = now;

	return (0);
}
