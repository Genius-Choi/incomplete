tdirrename(
	struct tmpnode *fromparent,	/* parent directory of source */
	struct tmpnode *fromtp,		/* source tmpnode */
	struct tmpnode *toparent,	/* parent directory of target */
	char *nm,			/* entry we are trying to change */
	struct tmpnode *to,		/* target tmpnode */
	struct tdirent *where,		/* target tmpnode directory entry */
	struct cred *cred)		/* credentials */
{
	int error = 0;
	int doingdirectory;
	timestruc_t now;

#if defined(lint)
	nm = nm;
#endif
	ASSERT(RW_WRITE_HELD(&toparent->tn_rwlock));

	/*
	 * Short circuit rename of something to itself.
	 */
	if (fromtp == to)
		return (ESAME);		/* special KLUDGE error code */

	rw_enter(&fromtp->tn_rwlock, RW_READER);
	rw_enter(&to->tn_rwlock, RW_READER);

	/*
	 * Check that everything is on the same filesystem.
	 */
	if (to->tn_vnode->v_vfsp != toparent->tn_vnode->v_vfsp ||
	    to->tn_vnode->v_vfsp != fromtp->tn_vnode->v_vfsp) {
		error = EXDEV;
		goto out;
	}

	/*
	 * Must have write permission to rewrite target entry.
	 * Check for stickyness.
	 */
	if ((error = tmp_taccess(toparent, VWRITE, cred)) != 0 ||
	    (error = tmp_sticky_remove_access(toparent, to, cred)) != 0)
		goto out;

	/*
	 * Ensure source and target are compatible (both directories
	 * or both not directories).  If target is a directory it must
	 * be empty and have no links to it; in addition it must not
	 * be a mount point, and both the source and target must be
	 * writable.
	 */
	doingdirectory = (fromtp->tn_type == VDIR);
	if (to->tn_type == VDIR) {
		if (!doingdirectory) {
			error = EISDIR;
			goto out;
		}
		/*
		 * vn_vfswlock will prevent mounts from using the directory
		 * until we are done.
		 */
		if (vn_vfswlock(TNTOV(to))) {
			error = EBUSY;
			goto out;
		}
		if (vn_mountedvfs(TNTOV(to)) != NULL) {
			vn_vfsunlock(TNTOV(to));
			error = EBUSY;
			goto out;
		}

		mutex_enter(&to->tn_tlock);
		if (to->tn_dirents > 2 || to->tn_nlink > 2) {
			mutex_exit(&to->tn_tlock);
			vn_vfsunlock(TNTOV(to));
			error = EEXIST; /* SIGH should be ENOTEMPTY */
			/*
			 * Update atime because checking tn_dirents is
			 * logically equivalent to reading the directory
			 */
			gethrestime(&to->tn_atime);
			goto out;
		}
		mutex_exit(&to->tn_tlock);
	} else if (doingdirectory) {
		error = ENOTDIR;
		goto out;
	}

	tmpfs_hash_change(where, fromtp);
	gethrestime(&now);
	toparent->tn_mtime = now;
	toparent->tn_ctime = now;

	/*
	 * Upgrade to write lock on "to" (i.e., the target tmpnode).
	 */
	rw_exit(&to->tn_rwlock);
	rw_enter(&to->tn_rwlock, RW_WRITER);

	/*
	 * Decrement the link count of the target tmpnode.
	 */
	DECR_COUNT(&to->tn_nlink, &to->tn_tlock);
	to->tn_ctime = now;

	if (doingdirectory) {
		/*
		 * The entry for "to" no longer exists so release the vfslock.
		 */
		vn_vfsunlock(TNTOV(to));

		/*
		 * Decrement the target link count and delete all entires.
		 */
		tdirtrunc(to);
		ASSERT(to->tn_nlink == 0);

		/*
		 * Renaming a directory with the parent different
		 * requires that ".." be rewritten.  The window is
		 * still there for ".." to be inconsistent, but this
		 * is unavoidable, and a lot shorter than when it was
		 * done in a user process.
		 */
		if (fromparent != toparent)
			tdirfixdotdot(fromtp, fromparent, toparent);
	}
out:
	rw_exit(&to->tn_rwlock);
	rw_exit(&fromtp->tn_rwlock);
	return (error);
}
