bool CIccTagXmlStruct::ParseTag(xmlNode *pNode, std::string &parseStr)
{
  xmlAttr *attr;

  if (pNode->type != XML_ELEMENT_NODE) {// || icXmlStrCmp(pNode->name, "Tag")) {
    parseStr += "Invalid Tag Node: ";
    parseStr += (const char *)pNode->name;
    parseStr += "\n";
    return false;
  }

  CIccTag *pTag = NULL;

  std::string nodeName = (icChar*)pNode->name;
  icSignature sigTag;
  if (m_pStruct)
    sigTag = m_pStruct->GetElemSig(nodeName.c_str());
  else
    sigTag = 0;

  if (sigTag != 0 || nodeName == "PrivateSubTag") { //Parsing of XML tags by name
    if (nodeName == "PrivateSubTag") {
      const char *tagSig = icXmlAttrValue(pNode, "TagSignature", "");
      if (tagSig[0]) {
        sigTag = (icTagSignature)icGetSigVal(tagSig);
      }
      else {
        parseStr += "Invalid TagSignature for PrivateSubTag\n";
        return false;
      }
    }

    const char *sameAs = icXmlAttrValue(pNode, "SameAs", "");

    if (sameAs[0]) {
      icTagSignature sigParentTag = icGetTagNameSig(sameAs);
      if (!strcmp(sameAs, "PrivateSubTag") || sigParentTag == icSigUnknownTag) {
        const char *sameAsSig = icXmlAttrValue(pNode, "SameAsSignature", "");
        if (sameAsSig[0]) {
          sigParentTag = (icTagSignature)icGetSigVal(sameAsSig);
        }
        else {
          parseStr += "Invalid SameAsSignature for PrivateSubTag\n";
          return false;
        }
      }
      pTag = this->FindElem(sigParentTag);
      if (pTag) {
        AttachElem(sigTag, pTag);
      }
      else {
        parseStr += "SameAs tag ";
        parseStr += sameAs;
        parseStr += " for ";
        parseStr += nodeName + " does not exist\n";
        return false;
      }

      return true;
    }
    else { //Parse the type node as the first child
      xmlNode *pTypeNode;
      for (pTypeNode = pNode->children; pTypeNode; pTypeNode = pTypeNode->next) {
        if (pTypeNode->type == XML_ELEMENT_NODE) {
          break;
        }
      }

      if (!pTypeNode) {
        parseStr += "No tag type node defined for ";
        parseStr += nodeName;
        parseStr += "\n";
        return false;
      }

      // get the tag type signature
      icTagTypeSignature sigType = icGetTypeNameTagSig((const icChar*)pTypeNode->name);

      if (sigType == icSigUnknownType) {
        xmlAttr *attr = icXmlFindAttr(pTypeNode, "type");
        sigType = (icTagTypeSignature)icGetSigVal((icChar*)icXmlAttrValue(attr));
      }

      CIccInfo info;

      // create a tag based on the signature
      pTag = CIccTag::Create(sigType);

      IIccExtensionTag *pExt;

      if (pTag && (pExt = pTag->GetExtension()) && !strcmp(pExt->GetExtClassName(), "CIccTagXml")) {
        CIccTagXml* pXmlTag = (CIccTagXml*)pExt;

        if (pXmlTag->ParseXml(pTypeNode->children, parseStr)) {
          if ((attr = icXmlFindAttr(pTypeNode, "reserved"))) {
            sscanf(icXmlAttrValue(attr), "%u", &pTag->m_nReserved);
          }
          AttachElem(sigTag, pTag);
        }
        else {
          parseStr += "Unable to Parse \"";
          parseStr += (const char*)pTypeNode->name;
          parseStr += "\" (";
          parseStr += nodeName;
          parseStr += ") Tag\n";
          return false;
        }
      }
      else {
        parseStr += "Invalid tag extension for \"";
        parseStr += (const char*)pTypeNode->name;
        parseStr += "\" (";
        parseStr += nodeName;
        parseStr += ") Tag\n";
        return false;
      }
    }
  }
  else {  //Legacy parsing of XML tags by type
    sigTag = (icTagSignature)0;
    // get the tag type signature
    icTagTypeSignature sigType = icGetTypeNameTagSig(nodeName.c_str());

    if (sigType == icSigUnknownType) {
      xmlAttr *attr = icXmlFindAttr(pNode, "type");
      sigType = (icTagTypeSignature)icGetSigVal((icChar*)icXmlAttrValue(attr));
    }

    CIccInfo info;

    // create a tag based on the signature
    pTag = CIccTag::Create(sigType);

    IIccExtensionTag *pExt;

    if (pTag && (pExt = pTag->GetExtension()) && !strcmp(pExt->GetExtClassName(), "CIccTagXml")) {
      CIccTagXml* pXmlTag = (CIccTagXml*)pExt;

      if (pXmlTag->ParseXml(pNode->children, parseStr)) {
        if ((attr = icXmlFindAttr(pNode, "reserved"))) {
          sscanf(icXmlAttrValue(attr), "%u", &pTag->m_nReserved);
        }

        for (xmlNode *tagSigNode = pNode->children; tagSigNode; tagSigNode = tagSigNode->next) {
          if (tagSigNode->type == XML_ELEMENT_NODE && !icXmlStrCmp(tagSigNode->name, "TagSignature")) {
            sigTag = (icTagSignature)icGetSigVal((const icChar*)tagSigNode->children->content);
            AttachElem(sigTag, pTag);
          }
        }
      }
      else {
        parseStr += "Unable to Parse \"";
        parseStr += info.GetTagTypeSigName(sigType);
        parseStr += "\" (";
        parseStr += nodeName;
        parseStr += ") Tag\n";
        return false;
      }
    }
    else {
      parseStr += "Invalid tag extension for \"";
      parseStr += info.GetTagTypeSigName(sigType);
      parseStr += "\" (";
      parseStr += nodeName;
      parseStr += ") Tag\n";
      return false;
    }
  }

  return true;
}
