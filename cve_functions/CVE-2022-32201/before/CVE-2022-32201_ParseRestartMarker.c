void EntropyParser::ParseRestartMarker(class ByteStream *io)
{
  LONG dt = io->PeekWord();
  
  while(dt == 0xffff) {
    // Found a filler byte. Skip over and try again.
    io->Get();
    dt = io->PeekWord();
  }
  
  if (dt == 0xffdc && m_bScanForDNL) {
    ParseDNLMarker(io);
  } else if (dt == m_usNextRestartMarker) {
    // Everything worked fine! Continue going after removing the marker.
    io->GetWord();
    Restart();
    m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;
    m_ulMCUsToGo          = m_ulRestartInterval;
    m_bSegmentIsValid     = true;
  } else {
    JPG_WARN(MALFORMED_STREAM,"EntropyParser::ParseRestartMarker",
             "entropy coder is out of sync, trying to advance to the next marker");
    // As said...
    //
    do {
      dt = io->Get();
      if (dt == ByteStream::EOF) {
        // Outch, run completely out of data.
        JPG_THROW(UNEXPECTED_EOF,"EntropyParser::ParseRestartMarker",
                  "run into end of file while trying to resync the entropy parser");
        //
        // Code never goes here...
        return;
      } else if (dt == 0xff) {
        // Could be a marker.
        io->LastUnDo();
        dt = io->PeekWord();
        // Depends now on the marker.
        if (dt >= 0xffd0 && dt < 0xffd8) {
          // Is a restart marker. If this is the correct one, just leave,
          // the entropy coder was behind and we are then again up at the
          // correct index.
          if (dt == m_usNextRestartMarker) {
            io->GetWord();
            Restart();
            m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;
            m_ulMCUsToGo          = m_ulRestartInterval;
            m_bSegmentIsValid     = true;
            return;
          } else if (((dt - m_usNextRestartMarker) & 0x07) >= 4) {
            // Here dt is *likely* behind, i.e. we need to skip more
            // data to advance to the correct restart marker.
            io->GetWord();
            // Remove the marker and keep going.
          } else {
            // Here dt is likely ahead, that is, the entropy decoder
            // should better skip the next entropy coded segment
            // completely and then should re-enter to re-examine whether
            // the marker fits. Keep the marker in the stream, then, but
            // do not continue to decode.
            m_bSegmentIsValid     = false;
            m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;
            m_ulMCUsToGo          = m_ulRestartInterval;
            // Do not run into a restart as this may pull bytes.
            return;
          }
        } else if (dt >= 0xffc0 && dt < 0xfff0) {
          // Is apparently some other marker, i.e. we are at the end of
          // the segment. Continue skipping until the end is reached and
          // the parser run out of fun...
          m_bSegmentIsValid     = false;
          m_usNextRestartMarker = (m_usNextRestartMarker + 1) & 0xfff7;
          m_ulMCUsToGo          = m_ulRestartInterval;
          // Do not run into a restart as this may pull bytes.
          return;
        } else {
          // Some garbadge data, or a 0xff00. Just eat it up, and continue
          // scanning. Note that a single Get is used here to eventually
          // skip over a "fill byte".
          io->Get();
        }
      }
    } while(true);
  }
}
