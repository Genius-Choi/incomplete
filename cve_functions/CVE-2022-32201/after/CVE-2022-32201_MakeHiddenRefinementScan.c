void Scan::MakeHiddenRefinementScan(UBYTE bitposition,class Component *comp,UBYTE start,UBYTE stop)
{
  bool colortrafo = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());
  bool residual   = false; // for a residual scan type.
  
  assert(m_pParser == NULL);

  
  if (m_pFrame->DepthOf() > 4)
    JPG_THROW(INVALID_PARAMETER,"Scan::MakeHiddenRefinementScan",
              "hidden refinement scans are confined to four components at most");

  m_ucScanStart    = start;
  m_ucScanStop     = stop; 
  m_ucLowBit       = bitposition;
  m_ucHighBit      = bitposition+1;
  m_ucHiddenBits   = 0; // not here anymore.
  m_bHidden        = true;

  switch(m_pFrame->ScanTypeOf()) { 
  case Residual:
  case ACResidual:
  case ResidualProgressive: 
  case ACResidualProgressive:
    // Only one component in the scan.
    assert(stop >= start);
      
    m_ucCount        = 1;
    m_ucComponent[0] = comp->IDOf();
    break;
  default:
    if (start == 0) {
      UBYTE i;
      
      assert(stop == 0); // This is a DC scan, hopefully.
      
      m_ucCount        = m_pFrame->DepthOf();
      for(i = 0;i < m_ucCount;i++) {
        m_ucComponent[i] = m_pFrame->ComponentOf(i)->IDOf();
        m_ucDCTable[i]   = 0;
        m_ucACTable[i]   = 0; // Fixed later.
      }
    } else {
      // Only one component in the scan.
      assert(stop >= start);
      
      m_ucCount        = 1;
      m_ucComponent[0] = comp->IDOf();
    }
    break;
  }
  
  switch(m_pFrame->ScanTypeOf()) {
  case Baseline:
  case Sequential:
  case Progressive:
    if (colortrafo) {
      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  // Luma uses a separate table.
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; // Chroma uses a separate table.
    } else {
      m_ucACTable[0] = 0;
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; // Chroma uses the same table.
    }
    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);
    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,
                                                start,stop,
                                                bitposition,bitposition+1,
                                                false,false);
    break;
  case ACSequential:
  case ACProgressive:
#if ACCUSOFT_CODE
    m_ucACTable[0] = 0;
    m_ucDCTable[0] = 0;
    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);
    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this,
                                                      start,stop,
                                                      bitposition,bitposition+1,
                                                      false,false);
#else
    JPG_THROW(NOT_IMPLEMENTED," Scan::MakeHiddenRefinementScan",
              "Arithmetic coding option not available in your code release, please contact Accusoft for a full version");
#endif
    break;
  case Residual:
  case ResidualProgressive:
    residual = true;
    // runs into the following.
  case ResidualDCT:
    if (colortrafo) {
      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  // Luma uses a separate table.
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; // Chroma uses a separate table.
    } else {
      m_ucACTable[0] = 0;
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; // Chroma uses the same table.
    }
    assert(residual == false || (start == 0 && stop == 63));
    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);
    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this,
                                                start,stop,
                                                bitposition,bitposition+1,
                                                false,residual);
    break;
  case ACResidual:
  case ACResidualProgressive:
    residual = true;
    // fall through
  case ACResidualDCT:
#if ACCUSOFT_CODE
    m_ucACTable[0] = 0;
    m_ucDCTable[0] = 0;
    assert(residual == false || (start == 0 && stop == 63));
    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);
    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this,
                                                      start,stop,
                                                      bitposition,bitposition+1,
                                                      false,residual);
#else
    JPG_THROW(NOT_IMPLEMENTED," Scan::MakeHiddenRefinementScan",
              "Arithmetic coding option not available in your code release, please contact Accusoft for a full version");
#endif   
    break;
  default:
    JPG_THROW(INVALID_PARAMETER,"Scan::MakeHiddenRefinementScan",
              "frame type does not support hidden refinement scans");
    break;
  }
}
