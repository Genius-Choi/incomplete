PJ_DEF(pj_status_t) pjmedia_vid_conf_create(
					pj_pool_t *pool,
					const pjmedia_vid_conf_setting *opt,
					pjmedia_vid_conf **p_vid_conf)
{
    pjmedia_vid_conf *vid_conf;
    pjmedia_clock_param clock_param;
    pj_status_t status;

    PJ_ASSERT_RETURN(pool && p_vid_conf, PJ_EINVAL);

    /* Allocate conf structure */
    vid_conf = PJ_POOL_ZALLOC_T(pool, pjmedia_vid_conf);
    PJ_ASSERT_RETURN(vid_conf, PJ_ENOMEM);

    /* Init settings */
    if (opt) {
	vid_conf->opt = *opt;
    } else {
	pjmedia_vid_conf_setting_default(&vid_conf->opt);
    }

    /* Allocate ports */
    vid_conf->ports = (vconf_port**)
		      pj_pool_zalloc(pool, vid_conf->opt.max_slot_cnt *
					   sizeof(vconf_port*));
    PJ_ASSERT_RETURN(vid_conf->ports, PJ_ENOMEM);

    /* Create mutex */
    status = pj_mutex_create_recursive(pool, CONF_NAME, &vid_conf->mutex);
    if (status != PJ_SUCCESS) {
	pjmedia_vid_conf_destroy(vid_conf);
	return status;
    }

    /* Create clock */
    pj_bzero(&clock_param, sizeof(clock_param));
    clock_param.clock_rate = TS_CLOCK_RATE;
    clock_param.usec_interval = 1000000 / vid_conf->opt.frame_rate;
    status = pjmedia_clock_create2(pool, &clock_param, 0, &on_clock_tick,
				   vid_conf, &vid_conf->clock);
    if (status != PJ_SUCCESS) {
	pjmedia_vid_conf_destroy(vid_conf);
	return status;
    }

    /* Done */
    *p_vid_conf = vid_conf;

    PJ_LOG(5,(THIS_FILE, "Created video conference bridge with %d ports",
	      vid_conf->opt.max_slot_cnt));

    return PJ_SUCCESS;
}
