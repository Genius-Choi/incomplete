static pj_status_t codec_decode( pjmedia_codec *codec, 
				 const struct pjmedia_frame *input,
				 unsigned output_buf_len, 
				 struct pjmedia_frame *output)
{
    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;
#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR
    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];
#endif
    pjmedia_frame_ext *output_ = (pjmedia_frame_ext*) output;

    pj_assert(input);
    PJ_UNUSED_ARG(output_buf_len);

#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR
    /* Need to rearrange the AMR bitstream, since the bitstream may not be 
     * started from bit 0 or may need to be reordered from sensitivity order 
     * into encoder bits order.
     */
    if (desc->pt == PJMEDIA_RTP_PT_AMR || desc->pt == PJMEDIA_RTP_PT_AMRWB) {
	pjmedia_frame input_;
	pjmedia_codec_amr_pack_setting *setting;

	setting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;

	input_ = *input;
	pjmedia_codec_amr_predecode(input, setting, &input_);
	
	pjmedia_frame_ext_append_subframe(output_, input_.buf, 
					  (pj_uint16_t)(input_.size << 3),
					  (pj_uint16_t)codec_data->samples_per_frame);
	output->timestamp = input->timestamp;
	
	return PJ_SUCCESS;
    }
#endif
    
    pjmedia_frame_ext_append_subframe(output_, input->buf, 
				      (pj_uint16_t)(input->size << 3),
				      (pj_uint16_t)codec_data->samples_per_frame);
    output->timestamp = input->timestamp;

    return PJ_SUCCESS;
}
