static pj_status_t and_media_codec_parse(pjmedia_codec *codec,
					 void *pkt,
					 pj_size_t pkt_size,
					 const pj_timestamp *ts,
					 unsigned *frame_cnt,
					 pjmedia_frame frames[])
{
    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;
    struct and_media_codec *and_media_data =
					&and_media_codec[codec_data->codec_idx];
    unsigned count = 0;

    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);

    if (and_media_data->parse != NULL) {
	return and_media_data->parse(codec_data, pkt,  pkt_size, ts, frame_cnt,
				     frames);
    }

    while (pkt_size >= codec_data->frame_size && count < *frame_cnt) {
	frames[count].type = PJMEDIA_FRAME_TYPE_AUDIO;
	frames[count].buf = pkt;
	frames[count].size = codec_data->frame_size;
	frames[count].timestamp.u64 = ts->u64 +
				      count*and_media_data->samples_per_frame;
	pkt = ((char*)pkt) + codec_data->frame_size;
	pkt_size -= codec_data->frame_size;
	++count;
    }

    if (pkt_size && count < *frame_cnt) {
	frames[count].type = PJMEDIA_FRAME_TYPE_AUDIO;
	frames[count].buf = pkt;
	frames[count].size = pkt_size;
	frames[count].timestamp.u64 = ts->u64 +
				      count*and_media_data->samples_per_frame;
	++count;
    }

    *frame_cnt = count;
    return PJ_SUCCESS;
}
