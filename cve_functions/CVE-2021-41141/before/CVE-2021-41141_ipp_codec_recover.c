static pj_status_t  ipp_codec_recover(pjmedia_codec *codec, 
				      unsigned output_buf_len, 
				      struct pjmedia_frame *output)
{
    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;
    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];
    unsigned samples_per_frame;

    PJ_UNUSED_ARG(output_buf_len);

    samples_per_frame = ippc->samples_per_frame;

    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    output->size = samples_per_frame << 1;

    if (codec_data->plc_enabled) {
	if (codec_data->plc) {
	    pjmedia_plc_generate(codec_data->plc, (pj_int16_t*)output->buf);
	} else {
	    USC_PCMStream out;
	    out.pBuffer = output->buf;
	    ippc->fxns->Decode(codec_data->dec, NULL, &out);
	}
    } else {
	pjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);
    }

    return PJ_SUCCESS;
}
