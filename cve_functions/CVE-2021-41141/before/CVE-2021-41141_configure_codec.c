static pj_status_t configure_codec(and_media_private_t *and_media_data,
				   pj_bool_t is_encoder)
{
    media_status_t am_status;
    AMediaFormat *aud_fmt;
    int idx = and_media_data->codec_idx;
    AMediaCodec *codec = (is_encoder?and_media_data->enc:and_media_data->dec);

    aud_fmt = AMediaFormat_new();
    if (!aud_fmt) {
        return PJ_ENOMEM;
    }
    AMediaFormat_setString(aud_fmt, AND_MEDIA_KEY_MIME,
                           and_media_codec[idx].mime_type);
    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_PCM_ENCODING, 2);
    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_CHANNEL_COUNT,
                          and_media_codec[idx].channel_count);
    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_SAMPLE_RATE,
			  and_media_codec[idx].clock_rate);
    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_BITRATE,
			  and_media_codec[idx].def_bitrate);

    /* Configure and start encoder. */
    am_status = AMediaCodec_configure(codec, aud_fmt, NULL, NULL, is_encoder);
    AMediaFormat_delete(aud_fmt);
    if (am_status != AMEDIA_OK) {
        PJ_LOG(4, (THIS_FILE, "%s [0x%x] configure failed, status=%d",
               is_encoder?"Encoder":"Decoder", codec, am_status));
        return PJMEDIA_CODEC_EFAILED;
    }
    am_status = AMediaCodec_start(codec);
    if (am_status != AMEDIA_OK) {
	PJ_LOG(4, (THIS_FILE, "%s [0x%x] start failed, status=%d",
	       is_encoder?"Encoder":"Decoder", codec, am_status));
	return PJMEDIA_CODEC_EFAILED;
    }
    PJ_LOG(4, (THIS_FILE, "%s [0x%x] started", is_encoder?"Encoder":"Decoder",
	   codec));
    return PJ_SUCCESS;
}
