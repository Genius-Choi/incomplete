static void update_render_state(pjmedia_vid_conf *vid_conf, vconf_port *cp)
{
    pjmedia_format_id fmt_id, tr_fmt_id[4];
    pjmedia_rect_size size, tr_size[4];
    unsigned i;
    pj_status_t status;

    /* Nothing to render, just return */
    if (cp->transmitter_cnt == 0)
	return;

    TRACE_((THIS_FILE, "Updating render state for port id %d (%d sources)..",
	    cp->idx, cp->transmitter_cnt));

    fmt_id = cp->port->info.fmt.id;
    size   = cp->port->info.fmt.det.vid.size;
    for (i = 0; i < cp->transmitter_cnt; ++i) {
	vconf_port *tr = vid_conf->ports[cp->transmitter_slots[i]];

	/* Cleanup render states & pool */
	cleanup_render_state(cp, i);

	/* Gather format ID, size of each transmitter */
	tr_fmt_id[i] = tr->port->info.fmt.id;
	tr_size[i]   = tr->port->info.fmt.det.vid.size;
    }

    /* If only one transmitter and it has matched format & size, just use
     * plain memcpy(). Usually preview window or call stream window will
     * have matched format & size with its source.
     */
    if (cp->transmitter_cnt == 1 && fmt_id == tr_fmt_id[0] &&
	pj_memcmp(&size, &tr_size[0], sizeof(size))==0)
    {
	TRACE_((THIS_FILE, "This port only has single source with "
			   "matched format & size, no conversion needed"));
	return;
    }

    for (i = 0; i < cp->transmitter_cnt && i < 4; ++i) {
	pj_pool_t *pool;
	render_state *rs;
	pjmedia_conversion_param cparam;
	char tmp_buf[32];

	/* Create pool & render state */
	pj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), "vcport_rs_%d->%d",
			 cp->transmitter_slots[i], cp->idx);
	pool = pj_pool_create(cp->pool->factory, tmp_buf, 128, 128, NULL);
	cp->render_pool[i] = pool;
	rs = cp->render_states[i] = PJ_POOL_ZALLOC_T(pool, render_state);

	TRACE_((THIS_FILE, "Created render state for connection %d->%d",
			   cp->transmitter_slots[i], cp->idx));

	/* Setup format & frame */
	rs->src_fmt_id = tr_fmt_id[i];
	rs->dst_fmt_id = fmt_id;
	rs->src_frame_size = tr_size[i];
	rs->dst_frame_size = size;

	/* For now, draw the whole source frame, will adjust ratio later */
	rs->src_rect.coord.x = rs->src_rect.coord.y = 0;
	rs->src_rect.size = tr_size[i];

	/* Setup layout */
	if (cp->transmitter_cnt == 1) {
	    rs->dst_rect.coord.x = rs->dst_rect.coord.y = 0;
	    rs->dst_rect.size = size;
	} else if (cp->transmitter_cnt == 2) {
	    if (is_landscape(&size)) {
		/*
		 *          |
		 * Source 0 | Source 1
		 *          |
		 */
		rs->dst_rect.coord.x = i * (size.w/2);
		rs->dst_rect.coord.y = 0;
		rs->dst_rect.size.w = size.w / 2;
		rs->dst_rect.size.h = size.h;
	    } else {
		/*
		 * Source 0
		 * --------
		 * Source 1
		 */
		rs->dst_rect.coord.x = 0;
		rs->dst_rect.coord.y = i * (size.h/2);
		rs->dst_rect.size.w = size.w;
		rs->dst_rect.size.h = size.h / 2;
	    }
	} else if (cp->transmitter_cnt == 3) {
	    if (is_landscape(&size)) {
		/*
		 *          | Source 1
		 * Source 0 |---------
		 *          | Source 2
		 */
		rs->dst_rect.coord.x = (i==0)? 0 : size.w/2;
		rs->dst_rect.coord.y = (i!=2)? 0 : size.h/2;
		rs->dst_rect.size.w = size.w / 2;
		rs->dst_rect.size.h = (i==0)? size.h : size.h/2;
	    } else {
		/*
		 * Source 0
		 * --------
		 * Source 1
		 * --------
		 * Source 2
		 */
		rs->dst_rect.coord.x = 0;
		rs->dst_rect.coord.y = i * size.h/3;
		rs->dst_rect.size.w = size.w;
		rs->dst_rect.size.h = size.h/3;
	    }
	} else if (cp->transmitter_cnt == 4) {
	    if (is_landscape(&size)) {
		/*
		 * Source 0 | Source 1
		 * ---------|---------
		 * Source 2 | Source 3
		 */
		rs->dst_rect.coord.x = (i%2==0)? 0 : size.w/2;
		rs->dst_rect.coord.y = (i/2==0)? 0 : size.h/2;
		rs->dst_rect.size.w = size.w/2;
		rs->dst_rect.size.h = size.h/2;
	    } else {
		/*
		 * Source 0
		 * --------
		 * Source 1
		 * --------
		 * Source 2
		 * --------
		 * Source 3
		 */
		rs->dst_rect.coord.x = 0;
		rs->dst_rect.coord.y = i * size.h/4;
		rs->dst_rect.size.w = size.w;
		rs->dst_rect.size.h = size.h/4;
	    }
	}

	/* Adjust source size to match aspect ratio of rendering space. */
	match_ratio_crop(&rs->src_rect.size, &rs->dst_rect.size);

	/* Now adjust source position after source size adjustment. */
	if (rs->src_rect.size.w < tr_size[i].w)
	    rs->src_rect.coord.x = (tr_size[i].w - rs->src_rect.size.w)/2;
	if (rs->src_rect.size.h < tr_size[i].h)
	    rs->src_rect.coord.y = (tr_size[i].h - rs->src_rect.size.h)/2;

	TRACE_((THIS_FILE, "src#%d=%s/%dx%d->%dx%d@%d,%d dst=%dx%d@%d,%d",
			   i, pjmedia_fourcc_name(tr_fmt_id[i], tmp_buf),
			   tr_size[i].w, tr_size[i].h,
			   rs->src_rect.size.w, rs->src_rect.size.h,
			   rs->src_rect.coord.x, rs->src_rect.coord.y,
			   rs->dst_rect.size.w, rs->dst_rect.size.h,
			   rs->dst_rect.coord.x, rs->dst_rect.coord.y));

	/* Create converter */
	pjmedia_format_init_video(&cparam.src, rs->src_fmt_id,
				  rs->src_rect.size.w,
				  rs->src_rect.size.h,
				  0, 1);
	pjmedia_format_init_video(&cparam.dst, rs->dst_fmt_id,
				  rs->dst_rect.size.w,
				  rs->dst_rect.size.h,
				  0, 1);
	status = pjmedia_converter_create(NULL, pool, &cparam,
					  &rs->converter);
	if (status != PJ_SUCCESS) {
	    PJ_PERROR(4,(THIS_FILE, status,
			 "Port %d failed creating converter "
			 "for source %d", cp->idx, i));
	}
    }
}
