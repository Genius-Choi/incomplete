static pj_status_t  spx_codec_parse( pjmedia_codec *codec,
				     void *pkt,
				     pj_size_t pkt_size,
				     const pj_timestamp *ts,
				     unsigned *frame_cnt,
				     pjmedia_frame frames[])
{
    struct spx_private *spx = (struct spx_private*) codec->codec_data;
    unsigned samples_per_frame;
    unsigned count = 0;
    int char_ptr = 0;
    int bit_ptr = 0;

    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;

    /* Copy the data into the speex bit-stream */
    speex_bits_read_from(&spx->dec_bits, (char*)pkt, (int)pkt_size);

    while (speex_get_next_frame(&spx->dec_bits) == 0 && 
	   spx->dec_bits.charPtr != char_ptr)
    {
	frames[count].buf = (char*)pkt + char_ptr;
	/* Bit info contains start bit offset of the frame */
	frames[count].bit_info = bit_ptr;
	frames[count].type = PJMEDIA_FRAME_TYPE_AUDIO;
	frames[count].timestamp.u64 = ts->u64 +
				      (pj_uint64_t)count * samples_per_frame;
	frames[count].size = spx->dec_bits.charPtr - char_ptr;
	if (spx->dec_bits.bitPtr)
	    ++frames[count].size;

	bit_ptr = spx->dec_bits.bitPtr;
	char_ptr = spx->dec_bits.charPtr;

	++count;
    }

    *frame_cnt = count;

    return PJ_SUCCESS;
}
