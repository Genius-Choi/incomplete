static pj_status_t ipp_codec_open( pjmedia_codec *codec, 
				   pjmedia_codec_param *attr )
{
    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;
    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];
    int info_size;
    pj_pool_t *pool;
    int i, j;
    USC_MemBank *membanks;
    int nb_membanks;

    pool = codec_data->pool;

    /* Get the codec info size */
    if (USC_NoError != ippc->fxns->std.GetInfoSize(&info_size)) {
	PJ_LOG(1,(THIS_FILE, "Error getting codec info size"));
	goto on_error;
    }
    /* Get the codec info */
    codec_data->info = pj_pool_zalloc(pool, info_size);
    if (USC_NoError != ippc->fxns->std.GetInfo((USC_Handle)NULL, 
					       codec_data->info))
    {
	PJ_LOG(1,(THIS_FILE, "Error getting codec info"));
	goto on_error;
    }

    /* PREPARING THE ENCODER */

    /* Setting the encoder params */
    codec_data->info->params.direction = USC_ENCODE;
    codec_data->info->params.modes.vad = attr->setting.vad && 
					 ippc->has_native_vad;
    codec_data->info->params.modes.bitrate = attr->info.avg_bps;
    codec_data->info->params.law = 0; /* Linear PCM input */

#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729
    if (ippc->pt == PJMEDIA_RTP_PT_G729) {
	/* Check if G729 Annex B is signaled to be disabled */
	for (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {
	    if (pj_stricmp2(&attr->setting.enc_fmtp.param[i].name, "annexb")==0)
	    {
		if (pj_stricmp2(&attr->setting.enc_fmtp.param[i].val, "no")==0)
		{
		    attr->setting.vad = 0;
		    codec_data->info->params.modes.vad = 0;
		}
		break;
	    }
	}
    }
#endif

    /* Get number of memory blocks needed by the encoder */
    if (USC_NoError != ippc->fxns->std.NumAlloc(&codec_data->info->params,
					        &nb_membanks))
    {
	PJ_LOG(1,(THIS_FILE, "Error getting no of memory blocks of encoder"));
	goto on_error;
    }

    /* Allocate memory blocks table */
    membanks = (USC_MemBank*) pj_pool_zalloc(pool, 
					     sizeof(USC_MemBank) * nb_membanks);
    /* Get size of each memory block */
    if (USC_NoError != ippc->fxns->std.MemAlloc(&codec_data->info->params, 
					        membanks))
    {
	PJ_LOG(1,(THIS_FILE, "Error getting memory blocks size of encoder"));
	goto on_error;
    }

    /* Allocate memory for each block */
    for (i = 0; i < nb_membanks; i++) {
	membanks[i].pMem = (char*) pj_pool_zalloc(pool, membanks[i].nbytes);
    }

    /* Create encoder instance */
    if (USC_NoError != ippc->fxns->std.Init(&codec_data->info->params,
					    membanks, 
					    &codec_data->enc))
    {
	PJ_LOG(1,(THIS_FILE, "Error initializing encoder"));
	goto on_error;
    }

    /* PREPARING THE DECODER */

    /* Setting the decoder params */
    codec_data->info->params.direction = USC_DECODE;

    /* Not sure if VAD affects decoder, just try to be safe */
    //codec_data->info->params.modes.vad = ippc->has_native_vad;

    /* Get number of memory blocks needed by the decoder */
    if (USC_NoError != ippc->fxns->std.NumAlloc(&codec_data->info->params, 
						 &nb_membanks))
    {
	PJ_LOG(1,(THIS_FILE, "Error getting no of memory blocks of decoder"));
	goto on_error;
    }

    /* Allocate memory blocks table */
    membanks = (USC_MemBank*) pj_pool_zalloc(pool, 
					     sizeof(USC_MemBank) * nb_membanks);
    /* Get size of each memory block */
    if (USC_NoError != ippc->fxns->std.MemAlloc(&codec_data->info->params, 
						membanks))
    {
	PJ_LOG(1,(THIS_FILE, "Error getting memory blocks size of decoder"));
	goto on_error;
    }

    /* Allocate memory for each block */
    for (i = 0; i < nb_membanks; i++) {
	membanks[i].pMem = (char*) pj_pool_zalloc(pool, membanks[i].nbytes);
    }

    /* Create decoder instance */
    if (USC_NoError != ippc->fxns->std.Init(&codec_data->info->params, 
					    membanks, &codec_data->dec))
    {
	PJ_LOG(1,(THIS_FILE, "Error initializing decoder"));
	goto on_error;
    }

    /* Update codec info */
    ippc->fxns->std.GetInfo((USC_Handle)codec_data->enc, codec_data->info);

    /* Get bitstream size */
    i = codec_data->info->params.modes.bitrate * ippc->samples_per_frame;
    j = ippc->clock_rate << 3;
    codec_data->frame_size = (pj_uint16_t)(i / j);
    if (i % j) ++codec_data->frame_size;

    codec_data->vad_enabled = (attr->setting.vad != 0);
    codec_data->plc_enabled = (attr->setting.plc != 0);

#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR
    /* Init AMR settings */
    if (ippc->pt == PJMEDIA_RTP_PT_AMR || ippc->pt == PJMEDIA_RTP_PT_AMRWB) {
	amr_settings_t *s;
	pj_uint8_t octet_align = 0;
	pj_int8_t enc_mode;

	enc_mode = pjmedia_codec_amr_get_mode(
				codec_data->info->params.modes.bitrate);
	pj_assert(enc_mode >= 0 && enc_mode <= 8);

	/* Check AMR specific attributes */

	for (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {
	    /* octet-align, one of the parameters that must have same value 
	     * in offer & answer (RFC 4867 Section 8.3.1). Just check fmtp
	     * in the decoder side, since it's value is guaranteed to fulfil 
	     * above requirement (by SDP negotiator).
	     */
	    const pj_str_t STR_FMTP_OCTET_ALIGN = {"octet-align", 11};
	    
	    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, 
			   &STR_FMTP_OCTET_ALIGN) == 0)
	    {
		octet_align=(pj_uint8_t)
			    pj_strtoul(&attr->setting.dec_fmtp.param[i].val);
		break;
	    }
	}

	for (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {
	    /* mode-set, encoding mode is chosen based on local default mode 
	     * setting:
	     * - if local default mode is included in the mode-set, use it
	     * - otherwise, find the closest mode to local default mode;
	     *   if there are two closest modes, prefer to use the higher
	     *   one, e.g: local default mode is 4, the mode-set param
	     *   contains '2,3,5,6', then 5 will be chosen.
	     */
	    const pj_str_t STR_FMTP_MODE_SET = {"mode-set", 8};
	    
	    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, 
			   &STR_FMTP_MODE_SET) == 0)
	    {
		const char *p;
		pj_size_t l;
		pj_int8_t diff = 99;
		
		p = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);
		l = pj_strlen(&attr->setting.enc_fmtp.param[i].val);

		while (l--) {
		    if ((ippc->pt==PJMEDIA_RTP_PT_AMR && *p>='0' && *p<='7') ||
		        (ippc->pt==PJMEDIA_RTP_PT_AMRWB && *p>='0' && *p<='8'))
		    {
			pj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);

			if (PJ_ABS(diff) > PJ_ABS(tmp) || 
			    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))
			{
			    diff = tmp;
			    if (diff == 0) break;
			}
		    }
		    ++p;
		}

		if (diff == 99)
		    goto on_error;

		enc_mode = (pj_int8_t)(enc_mode + diff);

		break;
	    }
	}

	/* Initialize AMR specific settings */
	s = PJ_POOL_ZALLOC_T(pool, amr_settings_t);
	codec_data->codec_setting = s;

	s->enc_setting.amr_nb = (pj_uint8_t)(ippc->pt == PJMEDIA_RTP_PT_AMR);
	s->enc_setting.octet_aligned = octet_align;
	s->enc_setting.reorder = PJ_TRUE;
	s->enc_setting.cmr = 15;

	s->dec_setting.amr_nb = (pj_uint8_t)(ippc->pt == PJMEDIA_RTP_PT_AMR);
	s->dec_setting.octet_aligned = octet_align;
	s->dec_setting.reorder = PJ_TRUE;

	/* Apply encoder mode/bitrate */
	s->enc_mode = enc_mode;
	codec_data->info->params.modes.bitrate = s->enc_setting.amr_nb?
				pjmedia_codec_amrnb_bitrates[s->enc_mode]:
				pjmedia_codec_amrwb_bitrates[s->enc_mode];
	ippc->fxns->std.Control(&codec_data->info->params.modes, 
				codec_data->enc);

	PJ_LOG(4,(THIS_FILE, "AMR%s encoding mode: %d (%dbps)", 
		  (s->enc_setting.amr_nb?"":"-WB"),
		  s->enc_mode,
		  codec_data->info->params.modes.bitrate));

	/* Return back bitrate info to application */
	attr->info.avg_bps = codec_data->info->params.modes.bitrate;
    }
#endif

#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1
    if (ippc->pt >= PJMEDIA_RTP_PT_G722_1_16 && 
	ippc->pt <= PJMEDIA_RTP_PT_G7221_RSV2)
    {
	codec_data->g7221_pcm_shift = ipp_factory.g7221_pcm_shift;
    }
#endif

    return PJ_SUCCESS;

on_error:
    return PJMEDIA_CODEC_EFAILED;
}
