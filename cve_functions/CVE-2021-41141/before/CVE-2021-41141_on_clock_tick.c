static void on_clock_tick(const pj_timestamp *now, void *user_data)
{
    pjmedia_vid_conf *vid_conf = (pjmedia_vid_conf*)user_data;
    unsigned ci, i;
    pj_int32_t ts_diff;
    pjmedia_frame frame;
    pj_status_t status;

    pj_mutex_lock(vid_conf->mutex);

    /* Iterate all (sink) ports */
    for (i=0, ci=0; i<vid_conf->opt.max_slot_cnt &&
		    ci<vid_conf->port_cnt; ++i)
    {
	unsigned j;
	pj_bool_t got_frame = PJ_FALSE;
	pj_bool_t ts_incremented = PJ_FALSE;
	vconf_port *sink = vid_conf->ports[i];

	/* Skip empty port */
	if (!sink)
	    continue;

	/* Increment occupied port counter */
	++ci;

	/* Skip non-sink port */
	if (!sink->port->put_frame)
	    continue;

	if (sink->ts_next.u64 == 0)
	    sink->ts_next = *now;

	/* Skip if too early for put_frame(), note:
	 * early = (now < ts_next)
	 * But careful for timestamp wrapped around.
	 */
	ts_diff = pj_timestamp_diff32(&sink->ts_next, now);
	if (ts_diff < 0 || ts_diff > TS_CLOCK_RATE)
	    continue;

	/* Clean up sink put buffer (should we draw black instead?) */
	//pj_bzero(sink->put_buf, sink->put_buf_size);

	/* Iterate transmitters of this sink port */
	for (j=0; j < sink->transmitter_cnt; ++j) {
	    vconf_port *src = vid_conf->ports[sink->transmitter_slots[j]];
	    pj_int32_t src_ts_diff;

	    if (src->ts_next.u64 == 0)
		src->ts_next = *now;

	    /* Is it time for src->get_frame()? yes, if (now >= ts_next) */
	    src_ts_diff = pj_timestamp_diff32(&src->ts_next, now);
	    if (src_ts_diff >= 0) {

		/* Call src->get_frame().
		 * Possible optimization: if this src only has one listener,
		 * perhaps we can skip this src buffer and directly render it
		 * to sink buffer (but still need buffer if conversion any).
		 */
		pj_bzero(&frame, sizeof(frame));
		frame.type = PJMEDIA_FRAME_TYPE_VIDEO;
		frame.timestamp = *now;
		frame.buf = src->get_buf;
		frame.size = src->get_buf_size;
		status = pjmedia_port_get_frame(src->port, &frame);
		if (status != PJ_SUCCESS) {
		    PJ_PERROR(5, (THIS_FILE, status,
				  "Failed to get frame from port %d [%s]!",
				  src->idx, src->port->info.name.ptr));
		}

		/* Update next src put/get */
		pj_add_timestamp32(&src->ts_next, src->ts_interval);
		ts_incremented = src==sink;
	    }

	    /* Render src get buffer to sink put buffer (based on sink layout
	     * settings, if any)
	     */
	    status = render_src_frame(src, sink, j);
	    if (status != PJ_SUCCESS) {
		PJ_PERROR(5, (THIS_FILE, status,
			      "Failed to render frame from port %d [%s] to "
			      "%d [%s]",
			      src->idx, src->port->info.name.ptr,
			      sink->idx, sink->port->info.name.ptr));
	    }

	    got_frame = PJ_TRUE;
	}

	/* Call sink->put_frame()
	 * Note that if transmitter_cnt==0, we should still call put_frame()
	 * with zero frame size, as sink may need to send keep-alive packets
	 * and get timestamp update.
	 */
	pj_bzero(&frame, sizeof(frame));
	frame.type = PJMEDIA_FRAME_TYPE_VIDEO;
	frame.timestamp = *now;
	if (got_frame) {
	    frame.buf = sink->put_buf;
	    frame.size = sink->put_buf_size;
	}
	status = pjmedia_port_put_frame(sink->port, &frame);
	if (got_frame && status != PJ_SUCCESS) {
	    sink->last_err_cnt++;
	    if (sink->last_err != status ||
	        sink->last_err_cnt % MAX_ERR_COUNT == 0)
	    {
		if (sink->last_err != status)
		    sink->last_err_cnt = 1;
		sink->last_err = status;
	    	PJ_PERROR(5, (THIS_FILE, status,
			      "Failed (%d time(s)) to put frame to port %d"
			      " [%s]!", sink->last_err_cnt,
			      sink->idx, sink->port->info.name.ptr));
	    }
	} else {
	    sink->last_err = status;
	    sink->last_err_cnt = 0;
	}

	/* Update next put/get, careful that it may have been updated
	 * if this port transmits to itself!
	 */
	if (!ts_incremented) {
	    pj_add_timestamp32(&sink->ts_next, sink->ts_interval);
	}
    }

    pj_mutex_unlock(vid_conf->mutex);
}
