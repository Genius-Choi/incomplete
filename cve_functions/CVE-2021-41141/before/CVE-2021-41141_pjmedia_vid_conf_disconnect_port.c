PJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port(
					    pjmedia_vid_conf *vid_conf,
					    unsigned src_slot,
					    unsigned sink_slot)
{
    vconf_port *src_port, *dst_port;
    unsigned i, j;

    /* Check arguments */
    PJ_ASSERT_RETURN(vid_conf &&
		     src_slot<vid_conf->opt.max_slot_cnt && 
		     sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);

    pj_mutex_lock(vid_conf->mutex);

    /* Ports must be valid. */
    src_port = vid_conf->ports[src_slot];
    dst_port = vid_conf->ports[sink_slot];
    if (!src_port || !dst_port) {
	pj_mutex_unlock(vid_conf->mutex);
	return PJ_EINVAL;
    }

    /* Check if connection has been made */
    for (i=0; i<src_port->listener_cnt; ++i) {
	if (src_port->listener_slots[i] == sink_slot)
	    break;
    }
    for (j=0; j<dst_port->transmitter_cnt; ++j) {
	if (dst_port->transmitter_slots[j] == src_slot)
	    break;
    }

    if (i != src_port->listener_cnt && j != dst_port->transmitter_cnt) {
	unsigned k;

	pj_assert(src_port->listener_cnt > 0 && 
		  src_port->listener_cnt < vid_conf->opt.max_slot_cnt);
	pj_assert(dst_port->transmitter_cnt > 0 && 
		  dst_port->transmitter_cnt < vid_conf->opt.max_slot_cnt);

	/* Cleanup all render states of the sink */
	for (k=0; k<dst_port->transmitter_cnt; ++k)
	    cleanup_render_state(dst_port, k);

	/* Update listeners array of the source and transmitters array of
	 * the sink.
	 */
	pj_array_erase(src_port->listener_slots, sizeof(unsigned), 
		       src_port->listener_cnt, i);
	pj_array_erase(dst_port->transmitter_slots, sizeof(unsigned), 
		       dst_port->transmitter_cnt, j);
	--src_port->listener_cnt;
	--dst_port->transmitter_cnt;

	/* Update render states of the sink */
	update_render_state(vid_conf, dst_port);

	--vid_conf->connect_cnt;

	if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {
	    pj_status_t status;
	    /* Warning: will stuck if this is called from the clock thread */
	    status = pjmedia_clock_stop(vid_conf->clock);
	    if (status != PJ_SUCCESS) {
		PJ_PERROR(4, (THIS_FILE, status, "Failed to stop clock"));
		return status;
	    }
	}

	PJ_LOG(4,(THIS_FILE,
		  "Port %d (%.*s) stop transmitting to port %d (%.*s)",
		  src_slot,
		  (int)src_port->name.slen,
		  src_port->name.ptr,
		  sink_slot,
		  (int)dst_port->name.slen,
		  dst_port->name.ptr));
    }

    pj_mutex_unlock(vid_conf->mutex);

    return PJ_SUCCESS;
}
