static pj_status_t and_media_codec_decode(pjmedia_codec *codec,
					  const struct pjmedia_frame *input,
					  unsigned output_buf_len,
					  struct pjmedia_frame *output)
{
    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;
    struct and_media_codec *and_media_data =
					&and_media_codec[codec_data->codec_idx];
    unsigned samples_per_frame;
    unsigned i;

    pj_uint8_t pt;
    pj_ssize_t buf_idx = -1;
    pj_uint8_t *input_buf;
    pj_size_t input_size;
    pj_size_t output_size;
    media_status_t am_status;
    AMediaCodecBufferInfo buf_info;
    pj_uint8_t *output_buf;
    pjmedia_frame input_;

    pj_bzero(&input_, sizeof(pjmedia_frame));
    pt = and_media_data->pt;
    samples_per_frame = and_media_data->samples_per_frame;

    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,
		     PJMEDIA_CODEC_EPCMTOOSHORT);

    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO)
    {
	goto on_return;
    }

    buf_idx = AMediaCodec_dequeueInputBuffer(codec_data->dec,
					     CODEC_DEQUEUE_TIMEOUT);

    if (buf_idx < 0) {
	PJ_LOG(4,(THIS_FILE, "Decoder dequeueInputBuffer failed return %d",
		  buf_idx));
	goto on_return;
    }

    input_buf = AMediaCodec_getInputBuffer(codec_data->dec,
					   buf_idx,
					   &input_size);
    if (input_buf == 0) {
	PJ_LOG(4,(THIS_FILE, "Decoder getInputBuffer failed "
		  "return input_buf=%d, size=%d", input_buf, input_size));
	goto on_return;
    }

    if (and_media_data->predecode) {
	input_.buf = input_buf;
	and_media_data->predecode(codec_data, input, &input_);
    } else {
	input_.size = input->size;
	pj_memcpy(input_buf, input->buf, input->size);
    }

    am_status = AMediaCodec_queueInputBuffer(codec_data->dec,
					     buf_idx,
					     0,
					     input_.size,
					     input->timestamp.u32.lo,
					     0);
    if (am_status != AMEDIA_OK) {
	PJ_LOG(4,(THIS_FILE, "Decoder queueInputBuffer failed return %d",
		  am_status));
	goto on_return;
    }

    for (i = 0; i < CODEC_WAIT_RETRY; ++i) {
	buf_idx = AMediaCodec_dequeueOutputBuffer(codec_data->dec,
						  &buf_info,
						  CODEC_DEQUEUE_TIMEOUT);
	if (buf_idx == -1) {
	    /* Timeout, wait until output buffer is availble. */
	    PJ_LOG(5, (THIS_FILE, "Decoder dequeueOutputBuffer timeout[%d]",
		       i+1));
	    pj_thread_sleep(CODEC_THREAD_WAIT);
	} else {
	    break;
	}
    }
    if (buf_idx < 0) {
	PJ_LOG(5, (THIS_FILE, "Decoder dequeueOutputBuffer failed [%d]",
		   buf_idx));
	goto on_return;
    }

    output_buf = AMediaCodec_getOutputBuffer(codec_data->dec,
					     buf_idx,
					     &output_size);
    if (output_buf == NULL) {
	am_status = AMediaCodec_releaseOutputBuffer(codec_data->dec,
					buf_idx,
					0);
	if (am_status != AMEDIA_OK) {
	    PJ_LOG(4,(THIS_FILE, "Decoder releaseOutputBuffer failed %d",
		      am_status));
	}
	PJ_LOG(4,(THIS_FILE, "Decoder getOutputBuffer failed"));
	goto on_return;
    }
    pj_memcpy(output->buf, output_buf, buf_info.size);
    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    output->size = buf_info.size;
    output->timestamp.u64 = input->timestamp.u64;
    am_status = AMediaCodec_releaseOutputBuffer(codec_data->dec,
						buf_idx,
						0);

    /* Invoke external PLC if codec has no internal PLC */
    if (codec_data->plc && codec_data->plc_enabled)
	pjmedia_plc_save(codec_data->plc, (pj_int16_t*)output->buf);

    return PJ_SUCCESS;

on_return:
    pjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);
    output->size = samples_per_frame << 1;
    output->timestamp.u64 = input->timestamp.u64;
    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    return PJ_SUCCESS;
}
