Status BatchFunctionKernel::InstantiateFunction(
    OpKernelContext* c, FunctionLibraryRuntime::Handle* handle) const {
  // TODO(b/173748062): Merge this instantiation logic with PartitionedCall.
  if (!flib_) {
    return errors::Internal("No function library");
  }

  FunctionLibraryRuntime::InstantiateOptions opts;
  opts.target = flib_->device() == nullptr ? "" : flib_->device()->name();
  opts.is_multi_device_function = true;
  const ConfigProto* config = flib_->config_proto();
  if (config) {
    opts.config_proto = *config;
  }

  Device* cpu_device;
  TF_RETURN_IF_ERROR(flib_->device_mgr()->LookupDevice("CPU:0", &cpu_device));

  const FunctionDef* fdef =
      flib_->GetFunctionLibraryDefinition()->Find(func_.name());
  if (!fdef) {
    return errors::NotFound("Failed to find definition for function \"",
                            func_.name(), "\"");
  }
  OpInputList in_tensors;
  TF_RETURN_IF_ERROR(c->input_list("in_tensors", &in_tensors));
  for (int i = 0; i < in_tensors.size(); i++) {
    if (in_tensors[i].dtype() == DT_RESOURCE) {
      return errors::InvalidArgument(
          "BatchFunction cannot take resource inputs but input ", i,
          " is a resource.");
    } else {
      // Currently, inputs are on CPU since they are concatenated on CPU
      opts.input_devices.push_back(cpu_device->name());
    }
  }
  OpInputList captured_tensors;
  TF_RETURN_IF_ERROR(c->input_list("captured_tensors", &captured_tensors));
  for (const Tensor& t : captured_tensors) {
    if (t.dtype() == DT_RESOURCE) {
      const ResourceHandle& rhandle = t.flat<ResourceHandle>()(0);
      opts.input_devices.push_back(rhandle.device());
    } else {
      opts.input_devices.push_back(cpu_device->name());
    }
  }
  const OpDef& signature = fdef->signature();
  for (int i = 0; i < signature.output_arg_size(); i++) {
    // Currently, outputs must be on CPU since they are split on CPU.
    opts.output_devices.push_back(cpu_device->name());
  }
  if (opts.input_devices.size() != signature.input_arg_size()) {
    return errors::InvalidArgument(
        "Function takes ", signature.input_arg_size(), " argument(s) but ",
        opts.input_devices.size(), " argument(s) were passed");
  }
  return flib_->Instantiate(func_.name(), AttrSlice(&func_.attr()), opts,
                            handle);
}
