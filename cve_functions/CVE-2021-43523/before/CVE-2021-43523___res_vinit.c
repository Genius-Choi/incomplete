__res_vinit(res_state rp, int preinit)
{
	int i, n, options, retrans, retry, ndots;
#ifdef __UCLIBC_HAS_IPV6__
	int m = 0;
#endif

	__close_nameservers();
	__open_nameservers();

	if (preinit) {
		options = rp->options;
		retrans = rp->retrans;
		retry = rp->retry;
		ndots = rp->ndots;
	}

	memset(rp, 0, sizeof(*rp));

	if (!preinit) {
		rp->options = RES_DEFAULT;
		rp->retrans = RES_TIMEOUT;
		rp->retry = RES_DFLRETRY;
		rp->ndots = 1;
	} else {
		rp->options = options;
		rp->retrans = retrans;
		rp->retry = retry;
		rp->ndots = ndots;
	}

#ifdef __UCLIBC_HAS_COMPAT_RES_STATE__
	/* Was: "rp->id = random();" but:
	 * - random() pulls in largish static buffers
	 * - isn't actually random unless, say, srandom(time(NULL)) was called
	 * - is not used by uclibc anyway :)
	 */
	/* rp->id = 0; - memset did it */
#endif
#ifdef __UCLIBC_HAS_EXTRA_COMPAT_RES_STATE__
	rp->_vcsock = -1;
#endif

	n = __searchdomains;
	if (n > ARRAY_SIZE(rp->dnsrch))
		n = ARRAY_SIZE(rp->dnsrch);
	for (i = 0; i < n; i++)
		rp->dnsrch[i] = __searchdomain[i];

	/* copy nameservers' addresses */
	i = 0;
#ifdef __UCLIBC_HAS_IPV4__
	n = 0;
	while (n < ARRAY_SIZE(rp->nsaddr_list) && i < __nameservers) {
		if (__nameserver[i].sa.sa_family == AF_INET) {
			rp->nsaddr_list[n] = __nameserver[i].sa4; /* struct copy */
#ifdef __UCLIBC_HAS_IPV6__
			if (m < ARRAY_SIZE(rp->_u._ext.nsaddrs)) {
				rp->_u._ext.nsaddrs[m] = (void*) &rp->nsaddr_list[n];
				m++;
			}
#endif
			n++;
		}
#ifdef __UCLIBC_HAS_IPV6__
		if (__nameserver[i].sa.sa_family == AF_INET6
		 && m < ARRAY_SIZE(rp->_u._ext.nsaddrs)
		) {
			struct sockaddr_in6 *sa6 = malloc(sizeof(*sa6));
			if (sa6) {
				*sa6 = __nameserver[i].sa6; /* struct copy */
				rp->_u._ext.nsaddrs[m] = sa6;
				m++;
			}
		}
#endif
		i++;
	}
	rp->nscount = n;
#ifdef __UCLIBC_HAS_IPV6__
	rp->_u._ext.nscount = m;
#endif

#else /* IPv6 only */
	while (m < ARRAY_SIZE(rp->_u._ext.nsaddrs) && i < __nameservers) {
		struct sockaddr_in6 *sa6 = malloc(sizeof(*sa6));
		if (sa6) {
			*sa6 = __nameserver[i].sa6; /* struct copy */
			rp->_u._ext.nsaddrs[m] = sa6;
			m++;
		}
		i++;
	}
	rp->_u._ext.nscount = m;
#endif

	rp->options |= RES_INIT;

	return 0;
}
