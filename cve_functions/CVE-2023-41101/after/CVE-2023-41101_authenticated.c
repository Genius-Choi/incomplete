static int authenticated(struct MHD_Connection *connection,
						const char *url,
						t_client *client)
{
	s_config *config = config_get_config();
	const char *host = config->gw_address;
	char *redirect_to_us = NULL;
	char *fasurl;
	char *query;
	char *msg;
	char *clientif;
	const char *accept;
	char *originurl_raw = NULL;
	char *captive_json = NULL;
	char *buff;
	int rc;
	int ret;
	struct MHD_Response *response;

	ret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_host_value_callback, &host);

	if (ret < 1) {
		debug(LOG_ERR, "authenticated: Error getting host");
		return MHD_NO;
	} else {
		debug(LOG_DEBUG, "An authenticated client is requesting: host [%s] url [%s]", host, url);
	}

	if (host == NULL) {
		debug(LOG_ERR, "authenticated: Error getting host");
		host = config->gw_address;
	}

	// Is it an RFC8908 type request? - check Accept: header

	accept = safe_calloc(SMALL_BUF);
	ret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_accept_callback, &accept);

	if (ret < 1) {
		debug(LOG_ERR, "authenticated: Error getting Accept header");
		return MHD_NO;
	}

	if (accept && strcmp(accept, "application/captive+json") == 0) {
		debug(LOG_NOTICE, "authenticated: Accept header [%s]", accept);
		debug(LOG_NOTICE, "authenticated: RFC 8908 captive+json request received");

		originurl_raw = safe_calloc(SMALL_BUF);
		captive_json = safe_calloc(SMALL_BUF);

		if (strcmp(config->gw_fqdn, "disable") == 0 || strcmp(config->gw_fqdn, "disabled") == 0) {
			safe_asprintf(&originurl_raw, "http://%s", config->gw_ip);
		} else {
			safe_asprintf(&originurl_raw, "http://%s", config->gw_fqdn);
		}

		safe_asprintf(&captive_json,
			"{ \"captive\": false, \"user-portal-url\": \"%s\", \"venue-info-url\": \"%s\", \"can-extend-session\": false }",
			originurl_raw,
			originurl_raw
		);

		debug(LOG_DEBUG, "captive_json [%s]", captive_json);
		ret = send_json(connection, captive_json);

		free(originurl_raw);
		free(captive_json);
		return ret;
	}

	/* check if this is a late request, meaning the user tries to get the internet, but ended up here,
	 * because the nftables rule came too late
	 */
	if (is_foreign_hosts(connection, host)) {
		// might happen if the firewall rule isn't yet installed
			return send_error(connection, 511);
	}

	if (check_authdir_match(url, config->denydir)) {
		debug(LOG_NOTICE, "Deauthentication request - client  [%s]", client->mac);
		auth_client_deauth(client->id, "client_deauth");
		debug(LOG_DEBUG, "Post deauth redirection [%s]", config->gw_address);

		redirect_to_us = safe_calloc(QUERYMAXLEN);

		if (!redirect_to_us) {
			ret = send_error(connection, 503);
			free(redirect_to_us);
			return ret;
		}

		safe_asprintf(&redirect_to_us, "http://%s/", config->gw_address);

		ret = send_redirect_temp(connection, client, redirect_to_us);
		free (redirect_to_us);
		return ret;
	}

	if (check_authdir_match(url, config->authdir)) {
		clientif = safe_calloc(STATUS_BUF);
		get_client_interface(clientif, STATUS_BUF, client->mac);

		if (config->fas_port && !config->preauth) {
			query = safe_calloc(QUERYMAXLEN);

			if (!query) {
				ret = send_error(connection, 503);
				free(query);
				return ret;
			}

			fasurl = safe_calloc(QUERYMAXLEN);

			if (!fasurl) {
				ret = send_error(connection, 503);
				free(fasurl);
				return ret;
			}

			get_query(connection, &query, HTMLQUERYSEPARATOR);

			safe_asprintf(&fasurl, "%s%s%sstatus=authenticated",
				config->fas_url,
				query,
				HTMLQUERYSEPARATOR
			);
			debug(LOG_DEBUG, "fasurl [%s]", fasurl);
			debug(LOG_DEBUG, "query [%s]", query);
			ret = send_redirect_temp(connection, client, fasurl);
			free(clientif);
			free(query);
			free(fasurl);
			return ret;
		} else if (config->fas_port && config->preauth) {
			fasurl = safe_calloc(QUERYMAXLEN);
			safe_asprintf(&fasurl, "?clientip=%s%sgatewayname=%s%sgatewayaddress=%s%sclientif=%s%sstatus=authenticated",
				client->ip,
				QUERYSEPARATOR,
				config->url_encoded_gw_name,
				QUERYSEPARATOR,
				config->gw_address,
				QUERYSEPARATOR,
				clientif,
				QUERYSEPARATOR
			);
			debug(LOG_DEBUG, "fasurl %s", fasurl);
			ret = show_preauthpage(connection, fasurl);
			free(fasurl);
			free(clientif);
			return ret;	
		}
		free(clientif);
	}

	if (check_authdir_match(url, config->preauthdir)) {

		if (config->fas_port) {
			query = safe_calloc(QUERYMAXLEN);
			fasurl = safe_calloc(QUERYMAXLEN);

			if (!query) {
				ret = send_error(connection, 503);
				free(query);
				return ret;
			}

			get_query(connection, &query, QUERYSEPARATOR);

			safe_asprintf(&fasurl, "%s%sstatus=authenticated",
				query,
				QUERYSEPARATOR
			);

			debug(LOG_DEBUG, "preauthdir: fasurl %s", fasurl);
			ret = show_preauthpage(connection, fasurl);
			free(query);
			free(fasurl);
			return ret;
		}
	}

	// User just entered gatewayaddress:gatewayport so give them the info page
	if (strcmp(url, "/") == 0 || strcmp(url, "/login") == 0) {
		query = safe_calloc(QUERYMAXLEN);

		if (!query) {
			ret = send_error(connection, 503);
			free(query);
			return ret;
		}

		get_query(connection, &query, QUERYSEPARATOR);
		debug(LOG_DEBUG, "status_query=[%s]", query);

		buff = safe_calloc(MID_BUF);

		if (!buff) {
			ret = send_error(connection, 503);
			free(buff);
			return ret;
		}

		b64_encode(buff, MID_BUF, query, strlen(query));

		debug(LOG_DEBUG, "b64_status_query=[%s]", buff);

		msg = safe_calloc(HTMLMAXSIZE);

		if (!msg) {
			ret = send_error(connection, 503);
			free(msg);
			return ret;
		}

		rc = execute_ret(msg, HTMLMAXSIZE - 1, "%s status '%s' '%s'", config->status_path, client->ip, buff);

		if (rc != 0) {
			debug(LOG_WARNING, "Script: %s - failed to execute", config->status_path);
			ret = send_error(connection, 503);
			free(msg);
			return ret;
		}

		// serve the script output (in msg)
		response = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);

		if (!response) {
			return send_error(connection, 503);
		}

		MHD_add_response_header(response, "Content-Type", "text/html; charset=utf-8");
		ret = MHD_queue_response(connection, MHD_HTTP_OK, response);
		MHD_destroy_response(response);
		return ret;
	}

	// Client wants a specific file eg /images/splash.jpg etc.:
	return serve_file(connection, client, url);
}
