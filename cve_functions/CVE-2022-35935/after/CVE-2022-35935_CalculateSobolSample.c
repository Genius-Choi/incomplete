void CalculateSobolSample(int32_t dim, int32_t num_results, int32_t skip,
                          int32_t start_point,
                          typename TTypes<T>::Flat output) {
  // Index variables used in this function, consistent with notation in [1].
  // i - point in the Sobol sequence
  // j - dimension
  // k - binary digit
  const int num_digits =
      NumBinaryDigits(skip + start_point + num_results + 1);
  Eigen::MatrixXi direction_numbers(dim, num_digits);

  // Shift things so we can use integers everywhere. Before we write to output,
  // divide by constant to convert back to floats.
  const T normalizing_constant = 1./(1 << num_digits);
  for (int j = 0; j < dim; ++j) {
    for (int k = 0; k < num_digits; ++k) {
      direction_numbers(j, k) = sobol_data::kDirectionNumbers[j][k]
                                << (num_digits - k - 1);
    }
  }

  // If needed, skip ahead to the appropriate point in the sequence. Otherwise
  // we start with the first column of direction numbers.
  Eigen::VectorXi integer_sequence =
      (skip + start_point > 0)
          ? GetFirstPoint(skip + start_point + 1, dim, direction_numbers)
          : direction_numbers.col(0);

  for (int j = 0; j < dim; ++j) {
    output(start_point * dim + j) = integer_sequence(j) * normalizing_constant;
  }
  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences
  for (int i = start_point + 1; i < num_results + start_point; ++i) {
    // The Gray code for the current point differs from the preceding one by
    // just a single bit -- the rightmost bit.
    int k = RightmostZeroBit(i + skip);
    // Update the current point from the preceding one with a single XOR
    // operation per dimension.
    for (int j = 0; j < dim; ++j) {
      integer_sequence(j) ^= direction_numbers(j, k);
      output(i * dim + j) = integer_sequence(j) * normalizing_constant;
    }
  }
}
