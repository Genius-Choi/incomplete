read_viminfo_up_to_marks(
    vir_T	*virp,
    int		forceit,
    int		writing)
{
    int		eof;
    buf_T	*buf;
    int		got_encoding = FALSE;

#ifdef FEAT_CMDHIST
    prepare_viminfo_history(forceit ? 9999 : 0, writing);
#endif

    eof = viminfo_readline(virp);
    while (!eof && virp->vir_line[0] != '>')
    {
	switch (virp->vir_line[0])
	{
		/* Characters reserved for future expansion, ignored now */
	    case '+': /* "+40 /path/dir file", for running vim without args */
	    case '^': /* to be defined */
	    case '<': /* long line - ignored */
		/* A comment or empty line. */
	    case NUL:
	    case '\r':
	    case '\n':
	    case '#':
		eof = viminfo_readline(virp);
		break;
	    case '|':
		eof = read_viminfo_barline(virp, got_encoding,
							    forceit, writing);
		break;
	    case '*': /* "*encoding=value" */
		got_encoding = TRUE;
		eof = viminfo_encoding(virp);
		break;
	    case '!': /* global variable */
#ifdef FEAT_EVAL
		eof = read_viminfo_varlist(virp, writing);
#else
		eof = viminfo_readline(virp);
#endif
		break;
	    case '%': /* entry for buffer list */
		eof = read_viminfo_bufferlist(virp, writing);
		break;
	    case '"':
		/* When registers are in bar lines skip the old style register
		 * lines. */
		if (virp->vir_version < VIMINFO_VERSION_WITH_REGISTERS)
		    eof = read_viminfo_register(virp, forceit);
		else
		    do {
			eof = viminfo_readline(virp);
		    } while (!eof && (virp->vir_line[0] == TAB
						|| virp->vir_line[0] == '<'));
		break;
	    case '/':	    /* Search string */
	    case '&':	    /* Substitute search string */
	    case '~':	    /* Last search string, followed by '/' or '&' */
		eof = read_viminfo_search_pattern(virp, forceit);
		break;
	    case '$':
		eof = read_viminfo_sub_string(virp, forceit);
		break;
	    case ':':
	    case '?':
	    case '=':
	    case '@':
#ifdef FEAT_CMDHIST
		/* When history is in bar lines skip the old style history
		 * lines. */
		if (virp->vir_version < VIMINFO_VERSION_WITH_HISTORY)
		    eof = read_viminfo_history(virp, writing);
		else
#endif
		    eof = viminfo_readline(virp);
		break;
	    case '-':
	    case '\'':
		/* When file marks are in bar lines skip the old style lines. */
		if (virp->vir_version < VIMINFO_VERSION_WITH_MARKS)
		    eof = read_viminfo_filemark(virp, forceit);
		else
		    eof = viminfo_readline(virp);
		break;
	    default:
		if (viminfo_error("E575: ", _("Illegal starting char"),
			    virp->vir_line))
		    eof = TRUE;
		else
		    eof = viminfo_readline(virp);
		break;
	}
    }

#ifdef FEAT_CMDHIST
    /* Finish reading history items. */
    if (!writing)
	finish_viminfo_history(virp);
#endif

    /* Change file names to buffer numbers for fmarks. */
    FOR_ALL_BUFFERS(buf)
	fmarks_check_names(buf);

    return eof;
}
