do_sleep(long msec)
{
    long	done;
    long	wait_now;

    cursor_on();
    out_flush_cursor(FALSE, FALSE);
    for (done = 0; !got_int && done < msec; done += wait_now)
    {
	wait_now = msec - done > 1000L ? 1000L : msec - done;
#ifdef FEAT_TIMERS
	{
	    long    due_time = check_due_timer();

	    if (due_time > 0 && due_time < wait_now)
		wait_now = due_time;
	}
#endif
#ifdef FEAT_JOB_CHANNEL
	if (has_any_channel() && wait_now > 100L)
	    wait_now = 100L;
#endif
	ui_delay(wait_now, TRUE);
#ifdef FEAT_JOB_CHANNEL
	if (has_any_channel())
	    ui_breakcheck_force(TRUE);
	else
#endif
	    ui_breakcheck();
#ifdef MESSAGE_QUEUE
	/* Process the netbeans and clientserver messages that may have been
	 * received in the call to ui_breakcheck() when the GUI is in use. This
	 * may occur when running a test case. */
	parse_queued_messages();
#endif
    }

    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the
    // input buffer, otherwise a following call to input() fails.
    if (got_int)
	(void)vpeekc();
}
