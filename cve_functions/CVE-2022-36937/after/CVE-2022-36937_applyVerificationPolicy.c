bool SSLSocket::applyVerificationPolicy(X509 *peer) {
  /* verification is turned off */
  if (!m_context[s_verify_peer].toBoolean()) {
    return true;
  }

  if (peer == nullptr) {
    raise_warning("Could not get peer certificate");
    return false;
  }

  int err = SSL_get_verify_result(m_data->m_handle);
  switch (err) {
  case X509_V_OK:
    /* fine */
    break;
  case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
    if (m_context[s_allow_self_signed].toBoolean()) {
      /* allowed */
      break;
    }
    /* not allowed, so fall through */
  default:
    raise_warning("Could not verify peer: code:%d %s", err,
                  X509_verify_cert_error_string(err));
    return false;
  }

  /* if the cert passed the usual checks, apply our own local policies now */

  /* Does the common name match ? (used primarily for https://) */
  String cnmatch = m_context[s_CN_match].toString();
  if (!cnmatch.empty()) {
    X509_NAME *name = X509_get_subject_name(peer);
    char buf[1024];
    int name_len = X509_NAME_get_text_by_NID(name, NID_commonName, buf,
                                             sizeof(buf));

    if (name_len < 0) {
      raise_warning("Unable to locate peer certificate CN");
      return false;
    } else if (name_len != (int)strlen(buf)) {
      raise_warning("Peer certificate CN=`%.*s' is malformed", name_len, buf);
      return false;
    } else if (name_len == sizeof(buf)) {
      raise_warning("Peer certificate CN=`%.*s' is too long to verify",
                    name_len, buf);
      return false;
    }

    bool match = (strcmp(cnmatch.c_str(), buf) == 0);
    if (!match && strlen(buf) > 3 && buf[0] == '*' && buf[1] == '.') {
      /* Try wildcard */
      if (strchr(buf+2, '.')) {
        const char* cnmatch_str = cnmatch.c_str();
        const char *tmp = strstr(cnmatch_str, buf+1);
        match = tmp && strcmp(tmp, buf+2) && tmp == strchr(cnmatch_str, '.');
      }
    }

    if (!match) {
      /* didn't match */
      raise_warning("Peer certificate CN=`%.*s' did not match expected CN=`%s'",
                    name_len, buf, cnmatch.c_str());
      return false;
    }
  }

  return true;
}
