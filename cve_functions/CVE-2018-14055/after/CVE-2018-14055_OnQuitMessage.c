bool CIRCSock::OnQuitMessage(CQuitMessage& Message) {
    const CNick& Nick = Message.GetNick();
    bool bIsVisible = false;

    if (Nick.NickEquals(GetNick())) {
        m_pNetwork->PutStatus(t_f("You quit: {1}")(Message.GetReason()));
        // We don't call module hooks and we don't
        // forward this quit to clients (Some clients
        // disconnect if they receive such a QUIT)
        return true;
    }

    vector<CChan*> vFoundChans;
    const vector<CChan*>& vChans = m_pNetwork->GetChans();

    for (CChan* pChan : vChans) {
        if (pChan->RemNick(Nick.GetNick())) {
            vFoundChans.push_back(pChan);

            if (!pChan->IsDetached()) {
                bIsVisible = true;
            }
        }
    }

    IRCSOCKMODULECALL(OnQuitMessage(Message, vFoundChans), NOTHING);

    return !bIsVisible;
}
