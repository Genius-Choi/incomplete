void CIRCSock::ParseISupport(const CMessage& Message) {
    const VCString vsParams = Message.GetParams();

    for (size_t i = 1; i + 1 < vsParams.size(); ++i) {
        const CString& sParam = vsParams[i];
        CString sName = sParam.Token(0, false, "=");
        CString sValue = sParam.Token(1, true, "=");

        if (0 < sName.length() && ':' == sName[0]) {
            break;
        }

        m_mISupport[sName] = sValue;

        if (sName.Equals("PREFIX")) {
            CString sPrefixes = sValue.Token(1, false, ")");
            CString sPermModes = sValue.Token(0, false, ")");
            sPermModes.TrimLeft("(");

            if (!sPrefixes.empty() && sPermModes.size() == sPrefixes.size()) {
                m_sPerms = sPrefixes;
                m_sPermModes = sPermModes;
            }
        } else if (sName.Equals("CHANTYPES")) {
            m_pNetwork->SetChanPrefixes(sValue);
        } else if (sName.Equals("NICKLEN")) {
            unsigned int uMax = sValue.ToUInt();

            if (uMax) {
                m_uMaxNickLen = uMax;
            }
        } else if (sName.Equals("CHANMODES")) {
            if (!sValue.empty()) {
                m_mceChanModes.clear();

                for (unsigned int a = 0; a < 4; a++) {
                    CString sModes = sValue.Token(a, false, ",");

                    for (unsigned int b = 0; b < sModes.size(); b++) {
                        m_mceChanModes[sModes[b]] = (EChanModeArgs)a;
                    }
                }
            }
        } else if (sName.Equals("NAMESX")) {
            if (m_bNamesx) continue;
            m_bNamesx = true;
            PutIRC("PROTOCTL NAMESX");
        } else if (sName.Equals("UHNAMES")) {
            if (m_bUHNames) continue;
            m_bUHNames = true;
            PutIRC("PROTOCTL UHNAMES");
        }
    }
}
