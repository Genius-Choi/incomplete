process_pattern(void)
{
BOOL utf;
uint32_t k;
uint8_t *p = buffer;
unsigned int delimiter = *p++;
int errorcode;
void *use_pat_context;
uint32_t use_forbid_utf = forbid_utf;
PCRE2_SIZE patlen;
PCRE2_SIZE valgrind_access_length;
PCRE2_SIZE erroroffset;

/* The perltest.sh script supports only / as a delimiter. */

if (restrict_for_perl_test && delimiter != '/')
  {
  fprintf(outfile, "** The only allowed delimiter after #perltest is '/'\n");
  return PR_ABEND;
  }

/* Initialize the context and pattern/data controls for this test from the
defaults. */

PATCTXCPY(pat_context, default_pat_context);
memcpy(&pat_patctl, &def_patctl, sizeof(patctl));

/* Find the end of the pattern, reading more lines if necessary. */

for(;;)
  {
  while (*p != 0)
    {
    if (*p == '\\' && p[1] != 0) p++;
      else if (*p == delimiter) break;
    p++;
    }
  if (*p != 0) break;
  if ((p = extend_inputline(infile, p, "    > ")) == NULL)
    {
    fprintf(outfile, "** Unexpected EOF\n");
    return PR_ABEND;
    }
  if (!INTERACTIVE(infile)) fprintf(outfile, "%s", (char *)p);
  }

/* If the first character after the delimiter is backslash, make the pattern
end with backslash. This is purely to provide a way of testing for the error
message when a pattern ends with backslash. */

if (p[1] == '\\') *p++ = '\\';

/* Terminate the pattern at the delimiter, and compute the length. */

*p++ = 0;
patlen = p - buffer - 2;

/* Look for modifiers and options after the final delimiter. */

if (!decode_modifiers(p, CTX_PAT, &pat_patctl, NULL)) return PR_SKIP;

/* Note that the match_invalid_utf option also sets utf when passed to
pcre2_compile(). */

utf = (pat_patctl.options & (PCRE2_UTF|PCRE2_MATCH_INVALID_UTF)) != 0;

/* The utf8_input modifier is not allowed in 8-bit mode, and is mutually
exclusive with the utf modifier. */

if ((pat_patctl.control & CTL_UTF8_INPUT) != 0)
  {
  if (test_mode == PCRE8_MODE)
    {
    fprintf(outfile, "** The utf8_input modifier is not allowed in 8-bit mode\n");
    return PR_SKIP;
    }
  if (utf)
    {
    fprintf(outfile, "** The utf and utf8_input modifiers are mutually exclusive\n");
    return PR_SKIP;
    }
  }

/* The convert and posix modifiers are mutually exclusive. */

if (pat_patctl.convert_type != CONVERT_UNSET &&
    (pat_patctl.control & CTL_POSIX) != 0)
  {
  fprintf(outfile, "** The convert and posix modifiers are mutually exclusive\n");
  return PR_SKIP;
  }

/* Check for mutually exclusive control modifiers. At present, these are all in
the first control word. */

for (k = 0; k < sizeof(exclusive_pat_controls)/sizeof(uint32_t); k++)
  {
  uint32_t c = pat_patctl.control & exclusive_pat_controls[k];
  if (c != 0 && c != (c & (~c+1)))
    {
    show_controls(c, 0, "** Not allowed together:");
    fprintf(outfile, "\n");
    return PR_SKIP;
    }
  }

/* Assume full JIT compile for jitverify and/or jitfast if nothing else was
specified. */

if (pat_patctl.jit == 0 &&
    (pat_patctl.control & (CTL_JITVERIFY|CTL_JITFAST)) != 0)
  pat_patctl.jit = JIT_DEFAULT;

/* Now copy the pattern to pbuffer8 for use in 8-bit testing and for reflecting
in callouts. Convert from hex if requested (literal strings in quotes may be
present within the hexadecimal pairs). The result must necessarily be fewer
characters so will always fit in pbuffer8. */

if ((pat_patctl.control & CTL_HEXPAT) != 0)
  {
  uint8_t *pp, *pt;
  uint32_t c, d;

  pt = pbuffer8;
  for (pp = buffer + 1; *pp != 0; pp++)
    {
    if (isspace(*pp)) continue;
    c = *pp++;

    /* Handle a literal substring */

    if (c == '\'' || c == '"')
      {
      uint8_t *pq = pp;
      for (;; pp++)
        {
        d = *pp;
        if (d == 0)
          {
          fprintf(outfile, "** Missing closing quote in hex pattern: "
            "opening quote is at offset %" PTR_FORM ".\n", pq - buffer - 2);
          return PR_SKIP;
          }
        if (d == c) break;
        *pt++ = d;
        }
      }

    /* Expect a hex pair */

    else
      {
      if (!isxdigit(c))
        {
        fprintf(outfile, "** Unexpected non-hex-digit '%c' at offset %"
          PTR_FORM " in hex pattern: quote missing?\n", c, pp - buffer - 2);
        return PR_SKIP;
        }
      if (*pp == 0)
        {
        fprintf(outfile, "** Odd number of digits in hex pattern\n");
        return PR_SKIP;
        }
      d = *pp;
      if (!isxdigit(d))
        {
        fprintf(outfile, "** Unexpected non-hex-digit '%c' at offset %"
          PTR_FORM " in hex pattern: quote missing?\n", d, pp - buffer - 1);
        return PR_SKIP;
        }
      c = toupper(c);
      d = toupper(d);
      *pt++ = ((isdigit(c)? (c - '0') : (c - 'A' + 10)) << 4) +
               (isdigit(d)? (d - '0') : (d - 'A' + 10));
      }
    }
  *pt = 0;
  patlen = pt - pbuffer8;
  }

/* If not a hex string, process for repetition expansion if requested. */

else if ((pat_patctl.control & CTL_EXPAND) != 0)
  {
  uint8_t *pp, *pt;

  pt = pbuffer8;
  for (pp = buffer + 1; *pp != 0; pp++)
    {
    uint8_t *pc = pp;
    uint32_t count = 1;
    size_t length = 1;

    /* Check for replication syntax; if not found, the defaults just set will
    prevail and one character will be copied. */

    if (pp[0] == '\\' && pp[1] == '[')
      {
      uint8_t *pe;
      for (pe = pp + 2; *pe != 0; pe++)
        {
        if (pe[0] == ']' && pe[1] == '{')
          {
          uint32_t clen = pe - pc - 2;
          uint32_t i = 0;
          unsigned long uli;
          char *endptr;

          pe += 2;
          uli = strtoul((const char *)pe, &endptr, 10);
          if (U32OVERFLOW(uli))
            {
            fprintf(outfile, "** Pattern repeat count too large\n");
            return PR_SKIP;
            }

          i = (uint32_t)uli;
          pe = (uint8_t *)endptr;
          if (*pe == '}')
            {
            if (i == 0)
              {
              fprintf(outfile, "** Zero repeat not allowed\n");
              return PR_SKIP;
              }
            pc += 2;
            count = i;
            length = clen;
            pp = pe;
            break;
            }
          }
        }
      }

    /* Add to output. If the buffer is too small expand it. The function for
    expanding buffers always keeps buffer and pbuffer8 in step as far as their
    size goes. */

    while (pt + count * length > pbuffer8 + pbuffer8_size)
      {
      size_t pc_offset = pc - buffer;
      size_t pp_offset = pp - buffer;
      size_t pt_offset = pt - pbuffer8;
      expand_input_buffers();
      pc = buffer + pc_offset;
      pp = buffer + pp_offset;
      pt = pbuffer8 + pt_offset;
      }

    for (; count > 0; count--)
      {
      memcpy(pt, pc, length);
      pt += length;
      }
    }

  *pt = 0;
  patlen = pt - pbuffer8;

  if ((pat_patctl.control & CTL_INFO) != 0)
    fprintf(outfile, "Expanded: %s\n", pbuffer8);
  }

/* Neither hex nor expanded, just copy the input verbatim. */

else
  {
  strncpy((char *)pbuffer8, (char *)(buffer+1), patlen + 1);
  }

/* Sort out character tables */

if (pat_patctl.locale[0] != 0)
  {
  if (pat_patctl.tables_id != 0)
    {
    fprintf(outfile, "** 'Locale' and 'tables' must not both be set\n");
    return PR_SKIP;
    }
  if (setlocale(LC_CTYPE, (const char *)pat_patctl.locale) == NULL)
    {
    fprintf(outfile, "** Failed to set locale '%s'\n", pat_patctl.locale);
    return PR_SKIP;
    }
  if (strcmp((const char *)pat_patctl.locale, (const char *)locale_name) != 0)
    {
    strcpy((char *)locale_name, (char *)pat_patctl.locale);
    if (locale_tables != NULL)
      { 
      PCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);
      } 
    PCRE2_MAKETABLES(locale_tables, general_context);
    }
  use_tables = locale_tables;
  }

else switch (pat_patctl.tables_id)
  {
  case 0: use_tables = NULL; break;
  case 1: use_tables = tables1; break;
  case 2: use_tables = tables2; break;

  case 3:
  if (tables3 == NULL)
    {
    fprintf(outfile, "** 'Tables = 3' is invalid: binary tables have not "
      "been loaded\n");
    return PR_SKIP;
    }
  use_tables = tables3;
  break;

  default:
  fprintf(outfile, "** 'Tables' must specify 0, 1, 2, or 3.\n");
  return PR_SKIP;
  }

PCRE2_SET_CHARACTER_TABLES(pat_context, use_tables);

/* Set up for the stackguard test. */

if (pat_patctl.stackguard_test != 0)
  {
  PCRE2_SET_COMPILE_RECURSION_GUARD(pat_context, stack_guard, NULL);
  }

/* Handle compiling via the POSIX interface, which doesn't support the
timing, showing, or debugging options, nor the ability to pass over
local character tables. Neither does it have 16-bit or 32-bit support. */

if ((pat_patctl.control & CTL_POSIX) != 0)
  {
#ifdef SUPPORT_PCRE2_8
  int rc;
  int cflags = 0;
  const char *msg = "** Ignored with POSIX interface:";
#endif

  if (test_mode != PCRE8_MODE)
    {
    fprintf(outfile, "** The POSIX interface is available only in 8-bit mode\n");
    return PR_SKIP;
    }

#ifdef SUPPORT_PCRE2_8
  /* Check for features that the POSIX interface does not support. */

  if (pat_patctl.locale[0] != 0) prmsg(&msg, "locale");
  if (pat_patctl.replacement[0] != 0) prmsg(&msg, "replace");
  if (pat_patctl.tables_id != 0) prmsg(&msg, "tables");
  if (pat_patctl.stackguard_test != 0) prmsg(&msg, "stackguard");
  if (timeit > 0) prmsg(&msg, "timing");
  if (pat_patctl.jit != 0) prmsg(&msg, "JIT");

  if ((pat_patctl.options & ~POSIX_SUPPORTED_COMPILE_OPTIONS) != 0)
    {
    show_compile_options(
      pat_patctl.options & (uint32_t)(~POSIX_SUPPORTED_COMPILE_OPTIONS),
        msg, "");
    msg = "";
    }

  if ((FLD(pat_context, extra_options) &
       (uint32_t)(~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS)) != 0)
    {
    show_compile_extra_options(
      FLD(pat_context, extra_options) &
        (uint32_t)(~POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS), msg, "");
    msg = "";
    }

  if ((pat_patctl.control & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS)) != 0 ||
      (pat_patctl.control2 & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS2)) != 0)
    {
    show_controls(
      pat_patctl.control & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS),
      pat_patctl.control2 & (uint32_t)(~POSIX_SUPPORTED_COMPILE_CONTROLS2),
      msg);
    msg = "";
    }

  if (local_newline_default != 0) prmsg(&msg, "#newline_default");
  if (FLD(pat_context, max_pattern_length) != PCRE2_UNSET)
    prmsg(&msg, "max_pattern_length");
  if (FLD(pat_context, parens_nest_limit) != PARENS_NEST_DEFAULT)
    prmsg(&msg, "parens_nest_limit");

  if (msg[0] == 0) fprintf(outfile, "\n");

  /* Translate PCRE2 options to POSIX options and then compile. */

  if (utf) cflags |= REG_UTF;
  if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0) cflags |= REG_NOSUB;
  if ((pat_patctl.options & PCRE2_UCP) != 0) cflags |= REG_UCP;
  if ((pat_patctl.options & PCRE2_CASELESS) != 0) cflags |= REG_ICASE;
  if ((pat_patctl.options & PCRE2_LITERAL) != 0) cflags |= REG_NOSPEC;
  if ((pat_patctl.options & PCRE2_MULTILINE) != 0) cflags |= REG_NEWLINE;
  if ((pat_patctl.options & PCRE2_DOTALL) != 0) cflags |= REG_DOTALL;
  if ((pat_patctl.options & PCRE2_UNGREEDY) != 0) cflags |= REG_UNGREEDY;

  if ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) != 0)
    {
    preg.re_endp = (char *)pbuffer8 + patlen;
    cflags |= REG_PEND;
    }

  rc = regcomp(&preg, (char *)pbuffer8, cflags);

  /* Compiling failed */

  if (rc != 0)
    {
    size_t bsize, usize;
    int psize;

    preg.re_pcre2_code = NULL;     /* In case something was left in there */
    preg.re_match_data = NULL;

    bsize = (pat_patctl.regerror_buffsize != 0)?
      pat_patctl.regerror_buffsize : pbuffer8_size;
    if (bsize + 8 < pbuffer8_size)
      memcpy(pbuffer8 + bsize, "DEADBEEF", 8);
    usize = regerror(rc, &preg, (char *)pbuffer8, bsize);

    /* Inside regerror(), snprintf() is used. If the buffer is too small, some
    versions of snprintf() put a zero byte at the end, but others do not.
    Therefore, we print a maximum of one less than the size of the buffer. */

    psize = (int)bsize - 1;
    fprintf(outfile, "Failed: POSIX code %d: %.*s\n", rc, psize, pbuffer8);
    if (usize > bsize)
      {
      fprintf(outfile, "** regerror() message truncated\n");
      if (memcmp(pbuffer8 + bsize, "DEADBEEF", 8) != 0)
        fprintf(outfile, "** regerror() buffer overflow\n");
      }
    return PR_SKIP;
    }

  /* Compiling succeeded. Check that the values in the preg block are sensible.
  It can happen that pcre2test is accidentally linked with a different POSIX
  library which succeeds, but of course puts different things into preg. In
  this situation, calling regfree() may cause a segfault (or invalid free() in
  valgrind), so ensure that preg.re_pcre2_code is NULL, which suppresses the
  calling of regfree() on exit. */

  if (preg.re_pcre2_code == NULL ||
      ((pcre2_real_code_8 *)preg.re_pcre2_code)->magic_number != MAGIC_NUMBER ||
      ((pcre2_real_code_8 *)preg.re_pcre2_code)->top_bracket != preg.re_nsub ||
      preg.re_match_data == NULL ||
      preg.re_cflags != cflags)
    {
    fprintf(outfile,
      "** The regcomp() function returned zero (success), but the values set\n"
      "** in the preg block are not valid for PCRE2. Check that pcre2test is\n"
      "** linked with PCRE2's pcre2posix module (-lpcre2-posix) and not with\n"
      "** some other POSIX regex library.\n**\n");
    preg.re_pcre2_code = NULL;
    return PR_ABEND;
    }

  return PR_OK;
#endif  /* SUPPORT_PCRE2_8 */
  }

/* Handle compiling via the native interface. Controls that act later are
ignored with "push". Replacements are locked out. */

if ((pat_patctl.control & (CTL_PUSH|CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)
  {
  if (pat_patctl.replacement[0] != 0)
    {
    fprintf(outfile, "** Replacement text is not supported with 'push'.\n");
    return PR_OK;
    }
  if ((pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS) != 0 ||
      (pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2) != 0)
    {
    show_controls(pat_patctl.control & ~PUSH_SUPPORTED_COMPILE_CONTROLS,
                  pat_patctl.control2 & ~PUSH_SUPPORTED_COMPILE_CONTROLS2,
      "** Ignored when compiled pattern is stacked with 'push':");
    fprintf(outfile, "\n");
    }
  if ((pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS) != 0 ||
      (pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2) != 0)
    {
    show_controls(pat_patctl.control & PUSH_COMPILE_ONLY_CONTROLS,
                  pat_patctl.control2 & PUSH_COMPILE_ONLY_CONTROLS2,
      "** Applies only to compile when pattern is stacked with 'push':");
    fprintf(outfile, "\n");
    }
  }

/* Convert the input in non-8-bit modes. */

errorcode = 0;

#ifdef SUPPORT_PCRE2_16
if (test_mode == PCRE16_MODE) errorcode = to16(pbuffer8, utf, &patlen);
#endif

#ifdef SUPPORT_PCRE2_32
if (test_mode == PCRE32_MODE) errorcode = to32(pbuffer8, utf, &patlen);
#endif

switch(errorcode)
  {
  case -1:
  fprintf(outfile, "** Failed: invalid UTF-8 string cannot be "
    "converted to %d-bit string\n", (test_mode == PCRE16_MODE)? 16:32);
  return PR_SKIP;

  case -2:
  fprintf(outfile, "** Failed: character value greater than 0x10ffff "
    "cannot be converted to UTF\n");
  return PR_SKIP;

  case -3:
  fprintf(outfile, "** Failed: character value greater than 0xffff "
    "cannot be converted to 16-bit in non-UTF mode\n");
  return PR_SKIP;

  default:
  break;
  }

/* The pattern is now in pbuffer[8|16|32], with the length in code units in
patlen. If it is to be converted, copy the result back afterwards so that it
ends up back in the usual place. */

if (pat_patctl.convert_type != CONVERT_UNSET)
  {
  int rc;
  int convert_return = PR_OK;
  uint32_t convert_options = pat_patctl.convert_type;
  void *converted_pattern;
  PCRE2_SIZE converted_length;

  if (pat_patctl.convert_length != 0)
    {
    converted_length = pat_patctl.convert_length;
    converted_pattern = malloc(converted_length * code_unit_size);
    if (converted_pattern == NULL)
      {
      fprintf(outfile, "** Failed: malloc failed for converted pattern\n");
      return PR_SKIP;
      }
    }
  else converted_pattern = NULL;  /* Let the library allocate */

  if (utf) convert_options |= PCRE2_CONVERT_UTF;
  if ((pat_patctl.options & PCRE2_NO_UTF_CHECK) != 0)
    convert_options |= PCRE2_CONVERT_NO_UTF_CHECK;

  CONCTXCPY(con_context, default_con_context);

  if (pat_patctl.convert_glob_escape != 0)
    {
    uint32_t escape = (pat_patctl.convert_glob_escape == '0')? 0 :
      pat_patctl.convert_glob_escape;
    PCRE2_SET_GLOB_ESCAPE(rc, con_context, escape);
    if (rc != 0)
      {
      fprintf(outfile, "** Invalid glob escape '%c'\n",
        pat_patctl.convert_glob_escape);
      convert_return = PR_SKIP;
      goto CONVERT_FINISH;
      }
    }

  if (pat_patctl.convert_glob_separator != 0)
    {
    PCRE2_SET_GLOB_SEPARATOR(rc, con_context, pat_patctl.convert_glob_separator);
    if (rc != 0)
      {
      fprintf(outfile, "** Invalid glob separator '%c'\n",
        pat_patctl.convert_glob_separator);
      convert_return = PR_SKIP;
      goto CONVERT_FINISH;
      }
    }

  PCRE2_PATTERN_CONVERT(rc, pbuffer, patlen, convert_options,
    &converted_pattern, &converted_length, con_context);

  if (rc != 0)
    {
    fprintf(outfile, "** Pattern conversion error at offset %" SIZ_FORM ": ",
      converted_length);
    convert_return = print_error_message(rc, "", "\n")? PR_SKIP:PR_ABEND;
    }

  /* Output the converted pattern, then copy it. */

  else
    {
    PCHARSV(converted_pattern, 0, converted_length, utf, outfile);
    fprintf(outfile, "\n");
    patlen = converted_length;
    CONVERT_COPY(pbuffer, converted_pattern, converted_length + 1);
    }

  /* Free the converted pattern. */

  CONVERT_FINISH:
  if (pat_patctl.convert_length != 0)
    free(converted_pattern);
  else
    PCRE2_CONVERTED_PATTERN_FREE(converted_pattern);

  /* Return if conversion was unsuccessful. */

  if (convert_return != PR_OK) return convert_return;
  }

/* By default we pass a zero-terminated pattern, but a length is passed if
"use_length" was specified or this is a hex pattern (which might contain binary
zeros). When valgrind is supported, arrange for the unused part of the buffer
to be marked as no access. */

valgrind_access_length = patlen;
if ((pat_patctl.control & (CTL_HEXPAT|CTL_USE_LENGTH)) == 0)
  {
  patlen = PCRE2_ZERO_TERMINATED;
  valgrind_access_length += 1;  /* For the terminating zero */
  }

#ifdef SUPPORT_VALGRIND
#ifdef SUPPORT_PCRE2_8
if (test_mode == PCRE8_MODE && pbuffer8 != NULL)
  {
  VALGRIND_MAKE_MEM_NOACCESS(pbuffer8 + valgrind_access_length,
    pbuffer8_size - valgrind_access_length);
  }
#endif
#ifdef SUPPORT_PCRE2_16
if (test_mode == PCRE16_MODE && pbuffer16 != NULL)
  {
  VALGRIND_MAKE_MEM_NOACCESS(pbuffer16 + valgrind_access_length,
    pbuffer16_size - valgrind_access_length*sizeof(uint16_t));
  }
#endif
#ifdef SUPPORT_PCRE2_32
if (test_mode == PCRE32_MODE && pbuffer32 != NULL)
  {
  VALGRIND_MAKE_MEM_NOACCESS(pbuffer32 + valgrind_access_length,
    pbuffer32_size - valgrind_access_length*sizeof(uint32_t));
  }
#endif
#else  /* Valgrind not supported */
(void)valgrind_access_length;  /* Avoid compiler warning */
#endif

/* If #newline_default has been used and the library was not compiled with an
appropriate default newline setting, local_newline_default will be non-zero. We
use this if there is no explicit newline modifier. */

if ((pat_patctl.control2 & CTL2_NL_SET) == 0 && local_newline_default != 0)
  {
  SETFLD(pat_context, newline_convention, local_newline_default);
  }

/* The null_context modifier is used to test calling pcre2_compile() with a
NULL context. */

use_pat_context = ((pat_patctl.control & CTL_NULLCONTEXT) != 0)?
  NULL : PTR(pat_context);

/* If PCRE2_LITERAL is set, set use_forbid_utf zero because PCRE2_NEVER_UTF
and PCRE2_NEVER_UCP are invalid with it. */

if ((pat_patctl.options & PCRE2_LITERAL) != 0) use_forbid_utf = 0;

/* Compile many times when timing. */

if (timeit > 0)
  {
  int i;
  clock_t time_taken = 0;
  for (i = 0; i < timeit; i++)
    {
    clock_t start_time = clock();
    PCRE2_COMPILE(compiled_code, pbuffer, patlen,
      pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,
        use_pat_context);
    time_taken += clock() - start_time;
    if (TEST(compiled_code, !=, NULL))
      { SUB1(pcre2_code_free, compiled_code); }
    }
  total_compile_time += time_taken;
  fprintf(outfile, "Compile time %.4f milliseconds\n",
    (((double)time_taken * 1000.0) / (double)timeit) /
      (double)CLOCKS_PER_SEC);
  }

/* A final compile that is used "for real". */

PCRE2_COMPILE(compiled_code, pbuffer, patlen, pat_patctl.options|use_forbid_utf,
  &errorcode, &erroroffset, use_pat_context);

/* Call the JIT compiler if requested. When timing, we must free and recompile
the pattern each time because that is the only way to free the JIT compiled
code. We know that compilation will always succeed. */

if (TEST(compiled_code, !=, NULL) && pat_patctl.jit != 0)
  {
  if (timeit > 0)
    {
    int i;
    clock_t time_taken = 0;

    for (i = 0; i < timeit; i++)
      {
      clock_t start_time;
      SUB1(pcre2_code_free, compiled_code);
      PCRE2_COMPILE(compiled_code, pbuffer, patlen,
        pat_patctl.options|use_forbid_utf, &errorcode, &erroroffset,
        use_pat_context);
      start_time = clock();
      PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);
      time_taken += clock() - start_time;
      }
    total_jit_compile_time += time_taken;
    fprintf(outfile, "JIT compile  %.4f milliseconds\n",
      (((double)time_taken * 1000.0) / (double)timeit) /
        (double)CLOCKS_PER_SEC);
    }
  else
    {
    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);
    }
  }

/* If valgrind is supported, mark the pbuffer as accessible again. The 16-bit
and 32-bit buffers can be marked completely undefined, but we must leave the
pattern in the 8-bit buffer defined because it may be read from a callout
during matching. */

#ifdef SUPPORT_VALGRIND
#ifdef SUPPORT_PCRE2_8
if (test_mode == PCRE8_MODE)
  {
  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer8 + valgrind_access_length,
    pbuffer8_size - valgrind_access_length);
  }
#endif
#ifdef SUPPORT_PCRE2_16
if (test_mode == PCRE16_MODE)
  {
  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer16, pbuffer16_size);
  }
#endif
#ifdef SUPPORT_PCRE2_32
if (test_mode == PCRE32_MODE)
  {
  VALGRIND_MAKE_MEM_UNDEFINED(pbuffer32, pbuffer32_size);
  }
#endif
#endif

/* Compilation failed; go back for another re, skipping to blank line
if non-interactive. */

if (TEST(compiled_code, ==, NULL))
  {
  fprintf(outfile, "Failed: error %d at offset %d: ", errorcode,
    (int)erroroffset);
  if (!print_error_message(errorcode, "", "\n")) return PR_ABEND;
  return PR_SKIP;
  }

/* If forbid_utf is non-zero, we are running a non-UTF test. UTF and UCP are
locked out at compile time, but we must also check for occurrences of \P, \p,
and \X, which are only supported when Unicode is supported. */

if (forbid_utf != 0)
  {
  if ((FLD(compiled_code, flags) & PCRE2_HASBKPORX) != 0)
    {
    fprintf(outfile, "** \\P, \\p, and \\X are not allowed after the "
      "#forbid_utf command\n");
    return PR_SKIP;
    }
  }

/* Remember the maximum lookbehind, for partial matching. */

if (pattern_info(PCRE2_INFO_MAXLOOKBEHIND, &maxlookbehind, FALSE) != 0)
  return PR_ABEND;

/* Remember the number of captures. */

if (pattern_info(PCRE2_INFO_CAPTURECOUNT, &maxcapcount, FALSE) < 0)
  return PR_ABEND;

/* If an explicit newline modifier was given, set the information flag in the
pattern so that it is preserved over push/pop. */

if ((pat_patctl.control2 & CTL2_NL_SET) != 0)
  {
  SETFLD(compiled_code, flags, FLD(compiled_code, flags) | PCRE2_NL_SET);
  }

/* Output code size and other information if requested. */

if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();
if ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();
if ((pat_patctl.control & CTL_ANYINFO) != 0)
  {
  int rc = show_pattern_info();
  if (rc != PR_OK) return rc;
  }

/* The "push" control requests that the compiled pattern be remembered on a
stack. This is mainly for testing the serialization functionality. */

if ((pat_patctl.control & CTL_PUSH) != 0)
  {
  if (patstacknext >= PATSTACKSIZE)
    {
    fprintf(outfile, "** Too many pushed patterns (max %d)\n", PATSTACKSIZE);
    return PR_ABEND;
    }
  patstack[patstacknext++] = PTR(compiled_code);
  SET(compiled_code, NULL);
  }

/* The "pushcopy" and "pushtablescopy" controls are similar, but push a
copy of the pattern, the latter with a copy of its character tables. This tests
the pcre2_code_copy() and pcre2_code_copy_with_tables() functions. */

if ((pat_patctl.control & (CTL_PUSHCOPY|CTL_PUSHTABLESCOPY)) != 0)
  {
  if (patstacknext >= PATSTACKSIZE)
    {
    fprintf(outfile, "** Too many pushed patterns (max %d)\n", PATSTACKSIZE);
    return PR_ABEND;
    }
  if ((pat_patctl.control & CTL_PUSHCOPY) != 0)
    {
    PCRE2_CODE_COPY_TO_VOID(patstack[patstacknext++], compiled_code);
    }
  else
    {
    PCRE2_CODE_COPY_WITH_TABLES_TO_VOID(patstack[patstacknext++],
      compiled_code); }
  }

return PR_OK;
}
