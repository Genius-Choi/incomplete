main(int argc, char **argv)
{
uint32_t temp;
uint32_t yield = 0;
uint32_t op = 1;
BOOL notdone = TRUE;
BOOL quiet = FALSE;
BOOL showtotaltimes = FALSE;
BOOL skipping = FALSE;
char *arg_subject = NULL;
char *arg_pattern = NULL;
char *arg_error = NULL;

/* The offsets to the options and control bits fields of the pattern and data
control blocks must be the same so that common options and controls such as
"anchored" or "memory" can work for either of them from a single table entry.
We cannot test this till runtime because "offsetof" does not work in the
preprocessor. */

if (PO(options) != DO(options) || PO(control) != DO(control) ||
    PO(control2) != DO(control2))
  {
  fprintf(stderr, "** Coding error: "
    "options and control offsets for pattern and data must be the same.\n");
  return 1;
  }

/* Get the PCRE2 and Unicode version number and JIT target information, at the
same time checking that a request for the length gives the same answer. Also
check lengths for non-string items. */

if (PCRE2_CONFIG(PCRE2_CONFIG_VERSION, NULL) !=
    PCRE2_CONFIG(PCRE2_CONFIG_VERSION, version) ||

    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, NULL) !=
    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE_VERSION, uversion) ||

    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, NULL) !=
    PCRE2_CONFIG(PCRE2_CONFIG_JITTARGET, jittarget) ||

    PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, NULL) != sizeof(uint32_t) ||
    PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, NULL) != sizeof(uint32_t))
  {
  fprintf(stderr, "** Error in pcre2_config(): bad length\n");
  return 1;
  }

/* Check that bad options are diagnosed. */

if (PCRE2_CONFIG(999, NULL) != PCRE2_ERROR_BADOPTION ||
    PCRE2_CONFIG(999, &temp) != PCRE2_ERROR_BADOPTION)
  {
  fprintf(stderr, "** Error in pcre2_config(): bad option not diagnosed\n");
  return 1;
  }

/* This configuration option is now obsolete, but running a quick check ensures
that its code is covered. */

(void)PCRE2_CONFIG(PCRE2_CONFIG_STACKRECURSE, &temp);

/* Get buffers from malloc() so that valgrind will check their misuse when
debugging. They grow automatically when very long lines are read. The 16-
and 32-bit buffers (pbuffer16, pbuffer32) are obtained only if needed. */

buffer = (uint8_t *)malloc(pbuffer8_size);
pbuffer8 = (uint8_t *)malloc(pbuffer8_size);

/* The following  _setmode() stuff is some Windows magic that tells its runtime
library to translate CRLF into a single LF character. At least, that's what
I've been told: never having used Windows I take this all on trust. Originally
it set 0x8000, but then I was advised that _O_BINARY was better. */

#if defined(_WIN32) || defined(WIN32)
_setmode( _fileno( stdout ), _O_BINARY );
#endif

/* Initialization that does not depend on the running mode. */

locale_name[0] = 0;

memset(&def_patctl, 0, sizeof(patctl));
def_patctl.convert_type = CONVERT_UNSET;

memset(&def_datctl, 0, sizeof(datctl));
def_datctl.oveccount = DEFAULT_OVECCOUNT;
def_datctl.copy_numbers[0] = -1;
def_datctl.get_numbers[0] = -1;
def_datctl.startend[0] = def_datctl.startend[1] = CFORE_UNSET;
def_datctl.cerror[0] = def_datctl.cerror[1] = CFORE_UNSET;
def_datctl.cfail[0] = def_datctl.cfail[1] = CFORE_UNSET;

/* Scan command line options. */

while (argc > 1 && argv[op][0] == '-' && argv[op][1] != 0)
  {
  char *endptr;
  char *arg = argv[op];
  unsigned long uli;

  /* List modifiers and exit. */

  if (strcmp(arg, "-LM") == 0)
    {
    display_modifiers();
    goto EXIT;
    }

  /* List properties and exit */

  if (strcmp(arg, "-LP") == 0)
    {
    display_properties(FALSE);
    goto EXIT;
    }

  /* List scripts and exit */

  if (strcmp(arg, "-LS") == 0)
    {
    display_properties(TRUE);
    goto EXIT;
    }

  /* Display and/or set return code for configuration options. */

  if (strcmp(arg, "-C") == 0)
    {
    yield = c_option(argv[op + 1]);
    goto EXIT;
    }

  /* Select operating mode. Ensure that pcre2_config() is called in 16-bit
  and 32-bit modes because that won't happen naturally when 8-bit is also
  configured. Also call some other functions that are not otherwise used. This
  means that a coverage report won't claim there are uncalled functions. */

  if (strcmp(arg, "-8") == 0)
    {
#ifdef SUPPORT_PCRE2_8
    test_mode = PCRE8_MODE;
    (void)pcre2_set_bsr_8(pat_context8, 999);
    (void)pcre2_set_newline_8(pat_context8, 999);
#else
    fprintf(stderr,
      "** This version of PCRE2 was built without 8-bit support\n");
    exit(1);
#endif
    }

  else if (strcmp(arg, "-16") == 0)
    {
#ifdef SUPPORT_PCRE2_16
    test_mode = PCRE16_MODE;
    (void)pcre2_config_16(PCRE2_CONFIG_VERSION, NULL);
    (void)pcre2_set_bsr_16(pat_context16, 999);
    (void)pcre2_set_newline_16(pat_context16, 999);
#else
    fprintf(stderr,
      "** This version of PCRE2 was built without 16-bit support\n");
    exit(1);
#endif
    }

  else if (strcmp(arg, "-32") == 0)
    {
#ifdef SUPPORT_PCRE2_32
    test_mode = PCRE32_MODE;
    (void)pcre2_config_32(PCRE2_CONFIG_VERSION, NULL);
    (void)pcre2_set_bsr_32(pat_context32, 999);
    (void)pcre2_set_newline_32(pat_context32, 999);
#else
    fprintf(stderr,
      "** This version of PCRE2 was built without 32-bit support\n");
    exit(1);
#endif
    }

  /* Set quiet (no version verification) */

  else if (strcmp(arg, "-q") == 0) quiet = TRUE;

  /* Set system stack size */

  else if (strcmp(arg, "-S") == 0 && argc > 2 &&
      ((uli = strtoul(argv[op+1], &endptr, 10)), *endptr == 0))
    {
#if defined(_WIN32) || defined(WIN32) || defined(__HAIKU__) || defined(NATIVE_ZOS) || defined(__VMS)
    fprintf(stderr, "pcre2test: -S is not supported on this OS\n");
    exit(1);
#else
    int rc;
    uint32_t stack_size;
    struct rlimit rlim;
    if (U32OVERFLOW(uli))
      {
      fprintf(stderr, "** Argument for -S is too big\n");
      exit(1);
      }
    stack_size = (uint32_t)uli;
    getrlimit(RLIMIT_STACK, &rlim);
    rlim.rlim_cur = stack_size * 1024 * 1024;
    if (rlim.rlim_cur > rlim.rlim_max)
      {
      fprintf(stderr,
        "pcre2test: requested stack size %luMiB is greater than hard limit "
          "%luMiB\n", (unsigned long int)stack_size,
          (unsigned long int)(rlim.rlim_max));
      exit(1);
      }
    rc = setrlimit(RLIMIT_STACK, &rlim);
    if (rc != 0)
      {
      fprintf(stderr, "pcre2test: setting stack size %luMiB failed: %s\n",
        (unsigned long int)stack_size, strerror(errno));
      exit(1);
      }
    op++;
    argc--;
#endif
    }

  /* Set some common pattern and subject controls */

  else if (strcmp(arg, "-AC") == 0)
    {
    def_patctl.options |= PCRE2_AUTO_CALLOUT;
    def_datctl.control2 |= CTL2_CALLOUT_EXTRA;
    }
  else if (strcmp(arg, "-ac") == 0)  def_patctl.options |= PCRE2_AUTO_CALLOUT;
  else if (strcmp(arg, "-b") == 0)   def_patctl.control |= CTL_FULLBINCODE;
  else if (strcmp(arg, "-d") == 0)   def_patctl.control |= CTL_DEBUG;
  else if (strcmp(arg, "-dfa") == 0) def_datctl.control |= CTL_DFA;
  else if (strcmp(arg, "-i") == 0)   def_patctl.control |= CTL_INFO;
  else if (strcmp(arg, "-jit") == 0 || strcmp(arg, "-jitverify") == 0 ||
           strcmp(arg, "-jitfast") == 0)
    {
    if (arg[4] == 'v') def_patctl.control |= CTL_JITVERIFY;
      else if (arg[4] == 'f') def_patctl.control |= CTL_JITFAST;
    def_patctl.jit = JIT_DEFAULT;  /* full & partial */
#ifndef SUPPORT_JIT
    fprintf(stderr, "** Warning: JIT support is not available: "
                    "-jit[fast|verify] calls functions that do nothing.\n");
#endif
    }

  /* Set timing parameters */

  else if (strcmp(arg, "-t") == 0 || strcmp(arg, "-tm") == 0 ||
           strcmp(arg, "-T") == 0 || strcmp(arg, "-TM") == 0)
    {
    int both = arg[2] == 0;
    showtotaltimes = arg[1] == 'T';
    if (argc > 2 && (uli = strtoul(argv[op+1], &endptr, 10), *endptr == 0))
      {
      if (uli == 0)
        {
        fprintf(stderr, "** Argument for %s must not be zero\n", arg);
        exit(1);
        }
      if (U32OVERFLOW(uli))
        {
        fprintf(stderr, "** Argument for %s is too big\n", arg);
        exit(1);
        }
      timeitm = (int)uli;
      op++;
      argc--;
      }
    else timeitm = LOOPREPEAT;
    if (both) timeit = timeitm;
    }

  /* Give help */

  else if (strcmp(arg, "-help") == 0 ||
           strcmp(arg, "--help") == 0)
    {
    usage();
    goto EXIT;
    }

  /* Show version */

  else if (strcmp(arg, "-version") == 0 ||
           strcmp(arg, "--version") == 0)
    {
    print_version(stdout);
    goto EXIT;
    }

  /* The following options save their data for processing once we know what
  the running mode is. */

  else if (strcmp(arg, "-error") == 0)
    {
    arg_error = argv[op+1];
    goto CHECK_VALUE_EXISTS;
    }

  else if (strcmp(arg, "-subject") == 0)
    {
    arg_subject = argv[op+1];
    goto CHECK_VALUE_EXISTS;
    }

  else if (strcmp(arg, "-pattern") == 0)
    {
    arg_pattern = argv[op+1];
    CHECK_VALUE_EXISTS:
    if (argc <= 2)
      {
      fprintf(stderr, "** Missing value for %s\n", arg);
      yield = 1;
      goto EXIT;
      }
    op++;
    argc--;
    }

  /* Unrecognized option */

  else
    {
    fprintf(stderr, "** Unknown or malformed option '%s'\n", arg);
    usage();
    yield = 1;
    goto EXIT;
    }
  op++;
  argc--;
  }

/* If -error was present, get the error numbers, show the messages, and exit.
We wait to do this until we know which mode we are in. */

if (arg_error != NULL)
  {
  int len;
  int errcode;
  char *endptr;

/* Ensure the relevant non-8-bit buffer is available. Ensure that it is at
least 128 code units, because it is used for retrieving error messages. */

#ifdef SUPPORT_PCRE2_16
  if (test_mode == PCRE16_MODE)
    {
    pbuffer16_size = 256;
    pbuffer16 = (uint16_t *)malloc(pbuffer16_size);
    if (pbuffer16 == NULL)
      {
      fprintf(stderr, "pcre2test: malloc(%" SIZ_FORM ") failed for pbuffer16\n",
        pbuffer16_size);
      yield = 1;
      goto EXIT;
      }
    }
#endif

#ifdef SUPPORT_PCRE2_32
  if (test_mode == PCRE32_MODE)
    {
    pbuffer32_size = 512;
    pbuffer32 = (uint32_t *)malloc(pbuffer32_size);
    if (pbuffer32 == NULL)
      {
      fprintf(stderr, "pcre2test: malloc(%" SIZ_FORM ") failed for pbuffer32\n",
        pbuffer32_size);
      yield = 1;
      goto EXIT;
      }
    }
#endif

  /* Loop along a list of error numbers. */

  for (;;)
    {
    errcode = strtol(arg_error, &endptr, 10);
    if (*endptr != 0 && *endptr != CHAR_COMMA)
      {
      fprintf(stderr, "** '%s' is not a valid error number list\n", arg_error);
      yield = 1;
      goto EXIT;
      }
    printf("Error %d: ", errcode);
    PCRE2_GET_ERROR_MESSAGE(len, errcode, pbuffer);
    if (len < 0)
      {
      switch (len)
        {
        case PCRE2_ERROR_BADDATA:
        printf("PCRE2_ERROR_BADDATA (unknown error number)");
        break;

        case PCRE2_ERROR_NOMEMORY:
        printf("PCRE2_ERROR_NOMEMORY (buffer too small)");
        break;

        default:
        printf("Unexpected return (%d) from pcre2_get_error_message()", len);
        break;
        }
      }
    else
      {
      PCHARSV(CASTVAR(void *, pbuffer), 0, len, FALSE, stdout);
      }
    printf("\n");
    if (*endptr == 0) goto EXIT;
    arg_error = endptr + 1;
    }
  /* Control never reaches here */
  }  /* End of -error handling */

/* Initialize things that cannot be done until we know which test mode we are
running in. Exercise the general context copying and match data size functions,
which are not otherwise used. */

code_unit_size = test_mode/8;
max_oveccount = DEFAULT_OVECCOUNT;

/* Use macros to save a lot of duplication. */

#define CREATECONTEXTS \
  G(general_context,BITS) = G(pcre2_general_context_create_,BITS)(&my_malloc, &my_free, NULL); \
  G(general_context_copy,BITS) = G(pcre2_general_context_copy_,BITS)(G(general_context,BITS)); \
  G(default_pat_context,BITS) = G(pcre2_compile_context_create_,BITS)(G(general_context,BITS)); \
  G(pat_context,BITS) = G(pcre2_compile_context_copy_,BITS)(G(default_pat_context,BITS)); \
  G(default_dat_context,BITS) = G(pcre2_match_context_create_,BITS)(G(general_context,BITS)); \
  G(dat_context,BITS) = G(pcre2_match_context_copy_,BITS)(G(default_dat_context,BITS)); \
  G(default_con_context,BITS) = G(pcre2_convert_context_create_,BITS)(G(general_context,BITS)); \
  G(con_context,BITS) = G(pcre2_convert_context_copy_,BITS)(G(default_con_context,BITS)); \
  G(match_data,BITS) = G(pcre2_match_data_create_,BITS)(max_oveccount, G(general_context,BITS))

#define CONTEXTTESTS \
  (void)G(pcre2_set_compile_extra_options_,BITS)(G(pat_context,BITS), 0); \
  (void)G(pcre2_set_max_pattern_length_,BITS)(G(pat_context,BITS), 0); \
  (void)G(pcre2_set_offset_limit_,BITS)(G(dat_context,BITS), 0); \
  (void)G(pcre2_get_match_data_size_,BITS)(G(match_data,BITS))


/* Call the appropriate functions for the current mode, and exercise some
functions that are not otherwise called. */

#ifdef SUPPORT_PCRE2_8
#undef BITS
#define BITS 8
if (test_mode == PCRE8_MODE)
  {
  CREATECONTEXTS;
  CONTEXTTESTS;
  }
#endif

#ifdef SUPPORT_PCRE2_16
#undef BITS
#define BITS 16
if (test_mode == PCRE16_MODE)
  {
  CREATECONTEXTS;
  CONTEXTTESTS;
  }
#endif

#ifdef SUPPORT_PCRE2_32
#undef BITS
#define BITS 32
if (test_mode == PCRE32_MODE)
  {
  CREATECONTEXTS;
  CONTEXTTESTS;
  }
#endif

/* Set a default parentheses nest limit that is large enough to run the
standard tests (this also exercises the function). */

PCRE2_SET_PARENS_NEST_LIMIT(default_pat_context, PARENS_NEST_DEFAULT);

/* Handle command line modifier settings, sending any error messages to
stderr. We need to know the mode before modifying the context, and it is tidier
to do them all in the same way. */

outfile = stderr;
if ((arg_pattern != NULL &&
    !decode_modifiers((uint8_t *)arg_pattern, CTX_DEFPAT, &def_patctl, NULL)) ||
    (arg_subject != NULL &&
    !decode_modifiers((uint8_t *)arg_subject, CTX_DEFDAT, NULL, &def_datctl)))
  {
  yield = 1;
  goto EXIT;
  }

/* Sort out the input and output files, defaulting to stdin/stdout. */

infile = stdin;
outfile = stdout;

if (argc > 1 && strcmp(argv[op], "-") != 0)
  {
  infile = fopen(argv[op], INPUT_MODE);
  if (infile == NULL)
    {
    printf("** Failed to open '%s': %s\n", argv[op], strerror(errno));
    yield = 1;
    goto EXIT;
    }
  }

#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)
if (INTERACTIVE(infile)) using_history();
#endif

if (argc > 2)
  {
  outfile = fopen(argv[op+1], OUTPUT_MODE);
  if (outfile == NULL)
    {
    printf("** Failed to open '%s': %s\n", argv[op+1], strerror(errno));
    yield = 1;
    goto EXIT;
    }
  }

/* Output a heading line unless quiet, then process input lines. */

if (!quiet) print_version(outfile);

SET(compiled_code, NULL);

#ifdef SUPPORT_PCRE2_8
preg.re_pcre2_code = NULL;
preg.re_match_data = NULL;
#endif

while (notdone)
  {
  uint8_t *p;
  int rc = PR_OK;
  BOOL expectdata = TEST(compiled_code, !=, NULL);
#ifdef SUPPORT_PCRE2_8
  expectdata |= preg.re_pcre2_code != NULL;
#endif

  if (extend_inputline(infile, buffer, expectdata? "data> " : "  re> ") == NULL)
    break;
  if (!INTERACTIVE(infile)) fprintf(outfile, "%s", (char *)buffer);
  fflush(outfile);
  p = buffer;

  /* If we have a pattern set up for testing, or we are skipping after a
  compile failure, a blank line terminates this test. */

  if (expectdata || skipping)
    {
    while (isspace(*p)) p++;
    if (*p == 0)
      {
#ifdef SUPPORT_PCRE2_8
      if (preg.re_pcre2_code != NULL)
        {
        regfree(&preg);
        preg.re_pcre2_code = NULL;
        preg.re_match_data = NULL;
        }
#endif  /* SUPPORT_PCRE2_8 */
      if (TEST(compiled_code, !=, NULL))
        {
        SUB1(pcre2_code_free, compiled_code);
        SET(compiled_code, NULL);
        }
      skipping = FALSE;
      setlocale(LC_CTYPE, "C");
      }

    /* Otherwise, if we are not skipping, and the line is not a data comment
    line starting with "\=", process a data line. */

    else if (!skipping && !(p[0] == '\\' && p[1] == '=' && isspace(p[2])))
      {
      rc = process_data();
      }
    }

  /* We do not have a pattern set up for testing. Lines starting with # are
  either comments or special commands. Blank lines are ignored. Otherwise, the
  line must start with a valid delimiter. It is then processed as a pattern
  line. A copy of the pattern is left in pbuffer8 for use by callouts. Under
  valgrind, make the unused part of the buffer undefined, to catch overruns. */

  else if (*p == '#')
    {
    if (isspace(p[1]) || p[1] == '!' || p[1] == 0) continue;
    rc = process_command();
    }

  else if (strchr("/!\"'`%&-=_:;,@~", *p) != NULL)
    {
    rc = process_pattern();
    dfa_matched = 0;
    }

  else
    {
    while (isspace(*p)) p++;
    if (*p != 0)
      {
      fprintf(outfile, "** Invalid pattern delimiter '%c' (x%x).\n", *buffer,
        *buffer);
      rc = PR_SKIP;
      }
    }

  if (rc == PR_SKIP && !INTERACTIVE(infile)) skipping = TRUE;
  else if (rc == PR_ABEND)
    {
    fprintf(outfile, "** pcre2test run abandoned\n");
    yield = 1;
    goto EXIT;
    }
  }

/* Finish off a normal run. */

if (INTERACTIVE(infile)) fprintf(outfile, "\n");

if (showtotaltimes)
  {
  const char *pad = "";
  fprintf(outfile, "--------------------------------------\n");
  if (timeit > 0)
    {
    fprintf(outfile, "Total compile time %.4f milliseconds\n",
      (((double)total_compile_time * 1000.0) / (double)timeit) /
        (double)CLOCKS_PER_SEC);
    if (total_jit_compile_time > 0)
      fprintf(outfile, "Total JIT compile  %.4f milliseconds\n",
        (((double)total_jit_compile_time * 1000.0) / (double)timeit) /
          (double)CLOCKS_PER_SEC);
    pad = "  ";
    }
  fprintf(outfile, "Total match time %s%.4f milliseconds\n", pad,
    (((double)total_match_time * 1000.0) / (double)timeitm) /
      (double)CLOCKS_PER_SEC);
  }


EXIT:

#if defined(SUPPORT_LIBREADLINE) || defined(SUPPORT_LIBEDIT)
if (infile != NULL && INTERACTIVE(infile)) clear_history();
#endif

if (infile != NULL && infile != stdin) fclose(infile);
if (outfile != NULL && outfile != stdout) fclose(outfile);

free(buffer);
free(dbuffer);
free(pbuffer8);
free(dfa_workspace);
free(tables3);
PCRE2_MAKETABLES_FREE(general_context, (void *)locale_tables);
PCRE2_MATCH_DATA_FREE(match_data);
SUB1(pcre2_code_free, compiled_code);

while(patstacknext-- > 0)
  {
  SET(compiled_code, patstack[patstacknext]);
  SUB1(pcre2_code_free, compiled_code);
  }

PCRE2_JIT_FREE_UNUSED_MEMORY(general_context);
if (jit_stack != NULL)
  {
  PCRE2_JIT_STACK_FREE(jit_stack);
  }

#define FREECONTEXTS \
  G(pcre2_general_context_free_,BITS)(G(general_context,BITS)); \
  G(pcre2_general_context_free_,BITS)(G(general_context_copy,BITS)); \
  G(pcre2_compile_context_free_,BITS)(G(pat_context,BITS)); \
  G(pcre2_compile_context_free_,BITS)(G(default_pat_context,BITS)); \
  G(pcre2_match_context_free_,BITS)(G(dat_context,BITS)); \
  G(pcre2_match_context_free_,BITS)(G(default_dat_context,BITS)); \
  G(pcre2_convert_context_free_,BITS)(G(default_con_context,BITS)); \
  G(pcre2_convert_context_free_,BITS)(G(con_context,BITS));

#ifdef SUPPORT_PCRE2_8
#undef BITS
#define BITS 8
if (preg.re_pcre2_code != NULL) regfree(&preg);
FREECONTEXTS;
#endif

#ifdef SUPPORT_PCRE2_16
#undef BITS
#define BITS 16
free(pbuffer16);
FREECONTEXTS;
#endif

#ifdef SUPPORT_PCRE2_32
#undef BITS
#define BITS 32
free(pbuffer32);
FREECONTEXTS;
#endif

#if defined(__VMS)
  yield = SS$_NORMAL;  /* Return values via DCL symbols */
#endif

return yield;
}
