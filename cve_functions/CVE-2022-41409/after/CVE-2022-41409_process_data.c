process_data(void)
{
PCRE2_SIZE len, ulen, arg_ulen;
uint32_t gmatched;
uint32_t c, k;
uint32_t g_notempty = 0;
uint8_t *p, *pp, *start_rep;
size_t needlen;
void *use_dat_context;
BOOL utf;
BOOL subject_literal;

PCRE2_SIZE *ovector;
PCRE2_SIZE ovecsave[3];
uint32_t oveccount;

#ifdef SUPPORT_PCRE2_8
uint8_t *q8 = NULL;
#endif
#ifdef SUPPORT_PCRE2_16
uint16_t *q16 = NULL;
#endif
#ifdef SUPPORT_PCRE2_32
uint32_t *q32 = NULL;
#endif

subject_literal = (pat_patctl.control2 & CTL2_SUBJECT_LITERAL) != 0;

/* Copy the default context and data control blocks to the active ones. Then
copy from the pattern the controls that can be set in either the pattern or the
data. This allows them to be overridden in the data line. We do not do this for
options because those that are common apply separately to compiling and
matching. */

DATCTXCPY(dat_context, default_dat_context);
memcpy(&dat_datctl, &def_datctl, sizeof(datctl));
dat_datctl.control |= (pat_patctl.control & CTL_ALLPD);
dat_datctl.control2 |= (pat_patctl.control2 & CTL2_ALLPD);
strcpy((char *)dat_datctl.replacement, (char *)pat_patctl.replacement);
if (dat_datctl.jitstack == 0) dat_datctl.jitstack = pat_patctl.jitstack;

if (dat_datctl.substitute_skip == 0)
    dat_datctl.substitute_skip = pat_patctl.substitute_skip;
if (dat_datctl.substitute_stop == 0)
    dat_datctl.substitute_stop = pat_patctl.substitute_stop;

/* Initialize for scanning the data line. */

#ifdef SUPPORT_PCRE2_8
utf = ((((pat_patctl.control & CTL_POSIX) != 0)?
  ((pcre2_real_code_8 *)preg.re_pcre2_code)->overall_options :
  FLD(compiled_code, overall_options)) & PCRE2_UTF) != 0;
#else
utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;
#endif

start_rep = NULL;
len = strlen((const char *)buffer);
while (len > 0 && isspace(buffer[len-1])) len--;
buffer[len] = 0;
p = buffer;
while (isspace(*p)) p++;

/* Check that the data is well-formed UTF-8 if we're in UTF mode. To create
invalid input to pcre2_match(), you must use \x?? or \x{} sequences. */

if (utf)
  {
  uint8_t *q;
  uint32_t cc;
  int n = 1;
  for (q = p; n > 0 && *q; q += n) n = utf82ord(q, &cc);
  if (n <= 0)
    {
    fprintf(outfile, "** Failed: invalid UTF-8 string cannot be used as input "
      "in UTF mode\n");
    return PR_OK;
    }
  }

#ifdef SUPPORT_VALGRIND
/* Mark the dbuffer as addressable but undefined again. */
if (dbuffer != NULL)
  {
  VALGRIND_MAKE_MEM_UNDEFINED(dbuffer, dbuffer_size);
  }
#endif

/* Allocate a buffer to hold the data line; len+1 is an upper bound on
the number of code units that will be needed (though the buffer may have to be
extended if replication is involved). */

needlen = (size_t)((len+1) * code_unit_size);
if (dbuffer == NULL || needlen >= dbuffer_size)
  {
  while (needlen >= dbuffer_size) dbuffer_size *= 2;
  dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);
  if (dbuffer == NULL)
    {
    fprintf(stderr, "pcre2test: realloc(%d) failed\n", (int)dbuffer_size);
    exit(1);
    }
  }
SETCASTPTR(q, dbuffer);  /* Sets q8, q16, or q32, as appropriate. */

/* Scan the data line, interpreting data escapes, and put the result into a
buffer of the appropriate width. In UTF mode, input is always UTF-8; otherwise,
in 16- and 32-bit modes, it can be forced to UTF-8 by the utf8_input modifier.
*/

while ((c = *p++) != 0)
  {
  int32_t i = 0;
  size_t replen;

  /* ] may mark the end of a replicated sequence */

  if (c == ']' && start_rep != NULL)
    {
    long li;
    char *endptr;

    if (*p++ != '{')
      {
      fprintf(outfile, "** Expected '{' after \\[....]\n");
      return PR_OK;
      }

    li = strtol((const char *)p, &endptr, 10);
    if (S32OVERFLOW(li))
      {
      fprintf(outfile, "** Repeat count too large\n");
      return PR_OK;
      }

    p = (uint8_t *)endptr;
    if (*p++ != '}')
      {
      fprintf(outfile, "** Expected '}' after \\[...]{...\n");
      return PR_OK;
      }

    i = (int32_t)li;
    if (i-- <= 0)
      {
      fprintf(outfile, "** Zero or negative repeat not allowed\n");
      return PR_OK;
      }

    replen = CAST8VAR(q) - start_rep;
    needlen += replen * i;

    if (needlen >= dbuffer_size)
      {
      size_t qoffset = CAST8VAR(q) - dbuffer;
      size_t rep_offset = start_rep - dbuffer;
      while (needlen >= dbuffer_size) dbuffer_size *= 2;
      dbuffer = (uint8_t *)realloc(dbuffer, dbuffer_size);
      if (dbuffer == NULL)
        {
        fprintf(stderr, "pcre2test: realloc(%d) failed\n", (int)dbuffer_size);
        exit(1);
        }
      SETCASTPTR(q, dbuffer + qoffset);
      start_rep = dbuffer + rep_offset;
      }

    while (i-- > 0)
      {
      memcpy(CAST8VAR(q), start_rep, replen);
      SETPLUS(q, replen/code_unit_size);
      }

    start_rep = NULL;
    continue;
    }

  /* Handle a non-escaped character. In non-UTF 32-bit mode with utf8_input
  set, do the fudge for setting the top bit. */

  if (c != '\\' || subject_literal)
    {
    uint32_t topbit = 0;
    if (test_mode == PCRE32_MODE && c == 0xff && *p != 0)
      {
      topbit = 0x80000000;
      c = *p++;
      }
    if ((utf || (pat_patctl.control & CTL_UTF8_INPUT) != 0) &&
      HASUTF8EXTRALEN(c)) { GETUTF8INC(c, p); }
    c |= topbit;
    }

  /* Handle backslash escapes */

  else switch ((c = *p++))
    {
    case '\\': break;
    case 'a': c = CHAR_BEL; break;
    case 'b': c = '\b'; break;
    case 'e': c = CHAR_ESC; break;
    case 'f': c = '\f'; break;
    case 'n': c = '\n'; break;
    case 'r': c = '\r'; break;
    case 't': c = '\t'; break;
    case 'v': c = '\v'; break;

    case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7':
    c -= '0';
    while (i++ < 2 && isdigit(*p) && *p != '8' && *p != '9')
      c = c * 8 + *p++ - '0';
    break;

    case 'o':
    if (*p == '{')
      {
      uint8_t *pt = p;
      c = 0;
      for (pt++; isdigit(*pt) && *pt != '8' && *pt != '9'; pt++)
        {
        if (++i == 12)
          fprintf(outfile, "** Too many octal digits in \\o{...} item; "
                           "using only the first twelve.\n");
        else c = c * 8 + *pt - '0';
        }
      if (*pt == '}') p = pt + 1;
        else fprintf(outfile, "** Missing } after \\o{ (assumed)\n");
      }
    break;

    case 'x':
    if (*p == '{')
      {
      uint8_t *pt = p;
      c = 0;

      /* We used to have "while (isxdigit(*(++pt)))" here, but it fails
      when isxdigit() is a macro that refers to its argument more than
      once. This is banned by the C Standard, but apparently happens in at
      least one MacOS environment. */

      for (pt++; isxdigit(*pt); pt++)
        {
        if (++i == 9)
          fprintf(outfile, "** Too many hex digits in \\x{...} item; "
                           "using only the first eight.\n");
        else c = c * 16 + tolower(*pt) - ((isdigit(*pt))? '0' : 'a' - 10);
        }
      if (*pt == '}')
        {
        p = pt + 1;
        break;
        }
      /* Not correct form for \x{...}; fall through */
      }

    /* \x without {} always defines just one byte in 8-bit mode. This
    allows UTF-8 characters to be constructed byte by byte, and also allows
    invalid UTF-8 sequences to be made. Just copy the byte in UTF-8 mode.
    Otherwise, pass it down as data. */

    c = 0;
    while (i++ < 2 && isxdigit(*p))
      {
      c = c * 16 + tolower(*p) - ((isdigit(*p))? '0' : 'a' - 10);
      p++;
      }
#if defined SUPPORT_PCRE2_8
    if (utf && (test_mode == PCRE8_MODE))
      {
      *q8++ = c;
      continue;
      }
#endif
    break;

    case 0:     /* \ followed by EOF allows for an empty line */
    p--;
    continue;

    case '=':   /* \= terminates the data, starts modifiers */
    goto ENDSTRING;

    case '[':   /* \[ introduces a replicated character sequence */
    if (start_rep != NULL)
      {
      fprintf(outfile, "** Nested replication is not supported\n");
      return PR_OK;
      }
    start_rep = CAST8VAR(q);
    continue;

    default:
    if (isalnum(c))
      {
      fprintf(outfile, "** Unrecognized escape sequence \"\\%c\"\n", c);
      return PR_OK;
      }
    }

  /* We now have a character value in c that may be greater than 255.
  In 8-bit mode we convert to UTF-8 if we are in UTF mode. Values greater
  than 127 in UTF mode must have come from \x{...} or octal constructs
  because values from \x.. get this far only in non-UTF mode. */

#ifdef SUPPORT_PCRE2_8
  if (test_mode == PCRE8_MODE)
    {
    if (utf)
      {
      if (c > 0x7fffffff)
        {
        fprintf(outfile, "** Character \\x{%x} is greater than 0x7fffffff "
          "and so cannot be converted to UTF-8\n", c);
        return PR_OK;
        }
      q8 += ord2utf8(c, q8);
      }
    else
      {
      if (c > 0xffu)
        {
        fprintf(outfile, "** Character \\x{%x} is greater than 255 "
          "and UTF-8 mode is not enabled.\n", c);
        fprintf(outfile, "** Truncation will probably give the wrong "
          "result.\n");
        }
      *q8++ = (uint8_t)c;
      }
    }
#endif
#ifdef SUPPORT_PCRE2_16
  if (test_mode == PCRE16_MODE)
    {
    if (utf)
      {
      if (c > 0x10ffffu)
        {
        fprintf(outfile, "** Failed: character \\x{%x} is greater than "
          "0x10ffff and so cannot be converted to UTF-16\n", c);
        return PR_OK;
        }
      else if (c >= 0x10000u)
        {
        c-= 0x10000u;
        *q16++ = 0xD800 | (c >> 10);
        *q16++ = 0xDC00 | (c & 0x3ff);
        }
      else
        *q16++ = c;
      }
    else
      {
      if (c > 0xffffu)
        {
        fprintf(outfile, "** Character \\x{%x} is greater than 0xffff "
          "and UTF-16 mode is not enabled.\n", c);
        fprintf(outfile, "** Truncation will probably give the wrong "
          "result.\n");
        }

      *q16++ = (uint16_t)c;
      }
    }
#endif
#ifdef SUPPORT_PCRE2_32
  if (test_mode == PCRE32_MODE)
    {
    *q32++ = c;
    }
#endif
  }

ENDSTRING:
SET(*q, 0);
len = CASTVAR(uint8_t *, q) - dbuffer;    /* Length in bytes */
ulen = len/code_unit_size;                /* Length in code units */
arg_ulen = ulen;                          /* Value to use in match arg */

/* If the string was terminated by \= we must now interpret modifiers. */

if (p[-1] != 0 && !decode_modifiers(p, CTX_DAT, NULL, &dat_datctl))
  return PR_OK;

/* Setting substitute_{skip,fail} implies a substitute callout. */

if (dat_datctl.substitute_skip != 0 || dat_datctl.substitute_stop != 0)
  dat_datctl.control2 |= CTL2_SUBSTITUTE_CALLOUT;

/* Check for mutually exclusive modifiers. At present, these are all in the
first control word. */

for (k = 0; k < sizeof(exclusive_dat_controls)/sizeof(uint32_t); k++)
  {
  c = dat_datctl.control & exclusive_dat_controls[k];
  if (c != 0 && c != (c & (~c+1)))
    {
    show_controls(c, 0, "** Not allowed together:");
    fprintf(outfile, "\n");
    return PR_OK;
    }
  }

if (pat_patctl.replacement[0] != 0)
  {
  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0 &&
      (dat_datctl.control & CTL_NULLCONTEXT) != 0)
    {
    fprintf(outfile, "** Replacement callouts are not supported with null_context.\n");
    return PR_OK;
    }

  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)
    fprintf(outfile, "** Ignored with replacement text: allcaptures\n");
  }

/* Warn for modifiers that are ignored for DFA. */

if ((dat_datctl.control & CTL_DFA) != 0)
  {
  if ((dat_datctl.control & CTL_ALLCAPTURES) != 0)
    fprintf(outfile, "** Ignored after DFA matching: allcaptures\n");
  }

/* We now have the subject in dbuffer, with len containing the byte length, and
ulen containing the code unit length, with a copy in arg_ulen for use in match
function arguments (this gets changed to PCRE2_ZERO_TERMINATED when the
zero_terminate modifier is present).

Move the data to the end of the buffer so that a read over the end can be
caught by valgrind or other means. If we have explicit valgrind support, mark
the unused start of the buffer unaddressable. If we are using the POSIX
interface, or testing zero-termination, we must include the terminating zero in
the usable data. */

c = code_unit_size * (((pat_patctl.control & CTL_POSIX) +
                       (dat_datctl.control & CTL_ZERO_TERMINATE) != 0)? 1:0);
pp = memmove(dbuffer + dbuffer_size - len - c, dbuffer, len + c);
#ifdef SUPPORT_VALGRIND
  VALGRIND_MAKE_MEM_NOACCESS(dbuffer, dbuffer_size - (len + c));
#endif

/* Now pp points to the subject string, but if null_subject was specified, set
it to NULL to test PCRE2's behaviour. */

if ((dat_datctl.control2 & CTL2_NULL_SUBJECT) != 0) pp = NULL;

/* POSIX matching is only possible in 8-bit mode, and it does not support
timing or other fancy features. Some were checked at compile time, but we need
to check the match-time settings here. */

#ifdef SUPPORT_PCRE2_8
if ((pat_patctl.control & CTL_POSIX) != 0)
  {
  int rc;
  int eflags = 0;
  regmatch_t *pmatch = NULL;
  const char *msg = "** Ignored with POSIX interface:";

  if (dat_datctl.cerror[0] != CFORE_UNSET || dat_datctl.cerror[1] != CFORE_UNSET)
    prmsg(&msg, "callout_error");
  if (dat_datctl.cfail[0] != CFORE_UNSET || dat_datctl.cfail[1] != CFORE_UNSET)
    prmsg(&msg, "callout_fail");
  if (dat_datctl.copy_numbers[0] >= 0 || dat_datctl.copy_names[0] != 0)
    prmsg(&msg, "copy");
  if (dat_datctl.get_numbers[0] >= 0 || dat_datctl.get_names[0] != 0)
    prmsg(&msg, "get");
  if (dat_datctl.jitstack != 0) prmsg(&msg, "jitstack");
  if (dat_datctl.offset != 0) prmsg(&msg, "offset");

  if ((dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS) != 0)
    {
    fprintf(outfile, "%s", msg);
    show_match_options(dat_datctl.options & ~POSIX_SUPPORTED_MATCH_OPTIONS);
    msg = "";
    }
  if ((dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS) != 0 ||
      (dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2) != 0)
    {
    show_controls(dat_datctl.control & ~POSIX_SUPPORTED_MATCH_CONTROLS,
                  dat_datctl.control2 & ~POSIX_SUPPORTED_MATCH_CONTROLS2, msg);
    msg = "";
    }

  if (msg[0] == 0) fprintf(outfile, "\n");

  if (dat_datctl.oveccount > 0)
    {
    pmatch = (regmatch_t *)malloc(sizeof(regmatch_t) * dat_datctl.oveccount);
    if (pmatch == NULL)
      {
      fprintf(outfile, "** Failed to get memory for recording matching "
        "information (size set = %du)\n", dat_datctl.oveccount);
      return PR_OK;
      }
    }

  if (dat_datctl.startend[0] != CFORE_UNSET)
    {
    pmatch[0].rm_so = dat_datctl.startend[0];
    pmatch[0].rm_eo = (dat_datctl.startend[1] != 0)?
      dat_datctl.startend[1] : len;
    eflags |= REG_STARTEND;
    }

  if ((dat_datctl.options & PCRE2_NOTBOL) != 0) eflags |= REG_NOTBOL;
  if ((dat_datctl.options & PCRE2_NOTEOL) != 0) eflags |= REG_NOTEOL;
  if ((dat_datctl.options & PCRE2_NOTEMPTY) != 0) eflags |= REG_NOTEMPTY;

  rc = regexec(&preg, (const char *)pp, dat_datctl.oveccount, pmatch, eflags);
  if (rc != 0)
    {
    (void)regerror(rc, &preg, (char *)pbuffer8, pbuffer8_size);
    fprintf(outfile, "No match: POSIX code %d: %s\n", rc, pbuffer8);
    }
  else if ((pat_patctl.control & CTL_POSIX_NOSUB) != 0)
    fprintf(outfile, "Matched with REG_NOSUB\n");
  else if (dat_datctl.oveccount == 0)
    fprintf(outfile, "Matched without capture\n");
  else
    {
    size_t i, j;
    size_t last_printed = (size_t)dat_datctl.oveccount;
    for (i = 0; i < (size_t)dat_datctl.oveccount; i++)
      {
      if (pmatch[i].rm_so >= 0)
        {
        PCRE2_SIZE start = pmatch[i].rm_so;
        PCRE2_SIZE end = pmatch[i].rm_eo;
        for (j = last_printed + 1; j < i; j++)
          fprintf(outfile, "%2d: <unset>\n", (int)j);
        last_printed = i;
        if (start > end)
          {
          start = pmatch[i].rm_eo;
          end = pmatch[i].rm_so;
          fprintf(outfile, "Start of matched string is beyond its end - "
            "displaying from end to start.\n");
          }
        fprintf(outfile, "%2d: ", (int)i);
        PCHARSV(pp, start, end - start, utf, outfile);
        fprintf(outfile, "\n");

        if ((i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0) ||
            (dat_datctl.control & CTL_ALLAFTERTEXT) != 0)
          {
          fprintf(outfile, "%2d+ ", (int)i);
          /* Note: don't use the start/end variables here because we want to
          show the text from what is reported as the end. */
          PCHARSV(pp, pmatch[i].rm_eo, len - pmatch[i].rm_eo, utf, outfile);
          fprintf(outfile, "\n"); }
        }
      }
    }
  free(pmatch);
  return PR_OK;
  }
#endif  /* SUPPORT_PCRE2_8 */

 /* Handle matching via the native interface. Check for consistency of
modifiers. */

if (dat_datctl.startend[0] != CFORE_UNSET)
  fprintf(outfile, "** \\=posix_startend ignored for non-POSIX matching\n");

/* ALLUSEDTEXT is not supported with JIT, but JIT is not used with DFA
matching, even if the JIT compiler was used. */

if ((dat_datctl.control & (CTL_ALLUSEDTEXT|CTL_DFA)) == CTL_ALLUSEDTEXT &&
    FLD(compiled_code, executable_jit) != NULL)
  {
  fprintf(outfile, "** Showing all consulted text is not supported by JIT: ignored\n");
  dat_datctl.control &= ~CTL_ALLUSEDTEXT;
  }

/* Handle passing the subject as zero-terminated. */

if ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)
  arg_ulen = PCRE2_ZERO_TERMINATED;

/* The nullcontext modifier is used to test calling pcre2_[jit_]match() with a
NULL context. */

use_dat_context = ((dat_datctl.control & CTL_NULLCONTEXT) != 0)?
  NULL : PTR(dat_context);

/* Enable display of malloc/free if wanted. We can do this only if either the
pattern or the subject is processed with a context. */

show_memory = (dat_datctl.control & CTL_MEMORY) != 0;

if (show_memory &&
    (pat_patctl.control & dat_datctl.control & CTL_NULLCONTEXT) != 0)
  fprintf(outfile, "** \\=memory requires either a pattern or a subject "
    "context: ignored\n");

/* Create and assign a JIT stack if requested. */

if (dat_datctl.jitstack != 0)
  {
  if (dat_datctl.jitstack != jit_stack_size)
    {
    PCRE2_JIT_STACK_FREE(jit_stack);
    PCRE2_JIT_STACK_CREATE(jit_stack, 1, dat_datctl.jitstack * 1024, NULL);
    jit_stack_size = dat_datctl.jitstack;
    }
  PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, jit_stack);
  }

/* Or de-assign */

else if (jit_stack != NULL)
  {
  PCRE2_JIT_STACK_ASSIGN(dat_context, NULL, NULL);
  PCRE2_JIT_STACK_FREE(jit_stack);
  jit_stack = NULL;
  jit_stack_size = 0;
  }

/* When no JIT stack is assigned, we must ensure that there is a JIT callback
if we want to verify that JIT was actually used. */

if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_stack == NULL)
   {
   PCRE2_JIT_STACK_ASSIGN(dat_context, jit_callback, NULL);
   }

/* Adjust match_data according to size of offsets required. A size of zero
causes a new match data block to be obtained that exactly fits the pattern. */

if (dat_datctl.oveccount == 0)
  {
  PCRE2_MATCH_DATA_FREE(match_data);
  PCRE2_MATCH_DATA_CREATE_FROM_PATTERN(match_data, compiled_code,
    general_context);
  PCRE2_GET_OVECTOR_COUNT(max_oveccount, match_data);
  }
else if (dat_datctl.oveccount <= max_oveccount)
  {
  SETFLD(match_data, oveccount, dat_datctl.oveccount);
  }
else
  {
  max_oveccount = dat_datctl.oveccount;
  PCRE2_MATCH_DATA_FREE(match_data);
  PCRE2_MATCH_DATA_CREATE(match_data, max_oveccount, general_context);
  }

if (CASTVAR(void *, match_data) == NULL)
  {
  fprintf(outfile, "** Failed to get memory for recording matching "
    "information (size requested: %d)\n", dat_datctl.oveccount);
  max_oveccount = 0;
  return PR_OK;
  }

ovector = FLD(match_data, ovector);
PCRE2_GET_OVECTOR_COUNT(oveccount, match_data);

/* Replacement processing is ignored for DFA matching. */

if (dat_datctl.replacement[0] != 0 && (dat_datctl.control & CTL_DFA) != 0)
  {
  fprintf(outfile, "** Ignored for DFA matching: replace\n");
  dat_datctl.replacement[0] = 0;
  }

/* If a replacement string is provided, call pcre2_substitute() instead of one
of the matching functions. First we have to convert the replacement string to
the appropriate width. */

if (dat_datctl.replacement[0] != 0)
  {
  int rc;
  uint8_t *pr;
  uint8_t rbuffer[REPLACE_BUFFSIZE];
  uint8_t nbuffer[REPLACE_BUFFSIZE];
  uint8_t *rbptr;
  uint32_t xoptions;
  uint32_t emoption;  /* External match option */
  PCRE2_SIZE j, rlen, nsize, erroroffset;
  BOOL badutf = FALSE;

#ifdef SUPPORT_PCRE2_8
  uint8_t *r8 = NULL;
#endif
#ifdef SUPPORT_PCRE2_16
  uint16_t *r16 = NULL;
#endif
#ifdef SUPPORT_PCRE2_32
  uint32_t *r32 = NULL;
#endif

  /* Fill the ovector with junk to detect elements that do not get set
  when they should be (relevant only when "allvector" is specified). */

  for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;

  if (timeitm)
    fprintf(outfile, "** Timing is not supported with replace: ignored\n");

  if ((dat_datctl.control & CTL_ALTGLOBAL) != 0)
    fprintf(outfile, "** Altglobal is not supported with replace: ignored\n");

  /* Check for a test that does substitution after an initial external match.
  If this is set, we run the external match, but leave the interpretation of
  its output to pcre2_substitute(). */

  emoption = ((dat_datctl.control2 & CTL2_SUBSTITUTE_MATCHED) == 0)? 0 :
    PCRE2_SUBSTITUTE_MATCHED;

  if (emoption != 0)
    {
    PCRE2_MATCH(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,
      dat_datctl.options, match_data, use_dat_context);
    }

  xoptions = emoption |
             (((dat_datctl.control & CTL_GLOBAL) == 0)? 0 :
                PCRE2_SUBSTITUTE_GLOBAL) |
             (((dat_datctl.control2 & CTL2_SUBSTITUTE_EXTENDED) == 0)? 0 :
                PCRE2_SUBSTITUTE_EXTENDED) |
             (((dat_datctl.control2 & CTL2_SUBSTITUTE_LITERAL) == 0)? 0 :
                PCRE2_SUBSTITUTE_LITERAL) |
             (((dat_datctl.control2 & CTL2_SUBSTITUTE_OVERFLOW_LENGTH) == 0)? 0 :
                PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) |
             (((dat_datctl.control2 & CTL2_SUBSTITUTE_REPLACEMENT_ONLY) == 0)? 0 :
                PCRE2_SUBSTITUTE_REPLACEMENT_ONLY) |
             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNKNOWN_UNSET) == 0)? 0 :
                PCRE2_SUBSTITUTE_UNKNOWN_UNSET) |
             (((dat_datctl.control2 & CTL2_SUBSTITUTE_UNSET_EMPTY) == 0)? 0 :
                PCRE2_SUBSTITUTE_UNSET_EMPTY);

  SETCASTPTR(r, rbuffer);  /* Sets r8, r16, or r32, as appropriate. */
  pr = dat_datctl.replacement;

  /* If the replacement starts with '[<number>]' we interpret that as length
  value for the replacement buffer. */

  nsize = REPLACE_BUFFSIZE/code_unit_size;
  if (*pr == '[')
    {
    PCRE2_SIZE n = 0;
    while ((c = *(++pr)) >= CHAR_0 && c <= CHAR_9) n = n * 10 + c - CHAR_0;
    if (*pr++ != ']')
      {
      fprintf(outfile, "Bad buffer size in replacement string\n");
      return PR_OK;
      }
    if (n > nsize)
      {
      fprintf(outfile, "Replacement buffer setting (%" SIZ_FORM ") is too "
        "large (max %" SIZ_FORM ")\n", n, nsize);
      return PR_OK;
      }
    nsize = n;
    }

  /* Now copy the replacement string to a buffer of the appropriate width. No
  escape processing is done for replacements. In UTF mode, check for an invalid
  UTF-8 input string, and if it is invalid, just copy its code units without
  UTF interpretation. This provides a means of checking that an invalid string
  is detected. Otherwise, UTF-8 can be used to include wide characters in a
  replacement. */

  if (utf) badutf = valid_utf(pr, strlen((const char *)pr), &erroroffset);

  /* Not UTF or invalid UTF-8: just copy the code units. */

  if (!utf || badutf)
    {
    while ((c = *pr++) != 0)
      {
#ifdef SUPPORT_PCRE2_8
      if (test_mode == PCRE8_MODE) *r8++ = c;
#endif
#ifdef SUPPORT_PCRE2_16
      if (test_mode == PCRE16_MODE) *r16++ = c;
#endif
#ifdef SUPPORT_PCRE2_32
      if (test_mode == PCRE32_MODE) *r32++ = c;
#endif
      }
    }

  /* Valid UTF-8 replacement string */

  else while ((c = *pr++) != 0)
    {
    if (HASUTF8EXTRALEN(c)) { GETUTF8INC(c, pr); }

#ifdef SUPPORT_PCRE2_8
    if (test_mode == PCRE8_MODE) r8 += ord2utf8(c, r8);
#endif

#ifdef SUPPORT_PCRE2_16
    if (test_mode == PCRE16_MODE)
      {
      if (c >= 0x10000u)
        {
        c-= 0x10000u;
        *r16++ = 0xD800 | (c >> 10);
        *r16++ = 0xDC00 | (c & 0x3ff);
        }
      else *r16++ = c;
      }
#endif

#ifdef SUPPORT_PCRE2_32
    if (test_mode == PCRE32_MODE) *r32++ = c;
#endif
    }

  SET(*r, 0);
  if ((dat_datctl.control & CTL_ZERO_TERMINATE) != 0)
    rlen = PCRE2_ZERO_TERMINATED;
  else
    rlen = (CASTVAR(uint8_t *, r) - rbuffer)/code_unit_size;

  if ((dat_datctl.control2 & CTL2_SUBSTITUTE_CALLOUT) != 0)
    {
    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, substitute_callout_function, NULL);
    }
  else
    {
    PCRE2_SET_SUBSTITUTE_CALLOUT(dat_context, NULL, NULL);  /* No callout */
    }

  /* There is a special option to set the replacement to NULL in order to test
  that case. */

  rbptr = ((dat_datctl.control2 & CTL2_NULL_REPLACEMENT) == 0)? rbuffer : NULL;

  PCRE2_SUBSTITUTE(rc, compiled_code, pp, arg_ulen, dat_datctl.offset,
    dat_datctl.options|xoptions, match_data, use_dat_context,
    rbptr, rlen, nbuffer, &nsize);

  if (rc < 0)
    {
    fprintf(outfile, "Failed: error %d", rc);
    if (rc != PCRE2_ERROR_NOMEMORY && nsize != PCRE2_UNSET)
      fprintf(outfile, " at offset %ld in replacement", (long int)nsize);
    fprintf(outfile, ": ");
    if (!print_error_message(rc, "", "")) return PR_ABEND;
    if (rc == PCRE2_ERROR_NOMEMORY &&
        (xoptions & PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) != 0)
      fprintf(outfile, ": %ld code units are needed", (long int)nsize);
    }
  else
    {
    fprintf(outfile, "%2d: ", rc);
    PCHARSV(nbuffer, 0, nsize, utf, outfile);
    }

  fprintf(outfile, "\n");
  show_memory = FALSE;

  /* Show final ovector contents if requested. */

  if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)
    show_ovector(ovector, oveccount);

  return PR_OK;
  }   /* End of substitution handling */

/* When a replacement string is not provided, run a loop for global matching
with one of the basic matching functions. For altglobal (or first time round
the loop), set an "unset" value for the previous match info. */

ovecsave[0] = ovecsave[1] = ovecsave[2] = PCRE2_UNSET;

for (gmatched = 0;; gmatched++)
  {
  PCRE2_SIZE j;
  int capcount;

  /* Fill the ovector with junk to detect elements that do not get set
  when they should be. */

  for (j = 0; j < 2*oveccount; j++) ovector[j] = JUNK_OFFSET;

  /* When matching is via pcre2_match(), we will detect the use of JIT via the
  stack callback function. */

  jit_was_used = (pat_patctl.control & CTL_JITFAST) != 0;

  /* Do timing if required. */

  if (timeitm > 0)
    {
    int i;
    clock_t start_time, time_taken;

    if ((dat_datctl.control & CTL_DFA) != 0)
      {
      if ((dat_datctl.options & PCRE2_DFA_RESTART) != 0)
        {
        fprintf(outfile, "Timing DFA restarts is not supported\n");
        return PR_OK;
        }
      if (dfa_workspace == NULL)
        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));
      start_time = clock();
      for (i = 0; i < timeitm; i++)
        {
        PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,
          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,
          use_dat_context, dfa_workspace, DFA_WS_DIMENSION);
        }
      }

    else if ((pat_patctl.control & CTL_JITFAST) != 0)
      {
      start_time = clock();
      for (i = 0; i < timeitm; i++)
        {
        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen,
          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,
          use_dat_context);
        }
      }

    else
      {
      start_time = clock();
      for (i = 0; i < timeitm; i++)
        {
        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen,
          dat_datctl.offset, dat_datctl.options | g_notempty, match_data,
          use_dat_context);
        }
      }
    total_match_time += (time_taken = clock() - start_time);
    fprintf(outfile, "Match time %.4f milliseconds\n",
      (((double)time_taken * 1000.0) / (double)timeitm) /
        (double)CLOCKS_PER_SEC);
    }

  /* Find the heap, match and depth limits if requested. The depth and heap
  limits are not relevant for JIT. The return from check_match_limit() is the
  return from the final call to pcre2_match() or pcre2_dfa_match(). */

  if ((dat_datctl.control & (CTL_FINDLIMITS|CTL_FINDLIMITS_NOHEAP)) != 0)
    {
    capcount = 0;  /* This stops compiler warnings */

    if ((dat_datctl.control & CTL_FINDLIMITS_NOHEAP) == 0 &&
        (FLD(compiled_code, executable_jit) == NULL ||
          (dat_datctl.options & PCRE2_NO_JIT) != 0))
      {
      (void)check_match_limit(pp, arg_ulen, PCRE2_ERROR_HEAPLIMIT, "heap");
      }

    capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_MATCHLIMIT,
      "match");

    if (FLD(compiled_code, executable_jit) == NULL ||
        (dat_datctl.options & PCRE2_NO_JIT) != 0 ||
        (dat_datctl.control & CTL_DFA) != 0)
      {
      capcount = check_match_limit(pp, arg_ulen, PCRE2_ERROR_DEPTHLIMIT,
        "depth");
      }

    if (capcount == 0)
      {
      fprintf(outfile, "Matched, but offsets vector is too small to show all matches\n");
      capcount = dat_datctl.oveccount;
      }
    }

  /* Otherwise just run a single match, setting up a callout if required (the
  default). There is a copy of the pattern in pbuffer8 for use by callouts. */

  else
    {
    if ((dat_datctl.control & CTL_CALLOUT_NONE) == 0)
      {
      PCRE2_SET_CALLOUT(dat_context, callout_function,
        (void *)(&dat_datctl.callout_data));
      first_callout = TRUE;
      last_callout_mark = NULL;
      callout_count = 0;
      }
    else
      {
      PCRE2_SET_CALLOUT(dat_context, NULL, NULL);  /* No callout */
      }

    /* Run a single DFA or NFA match. */

    if ((dat_datctl.control & CTL_DFA) != 0)
      {
      if (dfa_workspace == NULL)
        dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));
      if (dfa_matched++ == 0)
        dfa_workspace[0] = -1;  /* To catch bad restart */
      PCRE2_DFA_MATCH(capcount, compiled_code, pp, arg_ulen,
        dat_datctl.offset, dat_datctl.options | g_notempty, match_data,
        use_dat_context, dfa_workspace, DFA_WS_DIMENSION);
      if (capcount == 0)
        {
        fprintf(outfile, "Matched, but offsets vector is too small to show all matches\n");
        capcount = dat_datctl.oveccount;
        }
      }
    else
      {
      if ((pat_patctl.control & CTL_JITFAST) != 0)
        PCRE2_JIT_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,
          dat_datctl.options | g_notempty, match_data, use_dat_context);
      else
        PCRE2_MATCH(capcount, compiled_code, pp, arg_ulen, dat_datctl.offset,
          dat_datctl.options | g_notempty, match_data, use_dat_context);
      if (capcount == 0)
        {
        fprintf(outfile, "Matched, but too many substrings\n");
        capcount = dat_datctl.oveccount;
        }
      }
    }

  /* The result of the match is now in capcount. First handle a successful
  match. If pp was forced to be NULL (to test NULL handling) it will have been
  treated as an empty string if the length was zero. So re-create that for
  outputting. */

  if (capcount >= 0)
    {
    int i;

    if (pp == NULL) pp = (uint8_t *)"";

    if (capcount > (int)oveccount)   /* Check for lunatic return value */
      {
      fprintf(outfile,
        "** PCRE2 error: returned count %d is too big for ovector count %d\n",
        capcount, oveccount);
      capcount = oveccount;
      if ((dat_datctl.control & CTL_ANYGLOB) != 0)
        {
        fprintf(outfile, "** Global loop abandoned\n");
        dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */
        }
      }

    /* If PCRE2_COPY_MATCHED_SUBJECT was set, check that things are as they
    should be, but not for fast JIT, where it isn't supported. */

    if ((dat_datctl.options & PCRE2_COPY_MATCHED_SUBJECT) != 0 &&
        (pat_patctl.control & CTL_JITFAST) == 0)
      {
      if ((FLD(match_data, flags) & PCRE2_MD_COPIED_SUBJECT) == 0)
        fprintf(outfile,
          "** PCRE2 error: flag not set after copy_matched_subject\n");

      if (CASTFLD(void *, match_data, subject) == pp)
        fprintf(outfile,
          "** PCRE2 error: copy_matched_subject has not copied\n");

      if (memcmp(CASTFLD(void *, match_data, subject), pp, ulen) != 0)
        fprintf(outfile,
          "** PCRE2 error: copy_matched_subject mismatch\n");
      }

    /* If this is not the first time round a global loop, check that the
    returned string has changed. If it has not, check for an empty string match
    at different starting offset from the previous match. This is a failed test
    retry for null-matching patterns that don't match at their starting offset,
    for example /(?<=\G.)/. A repeated match at the same point is not such a
    pattern, and must be discarded, and we then proceed to seek a non-null
    match at the current point. For any other repeated match, there is a bug
    somewhere and we must break the loop because it will go on for ever. We
    know that there are always at least two elements in the ovector. */

    if (gmatched > 0 && ovecsave[0] == ovector[0] && ovecsave[1] == ovector[1])
      {
      if (ovector[0] == ovector[1] && ovecsave[2] != dat_datctl.offset)
        {
        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;
        ovecsave[2] = dat_datctl.offset;
        continue;    /* Back to the top of the loop */
        }
      fprintf(outfile,
        "** PCRE2 error: global repeat returned the same string as previous\n");
      fprintf(outfile, "** Global loop abandoned\n");
      dat_datctl.control &= ~CTL_ANYGLOB;        /* Break g/G loop */
      }

    /* "allcaptures" requests showing of all captures in the pattern, to check
    unset ones at the end. It may be set on the pattern or the data. Implement
    by setting capcount to the maximum. This is not relevant for DFA matching,
    so ignore it (warning given above). */

    if ((dat_datctl.control & (CTL_ALLCAPTURES|CTL_DFA)) == CTL_ALLCAPTURES)
      {
      capcount = maxcapcount + 1;   /* Allow for full match */
      if (capcount > (int)oveccount) capcount = oveccount;
      }

    /* "allvector" request showing the entire ovector. */

    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0) capcount = oveccount;

    /* Output the captured substrings. Note that, for the matched string,
    the use of \K in an assertion can make the start later than the end. */

    for (i = 0; i < 2*capcount; i += 2)
      {
      PCRE2_SIZE lleft, lmiddle, lright;
      PCRE2_SIZE start = ovector[i];
      PCRE2_SIZE end = ovector[i+1];

      if (start > end)
        {
        start = ovector[i+1];
        end = ovector[i];
        fprintf(outfile, "Start of matched string is beyond its end - "
          "displaying from end to start.\n");
        }

      fprintf(outfile, "%2d: ", i/2);

      /* Check for an unset group */

      if (start == PCRE2_UNSET && end == PCRE2_UNSET)
        {
        fprintf(outfile, "<unset>\n");
        continue;
        }

      /* Check for silly offsets, in particular, values that have not been
      set when they should have been. However, if we are past the end of the
      captures for this pattern ("allvector" causes this), or if we are DFA
      matching, it isn't an error if the entry is unchanged. */

      if (start > ulen || end > ulen)
        {
        if (((dat_datctl.control & CTL_DFA) != 0 ||
              i >= (int)(2*maxcapcount + 2)) &&
            start == JUNK_OFFSET && end == JUNK_OFFSET)
          fprintf(outfile, "<unchanged>\n");
        else
          fprintf(outfile, "ERROR: bad value(s) for offset(s): 0x%lx 0x%lx\n",
            (unsigned long int)start, (unsigned long int)end);
        continue;
        }

      /* When JIT is not being used, ALLUSEDTEXT may be set. (It if is set with
      JIT, it is disabled above, with a comment.) When the match is done by the
      interpreter, leftchar and rightchar are available, and if ALLUSEDTEXT is
      set, and if the leftmost consulted character is before the start of the
      match or the rightmost consulted character is past the end of the match,
      we want to show all consulted characters for the main matched string, and
      indicate which were lookarounds. */

      if (i == 0)
        {
        BOOL showallused;
        PCRE2_SIZE leftchar, rightchar;

        if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)
          {
          leftchar = FLD(match_data, leftchar);
          rightchar = FLD(match_data, rightchar);
          showallused = i == 0 && (leftchar < start || rightchar > end);
          }
        else showallused = FALSE;

        if (showallused)
          {
          PCHARS(lleft, pp, leftchar, start - leftchar, utf, outfile);
          PCHARS(lmiddle, pp, start, end - start, utf, outfile);
          PCHARS(lright, pp, end, rightchar - end, utf, outfile);
          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)
            fprintf(outfile, " (JIT)");
          fprintf(outfile, "\n    ");
          for (j = 0; j < lleft; j++) fprintf(outfile, "<");
          for (j = 0; j < lmiddle; j++) fprintf(outfile, " ");
          for (j = 0; j < lright; j++) fprintf(outfile, ">");
          }

        /* When a pattern contains \K, the start of match position may be
        different to the start of the matched string. When this is the case,
        show it when requested. */

        else if ((dat_datctl.control & CTL_STARTCHAR) != 0)
          {
          PCRE2_SIZE startchar;
          PCRE2_GET_STARTCHAR(startchar, match_data);
          PCHARS(lleft, pp, startchar, start - startchar, utf, outfile);
          PCHARSV(pp, start, end - start, utf, outfile);
          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)
            fprintf(outfile, " (JIT)");
          if (startchar != start)
            {
            fprintf(outfile, "\n    ");
            for (j = 0; j < lleft; j++) fprintf(outfile, "^");
            }
          }

        /* Otherwise, just show the matched string. */

        else
          {
          PCHARSV(pp, start, end - start, utf, outfile);
          if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)
            fprintf(outfile, " (JIT)");
          }
        }

      /* Not the main matched string. Just show it unadorned. */

      else
        {
        PCHARSV(pp, start, end - start, utf, outfile);
        }

      fprintf(outfile, "\n");

      /* Note: don't use the start/end variables here because we want to
      show the text from what is reported as the end. */

      if ((dat_datctl.control & CTL_ALLAFTERTEXT) != 0 ||
          (i == 0 && (dat_datctl.control & CTL_AFTERTEXT) != 0))
        {
        fprintf(outfile, "%2d+ ", i/2);
        PCHARSV(pp, ovector[i+1], ulen - ovector[i+1], utf, outfile);
        fprintf(outfile, "\n");
        }
      }

    /* Output (*MARK) data if requested */

    if ((dat_datctl.control & CTL_MARK) != 0 &&
         TESTFLD(match_data, mark, !=, NULL))
      {
      fprintf(outfile, "MK: ");
      PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);
      fprintf(outfile, "\n");
      }

    /* Process copy/get strings */

    if (!copy_and_get(utf, capcount)) return PR_ABEND;

    }    /* End of handling a successful match */

  /* There was a partial match. The value of ovector[0] is the bumpalong point,
  that is, startchar, not any \K point that might have been passed. When JIT is
  not in use, "allusedtext" may be set, in which case we indicate the leftmost
  consulted character. */

  else if (capcount == PCRE2_ERROR_PARTIAL)
    {
    PCRE2_SIZE leftchar;
    int backlength;
    int rubriclength = 0;

    if ((dat_datctl.control & CTL_ALLUSEDTEXT) != 0)
      {
      leftchar = FLD(match_data, leftchar);
      }
    else leftchar = ovector[0];

    fprintf(outfile, "Partial match");
    if ((dat_datctl.control & CTL_MARK) != 0 &&
         TESTFLD(match_data, mark, !=, NULL))
      {
      fprintf(outfile, ", mark=");
      PCHARS(rubriclength, CASTFLD(void *, match_data, mark), -1, -1, utf,
        outfile);
      rubriclength += 7;
      }
    fprintf(outfile, ": ");
    rubriclength += 15;

    PCHARS(backlength, pp, leftchar, ovector[0] - leftchar, utf, outfile);
    PCHARSV(pp, ovector[0], ulen - ovector[0], utf, outfile);

    if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)
      fprintf(outfile, " (JIT)");
    fprintf(outfile, "\n");

    if (backlength != 0)
      {
      int i;
      for (i = 0; i < rubriclength; i++) fprintf(outfile, " ");
      for (i = 0; i < backlength; i++) fprintf(outfile, "<");
      fprintf(outfile, "\n");
      }

    if (ulen != ovector[1])
      fprintf(outfile, "** ovector[1] is not equal to the subject length: "
        "%ld != %ld\n", (unsigned long int)ovector[1], (unsigned long int)ulen);

    /* Process copy/get strings */

    if (!copy_and_get(utf, 1)) return PR_ABEND;

    /* "allvector" outputs the entire vector */

    if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)
      show_ovector(ovector, oveccount);

    break;  /* Out of the /g loop */
    }       /* End of handling partial match */

  /* Failed to match. If this is a /g or /G loop, we might previously have
  set g_notempty (to PCRE2_NOTEMPTY_ATSTART|PCRE2_ANCHORED) after a null match.
  If that is the case, this is not necessarily the end. We want to advance the
  start offset, and continue. We won't be at the end of the string - that was
  checked before setting g_notempty. We achieve the effect by pretending that a
  single character was matched.

  Complication arises in the case when the newline convention is "any", "crlf",
  or "anycrlf". If the previous match was at the end of a line terminated by
  CRLF, an advance of one character just passes the CR, whereas we should
  prefer the longer newline sequence, as does the code in pcre2_match().

  Otherwise, in the case of UTF-8 or UTF-16 matching, the advance must be one
  character, not one byte. */

  else if (g_notempty != 0)   /* There was a previous null match */
    {
    uint16_t nl = FLD(compiled_code, newline_convention);
    PCRE2_SIZE start_offset = dat_datctl.offset;    /* Where the match was */
    PCRE2_SIZE end_offset = start_offset + 1;

    if ((nl == PCRE2_NEWLINE_CRLF || nl == PCRE2_NEWLINE_ANY ||
         nl == PCRE2_NEWLINE_ANYCRLF) &&
        start_offset < ulen - 1 &&
        CODE_UNIT(pp, start_offset) == '\r' &&
        CODE_UNIT(pp, end_offset) == '\n')
      end_offset++;

    else if (utf && test_mode != PCRE32_MODE)
      {
      if (test_mode == PCRE8_MODE)
        {
        for (; end_offset < ulen; end_offset++)
          if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;
        }
      else  /* 16-bit mode */
        {
        for (; end_offset < ulen; end_offset++)
          if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;
        }
      }

    SETFLDVEC(match_data, ovector, 0, start_offset);
    SETFLDVEC(match_data, ovector, 1, end_offset);
    }  /* End of handling null match in a global loop */

  /* A "normal" match failure. There will be a negative error number in
  capcount. */

  else
    {
    switch(capcount)
      {
      case PCRE2_ERROR_NOMATCH:
      if (gmatched == 0)
        {
        fprintf(outfile, "No match");
        if ((dat_datctl.control & CTL_MARK) != 0 &&
             TESTFLD(match_data, mark, !=, NULL))
          {
          fprintf(outfile, ", mark = ");
          PCHARSV(CASTFLD(void *, match_data, mark), -1, -1, utf, outfile);
          }
        if ((pat_patctl.control & CTL_JITVERIFY) != 0 && jit_was_used)
          fprintf(outfile, " (JIT)");
        fprintf(outfile, "\n");

        /* "allvector" outputs the entire vector */

        if ((dat_datctl.control2 & CTL2_ALLVECTOR) != 0)
          show_ovector(ovector, oveccount);
        }
      break;

      case PCRE2_ERROR_BADUTFOFFSET:
      fprintf(outfile, "Error %d (bad UTF-%d offset)\n", capcount, test_mode);
      break;

      default:
      fprintf(outfile, "Failed: error %d: ", capcount);
      if (!print_error_message(capcount, "", "")) return PR_ABEND;
      if (capcount <= PCRE2_ERROR_UTF8_ERR1 &&
          capcount >= PCRE2_ERROR_UTF32_ERR2)
        {
        PCRE2_SIZE startchar;
        PCRE2_GET_STARTCHAR(startchar, match_data);
        fprintf(outfile, " at offset %" SIZ_FORM, startchar);
        }
      fprintf(outfile, "\n");
      break;
      }

    break;  /* Out of the /g loop */
    }       /* End of failed match handling */

  /* Control reaches here in two circumstances: (a) after a match, and (b)
  after a non-match that immediately followed a match on an empty string when
  doing a global search. Such a match is done with PCRE2_NOTEMPTY_ATSTART and
  PCRE2_ANCHORED set in g_notempty. The code above turns it into a fake match
  of one character. So effectively we get here only after a match. If we
  are not doing a global search, we are done. */

  if ((dat_datctl.control & CTL_ANYGLOB) == 0) break; else
    {
    PCRE2_SIZE match_offset = FLD(match_data, ovector)[0];
    PCRE2_SIZE end_offset = FLD(match_data, ovector)[1];

    /* We must now set up for the next iteration of a global search. If we have
    matched an empty string, first check to see if we are at the end of the
    subject. If so, the loop is over. Otherwise, mimic what Perl's /g option
    does. Set PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED and try the match again
    at the same point. If this fails it will be picked up above, where a fake
    match is set up so that at this point we advance to the next character.

    However, in order to cope with patterns that never match at their starting
    offset (e.g. /(?<=\G.)/) we don't do this when the match offset is greater
    than the starting offset. This means there will be a retry with the
    starting offset at the match offset. If this returns the same match again,
    it is picked up above and ignored, and the special action is then taken. */

    if (match_offset == end_offset)
      {
      if (end_offset == ulen) break;           /* End of subject */
      if (match_offset <= dat_datctl.offset)
        g_notempty = PCRE2_NOTEMPTY_ATSTART | PCRE2_ANCHORED;
      }

    /* However, even after matching a non-empty string, there is still one
    tricky case. If a pattern contains \K within a lookbehind assertion at the
    start, the end of the matched string can be at the offset where the match
    started. In the case of a normal /g iteration without special action, this
    leads to a loop that keeps on returning the same substring. The loop would
    be caught above, but we really want to move on to the next match. */

    else
      {
      g_notempty = 0;   /* Set for a "normal" repeat */
      if ((dat_datctl.control & CTL_GLOBAL) != 0)
        {
        PCRE2_SIZE startchar;
        PCRE2_GET_STARTCHAR(startchar, match_data);
        if (end_offset <= startchar)
          {
          if (startchar >= ulen) break;       /* End of subject */
          end_offset = startchar + 1;
          if (utf && test_mode != PCRE32_MODE)
            {
            if (test_mode == PCRE8_MODE)
              {
              for (; end_offset < ulen; end_offset++)
                if ((((PCRE2_SPTR8)pp)[end_offset] & 0xc0) != 0x80) break;
              }
            else  /* 16-bit mode */
              {
              for (; end_offset < ulen; end_offset++)
                if ((((PCRE2_SPTR16)pp)[end_offset] & 0xfc00) != 0xdc00) break;
              }
            }
          }
        }
      }

    /* For a normal global (/g) iteration, save the current ovector[0,1] and
    the starting offset so that we can check that they do change each time.
    Otherwise a matching bug that returns the same string causes an infinite
    loop. It has happened! Then update the start offset, leaving other
    parameters alone. */

    if ((dat_datctl.control & CTL_GLOBAL) != 0)
      {
      ovecsave[0] = ovector[0];
      ovecsave[1] = ovector[1];
      ovecsave[2] = dat_datctl.offset;
      dat_datctl.offset = end_offset;
      }

    /* For altglobal, just update the pointer and length. */

    else
      {
      pp += end_offset * code_unit_size;
      len -= end_offset * code_unit_size;
      ulen -= end_offset;
      if (arg_ulen != PCRE2_ZERO_TERMINATED) arg_ulen -= end_offset;
      }
    }
  }  /* End of global loop */

show_memory = FALSE;
return PR_OK;
}
