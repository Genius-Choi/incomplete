process_command(void)
{
FILE *f;
PCRE2_SIZE serial_size;
size_t i;
int rc, cmd, cmdlen, yield;
uint16_t first_listed_newline;
const char *cmdname;
uint8_t *argptr, *serial;

yield = PR_OK;
cmd = CMD_UNKNOWN;
cmdlen = 0;

for (i = 0; i < cmdlistcount; i++)
  {
  cmdname = cmdlist[i].name;
  cmdlen = strlen(cmdname);
  if (strncmp((char *)(buffer+1), cmdname, cmdlen) == 0 &&
      isspace(buffer[cmdlen+1]))
    {
    cmd = cmdlist[i].value;
    break;
    }
  }

argptr = buffer + cmdlen + 1;

if (restrict_for_perl_test && cmd != CMD_PATTERN && cmd != CMD_SUBJECT)
  {
  fprintf(outfile, "** #%s is not allowed after #perltest\n", cmdname);
  return PR_ABEND;
  }

switch(cmd)
  {
  case CMD_UNKNOWN:
  fprintf(outfile, "** Unknown command: %s", buffer);
  break;

  case CMD_FORBID_UTF:
  forbid_utf = PCRE2_NEVER_UTF|PCRE2_NEVER_UCP;
  break;

  case CMD_PERLTEST:
  restrict_for_perl_test = TRUE;
  break;

  /* Set default pattern modifiers */

  case CMD_PATTERN:
  (void)decode_modifiers(argptr, CTX_DEFPAT, &def_patctl, NULL);
  if (def_patctl.jit == 0 && (def_patctl.control & CTL_JITVERIFY) != 0)
    def_patctl.jit = JIT_DEFAULT;
  break;

  /* Set default subject modifiers */

  case CMD_SUBJECT:
  (void)decode_modifiers(argptr, CTX_DEFDAT, NULL, &def_datctl);
  break;

  /* Check the default newline, and if not one of those listed, set up the
  first one to be forced. An empty list unsets. */

  case CMD_NEWLINE_DEFAULT:
  local_newline_default = 0;   /* Unset */
  first_listed_newline = 0;
  for (;;)
    {
    while (isspace(*argptr)) argptr++;
    if (*argptr == 0) break;
    for (i = 1; i < sizeof(newlines)/sizeof(char *); i++)
      {
      size_t nlen = strlen(newlines[i]);
      if (strncmpic(argptr, (const uint8_t *)newlines[i], nlen) == 0 &&
          isspace(argptr[nlen]))
        {
        if (i == NEWLINE_DEFAULT) return PR_OK;  /* Default is valid */
        if (first_listed_newline == 0) first_listed_newline = i;
        }
      }
    while (*argptr != 0 && !isspace(*argptr)) argptr++;
    }
  local_newline_default = first_listed_newline;
  break;

  /* Pop or copy a compiled pattern off the stack. Modifiers that do not affect
  the compiled pattern (e.g. to give information) are permitted. The default
  pattern modifiers are ignored. */

  case CMD_POP:
  case CMD_POPCOPY:
  if (patstacknext <= 0)
    {
    fprintf(outfile, "** Can't pop off an empty stack\n");
    return PR_SKIP;
    }
  memset(&pat_patctl, 0, sizeof(patctl));   /* Completely unset */
  if (!decode_modifiers(argptr, CTX_POPPAT, &pat_patctl, NULL))
    return PR_SKIP;

  if (cmd == CMD_POP)
    {
    SET(compiled_code, patstack[--patstacknext]);
    }
  else
    {
    PCRE2_CODE_COPY_FROM_VOID(compiled_code, patstack[patstacknext - 1]);
    }

  if (pat_patctl.jit != 0)
    {
    PCRE2_JIT_COMPILE(jitrc, compiled_code, pat_patctl.jit);
    }
  if ((pat_patctl.control & CTL_MEMORY) != 0) show_memory_info();
  if ((pat_patctl.control2 & CTL2_FRAMESIZE) != 0) show_framesize();
  if ((pat_patctl.control & CTL_ANYINFO) != 0)
    {
    rc = show_pattern_info();
    if (rc != PR_OK) return rc;
    }
  break;

  /* Save the stack of compiled patterns to a file, then empty the stack. */

  case CMD_SAVE:
  if (patstacknext <= 0)
    {
    fprintf(outfile, "** No stacked patterns to save\n");
    return PR_OK;
    }

  rc = open_file(argptr+1, BINARY_OUTPUT_MODE, &f, "#save");
  if (rc != PR_OK) return rc;

  PCRE2_SERIALIZE_ENCODE(rc, patstack, patstacknext, &serial, &serial_size,
    general_context);
  if (rc < 0)
    {
    fclose(f);
    if (!serial_error(rc, "Serialization")) return PR_ABEND;
    break;
    }

  /* Write the length at the start of the file to make it straightforward to
  get the right memory when re-loading. This saves having to read the file size
  in different operating systems. To allow for different endianness (even
  though reloading with the opposite endianness does not work), write the
  length byte-by-byte. */

  for (i = 0; i < 4; i++) fputc((serial_size >> (i*8)) & 255, f);
  if (fwrite(serial, 1, serial_size, f) != serial_size)
    {
    fprintf(outfile, "** Wrong return from fwrite()\n");
    fclose(f);
    return PR_ABEND;
    }

  fclose(f);
  PCRE2_SERIALIZE_FREE(serial);
  while(patstacknext > 0)
    {
    SET(compiled_code, patstack[--patstacknext]);
    SUB1(pcre2_code_free, compiled_code);
    }
  SET(compiled_code, NULL);
  break;

  /* Load a set of compiled patterns from a file onto the stack */

  case CMD_LOAD:
  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, "#load");
  if (rc != PR_OK) return rc;

  serial_size = 0;
  for (i = 0; i < 4; i++) serial_size |= fgetc(f) << (i*8);

  serial = malloc(serial_size);
  if (serial == NULL)
    {
    fprintf(outfile, "** Failed to get memory (size %" SIZ_FORM ") for #load\n",
      serial_size);
    fclose(f);
    return PR_ABEND;
    }

  i = fread(serial, 1, serial_size, f);
  fclose(f);

  if (i != serial_size)
    {
    fprintf(outfile, "** Wrong return from fread()\n");
    yield = PR_ABEND;
    }
  else
    {
    PCRE2_SERIALIZE_GET_NUMBER_OF_CODES(rc, serial);
    if (rc < 0)
      {
      if (!serial_error(rc, "Get number of codes")) yield = PR_ABEND;
      }
    else
      {
      if (rc + patstacknext > PATSTACKSIZE)
        {
        fprintf(outfile, "** Not enough space on pattern stack for %d pattern%s\n",
          rc, (rc == 1)? "" : "s");
        rc = PATSTACKSIZE - patstacknext;
        fprintf(outfile, "** Decoding %d pattern%s\n", rc,
          (rc == 1)? "" : "s");
        }
      PCRE2_SERIALIZE_DECODE(rc, patstack + patstacknext, rc, serial,
        general_context);
      if (rc < 0)
        {
        if (!serial_error(rc, "Deserialization")) yield = PR_ABEND;
        }
      else patstacknext += rc;
      }
    }

  free(serial);
  break;

  /* Load a set of binary tables into tables3. */

  case CMD_LOADTABLES:
  rc = open_file(argptr+1, BINARY_INPUT_MODE, &f, "#loadtables");
  if (rc != PR_OK) return rc;

  if (tables3 == NULL)
    {
    (void)PCRE2_CONFIG(PCRE2_CONFIG_TABLES_LENGTH, &loadtables_length);
    tables3 = malloc(loadtables_length);
    }

  if (tables3 == NULL)
    {
    fprintf(outfile, "** Failed: malloc failed for #loadtables\n");
    yield = PR_ABEND;
    }
  else if (fread(tables3, 1, loadtables_length, f) != loadtables_length)
    {
    fprintf(outfile, "** Wrong return from fread()\n");
    yield = PR_ABEND;
    }

  fclose(f);
  break;
  }

return yield;
}
