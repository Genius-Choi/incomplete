c_option(const char *arg)
{
uint32_t optval;
unsigned int i = COPTLISTCOUNT;
int yield = 0;

if (arg != NULL && arg[0] != CHAR_MINUS)
  {
  for (i = 0; i < COPTLISTCOUNT; i++)
    if (strcmp(arg, coptlist[i].name) == 0) break;

  if (i >= COPTLISTCOUNT)
    {
    fprintf(stderr, "** Unknown -C option '%s'\n", arg);
    return 0;
    }

  switch (coptlist[i].type)
    {
    case CONF_BSR:
    (void)PCRE2_CONFIG(coptlist[i].value, &optval);
    printf("%s\n", (optval == PCRE2_BSR_ANYCRLF)? "ANYCRLF" : "ANY");
    break;

    case CONF_FIX:
    yield = coptlist[i].value;
    printf("%d\n", yield);
    break;

    case CONF_FIZ:
    optval = coptlist[i].value;
    printf("%d\n", optval);
    break;

    case CONF_INT:
    (void)PCRE2_CONFIG(coptlist[i].value, &yield);
    printf("%d\n", yield);
    break;

    case CONF_NL:
    (void)PCRE2_CONFIG(coptlist[i].value, &optval);
    print_newline_config(optval, TRUE);
    break;
    }

/* For VMS, return the value by setting a symbol, for certain values only. This
is contributed code which the PCRE2 developers have no means of testing. */

#ifdef __VMS

/* This is the original code provided by the first VMS contributor. */
#ifdef NEVER
  if (copytlist[i].type == CONF_FIX || coptlist[i].type == CONF_INT)
    {
    char ucname[16];
    strcpy(ucname, coptlist[i].name);
    for (i = 0; ucname[i] != 0; i++) ucname[i] = toupper[ucname[i]];
    vms_setsymbol(ucname, 0, optval);
    }
#endif

/* This is the new code, provided by a second VMS contributor. */

  if (coptlist[i].type == CONF_FIX || coptlist[i].type == CONF_INT)
    {
    char nam_buf[22], val_buf[4];
    $DESCRIPTOR(nam, nam_buf);
    $DESCRIPTOR(val, val_buf);

    strcpy(nam_buf, coptlist[i].name);
    nam.dsc$w_length = strlen(nam_buf);
    sprintf(val_buf, "%d", yield);
    val.dsc$w_length = strlen(val_buf);
    lib$set_symbol(&nam, &val);
    }
#endif  /* __VMS */

  return yield;
  }

/* No argument for -C: output all configuration information. */

print_version(stdout);
printf("Compiled with\n");

#ifdef EBCDIC
printf("  EBCDIC code support: LF is 0x%02x\n", CHAR_LF);
#if defined NATIVE_ZOS
printf("  EBCDIC code page %s or similar\n", pcrz_cpversion());
#endif
#endif

(void)PCRE2_CONFIG(PCRE2_CONFIG_COMPILED_WIDTHS, &optval);
if (optval & 1) printf("  8-bit support\n");
if (optval & 2) printf("  16-bit support\n");
if (optval & 4) printf("  32-bit support\n");

#ifdef SUPPORT_VALGRIND
printf("  Valgrind support\n");
#endif

(void)PCRE2_CONFIG(PCRE2_CONFIG_UNICODE, &optval);
if (optval != 0)
  {
  printf("  UTF and UCP support (");
  print_unicode_version(stdout);
  printf(")\n");
  }
else printf("  No Unicode support\n");

(void)PCRE2_CONFIG(PCRE2_CONFIG_JIT, &optval);
if (optval != 0)
  {
  printf("  Just-in-time compiler support: ");
  print_jit_target(stdout);
  printf("\n");
  }
else
  {
  printf("  No just-in-time compiler support\n");
  }

(void)PCRE2_CONFIG(PCRE2_CONFIG_NEWLINE, &optval);
print_newline_config(optval, FALSE);
(void)PCRE2_CONFIG(PCRE2_CONFIG_BSR, &optval);
printf("  \\R matches %s\n",
  (optval == PCRE2_BSR_ANYCRLF)? "CR, LF, or CRLF only" :
                                 "all Unicode newlines");
(void)PCRE2_CONFIG(PCRE2_CONFIG_NEVER_BACKSLASH_C, &optval);
printf("  \\C is %ssupported\n", optval? "not ":"");
(void)PCRE2_CONFIG(PCRE2_CONFIG_LINKSIZE, &optval);
printf("  Internal link size = %d\n", optval);
(void)PCRE2_CONFIG(PCRE2_CONFIG_PARENSLIMIT, &optval);
printf("  Parentheses nest limit = %d\n", optval);
(void)PCRE2_CONFIG(PCRE2_CONFIG_HEAPLIMIT, &optval);
printf("  Default heap limit = %d kibibytes\n", optval);
(void)PCRE2_CONFIG(PCRE2_CONFIG_MATCHLIMIT, &optval);
printf("  Default match limit = %d\n", optval);
(void)PCRE2_CONFIG(PCRE2_CONFIG_DEPTHLIMIT, &optval);
printf("  Default depth limit = %d\n", optval);

#if defined SUPPORT_LIBREADLINE
printf("  pcre2test has libreadline support\n");
#elif defined SUPPORT_LIBEDIT
printf("  pcre2test has libedit support\n");
#else
printf("  pcre2test has neither libreadline nor libedit support\n");
#endif

return 0;
}
