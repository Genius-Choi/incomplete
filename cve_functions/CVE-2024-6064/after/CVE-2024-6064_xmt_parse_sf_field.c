static u32 xmt_parse_sf_field(GF_XMTParser *parser, GF_FieldInfo *info, GF_Node *n, char *a_value)
{
	u32 res = 0;
	switch (info->fieldType) {
	case GF_SG_VRML_SFINT32:
		res = xmt_parse_int(parser, info->name, (SFInt32 *)info->far_ptr, a_value);
		break;
	case GF_SG_VRML_SFBOOL:
		res = xmt_parse_bool(parser, info->name, (SFBool *)info->far_ptr, a_value);
		break;
	case GF_SG_VRML_SFFLOAT:
		res = xmt_parse_float(parser, info->name, (SFFloat *)info->far_ptr, a_value);
		break;
	case GF_SG_VRML_SFTIME:
		res = xmt_parse_time(parser, info->name, (SFTime *)info->far_ptr, a_value);
		if (n) xmt_check_time_offset(parser, n, info);
		break;
	case GF_SG_VRML_SFCOLOR:
		res = xmt_parse_float(parser, info->name, & ((SFColor *)info->far_ptr)->red, a_value);
		res += xmt_parse_float(parser, info->name, & ((SFColor *)info->far_ptr)->green, a_value + res);
		res += xmt_parse_float(parser, info->name, & ((SFColor *)info->far_ptr)->blue, a_value + res);
		break;
	case GF_SG_VRML_SFVEC2F:
		res = xmt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->x, a_value);
		res += xmt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->y, a_value + res);
		break;
	case GF_SG_VRML_SFVEC3F:
		res = xmt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->x, a_value);
		res += xmt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->y, a_value + res);
		res += xmt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->z, a_value + res);
		break;
	case GF_SG_VRML_SFROTATION:
		res = xmt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->x, a_value);
		res += xmt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->y, a_value + res);
		res += xmt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->z, a_value + res);
		res += xmt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->q, a_value + res);
		break;
	case GF_SG_VRML_SFSTRING:
		res = xmt_parse_string(parser, info->name, (SFString*)info->far_ptr, 0, a_value);
		if (n && (n->sgprivate->tag==TAG_MPEG4_BitWrapper)) {
			gf_sm_update_bitwrapper_buffer(n, parser->load->fileName);
		}
		break;
	case GF_SG_VRML_SFSCRIPT:
		res = xmt_parse_script(parser, info->name, (SFScript *)info->far_ptr, 0, a_value);
		break;
	case GF_SG_VRML_SFCOMMANDBUFFER:
	{
		SFCommandBuffer *cb = (SFCommandBuffer *)info->far_ptr;
		if (parser->command_buffer) {
			cb->buffer = (unsigned char*)parser->command_buffer;
		} else {
			cb->buffer = (unsigned char*)parser->command;
		}
		parser->command_buffer = cb;
	}
	break;

	case GF_SG_VRML_SFIMAGE:
	{
		u32 k, size, v;
		SFImage *img = (SFImage *)info->far_ptr;
		res = xmt_parse_int(parser, "width", (SFInt32*)&img->width, a_value);
		if (parser->last_error) return res;
		res += xmt_parse_int(parser, "height", (SFInt32*)&img->height, a_value + res);
		if (parser->last_error) return res;
		res += xmt_parse_int(parser, "nbComp", (SFInt32*)&v, a_value + res);
		if (parser->last_error) return res;
		img->numComponents = v;
		size = img->width * img->height * img->numComponents;
		if (img->pixels) gf_free(img->pixels);
		img->pixels = (unsigned char*)gf_malloc(sizeof(char) * size);
		a_value += res;
		res = 0;
		for (k=0; k<size; k++) {
			char *name = "pixels";
			XMT_GET_ONE_VAL
			if (strstr(value, "0x")) sscanf(value, "%x", &v);
			else sscanf(value, "%u", &v);
			switch (img->numComponents) {
			case 1:
				img->pixels[k] = (char) v;
				break;
			case 2:
				img->pixels[k] = (char) (v>>8)&0xFF;
				img->pixels[k+1] = (char) (v)&0xFF;
				k++;
				break;
			case 3:
				img->pixels[k] = (char) (v>>16)&0xFF;
				img->pixels[k+1] = (char) (v>>8)&0xFF;
				img->pixels[k+2] = (char) (v)&0xFF;
				k+=2;
				break;
			case 4:
				img->pixels[k] = (char) (v>>24)&0xFF;
				img->pixels[k+1] = (char) (v>>16)&0xFF;
				img->pixels[k+2] = (char) (v>>8)&0xFF;
				img->pixels[k+3] = (char) (v)&0xFF;
				k+=3;
				break;
			}
			res += i;
			a_value += i;
		}
	}
	break;

	default:
		parser->last_error = GF_NOT_SUPPORTED;
		break;
	}
	return res;
}
