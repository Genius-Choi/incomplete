static u32 xmt_parse_string(GF_XMTParser *parser, const char *name, SFString *val, Bool is_mf, char *a_value)
{
	char *value;
	char sep[10];
	u32 len;
	u32 i=0;
	u32 k=0;
	char *str = a_value;
	if (!str) return 0;

	/*SF string, no inspection*/
	if (!is_mf) {
		len = (u32) strlen(str);
		if (val->buffer) gf_free(val->buffer);
		val->buffer = NULL;
		if (len) val->buffer = gf_strdup(str);
		return len+1;
	}

	/*now this is the REAL pain:
		X3D allows '"String1" "String2"' and therefore '"String &quot;test&quot;"'
		XMT allows '&quot;String1&quot; &quot;String2&quot;' and therefore '&quot;String \&quot;test\&quot;&quot;'
	thus translating the string from xml to UTF may screw up the separators !! We need to identify them
	*/

	i = 0;
	while ((str[i]==' ') || (str[i]=='\t')) i++;
	if (!strncmp(&str[i], "&quot;", 6)) strcpy(sep, "&quot;");
	else if (!strncmp(&str[i], "&apos;", 6)) strcpy(sep, "&apos;");
	else if (str[i]=='\'') strcpy(sep, "\'");
	else if (str[i]=='\"') strcpy(sep, "\"");
	/*handle as a single field (old GPAC XMT & any unknown cases...*/
	else {
		len = (u32) strlen(str);
		if (val->buffer) gf_free(val->buffer);
		val->buffer = NULL;
		if (len) val->buffer = gf_strdup(str);
		return len;
	}
	k = 0;
	i += (u32) strlen(sep);

	value = gf_strdup(str);

	if (strncmp(&str[i], sep, strlen(sep))) {

		while (str[i]) {
			if ((str[i] == '\\') && !strncmp(&str[i+1], sep, strlen(sep))) {
				i++;
				continue;
			}
			value[k] = str[i];
			i++;
			k++;
			if (!strncmp(&str[i], sep, strlen(sep)) && (str[i-1] != '\\')) break;
		}
	}
	value[k] = 0;
	len = (u32) strlen(sep) + i;

	if (val->buffer) gf_free(val->buffer);
	val->buffer = NULL;
	if (strlen(value)) val->buffer = gf_strdup(value);
	gf_free(value);
	return len;
}
