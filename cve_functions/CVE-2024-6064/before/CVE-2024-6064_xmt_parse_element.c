static GF_Node *xmt_parse_element(GF_XMTParser *parser, char *name, const char *name_space, const GF_XMLAttribute *attributes, u32 nb_attributes, XMTNodeStack *parent)
{
	GF_Err e;
	GF_FieldInfo info;
	u32	tag, i, ID;
	Bool register_def = 0;
	Bool is_script = 0;
	GF_Node *node;
	GF_FieldInfo container;
	char *def_name;
	GF_Proto *proto = NULL;

	node = NULL;
	if (!strcmp(name, "NULL")) return NULL;
	if (!strcmp(name, "ROUTE")) {
		if (!parser->parsing_proto && (parser->doc_type==1) ) {
			GF_Command *sgcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);
			gf_list_add(parser->scene_au->commands, sgcom);
			xmt_parse_route(parser, attributes, nb_attributes, 0, sgcom);
			if (sgcom->RouteID) gf_list_add(parser->inserted_routes, sgcom);
		} else {
			xmt_parse_route(parser, attributes, nb_attributes, 0, NULL);
		}
		return NULL;
	}
	if (parent && parent->node && ((parent->node->sgprivate->tag==TAG_MPEG4_Script)
#ifndef GPAC_DISABLE_X3D
	                               || (parent->node->sgprivate->tag==TAG_X3D_Script)
#endif
	                              ) ) {
		is_script = 1;
		if (!strcmp(name, "field")) {
			xmt_parse_script_field(parser, parent->node, attributes, nb_attributes);
			return NULL;
		}
		else if (!strcmp(name, "node") || !strcmp(name, "nodes") ) return NULL;
	}

	/*proto declaration*/
	if (!strcmp(name, "ProtoDeclare") || !strcmp(name, "ExternProtoDeclare")) {
		if (!parser->parsing_proto && parser->command && !parser->command->new_proto_list) parser->command->new_proto_list = gf_list_new();
		xmt_parse_proto(parser, attributes, nb_attributes, (!parser->parsing_proto && parser->command) ? parser->command->new_proto_list : NULL);
		return NULL;
	}
	/*proto parsing*/
	if (parser->parsing_proto) {
		if (!strcmp(name, "IS"))
			return NULL;

		if (!strcmp(name, "field")) {
			char *fieldName = NULL;
			char *value = NULL;
			u32 fType, eType;
			fType = eType = 0;

			for (i=0; i<nb_attributes; i++) {
				GF_XMLAttribute *att = (GF_XMLAttribute *)&attributes[i];
				if (!att->value || !strlen(att->value)) continue;

				if (!strcmp(att->name, "name")) fieldName  = att->value;
				else if (!strcmp(att->name, "type")) fType = xmt_get_ft_by_name(att->value);
				else if (!strcmp(att->name, "vrml97Hint") || !strcmp(att->name, "accessType") ) eType = xmt_get_et_by_name(att->value);
				else if (strstr(att->name, "value") || strstr(att->name, "Value")) value = att->value;
			}
			parser->proto_field = gf_sg_proto_field_new(parser->parsing_proto, fType, eType, fieldName);
			if (value && strlen(value)) {
				gf_sg_proto_field_get_field(parser->proto_field, &info);
				if (gf_sg_vrml_is_sf_field(fType)) {
					xmt_parse_sf_field(parser, &info, NULL, value);
				} else {
					xmt_parse_mf_field(parser, &info, NULL, value);
				}
			} else if (gf_sg_vrml_get_sf_type(fType) != GF_SG_VRML_SFNODE) {
				/*value not specified for exter proto*/
			}
			/*SF/MFNode proto field: push node stack with container info but no parent*/
			else {
				XMTNodeStack *pf_stack;
				GF_SAFEALLOC(pf_stack, XMTNodeStack);
				if (pf_stack) {
					gf_sg_proto_field_get_field(parser->proto_field, &pf_stack->container_field);
					gf_list_add(parser->nodes, pf_stack);
				}
			}
			return NULL;
		}

		/*X3D style*/
		if (!strcmp(name, "ProtoInterface") || !strcmp(name, "ProtoBody"))
			return NULL;
		/*XMT1 decl for SFNode proto fields*/
		if (parser->proto_field && (!strcmp(name, "node") || !strcmp(name, "nodes")) )
			return NULL;
		/*anim & QP info */
		if (parser->proto_field  && !strcmp(name, "InterfaceCodingParameters")) {
			u32 qp_type, nbBits, hasMinMax, qp_sftype;
			Fixed ftMin, ftMax;
			ftMin = ftMax = 0;
			qp_type = hasMinMax = nbBits = 0;
			for (i=0; i<nb_attributes; i++) {
				GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];
				if (!att->value || !strlen(att->value)) continue;
				if (!strcmp(att->name, "quantCategory")) qp_type = xmt_get_protofield_qp_type(att->value);
				else if (!strcmp(att->name, "nbBits")) nbBits = atoi(att->value);
				else if (!strncmp(att->name, "position3DM", 11) || !strncmp(att->name, "position2DM", 11)
				         || !strncmp(att->name, "drawOrderM", 10) || !strncmp(att->name, "colorM", 6)
				         || !strncmp(att->name, "textureCoordinateM", 18) || !strncmp(att->name, "angleM", 6)
				         || !strncmp(att->name, "scaleM", 6) || !strncmp(att->name, "keyM", 4) || !strncmp(att->name, "sizeM", 5)
				        ) {
					hasMinMax = 1;
					if (strstr(att->name, "Min")) xmt_parse_float(parser, att->name, &ftMin, att->value);
					else xmt_parse_float(parser, att->name, &ftMax, att->value);
				}
			}
			if (gf_sg_vrml_get_sf_type(parser->proto_field->FieldType) == GF_SG_VRML_SFINT32) {
				qp_sftype = GF_SG_VRML_SFINT32;
			} else {
				qp_sftype = GF_SG_VRML_SFFLOAT;
			}
			gf_bifs_proto_field_set_aq_info(parser->proto_field, qp_type, hasMinMax, qp_sftype, &ftMin, &ftMax, nbBits);
			return NULL;
		}
		/*connect */
		if (!strcmp(name, "connect")) {
			GF_ProtoFieldInterface *pf;
			GF_FieldInfo pfield, nfield;
			char *atField, *atProtoField;
			XMTNodeStack *last = (XMTNodeStack*)gf_list_last(parser->nodes);
			is_script = 0;
			if (!last) {
				xmt_report(parser, GF_OK, "connect: no parent node specified - skipping");
				return NULL;
			}
			atField = atProtoField = NULL;
			for (i=0; i<nb_attributes; i++) {
				GF_XMLAttribute *att = (GF_XMLAttribute *)&attributes[i];
				if (!att->value || !strlen(att->value)) continue;
				if (!strcmp(att->name, "nodeField")) atField = att->value;
				else if (!strcmp(att->name, "protoField")) atProtoField = att->value;
			}
			if (!atField) {
				xmt_report(parser, GF_OK, "connect: Missing node field - skipping");
				return NULL;
			}
			if (!atProtoField) {
				xmt_report(parser, GF_OK, "connect: Missing proto field - skipping");
				return NULL;
			}
			if ( (e = gf_node_get_field_by_name(last->node, atField, &nfield)) != GF_OK) {
				u32 l_tag = gf_node_get_tag(last->node);
				if ((l_tag!=TAG_MPEG4_Script)
#ifndef GPAC_DISABLE_X3D
				        && (l_tag!=TAG_X3D_Script)
#endif
				   ) {
					xmt_report(parser, e, "connect: %s not an field of node %s", atField, gf_node_get_class_name(last->node) );
					return NULL;
				}
				is_script = 1;
			}
			pf = gf_sg_proto_field_find_by_name(parser->parsing_proto, atProtoField);
			if (!pf) {
				xmt_report(parser, GF_BAD_PARAM, "connect: Proto field %s is not defined", atProtoField);
				return NULL;
			}
			gf_sg_proto_field_get_field(pf, &pfield);
			if (is_script) {
				gf_sg_script_field_new(last->node, pfield.eventType, pfield.fieldType, atField);
				gf_node_get_field_by_name(last->node, atField, &nfield);
			}
			e = gf_sg_proto_field_set_ised(parser->parsing_proto, pfield.fieldIndex, last->node, nfield.fieldIndex);
			if (e) xmt_report(parser, GF_BAD_PARAM, "connect: %s", gf_error_to_string(e));
			return NULL;
		}
	}
	/*proto instance field*/
	if (!strcmp(name, "fieldValue")) {
		char *field, *value;
		if (!parent || !parent->node || (parent->node->sgprivate->tag != TAG_ProtoNode)) {
			xmt_report(parser, GF_OK, "Warning: fieldValue not a valid node");
			return NULL;
		}
		field = value = NULL;
		for (i=0; i<nb_attributes; i++) {
			GF_XMLAttribute *att = (GF_XMLAttribute *)&attributes[i];
			if (!att->value || !strlen(att->value)) continue;
			if (!strcmp(att->name, "name")) field = att->value;
			else if (!strstr(att->name, "Value") || !strstr(att->name, "value")) value = att->value;
		}
		if (!field) {
			xmt_report(parser, GF_OK, "Warning: unspecified proto field name - skipping");
			return NULL;
		}
		e = gf_node_get_field_by_name(parent->node, field, &info);
		if (e) {
			xmt_report(parser, GF_OK, "Warning: Unknown proto field %s - skipping", field);
			return NULL;
		}
		if (value) {
			if (gf_sg_vrml_is_sf_field(info.fieldType)) {
				xmt_parse_sf_field(parser, &info, parent->node, value);
			} else {
				xmt_parse_mf_field(parser, &info, parent->node, value);
			}
			gf_sg_proto_mark_field_loaded(parent->node, &info);
		} else if (gf_sg_vrml_get_sf_type(info.fieldType) == GF_SG_VRML_SFNODE) {
			parent->container_field = info;
			parent->last = NULL;
		}
		return NULL;
	}
	if (parent && parent->node && (parent->node->sgprivate->tag == TAG_ProtoNode) && (!strcmp(name, "node") || !strcmp(name, "nodes")) ) {
		return NULL;
	}

	ID = 0;
	def_name = NULL;
	tag = 0;

	if (!strcmp(name, "ProtoInstance")) {
		char *proto_name = NULL;
		char *proto_use = NULL;
		node = NULL;
		for (i=0; i<nb_attributes; i++) {
			GF_XMLAttribute *att = (GF_XMLAttribute *)&attributes[i];
			if (!att->value || !strlen(att->value)) continue;
			if (!strcmp(att->name, "name")) {
				proto_name = att->value;
				att->value = NULL;
			} else if (!strcmp(att->name, "USE")) {
				proto_use = att->value;
			}
		}
		if (proto_use) {
			node = xmt_find_node(parser, proto_use);
			e = GF_OK;
			if (!node)
				e = xmt_report(parser, GF_BAD_PARAM, "Warning: Cannot find node %s referenced in USE - skipping", proto_use);

			if (e) return NULL;
			ID = 0;
			register_def = 0;
			tag = 0;
		} else if (proto_name) {
			GF_SceneGraph *sg = parser->load->scene_graph;
			while (1) {
				proto = gf_sg_find_proto(sg, 0, proto_name);
				if (proto) break;
				sg = sg->parent_scene;
				if (!sg) break;
			}
			if (!proto) {
				xmt_report(parser, GF_BAD_PARAM, "%s: not a valid/supported proto", proto_name);
				return NULL;
			}
			node = gf_sg_proto_create_instance(parser->load->scene_graph, proto);
		}
	} else {
		tag = xmt_get_node_tag(parser, name);

		if (!tag) {
			/*XMT-A weird syntax*/
			if (parent) {
				if (gf_node_get_field_by_name(parent->node, name, &parent->container_field)==GF_OK) {
					parent->last = NULL;
					if (parent->container_field.fieldType==GF_SG_VRML_SFCOMMANDBUFFER) {
						parser->command_buffer = (SFCommandBuffer*)parent->container_field.far_ptr;
						/*store command*/
						parser->command_buffer->buffer = (unsigned char *)parser->command;
						parser->state = XMT_STATE_COMMANDS;
					}
					return NULL;
				}
				if (!strcmp(name, "store") && (parent->container_field.fieldType==GF_SG_VRML_MFATTRREF)) {
					GF_FieldInfo pinfo;
					GF_Node *atNode = NULL;
					char *fieldName = NULL;
					for (i=0; i<nb_attributes; i++) {
						GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];
						if (!att->value || !strlen(att->value)) continue;
						if (!strcmp(att->name, "node")) {
							atNode = xmt_find_node(parser, att->value);
							if (!atNode) xmt_report(parser, GF_BAD_PARAM, "Cannot locate node %s", att->value);
						}
						if (!strcmp(att->name, "field")) fieldName = att->value;
					}
					if (!fieldName || !atNode) {
						xmt_report(parser, GF_BAD_PARAM, "Node or field name missing in <store>");
					} else if (gf_node_get_field_by_name(atNode, fieldName, &pinfo) != GF_OK) {
						xmt_report(parser, GF_BAD_PARAM, "Field %s not a member of node %s", fieldName, gf_node_get_class_name(node) );
					} else {
						SFAttrRef *ptr;
						gf_sg_vrml_mf_append(parent->container_field.far_ptr , GF_SG_VRML_MFATTRREF, (void **) &ptr);
						ptr->node = atNode;
						ptr->fieldIndex = pinfo.fieldIndex;
					}
					return NULL;
				}
				parent->container_field.far_ptr = NULL;
			}
			else if (parser->command && (parser->command->tag == GF_SG_MULTIPLE_REPLACE)) {
				if (gf_node_get_field_by_name(parser->command->node, name, &container)==GF_OK) {
					GF_CommandField *field = gf_sg_command_field_new(parser->command);
					field->fieldIndex = container.fieldIndex;
					field->fieldType = container.fieldType;
					return NULL;
				}
			}
			xmt_report(parser, GF_NON_COMPLIANT_BITSTREAM, "Warning: %s is not a valid node - skipping", name);
			return NULL;
		}
		node = gf_node_new(parser->load->scene_graph, tag);
		if (!node) {
			xmt_report(parser, GF_SG_UNKNOWN_NODE, "Warning: %s is not a supported node - skipping", name);
			return NULL;
		}
	}

	parser->current_node_tag = tag;

	if (parent) container = parent->container_field;
	else {
		container.far_ptr = NULL;
		container.fieldIndex = 0;
		container.fieldType = 0;
	}

	for (i=0; i<nb_attributes; i++) {
		GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];
		if (!att->value || !strlen(att->value)) continue;

		if (!strcmp(att->name, "DEF")) {
			GF_Node *undef_node = gf_sg_find_node_by_name(parser->load->scene_graph, att->value);
			register_def = 1;
			if (undef_node) {
				gf_list_del_item(parser->peeked_nodes, undef_node);
				/*if we see twice a DEF N1 then force creation of a new node*/
				if (xmt_has_been_def(parser, att->value)) {
					ID = xmt_get_node_id(parser, att->value);
					xmt_report(parser, GF_OK, "Warning: Node %s has been defined several times - IDs may get corrupted", att->value);
				} else {
					gf_node_register(node, NULL);
					gf_node_unregister(node, NULL);
					node = undef_node;
					ID = 0;
				}
			} else {
				ID = xmt_get_node_id(parser, att->value);

			}
			def_name = att->value;
		}
		/*USE node*/
		else if (!strcmp(att->name, "USE")) {
			GF_Node *def_node;

			def_node = xmt_find_node(parser, att->value);

			e = GF_OK;
			if (!def_node)
				e = xmt_report(parser, GF_BAD_PARAM, "Warning: Cannot find node %s referenced in USE - skipping", att->value);
			else if (tag != gf_node_get_tag(def_node)) {
				xmt_report(parser, GF_OK, "Warning: Node type %s doesn't match type %s of node %s", gf_node_get_class_name(node), gf_node_get_class_name(def_node), att->value);
			}

			/*DESTROY NODE*/
			gf_node_register(node, NULL);
			gf_node_unregister(node, NULL);

			if (e) return NULL;

			node = def_node;
			ID = 0;
			register_def = 0;
			tag = 0;
			break;
		}
		/*X3D stuff*/
		else if (!strcmp(att->name, "containerField")) {
			if (parent) {
				if (gf_node_get_field_by_name(parent->node, att->value, &container) != GF_OK) {
					xmt_report(parser, GF_BAD_PARAM, "Warning: Container field %s not member of node %s", att->value, name);
					container.far_ptr = NULL;
				}
			}
		}
		/*ignored ones*/
		else if (!strcmp(att->name, "bboxCenter") || !strcmp(att->name, "bboxSize")) {
		}
		/*all other fields*/
		else {
			e = gf_node_get_field_by_name(node, att->name, &info);
			if (e) xmt_report(parser, GF_OK, "Warning: Unknown field \"%s\" for node %s - skipping", att->name, name);
			else if (gf_sg_vrml_is_sf_field(info.fieldType)) {
				xmt_parse_sf_field(parser, &info, node, att->value);
			} else {
				xmt_parse_mf_field(parser, &info, node, att->value);
			}
		}
	}

	if (!parser->parsing_proto) xmt_update_timenode(parser, node);

	if (register_def) {
		gf_node_register(node, NULL);
		gf_list_add(parser->def_nodes, node);
	}
	if (ID) gf_node_set_id(node, ID, def_name);

	if (is_script) {
		u32 last_field = gf_node_get_field_count(parent->node);
		gf_node_get_field(parent->node, last_field-1, &container);
	}

	if (parent) {
		if (!container.far_ptr) {
			if (parser->doc_type==2) {
				x3d_get_default_container(parent->node, node, &container);
				parent->last = NULL;
			}
			if (!container.far_ptr) {
				gf_node_get_field_by_name(parent->node, "children", &container);
				parent->last = NULL;
			}
			if (!container.far_ptr) {
				parser->last_error = GF_SG_UNKNOWN_NODE;
				container.fieldType = GF_SG_VRML_UNKNOWN;
			}
		}
		if (container.fieldType == GF_SG_VRML_SFNODE) {
			if (* ((GF_Node **)container.far_ptr) ) gf_node_unregister(* ((GF_Node **)container.far_ptr) , parent->node);
			* ((GF_Node **)container.far_ptr) = node;
			gf_node_register(node, parent->node);
			parent->container_field.far_ptr = NULL;
			parent->last = NULL;
		} else if (container.fieldType == GF_SG_VRML_MFNODE) {
			gf_node_list_add_child_last( (GF_ChildNodeItem **)container.far_ptr, node, &parent->last);
			gf_node_register(node, parent->node);
		}
		if (parent->node)
			gf_node_changed(parent->node, NULL);
		else {
			gf_assert(0);
		}
	}

	if (!parser->parsing_proto && (tag || proto) )
		gf_node_init(node);

	/*For Ivica: load proto as soon as found when in playback mode*/
	if ( (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && proto && !parser->parsing_proto) {
		parser->last_error = gf_sg_proto_load_code(node);
	}
	return node;
}
