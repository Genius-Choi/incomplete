static void xmt_resolve_od_links(GF_XMTParser *parser)
{
	u32 i, j;
	XMT_ESDLink *esdl, *esdl2;
	XMT_ODLink *l;
	char szURL[5000];

	/*fix ESD IDs*/
	i=0;
	while ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {
		if (!esdl->esd) {
			xmt_report(parser, GF_BAD_PARAM, "Stream %s ID %d has no associated ES descriptor\n", esdl->desc_name ? esdl->desc_name : "", esdl->ESID);
			i--;
			gf_list_rem(parser->esd_links, i);
			if (esdl->desc_name) gf_free(esdl->desc_name);
			gf_free(esdl);
			continue;
		}
		if (esdl->ESID) esdl->esd->ESID = esdl->ESID;
		else if (!esdl->esd->ESID) {
			u16 ESID = 1;
			while (!xmt_esid_available(parser, ESID)) ESID++;
			esdl->esd->ESID = ESID;
		}
	}

	/*set OCR es ids*/
	i=0;
	while ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {
		Bool use_old_fmt;
		u16 ocr_id;
		char szTest[50];

		esdl->esd->OCRESID = 0;
		if (!esdl->OCR_Name) continue;

		use_old_fmt = 0;
		ocr_id = atoi(esdl->OCR_Name);
		sprintf(szTest, "%d", ocr_id);
		if (!stricmp(szTest, esdl->OCR_Name)) use_old_fmt = 1;

		j=0;
		while ((esdl2 = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &j))) {
			if (esdl2->desc_name && !strcmp(esdl2->desc_name, esdl->OCR_Name)) {
				esdl->esd->OCRESID = esdl2->esd->ESID;
				break;
			}
			if (use_old_fmt && (esdl2->esd->ESID==ocr_id)) {
				esdl->esd->OCRESID = ocr_id;
				break;
			}
		}
		if (!esdl->esd->OCRESID) {
			xmt_report(parser, GF_OK, "WARNING: Could not find clock reference %s for ES %s - forcing self-synchronization", esdl->OCR_Name, esdl->desc_name);
		}
		gf_free(esdl->OCR_Name);
		esdl->OCR_Name = NULL;
	}

	/*set dependsOn es ids*/
	i=0;
	while ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {
		Bool use_old_fmt;
		u16 dep_id;
		char szTest[50];

		esdl->esd->dependsOnESID = 0;
		if (!esdl->Depends_Name) continue;

		use_old_fmt = 0;
		dep_id = atoi(esdl->Depends_Name);
		sprintf(szTest, "%d", dep_id);
		if (!stricmp(szTest, esdl->Depends_Name)) use_old_fmt = 1;

		j=0;
		while ((esdl2 = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &j))) {
			if (esdl2->desc_name && !strcmp(esdl2->desc_name, esdl->Depends_Name)) {
				esdl->esd->dependsOnESID = esdl2->esd->ESID;
				break;
			}
			if (use_old_fmt && (esdl2->esd->ESID==dep_id)) {
				esdl->esd->dependsOnESID = dep_id;
				break;
			}
		}
		if (!esdl->esd->dependsOnESID) {
			xmt_report(parser, GF_OK, "WARNING: Could not find stream dependence %s for ES %s - forcing self-synchronization", esdl->Depends_Name, esdl->desc_name);
		}
		gf_free(esdl->Depends_Name);
		esdl->Depends_Name = NULL;
	}

	while (gf_list_count(parser->esd_links)) {
		esdl = (XMT_ESDLink *)gf_list_get(parser->esd_links, 0);
		gf_list_rem(parser->esd_links, 0);
		if (esdl->desc_name) gf_free(esdl->desc_name);
		gf_free(esdl);
	}

	i=0;
	while ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i))) {
		if (l->od && !l->od->objectDescriptorID) {
			u16 ODID = 1;
			while (!xmt_odid_available(parser, ODID)) ODID++;
			l->od->objectDescriptorID = ODID;
		}
		if (l->od) {
			if (!l->ID) l->ID = l->od->objectDescriptorID;
			gf_assert(l->ID == l->od->objectDescriptorID);
		}
	}

	/*unroll dep in case some URLs reference ODs by their binary IDs not their string ones*/
	i=0;
	while ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i))) {
		XMT_ODLink *l2;
		/*not OD URL*/
		if (!l->ID) continue;
		j=i+1;
		while ((l2 = (XMT_ODLink*)gf_list_enum(parser->od_links, &j))) {
			/*not OD URL*/
			if (!l2->ID) continue;
			if (l->ID == l2->ID) {
				while (gf_list_count(l2->mf_urls)) {
					MFURL *url = (MFURL *)gf_list_get(l2->mf_urls, 0);
					gf_list_rem(l2->mf_urls, 0);
					gf_list_add(l->mf_urls, url);
				}
				j--;
				gf_list_rem(parser->od_links, j);
				if (l2->desc_name) gf_free(l2->desc_name);
				gf_list_del(l2->mf_urls);
				gf_free(l2);
			}
		}
	}

	while (gf_list_count(parser->od_links) ) {
		l = (XMT_ODLink*)gf_list_get(parser->od_links, 0);
		if (!l->od) {
			/*if no ID found this is not an OD URL*/
			if (l->ID) {
				if (l->desc_name) {
					xmt_report(parser, GF_OK, "WARNING: OD \"%s\" (ID %d) not assigned", l->desc_name, l->ID);
				} else {
					xmt_report(parser, GF_OK, "WARNING: OD ID %d not assigned", l->ID);
				}
			}
		} else {
			MFURL *the_url;
			j=0;
			while ((the_url = (MFURL *)gf_list_enum(l->mf_urls, &j))) {
				u32 k;
				char *seg = NULL;
				for (k=0; k<the_url->count; k++) {
					SFURL *url = &the_url->vals[k];
					if (url->url) seg = strstr(url->url, "#");
					if (seg) {
						sprintf(szURL, "od:%d#%s", l->od->objectDescriptorID, seg+1);
						gf_free(url->url);
						url->url = gf_strdup(szURL);
					} else {
						if (url->url) gf_free(url->url);
						url->url = NULL;
						url->OD_ID = l->od->objectDescriptorID;
					}
				}
			}
		}

		if (l->desc_name) gf_free(l->desc_name);
		gf_list_del(l->mf_urls);
		gf_free(l);
		gf_list_rem(parser->od_links, 0);
	}
}
