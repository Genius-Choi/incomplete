BOOL CEAnsi::OurWriteConsoleW(HANDLE hConsoleOutput, const VOID *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved, bool bInternal /*= false*/)
{
	ORIGINAL_KRNL(WriteConsoleW);
	BOOL lbRc = FALSE;
	//ExtWriteTextParm wrt = {sizeof(wrt), ewtf_None, hConsoleOutput};
	bool bIsConOut = false;
	bool bIsAnsi = false;

	FIRST_ANSI_CALL(static_cast<const BYTE*>(lpBuffer), nNumberOfCharsToWrite);

#if 0
	// Store prompt(?) for clink 0.1.1
	if ((gnAllowClinkUsage == 1) && nNumberOfCharsToWrite && lpBuffer && gpszLastWriteConsole && gcchLastWriteConsoleMax)
	{
		size_t cchMax = std::min(gcchLastWriteConsoleMax-1,nNumberOfCharsToWrite);
		gpszLastWriteConsole[cchMax] = 0;
		wmemmove(gpszLastWriteConsole, (const wchar_t*)lpBuffer, cchMax);
	}
#endif

	// In debug builds: Write to debug console all console Output
	const auto ansiIndex = DumpKnownEscape(static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, de_Normal);

#ifdef _DEBUG
	struct AnsiDuration  // NOLINT(cppcoreguidelines-special-member-functions)
	{
		const int ansiIndex_;
		const std::chrono::steady_clock::time_point startTime_;

		AnsiDuration(const int ansiIndex)
			: ansiIndex_(ansiIndex), startTime_(std::chrono::steady_clock::now())
		{
		}

		~AnsiDuration()
		{
			const auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - startTime_);
			wchar_t info[80] = L"";
			msprintf(info, countof(info), L"[%u] AnsiDump #%u duration(ms): %u\n", GetCurrentThreadId(), ansiIndex_, duration.count());
			OutputDebugStringW(info);
		}
	};
	AnsiDuration duration(ansiIndex);
#endif

	CEAnsi* pObj = nullptr;
	CEStr cpCvtBuffer;

	if (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput)
	{
		bIsAnsi = HandleKeeper::IsAnsiCapable(hConsoleOutput, &bIsConOut);

		if (ghAnsiLogFile && bIsConOut)
		{
			CEAnsi::WriteAnsiLogW(static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite);
		}
	}

	if (lpBuffer && nNumberOfCharsToWrite && hConsoleOutput && bIsAnsi)
	{
		// if that was API call of WriteConsoleW
		if (!bInternal && gCpConv.nFromCP && gCpConv.nToCP)
		{
			// Convert from unicode to MBCS
			CEStrA pszTemp;
			int iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);
			if ((iMbcsLen > 0) && ((pszTemp.GetBuffer(iMbcsLen)) != nullptr))
			{
				BOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped
				iMbcsLen = WideCharToMultiByte(gCpConv.nFromCP, 0, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, pszTemp.data(), iMbcsLen, nullptr, &bFailed);
				if ((iMbcsLen > 0) && !bFailed)
				{
					int iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, nullptr, 0);
					if (iWideLen > 0)
					{
						wchar_t* ptrBuf = cpCvtBuffer.GetBuffer(iWideLen);
						if (ptrBuf)
						{
							iWideLen = MultiByteToWideChar(gCpConv.nToCP, 0, pszTemp, iMbcsLen, ptrBuf, iWideLen);
							if (iWideLen > 0)
							{
								lpBuffer = ptrBuf;
								nNumberOfCharsToWrite = iWideLen;
							}
						}
					}
				}
			}
		}

		pObj = CEAnsi::Object();
		if (pObj)
		{
			if (pObj->gnPrevAnsiPart || gDisplayOpt.WrapWasSet)
			{
				// Если остался "хвост" от предущей записи - сразу, без проверок
				lbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);
				goto ansidone;
			}
			else
			{
				_ASSERTEX(ESC==27 && BEL==7 && DSC==0x90);
				const wchar_t* pch = static_cast<const wchar_t*>(lpBuffer);
				for (size_t i = nNumberOfCharsToWrite; i--; pch++)
				{
					// Если в выводимой строке встречается "Ansi ESC Code" - выводим сами
					TODO("Non-CSI codes, like as BEL, BS, CR, LF, FF, TAB, VT, SO, SI");
					if (*pch == ESC /*|| *pch == BEL*/ /*|| *pch == ENQ*/)
					{
						lbRc = pObj->WriteAnsiCodes(F(WriteConsoleW), hConsoleOutput, static_cast<const wchar_t*>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten);
						goto ansidone;
					}
				}
			}
		}
	}

	if (!bIsAnsi || ((pObj = CEAnsi::Object()) == nullptr))
	{
		lbRc = F(WriteConsoleW)(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
	}
	else
	{
		lbRc = pObj->WriteText(F(WriteConsoleW), hConsoleOutput, static_cast<LPCWSTR>(lpBuffer), nNumberOfCharsToWrite, lpNumberOfCharsWritten, TRUE);
		//wrt.Flags = ewtf_Current|ewtf_Commit;
		//wrt.Buffer = (const wchar_t*)lpBuffer;
		//wrt.NumberOfCharsToWrite = nNumberOfCharsToWrite;
		//wrt.Private = F(WriteConsoleW);
		//lbRc = ExtWriteText(&wrt);
		//if (lbRc)
		//{
		//	if (lpNumberOfCharsWritten)
		//		*lpNumberOfCharsWritten = wrt.NumberOfCharsWritten;
		//	if (wrt.ScrolledRowsUp > 0)
		//		gDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)wrt.ScrolledRowsUp));
		//}
	}
	goto wrap;

ansidone:
	{
		ExtCommitParm cmt = {sizeof(cmt), hConsoleOutput};
		ExtCommit(&cmt);
	}
wrap:
	return lbRc;
}
