HANDLE CEAnsi::XTermBufferConEmuAlternative()
{
	CONSOLE_SCREEN_BUFFER_INFO csbi1 = {}, csbi2 = {};
	HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
	// ReSharper disable once CppLocalVariableMayBeConst
	HANDLE hErr = GetStdHandle(STD_ERROR_HANDLE);
	ghStdOut.SetHandle(hOut, MConHandle::StdMode::Output);
	ghStdErr.SetHandle(hErr, MConHandle::StdMode::Output);
	if (GetConsoleScreenBufferInfoCached(hOut, &csbi1, TRUE))
	{
		// -- Turn on "alternative" buffer even if not scrolling exist now
		//if (csbi.dwSize.Y > (csbi.srWindow.Bottom - csbi.srWindow.Top + 1))
		{
			CESERVER_REQ *pIn = nullptr, *pOut = nullptr;
			pIn = ExecuteNewCmd(CECMD_ALTBUFFER,sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_ALTBUFFER));
			if (pIn)
			{
				pIn->AltBuf.AbFlags = abf_BufferOff | abf_SaveContents;
				if (isConnectorStarted())
					pIn->AltBuf.AbFlags |= abf_Connector;
				// support "virtual" dynamic console buffer height
				if (CESERVER_CONSOLE_APP_MAPPING* pAppMap = gpAppMap ? gpAppMap->Ptr() : nullptr)
					pIn->AltBuf.BufferHeight = std::max(static_cast<SHORT>(pAppMap->nLastConsoleRow), csbi1.srWindow.Bottom);
				else
					pIn->AltBuf.BufferHeight = csbi1.srWindow.Bottom;
				pOut = ExecuteSrvCmd(gnServerPID, pIn, ghConWnd);
				if (pOut)
				{
					if (!IsWin7Eql())
					{
						ghConOut.Close();
						// ReSharper disable once CppLocalVariableMayBeConst
						HANDLE hNewOut = ghConOut.GetHandle();
						if (hNewOut && hNewOut != INVALID_HANDLE_VALUE)
						{
							hOut = hNewOut;
							SetStdHandle(STD_OUTPUT_HANDLE, hNewOut);
							SetStdHandle(STD_ERROR_HANDLE, hNewOut);
						}
					}

					// Ensure we have fresh information (size was changed)
					GetConsoleScreenBufferInfoCached(hOut, &csbi2, TRUE);

					// Clear current screen contents, don't move cursor position
					const DWORD nChars = csbi2.dwSize.X * csbi2.dwSize.Y;
					ExtFillOutputParm fill = {sizeof(fill), efof_Current|efof_Attribute|efof_Character,
						hOut, {}, L' ', {}, static_cast<DWORD>(nChars) };
					ExtFillOutput(&fill);

					TODO("BufferWidth");
					if (!(gXTermAltBuffer.Flags & xtb_AltBuffer))
					{
						// Backscroll length
						gXTermAltBuffer.BufferSize = (csbi1.dwSize.Y > (csbi1.srWindow.Bottom - csbi1.srWindow.Top + 1))
							? csbi1.dwSize.Y : 0;
						gXTermAltBuffer.Flags = xtb_AltBuffer;
						// Stored cursor pos
						if (gDisplayCursor.bCursorPosStored)
						{
							gXTermAltBuffer.CursorPos = gDisplayCursor.StoredCursorPos;
							gXTermAltBuffer.Flags |= xtb_StoredCursor;
						}
						// Stored scroll region
						if (gDisplayOpt.ScrollRegion)
						{
							gXTermAltBuffer.ScrollStart = gDisplayOpt.ScrollStart;
							gXTermAltBuffer.ScrollEnd = gDisplayOpt.ScrollEnd;
							gXTermAltBuffer.Flags |= xtb_StoredScrollRegion;
						}
					}
				}
				ExecuteFreeResult(pIn);
				ExecuteFreeResult(pOut);
			}
		}
	}
	return hOut;
}
