bool SrvAnsiImpl::IsAnsiExecAllowed(LPCWSTR asCmd)
{
	// Invalid command or macro?
	if (!asCmd || !*asCmd)
		return false;

	// We need to check settings
	CESERVER_CONSOLE_MAPPING_HDR* pMap = m_Owner->GetConMap();
	if (!pMap)
		return false;

	if ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecAny) != 0)
	{
		// Allowed in any process
	}
	else if ((pMap->Flags & ConEmu::ConsoleFlags::AnsiExecCmd) != 0)
	{
		// #condata Allowed in Cmd.exe only
		// if (!gbIsCmdProcess)
		return false;
	}
	else
	{
		// Disallowed everywhere
		return false;
	}

	// Now we need to ask GUI, if the command (asCmd) is allowed
	bool bAllowed = false;
	ssize_t cchLen = wcslen(asCmd) + 1;
	CESERVER_REQ* pOut = nullptr;
	CESERVER_REQ* pIn = ExecuteNewCmd(CECMD_ALLOWANSIEXEC, sizeof(CESERVER_REQ_HDR)+sizeof(wchar_t)*cchLen);

	if (pIn)
	{
		_ASSERTE(sizeof(pIn->wData[0])==sizeof(*asCmd));
		memmove(pIn->wData, asCmd, cchLen*sizeof(pIn->wData[0]));

		pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);
		if (pOut && (pOut->DataSize() == sizeof(pOut->dwData[0])))
		{
			bAllowed = (pOut->dwData[0] == TRUE);
		}
	}

	ExecuteFreeResult(pOut);
	ExecuteFreeResult(pIn);

	return bAllowed;
}
