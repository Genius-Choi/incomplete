bool CEAnsi::GetFeatures(ConEmu::ConsoleFlags& features)
{
	struct FeaturesCache
	{
		ConEmu::ConsoleFlags features;
		BOOL result;
	};
	static FeaturesCache featuresCache{};
	// Don't use system_clock here, it fails in some cases during DllLoad (segment is not ready somehow)
	static DWORD nLastCheck{ 0 };

	if (!nLastCheck || (GetTickCount() - nLastCheck) > ANSI_MAP_CHECK_TIMEOUT)
	{
		CESERVER_CONSOLE_MAPPING_HDR* pMap = GetConMap();
		//	(CESERVER_CONSOLE_MAPPING_HDR*)malloc(sizeof(CESERVER_CONSOLE_MAPPING_HDR));
		if (pMap)
		{
			// bAnsiAllowed = ((pMap != nullptr) && (pMap->Flags & ConEmu::ConsoleFlags::ProcessAnsi));
			// bSuppressBells = ((pMap != nullptr) && (pMap->Flags & ConEmu::ConsoleFlags::SuppressBells));
			// Well, it's not so atomic as could be, but here we care only on proper features value
			// and we can't use std::atomic here because function is called during DllLoad
			InterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.features), static_cast<LONG>(pMap->Flags));
			InterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.result), static_cast<LONG>(true));
		}
		else
		{
			InterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.features), 0);
			InterlockedExchange(reinterpret_cast<LONG*>(&featuresCache.result), 0);
		}
		nLastCheck = GetTickCount();
	}

	features = static_cast<ConEmu::ConsoleFlags>(InterlockedCompareExchange(reinterpret_cast<LONG*>(&featuresCache.features), 0, 0));
	const bool result = InterlockedCompareExchange(reinterpret_cast<LONG*>(&featuresCache.result), 0, 0);
	return result;
}
