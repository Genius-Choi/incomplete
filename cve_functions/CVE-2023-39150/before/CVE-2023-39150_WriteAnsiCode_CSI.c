void SrvAnsiImpl::WriteAnsiCode_CSI(AnsiEscCode& Code)
{
	/*

CSI ? P m h			DEC Private Mode Set (DECSET)
	P s = 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)
	P s = 1 0 4 7 → Use Alternate Screen Buffer (unless disabled by the titeInhibit resource)
	P s = 1 0 4 8 → Save cursor as in DECSC (unless disabled by the titeInhibit resource)
	P s = 1 0 4 9 → Save cursor as in DECSC and use Alternate Screen Buffer, clearing it first (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.

CSI ? P m l			DEC Private Mode Reset (DECRST)
	P s = 4 7 → Use Normal Screen Buffer
	P s = 1 0 4 7 → Use Normal Screen Buffer, clearing screen first if in the Alternate Screen (unless disabled by the titeInhibit resource)
	P s = 1 0 4 8 → Restore cursor as in DECRC (unless disabled by the titeInhibit resource)
	P s = 1 0 4 9 → Use Normal Screen Buffer and restore cursor as in DECRC (unless disabled by the titeInhibit resource). This combines the effects of the 1 0 4 7 and 1 0 4 8 modes. Use this with terminfo-based applications rather than the 4 7 mode.


CSI P s @			Insert P s (Blank) Character(s) (default = 1) (ICH)

	*/
	switch (Code.Action) // case sensitive
	{
	case L's':
		// Save cursor position (can not be nested)
		XTermSaveRestoreCursor(true);
		break;

	case L'u':
		// Restore cursor position
		XTermSaveRestoreCursor(false);
		break;

	case L'H': // Set cursor position (1-based)
	case L'f': // Same as 'H'
	case L'A': // Cursor up by N rows
	case L'B': // Cursor down by N rows
	case L'C': // Cursor right by N cols
	case L'D': // Cursor left by N cols
	case L'E': // Moves cursor to beginning of the line n (default 1) lines down.
	case L'F': // Moves cursor to beginning of the line n (default 1) lines up.
	case L'G': // Moves the cursor to column n.
	case L'd': // Moves the cursor to line n.
		// Change cursor position
		{
			//if (gbIsVimProcess)
			//	gbIsVimAnsi = true;

			struct PointXY {int X,Y;};
			const auto& workSize = m_Table->GetSize();
			const struct {int left, top, right, bottom;} workRgn = {0, 0, (int)workSize.x - 1, workSize.y - 1};
			_ASSERTEX(workRgn.left <= workRgn.right && workRgn.top <= workRgn.bottom);
			const auto& clipRgn = m_Table->GetScrollRegion();
			const auto cur = PointXY{(int)m_Table->GetCursor().x, m_Table->GetCursor().y};
			PointXY crNewPos = cur;
			enum class Direction { kAbsolute, kCompatible, kRelative };

			auto set_y = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)
			{
				const int kLegacyY = 9999;
				if (direction == Direction::kCompatible && value >= std::min(kLegacyY, workRgn.bottom))
					// #XTERM_256 Allow to put cursor into the legacy true-color area
					crNewPos.Y = workRgn.bottom;
				else if (direction == Direction::kAbsolute || direction == Direction::kCompatible)
					crNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, value));
				else if (value < 0 && cur.Y >= (int)clipRgn.Top)
					crNewPos.Y = std::max<int>(clipRgn.Top, std::min(workRgn.bottom, cur.Y + value));
				else if (value > 0 && cur.Y <= (int)clipRgn.Bottom)
					crNewPos.Y = std::max(workRgn.top, std::min<int>(clipRgn.Bottom, cur.Y + value));
				else
					crNewPos.Y = std::max(workRgn.top, std::min(workRgn.bottom, cur.Y + value));
			};
			auto set_x = [&crNewPos, &workRgn, &clipRgn, &cur](Direction direction, int value)
			{
				if (direction == Direction::kAbsolute || direction == Direction::kCompatible)
					crNewPos.X = std::max(workRgn.left, std::min(workRgn.right, value));
				else
					crNewPos.X = std::max(workRgn.left, std::min(workRgn.right, cur.X + value));
			};

			switch (Code.Action)
			{
			case L'H':
				// Set cursor position (ANSI values are 1-based)
				set_y(Direction::kCompatible, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);
				set_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);
				break;
			case L'f':
				// Set cursor position (ANSI values are 1-based)
				set_y(Direction::kAbsolute, (Code.ArgC > 0 && Code.ArgV[0]) ? (Code.ArgV[0] - 1) : 0);
				set_x(Direction::kAbsolute, (Code.ArgC > 1 && Code.ArgV[1]) ? (Code.ArgV[1] - 1) : 0);
				break;
			case L'A':
				// Cursor up by N rows
				set_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));
				break;
			case L'B':
				// Cursor down by N rows
				set_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));
				break;
			case L'C':
				// Cursor right by N cols
				set_x(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));
				break;
			case L'D':
				// Cursor left by N cols
				set_x(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));
				break;
			case L'E':
				// Moves cursor to beginning of the line n (default 1) lines down.
				set_y(Direction::kRelative, +((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));
				set_x(Direction::kAbsolute, 0);
				break;
			case L'F':
				// Moves cursor to beginning of the line n (default 1) lines up.
				set_y(Direction::kRelative, -((Code.ArgC > 0 && Code.ArgV[0]) ? Code.ArgV[0] : 1));
				set_x(Direction::kAbsolute, 0);
				break;
			case L'G':
				// Moves the cursor to column n.
				set_x(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);
				break;
			case L'd':
				// Moves the cursor to line n (almost the same as 'H', but leave X unchanged).
				set_y(Direction::kAbsolute, (Code.ArgC > 0) ? (Code.ArgV[0] - 1) : 0);
				break;
			#ifdef _DEBUG
			default:
				_ASSERTEX(FALSE && "Missed (sub)case value!");
			#endif
			}

			// Goto
			m_Table->SetCursor({unsigned(crNewPos.X), crNewPos.Y});

		} // case 'H', 'f', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'd'
		break;

	case L'J': // Clears part of the screen
		// Clears the screen and moves the cursor to the home position (line 0, column 0).
		{
			m_Owner->ApplyDisplayParm();

			int nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;
			condata::Coord cur_pos = {};
			int from_row = -1, to_row = 0;

			switch (nCmd)
			{
			case 0:
				// clear from cursor to end of screen
				cur_pos = m_Table->GetCursor();
				from_row = cur_pos.y;
				to_row = m_Table->GetSize().y - 1;
				break;
			case 1:
				// clear from cursor to beginning of the screen
				cur_pos = m_Table->GetCursor();
				from_row = 0;
				to_row = cur_pos.y;
				break;
			case 2:
				// clear entire screen
				m_Table->ClearWorkspace();
				break;
			case 3:
				// xterm: clear scrollback buffer entirely
				m_Table->ClearBackscroll();
				break;
			default:
				DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
			}

			// Clears only part of working area
			if (from_row >= 0)
			{
				_ASSERTE(to_row >= from_row);
				const auto attr = m_Table->GetAttr();
				for (int row = to_row; row >= from_row; --row)
				{
					if (row != cur_pos.y)
						m_Table->GetRow((unsigned)row)->Reset(attr);
				}

				auto row = m_Table->CurrentRow();
				switch (nCmd)
				{
				case 0:
					// clear from cursor to end of screen
					row->Delete(cur_pos.x, row->GetLength() - cur_pos.x);
					break;
				case 1:
					// clear from cursor to beginning of the screen
					row->Delete(0, cur_pos.x + 1);
					break;
				}
			}

		} // case L'J':
		break;

	case L'b': // repeat output of the last written char N times
		if (!Code.PvtLen)
		{
			int repeat = (Code.ArgC > 0) ? Code.ArgV[0] : 1;
			if (m_Owner->m_LastWrittenChar && repeat > 0)
			{
				CEStr buffer;
				if (wchar_t* ptr = buffer.GetBuffer(repeat))
				{
					for (int i = 0; i < repeat; ++i)
						ptr[i] = m_Owner->m_LastWrittenChar;
					WriteText(ptr, repeat, nullptr);
				}
			}
		}
		else
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		break; // case L'b'

	case L'K': // Erases part of the line
		{
			m_Owner->ApplyDisplayParm();

			int nCmd = (Code.ArgC > 0) ? Code.ArgV[0] : 0;
			const auto cur = m_Table->GetCursor();
			auto row = m_Table->CurrentRow();

			switch (nCmd)
			{
			case 0: // clear from cursor to the end of the line (including char under the cursor)
				row->Delete(cur.x, row->GetLength() - cur.x);
				break;
			case 1: // clear from cursor to beginning of the line (including char under the cursor)
				row->Write(0, m_Table->GetAttr(), L' ', cur.x + 1);
				break;
			case 2: // clear entire line
				*row = condata::Row(m_Table->GetAttr());
				break;
			default:
				DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
			}
		}
		break; // case L'K':

	case L'r':
		//\027[Pt;Pbr
		//
		// Pt is the number of the top line of the scrolling region;
		// Pb is the number of the bottom line of the scrolling region
		//  and must be greater than Pt.
		// (The default for Pt is line 1, the default for Pb is the end
		// of the screen)
		//
		// Values are 1-based
		if ((Code.ArgC >= 2) && (Code.ArgV[0] >= 0) && (Code.ArgV[1] >= Code.ArgV[0]))
			SetScrollRegion(true, Code.ArgV[0], Code.ArgV[1]);
		else
			SetScrollRegion(false);
		break; // L'r'

	case L'L':
		// Insert P s Line(s) (default = 1) (IL).
		m_Owner->ApplyDisplayParm();
		m_Table->InsertRow((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);
		break;

	case L'M':
		// Delete N Line(s) (default = 1) (DL).
		// This is actually "Scroll UP N line(s) inside defined scrolling region"
		m_Owner->ApplyDisplayParm();
		m_Table->DeleteRow((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);
		break;

	case L'@':
		// Insert P s (Blank) Character(s) (default = 1) (ICH).
		m_Owner->ApplyDisplayParm();
		m_Table->InsertCell((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);
		break;
	case L'P':
		// Delete P s Character(s) (default = 1) (DCH).
		m_Owner->ApplyDisplayParm();
		m_Table->DeleteCell((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);
		break;

	case L'S':
		// Scroll whole page up by n (default 1) lines. New lines are added at the bottom.
		m_Owner->ApplyDisplayParm();
		m_Table->Scroll((Code.ArgC > 0 && Code.ArgV[0] > 0) ? -Code.ArgV[0] : -1);
		break;

	case L'T':
		// Scroll whole page down by n (default 1) lines. New lines are added at the top.
		m_Owner->ApplyDisplayParm();
		m_Table->Scroll((Code.ArgC > 0 && Code.ArgV[0] > 0) ? Code.ArgV[0] : 1);
		break;

	case L'h':
	case L'l':
		// Set/ReSet Mode
		if (Code.ArgC > 0)
		{
			//ESC [ 3 h
			//       DECCRM (default off): Display control chars.

			//ESC [ 4 h
			//       DECIM (default off): Set insert mode.

			//ESC [ 20 h
			//       LF/NL (default off): Automatically follow echo of LF, VT or FF with CR.

			//ESC [ ? 1 h
			//	  DECCKM (default off): When set, the cursor keys send an ESC O prefix,
			//	  rather than ESC [.

			//ESC [ ? 3 h
			//	  DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver
			//	  sources note that this alone does not suffice; some user-mode utility
			//	  such as resizecons(8) has to change the hardware registers on the
			//	  console video card.

			//ESC [ ? 5 h
			//	  DECSCNM (default off): Set reverse-video mode.

			//ESC [ ? 6 h
			//	  DECOM (default off): When set, cursor addressing is relative to the
			//	  upper left corner of the scrolling region.


			//ESC [ ? 8 h
			//	  DECARM (default on): Set keyboard autorepeat on.

			//ESC [ ? 9 h
			//	  X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to
			//	  0) -- see below.

			//ESC [ ? 1000 h
			//	  X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to
			//	  0) -- see below.

			//ESC [ ? 7711 h
			//    mimic mintty code, same as "ESC ] 9 ; 12 ST"

			switch (Code.ArgV[0])
			{
			case 1:
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
				{
					m_Owner->gDisplayCursor.CursorKeysApp = (Code.Action == L'h');

					#if 0
					if (gbIsVimProcess)
					{
						TODO("Need to find proper way for activation alternative buffer from ViM?");
						if (Code.Action == L'h')
						{
							StartVimTerm(false);
						}
						else
						{
							StopVimTerm();
						}
					}
					#endif

					m_Owner->ChangeTermMode(tmc_AppCursorKeys, (Code.Action == L'h'));
				}
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 3:
				m_Owner->gDisplayOpt.ShowRawAnsi = (Code.Action == L'h');
				break;
			case 7:
				//ESC [ ? 7 h
				//	  DECAWM (default off): Set autowrap on.  In this mode, a graphic
				//	  character emitted after column 80 (or column 132 of DECCOLM is on)
				//	  forces a wrap to the beginning of the following line first.
				//ESC [ = 7 h
				//    Enables line wrapping
				//ESC [ 7 ; _col_ h
				//    Our extension. _col_ - wrap at column (1-based), default = 80
				if ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))
				{
					m_Owner->gDisplayOpt.WrapAt = ((Code.ArgC > 1) && (Code.ArgV[1] > 0)) ? Code.ArgV[1] : 80;
				}
				break;
			case 20:
				if (Code.PvtLen == 0)
				{
					m_Owner->gDisplayOpt.AutoLfNl = (Code.Action == L'h');
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
				}
				else
				{
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				}
				break;
			//ESC [ ? 12 h
			//	  Start Blinking Cursor (att610)
			case 12:
			//ESC [ ? 25 h
			//	  DECTECM (default on): Make cursor visible.
			case 25:
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
				{
					bool unknown = false;
					for (int i = 0; i < Code.ArgC; ++i)
					{
						if (Code.ArgV[i] == 25)
							m_Owner->SetCursorVisibility((Code.Action == L'h'));
						else
							unknown = true;
					}
					if (unknown)
					{
						DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
					}
				}
				else
				{
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				}
				break;
			case 4:
				if (Code.PvtLen == 0)
				{
					/* h=Insert Mode (IRM), l=Replace Mode (IRM) */
					// Nano posts the `ESC [ 4 l` on start, but do not post `ESC [ 4 h` on exit, that is strange...
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now
				}
				else if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
				{
					/* h=Smooth (slow) scroll, l=Jump (fast) scroll */
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now
				}
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 9:    /* X10_MOUSE */
			case 1000: /* VT200_MOUSE */
			case 1002: /* BTN_EVENT_MOUSE */
			case 1003: /* ANY_EVENT_MOUSE */
			case 1004: /* FOCUS_EVENT_MOUSE */
			case 1005: /* Xterm's UTF8 encoding for mouse positions */
			case 1006: /* Xterm's CSI-style mouse encoding */
			case 1015: /* Urxvt's CSI-style mouse encoding */
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
				{
					static DWORD LastMode = 0;
					TermMouseMode ModeMask = (Code.ArgV[0] == 9) ? tmm_X10
						: (Code.ArgV[0] == 1000) ? tmm_VT200
						: (Code.ArgV[0] == 1002) ? tmm_BTN
						: (Code.ArgV[0] == 1003) ? tmm_ANY
						: (Code.ArgV[0] == 1004) ? tmm_FOCUS
						: (Code.ArgV[0] == 1005) ? tmm_UTF8
						: (Code.ArgV[0] == 1006) ? tmm_XTERM
						: (Code.ArgV[0] == 1015) ? tmm_URXVT
						: tmm_None;
					DWORD Mode = (Code.Action == L'h')
						? (LastMode | ModeMask)
						: (LastMode & ~ModeMask);
					LastMode = Mode;
					m_Owner->ChangeTermMode(tmc_MouseMode, Mode);
				}
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 7786: /* 'V': Mousewheel reporting */
			case 7787: /* 'W': Application mousewheel mode */
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored); // ignored for now
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 1034:
				// Interpret "meta" key, sets eighth bit. (enables/disables the eightBitInput resource).
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 47:   /* alternate screen */
			case 1047: /* alternate screen */
			case 1049: /* cursor & alternate screen */
				// xmux/screen: Alternate screen
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
				{
					m_Owner->ApplyDisplayParm();

					// \e[?1049h: save cursor pos
					if ((Code.ArgV[0] == 1049) && (Code.Action == L'h'))
						XTermSaveRestoreCursor(true);
					// h: switch to alternative buffer without backscroll
					// l: restore saved scrollback buffer
					XTermAltBuffer((Code.Action == L'h'));
					// \e[?1049l - restore cursor pos
					if ((Code.ArgV[0] == 1049) && (Code.Action == L'l'))
						XTermSaveRestoreCursor(false);
				}
				else
				{
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				}
				break;
			case 1048: /* save/restore cursor */
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
					XTermSaveRestoreCursor((Code.Action == L'h'));
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 2004: /* bracketed paste */
				/* All "pasted" text will be wrapped in `\e[200~ ... \e[201~` */
				if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
					m_Owner->ChangeTermMode(tmc_BracketedPaste, (Code.Action == L'h'));
				else
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				break;
			case 7711:
				if ((Code.Action == L'h') && (Code.PvtLen == 1) && (Code.Pvt[0] == L'?'))
				{
					//ESC [ ? 7711 h
					//    mimic mintty code, same as "ESC ] 9 ; 12 ST"
					m_Table->PromptPosStore();
				}
				else
				{
					DumpUnknownEscape(Code.pszEscStart, Code.nTotalLen);
				}
				break;
			default:
				DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
			}

			//switch (Code.ArgV[0])
			//{
			//case 0: case 1:
			//	// 40x25
			//	if ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))
			//	{
			//		m_Owner->gDisplayOpt.WrapAt = 40;
			//	}
			//	break;
			//case 2: case 3:
			//	// 80x25
			//	if ((m_Owner->gDisplayOpt.WrapWasSet = (Code.Action == L'h')))
			//	{
			//		m_Owner->gDisplayOpt.WrapAt = 80;
			//	}
			//	break;
			//case 7:
			//	{
			//		DWORD Mode = 0;
			//		GetConsoleMode(&Mode);
			//		if (Code.Action == L'h')
			//			Mode |= ENABLE_WRAP_AT_EOL_OUTPUT;
			//		else
			//			Mode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;
			//		SetConsoleMode(Mode);
			//	} // enable/disable line wrapping
			//	break;
			//}
		}
		else
		{
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		}
		break; // case L'h': case L'l':

	case L'n':
		if (Code.ArgC > 0)
		{
			switch (*Code.ArgV)
			{
			case 5:
				//ESC [ 5 n
				//      Device status report (DSR): Answer is ESC [ 0 n (Terminal OK).
				//
				ReportString(L"\x1B[0n");
				break;
			case 6:
				//ESC [ 6 n
				//      Cursor position report (CPR): Answer is ESC [ y ; x R, where x,y is the
				//      cursor location.
				ReportCursorPosition();
				break;
			default:
				DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
			}
		}
		else
		{
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		}
		break;

	case L'm':
		if (Code.PvtLen > 0)
		{
			DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
		}
		// Set display mode (colors, fonts, etc.)
		else if (!Code.ArgC)
		{
			m_Owner->ReSetDisplayParm(TRUE, FALSE);
		}
		else
		{
			for (int i = 0; i < Code.ArgC; i++)
			{
				switch (Code.ArgV[i])
				{
				case 0:
					m_Owner->ReSetDisplayParm(TRUE, FALSE);
					break;
				case 1:
					// Bold
					m_Owner->gDisplayParm.setBrightOrBold(TRUE);
					break;
				case 2:
					// Faint, decreased intensity (ISO 6429)
				case 22:
					// Normal (neither bold nor faint).
					m_Owner->gDisplayParm.setBrightOrBold(FALSE);
					break;
				case 3:
					// Italic
					m_Owner->gDisplayParm.setItalic(TRUE);
					break;
				case 23:
					// Not italic
					m_Owner->gDisplayParm.setItalic(FALSE);
					break;
				case 5: // #TODO ANSI Slow Blink (less than 150 per minute)
				case 6: // #TODO ANSI Rapid Blink (150+ per minute)
				case 25: // #TODO ANSI Blink Off
					DumpKnownEscape(Code.pszEscStart,Code.nTotalLen,SrvAnsi::de_Ignored);
					break;
				case 4: // Underlined
					m_Owner->gDisplayParm.setUnderline(TRUE);
					break;
				case 24:
					// Not underlined
					m_Owner->gDisplayParm.setUnderline(FALSE);
					break;
				case 7:
					// Reverse video
					m_Owner->gDisplayParm.setInverse(TRUE);
					break;
				case 27:
					// Positive (not inverse)
					m_Owner->gDisplayParm.setInverse(FALSE);
					break;
				case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
					m_Owner->gDisplayParm.setTextColor(Code.ArgV[i] - 30);
					m_Owner->gDisplayParm.setBrightFore(FALSE);
					m_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);
					break;
				case 38:
					// xterm-256 colors
					// ESC [ 38 ; 5 ; I m -- set foreground to I (0..255) color from xterm palette
					if (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))
					{
						m_Owner->gDisplayParm.setTextColor(Code.ArgV[i+2] & 0xFF);
						m_Owner->gDisplayParm.setText256(SrvAnsi::clr8b);
						i += 2;
					}
					// xterm-256 colors
					// ESC [ 38 ; 2 ; R ; G ; B m -- set foreground to RGB(R,G,B) 24-bit color
					else if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))
					{
						m_Owner->gDisplayParm.setTextColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));
						m_Owner->gDisplayParm.setText256(SrvAnsi::clr24b);
						i += 4;
					}
					break;
				case 39:
					// Reset
					m_Owner->gDisplayParm.setTextColor(CONFORECOLOR(SrvAnsi::GetDefaultAnsiAttr()));
					m_Owner->gDisplayParm.setBrightFore(FALSE);
					m_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);
					break;
				case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
					m_Owner->gDisplayParm.setBackColor(Code.ArgV[i] - 40);
					m_Owner->gDisplayParm.setBrightBack(FALSE);
					m_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);
					break;
				case 48:
					// xterm-256 colors
					// ESC [ 48 ; 5 ; I m -- set background to I (0..255) color from xterm palette
					if (((i+2) < Code.ArgC) && (Code.ArgV[i+1] == 5))
					{
						m_Owner->gDisplayParm.setBackColor(Code.ArgV[i+2] & 0xFF);
						m_Owner->gDisplayParm.setBack256(SrvAnsi::clr8b);
						i += 2;
					}
					// xterm-256 colors
					// ESC [ 48 ; 2 ; R ; G ; B m -- set background to RGB(R,G,B) 24-bit color
					else if (((i+4) < Code.ArgC) && (Code.ArgV[i+1] == 2))
					{
						m_Owner->gDisplayParm.setBackColor(RGB((Code.ArgV[i+2] & 0xFF),(Code.ArgV[i+3] & 0xFF),(Code.ArgV[i+4] & 0xFF)));
						m_Owner->gDisplayParm.setBack256(SrvAnsi::clr24b);
						i += 4;
					}
					break;
				case 49:
					// Reset
					m_Owner->gDisplayParm.setBackColor(CONBACKCOLOR(SrvAnsi::GetDefaultAnsiAttr()));
					m_Owner->gDisplayParm.setBrightBack(FALSE);
					m_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);
					break;
				case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:
					m_Owner->gDisplayParm.setTextColor((Code.ArgV[i] - 90) | 0x8);
					m_Owner->gDisplayParm.setText256(SrvAnsi::clr4b);
					m_Owner->gDisplayParm.setBrightFore(TRUE);
					break;
				case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107:
					m_Owner->gDisplayParm.setBackColor((Code.ArgV[i] - 100) | 0x8);
					m_Owner->gDisplayParm.setBack256(SrvAnsi::clr4b);
					m_Owner->gDisplayParm.setBrightBack(TRUE);
					break;
				case 10:
					// Something strange and unknown... (received from ssh)
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
					break;
				case 312:
				case 315:
				case 414:
				case 3130:
					// Something strange and unknown... (received from vim on WSL)
					DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
					break;
				default:
					DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
				}
			}
		}
		break; // "[...m"

	case L'p':
		if (Code.ArgC == 0 && Code.PvtLen == 1 && Code.Pvt[0] == L'!')
		{
			FullReset();
		}
		else
		{
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		}
		break; // "[!p"

	case L'q':
		if ((Code.PvtLen == 1) && (Code.Pvt[0] == L' '))
		{
			/*
			CSI Ps SP q
				Set cursor style (DECSCUSR, VT520).
					Ps = 0  -> ConEmu's default.
					Ps = 1  -> blinking block.
					Ps = 2  -> steady block.
					Ps = 3  -> blinking underline.
					Ps = 4  -> steady underline.
					Ps = 5  -> blinking bar (xterm).
					Ps = 6  -> steady bar (xterm).
			*/
			unsigned nStyle = ((Code.ArgC == 0) || (Code.ArgV[0] < 0) || (Code.ArgV[0] > 6))
				? 0 : Code.ArgV[0];
			m_Owner->SetCursorShape(nStyle);
		}
		else
		{
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		}
		break; // "[...q"

	case L't':
		if (Code.ArgC > 0 && Code.ArgC <= 3)
		{
			for (int i = 0; i < Code.ArgC; i++)
			{
				switch (Code.ArgV[i])
				{
				case 8:
					// `ESC [ 8 ; height ; width t` --> Resize the text area to [height;width] in characters.
					{
						int height = -1, width = -1;
						if (i < Code.ArgC)
							height = Code.ArgV[++i];
						if (i < Code.ArgC)
							width = Code.ArgV[++i];
						DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
					}
					break;
				case 14:
					// `ESC [ 1 4 t` --> Reports terminal window size in pixels as `CSI 4 ; height ; width t`.
					ReportTerminalPixelSize();
					break;
				case 18:
				case 19:
					// `ESC [ 1 8 t` --> Report the size of the text area in characters as `CSI 8 ; height ; width t`
					// `ESC [ 1 9 t` --> Report the size of the screen in characters as `CSI 9 ; height ; width t`
					ReportTerminalCharSize(Code.ArgV[i]);
					break;
				case 21:
					// `ESC [ 2 1 t` --> Report terminal window title as `OSC l title ST`
					ReportConsoleTitle();
					break;
				default:
					TODO("ANSI: xterm window manipulation");
					//Window manipulation (from dtterm, as well as extensions). These controls may be disabled using the allowWindowOps resource. Valid values for the first (and any additional parameters) are:
					// 1 --> De-iconify window.
					// 2 --> Iconify window.
					// 3 ; x ; y --> Move window to [x, y].
					// 4 ; height ; width --> Resize the xterm window to height and width in pixels.
					// 5 --> Raise the xterm window to the front of the stacking order.
					// 6 --> Lower the xterm window to the bottom of the stacking order.
					// 7 --> Refresh the xterm window.
					// 8 ; height ; width --> Resize the text area to [height;width] in characters.
					// 9 ; 0 --> Restore maximized window.
					// 9 ; 1 --> Maximize window (i.e., resize to screen size).
					// 1 1 --> Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t . If the xterm window is iconified, it returns CSI 2 t .
					// 1 3 --> Report xterm window position as CSI 3 ; x; y t
					// 1 4 --> Report xterm window in pixels as CSI 4 ; height ; width t
					// 2 0 --> Report xterm window�s icon label as OSC L label ST
					// >= 2 4 --> Resize to P s lines (DECSLPP)
					DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
				}
			}
		}
		else
		{
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		}
		break;

	case L'c':
		// echo -e "\e[>c"
		if ((Code.PvtLen == 1) && (Code.Pvt[0] == L'>')
			&& ((Code.ArgC < 1) || (Code.ArgV[0] == 0)))
		{
			// P s = 0 or omitted -> request the terminal's identification code.
			wchar_t szVerInfo[64];
			// this will be "ESC > 67 ; build ; 0 c"
			// 67 is ASCII code of 'C' (ConEmu, yeah)
			// Other terminals report examples: MinTTY -> 77, rxvt -> 82, screen -> 83
			// msprintf(szVerInfo, countof(szVerInfo), L"\x1B>%u;%u;0c", (int)'C', MVV_1*10000+MVV_2*100+MVV_3);
			// Emulate xterm version 136?
			wcscpy_c(szVerInfo, L"\x1B[>0;136;0c");
			ReportString(szVerInfo);
		}
		// echo -e "\e[c"
		else if ((Code.ArgC < 1) || (Code.ArgV[0] == 0))
		{
			// Report "VT100 with Advanced Video Option"
			ReportString(L"\x1B[?1;2c");
		}
		else
		{
			DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
		}
		break;

	case L'X':
		// CSI P s X:  Erase P s Character(s) (default = 1) (ECH)
		{
			m_Owner->ApplyDisplayParm();
			const auto cur = m_Table->GetCursor();
			auto row = m_Table->CurrentRow();
			const unsigned nCount = (Code.ArgC > 0) ? unsigned(Code.ArgV[0]) : 1;
			const unsigned nMax = row->GetLength();
			row->Write(cur.x, m_Table->GetAttr(), L' ', std::min(nCount, (nMax > cur.x) ? (nMax - cur.x) : 0));
		} // case L'X':
		break;

	default:
		DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
	} // switch (Code.Action)
}
