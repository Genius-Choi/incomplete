void CEAnsi::WriteAnsiLogA(LPCSTR lpBuffer, DWORD nChars)
{
	if (!ghAnsiLogFile || !lpBuffer || !nChars)
		return;

	ScopedObject(CLastErrorGuard);

	const UINT cp = GetCodePage();
	if (cp == CP_UTF8)
	{
		bool writeLineFeed = false;
		if (gbAnsiLogNewLine)
		{
			if ((lpBuffer[0] == '\n') || ((nChars > 1) && (lpBuffer[0] == '\r') && (lpBuffer[1] == '\n')))
			{
				gbAnsiLogNewLine = false;
			}
			else
			{
				writeLineFeed = true;
			}
		}

		WriteAnsiLogTime();
		if (writeLineFeed)
			WriteAnsiLogUtf8("\n", 1);
		WriteAnsiLogUtf8(lpBuffer, nChars);
	}
	else
	{
		// We don't check here for gbAnsiLogNewLine, because some codepages may even has different codes for CR+LF
		wchar_t sBuf[80 * 3];
		CEStr buffer;
		const int nNeed = MultiByteToWideChar(cp, 0, lpBuffer, nChars, nullptr, 0);
		if (nNeed < 1)
			return;
		wchar_t* pszBuf = (nNeed <= static_cast<int>(countof(sBuf))) ? sBuf : buffer.GetBuffer(nNeed);
		if (!pszBuf)
			return;
		const int nLen = MultiByteToWideChar(cp, 0, lpBuffer, nChars, pszBuf, nNeed);
		// Must be OK, but check it
		if (nLen > 0 && nLen <= nNeed)
		{
			WriteAnsiLogW(pszBuf, nLen);
		}
	}
}
