bool SrvAnsiImpl::OurWriteConsole(const wchar_t* lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)
{
	bool lbRc = false;

	// For debugger breakpoint
	m_Owner->FirstAnsiCall((const BYTE*)lpBuffer, nNumberOfCharsToWrite);
	// In debug builds: Write to debug console all console Output
	DumpKnownEscape((wchar_t*)lpBuffer, nNumberOfCharsToWrite, SrvAnsi::de_Normal);

	// Logging?
	if (lpBuffer && nNumberOfCharsToWrite && m_Owner->ghAnsiLogFile)
	{
		m_Owner->WriteAnsiLogW(lpBuffer, nNumberOfCharsToWrite);
	}

	CEStr CpCvt;

	if (lpBuffer && nNumberOfCharsToWrite)
	{
		// if that was API call of WriteConsoleW
		if (m_Owner->gCpConv.nFromCP && m_Owner->gCpConv.nToCP)
		{
			// Convert from Unicode to MBCS
			int iMBCSLen = WideCharToMultiByte(m_Owner->gCpConv.nFromCP, 0, (LPCWSTR)lpBuffer, nNumberOfCharsToWrite, nullptr, 0, nullptr, nullptr);
			if (iMBCSLen > 0)
			{
				CEStrA szTemp;
				if (char* pszTemp = szTemp.GetBuffer(iMBCSLen))
				{
					BOOL bFailed = FALSE; // Do not do conversion if some chars can't be mapped
					iMBCSLen = WideCharToMultiByte(m_Owner->gCpConv.nFromCP, 0, (LPCWSTR)lpBuffer, nNumberOfCharsToWrite, pszTemp, iMBCSLen, nullptr, &bFailed);
					if ((iMBCSLen > 0) && !bFailed)
					{
						int iWideLen = MultiByteToWideChar(m_Owner->gCpConv.nToCP, 0, pszTemp, iMBCSLen, nullptr, 0);
						if (iWideLen > 0)
						{
							if (wchar_t* ptrBuf = CpCvt.GetBuffer(iWideLen))
							{
								iWideLen = MultiByteToWideChar(m_Owner->gCpConv.nToCP, 0, pszTemp, iMBCSLen, ptrBuf, iWideLen);
								if (iWideLen > 0)
								{
									lpBuffer = ptrBuf;
									nNumberOfCharsToWrite = iWideLen;
								}
							}
						}
					}
				}
			}
		}
	}

	_ASSERTE(m_Owner->m_BellsCounter == 0);
	m_Owner->m_BellsCounter = 0;

	// The output
	lbRc = WriteAnsiCodes(lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten);

	// Bells counter?
	if (m_Owner->m_BellsCounter)
	{
		// User may disable flashing in ConEmu settings
		CESERVER_REQ *pIn = ExecuteNewCmd(CECMD_FLASHWINDOW, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_FLASHWINFO));
		if (pIn)
		{
			ExecutePrepareCmd(pIn, CECMD_FLASHWINDOW, sizeof(CESERVER_REQ_HDR)+sizeof(CESERVER_REQ_FLASHWINFO)); //-V119
			pIn->Flash.fType = eFlashBeep;
			pIn->Flash.hWnd = gState.realConWnd_;
			pIn->Flash.bInvert = FALSE;
			pIn->Flash.dwFlags = FLASHW_ALL;
			pIn->Flash.uCount = 1;
			pIn->Flash.dwTimeout = 0;
			auto pOut = ExecuteGuiCmd(gState.realConWnd_, pIn, gState.realConWnd_);
			if (pOut) ExecuteFreeResult(pOut);
			ExecuteFreeResult(pIn);
		}
		m_Owner->m_BellsCounter = 0;
	}
	return lbRc;
}
