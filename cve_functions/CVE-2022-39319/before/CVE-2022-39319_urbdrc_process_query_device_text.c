static UINT urbdrc_process_query_device_text(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,
                                             wStream* s, UINT32 MessageId, IUDEVMAN* udevman)
{
	UINT32 out_size;
	UINT32 TextType;
	UINT32 LocaleId;
	UINT32 InterfaceId;
	UINT8 bufferSize = 0xFF;
	UINT32 hr;
	wStream* out;
	BYTE DeviceDescription[0x100] = { 0 };

	if (!pdev || !callback || !s || !udevman)
		return ERROR_INVALID_PARAMETER;
	if (Stream_GetRemainingLength(s) < 8)
		return ERROR_INVALID_DATA;

	Stream_Read_UINT32(s, TextType);
	Stream_Read_UINT32(s, LocaleId);
	if (LocaleId > UINT16_MAX)
		return ERROR_INVALID_DATA;

	hr = pdev->control_query_device_text(pdev, TextType, (UINT16)LocaleId, &bufferSize,
	                                     DeviceDescription);
	InterfaceId = ((STREAM_ID_STUB << 30) | pdev->get_UsbDevice(pdev));
	out_size = 16 + bufferSize;

	if (bufferSize != 0)
		out_size += 2;

	out = Stream_New(NULL, out_size);

	if (!out)
		return ERROR_OUTOFMEMORY;

	Stream_Write_UINT32(out, InterfaceId);            /** interface */
	Stream_Write_UINT32(out, MessageId);              /** message id */
	Stream_Write_UINT32(out, bufferSize / 2);         /** cchDeviceDescription in WCHAR */
	Stream_Write(out, DeviceDescription, bufferSize); /* '\0' terminated unicode */
	Stream_Write_UINT32(out, hr);                     /** HResult */
	return stream_write_and_free(callback->plugin, callback->channel, out);
}
