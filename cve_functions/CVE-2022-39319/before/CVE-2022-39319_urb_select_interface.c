static UINT urb_select_interface(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,
                                 UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,
                                 int transferDir)
{
	MSUSB_CONFIG_DESCRIPTOR* MsConfig;
	MSUSB_INTERFACE_DESCRIPTOR* MsInterface;
	UINT32 out_size, InterfaceId, ConfigurationHandle;
	UINT32 OutputBufferSize;
	BYTE InterfaceNumber;
	wStream* out;
	UINT32 interface_size;
	URBDRC_PLUGIN* urbdrc;
	const BOOL noAck = (RequestField & 0x80000000U) != 0;
	const UINT32 RequestId = RequestField & 0x7FFFFFFF;

	if (!callback || !s || !udevman || !pdev)
		return ERROR_INVALID_PARAMETER;

	urbdrc = (URBDRC_PLUGIN*)callback->plugin;

	if (!urbdrc)
		return ERROR_INVALID_PARAMETER;

	if (transferDir == 0)
	{
		WLog_Print(urbdrc->log, WLOG_ERROR, "urb_select_interface: not support transfer out");
		return ERROR_INVALID_PARAMETER;
	}

	if (Stream_GetRemainingLength(s) < 4)
		return ERROR_INVALID_DATA;

	InterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));
	Stream_Read_UINT32(s, ConfigurationHandle);
	MsInterface = msusb_msinterface_read(s);

	if ((Stream_GetRemainingLength(s) < 4) || !MsInterface)
		return ERROR_INVALID_DATA;

	Stream_Read_UINT32(s, OutputBufferSize);
	pdev->select_interface(pdev, MsInterface->InterfaceNumber, MsInterface->AlternateSetting);
	/* replace device's MsInterface */
	MsConfig = pdev->get_MsConfig(pdev);
	InterfaceNumber = MsInterface->InterfaceNumber;
	if (!msusb_msinterface_replace(MsConfig, InterfaceNumber, MsInterface))
	{
		msusb_msconfig_free(MsConfig);
		return ERROR_BAD_CONFIGURATION;
	}
	/* complete configuration setup */
	if (!pdev->complete_msconfig_setup(pdev, MsConfig))
	{
		msusb_msconfig_free(MsConfig);
		return ERROR_BAD_CONFIGURATION;
	}
	MsInterface = MsConfig->MsInterfaces[InterfaceNumber];
	interface_size = 16 + (MsInterface->NumberOfPipes * 20);
	out_size = 36 + interface_size;
	out = Stream_New(NULL, out_size);

	if (!out)
		return ERROR_OUTOFMEMORY;

	Stream_Write_UINT32(out, InterfaceId);            /** interface */
	Stream_Write_UINT32(out, MessageId);              /** message id */
	Stream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */
	Stream_Write_UINT32(out, RequestId);              /** RequestId */
	Stream_Write_UINT32(out, 8 + interface_size);     /** CbTsUrbResult */
	/** TS_URB_RESULT_HEADER */
	Stream_Write_UINT16(out, 8 + interface_size); /** Size */
	/** Padding, MUST be ignored upon receipt */
	Stream_Write_UINT16(out, TS_URB_SELECT_INTERFACE);
	Stream_Write_UINT32(out, USBD_STATUS_SUCCESS); /** UsbdStatus */
	/** TS_URB_SELECT_INTERFACE_RESULT */
	msusb_msinterface_write(MsInterface, out);
	Stream_Write_UINT32(out, 0); /** HResult */
	Stream_Write_UINT32(out, 0); /** OutputBufferSize */

	if (!noAck)
		return stream_write_and_free(callback->plugin, callback->channel, out);
	else
		Stream_Free(out, TRUE);

	return ERROR_SUCCESS;
}
