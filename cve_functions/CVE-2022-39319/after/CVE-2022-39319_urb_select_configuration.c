static UINT urb_select_configuration(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,
                                     UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,
                                     int transferDir)
{
	MSUSB_CONFIG_DESCRIPTOR* MsConfig = NULL;
	size_t out_size;
	UINT32 InterfaceId, NumInterfaces, usbd_status = 0;
	BYTE ConfigurationDescriptorIsValid;
	wStream* out;
	int MsOutSize = 0;
	URBDRC_PLUGIN* urbdrc;
	const BOOL noAck = (RequestField & 0x80000000U) != 0;
	const UINT32 RequestId = RequestField & 0x7FFFFFFF;

	if (!callback || !s || !udevman || !pdev)
		return ERROR_INVALID_PARAMETER;

	urbdrc = (URBDRC_PLUGIN*)callback->plugin;

	if (!urbdrc)
		return ERROR_INVALID_PARAMETER;

	if (transferDir == 0)
	{
		WLog_Print(urbdrc->log, WLOG_ERROR, "urb_select_configuration: unsupported transfer out");
		return ERROR_INVALID_PARAMETER;
	}

	if (Stream_GetRemainingLength(s) < 8)
		return ERROR_INVALID_DATA;

	InterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));
	Stream_Read_UINT8(s, ConfigurationDescriptorIsValid);
	Stream_Seek(s, 3); /* Padding */
	Stream_Read_UINT32(s, NumInterfaces);

	/** if ConfigurationDescriptorIsValid is zero, then just do nothing.*/
	if (ConfigurationDescriptorIsValid)
	{
		/* parser data for struct config */
		MsConfig = msusb_msconfig_read(s, NumInterfaces);

		if (!MsConfig)
			return ERROR_INVALID_DATA;

		/* select config */
		pdev->select_configuration(pdev, MsConfig->bConfigurationValue);
		/* select all interface */
		func_select_all_interface_for_msconfig(pdev, MsConfig);
		/* complete configuration setup */
		if (!pdev->complete_msconfig_setup(pdev, MsConfig))
		{
			msusb_msconfig_free(MsConfig);
			MsConfig = NULL;
		}
	}

	if (MsConfig)
		MsOutSize = MsConfig->MsOutSize;

	if (MsOutSize > 0)
	{
		if ((size_t)MsOutSize > SIZE_MAX - 36)
			return ERROR_INVALID_DATA;

		out_size = 36 + MsOutSize;
	}
	else
		out_size = 44;

	out = Stream_New(NULL, out_size);

	if (!out)
		return ERROR_OUTOFMEMORY;

	Stream_Write_UINT32(out, InterfaceId);            /** interface */
	Stream_Write_UINT32(out, MessageId);              /** message id */
	Stream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */
	Stream_Write_UINT32(out, RequestId);              /** RequestId */

	if (MsOutSize > 0)
	{
		/** CbTsUrbResult */
		Stream_Write_UINT32(out, 8 + MsOutSize);
		/** TS_URB_RESULT_HEADER Size*/
		Stream_Write_UINT16(out, 8 + MsOutSize);
	}
	else
	{
		Stream_Write_UINT32(out, 16);
		Stream_Write_UINT16(out, 16);
	}

	/** Padding, MUST be ignored upon receipt */
	Stream_Write_UINT16(out, TS_URB_SELECT_CONFIGURATION);
	Stream_Write_UINT32(out, usbd_status); /** UsbdStatus */

	/** TS_URB_SELECT_CONFIGURATION_RESULT */
	if (MsOutSize > 0)
		msusb_msconfig_write(MsConfig, out);
	else
	{
		Stream_Write_UINT32(out, 0);             /** ConfigurationHandle */
		Stream_Write_UINT32(out, NumInterfaces); /** NumInterfaces */
	}

	Stream_Write_UINT32(out, 0); /** HResult */
	Stream_Write_UINT32(out, 0); /** OutputBufferSize */

	if (!noAck)
		return stream_write_and_free(callback->plugin, callback->channel, out);
	else
		Stream_Free(out, TRUE);

	return ERROR_SUCCESS;
}
