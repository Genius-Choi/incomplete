int cp_rsa_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,
		const rsa_t prv) {
	bn_t m, eb;
	int size, pad_len, result = RLC_OK;

	bn_null(m);
	bn_null(eb);

	size = bn_size_bin(prv->crt->n);

	if (prv == NULL || in_len != size || in_len < RSA_PAD_LEN) {
		return RLC_ERR;
	}

	RLC_TRY {
		bn_new(m);
		bn_new(eb);

		bn_read_bin(eb, in, in_len);
#if !defined(CP_CRT)
		bn_mxp(eb, eb, prv->d, prv->crt->n);
#else
		bn_mxp_crt(eb, eb, prv->crt->dp, prv->crt->dq, prv->crt, 0);
#endif /* CP_CRT */

#if CP_RSAPD == BASIC
		if (pad_basic(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {
#elif CP_RSAPD == PKCS1
		if (pad_pkcs1(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {
#elif CP_RSAPD == PKCS2
		if (pad_pkcs2(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {
#endif
			size = size - pad_len;

			if (size <= *out_len) {
				memset(out, 0, size);
				bn_write_bin(out, size, eb);
				*out_len = size;
			} else {
				result = RLC_ERR;
			}
		} else {
			result = RLC_ERR;
		}
	}
	RLC_CATCH_ANY {
		result = RLC_ERR;
	}
	RLC_FINALLY {
		bn_free(m);
		bn_free(eb);
	}

	return result;
}
