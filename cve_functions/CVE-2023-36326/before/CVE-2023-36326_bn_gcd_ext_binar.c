void bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {
	bn_t x, y, t, u, v, _a, _b, _e;
	int shift;

	if (bn_is_zero(a)) {
		bn_abs(c, b);
		bn_zero(d);
		if (e != NULL) {
			bn_set_dig(e, 1);
		}
		return;
	}

	if (bn_is_zero(b)) {
		bn_abs(c, a);
		bn_set_dig(d, 1);
		if (e != NULL) {
			bn_zero(e);
		}
		return;
	}

	bn_null(x);
	bn_null(y);
	bn_null(t);
	bn_null(u);
	bn_null(v);
	bn_null(_a);
	bn_null(_b);
	bn_null(_e);

	RLC_TRY {
		bn_new(x);
		bn_new(y);
		bn_new(t);
		bn_new(u);
		bn_new(v);
		bn_new(_a);
		bn_new(_b);
		bn_new(_e);

		bn_abs(x, a);
		bn_abs(y, b);

		/* g = 1. */
		shift = 0;
		/* While x and y are both even, x = x/2 and y = y/2, g = 2g. */
		while (bn_is_even(x) && bn_is_even(y)) {
			bn_hlv(x, x);
			bn_hlv(y, y);
			shift++;
		}

		bn_copy(u, x);
		bn_copy(v, y);

		/* u = x, y = v, A = 1, B = 0, C = 0, D = 1. */
		bn_set_dig(_a, 1);
		bn_zero(_b);
		bn_zero(d);
		bn_set_dig(_e, 1);

		/* While u is even, u = u/2. */
		while (bn_is_even(u)) {
			bn_hlv(u, u);
			/* If A = B = 0 (mod 2) then A = A/2, B = B/2. */
			if ((_a->dp[0] & 0x01) == 0 && (_b->dp[0] & 0x01) == 0) {
				bn_hlv(_a, _a);
				bn_hlv(_b, _b);
			} else {
				/* Otherwise A = (A + y)/2, B = (B - x)/2. */
				bn_add(_a, _a, y);
				bn_hlv(_a, _a);
				bn_sub(_b, _b, x);
				bn_hlv(_b, _b);
			}
		}
		while (bn_cmp(u, v) != RLC_EQ) {
			/* If v is even, v = v/2. */
			if (bn_is_even(v)) {
				bn_hlv(v, v);
				/* If C = D = 0 (mod 2) then C = C/2, D = D/2. */
				if ((d->dp[0] & 0x01) == 0 && (_e->dp[0] & 0x01) == 0) {
					bn_hlv(d, d);
					bn_hlv(_e, _e);
				} else {
					/* Otherwise C = (C + y)/2, D = (D - x)/2. */
					bn_add(d, d, y);
					bn_hlv(d, d);
					bn_sub(_e, _e, x);
					bn_hlv(_e, _e);
				}
			} else {
				if (bn_cmp(v, u) == RLC_LT) {
					bn_copy(c, u);
					bn_copy(u, v);
					bn_copy(v, c);
					bn_copy(c, d);
					bn_copy(d, _a);
					bn_copy(_a, c);
					bn_copy(c, _e);
					bn_copy(_e, _b);
					bn_copy(_b, c);
				} else {
					bn_sub(v, v, u);
					bn_sub(d, d, _a);
					bn_sub(_e, _e, _b);
				}
			}
		}
		/* If u = 0 then d = C, e = D and return (d, e, g * v). */
		bn_lsh(c, u, shift);
		/* Now fix reciprocals. */
		bn_div(x, x, u);
		bn_div(y, y, u);
		bn_hlv(_a, x);
		bn_hlv(_b, y);
		while (bn_cmp_abs(d, _b) == RLC_GT) {
			bn_div(t, d, _b);
			if (bn_bits(t) > 1) {
				bn_hlv(t, t);
			}
			bn_mul(v, x, t);
			bn_mul(u, y, t);
			if (bn_sign(d) != bn_sign(u)) {
				bn_add(d, d, u);
				bn_sub(_e, _e, v);
			} else {
				bn_sub(d, d, u);
				bn_add(_e, _e, v);
			}
		}
		if (e != NULL) {
			bn_copy(e, _e);
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(x);
		bn_free(y);
		bn_free(t);
		bn_free(u);
		bn_free(v);
		bn_free(_a);
		bn_free(_b);
		bn_free(_e);
	}
}
