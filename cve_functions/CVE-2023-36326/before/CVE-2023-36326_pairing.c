static int pairing(void) {
	int j, code = RLC_ERR;
	g1_t p[2];
	g2_t q[2];
	gt_t e1, e2;
	bn_t k, n;

	gt_null(e1);
	gt_null(e2);
	bn_null(k);
	bn_null(n);

	RLC_TRY {
		gt_new(e1);
		gt_new(e2);
		bn_new(k);
		bn_new(n);

		for (j = 0; j < 2; j++) {
			g1_null(p[j]);
			g2_null(q[j]);
			g1_new(p[j]);
			g2_new(q[j]);
		}

		pc_get_ord(n);

		TEST_CASE("pairing non-degeneracy is correct") {
			g1_rand(p[0]);
			g2_rand(q[0]);
			pc_map(e1, p[0], q[0]);
			TEST_ASSERT(gt_cmp_dig(e1, 1) != RLC_EQ, end);
			g1_set_infty(p[0]);
			pc_map(e1, p[0], q[0]);
			TEST_ASSERT(gt_cmp_dig(e1, 1) == RLC_EQ, end);
			g1_rand(p[0]);
			g2_set_infty(q[0]);
			pc_map(e1, p[0], q[0]);
			TEST_ASSERT(gt_cmp_dig(e1, 1) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("pairing is bilinear") {
			g1_rand(p[0]);
			g2_rand(q[0]);
			bn_rand_mod(k, n);
			g2_mul(q[1], q[0], k);
			pc_map(e1, p[0], q[1]);
			pc_map(e2, p[0], q[0]);
			gt_exp(e2, e2, k);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
			g1_mul(p[0], p[0], k);
			pc_map(e2, p[0], q[0]);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
			g1_dbl(p[0], p[0]);
			pc_map(e2, p[0], q[0]);
			gt_sqr(e1, e1);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
			g2_dbl(q[0], q[0]);
			pc_map(e2, p[0], q[0]);
			gt_sqr(e1, e1);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("multi-pairing is correct") {
			g1_rand(p[i % 2]);
			g2_rand(q[i % 2]);
			pc_map(e1, p[i % 2], q[i % 2]);
			g1_rand(p[1 - (i % 2)]);
			g2_set_infty(q[1 - (i % 2)]);
			pc_map_sim(e2, p, q, 2);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
			g1_set_infty(p[1 - (i % 2)]);
			g2_rand(q[1 - (i % 2)]);
			pc_map_sim(e2, p, q, 2);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
			g2_set_infty(q[i % 2]);
			pc_map_sim(e2, p, q, 2);
			TEST_ASSERT(gt_cmp_dig(e2, 1) == RLC_EQ, end);
			g1_rand(p[0]);
			g2_rand(q[0]);
			pc_map(e1, p[0], q[0]);
			g1_rand(p[1]);
			g2_rand(q[1]);
			pc_map(e2, p[1], q[1]);
			gt_mul(e1, e1, e2);
			pc_map_sim(e2, p, q, 2);
			TEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);
		} TEST_END;
	}
	RLC_CATCH_ANY {
		util_print("FATAL ERROR!\n");
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	gt_free(e1);
	gt_free(e2);
	bn_free(k);
	bn_free(n);
	for (j = 0; j < 2; j++) {
		g1_free(p[j]);
		g2_free(q[j]);
	}
	return code;
}
