static int exponentiation(void) {
	int code = RLC_ERR;
	bn_t a, b, c, p;
	crt_t crt;

	bn_null(a);
	bn_null(b);
	bn_null(c);
	bn_null(p);
	crt_null(crt);

	RLC_TRY {
		bn_new(a);
		bn_new(b);
		bn_new(c);
		bn_new(p);
		crt_new(crt);

#if BN_MOD != PMERS
		bn_gen_prime(p, RLC_BN_BITS);
#elif BN_PRECI >= 128
		/* Let's try a Mersenne prime. */
		bn_zero(p);
		bn_set_bit(p, 127, 1);
		bn_sub_dig(p, p, 1);
#endif

		TEST_CASE("modular exponentiation is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_mod(a, a, p);
			bn_mxp(b, a, p, p);
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("modular exponentiation with zero power is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_zero(b);
			bn_mxp(a, a, b, p);
			TEST_ASSERT(bn_cmp_dig(a, 1) == RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("modular exponentiation with negative power is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_mod(a, a, p);
			bn_rand(b, RLC_POS, RLC_BN_BITS);
			/* Compute c = a^b mod p. */
			bn_mxp(c, a, b, p);
			/* Compute b = a^-b mod p. */
			bn_neg(b, b);
			bn_mxp(b, a, b, p);
			/* Check that c * b = 1 mod p. */
			bn_mul(c, c, b);
			bn_mod(c, c, p);
			TEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);
		}
		TEST_END;

#if BN_MXP == BASIC || !defined(STRIP)
		TEST_CASE("basic modular exponentiation is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_mod(a, a, p);
			bn_mxp_basic(b, a, p, p);
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
		}
		TEST_END;
#endif

#if BN_MXP == SLIDE || !defined(STRIP)
		TEST_CASE("sliding window modular exponentiation is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_mod(a, a, p);
			bn_mxp_slide(b, a, p, p);
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
		}
		TEST_END;
#endif

#if BN_MXP == CONST || !defined(STRIP)
		TEST_CASE("powering ladder modular exponentiation is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_mod(a, a, p);
			bn_mxp_monty(b, a, p, p);
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
		}
		TEST_END;
#endif

		do {
			bn_gen_prime(crt->p, RLC_BN_BITS / 2);
			bn_gen_prime(crt->q, RLC_BN_BITS / 2);
		} while (bn_is_even(crt->p) || bn_is_even(crt->q));

		/* n = pq. */
		bn_mul(crt->n, crt->p, crt->q);
		/* qInv = q^(-1) mod p. */
		bn_mod_inv(crt->qi, crt->q, crt->p);
		bn_sub_dig(crt->dp, crt->p, 1);
		bn_sub_dig(crt->dq, crt->q, 1);

		TEST_CASE("chinese remainder theorem modular exponentiation is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_BN_BITS);
			bn_mod(a, a, crt->n);
			bn_mul(c, crt->dp, crt->dq);
			bn_mod(b, b, c);
			bn_mxp(p, a, b, crt->n);
			bn_mod(c, b, crt->dp);
			bn_mod(b, b, crt->dq);
			bn_mxp_crt(c, a, c, b, crt, 0);
			TEST_ASSERT(bn_cmp(c, p) == RLC_EQ, end);
		} TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	bn_free(a);
	bn_free(b);
	bn_free(c);
	bn_free(p);
	crt_free(crt);
	return code;
}
