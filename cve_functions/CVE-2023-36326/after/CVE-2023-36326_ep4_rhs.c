void ep4_rhs(fp4_t rhs, const ep4_t p) {
	fp4_t t0, t1;

	fp4_null(t0);
	fp4_null(t1);

	RLC_TRY {
		fp4_new(t0);
		fp4_new(t1);

		fp4_sqr(t0, p->x);                  /* x1^2 */

		switch (ep4_curve_opt_a()) {
			case RLC_ZERO:
				break;
#if FP_RDC != MONTY
			case RLC_MIN3:
				fp_sub_dig(t0[0][0], t0[0][0], 3);
				break;
			case RLC_ONE:
				fp_add_dig(t0[0][0], t0[0][0], 1);
				break;
			case RLC_TWO:
				fp_add_dig(t0[0][0], t0[0][0], 2);
				break;
			case RLC_TINY:
				ep4_curve_get_a(t1);
				fp_mul_dig(t0[0][0], t0[0][0], t1[0][0][0]);
				fp_mul_dig(t0[0][1], t0[0][1], t1[0][0][0]);
				fp_mul_dig(t0[1][0], t0[0][0], t1[0][0][0]);
				fp_mul_dig(t0[1][1], t0[1][1], t1[0][0][0]);
				break;
#endif
			default:
				ep4_curve_get_a(t1);
				fp4_add(t0, t0, t1);
				break;
		}

		fp4_mul(t0, t0, p->x);				/* x1^3 + a * x */

		switch (ep4_curve_opt_b()) {
			case RLC_ZERO:
				break;
#if FP_RDC != MONTY
			case RLC_MIN3:
				fp_sub_dig(t0[0][0], t0[0][0], 3);
				break;
			case RLC_ONE:
				fp_add_dig(t0[0][0], t0[0][0], 1);
				break;
			case RLC_TWO:
				fp_add_dig(t0[0][0], t0[0][0], 2);
				break;
			case RLC_TINY:
				ep4_curve_get_b(t1);
				fp_mul_dig(t0[0][0], t0[0][0], t1[0][0][0]);
				fp_mul_dig(t0[0][1], t0[0][1], t1[0][0][0]);
				fp_mul_dig(t0[1][0], t0[0][0], t1[0][0][0]);
				fp_mul_dig(t0[1][1], t0[1][1], t1[0][0][0]);
				break;
#endif
			default:
				ep4_curve_get_b(t1);
				fp4_add(t0, t0, t1);
				break;
		}

		fp4_copy(rhs, t0);
	} RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	} RLC_FINALLY {
		fp4_free(t0);
		fp4_free(t1);
	}
}
