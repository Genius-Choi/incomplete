static int digit(void) {
	int code = RLC_ERR;
	bn_t a, b, c, d, e, f;
	dig_t g;

	bn_null(a);
	bn_null(b);
	bn_null(c);
	bn_null(d);
	bn_null(e);
	bn_null(f);

	RLC_TRY {
		bn_new(a);
		bn_new(b);
		bn_new(c);
		bn_new(d);
		bn_new(e);
		bn_new(f);

		TEST_CASE("addition of a single digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			bn_get_dig(&g, b);
			bn_add(c, a, b);
			bn_add_dig(d, a, g);
			TEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("subtraction of a single digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			bn_get_dig(&g, b);
			bn_sub(c, a, b);
			bn_sub_dig(d, a, g);
			TEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("multiplication by a single digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			bn_get_dig(&g, b);
			bn_mul(c, a, b);
			bn_mul_dig(d, a, g);
			TEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("division by a single digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			if (bn_is_zero(b)) {
				continue;
			}
			bn_div(d, a, b);
			bn_div_dig(e, a, b->dp[0]);
			TEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);
			bn_div_rem(d, c, a, b);
			bn_div_rem_dig(e, &g, a, b->dp[0]);
			TEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);
			TEST_ASSERT(bn_cmp_dig(c, g) == RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("modular reduction modulo a digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			if (b->dp[0] == 0)
				continue;
			bn_div_rem(d, c, a, b);
			bn_mod_dig(&g, a, b->dp[0]);
			TEST_ASSERT(bn_cmp_dig(c, g) == RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("greatest common divisor with a digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			bn_get_dig(&g, b);
			bn_gcd(c, a, b);
			bn_gcd_dig(e, a, g);
			TEST_ASSERT(bn_cmp(c, e) == RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE
				("extended greatest common divisor with a digit is consistent")
		{
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			bn_get_dig(&g, b);
			bn_gcd_ext_dig(c, d, e, a, g);
			bn_mul(d, d, a);
			bn_mul(e, e, b);
			bn_add(d, d, e);
			TEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);
		}
		TEST_END;

#if BN_MOD != PMERS
		bn_gen_prime(d, RLC_BN_BITS);
#elif BN_PRECI >= 128
		/* Let's try a Mersenne prime. */
		bn_zero(d);
		bn_set_bit(d, 127, 1);
		bn_sub_dig(d, d, 1);
#endif

		TEST_CASE("modular exponentiation with a digit is consistent") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_DIG);
			bn_get_dig(&g, b);
			bn_mxp(c, a, b, d);
			bn_mxp_dig(e, a, g, d);
			TEST_ASSERT(bn_cmp(c, e) == RLC_EQ, end);
		}
		TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	bn_free(a);
	bn_free(b);
	bn_free(c);
	bn_free(d);
	bn_free(e);
	bn_free(f);
	return code;
}
