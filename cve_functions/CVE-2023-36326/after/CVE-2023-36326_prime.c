static int prime(void) {
	int code = RLC_ERR;
	bn_t p, q;

	bn_null(p);
	bn_null(q);

	RLC_TRY {
		bn_new(p);
		bn_new(q);

		TEST_ONCE("prime generation is consistent") {
			bn_gen_prime(p, RLC_BN_BITS);
			TEST_ASSERT(bn_is_prime(p) == 1, end);
		} TEST_END;

#if BN_GEN == BASIC || !defined(STRIP)
		TEST_ONCE("basic prime generation is consistent") {
			bn_gen_prime_basic(p, RLC_BN_BITS);
			TEST_ASSERT(bn_is_prime(p) == 1, end);
		} TEST_END;
#endif

#if BN_GEN == SAFEP || !defined(STRIP)
		TEST_ONCE("safe prime generation is consistent") {
			bn_gen_prime_safep(p, RLC_BN_BITS);
			TEST_ASSERT(bn_is_prime(p) == 1, end);
			bn_sub_dig(p, p, 1);
			bn_hlv(p, p);
			TEST_ASSERT(bn_is_prime(p) == 1, end);
		} TEST_END;
#endif

#if BN_GEN == STRON || !defined(STRIP)
		TEST_ONCE("strong prime generation is consistent") {
			bn_gen_prime_stron(p, RLC_BN_BITS);
			TEST_ASSERT(bn_is_prime(p) == 1, end);
		} TEST_END;
#endif
		bn_gen_prime(p, RLC_BN_BITS);

		TEST_ONCE("basic prime testing is correct") {
			TEST_ASSERT(bn_is_prime_basic(p) == 1, end);
		} TEST_END;

		TEST_ONCE("miller-rabin prime testing is correct") {
			TEST_ASSERT(bn_is_prime_rabin(p) == 1, end);
		} TEST_END;

		TEST_ONCE("solovay-strassen prime testing is correct") {
			TEST_ASSERT(bn_is_prime_solov(p) == 1, end);
		} TEST_END;

		bn_gen_prime_factor(q, p, RLC_BN_BITS>>1, RLC_BN_BITS);
		TEST_ONCE("prime with large (p-1) prime factor testing is correct") {
			TEST_ASSERT(bn_is_prime(p) == 1, end);
			TEST_ASSERT(bn_is_prime(q) == 1, end);
			bn_sub_dig(p, p, 1); 	// (p-1)
			bn_div(p, p, q);		// (p-1)/q
			bn_mul(p, p, q);		// ((p-1)/q)*q
			bn_add_dig(p, p, 1);	// ((p-1)/q)*q+1
			TEST_ASSERT(bn_is_prime(p) == 1, end);
		} TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	bn_free(p);
	bn_free(q);
	return code;
}
