static void parse_charstring(void)
{
  struct command *cp;

  charstring_start();
  while (!feof(ifp)) {
    get_charstring_token();
    if (line[0] == '}')
      break;
    if (is_integer(line)) {
      charstring_int(atoi(line));
    } else {
      int one;
      int two;
      int ok = 0;

      cp = (struct command *)
	bsearch((void *) line, (void *) command_table,
		sizeof(command_table) / sizeof(struct command),
		sizeof(struct command),
		command_compare);

      if (cp) {
	one = cp->one;
	two = cp->two;
	ok = 1;

      } else if (strncmp(line, "escape_", 7) == 0) {
	/* Parse the `escape' keyword requested by Lee Chun-Yu and Werner
           Lemberg */
	one = 12;
	if (sscanf(line + 7, "%d", &two) == 1)
	  ok = 1;

      } else if (strncmp(line, "UNKNOWN_", 8) == 0) {
	/* Allow unanticipated UNKNOWN commands. */
	one = 12;
	if (sscanf(line + 8, "12_%d", &two) == 1)
	  ok = 1;
	else if (sscanf(line + 8, "%d", &one) == 1) {
	  two = -1;
	  ok = 1;
	}
      }

      if (!ok)
	error("unknown charstring command `%s'", line);
      else if (one < 0 || one > 255)
	error("bad charstring command number `%d'", one);
      else if (two > 255)
	error("bad charstring command number `%d'", two);
      else if (two < 0)
	charstring_byte(one);
      else {
	charstring_byte(one);
	charstring_byte(two);
      }
    }
  }
  charstring_end();
}
