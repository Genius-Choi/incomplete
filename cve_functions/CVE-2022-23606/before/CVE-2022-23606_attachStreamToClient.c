void ConnPoolImplBase::attachStreamToClient(Envoy::ConnectionPool::ActiveClient& client,
                                            AttachContext& context) {
  ASSERT(client.state() == Envoy::ConnectionPool::ActiveClient::State::READY);

  if (enforceMaxRequests() && !host_->cluster().resourceManager(priority_).requests().canCreate()) {
    ENVOY_LOG(debug, "max streams overflow");
    onPoolFailure(client.real_host_description_, absl::string_view(),
                  ConnectionPool::PoolFailureReason::Overflow, context);
    host_->cluster().stats().upstream_rq_pending_overflow_.inc();
    return;
  }
  ENVOY_CONN_LOG(debug, "creating stream", client);

  // Latch capacity before updating remaining streams.
  uint64_t capacity = client.currentUnusedCapacity();
  client.remaining_streams_--;
  if (client.remaining_streams_ == 0) {
    ENVOY_CONN_LOG(debug, "maximum streams per connection, DRAINING", client);
    host_->cluster().stats().upstream_cx_max_requests_.inc();
    transitionActiveClientState(client, Envoy::ConnectionPool::ActiveClient::State::DRAINING);
  } else if (capacity == 1) {
    // As soon as the new stream is created, the client will be maxed out.
    transitionActiveClientState(client, Envoy::ConnectionPool::ActiveClient::State::BUSY);
  }

  // Decrement the capacity, as there's one less stream available for serving.
  // For HTTP/3, the capacity is updated in newStreamEncoder.
  if (trackStreamCapacity()) {
    state_.decrConnectingAndConnectedStreamCapacity(1);
  }
  // Track the new active stream.
  state_.incrActiveStreams(1);
  num_active_streams_++;
  host_->stats().rq_total_.inc();
  host_->stats().rq_active_.inc();
  host_->cluster().stats().upstream_rq_total_.inc();
  host_->cluster().stats().upstream_rq_active_.inc();
  host_->cluster().resourceManager(priority_).requests().inc();

  onPoolReady(client, context);
}
