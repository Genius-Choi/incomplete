void ConnPoolImplBase::onStreamClosed(Envoy::ConnectionPool::ActiveClient& client,
                                      bool delay_attaching_stream) {
  ENVOY_CONN_LOG(debug, "destroying stream: {} remaining", client, client.numActiveStreams());
  ASSERT(num_active_streams_ > 0);
  state_.decrActiveStreams(1);
  num_active_streams_--;
  host_->stats().rq_active_.dec();
  host_->cluster().stats().upstream_rq_active_.dec();
  host_->cluster().resourceManager(priority_).requests().dec();
  // We don't update the capacity for HTTP/3 as the stream count should only
  // increase when a MAX_STREAMS frame is received.
  if (trackStreamCapacity()) {
    // If the effective client capacity was limited by concurrency, increase connecting capacity.
    bool limited_by_concurrency =
        client.remaining_streams_ > client.concurrent_stream_limit_ - client.numActiveStreams() - 1;
    // The capacity calculated by concurrency could be negative if a SETTINGS frame lowered the
    // number of allowed streams. In this case, effective client capacity was still limited by
    // concurrency, compare client.concurrent_stream_limit_ and client.numActiveStreams() directly
    // to avoid overflow.
    bool negative_capacity = client.concurrent_stream_limit_ < client.numActiveStreams() + 1;
    if (negative_capacity || limited_by_concurrency) {
      state_.incrConnectingAndConnectedStreamCapacity(1);
    }
  }
  if (client.state() == ActiveClient::State::DRAINING && client.numActiveStreams() == 0) {
    // Close out the draining client if we no longer have active streams.
    client.close();
  } else if (client.state() == ActiveClient::State::BUSY && client.currentUnusedCapacity() > 0) {
    transitionActiveClientState(client, ActiveClient::State::READY);
    if (!delay_attaching_stream) {
      onUpstreamReady();
    }
  }
}
