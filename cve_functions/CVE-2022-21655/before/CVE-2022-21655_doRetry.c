void Filter::doRetry(bool can_send_early_data, bool can_use_http3) {
  ENVOY_STREAM_LOG(debug, "performing retry", *callbacks_);

  is_retry_ = true;
  attempt_count_++;
  callbacks_->streamInfo().setAttemptCount(attempt_count_);
  ASSERT(pending_retries_ > 0);
  pending_retries_--;

  // Clusters can technically get removed by CDS during a retry. Make sure it still exists.
  const auto cluster = config_.cm_.getThreadLocalCluster(route_entry_->clusterName());
  std::unique_ptr<GenericConnPool> generic_conn_pool;
  if (cluster != nullptr) {
    cluster_ = cluster->info();
    generic_conn_pool = createConnPool(*cluster);
  }

  if (!generic_conn_pool) {
    sendNoHealthyUpstreamResponse();
    cleanup();
    return;
  }
  UpstreamRequestPtr upstream_request = std::make_unique<UpstreamRequest>(
      *this, std::move(generic_conn_pool), can_send_early_data, can_use_http3);

  if (include_attempt_count_in_request_) {
    downstream_headers_->setEnvoyAttemptCount(attempt_count_);
  }

  if (Runtime::runtimeFeatureEnabled(
          "envoy.reloadable_features.update_expected_rq_timeout_on_retry")) {
    // If not enabled, then it will re-use the previous headers (if any.)

    // The request timeouts only account for time elapsed since the downstream request completed
    // which might not have happened yet (in which case zero time has elapsed.)
    std::chrono::milliseconds elapsed_time = std::chrono::milliseconds::zero();

    if (DateUtil::timePointValid(downstream_request_complete_time_)) {
      Event::Dispatcher& dispatcher = callbacks_->dispatcher();
      elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(
          dispatcher.timeSource().monotonicTime() - downstream_request_complete_time_);
    }

    FilterUtility::setTimeoutHeaders(elapsed_time.count(), timeout_, *route_entry_,
                                     *downstream_headers_, !config_.suppress_envoy_headers_,
                                     grpc_request_, hedging_params_.hedge_on_per_try_timeout_);
  }

  UpstreamRequest* upstream_request_tmp = upstream_request.get();
  LinkedList::moveIntoList(std::move(upstream_request), upstream_requests_);
  upstream_requests_.front()->encodeHeaders(!callbacks_->decodingBuffer() &&
                                            !downstream_trailers_ && downstream_end_stream_);
  // It's possible we got immediately reset which means the upstream request we just
  // added to the front of the list might have been removed, so we need to check to make
  // sure we don't encodeData on the wrong request.
  if (!upstream_requests_.empty() && (upstream_requests_.front().get() == upstream_request_tmp)) {
    if (callbacks_->decodingBuffer()) {
      // If we are doing a retry we need to make a copy.
      Buffer::OwnedImpl copy(*callbacks_->decodingBuffer());
      upstream_requests_.front()->encodeData(copy, !downstream_trailers_ && downstream_end_stream_);
    }

    if (downstream_trailers_) {
      upstream_requests_.front()->encodeTrailers(*downstream_trailers_);
    }
  }
}
