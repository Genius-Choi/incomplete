  void testAutoSniOptions(
      absl::optional<envoy::config::core::v3::UpstreamHttpProtocolOptions> dummy_option,
      Envoy::Http::TestRequestHeaderMapImpl headers, std::string server_name = "host",
      bool should_validate_san = false, std::string alt_server_name = "host") {
    NiceMock<StreamInfo::MockStreamInfo> stream_info;
    ON_CALL(*cm_.thread_local_cluster_.cluster_.info_, upstreamHttpProtocolOptions())
        .WillByDefault(ReturnRef(dummy_option));
    ON_CALL(callbacks_.stream_info_, filterState())
        .WillByDefault(ReturnRef(stream_info.filterState()));
    EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _, _))
        .WillOnce(Return(&cancellable_));
    stream_info.filterState()->setData(Network::UpstreamServerName::key(),
                                       std::make_unique<Network::UpstreamServerName>("dummy"),
                                       StreamInfo::FilterState::StateType::Mutable);
    expectResponseTimerCreate();

    HttpTestUtility::addDefaultHeaders(headers);
    router_.decodeHeaders(headers, true);
    EXPECT_EQ(server_name,
              stream_info.filterState()
                  ->getDataReadOnly<Network::UpstreamServerName>(Network::UpstreamServerName::key())
                  ->value());
    if (should_validate_san) {
      EXPECT_EQ(alt_server_name, stream_info.filterState()
                                     ->getDataReadOnly<Network::UpstreamSubjectAltNames>(
                                         Network::UpstreamSubjectAltNames::key())
                                     ->value()[0]);
    }
    EXPECT_CALL(cancellable_, cancel(_));
    router_.onDestroy();
    EXPECT_TRUE(verifyHostUpstreamStats(0, 0));
    EXPECT_EQ(0U,
              callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());
    EXPECT_EQ(0U,
              callbacks_.route_->route_entry_.virtual_cluster_.stats().upstream_rq_total_.value());
  }
