void Filter::onUpstream1xxHeaders(Http::ResponseHeaderMapPtr&& headers,
                                  UpstreamRequest& upstream_request) {
  const uint64_t response_code = Http::Utility::getResponseStatus(*headers);
  chargeUpstreamCode(response_code, *headers, upstream_request.upstreamHost(), false);
  ENVOY_STREAM_LOG(debug, "upstream 1xx ({}).", *callbacks_, response_code);

  downstream_response_started_ = true;
  final_upstream_request_ = &upstream_request;
  resetOtherUpstreams(upstream_request);

  // Don't send retries after 100-Continue has been sent on. Arguably we could attempt to do a
  // retry, assume the next upstream would also send an 100-Continue and swallow the second one
  // but it's sketchy (as the subsequent upstream might not send a 100-Continue) and not worth
  // the complexity until someone asks for it.
  retry_state_.reset();

  // We coalesce 1xx headers here, to prevent encoder filters and HCM from having to worry
  // about this. This is done in the router filter, rather than UpstreamRequest, since we want to
  // potentially coalesce across retries and multiple upstream requests in the future, even though
  // we currently don't support retry after 1xx.
  // It's plausible that this functionality might need to move to HCM in the future for internal
  // redirects, but we would need to maintain the "only call encode1xxHeaders() once"
  // invariant.
  if (!downstream_1xx_headers_encoded_) {
    downstream_1xx_headers_encoded_ = true;
    callbacks_->encode1xxHeaders(std::move(headers));
  }
}
