Status GraphDefImporter::ConvertFunctionAttributes(
    const absl::flat_hash_map<StringPiece, StringPiece> &gradient_map,
    const FunctionDef &function, GraphFuncOp op, NamedAttrList &attrs) {
  // Import the function attributes with a `tf.` prefix to match the current
  // infratructure expectations.
  for (const auto &name_attr : function.attr()) {
    if (name_attr.first.empty()) {
      return InvalidArgument("Function ", function.signature().name(),
                             " has an empty attr name");
    }
    // TODO(b/230143351): `ConvertAttributeValue` is a little slow due to
    // `ConvertTensorProto` and `ConvertTensorShapeProto`.
    TF_ASSIGN_OR_RETURN(Attribute attr,
                        ConvertAttributeValue(name_attr.second, b_, dialect_));
    attrs.append(absl::StrCat("tf.", name_attr.first), attr);
  }

  // Convert the first-class attributes.
  const tensorflow::OpDef &signature = function.signature();
  if (signature.name().empty())
    return InvalidArgument("Function without a name");
  attrs.append(op.sym_nameAttrName(), b_.getStringAttr(signature.name()));

  if (!signature.description().empty()) {
    attrs.append(op.descriptionAttrName(),
                 b_.getStringAttr(signature.description()));
  }
  if (signature.is_stateful())
    attrs.append(op.is_statefulAttrName(), b_.getUnitAttr());
  auto grad_it = gradient_map.find(signature.name());
  if (grad_it != gradient_map.end()) {
    StringPiece name = grad_it->second;
    attrs.append(op.gradientAttrName(),
                 FlatSymbolRefAttr::get(ctx_, {name.data(), name.size()}));
  }

  // The resource_arg_unique_id is a list of `pair<int, int>`, we import it
  // as two arrays of integer right now.
  if (function.resource_arg_unique_id_size()) {
    SmallVector<int32_t> resource_arg_unique_ids_keys;
    SmallVector<int32_t> resource_arg_unique_ids_values;
    resource_arg_unique_ids_keys.reserve(
        function.resource_arg_unique_id_size());
    resource_arg_unique_ids_values.reserve(
        function.resource_arg_unique_id_size());
    for (const auto &unique_id : function.resource_arg_unique_id()) {
      resource_arg_unique_ids_keys.push_back(unique_id.first);
      resource_arg_unique_ids_values.push_back(unique_id.second);
    }
    attrs.append(op.resource_arg_unique_ids_keysAttrName(),
                 b_.getI32TensorAttr(resource_arg_unique_ids_keys));
    attrs.append(op.resource_arg_unique_ids_valuesAttrName(),
                 b_.getI32TensorAttr(resource_arg_unique_ids_values));
  }
  return ::tensorflow::OkStatus();
}
