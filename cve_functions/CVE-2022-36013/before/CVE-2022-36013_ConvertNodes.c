Status GraphDefImporter::ConvertNodes(
    OpBuilder &builder, ConversionState &s,
    const tensorflow::protobuf::RepeatedPtrField<NodeDef> &nodes,
    Block *block) {
  OpBuilder::InsertionGuard ig(builder);
  builder.setInsertionPointToStart(block);
  for (const NodeDef &node : nodes) {
    TF_RETURN_IF_ERROR(ConvertNodeDef(builder, s, node));
  }

  // If the placeholder has remaining uses, then an input is missing.
  if (TF_PREDICT_FALSE(!s.GetPlaceholder().use_empty())) {
    // Stringify a result ID.
    const auto id_to_str = [](const ResultId &id) {
      std::string name = id.node.str();
      if (id.IsControl()) return absl::StrCat("^", name);
      if (id.output.empty())
        return id.index ? absl::StrCat(id.node.str(), ":", id.index) : name;
      return absl::StrCat(name, ":", id.output.str(), ":", id.index);
    };
    // Gather all missing input edges.
    std::vector<std::pair<std::string, std::string>> missing_edges;
    for (const ResultInfo &info :
         llvm::make_pointee_range(llvm::make_second_range(s))) {
      if (info.backedges.empty()) continue;
      const Backedge &edge = info.backedges.front();
      missing_edges.emplace_back(id_to_str(edge.id),
                                 TFOp(edge.operand->getOwner()).name().str());
    }
    assert(!missing_edges.empty() &&
           "placeholder had remaining uses but found no unresolved backedges");
    // Destroy the invalid IR.
    block->erase();
    // Report the missing edges in alphabetical order.
    llvm::sort(missing_edges);
    std::string error_message;
    llvm::raw_string_ostream os(error_message);
    llvm::interleave(
        missing_edges, os,
        [&](const auto &edge) {
          os << "Non-existent input " << edge.first << " in node "
             << edge.second;
        },
        "\n");
    return InvalidArgument(std::move(os.str()));
  }
  // The placeholder has no uses and should not acquire any more uses. Safely
  // delete it from the IR.
  s.Finalize();

  return ::tensorflow::OkStatus();
}
