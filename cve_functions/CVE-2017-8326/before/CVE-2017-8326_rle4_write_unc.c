static void rle4_write_unc(struct rle_context *rlectx)
{
	iw_byte dstbuf[128];
	size_t pixels_to_write;
	size_t bytes_to_write;

	if(rlectx->unc_len<1) return;

	// Note that, unlike the RLE8 encoder, we allow this function to be called
	// with uncompressed runs of arbitrary length.

	while(rlectx->unc_len>0) {
		pixels_to_write = rle4_get_best_unc_split(rlectx->unc_len);

		if(pixels_to_write<3) {
			// The minimum length for an uncompressed run is 3. For shorter runs
			// write them "compressed".
			dstbuf[0] = (iw_byte)pixels_to_write;
			dstbuf[1] = (rlectx->srcrow[rlectx->pending_data_start]<<4);
			if(pixels_to_write>1)
				dstbuf[1] |= (rlectx->srcrow[rlectx->pending_data_start+1]);

			// The actual writing will occur below. Just indicate how many bytes
			// of dstbuf[] to write.
			bytes_to_write = 2;
		}
		else {
			size_t i;

			// Write the length of the uncompressed run.
			dstbuf[0] = 0x00;
			dstbuf[1] = (iw_byte)pixels_to_write;
			iwbmp_write(rlectx->wctx,dstbuf,2);
			rlectx->total_bytes_written+=2;

			// Put the data to write in dstbuf[].
			bytes_to_write = 2*((pixels_to_write+3)/4);
			iw_zeromem(dstbuf,bytes_to_write);

			for(i=0;i<pixels_to_write;i++) {
				if(i&0x1) dstbuf[i/2] |= rlectx->srcrow[rlectx->pending_data_start+i];
				else dstbuf[i/2] = rlectx->srcrow[rlectx->pending_data_start+i]<<4;
			}
		}

		iwbmp_write(rlectx->wctx,dstbuf,bytes_to_write);
		rlectx->total_bytes_written += bytes_to_write;
		rlectx->unc_len -= pixels_to_write;
		rlectx->pending_data_start += pixels_to_write;
	}
}
