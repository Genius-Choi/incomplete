acceptor_complete(OM_uint32 * minor_status,
		  gssspnego_ctx ctx,
		  int *get_mic,
		  gss_buffer_t mech_buf,
		  gss_buffer_t mech_input_token,
		  gss_buffer_t mech_output_token,
		  heim_octet_string *mic,
		  gss_buffer_t output_token)
{
    OM_uint32 ret;
    int require_mic, verify_mic;

    ret = _gss_spnego_require_mechlist_mic(minor_status, ctx, &require_mic);
    if (ret)
	return ret;

    ctx->require_mic = require_mic;

    if (mic != NULL)
	require_mic = 1;

    if (ctx->open && require_mic) {
	if (mech_input_token == GSS_C_NO_BUFFER) { /* Even/One */
	    verify_mic = 1;
	    *get_mic = 0;
	} else if (mech_output_token != GSS_C_NO_BUFFER &&
		   mech_output_token->length == 0) { /* Odd */
	    *get_mic = verify_mic = 1;
	} else { /* Even/One */
	    verify_mic = 0;
	    *get_mic = 1;
	}

	if (verify_mic || *get_mic) {
	    int eret;
	    size_t buf_len = 0;

	    ASN1_MALLOC_ENCODE(MechTypeList,
			       mech_buf->value, mech_buf->length,
			       &ctx->initiator_mech_types, &buf_len, eret);
	    if (eret) {
		*minor_status = eret;
		return GSS_S_FAILURE;
	    }
	    heim_assert(mech_buf->length == buf_len, "Internal ASN.1 error");
	    UNREACHABLE(return GSS_S_FAILURE);
	}

	if (verify_mic) {
	    ret = verify_mechlist_mic(minor_status, ctx, mech_buf, mic);
	    if (ret) {
		if (*get_mic)
		    send_reject (minor_status, output_token);
		return ret;
	    }
	    ctx->verified_mic = 1;
	}
    } else
	*get_mic = 0;

    return GSS_S_COMPLETE;
}
