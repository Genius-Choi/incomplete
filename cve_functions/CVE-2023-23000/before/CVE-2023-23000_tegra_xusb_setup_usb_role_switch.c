static int tegra_xusb_setup_usb_role_switch(struct tegra_xusb_port *port)
{
	struct tegra_xusb_lane *lane;
	struct usb_role_switch_desc role_sx_desc = {
		.fwnode = dev_fwnode(&port->dev),
		.set = tegra_xusb_role_sw_set,
	};
	int err = 0;

	/*
	 * USB role switch driver needs parent driver owner info. This is a
	 * suboptimal solution. TODO: Need to revisit this in a follow-up patch
	 * where an optimal solution is possible with changes to USB role
	 * switch driver.
	 */
	port->dev.driver = devm_kzalloc(&port->dev,
					sizeof(struct device_driver),
					GFP_KERNEL);
	port->dev.driver->owner	 = THIS_MODULE;

	port->usb_role_sw = usb_role_switch_register(&port->dev,
						     &role_sx_desc);
	if (IS_ERR(port->usb_role_sw)) {
		err = PTR_ERR(port->usb_role_sw);
		dev_err(&port->dev, "failed to register USB role switch: %d",
			err);
		return err;
	}

	INIT_WORK(&port->usb_phy_work, tegra_xusb_usb_phy_work);
	usb_role_switch_set_drvdata(port->usb_role_sw, port);

	port->usb_phy.otg = devm_kzalloc(&port->dev, sizeof(struct usb_otg),
					 GFP_KERNEL);
	if (!port->usb_phy.otg)
		return -ENOMEM;

	lane = tegra_xusb_find_lane(port->padctl, "usb2", port->index);

	/*
	 * Assign phy dev to usb-phy dev. Host/device drivers can use phy
	 * reference to retrieve usb-phy details.
	 */
	port->usb_phy.dev = &lane->pad->lanes[port->index]->dev;
	port->usb_phy.dev->driver = port->dev.driver;
	port->usb_phy.otg->usb_phy = &port->usb_phy;
	port->usb_phy.otg->set_peripheral = tegra_xusb_set_peripheral;
	port->usb_phy.otg->set_host = tegra_xusb_set_host;

	err = usb_add_phy_dev(&port->usb_phy);
	if (err < 0) {
		dev_err(&port->dev, "Failed to add USB PHY: %d\n", err);
		return err;
	}

	/* populate connector entry */
	of_platform_populate(port->dev.of_node, NULL, NULL, &port->dev);

	return err;
}
