  static absl::optional<String> ParseBinary(Input* input) {
    auto pfx = input->ParseStringPrefix();
    if (!pfx.has_value()) return {};
    if (!pfx->huff) {
      if (pfx->length > 0 && input->peek() == 0) {
        // 'true-binary'
        input->Advance(1);
        return ParseUncompressed(input, pfx->length - 1);
      }
      // Base64 encoded... pull out the string, then unbase64 it
      auto base64 = ParseUncompressed(input, pfx->length);
      if (!base64.has_value()) return {};
      return Unbase64(input, std::move(*base64));
    } else {
      // Huffman encoded...
      std::vector<uint8_t> decompressed;
      // State here says either we don't know if it's base64 or binary, or we do
      // and what is it.
      enum class State { kUnsure, kBinary, kBase64 };
      State state = State::kUnsure;
      auto decompressed_ok =
          ParseHuff(input, pfx->length, [&state, &decompressed](uint8_t c) {
            if (state == State::kUnsure) {
              // First byte... if it's zero it's binary
              if (c == 0) {
                // Save the type, and skip the zero
                state = State::kBinary;
                return;
              } else {
                // Flag base64, store this value
                state = State::kBase64;
              }
            }
            // Non-first byte, or base64 first byte
            decompressed.push_back(c);
          });
      if (!decompressed_ok) return {};
      switch (state) {
        case State::kUnsure:
          // No bytes, empty span
          return String(absl::Span<const uint8_t>());
        case State::kBinary:
          // Binary, we're done
          return String(std::move(decompressed));
        case State::kBase64:
          // Base64 - unpack it
          return Unbase64(input, String(std::move(decompressed)));
      }
      GPR_UNREACHABLE_CODE(abort(););
    }
  }
