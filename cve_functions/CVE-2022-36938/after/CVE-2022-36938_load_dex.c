DexClasses DexLoader::load_dex(const dex_header* dh, dex_stats_t* stats) {
  if (dh->class_defs_size == 0) {
    return DexClasses(0);
  }
  m_idx = std::make_unique<DexIdx>(dh);
  auto off = (uint64_t)dh->class_defs_off;
  m_class_defs =
      reinterpret_cast<const dex_class_def*>((const uint8_t*)dh + off);
  DexClasses classes(dh->class_defs_size);
  m_classes = &classes;

  {
    auto num_threads = redex_parallel::default_num_threads();
    std::vector<std::exception_ptr> all_exceptions;
    std::mutex all_exceptions_mutex;
    workqueue_run_for<size_t>(
        0, dh->class_defs_size,
        [&all_exceptions, &all_exceptions_mutex, this](uint32_t num) {
          try {
            load_dex_class(num);
          } catch (const std::exception& exc) {
            TRACE(MAIN, 1, "Worker throw the exception:%s", exc.what());
            std::lock_guard<std::mutex> lock_guard(all_exceptions_mutex);
            all_exceptions.emplace_back(std::current_exception());
          }
        },
        num_threads);

    if (!all_exceptions.empty()) {
      // At least one of the workers raised an exception
      aggregate_exception ae(all_exceptions);
      throw ae;
    }
  }

  gather_input_stats(stats, dh);

  // Remove nulls from the classes list. They may have been introduced by benign
  // duplicate classes.
  classes.erase(std::remove(classes.begin(), classes.end(), nullptr),
                classes.end());

  return classes;
}
