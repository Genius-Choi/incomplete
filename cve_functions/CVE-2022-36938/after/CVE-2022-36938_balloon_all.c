static void balloon_all(const Scope& scope, bool throw_on_error) {
  ConcurrentMap<DexMethod*, std::string> ir_balloon_errors;
  walk::parallel::methods(scope, [&](DexMethod* m) {
    if (m->get_dex_code()) {
      try {
        m->balloon();
      } catch (RedexException& re) {
        ir_balloon_errors.emplace(m, re.what());
      }
    }
  });

  if (!ir_balloon_errors.empty()) {
    std::ostringstream oss;
    oss << "Error lifting DexCode to IRCode for the following methods:"
        << std::endl;
    for (const auto& [method, msg] : ir_balloon_errors) {
      oss << show(method) << ": " << msg << std::endl;
    }

    always_assert_log(!throw_on_error,
                      "%s" /* format string must be a string literal */,
                      oss.str().c_str());
    TRACE(MAIN, 1, "%s" /* format string must be a string literal */,
          oss.str().c_str());
  }
}
