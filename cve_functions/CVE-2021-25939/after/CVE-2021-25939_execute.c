  TRI_action_result_t execute(TRI_vocbase_t* vocbase, GeneralRequest* request,
                              GeneralResponse* response, Mutex* dataLock,
                              void** data) override {
    TRI_action_result_t result;

    // allow use database execution in rest calls?
    bool allowUseDatabase =
        _allowUseDatabase || _actionFeature.allowUseDatabase();

    // get a V8 context
    V8ContextGuard guard(
        vocbase, _isSystem ? JavaScriptSecurityContext::createInternalContext()
                           : JavaScriptSecurityContext::createRestActionContext(
                                 allowUseDatabase));

    // locate the callback
    READ_LOCKER(readLocker, _callbacksLock);

    {
      auto it = _callbacks.find(guard.isolate());

      if (it == _callbacks.end()) {
        LOG_TOPIC("94556", WARN, arangodb::Logger::FIXME)
            << "no callback function for JavaScript action '" << _url << "'";

        result.isValid = true;
        response->setResponseCode(rest::ResponseCode::NOT_FOUND);

        return result;
      }

      // and execute it
      {
        // cppcheck-suppress redundantPointerOp
        MUTEX_LOCKER(mutexLocker, *dataLock);

        if (*data != nullptr) {
          result.canceled = true;
          return result;
        }

        *data = (void*)guard.isolate();
      }
      v8::HandleScope scope(guard.isolate());
      auto localFunction =
          v8::Local<v8::Function>::New(guard.isolate(), it->second);

      // we can release the lock here already as no other threads will
      // work in our isolate at this time
      readLocker.unlock();

      try {
        result = ExecuteActionVocbase(vocbase, guard.isolate(), this,
                                      localFunction, request, response);
      } catch (...) {
        result.isValid = false;
      }

      {
        // cppcheck-suppress redundantPointerOp
        MUTEX_LOCKER(mutexLocker, *dataLock);
        *data = nullptr;
      }
    }

    return result;
  }
