  auto setRequestBodyJsonOrVPack = [&]() {
    if (rest::ContentType::UNSET == request->contentType()) {
      bool digestable = false;
      try {
        auto parsed = request->payload(true);
        if (parsed.isObject() || parsed.isArray()) {
          request->setDefaultContentType();
          digestable = true;
        }
      } catch (...) {
      }
      // ok, no json/vpack after all ;-)
      auto raw = request->rawPayload();
      headers[StaticStrings::ContentLength] = StringUtils::itoa(raw.size());
      V8Buffer* buffer = V8Buffer::New(isolate, raw.data(), raw.size());
      auto bufObj = v8::Local<v8::Object>::New(isolate, buffer->_handle);
      TRI_GET_GLOBAL_STRING(RawRequestBodyKey);
      req->Set(context, RawRequestBodyKey, bufObj).FromMaybe(false);
      req->Set(context, RequestBodyKey,
               TRI_V8_PAIR_STRING(isolate, raw.data(), raw.size()))
          .FromMaybe(false);
      if (!digestable) {
        return;
      }
    }

    if (rest::ContentType::JSON == request->contentType()) {
      VPackStringRef body = request->rawPayload();
      req->Set(context, RequestBodyKey,
               TRI_V8_PAIR_STRING(isolate, body.data(), body.size()))
          .FromMaybe(false);
      headers[StaticStrings::ContentLength] =
          StringUtils::itoa(request->contentLength());
    } else if (rest::ContentType::VPACK == request->contentType()) {
      // the VPACK is passed as it is to to JavaScript
      // FIXME not every VPack can be converted to JSON
      VPackSlice slice = request->payload(true);
      std::string jsonString = slice.toJson();

      LOG_TOPIC("8afce", DEBUG, Logger::COMMUNICATION)
          << "json handed into v8 request:\n"
          << jsonString;

      req->Set(context, RequestBodyKey, TRI_V8_STD_STRING(isolate, jsonString))
          .FromMaybe(false);
      headers[StaticStrings::ContentLength] =
          StringUtils::itoa(jsonString.size());
      headers[StaticStrings::ContentTypeHeader] = StaticStrings::MimeTypeJson;
    }
  };
