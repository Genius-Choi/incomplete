static ErrorCode clusterSendToAllServers(
    v8::Isolate* isolate, std::string const& dbname,
    std::string const& path,  // Note: Has to be properly encoded!
    arangodb::rest::RequestType const& method, std::string const& body) {
  TRI_GET_GLOBALS();
  network::ConnectionPool* pool =
      v8g->_server.getFeature<NetworkFeature>().pool();
  if (!pool || !pool->config().clusterInfo) {
    LOG_TOPIC("98fc7", ERR, Logger::COMMUNICATION)
        << "Network pool unavailable.";
    return TRI_ERROR_SHUTTING_DOWN;
  }
  ClusterInfo& ci = *pool->config().clusterInfo;
  std::vector<ServerID> DBServers = ci.getCurrentDBServers();

  network::Headers headers;
  fuerte::RestVerb verb = network::arangoRestVerbToFuerte(method);

  network::RequestOptions reqOpts;

  reqOpts.database = dbname;
  reqOpts.timeout = network::Timeout(3600);
  reqOpts.contentType = StaticStrings::MimeTypeJsonNoEncoding;

  std::vector<futures::Future<network::Response>> futures;
  futures.reserve(DBServers.size());

  // Have to propagate to DB Servers
  for (auto const& sid : DBServers) {
    VPackBuffer<uint8_t> buffer(body.size());
    buffer.append(body);
    auto f = network::sendRequestRetry(pool, "server:" + sid, verb, path,
                                       std::move(buffer), reqOpts, headers);
    futures.emplace_back(std::move(f));
  }

  for (auto& f : futures) {
    network::Response const& res = f.get();  // throws exceptions upwards
    auto commError = network::fuerteToArangoErrorCode(res);
    if (commError != TRI_ERROR_NO_ERROR) {
      return commError;
    }
  }
  return TRI_ERROR_NO_ERROR;
}
