bool amqpvalue_are_equal(AMQP_VALUE value1, AMQP_VALUE value2)
{
    bool result;

    /* Codes_SRS_AMQPVALUE_01_207: [If value1 and value2 are NULL, amqpvalue_are_equal shall return true.] */
    if ((value1 == NULL) &&
        (value2 == NULL))
    {
        LogError("Bad arguments: value1 = %p, value2 = %p",
            value1, value2);
        result = true;
    }
    /* Codes_SRS_AMQPVALUE_01_208: [If one of the arguments is NULL and the other is not, amqpvalue_are_equal shall return false.] */
    else if ((value1 != value2) && ((value1 == NULL) || (value2 == NULL)))
    {
        result = false;
    }
    else
    {
        AMQP_VALUE_DATA* value1_data = (AMQP_VALUE_DATA*)value1;
        AMQP_VALUE_DATA* value2_data = (AMQP_VALUE_DATA*)value2;

        /* Codes_SRS_AMQPVALUE_01_209: [If the types for value1 and value2 are different amqpvalue_are_equal shall return false.] */
#if _MSC_VER
#pragma warning(suppress: 28182) /* The compiler states that value2_data can be NULL, but it cannot. And there are tests for it. */
#endif
        if (value1_data->type != value2_data->type)
        {
            result = false;
        }
        else
        {
            switch (value1_data->type)
            {
            default:
                result = false;
                break;

            case AMQP_TYPE_NULL:
                /* Codes_SRS_AMQPVALUE_01_210: [- null: always equal.] */
                result = true;
                break;

            case AMQP_TYPE_BOOL:
                /* Codes_SRS_AMQPVALUE_01_211: [- boolean: compare the bool content.] */
                result = (value1_data->value.bool_value == value2_data->value.bool_value);
                break;

            case AMQP_TYPE_UBYTE:
                /* Codes_SRS_AMQPVALUE_01_212: [- ubyte: compare the unsigned char content.] */
                result = (value1_data->value.ubyte_value == value2_data->value.ubyte_value);
                break;

            case AMQP_TYPE_USHORT:
                /* Codes_SRS_AMQPVALUE_01_213: [- ushort: compare the uint16_t content.] */
                result = (value1_data->value.ushort_value == value2_data->value.ushort_value);
                break;

            case AMQP_TYPE_UINT:
                /* Codes_SRS_AMQPVALUE_01_214: [- uint: compare the uint32_t content.] */
                result = (value1_data->value.uint_value == value2_data->value.uint_value);
                break;

            case AMQP_TYPE_ULONG:
                /* Codes_SRS_AMQPVALUE_01_215: [- ulong: compare the uint64_t content.] */
                result = (value1_data->value.ulong_value == value2_data->value.ulong_value);
                break;

            case AMQP_TYPE_BYTE:
                /* Codes_SRS_AMQPVALUE_01_216: [- byte: compare the char content.] */
                result = (value1_data->value.byte_value == value2_data->value.byte_value);
                break;

            case AMQP_TYPE_SHORT:
                /* Codes_SRS_AMQPVALUE_01_217: [- short: compare the int16_t content.] */
                result = (value1_data->value.short_value == value2_data->value.short_value);
                break;

            case AMQP_TYPE_INT:
                /* Codes_SRS_AMQPVALUE_01_218: [- int: compare the int32_t content.] */
                result = (value1_data->value.int_value == value2_data->value.int_value);
                break;

            case AMQP_TYPE_LONG:
                /* Codes_SRS_AMQPVALUE_01_219: [- long: compare the int64_t content.] */
                result = (value1_data->value.long_value == value2_data->value.long_value);
                break;

            case AMQP_TYPE_FLOAT:
                /* Codes_SRS_AMQPVALUE_01_224: [- float: compare the float content.] */
                result = (value1_data->value.float_value == value2_data->value.float_value);
                break;

            case AMQP_TYPE_DOUBLE:
                /* Codes_SRS_AMQPVALUE_01_225: [- double: compare the double content.] */
                result = (value1_data->value.double_value == value2_data->value.double_value);
                break;

            case AMQP_TYPE_CHAR:
                /* Codes_SRS_AMQPVALUE_01_226: [- char: compare the UNICODE character.] */
                result = (value1_data->value.char_value == value2_data->value.char_value);
                break;

            case AMQP_TYPE_TIMESTAMP:
                /* Codes_SRS_AMQPVALUE_01_227: [- timestamp: compare the underlying 64 bit integer.] */
                result = (value1_data->value.timestamp_value == value2_data->value.timestamp_value);
                break;

            case AMQP_TYPE_UUID:
                /* Codes_SRS_AMQPVALUE_01_228: [- uuid: compare all uuid bytes.] */
                result = (memcmp(value1_data->value.uuid_value, value2_data->value.uuid_value, sizeof(value1_data->value.uuid_value)) == 0);
                break;

            case AMQP_TYPE_BINARY:
                /* Codes_SRS_AMQPVALUE_01_229: [- binary: compare all binary bytes.] */
                result = (value1_data->value.binary_value.length == value2_data->value.binary_value.length) &&
                    (memcmp(value1_data->value.binary_value.bytes, value2_data->value.binary_value.bytes, value1_data->value.binary_value.length) == 0);
                break;

            case AMQP_TYPE_STRING:
                /* Codes_SRS_AMQPVALUE_01_230: [- string: compare all string characters.] */
                result = (strcmp(value1_data->value.string_value.chars, value2_data->value.string_value.chars) == 0);
                break;

            case AMQP_TYPE_SYMBOL:
                /* Codes_SRS_AMQPVALUE_01_263: [- symbol: compare all symbol characters.] */
                result = (strcmp(value1_data->value.symbol_value.chars, value2_data->value.symbol_value.chars) == 0);
                break;

            case AMQP_TYPE_LIST:
            {
                /* Codes_SRS_AMQPVALUE_01_231: [- list: compare list item count and each element.] */
                if (value1_data->value.list_value.count != value2_data->value.list_value.count)
                {
                    result = false;
                }
                else
                {
                    uint32_t i;

                    for (i = 0; i < value1_data->value.list_value.count; i++)
                    {
                        /* Codes_SRS_AMQPVALUE_01_232: [Nesting shall be considered in comparison.] */
                        if (!amqpvalue_are_equal(value1_data->value.list_value.items[i], value2_data->value.list_value.items[i]))
                        {
                            break;
                        }
                    }

                    result = (i == value1_data->value.list_value.count);
                }

                break;
            }
            case AMQP_TYPE_ARRAY:
            {
                /* Codes_SRS_AMQPVALUE_01_427: [- array: compare array item count and each element. ] */
                if (value1_data->value.array_value.count != value2_data->value.array_value.count)
                {
                    result = false;
                }
                else
                {
                    uint32_t i;

                    for (i = 0; i < value1_data->value.array_value.count; i++)
                    {
                        /* Codes_SRS_AMQPVALUE_01_428: [ Nesting shall be considered in comparison. ] */
                        if (!amqpvalue_are_equal(value1_data->value.array_value.items[i], value2_data->value.array_value.items[i]))
                        {
                            break;
                        }
                    }

                    result = (i == value1_data->value.array_value.count);
                }

                break;
            }
            case AMQP_TYPE_MAP:
            {
                /* Codes_SRS_AMQPVALUE_01_233: [- map: compare map pair count and each key/value pair.] */
                if (value1_data->value.map_value.pair_count != value2_data->value.map_value.pair_count)
                {
                    result = false;
                }
                else
                {
                    uint32_t i;

                    /* Codes_SRS_AMQPVALUE_01_126: [Unless known to be otherwise, maps MUST be considered to be ordered, that is, the order of the key-value pairs is semantically important and two maps which are different only in the order in which their key-value pairs are encoded are not equal.] */
                    for (i = 0; i < value1_data->value.map_value.pair_count; i++)
                    {
                        /* Codes_SRS_AMQPVALUE_01_234: [Nesting shall be considered in comparison.] */
                        if ((!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].key, value2_data->value.map_value.pairs[i].key)) ||
                            (!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].value, value2_data->value.map_value.pairs[i].value)))
                        {
                            break;
                        }
                    }

                    result = (i == value1_data->value.map_value.pair_count);
                }

                break;
            }
            }
        }
    }

    return result;
}
