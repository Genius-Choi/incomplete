string decryptDHKey(const string &polyName, int ind) {
    vector<char> errMsg1(BUF_LEN, 0);
    int errStatus = 0;

    string DH_key_name = polyName + "_" + to_string(ind) + ":";
    shared_ptr <string> hexEncrKeyPtr = SGXWalletServer::readFromDb(DH_key_name, "DKG_DH_KEY_");

    spdlog::debug("encr DH key is {}", *hexEncrKeyPtr);

    vector<char> hexEncrKey(2 * BUF_LEN, 0);

    uint64_t dhEncLen = 0;
    SAFE_UINT8_BUF(encryptedDHKey, BUF_LEN);
    if (!hex2carray(hexEncrKeyPtr->c_str(), &dhEncLen, encryptedDHKey, BUF_LEN)) {
        throw SGXException(INVALID_HEX, "Invalid hexEncrKey");
    }
    spdlog::debug("encr DH key length is {}", dhEncLen);
    spdlog::debug("hex encr DH key length is {}", hexEncrKeyPtr->length());

    SAFE_CHAR_BUF(DHKey, ECDSA_SKEY_LEN);

    sgx_status_t status = trustedDecryptKeyAES(eid, &errStatus, errMsg1.data(), encryptedDHKey, dhEncLen, DHKey);
    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());

    return DHKey;
}
