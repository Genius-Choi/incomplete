vector <vector<string>> get_verif_vect(const char *encryptedPolyHex, int t, int n) {

    CHECK_STATE(encryptedPolyHex);

    vector<char> errMsg(BUF_LEN, 0);

    int errStatus = 0;

    vector<char> pubShares(10000, 0);

    uint64_t encLen = 0;

    vector <uint8_t> encrDKGPoly(2 * BUF_LEN, 0);

    if (!hex2carray(encryptedPolyHex, &encLen, encrDKGPoly.data(), 6100)) {
        throw SGXException(INVALID_HEX, "Invalid encryptedPolyHex");
    }



    sgx_status_t status = trustedGetPublicSharesAES(eid, &errStatus, errMsg.data(), encrDKGPoly.data(), encLen,
                                       pubShares.data(), t, n);
    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());

    vector <string> g2Strings = splitString(pubShares.data(), ',');
    vector <vector<string>> pubSharesVect;
    for (uint64_t i = 0; i < g2Strings.size(); i++) {
        vector <string> coeffStr = splitString(g2Strings.at(i).c_str(), ':');
        pubSharesVect.push_back(coeffStr);
    }

    return pubSharesVect;
}
