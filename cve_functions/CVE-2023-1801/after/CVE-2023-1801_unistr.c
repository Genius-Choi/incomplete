unistr(netdissect_options *ndo, char (*buf)[MAX_UNISTR_SIZE+1],
       const u_char *s, uint32_t strsize, int is_null_terminated,
       int use_unicode)
{
    u_int c;
    size_t l = 0;
    const u_char *sp;

    if (use_unicode) {
	/*
	 * Skip padding that puts the string on an even boundary.
	 */
	if (((s - startbuf) % 2) != 0) {
	    ND_TCHECK_1(s);
	    s++;
	}
    }
    if (is_null_terminated) {
	/*
	 * Null-terminated string.
	 * Find the length, counting the terminating NUL.
	 */
	strsize = 0;
	sp = s;
	if (!use_unicode) {
	    for (;;) {
		c = GET_U_1(sp);
		sp++;
		strsize++;
		if (c == '\0')
		    break;
	    }
	} else {
	    for (;;) {
		c = GET_LE_U_2(sp);
		sp += 2;
		strsize += 2;
		if (c == '\0')
		    break;
	    }
	}
    }
    if (!use_unicode) {
    	while (strsize != 0) {
	    c = GET_U_1(s);
	    s++;
	    strsize--;
	    if (c == 0) {
		/*
		 * Even counted strings may have embedded null
		 * terminators, so quit here, and skip past
		 * the rest of the data.
		 *
		 * Make sure, however, that the rest of the data
		 * is there, so we don't overflow the buffer when
		 * skipping past it.
		 */
		ND_TCHECK_LEN(s, strsize);
		s += strsize;
		strsize = 0;
		break;
	    }
	    if (l < MAX_UNISTR_SIZE) {
		if (ND_ASCII_ISPRINT(c)) {
		    /* It's a printable ASCII character */
		    (*buf)[l] = (char)c;
		} else {
		    /* It's a non-ASCII character or a non-printable ASCII character */
		    (*buf)[l] = '.';
		}
		l++;
	    }
	}
    } else {
	while (strsize > 1) {
	    c = GET_LE_U_2(s);
	    s += 2;
	    strsize -= 2;
	    if (c == 0) {
		/*
		 * Even counted strings may have embedded null
		 * terminators, so quit here, and skip past
		 * the rest of the data.
		 *
		 * Make sure, however, that the rest of the data
		 * is there, so we don't overflow the buffer when
		 * skipping past it.
		 */
		ND_TCHECK_LEN(s, strsize);
		s += strsize;
		strsize = 0;
		break;
	    }
	    if (l < MAX_UNISTR_SIZE) {
		if (ND_ASCII_ISPRINT(c)) {
		    /* It's a printable ASCII character */
		    (*buf)[l] = (char)c;
		} else {
		    /* It's a non-ASCII character or a non-printable ASCII character */
		    (*buf)[l] = '.';
		}
		l++;
	    }
	}
	if (strsize == 1) {
	    /* We have half of a code point; skip past it */
	    ND_TCHECK_1(s);
	    s++;
	}
    }
    (*buf)[l] = 0;
    return s;

trunc:
    (*buf)[l] = 0;
    return NULL;
}
