fetch_token(netdissect_options *ndo, const u_char *pptr, u_int idx, u_int len,
	    u_char *tbuf, size_t tbuflen)
{
	size_t toklen = 0;
	u_char c;

	for (; idx < len; idx++) {
		if (!ND_TTEST_1(pptr + idx)) {
			/* ran past end of captured data */
			return (0);
		}
		c = GET_U_1(pptr + idx);
		if (!ND_ISASCII(c)) {
			/* not an ASCII character */
			return (0);
		}
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			/* end of token */
			break;
		}
		if (!ND_ASCII_ISPRINT(c)) {
			/* not part of a command token or response code */
			return (0);
		}
		if (toklen + 2 > tbuflen) {
			/* no room for this character and terminating '\0' */
			return (0);
		}
		tbuf[toklen] = c;
		toklen++;
	}
	if (toklen == 0) {
		/* no token */
		return (0);
	}
	tbuf[toklen] = '\0';

	/*
	 * Skip past any white space after the token, until we see
	 * an end-of-line (CR or LF).
	 */
	for (; idx < len; idx++) {
		if (!ND_TTEST_1(pptr + idx)) {
			/* ran past end of captured data */
			break;
		}
		c = GET_U_1(pptr + idx);
		if (c == '\r' || c == '\n') {
			/* end of line */
			break;
		}
		if (!ND_ASCII_ISPRINT(c)) {
			/* not a printable ASCII character */
			break;
		}
		if (c != ' ' && c != '\t' && c != '\r' && c != '\n') {
			/* beginning of next token */
			break;
		}
	}
	return (idx);
}
