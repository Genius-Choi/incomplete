ahcp1_options_print(netdissect_options *ndo,
                    const u_char *cp, uint16_t len)
{
	while (len) {
		uint8_t option_no, option_len;

		/* Option no */
		option_no = GET_U_1(cp);
		cp += 1;
		len -= 1;
		ND_PRINT("\n\t %s", tok2str(ahcp1_opt_str, "Unknown-%u", option_no));
		if (option_no == AHCP1_OPT_PAD || option_no == AHCP1_OPT_MANDATORY)
			continue;
		/* Length */
		if (!len)
			goto invalid;
		option_len = GET_U_1(cp);
		cp += 1;
		len -= 1;
		if (option_len > len)
			goto invalid;
		/* Value */
		if (option_no <= AHCP1_OPT_MAX && data_decoders[option_no] != NULL) {
			data_decoders[option_no](ndo, cp, option_len);
		} else {
			ND_PRINT(" (Length %u)", option_len);
			ND_TCHECK_LEN(cp, option_len);
		}
		cp += option_len;
		len -= option_len;
	}
	return;

invalid:
	nd_print_invalid(ndo);
	ND_TCHECK_LEN(cp, len);
}
