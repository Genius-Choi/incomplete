void NppParameters::feedScintillaParam(TiXmlNode *node)
{
	TiXmlElement* element = node->ToElement();

	// Line Number Margin
	const TCHAR *nm = element->Attribute(TEXT("lineNumberMargin"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("show")))
			_svp._lineNumberMarginShow = true;
		else if (!lstrcmp(nm, TEXT("hide")))
			_svp._lineNumberMarginShow = false;
	}

	// Line Number Margin dynamic width
	nm = element->Attribute(TEXT("lineNumberDynamicWidth"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._lineNumberMarginDynamicWidth = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._lineNumberMarginDynamicWidth = false;
	}

	// Bookmark Margin
	nm = element->Attribute(TEXT("bookMarkMargin"));
	if (nm)
	{

		if (!lstrcmp(nm, TEXT("show")))
			_svp._bookMarkMarginShow = true;
		else if (!lstrcmp(nm, TEXT("hide")))
			_svp._bookMarkMarginShow = false;
	}

	// Indent GuideLine
	nm = element->Attribute(TEXT("indentGuideLine"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("show")))
			_svp._indentGuideLineShow = true;
		else if (!lstrcmp(nm, TEXT("hide")))
			_svp._indentGuideLineShow= false;
	}

	// Folder Mark Style
	nm = element->Attribute(TEXT("folderMarkStyle"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("box")))
			_svp._folderStyle = FOLDER_STYLE_BOX;
		else if (!lstrcmp(nm, TEXT("circle")))
			_svp._folderStyle = FOLDER_STYLE_CIRCLE;
		else if (!lstrcmp(nm, TEXT("arrow")))
			_svp._folderStyle = FOLDER_STYLE_ARROW;
		else if (!lstrcmp(nm, TEXT("simple")))
			_svp._folderStyle = FOLDER_STYLE_SIMPLE;
		else if (!lstrcmp(nm, TEXT("none")))
			_svp._folderStyle = FOLDER_STYLE_NONE;
	}

	// Line Wrap method
	nm = element->Attribute(TEXT("lineWrapMethod"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("default")))
			_svp._lineWrapMethod = LINEWRAP_DEFAULT;
		else if (!lstrcmp(nm, TEXT("aligned")))
			_svp._lineWrapMethod = LINEWRAP_ALIGNED;
		else if (!lstrcmp(nm, TEXT("indent")))
			_svp._lineWrapMethod = LINEWRAP_INDENT;
	}

	// Current Line Highlighting State
	nm = element->Attribute(TEXT("currentLineHilitingShow"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("show")))
			_svp._currentLineHiliteMode = LINEHILITE_HILITE;
		else
			_svp._currentLineHiliteMode = LINEHILITE_NONE;
	}
	else
	{
		const TCHAR* currentLineModeStr = element->Attribute(TEXT("currentLineIndicator"));
		if (currentLineModeStr && currentLineModeStr[0])
		{
			if (lstrcmp(currentLineModeStr, TEXT("1")) == 0)
				_svp._currentLineHiliteMode = LINEHILITE_HILITE;
			else if (lstrcmp(currentLineModeStr, TEXT("2")) == 0)
				_svp._currentLineHiliteMode = LINEHILITE_FRAME;
			else
				_svp._currentLineHiliteMode = LINEHILITE_NONE;
		}
	}

	// Current Line Frame Width
	nm = element->Attribute(TEXT("currentLineFrameWidth"));
	if (nm)
	{
		unsigned char frameWidth{ 1 };
		try
		{
			frameWidth = static_cast<unsigned char>(std::stoi(nm));
		}
		catch (...)
		{
			// do nothing. frameWidth is already set to '1'.
		}
		_svp._currentLineFrameWidth = (frameWidth < 1) ? 1 : (frameWidth > 6) ? 6 : frameWidth;
	}

	// Virtual Space
	nm = element->Attribute(TEXT("virtualSpace"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._virtualSpace = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._virtualSpace = false;
	}

	// Scrolling Beyond Last Line State
	nm = element->Attribute(TEXT("scrollBeyondLastLine"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._scrollBeyondLastLine = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._scrollBeyondLastLine = false;
	}

	// Do not change selection or caret position when right-clicking with mouse
	nm = element->Attribute(TEXT("rightClickKeepsSelection"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._rightClickKeepsSelection = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._rightClickKeepsSelection = false;
	}

	// Disable Advanced Scrolling
	nm = element->Attribute(TEXT("disableAdvancedScrolling"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._disableAdvancedScrolling = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._disableAdvancedScrolling = false;
	}

	// Current wrap symbol visibility State
	nm = element->Attribute(TEXT("wrapSymbolShow"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("show")))
			_svp._wrapSymbolShow = true;
		else if (!lstrcmp(nm, TEXT("hide")))
			_svp._wrapSymbolShow = false;
	}

	// Do Wrap
	nm = element->Attribute(TEXT("Wrap"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._doWrap = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._doWrap = false;
	}

	// Do Edge
	nm = element->Attribute(TEXT("isEdgeBgMode"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._isEdgeBgMode = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._isEdgeBgMode = false;
	}

	// Do Scintilla border edge
	nm = element->Attribute(TEXT("borderEdge"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._showBorderEdge = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._showBorderEdge = false;
	}

	nm = element->Attribute(TEXT("edgeMultiColumnPos"));
	if (nm)
	{
		str2numberVector(nm, _svp._edgeMultiColumnPos);
	}

	int val;
	nm = element->Attribute(TEXT("zoom"), &val);
	if (nm)
	{
		_svp._zoom = val;
	}

	nm = element->Attribute(TEXT("zoom2"), &val);
	if (nm)
	{
		_svp._zoom2 = val;
	}

	// White Space visibility State
	nm = element->Attribute(TEXT("whiteSpaceShow"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("show")))
			_svp._whiteSpaceShow = true;
		else if (!lstrcmp(nm, TEXT("hide")))
			_svp._whiteSpaceShow = false;
	}

	// EOL visibility State
	nm = element->Attribute(TEXT("eolShow"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("show")))
			_svp._eolShow = true;
		else if (!lstrcmp(nm, TEXT("hide")))
			_svp._eolShow = false;
	}

	nm = element->Attribute(TEXT("eolMode"), &val);
	if (nm)
	{
		if (val >= 0 && val <= 3)
			_svp._eolMode = static_cast<ScintillaViewParams::crlfMode>(val);
	}

	nm = element->Attribute(TEXT("borderWidth"), &val);
	if (nm)
	{
		if (val >= 0 && val <= 30)
			_svp._borderWidth = val;
	}

	// Do antialiased font
	nm = element->Attribute(TEXT("smoothFont"));
	if (nm)
	{
		if (!lstrcmp(nm, TEXT("yes")))
			_svp._doSmoothFont = true;
		else if (!lstrcmp(nm, TEXT("no")))
			_svp._doSmoothFont = false;
	}

	nm = element->Attribute(TEXT("paddingLeft"), &val);
	if (nm)
	{
		if (val >= 0 && val <= 30)
			_svp._paddingLeft = static_cast<unsigned char>(val);
	}

	nm = element->Attribute(TEXT("paddingRight"), &val);
	if (nm)
	{
		if (val >= 0 && val <= 30)
			_svp._paddingRight = static_cast<unsigned char>(val);
	}

	nm = element->Attribute(TEXT("distractionFreeDivPart"), &val);
	if (nm)
	{
		if (val >= 3 && val <= 9)
			_svp._distractionFreeDivPart = static_cast<unsigned char>(val);
	}
}
