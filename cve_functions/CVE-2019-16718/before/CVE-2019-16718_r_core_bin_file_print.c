static bool r_core_bin_file_print(RCore *core, RBinFile *bf, int mode) {
	r_return_val_if_fail (core && bf && bf->o, NULL);
	const char *name = bf ? bf->file : NULL;
	(void)r_bin_get_info (core->bin); // XXX is this necssary for proper iniitialization
	ut32 bin_sz = bf ? bf->size : 0;
	// TODO: handle mode to print in json and r2 commands

	switch (mode) {
	case '*':
		{
			char *n = __filterShell (name);
			r_cons_printf ("oba 0x%08"PFMT64x" %s # %d\n", bf->o->boffset, n, bf->id);
			free (n);
		}
		break;
	case 'q':
		r_cons_printf ("%d\n", bf->id);
		break;
	case 'j':
		// XXX there's only one binobj for each bf...so we should change that json
		// TODO: use pj API
		r_cons_printf ("{\"name\":\"%s\",\"iofd\":%d,\"bfid\":%d,\"size\":%d,\"objs\":[",
			name? name: "", bf->fd, bf->id, bin_sz);
		{
			RBinObject *obj = bf->o;
			RBinInfo *info = obj->info;
			ut8 bits = info ? info->bits : 0;
			const char *asmarch = r_config_get (core->config, "asm.arch");
			const char *arch = info ? info->arch ? info->arch: asmarch : "unknown";
			r_cons_printf ("{\"arch\":\"%s\",\"bits\":%d,\"binoffset\":%"
					PFMT64d",\"objsize\":%"PFMT64d"}",
					arch, bits, obj->boffset, obj->obj_size);
		}
		r_cons_print ("]}");
		break;
	default:
		{
			RBinInfo *info = bf->o->info;
			ut8 bits = info ? info->bits : 0;
			const char *asmarch = r_config_get (core->config, "asm.arch");
			const char *arch = info ? info->arch ? info->arch: asmarch: "unknown";
			r_cons_printf ("%d %d %s-%d ba:0x%08"PFMT64x" sz:%"PFMT64d" %s\n",
				bf->id, bf->fd, arch, bits, bf->o->baddr, bf->o->size, name);
		}
		break;
	}
	return true;
}
