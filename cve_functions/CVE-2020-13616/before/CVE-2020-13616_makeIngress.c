template <typename Socket> unique_ptr<Ingress> makeIngress(api::IngressHolder& holder, Socket&& s)
{
  auto container = array<uint8_t, 1024>{0};
  auto psk = MutableBuffer<uint8_t>{container};
  auto& vo = holder.vo_;
  switch (vo.type_) {
  case AdapterType::HTTP:
#ifdef ENABLE_TLS
    if (*vo.tls_) {
      auto ctx = createTlsContext(vo);
      return make_unique<HttpIngress<TlsSocket>>(vo.credentials_, forward<Socket>(s), ctx);
    }
    else
#endif // ENABLE_TLS
      return make_unique<HttpIngress<TcpSocket>>(vo.credentials_, forward<Socket>(s));
  case AdapterType::SOCKS5:
#ifdef ENABLE_TLS
    if (*vo.tls_) {
      auto ctx = createTlsContext(vo);
      return make_unique<Socks5Ingress<TlsSocket>>(vo.credentials_, forward<Socket>(s), ctx);
    }
    else
#endif // ENABLE_TLS
      return make_unique<Socks5Ingress<TcpSocket>>(vo.credentials_, forward<Socket>(s));
  case AdapterType::SS:
    psk = {container, generateKey(*vo.method_, ConstBuffer<uint8_t>{*vo.password_}, container)};
    switch (*vo.method_) {
    case CryptoMethod::RC4_MD5:
      return make_unique<SSStreamAdapter<CryptoMethod::RC4_MD5, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::BF_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::BF_CFB, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::AES_128_CTR:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CTR, Socket>>(psk,
                                                                             forward<Socket>(s));
    case CryptoMethod::AES_192_CTR:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CTR, Socket>>(psk,
                                                                             forward<Socket>(s));
    case CryptoMethod::AES_256_CTR:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CTR, Socket>>(psk,
                                                                             forward<Socket>(s));
    case CryptoMethod::AES_128_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CFB, Socket>>(psk,
                                                                             forward<Socket>(s));
    case CryptoMethod::AES_192_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CFB, Socket>>(psk,
                                                                             forward<Socket>(s));
    case CryptoMethod::AES_256_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CFB, Socket>>(psk,
                                                                             forward<Socket>(s));
    case CryptoMethod::CAMELLIA_128_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_128_CFB, Socket>>(
          psk, forward<Socket>(s));
    case CryptoMethod::CAMELLIA_192_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_192_CFB, Socket>>(
          psk, forward<Socket>(s));
    case CryptoMethod::CAMELLIA_256_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_256_CFB, Socket>>(
          psk, forward<Socket>(s));
    case CryptoMethod::CHACHA20:
      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::SALSA20:
      return make_unique<SSStreamAdapter<CryptoMethod::SALSA20, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::CHACHA20_IETF:
      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20_IETF, Socket>>(psk,
                                                                               forward<Socket>(s));
    case CryptoMethod::AES_128_GCM:
      return make_unique<SSAeadAdapter<CryptoMethod::AES_128_GCM, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::AES_192_GCM:
      return make_unique<SSAeadAdapter<CryptoMethod::AES_192_GCM, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::AES_256_GCM:
      return make_unique<SSAeadAdapter<CryptoMethod::AES_256_GCM, Socket>>(psk, forward<Socket>(s));
    case CryptoMethod::CHACHA20_IETF_POLY1305:
      return make_unique<SSAeadAdapter<CryptoMethod::CHACHA20_IETF_POLY1305, Socket>>(
          psk, forward<Socket>(s));
    case CryptoMethod::XCHACHA20_IETF_POLY1305:
      return make_unique<SSAeadAdapter<CryptoMethod::XCHACHA20_IETF_POLY1305, Socket>>(
          psk, forward<Socket>(s));
    default:
      fail(PichiError::BAD_PROTO);
    }
  case AdapterType::TUNNEL:
    return make_unique<TunnelIngress<api::IngressIterator, Socket>>(*holder.balancer_,
                                                                    forward<Socket>(s));
  default:
    fail(PichiError::BAD_PROTO);
  }
}
