unique_ptr<Egress> makeEgress(api::EgressVO const& vo, asio::io_context& io)
{
  auto container = array<uint8_t, 1024>{0};
  auto psk = MutableBuffer<uint8_t>{container};
  switch (vo.type_) {
  case AdapterType::HTTP:
#ifdef ENABLE_TLS
    if (*vo.tls_) {
      auto ctx = createTlsContext(vo);
      return make_unique<HttpEgress<TlsSocket>>(vo.credential_, io, ctx);
    }
    else
#endif // ENABLE_TLS
      return make_unique<HttpEgress<TcpSocket>>(vo.credential_, io);
  case AdapterType::SOCKS5:
#ifdef ENABLE_TLS
    if (*vo.tls_) {
      auto ctx = createTlsContext(vo);
      return make_unique<Socks5Egress<ssl::stream<tcp::socket>>>(vo.credential_, io, ctx);
    }
    else
#endif // ENABLE_TLS
      return make_unique<Socks5Egress<tcp::socket>>(vo.credential_, io);
  case AdapterType::DIRECT:
    return make_unique<DirectAdapter>(io);
  case AdapterType::REJECT:
    switch (*vo.mode_) {
    case api::DelayMode::RANDOM:
      return make_unique<RejectEgress>(io);
    case api::DelayMode::FIXED:
      return make_unique<RejectEgress>(io, *vo.delay_);
    default:
      fail(PichiError::BAD_PROTO);
    }
  case AdapterType::SS:
    psk = {container, generateKey(*vo.method_, ConstBuffer<uint8_t>{*vo.password_}, container)};
    switch (*vo.method_) {
    case CryptoMethod::RC4_MD5:
      return make_unique<SSStreamAdapter<CryptoMethod::RC4_MD5, TcpSocket>>(psk, io);
    case CryptoMethod::BF_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::BF_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::AES_128_CTR:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CTR, TcpSocket>>(psk, io);
    case CryptoMethod::AES_192_CTR:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CTR, TcpSocket>>(psk, io);
    case CryptoMethod::AES_256_CTR:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CTR, TcpSocket>>(psk, io);
    case CryptoMethod::AES_128_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_128_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::AES_192_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_192_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::AES_256_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::AES_256_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::CAMELLIA_128_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_128_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::CAMELLIA_192_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_192_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::CAMELLIA_256_CFB:
      return make_unique<SSStreamAdapter<CryptoMethod::CAMELLIA_256_CFB, TcpSocket>>(psk, io);
    case CryptoMethod::CHACHA20:
      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20, TcpSocket>>(psk, io);
    case CryptoMethod::SALSA20:
      return make_unique<SSStreamAdapter<CryptoMethod::SALSA20, TcpSocket>>(psk, io);
    case CryptoMethod::CHACHA20_IETF:
      return make_unique<SSStreamAdapter<CryptoMethod::CHACHA20_IETF, TcpSocket>>(psk, io);
    case CryptoMethod::AES_128_GCM:
      return make_unique<SSAeadAdapter<CryptoMethod::AES_128_GCM, TcpSocket>>(psk, io);
    case CryptoMethod::AES_192_GCM:
      return make_unique<SSAeadAdapter<CryptoMethod::AES_192_GCM, TcpSocket>>(psk, io);
    case CryptoMethod::AES_256_GCM:
      return make_unique<SSAeadAdapter<CryptoMethod::AES_256_GCM, TcpSocket>>(psk, io);
    case CryptoMethod::CHACHA20_IETF_POLY1305:
      return make_unique<SSAeadAdapter<CryptoMethod::CHACHA20_IETF_POLY1305, TcpSocket>>(psk, io);
    case CryptoMethod::XCHACHA20_IETF_POLY1305:
      return make_unique<SSAeadAdapter<CryptoMethod::XCHACHA20_IETF_POLY1305, TcpSocket>>(psk, io);
    default:
      fail(PichiError::BAD_PROTO);
    }
  default:
    fail(PichiError::BAD_PROTO);
  }
}
