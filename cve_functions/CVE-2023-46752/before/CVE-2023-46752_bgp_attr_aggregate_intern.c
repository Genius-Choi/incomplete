struct attr *bgp_attr_aggregate_intern(
	struct bgp *bgp, uint8_t origin, struct aspath *aspath,
	struct community *community, struct ecommunity *ecommunity,
	struct lcommunity *lcommunity, struct bgp_aggregate *aggregate,
	uint8_t atomic_aggregate, const struct prefix *p)
{
	struct attr attr;
	struct attr *new;
	route_map_result_t ret;

	memset(&attr, 0, sizeof(attr));

	/* Origin attribute. */
	attr.origin = origin;
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);

	/* MED */
	attr.med = 0;
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC);

	/* AS path attribute. */
	if (aspath)
		attr.aspath = aspath_intern(aspath);
	else
		attr.aspath = aspath_empty(bgp->asnotation);
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);

	if (community) {
		uint32_t gshut = COMMUNITY_GSHUT;

		/* If we are not shutting down ourselves and we are
		 * aggregating a route that contains the GSHUT community we
		 * need to remove that community when creating the aggregate */
		if (!bgp_in_graceful_shutdown(bgp)
		    && community_include(community, gshut)) {
			community_del_val(community, &gshut);
		}

		bgp_attr_set_community(&attr, community);
	}

	if (ecommunity)
		bgp_attr_set_ecommunity(&attr, ecommunity);

	if (lcommunity)
		bgp_attr_set_lcommunity(&attr, lcommunity);

	if (bgp_in_graceful_shutdown(bgp))
		bgp_attr_add_gshut_community(&attr);

	attr.label_index = BGP_INVALID_LABEL_INDEX;
	attr.label = MPLS_INVALID_LABEL;
	attr.weight = BGP_ATTR_DEFAULT_WEIGHT;
	attr.mp_nexthop_len = IPV6_MAX_BYTELEN;
	if (!aggregate->as_set || atomic_aggregate)
		attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);
	if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))
		attr.aggregator_as = bgp->confed_id;
	else
		attr.aggregator_as = bgp->as;
	attr.aggregator_addr = bgp->router_id;

	/* Aggregate are done for IPv4/IPv6 so checking ipv4 family,
	 * This should only be set for IPv4 AFI type
	 * based on RFC-4760:
	 * "An UPDATE message that carries no NLRI,
	 * other than the one encoded in
	 * the MP_REACH_NLRI attribute,
	 * SHOULD NOT carry the NEXT_HOP
	 * attribute"
	 */
	if (p->family == AF_INET) {
		/* Next hop attribute.  */
		attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);
		attr.mp_nexthop_len = IPV4_MAX_BYTELEN;
	}

	/* Apply route-map */
	if (aggregate->rmap.name) {
		struct attr attr_tmp = attr;
		struct bgp_path_info rmap_path;

		memset(&rmap_path, 0, sizeof(rmap_path));
		rmap_path.peer = bgp->peer_self;
		rmap_path.attr = &attr_tmp;

		SET_FLAG(bgp->peer_self->rmap_type, PEER_RMAP_TYPE_AGGREGATE);

		ret = route_map_apply(aggregate->rmap.map, p, &rmap_path);

		bgp->peer_self->rmap_type = 0;

		if (ret == RMAP_DENYMATCH) {
			/* Free uninterned attribute. */
			bgp_attr_flush(&attr_tmp);

			/* Unintern original. */
			aspath_unintern(&attr.aspath);
			return NULL;
		}

		if (bgp_in_graceful_shutdown(bgp))
			bgp_attr_add_gshut_community(&attr_tmp);

		new = bgp_attr_intern(&attr_tmp);
	} else {

		if (bgp_in_graceful_shutdown(bgp))
			bgp_attr_add_gshut_community(&attr);

		new = bgp_attr_intern(&attr);
	}

	/* Always release the 'intern()'ed AS Path. */
	aspath_unintern(&attr.aspath);

	return new;
}
