void bgp_attr_flush(struct attr *attr)
{
	struct ecommunity *ecomm;
	struct ecommunity *ipv6_ecomm;
	struct cluster_list *cluster;
	struct lcommunity *lcomm;
	struct community *comm;

	if (attr->aspath && !attr->aspath->refcnt) {
		aspath_free(attr->aspath);
		attr->aspath = NULL;
	}
	comm = bgp_attr_get_community(attr);
	if (comm && !comm->refcnt)
		community_free(&comm);
	bgp_attr_set_community(attr, NULL);

	ecomm = bgp_attr_get_ecommunity(attr);
	if (ecomm && !ecomm->refcnt)
		ecommunity_free(&ecomm);
	bgp_attr_set_ecommunity(attr, NULL);

	ipv6_ecomm = bgp_attr_get_ipv6_ecommunity(attr);
	if (ipv6_ecomm && !ipv6_ecomm->refcnt)
		ecommunity_free(&ipv6_ecomm);
	bgp_attr_set_ipv6_ecommunity(attr, NULL);

	lcomm = bgp_attr_get_lcommunity(attr);
	if (lcomm && !lcomm->refcnt)
		lcommunity_free(&lcomm);
	bgp_attr_set_lcommunity(attr, NULL);

	cluster = bgp_attr_get_cluster(attr);
	if (cluster && !cluster->refcnt) {
		cluster_free(cluster);
		bgp_attr_set_cluster(attr, NULL);
	}

	struct transit *transit = bgp_attr_get_transit(attr);

	if (transit && !transit->refcnt) {
		transit_free(transit);
		bgp_attr_set_transit(attr, NULL);
	}
	if (attr->encap_subtlvs && !attr->encap_subtlvs->refcnt) {
		encap_free(attr->encap_subtlvs);
		attr->encap_subtlvs = NULL;
	}
	if (attr->srv6_l3vpn && !attr->srv6_l3vpn->refcnt) {
		srv6_l3vpn_free(attr->srv6_l3vpn);
		attr->srv6_l3vpn = NULL;
	}
	if (attr->srv6_vpn && !attr->srv6_vpn->refcnt) {
		srv6_vpn_free(attr->srv6_vpn);
		attr->srv6_vpn = NULL;
	}
#ifdef ENABLE_BGP_VNC
	struct bgp_attr_encap_subtlv *vnc_subtlvs =
		bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs && !vnc_subtlvs->refcnt) {
		encap_free(vnc_subtlvs);
		bgp_attr_set_vnc_subtlvs(attr, NULL);
	}
#endif
}
