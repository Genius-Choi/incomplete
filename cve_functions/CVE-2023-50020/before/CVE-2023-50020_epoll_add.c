static int epoll_add(ogs_poll_t *poll)
{
    int rv, op;
    ogs_pollset_t *pollset = NULL;
    struct epoll_context_s *context = NULL;
    struct epoll_map_s *map = NULL;
    struct epoll_event ee;

    ogs_assert(poll);
    pollset = poll->pollset;
    ogs_assert(pollset);
    context = pollset->context;
    ogs_assert(context);

    map = ogs_hash_get(context->map_hash, &poll->fd, sizeof(poll->fd));
    if (!map) {
        map = ogs_calloc(1, sizeof(*map));
        if (!map) {
            ogs_error("ogs_calloc() failed");
            return OGS_ERROR;
        }

        op = EPOLL_CTL_ADD;
        ogs_hash_set(context->map_hash, &poll->fd, sizeof(poll->fd), map);
    } else {
        op = EPOLL_CTL_MOD;
    }

    if (poll->when & OGS_POLLIN)
        map->read = poll;
    if (poll->when & OGS_POLLOUT)
        map->write = poll;

    memset(&ee, 0, sizeof ee);

    ee.events = 0;
    if (map->read)
        ee.events |= (EPOLLIN|EPOLLRDHUP);
    if (map->write)
        ee.events |= EPOLLOUT;
    ee.data.fd = poll->fd;

    rv = epoll_ctl(context->epfd, op, poll->fd, &ee);
    if (rv < 0) {
        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,
                "epoll_ctl[%d] failed", op);
        return OGS_ERROR;
    }

    return OGS_OK;
}
