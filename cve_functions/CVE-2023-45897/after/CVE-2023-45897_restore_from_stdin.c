static int restore_from_stdin(struct exfat2img *ei)
{
	int in_fd, ret;
	unsigned char cc;
	unsigned int clu, end_clu;
	unsigned int cc_clu_count;
	unsigned int clus_size;
	__le32 t_cc_clu_count;
	off_t out_start_off, out_end_off_excl;
	off_t in_start_off;
	size_t len;

	in_fd = fileno(stdin);
	if (in_fd < 0) {
		exfat_err("failed to get fd from stdin\n");
		return in_fd;
	}

	if (read_stream(in_fd, &ei_hdr, sizeof(ei_hdr)) != (ssize_t)sizeof(ei_hdr)) {
		exfat_err("failed to read a header\n");
		return -EIO;
	}

	if (le32_to_cpu(ei_hdr.magic) != EI_MAGIC) {
		exfat_err("header has invalid magic %#x, expected %#x\n",
			  le32_to_cpu(ei_hdr.magic), EI_MAGIC);
		return -EINVAL;
	}

	clus_size = le32_to_cpu(ei_hdr.cluster_size);

	ei->out_fd = ei->bdev.dev_fd;
	ei->dump_bdesc = exfat_alloc_buffer(2, clus_size, 512);
	if (!ei->dump_bdesc)
		return -ENOMEM;

	/* restore boot regions, and FAT tables */
	in_start_off = le32_to_cpu(ei_hdr.data_offset);
	out_start_off = 0;
	out_end_off_excl = le32_to_cpu(ei_hdr.heap_clus_offset);
	while (out_start_off < out_end_off_excl) {
		len = MIN(out_end_off_excl - out_start_off, clus_size);
		if (read_stream(in_fd, ei->dump_bdesc[0].buffer, len) != (ssize_t)len) {
			exfat_err("failed to read first meta region. %llu ~ %llu\n",
				  (unsigned long long)in_start_off,
				  (unsigned long long)in_start_off + len);
			ret = -EIO;
			goto out;
		}

		if (pwrite(ei->out_fd, ei->dump_bdesc[0].buffer, len, out_start_off)
		    != (ssize_t)len) {
			exfat_err("failed to write first meta region. %llu ~ %llu\n",
				  (unsigned long long)out_start_off,
				  (unsigned long long)out_start_off + len);
			ret = -EIO;
			goto out;
		}

		out_start_off += len;
		in_start_off += len;
	}

	/* restore heap clusters */
	clu = 0;
	while (clu < le32_to_cpu(ei_hdr.cluster_count)) {
		if (read_stream(in_fd, &cc, sizeof(cc)) != (ssize_t)sizeof(cc)) {
			exfat_err("failed to read cc at %llu\n",
				  (unsigned long long)in_start_off);
			ret = -EIO;
			goto out;
		}
		in_start_off += 1;

		if (cc == EI_CC_COPY_2 || cc == EI_CC_SKIP_2) {
			if (read_stream(in_fd, &t_cc_clu_count, EI_CC_PAYLOAD_LEN) !=
			    (ssize_t)EI_CC_PAYLOAD_LEN) {
				exfat_err("failed to read cc cluster count at %llu\n",
					  (unsigned long long)in_start_off);
				ret = -EIO;
				goto out;
			}
			cc_clu_count = le32_to_cpu(t_cc_clu_count);
			in_start_off += EI_CC_PAYLOAD_LEN;
		} else if (cc == EI_CC_COPY_1 || cc == EI_CC_SKIP_1) {
			cc_clu_count = 1;
		} else {
			exfat_err("unexpected cc %d at %llu\n",
				  cc, (unsigned long long)in_start_off);
			ret = -EINVAL;
			goto out;
		}

		if (cc == EI_CC_COPY_1 || cc == EI_CC_COPY_2) {
			end_clu = clu + cc_clu_count;
			while (clu < end_clu) {
				if (read_stream(in_fd, ei->dump_bdesc[0].buffer,
						clus_size) != (ssize_t)clus_size) {
					exfat_err("failed to read range %llu ~ %llu\n",
						  (unsigned long long)in_start_off,
						  (unsigned long long)in_start_off + clus_size);
					ret = -EIO;
					goto out;
				}
				if (pwrite(ei->out_fd, ei->dump_bdesc[0].buffer,
					   clus_size, out_start_off) != (ssize_t)clus_size) {
					exfat_err("failed to write range %llu ~ %llu\n",
						  (unsigned long long)out_start_off,
						  (unsigned long long)out_start_off + clus_size);
					ret = -EIO;
					goto out;
				}

				out_start_off += clus_size;
				in_start_off += clus_size;
				clu++;
			}
		} else {
			out_start_off += (off_t)cc_clu_count * clus_size;
			in_start_off +=  (off_t)cc_clu_count * clus_size;
			if (lseek(ei->out_fd, out_start_off, SEEK_SET) == (off_t)-1) {
				exfat_err("failed to seek to %llu\n",
					  (unsigned long long)out_start_off);
				ret = -EIO;
				goto out;
			}
			clu += cc_clu_count;
		}
	}
out:
	fsync(ei->out_fd);
	exfat_free_buffer(ei->dump_bdesc, 2);
	return ret;
}
