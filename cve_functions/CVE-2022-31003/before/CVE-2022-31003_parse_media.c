static void parse_media(sdp_parser_t *p, char *r, sdp_media_t **result)
{
  /*
   media-descriptions =  *( media-field
                         information-field
                         *(connection-field)
                         bandwidth-fields
                         key-field
                         attribute-fields )

   media-field =         "m=" media space port ["/" integer]
                         space proto 1*(space fmt) CRLF

   media =               token
                         ;typically "audio", "video", "application"
                         ;or "data" or "text"

   fmt =                 token
                         ;typically an RTP payload type for audio
                         ;and video media

   proto =               token *("/" token)
                         ;typically "RTP/AVP" or "udp" for IP4

   port =                1*(DIGIT)
                         ;should in the range "1024" to "65535" inclusive
   */
  char *s;
  unsigned long value;
  PARSE_ALLOC(p, sdp_media_t, m);

  *result = m;

  m->m_mode = sdp_sendrecv;

  s = token(&r, SPACE, TOKEN, NULL);
  if (!s) {
    parsing_error(p, "m= invalid media field");
    return;
  }

  sdp_media_type(m, s);

  /* Accept m=* in configuration file */
  if (p->pr_config && m->m_type == sdp_media_any) {
    r += strspn(r, SPACE TAB);
    if (r[0] == '\0') {
      m->m_proto = sdp_proto_any, m->m_proto_name = "*";
      return;
    }
  }

  if (parse_ul(p, &r, &value, 0)) {
    parsing_error(p, "m= invalid port number");
    return;
  }
  m->m_port = value;

  if (*r == '/') {
    r++;
    if (parse_ul(p, &r, &value, 0)) {
      parsing_error(p, "m= invalid port specification");
      return;
    }
    m->m_number_of_ports = value;
  }

  s = token(&r, SPACE, "/" TOKEN, SPACE);
  if (s == NULL) {
    parsing_error(p, "m= missing protocol");
    return;
  }

  if (!STRICT(p) && su_casematch(s, "RTP"))
    m->m_proto = sdp_proto_rtp, m->m_proto_name = "RTP/AVP";
  else
    sdp_media_transport(m, s);

  /* RTP format list */
  if (*r && sdp_media_has_rtp(m)) {
	  parse_payload(p, r, &m->m_rtpmaps);
	  return;
  }

  /* "normal" format list */
  if (*r) {
    sdp_list_t **fmt = &m->m_format;

    while (r && *r) {
      PARSE_ALLOC(p, sdp_list_t, l);
      *fmt = l;
      l->l_text = token(&r, SPACE TAB, TOKEN, SPACE TAB);
      if (!l->l_text) {
         parsing_error(p, "m= invalid");
         return;
      }
      fmt = &l->l_next;
    }
  }
}
