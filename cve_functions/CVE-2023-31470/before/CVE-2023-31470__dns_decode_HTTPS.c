static int _dns_decode_HTTPS(struct dns_context *context, const char *domain, dns_rr_type type, unsigned int ttl,
							 int rr_len)
{
	unsigned char *start = context->ptr;

	struct dns_packet *packet = context->packet;
	int ret = 0;
	unsigned short priority;
	unsigned short key;
	unsigned short value_len;
	unsigned char *value = NULL;
	char target[DNS_MAX_CNAME_LEN] = {0};
	struct dns_rr_nested param;

	if (rr_len < 2) {
		tlog(TLOG_DEBUG, "https len is invalid.");
		return -1;
	}

	priority = _dns_read_short(&context->ptr);
	ret = _dns_decode_domain(context, target, sizeof(target));
	if (ret < 0) {
		return -1;
	}

	dns_add_HTTPS_start(&param, packet, DNS_RRS_AN, domain, ttl, priority, target);

	while (context->ptr - start < rr_len) {
		if (_dns_left_len(context) < 4) {
			tlog(TLOG_WARN, "data length is invalid, %d:%d", _dns_left_len(context),
				 (int)(context->ptr - context->data));
			return -1;
		}
		key = _dns_read_short(&context->ptr);
		value_len = _dns_read_short(&context->ptr);
		value = context->ptr;

		if (_dns_left_len(context) < value_len) {
			tlog(TLOG_ERROR, "read https data failed, svcParam key = %d, https_len = %d", key, value_len);
			return -1;
		}

		switch (key) {
		case DNS_HTTPS_T_MANDATORY:
		case DNS_HTTPS_T_ALPN:
		case DNS_HTTPS_T_NO_DEFAULT_ALPN:
		case DNS_HTTPS_T_PORT:
		case DNS_HTTPS_T_IPV4HINT:
		case DNS_HTTPS_T_ECH:
		case DNS_HTTPS_T_IPV6HINT: {
			dns_HTTPS_add_raw(&param, key, value, value_len);
		} break;
		default:
			tlog(TLOG_DEBUG, "DNS HTTPS key = %d not supported", key);
			break;
		}

		context->ptr += value_len;
	}

	dns_add_HTTPS_end(&param);

	return 0;
}
