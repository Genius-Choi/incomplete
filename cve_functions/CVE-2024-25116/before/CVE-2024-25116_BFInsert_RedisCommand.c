static int BFInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx);
    BFInsertOptions options = {.capacity = BFDefaultInitCapacity,
                               .error_rate = BFDefaultErrorRate,
                               .autocreate = 1,
                               .is_multi = 1,
                               .expansion = BF_DEFAULT_EXPANSION,
                               .nonScaling = 0};
    int items_index = -1;

    // Scan the arguments
    if (argc < 4) {
        return RedisModule_WrongArity(ctx);
    }

    size_t cur_pos = 2;
    while (cur_pos < argc && items_index < 0) {
        size_t arglen;
        const char *argstr = RedisModule_StringPtrLen(argv[cur_pos], &arglen);

        switch (tolower(*argstr)) {
        case 'i':
            items_index = ++cur_pos;
            break;

        case 'e':
            if (++cur_pos == argc) {
                return RedisModule_WrongArity(ctx);
            }
            if (tolower(*(argstr + 1)) == 'r') { // error rate
                if (RedisModule_StringToDouble(argv[cur_pos++], &options.error_rate) !=
                    REDISMODULE_OK) {
                    return RedisModule_ReplyWithError(ctx, "Bad error rate");
                }
            } else { // expansion
                if (RedisModule_StringToLongLong(argv[cur_pos++], &options.expansion) !=
                    REDISMODULE_OK) {
                    return RedisModule_ReplyWithError(ctx, "Bad expansion");
                }
            }
            break;

        case 'c':
            if (++cur_pos == argc) {
                return RedisModule_WrongArity(ctx);
            }
            if (RedisModule_StringToLongLong(argv[cur_pos++], &options.capacity) !=
                REDISMODULE_OK) {
                return RedisModule_ReplyWithError(ctx, "Bad capacity");
            }
            break;

        case 'n':
            if (tolower(*(argstr + 2)) == 'c') {
                options.autocreate = 0;
            } else {
                options.nonScaling = BLOOM_OPT_NO_SCALING;
            }
            cur_pos++;
            break;

        default:
            return RedisModule_ReplyWithError(ctx, "Unknown argument received");
        }
    }

    if (items_index < 0 || items_index == argc) {
        return RedisModule_WrongArity(ctx);
    }

    if (options.error_rate <= 0 || options.error_rate >= 1 || options.capacity < 1 ||
        options.expansion < 1) {
        return RedisModule_ReplyWithError(ctx, "Bad argument received");
    }

    return bfInsertCommon(ctx, argv[1], argv + items_index, argc - items_index, &options);
}
