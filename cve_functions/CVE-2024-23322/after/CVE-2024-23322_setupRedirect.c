bool Filter::setupRedirect(const Http::ResponseHeaderMap& headers) {
  ENVOY_STREAM_LOG(debug, "attempting internal redirect", *callbacks_);
  const Http::HeaderEntry* location = headers.Location();

  const uint64_t status_code = Http::Utility::getResponseStatus(headers);

  // Redirects are not supported for streaming requests yet.
  if (downstream_end_stream_ && (!request_buffer_overflowed_ || !callbacks_->decodingBuffer()) &&
      location != nullptr &&
      convertRequestHeadersForInternalRedirect(*downstream_headers_, headers, *location,
                                               status_code) &&
      callbacks_->recreateStream(&headers)) {
    ENVOY_STREAM_LOG(debug, "Internal redirect succeeded", *callbacks_);
    cluster_->trafficStats()->upstream_internal_redirect_succeeded_total_.inc();
    return true;
  }
  // convertRequestHeadersForInternalRedirect logs failure reasons but log
  // details for other failure modes here.
  if (!downstream_end_stream_) {
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: request incomplete", *callbacks_);
  } else if (request_buffer_overflowed_) {
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: request body overflow", *callbacks_);
  } else if (location == nullptr) {
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: missing location header", *callbacks_);
  }

  cluster_->trafficStats()->upstream_internal_redirect_failed_total_.inc();
  return false;
}
