void Filter::onResponseTimeout() {
  ENVOY_STREAM_LOG(debug, "upstream timeout", *callbacks_);

  // Reset any upstream requests that are still in flight.
  while (!upstream_requests_.empty()) {
    UpstreamRequestPtr upstream_request =
        upstream_requests_.back()->removeFromList(upstream_requests_);

    // We want to record the upstream timeouts and increase the stats counters in all the cases.
    // For example, we also want to record the stats in the case of BiDi streaming APIs where we
    // might have already seen the headers.
    cluster_->trafficStats()->upstream_rq_timeout_.inc();
    if (request_vcluster_) {
      request_vcluster_->stats().upstream_rq_timeout_.inc();
    }
    if (route_stats_context_.has_value()) {
      route_stats_context_->stats().upstream_rq_timeout_.inc();
    }

    if (upstream_request->upstreamHost()) {
      upstream_request->upstreamHost()->stats().rq_timeout_.inc();
    }

    if (upstream_request->awaitingHeaders()) {
      if (cluster_->timeoutBudgetStats().has_value()) {
        // Cancel firing per-try timeout information, because the per-try timeout did not come into
        // play when the global timeout was hit.
        upstream_request->recordTimeoutBudget(false);
      }

      // If this upstream request already hit a "soft" timeout, then it
      // already recorded a timeout into outlier detection. Don't do it again.
      if (!upstream_request->outlierDetectionTimeoutRecorded()) {
        updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, *upstream_request,
                               absl::optional<uint64_t>(enumToInt(timeout_response_code_)));
      }

      chargeUpstreamAbort(timeout_response_code_, false, *upstream_request);
    }
    upstream_request->resetStream();
  }

  onUpstreamTimeoutAbort(StreamInfo::CoreResponseFlag::UpstreamRequestTimeout,
                         StreamInfo::ResponseCodeDetails::get().ResponseTimeout);
}
