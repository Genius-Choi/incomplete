Filter::createConnPool(Upstream::ThreadLocalCluster& thread_local_cluster) {
  GenericConnPoolFactory* factory = nullptr;
  if (cluster_->upstreamConfig().has_value()) {
    factory = Envoy::Config::Utility::getFactory<GenericConnPoolFactory>(
        cluster_->upstreamConfig().ref());
    ENVOY_BUG(factory != nullptr,
              fmt::format("invalid factory type '{}', failing over to default upstream",
                          cluster_->upstreamConfig().ref().DebugString()));
  }
  if (!factory) {
    factory = &config_.router_context_.genericConnPoolFactory();
  }

  using UpstreamProtocol = Envoy::Router::GenericConnPoolFactory::UpstreamProtocol;
  UpstreamProtocol upstream_protocol = UpstreamProtocol::HTTP;
  if (route_entry_->connectConfig().has_value()) {
    auto method = downstream_headers_->getMethodValue();
    if (Runtime::runtimeFeatureEnabled("envoy.reloadable_features.enable_connect_udp_support") &&
        Http::HeaderUtility::isConnectUdpRequest(*downstream_headers_)) {
      upstream_protocol = UpstreamProtocol::UDP;
    } else if (method == Http::Headers::get().MethodValues.Connect ||
               (route_entry_->connectConfig()->allow_post() &&
                method == Http::Headers::get().MethodValues.Post)) {
      // Allow POST for proxying raw TCP if it is configured.
      upstream_protocol = UpstreamProtocol::TCP;
    }
  }
  return factory->createGenericConnPool(thread_local_cluster, upstream_protocol,
                                        route_entry_->priority(),
                                        callbacks_->streamInfo().protocol(), this);
}
