void Filter::onUpstreamReset(Http::StreamResetReason reset_reason,
                             absl::string_view transport_failure_reason,
                             UpstreamRequest& upstream_request) {
  ENVOY_STREAM_LOG(debug, "upstream reset: reset reason: {}, transport failure reason: {}",
                   *callbacks_, Http::Utility::resetReasonToString(reset_reason),
                   transport_failure_reason);

  const bool dropped = reset_reason == Http::StreamResetReason::Overflow;

  // Ignore upstream reset caused by a resource overflow.
  // Currently, circuit breakers can only produce this reset reason.
  // It means that this reason is cluster-wise, not upstream-related.
  // Therefore removing an upstream in the case of an overloaded cluster
  // would make the situation even worse.
  // https://github.com/envoyproxy/envoy/issues/25487
  if (!dropped) {
    // TODO: The reset may also come from upstream over the wire. In this case it should be
    // treated as external origin error and distinguished from local origin error.
    // This matters only when running OutlierDetection with split_external_local_origin_errors
    // config param set to true.
    updateOutlierDetection(Upstream::Outlier::Result::LocalOriginConnectFailed, upstream_request,
                           absl::nullopt);
  }

  if (maybeRetryReset(reset_reason, upstream_request, TimeoutRetry::No)) {
    return;
  }

  const Http::Code error_code = (reset_reason == Http::StreamResetReason::ProtocolError)
                                    ? Http::Code::BadGateway
                                    : Http::Code::ServiceUnavailable;
  chargeUpstreamAbort(error_code, dropped, upstream_request);
  auto request_ptr = upstream_request.removeFromList(upstream_requests_);
  callbacks_->dispatcher().deferredDelete(std::move(request_ptr));

  // If there are other in-flight requests that might see an upstream response,
  // don't return anything downstream.
  if (numRequestsAwaitingHeaders() > 0 || pending_retries_ > 0) {
    return;
  }

  const StreamInfo::CoreResponseFlag response_flags = streamResetReasonToResponseFlag(reset_reason);

  const std::string body =
      absl::StrCat("upstream connect error or disconnect/reset before headers. ",
                   (is_retry_ ? "retried and the latest " : ""),
                   "reset reason: ", Http::Utility::resetReasonToString(reset_reason),
                   !transport_failure_reason.empty() ? ", transport failure reason: " : "",
                   transport_failure_reason);
  const std::string& basic_details =
      downstream_response_started_ ? StreamInfo::ResponseCodeDetails::get().LateUpstreamReset
                                   : StreamInfo::ResponseCodeDetails::get().EarlyUpstreamReset;
  const std::string details = StringUtil::replaceAllEmptySpace(absl::StrCat(
      basic_details, "{", Http::Utility::resetReasonToString(reset_reason),
      transport_failure_reason.empty() ? "" : absl::StrCat(",", transport_failure_reason), "}"));
  onUpstreamAbort(error_code, response_flags, body, dropped, details);
}
