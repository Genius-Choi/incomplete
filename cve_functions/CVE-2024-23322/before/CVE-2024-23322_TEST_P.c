TEST_P(HttpTimeoutIntegrationTest, RequestHeaderTimeout) {
  if (downstreamProtocol() != Http::CodecType::HTTP1) {
    // This test requires that the downstream be using HTTP1.
    return;
  }

  config_helper_.addConfigModifier(
      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
              hcm) {
        auto* request_headers_timeout = hcm.mutable_request_headers_timeout();
        request_headers_timeout->set_seconds(1);
        request_headers_timeout->set_nanos(0);
      });
  initialize();

  const std::string input_request = ("GET / HTTP/1.1\r\n"
                                     // Omit trailing \r\n that would indicate the end of headers.
                                     "Host: localhost\r\n");
  std::string response;

  auto connection_driver = createConnectionDriver(
      lookupPort("http"), input_request,
      [&response](Network::ClientConnection&, const Buffer::Instance& data) -> void {
        response.append(data.toString());
      });

  while (!connection_driver->allBytesSent()) {
    ASSERT_TRUE(connection_driver->run(Event::Dispatcher::RunType::NonBlock));
  }
  test_server_->waitForGaugeGe("http.config_test.downstream_rq_active", 1);
  ASSERT_FALSE(connection_driver->closed());

  timeSystem().advanceTimeWait(std::chrono::milliseconds(1001));
  ASSERT_TRUE(connection_driver->run());

  // The upstream should send a 40x response and send a local reply.
  EXPECT_TRUE(connection_driver->closed());
  EXPECT_THAT(response, AllOf(HasSubstr("408"), HasSubstr("header")));
}
