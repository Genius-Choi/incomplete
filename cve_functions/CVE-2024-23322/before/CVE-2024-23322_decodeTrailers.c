Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap& trailers) {
  ENVOY_STREAM_LOG(debug, "router decoding trailers:\n{}", *callbacks_, trailers);

  if (shadow_headers_) {
    shadow_trailers_ = Http::createHeaderMap<Http::RequestTrailerMapImpl>(trailers);
  }

  // upstream_requests_.size() cannot be > 1 because that only happens when a per
  // try timeout occurs with hedge_on_per_try_timeout enabled but the per
  // try timeout timer is not started until onRequestComplete(). It could be zero
  // if the first request attempt has already failed and a retry is waiting for
  // a backoff timer.
  ASSERT(upstream_requests_.size() <= 1);
  downstream_trailers_ = &trailers;
  if (!upstream_requests_.empty()) {
    upstream_requests_.front()->acceptTrailersFromRouter(trailers);
  }
  for (auto* shadow_stream : shadow_streams_) {
    shadow_stream->removeDestructorCallback();
    shadow_stream->removeWatermarkCallbacks();
    shadow_stream->captureAndSendTrailers(
        Http::createHeaderMap<Http::RequestTrailerMapImpl>(*shadow_trailers_));
  }
  shadow_streams_.clear();

  onRequestComplete();
  return Http::FilterTrailersStatus::StopIteration;
}
