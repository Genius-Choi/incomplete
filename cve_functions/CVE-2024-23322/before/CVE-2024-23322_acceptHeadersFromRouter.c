void UpstreamRequest::acceptHeadersFromRouter(bool end_stream) {
  ASSERT(!router_sent_end_stream_);
  router_sent_end_stream_ = end_stream;

  // Make sure that when we are forwarding CONNECT payload we do not do so until
  // the upstream has accepted the CONNECT request.
  // This must be done before conn_pool->newStream, as onPoolReady un-pauses for CONNECT
  // termination.
  auto* headers = parent_.downstreamHeaders();
  if (headers->getMethodValue() == Http::Headers::get().MethodValues.Connect) {
    paused_for_connect_ = true;
  }

  // Kick off creation of the upstream connection immediately upon receiving headers.
  // In future it may be possible for upstream HTTP filters to delay this, or influence connection
  // creation but for now optimize for minimal latency and fetch the connection
  // as soon as possible.
  conn_pool_->newStream(this);

  if (parent_.config().upstream_log_flush_interval_.has_value()) {
    upstream_log_flush_timer_ = parent_.callbacks()->dispatcher().createTimer([this]() -> void {
      // If the request is complete, we've already done the stream-end upstream log, and shouldn't
      // do the periodic log.
      if (!streamInfo().requestComplete().has_value()) {
        upstreamLog(AccessLog::AccessLogType::UpstreamPeriodic);
        resetUpstreamLogFlushTimer();
      }
      // Both downstream and upstream bytes meters may not be initialized when
      // the timer goes off, e.g. if it takes longer than the interval for a
      // connection to be initialized; check for nullptr.
      auto& downstream_bytes_meter = stream_info_.getDownstreamBytesMeter();
      auto& upstream_bytes_meter = stream_info_.getUpstreamBytesMeter();
      const SystemTime now = parent_.callbacks()->dispatcher().timeSource().systemTime();
      if (downstream_bytes_meter) {
        downstream_bytes_meter->takeUpstreamPeriodicLoggingSnapshot(now);
      }
      if (upstream_bytes_meter) {
        upstream_bytes_meter->takeUpstreamPeriodicLoggingSnapshot(now);
      }
    });

    resetUpstreamLogFlushTimer();
  }

  filter_manager_->requestHeadersInitialized();
  filter_manager_->streamInfo().setRequestHeaders(*parent_.downstreamHeaders());
  filter_manager_->decodeHeaders(*parent_.downstreamHeaders(), end_stream);
}
