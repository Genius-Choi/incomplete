mobile::Module parse_flatbuffer_no_object(
    std::shared_ptr<char> data,
    size_t size,
    c10::optional<at::Device> device) {
  (void)device;
  (void)size;

  // Validate Flatbuffer module before parsing.
  flatbuffers::Verifier verifier(reinterpret_cast<uint8_t*>(data.get()), size);
  TORCH_CHECK(
      mobile::serialization::VerifyModuleBuffer(verifier),
      "Malformed Flatbuffer module");

  auto* flatbuffer_module = mobile::serialization::GetMutableModule(data.get());
  FlatbufferLoader loader;
  // replace parserObject with to handle only class with field case
  // function.
  loader.registerIValueParser(
      mobile::serialization::IValueUnion::Object,
      +[](FlatbufferLoader& loader,
          const mobile::serialization::IValue& ivalue) {
        const mobile::serialization::Object* object = ivalue.val_as_Object();
        auto cls = loader.getOrCreateClassTypeForObject(object);
        auto obj = c10::ivalue::Object::create(
            at::StrongTypePtr(loader.cu_, cls), object->attrs()->size());
        for (uint32_t i = 0; i < object->attrs()->size(); i++) {
          IValue val = loader.getIValue(object->attrs()->Get(i));
          obj->setSlot(i, std::move(val));
        }
        return static_cast<c10::IValue>(obj);
      });

  auto* end = data.get() + size;
  mobile::Module m = loader.parseModule(flatbuffer_module, end);
  m.set_delete_memory(std::move(data));
  return m;
}
