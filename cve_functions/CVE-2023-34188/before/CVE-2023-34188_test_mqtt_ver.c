static void test_mqtt_ver(uint8_t mqtt_version) {
  char buf[50] = {0}, client_id[16], will_topic[16];
  struct mqtt_data test_data = {buf, 50, 0, 0};
  struct mg_mgr mgr;
  struct mg_str topic = mg_str("x/f12"), data = mg_str("hi");
  struct mg_connection *c;
  struct mg_mqtt_opts opts;
  struct mg_mqtt_prop properties[4];
  const char *url = "mqtt://broker.hivemq.com:1883";
  int i;
  mg_mgr_init(&mgr);

  // Connect with empty client ID
  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, &test_data);
  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);
  if (buf[0] != 'X') MG_INFO(("[%s]", buf));
  ASSERT(buf[0] == 'X');
  ASSERT(test_data.subscribed == 0);

  opts.topic = topic, opts.qos = 1;
  mg_mqtt_sub(c, &opts);
  for (i = 0; i < 500 && test_data.subscribed == 0; i++) mg_mgr_poll(&mgr, 10);
  ASSERT(test_data.subscribed == 1);
  ASSERT(test_data.published == 0);

  opts.topic = topic, opts.message = data, opts.qos = 1, opts.retain = false;
  mg_mqtt_pub(c, &opts);
  for (i = 0; i < 500 && test_data.published == 0; i++) mg_mgr_poll(&mgr, 10);
  ASSERT(test_data.published == 1);
  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);
  if (strcmp(buf, "Xx/f12/hi") != 0) MG_INFO(("[%s]", buf));
  ASSERT(strcmp(buf, "Xx/f12/hi") == 0);

  // Set params
  test_data.subscribed = 0;
  test_data.published = 0;
  memset(buf, 0, sizeof(buf));
  memset(&opts, 0, sizeof(opts));

  opts.clean = true, opts.qos = 1, opts.retain = true, opts.keepalive = 20;
  opts.version = mqtt_version;
  opts.topic = mg_str(mg_random_str(will_topic, sizeof(will_topic)));
  opts.message = mg_str("mg_will_messsage");
  opts.client_id = mg_str(mg_random_str(client_id, sizeof(client_id)));
  c = mg_mqtt_connect(&mgr, url, &opts, mqtt_cb, &test_data);
  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);
  if (buf[0] != 'X') MG_INFO(("[%s]", buf));
  ASSERT(buf[0] == 'X');
  ASSERT(test_data.subscribed == 0);

  opts.topic = topic, opts.qos = 1;
  mg_mqtt_sub(c, &opts);
  for (i = 0; i < 500 && test_data.subscribed == 0; i++) mg_mgr_poll(&mgr, 10);
  ASSERT(test_data.subscribed == 1);
  ASSERT(test_data.published == 0);

  opts.topic = topic, opts.message = data, opts.qos = 1, opts.retain = false;
  if (mqtt_version == 5) {
    opts.props = properties;
    opts.num_props = 4;
    construct_props(properties);
  }

  mg_mqtt_pub(c, &opts);
  for (i = 0; i < 500 && test_data.published == 0; i++) mg_mgr_poll(&mgr, 10);
  ASSERT(test_data.published == 1);
  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);
  if (strcmp(buf, "Xx/f12/hi") != 0) MG_INFO(("[%s]", buf));
  ASSERT(strcmp(buf, "Xx/f12/hi") == 0);

  mg_mgr_free(&mgr);
  ASSERT(mgr.conns == NULL);
}
