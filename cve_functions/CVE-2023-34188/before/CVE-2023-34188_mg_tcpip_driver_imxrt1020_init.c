static bool mg_tcpip_driver_imxrt1020_init(struct mg_tcpip_if *ifp) {

  struct mg_tcpip_driver_imxrt1020_data *d = (struct mg_tcpip_driver_imxrt1020_data *) ifp->driver_data;
  s_ifp = ifp;

  // ENET Reset, wait complete
  ENET->ECR |= BIT(0);
  while((ENET->ECR & BIT(0)) != 0) {}

  // Re-latches the pin strapping pin values
  ENET->ECR |= BIT(0);
  while((ENET->ECR & BIT(0)) != 0) {}

  // Setup MII/RMII MDC clock divider (<= 2.5MHz).
  ENET->MSCR = 0x130; // HOLDTIME 2 clk, Preamble enable, MDC MII_Speed Div 0x30
  imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, 0x8000); // PHY W @0x00 D=0x8000 Soft reset
  while (imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BSR) & BIT(15)) {delay(0x5000);} // Wait finished poll 10ms

  // PHY: Start Link
  {
    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, 0x1200); // PHY W @0x00 D=0x1200 Autonego enable + start
    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, 0x1f, 0x8180);    // PHY W @0x1f D=0x8180 Ref clock 50 MHz at XI input

    uint32_t bcr = imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR);
    bcr &= ~BIT(10); // Isolation -> Normal
    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, bcr);
  }

  // Disable ENET
  ENET->ECR = 0x0; //  Disable before configuration

  // Configure ENET
  ENET->RCR = 0x05ee0104; // #CRCFWD=0 (CRC kept in frame) + RMII + MII Enable
  
  ENET->TCR = BIT(8) | BIT(2); // Addins (MAC address from PAUR+PALR) + Full duplex enable
  //ENET->TFWR = BIT(8); // Store And Forward Enable, 64 bytes (minimize tx latency)

  // Configure descriptors and buffers
  // RX
  for (int i = 0; i < ENET_RXBD_NUM; i++) {
    // Wrap last descriptor buffer ptr
    rx_buffer_descriptor[i].control = (BIT(15) | ((i<(ENET_RXBD_NUM-1))?0:BIT(13))); // E+(W*)
    rx_buffer_descriptor[i].buffer = (uint32_t *)rx_data_buffer[i];
  }

  // TX
  for (int i = 0; i < ENET_TXBD_NUM; i++) {
    // Wrap last descriptor buffer ptr
    tx_buffer_descriptor[i].control = ((i<(ENET_RXBD_NUM-1))?0:BIT(13)) | BIT(10); // (W*)+TC
    tx_buffer_descriptor[i].buffer = (uint32_t *)tx_data_buffer[i];
  }

  // Continue ENET configuration
  ENET->RDSR = (uint32_t)(uintptr_t)rx_buffer_descriptor;
  ENET->TDSR = (uint32_t)(uintptr_t)tx_buffer_descriptor;
  ENET->MRBR[0] = ENET_RXBUFF_SIZE; // Same size for RX/TX buffers

  // MAC address filtering (bytes in reversed order)
  ENET->PAUR = ((uint32_t) ifp->mac[4] << 24U) | (uint32_t) ifp->mac[5] << 16U;
  ENET->PALR = (uint32_t) (ifp->mac[0] << 24U) | ((uint32_t) ifp->mac[1] << 16U) |
                 ((uint32_t) ifp->mac[2] << 8U) | ifp->mac[3];

  // Init Hash tables (mac filtering)
  ENET->IAUR = 0; // Unicast
  ENET->IALR = 0;
  ENET->GAUR = 0; // Multicast
  ENET->GALR = 0;

  // Set ENET Online
  ENET->ECR |= BIT(8); // ENET Set Little-endian + (FEC buffer desc.)
  ENET->ECR |= BIT(1); // Enable

  // Set interrupt mask
  ENET->EIMR = EIMR_RX_ERR;

  // RX Descriptor activation
  ENET->RDAR = BIT(24); // Activate Receive Descriptor
  return true;
}
