static void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {
  uint32_t ip = 0, gw = 0, mask = 0;
  uint8_t *p = pkt->dhcp->options,
          *end = (uint8_t *) &pkt->raw.ptr[pkt->raw.len];
  if (end < (uint8_t *) (pkt->dhcp + 1)) return;
  while (p + 1 < end && p[0] != 255) {  // Parse options
    if (p[0] == 1 && p[1] == sizeof(ifp->mask) && p + 6 < end) {  // Mask
      memcpy(&mask, p + 2, sizeof(mask));
    } else if (p[0] == 3 && p[1] == sizeof(ifp->gw) && p + 6 < end) {  // GW
      memcpy(&gw, p + 2, sizeof(gw));
      ip = pkt->dhcp->yiaddr;
    } else if (p[0] == 51 && p[1] == 4 && p + 6 < end) {  // Lease
      uint32_t lease = 0;
      memcpy(&lease, p + 2, sizeof(lease));
      ifp->lease_expire = ifp->now + mg_ntohl(lease) * 1000;
    }
    p += p[1] + 2;
  }
  if (ip && mask && gw && ifp->ip == 0) {
    memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));
    ifp->ip = ip, ifp->gw = gw, ifp->mask = mask;
    ifp->state = MG_TCPIP_STATE_READY;
    onstatechange(ifp);
    tx_dhcp_request(ifp, pkt->eth->src, ip, pkt->dhcp->siaddr);
    uint64_t rand;
    mg_random(&rand, sizeof(rand));
    srand((unsigned int) (rand + mg_millis()));
  }
}
