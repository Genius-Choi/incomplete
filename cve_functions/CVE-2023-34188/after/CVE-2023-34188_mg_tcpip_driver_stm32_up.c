static bool mg_tcpip_driver_stm32_up(struct mg_tcpip_if *ifp) {
  uint32_t bsr = eth_read_phy(PHY_ADDR, PHY_BSR);
  bool up = bsr & BIT(2) ? 1 : 0;
  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up
    uint32_t scsr = eth_read_phy(PHY_ADDR, PHY_CSCR);
    uint32_t maccr = ETH->MACCR | BIT(14) | BIT(11);  // 100M, Full-duplex
    if ((scsr & BIT(3)) == 0) maccr &= ~BIT(14);      // 10M
    if ((scsr & BIT(4)) == 0) maccr &= ~BIT(11);      // Half-duplex
    ETH->MACCR = maccr;  // IRQ handler does not fiddle with this register
    MG_DEBUG(("Link is %uM %s-duplex", maccr & BIT(14) ? 100 : 10,
              maccr & BIT(11) ? "full" : "half"));
  }
  return up;
}
