static void dasher_insert_timeline_entry(GF_DasherCtx *ctx, GF_DashStream *ds)
{
	GF_MPD_SegmentTimelineEntry *s;
	u64 duration, pto, prev_patch_dur=0;
	Bool is_first = GF_FALSE;
	Bool seg_align = GF_FALSE;
	GF_MPD_SegmentTimeline *tl=NULL;

	//we only store segment timeline for the main component in the representation
	if (ds->muxed_base) return;

	if (ds->rep && ds->rep->state_seg_list) {
		GF_DASH_SegmentContext *sctx = gf_list_last(ds->rep->state_seg_list);
		if (sctx)
			sctx->dur = ds->first_cts_in_next_seg - ds->first_cts_in_seg;
	}
	//we only use segment timeline with templates
	if (!ds->stl && !ctx->do_index) return;

	if (gf_list_find(ds->set->representations, ds->rep)==0) is_first = GF_TRUE;
	assert(ds->first_cts_in_next_seg > ds->first_cts_in_seg);
	duration = ds->first_cts_in_next_seg - ds->first_cts_in_seg;

		//handle sap time adjustment (first_cts_in_seg is the SAP cts, we may have lower cts whith sap 2 or 3)
	if (ds->min_cts_in_seg_plus_one && (ds->min_cts_in_seg_plus_one-1 < ds->first_cts_in_seg)) {
		prev_patch_dur = ds->first_cts_in_seg - (ds->min_cts_in_seg_plus_one-1);
		if (ds->timescale != ds->mpd_timescale)
			prev_patch_dur = gf_timestamp_rescale(prev_patch_dur, ds->timescale, ds->mpd_timescale);
		ds->first_cts_in_seg = ds->min_cts_in_seg_plus_one-1;
		duration += prev_patch_dur;
		ds->seg_start_time -= prev_patch_dur;
	}

	pto = ds->presentation_time_offset;
	if (ds->timescale != ds->mpd_timescale) {
		duration = gf_timestamp_rescale(duration, ds->timescale, ds->mpd_timescale);

		pto = gf_timestamp_rescale(pto, ds->timescale, ds->mpd_timescale);
	}
	seg_align = (ds->set->segment_alignment || ds->set->subsegment_alignment) ? GF_TRUE : GF_FALSE;
	//not first and segment alignment, ignore
	if (!is_first && seg_align) {
		return;
	}
	if (ctx->do_index) {
		GF_MPD_SegmentURL *surl = gf_list_last(ds->rep->segment_list->segment_URLs);
		surl->duration = duration;
	}
	if (!ds->stl) return;

	//no segment alignment store in each rep
	if (!seg_align) {
		GF_MPD_SegmentTimeline **p_tl=NULL;
		if (!ds->rep) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] failed to store timeline entry, no representation assigned !\n"));
			return;
		}

		if (ctx->tpl) {
			p_tl = &ds->rep->segment_template->segment_timeline;
			ds->rep->segment_template->duration = 0;
		} else {
			p_tl = &ds->rep->segment_list->segment_timeline;
			ds->rep->segment_list->duration = 0;
		}
		if (! (*p_tl)) {
			(*p_tl) = gf_mpd_segmentimeline_new();
		}
		tl = (*p_tl);
	} else {
		Bool new_tl = GF_FALSE;
		GF_MPD_SegmentTimeline **p_tl=NULL;

		if (!ds->set) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] failed to store timeline entry, no AdpatationSet assigned !\n"));
			return;
		}
		assert(ds->set);
		if (ctx->tpl) {
			//in case we had no template at set level
			if (!ds->set->segment_template) {
				GF_SAFEALLOC(ds->set->segment_template, GF_MPD_SegmentTemplate);
				if (ds->set->segment_template) {
					ds->set->segment_template->start_number = (u32) -1;
					ds->set->segment_template->timescale = ds->mpd_timescale;
					ds->set->segment_template->presentation_time_offset = pto;
				}
				new_tl = GF_TRUE;
			}
			p_tl = &ds->set->segment_template->segment_timeline;
			ds->set->segment_template->duration = 0;
		} else {
			//in case we had no template at set level
			if (!ds->set->segment_list) {
				GF_SAFEALLOC(ds->set->segment_list, GF_MPD_SegmentList);
				if (ds->set->segment_list) {
					ds->set->segment_list->start_number = (u32) -1;
					ds->set->segment_list->timescale = ds->mpd_timescale;
					ds->set->segment_list->presentation_time_offset = pto;
				}
				new_tl = GF_TRUE;
			}
			p_tl = &ds->set->segment_list->segment_timeline;
			ds->set->segment_list->duration = 0;
		}

		if (! (*p_tl) ) {
			(*p_tl)  = gf_mpd_segmentimeline_new();
		}
		tl = (*p_tl);
		if (new_tl) {
			u32 i, count = gf_list_count(ds->set->representations);
			for (i=0; i<count; i++) {
				GF_MPD_Representation *arep = gf_list_get(ds->set->representations, i);
				if (arep && arep->segment_template) arep->segment_template->duration = 0;
				if (arep && arep->segment_list) arep->segment_list->duration = 0;
			}
		}
	}

	//append to previous entry if possible
	s = gf_list_last(tl->entries);

	if (prev_patch_dur) {
		u32 nb_ent = gf_list_count(tl->entries);
		//split entry
		if (s->repeat_count) {
			GF_MPD_SegmentTimelineEntry *next;
			s->repeat_count--;
			GF_SAFEALLOC(next, GF_MPD_SegmentTimelineEntry);
			if (!next) return;
			next->duration = (u32) (s->duration - prev_patch_dur);
			next->start_time = s->start_time + (s->repeat_count+1) * s->duration;
			gf_list_add(tl->entries, next);
			s = next;
		} else {
			//update entry
			s->duration -= (u32) prev_patch_dur;
			//merge with old one if possible
			GF_MPD_SegmentTimelineEntry *prev = (nb_ent>1) ? gf_list_get(tl->entries, nb_ent-2) : NULL;
			if (prev && (prev->duration==s->duration) && (prev->start_time + (prev->repeat_count+1) * prev->duration == s->start_time)) {
				prev->repeat_count++;
				gf_list_pop_back(tl->entries);
				gf_free(s);
				s=prev;
			}
		}
	}

	if (s && (s->duration == duration) && (s->start_time + (s->repeat_count+1) * s->duration == ds->seg_start_time + pto)) {
		s->repeat_count++;
		return;
	}

	//nope, allocate
	GF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);
	if (!s) return;
	s->start_time = ds->seg_start_time + pto;
	s->duration = (u32) duration;
	gf_list_add(tl->entries, s);
}
