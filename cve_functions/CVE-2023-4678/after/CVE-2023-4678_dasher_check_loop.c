static Bool dasher_check_loop(GF_DasherCtx *ctx, GF_DashStream *ds)
{
	u32 i, count;
	u32 pmode = GF_PLAYBACK_MODE_NONE;
	u64 ts_offset, max_ts_offset, max_ts_scale;
	const GF_PropertyValue *p;
	if (!ds->src_url) return GF_FALSE;

	//loop requested
	if (ds->loop_state==2) return GF_TRUE;

	count = gf_list_count(ctx->current_period->streams);
	if (!ds->loop_state) {
		for (i=0; i<count; i++) {
			GF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);

			p = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PLAYBACK_MODE);
			if (p) pmode = p->value.uint;
			if (pmode == GF_PLAYBACK_MODE_NONE) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Loop requested in subdur mode, but source cannot seek, defaulting to multi period for all streams\n"));
				ctx->loop = GF_FALSE;
				return GF_FALSE;
			}
		}
		ds->loop_state = 1;
	}

	max_ts_offset = 0;
	max_ts_scale = 1;
	//check all input media duration
	for (i=0; i<count; i++) {
		GF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);

		//one pid is waiting for loop while another has done its subdur and won't process any new segment until the next subdur call, which
		//will never happen since the first PID waits for loop. We must force early generation in this case
		if (a_ds->subdur_done) {
			a_ds->subdur_done = GF_FALSE;
			//remember the max period dur before this forced segment generation
			a_ds->subdur_forced_use_period_dur = a_ds->max_period_dur;
		}

		//wait for each input to query loop
		if (!a_ds->loop_state) {
			a_ds->done = 0;
			return GF_TRUE;
		}

		//get max duration
		ts_offset = a_ds->est_next_dts;

		if (gf_timestamp_less(max_ts_offset, max_ts_scale, ts_offset, a_ds->timescale)) {
			max_ts_offset = ts_offset;
			max_ts_scale = a_ds->timescale;
		}
	}

	//assign ts offset and send stop/play
	for (i=0; i<count; i++) {
		GF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);

		if (a_ds->subdur_done)
			continue;

		ts_offset = gf_timestamp_rescale(max_ts_offset, max_ts_scale, a_ds->timescale);

		a_ds->ts_offset = ts_offset;
		if (a_ds->done) continue;
		if (a_ds->ts_offset > a_ds->est_next_dts) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Looping streams of unequal duration, inserting "LLU" us of timestamp delay in pid %s from %s\n", ((a_ds->ts_offset - a_ds->est_next_dts) * 1000000) / a_ds->timescale, gf_filter_pid_get_name(a_ds->ipid), a_ds->src_url));
		}

		a_ds->seek_to_pck = 0;
		a_ds->nb_pck = 0;
		a_ds->clamp_done = GF_FALSE;

		a_ds->loop_state = 2;

		if (ctx->subdur) {
			GF_FilterEvent evt;

			GF_FEVT_INIT(evt, GF_FEVT_STOP, a_ds->ipid);
			gf_filter_pid_send_event(a_ds->ipid, &evt);

			gf_filter_pid_set_discard(a_ds->ipid, GF_FALSE);

			dasher_send_encode_hints(ctx, ds);

			GF_FEVT_INIT(evt, GF_FEVT_PLAY, a_ds->ipid);
			evt.play.speed = 1.0;
			gf_filter_pid_send_event(a_ds->ipid, &evt);
		}
	}

	return GF_TRUE;
}
