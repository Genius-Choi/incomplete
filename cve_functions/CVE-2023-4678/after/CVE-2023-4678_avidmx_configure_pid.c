GF_Err avidmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)
{
	const GF_PropertyValue *p;
	GF_AVIDmxCtx *ctx = gf_filter_get_udta(filter);

	if (is_remove) {
		ctx->ipid = NULL;
		if (ctx->v_opid) {
			gf_filter_pid_remove(ctx->v_opid);
			ctx->v_opid = NULL;
		}
		while (gf_list_count(ctx->audios) ) {
			AVIAstream *st = gf_list_pop_back(ctx->audios);
			if (st->opid)
				gf_filter_pid_remove(st->opid);
			gf_free(st);
		}
		return GF_OK;
	}
	if (! gf_filter_pid_check_caps(pid))
		return GF_NOT_SUPPORTED;

	if (!ctx->ipid) {
		GF_FilterEvent fevt;
		ctx->ipid = pid;

		//we work with full file only, send a play event on source to indicate that
		GF_FEVT_INIT(fevt, GF_FEVT_PLAY_HINT, pid);
		fevt.play.start_range = 0;
		fevt.base.on_pid = ctx->ipid;
		fevt.play.full_file_only = GF_TRUE;
		gf_filter_pid_send_event(ctx->ipid, &fevt);
	}

	p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);
	if (!p) return GF_NOT_SUPPORTED;

	if (ctx->src_url && !strcmp(ctx->src_url, p->value.string)) return GF_OK;

	if (ctx->avi) {
		u32 i;
		AVI_close(ctx->avi);
		ctx->v_in_use = GF_FALSE;
		for (i=0; i<gf_list_count(ctx->audios); i++) {
			AVIAstream *st = gf_list_get(ctx->audios, i);
			st->in_use = GF_FALSE;
		}
	}
	ctx->avi = NULL;

	ctx->src_url = p->value.string;

	return GF_OK;
}
