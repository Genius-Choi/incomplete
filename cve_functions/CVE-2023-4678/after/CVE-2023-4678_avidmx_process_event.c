static Bool avidmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)
{
	GF_AVIDmxCtx *ctx = gf_filter_get_udta(filter);

	switch (evt->base.type) {
	case GF_FEVT_PLAY:
		gf_filter_post_process_task(filter);
		if (evt->base.on_pid==ctx->v_opid) {
			u32 frame_idx = 0;
			ctx->v_playing = GF_TRUE;
			ctx->video_done = GF_FALSE;
			if ((evt->play.start_range==0) && !ctx->v_init_play_done) {
				ctx->v_init_play_done = GF_TRUE;
				return GF_TRUE;
			}
			ctx->v_init_play_done = GF_TRUE;
			frame_idx = (u32) (ctx->avi->fps * evt->play.start_range);
			if (frame_idx) {
#ifdef GPAC_ENABLE_COVERAGE
				if (gf_sys_is_cov_mode()) {
					AVI_seek_start(ctx->avi);
				}
#endif
				AVI_set_video_position(ctx->avi, frame_idx);
			} else {
				AVI_seek_start(ctx->avi);
				gf_filter_post_process_task(filter);
			}
			ctx->cur_frame = frame_idx;
		} else {
			u32 i;
			for (i=0; i<gf_list_count(ctx->audios); i++) {
				AVIAstream *st = gf_list_get(ctx->audios, i);
				if (st->opid != evt->base.on_pid) continue;
				st->playing = GF_TRUE;
				st->audio_done = GF_FALSE;
				if ((evt->play.start_range==0) && !st->init_play_done) {
					st->init_play_done = GF_TRUE;
					return GF_TRUE;
				}
				st->init_play_done = GF_TRUE;
				AVI_set_audio_position(ctx->avi, 0);
				st->seek_to_ts = (u32) (evt->play.start_range * st->freq);
			}
		}

		//cancel play event, we work with full file
		return GF_TRUE;

	case GF_FEVT_STOP:
		if (evt->base.on_pid==ctx->v_opid) {
			ctx->v_playing = GF_FALSE;
		} else {
			u32 i;
			for (i=0; i<gf_list_count(ctx->audios); i++) {
				AVIAstream *st = gf_list_get(ctx->audios, i);
				if (st->opid != evt->base.on_pid) continue;
				st->playing = GF_FALSE;
			}
		}
		//don't cancel event
		return GF_FALSE;

	case GF_FEVT_SET_SPEED:
		//cancel event
		return GF_TRUE;
	default:
		break;
	}
	//by default don't cancel event - to rework once we have downloading in place
	return GF_FALSE;
}
