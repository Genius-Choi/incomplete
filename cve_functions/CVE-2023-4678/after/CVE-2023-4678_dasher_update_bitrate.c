static void dasher_update_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)
{
	u64 rate;
	u32 scaler;
	if (!ds->dyn_bitrate || ds->bitrate) {
		return;
	}

	if (!ds->rate_first_dts_plus_one) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Couldn't compute bitrate of PID %s in time for manifest generation, please specify #Bitrate property\n", gf_filter_pid_get_name(ds->ipid)));
		return;
	}

	rate = ds->rate_media_size;
	rate *= 8;
	if (ds->rate_last_dts > ds->rate_first_dts_plus_one - 1) {
		rate *= ds->timescale;
		rate /= (ds->rate_last_dts - ds->rate_first_dts_plus_one + 1);
	} else {
		rate *= ds->dash_dur.den;
		rate /= ds->dash_dur.num;
	}
	//express rates in 100kbps or 10kbps, and if ds is done, trust the average, otherwise add 10%
	scaler = (rate > 1000000) ? 100000 : 10000;
	if (rate > 10*scaler) {
		rate /= scaler;
		if (!ds->done) scaler = 11 * scaler / 10;
		rate *= scaler;
	}

	ds->bitrate = (u32) rate;

	if (ds->rep) {
		ds->rep->bandwidth = ds->bitrate;

		if (ds->dep_id) {
			ds->rep->bandwidth = dasher_get_dep_bitrate(ctx, ds);
		} else if (ds->nb_comp && !ds->muxed_base) {
			u32 i, count = gf_list_count(ctx->current_period->streams);
			for (i=0; i<count; i++) {
				GF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);
				if (ds == a_ds) continue;
				if (a_ds->muxed_base != ds) continue;
				if (a_ds->dyn_bitrate) {
					dasher_update_bitrate(ctx, a_ds);
				}
				ds->rep->bandwidth += a_ds->bitrate;
			}
		}
	}

	//keep refreshing our rate estimation
	if (!ds->done && (ds->dyn_bitrate==1))
		ds->bitrate = 0;
}
