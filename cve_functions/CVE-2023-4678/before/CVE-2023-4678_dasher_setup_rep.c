static void dasher_setup_rep(GF_DasherCtx *ctx, GF_DashStream *ds, u32 *srd_rep_idx)
{
	const GF_PropertyValue *p;

	assert(ds->rep==NULL);
	ds->rep = gf_mpd_representation_new();
	ds->rep->playback.udta = ds;
	if (ds->tci)
		ds->rep->crypto_type = 1;
	else
		ds->rep->crypto_type = ds->is_encrypted ? 2 : 0;

	dasher_update_rep(ctx, ds);
	ds->rep->streamtype = ds->stream_type;

	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_AS_ID);
	//do not reset as id in case of period continuity
	if (p) {
		if (ds->as_id != p->value.uint) {
			if (ds->period_continuity_id) gf_free(ds->period_continuity_id);
			ds->period_continuity_id = NULL;
		}
		ds->as_id = p->value.uint;
	}

	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_REP_ID);
	if (p) {
		if (ds->rep_id) gf_free(ds->rep_id);

		if (!ds->tile_base && (ds->srd.w || ds->srd.z) && !ctx->sseg && !ctx->sfile) {
			char *rep_name = gf_malloc(sizeof(char) * (strlen(p->value.string) + 15) );
			sprintf(rep_name, "%s_%d", p->value.string, *srd_rep_idx);
			ds->rep_id = rep_name;
			(*srd_rep_idx) ++;
		} else {
			ds->rep_id = gf_strdup(p->value.string);
		}

	} else if (!ds->rep_id) {
		char szRepID[20];
		sprintf(szRepID, "%d", 1 + gf_list_find(ctx->pids, ds));
		ds->rep_id = gf_strdup(szRepID);
	}
	ds->rep->id = gf_strdup(ds->rep_id);

	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_EXT_MASTER);
	if (p) {
		ds->rep->nb_hls_master_tags = p->value.string_list.nb_items;
		ds->rep->hls_master_tags = (const char **) p->value.string_list.vals;
	}
	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_EXT_VARIANT);
	if (p) {
		ds->rep->nb_hls_variant_tags = p->value.string_list.nb_items;
		ds->rep->hls_variant_tags = (const char **) p->value.string_list.vals;
	}

	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);
	if (p && ctx->do_index) {
		char *dst = gf_filter_pid_get_destination(ctx->opid);
		if (dst) {
			char *opath=NULL, *ipath=NULL;
			if (gf_url_is_relative(p->value.string) && (p->value.string[0]!='.'))
				gf_dynstrcat(&opath, "./", NULL);
			gf_dynstrcat(&opath, p->value.string, NULL);
			if (gf_url_is_relative(dst) && (dst[0]!='.'))
				gf_dynstrcat(&ipath, "./", NULL);
			gf_dynstrcat(&ipath, dst, NULL);

			ds->rep->res_url = gf_url_concatenate_parent(ipath, opath);
			gf_free(ipath);
			gf_free(opath);
		} else {
			ds->rep->res_url = gf_strdup(p->value.string);
		}
		if (dst) gf_free(dst);
		p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_ID);
		ds->rep->trackID = p ? p->value.uint : 0;

		if (ctx->do_index==2) {
			if (!ds->rep->x_children) ds->rep->x_children = gf_list_new();
			u32 idx=0;
			char *obuf=NULL;
			u32 obuf_alloc = 0;
			while (1) {
				u32 p4cc;
				const char *pname;
				p = gf_filter_pid_enum_properties(ds->ipid, &idx, &p4cc, &pname);
				if (!p) break;
				switch (p4cc) {
				case GF_PROP_PID_ID:
				case GF_PROP_PID_URL:
				case GF_PROP_PID_FILEPATH:
				case GF_PROP_PID_FILE_EXT:
				case GF_PROP_PID_FILE_CACHED:
				case GF_PROP_PID_DOWN_SIZE:
				case GF_PROP_PID_DOWNLOAD_SESSION:
				case GF_PROP_PID_TRACK_NUM:
				case GF_PROP_PID_MEDIA_DATA_SIZE:
				case GF_PROP_PID_MAX_FRAME_SIZE:
				case GF_PROP_PID_AVG_FRAME_SIZE:
				case GF_PROP_PID_MAX_TS_DELTA:
				case GF_PROP_PID_CONSTANT_DURATION:
				case GF_PROP_PID_PLAYBACK_MODE:
				case GF_PROP_PID_CHAP_TIMES:
				case GF_PROP_PID_CHAP_NAMES:
				case GF_PROP_PID_ISOM_UDTA:
					continue;
				default:
					break;
				}
				if (p->type == GF_PROP_POINTER) continue;

				GF_XMLNode *prop = gf_xml_dom_node_new(NULL, "prop");
				prop->attributes = gf_list_new();
				gf_list_add(ds->rep->x_children,  prop);
				prop->orig_pos = -1;
				GF_XMLAttribute *att;
				if (p4cc) {
					att = gf_xml_dom_create_attribute("type", gf_props_4cc_get_name(p4cc));
					gf_list_add(prop->attributes, att);
				} else {
					att = gf_xml_dom_create_attribute("name", pname);
					gf_list_add(prop->attributes, att);
					att = gf_xml_dom_create_attribute("ptype", gf_props_get_type_name(p->type));
					gf_list_add(prop->attributes, att);
				}
				char szDump[GF_PROP_DUMP_ARG_SIZE];
				u32 res, obuf_size, j;
				char *cdata=NULL;

				switch (p->type) {
				case GF_PROP_DATA:
				case GF_PROP_DATA_NO_COPY:
				case GF_PROP_CONST_DATA:
					obuf_size = p->value.data.size*3;
					if (obuf_size>obuf_alloc) {
						obuf = gf_realloc(obuf, sizeof(char)*obuf_size);
						obuf_alloc = obuf_size;
					}
					res = gf_base64_encode(p->value.data.ptr, p->value.data.size, obuf, obuf_size);
					obuf[res] = 0;
					att = gf_xml_dom_create_attribute("value", obuf);
					gf_list_add(prop->attributes, att);
					break;
				case GF_PROP_STRING_LIST:
					for (j=0; j<p->value.string_list.nb_items; j++) {
						gf_dynstrcat( &cdata, p->value.string_list.vals[j], ",");
					}
					j = (u32) (strlen(cdata)+1);
					obuf_size = j*3;
					if (obuf_size>obuf_alloc) {
						obuf = gf_realloc(obuf, sizeof(char)*obuf_size);
						obuf_alloc = obuf_size;
					}
					res = gf_base64_encode(cdata, j, obuf, obuf_size);
					obuf[res] = 0;
					att = gf_xml_dom_create_attribute("value", obuf);
					gf_list_add(prop->attributes, att);
					gf_free(cdata);
					break;
				default:
					att = gf_xml_dom_create_attribute("value", gf_props_dump(p4cc, p, szDump, GF_PROP_DUMP_NO_REDUCE));
					gf_list_add(prop->attributes, att);
					break;
				}
			}
			if (obuf) gf_free(obuf);
		}
	}
}
