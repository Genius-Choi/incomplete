static char *dasher_strip_base(GF_DasherCtx *ctx, GF_DashStream *ds, char *seg_url, char *seg_name)
{
	if (ctx->keep_src) return gf_strdup(seg_name);

	const GF_PropertyValue *mpd_url = gf_filter_pid_get_property_str(ds->ipid, "manifest_url");
	if (!mpd_url || !ctx->out_path) return gf_strdup(seg_url);

	Bool gf_url_is_relative(const char *pathName);
	char *url, *mpd_out, *mpd_src_alloc=NULL;
	mpd_out = gf_file_basename(ctx->out_path);
	u32 len = (u32) (mpd_out - ctx->out_path);
	char *mpd_src = mpd_url->value.string;

	if (!strncmp(ctx->out_path, mpd_url->value.string, len)) {
		mpd_src += len;
	} else if (gf_url_is_relative(ctx->out_path) && gf_url_is_relative(mpd_src)) {
		char *opath=NULL, *ipath=NULL;
		if (ctx->out_path[0]!='.') gf_dynstrcat(&opath, "./", NULL);
		gf_dynstrcat(&opath, ctx->out_path, NULL);
		if (mpd_src[0]!='.') gf_dynstrcat(&ipath, "./", NULL);
		gf_dynstrcat(&ipath, mpd_src, NULL);

		mpd_src_alloc = gf_url_concatenate_parent(opath, ipath);
		mpd_src = mpd_src_alloc;
		if (opath) gf_free(opath);
		if (ipath) gf_free(ipath);
	} else {
		return gf_strdup(seg_name);
	}

	url = gf_url_concatenate(mpd_src, seg_name);
	return url;
}
