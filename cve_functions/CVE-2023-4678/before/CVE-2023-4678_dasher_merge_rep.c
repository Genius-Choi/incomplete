static Bool dasher_merge_rep(GF_DashStream *ds, GF_MPD_Representation *rep)
{
	Bool transcode_detected = GF_FALSE;
	Bool recompute_set = GF_FALSE;
	GF_MPD_Representation *n_rep = ds->rep;

	//TODO: copy other properties in case we transcode ?

#define CHECK_VAL(_name, _v) if (rep->_name != n_rep->_name) { rep->_name = n_rep->_name; transcode_detected = GF_TRUE; if (_v) recompute_set = GF_TRUE; }

#define CHECK_STR(_name) if (rep->_name && n_rep->_name && !strcmp(rep->_name, n_rep->_name)) {} \
	else if (!rep->_name && !n_rep->_name) {}\
	else { \
		if (rep->_name) gf_free(rep->_name); \
		rep->_name = n_rep->_name ? gf_strdup(n_rep->_name) : NULL; \
		transcode_detected = GF_TRUE; \
	}

//for frac, if not set on source PID, consider it unchanged
#define CHECK_FRAC(_name) if (rep->_name && n_rep->_name && (rep->_name->num * n_rep->_name->den == rep->_name->den * n_rep->_name->num)) {} \
	else if (!n_rep->_name) {}\
	else { \
		if (rep->_name) gf_free(rep->_name); \
		if (n_rep->_name) { rep->_name = gf_malloc(sizeof(GF_MPD_Fractional)); memcpy(rep->_name, n_rep->_name, sizeof(GF_MPD_Fractional)); } \
		else rep->_name = NULL; \
		transcode_detected = GF_TRUE; \
	}

	CHECK_STR(codecs)
	CHECK_STR(profiles)
	CHECK_STR(mime_type)
	CHECK_STR(segmentProfiles)
	CHECK_VAL(width, 1)
	CHECK_VAL(height, 1)
	CHECK_VAL(bandwidth, 0)
	CHECK_VAL(samplerate, 0)
	CHECK_VAL(scan_type, 0)
	CHECK_FRAC(sar)
	CHECK_FRAC(framerate)

	if (transcode_detected && !ds->transcode_detected) {
		ds->transcode_detected = GF_TRUE;
		GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Transcoded detected in forward mode, not fully tested !\n"));
	}
#undef CHECK_VAL
#undef CHECK_STR
#undef CHECK_FRAC

	return recompute_set;
}
