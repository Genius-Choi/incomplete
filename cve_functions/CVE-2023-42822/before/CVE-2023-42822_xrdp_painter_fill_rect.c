xrdp_painter_fill_rect(struct xrdp_painter *self,
                       struct xrdp_bitmap *dst,
                       int x, int y, int cx, int cy)
{
    struct xrdp_rect clip_rect;
    struct xrdp_rect draw_rect;
    struct xrdp_rect rect;
    struct xrdp_region *region;
    struct xrdp_brush brush;
    int k;
    int dx;
    int dy;
    int rop;

    LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_fill_rect:");

    if (self == 0)
    {
        return 0;
    }

    dx = 0;
    dy = 0;

    if (self->painter != 0)
    {
#if defined(XRDP_PAINTER)
        struct painter_bitmap dst_pb;
        struct xrdp_bitmap *ldst;
        struct painter_bitmap pat;

        LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_fill_rect: dst->type %d", dst->type);
        if (dst->type != WND_TYPE_OFFSCREEN)
        {
            LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_fill_rect: using painter");

            ldst = self->wm->screen;

            g_memset(&dst_pb, 0, sizeof(dst_pb));
            dst_pb.format = get_pt_format(self);
            dst_pb.width = ldst->width;
            dst_pb.stride_bytes = ldst->line_size;
            dst_pb.height = ldst->height;
            dst_pb.data = ldst->data;

            LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_fill_rect: ldst->width %d ldst->height %d "
                      "dst->data %p self->fg_color %d",
                      ldst->width, ldst->height, ldst->data, self->fg_color);

            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);
            region = xrdp_region_create(self->wm);
            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,
                                   self->clip_children);
            x += dx;
            y += dy;

            rop = self->rop;
            switch (self->rop)
            {
                case 0x5a:
                    rop = PT_ROP_DSx;
                    break;
                case 0xf0:
                    rop = PT_ROP_S;
                    break;
                case 0xfb:
                    rop = PT_ROP_D;
                    break;
                case 0xc0:
                    rop = PT_ROP_DSa;
                    break;
            }
            painter_set_rop(self->painter, rop);

            if (self->mix_mode == 0)
            {
                painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_OPAQUE);
                painter_set_fgcolor(self->painter, get_rgb_from_rdp_color(self, self->fg_color));
                k = 0;
                while (xrdp_region_get_rect(region, k, &rect) == 0)
                {
                    if (rect_intersect(&rect, &clip_rect, &draw_rect))
                    {
                        painter_set_clip(self->painter,
                                         draw_rect.left, draw_rect.top,
                                         draw_rect.right - draw_rect.left,
                                         draw_rect.bottom - draw_rect.top);
                        painter_fill_rect(self->painter, &dst_pb, x, y, cx, cy);
                        xrdp_painter_add_dirty_rect(self, x, y, cx, cy, &draw_rect);
                    }
                    k++;
                }
            }
            else
            {
                painter_set_pattern_mode(self->painter, PT_PATTERN_MODE_OPAQUE);
                painter_set_fgcolor(self->painter, get_rgb_from_rdp_color(self, self->fg_color));
                painter_set_bgcolor(self->painter, get_rgb_from_rdp_color(self, self->bg_color));
                painter_set_pattern_origin(self->painter, self->brush.x_origin, self->brush.y_origin);
                g_memset(&pat, 0, sizeof(pat));
                pat.format = PT_FORMAT_c1;
                pat.width = 8;
                pat.stride_bytes = 1;
                pat.height = 8;
                pat.data = self->brush.pattern;
                k = 0;
                while (xrdp_region_get_rect(region, k, &rect) == 0)
                {
                    if (rect_intersect(&rect, &clip_rect, &draw_rect))
                    {
                        painter_set_clip(self->painter,
                                         draw_rect.left, draw_rect.top,
                                         draw_rect.right - draw_rect.left,
                                         draw_rect.bottom - draw_rect.top);
                        painter_fill_pattern(self->painter, &dst_pb, &pat,
                                             x, y, x, y, cx, cy);
                        xrdp_painter_add_dirty_rect(self, x, y, cx, cy, &draw_rect);
                    }
                    k++;
                }
            }
            painter_clear_clip(self->painter);
            xrdp_region_delete(region);
        }
        return 0;
#endif
    }

    /* todo data */

    if (dst->type == WND_TYPE_BITMAP) /* 0 */
    {
        return 0;
    }

    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);
    region = xrdp_region_create(self->wm);

    if (dst->type != WND_TYPE_OFFSCREEN)
    {
        xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy, region,
                               self->clip_children);
    }
    else
    {
        xrdp_region_add_rect(region, &clip_rect);
    }

    x += dx;
    y += dy;

    if (self->mix_mode == 0 && self->rop == 0xcc)
    {
        k = 0;

        while (xrdp_region_get_rect(region, k, &rect) == 0)
        {
            if (rect_intersect(&rect, &clip_rect, &draw_rect))
            {
                libxrdp_orders_rect(self->session, x, y, cx, cy,
                                    self->fg_color, &draw_rect);
            }

            k++;
        }
    }
    else if (self->mix_mode == 0 &&
             ((self->rop & 0xf) == 0x0 || /* black */
              (self->rop & 0xf) == 0xf || /* white */
              (self->rop & 0xf) == 0x5))  /* DSTINVERT */
    {
        k = 0;

        while (xrdp_region_get_rect(region, k, &rect) == 0)
        {
            if (rect_intersect(&rect, &clip_rect, &draw_rect))
            {
                libxrdp_orders_dest_blt(self->session, x, y, cx, cy,
                                        self->rop, &draw_rect);
            }

            k++;
        }
    }
    else
    {
        k = 0;
        rop = self->rop;

        /* if opcode is in the form 0x00, 0x11, 0x22, ... convert it */
        if (((rop & 0xf0) >> 4) == (rop & 0xf))
        {
            switch (rop)
            {
                case 0x66: /* xor */
                    rop = 0x5a;
                    break;
                case 0xaa: /* noop */
                    rop = 0xfb;
                    break;
                case 0xcc: /* copy */
                    rop = 0xf0;
                    break;
                case 0x88: /* and */
                    rop = 0xc0;
                    break;
            }
        }

        xrdp_painter_setup_brush(self, &brush, &self->brush);

        while (xrdp_region_get_rect(region, k, &rect) == 0)
        {
            if (rect_intersect(&rect, &clip_rect, &draw_rect))
            {
                libxrdp_orders_pat_blt(self->session, x, y, cx, cy,
                                       rop, self->bg_color, self->fg_color,
                                       &brush, &draw_rect);
            }

            k++;
        }
    }

    xrdp_region_delete(region);
    return 0;
}
