int pico_tcp_reply_rst(struct pico_stack *S, struct pico_frame *fr)
{
    struct pico_tcp_hdr *hdr, *hdr1;
    struct pico_frame *f;
    uint16_t size = PICO_SIZE_TCPHDR;


    hdr1 = (struct pico_tcp_hdr *) (fr->transport_hdr);
    if ((hdr1->flags & PICO_TCP_RST) != 0)
        return -1;

    tcp_dbg("TCP> sending RST ... \n");

    f = fr->sock->net->alloc(fr->sock->stack, fr->sock->net, NULL, size);
    if (!f) {
        pico_err = PICO_ERR_ENOMEM;
        return -1;
    }

    tcp_fill_rst_payload(fr, f);

    hdr = (struct pico_tcp_hdr *) f->transport_hdr;
    hdr->len   = (uint8_t)(size << 2);
    hdr->flags = PICO_TCP_RST;

    tcp_fill_rst_header(fr, hdr1, f, hdr);

    if (0) {
#ifdef PICO_SUPPORT_IPV4
    } else if (IS_IPV4(f)) {
        tcp_dbg("Pushing IPv4 reset frame...\n");
        pico_ipv4_frame_push(S, f, &(((struct pico_ipv4_hdr *)(f->net_hdr))->dst), PICO_PROTO_TCP);
#endif
#ifdef PICO_SUPPORT_IPV6
    } else {
        pico_ipv6_frame_push(S, f, NULL, &(((struct pico_ipv6_hdr *)(f->net_hdr))->dst), PICO_PROTO_TCP, 0);
#endif
    }


    return 0;
}
