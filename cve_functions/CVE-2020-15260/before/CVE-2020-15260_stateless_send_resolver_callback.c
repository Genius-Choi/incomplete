stateless_send_resolver_callback( pj_status_t status,
				  void *token,
				  const struct pjsip_server_addresses *addr)
{
    pjsip_send_state *stateless_data = (pjsip_send_state*) token;
    pjsip_tx_data *tdata = stateless_data->tdata;

    /* Fail on server resolution. */
    if (status != PJ_SUCCESS) {
	if (stateless_data->app_cb) {
	    pj_bool_t cont = PJ_FALSE;
	    (*stateless_data->app_cb)(stateless_data, -status, &cont);
	}
	pjsip_tx_data_dec_ref(tdata);
	return;
    }

    /* Copy server addresses */
    if (addr && addr != &tdata->dest_info.addr) {
	pj_memcpy( &tdata->dest_info.addr, addr, 
	           sizeof(pjsip_server_addresses));
    }
    pj_assert(tdata->dest_info.addr.count != 0);

    /* RFC 3261 section 18.1.1:
     * If a request is within 200 bytes of the path MTU, or if it is larger
     * than 1300 bytes and the path MTU is unknown, the request MUST be sent
     * using an RFC 2914 [43] congestion controlled transport protocol, such
     * as TCP.
     */
    if (pjsip_cfg()->endpt.disable_tcp_switch==0 &&
	tdata->msg->type == PJSIP_REQUEST_MSG &&
	tdata->dest_info.addr.count > 0 && 
	tdata->dest_info.addr.entry[0].type == PJSIP_TRANSPORT_UDP)
    {
	int len;

	/* Encode the request */
	status = pjsip_tx_data_encode(tdata);
	if (status != PJ_SUCCESS) {
	    if (stateless_data->app_cb) {
		pj_bool_t cont = PJ_FALSE;
		(*stateless_data->app_cb)(stateless_data, -status, &cont);
	    }
	    pjsip_tx_data_dec_ref(tdata);
	    return;
	}

	/* Check if request message is larger than 1300 bytes. */
	len = (int)(tdata->buf.cur - tdata->buf.start);
	if (len >= PJSIP_UDP_SIZE_THRESHOLD) {
	    int i;
	    int count = tdata->dest_info.addr.count;

	    PJ_LOG(5,(THIS_FILE, "%s exceeds UDP size threshold (%u), "
				 "sending with TCP",
				 pjsip_tx_data_get_info(tdata),
				 PJSIP_UDP_SIZE_THRESHOLD));

	    /* Insert "TCP version" of resolved UDP addresses at the
	     * beginning.
	     */
	    if (count * 2 > PJSIP_MAX_RESOLVED_ADDRESSES)
		count = PJSIP_MAX_RESOLVED_ADDRESSES / 2;
	    for (i = 0; i < count; ++i) {
		pj_memcpy(&tdata->dest_info.addr.entry[i+count],
			  &tdata->dest_info.addr.entry[i],
			  sizeof(tdata->dest_info.addr.entry[0]));
		tdata->dest_info.addr.entry[i].type = PJSIP_TRANSPORT_TCP;
	    }
	    tdata->dest_info.addr.count = count * 2;
	}
    }

    /* Process the addresses. */
    stateless_send_transport_cb( stateless_data, tdata, -PJ_EPENDING);
}
