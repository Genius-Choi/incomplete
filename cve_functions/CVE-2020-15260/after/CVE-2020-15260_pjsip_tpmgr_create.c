PJ_DEF(pj_status_t) pjsip_tpmgr_create( pj_pool_t *pool,
					pjsip_endpoint *endpt,
					pjsip_rx_callback rx_cb,
					pjsip_tx_callback tx_cb,
					pjsip_tpmgr **p_mgr)
{
    pjsip_tpmgr *mgr;
    pj_status_t status;
    unsigned i = 0;
    pj_pool_t *mgr_pool;

    PJ_ASSERT_RETURN(pool && endpt && rx_cb && p_mgr, PJ_EINVAL);

    /* Register mod_msg_print module. */
    status = pjsip_endpt_register_module(endpt, &mod_msg_print);
    if (status != PJ_SUCCESS)
	return status;

    /* Create and initialize transport manager. */
    mgr_pool = pjsip_endpt_create_pool(endpt, "tpmgr",
				       TPMGR_POOL_INIT_SIZE,
				       TPMGR_POOL_INC_SIZE);
    mgr = PJ_POOL_ZALLOC_T(mgr_pool, pjsip_tpmgr);
    mgr->endpt = endpt;
    mgr->on_rx_msg = rx_cb;
    mgr->on_tx_msg = tx_cb;
    mgr->pool = mgr_pool;

    if (!mgr->pool)
	return PJ_ENOMEM;

    pj_list_init(&mgr->factory_list);
    pj_list_init(&mgr->tdata_list);
    pj_list_init(&mgr->tp_entry_freelist);

    mgr->table = pj_hash_create(mgr->pool, PJSIP_TPMGR_HTABLE_SIZE);
    if (!mgr->table)
	return PJ_ENOMEM;

    status = pj_lock_create_recursive_mutex(mgr->pool, "tmgr%p", &mgr->lock);
    if (status != PJ_SUCCESS)
	return status;

    for (; i < PJSIP_TRANSPORT_ENTRY_ALLOC_CNT; ++i) {
	transport *tp_add = NULL;

	tp_add = PJ_POOL_ZALLOC_T(mgr->pool, transport);
	if (!tp_add)
	    return PJ_ENOMEM;
	pj_list_init(tp_add);
	pj_list_push_back(&mgr->tp_entry_freelist, tp_add);
    }

#if defined(PJ_DEBUG) && PJ_DEBUG!=0
    status = pj_atomic_create(mgr->pool, 0, &mgr->tdata_counter);
    if (status != PJ_SUCCESS) {
    	pj_lock_destroy(mgr->lock);
    	return status;
    }
#endif

    /* Set transport state callback */
    pjsip_tpmgr_set_state_cb(mgr, &tp_state_callback);

    PJ_LOG(5, (THIS_FILE, "Transport manager created."));

    *p_mgr = mgr;
    return PJ_SUCCESS;
}
