PJ_DEF(pj_status_t) pjsip_transport_add_ref( pjsip_transport *tp )
{
    pjsip_tpmgr *tpmgr;
    pjsip_transport_key key;
    int key_len;

    PJ_ASSERT_RETURN(tp != NULL, PJ_EINVAL);

    /* Add ref transport group lock, if any */
    if (tp->grp_lock)
	pj_grp_lock_add_ref(tp->grp_lock);

    /* Cache some vars for checking transport validity later */
    tpmgr = tp->tpmgr;
    key_len = sizeof(tp->key.type) + tp->addr_len;
    pj_memcpy(&key, &tp->key, key_len);

    if (pj_atomic_inc_and_get(tp->ref_cnt) == 1) {
	pj_lock_acquire(tpmgr->lock);
	/* Verify again. But first, make sure transport is still valid
	 * (see #1883).
	 */
	if (is_transport_valid(tp, tpmgr, &key, key_len) &&
	    pj_atomic_get(tp->ref_cnt) == 1)
	{
	    if (tp->idle_timer.id != PJ_FALSE) {
		tp->idle_timer.id = PJ_FALSE;
		pjsip_endpt_cancel_timer(tp->tpmgr->endpt, &tp->idle_timer);
	    }
	}
	pj_lock_release(tpmgr->lock);
    }

    return PJ_SUCCESS;
}
