static void transport_idle_callback(pj_timer_heap_t *timer_heap,
				    struct pj_timer_entry *entry)
{
    pjsip_transport *tp = (pjsip_transport*) entry->user_data;
    pj_assert(tp != NULL);

    PJ_UNUSED_ARG(timer_heap);

    if (entry->id == PJ_FALSE)
	return;

    entry->id = PJ_FALSE;

    /* Set is_destroying flag under transport manager mutex to avoid
     * race condition with pjsip_tpmgr_acquire_transport2().
     */
    pj_lock_acquire(tp->tpmgr->lock);
    if (pj_atomic_get(tp->ref_cnt) == 0) {
	tp->is_destroying = PJ_TRUE;
    } else {
	pj_lock_release(tp->tpmgr->lock);
	return;
    }
    pj_lock_release(tp->tpmgr->lock);

    pjsip_transport_destroy(tp);
}
