static void gf_fs_print_filter_outputs(GF_Filter *f, GF_List *filters_done, u32 indent, GF_FilterPid *pid, GF_Filter *alias_for, u32 src_num_tiled_pids, Bool skip_print, s32 nb_recursion, u32 max_length)
{
	u32 i=0;

	if (!skip_print) {
		while (i<indent) {
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, ("-"));
			i++;
		}

		if (src_num_tiled_pids>1) {
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, ("(tilePID[%d]) ", src_num_tiled_pids));
		}
		else if (pid) {
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, ("(PID %s)", pid->name));
		}
		if (max_length) {
			u32 l;
			if (src_num_tiled_pids) {
				char szName[50];
				sprintf(szName, "PID[%d]", src_num_tiled_pids);
				l = (u32) strlen(szName);
			} else {
				l = (u32) strlen(pid->name);
			}
			while (l<max_length) {
				GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" "));
					l++;
			}
		}
		if (nb_recursion>0) {
			u32 k=0;
			while (k<(u32) nb_recursion-1) {
				k++;
				GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" "));
			}
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, ("\\\n"));
			return;
		}
		if (pid) {
			if (nb_recursion<0) {
				u32 k=(u32) -nb_recursion;
				while (k>1) {
					k--;
					GF_LOG(GF_LOG_INFO, GF_LOG_APP, ("-"));
				}
				GF_LOG(GF_LOG_INFO, GF_LOG_APP, (">"));
			}
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" "));
		}

		print_filter_name(f, GF_TRUE, GF_FALSE);

		GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" (%s=%u)\n", f->dynamic_filter ? "dyn_idx" : "idx", 1+gf_list_find(f->session->filters, f) ));
	}

	if (filters_done && (gf_list_find(filters_done, f)>=0))
		return;

	if (filters_done)
		gf_list_add(filters_done, f);
	if (alias_for && !skip_print) {
		GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" (<=> "));
		print_filter_name(alias_for, GF_TRUE, GF_TRUE);
		if (alias_for->id) {
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" ID=%s", alias_for->id));
		} else {
			GF_LOG(GF_LOG_INFO, GF_LOG_APP, (" ptr=%p", alias_for));
		}
		GF_LOG(GF_LOG_INFO, GF_LOG_APP, (")\n"));
	}

	GF_List *dests = gf_list_new();
	for (i=0; i<f->num_output_pids; i++) {
		u32 j;
		GF_FilterPid *pidout = gf_list_get(f->output_pids, i);
		for (j=0; j<pidout->num_destinations; j++) {
			GF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);
			if (gf_list_find(dests, pidi->filter)<0)
				gf_list_add(dests, pidi->filter);
		}
	}

	while (gf_list_count(dests)) {
	GF_Filter *dest = gf_list_pop_front(dests);
	GF_List *pids = gf_list_new();
	u32 max_name_len=0;
	u32 num_tile_pids=0;
	for (i=0; i<f->num_output_pids; i++) {
		u32 j;
		GF_FilterPid *pidout = gf_list_get(f->output_pids, i);
		for (j=0; j<pidout->num_destinations; j++) {
			GF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);
			if (pidi->filter != dest) continue;
			gf_list_add(pids, pidi);
		}
		u32 plen = (u32) strlen(pidout->name);

		const GF_PropertyValue *p = gf_filter_pid_get_property(pidout, GF_PROP_PID_CODECID);
		if (p &&
			((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))
		) {
			plen = 0;
			if (!num_tile_pids) {
				for (j=0; j<f->num_output_pids; j++) {
					GF_FilterPid *apid = gf_list_get(f->output_pids, j);
					p = gf_filter_pid_get_property(apid, GF_PROP_PID_CODECID);
					if (p &&
						((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))
					) {
						num_tile_pids++;
					}
				}
				plen = 5;
				j=0;
				while (j<num_tile_pids) {
					plen+=1;
					j+=10;
				}
			}
		}
		if (plen>max_name_len) max_name_len = plen;
	}
	s32 nb_pids_print = gf_list_count(pids);
	if (nb_pids_print==1) nb_pids_print = 0;
	if (num_tile_pids) nb_pids_print -= num_tile_pids-1;
	s32 nb_final_pids = nb_pids_print;
	if (nb_pids_print) nb_pids_print++;
	Bool first_tile = GF_TRUE;

	for (i=0; i<f->num_output_pids; i++) {
		u32 j, k;
		Bool is_tiled = GF_FALSE;
		Bool skip_tiled = skip_print;

		GF_FilterPid *pidout = gf_list_get(f->output_pids, i);
		if (num_tile_pids) {
			const GF_PropertyValue *p = gf_filter_pid_get_property(pidout, GF_PROP_PID_CODECID);
			if (p &&
				((p->value.uint==GF_CODECID_HEVC_TILES) || (p->value.uint==GF_CODECID_VVC_SUBPIC))
			) {
				is_tiled = GF_TRUE;
			}
		}

		for (j=0; j<pidout->num_destinations; j++) {
			GF_Filter *alias = NULL;
			GF_FilterPidInst *pidi = gf_list_get(pidout->destinations, j);
			if (pidi->filter != dest) continue;

			gf_list_del_item(pids, pidi);
			if (nb_pids_print && !gf_list_count(pids))
				nb_pids_print = 0;
			else if (is_tiled) {
				if (!first_tile) continue;
				nb_pids_print = 0;
				first_tile = GF_FALSE;
			}

			for (k=0; k<gf_list_count(f->destination_filters); k++) {
				alias = gf_list_get(f->destination_filters, k);
				if (alias->multi_sink_target == pidi->filter)
					break;
				alias = NULL;
			}
			if (alias) {
				gf_fs_print_filter_outputs(alias, filters_done, indent+1, pidout, pidi->filter, is_tiled ? num_tile_pids : src_num_tiled_pids, skip_tiled, nb_pids_print-nb_final_pids, max_name_len);
			} else {
				gf_fs_print_filter_outputs(pidi->filter, filters_done, indent+1, pidout, NULL, is_tiled ? num_tile_pids : src_num_tiled_pids, skip_tiled, nb_pids_print-nb_final_pids, max_name_len);
			}
		}
		if (nb_pids_print) nb_pids_print++;
	}
	gf_list_del(pids);
	}
	gf_list_del(dests);
}
