mb_tail_off(char_u *base, char_u *p)
{
    int		i;
    int		j;

    if (*p == NUL)
	return 0;

    if (enc_utf8)
    {
	// Find the last character that is 10xx.xxxx
	for (i = 0; (p[i + 1] & 0xc0) == 0x80; ++i)
	    ;
	// Check for illegal sequence.
	for (j = 0; p - j > base; ++j)
	    if ((p[-j] & 0xc0) != 0x80)
		break;
	if (utf8len_tab[p[-j]] != i + j + 1)
	    return 0;
	return i;
    }

    // It can't be the first byte if a double-byte when not using DBCS, at the
    // end of the string or the byte can't start a double-byte.
    if (enc_dbcs == 0 || p[1] == NUL || MB_BYTE2LEN(*p) == 1)
	return 0;

    // Return 1 when on the lead byte, 0 when on the tail byte.
    return 1 - dbcs_head_off(base, p);
}
