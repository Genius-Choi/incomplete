FILE* my_popen(DYNAMIC_STRING *ds_cmd, const char *mode,
               struct st_command *command)
{
#if _WIN32
  /*
    --execw is for tests executing commands containing non-ASCII characters.

    To correctly start such a program on Windows, we need to use the "wide"
    version of popen, with prior translation of the command line from
    the file character set to wide string. We use the current value
    of --character_set as a file character set, so before using --execw
    make sure to set --character_set properly.

    If we use the non-wide version of popen, Windows internally
    converts command line from the current ANSI code page to wide string.
    In case when character set of the command line does not match the
    current ANSI code page, non-ASCII characters get garbled in most cases.

    On Linux, the command line passed to popen() is considered
    as a binary string, no any internal to-wide and from-wide
    character set conversion happens, so we don't need to do anything.
    On Linux --execw is just a synonym to --exec.

    For simplicity, assume that  command line is limited to 4KB
    (like in cmd.exe) and that mode at most 10 characters.
  */
  if (command->type == Q_EXECW)
  {
    wchar_t wcmd[4096];
    wchar_t wmode[10];
    const char *cmd= ds_cmd->str;
    uint dummy_errors;
    size_t len;
    len= my_convert((char *) wcmd, sizeof(wcmd) - sizeof(wcmd[0]),
                    &my_charset_utf16le_bin,
                    ds_cmd->str, strlen(ds_cmd->str), charset_info,
                    &dummy_errors);
    wcmd[len / sizeof(wchar_t)]= 0;
    len= my_convert((char *) wmode, sizeof(wmode) - sizeof(wmode[0]),
                    &my_charset_utf16le_bin,
                    mode, strlen(mode), charset_info, &dummy_errors);
    wmode[len / sizeof(wchar_t)]= 0;
    return _wpopen(wcmd, wmode);
  }
#endif /* _WIN32 */

  return popen(ds_cmd->str, mode);
}
