Json::Value SGXWalletServer::ecdsaSignMessageHashImpl(int _base, const string &_keyName, const string &_messageHash) {

    INIT_RESULT(result)


    result["signature_v"] = "";
    result["signature_r"] = "";
    result["signature_s"] = "";

    vector <string> sign_vect(3);

    try {

        string cutHash = _messageHash;
        if (cutHash[0] == '0' && (cutHash[1] == 'x' || cutHash[1] == 'X')) {
            cutHash.erase(cutHash.begin(), cutHash.begin() + 2);
        }
        while (cutHash[0] == '0') {
            cutHash.erase(cutHash.begin(), cutHash.begin() + 1);
        }

        if (!checkECDSAKeyName(_keyName)) {
            throw SGXException(INVALID_ECDSA_KEY_NAME, "Invalid ECDSA key name");
        }
        if (!checkHex(cutHash)) {
            throw SGXException(INVALID_HEX, "Invalid hash");
        }
        if (_base <= 0 || _base > 32) {
            throw SGXException(-22, "Invalid base");
        }

        shared_ptr <string> key_ptr = readFromDb(_keyName, "");

        sign_vect = ecdsaSignHash(key_ptr->c_str(), cutHash.c_str(), _base);
        if (sign_vect.size() != 3) {
            throw SGXException(INVALID_ECSDA_SIGNATURE, "Invalid ecdsa signature");
        }

        spdlog::debug("got signature_s  {}", sign_vect.at(2));

        result["signature_v"] = sign_vect.at(0);
        result["signature_r"] = sign_vect.at(1);
        result["signature_s"] = sign_vect.at(2);

    } HANDLE_SGX_EXCEPTION(result)

    return result;
}
