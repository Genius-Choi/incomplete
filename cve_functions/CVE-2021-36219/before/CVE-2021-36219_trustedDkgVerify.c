void trustedDkgVerify(int *errStatus, char *errString, const char *public_shares, const char *s_share,
                      uint8_t *encryptedPrivateKey, uint64_t key_len, unsigned _t, int _ind, int *result) {


    LOG_DEBUG (__FUNCTION__);

    char skey[ECDSA_SKEY_LEN];
    sgx_status_t status = sgx_unseal_data(
            (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey, &key_len);
    if (status != SGX_SUCCESS) {
        *errStatus = status;
        snprintf(errString, BUF_LEN, "sgx_unseal_key failed with status %d", status);
        return;
    }

    char encr_sshare[ECDSA_SKEY_LEN];
    strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);
    encr_sshare[64] = 0;

    char common_key[ECDSA_SKEY_LEN];
    char decr_sshare[ECDSA_SKEY_LEN];
    session_key_recover(skey, s_share, common_key);
    common_key[ECDSA_SKEY_LEN - 1] = 0;
    if (common_key == NULL) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid common_key");
        return;
    }

    xor_decrypt(common_key, encr_sshare, decr_sshare);
    if (decr_sshare == NULL) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid common_key");
        return;
    }


    LOG_DEBUG (__FUNCTION__);


    mpz_t s;
    mpz_init(s);
    if (mpz_set_str(s, decr_sshare, 16) == -1) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid decr secret share");
        mpz_clear(s);
        return;
    }

    *result = Verification(public_shares, s, _t, _ind);

    snprintf(errString, BUF_LEN, "common_key in verification is %s", common_key);

}
