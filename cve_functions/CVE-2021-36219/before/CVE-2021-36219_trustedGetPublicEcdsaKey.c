void trustedGetPublicEcdsaKey(int *errStatus, char *errString,
                          uint8_t *encryptedPrivateKey, uint32_t dec_len, char *pub_key_x, char *pub_key_y) {

    LOG_DEBUG (__FUNCTION__);

    domain_parameters curve = domain_parameters_init();
    domain_parameters_load_curve(curve, secp256k1);

    char skey[ECDSA_SKEY_LEN];

    sgx_status_t status = sgx_unseal_data(
            (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey, &dec_len);

    if (status != SGX_SUCCESS) {
        snprintf(errString, BUF_LEN, "sgx_unseal_data failed with status %d", status);
        *errStatus = status;
        return;
    }

    //strncpy(errString, skey, 1024);

    mpz_t privateKeyMpz;
    mpz_init(privateKeyMpz);
    // mpz_import(privateKeyMpz, 32, 1, sizeof(skey[0]), 0, 0, skey);
    if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {
        snprintf(errString, BUF_LEN, "wrong string to init private key");
        *errStatus = -10;
        mpz_clear(privateKeyMpz);
        return;
    }

    //Public key
    point Pkey = point_init();

    signature_extract_public_key(Pkey, privateKeyMpz, curve);

    point Pkey_test = point_init();
    point_multiplication(Pkey_test, privateKeyMpz, curve->G, curve);

    if (!point_cmp(Pkey, Pkey_test)) {
        snprintf(errString, BUF_LEN, "Points are not equal");
        *errStatus = -11;
        return;
    }

    int base = 16;

    int len = mpz_sizeinbase(Pkey->x, base) + 2;
    //snprintf(errString, BUF_LEN, "len = %d\n", len);
    char arr_x[len];
    char *px = mpz_get_str(arr_x, base, Pkey->x);
    //snprintf(errString, BUF_LEN, "arr=%p px=%p\n", arr_x, px);
    int n_zeroes = 64 - strlen(arr_x);
    for (int i = 0; i < n_zeroes; i++) {
        pub_key_x[i] = '0';
    }

    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);

    char arr_y[mpz_sizeinbase(Pkey->y, base) + 2];
    char *py = mpz_get_str(arr_y, base, Pkey->y);
    n_zeroes = 64 - strlen(arr_y);
    for (int i = 0; i < n_zeroes; i++) {
        pub_key_y[i] = '0';
    }
    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);

    mpz_clear(privateKeyMpz);
    domain_parameters_clear(curve);
    point_clear(Pkey);
}
