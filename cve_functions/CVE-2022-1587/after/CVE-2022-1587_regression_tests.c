static int regression_tests(void)
{
	struct regression_test_case *current = regression_test_cases;
	int error;
	PCRE2_SIZE err_offs;
	int is_successful;
	int is_ascii;
	int total = 0;
	int successful = 0;
	int successful_row = 0;
	int counter = 0;
	int jit_compile_mode;
	int utf = 0;
	int disabled_options = 0;
	int i;
#ifdef SUPPORT_PCRE2_8
	pcre2_code_8 *re8;
	pcre2_compile_context_8 *ccontext8;
	pcre2_match_data_8 *mdata8_1;
	pcre2_match_data_8 *mdata8_2;
	pcre2_match_context_8 *mcontext8;
	PCRE2_SIZE *ovector8_1 = NULL;
	PCRE2_SIZE *ovector8_2 = NULL;
	int return_value8[2];
#endif
#ifdef SUPPORT_PCRE2_16
	pcre2_code_16 *re16;
	pcre2_compile_context_16 *ccontext16;
	pcre2_match_data_16 *mdata16_1;
	pcre2_match_data_16 *mdata16_2;
	pcre2_match_context_16 *mcontext16;
	PCRE2_SIZE *ovector16_1 = NULL;
	PCRE2_SIZE *ovector16_2 = NULL;
	int return_value16[2];
	int length16;
#endif
#ifdef SUPPORT_PCRE2_32
	pcre2_code_32 *re32;
	pcre2_compile_context_32 *ccontext32;
	pcre2_match_data_32 *mdata32_1;
	pcre2_match_data_32 *mdata32_2;
	pcre2_match_context_32 *mcontext32;
	PCRE2_SIZE *ovector32_1 = NULL;
	PCRE2_SIZE *ovector32_2 = NULL;
	int return_value32[2];
	int length32;
#endif

#if defined SUPPORT_PCRE2_8
	PCRE2_UCHAR8 cpu_info[128];
#elif defined SUPPORT_PCRE2_16
	PCRE2_UCHAR16 cpu_info[128];
#elif defined SUPPORT_PCRE2_32
	PCRE2_UCHAR32 cpu_info[128];
#endif
#if defined SUPPORT_UNICODE && ((defined(SUPPORT_PCRE2_8) + defined(SUPPORT_PCRE2_16) + defined(SUPPORT_PCRE2_32)) >= 2)
	int return_value;
#endif

	/* This test compares the behaviour of interpreter and JIT. Although disabling
	utf or ucp may make tests fail, if the pcre2_match result is the SAME, it is
	still considered successful from pcre2_jit_test point of view. */

#if defined SUPPORT_PCRE2_8
	pcre2_config_8(PCRE2_CONFIG_JITTARGET, &cpu_info);
#elif defined SUPPORT_PCRE2_16
	pcre2_config_16(PCRE2_CONFIG_JITTARGET, &cpu_info);
#elif defined SUPPORT_PCRE2_32
	pcre2_config_32(PCRE2_CONFIG_JITTARGET, &cpu_info);
#endif

	printf("Running JIT regression tests\n");
	printf("  target CPU of SLJIT compiler: ");
	for (i = 0; cpu_info[i]; i++)
		printf("%c", (char)(cpu_info[i]));
	printf("\n");

#if defined SUPPORT_PCRE2_8
	pcre2_config_8(PCRE2_CONFIG_UNICODE, &utf);
#elif defined SUPPORT_PCRE2_16
	pcre2_config_16(PCRE2_CONFIG_UNICODE, &utf);
#elif defined SUPPORT_PCRE2_32
	pcre2_config_32(PCRE2_CONFIG_UNICODE, &utf);
#endif

	if (!utf)
		disabled_options |= PCRE2_UTF;
#ifdef SUPPORT_PCRE2_8
	printf("  in  8 bit mode with UTF-8  %s:\n", utf ? "enabled" : "disabled");
#endif
#ifdef SUPPORT_PCRE2_16
	printf("  in 16 bit mode with UTF-16 %s:\n", utf ? "enabled" : "disabled");
#endif
#ifdef SUPPORT_PCRE2_32
	printf("  in 32 bit mode with UTF-32 %s:\n", utf ? "enabled" : "disabled");
#endif

	while (current->pattern) {
		/* printf("\nPattern: %s :\n", current->pattern); */
		total++;
		is_ascii = 0;
		if (!(current->start_offset & F_PROPERTY))
			is_ascii = check_ascii(current->pattern) && check_ascii(current->input);

		if (current->match_options & PCRE2_PARTIAL_SOFT)
			jit_compile_mode = PCRE2_JIT_PARTIAL_SOFT;
		else if (current->match_options & PCRE2_PARTIAL_HARD)
			jit_compile_mode = PCRE2_JIT_PARTIAL_HARD;
		else
			jit_compile_mode = PCRE2_JIT_COMPLETE;
		error = 0;
#ifdef SUPPORT_PCRE2_8
		re8 = NULL;
		ccontext8 = pcre2_compile_context_create_8(NULL);
		if (ccontext8) {
			if (GET_NEWLINE(current->newline))
				pcre2_set_newline_8(ccontext8, GET_NEWLINE(current->newline));
			if (GET_BSR(current->newline))
				pcre2_set_bsr_8(ccontext8, GET_BSR(current->newline));

			if (!(current->start_offset & F_NO8)) {
				re8 = pcre2_compile_8((PCRE2_SPTR8)current->pattern, PCRE2_ZERO_TERMINATED,
					current->compile_options & ~disabled_options,
					&error, &err_offs, ccontext8);

				if (!re8 && (utf || is_ascii))
					printf("\n8 bit: Cannot compile pattern \"%s\": %d\n", current->pattern, error);
			}
			pcre2_compile_context_free_8(ccontext8);
		}
		else
			printf("\n8 bit: Cannot allocate compile context\n");
#endif
#ifdef SUPPORT_PCRE2_16
		if ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))
			convert_utf8_to_utf16((PCRE2_SPTR8)current->pattern, regtest_buf16, NULL, REGTEST_MAX_LENGTH16);
		else
			copy_char8_to_char16((PCRE2_SPTR8)current->pattern, regtest_buf16, REGTEST_MAX_LENGTH16);

		re16 = NULL;
		ccontext16 = pcre2_compile_context_create_16(NULL);
		if (ccontext16) {
			if (GET_NEWLINE(current->newline))
				pcre2_set_newline_16(ccontext16, GET_NEWLINE(current->newline));
			if (GET_BSR(current->newline))
				pcre2_set_bsr_16(ccontext16, GET_BSR(current->newline));

			if (!(current->start_offset & F_NO16)) {
				re16 = pcre2_compile_16(regtest_buf16, PCRE2_ZERO_TERMINATED,
					current->compile_options & ~disabled_options,
					&error, &err_offs, ccontext16);

				if (!re16 && (utf || is_ascii))
					printf("\n16 bit: Cannot compile pattern \"%s\": %d\n", current->pattern, error);
			}
			pcre2_compile_context_free_16(ccontext16);
		}
		else
			printf("\n16 bit: Cannot allocate compile context\n");
#endif
#ifdef SUPPORT_PCRE2_32
		if ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))
			convert_utf8_to_utf32((PCRE2_SPTR8)current->pattern, regtest_buf32, NULL, REGTEST_MAX_LENGTH32);
		else
			copy_char8_to_char32((PCRE2_SPTR8)current->pattern, regtest_buf32, REGTEST_MAX_LENGTH32);

		re32 = NULL;
		ccontext32 = pcre2_compile_context_create_32(NULL);
		if (ccontext32) {
			if (GET_NEWLINE(current->newline))
				pcre2_set_newline_32(ccontext32, GET_NEWLINE(current->newline));
			if (GET_BSR(current->newline))
				pcre2_set_bsr_32(ccontext32, GET_BSR(current->newline));

			if (!(current->start_offset & F_NO32)) {
				re32 = pcre2_compile_32(regtest_buf32, PCRE2_ZERO_TERMINATED,
					current->compile_options & ~disabled_options,
					&error, &err_offs, ccontext32);

				if (!re32 && (utf || is_ascii))
					printf("\n32 bit: Cannot compile pattern \"%s\": %d\n", current->pattern, error);
			}
			pcre2_compile_context_free_32(ccontext32);
		}
		else
			printf("\n32 bit: Cannot allocate compile context\n");
#endif

		counter++;
		if ((counter & 0x3) != 0) {
#ifdef SUPPORT_PCRE2_8
			setstack8(NULL);
#endif
#ifdef SUPPORT_PCRE2_16
			setstack16(NULL);
#endif
#ifdef SUPPORT_PCRE2_32
			setstack32(NULL);
#endif
		}

#ifdef SUPPORT_PCRE2_8
		return_value8[0] = -1000;
		return_value8[1] = -1000;
		mdata8_1 = pcre2_match_data_create_8(OVECTOR_SIZE, NULL);
		mdata8_2 = pcre2_match_data_create_8(OVECTOR_SIZE, NULL);
		mcontext8 = pcre2_match_context_create_8(NULL);
		if (!mdata8_1 || !mdata8_2 || !mcontext8) {
			printf("\n8 bit: Cannot allocate match data\n");
			pcre2_match_data_free_8(mdata8_1);
			pcre2_match_data_free_8(mdata8_2);
			pcre2_match_context_free_8(mcontext8);
			pcre2_code_free_8(re8);
			re8 = NULL;
		} else {
			ovector8_1 = pcre2_get_ovector_pointer_8(mdata8_1);
			ovector8_2 = pcre2_get_ovector_pointer_8(mdata8_2);
			for (i = 0; i < OVECTOR_SIZE * 2; ++i)
				ovector8_1[i] = -2;
			for (i = 0; i < OVECTOR_SIZE * 2; ++i)
				ovector8_2[i] = -2;
			pcre2_set_match_limit_8(mcontext8, 10000000);
		}
		if (re8) {
			return_value8[1] = pcre2_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),
				current->start_offset & OFFSET_MASK, current->match_options, mdata8_2, mcontext8);

			if (pcre2_jit_compile_8(re8, jit_compile_mode)) {
				printf("\n8 bit: JIT compiler does not support \"%s\"\n", current->pattern);
			} else if ((counter & 0x1) != 0) {
				setstack8(mcontext8);
				return_value8[0] = pcre2_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),
					current->start_offset & OFFSET_MASK, current->match_options, mdata8_1, mcontext8);
			} else {
				pcre2_jit_stack_assign_8(mcontext8, NULL, getstack8());
				return_value8[0] = pcre2_jit_match_8(re8, (PCRE2_SPTR8)current->input, strlen(current->input),
					current->start_offset & OFFSET_MASK, current->match_options, mdata8_1, mcontext8);
			}
		}
#endif

#ifdef SUPPORT_PCRE2_16
		return_value16[0] = -1000;
		return_value16[1] = -1000;
		mdata16_1 = pcre2_match_data_create_16(OVECTOR_SIZE, NULL);
		mdata16_2 = pcre2_match_data_create_16(OVECTOR_SIZE, NULL);
		mcontext16 = pcre2_match_context_create_16(NULL);
		if (!mdata16_1 || !mdata16_2 || !mcontext16) {
			printf("\n16 bit: Cannot allocate match data\n");
			pcre2_match_data_free_16(mdata16_1);
			pcre2_match_data_free_16(mdata16_2);
			pcre2_match_context_free_16(mcontext16);
			pcre2_code_free_16(re16);
			re16 = NULL;
		} else {
			ovector16_1 = pcre2_get_ovector_pointer_16(mdata16_1);
			ovector16_2 = pcre2_get_ovector_pointer_16(mdata16_2);
			for (i = 0; i < OVECTOR_SIZE * 2; ++i)
				ovector16_1[i] = -2;
			for (i = 0; i < OVECTOR_SIZE * 2; ++i)
				ovector16_2[i] = -2;
			pcre2_set_match_limit_16(mcontext16, 10000000);
		}
		if (re16) {
			if ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))
				length16 = convert_utf8_to_utf16((PCRE2_SPTR8)current->input, regtest_buf16, regtest_offsetmap16, REGTEST_MAX_LENGTH16);
			else
				length16 = copy_char8_to_char16((PCRE2_SPTR8)current->input, regtest_buf16, REGTEST_MAX_LENGTH16);

			return_value16[1] = pcre2_match_16(re16, regtest_buf16, length16,
				current->start_offset & OFFSET_MASK, current->match_options, mdata16_2, mcontext16);

			if (pcre2_jit_compile_16(re16, jit_compile_mode)) {
				printf("\n16 bit: JIT compiler does not support \"%s\"\n", current->pattern);
			} else if ((counter & 0x1) != 0) {
				setstack16(mcontext16);
				return_value16[0] = pcre2_match_16(re16, regtest_buf16, length16,
					current->start_offset & OFFSET_MASK, current->match_options, mdata16_1, mcontext16);
			} else {
				pcre2_jit_stack_assign_16(mcontext16, NULL, getstack16());
				return_value16[0] = pcre2_jit_match_16(re16, regtest_buf16, length16,
					current->start_offset & OFFSET_MASK, current->match_options, mdata16_1, mcontext16);
			}
		}
#endif

#ifdef SUPPORT_PCRE2_32
		return_value32[0] = -1000;
		return_value32[1] = -1000;
		mdata32_1 = pcre2_match_data_create_32(OVECTOR_SIZE, NULL);
		mdata32_2 = pcre2_match_data_create_32(OVECTOR_SIZE, NULL);
		mcontext32 = pcre2_match_context_create_32(NULL);
		if (!mdata32_1 || !mdata32_2 || !mcontext32) {
			printf("\n32 bit: Cannot allocate match data\n");
			pcre2_match_data_free_32(mdata32_1);
			pcre2_match_data_free_32(mdata32_2);
			pcre2_match_context_free_32(mcontext32);
			pcre2_code_free_32(re32);
			re32 = NULL;
		} else {
			ovector32_1 = pcre2_get_ovector_pointer_32(mdata32_1);
			ovector32_2 = pcre2_get_ovector_pointer_32(mdata32_2);
			for (i = 0; i < OVECTOR_SIZE * 2; ++i)
				ovector32_1[i] = -2;
			for (i = 0; i < OVECTOR_SIZE * 2; ++i)
				ovector32_2[i] = -2;
			pcre2_set_match_limit_32(mcontext32, 10000000);
		}
		if (re32) {
			if ((current->compile_options & PCRE2_UTF) || (current->start_offset & F_FORCECONV))
				length32 = convert_utf8_to_utf32((PCRE2_SPTR8)current->input, regtest_buf32, regtest_offsetmap32, REGTEST_MAX_LENGTH32);
			else
				length32 = copy_char8_to_char32((PCRE2_SPTR8)current->input, regtest_buf32, REGTEST_MAX_LENGTH32);

			return_value32[1] = pcre2_match_32(re32, regtest_buf32, length32,
				current->start_offset & OFFSET_MASK, current->match_options, mdata32_2, mcontext32);

			if (pcre2_jit_compile_32(re32, jit_compile_mode)) {
				printf("\n32 bit: JIT compiler does not support \"%s\"\n", current->pattern);
			} else if ((counter & 0x1) != 0) {
				setstack32(mcontext32);
				return_value32[0] = pcre2_match_32(re32, regtest_buf32, length32,
					current->start_offset & OFFSET_MASK, current->match_options, mdata32_1, mcontext32);
			} else {
				pcre2_jit_stack_assign_32(mcontext32, NULL, getstack32());
				return_value32[0] = pcre2_jit_match_32(re32, regtest_buf32, length32,
					current->start_offset & OFFSET_MASK, current->match_options, mdata32_1, mcontext32);
			}
		}
#endif

		/* printf("[%d-%d-%d|%d-%d|%d-%d|%d-%d]%s",
			return_value8[0], return_value16[0], return_value32[0],
			(int)ovector8_1[0], (int)ovector8_1[1],
			(int)ovector16_1[0], (int)ovector16_1[1],
			(int)ovector32_1[0], (int)ovector32_1[1],
			(current->compile_options & PCRE2_CASELESS) ? "C" : ""); */

		/* If F_DIFF is set, just run the test, but do not compare the results.
		Segfaults can still be captured. */

		is_successful = 1;
		if (!(current->start_offset & F_DIFF)) {
#if defined SUPPORT_UNICODE && ((defined(SUPPORT_PCRE2_8) + defined(SUPPORT_PCRE2_16) + defined(SUPPORT_PCRE2_32)) >= 2)
			if (!(current->start_offset & F_FORCECONV)) {

				/* All results must be the same. */
#ifdef SUPPORT_PCRE2_8
				if ((return_value = return_value8[0]) != return_value8[1]) {
					printf("\n8 bit: Return value differs(J8:%d,I8:%d): [%d] '%s' @ '%s'\n",
						return_value8[0], return_value8[1], total, current->pattern, current->input);
					is_successful = 0;
				} else
#endif
#ifdef SUPPORT_PCRE2_16
				if ((return_value = return_value16[0]) != return_value16[1]) {
					printf("\n16 bit: Return value differs(J16:%d,I16:%d): [%d] '%s' @ '%s'\n",
						return_value16[0], return_value16[1], total, current->pattern, current->input);
					is_successful = 0;
				} else
#endif
#ifdef SUPPORT_PCRE2_32
				if ((return_value = return_value32[0]) != return_value32[1]) {
					printf("\n32 bit: Return value differs(J32:%d,I32:%d): [%d] '%s' @ '%s'\n",
						return_value32[0], return_value32[1], total, current->pattern, current->input);
					is_successful = 0;
				} else
#endif
#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_16
				if (return_value8[0] != return_value16[0]) {
					printf("\n8 and 16 bit: Return value differs(J8:%d,J16:%d): [%d] '%s' @ '%s'\n",
						return_value8[0], return_value16[0],
						total, current->pattern, current->input);
					is_successful = 0;
				} else
#endif
#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_32
				if (return_value8[0] != return_value32[0]) {
					printf("\n8 and 32 bit: Return value differs(J8:%d,J32:%d): [%d] '%s' @ '%s'\n",
						return_value8[0], return_value32[0],
						total, current->pattern, current->input);
					is_successful = 0;
				} else
#endif
#if defined SUPPORT_PCRE2_16 && defined SUPPORT_PCRE2_32
				if (return_value16[0] != return_value32[0]) {
					printf("\n16 and 32 bit: Return value differs(J16:%d,J32:%d): [%d] '%s' @ '%s'\n",
						return_value16[0], return_value32[0],
						total, current->pattern, current->input);
					is_successful = 0;
				} else
#endif
				if (return_value >= 0 || return_value == PCRE2_ERROR_PARTIAL) {
					if (return_value == PCRE2_ERROR_PARTIAL) {
						return_value = 2;
					} else {
						return_value *= 2;
					}
#ifdef SUPPORT_PCRE2_8
					return_value8[0] = return_value;
#endif
#ifdef SUPPORT_PCRE2_16
					return_value16[0] = return_value;
#endif
#ifdef SUPPORT_PCRE2_32
					return_value32[0] = return_value;
#endif
					/* Transform back the results. */
					if (current->compile_options & PCRE2_UTF) {
#ifdef SUPPORT_PCRE2_16
						for (i = 0; i < return_value; ++i) {
							if (ovector16_1[i] != PCRE2_UNSET)
								ovector16_1[i] = regtest_offsetmap16[ovector16_1[i]];
							if (ovector16_2[i] != PCRE2_UNSET)
								ovector16_2[i] = regtest_offsetmap16[ovector16_2[i]];
						}
#endif
#ifdef SUPPORT_PCRE2_32
						for (i = 0; i < return_value; ++i) {
							if (ovector32_1[i] != PCRE2_UNSET)
								ovector32_1[i] = regtest_offsetmap32[ovector32_1[i]];
							if (ovector32_2[i] != PCRE2_UNSET)
								ovector32_2[i] = regtest_offsetmap32[ovector32_2[i]];
						}
#endif
					}

					for (i = 0; i < return_value; ++i) {
#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_16
						if (ovector8_1[i] != ovector8_2[i] || ovector8_1[i] != ovector16_1[i] || ovector8_1[i] != ovector16_2[i]) {
							printf("\n8 and 16 bit: Ovector[%d] value differs(J8:%d,I8:%d,J16:%d,I16:%d): [%d] '%s' @ '%s' \n",
								i, (int)ovector8_1[i], (int)ovector8_2[i], (int)ovector16_1[i], (int)ovector16_2[i],
								total, current->pattern, current->input);
							is_successful = 0;
						}
#endif
#if defined SUPPORT_PCRE2_8 && defined SUPPORT_PCRE2_32
						if (ovector8_1[i] != ovector8_2[i] || ovector8_1[i] != ovector32_1[i] || ovector8_1[i] != ovector32_2[i]) {
							printf("\n8 and 32 bit: Ovector[%d] value differs(J8:%d,I8:%d,J32:%d,I32:%d): [%d] '%s' @ '%s' \n",
								i, (int)ovector8_1[i], (int)ovector8_2[i], (int)ovector32_1[i], (int)ovector32_2[i],
								total, current->pattern, current->input);
							is_successful = 0;
						}
#endif
#if defined SUPPORT_PCRE2_16 && defined SUPPORT_PCRE2_32
						if (ovector16_1[i] != ovector16_2[i] || ovector16_1[i] != ovector32_1[i] || ovector16_1[i] != ovector32_2[i]) {
							printf("\n16 and 32 bit: Ovector[%d] value differs(J16:%d,I16:%d,J32:%d,I32:%d): [%d] '%s' @ '%s' \n",
								i, (int)ovector16_1[i], (int)ovector16_2[i], (int)ovector32_1[i], (int)ovector32_2[i],
								total, current->pattern, current->input);
							is_successful = 0;
						}
#endif
					}
				}
			} else
#endif /* more than one of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16 and SUPPORT_PCRE2_32 */
			{
#ifdef SUPPORT_PCRE2_8
				if (return_value8[0] != return_value8[1]) {
					printf("\n8 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\n",
						return_value8[0], return_value8[1], total, current->pattern, current->input);
					is_successful = 0;
				} else if (return_value8[0] >= 0 || return_value8[0] == PCRE2_ERROR_PARTIAL) {
					if (return_value8[0] == PCRE2_ERROR_PARTIAL)
						return_value8[0] = 2;
					else
						return_value8[0] *= 2;

					for (i = 0; i < return_value8[0]; ++i)
						if (ovector8_1[i] != ovector8_2[i]) {
							printf("\n8 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\n",
								i, (int)ovector8_1[i], (int)ovector8_2[i], total, current->pattern, current->input);
							is_successful = 0;
						}
				}
#endif

#ifdef SUPPORT_PCRE2_16
				if (return_value16[0] != return_value16[1]) {
					printf("\n16 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\n",
						return_value16[0], return_value16[1], total, current->pattern, current->input);
					is_successful = 0;
				} else if (return_value16[0] >= 0 || return_value16[0] == PCRE2_ERROR_PARTIAL) {
					if (return_value16[0] == PCRE2_ERROR_PARTIAL)
						return_value16[0] = 2;
					else
						return_value16[0] *= 2;

					for (i = 0; i < return_value16[0]; ++i)
						if (ovector16_1[i] != ovector16_2[i]) {
							printf("\n16 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\n",
								i, (int)ovector16_1[i], (int)ovector16_2[i], total, current->pattern, current->input);
							is_successful = 0;
						}
				}
#endif

#ifdef SUPPORT_PCRE2_32
				if (return_value32[0] != return_value32[1]) {
					printf("\n32 bit: Return value differs(%d:%d): [%d] '%s' @ '%s'\n",
						return_value32[0], return_value32[1], total, current->pattern, current->input);
					is_successful = 0;
				} else if (return_value32[0] >= 0 || return_value32[0] == PCRE2_ERROR_PARTIAL) {
					if (return_value32[0] == PCRE2_ERROR_PARTIAL)
						return_value32[0] = 2;
					else
						return_value32[0] *= 2;

					for (i = 0; i < return_value32[0]; ++i)
						if (ovector32_1[i] != ovector32_2[i]) {
							printf("\n32 bit: Ovector[%d] value differs(%d:%d): [%d] '%s' @ '%s'\n",
								i, (int)ovector32_1[i], (int)ovector32_2[i], total, current->pattern, current->input);
							is_successful = 0;
						}
				}
#endif
			}
		}

		if (is_successful) {
#ifdef SUPPORT_PCRE2_8
			if (!(current->start_offset & F_NO8) && (utf || is_ascii)) {
				if (return_value8[0] < 0 && !(current->start_offset & F_NOMATCH)) {
					printf("8 bit: Test should match: [%d] '%s' @ '%s'\n",
						total, current->pattern, current->input);
					is_successful = 0;
				}

				if (return_value8[0] >= 0 && (current->start_offset & F_NOMATCH)) {
					printf("8 bit: Test should not match: [%d] '%s' @ '%s'\n",
						total, current->pattern, current->input);
					is_successful = 0;
				}
			}
#endif
#ifdef SUPPORT_PCRE2_16
			if (!(current->start_offset & F_NO16) && (utf || is_ascii)) {
				if (return_value16[0] < 0 && !(current->start_offset & F_NOMATCH)) {
					printf("16 bit: Test should match: [%d] '%s' @ '%s'\n",
						total, current->pattern, current->input);
					is_successful = 0;
				}

				if (return_value16[0] >= 0 && (current->start_offset & F_NOMATCH)) {
					printf("16 bit: Test should not match: [%d] '%s' @ '%s'\n",
						total, current->pattern, current->input);
					is_successful = 0;
				}
			}
#endif
#ifdef SUPPORT_PCRE2_32
			if (!(current->start_offset & F_NO32) && (utf || is_ascii)) {
				if (return_value32[0] < 0 && !(current->start_offset & F_NOMATCH)) {
					printf("32 bit: Test should match: [%d] '%s' @ '%s'\n",
						total, current->pattern, current->input);
					is_successful = 0;
				}

				if (return_value32[0] >= 0 && (current->start_offset & F_NOMATCH)) {
					printf("32 bit: Test should not match: [%d] '%s' @ '%s'\n",
						total, current->pattern, current->input);
					is_successful = 0;
				}
			}
#endif
		}

		if (is_successful) {
#ifdef SUPPORT_PCRE2_8
			if (re8 && !(current->start_offset & F_NO8) && pcre2_get_mark_8(mdata8_1) != pcre2_get_mark_8(mdata8_2)) {
				printf("8 bit: Mark value mismatch: [%d] '%s' @ '%s'\n",
					total, current->pattern, current->input);
				is_successful = 0;
			}
#endif
#ifdef SUPPORT_PCRE2_16
			if (re16 && !(current->start_offset & F_NO16) && pcre2_get_mark_16(mdata16_1) != pcre2_get_mark_16(mdata16_2)) {
				printf("16 bit: Mark value mismatch: [%d] '%s' @ '%s'\n",
					total, current->pattern, current->input);
				is_successful = 0;
			}
#endif
#ifdef SUPPORT_PCRE2_32
			if (re32 && !(current->start_offset & F_NO32) && pcre2_get_mark_32(mdata32_1) != pcre2_get_mark_32(mdata32_2)) {
				printf("32 bit: Mark value mismatch: [%d] '%s' @ '%s'\n",
					total, current->pattern, current->input);
				is_successful = 0;
			}
#endif
		}

#ifdef SUPPORT_PCRE2_8
		pcre2_code_free_8(re8);
		pcre2_match_data_free_8(mdata8_1);
		pcre2_match_data_free_8(mdata8_2);
		pcre2_match_context_free_8(mcontext8);
#endif
#ifdef SUPPORT_PCRE2_16
		pcre2_code_free_16(re16);
		pcre2_match_data_free_16(mdata16_1);
		pcre2_match_data_free_16(mdata16_2);
		pcre2_match_context_free_16(mcontext16);
#endif
#ifdef SUPPORT_PCRE2_32
		pcre2_code_free_32(re32);
		pcre2_match_data_free_32(mdata32_1);
		pcre2_match_data_free_32(mdata32_2);
		pcre2_match_context_free_32(mcontext32);
#endif

		if (is_successful) {
			successful++;
			successful_row++;
			printf(".");
			if (successful_row >= 60) {
				successful_row = 0;
				printf("\n");
			}
		} else
			successful_row = 0;

		fflush(stdout);
		current++;
	}
#ifdef SUPPORT_PCRE2_8
	setstack8(NULL);
#endif
#ifdef SUPPORT_PCRE2_16
	setstack16(NULL);
#endif
#ifdef SUPPORT_PCRE2_32
	setstack32(NULL);
#endif

	if (total == successful) {
		printf("\nAll JIT regression tests are successfully passed.\n");
		return 0;
	} else {
		printf("\nSuccessful test ratio: %d%% (%d failed)\n", successful * 100 / total, total - successful);
		return 1;
	}
}
