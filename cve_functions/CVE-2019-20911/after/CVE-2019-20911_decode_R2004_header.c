decode_R2004_header (Bit_Chain *restrict file_dat, Dwg_Data *restrict dwg)
{
  int error = 0;
  Dwg_Object *obj = NULL;
  struct Dwg_R2004_Header *_obj = &dwg->r2004_header;
  Bit_Chain *hdl_dat = file_dat;

  {
    const unsigned long size = sizeof (struct Dwg_R2004_Header);
    BITCODE_RC decrypted_data[size];
    Bit_Chain decrypted_header_dat = *file_dat;
    Bit_Chain *dat;

    decrypted_header_dat.size = size;
    decrypted_header_dat.chain = decrypted_data;
    decrypted_header_dat.byte = decrypted_header_dat.bit = 0;

    file_dat->byte = 0x80;
    file_dat->bit = 0;
    decrypt_R2004_header (file_dat, decrypted_data, size, dwg);

    dat = &decrypted_header_dat;
    dat->bit = dat->byte = 0;
    LOG_TRACE ("\n#### 2004 File Header ####\n");
    // clang-format off
    #include "r2004_file_header.spec"
    // clang-format on
  }

  /*-------------------------------------------------------------------------
   * Section Page Map
   */
  {
    Bit_Chain *dat = file_dat;
    dat->byte = dwg->r2004_header.section_map_address + 0x100;

    LOG_TRACE ("\n=== Read System Section (Section Page Map) ===\n\n")
    FIELD_RLx (section_type, 0);
    if (FIELD_VALUE (section_type) != 0x41630e3b)
      {
        LOG_ERROR ("Invalid System Section Page Map type 0x%x != 0x41630e3b",
                   FIELD_VALUE (section_type));
        return DWG_ERR_SECTIONNOTFOUND;
      }
    FIELD_RL (decomp_data_size, 0);
    FIELD_RL (comp_data_size, 0);
    FIELD_RL (compression_type, 0);
    FIELD_RLx (checksum, 0); // see dwg_section_page_checksum()
  }

  return error;
}
