decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
{
  BITCODE_RL entities_start, entities_end, blocks_start, blocks_end;
  BITCODE_RL rl1, rl2;
  BITCODE_RS rs2;
  Dwg_Object *obj = NULL;
  int tbl_id;
  int error = 0;

  {
    int i;
    struct Dwg_Header *_obj = &dwg->header;
    Bit_Chain *hdl_dat = dat;
    dat->byte = 0x06;
    // clang-format off
    #include "header.spec"
    // clang-format on
  }
  LOG_TRACE ("@0x%lx\n", dat->byte); // 0x14

  // tables really
  dwg->header.num_sections = 12;
  dwg->header.section = (Dwg_Section *)calloc (
      1, sizeof (Dwg_Section) * dwg->header.num_sections);
  if (!dwg->header.section)
    {
      LOG_ERROR ("Out of memory");
      return DWG_ERR_OUTOFMEM;
    }

  entities_start = bit_read_RL (dat);
  entities_end = bit_read_RL (dat);
  LOG_TRACE ("entities 0x%x - 0x%x\n", entities_start, entities_end);
  blocks_start = bit_read_RL (dat);
  rl1 = bit_read_RL (dat); // 0x40
  blocks_end = bit_read_RL (dat);
  rl2 = bit_read_RL (dat); // 0x80
  LOG_TRACE ("blocks   0x%x (0x%x) - 0x%x (0x%x)\n", blocks_start, rl1,
             blocks_end, rl2);

  tbl_id = 0;
  dwg->header.section[0].number = 0;
  dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;
  strcpy (dwg->header.section[0].name, "HEADER");

  decode_preR13_section_ptr ("BLOCK", SECTION_BLOCK, dat, dwg);
  decode_preR13_section_ptr ("LAYER", SECTION_LAYER, dat, dwg);
  decode_preR13_section_ptr ("STYLE", SECTION_STYLE, dat, dwg);
  // skip one
  decode_preR13_section_ptr ("LTYPE", SECTION_LTYPE, dat, dwg);
  decode_preR13_section_ptr ("VIEW", SECTION_VIEW, dat, dwg);

  if (dwg->header.section[SECTION_BLOCK].size > dat->size)
    {
      LOG_ERROR ("BLOCK.size overflow")
      return DWG_ERR_INVALIDDWG;
    }
  LOG_TRACE ("@0x%lx\n", dat->byte); // 0x5e
  {
    Dwg_Header_Variables *_obj = &dwg->header_vars;
    Bit_Chain *hdl_dat = dat;
    // clang-format off
    #include "header_variables_r11.spec"
    // clang-format on
  }
  LOG_TRACE ("@0x%lx\n", dat->byte); // 0x23a

  dat->byte = 0x3ef;
  LOG_TRACE ("@0x%lx\n", dat->byte);
  decode_preR13_section_ptr ("UCS", SECTION_UCS, dat, dwg);
  // skip: 0x500 - dat->bytes
  dat->byte = 0x500;
  LOG_TRACE ("@0x%lx\n", dat->byte); // 0x23a
  decode_preR13_section_ptr ("VPORT", SECTION_VPORT, dat, dwg);
  rl1 = bit_read_RL (dat);
  rl2 = bit_read_RL (dat);
  LOG_TRACE ("?2 long: 0x%x 0x%x\n", rl1, rl2);
  decode_preR13_section_ptr ("APPID", SECTION_APPID, dat, dwg);
  rl1 = bit_read_RL (dat);
  rs2 = bit_read_RS (dat);
  LOG_TRACE ("?long+short: 0x%x 0x%x\n", rl1, (unsigned)rs2);
  decode_preR13_section_ptr ("DIMSTYLE", SECTION_DIMSTYLE, dat, dwg);
  // skip: 0x69f - dat->bytes
  dat->byte = 0x69f;
  decode_preR13_section_ptr ("VPORT_ENTITY", SECTION_VPORT_ENTITY, dat, dwg);
  dat->byte += 38;
  // entities
  error |= decode_preR13_entities (entities_start, entities_end, 0, dat, dwg);
  if (error >= DWG_ERR_CRITICAL)
    return error;
  dat->byte += 19; /* crc + sentinel? */
  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);
  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);
  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);
  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);
  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);
  error |= decode_preR13_section (SECTION_UCS, dat, dwg);
  error |= decode_preR13_section (SECTION_VPORT, dat, dwg);
  error |= decode_preR13_section (SECTION_APPID, dat, dwg);
  error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);
  error |= decode_preR13_section (SECTION_VPORT_ENTITY, dat, dwg);
  if (error >= DWG_ERR_CRITICAL)
    return error;
  // blocks
  error |= decode_preR13_entities (blocks_start, blocks_end, blocks_start - 0x40000000,
                          dat, dwg);
  if (error >= DWG_ERR_CRITICAL)
    return error;
  LOG_TRACE ("@0x%lx\n", dat->byte);
  // 36 byte: 9x long
  rl1 = bit_read_RL (dat);
  rl2 = bit_read_RL (dat);
  LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
             (double)dat->chain[dat->byte - 8]);
  rl1 = bit_read_RL (dat);
  rl2 = bit_read_RL (dat);
  LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
             (double)dat->chain[dat->byte - 8]);
  rl1 = bit_read_RL (dat);
  rl2 = bit_read_RL (dat);
  LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
             (double)dat->chain[dat->byte - 8]);
  rl1 = bit_read_RL (dat);
  rl2 = bit_read_RL (dat);
  LOG_TRACE ("?2long: 0x%x 0x%x %f\n", rl1, rl2,
             (double)dat->chain[dat->byte - 8]);
  rl1 = bit_read_RL (dat);
  LOG_TRACE ("?1long: 0x%x\n", rl1);

  LOG_TRACE ("@0x%lx: 4 block ptrs chk\n", dat->byte);
  if ((rl1 = bit_read_RL (dat)) != entities_start)
    {
      LOG_WARN ("entities_start %x/%x", rl1, entities_start);
    }
  if ((rl1 = bit_read_RL (dat)) != entities_end)
    {
      LOG_WARN ("entities_end %x/%x", rl1, entities_end);
    }
  if ((rl1 = bit_read_RL (dat)) != blocks_start)
    {
      LOG_WARN ("blocks_start %x/%x", rl1, blocks_start);
    }
  if ((rl1 = bit_read_RL (dat)) != blocks_end)
    {
      LOG_WARN ("blocks_end %x/%x", rl1, blocks_end);
    }
  // 12 byte
  LOG_TRACE ("@0x%lx\n", dat->byte);
  rl1 = bit_read_RL (dat);
  rl2 = bit_read_RL (dat);
  LOG_TRACE ("?2long: 0x%x 0x%x\n", rl1, rl2);
  rl1 = bit_read_RL (dat);
  LOG_TRACE ("?1long: 0x%x\n", rl1);

  dat->byte = blocks_end + 36 + 4 * 4 + 12;
  LOG_TRACE ("@0x%lx\n", dat->byte);
  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);
  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);
  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);
  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);
  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);
  decode_preR13_section_chk (SECTION_UCS, dat, dwg);
  decode_preR13_section_chk (SECTION_VPORT, dat, dwg);
  decode_preR13_section_chk (SECTION_APPID, dat, dwg);
  decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);
  decode_preR13_section_chk (SECTION_VPORT_ENTITY, dat, dwg);
  rl1 = bit_read_RL (dat);
  LOG_TRACE ("long 0x%x\n", rl1); // address

  return 0;
}
