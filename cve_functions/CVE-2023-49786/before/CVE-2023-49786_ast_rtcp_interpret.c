static struct ast_frame *ast_rtcp_interpret(struct ast_rtp_instance *instance, struct ast_srtp *srtp,
	const unsigned char *rtcpdata, size_t size, struct ast_sockaddr *addr)
{
	struct ast_rtp_instance *transport = instance;
	struct ast_rtp *transport_rtp = ast_rtp_instance_get_data(instance);
	int len = size;
	unsigned int *rtcpheader = (unsigned int *)(rtcpdata);
	unsigned int packetwords;
	unsigned int position;
	unsigned int first_word;
	/*! True if we have seen an acceptable SSRC to learn the remote RTCP address */
	unsigned int ssrc_seen;
	struct ast_rtp_rtcp_report_block *report_block;
	struct ast_frame *f = &ast_null_frame;
#ifdef TEST_FRAMEWORK
	struct ast_rtp_engine_test *test_engine;
#endif

	/* If this is encrypted then decrypt the payload */
	if ((*rtcpheader & 0xC0) && res_srtp && srtp && res_srtp->unprotect(
		    srtp, rtcpheader, &len, 1 | (srtp_replay_protection << 1)) < 0) {
	   return &ast_null_frame;
	}

	packetwords = len / 4;

	ast_debug_rtcp(2, "(%s) RTCP got report of %d bytes from %s\n",
		ast_rtp_instance_get_channel_id(instance),
		len, ast_sockaddr_stringify(addr));

	/*
	 * Validate the RTCP packet according to an adapted and slightly
	 * modified RFC3550 validation algorithm.
	 */
	if (packetwords < RTCP_HEADER_SSRC_LENGTH) {
		ast_debug_rtcp(2, "(%s) RTCP %p -- from %s: Frame size (%u words) is too short\n",
			ast_rtp_instance_get_channel_id(instance),
			transport_rtp, ast_sockaddr_stringify(addr), packetwords);
		return &ast_null_frame;
	}
	position = 0;
	first_word = ntohl(rtcpheader[position]);
	if ((first_word & RTCP_VALID_MASK) != RTCP_VALID_VALUE) {
		ast_debug_rtcp(2, "(%s) RTCP %p -- from %s: Failed first packet validity check\n",
			ast_rtp_instance_get_channel_id(instance),
			transport_rtp, ast_sockaddr_stringify(addr));
		return &ast_null_frame;
	}
	do {
		position += ((first_word >> RTCP_LENGTH_SHIFT) & RTCP_LENGTH_MASK) + 1;
		if (packetwords <= position) {
			break;
		}
		first_word = ntohl(rtcpheader[position]);
	} while ((first_word & RTCP_VERSION_MASK_SHIFTED) == RTCP_VERSION_SHIFTED);
	if (position != packetwords) {
		ast_debug_rtcp(2, "(%s) RTCP %p -- from %s: Failed packet version or length check\n",
			ast_rtp_instance_get_channel_id(instance),
			transport_rtp, ast_sockaddr_stringify(addr));
		return &ast_null_frame;
	}

	/*
	 * Note: RFC3605 points out that true NAT (vs NAPT) can cause RTCP
	 * to have a different IP address and port than RTP.  Otherwise, when
	 * strictrtp is enabled we could reject RTCP packets not coming from
	 * the learned RTP IP address if it is available.
	 */

	/*
	 * strictrtp safety needs SSRC to match before we use the
	 * sender's address for symmetrical RTP to send our RTCP
	 * reports.
	 *
	 * If strictrtp is not enabled then claim to have already seen
	 * a matching SSRC so we'll accept this packet's address for
	 * symmetrical RTP.
	 */
	ssrc_seen = transport_rtp->strict_rtp_state == STRICT_RTP_OPEN;

	position = 0;
	while (position < packetwords) {
		unsigned int i;
		unsigned int pt;
		unsigned int rc;
		unsigned int ssrc;
		/*! True if the ssrc value we have is valid and not garbage because it doesn't exist. */
		unsigned int ssrc_valid;
		unsigned int length;
		unsigned int min_length;
		/*! Always use packet source SSRC to find the rtp instance unless explicitly told not to. */
		unsigned int use_packet_source = 1;

		struct ast_json *message_blob;
		RAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);
		struct ast_rtp_instance *child;
		struct ast_rtp *rtp;
		struct ast_rtp_rtcp_feedback *feedback;

		i = position;
		first_word = ntohl(rtcpheader[i]);
		pt = (first_word >> RTCP_PAYLOAD_TYPE_SHIFT) & RTCP_PAYLOAD_TYPE_MASK;
		rc = (first_word >> RTCP_REPORT_COUNT_SHIFT) & RTCP_REPORT_COUNT_MASK;
		/* RFC3550 says 'length' is the number of words in the packet - 1 */
		length = ((first_word >> RTCP_LENGTH_SHIFT) & RTCP_LENGTH_MASK) + 1;

		/* Check expected RTCP packet record length */
		min_length = RTCP_HEADER_SSRC_LENGTH;
		switch (pt) {
		case RTCP_PT_SR:
			min_length += RTCP_SR_BLOCK_WORD_LENGTH;
			/* fall through */
		case RTCP_PT_RR:
			min_length += (rc * RTCP_RR_BLOCK_WORD_LENGTH);
			use_packet_source = 0;
			break;
		case RTCP_PT_FUR:
			break;
		case AST_RTP_RTCP_RTPFB:
			switch (rc) {
			case AST_RTP_RTCP_FMT_NACK:
				min_length += RTCP_FB_NACK_BLOCK_WORD_LENGTH;
				break;
			default:
				break;
			}
			use_packet_source = 0;
			break;
		case RTCP_PT_PSFB:
			switch (rc) {
			case AST_RTP_RTCP_FMT_REMB:
				min_length += RTCP_FB_REMB_BLOCK_WORD_LENGTH;
				break;
			default:
				break;
			}
			break;
		case RTCP_PT_SDES:
		case RTCP_PT_BYE:
			/*
			 * There may not be a SSRC/CSRC present.  The packet is
			 * useless but still valid if it isn't present.
			 *
			 * We don't know what min_length should be so disable the check
			 */
			min_length = length;
			break;
		default:
			ast_debug_rtcp(1, "(%p) RTCP %p -- from %s: %u(%s) skipping record\n",
				instance, transport_rtp, ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt));
			if (rtcp_debug_test_addr(addr)) {
				ast_verbose("\n");
				ast_verbose("RTCP from %s: %u(%s) skipping record\n",
					ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt));
			}
			position += length;
			continue;
		}
		if (length < min_length) {
			ast_debug_rtcp(1, "(%p) RTCP %p -- from %s: %u(%s) length field less than expected minimum.  Min:%u Got:%u\n",
				instance, transport_rtp, ast_sockaddr_stringify(addr), pt, rtcp_payload_type2str(pt),
				min_length - 1, length - 1);
			return &ast_null_frame;
		}

		/* Get the RTCP record SSRC if defined for the record */
		ssrc_valid = 1;
		switch (pt) {
		case RTCP_PT_SR:
		case RTCP_PT_RR:
			rtcp_report = ast_rtp_rtcp_report_alloc(rc);
			if (!rtcp_report) {
				return &ast_null_frame;
			}
			rtcp_report->reception_report_count = rc;

			ssrc = ntohl(rtcpheader[i + 2]);
			rtcp_report->ssrc = ssrc;
			break;
		case RTCP_PT_FUR:
		case RTCP_PT_PSFB:
			ssrc = ntohl(rtcpheader[i + 1]);
			break;
		case AST_RTP_RTCP_RTPFB:
			ssrc = ntohl(rtcpheader[i + 2]);
			break;
		case RTCP_PT_SDES:
		case RTCP_PT_BYE:
		default:
			ssrc = 0;
			ssrc_valid = 0;
			break;
		}

		if (rtcp_debug_test_addr(addr)) {
			const char *subtype = rtcp_payload_subtype2str(pt, rc);

			ast_verbose("\n");
			ast_verbose("RTCP from %s\n", ast_sockaddr_stringify(addr));
			ast_verbose("PT: %u (%s)\n", pt, rtcp_payload_type2str(pt));
			if (subtype) {
				ast_verbose("Packet Subtype: %u (%s)\n", rc, subtype);
			} else {
				ast_verbose("Reception reports: %u\n", rc);
			}
			ast_verbose("SSRC of sender: %u\n", ssrc);
		}

		/* Determine the appropriate instance for this */
		if (ssrc_valid) {
			/*
			 * Depending on the payload type, either the packet source or media source
			 * SSRC is used.
			 */
			if (use_packet_source) {
				child = rtp_find_instance_by_packet_source_ssrc(transport, transport_rtp, ssrc);
			} else {
				child = rtp_find_instance_by_media_source_ssrc(transport, transport_rtp, ssrc);
			}
			if (child && child != transport) {
				/*
				 * It is safe to hold the child lock while holding the parent lock.
				 * We guarantee that the locking order is always parent->child or
				 * that the child lock is not held when acquiring the parent lock.
				 */
				ao2_lock(child);
				instance = child;
				rtp = ast_rtp_instance_get_data(instance);
			} else {
				/* The child is the parent! We don't need to unlock it. */
				child = NULL;
				rtp = transport_rtp;
			}
		} else {
			child = NULL;
			rtp = transport_rtp;
		}

		if (ssrc_valid && rtp->themssrc_valid) {
			/*
			 * If the SSRC is 1, we still need to handle RTCP since this could be a
			 * special case. For example, if we have a unidirectional video stream, the
			 * SSRC may be set to 1 by the browser (in the case of chromium), and requests
			 * will still need to be processed so that video can flow as expected. This
			 * should only be done for PLI and FUR, since there is not a way to get the
			 * appropriate rtp instance when the SSRC is 1.
			 */
			int exception = (ssrc == 1 && !((pt == RTCP_PT_PSFB && rc == AST_RTP_RTCP_FMT_PLI) || pt == RTCP_PT_FUR));
			if ((ssrc != rtp->themssrc && use_packet_source && ssrc != 1)
					|| exception) {
				/*
				 * Skip over this RTCP record as it does not contain the
				 * correct SSRC.  We should not act upon RTCP records
				 * for a different stream.
				 */
				position += length;
				ast_debug_rtcp(1, "(%p) RTCP %p -- from %s: Skipping record, received SSRC '%u' != expected '%u'\n",
					instance, rtp, ast_sockaddr_stringify(addr), ssrc, rtp->themssrc);
				if (child) {
					ao2_unlock(child);
				}
				continue;
			}
			ssrc_seen = 1;
		}

		if (ssrc_seen && ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {
			/* Send to whoever sent to us */
			if (ast_sockaddr_cmp(&rtp->rtcp->them, addr)) {
				ast_sockaddr_copy(&rtp->rtcp->them, addr);
				if (ast_debug_rtp_packet_is_allowed) {
					ast_debug(0, "(%p) RTCP NAT: Got RTCP from other end. Now sending to address %s\n",
						instance, ast_sockaddr_stringify(addr));
				}
			}
		}

		i += RTCP_HEADER_SSRC_LENGTH; /* Advance past header and ssrc */
		switch (pt) {
		case RTCP_PT_SR:
			gettimeofday(&rtp->rtcp->rxlsr, NULL);
			rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16);
			rtp->rtcp->spc = ntohl(rtcpheader[i + 3]);
			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);

			rtcp_report->type = RTCP_PT_SR;
			rtcp_report->sender_information.packet_count = rtp->rtcp->spc;
			rtcp_report->sender_information.octet_count = rtp->rtcp->soc;
			ntp2timeval((unsigned int)ntohl(rtcpheader[i]),
					(unsigned int)ntohl(rtcpheader[i + 1]),
					&rtcp_report->sender_information.ntp_timestamp);
			rtcp_report->sender_information.rtp_timestamp = ntohl(rtcpheader[i + 2]);
			if (rtcp_debug_test_addr(addr)) {
				ast_verbose("NTP timestamp: %u.%06u\n",
						(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_sec,
						(unsigned int)rtcp_report->sender_information.ntp_timestamp.tv_usec);
				ast_verbose("RTP timestamp: %u\n", rtcp_report->sender_information.rtp_timestamp);
				ast_verbose("SPC: %u\tSOC: %u\n",
						rtcp_report->sender_information.packet_count,
						rtcp_report->sender_information.octet_count);
			}
			i += RTCP_SR_BLOCK_WORD_LENGTH;
			/* Intentional fall through */
		case RTCP_PT_RR:
			if (rtcp_report->type != RTCP_PT_SR) {
				rtcp_report->type = RTCP_PT_RR;
			}

			if (rc > 0) {
				/* Don't handle multiple reception reports (rc > 1) yet */
				report_block = ast_calloc(1, sizeof(*report_block));
				if (!report_block) {
					if (child) {
						ao2_unlock(child);
					}
					return &ast_null_frame;
				}
				rtcp_report->report_block[0] = report_block;
				report_block->source_ssrc = ntohl(rtcpheader[i]);
				report_block->lost_count.packets = ntohl(rtcpheader[i + 1]) & 0x00ffffff;
				report_block->lost_count.fraction = ((ntohl(rtcpheader[i + 1]) & 0xff000000) >> 24);
				report_block->highest_seq_no = ntohl(rtcpheader[i + 2]);
				report_block->ia_jitter =  ntohl(rtcpheader[i + 3]);
				report_block->lsr = ntohl(rtcpheader[i + 4]);
				report_block->dlsr = ntohl(rtcpheader[i + 5]);
				if (report_block->lsr) {
					int skewed = update_rtt_stats(rtp, report_block->lsr, report_block->dlsr);
					if (skewed && rtcp_debug_test_addr(addr)) {
						struct timeval now;
						unsigned int lsr_now, lsw, msw;
						gettimeofday(&now, NULL);
						timeval2ntp(now, &msw, &lsw);
						lsr_now = (((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16));
						ast_verbose("Internal RTCP NTP clock skew detected: "
							"lsr=%u, now=%u, dlsr=%u (%u:%03ums), "
							"diff=%u\n",
							report_block->lsr, lsr_now, report_block->dlsr, report_block->dlsr / 65536,
							(report_block->dlsr % 65536) * 1000 / 65536,
							report_block->dlsr - (lsr_now - report_block->lsr));
					}
				}
				update_jitter_stats(rtp, report_block->ia_jitter);
				update_lost_stats(rtp, report_block->lost_count.packets);
				/*
				 * update_reported_mes_stats must be called AFTER
				 * update_rtt_stats, update_jitter_stats and
				 * update_lost_stats.
				 */
				update_reported_mes_stats(rtp);

				if (rtcp_debug_test_addr(addr)) {
					int rate = ast_rtp_get_rate(rtp->f.subclass.format);

					ast_verbose("  Fraction lost: %d\n", report_block->lost_count.fraction);
					ast_verbose("  Packets lost so far: %u\n", report_block->lost_count.packets);
					ast_verbose("  Highest sequence number: %u\n", report_block->highest_seq_no & 0x0000ffff);
					ast_verbose("  Sequence number cycles: %u\n", report_block->highest_seq_no >> 16);
					ast_verbose("  Interarrival jitter (samp): %u\n", report_block->ia_jitter);
					ast_verbose("  Interarrival jitter (secs): %.6f\n", ast_samp2sec(report_block->ia_jitter, rate));
					ast_verbose("  Last SR(our NTP): %lu.%010lu\n",(unsigned long)(report_block->lsr) >> 16,((unsigned long)(report_block->lsr) << 16) * 4096);
					ast_verbose("  DLSR: %4.4f (sec)\n",(double)report_block->dlsr / 65536.0);
					ast_verbose("  RTT: %4.4f(sec)\n", rtp->rtcp->rtt);
					ast_verbose("  MES: %4.1f\n", rtp->rtcp->reported_mes);
				}
			}
			/* If and when we handle more than one report block, this should occur outside
			 * this loop.
			 */

			message_blob = ast_json_pack("{s: s, s: s, s: f, s: f}",
				"from", ast_sockaddr_stringify(addr),
				"to", transport_rtp->rtcp->local_addr_str,
				"rtt", rtp->rtcp->rtt,
				"mes", rtp->rtcp->reported_mes);
			ast_rtp_publish_rtcp_message(instance, ast_rtp_rtcp_received_type(),
					rtcp_report,
					message_blob);
			ast_json_unref(message_blob);

			/* Return an AST_FRAME_RTCP frame with the ast_rtp_rtcp_report
			 * object as a its data */
			transport_rtp->f.frametype = AST_FRAME_RTCP;
			transport_rtp->f.subclass.integer = pt;
			transport_rtp->f.data.ptr = rtp->rtcp->frame_buf + AST_FRIENDLY_OFFSET;
			memcpy(transport_rtp->f.data.ptr, rtcp_report, sizeof(struct ast_rtp_rtcp_report));
			transport_rtp->f.datalen = sizeof(struct ast_rtp_rtcp_report);
			if (rc > 0) {
				/* There's always a single report block stored, here */
				struct ast_rtp_rtcp_report *rtcp_report2;
				report_block = transport_rtp->f.data.ptr + transport_rtp->f.datalen + sizeof(struct ast_rtp_rtcp_report_block *);
				memcpy(report_block, rtcp_report->report_block[0], sizeof(struct ast_rtp_rtcp_report_block));
				rtcp_report2 = (struct ast_rtp_rtcp_report *)transport_rtp->f.data.ptr;
				rtcp_report2->report_block[0] = report_block;
				transport_rtp->f.datalen += sizeof(struct ast_rtp_rtcp_report_block);
			}
			transport_rtp->f.offset = AST_FRIENDLY_OFFSET;
			transport_rtp->f.samples = 0;
			transport_rtp->f.mallocd = 0;
			transport_rtp->f.delivery.tv_sec = 0;
			transport_rtp->f.delivery.tv_usec = 0;
			transport_rtp->f.src = "RTP";
			transport_rtp->f.stream_num = rtp->stream_num;
			f = &transport_rtp->f;
			break;
		case AST_RTP_RTCP_RTPFB:
			switch (rc) {
			case AST_RTP_RTCP_FMT_NACK:
				/* If retransmissions are not enabled ignore this message */
				if (!rtp->send_buffer) {
					break;
				}

				if (rtcp_debug_test_addr(addr)) {
					ast_verbose("Received generic RTCP NACK message\n");
				}

				ast_rtp_rtcp_handle_nack(instance, rtcpheader, position, length);
				break;
			default:
				break;
			}
			break;
		case RTCP_PT_FUR:
			/* Handle RTCP FUR as FIR by setting the format to 4 */
			rc = AST_RTP_RTCP_FMT_FIR;
		case RTCP_PT_PSFB:
			switch (rc) {
			case AST_RTP_RTCP_FMT_PLI:
			case AST_RTP_RTCP_FMT_FIR:
				if (rtcp_debug_test_addr(addr)) {
					ast_verbose("Received an RTCP Fast Update Request\n");
				}
				transport_rtp->f.frametype = AST_FRAME_CONTROL;
				transport_rtp->f.subclass.integer = AST_CONTROL_VIDUPDATE;
				transport_rtp->f.datalen = 0;
				transport_rtp->f.samples = 0;
				transport_rtp->f.mallocd = 0;
				transport_rtp->f.src = "RTP";
				f = &transport_rtp->f;
				break;
			case AST_RTP_RTCP_FMT_REMB:
				/* If REMB support is not enabled ignore this message */
				if (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_REMB)) {
					break;
				}

				if (rtcp_debug_test_addr(addr)) {
					ast_verbose("Received REMB report\n");
				}
				transport_rtp->f.frametype = AST_FRAME_RTCP;
				transport_rtp->f.subclass.integer = pt;
				transport_rtp->f.stream_num = rtp->stream_num;
				transport_rtp->f.data.ptr = rtp->rtcp->frame_buf + AST_FRIENDLY_OFFSET;
				feedback = transport_rtp->f.data.ptr;
				feedback->fmt = rc;

				/* We don't actually care about the SSRC information in the feedback message */
				first_word = ntohl(rtcpheader[i + 2]);
				feedback->remb.br_exp = (first_word >> 18) & ((1 << 6) - 1);
				feedback->remb.br_mantissa = first_word & ((1 << 18) - 1);

				transport_rtp->f.datalen = sizeof(struct ast_rtp_rtcp_feedback);
				transport_rtp->f.offset = AST_FRIENDLY_OFFSET;
				transport_rtp->f.samples = 0;
				transport_rtp->f.mallocd = 0;
				transport_rtp->f.delivery.tv_sec = 0;
				transport_rtp->f.delivery.tv_usec = 0;
				transport_rtp->f.src = "RTP";
				f = &transport_rtp->f;
				break;
			default:
				break;
			}
			break;
		case RTCP_PT_SDES:
			if (rtcp_debug_test_addr(addr)) {
				ast_verbose("Received an SDES from %s\n",
					ast_sockaddr_stringify(addr));
			}
#ifdef TEST_FRAMEWORK
			if ((test_engine = ast_rtp_instance_get_test(instance))) {
				test_engine->sdes_received = 1;
			}
#endif
			break;
		case RTCP_PT_BYE:
			if (rtcp_debug_test_addr(addr)) {
				ast_verbose("Received a BYE from %s\n",
					ast_sockaddr_stringify(addr));
			}
			break;
		default:
			break;
		}
		position += length;
		rtp->rtcp->rtcp_info = 1;

		if (child) {
			ao2_unlock(child);
		}
	}

	return f;
}
