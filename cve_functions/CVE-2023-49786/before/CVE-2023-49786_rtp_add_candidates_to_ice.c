static void rtp_add_candidates_to_ice(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *addr, int port, int component,
				      int transport)
{
	unsigned int count = 0;
	struct ifaddrs *ifa, *ia;
	struct ast_sockaddr tmp;
	pj_sockaddr pjtmp;
	struct ast_ice_host_candidate *candidate;
	int af_inet_ok = 0, af_inet6_ok = 0;
	struct sockaddr_in stunaddr_copy;

	if (ast_sockaddr_is_ipv4(addr)) {
		af_inet_ok = 1;
	} else if (ast_sockaddr_is_any(addr)) {
		af_inet_ok = af_inet6_ok = 1;
	} else {
		af_inet6_ok = 1;
	}

	if (getifaddrs(&ifa) < 0) {
		/* If we can't get addresses, we can't load ICE candidates */
		ast_log(LOG_ERROR, "(%p) ICE Error obtaining list of local addresses: %s\n",
				instance, strerror(errno));
	} else {
		ast_debug_ice(2, "(%p) ICE add system candidates\n", instance);
		/* Iterate through the list of addresses obtained from the system,
		 * until we've iterated through all of them, or accepted
		 * PJ_ICE_MAX_CAND candidates */
		for (ia = ifa; ia && count < PJ_ICE_MAX_CAND; ia = ia->ifa_next) {
			/* Interface is either not UP or doesn't have an address assigned,
			 * eg, a ppp that just completed LCP but no IPCP yet */
			if (!ia->ifa_addr || (ia->ifa_flags & IFF_UP) == 0) {
				continue;
			}

			/* Filter out non-IPvX addresses, eg, link-layer */
			if (ia->ifa_addr->sa_family != AF_INET && ia->ifa_addr->sa_family != AF_INET6) {
				continue;
			}

			ast_sockaddr_from_sockaddr(&tmp, ia->ifa_addr);

			if (ia->ifa_addr->sa_family == AF_INET) {
				const struct sockaddr_in *sa_in = (struct sockaddr_in*)ia->ifa_addr;
				if (!af_inet_ok) {
					continue;
				}

				/* Skip 127.0.0.0/8 (loopback) */
				/* Don't use IFF_LOOPBACK check since one could assign usable
				 * publics to the loopback */
				if ((sa_in->sin_addr.s_addr & htonl(0xFF000000)) == htonl(0x7F000000)) {
					continue;
				}

				/* Skip 0.0.0.0/8 based on RFC1122, and from pjproject */
				if ((sa_in->sin_addr.s_addr & htonl(0xFF000000)) == 0) {
					continue;
				}
			} else { /* ia->ifa_addr->sa_family == AF_INET6 */
				if (!af_inet6_ok) {
					continue;
				}

				/* Filter ::1 */
				if (!ast_sockaddr_cmp_addr(&lo6, &tmp)) {
					continue;
				}
			}

			/* Pull in the host candidates from [ice_host_candidates] */
			AST_RWLIST_RDLOCK(&host_candidates);
			AST_LIST_TRAVERSE(&host_candidates, candidate, next) {
				if (!ast_sockaddr_cmp(&candidate->local, &tmp)) {
					/* candidate->local matches actual assigned, so check if
					 * advertised is blacklisted, if not, add it to the
					 * advertised list.  Not that it would make sense to remap
					 * a local address to a blacklisted address, but honour it
					 * anyway. */
					if (!rtp_address_is_ice_blacklisted(&candidate->advertised)) {
						ast_sockaddr_to_pj_sockaddr(&candidate->advertised, &pjtmp);
						pj_sockaddr_set_port(&pjtmp, port);
						ast_rtp_ice_add_cand(instance, rtp, component, transport,
								PJ_ICE_CAND_TYPE_HOST, 65535, &pjtmp, &pjtmp, NULL,
								pj_sockaddr_get_len(&pjtmp));
						++count;
					}

					if (!candidate->include_local) {
						/* We don't want to advertise the actual address */
						ast_sockaddr_setnull(&tmp);
					}

					break;
				}
			}
			AST_RWLIST_UNLOCK(&host_candidates);

			/* we had an entry in [ice_host_candidates] that matched, and
			 * didn't have include_local_address set.  Alternatively, adding
			 * that match resulted in us going to PJ_ICE_MAX_CAND */
			if (ast_sockaddr_isnull(&tmp) || count == PJ_ICE_MAX_CAND) {
				continue;
			}

			if (rtp_address_is_ice_blacklisted(&tmp)) {
				continue;
			}

			ast_sockaddr_to_pj_sockaddr(&tmp, &pjtmp);
			pj_sockaddr_set_port(&pjtmp, port);
			ast_rtp_ice_add_cand(instance, rtp, component, transport,
					PJ_ICE_CAND_TYPE_HOST, 65535, &pjtmp, &pjtmp, NULL,
					pj_sockaddr_get_len(&pjtmp));
			++count;
		}
		freeifaddrs(ifa);
	}

	ast_rwlock_rdlock(&stunaddr_lock);
	memcpy(&stunaddr_copy, &stunaddr, sizeof(stunaddr));
	ast_rwlock_unlock(&stunaddr_lock);

	/* If configured to use a STUN server to get our external mapped address do so */
	if (stunaddr_copy.sin_addr.s_addr && !stun_address_is_blacklisted(addr) &&
		(ast_sockaddr_is_ipv4(addr) || ast_sockaddr_is_any(addr)) &&
		count < PJ_ICE_MAX_CAND) {
		struct sockaddr_in answer;
		int rsp;

		ast_debug_category(3, AST_DEBUG_CATEGORY_ICE | AST_DEBUG_CATEGORY_STUN,
			"(%p) ICE request STUN %s %s candidate\n", instance,
			transport == AST_TRANSPORT_UDP ? "UDP" : "TCP",
			component == AST_RTP_ICE_COMPONENT_RTP ? "RTP" : "RTCP");

		/*
		 * The instance should not be locked because we can block
		 * waiting for a STUN respone.
		 */
		ao2_unlock(instance);
		rsp = ast_stun_request(component == AST_RTP_ICE_COMPONENT_RTCP
			? rtp->rtcp->s : rtp->s, &stunaddr_copy, NULL, &answer);
		ao2_lock(instance);
		if (!rsp) {
			struct ast_rtp_engine_ice_candidate *candidate;
			pj_sockaddr ext, base;
			pj_str_t mapped = pj_str(ast_strdupa(ast_inet_ntoa(answer.sin_addr)));
			int srflx = 1, baseset = 0;
			struct ao2_iterator i;

			pj_sockaddr_init(pj_AF_INET(), &ext, &mapped, ntohs(answer.sin_port));

			/*
			 * If the returned address is the same as one of our host
			 * candidates, don't send the srflx.  At the same time,
			 * we need to set the base address (raddr).
			 */
			i = ao2_iterator_init(rtp->ice_local_candidates, 0);
			while (srflx && (candidate = ao2_iterator_next(&i))) {
				if (!baseset && ast_sockaddr_is_ipv4(&candidate->address)) {
					baseset = 1;
					ast_sockaddr_to_pj_sockaddr(&candidate->address, &base);
				}

				if (!pj_sockaddr_cmp(&candidate->address, &ext)) {
					srflx = 0;
				}

				ao2_ref(candidate, -1);
			}
			ao2_iterator_destroy(&i);

			if (srflx && baseset) {
				pj_sockaddr_set_port(&base, port);
				ast_rtp_ice_add_cand(instance, rtp, component, transport,
					PJ_ICE_CAND_TYPE_SRFLX, 65535, &ext, &base, &base,
					pj_sockaddr_get_len(&ext));
			}
		}
	}

	/* If configured to use a TURN relay create a session and allocate */
	if (pj_strlen(&turnaddr)) {
		ast_rtp_ice_turn_request(instance, component, AST_TRANSPORT_TCP, pj_strbuf(&turnaddr), turnport,
			pj_strbuf(&turnusername), pj_strbuf(&turnpassword));
	}
}
