static struct ast_frame *create_dtmf_frame(struct ast_rtp_instance *instance, enum ast_frame_type type, int compensate)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	struct ast_sockaddr remote_address = { {0,} };

	ast_rtp_instance_get_remote_address(instance, &remote_address);

	if (((compensate && type == AST_FRAME_DTMF_END) || (type == AST_FRAME_DTMF_BEGIN)) && ast_tvcmp(ast_tvnow(), rtp->dtmfmute) < 0) {
		ast_debug_rtp(1, "(%p) RTP ignore potential DTMF echo from '%s'\n",
			instance, ast_sockaddr_stringify(&remote_address));
		rtp->resp = 0;
		rtp->dtmfsamples = 0;
		return &ast_null_frame;
	} else if (type == AST_FRAME_DTMF_BEGIN && rtp->resp == 'X') {
		ast_debug_rtp(1, "(%p) RTP ignore flash begin from '%s'\n",
			instance, ast_sockaddr_stringify(&remote_address));
		rtp->resp = 0;
		rtp->dtmfsamples = 0;
		return &ast_null_frame;
	}

	if (rtp->resp == 'X') {
		ast_debug_rtp(1, "(%p) RTP creating flash Frame at %s\n",
			instance, ast_sockaddr_stringify(&remote_address));
		rtp->f.frametype = AST_FRAME_CONTROL;
		rtp->f.subclass.integer = AST_CONTROL_FLASH;
	} else {
		ast_debug_rtp(1, "(%p) RTP creating %s DTMF Frame: %d (%c), at %s\n",
			instance, type == AST_FRAME_DTMF_END ? "END" : "BEGIN",
			rtp->resp, rtp->resp,
			ast_sockaddr_stringify(&remote_address));
		rtp->f.frametype = type;
		rtp->f.subclass.integer = rtp->resp;
	}
	rtp->f.datalen = 0;
	rtp->f.samples = 0;
	rtp->f.mallocd = 0;
	rtp->f.src = "RTP";
	AST_LIST_NEXT(&rtp->f, frame_list) = NULL;

	return &rtp->f;
}
