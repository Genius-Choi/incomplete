static void rtp_transport_wide_cc_feedback_status_append(unsigned char *rtcpheader, int *packet_len, int *status_vector_chunk_bits,
	uint16_t *status_vector_chunk, int *run_length_chunk_count, int *run_length_chunk_status, int status)
{
	if (*run_length_chunk_status != status) {
		while (*run_length_chunk_count > 0 && *run_length_chunk_count < 8) {
			/* Realistically it only makes sense to use a run length chunk if there were 8 or more
			 * consecutive packets of the same type, otherwise we could end up making the packet larger
			 * if we have lots of small blocks of the same type. To help with this we backfill the status
			 * vector (since it always represents 7 packets). Best case we end up with only that single
			 * status vector and the rest are run length chunks.
			 */
			rtp_transport_wide_cc_feedback_status_vector_append(rtcpheader, packet_len, status_vector_chunk_bits,
				status_vector_chunk, *run_length_chunk_status);
			*run_length_chunk_count -= 1;
		}

		if (*run_length_chunk_count) {
			/* There is a run length chunk which needs to be written out */
			put_unaligned_uint16(rtcpheader + *packet_len, htons((0 << 15) | (*run_length_chunk_status << 13) | *run_length_chunk_count));
			*packet_len += 2;
		}

		/* In all cases the run length chunk has to be reset */
		*run_length_chunk_count = 0;
		*run_length_chunk_status = -1;

		if (*status_vector_chunk_bits == 14) {
			/* We aren't in the middle of a status vector so we can try for a run length chunk */
			*run_length_chunk_status = status;
			*run_length_chunk_count = 1;
		} else {
			/* We're doing a status vector so populate it accordingly */
			rtp_transport_wide_cc_feedback_status_vector_append(rtcpheader, packet_len, status_vector_chunk_bits,
				status_vector_chunk, status);
		}
	} else {
		/* This is easy, the run length chunk count can just get bumped up */
		*run_length_chunk_count += 1;
	}
}
