static void rtp_instance_parse_transport_wide_cc(struct ast_rtp_instance *instance, struct ast_rtp *rtp,
	unsigned char *data, int len)
{
	uint16_t *seqno = (uint16_t *)data;
	struct rtp_transport_wide_cc_packet_statistics statistics;
	struct ast_rtp_instance *transport = rtp->bundled ? rtp->bundled : instance;
	struct ast_rtp *transport_rtp = ast_rtp_instance_get_data(transport);

	/* If the sequence number has cycled over then record it as such */
	if (((int)transport_rtp->transport_wide_cc.last_seqno - (int)ntohs(*seqno)) > 100) {
		transport_rtp->transport_wide_cc.cycles += RTP_SEQ_MOD;
	}

	/* Populate the statistics information for this packet */
	statistics.seqno = transport_rtp->transport_wide_cc.cycles + ntohs(*seqno);
	statistics.received = ast_tvnow();

	/* We allow at a maximum 1000 packet statistics in play at a time, if we hit the
	 * limit we give up and start fresh.
	 */
	if (AST_VECTOR_SIZE(&transport_rtp->transport_wide_cc.packet_statistics) > 1000) {
		AST_VECTOR_RESET(&rtp->transport_wide_cc.packet_statistics, AST_VECTOR_ELEM_CLEANUP_NOOP);
	}

	if (!AST_VECTOR_SIZE(&transport_rtp->transport_wide_cc.packet_statistics) ||
		statistics.seqno > transport_rtp->transport_wide_cc.last_extended_seqno) {
		/* This is the expected path */
		if (AST_VECTOR_APPEND(&transport_rtp->transport_wide_cc.packet_statistics, statistics)) {
			return;
		}

		transport_rtp->transport_wide_cc.last_extended_seqno = statistics.seqno;
		transport_rtp->transport_wide_cc.last_seqno = ntohs(*seqno);
	} else {
		/* This packet was out of order, so reorder it within the vector accordingly */
		if (AST_VECTOR_ADD_SORTED(&transport_rtp->transport_wide_cc.packet_statistics, statistics,
			rtp_transport_wide_cc_packet_statistics_cmp)) {
			return;
		}
	}

	/* If we have not yet scheduled the periodic sending of feedback for this transport then do so */
	if (transport_rtp->transport_wide_cc.schedid < 0 && transport_rtp->rtcp) {
		ast_debug_rtcp(1, "(%p) RTCP starting transport-cc feedback transmission on RTP instance '%p'\n", instance, transport);
		ao2_ref(transport, +1);
		transport_rtp->transport_wide_cc.schedid = ast_sched_add(rtp->sched, 1000,
			rtp_transport_wide_cc_feedback_produce, transport);
		if (transport_rtp->transport_wide_cc.schedid < 0) {
			ao2_ref(transport, -1);
			ast_log(LOG_WARNING, "Scheduling RTCP transport-cc feedback transmission failed on RTP instance '%p'\n",
				transport);
		}
	}
}
