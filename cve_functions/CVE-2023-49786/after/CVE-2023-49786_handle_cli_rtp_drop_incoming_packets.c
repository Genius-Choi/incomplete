static char *handle_cli_rtp_drop_incoming_packets(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
{
	static const char * const completions_2[] = { "stop", "<N>", NULL };
	static const char * const completions_3[] = { "random", "incoming packets", NULL };
	static const char * const completions_5[] = { "on", "every", NULL };
	static const char * const completions_units[] =	{ "random", "usec", "msec", "sec", "min", NULL };

	unsigned int use_random_num = 0;
	unsigned int use_random_interval = 0;
	unsigned int num_to_drop = 0;
	unsigned int interval = 0;
	const char *interval_s = NULL;
	const char *unit_s = NULL;
	struct ast_sockaddr addr;
	const char *addr_s = NULL;

	switch (cmd) {
	case CLI_INIT:
		e->command = "rtp drop";
		e->usage =
			"Usage: rtp drop [stop|[<N> [random] incoming packets[ every <N> [random] {usec|msec|sec|min}][ on <ip[:port]>]]\n"
			"       Drop RTP incoming packets.\n";
		return NULL;
	case CLI_GENERATE:
		use_random_num = use_random(a, a->pos, 4);
		use_random_interval = use_random(a, a->pos, 8 + use_random_num) ||
			use_random(a, a->pos, 10 + use_random_num);

		switch (a->pos - use_random_num - use_random_interval) {
		case 2:
			return ast_cli_complete(a->word, completions_2, a->n);
		case 3:
			return ast_cli_complete(a->word, completions_3 + use_random_num, a->n);
		case 5:
			return ast_cli_complete(a->word, completions_5, a->n);
		case 7:
			if (!strcasecmp(a->argv[a->pos - 2], "on")) {
				ast_cli_completion_add(ast_strdup("every"));
				break;
			}
			/* Fall through */
		case 9:
			if (!strcasecmp(a->argv[a->pos - 2 - use_random_interval], "every")) {
				return ast_cli_complete(a->word, completions_units + use_random_interval, a->n);
			}
			break;
		case 8:
			if (!strcasecmp(a->argv[a->pos - 3 - use_random_interval], "every")) {
				ast_cli_completion_add(ast_strdup("on"));
			}
			break;
		}

		return NULL;
	}

	if (a->argc < 3) {
		return CLI_SHOWUSAGE;
	}

	use_random_num = use_random(a, a->argc, 4);
	use_random_interval = use_random(a, a->argc, 8 + use_random_num) ||
		use_random(a, a->argc, 10 + use_random_num);

	if (!strcasecmp(a->argv[2], "stop")) {
		/* rtp drop stop */
	} else if (a->argc < 5) {
		return CLI_SHOWUSAGE;
	} else if (ast_str_to_uint(a->argv[2], &num_to_drop)) {
		ast_cli(a->fd, "%s is not a valid number of packets to drop\n", a->argv[2]);
		return CLI_FAILURE;
	} else if (a->argc - use_random_num == 5) {
		/* rtp drop <N> [random] incoming packets */
	} else if (a->argc - use_random_num >= 7 && !strcasecmp(a->argv[5 + use_random_num], "on")) {
		/* rtp drop <N> [random] incoming packets on <ip[:port]> */
		addr_s = a->argv[6 + use_random_num];
		if (a->argc - use_random_num - use_random_interval == 10 &&
				!strcasecmp(a->argv[7 + use_random_num], "every")) {
			/* rtp drop <N> [random] incoming packets on <ip[:port]> every <N> [random] {usec|msec|sec|min} */
			interval_s = a->argv[8 + use_random_num];
			unit_s = a->argv[9 + use_random_num + use_random_interval];
		}
	} else if (a->argc - use_random_num >= 8 && !strcasecmp(a->argv[5 + use_random_num], "every")) {
		/* rtp drop <N> [random] incoming packets every <N> [random] {usec|msec|sec|min} */
		interval_s = a->argv[6 + use_random_num];
		unit_s = a->argv[7 + use_random_num + use_random_interval];
		if (a->argc == 10 + use_random_num + use_random_interval &&
				!strcasecmp(a->argv[8 + use_random_num + use_random_interval], "on")) {
			/* rtp drop <N> [random] incoming packets every <N> [random] {usec|msec|sec|min} on <ip[:port]> */
			addr_s = a->argv[9 + use_random_num + use_random_interval];
		}
	} else {
		return CLI_SHOWUSAGE;
	}

	if (a->argc - use_random_num >= 8 && !interval_s && !addr_s) {
		return CLI_SHOWUSAGE;
	}

	if (interval_s && ast_str_to_uint(interval_s, &interval)) {
		ast_cli(a->fd, "%s is not a valid interval number\n", interval_s);
		return CLI_FAILURE;
	}

	memset(&addr, 0, sizeof(addr));
	if (addr_s && !ast_sockaddr_parse(&addr, addr_s, 0)) {
		ast_cli(a->fd, "%s is not a valid hostname[:port]\n", addr_s);
		return CLI_FAILURE;
	}

	drop_packets_data.use_random_num = use_random_num;
	drop_packets_data.use_random_interval = use_random_interval;
	drop_packets_data.num_to_drop = num_to_drop;
	drop_packets_data.interval = ast_time_create_by_unit_str(interval, unit_s);
	ast_sockaddr_copy(&drop_packets_data.addr, &addr);
	drop_packets_data.port = ast_sockaddr_port(&addr);

	drop_packets_data_update(ast_tvnow());

	return CLI_SUCCESS;
}
