static void calc_rxstamp_and_jitter(struct timeval *tv,
	struct ast_rtp *rtp, unsigned int rx_rtp_ts,
	int mark)
{
	int rate = ast_rtp_get_rate(rtp->f.subclass.format);

	double jitter = 0.0;
	double prev_jitter = 0.0;
	struct timeval now;
	struct timeval tmp;
	double rxnow;
	double arrival_sec;
	unsigned int arrival;
	int transit;
	int d;

	gettimeofday(&now,NULL);

	if (rtp->rxcount == 1 || mark) {
		rtp->rxstart = ast_tv2double(&now);
		rtp->remote_seed_rx_rtp_ts = rx_rtp_ts;

		/*
		 * "tv" is placed in the received frame's
		 * "delivered" field and when this frame is
		 * sent out again on the other side, it's
		 * used to calculate the timestamp on the
		 * outgoing RTP packets.
		 *
		 * NOTE: We need to do integer math here
		 * because double math rounding issues can
		 * generate incorrect timestamps.
		 */
		rtp->rxcore = now;
		tmp = ast_samp2tv(rx_rtp_ts, rate);
		rtp->rxcore = ast_tvsub(rtp->rxcore, tmp);
		rtp->rxcore.tv_usec -= rtp->rxcore.tv_usec % 100;
		*tv = ast_tvadd(rtp->rxcore, tmp);

		ast_debug_rtcp(3, "%s: "
			"Seed ts: %u current time: %f\n",
			ast_rtp_instance_get_channel_id(rtp->owner)
			, rx_rtp_ts
			, rtp->rxstart
		);

		return;
	}

	tmp = ast_samp2tv(rx_rtp_ts, rate);
	/* See the comment about "tv" above. Even if
	 * we don't use this received packet for jitter
	 * calculations, we still need to set tv so the
	 * timestamp will be correct when this packet is
	 * sent out again.
	 */
	*tv = ast_tvadd(rtp->rxcore, tmp);

	/*
	 * The first few packets are generally unstable so let's
	 * not use them in the calculations.
	 */
	if (rtp->rxcount < RTP_IGNORE_FIRST_PACKETS_COUNT) {
		ast_debug_rtcp(3, "%s: Packet %d < %d.  Ignoring\n",
			ast_rtp_instance_get_channel_id(rtp->owner)
			, rtp->rxcount
			, RTP_IGNORE_FIRST_PACKETS_COUNT
		);

		return;
	}

	/*
	 * First good packet. Capture the start time and timestamp
	 * but don't actually use this packet for calculation.
	 */
	if (rtp->rxcount == RTP_IGNORE_FIRST_PACKETS_COUNT) {
		rtp->rxstart_stable = ast_tv2double(&now);
		rtp->remote_seed_rx_rtp_ts_stable = rx_rtp_ts;
		rtp->last_transit_time_samples = -rx_rtp_ts;

		ast_debug_rtcp(3, "%s: "
			"pkt: %5u Stable Seed ts: %u current time: %f\n",
			ast_rtp_instance_get_channel_id(rtp->owner)
			, rtp->rxcount
			, rx_rtp_ts
			, rtp->rxstart_stable
		);

		return;
	}

	/*
	 * If the current packet isn't in sequence, don't
	 * use it in any calculations as remote_current_rx_rtp_ts
	 * is not going to be correct.
	 */
	if (rtp->lastrxseqno != rtp->prevrxseqno + 1) {
		ast_debug_rtcp(3, "%s: Current packet seq %d != last packet seq %d + 1.  Ignoring\n",
			ast_rtp_instance_get_channel_id(rtp->owner)
			, rtp->lastrxseqno
			, rtp->prevrxseqno
		);

		return;
	}

	/*
	 * The following calculations are taken from
	 * https://www.rfc-editor.org/rfc/rfc3550#appendix-A.8
	 *
	 * The received rtp timestamp is the random "seed"
	 * timestamp chosen by the sender when they sent the
	 * first packet, plus the number of samples since then.
	 *
	 * To get our arrival time in the same units, we
	 * calculate the time difference in seconds between
	 * when we received the first packet and when we
	 * received this packet and convert that to samples.
	 */
	rxnow = ast_tv2double(&now);
	arrival_sec = rxnow - rtp->rxstart_stable;
	arrival = ast_sec2samp(arrival_sec, rate);

	/*
	 * Now we can use the exact formula in
	 * https://www.rfc-editor.org/rfc/rfc3550#appendix-A.8 :
	 *
	 * int transit = arrival - r->ts;
	 * int d = transit - s->transit;
	 * s->transit = transit;
	 * if (d < 0) d = -d;
	 * s->jitter += (1./16.) * ((double)d - s->jitter);
	 *
	 * Our rx_rtp_ts is their r->ts.
	 * Our rtp->last_transit_time_samples is their s->transit.
	 * Our rtp->rxjitter is their s->jitter.
	 */
	transit = arrival - rx_rtp_ts;
	d = transit - rtp->last_transit_time_samples;

	if (d < 0) {
		d = -d;
	}

	prev_jitter = rtp->rxjitter_samples;
	jitter = (1.0/16.0) * (((double)d) - prev_jitter);
	rtp->rxjitter_samples = prev_jitter + jitter;

	/*
	 * We need to hang on to jitter in both samples and seconds.
	 */
	rtp->rxjitter = ast_samp2sec(rtp->rxjitter_samples, rate);

	ast_debug_rtcp(3, "%s: pkt: %5u "
		"Arrival sec: %7.3f  Arrival ts: %10u  RX ts: %10u "
		"Transit samp: %6d Last transit samp: %6d d: %4d "
		"Curr jitter: %7.0f(%7.3f) Prev Jitter: %7.0f(%7.3f) New Jitter: %7.0f(%7.3f)\n",
		ast_rtp_instance_get_channel_id(rtp->owner)
		, rtp->rxcount
		, arrival_sec
		, arrival
		, rx_rtp_ts
		, transit
		, rtp->last_transit_time_samples
		, d
		, jitter
		, ast_samp2sec(jitter, rate)
		, prev_jitter
		, ast_samp2sec(prev_jitter, rate)
		, rtp->rxjitter_samples
		, rtp->rxjitter
		);

	rtp->last_transit_time_samples = transit;

	/*
	 * Update all the stats.
	 */
	if (rtp->rtcp) {
		if (rtp->rxjitter > rtp->rtcp->maxrxjitter)
			rtp->rtcp->maxrxjitter = rtp->rxjitter;
		if (rtp->rtcp->rxjitter_count == 1)
			rtp->rtcp->minrxjitter = rtp->rxjitter;
		if (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter)
			rtp->rtcp->minrxjitter = rtp->rxjitter;

		calc_mean_and_standard_deviation(rtp->rxjitter,
			&rtp->rtcp->normdev_rxjitter, &rtp->rtcp->stdev_rxjitter,
			&rtp->rtcp->rxjitter_count);
	}

	return;
}
