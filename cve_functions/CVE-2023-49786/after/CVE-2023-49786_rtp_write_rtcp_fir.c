static void rtp_write_rtcp_fir(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *remote_address)
{
	unsigned char *rtcpheader;
	unsigned char bdata[1024];
	int packet_len = 0;
	int fir_len = 20;
	int ice;
	int res;
	int sr;
	RAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);

	if (!rtp || !rtp->rtcp) {
		return;
	}

	if (ast_sockaddr_isnull(&rtp->rtcp->them) || rtp->rtcp->schedid < 0) {
		/*
		 * RTCP was stopped.
		 */
		return;
	}

	if (!rtp->themssrc_valid) {
		/* We don't know their SSRC value so we don't know who to update. */
		return;
	}

	/* Prepare RTCP FIR (PT=206, FMT=4) */
	rtp->rtcp->firseq++;
	if(rtp->rtcp->firseq == 256) {
		rtp->rtcp->firseq = 0;
	}

	rtcpheader = bdata;

	ao2_lock(instance);
	rtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);
	res = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);

	if (res == 0 || res == 1) {
		ao2_unlock(instance);
		return;
	}

	packet_len += res;

	put_unaligned_uint32(rtcpheader + packet_len + 0, htonl((2 << 30) | (4 << 24) | (RTCP_PT_PSFB << 16) | ((fir_len/4)-1)));
	put_unaligned_uint32(rtcpheader + packet_len + 4, htonl(rtp->ssrc));
	put_unaligned_uint32(rtcpheader + packet_len + 8, htonl(rtp->themssrc));
	put_unaligned_uint32(rtcpheader + packet_len + 12, htonl(rtp->themssrc)); /* FCI: SSRC */
	put_unaligned_uint32(rtcpheader + packet_len + 16, htonl(rtp->rtcp->firseq << 24)); /* FCI: Sequence number */
	res = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len + fir_len, 0, rtp->bundled ? remote_address : &rtp->rtcp->them, &ice);
	if (res < 0) {
		ast_log(LOG_ERROR, "RTCP FIR transmission error: %s\n", strerror(errno));
	} else {
		ast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, rtp->bundled ? *remote_address : rtp->rtcp->them, ice, sr);
	}

	ao2_unlock(instance);
}
