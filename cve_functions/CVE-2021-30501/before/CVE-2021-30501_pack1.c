void PackMachBase<T>::pack1(OutputFile *const fo, Filter &/*ft*/)  // generate executable header
{
    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];
    mhdro = mhdri;
    if (my_filetype==Mach_header::MH_EXECUTE) {
        memcpy(&mhdro, stub_main, sizeof(mhdro));
        mhdro.flags = mhdri.flags & ~(
              Mach_header::MH_DYLDLINK  // no dyld at this time
            | Mach_header::MH_TWOLEVEL  // dyld-specific
            | Mach_header::MH_BINDATLOAD  // dyld-specific
            );
        COMPILE_TIME_ASSERT(sizeof(mhdro.flags) == sizeof(unsigned))
    }
    unsigned pos = sizeof(mhdro);
    fo->write(&mhdro, sizeof(mhdro));

    memset(&segZERO, 0, sizeof(segZERO));
    segZERO.cmd = lc_seg;
    segZERO.cmdsize = sizeof(segZERO);
    strncpy((char *)segZERO.segname, "__PAGEZERO", sizeof(segZERO.segname));
    segZERO.vmsize = PAGE_SIZE;
    if __acc_cte(sizeof(segZERO.vmsize) == 8
    && mhdro.filetype == Mach_header::MH_EXECUTE
    && mhdro.cputype == Mach_header::CPU_TYPE_X86_64) {
        if (pagezero_vmsize < 0xF0000000ull) {
            segZERO.vmsize = pagezero_vmsize;
        }
        else {
            segZERO.vmsize <<= 20;  // (1ul<<32)
        }
    }

    segTEXT.cmd = lc_seg;
    segTEXT.cmdsize = sizeof(segTEXT) + sizeof(secTEXT);
    strncpy((char *)segTEXT.segname, "__TEXT", sizeof(segTEXT.segname));
    if (my_filetype==Mach_header::MH_EXECUTE) {
        if (Mach_header::MH_PIE & mhdri.flags) {
            segTEXT.vmaddr = segZERO.vmsize;  // contiguous
        }
        else { // not MH_PIE
            // Start above all eventual mappings.
            // Cannot enlarge segZERO.vmsize because MacOS 10.13 (HighSierra)
            // won't permit re-map of PAGEZERO.
            // Stub will fill with PROT_NONE first.
            segTEXT.vmaddr = vma_max;
        }
    }
    if (my_filetype==Mach_header::MH_DYLIB) {
        segTEXT.vmaddr = 0;
    }
    segTEXT.vmsize = 0;    // adjust later
    segTEXT.fileoff = 0;
    segTEXT.filesize = 0;  // adjust later
    segTEXT.maxprot =
        Mach_command::VM_PROT_READ |
        Mach_command::VM_PROT_WRITE |
        Mach_command::VM_PROT_EXECUTE;
    segTEXT.initprot =
        Mach_command::VM_PROT_READ |
        Mach_command::VM_PROT_EXECUTE;
    segTEXT.nsects = 1;  // secTEXT
    segTEXT.flags = 0;

    memset(&secTEXT, 0, sizeof(secTEXT));
    strncpy((char *)secTEXT.sectname, "__text", sizeof(secTEXT.sectname));
    memcpy(secTEXT.segname, segTEXT.segname, sizeof(secTEXT.segname));
    secTEXT.align = 2;  // (1<<2) ==> 4
    secTEXT.flags = Mach_section_command::S_REGULAR
        | Mach_section_command::S_ATTR_SOME_INSTRUCTIONS
        | Mach_section_command::S_ATTR_PURE_INSTRUCTIONS;

    segXHDR = segTEXT;
    segXHDR.cmdsize = sizeof(segXHDR) + sizeof(secXHDR);
    segXHDR.vmaddr = segZERO.vmsize;
    segXHDR.vmsize = PAGE_SIZE;
    segXHDR.filesize = PAGE_SIZE;
    segXHDR.nsects = 1;
    strncpy((char *)segXHDR.segname,  "UPX_DATA", sizeof(segXHDR.segname));

    memset(&secXHDR, 0, sizeof(secXHDR));
    strncpy((char *)secXHDR.sectname, "upx_data", sizeof(secXHDR.sectname));
    memcpy(secXHDR.segname,  segXHDR.segname, sizeof(secXHDR.segname));
    secXHDR.addr = segXHDR.vmaddr;
    secXHDR.size = 0;  // empty so far
    secXHDR.align = 2;  // (1<<2) ==> 4

    segLINK = segTEXT;
    segLINK.cmdsize = sizeof(segLINK);
    strncpy((char *)segLINK.segname, "__LINKEDIT", sizeof(segLINK.segname));
    segLINK.initprot = Mach_command::VM_PROT_READ;
    segLINK.nsects = 0;
    segLINK.vmsize = 0;
    // Adjust later: .vmaddr .vmsize .fileoff .filesize

    unsigned gap = 0;
    if (my_filetype == Mach_header::MH_EXECUTE) {
        unsigned cmdsize = mhdro.sizeofcmds;
        Mach_header const *const ptr0 = (Mach_header const *)stub_main;
        Mach_command const *ptr1 = (Mach_command const *)(1+ ptr0);
        for (unsigned j = 0; j < mhdro.ncmds -1; ++j, (cmdsize -= ptr1->cmdsize),
                ptr1 = (Mach_command const *)(ptr1->cmdsize + (char const *)ptr1)) {
            if (lc_seg == ptr1->cmd) {
                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr1;
                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);
                if (!strcmp("__TEXT", segptr->segname)) {
                    strncpy((char *)secTEXT.segname,   "__TEXT", sizeof(secTEXT.segname));
                    strncpy((char *)secTEXT.sectname, "upxTEXT", sizeof(secTEXT.sectname));
                    secTEXT.addr   = secptr->addr;
                    secTEXT.size   = secptr->size;  // update later
                    secTEXT.offset = secptr->offset;
                    secTEXT.align  = secptr->align;
                }
                if (!strcmp("__LINKEDIT", segptr->segname)) {
                    // Mach_command before __LINKEDIT
                    pos += (char const *)ptr1 - (char const *)(1+ ptr0);
                    fo->write((1+ ptr0), (char const *)ptr1 - (char const *)(1+ ptr0));

                    // Mach_command __LINKEDIT and after
                    pos += cmdsize;
                    fo->write((char const *)ptr1, cmdsize);

                    // 400: space for LC_UUID, LC_RPATH, LC_CODE_SIGNATURE, etc.
                    gap = 400 + threado_size();
                    secTEXT.offset = gap + pos;
                    secTEXT.addr = secTEXT.offset + segTEXT.vmaddr;
                    break;
                }
            }
        }
        unsigned const sz_threado = threado_size();
        MemBuffer space(sz_threado); memset(space, 0, sz_threado);
        fo->write(space, sz_threado);
    }
    else if (my_filetype == Mach_header::MH_DYLIB) {
        Mach_command const *ptr = (Mach_command const *)rawmseg;
        unsigned cmdsize = mhdri.sizeofcmds;
        for (unsigned j = 0; j < mhdri.ncmds; ++j, (cmdsize -= ptr->cmdsize),
                ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr)) {
            if (lc_seg == ptr->cmd) {
                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;
                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);
                if (!strcmp("__TEXT", segptr->segname)) {
                    if (!(1 <= segptr->nsects)) {
                        throwCantPack("TEXT.nsects == 0");
                    }
                    strncpy((char *)secTEXT.sectname, "upxTEXT", sizeof(secTEXT.sectname));
                    secTEXT.addr   = secptr->addr;
                    secTEXT.size   = secptr->size;  // update later
                    secTEXT.offset = secptr->offset;
                    secTEXT.align  = secptr->align;
                    fo->write(&segTEXT, sizeof(segTEXT));
                    fo->write(&secTEXT, sizeof(secTEXT));
                }
                else { // not __TEXT
                    fo->write(ptr, ptr->cmdsize);
                }
            }
            else { // not LC_SEGMENT*
                fo->write(ptr, ptr->cmdsize);
            }
        }
        memset(&linkitem, 0, sizeof(linkitem));
        fo->write(&linkitem, sizeof(linkitem));
    }
    sz_mach_headers = fo->getBytesWritten();
    gap = secTEXT.offset - sz_mach_headers;
    MemBuffer filler(gap); filler.clear();
    fo->write(filler, gap);
    sz_mach_headers += gap;

    memset((char *)&linfo, 0, sizeof(linfo));
    fo->write(&linfo, sizeof(linfo));

    return;
}
