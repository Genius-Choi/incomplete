void PackMachBase<T>::pack4dylib(  // append PackHeader
    OutputFile *const fo,
    Filter &ft,
    Addr init_address
)
{
    fo->seek(0, SEEK_SET);
    fo->rewrite(&mhdro, sizeof(mhdro));  // segTEXT.nsect=1 (only secTEXT)
    fo->rewrite(&segTEXT, sizeof(segTEXT));  // .vmsize
    unsigned opos = sizeof(mhdro);

    // Append each non-__TEXT segment, page aligned.
    int slide = 0;
    unsigned o_end_txt = 0;
    unsigned hdrpos = sizeof(mhdro);
    Mach_segment_command const *seg = rawmseg;
    Mach_segment_command const *const endseg =
        (Mach_segment_command const *)(mhdri.sizeofcmds + (char const *)seg);
    for ( ; seg < endseg; seg = (Mach_segment_command const *)(
            seg->cmdsize + (char const *)seg )
    ) switch (seg->cmd & ~Mach_command::LC_REQ_DYLD) {
    default:  // unknown if any file offset field must slide
        fprintf(stderr, "Unrecognized Macho cmd  offset=0x%lx  cmd=0x%lx  size=0x%lx\n",
            (unsigned long)((const char *)seg - (const char *)rawmseg),
            (unsigned long)seg->cmd, (unsigned long)seg->cmdsize);
        // fall through
    case Mach_command::LC_VERSION_MIN_MACOSX:
    case Mach_command::LC_SOURCE_VERSION:
    case Mach_command::LC_THREAD:
    case Mach_command::LC_UNIXTHREAD:
    case Mach_command::LC_LOAD_DYLIB:
    case Mach_command::LC_ID_DYLIB:
    case Mach_command::LC_LOAD_DYLINKER:
    case Mach_command::LC_UUID:
    case Mach_command::LC_RPATH:
    case Mach_command::LC_REEXPORT_DYLIB: { // contain no file offset fields
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(seg, seg->cmdsize);
        hdrpos += seg->cmdsize;
    } break;

    case Mach_command::LC_CODE_SIGNATURE:
    case Mach_command::LC_SEGMENT_SPLIT_INFO:
    case Mach_command::LC_DYLIB_CODE_SIGN_DRS:
    case Mach_command::LC_DATA_IN_CODE:
    case Mach_command::LC_FUNCTION_STARTS: {
        Mach_linkedit_data_command cmd; memcpy(&cmd, seg, sizeof(cmd));
        if (o_end_txt <= cmd.dataoff) { cmd.dataoff += slide; }
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(&cmd, sizeof(cmd));
        hdrpos += sizeof(cmd);
    } break;
    case Mach_command::LC_DYLD_INFO_ONLY & ~Mach_command::LC_REQ_DYLD: {
        Mach_dyld_info_only_command cmd; memcpy(&cmd, seg, sizeof(cmd));
        if (o_end_txt <= cmd.rebase_off)    { cmd.rebase_off    += slide; }
        if (o_end_txt <= cmd.bind_off)      { cmd.bind_off      += slide; }
        if (o_end_txt <= cmd.weak_bind_off) { cmd.weak_bind_off += slide; }
        if (o_end_txt <= cmd.lazy_bind_off) { cmd.lazy_bind_off += slide; }
        if (o_end_txt <= cmd.export_off)    { cmd.export_off    += slide; }
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(&cmd, sizeof(cmd));
        hdrpos += sizeof(cmd);
    } break;
    case Mach_command::LC_TWOLEVEL_HINTS: {
        Mach_twolevel_hints_command cmd; memcpy(&cmd, seg, sizeof(cmd));
        if (o_end_txt <= cmd.offset) { cmd.offset += slide; }
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(&cmd, sizeof(cmd));
        hdrpos += sizeof(cmd);
    } break;
    case Mach_command::LC_ROUTINES_64:
    case Mach_command::LC_ROUTINES: {
        Mach_routines_command cmd; memcpy(&cmd, seg, sizeof(cmd));
        cmd.reserved1 = cmd.init_address;
        cmd.init_address = init_address;
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(&cmd, sizeof(cmd));
        hdrpos += sizeof(cmd);
    } break;
    case Mach_command::LC_SEGMENT_64:
    case Mach_command::LC_SEGMENT: {
        // non-__TEXT might be observed and relocated by dyld before us.
        Mach_segment_command segcmdtmp = *seg;
        bool const is_text = 0==strncmp(&seg->segname[0], "__TEXT", 1+ 6);
        {
            if (is_text) {
                slide = 0;
                segTEXT.vmsize = segTEXT.filesize = fo->getBytesWritten();
                segTEXT.maxprot  |= Mach_command::VM_PROT_WRITE;
                segcmdtmp = segTEXT;
                opos = o_end_txt = segcmdtmp.filesize + segcmdtmp.fileoff;
            }
            else {
                opos += ~PAGE_MASK & (0u - opos);  // advance to PAGE_SIZE boundary
                slide = opos - segcmdtmp.fileoff;
                segcmdtmp.fileoff = opos;
            }

            fo->seek(hdrpos, SEEK_SET);
            fo->rewrite(&segcmdtmp, sizeof(segcmdtmp));
            hdrpos += sizeof(segcmdtmp);

            // Update the sections.
            Mach_section_command const *secp =
                (Mach_section_command const *)(const void*)(const char*)(1+ seg);
            if (is_text) {
                secTEXT.offset = secp->offset;
                secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;
                secTEXT.size = segTEXT.filesize - secTEXT.offset;
                secp = &secTEXT;
            }
            unsigned const nsects = (is_text ? 1 : segcmdtmp.nsects);
            Mach_section_command seccmdtmp;
            for (unsigned j = 0; j < nsects; ++secp, ++j) {
                seccmdtmp = *secp;
                if (o_end_txt <= seccmdtmp.offset) { seccmdtmp.offset += slide; }
                if (o_end_txt <= seccmdtmp.reloff) { seccmdtmp.reloff += slide; }
                fo->rewrite(&seccmdtmp, sizeof(seccmdtmp));
                hdrpos += sizeof(seccmdtmp);
            }

            if (!is_text) {
                unsigned const len = seg->filesize;
                MemBuffer data(len);
                fi->seek(seg->fileoff, SEEK_SET);
                fi->readx(data, len);
                unsigned const pos = o__mod_init_func - seg->fileoff;
                if (pos < seg->filesize) {
                    if (*(unsigned *)(pos + data) != (unsigned)prev_mod_init_func) {
                        throwCantPack("__mod_init_func inconsistent");
                    }
                    *(unsigned *)(pos + data) = (unsigned)entryVMA;
                }
                fo->seek(opos, SEEK_SET);
                fo->write(data, len);
                opos += len;
            }
        }
    } break;
    case Mach_command::LC_SYMTAB: {
        Mach_symtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));
        if (o_end_txt <= cmd.symoff) { cmd.symoff += slide; }
        if (o_end_txt <= cmd.stroff) { cmd.stroff += slide; }
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(&cmd, sizeof(cmd));
        hdrpos += sizeof(cmd);
    } break;
    case Mach_command::LC_DYSYMTAB: {
        Mach_dysymtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));
        if (o_end_txt <= cmd.tocoff)         { cmd.tocoff         += slide; }
        if (o_end_txt <= cmd.modtaboff)      { cmd.modtaboff      += slide; }
        if (o_end_txt <= cmd.extrefsymoff)   { cmd.extrefsymoff   += slide; }
        if (o_end_txt <= cmd.indirectsymoff) { cmd.indirectsymoff += slide; }
        if (o_end_txt <= cmd.extreloff)      { cmd.extreloff      += slide; }
        if (o_end_txt <= cmd.locreloff)      { cmd.locreloff      += slide; }
        fo->seek(hdrpos, SEEK_SET);
        fo->rewrite(&cmd, sizeof(cmd));
        hdrpos += sizeof(cmd);
    } break;
    }  // end 'switch'
    fo->seek(opos, SEEK_SET);  // BUG: "fo->seek(0, SEEK_END);" is broken

    PackMachBase<T>::pack4(fo, ft);
}
