static void dasher_process_hls_ll(GF_DasherCtx *ctx, const GF_FilterEvent *evt)
{
	u32 i, count = gf_list_count(ctx->pids);
	GF_DASH_SegmentContext *sctx;
	GF_DashStream *ds = NULL;

	if (ctx->forward_mode)
		return;

	if (!ctx->store_seg_states) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Received fragment size info event but no associated segment state\n"));
		return;
	}
	for (i=0; i<count; i++) {
		ds = gf_list_get(ctx->pids, i);
		if (ds->opid == evt->base.on_pid) break;
		ds = NULL;
	}
	if (!ds) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Received fragment size info event but no associated pid\n"));
		return;
	}
	if (ds->muxed_base)
		ds = ds->muxed_base;

	sctx = gf_list_get(ds->pending_segment_states, 0);
	if (!sctx || !ctx->nb_seg_url_pending) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Received segment size info event but no pending segments\n"));
		return;
	}
	sctx->frags = gf_realloc(sctx->frags, sizeof (GF_DASH_FragmentContext) * (sctx->nb_frags+1));
	if (!sctx->frags) {
		sctx->nb_frags = 0;
		return;
	}
	sctx->frags[sctx->nb_frags].size = evt->frag_size.size;
	sctx->frags[sctx->nb_frags].offset = evt->frag_size.offset;
	if (evt->frag_size.duration.den) {
		sctx->frags[sctx->nb_frags].duration = (u32) ((u64) evt->frag_size.duration.num * ds->rep->timescale / evt->frag_size.duration.den);
	} else {
		sctx->frags[sctx->nb_frags].duration = 0;
	}

	sctx->frags[sctx->nb_frags].independent = evt->frag_size.independent;
	sctx->nb_frags++;
	if (evt->frag_size.is_last) {
		sctx->llhls_done = GF_TRUE;
	} else {
		ctx->force_hls_ll_manifest = GF_TRUE;
	}
}
