static void mpeg2ps_scan_file (mpeg2ps_t *ps)
{
	u8 stream_id, stream_ix, substream, av_ix, max_cnt;
	u16 pes_len, pes_left;
	mpeg2ps_ts_t ts;
	s64 loc, first_video_loc = 0, first_audio_loc = 0;
	s64 check, orig_check;
	mpeg2ps_stream_t *sptr;
	Bool valid_stream;
	u8 *buffer;
	u32 buflen;
	Bool have_ts;

	ps->end_loc = file_size(ps->fd);
	orig_check = check = MAX(ps->end_loc / 50, 200 * 1024);

	/*
	 * This part reads and finds the streams.  We check up until we
	 * find audio and video plus a little, with a max of either 200K or
	 * the file size / 50
	 */
	loc = 0;
	while (read_to_next_pes_header(ps->fd, &stream_id, &pes_len) &&
	        loc < check) {
		pes_left = pes_len;
		if (stream_id >= 0xbd && stream_id < 0xf0) {
			loc = file_location(ps->fd) - 6;
			if (read_pes_header_data(ps->fd,
			                         pes_len,
			                         &pes_left,
			                         &have_ts,
			                         &ts) == 0) {
				return;
			}
			valid_stream = 0;
			substream = 0;
			if (stream_id == 0xbd) {
				if (file_read_bytes(ps->fd, &substream, 1) == 0) {
					return;
				}
				pes_left--; // remove byte we just read
				if ((substream >= 0x80 && substream < 0x90) ||
				        (substream >= 0xa0 && substream < 0xb0)) {
					valid_stream = 1;
				}
			} else if (stream_id >= 0xc0) {
				// audio and video
				valid_stream = 1;
			}
			if (valid_stream) {
				if (add_stream(ps, stream_id, substream, loc, &ts)) {
					// added
					if (stream_id >= 0xe0) {
						if (ps->video_cnt == 1) {
							first_video_loc = loc;
						}
					} else if (ps->audio_cnt == 1) {
						first_audio_loc = loc;
					}
					if (ps->audio_cnt > 0 && ps->video_cnt > 0) {
						s64 diff;
						if (first_audio_loc > first_video_loc)
							diff = first_audio_loc - first_video_loc;
						else
							diff = first_video_loc - first_audio_loc;
						diff *= 2;
						diff += first_video_loc;
						if (diff < check) {
							check = diff;
						}
					}
				}
			}
		}
		file_skip_bytes(ps->fd, pes_left);
	}
	if (ps->video_cnt == 0 && ps->audio_cnt == 0) {
		return;
	}
	/*
	 * Now, we go to close to the end, and try to find the last
	 * dts that we can
	 */
	file_seek_to(ps->fd, ps->end_loc - orig_check);

	while (read_to_next_pes_header(ps->fd, &stream_id, &pes_len)) {
		loc = file_location(ps->fd) - 6;
		if (stream_id == 0xbd || (stream_id >= 0xc0 && stream_id < 0xf0)) {
			if (read_pes_header_data(ps->fd,
			                         pes_len,
			                         &pes_left,
			                         &have_ts,
			                         &ts) == 0) {
				return;
			}
			if (stream_id == 0xbd) {
				if (file_read_bytes(ps->fd, &substream, 1) == 0) {
					return;
				}
				pes_left--; // remove byte we just read
				if (!((substream >= 0x80 && substream < 0x90) ||
				        (substream >= 0xa0 && substream < 0xb0))) {
					file_skip_bytes(ps->fd, pes_left);
					continue;
				}
			} else {
				substream = 0;
			}
			sptr = find_stream_from_id(ps, stream_id, substream);
			if (sptr == NULL) {
				add_stream(ps, stream_id, substream, 0, NULL);
				sptr = find_stream_from_id(ps, stream_id, substream);
			}
			if (sptr != NULL && have_ts) {
				sptr->end_dts = ts.have_dts ? ts.dts : ts.pts;
				sptr->end_dts_loc = loc;
			}
			file_skip_bytes(ps->fd, pes_left);
		}
	}

	/*
	 * Now, get the info for all streams, so we can use it again
	 * we could do this before the above, I suppose
	 */
	get_info_for_all_streams(ps);

	ps->first_dts = (u64) -1;

	/*
	 * we need to find the earliest start pts - we use that to calc
	 * the rest of the timing, so we're 0 based.
	 */
	for (av_ix = 0; av_ix < 2; av_ix++) {
		if (av_ix == 0) max_cnt = ps->video_cnt;
		else max_cnt = ps->audio_cnt;

		for (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {
			sptr = av_ix == 0 ? ps->video_streams[stream_ix] :
			       ps->audio_streams[stream_ix];
			if (sptr != NULL && sptr->start_dts < ps->first_dts) {
				ps->first_dts = sptr->start_dts;
			}
		}
	}

	/*
	 * Now, for each thread, we'll start at the last pts location, and
	 * read the number of frames.  This will give us a max time
	 */
	for (av_ix = 0; av_ix < 2; av_ix++) {
		if (av_ix == 0) max_cnt = ps->video_cnt;
		else max_cnt = ps->audio_cnt;
		for (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {
			u32 frame_cnt_since_last;
			sptr = av_ix == 0 ? ps->video_streams[stream_ix] :
			       ps->audio_streams[stream_ix];

			// pick up here - find the final time...
			if (sptr && (sptr->end_dts_loc != 0)) {
				file_seek_to(ps->fd, sptr->end_dts_loc);
				sptr->m_fd = ps->fd;
				frame_cnt_since_last = 0;
				clear_stream_buffer(sptr);
				while (mpeg2ps_stream_read_frame(sptr,
				                                 &buffer,
				                                 &buflen,
				                                 1)) {
					frame_cnt_since_last++;
				}
				sptr->m_fd = FDNULL;
				clear_stream_buffer(sptr);
				ps->max_time = MAX(ps->max_time,
				                   convert_ts(sptr,
				                              TS_MSEC,
				                              sptr->end_dts,
				                              ps->first_dts,
				                              frame_cnt_since_last));
			}
		}
	}

	ps->max_dts = (ps->max_time * 90) + ps->first_dts;
	file_seek_to(ps->fd, 0);
}
