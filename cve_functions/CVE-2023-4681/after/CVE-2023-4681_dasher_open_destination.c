static void dasher_open_destination(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_Representation *rep, const char *szInitURL, u32 trash_init)
{
	GF_Err e;
	Bool has_frag=GF_FALSE;
	Bool has_subs=GF_FALSE;
	Bool has_strun=GF_FALSE;
	Bool has_vodcache=GF_FALSE;
	Bool has_cmaf=GF_FALSE;
	Bool has_psshs=GF_FALSE;
	const GF_PropertyValue *p;
	char sep_args = gf_filter_get_sep(filter, GF_FS_SEP_ARGS);
	char sep_name = gf_filter_get_sep(filter, GF_FS_SEP_NAME);
	const char *dst_args, *trailer_args=NULL, *dst_forced=NULL;
	char *szDST = NULL;
	char szSRC[100];

	if (ctx->sigfrag || ctx->gencues || ctx->do_index)
		return;

	GF_DashStream *ds = rep->playback.udta;
	if (ds->muxed_base) return;

	switch (ctx->from_index) {
	case IDXMODE_MANIFEST:
	case IDXMODE_CHILD:
		if (trash_init==DASH_INITSEG_NONE) return;
		trash_init = DASH_INITSEG_SKIP;
		break;
	case IDXMODE_ALL:
		if (trash_init==DASH_INITSEG_NONE) return;
		break;
	case IDXMODE_INIT:
		if (trash_init==DASH_INITSEG_NONE) return;
		p = gf_filter_pid_get_property_str(ds->ipid, "idx_out");
		if (p) dst_forced = p->value.string;
		break;
	}

	ctx->check_connections = GF_TRUE;
	if (dst_forced) {
		gf_dynstrcat(&szDST, dst_forced, NULL);
		szInitURL = dst_forced; //for logs
	}
	else if (ctx->out_path) {
		char *rel = NULL;
		if (ctx->do_m3u8 && ds->hls_vp_name) {
			char *tmp = gf_url_concatenate(ctx->out_path, ds->hls_vp_name);
			if (tmp) {
				rel = gf_url_concatenate(tmp, szInitURL);
				gf_free(tmp);
			}
		}
		if (!rel)
			rel = gf_url_concatenate(ctx->out_path, szInitURL);
		if (rel) {
			szDST = rel;
		}
	}
	else
		gf_dynstrcat(&szDST, szInitURL, NULL);


	if (ds->tci) {
		char *tmp = szDST;
		szDST = NULL;
		gf_dynstrcat(&szDST, "gcryp://", NULL);
		gf_dynstrcat(&szDST, tmp, NULL);
		gf_free(tmp);
	}

	sprintf(szSRC, "%cgfopt", sep_args);
	gf_dynstrcat(&szDST, szSRC, NULL);

	dst_args = gf_filter_get_dst_args(filter);
	if (dst_args) {
		char szKey[20], *sep;
		sprintf(szSRC, "%c", sep_args);
		gf_dynstrcat(&szDST, szSRC, NULL);
		
		gf_dynstrcat(&szDST, dst_args, NULL);
		sprintf(szKey, "%c%c", sep_args, sep_args);
		sep = strstr(szDST, szKey);
		if (sep) {
			sep[0] = 0;
			trailer_args = strstr(dst_args, szKey);
		}
		//look for frag arg
		sprintf(szKey, "%cfrag", sep_args);
		if (strstr(dst_args, szKey)) has_frag = GF_TRUE;
		else {
			sprintf(szKey, "%csfrag", sep_args);
			if (strstr(dst_args, szKey)) has_frag = GF_TRUE;
		}
		//look for subs_sidx arg
		sprintf(szKey, "%csubs_sidx", sep_args);
		if (strstr(dst_args, szKey)) has_subs = GF_TRUE;

		sprintf(szKey, "%cstrun", sep_args);
		if (strstr(dst_args, szKey)) has_strun = GF_TRUE;

		sprintf(szKey, "%cvodcache", sep_args);
		if (strstr(dst_args, szKey)) has_vodcache = GF_TRUE;

		sprintf(szKey, "%ccmaf", sep_args);
		if (strstr(dst_args, szKey)) has_cmaf = GF_TRUE;

		sprintf(szKey, "%cpsshs", sep_args);
		if (strstr(dst_args, szKey)) has_psshs = GF_TRUE;
	}
	if ((ctx->from_index==IDXMODE_SEG) && !gf_sys_is_test_mode())
		trash_init = DASH_INITSEG_SKIP;

	if (trash_init) {
		if (ds->rawmux)
			sprintf(szSRC, "%cnoinitraw", sep_args);
		else
			sprintf(szSRC, "%cnoinit", sep_args);
		gf_dynstrcat(&szDST, szSRC, NULL);
	}
	if (!has_frag) {
		sprintf(szSRC, "%cfrag", sep_args);
		gf_dynstrcat(&szDST, szSRC, NULL);
	}
	if (!ctx->forward_mode) {
		if (!has_subs && ctx->sseg) {
			sprintf(szSRC, "%csubs_sidx%c0", sep_args, sep_name);
			gf_dynstrcat(&szDST, szSRC, NULL);
		}
		if (ctx->cues && !has_strun) {
			sprintf(szSRC, "%cstrun", sep_args);
			gf_dynstrcat(&szDST, szSRC, NULL);
		}
		if (ctx->styp) {
			sprintf(szSRC, "%cstyp=%s", sep_args, ctx->styp);
			gf_dynstrcat(&szDST, szSRC, NULL);
		}
	}

	{
		//override xps inband declaration in args
		char *xps_inband;
		switch (ds->inband_params) {
		case 1: xps_inband = "all"; break;
		case 2: xps_inband = "pps"; break;
		case 3: xps_inband = "both"; break;
		default: xps_inband = "no"; break;
		}
		sprintf(szSRC, "%cxps_inband%c%s", sep_args, sep_name, xps_inband);
	}
	gf_dynstrcat(&szDST, szSRC, NULL);

	if (ctx->no_fragments_defaults) {
		sprintf(szSRC, "%cnofragdef", sep_args );
		gf_dynstrcat(&szDST, szSRC, NULL);
	}
	if (!has_psshs) {
		switch (ctx->pssh) {
		case GF_DASH_PSSH_MPD:
		case GF_DASH_PSSH_NONE:
			sprintf(szSRC, "%cpsshs%cnone", sep_args, sep_name);
			break;
		case GF_DASH_PSSH_MOOF:
		case GF_DASH_PSSH_MOOF_MPD:
			p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);
			//dual moov+moof only for dash
			if (!ctx->do_mpd) p = NULL;
			if (p && p->value.boolean) {
				sprintf(szSRC, "%cpsshs%cboth", sep_args, sep_name);
			} else {
				sprintf(szSRC, "%cpsshs%cmoof", sep_args, sep_name);
			}
			break;
		default:
			p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);
			//dual moov+moof only for dash
			if (!ctx->do_mpd) p = NULL;
			if (p && p->value.boolean) {
				sprintf(szSRC, "%cpsshs%cboth", sep_args, sep_name);
			} else {
				sprintf(szSRC, "%cpsshs%cmoov", sep_args, sep_name);
			}
			break;
		}
		gf_dynstrcat(&szDST, szSRC, NULL);
	}

	//patch for old arch: make sure we don't have any extra free box before the sidx
	//we could also use vodcache=insert but this might break http outputs
	if (gf_sys_old_arch_compat() && !has_vodcache && ctx->sseg) {
		sprintf(szSRC, "%cvodcache%con", sep_args, sep_name );
		if (!strstr(szDST, szSRC))
			gf_dynstrcat(&szDST, szSRC, NULL);
	}

	//we don't append mime in case of raw streams, raw format (writegen doesn't use mime types for raw media, only file ext)
	if (!ds->rawmux && ((ctx->muxtype!=DASHER_MUX_RAW) || (ds->codec_id != GF_CODECID_RAW)) ) {
		sprintf(szSRC, "%cmime%c%s", sep_args, sep_name, rep->mime_type);
		gf_dynstrcat(&szDST, szSRC, NULL);
	}

	if (ds->moof_sn>1) {
		sprintf(szSRC, "%cmsn%c%d", sep_args, sep_name, ds->moof_sn);
		gf_dynstrcat(&szDST, szSRC, NULL);
	}
	if (ds->moof_sn_inc>1) {
		sprintf(szSRC, "%cmsninc%c%d", sep_args, sep_name, ds->moof_sn_inc);
		gf_dynstrcat(&szDST, szSRC, NULL);
	}
	if (ds->sscale) {
		sprintf(szSRC, "%cmoovts%c-1", sep_args, sep_name);
		gf_dynstrcat(&szDST, szSRC, NULL);
	}

	if (!has_cmaf && ctx->cmaf) {
		sprintf(szSRC, "%ccmaf%c%s", sep_args, sep_name, (ctx->cmaf==DASHER_CMAF_CMF2) ? "cmf2" : "cmfc");
		gf_dynstrcat(&szDST, szSRC, NULL);
	}


	if (trailer_args)
		gf_dynstrcat(&szDST, trailer_args, NULL);
		
	ds->dst_filter = gf_filter_connect_destination(filter, szDST, &e);
	gf_free(szDST);
	szDST = NULL;
	if (e) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Couldn't create output file %s: %s\n", szInitURL, gf_error_to_string(e) ));
		ctx->in_error = GF_TRUE;
		return;
	}
	//reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter
	sprintf(szSRC, "MuxSrc%cdasher_%p", sep_name, ds->dst_filter);
	gf_filter_reset_source(ds->dst_filter);
	gf_filter_set_source(ds->dst_filter, filter, szSRC);

	if (ds->tci && !trash_init) {
		//push NULL key, we are not encrypting the init segment
		gf_cryptfout_push_key(ds->dst_filter, NULL, NULL);
	}
}
