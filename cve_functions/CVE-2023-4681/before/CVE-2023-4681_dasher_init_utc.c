static void dasher_init_utc(GF_Filter *filter, GF_DasherCtx *ctx)
{
	u8 *data=NULL;
	u64 remote_utc;
#ifdef GPAC_USE_DOWNLOADER
	GF_Err e;
	const char *cache_name;
	u32 size;
#endif
	GF_DownloadManager *dm;
	char *url;
	DasherUTCTimingType def_type = DASHER_UTCREF_NONE;

	ctx->utc_initialized = GF_TRUE;
	ctx->utc_timing_type = DASHER_UTCREF_NONE;
	if (!ctx->utcs) {
		return;
	}
	url = ctx->utcs;
	if (!strncmp(url, "xsd@", 4)) {
		def_type = DASHER_UTCREF_XSDATE;
		url += 4;
	}

	if (!strcmp(ctx->utcs, "inband")) {
		ctx->utc_timing_type = DASHER_UTCREF_INBAND;
		return;
	}
#ifndef GPAC_USE_DOWNLOADER
	GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] No download manager, cannot sync to remote UTC clock\n"));
	ctx->utc_timing_type = DASHER_UTCREF_NONE;
	return;
#else
	//create session
	if (!ctx->utc_sess) {
		dm  = gf_filter_get_download_manager(filter);
		if (!dm) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Failed to get download manager, cannot sync to remote UTC clock\n"));
			return;
		}
		ctx->utc_sess = gf_dm_sess_new(dm, url, GF_NETIO_SESSION_MEMORY_CACHE, NULL, NULL, &e);
		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Failed to create session for remote UTC source %s: %s - local clock will be used instead\n", url, gf_error_to_string(e) ));
			return;
		}
		e = gf_dm_sess_process(ctx->utc_sess);
		if (e==GF_IP_NETWORK_EMPTY) {
			ctx->utc_initialized = GF_FALSE;
			return;
		}
	}
	//check we are done
	GF_NetIOStatus status;
	e = gf_dm_sess_get_stats(ctx->utc_sess, NULL, NULL, NULL, NULL, NULL, &status);
	if (status==GF_NETIO_DATA_TRANSFERED) e = GF_OK;
	else if (status==GF_NETIO_DATA_EXCHANGE) e = GF_NOT_READY;
	else if (status==GF_NETIO_STATE_ERROR) {}
	else if ((status==GF_NETIO_DISCONNECTED) && (e>=GF_OK))
		e = GF_OK;
	else
		e = GF_NOT_READY;

	if (e==GF_NOT_READY) {
		ctx->utc_initialized = GF_FALSE;
		return;
	}
	if (e<0) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Failed to fetch remote UTC source %s: %s\n", url, gf_error_to_string(e) ));
		gf_dm_sess_del(ctx->utc_sess);
		ctx->utc_sess = NULL;
		return;
	}
	cache_name = gf_dm_sess_get_cache_name(ctx->utc_sess);
	gf_blob_get(cache_name, &data, &size, NULL);

	if (data) {
		//xsDate or isoDate - we always signal using iso
		if (strchr(data, 'T')) {
			remote_utc = gf_net_parse_date(data);
			if (remote_utc)
				ctx->utc_timing_type = def_type ? def_type : DASHER_UTCREF_ISO;
		}
		//ntp
		else if (sscanf(data, LLU, &remote_utc) == 1) {
			//ntp value not counted since 1900, assume format is seconds till 1 jan 1970
			if (remote_utc<=GF_NTP_SEC_1900_TO_1970) {
				remote_utc = remote_utc*1000;
			} else {
				remote_utc = gf_net_ntp_to_utc(remote_utc);
			}
			if (remote_utc)
				ctx->utc_timing_type = DASHER_UTCREF_NTP;
		}
	}
	gf_blob_release(cache_name);

	//not match, try http date
	if (!ctx->utc_timing_type) {
		const char *hdr = gf_dm_sess_get_header(ctx->utc_sess, "Date");
		if (hdr) {
			//http-head
			remote_utc = gf_net_parse_date(hdr);
			if (remote_utc)
				ctx->utc_timing_type = DASHER_UTCREF_HTTP_HEAD;
		}
	}

	if (!ctx->utc_timing_type) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Failed to parse response %s from remote UTC source %s\n", data, url ));
	} else {
		ctx->utc_diff = (s32) ( (s64) gf_net_get_utc() - (s64) remote_utc );
		if (ABS(ctx->utc_diff) > 3600000) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Diff between local clock and remote %s is %d, way too large! Assuming 0 ms UTC diff\n", url, ctx->utc_diff));
			ctx->utc_diff = 0;
		} else {
			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[Dasher] Synchronized clock to remote %s - UTC diff (local - remote) %d ms\n", url, ctx->utc_diff));
		}
	}
	gf_dm_sess_del(ctx->utc_sess);
#endif
}
