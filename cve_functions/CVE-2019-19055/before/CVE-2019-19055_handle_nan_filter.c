static int handle_nan_filter(struct nlattr *attr_filter,
			     struct cfg80211_nan_func *func,
			     bool tx)
{
	struct nlattr *attr;
	int n_entries, rem, i;
	struct cfg80211_nan_func_filter *filter;

	n_entries = validate_nan_filter(attr_filter);
	if (n_entries < 0)
		return n_entries;

	BUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));

	filter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);
	if (!filter)
		return -ENOMEM;

	i = 0;
	nla_for_each_nested(attr, attr_filter, rem) {
		filter[i].filter = nla_memdup(attr, GFP_KERNEL);
		filter[i].len = nla_len(attr);
		i++;
	}
	if (tx) {
		func->num_tx_filters = n_entries;
		func->tx_filters = filter;
	} else {
		func->num_rx_filters = n_entries;
		func->rx_filters = filter;
	}

	return 0;
}
