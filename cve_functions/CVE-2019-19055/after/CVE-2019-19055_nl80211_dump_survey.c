static int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct nlattr **attrbuf;
	struct survey_info survey;
	struct cfg80211_registered_device *rdev;
	struct wireless_dev *wdev;
	int survey_idx = cb->args[2];
	int res;
	bool radio_stats;

	attrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);
	if (!attrbuf)
		return -ENOMEM;

	rtnl_lock();
	res = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);
	if (res)
		goto out_err;

	/* prepare_wdev_dump parsed the attributes */
	radio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];

	if (!wdev->netdev) {
		res = -EINVAL;
		goto out_err;
	}

	if (!rdev->ops->dump_survey) {
		res = -EOPNOTSUPP;
		goto out_err;
	}

	while (1) {
		res = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);
		if (res == -ENOENT)
			break;
		if (res)
			goto out_err;

		/* don't send disabled channels, but do send non-channel data */
		if (survey.channel &&
		    survey.channel->flags & IEEE80211_CHAN_DISABLED) {
			survey_idx++;
			continue;
		}

		if (nl80211_send_survey(skb,
				NETLINK_CB(cb->skb).portid,
				cb->nlh->nlmsg_seq, NLM_F_MULTI,
				wdev->netdev, radio_stats, &survey) < 0)
			goto out;
		survey_idx++;
	}

 out:
	cb->args[2] = survey_idx;
	res = skb->len;
 out_err:
	kfree(attrbuf);
	rtnl_unlock();
	return res;
}
