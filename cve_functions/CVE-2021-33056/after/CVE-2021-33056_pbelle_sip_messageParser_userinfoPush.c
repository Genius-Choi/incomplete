pbelle_sip_messageParser_userinfoPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_userinfo_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_userinfoStack->size(ctx->pbelle_sip_messageParser_userinfoStack) > ctx->pbelle_sip_messageParser_userinfoStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_userinfo_SCOPE)ctx->pbelle_sip_messageParser_userinfoStack->get(ctx->pbelle_sip_messageParser_userinfoStack, ctx->pbelle_sip_messageParser_userinfoStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_userinfo_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_userinfo_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_userinfoStack->push(ctx->pbelle_sip_messageParser_userinfoStack, newAttributes, (void (*)(void *))userinfoFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_userinfoStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}
