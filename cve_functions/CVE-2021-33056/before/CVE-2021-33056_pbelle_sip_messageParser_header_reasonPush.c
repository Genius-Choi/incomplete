pbelle_sip_messageParser_header_reasonPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_reason_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_reasonStack->size(ctx->pbelle_sip_messageParser_header_reasonStack) > ctx->pbelle_sip_messageParser_header_reasonStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_reason_SCOPE)ctx->pbelle_sip_messageParser_header_reasonStack->get(ctx->pbelle_sip_messageParser_header_reasonStack, ctx->pbelle_sip_messageParser_header_reasonStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_reason_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_reason_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_reasonStack->push(ctx->pbelle_sip_messageParser_header_reasonStack, newAttributes, (void (*)(void *))header_reasonFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_reasonStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}
