host_lookup(const guint addr)
{
    hashipv4_t * volatile tp;

    tp = (hashipv4_t *)wmem_map_lookup(ipv4_hash_table, GUINT_TO_POINTER(addr));
    if (tp == NULL) {
        /*
         * We don't already have an entry for this host name; create one,
         * and then try to resolve it.
         */
        tp = new_ipv4(addr);
        fill_dummy_ip4(addr, tp);
        wmem_map_insert(ipv4_hash_table, GUINT_TO_POINTER(addr), tp);
    } else if (tp->flags & TRIED_OR_RESOLVED_MASK) {
        return tp;
    }

    /*
     * This hasn't been resolved yet, and we haven't tried to
     * resolve it already.
     */

    if (!gbl_resolv_flags.network_name)
        return tp;

    if (gbl_resolv_flags.use_external_net_name_resolver) {
        tp->flags |= TRIED_RESOLVE_ADDRESS;

        if (async_dns_initialized) {
            /* c-ares is initialized, so we can use it */
            if (resolve_synchronously || name_resolve_concurrency == 0) {
                /*
                 * Either all names are to be resolved synchronously or
                 * the concurrencly level is 0; do the resolution
                 * synchronously.
                 */
                sync_lookup_ip4(addr);
            } else {
                /*
                 * Names are to be resolved asynchronously, and we
                 * allow at least one asynchronous request in flight;
                 * post an asynchronous request.
                 */
                async_dns_queue_msg_t *caqm;

                caqm = wmem_new(addr_resolv_scope, async_dns_queue_msg_t);
                caqm->family = AF_INET;
                caqm->addr.ip4 = addr;
                wmem_list_append(async_dns_queue_head, (gpointer) caqm);
            }
        }
    }

    return tp;

} /* host_lookup */
