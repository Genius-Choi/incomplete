parse_ether_address_fast(const guchar *cp, ether_t *eth, unsigned int *mask,
        const gboolean accept_mask)
{
    /* XXX copied from strutil.c */
    /* a map from ASCII hex chars to their value */
    static const gint8 str_to_nibble[256] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
        -1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    };
    const guint8 *str_to_nibble_usg = (const guint8 *)str_to_nibble;

    guchar sep = cp[2];
    if ((sep != ':' && sep != '-') || cp[5] != sep) {
        /* Unexpected separators. */
        return FALSE;
    }

    /* N.B. store octet values in an int to detect invalid (-1) entries */
    int num0 = (str_to_nibble_usg[cp[0]] << 4) | (gint8)str_to_nibble_usg[cp[1]];
    int num1 = (str_to_nibble_usg[cp[3]] << 4) | (gint8)str_to_nibble_usg[cp[4]];
    int num2 = (str_to_nibble_usg[cp[6]] << 4) | (gint8)str_to_nibble_usg[cp[7]];

    if ((num0 | num1 | num2) & 0x100) {
        /* Not hexadecimal numbers. */
        return FALSE;
    }

    eth->addr[0] = (guint8)num0;
    eth->addr[1] = (guint8)num1;
    eth->addr[2] = (guint8)num2;

    if (cp[8] == '\0' && accept_mask) {
        /* Indicate that this is a manufacturer ID (0 is not allowed as a mask). */
        *mask = 0;
        return TRUE;
    } else if (cp[8] != sep || !accept_mask) {
        /* Format not handled by this fast path. */
        return FALSE;
    }

    /* N.B. store octet values in an int to detect invalid (-1) entries */
    int num3 = (str_to_nibble_usg[cp[9]]  << 4) | (gint8)str_to_nibble_usg[cp[10]];
    int num4 = (str_to_nibble_usg[cp[12]] << 4) | (gint8)str_to_nibble_usg[cp[13]];
    int num5 = (str_to_nibble_usg[cp[15]] << 4) | (gint8)str_to_nibble_usg[cp[16]];

    if (((num3 | num4 | num5) & 0x100) || cp[11] != sep || cp[14] != sep)  {
        /* Not hexadecimal numbers or invalid separators. */
        return FALSE;
    }

    eth->addr[3] = (guint8)num3;
    eth->addr[4] = (guint8)num4;
    eth->addr[5] = (guint8)num5;
    if (cp[17] == '\0') {
        /* We got 6 bytes, so this is a MAC address (48 is not allowed as a mask). */
        *mask = 48;
        return TRUE;
    } else if (cp[17] != '/' || cp[20] != '\0') {
        /* Format not handled by this fast path. */
        return FALSE;
    }

    int m1 = cp[18];
    int m2 = cp[19];
    if (m1 == '3' && m2 == '6') {   /* Mask /36 */
        eth->addr[4] &= 0xf0;
        eth->addr[5] = 0;
        *mask = 36;
        return TRUE;
    }
    if (m1 == '2' && m2 == '8') {   /* Mask /28 */
        eth->addr[3] &= 0xf0;
        eth->addr[4] = 0;
        eth->addr[5] = 0;
        *mask = 28;
        return TRUE;
    }
    /* Unsupported mask */
    return FALSE;
}
