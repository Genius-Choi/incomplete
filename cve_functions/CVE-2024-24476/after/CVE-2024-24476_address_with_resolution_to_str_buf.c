static void address_with_resolution_to_str_buf(const address* addr, gchar *buf, int buf_len)
{
    address_type_t *at;
    int addr_len;
    gsize pos;

    if (!buf || !buf_len)
        return;

    ADDR_TYPE_LOOKUP(addr->type, at);

    if (at == NULL)
    {
        buf[0] = '\0';
        return;
    }

#if 0 /* XXX - If this remains a static function, we've already made this check in the only
         function that can call it.  If this function becomes "public", need to put this
         check back in */
    /* No name resolution support, just return address string */
    if (at->addr_name_res_str == NULL)
        return address_to_str_buf(addr, buf, buf_len);
#endif

    /* Copy the resolved name */
    g_strlcpy(buf, at->addr_name_res_str(addr), buf_len);

    /* Get the length of the copied resolved name */
    pos = strlen(buf);

    /* Get an upper bound on the length of the address string. */
    addr_len = at->addr_str_len(addr);
    /*
     * That includes the terminating '\0', so we subtract 1
     * to get the length prior to the terminator.
     */
    addr_len--;

    /*
     * If the upper bound is 0, that means that the address string is
     * empty, so don't add it after the resolved name.
     */
    if (addr_len == 0)
        return;

    /*
     * If the resolved name is an empty string, don't wrap parentheses
     * around the address string.
     */
    if (pos == 0) {
        /*
         * The resolved name is an empty string.
         * Make sure there's room in the buffer for the address string;
         * addr_len + 1 includes the terminating '\0', and buf_len
         * includes room for the terminating '\0', so if the former
         * is greater than the latter, there isn't room.
         */
        if (addr_len + 1 > buf_len)
            return;

        /* There is; just put the address string into the buffer. */
        at->addr_to_str(addr, buf, buf_len);
    } else {
        /*
         * Make sure there is enough room for the maximum length of the
         * address string wrapped in parentheses.  That's pos (the
         * length of the resolved name plus 2 (for " (" plus addr_len
         * (the length of the address string) plus 2 (for ")\0");
         * it must not be greater than the buffer length.
         */
        if ((int)(pos + 4 + addr_len) > buf_len)
            return;

        buf[pos++] = ' ';
        buf[pos++] = '(';

        addr_len = at->addr_to_str(addr, &buf[pos], (int)(buf_len-pos));
        pos += addr_len - 1; /* addr_len includes the trailing '\0' */

        buf[pos++] = ')';
        buf[pos++] = '\0';
    }
}
