host_lookup6(const ws_in6_addr *addr)
{
    hashipv6_t * volatile tp;

    tp = (hashipv6_t *)wmem_map_lookup(ipv6_hash_table, addr);
    if (tp == NULL) {
        /*
         * We don't already have an entry for this host name; create one,
         * and then try to resolve it.
         */
        ws_in6_addr *addr_key;

        addr_key = wmem_new(addr_resolv_scope, ws_in6_addr);
        tp = new_ipv6(addr);
        memcpy(addr_key, addr, 16);
        fill_dummy_ip6(tp);
        wmem_map_insert(ipv6_hash_table, addr_key, tp);
    } else if (tp->flags & TRIED_OR_RESOLVED_MASK) {
        return tp;
    }

    /*
     * This hasn't been resolved yet, and we haven't tried to
     * resolve it already.
     */

    if (!gbl_resolv_flags.network_name)
        return tp;

    if (gbl_resolv_flags.use_external_net_name_resolver) {
        tp->flags |= TRIED_RESOLVE_ADDRESS;

        if (async_dns_initialized) {
            /* c-ares is initialized, so we can use it */
            if (resolve_synchronously || name_resolve_concurrency == 0) {
                /*
                 * Either all names are to be resolved synchronously or
                 * the concurrencly level is 0; do the resolution
                 * synchronously.
                 */
                sync_lookup_ip6(addr);
            } else {
                /*
                 * Names are to be resolved asynchronously, and we
                 * allow at least one asynchronous request in flight;
                 * post an asynchronous request.
                 */
                async_dns_queue_msg_t *caqm;

                caqm = wmem_new(addr_resolv_scope, async_dns_queue_msg_t);
                caqm->family = AF_INET6;
                memcpy(&caqm->addr.ip6, addr, sizeof(caqm->addr.ip6));
                wmem_list_append(async_dns_queue_head, (gpointer) caqm);
            }
        }
    }

    return tp;

} /* host_lookup6 */
