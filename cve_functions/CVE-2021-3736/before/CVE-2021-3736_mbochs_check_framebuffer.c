static int mbochs_check_framebuffer(struct mdev_state *mdev_state,
				    struct mbochs_mode *mode)
{
	struct device *dev = mdev_dev(mdev_state->mdev);
	u16 *vbe = mdev_state->vbe;
	u32 virt_width;

	WARN_ON(!mutex_is_locked(&mdev_state->ops_lock));

	if (!(vbe[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED))
		goto nofb;

	memset(mode, 0, sizeof(*mode));
	switch (vbe[VBE_DISPI_INDEX_BPP]) {
	case 32:
		mode->drm_format = DRM_FORMAT_XRGB8888;
		mode->bytepp = 4;
		break;
	default:
		dev_info_ratelimited(dev, "%s: bpp %d not supported\n",
				     __func__, vbe[VBE_DISPI_INDEX_BPP]);
		goto nofb;
	}

	mode->width  = vbe[VBE_DISPI_INDEX_XRES];
	mode->height = vbe[VBE_DISPI_INDEX_YRES];
	virt_width  = vbe[VBE_DISPI_INDEX_VIRT_WIDTH];
	if (virt_width < mode->width)
		virt_width = mode->width;
	mode->stride = virt_width * mode->bytepp;
	mode->size   = (u64)mode->stride * mode->height;
	mode->offset = ((u64)vbe[VBE_DISPI_INDEX_X_OFFSET] * mode->bytepp +
		       (u64)vbe[VBE_DISPI_INDEX_Y_OFFSET] * mode->stride);

	if (mode->width < 64 || mode->height < 64) {
		dev_info_ratelimited(dev, "%s: invalid resolution %dx%d\n",
				     __func__, mode->width, mode->height);
		goto nofb;
	}
	if (mode->offset + mode->size > mdev_state->memsize) {
		dev_info_ratelimited(dev, "%s: framebuffer memory overflow\n",
				     __func__);
		goto nofb;
	}

	return 0;

nofb:
	memset(mode, 0, sizeof(*mode));
	return -EINVAL;
}
