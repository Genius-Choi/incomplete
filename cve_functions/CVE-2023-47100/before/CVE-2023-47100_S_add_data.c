S_add_data(RExC_state_t* const pRExC_state, const char* const s, const U32 n)
{
    U32 count = RExC_rxi->data ? RExC_rxi->data->count : 1;

    PERL_ARGS_ASSERT_ADD_DATA;

    /* in the below expression we have (count + n - 1), the minus one is there
     * because the struct that we allocate already contains a slot for 1 data
     * item, so we do not need to allocate it the first time. IOW, the
     * sizeof(*RExC_rxi->data) already accounts for one of the elements we need
     * to allocate. See struct reg_data in regcomp.h
     */
    Renewc(RExC_rxi->data,
	   sizeof(*RExC_rxi->data) + (sizeof(void*) * (count + n - 1)),
	   char, struct reg_data);
    /* however in the data->what expression we use (count + n) and do not
     * subtract one from the result because the data structure contains a
     * pointer to an array, and does not allocate the first element as part of
     * the data struct. */
    if (count > 1)
        Renew(RExC_rxi->data->what, (count + n), U8);
    else {
        /* when count == 1 it means we have not initialized anything.
         * we always fill the 0 slot of the data array with a '%' entry, which
         * means "zero" (all the other types are letters) which exists purely
         * so the return from add_data is ALWAYS true, so we can tell it apart
         * from a "no value" idx=0 in places where we would return an index
         * into add_data.  This is particularly important with the new "single
         * pass, usually, but not always" strategy that we use, where the code
         * will use a 0 to represent "not able to compute this yet".
         */
        Newx(RExC_rxi->data->what, n+1, U8);
        /* fill in the placeholder slot of 0 with a what of '%', we use
         * this because it sorta looks like a zero (0/0) and it is not a letter
         * like any of the other "whats", this type should never be created
         * any other way but here. '%' happens to also not appear in this
         * file for any other reason (at the time of writing this comment)*/
        RExC_rxi->data->what[0]= '%';
        RExC_rxi->data->data[0]= NULL;
    }
    RExC_rxi->data->count = count + n;
    Copy(s, RExC_rxi->data->what + count, n, U8);
    assert(count>0);
    return count;
}
