void hardwareCounterWrapperHelper(pid_t (*func)(int), int afdt_fd) {
  if (!s_trackProcessTimes) {
    func(afdt_fd);
    return;
  }

  auto arg = std::make_unique<HardwareCounterWrapperArg>();
  arg->afdt_fd = afdt_fd;
  arg->func = func;
  if (pthread_create(&arg->thr, nullptr, hardwareCounterWrapper, arg.get())) {
    throw Exception("Failed to pthread_create: %s",
                    folly::errnoStr(errno).c_str());
  }
  // Wait for the pid to be set. Note that we must not add any code here that
  // could cause issues for the fork (eg malloc); we should wait on the barrier
  // immediately after the thread is created.
  arg->barrier.wait();
  if (arg->pid > 0) {
    // successfully forked, so don't join until waitpid.
    auto& map_entry = s_pidToHCWMap[arg->pid];
    map_entry = std::move(arg);
  } else {
    // fork failed, join now.
    pthread_join(arg->thr, nullptr);
  }
}
