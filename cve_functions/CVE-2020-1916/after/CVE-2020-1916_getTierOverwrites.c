static std::vector<std::string> getTierOverwrites(IniSetting::Map& ini,
                                                  Hdf& config) {

  // Machine metrics
  string hostname, tier, task, cpu, tiers, tags;
  {
    hostname = Config::GetString(ini, config, "Machine.name");
    if (hostname.empty()) {
      hostname = Process::GetHostName();
    }

    tier = Config::GetString(ini, config, "Machine.tier");

    task = Config::GetString(ini, config, "Machine.task");

    cpu = Config::GetString(ini, config, "Machine.cpu");
    if (cpu.empty()) {
      cpu = Process::GetCPUModel();
    }

    tiers = Config::GetString(ini, config, "Machine.tiers");
    if (!tiers.empty()) {
      if (!folly::readFile(tiers.c_str(), tiers)) {
        tiers.clear();
      }
    }

    tags = Config::GetString(ini, config, "Machine.tags");
    if (!tags.empty()) {
      if (!folly::readFile(tags.c_str(), tags)) {
        tags.clear();
      }
    }
  }

  auto const checkPatterns = [&] (Hdf hdf) {
    // Check the patterns using "&" rather than "&&" so they all get
    // evaluated; otherwise with multiple patterns, if an earlier
    // one fails to match, the later one is reported as unused.
    return
      Config::matchHdfPattern(hostname, ini, hdf, "machine") &
      Config::matchHdfPattern(tier, ini, hdf, "tier") &
      Config::matchHdfPattern(task, ini, hdf, "task") &
      Config::matchHdfPattern(tiers, ini, hdf, "tiers", "m") &
      Config::matchHdfPattern(tags, ini, hdf, "tags", "m") &
      Config::matchHdfPattern(cpu, ini, hdf, "cpu");
  };

  std::vector<std::string> messages;
  // Tier overwrites
  {
    for (Hdf hdf = config["Tiers"].firstChild(); hdf.exists();
         hdf = hdf.next()) {
      if (messages.empty()) {
        messages.emplace_back(folly::sformat(
                                "Matching tiers using: "
                                "machine='{}', tier='{}', task='{}', "
                                "cpu='{}', tiers='{}', tags='{}'",
                                hostname, tier, task, cpu, tiers, tags));
      }
      // Check the patterns using "&" rather than "&&" so they all get
      // evaluated; otherwise with multiple patterns, if an earlier
      // one fails to match, the later one is reported as unused.
      if (checkPatterns(hdf) &
          (!hdf.exists("exclude") || !checkPatterns(hdf["exclude"])) &
          matchShard(hostname, ini, hdf, messages)) {
        messages.emplace_back(folly::sformat(
                                "Matched tier: {}", hdf.getName()));
        if (hdf.exists("clear")) {
          std::vector<std::string> list;
          hdf["clear"].configGet(list);
          for (auto const& s : list) {
            config.remove(s);
          }
        }
        config.copy(hdf["overwrite"]);
        // no break here, so we can continue to match more overwrites
      }
      hdf["overwrite"].setVisited(); // avoid lint complaining
      if (hdf.exists("clear")) {
        // when the tier does not match, "clear" is not accessed
        // mark it visited, so the linter does not complain
        hdf["clear"].setVisited();
      }
    }
  }
  return messages;
}
