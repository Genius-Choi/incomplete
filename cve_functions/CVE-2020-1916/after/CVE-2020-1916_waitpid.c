pid_t LightProcess::waitpid(pid_t pid, int *stat_loc, int options,
                            int timeout) {
  if (!Available()) {
    // light process is not really there
    rusage ru;
    const auto ret = wait4(pid, stat_loc, options, &ru);
    if (ret > 0 && s_trackProcessTimes) {
      s_extra_request_nanoseconds += ru2microseconds(ru) * 1000;
    }
    return ret;
  }

  return runLight("waitpid", [&] (LightProcess* proc) -> pid_t {
      lwp_write(proc->m_afdt_fd, "waitpid", pid, options, timeout);

      pid_t ret;
      int stat;
      int err;
      int64_t time_us, events[3];
      lwp_read(proc->m_afdt_fd, ret, err, stat,
               time_us, events[0], events[1], events[2]);

      *stat_loc = stat;
      if (ret < 0) {
        errno = err;
      } else if (s_trackProcessTimes) {
        s_extra_request_nanoseconds += time_us * 1000;
        HardwareCounter::IncInstructionCount(events[0]);
        HardwareCounter::IncLoadCount(events[1]);
        HardwareCounter::IncStoreCount(events[2]);
      }

      return ret;
    }, static_cast<pid_t>(-1));
}
