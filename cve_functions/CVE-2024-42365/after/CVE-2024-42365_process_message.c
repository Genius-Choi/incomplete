static int process_message(struct mansession *s, const struct message *m)
{
	int ret = 0;
	struct manager_action *act_found;
	struct ast_manager_user *user = NULL;
	const char *username;
	const char *action;

	action = __astman_get_header(m, "Action", GET_HEADER_SKIP_EMPTY);
	if (ast_strlen_zero(action)) {
		report_req_bad_format(s, "NONE");
		mansession_lock(s);
		astman_send_error(s, m, "Missing action in request");
		mansession_unlock(s);
		return 0;
	}

	log_action(m, action);

	if (ast_shutting_down()) {
		ast_log(LOG_ERROR, "Unable to process manager action '%s'. Asterisk is shutting down.\n", action);
		mansession_lock(s);
		astman_send_error(s, m, "Asterisk is shutting down");
		mansession_unlock(s);
		return 0;
	}

	if (!s->session->authenticated
		&& strcasecmp(action, "Login")
		&& strcasecmp(action, "Logoff")
		&& strcasecmp(action, "Challenge")) {
		if (!s->session->authenticated) {
			report_req_not_allowed(s, action);
		}
		mansession_lock(s);
		astman_send_error(s, m, "Permission denied");
		mansession_unlock(s);
		return 0;
	}

	if (!s->session->authenticated
		&& (!strcasecmp(action, "Login")
			|| !strcasecmp(action, "Challenge"))) {
		username = astman_get_header(m, "Username");

		if (!ast_strlen_zero(username) && check_manager_session_inuse(username)) {
			AST_RWLIST_WRLOCK(&users);
			user = get_manager_by_name_locked(username);
			if (user && !user->allowmultiplelogin) {
				AST_RWLIST_UNLOCK(&users);
				report_session_limit(s);
				sleep(1);
				mansession_lock(s);
				astman_send_error(s, m, "Login Already In Use");
				mansession_unlock(s);
				return -1;
			}
			AST_RWLIST_UNLOCK(&users);
		}
	}

	act_found = action_find(action);
	if (act_found) {
		/* Found the requested AMI action. */
		int acted = 0;

		if ((s->session->writeperm & act_found->authority)
			|| act_found->authority == 0) {
			/* We have the authority to execute the action. */
			ret = -1;
			ao2_lock(act_found);
			if (act_found->registered && act_found->func) {
				struct ast_module *mod_ref = ast_module_running_ref(act_found->module);

				ao2_unlock(act_found);
				if (mod_ref || !act_found->module) {
					ast_debug(1, "Running action '%s'\n", act_found->action);
					ret = act_found->func(s, m);
					acted = 1;
					ast_module_unref(mod_ref);
				}
			} else {
				ao2_unlock(act_found);
			}
		}
		if (!acted) {
			/*
			 * We did not execute the action because access was denied, it
			 * was no longer registered, or no action was really registered.
			 * Complain about it and leave.
			 */
			report_req_not_allowed(s, action);
			mansession_lock(s);
			astman_send_error(s, m, "Permission denied");
			mansession_unlock(s);
		}
		ao2_t_ref(act_found, -1, "done with found action object");
	} else {
		char buf[512];

		report_req_bad_format(s, action);
		snprintf(buf, sizeof(buf), "Invalid/unknown command: %s. Use Action: ListCommands to show available commands.", action);
		mansession_lock(s);
		astman_send_error(s, m, buf);
		mansession_unlock(s);
	}
	if (ret) {
		return ret;
	}
	/* Once done with our message, deliver any pending events unless the
	   requester doesn't want them as part of this response.
	*/
	if (ast_strlen_zero(astman_get_header(m, "SuppressEvents"))) {
		return process_events(s);
	} else {
		return ret;
	}
}
