static int action_status(struct mansession *s, const struct message *m)
{
	const char *name = astman_get_header(m, "Channel");
	const char *chan_variables = astman_get_header(m, "Variables");
	const char *all_chan_variables = astman_get_header(m, "AllVariables");
	int all_variables = 0;
	const char *id = astman_get_header(m, "ActionID");
	char *variables = ast_strdupa(S_OR(chan_variables, ""));
	struct ast_channel *chan;
	int channels = 0;
	int all = ast_strlen_zero(name); /* set if we want all channels */
	char id_text[256];
	struct ast_channel_iterator *it_chans = NULL;
	AST_DECLARE_APP_ARGS(vars,
		AST_APP_ARG(name)[100];
	);

	if (!ast_strlen_zero(all_chan_variables)) {
		all_variables = ast_true(all_chan_variables);
	}

	if (!(function_capable_string_allowed_with_auths(variables, s->session->writeperm))) {
		astman_send_error(s, m, "Status Access Forbidden: Variables");
		return 0;
	}

	if (all) {
		if (!(it_chans = ast_channel_iterator_all_new())) {
			astman_send_error(s, m, "Memory Allocation Failure");
			return 1;
		}
		chan = ast_channel_iterator_next(it_chans);
	} else {
		chan = ast_channel_get_by_name(name);
		if (!chan) {
			astman_send_error(s, m, "No such channel");
			return 0;
		}
	}

	astman_send_listack(s, m, "Channel status will follow", "start");

	if (!ast_strlen_zero(id)) {
		snprintf(id_text, sizeof(id_text), "ActionID: %s\r\n", id);
	} else {
		id_text[0] = '\0';
	}

	if (!ast_strlen_zero(chan_variables)) {
		AST_STANDARD_APP_ARGS(vars, variables);
	}

	/* if we look by name, we break after the first iteration */
	for (; chan; all ? chan = ast_channel_iterator_next(it_chans) : 0) {
		ast_channel_lock(chan);

		generate_status(s, chan, vars.name, vars.argc, all_variables, id_text, &channels);

		ast_channel_unlock(chan);
		chan = ast_channel_unref(chan);
	}

	if (it_chans) {
		ast_channel_iterator_destroy(it_chans);
	}

	astman_send_list_complete_start(s, m, "StatusComplete", channels);
	astman_append(s, "Items: %d\r\n", channels);
	astman_send_list_complete_end(s);

	return 0;
}
