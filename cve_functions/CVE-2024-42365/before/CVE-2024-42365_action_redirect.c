static int action_redirect(struct mansession *s, const struct message *m)
{
	char buf[256];
	const char *name = astman_get_header(m, "Channel");
	const char *name2 = astman_get_header(m, "ExtraChannel");
	const char *exten = astman_get_header(m, "Exten");
	const char *exten2 = astman_get_header(m, "ExtraExten");
	const char *context = astman_get_header(m, "Context");
	const char *context2 = astman_get_header(m, "ExtraContext");
	const char *priority = astman_get_header(m, "Priority");
	const char *priority2 = astman_get_header(m, "ExtraPriority");
	struct ast_channel *chan;
	struct ast_channel *chan2;
	int pi = 0;
	int pi2 = 0;
	int res;
	int chan1_wait = 0;
	int chan2_wait = 0;

	if (ast_strlen_zero(name)) {
		astman_send_error(s, m, "Channel not specified");
		return 0;
	}

	if (ast_strlen_zero(context)) {
		astman_send_error(s, m, "Context not specified");
		return 0;
	}
	if (ast_strlen_zero(exten)) {
		astman_send_error(s, m, "Exten not specified");
		return 0;
	}
	if (ast_strlen_zero(priority)) {
		astman_send_error(s, m, "Priority not specified");
		return 0;
	}
	if (sscanf(priority, "%30d", &pi) != 1) {
		pi = ast_findlabel_extension(NULL, context, exten, priority, NULL);
	}
	if (pi < 1) {
		astman_send_error(s, m, "Priority is invalid");
		return 0;
	}

	if (!ast_strlen_zero(name2) && !ast_strlen_zero(context2)) {
		/* We have an ExtraChannel and an ExtraContext */
		if (ast_strlen_zero(exten2)) {
			astman_send_error(s, m, "ExtraExten not specified");
			return 0;
		}
		if (ast_strlen_zero(priority2)) {
			astman_send_error(s, m, "ExtraPriority not specified");
			return 0;
		}
		if (sscanf(priority2, "%30d", &pi2) != 1) {
			pi2 = ast_findlabel_extension(NULL, context2, exten2, priority2, NULL);
		}
		if (pi2 < 1) {
			astman_send_error(s, m, "ExtraPriority is invalid");
			return 0;
		}
	}

	chan = ast_channel_get_by_name(name);
	if (!chan) {
		snprintf(buf, sizeof(buf), "Channel does not exist: %s", name);
		astman_send_error(s, m, buf);
		return 0;
	}
	if (ast_check_hangup_locked(chan)) {
		astman_send_error(s, m, "Redirect failed, channel not up.");
		chan = ast_channel_unref(chan);
		return 0;
	}

	if (ast_strlen_zero(name2)) {
		/* Single channel redirect in progress. */
		res = ast_async_goto(chan, context, exten, pi);
		if (!res) {
			astman_send_ack(s, m, "Redirect successful");
		} else {
			astman_send_error(s, m, "Redirect failed");
		}
		chan = ast_channel_unref(chan);
		return 0;
	}

	chan2 = ast_channel_get_by_name(name2);
	if (!chan2) {
		snprintf(buf, sizeof(buf), "ExtraChannel does not exist: %s", name2);
		astman_send_error(s, m, buf);
		chan = ast_channel_unref(chan);
		return 0;
	}
	if (ast_check_hangup_locked(chan2)) {
		astman_send_error(s, m, "Redirect failed, extra channel not up.");
		chan2 = ast_channel_unref(chan2);
		chan = ast_channel_unref(chan);
		return 0;
	}

	/* Dual channel redirect in progress. */
	ast_channel_lock(chan);
	if (ast_channel_is_bridged(chan)) {
		ast_set_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
		chan1_wait = 1;
	}
	ast_channel_unlock(chan);

	ast_channel_lock(chan2);
	if (ast_channel_is_bridged(chan2)) {
		ast_set_flag(ast_channel_flags(chan2), AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
		chan2_wait = 1;
	}
	ast_channel_unlock(chan2);

	res = ast_async_goto(chan, context, exten, pi);
	if (!res) {
		if (!ast_strlen_zero(context2)) {
			res = ast_async_goto(chan2, context2, exten2, pi2);
		} else {
			res = ast_async_goto(chan2, context, exten, pi);
		}
		if (!res) {
			astman_send_ack(s, m, "Dual Redirect successful");
		} else {
			astman_send_error(s, m, "Secondary redirect failed");
		}
	} else {
		astman_send_error(s, m, "Redirect failed");
	}

	/* Release the bridge wait. */
	if (chan1_wait) {
		ast_channel_clear_flag(chan, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
	}
	if (chan2_wait) {
		ast_channel_clear_flag(chan2, AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT);
	}

	chan2 = ast_channel_unref(chan2);
	chan = ast_channel_unref(chan);
	return 0;
}
