ofproto_rule_create(struct ofproto *ofproto, struct cls_rule *cr,
                    uint8_t table_id, ovs_be64 new_cookie,
                    uint16_t idle_timeout, uint16_t hard_timeout,
                    enum ofputil_flow_mod_flags flags, uint16_t importance,
                    const struct ofpact *ofpacts, size_t ofpacts_len,
                    uint64_t match_tlv_bitmap, uint64_t ofpacts_tlv_bitmap,
                    struct rule **new_rule)
    OVS_NO_THREAD_SAFETY_ANALYSIS
{
    struct rule *rule;
    enum ofperr error;

    /* Allocate new rule. */
    rule = ofproto->ofproto_class->rule_alloc();
    if (!rule) {
        cls_rule_destroy(cr);
        VLOG_WARN_RL(&rl, "%s: failed to allocate a rule.", ofproto->name);
        return OFPERR_OFPFMFC_UNKNOWN;
    }

    /* Initialize base state. */
    *CONST_CAST(struct ofproto **, &rule->ofproto) = ofproto;
    cls_rule_move(CONST_CAST(struct cls_rule *, &rule->cr), cr);
    ovs_refcount_init(&rule->ref_count);

    ovs_mutex_init(&rule->mutex);
    ovs_mutex_lock(&rule->mutex);
    *CONST_CAST(ovs_be64 *, &rule->flow_cookie) = new_cookie;
    rule->created = rule->modified = time_msec();
    rule->idle_timeout = idle_timeout;
    rule->hard_timeout = hard_timeout;
    *CONST_CAST(uint16_t *, &rule->importance) = importance;
    rule->removed_reason = OVS_OFPRR_NONE;

    *CONST_CAST(uint8_t *, &rule->table_id) = table_id;
    rule->flags = flags & OFPUTIL_FF_STATE;

    *CONST_CAST(const struct rule_actions **, &rule->actions)
        = rule_actions_create(ofpacts, ofpacts_len);

    ovs_list_init(&rule->meter_list_node);
    rule->eviction_group = NULL;
    rule->monitor_flags = 0;
    rule->add_seqno = 0;
    rule->modify_seqno = 0;
    ovs_list_init(&rule->expirable);
    ovs_mutex_unlock(&rule->mutex);

    /* Construct rule, initializing derived state. */
    error = ofproto->ofproto_class->rule_construct(rule);
    if (error) {
        ofproto_rule_destroy__(rule);
        return error;
    }

    rule->state = RULE_INITIALIZED;
    rule->match_tlv_bitmap = match_tlv_bitmap;
    rule->ofpacts_tlv_bitmap = ofpacts_tlv_bitmap;
    mf_vl_mff_ref(&rule->ofproto->vl_mff_map, match_tlv_bitmap);
    mf_vl_mff_ref(&rule->ofproto->vl_mff_map, ofpacts_tlv_bitmap);

    *new_rule = rule;
    return 0;
}
