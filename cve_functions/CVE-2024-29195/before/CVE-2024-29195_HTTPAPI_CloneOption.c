HTTPAPI_RESULT HTTPAPI_CloneOption(const char* optionName, const void* value, const void** savedValue)
{
    HTTPAPI_RESULT result;
    if (
        (optionName == NULL) ||
        (value == NULL) ||
        (savedValue == NULL)
        )
    {
        result = HTTPAPI_INVALID_ARG;
        LogError("invalid argument(NULL) passed to HTTPAPI_CloneOption");
    }
    else
    {
        if (strcmp(OPTION_HTTP_TIMEOUT, optionName) == 0)
        {
            /*by convention value is pointing to an unsigned int */
            unsigned int* temp = (unsigned int*)malloc(sizeof(unsigned int)); /*shall be freed by HTTPAPIEX*/
            if (temp == NULL)
            {
                result = HTTPAPI_ERROR;
                LogError("malloc failed (result = %" PRI_MU_ENUM ")", MU_ENUM_VALUE(HTTPAPI_RESULT, result));
            }
            else
            {
                *temp = *(const unsigned int*)value;
                *savedValue = temp;
                result = HTTPAPI_OK;
            }
        }
        else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)
        {
            /*this is getting the x509 certificate. In this case, value is a pointer to a const char* that contains the certificate as a null terminated string*/
            if (mallocAndStrcpy_s((char**)savedValue, (const char*)value) != 0)
            {
                LogError("unable to clone the x509 certificate content");
                result = HTTPAPI_ERROR;
            }
            else
            {
                /*return OK when the certificate has been cloned successfully*/
                result = HTTPAPI_OK;
            }
        }
        else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)
        {
            /*this is getting the x509 private key. In this case, value is a pointer to a const char* that contains the private key as a null terminated string*/
            if (mallocAndStrcpy_s((char**)savedValue, (const char*)value) != 0)
            {
                LogError("unable to clone the x509 private key content");
                result = HTTPAPI_ERROR;
            }
            else
            {
                /*return OK when the private key has been cloned successfully*/
                result = HTTPAPI_OK;
            }
        }
        else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)
        {
            /*this is getting the trusted certificate */
            if (mallocAndStrcpy_s((char**)savedValue, (const char*)value) != 0)
            {
                LogError("unable to clone the trusted certificate content");
                result = HTTPAPI_ERROR;
            }
            else
            {
                /*return OK when the certificate has been cloned successfully*/
                result = HTTPAPI_OK;
            }
        }
        else if (strcmp(OPTION_HTTP_PROXY, optionName) == 0)
        {
            *savedValue = malloc(sizeof(HTTP_PROXY_OPTIONS));
            if (*savedValue == NULL)
            {
                LogError("failure in malloc");
                result = HTTPAPI_ERROR;
            }
            else
            {
                HTTP_PROXY_OPTIONS *savedOption = (HTTP_PROXY_OPTIONS*) *savedValue;
                HTTP_PROXY_OPTIONS *option = (HTTP_PROXY_OPTIONS*) value;
                memset((void*)*savedValue, 0, sizeof(HTTP_PROXY_OPTIONS));
                if (mallocAndStrcpy_s((char**)&(savedOption->host_address),
                                      (const char*)option->host_address) != 0)
                {
                  LogError("unable to clone the proxy host adress content");
                  free((void*)*savedValue);
                  *savedValue = NULL;
                  result = HTTPAPI_ERROR;
                }
                else
                {
                    savedOption->port = option->port;
                    if (option->username != NULL && mallocAndStrcpy_s((char**)&(savedOption->username),
                                                                      (const char*)option->username) != 0)
                    {
                      LogError("unable to clone the proxy username content");
                      free((void*)savedOption->host_address);
                      savedOption->host_address = NULL;
                      free((void*)*savedValue);
                      *savedValue = NULL;
                      result = HTTPAPI_ERROR;
                    }
                    else
                    {
                        if (option->password != NULL && mallocAndStrcpy_s((char**)&(savedOption->password),
                                                                          (const char*)option->password) != 0)
                        {
                          LogError("unable to clone the proxy password content");
                          free((void*)savedOption->host_address);
                          savedOption->host_address = NULL;
                          free((void*)savedOption->username);
                          savedOption->username = NULL;
                          free((void*)*savedValue);
                          *savedValue = NULL;
                          result = HTTPAPI_ERROR;
                        }
                        else
                        {
                            result = HTTPAPI_OK;
                        }
                    }
                }
            }
        }
        else
        {
            result = HTTPAPI_INVALID_ARG;
            LogError("unknown option %s", optionName);
        }
    }
    return result;
}
