static OPTIONHANDLER_HANDLE tlsio_openssl_retrieveoptions(CONCRETE_IO_HANDLE handle)
{
    OPTIONHANDLER_HANDLE result;
    if (handle == NULL)
    {
        LogError("invalid parameter detected: CONCRETE_IO_HANDLE handle=%p", handle);
        result = NULL;
    }
    else
    {
        result = OptionHandler_Create(tlsio_openssl_CloneOption, tlsio_openssl_DestroyOption, tlsio_openssl_setoption);
        if (result == NULL)
        {
            LogError("unable to OptionHandler_Create");
            /*return as is*/
        }
        else
        {
            /*this layer cares about the certificates and the x509 credentials*/
            TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)handle;
            OPTIONHANDLER_HANDLE underlying_io_options;

            if ((underlying_io_options = xio_retrieveoptions(tls_io_instance->underlying_io)) == NULL)
            {
                LogError("unable to retrieve underlying_io options");
                OptionHandler_Destroy(result);
                result = NULL;
            }
            else
            {
                if (OptionHandler_AddOption(result, OPTION_UNDERLYING_IO_OPTIONS, underlying_io_options) != OPTIONHANDLER_OK)
                {
                    LogError("unable to save underlying_io options");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (
                    (tls_io_instance->certificate != NULL) &&
                    (OptionHandler_AddOption(result, OPTION_TRUSTED_CERT, tls_io_instance->certificate) != OPTIONHANDLER_OK)
                    )
                {
                    LogError("unable to save TrustedCerts option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (
                    (tls_io_instance->cipher_list != NULL) &&
                    (OptionHandler_AddOption(result, OPTION_OPENSSL_CIPHER_SUITE, tls_io_instance->cipher_list) != OPTIONHANDLER_OK)
                    )
                {
                    LogError("unable to save CipherSuite option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (tls_io_instance->x509_certificate != NULL && (OptionHandler_AddOption(result, SU_OPTION_X509_CERT, tls_io_instance->x509_certificate) != OPTIONHANDLER_OK) )
                {
                    LogError("unable to save x509 certificate option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (tls_io_instance->x509_private_key != NULL && (OptionHandler_AddOption(result, SU_OPTION_X509_PRIVATE_KEY, tls_io_instance->x509_private_key) != OPTIONHANDLER_OK) )
                {
                    LogError("unable to save x509 privatekey option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (tls_io_instance->tls_version != 0 && (OptionHandler_AddOption(result, OPTION_TLS_VERSION, &tls_io_instance->tls_version) != OPTIONHANDLER_OK) )
                {
                    LogError("unable to save tls_version option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (
                    (tls_io_instance->engine_id != NULL) &&
                    (OptionHandler_AddOption(result, OPTION_OPENSSL_ENGINE, tls_io_instance->engine_id) != OPTIONHANDLER_OK)
                    )
                {
                    LogError("unable to save Engine option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (
                    (tls_io_instance->x509_private_key_type != KEY_TYPE_DEFAULT) &&
                    (OptionHandler_AddOption(result, OPTION_OPENSSL_PRIVATE_KEY_TYPE, &tls_io_instance->x509_private_key_type))
                    )
                {
                    LogError("unable to save x509PrivatekeyType option");
                    OptionHandler_Destroy(result);
                    result = NULL;
                }
                else if (tls_io_instance->tls_validation_callback != NULL)
                {
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4152)
#endif
                    void* ptr = tls_io_instance->tls_validation_callback;
#ifdef WIN32
#pragma warning(pop)
#endif
                    if (OptionHandler_AddOption(result, "tls_validation_callback", (const char*)ptr) != OPTIONHANDLER_OK)
                    {
                        LogError("unable to save tls_validation_callback option");
                        OptionHandler_Destroy(result);
                        result = NULL;
                    }

                    if (OptionHandler_AddOption(result, "tls_validation_callback_data", (const char*)tls_io_instance->tls_validation_callback_data) != OPTIONHANDLER_OK)
                    {
                        LogError("unable to save tls_validation_callback_data option");
                        OptionHandler_Destroy(result);
                        result = NULL;
                    }
                }
                else
                {
                    /*all is fine, all interesting options have been saved*/
                    /*return as is*/
                }

                // Must destroy since OptionHandler_AddOption creates a copy of it. 
                OptionHandler_Destroy(underlying_io_options); 
            }
        }
    }
    return result;
}
