int belle_sip_provider_add_authorization(belle_sip_provider_t *p, belle_sip_request_t* request, belle_sip_response_t *resp,
					 belle_sip_uri_t *from_uri, belle_sip_list_t** auth_infos, const char* realm) {
	belle_sip_header_call_id_t* call_id;
	belle_sip_list_t* auth_context_iterator;
	belle_sip_list_t* authenticate_lst;
	belle_sip_list_t* head;
	belle_sip_header_www_authenticate_t* authenticate;
	belle_sip_header_authorization_t* authorization;
	belle_sip_header_from_t* from;
	belle_sip_auth_event_t* auth_event;
	authorization_context_t* auth_context;
	const char* ha1;
	char computed_ha1[65];
	int result=0;
	const char* request_method;
	size_t size;
	const char* algo;
	/*check params*/
	if (!p || !request) {
		belle_sip_error("belle_sip_provider_add_authorization bad parameters");
		return 0;
	}
	request_method=belle_sip_request_get_method(request);

	/*22 Usage of HTTP Authentication
		22.1 Framework
		While a server can legitimately challenge most SIP requests, there
		are two requests defined by this document that require special
		handling for authentication: ACK and CANCEL.
		Under an authentication scheme that uses responses to carry values
		used to compute nonces (such as Digest), some problems come up for
		any requests that take no response, including ACK.  For this reason,
		any credentials in the INVITE that were accepted by a server MUST be
		accepted by that server for the ACK.  UACs creating an ACK message
		will duplicate all of the Authorization and Proxy-Authorization
		header field values that appeared in the INVITE to which the ACK
		corresponds.  Servers MUST NOT attempt to challenge an ACK.

		Although the CANCEL method does take a response (a 2xx), servers MUST
		NOT attempt to challenge CANCEL requests since these requests cannot
		be resubmitted.  Generally, a CANCEL request SHOULD be accepted by a
		server if it comes from the same hop that sent the request being
		canceled (provided that some sort of transport or network layer
		security association, as described in Section 26.2.1, is in place).
	*/

	if (strcmp("CANCEL",request_method)==0 || strcmp("ACK",request_method)==0) {
		belle_sip_debug("no authorization header needed for method [%s]",request_method);
		return 0;
	}

	if (from_uri==NULL){
		from = belle_sip_message_get_header_by_type(request,belle_sip_header_from_t);
		from_uri=belle_sip_header_address_get_uri((belle_sip_header_address_t*)from);
	}

	/*get authenticates value from response*/
	if (resp) {
		belle_sip_list_t *it;

		call_id = belle_sip_message_get_header_by_type(BELLE_SIP_MESSAGE(resp),belle_sip_header_call_id_t);
		/*searching for authentication headers*/
		authenticate_lst = belle_sip_list_copy(belle_sip_message_get_headers(BELLE_SIP_MESSAGE(resp),BELLE_SIP_WWW_AUTHENTICATE));
		/*search for proxy authenticate*/
		authenticate_lst=belle_sip_list_concat(authenticate_lst,belle_sip_list_copy(belle_sip_message_get_headers(BELLE_SIP_MESSAGE(resp),BELLE_SIP_PROXY_AUTHENTICATE)));
		/*update auth contexts with authenticate headers from response*/
		for (it=authenticate_lst;it!=NULL;it=it->next) {
			authenticate=BELLE_SIP_HEADER_WWW_AUTHENTICATE(it->data);
			belle_sip_provider_update_or_create_auth_context(p,call_id,authenticate,from_uri,realm);
		}
		belle_sip_list_free(authenticate_lst);
	}

	/*put authorization header if passwd found*/
	call_id = belle_sip_message_get_header_by_type(BELLE_SIP_MESSAGE(request),belle_sip_header_call_id_t);

	belle_sip_debug("belle_sip_provider_auth: looking an auth context for [method=%s][realm=%s][user_id=%s][call_id=%s]"
		, request_method
		, realm?realm:"(null)"
		, from_uri?belle_sip_uri_get_user(from_uri):"(null)"
		, call_id?belle_sip_header_call_id_get_call_id(call_id):"(null)"
	);
	head=belle_sip_provider_get_auth_context_by_realm_or_call_id(p,call_id,from_uri,realm);
	/*we assume there no existing auth headers*/
	for (auth_context_iterator=head;auth_context_iterator!=NULL;auth_context_iterator=auth_context_iterator->next) {
		/*clear auth info*/
		auth_context=(authorization_context_t*)auth_context_iterator->data;
		auth_event = belle_sip_auth_event_create((belle_sip_object_t*)p,auth_context->realm,from_uri);
		belle_sip_auth_event_set_algorithm(auth_event, auth_context->algorithm);
		/*put data*/
		/*call listener*/
		BELLE_SIP_PROVIDER_INVOKE_LISTENERS(p->listeners,process_auth_requested,auth_event);
		if (auth_event->passwd || auth_event->ha1) {
			if (!auth_event->userid) {
				/*if no userid, username = userid*/

				belle_sip_auth_event_set_userid(auth_event,auth_event->username);
			}
			belle_sip_message("Auth info found for [%s] realm [%s]",auth_event->userid,auth_event->realm);

			algo = auth_context->algorithm;
			size = belle_sip_auth_define_size(algo);
			if (!size) {
				belle_sip_error("Cannot add authorization header for unsupported algo [%s]", algo);
				continue;
			}

			if (belle_sip_header_call_id_equals(call_id,auth_context->callid)) {
				/*Same call id so we can make sure auth_context->is_proxy is accurate*/
				if (auth_context->is_proxy)
					authorization=BELLE_SIP_HEADER_AUTHORIZATION(belle_sip_header_proxy_authorization_new());
				else
					authorization=belle_sip_header_authorization_new();

			} else if (realm
					   &&strcmp(realm,auth_context->realm)==0
					   &&from_uri
					   &&strcmp(auth_event->username,belle_sip_uri_get_user(from_uri))==0
					   &&strcmp("REGISTER",request_method)==0){
				/*We can only guess, so for REGISTER, it's probably Authorization*/
				authorization=belle_sip_header_authorization_new();
			} else {
				/* for other case, it's probably Proxy-Authorization*/
				authorization=BELLE_SIP_HEADER_AUTHORIZATION(belle_sip_header_proxy_authorization_new());
			}

			belle_sip_header_authorization_set_scheme(authorization,auth_context->scheme);
			belle_sip_header_authorization_set_realm(authorization,auth_context->realm);
			belle_sip_header_authorization_set_username(authorization,auth_event->userid);
			belle_sip_header_authorization_set_nonce(authorization,auth_context->nonce);
			belle_sip_header_authorization_set_qop(authorization,auth_context->qop);
			belle_sip_header_authorization_set_opaque(authorization,auth_context->opaque);
			belle_sip_header_authorization_set_algorithm(authorization,auth_context->algorithm);

			belle_sip_header_authorization_set_uri(authorization,(belle_sip_uri_t*)belle_sip_request_get_uri(request));
			if (auth_context->qop){
				++auth_context->nonce_count;
				belle_sip_header_authorization_set_nonce_count(authorization,auth_context->nonce_count);
			}

			if (auth_event->ha1) {
				ha1=auth_event->ha1;
			} else {
				belle_sip_auth_helper_compute_ha1_for_algorithm(auth_event->userid,auth_context->realm,auth_event->passwd, computed_ha1, size, algo);
				ha1=computed_ha1;
			}
			if (belle_sip_auth_helper_fill_authorization(authorization
														,belle_sip_request_get_method(request)
														,ha1)) {
				belle_sip_object_unref(authorization);
			} else
				belle_sip_message_add_header(BELLE_SIP_MESSAGE(request),BELLE_SIP_HEADER(authorization));
			result=1;
		} else {
			belle_sip_message("No auth info found for call id [%s]",belle_sip_header_call_id_get_call_id(call_id));
		}
			/*provides auth info in any cases, usefull even if found because auth info can contain wrong password*/
		if (auth_infos) {
			/*stored to give user information on realm/username which requires authentications*/
			*auth_infos=belle_sip_list_append(*auth_infos,auth_event);
			belle_sip_list_t* elem=belle_sip_list_find_double_events(*auth_infos,auth_event);
			if(elem!=NULL) {
				belle_sip_auth_event_destroy(bctbx_list_get_data(elem));
				*auth_infos=belle_sip_list_delete_link(*auth_infos,elem);
			}
		} else {
			belle_sip_auth_event_destroy(auth_event);
		}
	}
	belle_sip_list_free(head);
	return result;
}
