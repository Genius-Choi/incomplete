static void process_denoiser_mode_change(VP8_COMP *cpi) {
  const VP8_COMMON *const cm = &cpi->common;
  int i, j;
  int total = 0;
  int num_blocks = 0;
  // Number of blocks skipped along row/column in computing the
  // nmse (normalized mean square error) of source.
  int skip = 2;
  // Only select blocks for computing nmse that have been encoded
  // as ZERO LAST min_consec_zero_last frames in a row.
  // Scale with number of temporal layers.
  int min_consec_zero_last = 12 / cpi->oxcf.number_of_layers;
  // Decision is tested for changing the denoising mode every
  // num_mode_change times this function is called. Note that this
  // function called every 8 frames, so (8 * num_mode_change) is number
  // of frames where denoising mode change is tested for switch.
  int num_mode_change = 20;
  // Framerate factor, to compensate for larger mse at lower framerates.
  // Use ref_framerate, which is full source framerate for temporal layers.
  // TODO(marpan): Adjust this factor.
  int fac_framerate = cpi->ref_framerate < 25.0f ? 80 : 100;
  int tot_num_blocks = cm->mb_rows * cm->mb_cols;
  int ystride = cpi->Source->y_stride;
  unsigned char *src = cpi->Source->y_buffer;
  unsigned char *dst = cpi->denoiser.yv12_last_source.y_buffer;
  static const unsigned char const_source[16] = { 128, 128, 128, 128, 128, 128,
                                                  128, 128, 128, 128, 128, 128,
                                                  128, 128, 128, 128 };
  int bandwidth = (int)(cpi->target_bandwidth);
  // For temporal layers, use full bandwidth (top layer).
  if (cpi->oxcf.number_of_layers > 1) {
    LAYER_CONTEXT *lc = &cpi->layer_context[cpi->oxcf.number_of_layers - 1];
    bandwidth = (int)(lc->target_bandwidth);
  }
  // Loop through the Y plane, every skip blocks along rows and columns,
  // summing the normalized mean square error, only for blocks that have
  // been encoded as ZEROMV LAST at least min_consec_zero_last least frames in
  // a row and have small sum difference between current and previous frame.
  // Normalization here is by the contrast of the current frame block.
  for (i = 0; i < cm->Height; i += 16 * skip) {
    int block_index_row = (i >> 4) * cm->mb_cols;
    for (j = 0; j < cm->Width; j += 16 * skip) {
      int index = block_index_row + (j >> 4);
      if (cpi->consec_zero_last[index] >= min_consec_zero_last) {
        unsigned int sse;
        const unsigned int var =
            vpx_variance16x16(src + j, ystride, dst + j, ystride, &sse);
        // Only consider this block as valid for noise measurement
        // if the sum_diff average of the current and previous frame
        // is small (to avoid effects from lighting change).
        if ((sse - var) < 128) {
          unsigned int sse2;
          const unsigned int act =
              vpx_variance16x16(src + j, ystride, const_source, 0, &sse2);
          if (act > 0) total += sse / act;
          num_blocks++;
        }
      }
    }
    src += 16 * skip * ystride;
    dst += 16 * skip * ystride;
  }
  total = total * fac_framerate / 100;

  // Only consider this frame as valid sample if we have computed nmse over
  // at least ~1/16 blocks, and Total > 0 (Total == 0 can happen if the
  // application inputs duplicate frames, or contrast is all zero).
  if (total > 0 && (num_blocks > (tot_num_blocks >> 4))) {
    // Update the recursive mean square source_diff.
    total = (total << 8) / num_blocks;
    if (cpi->denoiser.nmse_source_diff_count == 0) {
      // First sample in new interval.
      cpi->denoiser.nmse_source_diff = total;
      cpi->denoiser.qp_avg = cm->base_qindex;
    } else {
      // For subsequent samples, use average with weight ~1/4 for new sample.
      cpi->denoiser.nmse_source_diff =
          (int)((total + 3 * cpi->denoiser.nmse_source_diff) >> 2);
      cpi->denoiser.qp_avg =
          (int)((cm->base_qindex + 3 * cpi->denoiser.qp_avg) >> 2);
    }
    cpi->denoiser.nmse_source_diff_count++;
  }
  // Check for changing the denoiser mode, when we have obtained #samples =
  // num_mode_change. Condition the change also on the bitrate and QP.
  if (cpi->denoiser.nmse_source_diff_count == num_mode_change) {
    // Check for going up: from normal to aggressive mode.
    if ((cpi->denoiser.denoiser_mode == kDenoiserOnYUV) &&
        (cpi->denoiser.nmse_source_diff >
         cpi->denoiser.threshold_aggressive_mode) &&
        (cpi->denoiser.qp_avg < cpi->denoiser.qp_threshold_up &&
         bandwidth > cpi->denoiser.bitrate_threshold)) {
      vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUVAggressive);
    } else {
      // Check for going down: from aggressive to normal mode.
      if (((cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive) &&
           (cpi->denoiser.nmse_source_diff <
            cpi->denoiser.threshold_aggressive_mode)) ||
          ((cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive) &&
           (cpi->denoiser.qp_avg > cpi->denoiser.qp_threshold_down ||
            bandwidth < cpi->denoiser.bitrate_threshold))) {
        vp8_denoiser_set_parameters(&cpi->denoiser, kDenoiserOnYUV);
      }
    }
    // Reset metric and counter for next interval.
    cpi->denoiser.nmse_source_diff = 0;
    cpi->denoiser.qp_avg = 0;
    cpi->denoiser.nmse_source_diff_count = 0;
  }
}
