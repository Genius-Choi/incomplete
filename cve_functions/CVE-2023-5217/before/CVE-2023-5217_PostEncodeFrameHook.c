  void PostEncodeFrameHook(::libvpx_test::Encoder *encoder) override {
    ::libvpx_test::CxDataIterator iter = encoder->GetCxData();
    while (const vpx_codec_cx_pkt_t *pkt = iter.Next()) {
      switch (pkt->kind) {
        case VPX_CODEC_CX_FRAME_PKT: {
          VpxTplGopStats tpl_stats;
          EXPECT_EQ(AllocateTplList(&tpl_stats), VPX_CODEC_OK);
          encoder->Control(VP9E_GET_TPL_STATS, &tpl_stats);
          bool stats_not_all_zero = false;
          for (int i = 0; i < tpl_stats.size; i++) {
            VpxTplFrameStats *frame_stats_list = tpl_stats.frame_stats_list;
            if (frame_stats_list[i].frame_width != 0) {
              ASSERT_EQ(frame_stats_list[i].frame_width, width_);
              ASSERT_EQ(frame_stats_list[i].frame_height, height_);
              ASSERT_GT(frame_stats_list[i].num_blocks, 0);
              ASSERT_NE(frame_stats_list[i].block_stats_list, nullptr);
              stats_not_all_zero = true;
            }
          }
          ASSERT_TRUE(stats_not_all_zero);
          if (test_io_ && tpl_stats.size > 0) {
            libvpx_test::TempOutFile *temp_out_file =
                new (std::nothrow) libvpx_test::TempOutFile("w+");
            ASSERT_NE(temp_out_file, nullptr);
            ASSERT_NE(temp_out_file->file(), nullptr);
            vpx_write_tpl_gop_stats(temp_out_file->file(), &tpl_stats);
            rewind(temp_out_file->file());
            VpxTplGopStats gop_stats_io;
            ASSERT_EQ(
                vpx_read_tpl_gop_stats(temp_out_file->file(), &gop_stats_io),
                VPX_CODEC_OK);
            CompareTplGopStats(gop_stats_io, tpl_stats);
            vpx_free_tpl_gop_stats(&gop_stats_io);
            delete temp_out_file;
          }
          free(tpl_stats.frame_stats_list);
          break;
        }
        default: break;
      }
    }
  }
