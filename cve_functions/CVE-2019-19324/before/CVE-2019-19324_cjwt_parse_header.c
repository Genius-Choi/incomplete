static int cjwt_parse_header( cjwt_t *p_cjwt, char *p_head )
{
    int sz_head, ret = 0;
    size_t head_desize;
    uint8_t *decoded_head;
    size_t out_size = 0;

    if( !p_cjwt || !p_head ) {
        return EINVAL;
    }

    sz_head = strlen( ( char * )p_head );
    head_desize = b64url_get_decoded_buffer_size( sz_head );
    cjwt_info( "----------------- header -------------------- \n" );
    cjwt_info( "Header Size = %d , Decoded size = %d\n", sz_head, ( int )head_desize );
    decoded_head = malloc( head_desize + 1 );

    if( !decoded_head ) {
        return ENOMEM;
    }

    memset( decoded_head, 0, head_desize + 1 );
    //decode header
    out_size = b64url_decode( ( uint8_t * )p_head, sz_head, decoded_head );
    cjwt_info( "Bytes = %d\n", ( int )out_size );

    if( !out_size ) {
        ret = EINVAL;
        goto end;
    }

    decoded_head[out_size] = '\0';
    cjwt_info( "Raw data  = %*s\n", ( int )out_size, decoded_head );
    ret = cjwt_update_header( p_cjwt, ( char* )decoded_head );
end:
    free( decoded_head );
    return ret;
}
