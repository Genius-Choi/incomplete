pdfioStreamWrite(
    pdfio_stream_t *st,			// I - Stream
    const void     *buffer,		// I - Data to write
    size_t         bytes)		// I - Number of bytes to write
{
  size_t		pbpixel,	// Size of pixel in bytes
      			pbline,		// Bytes per line
			remaining;	// Remaining bytes on this line
  const unsigned char	*bufptr,	// Pointer into buffer
			*bufsecond;	// Pointer to second pixel in buffer
  unsigned char		*sptr,		// Pointer into sbuffer
			*pptr;		// Previous raw buffer


  PDFIO_DEBUG("pdfioStreamWrite(st=%p, buffer=%p, bytes=%lu)\n", st, buffer, (unsigned long)bytes);

  // Range check input...
  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !buffer || !bytes)
    return (false);

  // Write it...
  if (st->filter == PDFIO_FILTER_NONE)
  {
    // No filtering...
    if (st->crypto_cb)
    {
      // Encrypt data before writing...
      uint8_t	temp[8192];		// Temporary buffer
      size_t	cbytes,			// Current bytes
		outbytes;		// Output bytes

      bufptr = (const unsigned char *)buffer;

      while (bytes > 0)
      {
        if (st->bufptr > st->buffer || bytes < 16)
        {
          // Write through the stream's buffer...
          if ((cbytes = bytes) > (size_t)(st->bufend - st->bufptr))
            cbytes = (size_t)(st->bufend - st->bufptr);

          memcpy(st->bufptr, bufptr, cbytes);
          st->bufptr += cbytes;
          if (st->bufptr >= st->bufend)
          {
            // Encrypt and flush
	    outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, sizeof(st->buffer));
	    if (!_pdfioFileWrite(st->pdf, temp, outbytes))
	      return (false);

	    st->bufptr = st->buffer;
          }
        }
        else
        {
          // Write directly up to sizeof(temp) bytes...
          if ((cbytes = bytes) > sizeof(temp))
            cbytes = sizeof(temp);
          if (cbytes & 15)
          {
            // AES has a 16-byte block size, so save the last few bytes...
            cbytes &= (size_t)~15;
          }

	  outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, bufptr, cbytes);
	  if (!_pdfioFileWrite(st->pdf, temp, outbytes))
	    return (false);
        }

        bytes -= cbytes;
        bufptr += cbytes;
      }

      return (true);
    }
    else
    {
      // Write unencrypted...
      return (_pdfioFileWrite(st->pdf, buffer, bytes));
    }
  }

  pbline = st->pbsize - 1;

  if (st->predictor == _PDFIO_PREDICTOR_NONE)
  {
    // No predictor, just write it out straight...
    return (stream_write(st, buffer, bytes));
  }
  else if ((bytes % pbline) != 0)
  {
    _pdfioFileError(st->pdf, "Write buffer size must be a multiple of a complete row.");
    return (false);
  }

  pbpixel   = st->pbpixel;
  bufptr    = (const unsigned char *)buffer;
  bufsecond = bufptr + pbpixel;

  while (bytes > 0)
  {
    // Store the PNG predictor in the first byte of the buffer...
    if (st->predictor == _PDFIO_PREDICTOR_PNG_AUTO)
      st->psbuffer[0] = 4;		// Use Paeth predictor for auto...
    else
      st->psbuffer[0] = (unsigned char)(st->predictor - 10);

    // Then process the current line using the specified PNG predictor...
    sptr = st->psbuffer + 1;
    pptr = st->prbuffer;

    switch (st->predictor)
    {
      default :
          // Anti-compiler-warning code (NONE is handled above, TIFF is not supported for writing)
	  return (false);

      case _PDFIO_PREDICTOR_PNG_NONE :
          // No PNG predictor...
          memcpy(sptr, buffer, pbline);
          break;

      case _PDFIO_PREDICTOR_PNG_SUB :
	  // Encode the difference from the previous column
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++)
	  {
	    if (bufptr >= bufsecond)
	      *sptr = *bufptr - bufptr[-(int)pbpixel];
	    else
	      *sptr = *bufptr;
	  }
	  break;

      case _PDFIO_PREDICTOR_PNG_UP :
	  // Encode the difference from the previous line
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)
	  {
	    *sptr = *bufptr - *pptr;
	  }
	  break;

      case _PDFIO_PREDICTOR_PNG_AVERAGE :
          // Encode the difference with the average of the previous column and line
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)
	  {
	    if (bufptr >= bufsecond)
	      *sptr = *bufptr - (bufptr[-(int)pbpixel] + *pptr) / 2;
	    else
	      *sptr = *bufptr - *pptr / 2;
	  }
	  break;

      case _PDFIO_PREDICTOR_PNG_PAETH :
      case _PDFIO_PREDICTOR_PNG_AUTO :
          // Encode the difference with a linear transform function
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)
	  {
	    if (bufptr >= bufsecond)
	      *sptr = *bufptr - stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);
	    else
	      *sptr = *bufptr - stream_paeth(0, *pptr, 0);
	  }
	  break;
    }

    // Write the encoded line...
    if (!stream_write(st, st->psbuffer, st->pbsize))
      return (false);

    memcpy(st->prbuffer, buffer, pbline);
    bytes -= pbline;
  }

  return (true);
}
