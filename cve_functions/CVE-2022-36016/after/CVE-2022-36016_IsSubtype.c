bool IsSubtype(const FullTypeDef& lhs, const FullTypeDef& rhs, bool covariant) {
  // Rule: ANY is a supertype of all types.
  if (rhs.type_id() == TFT_ANY) {
    return true;
  }
  // Compatibility rule: UNSET is treated as ANY for the purpose of subtyping.
  if (rhs.type_id() == TFT_UNSET) {
    return true;
  }
  // Compatibility rule: TENSOR[LEGACY_VARIANT] is treated as ANY for the
  // purpose of subtyping.
  if ((rhs.type_id() == TFT_TENSOR) &&
      (GetArgDefaultUnset(rhs, 0).type_id() == TFT_LEGACY_VARIANT)) {
    return true;
  }
  // Rule: encodings are subtypes of the encoding type.
  if (lhs.type_id() == TFT_ENCODED) {
    return IsSubtype(GetArgDefaultAny(lhs, 1), rhs, true);
  }

  // Default rule: type IDs must match.
  if (lhs.type_id() != rhs.type_id()) {
    return false;
  }

  // Arguments must be subtypes of one another.
  for (int i = 0; i < std::max(lhs.args_size(), rhs.args_size()); i++) {
    const FullTypeDef& lhs_arg = GetArgDefaultAny(lhs, i);
    const FullTypeDef& rhs_arg = GetArgDefaultAny(rhs, i);

    if (covariant) {
      if (!IsSubtype(lhs_arg, rhs_arg)) {
        return false;
      }
    } else {
      if (!IsSubtype(rhs_arg, lhs_arg)) {
        return false;
      }
    }
  }

  // Invariant: type IDs are equal, and all args are subtype of one another.
  return true;
}
