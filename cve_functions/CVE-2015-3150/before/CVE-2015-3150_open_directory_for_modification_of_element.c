static struct dump_dir *open_directory_for_modification_of_element(
    GDBusMethodInvocation *invocation,
    uid_t caller_uid,
    const char *problem_id,
    const char *element)
{
    static const char *const protected_elements[] = {
        FILENAME_TIME,
        FILENAME_UID,
        NULL,
    };

    for (const char *const *protected = protected_elements; *protected; ++protected)
    {
        if (strcmp(*protected, element) == 0)
        {
            log_notice("'%s' element of '%s' can't be modified", element, problem_id);
            char *error = xasprintf(_("'%s' element can't be modified"), element);
            g_dbus_method_invocation_return_dbus_error(invocation,
                                        "org.freedesktop.problems.ProtectedElement",
                                        error);
            free(error);
            return NULL;
        }
    }

    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))
    {
        if (errno == ENOTDIR)
        {
            log_notice("'%s' is not a valid problem directory", problem_id);
            return_InvalidProblemDir_error(invocation, problem_id);
        }
        else
        {
            log_notice("UID(%d) is not Authorized to access '%s'", caller_uid, problem_id);
            g_dbus_method_invocation_return_dbus_error(invocation,
                                "org.freedesktop.problems.AuthFailure",
                                _("Not Authorized"));
        }

        return NULL;
    }

    struct dump_dir *dd = dd_opendir(problem_id, /* flags : */ 0);
    if (!dd)
    {   /* This should not happen because of the access check above */
        log_notice("Can't access the problem '%s' for modification", problem_id);
        g_dbus_method_invocation_return_dbus_error(invocation,
                                "org.freedesktop.problems.Failure",
                                _("Can't access the problem for modification"));
        return NULL;
    }

    return dd;
}
