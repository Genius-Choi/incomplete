static int http_response_process_headers(server *srv, connection *con, http_response_opts *opts, buffer *hdrs) {
    char *ns;
    const char *s;
    int line = 0;

    for (s = hdrs->ptr; NULL != (ns = strchr(s, '\n')); s = ns + 1, ++line) {
        const char *key, *value;
        int key_len;
        data_string *ds;

        /* strip the \n */
        ns[0] = '\0';
        if (ns > s && ns[-1] == '\r') ns[-1] = '\0';

        if (0 == line && 0 == strncmp(s, "HTTP/1.", 7)) {
            /* non-parsed headers ... we parse them anyway */
            if ((s[7] == '1' || s[7] == '0') && s[8] == ' ') {
                /* after the space should be a status code for us */
                int status = strtol(s+9, NULL, 10);
                if (status >= 100 && status < 1000) {
                    con->parsed_response |= HTTP_STATUS;
                    con->http_status = status;
                } /* else we expected 3 digits and didn't get them */
            }

            if (0 == con->http_status) {
                log_error_write(srv, __FILE__, __LINE__, "ss",
                                "invalid HTTP status line:", s);
                con->http_status = 502; /* Bad Gateway */
                con->mode = DIRECT;
                return -1;
            }

            continue;
        }

        /* parse the headers */
        key = s;
        if (NULL == (value = strchr(s, ':'))) {
            /* we expect: "<key>: <value>\r\n" */
            continue;
        }

        key_len = value - key;
        do { ++value; } while (*value == ' ' || *value == '\t'); /* skip LWS */

        if (opts->authorizer) {
            if (0 == con->http_status || 200 == con->http_status) {
                if (key_len == 6 && 0 == strncasecmp(key, "Status", key_len)) {
                    int status = strtol(value, NULL, 10);
                    if (status >= 100 && status < 1000) {
                        con->http_status = status;
                    } else {
                        con->http_status = 502; /* Bad Gateway */
                        break;
                    }
                } else if (key_len > 9
                           && 0==strncasecmp(key, CONST_STR_LEN("Variable-"))) {
                    ds = (data_string *)
                      array_get_unused_element(con->environment, TYPE_STRING);
                    if (NULL == ds) ds = data_string_init();
                    buffer_copy_string_len(ds->key, key + 9, key_len - 9);
                    buffer_copy_string(ds->value, value);

                    array_insert_unique(con->environment, (data_unset *)ds);
                }
                continue;
            }
        }

        switch(key_len) {
        case 4:
            if (0 == strncasecmp(key, "Date", key_len)) {
                con->parsed_response |= HTTP_DATE;
            }
            break;
        case 6:
            if (0 == strncasecmp(key, "Status", key_len)) {
                int status;
                if (opts->backend == BACKEND_PROXY) break; /*(pass w/o parse)*/
                status = strtol(value, NULL, 10);
                if (status >= 100 && status < 1000) {
                    con->http_status = status;
                    con->parsed_response |= HTTP_STATUS;
                } else {
                    con->http_status = 502;
                    con->mode = DIRECT;
                }
                continue; /* do not send Status to client */
            }
            break;
        case 7:
            if (0 == strncasecmp(key, "Upgrade", key_len)) {
                /*(technically, should also verify Connection: upgrade)*/
                /*(flag only for mod_proxy and mod_cgi (for now))*/
                if (opts->backend == BACKEND_PROXY
                    || opts->backend == BACKEND_CGI) {
                    con->parsed_response |= HTTP_UPGRADE;
                }
            }
            break;
        case 8:
            if (0 == strncasecmp(key, "Location", key_len)) {
                con->parsed_response |= HTTP_LOCATION;
            }
            break;
        case 10:
            if (0 == strncasecmp(key, "Connection", key_len)) {
                if (opts->backend == BACKEND_PROXY) continue;
                con->response.keep_alive =
                  (0 == strcasecmp(value, "Keep-Alive")) ? 1 : 0;
                con->parsed_response |= HTTP_CONNECTION;
            }
            else if (0 == strncasecmp(key, "Set-Cookie", key_len)) {
                con->parsed_response |= HTTP_SET_COOKIE;
            }
            break;
        case 14:
            if (0 == strncasecmp(key, "Content-Length", key_len)) {
                con->response.content_length = strtoul(value, NULL, 10);
                con->parsed_response |= HTTP_CONTENT_LENGTH;
            }
            break;
        case 16:
            if (0 == strncasecmp(key, "Content-Location", key_len)) {
                con->parsed_response |= HTTP_CONTENT_LOCATION;
            }
            break;
        case 17:
            if (0 == strncasecmp(key, "Transfer-Encoding", key_len)) {
                if (opts->backend == BACKEND_PROXY) continue;
                con->parsed_response |= HTTP_TRANSFER_ENCODING;
            }
            break;
        default:
            break;
        }

        ds = (data_string *)
          array_get_unused_element(con->response.headers, TYPE_STRING);
        if (NULL == ds) ds = data_response_init();
        buffer_copy_string_len(ds->key, key, key_len);
        buffer_copy_string(ds->value, value);

        array_insert_unique(con->response.headers, (data_unset *)ds);
    }

    /* CGI/1.1 rev 03 - 7.2.1.2 */
    /* (proxy requires Status-Line, so never true for proxy)*/
    if ((con->parsed_response & HTTP_LOCATION) &&
        !(con->parsed_response & HTTP_STATUS)) {
        con->http_status = 302;
    }

    return 0;
}
