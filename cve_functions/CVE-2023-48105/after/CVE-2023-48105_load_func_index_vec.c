load_func_index_vec(const uint8 **p_buf, const uint8 *buf_end,
                    WASMModule *module, WASMTableSeg *table_segment,
                    bool use_init_expr, char *error_buf, uint32 error_buf_size)
{
    const uint8 *p = *p_buf, *p_end = buf_end;
    uint32 function_count, function_index = 0, i;
    uint64 total_size;

    read_leb_uint32(p, p_end, function_count);
    table_segment->function_count = function_count;
    total_size = sizeof(uint32) * (uint64)function_count;
    if (total_size > 0
        && !(table_segment->func_indexes = (uint32 *)loader_malloc(
                 total_size, error_buf, error_buf_size))) {
        return false;
    }

    for (i = 0; i < function_count; i++) {
        InitializerExpression init_expr = { 0 };

#if WASM_ENABLE_REF_TYPES != 0
        if (!use_init_expr) {
            read_leb_uint32(p, p_end, function_index);
        }
        else {
            if (!load_init_expr(&p, p_end, &init_expr, table_segment->elem_type,
                                error_buf, error_buf_size))
                return false;

            function_index = init_expr.u.ref_index;
        }
#else
        read_leb_uint32(p, p_end, function_index);
        (void)use_init_expr;
#endif

        /* since we are using -1 to indicate ref.null */
        if (init_expr.init_expr_type != INIT_EXPR_TYPE_REFNULL_CONST
            && !check_function_index(module, function_index, error_buf,
                                     error_buf_size)) {
            return false;
        }
        table_segment->func_indexes[i] = function_index;
    }

    *p_buf = p;
    return true;
fail:
    return false;
}
