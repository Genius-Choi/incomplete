check_wasi_abi_compatibility(const WASMModule *module,
#if WASM_ENABLE_MULTI_MODULE != 0
                             bool main_module,
#endif
                             char *error_buf, uint32 error_buf_size)
{
    /**
     * be careful with:
     * wasi compatiable modules(command/reactor) which don't import any wasi
     * APIs. Usually, a command has to import a "prox_exit" at least, but a
     * reactor can depend on nothing. At the same time, each has its own entry
     * point.
     *
     * observations:
     * - clang always injects `_start` into a command
     * - clang always injects `_initialize` into a reactor
     * - `iwasm -f` allows to run a function in the reactor
     *
     * strong assumptions:
     * - no one will define either `_start` or `_initialize` on purpose
     * - `_start` should always be `void _start(void)`
     * - `_initialize` should always be `void _initialize(void)`
     *
     */

    /* clang-format off */
    /**
     *
     * |             | import_wasi_api True |                  | import_wasi_api False |                  |
     * | ----------- | -------------------- | ---------------- | --------------------- | ---------------- |
     * |             | \_initialize() Y     | \_initialize() N | \_initialize() Y      | \_initialize() N |
     * | \_start() Y | N                    | COMMANDER        | N                     | COMMANDER        |
     * | \_start() N | REACTOR              | N                | REACTOR               | OTHERS           |
     */
    /* clang-format on */

    WASMExport *initialize = NULL, *memory = NULL, *start = NULL;

    /* (func (export "_start") (...) */
    start = wasm_loader_find_export(module, "", "_start", EXPORT_KIND_FUNC,
                                    error_buf, error_buf_size);
    if (start) {
        WASMType *func_type =
            module->functions[start->index - module->import_function_count]
                ->func_type;
        if (func_type->param_count || func_type->result_count) {
            set_error_buf(error_buf, error_buf_size,
                          "the signature of builtin _start function is wrong");
            return false;
        }
    }

    /* (func (export "_initialize") (...) */
    initialize = wasm_loader_find_export(
        module, "", "_initialize", EXPORT_KIND_FUNC, error_buf, error_buf_size);
    if (initialize) {
        WASMType *func_type =
            module->functions[initialize->index - module->import_function_count]
                ->func_type;
        if (func_type->param_count || func_type->result_count) {
            set_error_buf(
                error_buf, error_buf_size,
                "the signature of builtin _initialize function is wrong");
            return false;
        }
    }

    /* filter out non-wasi compatiable modules */
    if (!module->import_wasi_api && !start && !initialize) {
        return true;
    }

    /* should have one at least */
    if (module->import_wasi_api && !start && !initialize) {
        LOG_WARNING("warning: a module with WASI apis should be either "
                    "a command or a reactor");
    }

    /*
     * there is at least one of `_start` and `_initialize` in below cases.
     * according to the assumption, they should be all wasi compatiable
     */

    /* always can not have both at the same time  */
    if (start && initialize) {
        set_error_buf(
            error_buf, error_buf_size,
            "neither a command nor a reactor can both have _start function "
            "and _initialize function at the same time");
        return false;
    }

#if WASM_ENABLE_MULTI_MODULE != 0
    /* filter out commands (with `_start`) cases */
    if (start && !main_module) {
        set_error_buf(
            error_buf, error_buf_size,
            "a command (with _start function) can not be a sub-module");
        return false;
    }
#endif

    /*
     * it is ok a reactor acts as a main module,
     * so skip the check about (with `_initialize`)
     */

    memory = wasm_loader_find_export(module, "", "memory", EXPORT_KIND_MEMORY,
                                     error_buf, error_buf_size);
    if (!memory
#if WASM_ENABLE_LIB_WASI_THREADS != 0
        /*
         * with wasi-threads, it's still an open question if a memory
         * should be exported.
         *
         * https://github.com/WebAssembly/wasi-threads/issues/22
         * https://github.com/WebAssembly/WASI/issues/502
         *
         * Note: this code assumes the number of memories is at most 1.
         */
        && module->import_memory_count == 0
#endif
    ) {
        set_error_buf(error_buf, error_buf_size,
                      "a module with WASI apis must export memory by default");
        return false;
    }

    return true;
}
