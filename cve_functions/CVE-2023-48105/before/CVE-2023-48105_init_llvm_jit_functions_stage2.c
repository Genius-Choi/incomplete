init_llvm_jit_functions_stage2(WASMModule *module, char *error_buf,
                               uint32 error_buf_size)
{
    char *aot_last_error;
    uint32 i;

    if (module->function_count == 0)
        return true;

    if (!aot_compile_wasm(module->comp_ctx)) {
        aot_last_error = aot_get_last_error();
        bh_assert(aot_last_error != NULL);
        set_error_buf(error_buf, error_buf_size, aot_last_error);
        return false;
    }

#if WASM_ENABLE_FAST_JIT != 0 && WASM_ENABLE_LAZY_JIT != 0
    if (module->orcjit_stop_compiling)
        return false;
#endif

    bh_print_time("Begin to lookup llvm jit functions");

    for (i = 0; i < module->function_count; i++) {
        LLVMOrcJITTargetAddress func_addr = 0;
        LLVMErrorRef error;
        char func_name[48];

        snprintf(func_name, sizeof(func_name), "%s%d", AOT_FUNC_PREFIX, i);
        error = LLVMOrcLLLazyJITLookup(module->comp_ctx->orc_jit, &func_addr,
                                       func_name);
        if (error != LLVMErrorSuccess) {
            char *err_msg = LLVMGetErrorMessage(error);
            set_error_buf_v(error_buf, error_buf_size,
                            "failed to compile llvm jit function: %s", err_msg);
            LLVMDisposeErrorMessage(err_msg);
            return false;
        }

        /**
         * No need to lock the func_ptr[func_idx] here as it is basic
         * data type, the load/store for it can be finished by one cpu
         * instruction, and there can be only one cpu instruction
         * loading/storing at the same time.
         */
        module->func_ptrs[i] = (void *)func_addr;

#if WASM_ENABLE_FAST_JIT != 0 && WASM_ENABLE_LAZY_JIT != 0
        module->functions[i]->llvm_jit_func_ptr = (void *)func_addr;

        if (module->orcjit_stop_compiling)
            return false;
#endif
    }

    bh_print_time("End lookup llvm jit functions");

    return true;
}
