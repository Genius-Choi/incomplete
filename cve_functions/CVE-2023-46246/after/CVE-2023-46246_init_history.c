init_history(void)
{
    int		newlen;	    // new length of history table
    histentry_T	*temp;
    int		i;
    int		j;
    int		type;

    // If size of history table changed, reallocate it
    newlen = (int)p_hi;
    if (newlen == hislen)		// history length didn't change
	return;

    // history length changed
    for (type = 0; type < HIST_COUNT; ++type)   // adjust the tables
    {
	if (newlen > 0)
	{
	    temp = ALLOC_MULT(histentry_T, newlen);
	    if (temp == NULL)   // out of memory!
	    {
		if (type == 0)  // first one: just keep the old length
		{
		    newlen = hislen;
		    break;
		}
		// Already changed one table, now we can only have zero
		// length for all tables.
		newlen = 0;
		type = -1;
		continue;
	    }
	}
	else
	    temp = NULL;

	if (hisidx[type] < 0)		// there are no entries yet
	{
	    for (i = 0; i < newlen; ++i)
		clear_hist_entry(&temp[i]);
	}
	else if (newlen > hislen)	// array becomes bigger
	{
	    for (i = 0; i <= hisidx[type]; ++i)
		temp[i] = history[type][i];
	    j = i;
	    for ( ; i <= newlen - (hislen - hisidx[type]); ++i)
		clear_hist_entry(&temp[i]);
	    for ( ; j < hislen; ++i, ++j)
		temp[i] = history[type][j];
	}
	else				// array becomes smaller or 0
	{
	    j = hisidx[type];
	    for (i = newlen - 1; ; --i)
	    {
		if (i >= 0)		// copy newest entries
		    temp[i] = history[type][j];
		else			// remove older entries
		    vim_free(history[type][j].hisstr);
		if (--j < 0)
		    j = hislen - 1;
		if (j == hisidx[type])
		    break;
	    }
	    hisidx[type] = newlen - 1;
	}
	vim_free(history[type]);
	history[type] = temp;
    }
    hislen = newlen;
}
