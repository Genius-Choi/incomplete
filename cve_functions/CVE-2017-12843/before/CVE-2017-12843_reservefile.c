static int reservefile(struct protstream *in, const char *part,
                       struct message_guid *guid, unsigned long size,
                       const char **fname)
{
    FILE *file;
    char buf[8192+1];
    int r = 0;

    /* XXX - write to a temporary file then move in to place! */
    *fname = dlist_reserve_path(part, /*isarchive*/0, guid);

    /* remove any duplicates if they're still here */
    unlink(*fname);

    file = fopen(*fname, "w+");
    if (!file) {
        syslog(LOG_ERR,
               "IOERROR: failed to upload file %s", message_guid_encode(guid));
        r = IMAP_IOERROR;
        /* Note: we still read the file's data from the wire,
         * to avoid losing protocol sync */
    }

    /* XXX - calculate sha1 on the fly? */
    while (size) {
        size_t n = prot_read(in, buf, size > 8192 ? 8192 : size);
        if (!n) {
            syslog(LOG_ERR,
                "IOERROR: reading message: unexpected end of file");
            r = IMAP_IOERROR;
            break;
        }
        size -= n;
        if (fwrite(buf, 1, n, file) != n) {
            syslog(LOG_ERR, "IOERROR: writing to file '%s': %m", *fname);
            r = IMAP_IOERROR;
            break;
        }
    }

    if (r)
        goto error;

    /* Make sure that message flushed to disk just incase mmap has problems */
    fflush(file);
    if (ferror(file)) {
        r = IMAP_IOERROR;
        goto error;
    }

    if (fsync(fileno(file)) < 0) {
        syslog(LOG_ERR, "IOERROR: fsyncing file '%s': %m", *fname);
        r = IMAP_IOERROR;
        goto error;
    }

    fclose(file);

    return 0;

error:
    if (file) {
        fclose(file);
        unlink(*fname);
        *fname = NULL;
    }
    return r;
}
