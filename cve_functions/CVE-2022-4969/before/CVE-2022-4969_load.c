uint64_t load(RaggedArray * self, void * raw, uint64_t raw_length,
              size_t * raw_consumed, int rows, int length_power,
              int big_endian) {
  /* The workhorse behind ``RaggedArray.loads()``. */

  IntRead read = choose_int_read(length_power, big_endian);

  int start = self -> starts[0] = 0;
  void * raw_start = raw;
  void * raw_end = raw + raw_length;

  // Parse the array a row at a time:
  for (int row = 0; row < rows; row++) {

    // Escape if there is not enough input left to read another length. This
    // shall be propagated as an error in Python.
    if (raw > raw_end - (1 << length_power)) return row;

    // Read the `length` of the row then move the `raw` pointer onto the row's
    // data.
    uint64_t length = read(raw);
    raw += (1 << length_power);

    // Again, escape if there is not enough remaining input to contain the
    // expected row.
    if (raw > raw_end - length * self -> itemsize) return row;

    // Copy the row data itself and move the input pointer to the next row.
    memcpy(self -> flat + start * self -> itemsize, raw,
           self -> itemsize * length);
    raw += length * self -> itemsize;

    // Mark the end of this row. This also sets the start of the next
    // row because `self -> ends` is the same array as`self -> starts` but
    // shifted along one item.
    start += length;
    self -> ends[row] = start;

  }
  // Record how many bytes of input have been used.
  *raw_consumed = raw - raw_start;

  return rows;
}
