void gf_filter_pid_inst_delete_task(GF_FSTask *task)
{
	GF_FilterPid *pid = task->pid;
	GF_FilterPidInst *pidinst = task->udta;
	GF_Filter *filter = pid->filter;
	Bool pid_still_alive = GF_FALSE;

	assert(filter);
	//reset in process
	if ((pidinst->filter && pidinst->discard_packets) || filter->stream_reset_pending || filter->abort_pending) {
		TASK_REQUEUE(task)
		return;
	}

	//reset PID instance buffers before checking number of output shared packets
	//otherwise we may block because some of the shared packets are in the
	//pid instance buffer (not consumed)
	gf_filter_pid_inst_reset(pidinst);

	//we still have packets out there!
	if (pidinst->pid->nb_shared_packets_out) {
		//special case for disconnect of fanouts, destroy even if shared packets out
		if (!pid->num_destinations || ((pid->num_destinations>=1) && (gf_list_find(pid->destinations, pidinst)>=0))) {
			TASK_REQUEUE(task)
			return;
		}
	}

	//WARNING at this point pidinst->filter may be destroyed
	GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("Filter %s pid instance %s destruction (%d fan-out)\n",  filter->name, pid->name, pid->num_destinations));
	gf_mx_p(filter->tasks_mx);
	gf_list_del_item(pid->destinations, pidinst);
	pid->num_destinations = gf_list_count(pid->destinations);
	if (pidinst->pid->num_pidinst_del_pending) {
		pidinst->pid->num_pidinst_del_pending--;
		if (pidinst->pid->num_pidinst_del_pending)
			pid_still_alive = GF_TRUE;
	}
	gf_mx_v(filter->tasks_mx);

	if (pidinst->is_decoder_input) {
		assert(pid->nb_decoder_inputs);
		safe_int_dec(&pid->nb_decoder_inputs);
	}
	gf_filter_pid_inst_del(pidinst);
	//recompute max buf dur and nb units to update blocking state
	if (pid->num_destinations) {
		u32 i;
		u32 nb_pck = 0;
		s64 buf_dur = 0;
		for (i = 0; i < pid->num_destinations; i++) {
			GF_FilterPidInst *apidi = gf_list_get(pid->destinations, i);
			u32 npck = gf_fq_count(apidi->packets);
			if (npck > nb_pck) nb_pck = npck;
			if (apidi->buffer_duration > buf_dur) buf_dur = apidi->buffer_duration;
		}
		pid->nb_buffer_unit = nb_pck;
		pid->buffer_duration = buf_dur;
	} else {
		pid->nb_buffer_unit = 0;
		pid->buffer_duration = 0;
	}

	assert(pid->filter == filter);

	if (pid_still_alive)
		return;

	//some more destinations on pid, update blocking state
	if (pid->num_destinations || pid->init_task_pending) {
		if (pid->would_block)
			gf_filter_pid_check_unblock(pid);
		else
			gf_filter_pid_would_block(pid);

		return;
	}
	gf_mx_p(filter->tasks_mx);
	//still some input to the filter, cannot destroy the output pid
	if (gf_list_count(filter->input_pids)) {
		gf_mx_v(filter->tasks_mx);
		return;
	}
	//no more destinations on pid, unblock if blocking
	if (pid->would_block) {
		assert(pid->filter->would_block);
		safe_int_dec(&pid->filter->would_block);
	}

	//we cannot remove an output pid since the filter may still check status on that pid or try to dispatch packets
	//removal/destruction must come from the filter
	//we only count the number of output pids that have been internally discarded by this function, and trigger filter removal if last
	pid->removed = GF_TRUE;

	//filter still active and has no input, check if there are no more output pids valid. If so, remove filter
	if (!gf_list_count(filter->input_pids) && !filter->finalized) {
		u32 i, nb_opid_rem=0;
		for (i=0; i<filter->num_output_pids; i++) {
			GF_FilterPid *apid = gf_list_get(filter->output_pids, i);
			if (apid->removed) nb_opid_rem++;
		}
		if (gf_list_count(filter->output_pids)==nb_opid_rem) {
			gf_filter_post_remove(filter);
		}
	}

	gf_mx_v(filter->tasks_mx);
}
