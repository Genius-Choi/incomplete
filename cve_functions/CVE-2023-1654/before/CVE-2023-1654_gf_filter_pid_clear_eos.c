void gf_filter_pid_clear_eos(GF_FilterPid *pid, Bool clear_all)
{
	u32 i, j;
	GF_FilterPidInst *pidi = (GF_FilterPidInst *)pid;
	if (PID_IS_OUTPUT(pid)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Clearing EOS on output PID %s in filter %s\n", pid->pid->name, pid->filter->name));
		return;
	}
	pid = pid->pid;
	for (i=0; i<pid->filter->num_output_pids; i++) {
		GF_FilterPid *apid = gf_list_get(pid->filter->output_pids, i);
		if (!clear_all && (pid != apid)) continue;

		for (j=0; j<apid->num_destinations; j++) {
			GF_FilterPidInst *apidi = gf_list_get(apid->destinations, j);
			if (apidi->filter != pidi->filter) continue;

			if (apidi->is_end_of_stream) {
				apidi->is_end_of_stream = GF_FALSE;
			}
			if (apid->has_seen_eos) {
				apid->has_seen_eos = GF_FALSE;
				gf_filter_pid_check_unblock(apid);
			}

			if (apidi->pid->filter->would_block && apidi->pid->filter->num_input_pids) {
				u32 k;
				gf_mx_p(apidi->pid->filter->tasks_mx);
				for (k=0; k<apidi->pid->filter->num_input_pids; k++) {
					GF_FilterPidInst *source_pid_inst = gf_list_get(apidi->pid->filter->input_pids, k);
					gf_filter_pid_clear_eos((GF_FilterPid *) source_pid_inst, clear_all);
				}
				gf_mx_v(apidi->pid->filter->tasks_mx);
			}
		}
	}

	//if filter is blocking we cannot clear EOS down the chain
	if (clear_all && !pid->filter->would_block) {
		//block parent
		gf_mx_p(pid->filter->tasks_mx);
		for (i=0; i<pid->filter->num_input_pids; i++) {
			GF_FilterPidInst *apidi = gf_list_get(pid->filter->input_pids, i);
			gf_filter_pid_clear_eos((GF_FilterPid *) apidi, GF_TRUE);
		}
		gf_mx_v(pid->filter->tasks_mx);
	}
}
