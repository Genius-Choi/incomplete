static u64 gf_filter_pid_query_buffer_duration_internal(GF_FilterPid *pid, Bool check_pid_full, Bool force_update)
{
	u32 count, i, j;
	u64 duration=0;
	if (!pid || pid->filter->session->in_final_flush)
		return GF_FILTER_NO_TS;

	if (PID_IS_INPUT(pid)) {
		GF_Filter *filter;
		GF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;
		if (!pidinst->pid) return 0;
		filter = pidinst->pid->filter;
		if (check_pid_full) {
			u32 buffer_full = GF_FALSE;
			Bool buffer_valid = GF_FALSE;

			if (pidinst->pid->max_buffer_unit) {
				buffer_valid = GF_TRUE;
				if (pidinst->pid->max_buffer_unit<=pidinst->pid->nb_buffer_unit)
					buffer_full = GF_TRUE;
			}
			if (pidinst->pid->max_buffer_time) {
				buffer_valid = GF_TRUE;
				if (pidinst->pid->max_buffer_time<=pidinst->pid->buffer_duration)
					buffer_full = GF_TRUE;
			}

			if (buffer_valid) {
				if (!buffer_full) {
					return 0;
				}
				if (pidinst->pid->max_buffer_unit<=pidinst->pid->nb_buffer_unit)
					return GF_FILTER_NO_TS;
			}
		}

		//this is a very costly recursive call until each source, and is likely to be an overkill
		//if many PIDs (large tiling configurations for example)
		//we cache the last computed value and only update every 10 ms
		if (!force_update && (pidinst->filter->last_schedule_task_time - pidinst->last_buf_query_clock < 10000)) {
			return pidinst->last_buf_query_dur;
		}
		pidinst->last_buf_query_clock = pidinst->filter->last_schedule_task_time;
		force_update = GF_TRUE;

		gf_mx_p(filter->tasks_mx);
		count = filter->num_input_pids;
		for (i=0; i<count; i++) {
			u64 dur = gf_filter_pid_query_buffer_duration_internal( gf_list_get(filter->input_pids, i), GF_FALSE, force_update);
			if (dur > duration)
				duration = dur;

			//only probe for first pid when this is a mux or a reassembly filter
			//this is not as precise but avoids spending too much time here for very large number of input pids (tiling)
			if ((count>1) && (filter->num_output_pids==1))
				break;
		}
		gf_mx_v(filter->tasks_mx);
		duration += pidinst->buffer_duration;
		pidinst->last_buf_query_dur = duration;
		return duration;
	} else {
		u32 count2;
		u64 max_dur=0;

		if (check_pid_full) {
			if (pid->max_buffer_unit && (pid->max_buffer_unit>pid->nb_buffer_unit))
				return 0;
			if (pid->max_buffer_time && (pid->max_buffer_time>pid->buffer_duration))
				return 0;
		}

		count = pid->num_destinations;
		for (i=0; i<count; i++) {
			GF_FilterPidInst *pidinst = gf_list_get(pid->destinations, i);

			count2 = pidinst->filter->num_output_pids;
			for (j=0; j<count2; j++) {
				GF_FilterPid *pid_n = gf_list_get(pidinst->filter->output_pids, i);
				u64 dur = gf_filter_pid_query_buffer_duration_internal(pid_n, GF_FALSE, GF_FALSE);
				if (dur > max_dur ) max_dur = dur;
			}
		}
		duration += max_dur;
	}
	return duration;
}
