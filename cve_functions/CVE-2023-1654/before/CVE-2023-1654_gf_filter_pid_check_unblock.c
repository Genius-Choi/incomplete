static void gf_filter_pid_check_unblock(GF_FilterPid *pid)
{
	Bool unblock;

	if (pid->ignore_blocking) {
		return;
	}
	//if we are in end of stream state and done with all packets, stay blocked
	if (pid->has_seen_eos && !pid->nb_buffer_unit) {
		if (!pid->would_block) {
			safe_int_inc(&pid->would_block);
			safe_int_inc(&pid->filter->would_block);
			assert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);
		}
		return;
	}

	unblock=GF_FALSE;

	assert(pid->playback_speed_scaler);

	//we block according to the number of dispatched units (decoder output) or to the requested buffer duration
	//for other streams - unblock accordingly
	if (pid->max_buffer_unit) {
		if (pid->nb_buffer_unit * GF_FILTER_SPEED_SCALER < pid->max_buffer_unit * pid->playback_speed_scaler) {
			unblock=GF_TRUE;
		}
	} else if (pid->buffer_duration * GF_FILTER_SPEED_SCALER < pid->max_buffer_time * pid->playback_speed_scaler) {
		unblock=GF_TRUE;
	}

	if (!unblock) {
		return;
	}
	gf_mx_p(pid->filter->tasks_mx);
	unblock = GF_FALSE;

	//unblock pid
	if (pid->would_block) {
		safe_int_dec(&pid->would_block);

		assert(pid->filter->would_block);
		safe_int_dec(&pid->filter->would_block);
		assert((s32)pid->filter->would_block>=0);
		assert(pid->filter->would_block + pid->filter->num_out_pids_not_connected <= pid->filter->num_output_pids);

		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s unblocked (filter has %d blocking pids)\n", pid->pid->filter->name, pid->pid->name, pid->pid->filter->would_block));

		//check filter unblock
		unblock = GF_TRUE;
	}
	//pid was not blocking but filter is no longer scheduled (might happen in multi-threaded modes), check filter unblock
	else if (!pid->filter->process_task_queued) {
		unblock = GF_TRUE;
	}

	if (unblock && (pid->filter->would_block + pid->filter->num_out_pids_not_connected < pid->filter->num_output_pids)) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s has only %d / %d blocked pids, requesting process task (%d queued)\n", pid->filter->name, pid->filter->would_block + pid->filter->num_out_pids_not_connected, pid->filter->num_output_pids, pid->filter->process_task_queued));

		//post a process task
		gf_filter_post_process_task(pid->filter);
	}

	gf_mx_v(pid->filter->tasks_mx);
}
