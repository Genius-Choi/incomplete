u32 gf_filter_caps_to_caps_match(const GF_FilterRegister *src, u32 src_bundle_idx, const GF_FilterRegister *dst_reg, GF_Filter *dst_filter, u32 *dst_bundle_idx, u32 for_dst_bundle, u32 *loaded_filter_flags, GF_CapsBundleStore *capstore)
{
	u32 i=0;
	s32 first_static_cap=-1;
	u32 cur_bundle_start = 0;
	u32 cur_bundle_idx = 0;
	u32 nb_matched=0;
	//u32 nb_out_caps=0;
	u32 nb_in_bundles=0;
	u32 bundle_score = 0;
	u32 *bundles_in_ok = NULL;
	u32 *bundles_cap_found = NULL;
	u32 *bundles_in_scores = NULL;
	//initialize caps matched to true for first cap bundle
	Bool all_caps_matched = GF_TRUE;
	const GF_FilterCapability *dst_caps = dst_reg->caps;
	u32 nb_dst_caps = dst_reg->nb_caps;

	if (dst_filter && dst_filter->freg==dst_reg && dst_filter->forced_caps) {
		dst_caps = dst_filter->forced_caps;
		nb_dst_caps = dst_filter->nb_forced_caps;
	}

	//check all input caps of dst filter, count bundles
	if (! gf_filter_has_out_caps(src->caps, src->nb_caps)) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s has no output caps, cannot match filter %s inputs\n", src->name, dst_reg->name));
		return 0;
	}

	//check all input caps of dst filter, count bundles
	nb_in_bundles = gf_filter_caps_bundle_count(dst_caps, nb_dst_caps);
	if (!nb_in_bundles) {
		if (dst_reg->configure_pid) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s has no caps but pid configure possible, assuming possible connection\n", dst_reg->name));
			return 1;
		}
		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s has no caps and no pid configure, no possible connection\n", dst_reg->name));
		return 0;
	}
	if (capstore->nb_allocs < nb_in_bundles) {
		capstore->nb_allocs = nb_in_bundles;
		capstore->bundles_in_ok = gf_realloc(capstore->bundles_in_ok, sizeof(u32) * nb_in_bundles);
		capstore->bundles_cap_found = gf_realloc(capstore->bundles_cap_found, sizeof(u32) * nb_in_bundles);
		capstore->bundles_in_scores = gf_realloc(capstore->bundles_in_scores,  sizeof(u32) * nb_in_bundles);
	}
	bundles_in_ok =	capstore->bundles_in_ok;
	bundles_cap_found = capstore->bundles_cap_found;
	bundles_in_scores = capstore->bundles_in_scores;

	for (i=0; i<nb_in_bundles; i++) {
		bundles_in_ok[i] = 1;
		bundles_cap_found[i] = 0;
		bundles_in_scores[i] = 0;
	}

	//check all output caps of src filter
	for (i=0; i<src->nb_caps; i++) {
		u32 j, k;
		Bool already_tested = GF_FALSE;
		const GF_FilterCapability *out_cap = &src->caps[i];

		if (i<cur_bundle_start) {
			if (!(out_cap->flags & GF_CAPFLAG_STATIC))
				continue;
		}

		if (!(out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {
			all_caps_matched = GF_TRUE;
			cur_bundle_start = i+1;
			cur_bundle_idx++;
			if (src_bundle_idx < cur_bundle_idx)
				break;

			if (first_static_cap>=0)
				i = (u32) (first_static_cap-1);
			continue;
		}

		//not our selected output and not static cap
		if ((src_bundle_idx != cur_bundle_idx) && ! (out_cap->flags & GF_CAPFLAG_STATIC) ) {
			continue;
		}

		//not an output cap
		if (!(out_cap->flags & GF_CAPFLAG_OUTPUT) ) continue;

		if ((first_static_cap==-1) && (out_cap->flags & GF_CAPFLAG_STATIC)) {
			first_static_cap = i;
		}


		//no match possible for this cap, wait until next cap start
		if (!all_caps_matched) continue;

		//check we didn't test a cap with same name/code before us
		for (k=cur_bundle_start; k<i; k++) {
			const GF_FilterCapability *an_out_cap = &src->caps[k];
			if (! (an_out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {
				break;
			}
			if (! (an_out_cap->flags & GF_CAPFLAG_OUTPUT) ) {
				continue;
			}
			if (out_cap->code && (out_cap->code == an_out_cap->code) ) {
				already_tested = GF_TRUE;
				break;
			}
			if (out_cap->name && an_out_cap->name && !strcmp(out_cap->name, an_out_cap->name)) {
				already_tested = GF_TRUE;
				break;
			}
		}
		if (already_tested) {
			continue;
		}
		//nb_out_caps++;

		//set cap as OK in all bundles
		for (k=0; k<nb_in_bundles; k++) {
			bundles_cap_found[k] = 0;
		}

		//check all output caps in this bundle with the same code/name, consider OK if one is matched
		if (first_static_cap>=0)
			k = first_static_cap-1;
		else
			k = cur_bundle_start;

		for (; k<src->nb_caps; k++) {
			u32 cur_dst_bundle=0;
			Bool static_matched = GF_FALSE;
			u32 nb_caps_tested = 0;
			u32 cap_loaded_filter_only = 0;
			Bool matched=GF_FALSE;
			Bool exclude=GF_FALSE;
			Bool prop_found=GF_FALSE;
			const GF_FilterCapability *an_out_cap = &src->caps[k];

			if (k<cur_bundle_start) {
				if (!(an_out_cap->flags & GF_CAPFLAG_STATIC))
					continue;
			}
			if (! (an_out_cap->flags & GF_CAPFLAG_IN_BUNDLE) ) {
				break;
			}
			if (! (an_out_cap->flags & GF_CAPFLAG_OUTPUT) ) {
				continue;
			}
			if (out_cap->code && !cap_code_match(out_cap->code, an_out_cap->code) )
				continue;

			if (out_cap->name && (!an_out_cap->name || strcmp(out_cap->name, an_out_cap->name)))
				continue;

			//not our selected output and not static cap
			if ((src_bundle_idx != cur_bundle_idx) && ! (an_out_cap->flags & GF_CAPFLAG_STATIC) ) {
				continue;
			}

			nb_matched = 0;
			//check all input caps of dst filter, count ones that are matched
			for (j=0; j<nb_dst_caps; j++) {
				Bool prop_equal;
				const GF_FilterCapability *in_cap = &dst_caps[j];

				if (! (in_cap->flags & GF_CAPFLAG_IN_BUNDLE)) {
					if (((cur_dst_bundle >= for_dst_bundle) || (in_cap->flags & GF_CAPFLAG_STATIC))) {
						if (!matched && !nb_caps_tested && (out_cap->flags & GF_CAPFLAG_EXCLUDED)) {
							matched = GF_TRUE;
						}
					}

					//we found a prop, excluded but with != value hence acceptable, default matching to true
					if (!matched && prop_found) matched = GF_TRUE;

					//match, flag this bundle as ok
					if (matched) {
						if (!bundles_cap_found[cur_dst_bundle])
							bundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;

						nb_matched++;
					}

					matched = static_matched ? GF_TRUE : GF_FALSE;
					if (exclude) {
						bundles_cap_found[cur_dst_bundle] = 0;
						exclude = GF_FALSE;
					}
					prop_found = GF_FALSE;
					nb_caps_tested = 0;
					cur_dst_bundle++;
					if (cur_dst_bundle > for_dst_bundle)
						break;

					continue;
				}
				//not an input cap
				if (!(in_cap->flags & GF_CAPFLAG_INPUT) )
					continue;

				//optional cap, ignore
				if (in_cap->flags & GF_CAPFLAG_OPTIONAL)
					continue;

				if ((cur_dst_bundle < for_dst_bundle) && !(in_cap->flags & GF_CAPFLAG_STATIC))
					continue;

				//prop was excluded, cannot match in bundle
				if (exclude) continue;
				//prop was matched, no need to check other caps in the current bundle
				if (matched) continue;

				if (out_cap->code && !cap_code_match(out_cap->code, in_cap->code) )
					continue;

				if (out_cap->name && (!in_cap->name || strcmp(out_cap->name, in_cap->name)))
					continue;

				nb_caps_tested++;
				//we found a property of that type , check if equal equal
				prop_equal = gf_props_equal(&in_cap->val, &an_out_cap->val);
				if ((in_cap->flags & GF_CAPFLAG_EXCLUDED) && !(an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {
					//special case for excluded output caps marked for loaded filter only and optional:
					//always consider no match, the actual pid link resolving will sort this out
					//this fixes a bug in reframer -> ffdec links: since ffdec only specifies excluded GF_CODEC_ID caps,
					//not doing so will always force reframer->ufnalu->rfnalu->ffdec
					if (an_out_cap->flags & (GF_CAPFLAG_OPTIONAL|GF_CAPFLAG_LOADED_FILTER))
						prop_equal = GF_FALSE;

					//prop type matched, output includes it and input excludes it: no match, don't look any further
					if (prop_equal) {
						matched = GF_FALSE;
						exclude = GF_TRUE;
						prop_found = GF_FALSE;
					} else {
						//remember we found a prop of same type but excluded value
						// we will match unless we match an excluded value
						prop_found = GF_TRUE;
					}
				} else if (!(in_cap->flags & GF_CAPFLAG_EXCLUDED) && (an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {
					//prop type matched, input includes it and output excludes it: no match, don't look any further
					if (prop_equal) {
						matched = GF_FALSE;
						exclude = GF_TRUE;
						prop_found = GF_FALSE;
					} else {
						//remember we found a prop of same type but excluded value
						//we will match unless we match an excluded value
						prop_found = GF_TRUE;
					}
				} else if (prop_equal) {
					matched = GF_TRUE;
//					if (an_out_cap->flags & GF_CAPFLAG_STATIC)
//						static_matched = GF_TRUE;
				} else if ((in_cap->flags & GF_CAPFLAG_EXCLUDED) && (an_out_cap->flags & GF_CAPFLAG_EXCLUDED) ) {
					//prop type matched, input excludes it and output excludes it and no match, remmeber we found the prop type
					prop_found = GF_TRUE;
				}

				if (prop_found && (in_cap->flags & GF_CAPFLAG_LOADED_FILTER))
					cap_loaded_filter_only = 1;
			}
			if (nb_caps_tested) {
				//we found a prop, excluded but with != value hence acceptable, default matching to true
				if (!matched && prop_found) matched = GF_TRUE;
				//not match, flag this bundle as not ok
				if (matched) {
					if (!bundles_cap_found[cur_dst_bundle])
						bundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;

					nb_matched++;
				}
				//excluded cap was found, disable bundle (might have been activated before we found the excluded cap)
				else if (exclude) {
					bundles_cap_found[cur_dst_bundle] = 0;
				}
			} else if (!nb_dst_caps) {
				if (!bundles_cap_found[cur_dst_bundle])
					bundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;

				nb_matched++;
			} else if (!nb_matched && !prop_found && (an_out_cap->flags & (GF_CAPFLAG_EXCLUDED|GF_CAPFLAG_OPTIONAL)) && (cur_dst_bundle<nb_in_bundles) ) {
				if (!bundles_cap_found[cur_dst_bundle])
					bundles_cap_found[cur_dst_bundle] = cap_loaded_filter_only ? 2 : 1;

				nb_matched++;
			}
		}
		//merge bundle cap
		nb_matched=0;
		for (k=0; k<nb_in_bundles; k++) {
			if (!bundles_cap_found[k])
				bundles_in_ok[k] = 0;
			else {
				nb_matched += 1;
				//we matched this property, keep score for the bundle
				bundles_in_scores[k] ++;
				//mark if connection is only valid for loaded inputs
				if (bundles_cap_found[k]==2)
				 	bundles_in_ok[k] |= 1<<1;
				//mark if connection is only valid for loaded outputs
				if (out_cap->flags & GF_CAPFLAG_LOADED_FILTER)
					bundles_in_ok[k] |= 1<<2;
			}
		}

		//not matched and not excluded, skip until next bundle
		if (!nb_matched && !(out_cap->flags & (GF_CAPFLAG_EXCLUDED|GF_CAPFLAG_OPTIONAL))) {
			all_caps_matched = GF_FALSE;
		}
	}

	//get bundle with highest score
	bundle_score = 0;
	nb_matched = 0;

	for (i=0; i<nb_in_bundles; i++) {
		if (bundles_in_ok[i]) {
			nb_matched++;
			if (bundle_score < bundles_in_scores[i]) {
				*dst_bundle_idx = i;
				bundle_score = bundles_in_scores[i];
				if (loaded_filter_flags) {
					*loaded_filter_flags = (bundles_in_ok[i]>>1);
				}
			}
			if (for_dst_bundle==i) {
				*dst_bundle_idx = i;
				if (loaded_filter_flags) {
					*loaded_filter_flags = (bundles_in_ok[i]>>1);
				}
				return bundles_in_scores[i];
			}
		}
	}
	if (!bundle_score) {
//		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s outputs cap bundle %d do not match filter %s inputs\n", src->name, src_bundle_idx, dst_reg->name));
	} else {
//		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s outputs cap bundle %d matches filter %s inputs caps bundle %d (%d total bundle matches, bundle matched %d/%d caps)\n", src->name, src_bundle_idx, dst_reg->name, *dst_bundle_idx, nb_matched, bundle_score, nb_out_caps));
	}
	return bundle_score;
}
