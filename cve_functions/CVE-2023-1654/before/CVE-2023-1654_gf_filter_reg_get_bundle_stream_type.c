static s32 gf_filter_reg_get_bundle_stream_type(const GF_FilterRegister *freg, u32 cap_idx, Bool for_output)
{
	u32 i, cur_bundle, stype=0, nb_stype=0;

	cur_bundle = 0;
	for (i=0; i<freg->nb_caps; i++) {
		u32 cap_stype=0;
		const GF_FilterCapability *cap = &freg->caps[i];
		if (!(cap->flags & GF_CAPFLAG_IN_BUNDLE)) {
			cur_bundle++;
			continue;
		}
		if (for_output) {
			if (!(cap->flags & GF_CAPFLAG_OUTPUT)) continue;
		} else {
			if (!(cap->flags & GF_CAPFLAG_INPUT)) continue;
		}
		if ((cur_bundle != cap_idx) && !(cap->flags & GF_CAPFLAG_STATIC) ) continue;
		//output type is file or same media type, allow looking for filter chains
		if (cap->flags & GF_CAPFLAG_EXCLUDED) continue;

		if (cap->code == GF_PROP_PID_STREAM_TYPE)
			cap_stype = cap->val.value.uint;
		else if ((cap->code == GF_PROP_PID_MIME) || (cap->code == GF_PROP_PID_FILE_EXT) )
			cap_stype = GF_STREAM_FILE;

		if (!cap_stype) continue;

		if (stype != cap_stype) {
			stype = cap_stype;
			nb_stype++;
		}
	}
	if (nb_stype==1) return (s32) stype;
	if (nb_stype) return -1;
	return 0;
}
