static void gf_filter_pid_connect_task(GF_FSTask *task)
{
	GF_Filter *filter = task->filter;
	GF_FilterSession *fsess = filter->session;
	GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s pid %s connecting to %s (%p)\n", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name, filter));

	//filter will require a new instance, clone it
	if (filter->num_input_pids && (filter->max_extra_pids <= filter->num_input_pids - 1)) {
		GF_Filter *new_filter = gf_filter_clone(filter, task->pid->pid->filter);
		if (new_filter) {
			filter = new_filter;
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Failed to clone filter %s\n", filter->name));
			assert(filter->in_pid_connection_pending);
			safe_int_dec(&filter->in_pid_connection_pending);
			if (task->pid->pid) {
				gf_mx_p(filter->tasks_mx);
				gf_list_del_item(filter->temp_input_pids, task->pid->pid);
				gf_mx_v(filter->tasks_mx);
			}
			return;
		}
	}
	if (task->pid->pid) {
		gf_mx_p(filter->tasks_mx);
		gf_list_del_item(filter->temp_input_pids, task->pid->pid);
		gf_mx_v(filter->tasks_mx);
		gf_filter_pid_configure(filter, task->pid->pid, GF_PID_CONF_CONNECT);
		//once connected, any set_property before the first packet dispatch will have to trigger a reconfigure
		if (!task->pid->pid->nb_pck_sent) {
			task->pid->pid->request_property_map = GF_TRUE;
			task->pid->pid->pid_info_changed = GF_FALSE;
		}
	}
	
	//filter may now be the clone, decrement on original filter
	assert(task->filter->in_pid_connection_pending);
	safe_int_dec(&task->filter->in_pid_connection_pending);

	gf_fs_cleanup_filters(fsess);

}
