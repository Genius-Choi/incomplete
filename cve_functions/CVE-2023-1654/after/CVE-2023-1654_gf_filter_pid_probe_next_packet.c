static GF_FilterPacketInstance *gf_filter_pid_probe_next_packet(GF_FilterPidInst *pidinst)
{
	u32 i=0;
	//get first packet that is not an internal command
	//if packet is a clock, consume it
	while (1) {
		GF_FilterPacketInstance *pcki = (GF_FilterPacketInstance *)gf_fq_get(pidinst->packets, i);
		if (!pcki) break;
		i++;

		u32 ctype = (pcki->pck->info.flags & GF_PCK_CMD_MASK);
		if (ctype == GF_PCK_CMD_PID_EOS ) {
			break;
		} else if (ctype == GF_PCK_CMD_PID_REM) {
			break;
		}
		ctype = (pcki->pck->info.flags & GF_PCK_CKTYPE_MASK) >> GF_PCK_CKTYPE_POS;

		if (ctype) {
			if (pcki->pid->handles_clock_references) return NULL;

			gf_filter_pid_filter_internal_packet(pidinst, pcki);
			return gf_filter_pid_probe_next_packet(pidinst);
		}
		return pcki;
	}
	return NULL;
}
