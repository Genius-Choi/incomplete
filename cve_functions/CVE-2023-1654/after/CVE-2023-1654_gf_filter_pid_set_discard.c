GF_Err gf_filter_pid_set_discard(GF_FilterPid *pid, Bool discard_on)
{
	GF_FilterPidInst *pidi = (GF_FilterPidInst *) pid;
	if (PID_IS_OUTPUT(pid)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Attempt at discarding packets on output PID %s in filter %s not allowed\n", pid->pid->name, pid->filter->name));
		return GF_BAD_PARAM;
	}
	if (discard_on) {
		GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("Discarding packets on PID %s (filter %s to %s)\n", pid->pid->name, pid->pid->filter->name, pid->filter->name));
		gf_filter_aggregate_packets(pidi);
		//force discarding
		u32 pck_discard_bck = pidi->discard_packets;
		pidi->discard_packets = 0;
		while (gf_filter_pid_get_packet(pid)) {
			gf_filter_pid_drop_packet(pid);
		}
		pidi->discard_packets = pck_discard_bck;
		pidi->is_end_of_stream = GF_TRUE;
	} else {
		//no more packets in queue or postponed, we can trust the EOS signal on the PID
		//otherwise even though the PID has seen the EOS, it is not yet processed by the pid instance, signaling it
		//would break up filters (for example dash demux) relying on precise EOS signals which must be toggled at the EOS packet
		//once all previous packets have been processed
		if (!gf_fq_count(pidi->packets) && !pid->pid->filter->postponed_packets)
			pidi->is_end_of_stream = pid->pid->has_seen_eos;
	}
	pidi->discard_inputs = discard_on ? 1 : 0;
	return GF_OK;
}
