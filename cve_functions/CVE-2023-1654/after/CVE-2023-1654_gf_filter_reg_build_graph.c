static GF_FilterRegDesc *gf_filter_reg_build_graph(GF_List *links, const GF_FilterRegister *freg, GF_CapsBundleStore *capstore, GF_FilterPid *src_pid, GF_Filter *dst_filter)
{
	u32 nb_dst_caps, nb_regs, i, nb_caps;
	Bool freg_has_output;

	GF_FilterRegDesc *reg_desc = NULL;
	const GF_FilterCapability *caps = freg->caps;
	nb_caps = freg->nb_caps;
	if (dst_filter && ((freg->flags & (GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM)) || (src_pid && dst_filter->forced_caps) ) ) {
		caps = dst_filter->forced_caps;
		nb_caps = dst_filter->nb_forced_caps;
	}

	freg_has_output = gf_filter_has_out_caps(caps, nb_caps);

	GF_SAFEALLOC(reg_desc, GF_FilterRegDesc);
	if (!reg_desc) return NULL;

	reg_desc->freg = freg;

	nb_dst_caps = gf_filter_caps_bundle_count(caps, nb_caps);


	//we are building a register descriptor acting as destination, ignore any output caps
	if (src_pid || dst_filter) freg_has_output = GF_FALSE;

	//setup all connections
	nb_regs = gf_list_count(links);
	for (i=0; i<nb_regs; i++) {
		GF_FilterRegDesc *a_reg = gf_list_get(links, i);
		if (a_reg->freg == freg) continue;

		gf_filter_reg_build_graph_single(reg_desc, freg, a_reg, freg_has_output, nb_dst_caps, capstore, dst_filter);
	}

	if (!dst_filter && (freg->flags & GF_FS_REG_ALLOW_CYCLIC)) {
		gf_filter_reg_build_graph_single(reg_desc, freg, reg_desc, freg_has_output, nb_dst_caps, capstore, NULL);
	}
	return reg_desc;
}
