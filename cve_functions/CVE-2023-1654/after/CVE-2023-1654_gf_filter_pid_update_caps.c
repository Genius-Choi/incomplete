static void gf_filter_pid_update_caps(GF_FilterPid *pid)
{
	u32 mtype=0, codecid=0;
	u32 i;
	const GF_PropertyValue *p;

	pid->raw_media = GF_FALSE;
	p = gf_filter_pid_get_property_first(pid, GF_PROP_PID_CODECID);
	if (p) codecid = p->value.uint;

	p = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);
	if (p) mtype = p->value.uint;

	Bool was_sparse = pid->is_sparse;
	p = gf_filter_pid_get_property_first(pid, GF_PROP_PID_SPARSE);
	if (p) {
		pid->is_sparse = p->value.boolean;
	} else {
		u32 otype = mtype;
		p = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ORIG_STREAM_TYPE);
		if (p) otype = p->value.uint;
		switch (otype) {
		case GF_STREAM_AUDIO:
		case GF_STREAM_VISUAL:
		case GF_STREAM_FILE:
			pid->is_sparse = GF_FALSE;
			break;
		default:
			pid->is_sparse = GF_TRUE;
			break;
		}
	}
	if (was_sparse && !pid->is_sparse)
		safe_int_dec(&pid->filter->nb_sparse_pids);
	else if (!was_sparse && pid->is_sparse)
		safe_int_inc(&pid->filter->nb_sparse_pids);


	pid->stream_type = mtype;
	pid->codecid = codecid;

	u32 buffer_us = pid->filter->pid_buffer_max_us ? pid->filter->pid_buffer_max_us : pid->filter->session->default_pid_buffer_max_us;
	if (pid->user_max_buffer_time) {
		pid->max_buffer_time = MAX(pid->user_max_buffer_time, buffer_us);
		pid->max_buffer_unit = 0;
	} else {
		pid->max_buffer_time = buffer_us;
		pid->max_buffer_unit = pid->filter->pid_buffer_max_units ? pid->filter->pid_buffer_max_units : pid->filter->session->default_pid_buffer_max_units;
	}
	pid->raw_media = GF_FALSE;

	if (codecid!=GF_CODECID_RAW) {
		gf_mx_p(pid->filter->tasks_mx);
		for (i=0; i<pid->filter->num_input_pids; i++) {
			u32 i_codecid=0, i_type=0;
			GF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);
			if (!pidi->pid) continue;
			p = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_STREAM_TYPE);
			if (p) i_type = p->value.uint;

			p = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_CODECID);
			if (p) i_codecid = p->value.uint;
			//same stream type but changing from raw to not raw: this is an encoder input pid
			if ((mtype==i_type) && (i_codecid==GF_CODECID_RAW)) {
				pidi->is_encoder_input = GF_TRUE;
			}
		}
		gf_mx_v(pid->filter->tasks_mx);
		return;
	}

	//output is a decoded raw stream: if some input has same type but different codecid this is a decoder
	//set input buffer size
	gf_mx_p(pid->filter->tasks_mx);
	for (i=0; i<pid->filter->num_input_pids; i++) {
		u32 i_codecid=0, i_type=0;
		GF_FilterPidInst *pidi = gf_list_get(pid->filter->input_pids, i);
		if (!pidi->pid) continue;

		p = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_STREAM_TYPE);
		if (p) i_type = p->value.uint;

		p = gf_filter_pid_get_property_first(pidi->pid, GF_PROP_PID_CODECID);
		if (p) i_codecid = p->value.uint;

		//same stream type but changing format type: this is a decoder input pid, set buffer req
		if ((mtype==i_type) && (codecid != i_codecid)) {

			buffer_us = pid->filter->pid_decode_buffer_max_us ? pid->filter->pid_decode_buffer_max_us : pid->filter->session->decoder_pid_buffer_max_us;
			//default decoder buffer
			pidi->pid->max_buffer_time = MAX(pidi->pid->user_max_buffer_time, buffer_us);
			pidi->pid->max_buffer_unit = 0;

			//composition buffer
			if (pid->filter->pid_buffer_max_units) {
				pid->max_buffer_unit = pid->filter->pid_buffer_max_units;
			} else if (mtype==GF_STREAM_VISUAL) {
				pid->max_buffer_unit = 4;
			} else if (mtype==GF_STREAM_AUDIO) {
				pid->max_buffer_unit = 20;
			}

			if (!pidi->is_decoder_input) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s pid instance %s marked as decoder input\n",  pidi->pid->filter->name, pidi->pid->name));
				pidi->is_decoder_input = GF_TRUE;
				safe_int_inc(&pidi->pid->nb_decoder_inputs);

				if ((i_type == GF_STREAM_AUDIO) || (i_type == GF_STREAM_VISUAL))
					gf_filter_pid_inst_check_dependencies(pidi);
			}
		}
		//same media type, same codec: raw stream
		else if (mtype==i_type) {
			pid->raw_media = GF_TRUE;
			//special case if single input pid filter, copy buffer props from input
			if (pid->filter->num_input_pids==1) {
				GF_FilterPidInst *pid_in = gf_list_get(pid->filter->input_pids, i);
				if ((pid_in->pid->max_buffer_unit>1) || pid_in->pid->max_buffer_time) {
					pid->max_buffer_unit = pid_in->pid->max_buffer_unit;
					pid->filter->pid_buffer_max_units = pid_in->pid->max_buffer_unit;
					pid->max_buffer_time = pid_in->pid->max_buffer_time;
					pid->filter->pid_buffer_max_us = (u32) pid_in->pid->max_buffer_time;
				}
				//if input has a single destination, reset buffer props to default
				if (pid_in->pid->num_destinations==1) {
					pid_in->pid->max_buffer_unit = 1;
					pid_in->pid->max_buffer_time = 0;
				}
			}
		}
		//input is file, output is not and codec ID is raw, this is a raw media pid
		else if ((i_type==GF_STREAM_FILE) && (mtype!=GF_STREAM_FILE) && (codecid==GF_CODECID_RAW) ) {
			pid->raw_media = GF_TRUE;
		}
	}
	//source pid, mark raw media
	if (!pid->filter->num_input_pids && pid->num_destinations) {
		pid->raw_media = GF_TRUE;
	}
	gf_mx_v(pid->filter->tasks_mx);
}
