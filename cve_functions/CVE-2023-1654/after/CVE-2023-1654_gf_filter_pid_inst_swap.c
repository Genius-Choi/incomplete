static void gf_filter_pid_inst_swap(GF_Filter *filter, GF_FilterPidInst *dst)
{
	GF_PropertyMap *prev_dst_props;
	u32 nb_pck_transfer=0;
	GF_FilterPidInst *src = filter->swap_pidinst_src;
	if (!src) src = filter->swap_pidinst_dst;
	
	if (src) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s swaping PID %s to PID %s\n", filter->name, src->pid->name, dst->pid->name));
	}

	
	if (filter->swap_needs_init) {
		//we are in detach state, the packet queue of the old PID is never read
		assert(filter->swap_pidinst_dst && filter->swap_pidinst_dst->detach_pending);
		//we are in pending state, the origin of the old PID is never dispatching
//		assert(dst->pid && dst->pid->filter && dst->pid->filter->out_pid_connection_pending);
		//we can therefore swap the packet queues safely and other important info
	}
	//otherwise we actually swap the pid instance on the same PID
	else {
		gf_mx_p(dst->pid->filter->tasks_mx);
		if (src)
			gf_list_del_item(dst->pid->destinations, src);
		if (gf_list_find(dst->pid->destinations, dst)<0)
			gf_list_add(dst->pid->destinations, dst);
		dst->pid->num_destinations = gf_list_count(dst->pid->destinations);
		if (gf_list_find(dst->filter->input_pids, dst)<0) {
			gf_list_add(dst->filter->input_pids, dst);
			dst->filter->num_input_pids = gf_list_count(dst->filter->input_pids);

			if (dst->filter->num_input_pids==1) {
				dst->filter->single_source = dst->pid->filter;
			} else if (dst->filter->single_source != dst->pid->filter) {
				dst->filter->single_source = NULL;
			}
		}
		gf_mx_v(dst->pid->filter->tasks_mx);
	}

	if (src) {
		GF_FilterPacketInstance *pcki;
		while (1) {
			pcki = gf_fq_pop(src->packets);
			if (!pcki) break;
			assert(src->filter->pending_packets);
			safe_int_dec(&src->filter->pending_packets);

			if (pcki->pck->info.flags & GF_PCKF_FORCE_MAIN) {
				assert(src->filter->nb_main_thread_forced);
				safe_int_dec(&src->filter->nb_main_thread_forced);
				safe_int_inc(&dst->filter->nb_main_thread_forced);
			}
			pcki->pid = dst;
			gf_fq_add(dst->packets, pcki);
			safe_int_inc(&dst->filter->pending_packets);
			nb_pck_transfer++;
		}
		if (src->requires_full_data_block && gf_list_count(src->pck_reassembly)) {
			dst->requires_full_data_block = src->requires_full_data_block;
			dst->last_block_ended = src->last_block_ended;
			dst->first_block_started = src->first_block_started;
			if (!dst->pck_reassembly) dst->pck_reassembly = gf_list_new();
			while (gf_list_count(src->pck_reassembly)) {
				pcki = gf_list_pop_front(src->pck_reassembly);
				pcki->pid = dst;
				gf_list_add(dst->pck_reassembly, pcki);
			}
		}
		//copy over state
		dst->is_end_of_stream = src->is_end_of_stream;
		dst->nb_eos_signaled = src->nb_eos_signaled;
		dst->buffer_duration = src->buffer_duration;
		dst->nb_clocks_signaled = src->nb_clocks_signaled;

		//switch previous src property map to this new pid (this avoids rewriting props of already dispatched packets)
		//it may happen that we already have props on dest, due to configure of the pid
		//use the old props as new ones and merge the previous props of dst in the new props
		prev_dst_props = dst->props;
		dst->props = src->props;
		dst->force_reconfig = GF_TRUE;
		src->force_reconfig = GF_TRUE;
		src->props = NULL;
		if (prev_dst_props) {
			if (dst->props) {
				gf_props_merge_property(dst->props, prev_dst_props, NULL, NULL);
				assert(prev_dst_props->reference_count);
				if (safe_int_dec(&prev_dst_props->reference_count) == 0) {
					gf_props_del(prev_dst_props);
				}
			} else {
				dst->props = prev_dst_props;
			}
		}

		if (nb_pck_transfer && !dst->filter->process_task_queued) {
			gf_filter_post_process_task(dst->filter);
		}
	}


	src = filter->swap_pidinst_dst;
	if (src) {
		if (filter->swap_needs_init) {
			//exit out special handling of the pid since we are ready to detach
			assert(src->filter->stream_reset_pending);
			safe_int_dec(&src->filter->stream_reset_pending);

			//post detach task, we will reset the swap_pidinst only once truly deconnected from filter
			safe_int_inc(&src->pid->filter->detach_pid_tasks_pending);
			safe_int_inc(&filter->detach_pid_tasks_pending);
			gf_fs_post_task(filter->session, gf_filter_pid_detach_task, src->filter, src->pid, "pidinst_detach", filter);
		} else {
			GF_Filter *src_filter = src->filter;
			assert(!src->filter->sticky);
			assert(src->filter->num_input_pids==1);

			gf_mx_p(src_filter->tasks_mx);
			gf_list_del_item(src_filter->input_pids, src);
			src_filter->num_input_pids = gf_list_count(src_filter->input_pids);
			if (!src_filter->num_input_pids)
				src_filter->single_source = NULL;
			gf_mx_v(src_filter->tasks_mx);

			gf_list_del_item(src->pid->destinations, src);
			src->pid->num_destinations = gf_list_count(src->pid->destinations);
			gf_filter_pid_inst_del(src);

			filter->swap_pidinst_dst = NULL;
			filter->swap_pidinst_src = NULL;
			gf_filter_post_remove(src_filter);
		}
	}
	
	if (filter->swap_pidinst_src) {
		src = filter->swap_pidinst_src;
		assert(!src->filter->swap_pidinst_dst);
		src->filter->swap_pidinst_dst = filter->swap_pidinst_dst;
		src->filter->swap_pending = GF_TRUE;
		gf_fs_post_task(filter->session, gf_filter_pid_inst_swap_delete_task, src->filter, src->pid, "pid_inst_delete", src);
	}
}
