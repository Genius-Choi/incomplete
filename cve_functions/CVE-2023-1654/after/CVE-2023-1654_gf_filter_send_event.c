void gf_filter_send_event(GF_Filter *filter, GF_FilterEvent *evt, Bool upstream)
{
	GF_FilterEvent *an_evt;
	if (!filter) return;
	if (filter->multi_sink_target)
		filter = filter->multi_sink_target;

	//filter is being shut down, prevent any event posting
	if (filter->finalized) return;
	if (!evt) return;
	if ((evt->base.type==GF_FEVT_FILE_DELETE) && !evt->file_del.url) return;

	if (evt->base.type==GF_FEVT_RESET_SCENE)
		return;

	if (evt->base.on_pid && PID_IS_OUTPUT(evt->base.on_pid)) {
		gf_filter_pid_send_event_internal(evt->base.on_pid, evt, GF_FALSE);
		return;
	}

	//switch and seek events are only sent on source filters
	if ((evt->base.type==GF_FEVT_SOURCE_SWITCH) || (evt->base.type==GF_FEVT_SOURCE_SEEK)) {
		if (filter->num_input_pids && !(filter->freg->flags & GF_FS_REG_ACT_AS_SOURCE)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Sending %s event on non source filter %s is not allowed, discarding)\n", gf_filter_event_name(evt->base.type), filter->name));
			return;
		}
	}

	an_evt = init_evt(evt);

	if (evt->base.on_pid) {
		safe_int_inc(&evt->base.on_pid->filter->num_events_queued);
	}
	if (upstream)
		gf_fs_post_task_class(filter->session, gf_filter_pid_send_event_upstream, filter, evt->base.on_pid, "upstream_event", an_evt, TASK_TYPE_EVENT);
	else
		gf_fs_post_task_class(filter->session, gf_filter_pid_send_event_downstream, filter, evt->base.on_pid, "downstream_event", an_evt, TASK_TYPE_EVENT);
}
