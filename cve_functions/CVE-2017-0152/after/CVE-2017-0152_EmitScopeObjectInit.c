void ByteCodeGenerator::EmitScopeObjectInit(FuncInfo *funcInfo)
{
    Assert(!funcInfo->byteCodeFunction->GetFunctionBody()->DoStackNestedFunc());

    if (!funcInfo->GetHasCachedScope() /* || forcing scope/inner func caching */)
    {
        return;
    }

    Scope* currentScope = funcInfo->GetCurrentChildScope();
    uint slotCount = currentScope->GetScopeSlotCount();
    uint cachedFuncCount = 0;
    Js::PropertyId firstFuncSlot = Js::Constants::NoProperty;
    Js::PropertyId firstVarSlot = Js::Constants::NoProperty;
    uint extraAlloc = (slotCount + Js::ActivationObjectEx::ExtraSlotCount()) * sizeof(Js::PropertyId);

    // Create and fill the array of local property ID's.
    // They all have slots assigned to them already (if they need them): see StartEmitFunction.
    
    Js::PropertyIdArray *propIds = funcInfo->GetParsedFunctionBody()->AllocatePropertyIdArrayForFormals(extraAlloc, slotCount, Js::ActivationObjectEx::ExtraSlotCount());
    
    ParseNode *pnodeFnc = funcInfo->root;
    ParseNode *pnode;
    Symbol *sym;

    if (funcInfo->GetFuncExprNameReference() && pnodeFnc->sxFnc.GetFuncSymbol()->GetScope() == funcInfo->GetBodyScope())
    {
        Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.GetFuncSymbol(), propIds, this);
    }

    if (funcInfo->GetHasArguments())
    {
        // Because the arguments object can access all instances of same-named formals ("function(x,x){...}"),
        // be sure we initialize any duplicate appearances of a formal parameter to "NoProperty".
        Js::PropertyId slot = 0;
        auto initArg = [&](ParseNode *pnode)
        {
            if (pnode->IsVarLetOrConst())
            {
                Symbol *sym = pnode->sxVar.sym;
                Assert(sym);
                if (sym->GetScopeSlot() == slot)
                {
                    // This is the last appearance of the formal, so record the ID.
                    Symbol::SaveToPropIdArray(sym, propIds, this);
                }
                else
                {
                    // This is an earlier duplicate appearance of the formal, so use NoProperty as a placeholder
                    // since this slot can't be accessed by name.
                    Assert(sym->GetScopeSlot() != Js::Constants::NoProperty && sym->GetScopeSlot() > slot);
                    propIds->elements[slot] = Js::Constants::NoProperty;
                }
            }
            else
            {
                // This is for patterns
                propIds->elements[slot] = Js::Constants::NoProperty;
            }
            slot++;
        };
        MapFormalsWithoutRest(pnodeFnc, initArg);

        // If the rest is in the slot - we need to keep that slot.
        if (pnodeFnc->sxFnc.pnodeRest != nullptr && pnodeFnc->sxFnc.pnodeRest->sxVar.sym->IsInSlot(funcInfo))
        {
            Symbol::SaveToPropIdArray(pnodeFnc->sxFnc.pnodeRest->sxVar.sym, propIds, this);
        }
    }
    else
    {
        MapFormals(pnodeFnc, [&](ParseNode *pnode)
        {
            if (pnode->IsVarLetOrConst())
            {
                Symbol::SaveToPropIdArray(pnode->sxVar.sym, propIds, this);
            }
        });
    }

    auto saveFunctionVarsToPropIdArray = [&](ParseNode *pnodeFunction)
    {
        if (pnodeFunction->sxFnc.IsDeclaration())
        {
            ParseNode *pnodeName = pnodeFunction->sxFnc.pnodeName;
            if (pnodeName != nullptr)
            {
                while (pnodeName->nop == knopList)
                {
                    if (pnodeName->sxBin.pnode1->nop == knopVarDecl)
                    {
                        sym = pnodeName->sxBin.pnode1->sxVar.sym;
                        if (sym)
                        {
                            Symbol::SaveToPropIdArray(sym, propIds, this, &firstFuncSlot);
                        }
                    }
                    pnodeName = pnodeName->sxBin.pnode2;
                }
                if (pnodeName->nop == knopVarDecl)
                {
                    sym = pnodeName->sxVar.sym;
                    if (sym)
                    {
                        Symbol::SaveToPropIdArray(sym, propIds, this, &firstFuncSlot);
                        cachedFuncCount++;
                    }
                }
            }
        }
    };
    MapContainerScopeFunctions(pnodeFnc, saveFunctionVarsToPropIdArray);

    if (currentScope->GetScopeType() != ScopeType_Parameter)
    {
        for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)
        {
            sym = pnode->sxVar.sym;
            if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))
            {
                if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))
                {
                    sym = currentScope->FindLocalSymbol(sym->GetName());
                }
                Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);
            }
        }

        ParseNode *pnodeBlock = pnodeFnc->sxFnc.pnodeScopes;
        for (pnode = pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)
        {
            sym = pnode->sxVar.sym;
            Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);
        }

        pnodeBlock = pnodeFnc->sxFnc.pnodeBodyScope;
        for (pnode = pnodeBlock->sxBlock.pnodeLexVars; pnode; pnode = pnode->sxVar.pnodeNext)
        {
            sym = pnode->sxVar.sym;
            Symbol::SaveToPropIdArray(sym, propIds, this, &firstVarSlot);
        }
    }
    else
    {
        Assert(!currentScope->GetCanMergeWithBodyScope());
    }

    if (funcInfo->thisScopeSlot != Js::Constants::NoRegister)
    {
        propIds->elements[funcInfo->thisScopeSlot] = Js::PropertyIds::_lexicalThisSlotSymbol;
    }
    if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister)
    {
        propIds->elements[funcInfo->newTargetScopeSlot] = Js::PropertyIds::_lexicalNewTargetSymbol;
    }
    if (funcInfo->superScopeSlot != Js::Constants::NoRegister)
    {
        propIds->elements[funcInfo->superScopeSlot] = Js::PropertyIds::_superReferenceSymbol;
    }
    if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)
    {
        propIds->elements[funcInfo->superCtorScopeSlot] = Js::PropertyIds::_superCtorReferenceSymbol;
    }

    // Write the first func slot and first var slot into the auxiliary data
    Js::PropertyId *slots = propIds->elements + slotCount;
    slots[0] = cachedFuncCount;
    slots[1] = firstFuncSlot;
    slots[2] = firstVarSlot;
    slots[3] = funcInfo->GetParsedFunctionBody()->NewObjectLiteral();

    propIds->hasNonSimpleParams = funcInfo->root->sxFnc.HasNonSimpleParameterList();
    
    funcInfo->GetParsedFunctionBody()->SetHasCachedScopePropIds(true);
}
