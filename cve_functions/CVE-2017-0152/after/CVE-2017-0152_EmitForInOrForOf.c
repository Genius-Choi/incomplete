void EmitForInOrForOf(ParseNode *loopNode, ByteCodeGenerator *byteCodeGenerator, FuncInfo *funcInfo, BOOL fReturnValue)
{
    bool isForIn = (loopNode->nop == knopForIn);
    Assert(isForIn || loopNode->nop == knopForOf);

    BeginEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);

    byteCodeGenerator->StartStatement(loopNode);
    if (!isForIn)
    {
        funcInfo->AcquireLoc(loopNode);
    }

    // Record the branch bytecode offset.
    // This is used for "ignore exception" and "set next stmt" scenarios. See ProbeContainer::GetNextUserStatementOffsetForAdvance:
    // If there is a branch recorded between current offset and next stmt offset, we'll use offset of the branch recorded,
    // otherwise use offset of next stmt.
    // The idea here is that when we bail out after ignore exception, we need to bail out to the beginning of the ForIn,
    // but currently ForIn stmt starts at the condition part, which is needed for correct handling of break point on ForIn
    // (break every time on the loop back edge) and correct display of current statement under debugger.
    // See WinBlue 231880 for details.
    byteCodeGenerator->Writer()->RecordStatementAdjustment(Js::FunctionBody::SAT_All);
    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled() &&
        loopNode->sxForInOrForOf.pnodeBlock->sxBlock.HasBlockScopedContent())
    {
        byteCodeGenerator->Writer()->RecordForInOrOfCollectionScope();
    }
    Js::ByteCodeLabel loopEntrance = byteCodeGenerator->Writer()->DefineLabel();
    Js::ByteCodeLabel continuePastLoop = byteCodeGenerator->Writer()->DefineLabel();

    if (loopNode->sxForInOrForOf.pnodeLval->nop == knopVarDecl)
    {
        EmitReference(loopNode->sxForInOrForOf.pnodeLval, byteCodeGenerator, funcInfo);
    }

    Emit(loopNode->sxForInOrForOf.pnodeObj, byteCodeGenerator, funcInfo, false); // evaluate collection expression
    funcInfo->ReleaseLoc(loopNode->sxForInOrForOf.pnodeObj);

    if (byteCodeGenerator->IsES6ForLoopSemanticsEnabled())
    {
        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);
        if (loopNode->sxForInOrForOf.pnodeBlock->sxBlock.scope != nullptr)
        {
            loopNode->sxForInOrForOf.pnodeBlock->sxBlock.scope->ForEachSymbol([](Symbol *sym) {
                sym->SetIsTrackedForDebugger(false);
            });
        }
    }

    if (isForIn)
    {
        EmitForIn(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);

        if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())
        {
            EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);
        }

        return;
    }

    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();
    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrNeq_A, skipThrow, loopNode->sxForInOrForOf.pnodeObj->location, funcInfo->undefinedConstantRegister);
    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_ObjectCoercible));
    byteCodeGenerator->Writer()->MarkLabel(skipThrow);

    Js::RegSlot regException = Js::Constants::NoRegister;
    Js::RegSlot regOffset = Js::Constants::NoRegister;

    // These two temp variables store the information of return function to be called or not.
    // one variable is used for catch block and one is used for finally block. These variable will be set to true when we think that return function
    // to be called on abrupt loop break. 
    // Why two variables? since these are temps and JIT does like not flow if single variable is used in multiple blocks.
    Js::RegSlot shouldCallReturnFunctionLocation = funcInfo->AcquireTmpRegister();
    Js::RegSlot shouldCallReturnFunctionLocationFinally = funcInfo->AcquireTmpRegister();

    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();

    if (isCoroutine)
    {
        regException = funcInfo->AcquireTmpRegister();
        regOffset = funcInfo->AcquireTmpRegister();
    }

    // Grab registers for the enumerator and for the current enumerated item.
    // The enumerator register will be released after this call returns.
    loopNode->sxForInOrForOf.itemLocation = funcInfo->AcquireTmpRegister();

    // We want call profile information on the @@iterator call, so instead of adding a GetForOfIterator bytecode op
    // to do all the following work in a helper do it explicitly in bytecode so that the @@iterator call is exposed
    // to the profiler and JIT.

    byteCodeGenerator->SetHasFinally(true);
    byteCodeGenerator->SetHasTry(true);
    byteCodeGenerator->TopFuncInfo()->byteCodeFunction->SetDontInline(true);

    // do a ToObject on the collection
    Js::RegSlot tmpObj = funcInfo->AcquireTmpRegister();
    byteCodeGenerator->Writer()->Reg2(Js::OpCode::Conv_Obj, tmpObj, loopNode->sxForInOrForOf.pnodeObj->location);

    EmitGetIterator(loopNode->location, tmpObj, byteCodeGenerator, funcInfo);
    funcInfo->ReleaseTmpRegister(tmpObj);

    // The whole loop is surrounded with try..catch..finally - in order to capture the abrupt completion.
    Js::ByteCodeLabel finallyLabel = byteCodeGenerator->Writer()->DefineLabel();
    Js::ByteCodeLabel catchLabel = byteCodeGenerator->Writer()->DefineLabel();
    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);

    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);
    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);

    ByteCodeGenerator::TryScopeRecord tryRecForTryFinally(Js::OpCode::TryFinallyWithYield, finallyLabel);

    if (isCoroutine)
    {
        byteCodeGenerator->Writer()->BrReg2(Js::OpCode::TryFinallyWithYield, finallyLabel, regException, regOffset);
        tryRecForTryFinally.reg1 = regException;
        tryRecForTryFinally.reg2 = regOffset;
        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTryFinally);
    }
    else
    {
        byteCodeGenerator->Writer()->Br(Js::OpCode::TryFinally, finallyLabel);
    }

    byteCodeGenerator->Writer()->Br(Js::OpCode::TryCatch, catchLabel);

    ByteCodeGenerator::TryScopeRecord tryRecForTry(Js::OpCode::TryCatch, catchLabel);
    if (isCoroutine)
    {
        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForTry);
    }

    byteCodeGenerator->EndStatement(loopNode);

    // Need to increment loop count whether we are going into profile or not for HasLoop()
    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);
    loopNode->sxForInOrForOf.loopId = loopId;

    byteCodeGenerator->StartStatement(loopNode->sxForInOrForOf.pnodeLval);

    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocation);
    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnFunctionLocationFinally);

    EmitIteratorNext(loopNode->sxForInOrForOf.itemLocation, loopNode->location, Js::Constants::NoRegister, byteCodeGenerator, funcInfo);

    Js::RegSlot doneLocation = funcInfo->AcquireTmpRegister();
    EmitIteratorComplete(doneLocation, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);

    // branch past loop if the result's done property is truthy
    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrTrue_A, continuePastLoop, doneLocation);
    funcInfo->ReleaseTmpRegister(doneLocation);

    // otherwise put result's value property in itemLocation
    EmitIteratorValue(loopNode->sxForInOrForOf.itemLocation, loopNode->sxForInOrForOf.itemLocation, byteCodeGenerator, funcInfo);

    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocation);
    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdTrue, shouldCallReturnFunctionLocationFinally);

    EmitForInOfLoopBody(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);

    byteCodeGenerator->Writer()->ExitLoop(loopId);

    EmitCatchAndFinallyBlocks(catchLabel,
        finallyLabel,
        loopNode->location,
        shouldCallReturnFunctionLocation,
        shouldCallReturnFunctionLocationFinally,
        regException,
        regOffset,
        byteCodeGenerator,
        funcInfo);

    if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())
    {
        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);
    }
}
