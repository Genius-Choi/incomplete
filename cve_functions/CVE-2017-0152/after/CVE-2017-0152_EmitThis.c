void ByteCodeGenerator::EmitThis(FuncInfo *funcInfo, Js::RegSlot fromRegister)
{
    if (funcInfo->IsLambda())
    {
        Scope *scope;
        Js::PropertyId envIndex = -1;
        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);
        FuncInfo* parent = scope->GetFunc();

        if (parent->IsGlobalFunction())
        {
            if (this->flags & fscrEval)
            {
                scope = parent->GetGlobalEvalBlockScope();
                Js::PropertyId slot = parent->thisScopeSlot;
                EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->thisPointerRegister, false);
            }
            else
            {
                // Always load global object via LdThis of null to get the possibly protected via secureHostObject global object.
                this->m_writer.Reg2Int1(Js::OpCode::LdThis, funcInfo->thisPointerRegister, funcInfo->nullConstantRegister, this->GetModuleID());
            }
        }
        else if (!parent->IsClassConstructor() || parent->IsBaseClassConstructor())
        {
            // In a lambda inside a derived class constructor, 'this' should be loaded from the scope slot whenever 'this' is accessed.
            // It's safe to load 'this' into the register for base class constructors because there is no complex assignment to 'this'
            // via super call chain.
            Js::PropertyId slot = parent->thisScopeSlot;
            EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->thisPointerRegister, false);
        }
    }
    else if (funcInfo->byteCodeFunction->GetIsStrictMode() && (!funcInfo->IsGlobalFunction() || this->flags & fscrEval))
    {
        m_writer.Reg2(Js::OpCode::StrictLdThis, funcInfo->thisPointerRegister, fromRegister);
    }
    else
    {
        m_writer.Reg2Int1(Js::OpCode::LdThis, funcInfo->thisPointerRegister, fromRegister, this->GetModuleID());
    }
}
