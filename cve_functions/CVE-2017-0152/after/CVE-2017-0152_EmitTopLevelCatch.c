void EmitTopLevelCatch(Js::ByteCodeLabel catchLabel,
    Js::RegSlot iteratorLocation,
    Js::RegSlot shouldCallReturnLocation,
    Js::RegSlot shouldCallReturnLocationFinally,
    ByteCodeGenerator *byteCodeGenerator,
    FuncInfo *funcInfo)
{
    Js::ByteCodeLabel afterCatchBlockLabel = byteCodeGenerator->Writer()->DefineLabel();
    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);
    byteCodeGenerator->Writer()->Br(afterCatchBlockLabel);
    byteCodeGenerator->Writer()->MarkLabel(catchLabel);

    Js::RegSlot catchParamLocation = funcInfo->AcquireTmpRegister();
    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Catch, catchParamLocation);

    ByteCodeGenerator::TryScopeRecord tryRecForCatch(Js::OpCode::ResumeCatch, catchLabel);
    if (funcInfo->byteCodeFunction->IsCoroutine())
    {
        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForCatch);
    }

    Js::ByteCodeLabel skipCallCloseLabel = byteCodeGenerator->Writer()->DefineLabel();

    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, skipCallCloseLabel, shouldCallReturnLocation);
    byteCodeGenerator->Writer()->Reg1(Js::OpCode::LdFalse, shouldCallReturnLocationFinally);
    EmitTryCatchAroundClose(iteratorLocation, skipCallCloseLabel, byteCodeGenerator, funcInfo);

    byteCodeGenerator->Writer()->MarkLabel(skipCallCloseLabel);

    // Rethrow the exception.
    byteCodeGenerator->Writer()->Reg1(Js::OpCode::Throw, catchParamLocation);

    funcInfo->ReleaseTmpRegister(catchParamLocation);

    if (funcInfo->byteCodeFunction->IsCoroutine())
    {
        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();
    }

    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);
    byteCodeGenerator->Writer()->MarkLabel(afterCatchBlockLabel);
}
