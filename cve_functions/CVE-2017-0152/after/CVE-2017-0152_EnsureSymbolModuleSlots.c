bool ByteCodeGenerator::EnsureSymbolModuleSlots(Symbol* sym, FuncInfo* funcInfo)
{
    Assert(sym->GetIsModuleExportStorage());

    if (sym->GetModuleIndex() != Js::Constants::NoProperty && sym->GetScopeSlot() != Js::Constants::NoProperty)
    {
        return true;
    }

    Js::JavascriptLibrary* library = this->GetScriptContext()->GetLibrary();
    library->EnsureModuleRecordList();
    uint moduleIndex = this->GetModuleID();
    uint moduleSlotIndex;
    Js::SourceTextModuleRecord* moduleRecord = library->GetModuleRecord(moduleIndex);

    if (sym->GetIsModuleImport())
    {
        Js::PropertyId localImportNameId = sym->EnsurePosition(funcInfo);
        Js::ModuleNameRecord* moduleNameRecord = nullptr;
        if (!moduleRecord->ResolveImport(localImportNameId, &moduleNameRecord))
        {
            return false;
        }

        AnalysisAssert(moduleNameRecord != nullptr);
        Assert(moduleNameRecord->module->IsSourceTextModuleRecord());
        Js::SourceTextModuleRecord* resolvedModuleRecord = (Js::SourceTextModuleRecord*)moduleNameRecord->module;

        moduleIndex = resolvedModuleRecord->GetModuleId();
        moduleSlotIndex = resolvedModuleRecord->GetLocalExportSlotIndexByLocalName(moduleNameRecord->bindingName);
    }
    else
    {
        Js::PropertyId exportNameId = sym->EnsurePosition(funcInfo);
        moduleSlotIndex = moduleRecord->GetLocalExportSlotIndexByLocalName(exportNameId);
    }

    sym->SetModuleIndex(moduleIndex);
    sym->SetScopeSlot(moduleSlotIndex);

    return true;
}
