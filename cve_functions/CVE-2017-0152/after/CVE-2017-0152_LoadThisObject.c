void ByteCodeGenerator::LoadThisObject(FuncInfo *funcInfo, bool thisLoadedFromParams)
{
    if (this->scriptContext->GetConfig()->IsES6ClassAndExtendsEnabled() && funcInfo->IsClassConstructor())
    {
        // Derived class constructors initialize 'this' to be Undecl except "extends null" cases
        //   - we'll check this value during a super call and during 'this' access
        //
        // Base class constructors or "extends null" cases initialize 'this' to a new object using new.target
        if (funcInfo->IsBaseClassConstructor())
        {
            EmitBaseClassConstructorThisObject(funcInfo);
        }
        else
        {
            Js::ByteCodeLabel thisLabel = this->Writer()->DefineLabel();
            Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();

            Js::RegSlot tmpReg = funcInfo->AcquireTmpRegister();
            this->Writer()->Reg1(Js::OpCode::LdFuncObj, tmpReg);
            this->Writer()->BrReg1(Js::OpCode::BrOnBaseConstructorKind, thisLabel, tmpReg);  // branch when [[ConstructorKind]]=="base"
            funcInfo->ReleaseTmpRegister(tmpReg);

            this->m_writer.Reg1(Js::OpCode::InitUndecl, funcInfo->thisPointerRegister);  // not "extends null" case
            this->Writer()->Br(Js::OpCode::Br, skipLabel);

            this->Writer()->MarkLabel(thisLabel);
            EmitBaseClassConstructorThisObject(funcInfo);  // "extends null" case

            this->Writer()->MarkLabel(skipLabel);
        }
    }
    else if (!funcInfo->IsGlobalFunction() || (this->flags & fscrEval))
    {
        //
        // thisLoadedFromParams would be true for the event Handler case,
        // "this" would have been loaded from parameters to put in the environment
        //
        if (!thisLoadedFromParams && !funcInfo->IsLambda())
        {
            m_writer.ArgIn0(funcInfo->thisPointerRegister);
        }
        if (!(this->flags & fscrEval) || !funcInfo->IsGlobalFunction())
        {
            // we don't want to emit 'this' for eval, because 'this' value in eval is equal to 'this' value of caller
            // and does not depend on "use strict" inside of eval.
            // so we pass 'this' directly in GlobalObject::EntryEval()
            EmitThis(funcInfo, funcInfo->thisPointerRegister);
        }
    }
    else
    {
        Assert(funcInfo->IsGlobalFunction());
        Js::RegSlot root = funcInfo->nullConstantRegister;
        EmitThis(funcInfo, root);
    }
}
