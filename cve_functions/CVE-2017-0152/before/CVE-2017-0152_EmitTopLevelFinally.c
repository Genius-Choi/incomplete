void EmitTopLevelFinally(Js::ByteCodeLabel finallyLabel,
    Js::RegSlot iteratorLocation,
    Js::RegSlot shouldCallReturnLocation,
    Js::RegSlot yieldExceptionLocation,
    Js::RegSlot yieldOffsetLocation,
    ByteCodeGenerator *byteCodeGenerator,
    FuncInfo *funcInfo)
{
    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();

    Js::ByteCodeLabel afterFinallyBlockLabel = byteCodeGenerator->Writer()->DefineLabel();
    byteCodeGenerator->Writer()->Empty(Js::OpCode::Leave);

    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);
    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(true);

    byteCodeGenerator->Writer()->Br(afterFinallyBlockLabel);
    byteCodeGenerator->Writer()->MarkLabel(finallyLabel);

    ByteCodeGenerator::TryScopeRecord tryRecForFinally(Js::OpCode::ResumeFinally, finallyLabel, yieldExceptionLocation, yieldOffsetLocation);
    if (isCoroutine)
    {
        byteCodeGenerator->tryScopeRecordsList.LinkToEnd(&tryRecForFinally);
    }

    Js::ByteCodeLabel skipCallCloseLabel = byteCodeGenerator->Writer()->DefineLabel();

    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrFalse_A, skipCallCloseLabel, shouldCallReturnLocation);
    EmitIteratorClose(iteratorLocation, byteCodeGenerator, funcInfo);

    byteCodeGenerator->Writer()->MarkLabel(skipCallCloseLabel);

    if (isCoroutine)
    {
        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();
        funcInfo->ReleaseTmpRegister(yieldOffsetLocation);
        funcInfo->ReleaseTmpRegister(yieldExceptionLocation);
    }

    byteCodeGenerator->Writer()->RecordCrossFrameEntryExitRecord(false);
    byteCodeGenerator->Writer()->Empty(Js::OpCode::LeaveNull);
    byteCodeGenerator->Writer()->MarkLabel(afterFinallyBlockLabel);
}
