void EmitForIn(ParseNode *loopNode,
    Js::ByteCodeLabel loopEntrance,
    Js::ByteCodeLabel continuePastLoop,
    ByteCodeGenerator *byteCodeGenerator,
    FuncInfo *funcInfo,
    BOOL fReturnValue)
{
    Assert(loopNode->nop == knopForIn);
    Assert(loopNode->location == Js::Constants::NoRegister);

    // Grab registers for the enumerator and for the current enumerated item.
    // The enumerator register will be released after this call returns.
    loopNode->sxForInOrForOf.itemLocation = funcInfo->AcquireTmpRegister();

    uint forInLoopLevel = funcInfo->AcquireForInLoopLevel();

    // get enumerator from the collection
    byteCodeGenerator->Writer()->Reg1Unsigned1(Js::OpCode::InitForInEnumerator, loopNode->sxForInOrForOf.pnodeObj->location, forInLoopLevel);

    // The StartStatement is already done in the caller of the current function, which is EmitForInOrForOf
    byteCodeGenerator->EndStatement(loopNode);

    // Need to increment loop count whether we are going into profile or not for HasLoop()
    uint loopId = byteCodeGenerator->Writer()->EnterLoop(loopEntrance);
    loopNode->sxForInOrForOf.loopId = loopId;

    // The EndStatement will happen in the EmitForInOfLoopBody function
    byteCodeGenerator->StartStatement(loopNode->sxForInOrForOf.pnodeLval);

    // branch past loop when MoveAndGetNext returns nullptr
    byteCodeGenerator->Writer()->BrReg1Unsigned1(Js::OpCode::BrOnEmpty, continuePastLoop, loopNode->sxForInOrForOf.itemLocation, forInLoopLevel);
    
    EmitForInOfLoopBody(loopNode, loopEntrance, continuePastLoop, byteCodeGenerator, funcInfo, fReturnValue);

    byteCodeGenerator->Writer()->ExitLoop(loopId);

    funcInfo->ReleaseForInLoopLevel(forInLoopLevel);

    if (!byteCodeGenerator->IsES6ForLoopSemanticsEnabled())
    {
        EndEmitBlock(loopNode->sxForInOrForOf.pnodeBlock, byteCodeGenerator, funcInfo);
    }
}
