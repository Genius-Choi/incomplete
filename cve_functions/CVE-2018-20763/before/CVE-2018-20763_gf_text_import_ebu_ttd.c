static GF_Err gf_text_import_ebu_ttd(GF_MediaImporter *import, GF_DOMParser *parser, GF_XMLNode *root)
{
	GF_Err e, e_opt;
	u32 i, track, ID, desc_idx, nb_samples, nb_children;
	u64 last_sample_duration, last_sample_end;
	GF_XMLAttribute *att;
	GF_XMLNode *node, *root_working_copy, *sample_list_node;
	GF_DOMParser *parser_working_copy;
	char *samp_text;
	Bool has_body;

	samp_text = NULL;
	root_working_copy = NULL;
	parser_working_copy = NULL;

	/*setup track in 3GP format directly (no ES desc)*/
	ID = (import->esd) ? import->esd->ESID : 0;
	track = gf_isom_new_track(import->dest, ID, GF_ISOM_MEDIA_MPEG_SUBT, 1000);
	if (!track) {
		e = gf_isom_last_error(import->dest);
		goto exit;
	}
	gf_isom_set_track_enabled(import->dest, track, 1);

	/*some MPEG-4 setup*/
	if (import->esd) {
		if (!import->esd->ESID) import->esd->ESID = gf_isom_get_track_id(import->dest, track);
		if (!import->esd->decoderConfig) import->esd->decoderConfig = (GF_DecoderConfig *) gf_odf_desc_new(GF_ODF_DCD_TAG);
		if (!import->esd->slConfig) import->esd->slConfig = (GF_SLConfig *) gf_odf_desc_new(GF_ODF_SLC_TAG);
		import->esd->slConfig->timestampResolution = 1000;
		import->esd->decoderConfig->streamType = GF_STREAM_TEXT;
		import->esd->decoderConfig->objectTypeIndication = GPAC_OTI_TEXT_MPEG4;
		if (import->esd->OCRESID) gf_isom_set_track_reference(import->dest, track, GF_ISOM_REF_OCR, import->esd->OCRESID);
	}

	gf_import_message(import, GF_OK, "TTML EBU-TTD Import");

	/*** root (including language) ***/
	i=0;
	while ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("Found root attribute name %s, value %s\n", att->name, att->value));

		if (!strcmp(att->name, "xmlns")) {
			if (strcmp(att->value, TTML_NAMESPACE)) {
				e = gf_import_message(import, GF_BAD_PARAM, "Found invalid EBU-TTD root attribute name %s, value %s (shall be \"%s\")\n", att->name, att->value, TTML_NAMESPACE);
				goto exit;
			}
		} else if (!strcmp(att->name, "xml:lang")) {
			if (import->esd && !import->esd->langDesc) {
				char *lang;
				lang = gf_strdup(att->value);
				import->esd->langDesc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);
				gf_isom_set_media_language(import->dest, track, lang);
			} else {
				gf_isom_set_media_language(import->dest, track, att->value);
			}
		}
	}

	/*** style ***/
#if 0
	{
		Bool has_styling, has_style;
		GF_TextSampleDescriptor *sd;
		has_styling = GF_FALSE;
		has_style = GF_FALSE;
		sd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);
		i=0;
		while ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {
			if (node->type) {
				continue;
			} else if (gf_xml_get_element_check_namespace(node, "head", root->ns) == GF_OK) {
				GF_XMLNode *head_node;
				u32 head_idx = 0;
				while ( (head_node = (GF_XMLNode*)gf_list_enum(node->content, &head_idx))) {
					if (gf_xml_get_element_check_namespace(head_node, "styling", root->ns) == GF_OK) {
						GF_XMLNode *styling_node;
						u32 styling_idx;
						if (has_styling) {
							e = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] duplicated \"styling\" element. Abort.\n");
							goto exit;
						}
						has_styling = GF_TRUE;

						styling_idx = 0;
						while ( (styling_node = (GF_XMLNode*)gf_list_enum(head_node->content, &styling_idx))) {
							if (gf_xml_get_element_check_namespace(styling_node, "style", root->ns) == GF_OK) {
								GF_XMLAttribute *p_att;
								u32 style_idx = 0;
								while ( (p_att = (GF_XMLAttribute*)gf_list_enum(styling_node->attributes, &style_idx))) {
									if (!strcmp(p_att->name, "tts:direction")) {
									} else if (!strcmp(p_att->name, "tts:fontFamily")) {
										sd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));
										sd->font_count = 1;
										sd->fonts[0].fontID = 1;
										sd->fonts[0].fontName = gf_strdup(p_att->value);
									} else if (!strcmp(p_att->name, "tts:backgroundColor")) {
										GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ("EBU-TTD style attribute \"%s\" ignored.\n", p_att->name));
										//sd->back_color = ;
									} else {
										if ( !strcmp(p_att->name, "tts:fontSize")
										        || !strcmp(p_att->name, "tts:lineHeight")
										        || !strcmp(p_att->name, "tts:textAlign")
										        || !strcmp(p_att->name, "tts:color")
										        || !strcmp(p_att->name, "tts:fontStyle")
										        || !strcmp(p_att->name, "tts:fontWeight")
										        || !strcmp(p_att->name, "tts:textDecoration")
										        || !strcmp(p_att->name, "tts:unicodeBidi")
										        || !strcmp(p_att->name, "tts:wrapOption")
										        || !strcmp(p_att->name, "tts:multiRowAlign")
										        || !strcmp(p_att->name, "tts:linePadding")) {
											GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ("EBU-TTD style attribute \"%s\" ignored.\n", p_att->name));
										} else {
											GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("EBU-TTD unknown style attribute: \"%s\". Ignoring.\n", p_att->name));
										}
									}
								}
								break; //TODO: we only take care of the first style
							}
						}
					}
				}
			}
		}
		if (!has_styling) {
			e = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] missing \"styling\" element. Abort.\n");
			goto exit;
		}
		if (!has_style) {
			e = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] missing \"style\" element. Abort.\n");
			goto exit;
		}
		e = gf_isom_new_text_description(import->dest, track, sd, NULL, NULL, &desc_idx);
		gf_odf_desc_del((GF_Descriptor*)sd);
	}
#else
	e = gf_isom_new_xml_subtitle_description(import->dest, track, TTML_NAMESPACE, NULL, NULL, &desc_idx);
#endif
	if (e != GF_OK) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] incorrect sample description. Abort.\n"));
		e = gf_isom_last_error(import->dest);
		goto exit;
	}

	/*** body ***/
	parser_working_copy = gf_xml_dom_new();
	e = gf_xml_dom_parse(parser_working_copy, import->in_name, NULL, NULL);
	assert (e == GF_OK);
	root_working_copy = gf_xml_dom_get_root(parser_working_copy);
	assert(root_working_copy);
	last_sample_duration = 0;
	last_sample_end = 0;
	nb_samples = 0;
	nb_children = gf_list_count(root->content);
	has_body = GF_FALSE;
	i=0;
	while ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {
		if (node->type) {
			nb_children--;
			continue;
		}

		e_opt = gf_xml_get_element_check_namespace(node, "body", root->ns);
		if (e_opt == GF_BAD_PARAM) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] ignored \"%s\" node, check your namespaces\n", node->name));
		} else if (e_opt == GF_OK) {
			GF_XMLNode *body_node;
			u32 body_idx = 0;

			if (has_body) {
				e = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] duplicated \"body\" element. Abort.\n");
				goto exit;
			}
			has_body = GF_TRUE;

			/*remove all the entries from the working copy, we'll add samples one to one to create full XML samples*/
			gf_text_import_ebu_ttd_remove_samples(root_working_copy, &sample_list_node);

			while ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {
				e_opt = gf_xml_get_element_check_namespace(body_node, "div", root->ns);
				if (e_opt == GF_BAD_PARAM) {
					GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] ignored \"%s\" node, check your namespaces\n", node->name));
				} else if (e_opt == GF_OK) {
					GF_XMLNode *div_node;
					u32 div_idx = 0, nb_p_found = 0;
					while ( (div_node = (GF_XMLNode*)gf_list_enum(body_node->content, &div_idx))) {
						e_opt = gf_xml_get_element_check_namespace(div_node, "p", root->ns);
						if (e_opt != GF_OK) {
							GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML] ignored \"%s\" node, check your namespaces\n", node->name));
						} else if (e_opt == GF_OK) {
							GF_XMLNode *p_node;
							GF_XMLAttribute *p_att;
							u32 p_idx = 0, h, m, s, f, ms;
							s64 ts_begin = -1, ts_end = -1;

							//sample is either in the <p> ...
							while ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_node->attributes, &p_idx))) {
								if (!p_att) continue;
								
								if (!strcmp(p_att->name, "begin")) {
									if (ts_begin != -1) {
										e = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"begin\" attribute. Abort.\n");
										goto exit;
									}
									if (sscanf(p_att->value, "%u:%u:%u.%u", &h, &m, &s, &ms) == 4) {
										ts_begin = (h*3600 + m*60+s)*1000+ms;
									} else if (sscanf(p_att->value, "%u:%u:%u:%u", &h, &m, &s, &f) == 4) {
										ts_begin = (h*3600 + m*60+s)*1000+f*40;
									} else if (sscanf(p_att->value, "%u:%u:%u", &h, &m, &s) == 3) {
										ts_begin = (h*3600 + m*60+s)*1000;
									}
								} else if (!strcmp(p_att->name, "end")) {
									if (ts_end != -1) {
										e = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"end\" attribute. Abort.\n");
										goto exit;
									}
									if (sscanf(p_att->value, "%u:%u:%u.%u", &h, &m, &s, &ms) == 4) {
										ts_end = (h*3600 + m*60+s)*1000+ms;
									} else if (sscanf(p_att->value, "%u:%u:%u:%u", &h, &m, &s, &f) == 4) {
										ts_end = (h*3600 + m*60+s)*1000+f*40;
									} else if (sscanf(p_att->value, "%u:%u:%u", &h, &m, &s) == 3) {
										ts_end = (h*3600 + m*60+s)*1000;
									}
								}
								if ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {
									e = gf_xml_dom_append_child(sample_list_node, div_node);
									assert(e == GF_OK);
									assert(!samp_text);
									samp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);
									e = gf_xml_dom_rem_child(sample_list_node, div_node);
									assert(e == GF_OK);
								}
							}

							//or under a <span>
							p_idx = 0;
							while ( (p_node = (GF_XMLNode*)gf_list_enum(div_node->content, &p_idx))) {
								e_opt = gf_xml_get_element_check_namespace(p_node, "span", root->ns);
								if (e_opt == GF_BAD_PARAM) {
									GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML] ignored \"%s\" node, check your namespaces\n", node->name));
								} else if (e_opt == GF_OK) {
									u32 span_idx = 0;
									GF_XMLAttribute *span_att;
									while ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {
										if (!span_att) continue;
									
										if (!strcmp(span_att->name, "begin")) {
											if (ts_begin != -1) {
												e = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"begin\" attribute under <span>. Abort.\n");
												goto exit;
											}
											if (sscanf(span_att->value, "%u:%u:%u.%u", &h, &m, &s, &ms) == 4) {
												ts_begin = (h*3600 + m*60+s)*1000+ms;
											} else if (sscanf(p_att->value, "%u:%u:%u:%u", &h, &m, &s, &f) == 4) {
												ts_begin = (h*3600 + m*60+s)*1000+f*40;
											} else if (sscanf(span_att->value, "%u:%u:%u", &h, &m, &s) == 3) {
												ts_begin = (h*3600 + m*60+s)*1000;
											}
										} else if (!strcmp(span_att->name, "end")) {
											if (ts_end != -1) {
												e = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated \"end\" attribute under <span>. Abort.\n");
												goto exit;
											}
											if (sscanf(span_att->value, "%u:%u:%u.%u", &h, &m, &s, &ms) == 4) {
												ts_end = (h*3600 + m*60+s)*1000+ms;
											} else if (sscanf(p_att->value, "%u:%u:%u:%u", &h, &m, &s, &f) == 4) {
												ts_end = (h*3600 + m*60+s)*1000+f*40;
											} else if (sscanf(span_att->value, "%u:%u:%u", &h, &m, &s) == 3) {
												ts_end = (h*3600 + m*60+s)*1000;
											}
										}
										if ((ts_begin != -1) && (ts_end != -1) && !samp_text && sample_list_node) {
											if (samp_text) {
												e = gf_import_message(import, GF_BAD_PARAM, "[TTML] duplicated sample text under <span>. Abort.\n");
												goto exit;
											}

											/*append the sample*/
											e = gf_xml_dom_append_child(sample_list_node, div_node);
											assert(e == GF_OK);
											assert(!samp_text);
											samp_text = gf_xml_dom_serialize((GF_XMLNode*)root_working_copy, GF_FALSE);
											e = gf_xml_dom_rem_child(sample_list_node, div_node);
											assert(e == GF_OK);
										}
									}
								}
							}

							if ((ts_begin != -1) && (ts_end != -1) && samp_text) {
								GF_ISOSample *s;
								GF_GenericSubtitleSample *samp;
								u32 len;
								char *str;

								if (ts_end < ts_begin) {
									e = gf_import_message(import, GF_BAD_PARAM, "[TTML] invalid timings: \"begin\"="LLD" , \"end\"="LLD". Abort.\n", ts_begin, ts_end);
									goto exit;
								}

								if (ts_begin < (s64)last_sample_end) {
									e = gf_import_message(import, GF_BAD_PARAM, "[TTML] timing overlapping not supported: \"begin\" is "LLD" , last \"end\" was "LLD". Abort.\n", ts_begin, last_sample_end);
									goto exit;
								}

								str = ttxt_parse_string(import, samp_text, GF_TRUE);
								len = (u32) strlen(str);
								samp = gf_isom_new_xml_subtitle_sample();
								/*each sample consists of a full valid XML file*/
								e = gf_isom_xml_subtitle_sample_add_text(samp, str, len);
								if (e) {
									GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TTML] ISOM - sample add text: %s", gf_error_to_string(e)));
									goto exit;
								}
								gf_free(samp_text);
								samp_text = NULL;

								s = gf_isom_xml_subtitle_to_sample(samp);
								gf_isom_delete_xml_subtitle_sample(samp);
								if (!nb_samples) {
									s->DTS = 0; /*in MP4 we must start at T=0*/
									last_sample_duration = ts_end;
								} else {
									s->DTS = ts_begin;
									last_sample_duration = ts_end - ts_begin;
								}
								last_sample_end = ts_end;
								GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("ts_begin="LLD", ts_end="LLD", last_sample_duration="LLU" (real duration: "LLU"), last_sample_end="LLU"\n", ts_begin, ts_end, ts_end - last_sample_end, last_sample_duration, last_sample_end));

								e = gf_isom_add_sample(import->dest, track, desc_idx, s);
								if (e) {
									GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TTML] ISOM - Add Sample: %s", gf_error_to_string(e)));
									goto exit;
								}
								gf_isom_sample_del(&s);
								nb_samples++;

								nb_p_found++;
								gf_set_progress("Importing TTML", nb_samples, nb_children);
								if (import->duration && (ts_end > import->duration))
									break;
							} else {
								GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML] incomplete sample (begin="LLD", end="LLD", text=\"%s\"). Skip.\n", ts_begin, ts_end, samp_text ? samp_text : "NULL"));
							}
						}
					}

					if (!nb_p_found) {
						GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] \"%s\" div node has no <p> elements. Aborting.\n", node->name));
						goto exit;
					}
				}
			}
		}
	}
	if (!has_body) {
		e = gf_import_message(import, GF_BAD_PARAM, "[TTML EBU-TTD] missing \"body\" element. Abort.\n");
		goto exit;
	}
	GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("last_sample_duration="LLU", last_sample_end="LLU"\n", last_sample_duration, last_sample_end));
	gf_isom_set_last_sample_duration(import->dest, track, (u32) last_sample_duration);
	gf_media_update_bitrate(import->dest, track);
	gf_set_progress("Importing TTML EBU-TTD", nb_samples, nb_samples);

exit:
	gf_free(samp_text);
	gf_xml_dom_del(parser_working_copy);
	if (!gf_isom_get_sample_count(import->dest, track)) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] No sample imported. Might be an error. Check your content.\n"));
	}
	return e;
}
