void Transform::equalize( RawTile& in, vector<unsigned int>& histogram ){

  // Number of levels in our histogram
  const unsigned int bits = histogram.size();

  // Allocate and initialize our array to zero using std::fill
  float *cdf = new float[bits];
  fill( cdf, cdf+bits, 0.0 );

  // Find first non-zero bin
  unsigned int n0 = 0;
  while( histogram[n0] == 0 ) ++n0;

  // Calculate cumulative histogram
  cdf[0] = histogram[0];
  for( unsigned int i=1; i<bits; i++ ){
    cdf[i] = cdf[i-1] + histogram[i];
  }

  // Scale our CDF
  float scale = (float)(bits-1) / cdf[bits-1];
  float cdfmin = cdf[n0] / (float)(in.width*in.height);
#if defined(__ICC) || defined(__INTEL_COMPILER)
#pragma ivdep
#elif defined(_OPENMP)
#pragma omp parallel for
#endif
  for( unsigned int i=0; i<bits; i++ ){
    cdf[i] = round( scale * (cdf[i]-cdfmin) );
  }

  // Map image through cumulative histogram
#if defined(__ICC) || defined(__INTEL_COMPILER)
#pragma ivdep
#elif defined(_OPENMP)
#pragma omp parallel for if( in.width*in.height > PARALLEL_THRESHOLD )
#endif
  for( unsigned int i=0; i<in.width*in.height; i++ ){
    for( int j=0; j<in.channels; j++ ){
      unsigned int index = i*in.channels + j;
      unsigned int value = (unsigned int) (((unsigned char*)in.data)[index]);
      ((unsigned char*)in.data)[index] = (unsigned char) cdf[value];
    }
  }

  // Free our dynamically allocated array
  delete[] cdf;
}
