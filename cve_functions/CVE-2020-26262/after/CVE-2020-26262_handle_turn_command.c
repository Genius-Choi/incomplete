static int handle_turn_command(turn_turnserver *server, ts_ur_super_session *ss, ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int *resp_constructed, int can_resume)
{

	stun_tid tid;
	int err_code = 0;
	const uint8_t *reason = NULL;
	int no_response = 0;
	int message_integrity = 0;

	if(!(ss->client_socket))
		return -1;

	uint16_t unknown_attrs[MAX_NUMBER_OF_UNKNOWN_ATTRS];
	uint16_t ua_num = 0;
	uint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh), 
					     ioa_network_buffer_get_size(in_buffer->nbh));

	*resp_constructed = 0;

	stun_tid_from_message_str(ioa_network_buffer_data(in_buffer->nbh), 
				  ioa_network_buffer_get_size(in_buffer->nbh), 
				  &tid);

	if (stun_is_request_str(ioa_network_buffer_data(in_buffer->nbh), 
				ioa_network_buffer_get_size(in_buffer->nbh))) {

		if((method == STUN_METHOD_BINDING) && (*(server->no_stun))) {

			no_response = 1;
			if(server->verbose) {
				TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,
									"%s: STUN method 0x%x ignored\n",
									__FUNCTION__, (unsigned int)method);
			}

		} else if((method != STUN_METHOD_BINDING) && (*(server->stun_only))) {

				no_response = 1;
				if(server->verbose) {
					TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,
										"%s: STUN method 0x%x ignored\n",
										__FUNCTION__, (unsigned int)method);
				}

		} else if((method != STUN_METHOD_BINDING) || (*(server->secure_stun))) {

			if(method == STUN_METHOD_ALLOCATE) {

				allocation *a = get_allocation_ss(ss);
				if(is_allocation_valid(a)) {
					if(!stun_tid_equals(&(a->tid), &tid)) {
						err_code = 437;
						reason = (const uint8_t *)"Mismatched allocation: wrong transaction ID";
					}
				}

				if(!err_code) {
					SOCKET_TYPE cst = get_ioa_socket_type(ss->client_socket);
					turn_server_addrs_list_t *asl = server->alternate_servers_list;

					if(((cst == UDP_SOCKET)||(cst == DTLS_SOCKET)) && server->self_udp_balance &&
							server->aux_servers_list && server->aux_servers_list->size) {
						asl = server->aux_servers_list;
					} else if(((cst == TLS_SOCKET) || (cst == DTLS_SOCKET) ||(cst == TLS_SCTP_SOCKET)) &&
							server->tls_alternate_servers_list && server->tls_alternate_servers_list->size) {
						asl = server->tls_alternate_servers_list;
					}

					if(asl && asl->size) {
						turn_mutex_lock(&(asl->m));
						set_alternate_server(asl,get_local_addr_from_ioa_socket(ss->client_socket),&(server->as_counter),method,&tid,resp_constructed,&err_code,&reason,nbh);
						turn_mutex_unlock(&(asl->m));
					}
				}
			}

			/* check that the realm is the same as in the original request */
			if(ss->origin_set) {
				stun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),
					ioa_network_buffer_get_size(in_buffer->nbh));

				int origin_found = 0;
				int norigins = 0;

				while(sar && !origin_found) {
					if(stun_attr_get_type(sar) == STUN_ATTRIBUTE_ORIGIN) {
						int sarlen = stun_attr_get_len(sar);
						if(sarlen>0) {
							++norigins;
							char *o = (char*)malloc(sarlen+1);
							bcopy(stun_attr_get_value(sar),o,sarlen);
							o[sarlen]=0;
							char *corigin = (char*)malloc(STUN_MAX_ORIGIN_SIZE+1);
							corigin[0]=0;
							if(get_canonic_origin(o,corigin,STUN_MAX_ORIGIN_SIZE)<0) {
								TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,
									"%s: Wrong origin format: %s\n",
									__FUNCTION__, o);
							}
							if(!strncmp(ss->origin,corigin,STUN_MAX_ORIGIN_SIZE)) {
								origin_found = 1;
							}
							free(corigin);
							free(o);
						}
					}
					sar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),
							ioa_network_buffer_get_size(in_buffer->nbh), sar);
				}

				if(server->check_origin && *(server->check_origin)) {
					if(ss->origin[0]) {
						if(!origin_found) {
							err_code = 441;
							reason = (const uint8_t *)"The origin attribute does not match the initial session origin value";
							if(server->verbose) {
								char smethod[129];
								stun_method_str(method,smethod);
								log_method(ss, smethod, err_code, reason);
							}
						}
					} else if(norigins > 0){
						err_code = 441;
						reason = (const uint8_t *)"The origin attribute is empty, does not match the initial session origin value";
						if(server->verbose) {
							char smethod[129];
							stun_method_str(method,smethod);
							log_method(ss, smethod, err_code, reason);
						}
					}
				}
			}

			/* get the initial origin value */
			if(!err_code && !(ss->origin_set) && (method == STUN_METHOD_ALLOCATE)) {

				stun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),
					ioa_network_buffer_get_size(in_buffer->nbh));

				int origin_found = 0;

				while(sar && !origin_found) {
					if(stun_attr_get_type(sar) == STUN_ATTRIBUTE_ORIGIN) {
						int sarlen = stun_attr_get_len(sar);
						if(sarlen>0) {
							char *o = (char*)malloc(sarlen+1);
							bcopy(stun_attr_get_value(sar),o,sarlen);
							o[sarlen]=0;
							char *corigin = (char*)malloc(STUN_MAX_ORIGIN_SIZE+1);
							corigin[0]=0;
							if(get_canonic_origin(o,corigin,STUN_MAX_ORIGIN_SIZE)<0) {
								TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,
									"%s: Wrong origin format: %s\n",
									__FUNCTION__, o);
							}
							strncpy(ss->origin,corigin,STUN_MAX_ORIGIN_SIZE);
							free(corigin);
							free(o);
							origin_found = get_realm_options_by_origin(ss->origin,&(ss->realm_options));
						}
					}
					sar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),
							ioa_network_buffer_get_size(in_buffer->nbh), sar);
				}

				ss->origin_set = 1;
			}

			if(!err_code && !(*resp_constructed) && !no_response) {
				if(method == STUN_METHOD_CONNECTION_BIND) {
					;
				} else if(!(*(server->mobility)) || (method != STUN_METHOD_REFRESH) || is_allocation_valid(get_allocation_ss(ss))) {
					int postpone_reply = 0;
					check_stun_auth(server, ss, &tid, resp_constructed, &err_code, &reason, in_buffer, nbh, method, &message_integrity, &postpone_reply, can_resume);
					if(postpone_reply)
						no_response = 1;
				}
			}
		}

		if (!err_code && !(*resp_constructed) && !no_response) {

			switch (method){

			case STUN_METHOD_ALLOCATE:

			{
				handle_turn_allocate(server, ss, &tid, resp_constructed, &err_code, &reason,
							unknown_attrs, &ua_num, in_buffer, nbh);

				if(server->verbose) {
				  log_method(ss, "ALLOCATE", err_code, reason);
				}

				break;
			}

			case STUN_METHOD_CONNECT:

				handle_turn_connect(server, ss, &tid, &err_code, &reason,
							unknown_attrs, &ua_num, in_buffer);

				if(server->verbose) {
				  log_method(ss, "CONNECT", err_code, reason);
				}

				if(!err_code)
					no_response = 1;

				break;

			case STUN_METHOD_CONNECTION_BIND:

				handle_turn_connection_bind(server, ss, &tid, resp_constructed, &err_code, &reason,
								unknown_attrs, &ua_num, in_buffer, nbh, message_integrity, can_resume);

				if(server->verbose && err_code) {
				  log_method(ss, "CONNECTION_BIND", err_code, reason);
				}

				break;

			case STUN_METHOD_REFRESH:

				handle_turn_refresh(server, ss, &tid, resp_constructed, &err_code, &reason,
								unknown_attrs, &ua_num, in_buffer, nbh, message_integrity,
								&no_response, can_resume);

				if(server->verbose) {
				  log_method(ss, "REFRESH", err_code, reason);
				}
				break;

			case STUN_METHOD_CHANNEL_BIND:

				handle_turn_channel_bind(server, ss, &tid, resp_constructed, &err_code, &reason,
								unknown_attrs, &ua_num, in_buffer, nbh);

				if(server->verbose) {
				  log_method(ss, "CHANNEL_BIND", err_code, reason);
				}
				break;

			case STUN_METHOD_CREATE_PERMISSION:

				handle_turn_create_permission(server, ss, &tid, resp_constructed, &err_code, &reason,
								unknown_attrs, &ua_num, in_buffer, nbh);

				if(server->verbose) {
				  log_method(ss, "CREATE_PERMISSION", err_code, reason);
				}
				break;

			case STUN_METHOD_BINDING:

			{
				int origin_changed=0;
				ioa_addr response_origin;
				int dest_changed=0;
				ioa_addr response_destination;

				handle_turn_binding(server, ss, &tid, resp_constructed, &err_code, &reason,
							unknown_attrs, &ua_num, in_buffer, nbh,
							&origin_changed, &response_origin,
							&dest_changed, &response_destination,
							0, 0);

				if(server->verbose && server->log_binding) {
				  log_method(ss, "BINDING", err_code, reason);
				}

				if(*resp_constructed && !err_code && (origin_changed || dest_changed)) {

					if (server->verbose && server->log_binding) {
						TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "RFC 5780 request successfully processed\n");
					}

					{
						const uint8_t *field = (const uint8_t *) get_version(server);
						size_t fsz = strlen(get_version(server));
						size_t len = ioa_network_buffer_get_size(nbh);
						stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);
						ioa_network_buffer_set_size(nbh, len);
					}

					send_turn_message_to(server, nbh, &response_origin, &response_destination);

					no_response = 1;
				}

				break;
			}
			default:
				TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "Unsupported STUN request received, method 0x%x\n",(unsigned int)method);
			};
		}

	} else if (stun_is_indication_str(ioa_network_buffer_data(in_buffer->nbh), 
					  ioa_network_buffer_get_size(in_buffer->nbh))) {

		no_response = 1;
		int postpone = 0;

		if (!postpone && !err_code) {

			switch (method){

			case STUN_METHOD_BINDING:
				//ICE ?
				break;

			case STUN_METHOD_SEND:

				handle_turn_send(server, ss, &err_code, &reason, unknown_attrs, &ua_num, in_buffer);

				if(eve(server->verbose)) {
				  log_method(ss, "SEND", err_code, reason);
				}

				break;

			case STUN_METHOD_DATA:

				err_code = 403;

				if(eve(server->verbose)) {
				  log_method(ss, "DATA", err_code, reason);
				}

				break;

			default:
				if (server->verbose) {
					TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "Unsupported STUN indication received: method 0x%x\n",(unsigned int)method);
				}
			}
		};

	} else {

		no_response = 1;

		if (server->verbose) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "Wrong STUN message received\n");
		}
	}

	if(ss->to_be_closed || !(ss->client_socket) || ioa_socket_tobeclosed(ss->client_socket))
		return 0;

	if (ua_num > 0) {

		err_code = 420;

		size_t len = ioa_network_buffer_get_size(nbh);
		stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, NULL, &tid);

		stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_UNKNOWN_ATTRIBUTES, (const uint8_t*) unknown_attrs, (ua_num
						* 2));

		ioa_network_buffer_set_size(nbh,len);

		*resp_constructed = 1;
	}

	if (!no_response) {

		if (!(*resp_constructed)) {

			if (!err_code)
				err_code = 400;

			size_t len = ioa_network_buffer_get_size(nbh);
			stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, err_code, reason, &tid);
			ioa_network_buffer_set_size(nbh,len);
			*resp_constructed = 1;
		}

		{
			const uint8_t *field = (const uint8_t *) get_version(server);
			size_t fsz = strlen(get_version(server));
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);
			ioa_network_buffer_set_size(nbh, len);
		}

		if(message_integrity) {
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);
			ioa_network_buffer_set_size(nbh,len);
		}

		if(err_code) {
			if(server->verbose) {
			  log_method(ss, "message", err_code, reason);
			}
		}

	} else {
		*resp_constructed = 0;
	}

	return 0;
}
