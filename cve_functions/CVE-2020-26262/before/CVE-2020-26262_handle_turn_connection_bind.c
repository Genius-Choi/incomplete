static int handle_turn_connection_bind(turn_turnserver *server,
			       ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,
			       int *err_code, 	const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,
			       ioa_net_data *in_buffer, ioa_network_buffer_handle nbh, int message_integrity,
			       int can_resume) {

	allocation* a = get_allocation_ss(ss);

	uint16_t method = STUN_METHOD_CONNECTION_BIND;

	if(ss->to_be_closed) {

		*err_code = 400;

	} else if (is_allocation_valid(a)) {

		*err_code = 400;
		*reason = (const uint8_t *)"Bad request: CONNECTION_BIND cannot be issued after allocation";

	} else if(!is_stream_socket(get_ioa_socket_type(ss->client_socket))) {

		*err_code = 400;
		*reason = (const uint8_t *)"Bad request: CONNECTION_BIND only possible with TCP/TLS";

	} else {
		tcp_connection_id id = 0;

		stun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh),
							    ioa_network_buffer_get_size(in_buffer->nbh));
		while (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {
			int attr_type = stun_attr_get_type(sar);
			switch (attr_type) {
			SKIP_ATTRIBUTES;
			case STUN_ATTRIBUTE_CONNECTION_ID: {
				if (stun_attr_get_len(sar) != 4) {
					*err_code = 400;
					*reason = (const uint8_t *)"Wrong Connection ID field format";
				} else {
					const uint8_t* value = stun_attr_get_value(sar);
					if (!value) {
						*err_code = 400;
						*reason = (const uint8_t *)"Wrong Connection ID field data";
					} else {
						id = *((const uint32_t*)value); //AS-IS encoding, no conversion to/from network byte order
					}
				}
			}
				break;
			default:
				if(attr_type>=0x0000 && attr_type<=0x7FFF)
					unknown_attrs[(*ua_num)++] = nswap16(attr_type);
			};
			sar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh),
						     ioa_network_buffer_get_size(in_buffer->nbh), sar);
		}

		if (*ua_num > 0) {

			*err_code = 420;

		} else if (*err_code) {

			;

		} else {
			if(server->send_socket_to_relay) {
				turnserver_id sid = (id & 0xFF000000)>>24;
				ioa_socket_handle s = ss->client_socket;
				if(s && !ioa_socket_tobeclosed(s)) {
					ioa_socket_handle new_s = detach_ioa_socket(s);
					if(new_s) {
					  if(server->send_socket_to_relay(sid, id, tid, new_s, message_integrity, RMT_CB_SOCKET, in_buffer, can_resume)<0) {
					    *err_code = 400;
					    *reason = (const uint8_t *)"Wrong connection id";
					  }
					} else {
						*err_code = 500;
					}
				} else {
					*err_code = 500;
				}
			} else {
				*err_code = 500;
			}
			ss->to_be_closed = 1;
		}
	}

	if (!(*resp_constructed) && ss->client_socket && !ioa_socket_tobeclosed(ss->client_socket)) {

		if (!(*err_code)) {
			*err_code = 437;
		}

		size_t len = ioa_network_buffer_get_size(nbh);
		stun_init_error_response_str(method, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);
		ioa_network_buffer_set_size(nbh,len);

		*resp_constructed = 1;
	}

	return 0;
}
