int make_ioa_addr(const uint8_t* saddr0, int port, ioa_addr *addr) {

  if(!saddr0 || !addr) return -1;

  char ssaddr[257];
  STRCPY(ssaddr,saddr0);

  char* saddr=ssaddr;
  while(*saddr == ' ') ++saddr;

  size_t len=strlen(saddr);
  while(len>0) {
	  if(saddr[len-1]==' ') {
		  saddr[len-1]=0;
		  --len;
	  } else {
		  break;
	  }
  }

  bzero(addr, sizeof(ioa_addr));
  if((len == 0)||
     (inet_pton(AF_INET, saddr, &addr->s4.sin_addr) == 1)) {
    addr->s4.sin_family = AF_INET;
#if defined(TURN_HAS_SIN_LEN) /* tested when configured */
    addr->s4.sin_len = sizeof(struct sockaddr_in);
#endif
    addr->s4.sin_port = nswap16(port);
  } else if (inet_pton(AF_INET6, saddr, &addr->s6.sin6_addr) == 1) {
    addr->s6.sin6_family = AF_INET6;
#if defined(SIN6_LEN) /* this define is required by IPv6 if used */
    addr->s6.sin6_len = sizeof(struct sockaddr_in6);
#endif
    addr->s6.sin6_port = nswap16(port);
  } else {
    struct addrinfo addr_hints;
    struct addrinfo *addr_result = NULL;
    int err;

    memset(&addr_hints, 0, sizeof(struct addrinfo));
    addr_hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    addr_hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    addr_hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    addr_hints.ai_protocol = 0;          /* Any protocol */
    addr_hints.ai_canonname = NULL;
    addr_hints.ai_addr = NULL;
    addr_hints.ai_next = NULL;

    err = getaddrinfo(saddr, NULL, &addr_hints, &addr_result);
    if ((err != 0)||(!addr_result)) {
      fprintf(stderr,"error resolving '%s' hostname: %s\n",saddr,gai_strerror(err));
      return -1;
    }
    
    int family = AF_INET;
    struct addrinfo *addr_result_orig = addr_result;
    int found = 0;

    beg_af:

    while(addr_result) {

    	if(addr_result->ai_family == family) {
    		if (addr_result->ai_family == AF_INET) {
    			bcopy(addr_result->ai_addr, addr, addr_result->ai_addrlen);
    			addr->s4.sin_port = nswap16(port);
#if defined(TURN_HAS_SIN_LEN) /* tested when configured */
    			addr->s4.sin_len = sizeof(struct sockaddr_in);
#endif
    			found = 1;
    			break;
    		} else if (addr_result->ai_family == AF_INET6) {
    			bcopy(addr_result->ai_addr, addr, addr_result->ai_addrlen);
    			addr->s6.sin6_port = nswap16(port);
#if defined(SIN6_LEN) /* this define is required by IPv6 if used */
    			addr->s6.sin6_len = sizeof(struct sockaddr_in6);
#endif
    			found = 1;
    			break;
    		}
    	}

    	addr_result = addr_result->ai_next;
    }

    if(!found && family == AF_INET) {
    	family = AF_INET6;
    	addr_result = addr_result_orig;
    	goto beg_af;
    }
    
    freeaddrinfo(addr_result_orig);
  }

  return 0;
}
