static void tcp_peer_accept_connection(ioa_socket_handle s, void *arg)
{
	if(s) {

		if(!arg) {
			close_ioa_socket(s);
			return;
		}

		ts_ur_super_session *ss = (ts_ur_super_session*)arg;
		turn_turnserver *server=(turn_turnserver*)(ss->server);

		FUNCSTART;

		allocation *a = &(ss->alloc);
		ioa_addr *peer_addr = get_remote_addr_from_ioa_socket(s);
		if(!peer_addr) {
			close_ioa_socket(s);
			FUNCEND;
			return;
		}

		tcp_connection *tc = get_tcp_connection_by_peer(a, peer_addr);
		if(tc) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: peer data socket with this address already exist\n", __FUNCTION__);
			if(tc->peer_s != s)
				close_ioa_socket(s);
			FUNCEND;
			return;
		}

		if(!good_peer_addr(server, ss->realm_options.name, peer_addr)) {
			uint8_t saddr[256];
			addr_to_string(peer_addr, saddr);
			TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: an attempt to connect from a peer with forbidden address: %s\n", __FUNCTION__,saddr);
			close_ioa_socket(s);
			FUNCEND;
			return;
		}

		if(!can_accept_tcp_connection_from_peer(a,peer_addr,server->server_relay)) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: peer has no permission to connect\n", __FUNCTION__);
			close_ioa_socket(s);
			FUNCEND;
			return;
		}

		stun_tid tid;
		bzero(&tid,sizeof(stun_tid));
		int err_code=0;
		tc = create_tcp_connection(server->id, a, &tid, peer_addr, &err_code);
		if(!tc) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: cannot create TCP connection\n", __FUNCTION__);
			close_ioa_socket(s);
			FUNCEND;
			return;
		}

		tc->state = TC_STATE_PEER_CONNECTED;
		tc->peer_s = s;

		set_ioa_socket_session(s,ss);
		set_ioa_socket_sub_session(s,tc);

		if(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, tcp_peer_input_handler, tc, 1)<0) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: cannot set TCP peer data input callback\n", __FUNCTION__);
			IOA_CLOSE_SOCKET(tc->peer_s);
			tc->state = TC_STATE_UNKNOWN;
			FUNCEND;
			return;
		}

		IOA_EVENT_DEL(tc->conn_bind_timeout);
		tc->conn_bind_timeout = set_ioa_timer(server->e, TCP_CONN_BIND_TIMEOUT, 0,
							tcp_conn_bind_timeout_handler, tc, 0,
							"tcp_conn_bind_timeout_handler");

		ioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);
		size_t len = ioa_network_buffer_get_size(nbh);

		stun_init_indication_str(STUN_METHOD_CONNECTION_ATTEMPT, ioa_network_buffer_data(nbh), &len);
		stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_CONNECTION_ID,
					(const uint8_t*)&(tc->id), 4);
		stun_attr_add_addr_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_XOR_PEER_ADDRESS, peer_addr);

		ioa_network_buffer_set_size(nbh,len);

		{
			const uint8_t *field = (const uint8_t *) get_version(server);
			size_t fsz = strlen(get_version(server));
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);
			ioa_network_buffer_set_size(nbh, len);
		}

		if ((server->fingerprint) || ss->enforce_fingerprints) {
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);
			ioa_network_buffer_set_size(nbh, len);
		}

		write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);

		FUNCEND;
	}
}
