static int check_stun_auth(turn_turnserver *server,
			ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,
			int *err_code, 	const uint8_t **reason,
			ioa_net_data *in_buffer, ioa_network_buffer_handle nbh,
			uint16_t method, int *message_integrity,
			int *postpone_reply,
			int can_resume)
{
	uint8_t usname[STUN_MAX_USERNAME_SIZE+1];
	uint8_t nonce[STUN_MAX_NONCE_SIZE+1];
	uint8_t realm[STUN_MAX_REALM_SIZE+1];
	size_t alen = 0;

	if(!need_stun_authentication(server, ss))
		return 0;

	int new_nonce = 0;

	{
		int generate_new_nonce = 0;
		if(ss->nonce[0]==0) {
			generate_new_nonce = 1;
			new_nonce = 1;
		}

		if(*(server->stale_nonce)) {
			if(turn_time_before(ss->nonce_expiration_time,server->ctime)) {
				generate_new_nonce = 1;
			}
		}

		if(generate_new_nonce) {

			int i = 0;

			if(TURN_RANDOM_SIZE == 8) {
				for(i=0;i<(NONCE_LENGTH_32BITS>>1);i++) {
					uint8_t *s = ss->nonce + 8*i;
					uint64_t rand=(uint64_t)turn_random();
					snprintf((char*)s, NONCE_MAX_SIZE-8*i, "%08lx",(unsigned long)rand);
				}
			} else {
				for(i=0;i<NONCE_LENGTH_32BITS;i++) {
					uint8_t *s = ss->nonce + 4*i;
					uint32_t rand=(uint32_t)turn_random();
					snprintf((char*)s, NONCE_MAX_SIZE-4*i, "%04x",(unsigned int)rand);
				}
			}
			ss->nonce_expiration_time = server->ctime + *(server->stale_nonce);
		}
	}

	/* MESSAGE_INTEGRITY ATTR: */

	stun_attr_ref sar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),
							    ioa_network_buffer_get_size(in_buffer->nbh),
							    STUN_ATTRIBUTE_MESSAGE_INTEGRITY);

	if(!sar) {
		*err_code = 401;
		return create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);
	}

	{
		int sarlen = stun_attr_get_len(sar);

		switch(sarlen) {
		case SHA1SIZEBYTES:
			break;
		case SHA256SIZEBYTES:
		case SHA384SIZEBYTES:
		case SHA512SIZEBYTES:
		default:
			*err_code = 401;
			return create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);
		};
	}

	{

		/* REALM ATTR: */

		sar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),
					  ioa_network_buffer_get_size(in_buffer->nbh),
					  STUN_ATTRIBUTE_REALM);

		if(!sar) {
			*err_code = 400;
			return -1;
		}

		alen = min((size_t)stun_attr_get_len(sar),sizeof(realm)-1);
		bcopy(stun_attr_get_value(sar),realm,alen);
		realm[alen]=0;

		if(!is_secure_string(realm,0)) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: wrong realm: %s\n", __FUNCTION__, (char*)realm);
			realm[0]=0;
			*err_code = 400;
			return -1;
		}
		
		if(method == STUN_METHOD_CONNECTION_BIND) {

			get_realm_options_by_name((char *)realm, &(ss->realm_options));

		} else if(strcmp((char*)realm, (char*)(ss->realm_options.name))) {
			if(!(ss->oauth)){
				if(method == STUN_METHOD_ALLOCATE) {
					*err_code = 437;
					*reason = (const uint8_t*)"Allocation mismatch: wrong credentials: the realm value is incorrect";
				} else {
					*err_code = 441;
					*reason = (const uint8_t*)"Wrong credentials: the realm value is incorrect";
				}
				return -1;
			} else {
				bcopy(ss->realm_options.name,realm,sizeof(ss->realm_options.name));
			}
		}
	}

	/* USERNAME ATTR: */

	sar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),
					  ioa_network_buffer_get_size(in_buffer->nbh),
					  STUN_ATTRIBUTE_USERNAME);

	if(!sar) {
		*err_code = 400;
		return -1;
	}

	alen = min((size_t)stun_attr_get_len(sar),sizeof(usname)-1);
	bcopy(stun_attr_get_value(sar),usname,alen);
	usname[alen]=0;

	if(!is_secure_string(usname,1)) {
		TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: wrong username: %s\n", __FUNCTION__, (char*)usname);
		usname[0]=0;
		*err_code = 400;
		return -1;
	} else if(ss->username[0]) {
		if(strcmp((char*)ss->username,(char*)usname)) {
			if(ss->oauth) {
				ss->hmackey_set = 0;
				STRCPY(ss->username,usname);
			} else {
				if(method == STUN_METHOD_ALLOCATE) {
					*err_code = 437;
					*reason = (const uint8_t*)"Allocation mismatch: wrong credentials";
				} else {
					*err_code = 441;
				}
				return -1;
			}
		}
	} else {
		STRCPY(ss->username,usname);
	}

	{
		/* NONCE ATTR: */

		sar = stun_attr_get_first_by_type_str(ioa_network_buffer_data(in_buffer->nbh),
					  ioa_network_buffer_get_size(in_buffer->nbh),
					  STUN_ATTRIBUTE_NONCE);

		if(!sar) {
			*err_code = 400;
			return -1;
		}

		alen = min((size_t)stun_attr_get_len(sar),sizeof(nonce)-1);
		bcopy(stun_attr_get_value(sar),nonce,alen);
		nonce[alen]=0;

		/* Stale Nonce check: */

		if(new_nonce) {
			*err_code = 438;
			*reason = (const uint8_t*)"Wrong nonce";
			return create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);
		}

		if(strcmp((char*)ss->nonce,(char*)nonce)) {
			*err_code = 438;
			*reason = (const uint8_t*)"Stale nonce";
			return create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);
		}
	}

	/* Password */
	if(!(ss->hmackey_set) && (ss->pwd[0] == 0)) {
		if(can_resume) {
			(server->userkeycb)(server->id, server->ct, server->oauth, &(ss->oauth), usname, realm, resume_processing_after_username_check, in_buffer, ss->id, postpone_reply);
			if(*postpone_reply) {
				return 0;
			}
		}

		TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,
				"%s: Cannot find credentials of user <%s>\n",
				__FUNCTION__, (char*)usname);
		*err_code = 401;
		return create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);
	}

	/* Check integrity */
	if(stun_check_message_integrity_by_key_str(server->ct,ioa_network_buffer_data(in_buffer->nbh),
					  ioa_network_buffer_get_size(in_buffer->nbh),
					  ss->hmackey,
					  ss->pwd,
					  SHATYPE_DEFAULT)<1) {

		if(can_resume) {
			(server->userkeycb)(server->id, server->ct, server->oauth, &(ss->oauth), usname, realm, resume_processing_after_username_check, in_buffer, ss->id, postpone_reply);
			if(*postpone_reply) {
				return 0;
			}
		}

		TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR,
				"%s: user %s credentials are incorrect\n",
				__FUNCTION__, (char*)usname);
		*err_code = 401;
		return create_challenge_response(ss,tid,resp_constructed,err_code,reason,nbh,method);
	}

	*message_integrity = 1;

	return 0;
}
