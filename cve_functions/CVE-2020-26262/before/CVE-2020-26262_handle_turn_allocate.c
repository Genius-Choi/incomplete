static int handle_turn_allocate(turn_turnserver *server,
				ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,
				int *err_code, 	const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,
				ioa_net_data *in_buffer, ioa_network_buffer_handle nbh) {


	int err_code4 = 0;
	int err_code6 = 0;

	allocation* alloc = get_allocation_ss(ss);

	if (is_allocation_valid(alloc)) {

		if (!stun_tid_equals(tid, &(alloc->tid))) {
			*err_code = 437;
			*reason = (const uint8_t *)"Wrong TID";
		} else {
			size_t len = ioa_network_buffer_get_size(nbh);
			ioa_addr xor_relayed_addr1, *pxor_relayed_addr1=NULL;
			ioa_addr xor_relayed_addr2, *pxor_relayed_addr2=NULL;
			ioa_addr *relayed_addr1 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET));
			ioa_addr *relayed_addr2 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET6));

			if(get_relay_session_failure(alloc,AF_INET)) {
				addr_set_any(&xor_relayed_addr1);
				pxor_relayed_addr1 = &xor_relayed_addr1;
			} else if(relayed_addr1) {
				if(server->external_ip_set) {
					addr_cpy(&xor_relayed_addr1, &(server->external_ip));
					addr_set_port(&xor_relayed_addr1,addr_get_port(relayed_addr1));
				} else {
					addr_cpy(&xor_relayed_addr1, relayed_addr1);
				}
				pxor_relayed_addr1 = &xor_relayed_addr1;
			}

			if(get_relay_session_failure(alloc,AF_INET6)) {
				addr_set_any(&xor_relayed_addr2);
				pxor_relayed_addr2 = &xor_relayed_addr2;
			} else if(relayed_addr2) {
				if(server->external_ip_set) {
					addr_cpy(&xor_relayed_addr2, &(server->external_ip));
					addr_set_port(&xor_relayed_addr2,addr_get_port(relayed_addr2));
				} else {
					addr_cpy(&xor_relayed_addr2, relayed_addr2);
				}
				pxor_relayed_addr2 = &xor_relayed_addr2;
			}

			if(pxor_relayed_addr1 || pxor_relayed_addr2) {
				uint32_t lifetime = 0;
				if(pxor_relayed_addr1) {
					lifetime = (get_relay_session(alloc,pxor_relayed_addr1->ss.sa_family)->expiration_time - server->ctime);
				} else if(pxor_relayed_addr2) {
					lifetime = (get_relay_session(alloc,pxor_relayed_addr2->ss.sa_family)->expiration_time - server->ctime);
				}
				stun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len,
							tid,
							pxor_relayed_addr1, pxor_relayed_addr2,
							get_remote_addr_from_ioa_socket(ss->client_socket),
							lifetime,*(server->max_allocate_lifetime), 0, NULL, 0,
							ss->s_mobile_id);
				ioa_network_buffer_set_size(nbh,len);
				*resp_constructed = 1;
			}
		}

	} else {

		uint8_t transport = 0;
		turn_time_t lifetime = 0;
		int even_port = -1;
		int dont_fragment = 0;
		uint64_t in_reservation_token = 0;
		int af4 = 0;
		int af6 = 0;
		uint8_t username[STUN_MAX_USERNAME_SIZE+1]="\0";
		size_t ulen = 0;
		band_limit_t bps = 0;
		band_limit_t max_bps = 0;

		stun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), 
							    ioa_network_buffer_get_size(in_buffer->nbh));
		while (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {

			int attr_type = stun_attr_get_type(sar);

			if(attr_type == STUN_ATTRIBUTE_USERNAME) {
				const uint8_t* value = stun_attr_get_value(sar);
				if (value) {
					ulen = stun_attr_get_len(sar);
					if(ulen>=sizeof(username)) {
						*err_code = 400;
						*reason = (const uint8_t *)"User name is too long";
						break;
					}
					bcopy(value,username,ulen);
					username[ulen]=0;
					if(!is_secure_string(username,1)) {
						TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: wrong username: %s\n", __FUNCTION__, (char*)username);
						username[0]=0;
						*err_code = 400;
						break;
					}
				}
			}

			switch (attr_type) {
			SKIP_ATTRIBUTES;
			case STUN_ATTRIBUTE_NEW_BANDWIDTH:
				bps = stun_attr_get_bandwidth(sar);
				break;
			case STUN_ATTRIBUTE_MOBILITY_TICKET:
				if(!(*(server->mobility))) {
					*err_code = 405;
					*reason = (const uint8_t *)"Mobility Forbidden";
				} else if (stun_attr_get_len(sar) != 0) {
					*err_code = 400;
					*reason = (const uint8_t *)"Wrong Mobility Field";
				} else {
					ss->is_mobile = 1;
				}
				break;
			case STUN_ATTRIBUTE_REQUESTED_TRANSPORT: {
				if (stun_attr_get_len(sar) != 4) {
					*err_code = 400;
					*reason = (const uint8_t *)"Wrong Transport Field";
				} else if(transport) {
					*err_code = 400;
					*reason = (const uint8_t *)"Duplicate Transport Fields";
				} else {
					const uint8_t* value = stun_attr_get_value(sar);
					if (value) {
						transport = get_transport_value(value);
						if (!transport) {
							*err_code = 442;
						}
						if((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && *(server->no_tcp_relay)) {
							*err_code = 442;
							*reason = (const uint8_t *)"TCP Transport is not allowed by the TURN Server configuration";
						} else if((transport == STUN_ATTRIBUTE_TRANSPORT_UDP_VALUE) && *(server->no_udp_relay)) {
							*err_code = 442;
							*reason = (const uint8_t *)"UDP Transport is not allowed by the TURN Server configuration";
						} else if(ss->client_socket) {
							SOCKET_TYPE cst = get_ioa_socket_type(ss->client_socket);
							if((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && !is_stream_socket(cst)) {
								*err_code = 400;
								*reason = (const uint8_t *)"Wrong Transport Data";
							} else {
								ss->is_tcp_relay = (transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE);
							}
						}
					} else {
						*err_code = 400;
						*reason = (const uint8_t *)"Wrong Transport Data";
					}
				}
			}
				break;
			case STUN_ATTRIBUTE_DONT_FRAGMENT:
				dont_fragment = 1;
				if(!(server->dont_fragment))
					unknown_attrs[(*ua_num)++] = nswap16(attr_type);
				break;
			case STUN_ATTRIBUTE_LIFETIME: {
			  if (stun_attr_get_len(sar) != 4) {
			    *err_code = 400;
			    *reason = (const uint8_t *)"Wrong Lifetime Field";
			  } else {
			    const uint8_t* value = stun_attr_get_value(sar);
			    if (!value) {
			      *err_code = 400;
			      *reason = (const uint8_t *)"Wrong Lifetime Data";
			    } else {
			      lifetime = nswap32(*((const uint32_t*)value));
			    }
			  }
			}
			  break;
			case STUN_ATTRIBUTE_EVEN_PORT: {
			  if (in_reservation_token) {
			    *err_code = 400;
			    *reason = (const uint8_t *)"Even Port and Reservation Token cannot be used together";
			  } else {
			    even_port = stun_attr_get_even_port(sar);
			    if(even_port) {
			    	if (af4 && af6) {
			    		*err_code = 400;
			    		*reason = (const uint8_t *)"Even Port cannot be used with Dual Allocation";
			    	}
			    }
			  }
			}
			  break;
			case STUN_ATTRIBUTE_RESERVATION_TOKEN: {
			  int len = stun_attr_get_len(sar);
			  if (len != 8) {
			    *err_code = 400;
			    *reason = (const uint8_t *)"Wrong Format of Reservation Token";
			  } else if(af4 || af6) {
				  *err_code = 400;
				  *reason = (const uint8_t *)"Address family attribute can not be used with reservation token request";
			  } else {
			    if (even_port >= 0) {
			      *err_code = 400;
			      *reason = (const uint8_t *)"Reservation Token cannot be used in this request with even port";
			    } else if (in_reservation_token) {
			      *err_code = 400;
			      *reason = (const uint8_t *)"Reservation Token cannot be used in this request";
			    } else {
			      in_reservation_token = stun_attr_get_reservation_token_value(sar);
			    }
			  }
			}
			  break;
			case STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY:
				if(even_port>0) {
					*err_code = 400;
					*reason = (const uint8_t *)"Even Port cannot be used with Dual Allocation";
					break;
				}
				/* Falls through. */
			case STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY: {
				if(in_reservation_token) {
					*err_code = 400;
					*reason = (const uint8_t *)"Address family attribute can not be used with reservation token request";
				} else if(af4 || af6) {
					*err_code = 400;
					*reason = (const uint8_t *)"Extra address family attribute can not be used in the request";
				} else {
					int af_req = stun_get_requested_address_family(sar);
					switch (af_req) {
					case STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:
						if(attr_type == STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY) {
							*err_code = 400;
							*reason = (const uint8_t *)"Invalid value of the additional address family attribute";
						} else {
							af4 = af_req;
						}
						break;
					case STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:
						if(attr_type == STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY) {
							af4 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;
						}
						af6 = af_req;
						break;
					default:
						*err_code = 440;
					}
				}
			}
			  break;
			default:
				if(attr_type>=0x0000 && attr_type<=0x7FFF)
					unknown_attrs[(*ua_num)++] = nswap16(attr_type);
			};
			sar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), 
						     ioa_network_buffer_get_size(in_buffer->nbh), 
						     sar);
		}

		if (!transport) {

		  *err_code = 400;
		  if(!(*reason))
		    *reason = (const uint8_t *)"Transport field missed or wrong";
		  
		} else if (*ua_num > 0) {

		  *err_code = 420;

		} else if (*err_code) {

			;

		} else if((transport == STUN_ATTRIBUTE_TRANSPORT_TCP_VALUE) && (dont_fragment || in_reservation_token || (even_port!=-1))) {

			*err_code = 400;
			if(!(*reason))
			    *reason = (const uint8_t *)"Request parameters are incompatible with TCP transport";

		} else {

			if(*(server->mobility)) {
				if(!(ss->is_mobile)) {
					delete_session_from_mobile_map(ss);
				}
			}

			lifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);
			uint64_t out_reservation_token = 0;

			if(inc_quota(ss, username)<0) {

				*err_code = 486;

			} else {

				if(server->allocate_bps_func) {
					max_bps = ss->realm_options.perf_options.max_bps;
					if(max_bps && (!bps || (bps && (bps>max_bps)))) {
						bps = max_bps;
					}
					if(bps && (ss->bps == 0)) {
						ss->bps = server->allocate_bps_func(bps,1);
						if(!(ss->bps)) {
							*err_code = 486;
							*reason = (const uint8_t *)"Allocation Bandwidth Quota Reached";
						}
					}
				}

				if(af4) af4 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;
				if(af6) af6 = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6;

				if(af4 && af6) {
					if(server->external_ip_set) {
						*err_code = 440;
						*reason = (const uint8_t *)"Dual allocation cannot be supported in the current server configuration";
					}
					if(even_port > 0) {
						*err_code = 440;
						*reason = (const uint8_t *)"Dual allocation cannot be supported with even-port functionality";
					}
				}

				if(!(*err_code)) {
					if(!af4 && !af6) {
						int a_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_DEFAULT;
						if (server->keep_address_family) {
							switch(get_ioa_socket_address_family(ss->client_socket)) {
								case AF_INET6 :
									a_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6;
									break;
								case AF_INET :
									a_family = STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4;
									break;
							}
						}

						int res = create_relay_connection(server, ss, lifetime,
						a_family, transport,
						even_port, in_reservation_token, &out_reservation_token,
						err_code, reason,
						tcp_peer_accept_connection);

						if(res<0) {
							set_relay_session_failure(alloc,AF_INET);
							if(!(*err_code)) {
								*err_code = 437;
							}
						}
					} else if(!af4 && af6) {
						int af6res = create_relay_connection(server, ss, lifetime,
							af6, transport,
							even_port, in_reservation_token, &out_reservation_token,
							err_code, reason,
							tcp_peer_accept_connection);
						if(af6res<0) {
							set_relay_session_failure(alloc,AF_INET6);
							if(!(*err_code)) {
								*err_code = 437;
							}
						}
					} else if(af4 && !af6) {
						int af4res = create_relay_connection(server, ss, lifetime,
							af4, transport,
							even_port, in_reservation_token, &out_reservation_token,
							err_code, reason,
							tcp_peer_accept_connection);
						if(af4res<0) {
							set_relay_session_failure(alloc,AF_INET);
							if(!(*err_code)) {
								*err_code = 437;
							}
						}
					} else {
						const uint8_t *reason4 = NULL;
						const uint8_t *reason6 = NULL;
						{
							int af4res = create_relay_connection(server, ss, lifetime,
									af4, transport,
									even_port, in_reservation_token, &out_reservation_token,
									&err_code4, &reason4,
									tcp_peer_accept_connection);
							if(af4res<0) {
								set_relay_session_failure(alloc,AF_INET);
								if(!err_code4) {
									err_code4 = 440;
								}
							}
						}
						{
							int af6res = create_relay_connection(server, ss, lifetime,
												af6, transport,
												even_port, in_reservation_token, &out_reservation_token,
												&err_code6, &reason6,
												tcp_peer_accept_connection);
							if(af6res<0) {
								set_relay_session_failure(alloc,AF_INET6);
								if(!err_code6) {
									err_code6 = 440;
								}
							}
						}

						if(err_code4 && err_code6) {
							if(reason4) {
								*err_code = err_code4;
								*reason = reason4;
							} else if(reason6) {
								*err_code = err_code6;
								*reason = reason6;
							} else {
								*err_code = err_code4;
							}
						}
					}
				}

				if (*err_code) {

					if(!(*reason)) {
						*reason = (const uint8_t *)"Cannot create relay endpoint(s)";
					}

				} else {

					set_allocation_valid(alloc,1);

					stun_tid_cpy(&(alloc->tid), tid);

					size_t len = ioa_network_buffer_get_size(nbh);

					ioa_addr xor_relayed_addr1, *pxor_relayed_addr1=NULL;
					ioa_addr xor_relayed_addr2, *pxor_relayed_addr2=NULL;
					ioa_addr *relayed_addr1 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET));
					ioa_addr *relayed_addr2 = get_local_addr_from_ioa_socket(get_relay_socket_ss(ss,AF_INET6));

					if(get_relay_session_failure(alloc,AF_INET)) {
						addr_set_any(&xor_relayed_addr1);
						pxor_relayed_addr1 = &xor_relayed_addr1;
					} else if(relayed_addr1) {
						if(server->external_ip_set) {
							addr_cpy(&xor_relayed_addr1, &(server->external_ip));
							addr_set_port(&xor_relayed_addr1,addr_get_port(relayed_addr1));
						} else {
							addr_cpy(&xor_relayed_addr1, relayed_addr1);
						}
						pxor_relayed_addr1 = &xor_relayed_addr1;
					}

					if(get_relay_session_failure(alloc,AF_INET6)) {
						addr_set_any(&xor_relayed_addr2);
						pxor_relayed_addr2 = &xor_relayed_addr2;
					} else if(relayed_addr2) {
						if(server->external_ip_set) {
							addr_cpy(&xor_relayed_addr2, &(server->external_ip));
							addr_set_port(&xor_relayed_addr2,addr_get_port(relayed_addr2));
						} else {
							addr_cpy(&xor_relayed_addr2, relayed_addr2);
						}
						pxor_relayed_addr2 = &xor_relayed_addr2;
					}

					if(pxor_relayed_addr1 || pxor_relayed_addr2) {

						stun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len, tid,
									pxor_relayed_addr1, pxor_relayed_addr2,
									get_remote_addr_from_ioa_socket(ss->client_socket), lifetime,
									*(server->max_allocate_lifetime),0,NULL,
									out_reservation_token,
									ss->s_mobile_id);

						if(ss->bps) {
							stun_attr_add_bandwidth_str(ioa_network_buffer_data(nbh), &len, ss->bps);
						}

						ioa_network_buffer_set_size(nbh,len);
						*resp_constructed = 1;

						turn_report_allocation_set(&(ss->alloc), lifetime, 0);
					}
				}
			}
		}
	}

	if (!(*resp_constructed)) {

		if (!(*err_code)) {
			*err_code = 437;
		}

		size_t len = ioa_network_buffer_get_size(nbh);
		stun_set_allocate_response_str(ioa_network_buffer_data(nbh), &len, tid, NULL, NULL, NULL, 0, *(server->max_allocate_lifetime), *err_code, *reason, 0, ss->s_mobile_id);
		ioa_network_buffer_set_size(nbh,len);
		*resp_constructed = 1;
	}

	if(*resp_constructed && !(*err_code)) {
		if(err_code4) {
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_address_error_code(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4, err_code4);
			ioa_network_buffer_set_size(nbh,len);
		}
		if(err_code6) {
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_address_error_code(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6, err_code6);
			ioa_network_buffer_set_size(nbh,len);
		}
	}

	return 0;
}
