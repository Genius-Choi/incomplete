int turnserver_accept_tcp_client_data_connection(turn_turnserver *server, tcp_connection_id tcid, stun_tid *tid, ioa_socket_handle s, int message_integrity, ioa_net_data *in_buffer, int can_resume)
{
	if(!server)
		return -1;

	FUNCSTART;

	tcp_connection *tc = NULL;
	ts_ur_super_session *ss = NULL;

	int err_code = 0;
	const uint8_t *reason = NULL;

	ioa_socket_handle s_to_delete = s;

	if(tcid && tid && s) {

		tc = get_tcp_connection_by_id(server->tcp_relay_connections, tcid);
		ioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);
		int resp_constructed = 0;
		if(!tc || (tc->state == TC_STATE_READY) || (tc->client_s)) {
			err_code = 400;
		} else {
			allocation *a = (allocation*)(tc->owner);
			if(!a || !(a->owner)) {
				err_code = 500;
			} else {
				ss = (ts_ur_super_session*)(a->owner);

				if(ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {
					err_code = 404;
				} else {
					//Check security:
					int postpone_reply = 0;
					check_stun_auth(server, ss, tid, &resp_constructed, &err_code, &reason, in_buffer, nbh,
						STUN_METHOD_CONNECTION_BIND, &message_integrity, &postpone_reply, can_resume);

					if(postpone_reply) {

						ioa_network_buffer_delete(server->e, nbh);
						return 0;

					} else if(!err_code) {
						tc->state = TC_STATE_READY;
						tc->client_s = s;
						s_to_delete = NULL;
						set_ioa_socket_session(s,ss);
						set_ioa_socket_sub_session(s,tc);
						set_ioa_socket_app_type(s,TCP_CLIENT_DATA_SOCKET);
						if(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, tcp_client_input_handler_rfc6062data, tc, 1)<0) {
							TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: cannot set TCP client data input callback\n", __FUNCTION__);
							err_code = 500;
						} else {
							IOA_EVENT_DEL(tc->conn_bind_timeout);
						}
					}
				}
			}
		}

		if(tc)
			get_and_clean_tcp_connection_by_id(server->tcp_relay_connections, tcid);

		if(!resp_constructed) {
			if(!err_code) {
				size_t len = ioa_network_buffer_get_size(nbh);
				stun_init_success_response_str(STUN_METHOD_CONNECTION_BIND, ioa_network_buffer_data(nbh), &len, tid);
				ioa_network_buffer_set_size(nbh,len);
			} else {
				size_t len = ioa_network_buffer_get_size(nbh);
				stun_init_error_response_str(STUN_METHOD_CONNECTION_BIND, ioa_network_buffer_data(nbh), &len, err_code, NULL, tid);
				ioa_network_buffer_set_size(nbh,len);
			}
		}

		{
			size_t fsz = strlen(get_version(server));
			const uint8_t *field = (const uint8_t *) get_version(server);
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);
			ioa_network_buffer_set_size(nbh, len);
		}

		if(message_integrity && ss) {
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);
			ioa_network_buffer_set_size(nbh,len);
		}

		if ((server->fingerprint) || (ss &&(ss->enforce_fingerprints))) {
			size_t len = ioa_network_buffer_get_size(nbh);
			stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len);
			ioa_network_buffer_set_size(nbh, len);
		}

		if(server->verbose) {
			log_method(ss, "CONNECTION_BIND", err_code, reason);
		}

		if(ss && !err_code) {
			send_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);
			tcp_deliver_delayed_buffer(&(tc->ub_to_client),s,ss);
			IOA_CLOSE_SOCKET(s_to_delete);
			FUNCEND;
			return 0;
		} else {
			/* Just to set the necessary structures for the packet sending: */
			if(register_callback_on_ioa_socket(server->e, s, IOA_EV_READ, NULL, NULL, 1)<0) {
				TURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, "%s: cannot set TCP tmp client data input callback\n", __FUNCTION__);
				ioa_network_buffer_delete(server->e, nbh);
			} else {
				send_data_from_ioa_socket_nbh(s, NULL, nbh, TTL_IGNORE, TOS_IGNORE, NULL);
			}
		}
	}

	IOA_CLOSE_SOCKET(s_to_delete);

	FUNCEND;
	return -1;
}
