static void lossStatsThreadFunc(void* context) {
    char*lossStatsPayload;
    BYTE_BUFFER byteBuffer;

    lossStatsPayload = malloc(payloadLengths[IDX_LOSS_STATS]);
    if (lossStatsPayload == NULL) {
        Limelog("Loss Stats: malloc() failed\n");
        ListenerCallbacks.connectionTerminated(-1);
        return;
    }

    while (!PltIsThreadInterrupted(&lossStatsThread)) {
        // Construct the payload
        BbInitializeWrappedBuffer(&byteBuffer, lossStatsPayload, 0, payloadLengths[IDX_LOSS_STATS], BYTE_ORDER_LITTLE);
        BbPutInt(&byteBuffer, lossCountSinceLastReport);
        BbPutInt(&byteBuffer, LOSS_REPORT_INTERVAL_MS);
        BbPutInt(&byteBuffer, 1000);
        BbPutLong(&byteBuffer, lastGoodFrame);
        BbPutInt(&byteBuffer, 0);
        BbPutInt(&byteBuffer, 0);
        BbPutInt(&byteBuffer, 0x14);

        // Send the message (and don't expect a response)
        if (!sendMessageAndForget(packetTypes[IDX_LOSS_STATS],
            payloadLengths[IDX_LOSS_STATS], lossStatsPayload)) {
            free(lossStatsPayload);
            Limelog("Loss Stats: Transaction failed: %d\n", (int)LastSocketError());
            ListenerCallbacks.connectionTerminated(LastSocketError());
            return;
        }

        // Clear the transient state
        lossCountSinceLastReport = 0;

        // Wait a bit
        PltSleepMs(LOSS_REPORT_INTERVAL_MS);
    }

    free(lossStatsPayload);
}
