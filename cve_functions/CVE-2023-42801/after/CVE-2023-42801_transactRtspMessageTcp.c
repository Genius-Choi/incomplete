static int transactRtspMessageTcp(PRTSP_MESSAGE request, PRTSP_MESSAGE response, int expectingPayload, int* error) {
    SOCK_RET err;
    int ret = 0;
    int offset;
    char* serializedMessage = NULL;
    int messageLen;

    *error = -1;

    sock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, 48010, RTSP_TIMEOUT_SEC);
    if (sock == INVALID_SOCKET) {
        *error = LastSocketError();
        return ret;
    }
    enableNoDelay(sock);
    setRecvTimeout(sock, RTSP_TIMEOUT_SEC);

    serializedMessage = serializeRtspMessage(request, &messageLen);
    if (serializedMessage == NULL) {
        closeSocket(sock);
        sock = INVALID_SOCKET;
        return ret;
    }

    // Send our message
    err = send(sock, serializedMessage, messageLen, 0);
    if (err == SOCKET_ERROR) {
        *error = LastSocketError();
        Limelog("Failed to send RTSP message: %d\n", *error);
        goto Exit;
    }

    // Read the response until the server closes the connection
    offset = 0;
    for (;;) {
        err = recv(sock, &responseBuffer[offset], RTSP_MAX_RESP_SIZE - offset, 0);
        if (err <= 0) {
            // Done reading
            break;
        }
        offset += err;

        // Warn if the RTSP message is too big
        if (offset == RTSP_MAX_RESP_SIZE) {
            Limelog("RTSP message too long\n");
            goto Exit;
        }
    }

    if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {
        // Successfully parsed response
        ret = 1;
    }
    else {
        Limelog("Failed to parse RTSP response\n");
    }

Exit:
    if (serializedMessage != NULL) {
        free(serializedMessage);
    }

    closeSocket(sock);
    sock = INVALID_SOCKET;
    return ret;
}
