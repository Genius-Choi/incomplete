static void _shrink_window(gnrc_sixlowpan_frag_fb_t *fbuf)
{
    if (!IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {
        /* window does not shrink without congure */
        return;
    }
    if (!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {
        /* we are beyond the congestion window, so shrink it to the new size */
        clist_node_t new_window = { .next = NULL };
        _frag_desc_t *last;

        fbuf->sfr.frags_sent = 0;   /* temporarily reset fragments sent to count them again*/
        /* move all fragments within congestion window into new, temporary list */
        while (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {
            clist_rpush(&new_window, clist_lpop(&fbuf->sfr.window));
            fbuf->sfr.frags_sent++;
        }
        /* free all remaining fragments from old congestion window that did not fit into
         * the shrunk window */
        for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);
             node != NULL; node = clist_lpop(&fbuf->sfr.window)) {
            clist_rpush(&_frag_descs_free, node);
        }
        /* the temporary list is now the new, shrunk window */
        fbuf->sfr.window.next = new_window.next;
        /* recalculate offset for fragmentation header field */
        last = (_frag_desc_t *)clist_rpeek(&fbuf->sfr.window);
        fbuf->offset = last->offset + _frag_size(last);
    }
}
