static void _try_reassembly(gnrc_netif_hdr_t *netif_hdr,
                            gnrc_pktsnip_t *rfrag, unsigned offset,
                            _generic_rb_entry_t *entry,
                            unsigned page)
{
    gnrc_sixlowpan_frag_vrb_t *vrbe;
    const gnrc_sixlowpan_frag_sfr_bitmap_t *bitmap;
    sixlowpan_sfr_rfrag_t *hdr = rfrag->data;
    gnrc_pktsnip_t *netif_snip = rfrag->next;
    /* copy base for ACK */
    sixlowpan_sfr_t base = hdr->base;
    int8_t ack_req = sixlowpan_sfr_rfrag_ack_req(hdr);
    uint8_t seq = sixlowpan_sfr_rfrag_get_seq(hdr);

    assert(netif_snip->data == netif_hdr);
    gnrc_pktbuf_hold(netif_snip, 1);    /* hold netif header to use it with
                                         * dispatch_when_complete()
                                         * (rb_add() releases `pkt`) */
    entry->entry.rb = gnrc_sixlowpan_frag_rb_add(netif_hdr, rfrag,
                                                 offset, page);
    /* check if VRB entry was created */
    vrbe = gnrc_sixlowpan_frag_vrb_get(gnrc_netif_hdr_get_src_addr(netif_hdr),
                                       netif_hdr->src_l2addr_len, base.tag);
    if ((entry->entry.rb == NULL) && (vrbe == NULL)) {
        DEBUG("6lo sfr: can't allocate reassembly buffer or forward compressed "
              "fragment\n");
        /* send abort */
        bitmap = &_null_bitmap;
        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
            _stats.acks.aborts++;
        }
    }
    else if (vrbe != NULL) {
        DEBUG("6lo sfr: packet was forwarded\n");
        goto end;
    }
    else {
        int res;

        DEBUG("6lo sfr: reassembling datagram (%s, %u)\n",
              gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),
                                     netif_hdr->src_l2addr_len, addr_str),
              base.tag);
        entry->type = _RB;
        bf_set(entry->entry.rb->received, seq);
        if ((res = gnrc_sixlowpan_frag_rb_dispatch_when_complete(entry->entry.rb,
                                                                 netif_hdr)) < 0) {
            DEBUG("6lo sfr: can not dispatch datagram to upper layer\n");
            _clean_up_rb_entry(entry);
            /* send abort */
            bitmap = &_null_bitmap;
            if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
                _stats.acks.aborts++;
            }
        }
        else {
            if (res) {
                DEBUG("6lo sfr: dispatched datagram to upper layer\n");
                bitmap = &_full_bitmap;
                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
                    _stats.acks.full++;
                }
            }
            else if (ack_req) {
                DEBUG("6lo sfr: ACKing received fragments %02X%02X%02X%02X "
                      "(%u of %u bytes received)\n",
                      entry->entry.rb->received[0],
                      entry->entry.rb->received[1],
                      entry->entry.rb->received[2],
                      entry->entry.rb->received[3],
                      entry->entry.base->current_size,
                      entry->entry.base->datagram_size);
                bitmap = _get_bitmap(entry->entry.rb);
                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
                    _stats.acks.partly++;
                }
            }
            else {
                /* no ACK was requested and no error was causing an abort ACK*/
                DEBUG("6lo sfr: no ACK requested by received fragment %u "
                      "(bitmap so far: %02X%02X%02X%02X)\n", seq,
                      entry->entry.rb->received[0],
                      entry->entry.rb->received[1],
                      entry->entry.rb->received[2],
                      entry->entry.rb->received[3]);
                goto end;
            }
        }
    }
    _send_ack(gnrc_netif_hdr_get_netif(netif_hdr),
              gnrc_netif_hdr_get_src_addr(netif_hdr),
              netif_hdr->src_l2addr_len, &base, bitmap->bf);
end:
    gnrc_pktbuf_release(netif_snip);    /* release hold */
}
