static Jsi_RC InfoKeywordsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    bool isSql = 0;
    Jsi_Value* vsql = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 1);
    const char *str = NULL;
    if (vsql && Jsi_ValueGetBoolean(interp, vsql, &isSql) != JSI_OK)
            return Jsi_LogError("arg1: expected bool 'isSql'");
    if (val) {
        str = Jsi_ValueString(interp, val, NULL);
        if (!str)
            return Jsi_LogError("arg2: expected string 'name'");
    }

    if (!str) {
        if (!isSql) {
            if (interp->lexkeyTbl) {
                Jsi_HashKeysDump(interp, interp->lexkeyTbl, ret, 0);
                Jsi_ValueArraySort(interp, *ret, 0);
            }
        } else {
            Jsi_DString dStr = {};
            int vargc; char **vargv;
            Jsi_SplitStr(jsi_SqlKeysWords+1, &vargc, &vargv, ",", &dStr);
            Jsi_ValueMakeArrayObject(interp, ret, NULL);
            Jsi_Obj *obj = (*ret)->d.obj;
            int i;
            for (i = 0; i < (vargc-1); ++i)
                Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, vargv[i]), i);
            Jsi_DSFree(&dStr);
        }
        return JSI_OK;
    }
    Jsi_ValueMakeBool(interp, ret, Jsi_IsReserved(interp, str, isSql));
    return JSI_OK;
}
