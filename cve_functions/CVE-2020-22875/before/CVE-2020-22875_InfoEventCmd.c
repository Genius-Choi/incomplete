static Jsi_RC InfoEventCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    uint n = 0;
    int nid;
    Jsi_HashEntry *hPtr;
    Jsi_HashSearch search;
    Jsi_Obj *nobj;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    
    if (arg && Jsi_GetIntFromValue(interp, arg, &nid) != JSI_OK)
        return JSI_ERROR;
    if (!arg) {
        nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeArrayObject(interp, ret, nobj);
    }

    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);
        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {
        uintptr_t id;
        id = (uintptr_t)Jsi_HashKeyGet(hPtr);
        if (!arg) {
            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewNumber(interp, (Jsi_Number)id), n);
            n++;
        } else if (id == (uint)nid) {
            Jsi_Event *evPtr = (Jsi_Event *)Jsi_HashValueGet(hPtr);
            Jsi_DString dStr;
            if (!evPtr) return JSI_ERROR;
            Jsi_DSInit(&dStr);
            switch (evPtr->evType) {
                case JSI_EVENT_SIGNAL:
                    Jsi_DSPrintf(&dStr, "{ type:\"signal\", sigNum:%d, count:%u, builtin:%s, busy:%s }", 
                        evPtr->sigNum, evPtr->count, (evPtr->handler?"true":"false"),
                        (evPtr->busy?"true":"false") );
                    break;
                case JSI_EVENT_TIMER: {
             
                    long cur_sec, cur_ms;
                    uint64_t ms;
                    jsiGetTime(&cur_sec, &cur_ms);
                    ms = (evPtr->when_sec*1000LL + evPtr->when_ms) - (cur_sec * 1000LL + cur_ms);
                    Jsi_DSPrintf(&dStr, "{ type:\"timer\", once:%s, when:%" PRId64 ", count:%u, initial:%" PRId64 ", builtin:%s, busy:%s }",
                        evPtr->once?"true":"false", (Jsi_Wide)ms, evPtr->count, (Jsi_Wide)evPtr->initialms, (evPtr->handler?"true":"false"),
                        (evPtr->busy?"true":"false") );
                    break;
                }
                case JSI_EVENT_ALWAYS:
                    Jsi_DSPrintf(&dStr, "{ type:\"always\", count:%u, builtin:%s, busy:%s }", 
                        evPtr->count, (evPtr->handler?"true":"false"), (evPtr->busy?"true":"false") );
                    break;
            }
            Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);
            Jsi_DSFree(&dStr);
            return rc;
        }
    }
    return JSI_OK;
}
