static Jsi_RC DateStrftimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value* opt = Jsi_ValueArrayIndex(interp, args, 1);
    const char *fmt = NULL;//, *cp = NULL;
    DateOpts opts = {};
    Jsi_Number num;
    int isOpt = 0;
    Jsi_RC rc = JSI_OK;
    Jsi_DString dStr;
    Jsi_DSInit(&dStr);
    
    if (val==NULL || Jsi_ValueIsNull(interp, val)) {
        //num = 1000.0 * (Jsi_Number)time(NULL);
        struct timeval tv;
        gettimeofday(&tv, NULL);
        num = tv.tv_sec*1000LL + ((Jsi_Wide)tv.tv_usec)/1000LL;

   /* } else if ((cp=Jsi_ValueString(interp, val, NULL))) {*/
        /* Handle below */
    } else if (Jsi_GetDoubleFromValue(interp, val, &num) != JSI_OK)
        return JSI_ERROR;
        
    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {
        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {
            return JSI_ERROR;
        }
        isOpt = 1;
        fmt = opts.fmt;
        if (opts.iso) {
            if (fmt)
                return Jsi_LogError("Do not use both iso and fmt");
            fmt = "%FT%T.%f";
        }
    }
    const char *errMsg = "time format error";
/*    if (cp) {
        if (isdigit(*cp))
            rc = Jsi_GetDouble(interp, cp, &num);
        else {
            if (Jsi_Strcmp(cp,"now")==0) {
                num = Jsi_DateTime();
            } else {
                rc = JSI_ERROR;
                errMsg = "allowable strings are 'now' or digits";
            }
        }
    }*/
    if (rc == JSI_OK) {
        if (opts.secs)
            num = (Jsi_Number)((Jsi_Wide)(num*1000));
        rc = Jsi_DatetimeFormat(interp, num, fmt, opts.utc, &dStr);
    }
    if (rc != JSI_OK)
        Jsi_LogError("%s", errMsg);
    else
        Jsi_ValueFromDS(interp, &dStr, ret);
    if (isOpt)
        Jsi_OptionsFree(interp, DateOptions, &opts, 0);
    Jsi_DSFree(&dStr);
    return rc;
}
