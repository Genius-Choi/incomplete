static Jsi_RC SysParseOptsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args, 0),
    *v2 = Jsi_ValueArrayIndex(interp, args, 1),
    *v3 = Jsi_ValueArrayIndex(interp, args, 2);
    if (!v1 || !Jsi_ValueIsObjType(interp, v1, JSI_OT_OBJECT))
        return Jsi_LogError("arg 1: expected object 'self'");
    if (!v2 || !Jsi_ValueIsObjType(interp, v2, JSI_OT_OBJECT))
        return Jsi_LogError("arg 2: expected object 'options'");

    Jsi_TreeEntry *tPtr, *tPtr2;
    Jsi_TreeSearch search;
    for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);
        tPtr; tPtr = Jsi_TreeSearchNext(&search)) {
        Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
        if (v==NULL) continue;
        const char *key = (char*)Jsi_TreeKeyGet(tPtr);
        if (!Jsi_ValueObjLookup(interp, v1, key, 1))
            Jsi_ObjInsert(interp, v1->d.obj, key, v, 0);
    }
    Jsi_TreeSearchDone(&search);
    Jsi_RC rc = JSI_OK;

    if (!v3 || Jsi_ValueIsNull(interp, v3) || Jsi_ValueIsUndef(interp, v3)) {
        //return JSI_OK;
    } else {
        //bool isArr = Jsi_ValueIsObjType(interp, v3, JSI_OT_ARRAY);
        if (!Jsi_ValueIsObjType(interp, v3, JSI_OT_OBJECT))
            return Jsi_LogError("arg 3: expected object|null");
    
        Jsi_Value *oVal;
        int cnt = 0;
        for (tPtr = Jsi_TreeSearchFirst(v3->d.obj->tree, &search, 0, NULL);
            tPtr && rc == JSI_OK; tPtr = Jsi_TreeSearchNext(&search)) {
            Jsi_Value *val;
            const char *key;
            cnt++;
            val = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
            key = (char*)Jsi_TreeKeyGet(tPtr);
            if (!val || !key) continue;
            if (Jsi_ValueIsUndef(interp, val)) {
                rc = Jsi_LogError("value undefined for arg: '%s'", key);
                break;
            }

            if (cnt == 1 && !Jsi_Strcmp(key, "help") && v3->d.obj->tree->numEntries==1) {
                int isLong = 1;//Jsi_ValueIsTrue(interp, val);
                const char *help = "", *es = NULL, *fstr = NULL, *fname = interp->framePtr->ip->fname;
                Jsi_TreeSearchDone(&search);
                if (fname) {
                    jsi_FileInfo  *fi = (typeof(fi))Jsi_HashGet(interp->fileTbl, fname, 0);
                    fstr = fi->str;
                }
                if (!fstr)
                    fstr = interp->framePtr->ps->lexer->d.str;
                Jsi_DString dStr = {}, hStr = {}, vStr = {};
                if (fstr) fstr = Jsi_Strstr(fstr, "var options = ");
                if (fstr) fstr = Jsi_Strchr(fstr, '{');
                if (fstr) es = Jsi_Strchr(fstr, '\n');
                if (es) {
                    help = Jsi_DSAppendLen(&hStr, fstr+1, es-fstr-1);
                    fstr = es;
                }
                const char *mod = (fname?fname:interp->framePtr->fileName);
                if (mod && (mod = Jsi_Strrchr(mod, '/')))
                    mod++;
                while (help && isspace(help[0])) help++;
                while (help && help[0] == '/') help++;
                while (help && isspace(help[0])) help++;
                if (isLong)
                    Jsi_DSPrintf(&dStr, "\n%s.  Options are:\n", help);
                else
                    Jsi_DSPrintf(&dStr, "\n%s.  Options are:\n    ", help);
                for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);
                    tPtr; tPtr = Jsi_TreeSearchNext(&search)) {
                    Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);
                    const char *vstr, *key = (char*)Jsi_TreeKeyGet(tPtr);
                    if (!v || !key) continue;
                    help = jsi_FindHelpStr(fstr, key, &hStr);
                    int vlen, klen = Jsi_Strlen(key);
                    Jsi_DSSetLength(&vStr, 0);
                    vstr = Jsi_ValueGetDString(interp, v, &vStr, 1);
                    vlen = Jsi_Strlen(vstr);
                    if (!isLong)
                        Jsi_DSPrintf(&dStr, " -%s", key);
                    else
                        Jsi_DSPrintf(&dStr, "\t-%s%s\t%s\t%s%s\n", key, (klen<7?"\t":""), vstr, (vlen<7?"\t":""), help);
                }
                if (isLong)
                    Jsi_DSAppend(&dStr, "\nAccepted by all .jsi modules: -Debug, -Trace, -Test.", NULL);
                else
                    Jsi_DSAppend(&dStr, "\nUse -help for long help.", NULL);
                rc = JSI_BREAK;
                Jsi_ValueFromDS(interp, &dStr, ret);
                Jsi_DSFree(&hStr);
                Jsi_DSFree(&vStr);
                break;
            }
            Jsi_vtype oTyp, vTyp = jsi_getValType(val);
            if (!Jsi_Strcmp(key, "Debug") || !Jsi_Strcmp(key, "Test") || !Jsi_Strcmp(key, "Trace")) {
                oTyp = JSI_VT_BOOL; // Accept these 3 as builtin options.
                oVal = NULL;
            } else if (!(tPtr2=Jsi_TreeEntryFind(v2->d.obj->tree, key)) || !(oVal = (Jsi_Value*)Jsi_TreeValueGet(tPtr2))) {
                Jsi_TreeSearchDone(&search);
                Jsi_DString dStr = {};
                int cnt = 0;
                for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);
                    tPtr; tPtr = Jsi_TreeSearchNext(&search)) {
                    const char *key = (char*)Jsi_TreeKeyGet(tPtr);
                    if (!key) continue;
                    cnt++;
                    Jsi_DSAppend(&dStr, (cnt>1?", ":""), key, NULL);
                }
                Jsi_LogType("\nUnknown option: \"%s\" is not one of:\n  %s\n\n", key, Jsi_DSValue(&dStr));
                rc = JSI_BREAK;
                Jsi_DSFree(&dStr);
                break;
            } else {
                oTyp = jsi_getValType(oVal);
            }
            switch (oTyp) {
                case JSI_VT_UNDEF:
                case JSI_VT_NULL:
                    break;
                default:
                    if (oTyp != vTyp) {
                        rc = Jsi_LogError("type mismatch for '%s': '%s' is not a %s",
                            key, jsi_ValueTypeName(interp, val), (oVal?jsi_ValueTypeName(interp, oVal):"boolean"));
                    }
            }
            if (rc == JSI_OK)
                Jsi_ObjInsert(interp, v1->d.obj, key, val, 0);
        }
        Jsi_TreeSearchDone(&search);
    }
    if (rc == JSI_OK) {
        jsi_Frame *fptr = interp->framePtr;
        Jsi_Func *pf = interp->prevActiveFunc;
        Jsi_ModuleConf *mo = NULL;
        if (pf && pf->pkg)
            mo = &pf->pkg->popts.modConf;
        if (jsi_ModLogEnabled(interp, v1, "Debug") || (mo && mo->Debug)) {
            jsi_evalStrFile(interp, NULL, "this.LogDebug = console.log.bind(null, 'DEBUG:');", 0, fptr->level);
            fptr->logflag |= (1<<jsi_Oplf_debug);
        }
        if (jsi_ModLogEnabled(interp, v1, "Trace") || (mo && mo->Trace)) {
            jsi_evalStrFile(interp, NULL, "this.LogTrace = console.log.bind(null, 'TRACE:');", 0, fptr->level);
            fptr->logflag |= (1<<jsi_Oplf_trace);
        }
        if (jsi_ModLogEnabled(interp, v1, "Test") || (mo && mo->Test)) {
            jsi_evalStrFile(interp, NULL, "this.LogTest = console.log.bind(null, 'TEST: ');", 0, fptr->level);
            fptr->logflag |= (1<<jsi_Oplf_test);
        }
    }
    return rc;
}
