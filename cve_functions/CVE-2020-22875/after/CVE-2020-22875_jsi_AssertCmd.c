Jsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (!interp->asserts)
        return JSI_OK;
    int rc = 0;
    Jsi_RC rv = JSI_OK;
    Jsi_Number d;
    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);
    const char *msg = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);
    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 2);
    //int hasopts = 0;
    bool b;
    AssertData udata = {
        .mode=interp->assertMode,
        .noStderr=interp->noStderr
    };
    
    if (opts != NULL) {
        if (opts->vt == JSI_VT_OBJECT) {
            //hasopts = 1;
            if (Jsi_OptionsProcess(interp, AssertOptions, &udata, opts, 0) < 0) {
                return JSI_ERROR;
            }
        } else //if (opts->vt != JSI_VT_NULL)
            return Jsi_LogError("arg 3: expected object 'options'");
    }

    if (Jsi_ValueGetNumber(interp,v, &d) == JSI_OK)
        rc = (int)d;
    else if (Jsi_ValueGetBoolean(interp,v, &b) == JSI_OK)
        rc = b;
    else if (Jsi_ValueIsFunction(interp, v)) {
        if (!msg) {
        }
        Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));
        Jsi_IncrRefCount(interp, vpargs);
        rc = Jsi_FunctionInvoke(interp, v, vpargs, ret, NULL);
        Jsi_DecrRefCount(interp, vpargs);
        if (rc != JSI_OK)
            return JSI_OK;
        bool b;
        if (Jsi_ValueGetNumber(interp, *ret, &d) == JSI_OK)
            rc = (int)d;
        else if (Jsi_ValueGetBoolean(interp, *ret, &b) == JSI_OK)
            rc = b;
        else 
            return Jsi_LogError("invalid function assert");
    } else 
        return Jsi_LogError("invalid assert");
    if (rc == 0) {
        char mbuf[1024];
        mbuf[0] = 0;
        if (!msg) {
            char *ce, *cp = jsi_GetCurPSLine(interp);
            if (cp) {
                cp = Jsi_Strstr(cp, "assert(");
                while (cp && *cp && isspace(*cp)) cp++;
                if (cp) {
                    Jsi_Strncpy(mbuf, cp, sizeof(mbuf)-1);
                    mbuf[sizeof(mbuf)-1] = 0;
                    ce=Jsi_Strstr(mbuf, ");");
                    if (ce) {
                        ce[1] = 0;
                        msg = mbuf;
                    }
                }
            }
            if (!msg)
                msg = "ASSERT";
        }
        //Jsi_ValueDup2(interp, ret, v);
        if (udata.mode != jsi_AssertModeThrow) {
            Jsi_DString dStr;
            jsi_LogOptions lo = {}, *loPtr = ((udata.mode==jsi_AssertModeLog || interp->tracePuts)?&interp->logOpts:&lo);
            Jsi_DSInit(&dStr);
            const char *imsg = Jsi_DSAppend(&dStr, msg, NULL);
            SysPutsCmd_(interp, NULL, _this, ret, funcPtr, !udata.noStderr, loPtr, imsg, 0);
            Jsi_DSFree(&dStr);
        } else
            rv = Jsi_LogError("%s", msg);
    }
    Jsi_ValueMakeUndef(interp, ret);
    return rv;
}
