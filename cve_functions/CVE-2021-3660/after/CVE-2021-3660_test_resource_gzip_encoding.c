test_resource_gzip_encoding (TestResourceCase *tc,
                             gconstpointer data)
{
  CockpitWebResponse *response;
  GError *error = NULL;
  GBytes *bytes;
  gconstpointer str;
  const gchar *expected = "HTTP/1.1 200 OK\r\n"
    STATIC_HEADERS
    "Content-Encoding: gzip\r\n"
    "Cache-Control: no-cache, no-store\r\n"
    "Access-Control-Allow-Origin: http://localhost\r\n"
    "Content-Type: text/plain\r\n"
    "Transfer-Encoding: chunked\r\n"
    "Vary: Cookie\r\n"
    "\r\n"
    "34\r\n"
    "\x1F\x8B\x08\x08N1\x03U\x00\x03test-file.txt\x00sT(\xCEM\xCC\xC9Q(I-"
    ".QH\xCB\xCCI\xE5\x02\x00>PjG\x12\x00\x00\x00\x0D\x0A"
    "0\x0D\x0A\x0D\x0A";

  response = cockpit_web_response_new (tc->io, "/unused", "/unused", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);

  cockpit_channel_response_serve (tc->service, tc->headers, response, "@localhost", "/another/test-file.txt");

  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)
    g_main_context_iteration (NULL, TRUE);

  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);
  g_assert_no_error (error);

  bytes = g_memory_output_stream_steal_as_bytes (tc->output);
  str = g_bytes_get_data (bytes, NULL);
  g_assert (str_contains_strv (str, expected, "\n"));
  cockpit_assert_strmatch (str,
                           "*\r\n"
                           "34\r\n"
                           "\x1F\x8B\x08\x08N1\x03U\x00\x03test-file.txt\x00sT(\xCEM\xCC\xC9Q(I-"
                           ".QH\xCB\xCCI\xE5\x02\x00>PjG\x12\x00\x00\x00\x0D\x0A"
                           "0\x0D\x0A\x0D\x0A");

  g_bytes_unref (bytes);
  g_object_unref (response);
}
