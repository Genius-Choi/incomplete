setup_resource (TestResourceCase *tc,
                gconstpointer data)
{
  const TestResourceFixture *fixture = data;
  CockpitTransport *transport;
  GInputStream *input;
  GOutputStream *output;
  CockpitCreds *creds;
  gchar **environ;
  const gchar *user;
  const gchar *home = NULL;
  gboolean ready = FALSE;
  GBytes *password;
  gulong handler;

  const gchar *argv[] = {
    BUILDDIR "/cockpit-bridge",
    NULL
  };

  environ = g_get_environ ();
  environ = g_environ_setenv (environ, "XDG_DATA_DIRS", SRCDIR "/src/bridge/mock-resource/system", TRUE);

  if (fixture)
    home = fixture->xdg_data_home;
  if (!home)
    home = SRCDIR "/src/bridge/mock-resource/home";
  environ = g_environ_setenv (environ, "XDG_DATA_HOME", home, TRUE);

  /* Start up a cockpit-bridge here */
  tc->pipe = cockpit_pipe_spawn (argv, (const gchar **)environ, NULL, COCKPIT_PIPE_FLAGS_NONE);

  g_strfreev (environ);

  user = g_get_user_name ();
  password = g_bytes_new_take (g_strdup (PASSWORD), strlen (PASSWORD));
  creds = cockpit_creds_new ("cockpit", COCKPIT_CRED_USER, user, COCKPIT_CRED_PASSWORD, password, NULL);
  g_bytes_unref (password);

  transport = cockpit_pipe_transport_new (tc->pipe);
  tc->service = cockpit_web_service_new (creds, transport);

  /* Manually created services won't be init'd yet, wait for that before sending data */
  handler = g_signal_connect (transport, "control", G_CALLBACK (on_transport_control), &ready);

  while (!ready)
    g_main_context_iteration (NULL, TRUE);

  g_object_unref (transport);

  cockpit_creds_unref (creds);

  input = g_memory_input_stream_new_from_data ("", 0, NULL);
  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);
  tc->io = mock_io_stream_new (input, output);
  tc->output = G_MEMORY_OUTPUT_STREAM (output);
  g_object_unref (input);

  tc->headers = cockpit_web_server_new_table ();
  g_hash_table_insert (tc->headers, g_strdup ("Accept-Encoding"), g_strdup ("gzip, identity"));

  g_signal_handler_disconnect (transport, handler);
}
