X509_verify_cert_legacy_build_chain(X509_STORE_CTX *ctx, int *bad, int *out_ok)
{
	X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
	int bad_chain = 0;
	X509_VERIFY_PARAM *param = ctx->param;
	int ok = 0, ret = 0;
	int depth, i;
	int num, j, retry, trust;
	int (*cb) (int xok, X509_STORE_CTX *xctx);
	STACK_OF(X509) *sktmp = NULL;

	cb = ctx->verify_cb;

	/*
	 * First we make sure the chain we are going to build is
	 * present and that the first entry is in place.
	 */
	ctx->chain = sk_X509_new_null();
	if (ctx->chain == NULL || !sk_X509_push(ctx->chain, ctx->cert)) {
		X509error(ERR_R_MALLOC_FAILURE);
		ctx->error = X509_V_ERR_OUT_OF_MEM;
		goto end;
	}
	X509_up_ref(ctx->cert);
	ctx->num_untrusted = 1;

	/* We use a temporary STACK so we can chop and hack at it */
	if (ctx->untrusted != NULL &&
	    (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
		X509error(ERR_R_MALLOC_FAILURE);
		ctx->error = X509_V_ERR_OUT_OF_MEM;
		goto end;
	}

	num = sk_X509_num(ctx->chain);
	x = sk_X509_value(ctx->chain, num - 1);
	depth = param->depth;

	for (;;) {
		/* If we have enough, we break */
		/* FIXME: If this happens, we should take
		 * note of it and, if appropriate, use the
		 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
		 * later.
		 */
		if (depth < num)
			break;
		/* If we are self signed, we break */
		if (cert_self_signed(x))
			break;
		/*
		 * If asked see if we can find issuer in trusted store first
		 */
		if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {
			ok = ctx->get_issuer(&xtmp, ctx, x);
			if (ok < 0) {
				ctx->error = X509_V_ERR_STORE_LOOKUP;
				goto end;
			}
			/*
			 * If successful for now free up cert so it
			 * will be picked up again later.
			 */
			if (ok > 0) {
				X509_free(xtmp);
				break;
			}
		}
		/* If we were passed a cert chain, use it first */
		if (ctx->untrusted != NULL) {
			/*
			 * If we do not find a non-expired untrusted cert, peek
			 * ahead and see if we can satisify this from the trusted
			 * store. If not, see if we have an expired untrusted cert.
			 */
			xtmp = find_issuer(ctx, sktmp, x, 0);
			if (xtmp == NULL &&
			    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)) {
				ok = ctx->get_issuer(&xtmp, ctx, x);
				if (ok < 0) {
					ctx->error = X509_V_ERR_STORE_LOOKUP;
					goto end;
				}
				if (ok > 0) {
					X509_free(xtmp);
					break;
				}
				xtmp = find_issuer(ctx, sktmp, x, 1);
			}
			if (xtmp != NULL) {
				if (!sk_X509_push(ctx->chain, xtmp)) {
					X509error(ERR_R_MALLOC_FAILURE);
					ctx->error = X509_V_ERR_OUT_OF_MEM;
					ok = 0;
					goto end;
				}
				X509_up_ref(xtmp);
				(void)sk_X509_delete_ptr(sktmp, xtmp);
				ctx->num_untrusted++;
				x = xtmp;
				num++;
				/*
				 * reparse the full chain for the next one
				 */
				continue;
			}
		}
		break;
	}
	/* Remember how many untrusted certs we have */
	j = num;

	/*
	 * At this point, chain should contain a list of untrusted
	 * certificates.  We now need to add at least one trusted one,
	 * if possible, otherwise we complain.
	 */

	do {
		/*
		 * Examine last certificate in chain and see if it is
		 * self signed.
		 */
		i = sk_X509_num(ctx->chain);
		x = sk_X509_value(ctx->chain, i - 1);
		if (cert_self_signed(x)) {
			/* we have a self signed certificate */
			if (i == 1) {
				/*
				 * We have a single self signed
				 * certificate: see if we can find it
				 * in the store. We must have an exact
				 * match to avoid possible
				 * impersonation.
				 */
				ok = ctx->get_issuer(&xtmp, ctx, x);
				if ((ok <= 0) || X509_cmp(x, xtmp)) {
					ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
					ctx->current_cert = x;
					ctx->error_depth = i - 1;
					if (ok == 1)
						X509_free(xtmp);
					bad_chain = 1;
					ok = cb(0, ctx);
					if (!ok)
						goto end;
				} else {
					/*
					 * We have a match: replace
					 * certificate with store
					 * version so we get any trust
					 * settings.
					 */
					X509_free(x);
					x = xtmp;
					(void)sk_X509_set(ctx->chain, i - 1, x);
					ctx->num_untrusted = 0;
				}
			} else {
				/*
				 * extract and save self signed
				 * certificate for later use
				 */
				chain_ss = sk_X509_pop(ctx->chain);
				ctx->num_untrusted--;
				num--;
				j--;
				x = sk_X509_value(ctx->chain, num - 1);
			}
		}
		/* We now lookup certs from the certificate store */
		for (;;) {
			/* If we have enough, we break */
			if (depth < num)
				break;
			/* If we are self signed, we break */
			if (cert_self_signed(x))
				break;
			ok = ctx->get_issuer(&xtmp, ctx, x);

			if (ok < 0) {
				ctx->error = X509_V_ERR_STORE_LOOKUP;
				goto end;
			}
			if (ok == 0)
				break;
			x = xtmp;
			if (!sk_X509_push(ctx->chain, x)) {
				X509_free(xtmp);
				X509error(ERR_R_MALLOC_FAILURE);
				ctx->error = X509_V_ERR_OUT_OF_MEM;
				ok = 0;
				goto end;
			}
			num++;
		}

		/* we now have our chain, lets check it... */
		trust = check_trust(ctx);

		/* If explicitly rejected error */
		if (trust == X509_TRUST_REJECTED) {
			ok = 0;
			goto end;
		}
		/*
		 * If it's not explicitly trusted then check if there
		 * is an alternative chain that could be used. We only
		 * do this if we haven't already checked via
		 * TRUSTED_FIRST and the user hasn't switched off
		 * alternate chain checking
		 */
		retry = 0;
		if (trust != X509_TRUST_TRUSTED &&
		    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) &&
		    !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
			while (j-- > 1) {
				xtmp2 = sk_X509_value(ctx->chain, j - 1);
				ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
				if (ok < 0)
					goto end;
				/* Check if we found an alternate chain */
				if (ok > 0) {
					/*
					 * Free up the found cert
					 * we'll add it again later
					 */
					X509_free(xtmp);
					/*
					 * Dump all the certs above
					 * this point - we've found an
					 * alternate chain
					 */
					while (num > j) {
						xtmp = sk_X509_pop(ctx->chain);
						X509_free(xtmp);
						num--;
					}
					ctx->num_untrusted = sk_X509_num(ctx->chain);
					retry = 1;
					break;
				}
			}
		}
	} while (retry);

	/*
	 * If not explicitly trusted then indicate error unless it's a single
	 * self signed certificate in which case we've indicated an error already
	 * and set bad_chain == 1
	 */
	if (trust != X509_TRUST_TRUSTED && !bad_chain) {
		if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
			if (ctx->num_untrusted >= num)
				ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
			else
				ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
			ctx->current_cert = x;
		} else {
			if (!sk_X509_push(ctx->chain, chain_ss)) {
				X509error(ERR_R_MALLOC_FAILURE);
				ctx->error = X509_V_ERR_OUT_OF_MEM;
				ok = 0;
				goto end;
			}
			num++;
			ctx->num_untrusted = num;
			ctx->current_cert = chain_ss;
			ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
			chain_ss = NULL;
		}

		ctx->error_depth = num - 1;
		bad_chain = 1;
		ok = cb(0, ctx);
		if (!ok)
			goto end;
	}

	ret = 1;
 end:
	sk_X509_free(sktmp);
	X509_free(chain_ss);
	*bad = bad_chain;
	*out_ok = ok;

	return ret;
}
