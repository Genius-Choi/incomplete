x509_verify_chain_append(struct x509_verify_chain *chain, X509 *cert,
    int *error)
{
	int verify_err = X509_V_ERR_UNSPECIFIED;
	size_t idx;

	if (!x509_constraints_extract_names(chain->names, cert,
	    sk_X509_num(chain->certs) == 0, &verify_err)) {
		*error = verify_err;
		return 0;
	}

	X509_up_ref(cert);
	if (!sk_X509_push(chain->certs, cert)) {
		X509_free(cert);
		*error = X509_V_ERR_OUT_OF_MEM;
		return 0;
	}

	idx = sk_X509_num(chain->certs) - 1;
	chain->cert_errors[idx] = *error;

	/*
	 * We've just added the issuer for the previous certificate,
	 * clear its error if appropriate.
	 */
	if (idx > 1 && chain->cert_errors[idx - 1] ==
	    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
		chain->cert_errors[idx - 1] = X509_V_OK;

	return 1;
}
