void CScreencopyPortal::onStart(sdbus::MethodCall& call) {
    sdbus::ObjectPath requestHandle, sessionHandle;

    call >> requestHandle;
    call >> sessionHandle;

    std::string appID, parentWindow;
    call >> appID;
    call >> parentWindow;

    Debug::log(LOG, "[screencopy] Start:");
    Debug::log(LOG, "[screencopy]  | {}", requestHandle.c_str());
    Debug::log(LOG, "[screencopy]  | {}", sessionHandle.c_str());
    Debug::log(LOG, "[screencopy]  | appid: {}", appID);
    Debug::log(LOG, "[screencopy]  | parent_window: {}", parentWindow);

    const auto PSESSION = getSession(sessionHandle);

    if (!PSESSION) {
        Debug::log(ERR, "[screencopy] Start: no session found??");
        auto reply = call.createErrorReply(sdbus::Error{"NOSESSION", "No session found"});
        reply << (uint32_t)1;
        reply.send();
        return;
    }

    startSharing(PSESSION);

    auto reply = call.createReply();
    reply << (uint32_t)0;

    std::unordered_map<std::string, sdbus::Variant> options;

    if (PSESSION->persistMode != 0 && PSESSION->selection.allowToken) {
        // give them a token :)
        std::unordered_map<std::string, sdbus::Variant> mapData;

        switch (PSESSION->selection.type) {
            case TYPE_GEOMETRY:
            case TYPE_OUTPUT: mapData["output"] = PSESSION->selection.output; break;
            case TYPE_WINDOW:
                mapData["windowHandle"] = (uint64_t)PSESSION->selection.windowHandle;
                for (auto& w : g_pPortalManager->m_sHelpers.toplevel->m_vToplevels) {
                    if (w->handle == PSESSION->selection.windowHandle) {
                        mapData["windowClass"] = w->windowClass;
                        break;
                    }
                }
                break;
            default: Debug::log(ERR, "[screencopy] wonk selection in token saving"); break;
        }
        mapData["timeIssued"] = uint64_t(time(nullptr));
        mapData["token"]      = std::string("todo");
        mapData["withCursor"] = PSESSION->cursorMode;

        sdbus::Variant                                       restoreData{mapData};
        sdbus::Struct<std::string, uint32_t, sdbus::Variant> fullRestoreStruct{"hyprland", 3, restoreData};
        options["restore_data"] = sdbus::Variant{fullRestoreStruct};

        Debug::log(LOG, "[screencopy] Sent restore token to {}", PSESSION->sessionHandle.c_str());
    }

    uint32_t type = 0;
    switch (PSESSION->selection.type) {
        case TYPE_OUTPUT: type = 1 << MONITOR; break;
        case TYPE_WINDOW: type = 1 << WINDOW; break;
        case TYPE_GEOMETRY:
        case TYPE_WORKSPACE: type = 1 << VIRTUAL; break;
        default: type = 0; break;
    }
    options["source_type"] = type;

    std::vector<sdbus::Struct<uint32_t, std::unordered_map<std::string, sdbus::Variant>>> streams;

    std::unordered_map<std::string, sdbus::Variant>                                       streamData;
    streamData["position"]    = sdbus::Variant{sdbus::Struct<int32_t, int32_t>{0, 0}};
    streamData["size"]        = sdbus::Variant{sdbus::Struct<int32_t, int32_t>{PSESSION->sharingData.frameInfoSHM.w, PSESSION->sharingData.frameInfoSHM.h}};
    streamData["source_type"] = sdbus::Variant{uint32_t{type}};
    streams.emplace_back(sdbus::Struct<uint32_t, std::unordered_map<std::string, sdbus::Variant>>{PSESSION->sharingData.nodeID, streamData});

    options["streams"] = streams;

    reply << options;

    reply.send();
}
