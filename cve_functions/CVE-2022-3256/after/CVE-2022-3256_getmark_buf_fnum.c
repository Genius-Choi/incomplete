getmark_buf_fnum(
    buf_T	*buf,
    int		c,
    int		changefile,
    int		*fnum)
{
    pos_T		*posp;
    pos_T		*startp, *endp;
    static pos_T	pos_copy;

    posp = NULL;

    // Check for special key, can't be a mark name and might cause islower()
    // to crash.
    if (c < 0)
	return posp;
    if (c > '~')			// check for islower()/isupper()
	;
    else if (c == '\'' || c == '`')	// previous context mark
    {
	pos_copy = curwin->w_pcmark;	// need to make a copy because
	posp = &pos_copy;		//   w_pcmark may be changed soon
    }
    else if (c == '"')			// to pos when leaving buffer
	posp = &(buf->b_last_cursor);
    else if (c == '^')			// to where Insert mode stopped
	posp = &(buf->b_last_insert);
    else if (c == '.')			// to where last change was made
	posp = &(buf->b_last_change);
    else if (c == '[')			// to start of previous operator
	posp = &(buf->b_op_start);
    else if (c == ']')			// to end of previous operator
	posp = &(buf->b_op_end);
    else if (c == '{' || c == '}')	// to previous/next paragraph
    {
	pos_T	pos;
	oparg_T	oa;
	int	slcb = listcmd_busy;

	pos = curwin->w_cursor;
	listcmd_busy = TRUE;	    // avoid that '' is changed
	if (findpar(&oa.inclusive,
			       c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE))
	{
	    pos_copy = curwin->w_cursor;
	    posp = &pos_copy;
	}
	curwin->w_cursor = pos;
	listcmd_busy = slcb;
    }
    else if (c == '(' || c == ')')	// to previous/next sentence
    {
	pos_T	pos;
	int	slcb = listcmd_busy;

	pos = curwin->w_cursor;
	listcmd_busy = TRUE;	    // avoid that '' is changed
	if (findsent(c == ')' ? FORWARD : BACKWARD, 1L))
	{
	    pos_copy = curwin->w_cursor;
	    posp = &pos_copy;
	}
	curwin->w_cursor = pos;
	listcmd_busy = slcb;
    }
    else if (c == '<' || c == '>')	// start/end of visual area
    {
	startp = &buf->b_visual.vi_start;
	endp = &buf->b_visual.vi_end;
	if (((c == '<') == LT_POS(*startp, *endp) || endp->lnum == 0)
							  && startp->lnum != 0)
	    posp = startp;
	else
	    posp = endp;
	/*
	 * For Visual line mode, set mark at begin or end of line
	 */
	if (buf->b_visual.vi_mode == 'V')
	{
	    pos_copy = *posp;
	    posp = &pos_copy;
	    if (c == '<')
		pos_copy.col = 0;
	    else
		pos_copy.col = MAXCOL;
	    pos_copy.coladd = 0;
	}
    }
    else if (ASCII_ISLOWER(c))		// normal named mark
    {
	posp = &(buf->b_namedm[c - 'a']);
    }
    else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))	// named file mark
    {
	if (VIM_ISDIGIT(c))
	    c = c - '0' + NMARKS;
	else
	    c -= 'A';
	posp = &(namedfm[c].fmark.mark);

	if (namedfm[c].fmark.fnum == 0)
	    fname2fnum(&namedfm[c]);

	if (fnum != NULL)
	    *fnum = namedfm[c].fmark.fnum;
	else if (namedfm[c].fmark.fnum != buf->b_fnum)
	{
	    // mark is in another file
	    posp = &pos_copy;

	    if (namedfm[c].fmark.mark.lnum != 0
				       && changefile && namedfm[c].fmark.fnum)
	    {
		if (buflist_getfile(namedfm[c].fmark.fnum,
				      (linenr_T)1, GETF_SETMARK, FALSE) == OK)
		{
		    // Set the lnum now, autocommands could have changed it
		    curwin->w_cursor = namedfm[c].fmark.mark;
		    return (pos_T *)-1;
		}
		pos_copy.lnum = -1;	// can't get file
	    }
	    else
		pos_copy.lnum = 0;	// mark exists, but is not valid in
					// current buffer
	}
    }

    return posp;
}
