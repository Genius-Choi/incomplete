setmark_pos(int c, pos_T *pos, int fnum)
{
    int		i;
    buf_T	*buf;

    // Check for a special key (may cause islower() to crash).
    if (c < 0)
	return FAIL;

    if (c == '\'' || c == '`')
    {
	if (pos == &curwin->w_cursor)
	{
	    setpcmark();
	    // keep it even when the cursor doesn't move
	    curwin->w_prev_pcmark = curwin->w_pcmark;
	}
	else
	    curwin->w_pcmark = *pos;
	return OK;
    }

    buf = buflist_findnr(fnum);
    if (buf == NULL)
	return FAIL;

    if (c == '"')
    {
	buf->b_last_cursor = *pos;
	return OK;
    }

    // Allow setting '[ and '] for an autocommand that simulates reading a
    // file.
    if (c == '[')
    {
	buf->b_op_start = *pos;
	return OK;
    }
    if (c == ']')
    {
	buf->b_op_end = *pos;
	return OK;
    }

    if (c == '<' || c == '>')
    {
	if (c == '<')
	    buf->b_visual.vi_start = *pos;
	else
	    buf->b_visual.vi_end = *pos;
	if (buf->b_visual.vi_mode == NUL)
	    // Visual_mode has not yet been set, use a sane default.
	    buf->b_visual.vi_mode = 'v';
	return OK;
    }

    if (ASCII_ISLOWER(c))
    {
	i = c - 'a';
	buf->b_namedm[i] = *pos;
	return OK;
    }
    if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))
    {
	if (VIM_ISDIGIT(c))
	    i = c - '0' + NMARKS;
	else
	    i = c - 'A';
	namedfm[i].fmark.mark = *pos;
	namedfm[i].fmark.fnum = fnum;
	VIM_CLEAR(namedfm[i].fname);
#ifdef FEAT_VIMINFO
	namedfm[i].time_set = vim_time();
#endif
	return OK;
    }
    return FAIL;
}
