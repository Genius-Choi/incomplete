void SSNPSenderState::RemoveAckedReliableMessageFromUnackedList()
{

	// Trim messages from the head that have been acked.
	// Note that in theory we could have a message in the middle that
	// has been acked.  But it's not worth the time to go looking for them,
	// just to free up a bit of memory early.  We'll get to it once the earlier
	// messages have been acked.
	while ( !m_unackedReliableMessages.empty() )
	{
		CSteamNetworkingMessage *pMsg = m_unackedReliableMessages.m_pFirst;
		Assert( pMsg->SNPSend_ReliableStreamPos() > 0 );
		int64 nReliableEnd = pMsg->SNPSend_ReliableStreamPos() + pMsg->m_cbSize;

		// Are we backing a range that is in flight (and thus we might need
		// to resend?)
		if ( !m_listInFlightReliableRange.empty() )
		{
			auto head = m_listInFlightReliableRange.begin();
			Assert( head->first.m_nBegin >= pMsg->SNPSend_ReliableStreamPos() );
			if ( head->second == pMsg )
			{
				Assert( head->first.m_nBegin < nReliableEnd );
				return;
			}
			Assert( head->first.m_nBegin >= nReliableEnd );
		}

		// Are we backing the next range that is ready for resend now?
		if ( !m_listReadyRetryReliableRange.empty() )
		{
			auto head = m_listReadyRetryReliableRange.begin();
			Assert( head->first.m_nBegin >= pMsg->SNPSend_ReliableStreamPos() );
			if ( head->second == pMsg )
			{
				Assert( head->first.m_nBegin < nReliableEnd );
				return;
			}
			Assert( head->first.m_nBegin >= nReliableEnd );
		}

		// We're all done!
		DbgVerify( m_unackedReliableMessages.pop_front() == pMsg );
		pMsg->Release();
	}
}
