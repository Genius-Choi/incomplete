static int cls(void) {
	int i, code = RLC_ERR;
	bn_t r, t, u, v, vs[4];
	g1_t a, A, b, B, c, As[4], Bs[4];
	g2_t x, y, z, zs[4];
	const uint8_t m[5] = { 0, 1, 2, 3, 4 };
	const uint8_t *ms[5] = {m, m, m, m, m};
	const size_t ls[5] = {sizeof(m), sizeof(m), sizeof(m), sizeof(m), sizeof(m)};

	bn_null(r);
	bn_null(t);
	bn_null(u);
	bn_null(v);
	g1_null(a);
	g1_null(A);
	g1_null(b);
	g1_null(B);
	g1_null(c);
	g2_null(x);
	g2_null(y);
	g2_null(z);
	for (i = 0; i < 4; i++) {
		bn_null(vs[i]);
		g1_null(As[i]);
		g1_null(Bs[i]);
		g2_null(zs[i]);
	}

	RLC_TRY {
		bn_new(r);
		bn_new(t);
		bn_new(u);
		bn_new(v);
		g1_new(a);
		g1_new(A);
		g1_new(b);
		g1_new(B);
		g1_new(c);
		g2_new(x);
		g2_new(y);
		g2_new(z);
		for (i = 0; i < 4; i++) {
			bn_new(vs[i]);
			g1_new(As[i]);
			g1_new(Bs[i]);
			g2_new(zs[i]);
		}

		TEST_CASE("camenisch-lysyanskaya simple signature is correct") {
			TEST_ASSERT(cp_cls_gen(u, v, x, y) == RLC_OK, end);
			TEST_ASSERT(cp_cls_sig(a, b, c, m, sizeof(m), u, v) == RLC_OK, end);
			TEST_ASSERT(cp_cls_ver(a, b, c, m, sizeof(m), x, y) == 1, end);
			/* Check adversarial signature. */
			g1_set_infty(a);
			g1_set_infty(b);
			g1_set_infty(c);
			TEST_ASSERT(cp_cls_ver(a, b, c, m, sizeof(m), x, y) == 0, end);
		}
		TEST_END;

		TEST_CASE("camenisch-lysyanskaya message-independent signature is correct") {
			bn_rand(r, RLC_POS, 2 * pc_param_level());
			TEST_ASSERT(cp_cli_gen(t, u, v, x, y, z) == RLC_OK, end);
			TEST_ASSERT(cp_cli_sig(a, A, b, B, c, m, sizeof(m), r, t, u, v)
					== RLC_OK, end);
			TEST_ASSERT(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z)
					== 1, end);
			/* Check adversarial signature. */
			g1_set_infty(a);
			g1_set_infty(A);
			g1_set_infty(b);
			g1_set_infty(B);
			g1_set_infty(c);
			TEST_ASSERT(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z) == 0, end);
		}
		TEST_END;

		TEST_CASE("camenisch-lysyanskaya message-block signature is correct") {
			TEST_ASSERT(cp_clb_gen(t, u, vs, x, y, zs, 5) == RLC_OK, end);
			TEST_ASSERT(cp_clb_sig(a, As, b, Bs, c, ms, ls, t, u, vs, 5)
					== RLC_OK, end);
			TEST_ASSERT(cp_clb_ver(a, As, b, Bs, c, ms, ls, x, y, zs, 5)
					== 1, end);
		}
		TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	bn_free(r);
	bn_free(t);
	bn_free(u);
	bn_free(v);
	g1_free(a);
	g1_free(A);
	g1_free(b);
	g1_free(B);
	g1_free(c);
	g2_free(x);
	g2_free(y);
	g2_free(z);
	for (i = 0; i < 4; i++) {
		bn_free(vs[i]);
		g1_free(As[i]);
		g1_free(Bs[i]);
		g2_free(zs[i]);
	}
	return code;
}
