static int pss(void) {
	int i, code = RLC_ERR;
	bn_t ms[5], n, u, v, _v[5];
	g1_t a, b;
	g2_t g, x, y, _y[5];

	bn_null(n);
	bn_null(u);
	bn_null(v);
	g1_null(a);
	g1_null(b);
	g2_null(g);
	g2_null(x);
	g2_null(y);

	RLC_TRY {
		bn_new(n);
		bn_new(u);
		bn_new(v);
		g1_new(a);
		g1_new(b);
		g2_new(g);
		g2_new(x);
		g2_new(y);

		g1_get_ord(n);

		for (i = 0; i < 5; i++) {
			bn_null(ms[i]);
			bn_null(_v[i]);
			g2_null(_y[i]);
			bn_new(ms[i]);
			bn_rand_mod(ms[i], n);
			bn_new(_v[i]);
			g2_new(_y[i]);
		}

		TEST_CASE("pointcheval-sanders simple signature is correct") {
			TEST_ASSERT(cp_pss_gen(u, v, g, x, y) == RLC_OK, end);
			TEST_ASSERT(cp_pss_sig(a, b, ms[0], u, v) == RLC_OK, end);
			TEST_ASSERT(cp_pss_ver(a, b, ms[0], g, x, y) == 1, end);
			/* Check adversarial signature. */
			g1_set_infty(a);
			g1_set_infty(b);
			TEST_ASSERT(cp_pss_ver(a, b, ms[0], g, x, y) == 0, end);
		}
		TEST_END;

		TEST_CASE("pointcheval-sanders block signature is correct") {
			TEST_ASSERT(cp_psb_gen(u, _v, g, x, _y, 5) == RLC_OK, end);
			TEST_ASSERT(cp_psb_sig(a, b, ms, u, _v, 5) == RLC_OK, end);
			TEST_ASSERT(cp_psb_ver(a, b, ms, g, x, _y, 5) == 1, end);
		}
		TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	bn_free(n);
	bn_free(u);
	bn_free(v);
	g1_free(a);
	g1_free(b);
	g2_free(g);
	g2_free(x);
	g2_free(y);
	for (i = 0; i < 5; i++) {
		bn_free(ms[i]);
		bn_free(_v[i]);
		g2_free(_y[i]);
	}
	return code;
}
