static int subgroup_paillier() {
	int code = RLC_ERR;
	bn_t a, b, c, d;
	shpe_t pub, prv;
	int result, bits;

	bn_null(a);
	bn_null(b);
	bn_null(c);
	bn_null(d);
	shpe_null(pub);
	shpe_null(prv);

	RLC_TRY {
		bn_new(a);
		bn_new(b);
		bn_new(c);
		bn_new(d);
        shpe_new(pub);
		shpe_new(prv);

		for (bits = 3; bits < 6; bits++) {
			result = cp_shpe_gen(pub, prv, RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);

			util_print("(o = %d, |n| = %d) ", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);
			TEST_CASE("subgroup paillier encryption/decryption is correct") {
				TEST_ASSERT(result == RLC_OK, end);
				bn_rand_mod(a, pub->crt->n);
				TEST_ASSERT(cp_shpe_enc(c, a, pub) == RLC_OK, end);
				TEST_ASSERT(cp_shpe_dec(b, c, prv) == RLC_OK, end);
				TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
			}
			TEST_END;

			util_print("(o = %d, |n| = %d) ", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);
			TEST_CASE("subgroup paillier faster encryption with private key is correct") {
				TEST_ASSERT(result == RLC_OK, end);
				bn_rand_mod(a, pub->crt->n);
				TEST_ASSERT(cp_shpe_enc_prv(c, a, prv) == RLC_OK, end);
				TEST_ASSERT(cp_shpe_dec(b, c, prv) == RLC_OK, end);
				TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
			}
			TEST_END;

			util_print("(o = %d, |n| = %d) ", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);
			TEST_CASE("subgroup paillier encryption/decryption is homomorphic") {
				TEST_ASSERT(result == RLC_OK, end);
				bn_rand_mod(a, pub->crt->n);
				bn_rand_mod(b, pub->crt->n);
				TEST_ASSERT(cp_shpe_enc(c, a, pub) == RLC_OK, end);
				TEST_ASSERT(cp_shpe_enc(d, b, pub) == RLC_OK, end);
				bn_mul(c, c, d);
				bn_sqr(d, pub->crt->n);
				bn_mod(c, c, d);
				TEST_ASSERT(cp_shpe_dec(d, c, prv) == RLC_OK, end);
				bn_add(a, a, b);
				bn_mod(a, a, pub->crt->n);
				TEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);
			}
			TEST_END;
		}
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	bn_free(a);
	bn_free(b);
	bn_free(c);
	bn_free(d);
	shpe_free(pub);
	shpe_free(prv);
	return code;
}
