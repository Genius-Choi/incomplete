static int pdprv(void) {
	int code = RLC_ERR;
	bn_t r1, r2[3];
	g1_t p, u1[2], v1[3];
	g2_t q, u2[2], v2[4], w2[4];
	gt_t e[2], r, g[4];

	bn_null(r1);
	g1_null(p);
	g2_null(q);
	gt_null(r);
	for (int i = 0; i < 2; i++) {
		g1_null(u1[i]);
		g2_null(u2[i]);
		gt_null(e[i]);
	}
	for (int i = 0; i < 3; i++) {
		g1_null(v1[i]);
		bn_null(r2[i]);
	}
	for (int i = 0; i < 4; i++) {
		g2_null(v2[i]);
		g2_null(w2[i]);
		gt_null(g[i]);
	}

	RLC_TRY {
		bn_new(r1);
		g1_new(p);
		g2_new(q);
		gt_new(r);
		for (int i = 0; i < 2; i++) {
			g1_new(u1[i]);
			g2_new(u2[i]);
			gt_new(e[i]);
		}
		for (int i = 0; i < 3; i++) {
			g1_new(v1[i]);
			bn_new(r2[i]);
		}
		for (int i = 0; i < 4; i++) {
			g2_new(v2[i]);
			g2_new(w2[i]);
			gt_new(g[i]);
		}

		TEST_CASE("delegated pairing computation with private inputs is correct") {
			TEST_ASSERT(cp_pdprv_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);
			g1_rand(p);
			g2_rand(q);
			TEST_ASSERT(cp_pdprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);
			TEST_ASSERT(cp_pdprv_ans(g, v1, w2) == RLC_OK, end);
			TEST_ASSERT(cp_pdprv_ver(r, g, r1, e) == 1, end);
			pc_map(e[0], p, q);
			TEST_ASSERT(gt_cmp(r, e[0]) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("faster delegated pairing with private inputs is correct") {
			TEST_ASSERT(cp_pdprv_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);
			g1_rand(p);
			g2_rand(q);
			TEST_ASSERT(cp_lvprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);
			TEST_ASSERT(cp_lvprv_ans(g, v1, w2) == RLC_OK, end);
			TEST_ASSERT(cp_lvprv_ver(r, g, r1, e) == 1, end);
			pc_map(e[0], p, q);
			TEST_ASSERT(gt_cmp(r, e[0]) == RLC_EQ, end);
		} TEST_END;
	} RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	bn_free(r1);
	g1_free(p);
	g2_free(q);
	gt_free(r);
	for (int i = 0; i < 2; i++) {
		g1_free(u1[i]);
		g2_free(u2[i]);
		gt_free(e[i]);
	}
	for (int i = 0; i < 3; i++) {
		g1_free(v1[i]);
		bn_free(r2[i]);
	}
	for (int i = 0; i < 4; i++) {
		g2_free(v2[i]);
		g2_free(w2[i]);
		gt_free(g[i]);
	}
	return code;
}
