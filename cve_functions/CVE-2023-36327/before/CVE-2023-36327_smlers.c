static int smlers(void) {
	int code = RLC_ERR;
	ec_t pp, pk[4];
	bn_t sk[4], td;
	smlers_t ring[4];
	const uint8_t m[5] = { 0, 1, 2, 3, 4 };
	size_t size;

	bn_null(td);
	ec_null(pp);

	RLC_TRY {
		bn_new(td);
		ec_new(pp);
		for (int i = 0; i < 4; i++) {
			bn_null(sk[i]);
			bn_new(sk[i]);
			ec_null(pk[i]);
			ec_new(pk[i]);
			smlers_null(ring[i]);
			smlers_new(ring[i]);
			cp_ers_gen_key(sk[i], pk[i]);
		}

		cp_ers_gen(pp);

		TEST_CASE("same-message linkable ext. ring signature scheme is correct") {
			TEST_ASSERT(cp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);
			TEST_ASSERT(cp_smlers_ver(td, ring, 1, m, 5, pp) == 1, end);
			TEST_ASSERT(cp_smlers_ver(td, ring, 1, m, 0, pp) == 0, end);
			size = 1;
			for (int j = 1; j < 4; j++) {
				TEST_ASSERT(cp_smlers_ext(td, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);
				TEST_ASSERT(cp_smlers_ver(td, ring, size, m, 5, pp) == 1, end);
				TEST_ASSERT(cp_smlers_ver(td, ring, size, m, 0, pp) == 0, end);
				TEST_ASSERT(ec_cmp(ring[0]->tau, ring[j]->tau) == RLC_EQ, end);
			}
		} TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

end:
	bn_free(td);
	ec_free(pp);
	for (int i = 0; i < 4; i++) {
		bn_free(sk[i]);
		ec_free(pk[i]);
		smlers_free(ring[i])
	}
	return code;
}
