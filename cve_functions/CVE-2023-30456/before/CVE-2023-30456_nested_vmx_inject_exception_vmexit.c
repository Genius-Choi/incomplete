static void nested_vmx_inject_exception_vmexit(struct kvm_vcpu *vcpu)
{
	struct kvm_queued_exception *ex = &vcpu->arch.exception_vmexit;
	u32 intr_info = ex->vector | INTR_INFO_VALID_MASK;
	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
	unsigned long exit_qual;

	if (ex->has_payload) {
		exit_qual = ex->payload;
	} else if (ex->vector == PF_VECTOR) {
		exit_qual = vcpu->arch.cr2;
	} else if (ex->vector == DB_VECTOR) {
		exit_qual = vcpu->arch.dr6;
		exit_qual &= ~DR6_BT;
		exit_qual ^= DR6_ACTIVE_LOW;
	} else {
		exit_qual = 0;
	}

	if (ex->has_error_code) {
		/*
		 * Intel CPUs do not generate error codes with bits 31:16 set,
		 * and more importantly VMX disallows setting bits 31:16 in the
		 * injected error code for VM-Entry.  Drop the bits to mimic
		 * hardware and avoid inducing failure on nested VM-Entry if L1
		 * chooses to inject the exception back to L2.  AMD CPUs _do_
		 * generate "full" 32-bit error codes, so KVM allows userspace
		 * to inject exception error codes with bits 31:16 set.
		 */
		vmcs12->vm_exit_intr_error_code = (u16)ex->error_code;
		intr_info |= INTR_INFO_DELIVER_CODE_MASK;
	}

	if (kvm_exception_is_soft(ex->vector))
		intr_info |= INTR_TYPE_SOFT_EXCEPTION;
	else
		intr_info |= INTR_TYPE_HARD_EXCEPTION;

	if (!(vmcs12->idt_vectoring_info_field & VECTORING_INFO_VALID_MASK) &&
	    vmx_get_nmi_mask(vcpu))
		intr_info |= INTR_INFO_UNBLOCK_NMI;

	nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI, intr_info, exit_qual);
}
