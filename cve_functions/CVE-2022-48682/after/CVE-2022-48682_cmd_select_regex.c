int cmd_select_regex(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)
{
  size_t size;
  wchar_t *wcsfilename;
  size_t needed;
  int errorcode;
  PCRE2_SIZE erroroffset;
  pcre2_code *code;
  pcre2_match_data *md;
  int matches;
  int g;
  int f;
  int selectedgroupcount = 0;
  int selectedfilecount = 0;
  int groupselected;

  code = pcre2_compile((PCRE2_SPTR)commandarguments, PCRE2_ZERO_TERMINATED, PCRE2_UTF | PCRE2_UCP, &errorcode, &erroroffset, 0);

  if (code == 0)
    return -1;

  pcre2_jit_compile(code, PCRE2_JIT_COMPLETE);

  md = pcre2_match_data_create(1, 0);
  if (md == 0)
    return -1;

  for (g = 0; g < groupcount; ++g)
  {
    groupselected = 0;

    for (f = 0; f < groups[g].filecount; ++f)
    {
      needed = mbstowcs_escape_invalid(0, groups[g].files[f].file->d_name, 0);

      wcsfilename = (wchar_t*) malloc(needed * sizeof(wchar_t));
      if (wcsfilename == 0)
        continue;

      mbstowcs_escape_invalid(wcsfilename, groups[g].files[f].file->d_name, needed);

      matches = pcre2_match(code, (PCRE2_SPTR)wcsfilename, PCRE2_ZERO_TERMINATED, 0, 0, md, 0);

      free(wcsfilename);

      if (matches > 0)
      {
        groups[g].selected = 1;
        groups[g].files[f].selected = 1;

        groupselected = 1;
        ++selectedfilecount;
      }
    }

    if (groupselected)
      ++selectedgroupcount;
  }

  format_status_left(status, L"Matched %d files in %d groups.", selectedfilecount, selectedgroupcount);

  pcre2_code_free(code);

  return 1;
}
