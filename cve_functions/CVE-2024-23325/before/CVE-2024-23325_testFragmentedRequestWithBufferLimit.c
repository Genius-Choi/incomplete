  testFragmentedRequestWithBufferLimit(std::list<std::string> request_chunks,
                                       uint32_t buffer_limit) {
    autonomous_upstream_ = true;
    config_helper_.setBufferLimits(buffer_limit, buffer_limit);
    initialize();

    // write_request_cb will write each of the items in request_chunks as a separate SSL_write.
    auto write_request_cb = [&request_chunks](Buffer::Instance& buffer) {
      if (!request_chunks.empty()) {
        buffer.add(request_chunks.front());
        request_chunks.pop_front();
      }
      return false;
    };

    auto client_transport_socket_factory_ptr =
        createClientSslTransportSocketFactory({}, *context_manager_, *api_);
    std::string response;
    auto connection = createConnectionDriver(
        lookupPort("http"), write_request_cb,
        [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {
          response.append(data.toString());
        },
        client_transport_socket_factory_ptr->createTransportSocket({}, nullptr));

    // Drive the connection until we get a response.
    while (response.empty()) {
      EXPECT_TRUE(connection->run(Event::Dispatcher::RunType::NonBlock));
    }
    EXPECT_THAT(response, testing::HasSubstr("HTTP/1.1 200 OK\r\n"));

    connection->close();
    return reinterpret_cast<AutonomousUpstream*>(fake_upstreams_.front().get())
        ->lastRequestHeaders();
  }
