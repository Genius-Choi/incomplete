ex_let_option(
    char_u	*arg,
    typval_T	*tv,
    int		flags,
    char_u	*endchars,
    char_u	*op)
{
    char_u	*p;
    int		scope;
    char_u	*arg_end = NULL;

    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))
					 && (flags & ASSIGN_FOR_LOOP) == 0)
    {
	emsg(_(e_cannot_lock_option));
	return NULL;
    }

    // Find the end of the name.
    p = find_option_end(&arg, &scope);
    if (p == NULL || (endchars != NULL
			       && vim_strchr(endchars, *skipwhite(p)) == NULL))
	emsg(_(e_unexpected_characters_in_let));
    else
    {
	int	    c1;
	long	    n = 0;
	getoption_T opt_type;
	long	    numval;
	char_u	    *stringval = NULL;
	char_u	    *s = NULL;
	int	    failed = FALSE;
	int	    opt_p_flags;
	char_u	    *tofree = NULL;
	char_u	    numbuf[NUMBUFLEN];

	c1 = *p;
	*p = NUL;

	opt_type = get_option_value(arg, &numval, &stringval, &opt_p_flags,
									scope);
	if ((opt_type == gov_bool
		    || opt_type == gov_number
		    || opt_type == gov_hidden_bool
		    || opt_type == gov_hidden_number)
			 && (tv->v_type != VAR_STRING || !in_vim9script()))
	{
	    if (opt_type == gov_bool || opt_type == gov_hidden_bool)
		// bool, possibly hidden
		n = (long)tv_get_bool(tv);
	    else
		// number, possibly hidden
		n = (long)tv_get_number(tv);
	}

	if ((opt_p_flags & P_FUNC) && (tv->v_type == VAR_PARTIAL
						|| tv->v_type == VAR_FUNC))
	{
	    // If the option can be set to a function reference or a lambda
	    // and the passed value is a function reference, then convert it to
	    // the name (string) of the function reference.
	    s = tv2string(tv, &tofree, numbuf, 0);
	}
	// Avoid setting a string option to the text "v:false" or similar.
	// In Vim9 script also don't convert a number to string.
	else if (tv->v_type != VAR_BOOL && tv->v_type != VAR_SPECIAL
			 && (!in_vim9script() || tv->v_type != VAR_NUMBER))
	    s = tv_get_string_chk(tv);

	if (op != NULL && *op != '=')
	{
	    if (((opt_type == gov_bool || opt_type == gov_number) && *op == '.')
		    || (opt_type == gov_string && *op != '.'))
	    {
		semsg(_(e_wrong_variable_type_for_str_equal), op);
		failed = TRUE;  // don't set the value

	    }
	    else
	    {
		// number, in legacy script also bool
		if (opt_type == gov_number
			     || (opt_type == gov_bool && !in_vim9script()))
		{
		    switch (*op)
		    {
			case '+': n = numval + n; break;
			case '-': n = numval - n; break;
			case '*': n = numval * n; break;
			case '/': n = (long)num_divide(numval, n,
							       &failed); break;
			case '%': n = (long)num_modulus(numval, n,
							       &failed); break;
		    }
		    s = NULL;
		}
		else if (opt_type == gov_string
					 && stringval != NULL && s != NULL)
		{
		    // string
		    s = concat_str(stringval, s);
		    vim_free(stringval);
		    stringval = s;
		}
	    }
	}

	if (!failed)
	{
	    if (opt_type != gov_string || s != NULL)
	    {
		set_option_value(arg, n, s, scope);
		arg_end = p;
	    }
	    else
		emsg(_(e_string_required));
	}
	*p = c1;
	vim_free(stringval);
	vim_free(tofree);
    }
    return arg_end;
}
