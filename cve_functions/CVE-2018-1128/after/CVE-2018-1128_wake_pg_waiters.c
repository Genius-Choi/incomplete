void OSD::ShardedOpWQ::wake_pg_waiters(spg_t pgid)
{
  uint32_t shard_index = pgid.hash_to_shard(shard_list.size());
  auto sdata = shard_list[shard_index];
  bool queued = false;
  {
    Mutex::Locker l(sdata->sdata_op_ordering_lock);
    auto p = sdata->pg_slots.find(pgid);
    if (p != sdata->pg_slots.end()) {
      dout(20) << __func__ << " " << pgid
	       << " to_process " << p->second.to_process
	       << " waiting_for_pg=" << (int)p->second.waiting_for_pg << dendl;
      for (auto i = p->second.to_process.rbegin();
	   i != p->second.to_process.rend();
	   ++i) {
	sdata->_enqueue_front(make_pair(pgid, *i), osd->op_prio_cutoff);
      }
      p->second.to_process.clear();
      p->second.waiting_for_pg = false;
      ++p->second.requeue_seq;
      queued = true;
    }
  }
  if (queued) {
    sdata->sdata_lock.Lock();
    sdata->sdata_cond.SignalOne();
    sdata->sdata_lock.Unlock();
  }
}
