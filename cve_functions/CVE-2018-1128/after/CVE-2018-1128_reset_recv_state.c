void AsyncConnection::reset_recv_state()
{
  // clean up state internal variables and states
  if (state >= STATE_CONNECTING_SEND_CONNECT_MSG &&
      state <= STATE_CONNECTING_READY) {
    delete authorizer;
    authorizer = NULL;
    got_bad_auth = false;
  }

  if (state > STATE_OPEN_MESSAGE_THROTTLE_MESSAGE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH
      && policy.throttler_messages) {
    ldout(async_msgr->cct, 10) << __func__ << " releasing " << 1
                               << " message to policy throttler "
                               << policy.throttler_messages->get_current() << "/"
                               << policy.throttler_messages->get_max() << dendl;
    policy.throttler_messages->put();
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_BYTES &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    if (policy.throttler_bytes) {
      ldout(async_msgr->cct, 10) << __func__ << " releasing " << cur_msg_size
                                 << " bytes to policy throttler "
                                 << policy.throttler_bytes->get_current() << "/"
                                 << policy.throttler_bytes->get_max() << dendl;
      policy.throttler_bytes->put(cur_msg_size);
    }
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    ldout(async_msgr->cct, 10) << __func__ << " releasing " << cur_msg_size
                               << " bytes to dispatch_queue throttler "
                               << dispatch_queue->dispatch_throttler.get_current() << "/"
                               << dispatch_queue->dispatch_throttler.get_max() << dendl;
    dispatch_queue->dispatch_throttle_release(cur_msg_size);
  }
}
