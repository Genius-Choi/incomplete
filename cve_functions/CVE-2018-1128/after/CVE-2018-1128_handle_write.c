void AsyncConnection::handle_write()
{
  ldout(async_msgr->cct, 10) << __func__ << dendl;
  ssize_t r = 0;

  write_lock.lock();
  if (can_write == WriteStatus::CANWRITE) {
    if (keepalive) {
      _append_keepalive_or_ack();
      keepalive = false;
    }

    auto start = ceph::mono_clock::now();
    bool more;
    do {
      bufferlist data;
      Message *m = _get_next_outgoing(&data);
      if (!m)
        break;

      if (!policy.lossy) {
        // put on sent list
        sent.push_back(m);
        m->get();
      }
      more = _has_next_outgoing();
      write_lock.unlock();

      // send_message or requeue messages may not encode message
      if (!data.length())
        prepare_send_message(get_features(), m, data);

      r = write_message(m, data, more);
      if (r < 0) {
        ldout(async_msgr->cct, 1) << __func__ << " send msg failed" << dendl;
        goto fail;
      }
      write_lock.lock();
      if (r > 0)
        break;
    } while (can_write == WriteStatus::CANWRITE);
    write_lock.unlock();

    uint64_t left = ack_left;
    if (left) {
      ceph_le64 s;
      s = in_seq;
      outcoming_bl.append(CEPH_MSGR_TAG_ACK);
      outcoming_bl.append((char*)&s, sizeof(s));
      ldout(async_msgr->cct, 10) << __func__ << " try send msg ack, acked " << left << " messages" << dendl;
      ack_left -= left;
      left = ack_left;
      r = _try_send(left);
    } else if (is_queued()) {
      r = _try_send();
    }

    logger->tinc(l_msgr_running_send_time, ceph::mono_clock::now() - start);
    if (r < 0) {
      ldout(async_msgr->cct, 1) << __func__ << " send msg failed" << dendl;
      goto fail;
    }
  } else {
    write_lock.unlock();
    lock.lock();
    write_lock.lock();
    if (state == STATE_STANDBY && !policy.server && is_queued()) {
      ldout(async_msgr->cct, 10) << __func__ << " policy.server is false" << dendl;
      _connect();
    } else if (cs && state != STATE_NONE && state != STATE_CONNECTING && state != STATE_CONNECTING_RE && state != STATE_CLOSED) {
      r = _try_send();
      if (r < 0) {
        ldout(async_msgr->cct, 1) << __func__ << " send outcoming bl failed" << dendl;
        write_lock.unlock();
        fault();
        lock.unlock();
        return ;
      }
    }
    write_lock.unlock();
    lock.unlock();
  }

  return ;

 fail:
  lock.lock();
  fault();
  lock.unlock();
}
