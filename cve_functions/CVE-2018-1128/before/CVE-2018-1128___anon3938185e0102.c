  mgrc.set_pgstats_cb([this](){
      RWLock::RLocker l(map_lock);
      
      utime_t had_for = ceph_clock_now() - had_map_since;
      osd_stat_t cur_stat = service.get_osd_stat();
      cur_stat.os_perf_stat = store->get_cur_stats();

      MPGStats *m = new MPGStats(monc->get_fsid(), osdmap->get_epoch(), had_for);
      m->osd_stat = cur_stat;

      Mutex::Locker lec{min_last_epoch_clean_lock};
      min_last_epoch_clean = osdmap->get_epoch();
      min_last_epoch_clean_pgs.clear();
      RWLock::RLocker lpg(pg_map_lock);
      for (const auto &i : pg_map) {
        PG *pg = i.second;
        if (!pg->is_primary()) {
          continue;
        }

        pg->pg_stats_publish_lock.Lock();
        if (pg->pg_stats_publish_valid) {
          m->pg_stat[pg->info.pgid.pgid] = pg->pg_stats_publish;
	  const auto lec = pg->pg_stats_publish.get_effective_last_epoch_clean();
	  min_last_epoch_clean = min(min_last_epoch_clean, lec);
	  min_last_epoch_clean_pgs.push_back(pg->info.pgid.pgid);
        }
        pg->pg_stats_publish_lock.Unlock();
      }

      return m;
  });
