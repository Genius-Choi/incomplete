bool OSD::maybe_wait_for_max_pg(spg_t pgid, bool is_mon_create)
{
  const auto max_pgs_per_osd =
    (cct->_conf->get_val<uint64_t>("mon_max_pg_per_osd") *
     cct->_conf->get_val<double>("osd_max_pg_per_osd_hard_ratio"));

  RWLock::RLocker pg_map_locker{pg_map_lock};
  if (pg_map.size() < max_pgs_per_osd) {
    return false;
  }
  lock_guard<mutex> pending_creates_locker{pending_creates_lock};
  if (is_mon_create) {
    pending_creates_from_mon++;
  } else {
    bool is_primary = osdmap->get_pg_acting_rank(pgid.pgid, whoami) == 0;
    pending_creates_from_osd.emplace(pgid.pgid, is_primary);
  }
  dout(5) << __func__ << " withhold creation of pg " << pgid
	  << ": " << pg_map.size() << " >= "<< max_pgs_per_osd << dendl;
  return true;
}
