HTTPSession::HTTPSession(
  const WheelTimerInstance& timeout,
  AsyncTransportWrapper::UniquePtr sock,
  const SocketAddress& localAddr,
  const SocketAddress& peerAddr,
  HTTPSessionController* controller,
  unique_ptr<HTTPCodec> codec,
  const TransportInfo& tinfo,
  InfoCallback* infoCallback):
    HTTPSessionBase(localAddr, peerAddr, controller, tinfo, infoCallback,
                    std::move(codec)),
    writeTimeout_(this),
    txnEgressQueue_(isHTTP2CodecProtocol(codec_->getProtocol()) ?
                    WheelTimerInstance(timeout) :
                    WheelTimerInstance()),
    sock_(std::move(sock)),
    timeout_(timeout),
    draining_(false),
    started_(false),
    writesDraining_(false),
    resetAfterDrainingWrites_(false),
    ingressError_(false),
    flowControlTimeout_(this),
    drainTimeout_(this),
    reads_(SocketState::PAUSED),
    writes_(SocketState::UNPAUSED),
    ingressUpgraded_(false),
    resetSocketOnShutdown_(false),
    inLoopCallback_(false),
    inResume_(false),
    pendingPause_(false) {
  byteEventTracker_ = std::make_shared<ByteEventTracker>(this);
  initialReceiveWindow_ = receiveStreamWindowSize_ =
    receiveSessionWindowSize_ = codec_->getDefaultWindowSize();

  codec_.add<HTTPChecks>();

  setupCodec();

  nextEgressResults_.reserve(maxConcurrentIncomingStreams_);

  if (infoCallback_) {
    infoCallback_->onCreate(*this);
  }

  auto controllerPtr = getController();
  if (controllerPtr) {
    flowControlTimeout_.setTimeoutDuration(
      controllerPtr->getSessionFlowControlTimeout());
  }
  attachToSessionController();

  if (!sock_->isReplaySafe()) {
    sock_->setReplaySafetyCallback(this);
  }
}
