size_t HTTPSession::sendCertificateRequest(
    std::unique_ptr<folly::IOBuf> certificateRequestContext,
    std::vector<fizz::Extension> extensions) {
  // Check if both sending and receiving peer have advertised valid
  // SETTINGS_HTTP_CERT_AUTH setting. Otherwise, the frames for secondary
  // authentication should not be sent.
  auto ingressSettings = codec_->getIngressSettings();
  auto egressSettings = codec_->getEgressSettings();
  if (ingressSettings && egressSettings) {
    if (ingressSettings->getSetting(SettingsId::SETTINGS_HTTP_CERT_AUTH, 0) ==
            0 ||
        egressSettings->getSetting(SettingsId::SETTINGS_HTTP_CERT_AUTH, 0) ==
            0) {
      VLOG(4) << "Secondary certificate authentication is not supported.";
      return 0;
    }
  }
  auto authRequest = secondAuthManager_->createAuthRequest(
      std::move(certificateRequestContext), std::move(extensions));
  auto encodedSize = codec_->generateCertificateRequest(
      writeBuf_, authRequest.first, std::move(authRequest.second));
  if (encodedSize > 0) {
    scheduleWrite();
  } else {
    VLOG(4) << "Failed to generate CERTIFICATE_REQUEST frame.";
  }
  return encodedSize;
}
