int64_t quicly_get_first_timeout(quicly_conn_t *conn)
{
    if (conn->super.state >= QUICLY_STATE_CLOSING)
        return conn->egress.send_ack_at;

    if (should_send_datagram_frame(conn))
        return 0;

    uint64_t amp_window = calc_amplification_limit_allowance(conn);

    if (calc_send_window(conn, 0, amp_window, 0) > 0) {
        if (conn->egress.pending_flows != 0) {
            /* crypto streams (as indicated by lower 4 bits) can be sent whenever CWND is available; other flows need application
             * packet number space */
            if (conn->application != NULL && conn->application->cipher.egress.key.header_protection != NULL)
                return 0;
            if ((conn->egress.pending_flows & 0xf) != 0)
                return 0;
        }
        if (quicly_linklist_is_linked(&conn->egress.pending_streams.control))
            return 0;
        if (scheduler_can_send(conn))
            return 0;
    }

    /* if something can be sent, return the earliest timeout. Otherwise return the idle timeout. */
    int64_t at = conn->idle_timeout.at;
    if (amp_window > 0) {
        if (conn->egress.loss.alarm_at < at && !is_point5rtt_with_no_handshake_data_to_send(conn))
            at = conn->egress.loss.alarm_at;
        if (conn->egress.send_ack_at < at)
            at = conn->egress.send_ack_at;
    }

    return at;
}
