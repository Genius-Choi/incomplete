static int handle_new_connection_id_frame(quicly_conn_t *conn, struct st_quicly_handle_payload_state_t *state)
{
    int ret;
    quicly_new_connection_id_frame_t frame;

    /* TODO: return error when using zero-length CID */

    if ((ret = quicly_decode_new_connection_id_frame(&state->src, state->end, &frame)) != 0)
        return ret;

    QUICLY_PROBE(NEW_CONNECTION_ID_RECEIVE, conn, conn->stash.now, frame.sequence, frame.retire_prior_to,
                 QUICLY_PROBE_HEXDUMP(frame.cid.base, frame.cid.len),
                 QUICLY_PROBE_HEXDUMP(frame.stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN));
    QUICLY_LOG_CONN(new_connection_id_receive, conn, {
        PTLS_LOG_ELEMENT_UNSIGNED(sequence, frame.sequence);
        PTLS_LOG_ELEMENT_UNSIGNED(retire_prior_to, frame.retire_prior_to);
        PTLS_LOG_ELEMENT_HEXDUMP(cid, frame.cid.base, frame.cid.len);
        PTLS_LOG_ELEMENT_HEXDUMP(stateless_reset_token, frame.stateless_reset_token, QUICLY_STATELESS_RESET_TOKEN_LEN);
    });

    if (frame.sequence < conn->super.remote.largest_retire_prior_to) {
        /* An endpoint that receives a NEW_CONNECTION_ID frame with a sequence number smaller than the Retire Prior To
         * field of a previously received NEW_CONNECTION_ID frame MUST send a corresponding RETIRE_CONNECTION_ID frame
         * that retires the newly received connection ID, unless it has already done so for that sequence number. (19.15)
         * TODO: "unless ..." part may not be properly addressed here (we may already have sent the RCID frame for this
         * sequence) */
        schedule_retire_connection_id_frame(conn, frame.sequence);
        /* do not install this CID */
        return 0;
    }

    uint64_t unregistered_seqs[QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT];
    size_t num_unregistered_seqs;
    if ((ret = quicly_remote_cid_register(&conn->super.remote.cid_set, frame.sequence, frame.cid.base, frame.cid.len,
                                          frame.stateless_reset_token, frame.retire_prior_to, unregistered_seqs,
                                          &num_unregistered_seqs)) != 0)
        return ret;

    for (size_t i = 0; i < num_unregistered_seqs; i++)
        schedule_retire_connection_id_frame(conn, unregistered_seqs[i]);

    if (frame.retire_prior_to > conn->super.remote.largest_retire_prior_to)
        conn->super.remote.largest_retire_prior_to = frame.retire_prior_to;

    return 0;
}
