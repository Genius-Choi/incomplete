static int do_send(quicly_conn_t *conn, quicly_send_context_t *s)
{
    int restrict_sending = 0, ack_only = 0, ret;
    size_t min_packets_to_send = 0;

    /* handle timeouts */
    if (conn->idle_timeout.at <= conn->stash.now) {
        QUICLY_PROBE(IDLE_TIMEOUT, conn, conn->stash.now);
        QUICLY_LOG_CONN(idle_timeout, conn, {});
        goto CloseNow;
    }
    /* handle handshake timeouts */
    if ((conn->initial != NULL || conn->handshake != NULL) &&
        conn->created_at + (uint64_t)conn->super.ctx->handshake_timeout_rtt_multiplier * conn->egress.loss.rtt.smoothed <=
            conn->stash.now) {
        QUICLY_PROBE(HANDSHAKE_TIMEOUT, conn, conn->stash.now, conn->stash.now - conn->created_at, conn->egress.loss.rtt.smoothed);
        QUICLY_LOG_CONN(handshake_timeout, conn, {
            PTLS_LOG_ELEMENT_SIGNED(elapsed, conn->stash.now - conn->created_at);
            PTLS_LOG_ELEMENT_UNSIGNED(rtt_smoothed, conn->egress.loss.rtt.smoothed);
        });
        conn->super.stats.num_handshake_timeouts++;
        goto CloseNow;
    }
    if (conn->super.stats.num_packets.initial_handshake_sent > conn->super.ctx->max_initial_handshake_packets) {
        QUICLY_PROBE(INITIAL_HANDSHAKE_PACKET_EXCEED, conn, conn->stash.now, conn->super.stats.num_packets.initial_handshake_sent);
        QUICLY_LOG_CONN(initial_handshake_packet_exceed, conn,
                        { PTLS_LOG_ELEMENT_UNSIGNED(num_packets, conn->super.stats.num_packets.initial_handshake_sent); });
        conn->super.stats.num_initial_handshake_exceeded++;
        goto CloseNow;
    }
    if (conn->egress.loss.alarm_at <= conn->stash.now) {
        if ((ret = quicly_loss_on_alarm(&conn->egress.loss, conn->stash.now, conn->super.remote.transport_params.max_ack_delay,
                                        conn->initial == NULL && conn->handshake == NULL, &min_packets_to_send, &restrict_sending,
                                        on_loss_detected)) != 0)
            goto Exit;
        assert(min_packets_to_send > 0);
        assert(min_packets_to_send <= s->max_datagrams);

        if (restrict_sending) {
            /* PTO: when handshake is in progress, send from the very first unacknowledged byte so as to maximize the chance of
             * making progress. When handshake is complete, transmit new data if any, else retransmit the oldest unacknowledged data
             * that is considered inflight. */
            QUICLY_PROBE(PTO, conn, conn->stash.now, conn->egress.loss.sentmap.bytes_in_flight, conn->egress.cc.cwnd,
                         conn->egress.loss.pto_count);
            QUICLY_LOG_CONN(pto, conn, {
                PTLS_LOG_ELEMENT_SIGNED(inflight, conn->egress.loss.sentmap.bytes_in_flight);
                PTLS_LOG_ELEMENT_UNSIGNED(cwnd, conn->egress.cc.cwnd);
                PTLS_LOG_ELEMENT_SIGNED(pto_count, conn->egress.loss.pto_count);
            });
            ++conn->super.stats.num_ptos;
            size_t bytes_to_mark = min_packets_to_send * conn->egress.max_udp_payload_size;
            if (conn->initial != NULL && (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_INITIAL, &bytes_to_mark)) != 0)
                goto Exit;
            if (bytes_to_mark != 0 && conn->handshake != NULL &&
                (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_HANDSHAKE, &bytes_to_mark)) != 0)
                goto Exit;
            /* Mark already sent 1-RTT data for PTO only if there's no new data, i.e., when scheduler_can_send() return false. */
            if (bytes_to_mark != 0 && !scheduler_can_send(conn) &&
                (ret = mark_frames_on_pto(conn, QUICLY_EPOCH_1RTT, &bytes_to_mark)) != 0)
                goto Exit;
        }
    }

    /* disable ECN if zero packets where acked in the first 3 PTO of the connection during which all sent packets are ECT(0) */
    if (conn->egress.ecn.state == QUICLY_ECN_PROBING && conn->created_at + conn->egress.loss.rtt.smoothed * 3 < conn->stash.now) {
        update_ecn_state(conn, QUICLY_ECN_OFF);
        /* TODO reset CC? */
    }

    s->send_window = calc_send_window(conn, min_packets_to_send * conn->egress.max_udp_payload_size,
                                      calc_amplification_limit_allowance(conn), restrict_sending);
    if (s->send_window == 0)
        ack_only = 1;

    /* send handshake flows; when PTO fires...
     *  * quicly running as a client sends either a Handshake probe (or data) if the handshake keys are available, or else an
     *    Initial probe (or data).
     *  * quicly running as a server sends both Initial and Handshake probes (or data) if the corresponding keys are available. */
    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_INITIAL, s, ack_only,
                                   min_packets_to_send != 0 && (!quicly_is_client(conn) || conn->handshake == NULL))) != 0)
        goto Exit;
    if ((ret = send_handshake_flow(conn, QUICLY_EPOCH_HANDSHAKE, s, ack_only, min_packets_to_send != 0)) != 0)
        goto Exit;

    /* setup 0-RTT or 1-RTT send context (as the availability of the two epochs are mutually exclusive, we can try 1-RTT first as an
     * optimization), then send application data if that succeeds */
    if (setup_send_space(conn, QUICLY_EPOCH_1RTT, s) != NULL || setup_send_space(conn, QUICLY_EPOCH_0RTT, s) != NULL) {
        /* acks */
        if (conn->application->one_rtt_writable && conn->egress.send_ack_at <= conn->stash.now &&
            conn->application->super.unacked_count != 0) {
            if ((ret = send_ack(conn, &conn->application->super, s)) != 0)
                goto Exit;
        }
        /* DATAGRAM frame. Notes regarding current implementation:
         * * Not limited by CC, nor the bytes counted by CC.
         * * When given payload is too large and does not fit into a QUIC packet, a packet containing only PADDING frames is sent.
         *   This is because we do not have a way to retract the generation of a QUIC packet.
         * * Does not notify the application that the frame was dropped internally. */
        if (should_send_datagram_frame(conn)) {
            for (size_t i = 0; i != conn->egress.datagram_frame_payloads.count; ++i) {
                ptls_iovec_t *payload = conn->egress.datagram_frame_payloads.payloads + i;
                size_t required_space = quicly_datagram_frame_capacity(*payload);
                if ((ret = do_allocate_frame(conn, s, required_space, ALLOCATE_FRAME_TYPE_ACK_ELICITING_NO_CC)) != 0)
                    goto Exit;
                if (s->dst_end - s->dst >= required_space) {
                    s->dst = quicly_encode_datagram_frame(s->dst, *payload);
                    QUICLY_PROBE(DATAGRAM_SEND, conn, conn->stash.now, payload->base, payload->len);
                    QUICLY_LOG_CONN(datagram_send, conn,
                                    { PTLS_LOG_APPDATA_ELEMENT_HEXDUMP(payload, payload->base, payload->len); });
                } else {
                    /* FIXME: At the moment, we add a padding because we do not have a way to reclaim allocated space, and because
                     * it is forbidden to send an empty QUIC packet. */
                    *s->dst++ = QUICLY_FRAME_TYPE_PADDING;
                }
            }
        }
        if (!ack_only) {
            /* PTO or loss detection timeout, always send PING. This is the easiest thing to do in terms of timer control. */
            if (min_packets_to_send != 0) {
                if ((ret = do_allocate_frame(conn, s, 1, ALLOCATE_FRAME_TYPE_ACK_ELICITING)) != 0)
                    goto Exit;
                *s->dst++ = QUICLY_FRAME_TYPE_PING;
                ++conn->super.stats.num_frames_sent.ping;
                QUICLY_PROBE(PING_SEND, conn, conn->stash.now);
                QUICLY_LOG_CONN(ping_send, conn, {});
            }
            /* take actions only permitted for short header packets */
            if (conn->application->one_rtt_writable) {
                /* send HANDSHAKE_DONE */
                if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT) != 0 &&
                    (ret = send_handshake_done(conn, s)) != 0)
                    goto Exit;
                /* post-handshake messages */
                if ((conn->egress.pending_flows & (uint8_t)(1 << QUICLY_EPOCH_1RTT)) != 0) {
                    quicly_stream_t *stream = quicly_get_stream(conn, -(1 + QUICLY_EPOCH_1RTT));
                    assert(stream != NULL);
                    if ((ret = quicly_send_stream(stream, s)) != 0)
                        goto Exit;
                    resched_stream_data(stream);
                }
                /* send other connection-level control frames, and iff we succeed in sending all of them, clear OTHERS_BIT to
                 * disable `quicly_send` being called right again to send more control frames */
                if ((ret = send_other_control_frames(conn, s)) != 0)
                    goto Exit;
                conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_OTHERS_BIT;
                /* send NEW_TOKEN */
                if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_NEW_TOKEN_BIT) != 0 &&
                    (ret = send_resumption_token(conn, s)) != 0)
                    goto Exit;
            }
            /* send stream-level control frames */
            if ((ret = send_stream_control_frames(conn, s)) != 0)
                goto Exit;
            /* send STREAM frames */
            if ((ret = conn->super.ctx->stream_scheduler->do_send(conn->super.ctx->stream_scheduler, conn, s)) != 0)
                goto Exit;
            /* once more, send control frames related to streams, as the state might have changed */
            if ((ret = send_stream_control_frames(conn, s)) != 0)
                goto Exit;
            if ((conn->egress.pending_flows & QUICLY_PENDING_FLOW_OTHERS_BIT) != 0) {
                if ((ret = send_other_control_frames(conn, s)) != 0)
                    goto Exit;
                conn->egress.pending_flows &= ~QUICLY_PENDING_FLOW_OTHERS_BIT;
            }
        }
    }

Exit:
    if (ret == QUICLY_ERROR_SENDBUF_FULL)
        ret = 0;
    if (ret == 0 && s->target.first_byte_at != NULL) {
        /* last packet can be small-sized, unless it is the first flight sent from the client */
        if ((s->payload_buf.datagram[0] & QUICLY_PACKET_TYPE_BITMASK) == QUICLY_PACKET_TYPE_INITIAL &&
            (quicly_is_client(conn) || !ack_only))
            s->target.full_size = 1;
        commit_send_packet(conn, s, 0);
    }
    if (ret == 0) {
        /* update timers, start / stop delivery rate estimator */
        if (conn->application == NULL || conn->application->super.unacked_count == 0)
            conn->egress.send_ack_at = INT64_MAX; /* we have sent ACKs for every epoch (or before address validation) */
        int can_send_stream_data = scheduler_can_send(conn);
        update_send_alarm(conn, can_send_stream_data, 1);
        if (can_send_stream_data &&
            (s->num_datagrams == s->max_datagrams || conn->egress.loss.sentmap.bytes_in_flight >= conn->egress.cc.cwnd)) {
            /* as the flow is CWND-limited, start delivery rate estimator */
            quicly_ratemeter_in_cwnd_limited(&conn->egress.ratemeter, s->first_packet_number);
        } else {
            quicly_ratemeter_not_cwnd_limited(&conn->egress.ratemeter, conn->egress.packet_number);
        }
        if (s->num_datagrams != 0)
            update_idle_timeout(conn, 0);
    }
    return ret;

CloseNow:
    conn->super.state = QUICLY_STATE_DRAINING;
    destroy_all_streams(conn, 0, 0);
    return QUICLY_ERROR_FREE_CONNECTION;
}
