void test_nghttp2_session_on_settings_received(void) {
  nghttp2_session *session;
  nghttp2_session_callbacks callbacks;
  my_user_data user_data;
  nghttp2_stream *stream1, *stream2;
  nghttp2_frame frame;
  const size_t niv = 5;
  nghttp2_settings_entry iv[255];
  nghttp2_outbound_item *item;
  nghttp2_nv nv = MAKE_NV(":authority", "example.org");
  nghttp2_mem *mem;
  nghttp2_option *option;

  mem = nghttp2_mem_default();

  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
  iv[0].value = 50;

  iv[1].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;
  iv[1].value = 1000000009;

  iv[2].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;
  iv[2].value = 64 * 1024;

  iv[3].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;
  iv[3].value = 1024;

  iv[4].settings_id = NGHTTP2_SETTINGS_ENABLE_PUSH;
  iv[4].value = 0;

  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));
  callbacks.send_callback = null_send_callback;

  nghttp2_session_client_new(&session, &callbacks, &user_data);
  session->remote_settings.initial_window_size = 16 * 1024;

  stream1 = open_sent_stream(session, 1);
  stream2 = open_recv_stream(session, 2);

  /* Set window size for each streams and will see how settings
     updates these values */
  stream1->remote_window_size = 16 * 1024;
  stream2->remote_window_size = -48 * 1024;

  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE,
                              dup_iv(iv, niv), niv);

  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));
  CU_ASSERT(1000000009 == session->remote_settings.max_concurrent_streams);
  CU_ASSERT(64 * 1024 == session->remote_settings.initial_window_size);
  CU_ASSERT(1024 == session->remote_settings.header_table_size);
  CU_ASSERT(0 == session->remote_settings.enable_push);

  CU_ASSERT(64 * 1024 == stream1->remote_window_size);
  CU_ASSERT(0 == stream2->remote_window_size);

  frame.settings.iv[2].value = 16 * 1024;

  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));

  CU_ASSERT(16 * 1024 == stream1->remote_window_size);
  CU_ASSERT(-48 * 1024 == stream2->remote_window_size);

  CU_ASSERT(16 * 1024 == nghttp2_session_get_stream_remote_window_size(
                             session, stream1->stream_id));
  CU_ASSERT(0 == nghttp2_session_get_stream_remote_window_size(
                     session, stream2->stream_id));

  nghttp2_frame_settings_free(&frame.settings, mem);

  nghttp2_session_del(session);

  /* Check ACK with niv > 0 */
  nghttp2_session_server_new(&session, &callbacks, NULL);
  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, dup_iv(iv, 1),
                              1);
  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(item != NULL);
  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);

  nghttp2_frame_settings_free(&frame.settings, mem);
  nghttp2_session_del(session);

  /* Check ACK against no inflight SETTINGS */
  nghttp2_session_server_new(&session, &callbacks, NULL);
  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_ACK, NULL, 0);

  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(item != NULL);
  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);

  nghttp2_frame_settings_free(&frame.settings, mem);
  nghttp2_session_del(session);

  /* Check that 2 SETTINGS_HEADER_TABLE_SIZE 0 and 4096 are included
     and header table size is once cleared to 0. */
  nghttp2_session_client_new(&session, &callbacks, NULL);

  nghttp2_submit_request(session, NULL, &nv, 1, NULL, NULL);

  nghttp2_session_send(session);

  CU_ASSERT(session->hd_deflater.ctx.hd_table.len > 0);

  iv[0].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;
  iv[0].value = 0;

  iv[1].settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;
  iv[1].value = 2048;

  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 2),
                              2);

  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));

  CU_ASSERT(0 == session->hd_deflater.ctx.hd_table.len);
  CU_ASSERT(2048 == session->hd_deflater.ctx.hd_table_bufsize_max);
  CU_ASSERT(2048 == session->remote_settings.header_table_size);

  nghttp2_frame_settings_free(&frame.settings, mem);
  nghttp2_session_del(session);

  /* Check that remote SETTINGS_MAX_CONCURRENT_STREAMS is set to a value set by
     nghttp2_option_set_peer_max_concurrent_streams() and reset to the default
     value (unlimited) after receiving initial SETTINGS frame from the peer. */
  nghttp2_option_new(&option);
  nghttp2_option_set_peer_max_concurrent_streams(option, 1000);
  nghttp2_session_client_new2(&session, &callbacks, NULL, option);
  CU_ASSERT(1000 == session->remote_settings.max_concurrent_streams);

  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, NULL, 0);
  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));
  CU_ASSERT(NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ==
            session->remote_settings.max_concurrent_streams);

  nghttp2_frame_settings_free(&frame.settings, mem);
  nghttp2_session_del(session);
  nghttp2_option_del(option);

  /* Check too large SETTINGS_MAX_FRAME_SIZE */
  nghttp2_session_server_new(&session, &callbacks, NULL);

  iv[0].settings_id = NGHTTP2_SETTINGS_MAX_FRAME_SIZE;
  iv[0].value = NGHTTP2_MAX_FRAME_SIZE_MAX + 1;

  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),
                              1);

  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));

  item = nghttp2_session_get_next_ob_item(session);

  CU_ASSERT(item != NULL);
  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);

  nghttp2_frame_settings_free(&frame.settings, mem);
  nghttp2_session_del(session);

  /* Check the case where stream window size overflows */
  nghttp2_session_server_new(&session, &callbacks, NULL);

  stream1 = open_recv_stream(session, 1);

  /* This will increment window size by 1 */
  nghttp2_frame_window_update_init(&frame.window_update, NGHTTP2_FLAG_NONE, 1,
                                   1);

  CU_ASSERT(0 == nghttp2_session_on_window_update_received(session, &frame));

  nghttp2_frame_window_update_free(&frame.window_update);

  iv[0].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;
  iv[0].value = NGHTTP2_MAX_WINDOW_SIZE;

  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),
                              1);

  /* Now window size gets NGHTTP2_MAX_WINDOW_SIZE + 1, which is
     unacceptable situation in protocol spec. */
  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));

  nghttp2_frame_settings_free(&frame.settings, mem);

  item = nghttp2_session_get_next_ob_item(session);

  CU_ASSERT(NULL != item);
  CU_ASSERT(NGHTTP2_SETTINGS == item->frame.hd.type);

  item = nghttp2_outbound_queue_top(&session->ob_reg);

  CU_ASSERT(NULL != item);
  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);
  CU_ASSERT(NGHTTP2_STREAM_CLOSING == stream1->state);

  nghttp2_session_del(session);

  /* It is invalid that peer disables ENABLE_CONNECT_PROTOCOL once it
     has been enabled. */
  nghttp2_session_client_new(&session, &callbacks, NULL);

  session->remote_settings.enable_connect_protocol = 1;

  iv[0].settings_id = NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL;
  iv[0].value = 0;

  nghttp2_frame_settings_init(&frame.settings, NGHTTP2_FLAG_NONE, dup_iv(iv, 1),
                              1);

  CU_ASSERT(0 == nghttp2_session_on_settings_received(session, &frame, 0));

  nghttp2_frame_settings_free(&frame.settings, mem);

  item = nghttp2_session_get_next_ob_item(session);

  CU_ASSERT(NULL != item);
  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);

  nghttp2_session_del(session);
}
