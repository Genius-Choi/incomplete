void test_nghttp2_session_recv_data(void) {
  nghttp2_session *session;
  nghttp2_session_callbacks callbacks;
  my_user_data ud;
  uint8_t data[8092];
  ssize_t rv;
  nghttp2_outbound_item *item;
  nghttp2_stream *stream;
  nghttp2_frame_hd hd;
  int i;

  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));
  callbacks.send_callback = null_send_callback;
  callbacks.on_data_chunk_recv_callback = on_data_chunk_recv_callback;
  callbacks.on_frame_recv_callback = on_frame_recv_callback;
  callbacks.on_frame_send_callback = on_frame_send_callback;

  nghttp2_session_client_new(&session, &callbacks, &ud);

  /* Create DATA frame with length 4KiB */
  memset(data, 0, sizeof(data));
  hd.length = 4096;
  hd.type = NGHTTP2_DATA;
  hd.flags = NGHTTP2_FLAG_NONE;
  hd.stream_id = 1;
  nghttp2_frame_pack_frame_hd(data, &hd);

  /* stream 1 is not opened, so it must be responded with connection
     error.  This is not mandated by the spec */
  ud.data_chunk_recv_cb_called = 0;
  ud.frame_recv_cb_called = 0;
  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);

  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);
  CU_ASSERT(0 == ud.frame_recv_cb_called);
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);

  nghttp2_session_del(session);

  nghttp2_session_client_new(&session, &callbacks, &ud);

  /* Create stream 1 with CLOSING state. DATA is ignored. */
  stream = open_sent_stream2(session, 1, NGHTTP2_STREAM_CLOSING);

  /* Set initial window size 16383 to check stream flow control,
     isolating it from the connection flow control */
  stream->local_window_size = 16383;

  ud.data_chunk_recv_cb_called = 0;
  ud.frame_recv_cb_called = 0;
  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);

  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);
  CU_ASSERT(0 == ud.frame_recv_cb_called);
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(NULL == item);

  /* This is normal case. DATA is acceptable. */
  stream->state = NGHTTP2_STREAM_OPENED;

  ud.data_chunk_recv_cb_called = 0;
  ud.frame_recv_cb_called = 0;
  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);

  CU_ASSERT(1 == ud.data_chunk_recv_cb_called);
  CU_ASSERT(1 == ud.frame_recv_cb_called);

  CU_ASSERT(NULL == nghttp2_session_get_next_ob_item(session));

  ud.data_chunk_recv_cb_called = 0;
  ud.frame_recv_cb_called = 0;
  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);

  /* Now we got data more than initial-window-size / 2, WINDOW_UPDATE
     must be queued */
  CU_ASSERT(1 == ud.data_chunk_recv_cb_called);
  CU_ASSERT(1 == ud.frame_recv_cb_called);
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);
  CU_ASSERT(1 == item->frame.window_update.hd.stream_id);
  CU_ASSERT(0 == nghttp2_session_send(session));

  /* Set initial window size to 1MiB, so that we can check connection
     flow control individually */
  stream->local_window_size = 1 << 20;
  /* Connection flow control takes into account DATA which is received
     in the error condition. We have received 4096 * 4 bytes of
     DATA. Additional 4 DATA frames, connection flow control will kick
     in. */
  for (i = 0; i < 5; ++i) {
    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);
  }
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(NGHTTP2_WINDOW_UPDATE == item->frame.hd.type);
  CU_ASSERT(0 == item->frame.window_update.hd.stream_id);
  CU_ASSERT(0 == nghttp2_session_send(session));

  /* Reception of DATA with stream ID = 0 causes connection error */
  hd.length = 4096;
  hd.type = NGHTTP2_DATA;
  hd.flags = NGHTTP2_FLAG_NONE;
  hd.stream_id = 0;
  nghttp2_frame_pack_frame_hd(data, &hd);

  ud.data_chunk_recv_cb_called = 0;
  ud.frame_recv_cb_called = 0;
  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);

  CU_ASSERT(0 == ud.data_chunk_recv_cb_called);
  CU_ASSERT(0 == ud.frame_recv_cb_called);
  item = nghttp2_session_get_next_ob_item(session);
  CU_ASSERT(NGHTTP2_GOAWAY == item->frame.hd.type);
  CU_ASSERT(NGHTTP2_PROTOCOL_ERROR == item->frame.goaway.error_code);

  nghttp2_session_del(session);

  /* Check window_update_queued flag in both session and stream */
  nghttp2_session_server_new(&session, &callbacks, &ud);

  hd.length = 4096;
  hd.type = NGHTTP2_DATA;
  hd.flags = NGHTTP2_FLAG_NONE;
  hd.stream_id = 1;
  nghttp2_frame_pack_frame_hd(data, &hd);

  stream = open_recv_stream(session, 1);

  /* Send 32767 bytes of DATA.  In our current flow control algorithm,
     it triggers first WINDOW_UPDATE of window_size_increment
     32767. */
  for (i = 0; i < 7; ++i) {
    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);
  }

  hd.length = 4095;
  nghttp2_frame_pack_frame_hd(data, &hd);
  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4095);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4095 == rv);

  /* Now 2 WINDOW_UPDATEs for session and stream should be queued. */
  CU_ASSERT(0 == stream->recv_window_size);
  CU_ASSERT(0 == session->recv_window_size);
  CU_ASSERT(1 == stream->window_update_queued);
  CU_ASSERT(1 == session->window_update_queued);

  /* Then send 32768 bytes of DATA.  Since we have not sent queued
     WINDOW_UDPATE frame, recv_window_size should not be decreased */
  hd.length = 4096;
  nghttp2_frame_pack_frame_hd(data, &hd);

  for (i = 0; i < 8; ++i) {
    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);
  }

  /* WINDOW_UPDATE is blocked for session and stream, so
     recv_window_size must not be decreased. */
  CU_ASSERT(32768 == stream->recv_window_size);
  CU_ASSERT(32768 == session->recv_window_size);
  CU_ASSERT(1 == stream->window_update_queued);
  CU_ASSERT(1 == session->window_update_queued);

  ud.frame_send_cb_called = 0;

  /* This sends queued WINDOW_UPDATES.  And then check
     recv_window_size, and queue WINDOW_UPDATEs for both session and
     stream, and send them at once. */
  CU_ASSERT(0 == nghttp2_session_send(session));

  CU_ASSERT(4 == ud.frame_send_cb_called);
  CU_ASSERT(0 == stream->recv_window_size);
  CU_ASSERT(0 == session->recv_window_size);
  CU_ASSERT(0 == stream->window_update_queued);
  CU_ASSERT(0 == session->window_update_queued);

  nghttp2_session_del(session);
}
