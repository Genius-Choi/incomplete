void test_nghttp2_session_keep_idle_stream(void) {
  nghttp2_session *session;
  nghttp2_session_callbacks callbacks;
  const size_t max_concurrent_streams = 1;
  nghttp2_settings_entry iv = {NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,
                               (uint32_t)max_concurrent_streams};
  int i;
  int32_t stream_id;

  memset(&callbacks, 0, sizeof(callbacks));
  callbacks.send_callback = null_send_callback;

  nghttp2_session_server_new(&session, &callbacks, NULL);

  nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, &iv, 1);

  /* We at least allow NGHTTP2_MIN_IDLE_STREAM idle streams even if
     max concurrent streams is very low. */
  for (i = 0; i < NGHTTP2_MIN_IDLE_STREAMS; ++i) {
    open_recv_stream2(session, i * 2 + 1, NGHTTP2_STREAM_IDLE);
    nghttp2_session_adjust_idle_stream(session);
  }

  CU_ASSERT(NGHTTP2_MIN_IDLE_STREAMS == session->num_idle_streams);

  stream_id = (NGHTTP2_MIN_IDLE_STREAMS - 1) * 2 + 1;
  CU_ASSERT(1 == session->idle_stream_head->stream_id);
  CU_ASSERT(stream_id == session->idle_stream_tail->stream_id);

  stream_id += 2;

  open_recv_stream2(session, stream_id, NGHTTP2_STREAM_IDLE);
  nghttp2_session_adjust_idle_stream(session);

  CU_ASSERT(NGHTTP2_MIN_IDLE_STREAMS == session->num_idle_streams);
  CU_ASSERT(3 == session->idle_stream_head->stream_id);
  CU_ASSERT(stream_id == session->idle_stream_tail->stream_id);

  nghttp2_session_del(session);
}
