print_status(pe_working_set_t * data_set)
{
    static int updates = 0;

    GListPtr gIter = NULL;
    node_t *dc = NULL;
    char *since_epoch = NULL;
    char *online_nodes = NULL;
    char *offline_nodes = NULL;
    xmlNode *dc_version = NULL;
    xmlNode *quorum_node = NULL;
    xmlNode *stack = NULL;
    time_t a_time = time(NULL);

    int print_opts = pe_print_ncurses;
    const char *quorum_votes = "unknown";

    if (as_console) {
        blank_screen();
    } else {
        print_opts = pe_print_printf;
    }

    updates++;
    dc = data_set->dc_node;

    if (a_time == (time_t) - 1) {
        crm_perror(LOG_ERR, "set_node_tstamp(): Invalid time returned");
        return 1;
    }

    since_epoch = ctime(&a_time);
    if (since_epoch != NULL && print_last_updated) {
        print_as("Last updated: %s", since_epoch);
    }

    if (print_last_change) {
        const char *last_written = crm_element_value(data_set->input, XML_CIB_ATTR_WRITTEN);
        const char *user = crm_element_value(data_set->input, XML_ATTR_UPDATE_USER);
        const char *client = crm_element_value(data_set->input, XML_ATTR_UPDATE_CLIENT);
        const char *origin = crm_element_value(data_set->input, XML_ATTR_UPDATE_ORIG);

        print_as("Last change: %s", last_written ? last_written : "");
        if (user) {
            print_as(" by %s", user);
        }
        if (client) {
            print_as(" via %s", client);
        }
        if (origin) {
            print_as(" on %s", origin);
        }
        print_as("\n");
    }

    stack =
        get_xpath_object("//nvpair[@name='cluster-infrastructure']", data_set->input, LOG_DEBUG);
    if (stack) {
        print_as("Stack: %s\n", crm_element_value(stack, XML_NVPAIR_ATTR_VALUE));
    }

    dc_version = get_xpath_object("//nvpair[@name='dc-version']", data_set->input, LOG_DEBUG);
    if (dc == NULL) {
        print_as("Current DC: NONE\n");
    } else {
        const char *quorum = crm_element_value(data_set->input, XML_ATTR_HAVE_QUORUM);

        if (safe_str_neq(dc->details->uname, dc->details->id)) {
            print_as("Current DC: %s (%s)", dc->details->uname, dc->details->id);
        } else {
            print_as("Current DC: %s", dc->details->uname);
        }
        print_as(" - partition %s quorum\n", crm_is_true(quorum) ? "with" : "WITHOUT");
        if (dc_version) {
            print_as("Version: %s\n", crm_element_value(dc_version, XML_NVPAIR_ATTR_VALUE));
        }
    }

    quorum_node =
        get_xpath_object("//nvpair[@name='" XML_ATTR_EXPECTED_VOTES "']", data_set->input,
                         LOG_DEBUG);
    if (quorum_node) {
        quorum_votes = crm_element_value(quorum_node, XML_NVPAIR_ATTR_VALUE);
    }

    print_as("%d Nodes configured, %s expected votes\n", g_list_length(data_set->nodes),
             quorum_votes);
    print_as("%d Resources configured.\n", count_resources(data_set, NULL));
    print_as("\n\n");

    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {
        node_t *node = (node_t *) gIter->data;
        const char *node_mode = NULL;

        if (node->details->unclean) {
            if (node->details->online && node->details->unclean) {
                node_mode = "UNCLEAN (online)";

            } else if (node->details->pending) {
                node_mode = "UNCLEAN (pending)";

            } else {
                node_mode = "UNCLEAN (offline)";
            }

        } else if (node->details->pending) {
            node_mode = "pending";

        } else if (node->details->standby_onfail && node->details->online) {
            node_mode = "standby (on-fail)";

        } else if (node->details->standby) {
            if (node->details->online) {
                node_mode = "standby";
            } else {
                node_mode = "OFFLINE (standby)";
            }

        } else if (node->details->online) {
            node_mode = "online";
            if (group_by_node == FALSE) {
                online_nodes = add_list_element(online_nodes, node->details->uname);
                continue;
            }

        } else {
            node_mode = "OFFLINE";
            if (group_by_node == FALSE) {
                offline_nodes = add_list_element(offline_nodes, node->details->uname);
                continue;
            }
        }

        if (safe_str_eq(node->details->uname, node->details->id)) {
            print_as("Node %s: %s\n", node->details->uname, node_mode);
        } else {
            print_as("Node %s (%s): %s\n", node->details->uname, node->details->id, node_mode);
        }

        if (group_by_node) {
            GListPtr gIter2 = NULL;

            for (gIter2 = node->details->running_rsc; gIter2 != NULL; gIter2 = gIter2->next) {
                resource_t *rsc = (resource_t *) gIter2->data;

                rsc->fns->print(rsc, "\t", print_opts | pe_print_rsconly, stdout);
            }
        }
    }

    if (online_nodes) {
        print_as("Online: [%s ]\n", online_nodes);
        free(online_nodes);
    }
    if (offline_nodes) {
        print_as("OFFLINE: [%s ]\n", offline_nodes);
        free(offline_nodes);
    }

    if (group_by_node == FALSE && inactive_resources) {
        print_as("\nFull list of resources:\n");

    } else if (inactive_resources) {
        print_as("\nInactive resources:\n");
    }

    if (group_by_node == FALSE || inactive_resources) {
        print_as("\n");
        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {
            resource_t *rsc = (resource_t *) gIter->data;

            gboolean is_active = rsc->fns->active(rsc, TRUE);
            gboolean partially_active = rsc->fns->active(rsc, FALSE);

            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {
                continue;

            } else if (group_by_node == FALSE) {
                if (partially_active || inactive_resources) {
                    rsc->fns->print(rsc, NULL, print_opts, stdout);
                }

            } else if (is_active == FALSE && inactive_resources) {
                rsc->fns->print(rsc, NULL, print_opts, stdout);
            }
        }
    }

    if (print_nodes_attr) {
        print_as("\nNode Attributes:\n");
        for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {
            node_t *node = (node_t *) gIter->data;

            if (node == NULL || node->details->online == FALSE) {
                continue;
            }
            attr_list = NULL;
            print_as("* Node %s:\n", node->details->uname);
            g_hash_table_foreach(node->details->attrs, create_attr_list, NULL);
            g_list_foreach(attr_list, print_node_attribute, node);
        }
    }

    if (print_operations || print_failcount) {
        print_node_summary(data_set, print_operations);
    }

    if (xml_has_children(data_set->failed)) {
        xmlNode *xml_op = NULL;

        print_as("\nFailed actions:\n");
        for (xml_op = __xml_first_child(data_set->failed); xml_op != NULL;
             xml_op = __xml_next(xml_op)) {
            int val = 0;
            const char *id = ID(xml_op);
            const char *op_key = crm_element_value(xml_op, XML_LRM_ATTR_TASK_KEY);
            const char *last = crm_element_value(xml_op, "last_run");
            const char *node = crm_element_value(xml_op, XML_ATTR_UNAME);
            const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);
            const char *rc = crm_element_value(xml_op, XML_LRM_ATTR_RC);
            const char *status = crm_element_value(xml_op, XML_LRM_ATTR_OPSTATUS);

            val = crm_parse_int(status, "0");
            print_as("    %s (node=%s, call=%s, rc=%s, status=%s",
                     op_key ? op_key : id, node, call, rc, services_lrm_status_str(val));

            if (last) {
                time_t run_at = crm_parse_int(last, "0");

                print_as(", last-run=%s, queued=%sms, exec=%sms\n",
                         ctime(&run_at),
                         crm_element_value(xml_op, "exec_time"),
                         crm_element_value(xml_op, "queue_time"));
            }

            val = crm_parse_int(rc, "0");
            print_as("): %s\n", lrmd_event_rc2str(val));
        }
    }

    if (print_tickets) {
        print_cluster_tickets(data_set);
    }

#if CURSES_ENABLED
    if (as_console) {
        refresh();
    }
#endif
    return 0;
}
