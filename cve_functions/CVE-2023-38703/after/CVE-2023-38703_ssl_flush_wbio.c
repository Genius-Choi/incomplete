static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)
{
    pj_size_t len;
    pj_status_t status = PJ_SUCCESS;

    DTLS_LOCK(ds);

    if (!ds->ossl_wbio[idx]) {
        DTLS_UNLOCK(ds);
        return PJ_EGONE;
    }

    /* Check whether there is data to send */
    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {
        /* Yes, get and send it */
        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));
        if (len > 0) {
            DTLS_UNLOCK(ds);

            status = send_raw(ds, idx, ds->buf[idx], len);
            if (status != PJ_SUCCESS) {
#if DTLS_DEBUG
                pj_perror(2, ds->base.name, status, "Send error");
#endif
                /* This error should be recoverable, remote will retransmit
                 * its packet when not receiving from us.
                 */
            }
            DTLS_LOCK(ds);
        }
    }

    if (!ds->ossl_ssl[idx]) {
        DTLS_UNLOCK(ds);
        return PJ_EGONE;
    }

    /* Just return if handshake completion procedure (key parsing, fingerprint
     * verification, etc) has been done or handshake is still in progress.
     */
    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {
        DTLS_UNLOCK(ds);
        return PJ_SUCCESS;
    }

    /* Yes, SSL handshake is done! */
    ds->nego_completed[idx] = PJ_TRUE;
    PJ_LOG(2,(ds->base.name, "DTLS-SRTP negotiation for %s completed!",
                             CHANNEL_TO_STRING(idx)));

    DTLS_UNLOCK(ds);

    /* Stop the retransmission clock. Note that the clock may not be stopped
     * if this function is called from clock thread context. We'll try again
     * later in socket context.
     */
    if (ds->clock[idx])
        pjmedia_clock_stop(ds->clock[idx]);

    /* Get SRTP key material */
    status = ssl_get_srtp_material(ds, idx);
    if (status != PJ_SUCCESS) {
        pj_perror(4, ds->base.name, status,
                  "Failed to get SRTP material");
        goto on_return;
    }

    /* Verify remote fingerprint if we've already got one from SDP */
    if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING) {
        ds->rem_fprint_status = status = ssl_match_fingerprint(ds, idx);
        if (status != PJ_SUCCESS) {
            pj_perror(4, ds->base.name, status,
                      "Fingerprint specified in remote SDP doesn't match "
                      "to actual remote certificate fingerprint!");
            goto on_return;
        }
    }

    /* If media_start() has been called, start SRTP now */
    if (ds->pending_start && idx == RTP_CHANNEL) {
        ds->pending_start = PJ_FALSE;
        ds->srtp->keying_pending_cnt--;

        /* Copy negotiated policy to SRTP */
        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];
        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];

        status = start_srtp(ds->srtp);
        if (status != PJ_SUCCESS)
            pj_perror(4, ds->base.name, status, "Failed starting SRTP");
    } else if (idx == RTCP_CHANNEL) {
        pjmedia_srtp_setting setting;

        pjmedia_srtp_setting_default (&setting);

        /* Copy negotiated policy to SRTP */
        ds->srtp->srtp_rtcp.tx_policy_neg = ds->tx_crypto[idx];
        ds->srtp->srtp_rtcp.rx_policy_neg = ds->rx_crypto[idx];

        status = create_srtp_ctx(ds->srtp, &ds->srtp->srtp_rtcp,
                                 &setting, &ds->srtp->srtp_rtcp.tx_policy_neg,
                                 &ds->srtp->srtp_rtcp.rx_policy_neg);
        if (status != PJ_SUCCESS)
            pj_perror(4, ds->base.name, status, "Failed creating SRTP RTCP");
    }

on_return:
    if (idx == RTP_CHANNEL && ds->srtp->setting.cb.on_srtp_nego_complete) {
        (*ds->srtp->setting.cb.on_srtp_nego_complete)
                                            (&ds->srtp->base, status);
    }

    return status;
}
