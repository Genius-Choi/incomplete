static pj_status_t dtls_media_start( pjmedia_transport *tp,
                                     pj_pool_t *tmp_pool,
                                     const pjmedia_sdp_session *sdp_local,
                                     const pjmedia_sdp_session *sdp_remote,
                                     unsigned media_index)
{
    dtls_srtp *ds = (dtls_srtp *)tp;
    pj_ice_strans_state ice_state;
    pj_bool_t use_rtcp_mux = PJ_FALSE;
    pj_status_t status = PJ_SUCCESS;
    struct transport_srtp *srtp = (struct transport_srtp*)tp->user_data;

#if DTLS_DEBUG
    PJ_LOG(2,(ds->base.name, "dtls_media_start()"));
#endif

    PJ_UNUSED_ARG(tmp_pool);
    PJ_UNUSED_ARG(sdp_local);

    if (ds->srtp->offerer_side) {
        /* As offerer */
        dtls_setup last_setup = ds->setup;
        pj_str_t last_rem_fp = ds->rem_fingerprint;

        /* Parse a=setup and a=fingerprint */
        status = parse_setup_finger_attr(ds, PJ_FALSE, sdp_remote,
                                         media_index);
        if (status != PJ_SUCCESS)
            goto on_return;

        /* Check if remote signals DTLS re-nego by changing its
         * setup/fingerprint in SDP.
         */
        if ((last_setup != DTLS_SETUP_ACTPASS && last_setup != ds->setup) ||
            (last_rem_fp.slen &&
             pj_memcmp(&last_rem_fp, &ds->rem_fingerprint, sizeof(pj_str_t))))
        {
            dtls_media_stop_channel(ds, RTP_CHANNEL);
            dtls_media_stop_channel(ds, RTCP_CHANNEL);
            ds->got_keys = PJ_FALSE;
            ds->rem_fprint_status = PJ_EPENDING;
        }
    } else {
        /* As answerer */
        
        /* Nothing to do? */
    }

    /* Check and update ICE and rtcp-mux status */
    {
        pjmedia_transport_info info;
        pjmedia_ice_transport_info *ice_info;

        pjmedia_transport_info_init(&info);
        pjmedia_transport_get_info(ds->srtp->member_tp, &info);
        if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,
                            &info.sock_info.rtcp_addr_name) == 0)
        {
            ds->srtp->use_rtcp_mux = use_rtcp_mux = PJ_TRUE;
        }
        ice_info = (pjmedia_ice_transport_info*)
                   pjmedia_transport_info_get_spc_info(
                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);
        ds->use_ice = ice_info && ice_info->active;
        ice_state = ds->use_ice? ice_info->sess_state : 0;

        /* Update remote RTP & RTCP addresses */
        get_rem_addrs(ds, sdp_remote, media_index, &ds->rem_addr,
                      &ds->rem_rtcp, NULL);
    }

    /* Check if the background DTLS nego has completed */
    if (ds->got_keys) { 
        unsigned idx = RTP_CHANNEL;

        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];
        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];

        /* Verify remote fingerprint (if available) */
        if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING)
        {
            ds->rem_fprint_status = ssl_match_fingerprint(ds, idx);
            if (ds->rem_fprint_status != PJ_SUCCESS) {
                pj_perror(4, ds->base.name, ds->rem_fprint_status,
                          "Fingerprint specified in remote SDP doesn't match "
                          "to actual remote certificate fingerprint!");
                return ds->rem_fprint_status;
            }
        }

        return PJ_SUCCESS;
    } 

    /* SRTP key is not ready, SRTP start is pending */
    ds->srtp->keying_pending_cnt++;
    ds->pending_start = PJ_TRUE;

    srtp->peer_use = PJMEDIA_SRTP_MANDATORY;

    /* If our DTLS setup is ACTIVE:
     * - start DTLS nego after ICE nego, or
     * - start it now if there is no ICE.
     */
    if (ds->setup == DTLS_SETUP_ACTIVE) {
        if (ds->use_ice && ice_state < PJ_ICE_STRANS_STATE_RUNNING)  {
            /* Register ourselves to listen to ICE notifications */
            pjmedia_ice_cb ice_cb;
            pj_bzero(&ice_cb, sizeof(ice_cb));
            ice_cb.on_ice_complete2 = &on_ice_complete2;
            pjmedia_ice_add_ice_cb(ds->srtp->member_tp, &ice_cb, ds);
        } else {
            /* This can happen when we are SDP offerer and remote wants
             * PASSIVE DTLS role.
             */
            pjmedia_transport_attach_param ap;
            pj_bzero(&ap, sizeof(ap));
            ap.user_data = ds->srtp;

            /* Attach ourselves to member transport for DTLS nego. */
            if (pj_sockaddr_has_addr(&ds->rem_addr))
                pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);
            else
                pj_sockaddr_init(pj_AF_INET(), &ap.rem_addr, 0, 0);

            if (use_rtcp_mux) {
                /* Using RTP & RTCP multiplexing */
                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);
            } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {
                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);
            } else if (pj_sockaddr_has_addr(&ds->rem_addr)) {
                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);
                pj_sockaddr_set_port(&ap.rem_rtcp,
                                     pj_sockaddr_get_port(&ap.rem_rtcp) + 1);
            } else {
                pj_sockaddr_init(pj_AF_INET(), &ap.rem_rtcp, 0, 0);
            }

            ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);
            status = pjmedia_transport_attach2(&ds->srtp->base, &ap);
            if (status != PJ_SUCCESS)
                goto on_return;
#if DTLS_DEBUG
            {
                char addr[PJ_INET6_ADDRSTRLEN];
                PJ_LOG(2,(ds->base.name, "Attached transport, "
                          "remote addr=%s:%d",
                          pj_sockaddr_print(&ap.rem_addr, addr,
                          sizeof(addr), 2),
                          pj_sockaddr_get_port(&ap.rem_addr)));
            }
#endif
            
            status = ssl_handshake(ds);
            if (status != PJ_SUCCESS)
                goto on_return;
        }
    }

on_return:
#if DTLS_DEBUG
    if (status != PJ_SUCCESS) {
        pj_perror(4, ds->base.name, status, "dtls_media_start() failed");
    }
#endif
    return status;
}
