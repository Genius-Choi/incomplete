static pj_status_t parse_cand(const char *obj_name,
                              pj_pool_t *pool,
                              const pj_str_t *orig_input,
                              pj_ice_sess_cand *cand)
{
    pj_str_t token, delim, host;
    int af;
    pj_ssize_t found_idx;
    pj_status_t status = PJNATH_EICEINCANDSDP;

    pj_bzero(cand, sizeof(*cand));

    PJ_UNUSED_ARG(obj_name);

    /* Foundation */
    delim = pj_str(" ");
    found_idx = pj_strtok(orig_input, &delim, &token, 0);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE foundation in candidate"));
        goto on_return;
    }
    if (pool) {
        pj_strdup(pool, &cand->foundation, &token);
    } else {
        cand->foundation = token;
    }

    /* Component ID */
    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE component ID in candidate"));
        goto on_return;
    }
    cand->comp_id = (pj_uint8_t)pj_strtoul(&token);

    /* Transport */
    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE transport in candidate"));
        goto on_return;
    }
    if (pj_stricmp2(&token, "UDP") != 0) {
        TRACE__((obj_name, 
                 "Expecting ICE UDP transport only in candidate"));
        goto on_return;
    }

    /* Priority */
    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE priority in candidate"));
        goto on_return;
    }
    cand->prio = pj_strtoul(&token);

    /* Host */
    found_idx = pj_strtok(orig_input, &delim, &host, found_idx + token.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE host in candidate"));
        goto on_return;
    }
    /* Detect address family */
    if (pj_strchr(&host, ':'))
        af = pj_AF_INET6();
    else
        af = pj_AF_INET();
    /* Assign address */
    if (pj_sockaddr_init(af, &cand->addr, &host, 0)) {
        TRACE__((obj_name, "Invalid ICE candidate address"));
        goto on_return;
    }

    /* Port */
    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + host.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE port number in candidate"));
        goto on_return;
    }
    pj_sockaddr_set_port(&cand->addr, (pj_uint16_t)pj_strtoul(&token));

    /* typ */
    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE \"typ\" in candidate"));
        goto on_return;
    }
    if (pj_stricmp2(&token, "typ") != 0) {
        TRACE__((obj_name, "Expecting ICE \"typ\" in candidate"));
        goto on_return;
    }

    /* candidate type */
    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);
    if (found_idx == orig_input->slen) {
        TRACE__((obj_name, "Expecting ICE candidate type in candidate"));
        goto on_return;
    }

    if (pj_stricmp2(&token, "host") == 0) {
        cand->type = PJ_ICE_CAND_TYPE_HOST;

    } else if (pj_stricmp2(&token, "srflx") == 0) {
        cand->type = PJ_ICE_CAND_TYPE_SRFLX;

    } else if (pj_stricmp2(&token, "relay") == 0) {
        cand->type = PJ_ICE_CAND_TYPE_RELAYED;

    } else if (pj_stricmp2(&token, "prflx") == 0) {
        cand->type = PJ_ICE_CAND_TYPE_PRFLX;

    } else {
        PJ_LOG(5,(obj_name, "Invalid ICE candidate type %.*s in candidate", 
                  (int)token.slen, token.ptr));
        goto on_return;
    }

    status = PJ_SUCCESS;

on_return:
    return status;
}
