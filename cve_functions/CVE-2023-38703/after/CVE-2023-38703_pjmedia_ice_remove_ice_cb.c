PJ_DEF(pj_status_t) pjmedia_ice_remove_ice_cb( pjmedia_transport *tp,
                                               const pjmedia_ice_cb *cb,
                                               void *user_data)
{
    struct transport_ice *tp_ice = (struct transport_ice*)tp;
    ice_listener *il;
    pj_grp_lock_t *grp_lock;

    PJ_ASSERT_RETURN(tp && cb, PJ_EINVAL);
    grp_lock = pjmedia_ice_get_grp_lock(tp);
    PJ_ASSERT_RETURN(grp_lock, PJ_EINVAL);

    pj_grp_lock_acquire(grp_lock);

    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {
        if (pj_memcmp(&il->cb, cb, sizeof(*cb))==0 && il->user_data==user_data)
            break;
    }
    if (il != &tp_ice->listener) {
        pj_list_erase(il);
        pj_list_push_back(&tp_ice->listener_empty, il);
    }

    pj_grp_lock_release(grp_lock);

    return (il != &tp_ice->listener? PJ_SUCCESS : PJ_ENOTFOUND);
}
