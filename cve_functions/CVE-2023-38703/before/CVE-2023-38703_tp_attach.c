static pj_status_t tp_attach          (pjmedia_transport *tp,
                                       void *user_data,
                                       const pj_sockaddr_t *rem_addr,
                                       const pj_sockaddr_t *rem_rtcp,
                                       unsigned addr_len,
                                       void (*rtp_cb)(void*,
                                                      void*,
                                                      pj_ssize_t),
                                       void (*rtp_cb2)(pjmedia_tp_cb_param*),
                                       void (*rtcp_cb)(void*,
                                                       void*,
                                                       pj_ssize_t))
{
    struct transport_udp *udp = (struct transport_udp*) tp;
    const pj_sockaddr *rtcp_addr;
    pj_sockaddr sock_addr, remote_addr, remote_rtcp;
    int rem_addr_len;
    pj_status_t status;

    /* Validate arguments */
    PJ_ASSERT_RETURN(tp && rem_addr && addr_len, PJ_EINVAL);

    /* Must not be "attached" to existing application */
    //PJ_ASSERT_RETURN(!udp->attached, PJ_EINVALIDOP);

    /* Check again if we are multiplexing RTP & RTCP. */
    udp->use_rtcp_mux = (pj_sockaddr_has_addr(rem_addr) &&
                         pj_sockaddr_cmp(rem_addr, rem_rtcp) == 0);

    TRACE_((udp->base.name, "attach(): before locking keys"));

    /* Lock the ioqueue keys to make sure that callbacks are
     * not executed. See ticket #844 for details.
     */
    pj_ioqueue_lock_key(udp->rtp_key);
    pj_ioqueue_lock_key(udp->rtcp_key);

    TRACE_((udp->base.name, "attach(): inside locked keys"));

    /* "Attach" the application: */

    rem_addr_len = sizeof(pj_sockaddr);
    pj_sock_getsockname(udp->rtp_sock, &sock_addr, &rem_addr_len);

    /* Synthesize address, if necessary. */
    status = pj_sockaddr_synthesize(sock_addr.addr.sa_family,
                                    &remote_addr, rem_addr);
    if (status != PJ_SUCCESS) {
        pj_perror(3, tp->name, status, "Failed to synthesize the correct"
                                       "IP address for RTP");
    }
    rem_addr_len = pj_sockaddr_get_len(&remote_addr);

    /* Copy remote RTP address */
    pj_memcpy(&udp->rem_rtp_addr, &remote_addr, rem_addr_len);

    /* Copy remote RTP address, if one is specified. */
    rtcp_addr = (const pj_sockaddr*) rem_rtcp;
    if (rtcp_addr && pj_sockaddr_has_addr(rtcp_addr)) {
        status = pj_sockaddr_synthesize(sock_addr.addr.sa_family,
                                        &remote_rtcp, rem_rtcp);
        if (status != PJ_SUCCESS) {
            pj_perror(3, tp->name, status, "Failed to synthesize the correct"
                                           "IP address for RTCP");
        }
        pj_memcpy(&udp->rem_rtcp_addr, &remote_rtcp, rem_addr_len);

    } else {
        unsigned rtcp_port;

        /* Otherwise guess the RTCP address from the RTP address */
        pj_memcpy(&udp->rem_rtcp_addr, &udp->rem_rtp_addr, rem_addr_len);
        rtcp_port = pj_sockaddr_get_port(&udp->rem_rtp_addr) + 1;
        pj_sockaddr_set_port(&udp->rem_rtcp_addr, (pj_uint16_t)rtcp_port);
    }

    /* Save the callbacks */
    udp->rtp_cb = rtp_cb;
    udp->rtp_cb2 = rtp_cb2;
    udp->rtcp_cb = rtcp_cb;
    udp->user_data = user_data;

    /* Save address length */
    udp->addr_len = rem_addr_len;

    /* Last, mark transport as attached */
    //udp->attached = PJ_TRUE;

    /* Reset source RTP & RTCP addresses and counter */
    pj_bzero(&udp->rtp_src_addr, sizeof(udp->rtp_src_addr));
    pj_bzero(&udp->rtcp_src_addr, sizeof(udp->rtcp_src_addr));
    udp->rtcp_src_cnt = 0;

    /* Set buffer size for RTP socket */
#if PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE
    {
        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;
        
        status = pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_RCVBUF(),
                                          PJ_TRUE, &sobuf_size);
        if (status != PJ_SUCCESS) {
            pj_perror(3, tp->name, status, "Failed setting SO_RCVBUF");
        } else {
            if (sobuf_size < PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE) {
                PJ_LOG(4, (tp->name, 
                           "Warning! Cannot set SO_RCVBUF as configured, "
                           "now=%d, configured=%d",
                           sobuf_size, PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE));
            } else {
                PJ_LOG(5, (tp->name, "SO_RCVBUF set to %d", sobuf_size));
            }
        }
    }
#endif
#if PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE
    {
        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;

        status = pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_SNDBUF(),
                                          PJ_TRUE, &sobuf_size);
        if (status != PJ_SUCCESS) {
            pj_perror(3, tp->name, status, "Failed setting SO_SNDBUF");
        } else {
            if (sobuf_size < PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE) {
                PJ_LOG(4, (tp->name, 
                           "Warning! Cannot set SO_SNDBUF as configured, "
                           "now=%d, configured=%d",
                           sobuf_size, PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE));
            } else {
                PJ_LOG(5, (tp->name, "SO_SNDBUF set to %d", sobuf_size));
            }
        }
    }
#endif

    /* Unlock keys */
    pj_ioqueue_unlock_key(udp->rtcp_key);
    pj_ioqueue_unlock_key(udp->rtp_key);

    PJ_LOG(4,(udp->base.name, "UDP media transport attached"));

    return PJ_SUCCESS;
}
