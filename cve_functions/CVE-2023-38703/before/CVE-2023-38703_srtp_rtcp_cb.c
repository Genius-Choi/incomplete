static void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size)
{
    transport_srtp *srtp = (transport_srtp *) user_data;
    int len = (int)size;
    srtp_err_status_t err;
    void (*cb)(void*, void*, pj_ssize_t) = NULL;
    void *cb_data = NULL;

    if (srtp->bypass_srtp) {
        srtp->rtcp_cb(srtp->user_data, pkt, size);
        return;
    }

    if (size < 0) {
        return;
    }

    /* Give the packet to keying first by invoking its send_rtcp() op,
     * in the same way as for RTP packet above.
     */
    {
        unsigned i;
        pj_status_t status;
        for (i=0; i < srtp->keying_cnt; i++) {
            if (!srtp->keying[i]->op->send_rtcp)
                continue;
            status = pjmedia_transport_send_rtcp(srtp->keying[i], pkt, size);
            if (status != PJ_EIGNORED) {
                /* Packet is already consumed by the keying method */
                return;
            }
        }
    }

    /* Make sure buffer is 32bit aligned */
    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );

    pj_lock_acquire(srtp->mutex);

    if (!srtp->session_inited) {
        pj_lock_release(srtp->mutex);
        return;
    }
    err = srtp_unprotect_rtcp(srtp->srtp_rtcp.srtp_rx_ctx?
                              srtp->srtp_rtcp.srtp_rx_ctx:
                              srtp->srtp_ctx.srtp_rx_ctx,
                              (pj_uint8_t*)pkt, &len);
    if (err != srtp_err_status_ok) {
        PJ_LOG(5,(srtp->pool->obj_name,
                  "Failed to unprotect SRTCP, pkt size=%ld, err=%s",
                  size, get_libsrtp_errstr(err)));
    } else {
        cb = srtp->rtcp_cb;
        cb_data = srtp->user_data;
    }

    pj_lock_release(srtp->mutex);

    if (cb) {
        (*cb)(cb_data, pkt, len);
    }
}
