PJ_DEF(pj_status_t) pjmedia_transport_udp_create3(pjmedia_endpt *endpt,
                                                  int af,
                                                  const char *name,
                                                  const pj_str_t *addr,
                                                  int port,
                                                  unsigned options,
                                                  pjmedia_transport **p_tp)
{
    pjmedia_sock_info si;
    pj_status_t status;

    
    /* Sanity check */
    PJ_ASSERT_RETURN(endpt && port && p_tp, PJ_EINVAL);


    pj_bzero(&si, sizeof(pjmedia_sock_info));
    si.rtp_sock = si.rtcp_sock = PJ_INVALID_SOCKET;

    /* Create RTP socket */
    status = pj_sock_socket(af, pj_SOCK_DGRAM() | pj_SOCK_CLOEXEC(), 0, &si.rtp_sock);
    if (status != PJ_SUCCESS)
        goto on_error;

    /* Bind RTP socket */
    status = pj_sockaddr_init(af, &si.rtp_addr_name, addr, (pj_uint16_t)port);
    if (status != PJ_SUCCESS)
        goto on_error;

    status = pj_sock_bind(si.rtp_sock, &si.rtp_addr_name, 
                          pj_sockaddr_get_len(&si.rtp_addr_name));
    if (status != PJ_SUCCESS)
        goto on_error;


    /* Create RTCP socket */
    status = pj_sock_socket(af, pj_SOCK_DGRAM() | pj_SOCK_CLOEXEC(), 0, &si.rtcp_sock);
    if (status != PJ_SUCCESS)
        goto on_error;

    /* Bind RTCP socket */
    status = pj_sockaddr_init(af, &si.rtcp_addr_name, addr, 
                              (pj_uint16_t)(port+1));
    if (status != PJ_SUCCESS)
        goto on_error;

    status = pj_sock_bind(si.rtcp_sock, &si.rtcp_addr_name,
                          pj_sockaddr_get_len(&si.rtcp_addr_name));
    if (status != PJ_SUCCESS)
        goto on_error;

    
    /* Create UDP transport by attaching socket info */
    return pjmedia_transport_udp_attach( endpt, name, &si, options, p_tp);


on_error:
    if (si.rtp_sock != PJ_INVALID_SOCKET)
        pj_sock_close(si.rtp_sock);
    if (si.rtcp_sock != PJ_INVALID_SOCKET)
        pj_sock_close(si.rtcp_sock);
    return status;
}
