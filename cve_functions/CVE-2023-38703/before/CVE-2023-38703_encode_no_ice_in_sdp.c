static pj_status_t encode_no_ice_in_sdp( struct transport_ice *tp_ice,
                                         pj_pool_t *pool,
                                         pjmedia_sdp_session *sdp_local,
                                         const pjmedia_sdp_session *rem_sdp,
                                         unsigned media_index)
{
    if (tp_ice->enable_rtcp_mux) {
        pjmedia_sdp_media *m = sdp_local->media[media_index];
        pjmedia_sdp_attr *attr;
        pj_bool_t add_rtcp_mux = PJ_TRUE;

        if (rem_sdp)
            add_rtcp_mux = tp_ice->use_rtcp_mux;
        else {
            /* For subsequent offer, set it to false first since
             * we are still waiting for remote answer.
             */
            tp_ice->use_rtcp_mux = PJ_FALSE;
        }

        /* Remove RTCP attribute because for subsequent offers/answers,
         * the address (obtained from transport_get_info() ) may be
         * incorrect if we are not yet confirmed to use RTCP mux
         * (because we are still waiting for remote answer) or
         * if remote rejects it.
         */
        pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, "rtcp");
        
        if (!tp_ice->use_rtcp_mux && tp_ice->comp_cnt > 1) {
            pj_ice_sess_cand cand;
            pj_status_t status;
            
            status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 2, &cand);
            if (status == PJ_SUCCESS) {
                /* Add RTCP attribute if the remote doesn't offer or
                 * rejects it.
                 */
                attr = pjmedia_sdp_attr_create_rtcp(pool, &cand.addr);  
                if (attr)
                    pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);
            }
        }

        /* Add a=rtcp-mux attribute. */
        if (add_rtcp_mux) {
            attr = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_attr);
            attr->name = STR_RTCP_MUX;
            m->attr[m->attr_count++] = attr;
        }
    }
    return PJ_SUCCESS;
}
