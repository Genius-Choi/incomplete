static void on_rx_rtp(pj_ioqueue_key_t *key,
                      pj_ioqueue_op_key_t *op_key,
                      pj_ssize_t bytes_read)
{
    struct transport_udp *udp;
    pj_status_t status;
    pj_bool_t rem_switch = PJ_FALSE;
    pj_bool_t transport_restarted = PJ_FALSE;
    unsigned num_err = 0;
    pj_status_t last_err = PJ_SUCCESS;

    PJ_UNUSED_ARG(op_key);

    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);

    if (-bytes_read == PJ_ECANCELLED) {
        TRACE_((udp->base.name, "on_rx_rtp(): got PJ_ECANCELLED"));
        return;
    }

    if (-bytes_read == PJ_ESOCKETSTOP) {
        TRACE_((udp->base.name, "on_rx_rtp(): got PJ_ESOCKETSTOP"));

        /* Try to recover by restarting the transport. */
        status = transport_restart(PJ_TRUE, udp);
        if (status != PJ_SUCCESS) {
            bytes_read = -PJ_ESOCKETSTOP;
            call_rtp_cb(udp, bytes_read, NULL);
        }
        return;
    }

    do {
        pj_bool_t discard = PJ_FALSE;

        /* Simulate packet lost on RX direction */
        if (udp->rx_drop_pct) {
            if ((pj_rand() % 100) <= (int)udp->rx_drop_pct) {
                PJ_LOG(5,(udp->base.name, 
                          "RX RTP packet dropped because of pkt lost "
                          "simulation"));
                discard = PJ_TRUE;
            }
        }

        //if (!discard && udp->attached && cb)
        if (!discard && 
            (-bytes_read != PJ_STATUS_FROM_OS(PJ_BLOCKING_ERROR_VAL))) 
        {
            call_rtp_cb(udp, bytes_read, &rem_switch);
        }

#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \
    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)
        if (rem_switch &&
            (udp->options & PJMEDIA_UDP_NO_SRC_ADDR_CHECKING)==0)
        {
            char addr_text[PJ_INET6_ADDRSTRLEN+10];

            /* Set remote RTP address to source address */
            pj_sockaddr_cp(&udp->rem_rtp_addr, &udp->rtp_src_addr);

            PJ_LOG(4,(udp->base.name,
                      "Remote RTP address switched to %s",
                      pj_sockaddr_print(&udp->rtp_src_addr, addr_text,
                                        sizeof(addr_text), 3)));

            if (udp->use_rtcp_mux) {
                pj_sockaddr_cp(&udp->rem_rtcp_addr, &udp->rem_rtp_addr);
                pj_sockaddr_cp(&udp->rtcp_src_addr, &udp->rem_rtcp_addr);
            } else if (!pj_sockaddr_has_addr(&udp->rtcp_src_addr)) {
                /* Also update remote RTCP address if actual RTCP source
                 * address is not heard yet.
                 */
                pj_uint16_t port;

                pj_sockaddr_cp(&udp->rem_rtcp_addr, &udp->rem_rtp_addr);
                port = (pj_uint16_t)
                       (pj_sockaddr_get_port(&udp->rem_rtp_addr)+1);
                pj_sockaddr_set_port(&udp->rem_rtcp_addr, port);

                pj_sockaddr_cp(&udp->rtcp_src_addr, &udp->rem_rtcp_addr);

                PJ_LOG(4,(udp->base.name,
                          "Remote RTCP address switched to predicted"
                          " address %s",
                          pj_sockaddr_print(&udp->rtcp_src_addr, addr_text,
                                            sizeof(addr_text), 3)));
            }
        }
#endif

        bytes_read = sizeof(udp->rtp_pkt);
        udp->rtp_addrlen = sizeof(udp->rtp_src_addr);
        status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,
                                        udp->rtp_pkt, &bytes_read, 0,
                                        &udp->rtp_src_addr,
                                        &udp->rtp_addrlen);

        if (status != PJ_EPENDING && status != PJ_SUCCESS) {        
            if (transport_restarted && last_err == status) {
                /* Still the same error after restart */
                bytes_read = -PJ_ESOCKETSTOP;
                call_rtp_cb(udp, bytes_read, NULL);
                break;
            } else if (PJMEDIA_IGNORE_RECV_ERR_CNT) {
                if (last_err == status) {
                    ++num_err;
                } else {
                    num_err = 1;
                    last_err = status;
                }

                if (status == PJ_ESOCKETSTOP ||
                    num_err > PJMEDIA_IGNORE_RECV_ERR_CNT)
                {
                    status = transport_restart(PJ_TRUE, udp);               
                    if (status != PJ_SUCCESS) {
                        bytes_read = -PJ_ESOCKETSTOP;
                        call_rtp_cb(udp, bytes_read, NULL);
                        break;
                    }
                    transport_restarted = PJ_TRUE;
                    num_err = 0;
                }
            }
            bytes_read = -status;
            TRACE_((udp->base.name, "on_rx_rtp(): recvfrom error=%d", status));
        }
    } while (status != PJ_EPENDING && status != PJ_ECANCELLED &&
             udp->started);
}
