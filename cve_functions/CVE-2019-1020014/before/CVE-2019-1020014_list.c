GError *list(char *ref_label, char *** paths, char *** accts, unsigned int *list_l) {
	GList *items;
	GError *err = NULL;
	SecretService *service;
	SecretSearchFlags flags = SECRET_SEARCH_LOAD_SECRETS | SECRET_SEARCH_ALL | SECRET_SEARCH_UNLOCK;
	GHashTable *attributes = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);

	// List credentials with the right label only
	g_hash_table_insert(attributes, g_strdup("label"), g_strdup(ref_label));

	service = secret_service_get_sync(SECRET_SERVICE_NONE, NULL, &err);
	if (err != NULL) {
		return err;
	}

	items = secret_service_search_sync(service, NULL, attributes, flags, NULL, &err);
	int numKeys = g_list_length(items);
	if (err != NULL) {
		return err;
	}

	char **tmp_paths = (char **) calloc(1,(int)sizeof(char *)*numKeys);
	char **tmp_accts = (char **) calloc(1,(int)sizeof(char *)*numKeys);

	// items now contains our keys from the gnome keyring
	// we will now put it in our two lists to return it to go
	GList *current;
	int listNumber = 0;
	for(current = items; current!=NULL; current = current->next) {
		char *pathTmp = secret_item_get_label(current->data);
		// you cannot have a key without a label in the gnome keyring
		char *acctTmp = get_attribute("username",current->data);
		if (acctTmp==NULL) {
			acctTmp = "account not defined";
		}

		tmp_paths[listNumber] = (char *) calloc(1, sizeof(char)*(strlen(pathTmp)+1));
		tmp_accts[listNumber] = (char *) calloc(1, sizeof(char)*(strlen(acctTmp)+1));

		memcpy(tmp_paths[listNumber], pathTmp, sizeof(char)*(strlen(pathTmp)+1));
		memcpy(tmp_accts[listNumber], acctTmp, sizeof(char)*(strlen(acctTmp)+1));

		listNumber = listNumber + 1;
	}

	*paths = (char **) realloc(tmp_paths, (int)sizeof(char *)*listNumber);
	*accts = (char **) realloc(tmp_accts, (int)sizeof(char *)*listNumber);

	*list_l = listNumber;

	return NULL;
}
