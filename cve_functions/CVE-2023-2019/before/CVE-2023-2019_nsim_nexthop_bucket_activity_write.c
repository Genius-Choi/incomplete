static ssize_t nsim_nexthop_bucket_activity_write(struct file *file,
						  const char __user *user_buf,
						  size_t size, loff_t *ppos)
{
	struct nsim_fib_data *data = file->private_data;
	struct net *net = devlink_net(data->devlink);
	struct nsim_nexthop *nexthop;
	unsigned long *activity;
	loff_t pos = *ppos;
	u16 bucket_index;
	char buf[128];
	int err = 0;
	u32 nhid;

	if (pos != 0)
		return -EINVAL;
	if (size > sizeof(buf))
		return -EINVAL;
	if (copy_from_user(buf, user_buf, size))
		return -EFAULT;
	if (sscanf(buf, "%u %hu", &nhid, &bucket_index) != 2)
		return -EINVAL;

	rtnl_lock();

	nexthop = rhashtable_lookup_fast(&data->nexthop_ht, &nhid,
					 nsim_nexthop_ht_params);
	if (!nexthop || !nexthop->is_resilient ||
	    bucket_index >= nexthop->occ) {
		err = -EINVAL;
		goto out;
	}

	activity = bitmap_zalloc(nexthop->occ, GFP_KERNEL);
	if (!activity) {
		err = -ENOMEM;
		goto out;
	}

	bitmap_set(activity, bucket_index, 1);
	nexthop_res_grp_activity_update(net, nhid, nexthop->occ, activity);
	bitmap_free(activity);

out:
	rtnl_unlock();

	*ppos = size;
	return err ?: size;
}
