static const char* atos_parse(const char* p,
                              const char* start,
                              STRLEN* source_name_size,
                              STRLEN* source_line) {
    /* atos() output is something like:
     * perl_parse (in miniperl) (perl.c:2314)\n\n".
     * We cannot use Perl regular expressions, because we need to
     * stay low-level.  Therefore here we have a rolled-out version
     * of a state machine which matches _backwards_from_the_end_ and
     * if there's a success, returns the starts of the filename,
     * also setting the filename size and the source line number.
     * The matched regular expression is roughly "\(.*:\d+\)\s*$" */
    const char* source_number_start;
    const char* source_name_end;
    const char* source_line_end = start;
    const char* close_paren;
    UV uv;

    /* Skip trailing whitespace. */
    while (p > start && isSPACE(*p)) p--;
    /* Now we should be at the close paren. */
    if (p == start || *p != ')')
        return NULL;
    close_paren = p;
    p--;
    /* Now we should be in the line number. */
    if (p == start || !isDIGIT(*p))
        return NULL;
    /* Skip over the digits. */
    while (p > start && isDIGIT(*p))
        p--;
    /* Now we should be at the colon. */
    if (p == start || *p != ':')
        return NULL;
    source_number_start = p + 1;
    source_name_end = p; /* Just beyond the end. */
    p--;
    /* Look for the open paren. */
    while (p > start && *p != '(')
        p--;
    if (p == start)
        return NULL;
    p++;
    *source_name_size = source_name_end - p;
    if (grok_atoUV(source_number_start, &uv,  &source_line_end)
        && source_line_end == close_paren
        && uv <= PERL_INT_MAX
    ) {
        *source_line = (STRLEN)uv;
        return p;
    }
    return NULL;
}
