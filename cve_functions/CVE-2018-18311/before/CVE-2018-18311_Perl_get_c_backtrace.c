Perl_get_c_backtrace(pTHX_ int depth, int skip)
{
    /* Note that here we must stay as low-level as possible: Newx(),
     * Copy(), Safefree(); since we may be called from anywhere,
     * so we should avoid higher level constructs like SVs or AVs.
     *
     * Since we are using safesysmalloc() via Newx(), don't try
     * getting backtrace() there, unless you like deep recursion. */

    /* Currently only implemented with backtrace() and dladdr(),
     * for other platforms NULL is returned. */

#if defined(HAS_BACKTRACE) && defined(HAS_DLADDR)
    /* backtrace() is available via <execinfo.h> in glibc and in most
     * modern BSDs; dladdr() is available via <dlfcn.h>. */

    /* We try fetching this many frames total, but then discard
     * the |skip| first ones.  For the remaining ones we will try
     * retrieving more information with dladdr(). */
    int try_depth = skip +  depth;

    /* The addresses (program counters) returned by backtrace(). */
    void** raw_frames;

    /* Retrieved with dladdr() from the addresses returned by backtrace(). */
    Dl_info* dl_infos;

    /* Sizes _including_ the terminating \0 of the object name
     * and symbol name strings. */
    STRLEN* object_name_sizes;
    STRLEN* symbol_name_sizes;

#ifdef USE_BFD
    /* The symbol names comes either from dli_sname,
     * or if using BFD, they can come from BFD. */
    char** symbol_names;
#endif

    /* The source code location information.  Dug out with e.g. BFD. */
    char** source_names;
    STRLEN* source_name_sizes;
    STRLEN* source_lines;

    Perl_c_backtrace* bt = NULL;  /* This is what will be returned. */
    int got_depth; /* How many frames were returned from backtrace(). */
    UV frame_count = 0; /* How many frames we return. */
    UV total_bytes = 0; /* The size of the whole returned backtrace. */

#ifdef USE_BFD
    bfd_context bfd_ctx;
#endif
#ifdef PERL_DARWIN
    atos_context atos_ctx;
#endif

    /* Here are probably possibilities for optimizing.  We could for
     * example have a struct that contains most of these and then
     * allocate |try_depth| of them, saving a bunch of malloc calls.
     * Note, however, that |frames| could not be part of that struct
     * because backtrace() will want an array of just them.  Also be
     * careful about the name strings. */
    Newx(raw_frames, try_depth, void*);
    Newx(dl_infos, try_depth, Dl_info);
    Newx(object_name_sizes, try_depth, STRLEN);
    Newx(symbol_name_sizes, try_depth, STRLEN);
    Newx(source_names, try_depth, char*);
    Newx(source_name_sizes, try_depth, STRLEN);
    Newx(source_lines, try_depth, STRLEN);
#ifdef USE_BFD
    Newx(symbol_names, try_depth, char*);
#endif

    /* Get the raw frames. */
    got_depth = (int)backtrace(raw_frames, try_depth);

    /* We use dladdr() instead of backtrace_symbols() because we want
     * the full details instead of opaque strings.  This is useful for
     * two reasons: () the details are needed for further symbolic
     * digging, for example in OS X (2) by having the details we fully
     * control the output, which in turn is useful when more platforms
     * are added: we can keep out output "portable". */

    /* We want a single linear allocation, which can then be freed
     * with a single swoop.  We will do the usual trick of first
     * walking over the structure and seeing how much we need to
     * allocate, then allocating, and then walking over the structure
     * the second time and populating it. */

    /* First we must compute the total size of the buffer. */
    total_bytes = sizeof(Perl_c_backtrace_header);
    if (got_depth > skip) {
        int i;
#ifdef USE_BFD
        bfd_init(); /* Is this safe to call multiple times? */
        Zero(&bfd_ctx, 1, bfd_context);
#endif
#ifdef PERL_DARWIN
        Zero(&atos_ctx, 1, atos_context);
#endif
        for (i = skip; i < try_depth; i++) {
            Dl_info* dl_info = &dl_infos[i];

            object_name_sizes[i] = 0;
            source_names[i] = NULL;
            source_name_sizes[i] = 0;
            source_lines[i] = 0;

            /* Yes, zero from dladdr() is failure. */
            if (dladdr(raw_frames[i], dl_info)) {
                total_bytes += sizeof(Perl_c_backtrace_frame);

                object_name_sizes[i] =
                    dl_info->dli_fname ? strlen(dl_info->dli_fname) : 0;
                symbol_name_sizes[i] =
                    dl_info->dli_sname ? strlen(dl_info->dli_sname) : 0;
#ifdef USE_BFD
                bfd_update(&bfd_ctx, dl_info);
                bfd_symbolize(&bfd_ctx, raw_frames[i],
                              &symbol_names[i],
                              &symbol_name_sizes[i],
                              &source_names[i],
                              &source_name_sizes[i],
                              &source_lines[i]);
#endif
#if PERL_DARWIN
                atos_update(&atos_ctx, dl_info);
                atos_symbolize(&atos_ctx,
                               raw_frames[i],
                               &source_names[i],
                               &source_name_sizes[i],
                               &source_lines[i]);
#endif

                /* Plus ones for the terminating \0. */
                total_bytes += object_name_sizes[i] + 1;
                total_bytes += symbol_name_sizes[i] + 1;
                total_bytes += source_name_sizes[i] + 1;

                frame_count++;
            } else {
                break;
            }
        }
#ifdef USE_BFD
        Safefree(bfd_ctx.bfd_syms);
#endif
    }

    /* Now we can allocate and populate the result buffer. */
    Newxc(bt, total_bytes, char, Perl_c_backtrace);
    Zero(bt, total_bytes, char);
    bt->header.frame_count = frame_count;
    bt->header.total_bytes = total_bytes;
    if (frame_count > 0) {
        Perl_c_backtrace_frame* frame = bt->frame_info;
        char* name_base = (char *)(frame + frame_count);
        char* name_curr = name_base; /* Outputting the name strings here. */
        UV i;
        for (i = skip; i < skip + frame_count; i++) {
            Dl_info* dl_info = &dl_infos[i];

            frame->addr = raw_frames[i];
            frame->object_base_addr = dl_info->dli_fbase;
            frame->symbol_addr = dl_info->dli_saddr;

            /* Copies a string, including the \0, and advances the name_curr.
             * Also copies the start and the size to the frame. */
#define PERL_C_BACKTRACE_STRCPY(frame, doffset, src, dsize, size) \
            if (size && src) \
                Copy(src, name_curr, size, char); \
            frame->doffset = name_curr - (char*)bt; \
            frame->dsize = size; \
            name_curr += size; \
            *name_curr++ = 0;

            PERL_C_BACKTRACE_STRCPY(frame, object_name_offset,
                                    dl_info->dli_fname,
                                    object_name_size, object_name_sizes[i]);

#ifdef USE_BFD
            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,
                                    symbol_names[i],
                                    symbol_name_size, symbol_name_sizes[i]);
            Safefree(symbol_names[i]);
#else
            PERL_C_BACKTRACE_STRCPY(frame, symbol_name_offset,
                                    dl_info->dli_sname,
                                    symbol_name_size, symbol_name_sizes[i]);
#endif

            PERL_C_BACKTRACE_STRCPY(frame, source_name_offset,
                                    source_names[i],
                                    source_name_size, source_name_sizes[i]);
            Safefree(source_names[i]);

#undef PERL_C_BACKTRACE_STRCPY

            frame->source_line_number = source_lines[i];

            frame++;
        }
        assert(total_bytes ==
               (UV)(sizeof(Perl_c_backtrace_header) +
                    frame_count * sizeof(Perl_c_backtrace_frame) +
                    name_curr - name_base));
    }
#ifdef USE_BFD
    Safefree(symbol_names);
    if (bfd_ctx.abfd) {
        bfd_close(bfd_ctx.abfd);
    }
#endif
    Safefree(source_lines);
    Safefree(source_name_sizes);
    Safefree(source_names);
    Safefree(symbol_name_sizes);
    Safefree(object_name_sizes);
    /* Assuming the strings returned by dladdr() are pointers
     * to read-only static memory (the object file), so that
     * they do not need freeing (and cannot be). */
    Safefree(dl_infos);
    Safefree(raw_frames);
    return bt;
#else
    PERL_UNUSED_ARGV(depth);
    PERL_UNUSED_ARGV(skip);
    return NULL;
#endif
}
