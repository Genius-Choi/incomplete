static void atos_symbolize(atos_context* ctx,
                           void* raw_frame,
                           char** source_name,
                           STRLEN* source_name_size,
                           STRLEN* source_line)
{
    char cmd[1024];
    const char* p;
    Size_t cnt;

    if (ctx->unavail)
        return;
    /* Simple security measure: if there's any funny business with
     * the object name (used as "-o '%s'" ), leave since at least
     * partially the user controls it. */
    for (p = ctx->fname; *p; p++) {
        if (*p == '\'' || isCNTRL(*p)) {
            ctx->unavail = TRUE;
            return;
        }
    }
    cnt = snprintf(cmd, sizeof(cmd), ctx->format,
                   ctx->fname, ctx->object_base_addr, raw_frame);
    if (cnt < sizeof(cmd)) {
        /* Undo nostdio.h #defines that disable stdio.
         * This is somewhat naughty, but is used elsewhere
         * in the core, and affects only OS X. */
#undef FILE
#undef popen
#undef fread
#undef pclose
        FILE* fp = popen(cmd, "r");
        /* At the moment we open a new pipe for each stack frame.
         * This is naturally somewhat slow, but hopefully generating
         * stack traces is never going to in a performance critical path.
         *
         * We could play tricks with atos by batching the stack
         * addresses to be resolved: atos can either take multiple
         * addresses from the command line, or read addresses from
         * a file (though the mess of creating temporary files would
         * probably negate much of any possible speedup).
         *
         * Normally there are only two objects present in the backtrace:
         * perl itself, and the libdyld.dylib.  (Note that the object
         * filenames contain the full pathname, so perl may not always
         * be in the same place.)  Whenever the object in the
         * backtrace changes, the base address also changes.
         *
         * The problem with batching the addresses, though, would be
         * matching the results with the addresses: the parsing of
         * the results is already painful enough with a single address. */
        if (fp) {
            char out[1024];
            UV cnt = fread(out, 1, sizeof(out), fp);
            if (cnt < sizeof(out)) {
                const char* p = atos_parse(out + cnt - 1, out,
                                           source_name_size,
                                           source_line);
                if (p) {
                    Newx(*source_name,
                         *source_name_size, char);
                    Copy(p, *source_name,
                         *source_name_size,  char);
                }
            }
            pclose(fp);
        }
    }
}
