int ds_push_script_attrs(struct sip_msg *_m, str *script_attrs, 
		str *_ip, int port, int set, ds_partition_t *partition)
{
	ds_set_p list;
	struct ip_addr *ip;
	int j,k;

	if (!(ip = str2ip(_ip)) && !(ip = str2ip6(_ip))) {
		LM_ERR("IP val is not IP <%.*s>\n",_ip->len,_ip->s);
		return -1;
	}

	/* access ds data under reader's lock */
	lock_start_write( partition->lock );

	for(list = (*partition->data)->sets ; list!= NULL; list= list->next) {
		if ((set == -1) || (set == list->id)) {
			/* interate through all elements/destinations in the list */
			for(j=0; j<list->nr; j++) {
				/* interate through all IPs of each destination */
				for(k=0 ; k<list->dlist[j].ips_cnt ; k++ ) {
					if ( (list->dlist[j].ports[k]==0 || port==0
					|| port==list->dlist[j].ports[k]) &&
					ip_addr_cmp( ip, &list->dlist[j].ips[k]) ) {
						/* matching destination */
						
						list->dlist[j].script_attrs.s = shm_realloc(list->dlist[j].script_attrs.s,script_attrs->len);
						if (list->dlist[j].script_attrs.s == NULL) {
							LM_ERR("No more shm :( \n");
							goto error;
						}

						list->dlist[j].script_attrs.len = script_attrs->len;
						memcpy(list->dlist[j].script_attrs.s,script_attrs->s,script_attrs->len);
						
					}
				}
			}
		}
	}

	lock_stop_write( partition->lock );
	return 1;

error:
	lock_stop_write( partition->lock );
	return -1;

}
