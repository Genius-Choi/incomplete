int ds_set_state_repl(int group, str *address, int state, int type,
		ds_partition_t *partition, int do_repl, int is_sync)
{
	int i=0;
	ds_set_p idx = NULL;

	if ( (*partition->data)->sets==NULL ){
		LM_DBG("empty destination set\n");
		return -1;
	}

	/* access ds data under reader's lock */
	lock_start_read( partition->lock );

	/* get the index of the set */
	if(ds_get_index(group, &idx, partition)!=0) {
		LM_ERR("destination set [%d] not found\n", group);
		lock_stop_read( partition->lock );
		return -1;
	}

	while(i<idx->nr)
	{
		if(idx->dlist[i].uri.len==address->len
				&& strncasecmp(idx->dlist[i].uri.s, address->s,
					address->len)==0)
		{
			if (is_sync) {
				if ((idx->dlist[i].flags & (DS_INACTIVE_DST|DS_PROBING_DST)) !=
					(state & (DS_INACTIVE_DST|DS_PROBING_DST))) {
					/* status has changed */
					if (state & DS_INACTIVE_DST) {
						_ds_set_state(idx, i, address, DS_INACTIVE_DST, 1,
							partition, 0, 0);
						_ds_set_state(idx, i, address, DS_PROBING_DST, 0,
							partition, 0, 0);
					} else if (state & DS_PROBING_DST) {
						_ds_set_state(idx, i, address, DS_PROBING_DST, 1,
							partition, 0, 0);
						_ds_set_state(idx, i, address, DS_INACTIVE_DST, 0,
							partition, 0, 0);
					} else {  /* set active */
						_ds_set_state(idx, i, address,
							DS_INACTIVE_DST|DS_PROBING_DST, 0, partition, 0, 0);
					}
				}
			} else
				_ds_set_state(idx, i, address, state, type, partition,
					do_repl, 1);

			lock_stop_read( partition->lock );
			return 0;
		}
		i++;
	}

	lock_stop_read( partition->lock );
	return -1;
}
