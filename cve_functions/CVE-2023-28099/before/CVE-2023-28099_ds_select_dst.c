int ds_select_dst(struct sip_msg *msg, ds_select_ctl_p ds_select_ctl,
								ds_selected_dst_p selected_dst, int ds_flags)
{
	int i, j, cnt, i_unwrapped, set_size;
	unsigned int ds_hash, ds_rand;
	int_str avp_val;
	int ds_id;
	ds_set_p idx = NULL;
	int inactive_dst_count = 0;
	int destination_entries_to_skip = 0;
	/* used to sort the destinations for LB algo */
	ds_dest_p dest = NULL;
	ds_dest_p selected = NULL;
	static ds_dest_p *sorted_set = NULL;
	int rc;

	if(msg==NULL) {
		LM_ERR("bad parameters\n");
		return -1;
	}

	if ( (*ds_select_ctl->partition->data)->sets==NULL) {
		LM_DBG("empty destination set\n");
		return -1;
	}

	/* access ds data under reader's lock */
	lock_start_read( ds_select_ctl->partition->lock );

	/* get the index of the set */
	if(ds_get_index(ds_select_ctl->set, &idx, ds_select_ctl->partition)!=0)
	{
		LM_ERR("destination set [%d] not found\n", ds_select_ctl->set);
		goto error;
	}

	if (idx->nr == 0) {
		LM_DBG("destination set [%d] is empty!\n", idx->id);
		goto error;
	}

	if (idx->active_nr == 0) {
		LM_DBG("no active destinations in set [%d] !\n", idx->id);
		goto error;
	}

	/* calculate the real size of the set, depending on the USE_DEFAULT value
	 * This size will be all the time higher than 0 (>=1) */
	set_size =  (ds_flags&DS_USE_DEFAULT && idx->nr>1) ? idx->nr-1 : idx->nr ;

	/* at this point we know for sure that we have
	 * at least one  active destination */

	LM_DBG("set [%d], using alg [%d], size [%d], used size [%d], "
		"active size [%d]\n", ds_select_ctl->set, ds_select_ctl->alg, idx->nr,
		set_size, idx->active_nr);

	/* hash value used for picking the destination */
	ds_hash = 0;
	/* id of the destination candidate (still to check if active) */
	ds_id = -1;
	/* final selected destination */
	selected = NULL;

	switch(ds_select_ctl->alg)
	{
		case 0:
			if(ds_hash_callid(msg, &ds_hash)!=0)
			{
				LM_ERR("can't get callid hash\n");
				goto error;
			}
		break;
		case 1:
			if(ds_hash_fromuri(msg, &ds_hash, ds_flags)!=0)
			{
				LM_ERR("can't get From uri hash\n");
				goto error;
			}
		break;
		case 2:
			if(ds_hash_touri(msg, &ds_hash, ds_flags)!=0)
			{
				LM_ERR("can't get To uri hash\n");
				goto error;
			}
		break;
		case 3:
			if (ds_hash_ruri(msg, &ds_hash, ds_flags)!=0)
			{
				LM_ERR("can't get ruri hash\n");
				goto error;
			}
		break;
		case 4:
			/* round robin
			   Each destination is selected a number of times equal to its weight before moving
			   to the next destination
			   the count is incremented after we verify that the destination is active
			*/
			if( idx->dlist[idx->last].rr_count < idx->dlist[idx->last].weight)
				ds_id = idx->last;
			else {
				idx->dlist[idx->last].rr_count = 0;
				ds_id = (idx->last+1) % set_size;
			}
		break;
		case 5:
			i = ds_hash_authusername(msg, &ds_hash);
			switch (i)
			{
				case 0:
					/* Authorization-Header found: Nothing to be done here */
				break;
				case 1:
					/* No Authorization found: Use round robin */
					ds_id = idx->last;
					idx->last = (idx->last+1) % set_size;
				break;
				default:
					LM_ERR("can't get authorization hash\n");
					goto error;
				break;
			}
		break;
		case 6:
			ds_hash = rand();
		break;
		case 7:
			if (ds_hash_pvar(msg, &ds_hash)!=0)
			{
				LM_ERR("can't get PV hash\n");
				goto error;
			}
		break;
		case 8:
			ds_id = 0;
		break;
		case 9:
			if (ds_pattern_one==DS_PATTERN_NONE && ds_pattern_prefix.len == 0 ) {
				LM_WARN("no pattern specified - using first entry...\n");
				ds_select_ctl->alg = 8;
				break;
			}
			if (ds_pvar_algo(msg, idx, &sorted_set, ds_flags&DS_USE_DEFAULT)
			<= 0)
			{
				LM_ERR("can't get destination index\n");
				goto error;
			}
			selected = sorted_set[0];
			ds_id = 0;
		break;
		case 10:
			if (algo_route_param.s == NULL || algo_route_param.len == 0) {
				LM_ERR("No hash_route param provided \n");
				goto error;
			}
			if (ds_route_algo(msg, idx, &sorted_set, ds_flags&DS_USE_DEFAULT)
			<= 0) {
				LM_ERR("can't route \n");
				goto error;
			}	
			selected = sorted_set[0];
			ds_id = 0;
		break;
		default:
			LM_WARN("dispatching via [%d] with unknown algo [%d]"
					": defaulting to 0 - first entry\n",
					ds_select_ctl->set, ds_select_ctl->alg);
			ds_id = 0;
	}

	/* any destination selected yet? */
	if (selected==NULL) {

		LM_DBG("hash [%u], candidate [%d], weight sum [%u]\n",
			ds_hash, ds_id, idx->dlist[set_size-1].running_weight);

		/* any candidate selected yet */
		if (ds_id==-1) {
			/* no candidate yet -> do it based on hash and weights */
			if (idx->dlist[set_size-1].running_weight) {
				ds_rand = ds_hash % idx->dlist[set_size-1].running_weight;
				/* get the ds id based on weights */
				for( ds_id=0 ; ds_id<set_size ; ds_id++ )
					if (ds_rand<idx->dlist[ds_id].running_weight)
						break;
				if (ds_id==set_size) {
					LM_CRIT("BUG - no node found with weight %d in set %d\n",
						ds_rand,idx->id);
					goto error;
				}
			} else {
				/* get a candidate simply based on hash */
				ds_id = ds_hash % set_size;
			}
		}

		LM_DBG("candidate is [%u]\n",ds_id);

		/* now we have a candidate, so we need to check if active or not */
		i=ds_id;
		while ( !dst_is_active(idx->dlist[i]) ) {
			/* get a next candidate */
			if (ds_hash==0) {
				/* for algs with no hash, simple get the next in the list */
				i = (i+1) % set_size;
			} else {
				/* use the hash and weights over active destinations only ;
				 * if USE_DEFAULT is set, do a -1 if the default (last)
				 * destination is active (we want to skip it) */
				cnt = idx->active_nr - ((ds_flags&DS_USE_DEFAULT &&
					dst_is_active(idx->dlist[idx->nr-1]))?1:0);
				if (cnt) {
					/* weights or not ? */
					if (idx->dlist[set_size-1].active_running_weight) {
						ds_rand = ds_hash %
							idx->dlist[set_size-1].active_running_weight;
						/* get the ds id based on active weights */
						for( i=0 ; i<set_size ; i++ )
							if ( dst_is_active(idx->dlist[i]) &&
							(ds_rand<idx->dlist[i].active_running_weight) )
								break;
						if (i==set_size) {
							LM_CRIT("BUG - no active node found with "
								"weight %d in set %d\n",ds_rand,idx->id);
							goto error;
						}
					} else {
						j = ds_hash % cnt;
						/* translate this index to the full set of dsts */
						for ( i=0 ; i<set_size ; i++ ) {
							if ( dst_is_active(idx->dlist[i]) ) j--;
							if (j<0) break;
						}
						if (i==set_size) {
							LM_CRIT("BUG - no active node found with "
								"in set %d\n",idx->id);
							goto error;
						}
					}
				}
				/* i reflects the new candidate */
			}
			LM_DBG("new candidate is [%u]\n",i);
			if(i==ds_id) {
				if (ds_flags&DS_USE_DEFAULT) {
					i = idx->nr-1;
					if (!dst_is_active(idx->dlist[i]))
						goto error;
					break;
				} else {
					goto error;
				}
			}
		}
		LM_DBG("using destination [%u]\n",i);
		ds_id = i;
		selected = &idx->dlist[ds_id];
	}

	/* remember the last used destination */
	idx->last = ds_id;

	/* increase  chosen count in round-robin algritm, now that we know the candidate is active*/
	if(ds_select_ctl->alg == 4)
		idx->dlist[ds_id].rr_count++;

	/* start pushing the destinations to SIP level */
	cnt = 0;
	rc = 1;
	if(ds_select_ctl->set_destination
		&& ((rc = ds_update_dst(msg, &selected->dst_uri, selected->sock, ds_select_ctl->mode)) != 0) )
	{
		LM_ERR("cannot set dst addr\n");
		goto error;
	}

	if(rc == 0){
		selected->chosen_count++;
	}


	/* Save the selected destination for multilist failover */
	if (selected_dst->uri.s != NULL) {
		pkg_free(selected_dst->uri.s);
		memset(&selected_dst->uri, 0, sizeof(str));
	}
	if (pkg_str_dup(&selected_dst->uri, &selected->dst_uri) != 0) {
		LM_ERR("cannot set selected_dst uri\n");
		goto error;
	}
	selected_dst->socket = selected->sock;

	LM_DBG("selected [%d-%d/%d] <%.*s>\n",
		ds_select_ctl->alg, ds_select_ctl->set, ds_id,
		selected->dst_uri.len, selected->dst_uri.s);

	if(!(ds_flags&DS_FAILOVER_ON))
		goto done;

	if (!(ds_select_ctl->ds_flags & DS_APPEND_MODE))
	{
		/* do some AVP cleanup before start populating new ones */
		destroy_avps(0/*all types*/, ds_select_ctl->partition->dst_avp_name,1);
		destroy_avps(0/*all types*/, ds_select_ctl->partition->grp_avp_name,1);
		destroy_avps(0/*all types*/, ds_select_ctl->partition->cnt_avp_name,1);
		destroy_avps(0/*all types*/,ds_select_ctl->partition->sock_avp_name,1);
		if (ds_select_ctl->partition->attrs_avp_name>0)
			destroy_avps( 0 /*all types*/,
			ds_select_ctl->partition->attrs_avp_name, 1 /*all*/);
		if (ds_select_ctl->partition->script_attrs_avp_name>0)
			destroy_avps( 0 /*all types*/,
			ds_select_ctl->partition->script_attrs_avp_name, 1 /*all*/);
	}

	if((ds_flags&DS_USE_DEFAULT) && ds_id!=idx->nr-1)
	{
		if (push_ds_2_avps( &idx->dlist[idx->nr-1], ds_select_ctl->partition )
		!= 0 )
			goto error;
		cnt++;
	}

	inactive_dst_count =
		count_inactive_destinations(idx, ds_flags&DS_USE_DEFAULT);
	/* don't count inactive and default entries into total */
	destination_entries_to_skip = idx->nr - inactive_dst_count
		- (ds_flags&DS_USE_DEFAULT?1:0);
	destination_entries_to_skip -= ds_select_ctl->max_results;

	/* add to avp */

	for(i_unwrapped = ds_id-1+idx->nr; i_unwrapped>ds_id; i_unwrapped--) {
		i = i_unwrapped % idx->nr;
		dest = ((ds_select_ctl->alg == 9 || ds_select_ctl->alg == 10) ? 
			sorted_set[i] : 
			&idx->dlist[i]);

		if ( !dst_is_active(*dest) ||
		((ds_flags&DS_USE_DEFAULT) && i==(idx->nr-1)) )
			continue;
		if(destination_entries_to_skip > 0) {
			LM_DBG("skipped entry [%d/%d] (would create more than %i "
				"results)\n",
				ds_select_ctl->set, i, ds_select_ctl->max_results);
			destination_entries_to_skip--;
			continue;
		}

		LM_DBG("using entry [%d/%d]\n", ds_select_ctl->set, i);
		if (push_ds_2_avps( dest, ds_select_ctl->partition ) != 0 )
			goto error;
		cnt++;
	}

	/* add to avp the first used dst */
	avp_val.s = selected->uri;
	if(add_avp(AVP_VAL_STR|ds_select_ctl->partition->dst_avp_type,
				ds_select_ctl->partition->dst_avp_name,
				avp_val)!=0)
		goto error;
	cnt++;

done:
	if (ds_select_ctl->partition->attrs_avp_name>0) {
		avp_val.s = selected->attrs;
		if(add_avp(AVP_VAL_STR | ds_select_ctl->partition->attrs_avp_type,
		ds_select_ctl->partition->attrs_avp_name,avp_val)!=0)
			goto error;
	}

	if (ds_select_ctl->partition->script_attrs_avp_name>0) {
		avp_val.s = selected->script_attrs;
		if(add_avp(AVP_VAL_STR | ds_select_ctl->partition->script_attrs_avp_type,
		ds_select_ctl->partition->script_attrs_avp_name,avp_val)!=0)
			goto error;
	}

	/* add to avp the group id */
	avp_val.n = ds_select_ctl->set;
	if(add_avp(ds_select_ctl->partition->grp_avp_type,
				ds_select_ctl->partition->grp_avp_name, avp_val)!=0)
		goto error;

	/* add to avp the number of dst */
	avp_val.n = cnt;
	if(add_avp(ds_select_ctl->partition->cnt_avp_type,
				ds_select_ctl->partition->cnt_avp_name, avp_val)!=0)
		goto error;

	lock_stop_read( ds_select_ctl->partition->lock );
	return 1;

error:
	lock_stop_read( ds_select_ctl->partition->lock );
	return -1;
}
