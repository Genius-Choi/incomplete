static void mp4_mux_config_timing(GF_MP4MuxCtx *ctx)
{
	if ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign) {
		ctx->config_timing = GF_FALSE;
		return;
	}
	GF_List *services = gf_list_new();
	u32 i, count;
	Bool not_ready, blocking_refs, has_ready;

retry_all:
	count = gf_list_count(ctx->tracks);
	not_ready = GF_FALSE;
	blocking_refs = GF_FALSE;
	has_ready = GF_FALSE;

	for (i=0; i<gf_list_count(services);i++) {
		struct _service_info *si = gf_list_get(services, i);
		si->nb_non_sparse = si->nb_non_sparse_ready = 0;
		si->nb_sparse = si->nb_sparse_ready = 0;
	}

	//compute min dts of first packet on each track - this assume all tracks are synchronized, might need adjustment for MPEG4 Systems
	for (i=0; i<count; i++) {
		u64 ts, dts_min;
		GF_FilterPacket *pck;
		TrackWriter *tkw = gf_list_get(ctx->tracks, i);
		if (tkw->fake_track) continue;
		//get associated service
		struct _service_info *si = get_service_info(services, tkw);

		//already setup (happens when new PIDs are declared after a packet has already been written on other PIDs)
		if (tkw->nb_samples) {
			dts_min = gf_timestamp_rescale(tkw->ts_shift, tkw->src_timescale, 1000000);

			if (si->first_ts_min > dts_min) {
				si->first_ts_min = (u64) dts_min;
			}
			continue;
		}
retry_pck:
		pck = gf_filter_pid_get_packet(tkw->ipid);
		//check this after fetching a packet since it may reconfigure the track
		if (!tkw->track_num) {
			if (gf_filter_pid_is_eos(tkw->ipid)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] PID has no input packet and configuration not known after 10 retries, aborting initial timing sync\n"));
				continue;
			}
			not_ready = GF_TRUE;
			tkw->ts_shift = 0;
			continue;
		}

		if (pck) {
			if (gf_filter_pck_is_blocking_ref(pck))
				blocking_refs = GF_TRUE;
			if (tkw->wait_sap) {
				GF_FilterSAPType sap = gf_filter_pck_get_sap(pck);
				Bool seek = gf_filter_pck_get_seek_flag(pck);
				if (seek || !sap) {
					gf_filter_pid_drop_packet(tkw->ipid);
					goto retry_pck;
				} else {
					tkw->wait_sap = GF_FALSE;

					if (!ctx->wait_dts_plus_one) {
						ctx->wait_dts_plus_one = 1 + gf_filter_pck_get_dts(pck);
						ctx->wait_dts_timescale = tkw->src_timescale;
					}
				}
			}

			if (ctx->wait_dts_plus_one) {
				ts = gf_filter_pck_get_dts(pck);
				if (ts==GF_FILTER_NO_TS)
					ts = gf_filter_pck_get_cts(pck);
				if (ts==GF_FILTER_NO_TS)
					ts=0;

				if (gf_timestamp_less(ts, tkw->src_timescale, (ctx->wait_dts_plus_one-1), ctx->wait_dts_timescale)) {
					gf_filter_pid_drop_packet(tkw->ipid);
					goto retry_pck;
				}
			}
		}
		switch (tkw->stream_type) {
		case GF_STREAM_VISUAL:
		case GF_STREAM_AUDIO:
			si->nb_non_sparse++;
			break;
		default:
			si->nb_sparse++;
			break;
		}

		if (!pck) {
			//eos (wether real or flush event), setup cenc
			if (gf_filter_pid_is_eos(tkw->ipid)) {
				if (tkw->cenc_state==CENC_NEED_SETUP)
					mp4_mux_cenc_update(ctx, tkw, NULL, CENC_CONFIG, 0, 0);

				if (!tkw->nb_samples) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
					const GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);
					if (p) {
						gf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);
					}
#endif
				}
				if (tkw->dgl_copy) {
					gf_filter_pck_discard(tkw->dgl_copy);
					tkw->dgl_copy = NULL;
				}
				switch (tkw->stream_type) {
				case GF_STREAM_VISUAL:
				case GF_STREAM_AUDIO:
					si->nb_non_sparse_ready++;
					break;
				default:
					si->nb_sparse_ready++;
					break;
				}
				continue;
			}
			tkw->ts_shift = 0;
			tkw->si_min_ts_plus_one = 1;
			continue;
		}
		//we may have reorder tracks after the get_packet, redo
		if (gf_list_find(ctx->tracks, tkw) != i) {
			goto retry_all;
		}
		ts = gf_filter_pck_get_dts(pck);
		if (ts==GF_FILTER_NO_TS)
			ts = gf_filter_pck_get_cts(pck);
		if (ts==GF_FILTER_NO_TS)
			ts=0;

		dts_min = gf_timestamp_rescale(ts, tkw->src_timescale, 1000000);

		if (si->first_ts_min > dts_min) {
			si->first_ts_min = (u64) dts_min;
			has_ready = GF_TRUE;
		}

		switch (tkw->stream_type) {
		case GF_STREAM_VISUAL:
		case GF_STREAM_AUDIO:
			si->nb_non_sparse_ready++;
			break;
		default:
			si->nb_sparse_ready++;
			break;
		}

		tkw->ts_shift = ts;
		tkw->si_min_ts_plus_one = 0;
	}

	for (i=0; i<gf_list_count(services); i++) {
		struct _service_info *si = gf_list_get(services, i);
		//if some non-sparse streams are not ready, try to wait
		if (si->nb_non_sparse) {
			if (si->nb_non_sparse > si->nb_non_sparse_ready) not_ready = GF_TRUE;
		}
		//otherwise (only sparse stream), wait until first
		else if (si->nb_sparse) {
			if (!si->nb_sparse_ready) not_ready = GF_TRUE;
		}
	}

	if (not_ready) {
		if (blocking_refs && has_ready) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] Blocking input packets present, aborting initial timing sync\n"));
		}
		//this may be quite long until we have a packet in case input pid is video encoding
		else if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] No input packets present on one or more inputs for more than 10s, aborting initial timing sync\n"));
		} else {
			ctx->config_retry_start = gf_sys_clock();
			del_service_info(services);
			return;
		}
	}
	ctx->config_retry_start = 0;
	for (i=0; i<gf_list_count(services); i++) {
		struct _service_info *si = gf_list_get(services, i);
		if (si->first_ts_min==(u64)-1)
			si->first_ts_min = 0;
	}

	//for all packets with dts greater than min dts, we need to add a pause
	for (i=0; i<count; i++) {
		TrackWriter *tkw = gf_list_get(ctx->tracks, i);
		struct _service_info *si = get_service_info(services, tkw);
		if (tkw->si_min_ts_plus_one) {
			tkw->si_min_ts_plus_one = si->first_ts_min + 1;
			continue;
		}

		//if single text track don't reset back to 0
		mp4_mux_update_init_edit(ctx, tkw, si->first_ts_min, ((count==1) && (tkw->stream_type == GF_STREAM_TEXT)) ? GF_TRUE : GF_FALSE);
	}

	ctx->config_timing = GF_FALSE;
	del_service_info(services);
}
