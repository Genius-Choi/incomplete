static struct dlg_set *find_dlg_set_for_msg( pjsip_rx_data *rdata )
{
    /* CANCEL message doesn't have To tag, so we must lookup the dialog
     * by finding the INVITE UAS transaction being cancelled.
     */
    if (rdata->msg_info.cseq->method.id == PJSIP_CANCEL_METHOD) {

	pjsip_dialog *dlg;

	/* Create key for the rdata, but this time, use INVITE as the
	 * method.
	 */
	pj_str_t key;
	pjsip_role_e role;
	pjsip_transaction *tsx;

	if (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)
	    role = PJSIP_ROLE_UAS;
	else
	    role = PJSIP_ROLE_UAC;

	pjsip_tsx_create_key(rdata->tp_info.pool, &key, role, 
			     pjsip_get_invite_method(), rdata);

	/* Lookup the INVITE transaction */
	tsx = pjsip_tsx_layer_find_tsx2(&key, PJ_TRUE);

	/* We should find the dialog attached to the INVITE transaction */
	if (tsx) {
	    dlg = (pjsip_dialog*) tsx->mod_data[mod_ua.mod.id];
	    pj_grp_lock_dec_ref(tsx->grp_lock);

	    /* Dlg may be NULL on some extreme condition
	     * (e.g. during debugging where initially there is a dialog)
	     */
	    return dlg ? (struct dlg_set*) dlg->dlg_set : NULL;

	} else {
	    return NULL;
	}


    } else {
	pj_str_t *tag;
	struct dlg_set *dlg_set;

	if (rdata->msg_info.msg->type == PJSIP_REQUEST_MSG)
	    tag = &rdata->msg_info.to->tag;
	else
	    tag = &rdata->msg_info.from->tag;

	/* Lookup the dialog set. */
	dlg_set = (struct dlg_set*)
		  pj_hash_get_lower(mod_ua.dlg_table, tag->ptr, 
				    (unsigned)tag->slen, NULL);
	return dlg_set;
    }
}
