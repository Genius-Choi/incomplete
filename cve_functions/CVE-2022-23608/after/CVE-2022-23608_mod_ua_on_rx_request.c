static pj_bool_t mod_ua_on_rx_request(pjsip_rx_data *rdata)
{
    struct dlg_set *dlg_set;
    pj_str_t *from_tag;
    pjsip_dialog *dlg;
    pj_status_t status;

    /* Optimized path: bail out early if request is not CANCEL and it doesn't
     * have To tag 
     */
    if (rdata->msg_info.to->tag.slen == 0 && 
	rdata->msg_info.msg->line.req.method.id != PJSIP_CANCEL_METHOD)
    {
	return PJ_FALSE;
    }

    /* Incoming REGISTER may have tags in it */
    if (rdata->msg_info.msg->line.req.method.id == PJSIP_REGISTER_METHOD)
	return PJ_FALSE;

retry_on_deadlock:

    /* Lock user agent before looking up the dialog hash table. */
    pj_mutex_lock(mod_ua.mutex);

    /* Lookup the dialog set, based on the To tag header. */
    dlg_set = find_dlg_set_for_msg(rdata);

    /* If dialog is not found, respond with 481 (Call/Transaction
     * Does Not Exist).
     */
    if (dlg_set == NULL) {
	/* Unable to find dialog. */
	pj_mutex_unlock(mod_ua.mutex);

	if (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {
	    PJ_LOG(5,(THIS_FILE, 
		      "Unable to find dialogset for %s, answering with 481",
		      pjsip_rx_data_get_info(rdata)));

	    /* Respond with 481 . */
	    pjsip_endpt_respond_stateless( mod_ua.endpt, rdata, 481, NULL, 
					   NULL, NULL );
	}
	return PJ_TRUE;
    }

    /* Dialog set has been found.
     * Find the dialog in the dialog set based on the content of the remote 
     * tag.
     */
    from_tag = &rdata->msg_info.from->tag;
    dlg = dlg_set->dlg_list.next;
    while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {
	
	if (pj_stricmp(&dlg->remote.info->tag, from_tag) == 0)
	    break;

	dlg = dlg->next;
    }

    /* Dialog may not be found, e.g. in this case:
     *	- UAC sends SUBSCRIBE, then UAS sends NOTIFY before answering
     *    SUBSCRIBE request with 2xx.
     *
     * In this case, we can accept the request ONLY when the original 
     * dialog still has empty To tag.
     */
    if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {

	pjsip_dialog *first_dlg = dlg_set->dlg_list.next;

	if (first_dlg->remote.info->tag.slen != 0) {
	    /* Not found. Mulfunction UAC? */
	    pj_mutex_unlock(mod_ua.mutex);

	    if (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {
		PJ_LOG(5,(THIS_FILE, 
		          "Unable to find dialog for %s, answering with 481",
		          pjsip_rx_data_get_info(rdata)));

		pjsip_endpt_respond_stateless(mod_ua.endpt, rdata,
					      PJSIP_SC_CALL_TSX_DOES_NOT_EXIST, 
					      NULL, NULL, NULL);
	    } else {
		PJ_LOG(5,(THIS_FILE, 
		          "Unable to find dialog for %s",
		          pjsip_rx_data_get_info(rdata)));
	    }
	    return PJ_TRUE;
	}

	dlg = first_dlg;
    }

    /* Mark the dialog id of the request. */
    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;

    /* Try to lock the dialog */
    PJ_LOG(6,(dlg->obj_name, "UA layer acquiring dialog lock for request"));
    status = pjsip_dlg_try_inc_lock(dlg);
    if (status != PJ_SUCCESS) {
	/* Failed to acquire dialog mutex immediately, this could be 
	 * because of deadlock. Release UA mutex, yield, and retry 
	 * the whole thing once again.
	 */
	pj_mutex_unlock(mod_ua.mutex);
	pj_thread_sleep(0);
	goto retry_on_deadlock;
    }

    /* Done with processing in UA layer, release lock */
    pj_mutex_unlock(mod_ua.mutex);

    /* Pass to dialog. */
    pjsip_dlg_on_rx_request(dlg, rdata);

    /* Unlock the dialog. This may destroy the dialog */
    pjsip_dlg_dec_lock(dlg);

    /* Report as handled. */
    return PJ_TRUE;
}
