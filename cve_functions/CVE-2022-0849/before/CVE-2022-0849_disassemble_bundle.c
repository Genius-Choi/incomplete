static int disassemble_bundle(bundle_t *bundle, const ut32 *words, int count) {
	bool used[KVX_MAX_BUNDLE_ISSUE] = {0};
	insn_t *insn;
	ut32 word;
	int issue, immx, extension;
	int bcu = 0;
	int i;

	for (i = 0; i < count; i++) {
		extension = 0;
		word = words[i];
		switch (kvx_steering (word)) {
		case STEERING_BCU:
			if (i == 0 && !kvx_is_tca_opcode (word)) {
				bcu = 1;
				issue = BUNDLE_ISSUE_BCU;
			} else if ((i == 0 && kvx_is_tca_opcode (word))
				|| (i == 1 && bcu && kvx_is_tca_opcode (word))) {
				issue = BUNDLE_ISSUE_TCA;
			} else {
				immx = kvx_extension (word);
				issue = immx_to_bundle_issue[immx];
				extension = 1;
			}
			break;
		case STEERING_ALU:
			if (!used[BUNDLE_ISSUE_ALU0]) {
				issue = BUNDLE_ISSUE_ALU0;
			} else if (!used[BUNDLE_ISSUE_ALU1]) {
				issue = BUNDLE_ISSUE_ALU1;
			} else if (!used[BUNDLE_ISSUE_MAU]) {
				issue = BUNDLE_ISSUE_MAU;
			} else if (!used[BUNDLE_ISSUE_LSU]) {
				issue = BUNDLE_ISSUE_LSU;
			} else {
				/* too many ALUs */
				goto error;
			}
			break;
		case STEERING_MAU:
			issue = BUNDLE_ISSUE_MAU;
			break;
		case STEERING_LSU:
			issue = BUNDLE_ISSUE_LSU;
			break;
		}

		insn = &bundle->issue[issue];

		if (!used[issue]) {
			used[issue] = 1;
			insn->len = 0;
		} else if (!extension && used[issue]) {
			/* issue already used */
			goto error;
		} else if (extension && !used[issue]) {
			/* missing issue */
			goto error;
		}
		if (insn->len == KVX_MAX_SYLLABLES) {
			/* too many syllables */
			goto error;
		}
		insn->value[insn->len] = word;
		insn->len++;
	}

	for (issue = 0; issue < KVX_MAX_BUNDLE_ISSUE; issue++) {
		if (!used[issue])
			continue;
		insn = &bundle->issue[issue];

		insn->opc = NULL;
		for (i = 0; i < KV3_OPC_COUNT; i++) {
			if (kvx_opc_match (&kv3_opc[i], insn)) {
				insn->opc = &kv3_opc[i];
				break;
			}
		}
	}

	count = 0;
	for (issue = KVX_MAX_BUNDLE_ISSUE - 1; issue >= 0; issue--) {
		if (!used[issue])
			continue;
		insn = &bundle->issue[issue];
		insn->rem = count++;
	}

	return 0;
error:
	return -1;
}
