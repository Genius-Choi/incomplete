parse_publish(xmlTextReaderPtr reader, bool parse_hash, bool hash_required,
    struct publish **publish)
{
	struct publish *tmp;
	struct rpki_uri *uri;
	char *base64_str;
	int error;

	error = publish_create(&tmp);
	if (error)
		return error;

	error = parse_doc_data(reader, parse_hash, hash_required,
	    &tmp->doc_data);
	if (error)
		goto release_tmp;

	/* Read the text */
	if (xmlTextReaderRead(reader) != 1) {
		error = pr_val_err("Couldn't read publish content of element '%s'",
		    tmp->doc_data.uri);
		goto release_tmp;
	}

	error = parse_string(reader, NULL, &base64_str);
	if (error)
		goto release_tmp;

	error = base64_read(base64_str, &tmp->content, &tmp->content_len);
	if (error)
		goto release_base64;

	/* rfc8181#section-2.2 but considering optional hash */
	uri = NULL;
	if (tmp->doc_data.hash_len > 0) {
		/* Get the current file from the uri */
		error = uri_create_rsync_str_rrdp(&uri, tmp->doc_data.uri,
		    strlen(tmp->doc_data.uri));
		if (error)
			goto release_base64;

		error = hash_validate_file("sha256", uri, tmp->doc_data.hash,
		    tmp->doc_data.hash_len);
		uri_refput(uri);
		if (error != 0) {
			pr_val_info("Hash of base64 decoded element from URI '%s' doesn't match <publish> element hash",
			    tmp->doc_data.uri);
			error = EINVAL;
			goto release_base64;
		}
	}

	free(base64_str);
	*publish = tmp;
	return 0;
release_base64:
	free(base64_str);
release_tmp:
	publish_destroy(tmp);
	return error;
}
