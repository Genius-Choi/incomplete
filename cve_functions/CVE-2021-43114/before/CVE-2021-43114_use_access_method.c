use_access_method(struct sia_ca_uris *sia_uris,
    access_method_exec rsync_cb, access_method_exec rrdp_cb, bool new_level,
    bool *retry_repo_sync)
{
	access_method_exec *cb_primary;
	access_method_exec *cb_secondary;
	rrdp_req_status_t rrdp_req_status;
	bool primary_rrdp;
	int upd_error;
	int error;

	/*
	 * By default, RRDP has a greater priority than rsync.
	 * See "http.priority" default value.
	 */
	primary_rrdp = true;
	(*retry_repo_sync) = true;

	/*
	 * Very specific scenario, yet possible:
	 * - Still working at the same repository level
	 * - The previous object was working on an RRDP repository
	 * - This certificate doesn't have an update notification URI
	 *
	 * Probably the object does exist at the RRDP repository, so check if
	 * that's the case. Otherwise, just keep going.
	 *
	 * The main reason, is a (possible) hole at RFC 8182. Apparently, the
	 * CA childs aren't obligated to have the same RRDP accessMethod than
	 * their parent, so there's no problem if they don't use it at all; not
	 * even if such childs (and even the grandchilds or anyone below that
	 * level) "reside" at the RRDP repository.
	 */
	if (!new_level && db_rrdp_uris_workspace_get() != NULL &&
	    sia_uris->rpkiNotify.uri == NULL &&
	    verify_rrdp_mft_loc(sia_uris->mft.uri) == 0) {
		(*retry_repo_sync) = false;
		return replace_rrdp_mft_uri(&sia_uris->mft);
	}

	/*
	 * RSYNC will always be present (at least for now, see
	 * rfc6487#section-4.8.8.1). If rsync is disabled, the cb will take
	 * care of that.
	 */
	if (sia_uris->rpkiNotify.uri == NULL) {
		primary_rrdp = false;
		error = rsync_cb(sia_uris);
		if (!error)
			return 0;
		goto verify_mft;
	}

	/*
	 * There isn't any restriction about the preferred access method of
	 * children CAs being the same as the parent CA.
	 *
	 * Two possible scenarios arise:
	 * 1) CA Parent didn't utilized (or didn't had) an RRDP update
	 *    notification URI.
	 * 2) CA Parent successfully utilized an RRDP update notification URI.
	 *
	 * Step (1) is simple, do the check of the preferred access method.
	 * Step (2) must do something different.
	 * - If RRDP URI was already successfully visited, don't care
	 *   preference, don't execute access method.
	 */
	error = db_rrdp_uris_get_request_status(
	    uri_get_global(sia_uris->rpkiNotify.uri), &rrdp_req_status);
	if (error ==  0 && rrdp_req_status == RRDP_URI_REQ_VISITED) {
		error = db_rrdp_uris_workspace_enable();
		if (error) {
			db_rrdp_uris_workspace_disable();
			return error;
		}
		(*retry_repo_sync) = false;
		return replace_rrdp_mft_uri(&sia_uris->mft);
	}

	/* Use CA's or configured priority? */
	if (config_get_rsync_priority() == config_get_http_priority())
		primary_rrdp = sia_uris->caRepository.position
		    > sia_uris->rpkiNotify.position;
	else
		primary_rrdp = config_get_rsync_priority()
		    < config_get_http_priority();

	cb_primary = primary_rrdp ? rrdp_cb : rsync_cb;
	cb_secondary = primary_rrdp ? rsync_cb : rrdp_cb;

	/* Try with the preferred; in case of error, try with the next one */
	error = cb_primary(sia_uris);
	if (!error) {
		(*retry_repo_sync) = !primary_rrdp;
		return 0;
	}

	if (primary_rrdp) {
		working_repo_push(uri_get_global(sia_uris->rpkiNotify.uri));
		if (error != -EPERM)
			pr_val_info("Couldn't fetch data from RRDP repository '%s', trying to fetch data now from '%s'.",
			    uri_get_global(sia_uris->rpkiNotify.uri),
			    uri_get_global(sia_uris->caRepository.uri));
		else
			pr_val_info("RRDP repository '%s' download/processing returned error previously, now I will try to fetch data from '%s'.",
			    uri_get_global(sia_uris->rpkiNotify.uri),
			    uri_get_global(sia_uris->caRepository.uri));
	} else {
		working_repo_push(uri_get_global(sia_uris->caRepository.uri));
		pr_val_info("Couldn't fetch data from repository '%s', trying to fetch data now from RRDP '%s'.",
		    uri_get_global(sia_uris->caRepository.uri),
		    uri_get_global(sia_uris->rpkiNotify.uri));
	}

	/* Retry if rrdp was the first option but failed */
	(*retry_repo_sync) = primary_rrdp;
	error = cb_secondary(sia_uris);
	/* No need to remember the working repository anymore */
	working_repo_pop();

verify_mft:
	/* Reach here on error or when both access methods were utilized */
	switch (error) {
	case 0:
		/* Remove the error'd URI, since we got the repo files */
		if (working_repo_peek() != NULL)
			reqs_errors_rem_uri(working_repo_peek());
		break;
	case EREQFAILED:
		/* Log that we'll try to work with a local copy */
		pr_val_warn("Trying to work with the local cache files.");
		(*retry_repo_sync) = false;
		break;
	case -EPERM:
		/*
		 * Specific RRPD error: the URI error'd on the first try, so
		 * we'll keep trying with the local files
		 */
		(*retry_repo_sync) = false;
		break;
	default:
		return error;
	}

	/* Error and the primary access method was RRDP? Use its workspace */
	if (error && primary_rrdp) {
		db_rrdp_uris_workspace_enable();
		upd_error = replace_rrdp_mft_uri(&sia_uris->mft);
		if (upd_error)
			return upd_error;
	}

	/* Look for the manifest */
	return verify_mft_loc(sia_uris->mft.uri);
}
