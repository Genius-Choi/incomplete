check_dup_public_key(bool *duplicated, char const *file, void *arg)
{
	X509 *curr_cert = arg; /* Current cert */
	X509 *rcvd_cert;
	X509_PUBKEY *curr_pk, *rcvd_pk;
	struct rpki_uri *uri;
	uint8_t *tmp;
	int tmp_size;
	int error;

	uri = NULL;
	rcvd_cert = NULL;
	tmp_size = 0;

	error = uri_create_rsync_str(&uri, file, strlen(file));
	if (error)
		return error;

	/* Check if it's '.cer', otherwise treat as a signed object */
	if (uri_is_certificate(uri)) {
		error = certificate_load(uri, &rcvd_cert);
		if (error)
			goto free_uri;
	} else {
		error = cert_from_signed_object(uri, &tmp, &tmp_size);
		if (error)
			goto free_uri;

		rcvd_cert = d2i_X509(NULL, (const unsigned char **) &tmp,
		    tmp_size);
		free(tmp); /* Release at once */
		if (rcvd_cert == NULL) {
			error = val_crypto_err("Signed object's '%s' 'certificate' element does not decode into a Certificate",
			    uri_val_get_printable(uri));
			goto free_uri;
		}
	}

	curr_pk = X509_get_X509_PUBKEY(curr_cert);
	if (curr_pk == NULL) {
		error = val_crypto_err("X509_get_X509_PUBKEY() returned NULL");
		goto free_cert;
	}

	rcvd_pk = X509_get_X509_PUBKEY(rcvd_cert);
	if (rcvd_pk == NULL) {
		error = val_crypto_err("X509_get_X509_PUBKEY() returned NULL");
		goto free_cert;
	}

	/*
	 * The function response will be:
	 *   < 0 if there's an error
	 *   = 0 if the PKs are equal
	 *   > 0 if the PKs are different
	 */
	error = spki_cmp(curr_pk, rcvd_pk, cert_different_pk_err,
	    cert_different_pk_err);

	if (error < 0)
		goto free_cert;

	/* No error, a positive value means the name is duplicated */
	if (error)
		(*duplicated) = true;
	error = 0;

free_cert:
	X509_free(rcvd_cert);
free_uri:
	uri_refput(uri);
	return error;
}
