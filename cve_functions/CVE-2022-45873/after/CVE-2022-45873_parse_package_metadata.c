static int parse_package_metadata(const char *name, JsonVariant *id_json, Elf *elf, bool *ret_interpreter_found, StackContext *c) {
        bool interpreter_found = false;
        size_t n_program_headers;
        int r;

        assert(name);
        assert(elf);
        assert(c);

        /* When iterating over PT_LOAD we will visit modules more than once */
        if (set_contains(*c->modules, name))
                return 0;

        r = sym_elf_getphdrnum(elf, &n_program_headers);
        if (r < 0) /* Not the handle we are looking for - that's ok, skip it */
                return 0;

        /* Iterate over all program headers in that ELF object. These will have been copied by
         * the kernel verbatim when the core file is generated. */
        for (size_t i = 0; i < n_program_headers; ++i) {
                GElf_Phdr mem, *program_header;
                GElf_Nhdr note_header;
                Elf_Data *data;

                /* Package metadata is in PT_NOTE headers. */
                program_header = sym_gelf_getphdr(elf, i, &mem);
                if (!program_header || (program_header->p_type != PT_NOTE && program_header->p_type != PT_INTERP))
                        continue;

                if (program_header->p_type == PT_INTERP) {
                        interpreter_found = true;
                        continue;
                }

                /* Fortunately there is an iterator we can use to walk over the
                 * elements of a PT_NOTE program header. We are interested in the
                 * note with type. */
                data = sym_elf_getdata_rawchunk(elf,
                                                program_header->p_offset,
                                                program_header->p_filesz,
                                                ELF_T_NHDR);
                if (!data)
                        continue;

                for (size_t note_offset = 0, name_offset, desc_offset;
                     note_offset < data->d_size &&
                     (note_offset = sym_gelf_getnote(data, note_offset, &note_header, &name_offset, &desc_offset)) > 0;) {

                        _cleanup_(json_variant_unrefp) JsonVariant *v = NULL, *w = NULL;
                        const char *payload = (const char *)data->d_buf + desc_offset;

                        if (note_header.n_namesz == 0 || note_header.n_descsz == 0)
                                continue;

                        /* Package metadata might have different owners, but the
                         * magic ID is always the same. */
                        if (note_header.n_type != ELF_PACKAGE_METADATA_ID)
                                continue;

                        _cleanup_free_ char *payload_0suffixed = NULL;
                        assert(note_offset > desc_offset);
                        size_t payload_len = note_offset - desc_offset;

                        /* If we are lucky and the payload is NUL-padded, we don't need to copy the string.
                         * But if happens to go all the way until the end of the buffer, make a copy. */
                        if (payload[payload_len-1] != '\0') {
                                payload_0suffixed = memdup_suffix0(payload, payload_len);
                                if (!payload_0suffixed)
                                        return log_oom();
                                payload = payload_0suffixed;
                        }

                        r = json_parse(payload, 0, &v, NULL, NULL);
                        if (r < 0)
                                return log_error_errno(r, "json_parse on %s failed: %m", payload);

                        /* If we have a build-id, merge it in the same JSON object so that it appears all
                         * nicely together in the logs/metadata. */
                        if (id_json) {
                                r = json_variant_merge(&v, id_json);
                                if (r < 0)
                                        return log_error_errno(r, "json_variant_merge of package meta with buildId failed: %m");
                        }

                        /* Pretty-print to the buffer, so that the metadata goes as plaintext in the
                         * journal. */
                        report_module_metadata(c, name, v);

                        /* Then we build a new object using the module name as the key, and merge it
                         * with the previous parses, so that in the end it all fits together in a single
                         * JSON blob. */
                        r = json_build(&w, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(name, JSON_BUILD_VARIANT(v))));
                        if (r < 0)
                                return log_error_errno(r, "Failed to build JSON object: %m");

                        r = json_variant_merge(c->package_metadata, w);
                        if (r < 0)
                                return log_error_errno(r, "json_variant_merge of package meta with buildId failed: %m");

                        /* Finally stash the name, so we avoid double visits. */
                        r = set_put_strdup(c->modules, name);
                        if (r < 0)
                                return log_error_errno(r, "set_put_strdup failed: %m");

                        if (ret_interpreter_found)
                                *ret_interpreter_found = interpreter_found;

                        return 1;
                }
        }

        if (ret_interpreter_found)
                *ret_interpreter_found = interpreter_found;

        /* Didn't find package metadata for this module - that's ok, just go to the next. */
        return 0;
}
