static int mpls_dump_routes(struct sk_buff *skb, struct netlink_callback *cb)
{
	const struct nlmsghdr *nlh = cb->nlh;
	struct net *net = sock_net(skb->sk);
	struct mpls_route __rcu **platform_label;
	struct fib_dump_filter filter = {};
	unsigned int flags = NLM_F_MULTI;
	size_t platform_labels;
	unsigned int index;

	ASSERT_RTNL();

	if (cb->strict_check) {
		int err;

		err = mpls_valid_fib_dump_req(net, nlh, &filter, cb);
		if (err < 0)
			return err;

		/* for MPLS, there is only 1 table with fixed type and flags.
		 * If either are set in the filter then return nothing.
		 */
		if ((filter.table_id && filter.table_id != RT_TABLE_MAIN) ||
		    (filter.rt_type && filter.rt_type != RTN_UNICAST) ||
		     filter.flags)
			return skb->len;
	}

	index = cb->args[0];
	if (index < MPLS_LABEL_FIRST_UNRESERVED)
		index = MPLS_LABEL_FIRST_UNRESERVED;

	platform_label = rtnl_dereference(net->mpls.platform_label);
	platform_labels = net->mpls.platform_labels;

	if (filter.filter_set)
		flags |= NLM_F_DUMP_FILTERED;

	for (; index < platform_labels; index++) {
		struct mpls_route *rt;

		rt = rtnl_dereference(platform_label[index]);
		if (!rt)
			continue;

		if ((filter.dev && !mpls_rt_uses_dev(rt, filter.dev)) ||
		    (filter.protocol && rt->rt_protocol != filter.protocol))
			continue;

		if (mpls_dump_route(skb, NETLINK_CB(cb->skb).portid,
				    cb->nlh->nlmsg_seq, RTM_NEWROUTE,
				    index, rt, flags) < 0)
			break;
	}
	cb->args[0] = index;

	return skb->len;
}
