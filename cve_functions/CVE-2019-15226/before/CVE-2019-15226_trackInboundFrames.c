bool ServerConnectionImpl::trackInboundFrames(const nghttp2_frame_hd* hd, uint32_t padding_length) {
  ENVOY_CONN_LOG(trace, "track inbound frame type={} flags={} length={} padding_length={}",
                 connection_, static_cast<uint64_t>(hd->type), static_cast<uint64_t>(hd->flags),
                 static_cast<uint64_t>(hd->length), padding_length);
  switch (hd->type) {
  case NGHTTP2_HEADERS:
  case NGHTTP2_CONTINUATION:
    // Track new streams.
    if (hd->flags & NGHTTP2_FLAG_END_HEADERS) {
      inbound_streams_++;
    }
    FALLTHRU;
  case NGHTTP2_DATA:
    // Track frames with an empty payload and no end stream flag.
    if (hd->length - padding_length == 0 && !(hd->flags & NGHTTP2_FLAG_END_STREAM)) {
      ENVOY_CONN_LOG(trace, "frame with an empty payload and no end stream flag.", connection_);
      consecutive_inbound_frames_with_empty_payload_++;
    } else {
      consecutive_inbound_frames_with_empty_payload_ = 0;
    }
    break;
  case NGHTTP2_PRIORITY:
    inbound_priority_frames_++;
    break;
  case NGHTTP2_WINDOW_UPDATE:
    inbound_window_update_frames_++;
    break;
  default:
    break;
  }

  if (!checkInboundFrameLimits()) {
    // NGHTTP2_ERR_FLOODED is overridden within nghttp2 library and it doesn't propagate
    // all the way to nghttp2_session_mem_recv() where we need it.
    flood_detected_ = true;
    return false;
  }

  return true;
}
