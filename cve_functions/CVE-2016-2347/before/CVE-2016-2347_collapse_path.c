static void collapse_path(char *filename)
{
	unsigned int currpath_len;
	char *currpath;
	char *r, *w;

	// If the path starts with a /, it is an absolute path; skip over
	// that first character and don't remove it.

	if (filename[0] == '/') {
		++filename;
	}

	// Step through each character, copying it from 'r' to 'w'. It
	// is always the case that w <= r, and the final string will
	// be equal in length or shorter than the original.

	currpath = filename;
	w = filename;

	for (r = filename; *r != '\0'; ++r) {
		*w++ = *r;

		// Each time a new path separator is found, examine the
		// path that was just written.

		if (*r == '/') {

			currpath_len = w - currpath - 1;

			// Empty path (//) or current directory (.)?

			if (currpath_len == 0
			 || (currpath_len == 1 && currpath[0] == '.')) {
				w = currpath;

			// Parent directory (..)?

			} else if (currpath_len == 2
			        && currpath[0] == '.' && currpath[1] == '.') {

				// Walk back up by one directory. Don't go
				// past the start of the string.

				if (currpath == filename) {
					w = filename;
				} else {
					w = currpath - 1;

					while (w > filename) {
						if (*(w - 1) == '/') {
							break;
						}
						--w;
					}

					currpath = w;
				}

			// Save for next time we start a new path.

			} else {
				currpath = w;
			}
		}
	}

	*w = '\0';
}
