void OSDMonitor::create_pending()
{
  pending_inc = OSDMap::Incremental(osdmap.epoch+1);
  pending_inc.fsid = mon->monmap->fsid;
  pending_metadata.clear();
  pending_metadata_rm.clear();

  dout(10) << "create_pending e " << pending_inc.epoch << dendl;

  // clean up pg_temp, primary_temp
  OSDMap::clean_temps(cct, osdmap, &pending_inc);
  dout(10) << "create_pending  did clean_temps" << dendl;

  // safety checks (this shouldn't really happen)
  {
    if (osdmap.backfillfull_ratio <= 0) {
      pending_inc.new_backfillfull_ratio = g_conf->mon_osd_backfillfull_ratio;
      if (pending_inc.new_backfillfull_ratio > 1.0)
	pending_inc.new_backfillfull_ratio /= 100;
      dout(1) << __func__ << " setting backfillfull_ratio = "
	      << pending_inc.new_backfillfull_ratio << dendl;
    }
    if (osdmap.full_ratio <= 0) {
      pending_inc.new_full_ratio = g_conf->mon_osd_full_ratio;
      if (pending_inc.new_full_ratio > 1.0)
        pending_inc.new_full_ratio /= 100;
      dout(1) << __func__ << " setting full_ratio = "
	      << pending_inc.new_full_ratio << dendl;
    }
    if (osdmap.nearfull_ratio <= 0) {
      pending_inc.new_nearfull_ratio = g_conf->mon_osd_nearfull_ratio;
      if (pending_inc.new_nearfull_ratio > 1.0)
        pending_inc.new_nearfull_ratio /= 100;
      dout(1) << __func__ << " setting nearfull_ratio = "
	      << pending_inc.new_nearfull_ratio << dendl;
    }
  }

  // Rewrite CRUSH rule IDs if they are using legacy "ruleset"
  // structure.
  if (osdmap.crush->has_legacy_rule_ids()) {
    CrushWrapper newcrush;
    _get_pending_crush(newcrush);

    // First, for all pools, work out which rule they really used
    // by resolving ruleset to rule.
    for (const auto &i : osdmap.get_pools()) {
      const auto pool_id = i.first;
      const auto &pool = i.second;
      int new_rule_id = newcrush.find_rule(pool.crush_rule,
					   pool.type, pool.size);

      dout(1) << __func__ << " rewriting pool "
	      << osdmap.get_pool_name(pool_id) << " crush ruleset "
	      << pool.crush_rule << " -> rule id " << new_rule_id << dendl;
      if (pending_inc.new_pools.count(pool_id) == 0) {
	pending_inc.new_pools[pool_id] = pool;
      }
      pending_inc.new_pools[pool_id].crush_rule = new_rule_id;
    }

    // Now, go ahead and renumber all the rules so that their
    // rule_id field corresponds to their position in the array
    auto old_to_new = newcrush.renumber_rules();
    dout(1) << __func__ << " Rewrote " << old_to_new << " crush IDs:" << dendl;
    for (const auto &i : old_to_new) {
      dout(1) << __func__ << " " << i.first << " -> " << i.second << dendl;
    }
    pending_inc.crush.clear();
    newcrush.encode(pending_inc.crush, mon->get_quorum_con_features());
  }
}
