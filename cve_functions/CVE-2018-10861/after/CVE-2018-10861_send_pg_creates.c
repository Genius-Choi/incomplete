epoch_t OSDMonitor::send_pg_creates(int osd, Connection *con, epoch_t next) const
{
  dout(30) << __func__ << " osd." << osd << " next=" << next
	   << " " << creating_pgs_by_osd_epoch << dendl;
  std::lock_guard<std::mutex> l(creating_pgs_lock);
  if (creating_pgs_epoch <= creating_pgs.last_scan_epoch) {
    dout(20) << __func__
	     << " not using stale creating_pgs@" << creating_pgs_epoch << dendl;
    // the subscribers will be updated when the mapping is completed anyway
    return next;
  }
  auto creating_pgs_by_epoch = creating_pgs_by_osd_epoch.find(osd);
  if (creating_pgs_by_epoch == creating_pgs_by_osd_epoch.end())
    return next;
  assert(!creating_pgs_by_epoch->second.empty());

  MOSDPGCreate *oldm = nullptr; // for pre-mimic OSD compat
  MOSDPGCreate2 *m = nullptr;

  // for now, keep sending legacy creates.  Until we sort out how to address
  // racing mon create resends and splits, we are better off with the less
  // drastic impacts of http://tracker.ceph.com/issues/22165.  The legacy
  // create message handling path in the OSD still does the old thing where
  // the pg history is pregenerated and it's instantiated at the latest osdmap
  // epoch; child pgs are simply not created.
  bool old = true; // !HAVE_FEATURE(con->get_features(), SERVER_NAUTILUS);

  epoch_t last = 0;
  for (auto epoch_pgs = creating_pgs_by_epoch->second.lower_bound(next);
       epoch_pgs != creating_pgs_by_epoch->second.end(); ++epoch_pgs) {
    auto epoch = epoch_pgs->first;
    auto& pgs = epoch_pgs->second;
    dout(20) << __func__ << " osd." << osd << " from " << next
             << " : epoch " << epoch << " " << pgs.size() << " pgs" << dendl;
    last = epoch;
    for (auto& pg : pgs) {
      // Need the create time from the monitor using its clock to set
      // last_scrub_stamp upon pg creation.
      auto create = creating_pgs.pgs.find(pg.pgid);
      assert(create != creating_pgs.pgs.end());
      if (old) {
	if (!oldm) {
	  oldm = new MOSDPGCreate(creating_pgs_epoch);
	}
	oldm->mkpg.emplace(pg.pgid,
			   pg_create_t{create->second.first, pg.pgid, 0});
	oldm->ctimes.emplace(pg.pgid, create->second.second);
      } else {
	if (!m) {
	  m = new MOSDPGCreate2(creating_pgs_epoch);
	}
	m->pgs.emplace(pg, create->second);
      }
      dout(20) << __func__ << " will create " << pg
	       << " at " << create->second.first << dendl;
    }
  }
  if (m) {
    con->send_message(m);
  } else if (oldm) {
    con->send_message(oldm);
  } else {
    dout(20) << __func__ << " osd." << osd << " from " << next
             << " has nothing to send" << dendl;
    return next;
  }

  // sub is current through last + 1
  return last + 1;
}
