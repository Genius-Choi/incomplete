netplan_delete_connection(const char* id, const char* rootdir)
{
    g_autofree gchar* yaml_path = NULL;
    g_autoptr(GError) error = NULL;
    NetplanNetDefinition* nd = NULL;
    gboolean ret = TRUE;
    int patch_fd = -1;

    NetplanParser* input_parser = netplan_parser_new();
    NetplanState* input_state = netplan_state_new();
    NetplanParser* output_parser = NULL;
    NetplanState* output_state = NULL;

    /* parse all YAML files */
    if (   !netplan_parser_load_yaml_hierarchy(input_parser, rootdir, &error)
        || !netplan_state_import_parser_results(input_state, input_parser, &error)) {
        g_fprintf(stderr, "netplan_delete_connection: Cannot parse input: %s\n", error->message);
        ret = FALSE;
        goto cleanup;
    }

    /* find specified netdef in input state */
    nd = netplan_state_get_netdef(input_state, id);
    if (!nd) {
        g_fprintf(stderr, "netplan_delete_connection: Cannot delete %s, does not exist.\n", id);
        ret = FALSE;
        goto cleanup;
    }

    /* Build up a tab-separated YAML path for this Netdef (e.g. network.ethernets.eth0=...) */
    yaml_path = g_strdup_printf("network\t%s\t%s", netplan_def_type_name(nd->type), id);

    /* create a temporary file in memory, to hold our YAML patch */
    patch_fd = memfd_create("patch.yaml", 0);
    if (patch_fd < 0) {
        // LCOV_EXCL_START
        g_fprintf(stderr, "netplan_delete_connection: Cannot create memfd: %m\n");
        ret = FALSE;
        goto cleanup;
        // LCOV_EXCL_STOP
    }
    if (!netplan_util_create_yaml_patch(yaml_path, "NULL", patch_fd, &error)) {
        // LCOV_EXCL_START
        g_fprintf(stderr, "netplan_delete_connection: Cannot create YAML patch: %s\n", error->message);
        ret = FALSE;
        goto cleanup;
        // LCOV_EXCL_STOP
    }

    /* Create a new parser & state to hold our output YAML, ignoring the to be
     * deleted Netdef from the patch */
    output_parser = netplan_parser_new();
    output_state = netplan_state_new();

    lseek(patch_fd, 0, SEEK_SET);
    if (   !netplan_parser_load_nullable_fields(output_parser, patch_fd, &error)
        || !netplan_parser_load_yaml_hierarchy(output_parser, rootdir, &error)) {
        // LCOV_EXCL_START
        g_fprintf(stderr, "netplan_delete_connection: Cannot load output state: %s\n", error->message);
        ret = FALSE;
        goto cleanup;
        // LCOV_EXCL_STOP
    }

    lseek(patch_fd, 0, SEEK_SET);
    if (!netplan_parser_load_yaml_from_fd(output_parser, patch_fd, &error)) {
        // LCOV_EXCL_START
        g_fprintf(stderr, "netplan_delete_connection: Cannot parse YAML patch: %s\n", error->message);
        ret = FALSE;
        goto cleanup;
        // LCOV_EXCL_STOP
    }

    /* We're only deleting some data, so FALLBACK_FILENAME should never be created */
    if (   !netplan_state_import_parser_results(output_state, output_parser, &error)
        || !netplan_state_update_yaml_hierarchy(output_state, FALLBACK_FILENAME, rootdir, &error)) {
        // LCOV_EXCL_START
        g_fprintf(stderr, "netplan_delete_connection: Cannot write output state: %s\n", error->message);
        ret = FALSE;
        goto cleanup;
        // LCOV_EXCL_STOP
    }

cleanup:
    if (input_parser) netplan_parser_clear(&input_parser);
    if (input_state) netplan_state_clear(&input_state);
    if (output_parser) netplan_parser_clear(&output_parser);
    if (output_state) netplan_state_clear(&output_state);
    if (patch_fd >= 0) close(patch_fd);
    return ret;
}
