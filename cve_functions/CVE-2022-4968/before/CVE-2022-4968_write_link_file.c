write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)
{
    GString* s = NULL;
    mode_t orig_umask;

    /* Don't write .link files for virtual devices; they use .netdev instead.
     * Don't write .link files for MODEM devices, as they aren't supported by networkd.
     */
    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)
        return;

    /* do we need to write a .link file? */
    if (!def->set_name &&
        !def->wake_on_lan &&
        !def->mtubytes &&
        !(_is_macaddress_special_nd_option(def->set_mac) && def->backend == NETPLAN_BACKEND_NETWORKD) &&
        (def->receive_checksum_offload == NETPLAN_TRISTATE_UNSET) &&
        (def->transmit_checksum_offload == NETPLAN_TRISTATE_UNSET) &&
        (def->tcp_segmentation_offload == NETPLAN_TRISTATE_UNSET) &&
        (def->tcp6_segmentation_offload == NETPLAN_TRISTATE_UNSET) &&
        (def->generic_segmentation_offload == NETPLAN_TRISTATE_UNSET) &&
        (def->generic_receive_offload == NETPLAN_TRISTATE_UNSET) &&
        (def->large_receive_offload == NETPLAN_TRISTATE_UNSET))
        return;

    /* build file contents */
    s = g_string_sized_new(200);
    append_match_section(def, s, FALSE);

    g_string_append(s, "\n[Link]\n");
    if (def->set_name)
        g_string_append_printf(s, "Name=%s\n", def->set_name);
    /* FIXME: Should this be turned from bool to str and support multiple values? */
    g_string_append_printf(s, "WakeOnLan=%s\n", def->wake_on_lan ? "magic" : "off");
    if (def->mtubytes)
        g_string_append_printf(s, "MTUBytes=%u\n", def->mtubytes);

    if (_is_macaddress_special_nd_option(def->set_mac) && def->backend == NETPLAN_BACKEND_NETWORKD) {
        if (!g_strcmp0(def->set_mac, "permanent")) {
            /* "permanent" is used for both NM and ND, but the actual setting value for ND is "persistent" */
            g_string_append_printf(s, "MACAddressPolicy=persistent\n");
        } else {
            g_string_append_printf(s, "MACAddressPolicy=%s\n", def->set_mac);
        }
    }

    /* Offload options */
    if (def->receive_checksum_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "ReceiveChecksumOffload=%s\n",
        (def->receive_checksum_offload ? "true" : "false"));

    if (def->transmit_checksum_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "TransmitChecksumOffload=%s\n",
        (def->transmit_checksum_offload ? "true" : "false"));

    if (def->tcp_segmentation_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "TCPSegmentationOffload=%s\n",
        (def->tcp_segmentation_offload ? "true" : "false"));

    if (def->tcp6_segmentation_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "TCP6SegmentationOffload=%s\n",
        (def->tcp6_segmentation_offload ? "true" : "false"));

    if (def->generic_segmentation_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "GenericSegmentationOffload=%s\n",
        (def->generic_segmentation_offload ? "true" : "false"));

    if (def->generic_receive_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "GenericReceiveOffload=%s\n",
        (def->generic_receive_offload ? "true" : "false"));

    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)
        g_string_append_printf(s, "LargeReceiveOffload=%s\n",
        (def->large_receive_offload ? "true" : "false"));

    orig_umask = umask(022);
    _netplan_g_string_free_to_file(s, rootdir, path, ".link");
    umask(orig_umask);
}
