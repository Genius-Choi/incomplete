write_nm_vxlan_parameters(const NetplanNetDefinition* def, GKeyFile* kf)
{
    g_assert(def->vxlan);
    char uuidstr[37];
    if (def->vxlan->ageing)
        g_key_file_set_uint64(kf, "vxlan", "ageing", def->vxlan->ageing);
    if (def->tunnel.port)
        g_key_file_set_uint64(kf, "vxlan", "destination-port", def->tunnel.port);
    if (def->vxlan->vni)
        g_key_file_set_uint64(kf, "vxlan", "id", def->vxlan->vni);
    if (def->vxlan->mac_learning != NETPLAN_TRISTATE_UNSET)
        g_key_file_set_boolean(kf, "vxlan", "learning", def->vxlan->mac_learning);
    if (def->vxlan->limit)
        g_key_file_set_uint64(kf, "vxlan", "limit", def->vxlan->limit);
    if (def->tunnel.local_ip)
        g_key_file_set_string(kf, "vxlan", "local", def->tunnel.local_ip);
    if (def->tunnel.remote_ip)
        g_key_file_set_string(kf, "vxlan", "remote", def->tunnel.remote_ip);
    if (def->vxlan->arp_proxy != NETPLAN_TRISTATE_UNSET)
        g_key_file_set_boolean(kf, "vxlan", "proxy", def->vxlan->arp_proxy);
    if (def->vxlan->notifications) {
        if (def->vxlan->notifications & NETPLAN_VXLAN_NOTIFICATION_L2_MISS)
            g_key_file_set_boolean(kf, "vxlan", "l2-miss", TRUE);
        if (def->vxlan->notifications & NETPLAN_VXLAN_NOTIFICATION_L3_MISS)
            g_key_file_set_boolean(kf, "vxlan", "l3-miss", TRUE);
    }
    if (def->vxlan->source_port_min && def->vxlan->source_port_max) {
        g_key_file_set_uint64(kf, "vxlan", "source-port-min", def->vxlan->source_port_min);
        g_key_file_set_uint64(kf, "vxlan", "source-port-max", def->vxlan->source_port_max);
    }
    if (def->vxlan->tos)
        g_key_file_set_uint64(kf, "vxlan", "tos", def->vxlan->tos);
    if (def->tunnel_ttl)
        g_key_file_set_uint64(kf, "vxlan", "ttl", def->tunnel_ttl);
    if (def->vxlan->short_circuit != NETPLAN_TRISTATE_UNSET)
        g_key_file_set_boolean(kf, "vxlan", "rsc", def->vxlan->short_circuit);
    if (def->vxlan->link) {
        if (def->vxlan->link->has_match) {
            /* we need to refer to the parent's UUID as we don't have an
             * interface name with match: */
            maybe_generate_uuid(def->vxlan->link);
            uuid_unparse(def->vxlan->link->uuid, uuidstr);
            g_key_file_set_string(kf, "vxlan", "parent", uuidstr);
        } else {
            /* if we have an interface name, use that as parent */
            g_key_file_set_string(kf, "vxlan", "parent", def->vxlan->link->id);
        }
    }

    if (def->vxlan->checksums || def->vxlan->extensions || def->vxlan->flow_label != G_MAXUINT || def->vxlan->do_not_fragment != NETPLAN_TRISTATE_UNSET)
        g_warning("%s: checksums/extensions/flow-lable/do-not-fragment are not supported by NetworkManager\n", def->id);
}
