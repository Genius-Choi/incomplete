receiveTransportConnectionTCP(PRIVATE_NETWORKKEY ** network,
                              DUL_BLOCKOPTIONS block,
                              int timeout,
                              DUL_ASSOCIATESERVICEPARAMETERS * params,
                              PRIVATE_ASSOCIATIONKEY ** association)
{
#ifndef DCMTK_HAVE_POLL
    fd_set fdset;
#endif
    struct timeval timeout_val;
#ifdef HAVE_DECLARATION_SOCKLEN_T
    socklen_t len;
#elif !defined(HAVE_PROTOTYPE_ACCEPT) || defined(HAVE_INTP_ACCEPT)
    int len;
#else
    size_t len;
#endif
    int nfound, connected;
    struct sockaddr from;
    struct linger sockarg;

#ifdef HAVE_FORK
    pid_t pid = -1;
#endif

    (void) memset(&sockarg, 0, sizeof(sockarg));

    int reuse = 1;

#ifdef _WIN32
    SOCKET sock = dcmExternalSocketHandle.get();
    if (sock != INVALID_SOCKET)
#else
    int sock = dcmExternalSocketHandle.get();
    if (sock > 0)
#endif
    {
      // use the socket file descriptor provided to us externally
      // instead of calling accept().
      connected = 1;

      len = sizeof(from);
      if (getpeername(sock, &from, &len))
      {
          OFOStringStream stream;
          stream << "TCP Initialization Error: " << OFStandard::getLastNetworkErrorCode().message()
                 << ", getpeername failed on socket " << sock << OFStringStream_ends;
          OFSTRINGSTREAM_GETOFSTRING(stream, msg)
          return makeDcmnetCondition(DULC_TCPINITERROR, OF_error, msg.c_str());
      }
    }
    else
    {
        if (block == DUL_NOBLOCK)
        {
            connected = 0;
#ifdef DCMTK_HAVE_POLL
            struct pollfd pfd[] =
            {
                { (*network)->networkSpecific.TCP.listenSocket, POLLIN, 0 }
            };
#else
             FD_ZERO(&fdset);
#ifdef __MINGW32__
            // on MinGW, FD_SET expects an unsigned first argument
            FD_SET((unsigned int)((*network)->networkSpecific.TCP.listenSocket), &fdset);
#else
            FD_SET((*network)->networkSpecific.TCP.listenSocket, &fdset);
#endif /* __MINGW32__ */
#endif /* DCMTK_HAVE_POLL */

            timeout_val.tv_sec = timeout;
            timeout_val.tv_usec = 0;

#ifdef DCMTK_HAVE_POLL
            nfound = poll(pfd, 1, timeout_val.tv_sec*1000+(timeout_val.tv_usec/1000));
#else
#ifdef HAVE_INTP_SELECT
            nfound = select(
              OFstatic_cast(int, (*network)->networkSpecific.TCP.listenSocket + 1),
                           (int *)(&fdset), NULL, NULL, &timeout_val);
#else
            // On Win32, it is safe to cast the first parameter to int
            // because Windows ignores this parameter anyway.
            nfound = select(
              OFstatic_cast(int, (*network)->networkSpecific.TCP.listenSocket + 1),
                           &fdset, NULL, NULL, &timeout_val);
#endif /* HAVE_INTP_SELECT */
#endif /* DCMTK_HAVE_POLL*/

            if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL))
            {
                DU_logSelectResult(nfound);
            }
            if (nfound > 0) {
#ifdef DCMTK_HAVE_POLL
                if (pfd[0].revents & POLLIN)
                    connected++;
#else
                if (FD_ISSET((*network)->networkSpecific.TCP.listenSocket, &fdset))
                    connected++;
#endif
            }
            if (!connected) return DUL_NOASSOCIATIONREQUEST;
        }
        else
        {
            connected = 0;
            do {
#ifdef DCMTK_HAVE_POLL
                struct pollfd pfd[]=
                {
                    { (*network)->networkSpecific.TCP.listenSocket, POLLIN, 0 }
                };
#else
                FD_ZERO(&fdset);
#ifdef __MINGW32__
                // on MinGW, FD_SET expects an unsigned first argument
                FD_SET((unsigned int)((*network)->networkSpecific.TCP.listenSocket), &fdset);
#else
                FD_SET((*network)->networkSpecific.TCP.listenSocket, &fdset);
#endif /* __MINGW32__ */
#endif /* DCMTK_HAVE_POLL */
                timeout_val.tv_sec = 5;
                timeout_val.tv_usec = 0;
#ifdef DCMTK_HAVE_POLL
                nfound = poll(pfd, 1, timeout_val.tv_sec*1000+(timeout_val.tv_usec/1000));
#else
#ifdef HAVE_INTP_SELECT
                nfound = select(
                  OFstatic_cast(int, (*network)->networkSpecific.TCP.listenSocket + 1),
                                (int *)(&fdset), NULL, NULL, &timeout_val);
#else
                // On Win32, it is safe to cast the first parameter to int
                // because Windows ignores this parameter anyway.
                nfound = select(
                  OFstatic_cast(int, (*network)->networkSpecific.TCP.listenSocket + 1),
                                &fdset, NULL, NULL, &timeout_val);
#endif /* HAVE_INTP_SELECT */
#endif /* DCMTK_HAVE_POLL */
                if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL))
                {
                    DU_logSelectResult(nfound);
                }
                if (nfound > 0) {
#ifdef DCMTK_HAVE_POLL
                    if (pfd[0].revents & POLLIN)
                        connected++;
#else
                    if (FD_ISSET((*network)->networkSpecific.TCP.listenSocket, &fdset))
                        connected++;
#endif
                }
            } while (!connected);
        }

        len = sizeof(from);
        do
        {
            sock = accept((*network)->networkSpecific.TCP.listenSocket, &from, &len);
#ifdef _WIN32
        } while (sock == INVALID_SOCKET && WSAGetLastError() == WSAEINTR);
        if (sock == INVALID_SOCKET)
#else
        } while (sock == -1 && errno == EINTR);
        if (sock < 0)
#endif
        {
            OFOStringStream stream;
            stream << "TCP Initialization Error: " << OFStandard::getLastNetworkErrorCode().message()
                   << ", accept failed on socket " << sock << OFStringStream_ends;
            OFSTRINGSTREAM_GETOFSTRING(stream, msg)
            return makeDcmnetCondition(DULC_TCPINITERROR, OF_error, msg.c_str());
        }
    }

#ifdef HAVE_FORK
    if (shouldFork)
    {
        // fork for unix
        pid = fork();
        if (pid > 0)
        {
            // we're the parent process, close accepted socket and return
            close(sock);

            OFOStringStream stream;
            stream << "New child process started with pid " << pid << OFStringStream_ends;
            OFSTRINGSTREAM_GETOFSTRING(stream, msg)
            return makeDcmnetCondition(DULC_FORKEDCHILD, OF_ok, msg.c_str());
        }
        else if (pid < 0)
        {
            // fork failed, return error code
            close(sock);

            OFString msg = "Multi-Process Error: ";
            msg += OFStandard::getLastSystemErrorCode().message();
            msg += ", fork failed";
            return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, msg.c_str());
        }
        else
        {
          // we're the child process, continue normally
          processIsForkedChild = OFTrue;
        }
    }
#elif defined(_WIN32)
    if (shouldFork && (command_argc > 0) && command_argv)
    {
        // win32 code to create new child process
        HANDLE childSocketHandle;
        HANDLE hChildStdInRead;
        HANDLE hChildStdInWrite;
        HANDLE hChildStdInWriteDup;

        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = NULL;

        // prepare the command line
        OFString cmdLine = command_argv[0];
        cmdLine += " --forked-child";
        for (int i=1; i < command_argc; ++i)
        {
            /* copy each argv value and surround it with double quotes
             * to keep option values containing a space glued together
             */
            cmdLine += " \"";
            cmdLine += command_argv[i];
            /* if last character in argument value is a backslash, escape it
             * since otherwise it would escape the quote appended in the following
             * step, i.e. make sure that something like '\my\dir\' does not become
             * '"\my\dir\"' but instead ends up as '"\my\dir\\"' (single quotes for
             *  demonstration purposes). Make sure nobody passes a zero length string.
             */
            size_t len2 = strlen(command_argv[i]);
            if ((len2 > 0) && (command_argv[i][len2 - 1] == '\\'))
            {
	            cmdLine += "\\";
            }
            cmdLine += "\"";
        }

        // create anonymous pipe
        if (!CreatePipe(&hChildStdInRead, &hChildStdInWrite, &sa,0))
        {
            OFOStringStream stream;
            stream << "Multi-Process Error: Creating anonymous pipe failed with error code "
                   << GetLastError() << OFStringStream_ends;
            OFSTRINGSTREAM_GETOFSTRING(stream, msg)
            return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, msg.c_str());
        }

        // create duplicate of write end handle of pipe
        if (!DuplicateHandle(GetCurrentProcess(), hChildStdInWrite,
                             GetCurrentProcess(), &hChildStdInWriteDup, 0,
                             FALSE, DUPLICATE_SAME_ACCESS))
        {
            return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, "Multi-Process Error: Duplicating handle failed");
        }

        // destroy original write end handle of pipe
        CloseHandle(hChildStdInWrite);

        // we need a STARTUPINFO and a PROCESS_INFORMATION structure for CreateProcess.
        STARTUPINFOA si;
        PROCESS_INFORMATION pi;
        memset(&pi,0,sizeof(pi));
        memset(&si,0,sizeof(si));

        // prepare startup info for child process:
        // the child uses the same stdout and stderr as the parent, but
        // stdin is the read end of our anonymous pipe.
        si.cb = sizeof(si);
        si.dwFlags |= STARTF_USESTDHANDLES;
        si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
        si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
        si.hStdInput = hChildStdInRead;

        // create child process.
        if (!CreateProcessA(NULL,OFconst_cast(char *, cmdLine.c_str()), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        {
            OFOStringStream stream;
            stream << "Multi-Process Error: Creating process failed with error code "
                   << GetLastError() << OFStringStream_ends;
            OFSTRINGSTREAM_GETOFSTRING(stream, msg)
            return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, msg.c_str());
        }
        else
        {
            // call OpenProcess to retrieve the REAL process handle.  using
            // GetCurrentProcess() only returns a pseudo handle which may not
            // allow DuplicateHandle to create the child process socket with
            // sufficient permissions on certain versions of Windows.
            HANDLE hParentProcessHandle = OpenProcess(PROCESS_DUP_HANDLE, FALSE, GetCurrentProcessId());
            if (hParentProcessHandle == NULL)
            {
                // unable to get process handle...
                // ...this should really never happen as we are opening the current process.
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
                CloseHandle((HANDLE)sock);

                OFOStringStream stream;
                stream << "Multi-Process Error: Opening process to get real process handle failed with error code "
                       << GetLastError() << OFStringStream_ends;
                OFSTRINGSTREAM_GETOFSTRING(stream, msg)
                return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, msg.c_str());
            }

            // PROCESS_INFORMATION pi now contains various handles for the new process.
            // Now that we have a handle to the new process, we can duplicate the
            // socket handle into the new child process.
            if (DuplicateHandle(hParentProcessHandle, (HANDLE)sock, pi.hProcess,
                &childSocketHandle, 0, TRUE, DUPLICATE_SAME_ACCESS))
            {
                // close handles in PROCESS_INFORMATION structure
                // and our local copy of the socket handle.
                CloseHandle(hParentProcessHandle);
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
                closesocket(sock);

                // send number of socket handle in child process over anonymous pipe
                DWORD bytesWritten;
                char buf[30];
                // we pass the socket handle as a 64-bit unsigned integer, which should work for 32 and 64 bit Windows
                sprintf(buf, "%llu", OFreinterpret_cast(unsigned __int64, childSocketHandle));
                if (!WriteFile(hChildStdInWriteDup, buf, OFstatic_cast(DWORD, strlen(buf) + 1), &bytesWritten, NULL))
                {
                    CloseHandle(hChildStdInWriteDup);
                    return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, "Multi-Process Error: Writing to anonymous pipe failed");
                }

                // return OF_ok status code DULC_FORKEDCHILD with descriptive text
                OFOStringStream stream;
                stream << "New child process started with pid " << OFstatic_cast(int, pi.dwProcessId)
                       << ", socketHandle " << OFstatic_cast(int, OFreinterpret_cast(size_t, childSocketHandle)) << OFStringStream_ends;
                OFSTRINGSTREAM_GETOFSTRING(stream, msg)
                return makeDcmnetCondition(DULC_FORKEDCHILD, OF_ok, msg.c_str());
            }
            else
            {
                // unable to duplicate handle. Close handles nevertheless
                // to avoid resource leak.
                CloseHandle(hParentProcessHandle);
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
                return makeDcmnetCondition(DULC_CANNOTFORK, OF_error, "Multi-Process Error: Duplicating socket handle failed");
            }
        }
    }
#endif

    sockarg.l_onoff = 0;
    if (setsockopt(sock, SOL_SOCKET, SO_LINGER, (char *) &sockarg, sizeof(sockarg)) < 0)
    {
        OFOStringStream stream;
        stream << "TCP Initialization Error: " << OFStandard::getLastNetworkErrorCode().message()
               << ", setsockopt failed on socket " << sock << OFStringStream_ends;
        OFSTRINGSTREAM_GETOFSTRING(stream, msg)
        return makeDcmnetCondition(DULC_TCPINITERROR, OF_error, msg.c_str());
    }
    reuse = 1;

#ifdef _WIN32
    if (setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *) &reuse, sizeof(reuse)) < 0)
#else
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &reuse, sizeof(reuse)) < 0)
#endif
    {
        OFString msg = "TCP Initialization Error: ";
        msg += OFStandard::getLastNetworkErrorCode().message();
        return makeDcmnetCondition(DULC_TCPINITERROR, OF_error, msg.c_str());
    }
    setTCPBufferLength(sock);

    /*
     * Disable the so-called Nagle algorithm (if requested).
     * This might provide a better network performance on some systems/environments.
     * By default, the algorithm is not disabled unless DISABLE_NAGLE_ALGORITHM is defined.
     * The default behavior can be changed by setting the environment variable TCP_NODELAY.
     */

#ifdef DONT_DISABLE_NAGLE_ALGORITHM
#ifdef _MSC_VER
#pragma message("The macro DONT_DISABLE_NAGLE_ALGORITHM is not supported anymore. See 'macros.txt' for details.")
#else
#warning The macro DONT_DISABLE_NAGLE_ALGORITHM is not supported anymore. See "macros.txt" for details.
#endif
#endif

#ifdef DISABLE_NAGLE_ALGORITHM
    int tcpNoDelay = 1; // disable
#else
    int tcpNoDelay = 0; // don't disable
#endif
    char* tcpNoDelayString = NULL;
    DCMNET_TRACE("checking whether environment variable TCP_NODELAY is set");
    if ((tcpNoDelayString = getenv("TCP_NODELAY")) != NULL)
    {
      if (sscanf(tcpNoDelayString, "%d", &tcpNoDelay) != 1)
      {
        DCMNET_WARN("DUL: cannot parse environment variable TCP_NODELAY=" << tcpNoDelayString);
      }
    } else
      DCMNET_TRACE("  environment variable TCP_NODELAY not set, using the default value (" << tcpNoDelay << ")");
    if (tcpNoDelay) {
#ifdef DISABLE_NAGLE_ALGORITHM
      DCMNET_DEBUG("DUL: disabling Nagle algorithm as defined at compilation time (DISABLE_NAGLE_ALGORITHM)");
#else
      DCMNET_DEBUG("DUL: disabling Nagle algorithm as requested at runtime (TCP_NODELAY=" << tcpNoDelayString << ")");
#endif
      if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char*)&tcpNoDelay, sizeof(tcpNoDelay)) < 0)
      {
        OFString msg = "TCP Initialization Error: ";
        msg += OFStandard::getLastNetworkErrorCode().message();
        return makeDcmnetCondition(DULC_TCPINITERROR, OF_error, msg.c_str());
      }
#ifdef DISABLE_NAGLE_ALGORITHM
    } else {
      DCMNET_DEBUG("DUL: do not disable Nagle algorithm as requested at runtime (TCP_NODELAY=" << tcpNoDelayString << ")");
#endif
    }

    // create string containing numerical IP address.
    OFString client_dns_name;
    char client_ip_address[20];
    sprintf(client_ip_address, "%-d.%-d.%-d.%-d",  // this code is ugly but thread safe
       ((int) from.sa_data[2]) & 0xff,
       ((int) from.sa_data[3]) & 0xff,
       ((int) from.sa_data[4]) & 0xff,
       ((int) from.sa_data[5]) & 0xff);

    if (! dcmDisableGethostbyaddr.get())
       client_dns_name = OFStandard::getHostnameByAddress(&from.sa_data[2], sizeof(struct in_addr), AF_INET);

    if (client_dns_name.length() == 0)
    {
        // reverse DNS lookup disabled or host not found, use numerical address
        OFStandard::strlcpy(params->callingPresentationAddress, client_ip_address,
          sizeof(params->callingPresentationAddress));
        OFStandard::strlcpy((*association)->remoteNode, client_ip_address, sizeof((*association)->remoteNode));
        DCMNET_DEBUG("Association Received: " << params->callingPresentationAddress );
    }
    else
    {
        char node[260];
        if ((*network)->options & DUL_FULLDOMAINNAME)
            OFStandard::strlcpy(node, client_dns_name.c_str(), sizeof(node));
        else {
            if (sscanf(client_dns_name.c_str(), "%[^.]", node) != 1)
                node[0] = '\0';
        }
        OFStandard::strlcpy((*association)->remoteNode, node, sizeof((*association)->remoteNode));
        OFStandard::strlcpy(params->callingPresentationAddress, node, sizeof(params->callingPresentationAddress));
        DCMNET_DEBUG("Association Received: " << params->callingPresentationAddress );
    }

#ifdef WITH_TCPWRAPPER
    const char *daemon = dcmTCPWrapperDaemonName.get();
    if (daemon)
    {
        // enforce access control using the TCP wrapper - see hosts_access(5).

        // if reverse DNS lookup is disabled, use default value
        if (client_dns_name.empty()) client_dns_name = STRING_UNKNOWN;

        struct request_info request;
        request_init(&request, RQ_CLIENT_NAME, client_dns_name.c_str(), 0);
        request_set(&request, RQ_CLIENT_ADDR, client_ip_address, 0);
        request_set(&request, RQ_USER, STRING_UNKNOWN, 0);
        request_set(&request, RQ_DAEMON, daemon, 0);

        if (! dcmtk_hosts_access(&request))
        {
#ifdef HAVE_WINSOCK_H
          (void) shutdown(sock,  1 /* SD_SEND */);
          (void) closesocket(sock);
#else
          (void) close(sock);
#endif
          OFOStringStream stream;
          stream << "TCP wrapper: denied connection from " << client_dns_name
                 << " (" << client_ip_address << ")" << OFStringStream_ends;
          OFSTRINGSTREAM_GETOFSTRING(stream, msg)
          return makeDcmnetCondition(DULC_TCPWRAPPER, OF_error, msg.c_str());
        }
    }
#endif

    if ((*association)->connection) delete (*association)->connection;

    if ((*network)->networkSpecific.TCP.tLayer)
    {
      (*association)->connection = ((*network)->networkSpecific.TCP.tLayer)->createConnection(sock, params->useSecureLayer);
    }
    else (*association)->connection = NULL;

    if ((*association)->connection == NULL)
    {
#ifdef HAVE_WINSOCK_H
      (void) shutdown(sock,  1 /* SD_SEND */);
      (void) closesocket(sock);
#else
      (void) close(sock);
#endif
      OFString msg = "TCP Initialization Error: ";
      msg += OFStandard::getLastNetworkErrorCode().message();
      return makeDcmnetCondition(DULC_TCPINITERROR, OF_error, msg.c_str());
    }

    return (*association)->connection->serverSideHandshake();
}
