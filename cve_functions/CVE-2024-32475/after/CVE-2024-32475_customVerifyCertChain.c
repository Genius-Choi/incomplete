ValidationResults ContextImpl::customVerifyCertChain(
    Envoy::Ssl::SslExtendedSocketInfo* extended_socket_info,
    const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options, SSL* ssl) {
  ASSERT(extended_socket_info);
  STACK_OF(X509)* cert_chain = SSL_get_peer_full_cert_chain(ssl);
  if (cert_chain == nullptr) {
    extended_socket_info->setCertificateValidationStatus(Ssl::ClientValidationStatus::NotValidated);
    stats_.fail_verify_error_.inc();
    ENVOY_LOG(debug, "verify cert failed: no cert chain");
    return {ValidationResults::ValidationStatus::Failed, Ssl::ClientValidationStatus::NotValidated,
            SSL_AD_INTERNAL_ERROR, absl::nullopt};
  }
  ASSERT(cert_validator_);
  const char* host_name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);

  CertValidator::ExtraValidationContext validation_ctx;
  validation_ctx.callbacks =
      static_cast<Network::TransportSocketCallbacks*>(SSL_get_ex_data(ssl, sslSocketIndex()));

  ValidationResults result = cert_validator_->doVerifyCertChain(
      *cert_chain, extended_socket_info->createValidateResultCallback(), transport_socket_options,
      *SSL_get_SSL_CTX(ssl), validation_ctx, SSL_is_server(ssl),
      absl::NullSafeStringView(host_name));
  if (result.status != ValidationResults::ValidationStatus::Pending) {
    extended_socket_info->setCertificateValidationStatus(result.detailed_status);
    extended_socket_info->onCertificateValidationCompleted(
        result.status == ValidationResults::ValidationStatus::Successful, false);
  }
  return result;
}
