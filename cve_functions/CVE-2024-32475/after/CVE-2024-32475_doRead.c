Network::IoResult SslSocket::doRead(Buffer::Instance& read_buffer) {
  if (info_->state() != Ssl::SocketState::HandshakeComplete &&
      info_->state() != Ssl::SocketState::ShutdownSent) {
    PostIoAction action = doHandshake();
    if (action == PostIoAction::Close || info_->state() != Ssl::SocketState::HandshakeComplete) {
      // end_stream is false because either a hard error occurred (action == Close) or
      // the handshake isn't complete, so a half-close cannot occur yet.
      return {action, 0, false};
    }
  }

  bool keep_reading = true;
  bool end_stream = false;
  PostIoAction action = PostIoAction::KeepOpen;
  uint64_t bytes_read = 0;
  while (keep_reading) {
    uint64_t bytes_read_this_iteration = 0;
    Buffer::Reservation reservation = read_buffer.reserveForRead();
    for (uint64_t i = 0; i < reservation.numSlices(); i++) {
      auto result = sslReadIntoSlice(reservation.slices()[i]);
      bytes_read_this_iteration += result.bytes_read_;
      if (result.error_.has_value()) {
        keep_reading = false;
        int err = SSL_get_error(rawSsl(), result.error_.value());
        ENVOY_CONN_LOG(trace, "ssl error occurred while read: {}", callbacks_->connection(),
                       Utility::getErrorDescription(err));
        switch (err) {
        case SSL_ERROR_WANT_READ:
          break;
        case SSL_ERROR_ZERO_RETURN:
          // Graceful shutdown using close_notify TLS alert.
          end_stream = true;
          break;
        case SSL_ERROR_SYSCALL:
          if (result.error_.value() == 0) {
            // Non-graceful shutdown by closing the underlying socket.
            end_stream = true;
            break;
          }
          FALLTHRU;
        case SSL_ERROR_WANT_WRITE:
          // Renegotiation has started. We don't handle renegotiation so just fall through.
        default:
          drainErrorQueue();
          action = PostIoAction::Close;
          break;
        }

        break;
      }
    }

    reservation.commit(bytes_read_this_iteration);
    if (bytes_read_this_iteration > 0 && callbacks_->shouldDrainReadBuffer()) {
      callbacks_->setTransportSocketIsReadable();
      keep_reading = false;
    }

    bytes_read += bytes_read_this_iteration;
  }

  ENVOY_CONN_LOG(trace, "ssl read {} bytes", callbacks_->connection(), bytes_read);

  return {action, bytes_read, end_stream};
}
