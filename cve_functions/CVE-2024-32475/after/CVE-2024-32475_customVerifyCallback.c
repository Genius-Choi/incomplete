enum ssl_verify_result_t ContextImpl::customVerifyCallback(SSL* ssl, uint8_t* out_alert) {
  auto* extended_socket_info = reinterpret_cast<Envoy::Ssl::SslExtendedSocketInfo*>(
      SSL_get_ex_data(ssl, ContextImpl::sslExtendedSocketInfoIndex()));
  if (extended_socket_info->certificateValidationResult() != Ssl::ValidateStatus::NotStarted) {
    if (extended_socket_info->certificateValidationResult() == Ssl::ValidateStatus::Pending) {
      return ssl_verify_retry;
    }
    ENVOY_LOG(trace, "Already has a result: {}",
              static_cast<int>(extended_socket_info->certificateValidationStatus()));
    // Already has a binary result, return immediately.
    *out_alert = extended_socket_info->certificateValidationAlert();
    return extended_socket_info->certificateValidationResult() == Ssl::ValidateStatus::Successful
               ? ssl_verify_ok
               : ssl_verify_invalid;
  }
  // Hasn't kicked off any validation for this connection yet.
  SSL_CTX* ssl_ctx = SSL_get_SSL_CTX(ssl);
  ContextImpl* context_impl = static_cast<ContextImpl*>(SSL_CTX_get_app_data(ssl_ctx));
  auto transport_socket_options_shared_ptr_ptr =
      static_cast<const Network::TransportSocketOptionsConstSharedPtr*>(SSL_get_app_data(ssl));
  ASSERT(transport_socket_options_shared_ptr_ptr);
  ValidationResults result = context_impl->customVerifyCertChain(
      extended_socket_info, *transport_socket_options_shared_ptr_ptr, ssl);
  switch (result.status) {
  case ValidationResults::ValidationStatus::Successful:
    return ssl_verify_ok;
  case ValidationResults::ValidationStatus::Pending:
    return ssl_verify_retry;
  case ValidationResults::ValidationStatus::Failed: {
    if (result.tls_alert.has_value() && out_alert) {
      *out_alert = result.tls_alert.value();
    }
    return ssl_verify_invalid;
  }
  }
  PANIC("not reached");
}
