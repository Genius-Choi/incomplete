NO_INLINE JsVar *jspeStatementVar() {
  JsVar *lastDefined = 0;
  /* variable creation. TODO - we need a better way of parsing the left
   * hand side. Maybe just have a flag called can_create_var that we
   * set and then we parse as if we're doing a normal equals.*/
  assert(lex->tk==LEX_R_VAR || lex->tk==LEX_R_LET || lex->tk==LEX_R_CONST);
  jslGetNextToken();
  ///TODO: Correctly implement CONST and LET - we just treat them like 'var' at the moment
  bool hasComma = true; // for first time in loop
  while (hasComma && lex->tk == LEX_ID && !jspIsInterrupted()) {
    JsVar *a = 0;
    if (JSP_SHOULD_EXECUTE) {
      a = jspeiFindOnTop(jslGetTokenValueAsString(), true);
      if (!a) { // out of memory
        jspSetError(false);
        return lastDefined;
      }
    }
    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);
    // sort out initialiser
    if (lex->tk == '=') {
      JsVar *var;
      JSP_MATCH_WITH_CLEANUP_AND_RETURN('=', jsvUnLock(a), lastDefined);
      var = jsvSkipNameAndUnLock(jspeAssignmentExpression());
      if (JSP_SHOULD_EXECUTE)
        jsvReplaceWith(a, var);
      jsvUnLock(var);
    }
    jsvUnLock(lastDefined);
    lastDefined = a;
    hasComma = lex->tk == ',';
    if (hasComma) JSP_MATCH_WITH_RETURN(',', lastDefined);
  }
  return lastDefined;
}
