JsVar *jsvNewStringOfLength(unsigned int byteLength, const char *initialData) {
  // if string large enough, try and make a flat string instead
  if (byteLength > JSV_FLAT_STRING_BREAK_EVEN) {
    JsVar *v = jsvNewFlatStringOfLength(byteLength);
    if (v) {
      if (initialData) jsvSetString(v, initialData, byteLength);
      return v;
    }
  }
  // Create a var
  JsVar *first = jsvNewWithFlags(JSV_STRING_0);
  if (!first) return 0; // out of memory, will have already set flag
  // Now keep creating enough new jsVars
  JsVar *var = jsvLockAgain(first);
  while (true) {
    // copy data in
    unsigned int l = (unsigned int)jsvGetMaxCharactersInVar(var);
    if (l>=byteLength) {
      if (initialData)
        memcpy(var->varData.str, initialData, byteLength);
      // we've got enough
      jsvSetCharactersInVar(var, byteLength);
      break;
    } else {
      if (initialData) {
        memcpy(var->varData.str, initialData, l);
        initialData+=l;
      }
      // We need more
      jsvSetCharactersInVar(var, l);
      byteLength -= l;
      // Make a new one, link it in, and unlock the old one.
      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);
      if (!next) break; // out of memory, will have already set flag
      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)
      jsvSetLastChild(var, jsvGetRef(next));
      jsvUnLock(var);
      var = next;
    }
  }
  jsvUnLock(var);
  // return
  return first;
}
