JsVar *jsvNewWithFlags(JsVarFlags flags) {
  if (isMemoryBusy) {
    jsErrorFlags |= JSERR_MEMORY_BUSY;
    return 0;
  }
  JsVar *v = 0;
  jshInterruptOff(); // to allow this to be used from an IRQ
  if (jsVarFirstEmpty!=0) {
    v = jsvGetAddressOf(jsVarFirstEmpty); // jsvResetVariable will lock
    jsVarFirstEmpty = jsvGetNextSibling(v); // move our reference to the next in the free list
    touchedFreeList = true;
  }
  jshInterruptOn();
  if (v) {
    assert(v->flags == JSV_UNUSED);
    // Cope with IRQs/multi-threading when getting a new free variable
 /*   JsVarRef empty;
    JsVarRef next;
    JsVar *v;
    do {
      empty = jsVarFirstEmpty;
      v = jsvGetAddressOf(empty); // jsvResetVariable will lock
      next = jsvGetNextSibling(v); // move our reference to the next in the free list
      touchedFreeList = true;
    } while (!__sync_bool_compare_and_swap(&jsVarFirstEmpty, empty, next));
    assert(v->flags == JSV_UNUSED);*/
    jsvResetVariable(v, flags); // setup variable, and add one lock
    // return pointer
    return v;
  }
  jsErrorFlags |= JSERR_LOW_MEMORY;
  /* If we're calling from an IRQ, do NOT try and do fancy
   * stuff to free memory */
  if (jshIsInInterrupt()) {
    return 0;
  }
  /* we don't have memory - second last hope - run garbage collector */
  if (jsvGarbageCollect()) {
    return jsvNewWithFlags(flags); // if it freed something, continue
  }
  /* we don't have memory - last hope - ask jsInteractive to try and free some it
   may have kicking around */
  if (jsiFreeMoreMemory()) {
    return jsvNewWithFlags(flags);
  }
  /* We couldn't claim any more memory by Garbage collecting... */
#ifdef RESIZABLE_JSVARS
  jsvSetMemoryTotal(jsVarsSize*2);
  return jsvNewWithFlags(flags);
#else
  // On a micro, we're screwed.
  jsErrorFlags |= JSERR_MEMORY;
  jspSetInterrupted(true);
  return 0;
#endif
}
