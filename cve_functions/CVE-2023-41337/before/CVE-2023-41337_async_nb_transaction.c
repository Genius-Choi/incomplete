static void async_nb_transaction(neverbleed_iobuf_t *buf, int reponseless)
{
#if H2O_CAN_OSSL_ASYNC
    /* When using OpenSSL with ASYNC support, we may receive requests from a fiber. If so, process them asynchronously. */
    ASYNC_JOB *job;
    if ((job = ASYNC_get_current_job()) != NULL) {
        assert(!reponseless);
        assert(h2o_socket_get_fd(async_nb.sock) == neverbleed_get_fd(neverbleed));
        async_nb_do_async_transaction(job, buf);
        return;
    }
#endif

    if (reponseless && async_nb.sock != NULL) {
        /* this is an optimization for fire-and-forget transactions which do not require a response.
           these transactions are queued on the async socket with `reponseless` being true, and are free'd
           upon write completion in `async_nb_on_write_complete`
        */
        struct async_nb_transaction_t *transaction = h2o_mem_alloc(sizeof(*transaction));
        *transaction = (struct async_nb_transaction_t){
            .buf = h2o_mem_alloc(sizeof(*transaction->buf)),
            .link = (h2o_linklist_t){},
            .responseless = 1,
        };

        /* transfer ownership of stack `buf` to heap allocated `transaction->buf` */
        h2o_memcpy(transaction->buf, buf, sizeof(*buf));
        memset(buf, 0, sizeof(*buf));
        buf = NULL;

        async_nb_push(&async_nb.write_queue, transaction);
        async_nb_submit_write_pending();
    } else {
        /* do it synchronously, by at first reading all pending reads, then write asynchronously and wait for the repsonse */
        if (async_nb.sock != NULL) {
            while (async_nb.read_queue.len != 0)
                async_nb_read_ready(async_nb.sock, NULL);
        }

        async_nb_run_sync(buf, neverbleed_transaction_write);

        if (!reponseless) {
            async_nb_run_sync(buf, neverbleed_transaction_read);
        } else {
            neverbleed_iobuf_dispose(buf);
        }
    }
}
