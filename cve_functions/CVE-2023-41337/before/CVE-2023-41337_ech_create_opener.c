static ptls_aead_context_t *ech_create_opener(ptls_ech_create_opener_t *_self, ptls_hpke_kem_t **kem,
                                              ptls_hpke_cipher_suite_t **cipher, ptls_t *tls, uint8_t config_id,
                                              ptls_hpke_cipher_suite_id_t cipher_id, ptls_iovec_t enc, ptls_iovec_t info_prefix)
{
    struct ech_create_opener_t *self = (struct ech_create_opener_t *)_self;
    struct ech_opener_config_t *config = NULL;
    ptls_aead_context_t *aead = NULL;
    ptls_buffer_t info;
    int ret;

    *kem = NULL;
    *cipher = NULL;

    ptls_buffer_init(&info, "", 0);

    /* find matching config, or bail out if not found */
    for (config = self->configs; config->keyex != NULL; ++config)
        if (config->config_id == config_id)
            break;
    if (config->keyex == NULL)
        goto Exit;

    /* find matching cipher-suite, or bail out if not found */
    for (size_t i = 0; config->cipher_suites[i] != NULL; ++i) {
        if (config->cipher_suites[i]->id.kdf == cipher_id.kdf && config->cipher_suites[i]->id.aead == cipher_id.aead) {
            *cipher = config->cipher_suites[i];
            break;
        }
    }
    if (*cipher == NULL)
        goto Exit;

    /* build info */
    ptls_buffer_pushv(&info, info_prefix.base, info_prefix.len);
    ptls_buffer_pushv(&info, config->ech_config.base, config->ech_config.len);

    /* set kem, generate AEAD */
    *kem = config->kem;
    if ((ret = ptls_hpke_setup_base_r(*kem, *cipher, config->keyex, &aead, enc, ptls_iovec_init(info.base, info.off))) != 0)
        goto Exit;

Exit:
    ptls_buffer_dispose(&info);
    return aead;
}
