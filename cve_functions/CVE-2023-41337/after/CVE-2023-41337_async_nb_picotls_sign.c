static int async_nb_picotls_sign(ptls_sign_certificate_t *_self, ptls_t *tls, ptls_async_job_t **_job, uint16_t *selected_algorithm,
                                 ptls_buffer_t *output, ptls_iovec_t input, const uint16_t *algorithms, size_t num_algorithms)
{
    struct async_nb_picotls_context_t *self = (struct async_nb_picotls_context_t *)_self;
    const ptls_openssl_signature_scheme_t *scheme;
    int ret;

    assert(_job != NULL);

    if (*_job != NULL) {
        struct async_nb_job_t *job = (struct async_nb_job_t *)*_job;
        void *digest;
        size_t digestlen;

        assert(!h2o_linklist_is_linked(&job->transaction.link));

        *selected_algorithm = job->ptls.scheme_id;

        /* obtain signature, dispose async context */
        neverbleed_finish_digestsign(&job->buf, &digest, &digestlen);
        async_nb_job_free(&job->super);
        *_job = NULL;

        /* build response */
        if ((ret = ptls_buffer_reserve(output, digestlen)) == 0) {
            memcpy(output->base + output->off, digest, digestlen);
            output->off += digestlen;
        }

        ptls_clear_memory(digest, digestlen);
        free(digest);
        return 0;
    }

    /* select the signature scheme or return an error */
    if ((scheme = ptls_openssl_select_signature_scheme(self->schemes, algorithms, num_algorithms)) == NULL)
        return PTLS_ALERT_HANDSHAKE_FAILURE;

    /* submit async request */
    struct async_nb_job_t *job = async_nb_job_new();
    neverbleed_start_digestsign(&job->buf, self->key, scheme->scheme_md(), input.base, input.len, 1);
    job->ptls.scheme_id = scheme->scheme_id;
    *_job = &job->super;
    async_nb_job_submit(job);

    return PTLS_ERROR_ASYNC_OPERATION;
}
