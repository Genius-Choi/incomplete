static struct st_quic_keyset_t *update_quic_keys(void)
{
    unsigned new_generation;

    while ((new_generation = session_tickets.generation) != quic_keys.generation) {
        /* we need to update. first, release all entries from quic_keys */
        while (quic_keys.keys.size != 0)
            dispose_quic_keyset(quic_keys.keys.entries + --quic_keys.keys.size);

        /* build quic_keys while taking the read lock */
        pthread_rwlock_rdlock(&session_tickets.rwlock);
        assert(session_tickets.tickets.size != 0);
        h2o_vector_reserve(NULL, &quic_keys.keys, session_tickets.tickets.size);
        for (; quic_keys.keys.size != session_tickets.tickets.size; ++quic_keys.keys.size) {
            struct st_session_ticket_t *ticket = session_tickets.tickets.entries[quic_keys.keys.size];
            init_quic_keyset(
                quic_keys.keys.entries + quic_keys.keys.size, ticket->name[0],
                ptls_iovec_init(ticket->keybuf, EVP_CIPHER_key_length(ticket->cipher) + EVP_MD_block_size(ticket->hmac)));
        }
        pthread_rwlock_unlock(&session_tickets.rwlock);

        /* update our counter */
        quic_keys.generation = new_generation;
    }

    return quic_keys.keys.entries;
}
