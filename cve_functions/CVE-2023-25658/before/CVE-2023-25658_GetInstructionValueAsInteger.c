std::optional<DynamicOrStaticInteger> GetInstructionValueAsInteger(
    HloInstruction* instruction) {
  HloEvaluator evaluator;
  StatusOr<Literal> static_value = evaluator.Evaluate(
      instruction, /*recursively_evaluate_nonconstant_operands=*/true);
  if (static_value.ok()) {
    if (instruction->shape().element_type() == PrimitiveType::PRED) {
      return DynamicOrStaticInteger{
          static_cast<int64_t>(static_value->GetFirstElement<bool>())};
    } else {
      return DynamicOrStaticInteger{static_value->GetFirstInteger()};
    }
  }

  std::optional<EvalErrorDetail> eval_error_detail =
      ParseEvalErrorDetail(static_value.status());
  if (eval_error_detail.has_value() &&
      *eval_error_detail == EvalErrorDetail::kDynamicValueDependence) {
    return DynamicOrStaticInteger{std::nullopt};
  }
  return std::nullopt;
}
