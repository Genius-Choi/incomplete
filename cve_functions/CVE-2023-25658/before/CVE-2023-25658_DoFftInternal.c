bool ROCMFft::DoFftInternal(Stream *stream, fft::Plan *plan, FuncT hipfftExec,
                            const DeviceMemory<InputT> &input,
                            DeviceMemory<OutputT> *output) {
  ROCMFftPlan *rocm_fft_plan = dynamic_cast<ROCMFftPlan *>(plan);
  if (rocm_fft_plan == nullptr) {
    LOG(ERROR) << "the passed-in plan is not a ROCMFftPlan object.";
    return false;
  }

  if (!SetStream(parent_, rocm_fft_plan->GetPlan(), stream)) {
    return false;
  }

  // As per rocFFT documentation, input buffers may be overwritten during
  // execution of the C2R / D2Z transforms, even if the transform is not
  // in-place.
  // see rocFFT issue #298 for more info
  //
  // Same seems to apply for the R2C / Z2D transforms, as reported in
  // see ROCm TF issue # 1150
  //
  // Hence for all those transforms, copy the input buffer
  DeviceMemory<InputT> input_maybe_copy = input;
  if (input.opaque() != output->opaque() && (input.size() > 0)) {
    auto *allocator = rocm_fft_plan->GetScratchAllocator();
    if (allocator) {
      auto allocated = allocator->AllocateBytes(input.size());
      if (allocated.ok()) {
        if (stream->ThenMemcpy(&allocated.value(), input, input.size())
                .ok()) {
          input_maybe_copy = DeviceMemory<InputT>(allocated.value());
        } else {
          LOG(ERROR) << "failed to copy input buffer for rocFFT.";
        }
      }
    }
  }

  InputT *ip = const_cast<InputT *>(GpuMemory(input_maybe_copy));
  auto ret = hipfftExec(parent_, rocm_fft_plan->GetPlan(), GpuComplex(ip),
                        GpuComplex(GpuMemoryMutable(output)));

  if (ret != HIPFFT_SUCCESS) {
    LOG(ERROR) << "failed to run rocFFT routine: " << ret;
    return false;
  }

  return true;
}
