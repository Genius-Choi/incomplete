static pj_status_t update_factory_addr(struct tls_listener *listener,
				       const pjsip_host_port *addr_name)
{
    pj_status_t status = PJ_SUCCESS;
    pj_sockaddr *listener_addr = &listener->factory.local_addr;

    if (addr_name && addr_name->host.slen) {
	pj_sockaddr tmp;
	int af = pjsip_transport_type_get_af(listener->factory.type);

	status = pj_sockaddr_init(af, &tmp, &addr_name->host,
				  (pj_uint16_t)addr_name->port);
	if (status != PJ_SUCCESS || !pj_sockaddr_has_addr(&tmp) ||
	    (af == pj_AF_INET() && tmp.ipv4.sin_addr.s_addr == PJ_INADDR_NONE))
	{
	    /* Invalid address */
	    return PJ_EINVAL;
	}

	/* Copy the address */
	listener->factory.addr_name = *addr_name;
	pj_strdup(listener->factory.pool, &listener->factory.addr_name.host,
		  &addr_name->host);
	listener->factory.addr_name.port = addr_name->port;

    }
    else {
	/* No published address is given, use the bound address */

	/* If the address returns 0.0.0.0, use the default
	* interface address as the transport's address.
	*/
	if (!pj_sockaddr_has_addr(listener_addr)) {
	    pj_sockaddr hostip;

	    status = pj_gethostip(listener->bound_addr.addr.sa_family,
				  &hostip);
	    if (status != PJ_SUCCESS)
		return status;

	    pj_sockaddr_copy_addr(listener_addr, &hostip);
	}

	/* Save the address name */
	sockaddr_to_host_port(listener->factory.pool,
			      &listener->factory.addr_name, listener_addr);
    }

    /* If port is zero, get the bound port */
    if (listener->factory.addr_name.port == 0) {
	listener->factory.addr_name.port = pj_sockaddr_get_port(listener_addr);
    }

    pj_ansi_snprintf(listener->factory.obj_name,
		     sizeof(listener->factory.obj_name),
		     "tlstp:%d", listener->factory.addr_name.port);
    return status;
}
