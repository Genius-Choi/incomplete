static void tls_on_destroy(void *arg)
{
    struct tls_transport *tls = (struct tls_transport*)arg;

    if (tls->rdata.tp_info.pool) {
	pj_pool_secure_release(&tls->rdata.tp_info.pool);
    }

    if (tls->base.lock) {
	pj_lock_destroy(tls->base.lock);
	tls->base.lock = NULL;
    }

    if (tls->base.ref_cnt) {
	pj_atomic_destroy(tls->base.ref_cnt);
	tls->base.ref_cnt = NULL;
    }

    if (tls->base.pool) {
	if (tls->close_reason != PJ_SUCCESS) {
	    char errmsg[PJ_ERR_MSG_SIZE];

	    pj_strerror(tls->close_reason, errmsg, sizeof(errmsg));
	    PJ_LOG(4,(tls->base.obj_name, 
		      "TLS transport destroyed with reason %d: %s", 
		      tls->close_reason, errmsg));

	} else {

	    PJ_LOG(4,(tls->base.obj_name, 
		      "TLS transport destroyed normally"));

	}
	pj_pool_secure_release(&tls->base.pool);
    }
}
