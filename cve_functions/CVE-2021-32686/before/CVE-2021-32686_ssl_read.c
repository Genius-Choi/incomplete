static pj_status_t ssl_read(pj_ssl_sock_t *ssock, void *data, int *size)
{
    ossl_sock_t *ossock = (ossl_sock_t *)ssock;
    int size_ = *size;
    int len = size_;

    /* SSL_read() may write some data to write buffer when re-negotiation
     * is on progress, so let's protect it with write mutex.
     */
    pj_lock_acquire(ssock->write_mutex);
    *size = size_ = SSL_read(ossock->ossl_ssl, data, size_);
    pj_lock_release(ssock->write_mutex);

    if (size_ <= 0) {
	pj_status_t status;
	int err = SSL_get_error(ossock->ossl_ssl, size_);

	/* SSL might just return SSL_ERROR_WANT_READ in 
	 * re-negotiation.
	 */
	if (err != SSL_ERROR_NONE && err != SSL_ERROR_WANT_READ) {
	    if (err == SSL_ERROR_SYSCALL && size_ == -1 &&
		ERR_peek_error() == 0 && errno == 0)
	    {
		status = STATUS_FROM_SSL_ERR2("Read", ssock, size_,
					      err, len);
		PJ_LOG(4,("SSL", "SSL_read() = -1, with "
				 "SSL_ERROR_SYSCALL, no SSL error, "
				 "and errno = 0 - skip BIO error"));
		/* Ignore these errors */
	    } else {
		/* Reset SSL socket state, then return PJ_FALSE */
		status = STATUS_FROM_SSL_ERR2("Read", ssock, size_,
		        		      err, len);
		ssl_reset_sock_state(ssock);
		return status;
	    }
	}
	
	/* Need renegotiation */
	return PJ_EEOF;
    }

    return PJ_SUCCESS;
}
