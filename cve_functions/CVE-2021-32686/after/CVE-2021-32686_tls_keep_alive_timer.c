static void tls_keep_alive_timer(pj_timer_heap_t *th, pj_timer_entry *e)
{
    struct tls_transport *tls = (struct tls_transport*) e->user_data;
    pj_time_val delay;
    pj_time_val now;
    pj_ssize_t size;
    pj_status_t status;
    char addr[PJ_INET6_ADDRSTRLEN+10];    

    PJ_UNUSED_ARG(th);

    tls->ka_timer.id = PJ_TRUE;

    pj_gettimeofday(&now);
    PJ_TIME_VAL_SUB(now, tls->last_activity);

    if (now.sec > 0 && now.sec < pjsip_cfg()->tls.keep_alive_interval) {
	/* There has been activity, so don't send keep-alive */
	delay.sec = pjsip_cfg()->tls.keep_alive_interval - now.sec;
	delay.msec = 0;

	pjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, 
				   &delay);
	tls->ka_timer.id = PJ_TRUE;
	return;
    }

    PJ_LOG(5,(tls->base.obj_name, "Sending %d byte(s) keep-alive to %s", 
	      (int)tls->ka_pkt.slen, 
	      pj_addr_str_print(&tls->base.remote_name.host, 
				tls->base.remote_name.port, addr, 
				sizeof(addr), 1)));

    /* Send the data */
    size = tls->ka_pkt.slen;
    status = pj_ssl_sock_send(tls->ssock, &tls->ka_op_key.key,
			      tls->ka_pkt.ptr, &size, 0);

    if (status != PJ_SUCCESS && status != PJ_EPENDING) {
	tls_perror(tls->base.obj_name, 
		   "Error sending keep-alive packet", status,
		   &tls->remote_name);

	tls_init_shutdown(tls, status);
	return;
    }

    /* Register next keep-alive */
    delay.sec = pjsip_cfg()->tls.keep_alive_interval;
    delay.msec = 0;

    pjsip_endpt_schedule_timer(tls->base.endpt, &tls->ka_timer, 
			       &delay);
    tls->ka_timer.id = PJ_TRUE;
}
