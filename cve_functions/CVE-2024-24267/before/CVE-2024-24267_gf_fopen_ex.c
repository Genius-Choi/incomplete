FILE *gf_fopen_ex(const char *file_name, const char *parent_name, const char *mode, Bool no_warn)
{
	FILE *res = NULL;
	u32 gfio_type = 0;
	Bool is_mkdir = GF_FALSE;

	if (!file_name || !mode) return NULL;
	if (!strcmp(mode, "mkdir")) {
		is_mkdir = GF_TRUE;
		mode = "w";
	}

	if (!strncmp(file_name, "gmem://", 7)) {
		GF_FileIO *new_gfio;
		if (strstr(mode, "w"))
			return NULL;
		new_gfio = gf_fileio_from_blob(file_name);
		if (new_gfio)
			gf_register_file_handle((char*)file_name, (FILE *) new_gfio, GF_FALSE);
		return (FILE *) new_gfio;

	}

	if (!strncmp(file_name, "gfio://", 7))
		gfio_type = 1;
	else if (parent_name && !strncmp(parent_name, "gfio://", 7))
		gfio_type = 2;

	if (gfio_type) {
		GF_FileIO *gfio_ref;
		GF_FileIO *new_gfio;
		GF_Err e;
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, ("[Core] Open GFIO %s in mode %s\n", file_name, mode));

		if (gfio_type==1)
			gfio_ref = gf_fileio_from_url(file_name);
		else
			gfio_ref = gf_fileio_from_url(parent_name);

		if (!gfio_ref) return NULL;
		if (strchr(mode, 'r') && !gf_fileio_read_mode(gfio_ref)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("FileIO %s is not read-enabled and open mode %s was requested\n", file_name, mode));
			return NULL;
		}
		if ((strchr(mode, 'w') || strchr(mode, 'a'))  && !gf_fileio_write_mode(gfio_ref)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("FileIO %s is not write-enabled and open mode %s was requested\n", file_name, mode));
			return NULL;
		}
		new_gfio = gf_fileio_open_url(gfio_ref, file_name, mode, &e);
		if (e) {
			if (!no_warn) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("FileIO %s open in mode %s failed: %s\n", file_name, mode, gf_error_to_string(e)));
			}
			return NULL;
		}
		if (new_gfio)
			gf_register_file_handle((char*)file_name, (FILE *) new_gfio, GF_FALSE);
		return (FILE *) new_gfio;
	}

	GF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, ("[Core] Open file %s in mode %s\n", file_name, mode));
	if (strchr(mode, 'w')) {
		char *fname = gf_strdup(file_name);
		char *sep = strchr(fname, '/');
		if (!sep) sep = strchr(fname, '\\');
		if (file_name[0] == '/') sep = strchr(fname+1, '/');
		else if (file_name[2] == '\\') sep = strchr(fname+3, '\\');

		while (sep) {
			char *n_sep;
			char c = sep[0];
			sep[0] = 0;
			if (!gf_dir_exists(fname)) {
				GF_Err e = gf_mkdir(fname);
				if (e != GF_OK) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[Core] Failed to create directory \"%s\": %s\n", file_name, gf_error_to_string(e) ));
					sep[0] = c;
					gf_free(fname);
					return NULL;
				}
			}
			sep[0] = c;
			n_sep = strchr(sep+1, '/');
			if (!n_sep) n_sep = strchr(sep+1, '\\');
			sep = n_sep;
		}
		gf_free(fname);
		if (is_mkdir) return NULL;
	}

#ifdef GPAC_CONFIG_EMSCRIPTEN
	if (mainloop_th_id && strchr(mode, 'r') && (gf_th_id() != mainloop_th_id)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[Core] Opening file in read mode outside of main loop will likely deadlock - please report to GPAC devs\n"));
	}
#endif

#if defined(WIN32)
	wchar_t *wname;
	wchar_t *wmode;

	wname = gf_utf8_to_wcs(file_name);
	wmode = gf_utf8_to_wcs(mode);
	if (!wname || !wmode)
	{
		if (wname) gf_free(wname);
		if (wmode) gf_free(wmode);
		return NULL;
	}
	res = _wfsopen(wname, wmode, _SH_DENYNO);
	gf_free(wname);
	gf_free(wmode);
#elif defined(GPAC_CONFIG_LINUX) && !defined(GPAC_CONFIG_ANDROID)
	res = fopen64(file_name, mode);
#elif (defined(GPAC_CONFIG_FREEBSD) || defined(GPAC_CONFIG_DARWIN))
	res = fopen(file_name, mode);
#else
	res = fopen(file_name, mode);
#endif

	if (res) {
		if (!parent_name || strcmp(parent_name, "__temp_file"))
			gf_register_file_handle((char*)file_name, res, GF_FALSE);

		GF_LOG(GF_LOG_DEBUG, GF_LOG_CORE, ("[Core] file \"%s\" opened in mode \"%s\" - %d file handles\n", file_name, mode, gpac_file_handles));
	} else if (!no_warn) {
		if (strchr(mode, 'w') || strchr(mode, 'a')) {
#if defined(WIN32)
			u32 err = GetLastError();
			GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[Core] system failure for file opening of \"%s\" in mode \"%s\": 0x%08x\n", file_name, mode, err));
#else
			GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[Core] system failure for file opening of \"%s\" in mode \"%s\": %d\n", file_name, mode, errno));
#endif
		}
	}
	return res;
}
