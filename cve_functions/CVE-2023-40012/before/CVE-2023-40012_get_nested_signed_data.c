std::optional<SignedData> SignedData::get_nested_signed_data() const {
  PKCS7_SIGNER_INFO *signer_info = sk_PKCS7_SIGNER_INFO_value(p7_->d.sign->signer_info, 0);

  /* NOTE(ww): OpenSSL stupidity: you actually need to call OBJ_create before
   * OBJ_txt2obj; the latter won't do it for you. Luckily (?) OpenSSL 1.1.0+
   * auto-frees these, so they're not totally impossible to use in leakless C++.
   */
  OBJ_create(impl::SPC_NESTED_SIGNATURE_OID, NULL, NULL);
  auto *spc_nested_sig_oid_ptr = OBJ_txt2obj(impl::SPC_NESTED_SIGNATURE_OID, 1);
  if (spc_nested_sig_oid_ptr == nullptr) {
    return std::nullopt;
  }
  impl::ASN1_OBJECT_ptr spc_nested_sig_oid(spc_nested_sig_oid_ptr, ASN1_OBJECT_free);

  auto *nested_signed_data =
      PKCS7_get_attribute(signer_info, OBJ_obj2nid(spc_nested_sig_oid.get()));
  if (nested_signed_data == nullptr) {
    return std::nullopt;
  }

  if (ASN1_TYPE_get(nested_signed_data) != V_ASN1_SEQUENCE) {
    return std::nullopt;
  }

  auto *nested_signed_data_seq = nested_signed_data->value.sequence;
  std::vector<std::uint8_t> cert_buf(nested_signed_data_seq->data,
                                     nested_signed_data_seq->data + nested_signed_data_seq->length);

  return std::make_optional<SignedData>(cert_buf);
}
