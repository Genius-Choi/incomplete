static Bool isoffin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)
{
	u32 count, i;
	Bool is_byte_range;
	Bool cancel_event = GF_TRUE;
	Double start_range, speed;
	ISOMChannel *ch, *ref_ch;
	ISOMReader *read = gf_filter_get_udta(filter);

	if (!read || read->disconnected) return GF_FALSE;

	if (evt->base.type == GF_FEVT_QUALITY_SWITCH) {
		count = gf_list_count(read->channels);
		for (i = 0; i < count; i++) {
			ch = (ISOMChannel *)gf_list_get(read->channels, i);
			if (ch->base_track && gf_isom_needs_layer_reconstruction(read->mov)) {
				/*ch->next_track = */ //old code, see not in isoffin_reconfigure
				isoffin_channel_switch_quality(ch, read->mov, evt->quality_switch.up);
			}
		}
		return GF_TRUE;
	}

	if (!evt->base.on_pid) return GF_FALSE;

	ch = isor_get_channel(read, evt->base.on_pid);
	if (!ch)
		return GF_FALSE;

	switch (evt->base.type) {
	case GF_FEVT_PLAY:
		if (ch->skip_next_play) {
			ch->skip_next_play = 0;
			return GF_TRUE;
		}
		is_byte_range = (evt->play.hint_start_offset || evt->play.hint_end_offset) ? GF_TRUE : GF_FALSE;

		isor_reset_reader(ch);
		ch->eos_sent = 0;
		ch->speed = is_byte_range ? 1 : evt->play.speed;
		ch->initial_play_seen = 1;
		read->reset_frag_state = 1;
		//it can happen that input_is_stop is still TRUE because we did not get called back after the stop - reset to FALSE since we now play
		read->input_is_stop = GF_FALSE;
		if (read->frag_type)
			read->frag_type = 1;

		ch->start = ch->end = 0;
		start_range = is_byte_range ? 0 : evt->play.start_range;
		speed = ch->speed;
		//compute closest range if channel was disconnected
		if (read->nb_playing && ch->midrun_tune) {
			ref_ch = NULL;
			count = gf_list_count(read->channels);
			for (i = 0; i < count; i++) {
				ISOMChannel *ach = (ISOMChannel *)gf_list_get(read->channels, i);
				if (!ach->playing) continue;
				//check sync ID if multiple timelines
				if (ach->clock_id != ch->clock_id) continue;
				ref_ch = ach;
				break;
			}
			//we have a ref, if computed last sample clock is 1s greater than start range of channel, use current time
			if (ref_ch && ref_ch->timescale) {
				Double diff, orig_range = ref_ch->orig_start;
				speed = ref_ch->speed;
				if (ref_ch->has_edit_list) {
					start_range = (Double) ref_ch->sample_time;
				} else {
					start_range = (Double) ref_ch->cts;
				}
				start_range /= ref_ch->timescale;
				diff = orig_range - start_range;
				if (ABS(diff)<1.0)
					start_range = orig_range;
			}
		}
		if (!is_byte_range) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[IsoMedia] channel start is %f - requested %f\n", start_range, evt->play.start_range));

			if (speed>=0) {
				Double t;
				if (start_range>=0) {
					t = start_range;
					t *= ch->timescale;
					ch->start = (u64) t;
				}
				if (evt->play.end_range >= start_range) {
					ch->end = (u64) -1;
					if (evt->play.end_range<FLT_MAX) {
						t = evt->play.end_range;
						t *= ch->timescale;
						ch->end = (u64) t;
					}
				}
			} else {
				Double end = evt->play.end_range;
				if (end==-1) end = 0;
				ch->start = (u64) (s64) (start_range * ch->timescale);
				if (end <= start_range)
					ch->end = (u64) (s64) (end  * ch->timescale);
			}
			ch->sample_num = evt->play.from_pck;
			ch->sample_last = evt->play.to_pck;
			ch->sap_only = evt->play.drop_non_ref ? 1 : 0;

			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[IsoMedia] Starting channel playback "LLD" to "LLD" (%g to %g)\n", ch->start, ch->end, start_range, evt->play.end_range));
		} else {
			ch->end = 0;
			ch->sample_num = 0;
			ch->sample_last = 0;
			ch->sap_only = 0;
		}
		ch->orig_start = start_range;
		ch->playing = 1;

#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
		if (!read->nb_playing)
			gf_isom_reset_seq_num(read->mov);
#endif
		if (read->is_partial_download) read->input_loaded = GF_FALSE;

		if (is_byte_range) {
			if (!read->frag_type) {
				return GF_TRUE;
			}
			if (read->mem_load_mode) {
				GF_FilterEvent fevt;
				//new segment will be loaded, reset
				gf_isom_reset_tables(read->mov, GF_TRUE);
				gf_isom_reset_data_offset(read->mov, NULL);
				read->refresh_fragmented = GF_TRUE;
				read->mem_blob.size = 0;

				read->bytes_removed = evt->play.hint_start_offset;

				//send a seek request
				read->is_partial_download = GF_TRUE;
				read->wait_for_source = GF_TRUE;
				read->refresh_fragmented = GF_TRUE;

				GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, read->pid);
				fevt.seek.start_offset = read->bytes_removed;
				gf_filter_pid_send_event(read->pid, &fevt);

				gf_isom_set_removed_bytes(read->mov, read->bytes_removed);
				gf_isom_set_byte_offset(read->mov, 0);
			} else {
				GF_Err gf_isom_load_fragments(GF_ISOFile *movie, u64 start_range, u64 end_range, u64 *BytesMissing);
				gf_isom_load_fragments(read->mov, evt->play.hint_start_offset, evt->play.hint_end_offset, &read->missing_bytes);
				ch->hint_first_tfdt = evt->play.hint_first_dts;
			}
		} else if (evt->play.no_byterange_forward) {
			//new segment will be loaded, reset
			gf_isom_reset_tables(read->mov, GF_TRUE);
			gf_isom_reset_data_offset(read->mov, NULL);
			read->refresh_fragmented = GF_TRUE;
			read->mem_blob.size = 0;
			//send play event
			cancel_event = GF_FALSE;
		} else if (!read->nb_playing && read->pid && !read->input_loaded) {
			GF_FilterEvent fevt;
			Bool is_sidx_seek = GF_FALSE;
			u64 max_offset = GF_FILTER_NO_BO;
			count = gf_list_count(read->channels);

			//try sidx
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
			if (read->frag_type) {
				u32 ts;
				u64 dur=0;
				GF_Err e = gf_isom_get_file_offset_for_time(read->mov, evt->play.start_range, &max_offset);
				if (e==GF_OK) {
					if (evt->play.start_range>0)
						gf_isom_reset_tables(read->mov, GF_TRUE);

					is_sidx_seek = GF_TRUE;
					//in case we loaded moov but not sidx, update duration
					if ((gf_isom_get_sidx_duration(read->mov, &dur, &ts)==GF_OK) && dur) {
						dur = gf_timestamp_rescale(dur, ts, read->timescale);
						if (ch->duration != dur) {
							ch->duration = dur;
							gf_filter_pid_set_property(ch->pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));
						}
					}
				}
			}
#endif
			if (!is_sidx_seek) {
				for (i=0; i< count; i++) {
					u32 mode, sample_desc_index, sample_num;
					u64 data_offset;
					GF_Err e;
					u64 time;
					ch = gf_list_get(read->channels, i);
					mode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;
					time = (u64) (evt->play.start_range * ch->timescale);

					/*take care of seeking out of the track range*/
					if (!read->frag_type && (ch->duration < time)) {
						e = gf_isom_get_sample_for_movie_time(read->mov, ch->track, ch->duration, 	&sample_desc_index, mode, NULL, &sample_num, &data_offset);
					} else {
						e = gf_isom_get_sample_for_movie_time(read->mov, ch->track, time, &sample_desc_index, mode, NULL, &sample_num, &data_offset);
					}
					if ((e == GF_OK) && (data_offset<max_offset))
						max_offset = data_offset;
				}
			}

			if ((evt->play.start_range || read->is_partial_download)  && (max_offset != GF_FILTER_NO_BO) ) {
				//send a seek request
				read->is_partial_download = GF_TRUE;
				read->wait_for_source = GF_TRUE;
				read->refresh_fragmented = GF_TRUE;

				GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, read->pid);
				fevt.seek.start_offset = max_offset;
				gf_filter_pid_send_event(read->pid, &fevt);

				if (read->mem_load_mode) {
					read->mem_blob.size = 0;
					read->bytes_removed = max_offset;
					gf_isom_set_removed_bytes(read->mov, read->bytes_removed);
					gf_isom_set_byte_offset(read->mov, 0);
				} else {
					gf_isom_set_byte_offset(read->mov, is_sidx_seek ? 0 : max_offset);
				}
			}
		}


		read->nb_playing++;
		//trigger play on all "disconnected" channels
		if ((read->nb_playing>1) && !ch->midrun_tune) {
			count = gf_list_count(read->channels);
			for (i=0; i<count;i++) {
				ISOMChannel *ach = gf_list_get(read->channels, i);
				//locate disconnected channels playing
				if (ach == ch) continue;
				if (ach->clock_id != ch->clock_id) continue;
				if (!ach->playing || !ach->timescale || !ach->midrun_tune) continue;
				isor_reset_reader(ach);
				ach->playing = 1;
				ach->sample_num = 0;
				ach->start = gf_timestamp_rescale(ch->start, ch->timescale, ach->timescale);
				ach->orig_start = ch->orig_start;
				ach->start = (u64) (ach->orig_start * ach->timescale);
				ach->eos_sent = 0;
				ach->speed = is_byte_range ? 1 : evt->play.speed;
				ach->initial_play_seen = 1;
				ach->skip_next_play = 1;
				ach->set_disc = 1;
			}
		}

		//always request a process task upon a play
		gf_filter_post_process_task(read->filter);
		//cancel event unless dash mode
		return cancel_event;

	case GF_FEVT_STOP:
 		if (read->nb_playing) read->nb_playing--;
		isor_reset_reader(ch);

		//stop is due to a deconnection, mark channel as not active
		if (evt->play.initial_broadcast_play==2)
			ch->midrun_tune = 1;
		else
			ch->midrun_tune = 0;

		//don't send a stop if some of our channels are still waiting for initial play
		for (i=0; i<gf_list_count(read->channels); i++) {
			ISOMChannel *a_ch = gf_list_get(read->channels, i);
			if (ch==a_ch) continue;
			if (!a_ch->initial_play_seen) return GF_TRUE;
		}
		ch->skip_next_play = 0;
		//cancel event if nothing playing
		if (read->nb_playing) return GF_TRUE;
		read->input_is_stop = GF_TRUE;
		return GF_FALSE;

	case GF_FEVT_SET_SPEED:
	case GF_FEVT_RESUME:
		ch->speed = evt->play.speed;
		if (ch->sap_only && !evt->play.drop_non_ref) {
			ch->sap_only = 2;
		} else {
			ch->sap_only = evt->play.drop_non_ref ? 1 : 0;
		}
		//cancel event
		return GF_TRUE;
	default:
		break;
	}
	//by default don't cancel event
	return GF_FALSE;
}
