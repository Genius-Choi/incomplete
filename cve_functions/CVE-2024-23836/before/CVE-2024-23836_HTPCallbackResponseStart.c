static int HTPCallbackResponseStart(htp_tx_t *tx)
{
    HtpState *hstate = htp_connp_get_user_data(tx->connp);
    if (hstate == NULL) {
        SCReturnInt(HTP_ERROR);
    }

    uint64_t consumed = hstate->slice->offset + htp_connp_res_data_consumed(hstate->connp);
    SCLogDebug("HTTP response start: data offset %" PRIu64 ", out_data_counter %" PRIu64, consumed,
            (uint64_t)hstate->conn->out_data_counter);

    Frame *frame = AppLayerFrameNewByAbsoluteOffset(
            hstate->f, hstate->slice, consumed, -1, 1, HTTP_FRAME_RESPONSE);
    if (frame) {
        SCLogDebug("frame %p/%" PRIi64, frame, frame->id);
        hstate->response_frame_id = frame->id;
        AppLayerFrameSetTxId(frame, HtpGetActiveResponseTxID(hstate));
    }

    if (hstate->cfg)
        StreamTcpReassemblySetMinInspectDepth(hstate->f->protoctx, STREAM_TOCLIENT,
                hstate->cfg->response.inspect_min_size);

    HtpTxUserData *tx_ud = (HtpTxUserData *) htp_tx_get_user_data(tx);
    if (tx_ud == NULL) {
        tx_ud = HTPCalloc(1, sizeof(HtpTxUserData));
        if (unlikely(tx_ud == NULL)) {
            SCReturnInt(HTP_OK);
        }
        tx_ud->tx_data.file_tx =
                STREAM_TOCLIENT; // each http tx may xfer files. Toserver already missed.
        htp_tx_set_user_data(tx, tx_ud);
    }
    SCReturnInt(HTP_OK);
}
