static int HTPCallbackRequestBodyData(htp_tx_data_t *d)
{
    SCEnter();

    if (!(SC_ATOMIC_GET(htp_config_flags) & HTP_REQUIRE_REQUEST_BODY))
        SCReturnInt(HTP_OK);

    if (d->len == 0)
        SCReturnInt(HTP_OK);

#ifdef PRINT
    printf("HTPBODY START: \n");
    PrintRawDataFp(stdout, (uint8_t *)d->data, d->len);
    printf("HTPBODY END: \n");
#endif

    HtpState *hstate = htp_connp_get_user_data(d->tx->connp);
    if (hstate == NULL) {
        SCReturnInt(HTP_ERROR);
    }

    SCLogDebug("New request body data available at %p -> %p -> %p, bodylen "
               "%"PRIu32"", hstate, d, d->data, (uint32_t)d->len);

    HtpTxUserData *tx_ud = (HtpTxUserData *) htp_tx_get_user_data(d->tx);
    if (tx_ud == NULL) {
        SCReturnInt(HTP_OK);
    }
    tx_ud->tx_data.file_flags |= hstate->state_data.file_flags;

    if (!tx_ud->response_body_init) {
        tx_ud->response_body_init = 1;

        if (d->tx->request_method_number == HTP_M_POST) {
            SCLogDebug("POST");
            int r = HtpRequestBodySetupMultipart(d->tx, tx_ud);
            if (r == 1) {
                tx_ud->request_body_type = HTP_BODY_REQUEST_MULTIPART;
            } else if (r == 0) {
                tx_ud->request_body_type = HTP_BODY_REQUEST_POST;
                SCLogDebug("not multipart");
            }
        } else if (d->tx->request_method_number == HTP_M_PUT) {
            tx_ud->request_body_type = HTP_BODY_REQUEST_PUT;
        }
    }

    /* see if we can get rid of htp body chunks */
    HtpBodyPrune(hstate, &tx_ud->request_body, STREAM_TOSERVER);

    SCLogDebug("tx_ud->request_body.content_len_so_far %"PRIu64, tx_ud->request_body.content_len_so_far);
    SCLogDebug("hstate->cfg->request.body_limit %u", hstate->cfg->request.body_limit);

    /* within limits, add the body chunk to the state. */
    if (AppLayerHtpCheckDepth(&hstate->cfg->request, &tx_ud->request_body, tx_ud->tsflags)) {
        uint32_t stream_depth = FileReassemblyDepth();
        uint32_t len = AppLayerHtpComputeChunkLength(tx_ud->request_body.content_len_so_far,
                                                     hstate->cfg->request.body_limit,
                                                     stream_depth,
                                                     tx_ud->tsflags,
                                                     (uint32_t)d->len);
        BUG_ON(len > (uint32_t)d->len);

        HtpBodyAppendChunk(&hstate->cfg->request, &tx_ud->request_body, d->data, len);

        const uint8_t *chunks_buffer = NULL;
        uint32_t chunks_buffer_len = 0;

        if (tx_ud->request_body_type == HTP_BODY_REQUEST_MULTIPART) {
            /* multi-part body handling starts here */
            if (!(tx_ud->tsflags & HTP_BOUNDARY_SET)) {
                goto end;
            }

            HtpRequestBodyReassemble(tx_ud, &chunks_buffer, &chunks_buffer_len);
            if (chunks_buffer == NULL) {
                goto end;
            }
#ifdef PRINT
            printf("REASSCHUNK START: \n");
            PrintRawDataFp(stdout, chunks_buffer, chunks_buffer_len);
            printf("REASSCHUNK END: \n");
#endif

            HtpRequestBodyHandleMultipart(hstate, tx_ud, d->tx, chunks_buffer, chunks_buffer_len);

        } else if (tx_ud->request_body_type == HTP_BODY_REQUEST_POST ||
                   tx_ud->request_body_type == HTP_BODY_REQUEST_PUT) {
            HtpRequestBodyHandlePOSTorPUT(hstate, tx_ud, d->tx, (uint8_t *)d->data, len);
        }

    } else {
        if (tx_ud->tsflags & HTP_FILENAME_SET) {
            SCLogDebug("closing file that was being stored");
            (void)HTPFileClose(hstate, tx_ud, NULL, 0, FILE_TRUNCATED, STREAM_TOSERVER);
            tx_ud->tsflags &= ~HTP_FILENAME_SET;
        }
    }

end:
    if (hstate->conn != NULL) {
        SCLogDebug("checking body size %"PRIu64" against inspect limit %u (cur %"PRIu64", last %"PRIu64")",
                tx_ud->request_body.content_len_so_far,
                hstate->cfg->request.inspect_min_size,
                (uint64_t)hstate->conn->in_data_counter, hstate->last_request_data_stamp);

        /* if we reach the inspect_min_size we'll trigger inspection,
         * so make sure that raw stream is also inspected. Set the
         * data to be used to the amount of raw bytes we've seen to
         * get here. */
        if (tx_ud->request_body.body_inspected == 0 &&
            tx_ud->request_body.content_len_so_far >= hstate->cfg->request.inspect_min_size) {
            if ((uint64_t)hstate->conn->in_data_counter > hstate->last_request_data_stamp &&
                (uint64_t)hstate->conn->in_data_counter - hstate->last_request_data_stamp < (uint64_t)UINT_MAX)
            {
                const uint32_t data_size = (uint32_t)(
                        (uint64_t)hstate->conn->in_data_counter - hstate->last_request_data_stamp);
                const uint32_t depth = MIN(data_size, hstate->cfg->request.inspect_min_size);

                /* body still in progress, but due to min inspect size we need to inspect now */
                StreamTcpReassemblySetMinInspectDepth(hstate->f->protoctx, STREAM_TOSERVER, depth);
                AppLayerParserTriggerRawStreamReassembly(hstate->f, STREAM_TOSERVER);
            }
        /* after the start of the body, disable the depth logic */
        } else if (tx_ud->request_body.body_inspected > 0) {
            StreamTcpReassemblySetMinInspectDepth(hstate->f->protoctx, STREAM_TOSERVER, 0);
        }
    }
    SCReturnInt(HTP_OK);
}
