static int HTPCallbackResponseBodyData(htp_tx_data_t *d)
{
    SCEnter();

    if (!(SC_ATOMIC_GET(htp_config_flags) & HTP_REQUIRE_RESPONSE_BODY))
        SCReturnInt(HTP_OK);

    if (d->len == 0)
        SCReturnInt(HTP_OK);

    HtpState *hstate = htp_connp_get_user_data(d->tx->connp);
    if (hstate == NULL) {
        SCReturnInt(HTP_ERROR);
    }

    SCLogDebug("New response body data available at %p -> %p -> %p, bodylen "
               "%"PRIu32"", hstate, d, d->data, (uint32_t)d->len);

    HtpTxUserData *tx_ud = (HtpTxUserData *) htp_tx_get_user_data(d->tx);
    if (tx_ud == NULL) {
        SCReturnInt(HTP_OK);
    }
    tx_ud->tx_data.file_flags |= hstate->state_data.file_flags;
    if (!tx_ud->request_body_init) {
        tx_ud->request_body_init = 1;
    }

    /* see if we can get rid of htp body chunks */
    HtpBodyPrune(hstate, &tx_ud->response_body, STREAM_TOCLIENT);

    SCLogDebug("tx_ud->response_body.content_len_so_far %"PRIu64, tx_ud->response_body.content_len_so_far);
    SCLogDebug("hstate->cfg->response.body_limit %u", hstate->cfg->response.body_limit);

    /* within limits, add the body chunk to the state. */
    if (AppLayerHtpCheckDepth(&hstate->cfg->response, &tx_ud->response_body, tx_ud->tcflags)) {
        uint32_t stream_depth = FileReassemblyDepth();
        uint32_t len = AppLayerHtpComputeChunkLength(tx_ud->response_body.content_len_so_far,
                                                     hstate->cfg->response.body_limit,
                                                     stream_depth,
                                                     tx_ud->tcflags,
                                                     (uint32_t)d->len);
        BUG_ON(len > (uint32_t)d->len);

        HtpBodyAppendChunk(&hstate->cfg->response, &tx_ud->response_body, d->data, len);

        HtpResponseBodyHandle(hstate, tx_ud, d->tx, (uint8_t *)d->data, len);
    } else {
        if (tx_ud->tcflags & HTP_FILENAME_SET) {
            SCLogDebug("closing file that was being stored");
            (void)HTPFileClose(hstate, tx_ud, NULL, 0, FILE_TRUNCATED, STREAM_TOCLIENT);
            tx_ud->tcflags &= ~HTP_FILENAME_SET;
        }
    }

    if (hstate->conn != NULL) {
        SCLogDebug("checking body size %"PRIu64" against inspect limit %u (cur %"PRIu64", last %"PRIu64")",
                tx_ud->response_body.content_len_so_far,
                hstate->cfg->response.inspect_min_size,
                (uint64_t)hstate->conn->in_data_counter, hstate->last_response_data_stamp);
        /* if we reach the inspect_min_size we'll trigger inspection,
         * so make sure that raw stream is also inspected. Set the
         * data to be used to the amount of raw bytes we've seen to
         * get here. */
        if (tx_ud->response_body.body_inspected == 0 &&
            tx_ud->response_body.content_len_so_far >= hstate->cfg->response.inspect_min_size) {
            if ((uint64_t)hstate->conn->out_data_counter > hstate->last_response_data_stamp &&
                (uint64_t)hstate->conn->out_data_counter - hstate->last_response_data_stamp < (uint64_t)UINT_MAX)
            {
                const uint32_t data_size = (uint32_t)((uint64_t)hstate->conn->out_data_counter -
                                                      hstate->last_response_data_stamp);
                const uint32_t depth = MIN(data_size, hstate->cfg->response.inspect_min_size);

                /* body still in progress, but due to min inspect size we need to inspect now */
                StreamTcpReassemblySetMinInspectDepth(hstate->f->protoctx, STREAM_TOCLIENT, depth);
                AppLayerParserTriggerRawStreamReassembly(hstate->f, STREAM_TOCLIENT);
            }
        /* after the start of the body, disable the depth logic */
        } else if (tx_ud->response_body.body_inspected > 0) {
            StreamTcpReassemblySetMinInspectDepth(hstate->f->protoctx, STREAM_TOCLIENT, 0);
        }
    }
    SCReturnInt(HTP_OK);
}
