static int HTPCallbackResponseComplete(htp_tx_t *tx)
{
    SCEnter();

    HtpState *hstate = htp_connp_get_user_data(tx->connp);
    if (hstate == NULL) {
        SCReturnInt(HTP_ERROR);
    }

    /* we have one whole transaction now */
    hstate->transaction_cnt++;

    const uint64_t abs_right_edge =
            hstate->slice->offset + htp_connp_res_data_consumed(hstate->connp);

    if (hstate->response_frame_id > 0) {
        Frame *frame = AppLayerFrameGetById(hstate->f, 1, hstate->response_frame_id);
        if (frame) {
            const uint64_t response_size = abs_right_edge - hstate->last_response_data_stamp;

            SCLogDebug("HTTP response complete: data offset %" PRIu64 ", response_size %" PRIu64,
                    hstate->last_response_data_stamp, response_size);
            SCLogDebug("frame %p/%" PRIi64 " setting len to  %" PRIu64, frame, frame->id,
                    response_size);
            frame->len = (int64_t)response_size;
        }
        hstate->response_frame_id = 0;
    }

    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);
    if (htud != NULL) {
        if (htud->tcflags & HTP_FILENAME_SET) {
            SCLogDebug("closing file that was being stored");
            (void)HTPFileClose(hstate, htud, NULL, 0, 0, STREAM_TOCLIENT);
            htud->tcflags &= ~HTP_FILENAME_SET;
        }
    }

    /* response done, do raw reassembly now to inspect state and stream
     * at the same time. */
    AppLayerParserTriggerRawStreamReassembly(hstate->f, STREAM_TOCLIENT);

    /* handle HTTP CONNECT */
    if (tx->request_method_number == HTP_M_CONNECT) {
        /* any 2XX status response implies that the connection will become
           a tunnel immediately after this packet (RFC 7230, 3.3.3). */
        if ((tx->response_status_number >= 200) &&
                (tx->response_status_number < 300) &&
                (hstate->transaction_cnt == 1)) {
            uint16_t dp = 0;
            if (tx->request_port_number != -1) {
                dp = (uint16_t)tx->request_port_number;
            }
            // both ALPROTO_HTTP1 and ALPROTO_TLS are normal options
            if (!AppLayerRequestProtocolChange(hstate->f, dp, ALPROTO_UNKNOWN)) {
                HTPSetEvent(
                        hstate, htud, STREAM_TOCLIENT, HTTP_DECODER_EVENT_FAILED_PROTOCOL_CHANGE);
            }
            tx->request_progress = HTP_REQUEST_COMPLETE;
            tx->response_progress = HTP_RESPONSE_COMPLETE;
        }
    }

    hstate->last_response_data_stamp = abs_right_edge;
    SCReturnInt(HTP_OK);
}
