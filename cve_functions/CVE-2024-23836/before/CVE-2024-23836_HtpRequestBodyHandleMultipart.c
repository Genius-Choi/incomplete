static int HtpRequestBodyHandleMultipart(HtpState *hstate, HtpTxUserData *htud, void *tx,
        const uint8_t *chunks_buffer, uint32_t chunks_buffer_len)
{
    int result = 0;
    uint8_t boundary[htud->boundary_len + 4]; /**< size limited to HTP_BOUNDARY_MAX + 4 */
    uint16_t expected_boundary_len = htud->boundary_len + 2;
    uint16_t expected_boundary_end_len = htud->boundary_len + 4;
    int tx_progress = 0;

#ifdef PRINT
    printf("CHUNK START: \n");
    PrintRawDataFp(stdout, chunks_buffer, chunks_buffer_len);
    printf("CHUNK END: \n");
#endif

    HtpRequestBodySetupBoundary(htud, boundary, htud->boundary_len + 4);

    /* search for the header start, header end and form end */
    const uint8_t *header_start = Bs2bmSearch(chunks_buffer, chunks_buffer_len,
            boundary, expected_boundary_len);
    /* end of the multipart form */
    const uint8_t *form_end = NULL;
    /* end marker belonging to header_start */
    const uint8_t *header_end = NULL;
    if (header_start != NULL) {
        header_end = Bs2bmSearch(header_start, chunks_buffer_len - (header_start - chunks_buffer),
                (uint8_t *)"\r\n\r\n", 4);
        form_end = Bs2bmSearch(header_start, chunks_buffer_len - (header_start - chunks_buffer),
                boundary, expected_boundary_end_len);
    }

    SCLogDebug("header_start %p, header_end %p, form_end %p", header_start,
            header_end, form_end);

    /* we currently only handle multipart for ts.  When we support it for tc,
     * we will need to supply right direction */
    tx_progress = AppLayerParserGetStateProgress(IPPROTO_TCP, ALPROTO_HTTP1, tx, STREAM_TOSERVER);
    /* if we're in the file storage process, deal with that now */
    if (htud->tsflags & HTP_FILENAME_SET) {
        if (header_start != NULL || (tx_progress > HTP_REQUEST_BODY)) {
            SCLogDebug("reached the end of the file");

            const uint8_t *filedata = chunks_buffer;
            uint32_t filedata_len = 0;
            uint8_t flags = 0;

            if (header_start != NULL) {
                if (header_start == filedata + 2) {
                    /* last chunk had all data, but not the boundary */
                    SCLogDebug("last chunk had all data, but not the boundary");
                    filedata_len = 0;
                } else if (header_start > filedata + 2) {
                    SCLogDebug("some data from last file before the boundary");
                    /* some data from last file before the boundary */
                    filedata_len = header_start - filedata - 2;
                }
            }
            /* body parsing done, we did not get our form end. Use all data
             * we still have and signal to files API we have an issue. */
            if (tx_progress > HTP_REQUEST_BODY) {
                filedata_len = chunks_buffer_len;
                flags = FILE_TRUNCATED;
            }

            if (filedata_len > chunks_buffer_len) {
                HTPSetEvent(hstate, htud, STREAM_TOSERVER,
                        HTTP_DECODER_EVENT_MULTIPART_GENERIC_ERROR);
                goto end;
            }
#ifdef PRINT
            printf("FILEDATA (final chunk) START: \n");
            PrintRawDataFp(stdout, filedata, filedata_len);
            printf("FILEDATA (final chunk) END: \n");
#endif
            if (!(htud->tsflags & HTP_DONTSTORE)) {
                if (HTPFileClose(hstate, htud, filedata, filedata_len, flags, STREAM_TOSERVER) ==
                        -1) {
                    goto end;
                }
            }

            htud->tsflags &=~ HTP_FILENAME_SET;

            /* fall through */
        } else {
            SCLogDebug("not yet at the end of the file");

            if (chunks_buffer_len > expected_boundary_end_len) {
                const uint8_t *filedata = chunks_buffer;
                uint32_t filedata_len = chunks_buffer_len - expected_boundary_len;
                for (; filedata_len < chunks_buffer_len; filedata_len++) {
                    // take as much as we can until the beginning of a new line
                    if (chunks_buffer[filedata_len] == '\r') {
                        if (filedata_len + 1 == chunks_buffer_len ||
                                chunks_buffer[filedata_len + 1] == '\n') {
                            break;
                        }
                    }
                }

#ifdef PRINT
                printf("FILEDATA (part) START: \n");
                PrintRawDataFp(stdout, filedata, filedata_len);
                printf("FILEDATA (part) END: \n");
#endif

                if (!(htud->tsflags & HTP_DONTSTORE)) {
                    result = HTPFileStoreChunk(
                            hstate, htud, filedata, filedata_len, STREAM_TOSERVER);
                    if (result == -1) {
                        goto end;
                    } else if (result == -2) {
                        /* we know for sure we're not storing the file */
                        htud->tsflags |= HTP_DONTSTORE;
                    }
                }

                htud->request_body.body_parsed += filedata_len;
            } else {
                SCLogDebug("chunk too small to already process in part");
            }

            goto end;
        }
    }

    while (header_start != NULL && header_end != NULL &&
            header_end != form_end &&
            header_start < (chunks_buffer + chunks_buffer_len) &&
            header_end < (chunks_buffer + chunks_buffer_len) &&
            header_start < header_end)
    {
        uint8_t *filename = NULL;
        uint16_t filename_len = 0;
        uint8_t *filetype = NULL;
        uint16_t filetype_len = 0;

        uint32_t header_len = header_end - header_start;
        SCLogDebug("header_len %u", header_len);
        uint8_t *header = (uint8_t *)header_start;

        /* skip empty records */
        if (expected_boundary_len == header_len) {
            goto next;
        } else if ((uint32_t)(expected_boundary_len + 2) <= header_len) {
            header_len -= (expected_boundary_len + 2);
            header = (uint8_t *)header_start + (expected_boundary_len + 2); // + for 0d 0a
        }

        HtpRequestBodyMultipartParseHeader(hstate, htud, header, header_len,
                &filename, &filename_len, &filetype, &filetype_len);

        if (filename != NULL) {
            const uint8_t *filedata = NULL;
            uint32_t filedata_len = 0;

            SCLogDebug("we have a filename");

            htud->tsflags |= HTP_FILENAME_SET;
            htud->tsflags &= ~HTP_DONTSTORE;

            SCLogDebug("header_end %p", header_end);
            SCLogDebug("form_end %p", form_end);

            /* everything until the final boundary is the file */
            if (form_end != NULL) {
                SCLogDebug("have form_end");

                filedata = header_end + 4;
                if (form_end == filedata) {
                    HTPSetEvent(hstate, htud, STREAM_TOSERVER,
                            HTTP_DECODER_EVENT_MULTIPART_NO_FILEDATA);
                    goto end;
                } else if (form_end < filedata) {
                    HTPSetEvent(hstate, htud, STREAM_TOSERVER,
                            HTTP_DECODER_EVENT_MULTIPART_GENERIC_ERROR);
                    goto end;
                }

                filedata_len = form_end - (header_end + 4 + 2);
                SCLogDebug("filedata_len %"PRIuMAX, (uintmax_t)filedata_len);

                /* or is it? */
                uint8_t *header_next = Bs2bmSearch(filedata, filedata_len,
                        boundary, expected_boundary_len);
                if (header_next != NULL) {
                    filedata_len -= (form_end - header_next);
                }

                if (filedata_len > chunks_buffer_len) {
                    HTPSetEvent(hstate, htud, STREAM_TOSERVER,
                            HTTP_DECODER_EVENT_MULTIPART_GENERIC_ERROR);
                    goto end;
                }
                SCLogDebug("filedata_len %"PRIuMAX, (uintmax_t)filedata_len);
#ifdef PRINT
                printf("FILEDATA START: \n");
                PrintRawDataFp(stdout, filedata, filedata_len);
                printf("FILEDATA END: \n");
#endif

                result = HTPFileOpen(hstate, htud, filename, filename_len, filedata, filedata_len,
                        HtpGetActiveRequestTxID(hstate), STREAM_TOSERVER);
                if (result == -1) {
                    goto end;
                } else if (result == -2) {
                    htud->tsflags |= HTP_DONTSTORE;
                } else {
                    if (HTPFileClose(hstate, htud, NULL, 0, 0, STREAM_TOSERVER) == -1) {
                        goto end;
                    }
                }
                FlagDetectStateNewFile(htud, STREAM_TOSERVER);

                htud->request_body.body_parsed += (header_end - chunks_buffer);
                htud->tsflags &= ~HTP_FILENAME_SET;
            } else {
                SCLogDebug("chunk doesn't contain form end");

                filedata = header_end + 4;
                filedata_len = chunks_buffer_len - (filedata - chunks_buffer);
                SCLogDebug("filedata_len %u (chunks_buffer_len %u)", filedata_len, chunks_buffer_len);

                if (filedata_len > chunks_buffer_len) {
                    HTPSetEvent(hstate, htud, STREAM_TOSERVER,
                            HTTP_DECODER_EVENT_MULTIPART_GENERIC_ERROR);
                    goto end;
                }

#ifdef PRINT
                printf("FILEDATA START: \n");
                PrintRawDataFp(stdout, filedata, filedata_len);
                printf("FILEDATA END: \n");
#endif
                /* form doesn't end in this chunk, but the part might. Lets
                 * see if have another coming up */
                uint8_t *header_next = Bs2bmSearch(filedata, filedata_len,
                        boundary, expected_boundary_len);
                SCLogDebug("header_next %p", header_next);
                if (header_next == NULL) {
                    SCLogDebug("more file data to come");

                    uint32_t offset = (header_end + 4) - chunks_buffer;
                    SCLogDebug("offset %u", offset);
                    htud->request_body.body_parsed += offset;

                    if (filedata_len >= (uint32_t)(expected_boundary_len + 2)) {
                        filedata_len -= (expected_boundary_len + 2 - 1);
                        // take as much as we can until start of boundary
                        for (size_t nb = 0; nb < (size_t)expected_boundary_len + 1; nb++) {
                            if (filedata[filedata_len] == '\r') {
                                if (nb == expected_boundary_len ||
                                        filedata[filedata_len + 1] == '\n') {
                                    break;
                                }
                            }
                            filedata_len++;
                        }
                        SCLogDebug("opening file with partial data");
                    } else {
                        filedata = NULL;
                        filedata_len = 0;
                    }
                    result = HTPFileOpen(hstate, htud, filename, filename_len, filedata,
                            filedata_len, HtpGetActiveRequestTxID(hstate), STREAM_TOSERVER);
                    if (result == -1) {
                        goto end;
                    } else if (result == -2) {
                        htud->tsflags |= HTP_DONTSTORE;
                    }
                    FlagDetectStateNewFile(htud, STREAM_TOSERVER);
                    htud->request_body.body_parsed += filedata_len;
                    SCLogDebug("htud->request_body.body_parsed %"PRIu64, htud->request_body.body_parsed);

                } else if (header_next - filedata > 2) {
                    filedata_len = header_next - filedata - 2;
                    SCLogDebug("filedata_len %u", filedata_len);

                    result = HTPFileOpen(hstate, htud, filename, filename_len, filedata,
                            filedata_len, HtpGetActiveRequestTxID(hstate), STREAM_TOSERVER);
                    if (result == -1) {
                        goto end;
                    } else if (result == -2) {
                        htud->tsflags |= HTP_DONTSTORE;
                    } else {
                        if (HTPFileClose(hstate, htud, NULL, 0, 0, STREAM_TOSERVER) == -1) {
                            goto end;
                        }
                    }
                    FlagDetectStateNewFile(htud, STREAM_TOSERVER);

                    htud->tsflags &= ~HTP_FILENAME_SET;
                    htud->request_body.body_parsed += (header_end - chunks_buffer);
                }
            }
        }
next:
        SCLogDebug("header_start %p, header_end %p, form_end %p",
                header_start, header_end, form_end);

        /* Search next boundary entry after the start of body */
        uint32_t cursizeread = header_end - chunks_buffer;
        header_start = Bs2bmSearch(header_end + 4,
                chunks_buffer_len - (cursizeread + 4),
                boundary, expected_boundary_len);
        if (header_start != NULL) {
            header_end = Bs2bmSearch(header_end + 4,
                    chunks_buffer_len - (cursizeread + 4),
                    (uint8_t *) "\r\n\r\n", 4);
        }
    }

    /* if we're parsing the multipart and we're not currently processing a
     * file, we move the body pointer forward. */
    if (form_end == NULL && !(htud->tsflags & HTP_FILENAME_SET) && header_start == NULL) {
        if (chunks_buffer_len > expected_boundary_end_len) {
            uint32_t move = chunks_buffer_len - expected_boundary_end_len + 1;

            htud->request_body.body_parsed += move;
            SCLogDebug("form not ready, file not set, parsing non-file "
                    "record: moved %u", move);
        }
    }

end:
    SCLogDebug("htud->request_body.body_parsed %"PRIu64, htud->request_body.body_parsed);
    return 0;
}
