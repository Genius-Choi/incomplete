static int Setup(Flow *f, HtpState *hstate)
{
    /* store flow ref in state so callbacks can access it */
    hstate->f = f;

    HTPCfgRec *htp_cfg_rec = &cfglist;
    htp_cfg_t *htp = cfglist.cfg; /* Default to the global HTP config */
    void *user_data = NULL;

    if (FLOW_IS_IPV4(f)) {
        SCLogDebug("Looking up HTP config for ipv4 %08x", *GET_IPV4_DST_ADDR_PTR(f));
        (void)SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_DST_ADDR_PTR(f), cfgtree, &user_data);
    }
    else if (FLOW_IS_IPV6(f)) {
        SCLogDebug("Looking up HTP config for ipv6");
        (void)SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_DST_ADDR(f), cfgtree, &user_data);
    }
    else {
        SCLogError("unknown address family, bug!");
        goto error;
    }

    if (user_data != NULL) {
        htp_cfg_rec = user_data;
        htp = htp_cfg_rec->cfg;
        SCLogDebug("LIBHTP using config: %p", htp);
    } else {
        SCLogDebug("Using default HTP config: %p", htp);
    }

    if (NULL == htp) {
#ifdef DEBUG_VALIDATION
        BUG_ON(htp == NULL);
#endif
        /* should never happen if HTPConfigure is properly invoked */
        goto error;
    }

    hstate->connp = htp_connp_create(htp);
    if (hstate->connp == NULL) {
        goto error;
    }

    hstate->conn = htp_connp_get_connection(hstate->connp);

    htp_connp_set_user_data(hstate->connp, (void *)hstate);
    hstate->cfg = htp_cfg_rec;

    SCLogDebug("New hstate->connp %p", hstate->connp);

    struct timeval tv = { SCTIME_SECS(f->startts), SCTIME_USECS(f->startts) };
    htp_connp_open(hstate->connp, NULL, f->sp, NULL, f->dp, &tv);

    StreamTcpReassemblySetMinInspectDepth(f->protoctx, STREAM_TOSERVER,
            htp_cfg_rec->request.inspect_min_size);
    StreamTcpReassemblySetMinInspectDepth(f->protoctx, STREAM_TOCLIENT,
            htp_cfg_rec->response.inspect_min_size);
    return 0;
error:
    return -1;
}
