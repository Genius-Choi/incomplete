static AppLayerResult HTPHandleResponseData(Flow *f, void *htp_state, AppLayerParserState *pstate,
        StreamSlice stream_slice, void *local_data)
{
    SCEnter();
    int ret = 0;
    HtpState *hstate = (HtpState *)htp_state;

    const uint8_t *input = StreamSliceGetData(&stream_slice);
    uint32_t input_len = StreamSliceGetDataLen(&stream_slice);

    /* On the first invocation, create the connection parser structure to
     * be used by HTP library.  This is looked up via IP in the radix
     * tree.  Failing that, the default HTP config is used.
     */
    if (NULL == hstate->conn) {
        if (Setup(f, hstate) != 0) {
            SCReturnStruct(APP_LAYER_ERROR);
        }
    }
    DEBUG_VALIDATE_BUG_ON(hstate->connp == NULL);
    hstate->slice = &stream_slice;

    htp_time_t ts = { SCTIME_SECS(f->startts), SCTIME_USECS(f->startts) };
    htp_tx_t *tx = NULL;
    size_t consumed = 0;
    if (input_len > 0) {
        const int r = htp_connp_res_data(hstate->connp, &ts, input, input_len);
        switch (r) {
            case HTP_STREAM_ERROR:
                ret = -1;
                break;
            case HTP_STREAM_TUNNEL:
                tx = htp_connp_get_out_tx(hstate->connp);
                if (tx != NULL && tx->response_status_number == 101) {
                    htp_header_t *h =
                            (htp_header_t *)htp_table_get_c(tx->response_headers, "Upgrade");
                    if (h == NULL || bstr_cmp_c(h->value, "h2c") != 0) {
                        break;
                    }
                    if (AppLayerProtoDetectGetProtoName(ALPROTO_HTTP2) == NULL) {
                        // if HTTP2 is disabled, keep the HTP_STREAM_TUNNEL mode
                        break;
                    }
                    uint16_t dp = 0;
                    if (tx->request_port_number != -1) {
                        dp = (uint16_t)tx->request_port_number;
                    }
                    consumed = htp_connp_res_data_consumed(hstate->connp);
                    hstate->slice = NULL;
                    if (!AppLayerRequestProtocolChange(hstate->f, dp, ALPROTO_HTTP2)) {
                        HTPSetEvent(hstate, NULL, STREAM_TOCLIENT,
                                HTTP_DECODER_EVENT_FAILED_PROTOCOL_CHANGE);
                    }
                    // During HTTP2 upgrade, we may consume the HTTP1 part of the data
                    // and we need to parser the remaining part with HTTP2
                    if (consumed > 0 && consumed < input_len) {
                        SCReturnStruct(APP_LAYER_INCOMPLETE(consumed, input_len - consumed));
                    }
                    SCReturnStruct(APP_LAYER_OK);
                }
                break;
            default:
                break;
        }
        HTPHandleError(hstate, STREAM_TOCLIENT);
    }

    /* if we the TCP connection is closed, then close the HTTP connection */
    if (AppLayerParserStateIssetFlag(pstate, APP_LAYER_PARSER_EOF_TC) &&
        !(hstate->flags & HTP_FLAG_STATE_CLOSED_TC))
    {
        htp_connp_close(hstate->connp, &ts);
        hstate->flags |= HTP_FLAG_STATE_CLOSED_TC;
    }

    SCLogDebug("hstate->connp %p", hstate->connp);
    hstate->slice = NULL;

    if (ret < 0) {
        SCReturnStruct(APP_LAYER_ERROR);
    }
    SCReturnStruct(APP_LAYER_OK);
}
