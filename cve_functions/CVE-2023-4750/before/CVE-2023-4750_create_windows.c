create_windows(mparm_T *parmp UNUSED)
{
    int		dorewind;
    int		done = 0;

    /*
     * Create the number of windows that was requested.
     */
    if (parmp->window_count == -1)	// was not set
	parmp->window_count = 1;
    if (parmp->window_count == 0)
	parmp->window_count = GARGCOUNT;
    if (parmp->window_count > 1)
    {
	// Don't change the windows if there was a command in .vimrc that
	// already split some windows
	if (parmp->window_layout == 0)
	    parmp->window_layout = WIN_HOR;
	if (parmp->window_layout == WIN_TABS)
	{
	    parmp->window_count = make_tabpages(parmp->window_count);
	    TIME_MSG("making tab pages");
	}
	else if (firstwin->w_next == NULL)
	{
	    parmp->window_count = make_windows(parmp->window_count,
					     parmp->window_layout == WIN_VER);
	    TIME_MSG("making windows");
	}
	else
	    parmp->window_count = win_count();
    }
    else
	parmp->window_count = 1;

    if (recoverymode)			// do recover
    {
	msg_scroll = TRUE;		// scroll message up
	ml_recover(TRUE);
	if (curbuf->b_ml.ml_mfp == NULL) // failed
	    getout(1);
	do_modelines(0);		// do modelines
    }
    else
    {
	/*
	 * Open a buffer for windows that don't have one yet.
	 * Commands in the .vimrc might have loaded a file or split the window.
	 * Watch out for autocommands that delete a window.
	 */
	/*
	 * Don't execute Win/Buf Enter/Leave autocommands here
	 */
	++autocmd_no_enter;
	++autocmd_no_leave;
	dorewind = TRUE;
	while (done++ < 1000)
	{
	    if (dorewind)
	    {
		if (parmp->window_layout == WIN_TABS)
		    goto_tabpage(1);
		else
		    curwin = firstwin;
	    }
	    else if (parmp->window_layout == WIN_TABS)
	    {
		if (curtab->tp_next == NULL)
		    break;
		goto_tabpage(0);
	    }
	    else
	    {
		if (curwin->w_next == NULL)
		    break;
		curwin = curwin->w_next;
	    }
	    dorewind = FALSE;
	    curbuf = curwin->w_buffer;
	    if (curbuf->b_ml.ml_mfp == NULL)
	    {
#ifdef FEAT_FOLDING
		// Set 'foldlevel' to 'foldlevelstart' if it's not negative.
		if (p_fdls >= 0)
		    curwin->w_p_fdl = p_fdls;
#endif
		// When getting the ATTENTION prompt here, use a dialog
		swap_exists_action = SEA_DIALOG;

		set_buflisted(TRUE);

		// create memfile, read file
		(void)open_buffer(FALSE, NULL, 0);

		if (swap_exists_action == SEA_QUIT)
		{
		    if (got_int || only_one_window())
		    {
			// abort selected or quit and only one window
			did_emsg = FALSE;   // avoid hit-enter prompt
			getout(1);
		    }
		    // We can't close the window, it would disturb what
		    // happens next.  Clear the file name and set the arg
		    // index to -1 to delete it later.
		    setfname(curbuf, NULL, NULL, FALSE);
		    curwin->w_arg_idx = -1;
		    swap_exists_action = SEA_NONE;
		}
		else
		    handle_swap_exists(NULL);
		dorewind = TRUE;		// start again
	    }
	    ui_breakcheck();
	    if (got_int)
	    {
		(void)vgetc();	// only break the file loading, not the rest
		break;
	    }
	}
	if (parmp->window_layout == WIN_TABS)
	    goto_tabpage(1);
	else
	    curwin = firstwin;
	curbuf = curwin->w_buffer;
	--autocmd_no_enter;
	--autocmd_no_leave;
    }
}
