command_line_scan(mparm_T *parmp)
{
    int		argc = parmp->argc;
    char	**argv = parmp->argv;
    int		argv_idx;		// index in argv[n][]
    int		had_minmin = FALSE;	// found "--" argument
    int		want_argument;		// option argument with argument
    int		c;
    char_u	*p = NULL;
    long	n;

    --argc;
    ++argv;
    argv_idx = 1;	    // active option letter is argv[0][argv_idx]
    while (argc > 0)
    {
	/*
	 * "+" or "+{number}" or "+/{pat}" or "+{command}" argument.
	 */
	if (argv[0][0] == '+' && !had_minmin)
	{
	    if (parmp->n_commands >= MAX_ARG_CMDS)
		mainerr(ME_EXTRA_CMD, NULL);
	    argv_idx = -1;	    // skip to next argument
	    if (argv[0][1] == NUL)
		parmp->commands[parmp->n_commands++] = (char_u *)"$";
	    else
		parmp->commands[parmp->n_commands++] = (char_u *)&(argv[0][1]);
	}

	/*
	 * Optional argument.
	 */
	else if (argv[0][0] == '-' && !had_minmin)
	{
	    want_argument = FALSE;
	    c = argv[0][argv_idx++];
#ifdef VMS
	    /*
	     * VMS only uses upper case command lines.  Interpret "-X" as "-x"
	     * and "-/X" as "-X".
	     */
	    if (c == '/')
	    {
		c = argv[0][argv_idx++];
		c = TOUPPER_ASC(c);
	    }
	    else
		c = TOLOWER_ASC(c);
#endif
	    switch (c)
	    {
	    case NUL:		// "vim -"  read from stdin
				// "ex -" silent mode
		if (exmode_active)
		    silent_mode = TRUE;
		else
		{
		    if (parmp->edit_type != EDIT_NONE)
			mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
		    parmp->edit_type = EDIT_STDIN;
		    read_cmd_fd = 2;	// read from stderr instead of stdin
		}
		argv_idx = -1;		// skip to next argument
		break;

	    case '-':		// "--" don't take any more option arguments
				// "--help" give help message
				// "--version" give version message
				// "--clean" clean context
				// "--literal" take files literally
				// "--startuptime fname" write timing info
				// "--log fname" start logging early
				// "--nofork" don't fork
				// "--not-a-term" don't warn for not a term
				// "--gui-dialog-file fname" write dialog text
				// "--ttyfail" exit if not a term
				// "--noplugin[s]" skip plugins
				// "--cmd <cmd>" execute cmd before vimrc
		if (STRICMP(argv[0] + argv_idx, "help") == 0)
		    usage();
		else if (STRICMP(argv[0] + argv_idx, "version") == 0)
		{
		    Columns = 80;	// need to init Columns
		    info_message = TRUE; // use mch_msg(), not mch_errmsg()
#if defined(FEAT_GUI) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)
		    gui.starting = FALSE; // not starting GUI, will exit
#endif
		    list_version();
		    msg_putchar('\n');
		    msg_didout = FALSE;
		    mch_exit(0);
		}
		else if (STRNICMP(argv[0] + argv_idx, "clean", 5) == 0)
		{
		    parmp->use_vimrc = (char_u *)"DEFAULTS";
#ifdef FEAT_GUI
		    use_gvimrc = (char_u *)"NONE";
#endif
		    parmp->clean = TRUE;
		    set_option_value_give_err((char_u *)"vif",
						      0L, (char_u *)"NONE", 0);
		}
		else if (STRNICMP(argv[0] + argv_idx, "literal", 7) == 0)
		{
#ifdef EXPAND_FILENAMES
		    parmp->literal = TRUE;
#endif
		}
		else if (STRNICMP(argv[0] + argv_idx, "nofork", 6) == 0)
		{
#ifdef FEAT_GUI
		    gui.dofork = FALSE;	// don't fork() when starting GUI
#endif
		}
		else if (STRNICMP(argv[0] + argv_idx, "noplugin", 8) == 0)
		    p_lpl = FALSE;
		else if (STRNICMP(argv[0] + argv_idx, "not-a-term", 10) == 0)
		    parmp->not_a_term = TRUE;
		else if (STRNICMP(argv[0] + argv_idx, "gui-dialog-file", 15)
									 == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 15;
		}
		else if (STRNICMP(argv[0] + argv_idx, "ttyfail", 7) == 0)
		    parmp->tty_fail = TRUE;
		else if (STRNICMP(argv[0] + argv_idx, "cmd", 3) == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 3;
		}
		else if (STRNICMP(argv[0] + argv_idx, "startuptime", 11) == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 11;
		}
		else if (STRNICMP(argv[0] + argv_idx, "log", 3) == 0)
		{
		    want_argument = TRUE;
		    argv_idx += 3;
		}
#ifdef FEAT_CLIENTSERVER
		else if (STRNICMP(argv[0] + argv_idx, "serverlist", 10) == 0)
		    ; // already processed -- no arg
		else if (STRNICMP(argv[0] + argv_idx, "servername", 10) == 0
		       || STRNICMP(argv[0] + argv_idx, "serversend", 10) == 0)
		{
		    // already processed -- snatch the following arg
		    if (argc > 1)
		    {
			--argc;
			++argv;
		    }
		}
#endif
#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MSWIN)
# ifdef FEAT_GUI_GTK
		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
# else
		else if (STRNICMP(argv[0] + argv_idx, "windowid", 8) == 0)
# endif
		{
		    // already processed -- snatch the following arg
		    if (argc > 1)
		    {
			--argc;
			++argv;
		    }
		}
#endif
#ifdef FEAT_GUI_GTK
		else if (STRNICMP(argv[0] + argv_idx, "echo-wid", 8) == 0)
		{
		    // already processed, skip
		}
#endif
		else
		{
		    if (argv[0][argv_idx])
			mainerr(ME_UNKNOWN_OPTION, (char_u *)argv[0]);
		    had_minmin = TRUE;
		}
		if (!want_argument)
		    argv_idx = -1;	// skip to next argument
		break;

	    case 'A':		// "-A" start in Arabic mode
#ifdef FEAT_ARABIC
		set_option_value_give_err((char_u *)"arabic", 1L, NULL, 0);
#else
		mch_errmsg(_(e_arabic_cannot_be_used_not_enabled_at_compile_time));
		mch_exit(2);
#endif
		break;

	    case 'b':		// "-b" binary mode
		// Needs to be effective before expanding file names, because
		// for Win32 this makes us edit a shortcut file itself,
		// instead of the file it links to.
		set_options_bin(curbuf->b_p_bin, 1, 0);
		curbuf->b_p_bin = 1;	    // binary file I/O
		break;

	    case 'C':		// "-C"  Compatible
		change_compatible(TRUE);
		has_dash_c_arg = TRUE;
		break;

	    case 'e':		// "-e" Ex mode
		exmode_active = EXMODE_NORMAL;
		break;

	    case 'E':		// "-E" Improved Ex mode
		exmode_active = EXMODE_VIM;
		break;

	    case 'f':		// "-f"  GUI: run in foreground.  Amiga: open
				// window directly, not with newcli
#ifdef FEAT_GUI
		gui.dofork = FALSE;	// don't fork() when starting GUI
#endif
		break;

	    case 'g':		// "-g" start GUI
		main_start_gui();
		break;

	    case 'F':		// "-F" was for Farsi mode
		mch_errmsg(_(e_farsi_support_has_been_removed));
		mch_exit(2);
		break;

	    case '?':		// "-?" give help message (for MS-Windows)
	    case 'h':		// "-h" give help message
#ifdef FEAT_GUI_GNOME
		// Tell usage() to exit for "gvim".
		gui.starting = FALSE;
#endif
		usage();
		break;

	    case 'H':		// "-H" start in Hebrew mode: rl + hkmap set
#ifdef FEAT_RIGHTLEFT
		p_hkmap = TRUE;
		set_option_value_give_err((char_u *)"rl", 1L, NULL, 0);
#else
		mch_errmsg(_(e_hebrew_cannot_be_used_not_enabled_at_compile_time));
		mch_exit(2);
#endif
		break;

	    case 'l':		// "-l" lisp mode, 'lisp' and 'showmatch' on
		set_option_value_give_err((char_u *)"lisp", 1L, NULL, 0);
		p_sm = TRUE;
		break;

	    case 'M':		// "-M"  no changes or writing of files
		reset_modifiable();
		// FALLTHROUGH

	    case 'm':		// "-m"  no writing of files
		p_write = FALSE;
		break;

	    case 'y':		// "-y"  easy mode
#ifdef FEAT_GUI
		gui.starting = TRUE;	// start GUI a bit later
#endif
		parmp->evim_mode = TRUE;
		break;

	    case 'N':		// "-N"  Nocompatible
		change_compatible(FALSE);
		break;

	    case 'n':		// "-n" no swap file
#ifdef FEAT_NETBEANS_INTG
		// checking for "-nb", netbeans parameters
		if (argv[0][argv_idx] == 'b')
		{
		    netbeansArg = argv[0];
		    argv_idx = -1;	    // skip to next argument
		}
		else
#endif
		parmp->no_swap_file = TRUE;
		break;

	    case 'p':		// "-p[N]" open N tab pages
#ifdef TARGET_API_MAC_OSX
		// For some reason on MacOS X, an argument like:
		// -psn_0_10223617 is passed in when invoke from Finder
		// or with the 'open' command
		if (argv[0][argv_idx] == 's')
		{
		    argv_idx = -1; // bypass full -psn
		    main_start_gui();
		    break;
		}
#endif
		// default is 0: open window for each file
		parmp->window_count = get_number_arg((char_u *)argv[0],
								&argv_idx, 0);
		parmp->window_layout = WIN_TABS;
		break;

	    case 'o':		// "-o[N]" open N horizontal split windows
		// default is 0: open window for each file
		parmp->window_count = get_number_arg((char_u *)argv[0],
								&argv_idx, 0);
		parmp->window_layout = WIN_HOR;
		break;

		case 'O':	// "-O[N]" open N vertical split windows
		// default is 0: open window for each file
		parmp->window_count = get_number_arg((char_u *)argv[0],
								&argv_idx, 0);
		parmp->window_layout = WIN_VER;
		break;

#ifdef FEAT_QUICKFIX
	    case 'q':		// "-q" QuickFix mode
		if (parmp->edit_type != EDIT_NONE)
		    mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
		parmp->edit_type = EDIT_QF;
		if (argv[0][argv_idx])		// "-q{errorfile}"
		{
		    parmp->use_ef = (char_u *)argv[0] + argv_idx;
		    argv_idx = -1;
		}
		else if (argc > 1)		// "-q {errorfile}"
		    want_argument = TRUE;
		break;
#endif

	    case 'R':		// "-R" readonly mode
		readonlymode = TRUE;
		curbuf->b_p_ro = TRUE;
		p_uc = 10000;			// don't update very often
		break;

	    case 'r':		// "-r" recovery mode
	    case 'L':		// "-L" recovery mode
		recoverymode = 1;
		break;

	    case 's':
		if (exmode_active)	// "-s" silent (batch) mode
		    silent_mode = TRUE;
		else		// "-s {scriptin}" read from script file
		    want_argument = TRUE;
		break;

	    case 't':		// "-t {tag}" or "-t{tag}" jump to tag
		if (parmp->edit_type != EDIT_NONE)
		    mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
		parmp->edit_type = EDIT_TAG;
		if (argv[0][argv_idx])		// "-t{tag}"
		{
		    parmp->tagname = (char_u *)argv[0] + argv_idx;
		    argv_idx = -1;
		}
		else				// "-t {tag}"
		    want_argument = TRUE;
		break;

#ifdef FEAT_EVAL
	    case 'D':		// "-D"		Debugging
		parmp->use_debug_break_level = 9999;
		break;
#endif
#ifdef FEAT_DIFF
	    case 'd':		// "-d"		'diff'
# ifdef AMIGA
		// check for "-dev {device}"
		if (argv[0][argv_idx] == 'e' && argv[0][argv_idx + 1] == 'v')
		    want_argument = TRUE;
		else
# endif
		    parmp->diff_mode = TRUE;
		break;
#endif
	    case 'V':		// "-V{N}"	Verbose level
		// default is 10: a little bit verbose
		p_verbose = get_number_arg((char_u *)argv[0], &argv_idx, 10);
		if (argv[0][argv_idx] != NUL)
		{
		    set_option_value_give_err((char_u *)"verbosefile",
					  0L, (char_u *)argv[0] + argv_idx, 0);
		    argv_idx = (int)STRLEN(argv[0]);
		}
		break;

	    case 'v':		// "-v"  Vi-mode (as if called "vi")
		exmode_active = 0;
#if defined(FEAT_GUI) && !defined(VIMDLL)
		gui.starting = FALSE;	// don't start GUI
#endif
		break;

	    case 'w':		// "-w{number}"	set window height
				// "-w {scriptout}"	write to script
		if (vim_isdigit(((char_u *)argv[0])[argv_idx]))
		{
		    n = get_number_arg((char_u *)argv[0], &argv_idx, 10);
		    set_option_value_give_err((char_u *)"window", n, NULL, 0);
		    break;
		}
		want_argument = TRUE;
		break;

#ifdef FEAT_CRYPT
	    case 'x':		// "-x"  encrypted reading/writing of files
		parmp->ask_for_key = TRUE;
		break;
#endif

	    case 'X':		// "-X"  don't connect to X server
#if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)
		x_no_connect = TRUE;
#endif
		break;

	    case 'Z':		// "-Z"  restricted mode
		restricted = TRUE;
		break;

	    case 'c':		// "-c{command}" or "-c {command}" execute
				// command
		if (argv[0][argv_idx] != NUL)
		{
		    if (parmp->n_commands >= MAX_ARG_CMDS)
			mainerr(ME_EXTRA_CMD, NULL);
		    parmp->commands[parmp->n_commands++] = (char_u *)argv[0]
								   + argv_idx;
		    argv_idx = -1;
		    break;
		}
		// FALLTHROUGH
	    case 'S':		// "-S {file}" execute Vim script
	    case 'i':		// "-i {viminfo}" use for viminfo
#ifndef FEAT_DIFF
	    case 'd':		// "-d {device}" device (for Amiga)
#endif
	    case 'T':		// "-T {terminal}" terminal name
	    case 'u':		// "-u {vimrc}" vim inits file
	    case 'U':		// "-U {gvimrc}" gvim inits file
	    case 'W':		// "-W {scriptout}" overwrite
#ifdef FEAT_GUI_MSWIN
	    case 'P':		// "-P {parent title}" MDI parent
#endif
		want_argument = TRUE;
		break;

	    default:
		mainerr(ME_UNKNOWN_OPTION, (char_u *)argv[0]);
	    }

	    /*
	     * Handle option arguments with argument.
	     */
	    if (want_argument)
	    {
		/*
		 * Check for garbage immediately after the option letter.
		 */
		if (argv[0][argv_idx] != NUL)
		    mainerr(ME_GARBAGE, (char_u *)argv[0]);

		--argc;
		if (argc < 1 && c != 'S')  // -S has an optional argument
		    mainerr_arg_missing((char_u *)argv[0]);
		++argv;
		argv_idx = -1;

		switch (c)
		{
		case 'c':	// "-c {command}" execute command
		case 'S':	// "-S {file}" execute Vim script
		    if (parmp->n_commands >= MAX_ARG_CMDS)
			mainerr(ME_EXTRA_CMD, NULL);
		    if (c == 'S')
		    {
			char	*a;

			if (argc < 1)
			    // "-S" without argument: use default session file
			    // name.
			    a = SESSION_FILE;
			else if (argv[0][0] == '-')
			{
			    // "-S" followed by another option: use default
			    // session file name.
			    a = SESSION_FILE;
			    ++argc;
			    --argv;
			}
			else
			    a = argv[0];
			p = alloc(STRLEN(a) + 4);
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, "so %s", a);
			parmp->cmds_tofree[parmp->n_commands] = TRUE;
			parmp->commands[parmp->n_commands++] = p;
		    }
		    else
			parmp->commands[parmp->n_commands++] =
							    (char_u *)argv[0];
		    break;

		case '-':
		    if (argv[-1][2] == 'c')
		    {
			// "--cmd {command}" execute command
			if (parmp->n_pre_commands >= MAX_ARG_CMDS)
			    mainerr(ME_EXTRA_CMD, NULL);
			parmp->pre_commands[parmp->n_pre_commands++] =
							    (char_u *)argv[0];
		    }
		    // --gui-dialog-file fname
		    if (argv[-1][2] == 'g')
		    {
			// without GUI ignore the argument
#ifdef FEAT_GUI
			parmp->gui_dialog_file = (char_u *)argv[0];
#endif
		    }

		    // "--startuptime <file>" already handled
		    // "--log <file>" already handled
		    break;

	    //	case 'd':   -d {device} is handled in mch_check_win() for the
	    //		    Amiga

#ifdef FEAT_QUICKFIX
		case 'q':	// "-q {errorfile}" QuickFix mode
		    parmp->use_ef = (char_u *)argv[0];
		    break;
#endif

		case 'i':	// "-i {viminfo}" use for viminfo
		    set_option_value_give_err((char_u *)"vif",
						     0L, (char_u *)argv[0], 0);
		    break;

		case 's':	// "-s {scriptin}" read from script file
		    if (scriptin[0] != NULL)
		    {
scripterror:
			mch_errmsg(_("Attempt to open script file again: \""));
			mch_errmsg(argv[-1]);
			mch_errmsg(" ");
			mch_errmsg(argv[0]);
			mch_errmsg("\"\n");
			mch_exit(2);
		    }
		    if ((scriptin[0] = mch_fopen(argv[0], READBIN)) == NULL)
		    {
			mch_errmsg(_("Cannot open for reading: \""));
			mch_errmsg(argv[0]);
			mch_errmsg("\"\n");
			mch_exit(2);
		    }
		    if (save_typebuf() == FAIL)
			mch_exit(2);	// out of memory
		    break;

		case 't':	// "-t {tag}"
		    parmp->tagname = (char_u *)argv[0];
		    break;

		case 'T':	// "-T {terminal}" terminal name
		    /*
		     * The -T term argument is always available and when
		     * HAVE_TERMLIB is supported it overrides the environment
		     * variable TERM.
		     */
#ifdef FEAT_GUI
		    if (term_is_gui((char_u *)argv[0]))
			gui.starting = TRUE;	// start GUI a bit later
		    else
#endif
			parmp->term = (char_u *)argv[0];
		    break;

		case 'u':	// "-u {vimrc}" vim inits file
		    parmp->use_vimrc = (char_u *)argv[0];
		    break;

		case 'U':	// "-U {gvimrc}" gvim inits file
#ifdef FEAT_GUI
		    use_gvimrc = (char_u *)argv[0];
#endif
		    break;

		case 'w':	// "-w {nr}" 'window' value
				// "-w {scriptout}" append to script file
		    if (vim_isdigit(*((char_u *)argv[0])))
		    {
			argv_idx = 0;
			n = get_number_arg((char_u *)argv[0], &argv_idx, 10);
			set_option_value_give_err((char_u *)"window",
								   n, NULL, 0);
			argv_idx = -1;
			break;
		    }
		    // FALLTHROUGH
		case 'W':	// "-W {scriptout}" overwrite script file
		    if (scriptout != NULL)
			goto scripterror;
		    if ((scriptout = mch_fopen(argv[0],
				    c == 'w' ? APPENDBIN : WRITEBIN)) == NULL)
		    {
			mch_errmsg(_("Cannot open for script output: \""));
			mch_errmsg(argv[0]);
			mch_errmsg("\"\n");
			mch_exit(2);
		    }
		    break;

#ifdef FEAT_GUI_MSWIN
		case 'P':		// "-P {parent title}" MDI parent
		    gui_mch_set_parent(argv[0]);
		    break;
#endif
		}
	    }
	}

	/*
	 * File name argument.
	 */
	else
	{
	    argv_idx = -1;	    // skip to next argument

	    // Check for only one type of editing.
	    if (parmp->edit_type != EDIT_NONE && parmp->edit_type != EDIT_FILE)
		mainerr(ME_TOO_MANY_ARGS, (char_u *)argv[0]);
	    parmp->edit_type = EDIT_FILE;

#ifdef MSWIN
	    // Remember if the argument was a full path before changing
	    // slashes to backslashes.
	    if (argv[0][0] != NUL && argv[0][1] == ':' && argv[0][2] == '\\')
		parmp->full_path = TRUE;
#endif

	    // Add the file to the global argument list.
	    if (ga_grow(&global_alist.al_ga, 1) == FAIL
		    || (p = vim_strsave((char_u *)argv[0])) == NULL)
		mch_exit(2);
#ifdef FEAT_DIFF
	    if (parmp->diff_mode && mch_isdir(p) && GARGCOUNT > 0
				      && !mch_isdir(alist_name(&GARGLIST[0])))
	    {
		char_u	    *r;

		r = concat_fnames(p, gettail(alist_name(&GARGLIST[0])), TRUE);
		if (r != NULL)
		{
		    vim_free(p);
		    p = r;
		}
	    }
#endif
#ifdef __CYGWIN__
	    /*
	     * If vim is invoked by non-Cygwin tools, convert away any
	     * DOS paths, so things like .swp files are created correctly.
	     * Look for evidence of non-Cygwin paths before we bother.
	     * This is only for when using the Unix files.
	     */
	    if (vim_strpbrk(p, "\\:") != NULL && !path_with_url(p))
	    {
		char posix_path[MAXPATHL];

# if CYGWIN_VERSION_DLL_MAJOR >= 1007
		cygwin_conv_path(CCP_WIN_A_TO_POSIX, p, posix_path, MAXPATHL);
# else
		cygwin_conv_to_posix_path(p, posix_path);
# endif
		vim_free(p);
		p = vim_strsave((char_u *)posix_path);
		if (p == NULL)
		    mch_exit(2);
	    }
#endif

#ifdef USE_FNAME_CASE
	    // Make the case of the file name match the actual file.
	    fname_case(p, 0);
#endif

	    alist_add(&global_alist, p,
#ifdef EXPAND_FILENAMES
		    parmp->literal ? 2 : 0	// add buffer nr after exp.
#else
		    2		// add buffer number now and use curbuf
#endif
		    );

#ifdef MSWIN
	    {
		// Remember this argument has been added to the argument list.
		// Needed when 'encoding' is changed.
		used_file_arg(argv[0], parmp->literal, parmp->full_path,
# ifdef FEAT_DIFF
							    parmp->diff_mode
# else
							    FALSE
# endif
							    );
	    }
#endif
	}

	/*
	 * If there are no more letters after the current "-", go to next
	 * argument.  argv_idx is set to -1 when the current argument is to be
	 * skipped.
	 */
	if (argv_idx <= 0 || argv[0][argv_idx] == NUL)
	{
	    --argc;
	    ++argv;
	    argv_idx = 1;
	}
    }

#ifdef FEAT_EVAL
    // If there is a "+123" or "-c" command, set v:swapcommand to the first
    // one.
    if (parmp->n_commands > 0)
    {
	p = alloc(STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, ":%s\r", parmp->commands[0]);
	    set_vim_var_string(VV_SWAPCOMMAND, p, -1);
	    vim_free(p);
	}
    }
#endif
}
