nv_esc(cmdarg_T *cap)
{
    int		no_reason;

    no_reason = (cap->oap->op_type == OP_NOP
		&& cap->opcount == 0
		&& cap->count0 == 0
		&& cap->oap->regname == 0
		&& !p_im);

    if (cap->arg)		// TRUE for CTRL-C
    {
	if (restart_edit == 0 && cmdwin_type == 0
						&& !VIsual_active && no_reason)
	{
	    int	out_redir = !stdout_isatty && !is_not_a_term_or_gui();

	    // The user may accidentally do "vim file | grep word" and then
	    // CTRL-C doesn't show anything.  With a changed buffer give the
	    // message on stderr.  Without any changes might as well exit.
	    if (anyBufIsChanged())
	    {
		char *ms = _("Type  :qa!  and press <Enter> to abandon all changes and exit Vim");

		if (out_redir)
		    mch_errmsg(ms);
		else
		    msg(ms);
	    }
	    else
	    {
		if (out_redir)
		{
		    got_int = FALSE;
		    do_cmdline_cmd((char_u *)"qa");
		}
		else
		    msg(_("Type  :qa  and press <Enter> to exit Vim"));
	    }
	}

	if (restart_edit != 0)
	    redraw_mode = TRUE;  // remove "-- (insert) --"

	// Don't reset "restart_edit" when 'insertmode' is set, it won't be
	// set again below when halfway a mapping.
	if (!p_im)
	    restart_edit = 0;
	if (cmdwin_type != 0)
	{
	    cmdwin_result = K_IGNORE;
	    got_int = FALSE;	// don't stop executing autocommands et al.
	    return;
	}
    }
    else if (cmdwin_type != 0 && ex_normal_busy && typebuf_was_empty)
    {
	// When :normal runs out of characters while in the command line window
	// vgetorpeek() will repeatedly return ESC.  Exit the cmdline window to
	// break the loop.
	cmdwin_result = K_IGNORE;
	return;
    }

    if (VIsual_active)
    {
	end_visual_mode();	// stop Visual
	check_cursor_col();	// make sure cursor is not beyond EOL
	curwin->w_set_curswant = TRUE;
	redraw_curbuf_later(UPD_INVERTED);
    }
    else if (no_reason)
    {
#ifdef HAS_MESSAGE_WINDOW
	if (!cap->arg && popup_message_win_visible())
	    popup_hide_message_win();
	else
#endif
	    vim_beep(BO_ESC);
    }
    clearop(cap->oap);

    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is
    // set return to Insert mode afterwards.
    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)
	restart_edit = 'a';
}
