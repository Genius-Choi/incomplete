static const unsigned char* pcap_next_wrapper(pcap_t *foo, struct pcap_pkthdr *h_out) {
	if(!filebased) {
		const unsigned char* ret = 0;
		struct pcap_pkthdr *hdr_temp;
		int err = pcap_next_ex(foo, &hdr_temp, &ret);
		if(err == 1) {
			*h_out = *hdr_temp;
		} else ret = 0;
		if(ret && outfd != -1){
			struct pcap_file_pkthdr {
				unsigned sec_epoch;
				unsigned ms_sec;
				unsigned caplen;
				unsigned len;
			} hdr_out = {
				.sec_epoch = h_out->ts.tv_sec,
				.ms_sec = h_out->ts.tv_usec,
				.caplen = h_out->caplen,
				.len = h_out->len,
			};
			write(outfd, &hdr_out, sizeof hdr_out);
			write(outfd, ret, h_out->len);
		}
		return ret;
	}
	static long long pcap_file_start_time, start_time;
	static unsigned char buf[2][2048];
	static struct pcap_pkthdr h[2];
	static int actbuf;
	const unsigned char* ret;
	if(start_time == 0 || getutime64() - start_time >= timeval2utime(&h[!actbuf].ts) - pcap_file_start_time) {
		ret = pcap_next(foo, h_out);
		if(ret) {
			h[actbuf] = *h_out;
			assert(h[actbuf].len <= sizeof buf[actbuf]);
			memcpy(buf[actbuf], ret, h[actbuf].len);
			actbuf = !actbuf;
		}
		if(!start_time) {
			start_time = getutime64();
			assert(ret);
			pcap_file_start_time = timeval2utime(&h_out->ts);
			return 0;
		}
		if(ret) {
			*h_out = h[actbuf];
			return buf[actbuf];
		} else return 0;
	} else
		return 0;
}
