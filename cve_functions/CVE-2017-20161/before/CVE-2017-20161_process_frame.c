static int process_frame(pcap_t *foo) {
	struct pcap_pkthdr h;
	const unsigned char* data = pcap_next_wrapper(foo, &h);
	if(data) {
		if(console_getbackendtype(t) == cb_sdl && getenv("DEBUG")) dump_packet(data, h.len);
		struct ieee80211_radiotap_header *rh = (void*) data;
		//size_t next_chunk = sizeof(*rh);
		uint32_t flags = rh->it_present, flags_copy = flags;
		unsigned ext_bytes = 0;
		while(flags_copy & (1U << IEEE80211_RADIOTAP_EXT)) {
			memcpy(&flags_copy, data+sizeof(*rh)+ext_bytes, 4);
			ext_bytes += 4;
		}
		unsigned rtap_data = sizeof(*rh) + ext_bytes;

		struct wlaninfo temp = {0};
		{
			if(!(flags & (1U << IEEE80211_RADIOTAP_DBM_ANTSIGNAL))) return -1;
			unsigned dbmoff = get_dbm_off(flags, rtap_data);
			temp.last_rssi = ((signed char*)data)[dbmoff];
		}
		{
//			if(!(flags & (1U << IEEE80211_RADIOTAP_CHANNEL))) return -1;
			short freq;
			unsigned chanoff = get_chan_off(flags, rtap_data);
			memcpy(&freq, data+ chanoff, 2);
			temp.channel = channel_from_freq(freq);
		}
		uint16_t framectl;
		memcpy(&framectl, data+rh->it_len, 2);
		struct beaconframe* beacon;
		unsigned const char* tagdata, *curr_tag;
		unsigned pos;
		switch(htons(framectl)) {
			/* IEEE 802.11 packet type */
			case 0xd400: /*ack*/
				//memcpy(&temp.mac,data+rh->it_len+4, 6);
				//set_rssi(&temp, dbm);
				//break;
				return -1;
			case 0x8000: /*beacon */
				beacon = (void*)(data+rh->it_len);
				memcpy(&temp.mac,beacon->source,6);
				pos = rh->it_len+sizeof(*beacon)+12;
				tagdata = data+pos;
				curr_tag = find_tag(tagdata, 0, h.len-pos); /* find essid tag */
				if(curr_tag) {
					memcpy(temp.essid, curr_tag+2, curr_tag[1]);
					temp.essid[curr_tag[1]] = 0;
				} else {
					/* dubious beacon without essid */
					dprintf(2, "XXX\n");
					if(console_getbackendtype(t) == cb_sdl && getenv("DEBUG")) dump_packet(data, h.len);
				}
				curr_tag = find_tag(tagdata, 3, h.len-pos); /* find channel nr tag */
				if(curr_tag) {
					assert(curr_tag[1] == 1);
					temp.channel = curr_tag[2];
				}
				setminmax(temp.last_rssi);

				return set_rssi(&temp);

				break;
			case 0x8842: /*QOS */
			case 0x4000: /* probe request */
			default:
				return -1;
		}
		//while(htonl(*(flags++)) & (1U << IEEE80211_RADIOTAP_EXT)) next_chunk+=4;
		//dprintf(2, "got data\n");
		//dump();
	} else usleep(1);
	return -1;
}
