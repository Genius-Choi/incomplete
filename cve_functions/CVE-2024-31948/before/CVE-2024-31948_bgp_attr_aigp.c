static enum bgp_attr_parse_ret bgp_attr_aigp(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	uint8_t *s = stream_pnt(peer->curr);
	uint64_t aigp = 0;

	/* If an AIGP attribute is received on a BGP session for which
	 * AIGP_SESSION is disabled, the attribute MUST be treated exactly
	 * as if it were an unrecognized non-transitive attribute.
	 * That is, it "MUST be quietly ignored and not passed along to
	 * other BGP peers".
	 * For Internal BGP (IBGP) sessions, and for External BGP (EBGP)
	 * sessions between members of the same BGP Confederation,
	 * the default value of AIGP_SESSION SHOULD be "enabled".
	 */
	if (peer->sort == BGP_PEER_EBGP &&
	    (!CHECK_FLAG(peer->flags, PEER_FLAG_AIGP) ||
	     peer->sub_sort != BGP_PEER_EBGP_OAD)) {
		zlog_warn(
			"%pBP received AIGP attribute, but eBGP peer do not support it",
			peer);
		goto aigp_ignore;
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto aigp_ignore;

	if (!bgp_attr_aigp_valid(s, length))
		goto aigp_ignore;

	/* Extract AIGP Metric TLV */
	if (bgp_attr_aigp_get_tlv_metric(s, length, &aigp))
		bgp_attr_set_aigp_metric(attr, aigp);

aigp_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}
