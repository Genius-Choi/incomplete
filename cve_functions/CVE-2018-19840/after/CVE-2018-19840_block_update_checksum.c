static void block_update_checksum (unsigned char *buffer_start)
{
    WavpackHeader *wphdr = (WavpackHeader *) buffer_start;
    unsigned char *dp, meta_id, c1, c2;
    uint32_t bcount, meta_bc;

    if (!(wphdr->flags & HAS_CHECKSUM))
        return;

    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;
    dp = (unsigned char *)(wphdr + 1);

    while (bcount >= 2) {
        meta_id = *dp++;
        c1 = *dp++;

        meta_bc = c1 << 1;
        bcount -= 2;

        if (meta_id & ID_LARGE) {
            if (bcount < 2)
                return;

            c1 = *dp++;
            c2 = *dp++;
            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);
            bcount -= 2;
        }

        if (bcount < meta_bc)
            return;

        if ((meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {
#ifdef BITSTREAM_SHORTS
            uint16_t *csptr = (uint16_t*) buffer_start;
#else
            unsigned char *csptr = buffer_start;
#endif
            int wcount = (int)(dp - 2 - buffer_start) >> 1;
            uint32_t csum = (uint32_t) -1;

            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)
                return;

#ifdef BITSTREAM_SHORTS
            while (wcount--)
                csum = (csum * 3) + *csptr++;
#else
            WavpackNativeToLittleEndian ((WavpackHeader *) buffer_start, WavpackHeaderFormat);

            while (wcount--) {
                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);
                csptr += 2;
            }

            WavpackLittleEndianToNative ((WavpackHeader *) buffer_start, WavpackHeaderFormat);
#endif

            if (meta_bc == 4) {
                *dp++ = csum;
                *dp++ = csum >> 8;
                *dp++ = csum >> 16;
                *dp++ = csum >> 24;
                return;
            }
            else {
                csum ^= csum >> 16;
                *dp++ = csum;
                *dp++ = csum >> 8;
                return;
            }
        }

        bcount -= meta_bc;
        dp += meta_bc;
    }
}
