wsemul_vt100_output(void *cookie, const u_char *data, u_int count, int kernel)
{
	struct wsemul_vt100_emuldata *edp = cookie;
	struct wsemul_inputstate *instate;
	u_int prev_count, processed = 0;
#ifdef HAVE_JUMP_SCROLL
	int lines;
#endif
	int rc = 0;

#ifdef DIAGNOSTIC
	if (kernel && !edp->console)
		panic("wsemul_vt100_output: kernel output, not console");
#endif

	instate = kernel ? &edp->kstate : &edp->instate;

	switch (edp->abortstate.state) {
	case ABORT_FAILED_CURSOR:
		/*
		 * If we could not display the cursor back, we pretended not
		 * having been able to process the last byte. But this
		 * is a lie, so compensate here.
		 */
		data++, count--;
		processed++;
		wsemul_reset_abortstate(&edp->abortstate);
		break;
	case ABORT_OK:
		/* remove cursor image if visible */
		if (edp->flags & VTFL_CURSORON) {
			rc = (*edp->emulops->cursor)
			    (edp->emulcookie, 0, edp->crow,
#ifdef HAVE_DOUBLE_WIDTH_HEIGHT
			     edp->ccol << edp->dw);
#else
			     edp->ccol);
#endif
			if (rc != 0)
				return 0;
		}
		break;
	default:
		break;
	}

	for (;;) {
#ifdef HAVE_JUMP_SCROLL
		switch (edp->abortstate.state) {
		case ABORT_FAILED_JUMP_SCROLL:
			/*
			 * If we failed a previous jump scroll attempt, we
			 * need to try to resume it with the same distance.
			 * We can not recompute it since there might be more
			 * bytes in the tty ring, causing a different result.
			 */
			lines = edp->abortstate.lines;
			break;
		case ABORT_OK:
			/*
			 * If we are at the bottom of the scrolling area, count
			 * newlines until an escape sequence appears.
			 */
			if ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&
			    ROWS_BELOW == 0)
				lines = wsemul_vt100_jump_scroll(edp, data,
				    count, kernel);
			else
				lines = 0;
			break;
		default:
			/*
			 * If we are recovering a non-scrolling failure,
			 * do not try to scroll yet.
			 */
			lines = 0;
			break;
		}

		if (lines > 1) {
			wsemul_resume_abort(&edp->abortstate);
			rc = wsemul_vt100_scrollup(edp, lines);
			if (rc != 0) {
				wsemul_abort_jump_scroll(&edp->abortstate,
				    lines);
				return processed;
			}
			wsemul_reset_abortstate(&edp->abortstate);
			edp->crow -= lines;
		}
#endif

		wsemul_resume_abort(&edp->abortstate);

		prev_count = count;
		if (wsemul_getchar(&data, &count, instate,
#ifdef HAVE_UTF8_SUPPORT
		    (edp->state == VT100_EMUL_STATE_NORMAL && !kernel) ?
		      edp->flags & VTFL_UTF8 : 0
#else
		    0
#endif
		    ) != 0)
			break;

		if (!(instate->inchar & ~0xff) &&
		    (instate->inchar & 0x7f) < 0x20) {
			rc = wsemul_vt100_output_c0c1(edp, instate, kernel);
			if (rc != 0)
				break;
			processed += prev_count - count;
 			continue;
 		}

		if (edp->state == VT100_EMUL_STATE_NORMAL || kernel) {
			rc = wsemul_vt100_output_normal(edp, instate, kernel);
			if (rc != 0)
				break;
			processed += prev_count - count;
			continue;
		}
#ifdef DIAGNOSTIC
		if (edp->state > nitems(vt100_output))
			panic("wsemul_vt100: invalid state %d", edp->state);
#endif
		rc = vt100_output[edp->state - 1](edp, instate);
		if (rc != 0)
			break;
		processed += prev_count - count;
	}

	if (rc != 0)
		wsemul_abort_other(&edp->abortstate);
	else {
		/* put cursor image back if visible */
		if (edp->flags & VTFL_CURSORON) {
			rc = (*edp->emulops->cursor)
			    (edp->emulcookie, 1, edp->crow,
#ifdef HAVE_DOUBLE_WIDTH_HEIGHT
			     edp->ccol << edp->dw);
#else
			     edp->ccol);
#endif
			if (rc != 0) {
				/*
				 * Pretend the last byte hasn't been processed,
				 * while remembering that only the cursor
				 * operation really needs to be done.
				 */
				wsemul_abort_cursor(&edp->abortstate);
				processed--;
			}
		}
	}

	if (rc == 0)
		wsemul_reset_abortstate(&edp->abortstate);

	return processed;
}
