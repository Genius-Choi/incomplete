wsemul_vt100_output_esc_hash(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	int rc = 0;

	switch (instate->inchar) {
	case '5': /*  DECSWL single width, single height */
#ifdef HAVE_DOUBLE_WIDTH_HEIGHT
		if (edp->dblwid != NULL && edp->dw != 0) {
			int i;
			for (i = 0; i < edp->ncols / 2; i++) {
				WSEMULOP(rc, edp, &edp->abortstate, copycols,
				    (edp->emulcookie, edp->crow, 2 * i, i, 1));
				if (rc != 0)
					return rc;
			}
			WSEMULOP(rc, edp, &edp->abortstate, erasecols,
			    (edp->emulcookie, edp->crow, i, edp->ncols - i,
			     edp->bkgdattr));
			if (rc != 0)
				return rc;
			edp->dblwid[edp->crow] = 0;
			edp->dw = 0;
		}
#endif
		break;
	case '6': /*  DECDWL double width, single height */
	case '3': /*  DECDHL double width, double height, top half */
	case '4': /*  DECDHL double width, double height, bottom half */
#ifdef HAVE_DOUBLE_WIDTH_HEIGHT
		if (edp->dblwid != NULL && edp->dw == 0) {
			int i;
			for (i = edp->ncols / 2 - 1; i >= 0; i--) {
				WSEMULOP(rc, edp, &edp->abortstate, copycols,
				    (edp->emulcookie, edp->crow, i, 2 * i, 1));
				if (rc != 0)
					return rc;
			}
			for (i = 0; i < edp->ncols / 2; i++) {
				WSEMULOP(rc, edp, &edp->abortstate, erasecols,
				    (edp->emulcookie, edp->crow, 2 * i + 1, 1,
				     edp->bkgdattr));
				if (rc != 0)
					return rc;
			}
			edp->dblwid[edp->crow] = 1;
			edp->dw = 1;
			if (edp->ccol > (edp->ncols >> 1) - 1)
				edp->ccol = (edp->ncols >> 1) - 1;
		}
#endif
		break;
	case '8': { /* DECALN */
		int i, j;
		for (i = 0; i < edp->nrows; i++)
			for (j = 0; j < edp->ncols; j++) {
				WSEMULOP(rc, edp, &edp->abortstate, putchar,
				    (edp->emulcookie, i, j, 'E', edp->curattr));
				if (rc != 0)
					return rc;
			}
		}
		edp->ccol = 0;
		edp->crow = 0;
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC# %x unknown\n", instate->inchar);
#endif
		break;
	}

	if (COLS_LEFT != 0)
		edp->flags &= ~VTFL_LASTCHAR;

	edp->state = VT100_EMUL_STATE_NORMAL;
	return 0;
}
