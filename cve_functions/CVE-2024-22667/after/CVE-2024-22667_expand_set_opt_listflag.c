expand_set_opt_listflag(
	optexpand_T *args,
	char_u *flags,
	int *numMatches,
	char_u ***matches)
{
    char_u  *p;
    char_u  *option_val = args->oe_opt_value;
    char_u  *cmdline_val = args->oe_set_arg;
    int	    append = args->oe_append;
    int	    include_orig_val = args->oe_include_orig_val && (*option_val != NUL);

    size_t num_flags = STRLEN(flags);

    // Assume we only have small number of flags, so just allocate max size.
    *matches = ALLOC_MULT(char_u *, num_flags + 1);
    if (*matches == NULL)
	return FAIL;

    int count = 0;

    if (include_orig_val)
    {
	p = vim_strsave(option_val);
	if (p == NULL)
	{
	    VIM_CLEAR(*matches);
	    return FAIL;
	}
	(*matches)[count++] = p;
    }

    for (char_u *flag = flags; *flag != NUL; flag++)
    {
	if (append && vim_strchr(option_val, *flag) != NULL)
	    continue;

	if (vim_strchr(cmdline_val, *flag) == NULL)
	{
	    if (include_orig_val
		    && option_val[1] == NUL
		    && *flag == option_val[0])
	    {
		// This value is already used as the first choice as it's the
		// existing flag. Just skip it to avoid duplicate.
		continue;
	    }
	    p = vim_strnsave(flag, 1);
	    if (p == NULL)
	    {
		if (count == 0)
		{
		    VIM_CLEAR(*matches);
		    return FAIL;
		}
		else
		    break;
	    }
	    (*matches)[count++] = p;
	}
    }

    if (count == 0)
    {
	VIM_CLEAR(*matches);
	return FAIL;
    }
    *numMatches = count;
    return OK;
}
