ExpandSettingSubtract(
    expand_T	*xp,
    regmatch_T	*regmatch,
    int		*numMatches,
    char_u	***matches)
{
    if (expand_option_idx < 0)
	// term option
	return ExpandOldSetting(numMatches, matches);

    char_u *option_val = *(char_u**)get_option_varp_scope(
	expand_option_idx, expand_option_flags);

    long_u option_flags =  options[expand_option_idx].flags;

    if (option_flags & P_NUM)
	return ExpandOldSetting(numMatches, matches);
    else if (option_flags & P_COMMA)
    {
	// Split the option by comma, then present each option to the user if
	// it matches the pattern.
	// This condition needs to go first, because 'whichwrap' has both
	// P_COMMA and P_FLAGLIST.
	garray_T    ga;

	char_u	    *item;
	char_u	    *option_copy;
	char_u	    *next_val;
	char_u	    *comma;

	if (*option_val == NUL)
	    return FAIL;

	// Make a copy as we need to inject null characters destructively.
	option_copy = vim_strsave(option_val);
	if (option_copy == NULL)
	    return FAIL;
	next_val = option_copy;

	ga_init2(&ga, sizeof(char_u *), 10);

	do
	{
	    item = next_val;
	    comma = vim_strchr(next_val, ',');
	    while (comma != NULL && comma != next_val && *(comma - 1) == '\\')
	    {
		// "\," is interpreted as a literal comma rather than option
		// separator when reading options in copy_option_part(). Skip
		// it.
		comma = vim_strchr(comma + 1, ',');
	    }
	    if (comma != NULL)
	    {
		*comma = NUL; // null-terminate this value, required by later functions
		next_val = comma + 1;
	    }
	    else
		next_val = NULL;

	    if (*item == NUL)
		// empty value, don't add to list
		continue;

	    if (!vim_regexec(regmatch, item, (colnr_T)0))
		continue;

	    char_u *buf = escape_option_str_cmdline(item);
	    if (buf == NULL)
	    {
		vim_free(option_copy);
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    if (ga_add_string(&ga, buf) != OK)
	    {
		vim_free(buf);
		break;
	    }
	} while (next_val != NULL);

	vim_free(option_copy);

	*matches = ga.ga_data;
	*numMatches = ga.ga_len;
	return OK;
    }
    else if (option_flags & P_FLAGLIST)
    {
	// Only present the flags that are set on the option as the other flags
	// are not meaningful to do set-= on.

	if (*xp->xp_pattern != NUL)
	{
	    // Don't suggest anything if cmdline is non-empty. Vim's set-=
	    // behavior requires consecutive strings and it's usually
	    // unintuitive to users if they try to subtract multiple flags at
	    // once.
	    return FAIL;
	}

	size_t num_flags = STRLEN(option_val);
	if (num_flags == 0)
	    return FAIL;

	*matches = ALLOC_MULT(char_u *, num_flags + 1);
	if (*matches == NULL)
	    return FAIL;

	int count = 0;
	char_u *p;

	p = vim_strsave(option_val);
	if (p == NULL)
	{
	    VIM_CLEAR(*matches);
	    return FAIL;
	}
	(*matches)[count++] = p;

	if (num_flags > 1)
	{
	    // If more than one flags, split the flags up and expose each
	    // character as individual choice.
	    for (char_u *flag = option_val; *flag != NUL; flag++)
	    {
		p = vim_strnsave(flag, 1);
		if (p == NULL)
		    break;
		(*matches)[count++] = p;
	    }
	}

	*numMatches = count;
	return OK;
    }

    return ExpandOldSetting(numMatches, matches);
}
