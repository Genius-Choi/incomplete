parse_option_name(char_u *arg, int *opt_idxp, int *lenp, int *keyp)
{
    int	key = 0;
    int	len;
    int	opt_idx;

    if (*arg == '<')
    {
	opt_idx = -1;
	// look out for <t_>;>
	if (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])
	    len = 5;
	else
	{
	    len = 1;
	    while (arg[len] != NUL && arg[len] != '>')
		++len;
	}
	if (arg[len] != '>')
	    return FAIL;

	arg[len] = NUL;			    // put NUL after name
	if (arg[1] == 't' && arg[2] == '_') // could be term code
	    opt_idx = findoption(arg + 1);
	arg[len++] = '>';		    // restore '>'
	if (opt_idx == -1)
	    key = find_key_option(arg + 1, TRUE);
    }
    else
    {
	int	nextchar;   // next non-white char after option name

	len = 0;
	// The two characters after "t_" may not be alphanumeric.
	if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3])
	    len = 4;
	else
	    while (ASCII_ISALNUM(arg[len]) || arg[len] == '_')
		++len;
	nextchar = arg[len];
	arg[len] = NUL;			    // put NUL after name
	opt_idx = findoption(arg);
	arg[len] = nextchar;		    // restore nextchar
	if (opt_idx == -1)
	    key = find_key_option(arg, FALSE);
    }

    *keyp = key;
    *lenp = len;
    *opt_idxp = opt_idx;

    return OK;
}
