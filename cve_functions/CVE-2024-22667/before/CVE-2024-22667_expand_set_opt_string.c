expand_set_opt_string(
	optexpand_T *args,
	char **values,
	size_t numValues,
	int *numMatches,
	char_u ***matches)
{
    char_u	*p;
    regmatch_T	*regmatch = args->oe_regmatch;
    int		include_orig_val = args->oe_include_orig_val;
    char_u	*option_val = args->oe_opt_value;

    // Assume numValues is small since they are fixed enums, so just allocate
    // upfront instead of needing two passes to calculate output size.
    *matches = ALLOC_MULT(char_u *, numValues + 1);
    if (*matches == NULL)
	return FAIL;

    int count = 0;

    if (include_orig_val && *option_val != NUL)
    {
	p = vim_strsave(option_val);
	if (p == NULL)
	{
	    VIM_CLEAR(*matches);
	    return FAIL;
	}
	(*matches)[count++] = p;
    }

    for (char **val = values; *val != NULL; val++)
    {
	if (include_orig_val && *option_val != NUL)
	{
	    if (STRCMP((char_u*)*val, option_val) == 0)
		continue;
	}
	if (vim_regexec(regmatch, (char_u*)(*val), (colnr_T)0))
	{
	    p = vim_strsave((char_u*)*val);
	    if (p == NULL)
	    {
		if (count == 0)
		{
		    VIM_CLEAR(*matches);
		    return FAIL;
		}
		else
		    break;
	    }
	    (*matches)[count++] = p;
	}
    }
    if (count == 0)
    {
	VIM_CLEAR(*matches);
	return FAIL;
    }
    *numMatches = count;
    return OK;
}
