set_init_default_backupskip(void)
{
    int		opt_idx;
    long_u	n;
    char_u	*p;
#ifdef UNIX
    static char	*(names[4]) = {"", "TMPDIR", "TEMP", "TMP"};
#else
    static char	*(names[3]) = {"TMPDIR", "TEMP", "TMP"};
#endif
    int		len;
    garray_T	ga;
    char_u	*item;

    opt_idx = findoption((char_u *)"backupskip");

    ga_init2(&ga, 1, 100);
    for (n = 0; n < (long)ARRAY_LENGTH(names); ++n)
    {
	int		mustfree = FALSE;
#ifdef UNIX
	if (*names[n] == NUL)
# ifdef MACOS_X
	    p = (char_u *)"/private/tmp";
# else
	p = (char_u *)"/tmp";
# endif
	else
#endif
	    p = vim_getenv((char_u *)names[n], &mustfree);
	if (p != NULL && *p != NUL)
	{
	    // First time count the NUL, otherwise count the ','.
	    len = (int)STRLEN(p) + 3;
	    item = alloc(len);
	    if (item != NULL)
	    {
		STRCPY(item, p);
		add_pathsep(item);
		STRCAT(item, "*");
		if (find_dup_item(ga.ga_data, item, options[opt_idx].flags)
									== NULL
			&& ga_grow(&ga, len) == OK)
		{
		    if (ga.ga_len > 0)
			STRCAT(ga.ga_data, ",");
		    STRCAT(ga.ga_data, item);
		    ga.ga_len += len;
		}
		vim_free(item);
	    }
	}
	if (mustfree)
	    vim_free(p);
    }
    if (ga.ga_data != NULL)
    {
	set_string_default("bsk", ga.ga_data);
	vim_free(ga.ga_data);
    }
}
