do_set_option(
    int		opt_flags,
    char_u	**argp,
    char_u	*arg_start,
    char_u	**startarg,
    int		*did_show,
    int		*stopopteval,
    char	*errbuf,
    size_t	errbuflen)
{
    int		opt_idx;
    char_u	*arg;
    set_prefix_T prefix;	// no prefix, "no" prefix or "inv" prefix
    set_op_T	op;
    long_u	flags;		// flags for current option
    char_u	*varp;		// pointer to variable for current option
    char_u	key_name[2];
    int		nextchar;	// next non-white char after option name
    int		afterchar;	// character just after option name
    char	*errmsg = NULL;
    int		key;
    int		len;

    prefix = get_option_prefix(argp);
    arg = *argp;

    // find end of name
    key = 0;
    if (parse_option_name(arg, &opt_idx, &len, &key) == FAIL)
	return e_invalid_argument;

    // remember character after option name
    afterchar = arg[len];

    if (in_vim9script())
    {
	char_u *p = skipwhite(arg + len);

	// disallow white space before =val, +=val, -=val, ^=val
	if (p > arg + len && (p[0] == '='
		    || (vim_strchr((char_u *)"+-^", p[0]) != NULL
			&& p[1] == '=')))
	{
	    errmsg = e_no_white_space_allowed_between_option_and;
	    arg = p;
	    *startarg = p;
	    goto skip;
	}
    }
    else
	// skip white space, allow ":set ai  ?", ":set hlsearch  !"
	while (VIM_ISWHITE(arg[len]))
	    ++len;

    op = get_opt_op(arg + len);
    if (op != OP_NONE)
	len++;

    nextchar = arg[len];

    if (opt_idx == -1 && key == 0)	// found a mismatch: skip
    {
	if (in_vim9script() && arg > arg_start
		&& vim_strchr((char_u *)"!&<", *arg) != NULL)
	    errmsg = e_no_white_space_allowed_between_option_and;
	else
	    errmsg = e_unknown_option;
	goto skip;
    }

    if (opt_idx >= 0)
    {
	if (options[opt_idx].var == NULL)   // hidden option: skip
	{
	    // Only give an error message when requesting the value of
	    // a hidden option, ignore setting it.
	    if (vim_strchr((char_u *)"=:!&<", nextchar) == NULL
		    && (!(options[opt_idx].flags & P_BOOL)
			|| nextchar == '?'))
		errmsg = e_option_not_supported;
	    goto skip;
	}

	flags = options[opt_idx].flags;
	varp = get_varp_scope(&(options[opt_idx]), opt_flags);
    }
    else
    {
	flags = P_STRING;
	varp = NULL;
	if (key < 0)
	{
	    key_name[0] = KEY2TERMCAP0(key);
	    key_name[1] = KEY2TERMCAP1(key);
	}
	else
	{
	    key_name[0] = KS_KEY;
	    key_name[1] = (key & 0xff);
	}
    }

    // Make sure the option value can be changed.
    if (validate_opt_idx(opt_idx, opt_flags, flags, &errmsg) == FAIL)
	goto skip;

    int cp_val = p_cp;
    if (vim_strchr((char_u *)"?=:!&<", nextchar) != NULL)
    {
	arg += len;
	if (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i')
	{
	    if (arg[3] == 'm')	// "opt&vim": set to Vim default
	    {
		cp_val = FALSE;
		arg += 3;
	    }
	    else		// "opt&vi": set to Vi default
	    {
		cp_val = TRUE;
		arg += 2;
	    }
	}
	if (vim_strchr((char_u *)"?!&<", nextchar) != NULL
		&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))
	{
	    errmsg = e_trailing_characters;
	    goto skip;
	}
    }

    // Allow '=' and ':' for historical reasons (MSDOS command.com).
    // Allows only one '=' character per "set" command line. grrr. (jw)
    if (nextchar == '?'
	    || (prefix == PREFIX_NONE
		&& vim_strchr((char_u *)"=:&<", nextchar) == NULL
		&& !(flags & P_BOOL)))
    {
	// print value
	if (*did_show)
	    msg_putchar('\n');	    // cursor below last one
	else
	{
	    gotocmdline(TRUE);	    // cursor at status line
	    *did_show = TRUE;	    // remember that we did a line
	}
	if (opt_idx >= 0)
	{
	    showoneopt(&options[opt_idx], opt_flags);
#ifdef FEAT_EVAL
	    if (p_verbose > 0)
	    {
		// Mention where the option was last set.
		if (varp == options[opt_idx].var)
		    last_set_msg(options[opt_idx].script_ctx);
		else if ((int)options[opt_idx].indir & PV_WIN)
		    last_set_msg(curwin->w_p_script_ctx[
			    (int)options[opt_idx].indir & PV_MASK]);
		else if ((int)options[opt_idx].indir & PV_BUF)
		    last_set_msg(curbuf->b_p_script_ctx[
			    (int)options[opt_idx].indir & PV_MASK]);
	    }
#endif
	}
	else
	{
	    char_u	    *p;

	    p = find_termcode(key_name);
	    if (p == NULL)
	    {
		errmsg = e_key_code_not_set;
		goto skip;
	    }
	    else
		(void)show_one_termcode(key_name, p, TRUE);
	}
	if (nextchar != '?'
		&& nextchar != NUL && !VIM_ISWHITE(afterchar))
	    errmsg = e_trailing_characters;
    }
    else
    {
	errmsg = do_set_option_value(opt_idx, opt_flags, &arg, prefix, op,
					flags, varp, key_name, nextchar,
					afterchar, cp_val, stopopteval, errbuf,
					errbuflen);
    }

skip:
    *argp = arg;
    return errmsg;
}
