expand_set_highlight(optexpand_T *args, int *numMatches, char_u ***matches)
{
    char_u	    *p;
    expand_T	    *xp = args->oe_xp;
    static char_u   hl_flags[HLF_COUNT] = HL_FLAGS;
    size_t	    i;
    int		    count = 0;

    if (xp->xp_pattern > args->oe_set_arg && *(xp->xp_pattern-1) == ':')
    {
	// Right after a ':', meaning we just return all highlight names.
	return expand_set_opt_generic(
		args,
		get_highlight_name,
		numMatches,
		matches);
    }

    if (*xp->xp_pattern == NUL)
    {
	// At beginning of a comma-separated list. Return the specific list of
	// supported occasions.
	*matches = ALLOC_MULT(char_u *, HLF_COUNT + 1);
	if (*matches == NULL)
	    return FAIL;

	// We still want to return the full option if it's requested.
	if (args->oe_include_orig_val)
	{
	    p = vim_strsave(args->oe_opt_value);
	    if (p == NULL)
	    {
		VIM_CLEAR(*matches);
		return FAIL;
	    }
	    (*matches)[count++] = p;
	}

	for (i = 0; i < HLF_COUNT; i++)
	{
	    p = vim_strnsave(&hl_flags[i], 1);
	    if (p == NULL)
	    {
		if (count == 0)
		{
		    VIM_CLEAR(*matches);
		    return FAIL;
		}
		else
		    break;
	    }
	    (*matches)[count++] = p;
	}

	if (count == 0)
	{
	    VIM_CLEAR(*matches);
	    return FAIL;
	}
	*numMatches = count;
	return OK;
    }

    // We are after the initial character (which indicates the occasion). We
    // already made sure we are not matching after a ':' above, so now we want
    // to match against display mode modifiers.
    // Since the xp_pattern starts from the beginning, we need to include it in
    // the returned match.

    // Note: Keep this in sync with highlight_changed()
    static char_u p_hl_mode_values[] =
	{':', 'b', 'i', '-', 'n', 'r', 's', 'u', 'c', '2', 'd', '=', 't'};
    size_t num_hl_modes = ARRAY_LENGTH(p_hl_mode_values);

    *matches = ALLOC_MULT(char_u *, num_hl_modes);
    if (*matches == NULL)
	return FAIL;

    int pattern_len = xp->xp_pattern_len;

    for (i = 0; i < num_hl_modes; i++)
    {
	// Don't allow duplicates as these are unique flags
	char_u *dup = vim_strchr(xp->xp_pattern + 1, p_hl_mode_values[i]);
	if (dup != NULL && (int)(dup - xp->xp_pattern) < pattern_len)
	    continue;

	// ':' only works by itself, not with other flags.
	if (pattern_len > 1 && p_hl_mode_values[i] == ':')
	    continue;

	p = vim_strnsave(xp->xp_pattern, pattern_len + 1);
	if (p == NULL)
	{
	    if (i == 0)
	    {
		VIM_CLEAR(*matches);
		return FAIL;
	    }
	    else
		break;
	}
	p[pattern_len] = p_hl_mode_values[i];
	p[pattern_len + 1] = NUL;
	(*matches)[count++] = p;
    }
    if (count == 0)
    {
	VIM_CLEAR(*matches);
	return FAIL;
    }
    *numMatches = count;

    return OK;
}
