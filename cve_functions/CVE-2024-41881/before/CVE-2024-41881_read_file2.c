read_file2(uschar *filename, item **nest_stack, int *nest_stackptr)
{
item *fn;
uschar *p;
uschar buffer1[LINEBUFSIZE];
uschar buffer2[LINEBUFSIZE];

linebuffer = buffer1;      /* For use when comments overflow lines */

if (filename == NULL)
  {
  DEBUG(D_any) debug_printf("===> Reading from stdin\n");
  infile = stdin;
  }
else
  {
  DEBUG(D_any) debug_printf("===> Reading from %s\n", filename);
  infile = Ufopen(filename, "rb");
  if (infile == NULL)
    (void)error(0, filename, "input file", strerror(errno));  /* Hard */
  }

read_filename = (filename == NULL)? US"(stdin)" : filename;
read_linenumber = 0;

/* Stick in a dummy element to hold the file name so we can distinguish
included files in error messages. */

fn = misc_malloc(sizeof(item));
fn->prev = read_addto;
fn->next = read_addto->next;
fn->linenumber = 0;
fn->flags = 0;
fn->partner = fn;
Ustrcpy(fn->name, "#FILENAME");
fn->p.string = misc_malloc(Ustrlen(read_filename) + 1);
Ustrcpy(fn->p.string, read_filename);

read_addto->next = fn;
read_addto = fn;

/* Now process the lines of the file */

while ((p = Ufgets(buffer1, sizeof(buffer1), infile)) != NULL)
  {
  uschar *pp = p + Ustrlen(p);

  /* Retain the newline on the end of the line, but remove any white space
  that precedes it. */

  while (pp > p + 1)
    {
    if (!isspace(pp[-2])) break;
    (pp--)[-2] = '\n';
    }
  *pp = 0;

  read_linenumber++;

  /* Unless we are in <literallayout>, remove leading whitespace before
  processing the line. This is an optimization just to save storing all those
  leading spaces when the input is indented. The later code would in fact work
  without it. */

  if (!inliterallayout) while (isspace(*p)) p++;

  /* The <quote> and </quote> elements get converted into quote characters, and
  so are not like other elements. We do the conversion here so that they do not
  interrupt strings of data. Otherwise, there can be problems when </quote> is
  at the end of a line (because of the way newline is handled). These elements
  are presumed not to be very common, so I've done this quite crudely. */

  while ((pp = Ustrstr(p, "<quote>")) != NULL ||
         (pp = Ustrstr(p, "</quote>")) != NULL)
    {
    int len;
    uschar *c, *pn;
    if (pp[1] == '/')
      {
      c = US"&#x201D;";
      len = 8;
      }
    else
      {
      c = US"&#x201C;";
      len = 7;
      }
    memcpy(buffer2, p, pp - p);
    pn = buffer2 + (pp - p);
    memcpy(pn, c, 8);
    Ustrcpy(pn + 8, pp + len);
    Ustrcpy(buffer1, buffer2);
    p = buffer1;
    }

  /* Now process the input line */

  read_string(p, nest_stack, nest_stackptr, 0);
  }

(void)fclose(infile);
read_linenumber = 0;
return TRUE;
}
