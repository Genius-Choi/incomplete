read_element(uschar *p, item **nest_stack, int *nest_ptrptr)
{
BOOL ender = FALSE;
BOOL procinst = FALSE;
int i = 0;
int nest_stackptr = *nest_ptrptr;
int elementstartline = read_linenumber;
uschar name[DBNAMESIZE];
uschar *pp = name;
item *new;

/* Handle special kinds of markup:

  <?.....?> is a processing instruction - ignore unless for sdop
  <!......> is a heading (?) - currently ignored
  <!--..--> is a comment that may span multiple lines, and be nested (?)
  <![CDATA[....]]> is literal character data, possibly spanning linebreaks
*/

if (*(++p) == '?')
  {
  if (Ustrncmp(p, "?sdop", 5) != 0 || !isspace(p[5]))
    {
    for (;;)
      {
      while (*(++p) != 0 && *p != '>');
      if (*p == '>')
        {
        p++;
        return p;
        }
      p = Ufgets(linebuffer, LINEBUFSIZE, infile);
      read_linenumber++;
      if (p == NULL) (void)error(89, elementstartline);  /* Hard */
      }
    }

  /* We have a processing instruction for sdop. Arrange to set this up
  as an item whose name is "?sdop", with appropriate attributes. We can do this
  by setting the leading '?' and then falling through. */

  procinst = TRUE;
  *pp++ = '?';
  i++;
  p++;
  }

/* Handle CDATA, headings, and comments */

else if (*p == '!')
  {
  int nestcount;

  if (Ustrncmp(p, "![CDATA[", 8) == 0)
    {
    BOOL incdata = TRUE;
    p += 8;
    for (;;)
      {
      uschar *ppp;
      p = read_text(p, &incdata, 0);
      if (!incdata)break;
      ppp = Ufgets(linebuffer, LINEBUFSIZE, infile);
      read_linenumber++;
      if (ppp == NULL) (void)error(88, elementstartline);  /* Hard */
        else p = ppp;
      }
    return p;
    }

  /* If not a comment, just skip to the closing '>' */

  if (Ustrncmp(p, "!--", 3) != 0)
    {
    while (*(++p) != 0 && *p != '>');
    if (*p == '>') p++;
    return p;
    }

  /* Handle comments */

  nestcount = 1;
  p += 3;

  while (nestcount > 0)
    {
    while (*p != 0)
      {
      if (Ustrncmp(p, "-->", 3) == 0)
        {
        p += 3;
        if (--nestcount <= 0) break;
        }
      else if (Ustrncmp(p, "<!--", 4) == 0)
        {
        nestcount++;
        p += 4;
        }
      else p++;
      }

    /* Comment continues onto the next line */

    if (*p == 0 && nestcount > 0)
      {
      uschar *ppp = Ufgets(linebuffer, LINEBUFSIZE, infile);
      read_linenumber++;
      if (ppp == NULL) (void)error(18, elementstartline);  /* Hard */
        else p = ppp;
      }
    }

  return p;
  }

/* Handle "normal" markup: test for an ending tag. */

if (*p == '/') { ender = TRUE; p++; }

/* Scan for the element name */

while (isalnum(*p) || *p == '_' || *p == '-' || *p == '.')
  {
  if (i++ < DBNAMESIZE - 1) *pp++ = *p;
  p++;
  }
*pp = 0;

/* Deal with an ending tag */

if (ender)
  {
  item *partner;

  if (Ustrcmp(name, "chapter") == 0)
    inchapter = insection = insubsection = 0;

  else if (Ustrcmp(name, "preface") == 0)
    inpreface = FALSE;

  else if (ISSECT(name))
    {
    if (insubsection > 0) insubsection = 0;
      else insection = insubsection = 0;
    }

  else if (Ustrcmp(name, "appendix") == 0)
    inappendix = insection = insubsection = 0;

  else if (Ustrcmp(name, "literallayout") == 0)
    inliterallayout = FALSE;

  if (*p != '>')
    {
    (void)error(2, name);
    while (*p != 0 && *p != '>') p++;
    }

  else
    {
    p++;
    if (nest_stackptr <= 0)
      {
      (void)error(3, name);
      }
    else if (Ustrcmp(nest_stack[nest_stackptr-1]->name, name) != 0)
      {
      (void)error(85, name, nest_stack[nest_stackptr-1]->name);
      }
    else
      {
      partner = nest_stack[--nest_stackptr];
      new = misc_malloc(sizeof(item));
      new->prev = read_addto;
      new->next = read_addto->next;
      if (new->next != NULL) new->next->prev = new;
      new->linenumber = read_linenumber;
      new->flags = 0;
      Ustrcpy(new->name, "/");
      new->p.param = NULL;
      read_addto->next = new;
      read_addto = new;

      new->partner = partner;
      partner->partner = new;
      }
    }
  }

/* Deal with a starting tag */

else
  {
  BOOL ended = FALSE;
  BOOL numbered = FALSE;
  tree_node *tn = NULL;
  paramstr *param = NULL;
  paramstr *lastparam = NULL;
  paramstr *newparam;

  if (Ustrcmp(name, "preface") == 0)
    inpreface = TRUE;

  else if (Ustrcmp(name, "chapter") == 0)
    {
    inchapter = ++chapter_number;
    insection = insubsection = 0;
    section_number = subsection_number = 0;
    numbered = TRUE;
    }

  else if (Ustrcmp(name, "appendix") == 0)
    {
    inappendix = ++appendix_number;
    insection = insubsection = 0;
    section_number = subsection_number = 0;
    numbered = TRUE;
    }

  else if (ISSECT(name) && !inpreface)
    {
    if (insection > 0)
      {
      insubsection = ++subsection_number;
      }
    else
      {
      insection = ++section_number;
      insubsection = 0;
      subsection_number = 0;
      }
    numbered = TRUE;
    }

  else if (Ustrcmp(name, "literallayout") == 0)
    inliterallayout = TRUE;

  if (numbered)
    {
    param = lastparam = misc_malloc(sizeof(paramstr) + 16);
    param->next = NULL;
    param->seen = TRUE;
    Ustrcpy(param->name, "#number");
    pp = param->value;
    if (inchapter > 0) pp += sprintf(CS pp, "%d", inchapter);
    if (inappendix > 0) pp += sprintf(CS pp, "%c", 'A' + inappendix - 1);
    if (insection > 0) pp += sprintf(CS pp, "%s%d",
      (pp == param->value)? "" : ".", insection);
    if (insubsection > 0) pp += sprintf(CS pp, "%s%d",
      (pp == param->value)? "" : ".", insubsection);
    }

  /* Now read any attributes that are set in the element. This may continue
  onto more than one line. */

  while (isspace(*p)) p++;
  for (;;)
    {
    int quote, dlen;
    uschar attname[DBNAMESIZE];

    /* Handle line continuations */

    while (*p == 0)
      {
      uschar *pnew = Ufgets(linebuffer, LINEBUFSIZE, infile);
      read_linenumber++;
      if (pnew == NULL)
        {
        (void)error(24, elementstartline);
        break;
        }
      else p = pnew;
      while (isspace(*p)) p++;
      }

    /* Test for end of the element */

    if (*p == '>' || *p == '/' || *p == '?')  break;

    /* Now read the name of the attribute */

    pp = attname;
    i = 0;
    while (isalnum(*p) || *p == '-' || *p == '_' || *p == '.')
      {
      if (i++ < DBNAMESIZE - 1) *pp++ = *p;
      p++;
      }
    *pp = 0;

    while (isspace(*p)) p++;
    if (*p != '=') { (void)error(6, attname); break; }
    while (isspace(*(++p)));
    if (*p != '"' && *p != '\'') { (void)error(7, attname); break; }
    quote = *p++;
    pp = p;

    while (*p != 0 && *p != quote) p++;
    if (*p != quote) { (void)error(8, quote, attname, quote); break; }

    dlen = p - pp;
    newparam = misc_malloc(sizeof(paramstr) + dlen);
    newparam->next = NULL;
    newparam->seen = FALSE;
    Ustrcpy(newparam->name, attname);
    Ustrncpy(newparam->value, pp, dlen);
    newparam->value[dlen] = 0;

    if (param == NULL) param = newparam;
      else lastparam->next = newparam;
    lastparam = newparam;
    while (isspace(*(++p)));

    /* If the attribute is "id", add it to the id tree */

    if (Ustrcmp(attname, "id") == 0)
      {
      tn = misc_malloc(sizeof(tree_node) + dlen);
      Ustrcpy(tn->name, newparam->value);
      if (!tree_insertnode(&id_tree, tn)) (void)error(11, tn->name);
      }
    }

  if (*p == '/' || (procinst && *p == '?'))
    {
    ended = TRUE;
    if (*(++p) != '>') (void)error(9, name);
    }

  /* Skip to end of element (in case jumped out after an error) */

  while (*p != 0 && *p != '>') p++;
  if (*p == 0) (void)error(5, name); else p++;

  /* Create the new element, crossreference it's id, note if it or any of its
  attributes are not supported, and push it onto the stack for checking its
  partner. */

  new = misc_malloc(sizeof(item));
  new->linenumber = read_linenumber;
  new->flags = 0;
  new->partner = ended? new : NULL;
  Ustrcpy(new->name, name);
  new->p.param = param;

  new->prev = read_addto;
  new->next = read_addto->next;
  if (new->next != NULL) new->next->prev = new;
  read_addto->next = new;
  read_addto = new;

  if (tn != NULL) tn->data.ptr = new;
  if (new->name[0] != '?') check_supported(new);

  if (!ended)
    {
    if (nest_stackptr >= NESTSTACKSIZE) (void)error(4);  /* Hard error */
    nest_stack[nest_stackptr++] = new;
    }

  /* Remember if this is the first <preface> element. */

  if (inpreface && preface_item_list == NULL) preface_item_list = new;
  }

/* Update stack pointer and return char pointer */

*nest_ptrptr = nest_stackptr;
return p;
}
