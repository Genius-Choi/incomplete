Status Tensor::BitcastFrom(const Tensor& other, DataType dtype,
                           const TensorShape& shape) {
  int in_size = DataTypeSize(other.dtype());
  int out_size = DataTypeSize(dtype);
  if (in_size == 0) {
    return errors::InvalidArgument("other tensor has zero-sized data type");
  }
  if (out_size == 0) {
    return errors::InvalidArgument("specified output type is zero-sized");
  }
  if (shape.num_elements() * out_size !=
      other.shape().num_elements() * in_size) {
    return errors::InvalidArgument(
        "input and output shapes/data type sizes are not compatible");
  }
  shape_ = shape;
  shape_.set_data_type(dtype);
  if (buf_ != other.buf_) {
    UnrefIfNonNull(buf_);
    if (port::kLittleEndian || in_size == out_size) {
      buf_ = other.buf_;
      RefIfNonNull(buf_);
    } else {
      Tensor ts_ = tensor::DeepCopy(other);
      buf_ = ts_.buf_;
      TF_RETURN_IF_ERROR(
          tsl::ByteSwapArray((char*)(buf_->root_buffer()->data()), in_size,
                             other.shape().num_elements()));
      TF_RETURN_IF_ERROR(
          tsl::ByteSwapArray((char*)(buf_->root_buffer()->data()), out_size,
                             shape.num_elements()));
      RefIfNonNull(buf_);
    }
  }
  return OkStatus();
}
