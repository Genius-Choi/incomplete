int h1_parse_xfer_enc_header(struct h1m *h1m, struct ist value)
{
	char *e, *n;
	struct ist word;

	h1m->flags |= H1_MF_XFER_ENC;

	word.ptr = value.ptr - 1; // -1 for next loop's pre-increment
	e = istend(value);

	while (++word.ptr < e) {
		/* skip leading delimiter and blanks */
		if (HTTP_IS_LWS(*word.ptr))
			continue;

		n = http_find_hdr_value_end(word.ptr, e); // next comma or end of line
		word.len = n - word.ptr;

		/* trim trailing blanks */
		while (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))
			word.len--;

		h1m->flags &= ~H1_MF_CHNK;
		if (isteqi(word, ist("chunked"))) {
			if (h1m->flags & H1_MF_TE_CHUNKED) {
				/* cf RFC7230#3.3.1 : A sender MUST NOT apply
				 * chunked more than once to a message body
				 * (i.e., chunking an already chunked message is
				 * not allowed)
				 */
				goto fail;
			}
			h1m->flags |= (H1_MF_TE_CHUNKED|H1_MF_CHNK);
		}
		else {
			if ((h1m->flags & (H1_MF_RESP|H1_MF_TE_CHUNKED)) == H1_MF_TE_CHUNKED) {
				/* cf RFC7230#3.3.1 : If any transfer coding
				 * other than chunked is applied to a request
				 * payload body, the sender MUST apply chunked
				 * as the final transfer coding to ensure that
				 * the message is properly framed.
				 */
				goto fail;
			}
			h1m->flags |= H1_MF_TE_OTHER;
		}

		word.ptr = n;
	}

	return 1;
  fail:
	return -1;
}
