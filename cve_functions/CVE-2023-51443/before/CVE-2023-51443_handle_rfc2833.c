static handle_rfc2833_result_t handle_rfc2833(switch_rtp_t *rtp_session, switch_size_t bytes, int *do_cng)
{

	if (rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]) {
		rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]++;

		if (rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] > DTMF_SANITY) {
			rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = 0;
		} else {
			rtp_session->stats.inbound.last_processed_seq = 0;
		}
	}


#ifdef DEBUG_2833
	if (rtp_session->dtmf_data.in_digit_sanity && !(rtp_session->dtmf_data.in_digit_sanity % 100)) {
		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "sanity %d %ld\n", rtp_session->dtmf_data.in_digit_sanity, bytes);
	}
#endif

	if (rtp_session->dtmf_data.in_digit_sanity && !--rtp_session->dtmf_data.in_digit_sanity) {

		rtp_session->dtmf_data.last_digit = 0;
		rtp_session->dtmf_data.in_digit_ts = 0;
		rtp_session->dtmf_data.in_digit_queued = 0;
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Failed DTMF sanity check.\n");
	}

	if (!bytes) return RESULT_CONTINUE;


	/* RFC2833 ... like all RFC RE: VoIP, guaranteed to drive you to insanity!
	   We know the real rules here, but if we enforce them, it's an interop nightmare so,
	   we put up with as much as we can so we don't have to deal with being punished for
	   doing it right. Nice guys finish last!
	*/

	if (bytes > rtp_header_len && !rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] &&
		rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {
		switch_size_t len = bytes - rtp_header_len;
		unsigned char *packet = (unsigned char *) RTP_BODY(rtp_session);
		int end;
		uint16_t duration;
		char key;
		uint16_t in_digit_seq;
		uint32_t ts;

		rtp_session->stats.inbound.last_processed_seq = 0;

		if (!(packet[0] || packet[1] || packet[2] || packet[3]) && len >= 8) {
			packet += 4;
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, "DTMF payload offset by 4 bytes.\n");
		}

		if (!(packet[0] || packet[1] || packet[2] || packet[3]) && rtp_session->dtmf_data.in_digit_ts) {
			switch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, "__session");
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, "Failed DTMF payload check.\n");
			rtp_session->dtmf_data.last_digit = 0;
			rtp_session->dtmf_data.in_digit_ts = 0;
			rtp_session->dtmf_data.in_digit_sanity = 0;
			rtp_session->dtmf_data.in_digit_queued = 0;
		}

		end = packet[1] & 0x80 ? 1 : 0;
		duration = (packet[2] << 8) + packet[3];
		key = switch_rfc2833_to_char(packet[0]);
		in_digit_seq = ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);
		ts = htonl(rtp_session->last_rtp_hdr.ts);

		if (rtp_session->flags[SWITCH_RTP_FLAG_PASS_RFC2833]) {

			if (end) {
				rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = DTMF_SANITY - 3;
			} else if (!rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]) {
				rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] = 1;
			}

			return RESULT_CONTINUE;
		}

		if (in_digit_seq < rtp_session->dtmf_data.in_digit_seq) {
			if (rtp_session->dtmf_data.in_digit_seq - in_digit_seq > 100) {
				rtp_session->dtmf_data.in_digit_seq = 0;
			}
		}
#ifdef DEBUG_2833
		if (!(packet[0] || packet[1] || packet[2] || packet[3]) && len >= 8) {
			len -= 4;
		}
		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "packet[%d]: %02x %02x %02x %02x\n", (int) len, (unsigned char) packet[0], (unsigned char) packet[1], (unsigned char) packet[2], (unsigned char) packet[3]);
#endif

		if (in_digit_seq > rtp_session->dtmf_data.in_digit_seq) {

			rtp_session->dtmf_data.in_digit_seq = in_digit_seq;
#ifdef DEBUG_2833

			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "read: %c %u %u %u %u %d %d %s\n",
							  key, in_digit_seq, rtp_session->dtmf_data.in_digit_seq,
				   ts, duration, rtp_session->last_rtp_hdr.m, end, end && !rtp_session->dtmf_data.in_digit_ts ? "ignored" : "");
#endif


			if (rtp_session->dtmf_data.in_digit_ts && rtp_session->dtmf_data.in_digit_ts != ts) {
				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "TS changed from last packet, resetting....\n");
				rtp_session->dtmf_data.last_digit = 0;
				rtp_session->dtmf_data.in_digit_ts = 0;
				rtp_session->dtmf_data.in_digit_sanity = 0;
				rtp_session->dtmf_data.in_digit_queued = 0;
			}


			if (!rtp_session->dtmf_data.in_digit_queued && rtp_session->dtmf_data.in_digit_ts) {
				if ((rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION)) {
					switch_dtmf_t dtmf = { key, switch_core_min_dtmf_duration(0), 0, SWITCH_DTMF_RTP };
#ifdef DEBUG_2833
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Early Queuing digit %c:%d\n", dtmf.digit, dtmf.duration / 8);
#endif
					switch_rtp_queue_rfc2833_in(rtp_session, &dtmf);
					rtp_session->dtmf_data.in_digit_queued = 1;
				}

				if (rtp_session->jb && (rtp_session->rtp_bugs & RTP_BUG_FLUSH_JB_ON_DTMF)) {
					switch_jb_reset(rtp_session->jb);
				}

			}

			/* only set sanity if we do NOT ignore the packet */
			if (rtp_session->dtmf_data.in_digit_ts) {
				rtp_session->dtmf_data.in_digit_sanity = 2000;
			}

			if (rtp_session->dtmf_data.last_duration > duration &&
				rtp_session->dtmf_data.last_duration > 0xFC17 && ts == rtp_session->dtmf_data.in_digit_ts) {
				rtp_session->dtmf_data.flip++;
			}

			if (end) {
				if (!rtp_session->dtmf_data.in_digit_ts && rtp_session->dtmf_data.last_in_digit_ts != ts) {
#ifdef DEBUG_2833
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "start with end packet %d\n", ts);
#endif
					rtp_session->dtmf_data.last_in_digit_ts = ts;
					rtp_session->dtmf_data.in_digit_ts = ts;
					rtp_session->dtmf_data.first_digit = key;
					rtp_session->dtmf_data.in_digit_sanity = 2000;
				}
				if (rtp_session->dtmf_data.in_digit_ts) {
					switch_dtmf_t dtmf = { key, duration, 0, SWITCH_DTMF_RTP };

					if (ts > rtp_session->dtmf_data.in_digit_ts) {
						dtmf.duration += (ts - rtp_session->dtmf_data.in_digit_ts);
					}
					if (rtp_session->dtmf_data.flip) {
						dtmf.duration += rtp_session->dtmf_data.flip * 0xFFFF;
						rtp_session->dtmf_data.flip = 0;
#ifdef DEBUG_2833
						switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "you're welcome!\n");
#endif
					}
#ifdef DEBUG_2833
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "done digit=%c ts=%u start_ts=%u dur=%u ddur=%u\n",
						   dtmf.digit, ts, rtp_session->dtmf_data.in_digit_ts, duration, dtmf.duration);
#endif

					if (!(rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION) && !rtp_session->dtmf_data.in_digit_queued) {
#ifdef DEBUG_2833
						switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Queuing digit %c:%d\n", dtmf.digit, dtmf.duration / 8);
#endif
						switch_rtp_queue_rfc2833_in(rtp_session, &dtmf);
					}

					rtp_session->dtmf_data.last_digit = rtp_session->dtmf_data.first_digit;

					rtp_session->dtmf_data.in_digit_ts = 0;
					rtp_session->dtmf_data.in_digit_sanity = 0;
					rtp_session->dtmf_data.in_digit_queued = 0;
					*do_cng = 1;
				} else {
					if (!switch_rtp_ready(rtp_session)) {
						return RESULT_GOTO_END;
					}
					switch_cond_next();
					return RESULT_GOTO_RECVFROM;
				}

			} else if (!rtp_session->dtmf_data.in_digit_ts) {
#ifdef DEBUG_2833
				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "start %d [%c]\n", ts, key);
#endif
				rtp_session->dtmf_data.in_digit_ts = ts;
				rtp_session->dtmf_data.last_in_digit_ts = ts;
				rtp_session->dtmf_data.first_digit = key;
				rtp_session->dtmf_data.in_digit_sanity = 2000;
			}

			rtp_session->dtmf_data.last_duration = duration;
		} else {
#ifdef DEBUG_2833
			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "drop: %c %u %u %u %u %d %d\n",
				   key, in_digit_seq, rtp_session->dtmf_data.in_digit_seq, ts, duration, rtp_session->last_rtp_hdr.m, end);
#endif
			switch_cond_next();
			return RESULT_GOTO_RECVFROM;
		}
	}

	if (rtp_session->dtmf_data.in_digit_ts) {
		if (!switch_rtp_ready(rtp_session)) {
			return RESULT_GOTO_END;
		}

		if (!rtp_session->dtmf_data.in_interleaved && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te) {
			/* Drat, they are sending audio still as well as DTMF ok fine..... *sigh* */
			rtp_session->dtmf_data.in_interleaved = 1;
		}

		if (rtp_session->dtmf_data.in_interleaved || (rtp_session->rtp_bugs & RTP_BUG_IGNORE_DTMF_DURATION)) {
			if (rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {
				return RESULT_GOTO_RECVFROM;
			}
		} else {
			*do_cng = 1;
			return RESULT_GOTO_TIMERCHECK;
		}
	}

	return RESULT_CONTINUE;
}
