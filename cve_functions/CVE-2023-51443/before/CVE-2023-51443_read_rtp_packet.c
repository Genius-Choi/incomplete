static switch_status_t read_rtp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes, switch_frame_flag_t *flags,
									   payload_map_t **pmapP, switch_status_t poll_status, switch_bool_t return_jb_packet)
{
	switch_status_t status = SWITCH_STATUS_FALSE;
	uint32_t ts = 0;
	unsigned char *b = NULL;
	int sync = 0;
	switch_time_t now;
	switch_size_t xcheck_jitter = 0;
	int tries = 0;
	int block = 0;

	switch_assert(bytes);
 more:

	tries++;

	if (tries > 20) {
		if (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {
			switch_jb_reset(rtp_session->jb);
		}
		rtp_session->punts++;
		rtp_session->clean = 0;
		*bytes = 0;
		return SWITCH_STATUS_BREAK;
	}

	if (block) {
		int to = 20000;
		int fdr = 0;

		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
			to = 100000;
		} else {
			if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->timer.interval) {
				to = rtp_session->timer.interval * 1000;
			}
		}

		poll_status = switch_poll(rtp_session->read_pollfd, 1, &fdr, to);

		if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->timer.interval) {
			switch_core_timer_sync(&rtp_session->timer);
		}

		if (rtp_session->session) {
			switch_ivr_parse_all_messages(rtp_session->session);
		}

		block = 0;
	}

	*bytes = sizeof(rtp_msg_t);
	sync = 0;

	rtp_session->has_rtp = 0;
	rtp_session->has_ice = 0;
	rtp_session->has_rtcp = 0;
	if (rtp_session->dtls) {
		rtp_session->dtls->bytes = 0;
		rtp_session->dtls->data = NULL;
	}
	memset(&rtp_session->last_rtp_hdr, 0, sizeof(rtp_session->last_rtp_hdr));

	if (poll_status == SWITCH_STATUS_SUCCESS) {
		status = switch_socket_recvfrom(rtp_session->from_addr, rtp_session->sock_input, 0, (void *) &rtp_session->recv_msg, bytes);
	} else {
		*bytes = 0;
	}

	if (*bytes) {
		b = (unsigned char *) &rtp_session->recv_msg;

		/* version 2 probably rtp */
		rtp_session->has_rtp = (rtp_session->recv_msg.header.version == 2);

		if (rtp_session->media_timeout || rtp_session->ice.ice_user) {
			rtp_session->last_media = switch_micro_time_now();
		}

		if ((*b >= 20) && (*b <= 64)) {
			if (rtp_session->dtls) {
				rtp_session->dtls->bytes = *bytes;
				rtp_session->dtls->data = (void *) &rtp_session->recv_msg;
			}
			rtp_session->has_ice = 0;
			rtp_session->has_rtp = 0;
			rtp_session->has_rtcp = 0;
		} else if (*b == 0 || *b == 1) {
			rtp_session->has_ice = 1;
			rtp_session->has_rtp = 0;
			rtp_session->has_rtcp = 0;
		} else {
			if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {
				switch(rtp_session->recv_msg.header.pt) {
				case 64:        //  192 Full INTRA-frame request.
				case 72:        //  200 Sender report.
				case 73:        //  201 Receiver report.
				case 74:        //  202 Source description.
				case 75:        //  203 Goodbye.
				case 76:        //  204 Application-defined.
				case 77:        //  205 Transport layer FB message.
				case 78:        //  206 Payload-specific FB message.
				case 79:        //  207 Extended report.
					rtp_session->has_rtcp = 1;
					rtp_session->has_rtp = 0;
					rtp_session->has_ice = 0;
					break;
				default:
					if (rtp_session->rtcp_recv_msg_p->header.version == 2 &&
						rtp_session->rtcp_recv_msg_p->header.type > 199 && rtp_session->rtcp_recv_msg_p->header.type < 208) {
						rtp_session->has_rtcp = 1;
						rtp_session->has_rtp = 0;
						rtp_session->has_ice = 0;
					}
					break;
				}
			}
		}

		if (rtp_session->has_rtp || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
			rtp_session->missed_count = 0;
			switch_cp_addr(rtp_session->rtp_from_addr, rtp_session->from_addr);
		}

		if (rtp_session->has_rtp) {
			rtp_session->last_rtp_hdr = rtp_session->recv_msg.header;


			if (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&
				rtp_session->last_rtp_hdr.pt != 13 &&
				rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&
				rtp_session->last_rtp_hdr.pt != rtp_session->cng_pt) {
				int accept_packet = 1;


				if (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PAYLOAD) && 
					!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PACKETS) && rtp_session->pmaps && *rtp_session->pmaps) {
					payload_map_t *pmap;
					accept_packet = 0;

					switch_mutex_lock(rtp_session->flag_mutex);
					for (pmap = *rtp_session->pmaps; pmap && pmap->allocated; pmap = pmap->next) {

						if (!pmap->negotiated) {
							continue;
						}

						if (rtp_session->last_rtp_hdr.pt == pmap->pt) {
							accept_packet = 1;
							if (pmapP) {
								*pmapP = pmap;
							}
							break;
						}
					}
					switch_mutex_unlock(rtp_session->flag_mutex);
				}

				if (!accept_packet) {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1,
									  "Invalid Packet SEQ: %d TS: %d PT:%d ignored\n",
									  ntohs(rtp_session->recv_msg.header.seq), ntohl(rtp_session->last_rtp_hdr.ts), rtp_session->last_rtp_hdr.pt);
					*bytes = 0;
				}
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_DETECT_SSRC]) {
				//if (rtp_session->remote_ssrc != rtp_session->stats.rtcp.peer_ssrc && rtp_session->stats.rtcp.peer_ssrc) {
				//	rtp_session->remote_ssrc = rtp_session->stats.rtcp.peer_ssrc;
				//}

				if (rtp_session->remote_ssrc != rtp_session->last_rtp_hdr.ssrc && rtp_session->last_rtp_hdr.ssrc) {
					rtp_session->remote_ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);
				}
			}
		}
	}

	if (!rtp_session->vb && (!rtp_session->jb || rtp_session->pause_jb || !jb_valid(rtp_session))) {
		if (*bytes > rtp_header_len && (rtp_session->has_rtp && check_recv_payload(rtp_session))) {
			xcheck_jitter = *bytes;
			check_jitter(rtp_session);
		}
	}

	if (check_rtcp_and_ice(rtp_session) == -1) {
		//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
		//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, "WTF CHECK FAIL\n");
		//}
		return SWITCH_STATUS_GENERR;
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
		goto udptl;
	}


	if (*bytes) {
		*flags &= ~SFF_PROXY_PACKET;

		//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
		//	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, "WTF BYTES %ld b=%d\n", *bytes, *b);
		//}


		if (rtp_session->has_ice) {
			if (rtp_session->ice.ice_user) {
				handle_ice(rtp_session, &rtp_session->ice, (void *) &rtp_session->recv_msg, *bytes);
			}
			*bytes = 0;
			sync = 1;
		}
	}

	switch_mutex_lock(rtp_session->ice_mutex);

	if (rtp_session->dtls) {

		if (rtp_session->rtcp_dtls && rtp_session->rtcp_dtls != rtp_session->dtls) {
			rtp_session->rtcp_dtls->bytes = 0;
			rtp_session->rtcp_dtls->data = NULL;
			do_dtls(rtp_session, rtp_session->rtcp_dtls);
		}

		do_dtls(rtp_session, rtp_session->dtls);

		if (rtp_session->dtls && rtp_session->dtls->bytes) {
			*bytes = 0;
			sync = 1;
		}
	}



	if (status == SWITCH_STATUS_SUCCESS && *bytes) {
		if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {
			*flags &= ~SFF_RTCP;
			if (rtp_session->has_rtcp) {
				*flags |= SFF_RTCP;

#ifdef ENABLE_SRTP
				if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {
					int sbytes = (int) *bytes;
					srtp_err_status_t stat = 0;

					if (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {
						stat = srtp_unprotect_rtcp(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes);
					} else {
						stat = srtp_unprotect_rtcp_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes, 1);
					}

					if (stat) {
						//++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp]++;
						switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "RTCP UNPROTECT ERR\n");
					} else {
						//rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;
					}

					*bytes = sbytes;
				}
#endif
				switch_mutex_unlock(rtp_session->ice_mutex);
				return SWITCH_STATUS_SUCCESS;
			}
		}
	}

	switch_mutex_unlock(rtp_session->ice_mutex);

	if ((*bytes && (!rtp_write_ready(rtp_session, *bytes, __LINE__) || !rtp_session->has_rtp || rtp_session->has_rtcp)) || sync) {
		rtp_session->hot_hits = 0;
		block = 1;
		*bytes = 0;
		goto more;
	}

	if (*bytes && rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]) {
		const char *tx_host;
		const char *old_host;
		const char *my_host;

		char bufa[50], bufb[50], bufc[50];


		tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);
		old_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);
		my_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);

		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,
						  "R %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\n",
						  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : "No-Name",
						  (long) *bytes,
						  my_host, switch_sockaddr_get_port(rtp_session->local_addr),
						  old_host, rtp_session->remote_port,
						  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),
						  rtp_session->last_rtp_hdr.pt, ntohl(rtp_session->last_rtp_hdr.ts), ntohs(rtp_session->last_rtp_hdr.seq),
						  rtp_session->last_rtp_hdr.m);

	}

#ifdef RTP_READ_PLOSS
	{
		int r = (rand() % 10000) + 1;
		if (r <= 200) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ALERT,
							  "Simulate dropped packet ......... ts: %u seq: %u\n", ntohl(rtp_session->last_rtp_hdr.ts), ntohs(rtp_session->last_rtp_hdr.seq));
			*bytes = 0;
		}
	}
#endif



 udptl:

	ts = 0;
	rtp_session->recv_msg.ebody = NULL;
	now = switch_micro_time_now();

	if (*bytes) {
		uint16_t seq = ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);
		ts = ntohl(rtp_session->last_rtp_hdr.ts);

#ifdef DEBUG_MISSED_SEQ
		if (rtp_session->last_seq && rtp_session->last_seq+1 != seq) {
			//2012-11-28 18:33:11.799070 [ERR] switch_rtp.c:2883 Missed -65536 RTP frames from sequence [65536] to [-1] (missed). Time since last read [20021]
			switch_size_t flushed_packets_diff = rtp_session->stats.inbound.flush_packet_count - rtp_session->last_flush_packet_count;
			switch_size_t num_missed = (switch_size_t)seq - (rtp_session->last_seq+1);

			if (num_missed == 1) { /* We missed one packet */
				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Missed one RTP frame with sequence [%d]%s. Time since last read [%ld]\n",
								  rtp_session->last_seq+1, (flushed_packets_diff == 1) ? " (flushed by FS)" : " (missed)",
								  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);
			} else { /* We missed multiple packets */
				if (flushed_packets_diff == 0) {
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,
									  "Missed %ld RTP frames from sequence [%d] to [%d] (missed). Time since last read [%ld]\n",
									  num_missed, rtp_session->last_seq+1, seq-1,
									  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);
				} else if (flushed_packets_diff == num_missed) {
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,
									  "Missed %ld RTP frames from sequence [%d] to [%d] (flushed by FS). Time since last read [%ld]\n",
									  num_missed, rtp_session->last_seq+1, seq-1,
									  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);
				} else if (num_missed > flushed_packets_diff) {
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,
									  "Missed %ld RTP frames from sequence [%d] to [%d] (%ld packets flushed by FS, %ld packets missed)."
									  " Time since last read [%ld]\n",
									  num_missed, rtp_session->last_seq+1, seq-1,
									  flushed_packets_diff, num_missed-flushed_packets_diff,
									  rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);
				} else {
					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,
									  "Missed %ld RTP frames from sequence [%d] to [%d] (%ld packets flushed by FS). Time since last read [%ld]\n",
									  num_missed, rtp_session->last_seq+1, seq-1,
									  flushed_packets_diff, rtp_session->last_read_time ? now-rtp_session->last_read_time : 0);
				}
			}

		}
#endif
		rtp_session->last_seq = seq;


		rtp_session->last_flush_packet_count = rtp_session->stats.inbound.flush_packet_count;


		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && now - rtp_session->last_read_time > 5000000) {
			switch_rtp_video_refresh(rtp_session);
		}

		rtp_session->last_read_time = now;
	}

	if (*bytes && rtp_session->has_rtp && rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]){
		rtcp_stats(rtp_session);
	}


	if (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&
		*bytes && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&
		ts && !rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session) && ts == rtp_session->last_cng_ts) {
		/* we already sent this frame..... */
		*bytes = 0;
		return SWITCH_STATUS_SUCCESS;
	}

	if (*bytes) {
		if (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {

#ifdef ENABLE_SRTP
			switch_mutex_lock(rtp_session->ice_mutex);
			if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && rtp_session->has_rtp &&
				(check_recv_payload(rtp_session) ||
				 rtp_session->last_rtp_hdr.pt == rtp_session->recv_te ||
				 rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt)) {
				//if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && (!rtp_session->ice.ice_user || rtp_session->has_rtp)) {
				int sbytes = (int) *bytes;
				srtp_err_status_t stat = 0;

				if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_RESET] || !rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {
					switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_RECV_RESET);
					srtp_dealloc(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]);
					rtp_session->recv_ctx[rtp_session->srtp_idx_rtp] = NULL;
					if ((stat = srtp_create(&rtp_session->recv_ctx[rtp_session->srtp_idx_rtp],
											&rtp_session->recv_policy[rtp_session->srtp_idx_rtp])) || !rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {

						rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;
						switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Error! RE-Activating Secure RTP RECV\n");
						rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;
						switch_mutex_unlock(rtp_session->ice_mutex);
						return SWITCH_STATUS_FALSE;
					} else {

						switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, "RE-Activating Secure RTP RECV\n");
						rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;
					}
				}

				if (!(*flags & SFF_PLC) && rtp_session->recv_ctx[rtp_session->srtp_idx_rtp]) {
					if (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {
						stat = srtp_unprotect(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp], &rtp_session->recv_msg.header, &sbytes);
					} else {
						stat = srtp_unprotect_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtp], &rtp_session->recv_msg.header, &sbytes, 1);
					}

					if (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && stat == srtp_err_status_replay_fail) {
						/* false alarm nack */
						switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, "REPLAY ERR, FALSE NACK\n");
						sbytes = 0;
						*bytes = 0;
						if (rtp_session->stats.rtcp.pkt_count) {
							rtp_session->stats.rtcp.period_pkt_count--;
							rtp_session->stats.rtcp.pkt_count--;
						}
						switch_mutex_unlock(rtp_session->ice_mutex);
						goto more;
					}
				}

				if (stat && rtp_session->recv_msg.header.pt != rtp_session->recv_te && rtp_session->recv_msg.header.pt != rtp_session->cng_pt) {
					int errs = ++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp];
					if (rtp_session->flags[SWITCH_RTP_FLAG_SRTP_HANGUP_ON_ERROR] && stat != srtp_err_status_replay_old) {
						char *msg;
						switch_srtp_err_to_txt(stat, &msg);
						if (errs >= MAX_SRTP_ERRS) {
							switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);
							switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,
											  "SRTP %s unprotect failed with code %d (%s) %ld bytes %d errors\n",
											  rtp_type(rtp_session), stat, msg, (long)*bytes, errs);
							switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,
											  "Ending call due to SRTP error\n");
							switch_channel_hangup(channel, SWITCH_CAUSE_SRTP_READ_ERROR);
						} else if (errs >= WARN_SRTP_ERRS && !(errs % WARN_SRTP_ERRS)) {
							switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,
											  "SRTP %s unprotect failed with code %d (%s) %ld bytes %d errors\n",
											  rtp_type(rtp_session), stat, msg, (long)*bytes, errs);
						}
					}
					sbytes = 0;
				} else {
					rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;
				}

				*bytes = sbytes;
			}
			switch_mutex_unlock(rtp_session->ice_mutex);
#endif
		}


		if (rtp_session->has_rtp) {
			if (rtp_session->recv_msg.header.cc > 0) { /* Contributing Source Identifiers (4 bytes = sizeof CSRC header)*/
				rtp_session->recv_msg.ebody = RTP_BODY(rtp_session) + (rtp_session->recv_msg.header.cc * 4);
			}

			/* recalculate body length in case rtp extension used */
			if (!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] && !rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&
				rtp_session->recv_msg.header.x) { /* header extensions */
				uint16_t length;

				rtp_session->recv_msg.ext = (switch_rtp_hdr_ext_t *) RTP_BODY(rtp_session);
				length = ntohs((uint16_t)rtp_session->recv_msg.ext->length);

				if (length < SWITCH_RTP_MAX_BUF_LEN_WORDS) {
					rtp_session->recv_msg.ebody = (char *)rtp_session->recv_msg.ext + (length * 4) + 4;
					if (*bytes > (length * 4 + 4)) {
						*bytes -= (length * 4 + 4);
					} else {
						*bytes = 0;
					}
				}
			}


#ifdef DEBUG_CHROME

			if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->has_rtp) {

				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO,
								  "VIDEO: seq: %d ts: %u len: %ld %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x mark: %d\n",
								  ntohs(rtp_session->last_rtp_hdr.seq), ntohl(rtp_session->last_rtp_hdr.ts), *bytes,
								  *((uint8_t *)RTP_BODY(rtp_session)), *((uint8_t *)RTP_BODY(rtp_session) + 1),
								  *((uint8_t *)RTP_BODY(rtp_session) + 2), *((uint8_t *)RTP_BODY(rtp_session) + 3),
								  *((uint8_t *)RTP_BODY(rtp_session) + 4), *((uint8_t *)RTP_BODY(rtp_session) + 5),
								  *((uint8_t *)RTP_BODY(rtp_session) + 6), *((uint8_t *)RTP_BODY(rtp_session) + 7),
								  *((uint8_t *)RTP_BODY(rtp_session) + 8), *((uint8_t *)RTP_BODY(rtp_session) + 9),
								  *((uint8_t *)RTP_BODY(rtp_session) + 10), rtp_session->last_rtp_hdr.m);

			}
#endif



		}


		rtp_session->stats.inbound.raw_bytes += *bytes;

		if (rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {
			rtp_session->stats.inbound.dtmf_packet_count++;
		} else if (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {
			rtp_session->stats.inbound.cng_packet_count++;
		} else {
			rtp_session->stats.inbound.media_packet_count++;
			rtp_session->stats.inbound.media_bytes += *bytes;
		}

		rtp_session->stats.inbound.packet_count++;
	}

	if (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&
		((rtp_session->recv_te && rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) ||
		 (*bytes < rtp_header_len && *bytes > 0 && !(rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL])))) {
		return SWITCH_STATUS_BREAK;
	}

	if (ts) {
		rtp_session->prev_read_ts = rtp_session->last_read_ts;
		rtp_session->last_read_ts = ts;
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_BYTESWAP] && check_recv_payload(rtp_session)) {
		switch_swap_linear((int16_t *)RTP_BODY(rtp_session), (int) *bytes - rtp_header_len);
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_KILL_JB]) {
		rtp_session->flags[SWITCH_RTP_FLAG_KILL_JB] = 0;

		if (rtp_session->jb) {
			switch_jb_destroy(&rtp_session->jb);
		}

		if (rtp_session->vb) {
			switch_jb_destroy(&rtp_session->vb);
		}

		if (rtp_session->vbw) {
			switch_jb_destroy(&rtp_session->vbw);
		}

	}

	if (rtp_session->has_rtp && *bytes) {
		uint32_t read_ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);

		if (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
			return SWITCH_STATUS_SUCCESS;
		}

		if (rtp_session->vb && !rtp_session->pause_jb && jb_valid(rtp_session)) {
			status = switch_jb_put_packet(rtp_session->vb, (switch_rtp_packet_t *) &rtp_session->recv_msg, *bytes);

			if (status == SWITCH_STATUS_TOO_LATE) {
				goto more;
			}

			status = SWITCH_STATUS_FALSE;
			*bytes = 0;

			if (!return_jb_packet) {
				return status;
			}
		}

		if (rtp_session->jb && jb_valid(rtp_session)) {
			if (rtp_session->last_jb_read_ssrc && rtp_session->last_jb_read_ssrc != read_ssrc) {
				switch_jb_reset(rtp_session->jb);
			}

			rtp_session->last_jb_read_ssrc = read_ssrc;
		}

		if (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {

			status = switch_jb_put_packet(rtp_session->jb, (switch_rtp_packet_t *) &rtp_session->recv_msg, *bytes);
			if (status == SWITCH_STATUS_TOO_LATE) {
				goto more;
			}


			status = SWITCH_STATUS_FALSE;
			*bytes = 0;

			if (!return_jb_packet) {
				return status;
			}
		} else {
			if (rtp_session->last_rtp_hdr.m && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&
				!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && !(rtp_session->rtp_bugs & RTP_BUG_IGNORE_MARK_BIT) && 
				rtp_session->last_read_ts - rtp_session->prev_read_ts < rtp_session->samples_per_interval * 3) {  
				switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);
			} else if (rtp_session->last_jb_read_ssrc && rtp_session->last_jb_read_ssrc != read_ssrc) {
				switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);
			}
		}
	}

	if (!*bytes || rtp_session->has_rtp) {

		if (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {
			switch_status_t jstatus = switch_jb_get_packet(rtp_session->jb, (switch_rtp_packet_t *) &rtp_session->recv_msg, bytes);

			status = jstatus;

			switch(jstatus) {
			case SWITCH_STATUS_MORE_DATA:
				if (rtp_session->punts < 4) {
					block = 1;
					goto more;
				}
				*bytes = 0;
				break;
			case SWITCH_STATUS_NOTFOUND:
				{
					int pt = get_recv_payload(rtp_session);
					(*flags) |= SFF_PLC;
					status = SWITCH_STATUS_SUCCESS;
					*bytes = switch_jb_get_last_read_len(rtp_session->jb);
					rtp_session->last_rtp_hdr = rtp_session->recv_msg.header;
					rtp_session->last_rtp_hdr.pt = pt;
				}
				break;
			case SWITCH_STATUS_BREAK:
				break;
			case SWITCH_STATUS_SUCCESS:
			case SWITCH_STATUS_TIMEOUT:
			default:
				{
					if (status == SWITCH_STATUS_TIMEOUT) {
						rtp_session->skip_timer = 1;
					}
					rtp_session->stats.inbound.jb_packet_count++;
					status = SWITCH_STATUS_SUCCESS;
					rtp_session->last_rtp_hdr = rtp_session->recv_msg.header;
					if (++rtp_session->clean > 200) {
						rtp_session->punts = 0;
					}
					if (!xcheck_jitter) {
						check_jitter(rtp_session);
					}
				}
				break;
			}
		}

		if (rtp_session->vb && !rtp_session->pause_jb && jb_valid(rtp_session)) {
			switch_status_t vstatus = switch_jb_get_packet(rtp_session->vb, (switch_rtp_packet_t *) &rtp_session->recv_msg, bytes);
			status = vstatus;

			switch(vstatus) {
			case SWITCH_STATUS_RESTART:
				switch_core_session_request_video_refresh(rtp_session->session);
				status = SWITCH_STATUS_BREAK;
				break;
			case SWITCH_STATUS_MORE_DATA:
				status = SWITCH_STATUS_BREAK;
				break;
			case SWITCH_STATUS_BREAK:
			default:
				break;
			}

			if (vstatus == SWITCH_STATUS_NOTFOUND && rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {
				int pt = get_recv_payload(rtp_session);
				(*flags) |= SFF_PLC;
				status = SWITCH_STATUS_SUCCESS;
				*bytes = switch_jb_get_last_read_len(rtp_session->vb);
				rtp_session->last_rtp_hdr = rtp_session->recv_msg.header;
				if (pt > -1) {
					rtp_session->last_rtp_hdr.pt = pt;
				}
			}

			if (vstatus == SWITCH_STATUS_SUCCESS) {
				rtp_session->last_rtp_hdr = rtp_session->recv_msg.header;

				if (!xcheck_jitter) {
					check_jitter(rtp_session);
				}
			}
		}
	}

	return status;
}
