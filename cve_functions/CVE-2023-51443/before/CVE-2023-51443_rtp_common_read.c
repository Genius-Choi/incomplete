static int rtp_common_read(switch_rtp_t *rtp_session, switch_payload_t *payload_type,
						   payload_map_t **pmapP, switch_frame_flag_t *flags, switch_io_flag_t io_flags)
{

	switch_channel_t *channel = NULL;
	switch_size_t bytes = 0;
	switch_size_t rtcp_bytes = 0;
	switch_status_t status = SWITCH_STATUS_SUCCESS, poll_status = SWITCH_STATUS_SUCCESS;
	switch_status_t rtcp_status = SWITCH_STATUS_SUCCESS, rtcp_poll_status = SWITCH_STATUS_SUCCESS;
	int check = 0;
	int ret = -1;
	int sleep_mss = 1000;
	int poll_sec = 5;
	int poll_loop = 0;
	int fdr = 0;
	int rtcp_fdr = 0;
	int hot_socket = 0;
	int read_loops = 0;
	int slept = 0;
	switch_bool_t got_jb = SWITCH_FALSE;

	if (!switch_rtp_ready(rtp_session)) {
		return -1;
	}

	if (rtp_session->session) {
		channel = switch_core_session_get_channel(rtp_session->session);
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {
		sleep_mss = rtp_session->timer.interval * 1000;
	}

	READ_INC(rtp_session);



	while (switch_rtp_ready(rtp_session)) {
		int do_cng = 0;
		int read_pretriggered = 0;
		int has_rtcp = 0;
		int got_rtp_poll = 0;

		bytes = 0;

		if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&
			!rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] &&
			!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&
			!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&
			rtp_session->read_pollfd) {

			if (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {
				while (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {
					status = read_rtp_packet(rtp_session, &bytes, flags, pmapP, SWITCH_STATUS_SUCCESS, SWITCH_FALSE);

					if (status == SWITCH_STATUS_GENERR) {
						ret = -1;
						goto end;
					}

					if ((*flags & SFF_RTCP)) {
						*flags &= ~SFF_RTCP;
						has_rtcp = 1;
						read_pretriggered = 0;
						goto rtcp;
					}

					if (status == SWITCH_STATUS_BREAK) {
						read_pretriggered = 1;
						break;
					}
				}

			} else if ((rtp_session->flags[SWITCH_RTP_FLAG_AUTOFLUSH] || rtp_session->flags[SWITCH_RTP_FLAG_STICKY_FLUSH])) {

				if (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {
					status = read_rtp_packet(rtp_session, &bytes, flags, pmapP, SWITCH_STATUS_SUCCESS, SWITCH_FALSE);
					if (status == SWITCH_STATUS_GENERR) {
						ret = -1;
						goto end;
					}
					if ((*flags & SFF_RTCP)) {
						*flags &= ~SFF_RTCP;
						has_rtcp = 1;
						read_pretriggered = 0;
						goto rtcp;
					}

					/* switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, "Initial (%i) %d\n", status, bytes); */
					if (status != SWITCH_STATUS_FALSE) {
						read_pretriggered = 1;
					}

					if (bytes) {
						if (switch_poll(rtp_session->read_pollfd, 1, &fdr, 0) == SWITCH_STATUS_SUCCESS) {
							rtp_session->hot_hits++;//+= rtp_session->samples_per_interval;

							switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, "%s Hot Hit %d\n",
											  rtp_session_name(rtp_session),
											  rtp_session->hot_hits);
						} else {
							rtp_session->hot_hits = 0;
						}
					}

					if (rtp_session->hot_hits > 1 && !rtp_session->sync_packets) {// >= (rtp_session->samples_per_second * 30)) {
						hot_socket = 1;
					}
				} else {
					rtp_session->hot_hits = 0;
				}
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {
				///NOOP
			} else if (hot_socket && (rtp_session->hot_hits % 10) != 0) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, "%s timer while HOT\n", rtp_session_name(rtp_session));
				switch_core_timer_next(&rtp_session->timer);
			} else if (hot_socket) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10, "%s skip timer once\n", rtp_session_name(rtp_session));
				rtp_session->sync_packets++;
				switch_core_timer_sync(&rtp_session->timer);
				reset_jitter_seq(rtp_session);
			} else {

				if (rtp_session->sync_packets) {

					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG10,
									  "%s Auto-Flush catching up %d packets (%d)ms.\n",
									  rtp_session_name(rtp_session),
									  rtp_session->sync_packets, (rtp_session->ms_per_packet * rtp_session->sync_packets) / 1000);
					if (!rtp_session->flags[SWITCH_RTP_FLAG_PAUSE]) {
						switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG3, "%s syncing %d %s packet(s)\n",
										 rtp_session_name(rtp_session),
										  rtp_session->sync_packets, rtp_type(rtp_session));

						rtp_session->bad_stream++;
						rtp_session->stats.inbound.flaws += rtp_session->sync_packets;

						if (rtp_session->stats.inbound.error_log) {
							rtp_session->stats.inbound.error_log->flaws += rtp_session->sync_packets;
						}
					}

					switch_core_timer_sync(&rtp_session->timer);
					reset_jitter_seq(rtp_session);
					rtp_session->hot_hits = 0;
				} else {
					if (slept) {
						switch_cond_next();
					} else {
						if (rtp_session->skip_timer) {
							rtp_session->skip_timer = 0;
							switch_cond_next();
						} else {
							switch_core_timer_next(&rtp_session->timer);
						}
						slept++;
					}

				}

				rtp_session->sync_packets = 0;
			}
		}

		rtp_session->stats.read_count++;

	recvfrom:

		if (!read_pretriggered) {
			bytes = 0;
		}
		read_loops++;
		//poll_loop = 0;

		if (!switch_rtp_ready(rtp_session)) {
			break;
		}

		if (!rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && rtp_session->read_pollfd) {
			int pt = poll_sec * 1000000;

			do_2833(rtp_session);

			if (rtp_session->dtmf_data.out_digit_dur > 0 || rtp_session->dtmf_data.in_digit_sanity || rtp_session->sending_dtmf ||
				switch_queue_size(rtp_session->dtmf_data.dtmf_queue) || switch_queue_size(rtp_session->dtmf_data.dtmf_inqueue)) {
				pt = 20000;
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && !rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA]) {
				pt = 100000;
			}

			if (rtp_session->vb && !rtp_session->pause_jb) {
				if (switch_jb_poll(rtp_session->vb)) {
					pt = 1000;
				}
			}

			if ((io_flags & SWITCH_IO_FLAG_NOBLOCK)) {
				pt = 0;
			}

			poll_status = switch_poll(rtp_session->read_pollfd, 1, &fdr, pt);

			if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && poll_status != SWITCH_STATUS_SUCCESS && rtp_session->media_timeout && rtp_session->last_media) {
				check_timeout(rtp_session);
			}

			if (!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->dtmf_data.out_digit_dur > 0) {
				return_cng_frame();
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_BREAK]) {
				switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_BREAK);
				bytes = 0;
				reset_jitter_seq(rtp_session);
				return_cng_frame();
			}

		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
			got_jb = (rtp_session->vb && !rtp_session->pause_jb && switch_jb_poll(rtp_session->vb));
		} else {
			got_jb = SWITCH_TRUE;
		}

		if (poll_status == SWITCH_STATUS_SUCCESS || got_jb) {

			got_rtp_poll = 1;

			if (read_pretriggered) {
				read_pretriggered = 0;
			} else {
				
				
				status = read_rtp_packet(rtp_session, &bytes, flags, pmapP, poll_status, got_jb);

				if (status == SWITCH_STATUS_GENERR) {
					ret = -1;
					goto end;
				}

				if (rtp_session->max_missed_packets && read_loops == 1 && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&
					!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
					if (bytes && status == SWITCH_STATUS_SUCCESS) {
						rtp_session->missed_count = 0;
					} else {
						if (rtp_session->media_timeout && rtp_session->last_media) {
							check_timeout(rtp_session);
						} else {
							if (++rtp_session->missed_count >= rtp_session->max_missed_packets) {
								ret = -2;
								goto end;
							}
						}
					}
				}

				if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
					//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, "Read bytes (%i) %ld\n", status, bytes);

					if (bytes == 0) {
						if (check_rtcp_and_ice(rtp_session) == -1) {
							ret = -1;
							goto end;
						}
						// This is dumb
						//switch_rtp_video_refresh(rtp_session);
						goto  rtcp;
					}
				}

				if ((*flags & SFF_PROXY_PACKET)) {
					ret = (int) bytes;
					goto end;
				}

				if ((*flags & SFF_RTCP)) {
					*flags &= ~SFF_RTCP;
					has_rtcp = 1;
					goto rtcp;
				}


			}
			poll_loop = 0;
		} else {

			if (!switch_rtp_ready(rtp_session)) {
				ret = -1;
				goto end;
			}

			if (!SWITCH_STATUS_IS_BREAK(poll_status) && poll_status != SWITCH_STATUS_TIMEOUT) {
				char tmp[128] = "";
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Poll failed with error: %d [%s]\n",
								  poll_status, switch_strerror_r(poll_status, tmp, sizeof(tmp)));
				ret = -1;
				goto end;
			}

			if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
				rtp_session->missed_count += (poll_sec * 1000) / (rtp_session->ms_per_packet ? rtp_session->ms_per_packet / 1000 : 20);
				bytes = 0;

				if (rtp_session->media_timeout && rtp_session->last_media) {
					check_timeout(rtp_session);
				} else if (rtp_session->max_missed_packets) {
					if (rtp_session->missed_count >= rtp_session->max_missed_packets) {
						ret = -2;
						goto end;
					}
				}
			}


			if (check_rtcp_and_ice(rtp_session) == -1) {
				ret = -1;
				goto end;
			}


			if ((!(io_flags & SWITCH_IO_FLAG_NOBLOCK)) &&
				(rtp_session->dtmf_data.out_digit_dur == 0) && !rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {
				return_cng_frame();
			}
		}

	rtcp:

		if (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {
			rtcp_poll_status = SWITCH_STATUS_FALSE;

			if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX] && has_rtcp) {
				if (rtp_session->rtcp_recv_msg_p->header.version == 2) { //rtcp muxed
					rtp_session->rtcp_from_addr = rtp_session->from_addr;
					rtcp_status = rtcp_poll_status = SWITCH_STATUS_SUCCESS;
					rtcp_bytes = bytes;
				}

				has_rtcp = 0;

			} else if (rtp_session->rtcp_read_pollfd) {
				rtcp_poll_status = switch_poll(rtp_session->rtcp_read_pollfd, 1, &rtcp_fdr, 0);
			}

			if (rtcp_poll_status == SWITCH_STATUS_SUCCESS) {

				if (!rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {
					rtcp_status = read_rtcp_packet(rtp_session, &rtcp_bytes, flags);
				}

				if (rtcp_status == SWITCH_STATUS_SUCCESS) {
					switch_rtp_reset_media_timer(rtp_session);
					
					if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU]) {
						switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);
						const char *uuid = switch_channel_get_partner_uuid(channel);

						if (uuid) {
							switch_core_session_t *other_session;
							switch_rtp_t *other_rtp_session = NULL;

							if ((other_session = switch_core_session_locate(uuid))) {
								switch_channel_t *other_channel = switch_core_session_get_channel(other_session);
								if ((other_rtp_session = switch_channel_get_private(other_channel, "__rtcp_audio_rtp_session")) &&
									other_rtp_session->rtcp_sock_output &&
									switch_rtp_test_flag(other_rtp_session, SWITCH_RTP_FLAG_ENABLE_RTCP)) {
									other_rtp_session->rtcp_send_msg = rtp_session->rtcp_recv_msg;

#ifdef ENABLE_SRTP
									switch_mutex_lock(other_rtp_session->ice_mutex);
									if (switch_rtp_test_flag(other_rtp_session, SWITCH_RTP_FLAG_SECURE_SEND)) {
										int stat = 0;
										int sbytes = (int) rtcp_bytes;
										
										if (!other_rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {
											stat = srtp_protect_rtcp(other_rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &other_rtp_session->rtcp_send_msg.header, &sbytes);
										} else {
											stat = srtp_protect_rtcp_mki(other_rtp_session->send_ctx[other_rtp_session->srtp_idx_rtcp], &other_rtp_session->rtcp_send_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);
										}

										if (stat) {
											switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Error: SRTP RTCP protection failed with code %d\n", stat);
										}
										rtcp_bytes = sbytes;
									}
									switch_mutex_unlock(other_rtp_session->ice_mutex);
#endif

									if (switch_socket_sendto(other_rtp_session->rtcp_sock_output, other_rtp_session->rtcp_remote_addr, 0,
															 (const char*)&other_rtp_session->rtcp_send_msg, &rtcp_bytes ) != SWITCH_STATUS_SUCCESS) {
										switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,"RTCP packet not written\n");
									}


								}
								switch_core_session_rwunlock(other_session);
							}
						}

					}

					if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {
						process_rtcp_packet(rtp_session, &rtcp_bytes);
						ret = 1;

						continue;
					}
				}
			}
		}

		if ((!(io_flags & SWITCH_IO_FLAG_NOBLOCK)) &&
			(rtp_session->dtmf_data.out_digit_dur == 0) && !got_rtp_poll) {
			return_cng_frame();
		}

		if (!bytes && (io_flags & SWITCH_IO_FLAG_NOBLOCK)) {
			rtp_session->missed_count = 0;
			ret = 0;
			goto end;
		}

		check = !bytes;

		if (rtp_session->flags[SWITCH_RTP_FLAG_FLUSH]) {
			bytes = do_flush(rtp_session, SWITCH_FALSE, bytes);
			switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_FLUSH);
		}

		if ((!bytes && rtp_session->flags[SWITCH_RTP_FLAG_BREAK]) || (bytes && bytes == 4 && *((int *) &rtp_session->recv_msg) == UINT_MAX)) {
			switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_BREAK);

			if (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] || !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] ||
				rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] ||
				(bytes && bytes < 5) || (!bytes && poll_loop)) {
				bytes = 0;
				reset_jitter_seq(rtp_session);
				return_cng_frame();
			}
		}

		if (bytes && bytes < 5) {
			continue;
		}

		if (!bytes && poll_loop) {
			goto recvfrom;
		}

		if (bytes && rtp_session->last_rtp_hdr.m && rtp_session->last_rtp_hdr.pt != rtp_session->recv_te &&
			!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&
			!rtp_session->flags[SWITCH_RTP_FLAG_TEXT] &&
			!(rtp_session->rtp_bugs & RTP_BUG_IGNORE_MARK_BIT)) {
			rtp_flush_read_buffer(rtp_session, SWITCH_RTP_FLUSH_ONCE);
		}

		if (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {
			*flags |= SFF_NOT_AUDIO;
		} else {
			*flags &= ~SFF_NOT_AUDIO; /* If this flag was already set, make sure to remove it when we get real audio */
		}

		/* ignore packets not meant for us unless the auto-adjust window is open (ice mode has its own alternatives to this) */
		if (!using_ice(rtp_session) && bytes) {
			if (rtp_session->flags[SWITCH_RTP_FLAG_AUTOADJ]) {
				if (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13) {
					goto recvfrom;

				}
			} else if (!(rtp_session->rtp_bugs & RTP_BUG_ACCEPT_ANY_PACKETS) && !switch_cmp_addr(rtp_session->rtp_from_addr, rtp_session->remote_addr, SWITCH_FALSE)) {
				goto recvfrom;
			}
		}

		if (bytes && rtp_session->flags[SWITCH_RTP_FLAG_AUTOADJ] && switch_sockaddr_get_port(rtp_session->rtp_from_addr)) {
			if (!switch_cmp_addr(rtp_session->rtp_from_addr, rtp_session->remote_addr, SWITCH_FALSE)) {
				if (++rtp_session->autoadj_tally >= rtp_session->autoadj_threshold) {
					const char *err;
					uint32_t old = rtp_session->remote_port;
					const char *tx_host;
					const char *old_host;
					char bufa[50], bufb[50];
					char adj_port[6];

					tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);
					old_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);

					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,
									  "Auto Changing %s port from %s:%u to %s:%u\n", rtp_type(rtp_session), old_host, old, tx_host,
									  switch_sockaddr_get_port(rtp_session->rtp_from_addr));

					if (channel) {
						char varname[80] = "";

						switch_snprintf(varname, sizeof(varname), "remote_%s_ip_reported", rtp_type(rtp_session));
						switch_channel_set_variable(channel, varname, switch_channel_get_variable(channel, "remote_media_ip"));

						switch_snprintf(varname, sizeof(varname), "remote_%s_ip", rtp_type(rtp_session));
						switch_channel_set_variable(channel, varname, tx_host);

						switch_snprintf(varname, sizeof(varname), "remote_%s_port_reported", rtp_type(rtp_session));
						switch_snprintf(adj_port, sizeof(adj_port), "%u", switch_sockaddr_get_port(rtp_session->rtp_from_addr));
						switch_channel_set_variable(channel, varname, switch_channel_get_variable(channel, "remote_media_port"));

						switch_snprintf(varname, sizeof(varname), "remote_%s_port", rtp_type(rtp_session));
						switch_channel_set_variable(channel, varname, adj_port);

						switch_snprintf(varname, sizeof(varname), "rtp_auto_adjust_%s", rtp_type(rtp_session));
						switch_channel_set_variable(channel, varname, "true");
					}
					rtp_session->auto_adj_used = 1;
					switch_rtp_set_remote_address(rtp_session, tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr), 0, SWITCH_FALSE, &err);
					if ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {
						switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);
						switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);
					} else {
						switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);
					}
					if (rtp_session->ice.ice_user) {
						rtp_session->ice.addr = rtp_session->remote_addr;
					}
				}
			} else {
				if ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {
					switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);
					switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);
				} else {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, "Correct %s ip/port confirmed.\n", rtp_type(rtp_session));
					switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);
				}
				rtp_session->auto_adj_used = 0;
			}
		}

		if (bytes && !(rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST) && rtp_session->autoadj_window) {
			if (--rtp_session->autoadj_window == 0) {
				switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_AUTOADJ);
			}
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {
			if (!bytes) {
				if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {
					switch_core_timer_next(&rtp_session->timer);
				}
				return_cng_frame();
			} else {
				*payload_type = rtp_session->last_rtp_hdr.pt;
				ret = (int) bytes;
				goto end;
			}
		}

		if (bytes && (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL])) {
			/* Fast PASS! */
			*flags |= SFF_PROXY_PACKET;

			if (rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
#if 0
				if (rtp_session->has_rtp && check_recv_payload(rtp_session)) {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,
									  "Ignoring udptl packet of size of %ld bytes that looks strikingly like a RTP packet.\n", (long)bytes);
					bytes = 0;
					goto do_continue;
				}
#endif
				*flags |= SFF_UDPTL_PACKET;
			}

			ret = (int) bytes;
			goto end;
		}

		if (bytes) {
			rtp_session->missed_count = 0;

			if (bytes < rtp_header_len) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, "Ignoring invalid RTP packet size of %ld bytes.\n", (long)bytes);
				bytes = 0;
				goto do_continue;
			}

			if (rtp_session->last_rtp_hdr.pt && (rtp_session->last_rtp_hdr.pt == rtp_session->cng_pt || rtp_session->last_rtp_hdr.pt == 13)) {
				return_cng_frame();
			}
		}

		if (check || bytes) {
			do_2833(rtp_session);
		}

		if (bytes && rtp_session->recv_msg.header.version != 2) {
			uint8_t *data = (uint8_t *) RTP_BODY(rtp_session);

			//if (rtp_session->recv_msg.header.version == 0) {
			//	if (rtp_session->ice.ice_user) {
			//		handle_ice(rtp_session, &rtp_session->ice, (void *) &rtp_session->recv_msg, bytes);
			//		goto recvfrom;
			//	}
			//}

			if (rtp_session->invalid_handler) {
				rtp_session->invalid_handler(rtp_session, rtp_session->sock_input, (void *) &rtp_session->recv_msg, bytes, rtp_session->rtp_from_addr);
			}

			memset(data, 0, 2);
			data[0] = 65;

			rtp_session->last_rtp_hdr.pt = rtp_session->cng_pt != INVALID_PT ? rtp_session->cng_pt : SWITCH_RTP_CNG_PAYLOAD;
			*flags |= SFF_CNG;
			*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;
			ret = 2 + rtp_header_len;
			goto end;
		} else if (bytes) {
			rtp_session->stats.inbound.period_packet_count++;
		}


		/* Handle incoming RFC2833 packets */
		switch (handle_rfc2833(rtp_session, bytes, &do_cng)) {
		case RESULT_GOTO_END:
			goto end;
		case RESULT_GOTO_RECVFROM:
			goto recvfrom;
		case RESULT_GOTO_TIMERCHECK:
			goto timer_check;
		case RESULT_CONTINUE:
			status = SWITCH_STATUS_SUCCESS;
			goto result_continue;
		}

	result_continue:
	timer_check:

		if (!rtp_session->media_timeout && rtp_session->flags[SWITCH_RTP_FLAG_MUTE]) {
			do_cng++;
		}

		if (do_cng) {
			uint8_t *data = (uint8_t *) RTP_BODY(rtp_session);

			do_2833(rtp_session);

			if (rtp_session->last_cng_ts == rtp_session->last_read_ts + rtp_session->samples_per_interval) {
				rtp_session->last_cng_ts = 0;
			} else {
				rtp_session->last_cng_ts = rtp_session->last_read_ts + rtp_session->samples_per_interval;
			}

			memset(data, 0, 2);
			data[0] = 65;
			rtp_session->last_rtp_hdr.pt = rtp_session->cng_pt != INVALID_PT ? rtp_session->cng_pt : SWITCH_RTP_CNG_PAYLOAD;
			*flags |= SFF_CNG;
			*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;
			ret = 2 + rtp_header_len;
			rtp_session->stats.inbound.skip_packet_count++;
			goto end;
		}


		if (check || (bytes && !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER])) {
			if (!bytes && rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {	/* We're late! We're Late! */
				if (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] && status == SWITCH_STATUS_BREAK) {
					switch_cond_next();
					continue;
				}



				if (!rtp_session->flags[SWITCH_RTP_FLAG_PAUSE] && !rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON] && !rtp_session->dtmf_data.in_digit_ts
					&& rtp_session->cng_count > (rtp_session->one_second * 2) && rtp_session->jitter_lead > JITTER_LEAD_FRAMES) {

					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, "%s %s timeout\n",
									  rtp_session_name(rtp_session), rtp_type(rtp_session));

					if (rtp_session->media_timeout && rtp_session->last_media) {
						check_timeout(rtp_session);
					}

					if (rtp_session->stats.inbound.error_log) {
						rtp_session->stats.inbound.error_log->flaws++;
					}
					rtp_session->stats.inbound.flaws++;
					do_mos(rtp_session);
				}

				rtp_session->cng_count++;
				return_cng_frame();
			}
		}

		rtp_session->cng_count = 0;

		if (status == SWITCH_STATUS_BREAK || bytes == 0) {
			if (!(io_flags & SWITCH_IO_FLAG_SINGLE_READ) && rtp_session->flags[SWITCH_RTP_FLAG_DATAWAIT]) {
				goto do_continue;
			}
			return_cng_frame();
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_GOOGLEHACK] && rtp_session->last_rtp_hdr.pt == 102) {
			rtp_session->last_rtp_hdr.pt = 97;
		}

		break;

	do_continue:

		if (!bytes && !rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {

			if (sleep_mss) {
				switch_yield(sleep_mss);
			}
		}

	}

	if (switch_rtp_ready(rtp_session)) {
		*payload_type = (switch_payload_t) rtp_session->last_rtp_hdr.pt;

		if (*payload_type == SWITCH_RTP_CNG_PAYLOAD) {
			*flags |= SFF_CNG;
		}

		ret = (int) bytes;
	} else {
		ret = -1;
	}

 end:

	READ_DEC(rtp_session);

	return ret;
}
