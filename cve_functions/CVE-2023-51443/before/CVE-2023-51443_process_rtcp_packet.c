static switch_status_t process_rtcp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes)
{
	switch_size_t len;
	switch_size_t remain = *bytes;
	switch_status_t status = SWITCH_STATUS_FALSE;
	rtcp_msg_t *msg = rtp_session->rtcp_recv_msg_p;

	if (remain < sizeof(switch_rtcp_ext_hdr_t) || remain > sizeof(rtcp_msg_t)) {
		return status;
	}
	if (msg->header.version != 2) {
		if (msg->header.version == 0) {
			if (rtp_session->ice.ice_user) {
				handle_ice(rtp_session, &rtp_session->rtcp_ice, (void *) msg, *bytes);
			}
			return SWITCH_STATUS_SUCCESS;
		} else {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),
							  SWITCH_LOG_WARNING, "Received an unsupported RTCP packet version %d\n", msg->header.version);
			return SWITCH_STATUS_FALSE;
		}
	}

	do {
		len = ((switch_size_t)ntohs(msg->header.length) * 4) + 4;

		if (msg->header.version != 2 || !(msg->header.type > 191 && msg->header.type < 210)) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,
							  "INVALID RTCP PACKET TYPE %d VER %d LEN %" SWITCH_SIZE_T_FMT "\n", msg->header.type,
							  msg->header.version, len);
			status = SWITCH_STATUS_BREAK;
			break;
		}

		//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT,
		//"WTF BYTES %ld REMAIN %ld PACKET TYPE %d LEN %ld\n", *bytes, remain, msg->header.type, len);

		if (len > remain) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING,
							  "RTCP INVALID LENGTH %" SWITCH_SIZE_T_FMT "\n", len);
			len = remain;
		}

		status = process_rtcp_report(rtp_session, msg, len);

		if (remain > len) {
			unsigned char *p = (unsigned char *) msg;
			p += len;
			msg = (rtcp_msg_t *) p;
		}

		remain -= len;

	} while (remain >= 4);

	return status;
}
