static switch_status_t read_rtcp_packet(switch_rtp_t *rtp_session, switch_size_t *bytes, switch_frame_flag_t *flags)
{
	switch_status_t status = SWITCH_STATUS_FALSE;

	if (!rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {
		return SWITCH_STATUS_FALSE;
	}

	switch_assert(bytes);

	*bytes = sizeof(rtcp_msg_t);

	if ((status = switch_socket_recvfrom(rtp_session->rtcp_from_addr, rtp_session->rtcp_sock_input, 0, (void *) rtp_session->rtcp_recv_msg_p, bytes))
		!= SWITCH_STATUS_SUCCESS) {
		*bytes = 0;
	}

	switch_mutex_lock(rtp_session->ice_mutex);
	if (rtp_session->rtcp_dtls) {
		char *b = (char *) rtp_session->rtcp_recv_msg_p;

		if (*b == 0 || *b == 1) {
			if (rtp_session->rtcp_ice.ice_user) {
				handle_ice(rtp_session, &rtp_session->rtcp_ice, (void *) rtp_session->rtcp_recv_msg_p, *bytes);
			}
			*bytes = 0;
		}

		if (*bytes && (*b >= 20) && (*b <= 64)) {
			rtp_session->rtcp_dtls->bytes = *bytes;
			rtp_session->rtcp_dtls->data = (void *) rtp_session->rtcp_recv_msg_p;
		} else {
			rtp_session->rtcp_dtls->bytes = 0;
			rtp_session->rtcp_dtls->data = NULL;
		}

		do_dtls(rtp_session, rtp_session->rtcp_dtls);


		if (rtp_session->rtcp_dtls->bytes) {
			*bytes = 0;
		}
	}

#ifdef ENABLE_SRTP
	if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && rtp_session->rtcp_recv_msg_p->header.version == 2) {
		//if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && (!rtp_session->ice.ice_user || rtp_session->rtcp_recv_msg_p->header.version == 2)) {
		int sbytes = (int) *bytes;
		srtp_err_status_t stat = 0;


		if (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI]) {
			stat = srtp_unprotect_rtcp(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes);
		} else {
			stat = srtp_unprotect_rtcp_mki(rtp_session->recv_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_recv_msg_p->header, &sbytes, 1);
		}

		if (stat) {
			//++rtp_session->srtp_errs[rtp_session->srtp_idx_rtp]++;
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "RTCP UNPROTECT ERR\n");
		} else {
			//rtp_session->srtp_errs[rtp_session->srtp_idx_rtp] = 0;
		}

		*bytes = sbytes;

	}
#endif

	switch_mutex_unlock(rtp_session->ice_mutex);


	/* RTCP Auto ADJ */
	if (*bytes && rtp_session->flags[SWITCH_RTP_FLAG_RTCP_AUTOADJ] &&  switch_sockaddr_get_port(rtp_session->rtcp_from_addr)) {
		if (!switch_cmp_addr(rtp_session->rtcp_from_addr, rtp_session->rtcp_remote_addr, SWITCH_FALSE)) {
				if (++rtp_session->rtcp_autoadj_tally >= rtp_session->rtcp_autoadj_threshold) {
					const char *err;
					uint32_t old = rtp_session->remote_rtcp_port;
					const char *tx_host;
					const char *old_host;
					char bufa[50], bufb[50];

					tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtcp_from_addr);
					old_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->rtcp_remote_addr);

					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,
									  "Auto Changing %s RTCP port from %s:%u to %s:%u\n", rtp_type(rtp_session), old_host, old, tx_host,
									  switch_sockaddr_get_port(rtp_session->rtcp_from_addr));


					rtp_session->eff_remote_host_str = switch_core_strdup(rtp_session->pool, tx_host);
					rtp_session->remote_rtcp_port = switch_sockaddr_get_port(rtp_session->rtcp_from_addr);
					status = enable_remote_rtcp_socket(rtp_session, &err);
					rtp_session->rtcp_auto_adj_used = 1;

					if ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {
						switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);
					} else {
						switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);
					}
				}
			} else {

				if ((rtp_session->rtp_bugs & RTP_BUG_ALWAYS_AUTO_ADJUST)) {
					switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);
				} else {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),
									  SWITCH_LOG_DEBUG, "Correct %s RTCP ip/port confirmed.\n", rtp_type(rtp_session));
					switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_RTCP_AUTOADJ);
				}
				rtp_session->rtcp_auto_adj_used = 0;

			}
	}

	if (*bytes) {
		return process_rtcp_packet(rtp_session, bytes);
	}

	return status;
}
