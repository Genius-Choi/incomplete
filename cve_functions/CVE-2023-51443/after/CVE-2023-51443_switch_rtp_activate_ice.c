SWITCH_DECLARE(switch_status_t) switch_rtp_activate_ice(switch_rtp_t *rtp_session, char *login, char *rlogin,
														const char *password, const char *rpassword, ice_proto_t proto,
														switch_core_media_ice_type_t type, ice_t *ice_params)
{
	char ice_user[STUN_USERNAME_MAX_SIZE];
	char user_ice[STUN_USERNAME_MAX_SIZE];
	char luser_ice[SDP_UFRAG_MAX_SIZE];
	switch_rtp_ice_t *ice;
	char *host = NULL;
	switch_port_t port = 0;
	char bufc[50];


	switch_mutex_lock(rtp_session->ice_mutex);

	if (proto == IPR_RTP) {
		ice = &rtp_session->ice;
		rtp_session->flags[SWITCH_RTP_FLAG_PAUSE] = 0;
		rtp_session->flags[SWITCH_RTP_FLAG_MUTE] = 0;
	} else {
		ice = &rtp_session->rtcp_ice;
	}

	ice->proto = proto;

	if ((type & ICE_VANILLA)) {
		switch_snprintf(ice_user, sizeof(ice_user), "%s:%s", login, rlogin);
		switch_snprintf(user_ice, sizeof(user_ice), "%s:%s", rlogin, login);
		switch_snprintf(luser_ice, sizeof(luser_ice), "%s%s", rlogin, login);
		ice->ready = ice->rready = 0;
		ice->cand_responsive = 0;
	} else {
		switch_snprintf(ice_user, sizeof(ice_user), "%s%s", login, rlogin);
		switch_snprintf(user_ice, sizeof(user_ice), "%s%s", rlogin, login);
		switch_snprintf(luser_ice, sizeof(luser_ice), "");
		ice->ready = ice->rready = 1;
		ice->cand_responsive = 0;
	}

	ice->ice_user = switch_core_strdup(rtp_session->pool, ice_user);
	ice->user_ice = switch_core_strdup(rtp_session->pool, user_ice);
	ice->luser_ice = switch_core_strdup(rtp_session->pool, luser_ice);
	ice->type = type;
	ice->ice_params = ice_params;
	ice->pass = "";
	ice->rpass = "";
	ice->next_run = switch_micro_time_now();
	ice->initializing = 1;

	if (password) {
		ice->pass = switch_core_strdup(rtp_session->pool, password);
	}

	if (rpassword) {
		ice->rpass = switch_core_strdup(rtp_session->pool, rpassword);
	}

	if ((ice->type & ICE_VANILLA) && ice->ice_params) {
		host = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_addr;
		port = ice->ice_params->cands[ice->ice_params->chosen[ice->proto]][ice->proto].con_port;

		if (!host || !port || switch_sockaddr_info_get(&ice->addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS || !ice->addr) {
			switch_mutex_unlock(rtp_session->ice_mutex);
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Error setting remote host!\n");
			return SWITCH_STATUS_FALSE;
		}
	} else {
		if (proto == IPR_RTP) {
			ice->addr = rtp_session->remote_addr;
		} else {
			ice->addr = rtp_session->rtcp_remote_addr;
		}

		host = (char *)switch_get_addr(bufc, sizeof(bufc), ice->addr);
		port = switch_sockaddr_get_port(ice->addr);
	}

	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_NOTICE, "Activating %s %s ICE: %s %s:%d\n",
					  proto == IPR_RTP ? "RTP" : "RTCP", rtp_type(rtp_session), ice_user, host, port);


	rtp_session->rtp_bugs |= RTP_BUG_ACCEPT_ANY_PACKETS;


	if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
		rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 1;
		switch_rtp_break(rtp_session);
	}

	switch_mutex_unlock(rtp_session->ice_mutex);

	return SWITCH_STATUS_SUCCESS;
}
