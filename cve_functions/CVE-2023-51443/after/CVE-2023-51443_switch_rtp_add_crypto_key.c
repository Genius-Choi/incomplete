SWITCH_DECLARE(switch_status_t) switch_rtp_add_crypto_key(switch_rtp_t *rtp_session, switch_rtp_crypto_direction_t direction, uint32_t index, switch_secure_settings_t *ssec)
{
#ifndef ENABLE_SRTP
	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, "SRTP NOT SUPPORTED IN THIS BUILD!\n");
	return SWITCH_STATUS_FALSE;
#else

	switch_rtp_crypto_key_t *crypto_key;
	srtp_policy_t *policy;
	srtp_err_status_t stat;
	switch_status_t status = SWITCH_STATUS_SUCCESS;

	switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);
	switch_event_t *fsevent = NULL;
	int idx = 0;
	const char *var;
	unsigned char b64_key[512] = "";
	
	unsigned char	*keysalt = NULL;
	switch_size_t	keysalt_len = 0;
	
	switch_crypto_key_material_t	*key_material = NULL;
	unsigned long					*key_material_n = NULL;
	srtp_master_key_t		**mkis = NULL;
	srtp_master_key_t		*mki = NULL;
	int mki_idx = 0;

	keysalt_len = switch_core_media_crypto_keysalt_len(ssec->crypto_type);

	if (direction >= SWITCH_RTP_CRYPTO_MAX || keysalt_len > SWITCH_RTP_MAX_CRYPTO_LEN) {
		return SWITCH_STATUS_FALSE;
	}

	if (direction == SWITCH_RTP_CRYPTO_RECV_RTCP) {
		direction = SWITCH_RTP_CRYPTO_RECV;
		rtp_session->srtp_idx_rtcp = idx = 1;
	} else if (direction == SWITCH_RTP_CRYPTO_SEND_RTCP) {
		direction = SWITCH_RTP_CRYPTO_SEND;
		rtp_session->srtp_idx_rtcp = idx = 1;
	}

	if (direction == SWITCH_RTP_CRYPTO_RECV) {
		policy = &rtp_session->recv_policy[idx];
		keysalt = ssec->remote_raw_key;
		key_material = ssec->remote_key_material_next;
		key_material_n = &ssec->remote_key_material_n;
	} else {
		policy = &rtp_session->send_policy[idx];
		keysalt = ssec->local_raw_key;
		key_material = ssec->local_key_material_next;
		key_material_n = &ssec->local_key_material_n;
	}

	switch_b64_encode(keysalt, keysalt_len, b64_key, sizeof(b64_key));

	if (switch_true(switch_core_get_variable("rtp_retain_crypto_keys"))) {
		switch(direction) {
			case SWITCH_RTP_CRYPTO_SEND:
				switch_channel_set_variable(channel, "srtp_local_crypto_key", (const char *)b64_key);
				break;
			case SWITCH_RTP_CRYPTO_RECV:
				switch_channel_set_variable(channel, "srtp_remote_crypto_key", (const char *)b64_key);
				break;
			default:
				break;
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
			switch(direction) {
			case SWITCH_RTP_CRYPTO_SEND:
				switch_channel_set_variable(channel, "srtp_local_video_crypto_key", (const char *)b64_key);
				break;
			case SWITCH_RTP_CRYPTO_RECV:
				switch_channel_set_variable(channel, "srtp_remote_video_crypto_key", (const char *)b64_key);
				break;
			default:
				break;
			}

		} else {
			switch(direction) {
			case SWITCH_RTP_CRYPTO_SEND:
				switch_channel_set_variable(channel, "srtp_local_audio_crypto_key", (const char *)b64_key);
				break;
			case SWITCH_RTP_CRYPTO_RECV:
				switch_channel_set_variable(channel, "srtp_remote_audio_crypto_key", (const char *)b64_key);
				break;
			default:
				break;
			}
		}
	}

	crypto_key = switch_core_alloc(rtp_session->pool, sizeof(*crypto_key));

	crypto_key->type = ssec->crypto_type;
	crypto_key->index = index;
	memcpy(crypto_key->keysalt, keysalt, keysalt_len);
	crypto_key->next = rtp_session->crypto_keys[direction];
	rtp_session->crypto_keys[direction] = crypto_key;

	memset(policy, 0, sizeof(*policy));

	/* many devices can't handle gaps in SRTP streams */
	if (!((var = switch_channel_get_variable(channel, "srtp_allow_idle_gaps"))
		  && switch_true(var))
		&& (!(var = switch_channel_get_variable(channel, "send_silence_when_idle"))
			|| !(atoi(var)))) {
		switch_channel_set_variable(channel, "send_silence_when_idle", "-1");
	}

	switch (crypto_key->type) {
	case AES_CM_128_HMAC_SHA1_80:
		srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_128_hmac_sha1_80(&policy->rtcp);

		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_128_HMAC_SHA1_80");
		}
		break;
	case AES_CM_128_HMAC_SHA1_32:
		srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_128_hmac_sha1_32(&policy->rtcp);


		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_128_HMAC_SHA1_32");
		}
		break;

	case AEAD_AES_256_GCM_8:
		srtp_crypto_policy_set_aes_gcm_256_8_auth(&policy->rtp);
		srtp_crypto_policy_set_aes_gcm_256_8_auth(&policy->rtcp);

		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AEAD_AES_256_GCM_8");
		}
		break;

	case AEAD_AES_256_GCM:
		srtp_crypto_policy_set_aes_gcm_256_16_auth(&policy->rtp);
		srtp_crypto_policy_set_aes_gcm_256_16_auth(&policy->rtcp);

		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AEAD_AES_256_GCM");
		}
		break;

	case AEAD_AES_128_GCM_8:
		srtp_crypto_policy_set_aes_gcm_128_8_auth(&policy->rtp);
		srtp_crypto_policy_set_aes_gcm_128_8_auth(&policy->rtcp);

		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AEAD_AES_128_GCM_8");
		}
		break;

	case AEAD_AES_128_GCM:
		srtp_crypto_policy_set_aes_gcm_128_16_auth(&policy->rtp);
		srtp_crypto_policy_set_aes_gcm_128_16_auth(&policy->rtcp);

		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AEAD_AES_128_GCM");
		}
		break;

	case AES_CM_256_HMAC_SHA1_80:
		srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80(&policy->rtcp);
		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_256_HMAC_SHA1_80");
		}
		break;
	case AES_CM_256_HMAC_SHA1_32:
		srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32(&policy->rtcp);
		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_256_HMAC_SHA1_32");
		}
		break;
	case AES_CM_192_HMAC_SHA1_80:
		srtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_192_hmac_sha1_80(&policy->rtcp);
		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_192_HMAC_SHA1_80");
		}
		break;
	case AES_CM_192_HMAC_SHA1_32:
		srtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_192_hmac_sha1_32(&policy->rtcp);
		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_192_HMAC_SHA1_32");
		}
		break;
	case AES_CM_128_NULL_AUTH:
		srtp_crypto_policy_set_aes_cm_128_null_auth(&policy->rtp);
		srtp_crypto_policy_set_aes_cm_128_null_auth(&policy->rtcp);

		if (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
			switch_channel_set_variable(channel, "rtp_has_crypto", "AES_CM_128_NULL_AUTH");
		}
		break;
	default:
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Missing crypto type!\n");
		break;
	}

	/* Setup the policy with MKI if they are used. Number of key materials must be positive to use MKI. */
	if (key_material && (*key_material_n > 0)) {

		if (direction == SWITCH_RTP_CRYPTO_RECV) {
			rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI] = 1;	/* tell the rest of the environment MKI is used */
		} else {
			rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI] = 1;	/* tell the rest of the environment MKI is used */
		}

		/* key must be NULL for libsrtp to work correctly with MKI. */
		policy->key = NULL;

		/* Allocate array for MKIs. */
		mkis = switch_core_alloc(rtp_session->pool, *key_material_n * sizeof(srtp_master_key_t*));
		if (!mkis) {
			return SWITCH_STATUS_FALSE;
		}

		/* Build array of MKIs. */
		mki_idx = 0;

		while (key_material && (mki_idx < *key_material_n)) {

			if (key_material->mki_size < 1) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "MKI bad key size at MKI %d\n", mki_idx);
				return SWITCH_STATUS_FALSE;
			}

			mki = switch_core_alloc(rtp_session->pool, sizeof(srtp_master_key_t));
			if (!mki) {
				return SWITCH_STATUS_FALSE;
			}

			/* Setup MKI. */
			mki->mki_id = switch_core_alloc(rtp_session->pool, sizeof(key_material->mki_size));
			if (!mki->mki_id) {
				return SWITCH_STATUS_FALSE;
			}

			mki->key = switch_core_alloc(rtp_session->pool, keysalt_len);
			if (!mki->key) {
				return SWITCH_STATUS_FALSE;
			}

			memcpy(mki->mki_id, &key_material->mki_id, key_material->mki_size);
			mki->mki_size = key_material->mki_size;
			memcpy(mki->key, key_material->raw_key, keysalt_len);

			mkis[mki_idx] = mki;

			key_material = key_material->next;
			++mki_idx;
		}

		/* And pass the array of MKIs to libsrtp. */
		policy->keys = mkis;
		policy->num_master_keys = mki_idx;

	} else {
		policy->key = (uint8_t *) crypto_key->keysalt;
	}

	policy->next = NULL;

	policy->window_size = 1024;
	policy->allow_repeat_tx = 1;

	//policy->rtp.sec_serv = sec_serv_conf_and_auth;
	//policy->rtcp.sec_serv = sec_serv_conf_and_auth;

	switch (direction) {
	case SWITCH_RTP_CRYPTO_RECV:
		policy->ssrc.type = ssrc_any_inbound;

		if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] && idx == 0 && rtp_session->recv_ctx[idx]) {
			rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_RESET] = 1;
		} else {
			if ((stat = srtp_create(&rtp_session->recv_ctx[idx], policy)) || !rtp_session->recv_ctx[idx]) {
				status = SWITCH_STATUS_FALSE;
			}

			if (status == SWITCH_STATUS_SUCCESS) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, "Activating %s Secure %s RECV%s\n",
								  rtp_type(rtp_session), idx ? "RTCP" : "RTP", rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV_MKI] ? " (with MKI)" : "");
				rtp_session->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 1;
			} else {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Error allocating srtp [%d]\n", stat);
				return status;
			}
		}
		break;
	case SWITCH_RTP_CRYPTO_SEND:
		policy->ssrc.type = ssrc_any_outbound;
		//policy->ssrc.type = ssrc_specific;
		//policy->ssrc.value = rtp_session->ssrc;

		if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] && idx == 0 && rtp_session->send_ctx[idx]) {
			rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET] = 1;
		} else {
			if ((stat = srtp_create(&rtp_session->send_ctx[idx], policy)) || !rtp_session->send_ctx[idx]) {
				status = SWITCH_STATUS_FALSE;
			}

			if (status == SWITCH_STATUS_SUCCESS) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, "Activating %s Secure %s SEND%s\n",
								  rtp_type(rtp_session), idx ? "RTCP" : "RTP", rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI] ? " (with MKI)" : "");
				rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 1;
			} else {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Error allocating SRTP [%d]\n", stat);
				return status;
			}
		}

		break;
	default:
		abort();
		break;
	}

	if (switch_event_create(&fsevent, SWITCH_EVENT_CALL_SECURE) == SWITCH_STATUS_SUCCESS) {
		if (rtp_session->dtls) {
			switch_event_add_header(fsevent, SWITCH_STACK_BOTTOM, "secure_type", "srtp:dtls:AES_CM_128_HMAC_SHA1_80");
			switch_channel_set_variable(channel, "rtp_has_crypto", "srtp:dtls:AES_CM_128_HMAC_SHA1_80");
		} else {
			switch_event_add_header(fsevent, SWITCH_STACK_BOTTOM, "secure_type", "srtp:sdes:%s", switch_channel_get_variable(channel, "rtp_has_crypto"));
		}
		switch_event_add_header_string(fsevent, SWITCH_STACK_BOTTOM, "caller-unique-id", switch_channel_get_uuid(channel));
		switch_event_fire(&fsevent);
	}


	return SWITCH_STATUS_SUCCESS;
#endif
}
