SWITCH_DECLARE(switch_status_t) switch_rtp_create(switch_rtp_t **new_rtp_session,
												  switch_payload_t payload,
												  uint32_t samples_per_interval,
												  uint32_t ms_per_packet,
												  switch_rtp_flag_t flags[SWITCH_RTP_FLAG_INVALID], char *timer_name, const char **err, switch_memory_pool_t *pool)
{
	switch_rtp_t *rtp_session = NULL;
	switch_core_session_t *session = switch_core_memory_pool_get_data(pool, "__session");
	switch_channel_t *channel = NULL;

	if (session) channel = switch_core_session_get_channel(session);

	*new_rtp_session = NULL;

	if (samples_per_interval > SWITCH_RTP_MAX_BUF_LEN) {
		*err = "Packet Size Too Large!";
		return SWITCH_STATUS_FALSE;
	}

	if (!(rtp_session = switch_core_alloc(pool, sizeof(*rtp_session)))) {
		*err = "Memory Error!";
		return SWITCH_STATUS_MEMERR;
	}

	rtp_session->pool = pool;
	rtp_session->te = INVALID_PT;
	rtp_session->recv_te = INVALID_PT;
	rtp_session->cng_pt = INVALID_PT;
	rtp_session->session = session;

	switch_mutex_init(&rtp_session->flag_mutex, SWITCH_MUTEX_NESTED, pool);
	switch_mutex_init(&rtp_session->read_mutex, SWITCH_MUTEX_NESTED, pool);
	switch_mutex_init(&rtp_session->write_mutex, SWITCH_MUTEX_NESTED, pool);
	switch_mutex_init(&rtp_session->ice_mutex, SWITCH_MUTEX_NESTED, pool);
	switch_mutex_init(&rtp_session->dtmf_data.dtmf_mutex, SWITCH_MUTEX_NESTED, pool);
	switch_queue_create(&rtp_session->dtmf_data.dtmf_queue, 100, rtp_session->pool);
	switch_queue_create(&rtp_session->dtmf_data.dtmf_inqueue, 100, rtp_session->pool);

	switch_rtp_set_flags(rtp_session, flags);

	/* for from address on recvfrom calls */
	switch_sockaddr_create(&rtp_session->from_addr, pool);
	switch_sockaddr_create(&rtp_session->rtp_from_addr, pool);

	if (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {
		switch_sockaddr_create(&rtp_session->rtcp_from_addr, pool);
	}

	rtp_session->seq = (uint16_t) rand();
	rtp_session->ssrc = (uint32_t) ((intptr_t) rtp_session + (switch_time_t) switch_epoch_time_now(NULL));
#ifdef DEBUG_TS_ROLLOVER
	rtp_session->last_write_ts = TS_ROLLOVER_START;
#endif
	rtp_session->stats.inbound.R = 100.0;
	rtp_session->stats.inbound.mos = 4.5;
	rtp_session->send_msg.header.ssrc = htonl(rtp_session->ssrc);
	rtp_session->send_msg.header.ts = 0;
	rtp_session->send_msg.header.m = 0;
	rtp_session->send_msg.header.pt = (switch_payload_t) htonl(payload);
	rtp_session->send_msg.header.version = 2;
	rtp_session->send_msg.header.p = 0;
	rtp_session->send_msg.header.x = 0;
	rtp_session->send_msg.header.cc = 0;

	rtp_session->recv_msg.header.ssrc = 0;
	rtp_session->recv_msg.header.ts = 0;
	rtp_session->recv_msg.header.seq = 0;
	rtp_session->recv_msg.header.m = 0;
	rtp_session->recv_msg.header.pt = (switch_payload_t) htonl(payload);
	rtp_session->recv_msg.header.version = 2;
	rtp_session->recv_msg.header.p = 0;
	rtp_session->recv_msg.header.x = 0;
	rtp_session->recv_msg.header.cc = 0;

	rtp_session->payload = payload;
	rtp_session->rtcp_last_sent = switch_micro_time_now();

	switch_rtp_set_interval(rtp_session, ms_per_packet, samples_per_interval);
	rtp_session->conf_samples_per_interval = samples_per_interval;

	if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] && zstr(timer_name)) {
		timer_name = "soft";
	}

	if (!zstr(timer_name) && !strcasecmp(timer_name, "none")) {
		timer_name = NULL;
	}

	if (!zstr(timer_name)) {
		rtp_session->timer_name = switch_core_strdup(pool, timer_name);
		switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);
		switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);

		if (switch_core_timer_init(&rtp_session->timer, timer_name, ms_per_packet / 1000, samples_per_interval, pool) == SWITCH_STATUS_SUCCESS) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,
							  "Starting timer [%s] %d bytes per %dms\n", timer_name, samples_per_interval, ms_per_packet / 1000);
			switch_core_timer_init(&rtp_session->write_timer, timer_name, (ms_per_packet / 1000), samples_per_interval, pool);
#ifdef DEBUG_TS_ROLLOVER
			rtp_session->timer.tick = TS_ROLLOVER_START / samples_per_interval;
#endif
		} else {
			memset(&rtp_session->timer, 0, sizeof(rtp_session->timer));
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,
							  "Error Starting timer [%s] %d bytes per %dms, async RTP disabled\n", timer_name, samples_per_interval, ms_per_packet / 1000);
			switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);
		}
	} else {
		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
			if (switch_core_timer_init(&rtp_session->timer, "soft", 1, 90, pool) == SWITCH_STATUS_SUCCESS) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, "Starting video timer.\n");
			}

			//switch_jb_create(&rtp_session->vb, 3, 10, rtp_session->pool);
			//switch_jb_debug_level(rtp_session->vb, 10);

		} else {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG, "Not using a timer\n");
		}

		switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER);
		switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);
	}


	if (channel) {
		switch_channel_set_private(channel, "__rtcp_audio_rtp_session", rtp_session);
	}


	/* Jitter */
	rtp_session->stats.inbound.last_proc_time = switch_micro_time_now() / 1000;
	rtp_session->stats.inbound.jitter_n = 0;
	rtp_session->stats.inbound.jitter_add = 0;
	rtp_session->stats.inbound.jitter_addsq = 0;
	rtp_session->stats.inbound.min_variance = 0;
	rtp_session->stats.inbound.max_variance = 0;

	/* Burst and Packet Loss */
	rtp_session->stats.inbound.lossrate = 0;
	rtp_session->stats.inbound.burstrate = 0;
	memset(rtp_session->stats.inbound.loss, 0, sizeof(rtp_session->stats.inbound.loss));
	rtp_session->stats.inbound.last_loss = 0;
	rtp_session->stats.inbound.last_processed_seq = -1;

	rtp_session->ready = 1;
	*new_rtp_session = rtp_session;

	return SWITCH_STATUS_SUCCESS;
}
