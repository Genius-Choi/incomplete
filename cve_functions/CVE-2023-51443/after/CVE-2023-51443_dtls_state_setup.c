static int dtls_state_setup(switch_rtp_t *rtp_session, switch_dtls_t *dtls)
{
	X509 *cert;
	switch_secure_settings_t	ssec;	/* Used just to wrap over params in a call to switch_rtp_add_crypto_key. */
	int r = 0;

	uint8_t raw_key_data[cr_kslen * 2];
	unsigned char local_key_buf[cr_kslen];
	unsigned char remote_key_buf[cr_kslen];

	memset(&ssec, 0, sizeof(ssec));
	memset(&raw_key_data, 0, cr_kslen * 2 * sizeof(uint8_t));
	memset(&local_key_buf, 0, cr_kslen * sizeof(unsigned char));
	memset(&remote_key_buf, 0, cr_kslen * sizeof(unsigned char));

	if ((dtls->type & DTLS_TYPE_SERVER)) {
		r = 1;
	} else if ((cert = SSL_get_peer_certificate(dtls->ssl))) {
		switch_core_cert_extract_fingerprint(cert, dtls->remote_fp);
		r = switch_core_cert_verify(dtls->remote_fp);
		X509_free(cert);
	}

	if (!r) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s Fingerprint Verification Failed!\n", rtp_type(rtp_session));
		dtls_set_state(dtls, DS_FAIL);
		return -1;
	} else {
		unsigned char *local_key, *remote_key, *local_salt, *remote_salt;

		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO, "%s Fingerprint Verified.\n", rtp_type(rtp_session));

#ifdef HAVE_OPENSSL_DTLS_SRTP
		if (!SSL_export_keying_material(dtls->ssl, raw_key_data, sizeof(raw_key_data), "EXTRACTOR-dtls_srtp", 19, NULL, 0, 0)) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s Key material export failure\n", rtp_type(rtp_session));
			dtls_set_state(dtls, DS_FAIL);
			return -1;
		}
#else
		return -1;
#endif

		if ((dtls->type & DTLS_TYPE_CLIENT)) {
			local_key = raw_key_data;
			remote_key = local_key + cr_keylen;
			local_salt = remote_key + cr_keylen;
			remote_salt = local_salt + cr_saltlen;

		} else {
			remote_key = raw_key_data;
			local_key = remote_key + cr_keylen;
			remote_salt = local_key + cr_keylen;
			local_salt = remote_salt + cr_saltlen;
		}

		memcpy(ssec.local_raw_key, local_key, cr_keylen);
		memcpy(ssec.local_raw_key + cr_keylen, local_salt, cr_saltlen);

		memcpy(ssec.remote_raw_key, remote_key, cr_keylen);
		memcpy(ssec.remote_raw_key + cr_keylen, remote_salt, cr_saltlen);

		ssec.crypto_type = AES_CM_128_HMAC_SHA1_80;

		if (dtls == rtp_session->rtcp_dtls && rtp_session->rtcp_dtls != rtp_session->dtls) {
			switch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_SEND_RTCP, 0, &ssec);
			switch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_RECV_RTCP, 0, &ssec);
		} else {
			switch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_SEND, 0, &ssec);
			switch_rtp_add_crypto_key(rtp_session, SWITCH_RTP_CRYPTO_RECV, 0, &ssec);
		}
	}

	dtls_set_state(dtls, DS_READY);

	return 0;
}
