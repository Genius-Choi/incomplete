static int jpegxl_anim_read_header(AVFormatContext *s)
{
    JXLAnimDemuxContext *ctx = s->priv_data;
    AVIOContext *pb = s->pb;
    AVStream *st;
    uint8_t head[256 + AV_INPUT_BUFFER_PADDING_SIZE];
    const int sizeofhead = sizeof(head) - AV_INPUT_BUFFER_PADDING_SIZE;
    int headsize = 0, ret;
    FFJXLMetadata meta = { 0 };

    uint64_t sig16 = avio_rl16(pb);
    if (sig16 == FF_JPEGXL_CODESTREAM_SIGNATURE_LE) {
        AV_WL16(head, sig16);
        headsize = avio_read(s->pb, head + 2, sizeofhead - 2);
        if (headsize < 0)
            return headsize;
        headsize += 2;
        ctx->initial = av_buffer_alloc(headsize);
        if (!ctx->initial)
            return AVERROR(ENOMEM);
        memcpy(ctx->initial->data, head, headsize);
    } else {
        uint64_t sig64 = avio_rl64(pb);
        sig64 = (sig64 << 16) | sig16;
        if (sig64 != FF_JPEGXL_CONTAINER_SIGNATURE_LE)
            return AVERROR_INVALIDDATA;
        avio_skip(pb, 2); // first box always 12 bytes
        while (1) {
            int copied = 0;
            uint8_t buf[4096];
            int read = avio_read(pb, buf, sizeof(buf));
            if (read < 0)
                return read;
            if (!ctx->initial) {
                ctx->initial = av_buffer_alloc(read + 12);
                if (!ctx->initial)
                    return AVERROR(ENOMEM);
                AV_WL64(ctx->initial->data, FF_JPEGXL_CONTAINER_SIGNATURE_LE);
                AV_WL32(ctx->initial->data + 8, 0x0a870a0d);
            } else {
                /* this only should be happening zero or one times in practice */
                if (av_buffer_realloc(&ctx->initial, ctx->initial->size + read) < 0)
                    return AVERROR(ENOMEM);
            }
            ff_jpegxl_collect_codestream_header(buf, read, head + headsize, sizeofhead - headsize, &copied);
            memcpy(ctx->initial->data + (ctx->initial->size - read), buf, read);
            headsize += copied;
            if (headsize >= sizeofhead || read < sizeof(buf))
                break;
        }
    }

    /* offset in bits of the animation header */
    ret = ff_jpegxl_parse_codestream_header(head, headsize, &meta, 0);
    if (ret < 0 || meta.animation_offset <= 0)
        return AVERROR_INVALIDDATA;

    st = avformat_new_stream(s, NULL);
    if (!st)
        return AVERROR(ENOMEM);

    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codecpar->codec_id   = AV_CODEC_ID_JPEGXL;
    avpriv_set_pts_info(st, 1, meta.timebase.num, meta.timebase.den);
    ffstream(st)->need_parsing = AVSTREAM_PARSE_FULL;

    return 0;
}
