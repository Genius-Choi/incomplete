authentic_create_file(struct sc_card *card, struct sc_file *file)
{
	struct sc_context *ctx = card->ctx;
	struct sc_apdu apdu;
	unsigned char sbuf[0x100];
	size_t sbuf_len;
	struct sc_path path;
	int rv;

	LOG_FUNC_CALLED(ctx);

	if (file->type != SC_FILE_TYPE_WORKING_EF)
		LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, "Creation of the file with of this type is not supported");

	authentic_debug_select_file(card, &file->path);

	sbuf_len = authentic_fcp_encode(card, file, sbuf + 2, sizeof(sbuf)-2);
	LOG_TEST_RET(ctx, sbuf_len, "FCP encode error");

	sbuf[0] = ISO7816_TAG_FCP;
	sbuf[1] = sbuf_len;

	if (card->cache.valid  && card->cache.current_df)   {
		const struct sc_acl_entry *entry = sc_file_get_acl_entry(card->cache.current_df, SC_AC_OP_CREATE);

		sc_log(ctx, "CREATE method/reference %X/%X", entry->method, entry->key_ref);
		if (entry->method == SC_AC_SCB)
			LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, "Not yet supported");
	}

	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0, 0);
	apdu.data = sbuf;
	apdu.datalen = sbuf_len + 2;
	apdu.lc = sbuf_len + 2;

	rv = sc_transmit_apdu(card, &apdu);
	LOG_TEST_RET(ctx, rv, "APDU transmit failed");
	rv = sc_check_sw(card, apdu.sw1, apdu.sw2);
	LOG_TEST_RET(ctx, rv, "authentic_create_file() create file error");

	path = file->path;
	memcpy(path.value, path.value + path.len - 2, 2);
	path.len = 2;
	rv = authentic_set_current_files(card, &path, sbuf, sbuf_len + 2, NULL);
	LOG_TEST_RET(ctx, rv, "authentic_select_file() cannot set 'current_file'");

	LOG_FUNC_RETURN(ctx, rv);
}
