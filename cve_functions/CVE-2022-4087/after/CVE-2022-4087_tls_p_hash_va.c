static void tls_p_hash_va ( struct tls_connection *tls,
			    struct digest_algorithm *digest,
			    const void *secret, size_t secret_len,
			    void *out, size_t out_len,
			    va_list seeds ) {
	uint8_t ctx[ hmac_ctxsize ( digest ) ];
	uint8_t ctx_partial[ sizeof ( ctx ) ];
	uint8_t a[digest->digestsize];
	uint8_t out_tmp[digest->digestsize];
	size_t frag_len = digest->digestsize;
	va_list tmp;

	DBGC2 ( tls, "TLS %p %s secret:\n", tls, digest->name );
	DBGC2_HD ( tls, secret, secret_len );

	/* Calculate A(1) */
	hmac_init ( digest, ctx, secret, secret_len );
	va_copy ( tmp, seeds );
	tls_hmac_update_va ( digest, ctx, tmp );
	va_end ( tmp );
	hmac_final ( digest, ctx, a );
	DBGC2 ( tls, "TLS %p %s A(1):\n", tls, digest->name );
	DBGC2_HD ( tls, &a, sizeof ( a ) );

	/* Generate as much data as required */
	while ( out_len ) {
		/* Calculate output portion */
		hmac_init ( digest, ctx, secret, secret_len );
		hmac_update ( digest, ctx, a, sizeof ( a ) );
		memcpy ( ctx_partial, ctx, sizeof ( ctx_partial ) );
		va_copy ( tmp, seeds );
		tls_hmac_update_va ( digest, ctx, tmp );
		va_end ( tmp );
		hmac_final ( digest, ctx, out_tmp );

		/* Copy output */
		if ( frag_len > out_len )
			frag_len = out_len;
		memcpy ( out, out_tmp, frag_len );
		DBGC2 ( tls, "TLS %p %s output:\n", tls, digest->name );
		DBGC2_HD ( tls, out, frag_len );

		/* Calculate A(i) */
		hmac_final ( digest, ctx_partial, a );
		DBGC2 ( tls, "TLS %p %s A(n):\n", tls, digest->name );
		DBGC2_HD ( tls, &a, sizeof ( a ) );

		out += frag_len;
		out_len -= frag_len;
	}
}
