static int tls_send_certificate ( struct tls_connection *tls ) {
	struct {
		tls24_t length;
		uint8_t data[0];
	} __attribute__ (( packed )) *certificate;
	struct {
		uint32_t type_length;
		tls24_t length;
		typeof ( *certificate ) certificates[0];
	} __attribute__ (( packed )) *certificates;
	struct x509_link *link;
	struct x509_certificate *cert;
	size_t len;
	int rc;

	/* Calculate length of client certificates */
	len = 0;
	list_for_each_entry ( link, &tls->certs->links, list ) {
		cert = link->cert;
		len += ( sizeof ( *certificate ) + cert->raw.len );
		DBGC ( tls, "TLS %p sending client certificate %s\n",
		       tls, x509_name ( cert ) );
	}

	/* Allocate storage for Certificate record (which may be too
	 * large for the stack).
	 */
	certificates = zalloc ( sizeof ( *certificates ) + len );
	if ( ! certificates )
		return -ENOMEM_CERTIFICATE;

	/* Populate record */
	certificates->type_length =
		( cpu_to_le32 ( TLS_CERTIFICATE ) |
		  htonl ( sizeof ( *certificates ) + len -
			  sizeof ( certificates->type_length ) ) );
	tls_set_uint24 ( &certificates->length, len );
	certificate = &certificates->certificates[0];
	list_for_each_entry ( link, &tls->certs->links, list ) {
		cert = link->cert;
		tls_set_uint24 ( &certificate->length, cert->raw.len );
		memcpy ( certificate->data, cert->raw.data, cert->raw.len );
		certificate = ( ( ( void * ) certificate->data ) +
				cert->raw.len );
	}

	/* Transmit record */
	rc = tls_send_handshake ( tls, certificates,
				  ( sizeof ( *certificates ) + len ) );

	/* Free record */
	free ( certificates );

	return rc;
}
