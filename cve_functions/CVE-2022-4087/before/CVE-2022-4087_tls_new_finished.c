static int tls_new_finished ( struct tls_connection *tls,
			      const void *data, size_t len ) {
	struct tls_session *session = tls->session;
	struct digest_algorithm *digest = tls->handshake_digest;
	const struct {
		uint8_t verify_data[ sizeof ( tls->verify.server ) ];
		char next[0];
	} __attribute__ (( packed )) *finished = data;
	uint8_t digest_out[ digest->digestsize ];

	/* Sanity check */
	if ( sizeof ( *finished ) != len ) {
		DBGC ( tls, "TLS %p received overlength Finished\n", tls );
		DBGC_HD ( tls, data, len );
		return -EINVAL_FINISHED;
	}

	/* Verify data */
	tls_verify_handshake ( tls, digest_out );
	tls_prf_label ( tls, &tls->master_secret, sizeof ( tls->master_secret ),
			tls->verify.server, sizeof ( tls->verify.server ),
			"server finished", digest_out, sizeof ( digest_out ) );
	if ( memcmp ( tls->verify.server, finished->verify_data,
		      sizeof ( tls->verify.server ) ) != 0 ) {
		DBGC ( tls, "TLS %p verification failed\n", tls );
		return -EPERM_VERIFY;
	}

	/* Mark server as finished */
	pending_put ( &tls->server_negotiation );

	/* If we are resuming a session (i.e. if the server Finished
	 * arrives before the client Finished is sent), then schedule
	 * transmission of Change Cipher and Finished.
	 */
	if ( is_pending ( &tls->client_negotiation ) ) {
		tls->tx_pending |= ( TLS_TX_CHANGE_CIPHER | TLS_TX_FINISHED );
		tls_tx_resume ( tls );
	}

	/* Record session ID, ticket, and master secret, if applicable */
	if ( tls->session_id_len || tls->new_session_ticket_len ) {
		memcpy ( session->master_secret, tls->master_secret,
			 sizeof ( session->master_secret ) );
	}
	if ( tls->session_id_len ) {
		session->id_len = tls->session_id_len;
		memcpy ( session->id, tls->session_id, sizeof ( session->id ) );
	}
	if ( tls->new_session_ticket_len ) {
		free ( session->ticket );
		session->ticket = tls->new_session_ticket;
		session->ticket_len = tls->new_session_ticket_len;
		tls->new_session_ticket = NULL;
		tls->new_session_ticket_len = 0;
	}

	/* Move to end of session's connection list and allow other
	 * connections to start making progress.
	 */
	list_del ( &tls->list );
	list_add_tail ( &tls->list, &session->conn );
	tls_tx_resume_all ( session );

	/* Send notification of a window change */
	xfer_window_changed ( &tls->plainstream );

	return 0;
}
