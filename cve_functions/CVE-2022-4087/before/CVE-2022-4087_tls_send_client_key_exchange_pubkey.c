static int tls_send_client_key_exchange_pubkey ( struct tls_connection *tls ) {
	struct tls_cipherspec *cipherspec = &tls->tx_cipherspec_pending;
	struct pubkey_algorithm *pubkey = cipherspec->suite->pubkey;
	size_t max_len = pubkey_max_len ( pubkey, cipherspec->pubkey_ctx );
	struct {
		uint16_t version;
		uint8_t random[46];
	} __attribute__ (( packed )) pre_master_secret;
	struct {
		uint32_t type_length;
		uint16_t encrypted_pre_master_secret_len;
		uint8_t encrypted_pre_master_secret[max_len];
	} __attribute__ (( packed )) key_xchg;
	size_t unused;
	int len;
	int rc;

	/* Generate pre-master secret */
	pre_master_secret.version = htons ( TLS_VERSION_MAX );
	if ( ( rc = tls_generate_random ( tls, &pre_master_secret.random,
			  ( sizeof ( pre_master_secret.random ) ) ) ) != 0 ) {
		return rc;
	}

	/* Generate master secret */
	tls_generate_master_secret ( tls, &pre_master_secret,
				     sizeof ( pre_master_secret ) );

	/* Generate keys */
	if ( ( rc = tls_generate_keys ( tls ) ) != 0 ) {
		DBGC ( tls, "TLS %p could not generate keys: %s\n",
		       tls, strerror ( rc ) );
		return rc;
	}

	/* Encrypt pre-master secret using server's public key */
	memset ( &key_xchg, 0, sizeof ( key_xchg ) );
	len = pubkey_encrypt ( pubkey, cipherspec->pubkey_ctx,
			       &pre_master_secret, sizeof ( pre_master_secret ),
			       key_xchg.encrypted_pre_master_secret );
	if ( len < 0 ) {
		rc = len;
		DBGC ( tls, "TLS %p could not encrypt pre-master secret: %s\n",
		       tls, strerror ( rc ) );
		return rc;
	}
	unused = ( max_len - len );
	key_xchg.type_length =
		( cpu_to_le32 ( TLS_CLIENT_KEY_EXCHANGE ) |
		  htonl ( sizeof ( key_xchg ) -
			  sizeof ( key_xchg.type_length ) - unused ) );
	key_xchg.encrypted_pre_master_secret_len =
		htons ( sizeof ( key_xchg.encrypted_pre_master_secret ) -
			unused );

	return tls_send_handshake ( tls, &key_xchg,
				    ( sizeof ( key_xchg ) - unused ) );
}
