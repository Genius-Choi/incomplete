  void Compute(OpKernelContext* context) override {
    const Tensor& min_input_tensor = context->input(1);
    const Tensor& max_input_tensor = context->input(2);
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),
                errors::InvalidArgument(
                    "min_input shape must be rank 0 but is rank ",
                    min_input_tensor.dims(),
                    ", received shape: ", min_input_tensor.shape()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),
                errors::InvalidArgument(
                    "max_input shape must be rank 0 but is rank ",
                    max_input_tensor.dims(),
                    ", received shape: ", max_input_tensor.shape()));
    const float min_input = context->input(1).scalar<float>()();
    const float max_input = context->input(2).scalar<float>()();
    MaxPoolingOp<Device, T>::Compute(context);
    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
    output_min->flat<float>()(0) = min_input;
    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
    output_max->flat<float>()(0) = max_input;
  }
