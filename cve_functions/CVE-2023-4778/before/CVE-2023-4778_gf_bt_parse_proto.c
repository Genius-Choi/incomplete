GF_Err gf_bt_parse_proto(GF_BTParser *parser, char *proto_code, GF_List *proto_list)
{
	GF_FieldInfo info;
	u32 fType, eType, QPType=0, pID;
	Bool externProto;
	GF_Proto *proto, *prevproto;
	GF_ProtoFieldInterface *pfield;
	GF_SceneGraph *sg;
	char *str, *name;
	char szDefName[1024];
	Bool isDEF;

	if (proto_code)
		str = proto_code;
	else
		str = gf_bt_get_next(parser, 0);

	externProto = !strcmp(str, "EXTERNPROTO") ? 1 : 0;
	str = gf_bt_get_next(parser, 0);
	name = gf_strdup(str);
	if (!gf_bt_check_code(parser, '[')) {
		return gf_bt_report(parser, GF_BAD_PARAM, "[ expected in proto declare");
	}
	pID = gf_bt_get_next_proto_id(parser);
	/*if redefinition remove it - WRL only, may be used by loadVRMLFormString*/
	if (!proto_list && parser->is_wrl) {
		proto = gf_sg_find_proto(parser->load->scene_graph, pID, name);
		if (proto) gf_sg_proto_del(proto);
	}
	proto = gf_sg_proto_new(parser->load->scene_graph, pID, name, proto_list ? 1 : 0);
	if (proto_list) gf_list_add(proto_list, proto);
	if (parser->load->ctx && (parser->load->ctx->max_proto_id<pID)) parser->load->ctx->max_proto_id = pID;

	/*hack for VRML, where externProto default field values are not mandatory*/
	parser->is_extern_proto_field = externProto;

	gf_free(name);
	/*get all fields*/
	while (!parser->last_error && !gf_bt_check_code(parser, ']')) {
		str = gf_bt_get_next(parser, 0);

next_field:
		if (gf_bt_check_code(parser, ']')) break;

		eType = get_evt_type(str);
		if (eType==GF_SG_EVENT_UNKNOWN) {
			gf_bt_report(parser, GF_BAD_PARAM, "%s: Unknown event type", str);
			goto err;
		}
		str = gf_bt_get_next(parser, 0);
		fType = gf_sg_field_type_by_name(str);
		if (fType==GF_SG_VRML_UNKNOWN) {
			gf_bt_report(parser, GF_BAD_PARAM, "%s: Unknown field type", str);
			goto err;
		}
		str = gf_bt_get_next(parser, 0);
		pfield = gf_sg_proto_field_new(proto, fType, eType, str);
		if ((eType==GF_SG_EVENT_IN) || (eType==GF_SG_EVENT_OUT)) continue;

		gf_sg_proto_field_get_field(pfield, &info);
		if (fType==GF_SG_VRML_SFNODE) {
			str = gf_bt_get_next(parser, 0);
			if (strcmp(str, "NULL")) {
				if ( (!strlen(str) || (get_evt_type(str)!=GF_SG_EVENT_UNKNOWN)) && parser->is_extern_proto_field) goto next_field;
				pfield->def_sfnode_value = gf_bt_sf_node(parser, str, NULL, NULL);
			}
		} else if (fType==GF_SG_VRML_MFNODE) {
			GF_ChildNodeItem *last = NULL;
			if (gf_bt_check_code(parser, '[')) {
				while (1) {
					GF_Node *pf_node;
					if (gf_bt_check_code(parser, ']')) break;
					pf_node = gf_bt_sf_node(parser, NULL, NULL, NULL);
					if (pf_node) gf_node_list_add_child_last( &pfield->def_mfnode_value, pf_node, &last);
				}
			}
		} else if (gf_sg_vrml_is_sf_field(fType)) {
			gf_bt_sffield(parser, &info, NULL);
			/*value not specified for externproto*/
			if (parser->last_error==GF_EOS) {
				parser->last_error=GF_OK;
				goto next_field;
			}
		} else {
			gf_bt_mffield(parser, &info, NULL);
		}
		/*check QP info*/
		if (!gf_bt_check_code(parser, '{')) continue;
		if (gf_bt_check_code(parser, '}')) continue;
		str = gf_bt_get_next(parser, 0);
		if (!strcmp(str, "QP")) {
			u32 nbBits, hasMin;
			Fixed ftMin, ftMax;
			gf_bt_parse_int(parser, "QPType", (SFInt32*)&QPType);

			nbBits = 0;
			str = gf_bt_get_next(parser, 0);
			if (!strcmp(str, "nbBits")) {
				gf_bt_parse_int(parser, "nbBits", (SFInt32*)&nbBits);
				str = gf_bt_get_next(parser, 0);
			}
			hasMin = 0;
			eType = 0;
			if (!strcmp(str, "b")) {
				hasMin = 1;
				if (!gf_bt_check_code(parser, '{')) {
					gf_bt_report(parser, GF_BAD_PARAM, "%s: Invalid proto coding parameter declare", str);
					goto err;
				}
				gf_bt_parse_float(parser, "min", &ftMin);
				gf_bt_parse_float(parser, "max", &ftMax);
				if (!gf_bt_check_code(parser, '}')) {
					gf_bt_report(parser, GF_BAD_PARAM, "Invalid proto coding parameter declare");
					goto err;
				}
				if (gf_sg_vrml_get_sf_type(fType) == GF_SG_VRML_SFINT32) {
					eType = GF_SG_VRML_SFINT32;
				} else {
					eType = GF_SG_VRML_SFFLOAT;
				}
			}
			gf_bifs_proto_field_set_aq_info(pfield, QPType, hasMin, eType, &ftMin, &ftMax, nbBits);
			if (!gf_bt_check_code(parser, '}')) {
				gf_bt_report(parser, GF_BAD_PARAM, "Invalid proto coding parameter declare");
				goto err;
			}
		}
	}
	parser->is_extern_proto_field = 0;

	if (externProto) {
		SFURL *url;
		Bool has_urls = 0;
		if (gf_bt_check_code(parser, '[')) has_urls = 1;

		gf_sg_vrml_mf_reset(&proto->ExternProto, GF_SG_VRML_MFURL);
		do {
			str = gf_bt_get_next(parser, 0);
			gf_sg_vrml_mf_append(&proto->ExternProto, GF_SG_VRML_MFURL, (void **) &url);
			if (!strnicmp(str, "od:", 3)) {
				sscanf(str, "od:%u", &url->OD_ID);
			} else {
				if (!sscanf(str, "%u", &url->OD_ID)) {
					url->url = gf_strdup(str);
				} else {
					char szURL[20];
					sprintf(szURL, "%d", url->OD_ID);
					if (strcmp(szURL, str)) {
						url->OD_ID = 0;
						url->url = gf_strdup(str);
					}
				}
			}
			if (has_urls) {
				gf_bt_check_code(parser, ',');
				if (gf_bt_check_code(parser, ']')) has_urls = 0;
			}
		} while (has_urls);
		return GF_OK;
	}

	/*parse proto code */
	if (!gf_bt_check_code(parser, '{')) {
		gf_bt_report(parser, GF_OK, "empty proto body");
		return GF_OK;
	}

	prevproto = parser->parsing_proto;
	sg = parser->load->scene_graph;
	parser->parsing_proto = proto;
	parser->load->scene_graph = gf_sg_proto_get_graph(proto);

	isDEF = 0;
	while (!gf_bt_check_code(parser, '}')) {
		str = gf_bt_get_next(parser, 0);
		if (!strcmp(str, "PROTO") || !strcmp(str, "EXTERNPROTO")) {
			gf_bt_parse_proto(parser, str, NULL);
		} else if (!strcmp(str, "DEF")) {
			isDEF = 1;
			str = gf_bt_get_next(parser, 0);
			strcpy(szDefName, str);
		} else if (!strcmp(str, "ROUTE")) {
			GF_Route *r = gf_bt_parse_route(parser, 1, 0, NULL);
			if (isDEF) {
				u32 rID = gf_bt_get_route(parser, szDefName);
				if (!rID) rID = gf_bt_get_next_route_id(parser);
				parser->last_error = gf_sg_route_set_id(r, rID);
				gf_sg_route_set_name(r, szDefName);
				isDEF = 0;
			}
		} else {
			GF_Node *n = gf_bt_sf_node(parser, str, NULL, isDEF ? szDefName : NULL);
			isDEF = 0;
			if (!n) goto err;
			if ((0) && isDEF) {
				u32 ID = gf_bt_get_def_id(parser, szDefName);
				isDEF = 0;
				gf_node_set_id(n, ID, szDefName);
			}
			gf_sg_proto_add_node_code(proto, n);
		}
	}
	gf_bt_resolve_routes(parser, 1);
	gf_bt_check_unresolved_nodes(parser);
	parser->load->scene_graph = sg;
	parser->parsing_proto = prevproto;
	return parser->last_error;

err:
	if (proto_list) gf_list_del_item(proto_list, proto);
	gf_sg_proto_del(proto);
	return parser->last_error;
}
