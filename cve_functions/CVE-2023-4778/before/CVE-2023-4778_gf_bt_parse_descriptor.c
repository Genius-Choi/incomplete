GF_Descriptor *gf_bt_parse_descriptor(GF_BTParser *parser, char *name)
{
	char *str, field[500];
	GF_Descriptor *desc, *subdesc;
	GF_ODF_FieldType type;
	u8 tag;
	if (name) {
		str = name;
	} else {
		str = gf_bt_get_next(parser, 0);
	}
	tag = gf_odf_get_tag_by_name(str);
	if (!tag) {
		gf_bt_report(parser, GF_BAD_PARAM, "%s: Unknown descriptor", str);
		return NULL;
	}
	desc = gf_odf_desc_new(tag);

	if (!desc) return NULL;
	if (!gf_bt_check_code(parser, '{')) return desc;

	while (1) {
		Bool is_anim_mask = 0;
		/*done*/
		if (gf_bt_check_code(parser, '}')) break;
		str = gf_bt_get_next(parser, 0);
		strcpy(field, str);

		if ((tag==GF_ODF_BIFS_CFG_TAG) && !strcmp(field, "animationMask")) {
			gf_bt_get_next(parser, 0);
			if (gf_bt_check_code(parser, '{')) is_anim_mask = 1;
			str = gf_bt_get_next(parser, 0);
			strcpy(field, str);
		}

		type = gf_odf_get_field_type(desc, str);
		switch (type) {
#ifndef GPAC_MINIMAL_ODF
		/*IPMPX list*/
		case GF_ODF_FT_IPMPX_LIST:
			if(desc->tag!=GF_ODF_IPMP_TAG) {
				gf_bt_report(parser, GF_BAD_PARAM, "IPMPX_Data list only allowed in GF_IPMP_Descriptor");
				gf_odf_desc_del(desc);
				return NULL;
			}
			if (gf_bt_check_code(parser, '[')) {
				while (!gf_bt_check_code(parser, ']')) {
					GF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);
					if (!ipmpx) {
						gf_odf_desc_del(desc);
						parser->last_error = GF_BAD_PARAM;
						return NULL;
					}
					gf_list_add( ((GF_IPMP_Descriptor *)desc)->ipmpx_data, ipmpx);
				}
			}
			break;
		/*IPMPX*/
		case GF_ODF_FT_IPMPX:
			if(desc->tag!=GF_ODF_IPMP_TOOL_TAG) {
				gf_bt_report(parser, GF_BAD_PARAM, "IPMPX_Data only allowed in GF_IPMP_Tool");
				gf_odf_desc_del(desc);
				return NULL;
			}
			if (gf_bt_check_code(parser, '[')) {
				while (!gf_bt_check_code(parser, ']')) {
					GF_IPMPX_Data *ipmpx = gf_bt_parse_ipmpx(parser, NULL);
					if (!ipmpx) {
						gf_odf_desc_del(desc);
						parser->last_error = GF_BAD_PARAM;
						return NULL;
					}
					if (ipmpx->tag==GF_IPMPX_PARAMETRIC_DESCRIPTION_TAG) {
						GF_IPMP_Tool *it = (GF_IPMP_Tool *)desc;
						if (it->toolParamDesc) gf_ipmpx_data_del((GF_IPMPX_Data *)it->toolParamDesc);
						it->toolParamDesc = (GF_IPMPX_ParametricDescription*)ipmpx;
					} else {
						gf_bt_report(parser, GF_OK, "Only ToolParametricDescription allowed in GF_IPMP_Tool - skipping");
						gf_ipmpx_data_del(ipmpx);
					}
				}
			}
			break;
#endif

		/*descriptor list*/
		case GF_ODF_FT_OD_LIST:
			if (gf_bt_check_code(parser, '[')) {
				while (!gf_bt_check_code(parser, ']')) {
					subdesc = gf_bt_parse_descriptor(parser, NULL);
					if (!subdesc) {
						gf_odf_desc_del(desc);
						parser->last_error = GF_BAD_PARAM;
						return NULL;
					}
					gf_bt_add_desc(parser, desc, subdesc, field);
				}
			}
			if (is_anim_mask)
				gf_bt_check_code(parser, '}');
			break;
		/*single descriptor*/
		case GF_ODF_FT_OD:
			str = gf_bt_get_next(parser, 0);
			subdesc = gf_bt_parse_descriptor(parser, str);
			if (!subdesc) {
				gf_bt_report(parser, GF_BAD_PARAM, "Unknown desc %s in field %s", str, field);
				gf_odf_desc_del(desc);
				return NULL;
			}
			gf_bt_add_desc(parser, desc, subdesc, field);
			break;
		/*regular field*/
		default:
			str = gf_bt_get_next(parser, 0);
			parser->last_error = gf_odf_set_field(desc, field, str);

			if (parser->last_error) {
				gf_bt_report(parser, GF_BAD_PARAM, "Invalid value %s in field %s", str, field);
				gf_odf_desc_del(desc);
				return NULL;
			}
			break;
		}
	}
	if (desc->tag == GF_ODF_BIFS_CFG_TAG) {
		GF_BIFSConfig *bcfg = (GF_BIFSConfig *)desc;
		if (!parser->load->ctx->scene_width) {
			parser->load->ctx->scene_width = bcfg->pixelWidth;
			parser->load->ctx->scene_height = bcfg->pixelHeight;
			parser->load->ctx->is_pixel_metrics = bcfg->pixelMetrics;
		}

		/*for bt->xmt*/
		if (!bcfg->version) bcfg->version = 1;
	}
	else if (desc->tag==GF_ODF_ESD_TAG) {
		GF_ESD *esd  =(GF_ESD*)desc;
		if (esd->decoderConfig) {
			GF_StreamContext *sc=NULL;
			GF_MuxInfo *mux;
			/*watchout for default BIFS stream*/
			if (parser->bifs_es && !parser->base_bifs_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) {
				parser->bifs_es->ESID = parser->base_bifs_id = esd->ESID;
				parser->bifs_es->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;
				sc = parser->bifs_es;
			} else {
				sc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);
				/*set default timescale for systems tracks (ignored for other)*/
				if (sc) sc->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;
				/*assign base OD*/
				if (!parser->base_od_id && (esd->decoderConfig->streamType==GF_STREAM_OD)) parser->base_od_id = esd->ESID;
			}
			/*assign broadcast parameter tools*/
			mux = gf_sm_get_mux_info(esd);
			if (sc && mux) {
				sc->aggregate_on_esid = mux->aggregate_on_esid;
				if (!mux->carousel_period_plus_one) sc->carousel_period  = (u32) -1;
				else sc->carousel_period = mux->carousel_period_plus_one - 1;
			}
		}
	} else if (desc->tag==GF_ODF_MUXINFO_TAG) {
		GF_MuxInfo *mi = (GF_MuxInfo *)desc;
		if (! mi->src_url) {
			mi->src_url = gf_strdup(parser->load->src_url ? parser->load->src_url : parser->load->fileName);
		}
	}
	return desc;
}
