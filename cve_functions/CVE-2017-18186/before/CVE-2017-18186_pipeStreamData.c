QPDF::pipeStreamData(int objid, int generation,
		     qpdf_offset_t offset, size_t length,
		     QPDFObjectHandle stream_dict,
		     Pipeline* pipeline,
                     bool suppress_warnings)
{
    bool success = false;
    std::vector<PointerHolder<Pipeline> > to_delete;
    if (this->m->encrypted)
    {
	decryptStream(pipeline, objid, generation, stream_dict, to_delete);
    }

    try
    {
	this->m->file->seek(offset, SEEK_SET);
	char buf[10240];
	while (length > 0)
	{
	    size_t to_read = (sizeof(buf) < length ? sizeof(buf) : length);
	    size_t len = this->m->file->read(buf, to_read);
	    if (len == 0)
	    {
		throw QPDFExc(qpdf_e_damaged_pdf,
			      this->m->file->getName(),
			      this->m->last_object_description,
			      this->m->file->getLastOffset(),
			      "unexpected EOF reading stream data");
	    }
	    length -= len;
	    pipeline->write(QUtil::unsigned_char_pointer(buf), len);
	}
        pipeline->finish();
        success = true;
    }
    catch (QPDFExc& e)
    {
        if (! suppress_warnings)
        {
            warn(e);
        }
    }
    catch (std::exception& e)
    {
        if (! suppress_warnings)
        {
            QTC::TC("qpdf", "QPDF decoding error warning");
            warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),
                         "", this->m->file->getLastOffset(),
                         "error decoding stream data for object " +
                         QUtil::int_to_string(objid) + " " +
                         QUtil::int_to_string(generation) + ": " + e.what()));
        }
    }
    if (! success)
    {
        try
        {
            pipeline->finish();
        }
        catch (std::exception&)
        {
            // ignore
        }
    }
    return success;
}
