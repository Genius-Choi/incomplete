static void tipc_link_update_cwin(struct tipc_link *l, int released,
				  bool retransmitted)
{
	int bklog_len = skb_queue_len(&l->backlogq);
	struct sk_buff_head *txq = &l->transmq;
	int txq_len = skb_queue_len(txq);
	u16 cwin = l->window;

	/* Enter fast recovery */
	if (unlikely(retransmitted)) {
		l->ssthresh = max_t(u16, l->window / 2, 300);
		l->window = min_t(u16, l->ssthresh, l->window);
		return;
	}
	/* Enter slow start */
	if (unlikely(!released)) {
		l->ssthresh = max_t(u16, l->window / 2, 300);
		l->window = l->min_win;
		return;
	}
	/* Don't increase window if no pressure on the transmit queue */
	if (txq_len + bklog_len < cwin)
		return;

	/* Don't increase window if there are holes the transmit queue */
	if (txq_len && l->snd_nxt - buf_seqno(skb_peek(txq)) != txq_len)
		return;

	l->cong_acks += released;

	/* Slow start  */
	if (cwin <= l->ssthresh) {
		l->window = min_t(u16, cwin + released, l->max_win);
		return;
	}
	/* Congestion avoidance */
	if (l->cong_acks < cwin)
		return;
	l->window = min_t(u16, ++cwin, l->max_win);
	l->cong_acks = 0;
}
