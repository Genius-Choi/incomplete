m_pullup(struct mbuf *m0, int len)
{
	struct mbuf *m;
	unsigned int adj;
	caddr_t head, tail;
	unsigned int space;

	/* if len is already contig in m0, then don't do any work */
	if (len <= m0->m_len)
		return (m0);

	/* look for some data */
	m = m0->m_next;
	if (m == NULL)
		goto freem0;

	head = M_DATABUF(m0);
	if (m0->m_len == 0) {
		while (m->m_len == 0) {
			m = m_free(m);
			if (m == NULL)
				goto freem0;
		}

		adj = mtod(m, unsigned long) & (sizeof(long) - 1);
	} else
		adj = mtod(m0, unsigned long) & (sizeof(long) - 1);

	tail = head + M_SIZE(m0);
	head += adj;

	if (!M_READONLY(m0) && len <= tail - head) {
		/* we can copy everything into the first mbuf */
		if (m0->m_len == 0) {
			m0->m_data = head;
		} else if (len > tail - mtod(m0, caddr_t)) {
			/* need to memmove to make space at the end */
			memmove(head, mtod(m0, caddr_t), m0->m_len);
			m0->m_data = head;
		}

		len -= m0->m_len;
	} else {
		/* the first mbuf is too small or read-only, make a new one */
		space = adj + len;

		if (space > MAXMCLBYTES)
			goto bad;

		m0->m_next = m;
		m = m0;

		MGET(m0, M_DONTWAIT, m->m_type);
		if (m0 == NULL)
			goto bad;

		if (space > MHLEN) {
			MCLGETL(m0, M_DONTWAIT, space);
			if ((m0->m_flags & M_EXT) == 0)
				goto bad;
		}

		if (m->m_flags & M_PKTHDR)
			M_MOVE_PKTHDR(m0, m);

		m0->m_len = 0;
		m0->m_data += adj;
	}

	KDASSERT(m_trailingspace(m0) >= len);

	for (;;) {
		space = min(len, m->m_len);
		memcpy(mtod(m0, caddr_t) + m0->m_len, mtod(m, caddr_t), space);
		len -= space;
		m0->m_len += space;
		m->m_len -= space;

		if (m->m_len > 0)
			m->m_data += space;
		else
			m = m_free(m);

		if (len == 0)
			break;

		if (m == NULL)
			goto bad;
	}

	m0->m_next = m; /* link the chain back up */

	return (m0);

bad:
	m_freem(m);
freem0:
	m_free(m0);
	return (NULL);
}
