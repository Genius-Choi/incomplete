static HRESULT VerifyFileAgainstContainer(
    __in BURN_CONTAINER* pContainer,
    __in_z LPCWSTR wzVerifyPath,
    __in BOOL fAlreadyCached,
    __in BURN_CACHE_STEP cacheStep,
    __in PFN_BURNCACHEMESSAGEHANDLER pfnCacheMessageHandler,
    __in LPPROGRESS_ROUTINE pfnProgress,
    __in LPVOID pContext
    )
{
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Get the container on disk actual hash.
    hFile = ::CreateFileW(wzVerifyPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (E_PATHNOTFOUND == hr || E_FILENOTFOUND == hr)
        {
            ExitFunction(); // do not log error when the file was not found.
        }
        ExitOnRootFailure(hr, "Failed to open container at path: %ls", wzVerifyPath);
    }

    switch (pContainer->verification)
    {
    case BURN_CONTAINER_VERIFICATION_HASH:
        hr = VerifyHash(pContainer->pbHash, pContainer->cbHash, pContainer->qwFileSize, TRUE, wzVerifyPath, hFile, cacheStep, pfnCacheMessageHandler, pfnProgress, pContext);
        ExitOnFailure(hr, "Failed to verify hash of container: %ls", pContainer->sczId);
        break;
    default:
        ExitOnRootFailure(hr = E_INVALIDARG, "Container has no verification information: %ls", pContainer->sczId);
        break;
    }

    if (fAlreadyCached)
    {
        LogId(REPORT_STANDARD, MSG_VERIFIED_EXISTING_CONTAINER, pContainer->sczId, wzVerifyPath);
        ::DecryptFileW(wzVerifyPath, 0);  // Let's try to make sure it's not encrypted.
    }

LExit:
    ReleaseFileHandle(hFile);

    if (FAILED(hr) && E_PATHNOTFOUND != hr && E_FILENOTFOUND != hr)
    {
        if (fAlreadyCached)
        {
            LogErrorId(hr, MSG_FAILED_VERIFY_CONTAINER, pContainer->sczId, wzVerifyPath, NULL);
        }

        FileEnsureDelete(wzVerifyPath); // if the file existed but did not verify correctly, make it go away.
    }

    return hr;
}
