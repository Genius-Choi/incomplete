static HRESULT VerifyHash(
    __in BYTE* pbHash,
    __in DWORD cbHash,
    __in DWORD64 qwFileSize,
    __in BOOL fVerifyFileSize,
    __in_z LPCWSTR wzUnverifiedPayloadPath,
    __in HANDLE hFile,
    __in BURN_CACHE_STEP cacheStep,
    __in PFN_BURNCACHEMESSAGEHANDLER pfnCacheMessageHandler,
    __in LPPROGRESS_ROUTINE /*pfnProgress*/,
    __in LPVOID pContext
    )
{
    HRESULT hr = S_OK;
    BYTE rgbActualHash[SHA512_HASH_LEN] = { };
    DWORD64 qwHashedBytes = 0;
    LPWSTR pszExpected = NULL;
    LPWSTR pszActual = NULL;
    BOOL fFailedVerification = FALSE;

    hr = SendCacheBeginMessage(pfnCacheMessageHandler, pContext, cacheStep);
    ExitOnFailure(hr, "Aborted cache verify hash begin.");

    fFailedVerification = TRUE;

    if (fVerifyFileSize)
    {
        hr = VerifyFileSize(hFile, qwFileSize, wzUnverifiedPayloadPath);
        ExitOnFailure(hr, "Failed to verify file size for path: %ls", wzUnverifiedPayloadPath);
    }

    // TODO: create a cryp hash file that sends progress.
    hr = CrypHashFileHandle(hFile, PROV_RSA_AES, CALG_SHA_512, rgbActualHash, sizeof(rgbActualHash), &qwHashedBytes);
    ExitOnFailure(hr, "Failed to calculate hash for path: %ls", wzUnverifiedPayloadPath);

    // Compare hashes.
    if (cbHash != sizeof(rgbActualHash) || 0 != memcmp(pbHash, rgbActualHash, sizeof(rgbActualHash)))
    {
        hr = CRYPT_E_HASH_VALUE;

        // Best effort to log the expected and actual hash value strings.
        if (SUCCEEDED(StrAllocHexEncode(pbHash, cbHash, &pszExpected)) &&
            SUCCEEDED(StrAllocHexEncode(rgbActualHash, sizeof(rgbActualHash), &pszActual)))
        {
            ExitOnFailure(hr, "Hash mismatch for path: %ls, expected: %ls, actual: %ls", wzUnverifiedPayloadPath, pszExpected, pszActual);
        }
        else
        {
            ExitOnFailure(hr, "Hash mismatch for path: %ls", wzUnverifiedPayloadPath);
        }
    }

    fFailedVerification = FALSE;

    hr = SendCacheSuccessMessage(pfnCacheMessageHandler, pContext, qwFileSize);

LExit:
    if (fFailedVerification)
    {
        // Make sure the BA process marks this container or payload as having failed verification.
        SendCacheFailureMessage(pfnCacheMessageHandler, pContext, cacheStep);
    }

    SendCacheCompleteMessage(pfnCacheMessageHandler, pContext, hr);

    ReleaseStr(pszActual);
    ReleaseStr(pszExpected);

    return hr;
}
