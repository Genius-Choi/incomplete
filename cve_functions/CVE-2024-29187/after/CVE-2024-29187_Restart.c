static HRESULT Restart(
    __in BURN_ENGINE_STATE* pEngineState
    )
{
    HRESULT hr = S_OK;
    DWORD dwRetries = 0;

    hr = ProcEnablePrivilege(::GetCurrentProcess(), SE_SHUTDOWN_NAME);
    ExitOnFailure(hr, "Failed to enable shutdown privilege in process token.");

    pEngineState->fRestarting = TRUE;
    CoreUpdateRestartState(pEngineState, BURN_RESTART_STATE_REQUESTING);

    do
    {
        hr = S_OK;

        if (dwRetries)
        {
            // On retry, wait a second to let the OS try to get to a place where the restart can
            // be initiated.
            ::Sleep(1000);
        }

        if (!vpfnInitiateSystemShutdownExW(NULL, NULL, 0, FALSE, TRUE, SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_INSTALLATION | SHTDN_REASON_FLAG_PLANNED))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    } while (dwRetries++ < RESTART_RETRIES && (HRESULT_FROM_WIN32(ERROR_MACHINE_LOCKED) == hr || HRESULT_FROM_WIN32(ERROR_NOT_READY) == hr));
    ExitOnRootFailure(hr, "Failed to schedule restart.");

    CoreUpdateRestartState(pEngineState, BURN_RESTART_STATE_REQUESTED);

    // Give the UI thread approximately 15 seconds to get the WM_QUERYENDSESSION message.
    for (DWORD i = 0; i < 60; ++i)
    {
        if (!::IsWindow(pEngineState->hMessageWindow))
        {
            ExitFunction();
        }

        if (BURN_RESTART_STATE_REQUESTED < pEngineState->restartState)
        {
            break;
        }

        ::Sleep(250);
    }

    if (BURN_RESTART_STATE_INITIATING > pEngineState->restartState)
    {
        LogId(REPORT_WARNING, MSG_RESTART_BLOCKED);
        ExitFunction();
    }

    // Give the UI thread the chance to process the WM_ENDSESSION message.
    for (;;)
    {
        if (!::IsWindow(pEngineState->hMessageWindow) || BURN_RESTART_STATE_INITIATING < pEngineState->restartState)
        {
            break;
        }

        ::Sleep(250);
    }

LExit:
    return hr;
}
