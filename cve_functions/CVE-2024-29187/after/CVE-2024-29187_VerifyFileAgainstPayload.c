static HRESULT VerifyFileAgainstPayload(
    __in BURN_PAYLOAD* pPayload,
    __in_z LPCWSTR wzVerifyPath,
    __in BOOL fAlreadyCached,
    __in BURN_CACHE_STEP cacheStep,
    __in PFN_BURNCACHEMESSAGEHANDLER pfnCacheMessageHandler,
    __in LPPROGRESS_ROUTINE pfnProgress,
    __in LPVOID pContext
    )
{
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL fVerifyFileSize = FALSE;

    // Get the payload on disk actual hash.
    hFile = ::CreateFileW(wzVerifyPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (E_PATHNOTFOUND == hr || E_FILENOTFOUND == hr)
        {
            ExitFunction(); // do not log error when the file was not found.
        }
        ExitOnRootFailure(hr, "Failed to open payload at path: %ls", wzVerifyPath);
    }

    switch (pPayload->verification)
    {
    case BURN_PAYLOAD_VERIFICATION_AUTHENTICODE:
        hr = CacheVerifyPayloadSignature(pPayload, wzVerifyPath, hFile, cacheStep, pfnCacheMessageHandler, pfnProgress, pContext);
        ExitOnFailure(hr, "Failed to verify signature of payload: %ls", pPayload->sczKey);
        break;
    case BURN_PAYLOAD_VERIFICATION_HASH:
        fVerifyFileSize = TRUE;

        hr = VerifyHash(pPayload->pbHash, pPayload->cbHash, pPayload->qwFileSize, fVerifyFileSize, wzVerifyPath, hFile, cacheStep, pfnCacheMessageHandler, pfnProgress, pContext);
        ExitOnFailure(hr, "Failed to verify hash of payload: %ls", pPayload->sczKey);

        break;
    case BURN_PAYLOAD_VERIFICATION_UPDATE_BUNDLE:
        fVerifyFileSize = 0 != pPayload->qwFileSize;

        if (pPayload->pbHash)
        {
            hr = VerifyHash(pPayload->pbHash, pPayload->cbHash, pPayload->qwFileSize, fVerifyFileSize, wzVerifyPath, hFile, cacheStep, pfnCacheMessageHandler, pfnProgress, pContext);
            ExitOnFailure(hr, "Failed to verify hash of payload: %ls", pPayload->sczKey);
        }
        else if (fVerifyFileSize)
        {
            hr = VerifyFileSize(hFile, pPayload->qwFileSize, wzVerifyPath);
            ExitOnFailure(hr, "Failed to verify file size for path: %ls", wzVerifyPath);
        }

        break;
    default:
        ExitOnRootFailure(hr = E_INVALIDARG, "Payload has no verification information: %ls", pPayload->sczKey);
        break;
    }

    if (fAlreadyCached)
    {
        LogId(REPORT_STANDARD, MSG_VERIFIED_EXISTING_PAYLOAD, pPayload->sczKey, wzVerifyPath);
        ::DecryptFileW(wzVerifyPath, 0);  // Let's try to make sure it's not encrypted.
    }

LExit:
    ReleaseFileHandle(hFile);

    if (FAILED(hr) && E_PATHNOTFOUND != hr && E_FILENOTFOUND != hr)
    {
        if (fAlreadyCached)
        {
            LogErrorId(hr, MSG_FAILED_VERIFY_PAYLOAD, pPayload->sczKey, wzVerifyPath, NULL);
        }

        FileEnsureDelete(wzVerifyPath); // if the file existed but did not verify correctly, make it go away.
    }

    return hr;
}
