static HRESULT DetectPackagePayloadsCached(
    __in BURN_CACHE* pCache,
    __in BURN_PACKAGE* pPackage
    )
{
    HRESULT hr = S_OK;
    LPWSTR sczCachePath = NULL;
    BOOL fCached = FALSE; // assume the package is not cached.
    LPWSTR sczPayloadCachePath = NULL;

    if (pPackage->sczCacheId && *pPackage->sczCacheId)
    {
        hr = CacheGetCompletedPath(pCache, pPackage->fPerMachine, pPackage->sczCacheId, &sczCachePath);
        ExitOnFailure(hr, "Failed to get completed cache path.");

        // If the cached directory exists, we have something.
        if (DirExists(sczCachePath, NULL))
        {
            // Check all payloads to see if any exist.
            for (DWORD i = 0; i < pPackage->payloads.cItems; ++i)
            {
                BURN_PAYLOAD* pPayload = pPackage->payloads.rgItems[i].pPayload;

                hr = PathConcatRelativeToFullyQualifiedBase(sczCachePath, pPayload->sczFilePath, &sczPayloadCachePath);
                ExitOnFailure(hr, "Failed to concat payload cache path.");

                if (FileExistsEx(sczPayloadCachePath, NULL))
                {
                    fCached = TRUE;
                    break;
                }
                else
                {
                    LogId(REPORT_STANDARD, MSG_DETECT_PACKAGE_NOT_FULLY_CACHED, pPackage->sczId, pPayload->sczKey);
                }
            }
        }
    }

    pPackage->fCached = fCached;

    if (pPackage->fCanAffectRegistration)
    {
        pPackage->cacheRegistrationState = pPackage->fCached ? BURN_PACKAGE_REGISTRATION_STATE_PRESENT : BURN_PACKAGE_REGISTRATION_STATE_ABSENT;
    }

LExit:
    ReleaseStr(sczPayloadCachePath);
    ReleaseStr(sczCachePath);
    return hr;
}
