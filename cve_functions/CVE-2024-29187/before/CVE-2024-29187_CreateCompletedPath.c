static HRESULT CreateCompletedPath(
    __in BURN_CACHE* pCache,
    __in BOOL fPerMachine,
    __in LPCWSTR wzId,
    __in LPCWSTR wzFilePath,
    __out_z LPWSTR* psczCachePath
    )
{
    HRESULT hr = S_OK;
    LPWSTR sczCacheDirectory = NULL;
    LPWSTR sczCacheFile = NULL;

    if (fPerMachine)
    {
        hr = SecurePerMachineCacheRoot(pCache);
        ExitOnFailure(hr, "Failed to secure per-machine cache root.");
    }

    // Get the cache completed path.
    hr = CacheGetCompletedPath(pCache, fPerMachine, wzId, &sczCacheDirectory);
    ExitOnFailure(hr, "Failed to get cache directory.");

    // Ensure it exists.
    hr = DirEnsureExists(sczCacheDirectory, NULL);
    ExitOnFailure(hr, "Failed to create cache directory: %ls", sczCacheDirectory);

    if (!wzFilePath)
    {
        // Reset any permissions people might have tried to set on the directory
        // so we inherit the (correct!) security permissions from the parent directory.
        ResetPathPermissions(fPerMachine, sczCacheDirectory);

        *psczCachePath = sczCacheDirectory;
        sczCacheDirectory = NULL;
    }
    else
    {
        // Get the cache completed file path.
        hr = PathConcatRelativeToFullyQualifiedBase(sczCacheDirectory, wzFilePath, &sczCacheFile);
        ExitOnFailure(hr, "Failed to construct cache file.");

        // Don't reset permissions here. The payload's package must reset its cache folder when it starts caching.

        *psczCachePath = sczCacheFile;
        sczCacheFile = NULL;
    }

LExit:
    ReleaseStr(sczCacheDirectory);
    ReleaseStr(sczCacheFile);
    return hr;
}
