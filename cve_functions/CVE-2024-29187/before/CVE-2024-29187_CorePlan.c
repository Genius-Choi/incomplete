extern "C" HRESULT CorePlan(
    __in BURN_ENGINE_STATE* pEngineState,
    __in BOOTSTRAPPER_ACTION action
    )
{
    HRESULT hr = S_OK;
    BOOL fPlanBegan = FALSE;
    BURN_PACKAGE* pUpgradeBundlePackage = NULL;
    BURN_PACKAGE* pForwardCompatibleBundlePackage = NULL;
    BOOL fContinuePlanning = TRUE; // assume we won't skip planning due to dependencies.

    LogId(REPORT_STANDARD, MSG_PLAN_BEGIN, pEngineState->packages.cPackages, LoggingBurnActionToString(action));

    fPlanBegan = TRUE;
    hr = UserExperienceOnPlanBegin(&pEngineState->userExperience, pEngineState->packages.cPackages);
    ExitOnRootFailure(hr, "BA aborted plan begin.");

    if (!pEngineState->fDetected)
    {
        ExitWithRootFailure(hr, E_INVALIDSTATE, "Plan cannot be done without a successful Detect.");
    }
    else if (pEngineState->plan.fAffectedMachineState)
    {
        ExitWithRootFailure(hr, E_INVALIDSTATE, "Plan requires a new successful Detect after calling Apply.");
    }

    // Always reset the plan.
    pEngineState->fPlanned = FALSE;
    PlanReset(&pEngineState->plan, &pEngineState->variables, &pEngineState->containers, &pEngineState->packages, &pEngineState->layoutPayloads);

    hr = PlanSetVariables(action, &pEngineState->variables);
    ExitOnFailure(hr, "Failed to update action.");

    // Remember the overall action state in the plan since it shapes the changes
    // we make everywhere.
    pEngineState->plan.action = action;
    pEngineState->plan.pCache = &pEngineState->cache;
    pEngineState->plan.pCommand = &pEngineState->command;
    pEngineState->plan.pInternalCommand = &pEngineState->internalCommand;
    pEngineState->plan.pPayloads = &pEngineState->payloads;
    pEngineState->plan.wzBundleId = pEngineState->registration.sczId;
    pEngineState->plan.wzBundleProviderKey = pEngineState->registration.sczId;
    pEngineState->plan.fDisableRollback = pEngineState->fDisableRollback || BOOTSTRAPPER_ACTION_UNSAFE_UNINSTALL == pEngineState->plan.action;
    pEngineState->plan.fPlanPackageCacheRollback = BOOTSTRAPPER_REGISTRATION_TYPE_NONE == pEngineState->registration.detectedRegistrationType;

    // Set resume commandline
    hr = PlanSetResumeCommand(&pEngineState->plan, &pEngineState->registration, &pEngineState->log);
    ExitOnFailure(hr, "Failed to set resume command");

    hr = DependencyPlanInitialize(&pEngineState->dependencies, &pEngineState->plan);
    ExitOnFailure(hr, "Failed to initialize the dependencies for the plan.");

    hr = RegistrationPlanInitialize(&pEngineState->registration);
    ExitOnFailure(hr, "Failed to initialize registration for the plan.");

    if (BOOTSTRAPPER_ACTION_LAYOUT == action)
    {
        Assert(!pEngineState->plan.fPerMachine);

        // Plan the bundle's layout.
        hr = PlanLayoutBundle(&pEngineState->plan, pEngineState->registration.sczExecutableName, pEngineState->section.qwBundleSize, &pEngineState->variables, &pEngineState->layoutPayloads);
        ExitOnFailure(hr, "Failed to plan the layout of the bundle.");

        // Plan the packages' layout.
        hr = PlanPackages(&pEngineState->userExperience, &pEngineState->packages, &pEngineState->plan, &pEngineState->log, &pEngineState->variables);
        ExitOnFailure(hr, "Failed to plan packages.");
    }
    else if (BOOTSTRAPPER_ACTION_UPDATE_REPLACE == action || BOOTSTRAPPER_ACTION_UPDATE_REPLACE_EMBEDDED == action)
    {
        Assert(!pEngineState->plan.fPerMachine);

        pUpgradeBundlePackage = &pEngineState->update.package;

        hr = PlanUpdateBundle(&pEngineState->userExperience, pUpgradeBundlePackage, &pEngineState->plan, &pEngineState->log, &pEngineState->variables);
        ExitOnFailure(hr, "Failed to plan update.");
    }
    else
    {
        hr = PlanForwardCompatibleBundles(&pEngineState->userExperience, &pEngineState->plan, &pEngineState->registration);
        ExitOnFailure(hr, "Failed to plan forward compatible bundles.");

        if (pEngineState->plan.fEnabledForwardCompatibleBundle)
        {
            Assert(!pEngineState->plan.fPerMachine);

            pForwardCompatibleBundlePackage = &pEngineState->plan.forwardCompatibleBundle;

            hr = PlanPassThroughBundle(&pEngineState->userExperience, pForwardCompatibleBundlePackage, &pEngineState->plan, &pEngineState->log, &pEngineState->variables);
            ExitOnFailure(hr, "Failed to plan passthrough.");
        }
        else // doing an action that modifies the machine state.
        {
            pEngineState->plan.fPerMachine = pEngineState->registration.fPerMachine; // default the scope of the plan to the per-machine state of the bundle.

            hr = PlanRelatedBundlesInitialize(&pEngineState->userExperience, &pEngineState->registration, pEngineState->command.relationType, &pEngineState->plan);
            ExitOnFailure(hr, "Failed to initialize related bundles for plan.");

            if (pEngineState->plan.fDowngrade)
            {
                fContinuePlanning = FALSE;
            }
            else
            {
                hr = PlanRegistration(&pEngineState->plan, &pEngineState->registration, &pEngineState->dependencies, pEngineState->command.resumeType, pEngineState->command.relationType, &fContinuePlanning);
                ExitOnFailure(hr, "Failed to plan registration.");
            }

            if (fContinuePlanning)
            {
                // Remember the early index, because we want to be able to insert some related bundles
                // into the plan before other executed packages. This particularly occurs for uninstallation
                // of addons and patches, which should be uninstalled before the main product.
                DWORD dwExecuteActionEarlyIndex = pEngineState->plan.cExecuteActions;

                // Plan the related bundles first to support downgrades with ref-counting.
                hr = PlanRelatedBundlesBegin(&pEngineState->userExperience, &pEngineState->registration, pEngineState->command.relationType, &pEngineState->plan);
                ExitOnFailure(hr, "Failed to plan related bundles.");

                hr = PlanPackages(&pEngineState->userExperience, &pEngineState->packages, &pEngineState->plan, &pEngineState->log, &pEngineState->variables);
                ExitOnFailure(hr, "Failed to plan packages.");

                // Schedule the update of related bundles last.
                hr = PlanRelatedBundlesComplete(&pEngineState->userExperience, &pEngineState->registration, &pEngineState->plan, &pEngineState->log, &pEngineState->variables, dwExecuteActionEarlyIndex);
                ExitOnFailure(hr, "Failed to schedule related bundles.");
            }
        }
    }

    if (fContinuePlanning)
    {
        // Finally, display all packages and related bundles in the log.
        LogPackages(pUpgradeBundlePackage, pForwardCompatibleBundlePackage, &pEngineState->packages, &pEngineState->registration.relatedBundles, action);
    }

    PlanDump(&pEngineState->plan);

LExit:
    if (SUCCEEDED(hr))
    {
        pEngineState->fPlanned = TRUE;
    }

    if (fPlanBegan)
    {
        UserExperienceOnPlanComplete(&pEngineState->userExperience, hr);
    }

    LogId(REPORT_STANDARD, MSG_PLAN_COMPLETE, hr);

    return hr;
}
