extern "C" HRESULT CacheEnsureBaseWorkingFolder(
    __in BURN_CACHE* pCache,
    __deref_out_z_opt LPWSTR* psczBaseWorkingFolder
    )
{
    Assert(pCache->fInitializedCache);

    HRESULT hr = S_OK;
    LPWSTR sczPotential = NULL;

    if (!pCache->fInitializedBaseWorkingFolder)
    {
        for (DWORD i = 0; i < pCache->cPotentialBaseWorkingFolders; ++i)
        {
            hr = PathConcatRelativeToFullyQualifiedBase(pCache->rgsczPotentialBaseWorkingFolders[i], pCache->wzGuid, &sczPotential);
            if (SUCCEEDED(hr))
            {
                hr = DirEnsureExists(sczPotential, NULL);
                if (SUCCEEDED(hr))
                {
                    pCache->sczBaseWorkingFolder = sczPotential;
                    sczPotential = NULL;
                    break;
                }
            }

            LogErrorId(hr, MSG_INVALID_BASE_WORKING_FOLDER, sczPotential, NULL, NULL);
        }

        ExitOnNull(pCache->sczBaseWorkingFolder, hr, E_INVALIDSTATE, "No usable base working folder found.");

        pCache->fInitializedBaseWorkingFolder = TRUE;
    }

    // Best effort to ensure our working folder is not encrypted.
    ::DecryptFileW(pCache->sczBaseWorkingFolder, 0);

    if (psczBaseWorkingFolder)
    {
        hr = StrAllocString(psczBaseWorkingFolder, pCache->sczBaseWorkingFolder, 0);
        ExitOnFailure(hr, "Failed to copy working folder.");
    }

LExit:
    ReleaseStr(sczPotential);

    return hr;
}
