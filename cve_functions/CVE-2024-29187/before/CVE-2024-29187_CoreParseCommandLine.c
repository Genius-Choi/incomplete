extern "C" HRESULT CoreParseCommandLine(
    __in BURN_ENGINE_COMMAND* pInternalCommand,
    __in BOOTSTRAPPER_COMMAND* pCommand,
    __in BURN_PIPE_CONNECTION* pCompanionConnection,
    __in BURN_PIPE_CONNECTION* pEmbeddedConnection,
    __inout HANDLE* phSectionFile,
    __inout HANDLE* phSourceEngineFile
    )
{
    HRESULT hr = S_OK;
    BOOL fUnknownArg = FALSE;
    BOOL fInvalidCommandLine = FALSE;
    DWORD64 qw = 0;
    int argc = pInternalCommand->argc;
    LPWSTR* argv = pInternalCommand->argv;

    for (int i = 0; i < argc; ++i)
    {
        fUnknownArg = FALSE;

        if (argv[i][0] == L'-' || argv[i][0] == L'/')
        {
            if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"l", -1) ||
                CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"log", -1) ||
                CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"xlog", -1))
            {
                pInternalCommand->dwLoggingAttributes &= ~BURN_LOGGING_ATTRIBUTE_APPEND;

                if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], 1, L"x", 1))
                {
                    pInternalCommand->dwLoggingAttributes |= BURN_LOGGING_ATTRIBUTE_VERBOSE | BURN_LOGGING_ATTRIBUTE_EXTRADEBUG;
                }

                if (i + 1 >= argc)
                {
                    fInvalidCommandLine = TRUE;
                    ExitOnRootFailure(hr = E_INVALIDARG, "Must specify a path for log.");
                }

                ++i;

                hr = PathExpand(&pInternalCommand->sczLogFile, argv[i], PATH_EXPAND_FULLPATH);
                ExitOnFailure(hr, "Failed to copy log file path.");
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"?", -1) ||
                     CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"h", -1) ||
                     CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"help", -1))
            {
                pCommand->action = BOOTSTRAPPER_ACTION_HELP;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"q", -1) ||
                     CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"quiet", -1) ||
                     CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"s", -1) ||
                     CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"silent", -1))
            {
                pCommand->display = BOOTSTRAPPER_DISPLAY_NONE;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"passive", -1))
            {
                pCommand->display = BOOTSTRAPPER_DISPLAY_PASSIVE;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"layout", -1))
            {
                if (BOOTSTRAPPER_ACTION_HELP != pCommand->action)
                {
                    pCommand->action = BOOTSTRAPPER_ACTION_LAYOUT;
                }

                // If there is another command line argument and it is not a switch, use that as the layout directory.
                if (i + 1 < argc && argv[i + 1][0] != L'-' && argv[i + 1][0] != L'/')
                {
                    ++i;

                    hr = PathExpand(&pCommand->wzLayoutDirectory, argv[i], PATH_EXPAND_ENVIRONMENT | PATH_EXPAND_FULLPATH);
                    ExitOnFailure(hr, "Failed to copy path for layout directory.");
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"unsafeuninstall", -1))
            {
                if (BOOTSTRAPPER_ACTION_HELP != pCommand->action)
                {
                    pCommand->action = BOOTSTRAPPER_ACTION_UNSAFE_UNINSTALL;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"uninstall", -1))
            {
                if (BOOTSTRAPPER_ACTION_HELP != pCommand->action)
                {
                    pCommand->action = BOOTSTRAPPER_ACTION_UNINSTALL;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"repair", -1))
            {
                if (BOOTSTRAPPER_ACTION_HELP != pCommand->action)
                {
                    pCommand->action = BOOTSTRAPPER_ACTION_REPAIR;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"modify", -1))
            {
                if (BOOTSTRAPPER_ACTION_HELP != pCommand->action)
                {
                    pCommand->action = BOOTSTRAPPER_ACTION_MODIFY;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"package", -1) ||
                     CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"update", -1))
            {
                if (BOOTSTRAPPER_ACTION_UNKNOWN == pCommand->action)
                {
                    pCommand->action = BOOTSTRAPPER_ACTION_INSTALL;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"noaupause", -1))
            {
                pInternalCommand->automaticUpdates = BURN_AU_PAUSE_ACTION_NONE;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"keepaupaused", -1))
            {
                // Switch /noaupause takes precedence.
                if (BURN_AU_PAUSE_ACTION_NONE != pInternalCommand->automaticUpdates)
                {
                    pInternalCommand->automaticUpdates = BURN_AU_PAUSE_ACTION_IFELEVATED_NORESUME;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"disablesystemrestore", -1))
            {
                pInternalCommand->fDisableSystemRestore = TRUE;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, L"originalsource", -1))
            {
                if (i + 1 >= argc)
                {
                    fInvalidCommandLine = TRUE;
                    ExitOnRootFailure(hr = E_INVALIDARG, "Must specify a path for original source.");
                }

                ++i;
                hr = PathExpand(&pInternalCommand->sczOriginalSource, argv[i], PATH_EXPAND_FULLPATH);
                ExitOnFailure(hr, "Failed to copy last used source.");
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_PARENT, -1))
            {
                if (i + 1 >= argc)
                {
                    fInvalidCommandLine = TRUE;
                    ExitOnRootFailure(hr = E_INVALIDARG, "Must specify a value for parent.");
                }

                ++i;

                hr = StrAllocString(&pInternalCommand->sczActiveParent, argv[i], 0);
                ExitOnFailure(hr, "Failed to copy parent.");
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_PARENT_NONE, -1))
            {
                hr = StrAllocString(&pInternalCommand->sczActiveParent, L"", 0);
                ExitOnFailure(hr, "Failed to initialize parent to none.");
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_LOG_APPEND, -1))
            {
                if (i + 1 >= argc)
                {
                    fInvalidCommandLine = TRUE;
                    ExitOnRootFailure(hr = E_INVALIDARG, "Must specify a path for append log.");
                }

                ++i;

                hr = PathExpand(&pInternalCommand->sczLogFile, argv[i], PATH_EXPAND_FULLPATH);
                ExitOnFailure(hr, "Failed to copy append log file path.");

                pInternalCommand->dwLoggingAttributes |= BURN_LOGGING_ATTRIBUTE_APPEND;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_LOG_MODE), BURN_COMMANDLINE_SWITCH_LOG_MODE, -1))
            {
                // Get a pointer to the next character after the switch.
                LPCWSTR wzParam = &argv[i][2 + lstrlenW(BURN_COMMANDLINE_SWITCH_LOG_MODE)];
                if (L'=' != wzParam[-1] || L'\0' == wzParam[0])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Missing required parameter for switch: %ls", BURN_COMMANDLINE_SWITCH_LOG_MODE);
                }
                else
                {
                    while (L'\0' != wzParam[0])
                    {
                        switch (wzParam[0])
                        {
                        case L'x':
                            pInternalCommand->dwLoggingAttributes |= BURN_LOGGING_ATTRIBUTE_EXTRADEBUG | BURN_LOGGING_ATTRIBUTE_VERBOSE;
                            break;
                        default:
                            // Skip (but log) any other modifiers we don't recognize,
                            // so that adding future modifiers doesn't break old bundles.
                            LogId(REPORT_STANDARD, MSG_BURN_UNKNOWN_PRIVATE_SWITCH_MODIFIER, BURN_COMMANDLINE_SWITCH_LOG_MODE, wzParam[0]);
                            break;
                        }

                        ++wzParam;
                    }
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_ELEVATED, -1))
            {
                if (i + 3 >= argc)
                {
                    fInvalidCommandLine = TRUE;
                    ExitOnRootFailure(hr = E_INVALIDARG, "Must specify the elevated name, token and parent process id.");
                }

                if (BURN_MODE_UNKNOWN != pInternalCommand->mode)
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Multiple mode command-line switches were provided.");
                }

                pInternalCommand->mode = BURN_MODE_ELEVATED;

                ++i;

                hr = MemEnsureArraySizeForNewItems(reinterpret_cast<LPVOID*>(&pInternalCommand->rgSecretArgs), pInternalCommand->cSecretArgs, 3, sizeof(int), 3);
                ExitOnFailure(hr, "Failed to ensure size for secret args.");

                pInternalCommand->rgSecretArgs[pInternalCommand->cSecretArgs] = i;
                pInternalCommand->cSecretArgs += 1;
                pInternalCommand->rgSecretArgs[pInternalCommand->cSecretArgs] = i + 1;
                pInternalCommand->cSecretArgs += 1;
                pInternalCommand->rgSecretArgs[pInternalCommand->cSecretArgs] = i + 2;
                pInternalCommand->cSecretArgs += 1;

                hr = ParsePipeConnection(argv + i, pCompanionConnection);
                if (FAILED(hr))
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(hr, "Failed to parse elevated connection.");
                    hr = S_OK;
                }

                i += 2;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_CLEAN_ROOM), BURN_COMMANDLINE_SWITCH_CLEAN_ROOM, lstrlenW(BURN_COMMANDLINE_SWITCH_CLEAN_ROOM)))
            {
                if (0 != i)
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Clean room command-line switch must be first argument on command-line.");
                }

                if (BURN_MODE_UNKNOWN == pInternalCommand->mode)
                {
                    pInternalCommand->mode = BURN_MODE_NORMAL;
                }
                else
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Multiple mode command-line switches were provided.");
                }

                // Get a pointer to the next character after the switch.
                LPCWSTR wzParam = &argv[i][1 + lstrlenW(BURN_COMMANDLINE_SWITCH_CLEAN_ROOM)];
                if (L'\0' != wzParam[0])
                {
                    if (L'=' != wzParam[0])
                    {
                        fInvalidCommandLine = TRUE;
                        TraceLog(E_INVALIDARG, "Invalid switch: %ls", argv[i]);
                    }
                    else if (L'\0' != wzParam[1])
                    {
                        hr = PathExpand(&pInternalCommand->sczSourceProcessPath, wzParam + 1, PATH_EXPAND_FULLPATH);
                        ExitOnFailure(hr, "Failed to copy source process path.");
                    }
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_SYSTEM_COMPONENT), BURN_COMMANDLINE_SWITCH_SYSTEM_COMPONENT, lstrlenW(BURN_COMMANDLINE_SWITCH_SYSTEM_COMPONENT)))
            {
                // Get a pointer to the next character after the switch.
                LPCWSTR wzParam = &argv[i][1 + lstrlenW(BURN_COMMANDLINE_SWITCH_SYSTEM_COMPONENT)];

                // Switch without an argument is allowed. An empty string means FALSE, everything else means TRUE.
                if (L'\0' != wzParam[0])
                {
                    if (L'=' != wzParam[0])
                    {
                        fInvalidCommandLine = TRUE;
                        TraceLog(E_INVALIDARG, "Invalid switch: %ls", argv[i]);
                    }
                    else
                    {
                        pInternalCommand->fArpSystemComponent = L'\0' != wzParam[1];
                    }
                }
                else
                {
                    pInternalCommand->fArpSystemComponent = TRUE;
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_EMBEDDED, -1))
            {
                if (i + 3 >= argc)
                {
                    fInvalidCommandLine = TRUE;
                    ExitWithRootFailure(hr, E_INVALIDARG, "Must specify the embedded name, token and parent process id.");
                }

                switch (pInternalCommand->mode)
                {
                case BURN_MODE_UNKNOWN:
                    // Set mode to UNTRUSTED to ensure multiple modes weren't specified.
                    pInternalCommand->mode = BURN_MODE_UNTRUSTED;
                    break;
                case BURN_MODE_NORMAL:
                    // The initialization code already assumes that the
                    // clean room switch is at the beginning of the command line,
                    // so it's safe to assume that the mode is NORMAL in the clean room.
                    pInternalCommand->mode = BURN_MODE_EMBEDDED;
                    break;
                default:
                    fInvalidCommandLine = TRUE;
                    ExitWithRootFailure(hr, E_INVALIDARG, "Multiple mode command-line switches were provided.");
                }

                ++i;

                hr = ParsePipeConnection(argv + i, pEmbeddedConnection);
                if (FAILED(hr))
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(hr, "Failed to parse embedded connection.");
                    hr = S_OK;
                }

                i += 2;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_DETECT, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_DETECT;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_UPGRADE, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_UPGRADE;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_ADDON, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_ADDON;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_DEPENDENT_ADDON, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_DEPENDENT_ADDON;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_PATCH, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_PATCH;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_DEPENDENT_PATCH, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_DEPENDENT_PATCH;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_UPDATE, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_UPDATE;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RELATED_CHAIN_PACKAGE, -1))
            {
                pCommand->relationType = BOOTSTRAPPER_RELATION_CHAIN_PACKAGE;

                LogId(REPORT_STANDARD, MSG_BURN_RUN_BY_RELATED_BUNDLE, LoggingRelationTypeToString(pCommand->relationType));
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_PASSTHROUGH, -1))
            {
                pCommand->fPassthrough = TRUE;
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], -1, BURN_COMMANDLINE_SWITCH_RUNONCE, -1))
            {
                switch (pInternalCommand->mode)
                {
                case BURN_MODE_UNKNOWN: __fallthrough;
                case BURN_MODE_NORMAL:
                    pInternalCommand->mode = BURN_MODE_RUNONCE;
                    break;
                default:
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Multiple mode command-line switches were provided.");
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_IGNOREDEPENDENCIES), BURN_COMMANDLINE_SWITCH_IGNOREDEPENDENCIES, lstrlenW(BURN_COMMANDLINE_SWITCH_IGNOREDEPENDENCIES)))
            {
                // Get a pointer to the next character after the switch.
                LPCWSTR wzParam = &argv[i][1 + lstrlenW(BURN_COMMANDLINE_SWITCH_IGNOREDEPENDENCIES)];
                if (L'=' != wzParam[0] || L'\0' == wzParam[1])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Missing required parameter for switch: %ls", BURN_COMMANDLINE_SWITCH_IGNOREDEPENDENCIES);
                }
                else
                {
                    hr = StrAllocString(&pInternalCommand->sczIgnoreDependencies, &wzParam[1], 0);
                    ExitOnFailure(hr, "Failed to allocate the list of dependencies to ignore.");
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_ANCESTORS), BURN_COMMANDLINE_SWITCH_ANCESTORS, lstrlenW(BURN_COMMANDLINE_SWITCH_ANCESTORS)))
            {
                // Get a pointer to the next character after the switch.
                LPCWSTR wzParam = &argv[i][1 + lstrlenW(BURN_COMMANDLINE_SWITCH_ANCESTORS)];
                if (L'=' != wzParam[0] || L'\0' == wzParam[1])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(hr = E_INVALIDARG, "Missing required parameter for switch: %ls", BURN_COMMANDLINE_SWITCH_ANCESTORS);
                }
                else
                {
                    hr = StrAllocString(&pInternalCommand->sczAncestors, &wzParam[1], 0);
                    ExitOnFailure(hr, "Failed to allocate the list of ancestors.");
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_WORKING_DIRECTORY), BURN_COMMANDLINE_SWITCH_WORKING_DIRECTORY, lstrlenW(BURN_COMMANDLINE_SWITCH_WORKING_DIRECTORY)))
            {
                // Get a pointer to the next character after the switch.
                LPCWSTR wzParam = &argv[i][1 + lstrlenW(BURN_COMMANDLINE_SWITCH_WORKING_DIRECTORY)];
                if (L'=' != wzParam[0])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Invalid switch: %ls", argv[i]);
                }
                else
                {
                    hr = PathExpand(&pInternalCommand->sczEngineWorkingDirectory, wzParam + 1, PATH_EXPAND_FULLPATH);
                    ExitOnFailure(hr, "Failed to store the custom working directory.");
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_FILEHANDLE_ATTACHED), BURN_COMMANDLINE_SWITCH_FILEHANDLE_ATTACHED, lstrlenW(BURN_COMMANDLINE_SWITCH_FILEHANDLE_ATTACHED)))
            {
                LPCWSTR wzParam = &argv[i][2 + lstrlenW(BURN_COMMANDLINE_SWITCH_FILEHANDLE_ATTACHED)];
                if (L'=' != wzParam[-1] || L'\0' == wzParam[0])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Missing required parameter for switch: %ls", BURN_COMMANDLINE_SWITCH_FILEHANDLE_ATTACHED);
                }
                else
                {
                    hr = StrStringToUInt64(wzParam, 0, &qw);
                    if (FAILED(hr))
                    {
                        TraceLog(hr, "Failed to parse file handle: '%ls'", wzParam);
                        hr = S_OK;
                    }
                    else
                    {
                        *phSourceEngineFile = (HANDLE)qw;
                    }
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_FILEHANDLE_SELF), BURN_COMMANDLINE_SWITCH_FILEHANDLE_SELF, lstrlenW(BURN_COMMANDLINE_SWITCH_FILEHANDLE_SELF)))
            {
                LPCWSTR wzParam = &argv[i][2 + lstrlenW(BURN_COMMANDLINE_SWITCH_FILEHANDLE_SELF)];
                if (L'=' != wzParam[-1] || L'\0' == wzParam[0])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Missing required parameter for switch: %ls", BURN_COMMANDLINE_SWITCH_FILEHANDLE_SELF);
                }
                else
                {
                    hr = StrStringToUInt64(wzParam, 0, &qw);
                    if (FAILED(hr))
                    {
                        TraceLog(hr, "Failed to parse file handle: '%ls'", wzParam);
                        hr = S_OK;
                    }
                    else
                    {
                        *phSectionFile = (HANDLE)qw;
                    }
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_SPLASH_SCREEN), BURN_COMMANDLINE_SWITCH_SPLASH_SCREEN, lstrlenW(BURN_COMMANDLINE_SWITCH_SPLASH_SCREEN)))
            {
                LPCWSTR wzParam = &argv[i][2 + lstrlenW(BURN_COMMANDLINE_SWITCH_SPLASH_SCREEN)];
                if (L'=' != wzParam[-1] || L'\0' == wzParam[0])
                {
                    fInvalidCommandLine = TRUE;
                    TraceLog(E_INVALIDARG, "Missing required parameter for switch: %ls", BURN_COMMANDLINE_SWITCH_SPLASH_SCREEN);
                }
                else
                {
                    hr = StrStringToUInt64(wzParam, 0, &qw);
                    if (FAILED(hr))
                    {
                        TraceLog(hr, "Failed to parse splash screen window: '%ls'", wzParam);
                        hr = S_OK;
                    }
                    else
                    {
                        pCommand->hwndSplashScreen = (HWND)qw;
                    }
                }
            }
            else if (CSTR_EQUAL == ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &argv[i][1], lstrlenW(BURN_COMMANDLINE_SWITCH_PREFIX), BURN_COMMANDLINE_SWITCH_PREFIX, lstrlenW(BURN_COMMANDLINE_SWITCH_PREFIX)))
            {
                // Skip (but log) any other private burn switches we don't recognize, so that
                // adding future private variables doesn't break old bundles
                LogId(REPORT_STANDARD, MSG_BURN_UNKNOWN_PRIVATE_SWITCH, &argv[i][1]);
            }
            else
            {
                fUnknownArg = TRUE;
            }
        }
        else
        {
            fUnknownArg = TRUE;
        }

        if (fUnknownArg)
        {
            hr = MemEnsureArraySizeForNewItems(reinterpret_cast<LPVOID*>(&pInternalCommand->rgUnknownArgs), pInternalCommand->cUnknownArgs, 1, sizeof(int), 5);
            ExitOnFailure(hr, "Failed to ensure size for unknown args.");

            pInternalCommand->rgUnknownArgs[pInternalCommand->cUnknownArgs] = i;
            pInternalCommand->cUnknownArgs += 1;
        }
    }

    if (BURN_MODE_EMBEDDED == pInternalCommand->mode)
    {
        // Ensure the display goes embedded as well.
        pCommand->display = BOOTSTRAPPER_DISPLAY_EMBEDDED;

        // Disable system restore since the parent bundle may have done it.
        pInternalCommand->fDisableSystemRestore = TRUE;
    }

    // Set the defaults if nothing was set above.
    if (BOOTSTRAPPER_ACTION_UNKNOWN == pCommand->action)
    {
        pCommand->action = BOOTSTRAPPER_ACTION_INSTALL;
    }

    if (BOOTSTRAPPER_DISPLAY_UNKNOWN == pCommand->display)
    {
        pCommand->display = BOOTSTRAPPER_DISPLAY_FULL;
    }

    if (BURN_MODE_UNKNOWN == pInternalCommand->mode)
    {
        pInternalCommand->mode = BURN_MODE_UNTRUSTED;
    }

LExit:
    if (fInvalidCommandLine)
    {
        hr = S_OK;
        pInternalCommand->fInvalidCommandLine = TRUE;
    }

    return hr;
}
