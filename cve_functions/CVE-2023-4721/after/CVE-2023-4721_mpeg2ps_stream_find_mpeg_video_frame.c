mpeg2ps_stream_find_mpeg_video_frame (mpeg2ps_stream_t *sptr)
{
	u32 offset, scode;
	Bool have_pict;
	Bool started_new_pes = 0;
	u32 start;
	/*
	 * First thing - determine if we have enough bytes to read the header.
	 * if we do, we have the correct timestamp.  If not, we read the new
	 * pes, so we'd want to use the timestamp we read.
	 */
	sptr->frame_ts = sptr->next_pes_ts;
	if (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {
		if (sptr->pes_buffer_size != sptr->pes_buffer_on)
			started_new_pes = 1;
		if (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {
			return 0;
		}
	}
	while (gf_mv12_next_start_code(sptr->pes_buffer + sptr->pes_buffer_on,
	                               sptr->pes_buffer_size - sptr->pes_buffer_on,
	                               &offset,
	                               &scode) < 0 ||
	        (!IS_MPEG_START(scode & 0xff))) {
		if (sptr->pes_buffer_size > 3)
			sptr->pes_buffer_on = sptr->pes_buffer_size - 3;
		else {
			sptr->pes_buffer_on = sptr->pes_buffer_size;
			started_new_pes = 1;
		}
		if (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {
			return 0;
		}
	}
	sptr->pes_buffer_on += offset;
	if (offset == 0 && started_new_pes) {
		// nothing...  we've copied the timestamp already.
	} else {
		// we found the new start, but we pulled in a new pes header before
		// starting.  So, we want to use the header that we read.
		sptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching
		// clear timestamp indication
		sptr->next_pes_ts.have_pts = sptr->next_pes_ts.have_dts = 0;
	}

	if (scode == MPEG12_PICTURE_START_CODE) {
		sptr->pict_header_offset = sptr->pes_buffer_on;
		have_pict = 1;
	} else have_pict = 0;

	start = 4 + sptr->pes_buffer_on;
	while (1) {

		if (gf_mv12_next_start_code(sptr->pes_buffer + start,
		                            sptr->pes_buffer_size - start,
		                            &offset,
		                            &scode) < 0) {
			start = sptr->pes_buffer_size - 3;
			start -= sptr->pes_buffer_on;
			sptr->pict_header_offset -= sptr->pes_buffer_on;
			if (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {
				return 0;
			}
			start += sptr->pes_buffer_on;
			sptr->pict_header_offset += sptr->pes_buffer_on;
		} else {
			start += offset;
			if (have_pict == 0) {
				if (scode == MPEG12_PICTURE_START_CODE) {
					have_pict = 1;
					sptr->pict_header_offset = start;
				}
			} else {
				if (IS_MPEG_START(scode & 0xff) ||
				        scode == MPEG12_SEQUENCE_END_START_CODE) {
					sptr->frame_len = start - sptr->pes_buffer_on;
					sptr->have_frame_loaded = 1;
					return 1;
				}
			}
			start += 4;
		}
	}
	return 0;
}
