bool fastly_compute_at_edge_http_req_header_names_get(
    fastly_compute_at_edge_http_types_request_handle_t h, fastly_world_list_string_t *ret,
    fastly_compute_at_edge_types_error_t *err) {
  std::vector<Chunk> header_names;
  {
    JS::UniqueChars buf{static_cast<char *>(cabi_malloc(HOSTCALL_BUFFER_LEN, 1))};
    uint32_t cursor = 0;
    while (true) {
      size_t length = 0;
      int64_t ending_cursor = 0;
      auto res = fastly::req_header_names_get(h, reinterpret_cast<uint8_t *>(buf.get()),
                                              HEADER_MAX_LEN, cursor, &ending_cursor, &length);
      if (!convert_result(res, err)) {
        return false;
      }

      if (length == 0) {
        break;
      }

      std::string_view result{buf.get(), length};
      while (!result.empty()) {
        auto end = result.find('\0');
        header_names.emplace_back(Chunk::make(result.substr(0, end)));
        if (end == result.npos) {
          break;
        }

        result = result.substr(end + 1);
      }

      if (ending_cursor < 0) {
        break;
      }

      cursor = ending_cursor;
    }
  }

  ret->len = header_names.size();
  ret->ptr = static_cast<fastly_world_string_t *>(cabi_malloc(
      header_names.size() * sizeof(fastly_world_string_t), alignof(fastly_world_string_t)));
  auto *next = ret->ptr;
  for (auto &chunk : header_names) {
    next->len = chunk.length;
    next->ptr = reinterpret_cast<uint8_t *>(chunk.buffer.release());
    ++next;
  }

  return true;
}
