txSlot* fxGetBufferInfo(txMachine* the, txSlot* buffer)
{
	txSlot* arrayBuffer = buffer->value.reference->next;
	txSlot* bufferInfo = arrayBuffer->next;
	if (arrayBuffer->kind == XS_ARRAY_BUFFER_KIND) {
		if (arrayBuffer->value.arrayBuffer.address == C_NULL)
			mxTypeError("detached buffer");
		return bufferInfo;
	}
	if (arrayBuffer->kind == XS_HOST_KIND) {
		txInteger byteLength;
		if (bufferInfo && (bufferInfo->kind == XS_BUFFER_INFO_KIND))
			return bufferInfo;
		mxPushSlot(buffer);
		mxGetID(mxID(_byteLength));
		if (!fxCheckLength(the, the->stack, &byteLength))
			mxTypeError("invalid byteLength");
		fxReport(the, "# Use xsSetHostBuffer instead of xsSetHostData\n");
		mxPop();
		bufferInfo = fxNewSlot(the);
		bufferInfo->next = arrayBuffer->next;
		bufferInfo->flag = XS_INTERNAL_FLAG;
		bufferInfo->kind = XS_BUFFER_INFO_KIND;
		bufferInfo->value.bufferInfo.length = byteLength;
		bufferInfo->value.bufferInfo.maxLength = -1;
		arrayBuffer->next = bufferInfo;
		return bufferInfo;
	}
	mxTypeError("invalid buffer");
	return C_NULL;
}
