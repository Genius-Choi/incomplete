void fx_ArrayBuffer_prototype_resize(txMachine* the)
{
	/* txSlot* instance = */ fxCheckArrayBufferInstance(the, mxThis);
	txSlot* arrayBuffer = fxCheckArrayBufferDetached(the, mxThis, XS_MUTABLE);
	txSlot* bufferInfo = arrayBuffer->next;
	txInteger maxByteLength, oldByteLength, newByteLength;
	txByte* chunk;
	maxByteLength = bufferInfo->value.bufferInfo.maxLength;
	if (maxByteLength < 0)
		mxTypeError("not resizable");
	oldByteLength = bufferInfo->value.bufferInfo.length;
	newByteLength = fxArgToByteLength(the, 0, 0);
	if (newByteLength > maxByteLength)
		mxRangeError("newLength > maxByteLength");
	chunk = (txByte*)fxRenewChunk(the, arrayBuffer->value.arrayBuffer.address, newByteLength);
	if (!chunk) {
		chunk = (txByte*)fxNewChunk(the, newByteLength);
		c_memcpy(chunk, arrayBuffer->value.arrayBuffer.address, (newByteLength < oldByteLength) ? newByteLength : oldByteLength);
	}
	if (newByteLength > oldByteLength)
		c_memset(chunk + oldByteLength, 0, newByteLength - oldByteLength);
	arrayBuffer->value.arrayBuffer.address = chunk;
	bufferInfo->value.bufferInfo.length = newByteLength;
}
