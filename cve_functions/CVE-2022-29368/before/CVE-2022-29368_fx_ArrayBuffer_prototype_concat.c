void fx_ArrayBuffer_prototype_concat(txMachine* the)
{
	txSlot* instance = fxCheckArrayBufferInstance(the, mxThis);
	txSlot* arrayBuffer = instance->next;
	txSlot* bufferInfo = arrayBuffer->next;
	txInteger length = bufferInfo->value.bufferInfo.length;
	txInteger c = mxArgc, i = 0;
	txByte* address;
	txSlot* slot;
	while (i < c) {
		arrayBuffer = C_NULL;
		bufferInfo = C_NULL;
		slot = mxArgv(i);
		if (slot->kind == XS_REFERENCE_KIND) {
			slot = slot->value.reference->next;
			if (slot && (slot->kind == XS_ARRAY_BUFFER_KIND)) {
				arrayBuffer = slot;
				bufferInfo = slot->next;
			}
		}
		if (arrayBuffer) 
			length = fxAddChunkSizes(the, length, bufferInfo->value.bufferInfo.length);
		else
			mxTypeError("arguments[%ld] is no ArrayBuffer instance", i);
		i++;
	}
	fxConstructArrayBufferResult(the, C_NULL, length);
	arrayBuffer = instance->next;
	bufferInfo = arrayBuffer->next;
	address = mxResult->value.reference->next->value.arrayBuffer.address;
	length = bufferInfo->value.bufferInfo.length;
	c_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);
	address += length;
	i = 0;
	while (i < c) {
		arrayBuffer = mxArgv(i)->value.reference->next;
		bufferInfo = arrayBuffer->next;
		length = bufferInfo->value.bufferInfo.length;
		c_memcpy(address, arrayBuffer->value.arrayBuffer.address, length);
		address += length;
		i++;
	}
}
