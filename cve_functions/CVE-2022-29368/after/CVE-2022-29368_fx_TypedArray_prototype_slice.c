void fx_TypedArray_prototype_slice(txMachine* the)
{
	mxTypedArrayDeclarations;
	txInteger delta = dispatch->value.typedArray.dispatch->size;
	txInteger start = (txInteger)fxArgToIndex(the, 0, 0, length);
	txInteger end = (txInteger)fxArgToIndex(the, 1, length, length);
	txInteger count = (end > start) ? end - start : 0;
	txInteger index = 0;
	fxCreateTypedArraySpecies(the);
	mxPushNumber(count);
	mxRunCount(1);
	mxPullSlot(mxResult);
	{
		mxResultTypedArrayDeclarations;
		if (resultLength < count)
			mxTypeError("insufficient buffer");
		if (count) {
			length = fxCheckDataViewSize(the, view, buffer, XS_IMMUTABLE);
			mxPushUndefined();
			while ((start < length) && (start < end)) {
				(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, view->value.dataView.offset + (start * delta), the->stack, EndianNative);
				(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);
				(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << resultDispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);
				start++;
				index++;
			}
			while (start < end) {
				the->stack->kind = XS_UNDEFINED_KIND;
				(*resultDispatch->value.typedArray.dispatch->coerce)(the, the->stack);
				(*resultDispatch->value.typedArray.dispatch->setter)(the, resultBuffer->value.reference->next, resultView->value.dataView.offset + (index << resultDispatch->value.typedArray.dispatch->shift), the->stack, EndianNative);
				start++;
				index++;
			}
			mxPop();
		}
	}
}
