void fx_TypedArray_from_object(txMachine* the, txSlot* instance, txSlot* function, txSlot* _this)
{
	txSlot* stack = the->stack;
	txSlot* iterator;
	txSlot* next;
	txSlot* value;
	txSlot* list = C_NULL;
	txSlot* slot;
	txSlot* dispatch;
	txSlot* view;
	txSlot* buffer;
	txSlot* data;
	txU2 shift;
	txNumber length;
	mxTemporary(iterator);
	mxTemporary(next);
	if (fxGetIterator(the, mxArgv(0), iterator, next, 1)) {
		list = fxNewInstance(the);
		slot = list;
		length = 0;
		mxTemporary(value);
		while (fxIteratorNext(the, iterator, next, value)) {
			slot = fxNextSlotProperty(the, slot, value, XS_NO_ID, XS_NO_FLAG);
			length++;
		}
	}
	else {
		mxPushSlot(mxArgv(0));
		mxGetID(mxID(_length));
		length = fxToLength(the, the->stack);
		mxPop();
	}
	if (instance) {
		dispatch = instance->next;
		view = dispatch->next;
		buffer = view->next;
		shift = dispatch->value.typedArray.dispatch->shift;
		mxPush(mxArrayBufferConstructor);
		mxNew();
		mxPushNumber(length * dispatch->value.typedArray.dispatch->size);
		mxRunCount(1);
		mxPullSlot(buffer);
		data = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);
		view->value.dataView.offset = 0;
		view->value.dataView.size = data->next->value.bufferInfo.length;
	}
	else {
		mxPushSlot(mxThis);
		mxNew();
		mxPushNumber(length);
		mxRunCount(1);
		mxPullSlot(mxResult);
		instance = fxToInstance(the, mxResult);
		if (((slot = instance->next)) && (slot->flag & XS_INTERNAL_FLAG) && (slot->kind == XS_TYPED_ARRAY_KIND)) {
			dispatch = instance->next;
			view = dispatch->next;
			buffer = view->next;
			data = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);
			shift = dispatch->value.typedArray.dispatch->shift;
			if (view->value.dataView.size < (length * dispatch->value.typedArray.dispatch->size))
				mxTypeError("too small TypedArray");
		}
		else
			mxTypeError("no TypedArray");
	}
	if (list) {
		txInteger index = 0;
		slot = list->next;
		while (slot) {
			/* ARG0 */
			if (function) {
				/* THIS */
				if (_this)
					mxPushSlot(_this);
				else
					mxPushUndefined();
				/* FUNCTION */
				mxPushSlot(function);
				mxCall();
				/* ARGUMENTS */
				mxPushSlot(slot);
				mxPushInteger(index);
				mxRunCount(2);
			}
			else
				mxPushSlot(slot);
			(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);
			(*dispatch->value.typedArray.dispatch->setter)(the, data, (index << shift), the->stack, EndianNative);
			mxPop();
			index++;
			slot = slot->next;
		}
	}
	else {
		txInteger index = 0;
		txInteger count = (txInteger)length;
		while (index < count) {
			if (function) {
				/* THIS */
				if (_this)
					mxPushSlot(_this);
				else
					mxPushUndefined();
				/* FUNCTION */
				mxPushSlot(function);
				mxCall();
				/* ARGUMENTS */
				mxPushSlot(mxArgv(0));
				mxGetIndex(index);
				mxPushInteger(index);
				mxRunCount(2);
			}
			else {
				mxPushSlot(mxArgv(0));
				mxGetIndex(index);
			}
			(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);
			(*dispatch->value.typedArray.dispatch->setter)(the, data, (index << shift), the->stack, EndianNative);
			mxPop();
			index++;
		}	
	}
	the->stack = stack;
}
