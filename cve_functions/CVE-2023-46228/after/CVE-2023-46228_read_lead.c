static bool read_lead(zckCtx *zck) {
    VALIDATE_READ_BOOL(zck);

    int lead = 5 + 2*MAX_COMP_SIZE;

    char *header = zmalloc(lead);
    if (!header) {
	    zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
	    return false;
    }
    size_t length = 0;

    if(read_data(zck, header, lead) < lead) {
        free(header);
        set_error(zck, "Short read");
        return false;
    }

    if(memcmp(header, "\0ZHR1", 5) == 0) {
        zck->header_only = true;
    } else if(memcmp(header, "\0ZCK1", 5) != 0) {
        free(header);
        set_error(zck, "Invalid lead, perhaps this is not a zck file?");
        return false;
    }
    length += 5;

    /* Read hash type for header and full digest and initialize check hash */
    int hash_type = 0;
    if(!compint_to_int(zck, &hash_type, header+length, &length, lead)) {
        free(header);
        return false;
    }
    if(zck->prep_hash_type > -1 && zck->prep_hash_type != hash_type) {
        free(header);
        set_error(zck, "Hash type (%i) doesn't match requested hash type "
                  "(%i)", hash_type, zck->prep_hash_type);
        return false;
    }
    if(!hash_setup(zck, &(zck->hash_type), hash_type)) {
        free(header);
        return false;
    }
    zck_log(ZCK_LOG_DEBUG, "Setting header and full digest hash type to %s",
            zck_hash_name_from_type(hash_type));

    /* Read header size */
    size_t header_length = 0;
    if(!compint_to_size(zck, &header_length, header+length, &length, lead)) {
        free(header);
        hash_reset(&(zck->hash_type));
        return false;
    }
    if(header_length > SIZE_MAX) {
        free(header);
        set_error(zck, "Header length of %li invalid", header_length);
        hash_reset(&(zck->hash_type));
        return false;
    }
    zck->header_length = header_length;

    /* Set header digest location */
    zck->hdr_digest_loc = length;

    /* Verify that we're not going to overflow */
    if(length > length + zck->hash_type.digest_size) {
        zck_log(ZCK_LOG_ERROR, "Integer overflow when reading lead");
        return false;
    }

    /* Read header digest */
    zck_log(ZCK_LOG_DEBUG, "Reading header digest");
    header = zrealloc(header, length + zck->hash_type.digest_size);
    if (!header) {
        zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
        return false;
    }
    size_t to_read = 0;
    if(lead < length + zck->hash_type.digest_size)
        to_read = length + zck->hash_type.digest_size - lead;
    if(read_data(zck, header + lead, to_read) < to_read) {
        free(header);
        zck->header_length = 0;
        zck->hdr_digest_loc = 0;
        hash_reset(&(zck->hash_type));
        return false;
    }
    lead += to_read;

    if(zck->prep_digest &&
       memcmp(zck->prep_digest, header + length, zck->hash_type.digest_size) != 0) {
        zck->header_length = 0;
        zck->hdr_digest_loc = 0;
        hash_reset(&(zck->hash_type));
        set_error(zck,
                  "Header digest doesn't match requested header digest"
                  "Expected: %sActual: %s",
                  get_digest_string(zck->prep_digest,
                                    zck->hash_type.digest_size),
                  get_digest_string(header + length,
                                    zck->hash_type.digest_size));
        free(header);
        return false;
    }
    zck->header_digest = zmalloc(zck->hash_type.digest_size);
    if (!zck->header_digest) {
	    zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
	    free(header);
	    return false;
    }
    memcpy(zck->header_digest, header + length, zck->hash_type.digest_size);
    length += zck->hash_type.digest_size;

    /* Check whether full header length matches specified header length */
    if(zck->prep_hdr_size > -1 &&
       (size_t)zck->prep_hdr_size != zck->header_length + length) {
        free(header);
        zck->header_length = 0;
        zck->hdr_digest_loc = 0;
        hash_reset(&(zck->hash_type));
        free(zck->header_digest);
        zck->header_digest = NULL;
        set_error(
            zck,
            "Header length (%llu) doesn't match requested header length (%llu)",
            (long long unsigned) zck->header_length + length,
            (long long unsigned) zck->prep_hdr_size
        );
        return false;
    }
    /* Store pre-header */
    zck->header = header;
    zck->header_size = lead;
    zck->lead_string = header;
    zck->lead_size = length;
    zck_log(
        ZCK_LOG_DEBUG,
        "Parsed lead: %llu bytes",
        (long long unsigned) length
    );
    return true;
}
