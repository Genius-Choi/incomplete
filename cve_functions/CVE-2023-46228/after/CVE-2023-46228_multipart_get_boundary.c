size_t multipart_get_boundary(zckDL *dl, char *b, size_t size) {
    ALLOCD_BOOL(NULL, dl);
    VALIDATE_BOOL(dl->zck);

    /* Create regex to find boundary */
    if(dl->hdr_regex == NULL) {
        char *regex = "boundary *= *(.*?) *\r";
        dl->hdr_regex = zmalloc(sizeof(regex_t));
        if(!dl->hdr_regex || !create_regex(dl->zck, dl->hdr_regex, regex))
            return 0;
    }

    /* Copy buffer to null-terminated string because POSIX regex requires null-
     * terminated string */
    char *buf = zmalloc(size+1);
    if (!buf) {
        zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
        return 0;
    }
    buf[size] = '\0';
    memcpy(buf, b, size);

    /* Check whether this header contains the boundary and set it if it does */
    regmatch_t match[2] = {{0}};
    if(regexec(dl->hdr_regex, buf, 2, match, 0) == 0) {
        reset_mp(dl->mp);
        size_t boundary_length = match[1].rm_eo - match[1].rm_so;
        char *boundary_start = buf + match[1].rm_so;
        if (boundary_start[0] == '\"' && boundary_length > 2
            && boundary_start[boundary_length-1] == '\"') {
            /* Remove optional quotes */
            boundary_start  += 1;
            boundary_length -= 2;
        }
        char *boundary = zmalloc(boundary_length + 1);
        if (!boundary) {
            zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
            free(buf);
            return 0;
        }
        memcpy(boundary, boundary_start, boundary_length);
        zck_log(ZCK_LOG_DEBUG, "Multipart boundary: %s", boundary);
        dl->boundary = boundary;
    }
    free(buf);
    return size;
}
