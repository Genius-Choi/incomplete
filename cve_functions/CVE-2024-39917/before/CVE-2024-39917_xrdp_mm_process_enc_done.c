xrdp_mm_process_enc_done(struct xrdp_mm *self)
{
    XRDP_ENC_DATA *enc;
    XRDP_ENC_DATA_DONE *enc_done;
    int x;
    int y;
    int cx;
    int cy;
    int is_gfx;
    int got_frame_id;
    int client_ack;

    LOG(LOG_LEVEL_TRACE, "xrdp_mm_process_enc_done:");

    while (1)
    {
        tc_mutex_lock(self->encoder->mutex);
        enc_done = (XRDP_ENC_DATA_DONE *)
                   fifo_remove_item(self->encoder->fifo_processed);
        tc_mutex_unlock(self->encoder->mutex);
        if (enc_done == NULL)
        {
            break;
        }
        is_gfx = ENC_IS_BIT_SET(enc_done->flags, ENC_DONE_FLAGS_GFX_BIT);
        if (is_gfx)
        {
            got_frame_id = ENC_IS_BIT_SET(enc_done->flags,
                                          ENC_DONE_FLAGS_FRAME_ID_BIT);
            client_ack = self->encoder->gfx_ack_off == 0;
        }
        else
        {
            got_frame_id = 1;
            client_ack = self->wm->client_info->use_frame_acks;
        }
        LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_mm_process_enc_done: message back "
                  "bytes %d", enc_done->comp_bytes);
        if (enc_done->comp_bytes > 0)
        {
            if (is_gfx)
            {
                xrdp_egfx_send_data(self->egfx,
                                    enc_done->comp_pad_data +
                                    enc_done->pad_bytes,
                                    enc_done->comp_bytes);
            }
            else
            {
                x = enc_done->x;
                y = enc_done->y;
                cx = enc_done->cx;
                cy = enc_done->cy;
                if (client_ack && !enc_done->continuation)
                {
                    libxrdp_fastpath_send_frame_marker(self->wm->session, 0,
                                                       enc_done->frame_id);
                }
                libxrdp_fastpath_send_surface(self->wm->session,
                                              enc_done->comp_pad_data,
                                              enc_done->pad_bytes,
                                              enc_done->comp_bytes,
                                              x, y, x + cx, y + cy,
                                              32, self->encoder->codec_id,
                                              cx, cy);
                if (client_ack && enc_done->last)
                {
                    libxrdp_fastpath_send_frame_marker(self->wm->session, 1,
                                                       enc_done->frame_id);
                }
            }
        }
        /* free enc_done */
        if (enc_done->last)
        {
            enc = enc_done->enc;
            LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_mm_process_enc_done: last set");
            if (got_frame_id)
            {
                if (client_ack)
                {
                    self->encoder->frame_id_server = enc_done->frame_id;
                    xrdp_mm_update_module_frame_ack(self);
                }
                else
                {
                    self->mod->mod_frame_ack(self->mod, 0,
                                             enc_done->frame_id);
                }
            }
            if (is_gfx)
            {
                g_free(enc->u.gfx.cmd);
            }
            else
            {
                g_free(enc->u.sc.drects);
                g_free(enc->u.sc.crects);
            }
            if (enc->shmem_ptr != NULL)
            {
                g_munmap(enc->shmem_ptr, enc->shmem_bytes);
            }
            g_free(enc);
        }
        g_free(enc_done->comp_pad_data);
        g_free(enc_done);
    }
    return 0;
}
