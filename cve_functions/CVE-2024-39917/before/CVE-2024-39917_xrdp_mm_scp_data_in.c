xrdp_mm_scp_data_in(struct trans *trans)
{
    int rv = 0;
    int available;

    rv = scp_msg_in_check_available(trans, &available);
    if (rv == 0 && available)
    {
        struct xrdp_mm *self = (struct xrdp_mm *)(trans->callback_data);
        enum scp_msg_code msgno;

        switch ((msgno = scp_msg_in_get_msgno(trans)))
        {
            case E_SCP_LOGIN_RESPONSE:
                rv = xrdp_mm_process_login_response(self);
                break;

            case E_SCP_CREATE_SESSION_RESPONSE:
                rv = xrdp_mm_process_create_session_response(self);
                break;

            default:
            {
                char buff[64];
                scp_msgno_to_str(msgno, buff, sizeof(buff));
                LOG(LOG_LEVEL_ERROR, "Ignored SCP message %s from sesman",
                    buff);
            }
        }

        scp_msg_in_reset(trans);
    }

    return rv;
}
