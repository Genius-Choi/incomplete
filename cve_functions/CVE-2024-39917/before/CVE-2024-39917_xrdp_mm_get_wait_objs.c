xrdp_mm_get_wait_objs(struct xrdp_mm *self,
                      tbus *read_objs, int *rcount,
                      tbus *write_objs, int *wcount, int *timeout)
{
    int rv = 0;

    if (self == 0)
    {
        return 0;
    }

    rv = 0;

    if (self->sesman_trans != 0 &&
            self->sesman_trans->status == TRANS_STATUS_UP)
    {
        trans_get_wait_objs(self->sesman_trans, read_objs, rcount);
    }

    if ((self->chan_trans != 0) && self->chan_trans->status == TRANS_STATUS_UP)
    {
        trans_get_wait_objs_rw(self->chan_trans, read_objs, rcount,
                               write_objs, wcount, timeout);
    }

    if (self->mod != 0)
    {
        if (self->mod->mod_get_wait_objs != 0)
        {
            rv = self->mod->mod_get_wait_objs(self->mod, read_objs, rcount,
                                              write_objs, wcount, timeout);
        }
    }

    if (self->encoder != 0)
    {
        read_objs[(*rcount)++] = self->encoder->xrdp_encoder_event_processed;
    }

    if (self->resize_queue != 0)
    {
        read_objs[(*rcount)++] = self->resize_ready;
    }

    if (self->wm->screen_dirty_region != NULL)
    {
        if (xrdp_region_not_empty(self->wm->screen_dirty_region))
        {
            int now = g_time3();
            int next_screen_draw_time = self->wm->last_screen_draw_time +
                                        MIN_MS_BETWEEN_FRAMES;
            int diff = next_screen_draw_time - now;
            int ltimeout = *timeout;
            diff = MAX(diff, MIN_MS_TO_WAIT_FOR_MORE_UPDATES);
            diff = MIN(diff, MIN_MS_BETWEEN_FRAMES);
            LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_get_wait_objs:"
                      " not empty diff %d", diff);
            if ((ltimeout < 0) || (ltimeout > diff))
            {
                *timeout = diff;
            }
        }
    }
    return rv;
}
