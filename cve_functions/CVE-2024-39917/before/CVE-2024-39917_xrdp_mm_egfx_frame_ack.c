xrdp_mm_egfx_frame_ack(void *user, uint32_t queue_depth, int frame_id,
                       int frames_decoded)
{
    struct xrdp_mm *self;
    struct xrdp_encoder *encoder;

    LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_frame_ack:");
    self = (struct xrdp_mm *) user;
    encoder = self->encoder;
    if (encoder == NULL)
    {
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_frame_ack: encoder is nil");
        return 0;
    }
    if (queue_depth == XR_SUSPEND_FRAME_ACKNOWLEDGEMENT)
    {
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_frame_ack: "
            "queue_depth %d frame_id %d frames_decoded %d",
            queue_depth, frame_id, frames_decoded);
        if (encoder->gfx_ack_off == 0)
        {
            LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_frame_ack: "
                "client request turn off frame acks.");
            encoder->gfx_ack_off = 1;
            frame_id = -1;
        }
    }
    else
    {
        if (encoder->gfx_ack_off)
        {
            LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_frame_ack: "
                      "client request turn on frame acks");
            encoder->gfx_ack_off = 0;
        }
    }
    LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_frame_ack: "
              "incoming %d, client %d, server %d",
              frame_id, encoder->frame_id_client, encoder->frame_id_server);
    if (frame_id < 0 || frame_id > encoder->frame_id_server)
    {
        /* if frame_id is negative or bigger then what server last sent
           just ack all sent frames */
        /* some clients can send big number just to clear all
           pending frames */
        encoder->frame_id_client = encoder->frame_id_server;
    }
    else
    {
        /* frame acks can come out of order so ignore older one */
        encoder->frame_id_client = MAX(frame_id, encoder->frame_id_client);
    }
    xrdp_mm_update_module_frame_ack(self);
    return 0;
}
