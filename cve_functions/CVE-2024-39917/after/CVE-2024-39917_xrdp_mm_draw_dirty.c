xrdp_mm_draw_dirty(struct xrdp_mm *self)
{
    struct xrdp_rect rect;
    struct xrdp_rect mon_rect;
    struct xrdp_region *mon_reg;
    int error;
    int index;
    int jndex;
    int count;
    int surface_id;
    struct monitor_info *mi;
    int rv = 0;

    LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_draw_dirty:");
    count = self->wm->client_info->display_sizes.monitorCount;
    if (count < 1)
    {
        error = xrdp_region_get_bounds(self->wm->screen_dirty_region, &rect);
        if (error == 0)
        {
            rv = xrdp_mm_egfx_send_planar_bitmap(self,
                                                 self->wm->screen, &rect,
                                                 self->egfx->surface_id, 0, 0);
        }
    }
    else
    {
        for (index = 0; index < count; index++)
        {
            /* make a copy of screen_dirty_region */
            mon_reg = xrdp_region_create(self->wm);
            if (mon_reg == NULL)
            {
                return 1;
            }
            jndex = 0;
            while (xrdp_region_get_rect(self->wm->screen_dirty_region,
                                        jndex, &mon_rect) == 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO, "xrdp_mm_draw_dirty: jndex %d "
                          "mon_rect %d %d %d %d",
                          jndex, mon_rect.left, mon_rect.top,
                          mon_rect.right, mon_rect.bottom);
                xrdp_region_add_rect(mon_reg, &mon_rect);
                jndex++;
            }
            /* intercect monitor */
            mi = self->wm->client_info->display_sizes.minfo_wm + index;
            mon_rect.left = mi->left;
            mon_rect.top = mi->top;
            mon_rect.right = mi->right + 1;
            mon_rect.bottom = mi->bottom + 1;
            xrdp_region_intersect_rect(mon_reg, &mon_rect);
            if (xrdp_region_not_empty(mon_reg))
            {
                error = xrdp_region_get_bounds(mon_reg, &rect);
                if (error == 0)
                {
                    surface_id = index;
                    rv = xrdp_mm_egfx_send_planar_bitmap(self,
                                                         self->wm->screen,
                                                         &rect,
                                                         surface_id,
                                                         mi->left, mi->top);
                }
            }
            xrdp_region_delete(mon_reg);
        }
    }
    return rv;
}
