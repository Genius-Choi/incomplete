xrdp_mm_connect_sm(struct xrdp_mm *self)
{
    int status = 0;

    /* we set self->mmcs_expecting_msg in the loop when we've send a
       message to sesman, and we need to wait for a response */
    self->mmcs_expecting_msg = 0;

    while (status == 0 && !self->mmcs_expecting_msg &&
            self->connect_state != MMCS_DONE)
    {
        switch (self->connect_state)
        {
            case MMCS_CONNECT_TO_SESMAN:
            {
                if (self->sesman_trans == NULL &&
                        (self->use_sesman || self->use_gw_login))
                {
                    /* Synchronous call */
                    status = xrdp_mm_sesman_connect(self);
                }
            }
            break;

            case MMCS_GATEWAY_LOGIN:
            {
                if (self->use_gw_login)
                {
                    const char *gw_username;
                    const char *gw_password;

                    gw_username = xrdp_mm_get_value(self, "pamusername");
                    gw_password = xrdp_mm_get_value(self, "pampassword");
                    if (!g_strcmp(gw_username, "same"))
                    {
                        gw_username = xrdp_mm_get_value(self, "username");
                    }

                    if (gw_password == NULL ||
                            !g_strcmp(gw_password, "same"))
                    {
                        gw_password = xrdp_mm_get_value(self, "password");
                    }

                    if (gw_username == NULL || gw_password == NULL)
                    {
                        xrdp_wm_log_msg(self->wm, LOG_LEVEL_ERROR,
                                        "Can't determine username and/or "
                                        "password for gateway login");
                        status = 1;
                    }
                    else
                    {
                        xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO,
                                        "Performing access control for %s",
                                        gw_username);

                        status = xrdp_mm_send_sys_login_request(self,
                                                                gw_username,
                                                                gw_password);
                        if (status == 0)
                        {
                            /* Now waiting for a reply from sesman - see
                               xrdp_mm_process_login_response() */
                            self->mmcs_expecting_msg = 1;
                        }
                    }
                }
            }
            break;

            case MMCS_SESSION_LOGIN:
            {
                // Finished with the gateway login
                if (self->use_gw_login)
                {
                    xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO,
                                    "access control check was successful");
                    // No reply needed for this one
                    status = scp_send_logout_request(self->sesman_trans);
                    self->uid = -1;
                }

                if (status == 0 && self->use_sesman)
                {
                    const char *username;
                    const char *password;

                    username = xrdp_mm_get_value(self, "username");
                    password = xrdp_mm_get_value(self, "password");
                    if (username == NULL || username[0] == '\0')
                    {
                        xrdp_wm_log_msg(self->wm, LOG_LEVEL_ERROR,
                                        "No username is available");
                        status = 1;
                    }
                    else if (password == NULL)
                    {
                        /* Can't find a password definition at all - even
                         * an empty one */
                        xrdp_wm_log_msg(self->wm, LOG_LEVEL_ERROR,
                                        "No password field is available");
                        status = 1;
                    }
                    else
                    {
                        xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO,
                                        "Performing login request for %s",
                                        username);
                        status = xrdp_mm_send_sys_login_request(self,
                                                                username,
                                                                password);
                        if (status == 0)
                        {
                            /* Now waiting for a reply from sesman - see
                               xrdp_mm_process_create_session_response() */
                            self->mmcs_expecting_msg = 1;
                        }
                    }
                }
            }
            break;

            case MMCS_CREATE_SESSION:
                if (self->use_sesman)
                {
                    xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO,
                                    "login was successful - creating session");
                    if ((status = xrdp_mm_create_session(self)) == 0)
                    {
                        /* Now waiting for a reply from sesman. Note that
                         * when it arrives, sesman is expecting us to
                         * close the connection - we can do nothing else
                         * with it */
                        self->mmcs_expecting_msg = 1;
                    }
                }
                break;

            case MMCS_CONNECT_TO_SESSION:
            {
                xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO,
                                "Connecting to session");
                /* This is synchronous - no reply message expected */
                status = xrdp_mm_user_session_connect(self);
            }
            break;

            case MMCS_CONNECT_TO_CHANSRV:
            {
                if (self->use_chansrv)
                {
                    char portbuff[XRDP_SOCKETS_MAXPATH];

                    xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO,
                                    "Connecting to chansrv");
                    if (self->use_sesman)
                    {
                        g_snprintf(portbuff, sizeof(portbuff),
                                   XRDP_CHANSRV_STR, self->uid, self->display);
                    }
                    else
                    {
                        const char *cp = xrdp_mm_get_value(self, "chansrvport");
                        portbuff[0] = '\0';
                        parse_chansrvport(cp, portbuff, sizeof(portbuff),
                                          self->uid);

                    }
                    xrdp_mm_update_allowed_channels(self);
                    xrdp_mm_chansrv_connect(self, portbuff);
                }
            }
            break;

            case MMCS_DONE:
            {
                /* Shouldn't get here */
                LOG(LOG_LEVEL_ERROR, "xrdp_mm_connect_sm: state machine error");
                status = 1;
            }
            break;
        }

        /* Move to the next state */
        if (self->connect_state < MMCS_DONE)
        {
            self->connect_state = (enum mm_connect_state)
                                  (self->connect_state + 1);
        }
    }

    if (!self->mmcs_expecting_msg)
    {
        /* We don't need the sesman transport anymore */
        if (self->sesman_trans != NULL)
        {
            self->delete_sesman_trans = 1;
        }
        xrdp_wm_mod_connect_done(self->wm, status);
        /* Make sure the module is cleaned up if we weren't successful */
        if (status != 0)
        {
            xrdp_mm_module_cleanup(self);
        }
    }
}
