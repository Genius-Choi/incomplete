server_egfx_cmd(struct xrdp_mod *mod,
                char *cmd, int cmd_bytes,
                char *data, int data_bytes)
{
    XRDP_ENC_DATA *enc;
    struct xrdp_wm *wm;
    struct xrdp_mm *mm;

    wm = (struct xrdp_wm *)(mod->wm);
    mm = wm->mm;
    if (mm->encoder == NULL)
    {
        // This can happen when we are in the resize state machine, if
        // there are messages queued up by the X server
        if (data != NULL)
        {
            g_munmap(data, data_bytes);
        }
        return 0;
    }
    enc = g_new0(struct xrdp_enc_data, 1);
    if (enc == NULL)
    {
        if (data != NULL)
        {
            g_munmap(data, data_bytes);
        }
        return 1;
    }
    ENC_SET_BIT(enc->flags, ENC_FLAGS_GFX_BIT);
    enc->u.gfx.cmd = g_new(char, cmd_bytes);
    if (enc->u.gfx.cmd == NULL)
    {
        if (data != NULL)
        {
            g_munmap(data, data_bytes);
        }
        g_free(enc);
        return 1;
    }
    g_memcpy(enc->u.gfx.cmd, cmd, cmd_bytes);
    enc->u.gfx.cmd_bytes = cmd_bytes;
    enc->u.gfx.data = data;
    enc->u.gfx.data_bytes = data_bytes;
    enc->shmem_ptr = data;
    enc->shmem_bytes = data_bytes;
    /* insert into fifo for encoder thread to process */
    tc_mutex_lock(mm->encoder->mutex);
    fifo_add_item(mm->encoder->fifo_to_proc, enc);
    tc_mutex_unlock(mm->encoder->mutex);
    /* signal xrdp_encoder thread */
    g_set_wait_obj(mm->encoder->xrdp_encoder_event_to_proc);
    return 0;
}
