xrdp_mm_egfx_send_planar_bitmap(struct xrdp_mm *self,
                                struct xrdp_bitmap *bitmap,
                                struct xrdp_rect *rect, int surface_id,
                                int x, int y)
{
    struct xrdp_egfx_rect gfx_rect;
    struct stream *comp_s;
    struct stream *temp_s;
    char *pixels;
    char *src8;
    char *dst8;
    int index;
    int lines;
    int comp_bytes;
    int xindex;
    int yindex;
    int bwidth;
    int bheight;
    int cx;
    int cy;
    int rv = 0;

    LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_send_planar_bitmap:");
    LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_mm_egfx_send_planar_bitmap: "
              "surface_id %d rect %d %d %d %d x %d y %d",
              surface_id, rect->left, rect->top, rect->right, rect->bottom,
              x, y);
    bwidth = rect->right - rect->left;
    bheight = rect->bottom - rect->top;
    if ((bwidth < 1) || (bheight < 1))
    {
        return 0;
    }
    if (bwidth < 64)
    {
        cx = bwidth;
        cy = 4096 / cx;
    }
    else if (bheight < 64)
    {
        cy = bheight;
        cx = 4096 / cy;
    }
    else
    {
        cx = 64;
        cy = 64;
    }
    while (cx * cy < 4096)
    {
        if (cx < cy)
        {
            cx++;
            cy = 4096 / cx;
        }
        else
        {
            cy++;
            cx = 4096 / cy;
        }
    }
    LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_send_planar_bitmap: cx %d cy %d", cx, cy);
    pixels = g_new(char, GFX_PLANAR_BYTES);
    make_stream(comp_s);
    init_stream(comp_s, GFX_PLANAR_BYTES);
    make_stream(temp_s);
    init_stream(temp_s, GFX_PLANAR_BYTES);
    if (xrdp_egfx_send_frame_start(self->egfx, 1, 0) != 0)
    {
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_send_planar_bitmap: "
            "xrdp_egfx_send_frame_start error");
        rv = 1;
        goto cleanup;
    }

    LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_send_planar_bitmap: left %d top %d right %d "
              "bottom %d", rect->left, rect->top, rect->right, rect->bottom);
    for (yindex = rect->top; yindex < rect->bottom; yindex += cy)
    {
        bheight = rect->bottom - yindex;
        bheight = MIN(bheight, cy);
        for (xindex = rect->left; xindex < rect->right; xindex += cx)
        {
            bwidth = rect->right - xindex;
            bwidth = MIN(bwidth, cx);
            LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_send_planar_bitmap: xindex %d "
                      "yindex %d, bwidth %d bheight %d",
                      xindex, yindex, bwidth, bheight);
            src8 = bitmap->data + bitmap->line_size * yindex + xindex * 4;
            dst8 = pixels + (bheight - 1) * bwidth * 4;
            for (index = 0; index < bheight; index++)
            {
                g_memcpy(dst8, src8, bwidth * 4);
                src8 += bitmap->line_size;
                dst8 -= bwidth * 4;
            }
            lines = libxrdp_planar_compress(pixels, bwidth, bheight, comp_s,
                                            32, GFX_PLANAR_BYTES, bheight - 1,
                                            temp_s, 0, 0x10);
            comp_s->end = comp_s->p;
            comp_s->p = comp_s->data;
            if (lines != bheight)
            {
                LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_send_planar_bitmap: "
                    "lines(%d) != bheight(%d) error", lines, bheight);
            }
            else
            {
                comp_bytes = (int)(comp_s->end - comp_s->data);
                LOG_DEVEL(LOG_LEVEL_TRACE, "xrdp_mm_egfx_send_planar_bitmap: lines %d "
                          "comp_bytes %d", lines, comp_bytes);
                gfx_rect.x1 = xindex - x;
                gfx_rect.y1 = yindex - y;
                gfx_rect.x2 = gfx_rect.x1 + bwidth;
                gfx_rect.y2 = gfx_rect.y1 + bheight;
                if (xrdp_egfx_send_wire_to_surface1(self->egfx, surface_id,
                                                    XR_RDPGFX_CODECID_PLANAR,
                                                    XR_PIXEL_FORMAT_XRGB_8888,
                                                    &gfx_rect, comp_s->data,
                                                    comp_bytes) != 0)
                {
                    LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_send_planar_bitmap: "
                        "xrdp_egfx_send_wire_to_surface1 error");
                    rv = 1;
                    goto cleanup;
                }
            }
        }
    }
    if (xrdp_egfx_send_frame_end(self->egfx, 1) != 0)
    {
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_send_planar_bitmap: "
            "xrdp_egfx_send_frame_end error");
        rv = 1;
    }
cleanup:
    g_free(pixels);
    free_stream(comp_s);
    free_stream(temp_s);
    return rv;
}
