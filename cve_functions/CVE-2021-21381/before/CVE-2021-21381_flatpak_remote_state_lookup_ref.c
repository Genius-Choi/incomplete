flatpak_remote_state_lookup_ref (FlatpakRemoteState *self,
                                 const char         *ref,
                                 char              **out_checksum,
                                 guint64            *out_timestamp,
                                 VarRefInfoRef      *out_info,
                                 GFile             **out_sideload_path,
                                 GError            **error)
{
  if (!flatpak_remote_state_allow_ref (self, ref))
    {
      return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,
                                 _("No entry for %s in remote '%s' summary flatpak cache "),
                                 ref, self->remote_name);
    }

  /* If there is a summary we use it for metadata and for latest. We may later install from a sideloaded source though */
  if (self->summary != NULL || self->index != NULL)
    {
      VarRefInfoRef info;
      g_autofree char *checksum = NULL;
      GVariant *summary;

      summary = get_summary_for_ref (self, ref);
      if (summary == NULL ||
          !flatpak_summary_lookup_ref (summary, NULL, ref, &checksum, &info))
        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,
                                   _("No such ref '%s' in remote %s"),
                                   ref, self->remote_name);

      /* Even if its available in the summary we want to install it from a sideload repo if available */

      if (out_sideload_path)
        {
          g_autoptr(GFile) found_sideload_path = NULL;

          for (int i = 0; i < self->sideload_repos->len; i++)
            {
              FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);
              OstreeRepoCommitState commit_state;

              if (ostree_repo_load_commit (ss->repo, checksum, NULL, &commit_state, NULL) &&
                  commit_state == OSTREE_REPO_COMMIT_STATE_NORMAL)
                {
                  found_sideload_path = g_object_ref (ostree_repo_get_path (ss->repo));
                  break;
                }
            }

          *out_sideload_path = g_steal_pointer (&found_sideload_path);
        }

      if (out_info)
        *out_info = info;
      if (out_checksum)
        *out_checksum = g_steal_pointer (&checksum);
      if (out_timestamp)
        *out_timestamp = get_timestamp_from_ref_info (info);
    }
  else
    {
      FlatpakSideloadState *ss = NULL;

      if (!flatpak_remote_state_resolve_sideloaded_ref (self, ref, out_checksum, out_timestamp, out_info, &ss, error))
        return FALSE;

      if (out_sideload_path)
        *out_sideload_path = g_object_ref (ostree_repo_get_path (ss->repo));
    }

  return TRUE;
}
