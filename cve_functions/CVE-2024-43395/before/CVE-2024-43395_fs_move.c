static int fs_move(lua_State *L) {
    lastCFunction = __func__;
    std::string str1 = checkstring(L, 1);
    std::string str2 = checkstring(L, 2);
    if (fixpath_ro(get_comp(L), str1)) luaL_error(L, "Access denied");
    if (fixpath_ro(get_comp(L), str2)) luaL_error(L, "Access denied");
    bool isRoot = false;
    const path_t fromPath = fixpath(get_comp(L), str1, true, true, NULL, &isRoot);
    const path_t toPath = fixpath_mkdir(get_comp(L), str2);
    if (fromPath.empty()) luaL_error(L, "No such file");
    if (toPath.empty()) err(L, 2, "Invalid path");
    if (std::regex_search((*fromPath.begin()).native(), pathregex("^\\d+:"))) err(L, 1, "Permission denied");
    if (std::regex_search((*toPath.begin()).native(), pathregex("^\\d+:"))) err(L, 2, "Permission denied");
    if (std::mismatch(toPath.begin(), toPath.end(), fromPath.begin(), fromPath.end()).second == fromPath.end()) 
        luaL_error(L, "Can't move a directory inside itself");
    if (isRoot) luaL_error(L, "Cannot move mount");
    std::error_code e;
    if (fs::exists(toPath, e)) luaL_error(L, "File exists");
    e.clear();
    fs::create_directories(toPath.parent_path(), e);
    if (e) err(L, 2, e.message().c_str());
    fs::rename(fromPath, toPath, e);
    if (e) err(L, 1, e.message().c_str());
    return 0;
}
