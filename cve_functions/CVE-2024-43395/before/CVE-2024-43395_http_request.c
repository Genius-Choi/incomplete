static int http_request(lua_State *L) {
    lastCFunction = __func__;
    if (!config.http_enable) {
        lua_pushboolean(L, false);
        return 1;
    }
    if (!lua_isstring(L, 1) && !lua_istable(L, 1)) luaL_error(L, "bad argument #1 (expected string or table, got %s)", lua_typename(L, lua_type(L, 1)));
    http_param_t * param = new http_param_t;
    param->comp = get_comp(L);
    if (lua_istable(L, 1)) {
        lua_getfield(L, 1, "url");
        if (!lua_isstring(L, -1)) {delete param; return luaL_error(L, "bad field 'url' (string expected, got %s)", lua_typename(L, lua_type(L, -1)));}
        param->url = tostring(L, -1);
        param->old_url = param->url;
        lua_pop(L, 1);
        lua_getfield(L, 1, "body");
        if (!lua_isnil(L, -1) && !lua_isstring(L, -1)) {delete param; return luaL_error(L, "bad field 'body' (string expected, got %s)", lua_typename(L, lua_type(L, -1)));}
        else if (lua_isstring(L, -1)) param->postData = tostring(L, -1);
        lua_pop(L, 1);
        lua_getfield(L, 1, "method");
        if (!lua_isnil(L, -1) && !lua_isstring(L, -1)) {delete param; return luaL_error(L, "bad field 'method' (string expected, got %s)", lua_typename(L, lua_type(L, -1)));}
        else if (lua_isstring(L, -1)) param->method = tostring(L, -1);
        lua_pop(L, 1);
        lua_getfield(L, 1, "redirect");
        param->redirect = true;
        if (!lua_isnil(L, -1) && !lua_isboolean(L, -1)) {delete param; return luaL_error(L, "bad field 'redirect' (boolean expected, got %s)", lua_typename(L, lua_type(L, -1)));}
        else if (lua_isboolean(L, -1)) param->redirect = lua_toboolean(L, -1);
        lua_pop(L, 1);
        lua_getfield(L, 1, "headers");
        if (!lua_isnil(L, -1) && !lua_istable(L, -1)) {delete param; return luaL_error(L, "bad field 'headers' (table expected, got %s)", lua_typename(L, lua_type(L, -1)));}
        else if (lua_istable(L, -1)) {
            lua_pushnil(L);
            while (lua_next(L, -2)) {
                size_t keyn = 0, valn = 0;
                const char * key = lua_tolstring(L, -2, &keyn), *val = lua_tolstring(L, -1, &valn);
                if (key && val) param->headers[std::string(key, keyn)] = std::string(val, valn);
                lua_pop(L, 1);
            }
        }
        lua_pop(L, 1);
        lua_getfield(L, 1, "timeout");
        if (!lua_isnil(L, -1) && !lua_isnumber(L, -1)) {delete param; return luaL_error(L, "bad field 'timeout' (number expected, got %s)", lua_typename(L, lua_type(L, -1)));}
        else if (lua_isnumber(L, -1)) param->timeout = lua_tonumber(L, -1);
        else param->timeout = 0;
        lua_pop(L, 1);
    } else {
        param->url = checkstring(L, 1);
        param->old_url = param->url;
        if (!lua_isnoneornil(L, 2)) param->postData = checkstring(L, 2);
        else param->postData = "";
        if (lua_istable(L, 3)) {
            lua_pushvalue(L, 3);
            lua_pushnil(L);
            for (int i = 0; lua_next(L, -2); i++) {
                size_t keyn = 0, valn = 0;
                const char * key = lua_tolstring(L, -2, &keyn), *val = lua_tolstring(L, -1, &valn);
                if (key && val) param->headers[std::string(key, keyn)] = std::string(val, valn);
                lua_pop(L, 1);
            }
            lua_pop(L, 1);
        }
        param->method = luaL_optstring(L, 5, "");
        param->redirect = !lua_isboolean(L, 6) || lua_toboolean(L, 6);
        param->timeout = 0;
    }
    std::lock_guard<std::mutex> lock(param->comp->httpRequestQueueMutex);
    if (param->comp->requests_open >= config.http_max_requests) {
        param->comp->httpRequestQueue.push(param);
    } else {
        std::thread th(downloadThread, param);
        setThreadName(th, "HTTP Request Thread");
        th.detach();
    }
    lua_pushboolean(L, 1);
    return 1;
}
