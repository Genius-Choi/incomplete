static int fs_copy(lua_State *L) {
    lastCFunction = __func__;
    std::string str1 = checkstring(L, 1);
    std::string str2 = checkstring(L, 2);
    if (fixpath_ro(get_comp(L), str2)) luaL_error(L, "/%s: Access denied", fixpath(get_comp(L), str2, false, false).c_str());
    const path_t fromPath = fixpath(get_comp(L), str1, true);
    const path_t toPath = fixpath_mkdir(get_comp(L), str2);
    if (fromPath.empty()) err(L, 1, "No such file");
    if (toPath.empty()) err(L, 2, "Invalid path");
    if (std::regex_search((*toPath.begin()).native(), pathregex("^\\d+:"))) err(L, 2, "Permission denied");
    if (std::regex_search((*fromPath.begin()).native(), pathregex("^\\d+:"))) {
        try {
            const FileEntry &d = get_comp(L)->virtualMounts[(unsigned)std::stoul((*fromPath.begin()).c_str())]->path(fromPath.lexically_relative(*fromPath.begin()));
            if (d.isDir) err(L, 1, "Is a directory");
            std::ofstream tofp(toPath);
            if (!tofp.is_open()) return err(L, 2, "Cannot write file");
            tofp.write(d.data.c_str(), d.data.size());
            tofp.close();
        } catch (...) {err(L, 1, "No such file");}
    } else {
        /*if (isFSCaseSensitive == -1) {
            struct_stat st;
            char* name = tmpnam(NULL);
            fclose(platform_fopen(name, "w"));
            std::transform(name, name + strlen(name), name, [](char c)->char{return isupper(c) ? tolower(c) : toupper(c);});
            isFSCaseSensitive = stat(name, &st);
            remove(name);
        }*/
        std::vector<std::string> fromElems = split(str1, "/\\"), toElems = split(str2, "/\\");
        while (!fromElems.empty() && fromElems.front().empty()) fromElems.erase(fromElems.begin());
        while (!toElems.empty() && toElems.front().empty()) toElems.erase(toElems.begin());
        while (!fromElems.empty() && fromElems.back().empty()) fromElems.pop_back();
        while (!toElems.empty() && toElems.back().empty()) toElems.pop_back();
        bool equal = true;
        for (unsigned i = 0; i < toElems.size() && equal; i++) {
            if (i >= fromElems.size()) err(L, 1, "Can't copy a directory inside itself");
            std::string lstrfrom = fromElems[i], lstrto = toElems[i];
            std::transform(lstrfrom.begin(), lstrfrom.end(), lstrfrom.begin(), [](unsigned char c) {return std::tolower(c);});
            std::transform(lstrto.begin(), lstrto.end(), lstrto.begin(), [](unsigned char c) {return std::tolower(c);});
            if (lstrfrom != lstrto) equal = false;
            else if ((i == fromElems.size() - 1 && i == toElems.size() - 1)) err(L, 1, "Can't copy a directory inside itself");
        }
        if (equal) err(L, 1, "Can't copy a directory inside itself");
        std::error_code e;
        fs::create_directories(toPath.parent_path(), e);
        if (e) err(L, 2, e.message().c_str());
        fs::copy(fromPath, toPath, fs::copy_options::recursive, e);
        if (e) err(L, 1, e.message().c_str());
    }
    return 0;
}
