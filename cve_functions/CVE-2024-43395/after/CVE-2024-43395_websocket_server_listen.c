static int websocket_server_listen(lua_State *L) {
    lastCFunction = __func__;
    websocket_server::Factory * f = *(websocket_server::Factory**)lua_touserdata(L, lua_upvalueindex(1));
    int tm = 0;
    if (lua_getctx(L, &tm) == LUA_YIELD) {
        if (lua_isstring(L, 1)) {
            // haha, another string scoping issue :DDD
            // can M$ PLEASE fix this? (maybe I need to repro & report? :thinking:)
            if (f == NULL) {
                lua_pushnil(L);
                return 1;
            }
            std::string * ev = new std::string(lua_tostring(L, 1));
            if (lua_isnumber(L, 2)) {
                int id = lua_tointeger(L, 2);
                if (*ev == "websocket_server_connect" && id == f->srv->port()) {
                    lua_pushvalue(L, 3);
                    delete ev;
                    return 1;
                } else if (tm > 0 && *ev == "timer" && id == tm) {
                    lua_pushnil(L);
                    delete ev;
                    return 1;
                } else if (*ev == "terminate") {
                    delete ev;
                    return luaL_error(L, "Terminated");
                }
            }
            delete ev;
        }
    } else {
        if (f == NULL) luaL_error(L, "attempt to use a closed file");
        // instead of using native timer routines, we're using os.startTimer so we can be resumed
        if (!lua_isnoneornil(L, 1)) {
            luaL_checknumber(L, 1);
            lua_pushcfunction(L, os_startTimer);
            lua_pushvalue(L, 1);
            lua_call(L, 1, 1);
            tm = lua_tointeger(L, -1);
            lua_pop(L, 1);
        } else tm = -1;
    }
    lua_settop(L, 0);
    return lua_yieldk(L, 0, tm, websocket_server_listen);
}
