bool matchIPClass(const std::string& address, const std::string& pattern) {
    static const std::regex ipv4_regex("(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)");
    static const std::regex ipv6_regex("");
    static const std::regex ipv4_class_regex("(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/(\\d+)");
    static const std::regex regex_escape("[\\^\\$\\\\\\.\\+\\?\\(\\)\\[\\]\\{\\}\\|]");
    static const std::regex regex_wildcard("\\*");
    if (!didAddIPv4IPs.load()) {
        didAddIPv4IPs.store(true);
        reservedIPv6s.reserve(reservedIPv6s.size() + reservedIPv4s.size());
        for (const auto& cl : reservedIPv4s)
            reservedIPv6s.push_back(std::make_pair<IPv6, uint8_t>({0, 0, 0, 0, 0, 0xffff, (uint16_t)(cl.first >> 16), (uint16_t)(cl.first & 0xFFFF)}, cl.second + 96));
    }
    std::smatch pmatch, amatch;
    const std::regex patreg(std::regex_replace(std::regex_replace(pattern, regex_escape, "\\$&"), regex_wildcard, ".*"));
    if ((pattern == "$private" && address == "localhost") || std::regex_match(address, patreg)) return true;
    else if (std::regex_match(address, amatch, ipv4_regex)) {
        const int a1 = std::stoi(amatch[1]), a2 = std::stoi(amatch[2]), a3 = std::stoi(amatch[3]), a4 = std::stoi(amatch[4]);
        const uint32_t ip = makeIP(a1, a2, a3, a4);
        if (std::regex_match(pattern, pmatch, ipv4_class_regex)) {
            const int b1 = std::stoi(pmatch[1]), b2 = std::stoi(pmatch[2]), b3 = std::stoi(pmatch[3]), b4 = std::stoi(pmatch[4]);
            const uint32_t pattern_ip = makeIP(b1, b2, b3, b4);
            const uint32_t netmask = 0xFFFFFFFFu << std::stoi(pmatch[5]);
            return (pattern_ip & netmask) == (ip & netmask);
        } else if (pattern == "$private")
            for (const auto& cl : reservedIPv4s)
                if ((ip & (0xFFFFFFFFu << cl.second)) == cl.first) return true;
    } // check IPv6 addresses
    return false;
}
