IMAPIdentity * IMAPSession::identity(IMAPIdentity * clientIdentity, ErrorCode * pError)
{
    connectIfNeeded(pError);
    if (* pError != ErrorNone)
        return NULL;

    struct mailimap_id_params_list * client_identification;

    client_identification = mailimap_id_params_list_new_empty();

    mc_foreacharray(String, key, clientIdentity->allInfoKeys()) {
        MMAPString * mmap_str_name = mmap_string_new(key->UTF8Characters());
        MMAPString * mmap_str_value = mmap_string_new(clientIdentity->infoForKey(key)->UTF8Characters());
        mmap_string_ref(mmap_str_name);
        mmap_string_ref(mmap_str_value);
        mailimap_id_params_list_add_name_value(client_identification, mmap_str_name->str, mmap_str_value->str);
    }

    int r;
    struct mailimap_id_params_list * server_identification;
    r = mailimap_id(mImap, client_identification, &server_identification);
    mailimap_id_params_list_free(client_identification);
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        return NULL;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;
        return NULL;
    }
    else if (hasError(r)) {
        * pError = ErrorIdentity;
        return NULL;
    }

    IMAPIdentity * result = new IMAPIdentity();
    
    clistiter * cur;
    for(cur = clist_begin(server_identification->idpa_list) ; cur != NULL ; cur = clist_next(cur)) {
        struct mailimap_id_param * param;

        param = (struct mailimap_id_param *) clist_content(cur);
        
        String * responseKey;
        String * responseValue;
        responseKey = String::stringWithUTF8Characters(param->idpa_name);
        responseValue = String::stringWithUTF8Characters(param->idpa_value);
        result->setInfoForKey(responseKey, responseValue);
    }

    mailimap_id_params_list_free(server_identification);
    * pError = ErrorNone;

    result->autorelease();
    return result;
}
