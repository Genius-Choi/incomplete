void IMAPSession::idle(String * folder, uint32_t lastKnownUID, Data ** response, ErrorCode * pError)
{
    int r;
    
    setNeedsReselect();

    // connection thread
    selectIfNeeded(folder, pError);
    if (* pError != ErrorNone)
        return;
    
    if (lastKnownUID != 0) {
        Array * msgs;
        
        msgs = fetchMessagesByUID(folder, IMAPMessagesRequestKindUid, IndexSet::indexSetWithRange(RangeMake(lastKnownUID, UINT64_MAX)),
                                  NULL, pError);
        if (* pError != ErrorNone)
            return;
        if (msgs->count() > 0) {
            IMAPMessage * msg;
            
            msg = (IMAPMessage *) msgs->objectAtIndex(0);
            if (msg->uid() > lastKnownUID) {
                MCLog("found msg UID %u %u", (unsigned int) msg->uid(), (unsigned int) lastKnownUID);
                return;
            }
        }
    }
    
    r = mailimap_idle(mImap);
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        return;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;
        return;
    }
    else if (hasError(r)) {
        * pError = ErrorIdle;
        return;
    }
    
    if (!mImap->imap_selection_info->sel_has_exists && !mImap->imap_selection_info->sel_has_recent) {
        int r;
        r = mailstream_wait_idle(mImap->imap_stream, MAX_IDLE_DELAY);
        switch (r) {
            case MAILSTREAM_IDLE_ERROR:
            case MAILSTREAM_IDLE_CANCELLED:
            {
                mShouldDisconnect = true;
                * pError = ErrorConnection;
                MCLog("error or cancelled");
                return;
            }
            case MAILSTREAM_IDLE_INTERRUPTED:
                * pError = ErrorIdleInterrupted;
                MCLog("interrupted by user");
                break;
            case MAILSTREAM_IDLE_HASDATA:
                MCLog("something on the socket");
                break;
            case MAILSTREAM_IDLE_TIMEOUT:
                MCLog("idle timeout");
                break;
        }
    }
    else {
        MCLog("found info before idling");
    }
    
    r = mailimap_idle_done(mImap);
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        return;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;
        return;
    }
    else if (hasError(r)) {
        * pError = ErrorIdle;
        return;
    }
    * pError = ErrorNone;
}
