Data * IMAPSession::fetchNonDecodedMessageAttachment(String * folder, bool identifier_is_uid,
                                           uint32_t identifier, String * partID,
                                           bool wholePart, uint32_t offset, uint32_t length,
                                           Encoding encoding, IMAPProgressCallback * progressCallback, ErrorCode * pError)
{
    struct mailimap_fetch_type * fetch_type;
    struct mailimap_fetch_att * fetch_att;
    struct mailimap_section * section;
    struct mailimap_section_part * section_part;
    clist * sec_list;
    Array * partIDArray;
    int r;
    char * text = NULL;
    size_t text_length = 0;
    Data * data;

    selectIfNeeded(folder, pError);
    if (* pError != ErrorNone)
        return NULL;

    mProgressItemsCount = 0;
    mProgressCallback = progressCallback;
    bodyProgress(0, 0);

    partIDArray = partID->componentsSeparatedByString(MCSTR("."));
    sec_list = clist_new();
    for(unsigned int i = 0 ; i < partIDArray->count() ; i ++) {
        uint32_t * value;
        String * element;

        element = (String *) partIDArray->objectAtIndex(i);
        value = (uint32_t *) malloc(sizeof(* value));
        * value = element->intValue();
        clist_append(sec_list, value);
    }
    section_part = mailimap_section_part_new(sec_list);
    section = mailimap_section_new_part(section_part);
    if (wholePart) {
        fetch_att = mailimap_fetch_att_new_body_peek_section(section);
    }
    else {
        fetch_att = mailimap_fetch_att_new_body_peek_section_partial(section, offset, length);
    }
    fetch_type = mailimap_fetch_type_new_fetch_att(fetch_att);

#ifdef LIBETPAN_HAS_MAILIMAP_RAMBLER_WORKAROUND
    if (mRamblerRuServer && (encoding == EncodingBase64 || encoding == EncodingUUEncode)) {
        mailimap_set_rambler_workaround_enabled(mImap, 1);
    }
#endif

    r = fetch_imap(mImap, identifier_is_uid, identifier, fetch_type, &text, &text_length);
    mailimap_fetch_type_free(fetch_type);

#ifdef LIBETPAN_HAS_MAILIMAP_RAMBLER_WORKAROUND
    mailimap_set_rambler_workaround_enabled(mImap, 0);
#endif

    mProgressCallback = NULL;
    
    MCLog("had error : %i", r);
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        return NULL;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;
        return NULL;
    }
    else if (hasError(r)) {
        * pError = ErrorFetch;
        return NULL;
    }

    data = Data::data();
    data->takeBytesOwnership(text, (unsigned int) text_length, nstringDeallocator);
    
    * pError = ErrorNone;
    
    return data;
}
