void IMAPSession::select(String * folder, ErrorCode * pError)
{
    int r;

    MCLog("select");
    MCAssert(mState == STATE_LOGGEDIN || mState == STATE_SELECTED);

    r = mailimap_select(mImap, MCUTF8(folder));
    MCLog("select error : %i", r);
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        MCLog("select error : %s %i", MCUTF8DESC(this), * pError);
        return;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;
        return;
    }
    else if (hasError(r)) {
        * pError = ErrorNonExistantFolder;
        mState = STATE_LOGGEDIN;
        MC_SAFE_RELEASE(mCurrentFolder);
        return;
    }

    MC_SAFE_REPLACE_COPY(String, mCurrentFolder, folder);

    if (mImap->imap_selection_info != NULL) {
        mUIDValidity = mImap->imap_selection_info->sel_uidvalidity;
        mUIDNext = mImap->imap_selection_info->sel_uidnext;        
        if (mImap->imap_selection_info->sel_has_exists) {
            mFolderMsgCount = (unsigned int) (mImap->imap_selection_info->sel_exists);
        } else {
            mFolderMsgCount = -1;
        }
        
        if (mImap->imap_selection_info->sel_first_unseen) {
            mFirstUnseenUid = mImap->imap_selection_info->sel_first_unseen;
        } else {
            mFirstUnseenUid = 0;
        }
        
        if (mImap->imap_selection_info->sel_unseen) {
            mUnseenCount = mImap->imap_selection_info->sel_unseen;
        } else {
            mUnseenCount = 0;
        }
        
        if (mImap->imap_selection_info->sel_perm_flags) {
          clistiter * cur;

          struct mailimap_flag_perm * perm_flag;
          for(cur = clist_end(mImap->imap_selection_info->sel_perm_flags) ; cur != NULL ;
              cur = clist_previous(cur)) {
            perm_flag = (struct mailimap_flag_perm *)clist_content(cur);
            mAllowsNewPermanentFlags = perm_flag->fl_type == MAILIMAP_FLAG_PERM_ALL;
            if (mAllowsNewPermanentFlags) {
              break;
            }
          }
        }
      
        mModSequenceValue = get_mod_sequence_value(mImap);
    }

    mState = STATE_SELECTED;
    * pError = ErrorNone;
    MCLog("select ok");
}
