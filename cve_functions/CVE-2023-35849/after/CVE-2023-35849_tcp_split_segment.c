static struct pico_frame *tcp_split_segment(struct pico_socket_tcp *t, struct pico_frame *f, uint16_t size)
{
    struct pico_frame *f1, *f2;
    uint16_t size1, size2, size_f;
    uint16_t overhead;
    struct pico_tcp_hdr *hdr1, *hdr2, *hdr = (struct pico_tcp_hdr *)f->transport_hdr;
    overhead = pico_tcp_overhead(&t->sock);
    size_f = f->payload_len;


    if (size >= size_f)
        return f; /* no need to split! */

    size1 = size;
    size2 = (uint16_t)(size_f - size);

    f1 = pico_socket_frame_alloc(&t->sock, get_sock_dev(&t->sock), (uint16_t) (size1 + overhead));
    f2 = pico_socket_frame_alloc(&t->sock, get_sock_dev(&t->sock), (uint16_t) (size2 + overhead));

    if (!f1 || !f2) {
        pico_err = PICO_ERR_ENOMEM;
        return NULL;
    }

    /* Advance payload pointer to the beginning of segment data */
    f1->payload += overhead;
    f1->payload_len = (uint16_t)(f1->payload_len - overhead);
    f2->payload += overhead;
    f2->payload_len = (uint16_t)(f2->payload_len - overhead);

    hdr1 = (struct pico_tcp_hdr *)f1->transport_hdr;
    hdr2 = (struct pico_tcp_hdr *)f2->transport_hdr;

    /* Copy payload */
    memcpy(f1->payload, f->payload, size1);
    memcpy(f2->payload, f->payload + size1, size2);

    /* Copy tcp hdr */
    memcpy(hdr1, hdr, sizeof(struct pico_tcp_hdr));
    memcpy(hdr2, hdr, sizeof(struct pico_tcp_hdr));

    /* Adjust f2's sequence number */
    hdr2->seq = long_be(SEQN(f) + size1);

    /* Add TCP options */
    pico_tcp_flags_update(f1, &t->sock);
    pico_tcp_flags_update(f2, &t->sock);
    tcp_add_options_frame(t, f1);
    tcp_add_options_frame(t, f2);

    /* Get rid of the full frame */
    pico_discard_segment(&t->tcpq_out, f);

    /* Enqueue f2 for later send... */
    if (pico_enqueue_segment(&t->tcpq_out, f2) < 0) {
        tcp_dbg("Discarding invalid segment\n");
        pico_frame_discard(f2);
    }

    /* Return the partial frame */
    return f1;
}
