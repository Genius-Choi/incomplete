static int pico_ipv4_rebound_large(struct pico_stack *S, struct pico_frame *f)
{
#ifdef PICO_SUPPORT_IPV4FRAG
    uint16_t total_payload_written = 0;
    uint32_t len = f->transport_len;
    struct pico_frame *fr;
    struct pico_ip4 dst;
    struct pico_ipv4_hdr *hdr;
    hdr = (struct pico_ipv4_hdr *) f->net_hdr;
    dst.addr = hdr->src.addr;

    while(total_payload_written < len) {
        uint32_t space = (uint32_t)len - total_payload_written;
        if (space > PICO_IPV4_MAXPAYLOAD)
            space = PICO_IPV4_MAXPAYLOAD;

        fr = pico_ipv4_alloc(S, &pico_proto_ipv4, NULL, (uint16_t)space);
        if (!fr) {
            pico_err = PICO_ERR_ENOMEM;
            return -1;
        }

        if (space + total_payload_written < len)
        {
            fr->frag |= PICO_IPV4_MOREFRAG;
        }
        else
        {
            fr->frag &= PICO_IPV4_FRAG_MASK;
        }

        fr->frag = (((total_payload_written) >> 3u) & 0xffffu) | fr->frag;

        memcpy(fr->transport_hdr, f->transport_hdr + total_payload_written, fr->transport_len);
        if (pico_ipv4_frame_push(S, fr, &dst, hdr->proto) > 0) {
            total_payload_written = (uint16_t)((uint16_t)fr->transport_len + total_payload_written);
        } else {
            /* No need to discard frame here, pico_ipv4_frame_push() already did that */
            break;
        }
    } /* while() */
    return (int)total_payload_written;
#else
    (void)f;
    return -1;
#endif
}
