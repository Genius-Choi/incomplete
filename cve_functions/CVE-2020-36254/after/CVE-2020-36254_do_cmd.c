do_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc)
{
	int pin[2], pout[2], reserved[2];

	if (verbose_mode)
		fprintf(stderr,
		    "Executing: program %s host %s, user %s, command %s\n",
		    ssh_program, host,
		    remuser ? remuser : "(unspecified)", cmd);

	/*
	 * Reserve two descriptors so that the real pipes won't get
	 * descriptors 0 and 1 because that will screw up dup2 below.
	 */
	pipe(reserved);

	/* Create a socket pair for communicating with ssh. */
	if (pipe(pin) < 0)
		fatal("pipe: %s", strerror(errno));
	if (pipe(pout) < 0)
		fatal("pipe: %s", strerror(errno));

	/* Free the reserved descriptors. */
	close(reserved[0]);
	close(reserved[1]);

	/* uClinux needs to build the args here before vforking,
	   otherwise we do it later on. */
#if DROPBEAR_VFORK
	arg_setup(host, remuser, cmd);
#endif

	/* Fork a child to execute the command on the remote host using ssh. */
#if DROPBEAR_VFORK
	do_cmd_pid = vfork();
#else
	do_cmd_pid = fork();
#endif

	if (do_cmd_pid == 0) {
		/* Child. */
		close(pin[1]);
		close(pout[0]);
		dup2(pin[0], 0);
		dup2(pout[1], 1);
		close(pin[0]);
		close(pout[1]);

#if !DROPBEAR_VFORK
		arg_setup(host, remuser, cmd);
#endif

		execvp(ssh_program, args.list);
		perror(ssh_program);
#if DROPBEAR_VFORK
		_exit(1);
#else
		exit(1);
#endif
	} else if (do_cmd_pid == -1) {
		fatal("fork: %s", strerror(errno));
	}

#if DROPBEAR_VFORK
	/* clean up command */
	/* pop cmd */
	xfree(args.list[args.num-1]);
	args.list[args.num-1]=NULL;
	args.num--;
	/* pop host */
	xfree(args.list[args.num-1]);
	args.list[args.num-1]=NULL;
	args.num--;
	/* pop user */
	if (remuser != NULL) {
		xfree(args.list[args.num-1]);
		args.list[args.num-1]=NULL;
		args.num--;
	}
#endif

	/* Parent.  Close the other side, and return the local side. */
	close(pin[0]);
	*fdout = pin[1];
	close(pout[1]);
	*fdin = pout[0];
	signal(SIGTERM, killchild);
	signal(SIGINT, killchild);
	signal(SIGHUP, killchild);
	return 0;
}
