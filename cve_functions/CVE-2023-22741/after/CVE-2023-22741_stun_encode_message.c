int stun_encode_message(stun_msg_t *msg, stun_buffer_t *pwd) {

  int z = -1, len, buf_len = 0;
  unsigned char *buf;
  stun_attr_t *attr, *msg_int=NULL;

  if (msg->enc_buf.data == NULL) {
    /* convert msg to binary format */
    /* convert attributes to binary format for transmission */
    len = 0;
    for (attr = msg->stun_attr; attr ; attr = attr->next) {
      switch(attr->attr_type) {
      case RESPONSE_ADDRESS:
      case MAPPED_ADDRESS:
      case SOURCE_ADDRESS:
      case CHANGED_ADDRESS:
      case REFLECTED_FROM:
#ifdef USE_TURN
      case TURN_ALTERNATE_SERVER:
      case TURN_DESTINATION_ADDRESS:
      case TURN_SOURCE_ADDRESS:
#endif
	z = stun_encode_address(attr);
	break;
      case CHANGE_REQUEST:
#ifdef USE_TURN
      case TURN_LIFETIME:
      case TURN_MAGIC_COOKIE:
      case TURN_BANDWIDTH:
#endif
	z = stun_encode_uint32(attr);
	break;

      case USERNAME:
      case PASSWORD:
#ifdef USE_TURN
      case TURN_REALM:
      case TURN_NONCE:
      case TURN_DATA:
#endif
	z = stun_encode_buffer(attr);
	break;
      case MESSAGE_INTEGRITY:
	msg_int = attr;
	z = 24;
	break;
      case ERROR_CODE:
	z = stun_encode_error_code(attr);
      default:
	break;
      }

      if(z < 0) return z;

      len += z;
    }

    msg->stun_hdr.msg_len = len;
    buf_len = 20 + msg->stun_hdr.msg_len;
    buf = (unsigned char *) malloc(buf_len);

    /* convert to binary format for transmission */
    set16(buf, 0, msg->stun_hdr.msg_type);
    set16(buf, 2, msg->stun_hdr.msg_len);
    memcpy(buf + 4, msg->stun_hdr.tran_id, STUN_TID_BYTES);

    len = 20;

    /* attaching encoded attributes */
    attr = msg->stun_attr;
    while(attr) {
      /* attach only if enc_buf is not null */
      if(attr->enc_buf.data && attr->attr_type != MESSAGE_INTEGRITY) {
	memcpy(buf+len, (void *)attr->enc_buf.data, attr->enc_buf.size);
	len += attr->enc_buf.size;
      }
      attr = attr->next;
    }

    if (msg_int) {
      /* compute message integrity */
      if(stun_encode_message_integrity(msg_int, buf, len, pwd)!=24) {
	free(buf);
	return -1;
      }
      memcpy(buf+len, (void *)msg_int->enc_buf.data,
	     msg_int->enc_buf.size);
    }

    /* save binary buffer for future reference */
    if (msg->enc_buf.data)
      free(msg->enc_buf.data);

    msg->enc_buf.data = buf; msg->enc_buf.size = buf_len;
  }

  return 0;
}
