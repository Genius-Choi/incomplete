pf_purge(void *xnloops)
{
	int *nloops = xnloops;

	/*
	 * process a fraction of the state table every second
	 * Note:
	 *     we no longer need PF_LOCK() here, because
	 *     pf_purge_expired_states() uses pf_state_lock to maintain
	 *     consistency.
	 */
	if (pf_default_rule.timeout[PFTM_INTERVAL] > 0)
		pf_purge_expired_states(1 + (pf_status.states
		    / pf_default_rule.timeout[PFTM_INTERVAL]));

	NET_LOCK();

	PF_LOCK();
	/* purge other expired types every PFTM_INTERVAL seconds */
	if (++(*nloops) >= pf_default_rule.timeout[PFTM_INTERVAL])
		pf_purge_expired_src_nodes();
	PF_UNLOCK();

	/*
	 * Fragments don't require PF_LOCK(), they use their own lock.
	 */
	if ((*nloops) >= pf_default_rule.timeout[PFTM_INTERVAL]) {
		pf_purge_expired_fragments();
		*nloops = 0;
	}
	NET_UNLOCK();

	timeout_add_sec(&pf_purge_to, 1);
}
