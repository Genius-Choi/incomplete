pf_synproxy(struct pf_pdesc *pd, struct pf_state **stp, u_short *reason)
{
	struct pf_state_key	*sk = (*stp)->key[pd->didx];

	if ((*stp)->src.state == PF_TCPS_PROXY_SRC) {
		struct tcphdr	*th = &pd->hdr.tcp;

		if (pd->dir != (*stp)->direction) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		}
		if (th->th_flags & TH_SYN) {
			if (ntohl(th->th_seq) != (*stp)->src.seqlo) {
				REASON_SET(reason, PFRES_SYNPROXY);
				return (PF_DROP);
			}
			pf_send_tcp((*stp)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    (*stp)->src.seqhi, ntohl(th->th_seq) + 1,
			    TH_SYN|TH_ACK, 0, (*stp)->src.mss, 0, 1,
			    0, pd->rdomain);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		} else if ((th->th_flags & (TH_ACK|TH_RST|TH_FIN)) != TH_ACK ||
		    (ntohl(th->th_ack) != (*stp)->src.seqhi + 1) ||
		    (ntohl(th->th_seq) != (*stp)->src.seqlo + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_DROP);
		} else if (!SLIST_EMPTY(&(*stp)->src_nodes) &&
		    pf_src_connlimit(stp)) {
			REASON_SET(reason, PFRES_SRCLIMIT);
			return (PF_DROP);
		} else
			pf_set_protostate(*stp, PF_PEER_SRC,
			    PF_TCPS_PROXY_DST);
	}
	if ((*stp)->src.state == PF_TCPS_PROXY_DST) {
		struct tcphdr	*th = &pd->hdr.tcp;

		if (pd->dir == (*stp)->direction) {
			if (((th->th_flags & (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th->th_ack) != (*stp)->src.seqhi + 1) ||
			    (ntohl(th->th_seq) != (*stp)->src.seqlo + 1)) {
				REASON_SET(reason, PFRES_SYNPROXY);
				return (PF_DROP);
			}
			(*stp)->src.max_win = MAX(ntohs(th->th_win), 1);
			if ((*stp)->dst.seqhi == 1)
				(*stp)->dst.seqhi = arc4random();
			pf_send_tcp((*stp)->rule.ptr, pd->af,
			    &sk->addr[pd->sidx], &sk->addr[pd->didx],
			    sk->port[pd->sidx], sk->port[pd->didx],
			    (*stp)->dst.seqhi, 0, TH_SYN, 0,
			    (*stp)->src.mss, 0, 0, (*stp)->tag,
			    sk->rdomain);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		} else if (((th->th_flags & (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th->th_ack) != (*stp)->dst.seqhi + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_DROP);
		} else {
			(*stp)->dst.max_win = MAX(ntohs(th->th_win), 1);
			(*stp)->dst.seqlo = ntohl(th->th_seq);
			pf_send_tcp((*stp)->rule.ptr, pd->af, pd->dst,
			    pd->src, th->th_dport, th->th_sport,
			    ntohl(th->th_ack), ntohl(th->th_seq) + 1,
			    TH_ACK, (*stp)->src.max_win, 0, 0, 0,
			    (*stp)->tag, pd->rdomain);
			pf_send_tcp((*stp)->rule.ptr, pd->af,
			    &sk->addr[pd->sidx], &sk->addr[pd->didx],
			    sk->port[pd->sidx], sk->port[pd->didx],
			    (*stp)->src.seqhi + 1, (*stp)->src.seqlo + 1,
			    TH_ACK, (*stp)->dst.max_win, 0, 0, 1,
			    0, sk->rdomain);
			(*stp)->src.seqdiff = (*stp)->dst.seqhi -
			    (*stp)->src.seqlo;
			(*stp)->dst.seqdiff = (*stp)->src.seqhi -
			    (*stp)->dst.seqlo;
			(*stp)->src.seqhi = (*stp)->src.seqlo +
			    (*stp)->dst.max_win;
			(*stp)->dst.seqhi = (*stp)->dst.seqlo +
			    (*stp)->src.max_win;
			(*stp)->src.wscale = (*stp)->dst.wscale = 0;
			pf_set_protostate(*stp, PF_PEER_BOTH,
			    TCPS_ESTABLISHED);
			REASON_SET(reason, PFRES_SYNPROXY);
			return (PF_SYNPROXY_DROP);
		}
	}
	return (PF_PASS);
}
