pf_state_insert(struct pfi_kif *kif, struct pf_state_key **skwp,
    struct pf_state_key **sksp, struct pf_state *st)
{
	struct pf_state_key *skw = *skwp;
	struct pf_state_key *sks = *sksp;
	int same = (skw == sks);

	PF_ASSERT_LOCKED();

	st->kif = kif;
	PF_STATE_ENTER_WRITE();

	skw = pf_state_key_attach(skw, st, PF_SK_WIRE);
	if (skw == NULL) {
		pf_state_key_unref(sks);
		PF_STATE_EXIT_WRITE();
		return (-1);
	}

	if (same) {
		/* pf_state_key_attach might have swapped skw */
		pf_state_key_unref(sks);
		st->key[PF_SK_STACK] = sks = pf_state_key_ref(skw);
	} else if (pf_state_key_attach(sks, st, PF_SK_STACK) == NULL) {
		pf_state_key_detach(st, PF_SK_WIRE);
		PF_STATE_EXIT_WRITE();
		return (-1);
	}

	if (st->id == 0 && st->creatorid == 0) {
		st->id = htobe64(pf_status.stateid++);
		st->creatorid = pf_status.hostid;
	}
	if (RBT_INSERT(pf_state_tree_id, &tree_id, st) != NULL) {
		if (pf_status.debug >= LOG_NOTICE) {
			log(LOG_NOTICE, "pf: state insert failed: "
			    "id: %016llx creatorid: %08x",
			    betoh64(st->id), ntohl(st->creatorid));
			addlog("\n");
		}
		pf_detach_state(st);
		PF_STATE_EXIT_WRITE();
		return (-1);
	}
	pf_state_list_insert(&pf_state_list, st);
	pf_status.fcounters[FCNT_STATE_INSERT]++;
	pf_status.states++;
	pfi_kif_ref(kif, PFI_KIF_REF_STATE);
#if NPFSYNC > 0
	pfsync_insert_state(st);
#endif	/* NPFSYNC > 0 */
	PF_STATE_EXIT_WRITE();

	*skwp = skw;
	*sksp = sks;

	return (0);
}
