static const char *ac3dmx_probe_data(const u8 *_data, u32 _size, GF_FilterProbeScore *score)
{
	GF_AC3Config ahdr;
	u32 i, nb_frames=0;
	Bool has_broken_frames = GF_FALSE;
	u32 pos=0;
	const u8 *data = _data;
	u32 size = _size;
	u32 nb_ac3_frames=0;

	//check AC3
	while (1) {
		ahdr.sample_rate = 0;
		if (! gf_ac3_parser((u8 *) data, size, &pos, &ahdr, GF_FALSE) ) {
			if (ahdr.sample_rate) nb_frames++;
		 	break;
		}
		u32 fsize = ahdr.framesize;
		if (pos) {
			nb_frames=0;
			has_broken_frames = GF_TRUE;
			//what is before is bigger than max ac3 frame size (1920 words), this is packaged ac3 (mkv) at best
			if (pos > 4000)
				break;
		}
		nb_frames++;
		if (fsize > size+pos) {
			if (!pos && (nb_frames==1)) nb_frames++;
			break;
		}
		if (nb_frames>4) break;
		if (size < fsize+pos) break;
		size -= fsize+pos;
		data += fsize+pos;
	}
	nb_ac3_frames = nb_frames;

	//check EAC3
	pos=0;
	data = _data;
	size = _size;
	nb_frames = 0;
	GF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);
	while (gf_bs_available(bs)) {
		ahdr.sample_rate = 0;
		if (!gf_eac3_parser_bs(bs, &ahdr, GF_FALSE)) {
			if (ahdr.sample_rate) nb_frames++;
			break;
		}

		if (pos != (u32) gf_bs_get_position(bs))
			has_broken_frames = GF_TRUE;
		nb_frames += ahdr.nb_streams;
		for (i=0; i<ahdr.nb_streams; i++)
			nb_frames += ahdr.streams[i].nb_dep_sub ? 1 : 0;
		gf_bs_skip_bytes(bs, ahdr.framesize);
		if (!pos && (nb_frames==1) && !gf_bs_available(bs)) nb_frames++;
		pos+=ahdr.framesize;
		if (nb_frames>4) break;
	}
	gf_bs_del(bs);

	if (nb_frames<nb_ac3_frames) {
		nb_frames = 0;
	}
	if (nb_ac3_frames>=2) {
		*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;
		return "audio/ac3";
	}

	if (nb_frames>=2) {
		*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;
		return "audio/eac3";
	}

	return NULL;
}
