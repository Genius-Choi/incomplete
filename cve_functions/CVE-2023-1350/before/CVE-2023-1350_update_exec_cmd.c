update_exec_cmd (updateJobPtr job)
{
	gboolean	ret;
	gchar		*cmd = (job->request->source) + 1;

	/* Previous versions ran through popen() and a lot of users may be depending
	 * on this behavior, so we run through a shell and keep compatibility. */
	gchar		*cmd_args[] = { "/bin/sh", "-c", cmd, NULL };

	job->result->httpstatus = 0;
	debug1 (DEBUG_UPDATE, "executing command \"%s\"...", cmd);
	ret = g_spawn_async_with_pipes (NULL, cmd_args, NULL,
		G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_STDERR_TO_DEV_NULL,
		NULL, NULL, &job->cmd.pid, NULL,
		&job->cmd.fd, NULL, NULL);

	if (!ret) {
		debug0 (DEBUG_UPDATE, "g_spawn_async_with_pipes failed");
		liferea_shell_set_status_bar (_("Error: Could not open pipe \"%s\""), cmd);
		job->result->httpstatus = 404; /* Not found */
		return;
	}

	debug1 (DEBUG_UPDATE, "New child process launched with pid %d", job->cmd.pid);

	job->cmd.child_watch_id = g_child_watch_add (job->cmd.pid, (GChildWatchFunc) update_exec_cmd_cb_child_watch, job);
	job->cmd.stdout_ch = g_io_channel_unix_new (job->cmd.fd);
	job->cmd.io_watch_id = g_io_add_watch (job->cmd.stdout_ch, G_IO_IN | G_IO_HUP, (GIOFunc) update_exec_cmd_cb_out_watch, job);

	job->cmd.timeout_id = g_timeout_add (get_exec_timeout_ms(), (GSourceFunc) update_exec_cmd_cb_timeout, job);
}
