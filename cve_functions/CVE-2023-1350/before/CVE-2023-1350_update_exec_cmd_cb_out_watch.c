update_exec_cmd_cb_out_watch (GIOChannel *source, GIOCondition condition, gpointer user_data)
{
	updateJobPtr	job = (updateJobPtr) user_data;
	GError		*err = NULL;
	gboolean	ret = TRUE;	/* Do not remove event source yet. */
	GIOStatus	st;
	gsize		nread;

	if (condition == G_IO_HUP) {
		debug1 (DEBUG_UPDATE, "Pipe closed, child process %d is terminating", job->cmd.pid);
		ret = FALSE;

	} else if (condition == G_IO_IN) {
		while (TRUE) {
			job->result->data = g_realloc (job->result->data, job->result->size + 1025);

			nread = 0;
			st = g_io_channel_read_chars (source,
				job->result->data + job->result->size,
				1024, &nread, &err);
			job->result->size += nread;
			job->result->data[job->result->size] = 0;

			if (err) {
				debug2 (DEBUG_UPDATE, "Error %d when reading from child %d", err->code, job->cmd.pid);
				g_error_free (err);
				err = NULL;
				ret = FALSE;	/* remove event */
			}

			if (nread == 0) {
				/* Finished reading */
				break;
			} else if (st == G_IO_STATUS_AGAIN) {
				/* just try again */
			} else if (st == G_IO_STATUS_EOF) {
				/* Pipe closed */
				ret = FALSE;
				break;
			} else if (st == G_IO_STATUS_ERROR) {
				debug1 (DEBUG_UPDATE, "Got a G_IO_STATUS_ERROR from child %d", job->cmd.pid);
				ret = FALSE;
				break;
			}
		}

	} else {
		debug2 (DEBUG_UPDATE, "Unexpected condition %d for child process %d", condition, job->cmd.pid);
		ret = FALSE;
	}

	if (ret == FALSE) {
		close (job->cmd.fd);
		job->cmd.fd = -1;
		job->cmd.io_watch_id = 0;	/* Caller will remove source. */
	}

	return ret;
}
