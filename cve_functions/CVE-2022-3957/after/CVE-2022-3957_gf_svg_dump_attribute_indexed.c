char *gf_svg_dump_attribute_indexed(GF_Node *elt, GF_FieldInfo *info)
{
	char tmp[1024];

	switch (info->fieldType) {
	case SVG_PointerEvents_datatype:
		break;
	case XMLRI_List_datatype:
		return gf_strdup(info->far_ptr ? (char *) info->far_ptr : "");

	case SVG_Points_datatype:
	{
#if DUMP_COORDINATES
		SVG_Point *p = (SVG_Point *)gf_list_get(*(GF_List **)info->far_ptr, 0);
		sprintf(tmp, "%g %g", _FIX2FLT(p->x), _FIX2FLT(p->y));
		return gf_strdup(tmp);
#endif
	}
	break;
	case SMIL_KeyPoints_datatype:
	case SMIL_KeyTimes_datatype:
	case SMIL_KeySplines_datatype:
	{
		Fixed *p = (Fixed *)gf_list_get(*(GF_List **)info->far_ptr, 0);
		sprintf(tmp, "%g", _FIX2FLT(*p));
		return gf_strdup(tmp);
	}
	break;
	case SVG_Coordinates_datatype:
#if DUMP_COORDINATES
		return svg_dump_number((SVG_Length *) (SVG_Coordinate *)info->far_ptr);
#endif
		break;
	case SVG_ViewBox_datatype:
	{
		Fixed *v = (Fixed *)info->far_ptr;
		sprintf(tmp, "%g", _FIX2FLT(*v));
		return gf_strdup(tmp);
	}
	break;
	case SVG_StrokeDashArray_datatype:
	{
		/*TODO: fix this: should be an SVG_Length*/
		Fixed *p = (Fixed *)info->far_ptr;
		sprintf(tmp, "%g", _FIX2FLT(*p));
		return gf_strdup(tmp);
	}
	break;
	case SMIL_Times_datatype:
	{
		SMIL_Time *t = (SMIL_Time *)gf_list_get(*(GF_List **)info->far_ptr, 0);
		if (t->type == GF_SMIL_TIME_CLOCK) {
			sprintf(tmp, "%gs", t->clock);
		} else if (t->type==GF_SMIL_TIME_INDEFINITE) {
			strcpy(tmp, "indefinite");
		} else if (t->type==GF_SMIL_TIME_WALLCLOCK) {
			u32 h, m, s;
			/*TODO - day month and year*/
			h = (u32) t->clock * 3600;
			m = (u32) (t->clock * 60 - 60*h);
			s = (u32) (t->clock - 3600*h - 60*m);
			sprintf(tmp, "wallclock(%d:%d:%d)", h, m, s);
		}
		else if (t->type==GF_SMIL_TIME_EVENT) {
			GF_Node *par = gf_node_get_parent((GF_Node *)elt, 0);
			if (t->event.type == GF_EVENT_KEYDOWN) {
				svg_dump_access_key(&t->event, tmp);
			} else {
				strcpy(tmp, "");
				if (t->element_id) {
					strcat(tmp, t->element_id);
					strcat(tmp, ".");
				} else if (t->element && (t->element!=par) && gf_node_get_id(t->element) ) {
					const char *name = gf_node_get_name(t->element);
					if (name) {
						strcat(tmp, name);
					} else {
						sprintf(tmp, "N%d", gf_node_get_id(t->element)-1 );
					}
					strcat(tmp, ".");
				}
				strcat(tmp, gf_dom_event_get_name(t->event.type));
			}
			if (t->clock) {
				char szBuf[100];
				sprintf(szBuf, "+%gs", t->clock);
				strcat(tmp, szBuf);
			}
		}
		return gf_strdup(tmp);
	}

	default:
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[SVG Dumping] indexed field %s of type %s not supported\n", info->name, gf_svg_attribute_type_to_string(info->fieldType)));
		break;
	}
	return gf_strdup("");
}
