static GF_Err smil_parse_time(GF_Node *elt, SMIL_Time *v, char *d)
{
	GF_Err e = GF_OK;
	char *tmp;

	/* Offset Values */
	if ((d[0] >= '0' && d[0] <= '9') || d[0] == '+' || d[0] == '-') {
		v->type = GF_SMIL_TIME_CLOCK;
		return svg_parse_clock_value(d, &(v->clock));
	}

	/* Indefinite Values */
	else if (!strcmp(d, "indefinite")) {
		v->type = GF_SMIL_TIME_INDEFINITE;
		return GF_OK;
	}

	/* Wallclock Values */
	else if ((tmp = strstr(d, "wallclock("))) {
		u32 year, month, day;
		u32 hours, minutes;
		u32 nhours, nminutes;
		Float seconds;
		char *tmp1;

		v->type = GF_SMIL_TIME_WALLCLOCK;
		tmp += 10;
		if ((tmp1 = strchr(tmp, 'T')) ) {
			/* From tmp to wallStartTime, we parse a date */
			sscanf(tmp, "%u-%u-%dT", &year, &month, &day);
			tmp1++;
			tmp = tmp1;
		}
		if ((tmp1 = strchr(tmp, ':')) ) {
			if (strchr(tmp1, ':')) {
				/* HHMMSS */
				sscanf(tmp, "%u:%u:%f", &hours, &minutes, &seconds);
			} else {
				/* HHMM */
				sscanf(tmp, "%u:%u", &hours, &minutes);
			}
		}
		if (strchr(tmp, 'Z')) {
			return GF_OK;
		} else {
			if ( (tmp1 = strchr(tmp, '+')) ) {
				sscanf(tmp1, "%u:%u", &nhours, &nminutes);
			} else if ( (tmp1 = strchr(tmp, '-')) ) {
				sscanf(tmp1, "%u:%u", &nhours, &nminutes);
			}
		}
		return GF_OK;
	}

	/* AccessKey Values */
	else if ((tmp = strstr(d, "accessKey("))) {
		char *sep;
		v->type = GF_SMIL_TIME_EVENT;
		v->event.type = GF_EVENT_KEYDOWN;
		v->element = elt->sgprivate->scenegraph->RootNode;
		tmp+=10;
		sep = strchr(d, ')');
		sep[0] = 0;
		v->event.parameter = gf_dom_get_key_type(tmp);
		sep++;
		if ((tmp = strchr(sep, '+')) || (tmp = strchr(sep, '-'))) {
			char c = *tmp;
			tmp++;
			e = svg_parse_clock_value(tmp, &(v->clock));
			if (c == '-') v->clock *= -1;
		}
		return e;
	}

	else {
		Bool had_param = 0;
		char *tmp2;
		v->type = GF_SMIL_TIME_EVENT;
		if ((tmp = strchr(d, '.'))) {
			tmp[0] = 0;
			if (strlen(d) == 0) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] expecting an id before '.' in SMIL Time .%s\n", tmp+1));
				return GF_BAD_PARAM;
			}
			v->element_id = gf_strdup(d);
			tmp[0] = '.';
			tmp++;
		} else {
			tmp = d;
		}
		if ((tmp2 = strchr(tmp, '('))) {
			tmp2[0] = 0;
			v->event.type = gf_dom_event_type_by_name(tmp);
			tmp2[0] = '(';
			tmp2++;
			had_param = 1;
			v->event.parameter = atoi(tmp2);
			tmp = strchr(tmp2, ')');
			if (!tmp) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] expecting ')' in SMIL Time %s\n", d));
				return GF_BAD_PARAM;
			}
			tmp++;
		}
		if ((tmp2 = strchr(tmp, '+')) || (tmp2 = strchr(tmp, '-'))) {
			char c = *tmp2;
			char *tmp3 = tmp2;
			tmp2[0] = 0;
			tmp3--;
			while (*tmp3==' ') {
				*tmp3=0;
				tmp3--;
			}
			if (v->event.type == 0) v->event.type = gf_dom_event_type_by_name(tmp);
			if (!had_param && (v->event.type == GF_EVENT_REPEAT || v->event.type == GF_EVENT_REPEAT_EVENT))
				v->event.parameter = 1;
			tmp2[0] = c;
			tmp2++;
			e = svg_parse_clock_value(tmp2, &(v->clock));
			if (c == '-') v->clock *= -1;
			return e;
		} else {
			if (v->event.type == 0) v->event.type = gf_dom_event_type_by_name(tmp);
			if (!had_param && (v->event.type == GF_EVENT_REPEAT || v->event.type == GF_EVENT_REPEAT_EVENT))
				v->event.parameter = 1;
		}
	}
	return GF_OK;
}
