RefPtr<PhysicalPage> MemoryManager::allocate_user_physical_page(ShouldZeroFill should_zero_fill)
{
    InterruptDisabler disabler;
    RefPtr<PhysicalPage> page = find_free_user_physical_page();

    if (!page) {
        if (m_user_physical_regions.is_empty()) {
            kprintf("MM: no user physical regions available (?)\n");
        }

        for_each_vmobject([&](auto& vmobject) {
            if (vmobject.is_purgeable()) {
                auto& purgeable_vmobject = static_cast<PurgeableVMObject&>(vmobject);
                int purged_page_count = purgeable_vmobject.purge_with_interrupts_disabled({});
                if (purged_page_count) {
                    kprintf("MM: Purge saved the day! Purged %d pages from PurgeableVMObject{%p}\n", purged_page_count, &purgeable_vmobject);
                    page = find_free_user_physical_page();
                    ASSERT(page);
                    return IterationDecision::Break;
                }
            }
            return IterationDecision::Continue;
        });

        if (!page) {
            kprintf("MM: no user physical pages available\n");
            ASSERT_NOT_REACHED();
            return {};
        }
    }

#ifdef MM_DEBUG
    dbgprintf("MM: allocate_user_physical_page vending P%p\n", page->paddr().get());
#endif

    if (should_zero_fill == ShouldZeroFill::Yes) {
        auto* ptr = (u32*)quickmap_page(*page);
        fast_u32_fill(ptr, 0, PAGE_SIZE / sizeof(u32));
        unquickmap_page();
    }

    ++m_user_physical_pages_used;
    return page;
}
