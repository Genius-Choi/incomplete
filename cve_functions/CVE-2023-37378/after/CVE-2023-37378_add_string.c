int CEXEBuild::add_string(const TCHAR *string, int process/*=1*/, UINT codepage/*=-2*/)
{
  if (!string || !*string) return 0;
  build_lockedunicodetarget = true;
  init_shellconstantvalues();
  if ((UINT)-2 == codepage)
  {
    codepage = curlinereader ? curlinereader->StreamEncoding().GetCodepage() : CP_UTF8;
    // If the current source file is Unicode we have to pick a real codepage for ANSI!
    // It might not be the correct codepage but it's the best we can do.
    // Not using CP_ACP to avoid heisenbugs when compiled on a different system.
    if (NStreamEncoding::IsUnicodeCodepage(codepage)) codepage = 1252;
  }
  if (*string == _T('$') && *(string+1) == _T('('))
  {
    int idx = 0;
    TCHAR *cp = _tcsdup(string+2);
    TCHAR *p = _tcschr(cp, _T(')'));
    if (p && p[1] == _T('\0') ) { // if string is only a language str identifier
      *p = 0;
      idx = DefineLangString(cp, process);
    }
    free(cp);
    if (idx < 0) return idx;
  }

  int i;
  if (process)
  {
    ExpandoString<TCHAR, NSIS_MAX_STRLEN*4> buf;
    // NOTE: It is impossible to know how much preprocessing will increase the size, we have to guess
    buf.Reserve(_tcsclen(string) * 2);
    preprocess_string(buf, string, codepage); // BUGBUG: This could overflow buf
    i = cur_strlist->add(buf, (WORD)codepage, true);
  }
  else
    i = cur_strlist->add(string, (WORD)codepage, false);
  return i;
}
