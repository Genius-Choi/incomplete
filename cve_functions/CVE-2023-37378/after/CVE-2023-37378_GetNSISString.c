TCHAR * NSISCALL GetNSISString(TCHAR *outbuf, int strtab)
{
  // This looks at the g_block (copied from header->blocks) and
  // indexes into the language
  TCHAR *in = (TCHAR*)GetNSISStringNP(GetNSISTab(strtab));
  TCHAR *out = ps_tmpbuf;

  // Still working within ps_tmpbuf, so set out to the
  // current position that is passed in.
  if (outbuf >= ps_tmpbuf && 
     (size_t) (outbuf - ps_tmpbuf) < COUNTOF(ps_tmpbuf))
  {
    out = outbuf;
    outbuf = 0;
  }

  while (*in && out - ps_tmpbuf < NSIS_MAX_STRLEN)
  {
    _TUCHAR nVarIdx = (_TUCHAR)*in++;
    int nData;
    int fldrs[4];
    if (nVarIdx < NS_SKIP_CODE)
    {
      // The next 2 BYTEs in the string might be coding either a value 0..MAX_CODED (nData), or 2 CSIDL of Special folders (for NS_SHELL_CODE)
      nData = DECODE_SHORT(in);
      // There are 2 CSIDL parameters for each context and query must be used before create 
      // because of bug #820 (CSIDL_FLAG_CREATE failures on root paths are cached in Vista).
#ifdef _UNICODE
      fldrs[1] = LOBYTE(*in); // current user
      fldrs[0] = fldrs[1] | CSIDL_FLAG_CREATE;
      fldrs[3] = HIBYTE(*in); // all users
      fldrs[2] = fldrs[3] | CSIDL_FLAG_CREATE;
#else
      fldrs[0] = in[0] | CSIDL_FLAG_CREATE; // current user
      fldrs[1] = in[0];
      fldrs[2] = in[1] | CSIDL_FLAG_CREATE; // all users
      fldrs[3] = in[1];
#endif
      in += sizeof(SHORT)/sizeof(TCHAR);

      if (nVarIdx == NS_SHELL_CODE)
      {
        LPITEMIDLIST idl;

        int x = 2;
        BOOL isWin9598 = IsWin9598();
        /*
        SHGetFolderPath as provided by shfolder.dll is used to get special folders
        unless the installer is running on Windows 95/98. For 95/98 shfolder.dll is
        only used for the Application Data and Documents folder (if the DLL exists).
        Otherwise, the old SHGetSpecialFolderLocation API is called.

        The reason for not using shfolder.dll for all folders on 95/98 is that some
        unsupported folders (such as the Start Menu folder for all users) are
        simulated instead of returning an error so we can fall back on the current
        user folder.

        SHGetFolderPath in shell32.dll could be called directly for Windows versions
        later than 95/98 but there is no need to do so, because shfolder.dll is still
        provided and calls shell32.dll.
        */
        BOOL use_shfolder =
          // Use shfolder if not on 95/98
          !isWin9598 ||
          // Unless the Application Data or Documents folder is requested
          (
            (fldrs[3] == CSIDL_COMMON_APPDATA) ||
            (fldrs[3] == CSIDL_COMMON_DOCUMENTS)
          );

        /* Carry on... shfolder stuff is over. */

        if (g_exec_flags.all_user_var)
        {
          x = 4; // Get common folder > Create common folder > Get user folder > Create user folder
        }

        if (fldrs[1] & 0x80)
        {
          myRegGetStr(HKEY_LOCAL_MACHINE, SYSREGKEY, GetNSISStringNP(fldrs[1] & 0x3F), out, fldrs[1] & 0x40);
          if (!*out)
            GetNSISString(out, fldrs[3]);
          x = 0;
        }
        else if (fldrs[1] == CSIDL_SYSTEM) // Does not work on 95, 98 nor NT4. Works on ME and 2000+.
        {
          GetSystemDirectory(out, NSIS_MAX_STRLEN);
          x = 0;
        }
        else if (fldrs[1] == CSIDL_WINDOWS) // Does not work on 95, 98 nor NT4. Works on ME and 2000+.
        {
          GetWindowsDirectory(out, NSIS_MAX_STRLEN);
          x = 0;
        }

        while (x--)
        {
          PFNSHCLONESPECIALIDLIST SHCSILFunc;
          int idandflags = fldrs[x] & ~0x40, create = idandflags & CSIDL_FLAG_CREATE;

          if (g_SHGetFolderPath && use_shfolder)
          {
            PFNSHGETFOLDERPATH SHGetFolderPathFunc = (PFNSHGETFOLDERPATH) g_SHGetFolderPath;
            if (!SHGetFolderPathFunc(g_hwnd, idandflags, NULL, SHGFP_TYPE_CURRENT, out))
            {
              break;
            }
          }

          // This function exists in 95 & NT4 but was undocumented back then so we have to import it by ordinal.
          SHCSILFunc = (PFNSHCLONESPECIALIDLIST) myGetProcAddress(MGA_SHCloneSpecialIDList);
          idl = SHCSILFunc(g_hwnd, LOBYTE(idandflags), create);
          if (idl)
          {
            BOOL res = SHGetPathFromIDList(idl, out);
            CoTaskMemFree(idl);
            if (res) break;
          }

          *out=0;
        }

        if (*out)
        {
          // all users' version is CSIDL_APPDATA only for $QUICKLAUNCH
          // for normal $APPDATA, it'd be CSIDL_APPDATA_COMMON
          if (fldrs[3] == CSIDL_APPDATA)
          {
            mystrcat(out, QUICKLAUNCH); // append suffix path for $QUICKLAUNCH
          }
        }
        validate_filename(out);
      }
      else if (nVarIdx == NS_VAR_CODE)
      {
        if (nData == 29) // $HWNDPARENT
          iptrtostr(out, (INT_PTR) g_hwnd);
        else
          mystrcpy(out, g_usrvars[nData]);
        // validate the directory name
        if ((unsigned int)(nData - 21) < 7) {
          // validate paths for $INSTDIR, $OUTDIR, $EXEDIR, $LANGUAGE, $TEMP, $PLUGINSDIR and $EXEPATH
          // $LANGUAGE is just a number anyway...
          validate_filename(out);
        }
      } // == VAR_CODES_START
      else if (nVarIdx == NS_LANG_CODE)
      {
        GetNSISString(out, -nData-1);
      }
      out += mystrlen(out);
    }
    else if (nVarIdx == NS_SKIP_CODE)
    {
      *out++ = *in++;
    }
    else // Normal char
    {
      *out++ = nVarIdx;
    }
  } // while
  *out = 0;
  if (outbuf)
    return mystrcpy(outbuf, ps_tmpbuf);
  return ps_tmpbuf;
}
