int CEXEBuild::uninstall_generate()
{
#ifdef NSIS_CONFIG_UNINSTALL_SUPPORT
  if (ubuild_entries.getlen() && uninstaller_writes_used)
  {
    SCRIPT_MSG(_T("Generating uninstaller... "));

    const int start_offset = postubuild_cmds ? truncate_cast(int, m_exehead_size) : 0;
    entry *ent = (entry *) build_entries.get();
    if (!ent) return PS_ERROR; // Check this early

    MMapBuf udata;
    firstheader fh={0,};

    GrowBuf uhd;
    {
      GrowBuf udata_exehead;

      set_uninstall_mode(1);

      PrepareHeaders(&udata_exehead);

      fh.length_of_header=udata_exehead.getlen();
      int err=add_data((char*)udata_exehead.get(),udata_exehead.getlen(),&uhd);
      set_uninstall_mode(0);
      if (err < 0) return PS_ERROR;
    }

    crc32_t crc=0;
#ifdef NSIS_CONFIG_CRC_SUPPORT
    bool calc_crc = true;
#else
    bool calc_crc = false;
#endif

    // Get offsets of icons to replace for uninstall
    // Also makes sure that the icons are there and in the right size.
    LPBYTE unicon_data = generate_uninstall_icon_data(installer_icon, uninstaller_icon, m_unicon_size);
    if (generate_unicons_offsets(m_exehead, m_exehead_size, unicon_data, IDI_ICON2) == 0)
    {
      delete [] unicon_data;
      return PS_ERROR;
    }

    int uns = uninstaller_writes_used;
    int uninstdata_offset = build_datablock.getlen();
    for (int ents = build_header.blocks[NB_ENTRIES].num; ents--; ent++)
    {
      if (ent->which == EW_WRITEUNINSTALLER)
      {
        ent->offsets[1] = uninstdata_offset;
        ent->offsets[2] = start_offset ? 0 : (int) m_unicon_size;
        if (!--uns)
          break;
      }
    }

    if (!start_offset && add_db_data((char *)unicon_data,m_unicon_size) < 0)
    {
      delete [] unicon_data;
      return PS_ERROR;
    }

    if (start_offset || calc_crc)
    {
      // create the uninstaller
      LPBYTE uninst_header = (LPBYTE) malloc(m_exehead_size);
      if (!uninst_header)
      {
        delete [] unicon_data;
        return PS_ERROR;
      }

      memcpy(uninst_header, m_exehead, m_exehead_size);

      // patch the icons
      LPBYTE seeker = unicon_data;
      while (*seeker) {
        DWORD dwSize = FIX_ENDIAN_INT32(*(LPDWORD) seeker);
        seeker += sizeof(DWORD);
        DWORD dwOffset = FIX_ENDIAN_INT32(*(LPDWORD) seeker);
        seeker += sizeof(DWORD);
        memcpy(uninst_header + dwOffset, seeker, dwSize);
        seeker += dwSize;
      }

      if (calc_crc)
      {
#ifdef NSIS_CONFIG_CRC_SUPPORT
#ifdef NSIS_CONFIG_CRC_ANAL
        crc=CRC32(crc, uninst_header, (DWORD)m_exehead_size);
#else
        crc=CRC32(crc, uninst_header + 512, (DWORD)m_exehead_size - 512);
#endif
#endif
      }

      // write the exehead
      if (start_offset)
        udata.add((char *)uninst_header, truncate_cast(int, m_exehead_size));

      free(uninst_header);
    }
    delete [] unicon_data;

    fh.nsinst[0]=FH_INT1;
    fh.nsinst[1]=FH_INT2;
    fh.nsinst[2]=FH_INT3;
    fh.flags=FH_FLAGS_UNINSTALL;
#ifdef NSIS_CONFIG_CRC_SUPPORT
    fh.flags|=(build_crcchk?(build_crcchk==2?FH_FLAGS_FORCE_CRC:0):FH_FLAGS_NO_CRC);
#endif
#ifdef NSIS_CONFIG_SILENT_SUPPORT
    if (build_uninst.flags&(CH_FLAGS_SILENT|CH_FLAGS_SILENT_LOG)) fh.flags |= FH_FLAGS_SILENT;
#endif
    fh.siginfo=FH_SIG;
    fh.length_of_all_following_data=
      uhd.getlen()+ubuild_datablock.getlen()+(int)sizeof(firstheader)+(build_crcchk?sizeof(crc32_t):0);

    {
      growbuf_writer_sink sink(&udata, mk_writer_target_info());
      firstheader_writer w(&sink);
      w.write(&fh);
    }

    ubuild_datablock.setro(TRUE);

#ifdef NSIS_CONFIG_COMPRESSION_SUPPORT
    if (build_compress_whole) {
      // compress uninstaller too
      {
        char obuf[65536];
        int n = compressor->Init(build_compress_level, build_compress_dict_size);
        if (n != C_OK)
        {
          ERROR_MSG(_T("Internal compiler error #12345: deflateInit() failed(%") NPRIs _T(" [%d]).\n"), compressor->GetErrStr(n), n);
          extern void quit(); quit();
        }

        compressor->SetNextIn((char*)uhd.get(), uhd.getlen());
        while (compressor->GetAvailIn())
        {
          compressor->SetNextOut(obuf, sizeof(obuf));
          compressor->Compress(0);
          if (compressor->GetNextOut() - obuf > 0)
          {
            udata.add(obuf, truncate_cast(int, (size_t)(compressor->GetNextOut() - obuf)));
          }
        }

        int avail_in = ubuild_datablock.getlen();
        int in_pos = 0;
        while (avail_in > 0) {
          int l = min(avail_in, build_filebuflen);

          char *p = (char*)ubuild_datablock.get(in_pos, l);
          compressor->SetNextIn(p, l);

          while (compressor->GetAvailIn())
          {
            compressor->SetNextOut(obuf, sizeof(obuf));
            compressor->Compress(0);
            if (compressor->GetNextOut() - obuf > 0)
              udata.add(obuf, truncate_cast(int, (size_t)(compressor->GetNextOut() - obuf)));
          }

          ubuild_datablock.release();

          avail_in -= l;
          in_pos += l;
        }

        for (;;)
        {
          compressor->SetNextOut(obuf, sizeof(obuf));
          compressor->Compress(C_FINISH);
          if (compressor->GetNextOut() - obuf > 0)
            udata.add(obuf, truncate_cast(int, (size_t)(compressor->GetNextOut() - obuf)));
          else break;
        }
        compressor->End();
      }

      firstheader *ufh=(firstheader *)udata.get(start_offset, sizeof(firstheader));
      ufh->length_of_all_following_data=FIX_ENDIAN_INT32((udata.getlen()-start_offset)+(build_crcchk?sizeof(crc32_t):0));
      udata.release();
    }
    else
#endif//NSIS_CONFIG_COMPRESSION_SUPPORT
    {
      udata.add(uhd.get(), uhd.getlen());

      int st = udata.getlen();
      int length = ubuild_datablock.getlen();
      int left = length;
      udata.resize(st + left);
      while (left > 0)
      {
        int l = min(build_filebuflen, left);
        void *p = ubuild_datablock.get(length - left, l);
        memcpy(udata.get(st + length - left, l), p, l);
        udata.flush(l);
        udata.release();
        ubuild_datablock.release();
        left -= l;
      }
    }

    ubuild_datablock.clear();

    udata.setro(TRUE);

#ifdef NSIS_CONFIG_CRC_SUPPORT
    if (build_crcchk)
    {
      int pos = 0;
      int left = udata.getlen() - start_offset;
      while (left > 0)
      {
        int l = min(build_filebuflen, left);
        crc = CRC32(crc, (unsigned char *) udata.get(pos + start_offset, l), l);
        udata.release();
        pos += l;
        left -= l;
      }
      udata.setro(FALSE);
      FIX_ENDIAN_INT32_INPLACE(crc);
      udata.add(&crc, sizeof(crc));
      udata.setro(TRUE);
    }
#endif

    if (start_offset)
    {
      TCHAR* fpath;
      if (!(fpath = create_tempfile_path()))
      {
        ERROR_MSG(_T("Error: can't get temporary path\n"));
        return PS_ERROR;
      }
      MANAGE_WITH(fpath, free);
      FILE *hfile = FOPEN(fpath, ("wb"));
      if (!hfile)
      {
        ERROR_MSG(_T("Error: failed opening file \"%") NPRIs _T("\"\n"), fpath);
        return PS_ERROR;
      }
      int succ = udata.write_to_external_file(hfile);
      fclose(hfile);
      if (!succ)
      {
        ERROR_MSG(_T("Error: can't write %d bytes to output\n"), udata.getlen());
        return PS_ERROR;
      }
      udata.clear();

      if (PS_OK != run_postbuild_cmds(postubuild_cmds, fpath, _T("UninstFinalize")))
      {
        return PS_ERROR;
      }

      MMapFile udata_in;
      UINT64 udata_size;
      if (!(udata_size = udata_in.setfile(fpath)))
      {
        ERROR_MSG(_T("Error: failed creating mmap of \"%") NPRIs _T("\"\n"), fpath);
        return PS_ERROR;
      }
      if (udata_size > NSIS_MAX_EXEFILESIZE || add_db_data(&udata_in) < 0)
        return PS_ERROR;

      assert(NSIS_MAX_EXEFILESIZE <= ~(UINT32)0);
      uninstall_size_full = (UINT32) udata_size;
      udata_in.clear();
      _tremove(fpath);
    }
    else
    {
      if (add_db_data(&udata) < 0)
        return PS_ERROR;

      //uninstall_size_full=fh.length_of_all_following_data + sizeof(int) + unicondata_size - 32 + sizeof(int);
      uninstall_size_full = fh.length_of_all_following_data+(int)m_unicon_size;
    }

    // compressed size
    uninstall_size=build_datablock.getlen()-uninstdata_offset;
    SCRIPT_MSG(_T("Done!\n"));
  }
#endif
  return PS_OK;
}
