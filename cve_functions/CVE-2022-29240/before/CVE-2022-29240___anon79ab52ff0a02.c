    }).then_wrapped([this, cqlop, stream, &client_state, linearization_buffer = std::move(linearization_buffer), trace_state] (future<result_with_foreign_response_ptr> f) {
        auto stop_trace = defer([&] {
            tracing::stop_foreground(trace_state);
        });
        --_server._stats.requests_serving;

        return utils::result_into_future<result_with_foreign_response_ptr>(utils::result_try([&] () -> result_with_foreign_response_ptr {
            result_with_foreign_response_ptr res = f.get0();
            if (!res) {
                return res;
            }

            auto response = std::move(res).assume_value();
            auto res_op = response->opcode();

            // and modify state now that we've generated a response.
            switch (client_state.get_auth_state()) {
            case auth_state::UNINITIALIZED:
                if (cqlop == cql_binary_opcode::STARTUP) {
                    if (res_op == cql_binary_opcode::AUTHENTICATE) {
                        client_state.set_auth_state(auth_state::AUTHENTICATION);
                    } else if (res_op == cql_binary_opcode::READY) {
                        client_state.set_auth_state(auth_state::READY);
                    }
                }
                break;
            case auth_state::AUTHENTICATION:
                // Support both SASL auth from protocol v2 and the older style Credentials auth from v1
                if (cqlop != cql_binary_opcode::AUTH_RESPONSE && cqlop != cql_binary_opcode::CREDENTIALS) {
                    throw exceptions::protocol_exception(format("Unexpected message {:d}, expecting AUTH_RESPONSE or CREDENTIALS", int(cqlop)));
                }
                if (res_op == cql_binary_opcode::READY || res_op == cql_binary_opcode::AUTH_SUCCESS) {
                    client_state.set_auth_state(auth_state::READY);
                }
                break;
            default:
            case auth_state::READY:
                break;
            }

            tracing::set_response_size(trace_state, response->size());
            return response;
        },  utils::result_catch<exceptions::unavailable_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_unavailable_error(stream, ex.code(), ex.what(), ex.consistency, ex.required, ex.alive, trace_state);
        }), utils::result_catch<exceptions::read_timeout_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_read_timeout_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.block_for, ex.data_present, trace_state);
        }), utils::result_catch<exceptions::read_failure_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_read_failure_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.failures, ex.block_for, ex.data_present, trace_state);
        }), utils::result_catch<exceptions::mutation_write_timeout_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_mutation_write_timeout_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.block_for, ex.type, trace_state);
        }), utils::result_catch<exceptions::mutation_write_failure_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_mutation_write_failure_error(stream, ex.code(), ex.what(), ex.consistency, ex.received, ex.failures, ex.block_for, ex.type, trace_state);
        }), utils::result_catch<exceptions::already_exists_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_already_exists_error(stream, ex.code(), ex.what(), ex.ks_name, ex.cf_name, trace_state);
        }), utils::result_catch<exceptions::prepared_query_not_found_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_unprepared_error(stream, ex.code(), ex.what(), ex.id, trace_state);
        }), utils::result_catch<exceptions::function_execution_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_function_failure_error(stream, ex.code(), ex.what(), ex.ks_name, ex.func_name, ex.args, trace_state);
        }), utils::result_catch<exceptions::rate_limit_exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_rate_limit_error(stream, ex.code(), ex.what(), ex.op_type, ex.rejected_by_coordinator, trace_state, client_state);
        }), utils::result_catch<exceptions::cassandra_exception>([&] (const auto& ex) {
            // Note: the CQL protocol specifies that many types of errors have
            // mandatory parameters. These cassandra_exception subclasses MUST
            // be handled above. This default "cassandra_exception" case is
            // only appropriate for the specific types of errors which do not have
            // additional information, such as invalid_request_exception.
            // TODO: consider listing those types explicitly, instead of the
            // catch-all type cassandra_exception.
            try { ++_server._stats.errors[ex.code()]; } catch(...) {}
            return make_error(stream, ex.code(), ex.what(), trace_state);
        }), utils::result_catch<std::exception>([&] (const auto& ex) {
            try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}
            sstring msg = ex.what();
            try {
                std::rethrow_if_nested(ex);
            } catch (...) {
                std::ostringstream ss;
                ss << msg << ": " << std::current_exception();
                msg = ss.str();
            }
            return make_error(stream, exceptions::exception_code::SERVER_ERROR, msg, trace_state);
        }), utils::result_catch_dots([&] () {
            try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}
            return make_error(stream, exceptions::exception_code::SERVER_ERROR, "unknown error", trace_state);
        })));
    });
