int cil_resolve_classorder(struct cil_tree_node *current, void *extra_args)
{
	struct cil_args_resolve *args = extra_args;
	struct cil_list *classorder_list = args->classorder_lists;
	struct cil_list *unordered_classorder_list = args->unordered_classorder_lists;
	struct cil_classorder *classorder = current->data;
	struct cil_list *new = NULL;
	struct cil_list_item *curr = NULL;
	struct cil_symtab_datum *datum = NULL;
	struct cil_ordered_list *class_list = NULL;
	int rc = SEPOL_ERR;
	int unordered = CIL_FALSE;

	cil_list_init(&new, CIL_CLASSORDER);

	cil_list_for_each(curr, classorder->class_list_str) {
		if (curr->data == CIL_KEY_UNORDERED) {
			unordered = CIL_TRUE;
			continue;
		}

		rc = cil_resolve_name(current, (char *)curr->data, CIL_SYM_CLASSES, extra_args, &datum);
		if (rc != SEPOL_OK) {
			cil_log(CIL_ERR, "Failed to resolve class %s in classorder\n", (char *)curr->data);
			goto exit;
		}
		cil_list_append(new, CIL_CLASS, datum);
	}

	__cil_ordered_list_init(&class_list);
	class_list->list = new;
	class_list->node = current;
	if (unordered) {
		cil_list_append(unordered_classorder_list, CIL_CLASSORDER, class_list);
	} else {
		cil_list_append(classorder_list, CIL_CLASSORDER, class_list);
	}

	return SEPOL_OK;

exit:
	cil_list_destroy(&new, CIL_FALSE);
	return rc;
}
