int cil_resolve_avrule(struct cil_tree_node *current, void *extra_args)
{
	struct cil_args_resolve *args = extra_args;
	struct cil_db *db = NULL;

	struct cil_avrule *rule = current->data;
	struct cil_symtab_datum *src_datum = NULL;
	struct cil_symtab_datum *tgt_datum = NULL;
	struct cil_symtab_datum *permx_datum = NULL;
	int used;
	int rc = SEPOL_ERR;

	if (args != NULL) {
		db = args->db;
	}

	rc = cil_resolve_name(current, rule->src_str, CIL_SYM_TYPES, args, &src_datum);
	if (rc != SEPOL_OK) {
		goto exit;
	}
	rule->src = src_datum;
		
	if (rule->tgt_str == CIL_KEY_SELF) {
		rule->tgt = db->selftype;
	} else {
		rc = cil_resolve_name(current, rule->tgt_str, CIL_SYM_TYPES, args, &tgt_datum);
		if (rc != SEPOL_OK) {
			goto exit;
		}
		rule->tgt = tgt_datum;
		used = (rule->rule_kind == CIL_AVRULE_NEVERALLOW) ?
			CIL_ATTR_NEVERALLOW : CIL_ATTR_AVRULE;
		cil_type_used(src_datum, used); /* src not used if tgt is self */
		cil_type_used(tgt_datum, used);
	}

	if (!rule->is_extended) {
		rc = cil_resolve_classperms_list(current, rule->perms.classperms, extra_args);
		if (rc != SEPOL_OK) {
			goto exit;
		}
	} else {
		if (rule->perms.x.permx_str != NULL) {
			rc = cil_resolve_name(current, rule->perms.x.permx_str, CIL_SYM_PERMX, args, &permx_datum);
			if (rc != SEPOL_OK) {
				goto exit;
			}
			rule->perms.x.permx = (struct cil_permissionx*)permx_datum;
		} else {
			rc = cil_resolve_permissionx(current, rule->perms.x.permx, extra_args);
			if (rc != SEPOL_OK) {
				goto exit;
			}
		}
	}

	return SEPOL_OK;

exit:
	return rc;
}
