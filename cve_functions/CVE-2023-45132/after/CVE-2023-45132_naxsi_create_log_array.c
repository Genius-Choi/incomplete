naxsi_create_log_array(ngx_http_request_ctx_t* ctx,
                       ngx_http_request_t*     r,
                       ngx_array_t*            ostr,
                       ngx_str_t**             ret_uri)
{
  u_int                     sz_left, sub, offset = 0, i;
  ngx_str_t *               fragment, *tmp_uri;
  ngx_http_special_score_t* sc;
  const char*               fmt_base   = "ip=%.*s&server=%.*s&uri=%.*s&config=%.*s&rid=";
  const char*               fmt_score  = "&cscore%d=%.*s&score%d=%zu";
  const char*               fmt_rm     = "&zone%d=%s&id%d=%d&var_name%d=%.*s";
  const char*               fmt_config = "";

  if (ctx->learning) {
    fmt_config = ctx->drop ? "learning-drop" : "learning";
  } else if (ctx->drop) {
    fmt_config = "drop";
  } else if (ctx->block) {
    fmt_config = "block";
  } else if (ctx->ignore) {
    fmt_config = "ignore";
  }

  ngx_http_matched_rule_t* mr;
  char                     tmp_zone[30];

  tmp_uri = ngx_pcalloc(r->pool, sizeof(ngx_str_t));
  if (!tmp_uri)
    return (NGX_ERROR);
  *ret_uri = tmp_uri;

  if (r->uri.len >= (NGX_MAX_UINT32_VALUE / 4) - 1) {
    r->uri.len /= 4;
  }

  tmp_uri->len  = r->uri.len + (2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_ARGS));
  tmp_uri->data = ngx_pcalloc(r->pool, tmp_uri->len + 1);
  ngx_escape_uri(tmp_uri->data, r->uri.data, r->uri.len, NGX_ESCAPE_ARGS);

  fragment = ngx_array_push(ostr);
  if (!fragment) {
    return (NGX_ERROR);
  }
  fragment->data = ngx_pcalloc(r->pool, MAX_LINE_SIZE + 1);
  if (!fragment->data) {
    return (NGX_ERROR);
  }
  sub = offset = 0;
  /* we keep extra space for seed*/
  sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - 1;

  /*
  ** don't handle uri > 4k, string will be split
  */

  sub = snprintf((char*)fragment->data,
                 sz_left,
                 fmt_base,
                 r->connection->addr_text.len,
                 r->connection->addr_text.data,
                 r->headers_in.server.len,
                 r->headers_in.server.data,
                 tmp_uri->len,
                 tmp_uri->data,
                 strlen(fmt_config),
                 fmt_config);

  if (sub >= sz_left) {
    sub = sz_left - 1;
  }
  sz_left -= sub;
  offset += sub;

  sub = NAXSI_REQUEST_ID_SIZE << 1;
  if (sz_left > (100 + sub)) {
    ngx_hex_dump(fragment->data + offset, ctx->request_id, NAXSI_REQUEST_ID_SIZE);
    if (sub >= sz_left) {
      sub = sz_left - 1;
    }
    sz_left -= sub;
    offset += sub;
  }

  /*
  ** if URI exceeds the MAX_LINE_SIZE, log directly, avoid null deref (#178)
  */
  if (sz_left < 100) {
    fragment = ngx_http_append_log(r, ostr, fragment, &offset);
    if (!fragment)
      return (NGX_ERROR);
    sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;
  }

  /*
  ** append scores
  */
  for (i = 0; ctx->special_scores && i < ctx->special_scores->nelts; i++) {
    sc = ctx->special_scores->elts;
    if (sc[i].sc_score != 0) {
      sub = snprintf(0, 0, fmt_score, i, sc[i].sc_tag->len, sc[i].sc_tag->data, i, sc[i].sc_score);
      if (sub >= sz_left) {
        /*
        ** ngx_http_append_log will add seed_start and seed_end, and adjust the
        *offset.
        */
        fragment = ngx_http_append_log(r, ostr, fragment, &offset);
        if (!fragment)
          return (NGX_ERROR);
        sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;
      }
      sub = snprintf((char*)(fragment->data + offset),
                     sz_left,
                     fmt_score,
                     i,
                     sc[i].sc_tag->len,
                     sc[i].sc_tag->data,
                     i,
                     sc[i].sc_score);
      if (sub >= sz_left) {
        sub = sz_left - 1;
      }
      offset += sub;
      sz_left -= sub;
    }
  }
  /*
  ** and matched zone/id/name
  */
  if (ctx->matched) {
    mr  = ctx->matched->elts;
    sub = 0;
    i   = 0;
    do {
      memset(tmp_zone, 0, sizeof(tmp_zone));
      if (mr[i].body_var)
        strcat(tmp_zone, "BODY");
      else if (mr[i].args_var)
        strcat(tmp_zone, "ARGS");
      else if (mr[i].headers_var)
        strcat(tmp_zone, "HEADERS");
      else if (mr[i].url)
        strcat(tmp_zone, "URL");
      else if (mr[i].file_ext)
        strcat(tmp_zone, "FILE_EXT");
      if (mr[i].target_name)
        strcat(tmp_zone, "|NAME");

      ngx_str_t tmp_val;

      if (mr[i].name->len >= (NGX_MAX_UINT32_VALUE / 4) - 1) {
        mr[i].name->len /= 4;
      }

      tmp_val.len =
        mr[i].name->len +
        (2 * ngx_escape_uri(NULL, mr[i].name->data, mr[i].name->len, NGX_ESCAPE_URI_COMPONENT));

      tmp_val.data = ngx_pcalloc(r->pool, tmp_val.len + 1);
      ngx_escape_uri(tmp_val.data, mr[i].name->data, mr[i].name->len, NGX_ESCAPE_URI_COMPONENT);

      sub =
        snprintf(0, 0, fmt_rm, i, tmp_zone, i, mr[i].rule->rule_id, i, tmp_val.len, tmp_val.data);
      /*
      ** This one would not fit :
      ** append a seed to the current fragment,
      ** and start a new one
      */
      if (sub >= sz_left) {
        fragment = ngx_http_append_log(r, ostr, fragment, &offset);
        if (!fragment)
          return (NGX_ERROR);
        sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;
      }
      sub = snprintf((char*)fragment->data + offset,
                     sz_left,
                     fmt_rm,
                     i,
                     tmp_zone,
                     i,
                     mr[i].rule->rule_id,
                     i,
                     tmp_val.len,
                     tmp_val.data);
      if (sub >= sz_left)
        sub = sz_left - 1;
      offset += sub;
      sz_left -= sub;
      i += 1;
    } while (i < ctx->matched->nelts);
  }
  fragment->len = offset;
  return (NGX_HTTP_OK);
}
