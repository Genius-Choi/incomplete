ngx_http_apply_rulematch_v_n(ngx_http_rule_t*        r,
                             ngx_http_request_ctx_t* ctx,
                             ngx_http_request_t*     req,
                             ngx_str_t*              name,
                             ngx_str_t*              value,
                             naxsi_match_zone_t      zone,
                             ngx_int_t               nb_match,
                             ngx_int_t               target_name)
{
  unsigned int               found = 0, i, z;
  ngx_http_special_score_t * sc, *rsc;
  ngx_http_naxsi_loc_conf_t* cf;
  ngx_http_matched_rule_t*   mr;
  ngx_str_t                  empty = ngx_string("");

  if (!name) {
    name = &empty;
  }
  if (!value) {
    value = &empty;
  }

  cf = ngx_http_get_module_loc_conf(req, ngx_http_naxsi_module);
  if (!cf || !ctx)
    return (0);
  if (ngx_http_naxsi_is_rule_whitelisted_n(req, cf, r, name, zone, target_name) == 1) {

    NX_DEBUG(
      _debug_whitelist_light, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, "rule is whitelisted.");

    return (0);
  }
  NX_DEBUG(_debug_extensive_log,
           NGX_LOG_DEBUG_HTTP,
           req->connection->log,
           0,
           "Current extensive log value: %d",
           ctx->extensive_log);

  if (ctx->extensive_log) {
    if (target_name) {
      naxsi_log_offending(ctx, req, value, name, r, zone, target_name);
    } else {
      naxsi_log_offending(ctx, req, name, value, r, zone, target_name);
    }
  }
  if (nb_match == 0)
    nb_match = 1;
  if (!ctx->matched)
    ctx->matched = ngx_array_create(req->pool, 2, sizeof(ngx_http_matched_rule_t));
  /* log stuff, cause this case sux */
  if (!ctx->matched)
    return (0);
  mr = ngx_array_push(ctx->matched);
  if (!mr)
    return (0);
  memset(mr, 0, sizeof(ngx_http_matched_rule_t));
  if (target_name)
    mr->target_name = 1;
  switch (zone) {
    case HEADERS:
      mr->headers_var = 1;
      break;
    case URL:
      mr->url = 1;
      break;
    case ARGS:
      mr->args_var = 1;
      break;
    case BODY:
      mr->body_var = 1;
      break;
    case FILE_EXT:
      mr->file_ext = 1;
      break;
    default:
      break;
  };
  mr->rule = r;
  // the current "name" ptr will be free by caller, so make a copy
  mr->name = ngx_pcalloc(req->pool, sizeof(ngx_str_t));
  if (name->len > 0) {
    mr->name->data = ngx_pcalloc(req->pool, name->len + 1);
    memcpy(mr->name->data, name->data, name->len);
    mr->name->len = name->len;
  } else {
    mr->name->data = NULL;
    mr->name->len  = 0;
  }
  /* apply special score on rulematch */
  if (r->sscores) {
    NX_DEBUG(_debug_whitelist,
             NGX_LOG_DEBUG_HTTP,
             req->connection->log,
             0,
             "Rule applies %d custom scores",
             r->sscores->nelts);

    if (!ctx->special_scores) // create the list
      ctx->special_scores = ngx_array_create(req->pool, 1, sizeof(ngx_http_special_score_t));
    rsc = r->sscores->elts;
    for (z = 0; z < r->sscores->nelts; z++) {
      // search into the list for matching special score
      found = 0;
      sc    = ctx->special_scores->elts;
      for (i = 0; i < ctx->special_scores->nelts; i++) {
        if (rsc[z].sc_tag && sc[i].sc_tag && sc[i].sc_tag->len == rsc[z].sc_tag->len &&
            !ngx_strcmp(sc[i].sc_tag->data, rsc[z].sc_tag->data)) {
          NX_DEBUG(_debug_whitelist,
                   NGX_LOG_DEBUG_HTTP,
                   req->connection->log,
                   0,
                   "Special Score (%V) actual=%d,next=%d",
                   rsc[z].sc_tag,
                   sc[i].sc_score,
                   sc[i].sc_score + (rsc[z].sc_score * nb_match));

          sc[i].sc_score += (rsc[z].sc_score * nb_match);
          found = 1;
          break;
        }
      }

      if (!found) {
        NX_DEBUG(_debug_whitelist,
                 NGX_LOG_DEBUG_HTTP,
                 req->connection->log,
                 0,
                 "Special Score (%V)  next=%d",
                 rsc[z].sc_tag,
                 (rsc[z].sc_score * nb_match));

        sc = ngx_array_push(ctx->special_scores);
        if (!sc)
          return (0);
        memset(sc, 0, sizeof(ngx_http_special_score_t));
        sc->sc_tag   = rsc[z].sc_tag;
        sc->sc_score = (rsc[z].sc_score * nb_match);
      }
    }
  }
  /* else, apply normal score */
  ctx->score += (r->score * nb_match);
  if (r->block)
    ctx->block = 1;
  if (r->allow)
    ctx->allow = 1;
  if (r->drop)
    ctx->drop = 1;
  if (r->log)
    ctx->log = 1;
  ngx_http_naxsi_update_current_ctx_status(ctx, cf, req);
  return (1);
}
