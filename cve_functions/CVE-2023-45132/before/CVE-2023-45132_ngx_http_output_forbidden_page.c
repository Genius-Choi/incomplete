ngx_http_output_forbidden_page(ngx_http_request_ctx_t* ctx, ngx_http_request_t* r)
{
  ngx_str_t *                tmp_uri, denied_args;
  ngx_str_t                  empty = ngx_string("");
  ngx_http_naxsi_loc_conf_t* cf;
  ngx_array_t*               ostr;
  ngx_table_elt_t*           h;
  unsigned int               i = 0;

  cf = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);
  /* get array of signatures strings */
  ostr = ngx_array_create(r->pool, 1, sizeof(ngx_str_t));
  if (naxsi_create_log_array(ctx, r, ostr, &tmp_uri) != NGX_HTTP_OK) {
    return (NGX_ERROR);
  }

  if (!ctx->json_log) {
    for (i = 0; i < ostr->nelts; i++) {
      ngx_log_error(NGX_LOG_ERR,
                    cf->log ? cf->log : r->connection->log,
                    0,
                    "NAXSI_FMT: %s",
                    ((ngx_str_t*)ostr->elts)[i].data);
    }
  } else {
    const char* hex  = "0123456789abcdef";
    ngx_str_t*  elts = (ngx_str_t*)ostr->elts;
    for (i = 0; i < ostr->nelts; i++) {
      char json[NAXSI_LOG_JSON_STRLEN] = { 0 };
      // line only
      const char* line = (const char*)elts[i].data;
      char*       curr = json + 2;
      char*       end  = (curr + sizeof(json)) - 4;

      json[0] = '{';
      json[1] = '"';

      size_t j;
      for (j = 0; line[j] && curr < end; j++) {
        if (line[j] == '=') {
          *curr = '"';
          curr++;
          break_if(curr >= end);
          *curr = ':';
          curr++;
          break_if(curr >= end);
          *curr = '"';
        } else if (line[j] == '&') {
          *curr = '"';
          curr++;
          break_if(curr >= end);
          *curr = ',';
          curr++;
          break_if(curr >= end);
          *curr = '"';
        } else if (line[j] == '"' || line[j] == '\\' /* || line[i] == '/'*/) {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = line[j];
        } else if (line[j] == '\b') {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = 'b';
        } else if (line[j] == '\f') {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = 'f';
        } else if (line[j] == '\n') {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = 'n';
        } else if (line[j] == '\r') {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = 'r';
        } else if (line[j] == '\t') {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = 't';
        } else if (is_printable(line[j])) {
          *curr = line[j];
        } else {
          *curr = '\\';
          curr++;
          break_if(curr >= end);
          *curr = 'u';
          curr++;
          break_if(curr >= end);
          *curr = '0';
          curr++;
          break_if(curr >= end);
          *curr = '0';
          curr++;
          break_if(curr >= end);
          *curr = hex[line[j] >> 8];
          curr++;
          break_if(curr >= end);
          *curr = hex[line[j] & 0x0F];
        }
        curr++;
      }

      if (curr >= end) {
        ngx_log_error(NGX_LOG_ERR,
                      r->connection->log,
                      0,
                      "cannot generate json structure due NGX_MAX_ERROR_STR size.");
        continue;
      }

      *curr = '"';
      curr++;
      *curr = '}';
      curr++;
      *curr = 0;

      ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "%s", json);
    }
  }

  if (ostr->nelts >= 1) {
    denied_args.data = ((ngx_str_t*)ostr->elts)[0].data;
    denied_args.len  = ((ngx_str_t*)ostr->elts)[0].len;
  } else {
    denied_args.data = empty.data;
    denied_args.len  = empty.len;
  }

  /*
  ** If we shouldn't block the request,
  ** but a log score was reached, stop.
  */
  if (ctx->log && (!ctx->block && !ctx->drop)) {
    return (NGX_DECLINED);
  }

  /*
  ** If we are in learning without post_action and without drop
  ** stop here as well.
  */
  if (ctx->learning && !ctx->post_action && !ctx->drop) {
    return (NGX_DECLINED);
  }
  /*
  ** add headers with original url
  ** and arguments, as well as
  ** the first fragment of log
  */

#define NAXSI_HEADER_ORIG_URL  "x-orig_url"
#define NAXSI_HEADER_ORIG_ARGS "x-orig_args"
#define NAXSI_HEADER_NAXSI_SIG "x-naxsi_sig"

  if (r->headers_in.headers.last) {

    h = ngx_list_push(&(r->headers_in.headers));
    if (!h)
      return (NGX_ERROR);
    h->key.len  = strlen(NAXSI_HEADER_ORIG_URL);
    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_URL) + 1);
    if (!h->key.data)
      return (NGX_ERROR);
    memcpy(h->key.data, NAXSI_HEADER_ORIG_URL, strlen(NAXSI_HEADER_ORIG_URL));
    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_URL) + 1);
    memcpy(h->lowcase_key, NAXSI_HEADER_ORIG_URL, strlen(NAXSI_HEADER_ORIG_URL));
    h->value.len  = tmp_uri->len;
    h->value.data = ngx_pcalloc(r->pool, tmp_uri->len + 1);
    memcpy(h->value.data, tmp_uri->data, tmp_uri->len);

    h = ngx_list_push(&(r->headers_in.headers));
    if (!h)
      return (NGX_ERROR);
    h->key.len  = strlen(NAXSI_HEADER_ORIG_ARGS);
    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_ARGS) + 1);
    if (!h->key.data)
      return (NGX_ERROR);
    memcpy(h->key.data, NAXSI_HEADER_ORIG_ARGS, strlen(NAXSI_HEADER_ORIG_ARGS));
    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_ARGS) + 1);
    memcpy(h->lowcase_key, NAXSI_HEADER_ORIG_ARGS, strlen(NAXSI_HEADER_ORIG_ARGS));
    h->value.len  = r->args.len;
    h->value.data = ngx_pcalloc(r->pool, r->args.len + 1);
    memcpy(h->value.data, r->args.data, r->args.len);

    h = ngx_list_push(&(r->headers_in.headers));
    if (!h)
      return (NGX_ERROR);
    h->key.len  = strlen(NAXSI_HEADER_NAXSI_SIG);
    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_NAXSI_SIG) + 1);
    if (!h->key.data)
      return (NGX_ERROR);
    memcpy(h->key.data, NAXSI_HEADER_NAXSI_SIG, strlen(NAXSI_HEADER_NAXSI_SIG));
    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_NAXSI_SIG) + 1);
    memcpy(h->lowcase_key, NAXSI_HEADER_NAXSI_SIG, strlen(NAXSI_HEADER_NAXSI_SIG));
    h->value.len  = denied_args.len;
    h->value.data = denied_args.data;
  }

  if (ctx->learning && !ctx->drop) {
    if (ctx->post_action) {
      ngx_http_core_loc_conf_t* clcf;
      clcf                   = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
      clcf->post_action.data = cf->denied_url->data;
      clcf->post_action.len  = cf->denied_url->len;
    }
    return (NGX_DECLINED);
  } else {
    ngx_http_internal_redirect(r, cf->denied_url, &empty);
    return (NGX_HTTP_OK);
  }
}
