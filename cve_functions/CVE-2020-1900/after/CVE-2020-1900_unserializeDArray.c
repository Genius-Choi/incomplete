Array VariableUnserializer::unserializeDArray() {
  if (m_dvOverrides) m_dvOverrides->push_back(true);

  int64_t size = readInt();
  expectChar(':');
  expectChar('{');

  auto provTag = unserializeProvenanceTag();
  if (!RO::EvalArrProvDVArrays) provTag = {};

  if (size == 0) {
    expectChar('}');
    return Array::attach(provTag
      ? arrprov::tagStaticArr(staticEmptyDArray(), provTag)
      : staticEmptyDArray()
    );
  }
  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {
    throwArraySizeOutOfBounds();
  }

  // For large arrays, do a naive pre-check for OOM.
  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(size);
  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {
    check_non_safepoint_surprise();
  }

  auto arr = DArrayInit(size).toArray();
  reserveForAdd(size);

  for (int64_t i = 0; i < size; i++) {
    Variant key;
    unserializeVariant(key.asTypedValue(), UnserializeMode::Key);
    if (!key.isString() && !key.isInteger()) throwInvalidKey();
    unserializeVariant(MixedArray::LvalInPlace(arr.get(), key));
    if (i < size - 1) checkElemTermination();
  }

  check_non_safepoint_surprise();
  expectChar('}');
  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);
  return arr;
}
