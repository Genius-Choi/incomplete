bool ObjectData::equal(const ObjectData& other) const {
  if (this == &other) return true;
  if (isCollection()) {
    return collections::equals(this, &other);
  }
  if (UNLIKELY(instanceof(SystemLib::s_DateTimeInterfaceClass) &&
               other.instanceof(SystemLib::s_DateTimeInterfaceClass))) {
    return DateTimeData::compare(this, &other) == 0;
  }
  if (getVMClass() != other.getVMClass()) return false;
  if (UNLIKELY(instanceof(SimpleXMLElement_classof()))) {
    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {
      raise_notice("SimpleXMLElement equality comparison");
    }
    // Compare the whole object (including native data), not just props
    auto ar1 = SimpleXMLElement_objectCast(this, KindOfArray).toArray();
    auto ar2 = SimpleXMLElement_objectCast(&other, KindOfArray).toArray();
    return ArrayData::Equal(ar1.get(), ar2.get());
  }
  if (UNLIKELY(instanceof(c_Closure::classof()))) {
    // First comparison already proves they are different
    return false;
  }

  // check for dynamic props first because we need to short-circuit if there's
  // a different number of them
  auto thisSize = UNLIKELY(getAttribute(HasDynPropArr)) ?
    dynPropArray().size() : 0;
  size_t otherSize = 0;
  ArrayData* otherDynProps = nullptr;
  if (UNLIKELY(other.getAttribute(HasDynPropArr))) {
    otherDynProps = other.dynPropArray().get();
    otherSize = otherDynProps->size();
  }
  if (thisSize != otherSize) return false;

  // Prevent circular referenced objects/arrays or deep ones.
  check_recursion_error();

  bool result = true;
  IteratePropMemOrderNoInc(
    this,
    [&](Slot slot, const Class::Prop& prop, tv_rval thisVal) {
      auto otherVal = other.propRvalAtOffset(slot);
      if ((UNLIKELY(thisVal.type() == KindOfUninit) ||
           UNLIKELY(otherVal.type() == KindOfUninit)) &&
          (prop.attrs & AttrLateInit)) {
        throw_late_init_prop(prop.cls, prop.name, false);
      }
      if (!tvEqual(thisVal.tv(), otherVal.tv())) {
        result = false;
        return true;
      }
      return false;
    },
    [&](TypedValue key, TypedValue thisVal) {
      auto const otherVal = otherDynProps->get(key);
      if (!otherVal.is_init() || !tvEqual(thisVal, otherVal)) {
        result = false;
        return true;
      }
      return false;
    }
  );
  return result;
}
