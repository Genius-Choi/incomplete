ObjectData::PropLookup ObjectData::getPropImpl(
  const Class* ctx,
  const StringData* key
) {
  auto const lookup = m_cls->getDeclPropSlot(ctx, key);
  auto const propSlot = lookup.slot;

  if (LIKELY(propSlot != kInvalidSlot)) {
    // We found a visible property, but it might not be accessible.  No need to
    // check if there is a dynamic property with this name.
    auto const propIndex = m_cls->propSlotToIndex(propSlot);
    auto prop = props()->at(propIndex);
    assertx(assertTypeHint(prop, propSlot));

    auto const& declProp = m_cls->declProperties()[propSlot];
    if (!ignoreLateInit && lookup.accessible) {
      if (UNLIKELY(type(prop) == KindOfUninit) &&
          (declProp.attrs & AttrLateInit)) {
        throw_late_init_prop(declProp.cls, key, false);
      }
    }

    return {
     prop,
     &declProp,
     propSlot,
     lookup.accessible,
     // we always return true in the !forWrite case; this way the compiler
     // may optimize away this value, and if a caller intends to write but
     // instantiates with false by mistake it will always see const
     forWrite
       ? bool(declProp.attrs & AttrIsConst)
       : true
    };
  }

  // We could not find a visible declared property. We need to check for a
  // dynamic property with this name.
  if (UNLIKELY(getAttribute(HasDynPropArr))) {
    auto& arr = dynPropArray();
    if (arr->exists(key)) {
      if (forRead && RuntimeOption::EvalNoticeOnReadDynamicProp) {
        raiseReadDynamicProp(key);
      }
      // Returning a non-declared property. We know that it is accessible and
      // not const since all dynamic properties are. If we may write to
      // the property we need to allow the array to escalate.
      auto const lval = arr.lval(StrNR(key), AccessFlags::Key);
      return { lval, nullptr, kInvalidSlot, true, !forWrite };
    }
  }

  return { nullptr, nullptr, kInvalidSlot, false, !forWrite };
}
