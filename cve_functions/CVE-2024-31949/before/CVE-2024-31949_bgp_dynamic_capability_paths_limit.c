static void bgp_dynamic_capability_paths_limit(uint8_t *pnt, int action,
					       struct capability_header *hdr,
					       struct peer *peer)
{
	uint8_t *data = pnt + 3;
	uint8_t *end = data + hdr->length;
	size_t len = end - data;
	afi_t afi;
	safi_t safi;

	if (action == CAPABILITY_ACTION_SET) {
		if (len % CAPABILITY_CODE_PATHS_LIMIT_LEN) {
			flog_warn(EC_BGP_CAPABILITY_INVALID_LENGTH,
				  "Paths-Limit: Received invalid length %zu, non-multiple of %d",
				  len, CAPABILITY_CODE_PATHS_LIMIT_LEN);
			return;
		}

		if (!CHECK_FLAG(peer->cap, PEER_CAP_ADDPATH_RCV)) {
			flog_warn(EC_BGP_CAPABILITY_INVALID_DATA,
				  "Paths-Limit: Received Paths-Limit capability without Add-Path capability");
			goto ignore;
		}

		SET_FLAG(peer->cap, PEER_CAP_PATHS_LIMIT_RCV);

		while (data + CAPABILITY_CODE_PATHS_LIMIT_LEN <= end) {
			afi_t afi;
			safi_t safi;
			iana_afi_t pkt_afi;
			iana_safi_t pkt_safi;
			uint16_t paths_limit = 0;
			struct bgp_paths_limit_capability bpl = {};

			memcpy(&bpl, data, sizeof(bpl));
			pkt_afi = ntohs(bpl.afi);
			pkt_safi = safi_int2iana(bpl.safi);
			paths_limit = ntohs(bpl.paths_limit);

			if (bgp_debug_neighbor_events(peer))
				zlog_debug("%s OPEN has %s capability for afi/safi: %s/%s limit: %u",
					   peer->host,
					   lookup_msg(capcode_str, hdr->code,
						      NULL),
					   iana_afi2str(pkt_afi),
					   iana_safi2str(pkt_safi), paths_limit);

			if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,
						      &safi)) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) not supported. Ignore the Paths-Limit capability for this AFI/SAFI",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
				goto ignore;
			} else if (!peer->afc[afi][safi]) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) not enabled. Ignore the Paths-Limit capability for this AFI/SAFI",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
				goto ignore;
			}

			SET_FLAG(peer->af_cap[afi][safi],
				 PEER_CAP_PATHS_LIMIT_AF_RCV);
			peer->addpath_paths_limit[afi][safi].receive =
				paths_limit;
ignore:
			data += CAPABILITY_CODE_PATHS_LIMIT_LEN;
		}
	} else {
		FOREACH_AFI_SAFI (afi, safi)
			UNSET_FLAG(peer->af_cap[afi][safi],
				   PEER_CAP_PATHS_LIMIT_AF_RCV);

		UNSET_FLAG(peer->cap, PEER_CAP_PATHS_LIMIT_RCV);
	}
}
