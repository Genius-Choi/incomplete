nvkm_uvmm_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,
	      struct nvkm_object **pobject)
{
	struct nvkm_mmu *mmu = nvkm_ummu(oclass->parent)->mmu;
	const bool more = oclass->base.maxver >= 0;
	union {
		struct nvif_vmm_v0 v0;
	} *args = argv;
	const struct nvkm_vmm_page *page;
	struct nvkm_uvmm *uvmm;
	int ret = -ENOSYS;
	u64 addr, size;

	if (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, more))) {
		addr = args->v0.addr;
		size = args->v0.size;
	} else
		return ret;

	if (!(uvmm = kzalloc(sizeof(*uvmm), GFP_KERNEL)))
		return -ENOMEM;
	nvkm_object_ctor(&nvkm_uvmm, oclass, &uvmm->object);
	*pobject = &uvmm->object;

	if (!mmu->vmm) {
		ret = mmu->func->vmm.ctor(mmu, addr, size, argv, argc,
					  NULL, "user", &uvmm->vmm);
		if (ret)
			return ret;

		uvmm->vmm->debug = max(uvmm->vmm->debug, oclass->client->debug);
	} else {
		if (size)
			return -EINVAL;

		uvmm->vmm = nvkm_vmm_ref(mmu->vmm);
	}

	page = uvmm->vmm->func->page;
	args->v0.page_nr = 0;
	while (page && (page++)->shift)
		args->v0.page_nr++;
	args->v0.addr = uvmm->vmm->start;
	args->v0.size = uvmm->vmm->limit;
	return 0;
}
