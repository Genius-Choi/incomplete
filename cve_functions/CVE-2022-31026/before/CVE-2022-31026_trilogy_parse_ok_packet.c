int trilogy_parse_ok_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_ok_packet_t *out_packet)
{
    int rc;

    trilogy_reader_t reader = TRILOGY_READER(buff, len);

    // skip packet type
    CHECKED(trilogy_reader_get_uint8(&reader, NULL));

    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->affected_rows));

    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->last_insert_id));

    out_packet->status_flags = 0;
    out_packet->warning_count = 0;
    out_packet->txn_status_flags = 0;
    out_packet->session_status = NULL;
    out_packet->session_status_len = 0;
    out_packet->session_state_changes = NULL;
    out_packet->session_state_changes_len = 0;
    out_packet->info = NULL;
    out_packet->info_len = 0;
    out_packet->last_gtid_len = 0;

    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {
        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->status_flags));
        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->warning_count));
    } else if (capabilities & TRILOGY_CAPABILITIES_TRANSACTIONS) {
        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->txn_status_flags));
    }

    if (capabilities & TRILOGY_CAPABILITIES_SESSION_TRACK && !trilogy_reader_eof(&reader)) {
        CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->session_status_len,
                                                 (const void **)&out_packet->session_status));

        if (out_packet->status_flags & TRILOGY_SERVER_STATUS_SESSION_STATE_CHANGED) {
            CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->session_state_changes_len,
                                                     (const void **)&out_packet->session_state_changes));

            TRILOGY_SESSION_TRACK_TYPE_t type = 0;
            const char *state_info = NULL;
            size_t state_info_len = 0;

            trilogy_reader_t state_reader = TRILOGY_READER((const uint8_t *)out_packet->session_state_changes,
                                                           out_packet->session_state_changes_len);

            while (!trilogy_reader_eof(&state_reader)) {
                CHECKED(trilogy_reader_get_uint8(&state_reader, (uint8_t *)&type));
                CHECKED(trilogy_reader_get_lenenc_buffer(&state_reader, &state_info_len, (const void **)&state_info));

                switch (type) {
                case TRILOGY_SESSION_TRACK_GTIDS: {
                    trilogy_reader_t gtid_reader = TRILOGY_READER((const uint8_t *)state_info, state_info_len);
                    // There's a type with value TRILOGY_SESSION_TRACK_GTIDS tag
                    // at the beginning here we can ignore since we already had
                    // the type one level higher as well.
                    CHECKED(trilogy_reader_get_uint8(&gtid_reader, NULL));
                    CHECKED(trilogy_reader_get_lenenc_buffer(&gtid_reader, &out_packet->last_gtid_len,
                                                             (const void **)&out_packet->last_gtid));
                    if (out_packet->last_gtid_len > TRILOGY_MAX_LAST_GTID_LEN) {
                        return TRILOGY_PROTOCOL_VIOLATION;
                    }
                    break;
                }
                default:
                    break;
                }
            }
        }
    } else {
        CHECKED(trilogy_reader_get_eof_buffer(&reader, &out_packet->info_len, (const void **)&out_packet->info));
    }

    return trilogy_reader_finish(&reader);

fail:
    return rc;
}
