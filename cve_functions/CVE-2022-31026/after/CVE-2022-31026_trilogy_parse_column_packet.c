int trilogy_parse_column_packet(const uint8_t *buff, size_t len, bool field_list, trilogy_column_packet_t *out_packet)
{
    int rc;

    trilogy_reader_t reader = TRILOGY_READER(buff, len);

    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->catalog_len, (const void **)&out_packet->catalog));

    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->schema_len, (const void **)&out_packet->schema));

    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->table_len, (const void **)&out_packet->table));

    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->original_table_len,
                                             (const void **)&out_packet->original_table));

    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->name_len, (const void **)&out_packet->name));

    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->original_name_len,
                                             (const void **)&out_packet->original_name));

    // skip length of fixed length field until we have something to use it for
    CHECKED(trilogy_reader_get_lenenc(&reader, NULL));

    uint16_t charset;
    CHECKED(trilogy_reader_get_uint16(&reader, &charset));

    out_packet->charset = charset;

    CHECKED(trilogy_reader_get_uint32(&reader, &out_packet->len));

    uint8_t type;
    CHECKED(trilogy_reader_get_uint8(&reader, &type));
    out_packet->type = type;

    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->flags));

    CHECKED(trilogy_reader_get_uint8(&reader, &out_packet->decimals));

    // skip NULL filler
    CHECKED(trilogy_reader_get_uint16(&reader, NULL));

    out_packet->default_value_len = 0;

    if (field_list) {
        CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->default_value_len,
                                                 (const void **)&out_packet->default_value));
    }

    return trilogy_reader_finish(&reader);

fail:
    return rc;
}
