static void set_mb_wiener_variance(VP9_COMP *cpi) {
  VP9_COMMON *cm = &cpi->common;
  uint8_t *buffer = cpi->Source->y_buffer;
  int buf_stride = cpi->Source->y_stride;

#if CONFIG_VP9_HIGHBITDEPTH
  ThreadData *td = &cpi->td;
  MACROBLOCK *x = &td->mb;
  MACROBLOCKD *xd = &x->e_mbd;
  DECLARE_ALIGNED(16, uint16_t, zero_pred16[32 * 32]);
  DECLARE_ALIGNED(16, uint8_t, zero_pred8[32 * 32]);
  uint8_t *zero_pred;
#else
  DECLARE_ALIGNED(16, uint8_t, zero_pred[32 * 32]);
#endif

  DECLARE_ALIGNED(16, int16_t, src_diff[32 * 32]);
  DECLARE_ALIGNED(16, tran_low_t, coeff[32 * 32]);

  int mb_row, mb_col, count = 0;
  // Hard coded operating block size
  const int block_size = 16;
  const int coeff_count = block_size * block_size;
  const TX_SIZE tx_size = TX_16X16;

#if CONFIG_VP9_HIGHBITDEPTH
  xd->cur_buf = cpi->Source;
  if (xd->cur_buf->flags & YV12_FLAG_HIGHBITDEPTH) {
    zero_pred = CONVERT_TO_BYTEPTR(zero_pred16);
    memset(zero_pred16, 0, sizeof(*zero_pred16) * coeff_count);
  } else {
    zero_pred = zero_pred8;
    memset(zero_pred8, 0, sizeof(*zero_pred8) * coeff_count);
  }
#else
  memset(zero_pred, 0, sizeof(*zero_pred) * coeff_count);
#endif

  cpi->norm_wiener_variance = 0;

  for (mb_row = 0; mb_row < cm->mb_rows; ++mb_row) {
    for (mb_col = 0; mb_col < cm->mb_cols; ++mb_col) {
      int idx;
      int16_t median_val = 0;
      uint8_t *mb_buffer =
          buffer + mb_row * block_size * buf_stride + mb_col * block_size;
      int64_t wiener_variance = 0;

#if CONFIG_VP9_HIGHBITDEPTH
      if (xd->cur_buf->flags & YV12_FLAG_HIGHBITDEPTH) {
        vpx_highbd_subtract_block(block_size, block_size, src_diff, block_size,
                                  mb_buffer, buf_stride, zero_pred, block_size,
                                  xd->bd);
        vp9_highbd_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);
      } else {
        vpx_subtract_block(block_size, block_size, src_diff, block_size,
                           mb_buffer, buf_stride, zero_pred, block_size);
        vp9_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);
      }
#else
      vpx_subtract_block(block_size, block_size, src_diff, block_size,
                         mb_buffer, buf_stride, zero_pred, block_size);
      vp9_wht_fwd_txfm(src_diff, block_size, coeff, tx_size);
#endif  // CONFIG_VP9_HIGHBITDEPTH

      coeff[0] = 0;
      for (idx = 1; idx < coeff_count; ++idx) coeff[idx] = abs(coeff[idx]);

      qsort(coeff, coeff_count - 1, sizeof(*coeff), qsort_comp);

      // Noise level estimation
      median_val = coeff[coeff_count / 2];

      // Wiener filter
      for (idx = 1; idx < coeff_count; ++idx) {
        int64_t sqr_coeff = (int64_t)coeff[idx] * coeff[idx];
        int64_t tmp_coeff = (int64_t)coeff[idx];
        if (median_val) {
          tmp_coeff = (sqr_coeff * coeff[idx]) /
                      (sqr_coeff + (int64_t)median_val * median_val);
        }
        wiener_variance += tmp_coeff * tmp_coeff;
      }
      cpi->mb_wiener_variance[mb_row * cm->mb_cols + mb_col] =
          wiener_variance / coeff_count;
      cpi->norm_wiener_variance +=
          cpi->mb_wiener_variance[mb_row * cm->mb_cols + mb_col];
      ++count;
    }
  }

  if (count) cpi->norm_wiener_variance /= count;
  cpi->norm_wiener_variance = VPXMAX(1, cpi->norm_wiener_variance);
}
