static void setup_frame(VP9_COMP *cpi) {
  VP9_COMMON *const cm = &cpi->common;
  // Set up entropy context depending on frame type. The decoder mandates
  // the use of the default context, index 0, for keyframes and inter
  // frames where the error_resilient_mode or intra_only flag is set. For
  // other inter-frames the encoder currently uses only two contexts;
  // context 1 for ALTREF frames and context 0 for the others.
  if (frame_is_intra_only(cm) || cm->error_resilient_mode) {
    vp9_setup_past_independence(cm);
  } else {
    if (!cpi->use_svc) cm->frame_context_idx = cpi->refresh_alt_ref_frame;
  }

  // TODO(jingning): Overwrite the frame_context_idx index in multi-layer ARF
  // case. Need some further investigation on if we could apply this to single
  // layer ARF case as well.
  if (cpi->multi_layer_arf && !cpi->use_svc) {
    GF_GROUP *const gf_group = &cpi->twopass.gf_group;
    const int gf_group_index = gf_group->index;
    const int boost_frame =
        !cpi->rc.is_src_frame_alt_ref &&
        (cpi->refresh_golden_frame || cpi->refresh_alt_ref_frame);

    // frame_context_idx           Frame Type
    //        0              Intra only frame, base layer ARF
    //        1              ARFs with layer depth = 2,3
    //        2              ARFs with layer depth > 3
    //        3              Non-boosted frames
    if (frame_is_intra_only(cm)) {
      cm->frame_context_idx = 0;
    } else if (boost_frame) {
      if (gf_group->rf_level[gf_group_index] == GF_ARF_STD)
        cm->frame_context_idx = 0;
      else if (gf_group->layer_depth[gf_group_index] <= 3)
        cm->frame_context_idx = 1;
      else
        cm->frame_context_idx = 2;
    } else {
      cm->frame_context_idx = 3;
    }
  }

  if (cm->frame_type == KEY_FRAME) {
    cpi->refresh_golden_frame = 1;
    cpi->refresh_alt_ref_frame = 1;
    vp9_zero(cpi->interp_filter_selected);
  } else {
    *cm->fc = cm->frame_contexts[cm->frame_context_idx];
    vp9_zero(cpi->interp_filter_selected[0]);
  }
}
