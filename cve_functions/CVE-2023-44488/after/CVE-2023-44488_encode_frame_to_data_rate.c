static void encode_frame_to_data_rate(
    VP9_COMP *cpi, size_t *size, uint8_t *dest, unsigned int *frame_flags,
    ENCODE_FRAME_RESULT *encode_frame_result) {
  VP9_COMMON *const cm = &cpi->common;
  const VP9EncoderConfig *const oxcf = &cpi->oxcf;
  struct segmentation *const seg = &cm->seg;
  TX_SIZE t;

  // SVC: skip encoding of enhancement layer if the layer target bandwidth = 0.
  // No need to set svc.skip_enhancement_layer if whole superframe will be
  // dropped.
  if (cpi->use_svc && cpi->svc.spatial_layer_id > 0 &&
      cpi->oxcf.target_bandwidth == 0 &&
      !(cpi->svc.framedrop_mode != LAYER_DROP &&
        (cpi->svc.framedrop_mode != CONSTRAINED_FROM_ABOVE_DROP ||
         cpi->svc
             .force_drop_constrained_from_above[cpi->svc.number_spatial_layers -
                                                1]) &&
        cpi->svc.drop_spatial_layer[0])) {
    cpi->svc.skip_enhancement_layer = 1;
    vp9_rc_postencode_update_drop_frame(cpi);
    cpi->ext_refresh_frame_flags_pending = 0;
    cpi->last_frame_dropped = 1;
    cpi->svc.last_layer_dropped[cpi->svc.spatial_layer_id] = 1;
    cpi->svc.drop_spatial_layer[cpi->svc.spatial_layer_id] = 1;
    vp9_inc_frame_in_layer(cpi);
    return;
  }

  set_ext_overrides(cpi);
  vpx_clear_system_state();

#ifdef ENABLE_KF_DENOISE
  // Spatial denoise of key frame.
  if (is_spatial_denoise_enabled(cpi)) spatial_denoise_frame(cpi);
#endif

  if (cm->show_existing_frame == 0) {
    // Update frame index
    set_frame_index(cpi, cm);

    // Set the arf sign bias for this frame.
    set_ref_sign_bias(cpi);
  }

  // Set default state for segment based loop filter update flags.
  cm->lf.mode_ref_delta_update = 0;

  if (cpi->oxcf.pass == 2 && cpi->sf.adaptive_interp_filter_search)
    cpi->sf.interp_filter_search_mask = setup_interp_filter_search_mask(cpi);

  // Set various flags etc to special state if it is a key frame.
  if (frame_is_intra_only(cm)) {
    // Reset the loop filter deltas and segmentation map.
    vp9_reset_segment_features(&cm->seg);

    // If segmentation is enabled force a map update for key frames.
    if (seg->enabled) {
      seg->update_map = 1;
      seg->update_data = 1;
    }

    // The alternate reference frame cannot be active for a key frame.
    cpi->rc.source_alt_ref_active = 0;

    cm->error_resilient_mode = oxcf->error_resilient_mode;
    cm->frame_parallel_decoding_mode = oxcf->frame_parallel_decoding_mode;

    // By default, encoder assumes decoder can use prev_mi.
    if (cm->error_resilient_mode) {
      cm->frame_parallel_decoding_mode = 1;
      cm->reset_frame_context = 0;
      cm->refresh_frame_context = 0;
    } else if (cm->intra_only) {
      // Only reset the current context.
      cm->reset_frame_context = 2;
    }
  }

  if (oxcf->tuning == VP8_TUNE_SSIM) set_mb_ssim_rdmult_scaling(cpi);

  if (oxcf->aq_mode == PERCEPTUAL_AQ) {
    init_mb_wiener_var_buffer(cpi);
    set_mb_wiener_variance(cpi);
  }

  vpx_clear_system_state();

#if CONFIG_INTERNAL_STATS
  memset(cpi->mode_chosen_counts, 0,
         MAX_MODES * sizeof(*cpi->mode_chosen_counts));
#endif
  // Backup to ensure consistency between recodes
  save_encode_params(cpi);
  if (cpi->ext_ratectrl.ready &&
      (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_RDMULT) != 0 &&
      cpi->ext_ratectrl.funcs.get_frame_rdmult != NULL) {
    vpx_codec_err_t codec_status;
    const GF_GROUP *gf_group = &cpi->twopass.gf_group;
    FRAME_UPDATE_TYPE update_type = gf_group->update_type[gf_group->index];
    const int ref_frame_flags = get_ref_frame_flags(cpi);
    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];
    const RefCntBuffer *curr_frame_buf = get_ref_cnt_buffer(cm, cm->new_fb_idx);
    // index 0 of a gf group is always KEY/OVERLAY/GOLDEN.
    // index 1 refers to the first encoding frame in a gf group.
    // Therefore if it is ARF_UPDATE, it means this gf group uses alt ref.
    // See function define_gf_group_structure().
    const int use_alt_ref = gf_group->update_type[1] == ARF_UPDATE;
    int ext_rdmult = VPX_DEFAULT_RDMULT;
    get_ref_frame_bufs(cpi, ref_frame_bufs);
    codec_status = vp9_extrc_get_frame_rdmult(
        &cpi->ext_ratectrl, curr_frame_buf->frame_index,
        cm->current_frame_coding_index, gf_group->index, update_type,
        gf_group->gf_group_size, use_alt_ref, ref_frame_bufs, ref_frame_flags,
        &ext_rdmult);
    if (codec_status != VPX_CODEC_OK) {
      vpx_internal_error(&cm->error, codec_status,
                         "vp9_extrc_get_frame_rdmult() failed");
    }
    cpi->ext_ratectrl.ext_rdmult = ext_rdmult;
  }

  if (cpi->sf.recode_loop == DISALLOW_RECODE) {
    if (!encode_without_recode_loop(cpi, size, dest)) return;
  } else {
#if !CONFIG_REALTIME_ONLY
#if CONFIG_RATE_CTRL
    encode_with_recode_loop(cpi, size, dest, &encode_frame_result->rq_history);
#else  // CONFIG_RATE_CTRL
#if CONFIG_COLLECT_COMPONENT_TIMING
    start_timing(cpi, encode_with_recode_loop_time);
#endif
    encode_with_recode_loop(cpi, size, dest);
#if CONFIG_COLLECT_COMPONENT_TIMING
    end_timing(cpi, encode_with_recode_loop_time);
#endif
#endif  // CONFIG_RATE_CTRL
#endif  // !CONFIG_REALTIME_ONLY
  }

  // TODO(jingning): When using show existing frame mode, we assume that the
  // current ARF will be directly used as the final reconstructed frame. This is
  // an encoder control scheme. One could in principle explore other
  // possibilities to arrange the reference frame buffer and their coding order.
  if (cm->show_existing_frame) {
    ref_cnt_fb(cm->buffer_pool->frame_bufs, &cm->new_fb_idx,
               cm->ref_frame_map[cpi->alt_fb_idx]);
  }

#if !CONFIG_REALTIME_ONLY
  // Disable segmentation if it decrease rate/distortion ratio
  if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ)
    vp9_try_disable_lookahead_aq(cpi, size, dest);
#endif

#if CONFIG_VP9_TEMPORAL_DENOISING
#ifdef OUTPUT_YUV_DENOISED
  if (oxcf->noise_sensitivity > 0 && denoise_svc(cpi)) {
    vpx_write_yuv_frame(yuv_denoised_file,
                        &cpi->denoiser.running_avg_y[INTRA_FRAME]);
  }
#endif
#endif
#ifdef OUTPUT_YUV_SKINMAP
  if (cpi->common.current_video_frame > 1) {
    vp9_output_skin_map(cpi, yuv_skinmap_file);
  }
#endif

  // Special case code to reduce pulsing when key frames are forced at a
  // fixed interval. Note the reconstruction error if it is the frame before
  // the force key frame
  if (cpi->rc.next_key_frame_forced && cpi->rc.frames_to_key == 1) {
#if CONFIG_VP9_HIGHBITDEPTH
    if (cm->use_highbitdepth) {
      cpi->ambient_err =
          vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));
    } else {
      cpi->ambient_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));
    }
#else
    cpi->ambient_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));
#endif  // CONFIG_VP9_HIGHBITDEPTH
  }

  // If the encoder forced a KEY_FRAME decision
  if (cm->frame_type == KEY_FRAME) cpi->refresh_last_frame = 1;

  cm->frame_to_show = get_frame_new_buffer(cm);
  cm->frame_to_show->color_space = cm->color_space;
  cm->frame_to_show->color_range = cm->color_range;
  cm->frame_to_show->render_width = cm->render_width;
  cm->frame_to_show->render_height = cm->render_height;

#if CONFIG_COLLECT_COMPONENT_TIMING
  start_timing(cpi, loopfilter_frame_time);
#endif
  // Pick the loop filter level for the frame.
  loopfilter_frame(cpi, cm);
#if CONFIG_COLLECT_COMPONENT_TIMING
  end_timing(cpi, loopfilter_frame_time);
#endif

  if (cpi->rc.use_post_encode_drop) save_coding_context(cpi);

#if CONFIG_COLLECT_COMPONENT_TIMING
  start_timing(cpi, vp9_pack_bitstream_time);
#endif
  // build the bitstream
  vp9_pack_bitstream(cpi, dest, size);
#if CONFIG_COLLECT_COMPONENT_TIMING
  end_timing(cpi, vp9_pack_bitstream_time);
#endif

  if (cpi->ext_ratectrl.ready &&
      cpi->ext_ratectrl.funcs.update_encodeframe_result != NULL) {
    const RefCntBuffer *coded_frame_buf =
        get_ref_cnt_buffer(cm, cm->new_fb_idx);
    vpx_codec_err_t codec_status = vp9_extrc_update_encodeframe_result(
        &cpi->ext_ratectrl, (*size) << 3, cpi->Source, &coded_frame_buf->buf,
        cm->bit_depth, cpi->oxcf.input_bit_depth, cm->base_qindex);
    if (codec_status != VPX_CODEC_OK) {
      vpx_internal_error(&cm->error, codec_status,
                         "vp9_extrc_update_encodeframe_result() failed");
    }
  }
#if CONFIG_REALTIME_ONLY
  (void)encode_frame_result;
  assert(encode_frame_result == NULL);
#else  // CONFIG_REALTIME_ONLY
  if (encode_frame_result != NULL) {
    const RefCntBuffer *coded_frame_buf =
        get_ref_cnt_buffer(cm, cm->new_fb_idx);
    RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];
    FRAME_UPDATE_TYPE update_type =
        cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index];
    int quantize_index = vp9_get_quantizer(cpi);
    get_ref_frame_bufs(cpi, ref_frame_bufs);
    // update_encode_frame_result() depends on twopass.gf_group.index and
    // cm->new_fb_idx, cpi->Source, cpi->lst_fb_idx, cpi->gld_fb_idx and
    // cpi->alt_fb_idx are updated for current frame and have
    // not been updated for the next frame yet.
    // The update locations are as follows.
    // 1) twopass.gf_group.index is initialized at define_gf_group by vp9_zero()
    // for the first frame in the gf_group and is updated for the next frame at
    // vp9_twopass_postencode_update().
    // 2) cpi->Source is updated at the beginning of vp9_get_compressed_data()
    // 3) cm->new_fb_idx is updated at the beginning of
    // vp9_get_compressed_data() by get_free_fb(cm).
    // 4) cpi->lst_fb_idx/gld_fb_idx/alt_fb_idx will be updated for the next
    // frame at vp9_update_reference_frames().
    // This function needs to be called before vp9_update_reference_frames().
    // TODO(angiebird): Improve the codebase to make the update of frame
    // dependent variables more robust.

    update_encode_frame_result_basic(update_type, coded_frame_buf->frame_index,
                                     quantize_index, encode_frame_result);
#if CONFIG_RATE_CTRL
    if (cpi->oxcf.use_simple_encode_api) {
      const int ref_frame_flags = get_ref_frame_flags(cpi);
      update_encode_frame_result_simple_encode(
          ref_frame_flags,
          cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index],
          cpi->Source, coded_frame_buf, ref_frame_bufs, quantize_index,
          cm->bit_depth, cpi->oxcf.input_bit_depth, cpi->td.counts,
          cpi->partition_info, cpi->motion_vector_info, cpi->tpl_stats_info,
          encode_frame_result);
    }
#endif  // CONFIG_RATE_CTRL
  }
#endif  // CONFIG_REALTIME_ONLY

  if (cpi->rc.use_post_encode_drop && cm->base_qindex < cpi->rc.worst_quality &&
      cpi->svc.spatial_layer_id == 0 && post_encode_drop_cbr(cpi, size)) {
    restore_coding_context(cpi);
    return;
  }

  cpi->last_frame_dropped = 0;
  cpi->svc.last_layer_dropped[cpi->svc.spatial_layer_id] = 0;
  if (cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1)
    cpi->svc.num_encoded_top_layer++;

  // Keep track of the frame buffer index updated/refreshed for the
  // current encoded TL0 superframe.
  if (cpi->svc.temporal_layer_id == 0) {
    if (cpi->refresh_last_frame)
      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->lst_fb_idx;
    else if (cpi->refresh_golden_frame)
      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->gld_fb_idx;
    else if (cpi->refresh_alt_ref_frame)
      cpi->svc.fb_idx_upd_tl0[cpi->svc.spatial_layer_id] = cpi->alt_fb_idx;
  }

  if (cm->seg.update_map) update_reference_segmentation_map(cpi);

  if (frame_is_intra_only(cm) == 0) {
    release_scaled_references(cpi);
  }
  vp9_update_reference_frames(cpi);

  if (!cm->show_existing_frame) {
    for (t = TX_4X4; t <= TX_32X32; ++t) {
      full_to_model_counts(cpi->td.counts->coef[t],
                           cpi->td.rd_counts.coef_counts[t]);
    }

    if (!cm->error_resilient_mode && !cm->frame_parallel_decoding_mode) {
      if (!frame_is_intra_only(cm)) {
        vp9_adapt_mode_probs(cm);
        vp9_adapt_mv_probs(cm, cm->allow_high_precision_mv);
      }
      vp9_adapt_coef_probs(cm);
    }
  }

  cpi->ext_refresh_frame_flags_pending = 0;

  if (cpi->refresh_golden_frame == 1)
    cpi->frame_flags |= FRAMEFLAGS_GOLDEN;
  else
    cpi->frame_flags &= ~FRAMEFLAGS_GOLDEN;

  if (cpi->refresh_alt_ref_frame == 1)
    cpi->frame_flags |= FRAMEFLAGS_ALTREF;
  else
    cpi->frame_flags &= ~FRAMEFLAGS_ALTREF;

  cpi->ref_frame_flags = get_ref_frame_flags(cpi);

  cm->last_frame_type = cm->frame_type;

  vp9_rc_postencode_update(cpi, *size);

  if (cpi->compute_frame_low_motion_onepass && oxcf->pass == 0 &&
      !frame_is_intra_only(cm) &&
      (!cpi->use_svc ||
       (cpi->use_svc &&
        !cpi->svc.layer_context[cpi->svc.temporal_layer_id].is_key_frame &&
        cpi->svc.spatial_layer_id == cpi->svc.number_spatial_layers - 1))) {
    vp9_compute_frame_low_motion(cpi);
  }

  *size = VPXMAX(1, *size);

#if 0
  output_frame_level_debug_stats(cpi);
#endif

  if (cm->frame_type == KEY_FRAME) {
    // Tell the caller that the frame was coded as a key frame
    *frame_flags = cpi->frame_flags | FRAMEFLAGS_KEY;
  } else {
    *frame_flags = cpi->frame_flags & ~FRAMEFLAGS_KEY;
  }

  // Clear the one shot update flags for segmentation map and mode/ref loop
  // filter deltas.
  cm->seg.update_map = 0;
  cm->seg.update_data = 0;
  cm->lf.mode_ref_delta_update = 0;

  // keep track of the last coded dimensions
  cm->last_width = cm->width;
  cm->last_height = cm->height;

  // reset to normal state now that we are done.
  if (!cm->show_existing_frame) {
    cm->last_show_frame = cm->show_frame;
    cm->prev_frame = cm->cur_frame;
  }

  if (cm->show_frame) {
    vp9_swap_mi_and_prev_mi(cm);
    if (cpi->use_svc) vp9_inc_frame_in_layer(cpi);
  }
  update_frame_indexes(cm, cm->show_frame);

  if (cpi->use_svc) {
    cpi->svc
        .layer_context[cpi->svc.spatial_layer_id *
                           cpi->svc.number_temporal_layers +
                       cpi->svc.temporal_layer_id]
        .last_frame_type = cm->frame_type;
    // Reset layer_sync back to 0 for next frame.
    cpi->svc.spatial_layer_sync[cpi->svc.spatial_layer_id] = 0;
  }

  cpi->force_update_segmentation = 0;

#if !CONFIG_REALTIME_ONLY
  if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ)
    vp9_alt_ref_aq_unset_all(cpi->alt_ref_aq, cpi);
#endif

  cpi->svc.previous_frame_is_intra_only = cm->intra_only;
  cpi->svc.set_intra_only_frame = 0;
}
