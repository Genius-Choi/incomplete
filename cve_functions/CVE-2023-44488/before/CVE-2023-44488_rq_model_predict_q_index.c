static int rq_model_predict_q_index(const RATE_QSTEP_MODEL *rq_model,
                                    const RATE_QINDEX_HISTORY *rq_history,
                                    int target_bits) {
  int q_index = 128;
  if (rq_history->recode_count > 0) {
    const int actual_bits =
        rq_history->rate_history[rq_history->recode_count - 1];
    const int prev_q_index =
        rq_history->q_index_history[rq_history->recode_count - 1];
    const double percent_diff = get_bits_percent_diff(target_bits, actual_bits);
    if (percent_diff > 50) {
      // Binary search.
      // When the actual_bits and target_bits are far apart, binary search
      // q_index is faster.
      q_index = (rq_history->q_index_low + rq_history->q_index_high) / 2;
    } else {
      if (rq_model->ready) {
        q_index = guess_q_index_from_model(rq_model, target_bits);
      } else {
        // TODO(angiebird): Find a better way to set the gap.
        q_index =
            guess_q_index_linear(prev_q_index, target_bits, actual_bits, 20);
      }
    }
  } else {
    if (rq_model->ready) {
      q_index = guess_q_index_from_model(rq_model, target_bits);
    }
  }

  assert(rq_history->q_index_low <= rq_history->q_index_high);
  if (q_index <= rq_history->q_index_low) {
    q_index = rq_history->q_index_low + 1;
  }
  if (q_index >= rq_history->q_index_high) {
    q_index = rq_history->q_index_high - 1;
  }
  return q_index;
}
