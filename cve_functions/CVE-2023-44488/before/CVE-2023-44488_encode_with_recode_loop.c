static void encode_with_recode_loop(VP9_COMP *cpi, size_t *size, uint8_t *dest
#if CONFIG_RATE_CTRL
                                    ,
                                    RATE_QINDEX_HISTORY *rq_history
#endif  // CONFIG_RATE_CTRL
) {
  const VP9EncoderConfig *const oxcf = &cpi->oxcf;
  VP9_COMMON *const cm = &cpi->common;
  RATE_CONTROL *const rc = &cpi->rc;
  int bottom_index, top_index;
  int loop_count = 0;
  int loop_at_this_size = 0;
  int loop = 0;
  int overshoot_seen = 0;
  int undershoot_seen = 0;
  int frame_over_shoot_limit;
  int frame_under_shoot_limit;
  int q = 0, q_low = 0, q_high = 0;
  int enable_acl;
#ifdef AGGRESSIVE_VBR
  int qrange_adj = 1;
#endif

  // A flag which indicates whether we are recoding the current frame
  // when the current frame size is larger than the max frame size in the
  // external rate control model.
  // This flag doesn't have any impact when external rate control is not used.
  int ext_rc_recode = 0;
  // Maximal frame size allowed by the external rate control.
  // case: 0, we ignore the max frame size limit, and encode with the qindex
  // passed in by the external rate control model.
  // If the external qindex is VPX_DEFAULT_Q, libvpx will pick a qindex
  // and may recode if undershoot/overshoot is seen.
  // If the external qindex is not VPX_DEFAULT_Q, we force no recode.
  // case: -1, we take libvpx's decision for the max frame size, as well as
  // the recode decision.
  // Otherwise: if a specific size is given, libvpx's recode decision
  // will respect the given size.
  int ext_rc_max_frame_size = 0;
  // Use VP9's decision of qindex. This flag is in use only in external rate
  // control model to help determine whether to recode when
  // |ext_rc_max_frame_size| is 0.
  int ext_rc_use_default_q = 1;
  const int orig_rc_max_frame_bandwidth = rc->max_frame_bandwidth;

#if CONFIG_RATE_CTRL
  RATE_QSTEP_MODEL *rq_model;
  {
    const FRAME_UPDATE_TYPE update_type =
        cpi->twopass.gf_group.update_type[cpi->twopass.gf_group.index];
    const ENCODE_FRAME_TYPE frame_type = get_encode_frame_type(update_type);
    rq_model = &cpi->rq_model[frame_type];
  }
  init_rq_history(rq_history);
#endif  // CONFIG_RATE_CTRL

  if (cm->show_existing_frame) {
    rc->this_frame_target = 0;
    if (is_psnr_calc_enabled(cpi)) set_raw_source_frame(cpi);
    return;
  }

  set_size_independent_vars(cpi);

  enable_acl = cpi->sf.allow_acl ? (cm->frame_type == KEY_FRAME) ||
                                       (cpi->twopass.gf_group.index == 1)
                                 : 0;

#if CONFIG_COLLECT_COMPONENT_TIMING
  printf("\n Encoding a frame: \n");
#endif
  do {
    vpx_clear_system_state();

    set_frame_size(cpi);

    if (loop_count == 0 || cpi->resize_pending != 0) {
      set_size_dependent_vars(cpi, &q, &bottom_index, &top_index);

#ifdef AGGRESSIVE_VBR
      if (two_pass_first_group_inter(cpi)) {
        // Adjustment limits for min and max q
        qrange_adj = VPXMAX(1, (top_index - bottom_index) / 2);

        bottom_index =
            VPXMAX(bottom_index - qrange_adj / 2, oxcf->best_allowed_q);
        top_index = VPXMIN(oxcf->worst_allowed_q, top_index + qrange_adj / 2);
      }
#endif
      // TODO(agrange) Scale cpi->max_mv_magnitude if frame-size has changed.
      set_mv_search_params(cpi);

      // Reset the loop state for new frame size.
      overshoot_seen = 0;
      undershoot_seen = 0;

      // Reconfiguration for change in frame size has concluded.
      cpi->resize_pending = 0;

      q_low = bottom_index;
      q_high = top_index;

      loop_at_this_size = 0;
    }

    // Decide frame size bounds first time through.
    if (loop_count == 0) {
      vp9_rc_compute_frame_size_bounds(cpi, rc->this_frame_target,
                                       &frame_under_shoot_limit,
                                       &frame_over_shoot_limit);
    }

    cpi->Source =
        vp9_scale_if_required(cm, cpi->un_scaled_source, &cpi->scaled_source,
                              (oxcf->pass == 0), EIGHTTAP, 0);

    // Unfiltered raw source used in metrics calculation if the source
    // has been filtered.
    if (is_psnr_calc_enabled(cpi)) {
#ifdef ENABLE_KF_DENOISE
      if (is_spatial_denoise_enabled(cpi)) {
        cpi->raw_source_frame = vp9_scale_if_required(
            cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,
            (oxcf->pass == 0), EIGHTTAP, 0);
      } else {
        cpi->raw_source_frame = cpi->Source;
      }
#else
      cpi->raw_source_frame = cpi->Source;
#endif
    }

    if (cpi->unscaled_last_source != NULL)
      cpi->Last_Source = vp9_scale_if_required(cm, cpi->unscaled_last_source,
                                               &cpi->scaled_last_source,
                                               (oxcf->pass == 0), EIGHTTAP, 0);

    if (frame_is_intra_only(cm) == 0) {
      if (loop_count > 0) {
        release_scaled_references(cpi);
      }
      vp9_scale_references(cpi);
    }

#if CONFIG_RATE_CTRL
    // TODO(angiebird): This is a hack for making sure the encoder use the
    // external_quantize_index exactly. Avoid this kind of hack later.
    if (cpi->oxcf.use_simple_encode_api) {
      if (cpi->encode_command.use_external_target_frame_bits) {
        q = rq_model_predict_q_index(rq_model, rq_history,
                                     rc->this_frame_target);
      }
      if (cpi->encode_command.use_external_quantize_index) {
        q = cpi->encode_command.external_quantize_index;
      }
    }
#endif  // CONFIG_RATE_CTRL
    if (cpi->ext_ratectrl.ready && !ext_rc_recode &&
        (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_QP) != 0 &&
        cpi->ext_ratectrl.funcs.get_encodeframe_decision != NULL) {
      vpx_codec_err_t codec_status;
      const GF_GROUP *gf_group = &cpi->twopass.gf_group;
      vpx_rc_encodeframe_decision_t encode_frame_decision;
      FRAME_UPDATE_TYPE update_type = gf_group->update_type[gf_group->index];
      const int ref_frame_flags = get_ref_frame_flags(cpi);
      RefCntBuffer *ref_frame_bufs[MAX_INTER_REF_FRAMES];
      const RefCntBuffer *curr_frame_buf =
          get_ref_cnt_buffer(cm, cm->new_fb_idx);
      // index 0 of a gf group is always KEY/OVERLAY/GOLDEN.
      // index 1 refers to the first encoding frame in a gf group.
      // Therefore if it is ARF_UPDATE, it means this gf group uses alt ref.
      // See function define_gf_group_structure().
      const int use_alt_ref = gf_group->update_type[1] == ARF_UPDATE;
      get_ref_frame_bufs(cpi, ref_frame_bufs);
      codec_status = vp9_extrc_get_encodeframe_decision(
          &cpi->ext_ratectrl, curr_frame_buf->frame_index,
          cm->current_frame_coding_index, gf_group->index, update_type,
          gf_group->gf_group_size, use_alt_ref, ref_frame_bufs, ref_frame_flags,
          &encode_frame_decision);
      if (codec_status != VPX_CODEC_OK) {
        vpx_internal_error(&cm->error, codec_status,
                           "vp9_extrc_get_encodeframe_decision() failed");
      }
      // If the external model recommends a reserved value, we use
      // libvpx's default q.
      if (encode_frame_decision.q_index != VPX_DEFAULT_Q) {
        q = encode_frame_decision.q_index;
        ext_rc_use_default_q = 0;
      }
      ext_rc_max_frame_size = encode_frame_decision.max_frame_size;
    }

    vp9_set_quantizer(cpi, q);

    if (loop_count == 0) setup_frame(cpi);

    // Variance adaptive and in frame q adjustment experiments are mutually
    // exclusive.
    if (oxcf->aq_mode == VARIANCE_AQ) {
      vp9_vaq_frame_setup(cpi);
    } else if (oxcf->aq_mode == EQUATOR360_AQ) {
      vp9_360aq_frame_setup(cpi);
    } else if (oxcf->aq_mode == COMPLEXITY_AQ) {
      vp9_setup_in_frame_q_adj(cpi);
    } else if (oxcf->aq_mode == LOOKAHEAD_AQ) {
      vp9_alt_ref_aq_setup_map(cpi->alt_ref_aq, cpi);
    } else if (oxcf->aq_mode == PSNR_AQ) {
      vp9_psnr_aq_mode_setup(&cm->seg);
    }

    vp9_encode_frame(cpi);

    // Update the skip mb flag probabilities based on the distribution
    // seen in the last encoder iteration.
    // update_base_skip_probs(cpi);

    vpx_clear_system_state();

    // Dummy pack of the bitstream using up to date stats to get an
    // accurate estimate of output frame size to determine if we need
    // to recode.
    if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF) {
      save_coding_context(cpi);
      if (!cpi->sf.use_nonrd_pick_mode) vp9_pack_bitstream(cpi, dest, size);

      rc->projected_frame_size = (int)(*size) << 3;

      if (frame_over_shoot_limit == 0) frame_over_shoot_limit = 1;
    }

    if (cpi->ext_ratectrl.ready &&
        (cpi->ext_ratectrl.funcs.rc_type & VPX_RC_QP) != 0) {
      // In general, for the external rate control, we take the qindex provided
      // as input and encode the frame with this qindex faithfully. However,
      // in some extreme scenarios, the provided qindex leads to a massive
      // overshoot of frame size. In this case, we fall back to VP9's decision
      // to pick a new qindex and recode the frame. We return the new qindex
      // through the API to the external model.
      if (ext_rc_max_frame_size == 0) {
        if (!ext_rc_use_default_q) break;
      } else if (ext_rc_max_frame_size == -1) {
        // Do nothing, fall back to libvpx's recode decision.
      } else {
        // Change the max frame size, used in libvpx's recode decision.
        rc->max_frame_bandwidth = ext_rc_max_frame_size;
      }
      ext_rc_recode = 1;
    }
#if CONFIG_RATE_CTRL
    if (cpi->oxcf.use_simple_encode_api) {
      // This part needs to be after save_coding_context() because
      // restore_coding_context will be called in the end of this function.
      // TODO(angiebird): This is a hack for making sure the encoder use the
      // external_quantize_index exactly. Avoid this kind of hack later.
      if (cpi->encode_command.use_external_quantize_index) {
        break;
      }

      if (cpi->encode_command.use_external_target_frame_bits) {
        const double percent_diff = get_bits_percent_diff(
            rc->this_frame_target, rc->projected_frame_size);
        update_rq_history(rq_history, rc->this_frame_target,
                          rc->projected_frame_size, q);
        loop_count += 1;

        rq_model_update(rq_history, rc->this_frame_target, rq_model);

        // Check if we hit the target bitrate.
        if (percent_diff <=
                cpi->encode_command.target_frame_bits_error_percent ||
            rq_history->recode_count >= RATE_CTRL_MAX_RECODE_NUM ||
            rq_history->q_index_low >= rq_history->q_index_high) {
          break;
        }

        loop = 1;
        restore_coding_context(cpi);
        continue;
      }
    }
#endif  // CONFIG_RATE_CTRL

    if (oxcf->rc_mode == VPX_Q) {
      loop = 0;
    } else {
      if ((cm->frame_type == KEY_FRAME) && rc->this_key_frame_forced &&
          (rc->projected_frame_size < rc->max_frame_bandwidth)) {
        int last_q = q;
        int64_t kf_err;

        int64_t high_err_target = cpi->ambient_err;
        int64_t low_err_target = cpi->ambient_err >> 1;

#if CONFIG_VP9_HIGHBITDEPTH
        if (cm->use_highbitdepth) {
          kf_err = vpx_highbd_get_y_sse(cpi->Source, get_frame_new_buffer(cm));
        } else {
          kf_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));
        }
#else
        kf_err = vpx_get_y_sse(cpi->Source, get_frame_new_buffer(cm));
#endif  // CONFIG_VP9_HIGHBITDEPTH

        // Prevent possible divide by zero error below for perfect KF
        kf_err += !kf_err;

        // The key frame is not good enough or we can afford
        // to make it better without undue risk of popping.
        if ((kf_err > high_err_target &&
             rc->projected_frame_size <= frame_over_shoot_limit) ||
            (kf_err > low_err_target &&
             rc->projected_frame_size <= frame_under_shoot_limit)) {
          // Lower q_high
          q_high = q > q_low ? q - 1 : q_low;

          // Adjust Q
          q = (int)((q * high_err_target) / kf_err);
          q = VPXMIN(q, (q_high + q_low) >> 1);
        } else if (kf_err < low_err_target &&
                   rc->projected_frame_size >= frame_under_shoot_limit) {
          // The key frame is much better than the previous frame
          // Raise q_low
          q_low = q < q_high ? q + 1 : q_high;

          // Adjust Q
          q = (int)((q * low_err_target) / kf_err);
          q = VPXMIN(q, (q_high + q_low + 1) >> 1);
        }

        // Clamp Q to upper and lower limits:
        q = clamp(q, q_low, q_high);

        loop = q != last_q;
      } else if (recode_loop_test(cpi, frame_over_shoot_limit,
                                  frame_under_shoot_limit, q,
                                  VPXMAX(q_high, top_index), bottom_index)) {
        // Is the projected frame size out of range and are we allowed
        // to attempt to recode.
        int last_q = q;
        int retries = 0;
        int qstep;

        if (cpi->resize_pending == 1) {
          // Change in frame size so go back around the recode loop.
          cpi->rc.frame_size_selector =
              SCALE_STEP1 - cpi->rc.frame_size_selector;
          cpi->rc.next_frame_size_selector = cpi->rc.frame_size_selector;

#if CONFIG_INTERNAL_STATS
          ++cpi->tot_recode_hits;
#endif
          ++loop_count;
          loop = 1;
          continue;
        }

        // Frame size out of permitted range:
        // Update correction factor & compute new Q to try...

        // Frame is too large
        if (rc->projected_frame_size > rc->this_frame_target) {
          // Special case if the projected size is > the max allowed.
          if ((q == q_high) &&
              ((rc->projected_frame_size >= rc->max_frame_bandwidth) ||
               (!rc->is_src_frame_alt_ref &&
                (rc->projected_frame_size >=
                 big_rate_miss_high_threshold(cpi))))) {
            int max_rate = VPXMAX(1, VPXMIN(rc->max_frame_bandwidth,
                                            big_rate_miss_high_threshold(cpi)));
            double q_val_high;
            q_val_high = vp9_convert_qindex_to_q(q_high, cm->bit_depth);
            q_val_high =
                q_val_high * ((double)rc->projected_frame_size / max_rate);
            q_high = vp9_convert_q_to_qindex(q_val_high, cm->bit_depth);
            q_high = clamp(q_high, rc->best_quality, rc->worst_quality);
          }

          // Raise Qlow as to at least the current value
          qstep =
              get_qstep_adj(rc->projected_frame_size, rc->this_frame_target);
          q_low = VPXMIN(q + qstep, q_high);

          if (undershoot_seen || loop_at_this_size > 1) {
            // Update rate_correction_factor unless
            vp9_rc_update_rate_correction_factors(cpi);

            q = (q_high + q_low + 1) / 2;
          } else {
            // Update rate_correction_factor unless
            vp9_rc_update_rate_correction_factors(cpi);

            q = vp9_rc_regulate_q(cpi, rc->this_frame_target, bottom_index,
                                  VPXMAX(q_high, top_index));

            while (q < q_low && retries < 10) {
              vp9_rc_update_rate_correction_factors(cpi);
              q = vp9_rc_regulate_q(cpi, rc->this_frame_target, bottom_index,
                                    VPXMAX(q_high, top_index));
              retries++;
            }
          }

          overshoot_seen = 1;
        } else {
          // Frame is too small
          qstep =
              get_qstep_adj(rc->this_frame_target, rc->projected_frame_size);
          q_high = VPXMAX(q - qstep, q_low);

          if (overshoot_seen || loop_at_this_size > 1) {
            vp9_rc_update_rate_correction_factors(cpi);
            q = (q_high + q_low) / 2;
          } else {
            vp9_rc_update_rate_correction_factors(cpi);
            q = vp9_rc_regulate_q(cpi, rc->this_frame_target,
                                  VPXMIN(q_low, bottom_index), top_index);
            // Special case reset for qlow for constrained quality.
            // This should only trigger where there is very substantial
            // undershoot on a frame and the auto cq level is above
            // the user passed in value.
            if (oxcf->rc_mode == VPX_CQ && q < q_low) {
              q_low = q;
            }

            while (q > q_high && retries < 10) {
              vp9_rc_update_rate_correction_factors(cpi);
              q = vp9_rc_regulate_q(cpi, rc->this_frame_target,
                                    VPXMIN(q_low, bottom_index), top_index);
              retries++;
            }
          }
          undershoot_seen = 1;
        }

        // Clamp Q to upper and lower limits:
        q = clamp(q, q_low, q_high);

        loop = (q != last_q);
      } else {
        loop = 0;
      }
    }

    // Special case for overlay frame.
    if (rc->is_src_frame_alt_ref &&
        rc->projected_frame_size < rc->max_frame_bandwidth)
      loop = 0;

    if (loop) {
      ++loop_count;
      ++loop_at_this_size;

#if CONFIG_INTERNAL_STATS
      ++cpi->tot_recode_hits;
#endif
    }

    if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF)
      if (loop) restore_coding_context(cpi);
#if CONFIG_COLLECT_COMPONENT_TIMING
    if (loop) printf("\n Recoding:");
#endif
  } while (loop);

  rc->max_frame_bandwidth = orig_rc_max_frame_bandwidth;

#ifdef AGGRESSIVE_VBR
  if (two_pass_first_group_inter(cpi)) {
    cpi->twopass.active_worst_quality =
        VPXMIN(q + qrange_adj, oxcf->worst_allowed_q);
  } else if (!frame_is_kf_gf_arf(cpi)) {
#else
  if (!frame_is_kf_gf_arf(cpi)) {
#endif
    // Have we been forced to adapt Q outside the expected range by an extreme
    // rate miss. If so adjust the active maxQ for the subsequent frames.
    if (!rc->is_src_frame_alt_ref && (q > cpi->twopass.active_worst_quality)) {
      cpi->twopass.active_worst_quality = q;
    } else if (oxcf->vbr_corpus_complexity && q == q_low &&
               rc->projected_frame_size < rc->this_frame_target) {
      cpi->twopass.active_worst_quality =
          VPXMAX(q, cpi->twopass.active_worst_quality - 1);
    }
  }

  if (enable_acl) {
    // Skip recoding, if model diff is below threshold
    const int thresh = compute_context_model_thresh(cpi);
    const int diff = compute_context_model_diff(cm);
    if (diff >= thresh) {
      vp9_encode_frame(cpi);
    }
  }
  if (cpi->sf.recode_loop >= ALLOW_RECODE_KFARFGF) {
    vpx_clear_system_state();
    restore_coding_context(cpi);
  }
}
