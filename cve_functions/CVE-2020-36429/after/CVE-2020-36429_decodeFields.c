decodeFields(CtxJson *ctx, ParseCtx *parseCtx, DecodeEntry *entries,
             size_t entryCount, const UA_DataType *type) {
    CHECK_TOKEN_BOUNDS;
    size_t objectCount = (size_t)(parseCtx->tokenArray[parseCtx->index].size);
    status ret = UA_STATUSCODE_GOOD;

    if(entryCount == 1) {
        if(*(entries[0].fieldName) == 0) { /*No MemberName*/
            return entries[0].function(entries[0].fieldPointer, type,
                                       ctx, parseCtx, true); /*ENCODE DIRECT*/
        }
    } else if(entryCount == 0) {
        return UA_STATUSCODE_BADDECODINGERROR;
    }

    parseCtx->index++; /*go to first key*/
    CHECK_TOKEN_BOUNDS;
    
    for (size_t currentObjectCount = 0; currentObjectCount < objectCount &&
             parseCtx->index < parseCtx->tokenCount; currentObjectCount++) {

        /* start searching at the index of currentObjectCount */
        for (size_t i = currentObjectCount; i < entryCount + currentObjectCount; i++) {
            /* Search for KEY, if found outer loop will be one less. Best case
             * is objectCount if in order! */
            size_t index = i % entryCount;
            
            CHECK_TOKEN_BOUNDS;
            if(jsoneq((char*) ctx->pos, &parseCtx->tokenArray[parseCtx->index], 
                       entries[index].fieldName) != 0)
                continue;

            if(entries[index].found) {
                /*Duplicate Key found, abort.*/
                return UA_STATUSCODE_BADDECODINGERROR;
            }

            entries[index].found = true;

            parseCtx->index++; /*goto value*/
            CHECK_TOKEN_BOUNDS;
            
            /* Find the data type.
             * TODO: get rid of parameter type. Only forward via DecodeEntry.
             */
            const UA_DataType *membertype = type;
            if(entries[index].type)
                membertype = entries[index].type;

            if(entries[index].function != NULL) {
                ret = entries[index].function(entries[index].fieldPointer,
                                              membertype, ctx, parseCtx, true); /*Move Token True*/
                if(ret != UA_STATUSCODE_GOOD)
                    return ret;
            } else {
                /*overstep single value, this will not work if object or array
                 Only used not to double parse pre looked up type, but it has to be overstepped*/
                parseCtx->index++;
            }
            break;
        }
    }
    return ret;
}
