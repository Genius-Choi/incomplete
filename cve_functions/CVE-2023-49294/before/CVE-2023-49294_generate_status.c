static void generate_status(struct mansession *s, struct ast_channel *chan, char **vars, int varc, int all_variables, char *id_text, int *count)
{
	struct timeval now;
	long elapsed_seconds;
	struct ast_bridge *bridge;
	RAII_VAR(struct ast_str *, variable_str, NULL, ast_free);
	struct ast_str *write_transpath = ast_str_alloca(256);
	struct ast_str *read_transpath = ast_str_alloca(256);
	struct ast_str *codec_buf = ast_str_alloca(AST_FORMAT_CAP_NAMES_LEN);
	struct ast_party_id effective_id;
	int i;
	RAII_VAR(struct ast_channel_snapshot *, snapshot,
		ast_channel_snapshot_get_latest(ast_channel_uniqueid(chan)),
		ao2_cleanup);
	RAII_VAR(struct ast_str *, snapshot_str, NULL, ast_free);

	if (!snapshot) {
		return;
	}

	snapshot_str = ast_manager_build_channel_state_string(snapshot);
	if (!snapshot_str) {
		return;
	}

	if (all_variables) {
		variable_str = ast_str_create(2048);
	} else {
		variable_str = ast_str_create(1024);
	}
	if (!variable_str) {
		return;
	}

	now = ast_tvnow();
	elapsed_seconds = ast_tvdiff_sec(now, ast_channel_creationtime(chan));

	/* Even if all_variables has been specified, explicitly requested variables
	 * may be global variables or dialplan functions */
	for (i = 0; i < varc; i++) {
		char valbuf[512], *ret = NULL;

		if (vars[i][strlen(vars[i]) - 1] == ')') {
			if (ast_func_read(chan, vars[i], valbuf, sizeof(valbuf)) < 0) {
				valbuf[0] = '\0';
			}
			ret = valbuf;
		} else {
			pbx_retrieve_variable(chan, vars[i], &ret, valbuf, sizeof(valbuf), NULL);
		}

		ast_str_append(&variable_str, 0, "Variable: %s=%s\r\n", vars[i], ret);
	}

	/* Walk all channel variables and add them */
	if (all_variables) {
		struct ast_var_t *variables;

		AST_LIST_TRAVERSE(ast_channel_varshead(chan), variables, entries) {
			ast_str_append(&variable_str, 0, "Variable: %s=%s\r\n",
				ast_var_name(variables), ast_var_value(variables));
		}
	}

	bridge = ast_channel_get_bridge(chan);
	effective_id = ast_channel_connected_effective_id(chan);

	astman_append(s,
		"Event: Status\r\n"
		"Privilege: Call\r\n"
		"%s"
		"Type: %s\r\n"
		"DNID: %s\r\n"
		"EffectiveConnectedLineNum: %s\r\n"
		"EffectiveConnectedLineName: %s\r\n"
		"TimeToHangup: %ld\r\n"
		"BridgeID: %s\r\n"
		"Application: %s\r\n"
		"Data: %s\r\n"
		"Nativeformats: %s\r\n"
		"Readformat: %s\r\n"
		"Readtrans: %s\r\n"
		"Writeformat: %s\r\n"
		"Writetrans: %s\r\n"
		"Callgroup: %llu\r\n"
		"Pickupgroup: %llu\r\n"
		"Seconds: %ld\r\n"
		"%s"
		"%s"
		"\r\n",
		ast_str_buffer(snapshot_str),
		ast_channel_tech(chan)->type,
		S_OR(ast_channel_dialed(chan)->number.str, ""),
		S_COR(effective_id.number.valid, effective_id.number.str, "<unknown>"),
		S_COR(effective_id.name.valid, effective_id.name.str, "<unknown>"),
		(long)ast_channel_whentohangup(chan)->tv_sec,
		bridge ? bridge->uniqueid : "",
		ast_channel_appl(chan),
		ast_channel_data(chan),
		ast_format_cap_get_names(ast_channel_nativeformats(chan), &codec_buf),
		ast_format_get_name(ast_channel_readformat(chan)),
		ast_translate_path_to_str(ast_channel_readtrans(chan), &read_transpath),
		ast_format_get_name(ast_channel_writeformat(chan)),
		ast_translate_path_to_str(ast_channel_writetrans(chan), &write_transpath),
		ast_channel_callgroup(chan),
		ast_channel_pickupgroup(chan),
		(long)elapsed_seconds,
		ast_str_buffer(variable_str),
		id_text);
	++*count;

	ao2_cleanup(bridge);
}
