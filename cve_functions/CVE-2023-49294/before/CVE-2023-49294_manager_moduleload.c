static int manager_moduleload(struct mansession *s, const struct message *m)
{
	int res;
	const char *module = astman_get_header(m, "Module");
	const char *loadtype = astman_get_header(m, "LoadType");

	if (!loadtype || strlen(loadtype) == 0) {
		astman_send_error(s, m, "Incomplete ModuleLoad action.");
	}
	if ((!module || strlen(module) == 0) && strcasecmp(loadtype, "reload") != 0) {
		astman_send_error(s, m, "Need module name");
	}

	if (!strcasecmp(loadtype, "load")) {
		res = ast_load_resource(module);
		if (res) {
			astman_send_error(s, m, "Could not load module.");
		} else {
			astman_send_ack(s, m, "Module loaded.");
		}
	} else if (!strcasecmp(loadtype, "unload")) {
		res = ast_unload_resource(module, AST_FORCE_SOFT);
		if (res) {
			astman_send_error(s, m, "Could not unload module.");
		} else {
			astman_send_ack(s, m, "Module unloaded.");
		}
	} else if (!strcasecmp(loadtype, "reload")) {
		/* TODO: Unify the ack/error messages here with action_reload */
		if (!ast_strlen_zero(module)) {
			enum ast_module_reload_result reload_res = ast_module_reload(module);

			switch (reload_res) {
			case AST_MODULE_RELOAD_NOT_FOUND:
				astman_send_error(s, m, "No such module.");
				break;
			case AST_MODULE_RELOAD_NOT_IMPLEMENTED:
				astman_send_error(s, m, "Module does not support reload action.");
				break;
			case AST_MODULE_RELOAD_ERROR:
				astman_send_error(s, m, "An unknown error occurred");
				break;
			case AST_MODULE_RELOAD_IN_PROGRESS:
				astman_send_error(s, m, "A reload is in progress");
				break;
			case AST_MODULE_RELOAD_UNINITIALIZED:
				astman_send_error(s, m, "Module not initialized");
				break;
			case AST_MODULE_RELOAD_QUEUED:
			case AST_MODULE_RELOAD_SUCCESS:
				/* Treat a queued request as success */
				astman_send_ack(s, m, "Module reloaded.");
				break;
			}
		} else {
			ast_module_reload(NULL);	/* Reload all modules */
			astman_send_ack(s, m, "All modules reloaded");
		}
	} else
		astman_send_error(s, m, "Incomplete ModuleLoad action.");
	return 0;
}
