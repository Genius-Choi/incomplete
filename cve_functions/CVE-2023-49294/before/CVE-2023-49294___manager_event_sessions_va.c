static int __attribute__((format(printf, 9, 0))) __manager_event_sessions_va(
	struct ao2_container *sessions,
	int category,
	const char *event,
	int chancount,
	struct ast_channel **chans,
	const char *file,
	int line,
	const char *func,
	const char *fmt,
	va_list ap)
{
	struct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);
	const char *cat_str;
	struct timeval now;
	struct ast_str *buf;
	int i;

	if (!ast_strlen_zero(manager_disabledevents)) {
		if (ast_in_delimited_string(event, manager_disabledevents, ',')) {
			ast_debug(3, "AMI Event '%s' is globally disabled, skipping\n", event);
			/* Event is globally disabled */
			return -1;
		}
	}

	buf = ast_str_thread_get(&manager_event_buf, MANAGER_EVENT_BUF_INITSIZE);
	if (!buf) {
		return -1;
	}

	cat_str = authority_to_str(category, &auth);
	ast_str_set(&buf, 0,
		"Event: %s\r\n"
		"Privilege: %s\r\n",
		event, cat_str);

	if (timestampevents) {
		now = ast_tvnow();
		ast_str_append(&buf, 0,
			"Timestamp: %ld.%06lu\r\n",
			(long)now.tv_sec, (unsigned long) now.tv_usec);
	}
	if (manager_debug) {
		static int seq;

		ast_str_append(&buf, 0,
			"SequenceNumber: %d\r\n",
			ast_atomic_fetchadd_int(&seq, 1));
		ast_str_append(&buf, 0,
			"File: %s\r\n"
			"Line: %d\r\n"
			"Func: %s\r\n",
			file, line, func);
	}
	if (!ast_strlen_zero(ast_config_AST_SYSTEM_NAME)) {
		ast_str_append(&buf, 0,
			"SystemName: %s\r\n",
			ast_config_AST_SYSTEM_NAME);
	}

	ast_str_append_va(&buf, 0, fmt, ap);
	for (i = 0; i < chancount; i++) {
		append_channel_vars(&buf, chans[i]);
	}

	ast_str_append(&buf, 0, "\r\n");

	append_event(ast_str_buffer(buf), category);

	/* Wake up any sleeping sessions */
	if (sessions) {
		struct ao2_iterator iter;
		struct mansession_session *session;

		iter = ao2_iterator_init(sessions, 0);
		while ((session = ao2_iterator_next(&iter))) {
			ast_mutex_lock(&session->notify_lock);
			if (session->waiting_thread != AST_PTHREADT_NULL) {
				pthread_kill(session->waiting_thread, SIGURG);
			} else {
				/* We have an event to process, but the mansession is
				 * not waiting for it. We still need to indicate that there
				 * is an event waiting so that get_input processes the pending
				 * event instead of polling.
				 */
				session->pending_event = 1;
			}
			ast_mutex_unlock(&session->notify_lock);
			unref_mansession(session);
		}
		ao2_iterator_destroy(&iter);
	}

	if (category != EVENT_FLAG_SHUTDOWN && !AST_RWLIST_EMPTY(&manager_hooks)) {
		struct manager_custom_hook *hook;

		AST_RWLIST_RDLOCK(&manager_hooks);
		AST_RWLIST_TRAVERSE(&manager_hooks, hook, list) {
			hook->helper(category, event, ast_str_buffer(buf));
		}
		AST_RWLIST_UNLOCK(&manager_hooks);
	}

	return 0;
}
