bgp_attr_as4_aggregator(struct bgp_attr_parser_args *args,
			as_t *as4_aggregator_as,
			struct in_addr *as4_aggregator_addr)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	as_t aggregator_as;

	if (length != 8) {
		flog_err(EC_BGP_ATTR_LEN, "New Aggregator length is not 8 [%d]",
			 length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  0);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto as4_aggregator_ignore;

	aggregator_as = stream_getl(peer->curr);

	*as4_aggregator_as = aggregator_as;
	as4_aggregator_addr->s_addr = stream_get_ipv4(peer->curr);

	/* Codification of AS 0 Processing */
	if (aggregator_as == BGP_AS_ZERO) {
		flog_err(EC_BGP_ATTR_LEN,
			 "%s: AS4_AGGREGATOR AS number is 0 for aspath: %s",
			 peer->host, aspath_print(attr->aspath));

		if (bgp_debug_update(peer, NULL, NULL, 1)) {
			char attr_str[BUFSIZ] = {0};

			bgp_dump_attr(attr, attr_str, sizeof(attr_str));

			zlog_debug("%s: attributes: %s", __func__, attr_str);
		}
	} else {
		attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR);
	}

	return BGP_ATTR_PARSE_PROCEED;

as4_aggregator_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}
