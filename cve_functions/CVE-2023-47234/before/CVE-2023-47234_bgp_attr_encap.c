static int bgp_attr_encap(struct bgp_attr_parser_args *args)
{
	uint16_t tunneltype = 0;
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	bgp_size_t length = args->length;
	uint8_t type = args->type;
	uint8_t flag = args->flags;

	if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS)
	    || !CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {
		zlog_err("Tunnel Encap attribute flag isn't optional and transitive %d",
			 flag);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
					  args->total);
	}

	if (BGP_ATTR_ENCAP == type) {
		/* read outer TLV type and length */
		uint16_t tlv_length;

		if (length < 4) {
			zlog_err(
				"Tunnel Encap attribute not long enough to contain outer T,L");
			return bgp_attr_malformed(args,
						  BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
						  args->total);
		}
		tunneltype = stream_getw(BGP_INPUT(peer));
		tlv_length = stream_getw(BGP_INPUT(peer));
		length -= 4;

		if (tlv_length != length) {
			zlog_info("%s: tlv_length(%d) != length(%d)",
				  __func__, tlv_length, length);
		}
	}

	while (length >= 4) {
		uint16_t subtype = 0;
		uint16_t sublength = 0;
		struct bgp_attr_encap_subtlv *tlv;

		if (BGP_ATTR_ENCAP == type) {
			subtype = stream_getc(BGP_INPUT(peer));
			sublength = (subtype < 128)
					    ? stream_getc(BGP_INPUT(peer))
					    : stream_getw(BGP_INPUT(peer));
			length -= 2;
#ifdef ENABLE_BGP_VNC
		} else {
			subtype = stream_getw(BGP_INPUT(peer));
			sublength = stream_getw(BGP_INPUT(peer));
			length -= 4;
#endif
		}

		if (sublength > length) {
			zlog_err("Tunnel Encap attribute sub-tlv length %d exceeds remaining length %d",
				 sublength, length);
			return bgp_attr_malformed(args,
						  BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
						  args->total);
		}

		/* alloc and copy sub-tlv */
		/* TBD make sure these are freed when attributes are released */
		tlv = XCALLOC(MTYPE_ENCAP_TLV,
			      sizeof(struct bgp_attr_encap_subtlv) + sublength);
		tlv->type = subtype;
		tlv->length = sublength;
		stream_get(tlv->value, peer->curr, sublength);
		length -= sublength;

		/* attach tlv to encap chain */
		if (BGP_ATTR_ENCAP == type) {
			struct bgp_attr_encap_subtlv *stlv_last;
			for (stlv_last = attr->encap_subtlvs;
			     stlv_last && stlv_last->next;
			     stlv_last = stlv_last->next)
				;
			if (stlv_last) {
				stlv_last->next = tlv;
			} else {
				attr->encap_subtlvs = tlv;
			}
#ifdef ENABLE_BGP_VNC
		} else {
			struct bgp_attr_encap_subtlv *stlv_last;
			struct bgp_attr_encap_subtlv *vnc_subtlvs =
				bgp_attr_get_vnc_subtlvs(attr);

			for (stlv_last = vnc_subtlvs;
			     stlv_last && stlv_last->next;
			     stlv_last = stlv_last->next)
				;
			if (stlv_last)
				stlv_last->next = tlv;
			else
				bgp_attr_set_vnc_subtlvs(attr, tlv);
#endif
		}
	}

	if (BGP_ATTR_ENCAP == type) {
		attr->encap_tunneltype = tunneltype;
	}

	if (length) {
		/* spurious leftover data */
		zlog_err("Tunnel Encap attribute length is bad: %d leftover octets",
			 length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,
					  args->total);
	}

	return 0;
}
