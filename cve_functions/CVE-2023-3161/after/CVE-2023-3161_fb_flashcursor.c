static void fb_flashcursor(struct work_struct *work)
{
	struct fbcon_ops *ops = container_of(work, struct fbcon_ops, cursor_work.work);
	struct fb_info *info;
	struct vc_data *vc = NULL;
	int c;
	int mode;
	int ret;

	/* FIXME: we should sort out the unbind locking instead */
	/* instead we just fail to flash the cursor if we can't get
	 * the lock instead of blocking fbcon deinit */
	ret = console_trylock();
	if (ret == 0)
		return;

	/* protected by console_lock */
	info = ops->info;

	if (ops->currcon != -1)
		vc = vc_cons[ops->currcon].d;

	if (!vc || !con_is_visible(vc) ||
	    fbcon_info_from_console(vc->vc_num) != info ||
	    vc->vc_deccm != 1) {
		console_unlock();
		return;
	}

	c = scr_readw((u16 *) vc->vc_pos);
	mode = (!ops->cursor_flash || ops->cursor_state.enable) ?
		CM_ERASE : CM_DRAW;
	ops->cursor(vc, info, mode, get_color(vc, info, c, 1),
		    get_color(vc, info, c, 0));
	console_unlock();

	queue_delayed_work(system_power_efficient_wq, &ops->cursor_work,
			   ops->cur_blink_jiffies);
}
