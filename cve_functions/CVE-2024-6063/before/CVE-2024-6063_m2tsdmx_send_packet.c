static void m2tsdmx_send_packet(GF_M2TSDmxCtx *ctx, GF_M2TS_PES_PCK *pck)
{
	GF_FilterPid *opid;
	GF_FilterPacket *dst_pck;
	u8 * data;
	//we don't have end of frame signaling by default
	Bool au_end = GF_FALSE;
	GF_FilterSAPType sap_type = GF_FILTER_SAP_NONE;

	/*pcr not initialized, don't send any data*/
//	if (! pck->stream->program->first_dts) return;
	if (!pck->stream->user) return;
	opid = pck->stream->user;

	u8 *ptr = pck->data;
	u32 len = pck->data_len;

	//skip dataID and stream ID
	if (pck->stream->stream_type==GF_M2TS_DVB_SUBTITLE) {
		ptr+=2;
		len-=2;
	}
	//for now GF_M2TS_ES_FULL_AU is only used for text, all rap
	if (pck->stream->flags & GF_M2TS_ES_FULL_AU) {
		au_end = GF_TRUE;
		sap_type = GF_FILTER_SAP_1;
	}

	if (pck->stream->flags & GF_M2TS_CHECK_VC1) {
#ifndef GPAC_DISABLE_AV_PARSERS
		//extract seq header
		u32 start, next, sc_size, sc_size2, sc_size3, hdr_len=0;

		start = next = gf_media_nalu_next_start_code(ptr, len, &sc_size);
		if ((next<len) && (ptr[next+sc_size]==0x0F)) {
			u32 ephdr = gf_media_nalu_next_start_code (ptr+next+sc_size, len-next-sc_size, &sc_size2);
			if ((ephdr + next + sc_size < len) && (ptr[next+sc_size+ephdr+sc_size2]==0x0E)) {
				u32 end = gf_media_nalu_next_start_code (ptr+next+sc_size+ephdr+sc_size2, len-next-sc_size-ephdr-sc_size2, &sc_size3);
				if (end + ephdr + next + sc_size + sc_size2 < len)
					hdr_len = end + ephdr + sc_size2 + next + sc_size;
			} else if ((ephdr + next + sc_size < len) && (ptr[next+sc_size+ephdr+sc_size2]==0x0D)) {
				hdr_len = ephdr + next + sc_size;
			}
		}
		if (hdr_len) {
			u8 *dsi=NULL;
			u32 dsi_len;
			ptr += start;
			len -= start;
			gf_media_vc1_seq_header_to_dsi(ptr, len, &dsi, &dsi_len);
			if (dsi)
				gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_len));

			ptr += hdr_len;
			len -= hdr_len;
			pck->stream->flags &= ~GF_M2TS_CHECK_VC1;
		}
#endif
	}


	dst_pck = gf_filter_pck_new_alloc(opid, len, &data);
	if (!dst_pck) return;
	memcpy(data, ptr, len);

	gf_filter_pck_set_framing(dst_pck, (pck->flags & GF_M2TS_PES_PCK_AU_START) ? GF_TRUE : GF_FALSE, au_end);

	if (pck->flags & GF_M2TS_PES_PCK_AU_START) {
		if (pck->flags & GF_M2TS_PES_PCK_RAP)
			sap_type = GF_FILTER_SAP_1;

		gf_filter_pck_set_cts(dst_pck, pck->PTS);
		if (pck->DTS != pck->PTS) {
			gf_filter_pck_set_dts(dst_pck, pck->DTS);
		}
		gf_filter_pck_set_sap(dst_pck, sap_type);

		if (pck->stream->flags & GF_M2TS_ES_IS_PES) {
			GF_M2TS_PES *pes = (GF_M2TS_PES *)pck->stream;
			if (pes->map_utc) {
				s64 diff = pck->PTS;
				diff -= pes->map_utc_pcr;
				diff = gf_timestamp_rescale_signed(diff, 90000, 1000);
				gf_filter_pck_set_property(dst_pck, GF_PROP_PCK_UTC_TIME, &PROP_LONGUINT(pes->map_utc+diff) );
				pes->map_utc=0;
			}
			if (pes->map_pcr) {
				Double diff = (Double) pck->PTS;
				diff -= pes->map_pcr;
				diff /= 90000;
				gf_filter_pck_set_property(dst_pck, GF_PROP_PCK_MEDIA_TIME, &PROP_DOUBLE(ctx->media_start_range+diff) );
				pes->map_pcr=0;
			}
		}
	}
	m2tdmx_merge_props(opid, (GF_M2TS_ES *)pck->stream, dst_pck);

	if (pck->stream->is_seg_start) {
		pck->stream->is_seg_start = GF_FALSE;
		gf_filter_pck_set_property(dst_pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));
	}
	if (ctx->sigfrag) {
		u64 pat_offset;

		if (pck->stream->flags & GF_M2TS_ES_IS_PES) {
			pat_offset = pck->stream->before_last_pes_start_pn;
			if (pat_offset>pck->stream->before_last_pat_pn)
				pat_offset = pck->stream->before_last_pat_pn;
		} else {
			pat_offset = ctx->ts->last_pat_start_num;
		}
		pat_offset *= (ctx->ts->prefix_present ? 192 : 188);
		gf_filter_pck_set_property(dst_pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(pat_offset, 0));
	}
	gf_filter_pck_send(dst_pck);
	ctx->nb_stop_pending = 0;
}
