static GF_Err m2tsdmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)
{
	const GF_PropertyValue *p;
	Bool can_probe=GF_FALSE;
	GF_M2TSDmxCtx *ctx = gf_filter_get_udta(filter);

	if (is_remove) {
		ctx->ipid = NULL;
		u32 i, count = gf_filter_get_opid_count(filter);
		for (i=0; i<count; i++) {
			GF_FilterPid *opid = gf_filter_get_opid(filter, i);
			gf_filter_pid_remove( opid);
		}
		return GF_OK;
	}
	if (! gf_filter_pid_check_caps(pid))
		return GF_NOT_SUPPORTED;

	//by default for all URLs, send packets as soon as the program is configured
	ctx->mux_tune_state = DMX_TUNE_DONE;

	p = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);
	if (p && p->value.string && !ctx->duration.num && strncmp(p->value.string, "gmem://", 7)) {
		can_probe = GF_TRUE;
	}

	if (can_probe) {
		if (ctx->seeksrc) {
			//for local file we will send a seek and stop once all programs are configured, and reparse from start
			p = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);
			if (p && p->value.string && gf_file_exists(p->value.string)) {
				ctx->mux_tune_state = DMX_TUNE_INIT;
			}
		}

		FILE *stream = NULL;
		if (!ctx->sigfrag && ctx->index) {
			stream = gf_fopen(p->value.string, "rb");
		}

		ctx->ipid = pid;
		ctx->is_file = GF_TRUE;
		if (stream) {
			ctx->ts->seek_mode = GF_TRUE;
			ctx->ts->on_event = m2tsdmx_on_event_duration_probe;
			while (!gf_feof(stream)) {
				char buf[1880];
				u32 nb_read = (u32) gf_fread(buf, 1880, stream);
				gf_m2ts_process_data(ctx->ts, buf, nb_read);
				if (ctx->duration.num || (nb_read!=1880)) break;
			}
			gf_fclose(stream);
			gf_m2ts_demux_del(ctx->ts);
			ctx->ts = gf_m2ts_demux_new();
			ctx->ts->on_event = m2tsdmx_on_event;
			ctx->ts->user = filter;
		}
	} else if (!p) {
		GF_FilterEvent evt;
		ctx->duration.num = 1;

		//not-file base TS, we need to start demuxing the first time we see the PID
		if (!ctx->ipid) {
			GF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);
			gf_filter_pid_send_event(pid, &evt);
		}
	}
	ctx->ipid = pid;
	return GF_OK;
}
