lys_set_implemented(const struct lys_module *module)
{
    struct unres_schema *unres;
    int disabled = 0;

    if (!module) {
        LOGARG;
        return EXIT_FAILURE;
    }

    module = lys_main_module(module);

    if (module->disabled) {
        disabled = 1;
        lys_set_enabled(module);
    }

    if (module->implemented) {
        return EXIT_SUCCESS;
    }

    unres = calloc(1, sizeof *unres);
    if (!unres) {
        LOGMEM(module->ctx);
        if (disabled) {
            /* set it back disabled */
            lys_set_disabled(module);
        }
        return EXIT_FAILURE;
    }
    /* recursively make the module implemented */
    ((struct lys_module *)module)->implemented = 1;
    if (lys_make_implemented_r((struct lys_module *)module, unres)) {
        goto error;
    }

    /* try again resolve augments in other modules possibly augmenting this one,
     * since we have just enabled it
     */
    /* resolve rest of unres items */
    if (unres->count && resolve_unres_schema((struct lys_module *)module, unres)) {
        goto error;
    }
    unres_schema_free(NULL, &unres, 0);

    LOGVRB("Module \"%s%s%s\" now implemented.", module->name, (module->rev_size ? "@" : ""),
           (module->rev_size ? module->rev[0].date : ""));
    return EXIT_SUCCESS;

error:
    if (disabled) {
        /* set it back disabled */
        lys_set_disabled(module);
    }

    ((struct lys_module *)module)->implemented = 0;
    unres_schema_free((struct lys_module *)module, &unres, 1);
    return EXIT_FAILURE;
}
