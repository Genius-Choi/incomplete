lyd_dup_withsiblings_r(const struct lyd_node *first, struct lyd_node *parent_dup, int options)
{
    struct lyd_node *first_dup = NULL, *prev_dup = NULL, *last_dup;
    const struct lyd_node *next;

    assert(first);

    /* duplicate and connect all siblings */
    LY_TREE_FOR(first, next) {
        last_dup = _lyd_dup_node(next, next->schema, next->schema->module->ctx, options);
        if (!last_dup) {
            goto error;
        }

        /* the whole data tree is exactly the same so we can safely copy the validation flags */
        last_dup->validity = next->validity;
        last_dup->when_status = next->when_status;

        last_dup->parent = parent_dup;
        if (!first_dup) {
            first_dup = last_dup;
        } else {
            assert(prev_dup);
            prev_dup->next = last_dup;
            last_dup->prev = prev_dup;
        }

        if ((next->schema->nodetype & (LYS_LIST | LYS_CONTAINER | LYS_RPC | LYS_ACTION | LYS_NOTIF)) && next->child) {
            /* recursively duplicate all children */
            if (!lyd_dup_withsiblings_r(next->child, last_dup, options)) {
                goto error;
            }
        }

        prev_dup = last_dup;
    }

    /* correctly set last sibling and parent child pointer */
    assert(!prev_dup->next);
    first_dup->prev = prev_dup;
    if (parent_dup) {
        parent_dup->child = first_dup;
    }

    return first_dup;

error:
    /* disconnect and free */
    first_dup->parent = NULL;
    lyd_free_withsiblings(first_dup);
    return NULL;
}
