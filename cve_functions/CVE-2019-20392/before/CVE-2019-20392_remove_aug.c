remove_aug(struct lys_node_augment *augment)
{
    struct lys_node *last, *elem;

    if ((augment->flags & LYS_NOTAPPLIED) || !augment->target) {
        /* skip already not applied augment */
        return;
    }

    elem = augment->child;
    if (elem) {
        LY_TREE_FOR(elem, last) {
            if (!last->next || (last->next->parent != (struct lys_node *)augment)) {
                break;
            }
        }
        /* elem is first augment child, last is the last child */

        /* parent child ptr */
        if (augment->target->child == elem) {
            augment->target->child = last->next;
        }

        /* parent child next ptr */
        if (elem->prev->next) {
            elem->prev->next = last->next;
        }

        /* parent child prev ptr */
        if (last->next) {
            last->next->prev = elem->prev;
        } else if (augment->target->child) {
            augment->target->child->prev = elem->prev;
        }

        /* update augment children themselves */
        elem->prev = last;
        last->next = NULL;
    }

    /* augment->target still keeps the resolved target, but for lys_augment_free()
     * we have to keep information that this augment is not applied to free its data */
    augment->flags |= LYS_NOTAPPLIED;
}
