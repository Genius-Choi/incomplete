QSqlIndex QODBCDriver::primaryIndex(const QString& tablename) const
{
    Q_D(const QODBCDriver);
    QSqlIndex index(tablename);
    if (!isOpen())
        return index;
    bool usingSpecialColumns = false;
    QSqlRecord rec = record(tablename);

    SQLHANDLE hStmt;
    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,
                                  d->hDbc,
                                  &hStmt);
    if (r != SQL_SUCCESS) {
        qSqlWarning("QODBCDriver::primaryIndex: Unable to list primary key"_L1, d);
        return index;
    }
    QString catalog, schema, table;
    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);

    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))
        catalog = stripDelimiters(catalog, QSqlDriver::TableName);
    else
        catalog = d->adjustCase(catalog);

    if (isIdentifierEscaped(schema, QSqlDriver::TableName))
        schema = stripDelimiters(schema, QSqlDriver::TableName);
    else
        schema = d->adjustCase(schema);

    if (isIdentifierEscaped(table, QSqlDriver::TableName))
        table = stripDelimiters(table, QSqlDriver::TableName);
    else
        table = d->adjustCase(table);

    r = SQLSetStmtAttr(hStmt,
                        SQL_ATTR_CURSOR_TYPE,
                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,
                        SQL_IS_UINTEGER);
    r = SQLPrimaryKeys(hStmt,
                        catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),
                        catalog.length(),
                        schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),
                        schema.length(),
                        toSQLTCHAR(table).data(),
                        table.length() /* in characters, not in bytes */);

    // if the SQLPrimaryKeys() call does not succeed (e.g the driver
    // does not support it) - try an alternative method to get hold of
    // the primary index (e.g MS Access and FoxPro)
    if (r != SQL_SUCCESS) {
            r = SQLSpecialColumns(hStmt,
                        SQL_BEST_ROWID,
                        catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),
                        catalog.length(),
                        schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),
                        schema.length(),
                        toSQLTCHAR(table).data(),
                        table.length(),
                        SQL_SCOPE_CURROW,
                        SQL_NULLABLE);

            if (r != SQL_SUCCESS) {
                qSqlWarning("QODBCDriver::primaryIndex: Unable to execute primary key list"_L1, d);
            } else {
                usingSpecialColumns = true;
            }
    }

    if (d->hasSQLFetchScroll)
        r = SQLFetchScroll(hStmt,
                           SQL_FETCH_NEXT,
                           0);
    else
        r = SQLFetch(hStmt);

    int fakeId = 0;
    QString cName, idxName;
    // Store all fields in a StringList because some drivers can't detail fields in this FETCH loop
    while (r == SQL_SUCCESS) {
        if (usingSpecialColumns) {
            cName = qGetStringData(hStmt, 1, -1, d->unicode).toString(); // column name
            idxName = QString::number(fakeId++); // invent a fake index name
        } else {
            cName = qGetStringData(hStmt, 3, -1, d->unicode).toString(); // column name
            idxName = qGetStringData(hStmt, 5, -1, d->unicode).toString(); // pk index name
        }
        index.append(rec.field(cName));
        index.setName(idxName);

        if (d->hasSQLFetchScroll)
            r = SQLFetchScroll(hStmt,
                               SQL_FETCH_NEXT,
                               0);
        else
            r = SQLFetch(hStmt);

    }
    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
    if (r!= SQL_SUCCESS)
        qSqlWarning("QODBCDriver: Unable to free statement handle"_L1 + QString::number(r), d);
    return index;
}
