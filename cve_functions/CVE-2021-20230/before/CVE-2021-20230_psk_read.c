NOEXPORT PSK_KEYS *psk_read(char *key_file) {
    DISK_FILE *df;
    char line[CONFLINELEN], *key_str;
    unsigned char *key_buf;
    long key_len;
    PSK_KEYS *head=NULL, *tail=NULL, *curr;
    int line_number=0;

    if(file_permissions(key_file))
        return NULL;
    df=file_open(key_file, FILE_MODE_READ);
    if(!df) {
        s_log(LOG_ERR, "Cannot open PSKsecrets file");
        return NULL;
    }
    while(file_getline(df, line, CONFLINELEN)>=0) {
        ++line_number;
        if(!line[0]) /* empty line */
            continue;
        key_str=strchr(line, ':');
        if(!key_str) {
            s_log(LOG_ERR,
                "PSKsecrets line %d: Not in identity:key format",
                line_number);
            file_close(df);
            psk_free(head);
            return NULL;
        }
        *key_str++='\0';
        if(strlen(line)+1>PSK_MAX_IDENTITY_LEN) { /* with the trailing '\0' */
            s_log(LOG_ERR,
                "PSKsecrets line %d: Identity longer than %d characters",
                line_number, PSK_MAX_IDENTITY_LEN);
            file_close(df);
            psk_free(head);
            return NULL;
        }
        key_buf=OPENSSL_hexstr2buf(key_str, &key_len);
        if(key_buf) { /* a valid hexadecimal value */
            s_log(LOG_INFO, "PSKsecrets line %d: "
                "%ld-byte hexadecimal key configured for identity \"%s\"",
                line_number, key_len, line);
        } else { /* not a valid hexadecimal value -> copy as a string */
            key_len=(long)strlen(key_str);
            key_buf=OPENSSL_malloc((size_t)key_len);
            memcpy(key_buf, key_str, (size_t)key_len);
            s_log(LOG_INFO, "PSKsecrets line %d: "
                "%ld-byte ASCII key configured for identity \"%s\"",
                line_number, key_len, line);
        }
        if(key_len>PSK_MAX_PSK_LEN) {
            s_log(LOG_ERR,
                "PSKsecrets line %d: Key longer than %d bytes",
                line_number, PSK_MAX_PSK_LEN);
            OPENSSL_free(key_buf);
            file_close(df);
            psk_free(head);
            return NULL;
        }
        if(key_len<16) {
            /* shorter keys are unlikely to have sufficient entropy */
            s_log(LOG_ERR,
                "PSKsecrets line %d: Key shorter than 16 bytes",
                line_number);
            OPENSSL_free(key_buf);
            file_close(df);
            psk_free(head);
            return NULL;
        }
        curr=str_alloc_detached(sizeof(PSK_KEYS));
        curr->identity=str_dup_detached(line);
        curr->key_val=str_alloc_detached((size_t)key_len);
        memcpy(curr->key_val, key_buf, (size_t)key_len);
        OPENSSL_free(key_buf);
        curr->key_len=(unsigned)key_len;
        curr->next=NULL;
        if(head)
            tail->next=curr;
        else
            head=curr;
        tail=curr;
    }
    file_close(df);
    return head;
}
