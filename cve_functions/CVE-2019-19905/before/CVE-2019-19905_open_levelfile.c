open_levelfile(lev, errbuf)
int lev;
char errbuf[];
{
    int fd;
    const char *fq_lock;

    if (errbuf)
        *errbuf = '\0';
    set_levelfile_name(lock, lev);
    fq_lock = fqname(lock, LEVELPREFIX, 0);
#ifdef MFLOPPY
    /* If not currently accessible, swap it in. */
    if (level_info[lev].where != ACTIVE)
        swapin_file(lev);
#endif
#ifdef MAC
    fd = macopen(fq_lock, O_RDONLY | O_BINARY, LEVL_TYPE);
#else
#ifdef HOLD_LOCKFILE_OPEN
    if (lev == 0)
        fd = open_levelfile_exclusively(fq_lock, lev, O_RDONLY | O_BINARY);
    else
#endif
        fd = open(fq_lock, O_RDONLY | O_BINARY, 0);
#endif

    /* for failure, return an explanation that our caller can use;
       settle for `lock' instead of `fq_lock' because the latter
       might end up being too big for nethack's BUFSZ */
    if (fd < 0 && errbuf)
        Sprintf(errbuf, "Cannot open file \"%s\" for level %d (errno %d).",
                lock, lev, errno);

    return fd;
}
