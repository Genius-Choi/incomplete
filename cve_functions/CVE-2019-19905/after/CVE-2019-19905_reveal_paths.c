reveal_paths(VOID_ARGS)
{
    const char *fqn, *nodumpreason;
    char buf[BUFSZ];
#if defined(SYSCF) || !defined(UNIX) || defined(DLB)
    const char *filep;
#ifdef SYSCF
    const char *gamename = (hname && *hname) ? hname : "NetHack";
#endif
#endif
#ifdef UNIX
    char *endp, *envp, cwdbuf[PATH_MAX];
#endif
#ifdef PREFIXES_IN_USE
    const char *strp;
    int i, maxlen = 0;

    raw_print("Variable playground locations:");
    for (i = 0; i < PREFIX_COUNT; i++)
        raw_printf("    [%-10s]=\"%s\"", fqn_prefix_names[i],
                   fqn_prefix[i] ? fqn_prefix[i] : "not set");
#endif

    /* sysconf file */

#ifdef SYSCF
#ifdef PREFIXES_IN_USE
    strp = fqn_prefix_names[SYSCONFPREFIX];
    maxlen = BUFSZ - sizeof " (in )";
    if (strp && (int) strlen(strp) < maxlen)
        Sprintf(buf, " (in %s)", strp);
#else
    buf[0] = '\0';
#endif
    raw_printf("%s system configuration file%s:", s_suffix(gamename), buf);
#ifdef SYSCF_FILE
    filep = SYSCF_FILE;
#else
    filep = "sysconf";
#endif
    fqn = fqname(filep, SYSCONFPREFIX, 0);
    if (fqn) {
        set_configfile_name(fqn);
        filep = configfile;
    }
    raw_printf("    \"%s\"", filep);
#else /* !SYSCF */
    raw_printf("No system configuration file.");
#endif /* ?SYSCF */

    /* symbols file */

    buf[0] = '\0';
#ifndef UNIX
#ifdef PREFIXES_IN_USE
#ifdef WIN32
    strp = fqn_prefix_names[SYSCONFPREFIX];
#else
    strp = fqn_prefix_names[HACKPREFIX];
#endif /* WIN32 */
    maxlen = BUFSZ - sizeof " (in )";
    if (strp && (int) strlen(strp) < maxlen)
        Sprintf(buf, " (in %s)", strp);
#endif /* PREFIXES_IN_USE */
    raw_printf("The loadable symbols file%s:", buf);
#endif /* UNIX */

#ifdef UNIX
    envp = getcwd(cwdbuf, PATH_MAX);
    if (envp) {
        raw_print("The loadable symbols file:");
        raw_printf("    \"%s/%s\"", envp, SYMBOLS);
    }
#else /* UNIX */
    filep = SYMBOLS;
#ifdef PREFIXES_IN_USE
#ifdef WIN32
    fqn = fqname(filep, SYSCONFPREFIX, 1);
#else
    fqn = fqname(filep, HACKPREFIX, 1);
#endif /* WIN32 */
    if (fqn)
        filep = fqn;
#endif /* PREFIXES_IN_USE */
    raw_printf("    \"%s\"", filep);
#endif /* UNIX */

    /* dlb vs non-dlb */

    buf[0] = '\0';
#ifdef PREFIXES_IN_USE
    strp = fqn_prefix_names[DATAPREFIX];
    maxlen = BUFSZ - sizeof " (in )";
    if (strp && (int) strlen(strp) < maxlen)
        Sprintf(buf, " (in %s)", strp);
#endif
#ifdef DLB
    raw_printf("Basic data files%s are collected inside:", buf);
    filep = DLBFILE;
#ifdef VERSION_IN_DLB_FILENAME
    Strcpy(buf, build_dlb_filename((const char *) 0));
#ifdef PREFIXES_IN_USE
    fqn = fqname(buf, DATAPREFIX, 1);
    if (fqn)
        filep = fqn;
#endif /* PREFIXES_IN_USE */
#endif
    raw_printf("    \"%s\"", filep);
#ifdef DLBFILE2
    filep = DLBFILE2;
    raw_printf("    \"%s\"", filep);
#endif
#else /* !DLB */
    raw_printf("Basic data files%s are in many separate files.", buf);
#endif /* ?DLB */

    /* dumplog */

#ifndef DUMPLOG
    nodumpreason = "not supported";
#else
    nodumpreason = "disabled";
#ifdef SYSCF
    fqn = sysopt.dumplogfile;
#else  /* !SYSCF */
#ifdef DUMPLOG_FILE
    fqn = DUMPLOG_FILE;
#else
    fqn = (char *) 0;
#endif
#endif /* ?SYSCF */
    if (fqn && *fqn) {
        raw_print("Your end-of-game disclosure file:");
        (void) dump_fmtstr(fqn, buf, FALSE);
        buf[sizeof buf - sizeof "    \"\""] = '\0';
        raw_printf("    \"%s\"", buf);
    } else
#endif /* ?DUMPLOG */
        raw_printf("No end-of-game disclosure file (%s).", nodumpreason);

#ifdef WIN32
    if (sysopt.portable_device_top) {
        const char *pd = get_portable_device();

        raw_printf("Writable folder for portable device config (sysconf %s):",
                    "portable_device_top");
        raw_printf("    \"%s\"", pd);
    }
#endif

    /* personal configuration file */

    buf[0] = '\0';
#ifdef PREFIXES_IN_USE
    strp = fqn_prefix_names[CONFIGPREFIX];
    maxlen = BUFSZ - sizeof " (in )";
    if (strp && (int) strlen(strp) < maxlen)
        Sprintf(buf, " (in %s)", strp);
#endif /* PREFIXES_IN_USE */
    raw_printf("Your personal configuration file%s:", buf);

#ifdef UNIX
    buf[0] = '\0';
    if ((envp = nh_getenv("HOME")) != 0) {
        copynchars(buf, envp, (int) sizeof buf - 1 - 1);
        Strcat(buf, "/");
    }
    endp = eos(buf);
    copynchars(endp, default_configfile,
               (int) (sizeof buf - 1 - strlen(buf)));
#if defined(__APPLE__) /* UNIX+__APPLE__ => MacOSX aka OSX aka macOS */
    if (envp) {
        if (access(buf, 4) == -1) { /* 4: R_OK, -1: failure */
            /* read access to default failed; might be protected excessively
               but more likely it doesn't exist; try first alternate:
               "$HOME/Library/Pref..."; 'endp' points past '/' */
            copynchars(endp, "Library/Preferences/NetHack Defaults",
                       (int) (sizeof buf - 1 - strlen(buf)));
            if (access(buf, 4) == -1) {
                /* first alternate failed, try second:
                   ".../NetHack Defaults.txt"; no 'endp', just append */
                copynchars(eos(buf), ".txt",
                           (int) (sizeof buf - 1 - strlen(buf)));
                if (access(buf, 4) == -1) {
                    /* second alternate failed too, so revert to the
                       original default ("$HOME/.nethackrc") for message */
                    copynchars(endp, default_configfile,
                               (int) (sizeof buf - 1 - strlen(buf)));
                }
            }
        }
    }
#endif /* __APPLE__ */
    raw_printf("    \"%s\"", buf);
#else /* !UNIX */
    fqn = (const char *) 0;
#ifdef PREFIXES_IN_USE
    fqn = fqname(default_configfile, CONFIGPREFIX, 2);
#endif
    raw_printf("    \"%s\"", fqn ? fqn : default_configfile);
#endif  /* ?UNIX */

    raw_print("");
}
