create_bonesfile(lev, bonesid, errbuf)
d_level *lev;
char **bonesid;
char errbuf[];
{
    const char *file;
    int fd;

    if (errbuf)
        *errbuf = '\0';
    *bonesid = set_bonesfile_name(bones, lev);
    file = set_bonestemp_name();
    file = fqname(file, BONESPREFIX, 0);

#if defined(MICRO) || defined(WIN32)
    /* Use O_TRUNC to force the file to be shortened if it already
     * exists and is currently longer.
     */
    fd = open(file, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, FCMASK);
#else
#ifdef MAC
    fd = maccreat(file, BONE_TYPE);
#else
    fd = creat(file, FCMASK);
#endif
#endif
    if (fd < 0 && errbuf) /* failure explanation */
        Sprintf(errbuf, "Cannot create bones \"%s\", id %s (errno %d).", lock,
                *bonesid, errno);

#if defined(VMS) && !defined(SECURE)
    /*
       Re-protect bones file with world:read+write+execute+delete access.
       umask() doesn't seem very reliable; also, vaxcrtl won't let us set
       delete access without write access, which is what's really wanted.
       Can't simply create it with the desired protection because creat
       ANDs the mask with the user's default protection, which usually
       denies some or all access to world.
     */
    (void) chmod(file, FCMASK | 007); /* allow other users full access */
#endif /* VMS && !SECURE */

    return fd;
}
