gui_wait_for_chars_buf(
    char_u	*buf,
    int		maxlen,
    long	wtime,	    // don't use "time", MIPS cannot handle it
    int		tb_change_cnt)
{
    int	    retval;

#ifdef FEAT_MENU
    // If we're going to wait a bit, update the menus and mouse shape for the
    // current State.
    if (wtime != 0)
	gui_update_menus(0);
#endif

    gui_mch_update();
    if (input_available())	// Got char, return immediately
    {
	if (buf != NULL && !typebuf_changed(tb_change_cnt))
	    return read_from_input_buf(buf, (long)maxlen);
	return 0;
    }
    if (wtime == 0)		// Don't wait for char
	return FAIL;

    // Before waiting, flush any output to the screen.
    gui_mch_flush();

    // Blink while waiting for a character.
    gui_mch_start_blink();

    // Common function to loop until "wtime" is met, while handling timers and
    // other callbacks.
    retval = inchar_loop(buf, maxlen, wtime, tb_change_cnt,
			 gui_wait_for_chars_or_timer, NULL);

    gui_mch_stop_blink(TRUE);

    return retval;
}
