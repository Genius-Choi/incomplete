void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,
                               size_t TSize) {
  constexpr size_t MinGrowth = 1;
  size_t NewCapacity = 2 * capacity() + MinGrowth; // Always grow.
  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));

  // Ensure that NewCapacity did not overflow an unsigned int,
  // and that the capacity in bytes will not overflow a size_t.
  if (NewCapacity <= this->capacity() ||
      NewCapacity < MinCapacity ||
      NewCapacity > size_t(-1) / TSize)
    report_bad_alloc_error("SmallVector capacity overflow during allocation");

  void *NewElts;
  if (BeginX == FirstEl) {
    NewElts = safe_malloc(NewCapacity * TSize);

    // Copy the elements over.  No need to run dtors on PODs.
    memcpy(NewElts, this->BeginX, size() * TSize);
  } else {
    // If this wasn't grown from the inline copy, grow the allocated space.
    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);
  }

  this->BeginX = NewElts;
  this->Capacity = NewCapacity;
}
