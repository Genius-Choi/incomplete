static void mp4_mux_set_tags(GF_MP4MuxCtx *ctx, TrackWriter *tkw)
{
	u32 idx=0;

	if (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat() ) {
		const char *tool = "GPAC-"GPAC_VERSION"-rev"GPAC_GIT_REVISION;
		u32 len = (u32) strlen(tool);
		gf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_TOOL, tool, len, 0, 0);
	}

	if (ctx->itags==TAG_NONE) return;

	while (1) {
		GF_Err e;
		u32 len;
		u32 prop_4cc=0;
		u32 itag;
		s32 tag_idx;
		const char *tag_name=NULL;
		const GF_PropertyValue *tag = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &tag_name);
		if (!tag) break;

		if (prop_4cc==GF_PROP_PID_COVER_ART) {
			e = gf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_COVER_ART, tag->value.data.ptr, tag->value.data.size, 0, 0);
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set cover art: %s\n", gf_error_to_string(e)));
			}
		}
		if (!tag_name)
			continue;

		if (!strncmp(tag_name, "tkgp_", 5)) {
			mp4mx_set_track_group(ctx, tkw, (char*) tag_name+5, tag);
			continue;
		}

		tag_idx = gf_itags_find_by_name(tag_name);
		if (tag_idx>=0) {
			itag = gf_itags_get_itag(tag_idx);
		} else if (!strnicmp(tag_name, "qtt_", 4)) {
			tag_name += 4;

			switch (tag->type) {
			case GF_PROP_DATA:
			case GF_PROP_CONST_DATA:
			case GF_PROP_DATA_NO_COPY:
			{
				GF_QT_UDTAKey key;
				key.type = GF_QT_KEY_OPAQUE;
				key.name = tag_name;
				key.ns = GF_4CC('m','d','t','a');
				char *sep = strchr(tag_name, '@');
				if (sep) {
					key.name = sep+1;
					key.ns = GF_4CC(tag_name[0], tag_name[1],tag_name[2],tag_name[3]);
				}
				key.value.data.data = tag->value.data.ptr;
				key.value.data.data_len = tag->value.data.size;
				e = gf_isom_set_qt_key(ctx->file, &key);
			}
				break;
			case GF_PROP_POINTER:
				e = GF_NOT_SUPPORTED;
				break;
			default:
			{
				char szDump[GF_PROP_DUMP_ARG_SIZE];
				const char *str = gf_props_dump_val(tag, szDump, GF_PROP_DUMP_DATA_NONE, NULL);
				e = gf_media_isom_apply_qt_key(ctx->file, tag_name, str);
			}
				break;
			}
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set QT tag: %s\n", gf_error_to_string(e)));
			}
			continue;
		} else {
			if (ctx->itags==TAG_STRICT)
				continue;

			if (strnicmp(tag_name, "tag_", 4))
				continue;

			tag_name += 4;

			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[MP4Mux] Unrecognized tag %s: %s\n", tag_name, tag->value.string));

			if (strlen(tag_name)==4) {
				itag = GF_4CC(tag_name[0], tag_name[1], tag_name[2], tag_name[3]);
			} else if (strlen(tag_name)==3) {
				itag = GF_4CC(0xA9, tag_name[0], tag_name[1], tag_name[2]);
			} else {
				itag = gf_crc_32(tag_name, (u32) strlen(tag_name));
				GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("[MP4Mux] Tag name %s is not a 4CC, using CRC32 %08X as value\n", tag_name, itag));
			}
		}

		if (itag==GF_ISOM_ITUNE_TOOL) {
			continue;
		}

		switch (tag->type) {
		case GF_PROP_STRING:
		case GF_PROP_NAME:
			len = tag->value.string ? (u32) strlen(tag->value.string) : 0;
			e = gf_isom_apple_set_tag(ctx->file, itag, tag->value.string, len, 0, 0);
			break;
		case GF_PROP_BOOL:
			e = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.boolean, 0);
			break;
		case GF_PROP_UINT:
		case GF_PROP_4CC:
			e = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.uint, 0);
			break;
		case GF_PROP_LUINT:
			e = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.longuint, 0);
			break;
		case GF_PROP_FRACTION:
			e = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.frac.num, tag->value.frac.den);
			break;
		case GF_PROP_DATA:
		case GF_PROP_CONST_DATA:
			e = gf_isom_apple_set_tag(ctx->file, itag, tag->value.data.ptr, tag->value.data.size, 0, 0);
			break;
		default:
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set tag %s: invalid data format\n", gf_itags_get_name(tag_idx) ));
			e = GF_OK;
			break;
		}

		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set tag %s: %s\n", tag_name, gf_error_to_string(e)));
		}
	}
}
