void apc_load(int thread) {
#ifndef _MSC_VER
  static void *handle = nullptr;
  if (handle ||
      apcExtension::PrimeLibrary.empty() ||
      !apcExtension::Enable) {
    return;
  }
  BootStats::Block timer("loading APC data",
                         RuntimeOption::ServerExecutionMode());
  if (apc_store().primeFromSnapshot(apcExtension::PrimeLibrary.c_str())) {
    return;
  }
  Logger::Info("Fall back to shared object format");
  handle = dlopen(apcExtension::PrimeLibrary.c_str(), RTLD_LAZY);
  if (!handle) {
    throw Exception("Unable to open apc prime library %s: %s",
                    apcExtension::PrimeLibrary.c_str(), dlerror());
  }

  auto upgradeDest = apcExtension::PrimeLibraryUpgradeDest;
  if (!upgradeDest.empty()) {
    thread = 1; // SnapshotBuilder is not (yet) thread-safe.
    // TODO(9755792): Ensure APCFileStorage is enabled.
  }

  if (thread <= 1) {
    apc_load_func(handle, "_apc_load_all")();
  } else {
    int count = ((int(*)())apc_load_func(handle, "_apc_load_count"))();

    std::vector<std::shared_ptr<ApcLoadJob>> jobs;
    jobs.reserve(count);
    for (int i = 0; i < count; i++) {
      jobs.push_back(std::make_shared<ApcLoadJob>(handle, i));
    }
    JobDispatcher<ApcLoadJob, ApcLoadWorker>(std::move(jobs), thread).run();
  }

  apc_store().primeDone();
  if (!upgradeDest.empty()) {
    s_snapshotBuilder.writeToFile(upgradeDest);
  }

  // We've copied all the data out, so close it out.
  dlclose(handle);
#endif
}
