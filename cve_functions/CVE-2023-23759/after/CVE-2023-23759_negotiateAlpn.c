static Optional<std::string> negotiateAlpn(
    const ClientHello& chlo,
    folly::Optional<std::string> zeroRttAlpn,
    const FizzServerContext& context) {
  auto ext = getExtension<ProtocolNameList>(chlo.extensions);
  std::vector<std::string> clientProtocols;
  // Check whether client supports ALPN
  if (ext) {
    for (auto& protocol : ext->protocol_name_list) {
      clientProtocols.push_back(protocol.name->moveToFbString().toStdString());
    }
  } else {
    VLOG(6) << "Client did not send ALPN extension";
    if (context.getAlpnMode() == AlpnMode::Required) {
      throw FizzException(
          "ALPN is required", AlertDescription::no_application_protocol);
    }
    return folly::none;
  }

  // Since both support ALPN, check whether the protocols match.
  // Server's support for ALPN is to be enforced at the configuration.
  auto selected = context.negotiateAlpn(clientProtocols, zeroRttAlpn);
  if (!selected) {
    VLOG(6) << "ALPN mismatch";
    if (context.getAlpnMode() != AlpnMode::AllowMismatch) {
      auto msg = context.getAlpnMode() == AlpnMode::Optional
          ? "Unable to negotiate ALPN, as required by policy. policy=AlpnMode::Optional"
          : "Unable to negotiate ALPN, as required by policy. policy=AlpnMode::Required";
      throw FizzException(msg, AlertDescription::no_application_protocol);
    }
  } else {
    VLOG(6) << "ALPN: " << *selected;
  }
  return selected;
}
