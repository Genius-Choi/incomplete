static SemiFuture<Optional<WriteToSocket>> generateTicket(
    const State& state,
    const std::vector<uint8_t>& resumptionMasterSecret,
    Buf appToken = nullptr) {
  auto ticketCipher = state.context()->getTicketCipher();

  if (!ticketCipher || *state.pskType() == PskType::NotSupported) {
    return folly::none;
  }

  Buf resumptionSecret;
  auto ticketNonce = folly::IOBuf::create(0);
  resumptionSecret = state.keyScheduler()->getResumptionSecret(
      folly::range(resumptionMasterSecret), ticketNonce->coalesce());

  ResumptionState resState;
  resState.version = *state.version();
  resState.cipher = *state.cipher();
  resState.resumptionSecret = std::move(resumptionSecret);
  resState.serverCert = state.serverCert();
  resState.clientCert = state.clientCert();
  resState.alpn = state.alpn();
  resState.ticketAgeAdd = state.context()->getFactory()->makeTicketAgeAdd();
  resState.ticketIssueTime = state.context()->getClock().getCurrentTime();
  resState.appToken = std::move(appToken);
  resState.handshakeTime = *state.handshakeTime();

  auto ticketFuture = ticketCipher->encrypt(std::move(resState));
  return runOnCallerIfComplete(
      state.executor(),
      std::move(ticketFuture),
      [&state,
       ticketAgeAdd = resState.ticketAgeAdd,
       ticketNonce = std::move(ticketNonce)](
          Optional<std::pair<Buf, std::chrono::seconds>> ticket) mutable
      -> Optional<WriteToSocket> {
        if (!ticket) {
          return folly::none;
        }
        return writeNewSessionTicket(
            *state.context(),
            *state.writeRecordLayer(),
            ticket->second,
            ticketAgeAdd,
            std::move(ticketNonce),
            std::move(ticket->first),
            *state.version());
      });
}
