                   handshakeTime](Optional<Buf> sig) mutable {
                    Optional<Buf> encodedCertificateVerify;
                    if (sig) {
                      encodedCertificateVerify = getCertificateVerify(
                          *sigScheme, std::move(*sig), *handshakeContext);
                    }

                    auto encodedFinished = Protocol::getFinished(
                        folly::range(handshakeWriteSecret.secret),
                        *handshakeContext);

                    folly::IOBufQueue combined;
                    if (encodedCertificate) {
                      if (encodedCertRequest) {
                        combined.append(std::move(encodedEncryptedExt));
                        combined.append(std::move(*encodedCertRequest));
                        combined.append(std::move(*encodedCertificate));
                        combined.append(std::move(*encodedCertificateVerify));
                        combined.append(std::move(encodedFinished));
                      } else {
                        combined.append(std::move(encodedEncryptedExt));
                        combined.append(std::move(*encodedCertificate));
                        combined.append(std::move(*encodedCertificateVerify));
                        combined.append(std::move(encodedFinished));
                      }
                    } else {
                      combined.append(std::move(encodedEncryptedExt));
                      combined.append(std::move(encodedFinished));
                    }

                    // Some middleboxes appear to break if the first encrypted
                    // record is larger than ~1300 bytes (likely if it does not
                    // fit in the first packet).
                    auto serverEncrypted =
                        handshakeWriteRecordLayer->writeHandshake(
                            combined.splitAtMost(1000));
                    if (!combined.empty()) {
                      auto splitRecord =
                          handshakeWriteRecordLayer->writeHandshake(
                              combined.move());
                      // Split record must have the same encryption level as the
                      // main handshake.
                      DCHECK(
                          splitRecord.encryptionLevel ==
                          serverEncrypted.encryptionLevel);
                      serverEncrypted.data->prependChain(
                          std::move(splitRecord.data));
                    }

                    WriteToSocket serverFlight;
                    serverFlight.contents.emplace_back(
                        state.writeRecordLayer()->writeHandshake(
                            std::move(encodedServerHello)));
                    if (legacySessionId && !legacySessionId->empty()) {
                      TLSContent ccsWrite;
                      ccsWrite.encryptionLevel = EncryptionLevel::Plaintext;
                      ccsWrite.contentType = ContentType::change_cipher_spec;
                      ccsWrite.data =
                          folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);
                      serverFlight.contents.emplace_back(std::move(ccsWrite));
                    }
                    serverFlight.contents.emplace_back(
                        std::move(serverEncrypted));

                    scheduler->deriveMasterSecret();
                    auto clientFinishedContext =
                        handshakeContext->getHandshakeContext();
                    auto exporterMasterVector = scheduler->getSecret(
                        MasterSecrets::ExporterMaster,
                        clientFinishedContext->coalesce());
                    auto exporterMaster = folly::IOBuf::copyBuffer(
                        folly::range(exporterMasterVector.secret));

                    scheduler->deriveAppTrafficSecrets(
                        clientFinishedContext->coalesce());
                    auto appTrafficWriteRecordLayer =
                        state.context()
                            ->getFactory()
                            ->makeEncryptedWriteRecordLayer(
                                EncryptionLevel::AppTraffic);
                    appTrafficWriteRecordLayer->setProtocolVersion(version);
                    auto writeSecret = scheduler->getSecret(
                        AppTrafficSecrets::ServerAppTraffic);
                    Protocol::setAead(
                        *appTrafficWriteRecordLayer,
                        cipher,
                        folly::range(writeSecret.secret),
                        *state.context()->getFactory(),
                        *scheduler);

                    // If we have previously dealt with early data (before a
                    // HelloRetryRequest), don't overwrite the previous result.
                    auto earlyDataTypeSave = state.earlyDataType()
                        ? *state.earlyDataType()
                        : earlyDataType;

                    SecretAvailable handshakeReadSecretAvailable(
                        std::move(handshakeReadSecret));
                    SecretAvailable handshakeWriteSecretAvailable(
                        std::move(handshakeWriteSecret));
                    SecretAvailable appWriteSecretAvailable(
                        std::move(writeSecret));

                    // Save all the necessary state except for the read record
                    // layer, which is done separately as it varies if early
                    // data was accepted.
                    MutateState saveState(
                        [appTrafficWriteRecordLayer =
                             std::move(appTrafficWriteRecordLayer),
                         handshakeContext = std::move(handshakeContext),
                         scheduler = std::move(scheduler),
                         exporterMaster = std::move(exporterMaster),
                         serverCert = std::move(serverCert),
                         clientCert = std::move(clientCert),
                         cipher,
                         group,
                         sigScheme,
                         clientHandshakeSecret =
                             std::move(clientHandshakeSecret),
                         pskType,
                         pskMode,
                         version,
                         keyExchangeType,
                         alpn = std::move(alpn),
                         earlyDataTypeSave,
                         replayCacheResult,
                         clockSkew,
                         appToken = std::move(appToken),
                         serverCertCompAlgo,
                         echStatus,
                         clientRandom = std::move(clientRandom),
                         handshakeTime = std::move(handshakeTime)](
                            State& newState) mutable {
                          newState.writeRecordLayer() =
                              std::move(appTrafficWriteRecordLayer);
                          newState.handshakeContext() =
                              std::move(handshakeContext);
                          newState.keyScheduler() = std::move(scheduler);
                          newState.exporterMasterSecret() =
                              std::move(exporterMaster);
                          newState.serverCert() = std::move(*serverCert);
                          newState.clientCert() = std::move(clientCert);
                          newState.version() = version;
                          newState.cipher() = cipher;
                          newState.group() = group;
                          newState.sigScheme() = sigScheme;
                          newState.clientHandshakeSecret() =
                              std::move(clientHandshakeSecret);
                          newState.pskType() = pskType;
                          newState.pskMode() = pskMode;
                          newState.keyExchangeType() = keyExchangeType;
                          newState.earlyDataType() = earlyDataTypeSave;
                          newState.replayCacheResult() = replayCacheResult;
                          newState.alpn() = std::move(alpn);
                          newState.clientClockSkew() = clockSkew;
                          newState.appToken() = std::move(appToken);
                          newState.serverCertCompAlgo() = serverCertCompAlgo;
                          newState.handshakeTime() = std::move(handshakeTime);
                          newState.clientRandom() = std::move(clientRandom);
                          newState.echStatus() = echStatus;
                          newState.echState() = folly::none;
                        });

                    if (earlyDataType == EarlyDataType::Accepted) {
                      if (state.context()->getOmitEarlyRecordLayer()) {
                        return actions(
                            MutateState([handshakeReadRecordLayer = std::move(
                                             handshakeReadRecordLayer),
                                         earlyExporterMaster =
                                             std::move(earlyExporterMaster)](
                                            State& newState) mutable {
                              newState.readRecordLayer() =
                                  std::move(handshakeReadRecordLayer);
                              newState.earlyExporterMasterSecret() =
                                  std::move(earlyExporterMaster);
                            }),
                            std::move(saveState),
                            std::move(*earlyReadSecretAvailable),
                            std::move(handshakeReadSecretAvailable),
                            std::move(handshakeWriteSecretAvailable),
                            std::move(appWriteSecretAvailable),
                            std::move(serverFlight),
                            MutateState(
                                &Transition<StateEnum::ExpectingFinished>),
                            ReportEarlyHandshakeSuccess());

                      } else {
                        return actions(
                            MutateState([handshakeReadRecordLayer = std::move(
                                             handshakeReadRecordLayer),
                                         earlyReadRecordLayer =
                                             std::move(earlyReadRecordLayer),
                                         earlyExporterMaster =
                                             std::move(earlyExporterMaster)](
                                            State& newState) mutable {
                              newState.readRecordLayer() =
                                  std::move(earlyReadRecordLayer);
                              newState.handshakeReadRecordLayer() =
                                  std::move(handshakeReadRecordLayer);
                              newState.earlyExporterMasterSecret() =
                                  std::move(earlyExporterMaster);
                            }),
                            std::move(saveState),
                            std::move(*earlyReadSecretAvailable),
                            std::move(handshakeReadSecretAvailable),
                            std::move(handshakeWriteSecretAvailable),
                            std::move(appWriteSecretAvailable),
                            std::move(serverFlight),
                            MutateState(
                                &Transition<StateEnum::AcceptingEarlyData>),
                            ReportEarlyHandshakeSuccess());
                      }
                    } else {
                      auto transition = requestClientAuth
                          ? Transition<StateEnum::ExpectingCertificate>
                          : Transition<StateEnum::ExpectingFinished>;
                      return actions(
                          MutateState([handshakeReadRecordLayer =
                                           std::move(handshakeReadRecordLayer)](
                                          State& newState) mutable {
                            newState.readRecordLayer() =
                                std::move(handshakeReadRecordLayer);
                          }),
                          std::move(saveState),
                          std::move(handshakeReadSecretAvailable),
                          std::move(handshakeWriteSecretAvailable),
                          std::move(appWriteSecretAvailable),
                          std::move(serverFlight),
                          MutateState(transition));
                    }
                  });
