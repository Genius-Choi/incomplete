constructPresentationContext(unsigned char associateType,
           unsigned char contextID,
           unsigned char reason, char *abstractSyntax,
           LST_HEAD ** proposedTransferSyntax, char *acceptedTransferSyntax,
           PRV_PRESENTATIONCONTEXTITEM * context, unsigned long *rtnLen)
{
    OFCondition cond = EC_Normal;
    unsigned long length;
    /* Subitem pointer created for transfer syntax items */
    DUL_SUBITEM * subItem;
    /* Pointer to loop through list of transfer syntaxes */
    DUL_TRANSFERSYNTAX * transfer;

    *rtnLen = 0;

    if (associateType == DUL_TYPEASSOCIATERQ)
        context->type = DUL_TYPEPRESENTATIONCONTEXTRQ;
    else
        context->type = DUL_TYPEPRESENTATIONCONTEXTAC;

    context->rsv1 = 0;
    context->length = 0;
    context->contextID = contextID;
    context->rsv2 = 0;
    context->result = reason;
    context->rsv3 = 0;
    context->length += 4;
    *rtnLen += 8;

    if (associateType == DUL_TYPEASSOCIATERQ) {
        cond = constructSubItem(abstractSyntax, DUL_TYPEABSTRACTSYNTAX,
                &(context->abstractSyntax), &length);
        if (cond.bad())
            return cond;
        context->length += (unsigned short) length;
        *rtnLen += length;
    } else
        context->abstractSyntax.length = 0;

    context->transferSyntaxList = LST_Create();
    if (context->transferSyntaxList == NULL) return EC_MemoryExhausted;

    if (associateType == DUL_TYPEASSOCIATERQ) {
        transfer = (DUL_TRANSFERSYNTAX*)LST_Head(proposedTransferSyntax);
        if (transfer == NULL) return DUL_LISTERROR;
        (void) LST_Position(proposedTransferSyntax, (LST_NODE*)transfer);

        while (transfer != NULL) {
            subItem = (DUL_SUBITEM *) malloc(sizeof(DUL_SUBITEM));
            if (subItem == NULL) return EC_MemoryExhausted;

            cond = constructSubItem(transfer->transferSyntax,
                    DUL_TYPETRANSFERSYNTAX, subItem, &length);
            if (cond.bad())
            {
                free(subItem);
                return cond;
            }

            LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);

            context->length += (unsigned short) length;
            *rtnLen += length;
            transfer = (DUL_TRANSFERSYNTAX*)LST_Next(proposedTransferSyntax);
        }
    } else {
        subItem = (DUL_SUBITEM *) malloc(sizeof(*subItem));
        if (subItem == NULL) return EC_MemoryExhausted;
        cond = constructSubItem(acceptedTransferSyntax,
                DUL_TYPETRANSFERSYNTAX, subItem, &length);
        if (cond.bad()) {
            free(subItem);
            return cond;
        }

        LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);

        context->length += (unsigned short) length;
        *rtnLen += length;
    }

    return EC_Normal;
}
