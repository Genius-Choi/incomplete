void *decompress_file_thread(void *arg)
{
    size_t thread_id = (size_t)arg;
    bool just_recovered_block = false;
    recovery_file_written = 0;

    update_statusbar("d", true);

    for(;;)
    {
        unsigned long long my_chunk;
        unsigned int crc_r, crc_original;
        size_t decomp_size;

        pthread_mutex_lock(&disk_read_mutex);
        update_statusbar("d", false);

        if (end_of_file)
        {
            pthread_mutex_unlock(&disk_read_mutex);
            break;
        }

        if(!just_recovered_block)
        {
            // read NEWBNEWB or ENDSENDS
            try_aread(src[thread_id], 1);
            try_aread(tmp, 7);
        }

        if (*src[thread_id] == 'N') // NEWBNEWB
        {
            fread64(); // reset pos
        }
        else if(*src[thread_id] == 'E') // ENDSENDS
        {
            end_of_file = true;
            try_aread(tmp, 8); // reset pos
            files++;
            pthread_mutex_unlock(&disk_read_mutex);
            break;
        }
        else if(just_recovered_block)
            just_recovered_block = false;
        else
            abort("Data error, not recoverable"); // todo, it is recoverable, but code is not implemented yet

        crc_original = fread32();
        try_aread(src[thread_id], 9);
        if (QLZ_SIZE_COMPRESSED(src[thread_id]) > compress_chunk_size + QLZ_SIZE_OVERHEAD)
            abort("Data error, not recoverable"); // todo, it is recoverable, but code is not implemented yet

        try_aread(src[thread_id] + 9, QLZ_SIZE_COMPRESSED(src[thread_id]) - 9);

        my_chunk = chunks_read;
        chunks_read++;
        pthread_mutex_unlock(&disk_read_mutex);

        crc_r = adler((unsigned char *)src[thread_id], QLZ_SIZE_COMPRESSED(src[thread_id]), 0x00010000);
        if (crc_r != crc_original)
        {
            just_recovered_block = true;
            recover();
        }
        decomp_size = QLZ_DECOMPRESS(src[thread_id], dst[thread_id], scratch[thread_id]);

        // Could be beautified into not using yield. Schedules writes to occur in correct order.
        for(;;)
        {
            pthread_mutex_lock(&disk_write_mutex);
            if(my_chunk == chunks_written)
                break;
            else
            {
                pthread_mutex_unlock(&disk_write_mutex);
                utils_yield();
            }
        }
        chunks_written++;
        if(!just_recovered_block)
        {
            payload_counter += decomp_size;
            recovery_file_written += decomp_size;
            try_awrite(dst[thread_id], decomp_size);
        }
        pthread_mutex_unlock(&disk_write_mutex);
    }
    return 0;
}
