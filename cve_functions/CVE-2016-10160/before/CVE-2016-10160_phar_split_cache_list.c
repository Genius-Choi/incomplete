static void phar_split_cache_list(TSRMLS_D) /* {{{ */
{
	char *tmp;
	char *key, *lasts, *end;
	char ds[2];
	phar_archive_data *phar;
	uint i = 0;

	if (!PHAR_GLOBALS->cache_list || !(PHAR_GLOBALS->cache_list[0])) {
		return;
	}

	ds[0] = DEFAULT_DIR_SEPARATOR;
	ds[1] = '\0';
	tmp = estrdup(PHAR_GLOBALS->cache_list);

	/* fake request startup */
	PHAR_GLOBALS->request_init = 1;
	if (zend_hash_init(&EG(regular_list), 0, NULL, NULL, 0) == SUCCESS) {
		EG(regular_list).nNextFreeElement=1;	/* we don't want resource id 0 */
	}

	PHAR_G(has_bz2) = zend_hash_exists(&module_registry, "bz2", sizeof("bz2"));
	PHAR_G(has_zlib) = zend_hash_exists(&module_registry, "zlib", sizeof("zlib"));
	/* these two are dummies and will be destroyed later */
	zend_hash_init(&cached_phars, sizeof(phar_archive_data*), zend_get_hash_value, destroy_phar_data,  1);
	zend_hash_init(&cached_alias, sizeof(phar_archive_data*), zend_get_hash_value, NULL, 1);
	/* these two are real and will be copied over cached_phars/cached_alias later */
	zend_hash_init(&(PHAR_GLOBALS->phar_fname_map), sizeof(phar_archive_data*), zend_get_hash_value, destroy_phar_data,  1);
	zend_hash_init(&(PHAR_GLOBALS->phar_alias_map), sizeof(phar_archive_data*), zend_get_hash_value, NULL, 1);
	PHAR_GLOBALS->manifest_cached = 1;
	PHAR_GLOBALS->persist = 1;

	for (key = php_strtok_r(tmp, ds, &lasts);
			key;
			key = php_strtok_r(NULL, ds, &lasts)) {
		end = strchr(key, DEFAULT_DIR_SEPARATOR);

		if (end) {
			if (SUCCESS == phar_open_from_filename(key, end - key, NULL, 0, 0, &phar, NULL TSRMLS_CC)) {
finish_up:
				phar->phar_pos = i++;
				php_stream_close(phar->fp);
				phar->fp = NULL;
			} else {
finish_error:
				PHAR_GLOBALS->persist = 0;
				PHAR_GLOBALS->manifest_cached = 0;
				efree(tmp);
				zend_hash_destroy(&(PHAR_G(phar_fname_map)));
				PHAR_GLOBALS->phar_fname_map.arBuckets = 0;
				zend_hash_destroy(&(PHAR_G(phar_alias_map)));
				PHAR_GLOBALS->phar_alias_map.arBuckets = 0;
				zend_hash_destroy(&cached_phars);
				zend_hash_destroy(&cached_alias);
				zend_hash_graceful_reverse_destroy(&EG(regular_list));
				memset(&EG(regular_list), 0, sizeof(HashTable));
				/* free cached manifests */
				PHAR_GLOBALS->request_init = 0;
				return;
			}
		} else {
			if (SUCCESS == phar_open_from_filename(key, strlen(key), NULL, 0, 0, &phar, NULL TSRMLS_CC)) {
				goto finish_up;
			} else {
				goto finish_error;
			}
		}
	}

	PHAR_GLOBALS->persist = 0;
	PHAR_GLOBALS->request_init = 0;
	/* destroy dummy values from before */
	zend_hash_destroy(&cached_phars);
	zend_hash_destroy(&cached_alias);
	cached_phars = PHAR_GLOBALS->phar_fname_map;
	cached_alias = PHAR_GLOBALS->phar_alias_map;
	PHAR_GLOBALS->phar_fname_map.arBuckets = 0;
	PHAR_GLOBALS->phar_alias_map.arBuckets = 0;
	zend_hash_graceful_reverse_destroy(&EG(regular_list));
	memset(&EG(regular_list), 0, sizeof(HashTable));
	efree(tmp);
}
