tport_t *tport_alloc_secondary(tport_primary_t *pri,
			       int socket,
			       int accepted,
			       char const **return_reason)
{
  tport_master_t *mr = pri->pri_master;
  tport_t *self;

  self = su_home_clone(mr->mr_home, pri->pri_vtable->vtp_secondary_size);

  if (self) {
    self->tp_refs = -1;			/* Freshly allocated  */
    self->tp_master = mr;
    self->tp_pri = pri;
    self->tp_params = pri->pri_params;
    self->tp_accepted = accepted != 0;
    self->tp_reusable = pri->pri_primary->tp_reusable;

    self->tp_magic = pri->pri_primary->tp_magic;

    self->tp_addrinfo->ai_addr = (void *)self->tp_addr;

    self->tp_socket = socket;

    self->tp_timer = su_timer_create(su_root_task(mr->mr_root), 0);
    self->tp_stime = self->tp_ktime = self->tp_rtime = su_now();

    if (pri->pri_vtable->vtp_init_secondary &&

		pri->pri_vtable->vtp_init_secondary(self, socket, accepted, return_reason) < 0) {
      if (pri->pri_vtable->vtp_deinit_secondary) {
        pri->pri_vtable->vtp_deinit_secondary(self);
      }
      su_timer_destroy(self->tp_timer);
      su_home_zap(self->tp_home);

      return NULL;
    }

    /* Set IP TOS if it is set in primary */
    tport_set_tos(socket,
		  pri->pri_primary->tp_addrinfo,
		  pri->pri_params->tpp_tos);
  }
  else {
    *return_reason = "malloc";
  }
  return self;
}
