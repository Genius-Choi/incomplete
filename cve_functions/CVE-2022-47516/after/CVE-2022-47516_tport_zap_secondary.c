void tport_zap_secondary(tport_t *self)
{
  tport_master_t *mr;

  if (self == NULL)
    return;

  /* Remove from rbtree */
  if (!tport_is_closed(self))
    tprb_remove(&self->tp_pri->pri_open, self);
  else
    tplist_remove(&self->tp_pri->pri_closed, self);

  if (self->tp_timer)
    su_timer_destroy(self->tp_timer), self->tp_timer = NULL;

  /* Do not deinit primary as secondary! */
  if (tport_is_secondary(self) && self->tp_pri->pri_vtable->vtp_deinit_secondary) {
    self->tp_pri->pri_vtable->vtp_deinit_secondary(self);
  }

  if (self->tp_msg) {
    msg_destroy(self->tp_msg), self->tp_msg = NULL;
    SU_DEBUG_3(("%s(%p): zapped partially received message\n",
		__func__, (void *)self));
  }

  if (tport_has_queued(self)) {
    size_t n = 0, i, N = self->tp_params->tpp_qsize;
    for (i = self->tp_qhead; self->tp_queue[i]; i = (i + 1) % N) {
      msg_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;
      n++;
    }
    SU_DEBUG_3(("%s(%p): zapped %lu queued messages\n",
		__func__, (void *)self, (LU)n));
  }

  if (self->tp_pused) {
    SU_DEBUG_3(("%s(%p): zapped while pending\n",
		__func__, (void *)self));
  }

  mr = self->tp_master;

#if HAVE_SOFIA_STUN
  tport_stun_server_remove_socket(self);
#endif

  if (self->tp_index)
    su_root_deregister(mr->mr_root, self->tp_index);
  self->tp_index = 0;
  if (self->tp_socket != INVALID_SOCKET)
    su_close(self->tp_socket);
  self->tp_socket = INVALID_SOCKET;

  decrementSecondaryCount(self);
  SU_DEBUG_4(("%s(%p): zap tport %p from " TPN_FORMAT ", count(wss) is %d, count(tcp) is %d\n", 
    __func__, (void *)self->tp_pri, (void *)self, TPN_ARGS(self->tp_name), wssCount, tcpCount));

  su_home_zap(self->tp_home);
}
