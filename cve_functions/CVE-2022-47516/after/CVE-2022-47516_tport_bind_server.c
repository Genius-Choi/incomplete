int tport_bind_server(tport_master_t *mr,
                      tp_name_t const *tpn,
                      char const * const transports[],
		      enum tport_via public,
		      tagi_t *tags)
{
  char hostname[TPORT_HOSTPORTSIZE];
  char const *canon = NULL, *host, *service;
  int error = 0, family = 0;
  tport_primary_t *pri = NULL, **tbf;
  su_addrinfo_t *ai, *res = NULL;
  unsigned port, port0, port1, old;
  unsigned short step = 0;

  bind6only_check(mr);

  (void)hostname;

  SU_DEBUG_5(("%s(%p) to " TPN_FORMAT "\n",
	      __func__, (void *)mr, TPN_ARGS(tpn)));

  if (tpn->tpn_host == NULL || strcmp(tpn->tpn_host, tpn_any) == 0) {
    /* Use a local IP address */
    host = NULL;
  }
#ifdef SU_HAVE_IN6
  else if (host_is_ip6_reference(tpn->tpn_host)) {
    /* Remove [] around IPv6 addresses. */
    size_t len = strlen(tpn->tpn_host);
    assert(len < sizeof hostname);
    host = memcpy(hostname, tpn->tpn_host + 1, len - 2);
    hostname[len - 2] = '\0';
  }
#endif
  else
    host = tpn->tpn_host;

  if (tpn->tpn_port != NULL && strlen(tpn->tpn_port) > 0 &&
      strcmp(tpn->tpn_port, tpn_any) != 0)
    service = tpn->tpn_port;
  else
    service = "";

  if (host && (strcmp(host, "0.0.0.0") == 0 || strcmp(host, "0") == 0))
    host = NULL, family = AF_INET;
#if SU_HAVE_IN6
  else if (host && strcmp(host, "::") == 0)
    host = NULL, family = AF_INET6;
#endif

  if (tpn->tpn_canon && strcmp(tpn->tpn_canon, tpn_any) &&
      (host || tpn->tpn_canon != tpn->tpn_host))
    canon = tpn->tpn_canon;

  if (tport_server_addrinfo(mr, canon, family,
			    host, service, tpn->tpn_proto,
			    transports, &res) < 0)
    return -1;

  for (tbf = &mr->mr_primaries; *tbf; tbf = &(*tbf)->pri_next)
    ;

  port = port0 = port1 = ntohs(((su_sockaddr_t *)res->ai_addr)->su_port);
  error = EPROTONOSUPPORT;

  /*
   * Loop until we can bind all the transports requested
   * by the transport user to the same port.
   */
  for (;;) {
    for (ai = res; ai; ai = ai->ai_next) {
      tp_name_t tpname[1];
      su_addrinfo_t ainfo[1];
      su_sockaddr_t su[1];
      tport_vtable_t const *vtable;

      vtable = tport_vtable_by_name(ai->ai_canonname, public);
      if (!vtable)
	continue;

      tport_addrinfo_copy(ainfo, su, sizeof su, ai);
      ainfo->ai_canonname = (char *)canon;
      su->su_port = htons(port);

      memcpy(tpname, tpn, sizeof tpname);
      tpname->tpn_canon = canon;
      tpname->tpn_host = host;

      SU_DEBUG_9(("%s(%p): calling tport_listen for %s\n",
		  __func__, (void *)mr, ai->ai_canonname));

      pri = tport_listen(mr, vtable, tpname, ainfo, tags);
      if (!pri) {
	switch (error = su_errno()) {
	case EADDRNOTAVAIL:	/* Not our address */
	case ENOPROTOOPT:	/* Protocol not supported */
	case ESOCKTNOSUPPORT:	/* Socket type not supported */
	  continue;
	default:
	  break;
	}
	break;
      }

      if (port0 == 0 && port == 0) {
	port = port1 = ntohs(su->su_port);
	assert(public != tport_type_server || port != 0);
      }
    }

    if (ai == NULL)
      break;

    while (*tbf)
      tport_zap_primary(*tbf);

    if (error != EADDRINUSE || port0 != 0 || port == 0)
      break;

    while (step == 0) {
      /* step should be relative prime to 65536 - 1024 */
      /* 65536 - 1024 = 7 * 3 * 3 * 1024 */
      step = su_randint(1, 65535 - 1024 - 1) | 1;
      if (step % 3 == 0)
	step = (step + 2) % (65536 - 1024);
      if (step % 7 == 0)
	step = (step + 2) % (65536 - 1024);
    }
    old = port; port += step; if (port >= 65536) port -= (65536 - 1024);

    if (port == port1)		/* All ports in use! */
      break;

    SU_DEBUG_3(("%s(%p): cannot bind all transports to port %u, trying %u\n",
		__func__, (void *)mr, old, port));
  }

  tport_freeaddrinfo(res);

  if (!*tbf) {
    su_seterrno(error);
    return -1;
  }

  return 0;
}
