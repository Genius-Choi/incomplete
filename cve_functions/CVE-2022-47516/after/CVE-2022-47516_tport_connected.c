static int tport_connected(su_root_magic_t *magic, su_wait_t *w, tport_t *self)
{
  int events = su_wait_events(w, self->tp_socket);
  tport_master_t *mr = self->tp_master;
  su_wait_t wait[1] =  { SU_WAIT_INIT };
  int su_wait_create_ret;

  int error;

  SU_DEBUG_7(("tport_connected(%p): events%s%s\n", (void *)self,
	      events & SU_WAIT_CONNECT ? " CONNECTED" : "",
	      events & SU_WAIT_ERR ? " ERR" : ""));

#if HAVE_POLL
  assert(w->fd == self->tp_socket);
#endif

  if (events & SU_WAIT_ERR)
    tport_error_event(self);

  if (!(events & SU_WAIT_CONNECT) || self->tp_closed) {
    return 0;
  }

  error = su_soerror(self->tp_socket);
  if (error) {
    tport_error_report(self, error, NULL);
    return 0;
  }

  self->tp_is_connected = 1;

  su_root_deregister(mr->mr_root, self->tp_index);
  self->tp_index = -1;
  self->tp_events = SU_WAIT_IN | SU_WAIT_ERR | SU_WAIT_HUP;

  if ((su_wait_create_ret = su_wait_create(wait, self->tp_socket, self->tp_events)) == -1 ||
      (self->tp_index = su_root_register(mr->mr_root,
					 wait, tport_wakeup, self, 0))
      == -1) {
    if (su_wait_create_ret == 0) {
      su_wait_destroy(wait);
    }
    tport_close(self);
    tport_set_secondary_timer(self);
    return 0;
  }

  if (tport_has_queued(self))
    tport_send_event(self);
  else
    tport_set_secondary_timer(self);

  return 0;
}
