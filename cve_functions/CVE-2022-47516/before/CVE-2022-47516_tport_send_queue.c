void tport_send_queue(tport_t *self)
{
  msg_t *msg;
  msg_iovec_t *iov;
  size_t i, iovused, n, total;
  unsigned short qhead = self->tp_qhead, N = self->tp_params->tpp_qsize;

  assert(self->tp_queue && self->tp_queue[qhead]);

  msg = self->tp_queue[qhead];

  iov = self->tp_unsent, self->tp_unsent = NULL;
  iovused = self->tp_unsentlen, self->tp_unsentlen = 0;

  if (iov && iovused) {
    ssize_t e;

    self->tp_stime = self->tp_ktime = su_now();

    e = tport_vsend(self, msg, self->tp_name, iov, iovused, NULL);

    if (e == -1)				/* XXX */
      return;

    n = (size_t)e;

    if (n > 0 && self->tp_master->mr_log && self->tp_slogged != msg) {
      tport_log_msg(self, msg, "send", "to", self->tp_stime);
      self->tp_slogged = msg;
    }

    for (i = 0, total = 0; i < iovused; i++) {
      if (total + (size_t)iov[i].mv_len > n) {
	iov[i].mv_len -= (su_ioveclen_t)(n - total);
	iov[i].mv_base = (char *)iov[i].mv_base + (n - total);

	self->tp_unsent = iov + i;
	self->tp_unsentlen = iovused - i;

	return;
      }
      total += iov[i].mv_len;
    }
    assert(total == n);

    /* We have sent a complete message */

    self->tp_queue[qhead] = NULL;
    tport_sent_message(self, msg, 0);
    msg_destroy(msg);

    qhead = (qhead + 1) % N;
  }

  while (msg_is_prepared(msg = self->tp_queue[self->tp_qhead = qhead])) {
    /* XXX - what about errors? */
    tport_send_msg(self, msg, self->tp_name, NULL);
    if (self->tp_unsent)
      return;

    msg = self->tp_queue[qhead]; /* tport_send_msg() may flush queue! */
    self->tp_queue[qhead] = NULL;
    msg_destroy(msg);
    qhead = (qhead + 1) % N;
  }

  /* No more send event(s)? */
  tport_set_events(self, 0, SU_WAIT_OUT);
}
