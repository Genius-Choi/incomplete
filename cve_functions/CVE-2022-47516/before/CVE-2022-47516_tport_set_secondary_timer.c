int tport_set_secondary_timer(tport_t *self)
{
  su_time_t const infinity = { ULONG_MAX, 999999 };
  su_time_t target = infinity;
  char const *why = "not specified";
  su_timer_f timer = tport_secondary_timer;

  if (!tport_is_secondary(self))
    return 0;

  if (tport_is_closed(self)) {
    if (self->tp_refs == 0) {
      SU_DEBUG_7(("tport(%p): set timer at %u ms because %s\n",
				  (void *)self, 0, "zap"));
      su_timer_set_interval(self->tp_timer, timer, self, 0);
    }
    else
      su_timer_reset(self->tp_timer);

    return 0;
  }

  if (self->tp_params->tpp_idle != UINT_MAX) {
    if (self->tp_refs == 0 &&
	self->tp_msg == NULL && !tport_has_queued(self)) {
      if (su_time_cmp(self->tp_stime, self->tp_rtime) < 0) {
	target = su_time_add(self->tp_rtime, self->tp_params->tpp_idle);
	why = "idle since recv";
      }
      else {
	target = su_time_add(self->tp_stime, self->tp_params->tpp_idle);
	why = "idle since send";
      }
    }
  }

  if (self->tp_pri->pri_vtable->vtp_next_secondary_timer)
    self->tp_pri->pri_vtable->
      vtp_next_secondary_timer(self, &target, &why);

  if (su_time_cmp(target, infinity)) {
    SU_DEBUG_7(("tport(%p): set timer at %ld ms because %s\n",
		(void *)self, su_duration(target, su_now()), why));
    su_timer_set_at(self->tp_timer, timer, self, target);
  }
  else {
    SU_DEBUG_9(("tport(%p): reset timer\n", (void *)self));
    su_timer_reset(self->tp_timer);
  }

  return 0;
}
