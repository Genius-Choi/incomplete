njs_generate_switch_case_after(njs_vm_t *vm, njs_generator_t *generator,
    njs_parser_node_t *branch)
{
    njs_int_t                   ret;
    njs_parser_node_t           *node;
    njs_generator_patch_t       *patch;
    njs_vmcode_equal_jump_t     *equal;
    njs_generator_switch_ctx_t  *ctx;

    ctx = generator->context;
    node = branch->right;

    njs_generate_code(generator, njs_vmcode_equal_jump_t, equal,
                      NJS_VMCODE_IF_EQUAL_JUMP, 3, branch);
    equal->offset = offsetof(njs_vmcode_equal_jump_t, offset);
    equal->value1 = ctx->index;
    equal->value2 = node->left->index;

    ret = njs_generate_node_index_release(vm, generator, node->left);
    if (njs_slow_path(ret != NJS_OK)) {
        return ret;
    }

    patch = njs_mp_alloc(vm->mem_pool, sizeof(njs_generator_patch_t));
    if (njs_slow_path(patch == NULL)) {
        return NJS_ERROR;
    }

    patch->jump_offset = njs_code_offset(generator, equal)
                         + offsetof(njs_vmcode_equal_jump_t, offset);
    patch->label = no_label;

    *ctx->last = patch;
    ctx->last = &patch->next;

    if (branch->left == NULL) {
        return njs_generator_stack_pop(vm, generator, NULL);
    }

    branch = branch->left;

    if (branch->token_type == NJS_TOKEN_DEFAULT) {
        branch = branch->left;

        if (branch == NULL) {
            return njs_generator_stack_pop(vm, generator, NULL);
        }
    }

    njs_generator_next(generator, njs_generate, branch->right->left);

    return njs_generator_after(vm, generator,
                               njs_queue_first(&generator->stack), branch,
                               njs_generate_switch_case_after, ctx, 0);
}
