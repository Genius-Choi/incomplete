virtio_net_tx_thread(void *param)
{
	struct virtio_net *net = param;
	struct virtio_vq_info *vq = &net->queues[VIRTIO_NET_TXQ];

	/*
	 * Let us wait till the tx queue pointers get initialised &
	 * first tx signaled
	 */
	pthread_mutex_lock(&net->tx_mtx);

	while (!net->closing && !vq_ring_ready(vq))
		pthread_cond_wait(&net->tx_cond, &net->tx_mtx);

	if (net->closing) {
		WPRINTF(("vtnet tx thread closing...\n"));
		pthread_mutex_unlock(&net->tx_mtx);
		return NULL;
	}

	for (;;) {
		/* note - tx mutex is locked here */
		net->tx_in_progress = 0;

		/*
		 * Checking the avail ring here serves two purposes:
		 *  - avoid vring processing due to spurious wakeups
		 *  - catch missing notifications before acquiring tx_mtx
		 */
		while (net->resetting || !vq_has_descs(vq)) {
			vq_clear_used_ring_flags(&net->base, vq);
			/* memory barrier */
			mb();
			if (!net->resetting && vq_has_descs(vq))
				break;

			pthread_cond_wait(&net->tx_cond, &net->tx_mtx);

			if (net->closing) {
				WPRINTF(("vtnet tx thread closing...\n"));
				pthread_mutex_unlock(&net->tx_mtx);
				return NULL;
			}
		}

		vq->used->flags |= VRING_USED_F_NO_NOTIFY;
		net->tx_in_progress = 1;
		pthread_mutex_unlock(&net->tx_mtx);

		do {
			/*
			 * Run through entries, placing them into
			 * iovecs and sending when an end-of-packet
			 * is found
			 */
			virtio_net_proctx(net, vq);
		} while (vq_has_descs(vq));

		/*
		 * Generate an interrupt if needed.
		 */
		vq_endchains(vq, 1);

		pthread_mutex_lock(&net->tx_mtx);
	}
}
