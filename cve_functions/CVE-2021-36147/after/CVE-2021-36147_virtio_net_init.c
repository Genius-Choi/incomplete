virtio_net_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	MD5_CTX mdctx;
	unsigned char digest[16];
	char nstr[80];
	char tname[MAXCOMLEN + 1];
	struct virtio_net *net;
	char *devname = NULL;
	char *vtopts;
	char *opt;
	int mac_provided;
	pthread_mutexattr_t attr;
	int rc;

	net = calloc(1, sizeof(struct virtio_net));
	if (!net) {
		WPRINTF(("virtio_net: calloc returns NULL\n"));
		return -1;
	}

	/* init mutex attribute properly to avoid deadlock */
	rc = pthread_mutexattr_init(&attr);
	if (rc)
		DPRINTF(("mutexattr init failed with erro %d!\n", rc));
	rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
	if (rc)
		DPRINTF(("virtio_net: mutexattr_settype failed with "
			"error %d!\n", rc));

	rc = pthread_mutex_init(&net->mtx, &attr);
	if (rc)
		DPRINTF(("virtio_net: pthread_mutex_init failed with "
			"error %d!\n", rc));

	/*
	 * Read the MAC address if specified
	 */
	mac_provided = 0;
	net->vhost_net = NULL;
	if (opts != NULL) {
		int err;

		devname = vtopts = strdup(opts);
		if (!devname) {
			WPRINTF(("virtio_net: strdup returns NULL\n"));
			free(net);
			return -1;
		}

		(void) strsep(&vtopts, ",");

		while ((opt = strsep(&vtopts, ",")) != NULL) {
			if (strcmp("vhost", opt) == 0)
				net->use_vhost = true;
			else {
				err = virtio_net_parsemac(opt,
					net->config.mac);
				if (err != 0) {
					free(devname);
					free(net);
					return err;
				}
				mac_provided = 1;
			}
		}
	}

	virtio_linkup(&net->base, &virtio_net_ops, net, dev, net->queues,
		      net->use_vhost ? BACKEND_VHOST : BACKEND_VBSU);
	net->base.mtx = &net->mtx;
	net->base.device_caps = VIRTIO_NET_S_HOSTCAPS;

	net->queues[VIRTIO_NET_RXQ].qsize = VIRTIO_NET_RINGSZ;
	net->queues[VIRTIO_NET_RXQ].notify = virtio_net_ping_rxq;
	net->queues[VIRTIO_NET_TXQ].qsize = VIRTIO_NET_RINGSZ;
	net->queues[VIRTIO_NET_TXQ].notify = virtio_net_ping_txq;
#ifdef notyet
	net->queues[VIRTIO_NET_CTLQ].qsize = VIRTIO_NET_RINGSZ;
	net->queues[VIRTIO_NET_CTLQ].notify = virtio_net_ping_ctlq;
#endif

	/*
	 * Attempt to open the tap device
	 */
	net->tapfd = -1;

	if (!devname) {
		WPRINTF(("virtio_net: devname NULL\n"));
		free(net);
		return -1;
	}

	if ((strstr(devname, "tap") != NULL) ||
	    (strncmp(devname, "vmnet", 5) == 0))
		virtio_net_tap_setup(net, devname);

	free(devname);

	/*
	 * The default MAC address is the standard NetApp OUI of 00-a0-98,
	 * followed by an MD5 of the PCI slot/func number and dev name
	 */
	if (!mac_provided) {
		snprintf(nstr, sizeof(nstr), "%d-%d-%s", dev->slot,
		    dev->func, mac_seed);

		MD5_Init(&mdctx);
		MD5_Update(&mdctx, nstr, strnlen(nstr, sizeof(nstr)));
		MD5_Final(digest, &mdctx);

		net->config.mac[0] = 0x00;
		net->config.mac[1] = 0x16;
		net->config.mac[2] = 0x3E;
		net->config.mac[3] = digest[0];
		net->config.mac[4] = digest[1];
		net->config.mac[5] = digest[2];
	}

	/* initialize config space */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_NET);
	pci_set_cfgdata16(dev, PCIR_VENDOR, VIRTIO_VENDOR);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_NETWORK);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_NET);
	if (is_winvm == true)
		pci_set_cfgdata16(dev, PCIR_SUBVEND_0, ORACLE_VENDOR_ID);
	else
		pci_set_cfgdata16(dev, PCIR_SUBVEND_0, VIRTIO_VENDOR);

	/* Link is up if we managed to open tap device */
	net->config.status = (opts == NULL || net->tapfd >= 0);

	/* use BAR 1 to map MSI-X table and PBA, if we're using MSI-X */
	if (virtio_interrupt_init(&net->base, virtio_uses_msix())) {
		if (net)
			free(net);
		return -1;
	}

	/* use BAR 0 to map config regs in IO space */
	virtio_set_io_bar(&net->base, 0);

	net->resetting = 0;
	net->closing = 0;

	net->rx_merge = 1;
	net->rx_vhdrlen = sizeof(struct virtio_net_rxhdr);
	net->rx_in_progress = 0;
	pthread_mutex_init(&net->rx_mtx, NULL);

	/*
	 * Initialize tx semaphore & spawn TX processing thread.
	 * As of now, only one thread for TX desc processing is
	 * spawned.
	 */
	net->tx_in_progress = 0;
	pthread_mutex_init(&net->tx_mtx, NULL);
	pthread_cond_init(&net->tx_cond, NULL);
	pthread_create(&net->tx_tid, NULL, virtio_net_tx_thread,
		       (void *)net);
	snprintf(tname, sizeof(tname), "vtnet-%d:%d tx", dev->slot,
		 dev->func);
	pthread_setname_np(net->tx_tid, tname);

	return 0;
}
