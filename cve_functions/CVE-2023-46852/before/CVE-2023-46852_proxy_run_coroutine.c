int proxy_run_coroutine(lua_State *Lc, mc_resp *resp, io_pending_proxy_t *p, conn *c) {
    int nresults = 0;
    int cores = lua_resume(Lc, NULL, 1, &nresults);
    size_t rlen = 0;

    if (cores == LUA_OK) {
        WSTAT_DECR(c->thread, proxy_req_active, 1);
        int type = lua_type(Lc, 1);
        P_DEBUG("%s: coroutine completed. return type: %d\n", __func__, type);
        if (type == LUA_TUSERDATA) {
            mcp_resp_t *r = luaL_checkudata(Lc, 1, "mcp.response");
            _set_noreply_mode(resp, r);
            if (r->status != MCMC_OK && r->resp.type != MCMC_RESP_ERRMSG) {
                proxy_out_errstring(resp, PROXY_SERVER_ERROR, "backend failure");
            } else if (r->cresp) {
                mc_resp *tresp = r->cresp;
                // The internal cache handler has created a resp we want to swap in
                // here. It would be fastest to swap *resp's position in the
                // link but if the set is deep this would instead be slow, so
                // we copy over details from this temporary resp instead.
                assert(c != NULL);

                // So far all we fill is the wbuf and some iov's? so just copy
                // that + the UDP info?
                memcpy(resp->wbuf, tresp->wbuf, tresp->iov[0].iov_len);
                for (int x = 0; x < tresp->iovcnt; x++) {
                    resp->iov[x] = tresp->iov[x];
                }
                // resp->iov[x].iov_base needs to be updated if it's
                // pointing within its wbuf.
                // FIXME: This is too fragile. we need to be able to
                // inherit details and swap resp objects around.
                if (tresp->iov[0].iov_base == tresp->wbuf) {
                    resp->iov[0].iov_base = resp->wbuf;
                }
                resp->iovcnt = tresp->iovcnt;
                resp->chunked_total = tresp->chunked_total;
                resp->chunked_data_iov = tresp->chunked_data_iov;
                // copy UDP headers...
                resp->request_id = tresp->request_id;
                resp->udp_sequence = tresp->udp_sequence;
                resp->udp_total = tresp->udp_total;
                resp->request_addr = tresp->request_addr;
                resp->request_addr_size = tresp->request_addr_size;
                resp->item = tresp->item; // will be populated if not extstore fetch
                resp->skip = tresp->skip;

                // we let the mcp_resp gc handler free up tresp and any
                // associated io_pending's of its own later.
            } else if (r->buf) {
                // response set from C.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
                memcpy(resp->wbuf, s, l);
                resp_add_iov(resp, resp->wbuf, l);
                lua_pop(Lc, 1);
            } else {
                // Empty response: used for ascii multiget emulation.
            }

        } else if (type == LUA_TSTRING) {
            // response is a raw string from lua.
            const char *s = lua_tolstring(Lc, 1, &rlen);
            size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
            memcpy(resp->wbuf, s, l);
            resp_add_iov(resp, resp->wbuf, l);
            lua_pop(Lc, 1);
        } else {
            proxy_out_errstring(resp, PROXY_SERVER_ERROR, "bad response");
        }

    } else if (cores == LUA_YIELD) {
        int coro_ref = 0;
        int yield_type = lua_tointeger(Lc, -1);
        P_DEBUG("%s: coroutine yielded. return type: %d\n", __func__, yield_type);
        assert(yield_type != 0);
        lua_pop(Lc, 1);

        // need to remove and free the io_pending, since c->resp owns it.
        // so we call mcp_queue_io() again and let it override the
        // mc_resp's io_pending object.
        //
        // p is not null only when being called from proxy_return_cb(),
        // a pending IO is returning to resume.
        if (p != NULL) {
            coro_ref = p->coro_ref;
            assert((void *)p == (void *)resp->io_pending);
            resp->io_pending = NULL;
            c = p->c;
            // *p is now dead.
            do_cache_free(c->thread->io_cache, p);
        } else {
            // coroutine object sitting on the _main_ VM right now, so we grab
            // the reference from there, which also pops it.
            assert(c != NULL);
            coro_ref = luaL_ref(c->thread->L, LUA_REGISTRYINDEX);
        }

        int res = 0;
        switch (yield_type) {
            case MCP_YIELD_AWAIT:
                mcplib_await_run(c, resp, Lc, coro_ref);
                break;
            case MCP_YIELD_POOL:
                // TODO (v2): c only used for cache alloc?
                mcp_queue_io(c, resp, coro_ref, Lc);
                break;
            case MCP_YIELD_LOCAL:
                // stack should be: rq, res
                res = mcplib_internal_run(Lc, c, resp, coro_ref);
                if (res == 0) {
                    // stack should still be: rq, res
                    // TODO: turn this function into a for loop that re-runs on
                    // certain status codes, to avoid recursive depth here.
                    //
                    // FIXME: this dance with the coroutine reference is
                    // annoying. In this case we immediately resume, so no *io
                    // was generated, so we won't do the above coro_ref swap, so
                    // we'll try to take the coro_ref again and fail.
                    // The ref is only actually used in proxy_await
                    // It should instead be stashed on the top mc_resp object
                    // (ideally removing c->proxy_coro_ref at the same time)
                    // and unref'ed when the resp is cleaned up.
                    lua_rawgeti(c->thread->L, LUA_REGISTRYINDEX, coro_ref);
                    luaL_unref(c->thread->L, LUA_REGISTRYINDEX, coro_ref);
                    proxy_run_coroutine(Lc, resp, NULL, c);
                } else if (res > 0) {
                    // internal run queued for extstore.
                } else {
                    assert(res < 0);
                    proxy_out_errstring(resp, PROXY_SERVER_ERROR, "bad request");
                }
                break;
            default:
                abort();
        }

    } else {
        WSTAT_DECR(c->thread, proxy_req_active, 1);
        P_DEBUG("%s: Failed to run coroutine: %s\n", __func__, lua_tostring(Lc, -1));
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_ERROR, NULL, lua_tostring(Lc, -1));
        proxy_out_errstring(resp, PROXY_SERVER_ERROR, "lua failure");
    }

    return 0;
}
