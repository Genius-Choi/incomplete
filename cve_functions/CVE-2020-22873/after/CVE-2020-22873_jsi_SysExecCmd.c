Jsi_RC jsi_SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, bool restricted)
{
    int n, exitCode = 0, hasopts = 0, sLen, sLen2 = 0;
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    const char *cp2=NULL, *cp = Jsi_ValueString(interp, arg, &sLen);
    FILE *fp = NULL;
    if (restricted && Jsi_ValueGetLength(interp, args)>1)
        return Jsi_LogError("restricted may not have args");
    if (interp->isSafe) {
        int rc =0, no = 1;
        if (restricted)
            no = 0;
        else if (interp->safeExecPattern && cp) {
            Jsi_Value *seq = Jsi_ValueNew1(interp);
            Jsi_RC rrc = jsi_RegExpValueNew(interp, interp->safeExecPattern, seq);
            if (rrc == JSI_OK && Jsi_RegExpMatch(interp, seq, cp, &rc, NULL)!=JSI_OK)
                rrc = JSI_ERROR;
            Jsi_DecrRefCount(interp, seq);
            if (rrc != JSI_OK)
                return Jsi_LogError("invalid regex");
            if (rc)
                no = 0;
            restricted = 1;
        }
        if (no)
            return Jsi_LogError("no exec in safe mode");
    }
    Jsi_RC rc = JSI_OK;
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    Jsi_DString dStr = {}, cStr = {};
    ExecOpts edata = {};
    edata.retval = 1;
    
    if (opt != NULL) {
        if (opt->vt == JSI_VT_OBJECT && opt->d.obj->ot == JSI_OT_OBJECT) {
            hasopts = 1;
            if (Jsi_OptionsProcess(interp, ExecOptions, &edata, opt, 0) < 0) {
                return JSI_ERROR;
            }
            if (edata.retCode)
                edata.retval = 0;
        } else if (Jsi_ValueString(interp, opt, NULL)) {
            edata.inputStr = opt;
        } else 
            return Jsi_LogError("arg 2: expected options or string 'input'?");
    }
    if (restricted || edata.noRedir) {
        // Sanity check command string to disallow shell escapes, redirection, etc.
        if (strcspn(cp, "<>|;&$`=") != strlen(cp))
            return Jsi_LogError("restricted chars in exec string: %s", cp);
    }
    int isbg = 0, ec = 0;
    const char *ocd = NULL, *cd = (edata.chdir ? Jsi_ValueString(interp, edata.chdir, NULL) : NULL);
    if (cd && interp->isSafe) {
        cd = NULL;
        rc = Jsi_LogError("no chdir in safe mode");
        goto done;        
    }
    if (cd) {
        ocd = Jsi_GetCwd(interp, &cStr);
        if (!Jsi_FSNative(interp, edata.chdir) || Jsi_Chdir(interp, edata.chdir)<0) {
            cd = NULL;
            rc = Jsi_LogError("chdir failed");
            goto done;        
        }
    }
    if (edata.bg || (isbg=((sLen>1 && cp[sLen-1] == '&')))) {
        if (edata.inputStr) {
            rc = Jsi_LogError("input string may not used with bg");
            goto done;
        }
        if (edata.noShell) {
            rc = Jsi_LogError("noShell may not used with bg");
            goto done;
        }
        if (!isbg) {
            Jsi_DSAppend(&dStr, cp, " &", NULL);
            cp = Jsi_DSValue(&dStr);
        }
        edata.bg = 1;
        edata.retCode = 1;
        edata.retval = 0;
        exitCode = ((ec=system(cp))>>8);
        Jsi_DSSetLength(&dStr, 0);
    } else {
        const char *type = (edata.inputStr?"w":"r");
        bool native = !edata.noShell;
#ifdef __WIN32
        native = 1;
#else
        if (native)
            native = (access("/bin/sh", X_OK)==0);
#endif
        int cpid;
        if (native)
            fp = popen(cp, type);
        else {
            int argc;
            char **argv;
            Jsi_DString pStr = {};
            Jsi_SplitStr(cp, &argc, &argv, NULL, &pStr);
            fp = jsi_popen(argv, type, &cpid);
            Jsi_DSFree(&pStr);
        }
        if (!fp) 
            exitCode = errno;
        else {
            if (edata.inputStr) {
                edata.retCode = 1;
                edata.retval = 0;
                cp2 = Jsi_ValueString(interp, edata.inputStr, &sLen2);
                while ((n=fwrite(cp2, 1, sLen2, fp))>0) {
                    sLen2 -= n;
                }
            } else {
                char buf[JSI_BUFSIZ];;
                while ((n=fread(buf, 1, sizeof(buf), fp))>0)
                    Jsi_DSAppendLen(&dStr, buf, n);
            }
            if (native)
                exitCode = ((ec=pclose(fp))>>8);
            else
                exitCode = ((ec=jsi_pclose(fp, cpid))>>8);
        }
    }
    if (exitCode && edata.noError==0 && edata.retCode==0 && edata.retAll==0) {
        if (exitCode==ENOENT)
            Jsi_LogError("command not found: %s", cp);
        else
            Jsi_LogError("program exit code (%x)", exitCode);
        rc = JSI_ERROR;
    }
    if (edata.trim) {
        char *cp = Jsi_DSValue(&dStr);
        int iLen = Jsi_DSLength(&dStr);
        while (iLen>0 && isspace(cp[iLen-1]))
            iLen--;
        cp[iLen] = 0;
        Jsi_DSSetLength(&dStr, iLen);
    }
    if (edata.retAll) {
        Jsi_Obj *nobj = Jsi_ObjNew(interp);
        Jsi_ValueMakeObject(interp, ret, nobj);
        Jsi_Value *cval = Jsi_ValueNewNumber(interp, (Jsi_Number)exitCode);
        Jsi_ObjInsert(interp, nobj, "code", cval, 0);
        cval = Jsi_ValueNewNumber(interp, (Jsi_Number)(ec&0xff));
        Jsi_ObjInsert(interp, nobj, "status", cval, 0);
        cval = Jsi_ValueNew(interp);
        Jsi_ValueFromDS(interp, &dStr, &cval);
        Jsi_ObjInsert(interp, nobj, "data", cval, 0);
        
    } else if (edata.retval)
        Jsi_ValueFromDS(interp, &dStr, ret);
    else {
        Jsi_DSFree(&dStr);
        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)exitCode);
    }
done:
    if (cd && ocd) {
        Jsi_Value *oc = Jsi_ValueNewStringDup(interp, ocd);
        Jsi_IncrRefCount(interp, oc);
        Jsi_Chdir(interp, oc);
        Jsi_DecrRefCount(interp, oc);
    }
    Jsi_DSFree(&cStr);
    if (hasopts)
        Jsi_OptionsFree(interp, ExecOptions, &edata, 0);
    return rc;
}
