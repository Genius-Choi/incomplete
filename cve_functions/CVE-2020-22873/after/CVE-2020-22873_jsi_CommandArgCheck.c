bool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent)
{
    bool rc = 1;
    Jsi_DString dStr = {};
    Jsi_DSAppend(&dStr, cmdSpec->argStr, NULL);
    const char *elips = Jsi_Strstr(cmdSpec->argStr, "...");
    if (cmdSpec->maxArgs<0 && !elips)
        Jsi_DSAppend(&dStr, ", ...", NULL);
    int aCnt = 0, i = -1;
    char *cp = Jsi_DSValue(&dStr);
    while (cp[++i]) if (cp[i]==',') aCnt++;
    
    if (cmdSpec->maxArgs>=0) {
        aCnt++;
        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>cmdSpec->maxArgs || 
            cmdSpec->minArgs>aCnt || cmdSpec->maxArgs>aCnt || elips) {
            rc = 0;
        }                    
    } else {
        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>aCnt) {
            rc = 0;
        }                    
    }
    Jsi_DSFree(&dStr);
    if (!rc) {
        jsi_TypeMismatch(interp);
        Jsi_LogWarn("inconsistent arg string for \"%s.%s(%s)\" [%d,%d]",
            parent, cmdSpec->name, cmdSpec->argStr, cmdSpec->minArgs, cmdSpec->maxArgs);
    }
    if (f->argnames==NULL && cmdSpec->argStr) {
        // At least give a clue where the problem is.
        const char *ocfile = interp->curFile;
        jsi_Pline *opl = interp->parseLine, pline;
        interp->parseLine = &pline;
        pline.first_line = 1;
        interp->curFile = cmdSpec->name;
        f->argnames = jsi_ParseArgStr(interp, cmdSpec->argStr);
        interp->curFile = ocfile;
        interp->parseLine = opl;
    }
    return rc;
}
