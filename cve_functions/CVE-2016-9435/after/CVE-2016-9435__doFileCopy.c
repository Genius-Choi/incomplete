_doFileCopy(char *tmpf, char *defstr, int download)
{
#ifndef __MINGW32_VERSION
    Str msg;
    Str filen;
    char *p, *q = NULL;
    pid_t pid;
    char *lock;
#if !(defined(HAVE_SYMLINK) && defined(HAVE_LSTAT))
    FILE *f;
#endif
    struct stat st;
    clen_t size = 0;
    int is_pipe = FALSE;

    if (fmInitialized) {
	p = searchKeyData();
	if (p == NULL || *p == '\0') {
	    /* FIXME: gettextize? */
	    q = inputLineHist("(Download)Save file to: ",
			      defstr, IN_COMMAND, SaveHist);
	    if (q == NULL || *q == '\0')
		return FALSE;
	    p = conv_to_system(q);
	}
	if (*p == '|' && PermitSaveToPipe)
	    is_pipe = TRUE;
	else {
	    if (q) {
		p = unescape_spaces(Strnew_charp(q))->ptr;
		p = conv_to_system(p);
	    }
	    p = expandPath(p);
	    if (checkOverWrite(p) < 0)
		return -1;
	}
	if (checkCopyFile(tmpf, p) < 0) {
	    /* FIXME: gettextize? */
	    msg = Sprintf("Can't copy. %s and %s are identical.",
			  conv_from_system(tmpf), conv_from_system(p));
	    disp_err_message(msg->ptr, FALSE);
	    return -1;
	}
	if (!download) {
	    if (_MoveFile(tmpf, p) < 0) {
		/* FIXME: gettextize? */
		msg = Sprintf("Can't save to %s", conv_from_system(p));
		disp_err_message(msg->ptr, FALSE);
	    }
	    return -1;
	}
	lock = tmpfname(TMPF_DFL, ".lock")->ptr;
#if defined(HAVE_SYMLINK) && defined(HAVE_LSTAT)
	symlink(p, lock);
#else
	f = fopen(lock, "w");
	if (f)
	    fclose(f);
#endif
	flush_tty();
	pid = fork();
	if (!pid) {
	    setup_child(FALSE, 0, -1);
	    if (!_MoveFile(tmpf, p) && PreserveTimestamp && !is_pipe &&
		!stat(tmpf, &st))
		setModtime(p, st.st_mtime);
	    unlink(lock);
	    exit(0);
	}
	if (!stat(tmpf, &st))
	    size = st.st_size;
	addDownloadList(pid, conv_from_system(tmpf), p, lock, size);
    }
    else {
	q = searchKeyData();
	if (q == NULL || *q == '\0') {
	    /* FIXME: gettextize? */
	    printf("(Download)Save file to: ");
	    fflush(stdout);
	    filen = Strfgets(stdin);
	    if (filen->length == 0)
		return -1;
	    q = filen->ptr;
	}
	for (p = q + strlen(q) - 1; IS_SPACE(*p); p--) ;
	*(p + 1) = '\0';
	if (*q == '\0')
	    return -1;
	p = q;
	if (*p == '|' && PermitSaveToPipe)
	    is_pipe = TRUE;
	else {
	    p = expandPath(p);
	    if (checkOverWrite(p) < 0)
		return -1;
	}
	if (checkCopyFile(tmpf, p) < 0) {
	    /* FIXME: gettextize? */
	    printf("Can't copy. %s and %s are identical.", tmpf, p);
	    return -1;
	}
	if (_MoveFile(tmpf, p) < 0) {
	    /* FIXME: gettextize? */
	    printf("Can't save to %s\n", p);
	    return -1;
	}
	if (PreserveTimestamp && !is_pipe && !stat(tmpf, &st))
	    setModtime(p, st.st_mtime);
    }
#endif /* __MINGW32_VERSION */
    return 0;
}
