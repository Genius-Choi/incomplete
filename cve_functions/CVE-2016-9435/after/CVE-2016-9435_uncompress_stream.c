uncompress_stream(URLFile *uf, char **src)
{
#ifndef __MINGW32_VERSION
    pid_t pid1;
    FILE *f1;
    char *expand_cmd = GUNZIP_CMDNAME;
    char *expand_name = GUNZIP_NAME;
    char *tmpf = NULL;
    char *ext = NULL;
    struct compression_decoder *d;

    if (IStype(uf->stream) != IST_ENCODED) {
	uf->stream = newEncodedStream(uf->stream, uf->encoding);
	uf->encoding = ENC_7BIT;
    }
    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {
	if (uf->compression == d->type) {
	    if (d->auxbin_p)
		expand_cmd = auxbinFile(d->cmd);
	    else
		expand_cmd = d->cmd;
	    expand_name = d->name;
	    ext = d->ext;
	    break;
	}
    }
    uf->compression = CMP_NOCOMPRESS;

    if (uf->scheme != SCM_LOCAL
#ifdef USE_IMAGE
	&& !image_source
#endif
	) {
	tmpf = tmpfname(TMPF_DFL, ext)->ptr;
    }

    /* child1 -- stdout|f1=uf -> parent */
    pid1 = open_pipe_rw(&f1, NULL);
    if (pid1 < 0) {
	UFclose(uf);
	return;
    }
    if (pid1 == 0) {
	/* child */
	pid_t pid2;
	FILE *f2 = stdin;

	/* uf -> child2 -- stdout|stdin -> child1 */
	pid2 = open_pipe_rw(&f2, NULL);
	if (pid2 < 0) {
	    UFclose(uf);
	    exit(1);
	}
	if (pid2 == 0) {
	    /* child2 */
	    char *buf = NewWithoutGC_N(char, SAVE_BUF_SIZE);
	    int count;
	    FILE *f = NULL;

	    setup_child(TRUE, 2, UFfileno(uf));
	    if (tmpf)
		f = fopen(tmpf, "wb");
	    while ((count = ISread_n(uf->stream, buf, SAVE_BUF_SIZE)) > 0) {
		if (fwrite(buf, 1, count, stdout) != count)
		    break;
		if (f && fwrite(buf, 1, count, f) != count)
		    break;
	    }
	    UFclose(uf);
	    if (f)
		fclose(f);
	    xfree(buf);
	    exit(0);
	}
	/* child1 */
	dup2(1, 2);		/* stderr>&stdout */
	setup_child(TRUE, -1, -1);
	execlp(expand_cmd, expand_name, NULL);
	exit(1);
    }
    if (tmpf) {
	if (src)
	    *src = tmpf;
	else
	    uf->scheme = SCM_LOCAL;
    }
    UFhalfclose(uf);
    uf->stream = newFileStream(f1, (void (*)())fclose);
#endif /* __MINGW32_VERSION */
}
