static int median_16(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)
{
    ColorCorrectContext *s = ctx->priv;
    AVFrame *frame = arg;
    const float imax = s->imax;
    const int width = s->planewidth[1];
    const int height = s->planeheight[1];
    const ptrdiff_t ulinesize = frame->linesize[1] / 2;
    const ptrdiff_t vlinesize = frame->linesize[2] / 2;
    const uint16_t *uptr = (const uint16_t *)frame->data[1];
    const uint16_t *vptr = (const uint16_t *)frame->data[2];
    unsigned *uhistogram = s->uhistogram;
    unsigned *vhistogram = s->vhistogram;
    const int half_size = width * height / 2;
    int umedian = s->max, vmedian = s->max;
    unsigned ucnt = 0, vcnt = 0;

    memset(uhistogram, 0, sizeof(*uhistogram) * (s->max + 1));
    memset(vhistogram, 0, sizeof(*vhistogram) * (s->max + 1));

    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            uhistogram[uptr[x]]++;
            vhistogram[vptr[x]]++;
        }

        uptr += ulinesize;
        vptr += vlinesize;
    }

    for (int i = 0; i < s->max + 1; i++) {
        ucnt += uhistogram[i];
        if (ucnt >= half_size) {
            umedian = i;
            break;
        }
    }

    for (int i = 0; i < s->max + 1; i++) {
        vcnt += vhistogram[i];
        if (vcnt >= half_size) {
            vmedian = i;
            break;
        }
    }

    s->analyzeret[0][0] = imax * umedian - 0.5f;
    s->analyzeret[0][1] = imax * vmedian - 0.5f;
    s->analyzeret[0][2] = imax * umedian - 0.5f;
    s->analyzeret[0][3] = imax * vmedian - 0.5f;

    return 0;
}
