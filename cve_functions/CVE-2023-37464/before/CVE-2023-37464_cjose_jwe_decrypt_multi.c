uint8_t *cjose_jwe_decrypt_multi(cjose_jwe_t *jwe, cjose_key_locator key_locator, void *data, size_t *content_len, cjose_err *err)
{

    uint8_t *cek = 0;
    size_t cek_len = 0;
    uint8_t *content = NULL;

    if (NULL == jwe || NULL == key_locator || NULL == content_len)
    {
        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);
        return NULL;
    }

    for (size_t i = 0; i < jwe->to_count; i++)
    {

        const cjose_jwk_t *key = key_locator(jwe, (cjose_header_t *)jwe->to[i].unprotected, data);
        if (NULL == key)
        {
            continue;
        }

        // decrypt JWE content-encryption key from encrypted key
        if (!jwe->to[i].fns.decrypt_ek(jwe->to + i, jwe, key, err))
        {
            // if one key failed to decrypt, fail everything.
            goto _cjose_jwe_decrypt_multi_fail;
        }

        if (NULL == cek)
        {
            cek_len = jwe->cek_len;
            cek = cjose_get_alloc()(cek_len);
            if (!cek)
            {
                CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);
                return NULL;
            }
            memcpy(cek, jwe->cek, cek_len);
        }
        else
        {
            if (cek_len != jwe->cek_len || memcmp(jwe->cek, cek, cek_len))
            {
                CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);
                goto _cjose_jwe_decrypt_multi_fail;
            }
        }
    }

    if (NULL == jwe->cek)
    {
        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);
        goto _cjose_jwe_decrypt_multi_fail;
    }

    // decrypt JWE encrypted data
    if (!jwe->fns.decrypt_dat(jwe, err))
    {
        goto _cjose_jwe_decrypt_multi_fail;
    }

    // take the plaintext data from the jwe object
    content = jwe->dat;
    *content_len = jwe->dat_len;

    jwe->dat = NULL;
    jwe->dat_len = 0;

_cjose_jwe_decrypt_multi_fail:

    _cjose_release_cek(&cek, cek_len);

    return content;
}
