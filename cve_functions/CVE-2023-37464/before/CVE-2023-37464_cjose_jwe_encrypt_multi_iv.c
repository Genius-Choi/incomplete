cjose_jwe_t *cjose_jwe_encrypt_multi_iv(const cjose_jwe_recipient_t *recipients,
                                        size_t recipient_count,
                                        cjose_header_t *protected_header,
                                        cjose_header_t *shared_unprotected_header,
                                        const uint8_t *iv,
                                        size_t iv_len,
                                        const uint8_t *plaintext,
                                        size_t plaintext_len,
                                        cjose_err *err)
{
    cjose_jwe_t *jwe = NULL;

    if (NULL == recipients || NULL == protected_header || recipient_count < 1)
    {
        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);
        return NULL;
    }

    // allocate and initialize a new JWE object
    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))
    {
        return NULL;
    }

    jwe->to_count = recipient_count;
    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t) * recipient_count, false, (uint8_t **)&jwe->to, err))
    {
        cjose_jwe_release(jwe);
        return NULL;
    }

    if (!_cjose_jwe_validate_enc(jwe, protected_header, err))
    {
        cjose_jwe_release(jwe);
        return NULL;
    }

    // validate JWE header
    for (size_t i = 0; i < recipient_count; i++)
    {

        if (NULL == recipients[i].jwk)
        {
            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);
            cjose_jwe_release(jwe);
            return NULL;
        }

        jwe->to[i].unprotected = json_incref(recipients[i].unprotected_header);

        // make sure we have an alg header
        if (!_cjose_jwe_validate_alg(protected_header, jwe->to[i].unprotected, recipient_count > 1, jwe->to + i, err))
        {
            cjose_jwe_release(jwe);
            return NULL;
        }
    }

    // prepare JWE headers
    jwe->hdr = json_deep_copy(protected_header);
    if (jwe->hdr == NULL)
    {
        cjose_jwe_release(jwe);
        return NULL;
    }
    jwe->shared_hdr = json_incref(shared_unprotected_header);

    for (size_t i = 0; i < recipient_count; i++)
    {

        // build JWE content-encryption key and encrypted key
        if (!jwe->to[i].fns.encrypt_ek(jwe->to + i, jwe, recipients[i].jwk, err))
        {
            cjose_jwe_release(jwe);
            return NULL;
        }
    }

    // build JWE header
    if (!_cjose_jwe_build_hdr(jwe, err))
    {
        cjose_jwe_release(jwe);
        return NULL;
    }

    // build JWE initialization vector
    if (iv == NULL)
    {
        if (!jwe->fns.set_iv(jwe, err))
        {
            cjose_jwe_release(jwe);
            return NULL;
        }
    }
    else
    {
        cjose_get_dealloc()(jwe->enc_iv.raw);
        jwe->enc_iv.raw_len = iv_len;
        if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, false, &jwe->enc_iv.raw, err))
        {
            cjose_jwe_release(jwe);
            return NULL;
        }
        memcpy(jwe->enc_iv.raw, iv, iv_len);
    }

    // build JWE encrypted data and authentication tag
    if (!jwe->fns.encrypt_dat(jwe, plaintext, plaintext_len, err))
    {
        cjose_jwe_release(jwe);
        return NULL;
    }

    _cjose_release_cek(&jwe->cek, jwe->cek_len);

    return jwe;
}
