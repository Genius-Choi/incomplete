bool ARMFrameLowering::restoreCalleeSavedRegisters(
    MachineBasicBlock &MBB, MachineBasicBlock::iterator MI,
    MutableArrayRef<CalleeSavedInfo> CSI, const TargetRegisterInfo *TRI) const {
  if (CSI.empty())
    return false;

  MachineFunction &MF = *MBB.getParent();
  ARMFunctionInfo *AFI = MF.getInfo<ARMFunctionInfo>();
  bool isVarArg = AFI->getArgRegsSaveSize() > 0;
  unsigned NumAlignedDPRCS2Regs = AFI->getNumAlignedDPRCS2Regs();

  // The emitPopInst calls below do not insert reloads for the aligned DPRCS2
  // registers. Do that here instead.
  if (NumAlignedDPRCS2Regs)
    emitAlignedDPRCS2Restores(MBB, MI, NumAlignedDPRCS2Regs, CSI, TRI);

  unsigned PopOpc = AFI->isThumbFunction() ? ARM::t2LDMIA_UPD : ARM::LDMIA_UPD;
  unsigned LdrOpc =
      AFI->isThumbFunction() ? ARM::t2LDR_POST : ARM::LDR_POST_IMM;
  unsigned FltOpc = ARM::VLDMDIA_UPD;
  if (STI.splitFramePointerPush(MF)) {
    emitPopInst(MBB, MI, CSI, PopOpc, LdrOpc, isVarArg, false,
                &isSplitFPArea2Register, 0);
    emitPopInst(MBB, MI, CSI, FltOpc, 0, isVarArg, true, &isARMArea3Register,
                NumAlignedDPRCS2Regs);
    emitPopInst(MBB, MI, CSI, PopOpc, LdrOpc, isVarArg, false,
                &isSplitFPArea1Register, 0);
  } else {
    emitPopInst(MBB, MI, CSI, FltOpc, 0, isVarArg, true, &isARMArea3Register,
                NumAlignedDPRCS2Regs);
    emitPopInst(MBB, MI, CSI, PopOpc, LdrOpc, isVarArg, false,
                &isARMArea2Register, 0);
    emitPopInst(MBB, MI, CSI, PopOpc, LdrOpc, isVarArg, false,
                &isARMArea1Register, 0);
  }

  return true;
}
