asUintNResultSize(uint64_t n, ImmutableBigIntRef src, uint32_t &resultSize) {
  static_assert(
      BigIntMaxSizeInDigits < std::numeric_limits<uint32_t>::max(),
      "uint32_t is not large enough to represent max bigint digits.");

  const uint64_t numBitsSrc = src.numDigits * BigIntDigitSizeInBits;

  uint64_t numBitsResult;
  if (!isNegative(src)) {
    // for src >= 0, the result is limited to the same number of digits in src,
    // plus an extra bit for the sign.
    numBitsResult = std::min(n, numBitsSrc) + 1;
  } else {
    // for src < 0, the result is potentially unlimited as negative bigints have
    // infinite size.
    numBitsResult = n + 1;
  }

  if (numBitsResult > BigIntMaxSizeInBits) {
    return OperationStatus::TOO_MANY_DIGITS;
  }

  resultSize = numDigitsForSizeInBits(numBitsResult);
  return OperationStatus::RETURNED;
}
