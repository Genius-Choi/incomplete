  void DrachtioController::httpCallRoutingComplete(const string& transactionId, long response_code, 
    const string& body) {

    std::ostringstream msg ;
    json_t *root;
    json_error_t error;
    root = json_loads(body.c_str(), 0, &error);

    DR_LOG(log_debug) << "DrachtioController::httpCallRoutingComplete thread id " << std::this_thread::get_id() << 
      " transaction id " << transactionId << " response: (" << response_code << ") " << body ; 

    try {
      if( !root ) {
        msg << "error parsing body as JSON on line " << error.line  << ": " << error.text ;
        return throw std::runtime_error(msg.str()) ;  
      }

      if(!json_is_object(root)) {
        throw std::runtime_error("expected JSON object but got something else") ;  
      }

      json_t* action = json_object_get( root, "action") ;
      json_t* data = json_object_get(root, "data") ;
      if( !json_is_string(action) ) {
        throw std::runtime_error("missing or invalid 'action' attribute") ;  
      }
      if( !json_is_object(data) ) {
        throw std::runtime_error("missing 'data' object") ;  
      }
      const char* actionText = json_string_value(action) ;
      if( 0 == strcmp("reject", actionText)) {
        json_t* status = json_object_get(data, "status") ;
        json_t* reason = json_object_get(data, "reason") ;

        if( !status || !json_is_number(status) ) {
          throw std::runtime_error("'status' is missing or is not a number") ;  
        }
        processRejectInstruction(transactionId, json_integer_value(status), json_string_value(reason));
      }
      else if( 0 == strcmp("proxy", actionText)) {
        bool recordRoute = false ;
        bool followRedirects = true ;
        bool simultaneous = false ;
        string provisionalTimeout = "5s";
        string finalTimeout = "60s";
        vector<string> vecDestination ;

        json_t* rr = json_object_get(data, "recordRoute") ;
        if( rr && json_is_boolean(rr) ) {
          recordRoute = json_boolean_value(rr) ;
        }

        json_t* follow = json_object_get(data, "followRedirects") ;
        if( follow && json_is_boolean(follow) ) {
          followRedirects = json_boolean_value(follow) ;
        }

        json_t* sim = json_object_get(data, "simultaneous") ;
        if( sim && json_is_boolean(sim) ) {
          simultaneous = json_boolean_value(sim) ;
        }

        json_t* pTimeout = json_object_get(data, "provisionalTimeout") ;
        if( pTimeout && json_is_string(pTimeout) ) {
          provisionalTimeout = json_string_value(pTimeout) ;
        }

        json_t* fTimeout = json_object_get(data, "finalTimeout") ;
        if( fTimeout && json_is_string(fTimeout) ) {
          finalTimeout = json_string_value(fTimeout) ;
        }

        json_t* destination = json_object_get(data, "destination") ;
        if( json_is_string(destination) ) {
          vecDestination.push_back( json_string_value(destination) ) ;
        }
        else if( json_is_array(destination) ) {
          size_t size = json_array_size(destination);
          for( unsigned int i = 0; i < size; i++ ) {
            json_t* aDest = json_array_get(destination, i);
            if( !json_is_string(aDest) ) {
              throw std::runtime_error("DrachtioController::processRoutingInstructions - invalid 'contact' array: must contain strings") ;  
            }
            vecDestination.push_back( json_string_value(aDest) );
          }
        }

        processProxyInstruction(transactionId, recordRoute, followRedirects, 
            simultaneous, provisionalTimeout, finalTimeout, vecDestination) ;
      }
      else if( 0 == strcmp("redirect", actionText)) {
        json_t* contact = json_object_get(data, "contact") ;
        vector<string> vecContact ;

        if( json_is_string(contact) ) {
          vecContact.push_back( json_string_value(contact) ) ;
        }
        else if( json_is_array(contact) ) {
          size_t size = json_array_size(contact);
          for( unsigned int i = 0; i < size; i++ ) {
            json_t* aContact = json_array_get(contact, i);
            if( !json_is_string(aContact) ) {
              throw std::runtime_error("DrachtioController::processRoutingInstructions - invalid 'contact' array: must contain strings") ;  
            }
            vecContact.push_back( json_string_value(aContact) );
          }
        }
        else {
          throw std::runtime_error("DrachtioController::processRoutingInstructions - invalid 'contact' attribute in redirect action: must be string or array") ;  
        }
        processRedirectInstruction(transactionId, vecContact);

      }
      else if( 0 == strcmp("route", actionText)) {
        json_t* uri = json_object_get(data, "uri") ;
        json_t* tag = json_object_get(data, "tag") ;

        if(uri && json_is_string(uri)) {
            processOutboundConnectionInstruction(transactionId, json_string_value(uri));
        }
        else if(tag && json_is_string(tag)) {
            processTaggedConnectionInstruction(transactionId, json_string_value(tag));
        }
        else {
          throw std::runtime_error("'uri' is missing or is not a string") ;  
        }
      }
      else {
        msg << "DrachtioController::processRoutingInstructions - invalid 'action' attribute value '" << actionText << 
            "': valid values are 'reject', 'proxy', 'redirect', and 'route'" ;
        return throw std::runtime_error(msg.str()) ;  
      }

      json_decref(root) ; 
    } catch( std::runtime_error& err ) {
      DR_LOG(log_error) << "DrachtioController::processRoutingInstructions " << err.what();
      DR_LOG(log_error) << body ;
      processRejectInstruction(transactionId, 500) ;
      if( root ) { 
        json_decref(root) ; 
      }
    }
      // clean up needed?  not in reject scenarios, nor redirect nor route (proxy?)
      //m_pController->getPendingRequestController()->findAndRemove( transactionId ) ;
  }
