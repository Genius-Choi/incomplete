TEE_Result crypto_hash_alloc_ctx(void **ctx, uint32_t algo)
{
	TEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;
	struct crypto_hash_ctx *c = NULL;

	/*
	 * Use default cryptographic implementation if no matching
	 * drvcrypt device.
	 */
	res = drvcrypt_hash_alloc_ctx(&c, algo);

	if (res == TEE_ERROR_NOT_IMPLEMENTED) {
		switch (algo) {
		case TEE_ALG_MD5:
			res = crypto_md5_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA1:
			res = crypto_sha1_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA224:
			res = crypto_sha224_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA256:
			res = crypto_sha256_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA384:
			res = crypto_sha384_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA512:
			res = crypto_sha512_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA3_224:
			res = crypto_sha3_224_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA3_256:
			res = crypto_sha3_256_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA3_384:
			res = crypto_sha3_384_alloc_ctx(&c);
			break;
		case TEE_ALG_SHA3_512:
			res = crypto_sha3_512_alloc_ctx(&c);
			break;
		case TEE_ALG_SHAKE128:
			res = crypto_shake128_alloc_ctx(&c);
			break;
		case TEE_ALG_SHAKE256:
			res = crypto_shake256_alloc_ctx(&c);
			break;
		case TEE_ALG_SM3:
			res = crypto_sm3_alloc_ctx(&c);
			break;
		default:
			break;
		}
	}

	if (!res)
		*ctx = c;

	return res;
}
