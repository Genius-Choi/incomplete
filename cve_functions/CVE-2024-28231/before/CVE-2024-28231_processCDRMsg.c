void MessageReceiver::processCDRMsg(
        const Locator_t& source_locator,
        const Locator_t& reception_locator,
        CDRMessage_t* msg)
{
    if (msg->length < RTPSMESSAGE_HEADER_SIZE)
    {
        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING "Received message too short, ignoring");
        return;
    }

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
    GuidPrefix_t participantGuidPrefix;
#else
    GuidPrefix_t participantGuidPrefix = participant_->getGuid().guidPrefix;
#endif // ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION

#if HAVE_SECURITY && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
    security::SecurityManager& security = participant_->security_manager();
    CDRMessage_t* auxiliary_buffer = &crypto_msg_;
    int decode_ret = 0;
#endif // if HAVE_SECURITY && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)

    bool ignore_submessages = false;

    {
        std::lock_guard<eprosima::shared_mutex> guard(mtx_);

        reset();

        dest_guid_prefix_ = participantGuidPrefix;

        msg->pos = 0; //Start reading at 0

        //Once everything is set, the reading begins:
        if (!checkRTPSHeader(msg))
        {
            return;
        }

#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
        ignore_submessages = participant_->is_participant_ignored(source_guid_prefix_);
#endif  // if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)

        if (!ignore_submessages)
        {
            notify_network_statistics(source_locator, reception_locator, msg);
        }

#if HAVE_SECURITY && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
        decode_ret = security.decode_rtps_message(*msg, *auxiliary_buffer, source_guid_prefix_);

        if (decode_ret < 0)
        {
            return;
        }

        if (decode_ret == 0)
        {
            // The original CDRMessage buffer (msg) now points to the proprietary temporary buffer crypto_msg_.
            // The auxiliary buffer now points to the propietary temporary buffer crypto_submsg_.
            // This way each decoded sub-message will be processed using the crypto_submsg_ buffer.
            msg = auxiliary_buffer;
            auxiliary_buffer = &crypto_submsg_;
        }
#endif // if HAVE_SECURITY && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
    }

    // Loop until there are no more submessages
    // Each submessage processing method choses the lock kind required
    bool valid;
    SubmessageHeader_t submsgh; //Current submessage header

    while (msg->pos < msg->length)// end of the message
    {
        CDRMessage_t* submessage = msg;

        bool current_message_was_decoded = false;

#if HAVE_SECURITY && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
        decode_ret = security.decode_rtps_submessage(*msg, *auxiliary_buffer, source_guid_prefix_);

        if (decode_ret < 0)
        {
            return;
        }

        if (decode_ret == 0)
        {
            current_message_was_decoded = true;
            submessage = auxiliary_buffer;
        }
#endif // if HAVE_SECURITY && !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)

        //First 4 bytes must contain: ID | flags | octets to next header
        if (!readSubmessageHeader(submessage, &submsgh))
        {
            return;
        }

        valid = true;
        uint32_t next_msg_pos = submessage->pos;
        next_msg_pos += (submsgh.submessageLength + 3u) & ~3u;

        // We ignore submessage if the source participant is to be ignored, unless the submessage king is INFO_SRC
        // which triggers a reevaluation of the flag.
        bool ignore_current_submessage = ignore_submessages && submsgh.submessageId != INFO_SRC;

        if (!ignore_current_submessage)
        {
            switch (submsgh.submessageId)
            {
                case DATA:
                {
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "Data Submsg ignored, DST is another RTPSParticipant");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "Data Submsg received, processing.");
                        EntityId_t writerId = c_EntityId_Unknown;
                        valid = proc_Submsg_Data(submessage, &submsgh, writerId, current_message_was_decoded);
#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
                        if (valid && writerId == c_EntityId_SPDPWriter)
                        {
                            ignore_submessages = participant_->is_participant_ignored(source_guid_prefix_);
                        }
#endif  // if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)

                    }
                    break;
                }
                case DATA_FRAG:
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN,
                                IDSTRING "DataFrag Submsg ignored, DST is another RTPSParticipant");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "DataFrag Submsg received, processing.");
                        valid = proc_Submsg_DataFrag(submessage, &submsgh, current_message_was_decoded);
                    }
                    break;
                case GAP:
                {
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN,
                                IDSTRING "Gap Submsg ignored, DST is another RTPSParticipant...");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "Gap Submsg received, processing...");
                        valid = proc_Submsg_Gap(submessage, &submsgh, current_message_was_decoded);
                    }
                    break;
                }
                case ACKNACK:
                {
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN,
                                IDSTRING "Acknack Submsg ignored, DST is another RTPSParticipant...");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "Acknack Submsg received, processing...");
                        valid = proc_Submsg_Acknack(submessage, &submsgh, current_message_was_decoded);
                    }
                    break;
                }
                case NACK_FRAG:
                {
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN,
                                IDSTRING "NackFrag Submsg ignored, DST is another RTPSParticipant...");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "NackFrag Submsg received, processing...");
                        valid = proc_Submsg_NackFrag(submessage, &submsgh, current_message_was_decoded);
                    }
                    break;
                }
                case HEARTBEAT:
                {
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "HB Submsg ignored, DST is another RTPSParticipant...");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "Heartbeat Submsg received, processing...");
                        valid = proc_Submsg_Heartbeat(submessage, &submsgh, current_message_was_decoded);
                    }
                    break;
                }
                case HEARTBEAT_FRAG:
                {
                    if (dest_guid_prefix_ != participantGuidPrefix)
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN,
                                IDSTRING "HBFrag Submsg ignored, DST is another RTPSParticipant...");
                    }
                    else
                    {
                        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "HeartbeatFrag Submsg received, processing...");
                        valid = proc_Submsg_HeartbeatFrag(submessage, &submsgh, current_message_was_decoded);
                    }
                    break;
                }
                case PAD:
                    EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING "PAD messages not yet implemented, ignoring");
                    break;
                case INFO_DST:
                    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "InfoDST message received, processing...");
                    valid = proc_Submsg_InfoDST(submessage, &submsgh);
                    break;
                case INFO_SRC:
                    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "InfoSRC message received, processing...");
                    valid = proc_Submsg_InfoSRC(submessage, &submsgh);
#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
                    ignore_submessages = participant_->is_participant_ignored(source_guid_prefix_);
#endif  // if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
                    break;
                case INFO_TS:
                {
                    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING "InfoTS Submsg received, processing...");
                    valid = proc_Submsg_InfoTS(submessage, &submsgh);
                    break;
                }
                case INFO_REPLY:
                    break;
                case INFO_REPLY_IP4:
                    break;
                default:
                    break;
            }
        }
        if (!valid || submsgh.is_last)
        {
            break;
        }

        submessage->pos = next_msg_pos;
    }

#if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
    participant_->assert_remote_participant_liveliness(source_guid_prefix_);
#endif // if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
}
