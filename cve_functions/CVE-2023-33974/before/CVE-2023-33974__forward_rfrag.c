static int _forward_rfrag(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,
                          uint16_t offset, unsigned page)
{
    gnrc_pktsnip_t *old, *new = gnrc_netif_hdr_build(
            NULL, 0,
            entry->entry.base->dst, entry->entry.base->dst_len
        );
    sixlowpan_sfr_rfrag_t *hdr;

    assert(entry->type == _VRB);
    /* restrict out_tag to value space of SFR, so that later RFRAG ACK can find
     * it in reverse look-up */
    entry->entry.vrb->out_tag &= UINT8_MAX;
    DEBUG("6lo sfr: Forwarding to (%s, %u)\n",
          gnrc_netif_addr_to_str(entry->entry.base->dst,
                                 entry->entry.base->dst_len, addr_str),
          entry->entry.vrb->out_tag);
    if (new == NULL) {
        DEBUG("6lo sfr: Unable to forward fragment, "
              "packet buffer full\n");
        gnrc_pktbuf_release(pkt);
        return -ENOMEM;
    }

    hdr = pkt->data;
    old = gnrc_pktsnip_search_type(pkt, GNRC_NETTYPE_NETIF);
    if (old != NULL) {
        /* remove original netif header */
        gnrc_pktbuf_remove_snip(pkt, old);
    }
    if (offset > 0) {
        offset += entry->entry.vrb->offset_diff;
    }
    sixlowpan_sfr_rfrag_set_offset(hdr, offset);
    hdr->base.tag = entry->entry.vrb->out_tag;
    gnrc_netif_hdr_set_netif(new->data, entry->entry.vrb->out_netif);
    new->next = pkt;
    _send_frame(new, NULL, NULL, page);
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {
        _stats.fragments_sent.forwarded++;
    }
    return 0;
}
