static status_t process_server_hello(private_tls_peer_t *this,
									 bio_reader_t *reader)
{
	uint8_t compression;
	uint16_t version, cipher, key_type = 0;
	bio_reader_t *extensions, *extension;
	chunk_t msg, random, session, ext = chunk_empty, key_share = chunk_empty;
	chunk_t cookie = chunk_empty;
	tls_cipher_suite_t suite = 0;
	tls_version_t version_max;
	bool is_retry_request;

	msg = reader->peek(reader);
	if (!reader->read_uint16(reader, &version) ||
		!reader->read_data(reader, sizeof(this->server_random), &random) ||
		!reader->read_data8(reader, &session) ||
		!reader->read_uint16(reader, &cipher) ||
		!reader->read_uint8(reader, &compression) ||
		(reader->remaining(reader) && !reader->read_data16(reader, &ext)))
	{
		DBG1(DBG_TLS, "received invalid ServerHello");
		this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
		return NEED_MORE;
	}

	is_retry_request = chunk_equals_const(random, tls_hello_retry_request_magic);

	memcpy(this->server_random, random.ptr, sizeof(this->server_random));

	extensions = bio_reader_create(ext);
	while (extensions->remaining(extensions))
	{
		uint16_t extension_type;
		chunk_t extension_data;

		if (!extensions->read_uint16(extensions, &extension_type) ||
			!extensions->read_data16(extensions, &extension_data))
		{
			DBG1(DBG_TLS, "invalid extension in ServerHello");
			this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
			extensions->destroy(extensions);
			return NEED_MORE;
		}
		extension = bio_reader_create(extension_data);
		switch (extension_type)
		{
			case TLS_EXT_SUPPORTED_VERSIONS:
				if (!extension->read_uint16(extension, &version))
				{
					DBG1(DBG_TLS, "invalid %N extension", tls_extension_names,
						 extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
				break;
			case TLS_EXT_KEY_SHARE:
				if (!extension->read_uint16(extension, &key_type) ||
					(!is_retry_request &&
					 !(extension->read_data16(extension, &key_share) &&
					   key_share.len)))
				{
					DBG1(DBG_TLS, "invalid %N extension", tls_extension_names,
						 extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
				break;
			case TLS_EXT_COOKIE:
				if (!extension->read_data16(extension, &cookie))
				{
					DBG1(DBG_TLS, "invalid %N extension", tls_extension_names,
						 extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
			default:
				break;
		}
		extension->destroy(extension);
	}
	extensions->destroy(extensions);

	/* downgrade protection (see RFC 8446, section 4.1.3) */
	version_max = this->tls->get_version_max(this->tls);
	if ((version_max == TLS_1_3 && version < TLS_1_3) ||
		(version_max == TLS_1_2 && version < TLS_1_2))
	{
		chunk_t server_random_end = chunk_create(&this->server_random[24], 8);

		if (chunk_equals(server_random_end, tls_downgrade_protection_tls11) ||
			chunk_equals(server_random_end, tls_downgrade_protection_tls12))
		{
			DBG1(DBG_TLS, "server random indicates downgrade attack to %N",
				 tls_version_names, version);
			this->alert->add(this->alert, TLS_FATAL, TLS_ILLEGAL_PARAMETER);
			return NEED_MORE;
		}
	}

	if (!this->tls->set_version(this->tls, version, version))
	{
		DBG1(DBG_TLS, "negotiated version %N not supported",
			 tls_version_names, version);
		this->alert->add(this->alert, TLS_FATAL, TLS_PROTOCOL_VERSION);
		return NEED_MORE;
	}

	if (this->tls->get_version_max(this->tls) < TLS_1_3)
	{
		if (chunk_equals(this->session, session))
		{
			suite = this->crypto->resume_session(this->crypto, session,
												 this->server, chunk_from_thing
												 (this->client_random),
												 chunk_from_thing
												 (this->server_random));
			if (suite)
			{
				DBG1(DBG_TLS, "resumed %N using suite %N",
					 tls_version_names, version, tls_cipher_suite_names, suite);
				this->resume = TRUE;
			}
		}
		DESTROY_IF(this->dh);
		this->dh = NULL;
	}

	if (!suite)
	{
		suite = cipher;
		if (!this->crypto->select_cipher_suite(this->crypto, &suite, 1, KEY_ANY))
		{
			DBG1(DBG_TLS, "received TLS cipher suite %N unacceptable",
				 tls_cipher_suite_names, suite);
			this->alert->add(this->alert, TLS_FATAL, TLS_HANDSHAKE_FAILURE);
			return NEED_MORE;
		}
		if (this->original_suite && this->original_suite != suite)
		{
			DBG1(DBG_TLS, "server selected %N instead of %N after retry",
				 tls_cipher_suite_names, suite, tls_cipher_suite_names,
				 this->original_suite);
			this->alert->add(this->alert, TLS_FATAL, TLS_ILLEGAL_PARAMETER);
			return NEED_MORE;
		}
		DBG1(DBG_TLS, "negotiated %N using suite %N",
			 tls_version_names, version, tls_cipher_suite_names, suite);
		free(this->session.ptr);
		this->session = chunk_clone(session);
	}

	if (is_retry_request)
	{
		if (!this->crypto->hash_handshake(this->crypto, NULL))
		{
			DBG1(DBG_TLS, "failed to hash handshake messages");
			this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
			return NEED_MORE;
		}
	}
	this->crypto->append_handshake(this->crypto, TLS_SERVER_HELLO, msg);

	if (is_retry_request)
	{
		if (key_type)
		{
			DBG1(DBG_TLS, "server requests key exchange with %N",
				 tls_named_group_names, key_type);
		}
		else if (cookie.len)
		{
			DBG1(DBG_TLS, "server requests retry with cookie");
		}
		else
		{
			DBG1(DBG_TLS, "invalid retry request received");
			this->alert->add(this->alert, TLS_FATAL, TLS_ILLEGAL_PARAMETER);
			return NEED_MORE;
		}
		if (this->requested_curve || this->cookie.len)
		{
			DBG1(DBG_TLS, "already replied to previous retry request");
			this->alert->add(this->alert, TLS_FATAL, TLS_UNEXPECTED_MESSAGE);
			return NEED_MORE;
		}
		if (key_type && !verify_requested_key_type(this, key_type))
		{
			this->alert->add(this->alert, TLS_FATAL, TLS_ILLEGAL_PARAMETER);
			return NEED_MORE;
		}

		DESTROY_IF(this->dh);
		this->dh = NULL;
		this->original_suite = suite;
		this->requested_curve = key_type;
		this->cookie = chunk_clone(cookie);
		this->state = STATE_INIT;
		return NEED_MORE;
	}

	if (this->tls->get_version_max(this->tls) >= TLS_1_3)
	{
		chunk_t shared_secret = chunk_empty;

		if (key_share.len &&
			key_type != TLS_CURVE25519 &&
			key_type != TLS_CURVE448)
		{	/* classic format (see RFC 8446, section 4.2.8.2) */
			if (key_share.ptr[0] != TLS_ANSI_UNCOMPRESSED)
			{
				DBG1(DBG_TLS, "DH point format '%N' not supported",
					 tls_ansi_point_format_names, key_share.ptr[0]);
				this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
				return NEED_MORE;
			}
			key_share = chunk_skip(key_share, 1);
		}
		if (!key_share.len ||
			!this->dh->set_other_public_value(this->dh, key_share) ||
			!this->dh->get_shared_secret(this->dh, &shared_secret) ||
			!this->crypto->derive_handshake_keys(this->crypto, shared_secret))
		{
			DBG1(DBG_TLS, "DH key derivation failed");
			this->alert->add(this->alert, TLS_FATAL, TLS_HANDSHAKE_FAILURE);
			chunk_clear(&shared_secret);
			return NEED_MORE;
		}
		chunk_clear(&shared_secret);

		this->crypto->change_cipher(this->crypto, TRUE);
		this->crypto->change_cipher(this->crypto, FALSE);
	}

	this->state = STATE_HELLO_RECEIVED;
	return NEED_MORE;
}
