static status_t send_certificate(private_tls_peer_t *this,
							tls_handshake_type_t *type, bio_writer_t *writer)
{
	enumerator_t *enumerator;
	certificate_t *cert;
	auth_rule_t rule;
	bio_writer_t *certs;
	private_key_t *key;
	auth_cfg_t *auth;
	chunk_t data;
	tls_version_t version_min, version_max;

	version_min = this->tls->get_version_min(this->tls);
	version_max = this->tls->get_version_max(this->tls);
	if (!this->hashsig.len)
	{
		convert_cert_types(this);
	}
	enumerator = tls_create_private_key_enumerator(version_min, version_max,
												   this->hashsig, this->peer);
	if (!enumerator || !enumerator->enumerate(enumerator, &key, &auth))
	{
		if (!enumerator)
		{
			DBG1(DBG_TLS, "no common signature algorithms found");
		}
		else
		{
			DBG1(DBG_TLS, "no usable TLS client certificate found for '%Y'",
				 this->peer);
		}
		this->peer->destroy(this->peer);
		this->peer = NULL;
	}
	else
	{
		this->private = key->get_ref(key);
		this->peer_auth->merge(this->peer_auth, auth, FALSE);
	}
	DESTROY_IF(enumerator);

	/* certificate request context as described in RFC 8446, section 4.4.2 */
	if (this->tls->get_version_max(this->tls) > TLS_1_2)
	{
		writer->write_uint8(writer, 0);
	}

	/* generate certificate payload */
	certs = bio_writer_create(256);
	cert = this->peer_auth->get(this->peer_auth, AUTH_RULE_SUBJECT_CERT);
	if (cert)
	{
		if (cert->get_encoding(cert, CERT_ASN1_DER, &data))
		{
			DBG1(DBG_TLS, "sending TLS client certificate '%Y'",
				 cert->get_subject(cert));
			certs->write_data24(certs, data);
			free(data.ptr);
		}
		/* extensions see RFC 8446, section 4.4.2 */
		if (this->tls->get_version_max(this->tls) > TLS_1_2)
		{
			certs->write_uint16(certs, 0);
		}
	}
	enumerator = this->peer_auth->create_enumerator(this->peer_auth);
	while (enumerator->enumerate(enumerator, &rule, &cert))
	{
		if (rule == AUTH_RULE_IM_CERT)
		{
			if (cert->get_encoding(cert, CERT_ASN1_DER, &data))
			{
				DBG1(DBG_TLS, "sending TLS intermediate certificate '%Y'",
					 cert->get_subject(cert));
				certs->write_data24(certs, data);
				free(data.ptr);
			}
		}
	}
	enumerator->destroy(enumerator);

	writer->write_data24(writer, certs->get_buf(certs));
	certs->destroy(certs);

	*type = TLS_CERTIFICATE;
	this->state = STATE_CERT_SENT;
	this->crypto->append_handshake(this->crypto, *type, writer->get_buf(writer));
	return NEED_MORE;
}
