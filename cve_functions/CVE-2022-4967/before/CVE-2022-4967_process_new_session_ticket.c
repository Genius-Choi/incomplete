static status_t process_new_session_ticket(private_tls_peer_t *this,
										   bio_reader_t *reader)
{
	uint32_t ticket_lifetime, ticket_age_add;
	chunk_t ticket_nonce, ticket, extensions;

	if (!reader->read_uint32(reader, &ticket_lifetime) ||
		!reader->read_uint32(reader, &ticket_age_add) ||
		!reader->read_data8(reader, &ticket_nonce) ||
		!reader->read_data16(reader, &ticket) ||
		!reader->read_data16(reader, &extensions))
	{
		DBG1(DBG_TLS, "received invalid NewSessionTicket");
		this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
		return NEED_MORE;
	}
	return NEED_MORE;
}
