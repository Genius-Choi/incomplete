static void process_footnotes(cmark_parser *parser) {
  // * Collect definitions in a map.
  // * Iterate the references in the document in order, assigning indices to
  //   definitions in the order they're seen.
  // * Write out the footnotes at the bottom of the document in index order.

  cmark_map *map = cmark_footnote_map_new(parser->mem);

  cmark_iter *iter = cmark_iter_new(parser->root);
  cmark_node *cur;
  cmark_event_type ev_type;

  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {
    cur = cmark_iter_get_node(iter);
    if (ev_type == CMARK_EVENT_EXIT && cur->type == CMARK_NODE_FOOTNOTE_DEFINITION) {
      cmark_footnote_create(map, cur);
    }
  }

  cmark_iter_free(iter);
  iter = cmark_iter_new(parser->root);
  unsigned int ix = 0;

  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {
    cur = cmark_iter_get_node(iter);
    if (ev_type == CMARK_EVENT_EXIT && cur->type == CMARK_NODE_FOOTNOTE_REFERENCE) {
      cmark_footnote *footnote = (cmark_footnote *)cmark_map_lookup(map, &cur->as.literal);
      if (footnote) {
        if (!footnote->ix)
          footnote->ix = ++ix;

        // store a reference to this footnote reference's footnote definition
        // this is used by renderers when generating label ids
        cur->parent_footnote_def = footnote->node;

        // keep track of a) count of how many times this footnote def has been
        // referenced, and b) which reference index this footnote ref is at.
        // this is used by renderers when generating links and backreferences.
        cur->footnote.ref_ix = ++footnote->node->footnote.def_count;

        char n[32];
        snprintf(n, sizeof(n), "%d", footnote->ix);
        cmark_chunk_free(parser->mem, &cur->as.literal);
        cmark_strbuf buf = CMARK_BUF_INIT(parser->mem);
        cmark_strbuf_puts(&buf, n);

        cur->as.literal = cmark_chunk_buf_detach(&buf);
      } else {
        cmark_node *text = (cmark_node *)parser->mem->calloc(1, sizeof(*text));
        cmark_strbuf_init(parser->mem, &text->content, 0);
        text->type = (uint16_t) CMARK_NODE_TEXT;

        cmark_strbuf buf = CMARK_BUF_INIT(parser->mem);
        cmark_strbuf_puts(&buf, "[^");
        cmark_strbuf_put(&buf, cur->as.literal.data, cur->as.literal.len);
        cmark_strbuf_putc(&buf, ']');

        text->as.literal = cmark_chunk_buf_detach(&buf);
        cmark_node_insert_after(cur, text);
        cmark_node_free(cur);
      }
    }
  }

  cmark_iter_free(iter);

  if (map->sorted) {
    qsort(map->sorted, map->size, sizeof(cmark_map_entry *), sort_footnote_by_ix);
    for (unsigned int i = 0; i < map->size; ++i) {
      cmark_footnote *footnote = (cmark_footnote *)map->sorted[i];
      if (!footnote->ix) {
        cmark_node_unlink(footnote->node);
        continue;
      }
      cmark_node_append_child(parser->root, footnote->node);
      footnote->node = NULL;
    }
  }

  cmark_unlink_footnotes_map(map);
  cmark_map_free(map);
}
