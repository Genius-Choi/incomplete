bool LoadBlockIndex(bool fAllowNew) {

    if(fTestNet) {
        pchMessageStart[0] = 0xfd;
        pchMessageStart[1] = 0xf2;
        pchMessageStart[2] = 0xf0;
        pchMessageStart[3] = 0xdf;

        bnProofOfStakeLimit = bnProofOfStakeLimitTestNet;
        bnProofOfWorkLimit  = bnProofOfWorkLimitTestNet;

        /* Positive time weight after 20 minutes */
        nStakeMinAge = 20 * 60;
        /* Full time weight at 20 hours (+20 minutes) */
        nStakeMaxAgeOne = 20 * 60 * 60;
        nStakeMaxAgeTwo = 20 * 60 * 60;
        /* Interval of 1 minute between stake modifiers */
        nModifierInterval = 60;
        /* Coin base and stake maturity */
        nCoinbaseMaturity = 10;
        /* NeoScrypt enabled always */
        fNeoScrypt = true;
    }

    //
    // Init with genesis block
    //
    CTxDB txdb("cr+");
    if(!txdb.LoadBlockIndex())
        return false;

    // Init with genesis block
    if(mapBlockIndex.empty()) {

        if(!fAllowNew) return false;

        CTransaction txNew;
        CBlock block;

        if(!fTestNet) {

            /* The Halcyon livenet genesis block */

            const char* pszTimestamp = "The ancient Greek myth of Halcyon is a tender story of love and commitment";
            txNew.nTime = 1408182502;
            txNew.vin.resize(1);
            txNew.vout.resize(1);
            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
            txNew.vout[0].SetEmpty();
            block.vtx.push_back(txNew);
            block.hashPrevBlock = 0;
            block.hashMerkleRoot = block.BuildMerkleTree();
            block.nVersion = 1;
            block.nTime    = 1408182502;
            block.nBits    = bnProofOfWorkLimit.GetCompact();
            block.nNonce   = 899198;

        } else {

/* The Halcyon testnet genesis block:
 * CBlock(hash=9a9e20c1cc8dc1297fc4842e1b358a576db6c985f6dc4a6b8cf16f36f69aa54d, ver=1, hashPrevBlock=0000000000000000000000000000000000000000000000000000000000000000, hashMerkleRoot=bef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362, nTime=1418677200, nBits=1f00ffff, nNonce=28699, vtx=1, vchBlockSig=)
 *   Coinbase(hash=bef44c6f33, nTime=1418677200, ver=1, vin.size=1, vout.size=1, nLockTime=0)
 *     CTxIn(COutPoint(0000000000, 4294967295), coinbase 00012a4c6d546865207465726d2048616c63796f6e206f726967696e617465732066726f6d2074686520477265656b206d797468206f6620416c63796f6e6520616e64206d65616e7320676f6c64656e206f72206d61726b656420627920706561636520616e642070726f73706572697479)
 *     CTxOut(empty)
 *   vMerkleTree: bef44c6f33 */

            const char* pszTimestamp = "The term Halcyon originates from the Greek myth of Alcyone and means golden or marked by peace and prosperity";
            txNew.nTime = 1418677200;
            txNew.vin.resize(1);
            txNew.vout.resize(1);
            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
            txNew.vout[0].SetEmpty();
            block.vtx.push_back(txNew);
            block.hashPrevBlock = 0;
            block.hashMerkleRoot = block.BuildMerkleTree();
            block.nVersion = 1;
            block.nTime    = 1418677200;
            block.nBits    = bnProofOfWorkLimitTestNet.GetCompact();
            block.nNonce   = 28699;

        }

        //// debug print
        printf("%s\n", block.GetHash().ToString().c_str());
        printf("%s\n", block.hashMerkleRoot.ToString().c_str());

        if(!fTestNet) assert(block.hashMerkleRoot ==
          uint256("0xb761dad6c210bae0a6c1abeec2d7cb83624e34702d3912acba8bef58a932183b"));
        else assert(block.hashMerkleRoot ==
          uint256("0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362"));

        // If no match on genesis block hash, then generate one
        if(false && ((fTestNet && (block.GetHash() != hashGenesisBlockTestNet)) ||
                    (!fTestNet && (block.GetHash() != hashGenesisBlock)))) {

            printf("Genesis block mining...\n");

            uint profile = 0x0;
            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();
            uint256 hash;

            while(true) {
                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);
                if(hash <= hashTarget) break;
                if(!(block.nNonce & 0xFFF))
                  printf("nonce %08X: hash = %s (target = %s)\n",
                    block.nNonce, hash.ToString().c_str(),
                    hashTarget.ToString().c_str());
                ++block.nNonce;
                if(!block.nNonce) {
                    printf("nonce limit reached, incrementing time\n");
                    ++block.nTime;
                }
            }
            printf("block.nTime = %u \n", block.nTime);
            printf("block.nNonce = %u \n", block.nNonce);
            printf("block.GetHash = %s\n", block.GetHash().ToString().c_str());
            printf("block.GetHashPoW = %s\n", block.GetHashPoW().ToString().c_str());
        }

        block.print();
        if(!fTestNet) assert(block.GetHash() == hashGenesisBlock);
        else assert(block.GetHash() == hashGenesisBlockTestNet);

        // Start new block file
        unsigned int nFile;
        unsigned int nBlockPos;
        if (!block.WriteToDisk(nFile, nBlockPos))
            return error("LoadBlockIndex() : writing genesis block to disk failed");
        if (!block.AddToBlockIndex(nFile, nBlockPos, 0))
            return error("LoadBlockIndex() : genesis block not accepted");

        // ppcoin: initialize synchronized checkpoint
        if (!Checkpoints::WriteSyncCheckpoint((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)))
            return error("LoadBlockIndex() : failed to init sync checkpoint");
    }

    string strPubKey = "";

    // if checkpoint master key changed must reset sync-checkpoint
    if (!txdb.ReadCheckpointPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMasterPubKey)
    {
        // write checkpoint master key to db
        txdb.TxnBegin();
        if (!txdb.WriteCheckpointPubKey(CSyncCheckpoint::strMasterPubKey))
            return error("LoadBlockIndex() : failed to write new checkpoint master key to db");
        if (!txdb.TxnCommit())
            return error("LoadBlockIndex() : failed to commit new checkpoint master key to db");
        if ((!fTestNet) && !Checkpoints::ResetSyncCheckpoint())
            return error("LoadBlockIndex() : failed to reset sync-checkpoint");
    }

    return true;
}
