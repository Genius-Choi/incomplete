uint256 CBlockIndex::GetBlockTrust() const {
    CBigNum bnTarget;
    bnTarget.SetCompact(nBits);

    if(bnTarget <= 0) return(0);

    /* Old protocol */

    if(!fTestNet && (nHeight < nForkOne))
      return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());

    /* New protocol: 80% PoS, 20% PoW */

    uint256 nBlockTrust = 1;

    if(IsProofOfWork()) {

        uint256 nPoWBase  = uint256("0x00000000FFFF0000000000000000000000000000000000000000000000000000");
        uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();

        /* The minimal PoW trust score prior to correction */
        if(nPoWTrust < 4) nPoWTrust = 4;

        /* Fixed trust for the first 10 blocks */
        if((pprev == NULL) || (pprev->nHeight < 10))
          return(nPoWTrust);

        const CBlockIndex* pindexP1 = pprev;
        const CBlockIndex* pindexP2 = pindexP1->pprev;

        if(pindexP1->IsProofOfStake()) {
            /* 100% trust for PoW following PoS */
            nBlockTrust = nPoWTrust;
        } else {
            if(pindexP2->IsProofOfStake()) {
                /* 50% trust for PoS->PoW->PoW */
                nBlockTrust = (nPoWTrust >> 1);
            } else {
                /* 25% trust for PoW->PoW->PoW */
                nBlockTrust = (nPoWTrust >> 2);
            }
        }

    } else {

        const CBlockIndex* pindexP1 = pprev;
        const CBlockIndex* pindexP2 = pindexP1->pprev;
        const CBlockIndex* pindexP3 = pindexP2->pprev;

        /* PoS difficulty is very low and of little use for trust scoring;
         * use full trust of the previous PoW block as a basis instead */
        uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;

        if(pindexP1->IsProofOfWork()) {
            /* 200% trust for PoS following PoW */
            if(pindexP2->IsProofOfStake()) {
                /* PoS->PoW->PoS: 100% to 200% */
                nBlockTrust = (nPrevTrust << 1);
            } else {
                if(pindexP3->IsProofOfStake()) {
                    /* PoS->PoW->PoW->PoS: 50% to 200% */
                    nBlockTrust = (nPrevTrust << 2);
                } else {
                    /* PoW->PoW->PoW->PoS: 25% to 200% */
                    nBlockTrust = (nPrevTrust << 3);
                }
            }
        } else {
            if(pindexP2->IsProofOfWork()) {
                /* 150% of trust for PoW->PoS->PoS */
                nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();
            } else {
                if(pindexP3->IsProofOfWork()) {
                    /* 120% of trust for PoW->PoS->PoS->PoS */
                    nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();
                } else {
                    const CBlockIndex* pindexP4 = pindexP3->pprev;
                    if(pindexP4->IsProofOfWork()) {
                        /* 100% of trust for PoW->PoS->PoS->PoS->PoS */
                        nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();
                    } else {
                        const CBlockIndex* pindexP5 = pindexP4->pprev;
                        if(pindexP5->IsProofOfWork()) {
                            /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */
                            nBlockTrust = (nPrevTrust >> 1);
                        } else {
                            /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */
                            nBlockTrust = nPrevTrust;
                        }
                    }
                }
            }
        }

    }

    return(nBlockTrust);
}
