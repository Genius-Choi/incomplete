bool CBlock::CheckBlock() const {
    uint i;

    // These are checks that are independent of context
    // that can be verified before saving an orphan block.

    // Size limits
    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)
        return DoS(100, error("CheckBlock() : size limits failed"));

    // Check timestamp
    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))
        return error("CheckBlock() : block timestamp too far in the future");

    // First transaction must be coinbase, the rest must not be
    if (vtx.empty() || !vtx[0].IsCoinBase())
        return DoS(100, error("CheckBlock() : first tx is not coinbase"));
    for(i = 1; i < vtx.size(); i++) {
        if(vtx[i].IsCoinBase())
          return(DoS(100, error("CheckBlock() : more than one coin base")));
    }

    // Check coinbase timestamp
    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))
        return DoS(50, error("CheckBlock() : coinbase timestamp is too early"));

    if(IsProofOfStake()) {

        // Coinbase output should be empty if proof-of-stake block
        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())
            return DoS(100, error("CheckBlock() : coinbase output not empty for proof-of-stake block"));

        // Second transaction must be coinstake, the rest must not be
        if (vtx.empty() || !vtx[1].IsCoinStake())
            return DoS(100, error("CheckBlock() : second tx is not coinstake"));
        for(i = 2; i < vtx.size(); i++) {
            if(vtx[i].IsCoinStake())
              return(DoS(100, error("CheckBlock() : more than one coin stake")));
        }

        // Check coinstake timestamp
        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))
            return DoS(50, error("CheckBlock() : coinstake timestamp violation nTimeBlock=%"PRId64" nTimeTx=%u", GetBlockTime(), vtx[1].nTime));

        // NovaCoin: check proof-of-stake block signature
        if(!CheckBlockSignature())
            return DoS(100, error("CheckBlock() : bad proof-of-stake block signature"));

    } else {

        /* No coin stakes in PoW blocks */
        for(i = 1; i < vtx.size(); i++) {
            if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))
              return(DoS(100, error("CheckBlock() : rogue coin stake")));
        }

        /* Proof-of-work verification against target */
        if(!CheckProofOfWork(GetHashPoW(), nBits))
          return(DoS(50, error("CheckBlock() : proof-of-work verification failed")));

        /* Proof-of-work block signature verification */
        if(!CheckBlockSignature())
          return(DoS(100, error("CheckBlock() : bad proof-of-work block signature")));
    }

    // Check transactions
    BOOST_FOREACH(const CTransaction& tx, vtx)
    {
        if (!tx.CheckTransaction())
            return DoS(tx.nDoS, error("CheckBlock() : CheckTransaction failed"));

        // ppcoin: check transaction timestamp
        if (GetBlockTime() < (int64_t)tx.nTime)
            return DoS(50, error("CheckBlock() : block timestamp earlier than transaction timestamp"));
    }

    /* Merkle root verification */
    if(hashMerkleRoot != BuildMerkleTree())
      return(DoS(100, error("CheckBlock() : merkle root verification failed")));

    /* Check for duplicate transactions */
    set<uint256> uniqueTx;
    BOOST_FOREACH(const CTransaction& tx, vtx) {
        uniqueTx.insert(tx.GetHash());
    }
    if(uniqueTx.size() != vtx.size())
      return(DoS(100, error("CheckBlock() : duplicate transaction found")));

    unsigned int nSigOps = 0;
    BOOST_FOREACH(const CTransaction& tx, vtx)
    {
        nSigOps += tx.GetLegacySigOpCount();
    }
    if (nSigOps > MAX_BLOCK_SIGOPS)
        return DoS(100, error("CheckBlock() : out-of-bounds SigOpCount"));

    return(true);
}
