RZ_API int rz_bin_object_set_items(RzBinFile *bf, RzBinObject *o) {
	rz_return_val_if_fail(bf && o && o->plugin, false);

	RzBin *bin = bf->rbin;
	RzBinPlugin *p = o->plugin;
	int minlen = (bf->rbin->minstrlen > 0) ? bf->rbin->minstrlen : p->minstrlen;
	bf->o = o;

	if (p->file_type) {
		int type = p->file_type(bf);
		if (type == RZ_BIN_TYPE_CORE) {
			if (p->regstate) {
				o->regstate = p->regstate(bf);
			}
		}
	}

	if (p->boffset) {
		o->boffset = p->boffset(bf);
	}
	// XXX: no way to get info from xtr pluginz?
	// Note, object size can not be set from here due to potential
	// inconsistencies
	if (p->size) {
		o->size = p->size(bf);
	}
	// XXX this is expensive because is O(n^n)
	if (p->binsym) {
		for (size_t i = 0; i < RZ_BIN_SPECIAL_SYMBOL_LAST; i++) {
			o->binsym[i] = p->binsym(bf, i);
			if (o->binsym[i]) {
				o->binsym[i]->paddr += o->opts.loadaddr;
			}
		}
	}
	if (p->entries) {
		o->entries = p->entries(bf);
		REBASE_PADDR(o, o->entries, RzBinAddr);
	}
	if (p->virtual_files) {
		o->vfiles = p->virtual_files(bf);
	}
	if (p->maps) {
		o->maps = p->maps(bf);
		if (o->maps) {
			REBASE_PADDR(o, o->maps, RzBinMap);
		}
	}
	if (p->fields) {
		o->fields = p->fields(bf);
		if (o->fields) {
			rz_warn_if_fail(o->fields->free);
			REBASE_PADDR(o, o->fields, RzBinField);
		}
	}
	if (p->imports) {
		rz_list_free(o->imports);
		o->imports = p->imports(bf);
		if (o->imports) {
			rz_warn_if_fail(o->imports->free);
		}
	}
	if (p->symbols) {
		o->symbols = p->symbols(bf);
		if (o->symbols) {
			REBASE_PADDR(o, o->symbols, RzBinSymbol);
			if (bin->filter) {
				rz_bin_filter_symbols(bf, o->symbols);
			}
			o->import_name_symbols = ht_pp_new0();
			if (o->import_name_symbols) {
				RzBinSymbol *sym;
				RzListIter *it;
				rz_list_foreach (o->symbols, it, sym) {
					if (!sym->is_imported || !sym->name || !*sym->name) {
						continue;
					}
					ht_pp_insert(o->import_name_symbols, sym->name, sym);
				}
			}
		}
	}
	if (p->libs) {
		o->libs = p->libs(bf);
	}
	if (p->sections) {
		// XXX sections are populated by call to size
		if (!o->sections) {
			o->sections = p->sections(bf);
		}
		REBASE_PADDR(o, o->sections, RzBinSection);
		if (bin->filter) {
			rz_bin_filter_sections(bf, o->sections);
		}
	}

	o->info = p->info ? p->info(bf) : NULL;

	if (bin->filter_rules & (RZ_BIN_REQ_RELOCS | RZ_BIN_REQ_IMPORTS)) {
		if (p->relocs) {
			RzList *l = p->relocs(bf);
			if (l) {
				REBASE_PADDR(o, l, RzBinReloc);
				o->relocs = rz_bin_reloc_storage_new(l);
			}
		}
	}
	if (bin->filter_rules & RZ_BIN_REQ_STRINGS) {
		RzList *strings;
		if (p->strings) {
			strings = p->strings(bf);
		} else {
			// when a bin plugin does not provide it's own strings
			// we always take all the strings found in the binary
			// the method also converts the paddrs to vaddrs
			strings = rz_bin_file_strings(bf, minlen, true);
		}

		if (bin->debase64) {
			bin_object_decode_all_base64_strings(strings);
		}
		REBASE_PADDR(o, strings, RzBinString);

		// RzBinStrDb becomes the owner of the RzList strings
		o->strings = rz_bin_string_database_new(strings);
	}

	if (o->info && RZ_STR_ISEMPTY(o->info->compiler)) {
		free(o->info->compiler);
		o->info->compiler = rz_bin_file_golang_compiler(bf);
		if (o->info->compiler) {
			o->info->lang = "go";
		}
	}

	o->lang = rz_bin_language_detect(bf);

	if (bin->filter_rules & (RZ_BIN_REQ_CLASSES | RZ_BIN_REQ_CLASSES_SOURCES)) {
		if (p->classes) {
			RzList *classes = p->classes(bf);
			if (classes) {
				// XXX we should probably merge them instead
				rz_list_free(o->classes);
				o->classes = classes;
				rz_bin_object_rebuild_classes_ht(o);
			}

			if (o->lang == RZ_BIN_LANGUAGE_SWIFT) {
				o->classes = classes_from_symbols(bf);
			}
		} else {
			RzList *classes = classes_from_symbols(bf);
			if (classes) {
				o->classes = classes;
			}
		}

		if (bin->filter) {
			filter_classes(bf, o->classes);
		}

		// cache addr=class+method
		if (o->classes) {
			RzList *klasses = o->classes;
			RzListIter *iter, *iter2;
			RzBinClass *klass;
			RzBinSymbol *method;
			if (!o->addrzklassmethod) {
				// this is slow. must be optimized, but at least its cached
				o->addrzklassmethod = ht_up_new0();
				rz_list_foreach (klasses, iter, klass) {
					rz_list_foreach (klass->methods, iter2, method) {
						ht_up_insert(o->addrzklassmethod, method->vaddr, method);
					}
				}
			}
		}
	}
	if (p->lines) {
		o->lines = p->lines(bf);
	}
	if (p->get_sdb) {
		Sdb *new_kv = p->get_sdb(bf);
		if (new_kv != o->kv) {
			sdb_free(o->kv);
		}
		o->kv = new_kv;
	}
	if (p->mem) {
		o->mem = p->mem(bf);
	}
	if (p->resources) {
		o->resources = p->resources(bf);
	}
	return true;
}
