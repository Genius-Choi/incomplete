void gf_sg_proto_del_instance(GF_ProtoInstance *inst)
{
	GF_SceneGraph *sg;

	while (gf_list_count(inst->fields)) {
		GF_ProtoField *field = (GF_ProtoField *)gf_list_get(inst->fields, 0);
		gf_list_rem(inst->fields, 0);

		if (field->field_pointer) {
			/*regular type*/
			if ( (field->FieldType!=GF_SG_VRML_SFNODE) && (field->FieldType!=GF_SG_VRML_MFNODE)) {
				gf_sg_vrml_field_pointer_del(field->field_pointer, field->FieldType);
			}
			/*node types: delete instances*/
			else {
				if (field->FieldType == GF_SG_VRML_SFNODE) {
					gf_node_unregister((GF_Node *) field->field_pointer, (GF_Node *) inst);
				} else {
					GF_ChildNodeItem *list = (GF_ChildNodeItem *)field->field_pointer;
					while (list) {
						GF_ChildNodeItem *cur = list;
						gf_node_unregister(list->node, (GF_Node *) inst);
						list = list->next;
						gf_free(cur);
					}
				}
			}
		}
		
		gf_free(field);
	}
	gf_list_del(inst->fields);

	/*destroy the code*/
	while (gf_list_count(inst->node_code)) {
		GF_Node *node = (GF_Node*)gf_list_get(inst->node_code, 0);
		gf_node_unregister(node, (GF_Node*) inst);
		gf_list_rem(inst->node_code, 0);
	}

	sg = inst->sgprivate->scenegraph;

	/*reset the scene graph before destroying the node code list, as unregistering nodes
	not destroyed in the previous phase (eg, cyclic references such as script and co) will
	refer to the node-code list*/
	gf_sg_reset(sg);
	sg->pOwningProto = NULL;

	gf_free((char *) inst->proto_name);
	gf_list_del(inst->node_code);
	assert(!gf_list_count(inst->scripts_to_load));
	gf_list_del(inst->scripts_to_load);

	if (inst->proto_interface && inst->proto_interface->instances) gf_list_del_item(inst->proto_interface->instances, inst);

	gf_node_free((GF_Node *)inst);
	gf_sg_del(sg);
}
