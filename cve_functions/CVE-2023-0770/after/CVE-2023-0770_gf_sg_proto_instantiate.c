void gf_sg_proto_instantiate(GF_ProtoInstance *proto_node)
{
	GF_Node *node, *orig;
	GF_Route *route, *r2;
	u32 i, count;
	GF_Proto *proto = proto_node->proto_interface;
	GF_Proto *owner = proto;

	if (!proto) return;

	if (owner->ExternProto.count) {
		GF_ProtoFieldInterface *pfi;
		GF_SceneGraph *extern_lib;
		if (!owner->parent_graph->GetExternProtoLib) return;
		extern_lib = owner->parent_graph->GetExternProtoLib(proto->parent_graph->userpriv, &owner->ExternProto);
		if (!extern_lib) return;

		/*this is an hardcoded proto - all routes, node modifications and co are handled internally*/
		if (PTR_TO_U_CAST extern_lib == GF_SG_INTERNAL_PROTO) {
			proto_node->sgprivate->flags |= GF_SG_NODE_DIRTY;
			// take default values
			count = gf_list_count(owner->proto_fields);
			for (i=0; i<count; i++) {
				GF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);
				if (!pf->has_been_accessed) {
					pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);
					gf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);
				}
			}
			owner->parent_graph->NodeCallback(owner->parent_graph->userpriv, GF_SG_CALLBACK_INIT, (GF_Node *) proto_node, NULL);
			proto_node->flags |= GF_SG_PROTO_LOADED | GF_SG_PROTO_HARDCODED;
			return;
		}
		/*not loaded yet*/
		if (!gf_list_count(extern_lib->protos)) return;

		/*overwrite this proto by external one*/
		proto = NULL;
		/*start with proto v2 addressing*/
		if (owner->ExternProto.vals[0].url) {
			u32 ID = (u32) -1;
			char *szName = strrchr(owner->ExternProto.vals[0].url, '#');
			if (szName) {
				szName++;
				if (sscanf(szName, "%u", &ID)) ID = (u32) -1;
			}
			/*if we have the proto name, use it*/
			if (owner->Name) szName = owner->Name;
			proto = gf_sg_find_proto(extern_lib, ID, szName);
		}
		if (!proto) proto = gf_sg_find_proto(extern_lib, owner->ID, owner->Name);
		if (!proto) proto = find_proto_by_interface(extern_lib, owner);

		if (proto && !is_same_proto(owner, proto)) {
			proto = NULL;
			GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, ("[Scenegraph] fields/types mismatch for PROTO %s - skipping instantiation\n", owner->Name));
		}
		/*couldn't find proto in the given lib, consider the proto as loaded (give up)*/
		if (!proto) {
			proto_node->flags |= GF_SG_PROTO_LOADED;
			return;
		}
		/*cf VRML: once an external proto is loaded, copy back the default field values of the external proto*/
		count = gf_list_count(owner->proto_fields);
		for (i=0; i<count; i++) {
			GF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);
			if (!pf->has_been_accessed) {
				pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);
				gf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);
			} else {
				//pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);
			}
		}

		/*unregister from prev and reg with real proto*/
		gf_list_del_item(owner->instances, proto_node);
		gf_list_add(proto->instances, proto_node);
	}

	/*OVERRIDE the proto instance (eg don't instantiate an empty externproto...)*/
	proto_node->proto_interface = proto;

	/*clone all nodes*/
	i=0;
	while ((orig = (GF_Node*)gf_list_enum(proto->node_code, &i))) {
		/*node is cloned in the new scenegraph and its parent is NULL */
		node = gf_node_clone(proto_node->sgprivate->scenegraph, orig, NULL, "", 1);
		assert(node);

		/*assign first rendering node*/
		if (i==1) proto_node->RenderingNode = node;
		gf_list_add(proto_node->node_code, node);
	}

	/*instantiate routes (not ISed ones)*/
	i=0;
	while ((route = (GF_Route*)gf_list_enum(proto->sub_graph->Routes, &i))) {
		if (route->IS_route) continue;

		r2 = gf_sg_route_new(proto_node->sgprivate->scenegraph,
		                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->FromNode) ),
		                     route->FromField.fieldIndex,
		                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->ToNode) ),
		                     route->ToField.fieldIndex);

		if (route->ID) gf_sg_route_set_id(r2, route->ID);
		if (route->name) gf_sg_route_set_name(r2, route->name);
	}
	/*activate all ISed fields so that inits on events is properly done*/
	i=0;
	while ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {
		if (!route->IS_route) continue;
		/*do not activate eventIn to eventIn routes*/
		if (route->is_setup) {
			if ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;
		}
		gf_sg_route_activate(route);
	}
	/*and load all scripts (this must be done once all fields are routed for the "initialize" method)*/
	while (gf_list_count(proto_node->scripts_to_load)) {
		node = (GF_Node*)gf_list_get(proto_node->scripts_to_load, 0);
		gf_list_rem(proto_node->scripts_to_load, 0);
		gf_sg_script_load(node);
	}
	/*re-activate all ISed fields pointing to scripts once scripts are loaded (eventIns)*/
	i=0;
	while ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {
		if (!route->IS_route || !route->ToNode) continue;
		/*		assert(route->is_setup);
				if ((route->FromField.eventType == GF_SG_EVENT_OUT) || (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;
		*/

		if (route->is_setup) {
			if ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;
		}

		if (route->ToNode->sgprivate->tag==TAG_MPEG4_Script)
			gf_sg_route_activate(route);
#ifndef GPAC_DISABLE_X3D
		else if (route->ToNode->sgprivate->tag==TAG_X3D_Script)
			gf_sg_route_activate(route);
#endif
	}

#if 0
	/*reset all regular route activation times - if we don't do so, creating a proto by script and then manipulating one of its
	ISed field may not trigger the proper routes*/
	i=0;
	while ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {
		if (!route->IS_route) {
			route->lastActivateTime = 0;
		}
	}
#endif
	proto_node->flags |= GF_SG_PROTO_LOADED;
}
