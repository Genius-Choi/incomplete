GF_Err gf_sg_proto_field_set_ised(GF_Proto *proto, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)
{
	GF_Err e;
	GF_Route *r;
	GF_FieldInfo field, nodeField;
	field.fieldIndex = protoFieldIndex;
	e = gf_sg_proto_get_field(proto, NULL, &field);
	if (e) return e;
	e = gf_node_get_field(node, nodeFieldIndex, &nodeField);
	if (e) return e;
	if (field.fieldType != nodeField.fieldType) {
		if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {
//			e = GF_OK;
		} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {
//			e = GF_OK;
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, ("[VRML] error in IS - node field %s.%s - inType %s - outType %s\n", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));
			return GF_SG_INVALID_PROTO;
		}
	}

	GF_SAFEALLOC(r, GF_Route)
	if (!r) return GF_OUT_OF_MEM;
	r->IS_route = 1;

	if (nodeField.eventType==GF_SG_EVENT_OUT) {
		r->FromField.fieldIndex = nodeFieldIndex;
		r->FromNode = node;
		r->ToField.fieldIndex = protoFieldIndex;
		r->ToNode = NULL;
		if (!node->sgprivate->interact) {
			GF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);
			if (!node->sgprivate->interact) {
				return GF_OUT_OF_MEM;
			}
		}
		if (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();
		gf_list_add(node->sgprivate->interact->routes, r);
	} else {
		switch (field.eventType) {
		case GF_SG_EVENT_FIELD:
		case GF_SG_EVENT_EXPOSED_FIELD:
		case GF_SG_EVENT_IN:
			r->FromField.fieldIndex = protoFieldIndex;
			r->FromNode = NULL;
			r->ToField.fieldIndex = nodeFieldIndex;
			r->ToNode = node;
			/*create an ISed route for the eventOut part of the exposedFIeld*/
			if ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {
				GF_Route *r2;
				GF_SAFEALLOC(r2, GF_Route);
				if (!r2) {
					gf_free(r);
					return GF_OUT_OF_MEM;
				}
				r2->IS_route = 1;
				r2->FromField.fieldIndex = nodeFieldIndex;
				r2->FromNode = node;
				r2->ToField.fieldIndex = protoFieldIndex;
				r2->ToNode = NULL;
				r2->graph =  proto->sub_graph;
				if (!node->sgprivate->interact) {
					GF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);
					if (!node->sgprivate->interact) return GF_OUT_OF_MEM;
				}
				if (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();
				gf_list_add(node->sgprivate->interact->routes, r2);
				gf_list_add(proto->sub_graph->Routes, r2);
			}
			break;
		case GF_SG_EVENT_OUT:
			r->FromField.fieldIndex = nodeFieldIndex;
			r->FromNode = node;
			r->ToField.fieldIndex = protoFieldIndex;
			r->ToNode = NULL;
			if (!node->sgprivate->interact) {
				GF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);
				if (!node->sgprivate->interact) return GF_OUT_OF_MEM;
			}
			if (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();
			break;
		default:
			gf_free(r);
			return GF_BAD_PARAM;
		}
	}
	r->graph = proto->sub_graph;
	return gf_list_add(proto->sub_graph->Routes, r);
}
