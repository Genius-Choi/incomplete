vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, 
	int len_bytes )
{
        int needle_len = g_utf8_strlen( needle_start, -1 );
        int needle_len_bytes = strlen( needle_start );

	const char *haystack;

	for( haystack = haystack_start; 
		haystack - haystack_start <= len_bytes - needle_len_bytes; 
		haystack = g_utf8_find_next_char( haystack, NULL ) ) {
                const char *needle_char;
                const char *haystack_char;
		int i;

                haystack_char = haystack;
                needle_char = needle_start;
                for( i = 0; i < needle_len; i++ ) {
			/* Haystack isn't necessarily null-terminated and
			 * might end half-way through a utf-8 character, so we
			 * need to be careful not to run off the end.
			 */
                        gunichar a = 
				g_utf8_get_char_validated( haystack_char, 
					haystack_start + len_bytes - haystack );
                        gunichar b = 
				g_utf8_get_char_validated( needle_char, -1 );

                        /* Invalid utf8? 
			 *
			 * gunichar is a uint32, so we can't compare < 0, we 
			 * have to look for -1 and -2 (the two possible error 
			 * values).
                         */
                        if( a == (gunichar) -1 ||
				a == (gunichar) -2 ||
				b == (gunichar) -1 ||
				b == (gunichar) -2 )
                                return( NULL );

                        /* Disallow codepoint U+0000 as it's a nul byte.
                         * This is redundant with GLib >= 2.63.0, see:
                         * https://gitlab.gnome.org/GNOME/glib/-/merge_requests/967
                         */
#if !GLIB_CHECK_VERSION( 2, 63, 0 )
                        if( a == (gunichar) 0 )
                                return( NULL );
#endif

                        /* Mismatch.
                         */
                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )
                                break;

                        haystack_char = 
				g_utf8_find_next_char( haystack_char, 
					haystack_start + len_bytes );

                        /* End of haystack. There can't be a complete needle
                         * anywhere.
                         */
                        if( haystack_char == NULL )
                                return( NULL );

                        /* needle_char will never be NULL.
                         */
                        needle_char = 
				g_utf8_find_next_char( needle_char, NULL );
                }

                if( i == needle_len )
			/* Walked the whole of needle, so we must have found a 
			 * complete match.
			 */
                        return( haystack );
        }

        /* Walked the whole of haystack without finding a match.
         */
        return( NULL );
}
