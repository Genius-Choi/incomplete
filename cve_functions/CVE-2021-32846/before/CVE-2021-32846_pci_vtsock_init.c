pci_vtsock_init(struct pci_devinst *pi, char *opts)
{
	uint64_t guest_cid = VMADDR_CID_ANY;
	const char *path = NULL;
	char *guest_forwards = NULL;
	struct pci_vtsock_softc *sc;
	struct sockaddr_un un;
	int i, pipefds[2];

	if (opts == NULL) {
		printf("virtio-sock: configuration required\n");
		return (1);
	}

	while (1) {
		char *next;
		if (! opts)
			break;
		next = strchr(opts, ',');
		if (next)
			next[0] = '\0';
		if (strncmp(opts, "guest_cid=", 10) == 0) {
			int tmp = atoi(&opts[10]);
			if (tmp <= 0) {
				fprintf(stderr, "bad guest cid: %s\r\n", opts);
				return 1;
			}
			guest_cid = (uint32_t)tmp;
		} else if (strncmp(opts, "path=", 5) == 0) {
			path = copy_up_to_comma(opts + 5);
		} else if (strncmp(opts, "guest_forwards=", 15) == 0) {
			guest_forwards = copy_up_to_comma(opts + 15);
		} else {
			fprintf(stderr, "invalid option: %s\r\n", opts);
			return 1;
		}

		if (! next)
			break;
		opts = &next[1];
	}
	if (guest_cid == VMADDR_CID_ANY || path == NULL) {
		fprintf(stderr, "guest_cid and path options are both required.\n");
		return 1;
	}

	if (guest_cid <= VMADDR_CID_HOST || guest_cid >= VMADDR_CID_MAX) {
		fprintf(stderr, "invalid guest_cid "PRIcid"\n", guest_cid);
		return 1;
	}

	/*
	 * We need to be able to construct socket paths of the form
	 * "%08x.%08x" cid,port.
	 */
	if (strlen(path) + sizeof("/00000000.00000000") > sizeof(un.sun_path)) {
		printf("virtio-sock: path too long\n");
		return (1);
	}

	/* XXX confirm path exists and is a directory */

	fprintf(stderr, "vsock init %d:%d = %s, guest_cid = "PRIcid"\n\r",
		pi->pi_slot, pi->pi_func, path, guest_cid);

	sc = calloc(1, sizeof(struct pci_vtsock_softc));

	LIST_INIT(&sc->free_list);
	LIST_INIT(&sc->inuse_list);

	for (i = 0; i < VTSOCK_MAXSOCKS; i++) {
		struct pci_vtsock_sock *str = &sc->socks[i];
		int err = pthread_mutex_init(&str->mtx, NULL);
		assert(err == 0);
		str->state = SOCK_FREE;
		str->fd = -1;
		str->port_generation = 0;
		LIST_INSERT_HEAD(&sc->free_list, str, list);
	}

	sc->nr_fwds = 0;
	for (i = 0; i < VTSOCK_MAXFWDS; i++) {
		struct pci_vtsock_forward *fwd = &sc->fwds[i];
		fwd->listen_fd = -1;
	}

	pthread_mutex_init(&sc->vssc_mtx, NULL);
	pthread_mutex_init(&sc->reply_mtx, NULL);
	pthread_rwlock_init(&sc->list_rwlock, NULL);

	sc->path = strdup(path);

	/* init virtio softc and virtqueues */
	vi_softc_linkup(&sc->vssc_vs, &vtsock_vi_consts, sc, pi, sc->vssc_vqs);
	sc->vssc_vs.vs_mtx = &sc->vssc_mtx;

	sc->vssc_vqs[VTSOCK_QUEUE_RX].vq_qsize = VTSOCK_RINGSZ;
	sc->vssc_vqs[VTSOCK_QUEUE_RX].vq_notify = pci_vtsock_notify_rx;

	sc->vssc_vqs[VTSOCK_QUEUE_TX].vq_qsize = VTSOCK_RINGSZ;
	sc->vssc_vqs[VTSOCK_QUEUE_TX].vq_notify = pci_vtsock_notify_tx;

	/* Unused, make it small */
	sc->vssc_vqs[VTSOCK_QUEUE_EVT].vq_qsize = 4;
	sc->vssc_vqs[VTSOCK_QUEUE_EVT].vq_notify = pci_vtsock_notify_evt;

	/* setup virtio sock config space */
	sc->vssc_cfg.guest_cid = guest_cid;

	/*
	 * Should we move some of this into virtio.c?  Could
	 * have the device, class, and subdev_0 as fields in
	 * the virtio constants structure.
	 */
	pci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_SOCK);
	pci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);
	pci_set_cfgdata8(pi, PCIR_REVID, 0 /*LEGACY 1*/);
	pci_set_cfgdata8(pi, PCIR_CLASS, PCIC_NETWORK);
	pci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_SOCK);
	pci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);

	if (vi_intr_init(&sc->vssc_vs, 1, fbsdrun_virtio_msix()))
		return (1);
	vi_set_io_bar(&sc->vssc_vs, 0);

	sc->connect_fd = -1;
	if (open_connect_socket(sc))
		return (1);

	if (open_forward_sockets(sc, guest_forwards))
		return (1);

	if (pipe(pipefds))
		return (1);
	sc->tx_wake_fd = pipefds[0];
	sc->tx_kick_fd = pipefds[1];

	assert(sc->tx_wake_fd < FD_SETSIZE);

	sc->rx_kick_pending = false;

	if (pthread_create(&sc->tx_thread, NULL,
			   pci_vtsock_tx_thread, sc))
		return (1);

	if (pipe(pipefds))
		return (1);
	sc->rx_wake_fd = pipefds[0];
	sc->rx_kick_fd = pipefds[1];

	assert(sc->rx_wake_fd < FD_SETSIZE);

	sc->reply_prod = 0;
	sc->reply_cons = 0;

	if (pthread_create(&sc->rx_thread, NULL,
			   pci_vtsock_rx_thread, sc))
		return (1);

	return (0);
}
