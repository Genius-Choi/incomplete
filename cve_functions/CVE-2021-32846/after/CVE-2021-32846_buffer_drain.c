static void buffer_drain(struct pci_vtsock_softc *sc,
			 struct pci_vtsock_sock *sock)
{
	ssize_t nr;

	DPRINTF(("TX: buffer drain on fd %d 0x%x-0x%x/0x%x\n",
		 sock->fd, sock->write_buf_head, sock->write_buf_tail,
		 WRITE_BUF_LENGTH));

	assert(sock_is_buffering(sock));
	assert(sock->write_buf_head < sock->write_buf_tail);

	nr = write(sock->fd, &sock->write_buf[sock->write_buf_head],
		   sock->write_buf_tail - sock->write_buf_head);
	if (nr == -1) {
		if (errno == EPIPE) {
			/* Assume EOF and shutdown */
			shutdown_local_sock("TX", sock, VIRTIO_VSOCK_FLAG_SHUTDOWN_RX);
			send_response_sock(sc, VIRTIO_VSOCK_OP_SHUTDOWN,
					   sock->local_shutdown, sock);
			return;
		} else if (errno == EAGAIN) {
			return;
		} else {
			PPRINTF(("TX: write fd=%d failed with %d %s\n", sock->fd,
				 errno, strerror(errno)));
			send_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);
			close_sock(sc, sock, "TX");
			return;
		}
	}

	DPRINTF(("TX: drained %zd/%"PRId32" bytes\n", nr,
		 sock->write_buf_tail - sock->write_buf_head));
	sock->write_buf_head += nr;
	if (sock->write_buf_head < sock->write_buf_tail)
		return;

	/* Buffer completely drained, reset and update peer.  NB: We
	 * only update fwd_cnt once the buffer is empty rather than as
	 * we go, in the hopes that we then won't need to buffer so
	 * much as we go on.
	 */
	DPRINTF(("TX: fd %d buffer drained of 0x%x bytes\n",
		 sock->fd, sock->write_buf_head));
	sock->fwd_cnt += sock->write_buf_head;
	sock->write_buf_head = sock->write_buf_tail = 0;

	/* shutdown_peer_local_fd will have deferred this if we were buffering */
	if ((sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) &&
	    !(sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX)) {
		int rc = shutdown(sock->fd, SHUT_WR);
		PPRINTF(("TX: buffer_drained, performing pending shutdown(%d, SHUT_WR)\n", sock->fd));
		if (rc < 0 && errno != ENOTCONN) {
			DPRINTF(("TX: shutdown(%d, SHUT_WR) after buffer drain failed: %s\n",
				 sock->fd, strerror(errno)));
			abort();
		}
		sock->local_shutdown |= VIRTIO_VSOCK_FLAG_SHUTDOWN_RX;
	}

	set_credit_update_required(sc, sock);
}
