static int handle_write(struct pci_vtsock_softc *sc,
			struct pci_vtsock_sock *sock,
			uint32_t len, struct iovec *iov, int iov_len)
{
	ssize_t num;

	if (sock_is_buffering(sock)) {
		return buffer_write(sock, len, iov, iov_len);
	}

	num = writev(sock->fd, iov, iov_len);
	if (num == -1) {
		if (errno == EPIPE) {
			/* Assume EOF and shutdown */
			PPRINTF(("TX: writev fd=%d failed with EPIPE => SHUTDOWN_RX\n", sock->fd));
			shutdown_local_sock("TX", sock, VIRTIO_VSOCK_FLAG_SHUTDOWN_RX);
			send_response_sock(sc, VIRTIO_VSOCK_OP_SHUTDOWN,
					   sock->local_shutdown, sock);
			return 0;
		} else if (errno == EAGAIN) {
			num = 0;
		} else {
			PPRINTF(("TX: writev fd=%d failed with %d %s\n", sock->fd,
				 errno, strerror(errno)));
			return -1;
		}
	}

	DPRINTF(("TX: wrote %zd/%"PRId32" bytes\n", num, len));
	sock->fwd_cnt += num;
	if (num == len) {
		return 1;
	} else { /* Buffer the rest */
		size_t pulled = iovec_pull(&iov, &iov_len, NULL, (size_t)num);
		assert(pulled == (size_t)num);
		return buffer_write(sock, len - (uint32_t)num, iov, iov_len);
	}
}
