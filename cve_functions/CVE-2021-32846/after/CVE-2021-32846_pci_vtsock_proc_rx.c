static ssize_t pci_vtsock_proc_rx(struct pci_vtsock_softc *sc,
				  struct vqueue_info *vq,
				  struct pci_vtsock_sock *s)
{
	struct virtio_sock_hdr *hdr;
	struct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;
	uint16_t flags[VTSOCK_MAXSEGS];
	uint16_t idx;
	uint32_t peer_free;
	int iovec_len;
	size_t pushed;
	ssize_t len;

	assert(s->fd >= 0);

	if (!vq_has_descs(vq)) {
		DPRINTF(("RX: no queues!\n"));
		return -1;
	}

	iovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);
	DPRINTF(("RX: virtio-vsock: got %d elem rx chain\n", iovec_len));
	dprint_chain(iov, iovec_len, "RX");

	assert(iovec_len >= 1);
	/* XXX needed so we can update len after the read */
	assert(iov[0].iov_len >= sizeof(*hdr));

	hdr = iov[0].iov_base;
	hdr->src_cid = s->local_addr.cid;
	hdr->src_port = s->local_addr.port;
	hdr->dst_cid = s->peer_addr.cid;
	hdr->dst_port = s->peer_addr.port;
	hdr->len = 0; /* XXX */
	hdr->type = VIRTIO_VSOCK_TYPE_STREAM;
	hdr->op = VIRTIO_VSOCK_OP_RW;
	hdr->flags = 0;
	hdr->buf_alloc = s->buf_alloc;
	hdr->fwd_cnt = s->fwd_cnt;

	peer_free = s->peer_buf_alloc - (s->rx_cnt - s->peer_fwd_cnt);
	DPRINTF(("RX:\tpeer free = %"PRIx32"\n", peer_free));
	if (!peer_free) goto credit_update; /* No space */

	pushed = iovec_push(&iov, &iovec_len, hdr, sizeof(*hdr));
	assert(pushed == sizeof(*hdr));

	iovec_clip(&iov, &iovec_len, peer_free);

	len = readv(s->fd, iov, iovec_len);
	if (len == -1) {
		if (errno == EAGAIN) { /* Nothing to read/would block */
			DPRINTF(("RX: readv fd=%d EAGAIN\n", s->fd));
			goto credit_update;
		}
		PPRINTF(("RX: readv fd=%d failed with %d %s\n",
			 s->fd, errno, strerror(errno)));
		hdr->op = VIRTIO_VSOCK_OP_RST;
		hdr->flags = 0;
		hdr->len = 0;
		dprint_header(hdr, 0, "RX");
		s->credit_update_required = false;
		vq_relchain(vq, idx, sizeof(*hdr));
		close_sock(sc, s, "RX");
		return 0;
	}
	DPRINTF(("RX: readv put %zd bytes into iov\n", len));
	if (len == 0) { /* Not actually anything to read -- EOF */
		PPRINTF(("RX: readv fd=%d EOF => SHUTDOWN_TX\n", s->fd));
		shutdown_local_sock("RX", s, VIRTIO_VSOCK_FLAG_SHUTDOWN_TX);
		hdr->op = VIRTIO_VSOCK_OP_SHUTDOWN;
		hdr->flags = s->local_shutdown;
		hdr->len = 0;
		dprint_header(hdr, 0, "RX");
		s->credit_update_required = false;
		vq_relchain(vq, idx, sizeof(*hdr));
		return 0;
	}
	hdr->len = (uint32_t)len;

	s->rx_cnt += len;

	dprint_header(hdr, 0, "RX");
	s->credit_update_required = false;
	vq_relchain(vq, idx, sizeof(*hdr) + (uint32_t)len);

	return len;

credit_update:
	if (s->credit_update_required) {
		hdr->op = VIRTIO_VSOCK_OP_CREDIT_UPDATE;
		hdr->flags = 0;
		hdr->len = 0;
		dprint_header(hdr, 0, "RX");
		s->credit_update_required = false;
		vq_relchain(vq, idx, sizeof(*hdr));
	} else {
		vq_retchain(vq);
	}
	return 0;
}
