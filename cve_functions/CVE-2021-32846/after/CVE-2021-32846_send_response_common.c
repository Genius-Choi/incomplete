static void send_response_common(struct pci_vtsock_softc *sc,
				 struct vsock_addr local_addr,
				 struct vsock_addr peer_addr,
				 uint16_t op, uint16_t type, uint32_t flags,
				 uint32_t buf_alloc, uint32_t fwd_cnt)
{
	struct virtio_sock_hdr *hdr;
	int slot;

	assert(op != VIRTIO_VSOCK_OP_RW);
	assert(flags == 0 || op == VIRTIO_VSOCK_OP_SHUTDOWN);

	pthread_mutex_lock(&sc->reply_mtx);

	slot = sc->reply_prod++;
	if (sc->reply_prod == VTSOCK_REPLYRINGSZ)
		sc->reply_prod = 0;
	DPRINTF(("TX: QUEUING REPLY IN SLOT %x (prod %x, cons %x)\n",
		 slot, sc->reply_prod, sc->reply_cons));
	/*
	 * We have just incremented reply_prod above but we hold the
	 * lock so the consumer cannot have caught us up. Hence for
	 * the ring to appear empty it must actually have just overflowed.
	 */
	assert(!REPLY_RING_EMPTY(sc));

	hdr = &sc->reply_ring[slot];

	hdr->src_cid = local_addr.cid;
	hdr->src_port = local_addr.port;

	hdr->dst_cid = peer_addr.cid;
	hdr->dst_port = peer_addr.port;

	hdr->len = 0;
	hdr->type = type;
	hdr->op = op;
	hdr->flags = flags;

	hdr->buf_alloc = buf_alloc;
	hdr->fwd_cnt = fwd_cnt;

	dprint_header(hdr, 0, "TX");

	pthread_mutex_unlock(&sc->reply_mtx);

	sc->rx_kick_pending = true;
}
