static int dprc_init(void)
{
	int err, child_portal_id, container_id;
	struct dprc_cfg cfg;
	uint64_t mc_portal_offset;

	/* Open root container */
	err = dprc_get_container_id(root_mc_io, MC_CMD_NO_FLAGS, &container_id);
	if (err < 0) {
		printf("dprc_get_container_id(): Root failed: %d\n", err);
		goto err_root_container_id;
	}

#ifdef DEBUG
	printf("Root container id = %d\n", container_id);
#endif
	err = dprc_open(root_mc_io, MC_CMD_NO_FLAGS, container_id,
			&root_dprc_handle);
	if (err < 0) {
		printf("dprc_open(): Root Container failed: %d\n", err);
		goto err_root_open;
	}

	if (!root_dprc_handle) {
		printf("dprc_open(): Root Container Handle is not valid\n");
		goto err_root_open;
	}

	err = dprc_version_check(root_mc_io, root_dprc_handle);
	if (err < 0) {
		printf("dprc_version_check() failed: %d\n", err);
		goto err_root_open;
	}

	memset(&cfg, 0, sizeof(struct dprc_cfg));
	cfg.options = DPRC_CFG_OPT_TOPOLOGY_CHANGES_ALLOWED |
		      DPRC_CFG_OPT_OBJ_CREATE_ALLOWED |
		      DPRC_CFG_OPT_ALLOC_ALLOWED;
	cfg.icid = DPRC_GET_ICID_FROM_POOL;
	cfg.portal_id = DPRC_GET_PORTAL_ID_FROM_POOL;
	err = dprc_create_container(root_mc_io, MC_CMD_NO_FLAGS,
			root_dprc_handle,
			&cfg,
			&child_dprc_id,
			&mc_portal_offset);
	if (err < 0) {
		printf("dprc_create_container() failed: %d\n", err);
		goto err_create;
	}

	dflt_mc_io = (struct fsl_mc_io *)calloc(sizeof(struct fsl_mc_io), 1);
	if (!dflt_mc_io) {
		err  = -ENOMEM;
		printf(" No memory: calloc() failed\n");
		goto err_calloc;
	}

	child_portal_id = MC_PORTAL_OFFSET_TO_PORTAL_ID(mc_portal_offset);
	dflt_mc_io->mmio_regs = SOC_MC_PORTAL_ADDR(child_portal_id);

#ifdef DEBUG
	printf("MC portal of child DPRC container: %d, physical addr %p)\n",
	       child_dprc_id, dflt_mc_io->mmio_regs);
#endif

	err = dprc_open(dflt_mc_io, MC_CMD_NO_FLAGS, child_dprc_id,
			&dflt_dprc_handle);
	if (err < 0) {
		printf("dprc_open(): Child container failed: %d\n", err);
		goto err_child_open;
	}

	if (!dflt_dprc_handle) {
		printf("dprc_open(): Child container Handle is not valid\n");
		goto err_child_open;
	}

	return 0;
err_child_open:
	free(dflt_mc_io);
err_calloc:
	dprc_destroy_container(root_mc_io, MC_CMD_NO_FLAGS,
			       root_dprc_handle, child_dprc_id);
err_create:
	dprc_close(root_mc_io, MC_CMD_NO_FLAGS, root_dprc_handle);
err_root_open:
err_root_container_id:
	return err;
}
