static void get_rbf_image_info(struct rbf_info *rbf, u16 *buffer)
{
	/*
	 * Magic ID starting at:
	 * -> 1st dword[15:0] in periph.rbf
	 * -> 2nd dword[15:0] in core.rbf
	 * Note: dword == 32 bits
	 */
	u32 word_reading_max = 2;
	u32 i;

	for (i = 0; i < word_reading_max; i++) {
		if (*(buffer + i) == FPGA_SOCFPGA_A10_RBF_UNENCRYPTED) {
			rbf->security = unencrypted;
		} else if (*(buffer + i) == FPGA_SOCFPGA_A10_RBF_ENCRYPTED) {
			rbf->security = encrypted;
		} else if (*(buffer + i + 1) ==
				FPGA_SOCFPGA_A10_RBF_UNENCRYPTED) {
			rbf->security = unencrypted;
		} else if (*(buffer + i + 1) ==
				FPGA_SOCFPGA_A10_RBF_ENCRYPTED) {
			rbf->security = encrypted;
		} else {
			rbf->security = invalid;
			continue;
		}

		/* PERIPH RBF(buffer + i + 1), CORE RBF(buffer + i + 2) */
		if (*(buffer + i + 1) == FPGA_SOCFPGA_A10_RBF_PERIPH) {
			rbf->section = periph_section;
			break;
		} else if (*(buffer + i + 1) == FPGA_SOCFPGA_A10_RBF_CORE) {
			rbf->section = core_section;
			break;
		} else if (*(buffer + i + 2) == FPGA_SOCFPGA_A10_RBF_PERIPH) {
			rbf->section = periph_section;
			break;
		} else if (*(buffer + i + 2) == FPGA_SOCFPGA_A10_RBF_CORE) {
			rbf->section = core_section;
			break;
		}

		rbf->section = unknown;
		break;

		WATCHDOG_RESET();
	}
}
