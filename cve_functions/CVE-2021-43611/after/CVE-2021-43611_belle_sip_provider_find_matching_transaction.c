belle_sip_transaction_t * belle_sip_provider_find_matching_transaction(belle_sip_list_t *transactions, belle_sip_request_t *req){
	struct transaction_matcher matcher;
	belle_sip_header_via_t *via=(belle_sip_header_via_t*)belle_sip_message_get_header((belle_sip_message_t*)req,"via");
	belle_sip_transaction_t *ret=NULL;
	belle_sip_list_t *elem=NULL;
	const char *branch;
	char token[BELLE_SIP_BRANCH_ID_LENGTH] = {0};


	matcher.method=belle_sip_request_get_method(req);
	matcher.is_ack_or_cancel=(strcmp(matcher.method,"ACK")==0 || strcmp(matcher.method,"CANCEL")==0);

	if (via!=NULL && (branch=belle_sip_header_via_get_branch(via))!=NULL &&
		strncmp(branch,BELLE_SIP_BRANCH_MAGIC_COOKIE,strlen(BELLE_SIP_BRANCH_MAGIC_COOKIE))==0){
		matcher.branchid=branch;
	}else{
		/*this request comes from an old equipment, we need to compute our own branch for this request.*/
		matcher.branchid=compute_rfc2543_branch(req,token,sizeof(token));
		belle_sip_request_set_rfc2543_branch(req,token);
		belle_sip_message("Message from old RFC2543 stack, computed branch is %s", token);
	}

	elem=belle_sip_list_find_custom(transactions,transaction_match,&matcher);

	if (elem){
		ret=(belle_sip_transaction_t*)elem->data;
		belle_sip_message("Found transaction [%p] matching request.",ret);
	}
	return ret;
}
