ANTLR3_API pbelle_sip_messageLexer belle_sip_messageLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pbelle_sip_messageLexer ctx; // Context structure we will build and return

    ctx = (pbelle_sip_messageLexer) ANTLR3_CALLOC(1, sizeof(belle_sip_messageLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in belle_sip_messageLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our belle_sip_messageLexer interface
     */
    ctx->mCOMMON_CHAR	= mCOMMON_CHAR;
    ctx->mHEX_CHAR	= mHEX_CHAR;
    ctx->mDIGIT	= mDIGIT;
    ctx->mAT	= mAT;
    ctx->mAND	= mAND;
    ctx->mDOLLARD	= mDOLLARD;
    ctx->mQMARK	= mQMARK;
    ctx->mEMARK	= mEMARK;
    ctx->mDASH	= mDASH;
    ctx->mCRLF	= mCRLF;
    ctx->mHTAB	= mHTAB;
    ctx->mOR	= mOR;
    ctx->mPERCENT	= mPERCENT;
    ctx->mDQUOTE	= mDQUOTE;
    ctx->mSQUOTE	= mSQUOTE;
    ctx->mBQUOTE	= mBQUOTE;
    ctx->mBSLASH	= mBSLASH;
    ctx->mLBRACE	= mLBRACE;
    ctx->mRBRACE	= mRBRACE;
    ctx->mUSCORE	= mUSCORE;
    ctx->mTILDE	= mTILDE;
    ctx->mDOT	= mDOT;
    ctx->mPLUS	= mPLUS;
    ctx->mCOLON	= mCOLON;
    ctx->mSEMI	= mSEMI;
    ctx->mCOMMA	= mCOMMA;
    ctx->mLAQUOT	= mLAQUOT;
    ctx->mRAQUOT	= mRAQUOT;
    ctx->mRPAREN	= mRPAREN;
    ctx->mLPAREN	= mLPAREN;
    ctx->mRSBRAQUET	= mRSBRAQUET;
    ctx->mLSBRAQUET	= mLSBRAQUET;
    ctx->mEQUAL	= mEQUAL;
    ctx->mSLASH	= mSLASH;
    ctx->mSTAR	= mSTAR;
    ctx->mSP	= mSP;
    ctx->mOCTET	= mOCTET;
    ctx->mTokens	= mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= belle_sip_messageLexerFree;
    ctx->reset          = belle_sip_messageLexerReset;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}
