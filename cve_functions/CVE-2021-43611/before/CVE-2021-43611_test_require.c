static void test_require(const char* header_name, const char * header_value, const char* values[],size_t number_values){
	belle_sip_list_t* list;
	belle_sip_header_require_t* L_tmp;
	belle_sip_header_require_t* L_require = BELLE_SIP_HEADER_REQUIRE(belle_sip_header_create(header_name,header_value));
	char* l_raw_header = belle_sip_object_to_string(BELLE_SIP_OBJECT(L_require));
	size_t i=0;
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_require));
	L_tmp = belle_sip_header_require_parse(l_raw_header);
	L_require = BELLE_SIP_HEADER_REQUIRE(belle_sip_object_clone(BELLE_SIP_OBJECT(L_tmp)));
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_tmp));

	belle_sip_free(l_raw_header);

	list = belle_sip_header_require_get_require(L_require);

	for(i=0;i<number_values;i++){
		BC_ASSERT_PTR_NOT_NULL(list);
		if (list) {
			BC_ASSERT_STRING_EQUAL((const char *)(list->data),values[i]);
			list=list->next;
		}
	}
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_require));
	BC_ASSERT_PTR_NULL(belle_sip_header_require_parse("nimportequoi"));
}
