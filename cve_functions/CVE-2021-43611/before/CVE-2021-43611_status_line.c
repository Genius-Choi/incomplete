status_line(pbelle_sip_messageParser ctx)
{
    belle_sip_response_t* ret;


    belle_sip_messageParser_status_code_return status_code14;
    #undef	RETURN_TYPE_status_code14
    #define	RETURN_TYPE_status_code14 belle_sip_messageParser_status_code_return

    belle_sip_messageParser_reason_phrase_return reason_phrase15;
    #undef	RETURN_TYPE_reason_phrase15
    #define	RETURN_TYPE_reason_phrase15 belle_sip_messageParser_reason_phrase_return

    /* Initialize rule variables
     */
    ret = NULL;

    ctx->pbelle_sip_messageParser_status_lineTop = pbelle_sip_messageParser_status_linePush(ctx);
    ret= belle_sip_response_new();
     
    {
        // ../grammars/belle_sip_message.g:232:2: ( sip_version SP status_code SP reason_phrase CRLF )
        // ../grammars/belle_sip_message.g:232:6: sip_version SP status_code SP reason_phrase CRLF
        {
            FOLLOWPUSH(FOLLOW_sip_version_in_status_line630);
            sip_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }


             MATCHT(SP, &FOLLOW_SP_in_status_line636);
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }


            FOLLOWPUSH(FOLLOW_status_code_in_status_line638);
            status_code14=status_code(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }


            if ( BACKTRACKING==0 )
            {
                belle_sip_response_set_status_code(ret
                ,atoi((char*)(STRSTREAM->toStringTT(STRSTREAM, status_code14.start, status_code14.stop))
                ->chars));
            }


             MATCHT(SP, &FOLLOW_SP_in_status_line646);
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }


            FOLLOWPUSH(FOLLOW_reason_phrase_in_status_line648);
            reason_phrase15=reason_phrase(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }


            if ( BACKTRACKING==0 )
            {
                belle_sip_response_set_reason_phrase(ret
                ,(char*)(STRSTREAM->toStringTT(STRSTREAM, reason_phrase15.start, reason_phrase15.stop))
                ->chars);
            }


             MATCHT(CRLF, &FOLLOW_CRLF_in_status_line656);
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestatus_lineEx; /* Prevent compiler warnings */
    rulestatus_lineEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref( ret
	    );
	       ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sip_messageParser_status_linePop(ctx);

    return ret;
}
