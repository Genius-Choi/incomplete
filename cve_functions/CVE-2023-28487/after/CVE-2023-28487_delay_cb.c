delay_cb(int fd, int what, void *v)
{
    struct replay_closure *closure = v;
    struct timing_closure *timing = &closure->timing;
    debug_decl(delay_cb, SUDO_DEBUG_UTIL);

    switch (timing->event) {
    case IO_EVENT_WINSIZE:
	resize_terminal(timing->u.winsize.lines, timing->u.winsize.cols);
	break;
    case IO_EVENT_STDIN:
	if (iolog_files[IOFD_STDIN].enabled)
	    timing->iol = &iolog_files[IOFD_STDIN];
	break;
    case IO_EVENT_STDOUT:
	if (iolog_files[IOFD_STDOUT].enabled)
	    timing->iol = &iolog_files[IOFD_STDOUT];
	break;
    case IO_EVENT_STDERR:
	if (iolog_files[IOFD_STDERR].enabled)
	    timing->iol = &iolog_files[IOFD_STDERR];
	break;
    case IO_EVENT_TTYIN:
	if (iolog_files[IOFD_TTYIN].enabled)
	    timing->iol = &iolog_files[IOFD_TTYIN];
	break;
    case IO_EVENT_TTYOUT:
	if (iolog_files[IOFD_TTYOUT].enabled)
	    timing->iol = &iolog_files[IOFD_TTYOUT];
	break;
    }

    if (timing->iol != NULL) {
	/* If the stream is open, enable the write event. */
	if (sudo_ev_add(closure->evbase, closure->output_ev, NULL, false) == -1)
	    sudo_fatal("%s", U_("unable to add event to queue"));
    } else {
	/* Not replaying, get the next timing record and continue. */
	next_timing_record(closure);
    }

    debug_return;
}
