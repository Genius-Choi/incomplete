do_logfile_sudo(const char *logline, const struct eventlog *evlog,
    const struct timespec *event_time)
{
    const struct eventlog_config *evl_conf = eventlog_getconf();
    char *full_line, timebuf[8192], *timestr = NULL;
    const char *timefmt = evl_conf->time_fmt;
    const char *logfile = evl_conf->logpath;
    struct tm tm;
    bool ret = false;
    FILE *fp;
    int len;
    debug_decl(do_logfile_sudo, SUDO_DEBUG_UTIL);

    if ((fp = evl_conf->open_log(EVLOG_FILE, logfile)) == NULL)
	debug_return_bool(false);

    if (!sudo_lock_file(fileno(fp), SUDO_LOCK)) {
	sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,
	    "unable to lock log file %s", logfile);
	goto done;
    }

    if (event_time != NULL) {
	time_t tv_sec = event_time->tv_sec;
	if (localtime_r(&tv_sec, &tm) != NULL) {
	    /* strftime() does not guarantee to NUL-terminate so we must check. */
	    timebuf[sizeof(timebuf) - 1] = '\0';
	    if (strftime(timebuf, sizeof(timebuf), timefmt, &tm) != 0 &&
		    timebuf[sizeof(timebuf) - 1] == '\0') {
		timestr = timebuf;
	    }
	}
    }
    if (evlog != NULL) {
	len = asprintf(&full_line, "%s : %s : %s",
	    timestr ? timestr : "invalid date", evlog->submituser, logline);
    } else {
	len = asprintf(&full_line, "%s : %s",
	    timestr ? timestr : "invalid date", logline);
    }
    if (len == -1) {
	sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
	goto done;
    }
    eventlog_writeln(fp, full_line, len, evl_conf->file_maxlen);
    free(full_line);
    (void)fflush(fp);
    if (ferror(fp)) {
	sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,
	    "unable to write log file %s", logfile);
	goto done;
    }
    ret = true;

done:
    (void)sudo_lock_file(fileno(fp), SUDO_UNLOCK);
    evl_conf->close_log(EVLOG_FILE, fp);
    debug_return_bool(ret);
}
