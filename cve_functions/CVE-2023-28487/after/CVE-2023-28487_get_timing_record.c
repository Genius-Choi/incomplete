get_timing_record(struct replay_closure *closure)
{
    struct timing_closure *timing = &closure->timing;
    bool nodelay = false;
    debug_decl(get_timing_record, SUDO_DEBUG_UTIL);

    if (follow_mode && timing->event == IO_EVENT_COUNT) {
	/* In follow mode, we already waited. */
	nodelay = true;
    }

    switch (iolog_read_timing_record(&iolog_files[IOFD_TIMING], timing)) {
    case -1:
	/* error */
	debug_return_int(-1);
    case 1:
	/* EOF */
	if (!follow_mode || iolog_complete(closure)) {
	    debug_return_int(1);
	}
	/* Follow mode, keep reading until done. */
	iolog_clearerr(&iolog_files[IOFD_TIMING]);
	timing->delay.tv_sec = 0;
	timing->delay.tv_nsec = 1000000;
	timing->iol = NULL;
	timing->event = IO_EVENT_COUNT;
	break;
    default:
	/* Record number bytes to read. */
	if (timing->event != IO_EVENT_WINSIZE &&
		timing->event != IO_EVENT_SUSPEND) {
	    closure->iobuf.len = 0;
	    closure->iobuf.off = 0;
	    closure->iobuf.lastc = '\0';
	    closure->iobuf.toread = timing->u.nbytes;
	}

	if (sudo_timespecisset(closure->offset)) {
	    if (sudo_timespeccmp(&timing->delay, closure->offset, >)) {
		sudo_timespecsub(&timing->delay, closure->offset, &timing->delay);
		sudo_timespecclear(closure->offset);
	    } else {
		sudo_timespecsub(closure->offset, &timing->delay, closure->offset);
		sudo_timespecclear(&timing->delay);
	    }
	}

	if (nodelay) {
	    /* Already waited, fire immediately. */
	    timing->delay.tv_sec = 0;
	    timing->delay.tv_nsec = 0;
	} else {
	    /* Adjust delay using speed factor and max_delay. */
	    iolog_adjust_delay(&timing->delay, closure->max_delay,
		speed_factor);
	}
	break;
    }

    /* Schedule the delay event. */
    if (sudo_ev_add(closure->evbase, closure->delay_ev, &timing->delay, false) == -1)
	sudo_fatal("%s", U_("unable to add event to queue"));

    debug_return_int(0);
}
