gnrc_sixlowpan_frag_vrb_t *gnrc_sixlowpan_frag_vrb_from_route(
            const gnrc_sixlowpan_frag_rb_base_t *base,
            gnrc_netif_t *netif, const gnrc_pktsnip_t *hdr)
{
    gnrc_sixlowpan_frag_vrb_t *res = NULL;

    assert(base != NULL);
    assert((hdr != NULL) && (hdr->data != NULL) && (hdr->size > 0));
    switch (hdr->type) {
#ifdef MODULE_GNRC_IPV6_NIB
        case GNRC_NETTYPE_IPV6: {
            assert(hdr->size >= sizeof(ipv6_hdr_t));
            const ipv6_addr_t *addr = &((const ipv6_hdr_t *)hdr->data)->dst;
            gnrc_ipv6_nib_nc_t nce;

            if (!ipv6_addr_is_link_local(addr) &&
                (gnrc_netif_get_by_ipv6_addr(addr) == NULL) &&
                (gnrc_ipv6_nib_get_next_hop_l2addr(addr, netif, NULL,
                                                   &nce) == 0)) {

                DEBUG("6lo vrb: FIB entry for IPv6 destination %s found\n",
                      ipv6_addr_to_str(addr_str, addr, sizeof(addr_str)));
                res = gnrc_sixlowpan_frag_vrb_add(
                        base,
                        gnrc_netif_get_by_pid(gnrc_ipv6_nib_nc_get_iface(&nce)),
                        nce.l2addr, nce.l2addr_len
                    );
            }
            else {
                DEBUG("6lo vrb: no FIB entry for IPv6 destination %s found\n",
                      ipv6_addr_to_str(addr_str, addr, sizeof(addr_str)));
            }
            break;
        }
#endif  /* MODULE_GNRC_IPV6_NIB */
        default:
            (void)base;
            (void)netif;
            DEBUG("6lo vrb: unknown forwarding header type %d\n", hdr->type);
            break;
    }
    return res;
}
