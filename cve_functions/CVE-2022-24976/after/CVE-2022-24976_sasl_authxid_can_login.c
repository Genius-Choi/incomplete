sasl_authxid_can_login(struct sasl_session *const restrict p, const char *const restrict authxid,
                       struct myuser **const restrict muo, char *const restrict val_name,
                       char *const restrict val_eid, const char *const restrict other_val_eid)
{
	return_val_if_fail(p != NULL, false);
	return_val_if_fail(p->si != NULL, false);
	return_val_if_fail(p->mechptr != NULL, false);

	struct myuser *const mu = myuser_find_by_nick(authxid);

	if (! mu)
	{
		(void) slog(LG_DEBUG, "%s: myuser_find_by_nick: does not exist", MOWGLI_FUNC_NAME);
		return false;
	}
	if (metadata_find(mu, "private:freeze:freezer"))
	{
		(void) logcommand(p->si, CMDLOG_LOGIN, "failed LOGIN to \2%s\2 (frozen)", entity(mu)->name);
		return false;
	}

	if (muo)
		*muo = mu;

	(void) mowgli_strlcpy(val_name, entity(mu)->name, NICKLEN + 1);
	(void) mowgli_strlcpy(val_eid, entity(mu)->id, IDLEN + 1);

	if (p->mechptr->password_based && (mu->flags & MU_NOPASSWORD))
	{
		(void) logcommand(p->si, CMDLOG_LOGIN, "failed LOGIN %s to \2%s\2 (password authentication disabled)",
		                  p->mechptr->name, entity(mu)->name);

		return false;
	}

	if (strcmp(val_eid, other_val_eid) == 0)
		// We have already executed the user_can_login hook for this user
		return true;

	struct hook_user_login_check req = {

		.si         = p->si,
		.mu         = mu,
		.allowed    = true,
	};

	(void) hook_call_user_can_login(&req);

	if (! req.allowed)
		(void) logcommand(p->si, CMDLOG_LOGIN, "failed LOGIN to \2%s\2 (denied by hook)", entity(mu)->name);

	return req.allowed;
}
