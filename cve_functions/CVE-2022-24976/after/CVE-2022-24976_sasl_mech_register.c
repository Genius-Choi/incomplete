sasl_mech_register(const struct sasl_mechanism *const restrict mech)
{
	if (sasl_mechanism_find(mech->name))
	{
		(void) slog(LG_DEBUG, "%s: ignoring attempt to register %s again", MOWGLI_FUNC_NAME, mech->name);
		return;
	}

	(void) slog(LG_DEBUG, "%s: registering %s", MOWGLI_FUNC_NAME, mech->name);

	mowgli_node_t *const node = mowgli_node_create();

	if (! node)
	{
		(void) slog(LG_ERROR, "%s: mowgli_node_create() failed; out of memory?", MOWGLI_FUNC_NAME);
		return;
	}

	/* Here we cast it to (void *) because mowgli_node_add() expects that; it cannot be made const because then
	 * it would have to return a (const void *) too which would cause multiple warnings any time it is actually
	 * storing, and thus gets assigned to, a pointer to a mutable object.
	 *
	 * To avoid the cast generating a diagnostic due to dropping a const qualifier, we first cast to uintptr_t.
	 * This is not unprecedented in this codebase; libathemecore/crypto.c & libathemecore/strshare.c do the
	 * same thing.
	 */
	(void) mowgli_node_add((void *)((uintptr_t) mech), node, &sasl_mechanisms);

	(void) sasl_mechlist_do_rebuild();
}
