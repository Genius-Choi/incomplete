bool LibzipPlugin::writeEntry(zip_t *archive, const QString &entry, const CompressOptions &options, bool isDir, const QString &strRoot)
{
    Q_ASSERT(archive);
    QFileInfo info(entry);
    QString str;
    if (!options.strDestination.isEmpty()) {
        str = QString(options.strDestination + entry.mid(strRoot.length()));
    } else {
        //移除前缀路径
        str = entry.mid(strRoot.length());
    }
    zip_int64_t index;
    if (isDir && !info.isSymLink()) {
        index = zip_dir_add(archive, str.toUtf8().constData(), ZIP_FL_ENC_GUESS);
        if (-1 == index) {
            // If directory already exists in archive, we get an error.
            return false;
        }
    } else if(info.isSymLink()) { // symlink
        QByteArray strLinkArr = info.symLinkTarget().toUtf8();
        struct zip_source *source = zip_source_buffer(archive , strLinkArr, strLinkArr.length(), 0);
        if (source)
        {
            index = zip_add(archive, str.toUtf8().constData(), source);
        }
        else
        {
            zip_source_free(source);
            emit error(("Failed to add entry: %1"));
            return false;
        }
        zip_source_commit_write(source);
        zip_source_close(source);
     } else {
        // 获取源文件
        zip_source_t *src = zip_source_file(archive, QFile::encodeName(entry).constData(), 0, -1);
        if (!src) {
            emit error(("Failed to add entry: %1"));
            return false;
        }

        // 向压缩包中添加文件
        index = zip_file_add(archive, str.toUtf8().constData(), src, ZIP_FL_ENC_GUESS | ZIP_FL_OVERWRITE);
        if (-1 == index) {
            zip_source_free(src);
            emit error(("Failed to add entry: %1"));
            return false;
        }
        zip_source_commit_write(src);
        zip_source_close(src);
    }
    zip_uint64_t uindex = static_cast<zip_uint64_t>(index);
#ifndef Q_OS_WIN
    // 设置文件权限
    QT_STATBUF result;
    if (QT_LSTAT(QFile::encodeName(entry).constData(), &result) != 0) {
    } else {
        zip_uint32_t attributes = result.st_mode << 16;
        if (zip_file_set_external_attributes(archive, uindex, 0, ZIP_OPSYS_UNIX, attributes) != 0) {
        }
    }
#endif

    // 设置压缩的加密算法
    if (options.bEncryption && !options.strEncryptionMethod.isEmpty()) { //ReadOnlyArchiveInterface::password()
        int ret = 0;
        if (QLatin1String("AES128") == options.strEncryptionMethod) {
            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_128, options.strPassword.toUtf8().constData());
        } else if (QLatin1String("AES192") == options.strEncryptionMethod) {
            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_192, options.strPassword.toUtf8().constData());
        } else if (QLatin1String("AES256") == options.strEncryptionMethod) {
            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_256, options.strPassword.toUtf8().constData());
        }
        if (ret != 0) {
            emit error(("Failed to set compression options for entry: %1"));
            return false;
        }
    }

    // 设置压缩算法
    zip_int32_t compMethod = ZIP_CM_DEFAULT;
    if (!options.strCompressionMethod.isEmpty()) {
        if (QLatin1String("Deflate") == options.strCompressionMethod) {
            compMethod = ZIP_CM_DEFLATE;
        } else if (QLatin1String("BZip2") == options.strCompressionMethod) {
            compMethod = ZIP_CM_BZIP2;
        } else if (QLatin1String("Store") == options.strCompressionMethod) {
            compMethod = ZIP_CM_STORE;
        }
    }

    // 设置压缩等级
    const int compLevel = (options.iCompressionLevel != -1) ? options.iCompressionLevel : 6;
    if (zip_set_file_compression(archive, uindex, compMethod, zip_uint32_t(compLevel)) != 0) {
        emit error(("Failed to set compression options for entry: %1"));
        return false;
    }
    return true;
}
