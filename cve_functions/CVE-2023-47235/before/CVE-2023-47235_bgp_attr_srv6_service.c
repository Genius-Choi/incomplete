bgp_attr_srv6_service(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	struct in6_addr ipv6_sid;
	uint8_t type, sid_flags;
	uint16_t length, endpoint_behavior;
	size_t headersz = sizeof(type) + sizeof(length);
	enum bgp_attr_parse_ret err;

	if (STREAM_READABLE(peer->curr) < headersz) {
		flog_err(
			EC_BGP_ATTR_LEN,
			"Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %zu for attribute header, have %zu remaining in UPDATE)",
			headersz, STREAM_READABLE(peer->curr));
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	type = stream_getc(peer->curr);
	length = stream_getw(peer->curr);

	if (STREAM_READABLE(peer->curr) < length) {
		flog_err(
			EC_BGP_ATTR_LEN,
			"Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %hu for attribute data, have %zu remaining in UPDATE)",
			length, STREAM_READABLE(peer->curr));
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO) {
		if (STREAM_READABLE(peer->curr) <
		    BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH) {
			flog_err(
				EC_BGP_ATTR_LEN,
				"Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %d for attribute data, have %zu remaining in UPDATE)",
				BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH,
				STREAM_READABLE(peer->curr));
			return bgp_attr_malformed(
				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
				args->total);
		}
		stream_getc(peer->curr);
		stream_get(&ipv6_sid, peer->curr, sizeof(ipv6_sid));
		sid_flags = stream_getc(peer->curr);
		endpoint_behavior = stream_getw(peer->curr);
		stream_getc(peer->curr);

		/* Log SRv6 Service Sub-TLV */
		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL))
			zlog_debug(
				"%s: srv6-l3-srv sid %pI6, sid-flags 0x%02x, end-behaviour 0x%04x",
				__func__, &ipv6_sid, sid_flags,
				endpoint_behavior);

		/* Configure from Info */
		if (attr->srv6_l3vpn) {
			flog_err(EC_BGP_ATTRIBUTE_REPEATED,
				 "Prefix SID SRv6 L3VPN field repeated");
			return bgp_attr_malformed(
				args, BGP_NOTIFY_UPDATE_MAL_ATTR, args->total);
		}
		attr->srv6_l3vpn = XCALLOC(MTYPE_BGP_SRV6_L3VPN,
					   sizeof(struct bgp_attr_srv6_l3vpn));
		sid_copy(&attr->srv6_l3vpn->sid, &ipv6_sid);
		attr->srv6_l3vpn->sid_flags = sid_flags;
		attr->srv6_l3vpn->endpoint_behavior = endpoint_behavior;
		attr->srv6_l3vpn->loc_block_len = 0;
		attr->srv6_l3vpn->loc_node_len = 0;
		attr->srv6_l3vpn->func_len = 0;
		attr->srv6_l3vpn->arg_len = 0;
		attr->srv6_l3vpn->transposition_len = 0;
		attr->srv6_l3vpn->transposition_offset = 0;

		// Sub-Sub-TLV found
		if (length > BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH) {
			err = bgp_attr_srv6_service_data(args);

			if (err != BGP_ATTR_PARSE_PROCEED)
				return err;
		}

		attr->srv6_l3vpn = srv6_l3vpn_intern(attr->srv6_l3vpn);
	}

	/* Placeholder code for unsupported type */
	else {
		if (bgp_debug_update(peer, NULL, NULL, 1))
			zlog_debug(
				"%s attr SRv6 Service Sub-TLV sub-type=%u is not supported, skipped",
				peer->host, type);

		stream_forward_getp(peer->curr, length);
	}

	return BGP_ATTR_PARSE_PROCEED;
}
