unsigned int attrhash_key_make(const void *p)
{
	const struct attr *attr = (struct attr *)p;
	uint32_t key = 0;
#define MIX(val)	key = jhash_1word(val, key)
#define MIX3(a, b, c)	key = jhash_3words((a), (b), (c), key)

	MIX3(attr->origin, attr->nexthop.s_addr, attr->med);
	MIX3(attr->local_pref, attr->aggregator_as,
	     attr->aggregator_addr.s_addr);
	MIX3(attr->weight, attr->mp_nexthop_global_in.s_addr,
	     attr->originator_id.s_addr);
	MIX3(attr->tag, attr->label, attr->label_index);

	if (attr->aspath)
		MIX(aspath_key_make(attr->aspath));
	if (bgp_attr_get_community(attr))
		MIX(community_hash_make(bgp_attr_get_community(attr)));
	if (bgp_attr_get_lcommunity(attr))
		MIX(lcommunity_hash_make(bgp_attr_get_lcommunity(attr)));
	if (bgp_attr_get_ecommunity(attr))
		MIX(ecommunity_hash_make(bgp_attr_get_ecommunity(attr)));
	if (bgp_attr_get_ipv6_ecommunity(attr))
		MIX(ecommunity_hash_make(bgp_attr_get_ipv6_ecommunity(attr)));
	if (bgp_attr_get_cluster(attr))
		MIX(cluster_hash_key_make(bgp_attr_get_cluster(attr)));
	if (bgp_attr_get_transit(attr))
		MIX(transit_hash_key_make(bgp_attr_get_transit(attr)));
	if (attr->encap_subtlvs)
		MIX(encap_hash_key_make(attr->encap_subtlvs));
	if (attr->srv6_l3vpn)
		MIX(srv6_l3vpn_hash_key_make(attr->srv6_l3vpn));
	if (attr->srv6_vpn)
		MIX(srv6_vpn_hash_key_make(attr->srv6_vpn));
#ifdef ENABLE_BGP_VNC
	struct bgp_attr_encap_subtlv *vnc_subtlvs =
		bgp_attr_get_vnc_subtlvs(attr);
	if (vnc_subtlvs)
		MIX(encap_hash_key_make(vnc_subtlvs));
#endif
	MIX(attr->mp_nexthop_len);
	key = jhash(attr->mp_nexthop_global.s6_addr, IPV6_MAX_BYTELEN, key);
	key = jhash(attr->mp_nexthop_local.s6_addr, IPV6_MAX_BYTELEN, key);
	MIX3(attr->nh_ifindex, attr->nh_lla_ifindex, attr->distance);
	MIX(attr->rmap_table_id);
	MIX(attr->nh_type);
	MIX(attr->bh_type);
	MIX(attr->otc);
	MIX(bgp_attr_get_aigp_metric(attr));

	return key;
}
