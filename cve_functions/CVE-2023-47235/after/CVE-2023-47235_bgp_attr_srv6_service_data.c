bgp_attr_srv6_service_data(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	uint8_t type, loc_block_len, loc_node_len, func_len, arg_len,
		transposition_len, transposition_offset;
	uint16_t length;
	size_t headersz = sizeof(type) + sizeof(length);

	if (STREAM_READABLE(peer->curr) < headersz) {
		flog_err(
			EC_BGP_ATTR_LEN,
			"Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficent data (need %zu for attribute header, have %zu remaining in UPDATE)",
			headersz, STREAM_READABLE(peer->curr));
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	type = stream_getc(peer->curr);
	length = stream_getw(peer->curr);

	if (STREAM_READABLE(peer->curr) < length) {
		flog_err(
			EC_BGP_ATTR_LEN,
			"Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficent data (need %hu for attribute data, have %zu remaining in UPDATE)",
			length, STREAM_READABLE(peer->curr));
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	if (length < BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH) {
		flog_err(
			EC_BGP_ATTR_LEN,
			"Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficient data (need %u, have %hu remaining in UPDATE)",
			BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH,
			length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE) {
		if (STREAM_READABLE(peer->curr) <
		    BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH) {
			flog_err(
				EC_BGP_ATTR_LEN,
				"Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficient data (need %u, have %zu remaining in UPDATE)",
				BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH,
				STREAM_READABLE(peer->curr));
			return bgp_attr_malformed(
				args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
				args->total);
		}

		loc_block_len = stream_getc(peer->curr);
		loc_node_len = stream_getc(peer->curr);
		func_len = stream_getc(peer->curr);
		arg_len = stream_getc(peer->curr);
		transposition_len = stream_getc(peer->curr);
		transposition_offset = stream_getc(peer->curr);

		/* Log SRv6 Service Data Sub-Sub-TLV */
		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL)) {
			zlog_debug(
				"%s: srv6-l3-srv-data loc-block-len=%u, loc-node-len=%u func-len=%u, arg-len=%u, transposition-len=%u, transposition-offset=%u",
				__func__, loc_block_len, loc_node_len, func_len,
				arg_len, transposition_len,
				transposition_offset);
		}

		attr->srv6_l3vpn->loc_block_len = loc_block_len;
		attr->srv6_l3vpn->loc_node_len = loc_node_len;
		attr->srv6_l3vpn->func_len = func_len;
		attr->srv6_l3vpn->arg_len = arg_len;
		attr->srv6_l3vpn->transposition_len = transposition_len;
		attr->srv6_l3vpn->transposition_offset = transposition_offset;
	}

	else {
		if (bgp_debug_update(peer, NULL, NULL, 1))
			zlog_debug(
				"%s attr SRv6 Service Data Sub-Sub-TLV sub-sub-type=%u is not supported, skipped",
				peer->host, type);

		stream_forward_getp(peer->curr, length);
	}

	return BGP_ATTR_PARSE_PROCEED;
}
