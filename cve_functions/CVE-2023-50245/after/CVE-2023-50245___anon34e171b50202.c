    QFuture<void> imageConverting = QtConcurrent::run([=]() {
        for (int y = 0; y < m_image.height(); y++) {
            unsigned char* line = m_image.scanLine(y);

            #pragma omp parallel for
            for (int x = 0; x < m_image.width(); x++) {
                const float r = ColorTransform::to_sRGB(
                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 0]);
                const float g = ColorTransform::to_sRGB(
                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 1]);
                const float b = ColorTransform::to_sRGB(
                  m_exposure_mul * m_pixelBuffer[4 * (y * m_width + x) + 2]);

                const float a = m_pixelBuffer[4 * (y * m_width + x) + 3];

                line[4 * x + 0] = qMax(0, qMin(255, int(255.f * r)));
                line[4 * x + 1] = qMax(0, qMin(255, int(255.f * g)));
                line[4 * x + 2] = qMax(0, qMin(255, int(255.f * b)));
                line[4 * x + 3] = qMax(0, qMin(255, int(255.f * a)));
            }

            if (m_imageEditingWatcher->isCanceled()) {
                break;
            }
        }

        // We do not notify any canceled process: this would result in
        // potentially corrupted conversion
        if (!m_imageEditingWatcher->isCanceled()) {
            emit imageChanged();
        }
    });
