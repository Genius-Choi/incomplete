    QFuture<void> imageConverting = QtConcurrent::run([=]() {
        for (int y = 0; y < m_image.height(); y++) {
            unsigned char* line = m_image.scanLine(y);

            #pragma omp parallel for
            for (int x = 0; x < m_image.width(); x++) {
                float value = m_pixelBuffer[y * m_width + x];
                float RGB[3];

                m_cmap->getRGBValue(value, m_min, m_max, RGB);

                for (int c = 0; c < 3; c++) {
                    line[3 * x + c] = qMax(0, qMin(255, int(255 * RGB[c])));
                }
            }

            if (m_imageEditingWatcher->isCanceled()) {
                break;
            }
        }

        // We do not notify any canceled process: this would result in
        // potentially corrupted conversion
        if (!m_imageEditingWatcher->isCanceled()) {
            emit imageChanged();
        }
    });
