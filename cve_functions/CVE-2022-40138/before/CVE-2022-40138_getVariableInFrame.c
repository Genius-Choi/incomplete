HermesValue Debugger::getVariableInFrame(
    uint32_t frame,
    uint32_t scopeDepth,
    uint32_t variableIndex,
    std::string *outName) const {
  GCScope gcScope{runtime_};
  auto frameInfo = runtime_.stackFrameInfoByIndex(frame);
  assert(frameInfo && "Invalid frame");

  const HermesValue undefined = HermesValue::encodeUndefinedValue();

  // Clear the outgoing info so we don't leave stale data there.
  if (outName)
    outName->clear();

  if (frameInfo->isGlobal) {
    // Globals not yet supported.
    // TODO: support them.
    return undefined;
  }
  const CodeBlock *cb = frameInfo->frame->getCalleeCodeBlock(runtime_);
  assert(cb && "Unexpectedly null code block");
  auto scopeChain = scopeChainForBlock(runtime_, cb);
  if (!scopeChain) {
    // Binary was compiled without variable debug info.
    return undefined;
  }

  const ScopeChainItem &item = scopeChain->functions.at(scopeDepth);
  if (outName)
    *outName = item.variables.at(variableIndex);

  // Descend the environment chain to the desired depth, or stop at null.
  // We may get a null environment if it has not been created.
  MutableHandle<Environment> env(
      runtime_, frameInfo->frame->getDebugEnvironment());
  for (uint32_t i = 0; env && i < scopeDepth; i++)
    env = env->getParentEnvironment(runtime_);

  // Now we can get the variable, or undefined if we have no environment.
  return env ? env->slot(variableIndex) : undefined;
}
