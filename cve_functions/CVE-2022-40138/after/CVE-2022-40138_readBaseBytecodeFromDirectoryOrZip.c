bool readBaseBytecodeFromDirectoryOrZip(
    BaseBytecodeMap &map,
    llvh::StringRef inputPath,
    ::hermes::parser::JSLexer::Allocator &alloc,
    struct zip_t *zip) {
  auto manifestBuf = getFileFromDirectoryOrZip(zip, inputPath, "manifest.json");
  if (!manifestBuf) {
    llvh::errs()
        << "Failed to read manifest: Input must contain a manifest.json file\n";
    return false;
  }

  auto *manifestVal = parseJSONFile(manifestBuf, alloc);
  if (!manifestVal) {
    // parseJSONFile prints any error messages.
    return false;
  }

  // Pull data from the manifest JSON object into C++ data structures.
  // The manifest format is documented at doc/Modules.md.

  auto *manifest = dyn_cast<parser::JSONArray>(manifestVal);
  if (!manifest) {
    llvh::errs() << "Manifest must be a JSON array.\n";
    return false;
  }

  for (auto it : *manifest) {
    auto *segment = llvh::dyn_cast_or_null<parser::JSONObject>(it);
    if (!segment) {
      llvh::errs() << "Each segment entry must be a JSON object.\n";
      return false;
    }
    llvh::StringRef prefix{"hbc-seg-"};
    auto *flavor =
        llvh::dyn_cast_or_null<parser::JSONString>(segment->get("flavor"));
    if (!flavor || flavor->str().size() <= prefix.size() ||
        !flavor->str().startswith(prefix)) {
      llvh::errs() << "flavor must be a string that prefix a number with "
                   << prefix << ".\n";
      return false;
    }
    uint32_t segmentID;
    if (flavor->str().substr(prefix.size()).getAsInteger(10, segmentID)) {
      // getAsInteger returns true to signal error.
      llvh::errs() << "flavor must be a string that prefix a number with "
                   << prefix << ". Found " << flavor->str() << '\n';
      return false;
    }

    auto *location =
        llvh::dyn_cast_or_null<parser::JSONString>(segment->get("location"));
    if (!location) {
      llvh::errs() << "Segment bytecode location must be a string.\n";
      return false;
    }

    auto fileBuf = getFileFromDirectoryOrZip(zip, inputPath, location->str());
    if (!fileBuf) {
      llvh::errs() << "Base bytecode does not exist: " << location->str()
                   << ".\n";
      return false;
    }

    auto bcProvider = loadBaseBytecodeProvider(std::move(fileBuf));
    if (!bcProvider) {
      return false;
    }

    map[segmentID] = std::move(bcProvider);
  }

  return true;
}
