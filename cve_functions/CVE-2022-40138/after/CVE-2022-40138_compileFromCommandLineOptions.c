CompileResult compileFromCommandLineOptions() {
#if !defined(NDEBUG) || defined(LLVM_ENABLE_STATS)
  if (cl::PrintStats)
    hermes::EnableStatistics();
#endif

  // Set up and validate flags.
  setFlagDefaults();
  if (!validateFlags())
    return InvalidFlags;

  // Load input files.
  SegmentTable fileBufs{};

  // Allocator for the metadata table.
  ::hermes::parser::JSLexer::Allocator metadataAlloc;

  // Resolution table in metadata, null if none could be read.
  std::unique_ptr<Context::ResolutionTable> resolutionTable = nullptr;

  // Segment IDs in metadata.
  std::vector<uint32_t> segments;

  // Attempt to open the first file as a Zip file.
  struct zip_t *zip = zip_open(cl::InputFilenames[0].data(), 0, 'r');

  if (llvh::sys::fs::is_directory(cl::InputFilenames[0]) || zip) {
    ::hermes::parser::JSONObject *metadata =
        readInputFilenamesFromDirectoryOrZip(
            cl::InputFilenames[0], fileBufs, segments, metadataAlloc, zip);

    if (zip) {
      zip_close(zip);
    }
    if (!metadata) {
      return InputFileError;
    }

    resolutionTable = readResolutionTable(metadata);
  } else {
    // If we aren't reading from a dir or a zip, we have only one segment.
    segments.push_back(0);

    uint32_t nextModuleID = 0;
    ModuleIDsTable moduleIDs;
    SegmentTableEntry entry{};
    for (const std::string &filename : cl::InputFilenames) {
      auto fileBuf = memoryBufferFromFile(filename, true);
      if (!fileBuf)
        return InputFileError;
      auto emplaceRes = moduleIDs.try_emplace(filename, nextModuleID);
      auto moduleID = emplaceRes.first->second;
      if (emplaceRes.second) {
        ++nextModuleID;
      }
      entry.push_back({moduleID, std::move(fileBuf), nullptr});
    }

    // Read input source map if available.
    if (!cl::InputSourceMap.empty()) {
      // TODO: support multiple JS sources from command line.
      if (cl::InputFilenames.size() != 1) {
        llvh::errs()
            << "Error: only support single js file for input source map."
            << '\n';
        return InvalidFlags;
      }
      assert(entry.size() == 1 && "Can't have more than one entries.");
      entry[0].sourceMap =
          memoryBufferFromFile(cl::InputSourceMap, /*stdinOk*/ false);
    }

    fileBufs.emplace(0, std::move(entry));
  }

  if (cl::BytecodeMode) {
    assert(
        fileBufs.size() == 1 && fileBufs[0].size() == 1 &&
        "validateFlags() should enforce exactly one bytecode input file");
    return processBytecodeFile(std::move(fileBufs[0][0].file));
  } else {
    std::shared_ptr<Context> context =
        createContext(std::move(resolutionTable), std::move(segments));
    return processSourceFiles(context, std::move(fileBufs));
  }
}
