CallResult<PseudoHandle<>> Interpreter::createObjectFromBuffer(
    Runtime &runtime,
    CodeBlock *curCodeBlock,
    unsigned numLiterals,
    unsigned keyBufferIndex,
    unsigned valBufferIndex) {
  // Create a new object using the built-in constructor or cached hidden class.
  // Note that the built-in constructor is empty, so we don't actually need to
  // call it.
  auto clazz = getHiddenClassForBuffer(
      runtime, curCodeBlock, numLiterals, keyBufferIndex);
  auto obj = runtime.makeHandle(JSObject::create(runtime, clazz));

  auto valGen =
      curCodeBlock->getObjectBufferValueIter(valBufferIndex, numLiterals);

#ifndef NDEBUG
  auto keyGen =
      curCodeBlock->getObjectBufferKeyIter(keyBufferIndex, numLiterals);
#endif

  uint32_t propIndex = 0;
  // keyGen should always have the same amount of elements as valGen
  while (valGen.hasNext()) {
#ifndef NDEBUG
    {
      GCScopeMarkerRAII marker{runtime};
      // keyGen points to an element in the key buffer, which means it will
      // only ever generate a Number or a Symbol. This means it will never
      // allocate memory, and it is safe to not use a Handle.
      SymbolID stringIdResult{};
      auto key = keyGen.get(runtime);
      if (key.isSymbol()) {
        stringIdResult = ID(key.getSymbol().unsafeGetIndex());
      } else {
        auto keyHandle =
            runtime.makeHandle(HermesValue::encodeDoubleValue(key.getNumber()));
        auto idRes = valueToSymbolID(runtime, keyHandle);
        assert(
            idRes != ExecutionStatus::EXCEPTION &&
            "valueToIdentifier() failed for uint32_t value");
        stringIdResult = **idRes;
      }
      NamedPropertyDescriptor desc;
      auto pos = HiddenClass::findProperty(
          clazz,
          runtime,
          stringIdResult,
          PropertyFlags::defaultNewNamedPropertyFlags(),
          desc);
      assert(
          pos &&
          "Should find this property in cached hidden class property table.");
      assert(
          desc.slot == propIndex &&
          "propIndex should be the same as recorded in hidden class table.");
    }
#endif
    // Explicitly make sure valGen.get() is called before obj.get() so that
    // any allocation in valGen.get() won't invalidate the raw pointer
    // returned from obj.get().
    auto val = valGen.get(runtime);
    auto shv = SmallHermesValue::encodeHermesValue(val, runtime);
    // We made this object, it's not a Proxy.
    JSObject::setNamedSlotValueUnsafe(obj.get(), runtime, propIndex, shv);
    ++propIndex;
  }

  return createPseudoHandle(HermesValue::encodeObjectValue(*obj));
}
