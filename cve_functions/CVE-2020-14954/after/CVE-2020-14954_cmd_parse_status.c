static void cmd_parse_status(struct ImapAccountData *adata, char *s)
{
  unsigned int litlen = 0;

  char *mailbox = imap_next_word(s);

  /* We need a real tokenizer. */
  if (imap_get_literal_count(mailbox, &litlen) == 0)
  {
    if (imap_cmd_step(adata) != IMAP_RES_CONTINUE)
    {
      adata->status = IMAP_FATAL;
      return;
    }

    if (strlen(adata->buf) < litlen)
    {
      mutt_debug(LL_DEBUG1, "Error parsing STATUS mailbox\n");
      return;
    }

    mailbox = adata->buf;
    s = mailbox + litlen;
    s[0] = '\0';
    s++;
    SKIPWS(s);
  }
  else
  {
    s = imap_next_word(mailbox);
    s[-1] = '\0';
    imap_unmunge_mbox_name(adata->unicode, mailbox);
  }

  struct Mailbox *m = find_mailbox(adata, mailbox);
  struct ImapMboxData *mdata = imap_mdata_get(m);
  if (!mdata)
  {
    mutt_debug(LL_DEBUG3, "Received status for an unexpected mailbox: %s\n", mailbox);
    return;
  }
  uint32_t olduv = mdata->uidvalidity;
  unsigned int oldun = mdata->uid_next;

  if (*s++ != '(')
  {
    mutt_debug(LL_DEBUG1, "Error parsing STATUS\n");
    return;
  }
  while ((s[0] != '\0') && (s[0] != ')'))
  {
    char *value = imap_next_word(s);

    errno = 0;
    const unsigned long ulcount = strtoul(value, &value, 10);
    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))
    {
      mutt_debug(LL_DEBUG1, "Error parsing STATUS number\n");
      return;
    }
    const unsigned int count = (unsigned int) ulcount;

    if (mutt_str_startswith(s, "MESSAGES", CASE_MATCH))
      mdata->messages = count;
    else if (mutt_str_startswith(s, "RECENT", CASE_MATCH))
      mdata->recent = count;
    else if (mutt_str_startswith(s, "UIDNEXT", CASE_MATCH))
      mdata->uid_next = count;
    else if (mutt_str_startswith(s, "UIDVALIDITY", CASE_MATCH))
      mdata->uidvalidity = count;
    else if (mutt_str_startswith(s, "UNSEEN", CASE_MATCH))
      mdata->unseen = count;

    s = value;
    if ((s[0] != '\0') && (*s != ')'))
      s = imap_next_word(s);
  }
  mutt_debug(LL_DEBUG3, "%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\n",
             mdata->name, mdata->uidvalidity, mdata->uid_next, mdata->messages,
             mdata->recent, mdata->unseen);

  mutt_debug(LL_DEBUG3, "Running default STATUS handler\n");

  mutt_debug(LL_DEBUG3, "Found %s in mailbox list (OV: %u ON: %u U: %d)\n",
             mailbox, olduv, oldun, mdata->unseen);

  bool new_mail = false;
  if (C_MailCheckRecent)
  {
    if ((olduv != 0) && (olduv == mdata->uidvalidity))
    {
      if (oldun < mdata->uid_next)
        new_mail = (mdata->unseen > 0);
    }
    else if ((olduv == 0) && (oldun == 0))
    {
      /* first check per session, use recent. might need a flag for this. */
      new_mail = (mdata->recent > 0);
    }
    else
      new_mail = (mdata->unseen > 0);
  }
  else
    new_mail = (mdata->unseen > 0);

#ifdef USE_SIDEBAR
  if ((m->has_new != new_mail) || (m->msg_count != mdata->messages) ||
      (m->msg_unread != mdata->unseen))
  {
    mutt_menu_set_current_redraw(REDRAW_SIDEBAR);
  }
#endif

  m->has_new = new_mail;
  m->msg_count = mdata->messages;
  m->msg_unread = mdata->unseen;

  // force back to keep detecting new mail until the mailbox is opened
  if (m->has_new)
    mdata->uid_next = oldun;
}
