sctp_clean_up_stream(struct sctp_tcb *stcb, struct sctp_readhead *rh)
{
	struct sctp_tmit_chunk *chk, *nchk;
	struct sctp_queued_to_read *control, *ncontrol;

	TAILQ_FOREACH_SAFE(control, rh, next_instrm, ncontrol) {
		TAILQ_REMOVE(rh, control, next_instrm);
		control->on_strm_q = 0;
		if (control->on_read_q == 0) {
			sctp_free_remote_addr(control->whoFrom);
			if (control->data) {
				sctp_m_freem(control->data);
				control->data = NULL;
			}
		}
		/* Reassembly free? */
		TAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {
			TAILQ_REMOVE(&control->reasm, chk, sctp_next);
			if (chk->data) {
				sctp_m_freem(chk->data);
				chk->data = NULL;
			}
			if (chk->holds_key_ref)
				sctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);
			sctp_free_remote_addr(chk->whoTo);
			SCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);
			SCTP_DECR_CHK_COUNT();
			/*sa_ignore FREED_MEMORY*/
		}
		/*
		 * We don't free the address here
		 * since all the net's were freed
		 * above.
		 */
		if (control->on_read_q == 0) {
			sctp_free_a_readq(stcb, control);
		}
	}
}
