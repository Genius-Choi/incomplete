sctp_startup_mcore_threads(void)
{
	int i, cpu;

	if (mp_ncpus == 1)
		return;

	if (sctp_mcore_workers != NULL) {
		/* Already been here in some previous
		 * vnet?
		 */
		return;
	}
	SCTP_MALLOC(sctp_mcore_workers, struct sctp_mcore_ctrl *,
		    ((mp_maxid+1) * sizeof(struct sctp_mcore_ctrl)),
		    SCTP_M_MCORE);
	if (sctp_mcore_workers == NULL) {
		/* TSNH I hope */
		return;
	}
	memset(sctp_mcore_workers, 0 , ((mp_maxid+1) *
					sizeof(struct sctp_mcore_ctrl)));
	/* Init the structures */
	for (i = 0; i<=mp_maxid; i++) {
		TAILQ_INIT(&sctp_mcore_workers[i].que);
		SCTP_MCORE_LOCK_INIT(&sctp_mcore_workers[i]);
		SCTP_MCORE_QLOCK_INIT(&sctp_mcore_workers[i]);
		sctp_mcore_workers[i].cpuid = i;
	}
	if (sctp_cpuarry == NULL) {
		SCTP_MALLOC(sctp_cpuarry, int *,
			    (mp_ncpus * sizeof(int)),
			    SCTP_M_MCORE);
		i = 0;
		CPU_FOREACH(cpu) {
			sctp_cpuarry[i] = cpu;
			i++;
		}
	}

	/* Now start them all */
	CPU_FOREACH(cpu) {
#if __FreeBSD_version <= 701000
		(void)kthread_create(sctp_mcore_thread,
				     (void *)&sctp_mcore_workers[cpu],
				     &sctp_mcore_workers[cpu].thread_proc,
				     RFPROC,
				     SCTP_KTHREAD_PAGES,
				     SCTP_MCORE_NAME);

#else
		(void)kproc_create(sctp_mcore_thread,
				   (void *)&sctp_mcore_workers[cpu],
				   &sctp_mcore_workers[cpu].thread_proc,
				   RFPROC,
				   SCTP_KTHREAD_PAGES,
				   SCTP_MCORE_NAME);
#endif

	}
}
