sctp_iterator_inp_being_freed(struct sctp_inpcb *inp)
{
	struct sctp_iterator *it, *nit;

	/*
	 * We enter with the only the ITERATOR_LOCK in place and a write
	 * lock on the inp_info stuff.
	 */
	it = sctp_it_ctl.cur_it;
#if defined(__FreeBSD__) && __FreeBSD_version >= 801000
	if (it && (it->vn != curvnet)) {
		/* Its not looking at our VNET */
		return;
	}
#endif
	if (it && (it->inp == inp)) {
		/*
		 * This is tricky and we hold the iterator lock,
		 * but when it returns and gets the lock (when we
		 * release it) the iterator will try to operate on
		 * inp. We need to stop that from happening. But
		 * of course the iterator has a reference on the
		 * stcb and inp. We can mark it and it will stop.
		 *
		 * If its a single iterator situation, we
		 * set the end iterator flag. Otherwise
		 * we set the iterator to go to the next inp.
		 *
		 */
		if (it->iterator_flags & SCTP_ITERATOR_DO_SINGLE_INP) {
			sctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_IT;
		} else {
			sctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_INP;
		}
	}
	/* Now go through and remove any single reference to
	 * our inp that may be still pending on the list
	 */
	SCTP_IPI_ITERATOR_WQ_LOCK();
	TAILQ_FOREACH_SAFE(it, &sctp_it_ctl.iteratorhead, sctp_nxt_itr, nit) {
#if defined(__FreeBSD__) && __FreeBSD_version >= 801000
		if (it->vn != curvnet) {
			continue;
		}
#endif
		if (it->inp == inp) {
			/* This one points to me is it inp specific? */
			if (it->iterator_flags & SCTP_ITERATOR_DO_SINGLE_INP) {
				/* Remove and free this one */
				TAILQ_REMOVE(&sctp_it_ctl.iteratorhead,
				    it, sctp_nxt_itr);
				if (it->function_atend != NULL) {
					(*it->function_atend) (it->pointer, it->val);
				}
				SCTP_FREE(it, SCTP_M_ITER);
			} else {
				it->inp = LIST_NEXT(it->inp, sctp_list);
				if (it->inp) {
					SCTP_INP_INCR_REF(it->inp);
				}
			}
			/* When its put in the refcnt is incremented so decr it */
			SCTP_INP_DECR_REF(inp);
		}
	}
	SCTP_IPI_ITERATOR_WQ_UNLOCK();
}
