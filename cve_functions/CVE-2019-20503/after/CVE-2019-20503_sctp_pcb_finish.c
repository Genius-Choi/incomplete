sctp_pcb_finish(void)
{
	struct sctp_vrflist *vrf_bucket;
	struct sctp_vrf *vrf, *nvrf;
	struct sctp_ifn *ifn, *nifn;
	struct sctp_ifa *ifa, *nifa;
	struct sctpvtaghead *chain;
	struct sctp_tagblock *twait_block, *prev_twait_block;
	struct sctp_laddr *wi, *nwi;
	int i;
	struct sctp_iterator *it, *nit;

	if (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {
		SCTP_PRINTF("%s: race condition on teardown.\n", __func__);
		return;
	}
	SCTP_BASE_VAR(sctp_pcb_initialized) = 0;
#if !defined(__FreeBSD__)
	/* Notify the iterator to exit. */
	SCTP_IPI_ITERATOR_WQ_LOCK();
	sctp_it_ctl.iterator_flags |= SCTP_ITERATOR_MUST_EXIT;
	sctp_wakeup_iterator();
	SCTP_IPI_ITERATOR_WQ_UNLOCK();
#endif
#if defined(__APPLE__)
#if !defined(APPLE_LEOPARD) && !defined(APPLE_SNOWLEOPARD) && !defined(APPLE_LION) && !defined(APPLE_MOUNTAINLION)
	in_pcbinfo_detach(&SCTP_BASE_INFO(sctbinfo));
#endif
	SCTP_IPI_ITERATOR_WQ_LOCK();
	do {
		msleep(&sctp_it_ctl.iterator_flags,
		       sctp_it_ctl.ipi_iterator_wq_mtx,
		       0, "waiting_for_work", 0);
	} while ((sctp_it_ctl.iterator_flags & SCTP_ITERATOR_EXITED) == 0);
	thread_deallocate(sctp_it_ctl.thread_proc);
	SCTP_IPI_ITERATOR_WQ_UNLOCK();
#endif
#if defined(__Windows__)
	if (sctp_it_ctl.iterator_thread_obj != NULL) {
		NTSTATUS status = STATUS_SUCCESS;

		KeSetEvent(&sctp_it_ctl.iterator_wakeup[1], IO_NO_INCREMENT, FALSE);
		status = KeWaitForSingleObject(sctp_it_ctl.iterator_thread_obj,
					       Executive,
					       KernelMode,
					       FALSE,
					       NULL);
		ObDereferenceObject(sctp_it_ctl.iterator_thread_obj);
	}
#endif
#if defined(__Userspace__)
	if (sctp_it_ctl.thread_proc) {
#if defined(__Userspace_os_Windows)
		WaitForSingleObject(sctp_it_ctl.thread_proc, INFINITE);
		CloseHandle(sctp_it_ctl.thread_proc);
		sctp_it_ctl.thread_proc = NULL;
#else
		pthread_join(sctp_it_ctl.thread_proc, NULL);
		sctp_it_ctl.thread_proc = 0;
#endif
	}
#endif
#if defined(SCTP_PROCESS_LEVEL_LOCKS)
#if defined(__Userspace_os_Windows)
	DeleteConditionVariable(&sctp_it_ctl.iterator_wakeup);
#else
	pthread_cond_destroy(&sctp_it_ctl.iterator_wakeup);
	pthread_mutexattr_destroy(&SCTP_BASE_VAR(mtx_attr));
#endif
#endif
	/* In FreeBSD the iterator thread never exits
	 * but we do clean up.
	 * The only way FreeBSD reaches here is if we have VRF's
	 * but we still add the ifdef to make it compile on old versions.
	 */
#if defined(__FreeBSD__)
retry:
#endif
	SCTP_IPI_ITERATOR_WQ_LOCK();
#if defined(__FreeBSD__)
	/*
	 * sctp_iterator_worker() might be working on an it entry without
	 * holding the lock.  We won't find it on the list either and
	 * continue and free/destroy it.  While holding the lock, spin, to
	 * avoid the race condition as sctp_iterator_worker() will have to
	 * wait to re-aquire the lock.
	 */
	if (sctp_it_ctl.iterator_running != 0 || sctp_it_ctl.cur_it != NULL) {
		SCTP_IPI_ITERATOR_WQ_UNLOCK();
		SCTP_PRINTF("%s: Iterator running while we held the lock. Retry. "
		            "cur_it=%p\n", __func__, sctp_it_ctl.cur_it);
		DELAY(10);
		goto retry;
	}
#endif
	TAILQ_FOREACH_SAFE(it, &sctp_it_ctl.iteratorhead, sctp_nxt_itr, nit) {
#if defined(__FreeBSD__) && __FreeBSD_version >= 801000
		if (it->vn != curvnet) {
			continue;
		}
#endif
		TAILQ_REMOVE(&sctp_it_ctl.iteratorhead, it, sctp_nxt_itr);
		if (it->function_atend != NULL) {
			(*it->function_atend) (it->pointer, it->val);
		}
		SCTP_FREE(it,SCTP_M_ITER);
	}
	SCTP_IPI_ITERATOR_WQ_UNLOCK();
#if defined(__FreeBSD__) && __FreeBSD_version >= 801000
	SCTP_ITERATOR_LOCK();
	if ((sctp_it_ctl.cur_it) &&
	    (sctp_it_ctl.cur_it->vn == curvnet)) {
		sctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_IT;
	}
	SCTP_ITERATOR_UNLOCK();
#endif
#if !defined(__FreeBSD__)
	SCTP_IPI_ITERATOR_WQ_DESTROY();
	SCTP_ITERATOR_LOCK_DESTROY();
#endif
	SCTP_OS_TIMER_STOP_DRAIN(&SCTP_BASE_INFO(addr_wq_timer.timer));
	SCTP_WQ_ADDR_LOCK();
	LIST_FOREACH_SAFE(wi, &SCTP_BASE_INFO(addr_wq), sctp_nxt_addr, nwi) {
		LIST_REMOVE(wi, sctp_nxt_addr);
		SCTP_DECR_LADDR_COUNT();
		if (wi->action == SCTP_DEL_IP_ADDRESS) {
			SCTP_FREE(wi->ifa, SCTP_M_IFA);
		}
		SCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_laddr), wi);
	}
	SCTP_WQ_ADDR_UNLOCK();

	/*
	 * free the vrf/ifn/ifa lists and hashes (be sure address monitor
	 * is destroyed first).
	 */
	vrf_bucket = &SCTP_BASE_INFO(sctp_vrfhash)[(SCTP_DEFAULT_VRFID & SCTP_BASE_INFO(hashvrfmark))];
	LIST_FOREACH_SAFE(vrf, vrf_bucket, next_vrf, nvrf) {
		LIST_FOREACH_SAFE(ifn, &vrf->ifnlist, next_ifn, nifn) {
			LIST_FOREACH_SAFE(ifa, &ifn->ifalist, next_ifa, nifa) {
				/* free the ifa */
				LIST_REMOVE(ifa, next_bucket);
				LIST_REMOVE(ifa, next_ifa);
				SCTP_FREE(ifa, SCTP_M_IFA);
			}
			/* free the ifn */
			LIST_REMOVE(ifn, next_bucket);
			LIST_REMOVE(ifn, next_ifn);
			SCTP_FREE(ifn, SCTP_M_IFN);
		}
		SCTP_HASH_FREE(vrf->vrf_addr_hash, vrf->vrf_addr_hashmark);
		/* free the vrf */
		LIST_REMOVE(vrf, next_vrf);
		SCTP_FREE(vrf, SCTP_M_VRF);
	}
	/* free the vrf hashes */
	SCTP_HASH_FREE(SCTP_BASE_INFO(sctp_vrfhash), SCTP_BASE_INFO(hashvrfmark));
	SCTP_HASH_FREE(SCTP_BASE_INFO(vrf_ifn_hash), SCTP_BASE_INFO(vrf_ifn_hashmark));

	/* free the TIMEWAIT list elements malloc'd in the function
	 * sctp_add_vtag_to_timewait()...
	 */
	for (i = 0; i < SCTP_STACK_VTAG_HASH_SIZE; i++) {
		chain = &SCTP_BASE_INFO(vtag_timewait)[i];
		if (!LIST_EMPTY(chain)) {
			prev_twait_block = NULL;
			LIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {
				if (prev_twait_block) {
					SCTP_FREE(prev_twait_block, SCTP_M_TIMW);
				}
				prev_twait_block = twait_block;
			}
			SCTP_FREE(prev_twait_block, SCTP_M_TIMW);
		}
	}

	/* free the locks and mutexes */
#if defined(__APPLE__)
	SCTP_TIMERQ_LOCK_DESTROY();
	SCTP_TIMERWAIT_LOCK_DESTROY();
#endif
#ifdef SCTP_PACKET_LOGGING
	SCTP_IP_PKTLOG_DESTROY();
#endif
	SCTP_IPI_ADDR_DESTROY();
#if defined(__APPLE__)
	SCTP_IPI_COUNT_DESTROY();
#endif
	SCTP_STATLOG_DESTROY();
	SCTP_INP_INFO_LOCK_DESTROY();

	SCTP_WQ_ADDR_DESTROY();

#if defined(__APPLE__)
#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)
	lck_grp_attr_free(SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);
	lck_grp_free(SCTP_BASE_INFO(sctbinfo).mtx_grp);
	lck_attr_free(SCTP_BASE_INFO(sctbinfo).mtx_attr);
#else
	lck_grp_attr_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);
	lck_grp_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp);
	lck_attr_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);
#endif
#endif
#if defined(__Userspace__)
	SCTP_TIMERQ_LOCK_DESTROY();
	SCTP_TIMERWAIT_LOCK_DESTROY();
	SCTP_ZONE_DESTROY(zone_mbuf);
	SCTP_ZONE_DESTROY(zone_clust);
	SCTP_ZONE_DESTROY(zone_ext_refcnt);
#endif
	/* Get rid of other stuff too. */
	if (SCTP_BASE_INFO(sctp_asochash) != NULL)
		SCTP_HASH_FREE(SCTP_BASE_INFO(sctp_asochash), SCTP_BASE_INFO(hashasocmark));
	if (SCTP_BASE_INFO(sctp_ephash) != NULL)
		SCTP_HASH_FREE(SCTP_BASE_INFO(sctp_ephash), SCTP_BASE_INFO(hashmark));
	if (SCTP_BASE_INFO(sctp_tcpephash) != NULL)
		SCTP_HASH_FREE(SCTP_BASE_INFO(sctp_tcpephash), SCTP_BASE_INFO(hashtcpmark));

#if defined(__Windows__) || defined(__FreeBSD__) || defined(__Userspace__)
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_ep));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asoc));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_laddr));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_net));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_chunk));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_readq));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_strmoq));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asconf));
	SCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asconf_ack));
#endif
#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)
	SCTP_FREE(SCTP_BASE_STATS, SCTP_M_MCORE);
#endif
}
