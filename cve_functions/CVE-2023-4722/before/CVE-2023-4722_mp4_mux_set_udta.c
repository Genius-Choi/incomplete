static void mp4_mux_set_udta(GF_MP4MuxCtx *ctx, TrackWriter *tkw)
{
	u32 idx=0;
	while (1) {
		GF_Err e;
		u32 prop_4cc=0;
		const char *udta_name=NULL;
		const GF_PropertyValue *udta = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &udta_name);
		if (!udta) break;
		if (!udta_name)
			continue;
		if (!strncmp(udta_name, "udta_", 5) || !strncmp(udta_name, "mudta_", 6) ) {
			u32 udta_type;
			u8 *data=NULL;
			u32 size=0;
			u32 track_num = 0;

			if (!strncmp(udta_name, "udta_", 5)) {
				udta_name += 5;
				track_num = tkw->track_num;
			} else {
				udta_name += 6;
			}

			if (strlen(udta_name) != 4) continue;
			udta_type = GF_4CC(udta_name[0], udta_name[1], udta_name[2], udta_name[3]);

			if (udta->type==GF_PROP_DATA) {
				data = (u8 *) udta->value.data.ptr;
				size = udta->value.data.size;
			} else if ((udta->type == GF_PROP_STRING) && udta->value.string) {
				data = (u8 *) udta->value.string;
				size = (u32) strlen(udta->value.string)+1;
			}
			if (!data) {
				e = GF_BAD_PARAM;
			} else {
				e = gf_isom_add_user_data(ctx->file, track_num, udta_type, NULL, data, size);
			}
		}
		else if (!strcmp(udta_name, "udtab") || !strcmp(udta_name, "mudtab")) {
			u32 track_num = (!strcmp(udta_name, "mudtab")) ? 0 : tkw->track_num;
			if (udta->type == GF_PROP_DATA) {
				e = gf_isom_add_user_data_boxes(ctx->file, track_num, udta->value.data.ptr, udta->value.data.size);
			} else {
				e = GF_BAD_PARAM;
			}
		} else {
			continue;
		}

		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set udta %s: %s\n", udta_name, gf_error_to_string(e)));
		}
	}
}
