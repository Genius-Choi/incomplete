openssl_pkey_export_impl(const Variant& key, BIO *bio_out,
                         const String& passphrase /* = null_string */,
                         const Variant& configargs /* = uninit_variant */) {
  auto okey = Key::Get(key, false, passphrase.data());
  if (!okey) {
    raise_warning("cannot get key from parameter 1");
    return false;
  }
  EVP_PKEY *pkey = okey->m_key;

  struct php_x509_request req;
  memset(&req, 0, sizeof(req));
  std::vector<String> strings;
  bool ret = false;
  if (php_openssl_parse_config(&req, configargs.toArray(), strings)) {
    const EVP_CIPHER *cipher;
    if (!passphrase.empty() && req.priv_key_encrypt) {
      cipher = (EVP_CIPHER *)EVP_des_ede3_cbc();
    } else {
      cipher = nullptr;
    }
    assertx(bio_out);

    switch (EVP_PKEY_id(pkey)) {
#ifdef HAVE_EVP_PKEY_EC
      case EVP_PKEY_EC:
        ret = PEM_write_bio_ECPrivateKey(bio_out, EVP_PKEY_get0_EC_KEY(pkey),
                                         cipher,
                                         (unsigned char *)passphrase.data(),
                                         passphrase.size(),
                                         nullptr,
                                         nullptr);
        break;
#endif
      default:
        ret = PEM_write_bio_PrivateKey(bio_out, pkey, cipher,
                                       (unsigned char *)passphrase.data(),
                                       passphrase.size(), nullptr, nullptr);
        break;
    }
  }
  php_openssl_dispose_config(&req);
  return ret;
}
