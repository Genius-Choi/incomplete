refresh_trust(struct mg_connection *conn)
{
	static int reload_lock = 0;
	static long int data_check = 0;
	volatile int *p_reload_lock = (volatile int *)&reload_lock;

	struct stat cert_buf;
	long int t;
	const char *pem;
	const char *chain;
	int should_verify_peer;

	if ((pem = conn->dom_ctx->config[SSL_CERTIFICATE]) == NULL) {
		/* If peem is NULL and conn->phys_ctx->callbacks.init_ssl is not,
		 * refresh_trust still can not work. */
		return 0;
	}
	chain = conn->dom_ctx->config[SSL_CERTIFICATE_CHAIN];
	if (chain == NULL) {
		/* pem is not NULL here */
		chain = pem;
	}
	if (*chain == 0) {
		chain = NULL;
	}

	t = data_check;
	if (stat(pem, &cert_buf) != -1) {
		t = (long int)cert_buf.st_mtime;
	}

	if (data_check != t) {
		data_check = t;

		should_verify_peer = 0;
		if (conn->dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {
			if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER], "yes")
			    == 0) {
				should_verify_peer = 1;
			} else if (mg_strcasecmp(conn->dom_ctx->config[SSL_DO_VERIFY_PEER],
			                         "optional") == 0) {
				should_verify_peer = 1;
			}
		}

		if (should_verify_peer) {
			char *ca_path = conn->dom_ctx->config[SSL_CA_PATH];
			char *ca_file = conn->dom_ctx->config[SSL_CA_FILE];
			if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,
			                                  ca_file,
			                                  ca_path) != 1) {
				mg_cry_internal(
				    fc(conn->phys_ctx),
				    "SSL_CTX_load_verify_locations error: %s "
				    "ssl_verify_peer requires setting "
				    "either ssl_ca_path or ssl_ca_file. Is any of them "
				    "present in "
				    "the .conf file?",
				    ssl_error());
				return 0;
			}
		}

		if (1 == mg_atomic_inc(p_reload_lock)) {
			if (ssl_use_pem_file(conn->phys_ctx, conn->dom_ctx, pem, chain)
			    == 0) {
				return 0;
			}
			*p_reload_lock = 0;
		}
	}
	/* lock while cert is reloading */
	while (*p_reload_lock) {
		sleep(1);
	}

	return 1;
}
