worker_thread_run(struct worker_thread_args *thread_args)
{
	struct mg_context *ctx = thread_args->ctx;
	struct mg_connection *conn;
	struct mg_workerTLS tls;
#if defined(MG_LEGACY_INTERFACE)
	uint32_t addr;
#endif

	mg_set_thread_name("worker");

	tls.is_master = 0;
	tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);
#if defined(_WIN32)
	tls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);
#endif

	/* Initialize thread local storage before calling any callback */
	pthread_setspecific(sTlsKey, &tls);

	if (ctx->callbacks.init_thread) {
		/* call init_thread for a worker thread (type 1) */
		ctx->callbacks.init_thread(ctx, 1);
	}

	/* Connection structure has been pre-allocated */
	if (((int)thread_args->index < 0)
	    || ((unsigned)thread_args->index
	        >= (unsigned)ctx->cfg_worker_threads)) {
		mg_cry_internal(fc(ctx),
		                "Internal error: Invalid worker index %i",
		                (int)thread_args->index);
		return NULL;
	}
	conn = ctx->worker_connections + thread_args->index;

	/* Request buffers are not pre-allocated. They are private to the
	 * request and do not contain any state information that might be
	 * of interest to anyone observing a server status.  */
	conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);
	if (conn->buf == NULL) {
		mg_cry_internal(fc(ctx),
		                "Out of memory: Cannot allocate buffer for worker %i",
		                (int)thread_args->index);
		return NULL;
	}
	conn->buf_size = (int)ctx->max_request_size;

	conn->phys_ctx = ctx;
	conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */
	conn->host = NULL;          /* until we have more information. */

	conn->thread_index = thread_args->index;
	conn->request_info.user_data = ctx->user_data;
	/* Allocate a mutex for this connection to allow communication both
	 * within the request handler and from elsewhere in the application
	 */
	if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {
		mg_free(conn->buf);
		mg_cry_internal(fc(ctx), "%s", "Cannot create mutex");
		return NULL;
	}

#if defined(USE_SERVER_STATS)
	conn->conn_state = 1; /* not consumed */
#endif

#if defined(ALTERNATIVE_QUEUE)
	while ((ctx->stop_flag == 0)
	       && consume_socket(ctx, &conn->client, conn->thread_index)) {
#else
	/* Call consume_socket() even when ctx->stop_flag > 0, to let it
	 * signal sq_empty condvar to wake up the master waiting in
	 * produce_socket() */
	while (consume_socket(ctx, &conn->client, conn->thread_index)) {
#endif

		conn->conn_birth_time = time(NULL);

/* Fill in IP, port info early so even if SSL setup below fails,
 * error handler would have the corresponding info.
 * Thanks to Johannes Winkelmann for the patch.
 */
#if defined(USE_IPV6)
		if (conn->client.rsa.sa.sa_family == AF_INET6) {
			conn->request_info.remote_port =
			    ntohs(conn->client.rsa.sin6.sin6_port);
		} else
#endif
		{
			conn->request_info.remote_port =
			    ntohs(conn->client.rsa.sin.sin_port);
		}

		sockaddr_to_string(conn->request_info.remote_addr,
		                   sizeof(conn->request_info.remote_addr),
		                   &conn->client.rsa);

		DEBUG_TRACE("Start processing connection from %s",
		            conn->request_info.remote_addr);

		conn->request_info.is_ssl = conn->client.is_ssl;

		if (conn->client.is_ssl) {
#if !defined(NO_SSL)
			/* HTTPS connection */
			if (sslize(conn,
			           conn->dom_ctx->ssl_ctx,
			           SSL_accept,
			           &(conn->phys_ctx->stop_flag))) {
				/* conn->dom_ctx is set in get_request */

				/* Get SSL client certificate information (if set) */
				ssl_get_client_cert_info(conn);

				/* process HTTPS connection */
				process_new_connection(conn);

				/* Free client certificate info */
				if (conn->request_info.client_cert) {
					mg_free((void *)(conn->request_info.client_cert->subject));
					mg_free((void *)(conn->request_info.client_cert->issuer));
					mg_free((void *)(conn->request_info.client_cert->serial));
					mg_free((void *)(conn->request_info.client_cert->finger));
					/* Free certificate memory */
					X509_free(
					    (X509 *)conn->request_info.client_cert->peer_cert);
					conn->request_info.client_cert->peer_cert = 0;
					conn->request_info.client_cert->subject = 0;
					conn->request_info.client_cert->issuer = 0;
					conn->request_info.client_cert->serial = 0;
					conn->request_info.client_cert->finger = 0;
					mg_free(conn->request_info.client_cert);
					conn->request_info.client_cert = 0;
				}
			} else {
				/* make sure the connection is cleaned up on SSL failure */
				close_connection(conn);
			}
#endif
		} else {
			/* process HTTP connection */
			process_new_connection(conn);
		}

		DEBUG_TRACE("%s", "Connection closed");
	}


	pthread_setspecific(sTlsKey, NULL);
#if defined(_WIN32)
	CloseHandle(tls.pthread_cond_helper_mutex);
#endif
	pthread_mutex_destroy(&conn->mutex);

	/* Free the request buffer. */
	conn->buf_size = 0;
	mg_free(conn->buf);
	conn->buf = NULL;

#if defined(USE_SERVER_STATS)
	conn->conn_state = 9; /* done */
#endif

	DEBUG_TRACE("%s", "exiting");
	return NULL;
}
