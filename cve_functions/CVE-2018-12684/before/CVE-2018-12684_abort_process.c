abort_process(void *data)
{
	/* Waitpid checks for child status and won't work for a pid that does not
	 * identify a child of the current process. Thus, if the pid is reused,
	 * we will not affect a different process. */
	pid_t pid = (pid_t)data;
	int status = 0;
	pid_t rpid = waitpid(pid, &status, WNOHANG);
	if ((rpid != (pid_t)-1) && (status == 0)) {
		/* Stop child process */
		DEBUG_TRACE("CGI timer: Stop child process %p\n", pid);
		kill(pid, SIGABRT);

		/* Wait until process is terminated (don't leave zombies) */
		while (waitpid(pid, &status, 0) != (pid_t)-1) /* nop */
			;
	} else {
		DEBUG_TRACE("CGI timer: Child process %p already stopped in time\n",
		            pid);
	}
	return 0;
}
