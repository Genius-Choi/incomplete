mg_connect_client_impl(const struct mg_client_options *client_options,
                       int use_ssl,
                       char *ebuf,
                       size_t ebuf_len)
{
	struct mg_connection *conn = NULL;
	SOCKET sock;
	union usa sa;
	struct sockaddr *psa;
	socklen_t len;

	unsigned max_req_size =
	    (unsigned)atoi(config_options[MAX_REQUEST_SIZE].default_value);

	/* Size of structures, aligned to 8 bytes */
	size_t conn_size = ((sizeof(struct mg_connection) + 7) >> 3) << 3;
	size_t ctx_size = ((sizeof(struct mg_context) + 7) >> 3) << 3;

	conn = (struct mg_connection *)mg_calloc_ctx(1,
	                                             conn_size + ctx_size
	                                                 + max_req_size,
	                                             &common_client_context);

	if (conn == NULL) {
		mg_snprintf(NULL,
		            NULL, /* No truncation check for ebuf */
		            ebuf,
		            ebuf_len,
		            "calloc(): %s",
		            strerror(ERRNO));
		return NULL;
	}

#if defined(__GNUC__) || defined(__MINGW32__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-align"
#endif /* defined(__GNUC__) || defined(__MINGW32__) */
	/* conn_size is aligned to 8 bytes */

	conn->phys_ctx = (struct mg_context *)(((char *)conn) + conn_size);

#if defined(__GNUC__) || defined(__MINGW32__)
#pragma GCC diagnostic pop
#endif /* defined(__GNUC__) || defined(__MINGW32__) */

	conn->buf = (((char *)conn) + conn_size + ctx_size);
	conn->buf_size = (int)max_req_size;
	conn->phys_ctx->context_type = CONTEXT_HTTP_CLIENT;
	conn->dom_ctx = &(conn->phys_ctx->dd);

	if (!connect_socket(&common_client_context,
	                    client_options->host,
	                    client_options->port,
	                    use_ssl,
	                    ebuf,
	                    ebuf_len,
	                    &sock,
	                    &sa)) {
		/* ebuf is set by connect_socket,
		 * free all memory and return NULL; */
		mg_free(conn);
		return NULL;
	}

#if !defined(NO_SSL)
#if defined(OPENSSL_API_1_1)
	if (use_ssl
	    && (conn->client_ssl_ctx = SSL_CTX_new(TLS_client_method())) == NULL) {
		mg_snprintf(NULL,
		            NULL, /* No truncation check for ebuf */
		            ebuf,
		            ebuf_len,
		            "SSL_CTX_new error");
		closesocket(sock);
		mg_free(conn);
		return NULL;
	}
#else
	if (use_ssl
	    && (conn->client_ssl_ctx = SSL_CTX_new(SSLv23_client_method()))
	           == NULL) {
		mg_snprintf(NULL,
		            NULL, /* No truncation check for ebuf */
		            ebuf,
		            ebuf_len,
		            "SSL_CTX_new error");
		closesocket(sock);
		mg_free(conn);
		return NULL;
	}
#endif /* OPENSSL_API_1_1 */
#endif /* NO_SSL */


#if defined(USE_IPV6)
	len = (sa.sa.sa_family == AF_INET) ? sizeof(conn->client.rsa.sin)
	                                   : sizeof(conn->client.rsa.sin6);
	psa = (sa.sa.sa_family == AF_INET)
	          ? (struct sockaddr *)&(conn->client.rsa.sin)
	          : (struct sockaddr *)&(conn->client.rsa.sin6);
#else
	len = sizeof(conn->client.rsa.sin);
	psa = (struct sockaddr *)&(conn->client.rsa.sin);
#endif

	conn->client.sock = sock;
	conn->client.lsa = sa;

	if (getsockname(sock, psa, &len) != 0) {
		mg_cry_internal(conn,
		                "%s: getsockname() failed: %s",
		                __func__,
		                strerror(ERRNO));
	}

	conn->client.is_ssl = use_ssl ? 1 : 0;
	if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {
		mg_snprintf(NULL,
		            NULL, /* No truncation check for ebuf */
		            ebuf,
		            ebuf_len,
		            "Can not create mutex");
#if !defined(NO_SSL)
		SSL_CTX_free(conn->client_ssl_ctx);
#endif
		closesocket(sock);
		mg_free(conn);
		return NULL;
	}


#if !defined(NO_SSL)
	if (use_ssl) {
		common_client_context.dd.ssl_ctx = conn->client_ssl_ctx;

		/* TODO: Check ssl_verify_peer and ssl_ca_path here.
		 * SSL_CTX_set_verify call is needed to switch off server
		 * certificate checking, which is off by default in OpenSSL and
		 * on in yaSSL. */
		/* TODO: SSL_CTX_set_verify(conn->client_ssl_ctx,
		 * SSL_VERIFY_PEER, verify_ssl_server); */

		if (client_options->client_cert) {
			if (!ssl_use_pem_file(&common_client_context,
			                      &(common_client_context.dd),
			                      client_options->client_cert,
			                      NULL)) {
				mg_snprintf(NULL,
				            NULL, /* No truncation check for ebuf */
				            ebuf,
				            ebuf_len,
				            "Can not use SSL client certificate");
				SSL_CTX_free(conn->client_ssl_ctx);
				closesocket(sock);
				mg_free(conn);
				return NULL;
			}
		}

		if (client_options->server_cert) {
			SSL_CTX_load_verify_locations(conn->client_ssl_ctx,
			                              client_options->server_cert,
			                              NULL);
			SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_PEER, NULL);
		} else {
			SSL_CTX_set_verify(conn->client_ssl_ctx, SSL_VERIFY_NONE, NULL);
		}

		if (!sslize(conn,
		            conn->client_ssl_ctx,
		            SSL_connect,
		            &(conn->phys_ctx->stop_flag))) {
			mg_snprintf(NULL,
			            NULL, /* No truncation check for ebuf */
			            ebuf,
			            ebuf_len,
			            "SSL connection error");
			SSL_CTX_free(conn->client_ssl_ctx);
			closesocket(sock);
			mg_free(conn);
			return NULL;
		}
	}
#endif

	if (0 != set_non_blocking_mode(sock)) {
		mg_cry_internal(conn,
		                "Cannot set non-blocking mode for client %s:%i",
		                client_options->host,
		                client_options->port);
	}

	return conn;
}
