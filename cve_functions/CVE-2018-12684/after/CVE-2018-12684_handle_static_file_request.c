handle_static_file_request(struct mg_connection *conn,
                           const char *path,
                           struct mg_file *filep,
                           const char *mime_type,
                           const char *additional_headers)
{
	char date[64], lm[64], etag[64];
	char range[128]; /* large enough, so there will be no overflow */
	const char *msg = "OK", *hdr;
	time_t curtime = time(NULL);
	int64_t cl, r1, r2;
	struct vec mime_vec;
	int n, truncated;
	char gz_path[PATH_MAX];
	const char *encoding = "";
	const char *cors1, *cors2, *cors3;
	int is_head_request;

#if defined(USE_ZLIB)
	/* Compression is allowed, unless there is a reason not to use compression.
	 * If the file is already compressed, too small or a "range" request was
	 * made, on the fly compression is not possible. */
	int allow_on_the_fly_compression = 1;
#endif

	if ((conn == NULL) || (conn->dom_ctx == NULL) || (filep == NULL)) {
		return;
	}

	is_head_request = !strcmp(conn->request_info.request_method, "HEAD");

	if (mime_type == NULL) {
		get_mime_type(conn, path, &mime_vec);
	} else {
		mime_vec.ptr = mime_type;
		mime_vec.len = strlen(mime_type);
	}
	if (filep->stat.size > INT64_MAX) {
		mg_send_http_error(conn,
		                   500,
		                   "Error: File size is too large to send\n%" INT64_FMT,
		                   filep->stat.size);
		return;
	}
	cl = (int64_t)filep->stat.size;
	conn->status_code = 200;
	range[0] = '\0';

#if defined(USE_ZLIB)
	/* if this file is in fact a pre-gzipped file, rewrite its filename
	 * it's important to rewrite the filename after resolving
	 * the mime type from it, to preserve the actual file's type */
	if (!conn->accept_gzip) {
		allow_on_the_fly_compression = 0;
	}
#endif

	if (filep->stat.is_gzipped) {
		mg_snprintf(conn, &truncated, gz_path, sizeof(gz_path), "%s.gz", path);

		if (truncated) {
			mg_send_http_error(conn,
			                   500,
			                   "Error: Path of zipped file too long (%s)",
			                   path);
			return;
		}

		path = gz_path;
		encoding = "Content-Encoding: gzip\r\n";

#if defined(USE_ZLIB)
		/* File is already compressed. No "on the fly" compression. */
		allow_on_the_fly_compression = 0;
#endif
	}

	if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {
		mg_send_http_error(conn,
		                   500,
		                   "Error: Cannot open file\nfopen(%s): %s",
		                   path,
		                   strerror(ERRNO));
		return;
	}

	fclose_on_exec(&filep->access, conn);

	/* If "Range" request was made: parse header, send only selected part
	 * of the file. */
	r1 = r2 = 0;
	hdr = mg_get_header(conn, "Range");
	if ((hdr != NULL) && ((n = parse_range_header(hdr, &r1, &r2)) > 0)
	    && (r1 >= 0) && (r2 >= 0)) {
		/* actually, range requests don't play well with a pre-gzipped
		 * file (since the range is specified in the uncompressed space) */
		if (filep->stat.is_gzipped) {
			mg_send_http_error(
			    conn,
			    416, /* 416 = Range Not Satisfiable */
			    "%s",
			    "Error: Range requests in gzipped files are not supported");
			(void)mg_fclose(
			    &filep->access); /* ignore error on read only file */
			return;
		}
		conn->status_code = 206;
		cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);
		mg_snprintf(conn,
		            NULL, /* range buffer is big enough */
		            range,
		            sizeof(range),
		            "Content-Range: bytes "
		            "%" INT64_FMT "-%" INT64_FMT "/%" INT64_FMT "\r\n",
		            r1,
		            r1 + cl - 1,
		            filep->stat.size);
		msg = "Partial Content";

#if defined(USE_ZLIB)
		/* Do not compress ranges. */
		allow_on_the_fly_compression = 0;
#endif
	}

/* Do not compress small files. Small files do not benefit from file
 * compression, but there is still some overhead. */
#if defined(USE_ZLIB)
	if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {
		/* File is below the size limit. */
		allow_on_the_fly_compression = 0;
	}
#endif

	/* Standard CORS header */
	hdr = mg_get_header(conn, "Origin");
	if (hdr) {
		/* Cross-origin resource sharing (CORS), see
		 * http://www.html5rocks.com/en/tutorials/cors/,
		 * http://www.html5rocks.com/static/images/cors_server_flowchart.png
		 * -
		 * preflight is not supported for files. */
		cors1 = "Access-Control-Allow-Origin: ";
		cors2 = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];
		cors3 = "\r\n";
	} else {
		cors1 = cors2 = cors3 = "";
	}

	/* Prepare Etag, Date, Last-Modified headers. Must be in UTC,
	 * according to
	 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3 */
	gmt_time_string(date, sizeof(date), &curtime);
	gmt_time_string(lm, sizeof(lm), &filep->stat.last_modified);
	construct_etag(etag, sizeof(etag), &filep->stat);

	/* Send header */
	(void)mg_printf(conn,
	                "HTTP/1.1 %d %s\r\n"
	                "%s%s%s" /* CORS */
	                "Date: %s\r\n"
	                "Last-Modified: %s\r\n"
	                "Etag: %s\r\n"
	                "Content-Type: %.*s\r\n"
	                "Connection: %s\r\n",
	                conn->status_code,
	                msg,
	                cors1,
	                cors2,
	                cors3,
	                date,
	                lm,
	                etag,
	                (int)mime_vec.len,
	                mime_vec.ptr,
	                suggest_connection_header(conn));
	send_static_cache_header(conn);
	send_additional_header(conn);

#if defined(USE_ZLIB)
	/* On the fly compression allowed */
	if (allow_on_the_fly_compression) {
		/* For on the fly compression, we don't know the content size in
		 * advance, so we have to use chunked encoding */
		(void)mg_printf(conn,
		                "Content-Encoding: gzip\r\n"
		                "Transfer-Encoding: chunked\r\n");
	} else
#endif
	{
		/* Without on-the-fly compression, we know the content-length
		 * and we can use ranges (with on-the-fly compression we cannot).
		 * So we send these response headers only in this case. */
		(void)mg_printf(conn,
		                "Content-Length: %" INT64_FMT "\r\n"
		                "Accept-Ranges: bytes\r\n"
		                "%s" /* range */
		                "%s" /* encoding */,
		                cl,
		                range,
		                encoding);
	}

	/* The previous code must not add any header starting with X- to make
	 * sure no one of the additional_headers is included twice */
	if (additional_headers != NULL) {
		(void)mg_printf(conn,
		                "%.*s\r\n\r\n",
		                (int)strlen(additional_headers),
		                additional_headers);
	} else {
		(void)mg_printf(conn, "\r\n");
	}

	if (!is_head_request) {
#if defined(USE_ZLIB)
		if (allow_on_the_fly_compression) {
			/* Compress and send */
			send_compressed_data(conn, filep);
		} else
#endif
		{
			/* Send file directly */
			send_file_data(conn, filep, r1, cl);
		}
	}
	(void)mg_fclose(&filep->access); /* ignore error on read only file */
}
