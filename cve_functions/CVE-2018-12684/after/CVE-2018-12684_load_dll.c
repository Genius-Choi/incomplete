load_dll(char *ebuf, size_t ebuf_len, const char *dll_name, struct ssl_func *sw)
{
	union {
		void *p;
		void (*fp)(void);
	} u;
	void *dll_handle;
	struct ssl_func *fp;
	int ok;
	int truncated = 0;

	if ((dll_handle = dlopen(dll_name, RTLD_LAZY)) == NULL) {
		mg_snprintf(NULL,
		            NULL, /* No truncation check for ebuf */
		            ebuf,
		            ebuf_len,
		            "%s: cannot load %s",
		            __func__,
		            dll_name);
		return NULL;
	}

	ok = 1;
	for (fp = sw; fp->name != NULL; fp++) {
#if defined(_WIN32)
		/* GetProcAddress() returns pointer to function */
		u.fp = (void (*)(void))dlsym(dll_handle, fp->name);
#else
		/* dlsym() on UNIX returns void *. ISO C forbids casts of data
		 * pointers to function pointers. We need to use a union to make a
		 * cast. */
		u.p = dlsym(dll_handle, fp->name);
#endif /* _WIN32 */
		if (u.fp == NULL) {
			if (ok) {
				mg_snprintf(NULL,
				            &truncated,
				            ebuf,
				            ebuf_len,
				            "%s: %s: cannot find %s",
				            __func__,
				            dll_name,
				            fp->name);
				ok = 0;
			} else {
				size_t cur_len = strlen(ebuf);
				if (!truncated) {
					mg_snprintf(NULL,
					            &truncated,
					            ebuf + cur_len,
					            ebuf_len - cur_len - 3,
					            ", %s",
					            fp->name);
					if (truncated) {
						/* If truncated, add "..." */
						strcat(ebuf, "...");
					}
				}
			}
			/* Debug:
			 * printf("Missing function: %s\n", fp->name); */
		} else {
			fp->ptr = u.fp;
		}
	}

	if (!ok) {
		(void)dlclose(dll_handle);
		return NULL;
	}

	return dll_handle;
}
