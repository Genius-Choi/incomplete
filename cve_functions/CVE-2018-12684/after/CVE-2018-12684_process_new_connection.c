process_new_connection(struct mg_connection *conn)
{
	struct mg_request_info *ri = &conn->request_info;
	int keep_alive, discard_len;
	char ebuf[100];
	const char *hostend;
	int reqerr, uri_type;

#if defined(USE_SERVER_STATS)
	int mcon = mg_atomic_inc(&(conn->phys_ctx->active_connections));
	mg_atomic_add(&(conn->phys_ctx->total_connections), 1);
	if (mcon > (conn->phys_ctx->max_connections)) {
		/* could use atomic compare exchange, but this
		 * seems overkill for statistics data */
		conn->phys_ctx->max_connections = mcon;
	}
#endif

	init_connection(conn);

	DEBUG_TRACE("Start processing connection from %s",
	            conn->request_info.remote_addr);

	/* Loop over multiple requests sent using the same connection
	 * (while "keep alive"). */
	do {

		DEBUG_TRACE("calling get_request (%i times for this connection)",
		            conn->handled_requests + 1);

#if defined(USE_SERVER_STATS)
		conn->conn_state = 3; /* ready */
#endif

		if (!get_request(conn, ebuf, sizeof(ebuf), &reqerr)) {
			/* The request sent by the client could not be understood by
			 * the server, or it was incomplete or a timeout. Send an
			 * error message and close the connection. */
			if (reqerr > 0) {
				DEBUG_ASSERT(ebuf[0] != '\0');
				mg_send_http_error(conn, reqerr, "%s", ebuf);
			}
		} else if (strcmp(ri->http_version, "1.0")
		           && strcmp(ri->http_version, "1.1")) {
			mg_snprintf(conn,
			            NULL, /* No truncation check for ebuf */
			            ebuf,
			            sizeof(ebuf),
			            "Bad HTTP version: [%s]",
			            ri->http_version);
			mg_send_http_error(conn, 505, "%s", ebuf);
		}

		if (ebuf[0] == '\0') {
			uri_type = get_uri_type(conn->request_info.request_uri);
			switch (uri_type) {
			case 1:
				/* Asterisk */
				conn->request_info.local_uri = NULL;
				break;
			case 2:
				/* relative uri */
				conn->request_info.local_uri = conn->request_info.request_uri;
				break;
			case 3:
			case 4:
				/* absolute uri (with/without port) */
				hostend = get_rel_url_at_current_server(
				    conn->request_info.request_uri, conn);
				if (hostend) {
					conn->request_info.local_uri = hostend;
				} else {
					conn->request_info.local_uri = NULL;
				}
				break;
			default:
				mg_snprintf(conn,
				            NULL, /* No truncation check for ebuf */
				            ebuf,
				            sizeof(ebuf),
				            "Invalid URI");
				mg_send_http_error(conn, 400, "%s", ebuf);
				conn->request_info.local_uri = NULL;
				break;
			}

#if defined(MG_LEGACY_INTERFACE)
			/* Legacy before split into local_uri and request_uri */
			conn->request_info.uri = conn->request_info.local_uri;
#endif
		}

		DEBUG_TRACE("http: %s, error: %s",
		            (ri->http_version ? ri->http_version : "none"),
		            (ebuf[0] ? ebuf : "none"));

		if (ebuf[0] == '\0') {
			if (conn->request_info.local_uri) {

/* handle request to local server */
#if defined(USE_SERVER_STATS)
				conn->conn_state = 4; /* processing */
#endif
				handle_request(conn);

#if defined(USE_SERVER_STATS)
				conn->conn_state = 5; /* processed */

				mg_atomic_add(&(conn->phys_ctx->total_data_read),
				              conn->consumed_content);
				mg_atomic_add(&(conn->phys_ctx->total_data_written),
				              conn->num_bytes_sent);
#endif

				DEBUG_TRACE("%s", "handle_request done");

				if (conn->phys_ctx->callbacks.end_request != NULL) {
					conn->phys_ctx->callbacks.end_request(conn,
					                                      conn->status_code);
					DEBUG_TRACE("%s", "end_request callback done");
				}
				log_access(conn);
			} else {
				/* TODO: handle non-local request (PROXY) */
				conn->must_close = 1;
			}
		} else {
			conn->must_close = 1;
		}

		if (ri->remote_user != NULL) {
			mg_free((void *)ri->remote_user);
			/* Important! When having connections with and without auth
			 * would cause double free and then crash */
			ri->remote_user = NULL;
		}

		/* NOTE(lsm): order is important here. should_keep_alive() call
		 * is using parsed request, which will be invalid after
		 * memmove's below.
		 * Therefore, memorize should_keep_alive() result now for later
		 * use in loop exit condition. */
		keep_alive = (conn->phys_ctx->stop_flag == 0) && should_keep_alive(conn)
		             && (conn->content_len >= 0);


		/* Discard all buffered data for this request */
		discard_len = ((conn->content_len >= 0) && (conn->request_len > 0)
		               && ((conn->request_len + conn->content_len)
		                   < (int64_t)conn->data_len))
		                  ? (int)(conn->request_len + conn->content_len)
		                  : conn->data_len;
		DEBUG_ASSERT(discard_len >= 0);
		if (discard_len < 0) {
			DEBUG_TRACE("internal error: discard_len = %li",
			            (long int)discard_len);
			break;
		}
		conn->data_len -= discard_len;
		if (conn->data_len > 0) {
			DEBUG_TRACE("discard_len = %lu", (long unsigned)discard_len);
			memmove(conn->buf, conn->buf + discard_len, (size_t)conn->data_len);
		}

		DEBUG_ASSERT(conn->data_len >= 0);
		DEBUG_ASSERT(conn->data_len <= conn->buf_size);

		if ((conn->data_len < 0) || (conn->data_len > conn->buf_size)) {
			DEBUG_TRACE("internal error: data_len = %li, buf_size = %li",
			            (long int)conn->data_len,
			            (long int)conn->buf_size);
			break;
		}

		conn->handled_requests++;

	} while (keep_alive);

	DEBUG_TRACE("Done processing connection from %s (%f sec)",
	            conn->request_info.remote_addr,
	            difftime(time(NULL), conn->conn_birth_time));

	close_connection(conn);

#if defined(USE_SERVER_STATS)
	mg_atomic_add(&(conn->phys_ctx->total_requests), conn->handled_requests);
	mg_atomic_dec(&(conn->phys_ctx->active_connections));
#endif
}
