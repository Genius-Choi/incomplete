mg_init_library(unsigned features)
{
#if !defined(NO_SSL)
	char ebuf[128];
#endif

	unsigned features_to_init = mg_check_feature(features & 0xFFu);
	unsigned features_inited = features_to_init;

	if (mg_init_library_called <= 0) {
		/* Not initialized yet */
		if (0 != pthread_mutex_init(&global_lock_mutex, NULL)) {
			return 0;
		}
	}

	mg_global_lock();

	if (mg_init_library_called <= 0) {
		if (0 != pthread_key_create(&sTlsKey, tls_dtor)) {
			/* Fatal error - abort start. However, this situation should
			 * never occur in practice. */
			mg_global_unlock();
			return 0;
		}

#if defined(_WIN32)
		InitializeCriticalSection(&global_log_file_lock);
#endif
#if !defined(_WIN32)
		pthread_mutexattr_init(&pthread_mutex_attr);
		pthread_mutexattr_settype(&pthread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);
#endif

#if defined(USE_LUA)
		lua_init_optional_libraries();
#endif
	}

	mg_global_unlock();

#if !defined(NO_SSL)
	if (features_to_init & MG_FEATURES_SSL) {
		if (!mg_ssl_initialized) {
			if (initialize_ssl(ebuf, sizeof(ebuf))) {
				mg_ssl_initialized = 1;
			} else {
				(void)ebuf;
				DEBUG_TRACE("Initializing SSL failed: %s", ebuf);
				features_inited &= ~((unsigned)(MG_FEATURES_SSL));
			}
		} else {
			/* ssl already initialized */
		}
	}
#endif

	/* Start WinSock for Windows */
	mg_global_lock();
	if (mg_init_library_called <= 0) {
#if defined(_WIN32)
		WSADATA data;
		WSAStartup(MAKEWORD(2, 2), &data);
#endif /* _WIN32 */
		mg_init_library_called = 1;
	} else {
		mg_init_library_called++;
	}
	mg_global_unlock();

	return features_inited;
}
