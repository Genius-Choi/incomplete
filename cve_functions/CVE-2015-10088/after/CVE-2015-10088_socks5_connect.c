int socks5_connect(int sockfd, const char *host, int port, AyProxyData *proxy)
{
	int i;
	char buff[530];
	int need_auth = 0;
	struct addrinfo *result = NULL;
	int j;

	buff[0] = 0x05;		/* use socks v5 */
	if (proxy->username && proxy->username[0]) {
		buff[1] = 0x02;	/* we support (no authentication & username/pass) */
		buff[2] = 0x00;	/* we support the method type "no authentication" */
		buff[3] = 0x02;	/* we support the method type "username/passw" */
		need_auth = 1;
	} else {
		buff[1] = 0x01;	/* we support (no authentication) */
		buff[2] = 0x00;	/* we support the method type "no authentication" */
	}

	write(sockfd, buff, 3 + ((proxy->username
				&& proxy->username[0]) ? 1 : 0));

	if (read(sockfd, buff, 2) < 0) {
		close(sockfd);
		return AY_SOCKS5_CONNECT_FAIL;
	}
	if (buff[1] == 0x00)
		need_auth = 0;
	else if (buff[1] == 0x02 && proxy->username && proxy->username[0])
		need_auth = 1;
	else {
		fprintf(stderr, "No Acceptable Methods");
		return AY_SOCKS5_CONNECT_FAIL;
	}
	if (((proxy->username && proxy->username[0]) ? 1 : 0)) {
		/* subneg start */
		buff[0] = 0x01;	/* subneg version  */
		printf("[%d]", buff[0]);
		buff[1] = strlen(proxy->username);	/* username length */
		printf("[%d]", buff[1]);
		for (i = 0; proxy->username[i] && i < 255; i++) {
			buff[i + 2] = proxy->username[i];	/* AUTH         */
			printf("%c", buff[i + 2]);
		}
		i += 2;
		buff[i] = strlen(proxy->password);
		printf("[%d]", buff[i]);
		i++;
		for (j = 0; j < proxy->password[j] && j < 255; j++) {
			buff[i + j] = proxy->password[j];	/* AUTH         */
			printf("%c", buff[i + j]);
		}
		i += (j);
		buff[i] = 0;

		write(sockfd, buff, i);

		if (read(sockfd, buff, 2) < 0) {
			close(sockfd);
			return AY_SOCKS5_CONNECT_FAIL;
		}

		if (buff[1] != 0)
			return AY_PROXY_PERMISSION_DENIED;
	}

	buff[0] = 0x05;		/* use socks5 */
	buff[1] = 0x01;		/* connect only SOCK_STREAM for now */
	buff[2] = 0x00;		/* reserved */
	buff[3] = 0x01;		/* ipv4 address */

	if ((result = lookup_address(host, port, AF_UNSPEC)) == NULL)
		return AY_HOSTNAME_LOOKUP_FAIL;

	memcpy(buff + 4, &(((struct sockaddr_in *)result->ai_addr)->sin_addr),
		4);
	memcpy((buff + 8), &(((struct sockaddr_in *)result->ai_addr)->sin_port),
		2);

	freeaddrinfo(result);

	write(sockfd, buff, 10);

	if (read(sockfd, buff, 10) < 0) {
		close(sockfd);
		return AY_SOCKS5_CONNECT_FAIL;
	}

	if (buff[1] != 0x00) {
		for (i = 0; i < 8; i++)
			printf("%03d ", buff[i]);

		printf("%d", ntohs(*(unsigned short *)&buff[8]));
		printf("\n");
		fprintf(stderr, "SOCKS error number %d\n", buff[1]);
		close(sockfd);
		return AY_CONNECTION_REFUSED;
	}

	return AY_NONE;
}
