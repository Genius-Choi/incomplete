int socks4_connect(int sock, const char *host, int port, AyProxyData *proxy)
{
	int i, packetlen;

	unsigned char *packet = NULL;
	struct addrinfo *result = NULL;

	int retval = 0;

	if (proxy->username && proxy->username[0])
		packetlen = 9 + strlen(proxy->username);
	else
		packetlen = 9;

	result = lookup_address(host, port, AF_INET);

	if (!result)
		return AY_HOSTNAME_LOOKUP_FAIL;

	packet = (unsigned char *)calloc(packetlen, sizeof(unsigned char));

	packet[0] = 4;		/* Version */
	packet[1] = 1;		/* CONNECT  */
	packet[2] = (((unsigned short)port) >> 8);	/* DESTPORT */
	packet[3] = (((unsigned short)port) & 0xff);	/* DESTPORT */

	/* DESTIP */
	bcopy(packet + 4, &(((struct sockaddr_in *)result->ai_addr)->sin_addr),
		4);

	freeaddrinfo(result);

	if (proxy->username && proxy->username[0]) {
		for (i = 0; proxy->username[i]; i++) {
			packet[i + 8] = (unsigned char)proxy->username[i];	/* AUTH      */
		}
	}
	packet[packetlen - 1] = 0;	/* END          */
	debug_print("Sending \"%s\"\n", packet);
	if (write(sock, packet, packetlen) == packetlen) {
		bzero(packet, sizeof(packet));
		/* Check response - return as SOCKS4 if its valid */
		if (read(sock, packet, 9) >= 4) {
			if (packet[1] == 90) {
				return 0;
			} else if (packet[1] == 91)
				retval = AY_SOCKS4_UNKNOWN;
			else if (packet[1] == 92)
				retval = AY_SOCKS4_IDENTD_FAIL;
			else if (packet[1] == 93)
				retval = AY_SOCKS4_IDENT_USER_DIFF;
			else {
				retval = AY_SOCKS4_INCOMPATIBLE_ERROR;
				printf("=>>%d\n", packet[1]);
			}
		} else {
			printf("short read %s\n", packet);
		}
	}
	close(sock);

	return retval;
}
