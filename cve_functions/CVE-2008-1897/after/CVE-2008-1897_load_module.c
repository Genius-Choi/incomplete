static int load_module(void)
{
	char *config = "iax.conf";
	int x = 0;
	struct iax2_registry *reg = NULL;

	peers = ao2_container_alloc(MAX_PEER_BUCKETS, peer_hash_cb, peer_cmp_cb);
	if (!peers)
		return AST_MODULE_LOAD_FAILURE;
	users = ao2_container_alloc(MAX_USER_BUCKETS, user_hash_cb, user_cmp_cb);
	if (!users) {
		ao2_ref(peers, -1);
		return AST_MODULE_LOAD_FAILURE;
	}

	ast_custom_function_register(&iaxpeer_function);
	ast_custom_function_register(&iaxvar_function);

	iax_set_output(iax_debug_output);
	iax_set_error(iax_error_output);
	jb_setoutput(jb_error_output, jb_warning_output, NULL);
	
#ifdef HAVE_ZAPTEL
#ifdef ZT_TIMERACK
	timingfd = open("/dev/zap/timer", O_RDWR);
	if (timingfd < 0)
#endif
		timingfd = open("/dev/zap/pseudo", O_RDWR);
	if (timingfd < 0) 
		ast_log(LOG_WARNING, "Unable to open IAX timing interface: %s\n", strerror(errno));
#endif		

	memset(iaxs, 0, sizeof(iaxs));

	for (x=0;x<IAX_MAX_CALLS;x++)
		ast_mutex_init(&iaxsl[x]);

	ast_cond_init(&sched_cond, NULL);

	if (!(sched = sched_context_create())) {
		ast_log(LOG_ERROR, "Failed to create scheduler context\n");
		return AST_MODULE_LOAD_FAILURE;
	}

	if (!(io = io_context_create())) {
		ast_log(LOG_ERROR, "Failed to create I/O context\n");
		sched_context_destroy(sched);
		return AST_MODULE_LOAD_FAILURE;
	}

	if (!(netsock = ast_netsock_list_alloc())) {
		ast_log(LOG_ERROR, "Failed to create netsock list\n");
		io_context_destroy(io);
		sched_context_destroy(sched);
		return AST_MODULE_LOAD_FAILURE;
	}
	ast_netsock_init(netsock);
	
	outsock = ast_netsock_list_alloc();
	if (!outsock) {
		ast_log(LOG_ERROR, "Could not allocate outsock list.\n");
		io_context_destroy(io);
		sched_context_destroy(sched);
		return AST_MODULE_LOAD_FAILURE;
	}
	ast_netsock_init(outsock);

	ast_cli_register_multiple(cli_iax2, sizeof(cli_iax2) / sizeof(struct ast_cli_entry));

	ast_register_application(papp, iax2_prov_app, psyn, pdescrip);
	
	ast_manager_register( "IAXpeers", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, manager_iax2_show_peers, "List IAX Peers" );
	ast_manager_register( "IAXpeerlist", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, manager_iax2_show_peer_list, "List IAX Peers" );
	ast_manager_register( "IAXnetstats", EVENT_FLAG_SYSTEM | EVENT_FLAG_REPORTING, manager_iax2_show_netstats, "Show IAX Netstats" );

	if(set_config(config, 0) == -1)
		return AST_MODULE_LOAD_DECLINE;

 	if (ast_channel_register(&iax2_tech)) {
		ast_log(LOG_ERROR, "Unable to register channel class %s\n", "IAX2");
		__unload_module();
		return AST_MODULE_LOAD_FAILURE;
	}

	if (ast_register_switch(&iax2_switch)) 
		ast_log(LOG_ERROR, "Unable to register IAX switch\n");

	if (start_network_thread()) {
		ast_log(LOG_ERROR, "Unable to start network thread\n");
		__unload_module();
		return AST_MODULE_LOAD_FAILURE;
	} else
		ast_verb(2, "IAX Ready and Listening\n");

	AST_LIST_LOCK(&registrations);
	AST_LIST_TRAVERSE(&registrations, reg, entry)
		iax2_do_register(reg);
	AST_LIST_UNLOCK(&registrations);	
	
	ao2_callback(peers, 0, peer_set_sock_cb, NULL);
	ao2_callback(peers, 0, iax2_poke_peer_cb, NULL);


	reload_firmware(0);
	iax_provision_reload(0);

	return AST_MODULE_LOAD_SUCCESS;
}
