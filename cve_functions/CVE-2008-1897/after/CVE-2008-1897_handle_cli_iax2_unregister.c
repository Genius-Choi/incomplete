static char *handle_cli_iax2_unregister(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
{
	struct iax2_peer *p;

	switch (cmd) {
	case CLI_INIT:
		e->command = "iax2 unregister";
		e->usage =
			"Usage: iax2 unregister <peername>\n"
			"       Unregister (force expiration) an IAX2 peer from the registry.\n";
		return NULL;
	case CLI_GENERATE:
		return complete_iax2_unregister(a->line, a->word, a->pos, a->n);
	}

	if (a->argc != 3)
		return CLI_SHOWUSAGE;

	p = find_peer(a->argv[2], 1);
	if (p) {
		if (p->expire > 0) {
			struct iax2_peer tmp_peer = {
				.name = a->argv[2],
			};
			struct iax2_peer *peer;

			peer = ao2_find(peers, &tmp_peer, OBJ_POINTER);
			if (peer) {
				expire_registry(peer_ref(peer)); /* will release its own reference when done */
				peer_unref(peer); /* ref from ao2_find() */
				ast_cli(a->fd, "Peer %s unregistered\n", a->argv[2]);
			} else {
				ast_cli(a->fd, "Peer %s not found\n", a->argv[2]);
			}
		} else {
			ast_cli(a->fd, "Peer %s not registered\n", a->argv[2]);
		}
	} else {
		ast_cli(a->fd, "Peer unknown: %s. Not unregistered\n", a->argv[2]);
	}
	return CLI_SUCCESS;
}
