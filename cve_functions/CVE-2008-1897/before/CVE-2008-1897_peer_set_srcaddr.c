static int peer_set_srcaddr(struct iax2_peer *peer, const char *srcaddr)
{
	struct sockaddr_in sin;
	int nonlocal = 1;
	int port = IAX_DEFAULT_PORTNO;
	int sockfd = defaultsockfd;
	char *tmp;
	char *addr;
	char *portstr;

	if (!(tmp = ast_strdupa(srcaddr)))
		return -1;

	addr = strsep(&tmp, ":");
	portstr = tmp;

	if (portstr) {
		port = atoi(portstr);
		if (port < 1)
			port = IAX_DEFAULT_PORTNO;
	}
	
	if (!ast_get_ip(&sin, addr)) {
		struct ast_netsock *sock;
		int res;

		sin.sin_port = 0;
		sin.sin_family = AF_INET;
		res = check_srcaddr((struct sockaddr *) &sin, sizeof(sin));
		if (res == 0) {
			/* ip address valid. */
			sin.sin_port = htons(port);
			if (!(sock = ast_netsock_find(netsock, &sin)))
				sock = ast_netsock_find(outsock, &sin);
			if (sock) {
				sockfd = ast_netsock_sockfd(sock);
				nonlocal = 0;
			} else {
				unsigned int orig_saddr = sin.sin_addr.s_addr;
				/* INADDR_ANY matches anyway! */
				sin.sin_addr.s_addr = INADDR_ANY;
				if (ast_netsock_find(netsock, &sin)) {
					sin.sin_addr.s_addr = orig_saddr;
					sock = ast_netsock_bind(outsock, io, srcaddr, port, tos, cos, socket_read, NULL);
					if (sock) {
						sockfd = ast_netsock_sockfd(sock);
						ast_netsock_unref(sock);
						nonlocal = 0;
					} else {
						nonlocal = 2;
					}
				}
			}
		}
	}
		
	peer->sockfd = sockfd;

	if (nonlocal == 1) {
		ast_log(LOG_WARNING, "Non-local or unbound address specified (%s) in sourceaddress for '%s', reverting to default\n",
			srcaddr, peer->name);
		return -1;
        } else if (nonlocal == 2) {
		ast_log(LOG_WARNING, "Unable to bind to sourceaddress '%s' for '%s', reverting to default\n",
			srcaddr, peer->name);
			return -1;
	} else {
		ast_debug(1, "Using sourceaddress %s for '%s'\n", srcaddr, peer->name);
		return 0;
	}
}
