static int complete_dpreply(struct chan_iax2_pvt *pvt, struct iax_ies *ies)
{
	char exten[256] = "";
	int status = CACHE_FLAG_UNKNOWN, expiry = iaxdefaultdpcache, x, matchmore = 0;
	struct iax2_dpcache *dp = NULL;
	
	if (ies->called_number)
		ast_copy_string(exten, ies->called_number, sizeof(exten));
	
	if (ies->dpstatus & IAX_DPSTATUS_EXISTS)
		status = CACHE_FLAG_EXISTS;
	else if (ies->dpstatus & IAX_DPSTATUS_CANEXIST)
		status = CACHE_FLAG_CANEXIST;
	else if (ies->dpstatus & IAX_DPSTATUS_NONEXISTENT)
		status = CACHE_FLAG_NONEXISTENT;

	if (ies->refresh)
		expiry = ies->refresh;
	if (ies->dpstatus & IAX_DPSTATUS_MATCHMORE)
		matchmore = CACHE_FLAG_MATCHMORE;
	
	AST_LIST_LOCK(&dpcache);
	AST_LIST_TRAVERSE_SAFE_BEGIN(&dpcache, dp, peer_list) {
		if (strcmp(dp->exten, exten))
			continue;
		AST_LIST_REMOVE_CURRENT(peer_list);
		dp->callno = 0;
		dp->expiry.tv_sec = dp->orig.tv_sec + expiry;
		if (dp->flags & CACHE_FLAG_PENDING) {
			dp->flags &= ~CACHE_FLAG_PENDING;
			dp->flags |= status;
			dp->flags |= matchmore;
		}
		/* Wake up waiters */
		for (x=0;x<sizeof(dp->waiters) / sizeof(dp->waiters[0]); x++)
			if (dp->waiters[x] > -1)
				write(dp->waiters[x], "asdf", 4);
	}
	AST_LIST_TRAVERSE_SAFE_END;
	AST_LIST_UNLOCK(&dpcache);

	return 0;
}
