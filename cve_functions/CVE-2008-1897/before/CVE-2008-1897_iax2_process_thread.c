static void *iax2_process_thread(void *data)
{
	struct iax2_thread *thread = data;
	struct timeval tv;
	struct timespec ts;
	int put_into_idle = 0;

	ast_atomic_fetchadd_int(&iaxactivethreadcount,1);
	pthread_cleanup_push(iax2_process_thread_cleanup, data);
	for(;;) {
		/* Wait for something to signal us to be awake */
		ast_mutex_lock(&thread->lock);

		/* Flag that we're ready to accept signals */
		thread->ready_for_signal = 1;
		
		/* Put into idle list if applicable */
		if (put_into_idle)
			insert_idle_thread(thread);

		if (thread->type == IAX_THREAD_TYPE_DYNAMIC) {
			struct iax2_thread *t = NULL;
			/* Wait to be signalled or time out */
			tv = ast_tvadd(ast_tvnow(), ast_samp2tv(30000, 1000));
			ts.tv_sec = tv.tv_sec;
			ts.tv_nsec = tv.tv_usec * 1000;
			if (ast_cond_timedwait(&thread->cond, &thread->lock, &ts) == ETIMEDOUT) {
				/* This thread was never put back into the available dynamic
				 * thread list, so just go away. */
				if (!put_into_idle) {
					ast_mutex_unlock(&thread->lock);
					break;
				}
				AST_LIST_LOCK(&dynamic_list);
				/* Account for the case where this thread is acquired *right* after a timeout */
				if ((t = AST_LIST_REMOVE(&dynamic_list, thread, list)))
					ast_atomic_fetchadd_int(&iaxdynamicthreadcount, -1);
				AST_LIST_UNLOCK(&dynamic_list);
				if (t) {
					/* This dynamic thread timed out waiting for a task and was
					 * not acquired immediately after the timeout, 
					 * so it's time to go away. */
					ast_mutex_unlock(&thread->lock);
					break;
				}
				/* Someone grabbed our thread *right* after we timed out.
				 * Wait for them to set us up with something to do and signal
				 * us to continue. */
				tv = ast_tvadd(ast_tvnow(), ast_samp2tv(30000, 1000));
				ts.tv_sec = tv.tv_sec;
				ts.tv_nsec = tv.tv_usec * 1000;
				if (ast_cond_timedwait(&thread->cond, &thread->lock, &ts) == ETIMEDOUT)
				{
					ast_mutex_unlock(&thread->lock);
					break;
				}
			}
		} else {
			ast_cond_wait(&thread->cond, &thread->lock);
		}

		/* Go back into our respective list */
		put_into_idle = 1;

		ast_mutex_unlock(&thread->lock);

		if (thread->iostate == IAX_IOSTATE_IDLE)
			continue;

		/* Add ourselves to the active list now */
		AST_LIST_LOCK(&active_list);
		AST_LIST_INSERT_HEAD(&active_list, thread, list);
		AST_LIST_UNLOCK(&active_list);

		/* See what we need to do */
		switch(thread->iostate) {
		case IAX_IOSTATE_READY:
			thread->actions++;
			thread->iostate = IAX_IOSTATE_PROCESSING;
			socket_process(thread);
			handle_deferred_full_frames(thread);
			break;
		case IAX_IOSTATE_SCHEDREADY:
			thread->actions++;
			thread->iostate = IAX_IOSTATE_PROCESSING;
#ifdef SCHED_MULTITHREADED
			thread->schedfunc(thread->scheddata);
#endif		
		default:
			break;
		}
		time(&thread->checktime);
		thread->iostate = IAX_IOSTATE_IDLE;
#ifdef DEBUG_SCHED_MULTITHREAD
		thread->curfunc[0]='\0';
#endif		

		/* Now... remove ourselves from the active list, and return to the idle list */
		AST_LIST_LOCK(&active_list);
		AST_LIST_REMOVE(&active_list, thread, list);
		AST_LIST_UNLOCK(&active_list);

		/* Make sure another frame didn't sneak in there after we thought we were done. */
		handle_deferred_full_frames(thread);
	}

	/*!\note For some reason, idle threads are exiting without being removed
	 * from an idle list, which is causing memory corruption.  Forcibly remove
	 * it from the list, if it's there.
	 */
	AST_LIST_LOCK(&idle_list);
	AST_LIST_REMOVE(&idle_list, thread, list);
	AST_LIST_UNLOCK(&idle_list);

	AST_LIST_LOCK(&dynamic_list);
	AST_LIST_REMOVE(&dynamic_list, thread, list);
	AST_LIST_UNLOCK(&dynamic_list);

	/* I am exiting here on my own volition, I need to clean up my own data structures
	* Assume that I am no longer in any of the lists (idle, active, or dynamic)
	*/
	pthread_cleanup_pop(1);
	return NULL;
}
