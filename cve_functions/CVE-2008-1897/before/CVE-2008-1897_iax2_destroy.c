static void iax2_destroy(int callno)
{
	struct chan_iax2_pvt *pvt = NULL;
	struct iax_frame *cur = NULL;
	struct ast_channel *owner = NULL;

retry:
	pvt = iaxs[callno];
	lastused[callno] = ast_tvnow();
	
	owner = pvt ? pvt->owner : NULL;

	if (owner) {
		if (ast_channel_trylock(owner)) {
			ast_log(LOG_NOTICE, "Avoiding IAX destroy deadlock\n");
			ast_mutex_unlock(&iaxsl[callno]);
			usleep(1);
			ast_mutex_lock(&iaxsl[callno]);
			goto retry;
		}
	}
	if (!owner)
		iaxs[callno] = NULL;
	if (pvt) {
		if (!owner)
			pvt->owner = NULL;
		iax2_destroy_helper(pvt);

		/* Already gone */
		ast_set_flag(pvt, IAX_ALREADYGONE);	

		if (owner) {
			/* If there's an owner, prod it to give up */
			/* It is ok to use ast_queue_hangup() here instead of iax2_queue_hangup()
			 * because we already hold the owner channel lock. */
			ast_queue_hangup(owner);
		}

		AST_LIST_LOCK(&frame_queue);
		AST_LIST_TRAVERSE(&frame_queue, cur, list) {
			/* Cancel any pending transmissions */
			if (cur->callno == pvt->callno) 
				cur->retries = -1;
		}
		AST_LIST_UNLOCK(&frame_queue);

		if (pvt->reg)
			pvt->reg->callno = 0;
		if (!owner) {
			jb_frame frame;
			if (pvt->vars) {
			    ast_variables_destroy(pvt->vars);
			    pvt->vars = NULL;
			}

			while (jb_getall(pvt->jb, &frame) == JB_OK)
				iax2_frame_free(frame.data);
			jb_destroy(pvt->jb);
			/* gotta free up the stringfields */
			ast_string_field_free_memory(pvt);
			ast_free(pvt);
		}
	}
	if (owner) {
		ast_channel_unlock(owner);
	}
	if (callno & 0x4000)
		update_max_trunk();
}
