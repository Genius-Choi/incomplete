int parse_accept_hdr( struct sip_msg *msg )
{
	static unsigned int mimes[MAX_MIMES_NR];
	int nr_mimes;
	unsigned int mime;
	char *end;
	char *ret;

	/* is the header already found? */
	if ( msg->accept==0 ) {
		/* if not, found it */
		if ( parse_headers(msg, HDR_ACCEPT_F, 0)==-1)
			goto error;
		if ( msg->accept==0 ) {
			LM_DBG("missing Accept header\n");
			return 0;
		}
	}

	/* maybe the header is already parsed! */
	if ( msg->accept->parsed!=0)
		return 1;

	/* it seams we have to parse it! :-( */
	ret = msg->accept->body.s;
	end = ret + msg->accept->body.len;
	nr_mimes = 0;
	while (1){
		ret = decode_mime_type(ret, end , &mime, NULL);
		if (ret==0)
			goto parse_error;
		/* a new mime was found  -> put it into array */
		if (nr_mimes==MAX_MIMES_NR) {
			LM_ERR("accept hdr contains more than"
				" %d mime type -> buffer overflow!!\n",MAX_MIMES_NR);
			goto error;
		}
		mimes[nr_mimes++] = mime;
		/* is another mime following? */
		if (ret==end )
			break;
		/* parse the mime separator ',' */
		if (*ret!=',' || ret+1==end) {
			LM_ERR("parse error between mimes at "
				"char <%x> (offset=%d) in <%.*s>!\n",
				*ret, (int)(ret-msg->accept->body.s),
				msg->accept->body.len, msg->accept->body.s);
			goto parse_error;
		}
		/* skip the ',' */
		ret++;
	}

	/* copy and link the mime buffer into the message */
	msg->accept->parsed = (void*)pkg_malloc((nr_mimes+1)*sizeof(int));
	if (msg->accept->parsed==0) {
		LM_ERR("no more pkg memory\n");
		goto error;
	}
	memcpy(msg->accept->parsed,mimes,nr_mimes*sizeof(int));
	/* make the buffer null terminated */
	((int*)msg->accept->parsed)[nr_mimes] = 0;

	return 1;

parse_error:
	set_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM,
		"error parsing ACCEPT header");
	set_err_reply(400, "bad headers");
error:
	return -1;
}
