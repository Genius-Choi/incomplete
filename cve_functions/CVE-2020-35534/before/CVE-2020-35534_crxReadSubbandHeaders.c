int crxReadSubbandHeaders(crx_data_header_t *hdr, CrxImage *img, CrxTile *tile,
                          CrxPlaneComp *comp, uint8_t **subbandMdatPtr,
                          uint32_t *mdatSize)
{
  CrxSubband *band = comp->subBands + img->subbandCount - 1; // set to last band
  uint32_t bandHeight = tile->height;
  uint32_t bandWidth = tile->width;
  int32_t bandWidthExCoef = 0;
  int32_t bandHeightExCoef = 0;
  if (img->levels)
  {
    // Build up subband sequences to crxDecode to a level in a header

    // Coefficient structure is a bit unclear and convoluted:
    //   3 levels max - 8 groups (for tile width rounded to 8 bytes)
    //                  of 3 band per level 4 sets of coefficients for each
    int32_t *rowExCoef =
        exCoefNumTbl + 0x60 * (img->levels - 1) + 12 * (tile->width & 7);
    int32_t *colExCoef =
        exCoefNumTbl + 0x60 * (img->levels - 1) + 12 * (tile->height & 7);
    for (int level = 0; level < img->levels; ++level)
    {
      int32_t widthOddPixel = bandWidth & 1;
      int32_t heightOddPixel = bandHeight & 1;
      bandWidth = (widthOddPixel + bandWidth) >> 1;
      bandHeight = (heightOddPixel + bandHeight) >> 1;

      int32_t bandWidthExCoef0 = 0;
      int32_t bandWidthExCoef1 = 0;
      int32_t bandHeightExCoef0 = 0;
      int32_t bandHeightExCoef1 = 0;
      if (tile->tileFlag & E_HAS_TILES_ON_THE_RIGHT)
      {
        bandWidthExCoef0 = rowExCoef[0];
        bandWidthExCoef1 = rowExCoef[1];
      }
      if (tile->tileFlag & E_HAS_TILES_ON_THE_LEFT)
        ++bandWidthExCoef0;
      if (tile->tileFlag & E_HAS_TILES_ON_THE_BOTTOM)
      {
        bandHeightExCoef0 = colExCoef[0];
        bandHeightExCoef1 = colExCoef[1];
      }
      if (tile->tileFlag & E_HAS_TILES_ON_THE_TOP)
        ++bandHeightExCoef0;

      band[0].width = bandWidth + bandWidthExCoef0 - widthOddPixel;
      band[0].height = bandHeight + bandHeightExCoef0 - heightOddPixel;

      band[-1].width = bandWidth + bandWidthExCoef1;
      band[-1].height = bandHeight + bandHeightExCoef0 - heightOddPixel;

      band[-2].width = bandWidth + bandWidthExCoef0 - widthOddPixel;
      band[-2].height = bandHeight + bandHeightExCoef1;

      rowExCoef += 4;
      colExCoef += 4;
      band -= 3;
    }
    bandWidthExCoef = bandHeightExCoef = 0;
    if (tile->tileFlag & E_HAS_TILES_ON_THE_RIGHT)
      bandWidthExCoef =
          exCoefNumTbl[0x60 * (img->levels - 1) + 12 * (tile->width & 7) +
                       4 * (img->levels - 1) + 1];
    if (tile->tileFlag & E_HAS_TILES_ON_THE_BOTTOM)
      bandHeightExCoef =
          exCoefNumTbl[0x60 * (img->levels - 1) + 12 * (tile->height & 7) +
                       4 * (img->levels - 1) + 1];
  }
  band->width = bandWidthExCoef + bandWidth;
  band->height = bandHeightExCoef + bandHeight;

  if (!img->subbandCount)
    return 0;
  int32_t curSubband = 0;
  int32_t subbandOffset = 0;
  band = comp->subBands;
  for (int curSubband = 0; curSubband < img->subbandCount; curSubband++, band++)
  {
    if (*mdatSize < 0xC)
      return -1;

    if (LibRaw::sgetn(2, *subbandMdatPtr) != 0xFF03)
      return -1;

    uint32_t bitData = LibRaw::sgetn(4, *subbandMdatPtr + 8);
    uint32_t subbandSize = LibRaw::sgetn(4, *subbandMdatPtr + 4);

    if (curSubband != bitData >> 28)
    {
      band->dataSize = subbandSize;
      return -1;
    }
    band->dataSize = subbandSize - (bitData & 0x7FF);
    band->supportsPartial = bitData & 0x8000 ? 1 : 0;
    band->dataOffset = subbandOffset;
    band->quantValue = (bitData >> 19) & 0xFF;
    band->paramK = 0;
    band->bandParam = 0;
    band->bandBuf = 0;
    band->bandSize = 0;

    subbandOffset += subbandSize;

    *subbandMdatPtr += 0xC;
    *mdatSize -= 0xC;
  }
  return 0;
}
