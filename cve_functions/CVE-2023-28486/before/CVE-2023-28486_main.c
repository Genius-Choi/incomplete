main(int argc, char *argv[])
{
    int ch, i, iolog_dir_fd, len, exitcode = EXIT_FAILURE;
    bool def_filter = true, listonly = false;
    bool interactive = true, suspend_wait = false, resize = true;
    const char *decimal, *id, *user = NULL, *pattern = NULL, *tty = NULL;
    char *cp, *ep, iolog_dir[PATH_MAX];
    struct timespec offset = { 0, 0};
    struct eventlog *evlog;
    struct timespec max_delay_storage, *max_delay = NULL;
    double dval;
    debug_decl(main, SUDO_DEBUG_MAIN);

#if defined(SUDO_DEVEL) && defined(__OpenBSD__)
    {
	extern char *malloc_options;
	malloc_options = "S";
    }
#endif

    initprogname(argc > 0 ? argv[0] : "sudoreplay");
    setlocale(LC_ALL, "");
    decimal = localeconv()->decimal_point;
    bindtextdomain("sudoers", LOCALEDIR); /* XXX - should have sudoreplay domain */
    textdomain("sudoers");

    /* Register fatal/fatalx callback. */
    sudo_fatal_callback_register(sudoreplay_cleanup);

    /* Read sudo.conf and initialize the debug subsystem. */
    if (sudo_conf_read(NULL, SUDO_CONF_DEBUG) == -1)
	exit(EXIT_FAILURE);
    sudo_debug_register(getprogname(), NULL, NULL,
	sudo_conf_debug_files(getprogname()), -1);

    while ((ch = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) {
	switch (ch) {
	case 'd':
	    session_dir = optarg;
	    break;
	case 'f':
	    /* Set the replay filter. */
	    def_filter = false;
	    for (cp = strtok_r(optarg, ",", &ep); cp; cp = strtok_r(NULL, ",", &ep)) {
		if (strcmp(cp, "stdin") == 0)
		    iolog_files[IOFD_STDIN].enabled = true;
		else if (strcmp(cp, "stdout") == 0)
		    iolog_files[IOFD_STDOUT].enabled = true;
		else if (strcmp(cp, "stderr") == 0)
		    iolog_files[IOFD_STDERR].enabled = true;
		else if (strcmp(cp, "ttyin") == 0)
		    iolog_files[IOFD_TTYIN].enabled = true;
		else if (strcmp(cp, "ttyout") == 0)
		    iolog_files[IOFD_TTYOUT].enabled = true;
		else
		    sudo_fatalx(U_("invalid filter option: %s"), optarg);
	    }
	    break;
	case 'F':
	    follow_mode = true;
	    break;
	case 'h':
	    help();
	    /* NOTREACHED */
	case 'l':
	    listonly = true;
	    break;
	case 'm':
	    errno = 0;
	    dval = strtod(optarg, &ep);
	    if (*ep != '\0' || errno != 0)
		sudo_fatalx(U_("invalid max wait: %s"), optarg);
	    if (dval <= 0.0) {
		sudo_timespecclear(&max_delay_storage);
	    } else {
		max_delay_storage.tv_sec = dval;
		max_delay_storage.tv_nsec =
		    (dval - max_delay_storage.tv_sec) * 1000000000.0;
	    }
	    max_delay = &max_delay_storage;
	    break;
	case 'n':
	    interactive = false;
	    break;
	case 'R':
	    resize = false;
	    break;
	case 'S':
	    suspend_wait = true;
	    break;
	case 's':
	    errno = 0;
	    speed_factor = strtod(optarg, &ep);
	    if (*ep != '\0' || errno != 0)
		sudo_fatalx(U_("invalid speed factor: %s"), optarg);
	    break;
	case 'V':
	    (void) printf(_("%s version %s\n"), getprogname(), PACKAGE_VERSION);
	    exitcode = EXIT_SUCCESS;
	    goto done;
	default:
	    usage();
	    /* NOTREACHED */
	}

    }
    argc -= optind;
    argv += optind;

    if (listonly) {
	exitcode = list_sessions(argc, argv, pattern, user, tty);
	goto done;
    }

    if (argc != 1)
	usage();

    /* By default we replay stdout, stderr and ttyout. */
    if (def_filter) {
	iolog_files[IOFD_STDOUT].enabled = true;
	iolog_files[IOFD_STDERR].enabled = true;
	iolog_files[IOFD_TTYOUT].enabled = true;
    }

    /* Check for offset in @sec.nsec form at the end of the id. */
    id = argv[0];
    if ((cp = strchr(id, '@')) != NULL) {
	ep = iolog_parse_delay(cp + 1, &offset, decimal);
	if (ep == NULL || *ep != '\0')
	    sudo_fatalx(U_("invalid time offset %s"), cp + 1);
	*cp = '\0';
    }

    /* 6 digit ID in base 36, e.g. 01G712AB or free-form name */
    if (VALID_ID(id)) {
	len = snprintf(iolog_dir, sizeof(iolog_dir), "%s/%.2s/%.2s/%.2s",
	    session_dir, id, &id[2], &id[4]);
	if (len < 0 || len >= ssizeof(iolog_dir))
	    sudo_fatalx(U_("%s/%.2s/%.2s/%.2s: %s"), session_dir,
		id, &id[2], &id[4], strerror(ENAMETOOLONG));
    } else if (id[0] == '/') {
	len = snprintf(iolog_dir, sizeof(iolog_dir), "%s", id);
	if (len < 0 || len >= ssizeof(iolog_dir))
	    sudo_fatalx(U_("%s/timing: %s"), id, strerror(ENAMETOOLONG));
    } else {
	len = snprintf(iolog_dir, sizeof(iolog_dir), "%s/%s", session_dir, id);
	if (len < 0 || len >= ssizeof(iolog_dir)) {
	    sudo_fatalx(U_("%s/%s: %s"), session_dir, id,
		strerror(ENAMETOOLONG));
	}
    }

    /* Open files for replay, applying replay filter for the -f flag. */
    if ((iolog_dir_fd = iolog_openat(AT_FDCWD, iolog_dir, O_RDONLY)) == -1)
	sudo_fatal("%s", iolog_dir);
    for (i = 0; i < IOFD_MAX; i++) {
	if (!iolog_open(&iolog_files[i], iolog_dir_fd, i, "r")) {
	    if (errno != ENOENT) {
		sudo_fatal(U_("unable to open %s/%s"), iolog_dir,
		    iolog_fd_to_name(i));
	    }
	}
    }
    if (!iolog_files[IOFD_TIMING].enabled) {
	sudo_fatal(U_("unable to open %s/%s"), iolog_dir,
	    iolog_fd_to_name(IOFD_TIMING));
    }

    /* Parse log file. */
    if ((evlog = iolog_parse_loginfo(iolog_dir_fd, iolog_dir)) == NULL)
	goto done;
    printf(_("Replaying sudo session: %s"), evlog->command);

    /* Setup terminal if appropriate. */
    if (!isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO))
	interactive = false;
    setup_terminal(evlog, interactive, resize);
    putchar('\r');
    putchar('\n');

    /* Done with parsed log file. */
    eventlog_free(evlog);
    evlog = NULL;

    /* Replay session corresponding to iolog_files[]. */
    exitcode = replay_session(iolog_dir_fd, iolog_dir, &offset, max_delay,
	decimal, interactive, suspend_wait);

    restore_terminal_size();
    sudo_term_restore(ttyfd, true);
done:
    sudo_debug_exit_int(__func__, __FILE__, __LINE__, sudo_debug_subsys, exitcode);
    return exitcode;
}
