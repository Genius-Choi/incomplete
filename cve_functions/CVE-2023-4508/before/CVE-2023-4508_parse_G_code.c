parse_G_code(gerb_file_t *fd, gerb_state_t *state,
		gerbv_image_t *image, long int *line_num_p)
{
    int  op_int;
    gerbv_format_t *format = image->format;
    gerbv_stats_t *stats = image->gerbv_stats;
    gerbv_error_list_t *error_list = stats->error_list;
    int c;

    op_int=gerb_fgetint(fd, NULL);

    /* Emphasize text with new line '\n' in the beginning */
    dprintf("\n     Found G%02d at line %ld (%s)\n",
		    op_int, *line_num_p, gerber_g_code_name(op_int));
    
    switch(op_int) {
    case 0:  /* Move */
	/* Is this doing anything really? */
	stats->G0++;
	break;
    case 1:  /* Linear Interpolation (1X scale) */
	state->interpolation = GERBV_INTERPOLATION_LINEARx1;
	stats->G1++;
	break;
    case 2:  /* Clockwise Linear Interpolation */
	state->interpolation = GERBV_INTERPOLATION_CW_CIRCULAR;
	stats->G2++;
	break;
    case 3:  /* Counter Clockwise Linear Interpolation */
	state->interpolation = GERBV_INTERPOLATION_CCW_CIRCULAR;
	stats->G3++;
	break;
    case 4:  /* Ignore Data Block */
	/* Don't do anything, just read 'til * */
	do {
	    c = gerb_fgetc(fd);
            if (c == '\r' || c == '\n') {
                gerbv_stats_printf(error_list, GERBV_MESSAGE_WARNING, -1,
                                   _("Found newline while parsing "
                                     "G04 code at line %ld in file \"%s\", "
                                     "maybe you forgot a \"*\"?"),
                                   *line_num_p, fd->filename);
            }
	}
	while (c != EOF && c != '*');

	stats->G4++;
	break;
    case 10: /* Linear Interpolation (10X scale) */
	state->interpolation = GERBV_INTERPOLATION_LINEARx10;
	stats->G10++;
	break;
    case 11: /* Linear Interpolation (0.1X scale) */
	state->interpolation = GERBV_INTERPOLATION_LINEARx01;
	stats->G11++;
	break;
    case 12: /* Linear Interpolation (0.01X scale) */
	state->interpolation = GERBV_INTERPOLATION_LINEARx001;
	stats->G12++;
	break;
    case 36: /* Turn on Polygon Area Fill */
	state->prev_interpolation = state->interpolation;
	state->interpolation = GERBV_INTERPOLATION_PAREA_START;
	state->changed = 1;
	stats->G36++;
	break;
    case 37: /* Turn off Polygon Area Fill */
	state->interpolation = GERBV_INTERPOLATION_PAREA_END;
	state->changed = 1;
	stats->G37++;
	break;
    case 54: /* Tool prepare */
	/* XXX Maybe uneccesary??? */
	if (gerb_fgetc(fd) == 'D') {
	    int a = gerb_fgetint(fd, NULL);
	    if ((a >= 0) && (a <= APERTURE_MAX)) {
		state->curr_aperture = a;
	    } else { 
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1, 
			_("Found aperture D%02d out of bounds while parsing "
			    "G code at line %ld in file \"%s\""),
			a, *line_num_p, fd->filename);
	    }
	} else {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Found unexpected code after G54 "
			"at line %ld in file \"%s\""),
		    *line_num_p, fd->filename);
/* TODO: insert error count here */
	}
	stats->G54++;
	break;
    case 55: /* Prepare for flash */
	stats->G55++;
	break;
    case 70: /* Specify inches */
	state->state = gerbv_image_return_new_netstate (state->state);
	state->state->unit = GERBV_UNIT_INCH;
	stats->G70++;
	break;
    case 71: /* Specify millimeters */
	state->state = gerbv_image_return_new_netstate (state->state);
	state->state->unit = GERBV_UNIT_MM;
	stats->G71++;
	break;
    case 74: /* Disable 360 circular interpolation */
	state->mq_on = 0;
	stats->G74++;
	break;
    case 75: /* Enable 360 circular interpolation */
	state->mq_on = 1;
	stats->G75++;
	break;
    case 90: /* Specify absolut format */
	if (format) format->coordinate = GERBV_COORDINATE_ABSOLUTE;
	stats->G90++;
	break;
    case 91: /* Specify incremental format */
	if (format) format->coordinate = GERBV_COORDINATE_INCREMENTAL;
	stats->G91++;
	break;
    default:
	gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		_("Encountered unknown G code G%02d "
		    "at line %ld in file \"%s\""),
		op_int, *line_num_p, fd->filename);
	gerbv_stats_printf(error_list, GERBV_MESSAGE_WARNING, -1,
		_("Ignoring unknown G code G%02d"), op_int);
	stats->G_unknown++;
/* TODO: insert error count here */

	break;
    }
    
    return;
} /* parse_G_code */
