parse_rs274x(gint levelOfRecursion, gerb_file_t *fd, gerbv_image_t *image, 
	     gerb_state_t *state, gerbv_net_t *curr_net, gerbv_stats_t *stats, 
	     gchar *directoryPath, long int *line_num_p)
{
    int op[2];
    char str[3];
    int tmp;
    gerbv_aperture_t *a = NULL;
    gerbv_amacro_t *tmp_amacro;
    int ano;
    gdouble scale = 1.0;
    gerbv_error_list_t *error_list = stats->error_list;
    
    if (state->state->unit == GERBV_UNIT_MM)
    	scale = 25.4;
    
    op[0] = gerb_fgetc(fd);
    op[1] = gerb_fgetc(fd);
    
    if (op[0] == EOF || op[1] == EOF)
	gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		_("Unexpected EOF found in file \"%s\""), fd->filename);

    switch (A2I(op[0], op[1])){
	
	/* 
	 * Directive parameters 
	 */
    case A2I('A','S'): /* Axis Select */
	op[0] = gerb_fgetc(fd);
	op[1] = gerb_fgetc(fd);
	state->state = gerbv_image_return_new_netstate (state->state);
	
	if (op[0] == EOF || op[1] == EOF)
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unexpected EOF found in file \"%s\""), fd->filename);
	
	if (((op[0] == 'A') && (op[1] == 'Y')) ||
	    ((op[0] == 'B') && (op[1] == 'X'))) {
	    state->state->axisSelect = GERBV_AXIS_SELECT_SWAPAB;
	} else {
	    state->state->axisSelect = GERBV_AXIS_SELECT_NOSELECT;
	}

	op[0] = gerb_fgetc(fd);
	op[1] = gerb_fgetc(fd);
	
	if (op[0] == EOF || op[1] == EOF)
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unexpected EOF found in file \"%s\""), fd->filename);

	if (((op[0] == 'A') && (op[1] == 'Y')) ||
	    ((op[0] == 'B') && (op[1] == 'X'))) {
	    state->state->axisSelect = GERBV_AXIS_SELECT_SWAPAB;
	} else {
	    state->state->axisSelect = GERBV_AXIS_SELECT_NOSELECT;
	}
	break;

    case A2I('F','S'): /* Format Statement */
	image->format = g_new0 (gerbv_format_t,1);
	
	switch (gerb_fgetc(fd)) {
	case 'L':
	    image->format->omit_zeros = GERBV_OMIT_ZEROS_LEADING;
	    break;
	case 'T':
	    image->format->omit_zeros = GERBV_OMIT_ZEROS_TRAILING;
	    break;
	case 'D':
	    image->format->omit_zeros = GERBV_OMIT_ZEROS_EXPLICIT;
	    break;
	default:
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("EagleCad bug detected: Undefined handling of zeros "
			"in format code at line %ld in file \"%s\""),
		    *line_num_p, fd->filename);
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_WARNING, -1,
		    _("Defaulting to omitting leading zeros"));
	    gerb_ungetc(fd);
	    image->format->omit_zeros = GERBV_OMIT_ZEROS_LEADING;
	}
	
	switch (gerb_fgetc(fd)) {
	case 'A':
	    image->format->coordinate = GERBV_COORDINATE_ABSOLUTE;
	    break;
	case 'I':
	    image->format->coordinate = GERBV_COORDINATE_INCREMENTAL;
	    break;
	default:
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Invalid coordinate type defined in format code "
			"at line %ld in file \"%s\""),
		    *line_num_p, fd->filename);
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_WARNING, -1,
		    _("Defaulting to absolute coordinates"));
	    image->format->coordinate = GERBV_COORDINATE_ABSOLUTE;
	}
	op[0] = gerb_fgetc(fd);
	while((op[0] != '*')&&(op[0] != EOF)) {
	    switch (op[0]) {
	    case 'N':
		op[0] = (char)gerb_fgetc(fd);
		image->format->lim_seqno = op[0] - '0';
		break;
	    case 'G':
		op[0] = (char)gerb_fgetc(fd);
		image->format->lim_gf = op[0] - '0';
		break;
	    case 'D':
		op[0] = (char)gerb_fgetc(fd);
		image->format->lim_pf = op[0] - '0';
		break;
	    case 'M':
		op[0] = (char)gerb_fgetc(fd);
		image->format->lim_mf = op[0] - '0';
		break;
	    case 'X' :
		op[0] = gerb_fgetc(fd);
		if ((op[0] < '0') || (op[0] > '6')) {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("Illegal format size '%s' "
				"at line %ld in file \"%s\""),
			    gerbv_escape_char(op[0]),
			    *line_num_p, fd->filename);
		}
		image->format->x_int = op[0] - '0';
		op[0] = gerb_fgetc(fd);
		if ((op[0] < '0') || (op[0] > '6')) {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("Illegal format size '%s' "
				"at line %ld in file \"%s\""),
			    gerbv_escape_char(op[0]),
			    *line_num_p, fd->filename);
		}
		image->format->x_dec = op[0] - '0';
		break;
	    case 'Y':
		op[0] = gerb_fgetc(fd);
		if ((op[0] < '0') || (op[0] > '6')) {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("Illegal format size '%s' "
				"at line %ld in file \"%s\""),
			    gerbv_escape_char(op[0]),
			    *line_num_p, fd->filename);
		}
		image->format->y_int = op[0] - '0';
		op[0] = gerb_fgetc(fd);
		if ((op[0] < '0') || (op[0] > '6')) {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("Illegal format size '%s' "
			       "at line %ld in file \"%s\""),
			    gerbv_escape_char(op[0]),
			    *line_num_p, fd->filename);
		}
		image->format->y_dec = op[0] - '0';
		break;
	    default :
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Illegal format statement '%s' "
			   "at line %ld in file \"%s\""),
			gerbv_escape_char(op[0]),
			*line_num_p, fd->filename);
		gerbv_stats_printf(error_list, GERBV_MESSAGE_WARNING, -1,
			_("Ignoring invalid format statement"));
	    }
	    op[0] = gerb_fgetc(fd);
	}
	break;
    case A2I('M','I'): /* Mirror Image */
	op[0] = gerb_fgetc(fd);
	state->state = gerbv_image_return_new_netstate (state->state);
	
	while ((op[0] != '*')&&(op[0] != EOF)) {
            gint readValue=0;
	    switch (op[0]) {
	    case 'A' :
		readValue = gerb_fgetint(fd, NULL);
		if (readValue == 1) {
		    if (state->state->mirrorState == GERBV_MIRROR_STATE_FLIPB)
			state->state->mirrorState=GERBV_MIRROR_STATE_FLIPAB;
		    else
			state->state->mirrorState=GERBV_MIRROR_STATE_FLIPA;
		}
		break;
	    case 'B' :
		readValue = gerb_fgetint(fd, NULL);
		if (readValue == 1) {
		    if (state->state->mirrorState == GERBV_MIRROR_STATE_FLIPA)
			state->state->mirrorState=GERBV_MIRROR_STATE_FLIPAB;
		    else
			state->state->mirrorState=GERBV_MIRROR_STATE_FLIPB;
		}
		break;
	    default :
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Wrong character '%s' in mirror "
			    "at line %ld in file \"%s\""),
			gerbv_escape_char(op[0]), *line_num_p, fd->filename);
	    }
	    op[0] = gerb_fgetc(fd);
	}
	break;  
    case A2I('M','O'): /* Mode of Units */
	op[0] = gerb_fgetc(fd);
	op[1] = gerb_fgetc(fd);
	
	if (op[0] == EOF || op[1] == EOF)
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unexpected EOF found in file \"%s\""), fd->filename);

	switch (A2I(op[0],op[1])) {
	case A2I('I','N'):
	    state->state = gerbv_image_return_new_netstate (state->state);
	    state->state->unit = GERBV_UNIT_INCH;
	    break;
	case A2I('M','M'):
	    state->state = gerbv_image_return_new_netstate (state->state);
	    state->state->unit = GERBV_UNIT_MM;
	    break;
	default:
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Illegal unit '%s%s' at line %ld in file \"%s\""),
		    gerbv_escape_char(op[0]), gerbv_escape_char(op[1]),
		    *line_num_p, fd->filename);
	}
	break;
    case A2I('O','F'): /* Offset */
	op[0] = gerb_fgetc(fd);
	
	while ((op[0] != '*')&&(op[0] != EOF)) {
	    switch (op[0]) {
	    case 'A' :
		state->state->offsetA = gerb_fgetdouble(fd) / scale;
		break;
	    case 'B' :
		state->state->offsetB = gerb_fgetdouble(fd) / scale;
		break;
	    default :
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Wrong character '%s' in offset "
			    "at line %ld in file \"%s\""),
			gerbv_escape_char(op[0]), *line_num_p, fd->filename);
	    }
	    op[0] = gerb_fgetc(fd);
	}
	break;
    case A2I('I','F'): /* Include file */
	{
	    gchar *includeFilename = gerb_fgetstring(fd, '*');
	    
	    if (includeFilename) {
		gchar *fullPath;
		if (!g_path_is_absolute(includeFilename)) {
		    fullPath = g_build_filename (directoryPath, includeFilename, NULL);
		} else {
		    fullPath = g_strdup (includeFilename);
		}
		if (levelOfRecursion < 10) {
		    gerb_file_t *includefd = NULL;
		    
		    includefd = gerb_fopen(fullPath);
		    if (includefd) {
			gerber_parse_file_segment (levelOfRecursion + 1, image, state, curr_net, stats, includefd, directoryPath);
			gerb_fclose(includefd);
		    } else {
			gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
				_("Included file \"%s\" cannot be found "
				    "at line %ld in file \"%s\""),
				fullPath, *line_num_p, fd->filename);
		    }
		    g_free (fullPath);
		} else {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("Parser encountered more than 10 levels of "
				"include file recursion which is not allowed "
				"by the RS-274X spec"));
		}
		g_free (includeFilename);
	    }
	}
	break;
    case A2I('I','O'): /* Image offset */
	op[0] = gerb_fgetc(fd);
	
	while ((op[0] != '*')&&(op[0] != EOF)) {
	    switch (op[0]) {
	    case 'A' :
		image->info->offsetA = gerb_fgetdouble(fd) / scale;
		break;
	    case 'B' :
		image->info->offsetB = gerb_fgetdouble(fd) / scale;
		break;
	    default :
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Wrong character '%s' in image offset "
			    "at line %ld in file \"%s\""),
			gerbv_escape_char(op[0]), *line_num_p, fd->filename);
	    }
	    op[0] = gerb_fgetc(fd);
	}
	break;
    case A2I('S','F'): /* Scale Factor */
     state->state = gerbv_image_return_new_netstate (state->state);
	if (gerb_fgetc(fd) == 'A')
	    state->state->scaleA = gerb_fgetdouble(fd);
	else 
	    gerb_ungetc(fd);
	if (gerb_fgetc(fd) == 'B')
	    state->state->scaleB = gerb_fgetdouble(fd);
	else 
	    gerb_ungetc(fd);
	break;
    case A2I('I','C'): /* Input Code */
	/* Thanks to Stephen Adam for providing this information. As he writes:
	 *      btw, here's a logic puzzle for you.  If you need to
	 * read the gerber file to see how it's encoded, then
	 * how can you read it?
	 */
	op[0] = gerb_fgetc(fd);
	op[1] = gerb_fgetc(fd);
	
	if (op[0] == EOF || op[1] == EOF)
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unexpected EOF found in file \"%s\""), fd->filename);

	switch (A2I(op[0],op[1])) {
	case A2I('A','S'):
	    image->info->encoding = GERBV_ENCODING_ASCII;
	    break;
	case A2I('E','B'):
	    image->info->encoding = GERBV_ENCODING_EBCDIC;
	    break;
	case A2I('B','C'):
	    image->info->encoding = GERBV_ENCODING_BCD;
	    break;
	case A2I('I','S'):
	    image->info->encoding = GERBV_ENCODING_ISO_ASCII;
	    break;
	case A2I('E','I'):
	    image->info->encoding = GERBV_ENCODING_EIA;
	    break;
	default:
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unknown input code (IC) '%s%s' "
			"at line %ld in file \"%s\""),
		    gerbv_escape_char(op[0]), gerbv_escape_char(op[1]),
		    *line_num_p, fd->filename);
	}
	break;
	
	/* Image parameters */
    case A2I('I','J'): /* Image Justify */
	op[0] = gerb_fgetc(fd);
	image->info->imageJustifyTypeA = GERBV_JUSTIFY_LOWERLEFT;
	image->info->imageJustifyTypeB = GERBV_JUSTIFY_LOWERLEFT;
	image->info->imageJustifyOffsetA = 0.0;
	image->info->imageJustifyOffsetB = 0.0;
	while ((op[0] != '*')&&(op[0] != EOF)) {
	    switch (op[0]) {
	    case 'A' :
	    	op[0] = gerb_fgetc(fd);
	    	if (op[0] == 'C') {
		    image->info->imageJustifyTypeA = GERBV_JUSTIFY_CENTERJUSTIFY;
	    	} else if (op[0] == 'L') {
		    image->info->imageJustifyTypeA = GERBV_JUSTIFY_LOWERLEFT;
	    	} else {
		    gerb_ungetc (fd);
		    image->info->imageJustifyOffsetA = gerb_fgetdouble(fd) / scale;
	    	}
		break;
	    case 'B' :
		op[0] = gerb_fgetc(fd);
	    	if (op[0] == 'C') {
		    image->info->imageJustifyTypeB = GERBV_JUSTIFY_CENTERJUSTIFY;
	    	} else if (op[0] == 'L') {
		    image->info->imageJustifyTypeB = GERBV_JUSTIFY_LOWERLEFT;
	    	} else {
		    gerb_ungetc (fd);
		    image->info->imageJustifyOffsetB = gerb_fgetdouble(fd) / scale;
	    	}
		break;
	    default :
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Wrong character '%s' in image justify "
			    "at line %ld in file \"%s\""),
			gerbv_escape_char(op[0]), *line_num_p, fd->filename);
	    }
	    op[0] = gerb_fgetc(fd);
	}
	break;
    case A2I('I','N'): /* Image Name */
	image->info->name = gerb_fgetstring(fd, '*');
	break;
    case A2I('I','P'): /* Image Polarity */
	
	for (ano = 0; ano < 3; ano++) {
	    op[0] = gerb_fgetc(fd);
	    if (op[0] == EOF) {
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Unexpected EOF while reading image polarity (IP) "
			    "in file \"%s\""), fd->filename);
	    }
	    str[ano] = (char)op[0];
	}
	
	if (strncmp(str, "POS", 3) == 0) 
	    image->info->polarity = GERBV_POLARITY_POSITIVE;
	else if (strncmp(str, "NEG", 3) == 0)
	    image->info->polarity = GERBV_POLARITY_NEGATIVE;
	else {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unknown polarity '%s%s%s' "
			"at line %ld in file \"%s\""),
		    gerbv_escape_char(str[0]), gerbv_escape_char(str[1]),
		    gerbv_escape_char(str[2]), *line_num_p, fd->filename);
	}
	break;
    case A2I('I','R'): /* Image Rotation */
	tmp = gerb_fgetint(fd, NULL) % 360;
	if (tmp == 0)
	    image->info->imageRotation = 0.0;
	else if (tmp == 90)
	    image->info->imageRotation = M_PI_2;
	else if (tmp == 180)
	    image->info->imageRotation = M_PI;
	else if (tmp == 270)
	    image->info->imageRotation = M_PI + M_PI_2;
	else {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Image rotation must be 0, 90, 180 or 270 "
			"(is actually %d) at line %ld in file \"%s\""),
		    tmp, *line_num_p, fd->filename);
	}
	break;
    case A2I('P','F'): /* Plotter Film */
	image->info->plotterFilm = gerb_fgetstring(fd, '*');
	break;
	
	/* Aperture parameters */
    case A2I('A','D'): /* Aperture Description */
	a = (gerbv_aperture_t *) g_new0 (gerbv_aperture_t,1);

	ano = parse_aperture_definition(fd, a, image, scale, line_num_p);
	if (ano == -1) {
		/* error with line parse, so just quietly ignore */
	}
	else if ((ano >= 0) && (ano <= APERTURE_MAX)) {
	    a->unit = state->state->unit;
	    image->aperture[ano] = a;
	    dprintf("     In %s(), adding new aperture to aperture list ...\n",
			    __func__);
	    gerbv_stats_add_aperture(stats->aperture_list,
				    -1, ano, 
				    a->type,
				    a->parameter);
	    gerbv_stats_add_to_D_list(stats->D_code_list,
				     ano);
	    if (ano < APERTURE_MIN) {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("Aperture number out of bounds %d "
				"at line %ld in file \"%s\""),
			    ano, *line_num_p, fd->filename);
	    }
	} else {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Aperture number out of bounds %d "
		       "at line %ld in file \"%s\""),
		    ano, *line_num_p, fd->filename);
	}
	/* Add aperture info to stats->aperture_list here */
	
	break;
    case A2I('A','M'): /* Aperture Macro */
	tmp_amacro = image->amacro;
	image->amacro = parse_aperture_macro(fd);
	if (image->amacro) {
	    image->amacro->next = tmp_amacro;
#ifdef AMACRO_DEBUG
	    print_program(image->amacro);
#endif
	} else {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Failed to parse aperture macro "
		       "at line %ld in file \"%s\""),
		    *line_num_p, fd->filename);
	}
	// return, since we want to skip the later back-up loop
	return;
	/* Layer */
    case A2I('L','N'): /* Layer Name */
	state->layer = gerbv_image_return_new_layer (state->layer);
	state->layer->name = gerb_fgetstring(fd, '*');
	break;
    case A2I('L','P'): /* Layer Polarity */
	state->layer = gerbv_image_return_new_layer (state->layer);
	switch (gerb_fgetc(fd)) {
	case 'D': /* Dark Polarity (default) */
	    state->layer->polarity = GERBV_POLARITY_DARK;
	    break;
	case 'C': /* Clear Polarity */
	    state->layer->polarity = GERBV_POLARITY_CLEAR;
	    break;
	default:
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Unknown layer polarity '%s' "
		       "at line %ld in file \"%s\""),
		    gerbv_escape_char(op[0]), *line_num_p, fd->filename);
	}
	break;
    case A2I('K','O'): /* Knock Out */
        state->layer = gerbv_image_return_new_layer (state->layer);
        gerber_update_any_running_knockout_measurements (image);
        /* reset any previous knockout measurements */
        knockoutMeasure = FALSE;
        op[0] = gerb_fgetc(fd);
	if (op[0] == '*') { /* Disable previous SR parameters */
	    state->layer->knockout.type = GERBV_KNOCKOUT_TYPE_NOKNOCKOUT;
	    break;
	} else if (op[0] == 'C') {
	    state->layer->knockout.polarity = GERBV_POLARITY_CLEAR;
	} else if (op[0] == 'D') {
	    state->layer->knockout.polarity = GERBV_POLARITY_DARK;
	} else {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Knockout must supply a polarity (C, D, or *) "
			"at line %ld in file \"%s\""),
		    *line_num_p, fd->filename);
	}
	state->layer->knockout.lowerLeftX = 0.0;
	state->layer->knockout.lowerLeftY = 0.0;
	state->layer->knockout.width = 0.0;
	state->layer->knockout.height = 0.0;
	state->layer->knockout.border = 0.0;
	state->layer->knockout.firstInstance = TRUE;
	op[0] = gerb_fgetc(fd);
	while ((op[0] != '*')&&(op[0] != EOF)) { 
	    switch (op[0]) {
	    case 'X':
	        state->layer->knockout.type = GERBV_KNOCKOUT_TYPE_FIXEDKNOCK;
		state->layer->knockout.lowerLeftX = gerb_fgetdouble(fd) / scale;
		break;
	    case 'Y':
	        state->layer->knockout.type = GERBV_KNOCKOUT_TYPE_FIXEDKNOCK;
		state->layer->knockout.lowerLeftY = gerb_fgetdouble(fd) / scale;
		break;
	    case 'I':
	        state->layer->knockout.type = GERBV_KNOCKOUT_TYPE_FIXEDKNOCK;
		state->layer->knockout.width = gerb_fgetdouble(fd) / scale;
		break;
	    case 'J':
	        state->layer->knockout.type = GERBV_KNOCKOUT_TYPE_FIXEDKNOCK;
		state->layer->knockout.height = gerb_fgetdouble(fd) / scale;
		break;
	    case 'K':
	        state->layer->knockout.type = GERBV_KNOCKOUT_TYPE_BORDER;
	        state->layer->knockout.border = gerb_fgetdouble(fd) / scale;
	        /* this is a bordered knockout, so we need to start measuring the
	           size of a square bordering all future components */
	        knockoutMeasure = TRUE;
	        knockoutLimitXmin = HUGE_VAL;
	        knockoutLimitYmin = HUGE_VAL;
	        knockoutLimitXmax = -HUGE_VAL;
	        knockoutLimitYmax = -HUGE_VAL;
	        knockoutLayer = state->layer;
	        break;
	    default:
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Unknown variable in knockout "
			    "at line %ld in file \"%s\""),
			*line_num_p, fd->filename);
	    }
	    op[0] = gerb_fgetc(fd);
	}
	break;
    case A2I('S','R'): /* Step and Repeat */
        /* start by generating a new layer (duplicating previous layer settings */
        state->layer = gerbv_image_return_new_layer (state->layer);
	op[0] = gerb_fgetc(fd);
	if (op[0] == '*') { /* Disable previous SR parameters */
	    state->layer->stepAndRepeat.X = 1;
	    state->layer->stepAndRepeat.Y = 1;
	    state->layer->stepAndRepeat.dist_X = 0.0;
	    state->layer->stepAndRepeat.dist_Y = 0.0;
	    break;
	}
	while ((op[0] != '*')&&(op[0] != EOF)) {
	    switch (op[0]) {
	    case 'X':
		state->layer->stepAndRepeat.X = gerb_fgetint(fd, NULL);
		break;
	    case 'Y':
		state->layer->stepAndRepeat.Y = gerb_fgetint(fd, NULL);
		break;
	    case 'I':
		state->layer->stepAndRepeat.dist_X = gerb_fgetdouble(fd) / scale;
		break;
	    case 'J':
		state->layer->stepAndRepeat.dist_Y = gerb_fgetdouble(fd) / scale;
		break;
	    default:
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Step-and-repeat parameter error "
			   "at line %ld in file \"%s\""),
			*line_num_p, fd->filename);
	    }
	    
	    /*
	     * Repeating 0 times in any direction would disable the whole plot, and
	     * is probably not intended. At least one other tool (viewmate) seems
	     * to interpret 0-time repeating as repeating just once too.
	     */
	    if(state->layer->stepAndRepeat.X == 0)
		state->layer->stepAndRepeat.X = 1;
	    if(state->layer->stepAndRepeat.Y == 0)
		state->layer->stepAndRepeat.Y = 1;
	    
	    op[0] = gerb_fgetc(fd);
	}
	break;
	/* is this an actual RS274X command??  It isn't explainined in the spec... */
    case A2I('R','O'):
	state->layer = gerbv_image_return_new_layer (state->layer);
	
	state->layer->rotation = DEG2RAD(gerb_fgetdouble(fd));
	op[0] = gerb_fgetc(fd);
	if (op[0] != '*') {
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Error in layer rotation command "
		       "at line %ld in file \"%s\""),
		    *line_num_p, fd->filename);
	}
	break;
    default:
	gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		_("Unknown RS-274X extension found %%%s%s%% "
		    "at line %ld in file \"%s\""),
		gerbv_escape_char(op[0]), gerbv_escape_char(op[1]),
		*line_num_p, fd->filename);
    }

    // make sure we read until the trailing * character
    // first, backspace once in case we already read the trailing *
    gerb_ungetc(fd);
    do {
    	tmp = gerb_fgetc(fd);
    } while (tmp != EOF && tmp != '*');

    return;
} /* parse_rs274x */
