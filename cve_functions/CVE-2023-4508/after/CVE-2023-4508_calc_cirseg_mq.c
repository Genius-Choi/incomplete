calc_cirseg_mq(struct gerbv_net *net, int cw, 
	       double delta_cp_x, double delta_cp_y)
{
    double d1x, d1y, d2x, d2y;
    double alfa, beta;

    net->cirseg->cp_x = net->start_x + delta_cp_x;
    net->cirseg->cp_y = net->start_y + delta_cp_y;

    /*
     * Some good values 
     */
    d1x = -delta_cp_x;
    d1y = -delta_cp_y;
    d2x = net->stop_x - net->cirseg->cp_x;
    d2y = net->stop_y - net->cirseg->cp_y;

    /*
     * It's possible for values to be calculated that smaller than epsilon,
     * but containing opposite signs. These values cause essentially a
     * "signed zero" effect, which makes atan2 results unpredictable.
     */
    if (fabs(d1x) < DBL_EPSILON) d1x = 0;
    if (fabs(d1y) < DBL_EPSILON) d1y = 0;
    if (fabs(d2x) < DBL_EPSILON) d2x = 0;
    if (fabs(d2y) < DBL_EPSILON) d2y = 0;

    net->cirseg->width = hypot(delta_cp_x, delta_cp_y);
    net->cirseg->width *= 2.0;
    net->cirseg->height = net->cirseg->width;

    /*
     *  Keep values in radians, convert to degrees only results
     */
    alfa = atan2(d1y, d1x);
    beta = atan2(d2y, d2x);

    /*
     * Make sure it's always positive angles
     */
    if (alfa < 0.0) {
	alfa += M_PI + M_PI;
	beta += M_PI + M_PI;
    }

    if (beta < 0.0)
	beta += M_PI + M_PI;

    /*
     * This is a sanity check for angles after the nature of atan2.
     * If cw we must make sure angle1-angle2 are always positive,
     * If ccw we must make sure angle2-angle1 are always negative.
     * We should really return one angle and the difference as GTK
     * uses them. But what the heck, it works for me.
     */
    if (cw) {
	if (alfa - beta < DBL_EPSILON)
	    beta -= M_PI + M_PI;
    } else {
	if (beta - alfa < DBL_EPSILON)
	    beta += M_PI + M_PI;
    }

    net->cirseg->angle1 = RAD2DEG(alfa);
    net->cirseg->angle2 = RAD2DEG(beta);
}
