simplify_aperture_macro(gerbv_aperture_t *aperture, gdouble scale)
{
    const int extra_stack_size = 10;
    macro_stack_t *s;
    gerbv_instruction_t *ip;
    int handled = 1, nuf_parameters = 0, i, j, clearOperatorUsed = FALSE;
    double *lp; /* Local copy of parameters */
    double tmp[2] = {0.0, 0.0};
    gerbv_aperture_type_t type = GERBV_APTYPE_NONE;
    gerbv_simplified_amacro_t *sam;

    if (aperture == NULL)
	GERB_FATAL_ERROR(_("aperture NULL in simplify aperture macro"));

    if (aperture->amacro == NULL)
	GERB_FATAL_ERROR(_("aperture->amacro NULL in simplify aperture macro"));

    /* Allocate stack for VM */
    s = new_stack(aperture->amacro->nuf_push + extra_stack_size);
    if (s == NULL) 
	GERB_FATAL_ERROR("malloc stack failed in %s()", __FUNCTION__);

    /* Make a copy of the parameter list that we can rewrite if necessary */
    lp = g_new (double,APERTURE_PARAMETERS_MAX);

    memcpy(lp, aperture->parameter, sizeof(double) * APERTURE_PARAMETERS_MAX);
    
    for(ip = aperture->amacro->program; ip != NULL; ip = ip->next) {
	switch(ip->opcode) {
	case GERBV_OPCODE_NOP:
	    break;
	case GERBV_OPCODE_PUSH :
	    push(s, ip->data.fval);
	    break;
        case GERBV_OPCODE_PPUSH : {
	    ssize_t const idx = ip->data.ival - 1;
	    if ((idx < 0) || (idx >= APERTURE_PARAMETERS_MAX))
		GERB_FATAL_ERROR(_("Tried to access oob aperture"));
	    push(s, lp[idx]);
	    break;
	}
	case GERBV_OPCODE_PPOP: {
	    if (pop(s, &tmp[0]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    ssize_t const idx = ip->data.ival - 1;
	    if ((idx < 0) || (idx >= APERTURE_PARAMETERS_MAX))
		GERB_FATAL_ERROR(_("Tried to access oob aperture"));
	    lp[idx] = tmp[0];
	    break;
	}
	case GERBV_OPCODE_ADD :
	    if (pop(s, &tmp[0]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    if (pop(s, &tmp[1]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    push(s, tmp[1] + tmp[0]);
	    break;
	case GERBV_OPCODE_SUB :
	    if (pop(s, &tmp[0]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    if (pop(s, &tmp[1]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    push(s, tmp[1] - tmp[0]);
	    break;
	case GERBV_OPCODE_MUL :
	    if (pop(s, &tmp[0]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    if (pop(s, &tmp[1]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    push(s, tmp[1] * tmp[0]);
	    break;
	case GERBV_OPCODE_DIV :
	    if (pop(s, &tmp[0]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    if (pop(s, &tmp[1]) < 0)
		GERB_FATAL_ERROR(_("Tried to pop an empty stack"));
	    push(s, tmp[1] / tmp[0]);
	    break;
	case GERBV_OPCODE_PRIM :
	    /* 
	     * This handles the exposure thing in the aperture macro
	     * The exposure is always the first element on stack independent
	     * of aperture macro.
	     */
	    switch(ip->data.ival) {
	    case 1:
		dprintf("  Aperture macro circle [1] (");
		type = GERBV_APTYPE_MACRO_CIRCLE;
		nuf_parameters = 4;
		break;
	    case 3:
		break;
	    case 4 :
		dprintf("  Aperture macro outline [4] (");
		type = GERBV_APTYPE_MACRO_OUTLINE;
		/*
		 * Number of parameters are:
		 * - number of points defined in entry 1 of the stack + 
		 *   start point. Times two since it is both X and Y.
		 * - Then three more; exposure,  nuf points and rotation.
		 *
		 * @warning Calculation must be guarded against signed integer
		 *     overflow
		 *
		 * @see CVE-2021-40394
		 */
		int const sstack = (int)s->stack[1];
		if ((sstack < 0) || (sstack >= INT_MAX / 4)) {
			GERB_COMPILE_ERROR(_("Possible signed integer overflow "
					"in calculating number of parameters "
					"to aperture macro, will clamp to "
					"(%d)"), APERTURE_PARAMETERS_MAX);
			nuf_parameters = APERTURE_PARAMETERS_MAX;
		} else {
			nuf_parameters = (sstack + 1) * 2 + 3;
		}
		break;
	    case 5 :
		dprintf("  Aperture macro polygon [5] (");
		type = GERBV_APTYPE_MACRO_POLYGON;
		nuf_parameters = 6;
		break;
	    case 6 :
		dprintf("  Aperture macro moire [6] (");
		type = GERBV_APTYPE_MACRO_MOIRE;
		nuf_parameters = 9;
		break;
	    case 7 :
		dprintf("  Aperture macro thermal [7] (");
		type = GERBV_APTYPE_MACRO_THERMAL;
		nuf_parameters = 6;
		break;
	    case 2  :
	    case 20 :
		dprintf("  Aperture macro line 20/2 (");
		type = GERBV_APTYPE_MACRO_LINE20;
		nuf_parameters = 7;
		break;
	    case 21 :
		dprintf("  Aperture macro line 21 (");
		type = GERBV_APTYPE_MACRO_LINE21;
		nuf_parameters = 6;
		break;
	    case 22 :
		dprintf("  Aperture macro line 22 (");
		type = GERBV_APTYPE_MACRO_LINE22;
		nuf_parameters = 6;
		break;
	    default :
		handled = 0;
	    }

	    if (type != GERBV_APTYPE_NONE) { 
		if (nuf_parameters > APERTURE_PARAMETERS_MAX) {
			GERB_COMPILE_ERROR(_("Number of parameters to aperture macro (%d) "
					"are more than gerbv is able to store (%d)"),
					nuf_parameters, APERTURE_PARAMETERS_MAX);
			nuf_parameters = APERTURE_PARAMETERS_MAX;
		}

		/*
		 * Create struct for simplified aperture macro and
		 * start filling in the blanks.
		 */
		sam = g_new (gerbv_simplified_amacro_t, 1);
		sam->type = type;
		sam->next = NULL;
		memset(sam->parameter, 0, 
		       sizeof(double) * APERTURE_PARAMETERS_MAX);

		/* CVE-2021-40400
		 */
		if (nuf_parameters > s->capacity) {
			GERB_COMPILE_ERROR(_("Number of parameters to aperture macro (%d) "
					"capped to stack capacity (%zu)"),
					nuf_parameters, s->capacity);
			nuf_parameters = s->capacity;
		}
		memcpy(sam->parameter, s->stack, 
		       sizeof(double) *  nuf_parameters);
		
		/* convert any mm values to inches */
		switch (type) {
		    case GERBV_APTYPE_MACRO_CIRCLE:
			if (fabs(sam->parameter[0]) < 0.001)
			    clearOperatorUsed = TRUE;
			sam->parameter[1]/=scale;
			sam->parameter[2]/=scale;
			sam->parameter[3]/=scale;
			break;
		    case GERBV_APTYPE_MACRO_OUTLINE:
			if (fabs(sam->parameter[0]) < 0.001)
			    clearOperatorUsed = TRUE;
			for (j=2; j<nuf_parameters-1; j++){
			    sam->parameter[j]/=scale;
			}
			break;
		    case GERBV_APTYPE_MACRO_POLYGON:
			if (fabs(sam->parameter[0]) < 0.001)
			    clearOperatorUsed = TRUE;
			sam->parameter[2]/=scale;
			sam->parameter[3]/=scale;
			sam->parameter[4]/=scale;
			break;
		    case GERBV_APTYPE_MACRO_MOIRE:
			sam->parameter[0]/=scale;
			sam->parameter[1]/=scale;
			sam->parameter[2]/=scale;
			sam->parameter[3]/=scale;
			sam->parameter[4]/=scale;
			sam->parameter[6]/=scale;
			sam->parameter[7]/=scale;
			break;
		    case GERBV_APTYPE_MACRO_THERMAL:
			sam->parameter[0]/=scale;
			sam->parameter[1]/=scale;
			sam->parameter[2]/=scale;
			sam->parameter[3]/=scale;
			sam->parameter[4]/=scale;
			break;
		    case GERBV_APTYPE_MACRO_LINE20:
			if (fabs(sam->parameter[0]) < 0.001)
			    clearOperatorUsed = TRUE;
			sam->parameter[1]/=scale;
			sam->parameter[2]/=scale;
			sam->parameter[3]/=scale;
			sam->parameter[4]/=scale;
			sam->parameter[5]/=scale;
			break;
		    case GERBV_APTYPE_MACRO_LINE21:
		    case GERBV_APTYPE_MACRO_LINE22:
			if (fabs(sam->parameter[0]) < 0.001)
			    clearOperatorUsed = TRUE;
			sam->parameter[1]/=scale;
			sam->parameter[2]/=scale;
			sam->parameter[3]/=scale;
			sam->parameter[4]/=scale;
			break;
		    default: 
			break;			
		}
		/* 
		 * Add this simplified aperture macro to the end of the list
		 * of simplified aperture macros. If first entry, put it
		 * in the top.
		 */
		if (aperture->simplified == NULL) {
		    aperture->simplified = sam;
		} else {
		    gerbv_simplified_amacro_t *tmp_sam;
		    tmp_sam = aperture->simplified;
		    while (tmp_sam->next != NULL) {
			tmp_sam = tmp_sam->next;
		    }
		    tmp_sam->next = sam;
		}

#ifdef DEBUG
		for (i = 0; i < nuf_parameters; i++) {
		    dprintf("%f, ", s->stack[i]);
		}
#endif /* DEBUG */
		dprintf(")\n");
	    }

	    /* 
	     * Here we reset the stack pointer. It's not general correct
	     * correct to do this, but since I know how the compiler works
	     * I can do this. The correct way to do this should be to 
	     * subtract number of used elements in each primitive operation.
	     */
	    s->sp = 0;
	    break;
	default :
	    break;
	}
    }
    free_stack(s);
    g_free (lp);

    /* store a flag to let the renderer know if it should expect any "clear"
       primatives */
    aperture->parameter[0]= (gdouble) clearOperatorUsed;
    return handled;
} /* simplify_aperture_macro */
