static int32_t check_load_area(uintptr_t dst, uintptr_t len)
{
	uint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;
	uintptr_t dram_start, dram_end;
	uintptr_t prot_start, prot_end;
	int32_t result = IO_SUCCESS;

	dram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;

	dram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :
	    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;

	prot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;

	prot_end = prot_start + DRAM_PROTECTED_SIZE;

	if (dst < dram_start || dst > dram_end - len || dram_end < len) {
		ERROR("BL2: dst address is on the protected area.\n");
		result = IO_FAIL;
		goto done;
	}

	/* load image is within SDRAM protected area */
	if (dst >= prot_start && dst < prot_end) {
		ERROR("BL2: dst address is on the protected area.\n");
		result = IO_FAIL;
	}

	if ((dst < prot_start && dst > prot_start - len) || prot_start < len) {
		ERROR("BL2: loaded data is on the protected area.\n");
		result = IO_FAIL;
	}
done:
	if (result == IO_FAIL) {
		ERROR("BL2: Out of range : dst=0x%lx len=0x%lx\n", dst, len);
	}

	if (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {
		ERROR("BL2: max loadable non secure images reached\n");
		result = IO_FAIL;
	}
	addr_loaded[addr_loaded_cnt].dest = dst;
	addr_loaded[addr_loaded_cnt].length = len;
	for(int n=0; n<addr_loaded_cnt; n++) {
		/* Check if next image invades a previous loaded image
		 *
		 * IMAGE n: area from previous image:	dest| IMAGE n |length
		 * IMAGE n+1: area from next image:	dst | IMAGE n |len
		 *
		 * 1. check:
		 *      | IMAGE n |
		 *           | IMAGE n+1 |
		 * 2. check:
		 *      | IMAGE n |
		 *  | IMAGE n+1 |
		 *
		 * */
		if (((dst > addr_loaded[n].dest) &&
		     (dst <  addr_loaded[n].dest + addr_loaded[n].length)) ||
		    (((dst < addr_loaded[n].dest) &&
		      (dst + len)) > addr_loaded[n].dest)) {
			ERROR("BL2: image is inside a previous image area.\n");
			result = IO_FAIL;
		}
	}
	addr_loaded_cnt++;

	return result;
}
