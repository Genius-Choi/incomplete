static int bfInsertCommon(RedisModuleCtx *ctx, RedisModuleString *keystr, RedisModuleString **items,
                          size_t nitems, const BFInsertOptions *options) {
    RedisModuleKey *key = RedisModule_OpenKey(ctx, keystr, REDISMODULE_READ | REDISMODULE_WRITE);
    SBChain *sb;
    const int status = bfGetChain(key, &sb);

    if (status == SB_EMPTY && options->autocreate) {
        sb = bfCreateChain(key, options->error_rate, options->capacity, options->expansion,
                           options->nonScaling);
        if (sb == NULL) {
            return RedisModule_ReplyWithError(ctx, "ERR could not create filter"); // LCOV_EXCL_LINE
        }
    } else if (status != SB_OK) {
        return RedisModule_ReplyWithError(ctx, statusStrerror(status));
    }

    if (options->is_multi) {
        RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_ARRAY_LEN);
    }

    size_t array_len = 0;
    int rv = 0;
    for (size_t ii = 0; ii < nitems && rv != -2; ++ii) {
        size_t n;
        const char *s = RedisModule_StringPtrLen(items[ii], &n);
        rv = SBChain_Add(sb, s, n);
        if (rv == -2) { // decide if to make into an error
            RedisModule_ReplyWithError(ctx, "ERR non scaling filter is full");
        } else if (rv == -1) {
            RedisModule_ReplyWithError(ctx, "ERR problem inserting into filter");
        } else {
            if (_is_resp3(ctx)) {
                RedisModule_ReplyWithBool(ctx, !!rv);
            } else {
                RedisModule_ReplyWithLongLong(ctx, !!rv);
            }
        }
        array_len++;
    }

    if (options->is_multi) {
        RedisModule_ReplySetArrayLength(ctx, array_len);
    }
    RedisModule_ReplicateVerbatim(ctx);
    return REDISMODULE_OK;
}
