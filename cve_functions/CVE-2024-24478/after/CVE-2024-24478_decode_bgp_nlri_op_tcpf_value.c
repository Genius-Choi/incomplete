decode_bgp_nlri_op_tcpf_value(proto_tree *parent_tree, proto_item *parent_item, tvbuff_t *tvb, gint offset)
{
    guint8 nlri_operator;
    guint8 tcp_flags;
    guint cursor_op_val=0;
    guint8 value_len=0;
    guint8 shift_amount=0;
    guint first_loop=0;

    static int * const nlri_tcp_flags[] = {
        &hf_bgp_flowspec_nlri_tcp_flags_cwr,
        &hf_bgp_flowspec_nlri_tcp_flags_ecn,
        &hf_bgp_flowspec_nlri_tcp_flags_urg,
        &hf_bgp_flowspec_nlri_tcp_flags_ack,
        &hf_bgp_flowspec_nlri_tcp_flags_push,
        &hf_bgp_flowspec_nlri_tcp_flags_reset,
        &hf_bgp_flowspec_nlri_tcp_flags_syn,
        &hf_bgp_flowspec_nlri_tcp_flags_fin,
        NULL
    };

    proto_item_append_text(parent_item," (");

    do {
        nlri_operator = tvb_get_guint8(tvb, offset+cursor_op_val);
        shift_amount = nlri_operator&0x30;
        shift_amount = shift_amount >> 4;
        value_len = 1 << shift_amount; /* as written in RFC 5575 section 4 */
        decode_bgp_flow_spec_bitmask_operator(parent_tree, tvb, offset+cursor_op_val); /* call to a operator decode function */
        if (first_loop == 0)
        {
            /* If first operator we remove a white space and or (||) is not relevant */
            proto_item_append_text(parent_item,"%s%s%s%s",
                 ((nlri_operator & BGPNLRI_FSPEC_AND_BIT) == 0) ? "" : "&& ",
                 ((nlri_operator & BGPNLRI_FSPEC_GREATER_THAN) == 0) ? "" : ">",
                 ((nlri_operator & BGPNLRI_FSPEC_LESS_THAN) == 0) ? "" : "<",
                 ((nlri_operator & BGPNLRI_FSPEC_EQUAL) == 0) ? "" : "=");
            first_loop = 1;
        }
        else
        {
            proto_item_append_text(parent_item," %s%s%s%s",
                 ((nlri_operator & BGPNLRI_FSPEC_AND_BIT) == 0) ? "|| " : "&& ",
                 ((nlri_operator & BGPNLRI_FSPEC_GREATER_THAN) == 0) ? "" : ">",
                 ((nlri_operator & BGPNLRI_FSPEC_LESS_THAN) == 0) ? "" : "<",
                 ((nlri_operator & BGPNLRI_FSPEC_EQUAL) == 0) ? "" : "=");
        }
        cursor_op_val++;  /* we manage this operator we move to the value */
        if (value_len == 2) {
            cursor_op_val++; /* tcp flags are coded over 2 bytes only the second one is significant, we move to second byte */
        }

        proto_tree_add_bitmask(parent_tree, tvb, offset+cursor_op_val, hf_bgp_flowspec_nlri_tcp_flags, ett_bgp_flow_spec_nlri_tcp, nlri_tcp_flags, ENC_NA);
        tcp_flags = tvb_get_guint8(tvb,offset+cursor_op_val);

        proto_item_append_text(parent_item," %s%s%s%s%s%s",
             ((tcp_flags & BGPNLRI_FSPEC_TH_URG) == 0) ? "" : "U",
             ((tcp_flags & BGPNLRI_FSPEC_TH_ACK) == 0) ? "" : "A",
             ((tcp_flags & BGPNLRI_FSPEC_TH_PUSH) == 0) ? "" : "P",
             ((tcp_flags & BGPNLRI_FSPEC_TH_RST) == 0) ? "" : "R",
             ((tcp_flags & BGPNLRI_FSPEC_TH_SYN) == 0) ? "" : "S",
             ((tcp_flags & BGPNLRI_FSPEC_TH_FIN) == 0) ? "" : "F");
        cursor_op_val = cursor_op_val + value_len;
    } while ((nlri_operator&BGPNLRI_FSPEC_END_OF_LST) == 0);
    proto_item_append_text(parent_item,")");
    return (cursor_op_val);
}
