decode_mp_next_hop_vpn_ipv4(tvbuff_t *tvb, proto_tree *tree, gint offset, packet_info *pinfo, wmem_strbuf_t *strbuf, gint nhlen)
{
    proto_item    *ti;
    const char    *rd_string;
    const guint8   rd_zero[] = {0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00 };

    switch (nhlen) {
        case (BGP_ROUTE_DISTINGUISHER_SIZE + FT_IPv4_LEN):
            rd_string = decode_bgp_rd(pinfo->pool, tvb, offset);
            ti = proto_tree_add_string(tree, hf_bgp_update_path_attribute_mp_reach_nlri_next_hop_rd, tvb, offset, BGP_ROUTE_DISTINGUISHER_SIZE, rd_string);
            if (tvb_memeql(tvb, offset, rd_zero, BGP_ROUTE_DISTINGUISHER_SIZE) != 0) {
                expert_add_info(pinfo, ti, &ei_bgp_next_hop_rd_nonzero);
            }
            wmem_strbuf_append_printf(strbuf, " RD=%s", rd_string);
            offset += BGP_ROUTE_DISTINGUISHER_SIZE;
            proto_tree_add_item(tree, hf_bgp_update_path_attribute_mp_reach_nlri_next_hop_ipv4, tvb, offset, FT_IPv4_LEN, ENC_BIG_ENDIAN);
            wmem_strbuf_append_printf(strbuf, " IPv4=%s", tvb_ip_to_str(pinfo->pool, tvb, offset));
            break;
        default:
            return 0;
    }
    return nhlen;
}
