decode_path_prefix6(proto_tree *tree, packet_info *pinfo, int hf_path_id, int hf_addr, tvbuff_t *tvb, gint offset,
               const char *tag)
{
    proto_tree          *prefix_tree;
    guint32 path_identifier;
    ws_in6_addr   addr;     /* IPv6 address                       */
    address             addr_str;
    int                 plen;     /* prefix length                      */
    int                 length;   /* number of octets needed for prefix */

    /* snarf length and prefix */
    path_identifier = tvb_get_ntohl(tvb, offset);
    plen = tvb_get_guint8(tvb, offset + 4);
    length = tvb_get_ipv6_addr_with_prefix_len(tvb, offset + 4 + 1, &addr, plen);
    if (length < 0) {
        proto_tree_add_expert_format(tree, pinfo, &ei_bgp_length_invalid, tvb, offset + 4, 1, "%s length %u invalid",
            tag, plen);
        return -1;
    }

    /* put prefix into protocol tree */
    set_address(&addr_str, AT_IPv6, 16, addr.bytes);
    prefix_tree = proto_tree_add_subtree_format(tree, tvb, offset,  4 + 1 + length,
                            ett_bgp_prefix, NULL, "%s/%u PathId %u ",
                            address_to_str(pinfo->pool, &addr_str), plen, path_identifier);

    proto_tree_add_item(prefix_tree, hf_path_id, tvb, offset, 4, ENC_BIG_ENDIAN);
    proto_tree_add_uint_format(prefix_tree, hf_bgp_prefix_length, tvb, offset + 4, 1, plen, "%s prefix length: %u",
        tag, plen);
    proto_tree_add_ipv6(prefix_tree, hf_addr, tvb, offset + 4 + 1, length, &addr);

    return(4 + 1 + length);
}
