decode_path_prefix4(proto_tree *tree, packet_info *pinfo, int hf_path_id, int hf_addr, tvbuff_t *tvb, gint offset,
                    const char *tag)
{
    proto_tree *prefix_tree;
    ws_in4_addr ip_addr; /* IP address                         */
    guint8 plen;         /* prefix length                      */
    int    length;       /* number of octets needed for prefix */
    guint32 path_identifier;
    address addr;

    /* snarf path identifier length and prefix */
    path_identifier = tvb_get_ntohl(tvb, offset);
    plen = tvb_get_guint8(tvb, offset + 4);
    length = tvb_get_ipv4_addr_with_prefix_len(tvb, offset + 4 + 1, &ip_addr, plen);
    if (length < 0) {
        proto_tree_add_expert_format(tree, pinfo, &ei_bgp_length_invalid, tvb, offset + 4 , 1, "%s length %u invalid (> 32)",
            tag, plen);
        return -1;
    }
    /* put prefix into protocol tree */
    set_address(&addr, AT_IPv4, 4, &ip_addr);
    prefix_tree = proto_tree_add_subtree_format(tree, tvb, offset,  4 + 1 + length,
                            ett_bgp_prefix, NULL, "%s/%u PathId %u ",
                            address_to_str(pinfo->pool, &addr), plen, path_identifier);
    proto_tree_add_item(prefix_tree, hf_path_id, tvb, offset, 4, ENC_BIG_ENDIAN);
    proto_tree_add_item(prefix_tree, hf_bgp_prefix_length, tvb, offset + 4, 1, ENC_BIG_ENDIAN);
    proto_tree_add_ipv4(prefix_tree, hf_addr, tvb, offset + 4 + 1, length, ip_addr);
    return(4 + 1 + length);
}
