DltReturnValue dlt_message_argument_print(DltMessage *msg,
                                          uint32_t type_info,
                                          uint8_t **ptr,
                                          int32_t *datalength,
                                          char *text,
                                          size_t textlength,
                                          int byteLength,
                                          int __attribute__((unused)) verbose)
{
    /* check null pointers */
    if ((msg == NULL) || (ptr == NULL) || (datalength == NULL) || (text == NULL))
        return DLT_RETURN_WRONG_PARAMETER;

    uint16_t length = 0, length2 = 0, length3 = 0;

    uint8_t value8u = 0;
    uint16_t value16u = 0, value16u_tmp = 0;
    uint32_t value32u = 0, value32u_tmp = 0;
    uint64_t value64u = 0, value64u_tmp = 0;

    int8_t value8i = 0;
    int16_t value16i = 0, value16i_tmp = 0;
    int32_t value32i = 0, value32i_tmp = 0;
    int64_t value64i = 0, value64i_tmp = 0;

    float32_t value32f = 0, value32f_tmp = 0;
    int32_t value32f_tmp_int32i = 0, value32f_tmp_int32i_swaped = 0;
    float64_t value64f = 0, value64f_tmp = 0;
    int64_t value64f_tmp_int64i = 0, value64f_tmp_int64i_swaped = 0;

    uint32_t quantisation_tmp = 0;

    // pointer to the value string
    char* value_text = text;
    // pointer to the "unit" attribute string, if there is one (only for *INT and FLOAT*)
    const uint8_t* unit_text_src = NULL;
    // length of the "unit" attribute string, if there is one (only for *INT and FLOAT*)
    size_t unit_text_len = 0;

    /* apparently this makes no sense but needs to be done to prevent compiler warning.
     * This variable is only written by DLT_MSG_READ_VALUE macro in if (type_info & DLT_TYPE_INFO_FIXP)
     * case but never read anywhere */
    quantisation_tmp += quantisation_tmp;

    if ((type_info & DLT_TYPE_INFO_STRG) &&
        (((type_info & DLT_TYPE_INFO_SCOD) == DLT_SCOD_ASCII) || ((type_info & DLT_TYPE_INFO_SCOD) == DLT_SCOD_UTF8))) {
        /* string type or utf8-encoded string type */
        if (byteLength < 0) {
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);
        }
        else {
            length = (uint16_t)byteLength;
        }

        if (type_info & DLT_TYPE_INFO_VARI) {
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

            if ((*datalength) < length2)
                return DLT_RETURN_ERROR;

            if (print_with_attributes) {
                // Print "name" attribute, if we have one with non-zero size.
                if (length2 > 1) {
                    snprintf(text, textlength, "%s:", *ptr);
                    value_text += length2+1-1;  // +1 for ":" and -1 for NUL
                    textlength -= length2+1-1;
                }
            }

            *ptr += length2;
            *datalength -= length2;
        }

        DLT_MSG_READ_STRING(value_text, *ptr, *datalength, textlength, length);

        if ((*datalength) < 0)
            return DLT_RETURN_ERROR;
    }
    else if (type_info & DLT_TYPE_INFO_BOOL)
    {
        /* Boolean type */
        if (type_info & DLT_TYPE_INFO_VARI) {
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

            if ((*datalength) < length2)
                return DLT_RETURN_ERROR;

            if (print_with_attributes) {
                // Print "name" attribute, if we have one with non-zero size.
                if (length2 > 1) {
                    snprintf(text, textlength, "%s:", *ptr);
                    value_text += length2+1-1;  // +1 for ":" and -1 for NUL
                    textlength -= length2+1-2;
                }
            }

            *ptr += length2;
            *datalength -= length2;
        }

        value8u = 0;
        DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */

        if ((*datalength) < 0)
            return DLT_RETURN_ERROR;

        snprintf(value_text, textlength, "%d", value8u);
    }
    else if ((type_info & DLT_TYPE_INFO_UINT) && (DLT_SCOD_BIN == (type_info & DLT_TYPE_INFO_SCOD)))
    {
        if (DLT_TYLE_8BIT == (type_info & DLT_TYPE_INFO_TYLE)) {
            DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            char binary[10] = { '\0' }; /* e.g.: "0b1100 0010" */
            int i;

            for (i = (1 << 7); i > 0; i >>= 1) {
                if ((1 << 3) == i)
                    strcat(binary, " ");

                strcat(binary, (i == (value8u & i)) ? "1" : "0");
            }

            snprintf(value_text, textlength, "0b%s", binary);
        }

        if (DLT_TYLE_16BIT == (type_info & DLT_TYPE_INFO_TYLE)) {
            DLT_MSG_READ_VALUE(value16u, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            char binary[20] = { '\0' }; /* e.g.: "0b1100 0010 0011 0110" */
            int i;

            for (i = (1 << 15); i > 0; i >>= 1) {
                if (((1 << 3) == i) || ((1 << 7) == i) || ((1 << 11) == i))
                    strcat(binary, " ");

                strcat(binary, (i == (value16u & i)) ? "1" : "0");
            }

            snprintf(value_text, textlength, "0b%s", binary);
        }
    }
    else if ((type_info & DLT_TYPE_INFO_UINT) && (DLT_SCOD_HEX == (type_info & DLT_TYPE_INFO_SCOD)))
    {
        if (DLT_TYLE_8BIT == (type_info & DLT_TYPE_INFO_TYLE)) {
            DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t); /* No endian conversion necessary */

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            snprintf(value_text, textlength, "0x%02x", value8u);
        }

        if (DLT_TYLE_16BIT == (type_info & DLT_TYPE_INFO_TYLE)) {
            DLT_MSG_READ_VALUE(value16u, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            snprintf(value_text, textlength, "0x%04x", value16u);
        }

        if (DLT_TYLE_32BIT == (type_info & DLT_TYPE_INFO_TYLE)) {
            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            snprintf(value_text, textlength, "0x%08x", value32u);
        }

        if (DLT_TYLE_64BIT == (type_info & DLT_TYPE_INFO_TYLE)) {
            *ptr += 4;
            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            snprintf(value_text, textlength, "0x%08x", value32u);
            *ptr -= 8;
            DLT_MSG_READ_VALUE(value32u, *ptr, *datalength, uint32_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            snprintf(value_text + strlen(value_text), textlength - strlen(value_text), "%08x", value32u);
            *ptr += 4;
        }
    }
    else if ((type_info & DLT_TYPE_INFO_SINT) || (type_info & DLT_TYPE_INFO_UINT))
    {
        /* signed or unsigned argument received */
        if (type_info & DLT_TYPE_INFO_VARI) {
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length2 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length3 = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

            if ((*datalength) < length2)
                return DLT_RETURN_ERROR;

            if (print_with_attributes) {
                // Print "name" attribute, if we have one with non-zero size.
                if (length2 > 1) {
                    snprintf(text, textlength, "%s:", *ptr);
                    value_text += length2+1-1;  // +1 for the ":", and -1 for nul
                    textlength -= length2+1-1;
                }
            }

            *ptr += length2;
            *datalength -= length2;

            if ((*datalength) < length3)
                return DLT_RETURN_ERROR;

            // We want to add the "unit" attribute only after the value, so remember its pointer and length here.
            unit_text_src = *ptr;
            unit_text_len = length3;

            *ptr += length3;
            *datalength -= length3;
        }

        if (type_info & DLT_TYPE_INFO_FIXP) {
            DLT_MSG_READ_VALUE(quantisation_tmp, *ptr, *datalength, uint32_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            switch (type_info & DLT_TYPE_INFO_TYLE) {
            case DLT_TYLE_8BIT:
            case DLT_TYLE_16BIT:
            case DLT_TYLE_32BIT:
            {
                if ((*datalength) < 4)
                    return DLT_RETURN_ERROR;

                *ptr += 4;
                *datalength -= 4;
                break;
            }
            case DLT_TYLE_64BIT:
            {
                if ((*datalength) < 8)
                    return DLT_RETURN_ERROR;

                *ptr += 8;
                *datalength -= 8;
                break;
            }
            case DLT_TYLE_128BIT:
            {
                if ((*datalength) < 16)
                    return DLT_RETURN_ERROR;

                *ptr += 16;
                *datalength -= 16;
                break;
            }
            default:
            {
                return DLT_RETURN_ERROR;
            }
            }
        }

        switch (type_info & DLT_TYPE_INFO_TYLE) {
        case DLT_TYLE_8BIT:
        {
            if (type_info & DLT_TYPE_INFO_SINT) {
                value8i = 0;
                DLT_MSG_READ_VALUE(value8i, *ptr, *datalength, int8_t);  /* No endian conversion necessary */

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                snprintf(value_text, textlength, "%d", value8i);
            }
            else {
                value8u = 0;
                DLT_MSG_READ_VALUE(value8u, *ptr, *datalength, uint8_t);  /* No endian conversion necessary */

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                snprintf(value_text, textlength, "%d", value8u);
            }

            break;
        }
        case DLT_TYLE_16BIT:
        {
            if (type_info & DLT_TYPE_INFO_SINT) {
                value16i = 0;
                value16i_tmp = 0;
                DLT_MSG_READ_VALUE(value16i_tmp, *ptr, *datalength, int16_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                value16i = (int16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16i_tmp);
                snprintf(value_text, textlength, "%hd", value16i);
            }
            else {
                value16u = 0;
                value16u_tmp = 0;
                DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                value16u = (uint16_t) DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);
                snprintf(value_text, textlength, "%hu", value16u);
            }

            break;
        }
        case DLT_TYLE_32BIT:
        {
            if (type_info & DLT_TYPE_INFO_SINT) {
                value32i = 0;
                value32i_tmp = 0;
                DLT_MSG_READ_VALUE(value32i_tmp, *ptr, *datalength, int32_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                value32i = (int32_t) DLT_ENDIAN_GET_32(msg->standardheader->htyp, (uint32_t)value32i_tmp);
                snprintf(value_text, textlength, "%d", value32i);
            }
            else {
                value32u = 0;
                value32u_tmp = 0;
                DLT_MSG_READ_VALUE(value32u_tmp, *ptr, *datalength, uint32_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                value32u = DLT_ENDIAN_GET_32(msg->standardheader->htyp, value32u_tmp);
                snprintf(value_text, textlength, "%u", value32u);
            }

            break;
        }
        case DLT_TYLE_64BIT:
        {
            if (type_info & DLT_TYPE_INFO_SINT) {
                value64i = 0;
                value64i_tmp = 0;
                DLT_MSG_READ_VALUE(value64i_tmp, *ptr, *datalength, int64_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                value64i = (int64_t) DLT_ENDIAN_GET_64(msg->standardheader->htyp, (uint64_t)value64i_tmp);
    #if defined (__WIN32__) && !defined(_MSC_VER)
                snprintf(value_text, textlength, "%I64d", value64i);
    #else
                snprintf(value_text, textlength, "%" PRId64, value64i);
    #endif
            }
            else {
                value64u = 0;
                value64u_tmp = 0;
                DLT_MSG_READ_VALUE(value64u_tmp, *ptr, *datalength, uint64_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                value64u = DLT_ENDIAN_GET_64(msg->standardheader->htyp, value64u_tmp);
    #if defined (__WIN32__) && !defined(_MSC_VER)
                snprintf(value_text, textlength, "%I64u", value64u);
    #else
                snprintf(value_text, textlength, "%" PRIu64, value64u);
    #endif
            }

            break;
        }
        case DLT_TYLE_128BIT:
        {
            if (*datalength >= 16)
                dlt_print_hex_string(value_text, (int) textlength, *ptr, 16);

            if ((*datalength) < 16)
                return DLT_RETURN_ERROR;

            *ptr += 16;
            *datalength -= 16;
            break;
        }
        default:
        {
            return DLT_RETURN_ERROR;
        }
        }
    }
    else if (type_info & DLT_TYPE_INFO_FLOA)
    {
        /* float data argument */
        if (type_info & DLT_TYPE_INFO_VARI) {
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length2 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length3 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

            if ((*datalength) < length2)
                return DLT_RETURN_ERROR;

            if (print_with_attributes) {
                // Print "name" attribute, if we have one with non-zero size.
                if (length2 > 1) {
                    snprintf(text, textlength, "%s:", *ptr);
                    value_text += length2+1-1;  // +1 for ":" and -1 for NUL
                    textlength -= length2+1-1;
                }
            }

            *ptr += length2;
            *datalength -= length2;

            if ((*datalength) < length3)
                return DLT_RETURN_ERROR;

            // We want to add the "unit" attribute only after the value, so remember its pointer and length here.
            unit_text_src = *ptr;
            unit_text_len = length3;

            *ptr += length3;
            *datalength -= length3;
        }

        switch (type_info & DLT_TYPE_INFO_TYLE) {
        case DLT_TYLE_8BIT:
        {
            if (*datalength >= 1)
                dlt_print_hex_string(value_text, (int) textlength, *ptr, 1);

            if ((*datalength) < 1)
                return DLT_RETURN_ERROR;

            *ptr += 1;
            *datalength -= 1;
            break;
        }
        case DLT_TYLE_16BIT:
        {
            if (*datalength >= 2)
                dlt_print_hex_string(value_text, (int) textlength, *ptr, 2);

            if ((*datalength) < 2)
                return DLT_RETURN_ERROR;

            *ptr += 2;
            *datalength -= 2;
            break;
        }
        case DLT_TYLE_32BIT:
        {
            if (sizeof(float32_t) == 4) {
                value32f = 0;
                value32f_tmp = 0;
                value32f_tmp_int32i = 0;
                value32f_tmp_int32i_swaped = 0;
                DLT_MSG_READ_VALUE(value32f_tmp, *ptr, *datalength, float32_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                memcpy(&value32f_tmp_int32i, &value32f_tmp, sizeof(float32_t));
                value32f_tmp_int32i_swaped =
                    (int32_t) DLT_ENDIAN_GET_32(msg->standardheader->htyp, (uint32_t)value32f_tmp_int32i);
                memcpy(&value32f, &value32f_tmp_int32i_swaped, sizeof(float32_t));
                snprintf(value_text, textlength, "%g", value32f);
            }
            else {
                dlt_log(LOG_ERR, "Invalid size of float32_t\n");
                return DLT_RETURN_ERROR;
            }

            break;
        }
        case DLT_TYLE_64BIT:
        {
            if (sizeof(float64_t) == 8) {
                value64f = 0;
                value64f_tmp = 0;
                value64f_tmp_int64i = 0;
                value64f_tmp_int64i_swaped = 0;
                DLT_MSG_READ_VALUE(value64f_tmp, *ptr, *datalength, float64_t);

                if ((*datalength) < 0)
                    return DLT_RETURN_ERROR;

                memcpy(&value64f_tmp_int64i, &value64f_tmp, sizeof(float64_t));
                value64f_tmp_int64i_swaped =
                    (int64_t) DLT_ENDIAN_GET_64(msg->standardheader->htyp, (uint64_t)value64f_tmp_int64i);
                memcpy(&value64f, &value64f_tmp_int64i_swaped, sizeof(float64_t));
#ifdef __arm__
                snprintf(value_text, textlength, "ILLEGAL");
#else
                snprintf(value_text, textlength, "%g", value64f);
#endif
            }
            else {
                dlt_log(LOG_ERR, "Invalid size of float64_t\n");
                return DLT_RETURN_ERROR;
            }

            break;
        }
        case DLT_TYLE_128BIT:
        {
            if (*datalength >= 16)
                dlt_print_hex_string(value_text, textlength, *ptr, 16);

            if ((*datalength) < 16)
                return DLT_RETURN_ERROR;

            *ptr += 16;
            *datalength -= 16;
            break;
        }
        default:
        {
            return DLT_RETURN_ERROR;
        }
        }
    }
    else if (type_info & DLT_TYPE_INFO_RAWD)
    {
        /* raw data argument */
        DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

        if ((*datalength) < 0)
            return DLT_RETURN_ERROR;

        length = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

        if (type_info & DLT_TYPE_INFO_VARI) {
            DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

            if ((*datalength) < 0)
                return DLT_RETURN_ERROR;

            length2 = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

            if ((*datalength) < length2)
                return DLT_RETURN_ERROR;

            if (print_with_attributes) {
                // Print "name" attribute, if we have one with non-zero size.
                if (length2 > 1) {
                    snprintf(text, textlength, "%s:", *ptr);
                    value_text += length2+1-1;  // +1 for ":" and -1 for NUL
                    textlength -= length2+1-1;
                }
            }

            *ptr += length2;
            *datalength -= length2;
        }

        if ((*datalength) < length)
            return DLT_RETURN_ERROR;

        if (dlt_print_hex_string_delim(value_text, (int) textlength, *ptr, length, '\'') < DLT_RETURN_OK)
            return DLT_RETURN_ERROR;
        *ptr += length;
        *datalength -= length;
    }
    else if (type_info & DLT_TYPE_INFO_TRAI)
    {
        /* trace info argument */
        DLT_MSG_READ_VALUE(value16u_tmp, *ptr, *datalength, uint16_t);

        if ((*datalength) < 0)
            return DLT_RETURN_ERROR;

        length = DLT_ENDIAN_GET_16(msg->standardheader->htyp, value16u_tmp);

        DLT_MSG_READ_STRING(value_text, *ptr, *datalength, textlength, length);

        if ((*datalength) < 0)
            return DLT_RETURN_ERROR;
    }
    else {
        return DLT_RETURN_ERROR;
    }

    if (*datalength < 0) {
        dlt_log(LOG_ERR, "Payload of DLT message corrupted\n");
        return DLT_RETURN_ERROR;
    }

    // Now write "unit" attribute, but only if it has more than only a nul-termination char.
    if (print_with_attributes) {
        if (unit_text_len > 1) {
            // 'value_text' still points to the +start+ of the value text
            size_t currLen = strlen(value_text);

            char* unitText = value_text + currLen;
            textlength -= currLen;
            snprintf(unitText, textlength, ":%s", unit_text_src);
        }
    }

    return DLT_RETURN_OK;
}
