int dlt_message_read(DltMessage *msg, uint8_t *buffer, unsigned int length, int resync, int verbose)
{
    uint32_t extra_size = 0;

    PRINT_FUNCTION_VERBOSE(verbose);

    if ((msg == NULL) || (buffer == NULL) || (length <= 0))
        return DLT_MESSAGE_ERROR_UNKNOWN;

    /* initialize resync_offset */
    msg->resync_offset = 0;

    /* check if message contains serial header, smaller than standard header */
    if (length < sizeof(dltSerialHeader))
        /* dlt_log(LOG_ERR, "Length smaller than serial header!\n"); */
        return DLT_MESSAGE_ERROR_SIZE;

    if (memcmp(buffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {
        /* serial header found */
        msg->found_serialheader = 1;
        buffer += sizeof(dltSerialHeader);
        length -= (unsigned int)sizeof(dltSerialHeader);
    }
    else {
        /* serial header not found */
        msg->found_serialheader = 0;

        if (resync) {
            /* resync if necessary */
            msg->resync_offset = 0;

            do {
                if (memcmp(buffer + msg->resync_offset, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {
                    /* serial header found */
                    msg->found_serialheader = 1;
                    buffer += sizeof(dltSerialHeader);
                    length -= (unsigned int)sizeof(dltSerialHeader);
                    break;
                }

                msg->resync_offset++;
            } while ((sizeof(dltSerialHeader) + (size_t)msg->resync_offset) <= length);

            /* Set new start offset */
            if (msg->resync_offset > 0) {
                /* Resyncing connection */
                buffer += msg->resync_offset;
                length -= (unsigned int)msg->resync_offset;
            }
        }
    }

    /* check that standard header fits buffer */
    if (length < sizeof(DltStandardHeader))
        /* dlt_log(LOG_ERR, "Length smaller than standard header!\n"); */
        return DLT_MESSAGE_ERROR_SIZE;

    memcpy(msg->headerbuffer + sizeof(DltStorageHeader), buffer, sizeof(DltStandardHeader));

    /* set ptrs to structures */
    msg->storageheader = (DltStorageHeader *)msg->headerbuffer;
    msg->standardheader = (DltStandardHeader *)(msg->headerbuffer + sizeof(DltStorageHeader));

    /* calculate complete size of headers */
    extra_size = (uint32_t) (DLT_STANDARD_HEADER_EXTRA_SIZE(msg->standardheader->htyp) +
        (DLT_IS_HTYP_UEH(msg->standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));
    msg->headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) + extra_size);
    msg->datasize = (uint32_t) DLT_BETOH_16(msg->standardheader->len) - msg->headersize + (uint32_t) sizeof(DltStorageHeader);

    /* calculate complete size of payload */
    int32_t temp_datasize;
    temp_datasize = DLT_BETOH_16(msg->standardheader->len) - (int32_t) msg->headersize + (int32_t) sizeof(DltStorageHeader);

    /* check data size */
    if (temp_datasize < 0) {
        dlt_vlog(LOG_WARNING,
                 "Plausibility check failed. Complete message size too short (%d)!\n",
                 temp_datasize);
        return DLT_MESSAGE_ERROR_CONTENT;
    }
    else {
        msg->datasize = (uint32_t) temp_datasize;
    }

    /* check if verbose mode is on*/
    if (verbose) {
        dlt_vlog(LOG_DEBUG, "BufferLength=%u, HeaderSize=%u, DataSize=%u\n",
                 length, msg->headersize, msg->datasize);
    }

    /* load standard header extra parameters and Extended header if used */
    if (extra_size > 0) {
        if (length < (msg->headersize - sizeof(DltStorageHeader)))
            return DLT_MESSAGE_ERROR_SIZE;

        memcpy(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader),
               buffer + sizeof(DltStandardHeader), (size_t)extra_size);

        /* set extended header ptr and get standard header extra parameters */
        if (DLT_IS_HTYP_UEH(msg->standardheader->htyp))
            msg->extendedheader =
                (DltExtendedHeader *)(msg->headerbuffer + sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +
                                      DLT_STANDARD_HEADER_EXTRA_SIZE(msg->standardheader->htyp));
        else
            msg->extendedheader = NULL;

        dlt_message_get_extraparameters(msg, verbose);
    }

    /* check if payload fits length */
    if (length < (msg->headersize - sizeof(DltStorageHeader) + msg->datasize))
        /* dlt_log(LOG_ERR,"length does not fit!\n"); */
        return DLT_MESSAGE_ERROR_SIZE;

    /* free last used memory for buffer */
    if (msg->databuffer) {
        if (msg->datasize > msg->databuffersize) {
            free(msg->databuffer);
            msg->databuffer = (uint8_t *)malloc(msg->datasize);
            msg->databuffersize = msg->datasize;
        }
    }
    else {
        /* get new memory for buffer */
        msg->databuffer = (uint8_t *)malloc(msg->datasize);
        msg->databuffersize = msg->datasize;
    }

    if (msg->databuffer == NULL) {
        dlt_vlog(LOG_WARNING,
                 "Cannot allocate memory for payload buffer of size %u!\n",
                 msg->datasize);
        return DLT_MESSAGE_ERROR_UNKNOWN;
    }

    /* load payload data from buffer */
    memcpy(msg->databuffer, buffer + (msg->headersize - sizeof(DltStorageHeader)), msg->datasize);

    return DLT_MESSAGE_ERROR_OK;
}
