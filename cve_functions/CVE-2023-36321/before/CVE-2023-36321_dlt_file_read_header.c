DltReturnValue dlt_file_read_header(DltFile *file, int verbose)
{
    PRINT_FUNCTION_VERBOSE(verbose);

    if (file == NULL)
        return DLT_RETURN_WRONG_PARAMETER;

    /* Loop until storage header is found */
    while (1) {
        /* load header from file */
        if (fread(file->msg.headerbuffer,
                  sizeof(DltStorageHeader) + sizeof(DltStandardHeader), 1,
                  file->handle) != 1) {
            if (!feof(file->handle))
                dlt_log(LOG_WARNING, "Cannot read header from file!\n");
            else
                dlt_log(LOG_DEBUG, "Reached end of file\n");

            return DLT_RETURN_ERROR;
        }

        /* set ptrs to structures */
        file->msg.storageheader = (DltStorageHeader *)file->msg.headerbuffer;
        file->msg.standardheader = (DltStandardHeader *)(file->msg.headerbuffer +
                                                         sizeof(DltStorageHeader));

        /* check id of storage header */
        if (dlt_check_storageheader(file->msg.storageheader) != DLT_RETURN_TRUE) {
            /* Shift the position back to the place where it stared to read + 1 */
            if (fseek(file->handle,
                      (long) (1 - (sizeof(DltStorageHeader) + sizeof(DltStandardHeader))),
                      SEEK_CUR) < 0) {
                dlt_log(LOG_WARNING, "DLT storage header pattern not found!\n");
                return DLT_RETURN_ERROR;
            }
        }
        else {
            /* storage header is found */
            break;
        }
    }

    /* calculate complete size of headers */
    file->msg.headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +
        DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp) +
        (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));

    /* calculate complete size of payload */
    int32_t temp_datasize;
    temp_datasize = DLT_BETOH_16(file->msg.standardheader->len) + (int32_t) sizeof(DltStorageHeader) - (int32_t) file->msg.headersize;

    /* check data size */
    if (temp_datasize < 0) {
        dlt_vlog(LOG_WARNING,
                 "Plausibility check failed. Complete message size too short! (%d)\n",
                 temp_datasize);
        return DLT_RETURN_ERROR;
    } else {
        file->msg.datasize = (uint32_t) temp_datasize;
    }

    /* check if verbose mode is on */
    if (verbose) {
        dlt_vlog(LOG_DEBUG, "HeaderSize=%u, DataSize=%u\n",
                 file->msg.headersize, file->msg.datasize);
    }

    return DLT_RETURN_OK;
}
