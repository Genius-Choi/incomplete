DltReturnValue dlt_file_read_raw(DltFile *file, int resync, int verbose)
{
    int found = DLT_RETURN_OK;
    long *ptr;

    if (verbose)
        dlt_vlog(LOG_DEBUG, "%s: Message %d:\n", __func__, file->counter_total);

    if (file == NULL)
        return DLT_RETURN_WRONG_PARAMETER;

    /* allocate new memory for index if number of messages exceeds a multiple of DLT_COMMON_INDEX_ALLOC (e.g.: 1000) */
    if (file->counter % DLT_COMMON_INDEX_ALLOC == 0) {
        ptr = (long *)malloc(((file->counter / DLT_COMMON_INDEX_ALLOC) + 1) * DLT_COMMON_INDEX_ALLOC * sizeof(long));

        if (ptr == NULL)
            return DLT_RETURN_ERROR;

        if (file->index) {
            memcpy(ptr, file->index, (size_t)(file->counter) * sizeof(long));
            free(file->index);
        }

        file->index = ptr;
    }

    /* set to end of last successful read message, because of conflicting calls to dlt_file_read and dlt_file_message */
    if (0 != fseek(file->handle, file->file_position, SEEK_SET))
        return DLT_RETURN_ERROR;

    /* get file position at start of DLT message */
    if (verbose)
        dlt_vlog(LOG_DEBUG, "Position in file: %" PRIu64 "\n", file->file_position);

    /* read header */
    if (dlt_file_read_header_raw(file, resync, verbose) < DLT_RETURN_OK) {
        /* go back to last position in file */
        if (0 != fseek(file->handle, file->file_position, SEEK_SET))
            dlt_log(LOG_WARNING, "dlt_file_read_raw, fseek failed 1\n");

        return DLT_RETURN_ERROR;
    }

    /* read the extended header if filter is enabled and extended header exists */
    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) {
        /* go back to last position in file */
        if (0 != fseek(file->handle, file->file_position, SEEK_SET))
            dlt_log(LOG_WARNING, "dlt_file_read_raw, fseek failed 2\n");

        return DLT_RETURN_ERROR;
    }

    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK) {
        /* go back to last position in file */
        if (0 != fseek(file->handle, file->file_position, SEEK_SET))
            dlt_log(LOG_WARNING, "dlt_file_read_raw, fseek failed 3\n");

        return DLT_RETURN_ERROR;
    }

    /* store index pointer to message position in DLT file */
    file->index[file->counter] = file->file_position;
    file->counter++;
    file->position = file->counter - 1;

    found = DLT_RETURN_TRUE;

    /* increase total message counter */
    file->counter_total++;

    /* store position to next message */
    file->file_position = ftell(file->handle);

    return found;
}
