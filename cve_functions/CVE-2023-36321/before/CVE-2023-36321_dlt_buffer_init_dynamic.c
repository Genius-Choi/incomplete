DltReturnValue dlt_buffer_init_dynamic(DltBuffer *buf, uint32_t min_size, uint32_t max_size, uint32_t step_size)
{
    /*Do not DLT_SEM_LOCK inside here! */
    DltBufferHead *head;

    /* catch null pointer */
    if (buf == NULL)
        return DLT_RETURN_WRONG_PARAMETER;

    /* catch 0 logical errors */
    if ((min_size == 0) || (max_size == 0) || (step_size == 0))
        return DLT_RETURN_WRONG_PARAMETER;

    if (min_size > max_size)
        return DLT_RETURN_WRONG_PARAMETER;

    if (step_size > max_size)
        return DLT_RETURN_WRONG_PARAMETER;

    /* Init parameters */
    buf->min_size = min_size;
    buf->max_size = max_size;
    buf->step_size = step_size;

    /* allocat memory */
    buf->shm = malloc(buf->min_size);

    if (buf->shm == NULL) {
        dlt_vlog(LOG_EMERG,
                 "%s: Buffer: Cannot allocate %u bytes\n",
                 __func__, buf->min_size);
        return DLT_RETURN_ERROR;
    }

    /* Init pointers */
    head = (DltBufferHead *)buf->shm;
    head->read = 0;
    head->write = 0;
    head->count = 0;
    buf->mem = (unsigned char *)(buf->shm + sizeof(DltBufferHead));

    if (buf->min_size < (uint32_t)sizeof(DltBufferHead)) {
        dlt_vlog(LOG_ERR,
                 "%s: min_size is too small [%u]\n",
                 __func__, buf->min_size);
        return DLT_RETURN_WRONG_PARAMETER;
    }

    buf->size = (uint32_t) (buf->min_size - sizeof(DltBufferHead));

    dlt_vlog(LOG_DEBUG,
             "%s: Buffer: Size %u, Start address %lX\n",
             __func__, buf->size, (unsigned long)buf->mem);

    /* clear memory */
    memset(buf->mem, 0, (size_t)buf->size);

    return DLT_RETURN_OK; /* OK */
}
