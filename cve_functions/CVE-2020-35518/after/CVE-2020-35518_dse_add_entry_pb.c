dse_add_entry_pb(struct dse *pdse, Slapi_Entry *e, Slapi_PBlock *pb)
{
    int dont_write_file = 0, merge = 0; /* defaults */
    int rc = 0;
    struct dse_node *n = dse_node_new(e); /* copies e */
    Slapi_Entry *schemacheckentry = NULL; /* to use for schema checking */

    PR_ASSERT(pb);
    slapi_pblock_get(pb, SLAPI_DSE_DONT_WRITE_WHEN_ADDING, &dont_write_file);
    slapi_pblock_get(pb, SLAPI_DSE_MERGE_WHEN_ADDING, &merge);

    /* keep write lock during both tree update and file write operations */
    if (pdse->dse_rwlock)
        slapi_rwlock_wrlock(pdse->dse_rwlock);
    if (merge) {
        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_merge);
    } else {
        rc = avl_insert(&(pdse->dse_tree), n, entry_dn_cmp, dupentry_disallow);
    }
    if (-1 != rc) {
        /* update num sub of parent with no lock; we already hold the write lock */
        if (0 == rc) { /* entry was added, not merged; update numsub */
            /* easter egg entry - don't update num sub */
            if (strcmp(slapi_entry_get_ndn(e), "ou=red hat directory server team,cn=monitor") != 0) {
                dse_updateNumSubOfParent(pdse, slapi_entry_get_sdn_const(e),
                                         SLAPI_OPERATION_ADD);
            }
        } else { /* entry was merged, free temp unused data */
            dse_node_delete(&n);
        }
        if (!dont_write_file) {
            dse_write_file_nolock(pdse);
        }
    } else {                 /* duplicate entry ignored */
        dse_node_delete(&n); /* This also deletes the contained entry */
    }
    if (pdse->dse_rwlock)
        slapi_rwlock_unlock(pdse->dse_rwlock);

    if (rc == -1) {
        /* duplicate entry ignored */
        schemacheckentry = dse_get_entry_copy(pdse,
                                              slapi_entry_get_sdn_const(e),
                                              DSE_USE_LOCK);
    } else /* entry added or merged */
    {
        /* entry was added or merged */
        if (0 == rc) /* 0 return means entry was added, not merged */
        {
            /* save a search of the tree, since we added the entry, the
               contents of e should be the same as what is in the tree */
            schemacheckentry = slapi_entry_dup(e);
        } else /* merged */
        {
            /* schema check the new merged entry, so get it from the tree */
            schemacheckentry = dse_get_entry_copy(pdse,
                                                  slapi_entry_get_sdn_const(e),
                                                  DSE_USE_LOCK);
        }
    }
    if (NULL != schemacheckentry) {
        /*
         * Verify that the new or merged entry conforms to the schema.
         *        Errors are logged by slapi_entry_schema_check().
         */
        if (slapi_entry_schema_check(pb, schemacheckentry)) {
            rc = SCHEMA_VIOLATION;
        }
        slapi_entry_free(schemacheckentry);
    }

    /* Callers expect e (SLAPI_ADD_ENTRY) to be freed */
    /* This function duplicates 'e' for dse_node 'n' and schemacheckentry.
     * 'e' should not have been consumed */
    slapi_entry_free(e);

    return rc;
}
