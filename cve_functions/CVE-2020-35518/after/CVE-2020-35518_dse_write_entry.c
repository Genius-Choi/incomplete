dse_write_entry(caddr_t data, caddr_t arg)
{
    struct dse_node *n = (struct dse_node *)data;
    FPWrapper *fpw = (FPWrapper *)arg;
    char *s;
    PRInt32 len;

    if (NULL != n && NULL != n->entry) {
        int returncode;
        char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = "";
        /* need to make a duplicate here for two reasons:
           1) we don't want to hold on to the raw data in the node for any longer
           than we have to; we will usually be inside the dse write lock, but . . .
           2) the write callback may modify the entry, so we want to pass it a
           writeable copy rather than the raw avl tree data pointer
        */
        Slapi_Entry *ec = slapi_entry_dup(n->entry);
        if (dse_call_callback(fpw->fpw_pdse, NULL, DSE_OPERATION_WRITE,
                              DSE_FLAG_PREOP, ec, NULL, &returncode, returntext) == SLAPI_DSE_CALLBACK_OK) {
            /*
             * 3-August-2000 mcs: We used to pass the SLAPI_DUMP_NOOPATTRS
             * option to slapi_entry2str_with_options() so that operational
             * attributes were NOT stored in the DSE LDIF files.  But now
             * we store all attribute types.
             */
            if ((s = slapi_entry2str_with_options(ec, &len, 0)) != NULL) {
                if (slapi_write_buffer(fpw->fpw_prfd, s, len) != len) {
                    fpw->fpw_rc = PR_GetOSError();
                    ;
                    slapi_ch_free((void **)&s);
                    return STOP_TRAVERSAL;
                }
                if (slapi_write_buffer(fpw->fpw_prfd, "\n", 1) != 1) {
                    fpw->fpw_rc = PR_GetOSError();
                    ;
                    slapi_ch_free((void **)&s);
                    return STOP_TRAVERSAL;
                }
                slapi_ch_free((void **)&s);
            }
        }
        slapi_entry_free(ec);
    }
    return 0;
}
