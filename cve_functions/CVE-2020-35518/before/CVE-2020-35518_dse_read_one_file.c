dse_read_one_file(struct dse *pdse, const char *filename, Slapi_PBlock *pb, int primary_file)
{
    Slapi_Entry *e = NULL;
    char *entrystr = NULL;
    char *buf = NULL;
    char *lastp = NULL;
    int rc = 0; /* Fail */
    PRInt32 nr = 0;
    PRFileInfo64 prfinfo;
    PRFileDesc *prfd = 0;
    int schema_flags = 0;

    slapi_pblock_get(pb, SLAPI_SCHEMA_FLAGS, &schema_flags);

    if ((NULL != pdse) && (NULL != filename)) {
        /* check if the "real" file exists and cam be used, if not try tmp as backup */
        rc = dse_check_file((char *)filename, pdse->dse_tmpfile);
        if (!rc) {
            rc = dse_check_file((char *)filename, pdse->dse_fileback);
        }

        if ((rc = PR_GetFileInfo64(filename, &prfinfo)) != PR_SUCCESS) {
            slapi_log_err(SLAPI_LOG_ERR, "dse_read_one_file",
                          "The configuration file %s could not be accessed, error %d\n",
                          filename, rc);
            rc = 0; /* Fail */
        } else if ((prfd = PR_Open(filename, PR_RDONLY, SLAPD_DEFAULT_FILE_MODE)) == NULL) {
            slapi_log_err(SLAPI_LOG_ERR, "dse_read_one_file",
                          "The configuration file %s could not be read. " SLAPI_COMPONENT_NAME_NSPR " %d (%s)\n",
                          filename,
                          PR_GetError(), slapd_pr_strerror(PR_GetError()));
            rc = 0; /* Fail */
        } else {
            int done = 0;
            /* read the entire file into core */
            buf = slapi_ch_malloc(prfinfo.size + 1);
            if ((nr = slapi_read_buffer(prfd, buf, prfinfo.size)) < 0) {
                slapi_log_err(SLAPI_LOG_ERR, "dse_read_one_file",
                              "Could only read %d of %ld bytes from config file %s\n",
                              nr, (long int)prfinfo.size, filename);
                rc = 0; /* Fail */
                done = 1;
            }

            (void)PR_Close(prfd);
            buf[nr] = '\0';

            if (!done) {
                int lineno = 1;
                int lines = 0;
                int dont_check_dups = 0;
                int str2entry_flags = SLAPI_STR2ENTRY_EXPAND_OBJECTCLASSES |
                                      SLAPI_STR2ENTRY_NOT_WELL_FORMED_LDIF;
                if (schema_flags & DSE_SCHEMA_LOCKED)
                    str2entry_flags |= SLAPI_STR2ENTRY_NO_SCHEMA_LOCK;

                PR_ASSERT(pb);
                slapi_pblock_get(pb, SLAPI_DSE_DONT_CHECK_DUPS, &dont_check_dups);
                if (!dont_check_dups) {
                    str2entry_flags |= SLAPI_STR2ENTRY_REMOVEDUPVALS;
                }

                /* Convert LDIF to entry structures */
                rc = 1; /* assume we will succeed */
                while ((entrystr = dse_read_next_entry(buf, &lastp)) != NULL) {
                    char *p, *q;
                    char errbuf[256];
                    size_t estrlen = strlen(entrystr);
                    size_t cpylen =
                        (estrlen < sizeof(errbuf)) ? estrlen : sizeof(errbuf) - 1;

                    memcpy(errbuf, entrystr, cpylen);
                    errbuf[cpylen] = '\0';

                    lines = 1;
                    p = entrystr;
                    while ((q = strchr(p, '\n'))) {
                        p = q + 1;
                        lines++;
                    }

                    e = slapi_str2entry(entrystr, str2entry_flags);
                    if (e != NULL) {
                        int returncode = 0;
                        char returntext[SLAPI_DSE_RETURNTEXT_SIZE] = {0};

                        slapi_log_err(SLAPI_LOG_TRACE, "dse_read_one_file",
                                      " processing entry \"%s\" in file %s%s "
                                      "(lineno: %d)\n",
                                      slapi_entry_get_dn_const(e), filename,
                                      primary_file ? " (primary file)" : "",
                                      lineno);

                        /* remove the numsubordinates attr, which may be bogus */
                        slapi_entry_attr_delete(e, subordinatecount);

                        /* set the "primary file" flag if appropriate */
                        slapi_pblock_set(pb, SLAPI_DSE_IS_PRIMARY_FILE, &primary_file);
                        if (dse_call_callback(pdse, pb, DSE_OPERATION_READ,
                                              DSE_FLAG_PREOP, e, NULL, &returncode,
                                              returntext) == SLAPI_DSE_CALLBACK_OK) {
                            /*
                             * This will free the entry if not added, so it is
                             * definitely consumed by this call
                             */
                            if (dse_add_entry_pb(pdse, e, pb) == SCHEMA_VIOLATION) {
                                /* schema violation, return failure */
                                rc = 0;
                            }
                        } else /* free entry if not used */
                        {
                            slapi_log_err(SLAPI_LOG_FATAL,
                                          "dse_read_one_file",
                                          "The entry %s in file %s "
                                          "(lineno: %d) is invalid, "
                                          "error code %d (%s) - %s\n",
                                          slapi_entry_get_dn_const(e),
                                          filename, lineno, returncode,
                                          ldap_err2string(returncode),
                                          returntext);
                            slapi_entry_free(e);
                            rc = 0; /* failure */
                        }
                    } else {
                        slapi_log_err(SLAPI_LOG_ERR, "dse_read_one_file",
                                      "Parsing entry (lineno: %d) "
                                      "in file %s failed.\n",
                                      lineno, filename);
                        slapi_log_err(SLAPI_LOG_ERR, "dse_read_one_file",
                                      "Invalid section [%s%s]\n",
                                      errbuf, cpylen == estrlen ? "" : " ...");
                        rc = 0; /* failure */
                    }
                    lineno += lines + 1 /* 1 is for a blank line. */;
                }
            }
            slapi_ch_free((void **)&buf);
        }
    }

    return rc;
}
