decompress_r2007 (BITCODE_RC *restrict dst, const unsigned dst_size,
                  BITCODE_RC *restrict src, const unsigned src_size,
                  const BITCODE_RC *restrict dst_end)
{
  uint32_t length = 0;
  uint32_t offset = 0;

  BITCODE_RC *dst_start = dst;
  BITCODE_RC *src_end = src + src_size;
  unsigned char opcode;
  if (!dst_end)
    dst_end = dst + dst_size;

  LOG_INSANE ("decompress_r2007 (%p, %d, %p, %d)\n", dst, dst_size, src,
              src_size);
  if (!dst || !src || !dst_size || src_size < 2)
    {
      LOG_ERROR ("Invalid argument to %s\n", __FUNCTION__);
      return DWG_ERR_INTERNALERROR;
    }

  opcode = *src++;
  if ((opcode & 0xf0) == 0x20)
    {
      src += 2;
      length = *src++ & 0x07;
      if (length == 0)
        {
          LOG_ERROR ("Decompression error: zero length")
          return DWG_ERR_INTERNALERROR;
        }
    }

  while (src < src_end)
    {
      if (length == 0)
        length = read_literal_length (&src, opcode);

      if ((dst + length) > dst_end || (src + length) > src_end)
        {
          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
            {
              if ((dst + length) > dst_end)
                HANDLER (OUTPUT, "copy_compressed_bytes: dst %p + %u >= %p\n",
                         dst, (unsigned)length, dst_end);
              else
                HANDLER (OUTPUT, "copy_compressed_bytes: src %p + %u > %p\n",
                         src, (unsigned)length, src_end);
            }
          LOG_ERROR ("Decompression error: length overflow");
          return DWG_ERR_INTERNALERROR;
        }

      LOG_INSANE (
          "copy_compressed_bytes (%p, %p, %u). remaining src: %ld, dst: %ld\n",
          dst, src, (unsigned)length, (long)(src_end - src),
          (long)(dst_end - dst));
      copy_compressed_bytes (dst, src, length);

      dst += length;
      src += length;

      length = 0;

      if (src >= src_end)
        return 0;

      opcode = *src++;

      read_instructions (&src, &opcode, &offset, &length);

      while (1)
        {
          if ((dst + length) > dst_end)
            {
              LOG_HANDLE ("copy_bytes: dst %p + %u > %p\n", dst,
                          (unsigned)length, dst_end);
              LOG_ERROR ("Decompression error: length overflow");
              return DWG_ERR_INTERNALERROR;
            }
          if (offset > (uint32_t)(dst - dst_start))
            {
              LOG_HANDLE ("copy_bytes: offset %u > %p - %p\n",
                          (unsigned)offset, dst, dst_start);
              LOG_ERROR ("Decompression error: offset underflow");
              return DWG_ERR_INTERNALERROR;
            }
          LOG_INSANE ("copy_bytes (%p, %u, [%u])\n", dst, (unsigned)length,
                      (unsigned)offset);
          copy_bytes (dst, length, offset);

          dst += length;
          length = (opcode & 7);

          if (length != 0 || src >= src_end)
            break;

          opcode = *src++;

          if ((opcode >> 4) == 0)
            break;

          if ((opcode >> 4) == 0x0f)
            opcode &= 0xf;

          read_instructions ((unsigned char **)&src, &opcode, &offset,
                             &length);
        }
    }
  return 0;
}
