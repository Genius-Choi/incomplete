read_data_page (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,
                int64_t page_size, int64_t size_comp, int64_t size_uncomp,
                BITCODE_RC *restrict decomp_end)
{
  int i;
  int error = 0;

  int64_t pesize;      // Pre RS encoded size
  int64_t block_count; // Number of RS encoded blocks

  BITCODE_RC *rsdata; // RS encoded data
  BITCODE_RC *pedata; // Pre RS encoded data
  long pedata_size;

  // Round to a multiple of 8
  pesize = ((size_comp + 7) & ~7);
  block_count = (pesize + 0xFB - 1) / 0xFB;
  pedata_size = block_count * 0xFB;

  rsdata = (BITCODE_RC *)calloc (1, page_size);
  if (rsdata == NULL)
    {
      LOG_ERROR ("Out of memory")
      return DWG_ERR_OUTOFMEM;
    }
  bit_read_fixed (dat, rsdata, page_size);
  pedata = decode_rs (rsdata, block_count, 0xFB, page_size);
  if (!pedata)
    {
      free (rsdata);
      return DWG_ERR_OUTOFMEM;
    }

  if (size_comp < size_uncomp)
    error = decompress_r2007 (decomp, size_uncomp, pedata,
                              MIN (pedata_size, size_comp), decomp_end);
  else
    {
      if (decomp + size_uncomp <= decomp_end)
        memcpy (decomp, pedata, size_uncomp);
      else
        {
          LOG_ERROR ("decomp overflow")
          free (pedata);
          return DWG_ERR_INTERNALERROR;
        }
    }

  free (pedata);
  free (rsdata);

  return error;
}
