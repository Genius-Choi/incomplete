static JSValue js_float_env_setPrec(JSContext *ctx,
                                    JSValueConst this_val,
                                    int argc, JSValueConst *argv)
{
    JSValueConst func;
    int exp_bits, flags, saved_flags;
    JSValue ret;
    limb_t saved_prec;
    int64_t prec;

    func = argv[0];
    if (JS_ToInt64Sat(ctx, &prec, argv[1]))
        return JS_EXCEPTION;
    if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
        return JS_ThrowRangeError(ctx, "invalid precision");
    exp_bits = BF_EXP_BITS_MAX;

    if (argc > 2 && !JS_IsUndefined(argv[2])) {
        if (JS_ToInt32Sat(ctx, &exp_bits, argv[2]))
            return JS_EXCEPTION;
        if (exp_bits < BF_EXP_BITS_MIN || exp_bits > BF_EXP_BITS_MAX)
            return JS_ThrowRangeError(ctx, "invalid number of exponent bits");
    }

    flags = BF_RNDN | BF_FLAG_SUBNORMAL | bf_set_exp_bits(exp_bits);

    saved_prec = ctx->fp_env.prec;
    saved_flags = ctx->fp_env.flags;

    ctx->fp_env.prec = prec;
    ctx->fp_env.flags = flags;

    ret = JS_Call(ctx, func, JS_UNDEFINED, 0, NULL);
    /* always restore the floating point precision */
    ctx->fp_env.prec = saved_prec;
    ctx->fp_env.flags = saved_flags;
    return ret;
}
