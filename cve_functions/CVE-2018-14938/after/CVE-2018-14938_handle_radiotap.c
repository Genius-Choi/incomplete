void WifiPacket::handle_radiotap(const u_char *p,size_t caplen)
{
#define	BITNO_32(x) (((x) >> 16) ? 16 + BITNO_16((x) >> 16) : BITNO_16((x)))
#define	BITNO_16(x) (((x) >> 8) ? 8 + BITNO_8((x) >> 8) : BITNO_8((x)))
#define	BITNO_8(x) (((x) >> 4) ? 4 + BITNO_4((x) >> 4) : BITNO_4((x)))
#define	BITNO_4(x) (((x) >> 2) ? 2 + BITNO_2((x) >> 2) : BITNO_2((x)))
#define	BITNO_2(x) (((x) & 2) ? 1 : 0)
#define	BIT(n)	(1 << n)
#define	IS_EXTENDED(__p) (EXTRACT_LE_32BITS(__p) & BIT(IEEE80211_RADIOTAP_EXT)) != 0

    // If caplen is too small, just give it a try and carry on.
    if (caplen < sizeof(struct ieee80211_radiotap_header)) {
        cbs->HandleRadiotap( *this, NULL, p, caplen);
        return;
    }

    struct ieee80211_radiotap_header *hdr = (struct ieee80211_radiotap_header *)p;

    size_t len = EXTRACT_LE_16BITS(&hdr->it_len); // length of radiotap header

    if (caplen < len) {
        //printf("[|802.11]");
        cbs->HandleRadiotap( *this, NULL, p, caplen);
        return;// caplen;
    }
    uint32_t *last_presentp=0;
    for (last_presentp = &hdr->it_present;
         IS_EXTENDED(last_presentp) && (u_char*)(last_presentp + 1) <= p + len;
         last_presentp++){
    }

    /* are there more bitmap extensions than bytes in header? */
    if (IS_EXTENDED(last_presentp)) {
        //printf("[|802.11]");
        cbs->HandleRadiotap( *this, NULL, p, caplen);
        return;// caplen;
    }

    const u_char *iter = (u_char*)(last_presentp + 1);
    struct cpack_state cpacker;
    if (cpack_init(&cpacker, (u_int8_t*)iter, len - (iter - p)) != 0) {
        /* XXX */
        //printf("[|802.11]");
        cbs->HandleRadiotap( *this, NULL, p, caplen);
        return;// caplen;
    }

    radiotap_hdr ohdr;
    memset(&ohdr, 0, sizeof(ohdr));
	
    /* Assume no Atheros padding between 802.11 header and body */
    int pad = 0;
    uint32_t *presentp;
    int bit0=0;
    for (bit0 = 0, presentp = &hdr->it_present; presentp <= last_presentp;
         presentp++, bit0 += 32) {

        u_int32_t present, next_present;
        for (present = EXTRACT_LE_32BITS(presentp); present;
             present = next_present) {
            /* clear the least significant bit that is set */
            next_present = present & (present - 1);

            /* extract the least significant bit that is set */
            enum ieee80211_radiotap_type bit = (enum ieee80211_radiotap_type)
                (bit0 + BITNO_32(present ^ next_present));

            /* print the next radiotap field */
            int r = print_radiotap_field(&cpacker, bit, &pad, &ohdr);

            /* If we got an error, break both loops */
            if(r!=0) goto done;
        }
    }
done:;
    cbs->HandleRadiotap( *this, &ohdr, p, caplen);
    //return len + ieee802_11_print(p + len, length - len, caplen - len, pad);
#undef BITNO_32
#undef BITNO_16
#undef BITNO_8
#undef BITNO_4
#undef BITNO_2
#undef BIT
    handle_80211(p+len, caplen-len);
}
