static void cmd_anal_blocks(RCore *core, const char *input) {
	ut64 from , to;
	char *arg = strchr (input, ' ');
	r_cons_break_push (NULL, NULL);
#if 0
	ls_foreach (core->io->sections, iter, s) {
		/* is executable */
		if (!(s->flags & R_IO_EXEC)) {
			continue;
		}
		min = s->vaddr;
		max = s->vaddr + s->vsize;
		r_core_cmdf (core, "abb%s 0x%08"PFMT64x" @ 0x%08"PFMT64x, input, (max - min), min);
		if (r_cons_is_breaked ()) {
			goto ctrl_c;
		}
	}
	if (ls_empty (core->io->sections)) {
		min = core->offset;
		max = 0xffff + min;
		r_core_cmdf (core, "abb%s 0x%08"PFMT64x" @ 0x%08"PFMT64x, input, (max - min), min);
		if (r_cons_is_breaked ()) {
			goto ctrl_c;
		}
	}
#endif
	if (!arg) {
		RList *list = r_core_get_boundaries_prot (core, R_IO_EXEC, NULL, "anal");
		RListIter *iter;
		RIOMap* map;
		r_list_foreach (list, iter, map) {
			from = map->itv.addr;
			to = r_itv_end (map->itv);
			if (r_cons_is_breaked ()) {
				goto ctrl_c;
			}
			if (!from && !to) {
				eprintf ("Cannot determine search boundaries\n");
			} else if (to - from > UT32_MAX) {
				eprintf ("Skipping huge range\n");
			} else {
				r_core_cmdf (core, "abb 0x%08"PFMT64x" @ 0x%08"PFMT64x, (to - from), from);
			}
		}
	} else {
		int sz = r_num_math (core->num, arg + 1);
		r_core_cmdf (core, "abb 0x%08"PFMT64x" @ 0x%08"PFMT64x, sz, core->offset);
	}
ctrl_c:
	r_cons_break_pop ();
}
