S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state,
                         regnode *node, I32* flagp, STRLEN len, UV code_point,
                         bool downgradable)
{
    /* This knows the details about sizing an EXACTish node, setting flags for
     * it (by setting <*flagp>, and potentially populating it with a single
     * character.
     *
     * If <len> (the length in bytes) is non-zero, this function assumes that
     * the node has already been populated, and just does the sizing.  In this
     * case <code_point> should be the final code point that has already been
     * placed into the node.  This value will be ignored except that under some
     * circumstances <*flagp> is set based on it.
     *
     * If <len> is zero, the function assumes that the node is to contain only
     * the single character given by <code_point> and calculates what <len>
     * should be.  In pass 1, it sizes the node appropriately.  In pass 2, it
     * additionally will populate the node's STRING with <code_point> or its
     * fold if folding.
     *
     * In both cases <*flagp> is appropriately set
     *
     * It knows that under FOLD, the Latin Sharp S and UTF characters above
     * 255, must be folded (the former only when the rules indicate it can
     * match 'ss')
     *
     * When it does the populating, it looks at the flag 'downgradable'.  If
     * true with a node that folds, it checks if the single code point
     * participates in a fold, and if not downgrades the node to an EXACT.
     * This helps the optimizer */

    bool len_passed_in = cBOOL(len != 0);
    U8 character[UTF8_MAXBYTES_CASE+1];

    PERL_ARGS_ASSERT_ALLOC_MAYBE_POPULATE_EXACT;

    /* Don't bother to check for downgrading in PASS1, as it doesn't make any
     * sizing difference, and is extra work that is thrown away */
    if (downgradable && ! PASS2) {
        downgradable = FALSE;
    }

    if (! len_passed_in) {
        if (UTF) {
            if (UVCHR_IS_INVARIANT(code_point)) {
                if (LOC || ! FOLD) {    /* /l defers folding until runtime */
                    *character = (U8) code_point;
                }
                else { /* Here is /i and not /l. (toFOLD() is defined on just
                          ASCII, which isn't the same thing as INVARIANT on
                          EBCDIC, but it works there, as the extra invariants
                          fold to themselves) */
                    *character = toFOLD((U8) code_point);

                    /* We can downgrade to an EXACT node if this character
                     * isn't a folding one.  Note that this assumes that
                     * nothing above Latin1 folds to some other invariant than
                     * one of these alphabetics; otherwise we would also have
                     * to check:
                     *  && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)
                     *      || ASCII_FOLD_RESTRICTED))
                     */
                    if (downgradable && PL_fold[code_point] == code_point) {
                        OP(node) = EXACT;
                    }
                }
                len = 1;
            }
            else if (FOLD && (! LOC
                              || ! is_PROBLEMATIC_LOCALE_FOLD_cp(code_point)))
            {   /* Folding, and ok to do so now */
                UV folded = _to_uni_fold_flags(
                                   code_point,
                                   character,
                                   &len,
                                   FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                                      ? FOLD_FLAGS_NOMIX_ASCII
                                                      : 0));
                if (downgradable
                    && folded == code_point /* This quickly rules out many
                                               cases, avoiding the
                                               _invlist_contains_cp() overhead
                                               for those.  */
                    && ! _invlist_contains_cp(PL_utf8_foldable, code_point))
                {
                    OP(node) = (LOC)
                               ? EXACTL
                               : EXACT;
                }
            }
            else if (code_point <= MAX_UTF8_TWO_BYTE) {

                /* Not folding this cp, and can output it directly */
                *character = UTF8_TWO_BYTE_HI(code_point);
                *(character + 1) = UTF8_TWO_BYTE_LO(code_point);
                len = 2;
            }
            else {
                uvchr_to_utf8( character, code_point);
                len = UTF8SKIP(character);
            }
        } /* Else pattern isn't UTF8.  */
        else if (! FOLD) {
            *character = (U8) code_point;
            len = 1;
        } /* Else is folded non-UTF8 */
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
        else if (LIKELY(code_point != LATIN_SMALL_LETTER_SHARP_S)) {
#else
        else if (1) {
#endif
            /* We don't fold any non-UTF8 except possibly the Sharp s  (see
             * comments at join_exact()); */
            *character = (U8) code_point;
            len = 1;

            /* Can turn into an EXACT node if we know the fold at compile time,
             * and it folds to itself and doesn't particpate in other folds */
            if (downgradable
                && ! LOC
                && PL_fold_latin1[code_point] == code_point
                && (! HAS_NONLATIN1_FOLD_CLOSURE(code_point)
                    || (isASCII(code_point) && ASCII_FOLD_RESTRICTED)))
            {
                OP(node) = EXACT;
            }
        } /* else is Sharp s.  May need to fold it */
        else if (AT_LEAST_UNI_SEMANTICS && ! ASCII_FOLD_RESTRICTED) {
            *character = 's';
            *(character + 1) = 's';
            len = 2;
        }
        else {
            *character = LATIN_SMALL_LETTER_SHARP_S;
            len = 1;
        }
    }

    if (SIZE_ONLY) {
        RExC_size += STR_SZ(len);
    }
    else {
        RExC_emit += STR_SZ(len);
        STR_LEN(node) = len;
        if (! len_passed_in) {
            Copy((char *) character, STRING(node), len, char);
        }
    }

    *flagp |= HASWIDTH;

    /* A single character node is SIMPLE, except for the special-cased SHARP S
     * under /di. */
    if ((len == 1 || (UTF && len == UVCHR_SKIP(code_point)))
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
        && ( code_point != LATIN_SMALL_LETTER_SHARP_S
            || ! FOLD || ! DEPENDS_SEMANTICS)
#endif
    ) {
        *flagp |= SIMPLE;
    }

    /* The OP may not be well defined in PASS1 */
    if (PASS2 && OP(node) == EXACTFL) {
        RExC_contains_locale = 1;
    }
}
