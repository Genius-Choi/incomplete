static void cmd_print_fromage(RCore *core, const char *input, const ut8* data, int size) {
	switch (*input) {
	case 'a': // "pFa" // DER/ASN1 encoding
		{
			int fmt = input[1];
			RAsn1 *a = r_asn1_new (data, size, fmt);
			// RASN1Object *asn1 = r_asn1_object_parse (data, data, size, fmt);
			if (a) {
				char *res = r_asn1_tostring (a);
				// char *res = r_asn1_object_tostring (asn1, 0, NULL, fmt);
				r_asn1_free (a);
				if (res) {
					r_cons_printf ("%s\n", res);
					free (res);
				}
			} else {
				R_LOG_ERROR ("Malformed object: did you supply enough data? try to change the block size (see b?)");
			}
		}
		break;
	case 'X': // "pFX" un-xz
		{
			size_t out_len = 0;
			ut8 *out = r_sys_unxz (data, size, &out_len);
			if (out) {
				r_cons_write ((const char *)out, out_len);
				free (out);
			}
		}
		break;
	case 'x': // "pFx" x509
		{
			ut8 *buf = (ut8*)data;
			RASN1Object *obj = r_asn1_object_parse (buf, buf, size, input[1]);
			if (!obj) {
				R_LOG_ERROR ("cannot parse asn1 object");
				break;
			}
			RX509Certificate* x509 = r_x509_parse_certificate (obj);
			if (x509) {
				if (input[1] == 'j') { // "pFxj"
					PJ *pj = r_core_pj_new (core);
					r_x509_certificate_json (pj, x509);
					char *res = pj_drain (pj);
					if (res) {
						r_cons_printf ("%s\n", res);
						free (res);
					}
				} else {
					RStrBuf *sb = r_strbuf_new ("");
					r_x509_certificate_dump (x509, NULL, sb);
					char *res = r_strbuf_drain (sb);
					if (res) {
						r_cons_printf ("%s\n", res);
						free (res);
					}
				}
				r_x509_free_certificate (x509);
			} else {
				R_LOG_ERROR ("Malformed object: did you supply enough data? try to change the block size (see b?)");
			}
		}
		break;
	case 'o': // "pFo" asn1 oid
		{
			const char fmt = input[1];
			RAsn1 *a = r_asn1_new (data, size, fmt);
			if (a) {
				char *oid = r_asn1_oid (a);
				if (oid) {
					r_cons_printf ("%s\n", oid);
					free (oid);
				}
				r_asn1_free (a);
			}
		}
		break;
	case 'p': // "pFp"
		{
			RCMS *cms = r_pkcs7_parse_cms (data, size);
			if (cms) {
				if (input[1] == 'j') {
					PJ *pj = r_pkcs7_cms_json (cms);
					if (pj) {
						char *res = pj_drain (pj);
						r_cons_printf ("%s\n", res);
						free (res);
					}
				} else {
					char *res = r_pkcs7_cms_tostring (cms);
					if (res) {
						r_cons_printf ("%s\n", res);
						free (res);
					}
				}
				r_pkcs7_free_cms (cms);
			} else {
				R_LOG_ERROR ("Malformed object: did you supply enough data? try to change the block size (see b?)");
			}
		}
		break;
	case 'b': // "pFb"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_pF, "pFb", false);
		} else {
			char *s = r_protobuf_decode (data, size, input[1]);
			if (s) {
				r_cons_printf ("%s", s);
				free (s);
			}
		}
		break;
	case 'A': // "pFA"
		if (input[1] == 'j') {
			PJ * pj = r_core_pj_new (core);
			char *s = r_axml_decode (data, size, pj);
			if (s) {
				free (s);
			}
			s = pj_drain (pj);
			r_cons_printf ("%s\n", s);
			free (s);
		} else {
			char *s = r_axml_decode (data, size, NULL);
			if (s) {
				r_cons_printf ("%s", s);
				free (s);
			} else {
				R_LOG_ERROR ("Malformed object: did you supply enough data? try to change the block size (see b?)");
			}
		}
		break;
	case 'B': // "pFB"
		if (input[1] == '?') {
			eprintf ("Usage: pFB[j] - parse binary plist format, check 'b'lock size, pFBj for json output\n");
		} else {
			PJ *pj = r_core_pj_new (core);
			if (!r_bplist_parse (pj, data, size)) {
				R_LOG_ERROR ("bplist parse error");
			}
			char *s = pj_drain (pj);
			if (input[1] == 'j') {
				r_cons_printf ("%s\n", s);
			} else {
				char *r = r_print_json_human (s);
				r_cons_printf ("%s\n", r);
				free (r);
			}
			free (s);
		}
		break;
	default:
	case '?': // "pF?"
		r_core_cmd_help (core, help_msg_pF);
		break;
	}
}
