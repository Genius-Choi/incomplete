static bool cmd_print_blocks(RCore *core, const char *input) {
	bool result = false;
	char mode = input[0];
	RList *list = NULL;
	RCoreAnalStats *as = NULL;
	RTable *t = NULL;
	PJ *pj = NULL;
	if (mode == '?') {
		r_core_cmd_help (core, help_msg_p_minus);
		return false;
	}

	if (mode && mode != ' ') {
		input++;
	}

	int w = (input[0] == ' ')
		? (int)r_num_math (core->num, input + 1)
		: (int)(core->print->cols * 2.7);

	if (w == 0) {
		r_core_cmd_help (core, help_msg_p_minus);
		return false;
	}
	int cols = r_config_get_i (core->config, "hex.cols");
	//int cols = r_cons_get_size (NULL) - 30;
	ut64 off = core->offset;
	ut64 from = UT64_MAX;
	ut64 to = 0;

	list = r_core_get_boundaries_prot (core, -1, NULL, "search");
	if (!list) {
		result = true;
		goto cleanup;
	}
	RListIter *iter;
	RIOMap *map;
	r_list_foreach (list, iter, map) {
		ut64 f = r_io_map_begin (map);
		ut64 t = r_io_map_end (map);
		if (f < from) {
			from = f;
		}
		if (t > to) {
			to = t;
		}
	}
	r_list_free (list);
	list = NULL;
	ut64 piece = R_MAX ((to - from) / R_MAX (cols, w), 1);
	as = r_core_anal_get_stats (core, from, to, piece);
	if (!as) {
		goto cleanup;
	}

	switch (mode) {
	case '-': // "p--"
#if 0
		{
			RConsPixel *p = r_cons_pixel_new (80, 80);
			r_cons_pixel_set (p, 5, 5, 1);
			r_cons_pixel_fill (p, 10, 10, 30, 30, 1);
			char *s = r_cons_pixel_drain (p);
			r_cons_printf ("%s%c", s, 10);
			free (s);
		}
#else
		r_print_graphline (core->print, core->block, core->blocksize);
#endif
		goto cleanup;
	case 'j': // "p-j"
		pj = pj_new ();
		if (!pj) {
			goto cleanup;
		}
		pj_o (pj);
		pj_kn (pj, "from", from);
		pj_kn (pj, "to", to);
		pj_ki (pj, "blocksize", piece);
		pj_k (pj, "blocks");
		pj_a (pj);
		break;
	case 'h': { // "p-h"
		t = r_core_table (core, "navbar");
		if (!t) {
			goto cleanup;
		}
		t->showSum = true;
		r_table_set_columnsf (t, "sddddd", "offset", "flags", "funcs", "cmts", "syms", "str");
		break;
	}
	case 'e':
	default:
		r_cons_printf ("0x%08"PFMT64x " [", from);
	}

	bool use_color = r_config_get_i (core->config, "scr.color");
	int len = 0;
	int i;
	for (i = 0; i < ((to - from) / piece); i++) {
		ut64 at = from + (piece * i);
		ut64 ate = at + piece;
		ut64 p = (at - from) / piece;
		switch (mode) {
		case 'j':
			pj_o (pj);
			if ((as->block[p].flags)
				|| (as->block[p].functions)
				|| (as->block[p].comments)
				|| (as->block[p].symbols)
				|| (as->block[p].perm)
				|| (as->block[p].strings)) {
				pj_kn (pj, "offset", at);
				pj_kn (pj, "size", piece);
			}
			if (as->block[p].flags) {
				pj_ki (pj, "flags", as->block[p].flags);
			}
			if (as->block[p].functions) {
				pj_ki (pj, "functions", as->block[p].functions);
			}
			if (as->block[p].in_functions) {
				pj_ki (pj, "in_functions", as->block[p].in_functions);
			}
			if (as->block[p].comments) {
				pj_ki (pj, "comments", as->block[p].comments);
			}
			if (as->block[p].symbols) {
				pj_ki (pj, "symbols", as->block[p].symbols);
			}
			if (as->block[p].strings) {
				pj_ki (pj, "strings", as->block[p].strings);
			}
			if (as->block[p].perm) {
				pj_ks (pj, "perm", r_str_rwx_i (as->block[p].perm));
			}
			pj_end (pj);
			len++;
			break;
		case 'h':
			if ((as->block[p].flags)
				|| (as->block[p].functions)
				|| (as->block[p].comments)
				|| (as->block[p].symbols)
				|| (as->block[p].strings)) {
				r_strf_var (atstr, 32, "0x%09"PFMT64x, at);
				r_table_add_rowf (t, "sddddd", atstr, as->block[p].flags,
						  as->block[p].functions, as->block[p].comments, as->block[p].symbols,  as->block[p].strings);
			}
			break;
		case 'e': // p-e
			cmd_p_minus_e (core, at, ate);
			break;
		default:{ // p--
			if (off >= at && off < ate) {
				r_cons_write ("^", 1);
			} else {
				RIOMap *s = r_io_map_get_at (core->io, at);
				if (use_color) {
					if (s) {
						if (s->perm & R_PERM_X) {
							r_cons_print (r_cons_singleton ()->context->pal.graph_trufae);
						} else {
							r_cons_print (r_cons_singleton ()->context->pal.graph_true);
						}
					} else {
						r_cons_print (r_cons_singleton ()->context->pal.graph_false);
					}
				}
				if (as->block[p].strings > 0) {
					r_cons_write ("z", 1);
				} else if (as->block[p].symbols > 0) {
					r_cons_write ("s", 1);
				} else if (as->block[p].functions > 0) {
					r_cons_write ("F", 1);
				} else if (as->block[p].comments > 0) {
					r_cons_write ("c", 1);
				} else if (as->block[p].flags > 0) {
					r_cons_write (".", 1);
				} else if (as->block[p].in_functions > 0) {
					r_cons_write ("f", 1);
				} else {
					r_cons_write ("_", 1);
				}
			}
		}
		break;
		}
	}
	switch (mode) {
	case 'j':
		pj_end (pj);
		pj_end (pj);
		r_cons_println (pj_string (pj));
		break;
	case 'h': {
		char *table_string = r_table_tofancystring (t);
		if (!table_string) {
			goto cleanup;
		}
		r_cons_printf ("\n%s\n", table_string);
		free (table_string);
		break;
	}
	case 'e':
	default:
		if (use_color) {
			r_cons_print (Color_RESET);
		}
		r_cons_printf ("] 0x%08"PFMT64x "\n", to);
		break;
	}
	result = true;
cleanup:
	pj_free (pj);
	r_table_free (t);
	r_list_free (list);
	r_core_anal_stats_free (as);
	return result;
}
