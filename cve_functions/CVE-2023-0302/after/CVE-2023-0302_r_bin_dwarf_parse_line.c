R_API RList *r_bin_dwarf_parse_line(RBin *bin, int mode) {
	r_return_val_if_fail (bin, NULL);
	ut8 *buf;
	RList *list = NULL;
	int len, ret;
	RBinSection *section = getsection (bin, "debug_line");
	RBinFile *binfile = bin->cur;
	if (binfile && section) {
		len = section->size;
		if (len < 1) {
			return NULL;
		}
		buf = calloc (1, len + 1);
		if (!buf) {
			return NULL;
		}
		ret = r_buf_read_at (binfile->buf, section->paddr, buf, len);
		if (ret != len) {
			free (buf);
			return NULL;
		}
		list = r_list_newf (row_free);
		if (!list) {
			free (buf);
			return NULL;
		}
		/* set the endianity global [HOTFIX] */
		big_end = r_bin_is_big_endian (bin);
		// Actually parse the section
		parse_line_raw (bin, buf, len, mode);
		// k bin/cur/addrinfo/*
		SdbListIter *iter;
		SdbKv *kv;
		SdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);
		// Use the parsed information from _raw and transform it to more useful format
		ls_foreach (ls, iter, kv) {
			const char *key = sdbkv_key (kv);
			if (r_str_startswith (key, "0x")) {
				char *file = strdup (sdbkv_value (kv));
				if (!file) {
					free (buf);
					ls_free (ls);
					r_list_free (list);
					return NULL;
				}
				char *tok = strchr (file, '|');
				if (tok) {
					*tok++ = 0;
					int line = atoi (tok);
					ut64 addr = r_num_math (NULL, key);
					RBinDwarfRow *row = row_new (addr, file, line, 0);
					r_list_append (list, row);
				}
				free (file);
			}
		}
		ls_free (ls);
		free (buf);
	}
	return list;
}
