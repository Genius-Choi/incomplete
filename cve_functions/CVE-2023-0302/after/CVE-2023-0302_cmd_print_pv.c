static void cmd_print_pv(RCore *core, const char *input, bool useBytes) {
	const char *stack[] = {
		"ret", "arg0", "arg1", "arg2", "arg3", "arg4", NULL
	};
	const bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);
	ut8 *block = core->block;
	int blocksize = core->blocksize;
	ut8 *heaped_block = NULL;
	ut8 *block_end = core->block + blocksize;
	int i, n = core->rasm->config->bits / 8;
	int type = 'v';
	bool fixed_size = true;
	switch (input[0]) {
	case 'p': // "pvp"
		input++;
		break;
	case '1': // "pv1"
		n = 1;
		input++;
		break;
	case '2': // "pv2"
		n = 2;
		input++;
		break;
	case '4': // "pv4"
		n = 4;
		input++;
		break;
	case '8': // "pv8"
		n = 8;
		input++;
		break;
	default:
		if (*input && input[1] == 'j') {
			input++;
		}
		fixed_size = false;
		break;
	}
	const char *arg = strchr (input, ' ');
	arg = arg? r_str_trim_head_ro (arg + 1): input;

	st64 repeat = r_num_math (core->num, arg);
	if (repeat < 0) {
		repeat = 1;
	}
	if (useBytes && n > 0 && repeat > 0) {
		repeat /= n;
	}
	if (repeat < 1) {
		repeat = 1;
	}
	// variables can be
	switch (input[0]) {
	case 'z': // "pvz"
		type = 'z';
		if (input[1]) {
			input++;
		} else {
			r_core_cmdf (core, "ps");
			break;
		}
	/* fallthrough */
	// case ' ': // "pv "
		for (i = 0; stack[i]; i++) {
			if (!strcmp (input + 1, stack[i])) {
				if (type == 'z') {
					r_core_cmdf (core, "ps @ [`drn sp`+%d]", n * i);
				} else {
					r_core_cmdf (core, "?v [`drn sp`+%d]", n * i);
				}
			}
		}
		break;
	case '*': { // "pv*"
		for (i = 0; i < repeat; i++) {
			const bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config);
			ut64 at = core->offset + (i * n);
			ut8 buf[8];
			r_io_read_at (core->io, at, buf, sizeof (buf));
			ut8 *b = buf;
			switch (n) {
			case 1:
				r_cons_printf ("f pval.0x%08"PFMT64x"=%d\n", at, r_read_ble8 (b));
				break;
			case 2:
				r_cons_printf ("f pval.0x%08"PFMT64x"=%d\n", at, r_read_ble16 (b, be));
				break;
			case 4:
				r_cons_printf ("f pval.0x%08"PFMT64x"=%d\n", at, r_read_ble32 (b, be));
				break;
			case 8:
			default:
				r_cons_printf ("f pval.0x%08"PFMT64x"=%"PFMT64d"\n", at, r_read_ble64 (b, be));
				break;
			}
		}
		break;
	}
	case 'j': { // "pvj"
		PJ *pj = r_core_pj_new (core);
		if (!pj) {
			return;
		}
		pj_a (pj);
		ut64 at = core->offset;
		for (i = 0; i < repeat; i++) {
			ut8 buf[8];
			r_io_read_at (core->io, at, buf, sizeof (buf));
			char *str = r_core_cmd_strf (core, "ps@0x%"PFMT64x, at);
			r_str_trim (str);
			char *p = str;
			if (p) {
				while (*p) {
					if (*p == '\\' && p[1] == 'x') {
						memmove (p, p + 4, strlen (p + 4) + 1);
					}
					p++;
				}
			}
			// r_num_get is gonna use a dangling pointer since the internal
			// token that RNum holds ([$$]) has been already freed by r_core_cmd_str
			// r_num_math reload a new token so the dangling pointer is gone
			pj_o (pj);
			pj_k (pj, "value");
			switch (n) {
			case 1:
				pj_i (pj, r_read_ble8 (buf));
				break;
			case 2:
				pj_n (pj, r_read_ble16 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));
				break;
			case 4:
				pj_n (pj, r_read_ble32 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));
				break;
			case 8:
			default:
				pj_n (pj, r_read_ble64 (buf, R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config)));
				break;
			}
			pj_ks (pj, "string", str);
			pj_kn (pj, "address", at);
			pj_end (pj);
			free (str);
			at += n;
		}
		pj_end (pj);
		r_cons_println (pj_string (pj));
		pj_free (pj);
		break;
	}
	case 'e': // "pve"
		{
			int size = 4; // default is 4.. or asm.bits?
			const char *byteorder = r_config_get_b (core->config, "cfg.bigendian")
				? "1234": "4321";
			if (strchr (input, ' ')) {
				size = atoi (input + 1);
				byteorder = r_str_trim_head_ro (input + 2);
			} else {
				size = strlen (byteorder);
			}
			int length = size;
			char *space = strchr (byteorder, ' ');
			if (space) {
				length = atoi (space + 1);
			}
			int i = 0;
			if (length + size > 0xfffff) {
				R_LOG_ERROR ("Too large");
				break;
			}
			ut8 * data = calloc (length + size, 1);
			if (data) {
				(void)r_io_read_at (core->io, core->offset, data, length + size);
				while (i < length) {
					ut32 n = convert (data + i, byteorder);
					r_cons_printf ("0x%08"PFMT64x"  %d (0x%08x)\n", core->offset + i, n, n);
					i += size;
				}
				free (data);
			}
		}
		break;
	case '?': // "pv?"
		r_core_cmd_help (core, help_msg_pv);
		break;
	default:
		do {
			repeat--;
			const int p_bits = core->rasm->config->bits / 8;
			if (block + 8 >= block_end) {
				int blockdelta = block - core->block;
				if (heaped_block) {
					blockdelta = block - heaped_block;
					free (heaped_block);
				}
				blocksize = ((1 + repeat) * 8) + 8;
				block_end = block + blocksize;
				heaped_block = calloc (blocksize, 1);
				if (!heaped_block) {
					break;
				}
				r_io_read_at (core->io, core->offset + blockdelta, heaped_block, blocksize);
				block = heaped_block;
			}
			ut64 v;
			if (!fixed_size) {
				n = 0;
			}
			switch (n) {
			case 1:
				v = r_read_ble8 (block);
				r_cons_printf ("0x%02" PFMT64x "\n", v);
				block += 1;
				break;
			case 2:
				v = r_read_ble16 (block, be);
				r_cons_printf ("0x%04" PFMT64x "\n", v);
				block += 2;
				break;
			case 4:
				v = r_read_ble32 (block, be);
				r_cons_printf ("0x%08" PFMT64x "\n", v);
				block += 4;
				break;
			case 8:
				v = r_read_ble64 (block, be);
				r_cons_printf ("0x%016" PFMT64x "\n", v);
				block += 8;
				break;
			default:
				v = r_read_ble64 (block, be);
				switch (p_bits) { // core->rasm->config->bits / 8) {
				case 1: r_cons_printf ("0x%02" PFMT64x "\n", v & UT8_MAX); break;
				case 2: r_cons_printf ("0x%04" PFMT64x "\n", v & UT16_MAX); break;
				case 4: r_cons_printf ("0x%08" PFMT64x "\n", v & UT32_MAX); break;
				case 8: r_cons_printf ("0x%016" PFMT64x "\n", v & UT64_MAX); break;
				default: break;
				}
				block += p_bits;
				break;
			}
		} while (repeat > 0);
		free (heaped_block);
		break;
	}
}
