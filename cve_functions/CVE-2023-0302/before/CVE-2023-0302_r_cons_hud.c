R_API char *r_cons_hud(RList *list, const char *prompt) {
	bool demo = r_cons_singleton ()->context->demo;
	char user_input[HUD_BUF_SIZE + 1];
	char *selected_entry = NULL;
	RListIter *iter;

	HtPP *ht = ht_pp_new (NULL, (HtPPKvFreeFunc)mht_free_kv, (HtPPCalcSizeV)strlen);
	RLineHud *hud = (RLineHud*) R_NEW (RLineHud);
	hud->activate = 0;
	hud->vi = 0;
	I(line)->echo = false;
	I(line)->hud = hud;
	user_input [0] = 0;
	user_input[HUD_BUF_SIZE] = 0;
	hud->top_entry_n = 0;
	r_cons_show_cursor (false);
	r_cons_enable_mouse (false);
	r_cons_set_raw (true);
	r_cons_clear ();

	// Repeat until the user exits the hud
	for (;;) {
		r_cons_gotoxy (0, 0);
		hud->current_entry_n = 0;

		if (hud->top_entry_n < 0) {
			hud->top_entry_n = 0;
		}
		selected_entry = NULL;
		char *p = NULL;
		if (prompt && *prompt) {
			p = r_str_appendf (p, ">> %s\n", prompt);
		}
		p = r_str_appendf (p, "%d> %s|\n", hud->top_entry_n, user_input);
		if (p) {
			if (demo) {
				char *q = r_str_ss (p, NULL, 0);
				free (p);
				p = q;
			}
			r_cons_printf ("%s", p);
			free (p);
		}
		char *row;
		RList *filtered_list = NULL;

		bool found = false;
		filtered_list = ht_pp_find (ht, user_input, &found);
		if (!found) {
			filtered_list = hud_filter (list, user_input,
				hud->top_entry_n, &(hud->current_entry_n), &selected_entry, false);
#if HUD_CACHE
			ht_pp_insert (ht, user_input, filtered_list);
#endif
		}
		r_list_foreach (filtered_list, iter, row) {
			r_cons_printf ("%s\n", row);
		}
		if (!filtered_list->length) {				// hack to remove garbage value when list is empty
			printf ("%s", R_CONS_CLEAR_LINE);
		}
#if !HUD_CACHE
		r_list_free (filtered_list);
#endif
		r_cons_visual_flush ();
		(void) r_line_readline ();
		r_str_ncpy (user_input, I(line)->buffer.data, HUD_BUF_SIZE);

		if (!hud->activate) {
			hud->top_entry_n = 0;
			if (hud->current_entry_n >= 1 ) {
				if (selected_entry) {
					R_FREE (I(line)->hud);
					I(line)->echo = true;
					r_cons_enable_mouse (false);
					r_cons_show_cursor (true);
					r_cons_set_raw (false);
					return strdup (selected_entry);
				}
			} else {
				goto _beach;
			}
		}
	}
_beach:
	R_FREE (I(line)->hud);
	I(line)->echo = true;
	r_cons_show_cursor (true);
	r_cons_enable_mouse (false);
	r_cons_set_raw (false);
	ht_pp_free (ht);
	return NULL;
}
