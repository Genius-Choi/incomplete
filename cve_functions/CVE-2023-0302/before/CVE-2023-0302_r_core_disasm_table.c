static void r_core_disasm_table(RCore *core, int l, const char *input) {
	int i;
	RTable *t = r_core_table (core, "disasm");
	char *arg = strchr (input, ' ');
	if (arg) {
		input = arg + 1;
	}
	r_table_set_columnsf (t, "snssssss", "name", "addr", "bytes", "disasm", "comment", "esil", "refs", "xrefs");
	const int minopsz = 1;
	const int options = R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT | R_ARCH_OP_MASK_DISASM | R_ARCH_OP_MASK_ESIL;
	ut64 ea = core->offset;
	for (i = 0; i < l; i++) {
		RAnalOp *op = r_core_anal_op (core, ea, options);
		if (!op || op->size < 1) {
			i += minopsz;
			ea += minopsz;
			continue;
		}
		const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, ea);
		// TODO parse/filter op->mnemonic for better disasm
		ut8 *bytes = malloc (op->size);
		if (!bytes) {
			break;
		}
		r_io_read_at (core->io, ea, bytes, op->size); // XXX ranalop should contain the bytes like rasmop do
		char *sbytes = r_hex_bin2strdup(bytes, op->size);
		RFlagItem *fi = r_flag_get_i (core->flags, ea);
		char *fn = fi? fi->name: "";
		const char *esil = R_STRBUF_SAFEGET (&op->esil);
		char *refs = __op_refs (core, op, 0);
		char *xrefs = __op_refs (core, op, 1);
		r_table_add_rowf (t, "sXssssss", fn, ea, sbytes, op->mnemonic, r_str_get (comment), esil, refs, xrefs);
		free (sbytes);
		free (bytes);
		free (xrefs);
		free (refs);
		ea += op->size;
		r_anal_op_free (op);
	}
	if (input && *input) {
		r_table_query (t, input);
	}
	char *ts = r_table_tostring (t);
	r_cons_printf ("%s", ts); // \n?
	free (ts);
	r_table_free (t);
}
