static int cmd_pdu(RCore *core, const char *input) {
	int ret = 0;
	const char *sep = strchr (input, ' ');
	const char *arg = sep? sep+1: NULL;

	ut64 addr = core->offset;
	int len = core->blocksize;
	ut8 *buf = malloc (len);
	if (buf) {
		r_io_read_at (core->io, addr, buf, len);
	} else {
		R_LOG_ERROR ("Cannot allocate %d byte(s)", len);
		return 1;
	}

	switch (*input) {
	case 'a': // "pdua"
		{
		if (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {
			r_core_cmd_help_match (core, help_msg_pdu, "pdua", true);
			break;
		}

		ut64 to = r_num_get (core->num, arg);

		if (!to) {
			R_LOG_ERROR ("Couldn't parse address \"%s\"", arg);
			ret = 1;
			break;
		} else if (to < addr) {
			R_LOG_ERROR ("Can't print until an earlier address");
			ret = 2;
			break;
		} else if (to == addr) {
			R_LOG_ERROR ("Can't print until the start address");
			ret = 2;
			break;
		}

		// pD <count>
		ut64 count = to - core->offset;
		ret = r_core_cmdf (core, "%s %" PFMT64u, (input[1]== 'j')? "pDJ": "pD", count);
		}
		break;
	case 'c': // "pduc"
		if (input[1] == '?' || (input[1] && input[2] == '?')) {
			r_core_cmd_help_match (core, help_msg_pdu, "pduc", true);
			break;
		}

		ret = r_core_print_disasm (core, addr, buf, len, 0, pdu_opcode, "call", false,
				input[1] == 'j', NULL, NULL);
		break;
	/*case 'e': // "pdue"
		if (input[1] == '?' || input[2] == '?' || !arg) {
			r_core_cmd_help_match (core, help_msg_pdu, "pdue", true);
			break;
		}

		ret = r_core_print_disasm (core, addr, buf, len, 0, esil, arg, false,
				input[1] == 'j', NULL, NULL);
		break;*/
	case 'i': // "pdui"
		if (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {
			r_core_cmd_help_match (core, help_msg_pdu, "pdui", true);
			break;
		}
		ret = r_core_print_disasm (core, addr, buf, len, 0, pdu_instruction, arg, false,
				input[1] == 'j', NULL, NULL);
		break;
	case 'o': // "pduo"
		if (input[1] == '?' || (input[1] && input[2] == '?') || !arg) {
			r_core_cmd_help_match (core, help_msg_pdu, "pduo", true);
			break;
		}
		ret = r_core_print_disasm (core, addr, buf, len, 0, pdu_opcode, arg, false,
				input[1] == 'j', NULL, NULL);
		break;
	case 's': // "pdus"
		if (input[1] == '?' || (input[1] && input[2] == '?')) {
			r_core_cmd_help_match (core, help_msg_pdu, "pdus", true);
			break;
		}
		ret = r_core_print_disasm (core, addr, buf, len, 0, pdu_instruction, "syscall", false,
				input[1] == 'j', NULL, NULL);
		break;
	case '?': // "pdu?"
	default:
		r_core_cmd_help (core, help_msg_pdu);
		break;
	}

	free (buf);
	return ret;
}
