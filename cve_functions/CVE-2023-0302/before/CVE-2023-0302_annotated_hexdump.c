static void annotated_hexdump(RCore *core, const char *str, int len) {
	r_return_if_fail (core);
	if (!str || len < 1) {
		return;
	}
	const int usecolor = r_config_get_i (core->config, "scr.color");
	int nb_cols = r_config_get_i (core->config, "hex.cols");
	core->print->use_comments = r_config_get_i (core->config, "hex.comments");
	int flagsz = r_config_get_i (core->config, "hex.flagsz");
	bool showSection = r_config_get_b (core->config, "hex.section");
	const ut8 *buf = core->block;
	ut64 addr = core->offset;
	int color_idx = 0;
	char *bytes, *chars;
	char *ebytes, *echars; // They'll walk over the vars above
	ut64 fend = UT64_MAX;
	int i, j, low, max, here, rows;
	bool marks = false, setcolor = true, hascolor = false;
	ut8 ch = 0;
	char *colors[10] = { NULL };
	for (i = 0; i < 10; i++) {
		colors[i] = r_cons_rainbow_get (i, 10, false);
	}
	const int col = core->print->col;
	RFlagItem *curflag = NULL;
	char **note;
	int html = r_config_get_i (core->config, "scr.html");
	int nb_cons_cols;
	bool compact = false;

	if (core->print) {
		compact = core->print->flags & R_PRINT_FLAGS_COMPACT;
	}
	char *format = compact ? " %X %X" : " %X %X ";
	int step = compact ? 4 : 5;

	// Adjust the number of columns
	if (nb_cols < 1) {
		nb_cols = 16;
	}
	nb_cols -= (nb_cols % 2); // nb_cols should be even
	if (nb_cols < 1) {
		return;
	}

	nb_cons_cols = 12 + nb_cols * 2 + (nb_cols / 2);
	nb_cons_cols += 17;
	rows = len / nb_cols;

	chars = calloc (nb_cols * 40, sizeof (char));
	if (!chars) {
		goto err_chars;
	}
	note = calloc (nb_cols, sizeof (char *));
	if (!note) {
		goto err_note;
	}
	bytes = calloc (64 + nb_cons_cols * 40, sizeof (char));
	if (!bytes) {
		goto err_bytes;
	}
#if 1
	char addrpad[32];
	int addrpadlen = snprintf (addrpad, 0, "%08"PFMT64x, addr) - 8;
	if (addrpadlen > 0) {
		memset (addrpad, ' ', addrpadlen);
		addrpad[addrpadlen] = 0;
		// Compute, then show the legend
		strcpy (bytes, addrpad);
	} else {
		*addrpad = 0;
		addrpadlen = 0;
	}
	strcpy (bytes + addrpadlen, "- offset -  ");
#endif
	j = strlen (bytes);
	for (i = 0; i < nb_cols; i += 2) {
		sprintf (bytes + j, format, (i & 0xf), (i + 1) & 0xf);
		j += step;
	}
	if (!compact) {
		j--;
	}
	strcpy (bytes + j, "     ");
	j += 2;
	for (i = 0; i < nb_cols; i++) {
		sprintf (bytes + j + i, "%0X", i % 17);
	}
	if (usecolor) {
		r_cons_strcat (Color_GREEN);
		r_cons_strcat (bytes);
		r_cons_strcat (Color_RESET);
	} else {
		r_cons_strcat (bytes);
	}
	r_cons_newline ();

	// hexdump
	for (i = 0; i < rows; i++) {
		bytes[0] = '\0';
		chars[0] = '\0';
		ebytes = bytes;
		echars = chars;
		ut64 ea = addr;
		if (core->print->pava) {
			ut64 va = r_io_p2v (core->io, addr);
			if (va != UT64_MAX) {
				ea = va;
			}
		}
		if (usecolor) {
			append (ebytes, core->cons->context->pal.offset);
		}
		if (showSection) {
			const char * name = r_core_get_section_name (core, ea);
			char *s = r_str_newf ("%20s ", name);
			append (ebytes, s);
			free (s);
		}
		ebytes += sprintf (ebytes, "0x%08"PFMT64x, ea);
		if (usecolor) {
			append (ebytes, Color_RESET);
		}
		append (ebytes, (col == 1)? " |": "  ");
		bool hadflag = false;
		for (j = 0; j < nb_cols; j++) {
			setcolor = true;
			R_FREE (note[j]);

			// TODO: in pava mode we should read addr or ea? // imho ea. but wat about hdrs and such
			RIntervalNode *meta_node = r_meta_get_in (core->anal, ea + j, R_META_TYPE_FORMAT);
			RAnalMetaItem *meta = meta_node ? meta_node->data : NULL;
			if (meta && meta->type == R_META_TYPE_FORMAT && meta_node->start == addr + j) {
				r_cons_printf (".format %s ; size=", meta->str);
				r_core_cmd_callf (core, "pfs %s", meta->str);
				r_core_cmdf (core, "pf %s @ 0x%08"PFMT64x, meta->str, meta_node->start);
				if (usecolor) {
					append (ebytes, Color_INVERT);
					append (echars, Color_INVERT);
				}
				hadflag = true;
			}
			if (meta) {
				meta = NULL;
			}
			// collect comments
			const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr + j);
			if (comment) {
				note[j] = r_str_newf (";%s", comment);
				marks = true;
			}
			const RList *list = r_flag_get_list (core->flags, addr + j);
			RListIter *iter;
			RFlagItem *fi;
			ut64 flagsize = 0;
			ut64 flagaddr = 0;
			bool found = false;
			char *flagname = NULL;
			ut64 at = addr + j;
			if (r_list_empty (list)) {
				// get flag fnear and check for size
				RFlagItem *fnear = r_flag_get_at (core->flags, at, true);
				if (fnear) {
					if (fnear->offset <= at) {
						if (fnear->offset + fnear->size >= at) {
							found = true;
						}
					}
					if (found) {
						flagaddr = fnear->offset;
						if (fnear->offset == at) {
							free (flagname);
							flagname = fnear->name;
						}
						if (fnear->color) {
							curflag = fnear;
						}
						if (!curflag) {
							curflag = fnear;
						}
						hascolor = false;
					}
				}
			} else {
				r_list_foreach (list, iter, fi) {
					flagsize = R_MAX (flagsize, fi->size);
					if (fi->color) {
						curflag = fi;
					}
					if (!flagaddr || fi->color) {
						flagaddr = fi->offset;
						if (fi->offset == at) {
							free (flagname);
							flagname = strdup (fi->name);
						}
						if (!fi->color) {
							curflag = fi;
						}
					}
				}
				if (curflag) {
					hascolor = false;
					found = true;
				}
			}
			// collect flags
			if (found) {
				if (flagsz) {
					flagsize = flagsz;
				}
				if (flagsize) {
					fend = addr + flagsize;
				} else {
					fend = addr + j + flagsize;
				}
				const char *name = r_name_filter_ro (flagname);
				if (name) {
					free (note[j]);
					note[j] = r_str_prepend (strdup (name), "/");
				} else {
					free (note[j]);
					note[j] = NULL;
				}
				marks = true;
				color_idx++;
				color_idx %= 10;
				if (showSection) {
					r_cons_printf ("%20s ", "");
				}
				if (flagaddr == addr + j) {
					if (usecolor) {
						append (ebytes, Color_INVERT);
						append (echars, Color_INVERT);
					}
					hadflag = true;
				}
			} else {
				// Are we past the current flag?
				if (curflag && addr + j > (curflag->offset + curflag->size)) {
					setcolor = false;
					curflag = NULL;
				}
				// Turn colour off if we're at the end of the current flag
				if (fend == UT64_MAX || fend <= addr + j) {
					setcolor = false;
				}
			}
			R_FREE (flagname);
			hascolor = false;
			if (usecolor) {
				if (!setcolor) {
					const char *bytecolor = r_print_byte_color (core->print, addr + j, ch);
					if (bytecolor) {
						append (ebytes, bytecolor);
						append (echars, bytecolor);
						hascolor = true;
					}
				} else if (!hascolor) {
					hascolor = true;
					if (curflag && curflag->color) {
						char *ansicolor = r_cons_pal_parse (curflag->color, NULL);
						if (ansicolor) {
							append (ebytes, ansicolor);
							append (echars, ansicolor);
							free (ansicolor);
						}
					} else { // Use "random" colours
						append (ebytes, colors[color_idx]);
						append (echars, colors[color_idx]);
					}
				}
			}
			here = R_MIN ((i * nb_cols) + j, core->blocksize);
			ch = buf[here];
			if (core->print->ocur != -1) {
				low = R_MIN (core->print->cur, core->print->ocur);
				max = R_MAX (core->print->cur, core->print->ocur);
			} else {
				low = max = core->print->cur;
			}
			if (core->print->cur_enabled) {
				if (low == max) {
					if (low == here) {
						if (html || !usecolor) {
							append (ebytes, "[");
							append (echars, "[");
						} else {
							append (echars, Color_INVERT);
							append (ebytes, Color_INVERT);
						}
					}
				} else {
					if (here >= low && here < max) {
						if (html || !usecolor) {
							append (ebytes, "[");
							append (echars, "[");
						} else {
							if (usecolor) {
								append (ebytes, Color_INVERT);
								append (echars, Color_INVERT);
							}
						}
					}
				}
			}
			// R2_590 - r_hex_from_byte (ebytes, ch);
			snprintf (ebytes, 3, "%02x", (ch & 0xff));
			ebytes += strlen (ebytes);
			if (hadflag) {
				if (usecolor) {
					append (ebytes, Color_INVERT_RESET);
					append (echars, Color_INVERT_RESET);
				}
				hadflag = false;
			}
			*echars++ = IS_PRINTABLE (ch)? ch: '.';
			*echars = 0;
			if (core->print->cur_enabled && max == here) {
				if (!html && usecolor) {
					append (ebytes, Color_RESET);
					append (echars, Color_RESET);
				}
				hascolor = false;
			}

			if (j < (nb_cols - 1) && (j % 2) && !compact) {
				append (ebytes, " ");
			}

			if (fend != UT64_MAX && fend == addr + j + 1) {
				if (!html && usecolor) {
					append (ebytes, Color_RESET);
					append (echars, Color_RESET);
				}
				fend = UT64_MAX;
				hascolor = false;
			}
		}
		if (!html && usecolor) {
			append (ebytes, Color_RESET);
			append (echars, Color_RESET);
		}
		append (ebytes, (col == 1)? "| ": (col == 2)? " |": "  ");
		if (col == 2) {
			append (echars, "|");
		}

		if (marks) { // show comments and flags
			int hasline = 0;
			int out_sz = nb_cons_cols + 20;
			char *out = calloc (out_sz, sizeof (char));
			memset (out, ' ', nb_cons_cols - 1);
			for (j = 0; j < nb_cols; j++) {
				if (note[j]) {
					int off = (j * 3) - (j / 2) + 13;
					int notej_len = strlen (note[j]);
					int sz = R_MIN (notej_len, nb_cons_cols - off);
					if (compact) {
						off -= (j / 2);
					} else {
						if (j % 2) {
							off--;
						}
					}
					memcpy (out + off, note[j], sz);
					if (sz < notej_len) {
						out[off + sz - 2] = '.';
						out[off + sz - 1] = '.';
					}
					hasline = (out[off] != ' ');
					R_FREE (note[j]);
				}
			}
			out[out_sz - 1] = 0;
			if (hasline) {
				r_cons_strcat (addrpad);
				r_cons_strcat (out + 1);
				r_cons_newline ();
			}
			marks = false;
			free (out);
		}
		r_cons_strcat (bytes);
		r_cons_strcat (chars);

		if (core->print->use_comments) {
			for (j = 0; j < nb_cols; j++) {
				char *comment = core->print->get_comments (core->print->user, addr + j);
				if (comment) {
					r_cons_printf (" ; %s", comment);
					free (comment);
				}
			}
		}

		r_cons_newline ();
		addr += nb_cols;
	}

	free (bytes);
 err_bytes:
	free (note);
 err_note:
	free (chars);
 err_chars:
	for (i = 0; i < R_ARRAY_SIZE (colors); i++) {
		R_FREE (colors[i]);
	}
}
