R_API char *r_str_encoded_json(const char *buf, int buf_size, int encoding) {
	r_return_val_if_fail (buf, NULL);
	size_t buf_sz = buf_size < 0 ? strlen (buf) : buf_size;
	char *encoded_str;

	if (encoding == PJ_ENCODING_STR_BASE64) {
		encoded_str = r_base64_encode_dyn (buf, buf_sz);
	} else if (encoding == PJ_ENCODING_STR_HEX || encoding == PJ_ENCODING_STR_ARRAY) {
		size_t loop = 0;
		size_t i = 0;
		size_t increment = encoding == PJ_ENCODING_STR_ARRAY ? 4 : 2;

		if (!SZT_MUL_OVFCHK (((buf_sz * increment) + 1), SZT_MAX)) {
			return NULL;
		}
		size_t new_sz = (buf_sz * increment) + 1;

		encoded_str = malloc (new_sz);
		if (!encoded_str) {
			return NULL;
		}

		const char *format = encoding == PJ_ENCODING_STR_ARRAY ? "%03u," : "%02X";
		while (buf[loop] != '\0' && i < (new_sz - 1)) {
			snprintf (encoded_str + i, new_sz - i, format, (ut8) buf[loop]);
			loop++;
			i += increment;
		}
		if (encoding == PJ_ENCODING_STR_ARRAY && i) {
			// get rid of the trailing comma
			encoded_str[i - 1] = '\0';
		} else {
			encoded_str[i] = '\0';
		}
	} else if (encoding == PJ_ENCODING_STR_STRIP) {
		encoded_str = r_str_escape_utf8_for_json_strip (buf, buf_sz);
	} else {
		encoded_str = r_str_escape_utf8_for_json (buf, buf_sz);
	}
	return encoded_str;
}
