static void r_core_cmd_print_binformat(RCore *core, const char *arg, int mode) {
	// r_io_read_at (core->io, core->offset, buf, sizeof (buf));
	const char *fmt = arg;
	int n = 0;
	char *names = strchr (fmt, ' ');
	RList *lnames = NULL;
	if (names) {
		names = strdup (names + 1);
		lnames = r_str_split_list (names, " ", 0);
	}
	int i = 0;
	int bpos = 0;
	ut64 v = 0;
	// bigbitendian
	// r_core_cmd0 (core, "pb 8");
	RBitmap *bm = r_bitmap_new (core->blocksize * 8);
	r_bitmap_set_bytes (bm, core->block, core->blocksize);
	RList *lart = lart_new ();

	while (*arg && *arg != ' ') {
		if (IS_DIGIT (*arg)) {
			n = atoi (arg);
			if (n > 64) {
				R_LOG_ERROR ("Too large. Max is 64");
				lart_free (lart);
				r_bitmap_free (bm);
				return;
			}
			while (IS_DIGIT (*arg)) {
				arg += 1;
			}
			arg--;
		} else if (*arg == '+') {
			// used to separate tokens
			// for example 3+3:4b  -> [0..3] + [6..10]
		} else if (*arg == 'b') {
			if (n < 1) {
				R_LOG_ERROR ("Invalid bitformat string");
				lart_free (lart);
				r_bitmap_free (bm);
				return;
			}
			char *name = lnames? r_list_get_n (lnames, i): NULL;
			v = read_val (bm, bpos, n);
			switch (mode) {
			case PFB_DBG:
				r_cons_printf ("field: %d\n", i);
				if (name) {
					r_cons_printf (" name: %s\n", name);
				}
				r_cons_printf ("  off: %d\n", bpos);
				r_cons_printf ("  siz: %d\n", n);
				r_cons_printf ("  val: %"PFMT64d"\n", v);
				break;
			case PFB_ART:
				lart_add (lart, name, bpos, n, v);
				break;
			}
			i++;
			bpos += n;
		}
		arg++;
	}
	if (mode == PFB_ART) {
		for (i = 0; i < bpos; i++) {
			bool v = read_val (bm, i, 1);
			r_cons_printf ("%d", v);
		}
		r_cons_printf ("     (big bit endian)\n");
		RLart *la;
		RListIter *iter;
		char firstline[1024] = {0};
		memset (firstline, ' ', sizeof (firstline) - 1);
		int padsz = 0;
		r_list_foreach (lart, iter, la) {
			if (la->sz == 1) {
				r_cons_printf ("V");
			} else {
				r_cons_printf ("\\");
				int i;
				for (i = 0; i < la->sz - 2; i++) {
					r_cons_printf ("_");
				}
				r_cons_printf ("/");
			}
			padsz = la->pos - 1 + (la->sz / 2);
			firstline[padsz + 1] = '|';
		}
		firstline[padsz + 2] = 0;
		int totalpad = padsz + 4;
		r_cons_newline ();
		r_list_reverse (lart);
		r_list_foreach (lart, iter, la) {
			int padsz = la->pos - 1 + (la->sz / 2);
			char *v = r_str_newf ("%s= %"PFMT64d" (0x%"PFMT64x")", la->name?la->name:"", la->value, la->value);
			char *pad2 = strdup (r_str_pad ('-', totalpad - padsz));
			char *pad = r_str_ndup (firstline, padsz + 1);
			if (la->value > 0xffff) {
				r_cons_printf ("%s`-%s %8s = 0x%016"PFMT64x" @ %d + %d\n",
						pad?pad:"", pad2,
						la->name?la->name: "",
						la->value,
						la->pos, la->sz
					      );
			} else {
				r_cons_printf ("%s`-%s %8s = %4"PFMT64o"o %5"PFMT64d"   0x%02"PFMT64x" @ %d + %d\n",
						pad?pad:"", pad2,
						la->name?la->name: "",
						la->value, la->value, la->value,
						la->pos, la->sz
					      );
			}
			free (pad);
			free (pad2);
			free (v);
		}
	}
	r_bitmap_free (bm);
	lart_free (lart);
	r_list_free (lnames);
}
