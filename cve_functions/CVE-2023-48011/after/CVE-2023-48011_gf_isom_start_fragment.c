GF_Err gf_isom_start_fragment(GF_ISOFile *movie, GF_ISOStartFragmentFlags flags)
{
	u32 i, count;
	GF_TrackExtendsBox *trex;
	GF_TrackFragmentBox *traf;
	GF_Err e;
	Bool moof_first = (flags & GF_ISOM_FRAG_MOOF_FIRST) ? GF_TRUE : GF_FALSE;
#ifdef GF_ENABLE_CTRN
	Bool use_ctrn = (flags & GF_ISOM_FRAG_USE_COMPACT) ? GF_TRUE : GF_FALSE;
#endif

	//and only at setup
	if (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )
		return GF_BAD_PARAM;
	if (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;

	count = gf_list_count(movie->moov->mvex->TrackExList);
	if (!count)
		return GF_BAD_PARAM;

	/*always force cached mode when writing movie segments*/
	if (movie->use_segments) moof_first = GF_TRUE;
	movie->moof_first = moof_first;

	//store existing fragment
	if (movie->moof) {
		e = StoreFragment(movie, movie->use_segments ? GF_TRUE : GF_FALSE, 0, NULL, movie->use_segments ? GF_TRUE : (movie->on_block_out ? GF_TRUE : GF_FALSE));
		if (e) return e;
	}

	//create new fragment
	movie->moof = (GF_MovieFragmentBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOF);
	if (!movie->moof) return GF_OUT_OF_MEM;
	movie->moof->mfhd = (GF_MovieFragmentHeaderBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_MFHD);
	if (!movie->moof->mfhd) return GF_OUT_OF_MEM;
	movie->moof->mfhd->sequence_number = movie->NextMoofNumber;
	movie->NextMoofNumber ++;
	if (movie->use_segments || movie->on_block_out)
		gf_list_add(movie->moof_list, movie->moof);


	/*remember segment offset*/
	movie->moof->fragment_offset = gf_bs_get_position(movie->editFileMap->bs);

	/*prepare MDAT*/
	if (movie->on_block_out)
		gf_bs_prevent_dispatch(movie->editFileMap->bs, GF_TRUE);

	gf_bs_write_u32(movie->editFileMap->bs, 0);
	gf_bs_write_u32(movie->editFileMap->bs, GF_ISOM_BOX_TYPE_MDAT);

	//we create a TRAF for each setup track, unused ones will be removed at store time
	for (i=0; i<count; i++) {
		trex = (GF_TrackExtendsBox*)gf_list_get(movie->moov->mvex->TrackExList, i);
		traf = (GF_TrackFragmentBox *) gf_isom_box_new_parent(&movie->moof->child_boxes, GF_ISOM_BOX_TYPE_TRAF);
		if (!traf) return GF_OUT_OF_MEM;
		traf->trex = trex;
		traf->tfhd = (GF_TrackFragmentHeaderBox *) gf_isom_box_new_parent(&traf->child_boxes, GF_ISOM_BOX_TYPE_TFHD);
		if (!traf->tfhd) return GF_OUT_OF_MEM;
		traf->tfhd->trackID = trex->trackID;
		//add 8 bytes (MDAT size+type) to avoid the data_offset in the first trun
		traf->tfhd->base_data_offset = movie->moof->fragment_offset + 8;
#ifdef GF_ENABLE_CTRN
		traf->use_ctrn = use_ctrn;
		if (trex->inherit_from_traf_id)
			traf->use_inherit = GF_TRUE;
#endif
		gf_list_add(movie->moof->TrackList, traf);

		if (movie->mfra) {
			GF_TrackFragmentRandomAccessBox *tfra;
			GF_RandomAccessEntry *raf;
			if (!traf->trex->tfra) {
				tfra = (GF_TrackFragmentRandomAccessBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_TFRA);
				if (!tfra) return GF_OUT_OF_MEM;
				tfra->track_id = traf->trex->trackID;
				tfra->traf_bits = 8;
				tfra->trun_bits = 8;
				tfra->sample_bits = 8;
				gf_list_add(movie->mfra->tfra_list, tfra);
				traf->trex->tfra = tfra;
			}
			tfra = traf->trex->tfra;
			tfra->entries = (GF_RandomAccessEntry *)gf_realloc(tfra->entries, (tfra->nb_entries+1)*sizeof(GF_RandomAccessEntry));
			tfra->nb_entries++;
			raf = &tfra->entries[tfra->nb_entries-1];
			raf->sample_number = 1;
			raf->time = 0;
			raf->traf_number = i+1;
			//trun number is set once we fond a sync
			raf->trun_number = 0;
			if (!strcmp(movie->fileName, "_gpac_isobmff_redirect")) {
				raf->moof_offset = movie->fragmented_file_pos;
			} else {
				raf->moof_offset = movie->moof->fragment_offset;
			}
		}
	}
	return GF_OK;
}
