GF_Err gf_isom_allocate_sidx(GF_ISOFile *movie, s32 subsegs_per_sidx, Bool daisy_chain_sidx, u32 nb_segs, u32 *frags_per_segment, u32 *start_range, u32 *end_range, Bool use_ssix)
{
	GF_BitStream *bs;
	GF_Err e;
	u32 i;

	//and only at setup
	if (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;
	if (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;
	if (movie->root_sidx) return GF_BAD_PARAM;
	if (movie->root_ssix) return GF_BAD_PARAM;
	if (movie->moof) return GF_BAD_PARAM;
	if (gf_list_count(movie->moof_list)) return GF_BAD_PARAM;

	movie->root_sidx = (GF_SegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SIDX);
	if (!movie->root_sidx) return GF_OUT_OF_MEM;
	/*we don't write anything between sidx and following moov*/
	movie->root_sidx->first_offset = 0;

	/*for now we only store one ref per subsegment and don't support daisy-chaining*/
	movie->root_sidx->nb_refs = nb_segs;

	if (use_ssix) {
		movie->root_ssix = (GF_SubsegmentIndexBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_SSIX);
		movie->root_ssix->subsegment_count = nb_segs;
		movie->root_ssix->subsegment_alloc = movie->root_ssix->subsegment_count;
	}

	//dynamic mode
	if (!nb_segs) {
		movie->dyn_root_sidx = GF_TRUE;
		return GF_OK;
	}

	movie->root_sidx->refs = (GF_SIDXReference*)gf_malloc(sizeof(GF_SIDXReference) * movie->root_sidx->nb_refs);
	if (!movie->root_sidx->refs) return GF_OUT_OF_MEM;
	memset(movie->root_sidx->refs, 0, sizeof(GF_SIDXReference) * movie->root_sidx->nb_refs);

	movie->root_sidx_index = 0;

	if (use_ssix) {
		movie->root_ssix->subsegments = gf_malloc(sizeof(GF_SubsegmentInfo) * nb_segs);
		if (!movie->root_ssix->subsegments) return GF_OUT_OF_MEM;
		for (i=0; i<nb_segs; i++) {
			movie->root_ssix->subsegments[i].range_count = 2;
			movie->root_ssix->subsegments[i].ranges = gf_malloc(sizeof(GF_SubsegmentRangeInfo)*2);
			if (!movie->root_ssix->subsegments[i].ranges) return GF_OUT_OF_MEM;
			movie->root_ssix->subsegments[i].ranges[0].level = 0;
			movie->root_ssix->subsegments[i].ranges[0].range_size = 0;
			movie->root_ssix->subsegments[i].ranges[1].level = 1;
			movie->root_ssix->subsegments[i].ranges[1].range_size = 0;
		}
	}
	
	/*remember start of sidx*/
	movie->root_sidx_offset = gf_bs_get_position(movie->editFileMap->bs);

	bs = movie->editFileMap->bs;

	e = gf_isom_box_size((GF_Box *) movie->root_sidx);
	if (e) return e;
	e = gf_isom_box_write((GF_Box *) movie->root_sidx, bs);
	if (e) return e;

	if (movie->root_ssix) {
		e = gf_isom_box_size((GF_Box *) movie->root_ssix);
		if (e) return e;
		e = gf_isom_box_write((GF_Box *) movie->root_ssix, bs);
		if (e) return e;
	}

	//include ssix in index range - spec is not clear whether this is forbidden
	if (start_range) *start_range = (u32) movie->root_sidx_offset;
	if (end_range) *end_range = (u32) gf_bs_get_position(bs)-1;

	return GF_OK;
}
