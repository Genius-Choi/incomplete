static void rpc_serve_client(ggml_backend_t backend, sockfd_t sockfd, size_t free_mem, size_t total_mem) {
    rpc_server server(backend);
    while (true) {
        uint8_t cmd;
        if (!recv_data(sockfd, &cmd, 1)) {
            break;
        }
        std::vector<uint8_t> input;
        std::vector<uint8_t> output;
        uint64_t input_size;
        if (!recv_data(sockfd, &input_size, sizeof(input_size))) {
            break;
        }
        input.resize(input_size);
        if (!recv_data(sockfd, input.data(), input_size)) {
            break;
        }
        bool ok = true;
        switch (cmd) {
            case ALLOC_BUFFER: {
                ok = server.alloc_buffer(input, output);
                break;
            }
            case GET_ALIGNMENT: {
                server.get_alignment(output);
                break;
            }
            case GET_MAX_SIZE: {
                server.get_max_size(output);
                break;
            }
            case BUFFER_GET_BASE: {
                ok = server.buffer_get_base(input, output);
                break;
            }
            case FREE_BUFFER: {
                ok = server.free_buffer(input);
                break;
            }
            case BUFFER_CLEAR: {
                ok = server.buffer_clear(input);
                break;
            }
            case SET_TENSOR: {
                ok = server.set_tensor(input);
                break;
            }
            case GET_TENSOR: {
                ok = server.get_tensor(input, output);
                break;
            }
            case COPY_TENSOR: {
                ok = server.copy_tensor(input, output);
                break;
            }
            case GRAPH_COMPUTE: {
                ok = server.graph_compute(input, output);
                break;
            }
            case GET_DEVICE_MEMORY: {
                // output serialization format: | free (8 bytes) | total (8 bytes) |
                output.resize(2*sizeof(uint64_t), 0);
                memcpy(output.data(), &free_mem, sizeof(free_mem));
                memcpy(output.data() + sizeof(uint64_t), &total_mem, sizeof(total_mem));
                break;
            }
            default: {
                fprintf(stderr, "Unknown command: %d\n", cmd);
                ok = false;
            }
        }
        if (!ok) {
            break;
        }
        uint64_t output_size = output.size();
        if (!send_data(sockfd, &output_size, sizeof(output_size))) {
            break;
        }
        if (!send_data(sockfd, output.data(), output_size)) {
            break;
        }
    }
}
