static int update_submodule(struct update_data *update_data)
{
	int ret;

	ret = determine_submodule_update_strategy(the_repository,
						  update_data->just_cloned,
						  update_data->sm_path,
						  update_data->update_default,
						  &update_data->update_strategy);
	if (ret)
		return ret;

	if (update_data->just_cloned)
		oidcpy(&update_data->suboid, null_oid());
	else if (resolve_gitlink_ref(update_data->sm_path, "HEAD", &update_data->suboid))
		return die_message(_("Unable to find current revision in submodule path '%s'"),
				   update_data->displaypath);

	if (update_data->remote) {
		char *remote_name;
		const char *branch;
		char *remote_ref;
		int code;

		code = get_default_remote_submodule(update_data->sm_path, &remote_name);
		if (code)
			return code;
		code = remote_submodule_branch(update_data->sm_path, &branch);
		if (code)
			return code;
		remote_ref = xstrfmt("refs/remotes/%s/%s", remote_name, branch);

		free(remote_name);

		if (!update_data->nofetch) {
			if (fetch_in_submodule(update_data->sm_path, update_data->depth,
					      0, NULL))
				return die_message(_("Unable to fetch in submodule path '%s'"),
						   update_data->sm_path);
		}

		if (resolve_gitlink_ref(update_data->sm_path, remote_ref, &update_data->oid))
			return die_message(_("Unable to find %s revision in submodule path '%s'"),
					   remote_ref, update_data->sm_path);

		free(remote_ref);
	}

	if (!oideq(&update_data->oid, &update_data->suboid) || update_data->force) {
		ret = run_update_procedure(update_data);
		if (ret)
			return ret;
	}

	if (update_data->recursive) {
		struct child_process cp = CHILD_PROCESS_INIT;
		struct update_data next = *update_data;

		next.prefix = NULL;
		oidcpy(&next.oid, null_oid());
		oidcpy(&next.suboid, null_oid());

		cp.dir = update_data->sm_path;
		cp.git_cmd = 1;
		prepare_submodule_repo_env(&cp.env);
		update_data_to_args(&next, &cp.args);

		ret = run_command(&cp);
		if (ret)
			die_message(_("Failed to recurse into submodule path '%s'"),
				    update_data->displaypath);
		return ret;
	}

	return 0;
}
