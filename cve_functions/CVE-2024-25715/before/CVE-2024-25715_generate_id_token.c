static char * generate_id_token(struct _oidc_config * config,
                                const char * username,
                                json_t * j_user,
                                json_t * j_client,
                                time_t now,
                                time_t auth_time,
                                const char * nonce,
                                json_t * j_amr,
                                const char * access_token,
                                const char * code,
                                const char * scopes,
                                json_t * j_claims_request,
                                const char * auth_req_id,
                                const char * refresh_token,
                                const char * s_hash,
                                const char * sid,
                                const char * ip_source) {
  jwt_t * jwt;
  jwa_alg alg = get_token_sign_alg(config, j_client, GLEWLWYD_TOKEN_TYPE_ID_TOKEN);
  jwk_t * jwk = get_jwk_sign(config, j_client, alg);
  int key_size = get_key_size_from_alg(r_jwa_alg_to_str(alg));
  char * token = NULL, at_hash_encoded[128] = {0}, c_hash_encoded[128] = {0}, rt_hash_encoded[128] = {0}, * sub = get_sub(config, username, j_client);
  unsigned char at_hash[128] = {0}, c_hash[128] = {0}, rt_hash[128] = {0};
  json_t * j_user_info;
  size_t at_hash_len = 128, at_hash_encoded_len = 0, c_hash_len = 128, c_hash_encoded_len = 0, rt_hash_len = 128, rt_hash_encoded_len = 0;
  gnutls_digest_algorithm_t dig_alg = GNUTLS_DIG_UNKNOWN;
  gnutls_datum_t hash_data;

  if (jwk != NULL && alg != R_JWA_ALG_UNKNOWN) {
    if (r_jwt_init(&jwt) == RHN_OK) {
      r_jwt_set_sign_alg(jwt, alg);
      if (sub != NULL) {
        if (key_size) {
          if ((j_user_info = get_userinfo(config, sub, j_user, j_claims_request, scopes)) != NULL) {
            json_object_set(j_user_info, "iss", json_object_get(config->j_params, "iss"));
            json_object_set(j_user_info, "aud", json_object_get(j_client, "client_id"));
            json_object_set_new(j_user_info, "exp", json_integer(((json_int_t)now) + config->access_token_duration));
            json_object_set_new(j_user_info, "iat", json_integer(now));
            json_object_set_new(j_user_info, "auth_time", json_integer(auth_time));
            json_object_set(j_user_info, "azp", json_object_get(j_client, "client_id"));
            if (!o_strnullempty(nonce)) {
              json_object_set_new(j_user_info, "nonce", json_string(nonce));
            }
            if (j_amr != NULL && json_array_size(j_amr)) {
              json_object_set(j_user_info, "amr", j_amr);
            }
            if (key_size == 256) dig_alg = GNUTLS_DIG_SHA256;
            else if (key_size == 384) dig_alg = GNUTLS_DIG_SHA384;
            else if (key_size == 512) dig_alg = GNUTLS_DIG_SHA512;
            if (access_token != NULL) {
              // Hash access_token using the key size for the hash size (SHA style of course!)
              // take the half left of the has, then encode in base64-url it
              if (dig_alg != GNUTLS_DIG_UNKNOWN) {
                hash_data.data = (unsigned char*)access_token;
                hash_data.size = (unsigned int)o_strlen(access_token);
                if (gnutls_fingerprint(dig_alg, &hash_data, at_hash, &at_hash_len) == GNUTLS_E_SUCCESS) {
                  if (o_base64url_encode(at_hash, at_hash_len/2, (unsigned char *)at_hash_encoded, &at_hash_encoded_len)) {
                    json_object_set_new(j_user_info, "at_hash", json_stringn(at_hash_encoded, at_hash_encoded_len));
                  } else {
                    y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error o_base64url_encode at_hash");
                  }
                } else {
                  y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error gnutls_fingerprint at_hash");
                }
              } else {
                y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error digest algorithm size '%d' not supported at_hash", key_size);
              }
            }
            if (code != NULL) {
              // Hash access_token using the key size for the hash size (SHA style of course!)
              // take the half left of the has, then encode in base64-url it
              if (dig_alg != GNUTLS_DIG_UNKNOWN) {
                hash_data.data = (unsigned char*)code;
                hash_data.size = (unsigned int)o_strlen(code);
                if (gnutls_fingerprint(dig_alg, &hash_data, c_hash, &c_hash_len) == GNUTLS_E_SUCCESS) {
                  if (o_base64url_encode(c_hash, c_hash_len/2, (unsigned char *)c_hash_encoded, &c_hash_encoded_len)) {
                    json_object_set_new(j_user_info, "c_hash", json_stringn(c_hash_encoded, c_hash_encoded_len));
                  } else {
                    y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error o_base64url_encode c_hash");
                  }
                } else {
                  y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error gnutls_fingerprint c_hash");
                }
              } else {
                y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error digest algorithm size '%d' not supported c_hash", key_size);
              }
            }
            if (s_hash != NULL) {
              json_object_set_new(j_user_info, "s_hash", json_string(s_hash));
            }
            if (auth_req_id != NULL) {
              json_object_set_new(j_user_info, "urn:openid:params:jwt:claim:auth_req_id", json_string(auth_req_id));
            }
            if (refresh_token != NULL) {
              // Hash access_token using the key size for the hash size (SHA style of course!)
              // take the half left of the hash, then encode in base64-url it
              if (dig_alg != GNUTLS_DIG_UNKNOWN) {
                hash_data.data = (unsigned char*)refresh_token;
                hash_data.size = (unsigned int)o_strlen(refresh_token);
                if (gnutls_fingerprint(dig_alg, &hash_data, rt_hash, &rt_hash_len) == GNUTLS_E_SUCCESS) {
                  if (o_base64url_encode(rt_hash, rt_hash_len/2, (unsigned char *)rt_hash_encoded, &rt_hash_encoded_len)) {
                    json_object_set_new(j_user_info, "urn:openid:params:jwt:claim:rt_hash", json_stringn(rt_hash_encoded, rt_hash_encoded_len));
                  } else {
                    y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error o_base64url_encode rt_hash");
                  }
                } else {
                  y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error gnutls_fingerprint rt_hash");
                }
              } else {
                y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - Error digest algorithm size '%d' not supported rt_hash", key_size);
              }
            }
            if (!o_strnullempty(sid)) {
              json_object_set_new(j_user_info, "sid", json_string(sid));
            }
            //jwt_add_grant(jwt, "acr", "plop"); // TODO?
            if (r_jwt_set_full_claims_json_t(jwt, j_user_info) == RHN_OK) {
              if ((token = r_jwt_serialize_signed(jwt, jwk, 0)) == NULL) {
                y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error r_jwt_serialize_signed");
              } else {
                y_log_message(Y_LOG_LEVEL_INFO, "Event oidc - Plugin '%s' - id_token generated for client '%s' granted by user '%s', origin: %s", config->name, json_string_value(json_object_get(j_client, "client_id")), username, ip_source);
              }
            } else {
              y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error jwt_add_grants_json");
            }
            json_decref(j_user_info);
          } else {
            y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error get_userinfo");
          }
        } else {
          y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error key_size");
        }
      } else {
        y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error get_sub");
      }
    } else {
      y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error r_jwt_init");
    }
    r_jwt_free(jwt);
  } else {
    y_log_message(Y_LOG_LEVEL_ERROR, "generate_id_token - oidc - Error no sign jwk available");
  }
  r_jwk_free(jwk);
  o_free(sub);
  return token;
}
