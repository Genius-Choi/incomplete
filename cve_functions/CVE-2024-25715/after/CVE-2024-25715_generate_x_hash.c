static char * generate_x_hash(struct _oidc_config * config, json_t * j_client, const char * value) {
  int key_size;
  gnutls_digest_algorithm_t dig_alg = GNUTLS_DIG_UNKNOWN;
  gnutls_datum_t hash_data;
  unsigned char x_hash[128] = {0};
  size_t x_hash_len = 128, x_hash_encoded_len = 0;
  char * to_return = NULL, x_hash_encoded[128] = {0};

  if (value != NULL && j_client != NULL) {
    key_size = get_key_size_from_alg(r_jwa_alg_to_str(get_token_sign_alg(config, j_client, GLEWLWYD_TOKEN_TYPE_ID_TOKEN)));
    if (key_size == 256) dig_alg = GNUTLS_DIG_SHA256;
    else if (key_size == 384) dig_alg = GNUTLS_DIG_SHA384;
    else if (key_size == 512) dig_alg = GNUTLS_DIG_SHA512;
    if (dig_alg != GNUTLS_DIG_UNKNOWN) {
      hash_data.data = (unsigned char*)value;
      hash_data.size = (unsigned int)o_strlen(value);
      if (gnutls_fingerprint(dig_alg, &hash_data, x_hash, &x_hash_len) == GNUTLS_E_SUCCESS) {
        if (o_base64url_encode(x_hash, x_hash_len/2, (unsigned char *)x_hash_encoded, &x_hash_encoded_len)) {
          to_return = o_strndup(x_hash_encoded, x_hash_encoded_len);
        } else {
          y_log_message(Y_LOG_LEVEL_ERROR, "generate_x_hash - Error o_base64url_encode x_hash");
        }
      } else {
        y_log_message(Y_LOG_LEVEL_ERROR, "generate_x_hash - Error gnutls_fingerprint x_hash");
      }
    } else {
      y_log_message(Y_LOG_LEVEL_ERROR, "generate_x_hash - Error digest algorithm size '%d' not supported x_hash", key_size);
    }
  }
  return to_return;
}
