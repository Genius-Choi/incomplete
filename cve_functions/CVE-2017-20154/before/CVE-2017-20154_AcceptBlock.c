bool CBlock::AcceptBlock()
{
    // Check for duplicate
    uint256 hash = GetHash();
    if (mapBlockIndex.count(hash))
        return error("AcceptBlock() : block already in mapBlockIndex");

    // Get the previous block index
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);
    if (mi == mapBlockIndex.end())
        return DoS(10, error("AcceptBlock() : cannot locate the previous block"));
    CBlockIndex* pindexPrev = (*mi).second;
    int nHeight = pindexPrev->nHeight+1;

    /* Don't accept v1 blocks after this point */
    if((fTestNet && (nTime > nTestnetSwitchV2)) || (!fTestNet && (nTime > nSwitchV2))) {
        CScript expect = CScript() << nHeight;
        if(!std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))
          return(DoS(100, error("AcceptBlock() : incorrect block height in coin base")));
    }

    /* Don't accept blocks with bogus nVersion numbers after this point */
    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {
        if(nVersion != 2)
          return(DoS(100, error("AcceptBlock() : incorrect block version")));
    }

    // Check for proof of work
    if (nBits != GetNextWorkRequired(pindexPrev, this))
        return DoS(100, error("AcceptBlock() : incorrect proof of work for block %d", nHeight));

    uint nOurTime   = (uint)GetAdjustedTime();

    // Check for time stamp (past limit #1)
    if(nTime <= (uint)pindexPrev->GetMedianTimePast())
      return(DoS(20, error("AcceptBlock() : block %s height %d has a time stamp behind the median",
        hash.ToString().substr(0,20).c_str(), nHeight)));

    // Soft fork 1: further restrictions
    if((fTestNet && (nHeight >= nTestnetSoftForkOne)) || (nHeight >= nSoftForkOne)) {

        if(nTime > (nOurTime + 10 * 60))
          return(DoS(5, error("AcceptBlock() : block %s height %d has a time stamp too far in the future",
            hash.ToString().substr(0,20).c_str(), nHeight)));

        if(nTime <= (pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))
          return(DoS(5, error("AcceptBlock() : block %s height %d rejected by the block limiter",
            hash.ToString().substr(0,20).c_str(), nHeight)));

        if(nTime <= (pindexPrev->GetBlockTime() - 10 * 60))
          return(DoS(20, error("AcceptBlock() : block %s height %d has a time stamp too far in the past",
            hash.ToString().substr(0,20).c_str(), nHeight)));

    }

    /* Soft fork 2 */
    if(!IsInitialBlockDownload() &&
      ((fTestNet && (nHeight >= nTestnetSoftForkTwo)) || (nHeight >= nSoftForkTwo))) {

        /* Check for time stamp (future limit) */
        if(nTime > (nOurTime + 5 * 60))
          return(DoS(5, error("AcceptBlock() [Soft Fork 2] : block %s height %d has a time stamp too far in the future",
            hash.ToString().substr(0,20).c_str(), nHeight)));

        /* Future travel detector for the block limiter */
        if((nTime > (nOurTime + 60)) &&
          ((pindexPrev->GetAverageTimePast(5, 45) + BLOCK_LIMITER_TIME) > nOurTime))
          return(DoS(5, error("AcceptBlock() : block %s height %d rejected by the future travel detector",
            hash.ToString().substr(0,20).c_str(), nHeight)));

    }

    // Check that all transactions are finalized
    BOOST_FOREACH(const CTransaction& tx, vtx)
        if (!tx.IsFinal(nHeight, GetBlockTime()))
            return DoS(10, error("AcceptBlock() : block %d contains a non-final transaction", nHeight));

    // Check if the block chain matches the known block chain up to a checkpoint
    if (!Checkpoints::CheckBlock(nHeight, hash))
        return DoS(100, error("AcceptBlock() : block %d is rejected by a regular checkpoint", nHeight));

    /* Check against advanced checkpoints */
    if(IsSyncCheckpointEnforced() &&
      !CheckSyncCheckpoint(hash, pindexPrev) &&
      !IsInitialBlockDownload())
      return(error("AcceptBlock() : block %s height %d rejected by the ACP",
        hash.ToString().substr(0,20).c_str(), nHeight));

    // Write block to history file
    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))
        return error("AcceptBlock() : out of disk space");
    unsigned int nFile = -1;
    unsigned int nBlockPos = 0;
    if (!WriteToDisk(nFile, nBlockPos))
        return error("AcceptBlock() : WriteToDisk failed");
    if (!AddToBlockIndex(nFile, nBlockPos))
        return error("AcceptBlock() : AddToBlockIndex failed");

    // Relay inventory, but don't relay old inventory during initial block download
    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();
    if (hashBestChain == hash)
    {
        LOCK(cs_vNodes);
        BOOST_FOREACH(CNode* pnode, vNodes)
            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))
                pnode->PushInventory(CInv(MSG_BLOCK, hash));
    }

    /* Process an advanced checkpoint pending */
    if(!IsInitialBlockDownload()) AcceptPendingSyncCheckpoint();

    return true;
}
