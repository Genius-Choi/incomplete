HttpStateData::forwardUpgrade(HttpHeader &hdrOut)
{
    if (!Config.http_upgrade_request_protocols)
        return; // forward nothing by default

    /* RFC 7230 section 6.7 paragraph 10:
     * A server MUST ignore an Upgrade header field that is received in
     * an HTTP/1.0 request.
     */
    if (request->http_ver == Http::ProtocolVersion(1,0))
        return;

    const auto &hdrIn = request->header;
    if (!hdrIn.has(Http::HdrType::UPGRADE))
        return;
    const auto upgradeIn = hdrIn.getList(Http::HdrType::UPGRADE);

    String upgradeOut;

    ACLFilledChecklist ch(nullptr, request.getRaw());
    ch.al = fwd->al;
    const char *pos = nullptr;
    const char *offeredStr = nullptr;
    int offeredStrLen = 0;
    while (strListGetItem(&upgradeIn, ',', &offeredStr, &offeredStrLen, &pos)) {
        const ProtocolView offeredProto(offeredStr, offeredStrLen);
        debugs(11, 5, "checks all rules applicable to " << offeredProto);
        Config.http_upgrade_request_protocols->forApplicable(offeredProto, [&ch, offeredStr, offeredStrLen, &upgradeOut] (const SBuf &cfgProto, const acl_access *guard) {
            debugs(11, 5, "checks " << cfgProto << " rule(s)");
            ch.changeAcl(guard);
            const auto answer = ch.fastCheck();
            if (answer.implicit)
                return false; // keep looking for an explicit rule match
            if (answer.allowed())
                strListAdd(upgradeOut, offeredStr, offeredStrLen);
            // else drop the offer (explicitly denied cases and ACL errors)
            return true; // stop after an explicit rule match or an error
        });
    }

    if (upgradeOut.size()) {
        hdrOut.putStr(Http::HdrType::UPGRADE, upgradeOut.termedBuf());

        /* RFC 7230 section 6.7 paragraph 10:
         * When Upgrade is sent, the sender MUST also send a Connection header
         * field that contains an "upgrade" connection option, in
         * order to prevent Upgrade from being accidentally forwarded by
         * intermediaries that might not implement the listed protocols.
         *
         * NP: Squid does not truly implement the protocol(s) in this Upgrade.
         * For now we are treating an explicit blind tunnel as "implemented"
         * regardless of the security implications.
         */
        hdrOut.putStr(Http::HdrType::CONNECTION, "upgrade");

        // Connection:close and Connection:keepalive confuse some Upgrade
        // recipients, so we do not send those headers. Our Upgrade request
        // implicitly offers connection persistency per HTTP/1.1 defaults.
        // Update the keepalive flag to reflect that offer.
        // * If the server upgrades, then we would not be talking HTTP past the
        //   HTTP 101 control message, and HTTP persistence would be irrelevant.
        // * Otherwise, our request will contradict onoff.server_pconns=off or
        //   other no-keepalive conditions (if any). We compensate by copying
        //   the original no-keepalive decision now and honoring it later.
        flags.forceClose = !flags.keepalive;
        flags.keepalive = true; // should already be true in most cases
    }
}
