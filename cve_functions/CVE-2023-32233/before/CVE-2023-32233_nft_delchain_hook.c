static int nft_delchain_hook(struct nft_ctx *ctx, struct nft_chain *chain,
			     struct netlink_ext_ack *extack)
{
	const struct nlattr * const *nla = ctx->nla;
	struct nft_chain_hook chain_hook = {};
	struct nft_base_chain *basechain;
	struct nft_hook *this, *hook;
	LIST_HEAD(chain_del_list);
	struct nft_trans *trans;
	int err;

	if (!nft_is_base_chain(chain))
		return -EOPNOTSUPP;

	basechain = nft_base_chain(chain);
	err = nft_chain_parse_hook(ctx->net, basechain, nla, &chain_hook,
				   ctx->family, chain->flags, extack);
	if (err < 0)
		return err;

	list_for_each_entry(this, &chain_hook.list, list) {
		hook = nft_hook_list_find(&basechain->hook_list, this);
		if (!hook) {
			err = -ENOENT;
			goto err_chain_del_hook;
		}
		list_move(&hook->list, &chain_del_list);
	}

	trans = nft_trans_alloc(ctx, NFT_MSG_DELCHAIN,
				sizeof(struct nft_trans_chain));
	if (!trans) {
		err = -ENOMEM;
		goto err_chain_del_hook;
	}

	nft_trans_basechain(trans) = basechain;
	nft_trans_chain_update(trans) = true;
	INIT_LIST_HEAD(&nft_trans_chain_hooks(trans));
	list_splice(&chain_del_list, &nft_trans_chain_hooks(trans));
	nft_chain_release_hook(&chain_hook);

	nft_trans_commit_list_add_tail(ctx->net, trans);

	return 0;

err_chain_del_hook:
	list_splice(&chain_del_list, &basechain->hook_list);
	nft_chain_release_hook(&chain_hook);

	return err;
}
