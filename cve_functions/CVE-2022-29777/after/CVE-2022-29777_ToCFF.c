    void CFontFileType1::ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream)
    {
        std::wstring sFontName = NSFile::CUtf8Converter::GetUnicodeFromCharPtr( m_sName, (LONG)strlen(m_sName) );
        CArray<std::wstring> aString;

        int nBias = 0;
        int nSubrsLen = m_arrSubrs.GetSize();
        if ( nSubrsLen < 1240 )
            nBias = 107;
        else if ( nSubrsLen < 33900 )
            nBias = 1131;
        else
            nBias = 32768;

        CArray<Type1Charstring> arrType2Charstrings;
        Type1Charstring oFirstCharstring;
        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x8B, false ) );
        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );
        arrType2Charstrings.Add( oFirstCharstring );
        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )
        {
            std::wstring sG = m_arrCharstrings[nIndex].sGlyph;
            if ( L"afii10090" == sG )
                int k = 10;
            arrType2Charstrings.Add( FlattenCharstring( m_arrCharstrings[nIndex].oData, nBias ) );
        }

        CArray<Type1Charstring> arrType2Subrs;

        //Type1Charstring oBias;
        ////oBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );
        //oBias.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );
        //for ( int nIndex = 0; nIndex < nBias; nIndex++ )
        //	arrType2Subrs.Add( oBias );

        for ( int nIndex = 0; nIndex < nSubrsLen; nIndex++ )
        {
            //if ( nIndex == 256 )
            //{
            //	Type1Charstring oBias;
            //	oBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );
            //	for ( int nIndex = 0; nIndex < nBias; nIndex++ )
            //		arrType2Subrs.Add( oBias );
            //}
            arrType2Subrs.Add( FlattenCharstring( m_arrSubrs[nIndex], 0 ) );
        }

        // Header
        TCharBuffer oHeader;
        oHeader.Write( "\x01\x00\x04\x04", 4 );

        // Name
        TCharBuffer oName;
        aString.RemoveAll();
        aString.Add( sFontName );
        CFFCreateIndexHeader( CharBufferWrite, &oName, aString );

        // Strings
        TCharBuffer oStrings;
        aString.RemoveAll();
        int nNewSID = CFF_STANDARD_STRINGS_COUNT;
        aString.Add( L"Version 0.11" );        nNewSID++; // Version
        aString.Add( L"See original notice" ); nNewSID++; // Notice
        aString.Add( sFontName );                 nNewSID++; // FullName
        aString.Add( sFontName );                 nNewSID++; // FamilyName
        aString.Add( L"Medium" );              nNewSID++; // Weight

        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )
        {
            int nSID = GetCFFStringIndex( m_arrCharstrings[nIndex].sGlyph.c_str() );
            if ( nSID < 0 )
            {
                aString.Add( m_arrCharstrings[nIndex].sGlyph );
                nSID = nNewSID;
                nNewSID++;
            }

            m_arrCharstrings[nIndex].nReserved = nSID;
        }

        CFFCreateIndexHeader( CharBufferWrite, &oStrings, aString );

        // GlobalSubrs
        TCharBuffer oGlobalSubrs;
        aString.RemoveAll(); // Записываем пустой массив
        CFFCreateIndexHeader( CharBufferWrite, &oGlobalSubrs, aString );

        // Charset
        TCharBuffer oCharset;
        oCharset.Write( (char)0x00 ); // Encoding

        int nGlyphsCount = m_arrCharstrings.GetSize();
        for ( int nIndex = 0; nIndex < nGlyphsCount; nIndex++ )
        {
            int nSID = m_arrCharstrings[nIndex].nReserved;
            oCharset.Write( (char)(nSID >> 8) );
            oCharset.Write( (char)(nSID & 0xFF) );
        }

        // Charstrings
        TCharBuffer oCharstrings;
        CFFCreateIndexHeader( NSFontConverter::CharBufferWrite, &oCharstrings, arrType2Charstrings );

        // Private
        TCharBuffer oPrivate;
        oPrivate.Write( "\x8b\x14", 2 ); // defaultWidth
        oPrivate.Write( "\x8b\x15", 2 ); // nominalWidth

        // Private: BlueValues
        if ( m_oPrivateDict.nBlueValues > 0 )
        {
            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[0] );
            for ( int nIndex = 1; nIndex < m_oPrivateDict.nBlueValues; nIndex++ )
                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[nIndex] - m_oPrivateDict.arrnBlueValues[nIndex - 1] );

            oPrivate.Write( (char)0x06 );
        }

        // Private: OtherBlues
        if ( m_oPrivateDict.nOtherBlues > 0 )
        {
            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[0] );
            for ( int nIndex = 1; nIndex < m_oPrivateDict.nOtherBlues; nIndex++ )
                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[nIndex] - m_oPrivateDict.arrnOtherBlues[nIndex - 1] );

            oPrivate.Write( (char)0x07 );
        }

        // Private: FamilyBlues
        if ( m_oPrivateDict.nFamilyBlues > 0 )
        {
            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[0] );
            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyBlues; nIndex++ )
                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[nIndex] - m_oPrivateDict.arrnFamilyBlues[nIndex - 1] );

            oPrivate.Write( (char)0x08 );
        }

        // Private: FamilyOtherBlues
        if ( m_oPrivateDict.nFamilyOtherBlues > 0 )
        {
            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[0] );
            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyOtherBlues; nIndex++ )
                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[nIndex] - m_oPrivateDict.arrnFamilyOtherBlues[nIndex - 1] );

            oPrivate.Write( (char)0x09 );
        }

        // Private: StemSnapH
        if ( m_oPrivateDict.nStemSnapH > 0 )
        {
            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[0] );
            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapH; nIndex++ )
                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[nIndex] - m_oPrivateDict.arrdStemSnapH[nIndex - 1] );

            oPrivate.Write( "\x0c\x0c" , 2);
        }

        // Private: StemSnapV
        if ( m_oPrivateDict.nStemSnapV > 0 )
        {
            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[0] );
            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapV; nIndex++ )
                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[nIndex] - m_oPrivateDict.arrdStemSnapV[nIndex - 1] );

            oPrivate.Write( "\x0c\x0d" , 2);
        }

        // Private: BlueShift
        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueShift );
        oPrivate.Write( "\x0c\x0a", 2 );

        // Private: BlueFuzz
        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueFuzz );
        oPrivate.Write( "\x0c\x0b", 2 );

        // Private: BlueScale
        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dBlueScale );
        oPrivate.Write( "\x0c\x09", 2 );

        // Private: LanguageGroup
        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nLanguageGroup );
        oPrivate.Write( "\x0c\x11", 2 );

        // Private: ExpansionFactor
        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dExpansionFactor );
        oPrivate.Write( "\x0c\x18", 2 );

        // Private: Subrs
        int nPrivateLen = oPrivate.nLen + (5 + 1);
        CFFEncodeNumber( CharBufferWrite, &oPrivate, nPrivateLen, true );
        oPrivate.Write( "\x13", 1 );

        // LocalSubrs
        TCharBuffer oLocalSubrs;
        CFFCreateIndexHeader( CharBufferWrite, &oLocalSubrs, arrType2Subrs );

        // Top Dict
        TCharBuffer oTopDict;
        oTopDict.Write( "\x00\x01\x04\x00\x00\x00\x01\x00\x00\0x00\x00", 11 );
        oTopDict.Write( "\xf8\x1b\x00", 3 ); // Version
        oTopDict.Write( "\xf8\x1c\x01", 3 ); // Notice
        oTopDict.Write( "\xf8\x1d\x02", 3 ); // FullName
        oTopDict.Write( "\xf8\x1e\x03", 3 ); // FamilyName
        oTopDict.Write( "\xf8\x1f\x04", 3 ); // Weight
        oTopDict.Write( "\x1c\x00\x00\x10", 4 ); // Encoding

        // BBox
        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[0] );
        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[1] );
        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[2] );
        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[3] );
        oTopDict.Write( "\x05", 1 );

        // Теперь оценим размер TopDict: Возьмем текущую длину, добавим к ней (4 * 5 + 3)
        // ( 4 числа, которые пишем по 5 байт + 3 байта на 3 команды)
        int nTopDictLen = oTopDict.nLen + ( 4 * 5 + 3);

        int nOffset = oHeader.nLen + oName.nLen + nTopDictLen + oStrings.nLen + oGlobalSubrs.nLen;
        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );
        oTopDict.Write( "\x0f", 1 ); // Charset

        nOffset += oCharset.nLen;//( arrType2Charstrings.GetSize() * 2 ) + 1;
        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );
        oTopDict.Write( "\x11", 1 ); // Charstrings

        CFFEncodeNumber( CharBufferWrite, &oTopDict, oPrivate.nLen, true );
        nOffset += oCharstrings.nLen;
        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );
        oTopDict.Write( "\x12", 1 ); // Private

        // Теперь запишем реальный размер TopDict
        int nTopDictDataLen = nTopDictLen - 10;
        oTopDict.sBuffer[7]  = ( nTopDictDataLen >> 24 ) & 0xFF;
        oTopDict.sBuffer[8]  = ( nTopDictDataLen >> 16 ) & 0xFF;
        oTopDict.sBuffer[9]  = ( nTopDictDataLen >> 8  ) & 0xFF;
        oTopDict.sBuffer[10] = nTopDictDataLen & 0xFF;

        // Записываем все в файл
        pOutputFunc( pOutputStream, oHeader.sBuffer,      oHeader.nLen      );
        pOutputFunc( pOutputStream, oName.sBuffer,        oName.nLen        );
        pOutputFunc( pOutputStream, oTopDict.sBuffer,     oTopDict.nLen     );
        pOutputFunc( pOutputStream, oStrings.sBuffer,     oStrings.nLen     );
        pOutputFunc( pOutputStream, oGlobalSubrs.sBuffer, oGlobalSubrs.nLen );
        pOutputFunc( pOutputStream, oCharset.sBuffer,     oCharset.nLen     );
        pOutputFunc( pOutputStream, oCharstrings.sBuffer, oCharstrings.nLen );
        pOutputFunc( pOutputStream, oPrivate.sBuffer,     oPrivate.nLen     );
        pOutputFunc( pOutputStream, oLocalSubrs.sBuffer,  oLocalSubrs.nLen  );
    }
