scroll_cursor_halfway(int atend)
{
    int		above = 0;
    linenr_T	topline;
    colnr_T	skipcol = 0;
    int		set_skipcol = FALSE;
#ifdef FEAT_DIFF
    int		topfill = 0;
#endif
    int		below = 0;
    int		used;
    lineoff_T	loff;
    lineoff_T	boff;
#ifdef FEAT_DIFF
    linenr_T	old_topline = curwin->w_topline;
#endif

#ifdef FEAT_PROP_POPUP
    // if the width changed this needs to be updated first
    may_update_popup_position();
#endif
    loff.lnum = boff.lnum = curwin->w_cursor.lnum;
#ifdef FEAT_FOLDING
    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);
#endif
#ifdef FEAT_DIFF
    used = plines_nofill(loff.lnum);
    loff.fill = 0;
    boff.fill = 0;
#else
    used = plines(loff.lnum);
#endif
    topline = loff.lnum;

    int half_height = 0;
    int smooth_scroll = FALSE;
    if (curwin->w_p_sms && curwin->w_p_wrap)
    {
	// 'smoothscroll' and 'wrap' are set
	smooth_scroll = TRUE;
	half_height = (curwin->w_height - used) / 2;
	used = 0;
    }

    while (topline > 1)
    {
	// If using smoothscroll, we can precisely scroll to the
	// exact point where the cursor is halfway down the screen.
	if (smooth_scroll)
	{
	    topline_back_winheight(&loff, FALSE);
	    if (loff.height == MAXCOL)
		break;
	    else
		used += loff.height;
	    if (used > half_height)
	    {
		if (used - loff.height < half_height)
		{
		    int plines_offset = used - half_height;
		    loff.height -= plines_offset;
		    used = half_height;

		    topline = loff.lnum;
#ifdef FEAT_DIFF
		    topfill = loff.fill;
#endif
		    skipcol = skipcol_from_plines(curwin, plines_offset);
		    set_skipcol = TRUE;
		}
		break;
	    }
	    topline = loff.lnum;
#ifdef FEAT_DIFF
	    topfill = loff.fill;
#endif
	    continue;
	}

	// If not using smoothscroll, we have to iteratively find how many
	// lines to scroll down to roughly fit the cursor.
	// This may not be right in the middle if the lines' physical height >
	// 1 (e.g. 'wrap' is on).

	if (below <= above)	    // add a line below the cursor first
	{
	    if (boff.lnum < curbuf->b_ml.ml_line_count)
	    {
		botline_forw(&boff);
		used += boff.height;
		if (used > curwin->w_height)
		    break;
		below += boff.height;
	    }
	    else
	    {
		++below;	    // count a "~" line
		if (atend)
		    ++used;
	    }
	}

	if (below > above)	    // add a line above the cursor
	{
	    topline_back(&loff);
	    if (loff.height == MAXCOL)
		used = MAXCOL;
	    else
		used += loff.height;
	    if (used > curwin->w_height)
		break;
	    above += loff.height;
	    topline = loff.lnum;
#ifdef FEAT_DIFF
	    topfill = loff.fill;
#endif
	}
    }
#ifdef FEAT_FOLDING
    if (!hasFolding(topline, &curwin->w_topline, NULL))
#endif
    {
	if (curwin->w_topline != topline
		|| set_skipcol
		|| curwin->w_skipcol != 0)
	{
	    curwin->w_topline = topline;
	    if (set_skipcol)
	    {
		curwin->w_skipcol = skipcol;
		redraw_later(UPD_NOT_VALID);
	    }
	    else
		reset_skipcol();
	}
    }
#ifdef FEAT_DIFF
    curwin->w_topfill = topfill;
    if (old_topline > curwin->w_topline + curwin->w_height)
	curwin->w_botfill = FALSE;
    check_topfill(curwin, FALSE);
#endif
    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
    curwin->w_valid |= VALID_TOPLINE;
}
