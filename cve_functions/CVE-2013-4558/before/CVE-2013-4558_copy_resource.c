copy_resource(const dav_resource *src,
              dav_resource *dst,
              int depth,
              dav_response **response)
{
  svn_error_t *serr;
  dav_error *err;
  const char *src_repos_path, *dst_repos_path;

  /* ### source must be from a collection under baseline control. the
     ### baseline will (implicitly) indicate the source revision, and the
     ### path will be derived simply from the URL path */

  /* ### the destination's parent must be a working collection */

  /* ### ben goofing around: */
  /*  char *msg;
      apr_psprintf
      (src->pool, "Got a COPY request with src arg '%s' and dst arg '%s'",
      src->uri, dst->uri);

      return dav_svn__new_error(src->pool, HTTP_NOT_IMPLEMENTED, 0, msg);
  */

  /* ### Safeguard: see issue #916, whereby we're allowing an
     auto-checkout of a baseline for PROPPATCHing, *without* creating
     a new baseline afterwards.  We need to safeguard here that nobody
     is calling COPY with the baseline as a Destination! */
  if (dst->baselined && dst->type == DAV_RESOURCE_TYPE_VERSION)
    return dav_svn__new_error(src->pool, HTTP_PRECONDITION_FAILED, 0,
                              "Illegal: COPY Destination is a baseline.");

  if (dst->type == DAV_RESOURCE_TYPE_REGULAR
      && !(dst->info->repos->autoversioning))
    return dav_svn__new_error(dst->pool, HTTP_METHOD_NOT_ALLOWED, 0,
                              "COPY called on regular resource, but "
                              "autoversioning is not active.");

  /* Auto-versioning copy of regular resource: */
  if (dst->type == DAV_RESOURCE_TYPE_REGULAR)
    {
      /* Change the VCR into a WR, in place.  This creates a txn and
         changes dst->info->root from a rev-root into a txn-root. */
      err = dav_svn__checkout(dst,
                              1 /* auto-checkout */,
                              0, 0, 0, NULL, NULL);
      if (err)
        return err;
    }

  src_repos_path = svn_repos_path(src->info->repos->repos, src->pool);
  dst_repos_path = svn_repos_path(dst->info->repos->repos, dst->pool);

  if (strcmp(src_repos_path, dst_repos_path) != 0)
    {
      /* Perhaps the source and dst repos use different path formats? */
      serr = svn_error_compose_create(
                svn_dirent_get_absolute(&src_repos_path, src_repos_path,
                                        src->pool),
                svn_dirent_get_absolute(&dst_repos_path, dst_repos_path,
                                        dst->pool));

      if (!serr && (strcmp(src_repos_path, dst_repos_path) != 0))
          return dav_svn__new_error_tag(
                dst->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                "Copy source and destination are in different repositories.",
                SVN_DAV_ERROR_NAMESPACE, SVN_DAV_ERROR_TAG);
    }
  else
      serr = SVN_NO_ERROR;

  if (!serr)
    {
      serr = svn_fs_copy(src->info->root.root,  /* root object of src rev*/
                         src->info->repos_path, /* relative path of src */
                         dst->info->root.root,  /* root object of dst txn*/
                         dst->info->repos_path, /* relative path of dst */
                         src->pool);
    }
  if (serr)
    return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                "Unable to make a filesystem copy.",
                                dst->pool);

  /* Auto-versioning commit of the txn. */
  if (dst->info->auto_checked_out)
    {
      /* This also changes the WR back into a VCR, in place. */
      err = dav_svn__checkin(dst, 0, NULL);
      if (err)
        return err;
    }

  return NULL;
}
