prep_working(dav_resource_combined *comb)
{
  apr_pool_t *pool = comb->res.pool;
  svn_error_t *serr;
  dav_error *derr;
  svn_node_kind_t kind;
  const char *txn_name = comb->priv.root.txn_name;

  /* A txnroot object will already have the txn_name filled in, but a
     DeltaV 'working resource' will only have the activity_id at this
     point. */
  if (txn_name == NULL)
    {
      txn_name = dav_svn__get_txn(comb->priv.repos,
                                  comb->priv.root.activity_id);
      if (txn_name == NULL)
        {
          return dav_svn__new_error(pool, HTTP_BAD_REQUEST, 0,
                                    "An unknown activity was specified in the "
                                    "URL. This is generally caused by a "
                                    "problem in the client software.");
        }
      comb->priv.root.txn_name = txn_name;
    }

  /* get the FS transaction, given its name */
  serr = svn_fs_open_txn(&comb->priv.root.txn, comb->priv.repos->fs, txn_name,
                         pool);
  if (serr != NULL)
    {
      if (serr->apr_err == SVN_ERR_FS_NO_SUCH_TRANSACTION)
        {
          svn_error_clear(serr);
          return dav_svn__new_error(pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                                    "An activity was specified and found, but "
                                    "the corresponding SVN FS transaction was "
                                    "not found.");
        }
      return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                  "Could not open the SVN FS transaction "
                                  "corresponding to the specified activity.",
                                  pool);
    }

  if (comb->res.baselined)
    {
      /* a Working Baseline */

      /* if the transaction exists, then the working resource exists */
      comb->res.exists = TRUE;

      return NULL;
    }

  /* Set the txn author if not previously set.  Protect against multi-author
   * commits by verifying authenticated user associated with the current
   * request is the same as the txn author.
   * Note that anonymous requests are being excluded as being a change
   * in author, because the commit may touch areas of the repository
   * that are anonymous writeable as well as areas that are not.
   */
  if (comb->priv.repos->username)
    {
      svn_string_t *current_author;
      svn_string_t request_author;

      serr = svn_fs_txn_prop(&current_author, comb->priv.root.txn,
                             SVN_PROP_REVISION_AUTHOR, pool);
      if (serr != NULL)
        {
          return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                   "Failed to retrieve author of the SVN FS transaction "
                   "corresponding to the specified activity.",
                   pool);
        }

      request_author.data = comb->priv.repos->username;
      request_author.len = strlen(request_author.data);
      if (!current_author)
        {
          serr = svn_fs_change_txn_prop(comb->priv.root.txn,
                                        SVN_PROP_REVISION_AUTHOR,
                                        &request_author, pool);
          if (serr != NULL)
            {
              return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                       "Failed to set the author of the SVN FS transaction "
                       "corresponding to the specified activity.",
                       pool);
            }
        }
      else if (!svn_string_compare(current_author, &request_author))
        {
          return dav_svn__new_error(pool, HTTP_NOT_IMPLEMENTED, 0,
                                    "Multi-author commits not supported.");
        }
    }

  /* get the root of the tree */
  serr = svn_fs_txn_root(&comb->priv.root.root, comb->priv.root.txn, pool);
  if (serr != NULL)
    {
      return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                  "Could not open the (transaction) root of "
                                  "the repository",
                                  pool);
    }

  derr = fs_check_path(&kind, comb->priv.root.root,
                       comb->priv.repos_path, pool);
  if (derr != NULL)
    return derr;

  comb->res.exists = (kind != svn_node_none);
  comb->res.collection = (kind == svn_node_dir);

  return NULL;
}
