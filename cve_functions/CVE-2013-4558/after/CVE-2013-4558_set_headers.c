set_headers(request_rec *r, const dav_resource *resource)
{
  svn_error_t *serr;
  svn_filesize_t length;
  const char *mimetype = NULL;
  apr_time_t last_modified;

  if (!resource->exists)
    return NULL;

  last_modified = get_last_modified(resource);
  if (last_modified != -1)
    {
      /* Note the modification time for the requested resource, and
         include the Last-Modified header in the response. */
      ap_update_mtime(r, last_modified);
      ap_set_last_modified(r);
    }

  /* generate our etag and place it into the output */
  apr_table_setn(r->headers_out, "ETag",
                 dav_svn__getetag(resource, resource->pool));

  /* As version resources don't change, encourage caching. */
  if ((resource->type == DAV_RESOURCE_TYPE_REGULAR
       && resource->versioned && !resource->collection)
      || resource->type == DAV_RESOURCE_TYPE_VERSION)
    /* Cache resource for one week (specified in seconds). */
    apr_table_setn(r->headers_out, "Cache-Control", "max-age=604800");

  /* we accept byte-ranges */
  apr_table_setn(r->headers_out, "Accept-Ranges", "bytes");

  /* For a directory, we will send text/html or text/xml. If we have a delta
     base, then we will always be generating an svndiff.  Otherwise,
     we need to fetch the appropriate MIME type from the resource's
     properties (and use text/plain if it isn't there). */
  if (resource->collection)
    {
      if (resource->info->repos->xslt_uri)
        mimetype = "text/xml";
      else
        mimetype = "text/html; charset=UTF-8";
    }
  else if (resource->info->delta_base != NULL)
    {
      dav_svn__uri_info info;

      /* First order of business is to parse it. */
      serr = dav_svn__simple_parse_uri(&info, resource,
                                       resource->info->delta_base,
                                       resource->pool);

      /* If we successfully parse the base URL, then send an svndiff. */
      if ((serr == NULL) && (info.rev != SVN_INVALID_REVNUM))
        {
          mimetype = SVN_SVNDIFF_MIME_TYPE;

          /* Note the base that this svndiff is based on, and tell any
             intermediate caching proxies that this header is
             significant.  */
          apr_table_setn(r->headers_out, "Vary", SVN_DAV_DELTA_BASE_HEADER);
          apr_table_setn(r->headers_out, SVN_DAV_DELTA_BASE_HEADER,
                         resource->info->delta_base);
        }
      svn_error_clear(serr);
    }

  if ((mimetype == NULL)
      && ((resource->type == DAV_RESOURCE_TYPE_VERSION)
          || (resource->type == DAV_RESOURCE_TYPE_REGULAR))
      && (resource->info->repos_path != NULL))
    {
      svn_string_t *value;

      serr = svn_fs_node_prop(&value,
                              resource->info->root.root,
                              resource->info->repos_path,
                              SVN_PROP_MIME_TYPE,
                              resource->pool);
      if (serr != NULL)
        return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                    "could not fetch the resource's MIME type",
                                    resource->pool);

      if (value)
        mimetype = value->data;
      else if ((! resource->info->repos->is_svn_client)
               && r->content_type)
        mimetype = r->content_type;

      /* If we found a MIME type, we'll make sure it's Subversion-friendly. */
      if (mimetype)
        {
          if ((serr = svn_mime_type_validate(mimetype, resource->pool)))
            {
              /* Probably serr->apr == SVN_ERR_BAD_MIME_TYPE, but there's
                 no point even checking.  No matter what the error is, we
                 can't use this MIME type.  */
              svn_error_clear(serr);
              mimetype = NULL;
            }
        }

      /* We've found/calculated/validated no usable MIME type.  We
         could fall back to "application/octet-stream" (aka "bag o'
         bytes"), but many browsers have grown to expect "text/plain"
         to mean "*shrug*", and kick off their own MIME type detection
         routines when they see it.  So we'll use "text/plain".

         ### Why not just avoid sending a Content-type at all?  Is
         ### that just bad form for HTTP?  */
      if (! mimetype)
        mimetype = "text/plain";


      /* if we aren't sending a diff and aren't expanding keywords,
         then we know the exact length of the file, so set up the
         Content-Length header. */
      if (! resource->info->keyword_subst)
        {
          serr = svn_fs_file_length(&length,
                                    resource->info->root.root,
                                    resource->info->repos_path,
                                    resource->pool);
          if (serr != NULL)
            {
              return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                          "could not fetch the resource length",
                                          resource->pool);
            }
          ap_set_content_length(r, (apr_off_t) length);
        }
    }

  /* set the discovered MIME type */
  /* ### it would be best to do this during the findct phase... */
  ap_set_content_type(r, mimetype);

  return NULL;
}
