remove_resource(dav_resource *resource, dav_response **response)
{
  svn_error_t *serr;
  dav_error *err;
  apr_hash_t *locks;

  /* Only activities, working resources, regular resources, and
     certain private resources can be deleted... */
  if (! (resource->type == DAV_RESOURCE_TYPE_WORKING
         || resource->type == DAV_RESOURCE_TYPE_REGULAR
         || resource->type == DAV_RESOURCE_TYPE_ACTIVITY
         || (resource->type == DAV_RESOURCE_TYPE_PRIVATE
             && resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)))
    return dav_svn__new_error(resource->pool, HTTP_METHOD_NOT_ALLOWED, 0,
                              "DELETE called on invalid resource type.");

  /* ...and regular resources only if autoversioning is turned on. */
  if (resource->type == DAV_RESOURCE_TYPE_REGULAR
      && ! (resource->info->repos->autoversioning))
    return dav_svn__new_error(resource->pool, HTTP_METHOD_NOT_ALLOWED, 0,
                              "DELETE called on regular resource, but "
                              "autoversioning is not active.");

  /* Handle activity deletions (early exit). */
  if (resource->type == DAV_RESOURCE_TYPE_ACTIVITY)
    {
      return dav_svn__delete_activity(resource->info->repos,
                                      resource->info->root.activity_id);
    }

  /* Handle deletions of transaction collections (early exit) */
  if (resource->type == DAV_RESOURCE_TYPE_PRIVATE
      && resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)
    {
      if (resource->info->root.vtxn_name)
        return dav_svn__delete_activity(resource->info->repos,
                                        resource->info->root.vtxn_name);
      else
        return dav_svn__abort_txn(resource->info->repos,
                                  resource->info->root.txn_name,
                                  resource->pool);
    }

  /* ### note that the parent was checked out at some point, and this
     ### is being preformed relative to the working rsrc for that parent */

  /* NOTE: strictly speaking, we cannot determine whether the parent was
     ever checked out, and that this working resource is relative to that
     checked out parent. It is entirely possible the client checked out
     the target resource and just deleted it. Subversion doesn't mind, but
     this does imply we are not enforcing the "checkout the parent, then
     delete from within" semantic. */

  /* Auto-versioning delete of regular resource: */
  if (resource->type == DAV_RESOURCE_TYPE_REGULAR)
    {
      /* Change the VCR into a WR, in place.  This creates a txn and
         changes resource->info->root from a rev-root into a txn-root. */
      err = dav_svn__checkout(resource,
                              1 /* auto-checkout */,
                              0, 0, 0, NULL, NULL);
      if (err)
        return err;
    }

  /* Sanity check: an svn client may have sent a custom request header
     containing the revision of the item it thinks it's deleting.  In
     this case, we enforce the svn-specific semantic that the item
     must be up-to-date. */
  if (SVN_IS_VALID_REVNUM(resource->info->version_name))
    {
      svn_revnum_t created_rev;
      serr = svn_fs_node_created_rev(&created_rev,
                                     resource->info->root.root,
                                     resource->info->repos_path,
                                     resource->pool);
      if (serr)
        return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                    "Could not get created rev of resource",
                                    resource->pool);

      if (resource->info->version_name < created_rev)
        {
          serr = svn_error_createf(SVN_ERR_RA_OUT_OF_DATE, NULL,
                                   "Item '%s' is out of date",
                                   resource->info->repos_path);
          return dav_svn__convert_err(serr, HTTP_CONFLICT,
                                      "Can't DELETE out-of-date resource",
                                      resource->pool);
        }
    }

  /* Before attempting the filesystem delete, we need to push any
     incoming lock-tokens into the filesystem's access_t.  Normally
     they come in via 'If:' header, and get_resource()
     automatically notices them and does this work for us.  In the
     case of a directory deletion, however, svn clients are sending
     'child' lock-tokens in the DELETE request body. */

  err = dav_svn__build_lock_hash(&locks, resource->info->r,
                                 resource->info->repos_path, resource->pool);
  if (err != NULL)
    return err;

  if (apr_hash_count(locks))
    {
      err = dav_svn__push_locks(resource, locks, resource->pool);
      if (err != NULL)
        return err;
    }

  if ((serr = svn_fs_delete(resource->info->root.root,
                            resource->info->repos_path,
                            resource->pool)) != NULL)
    {
      /* ### need a better error */
      return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                  "Could not delete the resource",
                                  resource->pool);
    }

  /* Auto-versioning commit of the txn. */
  if (resource->info->auto_checked_out)
    {
      /* This also changes the WR back into a VCR, in place. */
      err = dav_svn__checkin(resource, 0, NULL);
      if (err)
        return err;
    }

  return NULL;
}
