open_stream(const dav_resource *resource,
            dav_stream_mode mode,
            dav_stream **stream)
{
  svn_node_kind_t kind;
  dav_error *derr;
  svn_error_t *serr;

  if (mode == DAV_MODE_WRITE_TRUNC || mode == DAV_MODE_WRITE_SEEKABLE)
    {
      if (resource->type != DAV_RESOURCE_TYPE_WORKING)
        {
          return dav_svn__new_error(resource->pool, HTTP_METHOD_NOT_ALLOWED, 0,
                                    "Resource body changes may only be made to "
                                    "working resources (at this time).");
        }
    }

  /* ### TODO:  Can we support range writes someday? */
  if (mode == DAV_MODE_WRITE_SEEKABLE)
    {
      return dav_svn__new_error(resource->pool, HTTP_NOT_IMPLEMENTED, 0,
                                "Resource body writes cannot use ranges "
                                "(at this time).");
    }

  /* start building the stream structure */
  *stream = apr_pcalloc(resource->pool, sizeof(**stream));
  (*stream)->res = resource;

  derr = fs_check_path(&kind, resource->info->root.root,
                       resource->info->repos_path, resource->pool);
  if (derr != NULL)
    return derr;

  if (kind == svn_node_none) /* No existing file. */
    {
      serr = svn_fs_make_file(resource->info->root.root,
                              resource->info->repos_path,
                              resource->pool);

      if (serr != NULL)
        {
          return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                      "Could not create file within the "
                                      "repository.",
                                      resource->pool);
        }
    }

  /* if the working-resource was auto-checked-out (i.e. came into
     existence through the autoversioning feature), then possibly set
     the svn:mime-type property based on whatever value mod_mime has
     chosen.  If the path already has an svn:mime-type property
     set, do nothing. */
  if (resource->info->auto_checked_out
      && resource->info->r->content_type)
    {
      svn_string_t *mime_type;

      serr = svn_fs_node_prop(&mime_type,
                              resource->info->root.root,
                              resource->info->repos_path,
                              SVN_PROP_MIME_TYPE,
                              resource->pool);

      if (serr != NULL)
        {
          return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                      "Error fetching mime-type property.",
                                      resource->pool);
        }

      if (!mime_type)
        {
          serr = svn_fs_change_node_prop(resource->info->root.root,
                                         resource->info->repos_path,
                                         SVN_PROP_MIME_TYPE,
                                         svn_string_create
                                             (resource->info->r->content_type,
                                              resource->pool),
                                         resource->pool);
          if (serr != NULL)
            {
              return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                          "Could not set mime-type property.",
                                          resource->pool);
            }
        }
    }

  serr = svn_fs_apply_textdelta(&(*stream)->delta_handler,
                                &(*stream)->delta_baton,
                                resource->info->root.root,
                                resource->info->repos_path,
                                resource->info->base_checksum,
                                resource->info->result_checksum,
                                resource->pool);

  if (serr != NULL)
    {
      return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                  "Could not prepare to write the file",
                                  resource->pool);
    }

  /* if the incoming data is an SVNDIFF, then create a stream that
     will process the data into windows and invoke the FS window handler
     when a window is ready. */
  /* ### we need a better way to check the content-type! this is bogus
     ### because we're effectively looking at the request_rec. doubly
     ### bogus because this means you cannot open arbitrary streams and
     ### feed them content (the type is always tied to a request_rec).
     ### probably ought to pass the type to open_stream */
  if (resource->info->is_svndiff)
    {
      (*stream)->wstream =
        svn_txdelta_parse_svndiff((*stream)->delta_handler,
                                  (*stream)->delta_baton,
                                  TRUE,
                                  resource->pool);
    }

  return NULL;
}
