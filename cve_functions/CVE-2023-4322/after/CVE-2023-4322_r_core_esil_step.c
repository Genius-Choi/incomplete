R_API int r_core_esil_step(RCore *core, ut64 until_addr, const char *until_expr, ut64 *prev_addr, bool stepOver) {
#define return_tail(x) { tail_return_value = x; goto tail_return; }
	int tail_return_value = 0;
	int ret;
	ut8 code[32];
	RAnalOp op = {0};
	REsil *esil = core->anal->esil;
	// esil->trap = 0;
	const char *_pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	if (R_STR_ISEMPTY (_pcname)) {
		R_LOG_ERROR ("Cannot find =PC in current reg profile");
		return 0;
	}
	char *pcname = strdup (_pcname);
	const bool r2wars = r_config_get_b (core->config, "cfg.r2wars");
	const bool breakoninvalid = r_config_get_b (core->config, "esil.breakoninvalid");
	const int esiltimeout = r_config_get_i (core->config, "esil.timeout");
	ut64 startTime = 0;

	if (esiltimeout > 0) {
		startTime = r_time_now_mono ();
	}
	r_cons_break_push (NULL, NULL);
	ut64 addr = -1;
	ut64 oaddr = -1;
	int minopsz = r_arch_info (core->anal->arch, R_ARCH_INFO_MIN_OP_SIZE);
	ut64 naddr = addr + minopsz;
	bool notfirst = false;
	for (; true; r_anal_op_fini (&op)) {
		esil->trap = 0;
		oaddr = addr;
		addr = r_reg_getv (core->anal->reg, "PC");
		if (notfirst && addr == oaddr) {
			r_reg_setv (core->anal->reg, "PC", naddr);
			addr = naddr;
		} else {
			notfirst = true;
		}
		R_LOG_DEBUG ("esil step at 0x%08"PFMT64x, addr);
		if (r_cons_is_breaked ()) {
			R_LOG_INFO ("[+] ESIL emulation interrupted at 0x%08" PFMT64x, addr);
			return_tail (0);
		}
		// Break if we have exceeded esil.timeout
		if (esiltimeout > 0) {
			ut64 elapsedTime = r_time_now_mono () - startTime;
			elapsedTime >>= 20;
			if (elapsedTime >= esiltimeout) {
				R_LOG_INFO ("[ESIL] Timeout exceeded");
				return_tail (0);
			}
		}
		if (prev_addr) {
			*prev_addr = addr;
		}
		const int perm = esil->exectrap ? R_PERM_X: 0;
		if (!r_io_is_valid_offset (core->io, addr, perm)) {
			esil->trap = R_ANAL_TRAP_EXEC_ERR;
			esil->trap_code = addr;
			R_LOG_INFO ("[ESIL] Trap, trying to execute on non-executable memory");
			return_tail (1);
		}
		// eprintf ("addr %llx\n", addr);
		r_asm_set_pc (core->rasm, addr);
		// run esil pin command here
		const char *pincmd = r_anal_pin_call (core->anal, addr);
		if (pincmd) {
			r_core_cmd0 (core, pincmd);
			ut64 pc = r_reg_getv (core->anal->reg, pcname);
			if (addr != pc) {
				R_LOG_ERROR ("pincmd fail");
				return_tail (1);
			}
		}
		int dataAlign = r_anal_archinfo (esil->anal, R_ANAL_ARCHINFO_DATA_ALIGN);
		if (dataAlign > 1) {
			if (addr % dataAlign) {
				if (esil->cmd && R_STR_ISNOTEMPTY (esil->cmd_trap)) {
					esil->cmd (esil, esil->cmd_trap, addr, R_ANAL_TRAP_UNALIGNED);
				}
				if (breakoninvalid) {
					R_LOG_INFO ("Execution stopped on unaligned instruction (see e?esil.breakoninvalid)");
					return_tail (0);
				}
			}
		}
		(void) r_io_read_at (core->io, addr, code, sizeof (code));
		// TODO: sometimes this is dupe
		ret = r_anal_op (core->anal, &op, addr, code, sizeof (code), R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);
		naddr = addr + op.size;
		// if type is JMP then we execute the next N instructions
		// update the esil pointer because RAnal.op() can change it
		esil = core->anal->esil;
		if (op.size < 1 || ret < 1) {
			// eprintf ("esil trap\n");
			if (esil->cmd && R_STR_ISNOTEMPTY (esil->cmd_trap)) {
				esil->cmd (esil, esil->cmd_trap, addr, R_ANAL_TRAP_INVALID);
			}
			if (breakoninvalid) {
				R_LOG_INFO ("Stopped execution in an invalid instruction (see e??esil.breakoninvalid)");
				return_tail (0);
			}
			if (op.size < 1) {
				op.size = 1; // avoid inverted stepping
			}
		}
		if (stepOver) {
			switch (op.type) {
			case R_ANAL_OP_TYPE_SWI:
			case R_ANAL_OP_TYPE_UCALL:
			case R_ANAL_OP_TYPE_CALL:
			case R_ANAL_OP_TYPE_JMP:
			case R_ANAL_OP_TYPE_RCALL:
			case R_ANAL_OP_TYPE_RJMP:
			case R_ANAL_OP_TYPE_CJMP:
			case R_ANAL_OP_TYPE_RET:
			case R_ANAL_OP_TYPE_CRET:
			case R_ANAL_OP_TYPE_UJMP:
				if (addr == until_addr) {
					return_tail (0);
				} else {
					r_reg_setv (core->anal->reg, pcname, op.addr + op.size);
					r_reg_setv (core->dbg->reg, pcname, op.addr + op.size);
				}
				return_tail (1);
			}
		}
		if (r2wars) {
			// this is x86 and r2wars specific, shouldnt hurt outside x86
			ut64 vECX = r_reg_getv (core->anal->reg, "ecx");
			if (op.prefix  & R_ANAL_OP_PREFIX_REP && vECX > 1) {
				//char *tmp = strstr (op.esil.ptr, ",ecx,?{,5,GOTO,}");
				char *tmp = strstr (op.esil.ptr, ",0,GOTO");
				if (tmp) {
					tmp[0] = 0;
					op.esil.len -= 7; //16;
				} else {
					r_reg_setv (core->anal->reg, pcname, addr + op.size);
				}
			} else {
				r_reg_setv (core->anal->reg, pcname, addr + op.size);
			}
		} else {
			r_reg_setv (core->anal->reg, pcname, addr + op.size);
		}
		if (ret) {
			r_esil_set_pc (esil, addr);
			const char *e = R_STRBUF_SAFEGET (&op.esil);
			if (core->dbg->trace->enabled) {
				RReg *reg = core->dbg->reg;
				core->dbg->reg = core->anal->reg;
				r_debug_trace_op (core->dbg, &op);
				core->dbg->reg = reg;
			} else if (R_STR_ISNOTEMPTY (e)) {
				r_esil_parse (esil, e);
				if (esil->trap) {
					R_LOG_WARN ("ESIL TRAP %d/%d ON %s at 0x%08"PFMT64x,
							esil->trap, esil->trap_code, e, addr);
					if (r_config_get_b (core->config, "esil.exectrap")) {
						R_LOG_INFO ("ESIL TRAP ignored");
						esil->trap = false;
					}
				}
#if 0
				// XXX thats not related to arch plugins, and wonder if its useful at all or we want it as part of the anal or esil plugs
				if (core->anal->cur && core->anal->cur->esil_post_loop) {
					core->anal->cur->esil_post_loop (esil, &op);
				}
#endif
				// warn if esil stack is not empty
				r_esil_stack_free (esil);
			}
			bool isNextFall = false;
			if (op.type == R_ANAL_OP_TYPE_CJMP) {
				int err = 0;
				ut64 pc = r_reg_getv (core->anal->reg, pcname);
				if (err) {
					R_LOG_ERROR ("Missing PC register in the current profile");
					break;
				}
				if (pc == addr + op.size) {
					// do not opdelay here
					isNextFall = true;
				}
			}
			// only support 1 slot for now
			if (op.delay && !isNextFall) {
				ut8 code2[32];
				// ut64 naddr = addr + op.size;
				RAnalOp op2 = {0};
				// emulate only 1 instruction
				r_esil_set_pc (esil, naddr);
				(void)r_io_read_at (core->io, naddr, code2, sizeof (code2));
				// TODO: sometimes this is dupe
				ret = r_anal_op (core->anal, &op2, naddr, code2, sizeof (code2), R_ARCH_OP_MASK_ESIL | R_ARCH_OP_MASK_HINT);
				if (ret > 0) {
					switch (op2.type) {
					case R_ANAL_OP_TYPE_CJMP:
					case R_ANAL_OP_TYPE_JMP:
					case R_ANAL_OP_TYPE_CRET:
					case R_ANAL_OP_TYPE_RET:
						// branches are illegal in a delay slot
						esil->trap = R_ANAL_TRAP_EXEC_ERR;
						esil->trap_code = addr;
						R_LOG_INFO ("[ESIL] Trap, trying to execute a branch in a delay slot");
						return_tail (1);
						break;
					}
					const char *e = R_STRBUF_SAFEGET (&op2.esil);
					if (R_STR_ISNOTEMPTY (e)) {
						r_esil_parse (esil, e);
						esil->trap = false; // ignore traps on delayed instructions for now
					}
				} else {
					R_LOG_ERROR ("Invalid instruction at 0x%08"PFMT64x, naddr);
				}
				r_anal_op_fini (&op2);
			}
			tail_return_value = 1;
		}
		// esil->verbose ?
		// eprintf ("REPE 0x%llx %s => 0x%llx\n", addr, R_STRBUF_SAFEGET (&op.esil), r_reg_getv (core->anal->reg, "PC"));
		ut64 pc = r_reg_getv (core->anal->reg, pcname);
		if (pc == UT64_MAX || pc == UT32_MAX) {
			R_LOG_ERROR ("Invalid program counter PC=-1 coming from 0x%08"PFMT64x, addr);
			break;
		}
		if (core->anal->config->codealign > 0) {
			pc -= (pc % core->anal->config->codealign);
			r_reg_setv (core->anal->reg, pcname, pc);
			r_reg_setv (core->dbg->reg, pcname, pc);
		}
		st64 follow = (st64)r_config_get_i (core->config, "dbg.follow");
		if (follow > 0) {
			if ((pc < core->offset) || (pc > (core->offset + follow))) {
				r_core_seek (core, pc, true);
			}
		}
		// check breakpoints
		if (r_bp_get_at (core->dbg->bp, pc)) {
			R_LOG_INFO ("esil breakpoint hit at 0x%"PFMT64x, pc);
			return_tail (0);
		}
		// check addr
		if (until_addr != UT64_MAX) {
			if (pc == until_addr) {
				return_tail (0);
			}
			continue;
		}
#if 1
		if (esil->trap) {
			R_LOG_DEBUG ("TRAP");
			return_tail (0);
		}
#endif
		if (until_expr) {
			// eprintf ("CHK %s\n", until_expr);
			if (r_esil_condition (esil, until_expr)) {
				R_LOG_INFO ("ESIL BREAK!");
				return_tail (0);
			}
			esil->trap = false;
			continue;
		}
		break;
	}
tail_return:
	r_anal_op_fini (&op);
	r_cons_break_pop ();
	free (pcname);
	return tail_return_value;
}
