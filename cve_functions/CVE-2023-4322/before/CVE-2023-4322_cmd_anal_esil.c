static void cmd_anal_esil(RCore *core, const char *input, bool verbose) {
	REsil *esil = core->anal->esil;
	ut64 addr = core->offset;
	ut64 adr ;
	char *n, *n1;
	int off;
	ut64 until_addr = UT64_MAX;

	const char *until_expr = NULL;
	RAnalOp *op = NULL;

	switch (input[0]) {
	case 'v': // "aev"
		r_core_visual_esil (core, r_str_trim_head_ro (input + 1));
		break;
	case 'p': // "aep"
		switch (input[1]) {
		case 'a': // "aepa"
			{
				ut64 at = core->offset;
				if (input[2] == ' ') {
					at = r_num_math (core->num, input + 2);
				}
				// get flag in current offset
				// find a pin named like the flag, skip dots if any
				RFlagItem *f = r_flag_get_by_spaces (core->flags, at, R_FLAGS_FS_SYMBOLS, R_FLAGS_FS_IMPORTS, NULL);
				if (!f) {
					f = r_flag_get_i (core->flags, at);
				}
				if (f) {
					const char *last = r_str_rchr (f->name, NULL, '.');
					const char *pin_name = last? last + 1: f->name;
					const char *havepin = r_anal_pin_get (core->anal, pin_name);
					if (havepin) {
						r_core_cmdf (core, "aep %s @ 0x%08" PFMT64x, pin_name, at);
					}
				}
			}
			break;
		case '.': // "aep."
			{
			const char *n = r_anal_pin_at (core->anal, core->offset);
			if (R_STR_ISNOTEMPTY (n)) {
				r_cons_printf ("%s\n", n);
			}
			}
			break;
		case 'c': // "aepc"
			if (input[2] == ' ' || input[2] == '=') {
				// seek to this address
				reg_name_roll_set (core, "PC", r_num_math (core->num, input + 3));
				r_core_cmd0 (core, ".ar*");
			} else {
				r_core_cmd_help_match (core, help_msg_aep, "aepc", true);
			}
			break;
		case 'k':
			{
				char *out = sdb_querys (core->anal->sdb_pins, NULL, 0, r_str_trim_head_ro (input + 3));
				if (out) {
					r_cons_printf ("%s\n", out);
					free (out);
				}
			}
			break;
		case '*':
		case 0:
			r_anal_pin_list (core->anal);
			break;
		case '-':
			if (input[2] == '*') {
				r_anal_pin_init (core->anal);
			} else {
				if (input[2]) {
					addr = r_num_math (core->num, input + 2);
				}
				r_anal_pin_unset (core->anal, addr);
			}
			break;
		case ' ':
			r_anal_pin (core->anal, addr, input + 2);
			break;
		default:
			r_core_cmd_help (core, help_msg_aep);
			break;
		}
		break;
	case 'r': // "aer"
		// 'aer' is an alias for 'ar'
		cmd_anal_reg (core, input + 1);
		break;
	case '*': // "aeq"
		// XXX: this is wip, not working atm
		r_cons_printf ("trap: %d\n", core->anal->esil->trap);
		r_cons_printf ("trap-code: %d\n", core->anal->esil->trap_code);
		break;
	case ' ':
	case 'q': // "aeq"
		r_esil_set_pc (esil, core->offset);
		r_esil_parse (esil, r_str_trim_head_ro (input + 1));
		if (verbose && *input != 'q') {
			r_esil_dumpstack (esil);
		}
		r_esil_stack_free (esil);
		break;
	case 's': // "aes" "aeso" "aesu" "aesue"
#if 0
		r_core_cmd0 (core, "ae `aoe@r:PC`");
		r_core_cmd0 (core, ".ar*");
		break;
#endif
		// aes -> single step
		// aesb -> single step back
		// aeso -> single step over
		// aesu -> until address
		// aesue -> until esil expression
		switch (input[1]) {
		case '?':
			r_core_cmd_help (core, help_msg_aes);
			break;
		case 'l': // "aesl"
		{
			ut64 pc = r_debug_reg_get (core->dbg, "PC");
			RAnalOp *op = r_core_anal_op (core, pc, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);
			if (!op) {
				break;
			}
			r_core_esil_step (core, UT64_MAX, NULL, NULL, false);
			r_debug_reg_set (core->dbg, "PC", pc + op->size);
			r_esil_set_pc (esil, pc + op->size);
			r_core_cmd0 (core, ".ar*");
			r_anal_op_free (op);
		} break;
		case 'b': // "aesb"
			if (!r_core_esil_step_back (core)) {
				R_LOG_ERROR ("Cannot step back");
			}
			r_core_cmd0 (core, ".ar*");
			break;
		case 'B': // "aesB"
			n = strchr (input + 2, ' ');
			if (n) {
				n = (char *)r_str_trim_head_ro (n + 1);
			}
			if (n) {
				char *n2 = strchr (n, ' ');
				if (n2) {
					*n2++ = 0;
				}
				ut64 off = r_num_math (core->num, n);
				ut64 nth = n2? r_num_math (core->num, n2): 1;
				cmd_aespc (core, core->offset, off, (int)nth);
			} else {
				r_core_cmd_help_match (core, help_msg_aes, "aesB", true);
			}
			break;
		case 'u': // "aesu"
			until_expr = NULL;
			until_addr = UT64_MAX;
			if (r_str_endswith (input, "?")) {
				r_core_cmd_help_match (core, help_msg_aes, "aesu", true);
			} else switch (input[2]) {
			case 'e': // "aesue"
				until_expr = r_str_trim_head_ro (input + 3);
				break;
			case ' ': // "aesu"
				until_addr = r_num_math (core->num, input + 2);
				break;
			case 'o': // "aesuo"
				step_until_optype (core, r_str_trim_head_ro (input + 3));
				break;
			default:
				r_core_cmd0 (core, "aes?~aesu");
				break;
			}
			if (until_expr || until_addr != UT64_MAX) {
				r_core_esil_step (core, until_addr, until_expr, NULL, false);
			}
			r_core_cmd0 (core, ".ar*");
			break;
		case 's': // "aess"
			if (input[2] == 'u') { // "aessu"
				if (input[3] == 'e') {
					until_expr = input + 3;
				} else {
					until_addr = r_num_math (core->num, input + 2);
				}
				r_core_esil_step (core, until_addr, until_expr, NULL, true);
			} else {
				r_core_esil_step (core, UT64_MAX, NULL, NULL, true);
			}
			r_core_cmd0 (core, ".ar*");
			break;
		case 'o': // "aeso"
			if (input[2] == 'u') { // "aesou"
				if (input[3] == 'e') {
					until_expr = input + 3;
				} else {
					until_addr = r_num_math (core->num, input + 2);
				}
				r_core_esil_step (core, until_addr, until_expr, NULL, true);
				r_core_cmd0 (core, ".ar*");
			} else if (!input[2] || input[2] == ' ') { // "aeso [addr]"
				// step over
				op = r_core_anal_op (core, r_reg_getv (core->anal->reg,
					r_reg_get_name (core->anal->reg, R_REG_NAME_PC)), R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);
				if (op && op->type == R_ANAL_OP_TYPE_CALL) {
					until_addr = op->addr + op->size;
				}
				r_core_esil_step (core, until_addr, until_expr, NULL, false);
				r_anal_op_free (op);
				r_core_cmd0 (core, ".ar*");
			} else {
				r_core_cmd_help_match (core, help_msg_aes, "aesou", true);
			}
			break;
		case 'p': //"aesp"
			n = strchr (input, ' ');
			n1 = R_STR_ISNOTEMPTY (n) ? strchr (n + 1, ' ') : NULL;
			if ((!n || !n1) || (!*n || !*n1)) {
				r_core_cmd_help_match (core, help_msg_aes, "aesp", true);
				break;
			}
			adr = R_STR_ISNOTEMPTY (n)? r_num_math (core->num, n + 1): 0;
			off = R_STR_ISNOTEMPTY (n1)? r_num_math (core->num, n1 + 1): 0;
			cmd_aespc (core, adr, -1, off);
			break;
		case ' ':
			n = strchr (input, ' ');
			n1 = n ? n + 1: NULL;
			if (!n1 || !*n1) {
				r_core_esil_step (core, until_addr, until_expr, NULL, false);
				break;
			}
			off = r_num_math (core->num, n1);
			cmd_aespc (core, -1, -1, off);
			break;
		default:
			r_core_esil_step (core, until_addr, until_expr, NULL, false);
			r_core_cmd0 (core, ".ar*");
			break;
		}
		break;
	case 'C': // "aeC"
		if (input[1] == '?') { // "aec?"
			r_core_cmd_help (core, help_msg_aeC);
		} else {
			__core_anal_appcall (core, r_str_trim_head_ro (input + 1));
		}
		break;
	case 'c': // "aec"
		if (input[1] == '?') { // "aec?"
			r_core_cmd_help (core, help_msg_aec);
		} else if (input[1] == 's') { // "aecs"
			st64 maxsteps = r_config_get_i (core->config, "esil.maxsteps");
			ut64 countsteps = 0;
			const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
			for (; !maxsteps || countsteps < maxsteps; countsteps++) {
				// ignore return value is not an error, should 0, 1, -1 imho
				(void)r_core_esil_step (core, UT64_MAX, NULL, NULL, false);
				r_core_cmd0 (core, ".ar*");
				addr = r_reg_getv (core->anal->reg, pc);
				op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_HINT);
				if (!op) {
					R_LOG_ERROR ("invalid instruction at 0x%08" PFMT64x, addr);
					break;
				}
				if (op->type == R_ANAL_OP_TYPE_SWI) {
					R_LOG_INFO ("syscall instruction at 0x%08" PFMT64x, addr);
					break;
				} else if (op->type == R_ANAL_OP_TYPE_TRAP) {
					R_LOG_INFO ("trap instruction at 0x%08" PFMT64x, addr);
					break;
				}
				r_anal_op_free (op);
				op = NULL;
				if (core->anal->esil->trap || core->anal->esil->trap_code) {
					R_LOG_INFO ("esil trap '%s' (%d) at 0x%08" PFMT64x,
							r_esil_trapstr (core->anal->esil->trap),
							core->anal->esil->trap_code, addr);
					break;
				}
			}
			if (op) {
				r_anal_op_free (op);
				op = NULL;
			}
		} else if (input[1] == 'c') { // "aecc"
			const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
			st64 maxsteps = r_config_get_i (core->config, "esil.maxsteps");
			ut64 countsteps = 0;
			for (; !maxsteps || countsteps < maxsteps; countsteps++) {
				(void)r_core_esil_step (core, UT64_MAX, NULL, NULL, false);
				r_core_cmd0 (core, ".ar*");
				addr = r_num_get (core->num, pc);
				op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC);
				if (!op) {
					break;
				}
				if (op->type == R_ANAL_OP_TYPE_CALL || op->type == R_ANAL_OP_TYPE_UCALL) {
					R_LOG_INFO ("stop in call instruction at 0x%08" PFMT64x, addr);
					break;
				}
				r_anal_op_free (op);
				op = NULL;
				if (core->anal->esil->trap || core->anal->esil->trap_code) {
					break;
				}
			}
			if (op) {
				r_anal_op_free (op);
			}
		} else {
			// "aec"  -> continue until ^C
			// "aecu" -> until address
			// "aecue" -> until esil expression
			if (input[1] == 'u' && input[2] == 'e') {
				until_expr = input + 3;
			} else if (input[1] == 'u') {
				until_addr = r_num_math (core->num, input + 2);
			} else {
				until_expr = "0";
			}
			r_core_esil_step (core, until_addr, until_expr, NULL, false);
			r_core_cmd0 (core, ".ar*");
		}
		break;
	case 'i': // "aei"
		switch (input[1]) {
		case 's': // "aeis"
			{
				char *arg = r_str_trim_dup (input + 2);
				RList *args = r_str_split_list (arg, " ", 0);
				int i, argc = atoi (r_list_pop_head (args));
				if (argc < 1) {
					r_core_cmd_help (core, help_msg_aei);
					break;
				}
				char **argv = calloc (argc + 1, sizeof (void *));
				for (i = 0; i < argc; i++) {
					char *arg = r_list_pop_head (args);
					if (!arg) {
						break;
					}
					argv[i] = arg;
				}
				argv[i] = 0;
				char **envp = calloc (r_list_length (args) + 1, sizeof (void *));
				for (i = 0; ; i++) {
					char *arg = r_list_pop_head (args);
					if (!arg) {
						break;
					}
					envp[i] = arg;
				}
				envp[i] = 0;
#if R2__UNIX__
				if (strstr (input, "$env")) {
					extern char **environ;
					cmd_debug_stack_init (core, argc, argv, environ);
				} else {
					cmd_debug_stack_init (core, argc, argv, envp);
				}
#else
				cmd_debug_stack_init (core, argc, argv, envp);
#endif
				free (arg);
			}
			break;
		case 'm': // "aeim"
			cmd_esil_mem (core, input + 2);
			break;
		case 'p': // "aeip" // initialize pc = $$
			reg_name_roll_set (core, "PC", core->offset);
			break;
		case '?':
			r_core_cmd_help (core, help_msg_aei);
			cmd_esil_mem (core, "?");
			break;
		case '-':
			r_esil_reset (esil);
			break;
		case 0: // "aei"
			esil = esil_new_setup (core);
			if (esil) {
				r_esil_free (core->anal->esil);
				core->anal->esil = esil;
				r_esil_reset (esil);
				const char *pc = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
				if (pc && r_reg_getv (core->anal->reg, pc) == 0LL) {
					reg_name_roll_set (core, "PC", core->offset);
				}
			}
			/* restore user settings for interrupt handling */
			{
				const char *s = r_config_get (core->config, "cmd.esil.intr");
				if (s) {
					char *my = strdup (s);
					if (my) {
						r_config_set (core->config, "cmd.esil.intr", my);
						free (my);
					}
				}
			}
			break;
		default:
			cmd_esil_mem (core, "?");
			break;
		}
		break;
	case 'k': // "aek"
		switch (input[1]) {
		case '\0':
			input = "*";
			/* fall through */
		case ' ':
			if (esil && esil->stats) {
				char *out = sdb_querys (esil->stats, NULL, 0, input + 2);
				if (out) {
					r_cons_println (out);
					free (out);
				}
			} else {
				R_LOG_INFO ("esil.stats is empty. Run 'aei'");
			}
			break;
		case '-':
			if (esil) {
				sdb_reset (esil->stats);
			}
			break;
		default:
			r_core_cmd_help (core, help_msg_aek);
			break;
		}
		break;
	case 'L': // "aeL" esil plugins
		if (input[1] == ' ') { // "aeL"
			const char *name = r_str_trim_head_ro (input + 2);
			r_esil_plugin_activate (core->anal->esil, name);
		} else if (input[1] == '-') { // "aeL-"
			const char *name = r_str_trim_head_ro (input + 2);
			r_esil_plugin_deactivate (core->anal->esil, name);
		} else {
			REsilPlugin *p;
			RListIter *iter;
			if (core->anal->esil) {
				r_list_foreach (core->anal->esil->plugins, iter, p) {
					r_cons_printf ("%s\n", p->name);
				}
			} else {
				R_LOG_WARN ("Run 'aei'");
			}
		}
		break;
	case 'g': // "aeg"
		{
			int argc;
			char **argv = r_str_argv (input, &argc);
			r_return_if_fail (argv);
			cmd_aeg (core, argc, argv);
			int i;
			for (i = 0; i < argc; i++) {
				free (argv[i]);
			}
			free (argv);
		}
		break;
	case 'b': // "aeb"
		{
			ut64 addr = r_num_math (core->num, input + 1);
			if (!addr || addr == UT64_MAX) {
				addr = core->offset;
			}
			RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL);
			if (fcn) {
				RAnalBlock *bb = r_anal_function_bbget_in (core->anal, fcn, addr);
				if (bb) {
					cmd_aespc (core, bb->addr, bb->addr + bb->size, bb->ninstr);
					// r_core_cmdf (core, "aesp `ab~addr[1]` `ab~ninstr[1]`");
				} else {
					R_LOG_ERROR ("No basic block in this address");
				}
			} else {
				R_LOG_ERROR ("No function in this address");
			}
		// ab~ninstr[1]
		}
		break;
	case 'f': // "aef"
		if (input[1] == 'a') { // "aefa"
			r_anal_aefa (core, r_str_trim_head_ro (input + 2));
		} else { // This should be aefb -> because its emulating all the bbs
			// anal ESIL to REIL.
			__anal_esil_function (core, core->offset);
		} break;
	case 't': // "aet"
		switch (input[1]) {
		case 's': // "aets"
			switch (input[2]) {
			case '+': // "aets+"
#if 0
				if (!esil) {
					R_LOG_ERROR ("ESIL is not initialized. Use `aeim` first");
					break;
				}
#endif
				if (esil->trace) {
					R_LOG_INFO ("ESIL trace already started");
					break;
				}
				esil->trace = r_esil_trace_new (esil);
				if (!esil->trace) {
					break;
				}
				r_config_set_b (core->config, "dbg.trace", true);
				break;
			case '-': // "aets-"
				if (!esil) {
					R_LOG_ERROR ("ESIL is not initialized. Use `aeim` first");
					break;
				}
				if (!esil->trace) {
					R_LOG_ERROR ("No ESIL trace started");
					break;
				}
				r_esil_trace_free (esil->trace);
				esil->trace = NULL;
				r_config_set_b (core->config, "dbg.trace", false);
				break;
			default:
				r_core_cmd_help (core, help_msg_aets);
				break;
			}
			break;
		case 0: // "aet"
			r_esil_trace_list (core->anal->esil);
			break;
		default:
			R_LOG_ERROR ("Unknown command");
			break;
		}
		break;
	case 'A': // "aeA"
		switch (input[1]) {
		case '?':
			r_core_cmd_help (core, help_msg_aea);
			break;
		case 'r':
			cmd_aea (core, 1 + (1<<1), core->offset, r_num_math (core->num, input+2));
			break;
		case 'w':
			cmd_aea (core, 1 + (1<<2), core->offset, r_num_math (core->num, input+2));
			break;
		case 'n':
			cmd_aea (core, 1 + (1<<3), core->offset, r_num_math (core->num, input+2));
			break;
		case 'j':
			cmd_aea (core, 1 + (1<<4), core->offset, r_num_math (core->num, input+2));
			break;
		case '*':
			cmd_aea (core, 1 + (1<<5), core->offset, r_num_math (core->num, input+2));
			break;
		case 'f': {
			RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
			if (fcn) {
				cmd_aea (core, 1, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));
			}
			break;
			}
		default:
			cmd_aea (core, 1, core->offset, (int)r_num_math (core->num, input[1]? input + 2:input + 1));
		}
		break;
	case 'a': { // "aea"
		RReg *reg = core->anal->reg;
		ut64 pc = r_reg_getv (reg, "PC");
		RAnalOp *op = r_core_anal_op (core, pc, 0);
		if (!op) {
			break;
		}
		ut64 newPC = core->offset + op->size;
		r_reg_setv (reg, "PC", newPC);
		switch (input[1]) {
		case '?':
			r_core_cmd_help (core, help_msg_aea);
			break;
		case 'r':
			cmd_aea (core, 1<<1, core->offset, r_num_math (core->num, input+2));
			break;
		case 'w':
			cmd_aea (core, 1<<2, core->offset, r_num_math (core->num, input+2));
			break;
		case 'n':
			cmd_aea (core, 1<<3, core->offset, r_num_math (core->num, input+2));
			break;
		case 'j':
			cmd_aea (core, 1<<4, core->offset, r_num_math (core->num, input+2));
			break;
		case '*':
			cmd_aea (core, 1<<5, core->offset, r_num_math (core->num, input+2));
			break;
		case 'B': { // "aeaB"
			bool json = input[2] == 'j';
			int a = json? 3: 2;
			ut64 addr = (input[a] == ' ')? r_num_math (core->num, input + a): core->offset;
			RList *l = r_anal_get_blocks_in (core->anal, addr);
			RAnalBlock *b;
			RListIter *iter;
			r_list_foreach (l, iter, b) {
				int mode = json? (1<<4): 1;
				cmd_aea (core, mode, b->addr, b->size);
				break;
			}
			break;
		}
		case 'f': { // "aeaf"
			RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
			if (fcn) {
				switch (input[2]) {
				case 'j': // "aeafj"
					cmd_aea (core, 1<<4, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));
					break;
				default:
					cmd_aea (core, 1, r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn));
					break;
				}
				break;
			}
		}
			break;
		case 'b': { // "aeab"
			RAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);
			if (bb) {
				switch (input[2]) {
				case 'j': // "aeabj"
					cmd_aea (core, 1 | (1<<4), bb->addr, bb->size);
					break;
				default:
					cmd_aea (core, 1, bb->addr, bb->size);
					break;
				}
			}
			}
			break;
		default: {
			const char *arg = input[1]? input + 2: "";
			ut64 len = r_num_math (core->num, arg);
			cmd_aea (core, 0, core->offset, len);
			}
			break;
		}
		r_reg_setv (reg, "PC", pc);
		break;
		  }
	case 'x':
		if (input[1] == ' ') { // "aex"
			char *hex;
			int ret, bufsz;

			input = r_str_trim_head_ro (input + 1);
			hex = strdup (input);
			if (!hex) {
				break;
			}

			RAnalOp aop = {0};
			bufsz = r_hex_str2bin (hex, (ut8*)hex);
			ret = r_anal_op (core->anal, &aop, core->offset,
				(const ut8*)hex, bufsz, R_ARCH_OP_MASK_ESIL);
			if (ret > 0) {
				const char *str = R_STRBUF_SAFEGET (&aop.esil);
				char *str2 = r_str_newf (" %s", str);
				cmd_anal_esil (core, str2, false);
				free (str2);
				r_core_return_value (core, 1);
			} else {
				// fail to exevute, update code
				r_core_return_value (core, 0);
			}
			r_anal_op_fini (&aop);
			free (hex);
		} else if (input[1] == 'a') { // "aexa"
			char *bytes = r_core_cmd_strf (core, "\"pa %s\"", r_str_trim_head_ro (input + 2));
			if (R_STR_ISNOTEMPTY (bytes)) {
				r_core_cmdf (core, "aex %s", bytes);
			}
			free (bytes);
		} else { // "aex?"
			r_core_cmd_help (core, help_msg_aex);
		}
		break;
	case '?': // "ae?"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_detail_ae);
			break;
		}
		/* fallthrough */
	default:
		r_core_cmd_help (core, help_msg_ae);
		break;
	}
}
