static int cmd_anal_all(RCore *core, const char *input) {
	switch (*input) {
	case '?':
		r_core_cmd_help (core, help_msg_aa);
		break;
	case 'b': // "aab"
		cmd_anal_blocks (core, input + 1);
		break;
	case 'f':
		if (input[1] == 'e') {  // "aafe"
			r_core_cmd0 (core, "aef@@F");
		} else if (input[1] == 'r') {
			ut64 cur = core->offset;
			bool hasnext = r_config_get_b (core->config, "anal.hasnext");
			RListIter *iter;
			RIOMap *map;
			RList *list = r_core_get_boundaries_prot (core, R_PERM_X, NULL, "anal");
			if (!list) {
				break;
			}
			r_list_foreach (list, iter, map) {
				r_core_seek (core, r_io_map_begin (map), true);
				r_config_set_b (core->config, "anal.hasnext", true);
				r_core_cmd_call (core, "afr");
				r_config_set_b (core->config, "anal.hasnext", hasnext);
			}
			r_list_free (list);
			r_core_seek (core, cur, true);
		} else if (input[1] == 't') { // "aaft"
			cmd_anal_aaft (core);
		} else if (input[1] == 'f') { // "aaff"
			flag_every_function (core);
		} else if (input[1] == 's') { // "aafs"
			single_block_analysis (core);
		} else if (input[1] == 0) { // "aaf"
			const bool analHasnext = r_config_get_b (core->config, "anal.hasnext");
			r_config_set_b (core->config, "anal.hasnext", true);
			r_core_cmd0 (core, "afr@@c:isq");
			r_config_set_b (core->config, "anal.hasnext", analHasnext);
		} else {
			r_core_cmd_help (core, help_msg_aaf);
		}
		break;
	case 'c': // "aac"
		switch (input[1]) {
		case '*': // "aac*"
			cmd_anal_calls (core, input + 1, true, false);
			break;
		case 'i': // "aaci"
			cmd_anal_calls (core, input + 1, input[2] == '*', true);
			break;
		case '?': // "aac?"
			r_core_cmd_help_match (core, help_msg_aa, "aac", false);
			break;
		default: // "aac"
			cmd_anal_calls (core, input + 1, false, false);
			break;
		}
		break;
	case 'j': // "aaj"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aaj", true);
		} else {
			cmd_anal_jumps (core, input + 1);
		}
		break;
	case 'd': // "aad"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aad", true);
		} else {
			cmd_anal_aad (core, input);
		}
		break;
	case 'v': // "aav"
		if (strchr (input + 1, '?')) {
			r_core_cmd_help (core, help_msg_aav);
		} else {
			cmd_anal_aav (core, input);
		}
		break;
	case 'w': // "aaw"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aaw", true);
		} else {
			cmd_anal_aaw (core, input);
		}
		break;
	case 'u': // "aau" - print areas not covered by functions
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aau", true);
		} else {
			r_core_anal_nofunclist (core, input + 1);
		}
		break;
	case 'i': // "aai"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aai", true);
		} else {
			r_core_anal_info (core, input + 1);
		}
		break;
	case 's': // "aas"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aas", true);
		} else {
			r_core_cmd0 (core, "af @@= `isq~[0]`");
			r_core_cmd0 (core, "af @@f:entry*");
		}
		break;
	case 'S': // "aaS"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aaS", true);
		} else {
			r_core_cmd0 (core, "af @@f:sym.*");
			r_core_cmd0 (core, "af @@f:entry*");
		}
		break;
	case 'F': // "aaF" "aaFa"
		if (!input[1] || input[1] == ' ' || input[1] == 'a') {
			r_core_anal_inflags (core, input + 1);
		} else {
			r_core_cmd_help_match (core, help_msg_aa, "aaF", false);
		}
		break;
	case 'n': // "aan"
		switch (input[1]) {
		case 'r': // "aanr" // all noreturn propagation
			r_core_anal_propagate_noreturn (core, UT64_MAX);
			break;
		case 'g': // "aang"
			r_core_anal_autoname_all_golang_fcns (core);
			break;
		case '?':
			r_core_cmd_help (core, help_msg_aan);
			break;
		case 'f': // "aanf" same as "aan" but more friendly
		default: // "aan"
			r_core_anal_autoname_all_fcns (core);
		}
		break;
	case 'p': // "aap"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aap", true);
		} else {
			r_core_search_preludes (core, true);
		}
		break;
	case '\0': // "aa"
	case 'a':
		if (strchr (input, '?')) {
			r_core_cmd_help (core, help_msg_aaa);
		} else {
			bool didAap = false;
			char *dh_orig = NULL;
			if (!strncmp (input, "aaaaa", 5)) {
				R_LOG_INFO ("We fired the r2 developer that was heading to your location to help you analyze this binary");
				R_LOG_INFO ("Contact support for premium service");
				if (r_cons_is_interactive ()) {
					r_cons_any_key (NULL);
				}
				goto jacuzzi;
			}
			ut64 curseek = core->offset;
			R_LOG_INFO ("Analyze all flags starting with sym. and entry0 (aa)");
			r_cons_break_push (NULL, NULL);
			r_cons_break_timeout (r_config_get_i (core->config, "anal.timeout"));
			r_core_anal_all (core);
			r_core_task_yield (&core->tasks);
			if (r_cons_is_breaked ()) {
				goto jacuzzi;
			}

			// Run afvn in all fcns
			if (r_config_get_b (core->config, "anal.vars")) {
				R_LOG_INFO ("Analyze all functions arguments/locals (afva@@@F)");
				// r_core_cmd0 (core, "afva@@f");
				r_core_cmd0 (core, "afva@@@F");
			}

			// Run pending analysis immediately after analysis
			// Usefull when running commands with ";" or via r2 -c,-i
			dh_orig = core->dbg->current
				? strdup (core->dbg->current->plugin.meta.name)
				: strdup ("esil");
			if (core->io->desc && core->io->desc->plugin && !core->io->desc->plugin->isdbg) {
				//use dh_origin if we are debugging
				R_FREE (dh_orig);
			}
			if (r_cons_is_breaked ()) {
				goto jacuzzi;
			}
			r_cons_clear_line (1);
			bool cfg_debug = r_config_get_b (core->config, "cfg.debug");
			if (*input == 'a') { // "aaa" .. which is checked just in the case above
				if (r_str_startswith (r_config_get (core->config, "bin.lang"), "go")) {
					R_LOG_INFO ("Find function and symbol names from golang binaries (aang)");
					r_core_anal_autoname_all_golang_fcns (core);
					R_LOG_INFO ("Analyze all flags starting with sym.go. (aF @@f:sym.go.*)");
					r_core_cmd0 (core, "aF @@@F:sym.go.*");
				}
				r_core_task_yield (&core->tasks);
				if (!cfg_debug) {
					if (dh_orig && strcmp (dh_orig, "esil")) {
						r_core_cmd_call (core, "dL esil");
						r_core_task_yield (&core->tasks);
					}
				}
				// XXX do not override user settings!
				// int c = r_config_get_i (core->config, "anal.calls");
				// r_config_set_b (core->config, "anal.calls", true);
				r_core_cmd_call (core, "s $S");
				if (r_cons_is_breaked ()) {
					goto jacuzzi;
				}

				R_LOG_INFO ("Analyze function calls (aac)");
				(void)cmd_anal_calls (core, "", false, false); // "aac"
				r_core_seek (core, curseek, true);
				// R_LOG_INFO ("Analyze data refs as code (LEA)");
				// (void) cmd_anal_aad (core, NULL); // "aad"
				r_core_task_yield (&core->tasks);
				if (r_cons_is_breaked ()) {
					goto jacuzzi;
				}

				if (is_unknown_file (core)) {
					R_LOG_INFO ("find and analyze function preludes (aap)");
					(void)r_core_search_preludes (core, false); // "aap"
					didAap = true;
					r_core_task_yield (&core->tasks);
					if (r_cons_is_breaked ()) {
						goto jacuzzi;
					}
				}

				R_LOG_INFO ("Analyze len bytes of instructions for references (aar)");
				(void)r_core_anal_refs (core, ""); // "aar"
				r_core_task_yield (&core->tasks);
				if (r_cons_is_breaked ()) {
					goto jacuzzi;
				}
				if (is_apple_target (core)) {
					R_LOG_INFO ("Check for objc references (aao)");
					cmd_anal_objc (core, input + 1, true);
				}
				r_core_task_yield (&core->tasks);
				R_LOG_INFO ("Finding and parsing C++ vtables (avrr)");
				r_core_cmd_call (core, "avrr");
				r_core_cmd0 (core, "af @@ method.*");
				r_core_task_yield (&core->tasks);
				// r_config_set_b (core->config, "anal.calls", c);
				r_core_task_yield (&core->tasks);
				if (r_cons_is_breaked ()) {
					goto jacuzzi;
				}
				const bool isPreludableArch = core->rasm->config->bits == 64 && r_str_startswith (r_config_get (core->config, "asm.arch"), "arm");

				if (!didAap && isPreludableArch) {
					didAap = true;
					R_LOG_INFO ("Finding function preludes (aap)");
					(void)r_core_search_preludes (core, false); // "aap"
					r_core_task_yield (&core->tasks);
				}
				if (!r_str_startswith (r_config_get (core->config, "asm.arch"), "x86")) {
					r_core_cmd_call (core, "aav");
					r_core_task_yield (&core->tasks);
					if (cfg_debug) {
						R_LOG_INFO ("Skipping function emulation in debugger mode (aaef)");
						// nothing to do
					} else {
						const bool io_cache = r_config_get_i (core->config, "io.pcache");
						r_config_set_b (core->config, "io.pcache", true);
						R_LOG_INFO ("Emulate functions to find computed references (aaef)");
						r_core_cmd_call (core, "aaef");
						r_core_task_yield (&core->tasks);
						r_config_set_b (core->config, "io.pcache", io_cache);
					}
					if (r_cons_is_breaked ()) {
						goto jacuzzi;
					}
				}
				if (r_config_get_i (core->config, "anal.autoname")) {
					R_LOG_INFO ("Speculatively constructing a function name for fcn.* and sym.func.* functions (aan)");
					r_core_anal_autoname_all_fcns (core);
					r_core_task_yield (&core->tasks);
				}
				if (core->anal->opt.vars) {
					RAnalFunction *fcni;
					RListIter *iter;
					r_list_foreach (core->anal->fcns, iter, fcni) {
						if (r_cons_is_breaked ()) {
							break;
						}
						RList *list = r_anal_var_list (core->anal, fcni, 'r');
						if (!r_list_empty (list)) {
							r_list_free (list);
							continue;
						}
						// extract only reg based var here
						r_core_recover_vars (core, fcni, true);
						r_list_free (list);
					}
					r_core_task_yield (&core->tasks);
				}
				if (!sdb_isempty (core->anal->sdb_zigns)) {
					R_LOG_INFO ("Check for zignature from zigns folder (z/)");
					r_core_cmd_call (core, "z/");
					r_core_task_yield (&core->tasks);
				}
				if (cfg_debug) {
					R_LOG_INFO ("Skipping type matching analysis in debugger mode (aaft)");
					// nothing to do
				} else {
					R_LOG_INFO ("Type matching analysis for all functions (aaft)");
					r_core_cmd_call (core, "aaft");
				}
				r_core_task_yield (&core->tasks);

				R_LOG_INFO ("Propagate noreturn information (aanr)");
				r_core_anal_propagate_noreturn (core, UT64_MAX);
				r_core_task_yield (&core->tasks);

				// apply dwarf function information
				Sdb *dwarf_sdb = sdb_ns (core->anal->sdb, "dwarf", 0);
				if (dwarf_sdb) {
					R_LOG_INFO ("Integrate dwarf function information");
					r_anal_dwarf_integrate_functions (core->anal, core->flags, dwarf_sdb);
				}

				if (input[1] == 'a') { // "aaaa"
					R_LOG_INFO ("Scanning for strings constructed in code (/azs)");
					r_core_cmd_call (core, "/azs");
					if (!didAap) {
						didAap = true;
						R_LOG_INFO ("Finding function preludes (aap)");
						(void)r_core_search_preludes (core, false); // "aap"
						r_core_task_yield (&core->tasks);
					}
					R_LOG_INFO ("Enable anal.types.constraint for experimental type propagation");
					r_config_set_b (core->config, "anal.types.constraint", true);
					if (input[2] == 'a') { // "aaaa"
						R_LOG_INFO ("Reanalizing graph references to improve function count (aarr)");
						r_core_cmd_call (core, "aarr");
					}
				} else {
					R_LOG_INFO ("Use -AA or aaaa to perform additional experimental analysis");
				}
				r_core_cmd_call (core, "s-");
				if (dh_orig) {
					r_core_cmdf (core, "dL %s", dh_orig);
					r_core_task_yield (&core->tasks);
				}
			}
			r_core_seek (core, curseek, true);
		jacuzzi:
			// XXX this shouldnt be called. flags muts be created wheen the function is registered
			flag_every_function (core);
			r_core_anal_propagate_noreturn (core, UT64_MAX);
			r_cons_break_pop ();
			R_FREE (dh_orig);
		}
		break;
	case 't': // "aat"
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_aa, "aat", true);
		} else {
			char *off = input[1]? r_str_trim_dup (input + 2): NULL;
			RAnalFunction *fcn;
			RListIter *it;
			if (off && *off) {
				ut64 addr = r_num_math (NULL, off);
				fcn = r_anal_get_function_at (core->anal, core->offset);
				if (fcn) {
					r_core_link_stroff (core, fcn);
				} else {
					R_LOG_ERROR ("Cannot find function at %08" PFMT64x, addr);
				}
			} else {
				if (r_list_empty (core->anal->fcns)) {
					R_LOG_ERROR ("Couldn't find any functions");
					break;
				}
				r_list_foreach (core->anal->fcns, it, fcn) {
					if (r_cons_is_breaked ()) {
						break;
					}
					r_core_link_stroff (core, fcn);
				}
			}
			free (off);
		}
		break;
	case 'T': // "aaT"
		cmd_anal_aftertraps (core, input + 1);
		break;
	case 'o': // "aao"
		if (input[1] == '?') { // "aao?"
			r_core_cmd_help_match (core, help_msg_aa, "aao", true);
		} else {
			cmd_anal_objc (core, input + 1, false);
		}
		break;
	case 'e': // "aae"
		if (input[1] == 'f') { // "aaef"
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_aae, "aaef", true);
			} else {
				r_core_cmd0 (core, "aeim");
				RListIter *it;
				RAnalFunction *fcn;
				ut64 cur_seek = core->offset;
				r_list_foreach (core->anal->fcns, it, fcn) {
					r_core_seek (core, fcn->addr, true);
					r_core_anal_esil (core, "f", NULL);
					// __anal_esil_function (core, fcn->addr);
				}
				r_core_seek (core, cur_seek, true);
			}
		} else if (input[1] == '?') { // "aae?"
			r_core_cmd_help (core, help_msg_aae);
		} else if (input[1] == 'p') { // "aaep" // auto define all esil pins
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_aae, "aaef", true);
			} else {
				r_core_cmd0 (core, "aep ret0@@@i");
				r_core_cmd0 (core, "aepa@@@i");
			}
		} else if (input[1] == ' ') { // "aae "
			char *arg = r_str_trim_dup (input + 1);
			const char *len = (char *)arg;
			char *addr = strchr (arg, ' ');
			if (addr) {
				*addr = 0;
				addr = (char *)r_str_trim_head_ro (addr + 1);
			}
			r_core_cmd0 (core, "aeim");
			r_core_anal_esil (core, len, addr);
			free (arg);
		} else {
			ut64 at = core->offset;
			RIOMap *map;
			RListIter *iter;
			RList *list = r_core_get_boundaries_prot (core, -1, NULL, "anal");
			if (!list) {
				break;
			}
			if (!strcmp ("range", r_config_get (core->config, "anal.in"))) {
				ut64 from = r_config_get_i (core->config, "anal.from");
				ut64 to = r_config_get_i (core->config, "anal.to");
				if (to > from) {
					char *len = r_str_newf (" 0x%"PFMT64x, to - from);
					r_core_seek (core, from, true);
					r_core_anal_esil (core, len, NULL);
					free (len);
				} else {
					R_LOG_ERROR ("Assert: anal.from > anal.to");
				}
			} else {
				r_list_foreach (list, iter, map) {
					if (map->perm & R_PERM_X) {
						char *ss = r_str_newf (" 0x%"PFMT64x, r_io_map_size (map));
						r_core_seek (core, r_io_map_begin (map), true);
						r_core_anal_esil (core, ss, NULL);
						free (ss);
					}
				}
				r_list_free (list);
			}
			r_core_seek (core, at, true);
		}
		break;
	case 'r': // "aar"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_aar);
		} else if (input[1] == 'r') { // "aarr"
			anal_aarr (core);
		} else {
			(void)r_core_anal_refs (core, input + 1);
		}
		break;
	default:
		r_core_cmd_help (core, help_msg_aa);
		break;
	}

	return true;
}
