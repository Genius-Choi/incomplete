static void mg_http_handler2(struct mg_connection *nc, int ev,
                             void *ev_data MG_UD_ARG(void *user_data),
                             struct http_message *hm) {
#else  /* !__XTENSA__ */
void mg_http_handler(struct mg_connection *nc, int ev,
                     void *ev_data MG_UD_ARG(void *user_data)) {
  struct http_message shm, *hm = &shm;
#endif /* __XTENSA__ */
  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);
  struct mbuf *io = &nc->recv_mbuf;
  int req_len;
  const int is_req = (nc->listener != NULL);
#if MG_ENABLE_HTTP_WEBSOCKET
  struct mg_str *vec;
#endif
  if (ev == MG_EV_CLOSE) {
#if MG_ENABLE_HTTP_CGI
    /* Close associated CGI forwarder connection */
    if (pd != NULL && pd->cgi.cgi_nc != NULL) {
      pd->cgi.cgi_nc->user_data = NULL;
      pd->cgi.cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;
    }
#endif
#if MG_ENABLE_HTTP_STREAMING_MULTIPART
    if (pd != NULL && pd->mp_stream.boundary != NULL) {
      /*
       * Multipart message is in progress, but connection is closed.
       * Finish part and request with an error flag.
       */
      struct mg_http_multipart_part mp;
      memset(&mp, 0, sizeof(mp));
      mp.status = -1;
      mp.var_name = pd->mp_stream.var_name;
      mp.file_name = pd->mp_stream.file_name;
      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),
              nc->user_data, MG_EV_HTTP_PART_END, &mp);
      mp.var_name = NULL;
      mp.file_name = NULL;
      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),
              nc->user_data, MG_EV_HTTP_MULTIPART_REQUEST_END, &mp);
    } else
#endif
        if (io->len > 0 &&
            (req_len = mg_parse_http(io->buf, io->len, hm, is_req)) > 0) {
      /*
       * For HTTP messages without Content-Length, always send HTTP message
       * before MG_EV_CLOSE message.
       */
      int ev2 = is_req ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;
      hm->message.len = io->len;
      hm->body.len = io->buf + io->len - hm->body.p;
      deliver_chunk(nc, hm, req_len);
      mg_http_call_endpoint_handler(nc, ev2, hm);
    }
    if (pd != NULL && pd->endpoint_handler != NULL &&
        pd->endpoint_handler != nc->handler) {
      mg_call(nc, pd->endpoint_handler, nc->user_data, ev, NULL);
    }
  }

#if MG_ENABLE_FILESYSTEM
  if (pd != NULL && pd->file.fp != NULL) {
    mg_http_transfer_file_data(nc);
  }
#endif

  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);

#if MG_ENABLE_HTTP_STREAMING_MULTIPART
  if (pd != NULL && pd->mp_stream.boundary != NULL &&
      (ev == MG_EV_RECV || ev == MG_EV_POLL)) {
    if (ev == MG_EV_RECV) {
      pd->rcvd += *(int *) ev_data;
      mg_http_multipart_continue(nc);
    } else if (pd->mp_stream.data_avail) {
      /* Try re-delivering the data. */
      mg_http_multipart_continue(nc);
    }
    return;
  }
#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */

  if (ev == MG_EV_RECV) {
    struct mg_str *s;

  again:
    req_len = mg_parse_http(io->buf, io->len, hm, is_req);

    if (req_len > 0) {
      /* New request - new proto data */
      pd = mg_http_create_proto_data(nc);
      pd->rcvd = io->len;
    }

    if (req_len > 0 &&
        (s = mg_get_http_header(hm, "Transfer-Encoding")) != NULL &&
        mg_vcasecmp(s, "chunked") == 0) {
      mg_handle_chunked(nc, hm, io->buf + req_len, io->len - req_len);
    }

#if MG_ENABLE_HTTP_STREAMING_MULTIPART
    if (req_len > 0 && (s = mg_get_http_header(hm, "Content-Type")) != NULL &&
        s->len >= 9 && strncmp(s->p, "multipart", 9) == 0) {
      mg_http_multipart_begin(nc, hm, req_len);
      mg_http_multipart_continue(nc);
      return;
    }
#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */

    /* TODO(alashkin): refactor this ifelseifelseifelseifelse */
    if ((req_len < 0 ||
         (req_len == 0 && io->len >= MG_MAX_HTTP_REQUEST_SIZE))) {
      DBG(("invalid request"));
      nc->flags |= MG_F_CLOSE_IMMEDIATELY;
    } else if (req_len == 0) {
      /* Do nothing, request is not yet fully buffered */
    }
#if MG_ENABLE_HTTP_WEBSOCKET
    else if (nc->listener == NULL && (nc->flags & MG_F_IS_WEBSOCKET)) {
      /* We're websocket client, got handshake response from server. */
      DBG(("%p WebSocket upgrade code %d", nc, hm->resp_code));
      if (hm->resp_code == 101 &&
          mg_get_http_header(hm, "Sec-WebSocket-Accept")) {
        /* TODO(lsm): check the validity of accept Sec-WebSocket-Accept */
        mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,
                hm);
        mbuf_remove(io, req_len);
        nc->proto_handler = mg_ws_handler;
        mg_ws_handler(nc, MG_EV_RECV, ev_data MG_UD_ARG(user_data));
      } else {
        mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,
                hm);
        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        mbuf_remove(io, req_len);
      }
    } else if (nc->listener != NULL &&
               (vec = mg_get_http_header(hm, "Sec-WebSocket-Key")) != NULL) {
      struct mg_http_endpoint *ep;

      /* This is a websocket request. Switch protocol handlers. */
      mbuf_remove(io, req_len);
      nc->proto_handler = mg_ws_handler;
      nc->flags |= MG_F_IS_WEBSOCKET;

      /*
       * If we have a handler set up with mg_register_http_endpoint(),
       * deliver subsequent websocket events to this handler after the
       * protocol switch.
       */
      ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);
      if (ep != NULL) {
        nc->handler = ep->handler;
#if MG_ENABLE_CALLBACK_USERDATA
        nc->user_data = ep->user_data;
#endif
      }

      /* Send handshake */
      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_REQUEST,
              hm);
      if (!(nc->flags & (MG_F_CLOSE_IMMEDIATELY | MG_F_SEND_AND_CLOSE))) {
        if (nc->send_mbuf.len == 0) {
          mg_ws_handshake(nc, vec, hm);
        }
        mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,
                hm);
        mg_ws_handler(nc, MG_EV_RECV, ev_data MG_UD_ARG(user_data));
      }
    }
#endif /* MG_ENABLE_HTTP_WEBSOCKET */
    else if (hm->message.len > pd->rcvd) {
      /* Not yet received all HTTP body, deliver MG_EV_HTTP_CHUNK */
      deliver_chunk(nc, hm, req_len);
      if (nc->recv_mbuf_limit > 0 && nc->recv_mbuf.len >= nc->recv_mbuf_limit) {
        LOG(LL_ERROR, ("%p recv buffer (%lu bytes) exceeds the limit "
                       "%lu bytes, and not drained, closing",
                       nc, (unsigned long) nc->recv_mbuf.len,
                       (unsigned long) nc->recv_mbuf_limit));
        nc->flags |= MG_F_CLOSE_IMMEDIATELY;
      }
    } else {
      /* We did receive all HTTP body. */
      int request_done = 1;
      int trigger_ev = nc->listener ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;
      char addr[32];
      mg_sock_addr_to_str(&nc->sa, addr, sizeof(addr),
                          MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);
      DBG(("%p %s %.*s %.*s", nc, addr, (int) hm->method.len, hm->method.p,
           (int) hm->uri.len, hm->uri.p));
      deliver_chunk(nc, hm, req_len);
      /* Whole HTTP message is fully buffered, call event handler */
      mg_http_call_endpoint_handler(nc, trigger_ev, hm);
      mbuf_remove(io, hm->message.len);
      pd->rcvd -= hm->message.len;
#if MG_ENABLE_FILESYSTEM
      /* We don't have a generic mechanism of communicating that we are done
       * responding to a request (should probably add one). But if we are
       * serving
       * a file, we are definitely not done. */
      if (pd->file.fp != NULL) request_done = 0;
#endif
#if MG_ENABLE_HTTP_CGI
      /* If this is a CGI request, we are not done either. */
      if (pd->cgi.cgi_nc != NULL) request_done = 0;
#endif
      if (request_done && io->len > 0) goto again;
    }
  }
}
