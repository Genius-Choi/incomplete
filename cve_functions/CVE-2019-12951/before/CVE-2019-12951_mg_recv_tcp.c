static int mg_recv_tcp(struct mg_connection *nc, char *buf, size_t len) {
  int n = 0;
#if MG_ENABLE_SSL
  if (nc->flags & MG_F_SSL) {
    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {
      n = mg_ssl_if_read(nc, buf, len);
      DBG(("%p <- %d bytes (SSL)", nc, n));
      if (n < 0) {
        if (n == MG_SSL_WANT_READ) {
          nc->flags |= MG_F_WANT_READ;
          n = 0;
        } else {
          nc->flags |= MG_F_CLOSE_IMMEDIATELY;
        }
      } else if (n > 0) {
        nc->flags &= ~MG_F_WANT_READ;
      }
    } else {
      mg_ssl_handshake(nc);
    }
  } else
#endif
  {
    n = nc->iface->vtable->tcp_recv(nc, buf, len);
    DBG(("%p <- %d bytes", nc, n));
  }
  if (n > 0) {
    nc->recv_mbuf.len += n;
    nc->last_io_time = (time_t) mg_time();
#if !defined(NO_LIBC) && MG_ENABLE_HEXDUMP
    if (nc->mgr && nc->mgr->hexdump_file != NULL) {
      mg_hexdump_connection(nc, nc->mgr->hexdump_file, buf, n, MG_EV_RECV);
    }
#endif
    mbuf_trim(&nc->recv_mbuf);
    mg_call(nc, NULL, nc->user_data, MG_EV_RECV, &n);
  } else if (n < 0) {
    nc->flags |= MG_F_CLOSE_IMMEDIATELY;
  }
  mbuf_trim(&nc->recv_mbuf);
  return n;
}
