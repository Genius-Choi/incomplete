static int mg_recv_udp(struct mg_connection *nc, char *buf, size_t len) {
  int n = 0;
  struct mg_connection *lc = nc;
  union socket_address sa;
  size_t sa_len = sizeof(sa);
  n = nc->iface->vtable->udp_recv(lc, buf, len, &sa, &sa_len);
  if (n < 0) {
    lc->flags |= MG_F_CLOSE_IMMEDIATELY;
    goto out;
  }
  if (nc->flags & MG_F_LISTENING) {
    /*
     * Do we have an existing connection for this source?
     * This is very inefficient for long connection lists.
     */
    lc = nc;
    for (nc = mg_next(lc->mgr, NULL); nc != NULL; nc = mg_next(lc->mgr, nc)) {
      if (memcmp(&nc->sa.sa, &sa.sa, sa_len) == 0 && nc->listener == lc) {
        break;
      }
    }
    if (nc == NULL) {
      struct mg_add_sock_opts opts;
      memset(&opts, 0, sizeof(opts));
      /* Create fake connection w/out sock initialization */
      nc = mg_create_connection_base(lc->mgr, lc->handler, opts);
      if (nc != NULL) {
        nc->sock = lc->sock;
        nc->listener = lc;
        nc->sa = sa;
        nc->proto_handler = lc->proto_handler;
        nc->user_data = lc->user_data;
        nc->recv_mbuf_limit = lc->recv_mbuf_limit;
        nc->flags = MG_F_UDP;
        /*
         * Long-lived UDP "connections" i.e. interactions that involve more
         * than one request and response are rare, most are transactional:
         * response is sent and the "connection" is closed. Or - should be.
         * But users (including ourselves) tend to forget about that part,
         * because UDP is connectionless and one does not think about
         * processing a UDP request as handling a connection that needs to be
         * closed. Thus, we begin with SEND_AND_CLOSE flag set, which should
         * be a reasonable default for most use cases, but it is possible to
         * turn it off the connection should be kept alive after processing.
         */
        nc->flags |= MG_F_SEND_AND_CLOSE;
        mg_add_conn(lc->mgr, nc);
        mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);
      }
    }
  }
  if (nc != NULL) {
    DBG(("%p <- %d bytes from %s:%d", nc, n, inet_ntoa(nc->sa.sin.sin_addr),
         ntohs(nc->sa.sin.sin_port)));
    if (nc == lc) {
      nc->recv_mbuf.len += n;
    } else {
      mbuf_append(&nc->recv_mbuf, buf, n);
    }
    mbuf_trim(&lc->recv_mbuf);
    lc->last_io_time = nc->last_io_time = (time_t) mg_time();
#if !defined(NO_LIBC) && MG_ENABLE_HEXDUMP
    if (nc->mgr && nc->mgr->hexdump_file != NULL) {
      mg_hexdump_connection(nc, nc->mgr->hexdump_file, buf, n, MG_EV_RECV);
    }
#endif
    if (n != 0) {
      mg_call(nc, NULL, nc->user_data, MG_EV_RECV, &n);
    }
  }

out:
  mbuf_free(&lc->recv_mbuf);
  return n;
}
