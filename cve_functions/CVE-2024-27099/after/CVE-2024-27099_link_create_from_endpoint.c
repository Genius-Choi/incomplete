LINK_HANDLE link_create_from_endpoint(SESSION_HANDLE session, LINK_ENDPOINT_HANDLE link_endpoint, const char* name, role role, AMQP_VALUE source, AMQP_VALUE target)
{
    LINK_INSTANCE* result = (LINK_INSTANCE*)calloc(1, sizeof(LINK_INSTANCE));
    if (result == NULL)
    {
        LogError("Cannot create link");
    }
    else
    {
        result->link_state = LINK_STATE_DETACHED;
        result->previous_link_state = LINK_STATE_DETACHED;
        result->session = session;
        result->handle = 0;
        result->snd_settle_mode = sender_settle_mode_unsettled;
        result->rcv_settle_mode = receiver_settle_mode_first;
        result->delivery_count = 0;
        result->initial_delivery_count = 0;
        result->max_message_size = 0;
        result->max_link_credit = DEFAULT_LINK_CREDIT;
        result->peer_max_message_size = 0;
        result->is_underlying_session_begun = false;
        result->is_closed = false;
        result->attach_properties = NULL;
        result->received_payload = NULL;
        result->received_payload_size = 0;
        result->received_delivery_id = 0;
        result->source = amqpvalue_clone(target);
        result->target = amqpvalue_clone(source);
        result->on_link_detach_received_event_subscription.on_link_detach_received = NULL;
        result->on_link_detach_received_event_subscription.context = NULL;

        if (role == role_sender)
        {
            result->role = role_receiver;
        }
        else
        {
            result->role = role_sender;
        }

        result->tick_counter = tickcounter_create();
        if (result->tick_counter == NULL)
        {
            LogError("Cannot create tick counter for link");
            free(result);
            result = NULL;
        }
        else
        {
            result->pending_deliveries = singlylinkedlist_create();
            if (result->pending_deliveries == NULL)
            {
                LogError("Cannot create pending deliveries list");
                tickcounter_destroy(result->tick_counter);
                free(result);
                result = NULL;
            }
            else
            {
                size_t name_length = strlen(name);
                result->name = (char*)malloc(name_length + 1);
                if (result->name == NULL)
                {
                    LogError("Cannot allocate memory for link name");
                    tickcounter_destroy(result->tick_counter);
                    singlylinkedlist_destroy(result->pending_deliveries);
                    free(result);
                    result = NULL;
                }
                else
                {
                    (void)memcpy(result->name, name, name_length + 1);
                    result->on_link_state_changed = NULL;
                    result->callback_context = NULL;
                    result->link_endpoint = link_endpoint;
                }
            }
        }
    }

    return result;
}
