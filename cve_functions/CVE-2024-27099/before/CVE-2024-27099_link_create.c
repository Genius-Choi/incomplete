LINK_HANDLE link_create(SESSION_HANDLE session, const char* name, role role, AMQP_VALUE source, AMQP_VALUE target)
{
    LINK_INSTANCE* result = (LINK_INSTANCE*)calloc(1, sizeof(LINK_INSTANCE));
    if (result == NULL)
    {
        LogError("Cannot create link");
    }
    else
    {
        result->link_state = LINK_STATE_DETACHED;
        result->previous_link_state = LINK_STATE_DETACHED;
        result->role = role;
        result->source = amqpvalue_clone(source);
        result->target = amqpvalue_clone(target);
        result->session = session;
        result->handle = 0;
        result->snd_settle_mode = sender_settle_mode_unsettled;
        result->rcv_settle_mode = receiver_settle_mode_first;
        result->delivery_count = 0;
        result->initial_delivery_count = 0;
        result->max_message_size = 0;
        result->max_link_credit = DEFAULT_LINK_CREDIT;
        result->peer_max_message_size = 0;
        result->is_underlying_session_begun = false;
        result->is_closed = false;
        result->attach_properties = NULL;
        result->received_payload = NULL;
        result->received_payload_size = 0;
        result->received_delivery_id = 0;
        result->on_link_detach_received_event_subscription.on_link_detach_received = NULL;
        result->on_link_detach_received_event_subscription.context = NULL;

        result->tick_counter = tickcounter_create();
        if (result->tick_counter == NULL)
        {
            LogError("Cannot create tick counter for link");
            free(result);
            result = NULL;
        }
        else
        {
            result->pending_deliveries = singlylinkedlist_create();
            if (result->pending_deliveries == NULL)
            {
                LogError("Cannot create pending deliveries list");
                tickcounter_destroy(result->tick_counter);
                free(result);
                result = NULL;
            }
            else
            {
                size_t name_length = strlen(name);
                result->name = (char*)malloc(name_length + 1);
                if (result->name == NULL)
                {
                    LogError("Cannot allocate memory for link name");
                    tickcounter_destroy(result->tick_counter);
                    singlylinkedlist_destroy(result->pending_deliveries);
                    free(result);
                    result = NULL;
                }
                else
                {
                    result->on_link_state_changed = NULL;
                    result->callback_context = NULL;
                    set_link_state(result, LINK_STATE_DETACHED);

                    (void)memcpy(result->name, name, name_length + 1);
                    result->link_endpoint = session_create_link_endpoint(session, name);
                    if (result->link_endpoint == NULL)
                    {
                        LogError("Cannot create link endpoint");
                        tickcounter_destroy(result->tick_counter);
                        singlylinkedlist_destroy(result->pending_deliveries);
                        free(result->name);
                        free(result);
                        result = NULL;
                    }
                    else
                    {
                        // This ensures link.c gets notified if the link endpoint is destroyed
                        // by uamqp (due to a DETACH from the hub, e.g.) to prevent a double free.
                        session_set_link_endpoint_callback(result->link_endpoint, on_link_endpoint_destroyed, result);
                    }
                }
            }
        }
    }

    return result;
}
