static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,
			     struct packet_type *pt, struct net_device *orig_dev)
{
	struct packet_fanout *f = pt->af_packet_priv;
	unsigned int num = f->num_members;
	struct packet_sock *po;
	unsigned int idx;

	if (!net_eq(dev_net(dev), read_pnet(&f->net)) ||
	    !num) {
		kfree_skb(skb);
		return 0;
	}

	switch (f->type) {
	case PACKET_FANOUT_HASH:
	default:
		if (fanout_has_flag(f, PACKET_FANOUT_FLAG_DEFRAG)) {
			skb = ip_check_defrag(skb, IP_DEFRAG_AF_PACKET);
			if (!skb)
				return 0;
		}
		skb_get_rxhash(skb);
		idx = fanout_demux_hash(f, skb, num);
		break;
	case PACKET_FANOUT_LB:
		idx = fanout_demux_lb(f, skb, num);
		break;
	case PACKET_FANOUT_CPU:
		idx = fanout_demux_cpu(f, skb, num);
		break;
	case PACKET_FANOUT_RND:
		idx = fanout_demux_rnd(f, skb, num);
		break;
	case PACKET_FANOUT_ROLLOVER:
		idx = fanout_demux_rollover(f, skb, 0, (unsigned int) -1, num);
		break;
	}

	po = pkt_sk(f->arr[idx]);
	if (fanout_has_flag(f, PACKET_FANOUT_FLAG_ROLLOVER) &&
	    unlikely(!packet_rcv_has_room(po, skb))) {
		idx = fanout_demux_rollover(f, skb, idx, idx, num);
		po = pkt_sk(f->arr[idx]);
	}

	return po->prot_hook.func(skb, dev, &po->prot_hook, orig_dev);
}
