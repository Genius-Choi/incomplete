	demangle_function_name(work, mangled, declp, scan) struct work_stuff *work;
const char **mangled;
string *declp;
const char *scan;
{
	size_t i;
	string type;
	const char *tem;

	string_appendn(declp, (*mangled), scan - (*mangled));
	string_need(declp, 1);
	*(declp->p) = '\0';

	/* Consume the function name, including the "__" separating the name
	   from the signature.  We are guaranteed that SCAN points to the
	   separator.  */

	(*mangled) = scan + 2;
	/* We may be looking at an instantiation of a template function:
	   foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a
	   following _F marks the start of the function arguments.  Handle
	   the template arguments first. */

	if (HP_DEMANGLING && (**mangled == 'X')) {
		demangle_arm_hp_template(work, mangled, 0, declp);
		/* This leaves MANGLED pointing to the 'F' marking func args */
	}

	if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) {

		/* See if we have an ARM style constructor or destructor operator.
		   If so, then just record it, clear the decl, and return.
		   We can't build the actual constructor/destructor decl until later,
		   when we recover the class name from the signature.  */

		if (strcmp(declp->b, "__ct") == 0) {
			work->constructor += 1;
			string_clear(declp);
			return;
		} else if (strcmp(declp->b, "__dt") == 0) {
			work->destructor += 1;
			string_clear(declp);
			return;
		}
	}

	if (declp->p - declp->b >= 3 && declp->b[0] == 'o' && declp->b[1] == 'p' && strchr(cplus_markers, declp->b[2]) != NULL) {
		/* see if it's an assignment expression */
		if (declp->p - declp->b >= 10 /* op$assign_ */
			&& memcmp(declp->b + 3, "assign_", 7) == 0) {
			for (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {
				int len = declp->p - declp->b - 10;
				if ((int)strlen(optable[i].in) == len && memcmp(optable[i].in, declp->b + 10, len) == 0) {
					string_clear(declp);
					string_append(declp, "operator");
					string_append(declp, optable[i].out);
					string_append(declp, "=");
					break;
				}
			}
		} else {
			for (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {
				int len = declp->p - declp->b - 3;
				if ((int)strlen(optable[i].in) == len && memcmp(optable[i].in, declp->b + 3, len) == 0) {
					string_clear(declp);
					string_append(declp, "operator");
					string_append(declp, optable[i].out);
					break;
				}
			}
		}
	} else if (declp->p - declp->b >= 5 && memcmp(declp->b, "type", 4) == 0 && strchr(cplus_markers, declp->b[4]) != NULL) {
		/* type conversion operator */
		tem = declp->b + 5;
		if (do_type(work, &tem, &type)) {
			string_clear(declp);
			string_append(declp, "operator ");
			string_appends(declp, &type);
			string_delete(&type);
		}
	} else if (declp->b[0] == '_' && declp->b[1] == '_' && declp->b[2] == 'o' && declp->b[3] == 'p') {
		/* ANSI.  */
		/* type conversion operator.  */
		tem = declp->b + 4;
		if (do_type(work, &tem, &type)) {
			string_clear(declp);
			string_append(declp, "operator ");
			string_appends(declp, &type);
			string_delete(&type);
		}
	} else if (declp->b[0] == '_' && declp->b[1] == '_' && declp->b[2] >= 'a' && declp->b[2] <= 'z' && declp->b[3] >= 'a' && declp->b[3] <= 'z') {
		if (declp->b[4] == '\0') {
			/* Operator.  */
			for (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {
				if (strlen(optable[i].in) == 2 && memcmp(optable[i].in, declp->b + 2, 2) == 0) {
					string_clear(declp);
					string_append(declp, "operator");
					string_append(declp, optable[i].out);
					break;
				}
			}
		} else {
			if (declp->b[2] == 'a' && declp->b[5] == '\0') {
				/* Assignment.  */
				for (i = 0; i < sizeof(optable) / sizeof(optable[0]); i++) {
					if (strlen(optable[i].in) == 3 && memcmp(optable[i].in, declp->b + 2, 3) == 0) {
						string_clear(declp);
						string_append(declp, "operator");
						string_append(declp, optable[i].out);
						break;
					}
				}
			}
		}
	}
}
