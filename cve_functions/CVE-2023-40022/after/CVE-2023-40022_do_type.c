do_type(work, mangled, result)
struct work_stuff *work;
const char **mangled;
string *result;
{
	int n;
	int done;
	int success;
	string decl;
	const char *remembered_type;
	int type_quals;
	string btype;
	type_kind_t tk = tk_none;

	string_init(&btype);
	string_init(&decl);
	string_init(result);

	done = 0;
	success = 1;
	while (success && !done) {
		int member;
		switch (**mangled) {

			/* A pointer type */
		case 'P':
		case 'p':
			(*mangled)++;
			if (!(work->options & DMGL_JAVA))
				string_prepend(&decl, "*");
			if (tk == tk_none)
				tk = tk_pointer;
			break;

			/* A reference type */
		case 'R':
			(*mangled)++;
			string_prepend(&decl, "&");
			if (tk == tk_none)
				tk = tk_reference;
			break;

			/* An array */
		case 'A': {
			++(*mangled);
			if (!STRING_EMPTY(&decl) && (decl.b[0] == '*' || decl.b[0] == '&')) {
				string_prepend(&decl, "(");
				string_append(&decl, ")");
			}
			string_append(&decl, "[");
			if (**mangled != '_')
				success = demangle_template_value_parm(work, mangled, &decl,
					tk_integral);
			if (**mangled == '_')
				++(*mangled);
			string_append(&decl, "]");
			break;
		}

		/* A back reference to a previously seen type */
		case 'T':
			(*mangled)++;
			if (!get_count(mangled, &n) || n >= work->ntypes) {
				success = 0;
			} else {
				remembered_type = work->typevec[n];
				mangled = &remembered_type;
			}
			break;

			/* A function */
		case 'F':
			(*mangled)++;
			if (!STRING_EMPTY(&decl) && (decl.b[0] == '*' || decl.b[0] == '&')) {
				string_prepend(&decl, "(");
				string_append(&decl, ")");
			}
			/* After picking off the function args, we expect to either find the
			   function return type (preceded by an '_') or the end of the
			   string.  */
			if (!demangle_nested_args(work, mangled, &decl) || (**mangled != '_' && **mangled != '\0')) {
				success = 0;
				break;
			}
			if (success && (**mangled == '_'))
				(*mangled)++;
			break;

		case 'M':
		case 'O': {
			type_quals = TYPE_UNQUALIFIED;

			member = **mangled == 'M';
			(*mangled)++;

			string_append(&decl, ")");
			string_prepend(&decl, SCOPE_STRING(work));
			if (isdigit((unsigned char)**mangled)) {
				n = consume_count(mangled);
				if (n == -1 || (int)strlen(*mangled) < n) {
					success = 0;
					break;
				}
				string_prependn(&decl, *mangled, n);
				*mangled += n;
			} else if (**mangled == 'X' || **mangled == 'Y') {
				string temp;
				do_type(work, mangled, &temp);
				string_prepends(&decl, &temp);
			} else if (**mangled == 't') {
				string temp;
				string_init(&temp);
				success = demangle_template(work, mangled, &temp,
					NULL, 1, 1);
				if (success) {
					string_prependn(&decl, temp.b, temp.p - temp.b);
					string_clear(&temp);
				} else
					break;
			} else {
				success = 0;
				break;
			}

			string_prepend(&decl, "(");
			if (member) {
				switch (**mangled) {
				case 'C':
				case 'V':
				case 'u':
					type_quals |= code_for_qualifier(**mangled);
					(*mangled)++;
					break;

				default:
					break;
				}

				if (*(*mangled)++ != 'F') {
					success = 0;
					break;
				}
			}
			if ((member && !demangle_nested_args(work, mangled, &decl)) || **mangled != '_') {
				success = 0;
				break;
			}
			(*mangled)++;
			if (!PRINT_ANSI_QUALIFIERS) {
				break;
			}
			if (type_quals != TYPE_UNQUALIFIED) {
				APPEND_BLANK(&decl);
				string_append(&decl, qualifier_string(type_quals));
			}
			break;
		}
		case 'G':
			(*mangled)++;
			break;

		case 'C':
		case 'V':
		case 'u':
			if (PRINT_ANSI_QUALIFIERS) {
				if (!STRING_EMPTY(&decl))
					string_prepend(&decl, " ");

				string_prepend(&decl, demangle_qualifier(**mangled));
			}
			(*mangled)++;
			break;
			/*
			  }
			  */

			/* fall through */
		default:
			done = 1;
			break;
		}
	}

	if (success)
		switch (**mangled) {
			/* A qualified name, such as "Outer::Inner".  */
		case 'Q':
		case 'K': {
			success = demangle_qualified(work, mangled, result, 0, 1);
			break;
		}

		/* A back reference to a previously seen squangled type */
		case 'B':
			(*mangled)++;
			if (!get_count(mangled, &n) || n >= work->numb)
				success = 0;
			else
				string_append(result, work->btypevec[n]);
			break;

		case 'X':
		case 'Y':
			/* A template parm.  We substitute the corresponding argument. */
			{
				int idx;

				(*mangled)++;
				idx = consume_count_with_underscores(mangled);

				if (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1) {
					success = 0;
					break;
				}

				if (work->tmpl_argvec)
					string_append(result, work->tmpl_argvec[idx]);
				else {
					char buf[10];
					sprintf(buf, "T%d", idx);
					string_append(result, buf);
				}

				success = 1;
			}
			break;

		default:
			success = demangle_fund_type(work, mangled, result);
			if (tk == tk_none)
				tk = (type_kind_t)success;
			break;
		}

	if (success) {
		if (!STRING_EMPTY(&decl)) {
			string_append(result, " ");
			string_appends(result, &decl);
		}
	} else
		string_delete(result);
	string_delete(&decl);

	if (success)
		/* Assume an integral type, if we're not sure.  */
		return (int)((tk == tk_none) ? tk_integral : tk);
	else
		return 0;
}
