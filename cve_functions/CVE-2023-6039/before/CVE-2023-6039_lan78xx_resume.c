static int lan78xx_resume(struct usb_interface *intf)
{
	struct lan78xx_net *dev = usb_get_intfdata(intf);
	bool dev_open;
	int ret;

	mutex_lock(&dev->dev_mutex);

	netif_dbg(dev, ifup, dev->net, "resuming device");

	dev_open = test_bit(EVENT_DEV_OPEN, &dev->flags);

	if (dev_open) {
		bool pipe_halted = false;

		ret = lan78xx_flush_tx_fifo(dev);
		if (ret < 0)
			goto out;

		if (dev->urb_intr) {
			int ret = usb_submit_urb(dev->urb_intr, GFP_KERNEL);

			if (ret < 0) {
				if (ret == -ENODEV)
					netif_device_detach(dev->net);
				netdev_warn(dev->net, "Failed to submit intr URB");
			}
		}

		spin_lock_irq(&dev->txq.lock);

		if (netif_device_present(dev->net)) {
			pipe_halted = lan78xx_submit_deferred_urbs(dev);

			if (pipe_halted)
				lan78xx_defer_kevent(dev, EVENT_TX_HALT);
		}

		clear_bit(EVENT_DEV_ASLEEP, &dev->flags);

		spin_unlock_irq(&dev->txq.lock);

		if (!pipe_halted &&
		    netif_device_present(dev->net) &&
		    (lan78xx_tx_pend_data_len(dev) < lan78xx_tx_urb_space(dev)))
			netif_start_queue(dev->net);

		ret = lan78xx_start_tx_path(dev);
		if (ret < 0)
			goto out;

		napi_schedule(&dev->napi);

		if (!timer_pending(&dev->stat_monitor)) {
			dev->delta = 1;
			mod_timer(&dev->stat_monitor,
				  jiffies + STAT_UPDATE_TIMER);
		}

	} else {
		clear_bit(EVENT_DEV_ASLEEP, &dev->flags);
	}

	ret = lan78xx_write_reg(dev, WUCSR2, 0);
	if (ret < 0)
		goto out;
	ret = lan78xx_write_reg(dev, WUCSR, 0);
	if (ret < 0)
		goto out;
	ret = lan78xx_write_reg(dev, WK_SRC, 0xFFF1FF1FUL);
	if (ret < 0)
		goto out;

	ret = lan78xx_write_reg(dev, WUCSR2, WUCSR2_NS_RCD_ |
					     WUCSR2_ARP_RCD_ |
					     WUCSR2_IPV6_TCPSYN_RCD_ |
					     WUCSR2_IPV4_TCPSYN_RCD_);
	if (ret < 0)
		goto out;

	ret = lan78xx_write_reg(dev, WUCSR, WUCSR_EEE_TX_WAKE_ |
					    WUCSR_EEE_RX_WAKE_ |
					    WUCSR_PFDA_FR_ |
					    WUCSR_RFE_WAKE_FR_ |
					    WUCSR_WUFR_ |
					    WUCSR_MPR_ |
					    WUCSR_BCST_FR_);
	if (ret < 0)
		goto out;

	ret = 0;
out:
	mutex_unlock(&dev->dev_mutex);

	return ret;
}
