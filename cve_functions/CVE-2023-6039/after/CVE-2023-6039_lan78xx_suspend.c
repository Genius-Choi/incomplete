static int lan78xx_suspend(struct usb_interface *intf, pm_message_t message)
{
	struct lan78xx_net *dev = usb_get_intfdata(intf);
	bool dev_open;
	int ret;

	mutex_lock(&dev->dev_mutex);

	netif_dbg(dev, ifdown, dev->net,
		  "suspending: pm event %#x", message.event);

	dev_open = test_bit(EVENT_DEV_OPEN, &dev->flags);

	if (dev_open) {
		spin_lock_irq(&dev->txq.lock);
		/* don't autosuspend while transmitting */
		if ((skb_queue_len(&dev->txq) ||
		     skb_queue_len(&dev->txq_pend)) &&
		    PMSG_IS_AUTO(message)) {
			spin_unlock_irq(&dev->txq.lock);
			ret = -EBUSY;
			goto out;
		} else {
			set_bit(EVENT_DEV_ASLEEP, &dev->flags);
			spin_unlock_irq(&dev->txq.lock);
		}

		/* stop RX */
		ret = lan78xx_stop_rx_path(dev);
		if (ret < 0)
			goto out;

		ret = lan78xx_flush_rx_fifo(dev);
		if (ret < 0)
			goto out;

		/* stop Tx */
		ret = lan78xx_stop_tx_path(dev);
		if (ret < 0)
			goto out;

		/* empty out the Rx and Tx queues */
		netif_device_detach(dev->net);
		lan78xx_terminate_urbs(dev);
		usb_kill_urb(dev->urb_intr);

		/* reattach */
		netif_device_attach(dev->net);

		del_timer(&dev->stat_monitor);

		if (PMSG_IS_AUTO(message)) {
			ret = lan78xx_set_auto_suspend(dev);
			if (ret < 0)
				goto out;
		} else {
			struct lan78xx_priv *pdata;

			pdata = (struct lan78xx_priv *)(dev->data[0]);
			netif_carrier_off(dev->net);
			ret = lan78xx_set_suspend(dev, pdata->wol);
			if (ret < 0)
				goto out;
		}
	} else {
		/* Interface is down; don't allow WOL and PHY
		 * events to wake up the host
		 */
		u32 buf;

		set_bit(EVENT_DEV_ASLEEP, &dev->flags);

		ret = lan78xx_write_reg(dev, WUCSR, 0);
		if (ret < 0)
			goto out;
		ret = lan78xx_write_reg(dev, WUCSR2, 0);
		if (ret < 0)
			goto out;

		ret = lan78xx_read_reg(dev, PMT_CTL, &buf);
		if (ret < 0)
			goto out;

		buf &= ~PMT_CTL_RES_CLR_WKP_EN_;
		buf |= PMT_CTL_RES_CLR_WKP_STS_;
		buf &= ~PMT_CTL_SUS_MODE_MASK_;
		buf |= PMT_CTL_SUS_MODE_3_;

		ret = lan78xx_write_reg(dev, PMT_CTL, buf);
		if (ret < 0)
			goto out;

		ret = lan78xx_read_reg(dev, PMT_CTL, &buf);
		if (ret < 0)
			goto out;

		buf |= PMT_CTL_WUPS_MASK_;

		ret = lan78xx_write_reg(dev, PMT_CTL, buf);
		if (ret < 0)
			goto out;
	}

	ret = 0;
out:
	mutex_unlock(&dev->dev_mutex);

	return ret;
}
