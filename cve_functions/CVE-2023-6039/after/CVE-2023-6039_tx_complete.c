static void tx_complete(struct urb *urb)
{
	struct sk_buff *skb = (struct sk_buff *)urb->context;
	struct skb_data *entry = (struct skb_data *)skb->cb;
	struct lan78xx_net *dev = entry->dev;

	if (urb->status == 0) {
		dev->net->stats.tx_packets += entry->num_of_packet;
		dev->net->stats.tx_bytes += entry->length;
	} else {
		dev->net->stats.tx_errors += entry->num_of_packet;

		switch (urb->status) {
		case -EPIPE:
			lan78xx_defer_kevent(dev, EVENT_TX_HALT);
			break;

		/* software-driven interface shutdown */
		case -ECONNRESET:
		case -ESHUTDOWN:
			netif_dbg(dev, tx_err, dev->net,
				  "tx err interface gone %d\n",
				  entry->urb->status);
			break;

		case -EPROTO:
		case -ETIME:
		case -EILSEQ:
			netif_stop_queue(dev->net);
			netif_dbg(dev, tx_err, dev->net,
				  "tx err queue stopped %d\n",
				  entry->urb->status);
			break;
		default:
			netif_dbg(dev, tx_err, dev->net,
				  "unknown tx err %d\n",
				  entry->urb->status);
			break;
		}
	}

	usb_autopm_put_interface_async(dev->intf);

	skb_unlink(skb, &dev->txq);

	lan78xx_release_tx_buf(dev, skb);

	/* Re-schedule NAPI if Tx data pending but no URBs in progress.
	 */
	if (skb_queue_empty(&dev->txq) &&
	    !skb_queue_empty(&dev->txq_pend))
		napi_schedule(&dev->napi);
}
