static int lan78xx_rx(struct lan78xx_net *dev, struct sk_buff *skb,
		      int budget, int *work_done)
{
	if (skb->len < RX_SKB_MIN_LEN)
		return 0;

	/* Extract frames from the URB buffer and pass each one to
	 * the stack in a new NAPI SKB.
	 */
	while (skb->len > 0) {
		u32 rx_cmd_a, rx_cmd_b, align_count, size;
		u16 rx_cmd_c;
		unsigned char *packet;

		rx_cmd_a = get_unaligned_le32(skb->data);
		skb_pull(skb, sizeof(rx_cmd_a));

		rx_cmd_b = get_unaligned_le32(skb->data);
		skb_pull(skb, sizeof(rx_cmd_b));

		rx_cmd_c = get_unaligned_le16(skb->data);
		skb_pull(skb, sizeof(rx_cmd_c));

		packet = skb->data;

		/* get the packet length */
		size = (rx_cmd_a & RX_CMD_A_LEN_MASK_);
		align_count = (4 - ((size + RXW_PADDING) % 4)) % 4;

		if (unlikely(size > skb->len)) {
			netif_dbg(dev, rx_err, dev->net,
				  "size err rx_cmd_a=0x%08x\n",
				  rx_cmd_a);
			return 0;
		}

		if (unlikely(rx_cmd_a & RX_CMD_A_RED_)) {
			netif_dbg(dev, rx_err, dev->net,
				  "Error rx_cmd_a=0x%08x", rx_cmd_a);
		} else {
			u32 frame_len;
			struct sk_buff *skb2;

			if (unlikely(size < ETH_FCS_LEN)) {
				netif_dbg(dev, rx_err, dev->net,
					  "size err rx_cmd_a=0x%08x\n",
					  rx_cmd_a);
				return 0;
			}

			frame_len = size - ETH_FCS_LEN;

			skb2 = napi_alloc_skb(&dev->napi, frame_len);
			if (!skb2)
				return 0;

			memcpy(skb2->data, packet, frame_len);

			skb_put(skb2, frame_len);

			lan78xx_rx_csum_offload(dev, skb2, rx_cmd_a, rx_cmd_b);
			lan78xx_rx_vlan_offload(dev, skb2, rx_cmd_a, rx_cmd_b);

			/* Processing of the URB buffer must complete once
			 * it has started. If the NAPI work budget is exhausted
			 * while frames remain they are added to the overflow
			 * queue for delivery in the next NAPI polling cycle.
			 */
			if (*work_done < budget) {
				lan78xx_skb_return(dev, skb2);
				++(*work_done);
			} else {
				skb_queue_tail(&dev->rxq_overflow, skb2);
			}
		}

		skb_pull(skb, size);

		/* skip padding bytes before the next frame starts */
		if (skb->len)
			skb_pull(skb, align_count);
	}

	return 1;
}
