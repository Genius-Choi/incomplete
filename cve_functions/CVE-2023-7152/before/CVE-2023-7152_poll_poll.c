STATIC mp_obj_t poll_poll(size_t n_args, const mp_obj_t *args) {
    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);
    mp_uint_t n_ready = poll_poll_internal(n_args, args);

    // one or more objects are ready, or we had a timeout
    mp_obj_list_t *ret_list = MP_OBJ_TO_PTR(mp_obj_new_list(n_ready, NULL));
    n_ready = 0;
    for (mp_uint_t i = 0; i < self->poll_set.map.alloc; ++i) {
        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {
            continue;
        }
        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);
        if (poll_obj_get_revents(poll_obj) != 0) {
            mp_obj_t tuple[2] = {poll_obj->obj, MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj))};
            ret_list->items[n_ready++] = mp_obj_new_tuple(2, tuple);
        }
    }
    return MP_OBJ_FROM_PTR(ret_list);
}
