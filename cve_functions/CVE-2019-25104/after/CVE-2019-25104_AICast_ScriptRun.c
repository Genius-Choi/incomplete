qboolean AICast_ScriptRun( cast_state_t *cs, qboolean force ) {
	cast_script_stack_t *stack;

	if ( !aicast_scripts.integer ) {
		return qtrue;
	}

	if ( cs->castScriptStatus.castScriptEventIndex < 0 ) {
		return qtrue;
	}

	if ( !cs->castScriptEvents ) {
		cs->castScriptStatus.castScriptEventIndex = -1;
		return qtrue;
	}

	// only allow the PLAYER'S spawn function through if we're NOT still waiting on everything to finish loading in
	if ( !cs->entityNum && saveGamePending && Q_stricmp( "spawn", scriptEvents[cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].eventNum].eventStr ) ) {
		//char loading[4];
		//trap_Cvar_VariableStringBuffer( "savegame_loading", loading, sizeof(loading) );
		//if (strlen( loading ) > 0 && atoi(loading) != 0)	// we're loading a savegame
		return qfalse;
	}

	if ( !force && ( cs->scriptPauseTime >= level.time ) ) {
		return qtrue;
	}

	stack = &cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].stack;

	if ( !stack->numItems ) {
		cs->castScriptStatus.castScriptEventIndex = -1;
		return qtrue;
	}

	while ( cs->castScriptStatus.castScriptStackHead < stack->numItems )
	{
		//
		// show debugging info
		if (    ( cs->castScriptStatus.castScriptStackChangeTime == level.time ) &&
				(   ( aicast_debug.integer == 1 ) ||
					(   ( aicast_debug.integer == 2 ) &&
						( ( strlen( aicast_debugname.string ) < 1 ) || ( g_entities[cs->entityNum].aiName && !strcmp( aicast_debugname.string, g_entities[cs->entityNum].aiName ) ) ) ) ) ) {
			G_Printf( "(%s) AIScript command: %s %s\n", g_entities[cs->entityNum].aiName, stack->items[cs->castScriptStatus.castScriptStackHead].action->actionString, ( stack->items[cs->castScriptStatus.castScriptStackHead].params ? stack->items[cs->castScriptStatus.castScriptStackHead].params : "" ) );
		}
		//
		if ( !stack->items[cs->castScriptStatus.castScriptStackHead].action->actionFunc( cs, stack->items[cs->castScriptStatus.castScriptStackHead].params ) ) {
			// check that we are still running the same script that we were when we call the action
			if ( cs->castScriptStatus.castScriptEventIndex >= 0 && stack == &cs->castScriptEvents[cs->castScriptStatus.castScriptEventIndex].stack ) {
				cs->castScriptStatus.scriptFlags &= ~SFL_FIRST_CALL;
			}
			return qfalse;
		}
		// move to the next action in the script
		cs->castScriptStatus.castScriptStackHead++;
		// record the time that this new item became active
		cs->castScriptStatus.castScriptStackChangeTime = level.time;
		// reset misc stuff
		cs->castScriptStatus.scriptGotoId = -1;
		cs->castScriptStatus.scriptGotoEnt = -1;
		cs->castScriptStatus.scriptFlags |= SFL_FIRST_CALL;
	}

	cs->castScriptStatus.castScriptEventIndex = -1;

	return qtrue;
}
