static int32_t rcar_file_read(io_entity_t *entity, uintptr_t buffer,
			      size_t length, size_t *cnt)
{
	file_state_t *fp = (file_state_t *) entity->info;
	ssize_t offset = fp->offset + fp->position;
	uintptr_t handle;
	int32_t rc;

#ifdef SPD_NONE
	static uint32_t load_bl33x_counter = 1;
#else
	static uint32_t load_bl33x_counter;
#endif
	if (current_file.no_load != 0U) {
		*cnt = length;
		return IO_SUCCESS;
	}

	((io_drv_spec_t *) rcar_spec)->partition = fp->partition;

	rc = io_open(rcar_handle, rcar_spec, &handle);
	if (rc != IO_SUCCESS) {
		WARN("Failed to open FIP (%i)\n", rc);
		return IO_FAIL;
	}

	rc = io_seek(handle, IO_SEEK_SET, offset);
	if (rc != IO_SUCCESS) {
		WARN("%s: failed to seek\n", __func__);
		goto error;
	}

	if (load_bl33x_counter == RCAR_COUNT_LOAD_BL33) {
		rc = check_load_area(buffer, length);
		if (rc != IO_SUCCESS) {
			WARN("%s: load area err\n", __func__);
			goto error;
		}
	}

	rc = io_read(handle, buffer, length, cnt);
	if (rc != IO_SUCCESS) {
		WARN("Failed to read payload (%i)\n", rc);
		goto error;
	}

	fp->position += *cnt;
	io_close(handle);

	load_bl33x_counter += 1;
	if (load_bl33x_counter == RCAR_COUNT_LOAD_BL33X) {
		return load_bl33x();
	}

	return IO_SUCCESS;
error:
	io_close(handle);
	return IO_FAIL;
}
