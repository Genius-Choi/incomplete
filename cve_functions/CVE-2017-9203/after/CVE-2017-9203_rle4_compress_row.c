static int rle4_compress_row(struct rle_context *rlectx)
{
	size_t i;
	iw_byte dstbuf[2];
	iw_byte next_pix;
	int next_pix_is_trns;
	int num_trns = 0; // number of consecutive transparent pixels seen
	int retval = 0;
	iw_byte tmpb;

	rlectx->pending_data_start=0;
	rlectx->unc_len=0;
	rlectx->run_len=0;

	for(i=0;i<rlectx->img_width;i++) {

		// Read the next pixel
		next_pix = rlectx->srcrow[i];

		next_pix_is_trns = (rlectx->wctx->pal->entry[next_pix].a==0);
		if(num_trns>0 && !next_pix_is_trns) {
			rle_write_trns(rlectx,num_trns);
			num_trns=0;
		}
		else if(next_pix_is_trns) {
			if (rlectx->unc_len>0 || rlectx->run_len>0) {
				rle4_write_unc_and_run(rlectx);
			}
			num_trns++;
			continue;
		}

		// --------------------------------------------------------------
		// Add the pixel we just read to either the UNC or the RUN data.

		if(rlectx->run_len==0) {
			// We don't have a RUN, so we can put this pixel there.
			rlectx->run_len = 1;
			rlectx->run_byte = next_pix<<4;
		}
		else if(rlectx->run_len==1) {
			// If the run is 1, we can always add a 2nd pixel
			rlectx->run_byte |= next_pix;
			rlectx->run_len++;
		}
		else if(rlectx->run_len>=2 && (rlectx->run_len&1)==0 && next_pix==(rlectx->run_byte>>4)) {
			// pixel fits in the current run; add it.
			rlectx->run_len++;
		}
		else if(rlectx->run_len>=3 && (rlectx->run_len&1) && next_pix==(rlectx->run_byte&0x0f)) {
			// pixel fits in the current run; add it.
			rlectx->run_len++;
		}
		else if(rlectx->unc_len==0 && rlectx->run_len==2) {
			// We have one previous byte, and it's different from this one.
			// Move it to UNC, and make this one the RUN.
			rlectx->unc_len+=rlectx->run_len;
			rlectx->run_byte = next_pix<<4;
			rlectx->run_len = 1;
		}
		else if(ok_to_move_to_unc(rlectx)) {
			// We have a compressible run, but we think it's not long enough to be
			// beneficial. Convert it to uncompressed bytes -- except for the last
			// pixel, which can be left in the run.
			rlectx->unc_len += rlectx->run_len-1;
 
			if((rlectx->run_len&1)==0)
				rlectx->run_byte = (rlectx->run_byte&0x0f)<<4;
			else
				rlectx->run_byte = (rlectx->run_byte&0xf0);

			// Put the next byte in RLE. (It might get moved to UNC, below.)
			rlectx->run_len = 2;
			rlectx->run_byte |= next_pix;
		}
		else {
			// Nowhere to put the byte: write out everything, and start fresh.
			rle4_write_unc_and_run(rlectx);
			rlectx->run_len = 1;
			rlectx->run_byte = next_pix<<4;
		}

		// --------------------------------------------------------------
		// If any RUN bytes that can be added to UNC for free, do so.
		while(rlectx->unc_len>0 && rlectx->run_len>0 && rle4_get_incr_unc_cost(rlectx)==0) {
			rlectx->unc_len++;
			rlectx->run_len--;
			tmpb = rlectx->run_byte;
			// Reverse the two pixels stored in run_byte.
			rlectx->run_byte = (tmpb>>4) | ((tmpb&0x0f)<<4);
			if(rlectx->run_len==1) rlectx->run_byte &= 0xf0;
		}

		// --------------------------------------------------------------
		// If we hit certain high water marks, write out the current data.

		if(rlectx->run_len>=255) {
			// The maximum size for an RLE segment.
			rle4_write_unc_and_run(rlectx);
		}

		// --------------------------------------------------------------
		// Sanity check(s). This can be removed if we're sure the algorithm
		// is bug-free.

		// run_len can be at most 254 at this point.
		// If it were 255, it should have been written out already.
		if(rlectx->run_len>255) {
			iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 3");
			goto done;
		}
	}

	// End of row. Write out anything left over.
	rle4_write_unc_and_run(rlectx);

	// Write an end-of-line marker (0 0), or if this is the last row,
	// an end-of-bitmap marker (0 1).
	dstbuf[0]=0x00;
	dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;
	iwbmp_write(rlectx->wctx,dstbuf,2);
	rlectx->total_bytes_written+=2;

	retval = 1;

done:
	return retval;
}
