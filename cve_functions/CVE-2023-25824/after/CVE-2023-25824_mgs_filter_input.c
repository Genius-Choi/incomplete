apr_status_t mgs_filter_input(ap_filter_t * f,
        apr_bucket_brigade * bb,
        ap_input_mode_t mode,
        apr_read_type_e block, apr_off_t readbytes)
{
    apr_status_t status = APR_SUCCESS;
    mgs_handle_t *ctxt = (mgs_handle_t *) f->ctx;
    apr_size_t len = sizeof (ctxt->input_buffer);

    if (f->c->aborted) {
        gnutls_io_filter_eos(f, bb);
        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,
                      "%s: %sconnection aborted",
                      __func__, IS_PROXY_STR(ctxt));
        return APR_ECONNABORTED;
    }

    if (ctxt->status == 0) {
        int ret = gnutls_do_handshake(ctxt);
        if (ret == GNUTLS_E_SUCCESS)
            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, ctxt->c,
                          "%s: TLS %sconnection opened.",
                          __func__, IS_PROXY_STR(ctxt));
    }

    if (ctxt->status < 0)
    {
        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, ctxt->c,
                      "%s: %sconnection failed, cannot provide data!",
                      __func__, IS_PROXY_STR(ctxt));
        gnutls_io_filter_eos(f, bb);
        return APR_ECONNABORTED;
    }

    /* XXX: we don't currently support anything other than these modes. */
    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE &&
            mode != AP_MODE_SPECULATIVE && mode != AP_MODE_INIT) {
        return APR_ENOTIMPL;
    }

    ctxt->input_mode = mode;
    ctxt->input_block = block;

    if (ctxt->input_mode == AP_MODE_READBYTES ||
            ctxt->input_mode == AP_MODE_SPECULATIVE) {
        if (readbytes < 0) {
            /* you're asking us to speculatively read a negative number of bytes! */
            return APR_ENOTIMPL;
        }
        /* 'readbytes' and 'len' are of different integer types, which
         * might have different lengths. Read sizes should be too
         * small for 32 or 64 bit to matter, but we have to make
         * sure. */
#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)
        if ((apr_size_t) readbytes < len)
        {
            /* If readbytes is negative the function fails in the
             * check above, but the compiler doesn't get that. */
            if (__builtin_expect(imaxabs(readbytes) > SIZE_MAX, 0))
            {
                ap_log_cerror(APLOG_MARK, APLOG_CRIT, APR_EINVAL, ctxt->c,
                              "%s: prevented buffer length overflow",
                              __func__);
                return APR_EINVAL;
            }
            len = (apr_size_t) readbytes;
        }
#else
        if ((apr_size_t) readbytes < len
            && __builtin_add_overflow(readbytes, 0, &len))
        {
            ap_log_cerror(APLOG_MARK, APLOG_CRIT, APR_EINVAL, ctxt->c,
                          "%s: prevented buffer length overflow",
                          __func__);
            return APR_EINVAL;
        }
#endif
        status =
                gnutls_io_input_read(ctxt, ctxt->input_buffer, &len);
    } else if (ctxt->input_mode == AP_MODE_GETLINE) {
        status =
                gnutls_io_input_getline(ctxt, ctxt->input_buffer,
                &len);
    } else {
        /* We have no idea what you are talking about, so return an error. */
        return APR_ENOTIMPL;
    }

    if (status != APR_SUCCESS)
    {
        /* no data for nonblocking read, return APR_EAGAIN */
        if ((block == APR_NONBLOCK_READ) && APR_STATUS_IS_EINTR(status))
            return APR_EAGAIN;

        /* Close TLS session and free resources on EOF,
         * gnutls_io_filter_eos will add an EOS bucket */
        if (APR_STATUS_IS_EOF(status))
            mgs_bye(ctxt);

        gnutls_io_filter_eos(f, bb);
        return status;
    }

    /* Create a transient bucket out of the decrypted data. */
    if (len > 0) {
        apr_bucket *bucket =
                apr_bucket_transient_create(ctxt->input_buffer, len,
                f->c->bucket_alloc);
        APR_BRIGADE_INSERT_TAIL(bb, bucket);
    }

    return status;
}
