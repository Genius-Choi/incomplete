void testReadXRefSubsection()
{
    int64_t firstObject = 0;
    int64_t objectCount = 0;

    // TODO does ReadXRefSubsection with objectCount = 0 make sense ???

    // CVE-2017-5855 m_offsets.resize() NULL ptr read
    // CVE-2017-6844 m_offsets.resize() buffer overwrite 
    // false positives due to AFL setting allocator_may_return_null=1 which causes
    // ASAN to return NULL instead of throwing bad_alloc for out-of-memory conditions
    // https://github.com/mirrorer/afl/blob/master/docs/env_variables.txt#L248
    // https://github.com/google/sanitizers/issues/295#issuecomment-234273218 
    // the test for CVE-2018-5296 below checks that PoDoFo restricts allocations

    // CVE-2018-5296 m_offsets.resize() malloc failure when large size specified
    // check PoDoFo throws PdfError and not anything derived from exception
    // check PoDoFo can't allocate unrestricted amounts of memory

    if (PdfParser::GetMaxObjectCount() <= maxNumberOfIndirectObjects)
    {
        try
        {
            string strInput = generateXRefEntries(PdfParser::GetMaxObjectCount());
            PdfIndirectObjectList objects;
            PdfParserTest parser(objects, strInput);
            firstObject = 0;
            objectCount = PdfParser::GetMaxObjectCount();
            parser.ReadXRefSubsection(firstObject, objectCount);
            // expected to succeed
        }
        catch (PdfError&)
        {
            FAIL("should not throw PdfError");
        }
        catch (exception&)
        {
            FAIL("Unexpected exception type");
        }
    }
    else
    {
        // test has been called from testMaxObjectCount with PdfParser::SetMaxObjectCount()
        // set to a large value (large allocs are tested in address space tests below)
    }

    // don't run the following test if PdfParser::GetMaxObjectCount()+1 will overflow
    // in the numXRefEntries calculation below (otherwise we get an ASAN error)
    if (PdfParser::GetMaxObjectCount() < numeric_limits<unsigned>::max())
    {
        // don't generate xrefs for high values of GetMaxObjectCount() e.g. don't try to generate 2**63 xrefs
        unsigned numXRefEntries = std::min(maxNumberOfIndirectObjects + 1, PdfParser::GetMaxObjectCount() + 1);

        try
        {
            string strInput = generateXRefEntries(numXRefEntries);
            PdfIndirectObjectList objects;
            PdfParserTest parser(objects, strInput);
            firstObject = 0;
            objectCount = (int64_t)PdfParser::GetMaxObjectCount() + 1;
            parser.ReadXRefSubsection(firstObject, objectCount);
            FAIL("PdfError not thrown");
        }
        catch (PdfError& error)
        {
            // too many indirect objects in Trailer /Size key throws PdfErrorCode::ValueOutOfRange
            // but too many indirect objects in xref table throws PdfErrorCode::InvalidXRef
            REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
        }
        catch (exception&)
        {
            FAIL("Wrong exception type");
        }
    }

    // CVE-2018-5296 try to allocate more than address space size 
    // should throw a bad_length exception in STL which is rethrown as a PdfError
    try
    {
        // this attempts to allocate numeric_limits<size_t>::max()/2 * sizeof(TXRefEntry)
        // on 32-bit systems this allocates 2**31 * sizeof(TXRefEntry) = 2**31 * 16 (larger than 32-bit address space)
        // on LP64 (macOS,*nix) systems this allocates 2**63 * sizeof(TXRefEntry) = 2**63 * 24 (larger than 64-bit address space)
        // on LLP64 (Win64) systems this allocates 2**31 * sizeof(TXRefEntry) = 2**31 * 16 (smaller than 64-bit address space)
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = numeric_limits<size_t>::max() / 2 - 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        // if objectCount > PdfParser::GetMaxObjectCount() then we'll see PdfErrorCode::InvalidXRef
        // otherwise we'll see PdfErrorCode::ValueOutOfRange or PdfErrorCode::OutOfMemory (see testMaxObjectCount)
        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef
            || error.GetCode() == PdfErrorCode::ValueOutOfRange
            || error.GetCode() == PdfErrorCode::OutOfMemory));
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2018-5296 try to allocate 95% of VM address space size (which should always fail)
    if (!canOutOfMemoryKillUnitTests())
    {
        constexpr size_t maxObjects = numeric_limits<size_t>::max() / sizeof(PdfXRefEntry) / 100 * 95;

        try
        {
            string strInput = " ";
            PdfIndirectObjectList objects;
            PdfParserTest parser(objects, strInput);
            firstObject = 1;
            objectCount = maxObjects;
            parser.ReadXRefSubsection(firstObject, objectCount);
            FAIL("PdfError not thrown");
        }
        catch (PdfError& error)
        {
            if (maxObjects >= (size_t)PdfParser::GetMaxObjectCount())
                REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
            else
                REQUIRE(error.GetCode() == PdfErrorCode::OutOfMemory);
        }
        catch (exception&)
        {
            FAIL("Wrong exception type");
        }
    }

    // CVE-2015-8981 happens because this->GetNextNumber() can return negative numbers 
    // in range (LONG_MIN to LONG_MAX) so the xref section below causes a buffer underflow
    // because m_offsets[-5].bParsed is set to true when first entry is read
    // NOTE: vector operator[] is not bounds checked

    // xref
    // -5 5
    // 0000000000 65535 f 
    // 0000000018 00000 n 
    // 0000000077 00000 n 
    // 0000000178 00000 n 
    // 0000000457 00000 n 
    // trailer
    // <<  /Root 1 0 R
    //    /Size 5
    //>>
    // startxref
    // 565
    // %%EOF

    try
    {
        string strInput = "0000000000 65535 f\r\n";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = -5LL;
        objectCount = 5;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || error.GetCode() == PdfErrorCode::NoXRef));
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2015-8981 can also happen due to integer overflow in firstObject+objectCount
    // in the example below 2147483647=0x7FFF, so 0x7FFF + 0x7FFF = 0XFFFE = -2 on a 32-bit system
    // which means m_offsets.size()=5 because m_offsets.resize() is never called and 
    // m_offsets[2147483647].bParsed is set to true when first entry is read
    // NOTE: vector operator[] is not bounds checked

    // 2147483647 2147483647 
    // 0000000000 65535 f 
    // 0000000018 00000 n 
    // 0000000077 00000 n 
    // 0000000178 00000 n 
    // 0000000457 00000 n 
    // trailer
    // <<  /Root 1 0 R
    //    /Size 5
    //>>
    // startxref
    // 565
    // %%EOF

    try
    {
        string strInput = "0000000000 65535 f\r\n";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<unsigned>::max();
        objectCount = numeric_limits<unsigned>::max();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    try
    {
        string strInput = "0000000000 65535 f\r\n";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<int64_t>::max();
        objectCount = numeric_limits<int64_t>::max();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // test for integer overflows in ReadXRefSubsection (CVE-2017-5853) which caused
    // wrong buffer size to be calculated and then triggered buffer overflow (CVE-2017-6844)   
    // the overflow checks in ReadXRefSubsection depend on the value returned by GetMaxObjectCount
    // if the value changes these checks need looked at again
    REQUIRE(PdfParser::GetMaxObjectCount() <= numeric_limits<unsigned>::max());

    // test CVE-2017-5853 signed integer overflow in firstObject + objectCount
    // CVE-2017-5853 1.1 - firstObject < 0
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = -1LL;
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 1.2 - firstObject = min value of unsigned
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<unsigned>::min();
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::UnexpectedEOF);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 1.3 - firstObject = min value of int64_t
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<int64_t>::min();
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 1.4 - firstObject = min value of size_t is zero (size_t is unsigned)
    // and zero is a valid value for firstObject

    // CVE-2017-5853 1.5 - firstObject = max value of unsigned
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<unsigned>::max();
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 1.6 - firstObject = max value of int64_t
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<int64_t>::max();
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 1.7 - firstObject = max value of size_t
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = numeric_limits<size_t>::max();
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        // weird: different errors returned depending on architecture 
        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || sizeof(size_t) == 4));
        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || sizeof(size_t) == 8));
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 1.8 - firstObject = PdfParser::GetMaxObjectCount()
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        REQUIRE(PdfParser::GetMaxObjectCount() > 0);
        firstObject = PdfParser::GetMaxObjectCount();
        objectCount = 1;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.1 - objectCount < 0
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = -1LL;
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.2 - objectCount = min value of int
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = numeric_limits<int>::min();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.3 - objectCount = min value of int64_t
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = numeric_limits<int64_t>::min();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.4 - objectCount = min value of size_t is zero (size_t is unsigned)
    // and zero is a valid value for firstObject
    // TODO

    // CVE-2017-5853 2.5 - objectCount = max value of unsigned
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = numeric_limits<unsigned>::max();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.6 - objectCount = max value of int64_t
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = numeric_limits<int64_t>::max();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::ValueOutOfRange);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.7 - objectCount = max value of size_t
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = numeric_limits<size_t>::max();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        // weird: different errors returned depending on architecture 
        REQUIRE((error.GetCode() == PdfErrorCode::ValueOutOfRange || sizeof(size_t) == 4));
        REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || sizeof(size_t) == 8));
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.8 - objectCount = PdfParser::GetMaxObjectCount()
    try
    {
        string strInput = " ";
        PdfIndirectObjectList objects;
        PdfParserTest parser(objects, strInput);
        firstObject = 1;
        objectCount = PdfParser::GetMaxObjectCount();
        parser.ReadXRefSubsection(firstObject, objectCount);
        FAIL("PdfError not thrown");
    }
    catch (PdfError& error)
    {
        REQUIRE(error.GetCode() == PdfErrorCode::InvalidXRef);
    }
    catch (exception&)
    {
        FAIL("Wrong exception type");
    }

    // CVE-2017-5853 2.9 - finally - loop through a set of interesting bit patterns
    static uint64_t s_values[] =
    {
        //(1ull << 64) - 1,
        //(1ull << 64),
        //(1ull << 64) + 1,
        (1ull << 63) - 1,
        (1ull << 63),
        (1ull << 63) + 1,
        (1ull << 62) - 1,
        (1ull << 62),
        (1ull << 62) + 1,

        (1ull << 49) - 1,
        (1ull << 49),
        (1ull << 49) + 1,
        (1ull << 48) - 1,
        (1ull << 48),
        (1ull << 48) + 1,
        (1ull << 47) - 1,
        (1ull << 47),
        (1ull << 47) + 1,

        (1ull << 33) - 1,
        (1ull << 33),
        (1ull << 33) + 1,
        (1ull << 32) - 1,
        (1ull << 32),
        (1ull << 32) + 1,
        (1ull << 31) - 1,
        (1ull << 31),
        (1ull << 31) + 1,

        (1ull << 25) - 1,
        (1ull << 33),
        (1ull << 33) + 1,
        (1ull << 24) - 1,
        (1ull << 24),
        (1ull << 24) + 1,
        (1ull << 31) - 1,
        (1ull << 31),
        (1ull << 31) + 1,

        (1ull << 17) - 1,
        (1ull << 17),
        (1ull << 17) + 1,
        (1ull << 16) - 1,
        (1ull << 16),
        (1ull << 16) + 1,
        (1ull << 15) - 1,
        (1ull << 15),
        (1ull << 15) + 1,

        (uint64_t)-1,
        0,
        1
    };
    constexpr size_t numValues = sizeof(s_values) / sizeof(s_values[0]);

    for (size_t i = 0; i < numValues; i++)
    {
        for (size_t j = 0; j < numValues; j++)
        {
            try
            {
                string strInput = " ";
                PdfIndirectObjectList objects;
                PdfParserTest parser(objects, strInput);
                firstObject = s_values[i];
                objectCount = s_values[j];

                if (canOutOfMemoryKillUnitTests() && (firstObject > maxNumberOfIndirectObjects || objectCount > maxNumberOfIndirectObjects))
                {
                    // can't call this in test environments where an out-of-memory condition terminates
                    // unit test process before all tests have run (e.g. AddressSanitizer)
                }
                else
                {
                    parser.ReadXRefSubsection(firstObject, objectCount);
                    // some combinations of firstObject/objectCount from s_values are legal - so we expect to reach here sometimes
                }
            }
            catch (PdfError& error)
            {
                // other combinations of firstObject/objectCount from s_values are illegal 
                // if we reach here it should be an invalid xref value of some type
                REQUIRE((error.GetCode() == PdfErrorCode::InvalidXRef || error.GetCode() == PdfErrorCode::ValueOutOfRange
                    || error.GetCode() == PdfErrorCode::UnexpectedEOF
                    || error.GetCode() == PdfErrorCode::OutOfMemory));
            }
            catch (exception&)
            {
                // and should never reach here
                FAIL("Wrong exception type");
            }
        }
    }
}
