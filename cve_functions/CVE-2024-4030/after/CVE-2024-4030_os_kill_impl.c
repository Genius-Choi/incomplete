os_kill_impl(PyObject *module, pid_t pid, Py_ssize_t signal)
/*[clinic end generated code: output=8e346a6701c88568 input=61a36b86ca275ab9]*/
{
    if (PySys_Audit("os.kill", "in", pid, signal) < 0) {
        return NULL;
    }
#ifndef MS_WINDOWS
    if (kill(pid, (int)signal) == -1) {
        return posix_error();
    }

    // Check immediately if the signal was sent to the current process.
    // Don't micro-optimize pid == getpid(), since PyErr_SetString() check
    // is cheap.
    if (PyErr_CheckSignals()) {
        return NULL;
    }

    Py_RETURN_NONE;
#else /* !MS_WINDOWS */
    PyObject *result;
    DWORD sig = (DWORD)signal;
    DWORD err;
    HANDLE handle;

#ifdef HAVE_WINDOWS_CONSOLE_IO
    /* Console processes which share a common console can be sent CTRL+C or
       CTRL+BREAK events, provided they handle said events. */
    if (sig == CTRL_C_EVENT || sig == CTRL_BREAK_EVENT) {
        if (GenerateConsoleCtrlEvent(sig, (DWORD)pid) == 0) {
            err = GetLastError();
            PyErr_SetFromWindowsErr(err);
        }
        else {
            Py_RETURN_NONE;
        }
    }
#endif /* HAVE_WINDOWS_CONSOLE_IO */

    /* If the signal is outside of what GenerateConsoleCtrlEvent can use,
       attempt to open and terminate the process. */
    handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);
    if (handle == NULL) {
        err = GetLastError();
        return PyErr_SetFromWindowsErr(err);
    }

    if (TerminateProcess(handle, sig) == 0) {
        err = GetLastError();
        result = PyErr_SetFromWindowsErr(err);
    } else {
        result = Py_NewRef(Py_None);
    }

    CloseHandle(handle);
    return result;
#endif /* !MS_WINDOWS */
}
