os_chmod_impl(PyObject *module, path_t *path, int mode, int dir_fd,
              int follow_symlinks)
/*[clinic end generated code: output=5cf6a94915cc7bff input=674a14bc998de09d]*/
{
    int result;

#ifdef MS_WINDOWS
    DWORD attr;
#endif

#ifdef HAVE_FCHMODAT
    int fchmodat_nofollow_unsupported = 0;
    int fchmodat_unsupported = 0;
#endif

#if !(defined(HAVE_FCHMODAT) || defined(HAVE_LCHMOD))
    if (follow_symlinks_specified("chmod", follow_symlinks))
        return NULL;
#endif

    if (PySys_Audit("os.chmod", "Oii", path->object, mode,
                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {
        return NULL;
    }

#ifdef MS_WINDOWS
    Py_BEGIN_ALLOW_THREADS
    attr = GetFileAttributesW(path->wide);
    if (attr == INVALID_FILE_ATTRIBUTES)
        result = 0;
    else {
        if (mode & _S_IWRITE)
            attr &= ~FILE_ATTRIBUTE_READONLY;
        else
            attr |= FILE_ATTRIBUTE_READONLY;
        result = SetFileAttributesW(path->wide, attr);
    }
    Py_END_ALLOW_THREADS

    if (!result) {
        return path_error(path);
    }
#else /* MS_WINDOWS */
    Py_BEGIN_ALLOW_THREADS
#ifdef HAVE_FCHMOD
    if (path->fd != -1)
        result = fchmod(path->fd, mode);
    else
#endif /* HAVE_CHMOD */
#ifdef HAVE_LCHMOD
    if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))
        result = lchmod(path->narrow, mode);
    else
#endif /* HAVE_LCHMOD */
#ifdef HAVE_FCHMODAT
    if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks) {
        if (HAVE_FCHMODAT_RUNTIME) {
            /*
             * fchmodat() doesn't currently support AT_SYMLINK_NOFOLLOW!
             * The documentation specifically shows how to use it,
             * and then says it isn't implemented yet.
             * (true on linux with glibc 2.15, and openindiana 3.x)
             *
             * Once it is supported, os.chmod will automatically
             * support dir_fd and follow_symlinks=False.  (Hopefully.)
             * Until then, we need to be careful what exception we raise.
             */
            result = fchmodat(dir_fd, path->narrow, mode,
                              follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);
            /*
             * But wait!  We can't throw the exception without allowing threads,
             * and we can't do that in this nested scope.  (Macro trickery, sigh.)
             */
            fchmodat_nofollow_unsupported =
                             result &&
                             ((errno == ENOTSUP) || (errno == EOPNOTSUPP)) &&
                             !follow_symlinks;
        } else {
            fchmodat_unsupported = 1;
            fchmodat_nofollow_unsupported = 1;

            result = -1;
        }
    }
    else
#endif /* HAVE_FHCMODAT */
    {
#ifdef HAVE_CHMOD
        result = chmod(path->narrow, mode);
#elif defined(__wasi__)
        // WASI SDK 15.0 does not support chmod.
        // Ignore missing syscall for now.
        result = 0;
#else
        result = -1;
        errno = ENOSYS;
#endif
    }
    Py_END_ALLOW_THREADS

    if (result) {
#ifdef HAVE_FCHMODAT
        if (fchmodat_unsupported) {
            if (dir_fd != DEFAULT_DIR_FD) {
                argument_unavailable_error("chmod", "dir_fd");
                return NULL;
            }
        }

        if (fchmodat_nofollow_unsupported) {
            if (dir_fd != DEFAULT_DIR_FD)
                dir_fd_and_follow_symlinks_invalid("chmod",
                                                   dir_fd, follow_symlinks);
            else
                follow_symlinks_specified("chmod", follow_symlinks);
            return NULL;
        }
        else
#endif /* HAVE_FCHMODAT */
        return path_error(path);
    }
#endif /* MS_WINDOWS */

    Py_RETURN_NONE;
}
