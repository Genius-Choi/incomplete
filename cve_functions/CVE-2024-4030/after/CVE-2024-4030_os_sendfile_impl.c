os_sendfile_impl(PyObject *module, int out_fd, int in_fd, Py_off_t offset,
                 Py_off_t sbytes, PyObject *headers, PyObject *trailers,
                 int flags)
/*[clinic end generated code: output=81c4bcd143f5c82b input=b0d72579d4c69afa]*/
#elif defined(__FreeBSD__) || defined(__DragonFly__)
/*[clinic input]
os.sendfile

    out_fd: int
    in_fd: int
    offset: Py_off_t
    count: Py_ssize_t
    headers: object(c_default="NULL") = ()
    trailers: object(c_default="NULL") = ()
    flags: int = 0

Copy count bytes from file descriptor in_fd to file descriptor out_fd.
[clinic start generated code]*/

static PyObject *
os_sendfile_impl(PyObject *module, int out_fd, int in_fd, Py_off_t offset,
                 Py_ssize_t count, PyObject *headers, PyObject *trailers,
                 int flags)
/*[clinic end generated code: output=329ea009bdd55afc input=338adb8ff84ae8cd]*/
#else
/*[clinic input]
os.sendfile

    out_fd: int
    in_fd: int
    offset as offobj: object
    count: Py_ssize_t

Copy count bytes from file descriptor in_fd to file descriptor out_fd.
[clinic start generated code]*/

static PyObject *
os_sendfile_impl(PyObject *module, int out_fd, int in_fd, PyObject *offobj,
                 Py_ssize_t count)
/*[clinic end generated code: output=ae81216e40f167d8 input=76d64058c74477ba]*/
#endif
{
    Py_ssize_t ret;
    int async_err = 0;

#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__APPLE__)
#ifndef __APPLE__
    off_t sbytes;
#endif
    Py_buffer *hbuf, *tbuf;
    struct sf_hdtr sf;

    sf.headers = NULL;
    sf.trailers = NULL;

    if (headers != NULL) {
        if (!PySequence_Check(headers)) {
            PyErr_SetString(PyExc_TypeError,
                "sendfile() headers must be a sequence");
            return NULL;
        } else {
            Py_ssize_t i = PySequence_Size(headers);
            if (i < 0)
                return NULL;
            if (i > INT_MAX) {
                PyErr_SetString(PyExc_OverflowError,
                    "sendfile() header is too large");
                return NULL;
            }
            if (i > 0) {
                sf.hdr_cnt = (int)i;
                if (iov_setup(&(sf.headers), &hbuf,
                              headers, sf.hdr_cnt, PyBUF_SIMPLE) < 0)
                    return NULL;
#ifdef __APPLE__
                for (i = 0; i < sf.hdr_cnt; i++) {
                    Py_ssize_t blen = sf.headers[i].iov_len;
# define OFF_T_MAX 0x7fffffffffffffff
                    if (sbytes >= OFF_T_MAX - blen) {
                        PyErr_SetString(PyExc_OverflowError,
                            "sendfile() header is too large");
                        return NULL;
                    }
                    sbytes += blen;
                }
#endif
            }
        }
    }
    if (trailers != NULL) {
        if (!PySequence_Check(trailers)) {
            PyErr_SetString(PyExc_TypeError,
                "sendfile() trailers must be a sequence");
            return NULL;
        } else {
            Py_ssize_t i = PySequence_Size(trailers);
            if (i < 0)
                return NULL;
            if (i > INT_MAX) {
                PyErr_SetString(PyExc_OverflowError,
                    "sendfile() trailer is too large");
                return NULL;
            }
            if (i > 0) {
                sf.trl_cnt = (int)i;
                if (iov_setup(&(sf.trailers), &tbuf,
                              trailers, sf.trl_cnt, PyBUF_SIMPLE) < 0)
                    return NULL;
            }
        }
    }

    _Py_BEGIN_SUPPRESS_IPH
    do {
        Py_BEGIN_ALLOW_THREADS
#ifdef __APPLE__
        ret = sendfile(in_fd, out_fd, offset, &sbytes, &sf, flags);
#else
        ret = sendfile(in_fd, out_fd, offset, count, &sf, &sbytes, flags);
#endif
        Py_END_ALLOW_THREADS
    } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
    _Py_END_SUPPRESS_IPH

    int saved_errno = errno;
    if (sf.headers != NULL)
        iov_cleanup(sf.headers, hbuf, sf.hdr_cnt);
    if (sf.trailers != NULL)
        iov_cleanup(sf.trailers, tbuf, sf.trl_cnt);

    if (ret < 0) {
        if ((saved_errno == EAGAIN) || (saved_errno == EBUSY)) {
            if (sbytes != 0) {
                // some data has been sent
                goto done;
            }
            // no data has been sent; upper application is supposed
            // to retry on EAGAIN or EBUSY
        }
        if (!async_err) {
            errno = saved_errno;
            posix_error();
        }
        return NULL;
    }
    goto done;

done:
    #if !defined(HAVE_LARGEFILE_SUPPORT)
        return Py_BuildValue("l", sbytes);
    #else
        return Py_BuildValue("L", sbytes);
    #endif

#else
#ifdef __linux__
    if (offobj == Py_None) {
        do {
            Py_BEGIN_ALLOW_THREADS
            ret = sendfile(out_fd, in_fd, NULL, count);
            Py_END_ALLOW_THREADS
        } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
        if (ret < 0)
            return (!async_err) ? posix_error() : NULL;
        return Py_BuildValue("n", ret);
    }
#endif
    off_t offset;
    if (!Py_off_t_converter(offobj, &offset))
        return NULL;

#if defined(__sun) && defined(__SVR4)
    // On Solaris, sendfile raises EINVAL rather than returning 0
    // when the offset is equal or bigger than the in_fd size.
    struct stat st;

    do {
        Py_BEGIN_ALLOW_THREADS
        ret = fstat(in_fd, &st);
        Py_END_ALLOW_THREADS
    } while (ret != 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
    if (ret < 0)
        return (!async_err) ? posix_error() : NULL;

    if (offset >= st.st_size) {
        return Py_BuildValue("i", 0);
    }

    // On illumos specifically sendfile() may perform a partial write but
    // return -1/an error (in one confirmed case the destination socket
    // had a 5 second timeout set and errno was EAGAIN) and it's on the client
    // code to check if the offset parameter was modified by sendfile().
    //
    // We need this variable to track said change.
    off_t original_offset = offset;
#endif

    do {
        Py_BEGIN_ALLOW_THREADS
        ret = sendfile(out_fd, in_fd, &offset, count);
#if defined(__sun) && defined(__SVR4)
        // This handles illumos-specific sendfile() partial write behavior,
        // see a comment above for more details.
        if (ret < 0 && offset != original_offset) {
            ret = offset - original_offset;
        }
#endif
        Py_END_ALLOW_THREADS
    } while (ret < 0 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
    if (ret < 0)
        return (!async_err) ? posix_error() : NULL;
    return Py_BuildValue("n", ret);
#endif
}
