int mesh_add_sub(struct module_qstate* qstate, struct query_info* qinfo,
        uint16_t qflags, int prime, int valrec, struct module_qstate** newq,
	struct mesh_state** sub)
{
	/* find it, if not, create it */
	struct mesh_area* mesh = qstate->env->mesh;
	*sub = mesh_area_find(mesh, NULL, qinfo, qflags,
		prime, valrec);
	if(mesh_detect_cycle_found(qstate, *sub)) {
		verbose(VERB_ALGO, "attach failed, cycle detected");
		return 0;
	}
	if(!*sub) {
#ifdef UNBOUND_DEBUG
		struct rbnode_type* n;
#endif
		/* create a new one */
		*sub = mesh_state_create(qstate->env, qinfo, NULL, qflags, prime,
			valrec);
		if(!*sub) {
			log_err("mesh_attach_sub: out of memory");
			return 0;
		}
#ifdef UNBOUND_DEBUG
		n =
#else
		(void)
#endif
		rbtree_insert(&mesh->all, &(*sub)->node);
		log_assert(n != NULL);
		/* set detached (it is now) */
		mesh->num_detached_states++;
		/* set new query state to run */
#ifdef UNBOUND_DEBUG
		n =
#else
		(void)
#endif
		rbtree_insert(&mesh->run, &(*sub)->run_node);
		log_assert(n != NULL);
		*newq = &(*sub)->s;
	} else
		*newq = NULL;
	return 1;
}
