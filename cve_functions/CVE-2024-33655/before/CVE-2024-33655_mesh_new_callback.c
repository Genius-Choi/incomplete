mesh_new_callback(struct mesh_area* mesh, struct query_info* qinfo,
	uint16_t qflags, struct edns_data* edns, sldns_buffer* buf,
	uint16_t qid, mesh_cb_func_type cb, void* cb_arg, int rpz_passthru)
{
	struct mesh_state* s = NULL;
	int unique = unique_mesh_state(edns->opt_list_in, mesh->env);
	int timeout = mesh->env->cfg->serve_expired?
		mesh->env->cfg->serve_expired_client_timeout:0;
	int was_detached = 0;
	int was_noreply = 0;
	int added = 0;
	if(!unique)
		s = mesh_area_find(mesh, NULL, qinfo, qflags&(BIT_RD|BIT_CD), 0, 0);

	/* there are no limits on the number of callbacks */

	/* see if it already exists, if not, create one */
	if(!s) {
#ifdef UNBOUND_DEBUG
		struct rbnode_type* n;
#endif
		s = mesh_state_create(mesh->env, qinfo, NULL,
			qflags&(BIT_RD|BIT_CD), 0, 0);
		if(!s) {
			return 0;
		}
		/* set detached (it is now) */
		mesh->num_detached_states++;
		if(unique)
			mesh_state_make_unique(s);
		s->s.rpz_passthru = rpz_passthru;
		if(edns->opt_list_in) {
			s->s.edns_opts_front_in = edns_opt_copy_region(edns->opt_list_in,
				s->s.region);
			if(!s->s.edns_opts_front_in) {
				mesh_state_delete(&s->s);
				return 0;
			}
		}
#ifdef UNBOUND_DEBUG
		n =
#else
		(void)
#endif
		rbtree_insert(&mesh->all, &s->node);
		log_assert(n != NULL);
		added = 1;
	}
	if(!s->reply_list && !s->cb_list) {
		was_noreply = 1;
		if(s->super_set.count == 0) {
			was_detached = 1;
		}
	}
	/* add reply to s */
	if(!mesh_state_add_cb(s, edns, buf, cb, cb_arg, qid, qflags)) {
		if(added)
			mesh_state_delete(&s->s);
		return 0;
	}
	/* add serve expired timer if not already there */
	if(timeout && !mesh_serve_expired_init(s, timeout)) {
		if(added)
			mesh_state_delete(&s->s);
		return 0;
	}
#ifdef USE_CACHEDB
	if(!timeout && mesh->env->cfg->serve_expired &&
		!mesh->env->cfg->serve_expired_client_timeout &&
		(mesh->env->cachedb_enabled &&
		 mesh->env->cfg->cachedb_check_when_serve_expired)) {
		if(!mesh_serve_expired_init(s, -1)) {
			if(added)
				mesh_state_delete(&s->s);
			return 0;
		}
	}
#endif
	/* update statistics */
	if(was_detached) {
		log_assert(mesh->num_detached_states > 0);
		mesh->num_detached_states--;
	}
	if(was_noreply) {
		mesh->num_reply_states ++;
	}
	mesh->num_reply_addrs++;
	if(added)
		mesh_run(mesh, s, module_event_new, NULL);
	return 1;
}
