static bool transactRtspMessageTcp(PRTSP_MESSAGE request, PRTSP_MESSAGE response, int* error) {
    SOCK_RET err;
    bool ret;
    int offset;
    char* serializedMessage = NULL;
    int messageLen;
    char* responseBuffer;
    int responseBufferSize;
    int connectRetries;

    *error = -1;
    ret = false;
    responseBuffer = NULL;
    connectRetries = 0;

    // Retry up to 10 seconds if we receive ECONNREFUSED errors from the host PC.
    // This can happen with GFE 3.22 when initially launching a session because it
    // returns HTTP 200 OK for the /launch request before the RTSP handshake port
    // is listening.
    do {
        sock = connectTcpSocket(&RemoteAddr, RemoteAddrLen, RtspPortNumber, RTSP_CONNECT_TIMEOUT_SEC);
        if (sock == INVALID_SOCKET) {
            *error = LastSocketError();
            if (*error == ECONNREFUSED) {
                // Try again after 500 ms on ECONNREFUSED
                PltSleepMs(RTSP_RETRY_DELAY_MS);
            }
            else {
                // Fail if we get some other error
                break;
            }
        }
        else {
            // We successfully connected
            break;
        }
    } while (connectRetries++ < (RTSP_CONNECT_TIMEOUT_SEC * 1000) / RTSP_RETRY_DELAY_MS && !ConnectionInterrupted);
    if (sock == INVALID_SOCKET) {
        return ret;
    }

    serializedMessage = serializeRtspMessage(request, &messageLen);
    if (serializedMessage == NULL) {
        closeSocket(sock);
        sock = INVALID_SOCKET;
        return ret;
    }

    // Send our message split into smaller chunks to avoid MTU issues.
    // enableNoDelay() must have been called for sendMtuSafe() to work.
    enableNoDelay(sock);
    err = sendMtuSafe(sock, serializedMessage, messageLen);
    if (err == SOCKET_ERROR) {
        *error = LastSocketError();
        Limelog("Failed to send RTSP message: %d\n", *error);
        goto Exit;
    }

    // Read the response until the server closes the connection
    offset = 0;
    responseBufferSize = 0;
    for (;;) {
        struct pollfd pfd;

        if (offset >= responseBufferSize) {
            responseBufferSize = offset + 16384;
            responseBuffer = extendBuffer(responseBuffer, responseBufferSize);
            if (responseBuffer == NULL) {
                Limelog("Failed to allocate RTSP response buffer\n");
                goto Exit;
            }
        }

        pfd.fd = sock;
        pfd.events = POLLIN;
        err = pollSockets(&pfd, 1, RTSP_RECEIVE_TIMEOUT_SEC * 1000);
        if (err == 0) {
            *error = ETIMEDOUT;
            Limelog("RTSP request timed out\n");
            goto Exit;
        }
        else if (err < 0) {
            *error = LastSocketError();
            Limelog("Failed to wait for RTSP response: %d\n", *error);
            goto Exit;
        }

        err = recv(sock, &responseBuffer[offset], responseBufferSize - offset, 0);
        if (err < 0) {
            // Error reading
            *error = LastSocketError();
            Limelog("Failed to read RTSP response: %d\n", *error);
            goto Exit;
        }
        else if (err == 0) {
            // Done reading
            break;
        }
        else {
            offset += err;
        }
    }

    if (parseRtspMessage(response, responseBuffer, offset) == RTSP_ERROR_SUCCESS) {
        // Successfully parsed response
        ret = true;
    }
    else {
        Limelog("Failed to parse RTSP response\n");
    }

Exit:
    if (serializedMessage != NULL) {
        free(serializedMessage);
    }

    if (responseBuffer != NULL) {
        free(responseBuffer);
    }

    closeSocket(sock);
    sock = INVALID_SOCKET;
    return ret;
}
