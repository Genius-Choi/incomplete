static void httpd_poll(void) {
    fd_set recv_set, send_set;
    int max_fd, select_ret;
    struct connection *conn, *next;
    int bother_with_timeout = 0;
    struct timeval timeout, t0, t1;

    timeout.tv_sec = timeout_secs;
    timeout.tv_usec = 0;

    FD_ZERO(&recv_set);
    FD_ZERO(&send_set);
    max_fd = 0;

    /* set recv/send fd_sets */
#define MAX_FD_SET(sock, fdset) do { FD_SET(sock,fdset); \
                                max_fd = (max_fd<sock) ? sock : max_fd; } \
                                while (0)
    if (accepting) MAX_FD_SET(sockin, &recv_set);

    LIST_FOREACH_SAFE(conn, &connlist, entries, next) {
        switch (conn->state) {
        case DONE:
            /* do nothing, no connection should be left in this state */
            break;

        case RECV_REQUEST:
            MAX_FD_SET(conn->socket, &recv_set);
            bother_with_timeout = 1;
            break;

        case SEND_HEADER:
        case SEND_REPLY:
            MAX_FD_SET(conn->socket, &send_set);
            bother_with_timeout = 1;
            break;
        }
    }
#undef MAX_FD_SET

#if defined(__has_feature)
# if __has_feature(memory_sanitizer)
    __msan_unpoison(&recv_set, sizeof(recv_set));
    __msan_unpoison(&send_set, sizeof(send_set));
# endif
#endif

    /* -select- */
    if (timeout_secs == 0) {
        bother_with_timeout = 0;
    }
    if (debug) {
        printf("select() with max_fd %d timeout %d\n",
                max_fd, bother_with_timeout ? (int)timeout.tv_sec : 0);
        gettimeofday(&t0, NULL);
    }
    select_ret = select(max_fd + 1, &recv_set, &send_set, NULL,
        (bother_with_timeout) ? &timeout : NULL);
    if (select_ret == 0) {
        if (!bother_with_timeout)
            errx(1, "select() timed out");
    }
    if (select_ret == -1) {
        if (errno == EINTR)
            return; /* interrupted by signal */
        else
            err(1, "select() failed");
    }
    if (debug) {
        long long sec, usec;
        gettimeofday(&t1, NULL);
        sec = t1.tv_sec - t0.tv_sec;
        usec = t1.tv_usec - t0.tv_usec;
        if (usec < 0) {
            usec += 1000000;
            sec--;
        }
        printf("select() returned %d after %lld.%06lld secs\n",
                select_ret, sec, usec);
    }

    /* update time */
    now = time(NULL);

    /* poll connections that select() says need attention */
    if (FD_ISSET(sockin, &recv_set))
        accept_connection();

    LIST_FOREACH_SAFE(conn, &connlist, entries, next) {
        poll_check_timeout(conn);
        switch (conn->state) {
        case RECV_REQUEST:
            if (FD_ISSET(conn->socket, &recv_set)) poll_recv_request(conn);
            break;

        case SEND_HEADER:
            if (FD_ISSET(conn->socket, &send_set)) poll_send_header(conn);
            break;

        case SEND_REPLY:
            if (FD_ISSET(conn->socket, &send_set)) poll_send_reply(conn);
            break;

        case DONE:
            /* (handled later; ignore for now as it's a valid state) */
            break;
        }

        /* Handling SEND_REPLY could have set the state to done. */
        if (conn->state == DONE) {
            /* clean out finished connection */
            if (conn->conn_close) {
                LIST_REMOVE(conn, entries);
                free_connection(conn);
                free(conn);
            } else {
                recycle_connection(conn);
            }
        }
    }
}
