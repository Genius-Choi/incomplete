static int parse_apply_sb_mount_options(struct super_block *sb,
					struct ext4_fs_context *m_ctx)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	char *s_mount_opts = NULL;
	struct ext4_fs_context *s_ctx = NULL;
	struct fs_context *fc = NULL;
	int ret = -ENOMEM;

	if (!sbi->s_es->s_mount_opts[0])
		return 0;

	s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,
				sizeof(sbi->s_es->s_mount_opts),
				GFP_KERNEL);
	if (!s_mount_opts)
		return ret;

	fc = kzalloc(sizeof(struct fs_context), GFP_KERNEL);
	if (!fc)
		goto out_free;

	s_ctx = kzalloc(sizeof(struct ext4_fs_context), GFP_KERNEL);
	if (!s_ctx)
		goto out_free;

	fc->fs_private = s_ctx;
	fc->s_fs_info = sbi;

	ret = parse_options(fc, s_mount_opts);
	if (ret < 0)
		goto parse_failed;

	ret = ext4_check_opt_consistency(fc, sb);
	if (ret < 0) {
parse_failed:
		ext4_msg(sb, KERN_WARNING,
			 "failed to parse options in superblock: %s",
			 s_mount_opts);
		ret = 0;
		goto out_free;
	}

	if (s_ctx->spec & EXT4_SPEC_JOURNAL_DEV)
		m_ctx->journal_devnum = s_ctx->journal_devnum;
	if (s_ctx->spec & EXT4_SPEC_JOURNAL_IOPRIO)
		m_ctx->journal_ioprio = s_ctx->journal_ioprio;

	ext4_apply_options(fc, sb);
	ret = 0;

out_free:
	if (fc) {
		ext4_fc_free(fc);
		kfree(fc);
	}
	kfree(s_mount_opts);
	return ret;
}
