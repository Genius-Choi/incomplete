static int ext4_check_quota_consistency(struct fs_context *fc,
					struct super_block *sb)
{
#ifdef CONFIG_QUOTA
	struct ext4_fs_context *ctx = fc->fs_private;
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	bool quota_feature = ext4_has_feature_quota(sb);
	bool quota_loaded = sb_any_quota_loaded(sb);
	bool usr_qf_name, grp_qf_name, usrquota, grpquota;
	int quota_flags, i;

	/*
	 * We do the test below only for project quotas. 'usrquota' and
	 * 'grpquota' mount options are allowed even without quota feature
	 * to support legacy quotas in quota files.
	 */
	if (ctx_test_mount_opt(ctx, EXT4_MOUNT_PRJQUOTA) &&
	    !ext4_has_feature_project(sb)) {
		ext4_msg(NULL, KERN_ERR, "Project quota feature not enabled. "
			 "Cannot enable project quota enforcement.");
		return -EINVAL;
	}

	quota_flags = EXT4_MOUNT_QUOTA | EXT4_MOUNT_USRQUOTA |
		      EXT4_MOUNT_GRPQUOTA | EXT4_MOUNT_PRJQUOTA;
	if (quota_loaded &&
	    ctx->mask_s_mount_opt & quota_flags &&
	    !ctx_test_mount_opt(ctx, quota_flags))
		goto err_quota_change;

	if (ctx->spec & EXT4_SPEC_JQUOTA) {

		for (i = 0; i < EXT4_MAXQUOTAS; i++) {
			if (!(ctx->qname_spec & (1 << i)))
				continue;

			if (quota_loaded &&
			    !!sbi->s_qf_names[i] != !!ctx->s_qf_names[i])
				goto err_jquota_change;

			if (sbi->s_qf_names[i] && ctx->s_qf_names[i] &&
			    strcmp(get_qf_name(sb, sbi, i),
				   ctx->s_qf_names[i]) != 0)
				goto err_jquota_specified;
		}

		if (quota_feature) {
			ext4_msg(NULL, KERN_INFO,
				 "Journaled quota options ignored when "
				 "QUOTA feature is enabled");
			return 0;
		}
	}

	if (ctx->spec & EXT4_SPEC_JQFMT) {
		if (sbi->s_jquota_fmt != ctx->s_jquota_fmt && quota_loaded)
			goto err_jquota_change;
		if (quota_feature) {
			ext4_msg(NULL, KERN_INFO, "Quota format mount options "
				 "ignored when QUOTA feature is enabled");
			return 0;
		}
	}

	/* Make sure we don't mix old and new quota format */
	usr_qf_name = (get_qf_name(sb, sbi, USRQUOTA) ||
		       ctx->s_qf_names[USRQUOTA]);
	grp_qf_name = (get_qf_name(sb, sbi, GRPQUOTA) ||
		       ctx->s_qf_names[GRPQUOTA]);

	usrquota = (ctx_test_mount_opt(ctx, EXT4_MOUNT_USRQUOTA) ||
		    test_opt(sb, USRQUOTA));

	grpquota = (ctx_test_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA) ||
		    test_opt(sb, GRPQUOTA));

	if (usr_qf_name) {
		ctx_clear_mount_opt(ctx, EXT4_MOUNT_USRQUOTA);
		usrquota = false;
	}
	if (grp_qf_name) {
		ctx_clear_mount_opt(ctx, EXT4_MOUNT_GRPQUOTA);
		grpquota = false;
	}

	if (usr_qf_name || grp_qf_name) {
		if (usrquota || grpquota) {
			ext4_msg(NULL, KERN_ERR, "old and new quota "
				 "format mixing");
			return -EINVAL;
		}

		if (!(ctx->spec & EXT4_SPEC_JQFMT || sbi->s_jquota_fmt)) {
			ext4_msg(NULL, KERN_ERR, "journaled quota format "
				 "not specified");
			return -EINVAL;
		}
	}

	return 0;

err_quota_change:
	ext4_msg(NULL, KERN_ERR,
		 "Cannot change quota options when quota turned on");
	return -EINVAL;
err_jquota_change:
	ext4_msg(NULL, KERN_ERR, "Cannot change journaled quota "
		 "options when quota turned on");
	return -EINVAL;
err_jquota_specified:
	ext4_msg(NULL, KERN_ERR, "%s quota file already specified",
		 QTYPE2NAME(i));
	return -EINVAL;
#else
	return 0;
#endif
}
