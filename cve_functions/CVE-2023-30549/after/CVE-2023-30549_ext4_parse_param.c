static int ext4_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
	struct ext4_fs_context *ctx = fc->fs_private;
	struct fs_parse_result result;
	const struct mount_opts *m;
	int is_remount;
	kuid_t uid;
	kgid_t gid;
	int token;

	token = fs_parse(fc, ext4_param_specs, param, &result);
	if (token < 0)
		return token;
	is_remount = fc->purpose == FS_CONTEXT_FOR_RECONFIGURE;

	for (m = ext4_mount_opts; m->token != Opt_err; m++)
		if (token == m->token)
			break;

	ctx->opt_flags |= m->flags;

	if (m->flags & MOPT_EXPLICIT) {
		if (m->mount_opt & EXT4_MOUNT_DELALLOC) {
			ctx_set_mount_opt2(ctx, EXT4_MOUNT2_EXPLICIT_DELALLOC);
		} else if (m->mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) {
			ctx_set_mount_opt2(ctx,
				       EXT4_MOUNT2_EXPLICIT_JOURNAL_CHECKSUM);
		} else
			return -EINVAL;
	}

	if (m->flags & MOPT_NOSUPPORT) {
		ext4_msg(NULL, KERN_ERR, "%s option not supported",
			 param->key);
		return 0;
	}

	switch (token) {
#ifdef CONFIG_QUOTA
	case Opt_usrjquota:
		if (!*param->string)
			return unnote_qf_name(fc, USRQUOTA);
		else
			return note_qf_name(fc, USRQUOTA, param);
	case Opt_grpjquota:
		if (!*param->string)
			return unnote_qf_name(fc, GRPQUOTA);
		else
			return note_qf_name(fc, GRPQUOTA, param);
#endif
	case Opt_sb:
		if (fc->purpose == FS_CONTEXT_FOR_RECONFIGURE) {
			ext4_msg(NULL, KERN_WARNING,
				 "Ignoring %s option on remount", param->key);
		} else {
			ctx->s_sb_block = result.uint_32;
			ctx->spec |= EXT4_SPEC_s_sb_block;
		}
		return 0;
	case Opt_removed:
		ext4_msg(NULL, KERN_WARNING, "Ignoring removed %s option",
			 param->key);
		return 0;
	case Opt_abort:
		ctx_set_mount_flag(ctx, EXT4_MF_FS_ABORTED);
		return 0;
	case Opt_inlinecrypt:
#ifdef CONFIG_FS_ENCRYPTION_INLINE_CRYPT
		ctx_set_flags(ctx, SB_INLINECRYPT);
#else
		ext4_msg(NULL, KERN_ERR, "inline encryption not supported");
#endif
		return 0;
	case Opt_errors:
		ctx_clear_mount_opt(ctx, EXT4_MOUNT_ERRORS_MASK);
		ctx_set_mount_opt(ctx, result.uint_32);
		return 0;
#ifdef CONFIG_QUOTA
	case Opt_jqfmt:
		ctx->s_jquota_fmt = result.uint_32;
		ctx->spec |= EXT4_SPEC_JQFMT;
		return 0;
#endif
	case Opt_data:
		ctx_clear_mount_opt(ctx, EXT4_MOUNT_DATA_FLAGS);
		ctx_set_mount_opt(ctx, result.uint_32);
		ctx->spec |= EXT4_SPEC_DATAJ;
		return 0;
	case Opt_commit:
		if (result.uint_32 == 0)
			result.uint_32 = JBD2_DEFAULT_MAX_COMMIT_AGE;
		else if (result.uint_32 > INT_MAX / HZ) {
			ext4_msg(NULL, KERN_ERR,
				 "Invalid commit interval %d, "
				 "must be smaller than %d",
				 result.uint_32, INT_MAX / HZ);
			return -EINVAL;
		}
		ctx->s_commit_interval = HZ * result.uint_32;
		ctx->spec |= EXT4_SPEC_s_commit_interval;
		return 0;
	case Opt_debug_want_extra_isize:
		if ((result.uint_32 & 1) || (result.uint_32 < 4)) {
			ext4_msg(NULL, KERN_ERR,
				 "Invalid want_extra_isize %d", result.uint_32);
			return -EINVAL;
		}
		ctx->s_want_extra_isize = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_want_extra_isize;
		return 0;
	case Opt_max_batch_time:
		ctx->s_max_batch_time = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_max_batch_time;
		return 0;
	case Opt_min_batch_time:
		ctx->s_min_batch_time = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_min_batch_time;
		return 0;
	case Opt_inode_readahead_blks:
		if (result.uint_32 &&
		    (result.uint_32 > (1 << 30) ||
		     !is_power_of_2(result.uint_32))) {
			ext4_msg(NULL, KERN_ERR,
				 "EXT4-fs: inode_readahead_blks must be "
				 "0 or a power of 2 smaller than 2^31");
			return -EINVAL;
		}
		ctx->s_inode_readahead_blks = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_inode_readahead_blks;
		return 0;
	case Opt_init_itable:
		ctx_set_mount_opt(ctx, EXT4_MOUNT_INIT_INODE_TABLE);
		ctx->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;
		if (param->type == fs_value_is_string)
			ctx->s_li_wait_mult = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_li_wait_mult;
		return 0;
	case Opt_max_dir_size_kb:
		ctx->s_max_dir_size_kb = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_max_dir_size_kb;
		return 0;
#ifdef CONFIG_EXT4_DEBUG
	case Opt_fc_debug_max_replay:
		ctx->s_fc_debug_max_replay = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_fc_debug_max_replay;
		return 0;
#endif
	case Opt_stripe:
		ctx->s_stripe = result.uint_32;
		ctx->spec |= EXT4_SPEC_s_stripe;
		return 0;
	case Opt_resuid:
		uid = make_kuid(current_user_ns(), result.uint_32);
		if (!uid_valid(uid)) {
			ext4_msg(NULL, KERN_ERR, "Invalid uid value %d",
				 result.uint_32);
			return -EINVAL;
		}
		ctx->s_resuid = uid;
		ctx->spec |= EXT4_SPEC_s_resuid;
		return 0;
	case Opt_resgid:
		gid = make_kgid(current_user_ns(), result.uint_32);
		if (!gid_valid(gid)) {
			ext4_msg(NULL, KERN_ERR, "Invalid gid value %d",
				 result.uint_32);
			return -EINVAL;
		}
		ctx->s_resgid = gid;
		ctx->spec |= EXT4_SPEC_s_resgid;
		return 0;
	case Opt_journal_dev:
		if (is_remount) {
			ext4_msg(NULL, KERN_ERR,
				 "Cannot specify journal on remount");
			return -EINVAL;
		}
		ctx->journal_devnum = result.uint_32;
		ctx->spec |= EXT4_SPEC_JOURNAL_DEV;
		return 0;
	case Opt_journal_path:
	{
		struct inode *journal_inode;
		struct path path;
		int error;

		if (is_remount) {
			ext4_msg(NULL, KERN_ERR,
				 "Cannot specify journal on remount");
			return -EINVAL;
		}

		error = fs_lookup_param(fc, param, 1, LOOKUP_FOLLOW, &path);
		if (error) {
			ext4_msg(NULL, KERN_ERR, "error: could not find "
				 "journal device path");
			return -EINVAL;
		}

		journal_inode = d_inode(path.dentry);
		ctx->journal_devnum = new_encode_dev(journal_inode->i_rdev);
		ctx->spec |= EXT4_SPEC_JOURNAL_DEV;
		path_put(&path);
		return 0;
	}
	case Opt_journal_ioprio:
		if (result.uint_32 > 7) {
			ext4_msg(NULL, KERN_ERR, "Invalid journal IO priority"
				 " (must be 0-7)");
			return -EINVAL;
		}
		ctx->journal_ioprio =
			IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, result.uint_32);
		ctx->spec |= EXT4_SPEC_JOURNAL_IOPRIO;
		return 0;
	case Opt_test_dummy_encryption:
		return ext4_parse_test_dummy_encryption(param, ctx);
	case Opt_dax:
	case Opt_dax_type:
#ifdef CONFIG_FS_DAX
	{
		int type = (token == Opt_dax) ?
			   Opt_dax : result.uint_32;

		switch (type) {
		case Opt_dax:
		case Opt_dax_always:
			ctx_set_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS);
			ctx_clear_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER);
			break;
		case Opt_dax_never:
			ctx_set_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER);
			ctx_clear_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS);
			break;
		case Opt_dax_inode:
			ctx_clear_mount_opt(ctx, EXT4_MOUNT_DAX_ALWAYS);
			ctx_clear_mount_opt2(ctx, EXT4_MOUNT2_DAX_NEVER);
			/* Strictly for printing options */
			ctx_set_mount_opt2(ctx, EXT4_MOUNT2_DAX_INODE);
			break;
		}
		return 0;
	}
#else
		ext4_msg(NULL, KERN_INFO, "dax option not supported");
		return -EINVAL;
#endif
	case Opt_data_err:
		if (result.uint_32 == Opt_data_err_abort)
			ctx_set_mount_opt(ctx, m->mount_opt);
		else if (result.uint_32 == Opt_data_err_ignore)
			ctx_clear_mount_opt(ctx, m->mount_opt);
		return 0;
	case Opt_mb_optimize_scan:
		if (result.int_32 == 1) {
			ctx_set_mount_opt2(ctx, EXT4_MOUNT2_MB_OPTIMIZE_SCAN);
			ctx->spec |= EXT4_SPEC_mb_optimize_scan;
		} else if (result.int_32 == 0) {
			ctx_clear_mount_opt2(ctx, EXT4_MOUNT2_MB_OPTIMIZE_SCAN);
			ctx->spec |= EXT4_SPEC_mb_optimize_scan;
		} else {
			ext4_msg(NULL, KERN_WARNING,
				 "mb_optimize_scan should be set to 0 or 1.");
			return -EINVAL;
		}
		return 0;
	}

	/*
	 * At this point we should only be getting options requiring MOPT_SET,
	 * or MOPT_CLEAR. Anything else is a bug
	 */
	if (m->token == Opt_err) {
		ext4_msg(NULL, KERN_WARNING, "buggy handling of option %s",
			 param->key);
		WARN_ON(1);
		return -EINVAL;
	}

	else {
		unsigned int set = 0;

		if ((param->type == fs_value_is_flag) ||
		    result.uint_32 > 0)
			set = 1;

		if (m->flags & MOPT_CLEAR)
			set = !set;
		else if (unlikely(!(m->flags & MOPT_SET))) {
			ext4_msg(NULL, KERN_WARNING,
				 "buggy handling of option %s",
				 param->key);
			WARN_ON(1);
			return -EINVAL;
		}
		if (m->flags & MOPT_2) {
			if (set != 0)
				ctx_set_mount_opt2(ctx, m->mount_opt);
			else
				ctx_clear_mount_opt2(ctx, m->mount_opt);
		} else {
			if (set != 0)
				ctx_set_mount_opt(ctx, m->mount_opt);
			else
				ctx_clear_mount_opt(ctx, m->mount_opt);
		}
	}

	return 0;
}
