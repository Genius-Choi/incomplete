color2index(VTermColor *color, int fg, int *boldp)
{
    int red = color->red;
    int blue = color->blue;
    int green = color->green;

    if (color->ansi_index != VTERM_ANSI_INDEX_NONE)
    {
	/* First 16 colors and default: use the ANSI index, because these
	 * colors can be redefined. */
	if (t_colors >= 16)
	    return color->ansi_index;
	switch (color->ansi_index)
	{
	    case  0: return 0;
	    case  1: return lookup_color( 0, fg, boldp) + 1; /* black */
	    case  2: return lookup_color( 4, fg, boldp) + 1; /* dark red */
	    case  3: return lookup_color( 2, fg, boldp) + 1; /* dark green */
	    case  4: return lookup_color( 6, fg, boldp) + 1; /* brown */
	    case  5: return lookup_color( 1, fg, boldp) + 1; /* dark blue */
	    case  6: return lookup_color( 5, fg, boldp) + 1; /* dark magenta */
	    case  7: return lookup_color( 3, fg, boldp) + 1; /* dark cyan */
	    case  8: return lookup_color( 8, fg, boldp) + 1; /* light grey */
	    case  9: return lookup_color(12, fg, boldp) + 1; /* dark grey */
	    case 10: return lookup_color(20, fg, boldp) + 1; /* red */
	    case 11: return lookup_color(16, fg, boldp) + 1; /* green */
	    case 12: return lookup_color(24, fg, boldp) + 1; /* yellow */
	    case 13: return lookup_color(14, fg, boldp) + 1; /* blue */
	    case 14: return lookup_color(22, fg, boldp) + 1; /* magenta */
	    case 15: return lookup_color(18, fg, boldp) + 1; /* cyan */
	    case 16: return lookup_color(26, fg, boldp) + 1; /* white */
	}
    }

    if (t_colors >= 256)
    {
	if (red == blue && red == green)
	{
	    /* 24-color greyscale plus white and black */
	    static int cutoff[23] = {
		    0x0D, 0x17, 0x21, 0x2B, 0x35, 0x3F, 0x49, 0x53, 0x5D, 0x67,
		    0x71, 0x7B, 0x85, 0x8F, 0x99, 0xA3, 0xAD, 0xB7, 0xC1, 0xCB,
		    0xD5, 0xDF, 0xE9};
	    int i;

	    if (red < 5)
		return 17; /* 00/00/00 */
	    if (red > 245) /* ff/ff/ff */
		return 232;
	    for (i = 0; i < 23; ++i)
		if (red < cutoff[i])
		    return i + 233;
	    return 256;
	}
	{
	    static int cutoff[5] = {0x2F, 0x73, 0x9B, 0xC3, 0xEB};
	    int ri, gi, bi;

	    /* 216-color cube */
	    for (ri = 0; ri < 5; ++ri)
		if (red < cutoff[ri])
		    break;
	    for (gi = 0; gi < 5; ++gi)
		if (green < cutoff[gi])
		    break;
	    for (bi = 0; bi < 5; ++bi)
		if (blue < cutoff[bi])
		    break;
	    return 17 + ri * 36 + gi * 6 + bi;
	}
    }
    return 0;
}
