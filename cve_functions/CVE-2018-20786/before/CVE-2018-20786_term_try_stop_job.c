term_try_stop_job(buf_T *buf)
{
    int	    count;
    char    *how = (char *)buf->b_term->tl_kill;

#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
    if ((how == NULL || *how == NUL) && (p_confirm || cmdmod.confirm))
    {
	char_u	buff[DIALOG_MSG_SIZE];
	int	ret;

	dialog_msg(buff, _("Kill job in \"%s\"?"), buf->b_fname);
	ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);
	if (ret == VIM_YES)
	    how = "kill";
	else if (ret == VIM_CANCEL)
	    return FAIL;
    }
#endif
    if (how == NULL || *how == NUL)
	return FAIL;

    job_stop(buf->b_term->tl_job, NULL, how);

    /* wait for up to a second for the job to die */
    for (count = 0; count < 100; ++count)
    {
	/* buffer, terminal and job may be cleaned up while waiting */
	if (!buf_valid(buf)
		|| buf->b_term == NULL
		|| buf->b_term->tl_job == NULL)
	    return OK;

	/* call job_status() to update jv_status */
	job_status(buf->b_term->tl_job);
	if (buf->b_term->tl_job->jv_status >= JOB_ENDED)
	    return OK;
	ui_delay(10L, FALSE);
	mch_check_messages();
	parse_queued_messages();
    }
    return FAIL;
}
