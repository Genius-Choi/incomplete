find_reverse_dep_apps (FlatpakTransaction *transaction,
                       FlatpakDir         *dir,
                       FlatpakDecomposed  *ref,
                       gboolean           *out_is_extension)
{
  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);
  g_autoptr(GPtrArray) apps = NULL;
  g_autoptr(GError) local_error = NULL;

  g_assert (out_is_extension);

  *out_is_extension = flatpak_dir_is_runtime_extension (dir, ref);
  if (*out_is_extension)
    {
      /* Find apps which are using the ref as an extension directly or as an
       * extension of their runtime.
       */
      apps = flatpak_dir_list_app_refs_with_runtime_extension (dir,
                                                               &self->runtime_app_map,
                                                               &self->extension_app_map,
                                                               ref, NULL, &local_error);
      if (apps == NULL)
        {
          g_info ("Unable to list apps using extension %s: %s\n",
                  flatpak_decomposed_get_ref (ref), local_error->message);
          return NULL;
        }
    }
  else
    {
      /* Find any apps using the runtime directly */
      apps = flatpak_dir_list_app_refs_with_runtime (dir, &self->runtime_app_map, ref,
                                                     NULL, &local_error);
      if (apps == NULL)
        {
          g_info ("Unable to find apps using runtime %s: %s\n",
                  flatpak_decomposed_get_ref (ref), local_error->message);
          return NULL;
        }
    }

  /* Also check the current transaction since it's possible the EOL ref
   * and/or any app(s) that depend on it are not installed. It's also
   * possible the current transaction updates one of the apps to a
   * newer runtime but we don't handle that yet
   * (https://github.com/flatpak/flatpak/issues/4832)
   */
  check_current_transaction_for_dependent_apps (apps, transaction, ref);

  return g_steal_pointer (&apps);
}
