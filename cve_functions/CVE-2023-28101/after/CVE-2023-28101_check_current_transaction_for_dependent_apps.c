check_current_transaction_for_dependent_apps (GPtrArray          *apps,
                                              FlatpakTransaction *transaction,
                                              FlatpakDecomposed  *ref)
{
  g_autoptr(FlatpakTransactionOperation) ref_op = NULL;
  GPtrArray *related_ops;

  ref_op = flatpak_transaction_get_operation_for_ref (transaction, NULL, flatpak_decomposed_get_ref (ref), NULL);
  g_assert (ref_op != NULL);

  /* Get the related ops to find any apps that use @ref as a runtime or extension */
  related_ops = flatpak_transaction_operation_get_related_to_ops (ref_op);
  if (related_ops == NULL)
    return;

  for (int i = 0; i < related_ops->len; i++)
    {
      FlatpakTransactionOperation *related_op = g_ptr_array_index (related_ops, i);
      const char *related_op_ref = flatpak_transaction_operation_get_ref (related_op);
      g_autoptr(FlatpakDecomposed) related_op_decomposed = flatpak_decomposed_new_from_ref (related_op_ref, NULL);

      if (related_op_decomposed == NULL)
        continue;
      if (flatpak_decomposed_id_is_subref (related_op_decomposed))
        continue;

      /* Recurse in case @ref was a runtime extension. We need to check since a
       * runtime can have a runtime extension in its related ops in the
       * extra-data case, so if we recurse unconditionally it could be infinite
       * recursion.
       */
      if (flatpak_decomposed_is_runtime (related_op_decomposed))
        {
          GKeyFile *metadata = flatpak_transaction_operation_get_metadata (ref_op);
          if (g_key_file_has_group (metadata, FLATPAK_METADATA_GROUP_EXTENSION_OF))
            check_current_transaction_for_dependent_apps (apps, transaction, related_op_decomposed);
        }
      else if (!g_ptr_array_find_with_equal_func (apps, related_op_decomposed, (GEqualFunc)flatpak_decomposed_equal, NULL))
        g_ptr_array_add (apps, g_steal_pointer (&related_op_decomposed));
    }
}
