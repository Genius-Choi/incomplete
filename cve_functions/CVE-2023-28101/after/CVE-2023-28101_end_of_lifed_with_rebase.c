end_of_lifed_with_rebase (FlatpakTransaction *transaction,
                          const char         *remote,
                          const char         *ref_str,
                          const char         *reason,
                          const char         *rebased_to_ref,
                          const char        **previous_ids)
{
  FlatpakCliTransaction *self = FLATPAK_CLI_TRANSACTION (transaction);
  g_autoptr(FlatpakDecomposed) ref = flatpak_decomposed_new_from_ref (ref_str, NULL);
  g_autofree char *name = NULL;
  EolAction action = EOL_UNDECIDED;
  EolAction old_action = EOL_UNDECIDED;
  gboolean can_rebase = rebased_to_ref != NULL && remote != NULL;
  FlatpakInstallation *installation = flatpak_transaction_get_installation (transaction);
  FlatpakDir *dir = flatpak_installation_get_dir (installation, NULL);

  if (ref == NULL)
    return FALSE; /* Shouldn't happen, the ref should be valid */

  name = flatpak_decomposed_dup_id (ref);

  self->did_interaction = TRUE;

  if (flatpak_decomposed_id_is_subref (ref))
    {
      GLNX_HASH_TABLE_FOREACH_KV (self->eol_actions, FlatpakDecomposed *, eoled_ref, gpointer, value)
        {
          guint old_eol_action = GPOINTER_TO_UINT (value);

          if (flatpak_decomposed_id_is_subref_of (ref, eoled_ref))
              {
                old_action = old_eol_action; /* Do the same */
                break;
              }
        }
    }

  if (old_action != EOL_UNDECIDED)
    {
      switch (old_action)
        {
        default:
        case EOL_IGNORE:
          if (!can_rebase)
            action = EOL_IGNORE;
          /* Else, ask if we want to rebase */
          break;
        case EOL_REBASE:
        case EOL_NO_REBASE:
          if (can_rebase)
            action = old_action;
          else
            action = EOL_IGNORE;
        }
    }

  if (action == EOL_UNDECIDED)
    {
      action = EOL_IGNORE;

      print_eol_info_message (dir, ref, name, rebased_to_ref, reason);

      if (flatpak_decomposed_is_runtime (ref) && !rebased_to_ref)
        {
          gboolean is_extension;
          g_autoptr(GPtrArray) apps = find_reverse_dep_apps (transaction, dir, ref, &is_extension);

          if (apps && apps->len > 0)
            {
              if (is_extension)
                g_print (_("Info: applications using this extension:\n"));
              else
                g_print (_("Info: applications using this runtime:\n"));

              g_print ("   ");
              for (guint i = 0; i < apps->len; i++)
                {
                  FlatpakDecomposed *app_ref = g_ptr_array_index (apps, i);
                  g_autofree char *id = flatpak_decomposed_dup_id (app_ref);
                  if (i != 0)
                    g_print (", ");
                  g_print ("%s", id);
                }
              g_print ("\n");
            }
        }

      if (rebased_to_ref && remote)
        {
          /* The context for this prompt is in print_eol_info_message() */
          if (self->disable_interaction ||
              flatpak_yes_no_prompt (TRUE, _("Replace?")))
            {
              if (self->disable_interaction)
                g_print (_("Updating to rebased version\n"));

              action = EOL_REBASE;
            }
          else
            action = EOL_NO_REBASE;
        }
    }
  else
    {
      g_info ("%s is end-of-life, using action from parent ref", name);
    }

  /* Cache for later comparison and reuse */
  g_hash_table_insert (self->eol_actions, flatpak_decomposed_ref (ref), GUINT_TO_POINTER (action));

  if (action == EOL_REBASE)
    {
      g_autoptr(GError) error = NULL;

      if (!flatpak_transaction_add_rebase (transaction, remote, rebased_to_ref, NULL, previous_ids, &error))
        {
          g_propagate_prefixed_error (&self->first_operation_error,
                                      g_error_copy (error),
                                      _("Failed to rebase %s to %s: "),
                                      name, rebased_to_ref);
          return FALSE;
        }

      if (!flatpak_transaction_add_uninstall (transaction, ref_str, &error))
        {
          /* NOT_INSTALLED error is expected in case the op that triggered this was install not update */
          if (g_error_matches (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED))
            g_clear_error (&error);
          else
            {
              g_propagate_prefixed_error (&self->first_operation_error,
                                          g_error_copy (error),
                                          _("Failed to uninstall %s for rebase to %s: "),
                                          name, rebased_to_ref);
              return FALSE;
            }
        }

      return TRUE; /* skip install/update op of end-of-life ref */
    }
  else /* IGNORE or NO_REBASE */
    return FALSE;
}
