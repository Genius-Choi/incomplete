bit_convert_TU (BITCODE_TU restrict wstr)
{
  BITCODE_TU tmp = wstr;
  char *str;
  int i, len = 0;
  uint16_t c = 0;

  if (!wstr)
    return NULL;
#ifdef HAVE_ALIGNED_ACCESS_REQUIRED
  /* access bytewise. cannot copy to heap yet, because we have no length */
  if ((uintptr_t)wstr % SIZEOF_SIZE_T)
    {
      unsigned char *b = (unsigned char*)wstr;
      c = (b[0] << 8) + b[1];
      while (c)
        {
          len++;
          if (c >= 256)
            len++;
          if (c >= 0x800)
            len++;
          b += 2;
          c = (b[0] << 8) + b[1];
        }
    }
  else
#endif
  while ((c = *tmp++))
    {
      len++;
      if (c >= 256)
        len++;
      if (c >= 0x800)
        len++;
#if 0
        loglevel = 5;
        LOG_INSANE ("U+%04X ", c);
#endif
    }
  str = malloc (len + 1);
  i = 0;
#ifdef HAVE_ALIGNED_ACCESS_REQUIRED
  if ((uintptr_t)wstr % SIZEOF_SIZE_T)
    {
      unsigned char *b = (unsigned char*)wstr;
      c = (b[0] << 8) + b[1];
      while (c)
        {
          if (c < 256)
            {
              str[i++] = c & 0xFF;
            }
          else if (c < 0x800)
            {
              str[i++] = (c >> 6) | 0xC0;
              str[i++] = (c & 0x3F) | 0x80;
            }
          else /* if (c < 0x10000) */
            {
              str[i++] = (c >> 12) | 0xE0;
              str[i++] = ((c >> 6) & 0x3F) | 0x80;
              str[i++] = (c & 0x3F) | 0x80;
            }

          b += 2;
          c = (b[0] << 8) + b[1];
        }
    }
  else
#endif
  while ((c = *wstr++))
    {
      if (c < 256)
        {
          str[i++] = c & 0xFF;
        }
      else if (c < 0x800)
        {
          str[i++] = (c >> 6) | 0xC0;
          str[i++] = (c & 0x3F) | 0x80;
        }
      else /* if (c < 0x10000) */
        { /* windows ucs-2 has no D800-DC00 surrogate pairs. go straight up */
          /*if (i+3 > len) {
            str = realloc(str, i+3);
            len = i+2;
          }*/
          str[i++] = (c >> 12) | 0xE0;
          str[i++] = ((c >> 6) & 0x3F) | 0x80;
          str[i++] = (c & 0x3F) | 0x80;
        }
      /*
      else if (c < 0x110000)
        {
          str[i++] = (c >> 18) | 0xF0;
          str[i++] = ((c >> 12) & 0x3F) | 0x80;
          str[i++] = ((c >> 6) & 0x3F) | 0x80;
          str[i++] = (c & 0x3F) | 0x80;
        }
      else
        fprintf (stderr, "ERROR: overlarge unicode codepoint U+%0X", c);
     */
    }
  str[i] = '\0';
  return str;
}
