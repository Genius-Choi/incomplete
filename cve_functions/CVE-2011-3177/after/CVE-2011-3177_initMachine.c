int IniParser::initMachine (const YCPMap&scr)
{
    started = true;

    //
    // now process the script
    //
    ignore_case_regexps = ignore_case = prefer_uppercase = first_upper = line_can_continue = no_nested_sections =
	global_values = repeat_names = comments_last = join_multiline =
	no_finalcomment_kill = read_only = flat = false;

    // read the options
    YCPValue v = scr->value(YCPString("options"));
    if (!v.isNull()) {
	if (!v->isList ())
	    y2error ("'options' must be a list");
	else {
	    int len = v->asList()->size();
	    for (int i = 0;i<len;i++)
		{
		    if (!v->asList()->value(i)->isString()) {
			y2error ("items of 'options' must be strings");
			continue;
		    }
		    string sv = v->asList()->value(i)->asString()->value();
#define COMPARE_OPTION(X) if (sv == #X) X = true; else 
		    COMPARE_OPTION (ignore_case_regexps)
		    COMPARE_OPTION (ignore_case)
		    COMPARE_OPTION (prefer_uppercase)
		    COMPARE_OPTION (first_upper)
		    COMPARE_OPTION (line_can_continue)
		    COMPARE_OPTION (no_nested_sections)
		    COMPARE_OPTION (global_values)
		    COMPARE_OPTION (repeat_names)
		    COMPARE_OPTION (comments_last)
		    COMPARE_OPTION (join_multiline)
		    COMPARE_OPTION (no_finalcomment_kill)
		    COMPARE_OPTION (read_only)
		    COMPARE_OPTION (flat)
			y2error ("Option not implemented yet: %s", sv.c_str());
#undef  COMPARE_OPTION
		}
	}
    }

    if (ignore_case && multiple_files)
    {
       ycperror ("When using multiple files, ignore_case does not work");
       ignore_case = false;
    }

    v = scr->value(YCPString("rewrite"));
    if (!v.isNull()) {
	if (!v->isList ())
	    y2error ("'rewrite' must be a list");
	else {

	int len = v->asList()->size();
	rewrites.clear ();
	rewrites.reserve (len);
	for (int i = 0; i<len;i++)
	{
	    YCPValue ival = v->asList()->value(i);
	    if (ival->isList() && 
		2 == ival->asList()->size() && 
		ival->asList()->value(0)->isString() &&
		ival->asList()->value(1)->isString())
	    {
		IoPattern p;
		if (!p.rx.compile (ival->asList()->value(0)->asString()->value(), ignore_case_regexps))
		{
		    p.out = ival->asList()->value(1)->asString()->value();
		    rewrites.push_back (p);
		}
	    }
	    else
		y2error ("items of 'rewrite' must be lists of two strings");
	}

	}
    }

    v = scr->value(YCPString("subindent"));
    if (!v.isNull()) {
	if (!v->isString ())
	    y2error ("'subindent' must be a string");
	else
	    subindent = v->asString()->value();
    }

    // read comments
    v = scr->value(YCPString("comments"));
    if (!v.isNull()) {
	if (!v->isList ())
	    y2error ("'comments' must be a list");
	else {
	    int len = v->asList()->size();
	    linecomments.clear ();
	    comments.clear ();
	    linecomments.reserve (len);
	    comments.reserve (len);
	    for (int i = 0;  i < len; i++)
	    {
		if (!v->asList()->value(i)->isString()) {
		    y2error ("items of 'comments' must be strings");
		    continue;
		}
		YCPString s = v->asList()->value(i)->asString();
		vector <Regex> & regexes = ('^' == s->value_cstr()[0]) ?
		    linecomments : comments;
		Regex r;
		if (!r.compile (s->value (), ignore_case_regexps))
		{
		    regexes.push_back (r);
		}
	    }
	}
    }

    // read sections
    v = scr->value(YCPString("sections"));
    if (!v.isNull()) {
	if (!v->isList ())
	    y2error ("'sections' must be a list");
	else {
	    int len = v->asList()->size();
	    // compile them to regex_t
	    sections.clear ();
	    sections.reserve (len);
	    for (int i = 0;  i < len; i++)
		{
		    if (!v->asList()->value(i)->isMap())
			y2error ("items of 'sections' must be maps");
		    else
			{
			    section s;
			    YCPMap m = v->asList()->value(i)->asMap ();
			    s.end_valid = false;
			    YCPList p;
			    switch (getBeginEndType (m))
				{
				case 0:
				    p = m->value(YCPString("end"))->asList();
				    if (s.end.rx.compile (
					    p->value(0)->asString()->value (),
					    ignore_case_regexps))
					break;
				    s.end.out =
					p->value(1)->asString()->value ();
				    s.end_valid = true;
				    // Fall through
				case 1:
				    p = m->value(YCPString("begin"))->asList();
				    if (s.begin.rx.compile (
					    p->value(0)->asString()->value (),
					    ignore_case_regexps))
					{
					    // compile failed
					    break;
					}
				    s.begin.out =
					p->value(1)->asString()->value ();
				    sections.push_back (s);
				    break;
				case -1:
				default:
				    y2error ("Bad format of %dth section map", i);
				}
			}
		}
	}
    }

    // read parameters
    v = scr->value(YCPString("params"));
    if (!v.isNull()) {
	if (!v->isList ())
	    y2error ("'params' must be a list");
	else {
	    int len = v->asList()->size();
	    // compile them to regex_t
	    params.clear ();
	    params.reserve (len);
	    for (int i = 0; i < len; i++)
		{
		    if (!v->asList()->value(i)->isMap())
			y2error ("items of 'params' must be maps");
		    else
			{
			    YCPMap m = v->asList()->value(i)->asMap ();
			    param pa;
			    pa.multiline_valid = false;
			    YCPList p;
			    switch (getParamsType (m))
				{
				case 0:
				    p = m->value(YCPString("multiline"))->asList();
				    if (!pa.begin.compile (
					    p->value(0)->asString()->value (),
					    ignore_case_regexps))
					if (!pa.end.compile (
						p->value(1)->asString()->value (),
						ignore_case_regexps))
					    {
						pa.multiline_valid = true;
					    }
					else
					{
					    y2error ("Bad regexp(multiline): %s",
						p->value(1)->asString()->value_cstr());
					}
				    else
					  y2error ("Bad regexp(multiline): %s",
					      p->value(0)->asString()->value_cstr());
				case 1:
				    p = m->value(YCPString("match"))->asList();
				    if (pa.line.rx.compile (
					    p->value(0)->asString()->value (),
					    ignore_case_regexps))
				    {
					if (pa.multiline_valid)
					{
					    y2error ("Bad regexp(match): %s",
						p->value(0)->asString()->value_cstr());
					}
					break;
				    }
				    pa.line.out =
					p->value(1)->asString()->value ();
				    params.push_back (pa);
				    break;
				case -1:
				default:
				    y2error ("Bad format of %dth param map", i);
				}
			}
		}
	}
    }
    return 0;
}
