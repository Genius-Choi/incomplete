BrowserCookie CookieManager::ParseSingleCookie(const std::string& cookie) {
  LOG(TRACE) << "Entering CookieManager::ParsePersistentCookieInfo";
  // Cookies represented by a structured string record type.
  // This structure is modeled after how some versions of IE
  // stored perisitent cookeis as files on disk. Each cookie
  // is represented by 8 lines in the file separated by line
  // feed (0xA) characters, with the following format:
  //
  //     cookie_name
  //     cookie_value
  //     cookie.domain.value/cookie/path/value/
  //     <integer representing cookie flags>
  //     <unsigned long representing the low 32 bits of expiration time>
  //     <unsigned long representing the high 32 bits of expiration time>
  //     <unsigned long representing the low 32 bits of last-modified time>
  //     <unsigned long representing the high 32 bits of last-modified time>
  //
  // Read each of these lines and set the appropriate values
  // in the resulting cookie object.
  std::vector<std::string> cookie_parts;
  StringUtilities::Split(cookie, "\n", &cookie_parts);

  BrowserCookie cookie_to_return;
  cookie_to_return.set_name(cookie_parts[0]);
  cookie_to_return.set_value(cookie_parts[1]);

  size_t position = cookie_parts[2].find_first_of("/");
  cookie_to_return.set_domain(cookie_parts[2].substr(0, position));
  cookie_to_return.set_path(cookie_parts[2].substr(position));

  int flags = atoi(cookie_parts[3].c_str());
  cookie_to_return.set_is_secure(INTERNET_COOKIE_IS_SECURE == (INTERNET_COOKIE_IS_SECURE & flags));
  cookie_to_return.set_is_httponly(INTERNET_COOKIE_HTTPONLY == (INTERNET_COOKIE_HTTPONLY & flags));

  if (cookie_parts[4].size() > 0 && cookie_parts[5].size() > 0) {
    unsigned long expiry_time_low = strtoul(cookie_parts[4].c_str(), NULL, 10);
    unsigned long expiry_time_high = strtoul(cookie_parts[5].c_str(), NULL, 10);
    unsigned long long expiration_time = (expiry_time_high * static_cast<long long>(pow(2.0, 32))) + expiry_time_low;

    // Cookie expiration time is stored in the file as the number
    // of 100-nanosecond ticks since 1 January 1601 12:00:00 AM GMT.
    // We need the number of seconds since 1 January 1970 12:00:00 AM GMT.
    // This is the conversion.
    unsigned long cookie_expiration_time = static_cast<unsigned long>((expiration_time / TICKS_PER_SECOND) - UNIX_TIME_OFFSET_SECONDS);
    cookie_to_return.set_expiration_time(cookie_expiration_time);
  }
  return cookie_to_return;
}
