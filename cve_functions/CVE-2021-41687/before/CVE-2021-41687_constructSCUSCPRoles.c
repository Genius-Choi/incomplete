constructSCUSCPRoles(unsigned char type,
      DUL_ASSOCIATESERVICEPARAMETERS * params, LST_HEAD ** lst,
         unsigned long *rtnLength)
{
  /* Pointer to loop through presentation ctx */
  DUL_PRESENTATIONCONTEXT* presentationCtx;
  PRV_SCUSCPROLE* scuscpItem;
  unsigned char scuRole = 0, scpRole = 0;
  unsigned long length;

  *rtnLength = 0;
  OFCondition cond = EC_Normal;
  if (type == DUL_TYPEASSOCIATERQ)
  {
      presentationCtx = params->requestedPresentationContext != NULL ?
          (DUL_PRESENTATIONCONTEXT*)LST_Head(&params->requestedPresentationContext) :
          (DUL_PRESENTATIONCONTEXT*)NULL;

      if (presentationCtx != NULL)
          (void) LST_Position(&params->requestedPresentationContext, (LST_NODE*)presentationCtx);

      while (presentationCtx != NULL) {
          if (presentationCtx->proposedSCRole != DUL_SC_ROLE_DEFAULT) {
              scuscpItem = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));
              if (scuscpItem == NULL) return EC_MemoryExhausted;
              if (presentationCtx->proposedSCRole == DUL_SC_ROLE_SCU) {
                  scuRole = 1;
                  scpRole = 0;
              } else if (presentationCtx->proposedSCRole == DUL_SC_ROLE_SCP) {
                  scuRole = 0;
                  scpRole = 1;
              } else {
                  scuRole = scpRole = 1;
              }
              cond = constructSCUSCPSubItem(presentationCtx->abstractSyntax,
                      DUL_TYPESCUSCPROLE, scuRole, scpRole, scuscpItem, &length);
              if (cond.bad())
              {
                  free(scuscpItem);
                  return cond;
              }
              *rtnLength += length;
              LST_Enqueue(lst, (LST_NODE*)scuscpItem);
          }
          presentationCtx = (DUL_PRESENTATIONCONTEXT*)LST_Next(&params->requestedPresentationContext);
      }
  } else {  // type != DUL_TYPEASSOCIATERQ
     /* The implemented behaviour is documented in dul.h (see DUL_SC_ROLE enum definition).
      * The error case is already handled in ASC_acceptPresentationContext() in assoc.cc.
      */
      presentationCtx = params->acceptedPresentationContext != NULL ?
          (DUL_PRESENTATIONCONTEXT*)LST_Head(&params->acceptedPresentationContext) :
          (DUL_PRESENTATIONCONTEXT*)NULL;

      if (presentationCtx != NULL)
          (void) LST_Position(&params->acceptedPresentationContext, (LST_NODE*)presentationCtx);

      while (presentationCtx != NULL) {
          // check that the default behavior does not apply
          if ((presentationCtx->proposedSCRole != DUL_SC_ROLE_DEFAULT) &&
                  (presentationCtx->acceptedSCRole != DUL_SC_ROLE_DEFAULT)) {
              scuscpItem = (PRV_SCUSCPROLE*)malloc(sizeof(*scuscpItem));
              if (scuscpItem == NULL) return EC_MemoryExhausted;
              if (presentationCtx->acceptedSCRole == DUL_SC_ROLE_SCU) {
                  // only accept SCU role for the requester if proposed, see PS 3.7
                  scuRole = (presentationCtx->proposedSCRole != DUL_SC_ROLE_SCP) ? 1 : 0;
                  scpRole = 0;
              } else if (presentationCtx->acceptedSCRole == DUL_SC_ROLE_SCP) {
                  scuRole = 0;
                  // only accept SCP role for the requester if proposed, see PS 3.7
                  scpRole = (presentationCtx->proposedSCRole != DUL_SC_ROLE_SCU) ? 1 : 0;
              } else {
                  // only accept roles for the requester if proposed, see PS 3.7
                  scuRole = (presentationCtx->proposedSCRole != DUL_SC_ROLE_SCP) ? 1 : 0;
                  scpRole = (presentationCtx->proposedSCRole != DUL_SC_ROLE_SCU) ? 1 : 0;
              }
              // neither SCU nor SCP role accepted
              if ((scuRole == 0) && (scpRole == 0)) {
                  presentationCtx->acceptedSCRole = DUL_SC_ROLE_NONE;
                  DCMNET_WARN("setting accepted SCP/SCU role to NONE, i.e. both role fields are 0 in SCP/SCU role selection sub-item");
              }
              cond = constructSCUSCPSubItem(presentationCtx->abstractSyntax,
                      DUL_TYPESCUSCPROLE, scuRole, scpRole, scuscpItem, &length);
              if (cond.bad()) {
                  free(scuscpItem);
                  return cond;
              }
              *rtnLength += length;
              LST_Enqueue(lst, (LST_NODE*)scuscpItem);
          }
          presentationCtx = (DUL_PRESENTATIONCONTEXT*)LST_Next(&params->acceptedPresentationContext);
      }
  }
  return EC_Normal;
}
