int main(int argc, char * argv[])
{
	int c;
	bool ignore_driver_version_mismatch = false;
	DBusError error;
	DBusConnection* connection = NULL;

	dbus_error_init(&error);

	srandom(time(NULL));

	while (1) {
		static struct option long_options[] = {
			{"help", no_argument, 0, 'h'},
			{"version", no_argument, 0, 'v'},
			{"ignore-mismatch", no_argument, 0, 'i'},
			{"debug", no_argument, 0, 'd'},
			{"interface", required_argument, 0, 'I'},
			{"file", required_argument, 0, 'f'},
			{0, 0, 0, 0}
		};

		int option_index = 0;

		if ((optind < argc) && (find_cmd(argv[optind]) != NULL)) {
			// This is where the wpanctl command starts; skip
			// parsing the flags since they may belong to the command
			break;
	}

		c = getopt_long(argc, argv, "hvidI:f:", long_options,
				&option_index);

		if (c == -1)
			break;

		switch (c) {
		case 'h':
		print_version();
		print_arg_list_help(option_list,
		                    argv[0],
		                    "[options] <sub-command> [args]");
		print_commands();
		gRet = ERRORCODE_HELP;
		goto bail;

		case 'v':
			print_version();
			gRet = 0;
			goto bail;

		case 'd':
			gDebugMode++;
			break;

		case 'I':
			snprintf(gInterfaceName, sizeof(gInterfaceName),
				 "%s", optarg);
			break;

		case 'i':
			ignore_driver_version_mismatch = true;
			break;

		case 'f':
#if HAVE_LIBREADLINE
			if (NULL == freopen(optarg, "r", stdin))
			{
				fprintf(stderr,
						"%s: error: Unable to open file \"%s\".\n",
						argv[0], optarg);
				return ERRORCODE_BADARG;
			}
#else
			fprintf(stderr,
				"%s: Cannot read from file \"%s\" : Missing readline library.\n",
				argv[0], optarg);
			return ERRORCODE_BADARG;
#endif
		default:
		break;
	}
	}

	istty = isatty(fileno(stdin));

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: isatty(fileno(stdin)) = %d\n", istty);
	}

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: Will use interface '%s'.\n", gInterfaceName);
	}

#if HAVE_PWD_H
	if (getuid() == 0 && strcmp(WPANTUND_SERVICE_USER, "root")) {
		uid_t target_uid = 0;
		gid_t target_gid = 0;
		struct passwd *passwd = getpwnam(WPANTUND_SERVICE_USER);

		if (passwd == NULL) {
			fprintf(stderr, "getpwnam: Unable to lookup user \"%s\".", WPANTUND_SERVICE_USER);
			gRet = ERRORCODE_ERRNO;
			goto bail;
		}

		target_uid = passwd->pw_uid;
		target_gid = passwd->pw_gid;

		if (target_gid != 0) {
			if (setgid(target_gid) != 0) {
				perror("setgid");
				gRet = ERRORCODE_ERRNO;
				goto bail;
			}
		}

		if (target_uid != 0) {
			if (setuid(target_uid) != 0) {
				perror("setuid");
				gRet = ERRORCODE_ERRNO;
				goto bail;
			}
		}
	}
#endif // HAVE_PWD_H

	if (getenv("WPANCTL_DBUS_NAME") && gDebugMode>=1)
		fprintf(stderr, "DEBUG: Using dbus \"%s\"\n", getenv("WPANCTL_DBUS_NAME"));

	setenv("WPANCTL_DBUS_NAME", WPAN_TUNNEL_DBUS_NAME, 0);

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\n");
	}

	connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);

	require_string(connection != NULL, bail, error.message);

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: DBusConnection: %p\n", connection);
	}

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: Registering DBusConnection. . .\n");
	}

	dbus_bus_register(connection, &error);
	require_string(error.name == NULL, bail, error.message);

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: DBusConnection registered.\n");
	}

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: Requesting DBus name \"%s\". . .\n",WPAN_TUNNEL_DBUS_NAME ".wpanctl");
	}

	dbus_bus_request_name(connection,
	                      WPAN_TUNNEL_DBUS_NAME ".wpanctl",
	                      0,
	                      &error);

	if (gDebugMode >= 1) {
		if (error.name != NULL) {
			fprintf(stderr, "DEBUG: Requesting DBus name \"%s\" failed (no biggie): %s\n",WPAN_TUNNEL_DBUS_NAME ".wpanctl", error.name);
		} else {
			fprintf(stderr, "DEBUG: Requesting DBus name \"%s\" succeded.\n",WPAN_TUNNEL_DBUS_NAME ".wpanctl");
		}
	}

	// Don't fail if we can't get the name. It isn't a big deal.
	//require_string(error.name == NULL, bail, error.message);

	if (gDebugMode >= 1) {
		fprintf(stderr, "DEBUG: Performing wpantund version check. . .\n");
	}

	// Make sure that we are compatible with the copy of wpantund
	// that is currently running.
	gRet = wpan_dbus_version_check(connection);

	if (gRet != 0) {
		fprintf(stderr,
		        "%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\n",
		        argv[0]
		        );
		if (!ignore_driver_version_mismatch)
			goto bail;
	} else {
		if (gDebugMode >= 1) {
			fprintf(stderr,
				"DEBUG: wpantund version check succeded.\n");
		}
	}

	if (optind < argc) {
			if (gDebugMode >= 1) {
			fprintf(stderr, "DEBUG: Executing command '%s'. . .\n",
				argv[optind]);
		}

		argc -= optind;
		argv += optind;

		optind = 0;
		gRet = exec_command(argc, argv);
		goto bail;
	}

	if (istty) {
#if !HAVE_LIBREADLINE
		fprintf(stderr,
		        "%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\n",
		        argv[0]
		        );
		print_arg_list_help(option_list,
		                    argv[0],
		                    "[options] <sub-command> [args]");
		print_commands();
		gRet = ERRORCODE_NOCOMMAND;
		goto bail;
#else   // HAVE_LIBREADLINE
		setenv("WPANCTL_HISTORY_FILE", tilde_expand("~/.wpanctl_history"), 0);

		gRet = initialize_readline();
		if(gRet) {
			fprintf(stderr,
			        "%s: error: Failed to initialize readline: %d\n",
			        argv[0], gRet
			        );
			goto bail;
		}
#endif  // HAVE_LIBREADLINE
	}

	// Command mode.
	while ((gRet != ERRORCODE_QUIT) && !feof(stdin)) {
		optind = 0;
#if HAVE_LIBREADLINE
		if (istty) {
			int dbus_fd = -1;

			dbus_connection_get_unix_fd(connection, &dbus_fd);

			struct pollfd polltable[2] = {
				{ fileno(stdin), POLLIN | POLLHUP,               0                         },
				{ dbus_fd,               POLLIN | POLLHUP,               0                         },
			};

			if (poll(
			        polltable,
			        (dbus_fd >= 0) ? 2 : 1,
			        1000
			        ) < 0
			    ) {
				if (errno == EINTR) {
					// We just caught a signal.
					// Do nothing.
				} else {
					break;
				}
			}

			if (polltable[0].revents)
				rl_callback_read_char();
		} else
#endif  // HAVE_LIBREADLINE
		{
			char linebuffer[200];
			process_input_line(fgets(linebuffer, sizeof(linebuffer), stdin));
		}

		dbus_connection_read_write_dispatch(connection, 0);
	}
	printf("\n");

bail:
#if HAVE_LIBREADLINE
	rl_callback_handler_remove();
#endif  // HAVE_LIBREADLINE
	if (gRet == ERRORCODE_QUIT)
		gRet = 0;

	if (connection) {
		dbus_connection_unref(connection);
	}

	dbus_error_free(&error);

	return gRet;
}
