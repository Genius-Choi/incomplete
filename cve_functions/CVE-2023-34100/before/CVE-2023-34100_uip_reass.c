uip_reass(uint8_t *prev_proto_ptr)
{
  uint16_t offset=0;
  uint16_t len;
  uint16_t i;
  struct uip_frag_hdr *frag_buf = (struct uip_frag_hdr *)UIP_IP_PAYLOAD(uip_ext_len);

  /* If ip_reasstmr is zero, no packet is present in the buffer */
  /* We first write the unfragmentable part of IP header into the reassembly
     buffer. The reset the other reassembly variables. */
  if(uip_reass_on == 0) {
    LOG_INFO("Starting reassembly\n");
    memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
    /* temporary in case we do not receive the fragment with offset 0 first */
    etimer_set(&uip_reass_timer, UIP_REASS_MAXAGE*CLOCK_SECOND);
    uip_reass_on = 1;
    uip_reassflags = 0;
    uip_id = frag_buf->id;
    /* Clear the bitmap. */
    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
  }
  /*
   * Check if the incoming fragment matches the one currently present
   * in the reasembly buffer. If so, we proceed with copying the fragment
   * into the buffer.
   */
  if(uip_ipaddr_cmp(&FBUF->srcipaddr, &UIP_IP_BUF->srcipaddr) &&
     uip_ipaddr_cmp(&FBUF->destipaddr, &UIP_IP_BUF->destipaddr) &&
     frag_buf->id == uip_id) {
    len = uip_len - uip_ext_len - UIP_IPH_LEN - UIP_FRAGH_LEN;
    offset = (uip_ntohs(frag_buf->offsetresmore) & 0xfff8);
    /* in byte, originaly in multiple of 8 bytes*/
    LOG_INFO("len %d\n", len);
    LOG_INFO("offset %d\n", offset);
    if(offset == 0){
      uip_reassflags |= UIP_REASS_FLAG_FIRSTFRAG;
      /*
       * The Next Header field of the last header of the Unfragmentable
       * Part is obtained from the Next Header field of the first
       * fragment's Fragment header.
       */
      *prev_proto_ptr = frag_buf->next;
      memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
      LOG_INFO("src ");
      LOG_INFO_6ADDR(&FBUF->srcipaddr);
      LOG_INFO_("dest ");
      LOG_INFO_6ADDR(&FBUF->destipaddr);
      LOG_INFO_("next %d\n", UIP_IP_BUF->proto);

    }

    /* If the offset or the offset + fragment length overflows the
       reassembly buffer, we discard the entire packet. */
    if(offset > UIP_REASS_BUFSIZE ||
       offset + len > UIP_REASS_BUFSIZE) {
      uip_reass_on = 0;
      etimer_stop(&uip_reass_timer);
      return 0;
    }

    /* If this fragment has the More Fragments flag set to zero, it is the
       last fragment*/
    if((uip_ntohs(frag_buf->offsetresmore) & IP_MF) == 0) {
      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
      /*calculate the size of the entire packet*/
      uip_reasslen = offset + len;
      LOG_INFO("last fragment reasslen %d\n", uip_reasslen);
    } else {
      /* If len is not a multiple of 8 octets and the M flag of that fragment
         is 1, then that fragment must be discarded and an ICMP Parameter
         Problem, Code 0, message should be sent to the source of the fragment,
         pointing to the Payload Length field of the fragment packet. */
      if(len % 8 != 0){
        uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, 4);
        uip_reassflags |= UIP_REASS_FLAG_ERROR_MSG;
        /* not clear if we should interrupt reassembly, but it seems so from
           the conformance tests */
        uip_reass_on = 0;
        etimer_stop(&uip_reass_timer);
        return uip_len;
      }
    }

    /* Copy the fragment into the reassembly buffer, at the right
       offset. */
    memcpy((uint8_t *)FBUF + UIP_IPH_LEN + uip_ext_len + offset,
           (uint8_t *)frag_buf + UIP_FRAGH_LEN, len);

    /* Update the bitmap. */
    if(offset >> 6 == (offset + len) >> 6) {
      uip_reassbitmap[offset >> 6] |=
        bitmap_bits[(offset >> 3) & 7] &
        ~bitmap_bits[((offset + len) >> 3)  & 7];
    } else {
      /* If the two endpoints are in different bytes, we update the
         bytes in the endpoints and fill the stuff inbetween with
         0xff. */
      uip_reassbitmap[offset >> 6] |= bitmap_bits[(offset >> 3) & 7];

      for(i = (1 + (offset >> 6)); i < ((offset + len) >> 6); ++i) {
        uip_reassbitmap[i] = 0xff;
      }
      uip_reassbitmap[(offset + len) >> 6] |=
        ~bitmap_bits[((offset + len) >> 3) & 7];
    }

    /* Finally, we check if we have a full packet in the buffer. We do
       this by checking if we have the last fragment and if all bits
       in the bitmap are set. */

    if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
      /* Check all bytes up to and including all but the last byte in
         the bitmap. */
      for(i = 0; i < (uip_reasslen >> 6); ++i) {
        if(uip_reassbitmap[i] != 0xff) {
          return 0;
        }
      }
      /* Check the last byte in the bitmap. It should contain just the
         right amount of bits. */
      if(uip_reassbitmap[uip_reasslen >> 6] !=
         (uint8_t)~bitmap_bits[(uip_reasslen >> 3) & 7]) {
        return 0;
      }

      /* If we have come this far, we have a full packet in the
         buffer, so we copy it to uip_buf. We also reset the timer. */
      uip_reass_on = 0;
      etimer_stop(&uip_reass_timer);

      uip_reasslen += UIP_IPH_LEN + uip_ext_len;
      memcpy(UIP_IP_BUF, FBUF, uip_reasslen);
      uipbuf_set_len_field(UIP_IP_BUF, uip_reasslen - UIP_IPH_LEN);
      LOG_INFO("reassembled packet %d (%d)\n", uip_reasslen, uipbuf_get_len_field(UIP_IP_BUF));

      return uip_reasslen;

    }
  } else {
    LOG_WARN("Already reassembling another paquet\n");
  }
  return 0;
}
