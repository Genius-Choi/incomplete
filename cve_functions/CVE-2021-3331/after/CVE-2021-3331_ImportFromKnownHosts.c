void __fastcall TStoredSessionList::ImportFromKnownHosts(TStrings * Lines)
{
  bool SessionList = false;
  std::unique_ptr<THierarchicalStorage> HostKeyStorage(Configuration->CreateScpStorage(SessionList));
  std::unique_ptr<TStrings> KeyList(new TStringList());
  if (OpenHostKeysSubKey(HostKeyStorage.get(), false))
  {
    HostKeyStorage->GetValueNames(KeyList.get());
  }
  HostKeyStorage.reset(NULL);

  UnicodeString FirstError;
  for (int Index = 0; Index < Lines->Count; Index++)
  {
    try
    {
      UnicodeString Line = Lines->Strings[Index];
      Line = Trim(Line);
      if (!Line.IsEmpty() && (Line[1] != L';'))
      {
        int P = Pos(L' ', Line);
        if (P > 0)
        {
          UnicodeString HostNameStr = Line.SubString(1, P - 1);
          Line = Line.SubString(P + 1, Line.Length() - P);

          P = Pos(L',', HostNameStr);
          if (P > 0)
          {
            HostNameStr.SetLength(P - 1);
          }
          P = Pos(L':', HostNameStr);
          int PortNumber = -1;
          if (P > 0)
          {
            UnicodeString PortNumberStr = HostNameStr.SubString(P + 1, HostNameStr.Length() - P);
            PortNumber = StrToInt(PortNumberStr);
            HostNameStr.SetLength(P - 1);
          }
          if ((HostNameStr.Length() >= 2) &&
              (HostNameStr[1] == L'[') && (HostNameStr[HostNameStr.Length()] == L']'))
          {
            HostNameStr = HostNameStr.SubString(2, HostNameStr.Length() - 2);
          }

          UnicodeString NameStr = HostNameStr;
          if (PortNumber >= 0)
          {
            NameStr = FORMAT(L"%s:%d", (NameStr, PortNumber));
          }

          std::unique_ptr<TSessionData> SessionDataOwner;
          TSessionData * SessionData = dynamic_cast<TSessionData *>(FindByName(NameStr));
          if (SessionData == NULL)
          {
            SessionData = new TSessionData(L"");
            SessionDataOwner.reset(SessionData);
            SessionData->CopyData(DefaultSettings);
            SessionData->Name = NameStr;
            SessionData->HostName = HostNameStr;
            if (PortNumber >= 0)
            {
              SessionData->PortNumber = PortNumber;
            }
          }

          const struct ssh_keyalg * Algorithm;
          UnicodeString Key = ParseOpenSshPubLine(Line, Algorithm);
          UnicodeString KeyKey =
            FORMAT(L"%s@%d:%s", (Algorithm->cache_id, SessionData->PortNumber, HostNameStr));
          UnicodeString HostKey =
            FORMAT(L"%s:%s=%s", (Algorithm->ssh_id, KeyKey, Key));
          UnicodeString HostKeyList = SessionData->HostKey;
          AddToList(HostKeyList, HostKey, L";");
          SessionData->HostKey = HostKeyList;
          // If there's at least one unknown key type for this host, select it
          if (KeyList->IndexOf(KeyKey) < 0)
          {
            SessionData->Selected = true;
          }

          if (SessionDataOwner.get() != NULL)
          {
            Add(SessionDataOwner.release());
          }
        }
      }
    }
    catch (Exception & E)
    {
      if (FirstError.IsEmpty())
      {
        FirstError = E.Message;
      }
    }
  }

  if (Count == 0)
  {
    UnicodeString Message = LoadStr(KNOWN_HOSTS_NO_SITES);
    if (!FirstError.IsEmpty())
    {
      Message = FORMAT(L"%s\n(%s)", (Message, FirstError));
    }

    throw Exception(Message);
  }
}
