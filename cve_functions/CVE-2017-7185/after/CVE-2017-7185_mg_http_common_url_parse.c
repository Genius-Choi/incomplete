MG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,
                                         const char *schema_tls, int *use_ssl,
                                         char **user, char **pass, char **addr,
                                         int *port_i, const char **path) {
  int addr_len = 0;
  int auth_sep_pos = -1;
  int user_sep_pos = -1;
  int port_pos = -1;
  (void) user;
  (void) pass;

  if (strncmp(url, schema, strlen(schema)) == 0) {
    url += strlen(schema);
  } else if (strncmp(url, schema_tls, strlen(schema_tls)) == 0) {
    url += strlen(schema_tls);
    *use_ssl = 1;
#if !MG_ENABLE_SSL
    return -1; /* SSL is not enabled, cannot do HTTPS URLs */
#endif
  }

  while (*url != '\0') {
    *addr = (char *) MG_REALLOC(*addr, addr_len + 6 /* space for port too. */);
    if (*addr == NULL) {
      DBG(("OOM"));
      return -1;
    }
    if (*url == '/') {
      break;
    }
    if (*url == '@') {
      auth_sep_pos = addr_len;
      user_sep_pos = port_pos;
      port_pos = -1;
    }
    if (*url == ':') port_pos = addr_len;
    (*addr)[addr_len++] = *url;
    (*addr)[addr_len] = '\0';
    url++;
  }

  if (addr_len == 0) goto cleanup;
  if (port_pos < 0) {
    *port_i = addr_len;
    addr_len += sprintf(*addr + addr_len, ":%d", *use_ssl ? 443 : 80);
  } else {
    *port_i = -1;
  }

  if (*path == NULL) *path = url;

  if (**path == '\0') *path = "/";

  if (user != NULL && pass != NULL) {
    if (auth_sep_pos == -1) {
      *user = NULL;
      *pass = NULL;
    } else {
      /* user is from 0 to user_sep_pos */
      *user = (char *) MG_MALLOC(user_sep_pos + 1);
      memcpy(*user, *addr, user_sep_pos);
      (*user)[user_sep_pos] = '\0';
      /* pass is from user_sep_pos + 1 to auth_sep_pos */
      *pass = (char *) MG_MALLOC(auth_sep_pos - user_sep_pos - 1 + 1);
      memcpy(*pass, *addr + user_sep_pos + 1, auth_sep_pos - user_sep_pos - 1);
      (*pass)[auth_sep_pos - user_sep_pos - 1] = '\0';

      /* move address proper to the front */
      memmove(*addr, *addr + auth_sep_pos + 1, addr_len - auth_sep_pos);
    }
  }

  DBG(("%s %s", *addr, *path));

  return 0;

cleanup:
  MG_FREE(*addr);
  return -1;
}
