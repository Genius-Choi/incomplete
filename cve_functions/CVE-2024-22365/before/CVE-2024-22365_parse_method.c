static int parse_method(char *method, struct polydir_s *poly,
		struct instance_data *idata)
{
    enum polymethod pm;
    char *sptr = NULL;
    static const char *method_names[] = { "user", "context", "level", "tmpdir",
	"tmpfs", NULL };
    static const char *flag_names[] = { "create", "noinit", "iscript",
	"shared", "mntopts", NULL };
    static const unsigned int flag_values[] = { POLYDIR_CREATE, POLYDIR_NOINIT,
	POLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };
    int i;
    char *flag;

    method = strtok_r(method, ":", &sptr);
    pm = NONE;

    for (i = 0; method_names[i]; i++) {
	if (strcmp(method, method_names[i]) == 0) {
		pm = i + 1; /* 0 = NONE */
	}
    }

    if (pm == NONE) {
        pam_syslog(idata->pamh, LOG_NOTICE, "Unknown method");
        return -1;
    }

    poly->method = pm;

    while ((flag=strtok_r(NULL, ":", &sptr)) != NULL) {
	for (i = 0; flag_names[i]; i++) {
		size_t namelen = strlen(flag_names[i]);

		if (strncmp(flag, flag_names[i], namelen) == 0) {
			poly->flags |= flag_values[i];
			switch (flag_values[i]) {
			    case POLYDIR_CREATE:
				if (parse_create_params(flag+namelen, poly) != 0) {
				        pam_syslog(idata->pamh, LOG_CRIT, "Invalid create parameters");
					return -1;
				}
				break;

			    case POLYDIR_ISCRIPT:
				if (parse_iscript_params(flag+namelen, poly) != 0) {
				        pam_syslog(idata->pamh, LOG_CRIT, "Memory allocation error");
					return -1;
				};
				break;

			    case POLYDIR_MNTOPTS:
				if (flag[namelen] != '=')
					break;
				if (poly->method != TMPFS) {
					pam_syslog(idata->pamh, LOG_WARNING, "Mount options applicable only to tmpfs method");
					break;
				}
				free(poly->mount_opts); /* if duplicate mntopts specified */
				poly->mount_opts = NULL;
				if (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {
					pam_syslog(idata->pamh, LOG_CRIT, "Memory allocation error");
					return -1;
				}
				break;
			}
		}
	}
    }

    return 0;
}
