int pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,
                                    int argc, const char **argv)
{
    int i, retval;
    struct instance_data idata;
    const void *polyptr;

    /* init instance data */
    idata.flags = 0;
    idata.polydirs_ptr = NULL;
    idata.pamh = pamh;
#ifdef WITH_SELINUX
    if (is_selinux_enabled())
        idata.flags |= PAMNS_SELINUX_ENABLED;
    if (ctxt_based_inst_needed())
        idata.flags |= PAMNS_CTXT_BASED_INST;
#endif

    /* Parse arguments. */
    for (i = 0; i < argc; i++) {
        if (strcmp(argv[i], "debug") == 0)
            idata.flags |= PAMNS_DEBUG;
        if (strcmp(argv[i], "ignore_config_error") == 0)
            idata.flags |= PAMNS_IGN_CONFIG_ERR;
        if (strcmp(argv[i], "unmount_on_close") == 0)
            idata.flags |= PAMNS_UNMOUNT_ON_CLOSE;
    }

    if (idata.flags & PAMNS_DEBUG)
        pam_syslog(idata.pamh, LOG_DEBUG, "close_session - start");

    /*
     * Normally the unmount is implicitly done when the last
     * process in the private namespace exits.
     * If it is ensured that there are no child processes left in
     * the private namespace by other means and if there are
     * multiple sessions opened and closed sequentially by the
     * same process, the "unmount_on_close" option might be
     * used to unmount the polydirs explicitly.
     */
    if (!(idata.flags & PAMNS_UNMOUNT_ON_CLOSE)) {
	pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);
	pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);

	if (idata.flags & PAMNS_DEBUG)
	    pam_syslog(idata.pamh, LOG_DEBUG, "close_session - successful");
        return PAM_SUCCESS;
    }

    retval = get_user_data(&idata);
    if (retval != PAM_SUCCESS)
	return retval;

    retval = pam_get_data(idata.pamh, NAMESPACE_POLYDIR_DATA, &polyptr);
    if (retval != PAM_SUCCESS || polyptr == NULL)
	/* nothing to reset */
	return PAM_SUCCESS;

    DIAG_PUSH_IGNORE_CAST_QUAL;
    idata.polydirs_ptr = (void *)polyptr;
    DIAG_POP_IGNORE_CAST_QUAL;

    if (idata.flags & PAMNS_DEBUG)
        pam_syslog(idata.pamh, LOG_DEBUG, "Resetting namespace for pid %d",
		getpid());

    retval = orig_namespace(&idata);
    if (idata.flags & PAMNS_DEBUG) {
        if (retval)
            pam_syslog(idata.pamh, LOG_DEBUG,
		"resetting namespace failed for pid %d", getpid());
        else
            pam_syslog(idata.pamh, LOG_DEBUG,
		"resetting namespace ok for pid %d", getpid());
    }

    pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);
    pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);

    return PAM_SUCCESS;
}
