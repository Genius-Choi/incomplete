static ERL_NIF_TERM dss_verify(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{/* (DigestType,Data,Signature,Key=[P, Q, G, Y]) */
    ErlNifBinary data_bin, sign_bin;
    BIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_y = NULL;
    unsigned char hmacbuf[SHA_DIGEST_LENGTH];
    ERL_NIF_TERM head, tail;
    DSA *dsa;
    int i;

    if (!inspect_mpint(env, argv[2], &sign_bin)
	|| !enif_get_list_cell(env, argv[3], &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa_p)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa_q)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa_g)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa_y)
	|| !enif_is_empty_list(env,tail)) {
    badarg:
	if (dsa_p) BN_free(dsa_p);
	if (dsa_q) BN_free(dsa_q);
	if (dsa_g) BN_free(dsa_g);
	if (dsa_y) BN_free(dsa_y);
	return enif_make_badarg(env);
    }
    if (argv[0] == atom_sha && inspect_mpint(env, argv[1], &data_bin)) {
	SHA1(data_bin.data+4, data_bin.size-4, hmacbuf);
    }
    else if (argv[0] == atom_none && enif_inspect_binary(env, argv[1], &data_bin)
	     && data_bin.size == SHA_DIGEST_LENGTH) {
	memcpy(hmacbuf, data_bin.data, SHA_DIGEST_LENGTH);
    }
    else {
	goto badarg;
    }

    dsa = DSA_new();
    dsa->p = dsa_p;
    dsa->q = dsa_q;
    dsa->g = dsa_g;
    dsa->priv_key = NULL;
    dsa->pub_key = dsa_y;
    i =  DSA_verify(0, hmacbuf, SHA_DIGEST_LENGTH,
		    sign_bin.data+4, sign_bin.size-4, dsa);
    DSA_free(dsa);
    return(i > 0) ? atom_true : atom_false;
}
