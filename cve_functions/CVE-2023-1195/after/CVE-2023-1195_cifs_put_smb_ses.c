void cifs_put_smb_ses(struct cifs_ses *ses)
{
	unsigned int rc, xid;
	unsigned int chan_count;
	struct TCP_Server_Info *server = ses->server;

	spin_lock(&ses->ses_lock);
	if (ses->ses_status == SES_EXITING) {
		spin_unlock(&ses->ses_lock);
		return;
	}
	spin_unlock(&ses->ses_lock);

	cifs_dbg(FYI, "%s: ses_count=%d\n", __func__, ses->ses_count);
	cifs_dbg(FYI,
		 "%s: ses ipc: %s\n", __func__, ses->tcon_ipc ? ses->tcon_ipc->tree_name : "NONE");

	spin_lock(&cifs_tcp_ses_lock);
	if (--ses->ses_count > 0) {
		spin_unlock(&cifs_tcp_ses_lock);
		return;
	}
	spin_unlock(&cifs_tcp_ses_lock);

	/* ses_count can never go negative */
	WARN_ON(ses->ses_count < 0);

	if (ses->ses_status == SES_GOOD)
		ses->ses_status = SES_EXITING;

	cifs_free_ipc(ses);

	if (ses->ses_status == SES_EXITING && server->ops->logoff) {
		xid = get_xid();
		rc = server->ops->logoff(xid, ses);
		if (rc)
			cifs_server_dbg(VFS, "%s: Session Logoff failure rc=%d\n",
				__func__, rc);
		_free_xid(xid);
	}

	spin_lock(&cifs_tcp_ses_lock);
	list_del_init(&ses->smb_ses_list);
	spin_unlock(&cifs_tcp_ses_lock);

	chan_count = ses->chan_count;

	/* close any extra channels */
	if (chan_count > 1) {
		int i;

		for (i = 1; i < chan_count; i++) {
			if (ses->chans[i].iface) {
				kref_put(&ses->chans[i].iface->refcount, release_iface);
				ses->chans[i].iface = NULL;
			}
			cifs_put_tcp_session(ses->chans[i].server, 0);
			ses->chans[i].server = NULL;
		}
	}

	sesInfoFree(ses);
	cifs_put_tcp_session(server, 0);
}
