static int is_path_remote(struct mount_ctx *mnt_ctx)
{
	int rc;
	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
	struct TCP_Server_Info *server = mnt_ctx->server;
	unsigned int xid = mnt_ctx->xid;
	struct cifs_tcon *tcon = mnt_ctx->tcon;
	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
	char *full_path;
#ifdef CONFIG_CIFS_DFS_UPCALL
	bool nodfs = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS;
#endif

	if (!server->ops->is_path_accessible)
		return -EOPNOTSUPP;

	/*
	 * cifs_build_path_to_root works only when we have a valid tcon
	 */
	full_path = cifs_build_path_to_root(ctx, cifs_sb, tcon,
					    tcon->Flags & SMB_SHARE_IS_IN_DFS);
	if (full_path == NULL)
		return -ENOMEM;

	cifs_dbg(FYI, "%s: full_path: %s\n", __func__, full_path);

	rc = server->ops->is_path_accessible(xid, tcon, cifs_sb,
					     full_path);
#ifdef CONFIG_CIFS_DFS_UPCALL
	if (nodfs) {
		if (rc == -EREMOTE)
			rc = -EOPNOTSUPP;
		goto out;
	}

	/* path *might* exist with non-ASCII characters in DFS root
	 * try again with full path (only if nodfs is not set) */
	if (rc == -ENOENT && is_tcon_dfs(tcon))
		rc = cifs_dfs_query_info_nonascii_quirk(xid, tcon, cifs_sb,
							full_path);
#endif
	if (rc != 0 && rc != -EREMOTE)
		goto out;

	if (rc != -EREMOTE) {
		rc = cifs_are_all_path_components_accessible(server, xid, tcon,
			cifs_sb, full_path, tcon->Flags & SMB_SHARE_IS_IN_DFS);
		if (rc != 0) {
			cifs_server_dbg(VFS, "cannot query dirs between root and final path, enabling CIFS_MOUNT_USE_PREFIX_PATH\n");
			cifs_sb->mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;
			rc = 0;
		}
	}

out:
	kfree(full_path);
	return rc;
}
