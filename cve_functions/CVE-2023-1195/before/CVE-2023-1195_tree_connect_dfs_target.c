static int tree_connect_dfs_target(const unsigned int xid, struct cifs_tcon *tcon,
				   struct cifs_sb_info *cifs_sb, char *tree, bool islink,
				   struct dfs_cache_tgt_list *tl)
{
	int rc;
	int num_links = 0;
	struct TCP_Server_Info *server = tcon->ses->server;

	do {
		rc = __tree_connect_dfs_target(xid, tcon, cifs_sb, tree, islink, tl);
		if (!rc || rc != -EREMOTE)
			break;
	} while (rc = -ELOOP, ++num_links < MAX_NESTED_LINKS);
	/*
	 * If we couldn't tree connect to any targets from last referral path, then retry from
	 * original referral path.
	 */
	if (rc && server->current_fullpath != server->origin_fullpath) {
		server->current_fullpath = server->origin_fullpath;
		cifs_signal_cifsd_for_reconnect(server, true);
	}

	dfs_cache_free_tgts(tl);
	return rc;
}
