int ntlm_encode_chal_msg(struct ntlm_ctx *ctx,
                         uint32_t flags,
                         const char *target_name,
                         struct ntlm_buffer *challenge,
                         struct ntlm_buffer *target_info,
                         struct ntlm_buffer *message)
{
    struct wire_chal_msg *msg;
    struct ntlm_buffer buffer;
    size_t data_offs;
    size_t target_len = 0;
    int ret = 0;

    if (!ctx) return EINVAL;

    if (!challenge || challenge->length != 8) return EINVAL;

    buffer.length = sizeof(struct wire_chal_msg);

    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)
        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {
        if (!target_name) return EINVAL;

        target_len = strlen(target_name);
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            buffer.length += target_len * 2;
        } else {
            buffer.length += target_len;
        }
    }

    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {
        if (!target_info) return EINVAL;

        buffer.length += target_info->length;
    }

    buffer.data = calloc(1, buffer.length);
    if (!buffer.data) return ENOMEM;

    msg = (struct wire_chal_msg *)buffer.data;
    data_offs = (char *)msg->payload - (char *)msg;

    ntlm_encode_header(&msg->header, CHALLENGE_MESSAGE);

    /* this must be first as it pushes the payload further down */
    if (flags & NTLMSSP_NEGOTIATE_VERSION) {
        ret = ntlm_encode_version(ctx, &buffer,
                                  (char *)&msg->version - (char *)msg);
        if (ret) goto done;
    }

    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)
        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->target_name, &buffer,
                                           &data_offs, target_name, target_len);
        } else {
            ret = ntlm_encode_oem_str(&msg->target_name, &buffer,
                                      &data_offs, target_name, target_len);
        }
        if (ret) goto done;
    }

    msg->neg_flags = htole32(flags);
    memcpy(msg->server_challenge, challenge->data, 8);

    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {
        ret = ntlm_encode_field(&msg->target_info, &buffer,
                                &data_offs, target_info);
        if (ret) goto done;
    }

done:
    if (ret) {
        safefree(buffer.data);
    } else {
        *message = buffer;
    }
    return ret;
}
