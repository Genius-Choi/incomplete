void CoreUserInputHandler::handleDelkey(const BufferInfo &bufferInfo, const QString &msg)
{
    QString bufname = bufferInfo.bufferName().isNull() ? "" : bufferInfo.bufferName();
#ifdef HAVE_QCA2
    if (!bufferInfo.isValid())
        return;

    if (!Cipher::neededFeaturesAvailable()) {
        emit displayMsg(Message::Error, typeByTarget(bufname), bufname, tr("Error: QCA provider plugin not found. It is usually provided by the qca-ossl plugin."));
        return;
    }

    QStringList parms = msg.split(' ', QString::SkipEmptyParts);

    if (parms.isEmpty() && !bufferInfo.bufferName().isEmpty() && bufferInfo.acceptsRegularMessages())
        parms.prepend(bufferInfo.bufferName());

    if (parms.isEmpty()) {
        emit displayMsg(Message::Info, typeByTarget(bufname), bufname,
            tr("[usage] /delkey <nick|channel> deletes the encryption key for nick or channel or just /delkey when in a channel or query."));
        return;
    }

    QString target = parms.at(0);

    if (network()->cipherKey(target).isEmpty()) {
        emit displayMsg(Message::Info, typeByTarget(bufname), bufname, tr("No key has been set for %1.").arg(target));
        return;
    }

    network()->setCipherKey(target, QByteArray());
    emit displayMsg(Message::Info, typeByTarget(bufname), bufname, tr("The key for %1 has been deleted.").arg(target));

#else
    Q_UNUSED(msg)
    emit displayMsg(Message::Error, typeByTarget(bufname), bufname, tr("Error: Setting an encryption key requires Quassel to have been built "
                                                                    "with support for the Qt Cryptographic Architecture (QCA2) library. "
                                                                    "Contact your distributor about a Quassel package with QCA2 "
                                                                    "support, or rebuild Quassel with QCA2 present."));
#endif
}
