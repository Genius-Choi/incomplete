static pj_bool_t test_stun_on_status(pj_stun_sock *stun_sock, 
				     pj_stun_sock_op op,
				     pj_status_t status)
{
    pjsua_stun_resolve *sess;

    sess = (pjsua_stun_resolve*) pj_stun_sock_get_user_data(stun_sock);
    pj_assert(stun_sock == sess->stun_sock);

    if (status != PJ_SUCCESS) {
	char errmsg[PJ_ERR_MSG_SIZE];
	pj_strerror(status, errmsg, sizeof(errmsg));

	PJ_LOG(4,(THIS_FILE, "STUN resolution for %.*s failed: %s",
		  (int)sess->srv[sess->idx].slen,
		  sess->srv[sess->idx].ptr, errmsg));

	if (op == PJ_STUN_SOCK_BINDING_OP && !sess->async_wait) {
	    /* Just return here, we will destroy the STUN socket and
	     * continue the STUN resolution later in resolve_stun_entry().
	     * For more details, please refer to ticket #1962.
	     */
            return PJ_FALSE;
	}

	pj_stun_sock_destroy(stun_sock);
	sess->stun_sock = NULL;

	stun_resolve_add_ref(sess);

	if (pjsua_var.ua_cfg.stun_try_ipv6 && sess->af == pj_AF_INET()) {
	    sess->af = pj_AF_INET6();
	} else {
	    ++sess->idx;
	    sess->af = pj_AF_INET();
	    if (sess->idx >= sess->count)
                sess->status = status;
        }

	resolve_stun_entry(sess);

	stun_resolve_dec_ref(sess);

	return PJ_FALSE;

    } else if (op == PJ_STUN_SOCK_BINDING_OP) {
	pj_stun_sock_info ssi;

	pj_stun_sock_get_info(stun_sock, &ssi);
	pj_memcpy(&sess->addr, &ssi.srv_addr, sizeof(sess->addr));

	stun_resolve_add_ref(sess);

	sess->status = PJ_SUCCESS;
	pj_stun_sock_destroy(stun_sock);
	sess->stun_sock = NULL;

	stun_resolve_complete(sess);

	stun_resolve_dec_ref(sess);

	return PJ_FALSE;

    } else
	return PJ_TRUE;
    
}
