PJ_DEF(pj_status_t) pjsua_schedule_timer2_dbg( void (*cb)(void *user_data),
                                               void *user_data,
                                               unsigned msec_delay,
                                               const char *src_file,
                                               int src_line)
#else
PJ_DEF(pj_status_t) pjsua_schedule_timer2( void (*cb)(void *user_data),
                                           void *user_data,
                                           unsigned msec_delay)
#endif
{
    pjsua_timer_list *tmr = NULL;
    pj_status_t status;
    pj_time_val delay;

    pj_mutex_lock(pjsua_var.timer_mutex);

    if (pj_list_empty(&pjsua_var.timer_list)) {
        tmr = PJ_POOL_ALLOC_T(pjsua_var.timer_pool, pjsua_timer_list);
    } else {
        tmr = pjsua_var.timer_list.next;
        pj_list_erase(tmr);
    }
    pj_timer_entry_init(&tmr->entry, 0, tmr, timer_cb);
    tmr->cb = cb;
    tmr->user_data = user_data;
    delay.sec = 0;
    delay.msec = msec_delay;

#if PJ_TIMER_DEBUG
    status = pjsip_endpt_schedule_timer_dbg(pjsua_var.endpt, &tmr->entry,
                                            &delay, src_file, src_line);
#else
    status = pjsip_endpt_schedule_timer(pjsua_var.endpt, &tmr->entry, &delay);
#endif
    if (status == PJ_SUCCESS) {
    	pj_list_push_back(&pjsua_var.active_timer_list, tmr);
    } else {
        pj_list_push_back(&pjsua_var.timer_list, tmr);
    }

    pj_mutex_unlock(pjsua_var.timer_mutex);

    return status;
}
