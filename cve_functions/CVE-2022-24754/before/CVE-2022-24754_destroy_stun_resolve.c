static void destroy_stun_resolve(pjsua_stun_resolve *sess, pj_bool_t forced)
{
    pj_time_val timeout = {0, 0};

    if (sess->destroy_flag)
	return;

    sess->destroy_flag = PJ_TRUE;
    if (sess->stun_sock) {
        pj_stun_sock_destroy(sess->stun_sock);
        sess->stun_sock = NULL;
    }

    if (pjsua_var.stun_status == PJ_EUNKNOWN ||
    	pjsua_var.stun_status == PJ_EPENDING)
    {
        pjsua_var.stun_status = PJNATH_ESTUNDESTROYED;
    }

    if (forced) {
	release_stun_session(sess);
    } else {
	/* Schedule session clean up, it needs PJSUA lock and locking it here
	 * may cause deadlock as this function may be called by STUN socket
	 * while holding STUN socket lock, while application may wait for STUN
	 * resolution while holding PJSUA lock.
	 */
	pj_timer_entry_init(&sess->timer, 0, (void*)sess,
			    &destroy_stun_resolve_cb);
	pjsua_schedule_timer(&sess->timer, &timeout);
    }
}
