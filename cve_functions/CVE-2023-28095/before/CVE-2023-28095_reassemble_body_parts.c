void reassemble_body_parts( struct sip_msg* msg, char* new_buf,
						unsigned int* new_offs, unsigned int* orig_offs,
						struct socket_info* send_sock)
{
	struct body_part *part;
	struct lump* lump;
	unsigned int size;
	unsigned int offset;
	int padding=0;

	if (msg->body->updated_part_count==0) {

		/* no body to be placed in the new msg !
		 * simply skip the entire body */
		LM_DBG("no part to be added\n");

	} else if (msg->body->updated_part_count==1) {

		/* there is only one part to be added, so iterate
		 * and find it */
		LM_DBG("only one part to be added\n");

		for( part=&msg->body->first ; part ; part=part->next)
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;

		if (part==NULL) {
			LM_BUG("updated count is 1, but no non-deleted part found :-/\n");
			return;
		}

		LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n",
			part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

		/* handle the special case of preserving a single part which was
		 * received packed as multipart -> copy the boundries as
		 * received */
		if ( msg->body->flags & SIP_BODY_RCV_MULTIPART &&
		msg->body->part_count==1 &&
		(part->flags & SIP_BODY_PART_FLAG_NEW)==0 ) {
			/* copy whatever is between the beginning of the msg body 
			 * and the part body*/
			memcpy(new_buf+*new_offs, msg->body->body.s,
				part->body.s-msg->body->body.s );
			*new_offs += part->body.s-msg->body->body.s;
			padding = 1;
		}

		if (part->dump_f) {
			/* the dump function was triggered when the length was computed
			 * and the resulting buffer was linked as 'dump' (and we need
			 * to free it now) */
			/* copy the new body of the part */
			memcpy(new_buf+*new_offs, part->dump.s, part->dump.len );
			*new_offs += part->dump.len;
			pkg_free(part->dump.s);
			part->dump.s = NULL;
			part->dump.len = 0;
		} else {
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				/* simply copy the body of the part */
				memcpy(new_buf+*new_offs, part->body.s, part->body.len );
				*new_offs += part->body.len;
			} else {
				/* this is one part that was received (so potentially
				 * modified during runtime) -> apply all body lumps
				 * inside this part */
				*orig_offs = part->body.s - msg->buf;
				lump = msg->body_lumps;
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					/* apply the lumps */
					process_lumps( msg, lump, new_buf, new_offs, orig_offs,
						send_sock, part->body.s+part->body.len-msg->buf);
				}
				/* and copy whatever is left, all the way to the end of part */
				size = (part->body.s+part->body.len-msg->buf)-*orig_offs;
				memcpy(new_buf+*new_offs, msg->buf+*orig_offs, size);
				*new_offs += size;
			}
		}

		if (padding) {
			/* copy whatever is between the end of the part body 
			 * and the end of the msg body*/
			memcpy(new_buf+*new_offs, part->body.s+part->body.len,
				(msg->body->body.s+msg->body->body.len)-
				(part->body.s+part->body.len) );
			*new_offs += (msg->body->body.s+msg->body->body.len)-
				(part->body.s+part->body.len);
		}

	} else if (msg->body->part_count<2) {

		/* transition from 0/1 to multiple parts,
		 * so we need to add boundries */

		LM_DBG("transition from 0/1 parts to multi part body\n");
		offset = *new_offs;
		lump = msg->body_lumps;

		for( part=&msg->body->first ; part ; part=part->next) {

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n",
				part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			/* skip deleted parts */
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
					/* reposition at the end of the skipped body */
					*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			/* separator and CT header */
			memcpy(new_buf+offset, "--" OSS_BOUNDARY CRLF "Content-Type: ",
				2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14);
			offset += 2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14;
			memcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);
			offset += part->mime_s.len;
			if (part->headers.len==0) {
				memcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);
				offset += CRLF_LEN + CRLF_LEN ;
			} else {
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
				memcpy(new_buf+offset, part->headers.s , part->headers.len);
				offset += part->headers.len ;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			}

			/* part with dump function ? */
			if (part->dump_f) {
				memcpy(new_buf+offset, part->dump.s, part->dump.len );
				offset += part->dump.len;
				pkg_free(part->dump.s);
				part->dump.s = NULL;
				part->dump.len = 0;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else
			/* new part with body attached */
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				/* simpy copy the body of the part */
				memcpy(new_buf+offset, part->body.s, part->body.len );
				offset += part->body.len;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else
			/* old part with lumps */
			{
				/* first find the first lump inside our body part */
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					/* apply the lumps */
					process_lumps( msg, lump, new_buf, &offset, orig_offs,
						send_sock, part->body.s+part->body.len-msg->buf);
				}
				/* and copy whatever is left, all the way to the end of part */
				size = (part->body.s+part->body.len-msg->buf)-*orig_offs;
				memcpy(new_buf+offset, msg->buf+*orig_offs, size);
				offset += size;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			}

			/* reposition at the end of the processed body */
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN ;

		} /* end for(over the parts) */

		/* the final separator */
		memcpy(new_buf+offset, "--" OSS_BOUNDARY "--" CRLF,
			2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN);
		offset += 2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN;

		/*done here !!*/
		*new_offs = offset;

	} else {

		/* multi to multi parts - iterate the list, handle insert new parts,
		 * remove old ones, and modify the kept ones (if the case) */
		LM_DBG("multi to multi part body reconstruction\n");

		offset = *new_offs;
		lump = msg->body_lumps;
		for( part=&msg->body->first ; part ; part=part->next) {
			/* skip deleted parts */
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )
					/* reposition at the end of the skipped body */
					*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n",
				part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			/* new part ? */
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				/* separator and CT header */
				memcpy(new_buf+offset, "--" , 2);
				offset += 2;
				memcpy(new_buf+offset, msg->body->boundary.s , msg->body->boundary.len);
				offset += msg->body->boundary.len;
				memcpy(new_buf+offset, CRLF "Content-Type: " , CRLF_LEN+14);
				offset += CRLF_LEN + 14 ;
				memcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);
				offset += part->mime_s.len;
				if (part->headers.len==0) {
					memcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);
					offset += CRLF_LEN + CRLF_LEN ;
				} else {
					memcpy(new_buf+offset, CRLF , CRLF_LEN);
					offset += CRLF_LEN;
					memcpy(new_buf+offset, part->headers.s , part->headers.len);
					offset += part->headers.len ;
					memcpy(new_buf+offset, CRLF , CRLF_LEN);
					offset += CRLF_LEN;
				}
				/* simply copy the body of the part */
				if (part->dump_f) {
					memcpy(new_buf+offset, part->dump.s, part->dump.len );
					offset += part->dump.len;
					part->dump.s = NULL;
					part->dump.len = 0;
				} else {
					memcpy(new_buf+offset, part->body.s, part->body.len );
					offset += part->body.len;
				}
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else
			/* old part with dump function */
			if (part->dump_f) {
				/* copy separator and headers from original message */
				size = (part->body.s - msg->buf) - *orig_offs;
				memcpy( new_buf+offset,  msg->buf+*orig_offs, size);
				offset += size;
				/* put in the new body */
				memcpy(new_buf+offset, part->dump.s, part->dump.len );
				offset += part->dump.len;
				pkg_free(part->dump.s);
				part->dump.s = NULL;
				part->dump.len = 0;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else
			/* old part with lumps -> apply changes */
			{
				/* first find the first lump inside our body part
				 * NOTE: we do not need to explicitly copy the separtor and
				 * the headers as they will be automatically got by the 
				 * first lup or by the final copy */
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					/* apply the lumps */
					process_lumps( msg, lump, new_buf, &offset, orig_offs,
						send_sock, part->body.s+part->body.len-msg->buf);
				}
				/* and copy whatever is left, all the way to the end of part,
				 * including the next CRLF */
				size = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-*orig_offs;
				memcpy(new_buf+offset, msg->buf+*orig_offs, size);
				offset += size;
			}

			/* reposition at the end of the processed body */
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;

		} /* end for(over the parts) */

		/* the final separator */
		size = msg->len - *orig_offs;
		memcpy(new_buf+offset, msg->buf+*orig_offs , size);
		*new_offs = offset + size;
		*orig_offs += size;

	}
	return;
}
