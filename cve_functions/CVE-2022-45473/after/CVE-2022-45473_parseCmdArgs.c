    bool DrachtioController::parseCmdArgs( int argc, char* argv[] ) {        
        int c ;
        string port ;
        string publicAddress ;
        string localNet ;
        string contact ;
        vector<string> vecDnsNames;
        string httpMethod = "GET";
        string httpUrl ;
        string method;

        while (1)
        {
            static struct option long_options[] =
            {
                /* These options set a flag. */
                {"daemon", no_argument,       &m_bDaemonize, true},
                {"noconfig", no_argument,       &m_bNoConfig, true},
                
                /* These options don't set a flag.
                 We distinguish them by their indices. */
                {"file",    required_argument, 0, 'f'},
                {"help",    no_argument, 0, 'h'},
                {"user",    required_argument, 0, 'u'},
                {"port",    required_argument, 0, 'p'},
                {"contact",    required_argument, 0, 'c'},
                {"external-ip",    required_argument, 0, 'x'},
                {"local-net",    required_argument, 0, 'n'},
                {"dns-name",    required_argument, 0, 'd'},
                {"http-handler",    required_argument, 0, 'a'},
                {"http-method",    required_argument, 0, 'm'},
                {"loglevel",    required_argument, 0, 'l'},
                {"sofia-loglevel",    required_argument, 0, 's'},
                {"stdout",    no_argument, 0, 'b'},
                {"homer",    required_argument, 0, 'y'},
                {"homer-id",    required_argument, 0, 'z'},
                {"key-file", required_argument, 0, 'A'},
                {"cert-file", required_argument, 0, 'B'},
                {"chain-file", required_argument, 0, 'C'},
                {"mtu", required_argument, 0, 'D'},
                {"address", required_argument, 0, 'E'},
                {"secret", required_argument, 0, 'F'},
                {"dh-param", required_argument, 0, 'G'},
                {"tls-port",    required_argument, 0, 'H'},
                {"aggressive-nat-detection", no_argument, 0, 'I'},
                {"prometheus-scrape-port", required_argument, 0, 'J'},
                {"memory-debug", no_argument, 0, 'K'},
                {"tcp-keepalive-interval", required_argument, 0, 'L'},
                {"min-tls-version", required_argument, 0, 'M'},
                {"disable-nat-detection", no_argument, 0, 'N'},
                {"blacklist-redis-address", required_argument, 0, 'O'},
                {"blacklist-redis-port", required_argument, 0, 'P'},
                {"blacklist-redis-key", required_argument, 0, 'Q'},
                {"blacklist-refresh-secs", required_argument, 0, 'R'},
                {"always-send-180", no_argument, 0, 'S'},
                {"user-agent-options-auto-respond", no_argument, 0, 'T'},
                {"version",    no_argument, 0, 'v'},
                {0, 0, 0, 0}
            };
            /* getopt_long stores the option index here. */
            int option_index = 0;
            
            c = getopt_long (argc, argv, "a:c:f:hi:l:m:p:n:u:vx:y:z:A:B:C:D:E:F:G:I",
                             long_options, &option_index);
            
            /* Detect the end of the options. */
            if (c == -1)
                break;
            
            switch (c)
            {
                case 0:
                    /* If this option set a flag, do nothing else now. */
                    if (long_options[option_index].flag != 0)
                        break;
                    cout << "option " << long_options[option_index].name ;
                    if (optarg)
                        cout << " with arg " << optarg;
                    cout << endl ;
                    break;
                case 'A':
                    m_tlsKeyFile = optarg;
                    break;
                case 'B':
                    m_tlsCertFile = optarg;
                    break;
                case 'C':
                    m_tlsChainFile = optarg;
                    break;
                case 'D':
                    m_mtu = ::atoi(optarg);
                    break;
                case 'E':
                    m_adminAddress = optarg;
                    break;
                case 'F':
                    m_secret = optarg;
                    break;
                case 'G':
                    m_dhParam = optarg;
                    break;
                case 'a':
                    httpUrl = optarg ;
                    break;

                case 'b':
                    m_bConsoleLogging = true ;
                    break;

                case 'd':
                    vecDnsNames.push_back(optarg);
                    break;

                case 'f':
                    m_configFilename = optarg ;
                    break;

                case 'h':
                    usage() ;
                    exit(0);

                case 'l':
                    if( 0 == strcmp(optarg, "notice") ) m_current_severity_threshold = log_notice ;
                    else if( 0 == strcmp(optarg,"error") ) m_current_severity_threshold = log_error ;
                    else if( 0 == strcmp(optarg,"warning") ) m_current_severity_threshold = log_warning ;
                    else if( 0 == strcmp(optarg,"info") ) m_current_severity_threshold = log_info ;
                    else if( 0 == strcmp(optarg,"debug") ) m_current_severity_threshold = log_debug ;
                    else {
                        cerr << "Invalid loglevel '" << optarg << "': valid choices are notice, error, warning, info, debug" << endl ; 
                        return false ;
                    }

                    break;

                case 'm':
                    method = optarg ;
                    if( boost::iequals(method, "POST")) {
                      httpMethod = "POST";
                    }
                    break;

                case 's':
                    m_nSofiaLoglevel = atoi( optarg ) ;
                    if( m_nSofiaLoglevel < 0 || m_nSofiaLoglevel > 9 ) {
                        cerr << "Invalid sofia-loglevel '" << optarg << "': valid choices 0-9 inclusive" << endl ; 
                        return false ;                        
                    }

                    break;

                case 'u':
                    m_user = optarg ;
                    break;

                case 'c':
                    if( !contact.empty() ) {
                        m_vecTransports.push_back( std::make_shared<SipTransport>(contact, localNet, publicAddress )) ;
                        contact.clear() ;
                        publicAddress.clear() ;
                        localNet.clear() ;
                    }
                    contact = optarg ;
                    break;
                                    
                case 'x': 
                    if( contact.empty() ) {
                        cerr << "'public-ip' argument must follow a 'contact'" << endl ;
                        return false ;
                    }
                    if (!publicAddress.empty() ) {
                        cerr << "multiple 'public-ip' arguments provided for a single contact" << endl ;
                        return false ;
                    }
                    publicAddress = optarg ;
                    break ;

                case 'n':
                    if( contact.empty() ) {
                        cerr << "'local-net' argument must follow a 'contact'" << endl ;
                        return false ;
                    }
                    if (!localNet.empty() ) {
                        cerr << "multiple 'local-net' arguments provided for a single contact" << endl ;
                        return false ;
                    }
                    localNet = optarg ;
                    break ;

                case 'p':
                    port = optarg ;
                    m_adminTcpPort = ::atoi( port.c_str() ) ;
                    break;

                case 'H':
                    port = optarg ;
                    m_adminTlsPort = ::atoi( port.c_str() ) ;
                    break;

                case 'y':
                    {
                        m_nHomerPort = DEFAULT_HOMER_PORT;
                        vector<string>strs;
                        boost::split(strs, optarg, boost::is_any_of(":"));
                        if(strs.size() > 2) {
                            cerr << "invalid homer address: " << optarg << endl ;
                            return false ;
                        }
                        m_strHomerAddress = strs[0];
                        if( 2 == strs.size()) m_nHomerPort = boost::lexical_cast<uint32_t>(strs[1]);
                    }
                    break;

                case 'z':
                    try {
                        m_nHomerId = boost::lexical_cast<uint32_t>(optarg);
                    } catch(boost::bad_lexical_cast& err) {
                        cerr << "--homer-id must be a positive 32-bit integer" << endl;
                        return false;
                    }
                    if(0 == m_nHomerId) {
                        cerr << "--homer-id must be a positive 32-bit integer" << endl;
                        return false;                        
                    }
                    break;
                case 'I':
                    m_bAggressiveNatDetection = true;
                    break;

                case 'J':
                    {
                        vector<string>strs;
                        boost::split(strs, optarg, boost::is_any_of(":"));
                        if(strs.size() == 2) {
                            m_strPrometheusAddress = strs[0];
                            m_nPrometheusPort = boost::lexical_cast<uint32_t>(strs[1]);
                        }
                        else {
                            m_nPrometheusPort = boost::lexical_cast<uint32_t>(optarg); 
                        }
                    }
                    break;

                case 'K':
                    m_bMemoryDebug = true;
                    break;

                case 'L':
                    m_tcpKeepaliveSecs = ::atoi(optarg);
                    break;

                case 'M':
                    m_minTlsVersion = ::atof(optarg);
                    break;

                case 'N':
                    m_bDisableNatDetection = true;
                    break;
                case 'O':
                    m_redisAddress = optarg;
                    break;
                case 'P':
                    m_redisPort = ::atoi(optarg);
                    break;
                case 'Q':
                    m_redisKey = optarg;
                    break;
                case 'R':
                    m_redisRefreshSecs = ::atoi(optarg);
                    break;
                case 'S':
                    m_bAlwaysSend180 = true;
                    break;
                case 'T':
                    m_strUserAgentAutoAnswerOptions = optarg;
                    break;
                case 'v':
                    cout << DRACHTIO_VERSION << endl ;
                    exit(0) ;
                                                            
                case '?':
                    /* getopt_long already printed an error message. */
                    break;
                    
                default:
                    abort ();
            }
        }

        if(!m_strHomerAddress.empty() && 0 == m_nHomerId) {
            cerr << "--homer-id is required to specify an agent id when using --homer" << endl;
            return false;
        }

        if( !contact.empty() ) {
          std::shared_ptr<SipTransport> p = std::make_shared<SipTransport>(contact, localNet, publicAddress);
          for( std::vector<string>::const_iterator it = vecDnsNames.begin(); it != vecDnsNames.end(); ++it) {
            p->addDnsName(*it);
          }
          m_vecTransports.push_back(p) ;
        }

        if (!m_redisAddress.empty()) {
            if (0 == m_redisPort) m_redisPort = 6379;
            if (0 == m_redisRefreshSecs) m_redisRefreshSecs = 300;
        }

        if( !httpUrl.empty() ) {
          m_requestRouter.addRoute("*", httpMethod, httpUrl, true);
        }

        /* Print any remaining command line arguments (not options). */
        if (optind < argc)
        {
            cout << "non-option ARGV-elements: ";
            while (optind < argc)
                cout << argv[optind++] ;
        }
                
        return true ;
    }
