ipf_set_min_frag(struct ipf *ipf, bool v6, uint32_t value)
{
    /* If the user specifies an unreasonably large number, fragmentation
     * will not work well but it will not blow up. */
    if (value < (v6 ? IPF_V6_FRAG_SIZE_LBOUND :  IPF_V4_FRAG_SIZE_LBOUND)) {
        return 1;
    }

    ovs_mutex_lock(&ipf->ipf_lock);
    if (v6) {
        atomic_store_relaxed(&ipf->min_v6_frag_size, value);
    } else {
        atomic_store_relaxed(&ipf->min_v4_frag_size, value);
        ipf->max_v4_frag_list_size = DIV_ROUND_UP(
            IPV4_PACKET_MAX_SIZE - IPV4_PACKET_MAX_HDR_SIZE,
            ipf->min_v4_frag_size - IPV4_PACKET_MAX_HDR_SIZE);
    }
    ovs_mutex_unlock(&ipf->ipf_lock);
    return 0;
}
