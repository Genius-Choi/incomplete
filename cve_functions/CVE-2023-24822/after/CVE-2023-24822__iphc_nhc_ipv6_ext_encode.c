static ssize_t _iphc_nhc_ipv6_ext_encode(uint8_t *nhc_data,
                                        const gnrc_pktsnip_t *ext,
                                        uint16_t ext_len,
                                        uint8_t *protnum)
{
    const ipv6_ext_t *ext_hdr = ext->data;
    size_t nhc_len = 1; /* skip over NHC header */
    uint8_t nh = ext_hdr->nh;

    /* From https://tools.ietf.org/html/rfc6282#section-4.1:
     * > The Length field contained in a compressed IPv6 Extension Header
     * > indicates the number of octets that pertain to the (compressed)
     * > extension header following the Length field.
     *
     * ipv6_ext_t is nh + length field so subtract it
     */
    ext_len -= sizeof(ipv6_ext_t);
    if (ext_len > UINT8_MAX) {
        /* From https://tools.ietf.org/html/rfc6282#section-4.1:
         * > Note that specifying units in octets means that LOWPAN_NHC MUST NOT
         * > be used to encode IPv6 Extension Headers that have more than 255
         * > octets following the Length field after compression. */
        return 0;
    }
    /* Set IPv6 extension compression header type
     * (see https://tools.ietf.org/html/rfc6282#section-4.2). */
    nhc_data[0] = NHC_IPV6_EXT_ID;
    switch (*protnum) {
        case PROTNUM_IPV6_EXT_HOPOPT:
            nhc_data[0] |= NHC_IPV6_EXT_EID_HOPOPT;
            /* TODO: decrement ext_len by length of trailing Pad1/PadN option:
             * > IPv6 Hop-by-Hop and Destination Options Headers may use a trailing
             * > Pad1 or PadN to achieve 8-octet alignment.  When there is a single
             * > trailing Pad1 or PadN option of 7 octets or less and the containing
             * > header is a multiple of 8 octets, the trailing Pad1 or PadN option
             * > MAY be elided by the compressor. */
            break;
        case PROTNUM_IPV6_EXT_RH:
            nhc_data[0] |= NHC_IPV6_EXT_EID_RH;
            break;
        case PROTNUM_IPV6_EXT_FRAG:
            nhc_data[0] |= NHC_IPV6_EXT_EID_FRAG;
            break;
        case PROTNUM_IPV6_EXT_DST:
            nhc_data[0] |= NHC_IPV6_EXT_EID_DST;
            /* TODO: decrement ext_len by length of trailing Pad1/PadN option:
             * > IPv6 Hop-by-Hop and Destination Options Headers may use a trailing
             * > Pad1 or PadN to achieve 8-octet alignment.  When there is a single
             * > trailing Pad1 or PadN option of 7 octets or less and the containing
             * > header is a multiple of 8 octets, the trailing Pad1 or PadN option
             * > MAY be elided by the compressor. */
            break;
        case PROTNUM_IPV6_EXT_MOB:
            nhc_data[0] |= NHC_IPV6_EXT_EID_MOB;
            break;
        default:
            return -1;
    }
    if (_compressible_nh(nh) &&
        /* carry next header inline when fragment header and offset is equal to
         * 0 (which means the next header indicates the next header after the
         * fragment header in the *first fragment*) */
        ((*protnum != PROTNUM_IPV6_EXT_FRAG) ||
         (ipv6_ext_frag_get_offset((ipv6_ext_frag_t *)ext_hdr) == 0))) {
        nhc_data[0] |= NHC_IPV6_EXT_NH;
    }
    else {
        nhc_data[nhc_len++] = ext_hdr->nh;
        /* prevent next header from being encoded regardless (e.g. if not
         * first IPv6 fragment) */
        nh = PROTNUM_RESERVED;
    }
    /* integer overflow prevented by `ext_len > UINT8_MAX` check above */
    nhc_data[nhc_len++] = (uint8_t)ext_len;
    memcpy(&nhc_data[nhc_len], ext_hdr + 1, ext_len);
    *protnum = nh;
    return nhc_len + ext_len;
}
