pci_emul_diow(struct vmctx *ctx, int vcpu, struct pci_vdev *dev, int baridx,
	      uint64_t offset, int size, uint64_t value)
{
	int i;
	void *offset_ptr;
	struct pci_emul_dummy *dummy = dev->arg;

	if (baridx == 0) {
		if (offset + size > DIOSZ) {
			printf("diow: iow too large, offset %ld size %d\n",
			       offset, size);
			return;
		}

		offset_ptr = (void *) &dummy->ioregs[offset];
		if (size == 1)
			*(uint8_t *)offset_ptr = value & 0xff;
		else if (size == 2)
			*(uint16_t *)offset_ptr = value & 0xffff;
		else if (size == 4)
			*(uint32_t *)offset = value;
		else
			printf("diow: iow unknown size %d\n", size);

		/*
		 * Special magic value to generate an interrupt
		 */
		if (offset == 4 && size == 4 && pci_msi_enabled(dev))
			pci_generate_msi(dev, value % pci_msi_maxmsgnum(dev));

		if (value == 0xabcdef) {
			for (i = 0; i < pci_msi_maxmsgnum(dev); i++)
				pci_generate_msi(dev, i);
		}
	}

	if (baridx == 1 || baridx == 2) {
		if (offset + size > DMEMSZ) {
			printf("diow: memw too large, offset %ld size %d\n",
			       offset, size);
			return;
		}

		i = baridx - 1;		/* 'memregs' index */

		offset_ptr = (void *) &dummy->memregs[i][offset];
		if (size == 1)
			*(uint8_t *)offset_ptr = value;
		else if (size == 2)
			*(uint16_t *)offset_ptr = value;
		else if (size == 4)
			*(uint32_t *)offset_ptr = value;
		else if (size == 8)
			*(uint64_t *)offset_ptr = value;
		else
			printf("diow: memw unknown size %d\n", size);

		/*
		 * magic interrupt ??
		 */
	}

	if (baridx > 2 || baridx < 0)
		printf("diow: unknown bar idx %d\n", baridx);
}
