repeated_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,
			      unsigned count, const void *member,
			      ProtobufCBuffer *buffer)
{
	char *array = *(char * const *) member;

	if (count == 0)
		return 0;
	if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
		uint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];
		size_t rv = tag_pack(field->id, scratch);
		size_t payload_len = get_packed_payload_length(field, count, array);
		size_t tmp;

		scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
		rv += uint32_pack(payload_len, scratch + rv);
		buffer->append(buffer, rv, scratch);
		tmp = pack_buffer_packed_payload(field, count, array, buffer);
		assert(tmp == payload_len);
		return rv + payload_len;
	} else {
		size_t siz;
		unsigned i;
		/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */
		unsigned rv = 0;

		siz = sizeof_elt_in_repeated_array(field->type);
		for (i = 0; i < count; i++) {
			rv += required_field_pack_to_buffer(field, array, buffer);
			array += siz;
		}
		return rv;
	}
}
