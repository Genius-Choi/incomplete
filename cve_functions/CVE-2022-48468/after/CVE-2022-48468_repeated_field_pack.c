repeated_field_pack(const ProtobufCFieldDescriptor *field,
		    size_t count, const void *member, uint8_t *out)
{
	void *array = *(void * const *) member;
	unsigned i;

	if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
		unsigned header_len;
		unsigned len_start;
		unsigned min_length;
		unsigned payload_len;
		unsigned length_size_min;
		unsigned actual_length_size;
		uint8_t *payload_at;

		if (count == 0)
			return 0;
		header_len = tag_pack(field->id, out);
		out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
		len_start = header_len;
		min_length = get_type_min_size(field->type) * count;
		length_size_min = uint32_size(min_length);
		header_len += length_size_min;
		payload_at = out + header_len;

		switch (field->type) {
		case PROTOBUF_C_TYPE_SFIXED32:
		case PROTOBUF_C_TYPE_FIXED32:
		case PROTOBUF_C_TYPE_FLOAT:
			copy_to_little_endian_32(payload_at, array, count);
			payload_at += count * 4;
			break;
		case PROTOBUF_C_TYPE_SFIXED64:
		case PROTOBUF_C_TYPE_FIXED64:
		case PROTOBUF_C_TYPE_DOUBLE:
			copy_to_little_endian_64(payload_at, array, count);
			payload_at += count * 8;
			break;
		case PROTOBUF_C_TYPE_ENUM:
		case PROTOBUF_C_TYPE_INT32: {
			const int32_t *arr = (const int32_t *) array;
			for (i = 0; i < count; i++)
				payload_at += int32_pack(arr[i], payload_at);
			break;
		}
		case PROTOBUF_C_TYPE_SINT32: {
			const int32_t *arr = (const int32_t *) array;
			for (i = 0; i < count; i++)
				payload_at += sint32_pack(arr[i], payload_at);
			break;
		}
		case PROTOBUF_C_TYPE_SINT64: {
			const int64_t *arr = (const int64_t *) array;
			for (i = 0; i < count; i++)
				payload_at += sint64_pack(arr[i], payload_at);
			break;
		}
		case PROTOBUF_C_TYPE_UINT32: {
			const uint32_t *arr = (const uint32_t *) array;
			for (i = 0; i < count; i++)
				payload_at += uint32_pack(arr[i], payload_at);
			break;
		}
		case PROTOBUF_C_TYPE_INT64:
		case PROTOBUF_C_TYPE_UINT64: {
			const uint64_t *arr = (const uint64_t *) array;
			for (i = 0; i < count; i++)
				payload_at += uint64_pack(arr[i], payload_at);
			break;
		}
		case PROTOBUF_C_TYPE_BOOL: {
			const protobuf_c_boolean *arr = (const protobuf_c_boolean *) array;
			for (i = 0; i < count; i++)
				payload_at += boolean_pack(arr[i], payload_at);
			break;
		}
		default:
			PROTOBUF_C__ASSERT_NOT_REACHED();
		}

		payload_len = payload_at - (out + header_len);
		actual_length_size = uint32_size(payload_len);
		if (length_size_min != actual_length_size) {
			assert(actual_length_size == length_size_min + 1);
			memmove(out + header_len + 1, out + header_len,
				payload_len);
			header_len++;
		}
		uint32_pack(payload_len, out + len_start);
		return header_len + payload_len;
	} else {
		/* not "packed" cased */
		/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */
		size_t rv = 0;
		unsigned siz = sizeof_elt_in_repeated_array(field->type);

		for (i = 0; i < count; i++) {
			rv += required_field_pack(field, array, out + rv);
			array = (char *)array + siz;
		}
		return rv;
	}
}
