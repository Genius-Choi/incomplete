parse_oneof_member (ScannedMember *scanned_member,
		    void *member,
		    ProtobufCMessage *message,
		    ProtobufCAllocator *allocator)
{
	uint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, message,
					       scanned_member->field->quantifier_offset);

	/* If we have already parsed a member of this oneof, free it. */
	if (*oneof_case != 0) {
		const ProtobufCFieldDescriptor *old_field;
		size_t el_size;
		/* lookup field */
		int field_index =
			int_range_lookup(message->descriptor->n_field_ranges,
					 message->descriptor->field_ranges,
					 *oneof_case);
		if (field_index < 0)
			return FALSE;
		old_field = message->descriptor->fields + field_index;
		el_size = sizeof_elt_in_repeated_array(old_field->type);

		switch (old_field->type) {
	        case PROTOBUF_C_TYPE_STRING: {
			char **pstr = member;
			const char *def = old_field->default_value;
			if (*pstr != NULL && *pstr != def)
				do_free(allocator, *pstr);
			break;
	        }
		case PROTOBUF_C_TYPE_BYTES: {
			ProtobufCBinaryData *bd = member;
			const ProtobufCBinaryData *def_bd = old_field->default_value;
			if (bd->data != NULL &&
			   (def_bd == NULL || bd->data != def_bd->data))
			{
				do_free(allocator, bd->data);
			}
			break;
	        }
		case PROTOBUF_C_TYPE_MESSAGE: {
			ProtobufCMessage **pmessage = member;
			const ProtobufCMessage *def_mess = old_field->default_value;
			if (*pmessage != NULL && *pmessage != def_mess)
				protobuf_c_message_free_unpacked(*pmessage, allocator);
			break;
	        }
		default:
			break;
		}

		memset (member, 0, el_size);
	}
	if (!parse_required_member (scanned_member, member, allocator, TRUE))
		return FALSE;

	*oneof_case = scanned_member->tag;
	return TRUE;
}
