CK_RV token_specific_ecdh_pkcs_derive(STDLL_TokData_t *tokdata,
                                      CK_BYTE *priv_bytes,
                                      CK_ULONG priv_length,
                                      CK_BYTE *pub_bytes,
                                      CK_ULONG pub_length,
                                      CK_BYTE *secret_value,
                                      CK_ULONG *secret_value_len,
                                      CK_BYTE *oid, CK_ULONG oid_length)
{
    EC_KEY *ec_pub = NULL, *ec_priv = NULL;
    CK_ULONG privlen;
    int secret_len;
    CK_RV rc;

    UNUSED(tokdata);

    rc = make_ec_key_from_params(oid, oid_length, &ec_priv);
    if (rc != CKR_OK) {
        TRACE_DEVEL("make_ec_key_from_params failed\n");
        goto out;
    }

    rc = fill_ec_key_from_privkey(ec_priv, priv_bytes, priv_length);
    if (rc != CKR_OK) {
        TRACE_DEVEL("fill_ec_key_from_privkey failed\n");
        goto out;
    }

    rc = make_ec_key_from_params(oid, oid_length, &ec_pub);
    if (rc != CKR_OK) {
        TRACE_DEVEL("make_ec_key_from_params failed\n");
        goto out;
    }

    rc = fill_ec_key_from_pubkey(ec_pub, pub_bytes, pub_length, TRUE);
    if (rc != CKR_OK) {
        TRACE_DEVEL("fill_ec_key_from_pubkey failed\n");
        goto out;
    }

    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_priv)) + 7) / 8;

    secret_len = ECDH_compute_key(secret_value, privlen,
                                  EC_KEY_get0_public_key(ec_pub), ec_priv,
                                  NULL);
    if (secret_len <= 0) {
        TRACE_DEVEL("ECDH_compute_key failed\n");
        rc = CKR_FUNCTION_FAILED;
        *secret_value_len = 0;
        goto out;
    }

    *secret_value_len = secret_len;

out:
    if (ec_priv != NULL)
        EC_KEY_free(ec_priv);
    if (ec_pub != NULL)
        EC_KEY_free(ec_pub);

    return rc;
}
