static int codec_prefs_handler(const struct aco_option *opt,
	struct ast_variable *var, void *obj)
{
	struct ast_sip_endpoint *endpoint = obj;
	struct ast_stream_codec_negotiation_prefs *option_prefs;
	struct ast_stream_codec_negotiation_prefs prefs;
	struct ast_str *error_message = ast_str_create(128);
	enum ast_stream_codec_negotiation_prefs_prefer_values default_prefer;
	enum ast_stream_codec_negotiation_prefs_operation_values default_operation;
	int res = 0;

	res = ast_stream_codec_prefs_parse(var->value, &prefs, &error_message);
	if (res < 0) {
		ast_log(LOG_ERROR, "Endpoint '%s': %s for option '%s'\n",
			ast_sorcery_object_get_id(endpoint), ast_str_buffer(error_message), var->name);
		ast_free(error_message);
		return -1;
	}
	ast_free(error_message);

	if (strcmp(var->name, "codec_prefs_incoming_offer") == 0) {
		if (prefs.operation == CODEC_NEGOTIATION_OPERATION_UNION) {
			ast_log(LOG_ERROR, "Endpoint '%s': Codec preference '%s' has invalid value '%s' for option: '%s'",
				ast_sorcery_object_get_id(endpoint),
				ast_stream_codec_param_to_str(CODEC_NEGOTIATION_PARAM_OPERATION),
				ast_stream_codec_operation_to_str(CODEC_NEGOTIATION_OPERATION_UNION),
				var->name);
			return -1;
		}
		option_prefs = &endpoint->media.codec_prefs_incoming_offer;
		default_prefer = CODEC_NEGOTIATION_PREFER_PENDING;
		default_operation = CODEC_NEGOTIATION_OPERATION_INTERSECT;
	} else if (strcmp(var->name, "codec_prefs_outgoing_offer") == 0) {
		option_prefs = &endpoint->media.codec_prefs_outgoing_offer;
		default_prefer = CODEC_NEGOTIATION_PREFER_PENDING;
		default_operation = CODEC_NEGOTIATION_OPERATION_UNION;
	} else if (strcmp(var->name, "codec_prefs_incoming_answer") == 0) {
		option_prefs = &endpoint->media.codec_prefs_incoming_answer;
		default_prefer = CODEC_NEGOTIATION_PREFER_PENDING;
		default_operation = CODEC_NEGOTIATION_OPERATION_INTERSECT;
	} else if (strcmp(var->name, "codec_prefs_outgoing_answer") == 0) {
		option_prefs = &endpoint->media.codec_prefs_outgoing_answer;
		default_prefer = CODEC_NEGOTIATION_PREFER_PENDING;
		default_operation = CODEC_NEGOTIATION_OPERATION_INTERSECT;
	} else {
		ast_log(LOG_ERROR, "Endpoint '%s': Unsupported option '%s'\n",
			ast_sorcery_object_get_id(endpoint),
			var->name);
		return -1;
	}

	if (prefs.prefer == CODEC_NEGOTIATION_PREFER_UNSPECIFIED) {
		prefs.prefer = default_prefer;
	}

	if (prefs.operation == CODEC_NEGOTIATION_OPERATION_UNSPECIFIED) {
		prefs.operation = default_operation;
	}

	if (prefs.keep == CODEC_NEGOTIATION_KEEP_UNSPECIFIED) {
		prefs.keep = CODEC_NEGOTIATION_KEEP_ALL;
	}

	if (prefs.transcode == CODEC_NEGOTIATION_TRANSCODE_UNSPECIFIED) {
		prefs.transcode = CODEC_NEGOTIATION_TRANSCODE_ALLOW;
	}

	/* Now that defaults have been applied as needed we apply the full codec
	 * preference configuration to the option.
	 */
	*option_prefs = prefs;

	return 0;
}
