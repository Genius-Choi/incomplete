static void PrefsSubSetDlg(CharView *cv,char* windowTitle,struct prefs_list* plist) {
    struct prefs_list* pl = plist;
    GRect pos;
    GWindow gw;
    GWindowAttrs wattrs;
    GGadgetCreateData *pgcd, gcd[20], sgcd[45], mgcd[3], mfgcd[9], msgcd[9];
    GGadgetCreateData mfboxes[3], *mfarray[14];
    GGadgetCreateData mpboxes[3];
    GGadgetCreateData sboxes[2];
    GGadgetCreateData mboxes[3], mboxes2[5], *varray[5], *harray[8];
    GTextInfo *plabel, label[20], slabel[45], mflabels[9], mslabels[9];
    GTabInfo aspects[TOPICS+5], subaspects[3];
    GGadgetCreateData **hvarray, boxes[2*TOPICS];
    struct pref_data p;
    int line = 0,line_max = 3;
    int i = 0, gc = 0, ii, y=0, si=0, k=0;
    char buf[20];
    char *tempstr;

    PrefsInit();
    MfArgsInit();

    line_max=0;
    for ( i=0, pl=plist; pl->name; ++i, ++pl ) {
	    ++line_max;
    }

    int itemCount = 100;
    pgcd = calloc(itemCount,sizeof(GGadgetCreateData));
    plabel = calloc(itemCount,sizeof(GTextInfo));
    hvarray = calloc((itemCount)*5,sizeof(GGadgetCreateData *));
    memset(&p,'\0',sizeof(p));
    memset(&wattrs,0,sizeof(wattrs));
    memset(sgcd,0,sizeof(sgcd));
    memset(slabel,0,sizeof(slabel));
    memset(&mfgcd,0,sizeof(mfgcd));
    memset(&msgcd,0,sizeof(msgcd));
    memset(&mflabels,0,sizeof(mflabels));
    memset(&mslabels,0,sizeof(mslabels));
    memset(&mfboxes,0,sizeof(mfboxes));
    memset(&mpboxes,0,sizeof(mpboxes));
    memset(&sboxes,0,sizeof(sboxes));
    memset(&boxes,0,sizeof(boxes));
    memset(&mgcd,0,sizeof(mgcd));
    memset(&mgcd,0,sizeof(mgcd));
    memset(&subaspects,'\0',sizeof(subaspects));
    memset(&label,0,sizeof(label));
    memset(&gcd,0,sizeof(gcd));
    memset(&aspects,'\0',sizeof(aspects));
    GCDFillMacFeat(mfgcd,mflabels,250,default_mac_feature_map, true, mfboxes, mfarray);

    p.plist = plist;
    wattrs.mask = wam_events|wam_cursor|wam_utf8_wtitle|wam_undercursor|wam_restrict|wam_isdlg;
    wattrs.event_masks = ~(1<<et_charup);
    wattrs.restrict_input_to_me = 1;
    wattrs.is_dlg = 1;
    wattrs.undercursor = 1;
    wattrs.cursor = ct_pointer;
    wattrs.utf8_window_title = windowTitle;
    pos.x = pos.y = 0;
    pos.width = GGadgetScale(GDrawPointsToPixels(NULL,340));
    pos.height = GDrawPointsToPixels(NULL,line_max*26+25);
    gw = GDrawCreateTopWindow(NULL,&pos,e_h,&p,&wattrs);



    for ( i=0, pl=plist; pl->name; ++i, ++pl ) {

	    plabel[gc].text = (unichar_t *) _(pl->name);
	    plabel[gc].text_is_1byte = true;
	    pgcd[gc].gd.label = &plabel[gc];
	    pgcd[gc].gd.mnemonic = '\0';
	    pgcd[gc].gd.popup_msg = (unichar_t *) 0;//_(pl->popup);
	    pgcd[gc].gd.pos.x = 8;
	    pgcd[gc].gd.pos.y = y + 6;
	    pgcd[gc].gd.flags = gg_visible | gg_enabled | gg_utf8_popup;
	    pgcd[gc++].creator = GLabelCreate;
	    hvarray[si++] = &pgcd[gc-1];

	    plabel[gc].text_is_1byte = true;
	    pgcd[gc].gd.label = &plabel[gc];
	    pgcd[gc].gd.mnemonic = '\0';
	    pgcd[gc].gd.popup_msg = (unichar_t *) 0;//_(pl->popup);
	    pgcd[gc].gd.pos.x = 110;
	    pgcd[gc].gd.pos.y = y;
	    pgcd[gc].gd.flags = gg_visible | gg_enabled | gg_utf8_popup;
	    pgcd[gc].data = pl;
	    pgcd[gc].gd.cid = k*CID_PrefsOffset+CID_PrefsBase+i;
	    switch ( pl->type ) {
	      case pr_bool:
		plabel[gc].text = (unichar_t *) _("On");
		pgcd[gc].gd.pos.y += 3;
		pgcd[gc++].creator = GRadioCreate;
		hvarray[si++] = &pgcd[gc-1];
		pgcd[gc] = pgcd[gc-1];
		pgcd[gc].gd.pos.x += 50;
		pgcd[gc].gd.cid = 0;
		pgcd[gc].gd.label = &plabel[gc];
		plabel[gc].text = (unichar_t *) _("Off");
		plabel[gc].text_is_1byte = true;
		hvarray[si++] = &pgcd[gc];
		hvarray[si++] = GCD_Glue;
		if ( *((int *) pl->val))
		    pgcd[gc-1].gd.flags |= gg_cb_on;
		else
		    pgcd[gc].gd.flags |= gg_cb_on;
		++gc;
		y += 22;
	      break;
	      case pr_int:
		sprintf(buf,"%d", *((int *) pl->val));
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	      case pr_unicode:
		/*sprintf(buf,"U+%04x", *((int *) pl->val));*/
		{ char *pt; pt=buf; pt=utf8_idpb(pt,*((int *)pl->val),UTF8IDPB_NOZERO); *pt='\0'; }
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	      case pr_real:
		sprintf(buf,"%g", *((float *) pl->val));
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	      case pr_encoding:
		pgcd[gc].gd.u.list = GetEncodingTypes();
		pgcd[gc].gd.label = EncodingTypesFindEnc(pgcd[gc].gd.u.list,
			*(Encoding **) pl->val);
		for ( ii=0; pgcd[gc].gd.u.list[ii].text!=NULL ||pgcd[gc].gd.u.list[ii].line; ++ii )
		    if ( pgcd[gc].gd.u.list[ii].userdata!=NULL &&
			    (strcmp(pgcd[gc].gd.u.list[ii].userdata,"Compacted")==0 ||
			     strcmp(pgcd[gc].gd.u.list[ii].userdata,"Original")==0 ))
			pgcd[gc].gd.u.list[ii].disabled = true;
		pgcd[gc].creator = GListFieldCreate;
		pgcd[gc].gd.pos.width = 160;
		if ( pgcd[gc].gd.label==NULL ) pgcd[gc].gd.label = &encodingtypes[0];
		++gc;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_ColSpan; hvarray[si++] = GCD_ColSpan;
		y += 28;
	      break;
	      case pr_namelist:
	        { char **nlnames = AllNamelistNames();
		int cnt;
		GTextInfo *namelistnames;
		for ( cnt=0; nlnames[cnt]!=NULL; ++cnt);
		namelistnames = calloc(cnt+1,sizeof(GTextInfo));
		for ( cnt=0; nlnames[cnt]!=NULL; ++cnt) {
		    namelistnames[cnt].text = (unichar_t *) nlnames[cnt];
		    namelistnames[cnt].text_is_1byte = true;
		    if ( strcmp(_((*(NameList **) (pl->val))->title),nlnames[cnt])==0 ) {
			namelistnames[cnt].selected = true;
			pgcd[gc].gd.label = &namelistnames[cnt];
		    }
		}
		pgcd[gc].gd.u.list = namelistnames;
		pgcd[gc].creator = GListButtonCreate;
		pgcd[gc].gd.pos.width = 160;
		++gc;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_ColSpan; hvarray[si++] = GCD_ColSpan;
		y += 28;
	      } break;
	      case pr_string: case pr_file:
		if ( pl->set==SetAutoTraceArgs || ((char **) pl->val)==&mf_args )
		    pgcd[gc].gd.pos.width = 160;
		if ( pl->val!=NULL )
		    tempstr = *((char **) (pl->val));
		else
		    tempstr = (char *) ((pl->get)());
		if ( tempstr!=NULL )
		    plabel[gc].text = /* def2u_*/ uc_copy( tempstr );
		else if ( ((char **) pl->val)==&BDFFoundry )
		    plabel[gc].text = /* def2u_*/ uc_copy( "FontForge" );
		else
		    plabel[gc].text = /* def2u_*/ uc_copy( "" );
		plabel[gc].text_is_1byte = false;
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		if ( pl->type==pr_file ) {
		    pgcd[gc] = pgcd[gc-1];
		    pgcd[gc-1].gd.pos.width = 140;
		    hvarray[si++] = GCD_ColSpan;
		    pgcd[gc].gd.pos.x += 145;
		    pgcd[gc].gd.cid += CID_PrefsBrowseOffset;
		    pgcd[gc].gd.label = &plabel[gc];
		    plabel[gc].text = (unichar_t *) "...";
		    plabel[gc].text_is_1byte = true;
		    pgcd[gc].gd.handle_controlevent = Prefs_BrowseFile;
		    pgcd[gc++].creator = GButtonCreate;
		    hvarray[si++] = &pgcd[gc-1];
		} else if ( pl->set==SetAutoTraceArgs || ((char **) pl->val)==&mf_args ) {
		    hvarray[si++] = GCD_ColSpan;
		    hvarray[si++] = GCD_Glue;
		} else {
		    hvarray[si++] = GCD_Glue;
		    hvarray[si++] = GCD_Glue;
		}
		y += 26;
		if ( pl->val==NULL )
		    free(tempstr);
	      break;
	      case pr_angle:
		sprintf(buf,"%g", *((float *) pl->val) * RAD2DEG);
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		plabel[gc].text = (unichar_t *) U_("Â°");
		plabel[gc].text_is_1byte = true;
		pgcd[gc].gd.label = &plabel[gc];
		pgcd[gc].gd.pos.x = pgcd[gc-1].gd.pos.x+gcd[gc-1].gd.pos.width+2; pgcd[gc].gd.pos.y = pgcd[gc-1].gd.pos.y;
		pgcd[gc].gd.flags = gg_enabled|gg_visible;
		pgcd[gc++].creator = GLabelCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	    }
	    ++line;
	    hvarray[si++] = NULL;

    }

    harray[4] = 0;
    harray[5] = 0;
    harray[6] = 0;
    harray[7] = 0;

    gcd[gc].gd.pos.x = 30-3;
    gcd[gc].gd.pos.y = y+5-3;
    gcd[gc].gd.pos.width = -1;
    gcd[gc].gd.pos.height = 0;
    gcd[gc].gd.flags = gg_visible | gg_enabled | gg_but_default;
    label[gc].text = (unichar_t *) _("_OK");
    label[gc].text_is_1byte = true;
    label[gc].text_in_resource = true;
    gcd[gc].gd.mnemonic = 'O';
    gcd[gc].gd.label = &label[gc];
    gcd[gc].gd.handle_controlevent = PrefsSubSet_Ok;
    gcd[gc++].creator = GButtonCreate;
    harray[0] = GCD_Glue; harray[1] = &gcd[gc-1]; harray[2] = GCD_Glue; harray[3] = GCD_Glue;


    memset(mboxes,0,sizeof(mboxes));
    memset(mboxes2,0,sizeof(mboxes2));

    mboxes[2].gd.pos.x = 2;
    mboxes[2].gd.pos.y = 20;
    mboxes[2].gd.flags = gg_enabled|gg_visible;
    mboxes[2].gd.u.boxelements = harray;
    mboxes[2].creator = GHBoxCreate;

    mboxes[0].gd.pos.x = mboxes[0].gd.pos.y = 2;
    mboxes[0].gd.flags = gg_enabled|gg_visible;
    mboxes[0].gd.u.boxelements = hvarray;
    mboxes[0].creator = GHVGroupCreate;

    varray[0] = &mboxes[0];
    varray[1] = &mboxes[2];
    varray[2] = 0;
    varray[3] = 0;
    varray[4] = 0;

    /* varray[0] = &mboxes[2]; */
    /* varray[1] = 0;//&mboxes[2]; */
    /* varray[2] = 0; */
    /* varray[3] = 0; */
    /* varray[4] = 0; */

    mboxes2[0].gd.pos.x = 4;
    mboxes2[0].gd.pos.y = 4;
    mboxes2[0].gd.flags = gg_enabled|gg_visible;
    mboxes2[0].gd.u.boxelements = varray;
    mboxes2[0].creator = GVBoxCreate;

    GGadgetsCreate(gw,mboxes2);


    GDrawSetVisible(gw,true);
    while ( !p.done )
	GDrawProcessOneEvent(NULL);
    GDrawDestroyWindow(gw);
}
