static struct MHD_Daemon * ulfius_run_mhd_daemon(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem, const char * root_ca_perm) {
  unsigned int mhd_flags = MHD_USE_THREAD_PER_CONNECTION;
  int index;

#ifdef DEBUG
  mhd_flags |= MHD_USE_DEBUG;
#endif
#if MHD_VERSION >= 0x00095300
  mhd_flags |= MHD_USE_INTERNAL_POLLING_THREAD;
#endif
#ifndef U_DISABLE_WEBSOCKET
  mhd_flags |= MHD_ALLOW_UPGRADE;
#endif

  if (u_instance->mhd_daemon == NULL) {
    struct MHD_OptionItem mhd_ops[8];

    // Default options
    mhd_ops[0].option = MHD_OPTION_NOTIFY_COMPLETED;
    mhd_ops[0].value = (intptr_t)mhd_request_completed;
    mhd_ops[0].ptr_value = NULL;

#if MHD_VERSION >= 0x00095208
    // If bind_address6 is specified, listen only to IPV6 addresses
    if (u_instance->bind_address6 != NULL) {
      mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;
      mhd_ops[1].value = 0;
      mhd_ops[1].ptr_value = (void *)u_instance->bind_address6;
      mhd_flags |= MHD_USE_IPv6;
    } else {
      mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;
      mhd_ops[1].value = 0;
      mhd_ops[1].ptr_value = (void *)u_instance->bind_address;
      // Default network stack is listening to IPV4 only
      if ((u_instance->network_type & U_USE_IPV4) && (u_instance->network_type & U_USE_IPV6)) {
        // If u_instance->network_type & U_USE_ALL, listen to IPV4 and IPV6 addresses
        mhd_flags |= MHD_USE_DUAL_STACK;
      } else if (u_instance->network_type & U_USE_IPV6) {
        // If u_instance->network_type & U_USE_IPV6, listen to IPV6 addresses only
        mhd_flags |= MHD_USE_IPv6;
      }
    }
#else
    mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;
    mhd_ops[1].value = 0;
    mhd_ops[1].ptr_value = (void *)u_instance->bind_address;
#endif

    mhd_ops[2].option = MHD_OPTION_URI_LOG_CALLBACK;
    mhd_ops[2].value = (intptr_t)ulfius_uri_logger;
    mhd_ops[2].ptr_value = NULL;

    index = 3;

    if (key_pem != NULL && cert_pem != NULL) {
      // HTTPS parameters
      mhd_flags |= MHD_USE_SSL;
      mhd_ops[index].option = MHD_OPTION_HTTPS_MEM_KEY;
      mhd_ops[index].value = 0;
      mhd_ops[index].ptr_value = (void*)key_pem;

      mhd_ops[index + 1].option = MHD_OPTION_HTTPS_MEM_CERT;
      mhd_ops[index + 1].value = 0;
      mhd_ops[index + 1].ptr_value = (void*)cert_pem;

      index += 2;

      if (root_ca_perm != NULL) {
        mhd_ops[index].option = MHD_OPTION_HTTPS_MEM_TRUST;
        mhd_ops[index].value = 0;
        mhd_ops[index].ptr_value = (void *)root_ca_perm;

        index++;
      }
    }
    if (u_instance->timeout > 0) {
      mhd_ops[index].option = MHD_OPTION_CONNECTION_TIMEOUT;
      mhd_ops[index].value = u_instance->timeout;
      mhd_ops[index].ptr_value = NULL;

      index++;
    }

    mhd_ops[index].option = MHD_OPTION_END;
    mhd_ops[index].value = 0;
    mhd_ops[index].ptr_value = NULL;

    return MHD_start_daemon (
      mhd_flags, u_instance->port, NULL, NULL, &ulfius_webservice_dispatcher, (void *)u_instance,
      MHD_OPTION_ARRAY, mhd_ops,
      MHD_OPTION_END
    );
  } else {
    y_log_message(Y_LOG_LEVEL_ERROR, "Ulfius - Error, instance already started");
    return NULL;
  }
}
