qb_log_blackbox_print_from_file(const char *bb_filename)
{
	qb_ringbuffer_t *instance;
	ssize_t bytes_read;
	int max_size = 2 * QB_LOG_MAX_LEN;
	char *chunk;
	int fd;
	int err = 0;
	int saved_errno;
	struct _blackbox_file_header header;
	int have_timespecs = 0;
	char time_buf[64];

	fd = open(bb_filename, 0);
	if (fd < 0) {
		saved_errno = errno;
		qb_util_perror(LOG_ERR, "qb_log_blackbox_print_from_file");
		return -saved_errno;
	}

	/* Read the header. If it looks like one of ours then
	   we know we have hi-res timestamps */
	err = read(fd, &header, sizeof(header));
	if (err < sizeof(header)) {
		saved_errno = errno;
		close(fd);
		return -saved_errno;
	}

	if (header.word_size == QB_BLACKBOX_HEADER_WORDSIZE &&
	    header.read_pt == QB_BLACKBOX_HEADER_READPT &&
	    header.write_pt == QB_BLACKBOX_HEADER_WRITEPT &&
	    header.version == QB_BLACKBOX_HEADER_VERSION &&
	    header.hash == QB_BLACKBOX_HEADER_HASH) {
		have_timespecs = 1;
	} else {
		(void)lseek(fd, 0, SEEK_SET);
	}


	instance = qb_rb_create_from_file(fd, 0);
	close(fd);
	if (instance == NULL) {
		return -EIO;
	}
	chunk = malloc(max_size);
	if (!chunk) {
		goto cleanup;
	}

	do {
		char *ptr;
		uint32_t lineno;
		uint32_t tags;
		uint8_t priority;
		uint32_t fn_size;
		char *function;
		uint32_t len;
		struct timespec timestamp;
		time_t time_sec;
		uint32_t msg_len;
		struct tm *tm;
		char message[QB_LOG_MAX_LEN];

		bytes_read = qb_rb_chunk_read(instance, chunk, max_size, 0);

		if (bytes_read >= 0 && bytes_read < BB_MIN_ENTRY_SIZE) {
			printf("ERROR Corrupt file: blackbox header too small.\n");
			err = -1;
			goto cleanup;
		} else if (bytes_read < 0) {
			errno = -bytes_read;
			perror("ERROR: qb_rb_chunk_read failed");
			err = -EIO;
			goto cleanup;
		}
		ptr = chunk;

		/* lineno */
		memcpy(&lineno, ptr, sizeof(uint32_t));
		ptr += sizeof(uint32_t);

		/* tags */
		memcpy(&tags, ptr, sizeof(uint32_t));
		ptr += sizeof(uint32_t);

		/* priority */
		memcpy(&priority, ptr, sizeof(uint8_t));
		ptr += sizeof(uint8_t);

		/* function size & name */
		memcpy(&fn_size, ptr, sizeof(uint32_t));
		if ((fn_size + BB_MIN_ENTRY_SIZE) > bytes_read) {
#ifndef S_SPLINT_S
			printf("ERROR Corrupt file: fn_size way too big %" PRIu32 "\n", fn_size);
			err = -EIO;
#endif /* S_SPLINT_S */
			goto cleanup;
		}
		if (fn_size <= 0) {
#ifndef S_SPLINT_S
			printf("ERROR Corrupt file: fn_size negative %" PRIu32 "\n", fn_size);
			err = -EIO;
#endif /* S_SPLINT_S */
			goto cleanup;
		}
		ptr += sizeof(uint32_t);

		function = ptr;
		ptr += fn_size;

		/* timestamp size & content */
		if (have_timespecs) {
			memcpy(&timestamp, ptr, sizeof(struct timespec));
			ptr += sizeof(struct timespec);
			time_sec = timestamp.tv_sec;
		} else {
			memcpy(&time_sec, ptr, sizeof(time_t));
			ptr += sizeof(time_t);
			timestamp.tv_nsec = 0LL;
		}

		tm = localtime(&time_sec);
		if (tm) {
			int slen = strftime(time_buf,
					    sizeof(time_buf), "%b %d %T",
					    tm);
			snprintf(time_buf+slen, sizeof(time_buf) - slen, ".%03llu", timestamp.tv_nsec/QB_TIME_NS_IN_MSEC);
		} else {
			snprintf(time_buf, sizeof(time_buf), "%ld",
				 (long int)time_sec);
		}
		/* message length */
		memcpy(&msg_len, ptr, sizeof(uint32_t));
		if (msg_len > QB_LOG_MAX_LEN || msg_len <= 0) {
#ifndef S_SPLINT_S
			printf("ERROR Corrupt file: msg_len out of bounds %" PRIu32 "\n", msg_len);
			err = -EIO;
#endif /* S_SPLINT_S */
			goto cleanup;
		}

		ptr += sizeof(uint32_t);

		/* message content */
		len = qb_vsnprintf_deserialize(message, QB_LOG_MAX_LEN, ptr);
		assert(len > 0);
		message[len] = '\0';
		len--;
		while (len > 0 && (message[len] == '\n' || message[len] == '\0')) {
			message[len] = '\0';
			len--;
		}

		printf("%-7s %s %s(%u):%u: %s\n",
		       qb_log_priority2str(priority),
		       time_buf, function, lineno, tags, message);

	} while (bytes_read > BB_MIN_ENTRY_SIZE);

cleanup:
	qb_rb_close(instance);
	free(chunk);
	return err;
}
