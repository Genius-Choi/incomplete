consume_end_of_file_marker(struct archive_read *a, struct zip *zip)
{
	const char *marker;
	const char *p;
	uint64_t compressed32, uncompressed32;
	uint64_t compressed64, uncompressed64;
	uint64_t compressed_actual, uncompressed_actual;
	uint32_t crc32_actual;
	const uint32_t PK78 = 0x08074B50ULL;
	uint8_t crc32_ignored, crc32_may_be_zero;

	/* If there shouldn't be a marker, don't consume it. */
	if ((zip->entry->zip_flags & ZIP_LENGTH_AT_END) == 0) {
		return;
	}

	/* The longest Zip end-of-file record is 24 bytes.  Since an
	 * end-of-file record can never appear at the end of the
	 * archive, we know 24 bytes will be available unless
	 * the archive is severely truncated. */
	if (NULL == (marker = __archive_read_ahead(a, 24, NULL))) {
		return;
	}
	p = marker;

	/* The end-of-file record comprises:
	 * = Optional PK\007\010 marker
	 * = 4-byte CRC32
	 * = Compressed size
	 * = Uncompressed size
	 *
	 * The last two fields are either both 32 bits or both 64
	 * bits.  We check all possible layouts and accept any one
	 * that gives us a complete match, else we make a best-effort
	 * attempt to parse out the pieces.
	 */

	/* CRC32 checking can be tricky:
	 * * Test suites sometimes ignore the CRC32
	 * * AES AE-2 always writes zero for the CRC32
	 * * AES AE-1 sometimes writes zero for the CRC32
	 */
	crc32_ignored = zip->ignore_crc32;
	crc32_may_be_zero = 0;
	crc32_actual = zip->computed_crc32;
	if (zip->hctx_valid) {
	  switch (zip->entry->aes_extra.vendor) {
	  case AES_VENDOR_AE_2:
	    crc32_actual = 0;
	    break;
	  case AES_VENDOR_AE_1:
	  default:
	    crc32_may_be_zero = 1;
	    break;
	  }
	}

	/* Values computed from the actual data in the archive. */
	compressed_actual = (uint64_t)zip->entry_compressed_bytes_read;
	uncompressed_actual = (uint64_t)zip->entry_uncompressed_bytes_read;


	/* Longest: PK78 marker, all 64-bit fields (24 bytes total) */
	if (archive_le32dec(p) == PK78
	    && ((archive_le32dec(p + 4) == crc32_actual)
		|| (crc32_may_be_zero && (archive_le32dec(p + 4) == 0))
		|| crc32_ignored)
	    && (archive_le64dec(p + 8) == compressed_actual)
	    && (archive_le64dec(p + 16) == uncompressed_actual)) {
		if (!crc32_ignored) {
			zip->entry->crc32 = crc32_actual;
		}
		zip->entry->compressed_size = compressed_actual;
		zip->entry->uncompressed_size = uncompressed_actual;
		zip->unconsumed += 24;
		return;
	}

	/* No PK78 marker, 64-bit fields (20 bytes total) */
	if (((archive_le32dec(p) == crc32_actual)
	     || (crc32_may_be_zero && (archive_le32dec(p + 4) == 0))
	     || crc32_ignored)
	    && (archive_le64dec(p + 4) == compressed_actual)
	    && (archive_le64dec(p + 12) == uncompressed_actual)) {
	        if (!crc32_ignored) {
			zip->entry->crc32 = crc32_actual;
		}
		zip->entry->compressed_size = compressed_actual;
		zip->entry->uncompressed_size = uncompressed_actual;
		zip->unconsumed += 20;
		return;
	}

	/* PK78 marker and 32-bit fields (16 bytes total) */
	if (archive_le32dec(p) == PK78
	    && ((archive_le32dec(p + 4) == crc32_actual)
		|| (crc32_may_be_zero && (archive_le32dec(p + 4) == 0))
		|| crc32_ignored)
	    && (archive_le32dec(p + 8) == compressed_actual)
	    && (archive_le32dec(p + 12) == uncompressed_actual)) {
		if (!crc32_ignored) {
			zip->entry->crc32 = crc32_actual;
		}
		zip->entry->compressed_size = compressed_actual;
		zip->entry->uncompressed_size = uncompressed_actual;
		zip->unconsumed += 16;
		return;
	}

	/* Shortest: No PK78 marker, all 32-bit fields (12 bytes total) */
	if (((archive_le32dec(p) == crc32_actual)
	     || (crc32_may_be_zero && (archive_le32dec(p + 4) == 0))
	     || crc32_ignored)
	    && (archive_le32dec(p + 4) == compressed_actual)
	    && (archive_le32dec(p + 8) == uncompressed_actual)) {
		if (!crc32_ignored) {
			zip->entry->crc32 = crc32_actual;
		}
		zip->entry->compressed_size = compressed_actual;
		zip->entry->uncompressed_size = uncompressed_actual;
		zip->unconsumed += 12;
		return;
	}

	/* If none of the above patterns gives us a full exact match,
	 * then there's something definitely amiss.  The fallback code
	 * below will parse out some plausible values for error
	 * reporting purposes.  Note that this won't actually
	 * consume anything:
	 *
	 * = If there really is a marker here, the logic to resync to
	 *   the next entry will suffice to skip it.
	 *
	 * = There might not really be a marker: Corruption or bugs
	 *   may have set the length-at-end bit without a marker ever
	 *   having actually been written. In this case, we
	 *   explicitly should not consume any bytes, since that would
	 *   prevent us from correctly reading the next entry.
	 */
	if (archive_le32dec(p) == PK78) {
		p += 4; /* Ignore PK78 if it appears to be present */
	}
	zip->entry->crc32 = archive_le32dec(p);  /* Parse CRC32 */
	p += 4;

	/* Consider both 32- and 64-bit interpretations */
	compressed32 = archive_le32dec(p);
	uncompressed32 = archive_le32dec(p + 4);
	compressed64 = archive_le64dec(p);
	uncompressed64 = archive_le64dec(p + 8);

	/* The earlier patterns may have failed because of CRC32
	 * mismatch, so it's still possible that both sizes match.
	 * Try to match as many as we can...
	 */
	if (compressed32 == compressed_actual
	    && uncompressed32 == uncompressed_actual) {
		/* Both 32-bit fields match */
		zip->entry->compressed_size = compressed32;
		zip->entry->uncompressed_size = uncompressed32;
	} else if (compressed64 == compressed_actual
		   || uncompressed64 == uncompressed_actual) {
		/* One or both 64-bit fields match */
		zip->entry->compressed_size = compressed64;
		zip->entry->uncompressed_size = uncompressed64;
	} else {
		/* Zero or one 32-bit fields match */
		zip->entry->compressed_size = compressed32;
		zip->entry->uncompressed_size = uncompressed32;
	}
}
