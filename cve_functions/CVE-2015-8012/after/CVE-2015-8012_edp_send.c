edp_send(struct lldpd *global,
	 struct lldpd_hardware *hardware)
{
	const u_int8_t mcastaddr[] = EDP_MULTICAST_ADDR;
	const u_int8_t llcorg[] = LLC_ORG_EXTREME;
	struct lldpd_chassis *chassis;
	int length, i, v;
	u_int8_t *packet, *pos, *pos_llc, *pos_len_eh, *pos_len_edp, *pos_edp, *tlv, *end;
	u_int16_t checksum;
#ifdef ENABLE_DOT1
	struct lldpd_vlan *vlan;
	unsigned int state = 0;
#endif
	u_int8_t edp_fakeversion[] = {7, 6, 4, 99};
	/* Subsequent XXX can be replaced by other values. We place
	   them here to ensure the position of "" to be a bit
	   invariant with version changes. */
	char *deviceslot[] = { "eth", "veth", "XXX", "XXX", "XXX", "XXX", "XXX", "XXX", "", NULL };

	log_debug("edp", "send EDP frame on port %s", hardware->h_ifname);

	chassis = hardware->h_lport.p_chassis;
#ifdef ENABLE_DOT1
	while (state != 2) {
#endif
		length = hardware->h_mtu;
		if ((packet = (u_int8_t*)calloc(1, length)) == NULL)
			return ENOMEM;
		pos = packet;
		v = 0;

		/* Ethernet header */
		if (!(
		      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&
		      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&
		      POKE_SAVE(pos_len_eh) && /* We compute the len later */
		      POKE_UINT16(0)))
			goto toobig;

		/* LLC */
		if (!(
		      POKE_SAVE(pos_llc) && /* We need to save our
					       current position to
					       compute ethernet len */
		      /* SSAP and DSAP */
		      POKE_UINT8(0xaa) && POKE_UINT8(0xaa) &&
		      /* Control field */
		      POKE_UINT8(0x03) &&
		      /* ORG */
		      POKE_BYTES(llcorg, sizeof(llcorg)) &&
		      POKE_UINT16(LLC_PID_EDP)))
			goto toobig;

		/* EDP header */
		if ((chassis->c_id_len != ETHER_ADDR_LEN) ||
		    (chassis->c_id_subtype != LLDP_CHASSISID_SUBTYPE_LLADDR)) {
			log_warnx("edp", "local chassis does not use MAC address as chassis ID!?");
			free(packet);
			return EINVAL;
		}
		if (!(
		      POKE_SAVE(pos_edp) && /* Save the start of EDP frame */
		      POKE_UINT8(1) && POKE_UINT8(0) &&
		      POKE_SAVE(pos_len_edp) && /* We compute the len
						   and the checksum
						   later */
		      POKE_UINT32(0) && /* Len + Checksum */
		      POKE_UINT16(seq) &&
		      POKE_UINT16(0) &&
		      POKE_BYTES(chassis->c_id, ETHER_ADDR_LEN)))
			goto toobig;
		seq++;

#ifdef ENABLE_DOT1
		switch (state) {
		case 0:
#endif
			/* Display TLV */
			if (!(
			      POKE_START_EDP_TLV(EDP_TLV_DISPLAY) &&
			      POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&
			      POKE_UINT8(0) && /* Add a NULL character
						  for better
						  compatibility */
			      POKE_END_EDP_TLV))
				goto toobig;

			/* Info TLV */
			if (!(
			      POKE_START_EDP_TLV(EDP_TLV_INFO)))
				goto toobig;
			/* We try to emulate the slot thing */
			for (i=0; deviceslot[i] != NULL; i++) {
				if (strncmp(hardware->h_ifname, deviceslot[i],
					strlen(deviceslot[i])) == 0) {
					if (!(
					      POKE_UINT16(i) &&
					      POKE_UINT16(atoi(hardware->h_ifname +
							       strlen(deviceslot[i])))))
						goto toobig;
					break;
				}
			}
			/* If we don't find a "slot", we say that the
			   interface is in slot 8 */
			if (deviceslot[i] == NULL) {
				if (!(
				      POKE_UINT16(8) &&
				      POKE_UINT16(hardware->h_ifindex)))
					goto toobig;
			}
			if (!(
			      POKE_UINT16(0) && /* vchassis */
			      POKE_UINT32(0) && POKE_UINT16(0) && /* Reserved */
			      /* Version */
			      POKE_BYTES(edp_fakeversion, sizeof(edp_fakeversion)) &&
			      /* Connections, we say that we won't
				 have more interfaces than this
				 mask. */
			      POKE_UINT32(0xffffffff) &&
			      POKE_UINT32(0) && POKE_UINT32(0) && POKE_UINT32(0) &&
			      POKE_END_EDP_TLV))
				goto toobig;

#ifdef ENABLE_DOT1
			break;
		case 1:
			TAILQ_FOREACH(vlan, &hardware->h_lport.p_vlans,
			    v_entries) {
				v++;
				if (!(
				      POKE_START_EDP_TLV(EDP_TLV_VLAN) &&
				      POKE_UINT8(0) && /* Flags: no IP address */
				      POKE_UINT8(0) && /* Reserved */
				      POKE_UINT16(vlan->v_vid) &&
				      POKE_UINT32(0) && /* Reserved */
				      POKE_UINT32(0) && /* IP address */
				      /* VLAN name */
				      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&
				      POKE_UINT8(0) &&
				      POKE_END_EDP_TLV))
					goto toobig;
			}
			break;
		}

		if ((state == 1) && (v == 0)) {
			/* No VLAN, no need to send another TLV */
			free(packet);
			break;
		}
#endif
			
		/* Null TLV */
		if (!(
		      POKE_START_EDP_TLV(EDP_TLV_NULL) &&
		      POKE_END_EDP_TLV &&
		      POKE_SAVE(end)))
			goto toobig;

		/* Compute len and checksum */
		i = end - pos_llc; /* Ethernet length */
		v = end - pos_edp; /* EDP length */
		POKE_RESTORE(pos_len_eh);
		if (!(POKE_UINT16(i))) goto toobig;
		POKE_RESTORE(pos_len_edp);
		if (!(POKE_UINT16(v))) goto toobig;
		checksum = frame_checksum(pos_edp, v, 0);
		if (!(POKE_UINT16(checksum))) goto toobig;

		if (interfaces_send_helper(global, hardware,
			(char *)packet, end - packet) == -1) {
			log_warn("edp", "unable to send packet on real device for %s",
			    hardware->h_ifname);
			free(packet);
			return ENETDOWN;
		}
		free(packet);

#ifdef ENABLE_DOT1		
		state++;
	}
#endif

	hardware->h_tx_cnt++;
	return 0;
 toobig:
	free(packet);
	return E2BIG;
}
