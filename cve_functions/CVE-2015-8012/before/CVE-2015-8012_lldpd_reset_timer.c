lldpd_reset_timer(struct lldpd *cfg)
{
	/* Reset timer for ports that have been changed. */
	struct lldpd_hardware *hardware;
	TAILQ_FOREACH(hardware, &cfg->g_hardware, h_entries) {
		/* We keep a flat copy of the local port to see if there is any
		 * change. To do this, we zero out fields that are not
		 * significant, marshal the port, then restore. */
		struct lldpd_port *port = &hardware->h_lport;
		u_int8_t *output = NULL;
		ssize_t output_len;
		char save[LLDPD_PORT_START_MARKER];
		memcpy(save, port, sizeof(save));
		/* coverity[suspicious_sizeof]
		   We intentionally partially memset port */
		memset(port, 0, sizeof(save));
		output_len = lldpd_port_serialize(port, (void**)&output);
		memcpy(port, save, sizeof(save));
		if (output_len == -1) {
			log_warnx("localchassis",
			    "unable to serialize local port %s to check for differences",
			    hardware->h_ifname);
			continue;
		}

		/* Compare with the previous value */
		if (hardware->h_lport_previous &&
		    output_len == hardware->h_lport_previous_len &&
		    !memcmp(output, hardware->h_lport_previous, output_len)) {
			log_debug("localchassis",
			    "no change detected for port %s",
			    hardware->h_ifname);
		} else {
			log_debug("localchassis",
			    "change detected for port %s, resetting its timer",
			    hardware->h_ifname);
			levent_schedule_pdu(hardware);
		}

		/* Update the value */
		free(hardware->h_lport_previous);
		hardware->h_lport_previous = output;
		hardware->h_lport_previous_len = output_len;
	}
}
