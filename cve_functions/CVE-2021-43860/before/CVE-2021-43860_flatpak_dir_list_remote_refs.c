flatpak_dir_list_remote_refs (FlatpakDir         *self,
                              FlatpakRemoteState *state,
                              GHashTable        **refs,
                              GCancellable       *cancellable,
                              GError            **error)
{
  g_autoptr(GError) my_error = NULL;

  if (error == NULL)
    error = &my_error;

  if (!flatpak_dir_list_all_remote_refs (self, state, refs,
                                         cancellable, error))
    return FALSE;

  if (flatpak_dir_get_remote_noenumerate (self, state->remote_name))
    {
      g_autoptr(GHashTable) decomposed_local_refs =
        g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);
      g_autoptr(GHashTable) local_refs = NULL;
      g_autoptr(FlatpakDecomposed) decomposed_main_ref = NULL;
      GHashTableIter hash_iter;
      gpointer key;
      g_autofree char *refspec_prefix = g_strconcat (state->remote_name, ":.", NULL);
      g_autofree char *remote_main_ref = NULL;

      /* For noenumerate remotes, only return data for already locally
       * available refs, or the ref set as xa.main-ref on the remote, or
       * extensions of that main ref */

      if (!ostree_repo_list_refs (self->repo, refspec_prefix, &local_refs,
                                  cancellable, error))
        return FALSE;

      g_hash_table_iter_init (&hash_iter, local_refs);
      while (g_hash_table_iter_next (&hash_iter, &key, NULL))
        {
          const char *refspec = key;
          g_autofree char *ref = NULL;
          g_autoptr(FlatpakDecomposed) d = NULL;

          if (!ostree_parse_refspec (refspec, NULL, &ref, error))
            return FALSE;

          d = flatpak_decomposed_new_from_ref (ref, NULL);
          if (d)
            g_hash_table_insert (decomposed_local_refs, g_steal_pointer (&d), NULL);
        }

      remote_main_ref = flatpak_dir_get_remote_main_ref (self, state->remote_name);
      if (remote_main_ref != NULL && *remote_main_ref != '\0')
        decomposed_main_ref = flatpak_decomposed_new_from_col_ref (remote_main_ref, state->collection_id, NULL);

      /* Then we remove all remote refs not in the local refs set, not the main
       * ref, and not an extension of the main ref */
      GLNX_HASH_TABLE_FOREACH_IT (*refs, it, FlatpakDecomposed *, d, void *, v)
        {
          if (g_hash_table_contains (decomposed_local_refs, d))
            continue;

          if (decomposed_main_ref != NULL)
            {
              g_autofree char *main_ref_id = NULL;
              g_autofree char *main_ref_prefix = NULL;

              if (flatpak_decomposed_equal (decomposed_main_ref, d))
                continue;

              main_ref_id = flatpak_decomposed_dup_id (decomposed_main_ref);
              main_ref_prefix = g_strconcat (main_ref_id, ".", NULL);
              if (flatpak_decomposed_id_has_prefix (d, main_ref_prefix))
                continue;
            }

          g_hash_table_iter_remove (&it);
      }
    }

  return TRUE;
}
