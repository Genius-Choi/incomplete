local_match_prefix (FlatpakDir        *self,
                    FlatpakDecomposed *extension_ref,
                    const char        *remote,
                    GHashTable        *decomposed_to_search)
{
  GHashTable *matches = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash,
                                               (GEqualFunc)flatpak_decomposed_equal,
                                               (GDestroyNotify)flatpak_decomposed_unref,
                                               NULL);
  g_autofree char *id = NULL;
  g_autofree char *arch = NULL;
  g_autofree char *branch = NULL;
  g_autofree char *id_prefix = NULL;

  id = flatpak_decomposed_dup_id (extension_ref);
  arch = flatpak_decomposed_dup_arch (extension_ref);
  branch = flatpak_decomposed_dup_branch (extension_ref);

  id_prefix = g_strconcat (id, ".", NULL);

  if (decomposed_to_search)
    {
      GHashTableIter hash_iter;
      gpointer key;

      g_hash_table_iter_init (&hash_iter, decomposed_to_search);
      while (g_hash_table_iter_next (&hash_iter, &key, NULL))
        {
          FlatpakDecomposed *to_test = key;

          if (flatpak_decomposed_get_kind (extension_ref) != flatpak_decomposed_get_kind (to_test))
            continue;

          /* Must match type, arch, branch */
          if (!flatpak_decomposed_is_arch (to_test, arch) ||
              !flatpak_decomposed_is_branch (to_test, branch))
            continue;

          /* But only prefix of id */
          if (!flatpak_decomposed_id_has_prefix (to_test, id_prefix))
            continue;

          g_hash_table_add (matches, flatpak_decomposed_ref (to_test));
        }
    }

  /* Also check deploys. In case remote-delete --force is run, we can end up
   * with a deploy without a corresponding ref in the repo. */
  flatpak_dir_collect_deployed_refs (self, flatpak_decomposed_get_kind_str (extension_ref),
                                     id_prefix, arch, branch, matches, NULL, NULL);

  return matches;
}
