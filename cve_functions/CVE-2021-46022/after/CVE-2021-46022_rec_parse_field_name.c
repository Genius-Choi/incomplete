rec_parse_field_name (rec_parser_t parser,
                      char **fname)
{
  bool ret = true;
  int ci;
  size_t str_size;
  char c;
  rec_buf_t buf;

  /* Sanity check */
  if (rec_parser_eof (parser)
      || rec_parser_error (parser))
    return false;

  buf = rec_buf_new (fname, &str_size);
  if (!buf)
    {
      /* Out of memory */
      parser->error = REC_PARSER_ENOMEM;
      return false;
    }

  /* The syntax of a field name is described by the following regexp:
   *
   * [a-zA-Z%][a-zA-Z0-9_]*:
   */

  /* [a-zA-Z%] */
  ci = rec_parser_getc (parser);
  if (ci == EOF)
    ret = false;
  else
    {
      c = (char) ci;

      if ((rec_parser_letter_p (c))
          || (c == '%'))
        {
          if (rec_buf_putc (c, buf) == EOF)
            {
              /* Out of memory */
              parser->error = REC_PARSER_ENOMEM;
              return false;
            }
        }
      else
        {
          /* Parse error */
          parser->error = REC_PARSER_EFNAME;
          ret = false;
        }
    }

  /* [a-zA-Z0-9_]* */
  if (ret)
    {
      while ((ci = rec_parser_getc (parser)) != EOF)
        {
          c = (char) ci;

          if (rec_parser_letter_p (c)
              || rec_parser_digit_p (c)
              || (c == '_'))
            {
              if (rec_buf_putc (c, buf) == EOF)
                {
                  /* Out of memory */
                  parser->error = REC_PARSER_ENOMEM;
                  return false;
                }
              if (parser->error > 0)
                break;
            }
          else if (c == ':')
            /* End of token.  Consume the ':' and report success */
            break;
          else
            {
              /* Parse error */
              parser->error = REC_PARSER_EFNAME;
              ret = false;
              break;
            }
        }

      if (parser->eof)
        {
          parser->error = REC_PARSER_EFNAME;
          ret = false;
        }
    }

  rec_buf_close (buf);

  if (!ret)
    free (*fname);
  else
    {
      /* Field names ends with:
       *
       * - A blank character or
       * - A tab or
       * - A newline or
       * - The end of the file
       *
       * Note that if the field name ends with a newline it is
       * pushed back to the input stream, since (unlike a blank
       * character) it will be part of the field value.
       */

      ci = rec_parser_getc (parser);
      if (ci != EOF)
        {
          c = (char) ci;
          if ((c == ' ') || (c == '\t'))
            parser->error = REC_PARSER_NOERROR;
          else if (c == '\n')
            {
              parser->error = REC_PARSER_NOERROR;
              rec_parser_ungetc (parser, c);
            }
          else
            rec_parser_ungetc (parser, c);
        }
    }

  return ret;
}
