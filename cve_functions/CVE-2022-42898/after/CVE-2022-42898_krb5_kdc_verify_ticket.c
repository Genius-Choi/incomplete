krb5_kdc_verify_ticket(krb5_context context, const krb5_enc_tkt_part *enc_tkt,
                       krb5_const_principal server_princ,
                       const krb5_keyblock *server,
                       const krb5_keyblock *privsvr, krb5_pac *pac_out)
{
    krb5_error_code ret;
    krb5_pac pac = NULL;
    krb5_data *recoded_tkt = NULL;
    krb5_authdata **authdata, *orig, **ifrel = NULL, **recoded_ifrel = NULL;
    uint8_t z = 0;
    krb5_authdata zpac = { KV5M_AUTHDATA, KRB5_AUTHDATA_WIN2K_PAC, 1, &z };
    size_t i, j;

    *pac_out = NULL;

    /*
     * Find the position of the PAC in the ticket authdata.  ifrel will be the
     * decoded AD-IF-RELEVANT container at position i containing a PAC, and j
     * will be the offset within the container.
     */
    authdata = enc_tkt->authorization_data;
    for (i = 0; authdata != NULL && authdata[i] != NULL; i++) {
        if (authdata[i]->ad_type != KRB5_AUTHDATA_IF_RELEVANT)
            continue;

        ret = krb5_decode_authdata_container(context,
                                             KRB5_AUTHDATA_IF_RELEVANT,
                                             authdata[i], &ifrel);
        if (ret)
            goto cleanup;

        for (j = 0; ifrel[j] != NULL; j++) {
            if (ifrel[j]->ad_type == KRB5_AUTHDATA_WIN2K_PAC)
                break;
        }
        if (ifrel[j] != NULL)
            break;

        krb5_free_authdata(context, ifrel);
        ifrel = NULL;
    }

    /* Stop and return successfully if we didn't find a PAC. */
    if (ifrel == NULL) {
        ret = 0;
        goto cleanup;
    }

    ret = krb5_pac_parse(context, ifrel[j]->contents, ifrel[j]->length, &pac);
    if (ret)
        goto cleanup;

    if (privsvr != NULL && k5_pac_should_have_ticket_signature(server_princ)) {
        /* To check the PAC ticket signatures, re-encode the ticket with the
         * PAC contents replaced by a single zero. */
        orig = ifrel[j];
        ifrel[j] = &zpac;
        ret = krb5_encode_authdata_container(context,
                                             KRB5_AUTHDATA_IF_RELEVANT,
                                             ifrel, &recoded_ifrel);
        ifrel[j] = orig;
        if (ret)
            goto cleanup;
        orig = authdata[i];
        authdata[i] = recoded_ifrel[0];
        ret = encode_krb5_enc_tkt_part(enc_tkt, &recoded_tkt);
        authdata[i] = orig;
        if (ret)
            goto cleanup;

        ret = verify_checksum(context, pac, KRB5_PAC_TICKET_CHECKSUM, privsvr,
                              KRB5_KEYUSAGE_APP_DATA_CKSUM, recoded_tkt);
        if (ret)
            goto cleanup;
    }

    ret = krb5_pac_verify_ext(context, pac, enc_tkt->times.authtime, NULL,
                              server, privsvr, FALSE);

    *pac_out = pac;
    pac = NULL;

cleanup:
    krb5_pac_free(context, pac);
    krb5_free_data(context, recoded_tkt);
    krb5_free_authdata(context, ifrel);
    krb5_free_authdata(context, recoded_ifrel);
    return ret;
}
