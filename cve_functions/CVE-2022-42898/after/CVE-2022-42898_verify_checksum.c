verify_checksum(krb5_context context, const krb5_pac pac, uint32_t buffer_type,
                const krb5_keyblock *key, krb5_keyusage usage,
                const krb5_data *data)
{
    krb5_error_code ret;
    krb5_data buffer;
    krb5_cksumtype cksumtype;
    krb5_checksum checksum;
    krb5_boolean valid;
    size_t cksumlen;

    ret = k5_pac_locate_buffer(context, pac, buffer_type, &buffer);
    if (ret != 0)
        return ret;
    if (buffer.length < PAC_SIGNATURE_DATA_LENGTH)
        return KRB5_BAD_MSIZE;

    cksumtype = load_32_le(buffer.data);
    if (buffer_type == KRB5_PAC_SERVER_CHECKSUM && cksumtype == CKSUMTYPE_SHA1)
        return KRB5KDC_ERR_SUMTYPE_NOSUPP;
    if (!krb5_c_is_keyed_cksum(cksumtype))
        return KRB5KRB_ERR_GENERIC;

    /* There may be an RODCIdentifier trailer (see [MS-PAC] 2.8), so look up
     * the length of the checksum by its type. */
    ret = krb5_c_checksum_length(context, cksumtype, &cksumlen);
    if (ret)
        return ret;
    if (cksumlen > buffer.length - PAC_SIGNATURE_DATA_LENGTH)
        return KRB5_BAD_MSIZE;
    checksum.checksum_type = cksumtype;
    checksum.length = cksumlen;
    checksum.contents = (uint8_t *)buffer.data + PAC_SIGNATURE_DATA_LENGTH;

    ret = krb5_c_verify_checksum(context, key, usage, data, &checksum, &valid);
    return ret ? ret : (valid ? 0 : KRB5KRB_AP_ERR_MODIFIED);
}
