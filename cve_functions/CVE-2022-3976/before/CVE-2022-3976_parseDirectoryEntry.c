parseDirectoryEntry(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, MmsConnection_FileDirectoryHandler handler, void* parameter)
{
    char fileNameMemory[400];
    char* filename = NULL;
    uint32_t fileSize = 0;
    uint64_t lastModified = 0;

    while (bufPos < maxBufPos) {
        uint8_t tag = buffer[bufPos++];
        int length;

        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);
        if (bufPos < 0) {
            if (DEBUG_MMS_CLIENT)
                printf("MMS_CLIENT: invalid length field\n");
            return false;
        }

        switch (tag) {
        case 0xa0: /* file-name */

            filename = fileNameMemory;

            tag = buffer[bufPos++];

            bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);
            if (bufPos < 0) {
                if (DEBUG_MMS_CLIENT)
                    printf("MMS_CLIENT: invalid length field\n");
                return false;
            }

            memcpy(filename, buffer + bufPos, length);
            filename[length] = 0;

            bufPos += length;
            break;
        case 0xa1: /* file-attributes */
            if (!parseFileAttributes(buffer, bufPos, bufPos + length, &fileSize, &lastModified))
                return false;
            bufPos += length;
            break;
        case 0x00: /* indefinite length end tag -> ignore */
            break;
        default:
            bufPos += length;
            if (DEBUG_MMS_CLIENT)
                printf("MMS_CLIENT: message contains unknown tag!\n");

            return false;
        }
    }

    if (filename != NULL)
        handler(invokeId, parameter, MMS_ERROR_NONE, filename, fileSize, lastModified, true);
    else
        return false;

    return true;
}
