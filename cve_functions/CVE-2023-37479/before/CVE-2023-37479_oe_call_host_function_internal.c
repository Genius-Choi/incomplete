oe_result_t oe_call_host_function_internal(
    uint64_t function_id,
    const void* input_buffer,
    size_t input_buffer_size,
    void* output_buffer,
    size_t output_buffer_size,
    size_t* output_bytes_written,
    bool switchless)
{
    oe_result_t result = OE_UNEXPECTED;
    oe_call_host_function_args_t args, *args_host_ptr = NULL;
    oe_call_function_return_args_t return_args, *return_args_host_ptr = NULL;
    uint64_t host_result = 0;

    /* Ensure input buffer is outside the enclave memory and its size is valid
     */
    if (!oe_is_outside_enclave(input_buffer, input_buffer_size) ||
        input_buffer_size < sizeof(oe_call_function_return_args_t))
        OE_RAISE(OE_INVALID_PARAMETER);

    /* Ensure output buffer is outside the enclave memory and its size is
     * valid. Also, check its address is 8-byte aligned (against the xAPIC
     * vulnerability) */
    if (!oe_is_outside_enclave(output_buffer, output_buffer_size) ||
        output_buffer_size < sizeof(oe_call_function_return_args_t) ||
        ((uint64_t)output_buffer % 8) != 0)
        OE_RAISE(OE_INVALID_PARAMETER);

    /*
     * oe_post_switchless_ocall (below) can make a regular ocall to wake up the
     * host worker thread, and will end up using the ecall context's args.
     * Therefore, for switchless calls, allocate args in the arena so that it is
     * is not overwritten by oe_post_switchless_ocall.
     */
    args_host_ptr =
        (oe_call_host_function_args_t*)(switchless ? oe_arena_malloc(sizeof(*args_host_ptr)) : oe_ecall_context_get_ocall_args());

    /* Ensure the args_host_ptr is valid and 8-byte aligned (for xAPIC
     * vulnerability mitigation) */
    if (!oe_is_outside_enclave(
            (const void*)args_host_ptr, sizeof(oe_call_host_function_args_t)) ||
        ((uint64_t)args_host_ptr % 8) != 0)
    {
        /* Fail if the enclave is crashing. */
        OE_CHECK(__oe_enclave_status);
        OE_RAISE(OE_UNEXPECTED);
    }

    /* Prepare a local copy of args */
    args.function_id = function_id;
    args.input_buffer = input_buffer;
    args.input_buffer_size = input_buffer_size;
    args.output_buffer = output_buffer;
    args.output_buffer_size = output_buffer_size;
    args.result = OE_UNEXPECTED;

    /* Copy the local copy of args to host memory */
    OE_CHECK(oe_memcpy_s_with_barrier(
        args_host_ptr, sizeof(*args_host_ptr), &args, sizeof(args)));

    /* Call the host function with this address */
    if (switchless && oe_is_switchless_initialized())
    {
        oe_result_t post_result = oe_post_switchless_ocall(args_host_ptr);

        // Fall back to regular OCALL if host worker threads are unavailable
        if (post_result == OE_CONTEXT_SWITCHLESS_OCALL_MISSED)
            OE_CHECK(oe_ocall(
                OE_OCALL_CALL_HOST_FUNCTION, (uint64_t)args_host_ptr, NULL));
        else
        {
            OE_CHECK(post_result);
            // Wait until args.result is set by the host worker.
            while (true)
            {
                OE_ATOMIC_MEMORY_BARRIER_ACQUIRE();

                /* The member result is alignend given that args_host_ptr is
                 * aligned and its size is 8-byte (for xAPIC vulnerability
                 * mitigation). */
                if (__atomic_load_n(&args_host_ptr->result, __ATOMIC_SEQ_CST) !=
                    OE_UINT64_MAX)
                    break;

                /* Yield to CPU */
                asm volatile("pause");
            }
        }
    }
    else
    {
        OE_CHECK(oe_ocall(
            OE_OCALL_CALL_HOST_FUNCTION, (uint64_t)args_host_ptr, NULL));
    }

    /* Copy the result from the host memory
     * The member result is aligned given that args_host_ptr is aligned
     * and its size is 8 byte (for xAPIC vulnerability mitigation). */
    host_result = args_host_ptr->result;

    /* Check the result */
    OE_CHECK((oe_result_t)host_result);

    return_args_host_ptr = (oe_call_function_return_args_t*)output_buffer;

    /* Copy the marshaling struct from the host memory to avoid TOCTOU issues.
     * To mitigate the xAPIC vulnerability, the output_buffer and the size of
     * oe_call_function_return_args_t must be aligned at this point via runtime
     * and compile-time checks, repsectively. */
    oe_memcpy_aligned(
        &return_args,
        return_args_host_ptr,
        sizeof(oe_call_function_return_args_t));

    if (return_args.result == OE_OK)
    {
        /*
         * Error out the case if the deepcopy_out_buffer is NULL but the
         * deepcopy_out_buffer_size is not zero or if the deepcopy_out_buffer is
         * not NULL but the deepcopy_out_buffer_size is zero. Note that this
         * should only occur if the oeedger8r was not used or if
         * oeedger8r-generated routine is modified.
         */
        if ((!return_args.deepcopy_out_buffer &&
             return_args.deepcopy_out_buffer_size) ||
            (return_args.deepcopy_out_buffer &&
             !return_args.deepcopy_out_buffer_size))
            OE_RAISE(OE_UNEXPECTED);

        /*
         * Nonzero deepcopy_out_buffer and deepcopy_out_buffer_size fields
         * indicate that there is deep-copied content that needs to be
         * transmitted from the host.
         */
        if (return_args.deepcopy_out_buffer &&
            return_args.deepcopy_out_buffer_size)
        {
            /*
             * Ensure that the deepcopy_out_buffer and deepcopy_out_buffer_size
             * are both 8-byte aligned against the xAPIC vulnerability.
             */
            if ((((uint64_t)return_args.deepcopy_out_buffer % 8) != 0) ||
                (return_args.deepcopy_out_buffer_size % 8) != 0)
                OE_RAISE(OE_UNEXPECTED);

            /*
             * Ensure that the content lies in host memory.
             * Note that this should only fail if oeedger8r was not used or if
             * the oeedger8r-generated routine is modified.
             */
            if (!oe_is_outside_enclave(
                    return_args.deepcopy_out_buffer,
                    return_args.deepcopy_out_buffer_size))
                OE_RAISE(OE_UNEXPECTED);

            void* enclave_buffer =
                oe_malloc(return_args.deepcopy_out_buffer_size);

            if (!enclave_buffer)
                OE_RAISE(OE_OUT_OF_MEMORY);

            /* Copy the deep-copied content to enclave memory. */
            oe_memcpy_aligned(
                enclave_buffer,
                return_args.deepcopy_out_buffer,
                return_args.deepcopy_out_buffer_size);

            /* Release the memory on host heap. */
            oe_host_free(return_args.deepcopy_out_buffer);

            /*
             * Update the deepcopy_out_buffer field.
             * Note that the field is still in host memory. Currently, the
             * oeedger8r-generated code will perform an additional check that
             * ensures the buffer stays within the enclave memory.
             */
            OE_WRITE_VALUE_WITH_BARRIER(
                &(return_args_host_ptr->deepcopy_out_buffer), enclave_buffer);
        }
    }

    /* The member output_bytes_written is aligned given that args_host_ptr is
     * aligned (for xAPIC vulnerability mitigation) */
    *output_bytes_written = args_host_ptr->output_bytes_written;
    result = OE_OK;

done:
    if (result != OE_OK && return_args_host_ptr)
    {
        /* Set up the local return_args for the failing case */
        return_args.result = result;
        return_args.deepcopy_out_buffer = NULL;
        return_args.deepcopy_out_buffer_size = 0;

        /* Copy the return_args to host memory */
        oe_memcpy_s_with_barrier(
            return_args_host_ptr,
            sizeof(*return_args_host_ptr),
            &return_args,
            sizeof(return_args));
    }

    return result;
}
