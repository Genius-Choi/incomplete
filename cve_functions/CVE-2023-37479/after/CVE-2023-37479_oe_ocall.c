oe_result_t oe_ocall(uint16_t func, uint64_t arg_in, uint64_t* arg_out)
{
    oe_result_t result = OE_UNEXPECTED;
    oe_sgx_td_t* td = oe_sgx_get_td();
    oe_callsite_t* callsite = td->callsites;

    /* If the enclave is in crashing/crashed status, new OCALL should fail
    immediately. */
    if (__oe_enclave_status != OE_OK)
        OE_RAISE_NO_TRACE((oe_result_t)__oe_enclave_status);

    /* Check for unexpected failures */
    if (!callsite)
        OE_RAISE_NO_TRACE(OE_UNEXPECTED);

    /* Check for unexpected failures */
    if (!td_initialized(td))
        OE_RAISE_NO_TRACE(OE_FAILURE);

    /* Preserve the FXSTATE and flags */
    asm volatile("stmxcsr %[mxcsr] \n\t" // Save MXCSR
                 "fstcw %[fcw] \n\t"     // Save x87 control word
                 "pushfq \n\t"           // Save flags.
                 "popq %[rflags] \n\t"
                 :
                 : [mxcsr] "m"(callsite->mxcsr),
                   [fcw] "m"(callsite->fcw),
                   [rflags] "m"(callsite->rflags)
                 :);

    /* Save call site where execution will resume after OCALL */
    if (oe_setjmp(&callsite->jmpbuf) == 0)
    {
        /* Exit, giving control back to the host so it can handle OCALL */
        _handle_exit(OE_CODE_OCALL, func, arg_in);

        /* Unreachable! Host will transfer control back to oe_enter() */
        oe_abort();
    }
    else
    {
        /* ORET here */

        OE_CHECK_NO_TRACE(result = (oe_result_t)td->oret_result);

        if (arg_out)
            *arg_out = td->oret_arg;

        if (td->state != OE_TD_STATE_SECOND_LEVEL_EXCEPTION_HANDLING)
        {
            /* State machine check */
            if (td->state != OE_TD_STATE_ENTERED)
                oe_abort();

            td->state = OE_TD_STATE_RUNNING;
        }
    }

    result = OE_OK;

done:
    return result;
}
