static void _handle_ecall(
    oe_sgx_td_t* td,
    uint16_t func,
    uint64_t arg_in,
    uint64_t* output_arg1,
    uint64_t* output_arg2)
{
    /* To keep status of td consistent before and after _handle_ecall, td_init
     is moved into _handle_ecall. In this way _handle_ecall will not trigger
     stack check fail by accident. Of course not all function have the
     opportunity to keep such consistency. Such basic functions are moved to a
     separate source file and the stack protector is disabled by force
     through fno-stack-protector option. */

    /* Initialize thread data structure (if not already initialized) */
    if (!td_initialized(td))
    {
        td_init(td);
    }

    oe_result_t result = OE_OK;

    /* Insert ECALL context onto front of oe_sgx_td_t.ecalls list */
    oe_callsite_t callsite = {{0}};
    uint64_t arg_out = 0;

    td_push_callsite(td, &callsite);

    // Acquire release semantics for __oe_initialized are present in
    // _handle_init_enclave.
    if (!__oe_initialized)
    {
        // The first call to the enclave must be to initialize it.
        // Global constructors can throw exceptions/signals and result in signal
        // handlers being invoked. Eg. Using CPUID instruction within a global
        // constructor. We should also allow handling these exceptions.
        if (func != OE_ECALL_INIT_ENCLAVE &&
            func != OE_ECALL_VIRTUAL_EXCEPTION_HANDLER)
        {
            goto done;
        }
    }
    else
    {
        // Disallow re-initialization.
        if (func == OE_ECALL_INIT_ENCLAVE)
        {
            goto done;
        }
    }

    // td_push_callsite increments the depth. depth > 1 indicates a reentrant
    // call. Reentrancy is allowed to handle exceptions and to terminate the
    // enclave.
    if (td->depth > 1 && (func != OE_ECALL_VIRTUAL_EXCEPTION_HANDLER &&
                          func != OE_ECALL_DESTRUCTOR))
    {
        /* reentrancy not permitted. */
        result = OE_REENTRANT_ECALL;
        goto done;
    }

    /* Dispatch the ECALL */
    switch (func)
    {
        case OE_ECALL_CALL_ENCLAVE_FUNCTION:
        {
            arg_out = oe_handle_call_enclave_function(arg_in);
            break;
        }
        case OE_ECALL_CALL_AT_EXIT_FUNCTIONS:
        {
            _call_at_exit_functions();
            break;
        }
        case OE_ECALL_DESTRUCTOR:
        {
            /* Invoke atexit functions in case the host does not invoke
             * the CALL_AT_EXIT_FUNCTIONS ecall before the DESTRUCTOR ecall
             * (retaining the previous behavior) */
            _call_at_exit_functions();

            OE_CHECK(_enclave_destructor());

            break;
        }
        case OE_ECALL_VIRTUAL_EXCEPTION_HANDLER:
        {
            oe_virtual_exception_dispatcher(td, arg_in, &arg_out);
            break;
        }
        case OE_ECALL_INIT_ENCLAVE:
        {
            arg_out = _handle_init_enclave(arg_in);
            break;
        }
        default:
        {
            /* No function found with the number */
            result = OE_NOT_FOUND;
            goto done;
        }
    }

done:

    /* Free shared memory arena before we clear TLS */
    if (td->depth == 1)
    {
        oe_teardown_arena();
    }

    /* Remove ECALL context from front of oe_sgx_td_t.ecalls list */
    td_pop_callsite(td);

    /* Perform ERET, giving control back to host */
    *output_arg1 = oe_make_call_arg1(OE_CODE_ERET, func, 0, result);
    *output_arg2 = arg_out;
}
