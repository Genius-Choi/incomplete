static oe_result_t _handle_init_enclave(uint64_t arg_in)
{
    static bool _once = false;
    oe_result_t result = OE_OK;
    /* Double checked locking (DCLP). */
    bool o = _once;

    /* DCLP Acquire barrier. */
    OE_ATOMIC_MEMORY_BARRIER_ACQUIRE();
    if (o == false)
    {
        static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;
        oe_spin_lock(&_lock);

        if (_once == false)
        {
            oe_enclave_t* enclave = (oe_enclave_t*)arg_in;

            if (!oe_is_outside_enclave(enclave, 1))
                OE_RAISE(OE_INVALID_PARAMETER);

            oe_enclave = enclave;

            /* Initialize the CPUID table before calling global constructors. */
            OE_CHECK(oe_initialize_cpuid());

            /* Initialize the xstate settings
             * Depends on TD and sgx_create_report, so can't happen earlier */
            OE_CHECK(oe_set_is_xsave_supported());

            /* Initialize libc */
            oe_libc_initialize();

            /* Initialize the OE crypto library. */
            oe_crypto_initialize();

            /* Call global constructors. Now they can safely use simulated
             * instructions like CPUID. */
            oe_call_init_functions();

            /* DCLP Release barrier. */
            OE_ATOMIC_MEMORY_BARRIER_RELEASE();
            _once = true;
            __oe_initialized = 1;
        }

        oe_spin_unlock(&_lock);
    }
done:
    return result;
}
