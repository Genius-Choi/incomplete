HttpHealthCheckerImpl::HttpActiveHealthCheckSession::healthCheckResult() {
  const uint64_t response_code = Http::Utility::getResponseStatus(*response_headers_);
  ENVOY_CONN_LOG(debug, "hc response={} health_flags={}", *client_, response_code,
                 HostUtility::healthFlagsToString(*host_));

  if (!parent_.http_status_checker_.inExpectedRanges(response_code)) {
    // If the HTTP response code would indicate failure AND the immediate health check
    // failure header is set, exclude the host from LB.
    // TODO(mattklein123): We could consider doing this check for any HTTP response code, but this
    // seems like the least surprising behavior and we could consider relaxing this in the future.
    // TODO(mattklein123): This will not force a host set rebuild of the host was already failed.
    // This is something we could do in the future but seems unnecessary right now.
    if (response_headers_->EnvoyImmediateHealthCheckFail() != nullptr) {
      host_->healthFlagSet(Host::HealthFlag::EXCLUDED_VIA_IMMEDIATE_HC_FAIL);
    }

    if (parent_.http_status_checker_.inRetriableRanges(response_code)) {
      return HealthCheckResult::Retriable;
    } else {
      return HealthCheckResult::Failed;
    }
  }

  const auto degraded = response_headers_->EnvoyDegraded() != nullptr;

  if (parent_.service_name_matcher_.has_value() &&
      parent_.runtime_.snapshot().featureEnabled("health_check.verify_cluster", 100UL)) {
    parent_.stats_.verify_cluster_.inc();
    std::string service_cluster_healthchecked =
        response_headers_->EnvoyUpstreamHealthCheckedCluster()
            ? std::string(response_headers_->getEnvoyUpstreamHealthCheckedClusterValue())
            : EMPTY_STRING;
    if (parent_.service_name_matcher_->match(service_cluster_healthchecked)) {
      return degraded ? HealthCheckResult::Degraded : HealthCheckResult::Succeeded;
    } else {
      return HealthCheckResult::Failed;
    }
  }

  return degraded ? HealthCheckResult::Degraded : HealthCheckResult::Succeeded;
}
