int icall_send_reject_msg(struct icall *icall,
			  const struct list *clientl,
			  const char *userid_local,
			  const char *clientid_local)
{
	struct list targets = LIST_INIT;
	struct le *le = NULL;
	struct econn_message *msg = NULL;
	int err = 0;

	if (!icall || !clientl || !userid_local || !clientid_local)
		return EINVAL;

	info("icall(%p): send_reject_msg\n",
	     icall);

	LIST_FOREACH(clientl, le) {
		struct icall_client *cli = le->data;
		if (cli && strcaseeq(cli->userid, userid_local) &&
		    !strcaseeq(cli->clientid, clientid_local)) {
			struct icall_client *tgt;

			tgt = icall_client_alloc(cli->userid,
						 cli->clientid);
			if (!tgt) {
				warning("icall(%p): send_reject_msg "
					"unable to alloc target\n", icall);
				goto out;
			}
			list_append(&targets, &tgt->le, tgt);
		}
	}

	info("icall(%p): send_reject_msg targets=%u\n",
	     icall,
	     list_count(&targets));

	if (list_count(&targets) > 0) {

	msg = econn_message_alloc();
	if (!msg) {
		err = ENOMEM;
		goto out;
	}

	str_ncpy(msg->src_userid, userid_local, ECONN_ID_LEN);
	str_ncpy(msg->src_clientid, clientid_local, ECONN_ID_LEN);
	msg->msg_type = ECONN_REJECT;
	msg->resp = false;

	err = ICALL_CALL_CBE((*icall), sendh,
			     icall,
			     userid_local,
			     msg, &targets, icall->arg);
	}

out:
	mem_deref(msg);
	list_flush(&targets);
	return err;
}
