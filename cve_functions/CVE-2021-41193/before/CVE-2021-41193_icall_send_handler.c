static int icall_send_handler(struct icall *icall,
			      const char *userid,
			      struct econn_message *msg,
			      struct list *targets,
			      void *arg)
{	
	struct wcall *wcall = arg;
	struct calling_instance *inst = wcall ? wcall->inst : NULL;
	struct wcall_ctx *ctx;
	void *context = wcall;
	char *str = NULL;
	char *tjson = NULL;
	char *tstr = NULL;
	int err = 0;
	char convid_anon[ANON_ID_LEN];
	char userid_anon[ANON_ID_LEN];
	char clientid_anon[ANON_CLIENT_LEN];
	struct le *le;
	size_t ntargets = 0;

	(void)icall;

	if (!WCALL_VALID(wcall)) {
		warning("wcall(%p): icall_send_handler: invalid wcall "
			"inst=%p\n", wcall, inst);
		return ENODEV;
	}
	
	if (inst->sendh == NULL)
		return ENOSYS;
       
	err = ctx_alloc(&ctx, inst, context);
	if (err)
		return err;	

	err = econn_message_encode(&str, msg);
	if (err)
		return err;

	if (targets)
		ntargets = list_count(targets);

	if (ntargets > 0) {
		char uid_anon[ANON_ID_LEN];
		char cid_anon[ANON_CLIENT_LEN];
		struct mbuf *tmb;

		tmb = mbuf_alloc(512);
		LIST_FOREACH(targets, le) {
			struct icall_client *client = le->data;

			anon_id(uid_anon, client->userid),
			anon_client(cid_anon, client->clientid),
			mbuf_printf(tmb, "[%s.%s]", uid_anon, cid_anon);
			if (le->next)
				mbuf_printf(tmb, " ");
		}
		tmb->pos = 0;
		mbuf_strdup(tmb, &tstr, tmb->end);

		mem_deref(tmb);
	}
	
	info("wcall(%p): c3_message_send: convid=%s from=%s.%s to=%s "
	     "msg=%H ctx=%p\n",
	     wcall, anon_id(convid_anon, wcall->convid),
	     anon_id(userid_anon, userid), anon_client(clientid_anon, inst->clientid),
	     ntargets == 0 ? "ALL" : tstr,
	     econn_message_brief, msg, ctx);

	if (ntargets > 0) {
		err = targets_json(wcall, targets, &tjson);
		if (err)
			goto out;
	}

	err = inst->sendh(ctx, wcall->convid, userid, inst->clientid,
			  tjson, NULL, (uint8_t *)str, strlen(str),
			  msg->transient ? 1 : 0, inst->arg);

out:
	mem_deref(str);
	mem_deref(tstr);
	mem_deref(tjson);

	return err;
}
