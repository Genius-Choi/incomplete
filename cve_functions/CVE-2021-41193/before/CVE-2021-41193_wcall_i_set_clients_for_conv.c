void wcall_i_set_clients_for_conv(struct wcall *wcall, const char *json)
{
	struct json_object *jobj, *jclients;
	size_t nclients, i;
	struct list clientl = LIST_INIT;
	
	size_t len;
	int err = 0;

	if (!wcall) {
		warning("wcall; set_clients_for_conv: no wcall\n");
		return;
	}
	
	if (!wcall->icall) {
		warning("wcall; set_clients_for_conv: no icall\n");
		return;
	}

	info(APITAG "wcall(%p): set_clients_for_conv\n", wcall);

	len = strlen(json);
	err = jzon_decode(&jobj, json, len);
	if (err)
		return;

#if 0
	jzon_dump(jobj);
#endif

	err = jzon_array(&jclients, jobj, "clients");
	if (err)
		goto out;

	if (!jzon_is_array(jclients)) {
		warning("json object is not an array\n");
		goto out;
	}

	nclients = json_object_array_length(jclients);

	for (i = 0; i < nclients; ++i) {
		const char *uid, *cid;
		struct json_object *jcli;
		struct icall_client *cli;

		jcli = json_object_array_get_idx(jclients, i);
		if (!jcli) {
			goto out;
		}

		uid = jzon_str(jcli, "userid");
		cid = jzon_str(jcli, "clientid");
		if (uid && cid) {
			cli = icall_client_alloc(uid, cid);
			list_append(&clientl, &cli->le, cli);
		}
	}

	ICALL_CALL(wcall->icall, set_clients,
		&clientl);

out:
	mem_deref(jobj);
	list_flush(&clientl);
	return;
}
