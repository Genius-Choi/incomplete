static void data_channel_handler(struct iflow *iflow,
				 const uint8_t *data, 
				 size_t len,
				 void *arg)
{
	struct ecall *ecall = arg;
	struct econn_message *msg = 0;
	char convid_anon[ANON_ID_LEN];
	char userid_anon[ANON_ID_LEN];
	char clientid_anon[ANON_CLIENT_LEN];
	char dest_userid_anon[ANON_ID_LEN];
	char dest_clientid_anon[ANON_CLIENT_LEN];
	int err;

	assert(ECALL_MAGIC == ecall->magic);

	if (iflow != ecall->flow) {
		info("ecall(%p): ignoring %s on wrong flow\n", ecall, __FUNCTION__);
		return;
	}

	err = econn_message_decode(&msg, 0, 0, (char *)data, len);
	if (err) {
		warning("ecall: channel: failed to decode %zu bytes (%m)\n",
			len, err);
		return;
	}

	/* Check that message was received via correct transport */
	if (ECONN_TRANSP_DIRECT != econn_transp_resolve(msg->msg_type)) {
		warning("ecall: dc_recv: wrong transport for type %s\n",
			econn_msg_name(msg->msg_type));
	}

	if (msg->msg_type != ECONN_PING) {
		info("ecall(%p): dce_message_recv: convid=%s from=%s.%s to=%s.%s "
		     "msg=%H\n",
		     ecall, anon_id(convid_anon, ecall->convid),
		     anon_id(dest_userid_anon, ecall->userid_peer),
		     anon_client(dest_clientid_anon, ecall->clientid_peer),
		     anon_id(userid_anon, ecall->userid_self),
		     anon_client(clientid_anon, ecall->clientid_self),
		     econn_message_print, msg);

		ecall_trace(ecall, msg, false, ECONN_TRANSP_DIRECT,
			    "DataChan %H\n", econn_message_brief, msg);
	}

	if (msg->msg_type == ECONN_PROPSYNC) {
		handle_propsync(ecall, msg);
	}
	else {
		/* forward message to ECONN */
		econn_recv_message(ecall->econn, econn_userid_remote(ecall->econn),
				   econn_clientid_remote(ecall->econn), msg);
	}

	mem_deref(msg);
}
