int econn_message_decode(struct econn_message **msgp,
			 uint64_t curr_time, uint64_t msg_time,
			 const char *str, size_t len)
{
	struct econn_message *msg = NULL;
	struct json_object *jobj = NULL;
	const char *ver, *type, *sdp, *sessid, *userid, *clientid;
	int err;

	if (!msgp || !str)
		return EINVAL;

	err = jzon_decode(&jobj, str, len);
	if (err)
		return err;

	msg = econn_message_alloc();
	if (!msg) {
		err = ENOMEM;
		goto out;
	}

	ver = jzon_str(jobj, "version");
	if (!ver) {
		warning("econn: missing 'version' field\n");
		err = EBADMSG;
		goto out;
	}

	if (0 != str_casecmp(econn_proto_version, ver)) {
		warning("econn: version mismatch (us=%s, msg=%s)\n",
			econn_proto_version, ver);
		err = EPROTO;
		goto out;
	}

	type = jzon_str(jobj, "type");
	if (!type) {
		warning("econn: missing 'type' field\n");
		err = EBADMSG;
		goto out;
	}

	sessid = jzon_str(jobj, "sessid");
	if (!sessid) {
		warning("econn: missing 'sessid' field\n");
		goto out;
	}
	str_ncpy(msg->sessid_sender, sessid, sizeof(msg->sessid_sender));

	userid = jzon_str(jobj, "src_userid");
	str_ncpy(msg->src_userid, userid, sizeof(msg->src_userid));

	clientid = jzon_str(jobj, "src_clientid");
	str_ncpy(msg->src_clientid, clientid, sizeof(msg->src_clientid));

	userid = jzon_str(jobj, "dest_userid");
	str_ncpy(msg->dest_userid, userid, sizeof(msg->dest_userid));

	clientid = jzon_str(jobj, "dest_clientid");
	str_ncpy(msg->dest_clientid, clientid, sizeof(msg->dest_clientid));

	err = jzon_bool(&msg->resp, jobj, "resp");
	if (err) {
		warning("econn: missing 'resp' field\n");
		goto out;
	}

	if (0 == str_casecmp(type, econn_msg_name(ECONN_SETUP))) {
		const char *url;

		msg->msg_type = ECONN_SETUP;

		sdp = jzon_str(jobj, "sdp");
		if (!sdp) {
			warning("econn: missing 'sdp' field\n");
			err = EBADMSG;
			goto out;
		}

		err = str_dup(&msg->u.setup.sdp_msg, sdp);
		if (err)
			goto out;

		err = econn_props_decode(&msg->u.setup.props, jobj);
		if (err)
			goto out;

		url = jzon_str(jobj, "url");
		if (url)
			str_dup(&msg->u.setup.url, url);
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_GROUP_SETUP))) {

		msg->msg_type = ECONN_GROUP_SETUP;

		sdp = jzon_str(jobj, "sdp");
		if (!sdp) {
			warning("econn: missing 'sdp' field\n");
			err = EBADMSG;
			goto out;
		}

		err = str_dup(&msg->u.setup.sdp_msg, sdp);
		if (err)
			goto out;

		err = econn_props_decode(&msg->u.setup.props, jobj);
		if (err)
			goto out;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_UPDATE))) {

		msg->msg_type = ECONN_UPDATE;

		sdp = jzon_str(jobj, "sdp");
		if (!sdp) {
			warning("econn: missing 'sdp' field\n");
			err = EBADMSG;
			goto out;
		}

		err = str_dup(&msg->u.setup.sdp_msg, sdp);
		if (err)
			goto out;

		err = econn_props_decode(&msg->u.setup.props, jobj);
		if (err)
			info("econn: decode UPDATE: no props\n");
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CANCEL))) {

		msg->msg_type = ECONN_CANCEL;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_HANGUP))) {

		msg->msg_type = ECONN_HANGUP;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_REJECT))) {

		msg->msg_type = ECONN_REJECT;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_PROPSYNC))) {

		msg->msg_type = ECONN_PROPSYNC;

		err = econn_props_decode(&msg->u.propsync.props, jobj);
		if (err)
			goto out;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_GROUP_START))) {

		msg->msg_type = ECONN_GROUP_START;

		/* Props are optional, 
		 * dont fail to decode message if they are missing
		 */
		if (econn_props_decode(&msg->u.groupstart.props, jobj))
			info("econn: decode GROUPSTART: no props\n");
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_GROUP_LEAVE))) {
		
		msg->msg_type = ECONN_GROUP_LEAVE;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_GROUP_CHECK))) {

		msg->msg_type = ECONN_GROUP_CHECK;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CONF_START))) {
		struct pl pl = PL_INIT;
		const char *secret;
		uint8_t *sdata;
		size_t slen;

		msg->msg_type = ECONN_CONF_START;

		err = jzon_strdup(&msg->u.confstart.sft_url, jobj, "sft_url");
		if (err) {
			warning("econn: decode CONFSTART: couldnt read SFT URL\n");
			goto out;
		}
		pl_set_str(&pl, jzon_str(jobj, "timestamp"));
		msg->u.confstart.timestamp = pl_u64(&pl);
		pl_set_str(&pl, jzon_str(jobj, "seqno"));
		msg->u.confstart.seqno = pl_u32(&pl);

		secret = jzon_str(jobj, "secret");
		if (!secret || err)
			return EBADMSG;

		slen = str_len(secret) * 3 / 4;

		sdata = mem_zalloc(slen, NULL);
		if (!sdata) {
			return ENOMEM;
		}
		err = base64_decode(secret, str_len(secret), sdata, &slen);
		if (err) {
			mem_deref(sdata);
			return err;
		}

		msg->u.confstart.secret = sdata;
		msg->u.confstart.secretlen = slen;
		/* Props are optional, dont fail to decode message if they are missing */
		if (econn_props_decode(&msg->u.confstart.props, jobj))
			info("econn: decode CONFSTART: no props\n");
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CONF_CHECK))) {
		struct pl pl = PL_INIT;
		const char *secret;
		uint8_t *sdata;
		size_t slen;

		msg->msg_type = ECONN_CONF_CHECK;

		err = jzon_strdup(&msg->u.confcheck.sft_url, jobj, "sft_url");
		if (err) {
			warning("econn: decode CONFCHECK: couldnt read SFT URL\n");
			goto out;
		}
		pl_set_str(&pl, jzon_str(jobj, "timestamp"));
		msg->u.confcheck.timestamp = pl_u64(&pl);
		pl_set_str(&pl, jzon_str(jobj, "seqno"));
		msg->u.confcheck.seqno = pl_u32(&pl);

		secret = jzon_str(jobj, "secret");
		if (!secret || err)
			return EBADMSG;

		slen = str_len(secret) * 3 / 4;

		sdata = mem_zalloc(slen, NULL);
		if (!sdata) {
			return ENOMEM;
		}
		err = base64_decode(secret, str_len(secret), sdata, &slen);
		if (err) {
			mem_deref(sdata);
			return err;
		}

		msg->u.confcheck.secret = sdata;
		msg->u.confcheck.secretlen = slen;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CONF_CONN))) {
		struct json_object *jturns;
		const char *tool_str = NULL;
		int32_t status = 0, vstreams = 0;
		bool selective_audio = false, selective_video = false;

		msg->msg_type = ECONN_CONF_CONN;

		err = jzon_array(&jturns, jobj, "ice_servers");
		if (!err) {
			err = zapi_iceservers_decode(jturns,
						     &msg->u.confconn.turnv,
						     &msg->u.confconn.turnc);
			if (err) {
				warning("econn: confconn: "
					"could not decode ICE servers (%m)\n", err);
				goto out;
			}
		}

		jzon_bool(&msg->u.confconn.update, jobj,
			  "update");

		tool_str = jzon_str(jobj, "tool");
		if (tool_str) {
			err = str_dup(&msg->u.confconn.tool, tool_str);
			if (err)
				goto out;
		}

		tool_str = jzon_str(jobj, "toolver");
		if (tool_str) {
			err = str_dup(&msg->u.confconn.toolver, tool_str);
			if (err)
				goto out;
		}

		/* status is optional, missing = 0 */
		err = jzon_int(&status, jobj, "status");
		if (err) {
			status = 0;
			err = 0;
		}

		msg->u.confconn.status = (enum econn_confconn_status) status;

		/* selective_audio is optional, missing = false */
		err = jzon_bool(&selective_audio, jobj, "selective_audio");
		if (err) {
			selective_audio = false;
			err = 0;
		}
		msg->u.confconn.selective_audio = selective_audio;

		/* selective_video is optional, missing = false */
		err = jzon_bool(&selective_video, jobj, "selective_video");
		if (err) {
			selective_video = false;
			err = 0;
		}
		msg->u.confconn.selective_video = selective_video;

		/* vstreams is optional, missing = 0, range 0 to 32 */
		err = jzon_int(&vstreams, jobj, "vstreams");
		if (err) {
			vstreams = 0;
			err = 0;
		}
		if (vstreams < 0)
			vstreams = 0;
		if (vstreams > 32)
			vstreams = 32;
		msg->u.confconn.vstreams = vstreams;

	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CONF_END))) {
		msg->msg_type = ECONN_CONF_END;
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CONF_PART))) {
		struct pl pl = PL_INIT;
		const char *entropy;
		uint8_t *edata;
		size_t elen;

		msg->msg_type = ECONN_CONF_PART;

		jzon_bool(&msg->u.confpart.should_start, jobj,
			  "should_start");
		pl_set_str(&pl, jzon_str(jobj, "timestamp"));
		msg->u.confpart.timestamp = pl_u64(&pl);
		pl_set_str(&pl, jzon_str(jobj, "seqno"));
		msg->u.confpart.seqno = pl_u32(&pl);

		entropy = jzon_str(jobj, "entropy");
		if (entropy) {
			elen = str_len(entropy) * 3 / 4;

			edata = mem_zalloc(elen, NULL);
			if (!edata) {
				return ENOMEM;
			}
			err = base64_decode(entropy, str_len(entropy), edata, &elen);
			if (err) {
				mem_deref(edata);
				return err;
			}

			msg->u.confpart.entropy = edata;
			msg->u.confpart.entropylen = elen;
		}

		if (econn_parts_decode(&msg->u.confpart.partl, jobj))
			warning("econn: decode: CONF_PART no parts\n");
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_CONF_KEY))) {
		msg->msg_type = ECONN_CONF_KEY;
		err = econn_keys_decode(&msg->u.confkey.keyl, jobj);
		if (err)
			return err;
	}
	else if (0 == str_casecmp(type,
				  econn_msg_name(ECONN_DEVPAIR_PUBLISH))) {

		struct json_object *jturns;

		msg->msg_type = ECONN_DEVPAIR_PUBLISH;

		err = jzon_array(&jturns, jobj, "ice_servers");
		if (err) {
			warning("econn: devpair_publish: no ICE servers\n");
			goto out;
		}

		err = zapi_iceservers_decode(jturns,
					     &msg->u.devpair_publish.turnv,
					     &msg->u.devpair_publish.turnc);
		if (err) {
			warning("econn: devpair_publish: "
				"could not decode ICE servers (%m)\n", err);
			goto out;
		}

		err = jzon_strdup(&msg->u.devpair_publish.sdp,
				  jobj, "sdp");
		if (err) {
			warning("econn: devpair_publish: "
				"could not find SDP in message\n");
			goto out;
		}
		err = jzon_strdup(&msg->u.devpair_publish.username,
				  jobj, "username");
		if (err) {
			warning("econn: devpair_publish: "
				"could not find username in message\n");
			goto out;
		}
	}
	else if (0 == str_casecmp(type,
				  econn_msg_name(ECONN_DEVPAIR_ACCEPT))) {

		msg->msg_type = ECONN_DEVPAIR_ACCEPT;

		err = jzon_strdup(&msg->u.devpair_accept.sdp,
				  jobj, "sdp");
		if (err) {
			warning("econn: devpair_accept: "
				"could not find SDP in message\n");
			goto out;
		}
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_ALERT))) {

		msg->msg_type = ECONN_ALERT;

		err = jzon_u32(&msg->u.alert.level, jobj, "level");
		if (err) {
			warning("econn: alert: "
				"could not find level in message\n");
			goto out;
		}

		err = jzon_strdup(&msg->u.alert.descr,
				  jobj, "descr");
		if (err) {
			warning("econn: alert: "
				"could not find descr in message\n");
			goto out;
		}
	}
	else if (0 == str_casecmp(type, econn_msg_name(ECONN_PING))) {
		msg->msg_type = ECONN_PING;
	}
	else {
		warning("econn: decode: unknown message type '%s'\n", type);
		err = EPROTONOSUPPORT;
		goto out;
	}

	msg->time = msg_time;
	msg->age = (msg_time > curr_time) ? 0 : curr_time - msg_time;

#if 0
	re_printf("%H\n", jzon_encode_odict_pretty, jzon_get_odict(jobj));
#endif

 out:
	mem_deref(jobj);
	if (err)
		mem_deref(msg);
	else
		*msgp = msg;

	return err;
}
