static void mf_close_handler(struct iflow *iflow, int err, void *arg)
{
	struct ecall *ecall = arg;
	char userid_anon[ANON_ID_LEN];

	assert(ECALL_MAGIC == ecall->magic);

	info("ecall(%p): flow(%p) closed user=%s err=%m\n", ecall, iflow,
		anon_id(userid_anon, ecall->userid_self), err);

	if (iflow == ecall->oldflow) {
		struct iflow *oldflow = ecall->oldflow;

		info("ecall(%p): %s oldflow: %p closed\n", ecall, __FUNCTION__, oldflow);
		ecall->oldflow = NULL;
		IFLOW_CALL(oldflow, close);
		return;
	}
	if (iflow != ecall->flow) {
		info("ecall(%p): ignoring %s on wrong flow\n", ecall, __FUNCTION__);
		return;
	}

	enum econn_state state = econn_current_state(ecall->econn);
	if (ECONN_ANSWERED == state && ETIMEDOUT == err &&
		ecall->num_retries < ecall->max_retries) {
		ecall_restart(ecall, ecall->call_type);
	}
	else if (ecall->econn) {
		econn_set_error(ecall->econn, err);

		ecall_end(ecall);
	}
	else {
		/* notify upwards */
		ecall_close(ecall, err, ECONN_MESSAGE_TIME_UNKNOWN);
	}
}
