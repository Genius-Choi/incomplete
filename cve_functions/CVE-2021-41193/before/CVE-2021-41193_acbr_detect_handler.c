static void acbr_detect_handler(struct iflow *iflow,
				int enabled,
				void *arg)
{
	bool cbr_enabled = false;
	bool local_cbr = false;
	bool remote_cbr = false;
	const char *cr, *cl;

	struct ecall *ecall = arg;

	assert(ECALL_MAGIC == ecall->magic);

	if (iflow != ecall->flow) {
		info("ecall(%p): ignoring %s on wrong flow\n",
		     ecall, __FUNCTION__);
		return;
	}

	cl = ecall_props_get_local(ecall, "audiocbr");
	local_cbr = cl && (0 == strcmp(cl, "true"));

	cr = ecall_props_get_remote(ecall, "audiocbr");
	remote_cbr = cr && (0 == strcmp(cr, "true"));

	cbr_enabled = (enabled != 0) && (remote_cbr && local_cbr);
	if (enabled != ecall->audio.cbr_state) {
		info("ecall(%p): acbrh(%p) enabled=%d "
		     "lcbr=%s rcbr=%s cbr=%d\n",
		     ecall, ecall->icall.acbr_changedh,
		     enabled,
		     local_cbr ? "true" : "false",
		     remote_cbr ? "true" : "false",
		     cbr_enabled);

		if (ecall->icall.acbr_changedh) {
			ICALL_CALL_CB(ecall->icall, acbr_changedh,
				      &ecall->icall, ecall->userid_peer,
				      ecall->clientid_peer,
				      cbr_enabled, ecall->icall.arg);
			ecall->audio.cbr_state = cbr_enabled;
		}
	}
}
