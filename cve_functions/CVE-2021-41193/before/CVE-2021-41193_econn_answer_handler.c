static void econn_answer_handler(struct econn *conn, bool reset,
				 const char *sdp, struct econn_props *props,
				 void *arg)
{
	struct ecall *ecall = arg;
	int err = 0;
	char userid_anon[ANON_ID_LEN];
	char clientid_anon[ANON_CLIENT_LEN];

	assert(ECALL_MAGIC == ecall->magic);

	info("ecall(%p): [ %s.%s ] ecall: answered (reset=%d, sdp=%p)\n",
	     ecall, anon_id(userid_anon, ecall->userid_self),
	     anon_client(clientid_anon, ecall->clientid_self), reset, sdp);

	ecall->audio_setup_time = -1;
	ecall->call_estab_time = -1;
	ecall->ts_answered = tmr_jiffies();

	if (reset) {
		// Reset state replaced with full re-reation of mf
		
		bool muted = msystem_get_muted();
		err = alloc_flow(ecall, ASYNC_ANSWER, ecall->call_type, false);
		msystem_set_muted(muted);
		if (err) {
			warning("ecall: re-start: alloc_flow failed: %m\n", err);
			goto error;
		}
		
		IFLOW_CALL(ecall->flow, set_remote_userclientid,
			econn_userid_remote(conn),
			econn_clientid_remote(conn));

		ecall->sdp.async = ASYNC_NONE;
		set_offer_sdp(ecall, sdp);
		err = generate_or_gather_answer(ecall, conn);
		if (err) {
			warning("ecall: generate_answer\n");
			goto error;
		}

		ecall->answered = true;

		return;
	}

	if (ecall->answered) {
		warning("ecall: answer_handler: already connected\n");
		return;
	}

	IFLOW_CALL(ecall->flow, set_remote_userclientid,
		econn_userid_remote(conn),
		econn_clientid_remote(conn));

	IFLOW_CALL(ecall->flow, handle_answer, sdp);
	if (err) {
		warning("ecall: answer_handler: handle_answer failed"
			" (%m)\n", err);
		goto error;
	}

	ecall->props_remote = mem_ref(props);

	ecall->answered = true;

	ICALL_CALL_CB(ecall->icall, answerh,
		&ecall->icall, ecall->icall.arg);

	if (!ecall->established) {
		tmr_start(&ecall->connection_tmr, TIMEOUT_CONNECTION,
			  connection_timeout_handler, ecall);
	}
	return;

 error:
	/* if error, close the call */
	ecall_close(ecall, err, ECONN_MESSAGE_TIME_UNKNOWN);
}
