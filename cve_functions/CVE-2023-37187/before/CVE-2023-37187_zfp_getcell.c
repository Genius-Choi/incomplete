int zfp_getcell(void *thread_context, const uint8_t *block, int32_t cbytes, uint8_t *dest, int32_t destsize) {
  struct thread_context *thread_ctx = thread_context;
  blosc2_context *context = thread_ctx->parent_context;
  bool meta = false;
  int8_t ndim = ZFP_MAX_DIM + 1;
  int32_t blockmeta[ZFP_MAX_DIM];
  if (context->schunk->blockshape == NULL) {
    // blockshape is not filled yet.  Use the Blosc2 NDim layer to populate it.
    for (int nmetalayer = 0; nmetalayer < context->schunk->nmetalayers; nmetalayer++) {
      if (strcmp("b2nd", context->schunk->metalayers[nmetalayer]->name) == 0) {
        meta = true;
        uint8_t *pmeta = context->schunk->metalayers[nmetalayer]->content;
        ndim = (int8_t) pmeta[2];
        assert(ndim <= ZFP_MAX_DIM);
        pmeta += (6 + ndim * 9 + ndim * 5);
        for (int8_t i = 0; (uint8_t) i < ndim; i++) {
          pmeta += 1;
          swap_store(blockmeta + i, pmeta, sizeof(int32_t));
          pmeta += sizeof(int32_t);
        }
      }
    }
    if (!meta) {
      return -1;
    }
    context->schunk->ndim = ndim;
    context->schunk->blockshape = malloc(sizeof(int64_t) * ndim);
    for (int i = 0; i < ndim; ++i) {
      context->schunk->blockshape[i] = (int64_t) blockmeta[i];
    }
  }
  ndim = context->schunk->ndim;
  int64_t *blockshape = context->schunk->blockshape;

  // Compute the coordinates of the cell
  int64_t cell_start_ndim[ZFP_MAX_DIM];
  int64_t cell_ind_ndim[ZFP_MAX_DIM];
  int64_t ncell_ndim[ZFP_MAX_DIM];
  int64_t ind_strides[ZFP_MAX_DIM];
  int64_t cell_strides[ZFP_MAX_DIM];
  int64_t cell_ind, ncell;
  blosc2_unidim_to_multidim(ndim, blockshape, thread_ctx->zfp_cell_start, cell_start_ndim);
  for (int i = 0; i < ndim; ++i) {
    cell_ind_ndim[i] = cell_start_ndim[i] % ZFP_MAX_DIM;
    ncell_ndim[i] = cell_start_ndim[i] / ZFP_MAX_DIM;
  }
  ind_strides[ndim - 1] = cell_strides[ndim - 1] = 1;
  for (int i = ndim - 2; i >= 0; --i) {
    ind_strides[i] = ZFP_MAX_DIM * ind_strides[i + 1];
    cell_strides[i] = ((blockshape[i + 1] - 1) / ZFP_MAX_DIM + 1) * cell_strides[i + 1];
  }
  blosc2_multidim_to_unidim(cell_ind_ndim, (int8_t) ndim, ind_strides, &cell_ind);
  blosc2_multidim_to_unidim(ncell_ndim, (int8_t) ndim, cell_strides, &ncell);
  int cell_nitems = (int) (1u << (2 * ndim));
  if ((thread_ctx->zfp_cell_nitems > cell_nitems) ||
      ((cell_ind + thread_ctx->zfp_cell_nitems) > cell_nitems)) {
    return 0;
  }

  // Get the ZFP stream
  zfp_type type;     /* array scalar type */
  zfp_stream *zfp;   /* compressed stream */
  bitstream *stream; /* bit stream to write to or read from */
  int32_t typesize = context->typesize;
  zfp = zfp_stream_open(NULL);

  switch (typesize) {
    case sizeof(float):
      type = zfp_type_float;
      break;
    case sizeof(double):
      type = zfp_type_double;
      break;
    default:
      BLOSC_TRACE_ERROR("ZFP is not available for typesize: %d", typesize);
      return BLOSC2_ERROR_FAILURE;
  }
  uint8_t compmeta = context->compcode_meta;   // access to compressed chunk header
  double rate = (double) (compmeta * typesize * 8) /
                100.0;     // convert from output size / input size to output bits per input value
  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);

  stream = stream_open((void *) block, cbytes);
  zfp_stream_set_bit_stream(zfp, stream);
  zfp_stream_rewind(zfp);

  // Check that ncell is a valid index
  int ncells = (int) ((cbytes * 8) / zfp->maxbits);
  if (ncell >= ncells) {
    BLOSC_TRACE_ERROR("Invalid cell index");
    return -1;
  }

  // Position the stream at the ncell bit offset for reading
  stream_rseek(zfp->stream, (size_t) (ncell * zfp->maxbits));

  // Get the cell
  size_t zfpsize;
  uint8_t *cell = malloc(cell_nitems * typesize);
  switch (ndim) {
    case 1:
      if (type == zfp_type_float) {
        zfpsize = zfp_decode_block_float_1(zfp, (float *) cell);
      }
      else {
        zfpsize = zfp_decode_block_double_1(zfp, (double *) cell);
      }
      break;
    case 2:
      if (type == zfp_type_float) {
        zfpsize = zfp_decode_block_float_2(zfp, (float *) cell);
      }
      else {
        zfpsize = zfp_decode_block_double_2(zfp, (double *) cell);
      }
      break;
    case 3:
      if (type == zfp_type_float) {
        zfpsize = zfp_decode_block_float_3(zfp, (float *) cell);
      }
      else {
        zfpsize = zfp_decode_block_double_3(zfp, (double *) cell);
      }
      break;
    case 4:
      if (type == zfp_type_float) {
        zfpsize = zfp_decode_block_float_4(zfp, (float *) cell);
      }
      else {
        zfpsize = zfp_decode_block_double_4(zfp, (double *) cell);
      }
      break;
    default:
      BLOSC_TRACE_ERROR("ZFP is not available for ndims: %d", ndim);
      return BLOSC2_ERROR_FAILURE;
  }
  memcpy(dest, &cell[cell_ind * typesize], thread_ctx->zfp_cell_nitems * typesize);
  zfp_stream_close(zfp);
  stream_close(stream);
  free(cell);

  if ((zfpsize == 0) || ((int32_t) zfpsize > (destsize * 8)) ||
      ((int32_t) zfpsize > (cell_nitems * typesize * 8)) ||
      ((thread_ctx->zfp_cell_nitems * typesize * 8) > (int32_t) zfpsize)) {
    BLOSC_TRACE_ERROR("ZFP error or small destsize");
    return -1;
  }

  return (int) (thread_ctx->zfp_cell_nitems * typesize);
}
