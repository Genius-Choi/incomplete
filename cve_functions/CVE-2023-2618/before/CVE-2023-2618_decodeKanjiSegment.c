void DecodedBitStreamParser::decodeKanjiSegment(Ref<BitSource> bits, std::string& result, int count,
                                                ErrorHandler& err_handler) {
    // Each character will require 2 bytes. Read the characters as 2-byte pairs
    // and decode as Shift_JIS afterwards
    size_t nBytes = 2 * count;
    char* buffer = new char[nBytes];
    int offset = 0;
    while (count > 0) {
        // Each 13 bits encodes a 2-byte character

        int twoBytes = bits->readBits(13, err_handler);
        if (err_handler.ErrCode()) return;
        int assembledTwoBytes = ((twoBytes / 0x0C0) << 8) | (twoBytes % 0x0C0);
        if (assembledTwoBytes < 0x01F00) {
            // In the 0x8140 to 0x9FFC range
            assembledTwoBytes += 0x08140;
        } else {
            // In the 0xE040 to 0xEBBF range
            assembledTwoBytes += 0x0C140;
        }
        buffer[offset] = (char)(assembledTwoBytes >> 8);
        buffer[offset + 1] = (char)assembledTwoBytes;
        offset += 2;
        count--;
    }

    append(result, buffer, nBytes, err_handler);
    if (err_handler.ErrCode()) {
        delete[] buffer;
        return;
    }
    // cout<<buffer<<endl;
    delete[] buffer;
}
