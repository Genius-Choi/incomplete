void DecodedBitStreamParser::decodeByteSegment(Ref<BitSource> bits_, string& result, int count,
                                               CharacterSetECI* currentCharacterSetECI,
                                               ArrayRef<ArrayRef<char> >& byteSegments,
                                               ErrorHandler& err_handler) {
    BitSource& bits(*bits_);
    // Don't crash trying to read more bits than we have available.
    int available = bits.available();
    // try to repair count data if count data is invalid
    if (count * 8 > available) {
        count = (available + 7) / 8;
    }
    size_t nBytes = count;

    ArrayRef<char> bytes_(nBytes);
    // issue https://github.com/opencv/opencv_contrib/issues/3478
    if (bytes_->empty())
        return;

    char* readBytes = &(*bytes_)[0];
    for (int i = 0; i < count; i++) {
        //    readBytes[i] = (char) bits.readBits(8);
        int readBits = available < 8 ? available : 8;
        readBytes[i] = (char)bits.readBits(readBits, err_handler);
    }
    if (err_handler.ErrCode()) return;
    // vector<string> encoding;
    string encoding;

    if (currentCharacterSetECI == 0) {
        // The spec isn't clear on this mode; see
        // section 6.4.5: t does not say which encoding to assuming
        // upon decoding. I have seen ISO-8859-1 used as well as
        // Shift_JIS -- without anything like an ECI designator to
        // give a hint.
        encoding = outputCharset;

    } else {
        // encoding .push_back(currentCharacterSetECI->name());
        encoding = currentCharacterSetECI->name();
    }
    // cout<<"encoding: "<<encoding<<endl;

    append(result, readBytes, nBytes, err_handler);
    if (err_handler.ErrCode()) return;

    byteSegments->values().push_back(bytes_);
}
