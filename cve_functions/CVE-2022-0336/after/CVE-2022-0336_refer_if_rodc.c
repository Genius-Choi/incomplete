static char *refer_if_rodc(struct ldb_context *ldb, struct ldb_request *req,
			   struct ldb_dn *dn)
{
	bool rodc = false;
	struct loadparm_context *lp_ctx;
	char *referral;
	int ret;
	WERROR err;

	if (ldb_request_get_control(req, DSDB_CONTROL_REPLICATED_UPDATE_OID) ||
	    ldb_request_get_control(req, DSDB_CONTROL_DBCHECK_MODIFY_RO_REPLICA)) {
		return NULL;
	}

	ret = samdb_rodc(ldb, &rodc);
	if (ret != LDB_SUCCESS) {
		DEBUG(4, (__location__ ": unable to tell if we are an RODC\n"));
		return NULL;
	}

	if (rodc) {
		const char *domain = NULL;
		struct ldb_dn *fsmo_role_dn;
		struct ldb_dn *role_owner_dn;
		ldb_set_errstring(ldb, "RODC modify is forbidden!");
		lp_ctx = talloc_get_type(ldb_get_opaque(ldb, "loadparm"),
					 struct loadparm_context);

		err = dsdb_get_fsmo_role_info(req, ldb, DREPL_PDC_MASTER,
					      &fsmo_role_dn, &role_owner_dn);
		if (W_ERROR_IS_OK(err)) {
			struct ldb_dn *server_dn = ldb_dn_copy(req, role_owner_dn);
			if (server_dn != NULL) {
				ldb_dn_remove_child_components(server_dn, 1);

				domain = samdb_dn_to_dnshostname(ldb, req,
								 server_dn);
			}
		}
		if (domain == NULL) {
			domain = lpcfg_dnsdomain(lp_ctx);
		}
		referral = talloc_asprintf(req,
					   "ldap://%s/%s",
					   domain,
					   ldb_dn_get_linearized(dn));
		return referral;
	}

	return NULL;
}
