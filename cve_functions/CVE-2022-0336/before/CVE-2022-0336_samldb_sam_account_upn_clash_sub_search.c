static inline int samldb_sam_account_upn_clash_sub_search(
	struct samldb_ctx *ac,
	TALLOC_CTX *mem_ctx,
	struct ldb_dn *base_dn,
	const char *attr,
	const char *value,
	const char *err_msg
	)
{
	/*
	 * A very specific helper function for samldb_sam_account_upn_clash(),
	 * where we end up doing this same thing several times in a row.
	 */
	const char * const no_attrs[] = { NULL };
	struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
	struct ldb_result *res = NULL;
	int ret;
	char *enc_value = ldb_binary_encode_string(ac, value);
	if (enc_value == NULL) {
		return ldb_module_oom(ac->module);
	}
	ret = dsdb_module_search(ac->module, mem_ctx, &res,
				 base_dn,
				 LDB_SCOPE_SUBTREE, no_attrs,
				 DSDB_FLAG_NEXT_MODULE, ac->req,
				 "(%s=%s)",
				 attr, enc_value);
	talloc_free(enc_value);

	if (ret != LDB_SUCCESS) {
		return ret;
	} else if (res->count > 1) {
		return ldb_operr(ldb);
	} else if (res->count == 1) {
		if (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0){
			ldb_asprintf_errstring(ldb,
					       "samldb: %s '%s' "
					       "is already in use %s",
					       attr, value, err_msg);
			/* different errors for different attrs */
			if (strcasecmp("userPrincipalName", attr) == 0) {
				return LDB_ERR_CONSTRAINT_VIOLATION;
			}
			return LDB_ERR_ENTRY_ALREADY_EXISTS;
		}
	}
	return LDB_SUCCESS;
}
