static int user_coll_fill(struct user_coll *c, char *users,
                          struct user_coll *cmp_c, int take_over_cmp)
{
  char *orig_users= users;
  char *cmp_user= 0;
  size_t cmp_length;
  int refill_cmp_coll= 0;

  c->n_users= 0;

  while (*users)
  {
    while (*users == ' ')
      users++;
    if (!*users)
      return 0;

    (void) getkey_user(users, &cmp_length, FALSE);
    if (cmp_c)
    {
      cmp_user= coll_search(cmp_c, users, cmp_length);

      if (cmp_user && take_over_cmp)
      {
        ADD_ATOMIC(internal_stop_logging, 1);
        CLIENT_ERROR(1, "User '%.*b' was removed from the"
            " server_audit_excl_users.",
            MYF(ME_JUST_WARNING), (int) cmp_length, users);
        ADD_ATOMIC(internal_stop_logging, -1);
        blank_user(cmp_user);
        refill_cmp_coll= 1;
      }
      else if (cmp_user)
      {
        ADD_ATOMIC(internal_stop_logging, 1);
        CLIENT_ERROR(1, "User '%.*b' is in the server_audit_incl_users, "
            "so wasn't added.", MYF(ME_JUST_WARNING), (int) cmp_length, users);
        ADD_ATOMIC(internal_stop_logging, -1);
        remove_user(users);
        continue;
      }
    }
    if (coll_insert(c, users, cmp_length))
      return 1;
    while (*users && *users != ',')
      users++;
    if (!*users)
      break;
    users++;
  }

  if (refill_cmp_coll)
  {
    remove_blanks(excl_users);
    return user_coll_fill(cmp_c, excl_users, 0, 0);
  }

  if (users > orig_users && users[-1] == ',')
    users[-1]= 0;

  coll_sort(c);

  return 0;
}
