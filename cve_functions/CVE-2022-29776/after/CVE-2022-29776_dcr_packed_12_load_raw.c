void DCR_CLASS dcr_packed_12_load_raw(DCRAW* p)
{
	int vbits=0, rbits=0, irow, row, col;
	UINT64 bitbuf=0;

	if (p->raw_width * 2 >= p->width * 3) {	/* If raw_width is in bytes, */
		rbits = p->raw_width * 8;
		p->raw_width = p->raw_width * 2 / 3;	/* convert it to pixels and  */
		rbits -= p->raw_width * 12;		/* save the remainder.       */
	}
	p->order = p->load_flags & 1 ? 0x4949 : 0x4d4d;
	for (irow=0; irow < p->height; irow++) {
		row = irow;
		if (p->load_flags & 2 &&
			(row = irow * 2 % p->height + irow / (p->height/2)) == 1 &&
			p->load_flags & 4) {
			if (vbits=0, p->tiff_compress)
				dcr_fseek(p->obj_, p->data_offset - (-p->width*p->height*3/4 & -2048), SEEK_SET);
			else {
				dcr_fseek(p->obj_, 0, SEEK_END);
				dcr_fseek(p->obj_, dcr_ftell(p->obj_)/2, SEEK_SET);
			}
		}
		for (col=0; col < p->raw_width; col++) {
			if ((vbits -= 12) < 0) {
				bitbuf = bitbuf << 32 | dcr_get4(p);
				vbits += 32;
			}
			if ((unsigned) (col-p->left_margin) < p->width)
				BAYER(row,col-p->left_margin) = (unsigned short)(bitbuf << (52-vbits) >> 52);
			if (p->load_flags & 8 && (col % 10) == 9)
				if (vbits=0, bitbuf & 255) dcr_derror(p);
		}
		vbits -= rbits;
	}
	if (!strcmp(p->make,"OLYMPUS")) p->black >>= 4;
}
