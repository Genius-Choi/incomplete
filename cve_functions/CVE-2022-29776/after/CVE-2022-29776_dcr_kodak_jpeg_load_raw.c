void DCR_CLASS dcr_kodak_jpeg_load_raw(DCRAW* p)
{
	struct jpeg_decompress_struct cinfo;
	struct jpeg_error_mgr jerr;
	JSAMPARRAY buf;
	JSAMPLE (*pixel)[3];
	int row, col;

	cinfo.err = jpeg_std_error (&jerr);
	jpeg_create_decompress (&cinfo);
	jpeg_stdio_src (&cinfo);
	cinfo.src->fill_input_buffer = fill_input_buffer;
	jpeg_read_header (&cinfo, TRUE);
	jpeg_start_decompress (&cinfo);
	if ((cinfo.output_width      != p->width  ) ||
		(cinfo.output_height*2   != p->height ) ||
		(cinfo.output_components != 3      )) {
		fprintf (stderr,_("%s: incorrect JPEG dimensions\n"), p->ifname);
		jpeg_destroy_decompress (&cinfo);
		longjmp (p->failure, 3);
	}
	buf = (*cinfo.mem->alloc_sarray)
		((j_common_ptr) &cinfo, JPOOL_IMAGE, p->width*3, 1);

	while (cinfo.output_scanline < cinfo.output_height) {
		row = cinfo.output_scanline * 2;
		jpeg_read_scanlines (&cinfo, buf, 1);
		pixel = (JSAMPLE (*)[3]) buf[0];
		for (col=0; col < p->width; col+=2) {
			BAYER(row+0,col+0) = pixel[col+0][1] << 1;
			BAYER(row+1,col+1) = pixel[col+1][1] << 1;
			BAYER(row+0,col+1) = pixel[col][0] + pixel[col+1][0];
			BAYER(row+1,col+0) = pixel[col][2] + pixel[col+1][2];
		}
	}
	jpeg_finish_decompress (&cinfo);
	jpeg_destroy_decompress (&cinfo);
	p->maximum = 0xff << 1;
}
