void DCR_CLASS dcr_recover_highlights(DCRAW* p)
{
	float *map, sum, wgt, grow;
	int hsat[4], count, spread, change, val, i, c;
	unsigned high, wide, mrow, mcol, row, col, kc, d, y, x;
	ushort *pixel;
	static const signed char dir[8][2] =
    { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };

	if (p->opt.verbose) fprintf (stderr,_("Rebuilding highlights...\n"));

	grow = (float)pow (2, 4-p->opt.highlight);
	FORCC(p) hsat[c] = (int)(32000 * p->pre_mul[c]);
	for (kc=0, c=1; (int)c < p->colors; c++)
		if (p->pre_mul[kc] < p->pre_mul[c]) kc = c;
		high = p->height / SCALE;
		wide =  p->width / SCALE;
		map = (float *) calloc (high*wide, sizeof *map);
		dcr_merror (p, map, "recover_highlights()");
		FORCC(p) if ((unsigned int)c != kc) {
			memset (map, 0, high*wide*sizeof *map);
			for (mrow=0; mrow < high; mrow++)
				for (mcol=0; mcol < wide; mcol++) {
					sum = wgt = 0;
					count = 0;
					for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)
						for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {
							pixel = p->image[row*p->width+col];
							if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000) {
								sum += pixel[c];
								wgt += pixel[kc];
								count++;
							}
						}
						if (count == SCALE*SCALE)
							map[mrow*wide+mcol] = sum / wgt;
				}
			for (spread = (int)(32/grow); spread--; ) {
				for (mrow=0; mrow < high; mrow++)
					for (mcol=0; mcol < wide; mcol++) {
						if (map[mrow*wide+mcol]) continue;
						sum = 0;
						count = 0;
						for (d=0; d < 8; d++) {
							y = mrow + dir[d][0];
							x = mcol + dir[d][1];
							if (y < high && x < wide && map[y*wide+x] > 0) {
								sum  += (1 + (d & 1)) * map[y*wide+x];
								count += 1 + (d & 1);
							}
						}
						if (count > 3)
							map[mrow*wide+mcol] = - (sum+grow) / (count+grow);
					}
					for (change=i=0; i < (int)(high*wide); i++)
						if (map[i] < 0) {
							map[i] = -map[i];
							change = 1;
						}
						if (!change) break;
			}
			for (i=0; i < (int)(high*wide); i++)
				if (map[i] == 0) map[i] = 1;
			for (mrow=0; mrow < high; mrow++)
				for (mcol=0; mcol < wide; mcol++) {
					for (row = mrow*SCALE; row < (mrow+1)*SCALE; row++)
						for (col = mcol*SCALE; col < (mcol+1)*SCALE; col++) {
							pixel = p->image[row*p->width+col];
							if (pixel[c] / hsat[c] > 1) {
								val = (int)(pixel[kc] * map[mrow*wide+mcol]);
								if (pixel[c] < val) pixel[c] = CLIP(val);
							}
						}
				}
		}
		free (map);
}
