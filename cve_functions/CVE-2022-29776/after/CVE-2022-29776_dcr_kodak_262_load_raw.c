void DCR_CLASS dcr_kodak_262_load_raw(DCRAW* p)
{
	static const uchar kodak_tree[2][26] =
	{ { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },
    { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };
	struct dcr_decode *decode[2];
	uchar *pixel;
	int *strip, ns, i, row, col, chess, pi=0, pi1, pi2, pred, val;

	dcr_init_decoder(p);
	for (i=0; i < 2; i++) {
		decode[i] = p->free_decode;
		dcr_make_decoder (p, kodak_tree[i], 0);
	}
	ns = (p->raw_height+63) >> 5;
	pixel = (uchar *) malloc (p->raw_width*32 + ns*4);
	dcr_merror (p, pixel, "kodak_262_load_raw()");
	strip = (int *) (pixel + p->raw_width*32);
	p->order = 0x4d4d;
	for (i=0; i < ns; i++)
		strip[i] = dcr_get4(p);
	for (row=0; row < p->raw_height; row++) {
		if ((row & 31) == 0) {
			dcr_fseek(p->obj_, strip[row >> 5], SEEK_SET);
			dcr_getbits(p, -1);
			pi = 0;
		}
		for (col=0; col < p->raw_width; col++) {
			chess = (row + col) & 1;
			pi1 = chess ? pi-2           : pi-p->raw_width-1;
			pi2 = chess ? pi-2*p->raw_width : pi-p->raw_width+1;
			if (col <= chess) pi1 = -1;
			if (pi1 < 0) pi1 = pi2;
			if (pi2 < 0) pi2 = pi1;
			if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;
			pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;
			pixel[pi] = val = pred + dcr_ljpeg_diff (p, decode[chess]);
			if (val >> 8) dcr_derror(p);
			val = p->curve[pixel[pi++]];
			if ((unsigned) (col-p->left_margin) < p->width)
				BAYER(row,col-p->left_margin) = val;
			else p->black += val;
		}
	}
	free (pixel);
	if (p->raw_width > p->width)
		p->black /= (p->raw_width - p->width) * p->height;
}
