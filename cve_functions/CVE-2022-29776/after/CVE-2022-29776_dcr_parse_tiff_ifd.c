int DCR_CLASS dcr_parse_tiff_ifd (DCRAW* p, int base)
{
	unsigned entries, tag, type, len, plen=16, save;
	int ifd, use_cm=0, cfa, i, j, c, ima_len=0;
	char software[64], *cbuf, *cp;
	uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];
	double dblack, cc[4][4], cm[4][3], cam_xyz[4][3], num;
	double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };
	unsigned sony_curve[] = { 0,0,0,0,0,4095 };
	unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;
	struct dcr_jhead jh;

	if (p->tiff_nifds >= sizeof p->tiff_ifd / sizeof p->tiff_ifd[0])
		return 1;
	ifd = p->tiff_nifds++;
	for (j=0; j < 4; j++)
		for (i=0; i < 4; i++)
			cc[j][i] = i == j;
	entries = dcr_get2(p);
	if (entries > 512) return 1;
	while (entries--) {
		dcr_tiff_get (p, base, &tag, &type, &len, &save);
		switch (tag) {
		case 17: case 18:
			if (type == 3 && len == 1)
				p->cam_mul[(tag-17)*2] = dcr_get2(p) / 256.0f;
			break;
		case 23:
			if (type == 3) p->iso_speed = dcr_get2(p);
			break;
		case 36: case 37: case 38:
			p->cam_mul[tag-0x24] = dcr_get2(p);
			break;
		case 39:
			if (len < 50 || p->cam_mul[0]) break;
			dcr_fseek(p->obj_, 12, SEEK_CUR);
			FORC3 p->cam_mul[c] = dcr_get2(p);
			break;
		case 46:
			if (type != 7 || dcr_fgetc(p->obj_) != 0xff || dcr_fgetc(p->obj_) != 0xd8) break;
			p->thumb_offset = dcr_ftell(p->obj_) - 2;
			p->thumb_length = len;
			break;
		case 2: case 256:			/* ImageWidth */
			p->tiff_ifd[ifd].width = dcr_getint(p, type);
			break;
		case 3: case 257:			/* ImageHeight */
			p->tiff_ifd[ifd].height = dcr_getint(p, type);
			break;
		case 258:				/* BitsPerSample */
			p->tiff_ifd[ifd].samples = len & 7;
			p->tiff_ifd[ifd].bps = dcr_get2(p);
			break;
		case 259:				/* Compression */
			p->tiff_ifd[ifd].comp = dcr_get2(p);
			break;
		case 262:				/* PhotometricInterpretation */
			p->tiff_ifd[ifd].phint = dcr_get2(p);
			break;
		case 270:				/* ImageDescription */
			dcr_fread(p->obj_, p->desc, 512, 1);
			break;
		case 271:				/* Make */
			dcr_fgets(p->obj_, p->make, 64);
			break;
		case 272:				/* Model */
			dcr_fgets(p->obj_, p->model, 64);
			break;
		case 280:				/* Panasonic RW2 offset */
			if (type != 4) break;
			p->load_raw = &DCR_CLASS dcr_panasonic_load_raw;
			p->load_flags = 0x2008;
		case 273:				/* StripOffset */
		case 513:
			p->tiff_ifd[ifd].offset = dcr_get4(p)+base;
			if (!p->tiff_ifd[ifd].bps) {
				dcr_fseek(p->obj_, p->tiff_ifd[ifd].offset, SEEK_SET);
				if (dcr_ljpeg_start (p,&jh, 1)) {
					p->tiff_ifd[ifd].comp    = 6;
					p->tiff_ifd[ifd].width   = jh.wide << (jh.clrs == 2);
					p->tiff_ifd[ifd].height  = jh.high;
					p->tiff_ifd[ifd].bps     = jh.bits;
					p->tiff_ifd[ifd].samples = jh.clrs;
				}
			}
			break;
		case 274:				/* Orientation */
			p->tiff_ifd[ifd].flip = "50132467"[dcr_get2(p) & 7]-'0';
			break;
		case 277:				/* SamplesPerPixel */
			p->tiff_ifd[ifd].samples = dcr_getint(p, type) & 7;
			break;
		case 279:				/* StripByteCounts */
		case 514:
			p->tiff_ifd[ifd].bytes = dcr_get4(p);
			break;
		case 305:  case 11:		/* Software */
			dcr_fgets(p->obj_, software, 64);
			if (!strncmp(software,"Adobe",5) ||
				!strncmp(software,"dcraw",5) ||
				!strncmp(software,"UFRaw",5) ||
				!strncmp(software,"Bibble",6) ||
				!strncmp(software,"Nikon Scan",10) ||
				!strcmp (software,"Digital Photo Professional"))
				p->is_raw = 0;
			break;
		case 306:				/* DateTime */
			dcr_get_timestamp(p,0);
			break;
		case 315:				/* Artist */
			dcr_fread(p->obj_, p->artist, 64, 1);
			break;
		case 322:				/* TileWidth */
			p->tile_width = dcr_getint(p, type);
			break;
		case 323:				/* TileLength */
			p->tile_length = dcr_getint(p, type);
			break;
		case 324:				/* TileOffsets */
			p->tiff_ifd[ifd].offset = len > 1 ? dcr_ftell(p->obj_) : dcr_get4(p);
			if (len == 4) {
				p->load_raw = &DCR_CLASS dcr_sinar_4shot_load_raw;
				p->is_raw = 5;
			}
			break;
		case 330:				/* SubIFDs */
			if (!strcmp(p->model,"DSLR-A100") && p->tiff_ifd[ifd].width == 3872) {
				p->load_raw = &DCR_CLASS dcr_sony_arw_load_raw;
				p->data_offset = dcr_get4(p)+base;
				ifd++;  break;
			}
			while (len--) {
				i = dcr_ftell(p->obj_);
				dcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);
				if (dcr_parse_tiff_ifd (p, base)) break;
				dcr_fseek(p->obj_, i+4, SEEK_SET);
			}
			break;
		case 400:
			strcpy (p->make, "Sarnoff");
			p->maximum = 0xfff;
			break;
		case 28688:
			FORC4 sony_curve[c+1] = dcr_get2(p) >> 2 & 0xfff;
			for (i=0; i < 5; i++)
				for (j = sony_curve[i]+1; j <= (int)sony_curve[i+1]; j++)
					p->curve[j] = p->curve[j-1] + (1 << i);
				break;
		case 29184: sony_offset = dcr_get4(p);  break;
		case 29185: sony_length = dcr_get4(p);  break;
		case 29217: sony_key    = dcr_get4(p);  break;
		case 29264:
			dcr_parse_minolta (p, dcr_ftell(p->obj_));
			p->raw_width = 0;
			break;
		case 29443:
			FORC4 p->cam_mul[c ^ (c < 2)] = dcr_get2(p);
			break;
		case 29459:
			FORC4 p->cam_mul[c ^ (c >> 1)] = dcr_get2(p);
			break;
		case 33405:			/* Model2 */
			dcr_fgets(p->obj_, p->model2, 64);
			break;
		case 33422:			/* CFAPattern */
		case 64777:			/* Kodak P-series */
			if ((plen=len) > 16) plen = 16;
			dcr_fread(p->obj_, cfa_pat, 1, plen);
			for (p->colors=cfa=i=0; i < (int)plen; i++) {
				p->colors += !(cfa & (1 << cfa_pat[i]));
				cfa |= 1 << cfa_pat[i];
			}
			if (cfa == 070) memcpy (cfa_pc,"\003\004\005",3);	/* CMY */
			if (cfa == 072) memcpy (cfa_pc,"\005\003\004\001",4);	/* GMCY */
			goto guess_cfa_pc;
		case 33424:
			dcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);
			dcr_parse_kodak_ifd (p,base);
			break;
		case 33434:			/* ExposureTime */
			p->shutter = (float)dcr_getreal(p,type);
			break;
		case 33437:			/* FNumber */
			p->aperture = (float)dcr_getreal(p,type);
			break;
		case 34306:			/* Leaf p->white balance */
			FORC4 p->cam_mul[c ^ 1] = 4096.0f / dcr_get2(p);
			break;
		case 34307:			/* Leaf CatchLight color matrix */
			dcr_fread(p->obj_, software, 1, 7);
			if (strncmp(software,"MATRIX",6)) break;
			p->colors = 4;
			for (p->raw_color = i=0; i < 3; i++) {
				FORC4 dcr_fscanf(p->obj_, "%f", &p->rgb_cam[i][c^1]);
				if (!p->opt.use_camera_wb) continue;
				num = 0;
				FORC4 num += p->rgb_cam[i][c];
				FORC4 p->rgb_cam[i][c] /= (float)num;
			}
			break;
		case 34310:			/* Leaf metadata */
			dcr_parse_mos (p,dcr_ftell(p->obj_));
		case 34303:
			strcpy (p->make, "Leaf");
			break;
		case 34665:			/* EXIF tag */
			dcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);
			dcr_parse_exif (p,base);
			break;
		case 34853:			/* GPSInfo tag */
			dcr_fseek(p->obj_, dcr_get4(p)+base, SEEK_SET);
			dcr_parse_gps (p,base);
			break;
		case 34675:			/* InterColorProfile */
		case 50831:			/* AsShotICCProfile */
			p->profile_offset = dcr_ftell(p->obj_);
			p->profile_length = len;
			break;
		case 37122:			/* CompressedBitsPerPixel */
			p->kodak_cbpp = dcr_get4(p);
			break;
		case 37386:			/* FocalLength */
			p->focal_len = (float)dcr_getreal(p,type);
			break;
		case 37393:			/* ImageNumber */
			p->shot_order = dcr_getint(p, type);
			break;
		case 37400:			/* old Kodak KDC tag */
			for (p->raw_color = i=0; i < 3; i++) {
				dcr_getreal(p,type);
				FORC3 p->rgb_cam[i][c] = (float)dcr_getreal(p,type);
			}
			break;
		case 46275:			/* Imacon tags */
			strcpy (p->make, "Imacon");
			p->data_offset = dcr_ftell(p->obj_);
			ima_len = len;
			break;
		case 46279:
			if (!ima_len) break;
			dcr_fseek(p->obj_, 78, SEEK_CUR);
			p->raw_width  = dcr_get4(p);
			p->raw_height = dcr_get4(p);
			p->left_margin = dcr_get4(p) & 7;
			p->width = p->raw_width - p->left_margin - (dcr_get4(p) & 7);
			p->top_margin = dcr_get4(p) & 7;
			p->height = p->raw_height - p->top_margin - (dcr_get4(p) & 7);
			if (p->raw_width == 7262) {
				p->height = 5444;
				p->width  = 7244;
				p->left_margin = 7;
			}
			dcr_fseek(p->obj_, 52, SEEK_CUR);
			FORC3 p->cam_mul[c] = (float)dcr_getreal(p, 11);
			dcr_fseek(p->obj_, 114, SEEK_CUR);
			p->flip = (dcr_get2(p) >> 7) * 90;
			if (p->width * p->height * 6 == ima_len) {
				if (p->flip % 180 == 90) SWAP(p->width,p->height);
				p->filters = p->flip = 0;
			}
			sprintf (p->model, "Ixpress %d-Mp", p->height*p->width/1000000);
			p->load_raw = &DCR_CLASS dcr_imacon_full_load_raw;
			if (p->filters) {
				if (p->left_margin & 1) p->filters = 0x61616161;
				p->load_raw = &DCR_CLASS dcr_unpacked_load_raw;
			}
			p->maximum = 0xffff;
			break;
		case 50454:			/* Sinar tag */
		case 50455:
			if (!(cbuf = (char *) malloc(len))) break;
			dcr_fread(p->obj_, cbuf, 1, len);
			for (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\n'))
				if (!strncmp (++cp,"Neutral ",8))
					sscanf (cp+8, "%f %f %f", p->cam_mul, p->cam_mul+1, p->cam_mul+2);
			free (cbuf);
			break;
		case 50458:
			if (!p->make[0]) strcpy (p->make, "Hasselblad");
			break;
		case 50459:			/* Hasselblad tag */
			i = p->order;
			j = dcr_ftell(p->obj_);
			c = p->tiff_nifds;
			p->order = dcr_get2(p);
			dcr_fseek(p->obj_, j+(dcr_get2(p),dcr_get4(p)), SEEK_SET);
			dcr_parse_tiff_ifd (p, j);
			p->maximum = 0xffff;
			p->tiff_nifds = c;
			p->order = i;
			break;
		case 50706:			/* DNGVersion */
			FORC4 p->dng_version = (p->dng_version << 8) + dcr_fgetc(p->obj_);
			if (!p->make[0]) strcpy (p->make, "DNG");
			p->is_raw = 1;
			break;
		case 50710:			/* CFAPlaneColor */
			if (len > 4) len = 4;
			p->colors = len;
			dcr_fread(p->obj_, cfa_pc, 1, p->colors);
guess_cfa_pc:
			FORCC(p) tab[cfa_pc[c]] = c;
			p->cdesc[c] = 0;
			for (i=16; i--; )
				p->filters = p->filters << 2 | tab[cfa_pat[i % plen]];
			break;
		case 50711:			/* CFALayout */
			if (dcr_get2(p) == 2) {
				p->fuji_width = 1;
				p->filters = 0x49494949;
			}
			break;
		case 291:
		case 50712:			/* LinearizationTable */
			dcr_linear_table (p,len);
			break;
		case 50714:			/* BlackLevel */
		case 50715:			/* BlackLevelDeltaH */
		case 50716:			/* BlackLevelDeltaV */
			for (dblack=i=0; i < (int)len; i++)
				dblack += dcr_getreal(p, type);
			p->black += (unsigned int)(dblack/len + 0.5);
			break;
		case 50717:			/* WhiteLevel */
			p->maximum = dcr_getint(p, type);
			break;
		case 50718:			/* DefaultScale */
			p->pixel_aspect  = dcr_getreal(p,type);
			p->pixel_aspect /= dcr_getreal(p,type);
			break;
		case 50721:			/* ColorMatrix1 */
		case 50722:			/* ColorMatrix2 */
			FORCC(p) for (j=0; j < 3; j++)
				cm[c][j] = dcr_getreal(p,type);
			use_cm = 1;
			break;
		case 50723:			/* CameraCalibration1 */
		case 50724:			/* CameraCalibration2 */
			for (i=0; i < p->colors; i++)
				FORCC(p) cc[i][c] = dcr_getreal(p,type);
		case 50727:			/* AnalogBalance */
			FORCC(p) ab[c] = dcr_getreal(p,type);
			break;
		case 50728:			/* AsShotNeutral */
			FORCC(p) asn[c] = dcr_getreal(p, type);
			break;
		case 50729:			/* AsShotWhiteXY */
			xyz[0] = dcr_getreal(p,type);
			xyz[1] = dcr_getreal(p,type);
			xyz[2] = 1 - xyz[0] - xyz[1];
			FORC3 xyz[c] /= d65_white[c];
			break;
		case 50740:			/* DNGPrivateData */
			if (p->dng_version) break;
			dcr_parse_minolta (p, j = dcr_get4(p)+base);
			dcr_fseek(p->obj_, j, SEEK_SET);
			dcr_parse_tiff_ifd (p, base);
			break;
		case 50752:
			dcr_read_shorts (p, p->cr2_slice, 3);
			break;
		case 50829:			/* ActiveArea */
			p->top_margin = dcr_getint(p, type);
			p->left_margin = dcr_getint(p, type);
			p->height = dcr_getint(p, type) - p->top_margin;
			p->width = dcr_getint(p, type) - p->left_margin;
			break;
		case 64772:			/* Kodak P-series */
			dcr_fseek(p->obj_, 16, SEEK_CUR);
			p->data_offset = dcr_get4(p);
			dcr_fseek(p->obj_, 28, SEEK_CUR);
			p->data_offset += dcr_get4(p);
			p->load_raw = &DCR_CLASS dcr_packed_12_load_raw;
    }
    dcr_fseek(p->obj_, save, SEEK_SET);
  }
  if (sony_length && (buf = (unsigned *) malloc(sony_length))) {
	  dcr_stream_ops *sops_;
	  dcr_stream_obj *sobj_;
	  dcr_fseek(p->obj_, sony_offset, SEEK_SET);
	  dcr_fread(p->obj_, buf, sony_length, 1);
	  dcr_sony_decrypt (buf, sony_length/4, 1, sony_key);

	  sops_ = p->ops_;
	  sobj_ = p->obj_;
  	  p->ops_ = &dcr_stream_fileops;
	  if ((p->obj_ = tmpfile())) {
		  dcr_fwrite(p->obj_, buf, sony_length, 1);
		  dcr_fseek(p->obj_, 0, SEEK_SET);
		  dcr_parse_tiff_ifd (p, -(int)sony_offset);
		  dcr_fclose(p->obj_);
	  }
	  p->ops_ = sops_;
	  p->obj_ = sobj_;

	  free (buf);
  }
  for (i=0; i < p->colors; i++)
	  FORCC(p) cc[i][c] *= ab[i];
  if (use_cm) {
	  FORCC(p) for (i=0; i < 3; i++)
		  for (cam_xyz[c][i]=j=0; j < p->colors; j++)
			  cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];
		  dcr_cam_xyz_coeff (p, cam_xyz);
  }
  if (asn[0]) {
	  p->cam_mul[3] = 0;
	  FORCC(p) p->cam_mul[c] = 1.0f / (float)asn[c];
  }
  if (!use_cm)
	  FORCC(p) p->pre_mul[c] /= (float)cc[c][c];
  return 0;
}
