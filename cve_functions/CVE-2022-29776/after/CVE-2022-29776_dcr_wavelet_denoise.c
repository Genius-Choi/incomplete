void DCR_CLASS dcr_wavelet_denoise(DCRAW* p)
{
	float *fimg=0, *temp, thold, mul[2], avg, diff;
	int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast;
	ushort *window[4];
	static const float noise[] =
	{ 0.8002f,0.2735f,0.1202f,0.0585f,0.0291f,0.0152f,0.0080f,0.0044f };

	if (p->opt.verbose) fprintf (stderr,_("Wavelet denoising...\n"));

	while (p->maximum << scale < 0x10000) scale++;
	p->maximum <<= --scale;
	p->black <<= scale;
	if ((size = p->iheight*p->iwidth) < 0x15550000)
		fimg = (float *) malloc ((size*3 + p->iheight + p->iwidth) * sizeof *fimg);
	dcr_merror (p, fimg, "wavelet_denoise()");
	temp = fimg + size*3;
	if ((nc = p->colors) == 3 && p->filters) nc++;
	FORC(nc) {	/* denoise R,G1,B,G3 individually */
		for (i=0; i < size; i++)
			fimg[i] = 256 * (float)sqrt(p->image[i][c] << scale);
		for (hpass=lev=0; lev < 5; lev++) {
			lpass = size*((lev & 1)+1);
			for (row=0; row < p->iheight; row++) {
				dcr_hat_transform (temp, fimg+hpass+row*p->iwidth, 1, p->iwidth, 1 << lev);
				for (col=0; col < p->iwidth; col++)
					fimg[lpass + row*p->iwidth + col] = temp[col] * 0.25f;
			}
			for (col=0; col < p->iwidth; col++) {
				dcr_hat_transform (temp, fimg+lpass+col, p->iwidth, p->iheight, 1 << lev);
				for (row=0; row < p->iheight; row++)
					fimg[lpass + row*p->iwidth + col] = temp[row] * 0.25f;
			}
			thold = p->opt.threshold * noise[lev];
			for (i=0; i < size; i++) {
				fimg[hpass+i] -= fimg[lpass+i];
				if	(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;
				else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;
				else	 fimg[hpass+i] = 0;
				if (hpass) fimg[i] += fimg[hpass+i];
			}
			hpass = lpass;
		}
		for (i=0; i < size; i++)
			p->image[i][c] = (unsigned short)(CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000));
	}
	if (p->filters && p->colors == 3) {  /* pull G1 and G3 closer together */
		for (row=0; row < 2; row++)
			mul[row] = 0.125f * p->pre_mul[FC(row+1,0) | 1] / p->pre_mul[FC(row,0) | 1];
		for (i=0; i < 4; i++)
			window[i] = (ushort *) fimg + p->width*i;
		for (wlast=-1, row=1; row < p->height-1; row++) {
			while (wlast < row+1) {
				for (wlast++, i=0; i < 4; i++)
					window[(i+3) & 3] = window[i];
				for (col = FC(wlast,1) & 1; col < p->width; col+=2)
					window[2][col] = BAYER(wlast,col);
			}
			thold = p->opt.threshold/512;
			for (col = (FC(row,0) & 1)+1; col < p->width-1; col+=2) {
				avg = ( window[0][col-1] + window[0][col+1] +
					window[2][col-1] + window[2][col+1] - p->black*4 )
					* mul[row & 1] + (window[1][col] - p->black) * 0.5f + p->black;
				avg = avg < 0 ? 0 : (float)sqrt(avg);
				diff = (float)sqrt(BAYER(row,col)) - avg;
				if      (diff < -thold) diff += thold;
				else if (diff >  thold) diff -= thold;
				else diff = 0;
				BAYER(row,col) = (unsigned short)(CLIP(SQR(avg+diff) + 0.5f));
			}
		}
	}
	free (fimg);
}
