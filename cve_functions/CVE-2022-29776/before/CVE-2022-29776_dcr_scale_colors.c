void DCR_CLASS dcr_scale_colors(DCRAW* p)
{
	unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];
	int val, dark, sat;
	double dsum[8], dmin, dmax;
	float scale_mul[4], fr, fc;
	ushort *img=0, *pix;

	if (p->opt.user_mul[0])
		memcpy (p->pre_mul, p->opt.user_mul, sizeof p->pre_mul);
	if (p->opt.use_auto_wb || (p->opt.use_camera_wb && p->cam_mul[0] == -1)) {
		memset (dsum, 0, sizeof dsum);
		bottom = MIN (p->opt.greybox[1]+p->opt.greybox[3], p->height);
		right  = MIN (p->opt.greybox[0]+p->opt.greybox[2], p->width);
		for (row=p->opt.greybox[1]; row < bottom; row += 8)
			for (col=p->opt.greybox[0]; col < right; col += 8) {
				memset (sum, 0, sizeof sum);
				for (y=row; y < row+8 && y < bottom; y++)
					for (x=col; x < col+8 && x < right; x++)
						FORC4 {
						if (p->filters) {
							c = FC(y,x);
							val = BAYER(y,x);
						} else
							val = p->image[y*p->width+x][c];
						if (val > (int)p->maximum-25) goto skip_block;
						if ((val -= p->black) < 0) val = 0;
						sum[c] += val;
						sum[c+4]++;
						if (p->filters) break;
					}
					FORC(8) dsum[c] += sum[c];
skip_block: ;
			}
			FORC4 if (dsum[c]) p->pre_mul[c] = (float)(dsum[c+4] / dsum[c]);
	}
	if (p->opt.use_camera_wb && p->cam_mul[0] != -1) {
		memset (sum, 0, sizeof sum);
		for (row=0; row < 8; row++)
			for (col=0; col < 8; col++) {
				c = FC(row,col);
				if ((val = p->white[row][col] - p->black) > 0)
					sum[c] += val;
				sum[c+4]++;
			}
			if (sum[0] && sum[1] && sum[2] && sum[3])
				FORC4 p->pre_mul[c] = (float) sum[c+4] / sum[c];
			else if (p->cam_mul[0] && p->cam_mul[2])
				memcpy (p->pre_mul, p->cam_mul, sizeof p->pre_mul);
			else
				fprintf (stderr,_("%s: Cannot use camera p->white balance.\n"), p->ifname);
	}
	if (p->pre_mul[3] == 0) p->pre_mul[3] = p->colors < 4 ? p->pre_mul[1] : 1;
	dark = p->black;
	sat = p->maximum;
	if (p->opt.threshold) dcr_wavelet_denoise(p);
	p->maximum -= p->black;
	for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {
		if (dmin > p->pre_mul[c])
			dmin = p->pre_mul[c];
		if (dmax < p->pre_mul[c])
			dmax = p->pre_mul[c];
	}
	if (!p->opt.highlight) dmax = dmin;
	FORC4 scale_mul[c] = (float)((p->pre_mul[c] /= (float)dmax) * 65535.0f / p->maximum);
	if (p->opt.verbose) {
		fprintf (stderr,_("Scaling with darkness %d, saturation %d, and\nmultipliers"), dark, sat);
		FORC4 fprintf (stderr, " %f", p->pre_mul[c]);
		fputc ('\n', stderr);
	}
	size = p->iheight*p->iwidth;
	for (i=0; i < size*4; i++) {
		val = p->image[0][i];
		if (!val) continue;
		val -= p->black;
		val = (int)(val * scale_mul[i & 3]);
		p->image[0][i] = CLIP(val);
	}
	if ((p->opt.aber[0] != 1 || p->opt.aber[2] != 1) && p->colors == 3) {
		if (p->opt.verbose)
			fprintf (stderr,_("Correcting chromatic aberration...\n"));
		for (c=0; c < 4; c+=2) {
			if (p->opt.aber[c] == 1) continue;
			img = (ushort *) malloc (size * sizeof *img);
			dcr_merror (p, img, "scale_colors()");
			for (i=0; i < size; i++)
				img[i] = p->image[i][c];
			for (row=0; row < p->iheight; row++) {
				fr = (float)((row - p->iheight*0.5) * p->opt.aber[c] + p->iheight*0.5);
				ur = (unsigned int)fr;
				if ((int)ur > p->iheight-2) continue;
				fr -= ur;
				for (col=0; col < p->iwidth; col++) {
					fc = (float)((col - p->iwidth*0.5) * p->opt.aber[c] + p->iwidth*0.5);
					uc = (unsigned int)fc;
					if ((int)uc > p->iwidth-2) continue;
					fc -= uc;
					pix = img + ur*p->iwidth + uc;
					p->image[row*p->iwidth+col][c] = (unsigned short)(
						(pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +
						(pix[p->iwidth]*(1-fc) + pix[p->iwidth+1]*fc) * fr);
				}
			}
			free(img);
		}
	}
}
