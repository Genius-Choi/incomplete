void DCR_CLASS dcr_foveon_load_raw(DCRAW* p)
{
	struct dcr_decode *dindex;
	short diff[1024];
	unsigned bitbuf=0;
	int pred[3], fixed, row, col, bit=-1, c, i;

	fixed = dcr_get4(p);
	dcr_read_shorts (p, (ushort *) diff, 1024);
	if (!fixed) dcr_foveon_decoder (p, 1024, 0);

	for (row=0; row < p->height; row++) {
		memset (pred, 0, sizeof pred);
		if (!bit && !fixed && atoi(p->model+2) < 14) dcr_get4(p);
		for (col=bit=0; col < p->width; col++) {
			if (fixed) {
				bitbuf = dcr_get4(p);
				FORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];
			}
			else FORC3 {
				for (dindex=p->first_decode; dindex->branch[0]; ) {
					if ((bit = (bit-1) & 31) == 31)
						for (i=0; i < 4; i++)
							bitbuf = (bitbuf << 8) + dcr_fgetc(p->obj_);
						dindex = dindex->branch[bitbuf >> bit & 1];
				}
				pred[c] += diff[dindex->leaf];
				if (pred[c] >> 16 && ~pred[c] >> 16) dcr_derror(p);
			}
			FORC3 p->image[row*p->width+col][c] = pred[c];
		}
	}
	if (p->opt.document_mode)
		for (i=0; i < p->height*p->width*4; i++)
			if ((short) p->image[0][i] < 0) p->image[0][i] = 0;
			dcr_foveon_load_camf(p);
}
