void DCR_CLASS dcr_bad_pixels(DCRAW* p, char *fname)
{
	FILE *fp=0;
	char *cp, line[128];
	int len, time, row, col, r, c, rad, tot, n, fixed=0;

	if (!p->filters) return;
	if (fname)
		fp = fopen (fname, "r");
	else {
		for (len=32 ; ; len *= 2) {
			fname = (char *) malloc (len);
			if (!fname) return;
			if (_getcwd (fname, len-16)) break;
			free (fname);
			if (errno != ERANGE) return;
		}
#if defined(WIN32) || defined(DJGPP)
		if (fname[1] == ':')
			memmove (fname, fname+2, len-2);
		for (cp=fname; *cp; cp++)
			if (*cp == '\\') *cp = '/';
#endif
		cp = fname + strlen(fname);
		if (cp[-1] == '/') cp--;
		while (*fname == '/') {
			strcpy (cp, "/.badpixels");
			if ((fp = fopen (fname, "r"))) break;
			if (cp == fname) break;
			while (*--cp != '/');
		}
		free (fname);
	}
	if (!fp) return;
	while (fgets (line, 128, fp)) {
		cp = strchr (line, '#');
		if (cp) *cp = 0;
		if (sscanf (line, "%d %d %d", &col, &row, &time) != 3) continue;
		if ((unsigned) col >= p->width || (unsigned) row >= p->height) continue;
		if (time > p->timestamp) continue;
		for (tot=n=0, rad=1; rad < 3 && n==0; rad++)
			for (r = row-rad; r <= row+rad; r++)
				for (c = col-rad; c <= col+rad; c++)
					if ((unsigned) r < p->height && (unsigned) c < p->width &&
						(r != row || c != col) && dcr_fc(p,r,c) == dcr_fc(p,row,col)) {
						tot += BAYER2(r,c);
						n++;
					}
					BAYER2(row,col) = tot/n;
					if (p->opt.verbose) {
						if (!fixed++)
							fprintf (stderr,_("Fixed dead pixels at:"));
						fprintf (stderr, " %d,%d", col, row);
					}
	}
	if (fixed) fputc ('\n', stderr);
	fclose (fp);
}
