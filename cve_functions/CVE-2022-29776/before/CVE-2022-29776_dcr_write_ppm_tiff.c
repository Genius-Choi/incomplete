void DCR_CLASS dcr_write_ppm_tiff (DCRAW* p, FILE *ofp)
{
	struct dcr_tiff_hdr th;
	uchar *ppm, lut[0x10000];
	ushort *ppm2;
	int c, row, col, soff, rstep, cstep;

	p->iheight = p->height;
	p->iwidth  = p->width;
	if (p->flip & 4) SWAP(p->height,p->width);
	ppm = (uchar *) calloc (p->width, p->colors*p->opt.output_bps/8);
	ppm2 = (ushort *) ppm;
	dcr_merror (p, ppm, "write_ppm_tiff()");
	if (p->opt.output_tiff) {
		dcr_tiff_head (p, &th, 1);
		fwrite (&th, sizeof th, 1, ofp);
		if (p->oprof)
			fwrite (p->oprof, ntohl(p->oprof[0]), 1, ofp);
	} else if (p->colors > 3)
		fprintf (ofp,
		"P7\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
		p->width, p->height, p->colors, (1 << p->opt.output_bps)-1, p->cdesc);
	else
		fprintf (ofp, "P%d\n%d %d\n%d\n",
		p->colors/2+5, p->width, p->height, (1 << p->opt.output_bps)-1);

	if (p->opt.output_bps == 8) dcr_gamma_lut (p, lut);
	soff  = dcr_flip_index (p, 0, 0);
	cstep = dcr_flip_index (p, 0, 1) - soff;
	rstep = dcr_flip_index (p, 1, 0) - dcr_flip_index (p, 0, p->width);
	for (row=0; row < p->height; row++, soff += rstep) {
		for (col=0; col < p->width; col++, soff += cstep){
			if (p->opt.output_bps == 8)
				FORCC(p) ppm [col*p->colors+c] = lut[p->image[soff][c]];
			else
				FORCC(p) ppm2[col*p->colors+c] =     p->image[soff][c];
		}
		if (p->opt.output_bps == 16 && !p->opt.output_tiff && htons(0x55aa) != 0x55aa)
			_swab ((char*)ppm2, (char*)ppm2, p->width*p->colors*2);
		fwrite (ppm, p->colors*p->opt.output_bps/8, p->width, ofp);
	}
	free (ppm);
}
