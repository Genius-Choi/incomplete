void DCR_CLASS dcr_convert_to_rgb(DCRAW* p)
{
	int row, col, c, i, j, k;
	ushort *img;
	float out[3], out_cam[3][4];
	double num, inverse[3][3], bnd[2]={0,0};
	static const double xyzd50_srgb[3][3] =
	{ { 0.436083, 0.385083, 0.143055 },
    { 0.222507, 0.716888, 0.060608 },
    { 0.013930, 0.097097, 0.714022 } };
	static const double rgb_rgb[3][3] =
	{ { 1,0,0 }, { 0,1,0 }, { 0,0,1 } };
	static const double adobe_rgb[3][3] =
	{ { 0.715146, 0.284856, 0.000000 },
    { 0.000000, 1.000000, 0.000000 },
    { 0.000000, 0.041166, 0.958839 } };
	static const double wide_rgb[3][3] =
	{ { 0.593087, 0.404710, 0.002206 },
    { 0.095413, 0.843149, 0.061439 },
    { 0.011621, 0.069091, 0.919288 } };
	static const double prophoto_rgb[3][3] =
	{ { 0.529317, 0.330092, 0.140588 },
    { 0.098368, 0.873465, 0.028169 },
    { 0.016879, 0.117663, 0.865457 } };

	static const double (*out_rgb[])[3] =
	{ rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };
	static const char *name[] =
	{ "sRGB", "Adobe RGB (1998)", "WideGamut D65", "ProPhoto D65", "XYZ" };
	static const unsigned phead[] =
	{ 1024, 0, 0x2100000, 0x6d6e7472, 0x52474220, 0x58595a20, 0, 0, 0,
    0x61637370, 0, 0, 0x6e6f6e65, 0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };
	unsigned pbody[] =
	{ 10, 0x63707274, 0, 36,	/* cprt */
	0x64657363, 0, 40,	/* desc */
	0x77747074, 0, 20,	/* wtpt */
	0x626b7074, 0, 20,	/* bkpt */
	0x72545243, 0, 14,	/* rTRC */
	0x67545243, 0, 14,	/* gTRC */
	0x62545243, 0, 14,	/* bTRC */
	0x7258595a, 0, 20,	/* rXYZ */
	0x6758595a, 0, 20,	/* gXYZ */
	0x6258595a, 0, 20 };	/* bXYZ */
	static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };
	unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };

	bnd[p->opt.gamm[1] >= 1] = 1;
	if (p->opt.gamm[1] && (p->opt.gamm[1]-1)*(p->opt.gamm[0]-1) <= 0) {
		for (i=0; i < 36; i++) {
			p->opt.gamm[2] = (bnd[0] + bnd[1])/2;
			bnd[(pow(p->opt.gamm[2]/p->opt.gamm[1],-p->opt.gamm[0])-1)/p->opt.gamm[0]-1/p->opt.gamm[2] > -1] = p->opt.gamm[2];
		}
		p->opt.gamm[3] = p->opt.gamm[2]*(1/p->opt.gamm[0]-1);
		p->opt.gamm[2] /= p->opt.gamm[1];
	}
	p->opt.gamm[4] = 1 / (p->opt.gamm[1]/2*SQR(p->opt.gamm[2]) - p->opt.gamm[3]*(1-p->opt.gamm[2]) +
		(1-pow(p->opt.gamm[2],1+p->opt.gamm[0]))*(1+p->opt.gamm[3])/(1+p->opt.gamm[0])) - 1;

	memcpy (out_cam, p->rgb_cam, sizeof out_cam);
	p->raw_color |= p->colors == 1 || p->opt.document_mode ||
		p->opt.output_color < 1 || p->opt.output_color > 5;
	if (!p->raw_color) {
		p->oprof = (unsigned *) calloc (phead[0], 1);
		dcr_merror (p, p->oprof, "convert_to_rgb()");
		memcpy (p->oprof, phead, sizeof phead);
		if (p->opt.output_color == 5) p->oprof[4] = p->oprof[5];
		p->oprof[0] = 132 + 12*pbody[0];
		for (i=0; i < (int)pbody[0]; i++) {
			p->oprof[p->oprof[0]/4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;
			pbody[i*3+2] = p->oprof[0];
			p->oprof[0] += (pbody[i*3+3] + 3) & -4;
		}
		memcpy (p->oprof+32, pbody, sizeof pbody);
		p->oprof[pbody[5]/4+2] = strlen(name[p->opt.output_color-1]) + 1;
		memcpy ((char *)p->oprof+pbody[8]+8, pwhite, sizeof pwhite);
		if (p->opt.output_bps == 8)
			pcurve[3] = (short)(256/p->opt.gamm[4]+0.5) << 16;
		for (i=4; i < 7; i++)
			memcpy ((char *)p->oprof+pbody[i*3+2], pcurve, sizeof pcurve);
		dcr_pseudoinverse ((double (*)[3]) out_rgb[p->opt.output_color-1], inverse, 3);
		for (i=0; i < 3; i++)
			for (j=0; j < 3; j++) {
				for (num = k=0; k < 3; k++)
					num += xyzd50_srgb[i][k] * inverse[j][k];
				p->oprof[pbody[j*3+23]/4+i+2] = (unsigned int)(num * 0x10000 + 0.5);
			}
			for (i=0; i < (int)(phead[0]/4); i++)
				p->oprof[i] = htonl(p->oprof[i]);
			strcpy ((char *)p->oprof+pbody[2]+8, "auto-generated by dcraw");
			strcpy ((char *)p->oprof+pbody[5]+12, name[p->opt.output_color-1]);
			for (i=0; i < 3; i++)
				for (j=0; j < p->colors; j++)
                    for (out_cam[i][j] = 0, k=0; k < 3; k++)
						out_cam[i][j] += (float)out_rgb[p->opt.output_color-1][i][k] * p->rgb_cam[k][j];
	}
	if (p->opt.verbose)
		fprintf (stderr, p->raw_color ? _("Building histograms...\n") :
	_("Converting to %s colorspace...\n"), name[p->opt.output_color-1]);

	memset (p->histogram, 0, sizeof p->histogram);
	for (img=p->image[0], row=0; row < p->height; row++)
		for (col=0; col < p->width; col++, img+=4) {
			if (!p->raw_color) {
				out[0] = out[1] = out[2] = 0;
				FORCC(p) {
					out[0] += out_cam[0][c] * img[c];
					out[1] += out_cam[1][c] * img[c];
					out[2] += out_cam[2][c] * img[c];
				}
				FORC3 img[c] = CLIP((int) out[c]);
			}
			else if (p->opt.document_mode)
				img[0] = img[FC(row,col)];
			FORCC(p) p->histogram[c][img[c] >> 3]++;
		}
	if (p->colors == 4 && p->opt.output_color) p->colors = 3;
	if (p->opt.document_mode && p->filters) p->colors = 1;
}
