void DCR_CLASS dcr_lin_interpolate(DCRAW* p)
{
	int code[16][16][32], *ip, sum[4];
	int c, i, x, y, row, col, shift, color;
	ushort *pix;

	if (p->opt.verbose) fprintf (stderr,_("Bilinear interpolation...\n"));

	dcr_border_interpolate(p,1);
	for (row=0; row < 16; row++)
		for (col=0; col < 16; col++) {
			ip = code[row][col];
			memset (sum, 0, sizeof sum);
			for (y=-1; y <= 1; y++)
				for (x=-1; x <= 1; x++) {
					shift = (y==0) + (x==0);
					if (shift == 2) continue;
					color = dcr_fc(p,row+y,col+x);
					*ip++ = (p->width*y + x)*4 + color;
					*ip++ = shift;
					*ip++ = color;
					sum[color] += 1 << shift;
				}
				FORCC(p)
					if (c != dcr_fc(p,row,col)) {
						*ip++ = c;
						*ip++ = 256 / sum[c];
					}
		}
	for (row=1; row < p->height-1; row++)
		for (col=1; col < p->width-1; col++) {
			pix = p->image[row*p->width+col];
			ip = code[row & 15][col & 15];
			memset (sum, 0, sizeof sum);
			for (i=8; i--; ip+=3)
				sum[ip[2]] += pix[ip[0]] << ip[1];
			for (i=p->colors; --i; ip+=2)
				pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;
		}
}
