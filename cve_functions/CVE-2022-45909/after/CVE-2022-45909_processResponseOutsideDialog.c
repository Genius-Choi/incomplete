    int SipDialogController::processResponseOutsideDialog( nta_outgoing_t* orq, sip_t const* sip )  {
        DR_LOG(log_debug) << "SipDialogController::processResponseOutsideDialog"  ;
        string transactionId ;
        std::shared_ptr<SipDialog> dlg ;

        string encodedMessage ;
        bool truncated ;
        msg_t* msg = nta_outgoing_getresponse(orq) ;    //adds a reference
        SipMsgData_t meta( msg, orq, "network") ;

        EncodeStackMessage( sip, encodedMessage ) ;

        if( sip->sip_cseq->cs_method == sip_method_invite || sip->sip_cseq->cs_method == sip_method_subscribe ) {
            std:shared_ptr<IIP> iip;

            //check for retransmission 
            if (sip->sip_cseq->cs_method == sip_method_invite && m_timerDHandler.resendIfNeeded(orq)) {
                DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - retransmitted ACK for callid: " << sip->sip_call_id->i_id  <<
                    " for invite with orq: " << std::hex << (void *) orq;
                msg_destroy( msg ) ; 
                return 0;
            }

            if (!IIP_FindByOrq(m_invitesInProgress, orq, iip)) {
                DR_LOG(log_error) << "SipDialogController::processResponseOutsideDialog - unable to match invite response with callid: " << sip->sip_call_id->i_id  ;
                //TODO: do I need to destroy this transaction?
                msg_destroy( msg ) ; 
                return -1 ; //TODO: check meaning of return value           
            }      
            transactionId = iip->getTransactionId() ;   
            dlg = iip->dlg() ;   


            //update dialog variables            
            dlg->setSipStatus( sip->sip_status->st_status ) ;
            if( sip->sip_payload ) {
                iip->dlg()->setRemoteSdp( sip->sip_payload->pl_data, sip->sip_payload->pl_len ) ;
            }

            // stats
            if (theOneAndOnlyController->getStatsCollector().enabled()) {
                // post-dial delay
                if (sip->sip_cseq->cs_method == sip_method_invite && dlg->getSipStatus() <= 200) {
                    auto now = std::chrono::steady_clock::now();
                    std::chrono::duration<double> diff = now - dlg->getArrivalTime();
                    if (!dlg->hasAlerted()) {
                        dlg->alerting();
                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_PDD_OUT, diff.count())
                    }
                    if (200 == dlg->getSipStatus()) {
                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_RESPONSE_TIME_OUT, diff.count())
                    }
                }
            }


            //UAC Dialog is added when we receive a final response from the network, or a reliable provisional response
            //for non-success responses, it will subsequently be removed when we receive the ACK from the client

            if( (sip->sip_cseq->cs_method == sip_method_invite && 
                    (200 == sip->sip_status->st_status || (sip->sip_status->st_status > 100 && sip->sip_status->st_status < 200 && sip->sip_rseq))) || 
                (sip->sip_cseq->cs_method == sip_method_subscribe && 
                    (202 == sip->sip_status->st_status || 200 == sip->sip_status->st_status) ) )  {

                DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - adding dialog id: " << dlg->getDialogId()  ;
                nta_leg_t* leg = const_cast<nta_leg_t *>(iip->leg()) ;
                nta_leg_rtag( leg, sip->sip_to->a_tag) ;
                nta_leg_client_reroute( leg, sip->sip_record_route, sip->sip_contact, 1 );

                bool nat = false;
                const sip_route_t* route = NULL;
                if (nta_leg_get_route(leg, &route, NULL) >= 0 && route && route->r_url->url_host && isRfc1918(route->r_url->url_host)) {
                    DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client at RFC1918 address: " << route->r_url->url_host  ;
                    nat = true;
                }
                else if(sip->sip_cseq->cs_method == sip_method_invite && !route && sip->sip_contact && 
                    0 != strcmp(sip->sip_contact->m_url->url_host, meta.getAddress().c_str())) {

                    DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - (UAC) detected downstream client; contact ip: " << 
                        sip->sip_contact->m_url->url_host << " differs from recv address: " << meta.getAddress().c_str();
                    nat = true;
                }
                else if (theOneAndOnlyController->isAggressiveNatEnabled() && sipMsgHasNatEqualsYes(sip, true, true)) {
                        DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client advertising nat=yes";
                    nat = true;
                }

                if (nat && theOneAndOnlyController->isNatDetectionDisabled()) {
                    nat = false;
                    DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client, but ignoring because disable-nat-detection is on";
                }
                if (nat) {
                    url_t const * url = nta_outgoing_route_uri(orq);
                    string routeUri = string((url ? url->url_scheme : "sip")) + ":" + meta.getAddress() + ":" + meta.getPort();
                    dlg->setRouteUri(routeUri);
                    DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - (UAC) detected nat setting route to: " <<   routeUri;
                }
                else {
                    dlg->clearRouteUri();
                }
                if (iip->isCanceled()) {
                    DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - ACK/BYE race condition - received 200 OK to INVITE that was previously CANCELED";
                    dlg->doAckBye();
                }
                addDialog( dlg ) ;
            }
            tport_t* tp = nta_outgoing_transport(orq);
            if (sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status == 200 && tport_is_dgram(tp)) {
                // for successful uac invites, we need to handle retransmits
                m_timerDHandler.addInvite(orq);
            }
            tport_unref(tp);

            if (sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status == 200 && sip->sip_session_expires) {
                DR_LOG(log_info) << "SipDialogController::processResponseOutsideDialog - (UAC) detected session timer header: ";
                dlg->setSessionTimer( sip->sip_session_expires->x_delta, 
                    !sip->sip_session_expires->x_refresher || 0 == strcmp( sip->sip_session_expires->x_refresher, "uac") ? 
                    SipDialog::we_are_refresher : 
                    SipDialog::they_are_refresher) ;
            }
            else if (sip->sip_status->st_status > 200) {
                IIP_Clear(m_invitesInProgress, iip);
            }
        }
        else {
            std::shared_ptr<RIP> rip ;
            if( !findRIPByOrq( orq, rip ) ) {
                DR_LOG(log_error) << "SipDialogController::processResponseOutsideDialog - unable to match response with callid for a non-invite request we sent: " << sip->sip_call_id->i_id  ;
                //TODO: do I need to destroy this transaction?
                return -1 ; //TODO: check meaning of return value                           
            }
            transactionId = rip->getTransactionId() ;
            if( sip->sip_status->st_status >= 200 ) this->clearRIP( orq ) ;
        }
        
        if( !dlg ) {
            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, transactionId ) ;
        }
        else {
            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, transactionId, dlg->getDialogId() ) ;            
        }

        if( sip->sip_cseq->cs_method == sip_method_invite) {
          if (sip->sip_status->st_status >= 300) {
            Cdr::postCdr( std::make_shared<CdrStop>( msg, "network",
                487 == sip->sip_status->st_status ? Cdr::call_canceled : Cdr::call_rejected ) );
          }
          else if (sip->sip_status->st_status == 200) {
            Cdr::postCdr( std::make_shared<CdrStart>( msg, "network", Cdr::uac ) );                
          }
        }
        if( sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status > 200 ) {
            assert( dlg ) ;
            m_pController->getClientController()->removeDialog( dlg->getDialogId() ) ;
        }

        msg_destroy( msg ) ;                            //releases reference

        return 0 ;
    }
