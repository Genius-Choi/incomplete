    int SipDialogController::processRequestInsideDialog( nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip) {
        DR_LOG(log_debug) << "SipDialogController::processRequestInsideDialog: " << sip->sip_request->rq_method_name << " irq " << irq  ;
        int rc = 0 ;
        string transactionId ;
        generateUuid( transactionId ) ;

        switch (sip->sip_request->rq_method) {
            case sip_method_ack:
            {
                /* ack to 200 OK comes here  */
                std::shared_ptr<IIP> iip ;
                std::shared_ptr<SipDialog> dlg ;       
                if (!IIP_FindByLeg(m_invitesInProgress, leg, iip)) {
                    
                    /* not a new INVITE, so it should be found as an existing dialog; i.e. a reINVITE */
                    if( !findDialogByLeg( leg, dlg ) ) {
                        DR_LOG(log_error) << "SipDialogController::processRequestInsideDialog - unable to find Dialog for leg"  ;
                        assert(0) ;
                        return -1 ;
                    }
                }
                else {
                    transactionId = iip->getTransactionId() ;
                    dlg = iip->dlg();
                    IIP_Clear(m_invitesInProgress, iip);
                    this->clearSipTimers(dlg);
                    //addDialog( dlg ) ;  now adding when we send the 200 OK
                }
                string encodedMessage ;
                msg_t* msg = nta_incoming_getrequest( irq ) ; // adds a reference
                EncodeStackMessage( sip, encodedMessage ) ;
                SipMsgData_t meta( msg, irq ) ;
                msg_destroy(msg) ;      // releases the reference

                m_pController->getClientController()->route_ack_request_inside_dialog(  encodedMessage, meta, irq, sip, transactionId, dlg->getTransactionId(), dlg->getDialogId() ) ;

                nta_incoming_destroy(irq) ;
                break ;
            }
            case sip_method_cancel:
            {
                // this should only happen in a race condition, where we've sent the 200 OK but not yet received an ACK 
                //  in this case, send a 481 to the CANCEL and then generate a BYE
                std::shared_ptr<SipDialog> dlg ;
                if( !this->findDialogByLeg( leg, dlg ) ) {
                    DR_LOG(log_error) << "SipDialogController::processRequestInsideDialog - unable to find Dialog for leg"  ;
                    return 481 ;
                    assert(0) ;
                    return -1;
                }
                DR_LOG(log_warning) << "SipDialogController::processRequestInsideDialog - received CANCEL after 200 OK; reply 481 and tear down dialog"  ;
                this->clearSipTimers(dlg);

                // 481 to the CANCEL
                nta_incoming_treply( irq, SIP_481_NO_TRANSACTION, TAG_END() ) ;  

                // BYE to the far end
                nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,
                                        NULL,
                                        SIP_METHOD_BYE,
                                        NULL,
                                        SIPTAG_REASON_STR("SIP ;cause=200 ;text=\"CANCEL after 200 OK\""),
                                        TAG_END() ) ;

                msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference
                sip_t* sip = sip_object( m ) ;

                DR_LOG(log_info) << "SipDialogController::processRequestInsideDialog - (cancel) created orq " << std::hex << (void *) orq  <<
                    " call-id " << sip->sip_call_id->i_id;

                string encodedMessage ;
                EncodeStackMessage( sip, encodedMessage ) ;
                SipMsgData_t meta(m, orq) ;
                string s ;
                meta.toMessageFormat(s) ;

                m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, "unsolicited", dlg->getDialogId() ) ;
                msg_destroy(m);      // releases the reference

                nta_outgoing_destroy(orq) ;
                SD_Clear(m_dialogs, leg ) ;

            }
            default:
            {
                std::shared_ptr<SipDialog> dlg ;
                if( !this->findDialogByLeg( leg, dlg ) ) {
                    DR_LOG(log_error) << "SipDialogController::processRequestInsideDialog - unable to find Dialog for leg"  ;
                    return 481 ;
                    assert(0) ;
                }

                if (sip_method_invite == sip->sip_request->rq_method) {
                    nta_incoming_treply(irq, SIP_100_TRYING, TAG_END());
                }

                /* if this is a re-INVITE or an UPDATE deal with session timers */
                if( sip_method_invite == sip->sip_request->rq_method || sip_method_update == sip->sip_request->rq_method ) {
                    bool weAreRefresher = false;
                    if( dlg->hasSessionTimer() ) { 
                        DR_LOG(log_info) << "SipDialogController::processRequestInsideDialog - canceling session expires timer due to re-invite"  ;
                        weAreRefresher = dlg->areWeRefresher();
                        dlg->cancelSessionTimer() ;
                    }

                    /* reject if session timer is too small */
                    if( sip->sip_session_expires && sip->sip_session_expires->x_delta < dlg->getMinSE() ) {
                        ostringstream o ;
                        o << dlg->getMinSE() ;
                        nta_incoming_treply( irq, SIP_422_SESSION_TIMER_TOO_SMALL, 
                            SIPTAG_MIN_SE_STR(o.str().c_str()),
                            TAG_END() ) ;  
                        return 0 ;             
                    }
                    if( sip->sip_session_expires ) {
                        dlg->setSessionTimer( sip->sip_session_expires->x_delta, 
                            (!sip->sip_session_expires->x_refresher && weAreRefresher) ||(sip->sip_session_expires->x_refresher && 0 == strcmp( sip->sip_session_expires->x_refresher, "uac")) ? 
                            SipDialog::they_are_refresher : 
                            SipDialog::we_are_refresher) ;
                    }

                }

                string encodedMessage ;
                msg_t* msg = nta_incoming_getrequest( irq ) ;   //adds a reference
                EncodeStackMessage( sip, encodedMessage ) ;
                SipMsgData_t meta( msg, irq ) ;
                msg_destroy( msg ); // release the reference

                bool routed = m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, transactionId, dlg->getDialogId() ) ;
                if (!routed && dlg->getSipStatus() < 200) {
                    // got a request before we sent a 200 OK to the initial INVITE, treat as an out-of-dialog request
                    switch (sip->sip_request->rq_method) {
                        case sip_method_notify:
                        case sip_method_options:
                        case sip_method_info:
                        case sip_method_message:
                        case sip_method_publish:
                        case sip_method_subscribe:
                            return m_pController->processMessageStatelessly( msg, (sip_t*) sip);
                        default:
                        break;
                    }
                }

                addIncomingRequestTransaction( irq, transactionId) ;
    
                if( sip_method_bye == sip->sip_request->rq_method || 
                    (sip_method_notify == sip->sip_request->rq_method && !dlg->isInviteDialog() &&
                        NULL != sip->sip_subscription_state && 
                        NULL != sip->sip_subscription_state->ss_substate &&
                        NULL != strstr(sip->sip_subscription_state->ss_substate, "terminated") ) 
                ) {

                    this->clearSipTimers(dlg);

                    //clear dialog when we send a 200 OK response to BYE
                    SD_Clear(m_dialogs, leg ) ;
                    if( !routed ) {
                        nta_incoming_treply( irq, SIP_481_NO_TRANSACTION, TAG_END() ) ;                
                    }
                }

                if (sip_method_bye == sip->sip_request->rq_method) {
                  Cdr::postCdr( std::make_shared<CdrStop>( msg, "network", Cdr::normal_release ) );
                }
            }
        }
        return rc ;
    }
