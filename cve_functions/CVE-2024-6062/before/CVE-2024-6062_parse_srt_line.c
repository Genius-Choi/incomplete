static GF_Err parse_srt_line(GF_TXTIn *ctx, char *szLine, u32 *char_l, Bool *set_start_c, Bool *set_end_c)
{
	u32 i, char_line, j, rem_styles, len;
	Bool rem_color;
	char *ptr = szLine;
	unsigned short uniLine[5000], uniText[5000], *sptr;
	char szText[2048];

	len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);
	if (len == GF_UTF8_FAIL) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Invalid UTF data (line %d)\n", ctx->curLine));
		ctx->state = 0;
		return GF_NON_COMPLIANT_BITSTREAM;
	}

	i=j=0;
	rem_styles = 0;
	rem_color = 0;
	while (i<len) {
		u32 font_style = 0;
		u32 style_nb_chars = 0;
		u32 style_def_type = 0;

		if ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {
			style_nb_chars = 3;
			style_def_type = 1;
		}
		else if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {
			style_def_type = 2;
			style_nb_chars = 4;
		}
		else if (uniLine[i]=='<')  {
			const unsigned short* src = uniLine + i;
			u32 alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);
			if (alen == GF_UTF8_FAIL) alen = 0;
			szLine[alen] = 0;
			strlwr(szLine);
			if (!strncmp(szLine, "<font ", 6) ) {
				char *a_sep = strstr(szLine, "color");
				if (a_sep) a_sep = strstr(szLine, "=");
				if (a_sep) a_sep++;
				while (a_sep && a_sep[0]) {
					if (a_sep[0]!=' ') break;
					a_sep++;
				}
				if (a_sep) {
					char *e_sep;
					if ((a_sep[0]=='"') || ((a_sep[0]=='\''))) {
						e_sep = strchr(a_sep+1, a_sep[0]);
						a_sep++;
					} else {
						e_sep=a_sep;
						while (e_sep[0]) {
							if (e_sep[0]==' ') break;
							if (e_sep[0]=='>') break;
							e_sep++;
						}
					}

					if (e_sep) {
						char c_sep = e_sep[0];
						e_sep[0] = 0;
						font_style = gf_color_parse(a_sep);
						e_sep[0] = c_sep;
						if (c_sep!='>')
							e_sep = strchr(e_sep+1, '>');
						if (e_sep) {
							style_nb_chars = (u32) (1 + e_sep - szLine);
							style_def_type = 1;
						}
					}
				}
			}
			else if (!strncmp(szLine, "</font>", 7) ) {
				style_nb_chars = 7;
				style_def_type = 2;
				font_style = 0xFFFFFFFF;
			}


			else if (!strncmp(szLine, "<strike>", 8) ) {
				style_nb_chars = 8;
				style_def_type = 1;
			}
			else if (!strncmp(szLine, "</strike>", 9) ) {
				style_nb_chars = 9;
				style_def_type = 2;
				font_style = 0xFFFFFFFF;
			}
			//skip unknown
			else {
				char *a_sep = strstr(szLine, ">");
				if (a_sep) {
					style_nb_chars = (u32) (1 + a_sep - szLine);
					i += style_nb_chars;
					continue;
				}
			}

		}

		/*start of new style*/
		if (style_def_type==1)  {
			/*store prev style*/
			if (*set_end_c) {
				gf_assert(*set_start_c);
				gf_isom_text_add_style(ctx->samp, &ctx->style);
				*set_end_c = *set_start_c = GF_FALSE;
				ctx->style.style_flags &= ~rem_styles;
				rem_styles = 0;
				if (rem_color) {
					ctx->style.text_color = ctx->default_color;
					rem_color = 0;
				}
			}
			if (*set_start_c && (ctx->style.startCharOffset != j)) {
				ctx->style.endCharOffset = *char_l + j;
				if (ctx->style.style_flags) gf_isom_text_add_style(ctx->samp, &ctx->style);
			}
			switch (uniLine[i+1]) {
			case 'b':
			case 'B':
				ctx->style.style_flags |= GF_TXT_STYLE_BOLD;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 'i':
			case 'I':
				ctx->style.style_flags |= GF_TXT_STYLE_ITALIC;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 'u':
			case 'U':
				ctx->style.style_flags |= GF_TXT_STYLE_UNDERLINED;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 's':
			case 'S':
				ctx->style.style_flags |= GF_TXT_STYLE_STRIKETHROUGH;
				*set_start_c = GF_TRUE;
				ctx->style.startCharOffset = *char_l + j;
				break;
			case 'f':
			case 'F':
				if (font_style) {
					ctx->style.text_color = font_style;
					*set_start_c = GF_TRUE;
					ctx->style.startCharOffset = *char_l + j;
				}
				break;
			}
			i += style_nb_chars;
			continue;
		}

		/*end of prev style*/
		if (style_def_type==2)  {
			switch (uniLine[i+2]) {
			case 'b':
			case 'B':
				rem_styles |= GF_TXT_STYLE_BOLD;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 'i':
			case 'I':
				rem_styles |= GF_TXT_STYLE_ITALIC;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 'u':
			case 'U':
				rem_styles |= GF_TXT_STYLE_UNDERLINED;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 's':
			case 'S':
				rem_styles |= GF_TXT_STYLE_STRIKETHROUGH;
				*set_end_c = GF_TRUE;
				ctx->style.endCharOffset = *char_l + j;
				break;
			case 'f':
			case 'F':
				if (font_style) {
					rem_color = 1;
					*set_end_c = GF_TRUE;
					ctx->style.endCharOffset = *char_l + j;
				}
			}
			i+=style_nb_chars;
			continue;
		}
		/*store style*/
		if (*set_end_c) {
			gf_isom_text_add_style(ctx->samp, &ctx->style);
			*set_end_c = GF_FALSE;
			*set_start_c = GF_TRUE;
			ctx->style.startCharOffset = *char_l + j;
			ctx->style.style_flags &= ~rem_styles;
			rem_styles = 0;
			ctx->style.text_color = ctx->default_color;
			rem_color = 0;
		}

		uniText[j] = uniLine[i];
		j++;
		i++;
	}
	/*store last style*/
	if (*set_end_c) {
		gf_isom_text_add_style(ctx->samp, &ctx->style);
		*set_end_c = GF_FALSE;
		*set_start_c = GF_TRUE;
		ctx->style.startCharOffset = *char_l + j;
		ctx->style.style_flags &= ~rem_styles;
	}

	char_line = j;
	uniText[j] = 0;

	sptr = (u16 *) uniText;
	len = gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);
	if (len == GF_UTF8_FAIL) len = 0;

	gf_isom_text_add_text(ctx->samp, szText, len);
	if (ctx->forced_sub) gf_isom_text_set_forced(ctx->samp, GF_TRUE);
	*char_l += char_line;
	return GF_OK;
}
