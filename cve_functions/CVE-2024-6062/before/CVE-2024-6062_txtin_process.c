static GF_Err txtin_process(GF_Filter *filter)
{
	GF_TXTIn *ctx = gf_filter_get_udta(filter);
	GF_FilterPacket *pck;
	GF_Err e;
	u32 size=0;
	const u8 *data;
	pck = gf_filter_pid_get_packet(ctx->ipid);
	if (pck) ctx->is_loaded = GF_FALSE;

	//no input and not suspended, check eos
	if (!pck) {
		if (ctx->pid_framed || (!ctx->file_name && !ctx->is_suspended)) {
			if (gf_filter_pid_is_eos(ctx->ipid)) {
				if (ctx->end) {
#ifndef GPAC_DISABLE_VTT
					if (ctx->vttparser) {
						gf_webvtt_parser_flush(ctx->vttparser);
					}
					else
#endif
					if (!ctx->noflush) {
						gf_isom_text_reset(ctx->samp);
						txtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);
					}
					ctx->end = 0;
				}
				gf_filter_pid_set_eos(ctx->opid);
				return GF_EOS;
			}
		}
		if (!ctx->is_loaded)
			return GF_OK;
	}
	ctx->is_suspended = GF_FALSE;

	data = pck ? gf_filter_pck_get_data(pck, &size) : NULL;
	if (pck && (!data || !size)) {
		gf_filter_pid_drop_packet(ctx->ipid);
		return GF_OK;
	}
	if (ctx->fmt==GF_TXTIN_MODE_PROBE) {
		GF_Blob b;
		memset(&b, 0, sizeof(GF_Blob));
		b.size = size;
		b.data = (u8 *)data;
		char *url = gf_blob_register(&b);
		u32 fmt;
		gf_text_guess_format(ctx, url, &fmt);
		gf_blob_unregister(&b);
		gf_free(url);
		if (!fmt) {
			gf_filter_pid_drop_packet(ctx->ipid);
			gf_filter_setup_failure(filter, GF_NOT_SUPPORTED);
			return GF_NOT_SUPPORTED;
		}
		e = txtin_configure_pid_ex(filter, ctx->ipid, GF_FALSE, fmt);
		if (e) {
			gf_filter_pid_drop_packet(ctx->ipid);
			return e;
		}
	}

	if (ctx->pid_framed) {
		ctx->in_over = GF_TRUE;
	} else if (pck) {
		Bool start=GF_FALSE, end=GF_FALSE;
		gf_filter_pck_get_framing(pck, &start, &end);
		if (end) ctx->in_over = GF_TRUE;
	}

	if (ctx->pid_framed || !ctx->file_name) {
		if (ctx->single_text_chunk) {
			e = ctx->text_process(filter, ctx, pck);
			if (pck) gf_filter_pid_drop_packet(ctx->ipid);
			return e;
		}
		e = GF_OK;
		//append data to our blob
		if (data && size) {
			if (size+ctx->tmp_blob.size >= ctx->tmp_buf_alloc) {
				ctx->tmp_buf_alloc = size+ctx->tmp_blob.size+1;
				ctx->tmp_blob.data = gf_realloc(ctx->tmp_blob.data, ctx->tmp_buf_alloc);
				if (!ctx->tmp_blob.data) {
					if (pck) gf_filter_pid_drop_packet(ctx->ipid);
					return GF_OUT_OF_MEM;
				}
			}
			memcpy(ctx->tmp_blob.data + ctx->tmp_blob.size, data, size);
			ctx->tmp_blob.size += size;
			ctx->tmp_blob.data[ctx->tmp_blob.size] = 0;
			if (!ctx->blob_name) ctx->blob_name = gf_blob_register(&ctx->tmp_blob);
		}
		if (!ctx->pid_framed && ctx->full_file_only) {
			//we need full file to parse, wait end of file
			if (pck) {
				if (!ctx->in_over) {
					gf_filter_pid_drop_packet(ctx->ipid);
					return GF_OK;
				}
				ctx->full_file_only = GF_FALSE;
			} else {
				return GF_OK;
			}
		}

		ctx->src = gf_file_temp(NULL);
		if (!ctx->src)
			e = GF_IO_ERR;
		else if (gf_fwrite(ctx->tmp_blob.data, ctx->tmp_blob.size, ctx->src) != ctx->tmp_blob.size)
			e = GF_IO_ERR;
		gf_fseek(ctx->src, 0, SEEK_SET);
		//init state as parsing SRT payload
		if (ctx->pid_framed) {
			ctx->state = 2;
			ctx->start = gf_filter_pck_get_cts(pck);
			ctx->end = ctx->start + gf_filter_pck_get_duration(pck);
			ctx->curLine = 0;
		}

		if (!e)
			e = ctx->text_process(filter, ctx, pck);

		//purge data from our blob
		if (ctx->src) {
			u32 pos = gf_ftell(ctx->src);
			u32 remain = ctx->tmp_blob.size - pos;
			gf_fclose(ctx->src);
			ctx->src = NULL;
			if (ctx->pid_framed) {
				ctx->tmp_blob.size = 0;
			} else if (pos) {
				memmove(ctx->tmp_blob.data, ctx->tmp_blob.data+pos, remain);
				ctx->tmp_blob.size = remain;
				ctx->tmp_blob.data[remain] = 0;
			} else {
				//some parsers (XML ones) will not use the file at all,
				//if nothing is read, assume first load is done and move to suspended mode
				ctx->is_suspended = GF_TRUE;
				ctx->is_loaded = GF_TRUE;
			}
		}
		if (e==GF_EOS) e = GF_OK;

		if (pck) gf_filter_pid_drop_packet(ctx->ipid);
		return e;
	}

	if (pck) {
		if (!ctx->in_over) {
			gf_filter_pid_drop_packet(ctx->ipid);
			return GF_OK;
		}
		//file is loaded
		ctx->is_loaded = GF_TRUE;
	}

	e = ctx->text_process(filter, ctx, NULL);
	if (e==GF_EOS) {
		//keep input alive until end of stream, so that we keep getting called
		if (pck)
			gf_filter_pid_drop_packet(ctx->ipid);

		if (gf_filter_pid_is_eos(ctx->ipid)) {
			if (ctx->has_forced & 4) {
				if (ctx->has_forced & 2) gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_FORCED_SUB, &PROP_UINT(2));
				else if (ctx->has_forced & 1) gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_FORCED_SUB, &PROP_UINT(1));
			}
			gf_filter_pid_set_eos(ctx->opid);
		}
	}
	return e;
}
