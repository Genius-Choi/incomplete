u64 ttml_get_timestamp_ex(char *value, u32 tick_rate, u32 *ttml_fps_num, u32 *ttml_fps_den, u32 *ttml_sfps)
{
	u32 h, m, s, ms, f, sf;
	u64 ts = GF_FILTER_NO_TS;
	u32 len = (u32) strlen(value);

	//tick metrick - cannot be fractional
	if (len && (value[len-1]=='t')) {
		value[len-1] = 0;
		ts = (s64) (atoi(value) * 1000);
		value[len-1] = 't';
		if (tick_rate)
			ts /= tick_rate;
	}
	//hours metric, can be fractional
	else if (len && (value[len-1]=='h')) {
		value[len-1] = 0;
		ts = (s64) (atof(value) * 1000 * 3600);
		value[len-1] = 'h';
	}
	//minutes metric, can be fractional
	else if (len && (value[len-1]=='m')) {
		value[len-1] = 0;
		ts = (s64) (atof(value) * 1000 * 60);
		value[len-1] = 'm';
	}
	else if (len && (value[len-1]=='s')) {
		//milliseconds metric, can be fractional but we work at 1ms clock resolution anyway
		if ((len > 1) && (value[len-2]=='m')) {
			value[len-2] = 0;
			ts = (s64) (atof(value));
			value[len-2] = 'm';
		}
		//seconds metric, can be fractional
		else {
			value[len-1] = 0;
			ts = (s64) (atof(value) * 1000);
			value[len-1] = 's';
		}
	}
	//frames metric, can be fractional
	else if (len && (value[len-1]=='f')) {
		f = sf = 0;
		value[len-1] = 0;
		if (sscanf(value, "%u.%u", &f, &sf) != 2) {
			sscanf(value, "%u", &f);
			sf = 0;
		}
		value[len-1] = 'f';

		if (! *ttml_fps_num) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\n"));
			*ttml_fps_num = 25;
			*ttml_fps_den = 1;
		}
		if (sf && ! *ttml_sfps) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\n"));
			*ttml_sfps = 1;
		}
		ts = ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;
		if (sf)
			ts += ((s64) 1000 * sf * *ttml_fps_den / *ttml_sfps) / *ttml_fps_num;
	}
	else {
		u32 nb_val=0;
		Bool has_dot=GF_FALSE;
		u32 vals[6];
		char *cur = value;
		while (cur) {
			char sep;
			char *next_col = strchr(cur, ':');
			if (!next_col) next_col = strchr(cur, '.');
			if (next_col) {
				sep = next_col[0];
				next_col[0] = 0;
			}
			vals[nb_val] = atoi(cur);
			nb_val++;
			if (!next_col) break;
			has_dot = (sep=='.') ? GF_TRUE : GF_FALSE;
			next_col[0] = sep;
			cur = next_col+1;
			if (nb_val>6) break;
		}
		h = vals[0];
		m = vals[1];
		s = vals[2];
		if (nb_val==4) {
			ms = vals[3];
			if (has_dot) {
				ts = (h*3600 + m*60+s)*1000+ms;
			} else {
				ts = (h*3600 + m*60+s)*1000;
				if (! *ttml_fps_num) {
					GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\n"));
					*ttml_fps_num = 25;
					*ttml_fps_den = 1;
				}
				ts += ((s64) 1000 * ms * *ttml_fps_den) / *ttml_fps_num;
			}
		} else if (nb_val==5) {
			ms = vals[3];
			sf = vals[4];
			ts = (h*3600 + m*60+s)*1000;
			if (! *ttml_fps_num) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\n"));
				*ttml_fps_num = 25;
				*ttml_fps_den = 1;
			}
			if (! *ttml_sfps) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\n"));
				*ttml_sfps = 1;
			}
			ts += ((s64) 1000 * ms * *ttml_fps_den) / *ttml_fps_num;
			ts += ((s64) 1000 * sf * *ttml_fps_den / *ttml_sfps) / *ttml_fps_num;
		} else if (nb_val==3) {
			ts = (h*3600 + m*60+s)*1000;
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TTML EBU-TTD] Invalid timestamp %s\n", value));
			ts = (h*3600 + m*60+s)*1000;
		}
	}
	return ts;
}
