k5_asn1_full_encode(const void *rep, const struct atype_info *a,
                    krb5_data **code_out)
{
    krb5_error_code ret;
    asn1buf buf;
    krb5_data *d;
    uint8_t *bytes;

    *code_out = NULL;

    if (rep == NULL)
        return ASN1_MISSING_FIELD;

    /* Make a first pass over rep to count the encoding size. */
    buf.ptr = NULL;
    buf.count = 0;
    ret = encode_atype_and_tag(&buf, rep, a);
    if (ret)
        return ret;

    /* Allocate space for the encoding. */
    bytes = malloc(buf.count + 1);
    if (bytes == NULL)
        return ENOMEM;
    bytes[buf.count] = 0;

    /* Make a second pass over rep to encode it.  buf.ptr moves backwards as we
     * encode, and will always exactly return to the base. */
    buf.ptr = bytes + buf.count;
    buf.count = 0;
    ret = encode_atype_and_tag(&buf, rep, a);
    if (ret) {
        free(bytes);
        return ret;
    }
    assert(buf.ptr == bytes);

    /* Create the output data object. */
    *code_out = malloc(sizeof(*d));
    if (*code_out == NULL) {
        free(bytes);
        return ENOMEM;
    }
    **code_out = make_data(bytes, buf.count);
    return 0;
}
