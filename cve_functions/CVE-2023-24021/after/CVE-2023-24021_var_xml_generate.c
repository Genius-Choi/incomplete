static int var_xml_generate(modsec_rec *msr, msre_var *var, msre_rule *rule,
    apr_table_t *vartab, apr_pool_t *mptmp)
{
    const apr_array_header_t *tarr;
    const apr_table_entry_t *telts;
    xmlXPathContextPtr xpathCtx;
    xmlXPathObjectPtr xpathObj;
    xmlNodeSetPtr nodes;
    const xmlChar* xpathExpr = NULL;
    int i, count;

    /* Is there an XML document tree at all? */
    if ((msr->xml == NULL)||(msr->xml->doc == NULL)) {
        /* Sorry, we've got nothing to give! */
        return 0;
    }

    if (var->param == NULL) {
        /* Invocation without an XPath expression makes sense
         * with functions that manipulate the document tree.
         */
        msre_var *rvar = apr_pmemdup(mptmp, var, sizeof(msre_var));

        rvar->value = apr_pstrdup(mptmp, "[XML document tree]");
        rvar->value_len = strlen(rvar->value);
        apr_table_addn(vartab, rvar->name, (void *)rvar);

        return 1;
    }

    /* Process the XPath expression. */

    count = 0;
    xpathExpr = (const xmlChar*)var->param;

    xpathCtx = xmlXPathNewContext(msr->xml->doc);
    if (xpathCtx == NULL) {
        msr_log(msr, 1, "XML: Unable to create new XPath context.");
        return -1;
    }

    /* Look through the actionset of the associated rule
     * for the namespace information. Register them if any are found.
     */
    tarr = apr_table_elts(rule->actionset->actions);
    telts = (const apr_table_entry_t*)tarr->elts;
    for (i = 0; i < tarr->nelts; i++) {
        msre_action *action = (msre_action *)telts[i].val;

        if (strcasecmp(action->metadata->name, "xmlns") == 0) {
            char *prefix, *href;

            if (parse_name_eq_value(mptmp, action->param, &prefix, &href) < 0) return -1;
            if ((prefix == NULL)||(href == NULL)) return -1;

            if(xmlXPathRegisterNs(xpathCtx, (const xmlChar*)prefix, (const xmlChar*)href) != 0) {
                msr_log(msr, 1, "Failed to register XML namespace href \"%s\" prefix \"%s\".",
                    log_escape(mptmp, prefix), log_escape(mptmp, href));
                return -1;
            }

            msr_log(msr, 4, "Registered XML namespace href \"%s\" prefix \"%s\".",
                log_escape(mptmp, prefix), log_escape(mptmp, href));
        }
    }

    /* Initialise XPath expression. */
    xpathObj = xmlXPathEvalExpression(xpathExpr, xpathCtx);
    if (xpathObj == NULL) {
        msr_log(msr, 1, "XML: Unable to evaluate xpath expression.");
        xmlXPathFreeContext(xpathCtx);
        return -1;
    }

    /* Evaluate XPath expression. */
    nodes = xpathObj->nodesetval;
    if (nodes == NULL) {
        xmlXPathFreeObject(xpathObj);
        xmlXPathFreeContext(xpathCtx);
        return 0;
    }

    /* Create one variable for each node in the result. */
    for(i = 0; i < nodes->nodeNr; i++) {
        msre_var *rvar = NULL;
        char *content = NULL;

        content = (char *)xmlNodeGetContent(nodes->nodeTab[i]);
        if (content != NULL) {
            rvar = apr_pmemdup(mptmp, var, sizeof(msre_var));
            rvar->value = apr_pstrdup(mptmp, content);
            xmlFree(content);
            rvar->value_len = strlen(rvar->value);
            apr_table_addn(vartab, rvar->name, (void *)rvar);

            count++;
         }
    }

    xmlXPathFreeObject(xpathObj);
    xmlXPathFreeContext(xpathCtx);

    return count;
}
