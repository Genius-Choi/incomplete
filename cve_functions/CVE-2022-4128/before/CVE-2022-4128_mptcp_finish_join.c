bool mptcp_finish_join(struct sock *ssk)
{
	struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);
	struct mptcp_sock *msk = mptcp_sk(subflow->conn);
	struct sock *parent = (void *)msk;
	bool ret = true;

	pr_debug("msk=%p, subflow=%p", msk, subflow);

	/* mptcp socket already closing? */
	if (!mptcp_is_fully_established(parent)) {
		subflow->reset_reason = MPTCP_RST_EMPTCP;
		return false;
	}

	if (!list_empty(&subflow->node))
		goto out;

	if (!mptcp_pm_allow_new_subflow(msk))
		goto err_prohibited;

	/* active connections are already on conn_list.
	 * If we can't acquire msk socket lock here, let the release callback
	 * handle it
	 */
	mptcp_data_lock(parent);
	if (!sock_owned_by_user(parent)) {
		ret = __mptcp_finish_join(msk, ssk);
		if (ret) {
			sock_hold(ssk);
			list_add_tail(&subflow->node, &msk->conn_list);
		}
	} else {
		sock_hold(ssk);
		list_add_tail(&subflow->node, &msk->join_list);
		__set_bit(MPTCP_FLUSH_JOIN_LIST, &msk->cb_flags);
	}
	mptcp_data_unlock(parent);

	if (!ret) {
err_prohibited:
		subflow->reset_reason = MPTCP_RST_EPROHIBIT;
		return false;
	}

	subflow->map_seq = READ_ONCE(msk->ack_seq);
	WRITE_ONCE(msk->allow_infinite_fallback, false);

out:
	mptcp_event(MPTCP_EVENT_SUB_ESTABLISHED, msk, ssk, GFP_ATOMIC);
	return true;
}
