  void check_multi_info(drachtio::RequestHandler::GlobalInfo *g) {
    char *eff_url;
    CURLMsg *msg;
    int msgs_left;
    RequestHandler::ConnInfo *conn;
    CURL *easy;
    CURLcode res;

    while((msg = curl_multi_info_read(g->multi, &msgs_left))) {
      if(msg->msg == CURLMSG_DONE) {
        long response_code;
        double namelookup=0, connect=0, total=0 ;
        char *ct = NULL ;
        easy = msg->easy_handle;
        res = msg->data.result;
        curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);
        curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &eff_url);
        curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &response_code);
        curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &ct);

        curl_easy_getinfo(easy, CURLINFO_NAMELOOKUP_TIME, &namelookup);
        curl_easy_getinfo(easy, CURLINFO_CONNECT_TIME, &connect);
        curl_easy_getinfo(easy, CURLINFO_TOTAL_TIME, &total);

        DR_LOG(log_info) << "http " << response_code << " response received from server in " << dec <<
          std::setprecision(3) << total << " secs: " << conn->response;

        //notify controller
        theOneAndOnlyController->httpCallRoutingComplete(conn->transactionId, response_code, conn->response) ;

        // return easy handle to cache
        {
          //alloc and free happen in the same thread
          //std::lock_guard<std::mutex> l( m_lock ) ;
          RequestHandler::m_cacheEasyHandles.push_back(easy) ;
          DR_LOG(log_debug) << "RequestHandler::makeRequestForRoute - after returning handle  in thread" << 
            std::this_thread::get_id() << " " << dec <<
            RequestHandler::m_cacheEasyHandles.size() << " handles are available in cache";
        }

        curl_multi_remove_handle(g->multi, easy);
        
        if( conn->hdr_list ) curl_slist_free_all(conn->hdr_list);

        memset(conn, 0, sizeof(RequestHandler::ConnInfo));
        RequestHandler::m_pool.destroy(conn) ;
        //free(conn);
      }
    }
  }
