max3421_handle_error(struct usb_hcd *hcd, u8 hrsl)
{
	struct spi_device *spi = to_spi_device(hcd->self.controller);
	struct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);
	u8 result_code = hrsl & MAX3421_HRSL_RESULT_MASK;
	struct urb *urb = max3421_hcd->curr_urb;
	struct max3421_ep *max3421_ep = urb->ep->hcpriv;
	int switch_sndfifo;

	/*
	 * If an OUT command results in any response other than OK
	 * (i.e., error or NAK), we have to perform a dummy-write to
	 * SNDBC so the FIFO gets switched back to us.  Otherwise, we
	 * get out of sync with the SNDFIFO double buffer.
	 */
	switch_sndfifo = (max3421_ep->pkt_state == PKT_STATE_TRANSFER &&
			  usb_urb_dir_out(urb));

	switch (result_code) {
	case MAX3421_HRSL_OK:
		return;			/* this shouldn't happen */

	case MAX3421_HRSL_WRONGPID:	/* received wrong PID */
	case MAX3421_HRSL_BUSY:		/* SIE busy */
	case MAX3421_HRSL_BADREQ:	/* bad val in HXFR */
	case MAX3421_HRSL_UNDEF:	/* reserved */
	case MAX3421_HRSL_KERR:		/* K-state instead of response */
	case MAX3421_HRSL_JERR:		/* J-state instead of response */
		/*
		 * packet experienced an error that we cannot recover
		 * from; report error
		 */
		max3421_hcd->urb_done = hrsl_to_error[result_code];
		dev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",
			__func__, hrsl);
		break;

	case MAX3421_HRSL_TOGERR:
		if (usb_urb_dir_in(urb))
			; /* don't do anything (device will switch toggle) */
		else {
			/* flip the send toggle bit: */
			int sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;

			sndtog ^= 1;
			spi_wr8(hcd, MAX3421_REG_HCTL,
				BIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));
		}
		fallthrough;
	case MAX3421_HRSL_BADBC:	/* bad byte count */
	case MAX3421_HRSL_PIDERR:	/* received PID is corrupted */
	case MAX3421_HRSL_PKTERR:	/* packet error (stuff, EOP) */
	case MAX3421_HRSL_CRCERR:	/* CRC error */
	case MAX3421_HRSL_BABBLE:	/* device talked too long */
	case MAX3421_HRSL_TIMEOUT:
		if (max3421_ep->retries++ < USB_MAX_RETRIES)
			/* retry the packet again in the next frame */
			max3421_slow_retransmit(hcd);
		else {
			/* Based on ohci.h cc_to_err[]: */
			max3421_hcd->urb_done = hrsl_to_error[result_code];
			dev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",
				__func__, hrsl);
		}
		break;

	case MAX3421_HRSL_STALL:
		dev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",
			__func__, hrsl);
		max3421_hcd->urb_done = hrsl_to_error[result_code];
		break;

	case MAX3421_HRSL_NAK:
		/*
		 * Device wasn't ready for data or has no data
		 * available: retry the packet again.
		 */
		if (max3421_ep->naks++ < NAK_MAX_FAST_RETRANSMITS) {
			max3421_next_transfer(hcd, 1);
			switch_sndfifo = 0;
		} else
			max3421_slow_retransmit(hcd);
		break;
	}
	if (switch_sndfifo)
		spi_wr8(hcd, MAX3421_REG_SNDBC, 0);
}
