GF_Err rfc_6381_get_codec_av1(char *szCodec, u32 subtype, GF_AV1Config *av1c, COLR colr)
{
#ifndef GPAC_DISABLE_AV_PARSERS
	GF_Err e;
	u32 i = 0;
	AV1State av1_state;
	assert(av1c);

	gf_av1_init_state(&av1_state);
	av1_state.config = av1c;

	for (i = 0; i < gf_list_count(av1c->obu_array); ++i) {
		GF_BitStream *bs;
		GF_AV1_OBUArrayEntry *a = gf_list_get(av1c->obu_array, i);
		bs = gf_bs_new(a->obu, a->obu_length, GF_BITSTREAM_READ);
		if (!av1_is_obu_header(a->obu_type))
			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[RFC6381] AV1: unexpected obu_type %d - Parsing anyway.\n", a->obu_type, gf_4cc_to_str(subtype)));

		e = aom_av1_parse_temporal_unit_from_section5(bs, &av1_state);
		gf_bs_del(bs);
		bs = NULL;
		if (e) {
			return e;
		}
	}

	snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "%s.%01u.%02u%c.%02u", gf_4cc_to_str(subtype),
		av1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M', av1_state.bit_depth);

	if (av1_state.color_description_present_flag) {
		char tmp[RFC6381_CODEC_NAME_SIZE_MAX];
		snprintf(tmp, RFC6381_CODEC_NAME_SIZE_MAX, ".%01u.%01u%01u%01u.%02u.%02u.%02u.%01u",
			av1_state.config->monochrome, av1_state.config->chroma_subsampling_x, av1_state.config->chroma_subsampling_y,
			av1_state.config->chroma_subsampling_x && av1_state.config->chroma_subsampling_y ? av1_state.config->chroma_sample_position : 0,
			colr.override == GF_TRUE ? colr.colour_primaries : av1_state.color_primaries,
			colr.override == GF_TRUE ? colr.transfer_characteristics : av1_state.transfer_characteristics,
			colr.override == GF_TRUE ? colr.matrix_coefficients : av1_state.matrix_coefficients,
			colr.override == GF_TRUE ? colr.full_range : av1_state.color_range);
		strcat(szCodec, tmp);
	} else {
		if ((av1_state.color_primaries == 2) && (av1_state.transfer_characteristics == 2) && (av1_state.matrix_coefficients == 2) && av1_state.color_range == GF_FALSE) {

		} else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[RFC6381] incoherent color characteristics primaries %d transfer %d matrix %d color range %d\n",
				av1_state.color_primaries, av1_state.transfer_characteristics, av1_state.matrix_coefficients, av1_state.color_range));
		}
	}
	gf_av1_reset_state(&av1_state, GF_TRUE);
	return GF_OK;
#else
	return GF_NOT_SUPPORTED;
#endif
}
