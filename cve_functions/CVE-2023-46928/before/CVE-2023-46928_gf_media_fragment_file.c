GF_Err gf_media_fragment_file(GF_ISOFile *input, const char *output_file, Double max_duration_sec, Bool use_mfra)
{
	char szArgs[1024];
	FragCallback fc;
	GF_Err e = GF_OK;
	GF_Filter *f;
	GF_FilterSession *fsess = gf_fs_new_defaults(0);

	if (!fsess) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("Failed to create filter session\n"));
		return GF_OUT_OF_MEM;
	}


	sprintf(szArgs, "mp4dmx:mov=%p", input);
	f = gf_fs_load_filter(fsess, szArgs, &e);
	if (!f) return e;

	strcpy(szArgs, "reframer:FID=1");
	f = gf_fs_load_filter(fsess, szArgs, &e);
	if (!f) return e;

	sprintf(szArgs, "%s:SID=1:frag:cdur=%g:abs_offset:fragdur", output_file, max_duration_sec);
	if (use_mfra)
		strcat(szArgs, ":mfra");

	f = gf_fs_load_destination(fsess, szArgs, NULL, NULL, &e);
	if (!f) return e;

	if (!gf_sys_is_test_mode()
#ifndef GPAC_DISABLE_LOG
		&& (gf_log_get_tool_level(GF_LOG_APP)!=GF_LOG_QUIET)
#endif
		&& !gf_sys_is_quiet()
	) {
		fc.last_prog=0;
		fc.fsess=fsess;
		fc.filter_idx_plus_one=0;
		gf_fs_enable_reporting(fsess, GF_TRUE);
		gf_fs_set_ui_callback(fsess, on_frag_event, &fc);
	}

#ifdef GPAC_ENABLE_COVERAGE
	if (gf_sys_is_cov_mode())
		on_frag_event(NULL, NULL);
#endif

	e = gf_fs_run(fsess);
	if (e==GF_EOS) e = GF_OK;
	if (!e) e = gf_fs_get_last_connect_error(fsess);
	if (!e) e = gf_fs_get_last_process_error(fsess);
	gf_fs_del(fsess);
	return e;
}
