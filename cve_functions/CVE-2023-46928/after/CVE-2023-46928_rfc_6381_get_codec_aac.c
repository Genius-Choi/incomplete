GF_Err rfc_6381_get_codec_aac(char *szCodec, u32 codec_id,  u8 *dsi, u32 dsi_size, Bool force_sbr)
{
	if (dsi && dsi_size) {
		u8 audio_object_type;
		if (dsi_size < 2) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[RFC6381] invalid DSI size %u < 2\n", dsi_size));
			return GF_NON_COMPLIANT_BITSTREAM;
		}
		/*5 first bits of AAC config*/
		audio_object_type = (dsi[0] & 0xF8) >> 3;
		if (audio_object_type == 31) { /*escape code*/
			const u8 audio_object_type_ext = ((dsi[0] & 0x07) << 3) + ((dsi[1] & 0xE0) >> 5);
			audio_object_type = 32 + audio_object_type_ext;
		}
#ifndef GPAC_DISABLE_AV_PARSERS
		if (force_sbr && (audio_object_type==2) ) {
			GF_M4ADecSpecInfo a_cfg;
			GF_Err e = gf_m4a_get_config(dsi, dsi_size, &a_cfg);
			if (e==GF_OK) {
				if (a_cfg.sbr_sr)
					audio_object_type = a_cfg.sbr_object_type;
				if (a_cfg.has_ps)
					audio_object_type = 29;
			}
		}
#endif
		snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "mp4a.%02X.%01d", gf_codecid_oti(codec_id), audio_object_type);
		return GF_OK;
	}

	snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "mp4a.%02X", codec_id);

	switch (codec_id) {
	case GF_CODECID_AAC_MPEG4:
	case GF_CODECID_AAC_MPEG2_MP:
	case GF_CODECID_AAC_MPEG2_LCP:
	case GF_CODECID_AAC_MPEG2_SSRP:
	case GF_CODECID_USAC:
		GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[RFC6381] Cannot find AAC config, using default %s\n", szCodec));
		break;
	}
	return GF_OK;
}
