GF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, u32 stsd_idx, char *szCodec, Bool force_inband, Bool force_sbr)
{
	GF_ESD *esd;
	GF_Err e;
	GF_AVCConfig *avcc;
	GF_HEVCConfig *hvcc;
	u32 subtype = gf_isom_get_media_subtype(movie, track, stsd_idx);

	if (subtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {
		u32 originalFormat=0;
		if (gf_isom_is_ismacryp_media(movie, track, stsd_idx)) {
			e = gf_isom_get_ismacryp_info(movie, track, stsd_idx, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		} else if (gf_isom_is_omadrm_media(movie, track, stsd_idx)) {
			e = gf_isom_get_omadrm_info(movie, track, stsd_idx, &originalFormat, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		} else if(gf_isom_is_cenc_media(movie, track, stsd_idx)) {
			e = gf_isom_get_cenc_info(movie, track, stsd_idx, &originalFormat, NULL, NULL);
		} else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[RFC6381] Unknown protection scheme type %s\n", gf_4cc_to_str( gf_isom_is_media_encrypted(movie, track, stsd_idx)) ));
			e = gf_isom_get_original_format_type(movie, track, stsd_idx, &originalFormat);
		}
		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] Error fetching protection information\n"));
			return e;
		}

		if (originalFormat) subtype = originalFormat;
	}
	else if (subtype==GF_ISOM_SUBTYPE_MPEG4) {
		u32 stsd_type = gf_isom_get_mpeg4_subtype(movie, track, stsd_idx);
		if (stsd_type==GF_ISOM_SUBTYPE_RESV)
			gf_isom_get_original_format_type(movie, track, stsd_idx, &subtype);
	}

	switch (subtype) {
	case GF_ISOM_SUBTYPE_MPEG4:
		esd = gf_isom_get_esd(movie, track, stsd_idx);
		if (esd && esd->decoderConfig) {
			switch (esd->decoderConfig->streamType) {
			case GF_STREAM_AUDIO:
				if (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
					e = rfc_6381_get_codec_aac(szCodec, esd->decoderConfig->objectTypeIndication, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, force_sbr);
				} else {
					e = rfc_6381_get_codec_aac(szCodec, esd->decoderConfig->objectTypeIndication, NULL, 0, force_sbr);
				}
				break;
			case GF_STREAM_VISUAL:
				if (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
					e = rfc_6381_get_codec_m4v(szCodec, esd->decoderConfig->objectTypeIndication, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
				} else {
					e = rfc_6381_get_codec_m4v(szCodec, esd->decoderConfig->objectTypeIndication, NULL, 0);
				}
				break;
			default:
				snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "mp4s.%02X", esd->decoderConfig->objectTypeIndication);
				e = GF_OK;
				break;
			}
			gf_odf_desc_del((GF_Descriptor *)esd);
			return e;
		}
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] Cannot find ESD. Aborting.\n"));
		if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
		return GF_ISOM_INVALID_FILE;

	case GF_ISOM_SUBTYPE_AVC_H264:
	case GF_ISOM_SUBTYPE_AVC2_H264:
	case GF_ISOM_SUBTYPE_AVC3_H264:
	case GF_ISOM_SUBTYPE_AVC4_H264:
		avcc = gf_isom_avc_config_get(movie, track, stsd_idx);
		if (force_inband) {
			if (subtype==GF_ISOM_SUBTYPE_AVC_H264)
				subtype = GF_ISOM_SUBTYPE_AVC3_H264;
			else if (subtype==GF_ISOM_SUBTYPE_AVC2_H264)
				subtype = GF_ISOM_SUBTYPE_AVC4_H264;
		}
		if (avcc) {
			e = rfc_6381_get_codec_avc(szCodec, subtype, avcc);
			gf_odf_avc_cfg_del(avcc);
			return e;
		}
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] Cannot find AVC configuration box"));
		return GF_ISOM_INVALID_FILE;

	case GF_ISOM_SUBTYPE_SVC_H264:
	case GF_ISOM_SUBTYPE_MVC_H264:
		avcc = gf_isom_mvc_config_get(movie, track, stsd_idx);
		if (!avcc) avcc = gf_isom_svc_config_get(movie, track, stsd_idx);
		if (avcc) {
			e = rfc_6381_get_codec_avc(szCodec, subtype, avcc);
			gf_odf_avc_cfg_del(avcc);
			return e;
		}
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] Cannot find SVC/MVC configuration box\n"));
		return GF_ISOM_INVALID_FILE;

	case GF_ISOM_SUBTYPE_HVC1:
	case GF_ISOM_SUBTYPE_HEV1:
	case GF_ISOM_SUBTYPE_HVC2:
	case GF_ISOM_SUBTYPE_HEV2:
	case GF_ISOM_SUBTYPE_HVT1:
	case GF_ISOM_SUBTYPE_LHV1:
	case GF_ISOM_SUBTYPE_LHE1:

		if (force_inband) {
			if (subtype==GF_ISOM_SUBTYPE_HVC1) subtype = GF_ISOM_SUBTYPE_HEV1;
			else if (subtype==GF_ISOM_SUBTYPE_HVC2) subtype = GF_ISOM_SUBTYPE_HEV2;
		}
		hvcc = gf_isom_hevc_config_get(movie, track, stsd_idx);
		if (!hvcc) {
			hvcc = gf_isom_lhvc_config_get(movie, track, stsd_idx);
		}
		if (subtype==GF_ISOM_SUBTYPE_HVT1) {
			u32 refTrack;
			gf_isom_get_reference(movie, track, GF_ISOM_REF_TBAS, stsd_idx, &refTrack);
			if (hvcc) gf_odf_hevc_cfg_del(hvcc);
			hvcc = gf_isom_hevc_config_get(movie, refTrack, 1);
		}
		if (hvcc) {
			e = rfc_6381_get_codec_hevc(szCodec, subtype, hvcc);
			gf_odf_hevc_cfg_del(hvcc);
			return e;
		}
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] HEVCConfig not compliant\n"));
		return GF_ISOM_INVALID_FILE;

	case GF_ISOM_SUBTYPE_AV01:
	{
		GF_AV1Config *av1c = gf_isom_av1_config_get(movie, track, stsd_idx);
		if (av1c) {
			u32 colour_type;
			COLR colr;
			memset(&colr, 0, sizeof(colr));
			if (GF_OK == gf_isom_get_color_info(movie, track, stsd_idx, &colour_type, &colr.colour_primaries, &colr.transfer_characteristics, &colr.matrix_coefficients, &colr.full_range)) {
				colr.override = GF_TRUE;
			}
			e = rfc_6381_get_codec_av1(szCodec, subtype, av1c, colr);
			gf_odf_av1_cfg_del(av1c);
			return e;
		}
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[RFC6381] No config found for AV1 file (\"%s\") when computing RFC6381.\n", gf_4cc_to_str(subtype)));
		return GF_BAD_PARAM;
	}

	case GF_ISOM_SUBTYPE_VP08:
	case GF_ISOM_SUBTYPE_VP09:
	{
		GF_VPConfig *vpcc = gf_isom_vp_config_get(movie, track, stsd_idx);
		if (vpcc) {
			u32 colour_type;
			COLR colr;
			memset(&colr, 0, sizeof(colr));
			if (GF_OK == gf_isom_get_color_info(movie, track, stsd_idx, &colour_type, &colr.colour_primaries, &colr.transfer_characteristics, &colr.matrix_coefficients, &colr.full_range)) {
				colr.override = GF_TRUE;
			}
			e = rfc_6381_get_codec_vpx(szCodec, subtype, vpcc, colr);
			gf_odf_vp_cfg_del(vpcc);
			return e;
		}
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[RFC6381] No config found for VP file (\"%s\") when computing RFC6381.\n", gf_4cc_to_str(subtype)));
		return GF_BAD_PARAM;
	}

	case GF_ISOM_SUBTYPE_DVHE:
	case GF_ISOM_SUBTYPE_DVH1:
	case GF_ISOM_SUBTYPE_DVA1:
	case GF_ISOM_SUBTYPE_DVAV:
	case GF_ISOM_SUBTYPE_DAV1:
	{
		GF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(movie, track, stsd_idx);
		if (!dovi) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] No config found for Dolby Vision file (\"%s\") when computing RFC6381.\n", gf_4cc_to_str(subtype)));
			return GF_NON_COMPLIANT_BITSTREAM;
		}

		e = rfc_6381_get_codec_dolby_vision(szCodec, subtype, dovi);
		gf_odf_dovi_cfg_del(dovi);
		return e;
	}

	case GF_ISOM_SUBTYPE_VVC1:
	case GF_ISOM_SUBTYPE_VVI1:
	{
		GF_VVCConfig *vvcc = gf_isom_vvc_config_get(movie, track, stsd_idx);
		if (vvcc) {
			if (force_inband) subtype = GF_ISOM_SUBTYPE_VVI1;

			e = rfc_6381_get_codec_vvc(szCodec, subtype, vvcc);
			gf_odf_vvc_cfg_del(vvcc);
			return e;
		}
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[RFC6381] No config found for VVC file (\"%s\") when computing RFC6381.\n", gf_4cc_to_str(subtype)));
		return GF_BAD_PARAM;
	}

	case GF_ISOM_SUBTYPE_MH3D_MHA1:
	case GF_ISOM_SUBTYPE_MH3D_MHA2:
	case GF_ISOM_SUBTYPE_MH3D_MHM1:
	case GF_ISOM_SUBTYPE_MH3D_MHM2:
	{
		esd = gf_media_map_esd(movie, track, stsd_idx);
		if (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo
			|| !esd->decoderConfig->decoderSpecificInfo->data
		) {
			e = rfc_6381_get_codec_mpegha(szCodec, subtype, NULL, 0, -1);
		} else {
			e = rfc_6381_get_codec_mpegha(szCodec, subtype, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, -1);
		}
		if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
		return e;
	}

	case GF_ISOM_SUBTYPE_UNCV:
	{
		GF_GenericSampleDescription *udesc = gf_isom_get_generic_sample_description(movie, track, stsd_idx);

		e = rfc_6381_get_codec_uncv(szCodec, subtype, udesc ? udesc->extension_buf : NULL, udesc ? udesc->extension_buf_size : 0);
		if (udesc) {
			if (udesc->extension_buf) gf_free(udesc->extension_buf);
			gf_free(udesc);
		}
		return e;
	}
    case GF_ISOM_SUBTYPE_STPP:
    {
        const char *xmlnamespace;
        const char *xml_schema_loc;
        const char *mimes;
        e = gf_isom_xml_subtitle_get_description(movie, track, stsd_idx,
                                             &xmlnamespace, &xml_schema_loc, &mimes);
        if (e == GF_OK) {
            rfc_6381_get_codec_stpp(szCodec, subtype, xmlnamespace, xml_schema_loc, mimes);
        }
        return e;
    }
	default:
		return rfc6381_codec_name_default(szCodec, subtype, gf_codec_id_from_isobmf(subtype));

	}
	return GF_OK;
}
