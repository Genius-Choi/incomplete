static unsigned char * r_jws_sign_eddsa(jws_t * jws, jwk_t * jwk) {
#if GNUTLS_VERSION_NUMBER >= 0x030600
  gnutls_privkey_t privkey = r_jwk_export_to_gnutls_privkey(jwk);
  gnutls_datum_t body_dat, sig_dat;
  unsigned char * to_return = NULL;
  int res;
  struct _o_datum dat_sig = {0, NULL};

  if (privkey != NULL && GNUTLS_PK_EDDSA_ED25519 == gnutls_privkey_get_pk_algorithm(privkey, NULL)) {
    body_dat.data = (unsigned char *)msprintf("%s.%s", jws->header_b64url, jws->payload_b64url);
    body_dat.size = (unsigned int)o_strlen((const char *)body_dat.data);

    if (!(res = gnutls_privkey_sign_data(privkey, GNUTLS_DIG_SHA512, 0, &body_dat, &sig_dat))) {
      if (o_base64url_encode_alloc(sig_dat.data, sig_dat.size, &dat_sig)) {
        to_return = (unsigned char*)o_strndup((const char *)dat_sig.data, dat_sig.size);
        o_free(dat_sig.data);
      } else {
        y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_eddsa - Error o_base64url_encode_alloc for dat_sig");
      }
      gnutls_free(sig_dat.data);
    } else {
      y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_eddsa - Error gnutls_privkey_sign_data: %d", res);
    }
    o_free(body_dat.data);
  } else {
    y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_eddsa - Error extracting privkey");
  }
  gnutls_privkey_deinit(privkey);
  return to_return;
#else
  (void)(jws);
  (void)(jwk);
  return NULL;
#endif
}
