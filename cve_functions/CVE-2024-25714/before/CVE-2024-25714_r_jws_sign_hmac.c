static unsigned char * r_jws_sign_hmac(jws_t * jws, jwk_t * jwk) {
  int alg = GNUTLS_DIG_NULL;
  unsigned char * data = NULL, * key = NULL, * sig = NULL, * to_return = NULL;
  size_t key_len = 0, sig_len = 0;
  struct _o_datum dat_sig = {0, NULL};

  if (jws->alg == R_JWA_ALG_HS256) {
    alg = GNUTLS_DIG_SHA256;
  } else if (jws->alg == R_JWA_ALG_HS384) {
    alg = GNUTLS_DIG_SHA384;
  } else if (jws->alg == R_JWA_ALG_HS512) {
    alg = GNUTLS_DIG_SHA512;
  }

  if (alg != GNUTLS_DIG_NULL) {
    sig_len = (unsigned)gnutls_hmac_get_len((gnutls_mac_algorithm_t)alg);
    sig = o_malloc(sig_len);

    key_len = o_strlen(r_jwk_get_property_str(jwk, "k"));
    if (key_len) {
      key = o_malloc(key_len);

      if (key != NULL) {
        if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) {
          y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_hmac - Error r_jwk_export_to_symmetric_key");
          o_free(key);
          key = NULL;
        }
      } else {
        y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_hmac - Error allocating resources for key");
      }
    } else {
      y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_hmac - Error key invalid, 'k' empty");
    }
  } else {
    y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_hmac - Error key invalid, 'alg' invalid");
  }

  if (key != NULL && sig != NULL) {
    data = (unsigned char *)msprintf("%s.%s", jws->header_b64url, jws->payload_b64url);
    if (!gnutls_hmac_fast((gnutls_mac_algorithm_t)alg, key, key_len, data, o_strlen((const char *)data), sig)) {
      if (o_base64url_encode_alloc(sig, sig_len, &dat_sig)) {
        to_return = (unsigned char*)o_strndup((const char *)dat_sig.data, dat_sig.size);
        o_free(dat_sig.data);
      } else {
        y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_hmac - Error o_base64url_encode sig_b64");
      }
    } else {
      y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_sign_hmac - Error gnutls_hmac_fast");
    }
  }

  o_free(data);
  o_free(sig);
  o_free(key);

  return to_return;
}
