void bpf_prog_pack_free(struct bpf_binary_header *hdr)
{
	struct bpf_prog_pack *pack = NULL, *tmp;
	unsigned int nbits;
	unsigned long pos;

	mutex_lock(&pack_mutex);
	if (hdr->size > BPF_PROG_PACK_SIZE) {
		module_memfree(hdr);
		goto out;
	}

	list_for_each_entry(tmp, &pack_list, list) {
		if ((void *)hdr >= tmp->ptr && (tmp->ptr + BPF_PROG_PACK_SIZE) > (void *)hdr) {
			pack = tmp;
			break;
		}
	}

	if (WARN_ONCE(!pack, "bpf_prog_pack bug\n"))
		goto out;

	nbits = BPF_PROG_SIZE_TO_NBITS(hdr->size);
	pos = ((unsigned long)hdr - (unsigned long)pack->ptr) >> BPF_PROG_CHUNK_SHIFT;

	WARN_ONCE(bpf_arch_text_invalidate(hdr, hdr->size),
		  "bpf_prog_pack bug: missing bpf_arch_text_invalidate?\n");

	bitmap_clear(pack->bitmap, pos, nbits);
	if (bitmap_find_next_zero_area(pack->bitmap, BPF_PROG_CHUNK_COUNT, 0,
				       BPF_PROG_CHUNK_COUNT, 0) == 0) {
		list_del(&pack->list);
		module_memfree(pack->ptr);
		kfree(pack);
	}
out:
	mutex_unlock(&pack_mutex);
}
