bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
			  unsigned int alignment,
			  struct bpf_binary_header **rw_header,
			  u8 **rw_image,
			  bpf_jit_fill_hole_t bpf_fill_ill_insns)
{
	struct bpf_binary_header *ro_header;
	u32 size, hole, start;

	WARN_ON_ONCE(!is_power_of_2(alignment) ||
		     alignment > BPF_IMAGE_ALIGNMENT);

	/* add 16 bytes for a random section of illegal instructions */
	size = round_up(proglen + sizeof(*ro_header) + 16, BPF_PROG_CHUNK_SIZE);

	if (bpf_jit_charge_modmem(size))
		return NULL;
	ro_header = bpf_prog_pack_alloc(size, bpf_fill_ill_insns);
	if (!ro_header) {
		bpf_jit_uncharge_modmem(size);
		return NULL;
	}

	*rw_header = kvmalloc(size, GFP_KERNEL);
	if (!*rw_header) {
		bpf_arch_text_copy(&ro_header->size, &size, sizeof(size));
		bpf_prog_pack_free(ro_header);
		bpf_jit_uncharge_modmem(size);
		return NULL;
	}

	/* Fill space with illegal/arch-dep instructions. */
	bpf_fill_ill_insns(*rw_header, size);
	(*rw_header)->size = size;

	hole = min_t(unsigned int, size - (proglen + sizeof(*ro_header)),
		     BPF_PROG_CHUNK_SIZE - sizeof(*ro_header));
	start = get_random_u32_below(hole) & ~(alignment - 1);

	*image_ptr = &ro_header->image[start];
	*rw_image = &(*rw_header)->image[start];

	return ro_header;
}
