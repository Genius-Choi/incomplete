lys_data_path(const struct lys_node *node)
{
    char *result = NULL, buf[1024];
    const char *separator, *name;
    int i, used;
    struct ly_set *set;
    const struct lys_module *prev_mod;

    if (!node) {
        LOGARG;
        return NULL;
    }

    buf[0] = '\0';
    set = ly_set_new();
    LY_CHECK_ERR_GOTO(!set, LOGMEM(node->module->ctx), cleanup);

    while (node) {
        ly_set_add(set, (void *)node, 0);
        do {
            node = lys_parent(node);
        } while (node && (node->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));
    }

    prev_mod = NULL;
    used = 0;
    for (i = set->number - 1; i > -1; --i) {
        node = set->set.s[i];
        if (node->nodetype == LYS_EXT) {
            if (strcmp(((struct lys_ext_instance *)node)->def->name, "yang-data")) {
                continue;
            }
            name = ((struct lys_ext_instance *)node)->arg_value;
            separator = ":#";
        } else {
            name = node->name;
            separator = ":";
        }
        used += sprintf(buf + used, "/%s%s%s", (lys_node_module(node) == prev_mod ? "" : lys_node_module(node)->name),
                        (lys_node_module(node) == prev_mod ? "" : separator), name);
        prev_mod = lys_node_module(node);
    }

    result = strdup(buf);
    LY_CHECK_ERR_GOTO(!result, LOGMEM(node->module->ctx), cleanup);

cleanup:
    ly_set_free(set);
    return result;
}
