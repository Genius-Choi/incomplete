lys_sub_module_remove_devs_augs(struct lys_module *module)
{
    uint8_t u, v, w;
    struct unres_schema *unres;

    unres = calloc(1, sizeof *unres);
    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );

    /* remove applied deviations */
    for (u = 0; u < module->deviation_size; ++u) {
        /* the deviation could not be applied because it failed to be applied in the first place*/
        if (module->deviation[u].orig_node) {
            remove_dev(&module->deviation[u], module, unres);
        }

        /* Free the deviation's must array(s). These are shallow copies of the arrays
           on the target node(s), so a deep free is not needed. */
        for (v = 0; v < module->deviation[u].deviate_size; ++v) {
            if (module->deviation[u].deviate[v].mod == LY_DEVIATE_ADD) {
                free(module->deviation[u].deviate[v].must);
            }
        }
    }
    /* remove applied augments */
    for (u = 0; u < module->augment_size; ++u) {
        remove_aug(&module->augment[u]);
    }

    /* remove deviation and augments defined in submodules */
    for (v = 0; v < module->inc_size && module->inc[v].submodule; ++v) {
        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {
            if (module->inc[v].submodule->deviation[u].orig_node) {
                remove_dev(&module->inc[v].submodule->deviation[u], module, unres);
            }

            /* Free the deviation's must array(s). These are shallow copies of the arrays
               on the target node(s), so a deep free is not needed. */
            for (w = 0; w < module->inc[v].submodule->deviation[u].deviate_size; ++w) {
                if (module->inc[v].submodule->deviation[u].deviate[w].mod == LY_DEVIATE_ADD) {
                    free(module->inc[v].submodule->deviation[u].deviate[w].must);
                }
            }
        }

        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {
            remove_aug(&module->inc[v].submodule->augment[u]);
        }
    }

    if (unres->count) {
        resolve_unres_schema(module, unres);
    }
    /* nothing else left to do even if something is not resolved */
    unres_schema_free(module, &unres, 1);
}
