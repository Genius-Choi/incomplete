remove_dev(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)
{
    uint32_t idx = 0, j;
    const struct lys_module *mod;
    struct lys_module *target_mod, *target_submod;
    const char *ptr;

    if (dev->orig_node) {
        target_mod = lys_node_module(dev->orig_node);
        target_submod = dev->orig_node->module;
    } else {
        LOGINT(module->ctx);
        return;
    }
    lys_switch_deviation(dev, module, unres);

    /* clear the deviation flag if possible */
    while ((mod = ly_ctx_get_module_iter(module->ctx, &idx))) {
        if ((mod == module) || (mod == target_mod)) {
            continue;
        }

        for (j = 0; j < mod->deviation_size; ++j) {
            ptr = strstr(mod->deviation[j].target_name, target_mod->name);
            if (ptr && (ptr[strlen(target_mod->name)] == ':')) {
                /* some other module deviation targets the inspected module, flag remains */
                break;
            }
        }

        if (j < mod->deviation_size) {
            break;
        }
    }

    if (!mod) {
        target_mod->deviated = 0;    /* main module */
        target_submod->deviated = 0; /* possible submodule */
    }
}
