lys_leaf_add_leafref_target(struct lys_node_leaf *leafref_target, struct lys_node *leafref)
{
    struct lys_node_leaf *iter;
    struct ly_ctx *ctx = leafref_target->module->ctx;

    if (!(leafref_target->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {
        LOGINT(ctx);
        return -1;
    }

    /* check for config flag */
    if (((struct lys_node_leaf*)leafref)->type.info.lref.req != -1 &&
            (leafref->flags & LYS_CONFIG_W) && (leafref_target->flags & LYS_CONFIG_R)) {
        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, leafref,
               "The leafref %s is config but refers to a non-config %s.",
               strnodetype(leafref->nodetype), strnodetype(leafref_target->nodetype));
        return -1;
    }
    /* check for cycles */
    for (iter = leafref_target; iter && iter->type.base == LY_TYPE_LEAFREF; iter = iter->type.info.lref.target) {
        if ((void *)iter == (void *)leafref) {
            /* cycle detected */
            LOGVAL(ctx, LYE_CIRC_LEAFREFS, LY_VLOG_LYS, leafref);
            return -1;
        }
    }

    /* create fake child - the ly_set structure to hold the list of
     * leafrefs referencing the leaf(-list) */
    if (!leafref_target->backlinks) {
        leafref_target->backlinks = (void *)ly_set_new();
        if (!leafref_target->backlinks) {
            LOGMEM(ctx);
            return -1;
        }
    }
    ly_set_add(leafref_target->backlinks, leafref, 0);

    return 0;
}
