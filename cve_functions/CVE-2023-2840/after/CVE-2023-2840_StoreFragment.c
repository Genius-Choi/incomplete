static GF_Err StoreFragment(GF_ISOFile *movie, Bool load_mdat_only, s32 data_offset_diff, u32 *moof_size, Bool reassign_bs)
{
	GF_Err e;
	u64 moof_start, pos, trun_ref_size=0;
	u32 size, i, s_count, mdat_size;
	s32 offset;
	u8 *buffer;
	GF_TrackFragmentBox *traf;
	GF_TrackFragmentRunBox *trun;
	GF_BitStream *bs, *bs_orig;
	if (!movie->moof) return GF_OK;

	bs = movie->editFileMap->bs;
	if (!movie->moof_first) {
		load_mdat_only = GF_FALSE;
		movie->force_moof_base_offset = GF_FALSE;
	}

	mdat_size = 0;
	//1 - flush all caches
	i=0;
	while ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {
		u32 j, nb_written, last_gid, cur_sample_idx;
		/*do not write empty senc*/
		if (traf->sample_encryption && !gf_list_count(traf->sample_encryption->samp_aux_info)) {
			gf_list_del_item(traf->child_boxes, traf->sample_encryption);
			gf_isom_box_del((GF_Box *) traf->sample_encryption);
			traf->sample_encryption = NULL;
			/*remove saiz and saio (todo, check if other saiz/saio types are used*/
			for (j=0; j<gf_list_count(traf->sai_sizes); j++) {
				GF_SampleAuxiliaryInfoSizeBox *saiz = gf_list_get(traf->sai_sizes, j);
				switch (saiz->aux_info_type) {
				case GF_ISOM_CENC_SCHEME:
				case GF_ISOM_CBC_SCHEME:
				case GF_ISOM_CENS_SCHEME:
				case GF_ISOM_CBCS_SCHEME:
				case 0:
					gf_list_rem(traf->sai_sizes, j);
					gf_list_del_item(traf->child_boxes, saiz);
					gf_isom_box_del((GF_Box *)saiz);
					j--;
					break;
				}
			}
			for (j=0; j<gf_list_count(traf->sai_offsets); j++) {
				GF_SampleAuxiliaryInfoOffsetBox *saio = gf_list_get(traf->sai_offsets, j);
				switch (saio->aux_info_type) {
				case GF_ISOM_CENC_SCHEME:
				case GF_ISOM_CBC_SCHEME:
				case GF_ISOM_CENS_SCHEME:
				case GF_ISOM_CBCS_SCHEME:
				case 0:
					gf_list_rem(traf->sai_offsets, j);
					gf_list_del_item(traf->child_boxes, saio);
					gf_isom_box_del((GF_Box *)saio);
					j--;
					break;
				}
			}
		}
		trun_ref_size += traf->trun_ref_size;
		if (!traf->DataCache) continue;

		s_count = gf_list_count(traf->TrackRuns);
		if (!s_count) continue;

		//store all cached truns - there may be more than one when using sample interleaving in truns
		nb_written = 0;
		last_gid = 0;
		cur_sample_idx = 0;
		while (nb_written<s_count) {
			u32 min_next_gid = 0xFFFFFFFF;

			for (j=0; j<s_count; j++) {
				trun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, j);
				//done
				if (!trun->cache || !trun->sample_count) continue;

				if (!traf->use_sample_interleave || (last_gid!=trun->interleave_id)) {
					if (trun->interleave_id < min_next_gid)
						min_next_gid = trun->interleave_id;
					continue;
				}

				//update offset
				trun->data_offset = (u32) (gf_bs_get_position(bs) - movie->moof->fragment_offset - 8);
				//write cache
				gf_bs_get_content(trun->cache, &buffer, &size);
				gf_bs_write_data(bs, buffer, size);
				gf_bs_del(trun->cache);
				gf_free(buffer);
				trun->cache = NULL;
				trun->first_sample_idx = cur_sample_idx;
				cur_sample_idx += trun->sample_count;

				nb_written++;
			}
			last_gid = min_next_gid;
		}

		traf->DataCache=0;
	}

	if (load_mdat_only) {
		pos = trun_ref_size ? (trun_ref_size+8) : gf_bs_get_position(bs);
		if (movie->moof->fragment_offset > pos)
			return GF_CORRUPTED_DATA;

		//we assume we never write large MDATs in fragment mode which should always be true
		movie->moof->mdat_size = (u32) (pos - movie->moof->fragment_offset);

		if (trun_ref_size) {
			gf_bs_seek(movie->editFileMap->bs, 0);
			return GF_OK;
		}
		if (movie->segment_bs) {
			e = gf_bs_seek(bs, 0);
			if (e) return e;
			/*write mdat size*/
			gf_bs_write_u32(bs, (u32) movie->moof->mdat_size);
			/*and get internal buffer*/
			e = gf_bs_seek(bs, movie->moof->mdat_size);
			if (e) return e;
			gf_bs_get_content(bs, &movie->moof->mdat, &movie->moof->mdat_size);

			gf_bs_del(bs);
			movie->editFileMap->bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
		} else {
			u64 frag_offset = movie->segment_start;
			e = gf_bs_seek(bs, frag_offset);
			if (e) return e;
			/*write mdat size*/
			gf_bs_write_u32(bs, (u32) movie->moof->mdat_size);

			movie->moof->mdat = (char*)gf_malloc(sizeof(char) * movie->moof->mdat_size);
			if (!movie->moof->mdat) return GF_OUT_OF_MEM;

			e = gf_bs_seek(bs, frag_offset);
			if (e) return e;
			gf_bs_read_data(bs, movie->moof->mdat, movie->moof->mdat_size);

			e = gf_bs_seek(bs, frag_offset);
			if (e) return e;
			gf_bs_truncate(bs);
		}

		return GF_OK;
	}

	moof_start = gf_bs_get_position(bs);

	if (movie->moof->ntp) {
		moof_start += 8*4;
	}

	//2- update MOOF MDAT header
	if (!movie->moof->mdat && !trun_ref_size) {
		e = gf_bs_seek(bs, movie->moof->fragment_offset);
		if (e) return e;
		//we assume we never write large MDATs in fragment mode which should always be true
		mdat_size = (u32) (moof_start - movie->moof->fragment_offset);
		gf_bs_write_u32(bs, (u32) mdat_size);
		gf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);
		e = gf_bs_seek(bs, moof_start);
		if (e) return e;
	}

	/*estimate moof size and shift trun offsets*/
#ifndef USE_BASE_DATA_OFFSET
	offset = 0;
	if (movie->use_segments || movie->force_moof_base_offset) {
		e = gf_isom_box_size((GF_Box *) movie->moof);
		if (e) return e;
		offset = (s32) movie->moof->size;
		/*mdat size & type*/
		offset += 8;
		update_trun_offsets(movie, offset);
	}
#endif

	//3- clean our traf's
	i=0;
	while ((traf = (GF_TrackFragmentBox*) gf_list_enum(movie->moof->TrackList, &i))) {
		//compute default settings for the TRAF
		ComputeFragmentDefaults(traf);
		//updates all trun and set all flags, INCLUDING TRAF FLAGS (durations, ...)
		s_count = UpdateRuns(movie, traf);
		//empty fragment destroy it
		if (!traf->tfhd->EmptyDuration && !s_count) {
			i--;
			gf_list_rem(movie->moof->TrackList, i);
			gf_isom_box_del_parent(&movie->moof->child_boxes, (GF_Box *) traf);
			continue;
		}
	}

	buffer = NULL;
	/*rewind bitstream and load mdat in memory */
	if (movie->moof_first && !movie->moof->mdat && !trun_ref_size) {
		buffer = (char*)gf_malloc(sizeof(char)*mdat_size);
		if (!buffer) return GF_OUT_OF_MEM;
		e = gf_bs_seek(bs, movie->moof->fragment_offset);
		if (e) return e;
		gf_bs_read_data(bs, buffer, mdat_size);
		/*back to mdat start and erase with moov*/
		e = gf_bs_seek(bs, movie->moof->fragment_offset);
		if (e) return e;
		gf_bs_truncate(bs);
	}

	//4- Write moof
	e = gf_isom_box_size((GF_Box *) movie->moof);
	if (e) return e;
	/*moof first, update traf headers - THIS WILL IMPACT THE MOOF SIZE IF WE
	DECIDE NOT TO USE THE DATA-OFFSET FLAG*/
	if (movie->moof_first
#ifndef USE_BASE_DATA_OFFSET
	        && !(movie->use_segments || movie->force_moof_base_offset)
#endif
	   ) {
		i=0;
		while ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {
			/*offset increases by moof size*/
			traf->tfhd->base_data_offset += movie->moof->size;
			traf->tfhd->base_data_offset += data_offset_diff;
			if (movie->on_block_out) {
				traf->tfhd->base_data_offset += movie->fragmented_file_pos;
			}
		}
	}
#ifndef USE_BASE_DATA_OFFSET
	else if (movie->use_segments || movie->force_moof_base_offset) {
		if (offset != (movie->moof->size+8)) {
			offset = (s32) (movie->moof->size + 8 - offset);
			update_trun_offsets(movie, offset);
			e = gf_isom_box_size((GF_Box *) movie->moof);
			if (e) return e;
		}
	}
#endif

	if (!movie->moof_first && !movie->force_moof_base_offset) {
		i=0;
		while ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {
			/*offset increases by moof size*/
			if (movie->on_block_out) {
				traf->tfhd->base_data_offset += movie->fragmented_file_pos;
			}
		}
	}

	bs_orig = bs;
	if (reassign_bs && movie->on_block_out) {
		bs = gf_bs_new_cbk(isom_on_block_out, movie, movie->on_block_out_block_size);
	}

	if (trun_ref_size && movie->in_sidx_write) {
		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
	}

	if (movie->moof->ntp) {
		gf_bs_write_u32(bs, 8*4);
		gf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_PRFT );
		gf_bs_write_u8(bs, 1);
		gf_bs_write_u24(bs, 0);
		gf_bs_write_u32(bs, movie->moof->reference_track_ID);
		gf_bs_write_u64(bs, movie->moof->ntp);
		gf_bs_write_u64(bs, movie->moof->timestamp);
	}
	if (movie->moof->emsgs) {
		while (1) {
			GF_Box *emsg = gf_list_pop_front(movie->moof->emsgs);
			if (!emsg) break;
			gf_isom_box_size(emsg);
			gf_isom_box_write(emsg, bs);
			gf_isom_box_del(emsg);
		}
		gf_list_del(movie->moof->emsgs);
		movie->moof->emsgs = NULL;
	}

	if (moof_size) *moof_size = (u32) movie->moof->size;

	pos = gf_bs_get_position(bs);
	//graw buffer to hold moof, speeds up writes
	gf_bs_grow(bs, (u32) movie->moof->size + (trun_ref_size ? 8 : 0));

	i=0;
	while ((traf = (GF_TrackFragmentBox*)gf_list_enum(movie->moof->TrackList, &i))) {
		traf->moof_start_in_bs = pos;
	}

	/*we don't want to dispatch any block until done writing the moof*/
	if (movie->on_block_out)
		gf_bs_prevent_dispatch(bs, GF_TRUE);

	if (movie->compress_mode>GF_ISOM_COMP_MOOV) {
		e = gf_isom_write_compressed_box(movie, (GF_Box *) movie->moof, GF_4CC('!', 'm', 'o', 'f'), bs, moof_size);
	} else {
		e = gf_isom_box_write((GF_Box *) movie->moof, bs);
	}

	if (trun_ref_size) {
		gf_bs_write_u32(bs, movie->moof->mdat_size);
		gf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);
	}

	if (movie->on_block_out)
		gf_bs_prevent_dispatch(bs, GF_FALSE);

	if (e) return e;

	if (trun_ref_size) {
		flush_ref_samples(movie, NULL, GF_FALSE);
	} else {
		if (movie->on_last_block_start && !gf_list_count(movie->moof_list))
			movie->on_last_block_start(movie->on_block_out_usr_data);

		//rewrite mdat after moof
		if (movie->moof->mdat) {
			gf_bs_write_data(bs, movie->moof->mdat, movie->moof->mdat_size);
			gf_free(movie->moof->mdat);
			movie->moof->mdat = NULL;
		} else if (buffer) {
			gf_bs_write_data(bs, buffer, mdat_size);
			gf_free(buffer);
		}
	}

	if (trun_ref_size && movie->in_sidx_write) {
		gf_bs_get_content(bs, &movie->moof->moof_data, &movie->moof->moof_data_len);
		gf_bs_del(bs);
		movie->fragmented_file_pos += movie->moof->moof_data_len + trun_ref_size;
		movie->moof->trun_ref_size = (u32) trun_ref_size;
	}
	else if (bs != bs_orig) {
		u64 frag_size = gf_bs_get_position(bs);
		gf_bs_del(bs);
		movie->fragmented_file_pos += frag_size + trun_ref_size;
		gf_bs_seek(bs_orig, 0);
		gf_bs_truncate(bs_orig);
	}
	else if (movie->on_block_out) {
		u64 frag_size = gf_bs_get_position(bs);
		movie->fragmented_file_pos += frag_size + trun_ref_size;
	}

	if (!movie->use_segments) {
		//remove from moof list (may happen in regular fragmentation when single traf per moof is used)
		gf_list_del_item(movie->moof_list, movie->moof);
		gf_isom_box_del((GF_Box *) movie->moof);
		movie->moof = NULL;
	}
	return GF_OK;
}
