static int on_version_message(struct nvnc_client* client)
{
	struct nvnc* server = client->server;

	if (client->buffer_len - client->buffer_index < 12)
		return 0;

	char version_string[13];
	memcpy(version_string, client->msg_buffer + client->buffer_index, 12);
	version_string[12] = '\0';

	if (strcmp(RFB_VERSION_MESSAGE, version_string) != 0)
		return handle_unsupported_version(client);

	uint8_t buf[sizeof(struct rfb_security_types_msg) +
		SECURITY_TYPES_MAX] = {};
	struct rfb_security_types_msg* security =
		(struct rfb_security_types_msg*)buf;

	security->n = 0;
	if (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {
		assert(server->auth_fn);

#ifdef ENABLE_TLS
		if (server->tls_creds) {
			security->types[security->n++] = RFB_SECURITY_TYPE_VENCRYPT;
		}
#endif

#ifdef HAVE_CRYPTO
		security->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES256;
		security->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES;

		if (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {
			security->types[security->n++] = RFB_SECURITY_TYPE_APPLE_DH;
		}
#endif
	} else {
		security->n = 1;
		security->types[0] = RFB_SECURITY_TYPE_NONE;
	}

	if (security->n == 0) {
		nvnc_log(NVNC_LOG_PANIC, "Failed to satisfy requested security constraints");
	}

	stream_write(client->net_stream, security, sizeof(*security) +
			security->n, NULL, NULL);

	client->state = VNC_CLIENT_STATE_WAITING_FOR_SECURITY;
	return 12;
}
