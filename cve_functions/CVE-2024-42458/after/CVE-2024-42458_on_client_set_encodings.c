static int on_client_set_encodings(struct nvnc_client* client)
{
	struct rfb_client_set_encodings_msg* msg =
	        (struct rfb_client_set_encodings_msg*)(client->msg_buffer +
	                                               client->buffer_index);

	size_t n_encodings = ntohs(msg->n_encodings);
	size_t n = 0;

	if (client->buffer_len - client->buffer_index <
	    sizeof(*msg) + n_encodings * 4)
		return 0;

	client->quality = 10;

	for (size_t i = 0; i < n_encodings && n < MAX_ENCODINGS; ++i) {
		enum rfb_encodings encoding = htonl(msg->encodings[i]);

		switch (encoding) {
		case RFB_ENCODING_RAW:
		case RFB_ENCODING_COPYRECT:
		case RFB_ENCODING_RRE:
		case RFB_ENCODING_HEXTILE:
		case RFB_ENCODING_TIGHT:
		case RFB_ENCODING_TRLE:
		case RFB_ENCODING_ZRLE:
		case RFB_ENCODING_OPEN_H264:
		case RFB_ENCODING_CURSOR:
		case RFB_ENCODING_DESKTOPSIZE:
		case RFB_ENCODING_EXTENDEDDESKTOPSIZE:
		case RFB_ENCODING_QEMU_EXT_KEY_EVENT:
#ifdef ENABLE_EXPERIMENTAL
		case RFB_ENCODING_PTS:
		case RFB_ENCODING_NTP:
#endif
			client->encodings[n++] = encoding;
#ifndef ENABLE_EXPERIMENTAL
		case RFB_ENCODING_PTS:
		case RFB_ENCODING_NTP:
			;
#endif
		}

		if (RFB_ENCODING_JPEG_LOWQ <= encoding &&
				encoding <= RFB_ENCODING_JPEG_HIGHQ)
			client->quality = encoding - RFB_ENCODING_JPEG_LOWQ;
	}

	char encoding_list[256] = {};
	encodings_to_string_list(encoding_list, sizeof(encoding_list),
			client->encodings, n);
	nvnc_log(NVNC_LOG_DEBUG, "Client %p set encodings: %s", client,
			encoding_list);

	client->n_encodings = n;
	client->formats_changed = true;

	return sizeof(*msg) + 4 * n_encodings;
}
