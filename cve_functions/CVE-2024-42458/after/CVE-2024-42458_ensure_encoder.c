static bool ensure_encoder(struct nvnc_client* client, const struct nvnc_fb *fb)
{
	struct nvnc* server = client->server;

	enum rfb_encodings encoding = choose_frame_encoding(client, fb);
	if (client->encoder && encoding == encoder_get_type(client->encoder))
		return true;

	int width = server->display->buffer->width;
	int height = server->display->buffer->height;
	if (client->encoder) {
		server->n_damage_clients -= !(client->encoder->impl->flags &
				ENCODER_IMPL_FLAG_IGNORES_DAMAGE);
		client->encoder->on_done = NULL;
	}
	encoder_unref(client->encoder);

	/* Zlib streams need to be saved so we keep encoders around that
	 * use them.
	 */
	switch (encoding) {
	case RFB_ENCODING_ZRLE:
		if (!client->zrle_encoder) {
			client->zrle_encoder =
				encoder_new(encoding, width, height);
		}
		client->encoder = client->zrle_encoder;
		encoder_ref(client->encoder);
		break;
	case RFB_ENCODING_TIGHT:
		if (!client->tight_encoder) {
			client->tight_encoder =
				encoder_new(encoding, width, height);
		}
		client->encoder = client->tight_encoder;
		encoder_ref(client->encoder);
		break;
	default:
		client->encoder = encoder_new(encoding, width, height);
		break;
	}

	if (!client->encoder) {
		nvnc_log(NVNC_LOG_ERROR, "Failed to allocate new encoder");
		return false;
	}

	server->n_damage_clients += !(client->encoder->impl->flags &
			ENCODER_IMPL_FLAG_IGNORES_DAMAGE);

	nvnc_log(NVNC_LOG_INFO, "Choosing %s encoding for client %p",
			encoding_to_string(encoding), client);

	return true;
}
