check_tgs_req(kdc_realm_t *realm, struct tgs_req_info *t,
              krb5_audit_state *au_state, krb5_flags *tktflags,
              krb5_ticket_times *times, const char **status,
              krb5_pa_data ***e_data)
{
    krb5_context context = realm->realm_context;
    krb5_error_code ret;
    krb5_timestamp kdc_time;

    au_state->stage = VALIDATE_POL;

    ret = krb5_timeofday(context, &kdc_time);
    if (ret)
        return ret;

    ret = check_tgs_constraints(realm, t->req, t->server, t->header_tkt,
                                t->header_pac, t->stkt, t->stkt_pac,
                                t->stkt_server, kdc_time, t->s4u2self,
                                t->client, t->is_crossrealm, t->is_referral,
                                status, e_data);
    if (ret) {
        au_state->violation = PROT_CONSTRAINT;
        return ret;
    }

    ret = check_tgs_policy(realm, t->req, t->server, t->header_tkt,
                           t->header_pac, t->stkt, t->stkt_pac,
                           t->stkt_pac_client, t->stkt_server, kdc_time,
                           t->is_crossrealm, t->is_referral, status, e_data);
    if (ret) {
        au_state->violation = LOCAL_POLICY;
        if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {
            au_state->status = *status;
            kau_s4u2proxy(context, FALSE, au_state);
        }
        return ret;
    }

    /* Check auth indicators from the subject ticket, except for S4U2Self
     * requests (where the client didn't authenticate). */
    if (t->s4u2self == NULL) {
        ret = check_indicators(context, t->server, t->auth_indicators);
        if (ret) {
            *status = "HIGHER_AUTHENTICATION_REQUIRED";
            return ret;
        }
    }

    *tktflags = get_ticket_flags(t->req->kdc_options, t->client, t->server,
                                 t->header_tkt->enc_part2);
    compute_ticket_times(realm, t, kdc_time, tktflags, times);

    /* For S4U2Self requests, check if we need to suppress the forwardable
     * ticket flag. */
    if (t->s4u2self != NULL && !t->is_referral) {
        ret = s4u2self_forwardable(context, t->server, tktflags);
        if (ret)
            return ret;
    }

    /* Consult kdcpolicy modules, giving them a chance to modify the times of
     * the issued ticket. */
    ret = check_kdcpolicy_tgs(context, t->req, t->server, t->header_tkt,
                              t->auth_indicators, kdc_time, times, status);
    if (ret)
        return ret;

    if (!(t->req->kdc_options & KDC_OPT_DISABLE_TRANSITED_CHECK)) {
        /* Check the transited path for the issued ticket and set the
         * transited-policy-checked flag if successful. */
        ret = kdc_check_transited_list(context, &t->transited.tr_contents,
                                       &t->subject_tkt->client->realm,
                                       &t->req->server->realm);
        if (ret) {
            /* Log the transited-check failure and continue. */
            log_tgs_badtrans(context, t->cprinc, t->sprinc,
                             &t->transited.tr_contents, ret);
        } else {
            *tktflags |= TKT_FLG_TRANSIT_POLICY_CHECKED;
        }
    } else {
        krb5_klog_syslog(LOG_INFO, _("not checking transit path"));
    }

    /* By default, reject the request if the transited path was not checked
     * successfully. */
    if (realm->realm_reject_bad_transit &&
        !(*tktflags & TKT_FLG_TRANSIT_POLICY_CHECKED)) {
        *status = "BAD_TRANSIT";
        au_state->violation = LOCAL_POLICY;
        return KRB5KDC_ERR_POLICY;
    }

    return 0;
}
