gather_tgs_req_info(kdc_realm_t *realm, krb5_kdc_req **reqptr, krb5_data *pkt,
                    const krb5_fulladdr *from,
                    struct kdc_request_state *fast_state,
                    krb5_audit_state *au_state, struct tgs_req_info *t,
                    const char **status)
{
    krb5_context context = realm->realm_context;
    krb5_error_code ret;
    krb5_pa_data *pa_tgs_req;
    unsigned int s_flags;
    krb5_enc_tkt_part *header_enc;
    krb5_data d;

    /* Transfer ownership of *reqptr to *t. */
    t->req = *reqptr;
    *reqptr = NULL;

    if (t->req->msg_type != KRB5_TGS_REQ)
        return KRB5_BADMSGTYPE;

    /* Initially set t->sprinc to the outer request server, for logging of
     * early failures. */
    t->sprinc = t->req->server;

    /* Read the PA-TGS-REQ authenticator and decrypt the header ticket. */
    ret = kdc_process_tgs_req(realm, t->req, from, pkt, &t->header_tkt,
                              &t->header_server, &t->header_key, &t->subkey,
                              &pa_tgs_req);
    if (t->header_tkt != NULL && t->header_tkt->enc_part2 != NULL)
        t->cprinc = t->header_tkt->enc_part2->client;
    if (ret) {
        *status = "PROCESS_TGS";
        return ret;
    }
    ret = kau_make_tkt_id(context, t->header_tkt, &au_state->tkt_in_id);
    if (ret)
        return ret;
    header_enc = t->header_tkt->enc_part2;

    /* If PA-FX-FAST-REQUEST padata is present, replace t->req with the inner
     * request body. */
    d = make_data(pa_tgs_req->contents, pa_tgs_req->length);
    ret = kdc_find_fast(&t->req, &d, t->subkey, header_enc->session,
                        fast_state, NULL);
    if (ret) {
        *status = "FIND_FAST";
        return ret;
    }
    /* Reset t->sprinc for the inner body and check it. */
    t->sprinc = t->req->server;
    if (t->sprinc == NULL) {
        *status = "NULL_SERVER";
        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
    }

    /* The header ticket server is usually a TGT, but if it is not, fetch the
     * local TGT for the realm.  Get the decrypted first local TGT key. */
    ret = get_local_tgt(context, &t->sprinc->realm, t->header_server,
                        &t->local_tgt, &t->local_tgt_storage,
                        &t->local_tgt_key);
    if (ret) {
        *status = "GET_LOCAL_TGT";
        return ret;
    }

    /* Decode and verify the header ticket PAC. */
    ret = get_verified_pac(context, header_enc, t->header_server,
                           t->header_key, t->local_tgt, &t->local_tgt_key,
                           &t->header_pac);
    if (ret) {
        *status = "HEADER_PAC";
        return ret;
    }

    au_state->request = t->req;
    au_state->stage = SRVC_PRINC;

    /* Look up the server principal entry, or a referral/alternate TGT.  Reset
     * t->sprinc to the canonical server name (its final value). */
    s_flags = (t->req->kdc_options & KDC_OPT_CANONICALIZE) ?
        KRB5_KDB_FLAG_REFERRAL_OK : 0;
    ret = search_sprinc(realm, t->req, s_flags, &t->server, status);
    if (ret)
        return ret;
    t->sprinc = t->server->princ;

    /* If we got a cross-realm TGS which is not the requested server, we are
     * issuing a referral (or alternate TGT, which we treat similarly). */
    if (is_cross_tgs_principal(t->server->princ) &&
        !krb5_principal_compare(context, t->req->server, t->server->princ))
        t->flags |= KRB5_KDB_FLAG_ISSUING_REFERRAL;

    /* Mark the request as cross-realm if the header ticket server is not from
     * this realm. */
    if (!data_eq(t->header_server->princ->realm, t->sprinc->realm))
        t->flags |= KRB5_KDB_FLAG_CROSS_REALM;

    t->is_referral = (t->flags & KRB5_KDB_FLAG_ISSUING_REFERRAL);
    t->is_crossrealm = (t->flags & KRB5_KDB_FLAG_CROSS_REALM);

    /* If S4U2Self padata is present, read it to get the requested principal
     * name.  Look up the requested client if it is in this realm. */
    ret = kdc_process_s4u2self_req(context, t->req, t->server, t->subkey,
                                   header_enc->session, &t->s4u2self,
                                   &t->client, status);
    if (t->s4u2self != NULL || ret) {
        if (t->s4u2self != NULL)
            au_state->s4u2self_user = t->s4u2self->user_id.user;
        au_state->status = *status;
        kau_s4u2self(context, !ret, au_state);
        au_state->s4u2self_user = NULL;
    }
    if (ret)
        return ret;
    if (t->s4u2self != NULL) {
        t->flags |= KRB5_KDB_FLAG_PROTOCOL_TRANSITION;
        t->s4u_cprinc = t->s4u2self->user_id.user;

        /*
         * For consistency with Active Directory, don't allow authorization
         * data to be disabled if S4U2Self is requested.  The requesting
         * service likely needs a PAC for an S4U2Proxy operation, even if it
         * doesn't need authorization data in tickets received from clients.
         */
        t->server->attributes &= ~KRB5_KDB_NO_AUTH_DATA_REQUIRED;
    }

    /* For U2U or S4U2Proxy requests, decrypt the second ticket and read its
     * PAC. */
    ret = decrypt_2ndtkt(context, t->req, t->flags, t->local_tgt,
                         &t->local_tgt_key, &t->stkt, &t->stkt_pac,
                         &t->stkt_server, &t->stkt_server_key, status);
    if (ret)
        return ret;

    /* Determine the subject ticket and set the authtime for logging.  For
     * S4U2Proxy requests determine the requested client principal. */
    if (t->req->kdc_options & KDC_OPT_CNAME_IN_ADDL_TKT) {
        t->flags |= KRB5_KDB_FLAG_CONSTRAINED_DELEGATION;
        ret = kau_make_tkt_id(context, t->stkt, &au_state->evid_tkt_id);
        if (ret)
            return ret;
        if (t->is_crossrealm) {
            /* For cross-realm S4U2PROXY requests, the second ticket is a
             * cross TGT with the requested client principal in its PAC. */
            if (t->stkt_pac == NULL ||
                get_pac_princ_with_realm(context, t->stkt_pac,
                                         &t->stkt_pac_client, NULL) != 0) {
                au_state->status = *status = "RBCD_PAC_PRINC";
                au_state->violation = PROT_CONSTRAINT;
                kau_s4u2proxy(context, FALSE, au_state);
                return KRB5KDC_ERR_BADOPTION;
            }
            t->s4u_cprinc = t->stkt_pac_client;
        } else {
            /* Otherwise the requested client is the evidence ticket client. */
            t->s4u_cprinc = t->stkt->enc_part2->client;
        }
        t->subject_tkt = t->stkt->enc_part2;
    } else {
        t->subject_tkt = header_enc;
    }
    t->authtime = t->subject_tkt->times.authtime;

    /* For final S4U requests (either type) the issued ticket will be for the
     * requested name; otherwise it will be for the header ticket client. */
    t->tkt_client = ((t->flags & KRB5_KDB_FLAGS_S4U) && !t->is_referral) ?
        t->s4u_cprinc : header_enc->client;

    if (t->s4u2self == NULL) {
        /* Extract auth indicators from the subject ticket.  Skip this for
         * S4U2Self requests as the subject didn't authenticate. */
        ret = get_auth_indicators(context, t->subject_tkt, t->local_tgt,
                                  &t->local_tgt_key, &t->auth_indicators);
        if (ret) {
            *status = "GET_AUTH_INDICATORS";
            return ret;
        }

        if (!(t->server->attributes & KRB5_KDB_NO_AUTH_DATA_REQUIRED)) {
            /* Try to look up the subject principal so that KDB modules can add
             * additional authdata.  Ask the KDB to map foreign principals. */
            assert(t->client == NULL);
            (void)krb5_db_get_principal(context, t->subject_tkt->client,
                                        t->flags | KRB5_KDB_FLAG_CLIENT |
                                        KRB5_KDB_FLAG_MAP_PRINCIPALS,
                                        &t->client);
        }
    }

    /*
     * Compute the transited list implied by the request.  Use the existing
     * transited list if the realm of the header ticket server is the same as
     * the subject or server realm.
     */
    if (!t->is_crossrealm ||
        data_eq(t->header_tkt->server->realm, t->tkt_client->realm)) {
        t->transited = header_enc->transited;
    } else {
        if (header_enc->transited.tr_type != KRB5_DOMAIN_X500_COMPRESS) {
            *status = "VALIDATE_TRANSIT_TYPE";
            return KRB5KDC_ERR_TRTYPE_NOSUPP;
        }
        ret = add_to_transited(&header_enc->transited.tr_contents,
                               &t->new_transited, t->header_tkt->server,
                               t->tkt_client, t->req->server);
        if (ret) {
            *status = "ADD_TO_TRANSITED_LIST";
            return ret;
        }
        t->transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;
        t->transited.tr_contents = t->new_transited;
    }

    return 0;
}
