apply_trans_params (struct ietf_full_conn *conn,
                                        const struct transport_params *params)
{
    struct lsquic_stream *stream;
    struct lsquic_hash_elem *el;
    enum stream_id_type sit;
    uint64_t limit;

    if ((params->tp_set & (1 << TPI_LOSS_BITS))
                                    && conn->ifc_settings->es_ql_bits == 2)
    {
        LSQ_DEBUG("turn on QL loss bits");
        lsquic_send_ctl_do_ql_bits(&conn->ifc_send_ctl);
    }

    if (params->tp_init_max_streams_bidi > (1ull << 60)
                            || params->tp_init_max_streams_uni > (1ull << 60))
    {
        if (params->tp_init_max_streams_bidi > (1ull << 60))
            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, "init_max_streams_bidi is "
                "too large: %"PRIu64, params->tp_init_max_streams_bidi);
        else
            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, "init_max_streams_uni is "
                "too large: %"PRIu64, params->tp_init_max_streams_uni);
        return -1;
    }

    sit = gen_sit(conn->ifc_flags & IFC_SERVER, SD_BIDI);
    conn->ifc_max_allowed_stream_id[sit] =
                        params->tp_init_max_streams_bidi << SIT_SHIFT;
    sit = gen_sit(conn->ifc_flags & IFC_SERVER, SD_UNI);
    conn->ifc_max_allowed_stream_id[sit] =
                        params->tp_init_max_streams_uni << SIT_SHIFT;

    conn->ifc_max_stream_data_uni      = params->tp_init_max_stream_data_uni;

    if (params->tp_init_max_data < conn->ifc_pub.conn_cap.cc_sent)
    {
        ABORT_WARN("peer specified init_max_data=%"PRIu64" bytes, which is "
            "smaller than the amount of data already sent on this connection "
            "(%"PRIu64" bytes)", params->tp_init_max_data,
            conn->ifc_pub.conn_cap.cc_sent);
        return -1;
    }

    conn->ifc_pub.conn_cap.cc_max = params->tp_init_max_data;

    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;
                             el = lsquic_hash_next(conn->ifc_pub.all_streams))
    {
        stream = lsquic_hashelem_getdata(el);
        if (is_our_stream(conn, stream))
            limit = params->tp_init_max_stream_data_bidi_remote;
        else
            limit = params->tp_init_max_stream_data_bidi_local;
        if (0 != lsquic_stream_set_max_send_off(stream, limit))
        {
            ABORT_WARN("cannot set peer-supplied max_stream_data=%"PRIu64
                "on stream %"PRIu64, limit, stream->id);
            return -1;
        }
    }

    if (conn->ifc_flags & IFC_SERVER)
        conn->ifc_cfg.max_stream_send
                                = params->tp_init_max_stream_data_bidi_local;
    else
        conn->ifc_cfg.max_stream_send
                                = params->tp_init_max_stream_data_bidi_remote;
    conn->ifc_cfg.ack_exp = params->tp_ack_delay_exponent;

    switch ((!!conn->ifc_settings->es_idle_timeout << 1)
                | !!params->tp_max_idle_timeout)
    {
    case       (0 << 1) | 0:
        LSQ_DEBUG("neither side specified max idle time out, turn it off");
        break;
    case       (0 << 1) | 1:
        LSQ_DEBUG("peer specified max idle timeout of %"PRIu64" ms (vs ours "
            "of zero): use it", params->tp_max_idle_timeout);
        conn->ifc_idle_to = params->tp_max_idle_timeout * 1000;
        break;
    case       (1 << 1) | 0:
        LSQ_DEBUG("peer did not specify max idle timeout, while ours is "
            "%u ms: use it", conn->ifc_settings->es_idle_timeout * 1000);
        conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;
        break;
    default:/* (1 << 1) | 1 */
        LSQ_DEBUG("our max idle timeout is %u ms, peer's is %"PRIu64" ms; "
            "use minimum value of %"PRIu64" ms",
            conn->ifc_settings->es_idle_timeout * 1000,
            params->tp_max_idle_timeout,
            MIN(conn->ifc_settings->es_idle_timeout * 1000,
                                            params->tp_max_idle_timeout));
        conn->ifc_idle_to = 1000 * MIN(conn->ifc_settings->es_idle_timeout
                                        * 1000, params->tp_max_idle_timeout);
        break;
    }

    if (conn->ifc_idle_to >= 2000000
                            && conn->ifc_enpub->enp_settings.es_ping_period)
        conn->ifc_ping_period = conn->ifc_idle_to / 2;
    else
        conn->ifc_ping_period = 0;
    LSQ_DEBUG("PING period is set to %"PRIu64" usec", conn->ifc_ping_period);

    if (conn->ifc_settings->es_delayed_acks
            && (params->tp_set
                    & ((1 << TPI_MIN_ACK_DELAY)|(1 << TPI_MIN_ACK_DELAY_02))))
    {
        /* We do not use the min_ack_delay value for anything at the moment,
         * as ACK_FREQUENCY frames we generate do not change the peer's max
         * ACK delay.  When or if we do decide to do it, don't forget to use
         * the correct value here -- based on which TP is set!
         */
        LSQ_DEBUG("delayed ACKs enabled");
        conn->ifc_flags |= IFC_DELAYED_ACKS;
        lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PACK_TOL,
                                        packet_tolerance_alarm_expired, conn);
    }
    if (conn->ifc_settings->es_timestamps
            && (params->tp_set & (1 << TPI_TIMESTAMPS))
                && (params->tp_numerics[TPI_TIMESTAMPS] & TS_WANT_THEM))
    {
        LSQ_DEBUG("timestamps enabled: will send TIMESTAMP frames");
        conn->ifc_flags |= IFC_TIMESTAMPS;
    }
    if (conn->ifc_settings->es_datagrams
            && (params->tp_set & (1 << TPI_MAX_DATAGRAM_FRAME_SIZE)))
    {
        LSQ_DEBUG("datagrams enabled");
        conn->ifc_flags |= IFC_DATAGRAMS;
        conn->ifc_max_dg_sz =
            params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE] > USHRT_MAX
            ? USHRT_MAX : params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE];
    }

    conn->ifc_pub.max_peer_ack_usec = params->tp_max_ack_delay * 1000;

    if ((params->tp_set & (1 << TPI_MAX_UDP_PAYLOAD_SIZE))
            /* Second check is so that we don't truncate a large value when
             * storing it in unsigned short.
             */
            && params->tp_numerics[TPI_MAX_UDP_PAYLOAD_SIZE]
                                                < TP_DEF_MAX_UDP_PAYLOAD_SIZE)
        conn->ifc_max_udp_payload = params->tp_numerics[TPI_MAX_UDP_PAYLOAD_SIZE];
    else
        conn->ifc_max_udp_payload = TP_DEF_MAX_UDP_PAYLOAD_SIZE;

    if (conn->ifc_max_udp_payload < CUR_NPATH(conn)->np_pack_size)
    {
        CUR_NPATH(conn)->np_pack_size = conn->ifc_max_udp_payload;
        LSQ_DEBUG("decrease packet size to %hu bytes",
                                                CUR_NPATH(conn)->np_pack_size);
    }

    if (params->tp_active_connection_id_limit > conn->ifc_conn.cn_n_cces)
        conn->ifc_active_cids_limit = conn->ifc_conn.cn_n_cces;
    else
        conn->ifc_active_cids_limit = params->tp_active_connection_id_limit;
    conn->ifc_first_active_cid_seqno = conn->ifc_scid_seqno;

    return 0;
}
