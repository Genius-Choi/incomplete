path_chal_alarm_expired (enum alarm_id al_id, void *ctx,
                                lsquic_time_t expiry, lsquic_time_t now)
{
    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;
    const unsigned path_id = al_id - AL_PATH_CHAL;
    struct conn_path *const copath = &conn->ifc_paths[path_id];

    if (copath->cop_n_chals < sizeof(copath->cop_path_chals)
                                        / sizeof(copath->cop_path_chals[0]))
    {
        LSQ_DEBUG("path #%u challenge expired, schedule another one", path_id);
        conn->ifc_send_flags |= SF_SEND_PATH_CHAL << path_id;
    }
    else if (conn->ifc_cur_path_id != path_id)
    {
        LSQ_INFO("migration to path #%u failed after none of %u path "
            "challenges received responses", path_id, copath->cop_n_chals);
        /* There may be a lingering challenge if its generation is delayed */
        lsquic_send_ctl_cancel_path_verification(&conn->ifc_send_ctl,
                                                        &copath->cop_path);
        wipe_path(conn, path_id);
    }
    else
        LSQ_INFO("no path challenge responses on current path %u, stop "
            "sending path challenges", path_id);
}
