generate_ack_frame_for_pns (struct ietf_full_conn *conn,
                struct lsquic_packet_out *packet_out, enum packnum_space pns,
                lsquic_time_t now)
{
    const uint64_t *ecn_counts;
    int has_missing, w;

    if (conn->ifc_incoming_ecn
                        && lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))
        ecn_counts = conn->ifc_ecn_counts_in[pns];
    else if ((conn->ifc_mflags & MF_SEND_WRONG_COUNTS) && pns == PNS_APP)
    {
        /* We try once.  A more advanced version would wait until we get a
         * packet from peer and only then stop.
         */
        conn->ifc_mflags &= ~MF_SEND_WRONG_COUNTS;
        ecn_counts = conn->ifc_ecn_counts_in[pns];
    }
    else
        ecn_counts = NULL;

    w = conn->ifc_conn.cn_pf->pf_gen_ack_frame(
            packet_out->po_data + packet_out->po_data_sz,
            lsquic_packet_out_avail(packet_out),
            (gaf_rechist_first_f)        lsquic_rechist_first,
            (gaf_rechist_next_f)         lsquic_rechist_next,
            (gaf_rechist_largest_recv_f) lsquic_rechist_largest_recv,
            &conn->ifc_rechist[pns], now, &has_missing, &packet_out->po_ack2ed,
            ecn_counts);
    if (w < 0) {
        ABORT_ERROR("%s generating ACK frame failed: %d", lsquic_pns2str[pns], errno);
        return -1;
    }
    CONN_STATS(out.acks, 1);
    char buf[0x100];
    lsquic_hexstr(packet_out->po_data + packet_out->po_data_sz, w, buf, sizeof(buf));
    LSQ_DEBUG("ACK bytes: %s", buf);
    EV_LOG_GENERATED_ACK_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,
                        packet_out->po_data + packet_out->po_data_sz, w);
    lsquic_send_ctl_scheduled_ack(&conn->ifc_send_ctl, pns,
                                                    packet_out->po_ack2ed);

    // NOTE: Add a PING frame after ACK frame before HANDSHAKE_DONE, in a hacky way
    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)
        && packet_out->po_data_sz + w < packet_out->po_n_alloc)
    {
        LSQ_DEBUG("add a PING frame before HANDSHAKE_DONE");
        *(packet_out->po_data + packet_out->po_data_sz + w) = '\x01';
        ++w;
    }

    packet_out->po_frame_types |= 1 << QUIC_FRAME_ACK;
    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,
                            QUIC_FRAME_ACK, packet_out->po_data_sz, w))
    {
        ABORT_ERROR("adding frame to packet failed: %d", errno);
        return -1;
    }
    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);
    packet_out->po_regen_sz += w;
    if (has_missing && !(conn->ifc_mflags & MF_IGNORE_MISSING))
        conn->ifc_flags |= IFC_ACK_HAD_MISS;
    else
        conn->ifc_flags &= ~IFC_ACK_HAD_MISS;
    LSQ_DEBUG("Put %d bytes of ACK frame into packet %" PRIu64
              " on outgoing queue", w, packet_out->po_packno);
    if (conn->ifc_n_cons_unretx >= conn->ifc_ping_unretx_thresh &&
                !lsquic_send_ctl_have_outgoing_retx_frames(&conn->ifc_send_ctl))
    {
        LSQ_DEBUG("schedule PING frame after %u non-retx "
                                    "packets sent", conn->ifc_n_cons_unretx);
        conn->ifc_send_flags |= SF_SEND_PING;
        /* This gives a range [12, 27]: */
        conn->ifc_ping_unretx_thresh = 12
                    + lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand);
    }

    conn->ifc_n_slack_akbl[pns] = 0;
    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << pns);
    if (pns == PNS_APP)
    {
        conn->ifc_n_slack_all = 0;
        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);
    }
    lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);
    LSQ_DEBUG("%s ACK state reset", lsquic_pns2str[pns]);

    if (pns == PNS_APP && (conn->ifc_flags & IFC_TIMESTAMPS))
        generate_timestamp_frame(conn, packet_out, now);

    return 0;
}
