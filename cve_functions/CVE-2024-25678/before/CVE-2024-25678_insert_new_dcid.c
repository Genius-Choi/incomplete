insert_new_dcid (struct ietf_full_conn *conn, uint64_t seqno,
    const lsquic_cid_t *cid, const unsigned char *token, int update_cur_dcid)
{
    struct dcid_elem **dce, **el;
    char tokstr[IQUIC_SRESET_TOKEN_SZ * 2 + 1];

    dce = NULL;
    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)
                                            / sizeof(conn->ifc_dces[0]); ++el)
        if (*el)
        {
            if ((*el)->de_seqno == seqno)
            {
                if (!LSQUIC_CIDS_EQ(&(*el)->de_cid, cid))
                {
                    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,
                        "NEW_CONNECTION_ID: already have CID seqno %"PRIu64
                        " but with a different CID", seqno);
                    return -1;
                }
                else
                {
                    LSQ_DEBUG("Ignore duplicate CID seqno %"PRIu64, seqno);
                    return 0;
                }
            }
            else if (LSQUIC_CIDS_EQ(&(*el)->de_cid, cid))
            {
                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,
                    "NEW_CONNECTION_ID: received the same CID with sequence "
                    "numbers %u and %"PRIu64, (*el)->de_seqno, seqno);
                return -1;
            }
            else if (((*el)->de_flags & DE_SRST)
                    && 0 == memcmp((*el)->de_srst, token,
                                                    IQUIC_SRESET_TOKEN_SZ))
            {
                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,
                    "NEW_CONNECTION_ID: received second instance of reset "
                    "token %s in seqno %"PRIu64", same as in seqno %u",
                    (lsquic_hexstr(token, IQUIC_SRESET_TOKEN_SZ, tokstr,
                                                    sizeof(tokstr)), tokstr),
                    seqno, (*el)->de_seqno);
                return -1;
            }
        }
        else if (!dce)
            dce = el;

    if (!dce)
    {
        ABORT_QUIETLY(0, TEC_CONNECTION_ID_LIMIT_ERROR,
            "NEW_CONNECTION_ID: received connection ID that is going over the "
            "limit of %u CIDs", MAX_IETF_CONN_DCIDS);
        return -1;
    }

    *dce = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);
    if (*dce)
    {
        memset(*dce, 0, sizeof(**dce));
        (*dce)->de_seqno = seqno;
        (*dce)->de_cid = *cid;
        memcpy((*dce)->de_srst, token, sizeof((*dce)->de_srst));
        (*dce)->de_flags |= DE_SRST;
        if (update_cur_dcid)
        {
            *CUR_DCID(conn) = *cid;
            if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)
                CUR_CPATH(conn)->cop_spin_bit = 0;
        }
    }
    else
        LSQ_WARN("cannot allocate dce to insert DCID seqno %"PRIu64, seqno);

    return 0;
}
