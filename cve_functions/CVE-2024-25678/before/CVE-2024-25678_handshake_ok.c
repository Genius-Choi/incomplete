handshake_ok (struct lsquic_conn *lconn)
{
    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;
    struct dcid_elem *dce;
    const struct transport_params *params;
    char buf[MAX_TP_STR_SZ];

    fiu_return_on("full_conn_ietf/handshake_ok", -1);

    /* Need to set this flag even we hit an error in the rest of this funciton.
     * This is because this flag is used to calculate packet out header size
     */
    lconn->cn_flags |= LSCONN_HANDSHAKE_DONE;

    params = lconn->cn_esf.i->esfi_get_peer_transport_params(
                                                        lconn->cn_enc_session);
    if (!params)
    {
        ABORT_WARN("could not get transport parameters");
        return -1;
    }

    LSQ_DEBUG("peer transport parameters: %s",
                    ((lconn->cn_version == LSQVER_ID27 ? lsquic_tp_to_str_27
                    : lsquic_tp_to_str)(params, buf, sizeof(buf)), buf));
    if (0 != apply_trans_params(conn, params))
        return -1;

    dce = get_new_dce(conn);
    if (!dce)
    {
        ABORT_WARN("cannot allocate DCE");
        return -1;
    }

    memset(dce, 0, sizeof(*dce));
    dce->de_cid = *CUR_DCID(conn);
    dce->de_seqno = 0;
    if (params->tp_set & (1 << TPI_STATELESS_RESET_TOKEN))
    {
        memcpy(dce->de_srst, params->tp_stateless_reset_token,
                                                    sizeof(dce->de_srst));
        dce->de_flags = DE_SRST | DE_ASSIGNED;
        if (conn->ifc_enpub->enp_srst_hash)
        {
            if (!lsquic_hash_insert(conn->ifc_enpub->enp_srst_hash,
                    dce->de_srst, sizeof(dce->de_srst), &conn->ifc_conn,
                    &dce->de_hash_el))
            {
                ABORT_WARN("cannot insert DCE");
                return -1;
            }
        }
    }
    else
        dce->de_flags = DE_ASSIGNED;

    if (!(conn->ifc_flags & IFC_SERVER)
        && (params->tp_set & (1 << TPI_VERSION_INFORMATION)))
    {
        LSQ_DEBUG("server chosen version %s",
                  lsquic_ver2str[params->tp_chosen_version]);
        if (((1 << params->tp_chosen_version)
            & conn->ifc_settings->es_versions) == 0)
        {
            ABORT_QUIETLY(0, TEC_VERSION_NEGOTIATION_ERROR,
                          "server chosen version %s is not supported",
                          lsquic_ver2str[params->tp_chosen_version]
                         );
            return -1;
        }
//         if (conn->ifc_conn.cn_version != params->tp_chosen_version)
//         {
//             LSQ_DEBUG("version negociation: switch version from %s to %s",
//                   lsquic_ver2str[conn->ifc_conn.cn_version],
//                   lsquic_ver2str[params->tp_chosen_version]);
//             conn->ifc_conn.cn_version = params->tp_chosen_version;
//         }
    }

    LSQ_INFO("applied peer transport parameters");

    if ((conn->ifc_flags & (IFC_HTTP|IFC_HTTP_INITED)) == IFC_HTTP)
        if (0 != init_http(conn))
            return -1;

    if (conn->ifc_settings->es_dplpmtud)
        conn->ifc_mflags |= MF_CHECK_MTU_PROBE;

    if (can_issue_cids(conn))
        conn->ifc_send_flags |= SF_SEND_NEW_CID;
    maybe_create_delayed_streams(conn);

    if (!(conn->ifc_flags & IFC_SERVER))
        lsquic_send_ctl_0rtt_to_1rtt(&conn->ifc_send_ctl);

    return 0;
}
