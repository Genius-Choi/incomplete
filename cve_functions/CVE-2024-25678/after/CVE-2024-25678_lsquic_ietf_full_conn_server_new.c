lsquic_ietf_full_conn_server_new (struct lsquic_engine_public *enpub,
               unsigned flags, struct lsquic_conn *mini_conn)
{
    struct ietf_mini_conn *const imc = (void *) mini_conn;
    struct ietf_full_conn *conn;
    struct lsquic_packet_out *packet_out;
    struct lsquic_packet_in *packet_in;
    struct conn_cid_elem *cce;
    int have_outgoing_ack;
    lsquic_packno_t next_packno;
    lsquic_time_t now;
    enum packnum_space pns;
    unsigned i;
    struct ietf_mini_rechist mini_rechist;

    conn = calloc(1, sizeof(*conn));
    if (!conn)
        goto err0;
    now = lsquic_time_now();
    conn->ifc_conn.cn_cces = conn->ifc_cces;
    conn->ifc_conn.cn_n_cces = sizeof(conn->ifc_cces)
                                                / sizeof(conn->ifc_cces[0]);
    assert(conn->ifc_conn.cn_n_cces >= mini_conn->cn_n_cces);
    conn->ifc_conn.cn_cur_cce_idx = mini_conn->cn_cur_cce_idx;
    conn->ifc_conn.cn_cces_mask = mini_conn->cn_cces_mask;
    for (cce = mini_conn->cn_cces, i = 0; cce < END_OF_CCES(mini_conn);
                                                                    ++cce, ++i)
        if ((1 << (cce - mini_conn->cn_cces)) & mini_conn->cn_cces_mask)
        {
            conn->ifc_conn.cn_cces[i].cce_cid   = cce->cce_cid;
            conn->ifc_conn.cn_cces[i].cce_flags = cce->cce_flags;
            if (cce->cce_flags & CCE_SEQNO)
            {
                if (cce->cce_seqno > conn->ifc_scid_seqno)
                    conn->ifc_scid_seqno = cce->cce_seqno;
                conn->ifc_conn.cn_cces[i].cce_seqno = cce->cce_seqno;
                ++conn->ifc_active_cids_count;
            }
            conn->ifc_scid_timestamp[i] = now;
        }
    ++conn->ifc_scid_seqno;
    conn->ifc_conn.cn_logid = mini_conn->cn_logid;
    /* Set the flags early so that correct CID is used for logging */
    conn->ifc_conn.cn_flags |= LSCONN_IETF | LSCONN_SERVER;

    if (0 != ietf_full_conn_init(conn, enpub, flags,
                                        lsquic_mini_conn_ietf_ecn_ok(imc)))
        goto err1;
    conn->ifc_pub.packet_out_malo =
                        lsquic_malo_create(sizeof(struct lsquic_packet_out));
    if (!conn->ifc_pub.packet_out_malo)
        goto err1;
    if (imc->imc_flags & IMC_IGNORE_INIT)
        conn->ifc_flags |= IFC_IGNORE_INIT;
    if (enpub->enp_settings.es_support_srej)
        conn->ifc_send_flags |= SF_SEND_NEW_TOKEN;

    conn->ifc_paths[0].cop_path = imc->imc_path;
    conn->ifc_paths[0].cop_flags = COP_VALIDATED|COP_INITIALIZED|COP_ALLOW_MTU_PADDING;
    conn->ifc_used_paths = 1 << 0;
    maybe_enable_spin(conn, &conn->ifc_paths[0]);
    if (imc->imc_flags & IMC_ADDR_VALIDATED)
        lsquic_send_ctl_path_validated(&conn->ifc_send_ctl);
    else
        conn->ifc_mflags |= MF_VALIDATE_PATH;
    conn->ifc_pub.bytes_out = imc->imc_bytes_out;
    conn->ifc_pub.bytes_in = imc->imc_bytes_in;
    if (imc->imc_flags & IMC_PATH_CHANGED)
    {
        LSQ_DEBUG("path changed during mini conn: schedule PATH_CHALLENGE");
        conn->ifc_send_flags |= SF_SEND_PATH_CHAL_PATH_0;
    }

    conn->ifc_max_streams_in[SD_BIDI]
        = enpub->enp_settings.es_init_max_streams_bidi;
    conn->ifc_max_allowed_stream_id[SIT_BIDI_CLIENT]
        = conn->ifc_max_streams_in[SD_BIDI] << SIT_SHIFT;
    conn->ifc_max_streams_in[SD_UNI]
        = enpub->enp_settings.es_init_max_streams_uni;
    conn->ifc_max_allowed_stream_id[SIT_UNI_CLIENT]
        = conn->ifc_max_streams_in[SD_UNI] << SIT_SHIFT;
    conn->ifc_conn.cn_version     = mini_conn->cn_version;
    conn->ifc_conn.cn_flags      |= LSCONN_VER_SET;
    conn->ifc_conn.cn_pf          = mini_conn->cn_pf;
    conn->ifc_conn.cn_esf_c       = mini_conn->cn_esf_c;
    conn->ifc_conn.cn_esf         = mini_conn->cn_esf;

    if (enpub->enp_settings.es_support_push)
        conn->ifc_u.ser.ifser_flags |= IFSER_PUSH_ENABLED;
    if (flags & IFC_HTTP)
    {
        fiu_do_on("full_conn_ietf/promise_hash", goto promise_alloc_failed);
        conn->ifc_pub.u.ietf.promises = lsquic_hash_create();
#if FIU_ENABLE
  promise_alloc_failed:
#endif
        if (!conn->ifc_pub.u.ietf.promises)
            goto err2;
    }

    assert(mini_conn->cn_flags & LSCONN_HANDSHAKE_DONE);
    conn->ifc_conn.cn_flags      |= LSCONN_HANDSHAKE_DONE;
    if (!(imc->imc_flags & IMC_HSK_DONE_SENT))
    {
        LSQ_DEBUG("HANDSHAKE_DONE not yet sent, will process CRYPTO frames");
        conn->ifc_flags |= IFC_PROC_CRYPTO;
    }

    conn->ifc_conn.cn_enc_session = mini_conn->cn_enc_session;
    mini_conn->cn_enc_session     = NULL;
    conn->ifc_conn.cn_esf_c->esf_set_conn(conn->ifc_conn.cn_enc_session,
                                                            &conn->ifc_conn);
    conn->ifc_process_incoming_packet = process_incoming_packet_fast;

    conn->ifc_send_ctl.sc_cur_packno = imc->imc_next_packno - 1;
    conn->ifc_incoming_ecn = imc->imc_incoming_ecn;
    conn->ifc_pub.rtt_stats = imc->imc_rtt_stats;

    conn->ifc_last_live_update = now;

    lsquic_send_ctl_begin_optack_detection(&conn->ifc_send_ctl);

    for (pns = 0; pns < IMICO_N_PNS; ++pns)
    {
        lsquic_imico_rechist_init(&mini_rechist, imc, pns);
        if (pns < IMICO_N_PNS)
        {
            if (0 != lsquic_rechist_copy_ranges(&conn->ifc_rechist[pns],
                                    &mini_rechist, lsquic_imico_rechist_first,
                                    lsquic_imico_rechist_next))
                goto err2;
            conn->ifc_rechist[pns].rh_largest_acked_received
                                                = imc->imc_largest_recvd[pns];
        }
    }

    /* Mini connection sends out packets 0, 1, 2... and so on.  It deletes
     * packets that have been successfully sent and acked or those that have
     * been lost.  We take ownership of all packets in mc_packets_out; those
     * that are not on the list are recorded in fc_send_ctl.sc_senhist.
     */
    have_outgoing_ack = 0;
    next_packno = ~0ULL;
    /* mini conn may drop Init packets, making gaps; don't warn about them: */
    conn->ifc_send_ctl.sc_senhist.sh_flags |= SH_GAP_OK;
    while ((packet_out = TAILQ_FIRST(&imc->imc_packets_out)))
    {
        TAILQ_REMOVE(&imc->imc_packets_out, packet_out, po_next);

        /* Holes in the sequence signify no-longer-relevant Initial packets or
         * ACKed or lost packets.
         */
        ++next_packno;
        for ( ; next_packno < packet_out->po_packno; ++next_packno)
        {
            lsquic_senhist_add(&conn->ifc_send_ctl.sc_senhist, next_packno);
            conn->ifc_send_ctl.sc_senhist.sh_warn_thresh = next_packno;
        }

        packet_out->po_path = CUR_NPATH(conn);
        if (imc->imc_sent_packnos & (1ULL << packet_out->po_packno))
        {
            LSQ_DEBUG("got sent packet_out %"PRIu64" from mini",
                                                   packet_out->po_packno);
            if (0 != lsquic_send_ctl_sent_packet(&conn->ifc_send_ctl,
                                                             packet_out))
            {
                LSQ_WARN("could not add packet %"PRIu64" to sent set: %s",
                    packet_out->po_packno, strerror(errno));
                goto err2;
            }
        }
        else
        {
            LSQ_DEBUG("got unsent packet_out %"PRIu64" from mini (will send)",
                                                   packet_out->po_packno);
            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);
            have_outgoing_ack |= packet_out->po_frame_types &
                                                (1 << QUIC_FRAME_ACK);
        }
    }
    conn->ifc_send_ctl.sc_senhist.sh_flags &= ~SH_GAP_OK;
    /* ...Yes, that's a bunch of little annoying steps to suppress the gap
     * warnings, but it would have been even more annoying (and expensive)
     * to add packet renumbering logic to the mini conn.
     */

    for (pns = 0; pns < IMICO_N_PNS; ++pns)
        for (i = 0; i < 4; ++i)
        {
            conn->ifc_ecn_counts_in[pns][i]  = imc->imc_ecn_counts_in[pns][i];
        }

    if (0 != handshake_ok(&conn->ifc_conn))
        goto err3;

    LSQ_DEBUG("Calling on_new_conn callback");
    conn->ifc_conn.cn_conn_ctx = conn->ifc_enpub->enp_stream_if->on_new_conn(
                        conn->ifc_enpub->enp_stream_if_ctx, &conn->ifc_conn);
    conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;

    conn->ifc_created = now;
    if (conn->ifc_idle_to)
        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE,
                                        now + conn->ifc_idle_to);
    while ((packet_in = TAILQ_FIRST(&imc->imc_app_packets)))
    {
        TAILQ_REMOVE(&imc->imc_app_packets, packet_in, pi_next);
        LSQ_DEBUG("inherit packet %"PRIu64" from mini conn",
                                                        packet_in->pi_packno);
        ietf_full_conn_ci_packet_in(&conn->ifc_conn, packet_in);
        lsquic_packet_in_put(conn->ifc_pub.mm, packet_in);
    }

    LSQ_DEBUG("logging using %s SCID",
        LSQUIC_LOG_CONN_ID == CN_SCID(&conn->ifc_conn) ? "server" : "client");
    conn->ifc_flags |= IFC_CREATED_OK;
    return &conn->ifc_conn;

  err3:
    ietf_full_conn_ci_destroy(&conn->ifc_conn);
    return NULL;

  err2:
    lsquic_malo_destroy(conn->ifc_pub.packet_out_malo);
  err1:
    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);
    if (conn->ifc_pub.all_streams)
        lsquic_hash_destroy(conn->ifc_pub.all_streams);
    free(conn);
  err0:
    return NULL;
}
