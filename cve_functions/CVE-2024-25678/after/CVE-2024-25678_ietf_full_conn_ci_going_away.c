ietf_full_conn_ci_going_away (struct lsquic_conn *lconn)
{
    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;

    if (conn->ifc_flags & IFC_HTTP)
    {
        if (!(conn->ifc_flags & (IFC_CLOSING|IFC_GOING_AWAY)))
        {
            LSQ_INFO("connection marked as going away, last stream: %" PRIu64,
                     conn->ifc_max_req_id);
            conn->ifc_flags |= IFC_GOING_AWAY;
            const lsquic_stream_id_t stream_id = conn->ifc_max_req_id + N_SITS;
            if (valid_stream_id(stream_id))
            {
                if (0 == lsquic_hcso_write_goaway(&conn->ifc_hcso,
                                                        conn->ifc_max_req_id))
                    lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);
                else
                    /* We're already going away, don't abort because of this */
                    LSQ_WARN("could not write GOAWAY frame");
            }
            maybe_close_conn(conn);
        }
    }
    else
        LSQ_NOTICE("going away has no effect in non-HTTP mode");
}
