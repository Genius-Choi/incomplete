on_priority_update_server (void *ctx, enum hq_frame_type frame_type,
                                uint64_t id, const char *pfv, size_t pfv_sz)
{
    struct ietf_full_conn *const conn = ctx;
    struct lsquic_hash_elem *el;
    struct push_promise *promise;
    struct lsquic_stream *stream;
    enum stream_id_type sit;
    struct lsquic_ext_http_prio ehp;

    if (conn->ifc_pii != &ext_prio_iter_if)
    {
        LSQ_DEBUG("Ignore PRIORITY_UPDATE frame");
        return;
    }

    if (frame_type == HQFT_PRIORITY_UPDATE_STREAM)
    {
        sit = id & SIT_MASK;
        if (sit != SIT_BIDI_CLIENT)
        {
            ABORT_QUIETLY(1, HEC_ID_ERROR, "PRIORITY_UPDATE for non-request "
                "stream");
            return;
        }
        if (id >= conn->ifc_max_allowed_stream_id[sit])
        {
            ABORT_QUIETLY(1, HEC_ID_ERROR, "PRIORITY_UPDATE for non-existing "
                "stream %"PRIu64" exceeds allowed max of %"PRIu64,
                id, conn->ifc_max_allowed_stream_id[sit]);
            return;
        }
        stream = find_stream_by_id(conn, id);
        if (!stream && conn_is_stream_closed(conn, id))
        {
            LSQ_DEBUG("stream %"PRIu64" closed, ignore PRIORITY_UPDATE", id);
            return;
        }
    }
    else
    {
        if (id >= conn->ifc_u.ser.ifser_next_push_id)
        {
            ABORT_QUIETLY(1, HEC_ID_ERROR, "received PRIORITY_UPDATE with "
                "ID=%"PRIu64", which is greater than the maximum Push ID "
                "ever generated by this connection", id);
            return;
        }
        el = lsquic_hash_find(conn->ifc_pub.u.ietf.promises, &id, sizeof(id));
        if (!el)
        {
            LSQ_DEBUG("push promise %"PRIu64" not found, ignore "
                                                    "PRIORITY_UPDATE", id);
            return;
        }
        promise = lsquic_hashelem_getdata(el);
        stream = promise->pp_pushed_stream;
        assert(stream);
    }

    ehp = (struct lsquic_ext_http_prio) {
        .urgency     = LSQUIC_DEF_HTTP_URGENCY,
        .incremental = LSQUIC_DEF_HTTP_INCREMENTAL,
    };
    if (pfv_sz)
    {
        switch (lsquic_http_parse_pfv(pfv, pfv_sz, NULL, &ehp,
                                    (char *) conn->ifc_pub.mm->acki,
                                    sizeof(*conn->ifc_pub.mm->acki)))
        {
        case 0:
            LSQ_DEBUG("Parsed PFV `%.*s' correctly", (int) pfv_sz, pfv);
            break;
        case -2:    /* Out of memory, ignore */
            LSQ_INFO("Ignore PFV `%.*s': out of memory", (int) pfv_sz, pfv);
            return;
        default:
            LSQ_INFO("connection error due to invalid PFV `%.*s'",
                                                        (int) pfv_sz, pfv);
            /* From the draft (between versions 1 and 2):
             " Failure to parse the Priority Field Value MUST be treated
             " as a connection error of type FRAME_ENCODING_ERROR.
             */
            ABORT_QUIETLY(1, HEC_FRAME_ERROR, "cannot parse Priority Field "
                "Value in PRIORITY_UPDATE frame");
            return;
        }
    }
    else
        { /* Empty PFV means "use defaults" */ }

    if (stream)
        (void) lsquic_stream_set_http_prio(stream, &ehp);
    else
    {
        assert(frame_type == HQFT_PRIORITY_UPDATE_STREAM);
        if (0 == buffer_priority_update(conn, id, &ehp))
            LSQ_INFO("buffered priority update for stream %"PRIu64"; "
                "urgency: %hhu, incremental: %hhd", id, ehp.urgency,
                ehp.incremental);
    }
}
