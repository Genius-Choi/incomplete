on_goaway_client (void *ctx, uint64_t stream_id)
{
    struct ietf_full_conn *const conn = ctx;
    struct lsquic_stream *stream;
    struct lsquic_hash_elem *el;
    enum stream_id_type sit;

    sit = stream_id & SIT_MASK;
    if (sit != SIT_BIDI_CLIENT)
    {
        ABORT_QUIETLY(1, HEC_ID_ERROR,
                            "stream ID %"PRIu64" in GOAWAY frame", stream_id);
        return;
    }

    LSQ_DEBUG("received GOAWAY frame, last good stream ID: %"PRIu64, stream_id);

    if (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY)
    {
        if (stream_id == conn->ifc_u.cli.ifcli_min_goaway_stream_id)
        {
            LSQ_DEBUG("ignore duplicate GOAWAY frame");
            return;
        }
        if (stream_id > conn->ifc_u.cli.ifcli_min_goaway_stream_id)
        {
            ABORT_QUIETLY(1, HEC_ID_ERROR,
                "stream ID %"PRIu64" is larger than one already seen in a "
                "previous GOAWAY frame, %"PRIu64, stream_id,
                conn->ifc_u.cli.ifcli_min_goaway_stream_id);
            return;
        }
    }
    else
    {
        conn->ifc_u.cli.ifcli_min_goaway_stream_id = stream_id;
        conn->ifc_conn.cn_flags |= LSCONN_PEER_GOING_AWAY;
        if (conn->ifc_enpub->enp_stream_if->on_goaway_received)
            conn->ifc_enpub->enp_stream_if->on_goaway_received(&conn->ifc_conn);
    }

    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;
                             el = lsquic_hash_next(conn->ifc_pub.all_streams))
    {
        stream = lsquic_hashelem_getdata(el);
        if (stream->id > stream_id
                            && (stream->id & SIT_MASK) == SIT_BIDI_CLIENT)
        {
            lsquic_stream_received_goaway(stream);
        }
    }
}
