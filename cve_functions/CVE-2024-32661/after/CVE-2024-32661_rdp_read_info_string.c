static BOOL rdp_read_info_string(rdpSettings* settings, FreeRDP_Settings_Keys_String id,
                                 UINT32 flags, wStream* s, size_t cbLenNonNull, size_t max)
{
	union
	{
		char c;
		WCHAR w;
		BYTE b[2];
	} terminator;

	const BOOL unicode = (flags & INFO_UNICODE) ? TRUE : FALSE;
	const size_t nullSize = unicode ? sizeof(WCHAR) : sizeof(CHAR);

	if (!freerdp_settings_set_string(settings, id, NULL))
		return FALSE;

	if (!Stream_CheckAndLogRequiredLength(TAG, s, (size_t)(cbLenNonNull + nullSize)))
		return FALSE;

	if (cbLenNonNull > 0)
	{
		/* cbDomain is the size in bytes of the character data in the Domain field.
		 * This size excludes (!) the length of the mandatory null terminator.
		 * Maximum value including the mandatory null terminator: 512
		 */
		if ((cbLenNonNull % 2) || (cbLenNonNull > (max - nullSize)))
		{
			WLog_ERR(TAG, "protocol error: invalid value: %" PRIuz "", cbLenNonNull);
			return FALSE;
		}

		if (unicode)
		{
			const WCHAR* domain = Stream_PointerAs(s, WCHAR);
			if (!freerdp_settings_set_string_from_utf16N(settings, id, domain,
			                                             cbLenNonNull / sizeof(WCHAR)))
				return FALSE;
		}
		else
		{
			const char* domain = Stream_PointerAs(s, char);
			if (!freerdp_settings_set_string_len(settings, id, domain, cbLenNonNull))
				return FALSE;
		}
	}

	Stream_Seek(s, cbLenNonNull);

	terminator.w = L'\0';
	Stream_Read(s, terminator.b, nullSize);

	if (terminator.w != L'\0')
	{
		WLog_ERR(TAG, "protocol error: Domain must be null terminated");
		freerdp_settings_set_string(settings, id, NULL);
		return FALSE;
	}

	return TRUE;
}
