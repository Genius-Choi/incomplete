static BOOL rdp_write_extended_info_packet(rdpRdp* rdp, wStream* s)
{
	BOOL ret = FALSE;
	size_t cbClientAddress = 0;
	const size_t cbClientAddressMax = rdp_get_client_address_max_size(rdp);
	WCHAR* clientDir = NULL;
	size_t cbClientDir = 0;
	const size_t cbClientDirMax = 512;
	UINT16 cbAutoReconnectCookie = 0;

	WINPR_ASSERT(rdp);

	rdpSettings* settings = rdp->settings;
	WINPR_ASSERT(settings);

	UINT16 clientAddressFamily = ADDRESS_FAMILY_INET;
	if (settings->ConnectChildSession)
		clientAddressFamily = 0x0000;
	else if (settings->IPv6Enabled)
		clientAddressFamily = ADDRESS_FAMILY_INET6;

	WCHAR* clientAddress = ConvertUtf8ToWCharAlloc(settings->ClientAddress, &cbClientAddress);

	if (cbClientAddress > (UINT16_MAX / sizeof(WCHAR)))
	{
		WLog_ERR(TAG, "cbClientAddress > UINT16_MAX");
		goto fail;
	}

	if (cbClientAddress > 0)
	{
		cbClientAddress = (UINT16)(cbClientAddress + 1) * sizeof(WCHAR);
		if (cbClientAddress > cbClientAddressMax)
		{
			WLog_WARN(TAG,
			          "the client address %s [%" PRIuz "] exceeds the limit of %" PRIuz
			          ", truncating.",
			          settings->ClientAddress, cbClientAddress, cbClientAddressMax);

			clientAddress[(cbClientAddressMax / sizeof(WCHAR)) - 1] = '\0';
			cbClientAddress = cbClientAddressMax;
		}
	}

	clientDir = ConvertUtf8ToWCharAlloc(settings->ClientDir, &cbClientDir);
	if (cbClientDir > (UINT16_MAX / sizeof(WCHAR)))
	{
		WLog_ERR(TAG, "cbClientDir > UINT16_MAX");
		goto fail;
	}

	if (cbClientDir > 0)
	{
		cbClientDir = (UINT16)(cbClientDir + 1) * sizeof(WCHAR);
		if (cbClientDir > cbClientDirMax)
		{
			WLog_WARN(TAG,
			          "the client dir %s [%" PRIuz "] exceeds the limit of %" PRIuz ", truncating.",
			          settings->ClientDir, cbClientDir, cbClientDirMax);

			clientDir[(cbClientDirMax / sizeof(WCHAR)) - 1] = '\0';
			cbClientDir = cbClientDirMax;
		}
	}

	if (settings->ServerAutoReconnectCookie->cbLen > UINT16_MAX)
	{
		WLog_ERR(TAG, "ServerAutoreconnectCookie::cbLen > UINT16_MAX");
		goto fail;
	}

	cbAutoReconnectCookie = (UINT16)settings->ServerAutoReconnectCookie->cbLen;

	if (!Stream_EnsureRemainingCapacity(s, 4ull + cbClientAddress + 2ull + cbClientDir))
		goto fail;

	Stream_Write_UINT16(s, clientAddressFamily); /* clientAddressFamily (2 bytes) */
	Stream_Write_UINT16(s, cbClientAddress);     /* cbClientAddress (2 bytes) */

	Stream_Write(s, clientAddress, cbClientAddress); /* clientAddress */

	Stream_Write_UINT16(s, cbClientDir); /* cbClientDir (2 bytes) */

	Stream_Write(s, clientDir, cbClientDir); /* clientDir */

	if (!rdp_write_client_time_zone(s, settings)) /* clientTimeZone (172 bytes) */
		goto fail;

	if (!Stream_EnsureRemainingCapacity(s, 10ull))
		goto fail;

	Stream_Write_UINT32(
	    s, settings->ClientSessionId); /* clientSessionId (4 bytes), should be set to 0 */
	freerdp_performance_flags_make(settings);
	Stream_Write_UINT32(s, settings->PerformanceFlags); /* performanceFlags (4 bytes) */
	Stream_Write_UINT16(s, cbAutoReconnectCookie);      /* cbAutoReconnectCookie (2 bytes) */

	if (cbAutoReconnectCookie > 0)
	{
		if (!rdp_compute_client_auto_reconnect_cookie(rdp))
			goto fail;
		if (!rdp_write_client_auto_reconnect_cookie(rdp, s)) /* autoReconnectCookie */
			goto fail;

		if (!Stream_EnsureRemainingCapacity(s, 4ull))
			goto fail;
		Stream_Write_UINT16(s, 0); /* reserved1 (2 bytes) */
		Stream_Write_UINT16(s, 0); /* reserved2 (2 bytes) */
	}

	if (freerdp_settings_get_bool(settings, FreeRDP_SupportDynamicTimeZone))
	{
		if (!Stream_EnsureRemainingCapacity(s, 10 + 254 * sizeof(WCHAR)))
			goto fail;

		/* skip reserved1 and reserved2 fields */
		Stream_Seek(s, 4);

		size_t rlen = 0;
		const char* tz = freerdp_settings_get_string(settings, FreeRDP_DynamicDSTTimeZoneKeyName);
		if (tz)
			rlen = strnlen(tz, 254);
		Stream_Write_UINT16(s, (UINT16)rlen * sizeof(WCHAR));
		if (Stream_Write_UTF16_String_From_UTF8(s, rlen, tz, rlen, FALSE) < 0)
			goto fail;
		Stream_Write_UINT16(s, settings->DynamicDaylightTimeDisabled ? 0x01 : 0x00);
	}

	ret = TRUE;
fail:
	free(clientAddress);
	free(clientDir);
	return ret;
}
