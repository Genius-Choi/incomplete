        {
            //The array is a continuous array if there is only one segment
            if (startSeg->next == nullptr) // Single segment fast path
            {
                if (compFn != nullptr)
                {
                    countUndefined = startSeg->RemoveUndefined(scriptContext);

#ifdef VALIDATE_ARRAY
                    ValidateSegment(startSeg);
#endif
                    hybridSort(startSeg->elements, startSeg->length, &cvInfo);
                }
                else
                {
                    countUndefined = sort(startSeg->elements, &startSeg->length, scriptContext);
                }
                head = startSeg;
            }
            else
            {
                SparseArraySegment<Var>* allElements = SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, nullptr);
                SparseArraySegment<Var>* next = startSeg;

                uint32 nextIndex = 0;
                // copy all the elements to single segment
                while (next)
                {
                    countUndefined += next->RemoveUndefined(scriptContext);
                    if (next->length != 0)
                    {
                        allElements = SparseArraySegment<Var>::CopySegment(recycler, allElements, nextIndex, next, next->left, next->length);
                    }
                    next = (SparseArraySegment<Var>*)next->next;
                    nextIndex = allElements->length;

#ifdef VALIDATE_ARRAY
                    ValidateSegment(allElements);
#endif
                }

                if (compFn != nullptr)
                {
                    hybridSort(allElements->elements, allElements->length, &cvInfo);
                }
                else
                {
                    sort(allElements->elements, &allElements->length, scriptContext);
                }

                head = allElements;
                head->next = nullptr;
            }
        },
