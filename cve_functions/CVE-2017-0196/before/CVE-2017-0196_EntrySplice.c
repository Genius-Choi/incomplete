    Var JavascriptArray::EntrySplice(RecyclableObject* function, CallInfo callInfo, ...)
    {
        PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);

        ARGUMENTS(args, callInfo);
        ScriptContext* scriptContext = function->GetScriptContext();
        Recycler *recycler = scriptContext->GetRecycler();

        Assert(!(callInfo.Flags & CallFlags_New));

        AssertMsg(args.Info.Count >= 1, "Should have at least one argument");

        bool isArr = false;
        JavascriptArray* pArr = 0;
        RecyclableObject* pObj = 0;
        RecyclableObject* newObj = nullptr;
        uint32 start = 0;
        uint32 deleteLen = 0;
        uint32 len = 0;

        if (JavascriptArray::Is(args[0]) && scriptContext == JavascriptArray::FromVar(args[0])->GetScriptContext())
        {
            isArr = true;
            pArr = JavascriptArray::FromVar(args[0]);
            pObj = pArr;
            len = pArr->length;

#if ENABLE_COPYONACCESS_ARRAY
            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);
#endif
        }
        else
        {
            if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))
            {
                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u("Array.prototype.splice"));
            }

            if (scriptContext->GetConfig()->IsES6ToLengthEnabled())
            {
                int64 len64 = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);
                len = len64 > UINT_MAX ? UINT_MAX : (uint)len64;
            }
            else
            {
                len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext);
            }
        }

        switch (args.Info.Count)
        {
        case 1:
            start = len;
            deleteLen = 0;
            break;

        case 2:
            start = min(GetFromIndex(args[1], len, scriptContext), len);
            deleteLen = len - start;
            break;

        default:
            start = GetFromIndex(args[1], len, scriptContext);

            if (start > len)
            {
                start = len;
            }

            // When start >= len, we know we won't be deleting any items and don't really need to evaluate the second argument.
            // However, ECMA 262 15.4.4.12 requires that it be evaluated, anyway.  If the argument is an object with a valueOf
            // with a side effect, this evaluation is observable.  Hence, we must evaluate.
            if (TaggedInt::Is(args[2]))
            {
                int intDeleteLen = TaggedInt::ToInt32(args[2]);
                if (intDeleteLen < 0)
                {
                    deleteLen = 0;
                }
                else
                {
                    deleteLen = intDeleteLen;
                }
            }
            else
            {
                double dblDeleteLen = JavascriptConversion::ToInteger(args[2], scriptContext);

                if (dblDeleteLen > len)
                {
                    deleteLen = (uint32)-1;
                }
                else if (dblDeleteLen <= 0)
                {
                    deleteLen = 0;
                }
                else
                {
                    deleteLen = (uint32)dblDeleteLen;
                }
            }
            deleteLen = min(len - start, deleteLen);
            break;
        }

        Var* insertArgs = args.Info.Count > 3 ? &args.Values[3] : nullptr;
        uint32 insertLen = args.Info.Count > 3 ? args.Info.Count - 3 : 0;

        ::Math::RecordOverflowPolicy newLenOverflow;
        uint32 newLen = UInt32Math::Add(len - deleteLen, insertLen, newLenOverflow); // new length of the array after splice

        if (isArr)
        {
            // If we have missing values then convert to not native array for now
            // In future, we could support this scenario.
            if (deleteLen == insertLen)
            {
                pArr->FillFromPrototypes(start, start + deleteLen);
            }
            else if (len)
            {
                pArr->FillFromPrototypes(start, len);
            }

            //
            // If newLen overflowed, pre-process to prevent pushing sparse array segments or elements out of
            // max array length, which would result in tons of index overflow and difficult to fix.
            //
            if (newLenOverflow.HasOverflowed())
            {
                pArr = EnsureNonNativeArray(pArr);
                BigIndex dstIndex = MaxArrayLength;

                uint32 maxInsertLen = MaxArrayLength - start;
                if (insertLen > maxInsertLen)
                {
                    // Copy overflowing insertArgs to properties
                    for (uint32 i = maxInsertLen; i < insertLen; i++)
                    {
                        pArr->DirectSetItemAt(dstIndex, insertArgs[i]);
                        ++dstIndex;
                    }

                    insertLen = maxInsertLen; // update

                    // Truncate elements on the right to properties
                    if (start + deleteLen < len)
                    {
                        pArr->TruncateToProperties(dstIndex, start + deleteLen);
                    }
                }
                else
                {
                    // Truncate would-overflow elements to properties
                    pArr->TruncateToProperties(dstIndex, MaxArrayLength - insertLen + deleteLen);
                }

                len = pArr->length; // update
                newLen = len - deleteLen + insertLen;
                Assert(newLen == MaxArrayLength);
            }

            if (insertArgs)
            {
                pArr = EnsureNonNativeArray(pArr);
            }

            bool isIntArray = false;
            bool isFloatArray = false;
            bool isBuiltinArrayCtor = true;
            JavascriptArray *newArr = nullptr;

            // Just dump the segment map on splice (before any possible allocation and throw)
            pArr->ClearSegmentMap();

            // If the source object is an Array exotic object (Array.isArray) we should try to load the constructor property
            // and use it to construct the return object.
            newObj = ArraySpeciesCreate(pArr, deleteLen, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);
            if (newObj != nullptr)
            {
                pArr = EnsureNonNativeArray(pArr);
                // If the new object we created is an array, remember that as it will save us time setting properties in the object below
                if (JavascriptArray::Is(newObj))
                {
#if ENABLE_COPYONACCESS_ARRAY
                    JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);
#endif
                    newArr = JavascriptArray::FromVar(newObj);
                }
            }
            else
            // This is the ES5 case, pArr['constructor'] doesn't exist, or pArr['constructor'] is the builtin Array constructor
            {
                pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);
                newArr = CreateNewArrayHelper(deleteLen, isIntArray, isFloatArray, pArr, scriptContext);
#if ENABLE_COPYONACCESS_ARRAY
                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);
#endif
            }

            // If return object is a JavascriptArray, we can use all the array splice helpers
            if (newArr && isBuiltinArrayCtor && len == pArr->length)
            {

                // Array has a single segment (need not start at 0) and splice start lies in the range
                // of that segment we optimize splice - Fast path.
                if (pArr->IsSingleSegmentArray() && pArr->head->HasIndex(start))
                {
                    if (isIntArray)
                    {
                        ArraySegmentSpliceHelper<int32>(newArr, (SparseArraySegment<int32>*)pArr->head, (SparseArraySegment<int32>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);
                    }
                    else if (isFloatArray)
                    {
                        ArraySegmentSpliceHelper<double>(newArr, (SparseArraySegment<double>*)pArr->head, (SparseArraySegment<double>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);
                    }
                    else
                    {
                        ArraySegmentSpliceHelper<Var>(newArr, (SparseArraySegment<Var>*)pArr->head, (SparseArraySegment<Var>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);
                    }

                    // Since the start index is within the bounds of the original array's head segment, it will not acquire any new
                    // missing values. If the original array had missing values in the head segment, some of them may have been
                    // copied into the array that will be returned; otherwise, the array that is returned will also not have any
                    // missing values.
                    newArr->SetHasNoMissingValues(pArr->HasNoMissingValues());
                }
                else
                {
                    if (isIntArray)
                    {
                        ArraySpliceHelper<int32>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);
                    }
                    else if (isFloatArray)
                    {
                        ArraySpliceHelper<double>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);
                    }
                    else
                    {
                        ArraySpliceHelper<Var>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);
                    }

                    // This function currently does not track missing values in the head segment if there are multiple segments
                    pArr->SetHasNoMissingValues(false);
                    newArr->SetHasNoMissingValues(false);
                }

                if (isIntArray)
                {
                    pArr->EnsureHeadStartsFromZero<int32>(recycler);
                    newArr->EnsureHeadStartsFromZero<int32>(recycler);
                }
                else if (isFloatArray)
                {
                    pArr->EnsureHeadStartsFromZero<double>(recycler);
                    newArr->EnsureHeadStartsFromZero<double>(recycler);
                }
                else
                {
                    pArr->EnsureHeadStartsFromZero<Var>(recycler);
                    newArr->EnsureHeadStartsFromZero<Var>(recycler);
                }

                pArr->InvalidateLastUsedSegment();

                // it is possible for valueOf accessors for the start or deleteLen
                // arguments to modify the size of the array. Since the resulting size of the array
                // is based on the cached value of length, this might lead to us having to trim
                // excess array segments at the end of the splice operation, which SetLength() will do.
                // However, this is also slower than performing the simple length assignment, so we only
                // do it if we can detect the array length changing.
                if(pArr->length != len)
                {
                    pArr->SetLength(newLen);
                }
                else
                {
                    pArr->length = newLen;
                }

                if (newArr->length != deleteLen)
                {
                    newArr->SetLength(deleteLen);
                }
                else
                {
                    newArr->length = deleteLen;
                }

                newArr->InvalidateLastUsedSegment();

#ifdef VALIDATE_ARRAY
                newArr->ValidateArray();
                pArr->ValidateArray();
#endif
                if (newLenOverflow.HasOverflowed())
                {
                    // ES5 15.4.4.12 16: If new len overflowed, SetLength throws
                    JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);
                }

                return newArr;
            }
        }

        if (newLenOverflow.HasOverflowed())
        {
            return ObjectSpliceHelper<BigIndex>(pObj, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj);
        }
        else // Use uint32 version if no overflow
        {
            return ObjectSpliceHelper<uint32>(pObj, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj);
        }
    }
