    RecyclableObject* JavascriptArray::ObjectSpliceHelper(RecyclableObject* pObj, uint32 len, uint32 start,
        uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext, RecyclableObject* pNewObj)
    {
        JavascriptArray *pnewArr = nullptr;

        if (pNewObj == nullptr)
        {
            pNewObj = ArraySpeciesCreate(pObj, deleteLen, scriptContext);
            if (pNewObj == nullptr || !JavascriptArray::Is(pNewObj))
            {
                pnewArr = scriptContext->GetLibrary()->CreateArray(deleteLen);
                pnewArr->EnsureHead<Var>();

                pNewObj = pnewArr;
            }
        }

        if (JavascriptArray::Is(pNewObj))
        {
#if ENABLE_COPYONACCESS_ARRAY
            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pNewObj);
#endif
            pnewArr = JavascriptArray::FromVar(pNewObj);
        }

        // copy elements to delete to new array
        if (deleteLen > 0)
        {
            for (uint32 i = 0; i < deleteLen; i++)
            {
               if (JavascriptOperators::HasItem(pObj, start+i))
               {
                   Var element = JavascriptOperators::GetItem(pObj, start + i, scriptContext);
                   if (pnewArr)
                   {
                       pnewArr->SetItem(i, element, PropertyOperation_None);
                   }
                   else
                   {
                       ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(pNewObj, i, element), scriptContext, i);
                   }
               }
            }
        }

        ThrowTypeErrorOnFailureHelper h(scriptContext, _u("Array.prototype.splice"));

        // If the return object is not an array, we'll need to set the 'length' property
        if (pnewArr == nullptr)
        {
            h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, JavascriptNumber::ToVar(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));
        }

        // Now we need reserve room if it is necessary
        if (insertLen > deleteLen) // Might overflow max array length
        {
            // Unshift [start + deleteLen, len) to start + insertLen
            Unshift<indexT>(pObj, start + insertLen, start + deleteLen, len, scriptContext);
        }
        else if (insertLen < deleteLen) // Won't overflow max array length
        {
            uint32 j = 0;
            for (uint32 i = start + deleteLen; i < len; i++)
            {
                if (JavascriptOperators::HasItem(pObj, i))
                {
                    Var element = JavascriptOperators::GetItem(pObj, i, scriptContext);
                    h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, start + insertLen + j, element, scriptContext, PropertyOperation_ThrowIfNotExtensible));
                }
                else
                {
                    h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, start + insertLen + j, PropertyOperation_ThrowOnDeleteIfNotConfig));
                }
                j++;
            }

            // Clean up the rest
            for (uint32 i = len; i > len - deleteLen + insertLen; i--)
            {
                h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, i - 1, PropertyOperation_ThrowOnDeleteIfNotConfig));
            }
        }

        if (insertLen > 0)
        {
            indexT dstIndex = start; // insert index might overflow max array length
            for (uint i = 0; i < insertLen; i++)
            {
                h.ThrowTypeErrorOnFailure(IndexTrace<indexT>::SetItem(pObj, dstIndex, insertArgs[i], PropertyOperation_ThrowIfNotExtensible));
                ++dstIndex;
            }
        }

        // Set up new length
        indexT newLen = indexT(len - deleteLen) + insertLen;
        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pObj, pObj, PropertyIds::length, IndexTrace<indexT>::ToNumber(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));
        h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, IndexTrace<indexT>::ToNumber(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));
#ifdef VALIDATE_ARRAY
        if (pnewArr)
        {
            pnewArr->ValidateArray();
        }
#endif
        return pNewObj;
    }
