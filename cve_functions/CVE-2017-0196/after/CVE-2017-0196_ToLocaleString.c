    JavascriptString* JavascriptArray::ToLocaleString(T* arr, ScriptContext* scriptContext)
    {
        uint32 length = 0;
        if (TypedArrayBase::Is(arr))
        {
            // For a TypedArray use the actual length of the array.
            length = TypedArrayBase::FromVar(arr)->GetLength();
        }
        else
        {
            //For anything else, use the "length" property if present.
            length = ItemTrace<T>::GetLength(arr, scriptContext);
        }

        if (length == 0 || scriptContext->CheckObject(arr))
        {
            return scriptContext->GetLibrary()->GetEmptyString();
        }

        JavascriptString* res = scriptContext->GetLibrary()->GetEmptyString();
        bool pushedObject = false;

        TryFinally([&]()
        {
            scriptContext->PushObject(arr);
            pushedObject = true;

            Var element;
            if (ItemTrace<T>::GetItem(arr, 0, &element, scriptContext))
            {
                res = JavascriptArray::ToLocaleStringHelper(element, scriptContext);
            }

            if (length > 1)
            {
                JavascriptString* separator = GetLocaleSeparator(scriptContext);

                for (uint32 i = 1; i < length; i++)
                {
                    res = JavascriptString::Concat(res, separator);
                    if (ItemTrace<T>::GetItem(arr, i, &element, scriptContext))
                    {
                        res = JavascriptString::Concat(res, JavascriptArray::ToLocaleStringHelper(element, scriptContext));
                    }
                }
            }
        },
        [&](bool/*hasException*/)
        {
            if (pushedObject)
            {
                Var top = scriptContext->PopObject();
                AssertMsg(top == arr, "Unmatched operation stack");
            }
        });

        if (res == nullptr)
        {
            res = scriptContext->GetLibrary()->GetEmptyString();
        }

        return res;
    }
