static bool do_chown(const String& filename,
                     const Variant& user,
                     bool islChown,
                     const char* funcName) {
  // If filename points to a user file, invoke ExtendedWrapper::chown(..)
  Stream::Wrapper* w = Stream::getWrapperFromURI(filename);
  auto usw = dynamic_cast<Stream::ExtendedWrapper*>(w);
  if (usw != nullptr) {
    if (user.isInteger()) {
      return usw->chown(filename, user.toInt64());
    } else if (user.isString()) {
      return usw->chown(filename, user.toString());
    }
    raise_warning("%s(): parameter 2 should be string or integer, %s given",
      funcName, getDataTypeString(user.getType()).c_str());
    return false;
  }

#ifdef WIN32
  return false;
#else
  int uid;
  if (user.isString()) {
    String suser = user.toString();
    auto buf = PasswdBuffer{};
    struct passwd *pw;
    if (getpwnam_r(suser.data(), &buf.ent, buf.data.get(), buf.size, &pw)) {
      // failed to read user info
      return false;
    }
    if (!pw) {
      Logger::Verbose("%s/%d: Unable to find uid for %s",
        __FUNCTION__, __LINE__, suser.data());
      raise_warning("%s(): Unable to find uid for %s", funcName,
        user.toString().c_str());
      return false;
    }
    uid = pw->pw_uid;
  } else {
    uid = user.toInt32();
  }

  if (islChown) {
    CHECK_SYSTEM(lchown(File::TranslatePath(filename).data(), uid, (gid_t)-1));
  } else {
    CHECK_SYSTEM(chown(File::TranslatePath(filename).data(), uid, (gid_t)-1));
  }
  return true;
#endif
}
