int data_proc(
    image_desc_t *im)
{
    long      i, ii;
    double    pixstep = (double) (im->end - im->start)
        / (double) im->xsize;   /* how much time
                                   passes in one pixel */
    double    paintval;
    double    minval = DNAN, maxval = DNAN;

    unsigned long gr_time;

    /* memory for the processed data */
    for (i = 0; i < im->gdes_c; i++) {
        if ((im->gdes[i].gf == GF_LINE) ||
            (im->gdes[i].gf == GF_AREA) || (im->gdes[i].gf == GF_TICK)) {
            if ((im->gdes[i].p_data = (rrd_value_t*)malloc((im->xsize + 1)
                                             * sizeof(rrd_value_t))) == NULL) {
                rrd_set_error("malloc data_proc");
                return -1;
            }
        }
    }

    for (i = 0; i < im->xsize; i++) {   /* for each pixel */
        long      vidx;

        gr_time = im->start + pixstep * i;  /* time of the current step */
        paintval = 0.0;

        for (ii = 0; ii < im->gdes_c; ii++) {
            double    value;

            switch (im->gdes[ii].gf) {
            case GF_LINE:
            case GF_AREA:
            case GF_TICK:
                if (!im->gdes[ii].stack)
                    paintval = 0.0;
                value = im->gdes[ii].yrule;
                if (isnan(value) || (im->gdes[ii].gf == GF_TICK)) {
                    /* The time of the data doesn't necessarily match
                     ** the time of the graph. Beware.
                     */
                    vidx = im->gdes[ii].vidx;
                    if (im->gdes[vidx].gf == GF_VDEF) {
                        value = im->gdes[vidx].vf.val;
                    } else
                        if (((long int) gr_time >=
                             (long int) im->gdes[vidx].start)
                            && ((long int) gr_time <
                                (long int) im->gdes[vidx].end)) {
                        value = im->gdes[vidx].data[(unsigned long)
                                                    floor((double)
                                                          (gr_time -
                                                           im->gdes[vidx].
                                                           start)
                                                          /
                                                          im->gdes[vidx].step)
                                                    * im->gdes[vidx].ds_cnt +
                                                    im->gdes[vidx].ds];
                    } else {
                        value = DNAN;
                    }
                };

                if (!isnan(value)) {
                    paintval += value;
                    im->gdes[ii].p_data[i] = paintval;
                    /* GF_TICK: the data values are not
                     ** relevant for min and max
                     */
                    if (finite(paintval) && im->gdes[ii].gf != GF_TICK && !im->gdes[ii].skipscale) {
                        if ((isnan(minval) || paintval < minval) &&
                            !(im->logarithmic && paintval <= 0.0))
                            minval = paintval;
                        if (isnan(maxval) || paintval > maxval)
                            maxval = paintval;
                    }
                } else {
                    im->gdes[ii].p_data[i] = DNAN;
                }
                break;
            case GF_STACK:
                rrd_set_error
                    ("STACK should already be turned into LINE or AREA here");
                return -1;
                break;
            default:
                break;
            }
        }
    }

    /* if min or max have not been asigned a value this is because
       there was no data in the graph ... this is not good ...
       lets set these to dummy values then ... */

    if (im->logarithmic) {
        if (isnan(minval) || isnan(maxval) || maxval <= 0) {
            minval = 0.0;   /* catching this right away below */
            maxval = 5.1;
        }
        /* in logarithm mode, where minval is smaller or equal
           to 0 make the beast just way smaller than maxval */
        if (minval <= 0) {
            minval = maxval / 10e8;
        }
    } else {
        if (isnan(minval) || isnan(maxval)) {
            minval = 0.0;
            maxval = 1.0;
        }
    }

    /* adjust min and max values given by the user */
    /* for logscale we add something on top */
    if (isnan(im->minval)
        || ((!im->rigid) && im->minval > minval)
        ) {
        if (im->logarithmic)
            im->minval = minval / 2.0;
        else
            im->minval = minval;
    }
    if (isnan(im->maxval)
        || (!im->rigid && im->maxval < maxval)
        ) {
        if (im->logarithmic)
            im->maxval = maxval * 2.0;
        else
            im->maxval = maxval;
    }

    /* make sure min is smaller than max */
    if (im->minval > im->maxval) {
        if (im->minval > 0)
            im->minval = 0.99 * im->maxval;
        else
            im->minval = 1.01 * im->maxval;
    }

    /* make sure min and max are not equal */
    if (AlmostEqual2sComplement(im->minval, im->maxval, 4)) {
        if (im->maxval > 0)
            im->maxval *= 1.01;
        else
            im->maxval *= 0.99;

        /* make sure min and max are not both zero */
        if (AlmostEqual2sComplement(im->maxval, 0, 4)) {
            im->maxval = 1.0;
        }
    }
    return 0;
}
