void vertical_grid(
    image_desc_t *im)
{
    int       xlab_sel; /* which sort of label and grid ? */
    time_t    ti, tilab, timajor;
    long      factor;
    char      graph_label[100];
    double    X0, Y0, Y1;   /* points for filled graph and more */
    struct tm tm;

    /* the type of time grid is determined by finding
       the number of seconds per pixel in the graph */
    if (im->xlab_user.minsec == -1) {
        factor = (im->end - im->start) / im->xsize;
        xlab_sel = 0;
        while (xlab[xlab_sel + 1].minsec !=
               -1 && xlab[xlab_sel + 1].minsec <= factor) {
            xlab_sel++;
        }               /* pick the last one */
        while (xlab[xlab_sel - 1].minsec ==
               xlab[xlab_sel].minsec
               && xlab[xlab_sel].length > (im->end - im->start)) {
            xlab_sel--;
        }               /* go back to the smallest size */
        im->xlab_user.gridtm = xlab[xlab_sel].gridtm;
        im->xlab_user.gridst = xlab[xlab_sel].gridst;
        im->xlab_user.mgridtm = xlab[xlab_sel].mgridtm;
        im->xlab_user.mgridst = xlab[xlab_sel].mgridst;
        im->xlab_user.labtm = xlab[xlab_sel].labtm;
        im->xlab_user.labst = xlab[xlab_sel].labst;
        im->xlab_user.precis = xlab[xlab_sel].precis;
        im->xlab_user.stst = xlab[xlab_sel].stst;
    }

    /* y coords are the same for every line ... */
    Y0 = im->yorigin;
    Y1 = im->yorigin - im->ysize;
    /* paint the minor grid */
    if (!(im->extra_flags & NOMINOR)) {
        for (ti = find_first_time(im->start,
                                  im->
                                  xlab_user.
                                  gridtm,
                                  im->
                                  xlab_user.
                                  gridst),
             timajor =
             find_first_time(im->start,
                             im->xlab_user.
                             mgridtm,
                             im->xlab_user.
                             mgridst);
             ti < im->end && ti != -1;
             ti =
             find_next_time(ti, im->xlab_user.gridtm, im->xlab_user.gridst)
            ) {
            /* are we inside the graph ? */
            if (ti < im->start || ti > im->end)
                continue;
            while (timajor < ti && timajor != -1) {
                timajor = find_next_time(timajor,
                                         im->
                                         xlab_user.
                                         mgridtm, im->xlab_user.mgridst);
            }
            if (timajor == -1) break; /* fail in case of problems with time increments */
            if (ti == timajor)
                continue;   /* skip as falls on major grid line */
            X0 = xtr(im, ti);
            gfx_line(im, X0, Y1 - 2, X0, Y1,
                     GRIDWIDTH, im->graph_col[GRC_GRID]);
            gfx_line(im, X0, Y0, X0, Y0 + 2,
                     GRIDWIDTH, im->graph_col[GRC_GRID]);
            gfx_dashed_line(im, X0, Y0 + 1, X0,
                            Y1 - 1, GRIDWIDTH,
                            im->
                            graph_col[GRC_GRID],
                            im->grid_dash_on, im->grid_dash_off);
        }
    }

    /* paint the major grid */
    for (ti = find_first_time(im->start,
                              im->
                              xlab_user.
                              mgridtm,
                              im->
                              xlab_user.
                              mgridst);
         ti < im->end && ti != -1;
         ti = find_next_time(ti, im->xlab_user.mgridtm, im->xlab_user.mgridst)
        ) {
        /* are we inside the graph ? */
        if (ti < im->start || ti > im->end)
            continue;
        X0 = xtr(im, ti);
        gfx_line(im, X0, Y1 - 2, X0, Y1,
                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);
        gfx_line(im, X0, Y0, X0, Y0 + 3,
                 MGRIDWIDTH, im->graph_col[GRC_MGRID]);
        gfx_dashed_line(im, X0, Y0 + 3, X0,
                        Y1 - 2, MGRIDWIDTH,
                        im->
                        graph_col
                        [GRC_MGRID], im->grid_dash_on, im->grid_dash_off);
    }
    /* paint the labels below the graph */
    for (ti =
         find_first_time(im->start -
                         im->xlab_user.
                         precis / 2,
                         im->xlab_user.
                         labtm,
                         im->xlab_user.
                         labst);
         (ti <=
         im->end -
         im->xlab_user.precis / 2) && ti != -1;
         ti = find_next_time(ti, im->xlab_user.labtm, im->xlab_user.labst)
        ) {
        tilab = ti + im->xlab_user.precis / 2;  /* correct time for the label */
        /* are we inside the graph ? */
        if (tilab < im->start || tilab > im->end)
            continue;
#if HAVE_STRFTIME
        localtime_r(&tilab, &tm);
        strftime(graph_label, 99, im->xlab_user.stst, &tm);
#else
# error "your libc has no strftime I guess we'll abort the exercise here."
#endif
        gfx_text(im,
                 xtr(im, tilab),
                 Y0 + 3,
                 im->graph_col[GRC_FONT],
                 im->
                 text_prop[TEXT_PROP_AXIS].
                 font_desc,
                 im->tabwidth, 0.0,
                 GFX_H_CENTER, GFX_V_TOP, graph_label);
    }

}
