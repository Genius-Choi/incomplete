int data_fetch(
    image_desc_t *im)
{
    int       i, ii;

    /* pull the data from the rrd files ... */
    for (i = 0; i < (int) im->gdes_c; i++) {
        /* only GF_DEF elements fetch data */
        if (im->gdes[i].gf != GF_DEF)
            continue;

        /* do we have it already ? */
        gpointer value;
        char *key = gdes_fetch_key(im->gdes[i]);
        gboolean ok = g_hash_table_lookup_extended(im->rrd_map,key,NULL,&value);
        free(key);
        if (ok){
            ii = GPOINTER_TO_INT(value);
            im->gdes[i].start = im->gdes[ii].start;
            im->gdes[i].end = im->gdes[ii].end;
            im->gdes[i].step = im->gdes[ii].step;
            im->gdes[i].ds_cnt = im->gdes[ii].ds_cnt;
            im->gdes[i].ds_namv = im->gdes[ii].ds_namv;
            im->gdes[i].data = im->gdes[ii].data;
            im->gdes[i].data_first = 0;
        } else {
            unsigned long ft_step = im->gdes[i].step;   /* ft_step will record what we got from fetch */

            /* Flush the file if
             * - a connection to the daemon has been established
             * - this is the first occurrence of that RRD file
             */
            if (rrdc_is_connected(im->daemon_addr))
            {
                int status;

                status = 0;
                for (ii = 0; ii < i; ii++)
                {
                    if (strcmp (im->gdes[i].rrd, im->gdes[ii].rrd) == 0)
                    {
                        status = 1;
                        break;
                    }
                }

                if (status == 0)
                {
                    status = rrdc_flush (im->gdes[i].rrd);
                    if (status != 0)
                    {
                        rrd_set_error ("rrdc_flush (%s) failed with status %i.",
                                im->gdes[i].rrd, status);
                        return (-1);
                    }
                }
            } /* if (rrdc_is_connected()) */

            if ((rrd_fetch_fn(im->gdes[i].rrd,
                              im->gdes[i].cf,
                              &im->gdes[i].start,
                              &im->gdes[i].end,
                              &ft_step,
                              &im->gdes[i].ds_cnt,
                              &im->gdes[i].ds_namv,
                              &im->gdes[i].data)) == -1) {
                return -1;
            }
            im->gdes[i].data_first = 1;

            /* must reduce to at least im->step
               otherwhise we end up with more data than we can handle in the 
               chart and visibility of data will be random */            
            im->gdes[i].step = max(im->gdes[i].step,im->step);
            if (ft_step < im->gdes[i].step) {
                reduce_data(im->gdes[i].cf_reduce,
                            ft_step,
                            &im->gdes[i].start,
                            &im->gdes[i].end,
                            &im->gdes[i].step,
                            &im->gdes[i].ds_cnt, &im->gdes[i].data);
            } else {
                im->gdes[i].step = ft_step;
            }
        }

        /* lets see if the required data source is really there */
        for (ii = 0; ii < (int) im->gdes[i].ds_cnt; ii++) {
            if (strcmp(im->gdes[i].ds_namv[ii], im->gdes[i].ds_nam) == 0) {
                im->gdes[i].ds = ii;
            }
        }
        if (im->gdes[i].ds == -1) {
            rrd_set_error("No DS called '%s' in '%s'",
                          im->gdes[i].ds_nam, im->gdes[i].rrd);
            return -1;
        }

    }
    return 0;
}
