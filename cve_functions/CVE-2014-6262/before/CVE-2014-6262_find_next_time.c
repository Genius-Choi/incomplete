time_t find_next_time(
    time_t current,     /* what is the initial time */
    enum tmt_en baseint,    /* what is the basic interval */
    long basestep       /* how many if these do we jump a time */
    )
{
    struct tm tm;
    time_t    madetime;

    localtime_r(&current, &tm);
    /* let mktime figure this dst on its own */
    tm.tm_isdst = -1;

    int limit = 2;
    switch (baseint) {
    case TMT_SECOND: limit = 7200; break;
    case TMT_MINUTE: limit = 120; break;
    case TMT_HOUR: limit = 2; break;
    default: limit = 2; break;
    }
    do {
        switch (baseint) {
        case TMT_SECOND:
            tm.       tm_sec += basestep;

            break;
        case TMT_MINUTE:
            tm.       tm_min += basestep;

            break;
        case TMT_HOUR:
            tm.       tm_hour += basestep;

            break;
        case TMT_DAY:
            tm.       tm_mday += basestep;

            break;
        case TMT_WEEK:
            tm.       tm_mday += 7 * basestep;

            break;
        case TMT_MONTH:
            tm.       tm_mon += basestep;

            break;
        case TMT_YEAR:
            tm.       tm_year += basestep;
        }
        madetime = mktime(&tm);
    } while (madetime == -1 && limit-- >= 0);   /* this is necessary to skip impossible times
                                   like the daylight saving time skips */
    return madetime;

}
