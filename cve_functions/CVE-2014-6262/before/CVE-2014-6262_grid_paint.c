void grid_paint(
    image_desc_t *im)
{
    long      i;
    int       res = 0;
    double    X0, Y0;   /* points for filled graph and more */
    struct gfx_color_t water_color;

    if (im->draw_3d_border > 0) {
	    /* draw 3d border */
	    i = im->draw_3d_border;
	    gfx_new_area(im, 0, im->yimg,
			 i, im->yimg - i, i, i, im->graph_col[GRC_SHADEA]);
	    gfx_add_point(im, im->ximg - i, i);
	    gfx_add_point(im, im->ximg, 0);
	    gfx_add_point(im, 0, 0);
	    gfx_close_path(im);
	    gfx_new_area(im, i, im->yimg - i,
			 im->ximg - i,
			 im->yimg - i, im->ximg - i, i, im->graph_col[GRC_SHADEB]);
	    gfx_add_point(im, im->ximg, 0);
	    gfx_add_point(im, im->ximg, im->yimg);
	    gfx_add_point(im, 0, im->yimg);
	    gfx_close_path(im);
    }
    if (im->draw_x_grid == 1)
        vertical_grid(im);
    if (im->draw_y_grid == 1) {
        if (im->logarithmic) {
            res = horizontal_log_grid(im);
        } else {
            res = draw_horizontal_grid(im);
        }

        /* dont draw horizontal grid if there is no min and max val */
        if (!res) {
            char     *nodata = "No Data found";

            gfx_text(im, im->ximg / 2,
                     (2 * im->yorigin -
                      im->ysize) / 2,
                     im->graph_col[GRC_FONT],
                     im->
                     text_prop[TEXT_PROP_AXIS].
                     font_desc,
                     im->tabwidth, 0.0,
                     GFX_H_CENTER, GFX_V_CENTER, nodata);
        }
    }

    /* yaxis unit description */
    if (im->ylegend[0] != '\0'){
        gfx_text(im,
                 im->xOriginLegendY+10,
                 im->yOriginLegendY,
                 im->graph_col[GRC_FONT],
                 im->
                 text_prop[TEXT_PROP_UNIT].
                 font_desc,
                 im->tabwidth,
                 RRDGRAPH_YLEGEND_ANGLE, GFX_H_CENTER, GFX_V_CENTER, im->ylegend);

    }
    if (im->second_axis_legend[0] != '\0'){
            gfx_text( im,
                  im->xOriginLegendY2+10,
                  im->yOriginLegendY2,
                  im->graph_col[GRC_FONT],
                  im->text_prop[TEXT_PROP_UNIT].font_desc,
                  im->tabwidth,
                  RRDGRAPH_YLEGEND_ANGLE,
                  GFX_H_CENTER, GFX_V_CENTER,
                  im->second_axis_legend);
    }

    /* graph title */
    gfx_text(im,
             im->xOriginTitle, im->yOriginTitle+6,
             im->graph_col[GRC_FONT],
             im->
             text_prop[TEXT_PROP_TITLE].
             font_desc,
             im->tabwidth, 0.0, GFX_H_CENTER, GFX_V_TOP, im->title);
    /* rrdtool 'logo' */
    if (!(im->extra_flags & NO_RRDTOOL_TAG)){
        water_color = im->graph_col[GRC_FONT];
        water_color.alpha = 0.3;
        double xpos = im->legendposition == EAST ? im->xOriginLegendY : im->ximg - 4;
        gfx_text(im, xpos, 5,
                 water_color,
                 im->
                 text_prop[TEXT_PROP_WATERMARK].
                 font_desc, im->tabwidth,
                 -90, GFX_H_LEFT, GFX_V_TOP, "RRDTOOL / TOBI OETIKER");
    }
    /* graph watermark */
    if (im->watermark[0] != '\0') {
        water_color = im->graph_col[GRC_FONT];
        water_color.alpha = 0.3;
        gfx_text(im,
                 im->ximg / 2, im->yimg - 6,
                 water_color,
                 im->
                 text_prop[TEXT_PROP_WATERMARK].
                 font_desc, im->tabwidth, 0,
                 GFX_H_CENTER, GFX_V_BOTTOM, im->watermark);
    }

    /* graph labels */
    if (!(im->extra_flags & NOLEGEND) && !(im->extra_flags & ONLY_GRAPH)) {
        for (i = 0; i < im->gdes_c; i++) {
            if (im->gdes[i].legend[0] == '\0')
                continue;
            /* im->gdes[i].leg_y is the bottom of the legend */
            X0 = im->xOriginLegend + im->gdes[i].leg_x;
            Y0 = im->legenddirection == TOP_DOWN ? im->yOriginLegend + im->gdes[i].leg_y : im->yOriginLegend + im->legendheight - im->gdes[i].leg_y;
            gfx_text(im, X0, Y0,
                     im->graph_col[GRC_FONT],
                     im->
                     text_prop
                     [TEXT_PROP_LEGEND].font_desc,
                     im->tabwidth, 0.0,
                     GFX_H_LEFT, GFX_V_BOTTOM, im->gdes[i].legend);
            /* The legend for GRAPH items starts with "M " to have
               enough space for the box */
            if (im->gdes[i].gf != GF_PRINT &&
                im->gdes[i].gf != GF_GPRINT && im->gdes[i].gf != GF_COMMENT) {
                double    boxH, boxV;
                double    X1, Y1;

                boxH = gfx_get_text_width(im, 0,
                                          im->
                                          text_prop
                                          [TEXT_PROP_LEGEND].
                                          font_desc,
                                          im->tabwidth, "o") * 1.2;
                boxV = boxH;
                /* shift the box up a bit */
                Y0 -= boxV * 0.4;

        if (im->dynamic_labels && im->gdes[i].gf == GF_HRULE) { /* [-] */ 
			cairo_save(im->cr);
			cairo_new_path(im->cr);
			cairo_set_line_width(im->cr, 1.0);
			gfx_line(im,
				X0, Y0 - boxV / 2,
				X0 + boxH, Y0 - boxV / 2,
				1.0, im->gdes[i].col);
            		gfx_close_path(im);
		} else if (im->dynamic_labels && im->gdes[i].gf == GF_VRULE) { /* [|] */
			cairo_save(im->cr);
			cairo_new_path(im->cr);
			cairo_set_line_width(im->cr, 1.0);
			gfx_line(im,
				X0 + boxH / 2, Y0,
				X0 + boxH / 2, Y0 - boxV,
				1.0, im->gdes[i].col);
            		gfx_close_path(im);
		} else if (im->dynamic_labels && im->gdes[i].gf == GF_LINE) { /* [/] */
			cairo_save(im->cr);
			cairo_new_path(im->cr);
			cairo_set_line_width(im->cr, im->gdes[i].linewidth);
			gfx_line(im,
				X0, Y0,
				X0 + boxH, Y0 - boxV,
				im->gdes[i].linewidth, im->gdes[i].col);
            		gfx_close_path(im);
		} else {
		/* make sure transparent colors show up the same way as in the graph */
			gfx_new_area(im,
				     X0, Y0 - boxV,
				     X0, Y0, X0 + boxH, Y0, im->graph_col[GRC_BACK]);
			gfx_add_point(im, X0 + boxH, Y0 - boxV);
			gfx_close_path(im);
			gfx_new_area(im, X0, Y0 - boxV, X0,
				     Y0, X0 + boxH, Y0, im->gdes[i].col);
			gfx_add_point(im, X0 + boxH, Y0 - boxV);
			gfx_close_path(im);
			cairo_save(im->cr);
			cairo_new_path(im->cr);
			cairo_set_line_width(im->cr, 1.0);
			X1 = X0 + boxH;
			Y1 = Y0 - boxV;
			gfx_line_fit(im, &X0, &Y0);
			gfx_line_fit(im, &X1, &Y1);
			cairo_move_to(im->cr, X0, Y0);
			cairo_line_to(im->cr, X1, Y0);
			cairo_line_to(im->cr, X1, Y1);
			cairo_line_to(im->cr, X0, Y1);
			cairo_close_path(im->cr);
			cairo_set_source_rgba(im->cr,
					      im->graph_col[GRC_FRAME].red,
					      im->graph_col[GRC_FRAME].green,
					      im->graph_col[GRC_FRAME].blue,
					      im->graph_col[GRC_FRAME].alpha);
		}
                if (im->gdes[i].dash) {
                    /* make box borders in legend dashed if the graph is dashed */
                    double    dashes[] = {
                        3.0
                    };
                    cairo_set_dash(im->cr, dashes, 1, 0.0);
                }
                cairo_stroke(im->cr);
                cairo_restore(im->cr);
            }
        }
    }
}
