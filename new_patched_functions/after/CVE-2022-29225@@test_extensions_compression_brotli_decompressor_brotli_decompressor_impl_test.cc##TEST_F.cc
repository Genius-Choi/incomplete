TEST_F(BrotliDecompressorImplTest, CompressDecompressOfMultipleSlices) {
  Buffer::OwnedImpl buffer;
  Buffer::OwnedImpl accumulation_buffer;

  const std::string sample{"slice, slice, slice, slice, slice, "};
  std::string original_text;
  for (uint64_t i = 0; i < 20; ++i) {
    Buffer::BufferFragmentImpl* frag = new Buffer::BufferFragmentImpl(
        sample.c_str(), sample.size(),
        [](const void*, size_t, const Buffer::BufferFragmentImpl* frag) { delete frag; });

    buffer.addBufferFragment(*frag);
    original_text.append(sample);
  }

  const uint64_t num_slices = buffer.getRawSlices().size();
  EXPECT_EQ(num_slices, 20);

  Brotli::Compressor::BrotliCompressorImpl compressor{
      default_quality,
      default_window_bits,
      default_input_block_bits,
      false,
      Brotli::Compressor::BrotliCompressorImpl::EncoderMode::Default,
      4096};

  compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);
  accumulation_buffer.add(buffer);

  Stats::IsolatedStoreImpl stats_store{};
  BrotliDecompressorImpl decompressor{stats_store, "test.", 16, false};

  drainBuffer(buffer);
  ASSERT_EQ(0, buffer.length());

  decompressor.decompress(accumulation_buffer, buffer);
  std::string decompressed_text{buffer.toString()};

  ASSERT_EQ(original_text.length(), decompressed_text.length());
  EXPECT_EQ(original_text, decompressed_text);
  EXPECT_EQ(0, stats_store.counterFromString("test.brotli_error").value());
}
