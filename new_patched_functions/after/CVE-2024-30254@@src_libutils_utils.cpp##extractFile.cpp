bool extractFile(const std::filesystem::path &archivePath,
                 const std::filesystem::path &outputDirectory) {
  LOG.info(std::format("Extracting {} to {}", archivePath.generic_string(),
                       outputDirectory.generic_string()));
  auto *archive = archive_read_new();
  archive_read_support_format_all(archive);
  archive_read_support_filter_all(archive);
  auto *ext = archive_write_disk_new();
  archive_write_disk_set_options(
      ext, ARCHIVE_EXTRACT_TIME | ARCHIVE_EXTRACT_PERM | ARCHIVE_EXTRACT_ACL |
               ARCHIVE_EXTRACT_FFLAGS | ARCHIVE_EXTRACT_SECURE_NODOTDOT |
               ARCHIVE_EXTRACT_SECURE_SYMLINKS);
  archive_write_disk_set_standard_lookup(ext);

  const auto *filename = archivePath.c_str();

  if (auto res =
          archive_read_open_filename(archive, filename, LIBARCHIVE_BLOCKSIZE)) {
    LOG.error(std::format("Unable to open archive: {} {}", res,
                          archive_error_string(archive)));
    return false;
  }

  for (;;) {
    auto *entry = static_cast<struct archive_entry *>(nullptr);
    auto res = archive_read_next_header(archive, &entry);
    if (res == ARCHIVE_EOF) {
      break;
    }
    if (res < ARCHIVE_OK) {
      LOG.error(std::format("Error during reading archive: {}",
                            archive_error_string(archive)));
      goto cleanup;
    }
    std::string entryPathname = archive_entry_pathname(entry);
    if (entryPathname.contains("..")) {
      LOG.warn(std::format(
          "Attempted directory traversal with this entry: {}, ignoring it",
          entryPathname));
      continue;
    }
    auto entryPath = outputDirectory / entryPathname;
    archive_entry_set_pathname_utf8(entry, entryPath.string().c_str());

    const auto *originalHardlink = archive_entry_hardlink(entry);
    if (originalHardlink != nullptr) {
      auto newHardlink = outputDirectory / originalHardlink;
#ifdef _WIN32
      const wchar_t *newHardLinkW = newHardlink.c_str();
      char *data = (char *)calloc(newHardlink.generic_string().size() * 2, 1);
      // Should be use wcstombs_s?
      wcstombs(data, newHardLinkW, newHardlink.generic_string().size() * 2);
      archive_entry_set_hardlink(entry, data);
      free(data);
#else
      archive_entry_set_hardlink(entry, newHardlink.c_str());
#endif
    }

    if (res = archive_write_header(ext, entry); res < ARCHIVE_OK) {
      LOG.error(
          std::format("Failed writing header: {}", archive_error_string(ext)));
      goto cleanup;
    }
    if (archive_entry_size(entry) > 0) {
      auto copyResult = copyData(archive, ext);
      if (copyResult != ARCHIVE_OK && copyResult != ARCHIVE_EOF) {
        LOG.error(std::format("Failed writing result: {}",
                              archive_error_string(ext)));
        goto cleanup;
      }
    }

    if (res = archive_write_finish_entry(ext); res < ARCHIVE_OK) {
      LOG.error(
          std::format("Failed finishing entry: {}", archive_error_string(ext)));
      goto cleanup;
    }
  }

  archive_read_close(archive);
  archive_read_free(archive);
  archive_write_close(ext);
  archive_write_free(ext);
  return true;

cleanup:
  archive_read_close(archive);
  archive_read_free(archive);
  archive_write_close(ext);
  archive_write_free(ext);
  return false;
}
