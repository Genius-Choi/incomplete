static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)
{
	unsigned rlvlno;
	int v;

	if (jpc_dec_decodecblks(dec, tile)) {
		jas_logerrorf("jpc_dec_decodecblks failed\n");
		return -1;
	}

	/* Perform dequantization. */
	unsigned compno;
	const jpc_dec_tcomp_t *tcomp;
	for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;
	  ++compno, ++tcomp) {
		const jpc_dec_ccp_t *ccp = &tile->cp->ccps[compno];
		const jpc_dec_rlvl_t *rlvl;
		for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;
		  ++rlvlno, ++rlvl) {
			if (!rlvl->bands) {
				continue;
			}
			unsigned bandno;
			const jpc_dec_band_t *band;
			for (bandno = 0, band = rlvl->bands;
			  bandno < rlvl->numbands; ++bandno, ++band) {
				if (!band->data) {
					continue;
				}
				jpc_undo_roi(band->data, band->roishift, ccp->roishift -
				  band->roishift, band->numbps);
				if (ccp->qmfbid == JPC_COX_INS) {
					jas_matrix_asl(band->data, JPC_FIX_FRACBITS);
					jpc_dequantize(band->data, band->absstepsize);
				}

			}
		}
	}

	/* Apply an inverse wavelet transform if necessary. */
	for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;
	  ++compno, ++tcomp) {
		jpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);
	}


	/* Apply an inverse intercomponent transform if necessary. */
	switch (tile->cp->mctid) {
	case JPC_MCT_RCT:
		if (dec->numcomps < 3) {
			jas_logerrorf("RCT requires at least three components\n");
			return -1;
		}
		if (!jas_image_cmpt_domains_same(dec->image)) {
			jas_logerrorf("RCT requires all components have the same domain\n");
			return -1;
		}
		jpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,
		  tile->tcomps[2].data);
		break;
	case JPC_MCT_ICT:
		if (dec->numcomps < 3) {
			jas_logerrorf("ICT requires at least three components\n");
			return -1;
		}
		if (!jas_image_cmpt_domains_same(dec->image)) {
			jas_logerrorf("RCT requires all components have the same domain\n");
			return -1;
		}
		jpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,
		  tile->tcomps[2].data);
		break;
	}

	/* Perform rounding and convert to integer values. */
	for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;
		  ++compno, ++tcomp) {
		const jpc_dec_ccp_t *ccp = &tile->cp->ccps[compno];
		if (ccp->qmfbid == JPC_COX_INS) {
			jas_matrix_t *const data = tcomp->data;
			const jas_matind_t height = jas_matrix_numrows(data);
			const jas_matind_t numcols = jas_matrix_numcols(data);
			for (jas_matind_t i = 0; i < height; ++i) {
				jpc_fix_t *p = jas_matrix_getref(data, i, 0);
				for (jas_matind_t j = 0; j < numcols; ++j) {
					v = p[j];
					v = jpc_fix_round(v);
					p[j] = jpc_fixtoint(v);
				}
			}
		}
	}

	/* Perform level shift. */
	const jpc_dec_cmpt_t *cmpt;
	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
		if (cmpt->sgnd)
			continue;

		jas_matrix_t *const data = tcomp->data;
		const jas_matind_t width = jas_matrix_numcols(data);
		const jas_matind_t height = jas_matrix_numrows(data);
		const jas_seqent_t adjust = (jas_seqent_t)1 << (cmpt->prec - 1);
		for (jas_matind_t i = 0; i < height; ++i) {
			jpc_fix_t *p = jas_matrix_getref(data, i, 0);
			for (jas_matind_t j = 0; j < width; ++j) {
				p[j] += adjust;
			}
		}
	}

	/* Perform clipping. */
	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
		if (cmpt->prec >= sizeof(jpc_fix_t) * 8 - 2 + cmpt->sgnd)
			/* no need to clip, because the calculated
			   minimum/maximum values would overflow our
			   integer type anyway */
			continue;

		const jas_seqent_t mn = cmpt->sgnd
			? (-((jpc_fix_t)1 << (cmpt->prec - 1)))
			: (0);
		const jas_seqent_t mx = cmpt->sgnd
			? (((jpc_fix_t)1 << (cmpt->prec - 1)) - 1)
			: (((jpc_fix_t)1 << cmpt->prec) - 1);
		jas_matrix_clip(tcomp->data, mn, mx);
	}

	/* XXX need to free tsfb struct */

	/* Write the data for each component of the image. */
	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
		if (jas_image_writecmpt(dec->image, compno, tcomp->xstart -
		  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -
		  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(
		  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {
			jas_logerrorf("write component failed\n");
			return -1;
		}
	}

	return 0;
}
