void send_mountsources(int sockfd, pid_t child, char *mountsources, size_t mountsources_len)
{
	char proc_path[PATH_MAX];
	int host_mntns_fd;
	int container_mntns_fd;
	int fd;
	int ret;

	// container_linux.go shouldSendMountSources() decides if mount sources
	// should be pre-opened (O_PATH) and passed via SCM_RIGHTS
	if (mountsources == NULL)
		return;

	host_mntns_fd = open("/proc/self/ns/mnt", O_RDONLY | O_CLOEXEC);
	if (host_mntns_fd == -1)
		bail("failed to get current mount namespace");

	if (snprintf(proc_path, PATH_MAX, "/proc/%d/ns/mnt", child) < 0)
		bail("failed to get mount namespace path");

	container_mntns_fd = open(proc_path, O_RDONLY | O_CLOEXEC);
	if (container_mntns_fd == -1)
		bail("failed to get container mount namespace");

	if (setns(container_mntns_fd, CLONE_NEWNS) < 0)
		bail("failed to setns to container mntns");

	char *mountsources_end = mountsources + mountsources_len;
	while (mountsources < mountsources_end) {
		if (mountsources[0] == '\0') {
			mountsources++;
			continue;
		}

		fd = open(mountsources, O_PATH | O_CLOEXEC);
		if (fd < 0)
			bail("failed to open mount source %s", mountsources);

		send_fd(sockfd, fd);

		ret = close(fd);
		if (ret != 0)
			bail("failed to close mount source fd %d", fd);

		mountsources += strlen(mountsources) + 1;
	}

	if (setns(host_mntns_fd, CLONE_NEWNS) < 0)
		bail("failed to setns to host mntns");

	ret = close(host_mntns_fd);
	if (ret != 0)
		bail("failed to close host mount namespace fd %d", host_mntns_fd);
	ret = close(container_mntns_fd);
	if (ret != 0)
		bail("failed to close container mount namespace fd %d", container_mntns_fd);
}
