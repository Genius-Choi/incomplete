extract_one_file(EpubDocument* epub_document, GFile *tmp_gfile, GError ** error)
{
    GFile * outfile ;
    gsize writesize = 0;
    GString * gfilepath ;
    unz_file_info64 info ;
    gchar* directory;
    GString* dir_create;
    GFileOutputStream * outstream ;

    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )
    {
            return FALSE ;
    }

    gboolean result = TRUE;

    gpointer currentfilename = g_malloc0(512);
    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;
    directory = g_strrstr(currentfilename,"/") ;

    if ( directory != NULL )
        directory++;

    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;
    g_string_append_printf(gfilepath,"/%s",(gchar*)currentfilename);

    outfile = g_file_new_for_path (gfilepath->str);
    g_autofree gchar *rpath = g_file_get_relative_path (tmp_gfile, outfile);

    if (rpath == NULL)
    {
        g_set_error_literal (error,
                             EV_DOCUMENT_ERROR,
                             EV_DOCUMENT_ERROR_INVALID,
                             _("epub file is invalid or corrupt"));
        g_critical ("Invalid filename in Epub container - '%s'", (gchar *) currentfilename);
        result = FALSE;
        goto out;
    }

    /*if we encounter a directory, make a directory inside our temporary folder.*/
    if (directory != NULL && *directory == '\0')
    {
        g_mkdir(gfilepath->str,0777);
        goto out;
    }
    else if (directory != NULL && *directory != '\0' ) {
        gchar* createdir = currentfilename;
        /*Since a substring can't be longer than the parent string, allocating space equal to the parent's size should suffice*/
        gchar *createdirname = g_malloc0(strlen(currentfilename));
        /* Add the name of the directory and subdirectories,if any to a buffer and then create it */
        gchar *createdirnametemp = createdirname;
        while ( createdir != directory ) {
            (*createdirnametemp) = (*createdir);
            createdirnametemp++;
            createdir++;
        }
        (*createdirnametemp) = '\0';

        dir_create = g_string_new(epub_document->tmp_archive_dir);
        g_string_append_printf(dir_create,"/%s",createdirname);
        g_free(createdirname);

        g_mkdir_with_parents(dir_create->str,0777);
        g_string_free(dir_create,TRUE);
    }

    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);
    gpointer buffer = g_malloc0(512);
    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )
    {
        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )
        {
            result = FALSE;
            break;
        }
    }
    g_free(buffer);
    g_output_stream_close((GOutputStream*)outstream,NULL,error);
    g_object_unref(outstream);

out:
    g_object_unref(outfile);
    unzCloseCurrentFile (epub_document->epubDocument) ;
    g_string_free(gfilepath,TRUE);
    g_free(currentfilename);
    return result;
}
