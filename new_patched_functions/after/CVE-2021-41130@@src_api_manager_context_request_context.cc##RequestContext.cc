RequestContext::RequestContext(std::shared_ptr<ServiceContext> service_context,
                               std::unique_ptr<Request> request)
    : service_context_(service_context),
      request_(std::move(request)),
      is_first_report_(true),
      last_request_bytes_(0),
      last_response_bytes_(0),
      api_key_from_query_(false) {
  start_time_ = std::chrono::system_clock::now();
  last_report_time_ = std::chrono::steady_clock::now();
  operation_id_ = GenerateUUID();
  const std::string &method = GetRequestHTTPMethodWithOverride();
  const std::string &path = request_->GetUnparsedRequestPath();
  std::string query_params = request_->GetQueryParameters();

  // In addition to matching the method, service_context_->GetMethodCallInfo()
  // will extract the variable bindings from the url. We need variable bindings
  // only when we need to do transcoding. If this turns out to be a performance
  // problem for non-transcoded calls, we have a couple of options:
  // 1) Do not extract variable bindings here, and do the method matching again
  //    with extracting variable bindings when transcoding is needed.
  // 2) Store all the pieces needed for extracting variable bindings (such as
  //    http template variables, url path parts) in MethodCallInfo and extract
  //    variables lazily when needed.

  method_call_ =
      service_context_->GetMethodCallInfo(method, path, query_params);

  if (method_call_.method_info &&
      !method_call_.method_info->allow_unregistered_calls()) {
    ExtractApiKey();
  }
  request_->FindHeader("referer", &http_referer_);

  // Enable trace if tracing is not force disabled and the triggering header is
  // set.
  if (service_context_->cloud_trace_aggregator()) {
    std::string trace_context_header;
    // Default to CLOUD_TRACE_CONTEXT to not change the default behavior.
    HeaderType header_type = HeaderType::CLOUD_TRACE_CONTEXT;
    if (request_->FindHeader(kGRpcTraceContextHeader, &trace_context_header)) {
      // gRPC trace header found, the type of the header should be
      // GRPC_TRACE_CONTEXT
      header_type = HeaderType::GRPC_TRACE_CONTEXT;
    } else {
      request_->FindHeader(kCloudTraceContextHeader, &trace_context_header);
    }

    std::string method_name = kUnrecognizedOperation;
    if (method_call_.method_info) {
      method_name = method_call_.method_info->selector();
    }
    // qualify with the service name
    method_name = service_context_->service_name() + "/" + method_name;
    cloud_trace_.reset(cloud_trace::CreateCloudTrace(
        trace_context_header, method_name, header_type,
        &service_context_->cloud_trace_aggregator()->sampler()));
  }
}
