bool sign_aes(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, size_t _signerIndex,
              char *_sig) {

    auto keyStr = make_shared<string>(_encryptedKeyHex);

    auto hash = make_shared<array<uint8_t, 32>>();

    uint64_t binLen;

    if (!hex2carray(_hashHex, &binLen, hash->data())) {
        throw SGXException(INVALID_HEX, "Invalid hash");
    }



//  auto keyShare = make_shared<BLSPrivateKeyShareSGX>(keyStr, _t, _n);
//
//  auto sigShare = keyShare->signWithHelperSGX(hash, _signerIndex);
//
//  auto sigShareStr = sigShare->toString();
//
//  strncpy(_sig, sigShareStr->c_str(), BUF_LEN);
    shared_ptr<signatures::Bls> obj;
    obj = make_shared<signatures::Bls>(signatures::Bls(_t, _n));

    std::pair<libff::alt_bn128_G1, std::string> hash_with_hint =
            obj->HashtoG1withHint(hash);

    int errStatus = 0;


    string *xStr = FqToString(&(hash_with_hint.first.X));

    if (xStr == nullptr) {
        std::cerr << "Null xStr" << std::endl;
        BOOST_THROW_EXCEPTION(runtime_error("Null xStr"));
    }

    string *yStr = FqToString(&(hash_with_hint.first.Y));

    if (yStr == nullptr) {
        std::cerr << "Null yStr" << std::endl;
        BOOST_THROW_EXCEPTION(runtime_error("Null yStr"));
    }


    char errMsg[BUF_LEN];
    memset(errMsg, 0, BUF_LEN);

    char xStrArg[BUF_LEN];
    char yStrArg[BUF_LEN];
    char signature[BUF_LEN];

    memset(xStrArg, 0, BUF_LEN);
    memset(yStrArg, 0, BUF_LEN);

    strncpy(xStrArg, xStr->c_str(), BUF_LEN);
    strncpy(yStrArg, yStr->c_str(), BUF_LEN);

    size_t sz = 0;


    uint8_t encryptedKey[BUF_LEN];

    bool result = hex2carray(_encryptedKeyHex, &sz, encryptedKey);

    if (!result) {
        cerr << "Invalid hex encrypted key" << endl;
        BOOST_THROW_EXCEPTION(std::invalid_argument("Invalid hex encrypted key"));
    }

    sgx_status_t status =
            trustedBlsSignMessageAES(eid, &errStatus, errMsg, encryptedKey,
                                 sz, xStrArg, yStrArg, signature);


    if (status != SGX_SUCCESS) {
        cerr << "SGX enclave call  to trustedBlsSignMessage failed:" << status << std::endl;
        BOOST_THROW_EXCEPTION(runtime_error("SGX enclave call  to trustedBlsSignMessage failed"));
    }


    std::string hint = BLSutils::ConvertToString(hash_with_hint.first.Y) + ":" +
                       hash_with_hint.second;


    std::string sig = signature;

    sig.append(":");
    sig.append(hint);

    strncpy(_sig, sig.c_str(), BUF_LEN);

    printf("_sig is: %s\n", sig.c_str());

    //string sigShareStr = keyShare->signWithHelperSGXstr(hash, _signerIndex);
    //strncpy(_sig, sigShareStr.c_str(), BUF_LEN);

    // string test_sig = "8175162913343900215959836578795929492705714455632345516427532159927644835012:15265825550804683171644566522808807137117748565649051208189914766494241035855:9810286616503120081238481858289626967170509983220853777870754480048381194141:5";
    // auto sig_ptr = make_shared<string>(test_sig);
    // strncpy(_sig, sig_ptr->c_str(), BUF_LEN);

    return true;
}
