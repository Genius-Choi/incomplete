static int customRsaPrivEnc(
    int flen,
    const unsigned char* from,
    unsigned char* to,
    RSA* rsa,
    int padding) {
  LOG(INFO) << "rsa_priv_enc";
  EventBase* asyncJobEvb =
      reinterpret_cast<EventBase*>(RSA_get_ex_data(rsa, kRSAEvbExIndex));
  CHECK(asyncJobEvb);

  RSA* actualRSA = reinterpret_cast<RSA*>(RSA_get_ex_data(rsa, kRSAExIndex));
  CHECK(actualRSA);

  AsyncSSLSocket* socket = reinterpret_cast<AsyncSSLSocket*>(
      RSA_get_ex_data(rsa, kRSASocketExIndex));

  ASYNC_JOB* job = ASYNC_get_current_job();
  if (job == nullptr) {
    throw std::runtime_error("Expected call in job context");
  }
  ASYNC_WAIT_CTX* waitctx = ASYNC_get_wait_ctx(job);
  OSSL_ASYNC_FD pipefds[2] = {0, 0};
  makeNonBlockingPipe(pipefds);
  if (!ASYNC_WAIT_CTX_set_wait_fd(
          waitctx, kEngineId.data(), pipefds[0], nullptr, nullptr)) {
    throw std::runtime_error("Cannot set wait fd");
  }
  int ret = 0;
  int* retptr = &ret;

  auto hand = folly::NetworkSocket::native_handle_type(pipefds[1]);
  auto asyncPipeWriter = folly::AsyncPipeWriter::newWriter(
      asyncJobEvb, folly::NetworkSocket(hand));

  asyncJobEvb->runInEventBaseThread([retptr = retptr,
                                     flen = flen,
                                     from = from,
                                     to = to,
                                     padding = padding,
                                     actualRSA = actualRSA,
                                     writer = std::move(asyncPipeWriter),
                                     socket = socket]() {
    LOG(INFO) << "Running job";
    if (socket) {
      LOG(INFO) << "Got a socket passed in, closing it...";
      socket->closeNow();
    }
    *retptr = RSA_meth_get_priv_enc(RSA_PKCS1_OpenSSL())(
        flen, from, to, actualRSA, padding);
    LOG(INFO) << "Finished job, writing to pipe";
    uint8_t byte = *retptr > 0 ? 1 : 0;
    writer->write(nullptr, &byte, 1);
  });

  LOG(INFO) << "About to pause job";

  ASYNC_pause_job();
  LOG(INFO) << "Resumed job with ret: " << ret;
  return ret;
}
