static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,
	RBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {
	int i = 0;
	size_t count;
	const ut8 *tmp_buf = NULL;
	char *fn = NULL;

	if (mode == R_MODE_PRINT) {
		print (" The Directory Table:\n");
	}
	while (buf + 1 < buf_end) {
		size_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);
		size_t len = r_str_nlen ((const char *)buf, maxlen);
		char *str = r_str_ndup ((const char *)buf, len);
		if (len < 1 || len >= 0xfff || !str) {
			buf += 1;
			free (str);
			break;
		}
		if (mode == R_MODE_PRINT) {
			print ("  %d     %s\n", i + 1, str);
		}
		add_sdb_include_dir (sdb, str, i);
		free (str);
		i++;
		buf += len + 1;
	}

	tmp_buf = buf;
	count = 0;
	if (mode == R_MODE_PRINT) {
		print ("\n");
		print (" The File Name Table:\n");
		print ("  Entry Dir     Time      Size       Name\n");
	}
	int entry_index = 1; // used for printing information

	for (i = 0; i < 2; i++) {
		while (buf + 1 < buf_end) {
			size_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);
			ut64 id_idx, mod_time, file_len;
			free (fn);
			fn = r_str_ndup ((const char *)buf, maxlen);
			r_str_ansi_strip (fn);
			size_t len = strlen (fn);

			if (!len) {
				buf++;
				break;
			}
			buf += len + 1;
			if (buf >= buf_end) {
				buf = NULL;
				goto beach;
			}
			buf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);
			if (buf >= buf_end) {
				buf = NULL;
				goto beach;
			}
			buf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);
			if (buf >= buf_end) {
				buf = NULL;
				goto beach;
			}
			buf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);
			if (buf >= buf_end) {
				buf = NULL;
				goto beach;
			}

			if (i) {
				char *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;
				if (id_idx > 0) {
					include_dir = pinclude_dir = sdb_array_get (sdb, "includedirs", id_idx - 1, 0);
					if (include_dir && include_dir[0] != '/') {
						comp_dir = sdb_get (bf->sdb_addrinfo, "DW_AT_comp_dir", 0);
						if (comp_dir) {
							include_dir = r_str_newf ("%s/%s/", comp_dir, include_dir);
						}
					}
				} else {
					include_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, "DW_AT_comp_dir", 0);
					if (!include_dir) {
						include_dir = "./";
					}
				}

				if (hdr->file_names) {
					hdr->file_names[count].name = r_str_newf("%s/%s", r_str_get (include_dir), fn);
					hdr->file_names[count].id_idx = id_idx;
					hdr->file_names[count].mod_time = mod_time;
					hdr->file_names[count].file_len = file_len;
				}
				if (comp_dir) {
					R_FREE (include_dir);
					R_FREE (comp_dir);
				}
				R_FREE (pinclude_dir);
			}
			count++;
			if (mode == R_MODE_PRINT && i) {
				print ("  %d     %" PFMT64d "       %" PFMT64d "         %" PFMT64d "          %s\n",
						entry_index++, id_idx, mod_time, file_len, fn);
			}
		}
		if (i == 0) {
			if (count > 0) {
				hdr->file_names = calloc (sizeof (file_entry), count);
			} else {
				hdr->file_names = NULL;
			}
			hdr->file_names_count = count;
			buf = tmp_buf;
			count = 0;
		}
	}
	if (mode == R_MODE_PRINT) {
		print ("\n");
	}

beach:
	free (fn);
	sdb_free (sdb);

	return buf;
}
