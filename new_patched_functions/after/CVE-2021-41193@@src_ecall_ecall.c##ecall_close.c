void ecall_close(struct ecall *ecall, int err, uint32_t msg_time)
{
	icall_close_h *closeh;
	struct iflow *flow;

	if (!ecall)
		return;
	
	ecall->icall.qualityh = NULL;
	tmr_cancel(&ecall->quality.tmr);
	tmr_cancel(&ecall->dc_tmr);
	tmr_cancel(&ecall->media_start_tmr);
	tmr_cancel(&ecall->connection_tmr);

	closeh = ecall->icall.closeh;

	if (err) {
		info("ecall(%p): closed (%m)\n", ecall, err);
	}
	else {
		info("ecall(%p): closed (normal)\n", ecall);
	}

	char *json_str = NULL;

	/* Keep flow reference, but indicate that it's gone */
	flow = ecall->flow;
	ecall->flow = NULL;
	ecall->conf_part = mem_deref(ecall->conf_part);
	IFLOW_CALL(flow, close);

	flow = ecall->oldflow;
	ecall->oldflow = NULL;
	IFLOW_CALL(flow, close);

	/* NOTE: calling the callback handlers MUST be done last,
	 *       to make sure that all states are correct.
	 */
	if (ecall->video.recv_state != ICALL_VIDEO_STATE_STOPPED) {
		ICALL_CALL_CB(ecall->icall, vstate_changedh,
			&ecall->icall, ecall->userid_peer, ecall->clientid_peer,
			ICALL_VIDEO_STATE_STOPPED, ecall->icall.arg);
		ecall->video.recv_state = ICALL_VIDEO_STATE_STOPPED;
	}

	if (closeh) {
		ecall->icall.closeh = NULL;
		closeh(&ecall->icall, err, json_str, msg_time,
			ecall->userid_peer, ecall->clientid_peer, ecall->icall.arg);
	}

	/* NOTE here the app should have destroyed the econn */
}
