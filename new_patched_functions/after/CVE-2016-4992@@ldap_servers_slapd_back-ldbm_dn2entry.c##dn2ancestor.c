dn2ancestor(
    Slapi_Backend *be,
    const Slapi_DN	*sdn,
    Slapi_DN *ancestordn,
    back_txn		*txn,
    int			*err,
    int allow_suffix
)
{
    struct backentry *e = NULL;

    LDAPDebug( LDAP_DEBUG_TRACE, "=> dn2ancestor \"%s\"\n", slapi_sdn_get_dn(sdn), 0, 0 );

    /* first, check to see if the given sdn is empty or a root suffix of the
       given backend - if so, it has no parent */
    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {
        Slapi_DN ancestorndn;
        const char *ptr;

        /* assign ancestordn to the parent of the given dn */
        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));
        /* assign the ancestordn dn pointer to the parent of dn from sdn - sdn "owns"
           the memory, but ancestordn points to it */
        slapi_sdn_set_normdn_byref(ancestordn, ptr); /* free any previous contents */
        /* now, do the same for the normalized version */
        /* ancestorndn holds the normalized version for iteration purposes and
           because dn2entry needs the normalized dn */
        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));
        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);

        /*
          At this point you may be wondering why I need both ancestorndn and
          ancestordn.  Because, with the slapi_sdn interface, you cannot set both
          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,
          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I
          could have added another API to allow you to pass them both in.  Also, using
          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then
          normalizing the copy every time - not efficient.
          So, why not just use a char* for the ancestorndn?  Because dn2entry requires
          a Slapi_DN with the normalized dn.
        */

        /* stop when we get to "", or a backend suffix point */
        while (!e && !slapi_sdn_isempty(&ancestorndn)) {
            if (!allow_suffix) {
                /* Original behavior. */
                if (slapi_be_issuffix(be, &ancestorndn)) {
                    break;
                }
            }
            /* find the entry - it uses the ndn, so no further conversion is necessary */
            e= dn2entry(be,&ancestorndn,txn,err);
            if (!e) {
                /* not found, so set ancestordn to its parent and try again */
                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));
                /* keep in mind that ptr points to the raw ndn pointer inside
                   ancestorndn which is still the ndn string "owned" by sdn, the
                   original dn we started with - we are careful not to touch
                   or change it */
                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); /* wipe out the previous contents */
                /* now do the same for the unnormalized one */
                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));
                slapi_sdn_set_normdn_byref(ancestordn, ptr); /* wipe out the previous contents */
            }
        }

        slapi_sdn_done(&ancestorndn);
    }

    /* post conditions:
       e is the entry of the ancestor of sdn OR e is the suffix entry
       OR e is NULL
       ancestordn contains the unnormalized DN of e or is empty */
    LDAPDebug( LDAP_DEBUG_TRACE, "<= dn2ancestor %p\n", e, 0, 0 );
    return( e );
}
