enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,
				       bgp_size_t size,
				       struct bgp_nlri *mp_update,
				       struct bgp_nlri *mp_withdraw)
{
	enum bgp_attr_parse_ret ret;
	uint8_t flag = 0;
	uint8_t type = 0;
	bgp_size_t length = 0;
	uint8_t *startp, *endp;
	uint8_t *attr_endp;
	uint8_t seen[BGP_ATTR_BITMAP_SIZE];
	/* we need the as4_path only until we have synthesized the as_path with
	 * it */
	/* same goes for as4_aggregator */
	struct aspath *as4_path = NULL;
	as_t as4_aggregator = 0;
	struct in_addr as4_aggregator_addr = {.s_addr = 0};
	struct transit *transit;

	/* Initialize bitmap. */
	memset(seen, 0, BGP_ATTR_BITMAP_SIZE);

	/* End pointer of BGP attribute. */
	endp = BGP_INPUT_PNT(peer) + size;

	/* Get attributes to the end of attribute length. */
	while (BGP_INPUT_PNT(peer) < endp) {
		startp = BGP_INPUT_PNT(peer);

		/* Fewer than three octets remain (or fewer than four
		 * octets, if the Attribute Flags field has the Extended
		 * Length bit set) when beginning to parse the attribute.
		 * That is, this case exists if there remains unconsumed
		 * data in the path attributes but yet insufficient data
		 * to encode a single minimum-sized path attribute.
		 *
		 * An error condition exists and the "treat-as-withdraw"
		 * approach MUST be used (unless some other, more severe
		 * error is encountered dictating a stronger approach),
		 * and the Total Attribute Length MUST be relied upon to
		 * enable the beginning of the NLRI field to be located.
		 */

		/* Check remaining length check.*/
		if ((endp - startp) < BGP_ATTR_MIN_LEN) {
			/* XXX warning: long int format, int arg (arg 5) */
			flog_warn(
				EC_BGP_ATTRIBUTE_TOO_SMALL,
				"%s: error BGP attribute length %lu is smaller than min len",
				peer->host,
				(unsigned long)(endp
						- stream_pnt(BGP_INPUT(peer))));

			if (peer->sort != BGP_PEER_EBGP) {
				bgp_notify_send(peer->connection,
						BGP_NOTIFY_UPDATE_ERR,
						BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
				ret = BGP_ATTR_PARSE_ERROR;
			} else {
				ret = BGP_ATTR_PARSE_WITHDRAW;
			}

			goto done;
		}

		/* Fetch attribute flag and type.
		 * The lower-order four bits of the Attribute Flags octet are
		 * unused. They MUST be zero when sent and MUST be ignored when
		 * received.
		 */
		flag = 0xF0 & stream_getc(BGP_INPUT(peer));
		type = stream_getc(BGP_INPUT(peer));

		/* Check whether Extended-Length applies and is in bounds */
		if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)
		    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {
			flog_warn(
				EC_BGP_EXT_ATTRIBUTE_TOO_SMALL,
				"%s: Extended length set, but just %lu bytes of attr header",
				peer->host,
				(unsigned long)(endp
						- stream_pnt(BGP_INPUT(peer))));

			if (peer->sort != BGP_PEER_EBGP) {
				bgp_notify_send(peer->connection,
						BGP_NOTIFY_UPDATE_ERR,
						BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
				ret = BGP_ATTR_PARSE_ERROR;
			} else {
				ret = BGP_ATTR_PARSE_WITHDRAW;
			}

			goto done;
		}

		/* Check extended attribue length bit. */
		if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))
			length = stream_getw(BGP_INPUT(peer));
		else
			length = stream_getc(BGP_INPUT(peer));

		/* Overflow check. */
		attr_endp = BGP_INPUT_PNT(peer) + length;

		if (attr_endp > endp) {
			flog_warn(
				EC_BGP_ATTRIBUTE_TOO_LARGE,
				"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p",
				peer->host, type, length, size, attr_endp,
				endp);

			/* Only relax error handling for eBGP peers */
			if (peer->sort != BGP_PEER_EBGP) {
				/*
				 * RFC 4271 6.3
				 * If any recognized attribute has an Attribute
				 * Length that conflicts with the expected length
				 * (based on the attribute type code), then the
				 * Error Subcode MUST be set to Attribute Length
				 * Error.  The Data field MUST contain the erroneous
				 * attribute (type, length, and value).
				 * ----------
				 * We do not currently have a good way to determine the
				 * length of the attribute independent of the length
				 * received in the message. Instead we send the
				 * minimum between the amount of data we have and the
				 * amount specified by the attribute length field.
				 *
				 * Instead of directly passing in the packet buffer and
				 * offset we use the stream_get* functions to read into
				 * a stack buffer, since they perform bounds checking
				 * and we are working with untrusted data.
				 */
				unsigned char ndata[peer->max_packet_size];

				memset(ndata, 0x00, sizeof(ndata));
				size_t lfl =
					CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;
				/* Rewind to end of flag field */
				stream_rewind_getp(BGP_INPUT(peer), (1 + lfl));
				/* Type */
				stream_get(&ndata[0], BGP_INPUT(peer), 1);
				/* Length */
				stream_get(&ndata[1], BGP_INPUT(peer), lfl);
				/* Value */
				size_t atl = attr_endp - startp;
				size_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));

				stream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);

				bgp_notify_send_with_data(peer->connection,
							  BGP_NOTIFY_UPDATE_ERR,
							  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
							  ndata, ndl + lfl + 1);

				ret = BGP_ATTR_PARSE_ERROR;
				goto done;
			} else {
				/* Handling as per RFC7606 section 4, treat-as-withdraw approach
				 * must be followed when the total attribute length is in conflict
				 * with the enclosed path attribute length.
				 */
				flog_warn(
					EC_BGP_ATTRIBUTE_PARSE_WITHDRAW,
					"%s: Attribute %s, parse error - treating as withdrawal",
					peer->host, lookup_msg(attr_str, type, NULL));
				ret = BGP_ATTR_PARSE_WITHDRAW;
				stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
				goto done;
			}
		}

		/* If attribute appears more than once in the UPDATE message,
		 * for MP_REACH_NLRI & MP_UNREACH_NLRI attributes
		 * the Error Subcode is set to Malformed Attribute List.
		 * For all other attributes, all the occurances of the attribute
		 * other than the first occurence is discarded. (RFC7606 3g)
		 */

		if (CHECK_BITMAP(seen, type)) {
			/* Only relax error handling for eBGP peers */
			if (peer->sort != BGP_PEER_EBGP ||
					type == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {
				flog_warn(
					EC_BGP_ATTRIBUTE_REPEATED,
					"%s: error BGP attribute type %d appears twice in a message",
					peer->host, type);

				bgp_notify_send(peer->connection,
						BGP_NOTIFY_UPDATE_ERR,
						BGP_NOTIFY_UPDATE_MAL_ATTR);
				ret = BGP_ATTR_PARSE_ERROR;
				goto done;
			} else {
				flog_warn(
					EC_BGP_ATTRIBUTE_REPEATED,
					"%s: error BGP attribute type %d appears twice in a message - discard attribute",
					peer->host, type);
				/* Adjust the stream getp to the end of the attribute, in case we
				 * haven't read all the attributes.
				 */
				stream_set_getp(BGP_INPUT(peer),
					(startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));
				continue;
			}
		}

		/* Set type to bitmap to check duplicate attribute.  `type' is
		   unsigned char so it never overflow bitmap range. */

		SET_BITMAP(seen, type);

		struct bgp_attr_parser_args attr_args = {
			.peer = peer,
			.length = length,
			.attr = attr,
			.type = type,
			.flags = flag,
			.startp = startp,
			.total = attr_endp - startp,
		};


		/* If any recognized attribute has Attribute Flags that conflict
		   with the Attribute Type Code, then the Error Subcode is set
		   to
		   Attribute Flags Error.  The Data field contains the erroneous
		   attribute (type, length and value). */
		if (bgp_attr_flag_invalid(&attr_args)) {
			ret = bgp_attr_malformed(
				&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
				attr_args.total);
			if (ret == BGP_ATTR_PARSE_PROCEED)
				continue;
			stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
			goto done;
		}

		/* OK check attribute and store it's value. */
		switch (type) {
		case BGP_ATTR_ORIGIN:
			ret = bgp_attr_origin(&attr_args);
			break;
		case BGP_ATTR_AS_PATH:
			ret = bgp_attr_aspath(&attr_args);
			break;
		case BGP_ATTR_AS4_PATH:
			ret = bgp_attr_as4_path(&attr_args, &as4_path);
			break;
		case BGP_ATTR_NEXT_HOP:
			ret = bgp_attr_nexthop(&attr_args);
			break;
		case BGP_ATTR_MULTI_EXIT_DISC:
			ret = bgp_attr_med(&attr_args);
			break;
		case BGP_ATTR_LOCAL_PREF:
			ret = bgp_attr_local_pref(&attr_args);
			break;
		case BGP_ATTR_ATOMIC_AGGREGATE:
			ret = bgp_attr_atomic(&attr_args);
			break;
		case BGP_ATTR_AGGREGATOR:
			ret = bgp_attr_aggregator(&attr_args);
			break;
		case BGP_ATTR_AS4_AGGREGATOR:
			ret = bgp_attr_as4_aggregator(&attr_args,
						      &as4_aggregator,
						      &as4_aggregator_addr);
			break;
		case BGP_ATTR_COMMUNITIES:
			ret = bgp_attr_community(&attr_args);
			break;
		case BGP_ATTR_LARGE_COMMUNITIES:
			ret = bgp_attr_large_community(&attr_args);
			break;
		case BGP_ATTR_ORIGINATOR_ID:
			ret = bgp_attr_originator_id(&attr_args);
			break;
		case BGP_ATTR_CLUSTER_LIST:
			ret = bgp_attr_cluster_list(&attr_args);
			break;
		case BGP_ATTR_MP_REACH_NLRI:
			ret = bgp_mp_reach_parse(&attr_args, mp_update);
			break;
		case BGP_ATTR_MP_UNREACH_NLRI:
			ret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);
			break;
		case BGP_ATTR_EXT_COMMUNITIES:
			ret = bgp_attr_ext_communities(&attr_args);
			break;
#ifdef ENABLE_BGP_VNC_ATTR
		case BGP_ATTR_VNC:
#endif
		case BGP_ATTR_ENCAP:
			ret = bgp_attr_encap(&attr_args);
			break;
		case BGP_ATTR_PREFIX_SID:
			ret = bgp_attr_prefix_sid(&attr_args);
			break;
		case BGP_ATTR_PMSI_TUNNEL:
			ret = bgp_attr_pmsi_tunnel(&attr_args);
			break;
		case BGP_ATTR_IPV6_EXT_COMMUNITIES:
			ret = bgp_attr_ipv6_ext_communities(&attr_args);
			break;
		case BGP_ATTR_OTC:
			ret = bgp_attr_otc(&attr_args);
			break;
		case BGP_ATTR_AIGP:
			ret = bgp_attr_aigp(&attr_args);
			break;
		default:
			ret = bgp_attr_unknown(&attr_args);
			break;
		}

		if (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {
			bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
					BGP_NOTIFY_UPDATE_MAL_ATTR);
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}

		if (ret == BGP_ATTR_PARSE_ERROR) {
			flog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,
				  "%s: Attribute %s, parse error", peer->host,
				  lookup_msg(attr_str, type, NULL));
			goto done;
		}
		if (ret == BGP_ATTR_PARSE_WITHDRAW) {
			flog_warn(
				EC_BGP_ATTRIBUTE_PARSE_WITHDRAW,
				"%s: Attribute %s, parse error - treating as withdrawal",
				peer->host, lookup_msg(attr_str, type, NULL));
			stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
			goto done;
		}

		/* Check the fetched length. */
		if (BGP_INPUT_PNT(peer) != attr_endp) {
			flog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,
				  "%s: BGP attribute %s, fetch error",
				  peer->host, lookup_msg(attr_str, type, NULL));
			bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
					BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}
	}

	/*
	 * draft-ietf-idr-bgp-prefix-sid-27#section-3:
	 * About Prefix-SID path attribute,
	 * Label-Index TLV(type1) and The Originator SRGB TLV(type-3)
	 * may only appear in a BGP Prefix-SID attribute attached to
	 * IPv4/IPv6 Labeled Unicast prefixes ([RFC8277]).
	 * It MUST be ignored when received for other BGP AFI/SAFI combinations.
	 */
	if (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)
		attr->label_index = BGP_INVALID_LABEL_INDEX;

	/* Check final read pointer is same as end pointer. */
	if (BGP_INPUT_PNT(peer) != endp) {
		flog_warn(EC_BGP_ATTRIBUTES_MISMATCH,
			  "%s: BGP attribute %s, length mismatch", peer->host,
			  lookup_msg(attr_str, type, NULL));
		bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);

		ret = BGP_ATTR_PARSE_ERROR;
		goto done;
	}

	/*
	 * RFC4271: If the NEXT_HOP attribute field is syntactically incorrect,
	 * then the Error Subcode MUST be set to Invalid NEXT_HOP Attribute.
	 * This is implemented below and will result in a NOTIFICATION. If the
	 * NEXT_HOP attribute is semantically incorrect, the error SHOULD be
	 * logged, and the route SHOULD be ignored. In this case, a NOTIFICATION
	 * message SHOULD NOT be sent. This is implemented elsewhere.
	 *
	 * RFC4760: An UPDATE message that carries no NLRI, other than the one
	 * encoded in the MP_REACH_NLRI attribute, SHOULD NOT carry the NEXT_HOP
	 * attribute. If such a message contains the NEXT_HOP attribute, the BGP
	 * speaker that receives the message SHOULD ignore this attribute.
	 */
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {
		if (bgp_attr_nexthop_valid(peer, attr) < 0) {
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}
	}

	/* Check all mandatory well-known attributes are present */
	ret = bgp_attr_check(peer, attr, length);
	if (ret < 0)
		goto done;

	/*
	 * At this place we can see whether we got AS4_PATH and/or
	 * AS4_AGGREGATOR from a 16Bit peer and act accordingly.
	 * We can not do this before we've read all attributes because
	 * the as4 handling does not say whether AS4_PATH has to be sent
	 * after AS_PATH or not - and when AS4_AGGREGATOR will be send
	 * in relationship to AGGREGATOR.
	 * So, to be defensive, we are not relying on any order and read
	 * all attributes first, including these 32bit ones, and now,
	 * afterwards, we look what and if something is to be done for as4.
	 *
	 * It is possible to not have AS_PATH, e.g. GR EoR and sole
	 * MP_UNREACH_NLRI.
	 */
	/* actually... this doesn't ever return failure currently, but
	 * better safe than sorry */
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))
	    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,
					&as4_aggregator_addr)) {
		bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,
				BGP_NOTIFY_UPDATE_MAL_ATTR);
		ret = BGP_ATTR_PARSE_ERROR;
		goto done;
	}

	/*
	 * Finally do the checks on the aspath we did not do yet
	 * because we waited for a potentially synthesized aspath.
	 */
	if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {
		ret = bgp_attr_aspath_check(peer, attr);
		if (ret != BGP_ATTR_PARSE_PROCEED)
			goto done;
	}

	ret = BGP_ATTR_PARSE_PROCEED;
done:

	/*
	 * At this stage, we have done all fiddling with as4, and the
	 * resulting info is in attr->aggregator resp. attr->aspath so
	 * we can chuck as4_aggregator and as4_path alltogether in order
	 * to save memory
	 */
	/*
	 * unintern - it is in the hash
	 * The flag that we got this is still there, but that
	 * does not do any trouble
	 */
	aspath_unintern(&as4_path);

	transit = bgp_attr_get_transit(attr);
	/* If we received an UPDATE with mandatory attributes, then
	 * the unrecognized transitive optional attribute of that
	 * path MUST be passed. Otherwise, it's an error, and from
	 * security perspective it might be very harmful if we continue
	 * here with the unrecognized attributes.
	 */
	if (ret == BGP_ATTR_PARSE_PROCEED) {
		/* Finally intern unknown attribute. */
		if (transit)
			bgp_attr_set_transit(attr, transit_intern(transit));
		if (attr->encap_subtlvs)
			attr->encap_subtlvs = encap_intern(attr->encap_subtlvs,
							   ENCAP_SUBTLV_TYPE);
#ifdef ENABLE_BGP_VNC
		struct bgp_attr_encap_subtlv *vnc_subtlvs =
			bgp_attr_get_vnc_subtlvs(attr);

		if (vnc_subtlvs)
			bgp_attr_set_vnc_subtlvs(
				attr,
				encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));
#endif
	} else {
		if (transit) {
			transit_free(transit);
			bgp_attr_set_transit(attr, NULL);
		}

		bgp_attr_flush_encap(attr);
	};

	/* Sanity checks */
	transit = bgp_attr_get_transit(attr);
	if (transit)
		assert(transit->refcnt > 0);
	if (attr->encap_subtlvs)
		assert(attr->encap_subtlvs->refcnt > 0);
#ifdef ENABLE_BGP_VNC
	struct bgp_attr_encap_subtlv *vnc_subtlvs =
		bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs)
		assert(vnc_subtlvs->refcnt > 0);
#endif

	return ret;
}
