  void initializeWithArgs(uint64_t max_hosts = 1024, uint32_t max_pending_requests = 1024,
                          const std::string& override_auto_sni_header = "",
                          const std::string& typed_dns_resolver_config = "",
                          bool use_sub_cluster = false) {
    const std::string filter_use_sub_cluster = R"EOF(
name: dynamic_forward_proxy
typed_config:
  "@type": type.googleapis.com/envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
  sub_cluster_config:
    cluster_init_timeout: 5s
)EOF";
    const std::string filter_use_dns_cache =
        fmt::format(R"EOF(
name: dynamic_forward_proxy
typed_config:
  "@type": type.googleapis.com/envoy.extensions.filters.http.dynamic_forward_proxy.v3.FilterConfig
  dns_cache_config:
    dns_min_refresh_rate: 1s
    name: foo
    dns_lookup_family: {}
    max_hosts: {}
    host_ttl: {}s
    dns_cache_circuit_breaker:
      max_pending_requests: {}{}{}
)EOF",
                    Network::Test::ipVersionToDnsFamily(GetParam()), max_hosts, host_ttl_,
                    max_pending_requests, key_value_config_, typed_dns_resolver_config);
    config_helper_.prependFilter(use_sub_cluster ? filter_use_sub_cluster : filter_use_dns_cache);

    config_helper_.prependFilter(fmt::format(R"EOF(
name: stream-info-to-headers-filter
)EOF"));
    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {
      // Switch predefined cluster_0 to CDS filesystem sourcing.
      bootstrap.mutable_dynamic_resources()->mutable_cds_config()->set_resource_api_version(
          envoy::config::core::v3::ApiVersion::V3);
      bootstrap.mutable_dynamic_resources()
          ->mutable_cds_config()
          ->mutable_path_config_source()
          ->set_path(cds_helper_.cdsPath());
      bootstrap.mutable_static_resources()->clear_clusters();
    });

    // Set validate_clusters to false to allow us to reference a CDS cluster.
    config_helper_.addConfigModifier(
        [override_auto_sni_header](
            envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
                hcm) {
          hcm.mutable_route_config()->mutable_validate_clusters()->set_value(false);
        });

    // Setup the initial CDS cluster.
    cluster_.mutable_connect_timeout()->CopyFrom(
        Protobuf::util::TimeUtil::MillisecondsToDuration(5000));
    cluster_.set_name("cluster_0");
    cluster_.set_lb_policy(envoy::config::cluster::v3::Cluster::CLUSTER_PROVIDED);
    cluster_.set_dns_lookup_family(
        GetParam() == Network::Address::IpVersion::v4
            ? envoy::config::cluster::v3::Cluster_DnsLookupFamily::Cluster_DnsLookupFamily_V4_ONLY
            : envoy::config::cluster::v3::Cluster_DnsLookupFamily::Cluster_DnsLookupFamily_V6_ONLY);

    ConfigHelper::HttpProtocolOptions protocol_options;
    protocol_options.mutable_upstream_http_protocol_options()->set_auto_sni(true);
    if (!override_auto_sni_header.empty()) {
      protocol_options.mutable_upstream_http_protocol_options()->set_override_auto_sni_header(
          override_auto_sni_header);
    }
    protocol_options.mutable_upstream_http_protocol_options()->set_auto_san_validation(true);
    if (upstreamProtocol() == Http::CodecType::HTTP1) {
      protocol_options.mutable_explicit_http_config()->mutable_http_protocol_options();
    } else {
      ASSERT(upstreamProtocol() == Http::CodecType::HTTP2);
      protocol_options.mutable_explicit_http_config()->mutable_http2_protocol_options();
    }
    ConfigHelper::setProtocolOptions(cluster_, protocol_options);

    if (upstream_tls_) {
      envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;
      auto* validation_context =
          tls_context.mutable_common_tls_context()->mutable_validation_context();
      validation_context->mutable_trusted_ca()->set_filename(
          TestEnvironment::runfilesPath("test/config/integration/certs/upstreamcacert.pem"));
      cluster_.mutable_transport_socket()->set_name("envoy.transport_sockets.tls");
      cluster_.mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);
    }

    const std::string cluster_type_config_use_sub_cluster = fmt::format(
        R"EOF(
name: envoy.clusters.dynamic_forward_proxy
typed_config:
  "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
  sub_clusters_config:
    max_sub_clusters: {}
)EOF",
        max_hosts);
    const std::string cluster_type_config_use_dns_cache = fmt::format(
        R"EOF(
name: envoy.clusters.dynamic_forward_proxy
typed_config:
  "@type": type.googleapis.com/envoy.extensions.clusters.dynamic_forward_proxy.v3.ClusterConfig
  dns_cache_config:
    dns_min_refresh_rate: 1s
    name: foo
    dns_lookup_family: {}
    max_hosts: {}
    host_ttl: {}s
    dns_cache_circuit_breaker:
      max_pending_requests: {}{}{}
)EOF",
        Network::Test::ipVersionToDnsFamily(GetParam()), max_hosts, host_ttl_, max_pending_requests,
        key_value_config_, typed_dns_resolver_config);

    TestUtility::loadFromYaml(use_sub_cluster ? cluster_type_config_use_sub_cluster
                                              : cluster_type_config_use_dns_cache,
                              *cluster_.mutable_cluster_type());
    cluster_.mutable_circuit_breakers()
        ->add_thresholds()
        ->mutable_max_pending_requests()
        ->set_value(max_pending_requests);

    // Load the CDS cluster and wait for it to initialize.
    cds_helper_.setCds({cluster_});
    HttpIntegrationTest::initialize();
    test_server_->waitForCounterEq("cluster_manager.cluster_added", 1);
    test_server_->waitForGaugeEq("cluster_manager.warming_clusters", 0);
  }
