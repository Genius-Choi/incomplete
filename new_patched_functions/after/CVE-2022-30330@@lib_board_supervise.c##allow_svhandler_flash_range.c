bool allow_svhandler_flash_range(size_t start, size_t end) {
  // Protect from overflow.
  if (start > end) return false;

  // Disallow non-flash writes.
  if (start < FLASH_ORIGIN || end > FLASH_END) return false;

  // Disallow writes to any sectors which aren't allowed.
  bool startAllowed = false;
  bool endAllowed = false;
  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {
    if (allow_svhandler_flash_sector(s)) {
      if (!startAllowed &&
          start + 1 > start &&
          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {
        startAllowed = true;
      }
      if (!endAllowed &&
          end - 1 < end &&
          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {
        endAllowed = true;
      }
    } else {
      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;
    }
  }

  // Ensure writes start and end in allowed sectors. As long as flash_sector_map consists of
  // contiguous sectors, this will ensure no writes can target flash outside the map.
  if (!startAllowed || !endAllowed) return false;

  return true;
}
