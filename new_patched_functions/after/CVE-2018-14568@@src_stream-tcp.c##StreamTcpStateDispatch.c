static inline int StreamTcpStateDispatch(ThreadVars *tv, Packet *p,
        StreamTcpThread *stt, TcpSession *ssn, PacketQueue *pq,
        const uint8_t state)
{
    switch (state) {
        case TCP_SYN_SENT:
            if (StreamTcpPacketStateSynSent(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_SYN_RECV:
            if (StreamTcpPacketStateSynRecv(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_ESTABLISHED:
            if (StreamTcpPacketStateEstablished(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_FIN_WAIT1:
            if (StreamTcpPacketStateFinWait1(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_FIN_WAIT2:
            if (StreamTcpPacketStateFinWait2(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_CLOSING:
            if (StreamTcpPacketStateClosing(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_CLOSE_WAIT:
            if (StreamTcpPacketStateCloseWait(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_LAST_ACK:
            if (StreamTcpPacketStateLastAck(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_TIME_WAIT:
            if (StreamTcpPacketStateTimeWait(tv, p, stt, ssn, pq)) {
                return -1;
            }
            break;
        case TCP_CLOSED:
            /* TCP session memory is not returned to pool until timeout. */
            SCLogDebug("packet received on closed state");

            if (StreamTcpPacketStateClosed(tv, p, stt, ssn, pq)) {
                return -1;
            }

            break;
        default:
            SCLogDebug("packet received on default state");
            break;
    }
    return 0;
}
