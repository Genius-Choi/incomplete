  void Compute(OpKernelContext* context) override {
    const Tensor& input = context->input(0);
    const Tensor& bias = context->input(1);

    const Tensor& min_input = context->input(2);
    const Tensor& max_input = context->input(3);
    const Tensor& min_bias = context->input(4);
    const Tensor& max_bias = context->input(5);
    OP_REQUIRES(
        context, TensorShapeUtils::IsScalar(min_input.shape()),
        errors::InvalidArgument("`min_input` must be rank 0 but is rank ",
                                min_input.dims()));
    OP_REQUIRES(
        context, TensorShapeUtils::IsScalar(max_input.shape()),
        errors::InvalidArgument("`max_input` must be rank 0 but is rank ",
                                max_input.dims()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_bias.shape()),
                errors::InvalidArgument(
                    "`min_bias` must be rank 0 but is rank ", min_bias.dims()));
    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_bias.shape()),
                errors::InvalidArgument(
                    "`max_bias` must be rank 0 but is rank ", max_bias.dims()));

    const float input_min = min_input.flat<float>()(0);
    const float input_max = max_input.flat<float>()(0);
    const float bias_min = min_bias.flat<float>()(0);
    const float bias_max = max_bias.flat<float>()(0);

    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input.shape()),
                errors::InvalidArgument("Input tensor must be at least 2D: ",
                                        input.shape().DebugString()));
    OP_REQUIRES(context, TensorShapeUtils::IsVector(bias.shape()),
                errors::InvalidArgument("Biases must be 1D: ",
                                        bias.shape().DebugString()));
    const auto last_dim = input.shape().dims() - 1;
    OP_REQUIRES(
        context, bias.shape().dim_size(0) == input.shape().dim_size(last_dim),
        errors::InvalidArgument(
            "Must provide as many biases as the last dimension "
            "of the input tensor: ",
            bias.shape().DebugString(), " vs. ", input.shape().DebugString()));
    OP_REQUIRES(context, bias.NumElements() > 0,
                errors::InvalidArgument("Must provide at least 1 bias"));

    Tensor* output = nullptr;
    OP_REQUIRES_OK(context,
                   context->allocate_output(0, input.shape(), &output));

    float total_min;
    float total_max;

    if (meta::IsSupportedAndEnabled() && std::is_same<T1, quint8>() &&
        std::is_same<T2, quint8>() && std::is_same<T3, qint32>()) {
      auto input_ui8_array = input.flat<quint8>();
      auto bias_ui8_array = bias.flat<quint8>();
      GetOutputMinAndMaxForQuantizedAdd(input_min, input_max, bias_min,
                                        bias_max, &total_min, &total_max);
      meta::QuantizedBiasAdd(context, input_ui8_array.data(),
                             input_ui8_array.size(), bias_ui8_array.data(),
                             bias_ui8_array.size(), input_min, input_max,
                             bias_min, bias_max, total_min, total_max,
                             output->flat<qint32>().data());
    } else {
      QuantizedAddUsingEigen<T1, T2, T3>(
          context->template eigen_device<CPUDevice>(), input, input_min,
          input_max, bias, bias_min, bias_max, output, &total_min, &total_max);
    }

    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));
    output_min->flat<float>()(0) = total_min;

    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));
    output_max->flat<float>()(0) = total_max;
  }
