mmsServer_handleObtainFileRequest(
        MmsServerConnection connection,
        uint8_t* buffer, int bufPos, int maxBufPos,
        uint32_t invokeId,
        ByteBuffer* response)
{
    char sourceFilename[256];
    bool hasSourceFileName = false;

    char destinationFilename[256];
    bool hasDestinationFilename = false;

    while (bufPos < maxBufPos) {
        uint8_t tag = buffer[bufPos++];
        int length;

        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);

        if (bufPos < 0) goto exit_reject_invalid_pdu;

        switch(tag) {

        case 0xa1: /* source filename */

            if (!mmsMsg_parseFileName(sourceFilename, buffer, &bufPos, bufPos + length, invokeId, response))
                return;

            hasSourceFileName = true;

            break;

        case 0xa2: /* destination filename */

            if (!mmsMsg_parseFileName(destinationFilename, buffer, &bufPos, bufPos + length, invokeId, response))
                return;

            hasDestinationFilename = true;

            break;

        case 0x00: /* indefinite length end tag -> ignore */
            break;

        default: /* unrecognized parameter */
            bufPos += length;
            goto exit_reject_invalid_pdu;
        }
    }

    if (hasSourceFileName && hasDestinationFilename) {

        if (mmsMsg_isFilenameSave(destinationFilename) == false) {
            /* potential attack */

            if (DEBUG_MMS_SERVER)
                printf("MMS_SERVER: remote provided unsave filename -> rejected\n");

            goto exit_invalid_parameter;
        }

        /* Call user to check if access is allowed */
        if (connection->server->fileAccessHandler != NULL) {
            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,
                                connection, MMS_FILE_ACCESS_TYPE_OBTAIN, destinationFilename, sourceFilename);

            if (access != MMS_ERROR_NONE) {
                mmsMsg_createServiceErrorPdu(invokeId, response, access);
                return;
            }
        }

        /* call callback to check if access is allowed -- DEPRECATED */
        if (connection->server->obtainFileHandler)
            if (connection->server->obtainFileHandler(connection->server->obtainFileHandlerParameter, connection, sourceFilename, destinationFilename) == false)
                goto exit_access_denied;

        /*  check if destination file already exists. If exists return error message */

#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)
        char extendedFileName[512];
        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection), 512,
                extendedFileName, destinationFilename);

#else
        char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];

        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection),
                sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256,
                extendedFileName, destinationFilename);
#endif

        if (FileSystem_getFileInfo(extendedFileName, NULL, NULL)) {
            if (DEBUG_MMS_SERVER)
                printf("MMS_SERVER: obtainFile - file already exists on server\n");
            goto exit_file_already_exists;
        }

        if (DEBUG_MMS_SERVER)
            printf("MMS_SERVER: Start download file %s from client to local file %s...\n", sourceFilename, destinationFilename);

        MmsObtainFileTask task = MmsServer_getObtainFileTask(connection->server);

        if (task != NULL) {

            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection),
                    destinationFilename, true);

            task->connection = connection;
            task->obtainFileRequestInvokeId = invokeId;

            if (fileHandle == NULL) {
                task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION;
            }
            else {
                /* send file open request */
                task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(connection);
                task->fileHandle = fileHandle;

                StringUtils_copyStringMax(task->destinationFilename, 256, destinationFilename);

                ByteBuffer* request = MmsServer_reserveTransmitBuffer(connection->server);

                mmsClient_createFileOpenRequest(task->lastRequestInvokeId, request, sourceFilename, 0);

                IsoConnection_sendMessage(task->connection->isoConnection, request);

                MmsServer_releaseTransmitBuffer(connection->server);

                task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */

                task->state = MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT;
            }

#if (CONFIG_MMS_THREADLESS_STACK != 1)
            Semaphore_post(task->taskLock);
#endif
        }
        else
            goto exit_unavailable;
    }
    else
        goto exit_invalid_parameter;

    return;

exit_invalid_parameter:
    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);
    return;

exit_access_denied:
    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED, 1);
    return;

exit_file_already_exists:
    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_DUPLICATE_FILENAME, 1);
    return;

exit_unavailable:
    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE);
    return;

exit_reject_invalid_pdu:
    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);
}
