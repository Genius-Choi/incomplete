static int nsim_fib_event_schedule_work(struct nsim_fib_data *data,
					struct fib_notifier_info *info,
					unsigned long event)
{
	struct nsim_fib_event *fib_event;
	int err;

	if (info->family != AF_INET && info->family != AF_INET6)
		/* netdevsim does not support 'RTNL_FAMILY_IP6MR' and
		 * 'RTNL_FAMILY_IPMR' and should ignore them.
		 */
		return NOTIFY_DONE;

	fib_event = kzalloc(sizeof(*fib_event), GFP_ATOMIC);
	if (!fib_event)
		goto err_fib_event_alloc;

	fib_event->data = data;
	fib_event->event = event;
	fib_event->family = info->family;

	switch (info->family) {
	case AF_INET:
		err = nsim_fib4_prepare_event(info, fib_event, event);
		break;
	case AF_INET6:
		err = nsim_fib6_prepare_event(info, fib_event, event);
		break;
	}

	if (err)
		goto err_fib_prepare_event;

	/* Enqueue the event and trigger the work */
	spin_lock_bh(&data->fib_event_queue_lock);
	list_add_tail(&fib_event->list, &data->fib_event_queue);
	spin_unlock_bh(&data->fib_event_queue_lock);
	schedule_work(&data->fib_event_work);

	return NOTIFY_DONE;

err_fib_prepare_event:
	kfree(fib_event);
err_fib_event_alloc:
	if (event == FIB_EVENT_ENTRY_DEL)
		schedule_work(&data->fib_flush_work);
	return NOTIFY_BAD;
}
