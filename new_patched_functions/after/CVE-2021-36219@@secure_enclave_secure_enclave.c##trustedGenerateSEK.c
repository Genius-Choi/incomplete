void trustedGenerateSEK(int *errStatus, char *errString,
                  uint8_t *encrypted_SEK, uint32_t *enc_len, char *SEK_hex) {

    LOG_DEBUG (__FUNCTION__);

    uint8_t SEK_raw[SGX_AESGCM_KEY_SIZE];
    sgx_read_rand(SEK_raw, SGX_AESGCM_KEY_SIZE);

    uint32_t hex_aes_key_length = SGX_AESGCM_KEY_SIZE * 2;
    uint8_t SEK[hex_aes_key_length];
    carray2Hex(SEK_raw, SGX_AESGCM_KEY_SIZE, SEK_hex);

    uint32_t sealedLen = sgx_calc_sealed_data_size(0, hex_aes_key_length + 1);

    for (uint8_t i = 0; i < 16; i++) {
        AES_key[i] = SEK_raw[i];
    }

    sgx_status_t status = sgx_seal_data(0, NULL, hex_aes_key_length + 1, SEK_hex, sealedLen,
                                        (sgx_sealed_data_t *) encrypted_SEK);
    if (status != SGX_SUCCESS) {
        snprintf(errString, BUF_LEN, "seal SEK failed");
        *errStatus = status;
        return;
    }


    *enc_len = sealedLen;

}
