find_alternate_tgs(krb5_context context, krb5_principal princ,
                   krb5_db_entry **server_ptr, const char **status)
{
    krb5_error_code retval;
    krb5_principal *plist = NULL, *pl2;
    krb5_data tmp;
    krb5_db_entry *server = NULL;

    *server_ptr = NULL;
    assert(is_cross_tgs_principal(princ));
    retval = krb5_walk_realm_tree(context, &princ->realm, &princ->data[1],
                                  &plist, KRB5_REALM_BRANCH_CHAR);
    if (retval)
        goto cleanup;
    /* move to the end */
    for (pl2 = plist; *pl2; pl2++);

    /* the first entry in this array is for krbtgt/local@local, so we
       ignore it */
    while (--pl2 > plist) {
        tmp = *krb5_princ_realm(context, *pl2);
        krb5_princ_set_realm(context, *pl2, &princ->realm);
        retval = db_get_svc_princ(context, *pl2, 0, &server, status);
        krb5_princ_set_realm(context, *pl2, &tmp);
        if (retval == KRB5_KDB_NOENTRY)
            continue;
        else if (retval)
            goto cleanup;

        log_tgs_alt_tgt(context, server->princ);
        *server_ptr = server;
        server = NULL;
        goto cleanup;
    }
cleanup:
    if (retval == 0 && *server_ptr == NULL)
        retval = KRB5_KDB_NOENTRY;
    if (retval != 0)
        *status = "UNKNOWN_SERVER";

    krb5_free_realm_tree(context, plist);
    krb5_db_free_principal(context, server);
    return retval;
}
