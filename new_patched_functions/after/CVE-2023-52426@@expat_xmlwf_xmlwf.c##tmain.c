tmain(int argc, XML_Char **argv) {
  int i, j;
  const XML_Char *outputDir = NULL;
  const XML_Char *encoding = NULL;
  unsigned processFlags = XML_MAP_FILE;
  int windowsCodePages = 0;
  int outputType = 0;
  int useNamespaces = 0;
  int requireStandalone = 0;
  int requiresNotations = 0;
  int continueOnError = 0;

  float attackMaximumAmplification = -1.0f; /* signaling "not set" */
  unsigned long long attackThresholdBytes = 0;
  XML_Bool attackThresholdGiven = XML_FALSE;

  int exitCode = XMLWF_EXIT_SUCCESS;
  enum XML_ParamEntityParsing paramEntityParsing
      = XML_PARAM_ENTITY_PARSING_NEVER;
  int useStdin = 0;
  XmlwfUserData userData = {NULL, NULL, NULL};

#ifdef _MSC_VER
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

  i = 1;
  j = 0;
  while (i < argc) {
    if (j == 0) {
      if (argv[i][0] != T('-'))
        break;
      if (argv[i][1] == T('-')) {
        if (argv[i][2] == T('\0')) {
          i++;
          break;
        } else if (tcscmp(argv[i] + 2, T("help")) == 0) {
          usage(argv[0], XMLWF_EXIT_SUCCESS);
          // usage called exit(..), never gets here
        } else if (tcscmp(argv[i] + 2, T("version")) == 0) {
          showVersion(argv[0]);
          return XMLWF_EXIT_SUCCESS;
        }
      }
      j++;
    }
    switch (argv[i][j]) {
    case T('r'):
      processFlags &= ~XML_MAP_FILE;
      j++;
      break;
    case T('s'):
      requireStandalone = 1;
      j++;
      break;
    case T('n'):
      useNamespaces = 1;
      j++;
      break;
    case T('p'):
      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;
      /* fall through */
    case T('x'):
      processFlags |= XML_EXTERNAL_ENTITIES;
      j++;
      break;
    case T('w'):
      windowsCodePages = 1;
      j++;
      break;
    case T('m'):
      outputType = 'm';
      j++;
      break;
    case T('c'):
      outputType = 'c';
      useNamespaces = 0;
      j++;
      break;
    case T('t'):
      outputType = 't';
      j++;
      break;
    case T('N'):
      requiresNotations = 1;
      j++;
      break;
    case T('d'):
      XMLWF_SHIFT_ARG_INTO(outputDir, argc, argv, i, j);
      break;
    case T('e'):
      XMLWF_SHIFT_ARG_INTO(encoding, argc, argv, i, j);
      break;
    case T('h'):
      usage(argv[0], XMLWF_EXIT_SUCCESS);
      // usage called exit(..), never gets here
    case T('v'):
      showVersion(argv[0]);
      return XMLWF_EXIT_SUCCESS;
    case T('g'): {
      const XML_Char *valueText = NULL;
      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);

      errno = 0;
      XML_Char *afterValueText = (XML_Char *)valueText;
      const long long read_size_bytes_candidate
          = tcstoull(valueText, &afterValueText, 10);
      if ((errno != 0) || (afterValueText[0] != T('\0'))
          || (read_size_bytes_candidate < 1)
          || (read_size_bytes_candidate > (INT_MAX / 2 + 1))) {
        // This prevents tperror(..) from reporting misleading "[..]: Success"
        errno = ERANGE;
        tperror(T("invalid buffer size") T(
            " (needs an integer from 1 to INT_MAX/2+1 i.e. 1,073,741,824 on most platforms)"));
        exit(XMLWF_EXIT_USAGE_ERROR);
      }
      g_read_size_bytes = (int)read_size_bytes_candidate;
      break;
    }
    case T('k'):
      continueOnError = 1;
      j++;
      break;
    case T('a'): {
      const XML_Char *valueText = NULL;
      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);

      errno = 0;
      XML_Char *afterValueText = NULL;
      attackMaximumAmplification = tcstof(valueText, &afterValueText);
      if ((errno != 0) || (afterValueText[0] != T('\0'))
          || isnan(attackMaximumAmplification)
          || (attackMaximumAmplification < 1.0f)) {
        // This prevents tperror(..) from reporting misleading "[..]: Success"
        errno = ERANGE;
        tperror(T("invalid amplification limit") T(
            " (needs a floating point number greater or equal than 1.0)"));
        exit(XMLWF_EXIT_USAGE_ERROR);
      }
#if ! defined(XML_DTD) && XML_GE == 0
      ftprintf(stderr,
               T("Warning: Given amplification limit ignored")
                   T(", xmlwf has been compiled without DTD/GE support.\n"));
#endif
      break;
    }
    case T('b'): {
      const XML_Char *valueText = NULL;
      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);

      errno = 0;
      XML_Char *afterValueText = (XML_Char *)valueText;
      attackThresholdBytes = tcstoull(valueText, &afterValueText, 10);
      if ((errno != 0) || (afterValueText[0] != T('\0'))) {
        // This prevents tperror(..) from reporting misleading "[..]: Success"
        errno = ERANGE;
        tperror(T("invalid ignore threshold")
                    T(" (needs an integer from 0 to 2^64-1)"));
        exit(XMLWF_EXIT_USAGE_ERROR);
      }
      attackThresholdGiven = XML_TRUE;
#if ! defined(XML_DTD) && XML_GE == 0
      ftprintf(stderr,
               T("Warning: Given attack threshold ignored")
                   T(", xmlwf has been compiled without DTD/GE support.\n"));
#endif
      break;
    }
    case T('\0'):
      if (j > 1) {
        i++;
        j = 0;
        break;
      }
      /* fall through */
    default:
      usage(argv[0], XMLWF_EXIT_USAGE_ERROR);
      // usage called exit(..), never gets here
    }
  }
  if (i == argc) {
    useStdin = 1;
    processFlags &= ~XML_MAP_FILE;
    i--;
  }
  for (; i < argc; i++) {
    XML_Char *outName = 0;
    int result;
    XML_Parser parser;
    if (useNamespaces)
      parser = XML_ParserCreateNS(encoding, NSSEP);
    else
      parser = XML_ParserCreate(encoding);

    if (! parser) {
      tperror(T("Could not instantiate parser"));
      exit(XMLWF_EXIT_INTERNAL_ERROR);
    }

    if (attackMaximumAmplification != -1.0f) {
#if defined(XML_DTD) || XML_GE == 1
      XML_SetBillionLaughsAttackProtectionMaximumAmplification(
          parser, attackMaximumAmplification);
#endif
    }
    if (attackThresholdGiven) {
#if defined(XML_DTD) || XML_GE == 1
      XML_SetBillionLaughsAttackProtectionActivationThreshold(
          parser, attackThresholdBytes);
#else
      (void)attackThresholdBytes; // silence -Wunused-but-set-variable
#endif
    }

    if (requireStandalone)
      XML_SetNotStandaloneHandler(parser, notStandalone);
    XML_SetParamEntityParsing(parser, paramEntityParsing);
    if (outputType == 't') {
      /* This is for doing timings; this gives a more realistic estimate of
         the parsing time. */
      outputDir = 0;
      XML_SetElementHandler(parser, nopStartElement, nopEndElement);
      XML_SetCharacterDataHandler(parser, nopCharacterData);
      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);
    } else if (outputDir) {
      const XML_Char *delim = T("/");
      const XML_Char *file = useStdin ? T("STDIN") : argv[i];
      if (! useStdin) {
        /* Jump after last (back)slash */
        const XML_Char *lastDelim = tcsrchr(file, delim[0]);
        if (lastDelim)
          file = lastDelim + 1;
#if defined(_WIN32)
        else {
          const XML_Char *winDelim = T("\\");
          lastDelim = tcsrchr(file, winDelim[0]);
          if (lastDelim) {
            file = lastDelim + 1;
            delim = winDelim;
          }
        }
#endif
      }
      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)
                                   * sizeof(XML_Char));
      if (! outName) {
        tperror(T("Could not allocate memory"));
        exit(XMLWF_EXIT_INTERNAL_ERROR);
      }
      tcscpy(outName, outputDir);
      tcscat(outName, delim);
      tcscat(outName, file);
      userData.fp = tfopen(outName, T("wb"));
      if (! userData.fp) {
        tperror(outName);
        exitCode = XMLWF_EXIT_OUTPUT_ERROR;
        free(outName);
        XML_ParserFree(parser);
        if (continueOnError) {
          continue;
        } else {
          break;
        }
      }
      setvbuf(userData.fp, NULL, _IOFBF, 16384);
#ifdef XML_UNICODE
      puttc(0xFEFF, userData.fp);
#endif
      XML_SetUserData(parser, &userData);
      switch (outputType) {
      case 'm':
        XML_UseParserAsHandlerArg(parser);
        XML_SetElementHandler(parser, metaStartElement, metaEndElement);
        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);
        XML_SetCommentHandler(parser, metaComment);
        XML_SetCdataSectionHandler(parser, metaStartCdataSection,
                                   metaEndCdataSection);
        XML_SetCharacterDataHandler(parser, metaCharacterData);
        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,
                                  metaEndDoctypeDecl);
        XML_SetEntityDeclHandler(parser, metaEntityDecl);
        XML_SetNotationDeclHandler(parser, metaNotationDecl);
        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,
                                    metaEndNamespaceDecl);
        metaStartDocument(parser);
        break;
      case 'c':
        XML_UseParserAsHandlerArg(parser);
        XML_SetDefaultHandler(parser, markup);
        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);
        XML_SetCharacterDataHandler(parser, defaultCharacterData);
        XML_SetProcessingInstructionHandler(parser,
                                            defaultProcessingInstruction);
        break;
      default:
        if (useNamespaces)
          XML_SetElementHandler(parser, startElementNS, endElementNS);
        else
          XML_SetElementHandler(parser, startElement, endElement);
        XML_SetCharacterDataHandler(parser, characterData);
#ifndef W3C14N
        XML_SetProcessingInstructionHandler(parser, processingInstruction);
        if (requiresNotations) {
          XML_SetDoctypeDeclHandler(parser, startDoctypeDecl, endDoctypeDecl);
          XML_SetNotationDeclHandler(parser, notationDecl);
        }
#endif /* not W3C14N */
        break;
      }
    }
    if (windowsCodePages)
      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);
    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);
    if (outputDir) {
      if (outputType == 'm')
        metaEndDocument(parser);
      fclose(userData.fp);
      if (! result) {
        tremove(outName);
      }
      free(outName);
    }
    XML_ParserFree(parser);
    if (! result) {
      exitCode = XMLWF_EXIT_NOT_WELLFORMED;
      cleanupUserData(&userData);
      if (! continueOnError) {
        break;
      }
    }
  }
  return exitCode;
}
