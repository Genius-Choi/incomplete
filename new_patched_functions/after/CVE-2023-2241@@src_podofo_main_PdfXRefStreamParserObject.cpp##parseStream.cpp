void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)
{
    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)
    {
        if (wArray[i] < 0)
        {
            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,
                "Negative field length in XRef stream");
        }
        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])
        {
            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,
                "Invalid entry length in XRef stream");
        }
        else
        {
            lengthSum += wArray[i];
        }
    }

    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);

    charbuff buffer;
    this->GetOrCreateStream().CopyTo(buffer);

    vector<int64_t>::const_iterator it = indices.begin();
    size_t offset = 0;
    while (it != indices.end())
    {
        int64_t firstObj = *it++;
        int64_t count = *it++;

        if ((offset + count * entryLen) > buffer.size())
            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, "Invalid count in XRef stream");

        m_entries->Enlarge(firstObj + count);
        for (unsigned index = 0; index < (unsigned)count; index++)
        {
            unsigned objIndex = (unsigned)firstObj + index;
            auto& entry = (*m_entries)[objIndex];
            if (objIndex < m_entries->GetSize() && !entry.Parsed)
                readXRefStreamEntry(entry, buffer.data() + offset, wArray);

            offset += entryLen;
        }
    }
}
