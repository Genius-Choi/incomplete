            paramScope->ForEachSymbol([&](Symbol* param) {
                Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());
                Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);
                Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));
                if (param->GetIsArguments() && !funcInfo->GetHasArguments())
                {
                    // Do not copy the arguments to the body if it is not used
                }
                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol
                                                                     // is expected to stay inside the function expression scope
                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))
                {
                    // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.
                    // Walking the scope chain is not possible at this time.
                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();
                    Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);
                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);
                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);

                    this->m_writer.SlotI1(op, tempReg, slot, profileId);

                    if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))
                    {
                        byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);
                    }

                    this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);
                    funcInfo->ReleaseTmpRegister(tempReg);
                }
            });
