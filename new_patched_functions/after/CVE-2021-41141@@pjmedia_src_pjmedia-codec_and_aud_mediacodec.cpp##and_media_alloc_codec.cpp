static pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory,
					 const pjmedia_codec_info *id,
					 pjmedia_codec **p_codec)
{
    and_media_private_t *codec_data;
    pjmedia_codec *codec;
    int idx;
    pj_pool_t *pool;
    unsigned i;

    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);
    PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL);

    pj_mutex_lock(and_media_factory.mutex);

    /* Find codec's index */
    idx = -1;
    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {
	pj_str_t name = pj_str((char*)and_media_codec[i].name);
	if ((pj_stricmp(&id->encoding_name, &name) == 0) &&
	    (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&
	    (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&
	    (and_media_codec[i].enabled))
	{
	    idx = i;
	    break;
	}
    }
    if (idx == -1) {
	*p_codec = NULL;
	pj_mutex_unlock(and_media_factory.mutex);
	return PJMEDIA_CODEC_EFAILED;
    }

    /* Create pool for codec instance */
    pool = pjmedia_endpt_create_pool(and_media_factory.endpt, "andmedaud%p",
                                     512, 512);
    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);
    PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);
    codec->op = &and_media_op;
    codec->factory = factory;
    codec->codec_data = PJ_POOL_ZALLOC_T(pool, and_media_private_t);
    codec_data = (and_media_private_t*) codec->codec_data;

    /* Create PLC if codec has no internal PLC */
    if (!and_media_codec[idx].has_native_plc) {
	pj_status_t status;
	status = pjmedia_plc_create(pool, and_media_codec[idx].clock_rate,
				    and_media_codec[idx].samples_per_frame, 0,
				    &codec_data->plc);
	if (status != PJ_SUCCESS) {
	    goto on_error;
	}
    }

    /* Create silence detector if codec has no internal VAD */
    if (!and_media_codec[idx].has_native_vad) {
	pj_status_t status;
	status = pjmedia_silence_det_create(pool,
					and_media_codec[idx].clock_rate,
					and_media_codec[idx].samples_per_frame,
					&codec_data->vad);
	if (status != PJ_SUCCESS) {
	    goto on_error;
	}
    }

    codec_data->pool = pool;
    codec_data->codec_idx = idx;

    create_codec(codec_data);
    if (!codec_data->enc || !codec_data->dec) {
	goto on_error;
    }
    pj_mutex_unlock(and_media_factory.mutex);

    *p_codec = codec;
    return PJ_SUCCESS;

on_error:
    pj_mutex_unlock(and_media_factory.mutex);
    and_media_dealloc_codec(factory, codec);
    return PJMEDIA_CODEC_EFAILED;
}
