rpmb_keybox_retrieve(__u8 mode, __u8 *key)
{
	int ret;
	uint32_t i;
	uint32_t block_num;
	rpmb_block_t *block_table;
	uint8_t *attkb = NULL;
	uint16_t kb_size;
	uint32_t kb_buf_size = 0;

	block_table = malloc(sizeof(rpmb_block_t));
	if (!block_table) {
		DPRINTF(("%s: block table malloc fail!\n", __func__));
		return -ENOMEM;
	}

	memset(block_table, 0, sizeof(rpmb_block_t));
	/* read block table */
	ret = rpmb_read_bara(mode, key, block_table);
	if (ret) {
		DPRINTF(("get block table fail!\n"));
		goto out;
	}

	if (memcmp(BLOCK_BARA_SIGNATURE, block_table->signature, SIGNATURE_LENGTH) || !(block_table->flag & ATTKB_PRESENT_FLAG_BIT)) {
		kb_size = get_attkb_size();
		if (kb_size == 0) {
			DPRINTF(("rpmb get_attkb_size fail!\n"));
			ret = -1;
			goto out;
		}

		if (kb_size % RPMB_BLOCK_SIZE) {
			kb_buf_size = (kb_size / RPMB_BLOCK_SIZE + 1) * RPMB_BLOCK_SIZE;
		} else {
			kb_buf_size = kb_size;
		}

		attkb = (uint8_t *)malloc(kb_buf_size);
		if (!attkb) {
			DPRINTF(("%s: attkb malloc fail!\n", __func__));
			ret = -ENOMEM;
			goto out;
		}

		memset(attkb, 0, kb_buf_size);
		ret = read_attkb(attkb, kb_size);
		if (ret == 0) {
			DPRINTF(("failed to read attkb"));
			ret = -1;
			goto out;
		}

		rpmb_bara_init(block_table, kb_size);
		block_num = (kb_size - 1) / RPMB_BLOCK_SIZE + 1;
		for (i = 0; i < block_num; i++) {
			ret = rpmb_write_block(mode, key, block_table->attkb_addr + i, attkb + i * RPMB_BLOCK_SIZE, 1);
			if (ret) {
				DPRINTF(("rpmb write key box fail!\n"));
				goto out;
			}
		}

		ret = rpmb_write_block(mode, key, BLOCK_BARA_BASE_ADDRESS, block_table, 1);
		if (ret) {
			DPRINTF(("rpmb write block table fail!\n"));
			goto out;
		}
	}

out:
	if (attkb) {
		memset(attkb, 0, kb_buf_size);
		free(attkb);
	}

	free(block_table);
	return ret;
}
