pf_remove_divert_state(struct pf_state_key *sk)
{
	struct pf_state_item	*si;

	PF_ASSERT_UNLOCKED();

	PF_LOCK();
	PF_STATE_ENTER_WRITE();
	TAILQ_FOREACH(si, &sk->sk_states, si_entry) {
		struct pf_state *sist = si->si_st;
		if (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&
		    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||
		     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {
			if (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&
			    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {
				/*
				 * If the local address is translated, keep
				 * the state for "tcp.closed" seconds to
				 * prevent its source port from being reused.
				 */
				if (sist->src.state < TCPS_FIN_WAIT_2 ||
				    sist->dst.state < TCPS_FIN_WAIT_2) {
					pf_set_protostate(sist, PF_PEER_BOTH,
					    TCPS_TIME_WAIT);
					pf_update_state_timeout(sist,
					    PFTM_TCP_CLOSED);
					sist->expire = getuptime();
				}
				sist->state_flags |= PFSTATE_INP_UNLINKED;
			} else
				pf_remove_state(sist);
			break;
		}
	}
	PF_STATE_EXIT_WRITE();
	PF_UNLOCK();
}
