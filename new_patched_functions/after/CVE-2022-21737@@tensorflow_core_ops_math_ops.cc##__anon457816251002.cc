    .SetShapeFn([](InferenceContext* c) {
      const Tensor* size_tensor = c->input_tensor(3);
      if (size_tensor == nullptr) {
        // Return unknown shape if size is not known.
        c->set_output(0, c->UnknownShape());
        return Status::OK();
      }
      if (size_tensor->dims() != 0) {
        return errors::InvalidArgument("Shape must be rank 0 but is rank ",
                                       size_tensor->dims());
      }

      int64_t size_val;
      DataType dtype;
      TF_RETURN_IF_ERROR(c->GetAttr("Tidx", &dtype));
      if (dtype == DT_INT32) {
        size_val = static_cast<int64_t>(size_tensor->scalar<int32>()());
      } else if (dtype == DT_INT64) {
        size_val = size_tensor->scalar<int64_t>()();
      } else {
        return errors::InvalidArgument("size dtype must be int32 or int64");
      }
      // Return `[size]` shape if size is known.
      if (size_val < 0) {
        return errors::InvalidArgument("size (", size_val,
                                       ") must be non-negative");
      }

      const Tensor* shape_tensor = c->input_tensor(2);
      if (shape_tensor == nullptr) {
        // Return unknown shape if size is not known.
        c->set_output(0, c->UnknownShape());
        return Status::OK();
      }
      if (shape_tensor->NumElements() == 1) {
        c->set_output(0, c->MakeShape({size_val}));
      } else if (shape_tensor->NumElements() == 2) {
        c->set_output(
            0, c->MakeShape({shape_tensor->flat<int64_t>()(0), size_val}));
      } else {
        return errors::InvalidArgument("Input must be less than rank 2");
      }
      return Status::OK();
    });
