adjust_skipcol(void)
{
    if (!curwin->w_p_wrap
	    || !curwin->w_p_sms
	    || curwin->w_cursor.lnum != curwin->w_topline)
	return;

    int	    width1 = curwin->w_width - curwin_col_off();
    if (width1 <= 0)
	return;  // no text will be displayed

    int	    width2 = width1 + curwin_col_off2();
    long    so = get_scrolloff_value();
    int	    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;
    int	    scrolled = FALSE;

    validate_cheight();
    if (curwin->w_cline_height == curwin->w_height
	    // w_cline_height may be capped at w_height, check there aren't
	    // actually more lines.
	    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)
							   <= curwin->w_height)
    {
	// the line just fits in the window, don't scroll
	reset_skipcol();
	return;
    }

    validate_virtcol();
    int overlap = sms_marker_overlap(curwin,
					 curwin_col_off() - curwin_col_off2());
    while (curwin->w_skipcol > 0
	    && curwin->w_virtcol < curwin->w_skipcol + overlap + scrolloff_cols)
    {
	// scroll a screen line down
	if (curwin->w_skipcol >= width1 + width2)
	    curwin->w_skipcol -= width2;
	else
	    curwin->w_skipcol -= width1;
	scrolled = TRUE;
    }
    if (scrolled)
    {
	validate_virtcol();
	redraw_later(UPD_NOT_VALID);
	return;  // don't scroll in the other direction now
    }

    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;
    int row = 0;
    if (col >= width1)
    {
	col -= width1;
	++row;
    }
    if (col > width2)
    {
	row += col / width2;
	// col may no longer be used, but make
	// sure it is correct anyhow, just in case
	col = col % width2;
    }
    if (row >= curwin->w_height)
    {
	if (curwin->w_skipcol == 0)
	{
	    curwin->w_skipcol += width1;
	    --row;
	}
	if (row >= curwin->w_height)
	    curwin->w_skipcol += (row - curwin->w_height) * width2;
	redraw_later(UPD_NOT_VALID);
    }
}
