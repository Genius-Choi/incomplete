int CGIFFF DGifSlurp(CGIFFF GifFileType *GifFile)
{
    static unsigned InterlacedOffset[] = { 0, 4, 2, 1 }, /* The way Interlaced image should. */
                    InterlacedJumps[] = { 8, 8, 4, 2 };  /* be read - offsets and jumps... */
    /**** pts: unused vars ****/
    /* int i, j, Error, ImageSize; */
    int ext_code;

    GifRecordType RecordType;
    /**** pts ****/
    SavedImage *sp=0; /**** pts: avoid gcc warning */
    /** Extension info of next SavedImage */
    SavedImage ext;
    /** No-extension info */
    SavedImage noext;

    GifByteType *ExtData;

    /**** pts ****/
    memset(&noext, 0, sizeof(noext));
    noext.delay=0;
    noext.dispose=0;
    noext.iter=1;
    noext.transp=(-1);
    noext.ExtensionBlocks=NULL;
    noext.ExtensionBlockCount=0;
    ext=noext;

    /**** pts ****/
    GifFile->SavedImages=0;

    do {
	if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR)
	    return(GIF_ERROR);

	switch (RecordType) {
	    case IMAGE_DESC_RECORD_TYPE:
		if (DGifGetImageDesc(GifFile) == GIF_ERROR)
		    return(GIF_ERROR);

                /**** pts: DGifGetImageDesc has already allocated the mem ****/
		sp = &GifFile->SavedImages[GifFile->ImageCount-1];
		/**** pts: apply extensions to the image just read */
		ext.RasterBits=sp->RasterBits;
		ext.ImageDesc=sp->ImageDesc;
		*sp=ext;
		ext=noext;

		/**** pts ****/
		sp->RasterBits = (GifPixelType*) xmalloc((0L+sp->ImageDesc.Width) * sp->ImageDesc.Height * sizeof(GifPixelType));
		if (sp->ImageDesc.Interlace) {
		  unsigned i, j, Height=sp->ImageDesc.Height, Width=sp->ImageDesc.Width;
		  /* Need to perform 4 passes on the images: */
 		  for (i = 0; i < 4; i++)
		    for (j = InterlacedOffset[i]; j < Height; j += InterlacedJumps[i])
		      if (DGifGetLine(GifFile, sp->RasterBits+Width*j, Width) != GIF_OK) return GIF_ERROR;
		} else {
		  if (DGifGetLine(GifFile, sp->RasterBits, (0L+sp->ImageDesc.Width) * sp->ImageDesc.Height)
		      == GIF_ERROR)
		      return(GIF_ERROR);
		}
		break;

	    case EXTENSION_RECORD_TYPE:

		if (DGifGetExtension(GifFile,&ext_code,&ExtData)==GIF_ERROR)
		    return(GIF_ERROR);
		if (ExtData!=NULL) {
		    #if 0 /**** pts ****/
		      ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];
		      ep->ByteCount = ExtData[0];
		      ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));
		      memcpy(ep->Bytes, ExtData, ep->ByteCount * sizeof(char));
		    #else
                      /**** pts ****/
                      if (0xf9==(unsigned char)(ext_code)) {
                        if (ExtData[0] < 4) { ext_too_short:
                          _GifError = D_GIF_ERR_EXT_TOO_SHORT;
                          return GIF_ERROR;
                        }
                        ext.dispose=ExtData[1]>>2;
                        ext.delay=(ExtData[3] << 8) | ExtData[2];
                        if ((ExtData[1] & 0x01) == 1) {
                          if (ExtData[0] < 5) goto ext_too_short;
                          ext.transp=ExtData[4];
                        }
                      } else if (0xff==(unsigned char)(ext_code)) {
                        if (ExtData[0] < 4) goto ext_too_short;
                        ext.iter=(ExtData[3] << 8) | ExtData[2];
                      } else {
                        AddExtensionBlock(&ext, ExtData[0], ExtData+1);
                        ext.ExtensionBlocks[ext.ExtensionBlockCount-1].code=ext_code;
                      }
		    #endif
		    while (1) {
		        if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)
			  return(GIF_ERROR);
		        #if 0 /**** pts ****/
  			  ep = &ext.ExtensionBlocks[ext.ExtensionBlockCount++];
  			  ep->ByteCount = ExtData[0];
			  ep->Bytes = (GifByteType *)xmalloc(ep->ByteCount * sizeof(GifByteType));
  			  memcpy(ep->Bytes,ExtData,ep->ByteCount * sizeof(char));
  			#else
  			  if (ExtData==NULL) break;
                          AddExtensionBlock(&ext, ExtData[0], ExtData+1);
                          ext.ExtensionBlocks[ext.ExtensionBlockCount-1].code=ext_code;
  			#endif
		    }
		}
		break;

	    case TERMINATE_RECORD_TYPE:
		break;

	    default:	/* Should be trapped by DGifGetRecordType */
		break;
	}
    }
    while
	(RecordType != TERMINATE_RECORD_TYPE);

    return(GIF_OK);
}
