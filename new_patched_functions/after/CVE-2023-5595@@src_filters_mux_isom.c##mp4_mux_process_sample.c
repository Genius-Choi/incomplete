static GF_Err mp4_mux_process_sample(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, Bool for_fragment)
{
	GF_Err e=GF_OK;
	u64 cts, prev_dts;
	u32 prev_size=0;
	u32 duration = 0;
	u32 timescale = 0;
	const GF_PropertyValue *subs;
	GF_FilterSAPType sap_type;
	u32 insert_subsample_dsi_size = 0;
	u32 first_nal_is_audelim = GF_FALSE;
	u32 sample_desc_index = tkw->stsd_idx;
	Bool sample_timing_ok = GF_TRUE;

	timescale = gf_filter_pck_get_timescale(pck);

	prev_dts = tkw->nb_samples ? tkw->sample.DTS : GF_FILTER_NO_TS;
	prev_size = tkw->sample.dataLength;
	tkw->sample.CTS_Offset = 0;
	if (gf_filter_pck_get_frame_interface(pck)) {
		tkw->dgl_copy = gf_filter_pck_dangling_copy(pck, tkw->dgl_copy);
		if (!tkw->dgl_copy) return GF_IO_ERR;
		tkw->sample.data = (char *)gf_filter_pck_get_data(tkw->dgl_copy, &tkw->sample.dataLength);
	} else {
		tkw->sample.data = (char *)gf_filter_pck_get_data(pck, &tkw->sample.dataLength);
	}

	ctx->update_report = GF_TRUE;
	ctx->total_bytes_in += tkw->sample.dataLength;
	ctx->total_samples++;

	tkw->sample.DTS = gf_filter_pck_get_dts(pck);
	cts = gf_filter_pck_get_cts(pck);

	if (tkw->sample.DTS == GF_FILTER_NO_TS) {
		if (cts == GF_FILTER_NO_TS) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Sample with no DTS/CTS, cannot add (last DTS "LLU", last size %d)\n", prev_dts, prev_size ));
			return GF_NON_COMPLIANT_BITSTREAM;
		} else {
			u32 min_pck_dur = gf_filter_pid_get_min_pck_duration(tkw->ipid);
			if (min_pck_dur) {
				tkw->sample.DTS = prev_dts;
				//transform back to inpput timescale
				if (timescale != tkw->tk_timescale) {
					tkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, tkw->tk_timescale, timescale);
				}
				tkw->sample.DTS += min_pck_dur;
			} else {
				tkw->sample.DTS = cts;
			}
		}
	} else {
		tkw->sample.CTS_Offset = (s32) ((s64) cts - (s64) tkw->sample.DTS);
	}

	//do our best to patch init ts if timing config aborted
	if (tkw->si_min_ts_plus_one) {
		u64 si_min_ts = tkw->si_min_ts_plus_one - 1;
		tkw->si_min_ts_plus_one = 0;
		tkw->ts_shift = tkw->sample.DTS;
		mp4_mux_update_init_edit(ctx, tkw, si_min_ts, GF_FALSE);
	}
	//tkw->ts_shift is in source timescale, apply it before rescaling TSs/duration
	if (tkw->ts_shift) {
		if (ctx->is_rewind) {
			if (tkw->sample.DTS <= tkw->ts_shift) {
				tkw->sample.DTS = tkw->ts_shift - tkw->sample.DTS;
				cts = tkw->ts_shift - cts;
			} else {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] broken timing in track, initial ts "LLU" less than TS "LLU"\n", tkw->ts_shift, tkw->sample.DTS));
				sample_timing_ok = GF_FALSE;
			}
		} else {
			if (tkw->sample.DTS >= tkw->ts_shift) {
				tkw->sample.DTS -= tkw->ts_shift;
				cts -= tkw->ts_shift;
			} else {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] broken timing in track, initial ts "LLU" greater than TS "LLU"\n", tkw->ts_shift, tkw->sample.DTS));
				sample_timing_ok = GF_FALSE;
			}
		}
	}

	//sample-accurate seek info, start logging min CTS of packets marked as non-sync
	if (tkw->check_seek_ts && !gf_filter_pck_get_seek_flag(pck)) {
		u64 ts_check = cts;
		subs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_BEGIN);
		if (subs)
			ts_check += subs->value.uint;

		if (!tkw->min_ts_seek_plus_one) {
			tkw->min_ts_seek_plus_one = ts_check + 1;
		} else if (tkw->min_ts_seek_plus_one > ts_check + 1) {
			tkw->min_ts_seek_plus_one = ts_check + 1;
		} else {
			//TS is greater than last non-seek packet TS, we're done seeking
			tkw->check_seek_ts = GF_FALSE;
		}
	}

	duration = gf_filter_pck_get_duration(pck);
	if (timescale != tkw->tk_timescale) {
		s64 ctso;
		tkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, timescale, tkw->tk_timescale);

		ctso = (s64) tkw->sample.CTS_Offset;
		ctso *= tkw->tk_timescale;
		ctso /= timescale;
		tkw->sample.CTS_Offset = (s32) ctso;
		duration *= tkw->tk_timescale;
		duration /= timescale;

		if (cts != GF_FILTER_NO_TS) {
			cts = gf_timestamp_rescale(cts, timescale, tkw->tk_timescale);
		}
	}

	tkw->sample.IsRAP = 0;
	if (tkw->codecid==GF_CODECID_RAW) {
		sap_type = GF_FILTER_SAP_1;
	} else {
		sap_type = mp4_mux_get_sap(ctx, pck);

		//if pps inband mode is used, turn sap3 into sap1
		if ((tkw->xps_inband==XPS_IB_PPS) && sap_type==GF_FILTER_SAP_3)
			sap_type=GF_FILTER_SAP_1;
	}
	if (sap_type==GF_FILTER_SAP_1)
		tkw->sample.IsRAP = SAP_TYPE_1;
	else if (sap_type==GF_FILTER_SAP_2)
		tkw->sample.IsRAP = SAP_TYPE_2;
	else if ( (sap_type == GF_FILTER_SAP_4) && (tkw->stream_type != GF_STREAM_VISUAL) )
		tkw->sample.IsRAP = SAP_TYPE_1;

	/*RFC8216bis is not clear here:
	"if the Partial Segment contains an independent frame."
		-> this would allow SAP1,2,3 (independent being only defined for segments)

	but

	"Partial Segment containing an independent frame SHOULD carry it to increase the efficiency with which clients can join and switch Renditions"
		-> if used for switching, this only allows SAP 1 and 2

	Spec should be fixed to allow for both cases (fast tune-in or in-segment switchingÃ )
	*/
	if ((tkw->sample.IsRAP == SAP_TYPE_1) || (tkw->sample.IsRAP == SAP_TYPE_2))
		ctx->frag_has_intra = GF_TRUE;

	tkw->sample.DTS += tkw->dts_patch;
	if (tkw->nb_samples && (prev_dts >= tkw->sample.DTS) ) {
		//the fragmented API will patch the duration on the fly
		if (!for_fragment && ctx->patch_dts) {
			gf_isom_patch_last_sample_duration(ctx->file, tkw->track_num, prev_dts ? prev_dts : 1);
		}
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] PID %s ID %d Sample %d with DTS "LLU" less than previous sample DTS "LLU", patching DTS%s\n", gf_filter_pid_get_name(tkw->ipid), tkw->track_id, tkw->nb_samples+1, tkw->sample.DTS, prev_dts, ctx->patch_dts ? "and adjusting prev sample duration" : "" ));
		sample_timing_ok = GF_FALSE;

		if (prev_dts) {
			tkw->dts_patch = prev_dts - tkw->sample.DTS;
			tkw->sample.DTS += tkw->dts_patch+1; //+1 to avoid 0-dur samples
		} else {
			tkw->sample.DTS += 1;
			if (tkw->sample.CTS_Offset) tkw->sample.CTS_Offset -= 1;
			duration-=1;
		}
	}


	if (tkw->negctts_shift)
		tkw->sample.CTS_Offset -= tkw->negctts_shift;

	if (sample_timing_ok) {
		if (tkw->probe_min_ctts) {
			s32 diff = (s32) ((s64) cts - (s64) tkw->sample.DTS);
			if (diff < tkw->min_neg_ctts)
				tkw->min_neg_ctts = diff;
		}
		if (tkw->sample.CTS_Offset) tkw->has_ctts = GF_TRUE;

		if (tkw->sample.CTS_Offset < tkw->min_neg_ctts)
			tkw->min_neg_ctts = tkw->sample.CTS_Offset;
	}

	tkw->sample.nb_pack = 0;
	if (tkw->raw_audio_bytes_per_sample) {
		tkw->sample.nb_pack = tkw->sample.dataLength / tkw->raw_audio_bytes_per_sample;
		if (tkw->sample.nb_pack) {
			duration = 1;
			if (tkw->raw_samplerate && (tkw->tk_timescale != tkw->raw_samplerate)) {
				duration *= tkw->tk_timescale;
				duration /= tkw->raw_samplerate;
			}
		}
	}

	if (tkw->cenc_state && tkw->clear_stsd_idx && !gf_filter_pck_get_crypt_flags(pck)) {
		sample_desc_index = tkw->clear_stsd_idx;
	}

	if (tkw->sparse_inject && (prev_dts!=GF_FILTER_NO_TS) && (tkw->sample.DTS!=GF_FILTER_NO_TS) && tkw->prev_duration) {
		u64 est_time = prev_dts + tkw->prev_duration;
		if (est_time < tkw->sample.DTS) {
			u32 ins_dur;
			GF_ISOSample s;
			memset(&s, 0, sizeof(GF_ISOSample));
			s.DTS = est_time;

			s.IsRAP = SAP_TYPE_1;
			ins_dur = (u32) (tkw->sample.DTS - est_time);
			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				e = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &s, tkw->stsd_idx, ins_dur, 0, 0, 0);
#else
				e = GF_NOT_SUPPORTED;
#endif
			} else {
				e = gf_isom_add_sample(ctx->file, tkw->track_num, tkw->stsd_idx, &s);
				gf_isom_set_last_sample_duration(ctx->file, tkw->track_num, ins_dur);
			}
		}
	}

	if (tkw->use_dref) {
		u64 data_offset = gf_filter_pck_get_byte_offset(pck);
		if (data_offset != GF_FILTER_NO_BO) {
			e = gf_isom_add_sample_reference(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample, data_offset);
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to add sample DTS "LLU" from %s as reference: %s\n", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), gf_error_to_string(e) ));
			}
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Cannot add sample reference at DTS "LLU" , input sample data is not continous in source\n", tkw->sample.DTS ));
		}
	} else if (tkw->nb_frames_per_sample && (tkw->nb_samples % tkw->nb_frames_per_sample)) {
		if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
		 	e = gf_isom_fragment_append_data(ctx->file, tkw->track_id, tkw->sample.data, tkw->sample.dataLength, 0);
#else
			e = GF_NOT_SUPPORTED;
#endif
		} else {
			e = gf_isom_append_sample_data(ctx->file, tkw->track_num, tkw->sample.data, tkw->sample.dataLength);
		}
		tkw->has_append = GF_TRUE;
		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to append sample DTS "LLU" data: %s\n", tkw->sample.DTS, gf_error_to_string(e) ));
		}
	} else {
		Bool inject_pps = ctx->pps_inband;
		if (ctx->xps_inband==XPS_IB_AUTO) {
			const GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_XPS_MASK);
			if (p && (p->value.uint & (1<<2) ) )
				inject_pps = GF_TRUE;
		}

		if ((tkw->sample.IsRAP || tkw->force_inband_inject || inject_pps) && tkw->xps_inband) {
			u8 *inband_xps;
			u32 inband_xps_size;
			char *au_delim=NULL;
			u32 au_delim_size=0;
			char *pck_data = tkw->sample.data;
			u32 pck_data_len = tkw->sample.dataLength;
			if (tkw->sample.IsRAP || tkw->force_inband_inject) {
				inband_xps = tkw->inband_hdr;
				inband_xps_size = tkw->inband_hdr_size;
				tkw->force_inband_inject = GF_FALSE;
			} else {
				inband_xps = tkw->inband_hdr_non_rap;
				inband_xps_size = tkw->inband_hdr_non_rap_size;
			}
			tkw->sample.data = inband_xps;
			tkw->sample.dataLength = inband_xps_size;

			if (tkw->is_nalu==NALU_AVC) {
				if (pck_data_len >= 2 + tkw->nal_unit_size) {
					char *nal = pck_data + tkw->nal_unit_size;
					if ((nal[0] & 0x1F) == GF_AVC_NALU_ACCESS_UNIT) {
						first_nal_is_audelim = au_delim_size = 2 + tkw->nal_unit_size;
						au_delim = pck_data;
						if (au_delim_size >= pck_data_len) au_delim = NULL;
					}
				}
			} else {
				if (pck_data_len >= 3 + tkw->nal_unit_size) {
					char *nal = pck_data + tkw->nal_unit_size;
					if (((nal[0] & 0x7E)>>1) == GF_HEVC_NALU_ACCESS_UNIT) {
						first_nal_is_audelim = au_delim_size = 3 + tkw->nal_unit_size;
						au_delim = pck_data;
						if (au_delim_size >= pck_data_len) au_delim = NULL;
					}
				}
			}

			if (au_delim) {
				tkw->sample.data = au_delim;
				tkw->sample.dataLength = au_delim_size;
				pck_data += au_delim_size;
				pck_data_len -= au_delim_size;
			}

			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				//force using ref mode
				void *ref=NULL;
				e = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, &ref, 0);
				if (!e && au_delim) {
					e = gf_isom_fragment_append_data(ctx->file, tkw->track_id, inband_xps, inband_xps_size, 0);
				}
				if (!e) {
					if (gf_filter_pck_is_blocking_ref(pck)) {
						e = gf_isom_fragment_append_data(ctx->file, tkw->track_id, pck_data, pck_data_len, 0);
					} else {
						gf_filter_pck_ref(&pck);
						GF_FilterPacket *ref = pck;
						e = gf_isom_fragment_append_data_ex(ctx->file, tkw->track_id, pck_data, pck_data_len, 0, (void**)&ref, au_delim ? au_delim_size : 0);
						if (!ref) {
							gf_list_add(ctx->ref_pcks, pck);
						} else {
							gf_filter_pck_unref(pck);
						}
					}
				}
#else
				e = GF_NOT_SUPPORTED;
#endif // GPAC_DISABLE_ISOM_FRAGMENTS
			} else {
				e = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);
				if (au_delim && !e) {
					e = gf_isom_append_sample_data(ctx->file, tkw->track_num, inband_xps, inband_xps_size);
				}
				if (!e) e = gf_isom_append_sample_data(ctx->file, tkw->track_num, pck_data, pck_data_len);
			}
			insert_subsample_dsi_size = inband_xps_size;
		} else if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
			if (gf_filter_pck_is_blocking_ref(pck)) {
				e = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0);
			} else {
				gf_filter_pck_ref(&pck);
				GF_FilterPacket *ref = pck;
				e = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, (void**) &ref, 0);
				if (!ref) {
					gf_list_add(ctx->ref_pcks, pck);
				} else {
					gf_filter_pck_unref(pck);
				}
			}
#else
			e = GF_NOT_SUPPORTED;
#endif // GPAC_DISABLE_ISOM_FRAGMENTS
		} else {
			e = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);
			if (!e && !duration) {
				gf_isom_set_last_sample_duration(ctx->file, tkw->track_num, 0);
			}
		}

		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to add sample DTS "LLU" from %s - prev DTS "LLU": %s\n", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), prev_dts, gf_error_to_string(e) ));
		} else {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[MP4Mux] added sample DTS "LLU" - prev DTS "LLU" - prev size %d\n", tkw->sample.DTS, prev_dts, prev_size));
		}

		if (!e && tkw->cenc_state) {
			e = mp4_mux_cenc_update(ctx, tkw, pck, for_fragment ? CENC_ADD_FRAG : CENC_ADD_NORMAL, tkw->sample.dataLength, insert_subsample_dsi_size);
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set sample CENC information: %s\n", gf_error_to_string(e) ));
			}
		}
	}

	tkw->nb_samples++;
	tkw->samples_in_stsd++;
	tkw->samples_in_frag++;

	if (e) return e;

	if (!for_fragment && sample_timing_ok) {
		u64 samp_cts;
		if (!tkw->clamp_ts_plus_one) {
			const GF_PropertyValue *skp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_PRES);
			if (skp && skp->value.boolean) {
				tkw->clamp_ts_plus_one = 1 + tkw->sample.DTS + tkw->sample.CTS_Offset;
			}
		}
		//store min max cts for edit list updates
		samp_cts = tkw->sample.DTS + tkw->sample.CTS_Offset;
		if (!tkw->clamp_ts_plus_one || (samp_cts + 1 < tkw->clamp_ts_plus_one)) {
			if (samp_cts > tkw->max_cts) {
				tkw->max_cts = samp_cts;
				tkw->max_cts_samp_dur = duration;
			}

			if (tkw->min_cts > samp_cts)
				tkw->min_cts = samp_cts;
		}
	}

	//compat with old arch: write sample to group info for all samples
	if ((sap_type==3) || tkw->has_open_gop)  {
		if (!ctx->norap) {
			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				e = gf_isom_fragment_set_sample_rap_group(ctx->file, tkw->track_id, tkw->samples_in_frag, (sap_type==3) ? GF_TRUE : GF_FALSE, 0);
#else
				e = GF_NOT_SUPPORTED;
#endif
			} else if (sap_type==3) {
				e = gf_isom_set_sample_rap_group(ctx->file, tkw->track_num, tkw->nb_samples, GF_TRUE /*(sap_type==3) ? GF_TRUE : GF_FALSE*/, 0);
			}
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set sample DTS "LLU" SAP 3 in RAP group: %s\n", tkw->sample.DTS, gf_error_to_string(e) ));
			}
		}
		tkw->has_open_gop = GF_TRUE;
	}
	if (!ctx->noroll) {
		if ((sap_type==GF_FILTER_SAP_4) || (sap_type==GF_FILTER_SAP_4_PROL) || tkw->gdr_type) {
			GF_ISOSampleRollType roll_type = 0;
			s16 roll = gf_filter_pck_get_roll_info(pck);
			if (sap_type==GF_FILTER_SAP_4) roll_type = GF_ISOM_SAMPLE_ROLL;
			else if (sap_type==GF_FILTER_SAP_4_PROL) roll_type = GF_ISOM_SAMPLE_PREROLL;
			else if (tkw->gdr_type==GF_FILTER_SAP_4_PROL) {
				roll_type = GF_ISOM_SAMPLE_PREROLL_NONE;
			}

			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				e = gf_isom_fragment_set_sample_roll_group(ctx->file, tkw->track_id, tkw->samples_in_frag, roll_type, roll);
#else
				e = GF_NOT_SUPPORTED;
#endif
			} else {
				e = gf_isom_set_sample_roll_group(ctx->file, tkw->track_num, tkw->nb_samples, roll_type, roll);
			}
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set sample DTS "LLU" SAP 4 roll %s in roll group: %s\n", tkw->sample.DTS, roll, gf_error_to_string(e) ));
			}
			if (sap_type && !tkw->gdr_type)
				tkw->gdr_type = sap_type;
		}
	}

	subs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);
	if (subs) {
		//if no AUDelim nal and inband header injection, push new subsample
		if (!first_nal_is_audelim && insert_subsample_dsi_size) {
			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				gf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);
#endif
			} else {
				gf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);
			}
			insert_subsample_dsi_size = 0;
		}
		tkw->has_subs = GF_TRUE;

		if (!ctx->bs_r) ctx->bs_r = gf_bs_new(subs->value.data.ptr, subs->value.data.size, GF_BITSTREAM_READ);
		else gf_bs_reassign_buffer(ctx->bs_r, subs->value.data.ptr, subs->value.data.size);

		while (gf_bs_available(ctx->bs_r)) {
			u32 flags = gf_bs_read_u32(ctx->bs_r);
			u32 subs_size = gf_bs_read_u32(ctx->bs_r);
			u32 reserved = gf_bs_read_u32(ctx->bs_r);
			u8 priority = gf_bs_read_u8(ctx->bs_r);
			u8 discardable = gf_bs_read_u8(ctx->bs_r);

			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				gf_isom_fragment_add_subsample(ctx->file, tkw->track_id, flags, subs_size, priority, reserved, discardable);
#endif
			} else {
				gf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, flags, subs_size, priority, reserved, discardable);
			}

			//we have AUDelim nal and inband header injection, push new subsample for inband header once we have pushed the first subsample (au delim)
			if (insert_subsample_dsi_size) {
				if (first_nal_is_audelim != subs_size) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] inserting inband param after AU delimiter NALU, but sample has subsample information not aligned on NALU (got %d subsample size but expecting %d) - file might be broken!\n", subs_size, first_nal_is_audelim));
				}
				if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
					gf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);
#endif
				} else {
					gf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);
				}
				insert_subsample_dsi_size = GF_FALSE;
			}
		}
	} else if (for_fragment && tkw->has_subs && ctx->cmaf && (tkw->codecid==GF_CODECID_SUBS_XML)) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
		//tentative implemntation of CMAF 7.5.20 which is just nonsense text !!:
		//"the value of subsample_count shall equal 1 for the first image sub-sample, and the subsample_count of the TTML document shall equal 0."
		//
		//we simply signal a single subsample
		gf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, tkw->sample.dataLength, 0, 0, 0);
#endif
	}

	if (ctx->deps) {
		u8 dep_flags = gf_filter_pck_get_dependency_flags(pck);
		if (dep_flags) {
			u32 is_leading = (dep_flags>>6) & 0x3;
			u32 depends_on = (dep_flags>>4) & 0x3;
			u32 depended_on = (dep_flags>>2) & 0x3;
			u32 redundant = (dep_flags) & 0x3;
			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				gf_isom_fragment_set_sample_flags(ctx->file, tkw->track_id, is_leading, depends_on, depended_on, redundant);
#endif
			} else {
				gf_isom_set_sample_flags(ctx->file, tkw->track_num, tkw->nb_samples, is_leading, depends_on, depended_on, redundant);
			}
		}
	}

	u32 idx = 0;
	while (1) {
		Bool is_sample_group=GF_FALSE;
		u32 aux_type=0, aux_info=0, sg_flags=0;
		u32 p4cc;
		const char *pname=NULL;
		const GF_PropertyValue *p = gf_filter_pck_enum_properties(pck, &idx, &p4cc, &pname);
		if (!p) break;
		if ((p->type!=GF_PROP_DATA) && (p->type!=GF_PROP_CONST_DATA)) continue;
		if (!p->value.data.size || !p->value.data.ptr) continue;
		if (!pname) continue;

		if (!strncmp(pname, "sai_", 4)) {

		} else if (!strncmp(pname, "grp_", 4)) {
			//discard emsg if fragmented, otherwise add as internal sample group - TODO, support for EventMessage tracks
			if (!strcmp(pname, "grp_EMSG") && (ctx->store>=MP4MX_MODE_FRAG)) continue;
			is_sample_group = GF_TRUE;
		} else {
			continue;
		}

		pname+=4;
		u32 plen = (u32) strlen(pname);
		if (plen==3) {
			aux_type = GF_4CC(pname[0], pname[1], pname[2], ' ');
			pname+=3;
		} else if (plen >= 4) {
			aux_type = GF_4CC(pname[0], pname[1], pname[2], pname[3]);
			pname+=4;
		} else {
			continue;
		}
		if (pname[0] == '_') {
			if (is_sample_group) {
				char *flags = strstr(pname, "_z");
				if (flags) flags[0]=0;
				if (pname[0]) aux_info = atoi(pname);
				if (flags) {
					sscanf(flags+2, "%x", &sg_flags);
					flags[0]='_';
				}
			} else {
				aux_info = atoi(pname);
			}
		}
		if (!aux_type) continue;

		if (is_sample_group) {
			if (aux_type==GF_ISOM_SAMPLE_GROUP_ESGH) {
				GF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type);
				gf_isom_set_sample_description_restricted(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC( 'e', 's', 's', 'g'));

				sg_flags |= 0x40000000;
			}

			gf_isom_set_sample_group_description(ctx->file, tkw->track_num, for_fragment ? 0 : tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size, sg_flags);

		} else {
			if (for_fragment) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				gf_isom_fragment_set_sample_aux_info(ctx->file, tkw->track_id, tkw->samples_in_frag, aux_type, aux_info, p->value.data.ptr, p->value.data.size);
#endif
			} else {
				gf_isom_add_sample_aux_info(ctx->file, tkw->track_num, tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size);
			}
		}
	}

	tkw->prev_duration = duration;
	if (duration && !for_fragment && !tkw->raw_audio_bytes_per_sample)
		gf_isom_set_last_sample_duration(ctx->file, tkw->track_num, duration);

	if (ctx->dur.num) {
		Bool abort = GF_FALSE;
		if (ctx->dur.num>0) {
			u64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);

			/*patch to align to old arch */
			if (gf_sys_old_arch_compat()) {
				if (tkw->stream_type==GF_STREAM_VISUAL) {
					mdur = tkw->sample.DTS;
				}
			}
			//adjust if shift is below half sec (to take AV delay into account)
			//if larger, we imported from non-0 initial ts, do not compensate
			else if (tkw->ts_shift<tkw->tk_timescale/2) {
				mdur += tkw->ts_shift;
			}

			if (ctx->importer) {
				tkw->prog_done = mdur * ctx->dur.den;
				tkw->prog_total =  ((u64)tkw->tk_timescale) * ctx->dur.num;
			}

			/*patch to align to old arch */
			if (gf_sys_old_arch_compat()) {
				if (gf_timestamp_greater(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))
					abort = GF_TRUE;
			} else {
				if (gf_timestamp_greater_or_equal(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))
					abort = GF_TRUE;
			}
		} else {
			if ((s32) tkw->nb_samples >= -ctx->dur.num)
				abort = GF_TRUE;
		}

		if (abort) {
			GF_FilterEvent evt;
			GF_FEVT_INIT(evt, GF_FEVT_STOP, tkw->ipid);
			gf_filter_pid_send_event(tkw->ipid, &evt);

			tkw->aborted = GF_TRUE;
		}
	} else if (ctx->importer) {
		if (tkw->nb_frames) {
			tkw->prog_done = tkw->nb_samples + tkw->frame_offset;
			tkw->prog_total = tkw->nb_frames;
		} else {
			u64 data_offset = gf_filter_pck_get_byte_offset(pck);
			if (data_offset == GF_FILTER_NO_BO) {
				data_offset = tkw->down_bytes;
			}
			if ((data_offset != GF_FILTER_NO_BO) && tkw->down_size) {
				tkw->prog_done = data_offset;
				tkw->prog_total = tkw->down_size;
			} else {
				if (tkw->pid_dur.den && tkw->pid_dur.num) {
					tkw->prog_done = tkw->sample.DTS * tkw->pid_dur.den;
					tkw->prog_total = tkw->pid_dur.num * tkw->tk_timescale;
				} else {
					tkw->prog_done = 0;
					tkw->prog_total = 1;
				}

			}
		}
	}
	return GF_OK;
}
