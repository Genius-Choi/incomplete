void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {
  ASSERT(!upstream_request.retried());
  // Track this as a timeout for outlier detection purposes even though we didn't
  // cancel the request yet and might get a 2xx later.
  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,
                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));
  upstream_request.outlierDetectionTimeoutRecorded(true);

  if (!downstream_response_started_ && retry_state_) {
    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(
        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {
          // Without any knowledge about what's going on in the connection pool, retry the request
          // with the safest settings which is no early data but keep using or not using alt-svc as
          // before. In this way, QUIC won't be falsely marked as broken.
          doRetry(/*can_send_early_data*/ false, can_use_http3, TimeoutRetry::Yes);
        });

    if (retry_status == RetryStatus::Yes) {
      runRetryOptionsPredicates(upstream_request);
      pending_retries_++;

      // Don't increment upstream_host->stats().rq_error_ here, we'll do that
      // later if 1) we hit global timeout or 2) we get bad response headers
      // back.
      upstream_request.retried(true);

      // TODO: cluster stat for hedge attempted.
    } else if (retry_status == RetryStatus::NoOverflow) {
      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);
    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {
      callbacks_->streamInfo().setResponseFlag(
          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);
    }
  }
}
