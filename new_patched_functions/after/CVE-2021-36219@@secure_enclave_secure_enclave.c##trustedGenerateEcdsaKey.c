void trustedGenerateEcdsaKey(int *errStatus, char *errString,
                        uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {

    LOG_DEBUG (__FUNCTION__);

    domain_parameters curve = domain_parameters_init();
    domain_parameters_load_curve(curve, secp256k1);

    unsigned char *rand_char = (unsigned char *) calloc(32, 1);
    sgx_read_rand(rand_char, 32);

    mpz_t seed;
    mpz_init(seed);
    mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);

    free(rand_char);

    mpz_t skey;
    mpz_init(skey);
    mpz_mod(skey, seed, curve->p);
    mpz_clear(seed);

    //mpz_set_str(skey, "e7af72d241d4dd77bc080ce9234d742f6b22e35b3a660e8c197517b909f63ca8", 16);
    //mpz_set_str(skey, "4160780231445160889237664391382223604576", 10);
    //mpz_set_str(skey, "4160780231445160889237664391382223604184857153814275770598791864649971919844", 10);
    //mpz_set_str(skey, "1", 10);
    //mpz_set_str(skey, "ebb2c082fd7727890a28ac82f6bdf97bad8de9f5d7c9028692de1a255cad3e0f", 16);
    // mpz_set_str(skey, "D30519BCAE8D180DBFCC94FE0B8383DC310185B0BE97B4365083EBCECCD75759", 16);

    //Public key
    point Pkey = point_init();

    signature_extract_public_key(Pkey, skey, curve);

    uint8_t base = 16;

    int len = mpz_sizeinbase(Pkey->x, base) + 2;
    //snprintf(errString, BUF_LEN, "len = %d\n", len);
    char arr_x[len];
    char *px = mpz_get_str(arr_x, base, Pkey->x);
    //snprintf(errString, BUF_LEN, "arr=%p px=%p\n", arr_x, px);
    int n_zeroes = 64 - strlen(arr_x);
    for (int i = 0; i < n_zeroes; i++) {
        pub_key_x[i] = '0';
    }

    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);

    char arr_y[mpz_sizeinbase(Pkey->y, base) + 2];
    char *py = mpz_get_str(arr_y, base, Pkey->y);
    n_zeroes = 64 - strlen(arr_y);
    for (int i = 0; i < n_zeroes; i++) {
        pub_key_y[i] = '0';
    }
    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);
    char skey_str[mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2];
    char *s = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);
    snprintf(errString, BUF_LEN, "skey is %s len %d\n", skey_str, strlen(skey_str));

    uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);

    sgx_status_t status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *) skey_str, sealedLen,
                                        (sgx_sealed_data_t *) encryptedPrivateKey);
    if (status != SGX_SUCCESS) {
        snprintf(errString, BUF_LEN, "seal ecsdsa private key failed");
        *errStatus = status;
        return;
    }

    *enc_len = sealedLen;

    mpz_clear(skey);
    domain_parameters_clear(curve);
    point_clear(Pkey);
}
