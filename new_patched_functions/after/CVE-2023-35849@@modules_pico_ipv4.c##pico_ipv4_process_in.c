static int pico_ipv4_process_in(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)
{
    uint8_t option_len = 0;
    int ret = 0;
    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;
    uint16_t max_allowed = (uint16_t) ((int)f->buffer_len - (f->net_hdr - f->buffer) - (int)PICO_SIZE_IP4HDR);

    if (!hdr)
        return -1;

    (void)self;

    /* NAT needs transport header information */
    if (((hdr->vhl) & 0x0F) > 5) {
        option_len =  (uint8_t)(4 * (((hdr->vhl) & 0x0F) - 5));
    }

    f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;
    f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);
    f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);

    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {
        pico_frame_discard(f);
        return 0;
    }
#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)
    f->frag = short_be(hdr->frag);
#endif

    if (f->transport_len > max_allowed) {
        pico_frame_discard(f);
        return 0; /* Packet is discarded due to unfeasible length */
    }

#ifdef PICO_SUPPORT_IPFILTER
    if (ipfilter(f)) {
        /*pico_frame is discarded as result of the filtering*/
        return 0;
    }

#endif
    /* ret == 1 indicates to continue the function */
    ret = pico_ipv4_crc_check(f);
    if (ret < 1)
        return ret;

    /* Validate source IP address. Discard quietly if invalid */
    if (!pico_ipv4_is_valid_src(S, hdr->src.addr, f->dev)) {
        pico_frame_discard(f);
        return 0;
    }

#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)
    if (f->frag & PICO_IPV4_EVIL) {
        (void)pico_icmp4_param_problem(S, f, 0);
        pico_frame_discard(f); /* RFC 3514 */
        return 0;
    }
#endif

    if ((hdr->vhl & 0x0f) < 5) {
        /* RFC 791: IHL minimum value is 5 */
        (void)pico_icmp4_param_problem(S, f, 0);
        pico_frame_discard(f);
        return 0;
    }

#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)
    if (f->frag & (PICO_IPV4_MOREFRAG | PICO_IPV4_FRAG_MASK))
    {
#ifdef PICO_SUPPORT_IPV4FRAG
        pico_ipv4_process_frag(hdr, f, hdr->proto);
        /* Frame can be discarded, frag will handle its own copy */
#endif
        /* We do not support fragmentation, discard quietly */
        pico_frame_discard(f);
        return 0;
    }
#endif

#ifdef PICO_SUPPORT_RAWSOCKETS
    pico_socket_ipv4_process_in(f);
#endif

    if (pico_ipv4_process_bcast_in(S, f) > 0)
        return 0;

    if (pico_ipv4_process_mcast_in(f) > 0)
        return 0;

    if (pico_ipv4_process_local_unicast_in(S, f) > 0)
        return 0;

    pico_ipv4_process_finally_try_forward(S, f);

    return 0;
}
