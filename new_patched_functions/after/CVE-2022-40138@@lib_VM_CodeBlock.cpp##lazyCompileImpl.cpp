ExecutionStatus CodeBlock::lazyCompileImpl(Runtime &runtime) {
  assert(isLazy() && "Laziness has not been checked");
  PerfSection perf("Lazy function compilation");
  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();
  auto *func = provider->getBytecodeFunction();
  auto *lazyData = func->getLazyCompilationData();
  SourceErrorManager &manager = lazyData->context->getSourceErrorManager();
  SimpleDiagHandlerRAII outputManager{manager};
  auto bcModule = compileLazyFunction(lazyData);

  if (manager.getErrorCount()) {
    // Raise a SyntaxError to be consistent with eval().
    return runtime.raiseSyntaxError(
        llvh::StringRef{outputManager.getErrorString()});
  }

  assert(bcModule && "No errors, yet no bcModule");

  runtimeModule_->initializeLazyMayAllocate(
      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));
  // Reset all meta lazyData of the CodeBlock to point to the newly
  // generated bytecode module.
  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();
  functionHeader_ =
      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);
  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);

  return ExecutionStatus::RETURNED;
}
