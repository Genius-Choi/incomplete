S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
{
    regnode_offset ret = 0;
    I32 flags = 0;
    char *parse_start;
    U8 op;
    int invert = 0;

    DECLARE_AND_GET_RE_DEBUG_FLAGS;

    *flagp = 0;		/* Initialize. */

    DEBUG_PARSE("atom");

    PERL_ARGS_ASSERT_REGATOM;

  tryagain:
    parse_start = RExC_parse;
    assert(RExC_parse < RExC_end);
    switch ((U8)*RExC_parse) {
    case '^':
	RExC_seen_zerolen++;
	nextchar(pRExC_state);
	if (RExC_flags & RXf_PMf_MULTILINE)
	    ret = reg_node(pRExC_state, MBOL);
	else
	    ret = reg_node(pRExC_state, SBOL);
        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */
	break;
    case '$':
	nextchar(pRExC_state);
	if (*RExC_parse)
	    RExC_seen_zerolen++;
	if (RExC_flags & RXf_PMf_MULTILINE)
	    ret = reg_node(pRExC_state, MEOL);
	else
	    ret = reg_node(pRExC_state, SEOL);
        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */
	break;
    case '.':
	nextchar(pRExC_state);
	if (RExC_flags & RXf_PMf_SINGLELINE)
	    ret = reg_node(pRExC_state, SANY);
	else
	    ret = reg_node(pRExC_state, REG_ANY);
	*flagp |= HASWIDTH|SIMPLE;
	MARK_NAUGHTY(1);
        Set_Node_Length(REGNODE_p(ret), 1); /* MJD */
	break;
    case '[':
    {
	char * const oregcomp_parse = ++RExC_parse;
        ret = regclass(pRExC_state, flagp, depth+1,
                       FALSE, /* means parse the whole char class */
                       TRUE, /* allow multi-char folds */
                       FALSE, /* don't silence non-portable warnings. */
                       (bool) RExC_strict,
                       TRUE, /* Allow an optimized regnode result */
                       NULL);
        if (ret == 0) {
            RETURN_FAIL_ON_RESTART_FLAGP(flagp);
            FAIL2("panic: regclass returned failure to regatom, flags=%#" UVxf,
                  (UV) *flagp);
        }
	if (*RExC_parse != ']') {
	    RExC_parse = oregcomp_parse;
	    vFAIL("Unmatched [");
	}
	nextchar(pRExC_state);
        Set_Node_Length(REGNODE_p(ret), RExC_parse - oregcomp_parse + 1); /* MJD */
	break;
    }
    case '(':
	nextchar(pRExC_state);
        ret = reg(pRExC_state, 2, &flags, depth+1);
	if (ret == 0) {
		if (flags & TRYAGAIN) {
		    if (RExC_parse >= RExC_end) {
			 /* Make parent create an empty node if needed. */
			*flagp |= TRYAGAIN;
			return(0);
		    }
		    goto tryagain;
		}
                RETURN_FAIL_ON_RESTART(flags, flagp);
                FAIL2("panic: reg returned failure to regatom, flags=%#" UVxf,
                                                                 (UV) flags);
	}
	*flagp |= flags&(HASWIDTH|SIMPLE|POSTPONED);
	break;
    case '|':
    case ')':
	if (flags & TRYAGAIN) {
	    *flagp |= TRYAGAIN;
	    return 0;
	}
	vFAIL("Internal urp");
				/* Supposed to be caught earlier. */
	break;
    case '?':
    case '+':
    case '*':
	RExC_parse++;
	vFAIL("Quantifier follows nothing");
	break;
    case '\\':
	/* Special Escapes

	   This switch handles escape sequences that resolve to some kind
	   of special regop and not to literal text. Escape sequences that
	   resolve to literal text are handled below in the switch marked
	   "Literal Escapes".

	   Every entry in this switch *must* have a corresponding entry
	   in the literal escape switch. However, the opposite is not
	   required, as the default for this switch is to jump to the
	   literal text handling code.
	*/
	RExC_parse++;
	switch ((U8)*RExC_parse) {
	/* Special Escapes */
	case 'A':
	    RExC_seen_zerolen++;
            /* Under wildcards, this is changed to match \n; should be
             * invisible to the user, as they have to compile under /m */
            if (RExC_pm_flags & PMf_WILDCARD) {
                ret = reg_node(pRExC_state, MBOL);
            }
            else {
                ret = reg_node(pRExC_state, SBOL);
                /* SBOL is shared with /^/ so we set the flags so we can tell
                 * /\A/ from /^/ in split. */
                FLAGS(REGNODE_p(ret)) = 1;
            }
	    goto finish_meta_pat;
	case 'G':
            if (RExC_pm_flags & PMf_WILDCARD) {
                RExC_parse++;
                /* diag_listed_as: Use of %s is not allowed in Unicode property
                   wildcard subpatterns in regex; marked by <-- HERE in m/%s/
                 */
                vFAIL("Use of '\\G' is not allowed in Unicode property"
                      " wildcard subpatterns");
            }
	    ret = reg_node(pRExC_state, GPOS);
            RExC_seen |= REG_GPOS_SEEN;
	    goto finish_meta_pat;
	case 'K':
            if (!RExC_in_lookaround) {
                RExC_seen_zerolen++;
                ret = reg_node(pRExC_state, KEEPS);
                /* XXX:dmq : disabling in-place substitution seems to
                 * be necessary here to avoid cases of memory corruption, as
                 * with: C<$_="x" x 80; s/x\K/y/> -- rgs
                 */
                RExC_seen |= REG_LOOKBEHIND_SEEN;
                goto finish_meta_pat;
            }
            else {
                ++RExC_parse; /* advance past the 'K' */
                vFAIL("\\K not permitted in lookahead/lookbehind");
            }
	case 'Z':
            if (RExC_pm_flags & PMf_WILDCARD) {
                /* See comment under \A above */
                ret = reg_node(pRExC_state, MEOL);
            }
            else {
                ret = reg_node(pRExC_state, SEOL);
            }
	    RExC_seen_zerolen++;		/* Do not optimize RE away */
	    goto finish_meta_pat;
	case 'z':
            if (RExC_pm_flags & PMf_WILDCARD) {
                /* See comment under \A above */
                ret = reg_node(pRExC_state, MEOL);
            }
            else {
                ret = reg_node(pRExC_state, EOS);
            }
	    RExC_seen_zerolen++;		/* Do not optimize RE away */
	    goto finish_meta_pat;
	case 'C':
	    vFAIL("\\C no longer supported");
	case 'X':
	    ret = reg_node(pRExC_state, CLUMP);
	    *flagp |= HASWIDTH;
	    goto finish_meta_pat;

	case 'B':
            invert = 1;
            /* FALLTHROUGH */
	case 'b':
          {
            U8 flags = 0;
	    regex_charset charset = get_regex_charset(RExC_flags);

	    RExC_seen_zerolen++;
            RExC_seen |= REG_LOOKBEHIND_SEEN;
	    op = BOUND + charset;

	    if (RExC_parse >= RExC_end || *(RExC_parse + 1) != '{') {
                flags = TRADITIONAL_BOUND;
                if (op > BOUNDA) {  /* /aa is same as /a */
                    op = BOUNDA;
                }
            }
            else {
                STRLEN length;
                char name = *RExC_parse;
                char * endbrace =  (char *) memchr(RExC_parse, '}',
                                                   RExC_end - RExC_parse);
                char * e = endbrace;

                RExC_parse += 2;

                if (! endbrace) {
                    vFAIL2("Missing right brace on \\%c{}", name);
                }

                while (isBLANK(*RExC_parse)) {
                    RExC_parse++;
                }

                while (RExC_parse < e && isBLANK(*(e - 1))) {
                    e--;
                }

                if (e == RExC_parse) {
                    RExC_parse = endbrace + 1;  /* After the '}' */
                    vFAIL2("Empty \\%c{}", name);
                }

                length = e - RExC_parse;

                switch (*RExC_parse) {
                    case 'g':
                        if (    length != 1
                            && (memNEs(RExC_parse + 1, length - 1, "cb")))
                        {
                            goto bad_bound_type;
                        }
                        flags = GCB_BOUND;
                        break;
                    case 'l':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        flags = LB_BOUND;
                        break;
                    case 's':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        flags = SB_BOUND;
                        break;
                    case 'w':
                        if (length != 2 || *(RExC_parse + 1) != 'b') {
                            goto bad_bound_type;
                        }
                        flags = WB_BOUND;
                        break;
                    default:
                      bad_bound_type:
                        RExC_parse = e;
			vFAIL2utf8f(
                            "'%" UTF8f "' is an unknown bound type",
			    UTF8fARG(UTF, length, e - length));
                        NOT_REACHED; /*NOTREACHED*/
                }
                RExC_parse = endbrace;
                REQUIRE_UNI_RULES(flagp, 0);

                if (op == BOUND) {
                    op = BOUNDU;
                }
                else if (op >= BOUNDA) {  /* /aa is same as /a */
                    op = BOUNDU;
                    length += 4;

                    /* Don't have to worry about UTF-8, in this message because
                     * to get here the contents of the \b must be ASCII */
                    ckWARN4reg(RExC_parse + 1,  /* Include the '}' in msg */
                              "Using /u for '%.*s' instead of /%s",
                              (unsigned) length,
                              endbrace - length + 1,
                              (charset == REGEX_ASCII_RESTRICTED_CHARSET)
                              ? ASCII_RESTRICT_PAT_MODS
                              : ASCII_MORE_RESTRICT_PAT_MODS);
                }
	    }

            if (op == BOUND) {
                RExC_seen_d_op = TRUE;
            }
            else if (op == BOUNDL) {
                RExC_contains_locale = 1;
            }

            if (invert) {
                op += NBOUND - BOUND;
            }

	    ret = reg_node(pRExC_state, op);
            FLAGS(REGNODE_p(ret)) = flags;

	    goto finish_meta_pat;
          }

	case 'R':
	    ret = reg_node(pRExC_state, LNBREAK);
	    *flagp |= HASWIDTH|SIMPLE;
	    goto finish_meta_pat;

	case 'd':
	case 'D':
	case 'h':
	case 'H':
	case 'p':
	case 'P':
	case 's':
	case 'S':
	case 'v':
	case 'V':
	case 'w':
	case 'W':
            /* These all have the same meaning inside [brackets], and it knows
             * how to do the best optimizations for them.  So, pretend we found
             * these within brackets, and let it do the work */
            RExC_parse--;

            ret = regclass(pRExC_state, flagp, depth+1,
                           TRUE, /* means just parse this element */
                           FALSE, /* don't allow multi-char folds */
                           FALSE, /* don't silence non-portable warnings.  It
                                     would be a bug if these returned
                                     non-portables */
                           (bool) RExC_strict,
                           TRUE, /* Allow an optimized regnode result */
                           NULL);
            RETURN_FAIL_ON_RESTART_FLAGP(flagp);
            /* regclass() can only return RESTART_PARSE and NEED_UTF8 if
             * multi-char folds are allowed.  */
            if (!ret)
                FAIL2("panic: regclass returned failure to regatom, flags=%#" UVxf,
                      (UV) *flagp);

            RExC_parse--;   /* regclass() leaves this one too far ahead */

          finish_meta_pat:
                   /* The escapes above that don't take a parameter can't be
                    * followed by a '{'.  But 'pX', 'p{foo}' and
                    * correspondingly 'P' can be */
            if (   RExC_parse - parse_start == 1
                && UCHARAT(RExC_parse + 1) == '{'
                && UNLIKELY(! regcurly(RExC_parse + 1, RExC_end, NULL)))
            {
                RExC_parse += 2;
                vFAIL("Unescaped left brace in regex is illegal here");
            }
            Set_Node_Offset(REGNODE_p(ret), parse_start);
            Set_Node_Length(REGNODE_p(ret), RExC_parse - parse_start + 1); /* MJD */
            nextchar(pRExC_state);
	    break;
        case 'N':
            /* Handle \N, \N{} and \N{NAMED SEQUENCE} (the latter meaning the
             * \N{...} evaluates to a sequence of more than one code points).
             * The function call below returns a regnode, which is our result.
             * The parameters cause it to fail if the \N{} evaluates to a
             * single code point; we handle those like any other literal.  The
             * reason that the multicharacter case is handled here and not as
             * part of the EXACtish code is because of quantifiers.  In
             * /\N{BLAH}+/, the '+' applies to the whole thing, and doing it
             * this way makes that Just Happen. dmq.
             * join_exact() will join this up with adjacent EXACTish nodes
             * later on, if appropriate. */
            ++RExC_parse;
            if (grok_bslash_N(pRExC_state,
                              &ret,     /* Want a regnode returned */
                              NULL,     /* Fail if evaluates to a single code
                                           point */
                              NULL,     /* Don't need a count of how many code
                                           points */
                              flagp,
                              RExC_strict,
                              depth)
            ) {
                break;
            }

            RETURN_FAIL_ON_RESTART_FLAGP(flagp);

            /* Here, evaluates to a single code point.  Go get that */
            RExC_parse = parse_start;
            goto defchar;

	case 'k':    /* Handle \k<NAME> and \k'NAME' and \k{NAME} */
      parse_named_seq:  /* Also handle non-numeric \g{...} */
        {
            char ch;
            if (   RExC_parse >= RExC_end - 1
                || ((   ch = RExC_parse[1]) != '<'
                                      && ch != '\''
                                      && ch != '{'))
            {
	        RExC_parse++;
		/* diag_listed_as: Sequence \%s... not terminated in regex; marked by <-- HERE in m/%s/ */
	        vFAIL2("Sequence %.2s... not terminated", parse_start);
	    } else {
		RExC_parse += 2;
                if (ch == '{') {
                    while (isBLANK(*RExC_parse)) {
                        RExC_parse++;
                    }
                }
                ret = handle_named_backref(pRExC_state,
                                           flagp,
                                           parse_start,
                                           (ch == '<')
                                           ? '>'
                                           : (ch == '{')
                                             ? '}'
                                             : '\'');
            }
            break;
	}
	case 'g':
	case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	    {
		I32 num;
		char * endbrace = NULL;
                char * s = RExC_parse;
                char * e = RExC_end;

		if (*s == 'g') {
                    bool isrel = 0;

		    s++;
		    if (*s == '{') {
                        endbrace = (char *) memchr(s, '}', RExC_end - s);
                        if (! endbrace ) {

                            /* Missing '}'.  Position after the number to give
                             * a better indication to the user of where the
                             * problem is. */
                            s++;
                            if (*s == '-') {
                                s++;
                            }

                            /* If it looks to be a name and not a number, go
                             * handle it there */
                            if (! isDIGIT(*s)) {
                                goto parse_named_seq;
                            }

                            do {
                                s++;
                            } while isDIGIT(*s);

                            RExC_parse = s;
                            vFAIL("Unterminated \\g{...} pattern");
                        }

		        s++;    /* Past the '{' */

                        while (isBLANK(*s)) {
                            s++;
                        }

                        /* Ignore trailing blanks */
                        e = endbrace;
                        while (s < e && isBLANK(*(e - 1))) {
                            e--;
                        }
		    }

                    /* Here, have isolated the meat of the construct from any
                     * surrounding braces */

		    if (*s == '-') {
		        isrel = 1;
		        s++;
		    }

		    if (endbrace && !isDIGIT(*s)) {
		        goto parse_named_seq;
                    }

                    RExC_parse = s;
                    num = S_backref_value(RExC_parse, RExC_end);
                    if (num == 0)
                        vFAIL("Reference to invalid group 0");
                    else if (num == I32_MAX) {
                         if (isDIGIT(*RExC_parse))
			    vFAIL("Reference to nonexistent group");
                        else
                            vFAIL("Unterminated \\g... pattern");
                    }

                    if (isrel) {
                        num = RExC_npar - num;
                        if (num < 1)
                            vFAIL("Reference to nonexistent or unclosed group");
                    }
                }
                else {
                    num = S_backref_value(RExC_parse, RExC_end);
                    /* bare \NNN might be backref or octal - if it is larger
                     * than or equal RExC_npar then it is assumed to be an
                     * octal escape. Note RExC_npar is +1 from the actual
                     * number of parens. */
                    /* Note we do NOT check if num == I32_MAX here, as that is
                     * handled by the RExC_npar check */

                    if (    /* any numeric escape < 10 is always a backref */
                           num > 9
                            /* any numeric escape < RExC_npar is a backref */
                        && num >= RExC_npar
                            /* cannot be an octal escape if it starts with [89]
                             * */
                        && ! inRANGE(*RExC_parse, '8', '9')
                    ) {
                        /* Probably not meant to be a backref, instead likely
                         * to be an octal character escape, e.g. \35 or \777.
                         * The above logic should make it obvious why using
                         * octal escapes in patterns is problematic. - Yves */
                        RExC_parse = parse_start;
                        goto defchar;
                    }
                }

                /* At this point RExC_parse points at a numeric escape like
                 * \12 or \88 or the digits in \g{34} or \g34 or something
                 * similar, which we should NOT treat as an octal escape. It
                 * may or may not be a valid backref escape. For instance
                 * \88888888 is unlikely to be a valid backref.
                 *
                 * We've already figured out what value the digits represent.
                 * Now, move the parse to beyond them. */
                if (endbrace) {
                    RExC_parse = endbrace + 1;
                }
                else while (isDIGIT(*RExC_parse)) {
                    RExC_parse++;
                }

                if (num >= (I32)RExC_npar) {

                    /* It might be a forward reference; we can't fail until we
                     * know, by completing the parse to get all the groups, and
                     * then reparsing */
                    if (ALL_PARENS_COUNTED)  {
                        if (num >= RExC_total_parens)  {
                            vFAIL("Reference to nonexistent group");
                        }
                    }
                    else {
                        REQUIRE_PARENS_PASS;
                    }
                }
                RExC_sawback = 1;
                ret = reganode(pRExC_state,
                               ((! FOLD)
                                 ? REF
                                 : (ASCII_FOLD_RESTRICTED)
                                   ? REFFA
                                   : (AT_LEAST_UNI_SEMANTICS)
                                     ? REFFU
                                     : (LOC)
                                       ? REFFL
                                       : REFF),
                                num);
                if (OP(REGNODE_p(ret)) == REFF) {
                    RExC_seen_d_op = TRUE;
                }
                *flagp |= HASWIDTH;

                /* override incorrect value set in reganode MJD */
                Set_Node_Offset(REGNODE_p(ret), parse_start);
                Set_Node_Cur_Length(REGNODE_p(ret), parse_start-1);
                skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                        FALSE /* Don't force to /x */ );
	    }
	    break;
	case '\0':
	    if (RExC_parse >= RExC_end)
		FAIL("Trailing \\");
	    /* FALLTHROUGH */
	default:
	    /* Do not generate "unrecognized" warnings here, we fall
	       back into the quick-grab loop below */
            RExC_parse = parse_start;
	    goto defchar;
	} /* end of switch on a \foo sequence */
	break;

    case '#':

        /* '#' comments should have been spaced over before this function was
         * called */
        assert((RExC_flags & RXf_PMf_EXTENDED) == 0);
	/*
        if (RExC_flags & RXf_PMf_EXTENDED) {
	    RExC_parse = reg_skipcomment( pRExC_state, RExC_parse );
	    if (RExC_parse < RExC_end)
		goto tryagain;
	}
        */

	/* FALLTHROUGH */

    default:
	  defchar: {

            /* Here, we have determined that the next thing is probably a
             * literal character.  RExC_parse points to the first byte of its
             * definition.  (It still may be an escape sequence that evaluates
             * to a single character) */

	    STRLEN len = 0;
	    UV ender = 0;
	    char *p;
	    char *s, *old_s = NULL, *old_old_s = NULL;
	    char *s0;
            U32 max_string_len = 255;

            /* We may have to reparse the node, artificially stopping filling
             * it early, based on info gleaned in the first parse.  This
             * variable gives where we stop.  Make it above the normal stopping
             * place first time through; otherwise it would stop too early */
            U32 upper_fill = max_string_len + 1;

            /* We start out as an EXACT node, even if under /i, until we find a
             * character which is in a fold.  The algorithm now segregates into
             * separate nodes, characters that fold from those that don't under
             * /i.  (This hopefully will create nodes that are fixed strings
             * even under /i, giving the optimizer something to grab on to.)
             * So, if a node has something in it and the next character is in
             * the opposite category, that node is closed up, and the function
             * returns.  Then regatom is called again, and a new node is
             * created for the new category. */
            U8 node_type = EXACT;

            /* Assume the node will be fully used; the excess is given back at
             * the end.  Under /i, we may need to temporarily add the fold of
             * an extra character or two at the end to check for splitting
             * multi-char folds, so allocate extra space for that.   We can't
             * make any other length assumptions, as a byte input sequence
             * could shrink down. */
            Ptrdiff_t current_string_nodes = STR_SZ(max_string_len
                                                 + ((! FOLD)
                                                    ? 0
                                                    : 2 * ((UTF)
                                                           ? UTF8_MAXBYTES_CASE
                        /* Max non-UTF-8 expansion is 2 */ : 2)));

            bool next_is_quantifier;
            char * oldp = NULL;

            /* We can convert EXACTF nodes to EXACTFU if they contain only
             * characters that match identically regardless of the target
             * string's UTF8ness.  The reason to do this is that EXACTF is not
             * trie-able, EXACTFU is, and EXACTFU requires fewer operations at
             * runtime.
             *
             * Similarly, we can convert EXACTFL nodes to EXACTFLU8 if they
             * contain only above-Latin1 characters (hence must be in UTF8),
             * which don't participate in folds with Latin1-range characters,
             * as the latter's folds aren't known until runtime. */
            bool maybe_exactfu = FOLD && (DEPENDS_SEMANTICS || LOC);

            /* Single-character EXACTish nodes are almost always SIMPLE.  This
             * allows us to override this as encountered */
            U8 maybe_SIMPLE = SIMPLE;

            /* Does this node contain something that can't match unless the
             * target string is (also) in UTF-8 */
            bool requires_utf8_target = FALSE;

            /* The sequence 'ss' is problematic in non-UTF-8 patterns. */
            bool has_ss = FALSE;

            /* So is the MICRO SIGN */
            bool has_micro_sign = FALSE;

            /* Set when we fill up the current node and there is still more
             * text to process */
            bool overflowed;

            /* Allocate an EXACT node.  The node_type may change below to
             * another EXACTish node, but since the size of the node doesn't
             * change, it works */
            ret = regnode_guts(pRExC_state, node_type, current_string_nodes,
                                                                    "exact");
            FILL_NODE(ret, node_type);
            RExC_emit++;

	    s = STRING(REGNODE_p(ret));

            s0 = s;

	  reparse:

            p = RExC_parse;
            len = 0;
            s = s0;
            node_type = EXACT;
            oldp = NULL;
            maybe_exactfu = FOLD && (DEPENDS_SEMANTICS || LOC);
            maybe_SIMPLE = SIMPLE;
            requires_utf8_target = FALSE;
            has_ss = FALSE;
            has_micro_sign = FALSE;

          continue_parse:

            /* This breaks under rare circumstances.  If folding, we do not
             * want to split a node at a character that is a non-final in a
             * multi-char fold, as an input string could just happen to want to
             * match across the node boundary.  The code at the end of the loop
             * looks for this, and backs off until it finds not such a
             * character, but it is possible (though extremely, extremely
             * unlikely) for all characters in the node to be non-final fold
             * ones, in which case we just leave the node fully filled, and
             * hope that it doesn't match the string in just the wrong place */

            assert( ! UTF     /* Is at the beginning of a character */
                   || UTF8_IS_INVARIANT(UCHARAT(RExC_parse))
                   || UTF8_IS_START(UCHARAT(RExC_parse)));

            overflowed = FALSE;

            /* Here, we have a literal character.  Find the maximal string of
             * them in the input that we can fit into a single EXACTish node.
             * We quit at the first non-literal or when the node gets full, or
             * under /i the categorization of folding/non-folding character
             * changes */
            while (p < RExC_end && len < upper_fill) {

                /* In most cases each iteration adds one byte to the output.
                 * The exceptions override this */
                Size_t added_len = 1;

		oldp = p;
                old_old_s = old_s;
                old_s = s;

                /* White space has already been ignored */
                assert(   (RExC_flags & RXf_PMf_EXTENDED) == 0
                       || ! is_PATWS_safe((p), RExC_end, UTF));

		switch ((U8)*p) {
                  const char* message;
                  U32 packed_warn;
                  U8 grok_c_char;

		case '^':
		case '$':
		case '.':
		case '[':
		case '(':
		case ')':
		case '|':
		    goto loopdone;
		case '\\':
		    /* Literal Escapes Switch

		       This switch is meant to handle escape sequences that
		       resolve to a literal character.

		       Every escape sequence that represents something
		       else, like an assertion or a char class, is handled
		       in the switch marked 'Special Escapes' above in this
		       routine, but also has an entry here as anything that
		       isn't explicitly mentioned here will be treated as
		       an unescaped equivalent literal.
		    */

		    switch ((U8)*++p) {

		    /* These are all the special escapes. */
		    case 'A':             /* Start assertion */
		    case 'b': case 'B':   /* Word-boundary assertion*/
		    case 'C':             /* Single char !DANGEROUS! */
		    case 'd': case 'D':   /* digit class */
		    case 'g': case 'G':   /* generic-backref, pos assertion */
		    case 'h': case 'H':   /* HORIZWS */
		    case 'k': case 'K':   /* named backref, keep marker */
		    case 'p': case 'P':   /* Unicode property */
		              case 'R':   /* LNBREAK */
		    case 's': case 'S':   /* space class */
		    case 'v': case 'V':   /* VERTWS */
		    case 'w': case 'W':   /* word class */
                    case 'X':             /* eXtended Unicode "combining
                                             character sequence" */
		    case 'z': case 'Z':   /* End of line/string assertion */
			--p;
			goto loopdone;

	            /* Anything after here is an escape that resolves to a
	               literal. (Except digits, which may or may not)
	             */
		    case 'n':
			ender = '\n';
			p++;
			break;
		    case 'N': /* Handle a single-code point named character. */
                        RExC_parse = p + 1;
                        if (! grok_bslash_N(pRExC_state,
                                            NULL,   /* Fail if evaluates to
                                                       anything other than a
                                                       single code point */
                                            &ender, /* The returned single code
                                                       point */
                                            NULL,   /* Don't need a count of
                                                       how many code points */
                                            flagp,
                                            RExC_strict,
                                            depth)
                        ) {
                            if (*flagp & NEED_UTF8)
                                FAIL("panic: grok_bslash_N set NEED_UTF8");
                            RETURN_FAIL_ON_RESTART_FLAGP(flagp);

                            /* Here, it wasn't a single code point.  Go close
                             * up this EXACTish node.  The switch() prior to
                             * this switch handles the other cases */
                            RExC_parse = p = oldp;
                            goto loopdone;
                        }
                        p = RExC_parse;
                        RExC_parse = parse_start;

                        /* The \N{} means the pattern, if previously /d,
                         * becomes /u.  That means it can't be an EXACTF node,
                         * but an EXACTFU */
                        if (node_type == EXACTF) {
                            node_type = EXACTFU;

                            /* If the node already contains something that
                             * differs between EXACTF and EXACTFU, reparse it
                             * as EXACTFU */
                            if (! maybe_exactfu) {
                                len = 0;
                                s = s0;
                                goto reparse;
                            }
                        }

                        break;
		    case 'r':
			ender = '\r';
			p++;
			break;
		    case 't':
			ender = '\t';
			p++;
			break;
		    case 'f':
			ender = '\f';
			p++;
			break;
		    case 'e':
			ender = ESC_NATIVE;
			p++;
			break;
		    case 'a':
			ender = '\a';
			p++;
			break;
		    case 'o':
                        if (! grok_bslash_o(&p,
                                            RExC_end,
                                            &ender,
                                            &message,
                                            &packed_warn,
                                            (bool) RExC_strict,
                                            FALSE, /* No illegal cp's */
                                            UTF))
                        {
                            RExC_parse = p; /* going to die anyway; point to
                                               exact spot of failure */
                            vFAIL(message);
                        }

                        if (message && TO_OUTPUT_WARNINGS(p)) {
                            warn_non_literal_string(p, packed_warn, message);
                        }
                        break;
		    case 'x':
                        if (! grok_bslash_x(&p,
                                            RExC_end,
                                            &ender,
                                            &message,
                                            &packed_warn,
                                            (bool) RExC_strict,
                                            FALSE, /* No illegal cp's */
                                            UTF))
                        {
                            RExC_parse = p;	/* going to die anyway; point
                                                   to exact spot of failure */
                            vFAIL(message);
                        }

                        if (message && TO_OUTPUT_WARNINGS(p)) {
                            warn_non_literal_string(p, packed_warn, message);
                        }

#ifdef EBCDIC
                        if (ender < 0x100) {
                            if (RExC_recode_x_to_native) {
                                ender = LATIN1_TO_NATIVE(ender);
                            }
                        }
#endif
                        break;
		    case 'c':
                        p++;
                        if (! grok_bslash_c(*p, &grok_c_char,
                                            &message, &packed_warn))
                        {
                            /* going to die anyway; point to exact spot of
                             * failure */
                            RExC_parse = p + ((UTF)
                                              ? UTF8_SAFE_SKIP(p, RExC_end)
                                              : 1);
                            vFAIL(message);
                        }

                        ender = grok_c_char;
                        p++;
                        if (message && TO_OUTPUT_WARNINGS(p)) {
                            warn_non_literal_string(p, packed_warn, message);
                        }

			break;
                    case '8': case '9': /* must be a backreference */
                        --p;
                        /* we have an escape like \8 which cannot be an octal escape
                         * so we exit the loop, and let the outer loop handle this
                         * escape which may or may not be a legitimate backref. */
                        goto loopdone;
                    case '1': case '2': case '3':case '4':
		    case '5': case '6': case '7':

                        /* When we parse backslash escapes there is ambiguity
                         * between backreferences and octal escapes. Any escape
                         * from \1 - \9 is a backreference, any multi-digit
                         * escape which does not start with 0 and which when
                         * evaluated as decimal could refer to an already
                         * parsed capture buffer is a back reference. Anything
                         * else is octal.
                         *
                         * Note this implies that \118 could be interpreted as
                         * 118 OR as "\11" . "8" depending on whether there
                         * were 118 capture buffers defined already in the
                         * pattern.  */

                        /* NOTE, RExC_npar is 1 more than the actual number of
                         * parens we have seen so far, hence the "<" as opposed
                         * to "<=" */
                        if ( !isDIGIT(p[1]) || S_backref_value(p, RExC_end) < RExC_npar)
                        {  /* Not to be treated as an octal constant, go
                                   find backref */
                            p = oldp;
                            goto loopdone;
                        }
                        /* FALLTHROUGH */
                    case '0':
			{
			    I32 flags = PERL_SCAN_SILENT_ILLDIGIT
                                      | PERL_SCAN_NOTIFY_ILLDIGIT;
			    STRLEN numlen = 3;
			    ender = grok_oct(p, &numlen, &flags, NULL);
			    p += numlen;
                            if (  (flags & PERL_SCAN_NOTIFY_ILLDIGIT)
                                && isDIGIT(*p)  /* like \08, \178 */
                                && ckWARN(WARN_REGEXP))
                            {
				reg_warn_non_literal_string(
                                     p + 1,
                                     form_alien_digit_msg(8, numlen, p,
                                                        RExC_end, UTF, FALSE));
                            }
			}
			break;
		    case '\0':
			if (p >= RExC_end)
			    FAIL("Trailing \\");
			/* FALLTHROUGH */
		    default:
			if (isALPHANUMERIC(*p)) {
                            /* An alpha followed by '{' is going to fail next
                             * iteration, so don't output this warning in that
                             * case */
                            if (! isALPHA(*p) || *(p + 1) != '{') {
                                ckWARN2reg(p + 1, "Unrecognized escape \\%.1s"
                                                  " passed through", p);
                            }
			}
			goto normal_default;
		    } /* End of switch on '\' */
		    break;
		case '{':
                    /* Trying to gain new uses for '{' without breaking too
                     * much existing code is hard.  The solution currently
                     * adopted is:
                     *  1)  If there is no ambiguity that a '{' should always
                     *      be taken literally, at the start of a construct, we
                     *      just do so.
                     *  2)  If the literal '{' conflicts with our desired use
                     *      of it as a metacharacter, we die.  The deprecation
                     *      cycles for this have come and gone.
                     *  3)  If there is ambiguity, we raise a simple warning.
                     *      This could happen, for example, if the user
                     *      intended it to introduce a quantifier, but slightly
                     *      misspelled the quantifier.  Without this warning,
                     *      the quantifier would silently be taken as a literal
                     *      string of characters instead of a meta construct */
		    if (len || (p > RExC_start && isALPHA_A(*(p - 1)))) {
                        if (      RExC_strict
                            || (  p > parse_start + 1
                                && isALPHA_A(*(p - 1))
                                && *(p - 2) == '\\'))
                        {
                            RExC_parse = p + 1;
                            vFAIL("Unescaped left brace in regex is "
                                  "illegal here");
                        }
                        ckWARNreg(p + 1, "Unescaped left brace in regex is"
                                         " passed through");
		    }
		    goto normal_default;
                case '}':
                case ']':
                    if (p > RExC_parse && RExC_strict) {
                        ckWARN2reg(p + 1, "Unescaped literal '%c'", *p);
                    }
		    /*FALLTHROUGH*/
		default:    /* A literal character */
		  normal_default:
		    if (! UTF8_IS_INVARIANT(*p) && UTF) {
			STRLEN numlen;
			ender = utf8n_to_uvchr((U8*)p, RExC_end - p,
					       &numlen, UTF8_ALLOW_DEFAULT);
			p += numlen;
		    }
		    else
			ender = (U8) *p++;
		    break;
		} /* End of switch on the literal */

		/* Here, have looked at the literal character, and <ender>
                 * contains its ordinal; <p> points to the character after it.
                 * */

                if (ender > 255) {
                    REQUIRE_UTF8(flagp);
                    if (   UNICODE_IS_PERL_EXTENDED(ender)
                        && TO_OUTPUT_WARNINGS(p))
                    {
                        ckWARN2_non_literal_string(p,
                                                   packWARN(WARN_PORTABLE),
                                                   PL_extended_cp_format,
                                                   ender);
                    }
                }

                /* We need to check if the next non-ignored thing is a
                 * quantifier.  Move <p> to after anything that should be
                 * ignored, which, as a side effect, positions <p> for the next
                 * loop iteration */
                skip_to_be_ignored_text(pRExC_state, &p,
                                        FALSE /* Don't force to /x */ );

                /* If the next thing is a quantifier, it applies to this
                 * character only, which means that this character has to be in
                 * its own node and can't just be appended to the string in an
                 * existing node, so if there are already other characters in
                 * the node, close the node with just them, and set up to do
                 * this character again next time through, when it will be the
                 * only thing in its new node */

                next_is_quantifier =    LIKELY(p < RExC_end)
                                     && UNLIKELY(isQUANTIFIER(p, RExC_end));

                if (next_is_quantifier && LIKELY(len)) {
                    p = oldp;
                    goto loopdone;
                }

                /* Ready to add 'ender' to the node */

                if (! FOLD) {  /* The simple case, just append the literal */
                  not_fold_common:

                    /* Don't output if it would overflow */
                    if (UNLIKELY(len > max_string_len - ((UTF)
                                                      ? UVCHR_SKIP(ender)
                                                      : 1)))
                    {
                        overflowed = TRUE;
                        break;
                    }

                    if (UVCHR_IS_INVARIANT(ender) || ! UTF) {
                        *(s++) = (char) ender;
                    }
                    else {
                        U8 * new_s = uvchr_to_utf8((U8*)s, ender);
                        added_len = (char *) new_s - s;
                        s = (char *) new_s;

                        if (ender > 255)  {
                            requires_utf8_target = TRUE;
                        }
                    }
                }
                else if (LOC && is_PROBLEMATIC_LOCALE_FOLD_cp(ender)) {

                    /* Here are folding under /l, and the code point is
                     * problematic.  If this is the first character in the
                     * node, change the node type to folding.   Otherwise, if
                     * this is the first problematic character, close up the
                     * existing node, so can start a new node with this one */
                    if (! len) {
                        node_type = EXACTFL;
                        RExC_contains_locale = 1;
                    }
                    else if (node_type == EXACT) {
                        p = oldp;
                        goto loopdone;
                    }

                    /* This problematic code point means we can't simplify
                     * things */
                    maybe_exactfu = FALSE;

                    /* Although these two characters have folds that are
                     * locale-problematic, they also have folds to above Latin1
                     * that aren't a problem.  Doing these now helps at
                     * runtime. */
                    if (UNLIKELY(   ender == GREEK_CAPITAL_LETTER_MU
                                 || ender == LATIN_CAPITAL_LETTER_SHARP_S))
                    {
                        goto fold_anyway;
                    }

                    /* Here, we are adding a problematic fold character.
                     * "Problematic" in this context means that its fold isn't
                     * known until runtime.  (The non-problematic code points
                     * are the above-Latin1 ones that fold to also all
                     * above-Latin1.  Their folds don't vary no matter what the
                     * locale is.) But here we have characters whose fold
                     * depends on the locale.  We just add in the unfolded
                     * character, and wait until runtime to fold it */
                    goto not_fold_common;
                }
                else /* regular fold; see if actually is in a fold */
                     if (   (ender < 256 && ! IS_IN_SOME_FOLD_L1(ender))
                         || (ender > 255
                            && ! _invlist_contains_cp(PL_in_some_fold, ender)))
                {
                    /* Here, folding, but the character isn't in a fold.
                     *
                     * Start a new node if previous characters in the node were
                     * folded */
                    if (len && node_type != EXACT) {
                        p = oldp;
                        goto loopdone;
                    }

                    /* Here, continuing a node with non-folded characters.  Add
                     * this one */
                    goto not_fold_common;
                }
                else {  /* Here, does participate in some fold */

                    /* If this is the first character in the node, change its
                     * type to folding.  Otherwise, if this is the first
                     * folding character in the node, close up the existing
                     * node, so can start a new node with this one.  */
                    if (! len) {
                        node_type = compute_EXACTish(pRExC_state);
                    }
                    else if (node_type == EXACT) {
                        p = oldp;
                        goto loopdone;
                    }

                    if (UTF) {  /* Alway use the folded value for UTF-8
                                   patterns */
                        if (UVCHR_IS_INVARIANT(ender)) {
                            if (UNLIKELY(len + 1 > max_string_len)) {
                                overflowed = TRUE;
                                break;
                            }

                            *(s)++ = (U8) toFOLD(ender);
                        }
                        else {
                            UV folded;

                          fold_anyway:
                            folded = _to_uni_fold_flags(
                                    ender,
                                    (U8 *) s,  /* We have allocated extra space
                                                  in 's' so can't run off the
                                                  end */
                                    &added_len,
                                    FOLD_FLAGS_FULL
                                  | ((   ASCII_FOLD_RESTRICTED
                                      || node_type == EXACTFL)
                                    ? FOLD_FLAGS_NOMIX_ASCII
                                    : 0));
                            if (UNLIKELY(len + added_len > max_string_len)) {
                                overflowed = TRUE;
                                break;
                            }

                            s += added_len;

                            if (   folded > 255
                                && LIKELY(folded != GREEK_SMALL_LETTER_MU))
                            {
                                /* U+B5 folds to the MU, so its possible for a
                                 * non-UTF-8 target to match it */
                                requires_utf8_target = TRUE;
                            }
                        }
                    }
                    else { /* Here is non-UTF8. */

                        /* The fold will be one or (rarely) two characters.
                         * Check that there's room for at least a single one
                         * before setting any flags, etc.  Because otherwise an
                         * overflowing character could cause a flag to be set
                         * even though it doesn't end up in this node.  (For
                         * the two character fold, we check again, before
                         * setting any flags) */
                        if (UNLIKELY(len + 1 > max_string_len)) {
                            overflowed = TRUE;
                            break;
                        }

#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)

                        /* On non-ancient Unicodes, check for the only possible
                         * multi-char fold  */
                        if (UNLIKELY(ender == LATIN_SMALL_LETTER_SHARP_S)) {

                            /* This potential multi-char fold means the node
                             * can't be simple (because it could match more
                             * than a single char).  And in some cases it will
                             * match 'ss', so set that flag */
                            maybe_SIMPLE = 0;
                            has_ss = TRUE;

                            /* It can't change to be an EXACTFU (unless already
                             * is one).  We fold it iff under /u rules. */
                            if (node_type != EXACTFU) {
                                maybe_exactfu = FALSE;
                            }
                            else {
                                if (UNLIKELY(len + 2 > max_string_len)) {
                                    overflowed = TRUE;
                                    break;
                                }

                                *(s++) = 's';
                                *(s++) = 's';
                                added_len = 2;

                                goto done_with_this_char;
                            }
                        }
                        else if (   UNLIKELY(isALPHA_FOLD_EQ(ender, 's'))
                                 && LIKELY(len > 0)
                                 && UNLIKELY(isALPHA_FOLD_EQ(*(s-1), 's')))
                        {
                            /* Also, the sequence 'ss' is special when not
                             * under /u.  If the target string is UTF-8, it
                             * should match SHARP S; otherwise it won't.  So,
                             * here we have to exclude the possibility of this
                             * node moving to /u.*/
                            has_ss = TRUE;
                            maybe_exactfu = FALSE;
                        }
#endif
                        /* Here, the fold will be a single character */

                        if (UNLIKELY(ender == MICRO_SIGN)) {
                            has_micro_sign = TRUE;
                        }
                        else if (PL_fold[ender] != PL_fold_latin1[ender]) {

                            /* If the character's fold differs between /d and
                             * /u, this can't change to be an EXACTFU node */
                            maybe_exactfu = FALSE;
                        }

                        *(s++) = (DEPENDS_SEMANTICS)
                                 ? (char) toFOLD(ender)

                                   /* Under /u, the fold of any character in
                                    * the 0-255 range happens to be its
                                    * lowercase equivalent, except for LATIN
                                    * SMALL LETTER SHARP S, which was handled
                                    * above, and the MICRO SIGN, whose fold
                                    * requires UTF-8 to represent.  */
                                 : (char) toLOWER_L1(ender);
                    }
		} /* End of adding current character to the node */

              done_with_this_char:

                len += added_len;

		if (next_is_quantifier) {

                    /* Here, the next input is a quantifier, and to get here,
                     * the current character is the only one in the node. */
                    goto loopdone;
		}

	    } /* End of loop through literal characters */

            /* Here we have either exhausted the input or run out of room in
             * the node.  If the former, we are done.  (If we encountered a
             * character that can't be in the node, transfer is made directly
             * to <loopdone>, and so we wouldn't have fallen off the end of the
             * loop.)  */
            if (LIKELY(! overflowed)) {
                goto loopdone;
            }

            /* Here we have run out of room.  We can grow plain EXACT and
             * LEXACT nodes.  If the pattern is gigantic enough, though,
             * eventually we'll have to artificially chunk the pattern into
             * multiple nodes. */
            if (! LOC && (node_type == EXACT || node_type == LEXACT)) {
                Size_t overhead = 1 + regarglen[OP(REGNODE_p(ret))];
                Size_t overhead_expansion = 0;
                char temp[256];
                Size_t max_nodes_for_string;
                Size_t achievable;
                SSize_t delta;

                /* Here we couldn't fit the final character in the current
                 * node, so it will have to be reparsed, no matter what else we
                 * do */
                p = oldp;

                /* If would have overflowed a regular EXACT node, switch
                 * instead to an LEXACT.  The code below is structured so that
                 * the actual growing code is common to changing from an EXACT
                 * or just increasing the LEXACT size.  This means that we have
                 * to save the string in the EXACT case before growing, and
                 * then copy it afterwards to its new location */
                if (node_type == EXACT) {
                    overhead_expansion = regarglen[LEXACT] - regarglen[EXACT];
                    RExC_emit += overhead_expansion;
                    Copy(s0, temp, len, char);
                }

                /* Ready to grow.  If it was a plain EXACT, the string was
                 * saved, and the first few bytes of it overwritten by adding
                 * an argument field.  We assume, as we do elsewhere in this
                 * file, that one byte of remaining input will translate into
                 * one byte of output, and if that's too small, we grow again,
                 * if too large the excess memory is freed at the end */

                max_nodes_for_string = U16_MAX - overhead - overhead_expansion;
                achievable = MIN(max_nodes_for_string,
                                 current_string_nodes + STR_SZ(RExC_end - p));
                delta = achievable - current_string_nodes;

                /* If there is just no more room, go finish up this chunk of
                 * the pattern. */
                if (delta <= 0) {
                    goto loopdone;
                }

                change_engine_size(pRExC_state, delta + overhead_expansion);
                current_string_nodes += delta;
                max_string_len
                           = sizeof(struct regnode) * current_string_nodes;
                upper_fill = max_string_len + 1;

                /* If the length was small, we know this was originally an
                 * EXACT node now converted to LEXACT, and the string has to be
                 * restored.  Otherwise the string was untouched.  260 is just
                 * a number safely above 255 so don't have to worry about
                 * getting it precise */
                if (len < 260) {
                    node_type = LEXACT;
                    FILL_NODE(ret, node_type);
                    s0 = STRING(REGNODE_p(ret));
                    Copy(temp, s0, len, char);
                    s = s0 + len;
                }

                goto continue_parse;
            }
            else if (FOLD) {
                bool splittable = FALSE;
                bool backed_up = FALSE;
                char * e;       /* should this be U8? */
                char * s_start; /* should this be U8? */

                /* Here is /i.  Running out of room creates a problem if we are
                 * folding, and the split happens in the middle of a
                 * multi-character fold, as a match that should have occurred,
                 * won't, due to the way nodes are matched, and our artificial
                 * boundary.  So back off until we aren't splitting such a
                 * fold.  If there is no such place to back off to, we end up
                 * taking the entire node as-is.  This can happen if the node
                 * consists entirely of 'f' or entirely of 's' characters (or
                 * things that fold to them) as 'ff' and 'ss' are
                 * multi-character folds.
                 *
                 * The Unicode standard says that multi character folds consist
                 * of either two or three characters.  That means we would be
                 * splitting one if the final character in the node is at the
                 * beginning of either type, or is the second of a three
                 * character fold.
                 *
                 * At this point:
                 *  ender     is the code point of the character that won't fit
                 *            in the node
                 *  s         points to just beyond the final byte in the node.
                 *            It's where we would place ender if there were
                 *            room, and where in fact we do place ender's fold
                 *            in the code below, as we've over-allocated space
                 *            for s0 (hence s) to allow for this
                 *  e         starts at 's' and advances as we append things.
                 *  old_s     is the same as 's'.  (If ender had fit, 's' would
                 *            have been advanced to beyond it).
                 *  old_old_s points to the beginning byte of the final
                 *            character in the node
                 *  p         points to the beginning byte in the input of the
                 *            character beyond 'ender'.
                 *  oldp      points to the beginning byte in the input of
                 *            'ender'.
                 *
                 * In the case of /il, we haven't folded anything that could be
                 * affected by the locale.  That means only above-Latin1
                 * characters that fold to other above-latin1 characters get
                 * folded at compile time.  To check where a good place to
                 * split nodes is, everything in it will have to be folded.
                 * The boolean 'maybe_exactfu' keeps track in /il if there are
                 * any unfolded characters in the node. */
                bool need_to_fold_loc = LOC && ! maybe_exactfu;

                /* If we do need to fold the node, we need a place to store the
                 * folded copy, and a way to map back to the unfolded original
                 * */
                char * locfold_buf = NULL;
                Size_t * loc_correspondence = NULL;

                if (! need_to_fold_loc) {   /* The normal case.  Just
                                               initialize to the actual node */
                    e = s;
                    s_start = s0;
                    s = old_old_s;  /* Point to the beginning of the final char
                                       that fits in the node */
                }
                else {

                    /* Here, we have filled a /il node, and there are unfolded
                     * characters in it.  If the runtime locale turns out to be
                     * UTF-8, there are possible multi-character folds, just
                     * like when not under /l.  The node hence can't terminate
                     * in the middle of such a fold.  To determine this, we
                     * have to create a folded copy of this node.  That means
                     * reparsing the node, folding everything assuming a UTF-8
                     * locale.  (If at runtime it isn't such a locale, the
                     * actions here wouldn't have been necessary, but we have
                     * to assume the worst case.)  If we find we need to back
                     * off the folded string, we do so, and then map that
                     * position back to the original unfolded node, which then
                     * gets output, truncated at that spot */

                    char * redo_p = RExC_parse;
                    char * redo_e;
                    char * old_redo_e;

                    /* Allow enough space assuming a single byte input folds to
                     * a single byte output, plus assume that the two unparsed
                     * characters (that we may need) fold to the largest number
                     * of bytes possible, plus extra for one more worst case
                     * scenario.  In the loop below, if we start eating into
                     * that final spare space, we enlarge this initial space */
                    Size_t size = max_string_len + (3 * UTF8_MAXBYTES_CASE) + 1;

                    Newxz(locfold_buf, size, char);
                    Newxz(loc_correspondence, size, Size_t);

                    /* Redo this node's parse, folding into 'locfold_buf' */
                    redo_p = RExC_parse;
                    old_redo_e = redo_e = locfold_buf;
                    while (redo_p <= oldp) {

                        old_redo_e = redo_e;
                        loc_correspondence[redo_e - locfold_buf]
                                                        = redo_p - RExC_parse;

                        if (UTF) {
                            Size_t added_len;

                            (void) _to_utf8_fold_flags((U8 *) redo_p,
                                                       (U8 *) RExC_end,
                                                       (U8 *) redo_e,
                                                       &added_len,
                                                       FOLD_FLAGS_FULL);
                            redo_e += added_len;
                            redo_p += UTF8SKIP(redo_p);
                        }
                        else {

                            /* Note that if this code is run on some ancient
                             * Unicode versions, SHARP S doesn't fold to 'ss',
                             * but rather than clutter the code with #ifdef's,
                             * as is done above, we ignore that possibility.
                             * This is ok because this code doesn't affect what
                             * gets matched, but merely where the node gets
                             * split */
                            if (UCHARAT(redo_p) != LATIN_SMALL_LETTER_SHARP_S) {
                                *redo_e++ = toLOWER_L1(UCHARAT(redo_p));
                            }
                            else {
                                *redo_e++ = 's';
                                *redo_e++ = 's';
                            }
                            redo_p++;
                        }


                        /* If we're getting so close to the end that a
                         * worst-case fold in the next character would cause us
                         * to overflow, increase, assuming one byte output byte
                         * per one byte input one, plus room for another worst
                         * case fold */
                        if (   redo_p <= oldp
                            && redo_e > locfold_buf + size
                                                    - (UTF8_MAXBYTES_CASE + 1))
                        {
                            Size_t new_size = size
                                            + (oldp - redo_p)
                                            + UTF8_MAXBYTES_CASE + 1;
                            Ptrdiff_t e_offset = redo_e - locfold_buf;

                            Renew(locfold_buf, new_size, char);
                            Renew(loc_correspondence, new_size, Size_t);
                            size = new_size;

                            redo_e = locfold_buf + e_offset;
                        }
                    }

                    /* Set so that things are in terms of the folded, temporary
                     * string */
                    s = old_redo_e;
                    s_start = locfold_buf;
                    e = redo_e;

                }

                /* Here, we have 's', 's_start' and 'e' set up to point to the
                 * input that goes into the node, folded.
                 *
                 * If the final character of the node and the fold of ender
                 * form the first two characters of a three character fold, we
                 * need to peek ahead at the next (unparsed) character in the
                 * input to determine if the three actually do form such a
                 * fold.  Just looking at that character is not generally
                 * sufficient, as it could be, for example, an escape sequence
                 * that evaluates to something else, and it needs to be folded.
                 *
                 * khw originally thought to just go through the parse loop one
                 * extra time, but that doesn't work easily as that iteration
                 * could cause things to think that the parse is over and to
                 * goto loopdone.  The character could be a '$' for example, or
                 * the character beyond could be a quantifier, and other
                 * glitches as well.
                 *
                 * The solution used here for peeking ahead is to look at that
                 * next character.  If it isn't ASCII punctuation, then it will
                 * be something that would continue on in an EXACTish node if
                 * there were space.  We append the fold of it to s, having
                 * reserved enough room in s0 for the purpose.  If we can't
                 * reasonably peek ahead, we instead assume the worst case:
                 * that it is something that would form the completion of a
                 * multi-char fold.
                 *
                 * If we can't split between s and ender, we work backwards
                 * character-by-character down to s0.  At each current point
                 * see if we are at the beginning of a multi-char fold.  If so,
                 * that means we would be splitting the fold across nodes, and
                 * so we back up one and try again.
                 *
                 * If we're not at the beginning, we still could be at the
                 * final two characters of a (rare) three character fold.  We
                 * check if the sequence starting at the character before the
                 * current position (and including the current and next
                 * characters) is a three character fold.  If not, the node can
                 * be split here.  If it is, we have to backup two characters
                 * and try again.
                 *
                 * Otherwise, the node can be split at the current position.
                 *
                 * The same logic is used for UTF-8 patterns and not */
                if (UTF) {
                    Size_t added_len;

                    /* Append the fold of ender */
                    (void) _to_uni_fold_flags(
                        ender,
                        (U8 *) e,
                        &added_len,
                        FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                        ? FOLD_FLAGS_NOMIX_ASCII
                                        : 0));
                    e += added_len;

                    /* 's' and the character folded to by ender may be the
                     * first two of a three-character fold, in which case the
                     * node should not be split here.  That may mean examining
                     * the so-far unparsed character starting at 'p'.  But if
                     * ender folded to more than one character, we already have
                     * three characters to look at.  Also, we first check if
                     * the sequence consisting of s and the next character form
                     * the first two of some three character fold.  If not,
                     * there's no need to peek ahead. */
                    if (   added_len <= UTF8SKIP(e - added_len)
                        && UNLIKELY(is_THREE_CHAR_FOLD_HEAD_utf8_safe(s, e)))
                    {
                        /* Here, the two do form the beginning of a potential
                         * three character fold.  The unexamined character may
                         * or may not complete it.  Peek at it.  It might be
                         * something that ends the node or an escape sequence,
                         * in which case we don't know without a lot of work
                         * what it evaluates to, so we have to assume the worst
                         * case: that it does complete the fold, and so we
                         * can't split here.  All such instances  will have
                         * that character be an ASCII punctuation character,
                         * like a backslash.  So, for that case, backup one and
                         * drop down to try at that position */
                        if (isPUNCT(*p)) {
                            s = (char *) utf8_hop_back((U8 *) s, -1,
                                       (U8 *) s_start);
                            backed_up = TRUE;
                        }
                        else {
                            /* Here, since it's not punctuation, it must be a
                             * real character, and we can append its fold to
                             * 'e' (having deliberately reserved enough space
                             * for this eventuality) and drop down to check if
                             * the three actually do form a folded sequence */
                            (void) _to_utf8_fold_flags(
                                (U8 *) p, (U8 *) RExC_end,
                                (U8 *) e,
                                &added_len,
                                FOLD_FLAGS_FULL | ((ASCII_FOLD_RESTRICTED)
                                                ? FOLD_FLAGS_NOMIX_ASCII
                                                : 0));
                            e += added_len;
                        }
                    }

                    /* Here, we either have three characters available in
                     * sequence starting at 's', or we have two characters and
                     * know that the following one can't possibly be part of a
                     * three character fold.  We go through the node backwards
                     * until we find a place where we can split it without
                     * breaking apart a multi-character fold.  At any given
                     * point we have to worry about if such a fold begins at
                     * the current 's', and also if a three-character fold
                     * begins at s-1, (containing s and s+1).  Splitting in
                     * either case would break apart a fold */
                    do {
                        char *prev_s = (char *) utf8_hop_back((U8 *) s, -1,
                                                            (U8 *) s_start);

                        /* If is a multi-char fold, can't split here.  Backup
                         * one char and try again */
                        if (UNLIKELY(is_MULTI_CHAR_FOLD_utf8_safe(s, e))) {
                            s = prev_s;
                            backed_up = TRUE;
                            continue;
                        }

                        /* If the two characters beginning at 's' are part of a
                         * three character fold starting at the character
                         * before s, we can't split either before or after s.
                         * Backup two chars and try again */
                        if (   LIKELY(s > s_start)
                            && UNLIKELY(is_THREE_CHAR_FOLD_utf8_safe(prev_s, e)))
                        {
                            s = prev_s;
                            s = (char *) utf8_hop_back((U8 *) s, -1, (U8 *) s_start);
                            backed_up = TRUE;
                            continue;
                        }

                        /* Here there's no multi-char fold between s and the
                         * next character following it.  We can split */
                        splittable = TRUE;
                        break;

                    } while (s > s_start); /* End of loops backing up through the node */

                    /* Here we either couldn't find a place to split the node,
                     * or else we broke out of the loop setting 'splittable' to
                     * true.  In the latter case, the place to split is between
                     * the first and second characters in the sequence starting
                     * at 's' */
                    if (splittable) {
                        s += UTF8SKIP(s);
                    }
                }
                else {  /* Pattern not UTF-8 */
                    if (   ender != LATIN_SMALL_LETTER_SHARP_S
                        || ASCII_FOLD_RESTRICTED)
                    {
                        assert( toLOWER_L1(ender) < 256 );
                        *e++ = (char)(toLOWER_L1(ender)); /* should e and the cast be U8? */
                    }
                    else {
                        *e++ = 's';
                        *e++ = 's';
                    }

                    if (   e - s  <= 1
                        && UNLIKELY(is_THREE_CHAR_FOLD_HEAD_latin1_safe(s, e)))
                    {
                        if (isPUNCT(*p)) {
                            s--;
                            backed_up = TRUE;
                        }
                        else {
                            if (   UCHARAT(p) != LATIN_SMALL_LETTER_SHARP_S
                                || ASCII_FOLD_RESTRICTED)
                            {
                                assert( toLOWER_L1(ender) < 256 );
                                *e++ = (char)(toLOWER_L1(ender)); /* should e and the cast be U8? */
                            }
                            else {
                                *e++ = 's';
                                *e++ = 's';
                            }
                        }
                    }

                    do {
                        if (UNLIKELY(is_MULTI_CHAR_FOLD_latin1_safe(s, e))) {
                            s--;
                            backed_up = TRUE;
                            continue;
                        }

                        if (   LIKELY(s > s_start)
                            && UNLIKELY(is_THREE_CHAR_FOLD_latin1_safe(s - 1, e)))
                        {
                            s -= 2;
                            backed_up = TRUE;
                            continue;
                        }

                        splittable = TRUE;
                        break;

                    } while (s > s_start);

                    if (splittable) {
                        s++;
                    }
                }

                /* Here, we are done backing up.  If we didn't backup at all
                 * (the likely case), just proceed */
                if (backed_up) {

                   /* If we did find a place to split, reparse the entire node
                    * stopping where we have calculated. */
                    if (splittable) {

                       /* If we created a temporary folded string under /l, we
                        * have to map that back to the original */
                        if (need_to_fold_loc) {
                            upper_fill = loc_correspondence[s - s_start];
                            if (upper_fill == 0) {
                                FAIL2("panic: loc_correspondence[%d] is 0",
                                      (int) (s - s_start));
                            }
                            Safefree(locfold_buf);
                            Safefree(loc_correspondence);
                        }
                        else {
                            upper_fill = s - s0;
                        }
                        goto reparse;
                    }

                    /* Here the node consists entirely of non-final multi-char
                     * folds.  (Likely it is all 'f's or all 's's.)  There's no
                     * decent place to split it, so give up and just take the
                     * whole thing */
                    len = old_s - s0;
                }

                if (need_to_fold_loc) {
                    Safefree(locfold_buf);
                    Safefree(loc_correspondence);
                }
	    }   /* End of verifying node ends with an appropriate char */

            /* We need to start the next node at the character that didn't fit
             * in this one */
            p = oldp;

          loopdone:   /* Jumped to when encounters something that shouldn't be
                         in the node */

            /* Free up any over-allocated space; cast is to silence bogus
             * warning in MS VC */
            change_engine_size(pRExC_state,
                        - (Ptrdiff_t) (current_string_nodes - STR_SZ(len)));

            /* I (khw) don't know if you can get here with zero length, but the
             * old code handled this situation by creating a zero-length EXACT
             * node.  Might as well be NOTHING instead */
            if (len == 0) {
                OP(REGNODE_p(ret)) = NOTHING;
            }
            else {

                /* If the node type is EXACT here, check to see if it
                 * should be EXACTL, or EXACT_REQ8. */
                if (node_type == EXACT) {
                    if (LOC) {
                        node_type = EXACTL;
                    }
                    else if (requires_utf8_target) {
                        node_type = EXACT_REQ8;
                    }
                }
                else if (node_type == LEXACT) {
                    if (requires_utf8_target) {
                        node_type = LEXACT_REQ8;
                    }
                }
                else if (FOLD) {
                    if (    UNLIKELY(has_micro_sign || has_ss)
                        && (node_type == EXACTFU || (   node_type == EXACTF
                                                     && maybe_exactfu)))
                    {   /* These two conditions are problematic in non-UTF-8
                           EXACTFU nodes. */
                        assert(! UTF);
                        node_type = EXACTFUP;
                    }
                    else if (node_type == EXACTFL) {

                        /* 'maybe_exactfu' is deliberately set above to
                         * indicate this node type, where all code points in it
                         * are above 255 */
                        if (maybe_exactfu) {
                            node_type = EXACTFLU8;
                        }
                        else if (UNLIKELY(
                             _invlist_contains_cp(PL_HasMultiCharFold, ender)))
                        {
                            /* A character that folds to more than one will
                             * match multiple characters, so can't be SIMPLE.
                             * We don't have to worry about this with EXACTFLU8
                             * nodes just above, as they have already been
                             * folded (since the fold doesn't vary at run
                             * time).  Here, if the final character in the node
                             * folds to multiple, it can't be simple.  (This
                             * only has an effect if the node has only a single
                             * character, hence the final one, as elsewhere we
                             * turn off simple for nodes whose length > 1 */
                            maybe_SIMPLE = 0;
                        }
                    }
                    else if (node_type == EXACTF) {  /* Means is /di */

                        /* This intermediate variable is needed solely because
                         * the asserts in the macro where used exceed Win32's
                         * literal string capacity */
                        char first_char = * STRING(REGNODE_p(ret));

                        /* If 'maybe_exactfu' is clear, then we need to stay
                         * /di.  If it is set, it means there are no code
                         * points that match differently depending on UTF8ness
                         * of the target string, so it can become an EXACTFU
                         * node */
                        if (! maybe_exactfu) {
                            RExC_seen_d_op = TRUE;
                        }
                        else if (   isALPHA_FOLD_EQ(first_char, 's')
                                 || isALPHA_FOLD_EQ(ender, 's'))
                        {
                            /* But, if the node begins or ends in an 's' we
                             * have to defer changing it into an EXACTFU, as
                             * the node could later get joined with another one
                             * that ends or begins with 's' creating an 'ss'
                             * sequence which would then wrongly match the
                             * sharp s without the target being UTF-8.  We
                             * create a special node that we resolve later when
                             * we join nodes together */

                            node_type = EXACTFU_S_EDGE;
                        }
                        else {
                            node_type = EXACTFU;
                        }
                    }

                    if (requires_utf8_target && node_type == EXACTFU) {
                        node_type = EXACTFU_REQ8;
                    }
                }

                OP(REGNODE_p(ret)) = node_type;
                setSTR_LEN(REGNODE_p(ret), len);
                RExC_emit += STR_SZ(len);

                /* If the node isn't a single character, it can't be SIMPLE */
                if (len > (Size_t) ((UTF) ? UTF8SKIP(STRING(REGNODE_p(ret))) : 1)) {
                    maybe_SIMPLE = 0;
                }

                *flagp |= HASWIDTH | maybe_SIMPLE;
            }

            Set_Node_Length(REGNODE_p(ret), p - parse_start - 1);
            RExC_parse = p;

	    {
		/* len is STRLEN which is unsigned, need to copy to signed */
		IV iv = len;
		if (iv < 0)
		    vFAIL("Internal disaster");
	    }

	} /* End of label 'defchar:' */
	break;
    } /* End of giant switch on input character */

    /* Position parse to next real character */
    skip_to_be_ignored_text(pRExC_state, &RExC_parse,
                                            FALSE /* Don't force to /x */ );
    if (   *RExC_parse == '{'
        && OP(REGNODE_p(ret)) != SBOL && ! regcurly(RExC_parse, RExC_end, NULL))
    {
        if (RExC_strict) {
            RExC_parse++;
            vFAIL("Unescaped left brace in regex is illegal here");
        }
        ckWARNreg(RExC_parse + 1, "Unescaped left brace in regex is"
                                  " passed through");
    }

    return(ret);
}
