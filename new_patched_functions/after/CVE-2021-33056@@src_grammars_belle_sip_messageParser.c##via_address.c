via_address(pbelle_sip_messageParser ctx)
{
    const char* ret;


    belle_sip_messageParser_ipv4address_return ipv4address89;
    #undef	RETURN_TYPE_ipv4address89
    #define	RETURN_TYPE_ipv4address89 belle_sip_messageParser_ipv4address_return

    belle_sip_messageParser_ipv6address_return ipv6address90;
    #undef	RETURN_TYPE_ipv6address90
    #define	RETURN_TYPE_ipv6address90 belle_sip_messageParser_ipv6address_return

    const char* ipv6reference91;
    #undef	RETURN_TYPE_ipv6reference91
    #define	RETURN_TYPE_ipv6reference91 const char*

    /* Initialize rule variables
     */
    ret = NULL;


    {
        {
            //  ../grammars/belle_sip_message.g:1417:3: ( ipv4address | ipv6address | ipv6reference )

            ANTLR3_UINT32 alt129;

            alt129=3;

            switch ( LA(1) )
            {
            case DIGIT:
            	{
            		switch ( LA(2) )
            		{
            		case DIGIT:
            			{
            				switch ( LA(3) )
            				{
            				case DIGIT:
            					{
            						switch ( LA(4) )
            						{
            						case DOT:
            							{
            								alt129=1;
            							}
            						    break;
            						case EOF:
            						case COLON:
            						case COMMA:
            						case CRLF:
            						case DIGIT:
            						case HEX_CHAR:
            						case SEMI:
            						case SP:
            							{
            								alt129=2;
            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return ret;
            						    }

            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 129;
            						    EXCEPTION->state        = 6;


            						    goto rulevia_addressEx;

            						}

            					}
            				    break;
            				case DOT:
            					{
            						alt129=1;
            					}
            				    break;
            				case EOF:
            				case COLON:
            				case COMMA:
            				case CRLF:
            				case HEX_CHAR:
            				case SEMI:
            				case SP:
            					{
            						alt129=2;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ret;
            				    }

            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 129;
            				    EXCEPTION->state        = 4;


            				    goto rulevia_addressEx;

            				}

            			}
            		    break;
            		case DOT:
            			{
            				alt129=1;
            			}
            		    break;
            		case EOF:
            		case COLON:
            		case COMMA:
            		case CRLF:
            		case HEX_CHAR:
            		case SEMI:
            		case SP:
            			{
            				alt129=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ret;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 129;
            		    EXCEPTION->state        = 1;


            		    goto rulevia_addressEx;

            		}

            	}
                break;
            case COLON:
            case HEX_CHAR:
            	{
            		alt129=2;
            	}
                break;
            case LSBRAQUET:
            	{
            		alt129=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 129;
                EXCEPTION->state        = 0;


                goto rulevia_addressEx;

            }

            switch (alt129)
            {
        	case 1:
        	    // ../grammars/belle_sip_message.g:1417:7: ipv4address
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv4address_in_via_address5366);
        	        ipv4address89=ipv4address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            ret=(const char*)
        	            (STRSTREAM->toStringTT(STRSTREAM, ipv4address89.start, ipv4address89.stop))
        	            ->chars;

        	        }


        	    }
        	    break;
        	case 2:
        	    // ../grammars/belle_sip_message.g:1418:9: ipv6address
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv6address_in_via_address5378);
        	        ipv6address90=ipv6address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            ret=(const char *)
        	            (STRSTREAM->toStringTT(STRSTREAM, ipv6address90.start, ipv6address90.stop))
        	            ->chars;

        	        }


        	    }
        	    break;
        	case 3:
        	    // ../grammars/belle_sip_message.g:1419:9: ipv6reference
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv6reference_in_via_address5390);
        	        ipv6reference91=ipv6reference(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }


        	        if ( BACKTRACKING==0 )
        	        {
        	            ret=(const char*)
        	            ipv6reference91
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulevia_addressEx; /* Prevent compiler warnings */
    rulevia_addressEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return ret;
}
