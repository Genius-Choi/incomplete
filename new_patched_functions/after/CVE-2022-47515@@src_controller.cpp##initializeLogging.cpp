    void DrachtioController::initializeLogging() {
        try {

            if( m_bNoConfig || m_Config->getConsoleLogTarget() || m_bConsoleLogging ) {

                m_sinkConsole.reset(
                    new sinks::synchronous_sink< sinks::text_ostream_backend >()
                );        
                m_sinkConsole->locked_backend()->add_stream( boost::shared_ptr<std::ostream>(&std::clog, boost::null_deleter()));

                // flush
                m_sinkConsole->locked_backend()->auto_flush(true);

                m_sinkConsole->set_formatter( &my_formatter ) ;
                          
                logging::core::get()->add_sink(m_sinkConsole);

                 logging::core::get()->set_filter(
                   expr::attr<severity_levels>("Severity") <= m_current_severity_threshold
                ) ;
            }
            if( !m_bNoConfig ) {


                // Create a syslog sink
                sinks::syslog::facility facility  ;
                string syslogAddress ;
                unsigned short syslogPort;
                
                // initalize syslog sink, if configuredd
                if( m_Config->getSyslogTarget( syslogAddress, syslogPort ) ) {
                    m_Config->getSyslogFacility( facility ) ;

                    m_sinkSysLog.reset(
                        new sinks::synchronous_sink< sinks::syslog_backend >(
                             keywords::use_impl = sinks::syslog::udp_socket_based
                            , keywords::facility = facility
                        )
                    );

                    // We'll have to map our custom levels to the syslog levels
                    sinks::syslog::custom_severity_mapping< severity_levels > mapping("Severity");
                    mapping[log_debug] = sinks::syslog::debug;
                    mapping[log_notice] = sinks::syslog::notice;
                    mapping[log_info] = sinks::syslog::info;
                    mapping[log_warning] = sinks::syslog::warning;
                    mapping[log_error] = sinks::syslog::critical;

                    m_sinkSysLog->locked_backend()->set_severity_mapper(mapping);

                    // Set the remote address to sent syslog messages to
                    m_sinkSysLog->locked_backend()->set_target_address( syslogAddress.c_str(), syslogPort );

                    logging::core::get()->add_global_attribute("RecordID", attrs::counter< unsigned int >());

                    // Add the sink to the core
                    logging::core::get()->add_sink(m_sinkSysLog);

                }

                //initialize text file sink, of configured
                string name, archiveDirectory ;
                unsigned int rotationSize, maxSize, minSize, maxFiles ;
                bool autoFlush ;
                if( m_Config->getFileLogTarget( name, archiveDirectory, rotationSize, autoFlush, maxSize, minSize, maxFiles ) ) {
                   if (!m_bGloballyReadableLogs) {
                   boost::filesystem::path p(name);
                    boost::filesystem::path dir = p.parent_path();
                    boost::filesystem::create_directory(dir);
                    std::ofstream output(name, ofstream::out | ofstream::app);
                    output.close();
                    boost::filesystem::permissions(name,
                        boost::filesystem::perms::owner_read |
                        boost::filesystem::perms::owner_write |
                        boost::filesystem::perms::group_read |
                        boost::filesystem::perms::group_write
                    );
                   }

                    m_sinkTextFile.reset(
                        new sinks::synchronous_sink< sinks::text_file_backend >(
                            keywords::file_name = name,                                          
                            keywords::rotation_size = rotationSize * 1000000,
                            keywords::auto_flush = autoFlush,
                            keywords::time_based_rotation = sinks::file::rotation_at_time_point(0, 0, 0),
                            keywords::open_mode = (std::ios::out | std::ios::app),
                            keywords::format = 
                            (
                                expr::stream
                                    << expr::attr< unsigned int >("RecordID")
                                    << ": "
                                    << expr::format_date_time< boost::posix_time::ptime >("TimeStamp", "%Y-%m-%d %H:%M:%S")
                                    << "> " << expr::smessage
                            )
                        )
                    );        

                    m_sinkTextFile->set_formatter( &my_formatter ) ;

                    m_sinkTextFile->locked_backend()->set_file_collector(sinks::file::make_collector(
                        keywords::target = archiveDirectory,                      
                        keywords::max_size = maxSize * 1000000,          
                        keywords::min_free_space = minSize * 1000000,
                        keywords::max_files = maxFiles
                    ));
                               
                    logging::core::get()->add_sink(m_sinkTextFile);
                }
                logging::core::get()->set_filter(
                   expr::attr<severity_levels>("Severity") <= m_current_severity_threshold
                ) ;
            }
            
            m_bLoggingInitialized = true ;

        }
        catch (std::exception& e) {
            std::cout << "FAILURE creating logger: " << e.what() << std::endl;
            throw e;
        }	
    }
