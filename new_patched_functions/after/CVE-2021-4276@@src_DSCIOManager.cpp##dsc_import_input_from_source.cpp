DSCIOManager::dsc_import_input_from_source() {

    dsc_populate_files_vector();
    int file_counter=file_vector_.size();
    int file_failures = 0;
    int file_commit_status = 0;  // status of transaction commit
    int data_process_status = 0; // status of data processing
    
    string node = bfs::initial_path().filename().generic_string();
    string server = bfs::initial_path().parent_path().filename().generic_string();
    //fix potential sql injection
    replace(node.begin(), node.end(), '\'', '_');
    replace(server.begin(), server.end(), '\'', '_');
    //transform to 'internal' name
    replace(server.begin(), server.end(), '-', '_');
    replace_string(server, ".", "__");
    transform(server.begin(), server.end(), server.begin(), ::tolower);
    
    cout << "*** Processing server: " << server << endl;
    cout << "*** Processing node:   " << node << endl;
    cout << "*** Found:             " << file_counter << " " <<  file_extension_ << " files to process." << endl;
    
    for (std::vector<bfs::path>::const_iterator file_vector_it (file_vector_.begin()); file_vector_it != file_vector_.end(); ++file_vector_it) {
        if ( pg_db_conn_ != NULL ) {
            pg_db_trans_ = new pqxx::work( *pg_db_conn_ );
            if ( pg_db_trans_ == NULL ) {
                cerr << "Error starting transaction." << endl;
                exit(1);
            }
        }
        cout << endl << currentDateTime() << ": Starting:  " << (*file_vector_it).string() << endl;
        DSCDataManager* dsc_data_manager = new DSCDataManager(server, node, pg_db_trans_);
        file_commit_status = 0;
        
        switch (input_) {
            case XML: {
                // Partially read the xml. This is done using a policy tree,
                // which uses rapidxml to do the parsing. There is no validation
                // performed. Each array element is a "data unit" to send to the
                // data manager load function.
                dsc_xml_ = new boost::property_tree::ptree();
                // If reading fails, exception is thrown.
                try {
                  boost::property_tree::read_xml((*file_vector_it).string(), *dsc_xml_);
                  // We can't validate the XML but make this call the check that the file 
                  // at least has the correct top level node
                  try {
                    dsc_xml_->get_child("dscdata");
                  }
                  catch( std::exception & e ) {
                    cerr << "Error: XML file has no content: " << e.what() << endl;
                    data_process_status = 1;
                    break;					
                  }
                }
                catch( std::exception & e )
                {
                    cerr << "Exception reading XML file: " << e.what() << endl;
                    data_process_status = 1;
                    break;
                }
                catch( ... )
                {
                    cerr << "Unknown exception caught" << endl;
                    data_process_status = 1;
                    break;
                }
                // Get each array element and process it
                BOOST_FOREACH(boost::property_tree::ptree::value_type &array_element, dsc_xml_->get_child("dscdata")) {
                    data_process_status = dsc_data_manager->load(array_element, rssac_);
                    if (data_process_status) break;
                    data_process_status = dsc_data_manager->process();
                    if (data_process_status) break;
                }
                delete dsc_xml_;
            }
            break;
            case DAT: {
                // Call out to strategies to find out how this dat file 
                // needs to be processed.
                // F1, F2 and F3a dat files contain multiple "data units"
                vector<DSCStrategy*>::iterator strategy_it;
                string name = (*file_vector_it).filename().string();
                std::vector<DSCStrategy*> strategies_vector = DSCStrategyFactory::createStrategyDat(server, name);
                bool multi;
                
                if (strategies_vector.size() != 1 ) { 
                    cerr << "Error: Failed to find a single strategy for loading dat file " << (*file_vector_it).string() << " (found: " << strategies_vector.size() << ")" << endl;
                    // exit(1);
                    break;
                }
                
                strategy_it = strategies_vector.begin();
                multi = (*strategy_it)->is_dat_file_multi_unit();

                if ( multi ) {
                    // read the file one line at a time
                    bfs::fstream dat_file;
                    string dat_line;
                    dat_file.open((*file_vector_it), ios_base::in);
                    while (getline(dat_file, dat_line)) {
                        if ( dsc_data_manager->load(dat_line, strategy_it) !=0 ) continue;
                        data_process_status = dsc_data_manager->process(strategy_it);
                        if (data_process_status) break;
                    }
                } else {
                    // The entire file is one "data unit"
                    dsc_data_manager->load((*file_vector_it), strategy_it);
                    data_process_status = dsc_data_manager->process(strategy_it);
                    if (data_process_status) break;
                }
            }
            break;
            default:
                // Should never get here!
                cerr << "Error: Unknown input source" << endl;
                exit(1);
        }
        
        if ( pg_db_trans_ != NULL ) {  
                if ( data_process_status == 0 ) {
                    try {
                        pg_db_trans_->commit();
                    }             
                    catch( std::exception & e ) {
                        cerr << "Commit failed with exception message: " << e.what() << endl;    
                        file_commit_status = 1;             
                    }
                    catch( ... ) {
                        cerr << "Commit failed with general error" << endl;
                        file_commit_status = 1;
                    }
                }
                // Tidy up. If the processing was not successful the transaction will implicitly rollback
                delete pg_db_trans_;
                pg_db_trans_ = NULL;         
        }      
        
        delete dsc_data_manager;        
        
        // move the file to the done directory if all is well
        if (file_commit_status == 0 && data_process_status == 0 ) {
             dsc_move_file_to_done((*file_vector_it));        
        } else {
              dsc_handle_failed_file((*file_vector_it), data_process_status);
            file_failures++;
        }
                
        // Display helpful message. Flush to ensure that it is seen.
        file_counter--;
        cout << currentDateTime() << ": Completed: " << setw(50) << left << (*file_vector_it).string() << "\t" << file_counter << " remaining (" << file_failures << " failures)."<< endl;

        std::flush(cout);
    }
    
    // clear the file vector
    file_vector_.clear();
    
    // endl since the previous cout used \r
    cout << endl;

}
