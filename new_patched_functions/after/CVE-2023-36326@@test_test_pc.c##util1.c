int util1(void) {
	int l, code = RLC_ERR;
	g1_t a, b, c;
	uint8_t bin[2 * RLC_PC_BYTES + 1];

	g1_null(a);
	g1_null(b);
	g1_null(c);

	RLC_TRY {
		g1_new(a);
		g1_new(b);
		g1_new(c);

		TEST_CASE("comparison is consistent") {
			g1_rand(a);
			g1_rand(b);
			TEST_ASSERT(g1_cmp(a, b) != RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("copy and comparison are consistent") {
			g1_rand(a);
			g1_rand(b);
			g1_rand(c);
			/* Compare points in affine coordinates. */
			if (g1_cmp(a, c) != RLC_EQ) {
				g1_copy(c, a);
				TEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);
			}
			if (g1_cmp(b, c) != RLC_EQ) {
				g1_copy(c, b);
				TEST_ASSERT(g1_cmp(b, c) == RLC_EQ, end);
			}
			/* Compare with one point in projective. */
			g1_dbl(c, a);
			g1_norm(c, c);
			g1_dbl(a, a);
			TEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);
			TEST_ASSERT(g1_cmp(a, c) == RLC_EQ, end);
			/* Compare with two points in projective. */
			g1_dbl(c, c);
			g1_dbl(a, a);
			TEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);
			TEST_ASSERT(g1_cmp(a, c) == RLC_EQ, end);
			g1_neg(b, a);
			g1_add(a, a, b);
			g1_set_infty(b);
			TEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("inversion and comparison are consistent") {
			g1_rand(a);
			g1_neg(b, a);
			TEST_ASSERT(g1_cmp(a, b) != RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE
				("assignment to random/infinity and comparison are consistent")
		{
			g1_rand(a);
			g1_set_infty(c);
			TEST_ASSERT(g1_cmp(a, c) != RLC_EQ, end);
			TEST_ASSERT(g1_cmp(c, a) != RLC_EQ, end);
		}
		TEST_END;

		TEST_CASE("assignment to infinity and infinity test are consistent") {
			g1_set_infty(a);
			TEST_ASSERT(g1_is_infty(a), end);
		}
		TEST_END;

		TEST_CASE("reading and writing a point are consistent") {
			for (int j = 0; j < 2; j++) {
				g1_set_infty(a);
				l = g1_size_bin(a, j);
				g1_write_bin(bin, l, a, j);
				g1_read_bin(b, bin, l);
				TEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);
				g1_rand(a);
				l = g1_size_bin(a, j);
				g1_write_bin(bin, l, a, j);
				g1_read_bin(b, bin, l);
				TEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);
				g1_rand(a);
				g1_dbl(a, a);
				l = g1_size_bin(a, j);
				g1_norm(a, a);
				g1_write_bin(bin, l, a, j);
				g1_read_bin(b, bin, l);
				TEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);
			}
		}
		TEST_END;
	}
	RLC_CATCH_ANY {
		util_print("FATAL ERROR!\n");
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	g1_free(a);
	g1_free(b);
	g1_free(c);
	return code;
}
