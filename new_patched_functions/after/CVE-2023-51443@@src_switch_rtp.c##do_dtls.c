static int do_dtls(switch_rtp_t *rtp_session, switch_dtls_t *dtls)
{
	int r = 0, ret = 0, len;
	switch_size_t bytes;
	unsigned char buf[MAX_DTLS_MTU] = "";
	uint8_t is_ice = rtp_session->ice.ice_user ? 1 : 0;
	int ready = is_ice ? (rtp_session->ice.rready && rtp_session->ice.ready) : 1;
	int pending;

	if (!dtls->bytes && !ready) {
		return 0;
	}

	if (is_ice && !(rtp_session->ice.type & ICE_LITE) && !rtp_session->ice.cand_responsive) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG6, "Got DTLS packet but candidate is not responsive\n");

		return 0;
	}

	if (is_ice && !switch_cmp_addr(rtp_session->from_addr, rtp_session->ice.addr, SWITCH_TRUE)) {
		char tmp_buf1[80] = "";
		char tmp_buf2[80] = "";
		const char *host_from = switch_get_addr(tmp_buf1, sizeof(tmp_buf1), rtp_session->from_addr);
		const char *host_ice_cur_addr = switch_get_addr(tmp_buf2, sizeof(tmp_buf2), rtp_session->ice.addr);

		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG5, "Got DTLS packet from [%s] whilst current ICE negotiated address is [%s]. Ignored.\n", host_from, host_ice_cur_addr);

		return 0;
	}

	if (dtls->bytes > 0 && dtls->data) {
		ret = BIO_write(dtls->read_bio, dtls->data, (int)dtls->bytes);
		if (ret <= 0) {
			ret = SSL_get_error(dtls->ssl, ret);
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS packet decode err: SSL err %d\n", rtp_type(rtp_session), ret);
		} else if (ret != (int)dtls->bytes) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS packet decode err: read %d bytes instead of %d\n", rtp_type(rtp_session), ret, (int)dtls->bytes);
		}
	}

	if (dtls_states[dtls->state]) {
		r = dtls_states[dtls->state](rtp_session, dtls);
	}

	while ((pending = BIO_ctrl_pending(dtls->filter_bio)) > 0) {
		switch_assert(pending <= sizeof(buf));

		len = BIO_read(dtls->write_bio, buf, pending);
		if (len > 0) {
			bytes = len;
			ret = switch_socket_sendto(dtls->sock_output, dtls->remote_addr, 0, (void *)buf, &bytes);

			if (ret != SWITCH_STATUS_SUCCESS) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS packet not written to socket: %d\n", rtp_type(rtp_session), ret);
			} else if (bytes != len) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS packet write err: written %d bytes instead of %d\n", rtp_type(rtp_session), (int)bytes, len);
			}
		} else {
			ret = SSL_get_error(dtls->ssl, len);
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS packet encode err: SSL err %d\n", rtp_type(rtp_session), ret);
		}
	}

	return r;
}
