static uint32_t parse_user_name(uint32_t *minor_status,
                                const char *str, size_t len,
                                char **domain, char **username)
{
    uint32_t retmaj;
    uint32_t retmin;
    char *at, *sep;

    if (len > MAX_NAME_LEN) {
        return GSSERRS(ERR_NAMETOOLONG, GSS_S_BAD_NAME);
    }

    *username = NULL;
    *domain = NULL;

    /* let's check if there are '@' or '\' signs */
    at = memchr(str, '@', len);
    sep = memchr(str, '\\', len);

    /* Check if enterprise name first */
    if (at && sep) {
        /* we may have an enterprise name here */
        char strbuf[len + 1];
        char *buf = strbuf;

        /* copy buf to manipulate it */
        memcpy(buf, str, len);
        buf[len] = '\0';

        /* adjust pointers relative to new buffer */
        sep = buf + (sep - str);
        at = buf + (at - str);

        if (sep > at) {
            /* domain name contains an '@' sign ... */
            if (*(sep + 1) == '@') {
                /* invalid case of XXX@YYY\@ZZZ*/
                set_GSSERR(EINVAL);
                goto done;
            }
        } else if (at - sep == 1) {
            /* it's just a '\@' escape */
            /* no leading domain */
            sep = NULL;
        }

        if (sep) {
            /* terminate and copy domain, even if empty */
            /* NOTE: this is important for the Windbind integration case
             * where we need to tell the machinery to *not* add the default
             * domain name, it happens when the domain is NULL. */
            *sep = '\0';
            *domain = strdup(buf);
            if (NULL == *domain) {
                set_GSSERR(ENOMEM);
                goto done;
            }
            /* point buf at username part */
            len = len - (sep - buf) - 1;
            buf = sep + 1;
        }

        for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {
            if (*(at - 1) == '\\') {
                if (*domain) {
                    /* Invalid forms like DOM\foo\@bar or foo@bar\@baz */
                    free(*domain);
                    *domain = NULL;
                    set_GSSERR(EINVAL);
                    goto done;
                }
                /* remove escape, moving all including terminating '\0' */
                memmove(at - 1, at, len - (at - buf) + 1);
            } else if (!*domain) {
                /* an '@' without escape and no previous
                 * domain was split out.
                 * the rest of the string is the domain */
                *at = '\0';
                *domain = strdup(at + 1);
                if (NULL == *domain) {
                    set_GSSERR(ENOMEM);
                    goto done;
                }
                /* note we continue the loop to check if any invalid
                 * \@ escapes is found in the domain part */
            }
            at += 1;
        }

        *username = strdup(buf);
        if (NULL == *username) {
            set_GSSERR(ENOMEM);
            goto done;
        }

        /* we got an enterprise name, return */
        set_GSSERRS(0, GSS_S_COMPLETE);
        goto done;
    }

    /* Check if in classic DOMAIN\User windows format */
    if (sep) {
        retmaj = string_split(&retmin, '\\', str, len, domain, username);
        goto done;
    }

    /* else accept a user@domain format too */
    if (at) {
        retmaj = string_split(&retmin, '@', str, len, username, domain);
        goto done;
    }

    /* finally, take string as simple user name */
    *username = strndup(str, len);
    if (NULL == *username) {
        set_GSSERR(ENOMEM);
    }
    set_GSSERRS(0, GSS_S_COMPLETE);

done:
    return GSSERR();
}
