runas_userlist_matches(const struct sudoers_parse_tree *parse_tree,
    const struct member_list *user_list, struct member **matching_user)
{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
    int user_matched = UNSPEC;
    struct member *m;
    struct alias *a;
    debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {
	switch (m->type) {
	    case ALL:
		user_matched = m->negated ? DENY : ALLOW;
		break;
	    case NETGROUP:
		if (netgr_matches(parse_tree->nss, m->name,
		    def_netgroup_tuple ? lhost : NULL,
		    def_netgroup_tuple ? shost : NULL,
		    ctx->runas.pw->pw_name))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case USERGROUP:
		if (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case ALIAS:
		a = alias_get(parse_tree, m->name, RUNASALIAS);
		if (a != NULL) {
		    const int rc = runas_userlist_matches(parse_tree,
			&a->members, matching_user);
		    if (SPECIFIED(rc)) {
			if (m->negated) {
			    user_matched = rc == ALLOW ? DENY : ALLOW;
			} else {
			    user_matched = rc;
			}
		    }
		    alias_put(a);
		    break;
		}
		FALLTHROUGH;
	    case WORD:
		if (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case MYSELF:
		/*
		 * Only match a rule with an empty runas user if a group
		 * was specified on the command line without a user _or_
		 * the user specified their own name on the command line.
		 */
		if ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) &&
			ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) ||
			strcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	}
	if (SPECIFIED(user_matched)) {
	    if (matching_user != NULL && m->type != ALIAS)
		*matching_user = m;
	    break;
	}
    }
    debug_return_int(user_matched);
}
