HTTP_HANDLE HTTPAPI_CreateConnection(const char* hostName)
{
    HTTP_HANDLE_DATA* httpHandleData;

    if (hostName == NULL)
    {
        LogError("invalid arg const char* hostName = %p", hostName);
        httpHandleData = NULL;
    }
    else
    {
        httpHandleData = (HTTP_HANDLE_DATA*)malloc(sizeof(HTTP_HANDLE_DATA));
        if (httpHandleData != NULL)
        {
            size_t hostURL_size = safe_add_size_t(strlen("https://"), strlen(hostName));
            hostURL_size = safe_add_size_t(hostURL_size, 1);

            if (hostURL_size == SIZE_MAX)
            {
                LogError("invalid malloc size");
                httpHandleData->hostURL = NULL;
            }
            else
            {
                httpHandleData->hostURL = malloc(hostURL_size);
            }

            if (httpHandleData->hostURL == NULL)
            {
                LogError("unable to malloc");
                free(httpHandleData);
                httpHandleData = NULL;
            }
            else if ((strcpy_s(httpHandleData->hostURL, hostURL_size, "https://") != 0) ||
                    (strcat_s(httpHandleData->hostURL, hostURL_size, hostName) != 0))
            {
                LogError("unable to set hostURL");
                free(httpHandleData->hostURL);
                free(httpHandleData);
                httpHandleData = NULL;
            }
            else if ((httpHandleData->curl = curl_easy_init()) == NULL)
            {
                LogError("unable to init cURL structure");
                free(httpHandleData->hostURL);
                free(httpHandleData);
                httpHandleData = NULL;
            }
            else
            {
#ifdef USE_BEARSSL
                // Gate testing currently supports version of cURL prior to cURL's BearSSL or SecureTransport support.
                // To pass Gates, cannot directly reference CURLSSLBACKEND_BEARSSL or CURLSSLBACKEND_SECURETRANSPORT.
                // Skipping validation of cURL's ssl backend.
                LogInfo("If using BearSSL with the C SDK, please confirm cURL is also configured to use BearSSL.");
#elif defined USE_OPENSSL || defined USE_WOLFSSL || defined USE_MBEDTLS

                // Check C SDK TLS platform matches cURL's
                const struct curl_tlssessioninfo* info = NULL;
                CURLcode result = curl_easy_getinfo(httpHandleData->curl, CURLINFO_TLS_SSL_PTR, &info);

                if (result != CURLE_OK || info == NULL)
                {
                    LogError("unable to get cURL backend SSL info");
                }
                else
                {
    #ifdef USE_OPENSSL
                    if (CURLSSLBACKEND_OPENSSL != (int32_t)info->backend) 
                    {
                        char* SDKSSLName = "OpenSSL";
    #elif USE_WOLFSSL
                    if (CURLSSLBACKEND_WOLFSSL != (int32_t)info->backend)
                    {
                        char* SDKSSLName = "wolfSSL";
    #elif USE_MBEDTLS
                    if (CURLSSLBACKEND_MBEDTLS != (int32_t)info->backend)
                    {
                        char* SDKSSLName = "mbedTLS";
    #else
                    // Should not get here.
    #endif
                        LogError("curl_sslbackend (%d) currently used by cURL does not match TLS platform (%s) "
                                 "used by C SDK on Linux or OSX. Please configure and compile cURL to use %s.",
                                 info->backend, SDKSSLName, SDKSSLName);
                    }
                }
#else // Other, possibly SecureTransport.
                // Gate testing currently supports version of cURL prior to cURL's BearSSL or SecureTransport support.
                // To pass Gates, cannot directly reference CURLSSLBACKEND_BEARSSL or CURLSSLBACKEND_SECURETRANSPORT.
                // Skipping validation of cURL's ssl backend.
                LogInfo("If using SecureTransport with the C SDK, please confirm cURL is also configured to use SecureTransport.");
#endif 
                httpHandleData->timeout = 242 * 1000; /*242 seconds seems like a nice enough time. Reasone for 242:
                                                        1. http://curl.haxx.se/libcurl/c/CURLOPT_TIMEOUT.html says Normally, name lookups can take a considerable time and limiting operations to less than a few minutes risk aborting perfectly normal operations.
                                                        2. 256KB of data... at 9600 bps transfers in about 218 seconds. Add to that a buffer of 10%... round it up to 242 :)*/
                httpHandleData->lowSpeedTime = 0;
                httpHandleData->lowSpeedLimit = 0;
                httpHandleData->forbidReuse = 0;
                httpHandleData->freshConnect = 0;
                httpHandleData->verbose = 0;
                httpHandleData->x509certificate = NULL;
                httpHandleData->x509privatekey = NULL;
                httpHandleData->certificates = NULL;
#ifdef USE_OPENSSL
                httpHandleData->x509privatekeytype = KEY_TYPE_DEFAULT;
#ifndef OPENSSL_NO_ENGINE
                httpHandleData->engineId = NULL;
                httpHandleData->engine = NULL;
#endif // OPENSSL_NO_ENGINE
#elif USE_MBEDTLS
                mbedtls_x509_crt_init(&httpHandleData->cert);
                mbedtls_pk_init(&httpHandleData->key);
                mbedtls_x509_crt_init(&httpHandleData->trusted_certificates);
#endif
            }
        }
    }

    return (HTTP_HANDLE)httpHandleData;
}
