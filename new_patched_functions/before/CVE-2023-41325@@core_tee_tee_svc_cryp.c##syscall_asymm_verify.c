TEE_Result syscall_asymm_verify(unsigned long state,
			const struct utee_attribute *usr_params,
			size_t num_params, const void *data, size_t data_len,
			const void *sig, size_t sig_len)
{
	struct ts_session *sess = ts_get_current_session();
	struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);
	struct tee_cryp_state *cs = NULL;
	TEE_Result res = TEE_SUCCESS;
	TEE_Attribute *params = NULL;
	struct tee_obj *o = NULL;
	size_t hash_size = 0;
	uint32_t hash_algo = 0;
	int salt_len = 0;
	size_t alloc_size = 0;

	res = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->mode != TEE_MODE_VERIFY)
		return TEE_ERROR_BAD_PARAMETERS;

	data = memtag_strip_tag_const(data);
	sig = memtag_strip_tag_const(sig);

	res = vm_check_access_rights(&utc->uctx,
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)data, data_len);
	if (res != TEE_SUCCESS)
		return res;

	res = vm_check_access_rights(&utc->uctx,
				     TEE_MEMORY_ACCESS_READ |
				     TEE_MEMORY_ACCESS_ANY_OWNER,
				     (uaddr_t)sig, sig_len);
	if (res != TEE_SUCCESS)
		return res;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
	if (!params)
		return TEE_ERROR_OUT_OF_MEMORY;
	res = copy_in_attrs(utc, usr_params, num_params, params);
	if (res != TEE_SUCCESS)
		goto out;

	res = tee_obj_get(utc, cs->key1, &o);
	if (res != TEE_SUCCESS)
		goto out;
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	switch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {
	case TEE_MAIN_ALGO_RSA:
		if (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {
			hash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);
			res = tee_alg_get_digest_size(hash_algo, &hash_size);
			if (res != TEE_SUCCESS)
				break;
			if (data_len != hash_size) {
				res = TEE_ERROR_BAD_PARAMETERS;
				break;
			}
			salt_len = pkcs1_get_salt_len(params, num_params,
						      hash_size);
		}
		res = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,
						   data, data_len, sig,
						   sig_len);
		break;

	case TEE_MAIN_ALGO_DSA:
		hash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);
		res = tee_alg_get_digest_size(hash_algo, &hash_size);
		if (res != TEE_SUCCESS)
			break;

		if (data_len != hash_size) {
			struct dsa_public_key *key = o->attr;

			/*
			 * Depending on the DSA algorithm (NIST), the
			 * digital signature output size may be truncated
			 * to the size of a key pair (Q prime size). Q
			 * prime size must be less or equal than the hash
			 * output length of the hash algorithm involved.
			 *
			 * We're checking here in order to be able to
			 * return this particular error code, which will
			 * cause TEE_AsymmetricVerifyDigest() to panic as
			 * required by GP. crypto_acipher_dsa_verify() is
			 * implemented in the glue layer of the crypto
			 * library and it might be a bit harder to catch
			 * this particular case there or lead to duplicated
			 * code in different crypto glue layers.
			 *
			 * The GP spec says that we SHOULD panic if
			 * data_len != hash_size, but that would break a
			 * few of the DSA tests in xtest where the
			 * hash_size is larger than possible data_len. So
			 * the compromise is in case data_len != hash_size
			 * check that it's not smaller than what makes
			 * sense.
			 */
			if (data_len != crypto_bignum_num_bytes(key->q)) {
				res = TEE_ERROR_BAD_PARAMETERS;
				break;
			}
		}
		res = crypto_acipher_dsa_verify(cs->algo, o->attr, data,
						data_len, sig, sig_len);
		break;

	case TEE_MAIN_ALGO_ED25519:
		res = tee_svc_obj_ed25519_verify(o->attr, data,
						 data_len, sig, sig_len,
						 params, num_params);
		break;

	case TEE_MAIN_ALGO_ECDSA:
	case TEE_MAIN_ALGO_SM2_DSA_SM3:
		res = crypto_acipher_ecc_verify(cs->algo, o->attr, data,
						data_len, sig, sig_len);
		break;

	default:
		res = TEE_ERROR_NOT_SUPPORTED;
	}

out:
	free_wipe(params);
	return res;
}
