int LightProcess::pclose(FILE *f) {
  pid_t pid;
  if (!Available()) {
    Lock lock(s_mutex);
    auto it = s_popenMap.find(f);
    if (it == s_popenMap.end()) return -1;
    pid = it->second;
    s_popenMap.erase(it);
  } else {
    auto proc = [] {
      if (tl_proc) return tl_proc;
      return &g_procs[GetId()];
    }();
    Lock lock(proc->m_procMutex);

    auto it = proc->m_popenMap.find(f);
    if (it == proc->m_popenMap.end()) return -1;
    pid = it->second;
    proc->m_popenMap.erase(it);
  }

  fclose(f);
  int status;
  if (LightProcess::waitpid(pid, &status, 0, 0) < 0) return -1;
  return status;
}
