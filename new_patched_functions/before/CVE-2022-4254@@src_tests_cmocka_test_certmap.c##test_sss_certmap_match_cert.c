static void test_sss_certmap_match_cert(void **state)
{
    struct sss_certmap_ctx *ctx;
    int ret;
    size_t c;

    struct match_tests {
        const char *rule;
        int result;
    } match_tests[] = {
        {"KRB5:<KU>digitalSignature", 0},
        {"KRB5:<KU>digitalSignature,nonRepudiation", 0},
        {"KRB5:<KU>digitalSignature,cRLSign", ENOENT},
        {"KRB5:<EKU>clientAuth", 0},
        {"KRB5:<EKU>clientAuth,OCSPSigning", ENOENT},
        {"KRB5:<EKU>clientAuth,serverAuth", 0},
        {NULL, 0}
    };

    struct match_tests match_tests_2[] = {
        {"KRB5:<KU>digitalSignature", 0},
        {"KRB5:<KU>keyEncipherment", 0},
        {"KRB5:<KU>digitalSignature,keyEncipherment", 0},
        {"KRB5:<KU>digitalSignature,keyEncipherment,cRLSign", ENOENT},
        {"KRB5:<EKU>clientAuth", 0},
        {"KRB5:<EKU>clientAuth,1.3.6.1.4.1.311.10.3.4", 0},
        {"KRB5:<EKU>clientAuth,1.3.6.1.4.1.311.10.3.41", ENOENT},
        {"KRB5:<SAN>tu1", 0},
        {"KRB5:<SAN:Principal>tu1", 0},
        {"KRB5:<SAN:ntPrincipalName>tu1", 0},
        {"KRB5:<SAN:pkinitSAN>tu1", ENOENT},
        {"KRB5:<SAN:Principal>^tu1@ad.devel$", 0},
        {"KRB5:<SAN:rfc822Name>tu", ENOENT},
        {"KRB5:<SAN:rfc822Name>test.user", 0},
        {"KRB5:<SAN:rfc822Name>test.user<SAN>tu1", 0},
        {"KRB5:||<SAN:rfc822Name>test.user<SAN>tu1", 0},
        {"KRB5:&&<SAN:rfc822Name>tu1<SAN>tu1", ENOENT},
        {"KRB5:||<SAN:rfc822Name>tu1<SAN>tu1", 0},
        {"KRB5:<SAN:otherName>MTIz", ENOENT}, /* 123 */
        {"KRB5:<SAN:otherName>DAx0dTFAYWQuZGV2ZWw=", 0}, /* "\f\ftu1@ad.devel" */
        {"KRB5:<SAN:otherName>DAx0dTFAYWQuZGV2ZWx4", ENOENT}, /* "\f\ftu1@ad.develx" */
        {"KRB5:<SAN:otherName>dHUxQGFkLmRldmVs", 0}, /* "tu1@ad.devel" */
        {"KRB5:<SAN:1.3.6.1.4.1.311.20.2.3>test", ENOENT},
        {"KRB5:<SAN:1.3.6.1.4.1.311.20.2.3>tu1@ad", 0},
        /* Fails because the NT principal SAN starts with binary values */
        {"KRB5:<SAN:1.3.6.1.4.1.311.20.2.3>^tu1@ad.devel$", ENOENT},
        {NULL, 0}
    };

    struct match_tests match_tests_3[] = {
        {"KRB5:<KU>digitalSignature", 0},
        {"KRB5:<KU>keyEncipherment", 0},
        {"KRB5:<KU>keyAgreement", 0},
        {"KRB5:<KU>digitalSignature,keyAgreement,keyEncipherment", 0},
        {"KRB5:<SAN:Principal>test", 0},
        {"KRB5:<SAN:ntPrincipal>test", ENOENT},
        {"KRB5:<SAN:Principal>comp2", 0},
        {"KRB5:<SAN:Principal>another", 0},
        {"KRB5:<SAN:Principal>test/comp2/another@SSSD.TEST", 0},
        {"KRB5:<SAN:Principal>^test/comp2/another@SSSD.TEST$", 0},
        {"KRB5:<SAN:pkinitSAN>^test/comp2/another@SSSD.TEST$", 0},
        {NULL, 0}
    };

    ret = sss_certmap_init(NULL, ext_debug, NULL, &ctx);
    assert_int_equal(ret, EOK);
    assert_non_null(ctx);
    assert_null(ctx->prio_list);

    ret = sss_certmap_add_rule(ctx, 1, "KRB5:<ISSUER>xyz<SUBJECT>xyz",
                               NULL, NULL);
    assert_int_equal(ret, EOK);

    ret = sss_certmap_match_cert(ctx, discard_const(test_cert_der),
                                 sizeof(test_cert_der));
    assert_int_equal(ret, ENOENT);

    ret = sss_certmap_add_rule(ctx, 1,
                            "KRB5:<ISSUER>CN=Certificate Authority,O=IPA.DEVEL",
                            NULL, NULL);
    assert_int_equal(ret, EOK);

    ret = sss_certmap_match_cert(ctx, discard_const(test_cert_der),
                                 sizeof(test_cert_der));
    assert_int_equal(ret, 0);

    sss_certmap_free_ctx(ctx);

    for (c = 0; match_tests[c].rule != NULL; c++) {
        ret = sss_certmap_init(NULL, ext_debug, NULL, &ctx);
        assert_int_equal(ret, EOK);
        assert_non_null(ctx);
        assert_null(ctx->prio_list);

        ret = sss_certmap_add_rule(ctx, 1, match_tests[c].rule, NULL, NULL);
        assert_int_equal(ret, EOK);

        ret = sss_certmap_match_cert(ctx, discard_const(test_cert_der),
                                     sizeof(test_cert_der));
        assert_int_equal(ret, match_tests[c].result);

        sss_certmap_free_ctx(ctx);
    }

    for (c = 0; match_tests_2[c].rule != NULL; c++) {
        ret = sss_certmap_init(NULL, ext_debug, NULL, &ctx);
        assert_int_equal(ret, EOK);
        assert_non_null(ctx);
        assert_null(ctx->prio_list);

        print_error("Checking matching rule [%s]\n", match_tests_2[c].rule);

        ret = sss_certmap_add_rule(ctx, 1, match_tests_2[c].rule, NULL, NULL);
        assert_int_equal(ret, EOK);

        ret = sss_certmap_match_cert(ctx, discard_const(test_cert2_der),
                                     sizeof(test_cert2_der));
        assert_int_equal(ret, match_tests_2[c].result);

        sss_certmap_free_ctx(ctx);
    }

    for (c = 0; match_tests_3[c].rule != NULL; c++) {
        ret = sss_certmap_init(NULL, ext_debug, NULL, &ctx);
        assert_int_equal(ret, EOK);
        assert_non_null(ctx);
        assert_null(ctx->prio_list);

        print_error("Checking matching rule [%s]\n", match_tests_3[c].rule);

        ret = sss_certmap_add_rule(ctx, 1, match_tests_3[c].rule, NULL, NULL);
        assert_int_equal(ret, EOK);

        ret = sss_certmap_match_cert(ctx, discard_const(test_cert3_der),
                                     sizeof(test_cert3_der));
        assert_int_equal(ret, match_tests_3[c].result);

        sss_certmap_free_ctx(ctx);
    }
}
