sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,
    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,
    int *cmnd_status, int pwflag)
{
    struct defaults_list *defs = NULL;
    struct sudoers_parse_tree *parse_tree = NULL;
    struct cmndspec *cs = NULL;
    struct sudo_nss *nss;
    struct cmnd_info info;
    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;
    int m, match = UNSPEC;
    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);

    /*
     * Special case checking the "validate", "list" and "kill" pseudo-commands.
     */
    if (pwflag) {
	debug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,
	    cb_data, pwflag));
    }

    /* Need to be runas user while stat'ing things. */
    if (!set_perms(ctx, PERM_RUNAS))
	debug_return_uint(validated);

    /* Query each sudoers source and check the user. */
    TAILQ_FOREACH(nss, snl, entries) {
	if (nss->query(ctx, nss, ctx->user.pw) == -1) {
	    /* The query function should have printed an error message. */
	    SET(validated, VALIDATE_ERROR);
	    break;
	}

	m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,
	    cb_data, &cs, &defs);
	if (m != UNSPEC) {
	    match = m;
	    parse_tree = nss->parse_tree;
	}

	if (!sudo_nss_can_continue(nss, m))
	    break;
    }
    if (match != UNSPEC) {
	if (info.cmnd_path != NULL) {
	    /* Update cmnd, cmnd_stat, cmnd_status from matching entry. */
	    free(ctx->user.cmnd);
	    ctx->user.cmnd = info.cmnd_path;
	    if (ctx->user.cmnd_stat != NULL)
		*ctx->user.cmnd_stat = info.cmnd_stat;
	    *cmnd_status = info.status;
	}
	if (defs != NULL)
	    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);
	if (!apply_cmndspec(ctx, cs))
	    SET(validated, VALIDATE_ERROR);
	else if (match == ALLOW)
	    SET(validated, VALIDATE_SUCCESS);
	else
	    SET(validated, VALIDATE_FAILURE);
    }
    if (!restore_perms())
	SET(validated, VALIDATE_ERROR);
    debug_return_uint(validated);
}
