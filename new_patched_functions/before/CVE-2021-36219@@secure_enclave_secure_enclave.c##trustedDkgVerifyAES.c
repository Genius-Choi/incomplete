void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share,
                          uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) {


    LOG_DEBUG (__FUNCTION__);

    char skey[ECDSA_SKEY_LEN];
    memset(skey, 0, ECDSA_SKEY_LEN);
    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey);


    if (status != SGX_SUCCESS) {
        snprintf(errString, BUF_LEN, "AES_decrypt failed (in trustedDkgVerifyAES)  with status %d", status);
        *errStatus = status;
        return;
    }

    char encr_sshare[ECDSA_SKEY_LEN];
    memset(encr_sshare, 0, ECDSA_SKEY_LEN);
    strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);


    char common_key[ECDSA_SKEY_LEN];
    memset(common_key, 0, ECDSA_SKEY_LEN);

    session_key_recover(skey, s_share, common_key);

    if (common_key == NULL || strlen(common_key) == 0) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid common_key");
        return;
    }

    char decr_sshare[ECDSA_SKEY_LEN];
    memset(decr_sshare, 0, ECDSA_SKEY_LEN);
    xor_decrypt(common_key, encr_sshare, decr_sshare);
    if (decr_sshare == NULL) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid common_key");
        return;
    }

    mpz_t s;
    mpz_init(s);
    if (mpz_set_str(s, decr_sshare, 16) == -1) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid decr secret share");
        mpz_clear(s);
        return;
    }

    *result = Verification(public_shares, s, _t, _ind);

    snprintf(errString, BUF_LEN, "secret share dec %s", public_shares);

}
