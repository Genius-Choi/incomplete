accept_param(pbelle_sip_messageParser ctx)
{
    belle_sip_messageParser_accept_main_media_type_return accept_main_media_type104;
    #undef	RETURN_TYPE_accept_main_media_type104
    #define	RETURN_TYPE_accept_main_media_type104 belle_sip_messageParser_accept_main_media_type_return

    belle_sip_messageParser_accept_sub_media_type_return accept_sub_media_type105;
    #undef	RETURN_TYPE_accept_sub_media_type105
    #define	RETURN_TYPE_accept_sub_media_type105 belle_sip_messageParser_accept_sub_media_type_return

    /* Initialize rule variables
     */
    ctx->pbelle_sip_messageParser_accept_paramTop = pbelle_sip_messageParser_accept_paramPush(ctx);
     if ((SCOPE_TOP(header_accept))->current == NULL) {
    	(SCOPE_TOP(header_accept))->first= (SCOPE_TOP(header_accept))->current = belle_sip_header_accept_new();
    	(SCOPE_TOP(accept_param))->prev=NULL;
    } else {
    	belle_sip_header_t* header;
    	(SCOPE_TOP(accept_param))->prev=(SCOPE_TOP(header_accept))->current;
    	header = BELLE_SIP_HEADER((SCOPE_TOP(header_accept))->current);
    	belle_sip_header_set_next(header,(belle_sip_header_t*)((SCOPE_TOP(header_accept))->current= belle_sip_header_accept_new()));
    }

    {
        // ../grammars/belle_sip_message.g:1628:4: ( accept_main_media_type slash accept_sub_media_type ( semi generic_param[BELLE_SIP_PARAMETERS($header_accept::current)] )* )
        // ../grammars/belle_sip_message.g:1628:4: accept_main_media_type slash accept_sub_media_type ( semi generic_param[BELLE_SIP_PARAMETERS($header_accept::current)] )*
        {
            FOLLOWPUSH(FOLLOW_accept_main_media_type_in_accept_param6117);
            accept_main_media_type104=accept_main_media_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaccept_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_accept_paramPop(ctx);

                return ;
            }


            if ( BACKTRACKING==0 )
            {
                belle_sip_header_accept_set_type((SCOPE_TOP(header_accept))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, accept_main_media_type104.start, accept_main_media_type104.stop))
                ->chars);
            }


            FOLLOWPUSH(FOLLOW_slash_in_accept_param6121);
            slash(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaccept_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_accept_paramPop(ctx);

                return ;
            }


            FOLLOWPUSH(FOLLOW_accept_sub_media_type_in_accept_param6123);
            accept_sub_media_type105=accept_sub_media_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaccept_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_accept_paramPop(ctx);

                return ;
            }


            if ( BACKTRACKING==0 )
            {
                belle_sip_header_accept_set_subtype((SCOPE_TOP(header_accept))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, accept_sub_media_type105.start, accept_sub_media_type105.stop))
                ->chars);
            }


            // ../grammars/belle_sip_message.g:1631:2: ( semi generic_param[BELLE_SIP_PARAMETERS($header_accept::current)] )*

            for (;;)
            {
                int alt140=2;
                alt140 = cdfa140.predict(ctx, RECOGNIZER, ISTREAM, &cdfa140);
                if  (HASEXCEPTION())
                {
                    goto ruleaccept_paramEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_accept_paramPop(ctx);

                    return ;
                }

                switch (alt140)
                {
            	case 1:
            	    // ../grammars/belle_sip_message.g:1631:2: semi generic_param[BELLE_SIP_PARAMETERS($header_accept::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_accept_param6128);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaccept_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_accept_paramPop(ctx);

            	            return ;
            	        }


            	        FOLLOWPUSH(FOLLOW_generic_param_in_accept_param6131);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS((SCOPE_TOP(header_accept))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaccept_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_accept_paramPop(ctx);

            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop140;	/* break out of the loop */
            	    break;
                }
            }
            loop140: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaccept_paramEx; /* Prevent compiler warnings */
    ruleaccept_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_accept_paramPop(ctx);

    return ;
}
