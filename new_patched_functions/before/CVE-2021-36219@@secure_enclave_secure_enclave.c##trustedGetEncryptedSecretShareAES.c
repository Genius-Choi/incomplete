void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,
                         char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) {

    char skey[ECDSA_SKEY_LEN];
    memset(skey, 0, BUF_LEN);
    char pub_key_x[BUF_LEN];
    memset(pub_key_x, 0, BUF_LEN);
    char pub_key_y[BUF_LEN];
    memset(pub_key_y, 0, BUF_LEN);

    uint32_t enc_len;

    trustedGenerateEcdsaKeyAES(errStatus, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);
    if (*errStatus != 0) {
        return;
    }


    int status = AES_decrypt(encrypted_skey, enc_len, skey);
    skey[ECDSA_SKEY_LEN - 1] = 0;

    if (status != SGX_SUCCESS) {
        snprintf(errString, BUF_LEN, "AES_decrypt failed (in trustedGetEncryptedSecretShareAES)  with status %d", status);
        *errStatus = status;
        return;
    }
    snprintf(errString, BUF_LEN, "unsealed random skey is %s\n", skey);

    *dec_len = enc_len;// + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;

    char *common_key[ECDSA_SKEY_LEN];
    gen_session_key(skey, pub_keyB, common_key);

    char *s_share[ECDSA_SKEY_LEN];


    if (calc_secret_share(decryptedDkgPoly, s_share, _t, _n, ind) != 0) {
        *errStatus = -1;

        snprintf(errString, BUF_LEN, decryptedDkgPoly);
        return;
    }
    snprintf(errString + 88, BUF_LEN, "\nsecret share is %s", s_share);

    if (calc_secret_shareG2(s_share, s_shareG2) != 0) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "invalid decr secret share");
        return;
    }

    char *cypher[ECDSA_SKEY_LEN];
    xor_encrypt(common_key, s_share, cypher);
    if (cypher == NULL) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid common_key");
        return;
    }


    strncpy(result_str, cypher, strlen(cypher));
    strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));
    strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));


}
