int main(int argc, char * argv[]) {
    int mode = MODE_ENCODE;

    // input and output file names
    char *input = NULL, *output = NULL;
    char *f1 = NULL, *f2 = NULL;
    int force = 0;

    // command line arguments
    int force_stdstreams = 0, workers = 0, batch = 0, verbose = 0;

    // the block size
    u32 block_size = MiB(16);

#ifdef PTHREAD
    const char * short_options = "Bb:cdefhj:ktvVz";
#else
    const char * short_options = "Bb:cdefhktvVz";
#endif

    static struct option long_options[] = { { "encode", no_argument, 0, 'e' },
                                            { "decode", no_argument, 0, 'd' },
                                            { "test", no_argument, 0, 't' },
                                            { "stdout", no_argument, 0, 'c' },
                                            { "force", no_argument, 0, 'f' },
                                            { "help", no_argument, 0, 'h' },
                                            { "keep", no_argument, 0, 'k' },
                                            { "version", no_argument, 0, 'V' },
                                            { "verbose", no_argument, 0, 'v' },
                                            { "block", required_argument, 0, 'b' },
                                            { "batch", no_argument, 0, 'B' },
#ifdef PTHREAD
                                            { "jobs", required_argument, 0, 'j' },
#endif
                                            { 0, 0, 0, 0 } };

    while (1) {
        int option_index = 0;
        int c = getopt_long(argc, argv, short_options, long_options, &option_index);
        if (c == -1) break;

        switch (c) {
            case '?':
                fprintf(stderr, "Try 'bzip3 --help' for more information.\n");
                return 1;
            case 'e': case 'z':
                mode = MODE_ENCODE;
                break;
            case 'd':
                mode = MODE_DECODE;
                break;
            case 't':
                mode = MODE_TEST;
                break;
            case 'c':
                force_stdstreams = 1;
                break;
            case 'f':
                force = 1;
                break;
            case 'k':
                break;
            case 'h':
                help();
                return 0;
            case 'V':
                version();
                return 0;
            case 'B':
                batch = 1;
                break;
            case 'v':
                verbose = 1;
                break;
            case 'b':
                if (!is_numeric(optarg)) {
                    fprintf(stderr, "bzip3: invalid block size: %s\n", optarg);
                    return 1;
                }
                block_size = MiB(atoi(optarg));
                break;
#ifdef PTHREAD
            case 'j':
                if (!is_numeric(optarg)) {
                    fprintf(stderr, "bzip3: invalid amount of jobs: %s\n", optarg);
                    return 1;
                }
                workers = atoi(optarg);
                break;
#endif
        }
    }

#if defined(__MSVCRT__)
    setmode(STDIN_FILENO, O_BINARY);
    setmode(STDOUT_FILENO, O_BINARY);
#endif

    if (block_size < KiB(65) || block_size > MiB(511)) {
        fprintf(stderr, "Block size must be between 65 KiB and 511 MiB.\n");
        return 1;
    }

    if (batch) {
        switch (mode) {
            case MODE_ENCODE:
                /* Encode each of the files. */
                while (optind < argc) {
                    char * arg = argv[optind++];

                    FILE * input_des = open_input(arg);
                    char * output_name;
                    if (force_stdstreams)
                        output_name = NULL;
                    else {
                        output_name = malloc(strlen(arg) + 5);
                        strcpy(output_name, arg);
                        strcat(output_name, ".bz3");
                    }

                    FILE * output_des = open_output(output_name, force);
                    process(input_des, output_des, mode, block_size, workers, verbose, arg);

                    fclose(input_des);
                    close_out_file(output_des);
                    if (!force_stdstreams) free(output_name);
                }
                break;
            case MODE_DECODE:
                /* Decode each of the files. */
                while (optind < argc) {
                    char * arg = argv[optind++];

                    FILE * input_des = open_input(arg);
                    char * output_name;
                    if (force_stdstreams)
                        output_name = NULL;
                    else {
                        output_name = malloc(strlen(arg) + 1);
                        strcpy(output_name, arg);
                        if (strlen(output_name) > 4 && !strcmp(output_name + strlen(output_name) - 4, ".bz3"))
                            output_name[strlen(output_name) - 4] = 0;
                        else {
                            fprintf(stderr, "Warning: file %s has an unknown extension, skipping.\n", arg);
                            return 1;
                        }
                    }

                    FILE * output_des = open_output(output_name, force);
                    process(input_des, output_des, mode, block_size, workers, verbose, arg);

                    fclose(input_des);
                    close_out_file(output_des);
                    if (!force_stdstreams) free(output_name);
                }
                break;
            case MODE_TEST:
                /* Test each of the files. */
                while (optind < argc) {
                    char * arg = argv[optind++];

                    FILE * input_des = open_input(arg);
                    process(input_des, NULL, mode, block_size, workers, verbose, arg);
                    fclose(input_des);
                }
                break;
        }

        if (fclose(stdout)) {
            fprintf(stderr, "Error: Failed on fclose(stdout): %s\n", strerror(errno));
            return 1;
        }

        return 0;
    }

    while (optind < argc) {
        // Positional argument. Likely a file name.
        char * arg = argv[optind++];

        if (f1 != NULL && f2 != NULL) {
            fprintf(stderr, "Error: too many files specified.\n");
            return 1;
        }

        if (f1 == NULL)
            f1 = arg;
        else
            f2 = arg;
    }

    if (f1 == NULL && f2 == NULL)
        input = NULL, output = NULL;
    else if (mode == MODE_TEST)
        input = f1;
    else {
        if (mode == MODE_ENCODE) {
            if (f2 == NULL) {
                // encode from f1?
                input = f1;
                if (force_stdstreams)
                    output = NULL;
                else {
                    output = malloc(strlen(f1) + 5);
                    strcpy(output, f1);
                    strcat(output, ".bz3");
                }
            } else {
                // encode from f1 to f2.
                input = f1;
                output = f2;
            }
        } else if (mode == MODE_DECODE) {
            if (f2 == NULL) {
                // decode from f1 to stdout.
                input = f1;
                if (force_stdstreams)
                    output = NULL;
                else {
                    output = malloc(strlen(f1) + 1);
                    strcpy(output, f1);
                    if (strlen(output) > 4 && !strcmp(output + strlen(output) - 4, ".bz3"))
                        output[strlen(output) - 4] = 0;
                    else {
                        fprintf(stderr, "Warning: file %s has an unknown extension, skipping.\n", f1);
                        return 1;
                    }
                }
            } else {
                // decode from f1 to f2.
                input = f1;
                output = f2;
            }
        }
    }

    FILE *input_des = NULL, *output_des = NULL;

    output_des = mode != MODE_TEST ? open_output(output, force) : NULL;
    input_des = open_input(input);

    int r = process(input_des, output_des, mode, block_size, workers, verbose, input);

    fclose(input_des);
    close_out_file(output_des);
    if (fclose(stdout)) {
        fprintf(stderr, "Error: Failed on fclose(stdout): %s\n", strerror(errno));
        return 1;
    }

    return r;
}
