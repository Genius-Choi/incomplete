vlvSearch_init(struct vlvSearch* p, Slapi_PBlock *pb, const Slapi_Entry *e, ldbm_instance *inst)
{
    /* VLV specification */
    /* Need to copy the entry here because this one is in the cache, 
     * not forever ! */
    p->vlv_e= slapi_entry_dup( e ); 
    p->vlv_dn= slapi_sdn_dup(slapi_entry_get_sdn_const(e));
    p->vlv_name= slapi_entry_attr_get_charptr(e,type_vlvName);
    p->vlv_base= slapi_sdn_new_dn_passin(slapi_entry_attr_get_charptr(e,type_vlvBase));
    p->vlv_scope= slapi_entry_attr_get_int(e,type_vlvScope);
    p->vlv_filter= slapi_entry_attr_get_charptr(e,type_vlvFilter);
    p->vlv_initialized = 1;

    /* JCM: Should perform some validation and report errors to the error log */
    /* JCM: Add brackets around the filter if none are there... */
    trimspaces(p->vlv_name);
    trimspaces(p->vlv_filter);

    if(strlen(p->vlv_filter)>0)
    {
        /* Convert the textual filter, into a Slapi_Filter structure */
        p->vlv_slapifilter= slapi_str2filter( p->vlv_filter );
        filter_normalize(p->vlv_slapifilter);
    }

    /* JCM: Really should convert the slapifilter into a string and use that. */

    /* Convert the filter based on the scope of the search */
    switch(p->vlv_scope)
    {
	case LDAP_SCOPE_BASE:
        /* Don't need to alter the filter */
		break;
	case LDAP_SCOPE_ONELEVEL:
        {
    	/*
    	 * Get the base object for the search.
    	 * The entry "" will never be contained in the database,
    	 * so treat it as a special case.
    	 */
        struct backentry *e= NULL;
    	if ( !slapi_sdn_isempty(p->vlv_base)) {
            Slapi_Backend *oldbe = NULL;
            entry_address addr;
            back_txn txn = {NULL};

            /* switch context to the target backend */
            slapi_pblock_get(pb, SLAPI_BACKEND, &oldbe);
            slapi_pblock_set(pb, SLAPI_BACKEND, inst->inst_be);
            slapi_pblock_set(pb, SLAPI_PLUGIN, inst->inst_be->be_database);
            slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);

            addr.sdn = p->vlv_base;
            addr.uniqueid = NULL;
            e = find_entry( pb, inst->inst_be, &addr, &txn );
            /* Check to see if the entry is absent. If it is, mark this search
             * as not initialized */
            if (NULL == e) {
                p->vlv_initialized = 0;
		/* We crash on anyhow, and rely on the fact that the filter
                 * we create is bogus to prevent chaos */
            }

            /* switch context back to the DSE backend */
            slapi_pblock_set(pb, SLAPI_BACKEND, oldbe);
            slapi_pblock_set(pb, SLAPI_PLUGIN, oldbe->be_database);
        }

    	/* make (&(parentid=idofbase)(|(originalfilter)(objectclass=referral))) */
        {
            Slapi_Filter *fid2kids= NULL;
            Slapi_Filter *focref= NULL;
            Slapi_Filter *fand= NULL;
            Slapi_Filter *forr= NULL;
        p->vlv_slapifilter= create_onelevel_filter(p->vlv_slapifilter, e, 0 /* managedsait */, &fid2kids, &focref, &fand, &forr);
        /* jcm: fid2kids, focref, fand, and forr get freed when we free p->vlv_slapifilter */
            CACHE_RETURN(&inst->inst_cache,&e);
        }
        }
		break;
	case LDAP_SCOPE_SUBTREE:
        {
        /* make (|(originalfilter)(objectclass=referral))) */
        /* No need for scope-filter since we apply a scope test before the filter test */
    	Slapi_Filter *focref= NULL;
    	Slapi_Filter *forr= NULL;
        p->vlv_slapifilter= create_subtree_filter(p->vlv_slapifilter,  0 /* managedsait */, &focref, &forr);
        /* jcm: focref and forr get freed when we free p->vlv_slapifilter */
        }
		break;
    }
}
