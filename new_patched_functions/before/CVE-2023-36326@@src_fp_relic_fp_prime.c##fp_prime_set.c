static void fp_prime_set(const bn_t p) {
	bn_t t;
	fp_t r;
	ctx_t *ctx = core_get();

	if (p->used != RLC_FP_DIGS) {
		RLC_THROW(ERR_NO_VALID);
		return;
	}

	bn_null(t);
	fp_null(r);

	RLC_TRY {
		bn_new(t);
		fp_new(r);

		bn_copy(&(ctx->prime), p);

#if FP_RDC == MONTY || !defined(STRIP)

		bn_mod_pre_monty(t, &(ctx->prime));
		ctx->u = t->dp[0];

		/* compute R mod p */
		bn_set_dig(&(ctx->one), 1);
		bn_lsh(&(ctx->one), &(ctx->one), RLC_FP_DIGS * RLC_DIG);
		bn_mod(&(ctx->one), &(ctx->one), &(ctx->prime));

		/* compute the R^2 mod p */
		fp_add(r, ctx->one.dp, ctx->one.dp);
		bn_set_dig(t, RLC_FP_DIGS);
		bn_lsh(t, t, RLC_DIG_LOG);
		fp_exp(ctx->conv.dp, r, t);
		ctx->conv.used = RLC_FP_DIGS;
		bn_trim(&(ctx->conv));

#endif /* FP_RDC == MONTY */

#if FP_INV == JUMPDS || !defined(STRIP)

		int d = (45907 * FP_PRIME + 26313) / 19929;

#if WSIZE == 8
		bn_set_dig(t, d >> 8);
		bn_lsh(t, t, 8);
		bn_add_dig(t, t, d & 0xFF);
#else
		bn_set_dig(t, d);
#endif
		ctx->inv.used = RLC_FP_DIGS;
		dv_copy(ctx->inv.dp, fp_prime_get(), RLC_FP_DIGS);
		fp_add_dig(ctx->inv.dp, ctx->inv.dp, 1);
		fp_hlv(ctx->inv.dp, ctx->inv.dp);
		fp_exp(ctx->inv.dp, ctx->inv.dp, t);

#if FP_RDC == MONTY

#if (FP_PRIME % WSIZE) != 0
		fp_mul(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);
		fp_mul(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);

		for (int i = 1, j = 0; i < d / (RLC_DIG - 2); i++) {
			j = i % RLC_FP_DIGS;
			if (j == 0) {
				fp_mulm_low(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);
			}
		}
#endif

#endif /* FP_RDC == MONTY */

#endif /* FP_INV */

		/* Now look for proper quadratic/cubic non-residues. */
		ctx->qnr = ctx->cnr = 0;
		bn_mod_dig(&(ctx->mod8), &(ctx->prime), 8);

		switch (ctx->mod8) {
			case 3:
				ctx->qnr = -1;
				ctx->cnr = 2;
				break;
			case 7:
				ctx->qnr = -1;
				ctx->cnr = -2;
				/* TODO: implement cube root to handle this better. */
#if FP_PRIME == 638
				ctx->cnr = -3;
#endif
				break;
			case 1:
			case 5:
				ctx->qnr = -2;
				ctx->cnr = 2;
				/* Check if it is a quadratic non-residue or find another. */
				fp_set_dig(r, -ctx->qnr);
				fp_neg(r, r);
				while (fp_srt(r, r) == 1) {
					ctx->qnr--;
					fp_set_dig(r, -ctx->qnr);
					fp_neg(r, r);
					/* We cannot guarantee a cubic extension anymore. */
					ctx->cnr = 0;
				};
				break;
		}
#ifdef FP_QNRES
		if (ctx->mod8 != 3) {
			RLC_THROW(ERR_NO_VALID);
		}
#endif

		ctx->ad2 = 0;
		bn_sub_dig(t, p, 1);
		while (bn_is_even(t)) {
			ctx->ad2++;
			bn_hlv(t, t);
		}

		fp_prime_calc();
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(t);
		fp_free(r);
	}
}
