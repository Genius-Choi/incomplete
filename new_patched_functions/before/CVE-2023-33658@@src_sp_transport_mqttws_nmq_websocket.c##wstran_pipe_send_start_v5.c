wstran_pipe_send_start_v5(ws_pipe *p, nni_msg *msg, nni_aio *aio)
{
	nni_msg *smsg;
	int       niov;
	nni_iov   iov[8];
	nni_pipe *pipe = p->npipe;
	uint8_t   qos = 0;


	if (nni_msg_get_type(msg) != CMD_PUBLISH)
		goto send;

	// never modify the original msg
	uint8_t *     body, *header, qos_pac;
	target_prover target_prover;
	int           len_offset = 0, sub_id = 0;
	uint16_t      pid;
	uint32_t tprop_bytes = 0, prop_bytes = 0, id_bytes = 0, property_len = 0;
	size_t        tlen, rlen, mlen, hlen, qlength, plength;
	bool          is_sqlite = p->conf->sqlite.enable;

	body    = nni_msg_body(msg);
	header  = nni_msg_header(msg);
	niov    = 0;
	qlength = 0;
	plength = 0;
	mlen    = nni_msg_len(msg);
	hlen    = nni_msg_header_len(msg);
	qos_pac = nni_msg_get_pub_qos(msg);
	NNI_GET16(body, tlen);

	// check max packet size for this client/msg
	uint32_t total_len = mlen + hlen;
	if (total_len > p->ws_param->max_packet_size) {
		// drop msg and finish aio
		// pretend it has been sent
		log_warn("msg dropped due to overceed max packet size!");
		nni_msg_free(msg);
		nni_aio_set_msg(aio, NULL);
		nni_aio_finish(aio, 0, 0);
		return;
	}

	if (nni_msg_cmd_type(msg) == CMD_PUBLISH_V5) {
		// V5 to V4 shrink msg, remove property length
		// APP layer must give topic name even if topic
		// alias is set
		if (qos_pac > 0) {
			property_len = get_var_integer(
			    body + 4 + tlen, &prop_bytes);

		} else {
			property_len = get_var_integer(
			    body + 2 + tlen, &prop_bytes);
		}
		target_prover = MQTTV5;
		plength = property_len + prop_bytes;
	}

	// subid
	subinfo *info = NULL;
	nni_msg_alloc(&smsg, 0);

	NNI_LIST_FOREACH (p->npipe->subinfol, info) {
		if (info->no_local == 1 &&
		    p->npipe->p_id == nni_msg_get_pipe(msg)) {
			continue;
		}
		len_offset      = 0;
		char *sub_topic = info->topic;
		if (sub_topic[0] == '$') {
			if (0 ==
			    strncmp(sub_topic, "$share/", strlen("$share/"))) {
				sub_topic = strchr(sub_topic, '/');
				sub_topic++;
				sub_topic = strchr(sub_topic, '/');
				sub_topic++;
			}
		}
		if (topic_filtern(sub_topic, (char *) (body + 2), tlen)) {
			uint8_t  var_extra[2], fixheader, tmp[4] = { 0 };
			uint8_t  proplen[4] = { 0 }, var_subid[5] = { 0 };
			uint32_t pos = 1;
			sub_id       = info->subid;
			qos          = info->qos;

			//else use original var payload & pid
			fixheader = *header;
			if (nni_msg_cmd_type(msg) == CMD_PUBLISH) {
				// V4 to V5 add 0 property length
				target_prover = MQTTV4_V5;
				prop_bytes    = 1;
				tprop_bytes   = 1;
				len_offset    = 1;
			}
			if (info->rap == 0) {
				fixheader = fixheader & 0xFE;
			}
			if (sub_id != 0) {
				var_subid[0] = 0x0B;
				id_bytes = put_var_integer(var_subid+1, sub_id);
				tprop_bytes = put_var_integer(proplen, property_len+1+id_bytes);
				len_offset += (tprop_bytes - prop_bytes + 1 + id_bytes);
			}

			// get final qos
			qos = qos_pac > qos ? qos : qos_pac;

			// alter qos according to sub qos
			if (qos_pac > qos) {
				if (qos == 1) {
					// set qos to 1
					fixheader = fixheader & 0xF9;
					fixheader = fixheader | 0x02;
				} else {
					// set qos to 0
					fixheader = fixheader & 0xF9;
					len_offset   = len_offset - 2;
				}
			}
			// fixed header + remaining length
			rlen = put_var_integer(
			    tmp, get_var_integer(header, &pos) + len_offset);
			// or just copy to qosbuf directly?
			*(p->qos_buf + qlength) = fixheader;
			memcpy(p->qos_buf + qlength + 1, tmp, rlen);
			iov[niov].iov_buf = p->qos_buf + qlength;
			iov[niov].iov_len = rlen + 1;
			niov++;
			qlength += rlen + 1;
			// 1st part of variable header: topic + topic len
			iov[niov].iov_buf = body;
			iov[niov].iov_len = tlen+2;
			niov++;
			// len to indicate the offset in packet
			len_offset = 0;
			plength = 0;
			if (qos > 0) {
				// set pid
				len_offset = 2;
				nni_msg *old;
				// packetid in aio to differ resend msg
				// TODO replace it with set prov data
				pid = (uint16_t)(size_t) nni_aio_get_prov_data(
				    aio);
				if (pid == 0) {
					// first time send this msg
					pid = nni_pipe_inc_packetid(pipe);
					// store msg for qos retrying
					nni_msg_clone(msg);
					if ((old = nni_qos_db_get(is_sqlite,
					         pipe->nano_qos_db, pipe->p_id,
					         pid)) != NULL) {
						// TODO packetid already
						// exists. we need to
						// replace old with new one
						// print warning to users
						nni_println("ERROR: packet id "
						            "duplicates in "
						            "nano_qos_db");
						nni_qos_db_remove_msg(
						    is_sqlite,
						    pipe->nano_qos_db, old);
					}
					old = msg;
					nni_qos_db_set(is_sqlite,
					    pipe->nano_qos_db, pipe->p_id, pid,
					    old);
					nni_qos_db_remove_oldest(is_sqlite,
					    pipe->nano_qos_db,
					    p->conf->sqlite.disk_cache_size);
				}
				NNI_PUT16(var_extra, pid);
				// copy packet id
				memcpy(p->qos_buf + qlength, var_extra, 2);
				qlength += 2;
				plength += 2;
			} else if (qos_pac > 0) {
				//ignore the packet id of original packet
				len_offset += 2;
			}
			// prop len + sub id if any
			if (sub_id != 0) {
				memcpy(p->qos_buf + qlength, proplen,
				    tprop_bytes);
				qlength += tprop_bytes;
				plength += tprop_bytes;
				memcpy(p->qos_buf + qlength, var_subid,
				    id_bytes + 1);
				qlength += id_bytes + 1;
				plength += id_bytes + 1;
				if (target_prover == MQTTV5)
					len_offset += prop_bytes;
			} else {
				//need to add 0 len for V4 msg
				if (target_prover == MQTTV4_V5) {
					// add proplen even 0
					memcpy(p->qos_buf + qlength, proplen,
					    tprop_bytes);
					qlength += tprop_bytes;
					plength += tprop_bytes;
				}
			}
			// 2nd part of variable header: pid + proplen+0x0B+subid
			iov[niov].iov_buf = p->qos_buf+qlength-plength;
			iov[niov].iov_len = plength;
			niov++;
			// prop + body
			iov[niov].iov_buf = body + 2 + tlen + len_offset;
			iov[niov].iov_len = mlen - 2 - len_offset - tlen;
			niov++;
			// apending directly
			for (int i = 0; i < niov; i++) {
				nni_msg_append(
				    smsg, iov[i].iov_buf, iov[i].iov_len);
			}
			niov = 0;
		}
	}

	// duplicated msg is gonna be freed by http. so we free old one
	// here
	nni_msg_free(msg);
	msg = smsg;

	// MQTT V5 flow control
	if (qos > 0) {
		if (p->qsend_quota > 0) {
			p->qsend_quota--;
		} else {
			// what should broker does when exceed
			// max_recv? msg lost, make it look like a
			// normal send. qos msg will be resend
			// afterwards
			nni_msg_free(msg);
			// nni_aio_set_prov_data(txaio, NULL);
			nni_aio_set_msg(aio, NULL);
			nni_aio_finish(aio, 0, 0);
			return;
		}
	}

// normal sending if it is not PUBLISH
send:
	nni_aio_set_msg(aio, msg);
	nni_aio_set_msg(p->txaio, msg);
	nni_aio_set_msg(aio, NULL);
	// verify connect
	if (nni_msg_cmd_type(msg) == CMD_CONNACK) {
		uint8_t *header = nni_msg_header(msg);
		if (*(header + 3) != 0x00) {
			nni_pipe_close(p->npipe);
		}
	}
	nng_stream_send(p->ws, p->txaio);
}
