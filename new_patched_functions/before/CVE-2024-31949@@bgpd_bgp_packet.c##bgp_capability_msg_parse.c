static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,
				    bgp_size_t length)
{
	uint8_t *end;
	struct capability_mp_data mpc;
	struct capability_header *hdr;
	uint8_t action;
	iana_afi_t pkt_afi;
	afi_t afi;
	iana_safi_t pkt_safi;
	safi_t safi;
	const char *capability;

	end = pnt + length;

	while (pnt < end) {
		/* We need at least action, capability code and capability
		 * length. */
		if (pnt + 3 > end) {
			zlog_err("%pBP: Capability length error", peer);
			bgp_notify_send(peer->connection, BGP_NOTIFY_CEASE,
					BGP_NOTIFY_SUBCODE_UNSPECIFIC);
			return BGP_Stop;
		}
		action = *pnt;
		hdr = (struct capability_header *)(pnt + 1);

		/* Action value check.  */
		if (action != CAPABILITY_ACTION_SET
		    && action != CAPABILITY_ACTION_UNSET) {
			zlog_err("%pBP: Capability Action Value error %d", peer,
				 action);
			bgp_notify_send(peer->connection, BGP_NOTIFY_CEASE,
					BGP_NOTIFY_SUBCODE_UNSPECIFIC);
			return BGP_Stop;
		}

		if (bgp_debug_neighbor_events(peer))
			zlog_debug("%pBP: CAPABILITY has action: %d, code: %u, length %u",
				   peer, action, hdr->code, hdr->length);

		/* Capability length check. */
		if ((pnt + hdr->length + 3) > end) {
			zlog_err("%pBP: Capability length error", peer);
			bgp_notify_send(peer->connection, BGP_NOTIFY_CEASE,
					BGP_NOTIFY_SUBCODE_UNSPECIFIC);
			return BGP_Stop;
		}

		/* Ignore capability when override-capability is set. */
		if (CHECK_FLAG(peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
			continue;

		capability = lookup_msg(capcode_str, hdr->code, "Unknown");

		switch (hdr->code) {
		case CAPABILITY_CODE_SOFT_VERSION:
			bgp_dynamic_capability_software_version(pnt, action,
								hdr, peer);
			break;
		case CAPABILITY_CODE_MP:
			if (hdr->length < sizeof(struct capability_mp_data)) {
				zlog_err("%pBP: Capability (%s) structure is not properly filled out, expected at least %zu bytes but header length specified is %d",
					 peer, capability,
					 sizeof(struct capability_mp_data),
					 hdr->length);
				return BGP_Stop;
			}

			memcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data));
			pkt_afi = ntohs(mpc.afi);
			pkt_safi = mpc.safi;

			/* Convert AFI, SAFI to internal values. */
			if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,
						      &safi)) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%pBP: Dynamic Capability %s afi/safi invalid (%s/%s)",
						   peer, capability,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
				continue;
			}

			/* Address family check.  */
			if (bgp_debug_neighbor_events(peer))
				zlog_debug("%pBP: CAPABILITY has %s %s CAP for afi/safi: %s/%s",
					   peer,
					   action == CAPABILITY_ACTION_SET
						   ? "Advertising"
						   : "Removing",
					   capability, iana_afi2str(pkt_afi),
					   iana_safi2str(pkt_safi));

			if (action == CAPABILITY_ACTION_SET) {
				peer->afc_recv[afi][safi] = 1;
				if (peer->afc[afi][safi]) {
					peer->afc_nego[afi][safi] = 1;
					bgp_announce_route(peer, afi, safi,
							   false);
				}
			} else {
				peer->afc_recv[afi][safi] = 0;
				peer->afc_nego[afi][safi] = 0;

				if (peer_active_nego(peer))
					bgp_clear_route(peer, afi, safi);
				else
					return BGP_Stop;
			}
			break;
		case CAPABILITY_CODE_RESTART:
			if ((hdr->length - 2) % 4) {
				zlog_err("%pBP: Received invalid Graceful-Restart capability length %d",
					 peer, hdr->length);
				bgp_notify_send(peer->connection,
						BGP_NOTIFY_CEASE,
						BGP_NOTIFY_SUBCODE_UNSPECIFIC);
				return BGP_Stop;
			}

			bgp_dynamic_capability_graceful_restart(pnt, action,
								hdr, peer);
			break;
		case CAPABILITY_CODE_LLGR:
			bgp_dynamic_capability_llgr(pnt, action, hdr, peer);
			break;
		case CAPABILITY_CODE_ADDPATH:
			bgp_dynamic_capability_addpath(pnt, action, hdr, peer);
			break;
		case CAPABILITY_CODE_PATHS_LIMIT:
			bgp_dynamic_capability_paths_limit(pnt, action, hdr,
							   peer);
			break;
		case CAPABILITY_CODE_ORF:
			bgp_dynamic_capability_orf(pnt, action, hdr, peer);
			break;
		case CAPABILITY_CODE_FQDN:
			bgp_dynamic_capability_fqdn(pnt, action, hdr, peer);
			break;
		case CAPABILITY_CODE_REFRESH:
		case CAPABILITY_CODE_AS4:
		case CAPABILITY_CODE_DYNAMIC:
		case CAPABILITY_CODE_ENHANCED_RR:
		case CAPABILITY_CODE_ENHE:
		case CAPABILITY_CODE_EXT_MESSAGE:
			break;
		case CAPABILITY_CODE_ROLE:
			if (hdr->length != CAPABILITY_CODE_ROLE_LEN) {
				zlog_err("%pBP: Capability (%s) length error",
					 peer, capability);
				bgp_notify_send(peer->connection,
						BGP_NOTIFY_CEASE,
						BGP_NOTIFY_SUBCODE_UNSPECIFIC);
				return BGP_Stop;
			}

			uint8_t role;

			if (action == CAPABILITY_ACTION_SET) {
				SET_FLAG(peer->cap, PEER_CAP_ROLE_RCV);
				memcpy(&role, pnt + 3, sizeof(role));

				peer->remote_role = role;
			} else {
				UNSET_FLAG(peer->cap, PEER_CAP_ROLE_RCV);
				peer->remote_role = ROLE_UNDEFINED;
			}
			break;
		default:
			flog_warn(EC_BGP_UNRECOGNIZED_CAPABILITY,
				  "%pBP: unrecognized capability code: %d - ignored",
				  peer, hdr->code);
			break;
		}

		pnt += hdr->length + 3;
	}

	/* No FSM action necessary */
	return BGP_PACKET_NOOP;
}
