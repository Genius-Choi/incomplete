bool Filter::convertRequestHeadersForInternalRedirect(
    Http::RequestHeaderMap& downstream_headers, const Http::ResponseHeaderMap& upstream_headers,
    const Http::HeaderEntry& internal_redirect, uint64_t status_code) {
  if (!downstream_headers.Path()) {
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: no path in downstream_headers", *callbacks_);
    return false;
  }

  absl::string_view redirect_url = internal_redirect.value().getStringView();
  // Make sure the redirect response contains a URL to redirect to.
  if (redirect_url.empty()) {
    stats_.passthrough_internal_redirect_bad_location_.inc();
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: empty location", *callbacks_);
    return false;
  }
  Http::Utility::Url absolute_url;
  if (!absolute_url.initialize(redirect_url, false)) {
    stats_.passthrough_internal_redirect_bad_location_.inc();
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: invalid location {}", *callbacks_,
                     redirect_url);
    return false;
  }

  const auto& policy = route_entry_->internalRedirectPolicy();
  // Don't change the scheme from the original request
  const bool scheme_is_http = schemeIsHttp(downstream_headers, callbacks_->connection());
  const bool target_is_http = Http::Utility::schemeIsHttp(absolute_url.scheme());
  if (!policy.isCrossSchemeRedirectAllowed() && scheme_is_http != target_is_http) {
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: incorrect scheme for {}", *callbacks_,
                     redirect_url);
    stats_.passthrough_internal_redirect_unsafe_scheme_.inc();
    return false;
  }

  const StreamInfo::FilterStateSharedPtr& filter_state = callbacks_->streamInfo().filterState();
  // Make sure that performing the redirect won't result in exceeding the configured number of
  // redirects allowed for this route.
  StreamInfo::UInt32Accessor* num_internal_redirect{};

  if (num_internal_redirect = filter_state->getDataMutable<StreamInfo::UInt32Accessor>(
          NumInternalRedirectsFilterStateName);
      num_internal_redirect == nullptr) {
    auto state = std::make_shared<StreamInfo::UInt32AccessorImpl>(0);
    num_internal_redirect = state.get();

    filter_state->setData(NumInternalRedirectsFilterStateName, std::move(state),
                          StreamInfo::FilterState::StateType::Mutable,
                          StreamInfo::FilterState::LifeSpan::Request);
  }

  if (num_internal_redirect->value() >= policy.maxInternalRedirects()) {
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: redirect limits exceeded.", *callbacks_);
    stats_.passthrough_internal_redirect_too_many_redirects_.inc();
    return false;
  }
  // Copy the old values, so they can be restored if the redirect fails.
  const bool scheme_is_set = (downstream_headers.Scheme() != nullptr);

  std::unique_ptr<Http::RequestHeaderMapImpl> saved_headers = Http::RequestHeaderMapImpl::create();
  Http::RequestHeaderMapImpl::copyFrom(*saved_headers, downstream_headers);

  for (const Http::LowerCaseString& header :
       route_entry_->internalRedirectPolicy().responseHeadersToCopy()) {
    Http::HeaderMap::GetResult result = upstream_headers.get(header);
    Http::HeaderMap::GetResult downstream_result = downstream_headers.get(header);
    if (result.empty()) {
      // Clear headers if present, else do nothing:
      if (downstream_result.empty()) {
        continue;
      }
      downstream_headers.remove(header);
    } else {
      // The header exists in the response, copy into the downstream headers
      if (!downstream_result.empty()) {
        downstream_headers.remove(header);
      }
      for (size_t idx = 0; idx < result.size(); idx++) {
        downstream_headers.addCopy(header, result[idx]->value().getStringView());
      }
    }
  }

  Cleanup restore_original_headers(
      [&downstream_headers, scheme_is_set, scheme_is_http, &saved_headers]() {
        downstream_headers.clear();
        if (scheme_is_set) {
          downstream_headers.setScheme(scheme_is_http ? Http::Headers::get().SchemeValues.Http
                                                      : Http::Headers::get().SchemeValues.Https);
        }

        Http::RequestHeaderMapImpl::copyFrom(downstream_headers, *saved_headers);
      });

  // Replace the original host, scheme and path.
  downstream_headers.setScheme(absolute_url.scheme());
  downstream_headers.setHost(absolute_url.hostAndPort());

  auto path_and_query = absolute_url.pathAndQueryParams();
  if (Runtime::runtimeFeatureEnabled("envoy.reloadable_features.http_reject_path_with_fragment")) {
    // Envoy treats internal redirect as a new request and will reject it if URI path
    // contains #fragment. However the Location header is allowed to have #fragment in URI path. To
    // prevent Envoy from rejecting internal redirect, strip the #fragment from Location URI if it
    // is present.
    auto fragment_pos = path_and_query.find('#');
    path_and_query = path_and_query.substr(0, fragment_pos);
  }
  downstream_headers.setPath(path_and_query);

  // Only clear the route cache if there are downstream callbacks. There aren't, for example,
  // for async connections.
  if (callbacks_->downstreamCallbacks()) {
    callbacks_->downstreamCallbacks()->clearRouteCache();
  }
  const auto route = callbacks_->route();
  // Don't allow a redirect to a non existing route.
  if (!route) {
    stats_.passthrough_internal_redirect_no_route_.inc();
    ENVOY_STREAM_LOG(trace, "Internal redirect failed: no route found", *callbacks_);
    return false;
  }

  const auto& route_name = route->routeName();
  for (const auto& predicate : policy.predicates()) {
    if (!predicate->acceptTargetRoute(*filter_state, route_name, !scheme_is_http,
                                      !target_is_http)) {
      stats_.passthrough_internal_redirect_predicate_.inc();
      ENVOY_STREAM_LOG(trace,
                       "Internal redirect failed: rejecting redirect targeting {}, by {} predicate",
                       *callbacks_, route_name, predicate->name());
      return false;
    }
  }

  // See https://tools.ietf.org/html/rfc7231#section-6.4.4.
  if (status_code == enumToInt(Http::Code::SeeOther) &&
      downstream_headers.getMethodValue() != Http::Headers::get().MethodValues.Get &&
      downstream_headers.getMethodValue() != Http::Headers::get().MethodValues.Head) {
    downstream_headers.setMethod(Http::Headers::get().MethodValues.Get);
    downstream_headers.remove(Http::Headers::get().ContentLength);
    callbacks_->modifyDecodingBuffer([](Buffer::Instance& data) { data.drain(data.length()); });
  }

  num_internal_redirect->increment();
  restore_original_headers.cancel();
  // Preserve the original request URL for the second pass.
  downstream_headers.setEnvoyOriginalUrl(
      absl::StrCat(scheme_is_http ? Http::Headers::get().SchemeValues.Http
                                  : Http::Headers::get().SchemeValues.Https,
                   "://", saved_headers->getHostValue(), saved_headers->getPathValue()));
  return true;
}
