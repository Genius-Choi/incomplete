static char *_consume_authority(uri_parser_result_t *result, char *uri,
                                char *uri_end)
{
    assert(uri);

    /* search until first '/' */
    char *authority_end = _strchrb(uri, uri_end, '/');
    if (!authority_end) {
        authority_end = uri_end;
    }
    result->host = uri;
    result->host_len = authority_end - uri;

    /* consume userinfo, if available */
    _consume_userinfo(result, uri, authority_end);

    char *ipv6_end = NULL;
    /* validate IPv6 form */
    if (result->host[0] == '[') {
        ipv6_end = _strchrb(result->host, uri_end, ']');
        /* found end marker of IPv6 form beyond authority part */
        if (ipv6_end >= authority_end) {
            return NULL;
        }

        char *zoneid_start = _strchrb(result->host, ipv6_end, '%');
        if (zoneid_start) {
            /* skip % */
            result->zoneid = zoneid_start + 1;
            result->zoneid_len = ipv6_end - result->zoneid;

            /* zoneid cannot be empty */
            if (result->zoneid_len == 0) {
                return NULL;
            }
        }

        /* remove '[', ']', and '%' zoneid from ipv6addr */
        result->ipv6addr = result->host + 1;
        result->ipv6addr_len = ipv6_end - result->ipv6addr;
        if (result->zoneid) {
            result->ipv6addr_len -= result->zoneid_len + 1;
        }
    }

    /* consume port, if available */
    if (!_consume_port(result, ipv6_end, authority_end)) {
        return NULL;
    }

    /* do not allow empty host if userinfo or port are set */
    if ((result->host_len == 0) &&
        (result->userinfo || result->port)) {
        return NULL;
    }

    /* this includes the '/' */
    return authority_end;
}
