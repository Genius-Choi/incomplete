void deletefiles(file_t *files, int prompt, FILE *tty, char *logfile)
{
  int counter;
  int groups = 0;
  int curgroup = 0;
  file_t *tmpfile;
  file_t *curfile;
  file_t **dupelist;
  int *preserve;
  int firstpreserved;
  char *preservestr;
  char *token;
  char *tstr;
  int number;
  int sum;
  int max = 0;
  int x;
  int i;
  struct log_info *loginfo;
  int log_error;
  FILE *file1;
  FILE *file2;
  int ismatch;

  curfile = files;
  
  while (curfile) {
    if (curfile->hasdupes) {
      counter = 1;
      groups++;

      tmpfile = curfile->duplicates;
      while (tmpfile) {
	counter++;
	tmpfile = tmpfile->duplicates;
      }
      
      if (counter > max) max = counter;
    }
    
    curfile = curfile->next;
  }

  max++;

  dupelist = (file_t**) malloc(sizeof(file_t*) * max);
  preserve = (int*) malloc(sizeof(int) * max);
  preservestr = (char*) malloc(INPUT_SIZE);

  if (!dupelist || !preserve || !preservestr) {
    errormsg("out of memory\n");
    exit(1);
  }

  loginfo = 0;
  if (logfile != 0)
    loginfo = log_open(logfile, &log_error);

  register_sigint_handler();

  while (files) {
    if (files->hasdupes) {
      curgroup++;
      counter = 1;
      dupelist[counter] = files;

      if (prompt) 
      {
        if (ISFLAG(flags, F_SHOWTIME))
          printf("[%d] [%s] %s\n", counter, fmttime(files->mtime), files->d_name);
        else
          printf("[%d] %s\n", counter, files->d_name);
      }

      tmpfile = files->duplicates;

      while (tmpfile) {
	dupelist[++counter] = tmpfile;
        if (prompt)
        {
          if (ISFLAG(flags, F_SHOWTIME))
            printf("[%d] [%s] %s\n", counter, fmttime(tmpfile->mtime), tmpfile->d_name);
          else
            printf("[%d] %s\n", counter, tmpfile->d_name);
        }
	tmpfile = tmpfile->duplicates;
      }

      if (prompt) printf("\n");

      if (!prompt) /* preserve only the first file */
      {
         preserve[1] = 1;
	 for (x = 2; x <= counter; x++) preserve[x] = 0;
      }

      else /* prompt for files to preserve */

      do {
	printf("Set %d of %d, preserve files [1 - %d, all, quit]",
          curgroup, groups, counter);
	if (ISFLAG(flags, F_SHOWSIZE)) printf(" (%lld byte%seach)", (long long int)files->size,
	  (files->size != 1) ? "s " : " ");
	printf(": ");
	fflush(stdout);

	if (!fgets(preservestr, INPUT_SIZE, tty))
	{
	  preservestr[0] = '\n'; /* treat fgets() failure as if nothing was entered */
	  preservestr[1] = '\0';

	  if (got_sigint)
	  {
	    if (loginfo)
	      log_close(loginfo);

	    free(dupelist);
	    free(preserve);
	    free(preservestr);

	    printf("\n");

	    exit(0);
	  }
	}

	i = strlen(preservestr) - 1;

	while (preservestr[i]!='\n'){ /* tail of buffer must be a newline */
	  tstr = (char*)
	    realloc(preservestr, strlen(preservestr) + 1 + INPUT_SIZE);
	  if (!tstr) { /* couldn't allocate memory, treat as fatal */
	    errormsg("out of memory!\n");
	    exit(1);
	  }

	  preservestr = tstr;
	  if (!fgets(preservestr + i + 1, INPUT_SIZE, tty))
	  {
	    preservestr[0] = '\n'; /* treat fgets() failure as if nothing was entered */
	    preservestr[1] = '\0';
	    break;
	  }
	  i = strlen(preservestr)-1;
	}

	if (strcmp(preservestr, "q\n") == 0 || strcmp(preservestr, "quit\n") == 0)
	{
	  if (loginfo)
	    log_close(loginfo);

	  free(dupelist);
	  free(preserve);
	  free(preservestr);

	  printf("\n");

	  exit(0);
	}

	for (x = 1; x <= counter; x++) preserve[x] = 0;
	
	token = strtok(preservestr, " ,\n");
	
	while (token != NULL) {
	  if (strcasecmp(token, "all") == 0 || strcasecmp(token, "a") == 0)
	    for (x = 0; x <= counter; x++) preserve[x] = 1;
	  
	  number = 0;
	  sscanf(token, "%d", &number);
	  if (number > 0 && number <= counter) preserve[number] = 1;
	  
	  token = strtok(NULL, " ,\n");
	}
      
	for (sum = 0, x = 1; x <= counter; x++) sum += preserve[x];
      } while (sum < 1); /* make sure we've preserved at least one file */

      printf("\n");

      if (loginfo)
        log_begin_set(loginfo);

      for (x = 1; x <= counter; x++) { 
	if (preserve[x])
        {
	  printf("   [+] %s\n", dupelist[x]->d_name);

          if (loginfo)
            log_file_remaining(loginfo, dupelist[x]->d_name);
        }
	else {
    if (ISFLAG(flags, F_DEFERCONFIRMATION))
    {
      firstpreserved = 0;
      for (i = 1; i <= counter; ++i)
      {
        if (preserve[i])
        {
          firstpreserved = i;
          break;
        }
      }

      file1 = fopen(dupelist[x]->d_name, "rb");
      file2 = fopen(dupelist[firstpreserved]->d_name, "rb");

      if (file1 && file2)
        ismatch = confirmmatch(file1, file2);
      else
        ismatch = 0;

      if (file2)
        fclose(file2);

      if (file1)
        fclose(file1);
    }
    else
    {
      ismatch = 1;
    }

    if (ismatch) {
      if (remove(dupelist[x]->d_name) == 0) {
        printf("   [-] %s\n", dupelist[x]->d_name);

        if (loginfo)
          log_file_deleted(loginfo, dupelist[x]->d_name);
      }
      else {
        printf("   [!] %s ", dupelist[x]->d_name);
        printf("-- unable to delete file!\n");

        if (loginfo)
          log_file_remaining(loginfo, dupelist[x]->d_name);
      }
    }
    else {
      printf("   [!] %s\n", dupelist[x]->d_name);
      printf(" -- unable to confirm match; file not deleted!\n");

      if (loginfo)
        log_file_remaining(loginfo, dupelist[x]->d_name);
    }
	}
      }
      printf("\n");

      if (loginfo)
        log_end_set(loginfo);
    }
    
    files = files->next;
  }

  if (loginfo)
    log_close(loginfo);

  free(dupelist);
  free(preserve);
  free(preservestr);
}
