void handle_follow_up(char *buf, ssize_t recv_len, clock_source_private_data *clock_private_info,
                      uint64_t reception_time) {
  if (clock_private_info->clock_id == 0) {
    debug(2, "Follow_Up received before announcement -- discarded.");
  } else {
    clock_private_info->announcements_without_followups = 0;
    if ((recv_len >= 0) && ((size_t)recv_len >= sizeof(struct ptp_follow_up_message))) {
      // debug_print_buffer(1, buf, recv_len);
      struct ptp_follow_up_message *msg = (struct ptp_follow_up_message *)buf;
      uint16_t seconds_hi = nctohs(&msg->follow_up.preciseOriginTimestamp[0]);
      uint32_t seconds_low = nctohl(&msg->follow_up.preciseOriginTimestamp[2]);
      uint32_t nanoseconds = nctohl(&msg->follow_up.preciseOriginTimestamp[6]);
      uint64_t preciseOriginTimestamp = seconds_hi;
      preciseOriginTimestamp = preciseOriginTimestamp << 32;
      preciseOriginTimestamp = preciseOriginTimestamp + seconds_low;
      preciseOriginTimestamp = preciseOriginTimestamp * 1000000000L;
      preciseOriginTimestamp = preciseOriginTimestamp + nanoseconds;

      // update our sample information
      int grandmasterClockIsStopped = 0;
      if ((clock_private_info->previous_preciseOriginTimestamp == preciseOriginTimestamp) &&
          (clock_private_info->clock_id == clock_private_info->grandmasterIdentity)) {
        clock_private_info->identical_previous_preciseOriginTimestamp_count++;
        grandmasterClockIsStopped = 1;
        if (clock_private_info->identical_previous_preciseOriginTimestamp_count == 8 * 60) {
          int64_t duration_of_mastership =
              reception_time - clock_private_info->mastership_start_time;
          if (clock_private_info->mastership_start_time == 0)
            duration_of_mastership = 0;
          debug(2,
                "Clock %" PRIx64 "'s grandmaster clock has stopped after %f seconds of mastership.",
                clock_private_info->clock_id, 0.000000001 * duration_of_mastership);
          int64_t wait_limit = 62;
          wait_limit = wait_limit * 1000000000;
          // only try to restart a grandmaster clock on the clock itself.
          if ((duration_of_mastership <= wait_limit) &&
              (clock_private_info->clock_id == clock_private_info->grandmasterIdentity)) {
            debug(2,
                  "Attempt to start a stopped clock %" PRIx64 ", at follow_up_number %u at IP %s.",
                  clock_private_info->clock_id, clock_private_info->follow_up_number,
                  clock_private_info->ip);
            send_awakening_announcement_sequence(
                clock_private_info->clock_id, clock_private_info->ip, clock_private_info->family,
                clock_private_info->grandmasterPriority1, clock_private_info->grandmasterPriority2);
          }
        }
      } else {
        clock_private_info->identical_previous_preciseOriginTimestamp_count = 0;
      }

      clock_private_info->previous_preciseOriginTimestamp = preciseOriginTimestamp;

      // clang-format off
      
      // actually the precision timestamp needs to be corrected by the Follow_Up Correction_Field contents.
      // According to IEEE Std 802.1AS-2020, paragraph 11.4.4.2.1:
      /*
      The value of the preciseOriginTimestamp field is the sourceTime of the ClockMaster entity of the Grandmaster PTP Instance,
      when the associated Sync message was sent by that Grandmaster PTP Instance, with any fractional nanoseconds truncated (see 10.2.9).
      The sum of the correctionFields in the Follow_Up and associated Sync messages, added to the preciseOriginTimestamp field of the Follow_Up message,
      is the value of the synchronized time corresponding to the syncEventEgressTimestamp at the PTP Instance that sent the associated Sync message,
      including any fractional nanoseconds.
      */

      // clang-format on

      int64_t correction_field = ntoh64(msg->header.correctionField);

      // debug(1," Check ntoh64: in: %" PRIx64 ", out: %" PRIx64 ".", msg->header.correctionField,
      // correction_field);

      correction_field = correction_field / 65536; // might be signed
      uint64_t correctedPreciseOriginTimestamp = preciseOriginTimestamp + correction_field;

      if (clock_private_info->follow_up_number < 100)
        clock_private_info->follow_up_number++;

      // if (clock_private_info->announcements_without_followups < 4) // if we haven't signalled
      // already
      clock_private_info->announcements_without_followups = 0; // we've seen a followup

      debug(2, "FOLLOWUP from %" PRIx64 ", %s.", clock_private_info->clock_id,
            &clock_private_info->ip);
      uint64_t offset = correctedPreciseOriginTimestamp - reception_time;

      int64_t jitter = 0;

      int64_t time_since_previous_offset = 0;
      uint64_t smoothed_offset = offset;

      // This is a bit hacky.
      // Basically, the idea is that if the grandmaster has changed, then acceptance checking and
      // smoothing should start as it it's a new clock. This is because the
      // correctedPreciseOriginTimestamp, which is part of the data that is being smoothed, refers
      // to the grandmaster, so when the grandmaster changes any previous calculations are no
      // longer valid. The hacky bit is to signal this condition by zeroing the
      // previous_offset_time.
      if (clock_private_info->previous_offset_grandmaster !=
          clock_private_info->grandmasterIdentity) {
        clock_private_info->previous_offset_time = 0;
        if (clock_private_info->previous_offset_grandmaster == 0)
          debug(1, "grandmaster is %" PRIx64 ".", clock_private_info->grandmasterIdentity);
        else
          debug(1, "grandmaster has changed from %" PRIx64 " to %" PRIx64 ".",
                clock_private_info->previous_offset_grandmaster,
                clock_private_info->grandmasterIdentity);
      }

      // Do acceptance checking and smoothing.

      // Positive changes in the offset are much more likely to be
      // legitimate, since they could only occur due to a shorter
      // propagation time or less of a delay sending or receiving the packet.
      // When the clock is new, we give preferential weighting to
      // positive changes in the offset to allow the clock to sync up quickly.

      // If the new offset is greater, by any amount, than the old offset,
      // or if it is less by up to the clamping_limit, accept it.

      // This seems to be quite stable

      if (reset_clock_smoothing == 0) {

        if (clock_private_info->previous_offset_time != 0) {
          time_since_previous_offset = reception_time - clock_private_info->previous_offset_time;
          jitter = offset - clock_private_info->previous_offset;
        }

        // We take any positive or a limited negative jitter as a sync event in
        // a continuous synchronisation sequence.

        // The full value of a positive offset jitter is accepted for a
        // number of follow_ups at the start.
        // After that, the weight of the jitter is reduced.
        // Follow-ups don't always come in at 125 ms intervals, especially after a discontinuity
        // Delays makes the offsets smaller than they should be, which is quickly
        // allowed for.

        const int64_t clamping_limit = -2500000; // nanoseconds

        int64_t mastership_time = reception_time - clock_private_info->mastership_start_time;
        if (clock_private_info->mastership_start_time == 0)
          mastership_time = 0;

        //          if ((clock_private_info->previous_offset_time != 0) &&
        //          (clock_private_info->identical_previous_preciseOriginTimestamp_count <= 1)) {
        if (clock_private_info->previous_offset_time != 0) {
          if (jitter < 0) {
            int64_t clamped_jitter = jitter;
            if (clamped_jitter < clamping_limit) {
              clamped_jitter = clamping_limit; // 0 means ignore a clamped value completely
            }
            // if (mastership_time < 1000000000) // at the beginning, if jitter is negative
            //   smoothed_offset = clock_private_info->previous_offset + clamped_jitter / 16;
            // else

            // ignore negative jitter at first...
            smoothed_offset = clock_private_info->previous_offset;
            if (mastership_time > 1000000000)
              smoothed_offset += clamped_jitter / 256; // later, if jitter is negative
          } else if (mastership_time < 1000000000) { // at the beginning
            smoothed_offset =
                clock_private_info->previous_offset +
                jitter /
                    1; // at the beginning, if jitter is positive -- accept positive changes quickly
          } else {
            smoothed_offset =
                clock_private_info->previous_offset + jitter / 16; // later, if jitter is positive
          }
        } else {
          if (clock_private_info->previous_offset_time == 0)
            debug(2, "Clock %" PRIx64 " record (re)starting at %s.", clock_private_info->clock_id,
                  clock_private_info->ip);
          else
            debug(2,
                  "Timing discontinuity on clock %" PRIx64
                  " at %s: time_since_previous_offset: %.3f seconds%s.",
                  clock_private_info->clock_id, clock_private_info->ip,
                  0.000000001 * time_since_previous_offset,
                  grandmasterClockIsStopped != 0 ? ", grandmaster clock stopped" : "");
          smoothed_offset = offset;
          // clock_private_info->follow_up_number = 0;
          clock_private_info->mastership_start_time =
              reception_time; // mastership is reset to this time...
        }

        int64_t delta = smoothed_offset - offset;
        debug(2,
              "Clock %" PRIx64 ", grandmaster %" PRIx64 ". Offset: %" PRIx64
              ", smoothed offset: %" PRIx64
              ". Smoothed Offset - Offset: %10.3f. Raw Precise Origin Timestamp: %" PRIx64
              "%s correction_field: %" PRIx64
              ". Time since previous offset: %8.3f milliseconds. ID: %5u, Follow_Up Number: "
              "%u. Source: %s",
              clock_private_info->clock_id, clock_private_info->grandmasterIdentity, offset,
              smoothed_offset, 0.000001 * delta, preciseOriginTimestamp,
              clock_is_active != 0 ? ". " : "*.", correction_field,
              0.000001 * time_since_previous_offset, ntohs(msg->header.sequenceId),
              clock_private_info->follow_up_number, clock_private_info->ip);
        if (clock_is_active) {
          update_master_clock_info(clock_private_info->grandmasterIdentity,
                                   (const char *)&clock_private_info->ip, reception_time,
                                   smoothed_offset, clock_private_info->mastership_start_time);
        } else {
          update_master_clock_info(0, NULL, 0, 0, 0); // the SMI may have obsolete stuff in it
        }

        clock_private_info->previous_offset = smoothed_offset;
        clock_private_info->previous_offset_time = reception_time;

      } else {
        reset_clock_smoothing = 0;
        clock_private_info->mastership_start_time = 0;
        clock_private_info->previous_offset = 0;
        clock_private_info->previous_offset_time =
            0; // so that the first non-stopped sample will be taken as the first one in a sequence
      }

      clock_private_info->previous_offset_grandmaster = clock_private_info->grandmasterIdentity;

      // now do some quick calculations on the possible "Universal Time"
      // debug_print_buffer(1, "", buf, recv_len);
      uint8_t *tlv = (uint8_t *)&msg->follow_up.tlvs[0];
      uint8_t *lastGmPhaseChange = tlv + 16;
      uint64_t lpt = nctoh64(lastGmPhaseChange + 4);
      uint64_t last_tlv_clock = nctoh64((uint8_t *)buf + 86);
      uint64_t huh = offset - lpt;
      debug_print_buffer(2, buf, (size_t)recv_len);
      debug(2,
            "%" PRIx64 ", %" PRIx64 ", %s, Origin: %016" PRIx64 ", LPT: %016" PRIx64
            ", Offset: %016" PRIx64 ", Universal Offset: %016" PRIx64 ", packet length: %u.",
            clock_private_info->clock_id, last_tlv_clock, hex_string(lastGmPhaseChange, 12),
            preciseOriginTimestamp, lpt, offset, huh, recv_len);
      // debug(1,"Clock: %" PRIx64 ", UT: %016" PRIx64 ", correctedPOT: %016" PRIx64 ", part of
      // lastGMPhaseChange: %016" PRIx64 ".", packet_clock_id, correctedPOT - lpt, correctedPOT,
      // lpt);

    } else {
      debug(1, "Follow_Up message is too small to be valid.");
    }
  }
}
