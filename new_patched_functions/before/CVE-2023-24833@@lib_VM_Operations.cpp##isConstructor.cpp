CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {
  // This is not a complete definition, since ES6 and later define member
  // functions of objects to not be constructors; however, Hermes does not have
  // ES6 classes implemented yet, so we cannot check for that case.
  if (!callable) {
    return false;
  }

  // We traverse the BoundFunction target chain to find the eventual target.
  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {
    callable = b->getTarget(runtime);
  }

  // If it is a bytecode function, check the flags.
  if (auto *func = dyn_vmcast<JSFunction>(callable)) {
    auto *cb = func->getCodeBlock(runtime);
    // Even though it doesn't make sense logically, we need to compile the
    // function in order to access it flags.
    if (LLVM_UNLIKELY(cb->lazyCompile(runtime) == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(
        true);
  }

  // We check for NativeFunction since those are defined to not be
  // constructible, with the exception of NativeConstructor.
  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {
    return true;
  }

  // JSCallableProxy is a NativeFunction, but may or may not be a
  // constructor, so we ask it.
  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {
    return cproxy->isConstructor(runtime);
  }

  return false;
}
