static int filter_frame(AVFilterLink *inlink, AVFrame *in)
{
    AVFilterContext *ctx = inlink->dst;
    AudioFWTDNContext *s = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    ThreadData td;
    AVFrame *out;
    int eof = in == NULL;

    out = ff_get_audio_buffer(outlink, s->nb_samples);
    if (!out) {
        av_frame_free(&in);
        return AVERROR(ENOMEM);
    }
    if (in) {
        av_frame_copy_props(out, in);
        s->eof_pts = in->pts + in->nb_samples;
    }
    if (eof)
        out->pts = s->eof_pts - s->padd_samples;

    if (!in || in->nb_samples < s->nb_samples) {
        AVFrame *new_in = ff_get_audio_buffer(outlink, s->nb_samples);

        if (!new_in) {
            av_frame_free(&in);
            av_frame_free(&out);
            return AVERROR(ENOMEM);
        }
        if (in)
            av_frame_copy_props(new_in, in);

        s->padd_samples -= s->nb_samples - (in ? in->nb_samples: 0);
        if (in)
            av_samples_copy(new_in->extended_data, in->extended_data, 0, 0,
                            in->nb_samples, in->ch_layout.nb_channels, in->format);
        av_frame_free(&in);
        in = new_in;
    }

    td.in  = in;
    td.out = out;
    ff_filter_execute(ctx, s->filter_channel, &td, NULL, inlink->ch_layout.nb_channels);
    if (s->need_profile)
        s->got_profile = 1;

    s->sn += s->nb_samples;

    if (s->drop_samples >= in->nb_samples) {
        s->drop_samples -= in->nb_samples;
        s->delay += in->nb_samples;
        av_frame_free(&in);
        av_frame_free(&out);
        FF_FILTER_FORWARD_STATUS(inlink, outlink);
        FF_FILTER_FORWARD_WANTED(outlink, inlink);
        return 0;
    } else if (s->drop_samples > 0) {
        for (int ch = 0; ch < out->ch_layout.nb_channels; ch++) {
            memmove(out->extended_data[ch],
                    out->extended_data[ch] + s->drop_samples * sizeof(double),
                    (in->nb_samples - s->drop_samples) * sizeof(double));
        }

        out->nb_samples = in->nb_samples - s->drop_samples;
        out->pts = in->pts - av_rescale_q(s->delay, (AVRational){1, outlink->sample_rate}, outlink->time_base);
        s->delay += s->drop_samples;
        s->drop_samples = 0;
    } else {
        if (s->padd_samples < 0 && eof) {
            out->nb_samples += s->padd_samples;
            s->padd_samples = 0;
        }
        if (!eof)
            out->pts = in->pts - av_rescale_q(s->delay, (AVRational){1, outlink->sample_rate}, outlink->time_base);
    }

    av_frame_free(&in);
    return ff_filter_frame(outlink, out);
}
