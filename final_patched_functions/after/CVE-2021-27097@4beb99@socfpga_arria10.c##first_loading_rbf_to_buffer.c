static int first_loading_rbf_to_buffer(struct udevice *dev,
				struct fpga_loadfs_info *fpga_loadfs,
				u32 *buffer, size_t *buffer_bsize)
{
	u32 *buffer_p = (u32 *)*buffer;
	u32 *loadable = buffer_p;
	size_t buffer_size = *buffer_bsize;
	size_t fit_size;
	int ret, i, count, confs_noffset, images_noffset, rbf_offset, rbf_size;
	const char *fpga_node_name = NULL;
	const char *uname = NULL;

	/* Load image header into buffer */
	ret = request_firmware_into_buf(dev,
					fpga_loadfs->fpga_fsinfo->filename,
					buffer_p, sizeof(struct image_header),
					0);
	if (ret < 0) {
		debug("FPGA: Failed to read image header from flash.\n");
		return -ENOENT;
	}

	if (image_get_magic((struct image_header *)buffer_p) != FDT_MAGIC) {
		debug("FPGA: No FDT magic was found.\n");
		return -EBADF;
	}

	fit_size = fdt_totalsize(buffer_p);

	if (fit_size > buffer_size) {
		debug("FPGA: FIT image is larger than available buffer.\n");
		debug("Please use FIT external data or increasing buffer.\n");
		return -ENOMEM;
	}

	/* Load entire FIT into buffer */
	ret = request_firmware_into_buf(dev,
					fpga_loadfs->fpga_fsinfo->filename,
					buffer_p, fit_size, 0);
	if (ret < 0)
		return ret;

	ret = fit_check_format(buffer_p, IMAGE_SIZE_INVAL);
	if (ret) {
		debug("FPGA: No valid FIT image was found.\n");
		return ret;
	}

	confs_noffset = fdt_path_offset(buffer_p, FIT_CONFS_PATH);
	images_noffset = fdt_path_offset(buffer_p, FIT_IMAGES_PATH);
	if (confs_noffset < 0 || images_noffset < 0) {
		debug("FPGA: No Configurations or images nodes were found.\n");
		return -ENOENT;
	}

	/* Get default configuration unit name from default property */
	confs_noffset = fit_conf_get_node(buffer_p, NULL);
	if (confs_noffset < 0) {
		debug("FPGA: No default configuration was found in config.\n");
		return -ENOENT;
	}

	count = fit_conf_get_prop_node_count(buffer_p, confs_noffset,
					    FIT_FPGA_PROP);
	if (count < 0) {
		debug("FPGA: Invalid configuration format for FPGA node.\n");
		return count;
	}
	debug("FPGA: FPGA node count: %d\n", count);

	for (i = 0; i < count; i++) {
		images_noffset = fit_conf_get_prop_node_index(buffer_p,
							     confs_noffset,
							     FIT_FPGA_PROP, i);
		uname = fit_get_name(buffer_p, images_noffset, NULL);
		if (uname) {
			debug("FPGA: %s\n", uname);

			if (strstr(uname, "fpga-periph") &&
				(!is_fpgamgr_early_user_mode() ||
				is_fpgamgr_user_mode())) {
				fpga_node_name = uname;
				printf("FPGA: Start to program ");
				printf("peripheral/full bitstream ...\n");
				break;
			} else if (strstr(uname, "fpga-core") &&
					(is_fpgamgr_early_user_mode() &&
					!is_fpgamgr_user_mode())) {
				fpga_node_name = uname;
				printf("FPGA: Start to program core ");
				printf("bitstream ...\n");
				break;
			}
		}
		WATCHDOG_RESET();
	}

	if (!fpga_node_name) {
		debug("FPGA: No suitable bitstream was found, count: %d.\n", i);
		return 1;
	}

	images_noffset = fit_image_get_node(buffer_p, fpga_node_name);
	if (images_noffset < 0) {
		debug("FPGA: No node '%s' was found in FIT.\n",
		     fpga_node_name);
		return -ENOENT;
	}

	if (!fit_image_get_data_position(buffer_p, images_noffset,
					&rbf_offset)) {
		debug("FPGA: Data position was found.\n");
	} else if (!fit_image_get_data_offset(buffer_p, images_noffset,
		  &rbf_offset)) {
		/*
		 * For FIT with external data, figure out where
		 * the external images start. This is the base
		 * for the data-offset properties in each image.
		 */
		rbf_offset += ((fdt_totalsize(buffer_p) + 3) & ~3);
		debug("FPGA: Data offset was found.\n");
	} else {
		debug("FPGA: No data position/offset was found.\n");
		return -ENOENT;
	}

	ret = fit_image_get_data_size(buffer_p, images_noffset, &rbf_size);
	if (ret < 0) {
		debug("FPGA: No data size was found (err=%d).\n", ret);
		return -ENOENT;
	}

	if (gd->ram_size < rbf_size) {
		debug("FPGA: Using default OCRAM buffer and size.\n");
	} else {
		ret = fit_image_get_load(buffer_p, images_noffset,
					(ulong *)loadable);
		if (ret < 0) {
			buffer_p = (u32 *)DEFAULT_DDR_LOAD_ADDRESS;
			debug("FPGA: No loadable was found.\n");
			debug("FPGA: Using default DDR load address: 0x%x .\n",
			     DEFAULT_DDR_LOAD_ADDRESS);
		} else {
			buffer_p = (u32 *)*loadable;
			debug("FPGA: Found loadable address = 0x%x.\n",
			     *loadable);
		}

		buffer_size = rbf_size;
	}

	debug("FPGA: External data: offset = 0x%x, size = 0x%x.\n",
	      rbf_offset, rbf_size);

	fpga_loadfs->remaining = rbf_size;

	/*
	 * Determine buffer size vs bitstream size, and calculating number of
	 * chunk by chunk transfer is required due to smaller buffer size
	 * compare to bitstream
	 */
	if (rbf_size <= buffer_size) {
		/* Loading whole bitstream into buffer */
		buffer_size = rbf_size;
		fpga_loadfs->remaining = 0;
	} else {
		fpga_loadfs->remaining -= buffer_size;
	}

	fpga_loadfs->offset = rbf_offset;
	/* Loading bitstream into buffer */
	ret = request_firmware_into_buf(dev,
					fpga_loadfs->fpga_fsinfo->filename,
					buffer_p, buffer_size,
					fpga_loadfs->offset);
	if (ret < 0) {
		debug("FPGA: Failed to read bitstream from flash.\n");
		return -ENOENT;
	}

	/* Getting info about bitstream types */
	get_rbf_image_info(&fpga_loadfs->rbfinfo, (u16 *)buffer_p);

	/* Update next reading bitstream offset */
	fpga_loadfs->offset += buffer_size;

	/* Update the final addr for bitstream */
	*buffer = (u32)buffer_p;

	/* Update the size of bitstream to be programmed into FPGA */
	*buffer_bsize = buffer_size;

	return 0;
}
