TEST(Security, MaliciousHeartbeatIgnore)
{
    PubSubWriter<HelloWorldPubSubType> writer("HelloWorldTopic_MaliciousHeartbeatIgnore");
    PubSubReader<HelloWorldPubSubType> reader("HelloWorldTopic_MaliciousHeartbeatIgnore");

    struct MaliciousHeartbeat
    {
        std::array<char, 4> rtps_id{{'R', 'T', 'P', 'S'}};
        std::array<uint8_t, 2> protocol_version{{2, 3}};
        std::array<uint8_t, 2> vendor_id{{0x01, 0x0F}};
        GuidPrefix_t sender_prefix;

        uint8_t submessage_id = 0x07;
#if FASTDDS_IS_BIG_ENDIAN_TARGET
        uint8_t flags = 0;
#else
        uint8_t flags = 0x01;
#endif  // FASTDDS_IS_BIG_ENDIAN_TARGET
        uint16_t submessage_length = 4 + 4 + 8 + 8 + 4;
        EntityId_t reader_id{};
        EntityId_t writer_id{};
        SequenceNumber_t first_sn{};
        SequenceNumber_t last_sn{};
        int32_t count = 0;
    };

    // Set custom transport on both participants
    auto transport = std::make_shared<test_UDPv4TransportDescriptor>();
    std::atomic<bool> avoid_sec_submessages{false};
    transport->sub_messages_filter_ = [&avoid_sec_submessages](CDRMessage_t& msg) -> bool
            {
                return avoid_sec_submessages.load() && (0x30 == (msg.buffer[msg.pos] & 0xF0));
            };

    UDPMessageSender fake_msg_sender;

    writer.disable_builtin_transport().add_user_transport_to_pparams(transport);
    reader.disable_builtin_transport().add_user_transport_to_pparams(transport);

    // Set custom reader locator so we can send malicious data to a known location
    Locator_t reader_locator;
    ASSERT_TRUE(IPLocator::setIPv4(reader_locator, "127.0.0.1"));
    reader_locator.port = 7000;
    reader.add_to_unicast_locator_list("127.0.0.1", 7000);

    // Set common QoS
    reader.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);
    writer.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);

    // Configure security
    const std::string governance_file("governance_helloworld_all_enable.smime");
    const std::string permissions_file("permissions_helloworld.smime");
    CommonPermissionsConfigure(reader, writer, governance_file, permissions_file);

    // Initialize and wait for discovery
    reader.init();
    ASSERT_TRUE(reader.isInitialized());
    writer.init();
    ASSERT_TRUE(writer.isInitialized());
    reader.wait_discovery();
    writer.wait_discovery();

    // Disable secure submessages and send data
    avoid_sec_submessages.store(true);
    auto data = default_helloworld_data_generator();
    reader.startReception(data);
    writer.send(data);
    ASSERT_TRUE(data.empty());

    // Send malicious heartbeat
    {
        auto writer_guid = writer.datawriter_guid();

        MaliciousHeartbeat hb{};
        hb.sender_prefix = writer_guid.guidPrefix;
        hb.writer_id = writer_guid.entityId;
        hb.reader_id = EntityId_t::unknown();
        hb.first_sn.low = 100;
        hb.last_sn.low = 100;
        hb.count = 100;

        CDRMessage_t msg(0);
        uint32_t msg_len = static_cast<uint32_t>(sizeof(hb));
        msg.init(reinterpret_cast<octet*>(&hb), msg_len);
        msg.length = msg_len;
        msg.pos = msg_len;
        fake_msg_sender.send(msg, reader_locator);
    }

    // Enable secure submessages
    avoid_sec_submessages.store(false);
    // Block reader until reception finished or timeout.
    reader.block_for_all();
}
