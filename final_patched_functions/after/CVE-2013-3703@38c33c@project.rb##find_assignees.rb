  def find_assignees(binary_name, limit=1, devel=true, filter=["maintainer","bugowner"], webui_mode=false)
    instances_without_definition=[]
    maintainers=[]
    pkg=nil
    projects=self.expand_all_projects

    match_all = (limit == 0)
    deepest = (limit < 0)

    # binary search via all projects
    prjlist = projects.map { |p| "@project='#{CGI.escape(p.name)}'" }
    path = "/search/published/binary/id?match=(@name='"+CGI.escape(binary_name)+"'"
    path += "+and+("
    path += prjlist.join("+or+")
    path += "))"
    answer = Suse::Backend.post path, nil
    data = Xmlhash.parse(answer.body)

    # found binary package?
    return [] if data["matches"].to_i == 0

    already_checked = {}
    deepest_match = nil
    projects.each do |prj| # project link order
      data.elements("binary").each do |b| # no order
        next unless b["project"] == prj.name

        pkg = prj.packages.find_by_name( b["package"] )
        next if pkg.nil?

        # the "" means any matching relationships will get taken
        m, limit, already_checked = lookup_package_owner(pkg, "", limit, devel, filter, deepest, already_checked)

        unless m
          # collect all no matched entries
          m = { :rootproject => self.name, :project => pkg.project.name, :package => pkg.name, :filter => filter }
          instances_without_definition << m
          next
        end

        # remember as deepest candidate
        if deepest == true
          deepest_match = m
          next
        end

        # add matching entry
        maintainers << m
        limit = limit - 1
        return maintainers if limit < 1 and not match_all
      end
    end

    return instances_without_definition if webui_mode and maintainers.length < 1

    maintainers << deepest_match if deepest_match

    return maintainers
  end
