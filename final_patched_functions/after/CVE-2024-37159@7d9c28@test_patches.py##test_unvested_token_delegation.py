def test_unvested_token_delegation(evmos_cluster):
    """
    test vesting account cannot delegate unvested tokens
    """
    cli = evmos_cluster.cosmos_cli()
    funder = eth_to_bech32(ADDRS["signer1"])
    # add a new key that will be the vesting account
    acc = cli.create_account("vesting_acc")
    address = acc["address"]

    # transfer some funds to pay for tx fees
    # when creating the vesting account
    tx = cli.transfer(
        funder,
        address,
        f"{7000000000000000}{DEFAULT_DENOM}",
        gas_prices=f"{cli.query_base_fee() + 100000}{DEFAULT_DENOM}",
        generate_only=True,
    )

    tx = cli.sign_tx_json(tx, funder, max_priority_price=0)

    rsp = cli.broadcast_tx_json(tx, broadcast_mode="sync")
    assert rsp["code"] == 0, rsp["raw_log"]

    wait_for_new_blocks(cli, 2)

    # create the vesting account
    tx = cli.create_vesting_acc(funder, address)
    tx = cli.sign_tx_json(tx, address, max_priority_price=0)
    rsp = cli.broadcast_tx_json(tx, broadcast_mode="sync")

    # assert tx returns OK code
    assert rsp["code"] == 0, rsp["raw_log"]

    # wait tx to be committed
    wait_for_new_blocks(cli, 2)

    # fund vesting account
    with tempfile.NamedTemporaryFile("w") as lockup_file:
        json.dump(
            {
                "start_time": 1625204910,
                "periods": [
                    {
                        "length_seconds": 1675184400,
                        "coins": "10000000000000000000aevmos",
                    }
                ],
            },
            lockup_file,
        )
        lockup_file.flush()

        with tempfile.NamedTemporaryFile("w") as vesting_file:
            json.dump(
                {
                    "start_time": 1625204910,
                    "periods": [
                        {
                            "length_seconds": 1675184400,
                            "coins": "3000000000000000000aevmos",
                        },
                        {
                            "length_seconds": 2419200,
                            "coins": "3000000000000000000aevmos",
                        },
                        {
                            "length_seconds": 2419200,
                            "coins": "4000000000000000000aevmos",
                        },
                    ],
                },
                vesting_file,
            )
            vesting_file.flush()

            tx = cli.fund_vesting_acc(
                address,
                funder,
                lockup_file.name,
                vesting_file.name,
            )
            tx = cli.sign_tx_json(tx, funder, max_priority_price=0)
            rsp = cli.broadcast_tx_json(tx, broadcast_mode="sync")
            # assert tx returns OK code
            assert rsp["code"] == 0, rsp["raw_log"]

            # wait tx to be committed
            wait_for_new_blocks(cli, 2)

    # check vesting balances
    # vested should be zero at this point
    balances = cli.vesting_balance(address)
    assert balances["vested"] == ""
    assert balances["locked"] == balances["unvested"]

    # try to delegate more than the allowed tokens
    del_amt = "7000000000000000000aevmos"
    validator_addr = cli.validators()[0]["operator_address"]
    tx = cli.delegate_amount(
        validator_addr,
        del_amt,
        address,
    )
    tx = cli.sign_tx_json(tx, address, max_priority_price=0)
    rsp = cli.broadcast_tx_json(tx, broadcast_mode="sync")
    # get tx receipt to check if tx failed as expected 
    receipt = wait_for_cosmos_tx_receipt(cli, rsp["txhash"])
    # assert tx fails with corresponding error message
    assert receipt["tx_result"]["code"] == 2
    assert "insufficient vested coins" in receipt["tx_result"]["log"]
