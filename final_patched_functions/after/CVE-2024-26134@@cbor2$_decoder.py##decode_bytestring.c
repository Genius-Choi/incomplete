decode_bytestring(CBORDecoderObject *self, uint8_t subtype)
{
    // major type 2
    uint64_t length = 0;
    bool indefinite = true;
    PyObject *ret;
    char length_hex[17];

    if (decode_length(self, subtype, &length, &indefinite) == -1)
        return NULL;

    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {
        sprintf(length_hex, "%llX", length);
        PyErr_Format(
                _CBOR2_CBORDecodeValueError,
                "excessive bytestring size 0x%s", length_hex);
        return NULL;
    }
    if (indefinite)
        ret = decode_indefinite_bytestrings(self);
    else if (length <= 65536)
        ret = decode_definite_short_bytestring(self, (Py_ssize_t)length);
    else
        ret = decode_definite_long_bytestring(self, (Py_ssize_t)length);

    if (ret)
        set_shareable(self, ret);

    return ret;
}
