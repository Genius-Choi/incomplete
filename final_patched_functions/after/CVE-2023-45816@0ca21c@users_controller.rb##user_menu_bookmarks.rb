  def user_menu_bookmarks
    if !current_user.username_equals_to?(params[:username])
      raise Discourse::InvalidAccess.new("username doesn't match current_user's username")
    end

    reminder_notifications =
      BookmarkQuery.new(user: current_user).unread_notifications(limit: USER_MENU_LIST_LIMIT)
    if reminder_notifications.size < USER_MENU_LIST_LIMIT
      exclude_bookmark_ids =
        reminder_notifications.filter_map { |notification| notification.data_hash[:bookmark_id] }

      bookmark_list =
        UserBookmarkList.new(
          user: current_user,
          guardian: guardian,
          per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,
        )

      bookmark_list.load do |query|
        if exclude_bookmark_ids.present?
          query.where("bookmarks.id NOT IN (?)", exclude_bookmark_ids)
        end
      end
    end

    if reminder_notifications.present?
      serialized_notifications =
        ActiveModel::ArraySerializer.new(
          reminder_notifications,
          each_serializer: NotificationSerializer,
          scope: guardian,
        )
    end

    if bookmark_list
      bookmark_list.bookmark_serializer_opts = { link_to_first_unread_post: true }
      serialized_bookmarks =
        serialize_data(bookmark_list, UserBookmarkListSerializer, scope: guardian, root: false)[
          :bookmarks
        ]
    end

    render json: {
             notifications: serialized_notifications || [],
             bookmarks: serialized_bookmarks || [],
           }
  end
