def pyon_scanstring(s, end, encoding = None, strict = True,
                    _b = BACKSLASH, _m = STRINGCHUNK.match):
  """Scan the string s for a JSON string. End is the index of the
  character in s after the quote that started the JSON string.
  Unescapes all valid JSON string escape sequences and raises ValueError
  on attempt to decode an invalid string. If strict is False then literal
  control characters are allowed in the string.
  Returns a tuple of the decoded string and the index of the character in s
  after the end quote."""
  if encoding is None: encoding = DEFAULT_ENCODING
  chunks = []
  _append = chunks.append
  begin = end - 1

  while True:
    chunk = _m(s, end)
    if chunk is None:
      raise ValueError(
        errmsg("Unterminated string starting at", s, begin))

    end = chunk.end()
    content, terminator = chunk.groups()

    # Content is contains zero or more unescaped string characters
    if content:
      if not isinstance(content, unicode):
        content = unicode(content, encoding)
      _append(content)

    # Terminator is the end of string, a literal control character,
    # or a backslash denoting that an escape sequence follows
    if terminator == '"': break
    elif terminator != '\\':
      if strict:
        msg = "Invalid control character {0!r} at".format(terminator)
        raise ValueError(errmsg(msg, s, end))
      else:
        _append(terminator)
        continue

    try:
      esc = s[end]
    except IndexError:
      raise ValueError(errmsg("Unterminated string starting at", s, begin))

    # If not a unicode escape sequence, must be in the lookup table
    if esc != 'u' and esc != 'x':
      try:
        char = _b[esc]
      except KeyError:
        msg = "Invalid \\escape: " + repr(esc)
        raise ValueError(errmsg(msg, s, end))
      end += 1

    elif esc == 'x':
      # Hex escape sequence
      try:
        code = s[end + 1: end + 3]
        char = code.decode('hex')
      except:
        raise ValueError(errmsg('Invalid \\escape: ' + repr(code), s, end))

      end += 3

    else:
      # Unicode escape sequence
      uni = _decode_uXXXX(s, end)
      end += 5
      # Check for surrogate pair on UCS-4 systems
      if sys.maxunicode > 65535 and \
         0xd800 <= uni <= 0xdbff and s[end:end + 2] == '\\u':
        uni2 = _decode_uXXXX(s, end + 1)
        if 0xdc00 <= uni2 <= 0xdfff:
          uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))
          end += 6
      char = unichr(uni)

    # Append the unescaped character
    _append(char)

  return u''.join(chunks), end
