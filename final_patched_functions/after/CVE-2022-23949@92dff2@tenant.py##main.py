def main(argv=sys.argv):
    """[summary]

    Keyword Arguments:
        argv {[type]} -- [description] (default: {sys.argv})

    Raises:
        UserError: [description]
        UserError: [description]
        UserError: [description]
    """
    parser = argparse.ArgumentParser(argv[0])
    parser.add_argument('-c', '--command', action='store', dest='command', default='add',
                        help="valid commands are add,delete,update,"
                             "regstatus,cvstatus,status,reglist,cvlist,reactivate,"
                             "regdelete,"
                             "bulkinfo. defaults to add")
    parser.add_argument('-t', '--targethost', action='store',
                        dest='agent_ip', help="the IP address of the host to provision")
    parser.add_argument('-tp', '--targetport', action='store',
                        dest='agent_port', help="the Port of the host to provision")
    parser.add_argument('-r', '--registrarhost', action='store',
                        dest='registrar_ip', help="the IP address of the registrar where to retrieve the agents data from.")
    parser.add_argument('-rp', '--registrarport', action="store",
                        dest='registrar_port', help="the port of the registrar.")
    parser.add_argument('--cv_targethost', action='store', default=None, dest='cv_agent_ip',
                        help='the IP address of the host to provision that the verifier will use (optional).  Use only if different than argument to option -t/--targethost')
    parser.add_argument('-v', '--cv', action='store', dest='verifier_ip',
                        help="the IP address of the cloud verifier")
    parser.add_argument('-vp', '--cvport', action='store', dest='verifier_port',
                        help="the port of the cloud verifier")
    parser.add_argument('-vi', '--cvid', action='store', dest='verifier_id',
                        help="the unique identifier of a cloud verifier")
    parser.add_argument('-nvc', '--no-verifier-check', action='store_false', dest='verifier_check', default=True,
                        help='Disable the check to confirm if the agent is being processed by the specified verifier. Use only with -c/--command delete or reactivate')
    parser.add_argument('-u', '--uuid', action='store',
                        dest='agent_uuid', help="UUID for the agent to provision")
    parser.add_argument('-f', '--file', action='store', default=None,
                        help='Deliver the specified plaintext to the provisioned agent')
    parser.add_argument('--cert', action='store', dest='ca_dir', default=None,
                        help='Create and deliver a certificate using a CA created by ca-util. Pass in the CA directory or use "default" to use the standard dir')
    parser.add_argument('-k', '--key', action='store', dest='keyfile',
                        help='an intermedia key file produced by user_data_encrypt')
    parser.add_argument('-p', '--payload', action='store', default=None,
                        help='Specify the encrypted payload to deliver with encrypted keys specified by -k')
    parser.add_argument('--include', action='store', dest='incl_dir', default=None,
                        help="Include additional files in provided directory in certificate zip file.  Must be specified with --cert")
    parser.add_argument('--allowlist', action='store', dest='allowlist',
                        default=None, help="Specify the file path of an allowlist")
    parser.add_argument('--signature-verification-key', '--sign_verification_key', action='append', dest='ima_sign_verification_keys',
                        default=[], help="Specify an IMA file signature verification key")
    parser.add_argument('--signature-verification-key-sig', action='append', dest='ima_sign_verification_key_sigs',
                        default=[], help="Specify the GPG signature file for an IMA file signature verification key; pair this option with --signature-verification-key")
    parser.add_argument('--signature-verification-key-sig-key', action='append', dest='ima_sign_verification_key_sig_keys',
                        default=[], help="Specify the GPG public key file use to validate the --signature-verification-key-sig; pair this option with --signature-verification-key")
    parser.add_argument('--signature-verification-key-url', action='append', dest='ima_sign_verification_key_urls',
                        default=[], help="Specify the URL for a remote IMA file signature verification key")
    parser.add_argument('--signature-verification-key-sig-url', action='append',
                        dest='ima_sign_verification_key_sig_urls',
                        default=[], help="Specify the URL for the remote GPG signature of a remote IMA file signature verification key; pair this option with --signature-verification-key-url")
    parser.add_argument('--signature-verification-key-sig-url-key', action='append',
                        dest='ima_sign_verification_key_sig_url_keys',
                        default=[], help="Specify the GPG public key file used to validate the --signature-verification-key-sig-url; pair this option with --signature-verification-key-url")
    parser.add_argument('--mb_refstate', action='store', dest='mb_refstate',
                        default=None, help="Specify the location of a measure boot reference state (intended state)")
    parser.add_argument('--allowlist-checksum', action='store', dest='allowlist_checksum',
                        default=None, help="Specify the SHA2 checksum of an allowlist")
    parser.add_argument('--allowlist-sig', action='store', dest='allowlist_sig',
                        default=None, help="Specify the GPG signature file of an allowlist")
    parser.add_argument('--allowlist-sig-key', action='store', dest='allowlist_sig_key',
                        default=None, help="Specify the GPG public key file used to validate the --allowlist-sig or --allowlist-sig-url")
    parser.add_argument('--allowlist-url', action='store', dest='allowlist_url',
                        default=None, help="Specify the URL of a remote allowlist")
    parser.add_argument('--allowlist-sig-url', action='store', dest='allowlist_sig_url',
                        default=None, help="Specify the URL of the remote GPG signature file of an allowlist")
    parser.add_argument('--exclude', action='store', dest='ima_exclude',
                        default=None, help="Specify the location of an IMA exclude list")
    parser.add_argument('--tpm_policy', action='store', dest='tpm_policy', default=None,
                        help="Specify a TPM policy in JSON format. e.g., {\"15\":\"0000000000000000000000000000000000000000\"}")
    parser.add_argument('--vtpm_policy', action='store', dest='vtpm_policy',
                        default=None, help="Specify a vTPM policy in JSON format")
    parser.add_argument('--verify', action='store_true', default=False,
                        help='Block on cryptographically checked key derivation confirmation from the agent once it has been provisioned')
    parser.add_argument('--allowlist-name', help='The name of allowlist to operate with')
    parser.add_argument('--supported-version', default=None, action="store", dest='supported_version', help='API version that is supported by the agent. Detected automatically by default')

    args = parser.parse_args(argv[1:])

    # Make sure argument dependencies are enforced
    if( args.allowlist and args.allowlist_url):
        parser.error("--allowlist and --allowlist-url cannot be specified at the same time")
    if( args.allowlist_url and not (args.allowlist_sig or args.allowlist_sig_url or args.allowlist_checksum)):
        parser.error("--allowlist-url must have either --allowlist-sig, --allowlist-sig-url or --allowlist-checksum to verifier integrity")
    if( args.allowlist_sig and not (args.allowlist_url or args.allowlist)):
        parser.error("--allowlist-sig must have either --allowlist or --allowlist-url")
    if( args.allowlist_sig_url and not (args.allowlist_url or args.allowlist)):
        parser.error("--allowlist-sig-url must have either --allowlist or --allowlist-url")
    if( args.allowlist_checksum and not (args.allowlist_url or args.allowlist)):
        parser.error("--allowlist-checksum must have either --allowlist or --allowlist-url")
    if( args.allowlist_sig and not args.allowlist_sig_key):
        parser.error("--allowlist-sig must also have --allowlist-sig-key")
    if( args.allowlist_sig_url and not args.allowlist_sig_key):
        parser.error("--allowlist-sig-url must also have --allowlist-sig-key")
    if( args.allowlist_sig_key and not (args.allowlist_sig or args.allowlist_sig_url)):
        parser.error("--allowlist-sig-key must have either --allowlist-sig or --allowlist-sig-url")

    mytenant = Tenant()

    if args.agent_uuid is not None:
        mytenant.agent_uuid = args.agent_uuid
        # if the uuid is actually a public key, then hash it
        if mytenant.agent_uuid.startswith('-----BEGIN PUBLIC KEY-----'):
            mytenant.agent_uuid = hashlib.sha256(
                mytenant.agent_uuid).hexdigest()
        if not validators.valid_agent_id(mytenant.agent_uuid):
            raise UserError("The agent ID set via agent uuid parameter use invalid characters")
    else:
        logger.warning("Using default UUID d432fbb3-d2f1-4a97-9ef7-75bd81c00000")
        mytenant.agent_uuid = "d432fbb3-d2f1-4a97-9ef7-75bd81c00000"

    if config.STUB_VTPM and config.TPM_CANNED_VALUES is not None:
        # Use canned values for agent UUID
        jsonIn = config.TPM_CANNED_VALUES
        if "add_vtpm_to_group" in jsonIn:
            mytenant.agent_uuid = jsonIn['add_vtpm_to_group']['retout']
        else:
            # Our command hasn't been canned!
            raise UserError("Command %s not found in canned JSON!" %
                            ("add_vtpm_to_group"))

    if args.verifier_id is not None:
        mytenant.verifier_id = args.verifier_id
    if args.verifier_ip is not None:
        mytenant.verifier_ip = args.verifier_ip
    if args.verifier_port is not None:
        mytenant.verifier_port = args.verifier_port

    if args.registrar_ip is not None:
        mytenant.registrar_ip = args.registrar_ip
    if args.registrar_port is not None:
        mytenant.registrar_port = args.registrar_port

    # we only need to fetch remote files if we are adding or updating
    if args.command in ['add', 'update']:
        delete_tmp_files = logger.level > logging.DEBUG # delete tmp files unless in DEBUG mode

        if args.allowlist_url:
            logger.info("Downloading Allowlist from %s", args.allowlist_url)
            response = requests.get(args.allowlist_url, allow_redirects=False)
            if response.status_code == 200:
                args.allowlist = write_to_namedtempfile(response.content, delete_tmp_files)
                logger.debug("Allowlist temporarily saved in %s" % args.allowlist)
            else:
                raise Exception(f"Downloading allowlist ({args.allowlist_url}) failed with status code {response.status_code}!")

        if args.allowlist_sig_url:
            logger.info("Downloading Allowlist signature from %s", args.allowlist_sig_url)
            response = requests.get(args.allowlist_sig_url, allow_redirects=False)
            if response.status_code == 200:
                args.allowlist_sig = write_to_namedtempfile(response.content, delete_tmp_files)
                logger.debug("Allowlist signature temporarily saved in %s", args.allowlist_sig)
            else:
                raise Exception(f"Downloading allowlist signature ({args.allowlist_sig_url}) failed with status code {response.status_code}!")

        # verify all the local keys for which we have a signature file and a key to verify
        for i, key_file in enumerate(args.ima_sign_verification_keys):
            if len(args.ima_sign_verification_key_sigs) <= i:
                break
            keysig_file = args.ima_sign_verification_key_sigs[i]
            if len(args.ima_sign_verification_key_sig_keys) == 0:
                raise UserError("A gpg key is missing for key signature file '%s'" % keysig_file)

            gpg_key_file = args.ima_sign_verification_key_sig_keys[i]
            gpg.gpg_verify_filesignature(gpg_key_file, key_file, keysig_file, "IMA file signing key")

            logger.info("Signature verification on %s was successful" % key_file)

        # verify all the remote keys for which we have a signature URL and key to to verify
        # Append the downloaded key files to args.ima_sign_verification_keys
        for i, key_url in enumerate(args.ima_sign_verification_key_urls):

            logger.info("Downloading key from %s", key_url)
            response = requests.get(key_url, allow_redirects=False)
            if response.status_code == 200:
                key_file = write_to_namedtempfile(response.content, delete_tmp_files)
                args.ima_sign_verification_keys.append(key_file)
                logger.debug("Key temporarily saved in %s" % key_file)
            else:
                raise Exception(f"Downloading key ({key_url}) failed with status code {response.status_code}!")

            if len(args.ima_sign_verification_key_sig_urls) <= i:
                continue

            keysig_url = args.ima_sign_verification_key_sig_urls[i]

            if len(args.ima_sign_verification_key_sig_url_keys) == 0:
                raise UserError("A gpg key is missing for key signature URL '%s'" % keysig_url)

            logger.info("Downloading key signature from %s" % keysig_url)
            response = requests.get(keysig_url, allow_redirects=False)
            if response.status_code == 200:
                keysig_file = write_to_namedtempfile(response.content, delete_tmp_files)
                logger.debug("Key signature temporarily saved in %s" % keysig_file)
            else:
                raise Exception(f"Downloading key signature ({key_url}) failed with status code {response.status_code}!")

            gpg_key_file = args.ima_sign_verification_key_sig_url_keys[i]
            gpg.gpg_verify_filesignature(gpg_key_file, key_file, keysig_file, "IMA file signing key")
            logger.info("Signature verification on %s was successful" % key_url)

    if args.command == 'add':
        mytenant.init_add(vars(args))
        mytenant.preloop()
        mytenant.do_cv()
        mytenant.do_quote()
        if args.verify:
            mytenant.do_verify()
    elif args.command == 'update':
        mytenant.init_add(vars(args))
        mytenant.do_cvdelete(args.verifier_check)
        mytenant.preloop()
        mytenant.do_cv()
        mytenant.do_quote()
        if args.verify:
            mytenant.do_verify()
    elif args.command == 'delete':
        mytenant.do_cvdelete(args.verifier_check)
    elif args.command == 'status':
        mytenant.do_status()
    elif args.command == 'cvstatus':
        mytenant.do_cvstatus()
    elif args.command == 'bulkinfo':
        mytenant.do_cvbulkinfo()
    elif args.command == 'cvlist':
        mytenant.do_cvlist()
    elif args.command == 'reactivate':
        mytenant.do_cvreactivate(args.verifier_check)
    elif args.command == 'regstatus':
        mytenant.do_regstatus()
    elif args.command == 'reglist':
        mytenant.do_reglist()
    elif args.command == 'regdelete':
        mytenant.do_regdelete()
    elif args.command == 'addallowlist':
        mytenant.do_add_allowlist(vars(args))
    elif args.command == 'showallowlist':
        mytenant.do_show_allowlist(args.allowlist_name)
    elif args.command == 'deleteallowlist':
        mytenant.do_delete_allowlist(args.allowlist_name)
    else:
        raise UserError("Invalid command specified: %s" % (args.command))
