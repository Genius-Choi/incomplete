static void do_core_init(void)
{
    /* Initialize heap allocator. WARNING: This *needs* to happen *after* the app cpu has booted.
       If the heap allocator is initialized first, it will put free memory linked list items into
       memory also used by the ROM. Starting the app cpu will let its ROM initialize that memory,
       corrupting those linked lists. Initializing the allocator *after* the app cpu has booted
       works around this problem.
       With SPI RAM enabled, there's a second reason: half of the SPI RAM will be managed by the
       app CPU, and when that is not up yet, the memory will be inaccessible and heap_caps_init may
       fail initializing it properly. */
    heap_caps_init();

    // When apptrace module is enabled, there will be SEGGER_SYSVIEW calls in the newlib init.
    // SEGGER_SYSVIEW relies on apptrace module
    // apptrace module uses esp_timer_get_time to determine timeout conditions.
    // esp_timer early initialization is required for esp_timer_get_time to work.
    esp_timer_early_init();
    esp_newlib_init();

#if CONFIG_SPIRAM_BOOT_INIT && (CONFIG_SPIRAM_USE_CAPS_ALLOC || CONFIG_SPIRAM_USE_MALLOC)
    if (esp_psram_is_initialized()) {
        esp_err_t r=esp_psram_extram_add_to_heap_allocator();
        if (r != ESP_OK) {
            ESP_EARLY_LOGE(TAG, "External RAM could not be added to heap!");
            abort();
        }
#if CONFIG_SPIRAM_USE_MALLOC
        heap_caps_malloc_extmem_enable(CONFIG_SPIRAM_MALLOC_ALWAYSINTERNAL);
#endif
    }
#endif

#if CONFIG_ESP_BROWNOUT_DET
    // [refactor-todo] leads to call chain rtc_is_register (driver) -> esp_intr_alloc (esp32/esp32s2) ->
    // malloc (newlib) -> heap_caps_malloc (heap), so heap must be at least initialized
    esp_brownout_init();
#endif

    esp_newlib_time_init();

#if CONFIG_VFS_SUPPORT_IO
    // VFS console register.
    esp_err_t vfs_err = esp_vfs_console_register();
    assert(vfs_err == ESP_OK && "Failed to register vfs console");
#endif

#if defined(CONFIG_VFS_SUPPORT_IO) && !defined(CONFIG_ESP_CONSOLE_NONE)
    const static char *default_stdio_dev = "/dev/console/";
    esp_reent_init(_GLOBAL_REENT);
    _GLOBAL_REENT->_stdin  = fopen(default_stdio_dev, "r");
    _GLOBAL_REENT->_stdout = fopen(default_stdio_dev, "w");
    _GLOBAL_REENT->_stderr = fopen(default_stdio_dev, "w");
#if ESP_ROM_NEEDS_SWSETUP_WORKAROUND
    /*
    - This workaround for printf functions using 32-bit time_t after the 64-bit time_t upgrade
    - The 32-bit time_t usage is triggered through ROM Newlib functions printf related functions calling __swsetup_r() on
      the first call to a particular file pointer (i.e., stdin, stdout, stderr)
    - Thus, we call the toolchain version of __swsetup_r() now (before any printf calls are made) to setup all of the
      file pointers. Thus, the ROM newlib code will never call the ROM version of __swsetup_r().
    - See IDFGH-7728 for more details
    */
    extern int __swsetup_r(struct _reent *, FILE *);
    __swsetup_r(_GLOBAL_REENT, _GLOBAL_REENT->_stdout);
    __swsetup_r(_GLOBAL_REENT, _GLOBAL_REENT->_stderr);
    __swsetup_r(_GLOBAL_REENT, _GLOBAL_REENT->_stdin);
#endif // ESP_ROM_NEEDS_SWSETUP_WORKAROUND
#else // defined(CONFIG_VFS_SUPPORT_IO) && !defined(CONFIG_ESP_CONSOLE_NONE)
    _REENT_SMALL_CHECK_INIT(_GLOBAL_REENT);
#endif // defined(CONFIG_VFS_SUPPORT_IO) && !defined(CONFIG_ESP_CONSOLE_NONE)

    esp_err_t err __attribute__((unused));

    err = esp_pthread_init();
    assert(err == ESP_OK && "Failed to init pthread module!");

#if CONFIG_SPI_FLASH_ROM_IMPL
    spi_flash_rom_impl_init();
#endif

    esp_flash_app_init();
    esp_err_t flash_ret = esp_flash_init_default_chip();
    assert(flash_ret == ESP_OK);
    (void)flash_ret;
#if CONFIG_SPI_FLASH_BROWNOUT_RESET
    spi_flash_needs_reset_check();
#endif // CONFIG_SPI_FLASH_BROWNOUT_RESET

#ifdef CONFIG_EFUSE_VIRTUAL
    ESP_LOGW(TAG, "eFuse virtual mode is enabled. If Secure boot or Flash encryption is enabled then it does not provide any security. FOR TESTING ONLY!");
#ifdef CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
    const esp_partition_t *efuse_partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM, NULL);
    if (efuse_partition) {
        esp_efuse_init_virtual_mode_in_flash(efuse_partition->address, efuse_partition->size);
    }
#endif
#endif

#if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK
    // For anti-rollback case, recheck security version before we boot-up the current application
    assert(esp_efuse_check_secure_version(esp_app_get_description()->secure_version) == true && "Incorrect secure version of app");
#endif

#ifdef CONFIG_SECURE_FLASH_ENC_ENABLED
    esp_flash_encryption_init_checks();
#endif

#if defined(CONFIG_SECURE_BOOT) || defined(CONFIG_SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT)
    // Note: in some configs this may read flash, so placed after flash init
    esp_secure_boot_init_checks();
#endif

#if CONFIG_SECURE_DISABLE_ROM_DL_MODE
    err = esp_efuse_disable_rom_download_mode();
    assert(err == ESP_OK && "Failed to disable ROM download mode");
#endif

#if CONFIG_SECURE_ENABLE_SECURE_ROM_DL_MODE
    err = esp_efuse_enable_rom_secure_download_mode();
    assert(err == ESP_OK && "Failed to enable Secure Download mode");
#endif

#if CONFIG_ESP32_DISABLE_BASIC_ROM_CONSOLE
    esp_efuse_disable_basic_rom_console();
#endif

#ifdef ROM_LOG_MODE
    esp_efuse_set_rom_log_scheme(ROM_LOG_MODE);
#endif

#if CONFIG_ESP_XT_WDT
    esp_xt_wdt_config_t cfg = {
        .timeout                = CONFIG_ESP_XT_WDT_TIMEOUT,
        .auto_backup_clk_enable = CONFIG_ESP_XT_WDT_BACKUP_CLK_ENABLE,
    };
    err = esp_xt_wdt_init(&cfg);
    assert(err == ESP_OK && "Failed to init xtwdt");
#endif
}
