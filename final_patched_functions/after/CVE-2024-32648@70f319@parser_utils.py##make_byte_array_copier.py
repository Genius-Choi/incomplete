def make_byte_array_copier(destination, source, pos=None):
    if not isinstance(source.typ, ByteArrayLike):
        raise TypeMismatch(f"Cannot cast from {source.typ} to {destination.typ}", pos)
    if isinstance(source.typ, ByteArrayLike) and source.typ.maxlen > destination.typ.maxlen:
        raise TypeMismatch(
            f"Cannot cast from greater max-length {source.typ.maxlen} to shorter "
            f"max-length {destination.typ.maxlen}"
        )

    # stricter check for zeroing a byte array.
    if isinstance(source.typ, ByteArrayLike):
        if source.value is None and source.typ.maxlen != destination.typ.maxlen:
            raise TypeMismatch(
                f"Bad type for clearing bytes: expected {destination.typ}" f" but got {source.typ}"
            )

    # Special case: memory to memory
    # TODO: this should be handled by make_byte_slice_copier.
    if destination.location == "memory" and source.location in ("memory", "code", "calldata"):
        if source.location == "memory":
            # TODO turn this into an LLL macro: memorycopy
            copy_op = ["assert", ["call", ["gas"], 4, 0, "src", "sz", destination, "sz"]]
            gas_bound = _identity_gas_bound(source.typ.maxlen)
        elif source.location == "calldata":
            copy_op = ["calldatacopy", destination, "src", "sz"]
            gas_bound = _calldatacopy_gas_bound(source.typ.maxlen)
        elif source.location == "code":
            copy_op = ["codecopy", destination, "src", "sz"]
            gas_bound = _codecopy_gas_bound(source.typ.maxlen)
        _sz_lll = ["add", 32, [load_op(source.location), "src"]]
        o = LLLnode.from_list(
            ["with", "src", source, ["with", "sz", _sz_lll, copy_op]],
            typ=None,
            add_gas_estimate=gas_bound,
            annotation="copy bytestring to memory",
        )
        return o

    if source.value is None:
        pos_node = source
    else:
        pos_node = LLLnode.from_list("_pos", typ=source.typ, location=source.location)
    # Get the length
    if source.value is None:
        length = 1
    elif source.location in ("memory", "code", "calldata"):
        length = ["add", [load_op(source.location), "_pos"], 32]
    elif source.location == "storage":
        length = ["add", ["sload", "_pos"], 32]
        pos_node = LLLnode.from_list(pos_node, typ=source.typ, location=source.location,)
    else:
        raise CompilerPanic(f"Unsupported location: {source.location} to {destination.location}")
    if destination.location == "storage":
        destination = LLLnode.from_list(
            destination, typ=destination.typ, location=destination.location,
        )
    # Maximum theoretical length
    max_length = 32 if source.value is None else source.typ.maxlen + 32
    return LLLnode.from_list(
        [
            "with",
            "_pos",
            0 if source.value is None else source,
            make_byte_slice_copier(destination, pos_node, length, max_length, pos=pos),
        ],
        typ=None,
    )
