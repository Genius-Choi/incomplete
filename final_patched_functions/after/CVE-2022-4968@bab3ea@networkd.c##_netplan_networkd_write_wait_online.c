_netplan_networkd_write_wait_online(const NetplanState* np_state, const char* rootdir)
{
    // Set of all current network interfaces, potentially non yet renamed
    GHashTable* system_interfaces = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
    _netplan_query_system_interfaces(system_interfaces);

    // Hash set of non-optional interfaces to wait for
    GHashTable* non_optional_interfaces = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
    NetplanStateIterator iter;
    netplan_state_iterator_init(np_state, &iter);
    while (netplan_state_iterator_has_next(&iter)) {
        NetplanNetDefinition* def = netplan_state_iterator_next(&iter);
        if (def->backend != NETPLAN_BACKEND_NETWORKD)
            continue;

        /* When activation-mode is used we default to being optional.
         * Otherwise, systemd might wait indefinitely for the interface to
         * come online.
         */
        if (!(def->optional || def->activation_mode)) {
            // Check if we have any IP configuration
            // bond and bridge members will never ask for link-local addresses (see above)
            struct address_iter* addr_iter = _netplan_netdef_new_address_iter(def);
            gboolean routable =   _netplan_address_iter_next(addr_iter) != NULL
                               || netplan_netdef_get_dhcp4(def)
                               || netplan_netdef_get_dhcp6(def);
            gboolean degraded =   (   netplan_netdef_get_link_local_ipv4(def)
                                   && !(netplan_netdef_get_bond_link(def) || netplan_netdef_get_bridge_link(def)))
                               || (   netplan_netdef_get_link_local_ipv6(def)
                                   && !(netplan_netdef_get_bond_link(def) || netplan_netdef_get_bridge_link(def)));
            gboolean any_ips = routable || degraded;
            _netplan_address_iter_free(addr_iter);

            // no matching => single physical interface, ignoring non-existing interfaces
            // OR: virtual interfaces, those will be created later on and cannot have a matching condition
            gboolean physical_no_match_or_virtual = FALSE
                || (!netplan_netdef_has_match(def) && g_hash_table_contains(system_interfaces, def->id))
                || (netplan_netdef_get_type(def) >= NETPLAN_DEF_TYPE_VIRTUAL);
            if (physical_no_match_or_virtual) {
                g_hash_table_replace(non_optional_interfaces, g_strdup(def->id), any_ips ? g_strdup("degraded") : g_strdup("carrier"));
            } else if (def->set_name) { // matching on a single interface, to be renamed
                 _netplan_enumerate_interfaces(def, system_interfaces, non_optional_interfaces, any_ips ? "degraded" : "carrier", def->set_name, rootdir);
            } else { // matching on potentially multiple interfaces
                // XXX: we shouldn't run this enumeration for every NetDef...
                _netplan_enumerate_interfaces(def, system_interfaces, non_optional_interfaces, any_ips ? "degraded" : "carrier", NULL, rootdir);
            }
        }
    }
    g_hash_table_destroy(system_interfaces);

    // create run/systemd/system/systemd-networkd-wait-online.service.d/
    const char* override = "/run/systemd/system/systemd-networkd-wait-online.service.d/10-netplan.conf";
    // The "ConditionPathIsSymbolicLink" is Netplan's s-n-wait-online enablement symlink,
    // as we want to run -wait-online only if enabled by Netplan.
    GString* content = g_string_new("[Unit]\n"
        "ConditionPathIsSymbolicLink=/run/systemd/generator/network-online.target.wants/systemd-networkd-wait-online.service\n");
    if (g_hash_table_size(non_optional_interfaces) == 0) {
        _netplan_g_string_free_to_file_with_permissions(content, rootdir, override, NULL, "root", "root", 0640);
        g_hash_table_destroy(non_optional_interfaces);
        return FALSE;
    }

    // We have non-optional interface, so let's wait for those explicitly
    GHashTableIter idx;
    gpointer key, value;
    g_string_append(content, "\n[Service]\nExecStart=\n"
                                "ExecStart=/lib/systemd/systemd-networkd-wait-online");
    g_hash_table_iter_init (&idx, non_optional_interfaces);
    while (g_hash_table_iter_next (&idx, &key, &value)) {
        const char* ifname = key;
        const char* min_oper_state = value;
        g_string_append_printf(content, " -i %s", ifname);
        // XXX: We should be checking IFF_LOOPBACK instead of interface name.
        //      But don't have access to the flags here.
        if (!g_strcmp0(ifname, "lo"))
            g_string_append(content, ":carrier"); // "carrier" as min-oper state for loopback
        else if (min_oper_state)
            g_string_append_printf(content, ":%s", min_oper_state);
    }
    g_string_append(content, "\n");

    _netplan_g_string_free_to_file_with_permissions(content, rootdir, override, NULL, "root", "root", 0640);
    g_hash_table_destroy(non_optional_interfaces);
    return TRUE;
}
