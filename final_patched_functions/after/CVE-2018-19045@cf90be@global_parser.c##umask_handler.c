umask_handler(vector_t *strvec)
{
	long umask_long;
	mode_t umask_val = 0;
	char *mask = strvec_slot(strvec, 1);
	char *endptr;
	unsigned i;
	char *p;

	if (umask_cmdline) {
		log_message(LOG_INFO, "umask command line option specified, ignoring config option");
		return;
	}

	if (isdigit(mask[0])) {
		if (vector_size(strvec) != 2) {
			report_config_error(CONFIG_GENERAL_ERROR, "%s parameter(s) to umask option", vector_size(strvec) == 1 ? "Missing" : "Extra");
			return;
		}
		umask_long = strtol(mask, &endptr, 0);
		if (*endptr || umask_long < 0 || umask_long & ~0777L) {
			report_config_error(CONFIG_GENERAL_ERROR, "invalid umask value %s", mask);
			return;
		}
		umask_val = umask_long & 0777;
	}
	else {
		bool need_or = false;
		for (i = 1; i < vector_size(strvec); i++) {
			for (p = strvec_slot(strvec, i); *p; ) {
				if (need_or) {
					if (*p == '|') {
						need_or = false;
						p++;
						continue;
					}

					report_config_error(CONFIG_GENERAL_ERROR, "Invalid umask syntax %s", FMT_STR_VSLOT(strvec, i));
					return;
				}

				if      (!strncmp(p, "IRUSR", 5)) umask_val |= S_IRUSR;
				else if (!strncmp(p, "IWUSR", 5)) umask_val |= S_IWUSR;
				else if (!strncmp(p, "IXUSR", 5)) umask_val |= S_IXUSR;
				else if (!strncmp(p, "IRGRP", 5)) umask_val |= S_IRGRP;
				else if (!strncmp(p, "IWGRP", 5)) umask_val |= S_IWGRP;
				else if (!strncmp(p, "IXGRP", 5)) umask_val |= S_IXGRP;
				else if (!strncmp(p, "IROTH", 5)) umask_val |= S_IROTH;
				else if (!strncmp(p, "IWOTH", 5)) umask_val |= S_IWOTH;
				else if (!strncmp(p, "IXOTH", 5)) umask_val |= S_IXOTH;
				else {
					report_config_error(CONFIG_GENERAL_ERROR, "Unknown umask bit %s", p);
					return;
				}

				p += 5;
				need_or = true;
			}
		}
		if (!need_or) {
			report_config_error(CONFIG_GENERAL_ERROR, "umask missing bit value");
			return;
		}
	}

	global_data->umask = umask_val;
	umask(umask_val);
}
