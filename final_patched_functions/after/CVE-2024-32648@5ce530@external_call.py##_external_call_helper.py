def _external_call_helper(
    contract_address, contract_sig, args_lll, context, pos=None, value=None, gas=None
):

    if value is None:
        value = 0
    if gas is None:
        gas = "gas"

    # sanity check
    assert len(contract_sig.args) == len(args_lll)

    if context.is_constant() and contract_sig.mutability not in ("view", "pure"):
        # TODO is this already done in type checker?
        raise StateAccessViolation(
            f"May not call state modifying function '{contract_sig.name}' "
            f"within {context.pp_constancy()}.",
            pos,
        )

    sub = ["seq"]

    buf, arg_packer, args_ofst, args_len = _pack_arguments(contract_sig, args_lll, context, pos)

    ret_unpacker, ret_ofst, ret_len = _unpack_returndata(buf, contract_sig, context, pos)

    sub += arg_packer

    if contract_sig.return_type is None:
        # if we do not expect return data, check that a contract exists at the
        # target address. we must perform this check BEFORE the call because
        # the contract might selfdestruct. on the other hand we can omit this
        # when we _do_ expect return data because we later check
        # `returndatasize` (that check works even if the contract
        # selfdestructs).
        sub.append(["assert", ["extcodesize", contract_address]])

    if context.is_constant() or contract_sig.mutability in ("view", "pure"):
        call_op = ["staticcall", gas, contract_address, args_ofst, args_len, ret_ofst, ret_len]
    else:
        call_op = ["call", gas, contract_address, value, args_ofst, args_len, ret_ofst, ret_len]

    sub.append(["assert", call_op])

    if contract_sig.return_type is not None:
        sub += ret_unpacker

    ret = LLLnode.from_list(
        # set the encoding to ABI here, downstream code will decode and add clampers.
        sub,
        typ=contract_sig.return_type,
        location="memory",
        encoding=_returndata_encoding(contract_sig),
        pos=pos,
    )

    return ret
