  def response_redirect(response, method, page, redirects, headers,
                        referer = current_page)
    case @redirect_ok
    when true, :all
      # shortcut
    when false, nil
      return page
    when :permanent
      return page unless Net::HTTPMovedPermanently === response
    end

    log.info("follow redirect to: #{response['Location']}") if log

    raise Mechanize::RedirectLimitReachedError.new(page, redirects) if
      redirects + 1 > @redirection_limit

    redirect_method = method == :head ? :head : :get

    new_uri = secure_resolve!(response['Location'].to_s, page)
    @history.push(page, page.uri)

    # Make sure we are not copying over the POST headers from the original request
    POST_HEADERS.each do |key|
      headers.delete_if { |h| h.casecmp?(key) }
    end

    # Make sure we clear credential headers if being redirected to another site
    if new_uri.host == page.uri.host
      if new_uri.port != page.uri.port
        # https://datatracker.ietf.org/doc/html/rfc6265#section-8.5
        # cookies are OK to be shared across ports on the same host
        CREDENTIAL_HEADERS.each { |ch| headers.delete_if { |h| h.casecmp?(ch) } }
      end
    else
      (COOKIE_HEADERS + CREDENTIAL_HEADERS).each { |ch| headers.delete_if { |h| h.casecmp?(ch) } }
    end

    fetch new_uri, redirect_method, headers, [], referer, redirects + 1
  end
