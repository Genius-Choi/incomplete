        def tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate):
            ''' adjust change amount (based on amount added from baton) '''
            if len(tx._outputs) not in (3,4):
                # no change, or a tx shape we don't know about
                self.print_error(f"Unkown tx shape, not adjusting fee!")
                return
            chg = tx._outputs[-1]  # change is always the last output due to BIP_LI01 sorting
            assert len(chg) == 3, "Expected tx output to be of length 3"
            if not self.main_window.wallet.is_mine(chg[1]):
                self.print_error(f"Unkown change address {chg[1]}, not adjusting fee!")
                return
            chg_amt = chg[2]
            if chg_amt <= 546:
                # if change is 546, then the BIP_LI01 sorting doesn't guarantee
                # change output is at the end.. so we don't know which was
                # changed based on the heuristics this code relies on.. so..
                # Abort! Abort!
                self.print_error("Could not determine change output, not adjusting fee!")
                return
            curr_fee, curr_size = tx.get_fee(), tx.estimated_size()
            fee_rate = curr_fee / curr_size
            diff = math.ceil((fee_rate - desired_fee_rate) * curr_size)
            if diff > 0:
                tx._outputs[-1] = (chg[0], chg[1], chg[2] + diff)  # adjust the output
                self.print_error(f"Added {diff} sats to change to maintain fee rate of {desired_fee_rate:0.2f}, new fee: {tx.get_fee()}")
