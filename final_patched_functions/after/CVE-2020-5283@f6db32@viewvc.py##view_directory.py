def view_directory(request):
  cfg = request.cfg

  # For Subversion repositories, the revision acts as a weak validator for
  # the directory listing (to take into account template changes or
  # revision property changes).
  if request.roottype == 'svn':
    try:
      rev = request.repos._getrev(request.pathrev)
    except vclib.InvalidRevision:
      raise debug.ViewVCException('Invalid revision', '404 Not Found')
    tree_rev = request.repos.created_rev(request.where, rev)
    if check_freshness(request, None, str(tree_rev), weak=1):
      return

  # List current directory
  options = {}
  if request.roottype == 'cvs':
    hideattic = int(request.query_dict.get('hideattic', 
                                           cfg.options.hide_attic))
    options["cvs_subdirs"] = (cfg.options.show_subdir_lastmod and
                              cfg.options.show_logs)
  debug.t_start("listdir")
  file_data = request.repos.listdir(request.path_parts, request.pathrev,
                                    options)
  debug.t_end("listdir")

  # sort with directories first, and using the "sortby" criteria
  sortby = request.query_dict.get('sortby', cfg.options.sort_by) or 'file'
  sortdir = request.query_dict.get('sortdir', 'up')

  # when paging and sorting by filename, we can greatly improve
  # performance by "cheating" -- first, we sort (we already have the
  # names), then we just fetch dirlogs for the needed entries.
  # however, when sorting by other properties or not paging, we've no
  # choice but to fetch dirlogs for everything.
  debug.t_start("dirlogs")
  if cfg.options.dir_pagesize and sortby == 'file':
    dirlogs_first = int(request.query_dict.get('dir_pagestart', 0))
    if dirlogs_first > len(file_data):
      dirlogs_first = 0
    dirlogs_last = dirlogs_first + cfg.options.dir_pagesize
    for file in file_data:
      file.rev = None
      file.date = None
      file.log = None
      file.author = None
      file.size = None
      file.lockinfo = None
      file.dead = None
    sort_file_data(file_data, request.roottype, sortdir, sortby,
                   cfg.options.sort_group_dirs)
    # request dirlogs only for the slice of files in "this page"
    request.repos.dirlogs(request.path_parts, request.pathrev,
                          file_data[dirlogs_first:dirlogs_last], options)
  else:
    request.repos.dirlogs(request.path_parts, request.pathrev,
                          file_data, options)
    sort_file_data(file_data, request.roottype, sortdir, sortby,
                   cfg.options.sort_group_dirs)
  debug.t_end("dirlogs")

  # If a regex is specified, build a compiled form thereof for filtering
  searchstr = None
  search_re = request.query_dict.get('search', '')
  if cfg.options.use_re_search and search_re:
    searchstr = re.compile(search_re)

  # loop through entries creating rows and changing these values
  rows = [ ]
  dirs_displayed = files_displayed = 0
  num_dead = 0
  
  # set some values to be used inside loop
  where = request.where
  where_prefix = where and where + '/'

  debug.t_start("row-building")
  for file in file_data:
    if is_dir_ignored_file(file.name, cfg):
      continue
    row = _item(author=None, log=None, short_log=None, state=None, size=None,
                log_file=None, log_rev=None, graph_href=None, mime_type=None,
                date=None, ago=None, view_href=None, log_href=None,
                revision_href=None, annotate_href=None, download_href=None,
                download_text_href=None, prefer_markup=ezt.boolean(0),
                is_viewable_image=ezt.boolean(0), is_binary=ezt.boolean(0))
    if request.roottype == 'cvs' and file.absent:
      continue
    if cfg.options.hide_errorful_entries and file.errors:
      continue
    row.rev = file.rev
    row.author = file.author
    row.state = (request.roottype == 'cvs' and file.dead) and 'dead' or ''
    if file.date is not None:
      row.date = make_time_string(file.date, cfg)
      row.ago = html_time(request, file.date)
    if cfg.options.show_logs:
      debug.t_start("dirview_logformat")
      lf = LogFormatter(request, file.log)
      row.log = lf.get(maxlen=0, htmlize=1)
      row.short_log = lf.get(maxlen=cfg.options.short_log_len, htmlize=1)
      debug.t_end("dirview_logformat")
    row.lockinfo = file.lockinfo
    row.anchor = request.server.escape(file.name)
    row.name = request.server.escape(file.name)
    row.pathtype = (file.kind == vclib.FILE and 'file') or \
                   (file.kind == vclib.DIR and 'dir')
    row.errors = file.errors

    if file.kind == vclib.DIR:
      if cfg.options.hide_cvsroot \
         and is_cvsroot_path(request.roottype,
                             request.path_parts + [file.name]):
        continue
    
      dirs_displayed += 1

      row.view_href = request.get_url(view_func=view_directory,
                                      where=where_prefix+file.name,
                                      pathtype=vclib.DIR,
                                      params={},
                                      escape=1)

      if request.roottype == 'svn':
        row.revision_href = request.get_url(view_func=view_revision,
                                            params={'revision': file.rev},
                                            escape=1)

      if request.roottype == 'cvs' and file.rev is not None:
        row.rev = None
        if cfg.options.show_logs:
          row.log_file = request.server.escape(file.newest_file)
          row.log_rev = file.rev

      if request.roottype == 'svn':
        row.log_href = request.get_url(view_func=view_log,
                                       where=where_prefix + file.name,
                                       pathtype=vclib.DIR,
                                       params={},
                                       escape=1)
      
    elif file.kind == vclib.FILE:
      if searchstr is not None:
        if request.roottype == 'cvs' and (file.errors or file.dead):
          continue
        if not search_file(request.repos, request.path_parts + [file.name],
                           request.pathrev, searchstr):
          continue
      if request.roottype == 'cvs' and file.dead:
        num_dead = num_dead + 1
        if hideattic:
          continue
        
      files_displayed += 1

      file_where = where_prefix + file.name
      if request.roottype == 'svn': 
        row.size = file.size

      row.mime_type, encoding = calculate_mime_type(request,
                                                    _path_parts(file_where),
                                                    file.rev)
      fvi = get_file_view_info(request, file_where, file.rev, row.mime_type)
      row.view_href = fvi.view_href
      row.download_href = fvi.download_href
      row.download_text_href = fvi.download_text_href
      row.annotate_href = fvi.annotate_href
      row.revision_href = fvi.revision_href
      row.prefer_markup = fvi.prefer_markup
      row.is_viewable_image = fvi.is_viewable_image
      row.is_binary = fvi.is_binary
      row.log_href = request.get_url(view_func=view_log,
                                     where=file_where,
                                     pathtype=vclib.FILE,
                                     params={},
                                     escape=1)
      if cfg.options.use_cvsgraph and request.roottype == 'cvs':
         row.graph_href = request.get_url(view_func=view_cvsgraph,
                                          where=file_where,
                                          pathtype=vclib.FILE,
                                          params={},
                                          escape=1)

    rows.append(row)
  debug.t_end("row-building")

  # Prepare the data that will be passed to the template, based on the
  # common template data.
  data = common_template_data(request)
  data.merge(TemplateData({
    'entries' : rows,
    'sortby' : sortby,
    'sortdir' : sortdir,
    'search_re' : request.server.escape(search_re),
    'dir_pagestart' : None,
    'sortby_file_href' :   request.get_url(params={'sortby': 'file',
                                                   'sortdir': None},
                                           escape=1),
    'sortby_rev_href' :    request.get_url(params={'sortby': 'rev',
                                                   'sortdir': None},
                                           escape=1),
    'sortby_date_href' :   request.get_url(params={'sortby': 'date',
                                                   'sortdir': None},
                                           escape=1),
    'sortby_author_href' : request.get_url(params={'sortby': 'author',
                                                   'sortdir': None},
                                           escape=1),
    'sortby_log_href' :    request.get_url(params={'sortby': 'log',
                                                   'sortdir': None},
                                           escape=1),
    'files_shown' : files_displayed,
    'dirs_shown' : dirs_displayed,
    'num_dead' : num_dead,
    'youngest_rev' : None,
    'youngest_rev_href' : None,
    'selection_form' : None,
    'attic_showing' : None,
    'show_attic_href' : None,
    'hide_attic_href' : None,
    'branch_tags': None,
    'plain_tags': None,
    'properties': get_itemprops(request, request.path_parts, request.pathrev),
    'tree_rev' : None,
    'tree_rev_href' : None,
    'dir_paging_action' : None,
    'dir_paging_hidden_values' : [],
    'search_re_action' : None,
    'search_re_hidden_values' : [],

    # Populated by paging()/paging_sws()
    'picklist' : [],
    'picklist_len' : 0,

    # Populated by pathrev_form()
    'pathrev_action' : None,
    'pathrev_hidden_values' : [],
    'pathrev_clear_action' : None,
    'pathrev_clear_hidden_values' : [],
    'pathrev' : None,
    'lastrev' : None,
  }))

  # clicking on sort column reverses sort order
  if sortdir == 'down':
    revsortdir = None # 'up'
  else:
    revsortdir = 'down'
  if sortby in ['file', 'rev', 'date', 'log', 'author']:
    data['sortby_%s_href' % sortby] = request.get_url(params={'sortdir':
                                                              revsortdir},
                                                      escape=1)
  # CVS doesn't support sorting by rev
  if request.roottype == "cvs":
    data['sortby_rev_href'] = None

  # set cvs-specific fields
  if request.roottype == 'cvs':
    plain_tags = options['cvs_tags']
    plain_tags.sort(icmp)
    plain_tags.reverse()
    data['plain_tags'] = []
    for plain_tag in plain_tags:
      data['plain_tags'].append(_item(name=plain_tag, revision=None))

    branch_tags = options['cvs_branches']
    branch_tags.sort(icmp)
    branch_tags.reverse()
    data['branch_tags'] = []
    for branch_tag in branch_tags:
      data['branch_tags'].append(_item(name=branch_tag, revision=None))
    
    data['attic_showing'] = ezt.boolean(not hideattic)
    data['show_attic_href'] = request.get_url(params={'hideattic': 0},
                                              escape=1)
    data['hide_attic_href'] = request.get_url(params={'hideattic': 1},
                                              escape=1)

  # set svn-specific fields
  elif request.roottype == 'svn':
    data['tree_rev'] = tree_rev
    data['tree_rev_href'] = request.get_url(view_func=view_revision,
                                            params={'revision': tree_rev},
                                            escape=1)
    data['youngest_rev'] = request.repos.get_youngest_revision()
    data['youngest_rev_href'] = request.get_url(view_func=view_revision,
                                                params={},
                                                escape=1)

  if cfg.options.dir_pagesize:
    data['dir_paging_action'], data['dir_paging_hidden_values'] = \
      request.get_form(params={'dir_pagestart': None})

  pathrev_form(request, data)

  if cfg.options.use_re_search:
    data['search_re_action'], data['search_re_hidden_values'] = \
      request.get_form(params={'search': None})

  if cfg.options.dir_pagesize:
    data['dir_pagestart'] = int(request.query_dict.get('dir_pagestart',0))
    data['entries'] = paging(data, 'entries', data['dir_pagestart'], 'name',
                             cfg.options.dir_pagesize)

  generate_page(request, "directory", data)
