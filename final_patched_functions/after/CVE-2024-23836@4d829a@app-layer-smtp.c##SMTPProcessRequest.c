static int SMTPProcessRequest(SMTPState *state, Flow *f,
                              AppLayerParserState *pstate)
{
    SCEnter();
    SMTPTransaction *tx = state->curr_tx;

    /* If current input is to be discarded because it completes a long line,
     * line's length and delimeter len are reset to 0. Skip processing this line.
     * This line is only to get us out of the state where we should discard any
     * data till LF. */
    if (state->current_line_len == 0 && state->current_line_delimiter_len == 0) {
        return 0;
    }
    if (state->curr_tx == NULL || (state->curr_tx->done && !NoNewTx(state))) {
        tx = SMTPTransactionCreate(state);
        if (tx == NULL)
            return -1;
        state->curr_tx = tx;
        TAILQ_INSERT_TAIL(&state->tx_list, tx, next);
        tx->tx_id = state->tx_cnt++;

        /* keep track of the start of the tx */
        state->toserver_last_data_stamp = state->toserver_data_count;
        StreamTcpReassemblySetMinInspectDepth(f->protoctx, STREAM_TOSERVER,
                smtp_config.content_inspect_min_size);
    }

    state->toserver_data_count += (
        state->current_line_len +
        state->current_line_delimiter_len);

    if (!(state->parser_state & SMTP_PARSER_STATE_FIRST_REPLY_SEEN)) {
        SMTPSetEvent(state, SMTP_DECODER_EVENT_NO_SERVER_WELCOME_MESSAGE);
    }

    /* there are 2 commands that can push it into this COMMAND_DATA mode -
     * STARTTLS and DATA */
    if (!(state->parser_state & SMTP_PARSER_STATE_COMMAND_DATA_MODE)) {
        int r = 0;

        if (state->current_line_len >= 8 &&
            SCMemcmpLowercase("starttls", state->current_line, 8) == 0) {
            state->current_command = SMTP_COMMAND_STARTTLS;
        } else if (state->current_line_len >= 4 &&
                   SCMemcmpLowercase("data", state->current_line, 4) == 0) {
            state->current_command = SMTP_COMMAND_DATA;
            if (state->curr_tx->is_data) {
                // We did not receive a confirmation from server
                // And now the sends a next DATA
                SMTPSetEvent(state, SMTP_DECODER_EVENT_UNPARSABLE_CONTENT);
                SCReturnInt(0);
            } else if (smtp_config.raw_extraction) {
                const char *msgname = "rawmsg"; /* XXX have a better name */
                if (state->files_ts == NULL)
                    state->files_ts = FileContainerAlloc();
                if (state->files_ts == NULL) {
                    return -1;
                }
                if (FileOpenFileWithId(state->files_ts, &smtp_config.sbcfg,
                        state->file_track_id++,
                        (uint8_t*) msgname, strlen(msgname), NULL, 0,
                        FILE_NOMD5|FILE_NOMAGIC|FILE_USE_DETECT) == 0) {
                    SMTPNewFile(state->curr_tx, state->files_ts->tail);
                }
            } else if (smtp_config.decode_mime) {
                DEBUG_VALIDATE_BUG_ON(tx->mime_state);
                tx->mime_state = MimeDecInitParser(f, SMTPProcessDataChunk);
                if (tx->mime_state == NULL) {
                    return MIME_DEC_ERR_MEM;
                }

                /* Add new MIME message to end of list */
                if (tx->msg_head == NULL) {
                    tx->msg_head = tx->mime_state->msg;
                    tx->msg_tail = tx->mime_state->msg;
                }
                else {
                    tx->msg_tail->next = tx->mime_state->msg;
                    tx->msg_tail = tx->mime_state->msg;
                }
            }
            state->curr_tx->is_data = true;
            /* Enter immediately data mode without waiting for server reply */
            if (state->parser_state & SMTP_PARSER_STATE_PIPELINING_SERVER) {
                state->parser_state |= SMTP_PARSER_STATE_COMMAND_DATA_MODE;
            }
        } else if (state->current_line_len >= 4 &&
                   SCMemcmpLowercase("bdat", state->current_line, 4) == 0) {
            r = SMTPParseCommandBDAT(state);
            if (r == -1) {
                SCReturnInt(-1);
            }
            state->current_command = SMTP_COMMAND_BDAT;
            state->parser_state |= SMTP_PARSER_STATE_COMMAND_DATA_MODE;
        } else if (state->current_line_len >= 4 &&
                   ((SCMemcmpLowercase("helo", state->current_line, 4) == 0) ||
                    SCMemcmpLowercase("ehlo", state->current_line, 4) == 0))  {
            r = SMTPParseCommandHELO(state);
            if (r == -1) {
                SCReturnInt(-1);
            }
            state->current_command = SMTP_COMMAND_OTHER_CMD;
        } else if (state->current_line_len >= 9 &&
                   SCMemcmpLowercase("mail from", state->current_line, 9) == 0) {
            r = SMTPParseCommandMAILFROM(state);
            if (r == -1) {
                SCReturnInt(-1);
            }
            state->current_command = SMTP_COMMAND_OTHER_CMD;
        } else if (state->current_line_len >= 7 &&
                   SCMemcmpLowercase("rcpt to", state->current_line, 7) == 0) {
            r = SMTPParseCommandRCPTTO(state);
            if (r == -1) {
                SCReturnInt(-1);
            }
            state->current_command = SMTP_COMMAND_OTHER_CMD;
        } else if (state->current_line_len >= 4 &&
                   SCMemcmpLowercase("rset", state->current_line, 4) == 0) {
            // Resets chunk index in case of connection reuse
            state->bdat_chunk_idx = 0;
            state->current_command = SMTP_COMMAND_RSET;
        } else {
            state->current_command = SMTP_COMMAND_OTHER_CMD;
        }

        /* Every command is inserted into a command buffer, to be matched
         * against reply(ies) sent by the server */
        if (SMTPInsertCommandIntoCommandBuffer(state->current_command,
                                               state, f) == -1) {
            SCReturnInt(-1);
        }

        SCReturnInt(r);
    }

    switch (state->current_command) {
        case SMTP_COMMAND_STARTTLS:
            return SMTPProcessCommandSTARTTLS(state, f, pstate);

        case SMTP_COMMAND_DATA:
            return SMTPProcessCommandDATA(state, f, pstate);

        case SMTP_COMMAND_BDAT:
            return SMTPProcessCommandBDAT(state, f, pstate);

        default:
            /* we have nothing to do with any other command at this instant.
             * Just let it go through */
            SCReturnInt(0);
    }
}
