bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {
   if(permitted().empty()) {
      return true;
   }

   const auto& alt_name = cert.subject_alt_name();

   if(reject_unknown) {
      if(m_permitted_name_types.find("URI") != m_permitted_name_types.end() && !alt_name.get_attribute("URI").empty()) {
         return false;
      }
      if(m_permitted_name_types.find("RFC822") != m_permitted_name_types.end() && !alt_name.get_attribute("RFC822").empty()) {
         return false;
      }
   }

   auto is_permitted_dn = [&](const X509_DN& dn) {
      // If no restrictions, then immediate accept
      if(m_permitted_name_types.find("DN") == m_permitted_name_types.end()) {
         return true;
      }

      if(dn.empty()) {
         return true;
      }

      for(const auto& c : m_permitted_subtrees) {
         if(c.base().type() == "DN" && c.base().matches_dn_obj(dn)) {
            return true;
         }
      }

      // There is at least one permitted name and we didn't match
      return false;
   };

   auto is_permitted_dns_name = [&](const std::string& name) {
      if(name.empty() || name[0] == '.') {
         return false;
      }

      // If no restrictions, then immediate accept
      if(m_permitted_name_types.find("DNS") == m_permitted_name_types.end()) {
         return true;
      }

      for(const auto& c : m_permitted_subtrees) {
         if(c.base().type() == "DNS" && c.base().matches_dns(name)) {
            return true;
         }
      }

      // There is at least one permitted name and we didn't match
      return false;
   };

   auto is_permitted_ipv4 = [&](const std::string& ipv4) {
      // If no restrictions, then immediate accept
      if(m_permitted_name_types.find("IP") == m_permitted_name_types.end()) {
         return true;
      }

      for(const auto& c : m_permitted_subtrees) {
         if(c.base().type() == "IP" && c.base().matches_ip(ipv4)) {
            return true;
         }
      }

      // There is at least one permitted name and we didn't match
      return false;
   };

   if(!is_permitted_dn(cert.subject_dn())) {
      return false;
   }

   if(!is_permitted_dn(alt_name.dn()))
      {
      return false;
      }

   for(const auto& alt_dns : alt_name.get_attribute("DNS")) {
      if(!is_permitted_dns_name(alt_dns)) {
         return false;
      }
   }

   for(const auto& alt_ipv4 : alt_name.get_attribute("IP")) {
      if(!is_permitted_ipv4(alt_ipv4)) {
         return false;
      }
   }

   if(!alt_name.has_items())
      {
      for(const auto& cn : cert.subject_info("Name"))
         {
         if(cn.find(".") != std::string::npos)
            {
            if(looks_like_ipv4(cn))
               {
               if(!is_permitted_ipv4(cn))
                  {
                  return false;
                  }
               }
            else
               {
               if(!is_permitted_dns_name(cn))
                  {
                  return false;
                  }
               }
            }
         }
      }

   // We didn't encounter a name that doesn't have a matching constraint
   return true;
}
