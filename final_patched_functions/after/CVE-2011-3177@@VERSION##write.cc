int IniParser::write()
{
    int bugs = 0;
    if (!inifile.isDirty())
    {
        y2debug ("File %s did not change. Not saving.", multiple_files ? files[0].c_str () : file.c_str ());
	return 0;
    }
    if (read_only)
    {
        y2debug ("Attempt to write file %s that was mounted read-only. Not saving.", multiple_files ? files[0].c_str () : file.c_str ());
	return 0;
    }
    UpdateIfModif ();

    if (multiple_files)
    {
	IniIterator
	    ci = inifile.getContainerBegin (),
	    ce = inifile.getContainerEnd ();

	for (;ci != ce; ++ci)
	    {
		if (ci->t () == SECTION)
		    {
			IniSection&s = ci->s ();
			int wb = s.getRewriteBy (); // bug #19066 
			string filename = getFileName (s.getName (), wb);

			// This is the only place where we unmark a
			// section for deletion - when it is a file
			// that got some data again. We can do it
			// because we only erase the files afterwards.
			deleted_sections.erase (filename);

			if (!s.isDirty ()) {
			    y2debug ("Skipping file %s that was not changed.", filename.c_str());
			    continue;
			}
			s.initReadBy ();
                        bugs += write_file(filename, s);
		    }
		else
		    {
			y2error ("Value %s encountered at multifile top level",
				 ci->e ().getName ());
		    }
	    }

	// FIXME: update time stamps of files...

	// erase removed files...
	for (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)
	    if (multi_files.find (*i) != multi_files.end ()) {
		y2debug ("Removing file %s\n", (*i).c_str());
		unlink ((*i).c_str());
	    }
    }
    else
    {
        bugs += write_file(file, inifile);
	timestamp = getTimeStamp ();
    }
    return bugs ? -1 : 0;
}
