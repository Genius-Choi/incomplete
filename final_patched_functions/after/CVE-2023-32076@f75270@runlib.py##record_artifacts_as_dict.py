def record_artifacts_as_dict(
    artifacts,
    exclude_patterns=None,
    base_path=None,
    follow_symlink_dirs=False,
    normalize_line_endings=False,
    lstrip_paths=None,
):
    """
    <Purpose>
      Hashes each file in the passed path list. If the path list contains
      paths to directories the directory tree(s) are traversed.

      The files a link command is executed on are called materials.
      The files that result form a link command execution are called
      products.

      Paths are normalized for matching and storing by left stripping "./"

      NOTE on exclude patterns:
        - Uses PathSpec to compile gitignore-style patterns, making use of the
          GitWildMatchPattern class (registered as 'gitwildmatch')

        - Patterns are checked for match against the full path relative to each
          path passed in the artifacts list

        - If a directory is excluded, all its files and subdirectories are also
          excluded

        - How it differs from .gitignore
              - No need to escape #
              - No ignoring of trailing spaces
              - No general negation with exclamation mark !
              - No special treatment of slash /
              - No special treatment of consecutive asterisks **

        - Exclude patterns are likely to become command line arguments or part of
          a config file.

    <Arguments>
      artifacts:
              A list of file or directory paths used as materials or products for
              the link command.

      exclude_patterns: (optional)
              Artifacts matched by the pattern are excluded from the result.
              Exclude patterns can be passed as argument or specified via
              ARTIFACT_EXCLUDE_PATTERNS setting (see `in_toto.settings`).
              If passed, patterns specified via settings are overriden.

      base_path: (optional)
              Change to base_path and record artifacts relative from there.
              If not passed, current working directory is used as base_path.
              NOTE: The base_path part of the recorded artifact is not included
              in the returned paths.

      follow_symlink_dirs: (optional)
              Follow symlinked dirs if the linked dir exists (default is False).
              The recorded path contains the symlink name, not the resolved name.
              NOTE: This parameter toggles following linked directories only,
              linked files are always recorded, independently of this parameter.
              NOTE: Beware of infinite recursions that can occur if a symlink
              points to a parent directory or itself.

      normalize_line_endings: (optional)
              If True, replaces windows and mac line endings with unix line
              endings before hashing the content of the passed files, for
              cross-platform support.

      lstrip_paths: (optional)
              If a prefix path is passed, the prefix is left stripped from
              the path of every artifact that contains the prefix.

    <Exceptions>
      OSError: cannot change to base path directory.
      ValueError: arguments are malformed.

    <Side Effects>
      Calls functions to generate cryptographic hashes.

    <Returns>
      A dictionary with file paths as keys and the files' hashes as values.

    """
    artifact_hashes = {}

    if not artifacts:
        return artifact_hashes

    if not base_path:
        base_path = in_toto.settings.ARTIFACT_BASE_PATH

    if not exclude_patterns:
        exclude_patterns = in_toto.settings.ARTIFACT_EXCLUDE_PATTERNS

    # Configure resolver with resolver specific arguments
    # FIXME: This should happen closer to the user boundary, where
    # resolver-specific config arguments are passed and global state is managed.
    RESOLVER_FOR_URI_SCHEME[FileResolver.SCHEME] = FileResolver(
        exclude_patterns,
        base_path,
        follow_symlink_dirs,
        normalize_line_endings,
        lstrip_paths,
    )

    # Configure resolver for OSTree
    RESOLVER_FOR_URI_SCHEME[OSTreeResolver.SCHEME] = OSTreeResolver(base_path)

    # Aggregate artifacts per resolver
    resolver_for_uris = defaultdict(list)
    for artifact in artifacts:
        resolver = Resolver.for_uri(artifact)
        resolver_for_uris[resolver].append(artifact)

    # Hash artifacts in a batch per resolver
    # FIXME: The behavior may change if we hash each artifact individually,
    # because the left-prefix duplicate check in FileResolver only works for the
    # artifacts hashed in one batch.
    for resolver, uris in resolver_for_uris.items():
        artifact_hashes.update(resolver.hash_artifacts(uris))

    # Clear resolvers to not preserve global state change beyond this function.
    # FIXME: This also clears resolver registered elsewhere. For now we
    # assume that we only modify RESOLVER_FOR_URI_SCHEME in this function.
    RESOLVER_FOR_URI_SCHEME.clear()

    return artifact_hashes
