int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,
			   sector_t block)
{
	struct mb2_cache_entry *entry, *dup;
	struct hlist_bl_node *dup_node;
	struct hlist_bl_head *head;

	entry = kmem_cache_alloc(mb2_entry_cache, mask);
	if (!entry)
		return -ENOMEM;

	INIT_LIST_HEAD(&entry->e_lru_list);
	/* One ref for hash, one ref returned */
	atomic_set(&entry->e_refcnt, 1);
	entry->e_key = key;
	entry->e_block = block;
	head = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];
	entry->e_hash_list_head = head;
	hlist_bl_lock(head);
	hlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {
		if (dup->e_key == key && dup->e_block == block) {
			hlist_bl_unlock(head);
			kmem_cache_free(mb2_entry_cache, entry);
			return -EBUSY;
		}
	}
	hlist_bl_add_head(&entry->e_hash_list, head);
	hlist_bl_unlock(head);

	spin_lock(&cache->c_lru_list_lock);
	list_add_tail(&entry->e_lru_list, &cache->c_lru_list);
	/* Grab ref for LRU list */
	atomic_inc(&entry->e_refcnt);
	cache->c_entry_count++;
	spin_unlock(&cache->c_lru_list_lock);

	return 0;
}
