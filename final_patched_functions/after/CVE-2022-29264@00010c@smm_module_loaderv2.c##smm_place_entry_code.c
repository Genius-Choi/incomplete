static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,
				unsigned int stack_top, const struct smm_loader_params *params)
{
	unsigned int i;
	unsigned int size;
	if (smm_create_map(smbase, num_cpus, params)) {
		/*
		 * Ensure there was enough space and the last CPUs smbase
		 * did not encroach upon the stack. Stack top is smram start
		 * + size of stack.
		 */
		if (cpus[num_cpus].active) {
			if (cpus[num_cpus - 1].smbase +
				params->smm_main_entry_offset < stack_top) {
				printk(BIOS_ERR, "%s: stack encroachment\n", __func__);
				printk(BIOS_ERR, "%s: smbase %zx, stack_top %x\n",
					__func__, cpus[num_cpus].smbase, stack_top);
				return 0;
			}
		}
	} else {
		printk(BIOS_ERR, "%s: unable to place smm entry code\n", __func__);
		return 0;
	}

	printk(BIOS_INFO, "%s: smbase %zx, stack_top %x\n",
		__func__, cpus[num_cpus-1].smbase, stack_top);

	/* start at 1, the first CPU stub code is already there */
	size = cpus[0].code_end - cpus[0].code_start;
	for (i = 1; i < num_cpus; i++) {
		memcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);
		printk(BIOS_DEBUG,
			"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\n",
			cpus[i].code_start, i);
		printk(BIOS_DEBUG, "%s: copying from %zx to %zx 0x%x bytes\n",
			__func__, cpus[0].code_start, cpus[i].code_start, size);
	}
	return 1;
}
