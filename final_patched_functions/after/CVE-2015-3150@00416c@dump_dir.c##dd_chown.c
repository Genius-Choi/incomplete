int dd_chown(struct dump_dir *dd, uid_t new_uid)
{
    if (!dd->locked)
        error_msg_and_die("dump_dir is not opened"); /* bug */

    struct stat statbuf;
    if (!(stat(dd->dd_dirname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode)))
    {
        perror_msg("stat('%s')", dd->dd_dirname);
        return 1;
    }

    struct passwd *pw = getpwuid(new_uid);
    if (!pw)
    {
        error_msg("UID %ld is not found in user database", (long)new_uid);
        return 1;
    }

#if DUMP_DIR_OWNED_BY_USER > 0
    uid_t owners_uid = pw->pw_uid;
    gid_t groups_gid = statbuf.st_gid;
#else
    uid_t owners_uid = statbuf.st_uid;
    gid_t groups_gid = pw->pw_gid;
#endif

    int chown_res = fchown(dd->dd_fd, owners_uid, groups_gid);
    if (chown_res)
        perror_msg("fchown('%s')", dd->dd_dirname);
    else
    {
        dd_init_next_file(dd);
        char *short_name;
        while (chown_res == 0 && dd_get_next_file(dd, &short_name, /*full_name*/ NULL))
        {
            /* The current process has to have read access at least */
            int fd = secure_openat_read(dd->dd_fd, short_name);
            if (fd < 0)
                goto next;

            log_debug("chowning %s", short_name);

            chown_res = fchown(fd, owners_uid, groups_gid);
            if (chown_res)
                perror_msg("fchownat('%s')", short_name);

            close(fd);
next:
            free(short_name);
        }
    }

    return chown_res;
}
