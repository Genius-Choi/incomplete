expand_command(struct eventlog *evlog, char **newbuf)
{
    size_t len, bufsize = strlen(evlog->command) + 1;
    char *cp, *buf;
    int ac;
    debug_decl(expand_command, SUDO_DEBUG_UTIL);

    if (evlog->argv == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {
	/* No arguments, we can use the command as-is. */
	*newbuf = NULL;
	debug_return_str(evlog->command);
    }

    /* Skip argv[0], we use evlog->command instead. */
    for (ac = 1; evlog->argv[ac] != NULL; ac++)
	bufsize += strlen(evlog->argv[ac]) + 1;

    if ((buf = malloc(bufsize)) == NULL)
	sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
    cp = buf;

    len = strlcpy(cp, evlog->command, bufsize);
    if (len >= bufsize)
	sudo_fatalx(U_("internal error, %s overflow"), __func__);
    cp += len;
    bufsize -= len;

    for (ac = 1; evlog->argv[ac] != NULL; ac++) {
	if (bufsize < 2)
	    sudo_fatalx(U_("internal error, %s overflow"), __func__);
	*cp++ = ' ';
	bufsize--;

	len = strlcpy(cp, evlog->argv[ac], bufsize);
	if (len >= bufsize)
	    sudo_fatalx(U_("internal error, %s overflow"), __func__);
	cp += len;
	bufsize -= len;
    }

    *newbuf = buf;
    debug_return_str(buf);
}
