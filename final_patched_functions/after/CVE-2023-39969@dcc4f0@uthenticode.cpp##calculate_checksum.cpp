std::optional<std::string> calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {
  auto nid = checksum_type_to_nid(kind);
  if (nid == NID_undef) {
    return {};
  }

  /* We'll stash the bits of the PE that we need to hash in this buffer.
   * Reserve the original PE's size upfront, since we expect the hashed data
   * to be only slightly smaller.
   */
  std::vector<std::uint8_t> pe_bits;
  pe_bits.reserve(pe->fileBuffer->bufLen);

  /* In both PEs and PE32+s, the PE checksum is 64 bytes into the optional header,
   * which itself is 24 bytes after the PE magic and COFF header from the offset
   * specified in the DOS header.
   */
  auto pe_checksum_offset = pe->peHeader.dos.e_lfanew + 24 + 64;

  /* The certificate table directory entry offset is also in the optional header,
   * albeit at different offsets for PE32 and PE32+. See each of the cases below.
   */
  std::size_t cert_table_offset = pe->peHeader.dos.e_lfanew + 24;
  std::uint32_t size_of_headers = 0;
  peparse::data_directory security_dir;
  if (pe->peHeader.nt.OptionalMagic == peparse::NT_OPTIONAL_32_MAGIC) {
    security_dir = pe->peHeader.nt.OptionalHeader.DataDirectory[peparse::DIR_SECURITY];
    size_of_headers = pe->peHeader.nt.OptionalHeader.SizeOfHeaders;
    cert_table_offset += 128;
  } else if (pe->peHeader.nt.OptionalMagic == peparse::NT_OPTIONAL_64_MAGIC) {
    security_dir = pe->peHeader.nt.OptionalHeader64.DataDirectory[peparse::DIR_SECURITY];
    size_of_headers = pe->peHeader.nt.OptionalHeader64.SizeOfHeaders;
    cert_table_offset += 144;
  } else {
    /* Mystical future PE version?
     */
    return {};
  }

  /* We explicitly don't support hashing files that don't contain a security
   * directory; not because we *can't*, but because doing so isn't well defined
   * in the Authenticode specification.
   */
  if (security_dir.VirtualAddress == 0) {
    return {};
  }

  /* "VirtualAddress" here is really an offset; an invalid one indicates a tampered input.
   * Similarly, a cert_table_offset beyond size_of_headers indicates a tampered input
   * (we get the pe_checksum_offset check for free, since it's always smaller).
   */
  if (security_dir.VirtualAddress + security_dir.Size > pe->fileBuffer->bufLen ||
      cert_table_offset + 8 > size_of_headers) {
    return {};
  }

  /* Copy everything up to the end of the headers into pe_bits.
   * Use a bounded_buffer to handle the range checks for us.
   */
  auto *header_buf = peparse::splitBuffer(pe->fileBuffer, 0, size_of_headers);
  if (header_buf == nullptr) {
    return {};
  }

  pe_bits.insert(pe_bits.begin(), header_buf->buf, header_buf->buf + header_buf->bufLen);
  delete header_buf;

  /* This won't happen under normal conditions, but could with a tampered input.
   * We don't have to check pe_checksum_offset here since it'll always be strictly less
   * than cert_table_offset.
   */
  if (pe_bits.size() <= cert_table_offset + 8) {
    return {};
  }

  /* Erase the PE checksum and certificate table entry from pe_bits.
   * Do the certificate table entry first, so that we don't have to rescale the checksum's offset.
   */
  pe_bits.erase(pe_bits.begin() + cert_table_offset, pe_bits.begin() + cert_table_offset + 8);
  pe_bits.erase(pe_bits.begin() + pe_checksum_offset, pe_bits.begin() + pe_checksum_offset + 4);

  struct iter_sec_ctx {
    impl::SectionList sections;
    uint32_t total_bytes_hashed;
  };

  impl::SectionList sections;
  uint32_t total_bytes_hashed = size_of_headers;
  iter_sec_ctx ctx = {sections, total_bytes_hashed};

  /* Build up the list of sections in the PE, in ascending order by PointerToRawData
   * (i.e., by file offset).
   *
   * NOTE(ww): Ideally we'd use a capture with the C++ lambda here, but C++ lambdas can't be
   * used within C callbacks unless they're captureless.
   */
  peparse::IterSec(
      pe,
      [](void *cbd,
         [[maybe_unused]] const peparse::VA &secBase,
         [[maybe_unused]] const std::string &sectionName,
         [[maybe_unused]] const peparse::image_section_header &sec,
         const peparse::bounded_buffer *b) -> int {
        auto &ctx = *static_cast<iter_sec_ctx *>(cbd);
        ctx.sections.emplace_back(b);
        ctx.total_bytes_hashed += sec.SizeOfRawData;
        return 0;
      },
      &ctx);

  /* Copy each section's data into pe_bits, in ascending order.
   */
  for (const auto &section : sections) {
    pe_bits.insert(pe_bits.end(), section->buf, section->buf + section->bufLen);
  }

  /* Also copy any data that happens to be trailing the certificate table into pe_bits.
   * Most PEs won't have any trailing data but the Authenticode specification is explicit about
   * hashing any if it exists.
   */
  auto file_size = pe->fileBuffer->bufLen;
  auto extra_data_size = file_size - (security_dir.Size + total_bytes_hashed);
  auto *trailer_buf = peparse::splitBuffer(
      pe->fileBuffer, total_bytes_hashed, total_bytes_hashed + extra_data_size);
  if (trailer_buf == nullptr) {
    return {};
  }
  pe_bits.insert(pe_bits.end(), trailer_buf->buf, trailer_buf->buf + trailer_buf->bufLen);
  delete trailer_buf;

  /* Finally, hash the damn thing.
   *
   * NOTE(ww): Instead of building up pe_bits and hashing it in one pass, we
   * could hash it incrementally with each section. This would also solve
   * the capture problem with the C++ callback above and would reduce
   * the number of needed allocations.
   */
  std::array<std::uint8_t, EVP_MAX_MD_SIZE> md_buf;
  const auto *md = EVP_get_digestbynid(nid);
  auto *md_ctx = EVP_MD_CTX_new();

  EVP_DigestInit(md_ctx, md);
  EVP_DigestUpdate(md_ctx, pe_bits.data(), pe_bits.size());
  EVP_DigestFinal(md_ctx, md_buf.data(), nullptr);
  EVP_MD_CTX_free(md_ctx);

  return tohex(md_buf.data(), EVP_MD_size(md));
}
