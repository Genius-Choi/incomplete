def parse_options_header(value: Union[str, bytes]) -> Tuple[bytes, Dict[bytes, bytes]]:
    """
    Parses a Content-Type header into a value in the following format:
        (content_type, {parameters})
    """
    # Uses email.message.Message to parse the header as described in PEP 594.
    # Ref: https://peps.python.org/pep-0594/#cgi
    if not value:
        return (b'', {})

    # If we are passed bytes, we assume that it conforms to WSGI, encoding in latin-1.
    if isinstance(value, bytes):  # pragma: no cover
        value = value.decode('latin-1')

    # For types
    assert isinstance(value, str), 'Value should be a string by now'

    # If we have no options, return the string as-is.
    if ";" not in value:
        return (value.lower().strip().encode('latin-1'), {})

    # Split at the first semicolon, to get our value and then options.
    # ctype, rest = value.split(b';', 1)
    message = Message()
    message['content-type'] = value
    params = message.get_params()
    # If there were no parameters, this would have already returned above
    assert params, 'At least the content type value should be present'
    ctype = params.pop(0)[0].encode('latin-1')
    options = {}
    for param in params:
        key, value = param
        # If the value is a filename, we need to fix a bug on IE6 that sends
        # the full file path instead of the filename.
        if key == 'filename':
            if value[1:3] == ':\\' or value[:2] == '\\\\':
                value = value.split('\\')[-1]
        options[key.encode('latin-1')] = value.encode('latin-1')
    return ctype, options
