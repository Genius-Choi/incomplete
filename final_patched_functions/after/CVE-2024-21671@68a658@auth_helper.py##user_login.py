def user_login(
    config: dict, username: str, password: str, mail: Mail
) -> tuple[dict | User, HTTPStatus]:
    """
    Returns user a message in case of failed login attempt.

    config: dict
        Dictionary with configuration settings
    username: str
        Username of user to be logged in
    password: str
        Password of user to be logged in
    mail: flask_mail.Mail
        An instance of the Flask mail class. Used to send email to user in case
        of too many failed login attempts.

    Returns
    -------
    :class:`~vantage6.server.model.user.User` or dict:
        User SQLAlchemy model if user is logged in, otherwise dictionary with
        error message
    HTTPStatus:
        Status code that the current request should return
    """
    log.info("Trying to login '%s'", username)
    failed_login_msg = "Failed to login"

    # check if username exists. If it does not, we continue anyway, to prevent
    # that an attacker can find out which usernames exist via a timing attack.
    # In that case, we fetch the first user as random user.
    username_exists = User.username_exists(username)
    random_username = User.get_first_user().username
    user = User.get_by_username(username) if username_exists \
        else User.get_by_username(random_username)

    password_policy = config.get("password_policy", {})
    max_failed_attempts = password_policy.get(
        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS
    )
    inactivation_time = password_policy.get(
        'inactivation_minutes', DEFAULT_INACTIVATION_MINUTES
    )

    is_blocked, min_rem = user.is_blocked(max_failed_attempts,
                                          inactivation_time)

    if user.check_password(password) and not is_blocked and username_exists:
        # Note: above the username_exists is checked to prevent that an
        # attacker happens to get the correct password for the random user
        # that is returned when the username does not exist. Note also that
        # the password is checked first to keep the timing equal for both.
        user.failed_login_attempts = 0
        user.save()
        return user, HTTPStatus.OK

    # Handle database updates required upon failed login in a separate thread
    # to ensure similar response times
    # pylint: disable=W0212
    t1 = Thread(target=__handle_failed_login, args=(
        current_app._get_current_object(), username_exists, username,
        password_policy, is_blocked, min_rem, mail, config,
        request.access_route[-1]
    ))
    t1.start()

    return {"msg": failed_login_msg}, HTTPStatus.UNAUTHORIZED
