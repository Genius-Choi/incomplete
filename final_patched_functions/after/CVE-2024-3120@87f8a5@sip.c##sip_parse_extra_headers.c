sip_parse_extra_headers(sip_msg_t *msg, const u_char *payload)
{
    regmatch_t pmatch[4];
    char warning[MAX_WARNING_SIZE];

     // Reason text
     if (regexec(&calls.reg_reason, (const char *)payload, 2, pmatch, 0) == 0) {
         msg->call->reasontxt = sng_malloc((int)pmatch[1].rm_eo - pmatch[1].rm_so + 1);
         strncpy(msg->call->reasontxt, (const char *)payload +  pmatch[1].rm_so, (int)pmatch[1].rm_eo - pmatch[1].rm_so);
     }

     // Warning code
     if (regexec(&calls.reg_warning, (const char *)payload, 2, pmatch, 0) == 0) {

        // Ensure the copy length does not exceed MAX_WARNING_SIZE - 1
        int warning_match_len = pmatch[1].rm_eo - pmatch[1].rm_so;
        if (warning_match_len > MAX_WARNING_SIZE - 1) {
            warning_match_len = MAX_WARNING_SIZE - 1;
        }
        strncpy(warning, (const char *)payload +  pmatch[1].rm_so, warning_match_len);
        warning[warning_match_len] = '\0'; // Ensuring null termination

        msg->call->warning = atoi(warning);
     }
}
