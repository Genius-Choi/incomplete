x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,
    enum rpki_policy policy, enum cert_type type)
{
	struct metadata_node *meta;
	struct defer_node *defer_separator;
	int ok;
	int error;

	meta = malloc(sizeof(struct metadata_node));
	if (meta == NULL)
		return pr_enomem();

	meta->uri = uri;
	uri_refget(uri);
	serial_numbers_init(&meta->serials);
	subjects_init(&meta->subjects);

	error = init_resources(x509, policy, type, &meta->resources);
	if (error)
		goto cleanup_subjects;

	error = init_level(stack, &meta->level); /* Does not need a revert */
	if (error)
		goto destroy_resources;

	defer_separator = create_separator();
	if (defer_separator == NULL) {
		error = pr_enomem();
		goto destroy_resources;
	}

	ok = sk_X509_push(stack->x509s, x509);
	if (ok <= 0) {
		error = val_crypto_err(
		    "Could not add certificate to trusted stack: %d", ok);
		goto destroy_separator;
	}

	SLIST_INSERT_HEAD(&stack->defers, defer_separator, next);
	SLIST_INSERT_HEAD(&stack->metas, meta, next);

	return 0;

destroy_separator:
	free(defer_separator);
destroy_resources:
	resources_destroy(meta->resources);
cleanup_subjects:
	subjects_cleanup(&meta->subjects, subject_cleanup);
	serial_numbers_cleanup(&meta->serials, serial_cleanup);
	uri_refput(meta->uri);
	free(meta);
	return error;
}
