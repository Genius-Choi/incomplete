static int cfInsertCommon(RedisModuleCtx *ctx, RedisModuleString *keystr, RedisModuleString **items,
                          size_t nitems, const CFInsertOptions *options) {
    RedisModuleKey *key = RedisModule_OpenKey(ctx, keystr, REDISMODULE_READ | REDISMODULE_WRITE);
    CuckooFilter *cf = NULL;
    int status = cfGetFilter(key, &cf);

    if (status == SB_EMPTY && options->autocreate) {
        if ((cf = cfCreate(key, options->capacity, CF_DEFAULT_BUCKETSIZE, CF_DEFAULT_MAX_ITERATIONS,
                           CF_DEFAULT_EXPANSION)) == NULL) {
            return RedisModule_ReplyWithError(ctx, "Could not create filter"); // LCOV_EXCL_LINE
        }
    } else if (status != SB_OK) {
        return RedisModule_ReplyWithError(ctx, statusStrerror(status));
    }

    if (cf->numFilters >= CFMaxExpansions) {
        // Ensure that adding new elements does not cause heavy expansion.
        // We might want to find a way to better distinguish legitimate from malicious
        // additions.
        return RedisModule_ReplyWithError(ctx, "Maximum expansions reached");
    }

    // See if we can add the element
    if (options->is_multi) {
        RedisModule_ReplyWithArray(ctx, nitems);
    }

    for (size_t ii = 0; ii < nitems; ++ii) {
        size_t elemlen;
        const char *elem = RedisModule_StringPtrLen(items[ii], &elemlen);
        CuckooHash hash = CUCKOO_GEN_HASH(elem, elemlen);
        CuckooInsertStatus insStatus;
        if (options->is_nx) {
            insStatus = CuckooFilter_InsertUnique(cf, hash);
        } else {
            insStatus = CuckooFilter_Insert(cf, hash);
        }
        switch (insStatus) {
        case CuckooInsert_Inserted:
            if (_is_resp3(ctx) && (!options->is_nx || !options->is_multi)) {
                // resp3 and CF.INSERT/CF.ADD/CF.ADDNX
                RedisModule_ReplyWithBool(ctx, 1);
            } else {
                // CF.INSERTNX or resp2
                RedisModule_ReplyWithLongLong(ctx, 1);
            }
            break;
        case CuckooInsert_Exists:
            if (_is_resp3(ctx) && (!options->is_nx || !options->is_multi)) {
                // resp3 and CF.ADDNX
                RedisModule_ReplyWithBool(ctx, 0);
            } else {
                // CF.INSERTNX or resp2
                RedisModule_ReplyWithLongLong(ctx, 0);
            }
            break;
        case CuckooInsert_NoSpace:
            if (!options->is_multi) {
                return RedisModule_ReplyWithError(ctx, "Filter is full");
            } else {
                if (_is_resp3(ctx) && !options->is_nx) {
                    // resp3 and CF.INSERT
                    RedisModule_ReplyWithBool(ctx, 0);
                } else {
                    // CF.INSERTNX or resp2
                    RedisModule_ReplyWithLongLong(ctx, -1);
                }
            }
            break;
        case CuckooInsert_MemAllocFailed:
            RedisModule_ReplyWithError(ctx, "Memory allocation failure"); // LCOV_EXCL_LINE
            break;
        default:
            break;
        }
    }

    RedisModule_ReplicateVerbatim(ctx);
    return REDISMODULE_OK;
}
