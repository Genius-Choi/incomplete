bool SecurityManager::discovered_participant(
        const ParticipantProxyData& participant_data)
{
    auto sentry = is_security_manager_initialized();
    if (!sentry)
    {
        return false;
    }

    // Early return when ParticipantSecurityInfo does not match
    auto& sec_attrs = participant_->security_attributes();
    if (!sec_attrs.match(participant_data.security_attributes_, participant_data.plugin_security_attributes_))
    {
        return false;
    }

    if (authentication_plugin_ == nullptr)
    {
        participant_->pdp()->notifyAboveRemoteEndpoints(participant_data, true);
        return true;
    }

    SecurityException exception;
    AuthenticationStatus auth_status = AUTHENTICATION_INIT;

    // Create or find information
    bool undiscovered = false;
    DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info;
    {
        std::lock_guard<shared_mutex> _(mutex_);

        auto map_ret = discovered_participants_.insert(
            std::make_pair(
                participant_data.m_guid,
                std::unique_ptr<DiscoveredParticipantInfo>(
                    new DiscoveredParticipantInfo(
                        auth_status,
                        participant_data))));

        undiscovered = map_ret.second;
        remote_participant_info = map_ret.first->second->get_auth();
    }

    bool notify_part_authorized = false;
    if (undiscovered && remote_participant_info)
    {
        // Configure the timed event but do not start it
        const GUID_t guid = participant_data.m_guid;
        remote_participant_info->event_.reset(new TimedEvent(participant_->getEventResource(),
                [&, guid]() -> bool
                {
                    resend_handshake_message_token(guid);
                    return true;
                },
                DiscoveredParticipantInfo::INITIAL_RESEND_HANDSHAKE_MILLISECS)); // TODO (Ricardo) Configurable

        IdentityHandle* remote_identity_handle = nullptr;

        // Validate remote participant.
        ValidationResult_t validation_ret = authentication_plugin_->validate_remote_identity(&remote_identity_handle,
                        *local_identity_handle_,
                        participant_data.identity_token_,
                        participant_data.m_guid, exception);

        switch (validation_ret)
        {
            case VALIDATION_OK:
                assert(remote_identity_handle != nullptr);
                auth_status = AUTHENTICATION_OK;
                break;
            case VALIDATION_PENDING_HANDSHAKE_REQUEST:
                assert(remote_identity_handle != nullptr);
                auth_status = AUTHENTICATION_REQUEST_NOT_SEND;
                break;
            case VALIDATION_PENDING_HANDSHAKE_MESSAGE:
                assert(remote_identity_handle != nullptr);
                auth_status = AUTHENTICATION_WAITING_REQUEST;
                break;
            case VALIDATION_PENDING_RETRY:
            // TODO(Ricardo) Send event.
            default:

                on_validation_failed(participant_data, exception);

                std::lock_guard<shared_mutex> _(mutex_);

                // Remove created element, because authentication failed.
                discovered_participants_.erase(participant_data.m_guid);

                //TODO(Ricardo) cryptograhy registration in AUTHENTICAITON_OK
                return false;
        }

        EPROSIMA_LOG_INFO(SECURITY, "Discovered participant " << participant_data.m_guid);

        // Match entities
        match_builtin_endpoints(participant_data);

        // Store new remote handle.
        remote_participant_info->auth_status_ = auth_status;
        remote_participant_info->identity_handle_ = remote_identity_handle;

        // TODO(Ricardo) Start cryptography if authentication ok in this point.
        // If authentication is successful, inform user about it.
        if (auth_status == AUTHENTICATION_OK)
        {
            //TODO(Ricardo) Shared secret on this case?
            std::shared_ptr<SecretHandle> ss;
            notify_part_authorized = participant_authorized(participant_data, remote_participant_info, ss);
        }
    }
    else
    {
        // If cannot retrieve the authentication info pointer then return, because
        // it is used in other thread.
        if (!remote_participant_info)
        {
            return false;
        }
    }

    bool returnedValue = true;

    if (remote_participant_info->auth_status_ == AUTHENTICATION_REQUEST_NOT_SEND)
    {
        // Maybe send request.
        returnedValue = on_process_handshake(participant_data, remote_participant_info,
                        MessageIdentity(), HandshakeMessageToken(), notify_part_authorized);
    }

    restore_discovered_participant_info(participant_data.m_guid, remote_participant_info);

    if (notify_part_authorized)
    {
        notify_participant_authorized(participant_data);
    }

    return returnedValue;
}
