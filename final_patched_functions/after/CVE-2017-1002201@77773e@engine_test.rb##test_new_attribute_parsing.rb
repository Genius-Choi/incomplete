  def test_new_attribute_parsing
    assert_equal("<a a2='b2'>bar</a>\n", render("%a(a2=b2) bar", :locals => {:b2 => 'b2'}))
    assert_equal(%Q{<a a='foo"bar'>bar</a>\n}, render(%q{%a(a="#{'foo"bar'}") bar})) #'
    assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\n}, render(%q{%a(a="#{"foo'bar"}") bar})) #'
    assert_equal(%Q{<a a='foo"bar'>bar</a>\n}, render(%q{%a(a='foo"bar') bar}))
    assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\n}, render(%q{%a(a="foo'bar") bar}))
    assert_equal("<a a:b='foo'>bar</a>\n", render("%a(a:b='foo') bar"))
    assert_equal("<a a='foo' b='bar'>bar</a>\n", render("%a(a = 'foo' b = 'bar') bar"))
    assert_equal("<a a='foo' b='bar'>bar</a>\n", render("%a(a = foo b = bar) bar", :locals => {:foo => 'foo', :bar => 'bar'}))
    assert_equal("<a a='foo'>(b='bar')</a>\n", render("%a(a='foo')(b='bar')"))
    assert_equal("<a a='foo)bar'>baz</a>\n", render("%a(a='foo)bar') baz"))
    assert_equal("<a a='foo'>baz</a>\n", render("%a( a = 'foo' ) baz"))
  end

  def test_new_attribute_escaping
    assert_equal(%Q{<a a='foo " bar'>bar</a>\n}, render(%q{%a(a="foo \" bar") bar}))
    assert_equal(%Q{<a a='foo \\" bar'>bar</a>\n}, render(%q{%a(a="foo \\\\\" bar") bar}))

    assert_equal(%Q{<a a='foo &#039; bar'>bar</a>\n}, render(%q{%a(a='foo \' bar') bar}))
    assert_equal(%Q{<a a='foo \\&#039; bar'>bar</a>\n}, render(%q{%a(a='foo \\\\\' bar') bar}))

    assert_equal(%Q{<a a='foo \\ bar'>bar</a>\n}, render(%q{%a(a="foo \\\\ bar") bar}))
    assert_equal(%Q{<a a='foo \#{1 + 1} bar'>bar</a>\n}, render(%q{%a(a="foo \#{1 + 1} bar") bar}))
  end

  def test_multiline_new_attribute
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a(a='b'\n  c='d') bar"))
    assert_equal("<a a='b' b='c' c='d' d='e' e='f' f='j'>bar</a>\n",
      render("%a(a='b' b='c'\n  c='d' d=e\n  e='f' f='j') bar", :locals => {:e => 'e'}))
  end

  def test_new_and_old_attributes
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a(a='b'){:c => 'd'} bar"))
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a{:c => 'd'}(a='b') bar"))
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a(c='d'){:a => 'b'} bar"))
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a{:a => 'b'}(c='d') bar"))

    # Old-style always takes precedence over new-style,
    # because theoretically old-style could have arbitrary end-of-method-call syntax.
    assert_equal("<a a='b'>bar</a>\n", render("%a{:a => 'b'}(a='d') bar"))
    assert_equal("<a a='b'>bar</a>\n", render("%a(a='d'){:a => 'b'} bar"))

    assert_equal("<a a='b' b='c' c='d' d='e'>bar</a>\n",
      render("%a{:a => 'b',\n:b => 'c'}(c='d'\nd='e') bar"))

    locals = {:b => 'b', :d => 'd'}
    assert_equal("<p a='b' c='d'></p>\n", render("%p{:a => b}(c=d)", :locals => locals))
    assert_equal("<p a='b' c='d'></p>\n", render("%p(a=b){:c => d}", :locals => locals))

    assert_equal("<p id='b_d'></p>\n<p id='b_d'></p>\n", render("%p(id=b){id:d}\n%p(id=b){id:d}", locals: locals))
  end

  # Ruby Multiline

  def test_silent_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
bar, baz, bang
<p>foo</p>
HTML
- foo = ["bar",
         "baz",
         "bang"]
= foo.join(", ")
%p foo
HAML
  end

  def test_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
bar, baz, bang
<p>foo</p>
<p>bar</p>
HTML
= ["bar",
   "baz",
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_with_punctuated_methods_is_continuation
    assert_equal(<<HTML, render(<<HAML))
bar, , true, bang
<p>foo</p>
<p>bar</p>
HTML
= ["bar",
   "  ".strip!,
   "".empty?,
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_character_literals_are_not_continuation
    html = ",\n,\n<p>foo</p>\n"
    assert_equal(html, render(<<HAML))
= ?,
= ?\,
%p foo
HAML
  end

  def test_escaped_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
bar&lt;, baz, bang
<p>foo</p>
<p>bar</p>
HTML
&= ["bar<",
    "baz",
    "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_unescaped_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML, :escape_html => true))
bar<, baz, bang
<p>foo</p>
<p>bar</p>
HTML
!= ["bar<",
    "baz",
    "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_flattened_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
<pre>bar&#x000A;baz&#x000A;bang</pre>
<p>foo</p>
<p>bar</p>
HTML
~ "<pre>" + ["bar",
             "baz",
             "bang"].join("\\n") + "</pre>"
%p foo
%p bar
HAML
  end

  def test_loud_ruby_multiline_with_block
    assert_equal(<<HTML, render(<<HAML))
#{%w[far faz fang]}<p>foo</p>
<p>bar</p>
HTML
= ["bar",
   "baz",
   "bang"].map do |str|
  - str.gsub("ba",
             "fa")
%p foo
%p bar
HAML
  end

  def test_silent_ruby_multiline_with_block
    assert_equal(<<HTML, render(<<HAML))
far
faz
fang
<p>foo</p>
<p>bar</p>
HTML
- ["bar",
   "baz",
   "bang"].map do |str|
  = str.gsub("ba",
             "fa")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_in_tag
    assert_equal(<<HTML, render(<<HAML))
<p>foo, bar, baz</p>
<p>foo</p>
<p>bar</p>
HTML
%p= ["foo",
     "bar",
     "baz"].join(", ")
%p foo
%p bar
HAML
  end

  def test_escaped_ruby_multiline_in_tag
    assert_equal(<<HTML, render(<<HAML))
<p>foo&lt;, bar, baz</p>
<p>foo</p>
<p>bar</p>
HTML
%p&= ["foo<",
      "bar",
      "baz"].join(", ")
%p foo
%p bar
HAML
  end

  def test_unescaped_ruby_multiline_in_tag
    assert_equal(<<HTML, render(<<HAML, :escape_html => true))
<p>foo<, bar, baz</p>
<p>foo</p>
<p>bar</p>
HTML
%p!= ["foo<",
      "bar",
      "baz"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_with_normal_multiline
    assert_equal(<<HTML, render(<<HAML))
foobarbar, baz, bang
<p>foo</p>
<p>bar</p>
HTML
= "foo" + |
  "bar" + |
  ["bar", |
   "baz",
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_after_filter
    assert_equal(<<HTML, render(<<HAML))
foo
bar
bar, baz, bang
<p>foo</p>
<p>bar</p>
HTML
:plain
  foo
  bar
= ["bar",
   "baz",
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  # Encodings

  def test_utf_8_bom
    assert_equal <<HTML, render(<<HAML)
<div class='foo'>
<p>baz</p>
</div>
HTML
\xEF\xBB\xBF.foo
  %p baz
HAML
  end

  def test_default_encoding
    assert_equal(Encoding.find("utf-8"), render(<<HAML.encode("us-ascii")).encoding)
%p bar
%p foo
HAML
  end

  def test_fake_ascii_encoding
    assert_encoded_equal(<<HTML.force_encoding("ascii-8bit"), render(<<HAML, :encoding => "ascii-8bit"))
<p>bâr</p>
<p>föö</p>
HTML
%p bâr
%p föö
HAML
  end

  def test_convert_template_render_proc
    assert_converts_template_properly {|e| e.render_proc.call}
  end

  def test_convert_template_render
    assert_converts_template_properly {|e| e.render}
  end

  def test_convert_template_def_method
    assert_converts_template_properly do |e|
      o = Object.new
      e.def_method(o, :render)
      o.render
    end
  end

  def test_encoding_error
    render("foo\nbar\nb\xFEaz".force_encoding("utf-8"))
    assert(false, "Expected exception")
  rescue Haml::Error => e
    assert_equal(3, e.line)
    assert_match(/Invalid .* character/, e.message)
  end

  def test_ascii_incompatible_encoding_error
    template = "foo\nbar\nb_z".encode("utf-16le")
    template[9] = "\xFE".force_encoding("utf-16le")
    render(template)
    assert(false, "Expected exception")
  rescue Haml::Error => e
    assert_equal(3, e.line)
    assert_match(/Invalid .* character/, e.message)
  end

  def test_same_coding_comment_as_encoding
    assert_renders_encoded(<<HTML, <<HAML)
<p>bâr</p>
<p>föö</p>
HTML
-# coding: utf-8
%p bâr
%p föö
HAML
  end

  def test_coding_comments
    assert_valid_encoding_comment("-# coding: ibm866")
    assert_valid_encoding_comment("-# CodINg: IbM866")
    assert_valid_encoding_comment("-#coding:ibm866")
    assert_valid_encoding_comment("-# CodINg= ibm866")
    assert_valid_encoding_comment("-# foo BAR FAOJcoding: ibm866")
    assert_valid_encoding_comment("-# coding: ibm866 ASFJ (&(&#!$")
    assert_valid_encoding_comment("-# -*- coding: ibm866")
    assert_valid_encoding_comment("-# coding: ibm866 -*- coding: blah")
    assert_valid_encoding_comment("-# -*- coding: ibm866 -*-")
    assert_valid_encoding_comment("-# -*- encoding: ibm866 -*-")
    assert_valid_encoding_comment('-# -*- coding: "ibm866" -*-')
    assert_valid_encoding_comment("-#-*-coding:ibm866-*-")
    assert_valid_encoding_comment("-#-*-coding:ibm866-*-")
    assert_valid_encoding_comment("-# -*- foo: bar; coding: ibm866; baz: bang -*-")
    assert_valid_encoding_comment("-# foo bar coding: baz -*- coding: ibm866 -*-")
    assert_valid_encoding_comment("-# -*- coding: ibm866 -*- foo bar coding: baz")
  end

  def test_different_coding_than_system
    assert_renders_encoded(<<HTML.encode("IBM866"), <<HAML.encode("IBM866"))
<p>тАЬ</p>
HTML
%p тАЬ
HAML
  end

  def test_block_spacing
    begin
      assert render(<<-HAML)
- foo = ["bar", "baz", "kni"]
- foo.each do | item |
  = item
HAML
    rescue ::SyntaxError
      flunk("Should not have raised syntax error")
    end
  end

  def test_tracing
    result = render('%p{:class => "hello"}', :trace => true, :filename => 'foo').strip
    assert_equal "<p class='hello' data-trace='foo:1'></p>", result
  end

  private

  def assert_valid_encoding_comment(comment)
    assert_renders_encoded(<<HTML.encode("IBM866"), <<HAML.encode("IBM866").force_encoding("UTF-8"))
<p>ЖЛЫ</p>
<p>тАЬ</p>
HTML
#{comment}
%p ЖЛЫ
%p тАЬ
HAML
  end

  def assert_converts_template_properly
    engine = Haml::Engine.new(<<HAML.encode("iso-8859-1"), :encoding => "macRoman")
%p bâr
%p föö
HAML
    assert_encoded_equal(<<HTML.encode("macRoman"), yield(engine))
<p>bâr</p>
<p>föö</p>
HTML
  end

  def assert_renders_encoded(html, haml)
    result = render(haml)
    assert_encoded_equal html, result
  end

  def assert_encoded_equal(expected, actual)
    assert_equal expected.encoding, actual.encoding
    assert_equal expected, actual
  end
end
