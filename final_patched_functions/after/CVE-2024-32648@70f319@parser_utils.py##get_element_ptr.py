def get_element_ptr(parent, key, pos, array_bounds_check=True):
    # TODO rethink this circular import
    from vyper.old_codegen.abi import abi_type_of

    typ, location = parent.typ, parent.location

    def _abi_helper(member_t, ofst, clamp=True):
        member_abi_t = abi_type_of(member_t)
        ofst_lll = _add_ofst(parent, ofst)

        if member_abi_t.is_dynamic():
            # double dereference, according to ABI spec
            # TODO optimize special case: first dynamic item
            # offset is statically known.
            ofst_lll = _add_ofst(parent, unwrap_location(ofst_lll))

        x = LLLnode.from_list(
            ["ofst"], typ=member_t, location=parent.location, annotation=f"&({typ}->{member_t})"
        )

        if clamp and _needs_clamp(member_t, parent.encoding):
            # special handling for unsanitized external data that need clamping
            # TODO optimize me. this results in a double dereference because
            # it returns a pointer and not a value. probably the best thing
            # is to move the clamp to make_setter
            ret = ["with", x, ofst_lll, ["seq", clamp_basetype(x), x]]
        else:
            ret = ofst_lll

        return LLLnode.from_list(
            ret,
            typ=member_t,
            location=parent.location,
            encoding=parent.encoding,
            pos=pos,
            # annotation=f"({parent.typ})[{key.typ}]",
        )

    if isinstance(typ, TupleLike):
        if isinstance(typ, StructType):
            subtype = typ.members[key]
            attrs = list(typ.tuple_keys())
            index = attrs.index(key)
            annotation = key
        else:
            attrs = list(range(len(typ.members)))
            index = key
            annotation = None

        # generated by empty()
        if parent.value is None:
            return LLLnode.from_list(None, typ=subtype)

        if parent.value == "multi":
            assert parent.encoding != Encoding.ABI, "no abi-encoded literals"
            return parent.args[index]

        if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):
            if parent.location == "storage":
                raise CompilerPanic("storage variables should not be abi encoded")

            # parent_abi_t = abi_type_of(parent.typ)
            member_t = typ.members[attrs[index]]

            ofst = 0  # offset from parent start

            for i in range(index):
                member_abi_t = abi_type_of(typ.members[attrs[i]])
                ofst += member_abi_t.embedded_static_size()

            return _abi_helper(member_t, ofst)

        if location == "storage":
            # for arrays and structs, calculate the storage slot by adding an offset
            # of [index value being accessed] * [size of each item within the sequence]
            offset = 0
            for i in range(index):
                offset += get_size_of_type(typ.members[attrs[i]])
            return LLLnode.from_list(
                ["add", parent, offset], typ=subtype, location="storage", pos=pos,
            )

        elif location in ("calldata", "memory", "code"):
            offset = 0
            for i in range(index):
                offset += 32 * get_size_of_type(typ.members[attrs[i]])
            return LLLnode.from_list(
                _add_ofst(parent, offset),
                typ=typ.members[key],
                location=location,
                annotation=annotation,
                pos=pos,
            )

    elif isinstance(typ, ListType) and is_base_type(key.typ, ("int128", "int256", "uint256")):
        subtype = typ.subtype

        if parent.value is None:
            return LLLnode.from_list(None, typ=subtype)

        k = unwrap_location(key)
        if not array_bounds_check:
            sub = k
        elif key.typ.is_literal:  # note: BaseType always has is_literal attr
            # perform the check at compile time and elide the runtime check.
            if key.value < 0 or key.value >= typ.count:
                return
            sub = k
        else:
            # this works, even for int128. for int128, since two's-complement
            # is used, if the index is negative, (unsigned) LT will interpret
            # it as a very large number, larger than any practical value for
            # an array index, and the clamp will throw an error.
            sub = ["uclamplt", k, typ.count]

        if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):
            if parent.location == "storage":
                raise CompilerPanic("storage variables should not be abi encoded")

            member_t = typ.subtype
            member_abi_t = abi_type_of(member_t)

            if key.typ.is_literal:
                # TODO this constant folding in LLL optimizer
                ofst = k.value * member_abi_t.embedded_static_size()
            else:
                ofst = ["mul", k, member_abi_t.embedded_static_size()]

            return _abi_helper(member_t, ofst)

        if location == "storage":
            # storage slot determined as [initial storage slot] + [index] * [size of base type]
            offset = get_size_of_type(subtype)
            return LLLnode.from_list(
                ["add", parent, ["mul", sub, offset]], typ=subtype, location="storage", pos=pos
            )
        elif location in ("calldata", "memory", "code"):
            offset = 32 * get_size_of_type(subtype)
            return LLLnode.from_list(
                ["add", ["mul", offset, sub], parent], typ=subtype, location=location, pos=pos
            )

    elif isinstance(typ, MappingType):
        sub = None
        if isinstance(key.typ, ByteArrayLike):
            # CMC 20210916 pretty sure this is dead code. TODO double check
            if isinstance(typ.keytype, ByteArrayLike) and (typ.keytype.maxlen >= key.typ.maxlen):
                subtype = typ.valuetype
                if len(key.args[0].args) >= 3:  # handle bytes literal.
                    sub = LLLnode.from_list(
                        [
                            "seq",
                            key,
                            [
                                "sha3",
                                ["add", key.args[0].args[-1], 32],
                                ["mload", key.args[0].args[-1]],
                            ],
                        ]
                    )
                else:
                    value = key.args[0].value
                    if value == "add":
                        # special case, key is a bytes array within a tuple/struct
                        value = key.args[0]
                    sub = LLLnode.from_list(["sha3", ["add", value, 32], key])
        else:
            subtype = typ.valuetype
            sub = unwrap_location(key)

        if sub is not None and location == "storage":
            return LLLnode.from_list(["sha3_64", parent, sub], typ=subtype, location="storage")
