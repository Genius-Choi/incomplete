def recipe_from_source(request):
    """
    function to retrieve a recipe from a given url or source string
    :param request: standard request with additional post parameters
            - url: url to use for importing recipe
            - data: if no url is given recipe is imported from provided source data
            - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes
    :return: JsonResponse containing the parsed json, original html,json and images
    """
    if request.method == 'GET':
        return HttpResponse(status=405)
    request_payload = json.loads(request.body.decode('utf-8'))
    url = request_payload.get('url', None)
    data = request_payload.get('data', None)
    bookmarklet = request_payload.get('bookmarklet', None)

    if bookmarklet := BookmarkletImport.objects.filter(pk=bookmarklet).first():
        url = bookmarklet.url
        data = bookmarklet.html
        bookmarklet.delete()

    # headers to use for request to external sites
    external_request_headers = {"User-Agent": "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.7) Gecko/2009021910 Firefox/3.0.7"}

    if not url and not data:
        return JsonResponse({
            'error': True,
            'msg': _('Nothing to do.')
        }, status=400)

    # in manual mode request complete page to return it later
    if url:
        try:
            if validators.url(url, public=True):
                data = requests.get(url, headers=external_request_headers).content
            else:
                return JsonResponse({
                    'error': True,
                    'msg': _('Invalid Url')
                }, status=400)
        except requests.exceptions.ConnectionError:
            return JsonResponse({
                'error': True,
                'msg': _('Connection Refused.')
            }, status=400)
        except requests.exceptions.MissingSchema:
            return JsonResponse({
                'error': True,
                'msg': _('Bad URL Schema.')
            }, status=400)

    recipe_json, recipe_tree, recipe_html, recipe_images = get_recipe_from_source(data, url, request)
    if len(recipe_tree) == 0 and len(recipe_json) == 0:
        return JsonResponse({
            'error': True,
            'msg': _('No usable data could be found.')
        }, status=400)
    else:
        return JsonResponse({
            'recipe_json': recipe_json,
            'recipe_tree': recipe_tree,
            'recipe_html': recipe_html,
            'recipe_images': list(dict.fromkeys(recipe_images)),
        })
