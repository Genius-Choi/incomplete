int VP8LBuildHuffmanTable(HuffmanTables* const root_table, int root_bits,
                          const int code_lengths[], int code_lengths_size) {
  const int total_size =
      BuildHuffmanTable(NULL, root_bits, code_lengths, code_lengths_size, NULL);
  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);
  if (total_size == 0 || root_table == NULL) return total_size;

  if (root_table->curr_segment->curr_table + total_size >=
      root_table->curr_segment->start + root_table->curr_segment->size) {
    // If 'root_table' does not have enough memory, allocate a new segment.
    // The available part of root_table->curr_segment is left unused because we
    // need a contiguous buffer.
    const int segment_size = root_table->curr_segment->size;
    struct HuffmanTablesSegment* next =
        (HuffmanTablesSegment*)WebPSafeMalloc(1, sizeof(*next));
    if (next == NULL) return 0;
    // Fill the new segment.
    // We need at least 'total_size' but if that value is small, it is better to
    // allocate a big chunk to prevent more allocations later. 'segment_size' is
    // therefore chosen (any other arbitrary value could be chosen).
    next->size = total_size > segment_size ? total_size : segment_size;
    next->start =
        (HuffmanCode*)WebPSafeMalloc(next->size, sizeof(*next->start));
    if (next->start == NULL) {
      WebPSafeFree(next);
      return 0;
    }
    next->curr_table = next->start;
    next->next = NULL;
    // Point to the new segment.
    root_table->curr_segment->next = next;
    root_table->curr_segment = next;
  }
  if (code_lengths_size <= SORTED_SIZE_CUTOFF) {
    // use local stack-allocated array.
    uint16_t sorted[SORTED_SIZE_CUTOFF];
    BuildHuffmanTable(root_table->curr_segment->curr_table, root_bits,
                      code_lengths, code_lengths_size, sorted);
  } else {  // rare case. Use heap allocation.
    uint16_t* const sorted =
        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));
    if (sorted == NULL) return 0;
    BuildHuffmanTable(root_table->curr_segment->curr_table, root_bits,
                      code_lengths, code_lengths_size, sorted);
    WebPSafeFree(sorted);
  }
  return total_size;
}
