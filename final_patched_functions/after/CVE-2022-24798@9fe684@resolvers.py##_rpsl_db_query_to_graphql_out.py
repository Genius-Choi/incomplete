def _rpsl_db_query_to_graphql_out(query: RPSLDatabaseQuery, info: GraphQLResolveInfo):
    """
    Given an RPSL database query, execute it and clean up the output
    to be suitable to return to GraphQL.

    Main changes are:
    - Enum handling
    - Adding the asn and prefix fields if applicable
    - Ensuring the right fields are returned as a list of strings or a string
    """
    database_handler = info.context['request'].app.state.database_handler
    if info.context.get('sql_trace'):
        if 'sql_queries' not in info.context:
            info.context['sql_queries'] = [repr(query)]
        else:
            info.context['sql_queries'].append(repr(query))

    for row in database_handler.execute_query(query, refresh_on_error=True):
        graphql_result = {snake_to_camel_case(k): v for k, v in row.items() if k != 'parsed_data'}
        if 'object_text' in row:
            graphql_result['objectText'] = remove_auth_hashes(row['object_text'])
        if 'rpki_status' in row:
            graphql_result['rpkiStatus'] = row['rpki_status']
        if row.get('ip_first') is not None and row.get('prefix_length'):
            graphql_result['prefix'] = row['ip_first'] + '/' + str(row['prefix_length'])
        if row.get('asn_first') is not None and row.get('asn_first') == row.get('asn_last'):
            graphql_result['asn'] = row['asn_first']

        object_type = resolve_rpsl_object_type(row)
        for key, value in row.get('parsed_data', dict()).items():
            if key == 'auth':
                value = [remove_auth_hashes(v) for v in value]
            graphql_type = schema.graphql_types[object_type][key]
            if graphql_type == 'String' and isinstance(value, list):
                value = '\n'.join(value)
            graphql_result[snake_to_camel_case(key)] = value
        yield graphql_result
