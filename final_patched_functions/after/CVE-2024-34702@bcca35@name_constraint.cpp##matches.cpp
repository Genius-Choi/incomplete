GeneralName::MatchResult GeneralName::matches(const X509_Certificate& cert) const {
   class MatchScore final {
      public:
         MatchScore() : m_any(false), m_some(false), m_all(true) {}

         void add(bool m) {
            m_any = true;
            m_some |= m;
            m_all &= m;
         }

         MatchResult result() const {
            if(!m_any) {
               return MatchResult::NotFound;
            } else if(m_all) {
               return MatchResult::All;
            } else if(m_some) {
               return MatchResult::Some;
            } else {
               return MatchResult::None;
            }
         }

      private:
         bool m_any;
         bool m_some;
         bool m_all;
   };

   const X509_DN& dn = cert.subject_dn();
   const AlternativeName& alt_name = cert.subject_alt_name();

   MatchScore score;

   if(m_type == NameType::DNS) {
      const auto& constraint = std::get<1>(m_names);

      const auto& alt_names = alt_name.dns();

      for(const std::string& dns : alt_names) {
         score.add(matches_dns(dns, constraint));
      }

      if(alt_names.empty()) {
         // Check CN instead...
         for(const std::string& cn : dn.get_attribute("CN")) {
            score.add(matches_dns(cn, constraint));
         }
      }
   } else if(m_type == NameType::DN) {
      const X509_DN& constraint = std::get<3>(m_names);
      score.add(matches_dn(dn, constraint));

      for(const auto& alt_dn : alt_name.directory_names()) {
         score.add(matches_dn(alt_dn, constraint));
      }
   } else if(m_type == NameType::IPv4) {
      auto [net, mask] = std::get<4>(m_names);

      for(uint32_t ipv4 : alt_name.ipv4_address()) {
         bool match = (ipv4 & mask) == net;
         score.add(match);
      }
   } else {
      // URI and email name constraint matching not implemented
      return MatchResult::UnknownType;
   }

   return score.result();
}
