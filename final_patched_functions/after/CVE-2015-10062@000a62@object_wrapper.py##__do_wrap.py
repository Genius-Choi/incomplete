    def __do_wrap( value ):
        if isinstance( value, SafeStringWrapper ):
            # Only ever wrap one-layer
            return value
        if callable( value ):
            safe_class = CallableSafeStringWrapper
        else:
            safe_class = SafeStringWrapper
        if isinstance( value, no_wrap_classes ):
            return value
        if isinstance( value, __DONT_WRAP_TYPES__ ):
            return sanitize_lists_to_string( value, valid_characters=VALID_CHARACTERS, character_map=CHARACTER_MAP )
        if isinstance( value, __WRAP_NO_SUBCLASS__ ):
            return safe_class( value, safe_string_wrapper_function = __do_wrap )
        for this_type in __WRAP_SEQUENCES__ + __WRAP_SETS__:
            if isinstance( value, this_type ):
                return this_type( map( __do_wrap, value ) )
        for this_type in __WRAP_MAPPINGS__:
            if isinstance( value, this_type ):
                # Wrap both key and value
                return this_type( map( lambda x: ( __do_wrap( x[0] ), __do_wrap( x[1] ) ), value.items() ) )
        # Create a dynamic class that joins SafeStringWrapper with the object being wrapped.
        # This allows e.g. isinstance to continue to work.
        try:
            wrapped_class_name = value.__name__
            wrapped_class = value
        except:
            wrapped_class_name = value.__class__.__name__
            wrapped_class = value.__class__
        value_mod = inspect.getmodule( value )
        if value_mod:
            wrapped_class_name = "%s.%s" % ( value_mod.__name__, wrapped_class_name )
        wrapped_class_name = "SafeStringWrapper(%s:%s)" % ( wrapped_class_name, ",".join( sorted( map( str, no_wrap_classes ) ) ) )
        do_wrap_func_name = "__do_wrap_%s" % ( wrapped_class_name )
        do_wrap_func = __do_wrap
        global_dict = globals()
        if wrapped_class_name in global_dict:
            # Check to see if we have created a wrapper for this class yet, if so, reuse
            wrapped_class = global_dict.get( wrapped_class_name )
            do_wrap_func = global_dict.get( do_wrap_func_name, __do_wrap )
        else:
            try:
                wrapped_class = type( wrapped_class_name, ( safe_class, wrapped_class, ), {} )
            except TypeError, e:
                 # Fail-safe for when a class cannot be dynamically subclassed.
                 log.warning( "Unable to create dynamic subclass for %s, %s: %s", type( value), value, e )
                 wrapped_class = type( wrapped_class_name, ( safe_class, ), {} )
            if wrapped_class not in ( SafeStringWrapper, CallableSafeStringWrapper ):
                # Save this wrapper for reuse and pickling/copying
                global_dict[ wrapped_class_name ] = wrapped_class
                do_wrap_func.__name__ = do_wrap_func_name
                global_dict[ do_wrap_func_name ] = do_wrap_func
                def pickle_safe_object( safe_object ):
                    return ( wrapped_class, ( safe_object.unsanitized, do_wrap_func, ) )
                # Set pickle and copy properties
                copy_reg.pickle( wrapped_class, pickle_safe_object, do_wrap_func )
        return wrapped_class( value, safe_string_wrapper_function = do_wrap_func )
