def findFirst2(path, fileName, level, searchAttributes, pktFlags=smb.SMB.FLAGS2_UNICODE, isSMB2=False):
    # TODO: Depending on the level, this could be done much simpler

    # print "FindFirs2 path:%s, filename:%s" % (path, fileName)
    fileName = os.path.normpath(fileName.replace('\\', '/'))
    # Let's choose the right encoding depending on the request
    if pktFlags & smb.SMB.FLAGS2_UNICODE:
        encoding = 'utf-16le'
    else:
        encoding = 'ascii'

    if len(fileName) > 0 and (fileName[0] == '/' or fileName[0] == '\\'):
        # strip leading '/'
        fileName = fileName[1:]

    if not isInFileJail(path, fileName):
        LOG.error("Path not in current working directory")
        return [], 0, STATUS_OBJECT_PATH_SYNTAX_BAD

    pathName = os.path.join(path, fileName)
    files = []

    if pathName.find('*') == -1 and pathName.find('?') == -1:
        # No search patterns
        pattern = ''
    else:
        pattern = os.path.basename(pathName)
        dirName = os.path.dirname(pathName)

    # Always add . and .. Not that important for Windows, but Samba whines if
    # not present (for * search only)
    if pattern == '*':
        files.append(os.path.join(dirName, '.'))
        files.append(os.path.join(dirName, '..'))

    if pattern != '':
        for file in os.listdir(dirName):
            if fnmatch.fnmatch(file.lower(), pattern.lower()):
                entry = os.path.join(dirName, file)
                if os.path.isdir(entry):
                    if searchAttributes & smb.ATTR_DIRECTORY:
                        files.append(entry)
                else:
                    files.append(entry)
    else:
        if os.path.exists(pathName):
            files.append(pathName)

    searchResult = []
    searchCount = len(files)
    errorCode = STATUS_SUCCESS

    for i in files:
        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:
            item = smb.SMBFindFileBothDirectoryInfo(flags=pktFlags)
        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO or level == smb2.SMB2_FILE_DIRECTORY_INFO:
            item = smb.SMBFindFileDirectoryInfo(flags=pktFlags)
        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:
            item = smb.SMBFindFileFullDirectoryInfo(flags=pktFlags)
        elif level == smb.SMB_FIND_INFO_STANDARD:
            item = smb.SMBFindInfoStandard(flags=pktFlags)
        elif level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO:
            item = smb.SMBFindFileIdFullDirectoryInfo(flags=pktFlags)
        elif level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO:
            item = smb.SMBFindFileIdBothDirectoryInfo(flags=pktFlags)
        elif level == smb.SMB_FIND_FILE_NAMES_INFO or level == smb2.SMB2_FILE_NAMES_INFO:
            item = smb.SMBFindFileNamesInfo(flags=pktFlags)
        else:
            LOG.error("Wrong level %d!" % level)
            return searchResult, searchCount, STATUS_NOT_SUPPORTED

        (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(i)
        if os.path.isdir(i):
            item['ExtFileAttributes'] = smb.ATTR_DIRECTORY
        else:
            item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE

        item['FileName'] = os.path.basename(i).encode(encoding)

        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:
            item['EaSize'] = 0
            item['EndOfFile'] = size
            item['AllocationSize'] = size
            item['CreationTime'] = getFileTime(ctime)
            item['LastAccessTime'] = getFileTime(atime)
            item['LastWriteTime'] = getFileTime(mtime)
            item['LastChangeTime'] = getFileTime(mtime)
            item['ShortName'] = '\x00' * 24
            item['FileName'] = os.path.basename(i).encode(encoding)
            padLen = (8 - (len(item) % 8)) % 8
            item['NextEntryOffset'] = len(item) + padLen
        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO:
            item['EndOfFile'] = size
            item['AllocationSize'] = size
            item['CreationTime'] = getFileTime(ctime)
            item['LastAccessTime'] = getFileTime(atime)
            item['LastWriteTime'] = getFileTime(mtime)
            item['LastChangeTime'] = getFileTime(mtime)
            item['FileName'] = os.path.basename(i).encode(encoding)
            padLen = (8 - (len(item) % 8)) % 8
            item['NextEntryOffset'] = len(item) + padLen
        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:
            item['EaSize'] = 0
            item['EndOfFile'] = size
            item['AllocationSize'] = size
            item['CreationTime'] = getFileTime(ctime)
            item['LastAccessTime'] = getFileTime(atime)
            item['LastWriteTime'] = getFileTime(mtime)
            item['LastChangeTime'] = getFileTime(mtime)
            padLen = (8 - (len(item) % 8)) % 8
            item['NextEntryOffset'] = len(item) + padLen
        elif level == smb.SMB_FIND_INFO_STANDARD:
            item['EaSize'] = size
            item['CreationDate'] = getSMBDate(ctime)
            item['CreationTime'] = getSMBTime(ctime)
            item['LastAccessDate'] = getSMBDate(atime)
            item['LastAccessTime'] = getSMBTime(atime)
            item['LastWriteDate'] = getSMBDate(mtime)
            item['LastWriteTime'] = getSMBTime(mtime)
        searchResult.append(item)

    # No more files
    if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:
        searchResult[-1]['NextEntryOffset'] = 0

    return searchResult, searchCount, errorCode
