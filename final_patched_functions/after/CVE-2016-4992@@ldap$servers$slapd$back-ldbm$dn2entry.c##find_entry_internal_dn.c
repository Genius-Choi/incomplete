find_entry_internal_dn(
    Slapi_PBlock	*pb,
    backend			*be,
    const Slapi_DN *sdn,
    int				lock,
    back_txn		*txn,
    int				flags,
    int				*rc /* return code */
)
{ 
	struct backentry *e;
	int	managedsait = 0;
	int	err;
	ldbm_instance *inst = (ldbm_instance *) be->be_instance_info;
	size_t tries = 0;
	int isroot = 0;
	int op_type;
	char *errbuf = NULL;

	/* get the managedsait ldap message control */
	slapi_pblock_get(pb, SLAPI_MANAGEDSAIT, &managedsait);
	slapi_pblock_get(pb, SLAPI_REQUESTOR_ISROOT, &isroot);
	slapi_pblock_get(pb, SLAPI_OPERATION_TYPE, &op_type);

	while ( (tries < LDBM_CACHE_RETRY_COUNT) && 
	        (e = dn2entry_ext( be, sdn, txn, flags & TOMBSTONE_INCLUDED, &err ))
	        != NULL )
	{
		/*
		 * we found the entry. if the managedsait control is set,
		 * we return the entry. if managedsait is not set, we check
		 * for the presence of a ref attribute, returning to the
		 * client a referral to the ref'ed entry if a ref is present,
		 * returning the entry to the caller if not.
		 */
		if ( !managedsait && !(flags & FE_REALLY_INTERNAL)) {
			/* see if the entry is a referral */
			if(check_entry_for_referral(pb, e->ep_entry, NULL, "find_entry_internal_dn"))
			{
				CACHE_RETURN( &inst->inst_cache, &e );
				if (rc) { /* if check_entry_for_referral returns non-zero, result is sent. */
					*rc = FE_RC_SENT_RESULT;
				}
				return( NULL );
			}
		}

		/*
		 * we'd like to return the entry. lock it if requested,
		 * retrying if necessary.
		 */

		/* wait for entry modify lock */
		if ( !lock || cache_lock_entry( &inst->inst_cache, e ) == 0 ) {
			LDAPDebug( LDAP_DEBUG_TRACE,
			    "<= find_entry_internal_dn found (%s)\n", slapi_sdn_get_dn(sdn), 0, 0 );
			return( e );
		}
		/*
		 * this entry has been deleted - see if it was actually
		 * replaced with a new copy, and try the whole thing again.
		 */
		LDAPDebug( LDAP_DEBUG_ARGS,
		    "   find_entry_internal_dn retrying (%s)\n", slapi_sdn_get_dn(sdn), 0, 0 );
		CACHE_RETURN( &inst->inst_cache, &e );
		tries++;
	}
	if (tries >= LDBM_CACHE_RETRY_COUNT) {
		LDAPDebug( LDAP_DEBUG_ANY,"find_entry_internal_dn retry count exceeded (%s)\n", slapi_sdn_get_dn(sdn), 0, 0 );
	}
	/*
	 * there is no such entry in this server. see how far we
	 * can match, and check if that entry contains a referral.
	 * if it does and managedsait is not set, we return the
	 * referral to the client. if it doesn't, or managedsait
	 * is set, we return no such object.
	 */
	if (!(flags & FE_REALLY_INTERNAL)) {
		struct backentry *me;
		Slapi_DN ancestorsdn;
		slapi_sdn_init(&ancestorsdn);
		me = dn2ancestor(pb->pb_backend, sdn, &ancestorsdn, txn, &err, 1 /* allow_suffix */);
		if ( !managedsait && me != NULL ) {
			/* if the entry is a referral send the referral */
			if(check_entry_for_referral(pb, me->ep_entry, (char*)slapi_sdn_get_dn(&ancestorsdn), "find_entry_internal_dn"))
			{
				CACHE_RETURN( &inst->inst_cache, &me );
				slapi_sdn_done(&ancestorsdn);
				if (rc) { /* if check_entry_for_referral returns non-zero, result is sent. */
					*rc = FE_RC_SENT_RESULT;
				}
				return( NULL );
			}
			/* else fall through to no such object */
		}

		/* entry not found */
		if ((0 == err) || (DB_NOTFOUND == err)) {
			if (me && !isroot) {
				/* If not root, you may not want to reveal it. */
				int acl_type = -1;
				int return_err = LDAP_NO_SUCH_OBJECT;
				err = LDAP_SUCCESS;
				switch (op_type) {
				case SLAPI_OPERATION_ADD:
					acl_type = SLAPI_ACL_ADD;
					return_err = LDAP_INSUFFICIENT_ACCESS;
					break;
				case SLAPI_OPERATION_DELETE:
					acl_type = SLAPI_ACL_DELETE;
					return_err = LDAP_INSUFFICIENT_ACCESS;
					break;
				case SLAPI_OPERATION_MODDN:
					acl_type = SLAPI_ACL_MODDN;
					return_err = LDAP_INSUFFICIENT_ACCESS;
					break;
				case SLAPI_OPERATION_MODIFY:
					acl_type = SLAPI_ACL_WRITE;
					return_err = LDAP_INSUFFICIENT_ACCESS;
					break;
				case SLAPI_OPERATION_SEARCH:
				case SLAPI_OPERATION_COMPARE:
					return_err = LDAP_SUCCESS;
					acl_type = SLAPI_ACL_READ;
					break;
				case SLAPI_OPERATION_BIND:
					acl_type = -1; /* skip acl check. acl is not set up for bind. */
					return_err = LDAP_INVALID_CREDENTIALS;
					slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, "No such entry");
					break;
				}
				if (acl_type > 0) {
					err = plugin_call_acl_plugin(pb, me->ep_entry, NULL, NULL, acl_type,
					                             ACLPLUGIN_ACCESS_DEFAULT, &errbuf);
				}
				if (((acl_type > 0) && err) || (op_type == SLAPI_OPERATION_BIND)) {
					/*
					 * Operations to be checked && ACL returns disallow.
					 * Not to disclose the info about the entry's existence,
					 * do not return the "matched" DN.
					 * Plus, the bind case returns LDAP_INAPPROPRIATE_AUTH.
					 */
					slapi_send_ldap_result(pb, return_err, NULL, NULL, 0, NULL);
				} else {
					slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT,
						(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL);
				}
			} else {
				slapi_send_ldap_result( pb, LDAP_NO_SUCH_OBJECT,
					(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL);
			}
		} else {
			slapi_send_ldap_result( pb, ( LDAP_INVALID_DN_SYNTAX == err ) ?
				LDAP_INVALID_DN_SYNTAX : LDAP_OPERATIONS_ERROR,
				(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL );
		}
		if (rc) {
			*rc = FE_RC_SENT_RESULT;
		}
		slapi_sdn_done(&ancestorsdn);
		CACHE_RETURN( &inst->inst_cache, &me );
	}

	slapi_ch_free_string(&errbuf);
	LDAPDebug( LDAP_DEBUG_TRACE, "<= find_entry_internal_dn not found (%s)\n",
	    slapi_sdn_get_dn(sdn), 0, 0 );
	return( NULL );
}
