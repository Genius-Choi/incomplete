  def suspend
    guardian.ensure_can_suspend!(@user)
    reason = params[:reason]

    if reason && (!reason.is_a?(String) || reason.size > 300)
      raise Discourse::InvalidParameters.new(:reason)
    end

    if @user.suspended?
      suspend_record = @user.suspend_record
      message =
        I18n.t(
          "user.already_suspended",
          staff: suspend_record.acting_user.username,
          time_ago:
            AgeWords.time_ago_in_words(
              suspend_record.created_at,
              true,
              scope: :"datetime.distance_in_words_verbose",
            ),
        )
      return render json: failed_json.merge(message: message), status: 409
    end

    params.require(%i[suspend_until reason])

    all_users = [@user]
    if Array === params[:other_user_ids]
      if params[:other_user_ids].size > MAX_SIMILAR_USERS
        raise Discourse::InvalidParameters.new(:other_user_ids)
      end

      all_users.concat(User.where(id: params[:other_user_ids]).to_a)
      all_users.uniq!
    end

    user_history = nil

    all_users.each { |user| raise Discourse::InvalidAccess.new if !guardian.can_suspend?(user) }

    all_users.each do |user|
      suspender =
        UserSuspender.new(
          user,
          suspended_till: params[:suspend_until],
          reason: params[:reason],
          by_user: current_user,
          message: params[:message],
          post_id: params[:post_id],
        )
      suspender.suspend
      user_history = suspender.user_history
    end

    perform_post_action

    render_json_dump(
      suspension: {
        suspend_reason: params[:reason],
        full_suspend_reason: user_history&.details,
        suspended_till: @user.suspended_till,
        suspended_at: @user.suspended_at,
        suspended_by: BasicUserSerializer.new(current_user, root: false).as_json,
      },
    )
  end
