def _unpack_returndata(buf, contract_sig, context, pos):
    return_t = contract_sig.return_type
    if return_t is None:
        return ["pass"], 0, 0

    return_t = calculate_type_for_external_return(return_t)
    # if the abi signature has a different type than
    # the vyper type, we need to wrap and unwrap the type
    # so that the ABI decoding works correctly
    should_unwrap_abi_tuple = return_t != contract_sig.return_type

    abi_return_t = abi_type_of(return_t)

    min_return_size = abi_return_t.min_size()
    max_return_size = abi_return_t.size_bound()
    assert 0 < min_return_size <= max_return_size

    ret_ofst = buf
    ret_len = max_return_size

    # revert when returndatasize is not in bounds
    ret = []
    # runtime: min_return_size <= returndatasize
    # TODO move the -1 optimization to LLL optimizer
    ret += [["assert", ["gt", "returndatasize", min_return_size - 1]]]

    # add as the last LLLnode a pointer to the return data structure

    # the return type has been wrapped by the calling contract;
    # unwrap it so downstream code isn't confused.
    # basically this expands to buf+32 if the return type has been wrapped
    # in a tuple AND its ABI type is dynamic.
    # in most cases, this simply will evaluate to ret.
    # in the special case where the return type has been wrapped
    # in a tuple AND its ABI type is dynamic, it expands to buf+32.
    buf = LLLnode(buf, typ=return_t, encoding=_returndata_encoding(contract_sig), location="memory")

    if should_unwrap_abi_tuple:
        buf = get_element_ptr(buf, 0, pos=None, array_bounds_check=False)

    ret += [buf]

    return ret, ret_ofst, ret_len
