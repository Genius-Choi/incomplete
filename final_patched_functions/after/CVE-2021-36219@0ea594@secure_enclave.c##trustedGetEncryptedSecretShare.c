void trustedGetEncryptedSecretShare(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,
                     char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) {

    LOG_DEBUG (__FUNCTION__);

    char skey[ECDSA_SKEY_LEN];
    char pub_key_x[BUF_LEN];
    memset(pub_key_x, 0, BUF_LEN);
    char pub_key_y[BUF_LEN];
    memset(pub_key_y, 0, BUF_LEN);

    uint32_t enc_len;

    trustedGenerateEcdsaKey(errStatus, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);
    if (*errStatus != 0) {
        return;
    }

    *dec_len = enc_len;

    sgx_status_t status = sgx_unseal_data(
            (const sgx_sealed_data_t *) encrypted_skey, NULL, 0, (uint8_t *) skey, &enc_len);

    if (status != SGX_SUCCESS) {
        snprintf(errString, BUF_LEN, "sgx_unseal_data failed - encrypted_skey with status %d", status);
        *errStatus = status;
        return;
    }
    snprintf(errString, BUF_LEN, "unsealed random skey is %s\n", skey);

    char *common_key[ECDSA_SKEY_LEN];
    gen_session_key(skey, pub_keyB, common_key);
    char *s_share[ECDSA_SKEY_LEN]; ;


    if (calc_secret_share(decryptedDkgPoly, s_share, _t, _n, ind) != 0) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "\nt does not match poly degree\n");
        return;
    }
    snprintf(errString + 88, BUF_LEN, "\nsecret share is %s", s_share);

    if (calc_secret_shareG2(s_share, s_shareG2) != 0) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "invalid decr secret share\n");
        return;
    }

    char *cypher[ECDSA_SKEY_LEN];
    xor_encrypt(common_key, s_share, cypher);
    if (cypher == NULL) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "invalid common_key");
        return;
    }


    strncpy(result_str, cypher, strlen(cypher));
    strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));
    strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));

}
