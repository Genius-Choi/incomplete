bool SignedData::verify_signature() const {
  STACK_OF(X509) *certs = nullptr;
  switch (OBJ_obj2nid(p7_->type)) {
    case NID_pkcs7_signed: {
      certs = p7_->d.sign->cert;
      break;
    }
    /* NOTE(ww): I'm pretty sure Authenticode signatures are always SignedData and never
     * SignedAndEnvelopedData, but it doesn't hurt us to handle the latter as well.
     */
    case NID_pkcs7_signedAndEnveloped: {
      certs = p7_->d.signed_and_enveloped->cert;
      break;
    }
  }

  if (certs == nullptr) {
    return false;
  }

  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);
  if (signers_stack_ptr == nullptr) {
    return false;
  }
  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);

  /* NOTE(ww): Authenticode specification, page 13: the signer must have the
   * codeSigning EKU, **or** no member of the signer's chain may have it.
   *
   * The check below is more strict than that: **every** signer must have
   * the codeSigning EKU, and we don't check the embedded chain (since
   * we can't do full chain verification anyways).
   */
  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {
    auto *signer = sk_X509_value(signers_stack.get(), i);

    /* NOTE(ww): Ths should really be X509_check_purpose with
     * X509_PURPOSE_CODE_SIGN, but this is inexplicably not present
     * in even the latest releases of OpenSSL as of 2023-05.
     */
    auto xku_flags = X509_get_extended_key_usage(signer);
    if (!(xku_flags & XKU_CODE_SIGN)) {
      return false;
    }
  }

  /* NOTE(ww): What happens below is a bit dumb: we convert our SpcIndirectDataContent back
   * into DER form so that we can unwrap its ASN.1 sequence and pass the underlying data
   * to PKCS7_verify for verification. This displays our intent a little more clearly than
   * our previous approach, which was to walk the PKCS#7 structure manually.
   */
  std::uint8_t *indirect_data_buf = nullptr;
  auto buf_size = impl::i2d_Authenticode_SpcIndirectDataContent(indirect_data_, &indirect_data_buf);
  if (buf_size < 0 || indirect_data_buf == nullptr) {
    return false;
  }
  auto indirect_data_ptr =
      impl::OpenSSL_ptr(reinterpret_cast<char *>(indirect_data_buf), impl::OpenSSL_free);

  const auto *signed_data_seq = reinterpret_cast<std::uint8_t *>(indirect_data_ptr.get());
  long length = 0;
  int tag = 0, tag_class = 0;
  ASN1_get_object(&signed_data_seq, &length, &tag, &tag_class, buf_size);
  if (tag != V_ASN1_SEQUENCE) {
    return false;
  }

  auto *signed_data_ptr = BIO_new_mem_buf(signed_data_seq, length);
  if (signed_data_ptr == nullptr) {
    return false;
  }
  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);

  /* Our actual verification happens here.
   *
   * We pass `certs` explicitly, but (experimentally) we don't have to -- the function correctly
   * extracts then from the SignedData in `p7_`.
   *
   * We pass `nullptr` for the X509_STORE, since we don't do full-chain verification
   * (we can't, since we don't have access to Windows's Trusted Publishers store on non-Windows).
   */
  auto status = PKCS7_verify(p7_, certs, nullptr, signed_data.get(), nullptr, PKCS7_NOVERIFY);

  return status == 1;
}
