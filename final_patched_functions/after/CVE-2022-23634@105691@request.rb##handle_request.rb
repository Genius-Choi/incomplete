    def handle_request(client, lines, requests)
      env = client.env
      io  = client.io   # io may be a MiniSSL::Socket

      return false if closed_socket?(io)

      normalize_env env, client

      env[PUMA_SOCKET] = io

      if env[HTTPS_KEY] && io.peercert
        env[PUMA_PEERCERT] = io.peercert
      end

      env[HIJACK_P] = true
      env[HIJACK] = client

      body = client.body

      head = env[REQUEST_METHOD] == HEAD

      env[RACK_INPUT] = body
      env[RACK_URL_SCHEME] ||= default_server_port(env) == PORT_443 ? HTTPS : HTTP

      if @early_hints
        env[EARLY_HINTS] = lambda { |headers|
          begin
            fast_write io, str_early_hints(headers)
          rescue ConnectionError => e
            @log_writer.debug_error e
            # noop, if we lost the socket we just won't send the early hints
          end
        }
      end

      req_env_post_parse env

      # A rack extension. If the app writes #call'ables to this
      # array, we will invoke them when the request is done.
      #
      after_reply = env[RACK_AFTER_REPLY] = []

      begin
        begin
          status, headers, res_body = @thread_pool.with_force_shutdown do
            @app.call(env)
          end

          return :async if client.hijacked

          status = status.to_i

          if status == -1
            unless headers.empty? and res_body == []
              raise "async response must have empty headers and body"
            end

            return :async
          end
        rescue ThreadPool::ForceShutdown => e
          @log_writer.unknown_error e, client, "Rack app"
          @log_writer.log "Detected force shutdown of a thread"

          status, headers, res_body = lowlevel_error(e, env, 503)
        rescue Exception => e
          @log_writer.unknown_error e, client, "Rack app"

          status, headers, res_body = lowlevel_error(e, env, 500)
        end

        res_info = {}
        res_info[:content_length] = nil
        res_info[:no_body] = head

        res_info[:content_length] = if res_body.kind_of? Array and res_body.size == 1
          res_body[0].bytesize
        else
          nil
        end

        cork_socket io

        str_headers(env, status, headers, res_info, lines, requests, client)

        line_ending = LINE_END

        content_length  = res_info[:content_length]
        if res_body && !res_body.respond_to?(:each)
          response_hijack = res_body
        else
          response_hijack = res_info[:response_hijack]
        end

        if res_info[:no_body]
          if content_length and status != 204
            lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending
          end

          lines << LINE_END
          fast_write io, lines.to_s
          return res_info[:keep_alive]
        end

        if content_length
          lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending
          chunked = false
        elsif !response_hijack and res_info[:allow_chunked]
          lines << TRANSFER_ENCODING_CHUNKED
          chunked = true
        end

        lines << line_ending

        fast_write io, lines.to_s

        if response_hijack
          response_hijack.call io
          return :async
        end

        begin
          res_body.each do |part|
            next if part.bytesize.zero?
            if chunked
               fast_write io, (part.bytesize.to_s(16) << line_ending)
               fast_write io, part            # part may have different encoding
               fast_write io, line_ending
            else
              fast_write io, part
            end
            io.flush
          end

          if chunked
            fast_write io, CLOSE_CHUNKED
            io.flush
          end
        rescue SystemCallError, IOError
          raise ConnectionError, "Connection error detected during write"
        end

      ensure
        begin
          uncork_socket io

          body.close
          client.tempfile.unlink if client.tempfile
        ensure
          # Whatever happens, we MUST call `close` on the response body.
          # Otherwise Rack::BodyProxy callbacks may not fire and lead to various state leaks
          res_body.close if res_body.respond_to? :close
        end

        after_reply.each { |o| o.call }
      end
