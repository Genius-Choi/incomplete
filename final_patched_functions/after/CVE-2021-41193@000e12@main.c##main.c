int main(int argc, char *argv[])
{
	const char *email = NULL;
	const char *password = NULL;
	const char *request_uri = DEFAULT_REQUEST_URL;
	const char *notification_uri = DEFAULT_NOTIFICATION_URL;
	enum log_level level = LOG_LEVEL_WARN;
	size_t i;

	int err = 0;

	for (;;) {
		const int c = getopt(argc, argv, "de:l:n:p:r:tDu:");
		if (c < 0)
			break;

		switch (c) {

		case 'd':
			if (level == LOG_LEVEL_INFO)
				level = LOG_LEVEL_DEBUG;
			else
				level = LOG_LEVEL_INFO;
			break;

		case 'D':
			request_uri = DEV_REQUEST_URL;
			notification_uri = DEV_NOTIFICATION_URL;
			break;

		case 'e':
			email = optarg;
			break;

		case 'n':
			notification_uri = optarg;
			break;

		case 'p':
			password = optarg;
			break;

		case 'r':
			request_uri = optarg;
			break;

		case 'u':
			turn_uri = optarg;
			break;

		case '?':
			err = EINVAL;
			/* fall through */
		case 'h':
			usage();
			return err;
		}
	}

	log_set_min_level(level);

	if (email == NULL) {
		(void)re_fprintf(stderr, "Missing email.\n");
		err = EINVAL;
		goto out;
	}
	if (password == NULL) {
		(void)re_fprintf(stderr, "Missing password.\n");
		err = EINVAL;
		goto out;
	}

	err = libre_init();
	if (err) {
		(void)re_fprintf(stderr, "libre init failed: %m\n", err);
		goto out;
	}

	err = avs_init(AVS_FLAG_EXPERIMENTAL);
	if (err) {
		(void)re_fprintf(stderr, "avs init failed: %m\n", err);
		goto out;
	}

	sys_coredump_set(true);

	err = engine_init("audummy");
	if (err) {
		(void)re_fprintf(stderr, "engine init failed: %m\n", err);
		goto out;
	}

	err = engine_alloc(&engine, request_uri, notification_uri, email,
			   password, NULL, false, false,
			   "netprobe/" AVS_VERSION,
			   ready_handler, error_handler,
			   engine_shutdown_handler, 0);
	if (err) {
		(void)re_fprintf(stderr, "Engine init failed: %m\n", err);
		goto out;
	}

	err = re_main(signal_handler);

 out:
	for (i=0; i<netprobec; i++)
		mem_deref(netprobev[i].np);

	mem_deref(g_config);
	mem_deref(engine);

	engine_close();
	dns_close();

	libre_close();

	/* check for memory leaks */
	mem_debug();
	tmr_debug();

	if (err) {
		return 1;
	}
	else {
		return 0;
	}
}
