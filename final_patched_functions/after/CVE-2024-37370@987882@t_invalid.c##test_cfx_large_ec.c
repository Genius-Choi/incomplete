test_cfx_large_ec(gss_ctx_id_t ctx, krb5_key subkey)
{
    OM_uint32 major, minor;
    uint8_t tokbuf[128] = { 0 }, plainbuf[20];
    krb5_data plain;
    krb5_enc_data cipher;
    gss_buffer_desc in, out;

    /* Construct a header with an EC value of 5. */
    write_cfx_header(5, tokbuf);

    /* Encrypt a 4-byte plaintext plus the header. */
    memcpy(plainbuf, "abcd", 4);
    memcpy(plainbuf + 4, tokbuf, 16);
    plain = make_data(plainbuf, 20);
    cipher.ciphertext.data = (char *)tokbuf + 16;
    cipher.ciphertext.length = sizeof(tokbuf) - 16;
    cipher.enctype = subkey->keyblock.enctype;
    if (krb5_k_encrypt(NULL, subkey, KG_USAGE_INITIATOR_SEAL, NULL,
                       &plain, &cipher) != 0)
        abort();

    /* Verify that the token is rejected by gss_unwrap(). */
    in.value = tokbuf;
    in.length = 16 + cipher.ciphertext.length;
    major = gss_unwrap(&minor, ctx, &in, &out, NULL, NULL);
    if (major != GSS_S_DEFECTIVE_TOKEN)
        abort();
    (void)gss_release_buffer(&minor, &out);
}
