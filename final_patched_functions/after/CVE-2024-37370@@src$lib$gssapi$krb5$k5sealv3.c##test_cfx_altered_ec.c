test_cfx_altered_ec(gss_ctx_id_t ctx, krb5_key subkey)
{
    OM_uint32 major, minor;
    uint8_t tokbuf[128], plainbuf[24];
    krb5_data plain;
    krb5_enc_data cipher;
    gss_buffer_desc in, out;
    gss_iov_buffer_desc iov[2];

    /* Construct a header with a plaintext EC value of 3. */
    write_cfx_header(3, tokbuf);

    /* Encrypt a plaintext and a copy of the header with the EC value 0. */
    memcpy(plainbuf, "truncate", 8);
    memcpy(plainbuf + 8, tokbuf, 16);
    store_16_be(0, plainbuf + 12);
    plain = make_data(plainbuf, 24);
    cipher.ciphertext.data = (char *)tokbuf + 16;
    cipher.ciphertext.length = sizeof(tokbuf) - 16;
    cipher.enctype = subkey->keyblock.enctype;
    if (krb5_k_encrypt(NULL, subkey, KG_USAGE_INITIATOR_SEAL, NULL,
                       &plain, &cipher) != 0)
        abort();

    /* Verify that the token is rejected by gss_unwrap(). */
    in.value = tokbuf;
    in.length = 16 + cipher.ciphertext.length;
    major = gss_unwrap(&minor, ctx, &in, &out, NULL, NULL);
    if (major != GSS_S_DEFECTIVE_TOKEN)
        abort();
    (void)gss_release_buffer(&minor, &out);

    /* Verify that the token is rejected by gss_unwrap_iov(). */
    iov[0].type = GSS_IOV_BUFFER_TYPE_STREAM;
    iov[0].buffer = in;
    iov[1].type = GSS_IOV_BUFFER_TYPE_DATA;
    major = gss_unwrap_iov(&minor, ctx, NULL, NULL, iov, 2);
    if (major != GSS_S_DEFECTIVE_TOKEN)
        abort();
}
