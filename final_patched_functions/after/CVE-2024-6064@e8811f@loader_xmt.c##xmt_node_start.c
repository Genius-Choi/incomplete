static void xmt_node_start(void *sax_cbck, const char *name, const char *name_space, const GF_XMLAttribute *attributes, u32 nb_attributes)
{
	GF_Node *elt;
	XMTNodeStack *top, *new_top;
	GF_XMTParser *parser = (GF_XMTParser *)sax_cbck;

	if (parser->last_error) {
		gf_xml_sax_suspend(parser->sax_parser, 1);
		if (parser->command_buffer)
			parser->command_buffer->buffer = NULL;
		return;
	}

	/*init doc type*/
	if (!parser->doc_type) {
		if (!strcmp(name, "XMT-A")) parser->doc_type = 1;
		else if (!strcmp(name, "X3D")) {
			parser->doc_type = 2;
			parser->script_to_load = gf_list_new();
		}
		else if (!strcmp(name, "XMT-O")) parser->doc_type = 3;
		return;
	}

	/*init doc state with already loaded context (for chunk encoding)*/
	if ((parser->state == XMT_STATE_INIT) && (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) && (parser->doc_type == 1)) {
		parser->state = XMT_STATE_COMMANDS;
	}
	/*init doc state for regular parsing*/
	else if (parser->state == XMT_STATE_INIT) {
		/*XMT-A header*/
		if ((parser->doc_type == 1) && !strcmp(name, "Header")) parser->state = XMT_STATE_HEAD;
		/*X3D header*/
		else if ((parser->doc_type == 2) && !strcmp(name, "head")) parser->state = XMT_STATE_HEAD;
		/*XMT-O header*/
		else if ((parser->doc_type == 3) && !strcmp(name, "head")) parser->state = XMT_STATE_HEAD;

		return;
	}

	/*XMT-A header: parse OD/IOD*/
	if ((parser->doc_type == 1) && (parser->state == XMT_STATE_HEAD)) {
		GF_Descriptor *desc, *par;
		par = (GF_Descriptor *)gf_list_last(parser->descriptors);
		desc = xmt_parse_descriptor(parser, (char *) name, attributes, nb_attributes, par);
		if (desc) gf_list_add(parser->descriptors, desc);
		return;
	}
	if (parser->state==XMT_STATE_END) {
		if (!strcmp(name, "head")) {
			parser->state = XMT_STATE_HEAD;
		} else {
			parser->state = XMT_STATE_COMMANDS;
		}
	}

	/*scene content*/
	if (parser->state==XMT_STATE_BODY) {
		/*XMT-A body*/
		if ((parser->doc_type == 1) && !strcmp(name, "Body")) parser->state = XMT_STATE_COMMANDS;
		/*X3D scene*/
		else if ((parser->doc_type == 2) && !strcmp(name, "Scene")) {
			parser->state = XMT_STATE_ELEMENTS;
			if (parser->load->ctx) {
				parser->load->ctx->is_pixel_metrics = 0;
				parser->load->ctx->scene_width = parser->load->ctx->scene_height = 0;
			}
			gf_sg_set_scene_size_info(parser->load->scene_graph, 0, 0, 0);
		}
		/*XMT-O body*/
		else if ((parser->doc_type == 3) && !strcmp(name, "body")) parser->state = XMT_STATE_COMMANDS;
		return;
	}
	/*XMT-A command*/
	if ((parser->doc_type == 1) && (parser->state == XMT_STATE_COMMANDS)) {
		/*OD command*/
		if (parser->od_command) {
			GF_Descriptor *desc, *par;
			par = (GF_Descriptor *)gf_list_last(parser->descriptors);
			desc = xmt_parse_descriptor(parser, (char *) name, attributes, nb_attributes, par);
			if (desc) gf_list_add(parser->descriptors, desc);
		} else {
			xmt_parse_command(parser, name, attributes, nb_attributes);
		}
		return;
	}


	/*node*/
	if (parser->state != XMT_STATE_ELEMENTS) return;

	top = (XMTNodeStack*)gf_list_last(parser->nodes);
	if (!top) top = parser->x3d_root;

	elt = xmt_parse_element(parser, (char *) name, name_space, attributes, nb_attributes, top);
	if (!elt) return;
	GF_SAFEALLOC(new_top, XMTNodeStack);
	if (!new_top) return;

	new_top->node = elt;
	gf_list_add(parser->nodes, new_top);

	/*assign root node here to enable progressive loading*/
	if (!top && (parser->doc_type == 1) && !parser->parsing_proto && parser->command && (parser->command->tag==GF_SG_SCENE_REPLACE) && !parser->command->node) {
		parser->command->node = elt;
		gf_node_register(elt, NULL);
	}
}
