  def find_categories
    query = Category.includes(CategoryList.included_associations).secured(@guardian)

    query =
      query.where(
        "categories.parent_category_id = ?",
        @options[:parent_category_id].to_i,
      ) if @options[:parent_category_id].present?

    query = self.class.order_categories(query)

    if @guardian.can_lazy_load_categories?
      page = [1, @options[:page].to_i].max
      query =
        query
          .where(parent_category_id: nil)
          .limit(CATEGORIES_PER_PAGE)
          .offset((page - 1) * CATEGORIES_PER_PAGE)
    end

    query =
      DiscoursePluginRegistry.apply_modifier(:category_list_find_categories_query, query, self)

    @categories = query.to_a

    if @guardian.can_lazy_load_categories?
      categories_with_rownum =
        Category
          .secured(@guardian)
          .select(:id, "ROW_NUMBER() OVER (PARTITION BY parent_category_id) rownum")
          .where(parent_category_id: @categories.map { |c| c.id })

      @categories +=
        Category.includes(CategoryList.included_associations).where(
          "id IN (WITH cte AS (#{categories_with_rownum.to_sql}) SELECT id FROM cte WHERE rownum <= ?)",
          SUBCATEGORIES_PER_CATEGORY,
        )
    end

    if Site.preloaded_category_custom_fields.any?
      Category.preload_custom_fields(@categories, Site.preloaded_category_custom_fields)
    end

    include_subcategories = @options[:include_subcategories] == true

    notification_levels = CategoryUser.notification_levels_for(@guardian.user)
    default_notification_level = CategoryUser.default_notification_level

    if @guardian.can_lazy_load_categories?
      subcategory_ids = {}
      Category
        .secured(@guardian)
        .where(parent_category_id: @categories.map(&:id))
        .pluck(:id, :parent_category_id)
        .each { |id, parent_id| (subcategory_ids[parent_id] ||= []) << id }
      @categories.each { |c| c.subcategory_ids = subcategory_ids[c.id] || [] }
    elsif @options[:parent_category_id].blank?
      subcategory_ids = {}
      subcategory_list = {}
      to_delete = Set.new
      @categories.each do |c|
        if c.parent_category_id.present?
          subcategory_ids[c.parent_category_id] ||= []
          subcategory_ids[c.parent_category_id] << c.id
          if include_subcategories
            subcategory_list[c.parent_category_id] ||= []
            subcategory_list[c.parent_category_id] << c
          end
          to_delete << c
        end
      end
      @categories.each do |c|
        c.subcategory_ids = subcategory_ids[c.id] || []
        c.subcategory_list = subcategory_list[c.id] || [] if include_subcategories
      end
      @categories.delete_if { |c| to_delete.include?(c) }
    end

    allowed_topic_create = Set.new(Category.topic_create_allowed(@guardian).pluck(:id))

    parent_ids =
      Category
        .secured(@guardian)
        .where(parent_category_id: categories_with_descendants.map(&:id))
        .pluck("DISTINCT parent_category_id")
        .to_set

    categories_with_descendants.each do |category|
      category.notification_level = notification_levels[category.id] || default_notification_level
      category.permission = CategoryGroup.permission_types[:full] if allowed_topic_create.include?(
        category.id,
      )
      category.has_children = parent_ids.include?(category.id)
    end
  end
