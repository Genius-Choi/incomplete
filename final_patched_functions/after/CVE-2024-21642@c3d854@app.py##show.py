def show(data=None, data_loader=None, name=None, context_vars=None, **options):
    """
    Entry point for kicking off D-Tale :class:`flask:flask.Flask` process from python process

    :param data: data which D-Tale will display
    :type data: :class:`pandas:pandas.DataFrame` or :class:`pandas:pandas.Series`
                or :class:`pandas:pandas.DatetimeIndex` or :class:`pandas:pandas.MultiIndex`, optional
    :param host: hostname of D-Tale, defaults to 0.0.0.0
    :type host: str, optional
    :param port: port number of D-Tale process, defaults to any open port on server
    :type port: str, optional
    :param name: optional label to assign a D-Tale process
    :type name: str, optional
    :param debug: will turn on :class:`flask:flask.Flask` debug functionality, defaults to False
    :type debug: bool, optional
    :param subprocess: run D-Tale as a subprocess of your current process, defaults to True
    :type subprocess: bool, optional
    :param data_loader: function to load your data
    :type data_loader: func, optional
    :param reaper_on: turn on subprocess which will terminate D-Tale after 1 hour of inactivity
    :type reaper_on: bool, optional
    :param open_browser: if true, this will try using the :mod:`python:webbrowser` package to automatically open
                         your default browser to your D-Tale process
    :type open_browser: bool, optional
    :param notebook: if true, this will try displaying an :class:`ipython:IPython.display.IFrame`
    :type notebook: bool, optional
    :param force: if true, this will force the D-Tale instance to run on the specified host/port by killing any
                  other process running at that location
    :type force: bool, optional
    :param context_vars: a dictionary of the variables that will be available for use in user-defined expressions,
                         such as filters
    :type context_vars: dict, optional
    :param ignore_duplicate: if true, this will not check if this data matches any other data previously loaded to
                             D-Tale
    :type ignore_duplicate: bool, optional
    :param app_root: Optional path to prepend to the routes of D-Tale. This is used when making use of
                     Jupyterhub server proxy
    :type app_root: str, optional
    :param allow_cell_edits: If false, this will not allow users to edit cells directly in their D-Tale grid
    :type allow_cell_edits: bool, optional
    :param inplace: If true, this will call `reset_index(inplace=True)` on the dataframe used as a way to save memory.
                    Otherwise this will create a brand new dataframe, thus doubling memory but leaving the dataframe
                    input unchanged.
    :type inplace: bool, optional
    :param drop_index: If true, this will drop any pre-existing index on the dataframe input.
    :type drop_index: bool, optional
    :param hide_shutdown: If true, this will hide the "Shutdown" buton from users
    :type hide_shutdown: bool, optional
    :param github_fork: If true, this will display a "Fork me on GitHub" ribbon in the upper right-hand corner of the
                        app
    :type github_fork: bool, optional
    :param hide_drop_rows: If true, this will hide the "Drop Rows" button from users
    :type hide_drop_rows: bool, optional
    :param hide_header_editor: If true, this will hide the header editor when editing cells
    :type hide_header_editor: bool, optional
    :param lock_header_menu: if true, this will always the display the header menu which usually only displays when you
                             hover over the top
    :type lock_header_menu: bool, optional
    :param hide_header_menu: If true, this will hide the header menu from the screen
    :type hide_header_menu: bool, optional
    :param hide_main_menu: If true, this will hide the main menu from the screen
    :type hide_main_menu: bool, optional
    :param hide_column_menus: If true, this will hide the column menus from the screen
    :type hide_column_menus: bool, optional
    :param column_edit_options: The options to allow on the front-end when editing a cell for the columns specified
    :type column_edit_options: dict, optional
    :param auto_hide_empty_columns: if True, then auto-hide any columns on the front-end that are comprised entirely of
                                    NaN values
    :type auto_hide_empty_columns: boolean, optional
    :param highlight_filter: if True, then highlight rows on the frontend which will be filtered when applying a filter
                             rather than hiding them from the dataframe
    :type highlight_filter: boolean, optional
    :param enable_custom_filters: If true, this will enable users to make custom filters from the UI
    :type enable_custom_filters: bool, optional
    :param enable_web_uploads: If true, this will enable users to upload files using URLs from the UI
    :type enable_web_uploads: bool, optional

    :Example:

        >>> import dtale
        >>> import pandas as pd
        >>> df = pandas.DataFrame([dict(a=1,b=2,c=3)])
        >>> dtale.show(df)
        D-Tale started at: http://hostname:port

        ..link displayed in logging can be copied and pasted into any browser
    """
    global ACTIVE_HOST, ACTIVE_PORT, SSL_CONTEXT, USE_NGROK

    if name:
        if global_state.get_data_id_by_name(name):
            print(
                "Data has already been loaded to D-Tale with the name '{}', please try another one.".format(
                    name
                )
            )
            return
        if any(not c.isalnum() and not c.isspace() for c in name):
            print(
                "'name' property cannot contain any special characters only letters, numbers or spaces."
            )
            return

    try:
        final_options = dtale_config.build_show_options(options)
        logfile, log_level, verbose = map(
            final_options.get, ["logfile", "log_level", "verbose"]
        )
        setup_logging(logfile, log_level or "info", verbose, dedicated_logger=True)

        if USE_NGROK:
            if not PY3:
                raise Exception(
                    "In order to use ngrok you must be using Python 3 or higher!"
                )

            from flask_ngrok import _run_ngrok

            ACTIVE_HOST = _run_ngrok()
            ACTIVE_PORT = None
        else:
            initialize_process_props(
                final_options["host"], final_options["port"], final_options["force"]
            )

        SSL_CONTEXT = options.get("ssl_context")
        app_url = build_url(ACTIVE_PORT, ACTIVE_HOST)
        startup_url, final_app_root = build_startup_url_and_app_root(
            final_options["app_root"]
        )
        instance = startup(
            startup_url,
            data=data,
            data_loader=data_loader,
            name=name,
            context_vars=context_vars,
            ignore_duplicate=final_options["ignore_duplicate"],
            allow_cell_edits=final_options["allow_cell_edits"],
            inplace=final_options["inplace"],
            drop_index=final_options["drop_index"],
            precision=final_options["precision"],
            show_columns=final_options["show_columns"],
            hide_columns=final_options["hide_columns"],
            column_formats=final_options["column_formats"],
            nan_display=final_options["nan_display"],
            sort=final_options["sort"],
            locked=final_options["locked"],
            background_mode=final_options["background_mode"],
            range_highlights=final_options["range_highlights"],
            vertical_headers=final_options["vertical_headers"],
            is_proxy=JUPYTER_SERVER_PROXY,
            app_root=final_app_root,
            hide_shutdown=final_options.get("hide_shutdown"),
            column_edit_options=final_options.get("column_edit_options"),
            auto_hide_empty_columns=final_options.get("auto_hide_empty_columns"),
            highlight_filter=final_options.get("highlight_filter"),
            hide_header_editor=final_options.get("hide_header_editor"),
            lock_header_menu=final_options.get("lock_header_menu"),
            hide_header_menu=final_options.get("hide_header_menu"),
            hide_main_menu=final_options.get("hide_main_menu"),
            hide_column_menus=final_options.get("hide_column_menus"),
            enable_custom_filters=final_options.get("enable_custom_filters"),
            enable_web_uploads=final_options.get("enable_web_uploads"),
        )
        instance.started_with_open_browser = final_options["open_browser"]
        is_active = not running_with_flask_debug() and is_up(app_url)
        if is_active:

            def _start():
                if final_options["open_browser"]:
                    instance.open_browser()

        else:
            if USE_NGROK:
                thread = Timer(1, _run_ngrok)
                thread.setDaemon(True)
                thread.start()

            def _start():
                try:
                    app = build_app(
                        app_url,
                        reaper_on=final_options["reaper_on"],
                        host=ACTIVE_HOST,
                        app_root=final_app_root,
                    )
                    if final_options["debug"] and not USE_NGROK:
                        app.jinja_env.auto_reload = True
                        app.config["TEMPLATES_AUTO_RELOAD"] = True
                    else:
                        logging.getLogger("werkzeug").setLevel(LOG_ERROR)

                    if final_options["open_browser"]:
                        instance.open_browser()

                    # hide banner message in production environments
                    cli = sys.modules.get("flask.cli")
                    if cli is not None:
                        cli.show_server_banner = lambda *x: None

                    run_kwargs = {}
                    if options.get("ssl_context"):
                        run_kwargs["ssl_context"] = options.get("ssl_context")

                    if USE_NGROK:
                        app.run(threaded=True, **run_kwargs)
                    else:
                        app.run(
                            host=ACTIVE_HOST,
                            port=ACTIVE_PORT,
                            debug=final_options["debug"],
                            threaded=True,
                            **run_kwargs
                        )
                except BaseException as ex:
                    logger.exception(ex)

        if final_options["subprocess"]:
            if is_active:
                _start()
            else:
                _thread.start_new_thread(_start, ())

            if final_options["notebook"]:
                instance.notebook()
        else:
            # Need to use logging.info() because for some reason other libraries like arctic seem to break logging
            logging.info("D-Tale started at: {}".format(app_url))
            _start()

        return instance
    except DuplicateDataError as ex:
        print(
            "It looks like this data may have already been loaded to D-Tale based on shape and column names. Here is "
            "URL of the data that seems to match it:\n\n{}\n\nIf you still want to load this data please use the "
            "following command:\n\ndtale.show(df, ignore_duplicate=True)".format(
                DtaleData(ex.data_id, build_url(ACTIVE_PORT, ACTIVE_HOST)).main_url()
            )
        )
    return None
