def manage_action_containers(
    request, action, o_type=None, o_id=None, conn=None, **kwargs
):
    """
    Handles many different actions on various objects.

    @param action:      "addnewcontainer", (creates a new Project, Dataset,
                        Screen), "editname", "savename", "editdescription",
                        "savedescription",  (used as GET and POST for in-line
                        editing),
                        "removefromshare", (tree P/D/I moving etc)
                        "delete", "deletemany"      (delete objects)
                        "remove" (remove tag/comment from object)
    @param o_type:      "dataset", "project", "image", "screen", "plate",
                        "acquisition", "well","comment", "file", "tag",
                        "tagset","share", "sharecomment"
    """
    template = None

    manager = None
    if o_type in (
        "dataset",
        "project",
        "image",
        "screen",
        "plate",
        "acquisition",
        "well",
        "comment",
        "file",
        "tag",
        "tagset",
    ):
        kw = {}
        if o_type is not None and int(o_id) > 0:
            o_id = int(o_id)
            kw[str(o_type)] = o_id
        try:
            manager = BaseContainer(conn, **kw)
        except AttributeError as x:
            return handlerInternalError(request, x)
    elif o_type in ("share", "sharecomment", "chat"):
        manager = BaseShare(conn, o_id)
    else:
        manager = BaseContainer(conn)

    form = None
    if action == "addnewcontainer":
        # Used within the jsTree to add a new Project, Dataset, Tag,
        # Tagset etc under a specified parent OR top-level
        if not request.method == "POST":
            return JsonResponse(
                {"Error": "Must use POST to create container"}, status=405
            )

        form = ContainerForm(data=request.POST.copy())
        if form.is_valid():
            logger.debug("Create new in %s: %s" % (o_type, str(form.cleaned_data)))
            name = form.cleaned_data["name"]
            description = form.cleaned_data["description"]
            owner = form.cleaned_data["owner"]

            if o_type == "project" and hasattr(manager, o_type) and o_id > 0:
                oid = manager.createDataset(name, description, owner=owner)
            elif o_type == "tagset" and o_id > 0:
                oid = manager.createTag(name, description, owner=owner)
            elif request.POST.get("folder_type") in (
                "project",
                "screen",
                "dataset",
                "tag",
                "tagset",
            ):
                # No parent specified. We can create orphaned 'project',
                # 'dataset' etc.
                folder_type = request.POST.get("folder_type")
                if folder_type == "dataset":
                    oid = manager.createDataset(
                        name,
                        description,
                        owner=owner,
                        img_ids=request.POST.getlist("image", None),
                    )
                else:
                    oid = conn.createContainer(
                        folder_type, name, description, owner=owner
                    )
            else:
                return HttpResponseServerError("Object does not exist")
            rdict = {"bad": "false", "id": oid}
            return JsonResponse(rdict)
        else:
            d = dict()
            for e in form.errors.items():
                d.update({e[0]: unicode(e[1])})
            rdict = {"bad": "true", "errs": d}
            return JsonResponse(rdict)

    elif action == "edit":
        # form for editing Shares only
        if o_id is None:
            raise Http404("No share ID")
        if o_type == "share" and int(o_id) > 0:
            template = "webclient/public/share_form.html"
            manager.getMembers(o_id)
            manager.getComments(o_id)
            experimenters = list(conn.getExperimenters())
            experimenters.sort(key=lambda x: x.getOmeName().lower())
            initial = {
                "message": manager.share.message,
                "expiration": "",
                "shareMembers": manager.membersInShare,
                "enable": manager.share.active,
                "experimenters": experimenters,
            }
            if manager.share.getExpireDate() is not None:
                initial["expiration"] = manager.share.getExpireDate().strftime(
                    "%Y-%m-%d"
                )
            form = ShareForm(initial=initial)  # 'guests':share.guestsInShare,
            context = {"manager": manager, "form": form}
    elif action == "save":
        # Handles submission of the 'edit' form above. TODO: not used now?
        if not request.method == "POST":
            return HttpResponseRedirect(
                reverse("manage_action_containers", args=["edit", o_type, o_id])
            )
        if o_type == "share":
            experimenters = list(conn.getExperimenters())
            experimenters.sort(key=lambda x: x.getOmeName().lower())
            form = ShareForm(
                initial={"experimenters": experimenters}, data=request.POST.copy()
            )
            if form.is_valid():
                logger.debug("Update share: %s" % (str(form.cleaned_data)))
                message = form.cleaned_data["message"]
                expiration = form.cleaned_data["expiration"]
                members = form.cleaned_data["members"]
                # guests = request.POST['guests']
                enable = form.cleaned_data["enable"]
                host = "%s?server=%i" % (
                    request.build_absolute_uri(
                        reverse("load_template", args=["public"])
                    ),
                    int(conn.server_id),
                )
                manager.updateShareOrDiscussion(
                    host, message, members, enable, expiration
                )
                r = "enable" if enable else "disable"
                return HttpResponse(r)
            else:
                template = "webclient/public/share_form.html"
                context = {"share": manager, "form": form}
        else:
            return HttpResponseServerError("Object does not exist")
    elif action == "editname":
        # start editing 'name' in-line
        if hasattr(manager, o_type) and o_id > 0:
            obj = getattr(manager, o_type)
            template = "webclient/ajax_form/container_form_ajax.html"
            if o_type == "tag":
                txtValue = obj.textValue
            else:
                txtValue = obj.getName()
            form = ContainerNameForm(initial={"name": txtValue})
            context = {"manager": manager, "form": form}
        else:
            return HttpResponseServerError("Object does not exist")
    elif action == "savename":
        # Save name edit in-line
        if not request.method == "POST":
            return HttpResponseRedirect(
                reverse("manage_action_containers", args=["edit", o_type, o_id])
            )
        if hasattr(manager, o_type) and o_id > 0:
            form = ContainerNameForm(data=request.POST.copy())
            if form.is_valid():
                logger.debug("Update name form:" + str(form.cleaned_data))
                name = form.cleaned_data["name"]
                rdict = {"bad": "false", "o_type": o_type}
                manager.updateName(o_type, name)
                return JsonResponse(rdict)
            else:
                d = dict()
                for e in form.errors.items():
                    d.update({e[0]: unicode(e[1])})
                rdict = {"bad": "true", "errs": d}
                return JsonResponse(rdict)
        else:
            return HttpResponseServerError("Object does not exist")
    elif action == "editdescription":
        # start editing description in-line
        if hasattr(manager, o_type) and o_id > 0:
            obj = getattr(manager, o_type)
            template = "webclient/ajax_form/container_form_ajax.html"
            form = ContainerDescriptionForm(initial={"description": obj.description})
            context = {"manager": manager, "form": form}
        else:
            return HttpResponseServerError("Object does not exist")
    elif action == "savedescription":
        # Save editing of description in-line
        if not request.method == "POST":
            return HttpResponseServerError(
                "Action '%s' on the '%s' id:%s cannot be complited"
                % (action, o_type, o_id)
            )
        if hasattr(manager, o_type) and o_id > 0:
            form = ContainerDescriptionForm(data=request.POST.copy())
            if form.is_valid():
                logger.debug("Update name form:" + str(form.cleaned_data))
                description = form.cleaned_data["description"]
                manager.updateDescription(o_type, description)
                rdict = {"bad": "false"}
                return JsonResponse(rdict)
            else:
                d = dict()
                for e in form.errors.items():
                    d.update({e[0]: unicode(e[1])})
                rdict = {"bad": "true", "errs": d}
                return JsonResponse(rdict)
        else:
            return HttpResponseServerError("Object does not exist")
    elif action == "remove":
        # Handles removal of comment, tag from
        # Object etc.
        # E.g. image-123  or image-1|image-2
        parents = request.POST["parent"]
        try:
            manager.remove(parents.split("|"))
        except Exception as x:
            logger.error(traceback.format_exc())
            rdict = {"bad": "true", "errs": str(x)}
            return JsonResponse(rdict)

        rdict = {"bad": "false"}
        return JsonResponse(rdict)
    elif action == "removefromshare":
        image_id = request.POST.get("source")
        try:
            manager.removeImage(image_id)
        except Exception as x:
            logger.error(traceback.format_exc())
            rdict = {"bad": "true", "errs": str(x)}
            return JsonResponse(rdict)
        rdict = {"bad": "false"}
        return JsonResponse(rdict)
    elif action == "delete":
        # Handles delete of a file attached to object.
        child = toBoolean(request.POST.get("child"))
        anns = toBoolean(request.POST.get("anns"))
        try:
            handle = manager.deleteItem(child, anns)
            request.session["callback"][str(handle)] = {
                "job_type": "delete",
                "delmany": False,
                "did": o_id,
                "dtype": o_type,
                "status": "in progress",
                "error": 0,
                "dreport": _formatReport(handle),
                "start_time": datetime.datetime.now(),
            }
            request.session.modified = True
        except Exception as x:
            logger.error(
                "Failed to delete: %r" % {"did": o_id, "dtype": o_type}, exc_info=True
            )
            rdict = {"bad": "true", "errs": str(x)}
        else:
            rdict = {"bad": "false"}
        return JsonResponse(rdict)
    elif action == "deletemany":
        # Handles multi-delete from jsTree.
        object_ids = {
            "Image": request.POST.getlist("image"),
            "Dataset": request.POST.getlist("dataset"),
            "Project": request.POST.getlist("project"),
            "Annotation": request.POST.getlist("tag"),
            "Screen": request.POST.getlist("screen"),
            "Plate": request.POST.getlist("plate"),
            "Well": request.POST.getlist("well"),
            "PlateAcquisition": request.POST.getlist("acquisition"),
        }
        child = toBoolean(request.POST.get("child"))
        anns = toBoolean(request.POST.get("anns"))
        logger.debug(
            "Delete many: child? %s anns? %s object_ids %s" % (child, anns, object_ids)
        )
        try:
            for key, ids in object_ids.items():
                if ids is not None and len(ids) > 0:
                    handle = manager.deleteObjects(key, ids, child, anns)
                    if key == "PlateAcquisition":
                        key = "Plate Run"  # for nicer user message
                    dMap = {
                        "job_type": "delete",
                        "start_time": datetime.datetime.now(),
                        "status": "in progress",
                        "error": 0,
                        "dreport": _formatReport(handle),
                        "dtype": key,
                    }
                    if len(ids) > 1:
                        dMap["delmany"] = len(ids)
                        dMap["did"] = ids
                    else:
                        dMap["delmany"] = False
                        dMap["did"] = ids[0]
                    request.session["callback"][str(handle)] = dMap
            request.session.modified = True
        except Exception:
            logger.error(
                "Failed to delete: %r" % {"did": ids, "dtype": key}, exc_info=True
            )
            # Ajax error handling will allow user to submit bug report
            raise
        else:
            rdict = {"bad": "false"}
        return JsonResponse(rdict)
    context["template"] = template
    return context
