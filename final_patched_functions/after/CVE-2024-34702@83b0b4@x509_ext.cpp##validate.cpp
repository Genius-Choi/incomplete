void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& /*issuer*/,
      const std::vector<std::shared_ptr<const X509_Certificate>>& cert_path,
      std::vector<std::set<Certificate_Status_Code>>& cert_status,
      size_t pos)
   {
   // This is much smaller limit than in Botan3 because here name constraint checks
   // are much more expensive due to optimizations which would be difficult to
   // backport here.
   const size_t MAX_NC_COMPARES = (1 << 12);
   const size_t total_constraints = m_name_constraints.permitted().size() + m_name_constraints.excluded().size();

   if(!m_name_constraints.permitted().empty() || !m_name_constraints.excluded().empty())
      {
      if(!subject.is_CA_cert())
         {
         cert_status.at(pos).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);
         }

      const bool issuer_name_constraint_critical =
         subject.is_critical("X509v3.NameConstraints");

      // Check that all subordinate certs pass the name constraint
      for(size_t j = 0; j < pos; ++j)
         {
         const auto& cert = cert_path.at(j);

         const size_t total_names =
            cert->subject_dn().dn_info().size() +
            cert->subject_alt_name().get_attributes().size();

         if(total_names * total_constraints >= MAX_NC_COMPARES) {
            cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);
            continue;
         }

         if(!m_name_constraints.is_permitted(*cert, issuer_name_constraint_critical)) {
            cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);
            continue;
         }

         if(m_name_constraints.is_excluded(*cert, issuer_name_constraint_critical)) {
            cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);
            continue;
         }
      }
   }
}
