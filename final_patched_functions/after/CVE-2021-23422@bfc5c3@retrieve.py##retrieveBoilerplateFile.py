def retrieveBoilerplateFile(doc, name, group=None, status=None, error=True, allowLocal=True):
    # Looks in three or four locations, in order:
    # the folder the spec source is in, the group's boilerplate folder, the megagroup's boilerplate folder, and the generic boilerplate folder.
    # In each location, it first looks for the file specialized on status, and then for the generic file.
    # Filenames must be of the format NAME.include or NAME-STATUS.include
    if group is None and doc.md.group is not None:
        group = doc.md.group.lower()
    if status is None:
        if doc.md.status is not None:
            status = doc.md.status
        elif doc.md.rawStatus is not None:
            status = doc.md.rawStatus
    megaGroup, status = splitStatus(status)

    searchLocally = allowLocal and doc.md.localBoilerplate[name]

    def boilerplatePath(*segs):
        return scriptPath("boilerplate", *segs)

    statusFile = f"{name}-{status}.include"
    genericFile = f"{name}.include"
    sources = []
    if searchLocally:
        sources.append(doc.inputSource.relative(statusFile))  # Can be None.
        sources.append(doc.inputSource.relative(genericFile))
    else:
        for f in (statusFile, genericFile):
            if doc.inputSource.cheaplyExists(f):
                warn(
                    (
                        "Found {0} next to the specification without a matching\n"
                        + "Local Boilerplate: {1} yes\n"
                        + "in the metadata. This include won't be found when building via a URL."
                    ).format(f, name)
                )
                # We should remove this after giving specs time to react to the warning:
                sources.append(doc.inputSource.relative(f))
    if group:
        sources.append(InputSource(boilerplatePath(group, statusFile), chroot=False))
        sources.append(InputSource(boilerplatePath(group, genericFile), chroot=False))
    if megaGroup:
        sources.append(InputSource(boilerplatePath(megaGroup, statusFile), chroot=False))
        sources.append(InputSource(boilerplatePath(megaGroup, genericFile), chroot=False))
    sources.append(InputSource(boilerplatePath(statusFile), chroot=False))
    sources.append(InputSource(boilerplatePath(genericFile), chroot=False))

    # Watch all the possible sources, not just the one that got used, because if
    # an earlier one appears, we want to rebuild.
    doc.recordDependencies(*sources)

    for source in sources:
        if source is not None:
            try:
                return source.read().content
            except OSError:
                # That input doesn't exist.
                pass
    else:
        if error:
            die(
                "Couldn't find an appropriate include file for the {0} inclusion, given group='{1}' and status='{2}'.",
                name,
                group,
                status,
            )
        return ""
