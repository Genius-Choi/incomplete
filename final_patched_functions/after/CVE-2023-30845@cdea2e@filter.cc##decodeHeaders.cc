Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(
    Envoy::Http::RequestHeaderMap& headers, bool) {
  ENVOY_LOG(debug, "Called ServiceControl Filter : {}", __func__);

  if (!headers.Method()) {
    rejectRequest(Envoy::Http::Code::BadRequest,
                  "No method in request headers.",
                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,
                                           utils::kRcDetailErrorTypeBadRequest,
                                           utils::kRcDetailErrorMissingMethod));
    return Envoy::Http::FilterHeadersStatus::StopIteration;
  } else if (!headers.Path()) {
    rejectRequest(Envoy::Http::Code::BadRequest, "No path in request headers.",
                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,
                                           utils::kRcDetailErrorTypeBadRequest,
                                           utils::kRcDetailErrorMissingPath));
    return Envoy::Http::FilterHeadersStatus::StopIteration;
  }

  // Make sure route is calculated
  auto route = decoder_callbacks_->route();

  // This shouldn't happen as the catch-all route match should catch all
  // the undefined requests.
  if (route == nullptr) {
    return Envoy::Http::FilterHeadersStatus::Continue;
  }

  handler_ = factory_.createHandler(headers, decoder_callbacks_, stats_);
  handler_->fillFilterState(*decoder_callbacks_->streamInfo().filterState());
  state_ = Calling;
  stopped_ = false;

  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();

  handler_->callCheck(headers, parent_span, *this);

  // If success happens synchronously, continue now.
  if (state_ == Complete) {
    return Envoy::Http::FilterHeadersStatus::Continue;
  }

  // Stop for now. If an async request is made, it will continue in onCheckDone.
  ENVOY_LOG(debug, "Called ServiceControl filter : Stop");
  stopped_ = true;
  return Envoy::Http::FilterHeadersStatus::StopIteration;
}
