int IniSection::setSectionProp (const YCPPath&p,const YCPValue&in, int what, int depth)
{
    string k = ip->changeCase (p->component_str (depth));
    // Find the matching sections.
    // If we need to recurse, choose one, creating if necessary
    // Otherwise set properties of all of the leaf sections,
    //  creating and deleting if the number of them does not match

    pair <IniSectionIdxIterator, IniSectionIdxIterator> r =
	isections.equal_range (k);
    IniSectionIdxIterator xi = r.first, xe = r.second;

    if (depth + 1 < p->length())
    {
	// recurse
	IniIterator si;
	if (xi == xe)
	{
	    // not found, need to add it;
	    y2debug ("Write: adding recursively %s to %s", k.c_str (), p->toString().c_str());

	    IniSection s (ip, k);
	    container.push_back (IniContainerElement (s));
	    isections.insert (IniSectionIndex::value_type (k, --container.end ()));

	    si = --container.end ();
	}
	else
	{
	    // there's something, choose last
	    si = (--xe)->second;
	}
	return si->s ().setSectionProp (p, in, what, depth+1);
    }
    else
    {
	// bottom level

	// make sure we have a list of values
	YCPList props;
	if (ip->repeatNames ())
	{
	    props = as_list (in, "property of section with repeat_names");
	    if (props.isNull())
		return -1;
	}
	else
	{
	    props->add (in);
	}
	int pi = 0, pe = props->size ();

	// Go simultaneously through the found sections
	// and the list of parameters, while _either_ lasts
	// Fewer sections-> add them, more sections-> delete them

	while (pi != pe || xi != xe)
	{
	    // watch out for validity of iterators!

	    if (pi == pe)
	    {
		// deleting a section
		delSection1 (xi++);
		// no ++pi
	    }
	    else
	    {
		YCPValue prop = props->value (pi);
		IniIterator si;
		if (xi == xe)
		{
		    ///need to add a section ...
		    y2debug ("Adding section %s", p->toString().c_str());
		    // prepare it to have its property set
		    // create it
		    IniSection s (ip, k);
		    s.dirty = true;
		    // insert and index
		    container.push_back (IniContainerElement (s));
		    isections.insert (IniSectionIndex::value_type (k, --container.end ()));
		    si = --container.end ();
		}
		else
		{
		    si = xi->second;
		}

		// set a section's property
		IniSection & s = si->s ();
		if (what == 0) {
		    YCPString str = as_string (prop, "section_comment");
		    if (str.isNull())
			return -1;
		    s.setComment (str->value_cstr());
		}
		else if (what == 1) {
		    YCPInteger i = as_integer (prop, "section_rewrite");
		    if (i.isNull())
			return -1;
		    s.setRewriteBy (i->value());
		}
		else if (what == 2) {
		    YCPInteger i = as_integer (prop, "section_type");
		    if (i.isNull())
			return -1;
		    s.setReadBy (i->value());
		}
		else if (what == 3) {
		    YCPBoolean b = as_boolean (prop, "section_private");
		    if (b.isNull())
			return -1;
		    s.setPrivate (b->value());
		}

		if (xi != xe)
		{
		    ++xi;
		}
		++pi;
	    }
	    // iterators have been advanced already
	}
	return 0;
    }
}
