def parse_type(item, location=None, sigs=None, custom_structs=None):
    # Base and custom types, e.g. num
    if isinstance(item, vy_ast.Name):
        if item.id in BASE_TYPES:
            return BaseType(item.id)
        elif (sigs is not None) and item.id in sigs:
            return InterfaceType(item.id)
        elif (custom_structs is not None) and (item.id in custom_structs):
            return make_struct_type(
                item.id, location, sigs, custom_structs[item.id], custom_structs,
            )
        else:
            raise InvalidType("Invalid base type: " + item.id, item)
    # Units, e.g. num (1/sec) or contracts
    elif isinstance(item, vy_ast.Call) and isinstance(item.func, vy_ast.Name):
        # Contract_types
        if item.func.id == "address":
            if sigs and item.args[0].id in sigs:
                return InterfaceType(item.args[0].id)
        # Struct types
        if (custom_structs is not None) and (item.func.id in custom_structs):
            return make_struct_type(
                item.id, location, sigs, custom_structs[item.id], custom_structs,
            )
        raise InvalidType("Units are no longer supported", item)
    # Subscripts
    elif isinstance(item, vy_ast.Subscript):
        # Fixed size lists or bytearrays, e.g. num[100]
        if isinstance(item.slice.value, vy_ast.Int):
            n_val = item.slice.value.n
            if not isinstance(n_val, int) or n_val <= 0:
                raise InvalidType(
                    "Arrays / ByteArrays must have a positive integral number of elements",
                    item.slice.value,
                )
            # ByteArray
            if getattr(item.value, "id", None) == "Bytes":
                return ByteArrayType(n_val)
            elif getattr(item.value, "id", None) == "String":
                return StringType(n_val)
            # List
            else:
                return ListType(
                    parse_type(item.value, location, sigs, custom_structs=custom_structs,), n_val,
                )
        elif item.value.id in ("HashMap",) and isinstance(item.slice.value, vy_ast.Tuple):
            keytype = parse_type(
                item.slice.value.elements[0], None, sigs, custom_structs=custom_structs,
            )
            return MappingType(
                keytype,
                parse_type(
                    item.slice.value.elements[1], location, sigs, custom_structs=custom_structs,
                ),
            )
        # Mappings, e.g. num[address]
        else:
            raise InvalidType("Unknown list type.", item)

    # Dicts, used to represent mappings, e.g. {uint: uint}. Key must be a base type
    elif isinstance(item, vy_ast.Dict):
        warnings.warn(
            "Anonymous structs have been removed in" " favor of named structs, see VIP300",
            DeprecationWarning,
        )
        raise InvalidType("Invalid type", item)
    elif isinstance(item, vy_ast.Tuple):
        members = [parse_type(x, location, custom_structs=custom_structs) for x in item.elements]
        return TupleType(members)
    else:
        raise InvalidType("Invalid type", item)
