Variant HHVM_FUNCTION(apc_add,
                      const Variant& key_or_array,
                      const Variant& var /* = null */,
                      int64_t ttl /* = 0 */) {
  if (!apcExtension::Enable) return false;

  if (key_or_array.isArray()) {
    Array valuesArr = key_or_array.toArray();

    // errors stores all keys corresponding to entries that could not be cached
    ArrayInit errors(valuesArr.size(), ArrayInit::Map{});

    for (ArrayIter iter(valuesArr); iter; ++iter) {
      Variant key = iter.first();
      if (!key.isString()) {
        throw_invalid_argument("apc key: (not a string)");
        return false;
      }
      Variant v = iter.second();

      auto const& strKey = key.toCStrRef();
      if (isKeyInvalid(strKey)) {
        throw_invalid_argument("apc key: (contains invalid characters)");
        return false;
      }

      if (!apc_store().add(strKey, v, ttl)) {
        errors.add(strKey, -1);
      }
    }
    return errors.toVariant();
  }

  if (!key_or_array.isString()) {
    throw_invalid_argument("apc key: (not a string)");
    return false;
  }
  String strKey = key_or_array.toString();
  if (isKeyInvalid(strKey)) {
    throw_invalid_argument("apc key: (contains invalid characters)");
    return false;
  }
  return apc_store().add(strKey, var, ttl);
}
