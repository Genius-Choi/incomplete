            [&](const DerivationOutput::CAFixed & dof) {
                auto & wanted = dof.ca.hash;

                // Replace the output by a fresh copy of itself to make sure
                // that there's no stale file descriptor pointing to it
                Path tmpOutput = actualPath + ".tmp";
                copyFile(actualPath, tmpOutput, true);
                renameFile(tmpOutput, actualPath);

                auto newInfo0 = newInfoFromCA(DerivationOutput::CAFloating {
                    .method = dof.ca.method,
                    .hashAlgo = wanted.algo,
                });

                /* Check wanted hash */
                assert(newInfo0.ca);
                auto & got = newInfo0.ca->hash;
                if (wanted != got) {
                    /* Throw an error after registering the path as
                       valid. */
                    worker.hashMismatch = true;
                    delayedException = std::make_exception_ptr(
                        BuildError("hash mismatch in fixed-output derivation '%s':\n  specified: %s\n     got:    %s",
                            worker.store.printStorePath(drvPath),
                            wanted.to_string(HashFormat::SRI, true),
                            got.to_string(HashFormat::SRI, true)));
                }
                if (!newInfo0.references.empty())
                    delayedException = std::make_exception_ptr(
                        BuildError("illegal path references in fixed-output derivation '%s'",
                            worker.store.printStorePath(drvPath)));

                return newInfo0;
            },
