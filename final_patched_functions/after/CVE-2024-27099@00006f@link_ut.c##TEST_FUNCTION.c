TEST_FUNCTION(link_receiver_frame_received_get_flow_fails_no_double_free_fails)
{
    // arrange
    LINK_HANDLE link = create_link(role_receiver);
    ON_ENDPOINT_FRAME_RECEIVED on_frame_received = NULL;
    int attach_result = attach_link(link, &on_frame_received);
    ASSERT_ARE_EQUAL(int, 0, attach_result);

    AMQP_VALUE performative = (AMQP_VALUE)0x5000;
    AMQP_VALUE descriptor = (AMQP_VALUE)0x5001;
    FLOW_HANDLE flow = NULL;
    uint32_t frame_payload_size = 30;
    const unsigned char payload_bytes[30] = { 0 };

    umock_c_reset_all_calls();
    STRICT_EXPECTED_CALL(amqpvalue_get_inplace_descriptor(performative))
        .SetReturn(descriptor);
    STRICT_EXPECTED_CALL(is_attach_type_by_descriptor(IGNORED_PTR_ARG))
        .SetReturn(false);
    STRICT_EXPECTED_CALL(is_flow_type_by_descriptor(IGNORED_PTR_ARG))
        .SetReturn(1);
    STRICT_EXPECTED_CALL(amqpvalue_get_flow(IGNORED_PTR_ARG, IGNORED_PTR_ARG))
        .CopyOutArgumentBuffer(2, &flow, sizeof(flow))
        .SetReturn(1);

    // act
    on_frame_received(link, performative, frame_payload_size, payload_bytes);

    // assert
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    // cleanup
    link_destroy(link);
}
