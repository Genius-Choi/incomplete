int HTPFileOpenWithRange(HtpState *s, HtpTxUserData *txud, const uint8_t *filename,
        uint16_t filename_len, const uint8_t *data, uint32_t data_len, uint64_t txid,
        bstr *rawvalue, HtpTxUserData *htud)
{
    SCEnter();
    uint16_t flags;

    DEBUG_VALIDATE_BUG_ON(s == NULL);

    // This function is only called STREAM_TOCLIENT from HtpResponseBodyHandle
    HTTPContentRange crparsed;
    if (HTPParseAndCheckContentRange(rawvalue, &crparsed, s, htud) != 0) {
        // range is invalid, fall back to classic open
        return HTPFileOpen(s, txud, filename, filename_len, data, data_len, txid, STREAM_TOCLIENT);
    }
    flags = FileFlowToFlags(s->f, STREAM_TOCLIENT);
    FileContainer *files = &txud->files_tc;

    // we open a file for this specific range
    if (FileOpenFileWithId(files, &htp_sbcfg, s->file_track_id++, filename, filename_len, data,
                data_len, flags) != 0) {
        SCReturnInt(-1);
    } else {
        const HTPCfgDir *cfg = &s->cfg->response;
        FileSetInspectSizes(files->tail, cfg->inspect_window, cfg->inspect_min_size);
    }
    txud->tx_data.files_opened++;

    if (FileSetRange(files, crparsed.start, crparsed.end) < 0) {
        SCLogDebug("set range failed");
    }

    // Then, we will try to handle reassembly of different ranges of the same file
    // TODO have the caller pass directly the tx
    htp_tx_t *tx = htp_list_get(s->conn->transactions, txid - s->tx_freed);
    if (!tx) {
        SCReturnInt(-1);
    }
    uint8_t *keyurl;
    uint32_t keylen;
    if (tx->request_hostname != NULL) {
        keylen = bstr_len(tx->request_hostname) + filename_len;
        keyurl = SCMalloc(keylen);
        if (keyurl == NULL) {
            SCReturnInt(-1);
        }
        memcpy(keyurl, bstr_ptr(tx->request_hostname), bstr_len(tx->request_hostname));
        memcpy(keyurl + bstr_len(tx->request_hostname), filename, filename_len);
    } else {
        // do not reassemble file without host info
        SCReturnInt(0);
    }
    DEBUG_VALIDATE_BUG_ON(htud->file_range);
    htud->file_range = HttpRangeContainerOpenFile(keyurl, keylen, s->f, &crparsed, &htp_sbcfg,
            filename, filename_len, flags, data, data_len);
    SCFree(keyurl);
    if (htud->file_range == NULL) {
        SCReturnInt(-1);
    }
    SCReturnInt(0);
}
