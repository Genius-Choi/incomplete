bool aws_php_thread_queue_drain(aws_php_thread_queue *queue) {
    assert(
        queue->thread_id == aws_thread_current_thread_id() &&
        "thread queue cannot be drained from a thread other than its home");
    aws_php_task drain_queue[AWS_PHP_THREAD_QUEUE_MAX_DEPTH];
    aws_mutex_lock(&queue->mutex);
    /* copy any queued tasks into the drain queue, then reset the queue */
    memcpy(drain_queue, queue->queue, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);
    memset(queue->queue, 0, sizeof(aws_php_task) * AWS_PHP_THREAD_QUEUE_MAX_DEPTH);
    queue->write_slot = 0;
    aws_mutex_unlock(&queue->mutex);

    bool did_work = false;
    for (int idx = 0; idx < AWS_PHP_THREAD_QUEUE_MAX_DEPTH; ++idx) {
        aws_php_task *task = &drain_queue[idx];
        if (!task->callback) {
            break;
        }
        did_work = true;
        task->callback(task->data);
        if (task->dtor) {
            task->dtor(task->data);
        }
    }

    return did_work;
}
