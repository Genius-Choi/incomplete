def passive_login():
    logger = logging.getLogger(__name__)

    user = flask_login.current_user

    remote_address = flask.request.remote_addr
    ip_check_enabled = settings().getBoolean(["server", "ipCheck", "enabled"])
    ip_check_trusted = settings().get(["server", "ipCheck", "trustedSubnets"])

    if isinstance(user, LocalProxy):
        # noinspection PyProtectedMember
        user = user._get_current_object()

    def login(u):
        # login known user
        if not u.is_anonymous:
            if not flask.g.identity or not flask.g.identity.id:
                # the user was just now found
                login_mechanism = octoprint.server.util.LoginMechanism.to_log(
                    flask.session.get("login_mechanism", "unknown")
                )
                auth_log(
                    f"Logging in user {u.get_id()} from {remote_address} via {login_mechanism}"
                )
            u = octoprint.server.userManager.login_user(u)

        flask_login.login_user(u)
        flask_principal.identity_changed.send(
            flask.current_app._get_current_object(),
            identity=flask_principal.Identity(u.get_id()),
        )
        if hasattr(u, "session"):
            flask.session["usersession.id"] = u.session
            flask.session["usersession.signature"] = session_signature(
                u.get_id(), u.session
            )
        flask.g.user = u

        eventManager().fire(Events.USER_LOGGED_IN, payload={"username": u.get_id()})

        return u

    def determine_user(u):
        if not u.is_anonymous and u.is_active:
            # known active user
            logger.info(f"Passively logging in user {u.get_id()} from {remote_address}")

        elif (
            settings().getBoolean(["accessControl", "autologinLocal"])
            and settings().get(["accessControl", "autologinAs"]) is not None
            and settings().get(["accessControl", "localNetworks"]) is not None
            and "active_logout" not in flask.request.cookies
            and remote_address
        ):
            # attempt local autologin
            autologin_as = settings().get(["accessControl", "autologinAs"])
            local_networks = _local_networks()
            logger.debug(
                "Checking if remote address {} is in localNetworks ({!r})".format(
                    remote_address, local_networks
                )
            )

            try:
                if netaddr.IPAddress(remote_address) in local_networks:
                    autologin_user = octoprint.server.userManager.find_user(autologin_as)
                    if autologin_user is not None and autologin_user.is_active:
                        logger.info(
                            f"Logging in user {autologin_as} from {remote_address} via autologin"
                        )
                        flask.session[
                            "login_mechanism"
                        ] = octoprint.server.util.LoginMechanism.AUTOLOGIN
                        flask.session["credentials_seen"] = False
                        return autologin_user
            except Exception:
                logger.exception(
                    "Could not autologin user {} from {} for networks {}".format(
                        autologin_as, remote_address, local_networks
                    )
                )

        if not u.is_active:
            # inactive user, switch to anonymous
            u = octoprint.server.userManager.anonymous_user_factory()

        return u

    user = login(determine_user(user))
    response = user.as_dict()
    response["_is_external_client"] = ip_check_enabled and not is_lan_address(
        remote_address, additional_private=ip_check_trusted
    )
    if flask.session.get("login_mechanism") is not None:
        response["_login_mechanism"] = flask.session.get("login_mechanism")
    response["_credentials_seen"] = to_api_credentials_seen(
        flask.session.get("credentials_seen", False)
    )
    return flask.jsonify(response)
