def abi_decode(lll_node, src, clamp=True, pos=None):
    os = o_list(lll_node, pos=pos)
    lll_ret = ["seq"]
    parent_abi_t = abi_type_of(lll_node.typ)
    for i, o in enumerate(os):
        abi_t = abi_type_of(o.typ)
        src_loc = LLLnode("src_loc", typ=o.typ, location=src.location)
        if parent_abi_t.is_complex_type():
            if abi_t.is_dynamic():
                # TODO optimize: special case where there is only one dynamic
                # member, the location is statically known.
                child_loc = ["add", "src", unwrap_location(src_loc)]
                child_loc = LLLnode.from_list(child_loc, typ=o.typ, location=src.location)
            else:
                child_loc = src_loc
            # descend into the child tuple
            lll_ret.append(abi_decode(o, child_loc, clamp=clamp, pos=pos))

        else:

            if clamp and _needs_clamp(o.typ, Encoding.ABI):
                src_loc = LLLnode.from_list(
                    ["with", "src_loc", src_loc, ["seq", clamp_basetype(src_loc), src_loc]],
                    typ=src_loc.typ,
                    location=src_loc.location,
                )
            else:
                pass

            lll_ret.append(make_setter(o, src_loc, location=o.location, pos=pos))

        if i + 1 == len(os):
            pass  # optimize out the last pointer increment
        else:
            sz = abi_t.embedded_static_size()
            lll_ret.append(["set", "src_loc", ["add", "src_loc", sz]])

    lll_ret = ["with", "src", src, ["with", "src_loc", "src", lll_ret]]

    return lll_ret
