static void parse_message(sdp_parser_t *p)
{
/*
   announcement =        proto-version
                         origin-field
                         session-name-field
                         information-field
                         uri-field
                         email-fields
                         phone-fields
                         connection-field
                         bandwidth-fields
                         time-fields
                         key-field
                         attribute-fields
                         media-descriptions
*/

  sdp_session_t *sdp = p->pr_session;
  char *record, *rest;
  char const *strip;
  char *message = p->pr_message;
  char field = '\0';
  sdp_list_t **emails = &sdp->sdp_emails;
  sdp_list_t **phones = &sdp->sdp_phones;
  sdp_bandwidth_t **bandwidths = &sdp->sdp_bandwidths;
  sdp_time_t **times = &sdp->sdp_time;
  sdp_repeat_t **repeats = NULL;
  sdp_zone_t **zones = NULL;
  sdp_attribute_t **attributes = &sdp->sdp_attributes;

  if (!STRICT(p))
    strip = SPACE TAB;		/* skip initial whitespace */
  else
    strip = "";

  p->pr_ok = 1;
  p->pr_session->sdp_size = sizeof(p->pr_session);

  /* Require that version comes first */
  record = next(&message, CRLF, strip);

  if (!su_strmatch(record, "v=0")) {
    if (!p->pr_config || !record || record[1] != '=') {
      parsing_error(p, "bad SDP message");
      return;
    }
  }
  else {
    record = next(&message, CRLF, strip);
  }

  /*
    XXX - the lines in SDP are in certain order, which we don't check here.
     For stricter parsing we might want to parse o= and s= next.
  */

  for (;
       record && p->pr_ok;
       record = next(&message, CRLF, strip)) {
    field = record[0];

    if (strlen(record) < 2) {
      return;
    }

    rest = record + 2; rest += strspn(rest, strip);

    if (record[1] != '=') {
      parsing_error(p, "bad line \"%s\"", record);
      return;
    }

    switch (field) {
    case 'o':
      parse_origin(p, rest, &sdp->sdp_origin);
      break;

    case 's':
      parse_subject(p, rest, &sdp->sdp_subject);
      break;

    case 'i':
      parse_information(p, rest, &sdp->sdp_information);
      break;

    case 'u':
      parse_uri(p, rest, &sdp->sdp_uri);
      break;

    case 'e':
      parse_email(p, rest, emails);
      emails = &(*emails)->l_next;
      break;

    case 'p':
      parse_phone(p, rest, phones);
      phones = &(*phones)->l_next;
      break;

    case 'c':
      parse_connection(p, rest, &sdp->sdp_connection);
      break;

    case 'b':
      parse_bandwidth(p, rest, bandwidths);
      bandwidths = &(*bandwidths)->b_next;
      break;

    case 't':
      parse_time(p, rest, times);
      repeats = &(*times)->t_repeat;
      zones = &(*times)->t_zone;
      times = &(*times)->t_next;
      break;

    case 'r':
      if (repeats)
	parse_repeat(p, rest, repeats);
      else
	parsing_error(p, "repeat field without time field");
      break;

    case 'z':
      if (zones)
	parse_zone(p, rest, zones), zones = NULL;
      else
	parsing_error(p, "zone field without time field");
      break;

    case 'k':
      parse_key(p, rest, &sdp->sdp_key);
      break;

    case 'a':
      parse_session_attr(p, rest, attributes);
      if (*attributes)
	attributes = &(*attributes)->a_next;
      break;

    case 'm':
      parse_descs(p, record, message, &sdp->sdp_media);
      post_session(p, sdp);
      return;

    default:
      parsing_error(p, "unknown field \"%s\"", record);
      return;
    }
  }

  post_session(p, sdp);
}
