parse_sym_line(buf, which_set)
char *buf;
int which_set;
{
    int val, i;
    struct symparse *symp;
    char *bufp, *commentp, *altp;

    if (strlen(buf) >= BUFSZ)
        buf[BUFSZ - 1] = '\0';
    /* convert each instance of whitespace (tabs, consecutive spaces)
       into a single space; leading and trailing spaces are stripped */
    mungspaces(buf);

    /* remove trailing comment, if any (this isn't strictly needed for
       individual symbols, and it won't matter if "X#comment" without
       separating space slips through; for handling or set description,
       symbol set creator is responsible for preceding '#' with a space
       and that comment itself doesn't contain " #") */
    if ((commentp = rindex(buf, '#')) != 0 && commentp[-1] == ' ')
        commentp[-1] = '\0';

    /* find the '=' or ':' */
    bufp = index(buf, '=');
    altp = index(buf, ':');
    if (!bufp || (altp && altp < bufp))
        bufp = altp;
    if (!bufp) {
        if (strncmpi(buf, "finish", 6) == 0) {
            /* end current graphics set */
            if (chosen_symset_start)
                chosen_symset_end = TRUE;
            chosen_symset_start = FALSE;
            return 1;
        }
        config_error_add("No \"finish\"");
        return 0;
    }
    /* skip '=' and space which follows, if any */
    ++bufp;
    if (*bufp == ' ')
        ++bufp;

    symp = match_sym(buf);
    if (!symp) {
        config_error_add("Unknown sym keyword");
        return 0;
    }

    if (!symset[which_set].name) {
        /* A null symset name indicates that we're just
           building a pick-list of possible symset
           values from the file, so only do that */
        if (symp->range == SYM_CONTROL) {
            struct symsetentry *tmpsp, *lastsp;

            for (lastsp = symset_list; lastsp; lastsp = lastsp->next)
                if (!lastsp->next)
                    break;
            switch (symp->idx) {
            case 0:
                tmpsp = (struct symsetentry *) alloc(sizeof *tmpsp);
                tmpsp->next = (struct symsetentry *) 0;
                if (!lastsp)
                    symset_list = tmpsp;
                else
                    lastsp->next = tmpsp;
                tmpsp->idx = symset_count++;
                tmpsp->name = dupstr(bufp);
                tmpsp->desc = (char *) 0;
                tmpsp->handling = H_UNK;
                /* initialize restriction bits */
                tmpsp->nocolor = 0;
                tmpsp->primary = 0;
                tmpsp->rogue = 0;
                break;
            case 2:
                /* handler type identified */
                tmpsp = lastsp; /* most recent symset */
                for (i = 0; known_handling[i]; ++i)
                    if (!strcmpi(known_handling[i], bufp)) {
                        tmpsp->handling = i;
                        break; /* for loop */
                    }
                break;
            case 3:
                /* description:something */
                tmpsp = lastsp; /* most recent symset */
                if (tmpsp && !tmpsp->desc)
                    tmpsp->desc = dupstr(bufp);
                break;
            case 5:
                /* restrictions: xxxx*/
                tmpsp = lastsp; /* most recent symset */
                for (i = 0; known_restrictions[i]; ++i) {
                    if (!strcmpi(known_restrictions[i], bufp)) {
                        switch (i) {
                        case 0:
                            tmpsp->primary = 1;
                            break;
                        case 1:
                            tmpsp->rogue = 1;
                            break;
                        }
                        break; /* while loop */
                    }
                }
                break;
            }
        }
        return 1;
    }
    if (symp->range) {
        if (symp->range == SYM_CONTROL) {
            switch (symp->idx) {
            case 0:
                /* start of symset */
                if (!strcmpi(bufp, symset[which_set].name)) {
                    /* matches desired one */
                    chosen_symset_start = TRUE;
                    /* these init_*() functions clear symset fields too */
                    if (which_set == ROGUESET)
                        init_rogue_symbols();
                    else if (which_set == PRIMARY)
                        init_primary_symbols();
                }
                break;
            case 1:
                /* finish symset */
                if (chosen_symset_start)
                    chosen_symset_end = TRUE;
                chosen_symset_start = FALSE;
                break;
            case 2:
                /* handler type identified */
                if (chosen_symset_start)
                    set_symhandling(bufp, which_set);
                break;
            /* case 3: (description) is ignored here */
            case 4: /* color:off */
                if (chosen_symset_start) {
                    if (bufp) {
                        if (!strcmpi(bufp, "true") || !strcmpi(bufp, "yes")
                            || !strcmpi(bufp, "on"))
                            symset[which_set].nocolor = 0;
                        else if (!strcmpi(bufp, "false")
                                 || !strcmpi(bufp, "no")
                                 || !strcmpi(bufp, "off"))
                            symset[which_set].nocolor = 1;
                    }
                }
                break;
            case 5: /* restrictions: xxxx*/
                if (chosen_symset_start) {
                    int n = 0;

                    while (known_restrictions[n]) {
                        if (!strcmpi(known_restrictions[n], bufp)) {
                            switch (n) {
                            case 0:
                                symset[which_set].primary = 1;
                                break;
                            case 1:
                                symset[which_set].rogue = 1;
                                break;
                            }
                            break; /* while loop */
                        }
                        n++;
                    }
                }
                break;
            }
        } else { /* !SYM_CONTROL */
            val = sym_val(bufp);
            if (chosen_symset_start) {
                if (which_set == PRIMARY) {
                    update_primary_symset(symp, val);
                } else if (which_set == ROGUESET) {
                    update_rogue_symset(symp, val);
                }
            }
        }
    }
    return 1;
}
