static int cjwt_verify_signature( cjwt_t *p_jwt, char *p_in, const char *p_sign )
{
    int ret = 0;
    int sz_signed = 0;
    unsigned char* signed_out = NULL;

    if( !p_jwt || !p_in || !p_sign ) {
        ret = EINVAL;
        goto end;
    }

    if( IS_RSA_ALG( p_jwt->header.alg ) ) {
        ret = cjwt_verify_rsa( p_jwt, p_in, p_sign );
        goto end;
    }

    //sign
    ret = cjwt_sign( p_jwt, &signed_out, p_in, &sz_signed );

    if( ret ) {
        ret = EINVAL;
        goto end;
    }

    //decode signature from input token
    size_t sz_p_sign = strlen( p_sign );
    size_t sz_decoded = b64url_get_decoded_buffer_size( sz_p_sign );
    uint8_t *signed_dec = malloc( sz_decoded + 1 );

    if( !signed_dec ) {
        ret = ENOMEM;
        goto err_decode;
    }

    memset( signed_dec, 0, ( sz_decoded + 1 ) );
    //decode
    int out_size = b64url_decode( ( uint8_t * )p_sign, sz_p_sign, signed_dec );

    if( !out_size ) {
        ret = EINVAL;
        goto err_match;
    }

    signed_dec[out_size] = '\0';
    cjwt_info( "Signature length : enc %d, signature %d\n",
               ( int )sz_signed, ( int )out_size );
    cjwt_info( "signed token : %s\n", signed_out );
    cjwt_info( "expected token signature  %s\n", signed_dec );

    if( sz_signed != out_size ) {
        cjwt_info( "Signature length mismatch: enc %d, signature %d\n",
                   ( int )sz_signed, ( int )out_size );
        ret = EINVAL;
        goto err_match;
    }

    if( 0 != CRYPTO_memcmp(signed_out, signed_dec, out_size) ) {
        ret = EINVAL;
    }

err_match:
    free( signed_dec );
err_decode:
    free( signed_out );
end:
    return ret;
}
