static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,
        const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,
        int list_id)
{
    SCEnter();

    InspectionBuffer *buffer =
            InspectionBufferMultipleForListGet(det_ctx, list_id, cbdata->local_id);
    if (buffer == NULL)
        return NULL;
    if (buffer->initialized)
        return buffer;

    int kw_thread_id;
    if (flags & STREAM_TOSERVER) {
        kw_thread_id = g_request_header_thread_id;
    } else {
        kw_thread_id = g_response_header_thread_id;
    }
    HttpMultiBufHeaderThreadData *hdr_td =
            DetectThreadCtxGetGlobalKeywordThreadCtx(det_ctx, kw_thread_id);
    if (unlikely(hdr_td == NULL)) {
        return NULL;
    }

    htp_tx_t *tx = (htp_tx_t *)cbdata->txv;
    htp_table_t *headers;
    if (flags & STREAM_TOSERVER) {
        headers = tx->request_headers;
    } else {
        headers = tx->response_headers;
    }
    size_t no_of_headers = htp_table_size(headers);
    if (cbdata->local_id == 0) {
        // We initialize a big buffer on first item
        // Then, we will just use parts of it
        hdr_td->len = 0;
        if (hdr_td->cap < no_of_headers) {
            void *new_buffer = SCRealloc(hdr_td->items, no_of_headers * sizeof(HttpMultiBufItem));
            if (unlikely(new_buffer == NULL)) {
                return NULL;
            }
            hdr_td->items = new_buffer;
            // zeroes the new part of the items
            memset(hdr_td->items + hdr_td->cap, 0,
                    (no_of_headers - hdr_td->cap) * sizeof(HttpMultiBufItem));
            hdr_td->cap = no_of_headers;
        }
        for (size_t i = 0; i < no_of_headers; i++) {
            htp_header_t *h = htp_table_get_index(headers, i, NULL);
            size_t size1 = bstr_size(h->name);
            size_t size2 = bstr_size(h->value);
            size_t size = size1 + size2 + 2;
            if (hdr_td->items[i].len < size) {
                // Use realloc, as this pointer is not freed until HttpMultiBufHeaderThreadDataFree
                hdr_td->items[i].buffer = SCRealloc(hdr_td->items[i].buffer, size);
                if (unlikely(hdr_td->items[i].buffer == NULL)) {
                    return NULL;
                }
            }
            memcpy(hdr_td->items[i].buffer, bstr_ptr(h->name), size1);
            hdr_td->items[i].buffer[size1] = ':';
            hdr_td->items[i].buffer[size1 + 1] = ' ';
            memcpy(hdr_td->items[i].buffer + size1 + 2, bstr_ptr(h->value), size2);
            hdr_td->items[i].len = size;
        }
        hdr_td->len = no_of_headers;
    }

    // cbdata->local_id is the index of the requested header buffer
    // hdr_td->len is the number of header buffers
    if (cbdata->local_id < hdr_td->len) {
        // we have one valid header buffer
        InspectionBufferSetupMulti(buffer, transforms, hdr_td->items[cbdata->local_id].buffer,
                hdr_td->items[cbdata->local_id].len);
        SCReturnPtr(buffer, "InspectionBuffer");
    } // else there are no more header buffer to get
    InspectionBufferSetupMultiEmpty(buffer);
    return NULL;
}
