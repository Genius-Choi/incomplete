tdirenter(
	struct tmount	*tm,
	struct tmpnode	*dir,		/* target directory to make entry in */
	char		*name,		/* name of entry */
	enum de_op	op,		/* entry operation */
	struct tmpnode	*fromparent,	/* source directory if rename */
	struct tmpnode	*tp,		/* source tmpnode, if link/rename */
	struct vattr	*va,
	struct tmpnode	**tpp,		/* return tmpnode, if create/mkdir */
	struct cred	*cred,
	caller_context_t *ctp)
{
	struct tdirent *tdp;
	struct tmpnode *found = NULL;
	int error = 0;
	char *s;

	/*
	 * tn_rwlock is held to serialize direnter and dirdeletes
	 */
	ASSERT(RW_WRITE_HELD(&dir->tn_rwlock));
	ASSERT(dir->tn_type == VDIR);

	/*
	 * Don't allow '/' characters in pathname component
	 * (thus in ufs_direnter()).
	 */
	for (s = name; *s; s++)
		if (*s == '/')
			return (EACCES);

	if (name[0] == '\0')
		panic("tdirenter: NULL name");

	/*
	 * For link and rename lock the source entry and check the link count
	 * to see if it has been removed while it was unlocked.
	 */
	if (op == DE_LINK || op == DE_RENAME) {
		if (tp != dir) {
			unsigned int tries = 0;

			/*
			 * If we are acquiring tp->tn_rwlock (for SOURCE)
			 * inside here, we must consider the following:
			 *
			 * - dir->tn_rwlock (TARGET) is already HELD (see
			 * above ASSERT()).
			 *
			 * - It is possible our SOURCE is a parent of our
			 * TARGET. Yes it's unusual, but it will return an
			 * error below via tdircheckpath().
			 *
			 * - It is also possible that another thread,
			 * concurrent to this one, is performing
			 * rmdir(TARGET), which means it will first acquire
			 * SOURCE's lock, THEN acquire TARGET's lock, which
			 * could result in this thread holding TARGET and
			 * trying for SOURCE, but the other thread holding
			 * SOURCE and trying for TARGET.  This is deadlock,
			 * and it's inducible.
			 *
			 * To prevent this, we borrow some techniques from UFS
			 * and rw_tryenter(), delaying if we fail, and
			 * if someone tweaks the number of backoff tries to be
			 * nonzero, return EBUSY after that number of tries.
			 */
			while (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {
				/*
				 * Sloppy, but this is a diagnostic so atomic
				 * increment would be overkill.
				 */
				tmpfs_rename_loops++;

				if (tmpfs_rename_backoff_tries != 0) {
					if (tries > tmpfs_rename_backoff_tries)
						return (EBUSY);
					tries++;
				}
				/*
				 * NOTE: We're still holding dir->tn_rwlock,
				 * so drop it over the delay, so any other
				 * thread can get its business done.
				 *
				 * No state change or state inspection happens
				 * prior to here, so it is not wholly dangerous
				 * to release-and-reacquire dir->tn_rwlock.
				 *
				 * Hold the vnode of dir in case it gets
				 * released by another thread, though.
				 */
				VN_HOLD(TNTOV(dir));
				rw_exit(&dir->tn_rwlock);
				delay(tmpfs_rename_backoff_delay);
				rw_enter(&dir->tn_rwlock, RW_WRITER);
				VN_RELE(TNTOV(dir));
			}
		}
		mutex_enter(&tp->tn_tlock);
		if (tp->tn_nlink == 0) {
			mutex_exit(&tp->tn_tlock);
			if (tp != dir)
				rw_exit(&tp->tn_rwlock);
			return (ENOENT);
		}

		if (tp->tn_nlink == MAXLINK) {
			mutex_exit(&tp->tn_tlock);
			if (tp != dir)
				rw_exit(&tp->tn_rwlock);
			return (EMLINK);
		}
		tp->tn_nlink++;
		gethrestime(&tp->tn_ctime);
		mutex_exit(&tp->tn_tlock);
		if (tp != dir)
			rw_exit(&tp->tn_rwlock);
	}

	/*
	 * This might be a "dangling detached directory".
	 * it could have been removed, but a reference
	 * to it kept in u_cwd.  don't bother searching
	 * it, and with any luck the user will get tired
	 * of dealing with us and cd to some absolute
	 * pathway.  *sigh*, thus in ufs, too.
	 */
	if (dir->tn_nlink == 0) {
		error = ENOENT;
		goto out;
	}

	/*
	 * If this is a rename of a directory and the parent is
	 * different (".." must be changed), then the source
	 * directory must not be in the directory hierarchy
	 * above the target, as this would orphan everything
	 * below the source directory.
	 */
	if (op == DE_RENAME) {
		if (tp == dir) {
			error = EINVAL;
			goto out;
		}
		if (tp->tn_type == VDIR) {
			if ((fromparent != dir) &&
			    (error = tdircheckpath(tp, dir, cred))) {
				goto out;
			}
		}
	}

	/*
	 * Search for the entry.  Return "found" if it exists.
	 */
	tdp = tmpfs_hash_lookup(name, dir, 1, &found);

	if (tdp) {
		ASSERT(found);
		switch (op) {
		case DE_CREATE:
		case DE_MKDIR:
			if (tpp) {
				*tpp = found;
				error = EEXIST;
			} else {
				tmpnode_rele(found);
			}
			break;

		case DE_RENAME:
			error = tdirrename(fromparent, tp,
			    dir, name, found, tdp, cred);
			if (error == 0) {
				if (found != NULL) {
					vnevent_rename_dest(TNTOV(found),
					    TNTOV(dir), name, ctp);
				}
			}

			tmpnode_rele(found);
			break;

		case DE_LINK:
			/*
			 * Can't link to an existing file.
			 */
			error = EEXIST;
			tmpnode_rele(found);
			break;
		}
	} else {

		/*
		 * The entry does not exist. Check write permission in
		 * directory to see if entry can be created.
		 */
		if (error = tmp_taccess(dir, VWRITE, cred))
			goto out;
		if (op == DE_CREATE || op == DE_MKDIR) {
			/*
			 * Make new tmpnode and directory entry as required.
			 */
			error = tdirmaketnode(dir, tm, va, op, &tp, cred);
			if (error)
				goto out;
		}
		if (error = tdiraddentry(dir, tp, name, op, fromparent)) {
			if (op == DE_CREATE || op == DE_MKDIR) {
				/*
				 * Unmake the inode we just made.
				 */
				rw_enter(&tp->tn_rwlock, RW_WRITER);
				if ((tp->tn_type) == VDIR) {
					ASSERT(tdp == NULL);
					/*
					 * cleanup allocs made by tdirinit()
					 */
					tdirtrunc(tp);
				}
				mutex_enter(&tp->tn_tlock);
				tp->tn_nlink = 0;
				mutex_exit(&tp->tn_tlock);
				gethrestime(&tp->tn_ctime);
				rw_exit(&tp->tn_rwlock);
				tmpnode_rele(tp);
				tp = NULL;
			}
		} else if (tpp) {
			*tpp = tp;
		} else if (op == DE_CREATE || op == DE_MKDIR) {
			tmpnode_rele(tp);
		}
	}

out:
	if (error && (op == DE_LINK || op == DE_RENAME)) {
		/*
		 * Undo bumped link count.
		 */
		DECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);
		gethrestime(&tp->tn_ctime);
	}
	return (error);
}
