  def import_csv
    Log.add_info(request, params.inspect)

    return unless request.post?

    file = params[:imp_file]
    mode = params[:mode]
    enc = params[:enc]

    all_users = User.find_all

    user_names = []
#   user_emails = []
    if mode == 'add'
      all_users.each do |user|
        user_names << user.name
#       user_emails << user.email
      end
    end

    @imp_errs = {}
    count = -1  # 0 for Header-line
    users = [] 

    opt = {
      :skip_blanks => true
    }

    csv = file.read
    begin
      csv.encode!(Encoding::UTF_8, enc, {:invalid => :replace, :undef => :replace, :replace => ' '})
    rescue => evar
      Log.add_error(request, evar)
    end

    found_update = false

    CSV.parse(csv, opt) do |row|
      unless row.first.nil?
        next if row.first.lstrip.index('#') == 0
      end
      next if row.compact.empty?

      count += 1
      next if count == 0  # for Header Line

      user = User.parse_csv_row(row)

      check = user.check_import(mode, user_names)  #, user_emails

      @imp_errs[count] = check unless check.empty?

      users << user

      if mode == 'update'
        update_user = all_users.find do |u|
          u.id == user.id
        end
        unless update_user.nil?
          all_users.delete(update_user)
          found_update = true
        end
      end
    end

    if users.empty?
      @imp_errs[0] = [t('user.nothing_to_import')]
    else
      if mode == 'update'
        if found_update
          user_admin = users.find do |user|
            user.admin?(User::AUTH_USER)
          end
          if user_admin.nil?
            @imp_errs[0] = [t('user.no_user_auth_import')]
          end

        else
          @imp_errs[0] = [t('user.nothing_to_update')]
        end
      end
    end

    # Create or Update
    count = 0
    @imp_cnt = 0
    if @imp_errs.empty?
      users.each do |user|
        count += 1
        begin
          user_id = user.id

          user.save!

          if user_id.nil?
            user.setup
          end

          @imp_cnt += 1

        rescue => evar
          @imp_errs[count] = [t('user.failed_to_save') + evar.to_s]
        end
      end
    end

    # Delete
    # Actually, the correct order of the process is Delete -> Create,
    # not to duplicate a User Name.
    #    3: morita   <- Delete
    #     : morita   <- Create
    # But such a case is most likely to be considered as a 
    # user's miss-operation. We can avoid this case with
    # 'opposite' process.
    del_cnt = 0
    if @imp_errs.empty? and mode == 'update'
      all_users.each do |user|
        user.destroy
        del_cnt += 1
      end
    end

    # Set order to display
    User.update_xorder(nil, User::XORDER_MAX)

    titles = User.get_config_titles
    unless titles.nil?
      idx = 0
      titles.each do |title|
        User.update_xorder title, idx
        idx += 1
      end
    end

    if @imp_errs.empty?
      flash[:notice] = users.length.to_s + t('user.imported')
      if del_cnt > 0
        flash[:notice] << '<br/>' + del_cnt.to_s + t('user.deleted')
      end
    end

    list
    render(:action => 'list')
  end
