gerb_fopen(char const * filename)
{
    gerb_file_t *fd;
    struct stat statinfo;
    
    dprintf("---> Entering gerb_fopen, filename = %s\n", filename);

    fd = g_new(gerb_file_t, 1);
    if (fd == NULL) {
	return NULL;
    }

    dprintf("     Doing fopen\n");
    /* fopen() can't open files with non ASCII filenames on windows */
    fd->fd = g_fopen(filename, "rb");
    if (fd->fd == NULL) {
	g_free(fd);
	return NULL;
    }

    dprintf("     Doing fstat\n");
    fd->ptr = 0;
    fd->fileno = fileno(fd->fd);
    if (fstat(fd->fileno, &statinfo) < 0) {
	fclose(fd->fd);
	g_free(fd);
	return NULL;
    }

    dprintf("     Checking S_ISREG\n");
    if (!S_ISREG(statinfo.st_mode)) {
	fclose(fd->fd);
	g_free(fd);
	errno = EISDIR;
	return NULL;
    }

    dprintf("     Checking statinfo.st_size\n");
    if ((int)statinfo.st_size == 0) {
	fclose(fd->fd);
	g_free(fd);
	errno = EIO; /* More compatible with the world outside Linux */
	return NULL;
    }

#ifdef HAVE_SYS_MMAN_H

    dprintf("     Doing mmap\n");
    fd->datalen = (int)statinfo.st_size;
    fd->data = (char *)mmap(0, statinfo.st_size, PROT_READ, MAP_PRIVATE, 
			    fd->fileno, 0);
    if(fd->data == MAP_FAILED) {
	fclose(fd->fd);
	g_free(fd);
	fd = NULL;
    }

#else
    /* all systems without mmap, not only MINGW32 */

    dprintf("     Doing calloc\n");
    fd->datalen = (int)statinfo.st_size;
    fd->data = calloc(1, statinfo.st_size + 1);
    if (fd->data == NULL) {
        fclose(fd->fd);
        g_free(fd);
        return NULL;
    }
    if (fread((void*)fd->data, 1, statinfo.st_size, fd->fd) != statinfo.st_size) {
        fclose(fd->fd);
	g_free(fd->data);
        g_free(fd);
	return NULL;
    }
    rewind (fd->fd);

#endif

    dprintf("     Setting filename\n");
    fd->filename = g_strdup(filename);

    dprintf("<--- Leaving gerb_fopen\n");
    return fd;
} /* gerb_fopen */
