def parse_regular_functions(
    o, regular_functions, sigs, external_interfaces, global_ctx, default_function
):
    # check for payable/nonpayable external functions to optimize nonpayable assertions
    func_types = [i._metadata["type"] for i in global_ctx._defs]
    mutabilities = [i.mutability for i in func_types if i.visibility == FunctionVisibility.EXTERNAL]
    has_payable = any(i == StateMutability.PAYABLE for i in mutabilities)
    has_nonpayable = any(i != StateMutability.PAYABLE for i in mutabilities)

    is_default_payable = (
        default_function is not None
        and default_function._metadata["type"].mutability == StateMutability.PAYABLE
    )

    # TODO streamline the nonpayable check logic

    # when a contract has a payable default function and at least one nonpayable
    # external function, we must perform the nonpayable check on every function
    check_per_function = is_default_payable and has_nonpayable

    # generate LLL for regular functions
    payable_funcs = []
    nonpayable_funcs = []
    internal_funcs = []
    add_gas = func_init_lll().gas

    for func_node in regular_functions:
        func_type = func_node._metadata["type"]
        func_lll, frame_start, frame_size = generate_lll_for_function(
            func_node, {**{"self": sigs}, **external_interfaces}, global_ctx, check_per_function
        )

        if func_type.visibility == FunctionVisibility.INTERNAL:
            internal_funcs.append(func_lll)

        elif func_type.mutability == StateMutability.PAYABLE:
            add_gas += 30  # CMC 20210910 why?
            payable_funcs.append(func_lll)

        else:
            add_gas += 30  # CMC 20210910 why?
            nonpayable_funcs.append(func_lll)

        func_lll.total_gas += add_gas

        # update sigs with metadata gathered from compiling the function so that
        # we can handle calls to self
        # TODO we only need to do this for internal functions; external functions
        # cannot be called via `self`
        sig = FunctionSignature.from_definition(func_node, external_interfaces, global_ctx._structs)
        sig.gas = func_lll.total_gas
        sig.frame_start = frame_start
        sig.frame_size = frame_size
        sigs[sig.name] = sig

    # generate LLL for fallback function
    if default_function:
        fallback_lll, _frame_start, _frame_size = generate_lll_for_function(
            default_function,
            {**{"self": sigs}, **external_interfaces},
            global_ctx,
            # include a nonpayble check here if the contract only has a default function
            check_per_function or not regular_functions,
        )
    else:
        fallback_lll = LLLnode.from_list(["revert", 0, 0], typ=None, annotation="Default function")

    if check_per_function:
        external_seq = ["seq"] + payable_funcs + nonpayable_funcs

    else:
        # payable functions are placed prior to nonpayable functions
        # and seperated by a nonpayable assertion
        external_seq = ["seq"]
        if has_payable:
            external_seq += payable_funcs
        if has_nonpayable:
            external_seq.append(["assert", ["iszero", "callvalue"]])
            external_seq += nonpayable_funcs

    # bytecode is organized by: external functions, fallback fn, internal functions
    # this way we save gas and reduce bytecode by not jumping over internal functions
    runtime = [
        "seq",
        func_init_lll(),
        ["with", "_calldata_method_id", ["mload", 0], external_seq],
        ["seq_unchecked", ["label", "fallback"], fallback_lll],
    ]
    runtime.extend(internal_funcs)

    # TODO CMC 20210911 why does the lll have a trailing 0
    o.append(["return", 0, ["lll", runtime, 0]])
    return o, runtime
