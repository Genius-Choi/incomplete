    def compile(raise_errors: false, force: false)
      return if compiled? && !force
      return if component_class == ViewComponent::Base

      component_class.superclass.compile(raise_errors: raise_errors) if should_compile_superclass?
      subclass_instance_methods = component_class.instance_methods(false)

      if subclass_instance_methods.include?(:with_content) && raise_errors
        raise ViewComponent::ComponentError.new(
          "#{component_class} implements a reserved method, `#with_content`.\n\n" \
          "To fix this issue, change the name of the method."
        )
      end

      if template_errors.present?
        raise ViewComponent::TemplateError.new(template_errors) if raise_errors

        return false
      end

      if subclass_instance_methods.include?(:before_render_check)
        ViewComponent::Deprecation.deprecation_warning(
          "`before_render_check`", :"`before_render`"
        )
      end

      if raise_errors
        component_class.validate_initialization_parameters!
        component_class.validate_collection_parameter!
      end

      templates.each do |template|
        # Remove existing compiled template methods,
        # as Ruby warns when redefining a method.
        method_name = call_method_name(template[:variant])
        @variants_rendering_templates << template[:variant]

        redefinition_lock.synchronize do
          component_class.silence_redefinition_of_method(method_name)
          # rubocop:disable Style/EvalWithLocation
          component_class.class_eval <<-RUBY, template[:path], 0
          def #{method_name}
            #{compiled_template(template[:path])}
          end
          RUBY
          # rubocop:enable Style/EvalWithLocation
        end
      end

      define_render_template_for

      component_class.build_i18n_backend

      CompileCache.register(component_class)
    end
