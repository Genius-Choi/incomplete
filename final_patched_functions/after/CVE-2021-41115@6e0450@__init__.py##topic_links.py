def topic_links(linkifiers_key: int, topic_name: str) -> List[Dict[str, str]]:
    matches: List[Dict[str, Union[str, int]]] = []
    linkifiers = linkifiers_for_realm(linkifiers_key)

    options = re2.Options()
    options.log_errors = False
    for linkifier in linkifiers:
        raw_pattern = linkifier["pattern"]
        url_format_string = linkifier["url_format"]
        try:
            pattern = re2.compile(prepare_linkifier_pattern(raw_pattern), options=options)
        except re2.error:
            # An invalid regex shouldn't be possible here, and logging
            # here on an invalid regex would spam the logs with every
            # message sent; simply move on.
            continue
        for m in pattern.finditer(topic_name):
            match_details = m.groupdict()
            match_text = match_details["linkifier_actual_match"]
            # We format the linkifier's url string using the matched text.
            # Also, we include the matched text in the response, so that our clients
            # don't have to implement any logic of their own to get back the text.
            matches += [
                dict(
                    url=url_format_string % match_details,
                    text=match_text,
                    index=topic_name.find(match_text),
                )
            ]

    # Also make raw URLs navigable.
    for sub_string in basic_link_splitter.split(topic_name):
        link_match = re.match(get_web_link_regex(), sub_string)
        if link_match:
            actual_match_url = link_match.group("url")
            result = urlsplit(actual_match_url)
            if not result.scheme:
                if not result.netloc:
                    i = (result.path + "/").index("/")
                    result = result._replace(netloc=result.path[:i], path=result.path[i:])
                url = result._replace(scheme="https").geturl()
            else:
                url = actual_match_url
            matches.append(
                dict(url=url, text=actual_match_url, index=topic_name.find(actual_match_url))
            )

    # In order to preserve the order in which the links occur, we sort the matched text
    # based on its starting index in the topic. We pop the index field before returning.
    matches = sorted(matches, key=lambda k: k["index"])
    return [{k: str(v) for k, v in match.items() if k != "index"} for match in matches]
