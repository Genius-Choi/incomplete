static int _open_as_other(char *path_name, batch_job_launch_msg_t *req)
{
	pid_t child;
	gids_t *gids;
	int pipe[2];
	int fd = -1, rc = 0;

	if (!(gids = _gids_cache_lookup(req->user_name, req->gid))) {
		error("%s: gids_cache_lookup for %s failed",
		      __func__, req->user_name);
		return -1;
	}

	if ((rc = container_g_create(req->job_id))) {
		error("%s: container_g_create(%u): %m", __func__, req->job_id);
		_dealloc_gids(gids);
		return -1;
	}

	/* child process will setuid to the user, register the process
	 * with the container, and open the file for us. */
	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe) != 0) {
		error("%s: Failed to open pipe: %m", __func__);
		_dealloc_gids(gids);
		return -1;
	}

	child = fork();
	if (child == -1) {
		error("%s: fork failure", __func__);
		_dealloc_gids(gids);
		close(pipe[0]);
		close(pipe[1]);
		return -1;
	} else if (child > 0) {
		close(pipe[0]);
		(void) waitpid(child, &rc, 0);
		_dealloc_gids(gids);
		if (WIFEXITED(rc) && (WEXITSTATUS(rc) == 0))
			fd = _receive_fd(pipe[1]);
		close(pipe[1]);
		return fd;
	}

	/* child process below here */

	close(pipe[1]);

	/* container_g_add_pid needs to be called in the
	 * forked process part of the fork to avoid a race
	 * condition where if this process makes a file or
	 * detacts itself from a child before we add the pid
	 * to the container in the parent of the fork. */
	if (container_g_add_pid(req->job_id, getpid(), req->uid)) {
		error("%s container_g_add_pid(%u): %m", __func__, req->job_id);
		exit(SLURM_ERROR);
	}

	/* The child actually performs the I/O and exits with
	 * a return code, do not return! */

	/*********************************************************************\
	 * NOTE: It would be best to do an exec() immediately after the fork()
	 * in order to help prevent a possible deadlock in the child process
	 * due to locks being set at the time of the fork and being freed by
	 * the parent process, but not freed by the child process. Performing
	 * the work inline is done for simplicity. Note that the logging
	 * performed by error() should be safe due to the use of
	 * atfork_install_handlers() as defined in src/common/log.c.
	 * Change the code below with caution.
	\*********************************************************************/

	if (setgroups(gids->ngids, gids->gids) < 0) {
		error("%s: uid: %u setgroups failed: %m", __func__, req->uid);
		exit(errno);
	}
	_dealloc_gids(gids);

	if (setgid(req->gid) < 0) {
		error("%s: uid:%u setgid(%u): %m", __func__, req->uid,req->gid);
		exit(errno);
	}
	if (setuid(req->uid) < 0) {
		error("%s: getuid(%u): %m", __func__, req->uid);
		exit(errno);
	}

	fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644);
	if (fd == -1) {
		error("%s: uid:%u can't open `%s`: %m",
		      __func__, req->uid, path_name);
		exit(errno);
	}
	_send_back_fd(pipe[0], fd);
	close(fd);
	exit(SLURM_SUCCESS);
}
