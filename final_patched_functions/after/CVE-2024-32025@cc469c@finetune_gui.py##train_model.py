def train_model(
    headless,
    print_only,
    pretrained_model_name_or_path,
    v2,
    v_parameterization,
    sdxl_checkbox,
    train_dir,
    image_folder,
    output_dir,
    dataset_config,
    logging_dir,
    max_resolution,
    min_bucket_reso,
    max_bucket_reso,
    batch_size,
    flip_aug,
    masked_loss,
    caption_metadata_filename,
    latent_metadata_filename,
    full_path,
    learning_rate,
    lr_scheduler,
    lr_warmup,
    dataset_repeats,
    train_batch_size,
    epoch,
    save_every_n_epochs,
    mixed_precision,
    save_precision,
    seed,
    num_cpu_threads_per_process,
    learning_rate_te,
    learning_rate_te1,
    learning_rate_te2,
    train_text_encoder,
    full_bf16,
    generate_caption_database,
    generate_image_buckets,
    save_model_as,
    caption_extension,
    # use_8bit_adam,
    xformers,
    clip_skip,
    num_processes,
    num_machines,
    multi_gpu,
    gpu_ids,
    main_process_port,
    save_state,
    save_state_on_train_end,
    resume,
    gradient_checkpointing,
    gradient_accumulation_steps,
    block_lr,
    mem_eff_attn,
    shuffle_caption,
    output_name,
    max_token_length,
    max_train_epochs,
    max_train_steps,
    max_data_loader_n_workers,
    full_fp16,
    color_aug,
    model_list,  # Keep this. Yes, it is unused here but required given the common list used
    cache_latents,
    cache_latents_to_disk,
    use_latent_files,
    keep_tokens,
    persistent_data_loader_workers,
    bucket_no_upscale,
    random_crop,
    bucket_reso_steps,
    v_pred_like_loss,
    caption_dropout_every_n_epochs,
    caption_dropout_rate,
    optimizer,
    optimizer_args,
    lr_scheduler_args,
    noise_offset_type,
    noise_offset,
    noise_offset_random_strength,
    adaptive_noise_scale,
    multires_noise_iterations,
    multires_noise_discount,
    ip_noise_gamma,
    ip_noise_gamma_random_strength,
    sample_every_n_steps,
    sample_every_n_epochs,
    sample_sampler,
    sample_prompts,
    additional_parameters,
    loss_type,
    huber_schedule,
    huber_c,
    vae_batch_size,
    min_snr_gamma,
    weighted_captions,
    save_every_n_steps,
    save_last_n_steps,
    save_last_n_steps_state,
    use_wandb,
    wandb_api_key,
    wandb_run_name,
    log_tracker_name,
    log_tracker_config,
    scale_v_pred_loss_like_noise_pred,
    sdxl_cache_text_encoder_outputs,
    sdxl_no_half_vae,
    min_timestep,
    max_timestep,
    extra_accelerate_launch_args,
):
    # Get list of function parameters and values
    parameters = list(locals().items())
    
    log.debug(f"headless = {headless} ; print_only = {print_only}")
    
    log.info(f"Start Finetuning...")

    if train_dir != "" and not os.path.exists(train_dir):
        os.mkdir(train_dir)

    if not validate_paths(
        output_dir=output_dir,
        pretrained_model_name_or_path=pretrained_model_name_or_path,
        finetune_image_folder=image_folder,
        headless=headless,
        logging_dir=logging_dir,
        log_tracker_config=log_tracker_config,
        resume=resume,
        dataset_config=dataset_config,
    ):
        return

    if not print_only and check_if_model_exist(
        output_name, output_dir, save_model_as, headless
    ):
        return

    if dataset_config:
        log.info(
            "Dataset config toml file used, skipping caption json file, image buckets, total_steps, train_batch_size, gradient_accumulation_steps, epoch, reg_factor, max_train_steps creation..."
        )
    else:
        # create caption json file
        if generate_caption_database:
            run_cmd = rf'"{PYTHON}" "{scriptdir}/sd-scripts/finetune/merge_captions_to_metadata.py"'
            if caption_extension == "":
                run_cmd += f' --caption_extension=".caption"'
            else:
                run_cmd += f" --caption_extension={caption_extension}"
            run_cmd += rf' "{image_folder}"'
            run_cmd += rf' "{train_dir}/{caption_metadata_filename}"'
            if full_path:
                run_cmd += f" --full_path"

            log.info(run_cmd)

            env = os.environ.copy()
            env["PYTHONPATH"] = (
                rf"{scriptdir}{os.pathsep}{scriptdir}/sd-scripts{os.pathsep}{env.get('PYTHONPATH', '')}"
            )
            env["TF_ENABLE_ONEDNN_OPTS"] = "0"

            if not print_only:
                # Run the command
                subprocess.run(run_cmd, env=env)

        # create images buckets
        if generate_image_buckets:
            run_cmd = rf'"{PYTHON}" "{scriptdir}/sd-scripts/finetune/prepare_buckets_latents.py"'
            run_cmd += rf' "{image_folder}"'
            run_cmd += rf' "{train_dir}/{caption_metadata_filename}"'
            run_cmd += rf' "{train_dir}/{latent_metadata_filename}"'
            run_cmd += rf' "{pretrained_model_name_or_path}"'
            run_cmd += f" --batch_size={batch_size}"
            run_cmd += f" --max_resolution={max_resolution}"
            run_cmd += f" --min_bucket_reso={min_bucket_reso}"
            run_cmd += f" --max_bucket_reso={max_bucket_reso}"
            run_cmd += f" --mixed_precision={mixed_precision}"
            # if flip_aug:
            #     run_cmd += f' --flip_aug'
            if full_path:
                run_cmd += f" --full_path"
            if sdxl_checkbox and sdxl_no_half_vae:
                log.info(
                    "Using mixed_precision = no because no half vae is selected..."
                )
                run_cmd += f' --mixed_precision="no"'

            log.info(run_cmd)

            env = os.environ.copy()
            env["PYTHONPATH"] = (
                rf"{scriptdir}{os.pathsep}{scriptdir}/sd-scripts{os.pathsep}{env.get('PYTHONPATH', '')}"
            )
            env["TF_ENABLE_ONEDNN_OPTS"] = "0"

            if not print_only:
                # Run the command
                subprocess.run(run_cmd, env=env)

        image_num = len(
            [
                f
                for f, lower_f in (
                    (file, file.lower()) for file in os.listdir(image_folder)
                )
                if lower_f.endswith((".jpg", ".jpeg", ".png", ".webp"))
            ]
        )
        log.info(f"image_num = {image_num}")

        repeats = int(image_num) * int(dataset_repeats)
        log.info(f"repeats = {str(repeats)}")

        # calculate max_train_steps
        max_train_steps = int(
            math.ceil(
                float(repeats)
                / int(train_batch_size)
                / int(gradient_accumulation_steps)
                * int(epoch)
            )
        )

        # Divide by two because flip augmentation create two copied of the source images
        if flip_aug and max_train_steps:
            max_train_steps = int(math.ceil(float(max_train_steps) / 2))

    if max_train_steps != "":
        log.info(f"max_train_steps = {max_train_steps}")
        lr_warmup_steps = round(float(int(lr_warmup) * int(max_train_steps) / 100))
    else:
        lr_warmup_steps = 0
    log.info(f"lr_warmup_steps = {lr_warmup_steps}")

    run_cmd = "accelerate launch"

    run_cmd += AccelerateLaunch.run_cmd(
        num_processes=num_processes,
        num_machines=num_machines,
        multi_gpu=multi_gpu,
        gpu_ids=gpu_ids,
        main_process_port=main_process_port,
        num_cpu_threads_per_process=num_cpu_threads_per_process,
        mixed_precision=mixed_precision,
        extra_accelerate_launch_args=extra_accelerate_launch_args,
    )

    if sdxl_checkbox:
        run_cmd += rf' "{scriptdir}/sd-scripts/sdxl_train.py"'
    else:
        run_cmd += rf' "{scriptdir}/sd-scripts/fine_tune.py"'

    in_json = (
        rf"{train_dir}/{latent_metadata_filename}"
        if use_latent_files == "Yes"
        else rf"{train_dir}/{caption_metadata_filename}"
    )
    cache_text_encoder_outputs = sdxl_checkbox and sdxl_cache_text_encoder_outputs
    no_half_vae = sdxl_checkbox and sdxl_no_half_vae

    # Initialize a dictionary with always-included keyword arguments
    kwargs_for_training = {
        "adaptive_noise_scale": adaptive_noise_scale,
        "block_lr": block_lr,
        "bucket_no_upscale": bucket_no_upscale,
        "bucket_reso_steps": bucket_reso_steps,
        "cache_latents": cache_latents,
        "cache_latents_to_disk": cache_latents_to_disk,
        "caption_dropout_every_n_epochs": caption_dropout_every_n_epochs,
        "caption_dropout_rate": caption_dropout_rate,
        "caption_extension": caption_extension,
        "clip_skip": clip_skip,
        "color_aug": color_aug,
        "dataset_config": dataset_config,
        "dataset_repeats": dataset_repeats,
        "enable_bucket": True,
        "flip_aug": flip_aug,
        "masked_loss": masked_loss,
        "full_bf16": full_bf16,
        "full_fp16": full_fp16,
        "gradient_accumulation_steps": gradient_accumulation_steps,
        "gradient_checkpointing": gradient_checkpointing,
        "in_json": in_json,
        "ip_noise_gamma": ip_noise_gamma,
        "ip_noise_gamma_random_strength": ip_noise_gamma_random_strength,
        "keep_tokens": keep_tokens,
        "learning_rate": learning_rate,
        "logging_dir": logging_dir,
        "log_tracker_name": log_tracker_name,
        "log_tracker_config": log_tracker_config,
        "lr_scheduler": lr_scheduler,
        "lr_scheduler_args": lr_scheduler_args,
        "lr_warmup_steps": lr_warmup_steps,
        "max_bucket_reso": max_bucket_reso,
        "max_data_loader_n_workers": max_data_loader_n_workers,
        "max_resolution": max_resolution,
        "max_timestep": max_timestep,
        "max_token_length": max_token_length,
        "max_train_epochs": max_train_epochs,
        "max_train_steps": max_train_steps,
        "mem_eff_attn": mem_eff_attn,
        "min_bucket_reso": min_bucket_reso,
        "min_snr_gamma": min_snr_gamma,
        "min_timestep": min_timestep,
        "mixed_precision": mixed_precision,
        "multires_noise_discount": multires_noise_discount,
        "multires_noise_iterations": multires_noise_iterations,
        "noise_offset": noise_offset,
        "noise_offset_random_strength": noise_offset_random_strength,
        "noise_offset_type": noise_offset_type,
        "optimizer": optimizer,
        "optimizer_args": optimizer_args,
        "output_dir": output_dir,
        "output_name": output_name,
        "persistent_data_loader_workers": persistent_data_loader_workers,
        "pretrained_model_name_or_path": pretrained_model_name_or_path,
        "random_crop": random_crop,
        "resume": resume,
        "save_every_n_epochs": save_every_n_epochs,
        "save_every_n_steps": save_every_n_steps,
        "save_last_n_steps": save_last_n_steps,
        "save_last_n_steps_state": save_last_n_steps_state,
        "save_model_as": save_model_as,
        "save_precision": save_precision,
        "save_state": save_state,
        "save_state_on_train_end": save_state_on_train_end,
        "scale_v_pred_loss_like_noise_pred": scale_v_pred_loss_like_noise_pred,
        "seed": seed,
        "shuffle_caption": shuffle_caption,
        "train_batch_size": train_batch_size,
        "train_data_dir": image_folder,
        "train_text_encoder": train_text_encoder,
        "use_wandb": use_wandb,
        "v2": v2,
        "v_parameterization": v_parameterization,
        "v_pred_like_loss": v_pred_like_loss,
        "vae_batch_size": vae_batch_size,
        "wandb_api_key": wandb_api_key,
        "wandb_run_name": wandb_run_name,
        "weighted_captions": weighted_captions,
        "xformers": xformers,
        "additional_parameters": additional_parameters,
        "loss_type": loss_type,
        "huber_schedule": huber_schedule,
        "huber_c": huber_c,
    }

    # Conditionally include specific keyword arguments based on sdxl_checkbox
    if sdxl_checkbox:
        kwargs_for_training["cache_text_encoder_outputs"] = cache_text_encoder_outputs
        kwargs_for_training["learning_rate_te1"] = learning_rate_te1
        kwargs_for_training["learning_rate_te2"] = learning_rate_te2
        kwargs_for_training["no_half_vae"] = no_half_vae
    else:
        kwargs_for_training["learning_rate_te"] = learning_rate_te

    # Pass the dynamically constructed keyword arguments to the function
    run_cmd += run_cmd_advanced_training(**kwargs_for_training)

    run_cmd += run_cmd_sample(
        sample_every_n_steps,
        sample_every_n_epochs,
        sample_sampler,
        sample_prompts,
        output_dir,
    )

    if print_only:
        log.warning(
            "Here is the trainer command as a reference. It will not be executed:\n"
        )
        print(run_cmd)

        save_to_file(run_cmd)
    else:
        # Saving config file for model
        current_datetime = datetime.now()
        formatted_datetime = current_datetime.strftime("%Y%m%d-%H%M%S")
        # config_dir = os.path.dirname(os.path.dirname(train_data_dir))
        file_path = os.path.join(output_dir, f"{output_name}_{formatted_datetime}.json")

        log.info(f"Saving training config to {file_path}...")

        SaveConfigFile(
            parameters=parameters,
            file_path=file_path,
            exclusion=["file_path", "save_as", "headless", "print_only"],
        )

        log.info(run_cmd)

        env = os.environ.copy()
        env["PYTHONPATH"] = (
            rf"{scriptdir}{os.pathsep}{scriptdir}/sd-scripts{os.pathsep}{env.get('PYTHONPATH', '')}"
        )
        env["TF_ENABLE_ONEDNN_OPTS"] = "0"

        # Run the command
        executor.execute_command(run_cmd=run_cmd, env=env)
