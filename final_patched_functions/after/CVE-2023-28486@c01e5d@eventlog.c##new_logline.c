new_logline(int event_type, int flags, struct eventlog_args *args,
    const struct eventlog *evlog)
{
    const struct eventlog_config *evl_conf = eventlog_getconf();
    const char *iolog_file;
    const char *tty, *tsid = NULL;
    char exit_str[(((sizeof(int) * 8) + 2) / 3) + 2];
    char sessid[7], offsetstr[64] = "";
    struct sudo_lbuf lbuf;
    int i;
    debug_decl(new_logline, SUDO_DEBUG_UTIL);

    sudo_lbuf_init(&lbuf, NULL, 0, NULL, 0);

    if (ISSET(flags, EVLOG_RAW) || evlog == NULL) {
	if (args->reason != NULL) {
	    if (args->errstr != NULL) {
		sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "%s: %s",
		    args->reason, args->errstr);
	    } else {
		sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "%s", args->reason);
	    }
	    if (sudo_lbuf_error(&lbuf))
		goto oom;
	}
	debug_return_str(lbuf.buf);
    }

    /* A TSID may be a sudoers-style session ID or a free-form string. */
    iolog_file = evlog->iolog_file;
    if (iolog_file != NULL) {
	if (IS_SESSID(iolog_file)) {
	    sessid[0] = iolog_file[0];
	    sessid[1] = iolog_file[1];
	    sessid[2] = iolog_file[3];
	    sessid[3] = iolog_file[4];
	    sessid[4] = iolog_file[6];
	    sessid[5] = iolog_file[7];
	    sessid[6] = '\0';
	    tsid = sessid;
	} else {
	    tsid = iolog_file;
	}
	if (sudo_timespecisset(&evlog->iolog_offset)) {
	    /* Only write up to two significant digits for the decimal part. */
	    if (evlog->iolog_offset.tv_nsec > 10000000) {
		(void)snprintf(offsetstr, sizeof(offsetstr), "@%lld.%02ld",
		    (long long)evlog->iolog_offset.tv_sec,
		    evlog->iolog_offset.tv_nsec / 10000000);
	    } else if (evlog->iolog_offset.tv_sec != 0) {
		(void)snprintf(offsetstr, sizeof(offsetstr), "@%lld",
		    (long long)evlog->iolog_offset.tv_sec);
	    }
	}
    }

    /* Sudo-format logs use the short form of the ttyname. */
    if ((tty = evlog->ttyname) != NULL) {
	if (strncmp(tty, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)
	    tty += sizeof(_PATH_DEV) - 1;
    }

    /*
     * Format the log line as an lbuf, escaping control characters in
     * octal form (#0nn).  Error checking (ENOMEM) is done at the end.
     */
    if (args->reason != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "%s%s", args->reason,
	    args->errstr ? " : " : " ; ");
    }
    if (args->errstr != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "%s ; ", args->errstr);
    }
    if (evlog->submithost != NULL && !evl_conf->omit_hostname) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "HOST=%s ; ",
	    evlog->submithost);
    }
    if (tty != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "TTY=%s ; ", tty);
    }
    if (evlog->runchroot != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "CHROOT=%s ; ",
	    evlog->runchroot);
    }
    if (evlog->runcwd != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "PWD=%s ; ",
	    evlog->runcwd);
    }
    if (evlog->runuser != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "USER=%s ; ",
	    evlog->runuser);
    }
    if (evlog->rungroup != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "GROUP=%s ; ",
	    evlog->rungroup);
    }
    if (tsid != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "TSID=%s%s ; ", tsid,
	    offsetstr);
    }
    if (evlog->env_add != NULL && evlog->env_add[0] != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, "ENV=%s",
	    evlog->env_add[0]);
	for (i = 1; evlog->env_add[i] != NULL; i++) {
	    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, " %s",
		evlog->env_add[i]);
	}
    }
    if (evlog->command != NULL) {
	sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL|LBUF_ESC_BLANK,
	    "COMMAND=%s", evlog->command);
	if (evlog->argv != NULL && evlog->argv[0] != NULL) {
	    for (i = 1; evlog->argv[i] != NULL; i++) {
		sudo_lbuf_append(&lbuf, " ");
		if (strchr(evlog->argv[i], ' ') != NULL) {
		    /* Wrap args containing spaces in single quotes. */
		    sudo_lbuf_append(&lbuf, "'");
		    sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL|LBUF_ESC_QUOTE,
			"%s", evlog->argv[i]);
		    sudo_lbuf_append(&lbuf, "'");
		} else {
		    /* Escape quotes here too for consistency. */
		    sudo_lbuf_append_esc(&lbuf,
			LBUF_ESC_CNTRL|LBUF_ESC_BLANK|LBUF_ESC_QUOTE,
			"%s", evlog->argv[i]);
		}
	    }
	}
	if (event_type == EVLOG_EXIT) {
	    if (evlog->signal_name != NULL) {
		sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, " ; SIGNAL=%s",
		    evlog->signal_name);
	    }
	    if (evlog->exit_value != -1) {
		(void)snprintf(exit_str, sizeof(exit_str), "%d",
		    evlog->exit_value);
		sudo_lbuf_append_esc(&lbuf, LBUF_ESC_CNTRL, " ; EXIT=%s",
		    exit_str);
	    }
	}
    }
    if (!sudo_lbuf_error(&lbuf))
	debug_return_str(lbuf.buf);
oom:
    sudo_lbuf_destroy(&lbuf);
    sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
    debug_return_str(NULL);
}
