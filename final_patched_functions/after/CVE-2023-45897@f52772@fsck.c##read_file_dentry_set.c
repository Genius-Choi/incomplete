static int read_file_dentry_set(struct exfat_de_iter *iter,
				struct exfat_inode **new_node, int *skip_dentries)
{
	struct exfat_dentry *file_de, *stream_de, *dentry;
	struct exfat_inode *node = NULL;
	int i, ret;
	bool need_delete = false;
	uint16_t checksum;

	ret = exfat_de_iter_get(iter, 0, &file_de);
	if (ret || file_de->type != EXFAT_FILE) {
		exfat_err("failed to get file dentry\n");
		return -EINVAL;
	}

	checksum = file_calc_checksum(iter);
	if (checksum != le16_to_cpu(file_de->file_checksum)) {
		if (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,
				    "the checksum of a file is wrong"))
			need_delete = true;
		*skip_dentries = 1;
		goto skip_dset;
	}

	if (file_de->file_num_ext < 2) {
		if (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,
				    "a file has too few secondary count. %d",
				    file_de->file_num_ext))
			need_delete = true;
		*skip_dentries = 1;
		goto skip_dset;
	}

	ret = exfat_de_iter_get(iter, 1, &stream_de);
	if (ret || stream_de->type != EXFAT_STREAM) {
		if (repair_file_ask(iter, NULL, ER_DE_STREAM,
				    "failed to get stream dentry"))
			need_delete = true;
		*skip_dentries = 2;
		goto skip_dset;
	}

	*new_node = NULL;
	node = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));
	if (!node)
		return -ENOMEM;

	for (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {
		ret = exfat_de_iter_get(iter, i, &dentry);
		if (ret || dentry->type != EXFAT_NAME) {
			if (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,
						     "failed to get name dentry")) {
				exfat_de_iter_get_dirty(iter, 0, &file_de);
				file_de->file_num_ext = i - 1;
				break;
			}
			*skip_dentries = i + 1;
			goto skip_dset;
		}

		memcpy(node->name +
		       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,
		       sizeof(dentry->name_unicode));
	}

	ret = check_name_dentry_set(iter, node);
	if (ret) {
		*skip_dentries = file_de->file_num_ext + 1;
		goto skip_dset;
	}

	if (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {
		ret = handle_dot_dotdot_filename(iter, dentry,
				stream_de->stream_name_len);
		if (ret < 0) {
			*skip_dentries = file_de->file_num_ext + 1;
			goto skip_dset;
		}
	}

	node->first_clus = le32_to_cpu(stream_de->stream_start_clu);
	node->is_contiguous =
		((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);
	node->size = le64_to_cpu(stream_de->stream_size);

	if (node->size < le64_to_cpu(stream_de->stream_valid_size)) {
		*skip_dentries = file_de->file_num_ext + 1;
		if (repair_file_ask(iter, node, ER_FILE_VALID_SIZE,
				    "valid size %" PRIu64 " greater than size %" PRIu64,
				    le64_to_cpu(stream_de->stream_valid_size),
				    node->size)) {
			exfat_de_iter_get_dirty(iter, 1, &stream_de);
			stream_de->stream_valid_size =
					stream_de->stream_size;
		} else {
			*skip_dentries = file_de->file_num_ext + 1;
			goto skip_dset;
		}
	}

	*skip_dentries = (file_de->file_num_ext + 1);
	*new_node = node;
	return 0;
skip_dset:
	if (need_delete) {
		exfat_de_iter_get_dirty(iter, 0, &dentry);
		dentry->type &= EXFAT_DELETE;
	}
	for (i = 1; i < *skip_dentries; i++) {
		exfat_de_iter_get(iter, i, &dentry);
		if (dentry->type == EXFAT_FILE)
			break;
		if (need_delete) {
			exfat_de_iter_get_dirty(iter, i, &dentry);
			dentry->type &= EXFAT_DELETE;
		}
	}
	*skip_dentries = i;
	*new_node = NULL;
	exfat_free_inode(node);
	return need_delete ? 1 : -EINVAL;
}
