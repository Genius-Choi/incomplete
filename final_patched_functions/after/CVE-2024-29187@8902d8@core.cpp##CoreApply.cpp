extern "C" HRESULT CoreApply(
    __in BURN_ENGINE_STATE* pEngineState,
    __in_opt HWND hwndParent
    )
{
    HRESULT hr = S_OK;
    HANDLE hLock = NULL;
    BOOL fApplyBegan = FALSE;
    BOOL fApplyInitialize = FALSE;
    BOOL fElevated = FALSE;
    BOOL fRegistered = FALSE;
    BOOL fSuspend = FALSE;
    BOOTSTRAPPER_APPLY_RESTART restart = BOOTSTRAPPER_APPLY_RESTART_NONE;
    BURN_APPLY_CONTEXT applyContext = { };
    BOOL fDeleteApplyCs = FALSE;
    BURN_CACHE_THREAD_CONTEXT cacheThreadContext = { };
    DWORD dwCacheExitCode = 0;
    BOOL fRollbackCache = FALSE;
    DWORD dwPhaseCount = 0;
    BOOTSTRAPPER_APPLYCOMPLETE_ACTION applyCompleteAction = BOOTSTRAPPER_APPLYCOMPLETE_ACTION_NONE;

    if (!pEngineState->fPlanned)
    {
        ExitOnFailure(hr = E_INVALIDSTATE, "Apply cannot be done without a successful Plan.");
    }
    else if (pEngineState->plan.fAffectedMachineState)
    {
        ExitOnFailure(hr = E_INVALIDSTATE, "Plans cannot be applied multiple times.");
    }

    fApplyBegan = TRUE;

    LogId(REPORT_STANDARD, MSG_APPLY_BEGIN);

    // Ensure any previous attempts to execute are reset.
    ApplyReset(&pEngineState->userExperience, &pEngineState->packages);

    if (pEngineState->plan.cCacheActions)
    {
        ++dwPhaseCount;
    }
    if (pEngineState->plan.cExecuteActions)
    {
        ++dwPhaseCount;
    }

    hr = UserExperienceOnApplyBegin(&pEngineState->userExperience, dwPhaseCount);
    ExitOnRootFailure(hr, "BA aborted apply begin.");

    if (pEngineState->plan.fDowngrade)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_VERSION);
        UserExperienceOnApplyDowngrade(&pEngineState->userExperience, &hr);

        ExitFunction();
    }

    pEngineState->plan.fAffectedMachineState = pEngineState->plan.fCanAffectMachineState;

    hr = ApplyLock(FALSE, &hLock);
    ExitOnFailure(hr, "Another per-user setup is already executing.");

    pEngineState->plan.fApplying = TRUE;

    // Initialize only after getting a lock.
    fApplyInitialize = TRUE;
    ApplyInitialize();

    pEngineState->userExperience.hwndApply = hwndParent;

    hr = ApplySetVariables(&pEngineState->variables);
    ExitOnFailure(hr, "Failed to set initial apply variables.");

    // If the plan is empty of work to do, skip everything.
    if (!(pEngineState->plan.cRegistrationActions || pEngineState->plan.cCacheActions || pEngineState->plan.cExecuteActions || pEngineState->plan.cCleanActions))
    {
        LogId(REPORT_STANDARD, MSG_APPLY_SKIPPED);
        ExitFunction();
    }

    fDeleteApplyCs = TRUE;
    ::InitializeCriticalSection(&applyContext.csApply);

    // Ensure the engine is cached to the working path.
    if (!pEngineState->sczBundleEngineWorkingPath)
    {
        hr = CacheBundleToWorkingDirectory(pEngineState->internalCommand.fInitiallyElevated, &pEngineState->cache, pEngineState->registration.sczExecutableName, &pEngineState->section, &pEngineState->sczBundleEngineWorkingPath);
        ExitOnFailure(hr, "Failed to cache engine to working directory.");
    }

    // Elevate.
    if (pEngineState->plan.fPerMachine)
    {
        hr = CoreElevate(pEngineState, WM_BURN_APPLY, pEngineState->userExperience.hwndApply);
        ExitOnFailure(hr, "Failed to elevate.");

        hr = ElevationApplyInitialize(pEngineState->companionConnection.hPipe, &pEngineState->userExperience, &pEngineState->variables, &pEngineState->plan);
        ExitOnFailure(hr, "Failed to initialize apply in elevated process.");

        fElevated = TRUE;
    }

    // Register.
    if (pEngineState->plan.fCanAffectMachineState)
    {
        fRegistered = TRUE;
        hr = ApplyRegister(pEngineState);
        ExitOnFailure(hr, "Failed to register bundle.");
    }

    // Cache.
    if (pEngineState->plan.cCacheActions)
    {
        // Launch the cache thread.
        cacheThreadContext.pEngineState = pEngineState;
        cacheThreadContext.pApplyContext = &applyContext;

        applyContext.hCacheThread = ::CreateThread(NULL, 0, CacheThreadProc, &cacheThreadContext, 0, NULL);
        ExitOnNullWithLastError(applyContext.hCacheThread, hr, "Failed to create cache thread.");

        fRollbackCache = TRUE;

        // If we're not caching in parallel, wait for the cache thread to terminate.
        if (!pEngineState->fParallelCacheAndExecute)
        {
            hr = ThrdWaitForCompletion(applyContext.hCacheThread, INFINITE, &dwCacheExitCode);
            ExitOnFailure(hr, "Failed to wait for cache thread before execute.");

            hr = (HRESULT)dwCacheExitCode;
            ExitOnFailure(hr, "Failed while caching, aborting execution.");

            ReleaseHandle(applyContext.hCacheThread);
        }
    }

    // Execute.
    if (pEngineState->plan.cExecuteActions)
    {
        hr = ApplyExecute(pEngineState, &applyContext, &fSuspend, &restart);
        UserExperienceExecutePhaseComplete(&pEngineState->userExperience, hr); // signal that execute completed.
    }

    // Wait for cache thread to terminate, this should return immediately unless we're waiting for layout to complete.
    if (applyContext.hCacheThread)
    {
        HRESULT hrCached = ThrdWaitForCompletion(applyContext.hCacheThread, INFINITE, &dwCacheExitCode);
        ExitOnFailure(hrCached, "Failed to wait for cache thread after execute.");

        if (SUCCEEDED(hr))
        {
            hr = (HRESULT)dwCacheExitCode;
        }
    }

    if (BOOTSTRAPPER_ACTION_UNSAFE_UNINSTALL == pEngineState->plan.action)
    {
        fSuspend = FALSE;
        restart = BOOTSTRAPPER_APPLY_RESTART_NONE;

        LogId(REPORT_STANDARD, MSG_UNSAFE_APPLY_COMPLETED);
    }

    if (fSuspend || BOOTSTRAPPER_APPLY_RESTART_INITIATED == restart)
    {
        // Leave cache alone.
        fRollbackCache = FALSE;
    }
    else if (SUCCEEDED(hr))
    {
        // Clean.
        fRollbackCache = FALSE;

        if (pEngineState->plan.cCleanActions)
        {
            ApplyClean(&pEngineState->userExperience, &pEngineState->plan, pEngineState->companionConnection.hPipe);
        }
    }

LExit:
    if (fRollbackCache && !pEngineState->plan.fDisableRollback)
    {
        ApplyCacheRollback(&pEngineState->userExperience, &pEngineState->plan, pEngineState->companionConnection.hCachePipe, &applyContext);
    }

    // Unregister.
    if (fRegistered)
    {
        ApplyUnregister(pEngineState, FAILED(hr), fSuspend, restart);
    }

    if (fElevated)
    {
        ElevationApplyUninitialize(pEngineState->companionConnection.hPipe);
    }

    pEngineState->userExperience.hwndApply = NULL;

    if (fApplyInitialize)
    {
        ApplyUninitialize();
    }

    pEngineState->plan.fApplying = FALSE;

    if (hLock)
    {
        ::ReleaseMutex(hLock);
        ::CloseHandle(hLock);
    }

    ReleaseHandle(applyContext.hCacheThread);

    if (fDeleteApplyCs)
    {
        DeleteCriticalSection(&applyContext.csApply);
    }

    if (fApplyBegan)
    {
        UserExperienceOnApplyComplete(&pEngineState->userExperience, hr, restart, &applyCompleteAction);
        if (BOOTSTRAPPER_APPLYCOMPLETE_ACTION_RESTART == applyCompleteAction)
        {
            pEngineState->fRestart = TRUE;
        }

        LogId(REPORT_STANDARD, MSG_APPLY_COMPLETE, hr, LoggingRestartToString(restart), LoggingBoolToString(pEngineState->fRestart));
    }

    return hr;
}
