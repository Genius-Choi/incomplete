TEST_P(SslIntegrationTest, LogPeerIpSanUnsupportedIpVersion) {
  useListenerAccessLog("%DOWNSTREAM_PEER_IP_SAN%");
  config_helper_.addFilter("name: sni-to-header-filter");
  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {
    return makeSslClientConnection(ClientSslTransportOptions().setSni("host.com"));
  };
  initialize();
  codec_client_ = makeHttpConnection(
      makeSslClientConnection(ClientSslTransportOptions().setSni("www.host.com")));

  // Disable IP version for the alternate type from the test. The client cert has both an ipv4 and
  // an ipv6 SAN. This must happen after the client has loaded the cert to send as the client cert.
  auto disabler = (version_ == Network::Address::IpVersion::v4)
                      ? Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest
                      : Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest;
  Cleanup cleaner(disabler(true));

  Http::TestRequestHeaderMapImpl request_headers{
      {":method", "GET"}, {":path", "/"}, {":scheme", "https"}, {":authority", "host.com"}};
  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);
  waitForNextUpstreamRequest();

  EXPECT_EQ("www.host.com", upstream_request_->headers()
                                .get(Http::LowerCaseString("x-envoy-client-sni"))[0]
                                ->value()
                                .getStringView());

  Http::TestResponseHeaderMapImpl response_headers{{":status", "200"}};
  upstream_request_->encodeHeaders(response_headers, true);
  RELEASE_ASSERT(response->waitForEndStream(), "unexpected timeout");
  codec_client_->close();

  checkStats();
  auto result = waitForAccessLog(listener_access_log_name_);
  if (version_ == Network::Address::IpVersion::v4) {
    EXPECT_EQ(result, "1.2.3.4");
  } else {
    EXPECT_EQ(result, "0:1:2:3::4");
  }
}
