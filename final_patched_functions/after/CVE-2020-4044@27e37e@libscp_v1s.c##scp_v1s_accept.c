enum SCP_SERVER_STATES_E scp_v1s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)
{
    enum SCP_SERVER_STATES_E result;
    struct SCP_SESSION *session;
    tui32 version;
    tui32 size;
    tui16 cmdset;
    tui16 cmd;

    (*s) = NULL;

    if (!skipVchk)
    {

        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))
        {
            in_uint32_be(c->in_s, version);

            if (version != 1)
            {
                log_message(LOG_LEVEL_WARNING, "[v1s:%d] connection aborted: version error", __LINE__);
                return SCP_SERVER_STATE_VERSION_ERR;
            }
        }
        else
        {
            log_message(LOG_LEVEL_WARNING, "[v1s:%d] connection aborted: network error", __LINE__);
            return SCP_SERVER_STATE_NETWORK_ERR;
        }
    }

    in_uint32_be(c->in_s, size);

    /* Check the message is big enough for the header, the command set, and
     * the command (but not too big) */
    if (size < (8 + 2 + 2) || size > SCP_MAX_MESSAGE_SIZE)
    {
        log_message(LOG_LEVEL_WARNING, "[v1s:%d] connection aborted: size error", __LINE__);
        return SCP_SERVER_STATE_SIZE_ERR;
    }

    init_stream(c->in_s, size - 8);

    if (0 != scp_tcp_force_recv(c->in_sck, c->in_s->data, (size - 8)))
    {
        log_message(LOG_LEVEL_WARNING, "[v1s:%d] connection aborted: network error", __LINE__);
        return SCP_SERVER_STATE_NETWORK_ERR;
    }

    c->in_s->end = c->in_s->data + (size - 8);

    /* reading command set */
    in_uint16_be(c->in_s, cmdset);

    /* if we are starting a management session */
    if (cmdset == SCP_COMMAND_SET_MANAGE)
    {
        log_message(LOG_LEVEL_DEBUG, "[v1s:%d] requested management connection", __LINE__);
        /* should return SCP_SERVER_STATE_START_MANAGE */
        return scp_v1s_mng_accept(c, s);
    }

    /* if we started with resource sharing... */
    if (cmdset == SCP_COMMAND_SET_RSR)
    {
        log_message(LOG_LEVEL_WARNING, "[v1s:%d] connection aborted: sequence error", __LINE__);
        return SCP_SERVER_STATE_SEQUENCE_ERR;
    }

    /* reading command */
    in_uint16_be(c->in_s, cmd);

    if (cmd != 1)
    {
        log_message(LOG_LEVEL_WARNING, "[v1s:%d] connection aborted: sequence error", __LINE__);
        return SCP_SERVER_STATE_SEQUENCE_ERR;
    }

    session = scp_session_create();

    if (NULL == session)
    {
        log_message(LOG_LEVEL_WARNING,
                    "[v1s:%d] connection aborted: internal error "
                    "(malloc returned NULL)", __LINE__);
        result = SCP_SERVER_STATE_INTERNAL_ERR;
    }
    else
    {
        result = scp_v1s_init_session(c, session);
        if (result != SCP_SERVER_STATE_OK)
        {
            scp_session_destroy(session);
            session = NULL;
        }
    }

    /* returning the struct */
    (*s) = session;

    return result;
}
