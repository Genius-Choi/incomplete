Test::Result test_x509_extensions(const Botan::Private_Key& ca_key,
                                  const std::string& sig_algo,
                                  const std::string& sig_padding,
                                  const std::string& hash_fn,
                                  Botan::RandomNumberGenerator& rng) {
   using Botan::Key_Constraints;

   Test::Result result("X509 Extensions");

   /* Create the self-signed cert */
   Botan::X509_Certificate ca_cert = Botan::X509::create_self_signed_cert(ca_opts(sig_padding), ca_key, hash_fn, rng);

   /* Create the CA object */
   Botan::X509_CA ca(ca_cert, ca_key, hash_fn, sig_padding, rng);

   /* Prepare CDP extension */
   std::vector<std::string> cdp_urls = {
      "http://example.com/crl1.pem",
      "ldap://ldap.example.com/cn=crl1,dc=example,dc=com?certificateRevocationList;binary"};

   std::vector<Botan::Cert_Extension::CRL_Distribution_Points::Distribution_Point> dps;

   for(const auto& uri : cdp_urls) {
      Botan::AlternativeName cdp_alt_name;
      cdp_alt_name.add_uri(uri);
      Botan::Cert_Extension::CRL_Distribution_Points::Distribution_Point dp(cdp_alt_name);

      dps.emplace_back(dp);
   }

   auto user_key = make_a_private_key(sig_algo, rng);

   Botan::X509_Cert_Options opts("Test User 1/US/Botan Project/Testing");
   opts.constraints = Key_Constraints::DigitalSignature;

   // include a custom extension in the request
   Botan::Extensions req_extensions;
   const Botan::OID oid("1.2.3.4.5.6.7.8.9.1");
   const Botan::OID ku_oid = Botan::OID::from_string("X509v3.KeyUsage");
   req_extensions.add(std::make_unique<String_Extension>("AAAAAAAAAAAAAABCDEF"), false);
   req_extensions.add(std::make_unique<Botan::Cert_Extension::CRL_Distribution_Points>(dps));
   opts.extensions = req_extensions;
   opts.set_padding_scheme(sig_padding);

   /* Create a self-signed certificate */
   const Botan::X509_Certificate self_signed_cert = Botan::X509::create_self_signed_cert(opts, *user_key, hash_fn, rng);

   result.confirm("Extensions::extension_set true for Key_Usage",
                  self_signed_cert.v3_extensions().extension_set(ku_oid));

   // check if known Key_Usage extension is present in self-signed cert
   auto key_usage_ext = self_signed_cert.v3_extensions().get(ku_oid);
   if(result.confirm("Key_Usage extension present in self-signed certificate", key_usage_ext != nullptr)) {
      result.confirm(
         "Key_Usage extension value matches in self-signed certificate",
         dynamic_cast<Botan::Cert_Extension::Key_Usage&>(*key_usage_ext).get_constraints() == opts.constraints);
   }

   // check if custom extension is present in self-signed cert
   auto string_ext = self_signed_cert.v3_extensions().get_raw<String_Extension>(oid);
   if(result.confirm("Custom extension present in self-signed certificate", string_ext != nullptr)) {
      result.test_eq(
         "Custom extension value matches in self-signed certificate", string_ext->value(), "AAAAAAAAAAAAAABCDEF");
   }

   // check if CDPs are present in the self-signed cert
   auto cert_cdps =
      self_signed_cert.v3_extensions().get_extension_object_as<Botan::Cert_Extension::CRL_Distribution_Points>();

   if(result.confirm("CRL Distribution Points extension present in self-signed certificate",
                     !cert_cdps->crl_distribution_urls().empty())) {
      for(const auto& cdp : cert_cdps->distribution_points()) {
         result.confirm("CDP URI present in self-signed certificate",
                        std::ranges::find(cdp_urls, cdp.point().get_first_attribute("URI")) != cdp_urls.end());
      }
   }

   const Botan::PKCS10_Request user_req = Botan::X509::create_cert_req(opts, *user_key, hash_fn, rng);

   /* Create a CA-signed certificate */
   const Botan::X509_Certificate ca_signed_cert =
      ca.sign_request(user_req, rng, from_date(-1, 01, 01), from_date(2, 01, 01));

   // check if known Key_Usage extension is present in CA-signed cert
   result.confirm("Extensions::extension_set true for Key_Usage", ca_signed_cert.v3_extensions().extension_set(ku_oid));

   key_usage_ext = ca_signed_cert.v3_extensions().get(ku_oid);
   if(result.confirm("Key_Usage extension present in CA-signed certificate", key_usage_ext != nullptr)) {
      auto constraints = dynamic_cast<Botan::Cert_Extension::Key_Usage&>(*key_usage_ext).get_constraints();
      result.confirm("Key_Usage extension value matches in user certificate",
                     constraints == Botan::Key_Constraints::DigitalSignature);
   }

   // check if custom extension is present in CA-signed cert
   result.confirm("Extensions::extension_set true for String_Extension",
                  ca_signed_cert.v3_extensions().extension_set(oid));
   string_ext = ca_signed_cert.v3_extensions().get_raw<String_Extension>(oid);
   if(result.confirm("Custom extension present in CA-signed certificate", string_ext != nullptr)) {
      result.test_eq(
         "Custom extension value matches in CA-signed certificate", string_ext->value(), "AAAAAAAAAAAAAABCDEF");
   }

   // check if CDPs are present in the CA-signed cert
   cert_cdps = ca_signed_cert.v3_extensions().get_extension_object_as<Botan::Cert_Extension::CRL_Distribution_Points>();

   if(result.confirm("CRL Distribution Points extension present in self-signed certificate",
                     !cert_cdps->crl_distribution_urls().empty())) {
      for(const auto& cdp : cert_cdps->distribution_points()) {
         result.confirm("CDP URI present in self-signed certificate",
                        std::ranges::find(cdp_urls, cdp.point().get_first_attribute("URI")) != cdp_urls.end());
      }
   }

   return result;
}
