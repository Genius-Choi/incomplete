scp_v1s_mng_init_session(struct SCP_CONNECTION *c, struct SCP_SESSION *session)
{
    tui32 ipaddr;
    tui16 cmd;
    tui8 sz;
    char buf[256];

    scp_session_set_version(session, 1);

    /* reading command */
    if (!s_check_rem(c->in_s, 2))
    {
        /* Caller should have checked this */
        return SCP_SERVER_STATE_SIZE_ERR;
    }
    in_uint16_be(c->in_s, cmd);

    if (cmd != 1) /* manager login */
    {
        return SCP_SERVER_STATE_SEQUENCE_ERR;
    }

    /* reading username */
    if (!in_string8(c->in_s, buf, "username", __LINE__))
    {
        return SCP_SERVER_STATE_SIZE_ERR;
    }

    if (0 != scp_session_set_username(session, buf))
    {
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    /* reading password */
    if (!in_string8(c->in_s, buf, "passwd", __LINE__))
    {
        return SCP_SERVER_STATE_SIZE_ERR;
    }

    if (0 != scp_session_set_password(session, buf))
    {
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    /* reading remote address
     * Check there's enough data left for at least an IPv4 address (+len) */
    if (!s_check_rem(c->in_s, 1 + 4))
    {
        log_message(LOG_LEVEL_WARNING,
                    "[v1s_mng:%d] connection aborted: IP addr len missing",
                    __LINE__);
        return SCP_SERVER_STATE_SIZE_ERR;
    }

    in_uint8(c->in_s, sz);
    if (sz == SCP_ADDRESS_TYPE_IPV4)
    {
        in_uint32_be(c->in_s, ipaddr);
        scp_session_set_addr(session, sz, &ipaddr);
    }
    else if (sz == SCP_ADDRESS_TYPE_IPV6)
    {
        if (!s_check_rem(c->in_s, 16))
        {
            log_message(LOG_LEVEL_WARNING,
                        "[v1s_mng:%d] connection aborted: IP addr missing",
                        __LINE__);
            return SCP_SERVER_STATE_SIZE_ERR;
        }
        in_uint8a(c->in_s, buf, 16);
        scp_session_set_addr(session, sz, buf);
    }

    /* reading hostname */
    if (!in_string8(c->in_s, buf, "hostname", __LINE__))
    {
        return SCP_SERVER_STATE_SIZE_ERR;
    }

    if (0 != scp_session_set_hostname(session, buf))
    {
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    return SCP_SERVER_STATE_START_MANAGE;
}
