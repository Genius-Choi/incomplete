YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)
{
    if (!parser.isStarted())
    {
	y2warning("Can't execute Write before being mounted.");
	return YCPBoolean (false);
    }
    // no need to update if modified, we are changing value

    bool ok = false; // is the _path_ ok?
    // return value
    YCPBoolean b (true);

    if (0 == path->length ())
    {
	if (value->isString() && value->asString()->value() == "force")
	    parser.inifile.setDirty();
	else if (value->isString () && value->asString()->value() == "clean")
	    parser.inifile.clean ();
	if (0 != parser.write ())
	    b = false;
	ok = true;
    }
    else
    {
	if (( parser.repeatNames () && value->isList ()) ||
	    (!parser.repeatNames () &&  (value->isString () || value->isBoolean() || value->isInteger())) ||
	    path->component_str(0) == "all"
	    )
	    {
		ok = true;
		if (parser.inifile.Write (path, value, parser.HaveRewrites ()))
		    b = false;
	    }
        else if (value->isVoid ())
	    {
		int wb  = -1;
		string del_sec = "";
		ok = true;
		if (2 == path->length ())
		{
		    string pc = path->component_str(0);
		    if ("s" == pc || "section" == pc)
		    {	// request to delete section. Find the file name
			del_sec = path->component_str (1);
			wb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());
		    }
		}
		if (parser.inifile.Delete (path))
		    b = false;
		else if (del_sec != "")
		{
		    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));
		}
	    }
	else
	{
	    ycp2error ("Wrong value for path %s: %s", path->toString ().c_str (), value->toString ().c_str ());
	    b = false;
	}
    }
    if (!ok)
    {
    	ycp2error ( "Wrong path '%s' in Write().", path->toString().c_str () );
    }

    return b;
}
