def parse_command_line(argv: List[str]) -> argparse.Namespace:  # noqa: C901.
    defaults: Dict[str, Any] = {
        "json_indent": None,
        "ordered": True,
        "stringify": False,
        "yaml_options": {},
    }

    me = Path(argv[0]).name
    argv0_from, argv0_to = argv0_to_format(me)
    format_from_argv0 = argv0_to != ""

    parser = argparse.ArgumentParser(
        description="Convert between CBOR, JSON, MessagePack, TOML, and YAML."
    )
    parser.add_argument("-v", "--version", action="version", version=__version__)

    input_group = parser.add_mutually_exclusive_group()
    input_group.add_argument("input", nargs="?", default="-", help="input file")
    input_group.add_argument(
        "-i",
        "--input",
        dest="input_flag",
        metavar="input",
        default=None,
        help="input file",
    )

    if not format_from_argv0:
        parser.add_argument(
            "--if",
            "-if",
            "--input-format",
            dest="input_format",
            default="",
            help="input format",
            choices=FORMATS,
        )

    if not format_from_argv0 or argv0_to == "json":
        parser.add_argument(
            "--json-indent",
            "--indent-json",
            dest="json_indent",
            metavar="n",
            type=int,
            default=defaults["json_indent"],
            help="JSON indentation",
        )

    if not format_from_argv0 or argv0_to in {"json", "toml"}:
        parser.add_argument(
            "-k",
            "--stringify",
            dest="stringify",
            action="store_true",
            help=(
                "Turn into strings boolean, date-time, and null keys for JSON "
                "and TOML and null values for TOML"
            ),
        )

    parser.add_argument(
        "--max-nodes",
        dest="max_nodes",
        metavar="n",
        type=int,
        default=DEFAULT_MAX_NODES,
        help="maximum number of nodes in input data (default %(default)s)",
    )

    output_group = parser.add_mutually_exclusive_group()
    output_group.add_argument("output", nargs="?", default="-", help="output file")
    output_group.add_argument(
        "-o",
        "--output",
        dest="output_flag",
        metavar="output",
        default=None,
        help="output file",
    )

    if not format_from_argv0:
        parser.add_argument(
            "--of",
            "-of",
            "--output-format",
            dest="output_format",
            default="",
            help="output format",
            choices=FORMATS,
        )

    parser.add_argument(
        "-p",
        "--preserve-key-order",
        help=argparse.SUPPRESS,
    )

    if not format_from_argv0 or argv0_to in {"json", "toml", "yaml"}:
        parser.add_argument(
            "-s",
            "--sort-keys",
            dest="ordered",
            action="store_false",
            help="sort JSON, TOML, YAML keys instead of preserving key order",
        )

    parser.add_argument(
        "--unwrap",
        dest="unwrap",
        metavar="key",
        default=None,
        help="only output the data stored under the given key",
    )
    parser.add_argument(
        "--wrap",
        dest="wrap",
        metavar="key",
        default=None,
        help="wrap the data in a map type with the given key",
    )

    if not format_from_argv0 or argv0_to == "yaml":
        parser.add_argument(
            "--yaml-indent",
            dest="yaml_indent",
            metavar="n",
            type=int,
            default=2,
            help="YAML indentation",
        )
        parser.add_argument(
            "--yaml-style",
            dest="yaml_style",
            default=None,
            help="YAML formatting style",
            choices=["", "'", '"', "|", ">"],
        )

        def yaml_width(value: str) -> int:
            # This is theoretically compatible with LibYAML.
            return (1 << 32) - 1 if value.lower() == "inf" else int(value)

        parser.add_argument(
            "--yaml-width",
            dest="yaml_width",
            metavar="n",
            type=yaml_width,  # Allow "inf".
            default=80,
            help="YAML line width for long strings",
        )

    args = parser.parse_args(args=argv[1:])

    # Use the positional input and output arguments.
    if args.input_flag is not None:
        args.input = args.input_flag

    if args.output_flag is not None:
        args.output = args.output_flag

    # Determine the implicit input and output format if possible.
    if format_from_argv0:
        args.input_format = argv0_from
        args.output_format = argv0_to
    else:
        if args.input_format == "":
            args.input_format = extension_to_format(args.input)
            if args.input_format == "":
                parser.error("Need an explicit input format")

        if args.output_format == "":
            args.output_format = extension_to_format(args.output)
            if args.output_format == "":
                parser.error("Need an explicit output format")

    for key, value in defaults.items():
        vars(args).setdefault(key, value)

    # Wrap the yaml_* option.
    if "yaml_indent" in vars(args):
        vars(args)["yaml_options"] = {
            "default_style": args.yaml_style,
            "indent": args.yaml_indent,
            "width": args.yaml_width,
        }
        for key in ["yaml_indent", "yaml_style", "yaml_width"]:
            del vars(args)[key]

    return args
