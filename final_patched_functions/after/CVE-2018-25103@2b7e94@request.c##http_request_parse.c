int http_request_parse(server *srv, connection *con) {
	char *uri = NULL, *proto = NULL, *method = NULL;
	int is_key = 1, key_len = 0, is_ws_after_key = 0, in_folding;
	char *value = NULL, *key = NULL;
	data_string *current_header = NULL;

	int line = 0;

	int request_line_stage = 0;
	size_t i, first, ilen;

	int done = 0;
	const unsigned int http_header_strict = (con->conf.http_parseopts & HTTP_PARSEOPT_HEADER_STRICT);

	parse_header_state state;
	init_parse_header_state(&state);

	/*
	 * Request: "^(GET|POST|HEAD) ([^ ]+(\\?[^ ]+|)) (HTTP/1\\.[01])$"
	 * Option : "^([-a-zA-Z]+): (.+)$"
	 * End    : "^$"
	 */

	if (con->conf.log_request_header) {
		log_error_write(srv, __FILE__, __LINE__, "sdsdSb",
				"fd:", con->fd,
				"request-len:", buffer_string_length(con->request.request),
				"\n", con->request.request);
	}

	if (con->request_count > 1 &&
	    con->request.request->ptr[0] == '\r' &&
	    con->request.request->ptr[1] == '\n') {
		/* we are in keep-alive and might get \r\n after a previous POST request.*/

	      #ifdef __COVERITY__
		if (buffer_string_length(con->request.request) < 2) {
			goto failure;
		}
	      #endif
		/* coverity[overflow_sink : FALSE] */
		buffer_copy_string_len(con->parse_request, con->request.request->ptr + 2, buffer_string_length(con->request.request) - 2);
	} else if (con->request_count > 0 &&
	    con->request.request->ptr[1] == '\n') {
		/* we are in keep-alive and might get \n after a previous POST request.*/
		if (http_header_strict) {
			http_request_missing_CR_before_LF(srv, con);
			goto failure;
		}
	      #ifdef __COVERITY__
		if (buffer_string_length(con->request.request) < 1) {
			goto failure;
		}
	      #endif
		/* coverity[overflow_sink : FALSE] */
		buffer_copy_string_len(con->parse_request, con->request.request->ptr + 1, buffer_string_length(con->request.request) - 1);
	} else {
		/* fill the local request buffer */
		buffer_copy_buffer(con->parse_request, con->request.request);
	}

	/* parse the first line of the request
	 *
	 * should be:
	 *
	 * <method> <uri> <protocol>\r\n
	 * */
	ilen = buffer_string_length(con->parse_request);
	for (i = 0, first = 0; i < ilen && line == 0; i++) {
		switch(con->parse_request->ptr[i]) {
		case '\r':
			if (con->parse_request->ptr[i+1] != '\n') break;
			/* fall through */
		case '\n':
			{
				http_method_t r;
				char *nuri = NULL;
				size_t j, jlen;

				buffer_copy_string_len(con->request.request_line, con->parse_request->ptr, i);

				/* \r\n -> \0\0 */
				if (con->parse_request->ptr[i] == '\r') {
					con->parse_request->ptr[i] = '\0';
					++i;
				} else if (http_header_strict) { /* '\n' */
					http_request_missing_CR_before_LF(srv, con);
					goto failure;
				}
				con->parse_request->ptr[i] = '\0';

				if (request_line_stage != 2) {
					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "s", "incomplete request line -> 400");
						log_error_write(srv, __FILE__, __LINE__, "Sb",
								"request-header:\n",
								con->request.request);
					}
					goto failure;
				}

				proto = con->parse_request->ptr + first;

				*(uri - 1) = '\0';
				*(proto - 1) = '\0';

				/* we got the first one :) */
				if (HTTP_METHOD_UNSET == (r = get_http_method_key(method))) {
					con->http_status = 501;

					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "s", "unknown http-method -> 501");
						log_error_write(srv, __FILE__, __LINE__, "Sb",
								"request-header:\n",
								con->request.request);
					}

					goto failure;
				}

				con->request.http_method = r;

				/*
				 * RFC2616 says:
				 *
				 * HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
				 *
				 * */
				if (0 == strncmp(proto, "HTTP/", sizeof("HTTP/") - 1)) {
					char * major = proto + sizeof("HTTP/") - 1;
					char * minor = strchr(major, '.');
					char *err = NULL;
					int major_num = 0, minor_num = 0;

					int invalid_version = 0;

					if (NULL == minor || /* no dot */
					    minor == major || /* no major */
					    *(minor + 1) == '\0' /* no minor */) {
						invalid_version = 1;
					} else {
						*minor = '\0';
						major_num = strtol(major, &err, 10);

						if (*err != '\0') invalid_version = 1;

						*minor++ = '.';
						minor_num = strtol(minor, &err, 10);

						if (*err != '\0') invalid_version = 1;
					}

					if (invalid_version) {
						if (srv->srvconf.log_request_header_on_error) {
							log_error_write(srv, __FILE__, __LINE__, "s", "unknown protocol -> 400");
							log_error_write(srv, __FILE__, __LINE__, "Sb",
									"request-header:\n",
									con->request.request);
						}
						goto failure;
					}

					if (major_num == 1 && minor_num == 1) {
						con->request.http_version = con->conf.allow_http11 ? HTTP_VERSION_1_1 : HTTP_VERSION_1_0;
					} else if (major_num == 1 && minor_num == 0) {
						con->request.http_version = HTTP_VERSION_1_0;
					} else {
						con->http_status = 505;

						if (srv->srvconf.log_request_header_on_error) {
							log_error_write(srv, __FILE__, __LINE__, "s", "unknown HTTP version -> 505");
							log_error_write(srv, __FILE__, __LINE__, "Sb",
									"request-header:\n",
									con->request.request);
						}
						goto failure;
					}
				} else {
					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "s", "unknown protocol -> 400");
						log_error_write(srv, __FILE__, __LINE__, "Sb",
								"request-header:\n",
								con->request.request);
					}
					goto failure;
				}

				if (*uri == '/') {
					/* (common case) */
					buffer_copy_string_len(con->request.uri, uri, proto - uri - 1);
				} else if (0 == strncasecmp(uri, "http://", 7) &&
				    NULL != (nuri = strchr(uri + 7, '/'))) {
					state.reqline_host = uri + 7;
					state.reqline_hostlen = nuri - state.reqline_host;

					buffer_copy_string_len(con->request.uri, nuri, proto - nuri - 1);
				} else if (0 == strncasecmp(uri, "https://", 8) &&
				    NULL != (nuri = strchr(uri + 8, '/'))) {
					state.reqline_host = uri + 8;
					state.reqline_hostlen = nuri - state.reqline_host;

					buffer_copy_string_len(con->request.uri, nuri, proto - nuri - 1);
				} else if (!http_header_strict
					   || (HTTP_METHOD_CONNECT == con->request.http_method && (uri[0] == ':' || light_isdigit(uri[0])))
					   || (HTTP_METHOD_OPTIONS == con->request.http_method && uri[0] == '*' && uri[1] == '\0')) {
					/* everything looks good so far */
					buffer_copy_string_len(con->request.uri, uri, proto - uri - 1);
				} else {
					log_error_write(srv, __FILE__, __LINE__, "ss", "request-URI parse error -> 400 for:", uri);
					goto failure;
				}

				/* check uri for invalid characters */
				jlen = buffer_string_length(con->request.uri);
				if ((con->conf.http_parseopts & HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT)) {
					j = jlen; /* URI will be checked in http_response_prepare() */
				} else if (http_header_strict) {
					for (j = 0; j < jlen && request_uri_is_valid_char(con->request.uri->ptr[j]); j++) ;
				} else {
					char *z = memchr(con->request.uri->ptr, '\0', jlen);
					j = (NULL == z) ? jlen : (size_t)(z - con->request.uri->ptr);
				}
				if (j < jlen) {
					if (srv->srvconf.log_request_header_on_error) {
						unsigned char buf[2];
						buf[0] = con->request.uri->ptr[j];
						buf[1] = '\0';

						if (con->request.uri->ptr[j] > 32 &&
							con->request.uri->ptr[j] != 127) {
							/* the character is printable -> print it */
							log_error_write(srv, __FILE__, __LINE__, "ss",
									"invalid character in URI -> 400",
									buf);
						} else {
							/* a control-character, print ascii-code */
							log_error_write(srv, __FILE__, __LINE__, "sd",
									"invalid character in URI -> 400",
									con->request.uri->ptr[j]);
						}

						log_error_write(srv, __FILE__, __LINE__, "Sb",
								"request-header:\n",
								con->request.request);
					}

					goto failure;
				}

				buffer_copy_buffer(con->request.orig_uri, con->request.uri);

				con->http_status = 0;

				line++;
				first = i+1;
			}
			break;
		case ' ':
			switch(request_line_stage) {
			case 0:
				/* GET|POST|... */
				method = con->parse_request->ptr + first;
				first = i + 1;
				break;
			case 1:
				/* /foobar/... */
				uri = con->parse_request->ptr + first;
				first = i + 1;
				break;
			default:
				/* ERROR, one space to much */
				if (srv->srvconf.log_request_header_on_error) {
					log_error_write(srv, __FILE__, __LINE__, "s", "overlong request line -> 400");
					log_error_write(srv, __FILE__, __LINE__, "Sb",
							"request-header:\n",
							con->request.request);
				}
				goto failure;
			}

			request_line_stage++;
			break;
		}
	}

	in_folding = 0;

	if (buffer_string_is_empty(con->request.uri)) {
		if (srv->srvconf.log_request_header_on_error) {
			log_error_write(srv, __FILE__, __LINE__, "s", "no uri specified -> 400");
			log_error_write(srv, __FILE__, __LINE__, "Sb",
							"request-header:\n",
							con->request.request);
		}
		goto failure;
	}

	if (state.reqline_host) {
		/* Insert as host header */
		data_string *ds;

		if (NULL == (ds = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
			ds = data_string_init();
		}

		buffer_copy_string_len(ds->key, CONST_STR_LEN("Host"));
		buffer_copy_string_len(ds->value, state.reqline_host, state.reqline_hostlen);
		array_insert_unique(con->request.headers, (data_unset *)ds);
		con->request.http_host = ds->value;
	}

	for (; i <= ilen && !done; i++) {
		char *cur = con->parse_request->ptr + i;

		if (is_key) {
			size_t j;
			int got_colon = 0;

			/**
			 * 1*<any CHAR except CTLs or separators>
			 * CTLs == 0-31 + 127, CHAR = 7-bit ascii (0..127)
			 *
			 */
			switch(*cur) {
			case ':':
				is_key = 0;

				value = cur + 1;

				if (is_ws_after_key == 0) {
					key_len = i - first;
				}
				is_ws_after_key = 0;

				break;
			case '(':
			case ')':
			case '<':
			case '>':
			case '@':
			case ',':
			case ';':
			case '\\':
			case '\"':
			case '/':
			case '[':
			case ']':
			case '?':
			case '=':
			case '{':
			case '}':
				if (srv->srvconf.log_request_header_on_error) {
					log_error_write(srv, __FILE__, __LINE__, "sbsds",
						"invalid character in key", con->request.request, cur, *cur, "-> 400");

					log_error_write(srv, __FILE__, __LINE__, "Sb",
						"request-header:\n",
						con->request.request);
				}
				goto failure;
			case ' ':
			case '\t':
				if (i == first) {
					is_key = 0;
					in_folding = 1;
					value = cur;

					break;
				}


				key_len = i - first;

				/* skip every thing up to the : */
				for (j = 1; !got_colon; j++) {
					switch(con->parse_request->ptr[j + i]) {
					case ' ':
					case '\t':
						/* skip WS */
						continue;
					case ':':
						/* ok, done; handle the colon the usual way */

						i += j - 1;
						got_colon = 1;
						is_ws_after_key = 1; /* we already know the key length */

						break;
					default:
						/* error */

						if (srv->srvconf.log_request_header_on_error) {
							log_error_write(srv, __FILE__, __LINE__, "s", "WS character in key -> 400");
							log_error_write(srv, __FILE__, __LINE__, "Sb",
								"request-header:\n",
								con->request.request);
						}

						goto failure;
					}
				}

				break;
			case '\r':
				if (con->parse_request->ptr[i+1] == '\n' && i == first) {
					/* End of Header */
					con->parse_request->ptr[i] = '\0';
					con->parse_request->ptr[i+1] = '\0';

					i++;

					done = 1;
				} else {
					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "s", "CR without LF -> 400");
						log_error_write(srv, __FILE__, __LINE__, "Sb",
							"request-header:\n",
							con->request.request);
					}

					goto failure;
				}
				break;
			case '\n':
				if (http_header_strict) {
					http_request_missing_CR_before_LF(srv, con);
					goto failure;
				} else if (i == first) {
					con->parse_request->ptr[i] = '\0';
					done = 1;
					break;
				}
				/* fall through */
			default:
				if (http_header_strict ? (*cur < 32 || ((unsigned char)*cur) >= 127) : *cur == '\0') {
					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "sbsds",
							"invalid character in key", con->request.request, cur, *cur, "-> 400");

						log_error_write(srv, __FILE__, __LINE__, "Sb",
							"request-header:\n",
							con->request.request);
					}

					goto failure;
				}
				/* ok */
				break;
			}
		} else {
			switch(*cur) {
			case '\r':
			case '\n':
				if (*cur == '\n' || con->parse_request->ptr[i+1] == '\n') {
					int value_len;

					if (*cur == '\n') {
						if (http_header_strict) {
							http_request_missing_CR_before_LF(srv, con);
							goto failure;
						}
					} else { /* (con->parse_request->ptr[i+1] == '\n') */
						con->parse_request->ptr[i] = '\0';
						++i;
					}

					/* End of Headerline */
					con->parse_request->ptr[i] = '\0';

					value_len = cur - value;

					/* strip trailing white-spaces */
					while (value_len > 0 && (value[value_len - 1] == ' ' || value[value_len - 1] == '\t')) {
						--value_len;
					}

					if (in_folding) {
						if (!current_header) {
							/* 400 */

							if (srv->srvconf.log_request_header_on_error) {
								log_error_write(srv, __FILE__, __LINE__, "s", "WS at the start of first line -> 400");

								log_error_write(srv, __FILE__, __LINE__, "Sb",
									"request-header:\n",
									con->request.request);
							}

							goto failure;
						}

						buffer_append_string_len(current_header->value, value, value_len);
					} else {
						/* process previous header */
						if (current_header) {
							data_string *ds = current_header;
							current_header = NULL;
							if (!parse_single_header(srv, con, &state, ds)) {
								/* parse_single_header should already have logged it */
								goto failure;
							}
						}

						key = con->parse_request->ptr + first;

						if (NULL == (current_header = (data_string *)array_get_unused_element(con->request.headers, TYPE_STRING))) {
							current_header = data_string_init();
						}

						buffer_copy_string_len(current_header->key, key, key_len);
						buffer_copy_string_len(current_header->value, value, value_len);
					}

					first = i+1;
					is_key = 1;
					value = NULL;
					key_len = 0; 
					in_folding = 0;
				} else {
					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "sbs",
								"CR without LF", con->request.request, "-> 400");
					}

					goto failure;
				}
				break;
			case ' ':
			case '\t':
				/* strip leading WS */
				if (value == cur) value = cur+1;
				break;
			default:
				if (http_header_strict ? (*cur >= 0 && *cur < 32) : *cur == '\0') {
					if (srv->srvconf.log_request_header_on_error) {
						log_error_write(srv, __FILE__, __LINE__, "sds",
								"invalid char in header", (int)*cur, "-> 400");
					}

					goto failure;
				}
				break;
			}
		}
	}

	/* process last header */
	if (current_header) {
		data_string* ds = current_header;
		current_header = NULL;
		if (!parse_single_header(srv, con, &state, ds)) {
			/* parse_single_header should already have logged it */
			goto failure;
		}
	}

	con->header_len = i;

	/* do some post-processing */

	if (con->request.http_version == HTTP_VERSION_1_1) {
		if (state.keep_alive_set != HTTP_CONNECTION_CLOSE) {
			/* no Connection-Header sent */

			/* HTTP/1.1 -> keep-alive default TRUE */
			con->keep_alive = 1;
		} else {
			con->keep_alive = 0;
		}

		/* RFC 2616, 14.23 */
		if (con->request.http_host == NULL ||
		    buffer_string_is_empty(con->request.http_host)) {

			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, "s", "HTTP/1.1 but Host missing -> 400");
				log_error_write(srv, __FILE__, __LINE__, "Sb",
						"request-header:\n",
						con->request.request);
			}
			goto failure;
		}
	} else {
		if (state.keep_alive_set == HTTP_CONNECTION_KEEPALIVE) {
			/* no Connection-Header sent */

			/* HTTP/1.0 -> keep-alive default FALSE  */
			con->keep_alive = 1;
		} else {
			con->keep_alive = 0;
		}
	}

	/* check hostname field if it is set */
	if (!buffer_is_empty(con->request.http_host) &&
	    0 != http_request_host_policy(con, con->request.http_host, con->proto)) {

		if (srv->srvconf.log_request_header_on_error) {
			log_error_write(srv, __FILE__, __LINE__, "s",
					"Invalid Hostname -> 400");
			log_error_write(srv, __FILE__, __LINE__, "Sb",
					"request-header:\n",
					con->request.request);
		}

		goto failure;
	}

	{
		data_string *ds = (data_string *)array_get_element(con->request.headers, "Transfer-Encoding");
		if (NULL != ds) {
			if (con->request.http_version == HTTP_VERSION_1_0) {
				log_error_write(srv, __FILE__, __LINE__, "s",
						"HTTP/1.0 with Transfer-Encoding (bad HTTP/1.0 proxy?) -> 400");
				goto failure;
			}

			if (0 != strcasecmp(ds->value->ptr, "chunked")) {
				/* Transfer-Encoding might contain additional encodings,
				 * which are not currently supported by lighttpd */
				con->http_status = 501; /* Not Implemented */
				goto failure;
			}

			/* reset value for Transfer-Encoding, a hop-by-hop header,
			 * which must not be blindly forwarded to backends */
			buffer_reset(ds->value); /* headers with empty values are ignored */

			state.con_length_set = 1;
			con->request.content_length = -1;

			/*(note: ignore whether or not Content-Length was provided)*/
			ds = (data_string *)array_get_element(con->request.headers, "Content-Length");
			if (NULL != ds) buffer_reset(ds->value); /* headers with empty values are ignored */
		}
	}

	switch(con->request.http_method) {
	case HTTP_METHOD_GET:
	case HTTP_METHOD_HEAD:
		/* content-length is forbidden for those */
		if (state.con_length_set && con->request.content_length != 0) {
			/* content-length is missing */
			log_error_write(srv, __FILE__, __LINE__, "s",
					"GET/HEAD with content-length -> 400");

			goto failure;
		}
		break;
	case HTTP_METHOD_POST:
		/* content-length is required for them */
		if (!state.con_length_set) {
			/* content-length is missing */
			log_error_write(srv, __FILE__, __LINE__, "s",
					"POST-request, but content-length missing -> 411");

			con->http_status = 411;
			goto failure;
		}
		break;
	default:
		break;
	}


	/* check if we have read post data */
	if (state.con_length_set) {
		/* we have content */
		if (con->request.content_length != 0) {
			return 1;
		}
	}

	return 0;

failure:
	if (current_header) current_header->free((data_unset *)current_header);

	con->keep_alive = 0;
	con->response.keep_alive = 0;
	if (!con->http_status) con->http_status = 400;

	return 0;
}
