async def test_oauth_service_roles(
    app,
    mockservice_url,
    create_user_with_scopes,
    client_allowed_roles,
    request_scopes,
    expected_scopes,
    preserve_scopes,
):
    service = mockservice_url
    oauth_client = (
        app.db.query(orm.OAuthClient)
        .filter_by(identifier=service.oauth_client_id)
        .one()
    )
    scopes.define_custom_scopes(
        {
            "custom:jupyter_server:read:*": {
                "description": "read-only access to jupyter server",
            },
        },
    )
    roles.create_role(
        app.db,
        {
            "name": "read-only",
            "description": "read-only access to servers",
            "scopes": [
                "access:servers",
                "custom:jupyter_server:read:*",
            ],
        },
    )

    roles.create_role(
        app.db,
        {
            "name": "other",
            "description": "A role not held by our test user",
            "scopes": [
                "admin-ui",
            ],
        },
    )
    oauth_client.allowed_scopes = sorted(
        roles_to_scopes(
            [orm.Role.find(app.db, role_name) for role_name in client_allowed_roles]
        )
    )
    app.db.commit()
    user = create_user_with_scopes("access:services")
    url = url_path_join(public_url(app, mockservice_url) + 'owhoami/?arg=x')
    if request_scopes:
        request_scopes = {s.replace("$user", user.name) for s in request_scopes}
        url = url_concat(url, {"request-scope": " ".join(request_scopes)})
    # first request is only going to login and get us to the oauth form page
    s = AsyncSession()
    roles.grant_role(app.db, user, "user")
    roles.grant_role(app.db, user, "read-only")
    name = user.name
    s.cookies = await app.login_user(name)

    r = await s.get(url)
    if expected_scopes is None:
        # expected failed auth, stop here
        # verify expected 'invalid scope' error, not server error
        dest_url, _, query = r.url.partition("?")
        assert dest_url == public_url(app, mockservice_url) + "oauth_callback"
        assert parse_qs(query).get("error") == ["invalid_scope"]
        assert r.status_code == 400
        return

    r.raise_for_status()
    # we should be looking at the oauth confirmation page
    assert urlparse(r.url).path == app.base_url + 'hub/api/oauth2/authorize'
    # verify oauth state cookie was set at some point
    assert set(r.history[0].cookies.keys()) == {'service-%s-oauth-state' % service.name}

    page = BeautifulSoup(r.text, "html.parser")
    scope_inputs = page.find_all("input", {"name": "scopes"})
    scope_values = [input["value"] for input in scope_inputs]
    app_log.info(f"Submitting request with scope values {scope_values}")
    # submit the oauth form to complete authorization
    data = {}
    if scope_values:
        data["scopes"] = scope_values
    data["_xsrf"] = s.cookies["_xsrf"]
    r = await s.post(r.url, data=data)
    r.raise_for_status()
    assert r.url == url
    # verify oauth cookie is set
    assert 'service-%s' % service.name in set(s.cookies.keys())
    # verify oauth state cookie has been consumed
    assert 'service-%s-oauth-state' % service.name not in set(s.cookies.keys())

    # second request should be authenticated, which means no redirects
    r = await s.get(url, allow_redirects=False)
    r.raise_for_status()
    assert r.status_code == 200
    assert len(r.history) == 0
    reply = r.json()
    sub_reply = {key: reply.get(key, 'missing') for key in ('kind', 'name')}
    assert sub_reply == {'name': user.name, 'kind': 'user'}

    expected_scopes = {s.replace("$user", user.name) for s in expected_scopes}

    # expand roles to scopes (shortcut)
    for scope in list(expected_scopes):
        role = orm.Role.find(app.db, scope)
        if role:
            expected_scopes.discard(role.name)
            expected_scopes.update(
                roles.roles_to_expanded_scopes([role], owner=user.orm_user)
            )

    if 'inherit' in expected_scopes:
        expected_scopes = set(scopes.get_scopes_for(user.orm_user))

    # always expect identify/access scopes
    # on successful authentication
    expected_scopes.update(scopes.identify_scopes(user.orm_user))
    expected_scopes.update(scopes.access_scopes(oauth_client))
    expected_scopes = scopes.reduce_scopes(expected_scopes)
    have_scopes = scopes.reduce_scopes(set(reply['scopes']))
    # pytest is better at reporting list differences
    # than set differences, especially with `-vv`
    assert sorted(have_scopes) == sorted(expected_scopes)

    # token-authenticated request to HubOAuth
    token = app.users[name].new_api_token()
    # token in ?token parameter
    r = await async_requests.get(url_concat(url, {'token': token}), headers=s.headers)
    r.raise_for_status()
    reply = r.json()
    assert reply['name'] == name

    # verify that ?token= requests set a cookie
    assert len(r.cookies) != 0
    # ensure cookie works in future requests
    r = await async_requests.get(
        url, cookies=r.cookies, allow_redirects=False, headers=s.headers
    )
    r.raise_for_status()
    assert r.url == url
    reply = r.json()
    assert reply['name'] == name
