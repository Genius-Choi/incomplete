  def default_results(options = {})
    options.reverse_merge!(@options)
    options.reverse_merge!(per_page: per_page_setting) unless options[:limit] == false

    # Whether to include unlisted (visible = false) topics
    viewing_own_topics = @user && @user.id == options[:filtered_to_user]

    if options[:visible].nil?
      options[:visible] = true if @user.nil? || @user.regular?
      options[:visible] = false if @guardian.can_see_unlisted_topics? || viewing_own_topics
    end

    # Start with a list of all topics
    result = Topic.unscoped.includes(:category)

    if @user
      result =
        result.joins(
          "LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{@user.id.to_i})",
        ).references("tu")
    end

    category_id = get_category_id(options[:category])
    @options[:category_id] = category_id
    if category_id
      if options[:no_subcategories]
        result = result.where("topics.category_id = ?", category_id)
      else
        result = result.where("topics.category_id IN (?)", Category.subcategory_ids(category_id))
        if !SiteSetting.show_category_definitions_in_topic_lists
          result =
            result.where("categories.topic_id <> topics.id OR topics.category_id = ?", category_id)
        end
      end
      result = result.references(:categories)

      if !@options[:order]
        filter = (options[:filter] || options[:f])
        # category default sort order
        sort_order, sort_ascending =
          Category.where(id: category_id).pluck_first(:sort_order, :sort_ascending)
        if sort_order && (filter.blank? || %i[latest unseen].include?(filter))
          options[:order] = sort_order
          options[:ascending] = !!sort_ascending ? "true" : "false"
        else
          options[:order] = "default"
          options[:ascending] = "false"
        end
      end
    end

    if SiteSetting.tagging_enabled
      result = result.preload(:tags)

      tags_arg = @options[:tags]

      if tags_arg && tags_arg.size > 0
        tags_arg = tags_arg.split if String === tags_arg

        tags_arg =
          tags_arg.map do |t|
            if String === t
              t.downcase
            else
              t
            end
          end

        tags_query = tags_arg[0].is_a?(String) ? Tag.where_name(tags_arg) : Tag.where(id: tags_arg)
        tags = tags_query.select(:id, :target_tag_id).map { |t| t.target_tag_id || t.id }.uniq

        if ActiveModel::Type::Boolean.new.cast(@options[:match_all_tags])
          # ALL of the given tags:
          if tags_arg.length == tags.length
            tags.each_with_index do |tag, index|
              sql_alias = ["t", index].join
              result =
                result.joins(
                  "INNER JOIN topic_tags #{sql_alias} ON #{sql_alias}.topic_id = topics.id AND #{sql_alias}.tag_id = #{tag}",
                )
            end
          else
            result = result.none # don't return any results unless all tags exist in the database
          end
        else
          # ANY of the given tags:
          result = result.joins(:tags).where("tags.id in (?)", tags)
        end

        # TODO: this is very side-effecty and should be changed
        # It is done cause further up we expect normalized tags
        @options[:tags] = tags
      elsif @options[:no_tags]
        # the following will do: ("topics"."id" NOT IN (SELECT DISTINCT "topic_tags"."topic_id" FROM "topic_tags"))
        result = result.where.not(id: TopicTag.distinct.pluck(:topic_id))
      end

      result = result.where(<<~SQL, name: @options[:exclude_tag]) if @options[:exclude_tag].present?
        topics.id NOT IN (
          SELECT topic_tags.topic_id
          FROM topic_tags
          INNER JOIN tags ON tags.id = topic_tags.tag_id
          WHERE tags.name = :name
        )
        SQL
    end

    result = apply_ordering(result, options)

    all_listable_topics = @guardian.filter_allowed_categories(Topic.unscoped.listable_topics)

    if options[:include_pms] || options[:include_all_pms]
      all_pm_topics =
        if options[:include_all_pms] && @guardian.is_admin?
          Topic.unscoped.private_messages
        else
          Topic.unscoped.private_messages_for_user(@user)
        end
      result = result.merge(all_listable_topics.or(all_pm_topics))
    else
      result = result.merge(all_listable_topics)
    end

    # Don't include the category topics if excluded
    if options[:no_definitions]
      result = result.where("COALESCE(categories.topic_id, 0) <> topics.id")
    end

    result = result.limit(options[:per_page]) unless options[:limit] == false
    result = result.visible if options[:visible]
    result =
      result.where.not(topics: { id: options[:except_topic_ids] }).references(:topics) if options[
      :except_topic_ids
    ]

    if options[:page]
      offset = options[:page].to_i * options[:per_page]
      result = result.offset(offset) if offset > 0
    end

    if options[:topic_ids]
      result = result.where("topics.id in (?)", options[:topic_ids]).references(:topics)
    end

    if search = options[:search].presence
      result =
        result.where(
          "topics.id in (select pp.topic_id from post_search_data pd join posts pp on pp.id = pd.post_id where pd.search_data @@ #{Search.ts_query(term: search.to_s)})",
        )
    end

    # NOTE protect against SYM attack can be removed with Ruby 2.2
    #
    state = options[:state]
    if @user && state && TopicUser.notification_levels.keys.map(&:to_s).include?(state)
      level = TopicUser.notification_levels[state.to_sym]
      result =
        result.where(
          "topics.id IN (
                                SELECT topic_id
                                FROM topic_users
                                WHERE user_id = ? AND
                                      notification_level = ?)",
          @user.id,
          level,
        )
    end

    require_deleted_clause = true

    if before = options[:before]
      if (before = before.to_i) > 0
        result = result.where("topics.created_at < ?", before.to_i.days.ago)
      end
    end

    if bumped_before = options[:bumped_before]
      if (bumped_before = bumped_before.to_i) > 0
        result = result.where("topics.bumped_at < ?", bumped_before.to_i.days.ago)
      end
    end

    if status = options[:status]
      case status
      when "open"
        result = result.where("NOT topics.closed AND NOT topics.archived")
      when "closed"
        result = result.where("topics.closed")
      when "archived"
        result = result.where("topics.archived")
      when "listed"
        result = result.where("topics.visible")
      when "unlisted"
        result = result.where("NOT topics.visible")
      when "deleted"
        category = Category.find_by(id: options[:category])
        if @guardian.can_see_deleted_topics?(category)
          result = result.where("topics.deleted_at IS NOT NULL")
          require_deleted_clause = false
        end
      end
    end

    if (filter = (options[:filter] || options[:f])) && @user
      action = (PostActionType.types[:like] if filter == "liked")
      if action
        result =
          result.where(
            "topics.id IN (SELECT pp.topic_id
                              FROM post_actions pa
                              JOIN posts pp ON pp.id = pa.post_id
                              WHERE pa.user_id = :user_id AND
                                    pa.post_action_type_id = :action AND
                                    pa.deleted_at IS NULL
                           )",
            user_id: @user.id,
            action: action,
          )
      end

      result = TopicQuery.tracked_filter(result, @user.id) if filter == "tracked"
    end

    result = result.where("topics.deleted_at IS NULL") if require_deleted_clause
    result = result.where("topics.posts_count <= ?", options[:max_posts]) if options[
      :max_posts
    ].present?
    result = result.where("topics.posts_count >= ?", options[:min_posts]) if options[
      :min_posts
    ].present?

    result = TopicQuery.apply_custom_filters(result, self)

    result
  end
