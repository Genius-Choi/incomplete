def isURLInPortal(self, url, context=None):
    # Note: no docstring, because the method is publicly available
    # but does not need to be callable on site-url/portal_url/isURLInPortal.

    # Check if a given url is on the same host and contains the portal
    # path.  Used to ensure that login forms can determine relevant
    # referrers (i.e. in portal).  Also return true for some relative
    # urls if context is passed in to allow for url parsing. When context
    # is not provided, assume that relative urls are in the portal. It is
    # assumed that http://portal is the same portal as https://portal.

    # External sites listed in 'allow_external_login_sites' of
    # site_properties are also considered within the portal to allow for
    # single sign on.

    if len(url.splitlines()) > 1:
        # very fishy
        return False
    if url != url.strip():
        # somewhat fishy
        return False
    if url != " ".join(url.split()):
        # Some non-normal whitespace is used, like a tab.
        # Could be a ploy to circumvent our checks.  We don't trust this.
        return False
    if url and not safe_url_first_char(url):
        return False

    # sanitize url
    url = re.sub("^[\x00-\x20]+", "", url).strip()
    cmp_url = url.lower()
    for bad in BAD_URL_PARTS:
        if bad in cmp_url:
            return False

    p_url = self()

    schema, u_host, u_path, _, _, _ = urlparse(url)
    if schema and schema not in ALLOWED_SCHEMAS:
        # Redirecting to 'data:' may be harmful,
        # and redirecting to 'mailto:' or 'ftp:' is silly.
        return False

    # Someone may be doing tricks with escaped html code.
    unescaped_url = unescape(url)
    if unescaped_url != url:
        if not self.isURLInPortal(unescaped_url):
            return False

    if not u_host and not u_path.startswith("/"):
        if context is None:
            return True  # old behavior
        if not context.isPrincipiaFolderish:
            useurl = context.aq_parent.absolute_url()
        else:
            useurl = context.absolute_url()
    else:
        useurl = p_url  # when u_path.startswith('/')
    if not useurl.endswith("/"):
        useurl += "/"

    # urljoin to current url to get an absolute path
    _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))

    # normalise to end with a '/' so /foobar is not considered within /foo
    if not u_path:
        u_path = "/"
    else:
        u_path = normpath(u_path)
        if not u_path.endswith("/"):
            u_path += "/"
    _, host, path, _, _, _ = urlparse(p_url)
    if not path.endswith("/"):
        path += "/"
    if host == u_host and u_path.startswith(path):
        return True

    for external_site in get_external_sites(self):
        _, host, path, _, _, _ = urlparse(external_site)
        if not path.endswith("/"):
            path += "/"
        if host == u_host and u_path.startswith(path):
            return True
    return False
