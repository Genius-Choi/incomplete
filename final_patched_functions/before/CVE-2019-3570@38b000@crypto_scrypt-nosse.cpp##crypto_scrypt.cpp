crypto_scrypt(const uint8_t * passwd, size_t passwdlen,
    const uint8_t * salt, size_t saltlen, uint64_t N, uint32_t r, uint32_t p,
    uint8_t * buf, size_t buflen)
{
  void * B0, * V0, * XY0;
  uint8_t * B;
  uint32_t * V;
  uint32_t * XY;
  uint32_t i;

  /* Sanity-check parameters. */
  if (buflen > (((uint64_t)(1) << 32) - 1) * 32) {
    errno = EFBIG;
    goto err0;
  }
  if ((uint64_t)(r) * (uint64_t)(p) >= (1 << 30)) {
    errno = EFBIG;
    goto err0;
  }
  if (((N & (N - 1)) != 0) || (N == 0)) {
    errno = EINVAL;
    goto err0;
  }
  if ((r > SIZE_MAX / 128 / p) ||
      (N > SIZE_MAX / 128 / r)) {
    errno = ENOMEM;
    goto err0;
  }

  /* Allocate memory. */
  B0 = folly_ext::aligned_malloc(128 * r * p, 64);
  if (!B0) {
    goto err0;
  }

  XY0 = folly_ext::aligned_malloc(256 * r + 64, 64);
  if (!XY0) {
    goto err1;
  }

  B = (uint8_t *)(B0);
  XY = (uint32_t *)(XY0);

  if ((V0 = mmap(NULL, 128 * r * N, PROT_READ | PROT_WRITE,
#ifdef MAP_NOCORE
      MAP_ANON | MAP_PRIVATE | MAP_NOCORE,
#else
      MAP_ANON | MAP_PRIVATE,
#endif
      -1, 0)) == MAP_FAILED)
    goto err2;
  V = (uint32_t *)(V0);

  /* 1: (B_0 ... B_{p-1}) <-- PBKDF2(P, S, 1, p * MFLen) */
  PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1, B, p * 128 * r);

  /* 2: for i = 0 to p - 1 do */
  for (i = 0; i < p; i++) {
    /* 3: B_i <-- MF(B_i, N) */
    smix(&B[i * 128 * r], r, N, V, XY);
  }

  /* 5: DK <-- PBKDF2(P, B, 1, dkLen) */
  PBKDF2_SHA256(passwd, passwdlen, B, p * 128 * r, 1, buf, buflen);

  /* Free memory. */
  if (munmap(V0, 128 * r * N))
    goto err2;
  folly_ext::aligned_free(XY0);
  folly_ext::aligned_free(B0);

  /* Success! */
  return (0);

err2:
  folly_ext::aligned_free(XY0);
err1:
  folly_ext::aligned_free(B0);
err0:
  /* Failure! */
  return (-1);
}
