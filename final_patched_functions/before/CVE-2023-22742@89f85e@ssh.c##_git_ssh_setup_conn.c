static int _git_ssh_setup_conn(
	ssh_subtransport *t,
	const char *url,
	const char *cmd,
	git_smart_subtransport_stream **stream)
{
	int auth_methods, error = 0;
	ssh_stream *s;
	git_credential *cred = NULL;
	LIBSSH2_SESSION *session=NULL;
	LIBSSH2_CHANNEL *channel=NULL;

	t->current_stream = NULL;

	*stream = NULL;
	if (ssh_stream_alloc(t, cmd, stream) < 0)
		return -1;

	s = (ssh_stream *)*stream;
	s->session = NULL;
	s->channel = NULL;

	if (git_net_str_is_url(url))
		error = git_net_url_parse(&s->url, url);
	else
		error = git_net_url_parse_scp(&s->url, url);

	if (error < 0)
		goto done;

	if ((error = git_socket_stream_new(&s->io, s->url.host, s->url.port)) < 0 ||
	    (error = git_stream_connect(s->io)) < 0)
		goto done;

	if ((error = _git_ssh_session_create(&session, s->io)) < 0)
		goto done;

	if (t->owner->connect_opts.callbacks.certificate_check != NULL) {
		git_cert_hostkey cert = {{ 0 }}, *cert_ptr;
		const char *key;
		size_t cert_len;
		int cert_type;

		cert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;

		key = libssh2_session_hostkey(session, &cert_len, &cert_type);
		if (key != NULL) {
			cert.type |= GIT_CERT_SSH_RAW;
			cert.hostkey = key;
			cert.hostkey_len = cert_len;
			switch (cert_type) {
				case LIBSSH2_HOSTKEY_TYPE_RSA:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_RSA;
					break;
				case LIBSSH2_HOSTKEY_TYPE_DSS:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_DSS;
					break;

#ifdef LIBSSH2_HOSTKEY_TYPE_ECDSA_256
				case LIBSSH2_HOSTKEY_TYPE_ECDSA_256:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256;
					break;
				case LIBSSH2_HOSTKEY_TYPE_ECDSA_384:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384;
					break;
				case LIBSSH2_KNOWNHOST_KEY_ECDSA_521:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521;
					break;
#endif

#ifdef LIBSSH2_HOSTKEY_TYPE_ED25519
				case LIBSSH2_HOSTKEY_TYPE_ED25519:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_KEY_ED25519;
					break;
#endif
				default:
					cert.raw_type = GIT_CERT_SSH_RAW_TYPE_UNKNOWN;
			}
		}

#ifdef LIBSSH2_HOSTKEY_HASH_SHA256
		key = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA256);
		if (key != NULL) {
			cert.type |= GIT_CERT_SSH_SHA256;
			memcpy(&cert.hash_sha256, key, 32);
		}
#endif

		key = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);
		if (key != NULL) {
			cert.type |= GIT_CERT_SSH_SHA1;
			memcpy(&cert.hash_sha1, key, 20);
		}

		key = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);
		if (key != NULL) {
			cert.type |= GIT_CERT_SSH_MD5;
			memcpy(&cert.hash_md5, key, 16);
		}

		if (cert.type == 0) {
			git_error_set(GIT_ERROR_SSH, "unable to get the host key");
			error = -1;
			goto done;
		}

		/* We don't currently trust any hostkeys */
		git_error_clear();

		cert_ptr = &cert;

		error = t->owner->connect_opts.callbacks.certificate_check(
			(git_cert *)cert_ptr,
			0,
			s->url.host,
			t->owner->connect_opts.callbacks.payload);

		if (error < 0 && error != GIT_PASSTHROUGH) {
			if (!git_error_last())
				git_error_set(GIT_ERROR_NET, "user cancelled hostkey check");

			goto done;
		}
	}

	/* we need the username to ask for auth methods */
	if (!s->url.username) {
		if ((error = request_creds(&cred, t, NULL, GIT_CREDENTIAL_USERNAME)) < 0)
			goto done;

		s->url.username = git__strdup(((git_credential_username *) cred)->username);
		cred->free(cred);
		cred = NULL;
		if (!s->url.username)
			goto done;
	} else if (s->url.username && s->url.password) {
		if ((error = git_credential_userpass_plaintext_new(&cred, s->url.username, s->url.password)) < 0)
			goto done;
	}

	if ((error = list_auth_methods(&auth_methods, session, s->url.username)) < 0)
		goto done;

	error = GIT_EAUTH;
	/* if we already have something to try */
	if (cred && auth_methods & cred->credtype)
		error = _git_ssh_authenticate_session(session, cred);

	while (error == GIT_EAUTH) {
		if (cred) {
			cred->free(cred);
			cred = NULL;
		}

		if ((error = request_creds(&cred, t, s->url.username, auth_methods)) < 0)
			goto done;

		if (strcmp(s->url.username, git_credential_get_username(cred))) {
			git_error_set(GIT_ERROR_SSH, "username does not match previous request");
			error = -1;
			goto done;
		}

		error = _git_ssh_authenticate_session(session, cred);

		if (error == GIT_EAUTH) {
			/* refresh auth methods */
			if ((error = list_auth_methods(&auth_methods, session, s->url.username)) < 0)
				goto done;
			else
				error = GIT_EAUTH;
		}
	}

	if (error < 0)
		goto done;

	channel = libssh2_channel_open_session(session);
	if (!channel) {
		error = -1;
		ssh_error(session, "Failed to open SSH channel");
		goto done;
	}

	libssh2_channel_set_blocking(channel, 1);

	s->session = session;
	s->channel = channel;

	t->current_stream = s;

done:
	if (error < 0) {
		ssh_stream_free(*stream);

		if (session)
			libssh2_session_free(session);
	}

	if (cred)
		cred->free(cred);

	return error;
}
