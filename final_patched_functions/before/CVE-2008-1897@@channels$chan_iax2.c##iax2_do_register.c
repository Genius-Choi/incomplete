static int iax2_do_register(struct iax2_registry *reg)
{
	struct iax_ie_data ied;
	if (iaxdebug)
		ast_debug(1, "Sending registration request for '%s'\n", reg->username);

	if (reg->dnsmgr && 
	    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {
		/* Maybe the IP has changed, force DNS refresh */
		ast_dnsmgr_refresh(reg->dnsmgr);
	}
	
	/*
	 * if IP has Changed, free allocated call to create a new one with new IP
	 * call has the pointer to IP and must be updated to the new one
	 */
	if (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {
		ast_mutex_lock(&iaxsl[reg->callno]);
		iax2_destroy(reg->callno);
		ast_mutex_unlock(&iaxsl[reg->callno]);
		reg->callno = 0;
	}
	if (!reg->addr.sin_addr.s_addr) {
		if (iaxdebug)
			ast_debug(1, "Unable to send registration request for '%s' without IP address\n", reg->username);
		/* Setup the next registration attempt */
		reg->expire = iax2_sched_replace(reg->expire, sched, 
			(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);
		return -1;
	}

	if (!reg->callno) {
		ast_debug(1, "Allocate call number\n");
		reg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);
		if (reg->callno < 1) {
			ast_log(LOG_WARNING, "Unable to create call for registration\n");
			return -1;
		} else
			ast_debug(1, "Registration created on call %d\n", reg->callno);
		iaxs[reg->callno]->reg = reg;
		ast_mutex_unlock(&iaxsl[reg->callno]);
	}
	/* Setup the next registration a little early */
	reg->expire = iax2_sched_replace(reg->expire, sched, 
		(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);
	/* Send the request */
	memset(&ied, 0, sizeof(ied));
	iax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);
	iax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);
	send_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);
	reg->regstate = REG_STATE_REGSENT;
	return 0;
}
