scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)
{
  uint32_t bitlen[2];
  uint32_t r;
  const unsigned char *src = (unsigned char *) in;

  /* Number of bytes left in the buffer from previous updates */
  r = (ctx->count[1] >> 3) & 0x3f;

  /* Convert the length into a number of bits */
  bitlen[1] = ((uint32_t)len) << 3;
  bitlen[0] = (uint32_t)(len >> 29);

  /* Update number of bits */
  if ((ctx->count[1] += bitlen[1]) < bitlen[1])
    ctx->count[0]++;
  ctx->count[0] += bitlen[0];

  /* Handle the case where we don't need to perform any transforms */
  if (len < 64 - r) {
    memcpy(&ctx->buf[r], src, len);
    return;
  }

  /* Finish the current block */
  memcpy(&ctx->buf[r], src, 64 - r);
  SHA256_Transform(ctx->state, ctx->buf);
  src += 64 - r;
  len -= 64 - r;

  /* Perform complete blocks */
  while (len >= 64) {
    SHA256_Transform(ctx->state, src);
    src += 64;
    len -= 64;
  }

  /* Copy left over data into buffer */
  memcpy(ctx->buf, src, len);
}
