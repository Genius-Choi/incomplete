void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) {
	Q_UNUSED(size)

	using elf_addr   = typename M::elf_addr;
	using elf_header = typename M::elf_header;
	using elf_shdr   = typename M::elf_shdr;
	using elf_sym    = typename M::elf_sym;
	using elf_rela   = typename M::elf_rela;
	using elf_rel    = typename M::elf_rel;
	using symbol     = typename M::symbol;

	const auto base = reinterpret_cast<uintptr_t>(p);

	const auto header = static_cast<const elf_header *>(p);
	if (header->e_shnum == 0 || header->e_shentsize == 0) {
		return;
	}
	const auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff);
	const elf_shdr *const sections_end = sections_begin + header->e_shnum;
	auto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset);

	elf_addr plt_address = 0;
	elf_addr got_address = 0;
	std::set<elf_addr> plt_addresses;

	// collect special section addresses
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {
		if (strcmp(&section_strings[section->sh_name], ".plt") == 0) {
			plt_address = section->sh_addr;
		} else if (strcmp(&section_strings[section->sh_name], ".got") == 0) {
			got_address = section->sh_addr;
		}
	}

	// print out relocated symbols for special sections
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {
		elf_addr base_address = 0;
		if (strcmp(&section_strings[section->sh_name], ".rela.plt") == 0) {
			base_address = plt_address;
		} else if (strcmp(&section_strings[section->sh_name], ".rel.plt") == 0) {
			base_address = plt_address;
		} else if (strcmp(&section_strings[section->sh_name], ".rela.got") == 0) {
			base_address = got_address;
		} else if (strcmp(&section_strings[section->sh_name], ".rel.got") == 0) {
			base_address = got_address;
		} else {
			continue;
		}

		switch (section->sh_type) {
		case SHT_RELA: {
			elf_addr n      = 0;
			auto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset);

			if (section->sh_link == 0) {
				break;
			}

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const size_t sym_index = M::elf_r_sym(relocation[i].r_info);
				const elf_shdr *linked = &sections_begin[section->sh_link];
				auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);
				auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);

				const elf_addr symbol_address = base_address + ++n * M::plt_entry_size;

				const char *sym_name = &section_strings[section->sh_name];
				if (strlen(sym_name) > (sizeof(".rela.") - 1) && memcmp(sym_name, ".rela.", (sizeof(".rela.") - 1)) == 0) {
					sym_name += 6;
				}

				plt_addresses.insert(symbol_address);

				symbol sym;
				sym.address = symbol_address;
				sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);
				sym.name    = &string_tab[symbol_tab[sym_index].st_name];
				sym.name += "@";
				sym.name += sym_name;
				sym.type = 'P';
				symbols.push_back(sym);
			}
		} break;
		case SHT_REL: {
			elf_addr n      = 0;
			auto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset);

			if (section->sh_link == 0) {
				break;
			}

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const size_t sym_index = M::elf_r_sym(relocation[i].r_info);
				const elf_shdr *linked = &sections_begin[section->sh_link];
				auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset);
				auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset);

				const elf_addr symbol_address = base_address + ++n * M::plt_entry_size;

				const char *sym_name = &section_strings[section->sh_name];
				if (strlen(sym_name) > (sizeof(".rel.") - 1) && memcmp(sym_name, ".rel.", (sizeof(".rel.") - 1)) == 0) {
					sym_name += 5;
				}

				plt_addresses.insert(symbol_address);

				symbol sym;
				sym.address = symbol_address;
				sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10);
				sym.name    = &string_tab[symbol_tab[sym_index].st_name];
				sym.name += "@";
				sym.name += sym_name;
				sym.type = 'P';
				symbols.push_back(sym);
			}
		} break;
		}
	}

	// collect regular symbols
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {

		switch (section->sh_type) {
		case SHT_SYMTAB:
		case SHT_DYNSYM: {
			auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);
			auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const elf_shdr *related_section = nullptr;

				if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {
					related_section = &sections_begin[symbol_tab[i].st_shndx];
				}

				Q_UNUSED(related_section)

				if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {

					if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) {

						symbol sym;
						sym.address = symbol_tab[i].st_value;
						sym.size    = symbol_tab[i].st_size;
						sym.name    = &string_tab[symbol_tab[i].st_name];
						sym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');
						symbols.push_back(sym);
					}
				}
			}
		} break;
		}
	}

	// collect unnamed symbols
	for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {

		switch (section->sh_type) {
		case SHT_SYMTAB:
		case SHT_DYNSYM: {
			auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset);
			auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset);

			for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) {

				const elf_shdr *related_section = nullptr;

				if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) {
					related_section = &sections_begin[symbol_tab[i].st_shndx];
				}

				Q_UNUSED(related_section)

				if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) {

					if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) {
						symbol sym;
						sym.address = symbol_tab[i].st_value;
						sym.size    = symbol_tab[i].st_size;

						for (const elf_shdr *section = sections_begin; section != sections_end; ++section) {
							if (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) {
								const std::int64_t offset = sym.address - section->sh_addr;
								const QString hexPrefix   = std::abs(offset) > 9 ? "0x" : "";
								const QString offsetStr   = offset ? "+" + hexPrefix + QString::number(offset, 16) : "";
								const QString sectionName(&section_strings[section->sh_name]);
								if (!sectionName.isEmpty()) {
									sym.name = QString(sectionName + offsetStr);
									break;
								}
							}
						}

						if (sym.name.isEmpty()) {
							sym.name = QString("$sym_%1").arg(edb::v1::format_pointer(symbol_tab[i].st_value));
						}

						sym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D');
						symbols.push_back(sym);
					}
				}
			}
		} break;
		}
	}
}
