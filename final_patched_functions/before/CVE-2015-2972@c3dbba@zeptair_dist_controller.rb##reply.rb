  def reply
    Log.add_info(request, '')   # Not to show passwords.

    unless params[:attach_id].nil? or params[:attach_id].empty?
      target = Attachment.find(params[:attach_id])
    end
    unless params[:cmd_id].nil? or params[:cmd_id].empty?
      target = ZeptairCommand.find(params[:cmd_id])
    end
    if target.nil? or target.item.nil? \
        or target.item.xtype != Item::XTYPE_ZEPTAIR_DIST
      render(:text => 'ERROR:' + t('msg.system_error'))
      return
    end
    item = target.item

    comment = ZeptairDistHelper.get_comment_of(item.id, @login_user.id)

    case params[:status]
      when ZeptairDistHelper::ENTRY_STATUS_SAVED, ZeptairDistHelper::ENTRY_STATUS_EXECUTED, ZeptairDistHelper::ENTRY_STATUS_ERROR
        new_entry = "#{target.class}#{ZeptairDistHelper::ACK_CLASS_SEP}#{target.id}#{ZeptairDistHelper::ACK_ID_SEP}#{params[:timestamp]}#{ZeptairDistHelper::ACK_TS_SEP}#{params[:status]}"

        if comment.nil?
          comment = Comment.new
          comment.user_id = @login_user.id
          comment.item_id = item.id
          comment.xtype = Comment::XTYPE_DIST_ACK
          comment.message = new_entry + "\n"
          comment.save!
        else
          class_order = {'Attachment' => 0, 'ZeptairCommand' => 1}
          target_order = class_order[target.class.to_s]

          entries = ZeptairDistHelper.get_ack_array_of(comment)

          unless entries.include?(new_entry)
            msg = ''
            inserted = false

            entries.each do |entry|
              next if entry.nil? or entry.empty?

              regexp = Regexp.new("^([a-zA-Z]+)#{ZeptairDistHelper::ACK_CLASS_SEP}(\\d+)[#{ZeptairDistHelper::ACK_ID_SEP}]")
              matched_ary = entry.scan(regexp)
              next if matched_ary.nil?
              matched_ary = matched_ary.flatten
              next if matched_ary.length < 2

              entry_class = matched_ary.first
              entry_order = class_order[entry_class]
              entry_id = matched_ary.last.to_i
              if entry_class == target.class.to_s \
                  and entry_id == target.id
                msg << new_entry + "\n"
                inserted = true
              elsif !inserted \
                  and \
                    ((entry_class == target.class.to_s and target.id < entry_id) \
                      or (entry_class != target.class.to_s and target_order < entry_order))
                msg << new_entry + "\n"
                msg << entry + "\n"
                inserted = true
              else
                msg << entry + "\n"
              end
            end
            unless inserted
              msg << new_entry + "\n"
            end
            comment.update_attribute(:message, msg)
          end
        end
      when 'canceled'
        unless comment.nil?
          if comment.message.nil?
            entries = []
          else
            entries = comment.message.split("\n")
          end
          msg = ''
          exp = "^#{target.class}#{ZeptairDistHelper::ACK_CLASS_SEP}#{target.id}#{ZeptairDistHelper::ACK_ID_SEP}"

          entries.each do |entry|
            next if entry.nil? or entry.empty?

            if entry.match(exp).nil?
              msg << entry + "\n"
            end
          end

          if msg.empty?
            comment.destroy
          else
            comment.update_attribute(:message, msg)
          end
        end
    end
    render(:text => '')
  end
