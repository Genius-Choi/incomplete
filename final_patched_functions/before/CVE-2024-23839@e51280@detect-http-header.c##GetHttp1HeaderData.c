static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,
        const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,
        int list_id)
{
    SCEnter();

    InspectionBuffer *buffer =
            InspectionBufferMultipleForListGet(det_ctx, list_id, cbdata->local_id);
    if (buffer == NULL)
        return NULL;
    if (buffer->initialized)
        return buffer;

    HttpHeaderThreadData *hdr_td = NULL;
    HttpHeaderBuffer *buf =
            HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);
    if (unlikely(buf == NULL)) {
        return NULL;
    }

    htp_tx_t *tx = (htp_tx_t *)cbdata->txv;
    htp_table_t *headers;
    if (flags & STREAM_TOSERVER) {
        headers = tx->request_headers;
    } else {
        headers = tx->response_headers;
    }
    if (cbdata->local_id < htp_table_size(headers)) {
        htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);
        size_t size1 = bstr_size(h->name);
        size_t size2 = bstr_size(h->value);
        size_t b_len = size1 + 2 + size2;
        if (b_len > buf->size) {
            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {
                return NULL;
            }
        }
        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));
        buf->buffer[size1] = ':';
        buf->buffer[size1 + 1] = ' ';
        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));
        buf->len = b_len;
    } else {
        InspectionBufferSetupMultiEmpty(buffer);
        return NULL;
    }
    if (buf->len == 0) {
        InspectionBufferSetupMultiEmpty(buffer);
        return NULL;
    }

    InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);

    SCReturnPtr(buffer, "InspectionBuffer");
}
