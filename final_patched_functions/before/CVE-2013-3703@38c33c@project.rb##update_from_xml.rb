  def update_from_xml(xmlhash, force=nil)
    # check for raising read access permissions, which can't get ensured atm
    unless self.new_record? || self.disabled_for?('access', nil, nil)
      if FlagHelper.xml_disabled_for?(xmlhash, 'access')
        raise ForbiddenError.new
      end
    end
    unless self.new_record? || self.disabled_for?('sourceaccess', nil, nil)
      if FlagHelper.xml_disabled_for?(xmlhash, 'sourceaccess')
        raise ForbiddenError.new
      end
    end
    new_record = self.new_record?
    if ::Configuration.first.default_access_disabled == true and not new_record
      if self.disabled_for?('access', nil, nil) and not FlagHelper.xml_disabled_for?(xmlhash, 'access')
        raise ForbiddenError.new
      end
    end

    logger.debug "### name comparison: self.name -> #{self.name}, project_name -> #{xmlhash['name']}"
    if self.name != xmlhash['name']
      raise SaveError, "project name mismatch: #{self.name} != #{xmlhash['name']}"
    end

    self.title = xmlhash.value('title')
    self.description = xmlhash.value('description')
    self.remoteurl = xmlhash.value('remoteurl')
    self.remoteproject = xmlhash.value('remoteproject')
    kind = xmlhash['kind'] || "standard"
    project_type = DbProjectType.find_by_name(kind)
    raise SaveError.new("unable to find project kind '#{kind}'") unless project_type
    self.type_id = project_type.id

    # give us an id
    self.save!

    #--- update linked projects ---#
    position = 1
    #destroy all current linked projects
    self.linkedprojects.destroy_all

    #recreate linked projects from xml
    xmlhash.elements('link') do |l|
      link = Project.find_by_name( l['project'] )
      if link.nil?
        if Project.find_remote_project(l['project'])
          self.linkedprojects.create(project: self,
                                     linked_remote_project_name: l['project'],
                                     position: position)
        else
          raise SaveError, "unable to link against project '#{l['project']}'"
        end
      else
        if link == self
          raise SaveError, "unable to link against myself"
        end
        self.linkedprojects.create!(project: self,
                                    linked_db_project: link,
                                    position: position)
      end
      position += 1
    end
    #--- end of linked projects update  ---#
    
    #--- devel project ---#
    self.develproject = nil
    if devel = xmlhash['devel']
      if prj_name = devel['project']
        unless develprj = Project.get_by_name(prj_name)
          raise SaveError, "value of develproject has to be a existing project (project '#{prj_name}' does not exist)"
        end
        if develprj == self
          raise SaveError, "Devel project can not point to itself"
        end
        self.develproject = develprj
      end
    end
    #--- end devel project ---#

    # cycle detection
    prj = self
    processed = {}
    while ( prj and prj.develproject )
      prj_name = prj.name
      # cycle detection
      if processed[prj_name]
        str = ""
        processed.keys.each do |key|
          str = str + " -- " + key
        end
        raise CycleError.new "There is a cycle in devel definition at #{str}"
      end
      processed[prj_name] = 1
      prj = prj.develproject
      prj = self if prj && prj.id == self.id
    end
    
    #--- maintenance-related parts ---#
    # The attribute 'type' is only set for maintenance and maintenance incident projects.
    # kind_element = xmlhash['kind)
    # First remove all maintained project relations
    maintained_projects.each do |maintained_project|
      maintained_project.maintenance_project = nil
      maintained_project.save!
    end
    # Set this project as the maintenance project for all maintained projects found in the XML
    xmlhash.get('maintenance').elements("maintains") do |maintains|
      maintained_project = Project.find_by_name!(maintains['project'])
      maintained_project.maintenance_project = self
      maintained_project.save!
    end

    #--- update users ---#
    usercache = Hash.new
    self.project_user_role_relationships.each do |purr|
      h = usercache[purr.user.login] ||= Hash.new
      h[purr.role.title] = purr
    end

    xmlhash.elements('person') do |person|
      user=User.find_by_login!(person['userid'])
      if not Role.rolecache.has_key? person['role']
        raise SaveError, "illegal role name '#{person.role}'"
      end
      
      if usercache.has_key? person['userid']
        # user has already a role in this project
        pcache = usercache[person['userid']]
        if pcache.has_key? person['role']
          #role already defined, only remove from cache
          pcache[person['role']] = :keep
        else
          #new role
          self.project_user_role_relationships.new(user: user, role: Role.rolecache[person['role']])
          pcache[person['role']] = :new
        end
      else
        self.project_user_role_relationships.new(user: user, role: Role.rolecache[person['role']])
        usercache[person['userid']] = { person['role'] => :new }
      end
    end
      
    #delete all roles that weren't found in the uploaded xml
    usercache.each do |user, roles|
      roles.each do |role, object|
        next if [:keep, :new].include? object
        object.delete
      end
    end
    
    #--- end update users ---#
    
    #--- update groups ---#
    groupcache = Hash.new
    self.project_group_role_relationships.each do |pgrr|
      h = groupcache[pgrr.group.title] ||= Hash.new
      h[pgrr.role.title] = pgrr
    end

    xmlhash.elements('group') do |ge|
      group=Group.find_by_title(ge['groupid'])
      if not Role.rolecache.has_key? ge['role']
        raise SaveError, "illegal role name '#{ge['role']}'"
      end
      
      if groupcache.has_key? ge['groupid']
        # group has already a role in this project
        pcache = groupcache[ge['groupid']]
        if pcache.has_key? ge['role']
          #role already defined, only remove from cache
          pcache[ge['role']] = :keep
        else
          #new role
          self.project_group_role_relationships.new(group: group, role: Role.rolecache[ge['role']])
          pcache[ge['role']] = :new
        end
      else
        if !group
          # check with LDAP
          if defined?( CONFIG['ldap_mode'] ) && CONFIG['ldap_mode'] == :on
            if defined?( CONFIG['ldap_group_support'] ) && CONFIG['ldap_group_support'] == :on
              if User.find_group_with_ldap(ge['groupid'])
                logger.debug "Find and Create group '#{ge['groupid']}' from LDAP"
                newgroup = Group.create( :title => ge['groupid'] )
                unless newgroup.errors.empty?
                  raise SaveError, "unknown group '#{ge['groupid']}', failed to create the ldap groupid on OBS"
                end
                group=Group.find_by_title(ge['groupid'])
              else
                raise SaveError, "unknown group '#{ge['groupid']}' on LDAP server"
              end
            end
          end
          
          unless group
            raise SaveError, "unknown group '#{ge['groupid']}'"
          end
        end
        
        self.project_group_role_relationships.new(group: group, role: Role.rolecache[ge['role']])
      end
    end
    
    #delete all roles that weren't found in the uploaded xml
    groupcache.each do |group, roles|
      roles.each do |role, object|
        next if [:keep, :new].include? object
        object.destroy
      end
    end
    #--- end update groups ---#
    
    #--- update flag group ---#
    update_all_flags( xmlhash )
    if ::Configuration.first.default_access_disabled == true and new_record
      # write a default access disable flag by default in this mode for projects if not defined
      unless xmlhash.elements('access').length > 0
        self.flags.new(:status => 'disable', :flag => 'access')
      end
    end
    
    #--- update repository download settings ---#
    dlcache = Hash.new
    self.downloads.each do |dl|
      dlcache["#{dl.architecture.name}"] = dl
    end
    
    xmlhash.elements('download') do |dl|
      if dlcache.has_key? dl['arch']
        logger.debug "modifying download element, arch: #{dl['arch']}"
        cur = dlcache[dl['arch']]
      else
        logger.debug "adding new download entry, arch #{dl['arch']}"
        cur = self.downloads.create
        self.updated_at = Time.now
      end
      cur.metafile = dl['metafile']
      cur.mtype = dl['mtype']
      cur.baseurl = dl['baseurl']
      raise SaveError, "unknown architecture" unless Architecture.archcache.has_key? dl['arch']
      cur.architecture = Architecture.archcache[dl['arch']]
      cur.save!
      dlcache.delete dl['arch']
    end

    dlcache.each do |arch, object|
      logger.debug "remove download entry #{arch}"
      self.downloads.destroy object
      self.updated_at = Time.now
    end
    
    #--- update repositories ---#
    repocache = Hash.new
    self.repositories.each do |repo|
      repocache[repo.name] = repo unless repo.remote_project_name
    end
    
    xmlhash.elements("repository") do |repo|
      was_updated = false
      
      if not repocache.has_key? repo['name']
        logger.debug "adding repository '#{repo['name']}'"
        current_repo = self.repositories.new( :name => repo['name'] )
        was_updated = true
      else
        logger.debug "modifying repository '#{repo['name']}'"
        current_repo = repocache[repo['name']]
      end
      
      #--- repository flags ---#
      # check for rebuild configuration
      if !repo.has_key? 'rebuild' and current_repo.rebuild
        current_repo.rebuild = nil
        was_updated = true
      end
      if repo.has_key? 'rebuild'
        if repo['rebuild'] != current_repo.rebuild
          current_repo.rebuild = repo['rebuild']
          was_updated = true
        end
      end
      # check for block configuration
      if not repo.has_key? 'block' and current_repo.block
        current_repo.block = nil
        was_updated = true
      end
      if repo.has_key? 'block'
        if repo['block'] != current_repo.block
          current_repo.block = repo['block']
          was_updated = true
        end
      end
      # check for linkedbuild configuration
      if not repo.has_key? 'linkedbuild' and current_repo.linkedbuild
        current_repo.linkedbuild = nil
        was_updated = true
      end
      if repo.has_key? 'linkedbuild'
        if repo['linkedbuild'] != current_repo.linkedbuild
          current_repo.linkedbuild = repo['linkedbuild']
          was_updated = true
        end
      end
      #--- end of repository flags ---#

      #destroy all current releasetargets
      current_repo.release_targets.each { |rt| rt.destroy }

      #recreate release targets from xml
      repo.elements("releasetarget") do |rt|
        target_repo = Repository.find_by_project_and_repo_name( rt['project'], rt['repository'] )
        unless target_repo
          raise SaveError.new("Unknown target repository '#{rt['project']}/#{rt['repository']}'")
        end
        unless target_repo.remote_project_name.nil?
          raise SaveError.new("Can not use remote repository as release target '#{rt['project']}/#{rt['repository']}'")
        end
        current_repo.release_targets.new :target_repository => target_repo, :trigger => rt['trigger']
        was_updated = true
      end

      #set host hostsystem
      if repo.has_key? 'hostsystem'
        hostsystem = Project.get_by_name repo['hostsystem']['project']
        target_repo = hostsystem.repositories.find_by_name repo['hostsystem']['repository']
        if repo['hostsystem']['project'] == self.name and repo['hostsystem']['repository'] == repo['name']
          raise SaveError, "Using same repository as hostsystem element is not allowed"
        end
        unless target_repo
          raise SaveError, "Unknown target repository '#{repo['hostsystem']['project']}/#{repo['hostsystem']['repository']}'"
        end
        if target_repo != current_repo.hostsystem
          current_repo.hostsystem = target_repo
          was_updated = true
        end
      elsif current_repo.hostsystem
        current_repo.hostsystem = nil
        was_updated = true
      end

      #destroy all current pathelements
      current_repo.path_elements.each { |pe| pe.destroy }

      #recreate pathelements from xml
      position = 1
      repo.elements('path') do |path|
        link_repo = Repository.find_by_project_and_repo_name( path['project'], path['repository'] )
        if path['project'] == self.name and path['repository'] == repo['name']
          raise SaveError, "Using same repository as path element is not allowed"
        end
        unless link_repo
          raise SaveError, "unable to walk on path '#{path['project']}/#{path['repository']}'"
        end
        current_repo.path_elements.new :link => link_repo, :position => position
        position += 1
        was_updated = true
      end

      was_updated = true if current_repo.architectures.size > 0 or repo.elements('arch').size > 0

      if was_updated
        current_repo.save!
        self.updated_at = Time.now
      end

      #destroy architecture references
      logger.debug "delete all of #{current_repo.id}"
      RepositoryArchitecture.delete_all(["repository_id = ?", current_repo.id])

      position = 1
      repo.elements('arch') do |arch|
        unless Architecture.archcache.has_key? arch
          raise SaveError, "unknown architecture: '#{arch}'"
        end
        a = current_repo.repository_architectures.new :architecture => Architecture.archcache[arch]
        a.position = position
        position += 1
        a.save
        was_updated = true
      end

      repocache.delete repo['name']
    end

    # delete remaining repositories in repocache
    repocache.each do |name, object|
      logger.debug "offending repo: #{object.inspect}"
      unless force
        #find repositories that link against this one and issue warning if found
        list = PathElement.where(repository_id: object.id)
        error = ""
        unless list.empty?
          linking_repos = list.map {|x| x.repository.project.name+"/"+x.repository.name}.join "\n"
          error << "Repository #{self.name}/#{name} cannot be deleted because following repos link against it:\n"+linking_repos
        end
        list = ReleaseTarget.where(target_repository_id: object.id)
        unless list.empty?
          linking_repos = list.map {|x| x.repository.project.name+"/"+x.repository.name}.join "\n"
          error << "Repository #{self.name}/#{name} cannot be deleted because following repos define it as release target:/\n"+linking_repos
        end
        raise SaveError, error unless error.blank?
      end
      logger.debug "deleting repository '#{name}'"
      self.repositories.destroy object
      self.updated_at = Time.now
    end
    repocache = nil
    #--- end update repositories ---#
    
    save!
  end
