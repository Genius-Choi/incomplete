static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,
			       struct vqueue_info *vq)
{
	struct pci_vtsock_sock *sock;
	struct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;
	uint16_t idx, flags[VTSOCK_MAXSEGS];
	struct virtio_sock_hdr hdr;
	int iovec_len;
	size_t pulled;

	iovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);
	assert(iovec_len <= VTSOCK_MAXSEGS);

	DPRINTF(("TX: chain with %d buffers at idx %"PRIx16"\n",
		 iovec_len, idx));
	dprint_chain(iov, iovec_len, "TX");
	//assert(iov[0].iov_len >= sizeof(*hdr));
	//hdr = iov[0].iov_base;

	pulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));
	assert(pulled == sizeof(hdr));

	dprint_header(&hdr, 1, "TX");

	dprint_iovec(iov, iovec_len, "TX");

	if (hdr.src_cid != sc->vssc_cfg.guest_cid ||
	    hdr.dst_cid != VMADDR_CID_HOST ||
	    hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {
		DPRINTF(("TX: Bad src/dst address/type\n"));
		send_response_nosock(sc, VIRTIO_VSOCK_OP_RST,
				     hdr.type,
				     (struct vsock_addr) {
					     .cid = hdr.dst_cid,
					     .port =hdr.dst_port
				     },
				     (struct vsock_addr) {
					     .cid = hdr.src_cid,
					     .port =hdr.src_port
				     });
		vq_relchain(vq, idx, 0);
		return;
	}

	sock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,
			   (struct vsock_addr) {
				   .cid = hdr.dst_cid,
					   .port =hdr.dst_port
			   },
			   (struct vsock_addr) {
				   .cid = hdr.src_cid,
					   .port =hdr.src_port
			   });

	if (sock) {
		sock->peer_buf_alloc = hdr.buf_alloc;
		sock->peer_fwd_cnt = hdr.fwd_cnt;
	}

	switch (hdr.op) {
	case VIRTIO_VSOCK_OP_INVALID:
		PPRINTF(("TX: => INVALID\n"));
		goto do_rst;

	case VIRTIO_VSOCK_OP_REQUEST:
		/* Attempt to (re)connect existing sock? Naughty! */
		/* Or is it -- what are the semantics? */
		if (sock) {
			PPRINTF(("TX: Attempt to reconnect sock\n"));
			goto do_rst;
		}

		if (hdr.dst_cid == sc->vssc_cfg.guest_cid) {
			PPRINTF(("TX: Attempt to connect back to guest\n!"));
			goto do_rst;
		}

		sock = connect_sock(sc,
				    (struct vsock_addr){
					    .cid = hdr.dst_cid, .port = hdr.dst_port
				    },
				    (struct vsock_addr){
					    .cid = hdr.src_cid, .port = hdr.src_port
				    }, hdr.buf_alloc, hdr.fwd_cnt);
		if (!sock) {
			PPRINTF(("TX: Failed to open sock\n"));
			goto do_rst;
		}

		send_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);
		vq_relchain(vq, idx, 0);
		/* No rx kick required, send_response_sock did one */
		break;

	case VIRTIO_VSOCK_OP_RESPONSE:
		if (!sock) {
			PPRINTF(("TX: RESPONSE to non-existent sock\n"));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTING) {
			PPRINTF(("TX: RESPONSE to non-connecting sock (state %d)\n",
				 sock->state));
			goto do_rst;
		}
		PPRINTF(("TX: SOCK connected (%d) "PRIaddr" <=> "PRIaddr"\n",
			 sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));
		sock->state = SOCK_CONNECTED;
		vq_relchain(vq, idx, 0);
		kick_rx(sc, "new outgoing sock");
		break;

	case VIRTIO_VSOCK_OP_RST:
		/* No response */
		if (!sock)
			PPRINTF(("TX: RST to non-existent sock\n"));
		close_sock(sc, sock, "TX");
		vq_relchain(vq, idx, 0);
		break;

	case VIRTIO_VSOCK_OP_SHUTDOWN:
		if (!sock) {
			DPRINTF(("TX: SHUTDOWN to non-existent sock "PRIcid"."PRIport"\n",
				 hdr.dst_cid, hdr.dst_port));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF(("TX: SHUTDOWN to non-connected sock (state %d)\n",
				 sock->state));
			goto do_rst;
		}
		if (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {
			PPRINTF(("TX: SHUTDOWN with reserved flags %"PRIx32"\n",
				 hdr.flags));
			goto do_rst; /* ??? */
		}
		if (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {
			PPRINTF(("TX: SHUTDOWN with no flags %"PRIx32"\n",
				 hdr.flags));
			goto do_rst; /* ??? */
		}

		shutdown_peer_local_fd(sock, hdr.flags, "TX");

		/* If the peer is now SHUTDOWN_ALL then we should send
		 * a RST to the peer to finalise the shutdown.
		 */
		if (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)
			goto do_rst;

		vq_relchain(vq, idx, 0);
		break;

	case VIRTIO_VSOCK_OP_RW:
	{
		int rc;

		if (!sock) {
			PPRINTF(("TX: RW with no sock\n"));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF(("TX: RW to non-connected sock (state %d)\n",
				 sock->state));
			goto do_rst;
		}
		if (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {
			PPRINTF(("TX: RW to socket with peer_shutdown.TX\n"));
			goto do_rst;
		}
		if (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {
			PPRINTF(("TX: RW to socket with local_shutdown.RX\n"));
			goto do_rst;
		}
		rc = handle_write(sc, sock, hdr.len, iov, iovec_len);
		if (rc < 0) goto do_rst;
		vq_relchain(vq, idx, 0);
		if (rc == 1)
			set_credit_update_required(sc, sock);
		break;
	}

	case VIRTIO_VSOCK_OP_CREDIT_UPDATE:
		if (!sock) {
			PPRINTF(("TX: CREDIT_UPDATE to non-existent sock\n"));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF(("TX: CREDIT_UPDATE to non-connected sock (state %d)\n",
				 sock->state));
			goto do_rst;
		}
		/* No response needed, we updated above */
		vq_relchain(vq, idx, 0);
		/* But kick rx thread to attempt to send more */
		sc->rx_kick_pending = true;
		break;

	case VIRTIO_VSOCK_OP_CREDIT_REQUEST:
		if (!sock) {
			PPRINTF(("TX: CREDIT_REQUEST to non-existent sock\n"));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF(("TX: CREDIT_REQUEST to non-connected sock (state %d)\n",
				 sock->state));
			goto do_rst;
		}
		vq_relchain(vq, idx, 0);
		set_credit_update_required(sc, sock);
		break;
	}

	if (sock)
		put_sock(sock);

	return;

do_rst:
	if (sock)
		send_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);
	else
		send_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,
				     (struct vsock_addr) {
					     .cid = hdr.dst_cid,
					     .port =hdr.dst_port
				     },
				     (struct vsock_addr) {
					     .cid = hdr.src_cid,
					     .port =hdr.src_port
				     });
	vq_relchain(vq, idx, 0);
	close_sock(sc, sock, "TX");
	if (sock) put_sock(sock);
	return;
}
