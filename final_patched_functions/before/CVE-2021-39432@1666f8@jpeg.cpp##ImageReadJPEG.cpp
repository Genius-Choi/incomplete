FileInformation ImageReadJPEG(
      Image& out,
      String const& filename
) {
   // Open the file
   JpegInput jpeg( filename );

   // Get info
   FileInformation info = GetJPEGInfo( jpeg );

   // Allocate image
   int nchan = jpeg.cinfo().num_components;
   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;
   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );
   out.SetPixelSize( info.pixelSize );
   out.SetColorSpace( info.colorSpace );

   // Read data
   jpeg_start_decompress( jpeg.cinfoptr() );
   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); // casting to unsigned rather than dip::uint to shut up GCC warning.
   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );
   auto stride = out.Strides();
   auto tStride = out.TensorStride();
   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {
      JSAMPLE* indata = buffer.data();
      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );
      dip::uint8* outdata = imagedata;
      if( nchan > 1 ) {
         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {
            for( int kk = 0; kk < nchan; ++kk ) {
               *( outdata + kk * tStride ) = *indata;
               ++indata;
            }
            outdata += stride[ 0 ];
         }
      } else {
         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {
            *outdata = *indata;
            ++indata;
            outdata += stride[ 0 ];
         }
      }
      imagedata += stride[ 1 ];
   }
   jpeg_finish_decompress( jpeg.cinfoptr() );

   return info;
}
