  def create_patchinfo_from_request(req)
    patchinfo = Package.new(:name => "patchinfo", :title => "Patchinfo", :description => "Collected packages for update")
    self.packages << patchinfo
    patchinfo.add_flag("build", "enable", nil, nil)
    patchinfo.add_flag("useforbuild", "disable", nil, nil)
    patchinfo.add_flag("publish", "enable", nil, nil) unless self.flags.find_by_flag_and_status("access", "disable")
    patchinfo.store
    
    # create patchinfo XML file
    node = Nokogiri::XML::Builder.new
    attrs = { }
    if self.project_type.to_s == "maintenance_incident"
      # this is a maintenance incident project, the sub project name is the maintenance ID
      attrs[:incident] = self.name.gsub(/.*:/, '')
    end
    
    description = req.description || ''
    node.patchinfo(attrs) do |n|
      n.packager    req.creator
      n.category    "recommended" # update_patchinfo may switch to security
      n.rating      "low"
      n.summary     description.split(/\n|\r\n/)[0] # first line only
      n.description req.description
    end
    data = ActiveXML::Node.new( node.doc.to_xml )
    data = self.update_patchinfo( data, enfore_issue_update: true )
    p = { :user => User.current.login, :comment => "generated by request id #{req.id} accept call" }
    patchinfo_path = "/source/#{CGI.escape(patchinfo.project.name)}/patchinfo/_patchinfo"
    patchinfo_path << Suse::Backend.build_query_from_hash(p, [:user, :comment])
    Suse::Backend.put( patchinfo_path, data.dump_xml )
    patchinfo.sources_changed
  end
