smix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)
{
  uint32_t * X = XY;
  uint32_t * Y = &XY[32 * r];
  uint32_t * Z = &XY[64 * r];
  uint64_t i;
  uint64_t j;
  size_t k;

  /* 1: X <-- B */
  for (k = 0; k < 32 * r; k++) {
    X[k] = folly::Endian::little32(*((uint32_t *) &B[4 * k]));
  }

  /* 2: for i = 0 to N - 1 do */
  for (i = 0; i < N; i += 2) {
    /* 3: V_i <-- X */
    blkcpy(&V[i * (32 * r)], X, 128 * r);

    /* 4: X <-- H(X) */
    blockmix_salsa8(X, Y, Z, r);

    /* 3: V_i <-- X */
    blkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);

    /* 4: X <-- H(X) */
    blockmix_salsa8(Y, X, Z, r);
  }

  /* 6: for i = 0 to N - 1 do */
  for (i = 0; i < N; i += 2) {
    /* 7: j <-- Integerify(X) mod N */
    j = integerify(X, r) & (N - 1);

    /* 8: X <-- H(X \xor V_j) */
    blkxor(X, &V[j * (32 * r)], 128 * r);
    blockmix_salsa8(X, Y, Z, r);

    /* 7: j <-- Integerify(X) mod N */
    j = integerify(Y, r) & (N - 1);

    /* 8: X <-- H(X \xor V_j) */
    blkxor(Y, &V[j * (32 * r)], 128 * r);
    blockmix_salsa8(Y, X, Z, r);
  }

  /* 10: B' <-- X */
  for (k = 0; k < 32 * r; k++) {
    *((uint32_t *) &B[4 * k]) = folly::Endian::little32(X[k]);
  }
}
