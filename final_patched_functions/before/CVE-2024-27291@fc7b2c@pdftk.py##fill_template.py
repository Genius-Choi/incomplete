def fill_template(template, data_strings=None, data_names=None, hidden=None, readonly=None, images=None, pdf_url=None, editable=True, pdfa=False, password=None, owner_password=None, template_password=None, default_export_value=None, replacement_font=None):
    if data_strings is None:
        data_strings = []
    if data_names is None:
        data_names = []
    if hidden is None:
        hidden = []
    if readonly is None:
        readonly = []
    if images is None:
        images = []
    if pdf_url is None:
        pdf_url = 'file.pdf'
    if not pdf_url.endswith('.pdf'):
        pdf_url += '.pdf'
    the_fields = read_fields(template)
    if len(the_fields) == 0:
        raise DAError("PDF template has no fields in it.")
    export_values = {}
    for field, default, pageno, rect, field_type, export_value in the_fields:  # pylint: disable=unused-variable
        field_type = re.sub(r'[^/A-Za-z]', '', str(field_type))
        if field_type in ('/Btn', "/'Btn'"):
            if field in export_values:
                export_values[field].append(export_value or default_export_value or 'Yes')
            else:
                export_values[field] = [export_value or default_export_value or 'Yes']
    if len(export_values) > 0:
        new_data_strings = []
        for key, val in data_strings:
            if key in export_values and len(export_values[key]) > 0:
                if len(export_values[key]) > 1:
                    # Implies a radio button, so val should stay the same. Check for yes vs True, since
                    # parse.py turns "true" into "yes".
                    # Just turn things off if it doesn't match any value
                    if 'True' in export_values[key] and val in ('Yes', 'yes'):
                        val = 'True'
                    if 'False' in export_values[key] and val in ('No', 'no'):
                        val = 'False'
                    if val not in export_values[key]:
                        val = 'Off'
                else:
                    export_val = export_values[key][0]
                    if str(val) in ('Yes', 'yes', 'True', 'true', 'On', 'on', export_val):
                        val = export_val
                    else:
                        if export_val == 'On':
                            val = 'Off'
                        elif export_val == 'on':
                            val = 'off'
                        elif export_val == 'yes':
                            val = 'no'
                        else:
                            val = 'No'
            new_data_strings.append((key, val))
        data_strings = new_data_strings
    data_dict = {}
    for key, val in data_strings:
        data_dict[key] = val
    pdf_file = tempfile.NamedTemporaryFile(prefix="datemp", mode="wb", suffix=".pdf", delete=False)
    if pdfa or not editable:
        fdf = Xfdf(pdf_url, data_dict)
        # fdf = fdfgen.forge_fdf(pdf_url, data_strings, data_names, hidden, readonly)
        fdf_file = tempfile.NamedTemporaryFile(prefix="datemp", mode="wb", suffix=".xfdf", delete=False)
        # fdf_file.write(fdf)
        fdf_file.close()
        fdf.write_xfdf(fdf_file.name)
        if template_password is not None:
            template_file = tempfile.NamedTemporaryFile(prefix="datemp", mode="wb", suffix=".pdf", delete=False)
            qpdf_subprocess_arguments = [QPDF_PATH, '--decrypt', '--password=' + template_password, template, template_file.name]
            try:
                result = subprocess.run(qpdf_subprocess_arguments, timeout=60, check=False).returncode
            except subprocess.TimeoutExpired:
                result = 1
                logmessage("fill_template: call to qpdf took too long")
            if result != 0:
                logmessage("Failed to decrypt PDF template " + str(template))
                raise DAError("Call to qpdf failed for template " + str(template) + " where arguments were " + " ".join(qpdf_subprocess_arguments))
            template = template_file.name
        if replacement_font:
            if REPLACEMENT_FONT_SUPPORTED:
                font_arguments = ['replacement_font', replacement_font]
            else:
                logmessage("Warning: the rendering font feature requires system version 1.4.73 or later")
                font_arguments = []
        else:
            font_arguments = DEFAULT_FONT_ARGUMENTS
        subprocess_arguments = [PDFTK_PATH, template, 'fill_form', fdf_file.name, 'output', pdf_file.name] + font_arguments
        # logmessage("Arguments are " + str(subprocess_arguments))
        if len(images) > 0:
            subprocess_arguments.append('need_appearances')
        else:
            subprocess_arguments.append('flatten')
        completed_process = None
        try:
            completed_process = subprocess.run(subprocess_arguments, timeout=600, check=False, capture_output=True)
            result = completed_process.returncode
        except subprocess.TimeoutExpired:
            result = 1
            logmessage("fill_template: call to pdftk fill_form took too long")
        if result != 0:
            logmessage("Failed to fill PDF form " + str(template))
            pdftk_error_msg = (f": {completed_process.stderr}") if completed_process else ""
            raise DAError("Call to pdftk failed for template " + str(template) + " where arguments were " + " ".join(subprocess_arguments) + pdftk_error_msg)
        if len(images) > 0:
            temp_pdf_file = tempfile.NamedTemporaryFile(prefix="datemp", mode="wb", suffix=".pdf", delete=False)
            shutil.copyfile(pdf_file.name, temp_pdf_file.name)
            pdf = Pdf.open(temp_pdf_file.name)
    else:
        if template_password:
            pdf = Pdf.open(template, password=template_password)
        else:
            pdf = Pdf.open(template)
        pdf.Root.AcroForm.NeedAppearances = True
        for page in pdf.pages:
            if not hasattr(page, 'Annots'):
                continue
            for the_annot in page.Annots:
                for field, value in data_dict.items():
                    annot = the_annot
                    annot_kid = None
                    while not (hasattr(annot, "FT") and hasattr(annot, "T")) and hasattr(annot, 'Parent'):
                        annot_kid = annot
                        annot = annot.Parent
                    if not (hasattr(annot, "T") and hasattr(annot, "FT")):
                        continue
                    if field != str(annot.T):
                        continue
                    field_type = str(annot.FT)
                    if field_type == "/Tx":
                        the_string = pikepdf.String(value)
                        annot.V = the_string
                        annot.DV = the_string
                    elif field_type == "/Btn":
                        if hasattr(annot, "A"):
                            continue
                        the_name = pikepdf.Name('/' + value)
                        annot.V = the_name
                        annot.DV = the_name
                        # Could be radio button: if it is, set the appearance stream of the
                        # correct child annot
                        if (annot_kid is not None and hasattr(annot_kid, "AP")
                                and hasattr(annot_kid.AP, "N")):
                            annot.AS = the_name
                            if the_name in annot_kid.AP.N.keys():
                                annot_kid.AS = the_name
                            else:
                                for off in ["/Off", "/off"]:
                                    if off in annot_kid.AP.N.keys():
                                        annot_kid.AS = off
                        elif (hasattr(annot, "AP") and hasattr(annot.AP, "N")):
                            if the_name in annot.AP.N.keys():
                                annot.AS = the_name
                    elif field_type == "/Ch":
                        opt_list = [str(item) for item in annot.Opt]
                        if value not in opt_list:
                            opt_list.append(value)
                            annot.Opt = pikepdf.Array(opt_list)
                        the_string = pikepdf.String(value)
                        annot.V = the_string
                        annot.DV = the_string
        if len(images) == 0:
            pdf.save(pdf_file.name)
            pdf.close()
    if len(images) > 0:
        fields = {}
        for field, default, pageno, rect, field_type, export_value in the_fields:
            if str(field_type) in ('/Sig', "/'Sig'"):
                fields[field] = {'pageno': pageno, 'rect': rect}
        image_todo = []
        for field, file_info in images:
            if field not in fields:
                logmessage("field name " + str(field) + " not found in PDF file")
                continue
            temp_png = tempfile.NamedTemporaryFile(mode="wb", suffix=".png")
            args = [daconfig.get('imagemagick', 'convert'), file_info['fullpath'], "-trim", "+repage", "+profile", '*', '-density', '0', temp_png.name]
            try:
                result = subprocess.run(args, timeout=60, check=False).returncode
            except subprocess.TimeoutExpired:
                logmessage("fill_template: convert took too long")
                result = 1
            if result == 1:
                logmessage("failed to trim file: " + " ".join(args))
                continue
            im = Image.open(temp_png.name)
            width, height = im.size
            xone, yone, xtwo, ytwo = fields[field]['rect']
            dppx = width/(xtwo-xone)
            dppy = height/(ytwo-yone)
            if dppx > dppy:
                dpp = dppx
                x_offset = 0
                y_offset = int(0.5 * ((ytwo - yone) * dpp - height))
            else:
                dpp = dppy
                x_offset = int(0.5 * ((xtwo - xone) * dpp - width))
                y_offset = 0
            new_im = Image.new('RGBA', (int((xtwo - xone) * dpp), int((ytwo - yone) * dpp)), (255, 0, 0, 0))
            new_im.paste(im, (x_offset, y_offset))
            overlay_pdf_file = tempfile.NamedTemporaryFile(prefix="datemp", mode="wb", suffix=".pdf", delete=False)
            with BytesIO() as output:
                new_im.save(output, 'PNG')
                overlay_pdf_file.write(img2pdf.convert(output.getvalue()))
                overlay_pdf_file.close()
            image_todo.append({'overlay_file': overlay_pdf_file.name, 'pageno': fields[field]['pageno'], 'field': field})
        if len(image_todo) > 0:
            for item in image_todo:
                xone, yone, xtwo, ytwo = fields[item['field']]['rect']
                # logmessage("Trying to save to page " + repr(item['pageno'] - 1))
                with Pdf.open(item['overlay_file']) as overlay_file:
                    overlay_page = overlay_file.pages[0]
                    pdf.pages[item['pageno'] - 1].add_overlay(overlay_page, rect=pikepdf.Rectangle(xone, yone, xtwo, ytwo))
        pdf.save(pdf_file.name)
        pdf.close()
    if (pdfa or not editable) and len(images) > 0:
        flatten_pdf(pdf_file.name)
    if pdfa:
        pdf_to_pdfa(pdf_file.name)
    if password or owner_password:
        pdf_encrypt(pdf_file.name, password, owner_password)
    return pdf_file.name
