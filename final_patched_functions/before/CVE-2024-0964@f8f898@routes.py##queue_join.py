        async def queue_join(
            fn_index: int,
            session_hash: str,
            request: fastapi.Request,
            username: str = Depends(get_current_user),
            data: Optional[str] = None,
        ):
            blocks = app.get_blocks()
            if blocks._queue.server_app is None:
                blocks._queue.set_server_app(app)

            event = Event(session_hash, fn_index, request, username)
            if data is not None:
                input_data = json.loads(data)
                event.data = PredictBody(
                    session_hash=session_hash,
                    fn_index=fn_index,
                    data=input_data,
                    request=request,
                )

            # Continuous events are not put in the queue so that they do not
            # occupy the queue's resource as they are expected to run forever
            if blocks.dependencies[event.fn_index].get("every", 0):
                await cancel_tasks({f"{event.session_hash}_{event.fn_index}"})
                await blocks._queue.reset_iterators(event._id)
                blocks._queue.continuous_tasks.append(event)
                task = run_coro_in_background(
                    blocks._queue.process_events, [event], False
                )
                set_task_name(task, event.session_hash, event.fn_index, batch=False)
                app._asyncio_tasks.append(task)
            else:
                rank = blocks._queue.push(event)
                if rank is None:
                    event.send_message("queue_full", final=True)
                else:
                    estimation = blocks._queue.get_estimation()
                    await blocks._queue.send_estimation(event, estimation, rank)

            async def sse_stream(request: fastapi.Request):
                try:
                    last_heartbeat = time.perf_counter()
                    while True:
                        if await request.is_disconnected():
                            await blocks._queue.clean_event(event)
                        if not event.alive:
                            return

                        heartbeat_rate = 15
                        check_rate = 0.05
                        message = None
                        try:
                            message = event.message_queue.get_nowait()
                            if message is None:  # end of stream marker
                                return
                        except EmptyQueue:
                            await asyncio.sleep(check_rate)
                            if time.perf_counter() - last_heartbeat > heartbeat_rate:
                                message = {"msg": "heartbeat"}
                                # Need to reset last_heartbeat with perf_counter
                                # otherwise only a single hearbeat msg will be sent
                                # and then the stream will retry leading to infinite queue ğŸ˜¬
                                last_heartbeat = time.perf_counter()

                        if message:
                            yield f"data: {json.dumps(message)}\n\n"
                except asyncio.CancelledError as e:
                    await blocks._queue.clean_event(event)
                    raise e

            return StreamingResponse(
                sse_stream(request),
                media_type="text/event-stream",
            )
