    protected Runnable periodicExecutionRunnable = new Runnable() {

        @Override
        public void run() {
            String commandLine = (String) getConfig().get(COMMAND);

            int timeOut = 60000;
            if (((BigDecimal) getConfig().get(TIME_OUT)) != null) {
                timeOut = ((BigDecimal) getConfig().get(TIME_OUT)).intValue() * 1000;
            }

            if (commandLine != null && !commandLine.isEmpty()) {
                updateState(RUN, OnOffType.ON);

                // For some obscure reason, when using Apache Common Exec, or using a straight implementation of
                // Runtime.Exec(), on Mac OS X (Yosemite and El Capitan), there seems to be a lock race condition
                // randomly appearing (on UNIXProcess) *when* one tries to gobble up the stdout and sterr output of the
                // subprocess in separate threads. It seems to be common "wisdom" to do that in separate threads, but
                // only when keeping everything between .exec() and .waitfor() in the same thread, this lock race
                // condition seems to go away. This approach of not reading the outputs in separate threads *might* be a
                // problem for external commands that generate a lot of output, but this will be dependent on the limits
                // of the underlying operating system.

                try {
                    if (lastInput != null) {
                        commandLine = String.format(commandLine, Calendar.getInstance().getTime(), lastInput);
                    } else {
                        commandLine = String.format(commandLine, Calendar.getInstance().getTime());
                    }
                } catch (IllegalFormatException e) {
                    logger.warn(
                            "An exception occurred while formatting the command line with the current time and input values : '{}'",
                            e.getMessage());
                    updateState(RUN, OnOffType.OFF);
                    return;
                }

                String[] cmdArray;
                String[] shell;
                if (commandLine.contains(CMD_LINE_DELIMITER)) {
                    logger.debug("Splitting by '{}'", CMD_LINE_DELIMITER);
                    try {
                        cmdArray = commandLine.split(CMD_LINE_DELIMITER);
                    } catch (PatternSyntaxException e) {
                        logger.warn("An exception occurred while splitting '{}' : '{}'", commandLine, e.getMessage());
                        updateState(RUN, OnOffType.OFF);
                        updateState(OUTPUT, new StringType(e.getMessage()));
                        return;
                    }
                } else {
                    // Invoke shell with 'c' option and pass string
                    logger.debug("Passing to shell for parsing command.");
                    switch (getOperatingSystemType()) {
                        case WINDOWS:
                            shell = SHELL_WINDOWS;
                            logger.debug("OS: WINDOWS ({})", getOperatingSystemName());
                            cmdArray = createCmdArray(shell, "/c", commandLine);
                            break;

                        case LINUX:
                        case MAC:
                        case SOLARIS:
                            // assume sh is present, should all be POSIX-compliant
                            shell = SHELL_NIX;
                            logger.debug("OS: *NIX ({})", getOperatingSystemName());
                            cmdArray = createCmdArray(shell, "-c", commandLine);

                        default:
                            logger.debug("OS: Unknown ({})", getOperatingSystemName());
                            logger.warn("OS {} not supported, please manually split commands!",
                                    getOperatingSystemName());
                            updateState(RUN, OnOffType.OFF);
                            updateState(OUTPUT, new StringType("OS not supported, please manually split commands!"));
                            return;
                    }
                }

                if (cmdArray.length == 0) {
                    logger.trace("Empty command received, not executing");
                    return;
                }

                logger.trace("The command to be executed will be '{}'", Arrays.asList(cmdArray));

                Process proc = null;
                try {
                    proc = rt.exec(cmdArray);
                } catch (Exception e) {
                    logger.warn("An exception occurred while executing '{}' : '{}'", Arrays.asList(cmdArray),
                            e.getMessage());
                    updateState(RUN, OnOffType.OFF);
                    updateState(OUTPUT, new StringType(e.getMessage()));
                    return;
                }

                StringBuilder outputBuilder = new StringBuilder();
                StringBuilder errorBuilder = new StringBuilder();

                try (InputStreamReader isr = new InputStreamReader(proc.getInputStream());
                        BufferedReader br = new BufferedReader(isr)) {
                    String line = null;
                    while ((line = br.readLine()) != null) {
                        outputBuilder.append(line).append("\n");
                        logger.debug("Exec [{}]: '{}'", "OUTPUT", line);
                    }
                    isr.close();
                } catch (IOException e) {
                    logger.warn("An exception occurred while reading the stdout when executing '{}' : '{}'",
                            commandLine, e.getMessage());
                }

                try (InputStreamReader isr = new InputStreamReader(proc.getErrorStream());
                        BufferedReader br = new BufferedReader(isr)) {
                    String line = null;
                    while ((line = br.readLine()) != null) {
                        errorBuilder.append(line).append("\n");
                        logger.debug("Exec [{}]: '{}'", "ERROR", line);
                    }
                    isr.close();
                } catch (IOException e) {
                    logger.warn("An exception occurred while reading the stderr when executing '{}' : '{}'",
                            commandLine, e.getMessage());
                }

                boolean exitVal = false;
                try {
                    exitVal = proc.waitFor(timeOut, TimeUnit.MILLISECONDS);
                } catch (InterruptedException e) {
                    logger.warn("An exception occurred while waiting for the process ('{}') to finish : '{}'",
                            commandLine, e.getMessage());
                }

                if (!exitVal) {
                    logger.warn("Forcibly termininating the process ('{}') after a timeout of {} ms", commandLine,
                            timeOut);
                    proc.destroyForcibly();
                }

                updateState(RUN, OnOffType.OFF);
                updateState(EXIT, new DecimalType(proc.exitValue()));

                outputBuilder.append(errorBuilder.toString());

                outputBuilder.append(errorBuilder.toString());

                String transformedResponse = StringUtils.chomp(outputBuilder.toString());
                String transformation = (String) getConfig().get(TRANSFORM);

                if (transformation != null && transformation.length() > 0) {
                    transformedResponse = transformResponse(transformedResponse, transformation);
                }

                updateState(OUTPUT, new StringType(transformedResponse));

                DateTimeType stampType = new DateTimeType(ZonedDateTime.now());
                updateState(LAST_EXECUTION, stampType);
            }
        }

    };
