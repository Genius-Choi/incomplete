xml_read_notification(xmlTextReaderPtr reader, void *arg)
{
	struct rdr_notification_ctx *ctx = arg;
	xmlReaderTypes type;
	xmlChar const *name;
	int error;

	error = 0;
	name = xmlTextReaderConstLocalName(reader);
	type = xmlTextReaderNodeType(reader);
	switch (type) {
	case XML_READER_TYPE_ELEMENT:
		if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_DELTA)) {
			error = parse_notification_delta(reader, ctx);
		} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_SNAPSHOT)) {
			error = parse_doc_data(reader, true, true,
			    &ctx->notification->snapshot);
		} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {
			/* No need to validate session ID and serial */
			error = parse_global_data(reader,
			    &ctx->notification->global_data, NULL, 0);
			/* Init context for deltas and snapshot */
			rdr_notification_ctx_init(ctx);
		} else {
			return pr_val_err("Unexpected '%s' element", name);
		}
		break;
	case XML_READER_TYPE_END_ELEMENT:
		if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {
			error = order_notification_deltas(ctx);
			rdr_notification_ctx_cleanup(ctx);
			return error; /* Error 0 is ok */
		}
		break;
	default:
		return 0;
	}

	if (error) {
		rdr_notification_ctx_cleanup(ctx);
		return error;
	}

	return 0;
}
