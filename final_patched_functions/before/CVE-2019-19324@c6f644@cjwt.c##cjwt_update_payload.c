static int cjwt_update_payload( cjwt_t *p_cjwt, char *p_decpl )
{
    cJSON*  j_val = NULL;
   
    if( !p_cjwt || !p_decpl ) {
        return EINVAL;
    }

    //create cJSON object
    cJSON *j_payload = cJSON_Parse( ( char* )p_decpl );

    if( !j_payload ) {
        return ENOMEM;
    }

    //extract data
    cjwt_info( "Json  = %s\n", cJSON_Print( j_payload ) );
    cjwt_info( "--------------------------------------------- \n\n" );
    //iss
    j_val = cJSON_GetObjectItem( j_payload, "iss" );

    if( j_val ) {
        if( p_cjwt->iss ) {
            free( p_cjwt->iss );
            p_cjwt->iss = NULL;
        }

        p_cjwt->iss = strdup(j_val->valuestring);

        if( !p_cjwt->iss ) {
            cJSON_Delete( j_payload );
            return ENOMEM;
        }
    }

    //sub
    j_val = cJSON_GetObjectItem( j_payload, "sub" );

    if( j_val ) {
        if( p_cjwt->sub ) {
            free( p_cjwt->sub );
            p_cjwt->sub = NULL;
        }

        p_cjwt->sub = strdup(j_val->valuestring);

        if( !p_cjwt->sub ) {
            cJSON_Delete( j_payload );
            return ENOMEM;
        }
    }

    //aud
    j_val = cJSON_GetObjectItem( j_payload, "aud" );

    if( j_val ) {
        if( j_val->type == cJSON_Object ) {
            //array of strings
            cJSON*  j_tmp = NULL;
            int     cnt, i = 0;
            char    **ptr_values = NULL;
            char    *str_val = NULL;
            cnt = cJSON_GetArraySize( j_val->child );
            ptr_values = ( char** ) malloc( ( cnt ) * sizeof( char* ) );

            if( !ptr_values ) {
                cJSON_Delete( j_payload );
                return ENOMEM;
            }

            for( i = 0; i < cnt; i++ ) {
                j_tmp = cJSON_GetArrayItem( j_val->child, i );
                cjwt_info( "aud[%d] Json  = %s,type=%d,val=%s\n", i, cJSON_Print( j_tmp ), j_tmp->type, j_tmp->valuestring );

                if( j_tmp->type == cJSON_String ) {
                    str_val =  strdup(j_tmp->valuestring);

                    if( !str_val ) {
                        cJSON_Delete( j_payload );
                        i--;

                        while( i ) {
                            free( ptr_values[--i] );
                        }
                        
                        free (ptr_values);
                        return ENOMEM;
                    }

                    ptr_values[i] = str_val;
                }
            }//for
			
            p_cjwt_aud_list aud_new = malloc( sizeof( cjwt_aud_list_t ) );

            if( !aud_new ) {
                cJSON_Delete( j_payload );

                while( cnt ) {
                    free( ptr_values[--cnt] );
                }

                free (ptr_values);
                return ENOMEM;
            }

            aud_new->count = cnt;
            aud_new->names = ptr_values;
            p_cjwt->aud = aud_new;
        }
    }

    //jti
    j_val = cJSON_GetObjectItem( j_payload, "jti" );

    if( j_val ) {
        if( p_cjwt->jti ) {
            free( p_cjwt->jti );
            p_cjwt->jti = NULL;
        }

        p_cjwt->jti = strdup(j_val->valuestring);

        if( !p_cjwt->jti ) {
            cJSON_Delete( j_payload );
            return ENOMEM;
        }
    }

    //exp
    j_val = cJSON_GetObjectItem( j_payload, "exp" );

    if( j_val ) {
        cjwt_info( "exp Json  = %s,type=%d,int=%d,double=%f\n", cJSON_Print( j_val ), j_val->type, j_val->valueint, j_val->valuedouble );

        if( j_val->type == cJSON_Number ) {
            p_cjwt->exp.tv_sec = j_val->valueint;
            p_cjwt->exp.tv_nsec = 0;
        }
    }

    //nbf
    j_val = cJSON_GetObjectItem( j_payload, "nbf" );

    if( j_val ) {
        cjwt_info( "nbf Json  = %s,type=%d,int=%d,double=%f\n", cJSON_Print( j_val ), j_val->type, j_val->valueint, j_val->valuedouble );

        if( j_val->type == cJSON_Number ) {
            p_cjwt->nbf.tv_sec = j_val->valueint;
            p_cjwt->nbf.tv_nsec = 0;
        }
    }

    //iat
    j_val = cJSON_GetObjectItem( j_payload, "iat" );

    if( j_val ) {
        cjwt_info( "iat Json  = %s,type=%d,int=%d,double=%f\n", cJSON_Print( j_val ), j_val->type, j_val->valueint, j_val->valuedouble );

        if( j_val->type == cJSON_Number ) {
            p_cjwt->iat.tv_sec = j_val->valueint;
            p_cjwt->iat.tv_nsec = 0;
        }
    }

    //private_claims
    cJSON* j_new = cJSON_Duplicate( j_payload, 1 );

    if( j_new ) {
        cjwt_delete_public_claims( j_new );
        cjwt_info( "private claims count = %d\n", cJSON_GetArraySize( j_new ) );

        if( cJSON_GetArraySize( j_new ) ) {
            //cjwt_info( "private claims  = %s\n", cJSON_Print( j_new ) );
            if( p_cjwt->private_claims ) {
                cJSON_Delete( p_cjwt->private_claims );
            }

            p_cjwt->private_claims = j_new;
        } else {
            cJSON_Delete ( j_new );
        }
    }

    //destroy cJSON object
    cJSON_Delete( j_payload );
    return 0;
}
