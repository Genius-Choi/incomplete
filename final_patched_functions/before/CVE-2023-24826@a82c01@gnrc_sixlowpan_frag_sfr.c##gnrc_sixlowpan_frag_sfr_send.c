void gnrc_sixlowpan_frag_sfr_send(gnrc_pktsnip_t *pkt, void *ctx,
                                  unsigned page)
{
    gnrc_sixlowpan_frag_fb_t *fbuf = ctx;
    gnrc_netif_t *netif;
    int error_no = GNRC_NETERR_SUCCESS;
    gnrc_pktsnip_t *tx_sync = NULL;
    uint16_t res;

    assert((fbuf != NULL) && ((fbuf->pkt == pkt) || (pkt == NULL)));
    DEBUG("6lo sfr: (re-)sending fragmented datagram %u\n", fbuf->tag);
    pkt = fbuf->pkt;
    assert(pkt->type == GNRC_NETTYPE_NETIF);
    netif = gnrc_netif_hdr_get_netif(pkt->data);
    assert(netif != NULL);

    if (IS_USED(MODULE_GNRC_TX_SYNC)) {
        tx_sync = gnrc_tx_sync_split(pkt);
    }

    if (fbuf->offset == 0) {
        DEBUG("6lo sfr: sending first fragment\n");
        gnrc_sixlowpan_frag_sfr_congure_snd_setup(fbuf);
        res = _send_1st_fragment(netif, fbuf, page, &tx_sync);
        if (res == 0) {
            DEBUG("6lo sfr: error sending first fragment\n");
            /* _send_1st_fragment only returns 0 if there is a memory problem */
            error_no = ENOMEM;
            goto error;
        }
    }
    else if (!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {
        DEBUG("6lo sfr: frags_sent not within congestion window: "
              "don't send more\n");
        return;
    }
    else if (fbuf->offset < fbuf->datagram_size) {
        DEBUG("6lo sfr: sending subsequent fragment\n");
#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)
        assert(fbuf->sfr.congure);
        assert(fbuf->sfr.congure->driver);
#endif
        res = _send_nth_fragment(netif, fbuf, page, &tx_sync);
        if (res == 0) {
            DEBUG("6lo sfr: error sending subsequent fragment (offset = %u)\n",
                  fbuf->offset);
            /* _send_nth_fragment only returns 0 if there is a memory problem */
            error_no = ENOMEM;
            goto error;
        }
    }
    else {
        /* offset is greater or equal to datagram size
         * => we are done sending fragments (not an error, but we can release
         * the fragmentation buffer now) */
        goto error;
    }
    gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);
    fbuf->offset += res;

    if (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) &&
        (fbuf->offset < fbuf->datagram_size) &&
        !gnrc_sixlowpan_frag_fb_send(fbuf)) {
        /* the queue of the 6LoWPAN thread is full */
        error_no = ENOMEM;
        /* go back offset to not send abort on first fragment */
        fbuf->offset -= res;
        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_discard(fbuf);
        goto error;
    }
    /* check if last fragment sent requested an ACK */
    _frag_desc_t *frag_desc = (_frag_desc_t *)clist_rpeek(&fbuf->sfr.window);
    DEBUG("6lo sfr: last sent fragment (tag: %u, X: %i, seq: %u, "
          "frag_size: %u, offset: %u)\n",
          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),
          _frag_seq(frag_desc), _frag_size(frag_desc),
          frag_desc->offset);
    if (_frag_ack_req(frag_desc)) {
        /* initialize _arq_timer if not yet done */
        if (_arq_timer.callback == NULL) {
            evtimer_init_msg(&_arq_timer);
        }
        _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);
    }

    if (IS_USED(MODULE_GNRC_TX_SYNC) && tx_sync) {
        /* re-attach tx_sync to allow releasing it at end
         * of transmission, or transmission failure */
        gnrc_pkt_append(pkt, tx_sync);
    }
    thread_yield();
    return;
error:
    /* don't send abort for first fragment, the network does not know about
     * the datagram */
    if ((fbuf->offset > 0) &&
        _send_abort_frag(fbuf->pkt, fbuf, true, 0)) {
        /* wait for ACK before fbuf is deleted */
        _sched_abort_timeout(fbuf);
    }
    else {
        _clean_up_fbuf(fbuf, error_no);
    }
    if (IS_USED(MODULE_GNRC_TX_SYNC) && tx_sync) {
        gnrc_pktbuf_release(tx_sync);
    }
}
