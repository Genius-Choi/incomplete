void nsexec(void)
{
	int pipenum;
	jmp_buf env;
	int syncpipe[2];
	struct nlconfig_t config = {0};

	/*
	 * If we don't have an init pipe, just return to the go routine.
	 * We'll only get an init pipe for start or exec.
	 */
	pipenum = initpipe();
	if (pipenum == -1)
		return;

	/* Parse all of the netlink configuration. */
	nl_parse(pipenum, &config);

	/* clone(2) flags are mandatory. */
	if (config.cloneflags == -1)
		bail("missing clone_flags");

	/* Pipe so we can tell the child when we've finished setting up. */
	if (pipe(syncpipe) < 0)
		bail("failed to setup sync pipe between parent and child");

	/* Set up the jump point. */
	if (setjmp(env) == JUMP_VAL) {
		/*
		 * We're inside the child now, having jumped from the
		 * start_child() code after forking in the parent.
		 */
		uint8_t s = 0;
		int consolefd = config.consolefd;

		/* Close the writing side of pipe. */
		close(syncpipe[1]);

		/* Sync with parent. */
		if (read(syncpipe[0], &s, sizeof(s)) != sizeof(s) || s != SYNC_VAL)
			bail("failed to read sync byte from parent");

		if (setsid() < 0)
			bail("setsid failed");

		if (setuid(0) < 0)
			bail("setuid failed");

		if (setgid(0) < 0)
			bail("setgid failed");

		if (setgroups(0, NULL) < 0)
			bail("setgroups failed");

		if (consolefd != -1) {
			if (ioctl(consolefd, TIOCSCTTY, 0) < 0)
				bail("ioctl TIOCSCTTY failed");
			if (dup3(consolefd, STDIN_FILENO, 0) != STDIN_FILENO)
				bail("failed to dup stdin");
			if (dup3(consolefd, STDOUT_FILENO, 0) != STDOUT_FILENO)
				bail("failed to dup stdout");
			if (dup3(consolefd, STDERR_FILENO, 0) != STDERR_FILENO)
				bail("failed to dup stderr");
		}

		/* Free netlink data. */
		nl_free(&config);

		/* Finish executing, let the Go runtime take over. */
		return;
	}

	/* Run the parent code. */
	start_child(pipenum, &env, syncpipe, &config);

	/* Should never be reached. */
	bail("should never be reached");
}
