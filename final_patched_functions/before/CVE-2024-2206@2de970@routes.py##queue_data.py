        async def queue_data(
            request: fastapi.Request,
            session_hash: str,
        ):
            blocks = app.get_blocks()

            async def sse_stream(request: fastapi.Request):
                try:
                    last_heartbeat = time.perf_counter()
                    while True:
                        if await request.is_disconnected():
                            await blocks._queue.clean_events(session_hash=session_hash)
                            return

                        if (
                            session_hash
                            not in blocks._queue.pending_messages_per_session
                        ):
                            raise HTTPException(
                                status_code=status.HTTP_404_NOT_FOUND,
                                detail="Session not found.",
                            )

                        heartbeat_rate = 15
                        check_rate = 0.05
                        message = None
                        try:
                            messages = blocks._queue.pending_messages_per_session[
                                session_hash
                            ]
                            message = messages.get_nowait()
                        except EmptyQueue:
                            await asyncio.sleep(check_rate)
                            if time.perf_counter() - last_heartbeat > heartbeat_rate:
                                # Fix this
                                message = {
                                    "msg": ServerMessage.heartbeat,
                                }
                                # Need to reset last_heartbeat with perf_counter
                                # otherwise only a single hearbeat msg will be sent
                                # and then the stream will retry leading to infinite queue ðŸ˜¬
                                last_heartbeat = time.perf_counter()

                        if blocks._queue.stopped:
                            message = {
                                "msg": "unexpected_error",
                                "message": "Server stopped unexpectedly.",
                                "success": False,
                            }
                        if message:
                            yield f"data: {json.dumps(message)}\n\n"
                            if message["msg"] == ServerMessage.process_completed:
                                blocks._queue.pending_event_ids_session[
                                    session_hash
                                ].remove(message["event_id"])
                                if message["msg"] == ServerMessage.server_stopped or (
                                    message["msg"] == ServerMessage.process_completed
                                    and (
                                        len(
                                            blocks._queue.pending_event_ids_session[
                                                session_hash
                                            ]
                                        )
                                        == 0
                                    )
                                ):
                                    return
                except BaseException as e:
                    message = {
                        "msg": "unexpected_error",
                        "success": False,
                        "message": str(e),
                    }
                    yield f"data: {json.dumps(message)}\n\n"
                    if isinstance(e, asyncio.CancelledError):
                        del blocks._queue.pending_messages_per_session[session_hash]
                        await blocks._queue.clean_events(session_hash=session_hash)
                    raise e

            return StreamingResponse(
                sse_stream(request),
                media_type="text/event-stream",
            )
