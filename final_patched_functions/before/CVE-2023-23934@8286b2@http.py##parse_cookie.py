def parse_cookie(
    cookie: t.Union[bytes, str, None] = "",
    charset: str = "utf-8",
    errors: str = "replace",
    cls: t.Optional[t.Type["ds.MultiDict"]] = None,
) -> "ds.MultiDict[str, str]":
    """Parse a cookie from a string.

    The same key can be provided multiple times, the values are stored
    in-order. The default :class:`MultiDict` will have the first value
    first, and all values can be retrieved with
    :meth:`MultiDict.getlist`.

    :param cookie: The cookie header as a string.
    :param charset: The charset for the cookie values.
    :param errors: The error behavior for the charset decoding.
    :param cls: A dict-like class to store the parsed cookies in.
        Defaults to :class:`MultiDict`.

    .. versionadded:: 2.2
    """
    # PEP 3333 sends headers through the environ as latin1 decoded
    # strings. Encode strings back to bytes for parsing.
    if isinstance(cookie, str):
        cookie = cookie.encode("latin1", "replace")

    if cls is None:
        cls = ds.MultiDict

    def _parse_pairs() -> t.Iterator[t.Tuple[str, str]]:
        for key, val in _cookie_parse_impl(cookie):  # type: ignore
            key_str = _to_str(key, charset, errors, allow_none_charset=True)

            if not key_str:
                continue

            val_str = _to_str(val, charset, errors, allow_none_charset=True)
            yield key_str, val_str

    return cls(_parse_pairs())
