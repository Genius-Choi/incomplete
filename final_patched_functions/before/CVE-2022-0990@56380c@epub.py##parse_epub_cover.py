def parse_epub_cover(ns, tree, epub_zip, cover_path, tmp_file_path):
    cover_section = tree.xpath("/pkg:package/pkg:manifest/pkg:item[@id='cover-image']/@href", namespaces=ns)
    cover_file = None
    if len(cover_section) > 0:
        cover_file = _extract_cover(epub_zip, cover_section[0], cover_path, tmp_file_path)
    else:
        meta_cover = tree.xpath("/pkg:package/pkg:metadata/pkg:meta[@name='cover']/@content", namespaces=ns)
        if len(meta_cover) > 0:
            cover_section = tree.xpath(
                "/pkg:package/pkg:manifest/pkg:item[@id='"+meta_cover[0]+"']/@href", namespaces=ns)
            if not cover_section:
                cover_section = tree.xpath(
                    "/pkg:package/pkg:manifest/pkg:item[@properties='" + meta_cover[0] + "']/@href", namespaces=ns)
        else:
            cover_section = tree.xpath("/pkg:package/pkg:guide/pkg:reference/@href", namespaces=ns)
        for cs in cover_section:
            filetype = cs.rsplit('.', 1)[-1]
            if filetype == "xhtml" or filetype == "html":  # if cover is (x)html format
                markup = epub_zip.read(os.path.join(cover_path, cs))
                markup_tree = etree.fromstring(markup)
                # no matter xhtml or html with no namespace
                img_src = markup_tree.xpath("//*[local-name() = 'img']/@src")
                # Alternative image source
                if not len(img_src):
                    img_src = markup_tree.xpath("//attribute::*[contains(local-name(), 'href')]")
                if len(img_src):
                    # img_src maybe start with "../"" so fullpath join then relpath to cwd
                    filename = os.path.relpath(os.path.join(os.path.dirname(os.path.join(cover_path, cover_section[0])),
                                                            img_src[0]))
                    cover_file = _extract_cover(epub_zip, filename, "", tmp_file_path)
            else:
                cover_file = _extract_cover(epub_zip, cs, cover_path, tmp_file_path)
            if cover_file:
                break
    return cover_file
