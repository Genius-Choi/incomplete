pf_remove_state(struct pf_state *st)
{
	PF_ASSERT_LOCKED();

	if (st->timeout == PFTM_UNLINKED)
		return;

	st->timeout = PFTM_UNLINKED;

	/* handle load balancing related tasks */
	pf_postprocess_addr(st);

	if (st->src.state == PF_TCPS_PROXY_DST) {
		pf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,
		    &st->key[PF_SK_WIRE]->addr[1],
		    &st->key[PF_SK_WIRE]->addr[0],
		    st->key[PF_SK_WIRE]->port[1],
		    st->key[PF_SK_WIRE]->port[0],
		    st->src.seqhi, st->src.seqlo + 1,
		    TH_RST|TH_ACK, 0, 0, 0, 1, st->tag,
		    st->key[PF_SK_WIRE]->rdomain);
	}
	if (st->key[PF_SK_STACK]->proto == IPPROTO_TCP)
		pf_set_protostate(st, PF_PEER_BOTH, TCPS_CLOSED);

	RBT_REMOVE(pf_state_tree_id, &tree_id, st);
#if NPFLOW > 0
	if (st->state_flags & PFSTATE_PFLOW)
		export_pflow(st);
#endif	/* NPFLOW > 0 */
#if NPFSYNC > 0
	pfsync_delete_state(st);
#endif	/* NPFSYNC > 0 */
	pf_src_tree_remove_state(st);
	pf_detach_state(st);
}
