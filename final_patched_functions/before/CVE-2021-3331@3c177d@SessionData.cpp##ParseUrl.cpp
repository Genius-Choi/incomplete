bool __fastcall TSessionData::ParseUrl(UnicodeString Url, TOptions * Options,
  TStoredSessionList * StoredSessions, bool & DefaultsOnly, UnicodeString * FileName,
  bool * AProtocolDefined, UnicodeString * MaskedUrl, int Flags)
{
  bool ProtocolDefined = false;
  bool PortNumberDefined = false;
  TFSProtocol AFSProtocol;
  int APortNumber;
  TFtps AFtps = ftpsNone;
  int ProtocolLen = 0;
  if (IsProtocolUrl(Url, ScpProtocol, ProtocolLen))
  {
    AFSProtocol = fsSCPonly;
    APortNumber = SshPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, SftpProtocol, ProtocolLen))
  {
    AFSProtocol = fsSFTPonly;
    APortNumber = SshPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, FtpProtocol, ProtocolLen))
  {
    AFSProtocol = fsFTP;
    Ftps = ftpsNone;
    APortNumber = FtpPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, FtpsProtocol, ProtocolLen))
  {
    AFSProtocol = fsFTP;
    AFtps = ftpsImplicit;
    APortNumber = FtpsImplicitPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, FtpesProtocol, ProtocolLen))
  {
    AFSProtocol = fsFTP;
    AFtps = ftpsExplicitTls;
    APortNumber = FtpPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, WebDAVProtocol, ProtocolLen) ||
           IsProtocolUrl(Url, HttpProtocol, ProtocolLen))
  {
    AFSProtocol = fsWebDAV;
    AFtps = ftpsNone;
    APortNumber = HTTPPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, WebDAVSProtocol, ProtocolLen) ||
           IsProtocolUrl(Url, HttpsProtocol, ProtocolLen))
  {
    AFSProtocol = fsWebDAV;
    AFtps = ftpsImplicit;
    APortNumber = HTTPSPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, S3Protocol, ProtocolLen))
  {
    AFSProtocol = fsS3;
    AFtps = ftpsImplicit;
    APortNumber = HTTPSPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }
  else if (IsProtocolUrl(Url, SshProtocol, ProtocolLen))
  {
    // For most uses, handling ssh:// the same way as sftp://
    // The only place where a difference is made is GetLoginData() in WinMain.cpp
    AFSProtocol = fsSFTPonly;
    PuttyProtocol = PuttySshProtocol;
    APortNumber = SshPortNumber;
    MoveStr(Url, MaskedUrl, ProtocolLen);
    ProtocolDefined = true;
  }

  if (ProtocolDefined && (Url.SubString(1, 2) == L"//"))
  {
    MoveStr(Url, MaskedUrl, 2);
  }

  if (AProtocolDefined != NULL)
  {
    *AProtocolDefined = ProtocolDefined;
  }

  if (!Url.IsEmpty())
  {
    UnicodeString DecodedUrl = DecodeUrlChars(Url);
    // lookup stored session even if protocol was defined
    // (this allows setting for example default username for host
    // by creating stored session named by host)
    TSessionData * Data = NULL;
    // When using to paste URL on Login dialog, we do not want to lookup the stored sites
    if ((StoredSessions != NULL) &&
        (!ProtocolDefined || FLAGSET(Flags, pufAllowStoredSiteWithProtocol)))
    {
      // this can be optimized as the list is sorted
      for (Integer Index = 0; Index < StoredSessions->CountIncludingHidden; Index++)
      {
        TSessionData * AData = (TSessionData *)StoredSessions->Items[Index];
        if (!AData->IsWorkspace)
        {
          bool Match = false;
          // Comparison optimizations as this is called many times
          // e.g. when updating jumplist
          if ((AData->Name.Length() == DecodedUrl.Length()) &&
              SameText(AData->Name, DecodedUrl))
          {
            Match = true;
          }
          else if ((AData->Name.Length() < DecodedUrl.Length()) &&
                   (DecodedUrl[AData->Name.Length() + 1] == L'/') &&
                   // StrLIComp is an equivalent of SameText
                   (StrLIComp(AData->Name.c_str(), DecodedUrl.c_str(), AData->Name.Length()) == 0))
          {
            Match = true;
          }

          if (Match)
          {
            Data = AData;
            break;
          }
        }
      }
    }

    UnicodeString ARemoteDirectory;

    if (Data != NULL)
    {
      Assign(Data);
      int P = 1;
      while (!AnsiSameText(DecodeUrlChars(Url.SubString(1, P)), Data->Name))
      {
        P++;
        DebugAssert(P <= Url.Length());
      }
      ARemoteDirectory = Url.SubString(P + 1, Url.Length() - P);

      if (Data->Hidden)
      {
        Data->Remove();
        StoredSessions->Remove(Data);
        // only modified, implicit
        StoredSessions->Save(false, false);
      }

      if (MaskedUrl != NULL)
      {
        (*MaskedUrl) += Url;
      }
    }
    else
    {
      // This happens when pasting URL on Login dialog
      if (StoredSessions != NULL)
      {
        CopyData(StoredSessions->DefaultSettings);
      }
      Name = L"";

      int PSlash = Url.Pos(L"/");
      if (PSlash == 0)
      {
        PSlash = Url.Length() + 1;
      }

      UnicodeString ConnectInfo = Url.SubString(1, PSlash - 1);

      int P = ConnectInfo.LastDelimiter(L"@");

      UnicodeString UserInfo;
      UnicodeString HostInfo;

      if (P > 0)
      {
        UserInfo = ConnectInfo.SubString(1, P - 1);
        HostInfo = ConnectInfo.SubString(P + 1, ConnectInfo.Length() - P);
      }
      else
      {
        HostInfo = ConnectInfo;
      }

      UnicodeString OrigHostInfo = HostInfo;
      if ((HostInfo.Length() >= 2) && (HostInfo[1] == L'[') && ((P = HostInfo.Pos(L"]")) > 0))
      {
        HostName = HostInfo.SubString(2, P - 2);
        HostInfo.Delete(1, P);
        if (!HostInfo.IsEmpty() && (HostInfo[1] == L':'))
        {
          HostInfo.Delete(1, 1);
        }
      }
      else
      {
        HostName = DecodeUrlChars(CutToChar(HostInfo, L':', true));
      }

      // expanded from ?: operator, as it caused strange "access violation" errors
      if (!HostInfo.IsEmpty())
      {
        PortNumber = StrToIntDef(DecodeUrlChars(HostInfo), -1);
        PortNumberDefined = true;
      }
      else if (ProtocolDefined)
      {
        PortNumber = APortNumber;
      }

      if (ProtocolDefined)
      {
        Ftps = AFtps;
      }

      UnicodeString UserInfoWithoutConnectionParams = CutToChar(UserInfo, UrlParamSeparator, false);
      UnicodeString ConnectionParams = UserInfo;
      UserInfo = UserInfoWithoutConnectionParams;

      std::unique_ptr<TStrings> RawSettings(new TStringList());

      while (!ConnectionParams.IsEmpty())
      {
        UnicodeString ConnectionParam = CutToChar(ConnectionParams, UrlParamSeparator, false);
        UnicodeString ConnectionParamName = CutToChar(ConnectionParam, UrlParamValueSeparator, false);
        if (SameText(ConnectionParamName, UrlHostKeyParamName))
        {
          HostKey = DecodeUrlChars(ConnectionParam);
          FOverrideCachedHostKey = false;
        }
        else if (StartsText(UrlRawSettingsParamNamePrefix, ConnectionParamName))
        {
          UnicodeString AName = RightStr(ConnectionParamName, ConnectionParamName.Length() - UrlRawSettingsParamNamePrefix.Length());
          AName = DecodeUrlChars(AName);
          UnicodeString Value = DecodeUrlChars(ConnectionParam);
          if (SameText(AName, L"Name"))
          {
            Name = Value;
          }
          else
          {
            RawSettings->Values[AName] = Value;
          }
        }
      }

      if (RawSettings->Count > 0) // optimization
      {
        ApplyRawSettings(RawSettings.get());
      }

      bool HasPassword = (UserInfo.Pos(L':') > 0);
      UnicodeString RawUserName = CutToChar(UserInfo, L':', false);
      UserName = DecodeUrlChars(RawUserName);

      Password = DecodeUrlChars(UserInfo);
      if (HasPassword && Password.IsEmpty())
      {
        Password = EmptyString;
      }

      UnicodeString RemoteDirectoryWithSessionParams = Url.SubString(PSlash, Url.Length() - PSlash + 1);
      ARemoteDirectory = CutToChar(RemoteDirectoryWithSessionParams, UrlParamSeparator, false);
      UnicodeString SessionParams = RemoteDirectoryWithSessionParams;

      // We should handle session params in "stored session" branch too.
      // And particularly if there's a "save" param, we should actually not try to match the
      // URL against site names
      while (!SessionParams.IsEmpty())
      {
        UnicodeString SessionParam = CutToChar(SessionParams, UrlParamSeparator, false);
        UnicodeString SessionParamName = CutToChar(SessionParam, UrlParamValueSeparator, false);
        if (SameText(SessionParamName, UrlSaveParamName))
        {
          FSaveOnly = (StrToIntDef(SessionParam, 1) != 0);
        }
      }

      if (MaskedUrl != NULL)
      {
        (*MaskedUrl) += RawUserName;
        if (HasPassword)
        {
          (*MaskedUrl) += L":" + PasswordMask;
        }
        if (!RawUserName.IsEmpty() || HasPassword)
        {
          (*MaskedUrl) += L"@";
        }
        (*MaskedUrl) += OrigHostInfo + ARemoteDirectory;
      }
    }

    if (!ARemoteDirectory.IsEmpty() && (ARemoteDirectory != L"/"))
    {
      if ((ARemoteDirectory[ARemoteDirectory.Length()] != L'/') &&
          (FileName != NULL))
      {
        *FileName = DecodeUrlChars(UnixExtractFileName(ARemoteDirectory));
        ARemoteDirectory = UnixExtractFilePath(ARemoteDirectory);
      }
      RemoteDirectory = DecodeUrlChars(ARemoteDirectory);
    }

    DefaultsOnly = false;
  }
  else
  {
    // This happens when pasting URL on Login dialog
    if (StoredSessions != NULL)
    {
      CopyData(StoredSessions->DefaultSettings);
    }

    DefaultsOnly = true;
  }

  if (ProtocolDefined)
  {
    FSProtocol = AFSProtocol;
  }

  if (Options != NULL)
  {
    // we deliberately do keep defaultonly to false, in presence of any option,
    // as the option should not make session "connectable"

    UnicodeString Value;
    if (Options->FindSwitch(SESSIONNAME_SWICH, Value))
    {
      Name = Value;
    }
    if (Options->FindSwitch(NEWPASSWORD_SWITCH, Value))
    {
      ChangePassword = true;
      NewPassword = Value;
    }
    if (Options->FindSwitch(L"privatekey", Value))
    {
      PublicKeyFile = Value;
    }
    if (Options->FindSwitch(L"clientcert", Value))
    {
      TlsCertificateFile = Value;
    }
    if (Options->FindSwitch(PassphraseOption, Value))
    {
      Passphrase = Value;
    }
    if (Options->FindSwitch(L"timeout", Value))
    {
      Timeout = StrToInt(Value);
    }
    if (Options->FindSwitch(L"hostkey", Value) ||
        Options->FindSwitch(L"certificate", Value))
    {
      HostKey = Value;
      FOverrideCachedHostKey = true;
    }
    FtpPasvMode = Options->SwitchValue(L"passive", FtpPasvMode);
    if (Options->FindSwitch(L"implicit"))
    {
      bool Enabled = Options->SwitchValue(L"implicit", true);
      Ftps = Enabled ? ftpsImplicit : ftpsNone;
      if (!PortNumberDefined && Enabled)
      {
        PortNumber = FtpsImplicitPortNumber;
      }
    }
    // BACKWARD COMPATIBILITY with 5.5.x
    if (Options->FindSwitch(L"explicitssl"))
    {
      bool Enabled = Options->SwitchValue(L"explicitssl", true);
      Ftps = Enabled ? ftpsExplicitSsl : ftpsNone;
      if (!PortNumberDefined && Enabled)
      {
        PortNumber = FtpPortNumber;
      }
    }
    if (Options->FindSwitch(L"explicit") ||
        // BACKWARD COMPATIBILITY with 5.5.x
        Options->FindSwitch(L"explicittls"))
    {
      UnicodeString SwitchName =
        Options->FindSwitch(L"explicit") ? L"explicit" : L"explicittls";
      bool Enabled = Options->SwitchValue(SwitchName, true);
      Ftps = Enabled ? ftpsExplicitTls : ftpsNone;
      if (!PortNumberDefined && Enabled)
      {
        PortNumber = FtpPortNumber;
      }
    }
    if (Options->FindSwitch(RawSettingsOption))
    {
      std::unique_ptr<TStrings> RawSettings(new TStringList());
      if (Options->FindSwitch(RawSettingsOption, RawSettings.get()))
      {
        ApplyRawSettings(RawSettings.get());
      }
    }
  }

  return true;
}
