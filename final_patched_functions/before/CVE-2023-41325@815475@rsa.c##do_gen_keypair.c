static TEE_Result do_gen_keypair(struct rsa_keypair *key, size_t kb)
{
	sss_status_t st = kStatus_SSS_Fail;
	sss_se05x_object_t k_object = { };
	uint32_t oid = 0;
	uint64_t kid = 0;
	uint8_t k[2048] = { 0 };
	uint8_t *n = NULL;
	uint8_t *e = NULL;
	size_t n_len = 0;
	size_t e_len = 0;
	size_t k_len = sizeof(k);

	if (!oefid_keylen_supported(kb)) {
		if (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))
			return TEE_ERROR_NOT_IMPLEMENTED;

		DMSG("se050: debug: RSA software fallback: KEYGEN");
		return sw_crypto_acipher_gen_rsa_key(key, kb);
	}

	st = sss_se05x_key_object_init(&k_object, se050_kstore);
	if (st != kStatus_SSS_Success)
		return TEE_ERROR_BAD_PARAMETERS;

	st = se050_get_oid(&oid);
	if (st != kStatus_SSS_Success)
		return TEE_ERROR_GENERIC;

	st = sss_se05x_key_object_allocate_handle(&k_object, oid,
						  kSSS_KeyPart_Pair,
						  oefid_cipher_type(), 0,
						  kKeyObject_Mode_Persistent);
	if (st != kStatus_SSS_Success)
		return TEE_ERROR_BAD_PARAMETERS;

	st = sss_se05x_key_store_generate_key(se050_kstore, &k_object, kb,
					      &se050_asym_policy);
	if (st != kStatus_SSS_Success)
		goto error;

	st = sss_se05x_key_store_get_key(se050_kstore, &k_object, k, &k_len,
					 &kb);
	if (st != kStatus_SSS_Success)
		goto error;

	st = sss_util_asn1_rsa_parse_public(k, k_len, &n, &n_len, &e, &e_len);
	if (st != kStatus_SSS_Success)
		goto error;

	crypto_bignum_bin2bn(n, n_len, key->n);
	crypto_bignum_bin2bn(e, e_len, key->e);
	kid = se050_generate_private_key(oid);
	crypto_bignum_bin2bn((uint8_t *)&kid, sizeof(kid), (key->d));
	crypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->p);
	crypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->q);
	crypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->qp);
	crypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->dp);
	crypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->dq);
	free(n);
	free(e);

	return TEE_SUCCESS;
error:
	sss_se05x_key_store_erase_key(se050_kstore, &k_object);
	return TEE_ERROR_BAD_PARAMETERS;
}
