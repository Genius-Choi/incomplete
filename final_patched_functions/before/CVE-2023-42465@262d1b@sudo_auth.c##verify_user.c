verify_user(const struct sudoers_context *ctx, struct passwd *pw, char *prompt,
    unsigned int validated, struct sudo_conv_callback *callback)
{
    unsigned int ntries;
    int ret, status, success = AUTH_FAILURE;
    sudo_auth *auth;
    sigset_t mask, omask;
    struct sigaction sa, saved_sigtstp;
    debug_decl(verify_user, SUDOERS_DEBUG_AUTH);

    /* Make sure we have at least one auth method. */
    if (auth_switch[0].name == NULL) {
	audit_failure(ctx, ctx->runas.argv, N_("no authentication methods"));
    	log_warningx(ctx, SLOG_SEND_MAIL,
	    N_("There are no authentication methods compiled into sudo!  "
	    "If you want to turn off authentication, use the "
	    "--disable-authentication configure option."));
	debug_return_int(-1);
    }

    /* Enable suspend during password entry. */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_DFL;
    (void) sigaction(SIGTSTP, &sa, &saved_sigtstp);

    /*
     * We treat authentication as a critical section and block
     * keyboard-generated signals such as SIGINT and SIGQUIT
     * which might otherwise interrupt a sleep(3).
     * They are temporarily unblocked by auth_getpass().
     */
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    (void) sigprocmask(SIG_BLOCK, &mask, &omask);

    for (ntries = 0; ntries < def_passwd_tries; ntries++) {
	int num_methods = 0;
	char *pass = NULL;

	/* If user attempted to interrupt password verify, quit now. */
	if (user_interrupted())
	    goto done;

	if (ntries != 0)
	    pass_warn();

	/* Do any per-method setup and unconfigure the method if needed */
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;
	    num_methods++;
	    if (auth->setup != NULL) {
		status = (auth->setup)(ctx, pw, &prompt, auth);
		if (status == AUTH_FAILURE)
		    SET(auth->flags, FLAG_DISABLED);
		else if (status == AUTH_NONINTERACTIVE)
		    goto done;
		else if (status == AUTH_ERROR || user_interrupted())
		    goto done;		/* assume error msg already printed */
	    }
	}
	if (num_methods == 0) {
	    audit_failure(ctx, ctx->runas.argv,
		N_("no authentication methods"));
	    log_warningx(ctx, SLOG_SEND_MAIL,
		N_("Unable to initialize authentication methods."));
	    debug_return_int(-1);
	}

	/* Get the password unless the auth function will do it for us */
	if (!standalone) {
	    if (IS_NONINTERACTIVE(&auth_switch[0])) {
		success = AUTH_NONINTERACTIVE;
		goto done;
	    }
	    pass = auth_getpass(prompt, SUDO_CONV_PROMPT_ECHO_OFF, callback);
	    if (pass == NULL)
		break;
	}

	/* Call authentication functions. */
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;

	    success = auth->status = (auth->verify)(ctx, pw,
		standalone ? prompt : pass, auth, callback);
	    if (success != AUTH_FAILURE)
		break;
	}
	if (pass != NULL)
	    freezero(pass, strlen(pass));

	if (success != AUTH_FAILURE)
	    goto done;
    }

done:
    /* Restore signal handlers and signal mask. */
    (void) sigaction(SIGTSTP, &saved_sigtstp, NULL);
    (void) sigprocmask(SIG_SETMASK, &omask, NULL);

    switch (success) {
	case AUTH_SUCCESS:
	    ret = true;
	    break;
	case AUTH_INTR:
	case AUTH_FAILURE:
	    if (ntries != 0)
		SET(validated, FLAG_BAD_PASSWORD);
	    log_auth_failure(ctx, validated, ntries);
	    ret = false;
	    break;
	case AUTH_NONINTERACTIVE:
	    SET(validated, FLAG_NO_USER_INPUT);
	    FALLTHROUGH;
	case AUTH_ERROR:
	default:
	    log_auth_failure(ctx, validated, 0);
	    ret = -1;
	    break;
    }

    debug_return_int(ret);
}
