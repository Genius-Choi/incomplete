int bundle_update(struct iflow *flow,
		  enum icall_conv_type conv_type,
		  bool include_audio,
		  const char *remote_sdp,
		  struct list *membl,
		  bundle_flow_update_h *flow_updateh)
{
	struct sdp_media *sdpa = NULL;
	struct sdp_media *sdpv = NULL;
	char *grpstr;
	int err = 0;
	struct le *le;
	struct sdp_session *sess;
	struct bundle bundle;
	char *sdpres = NULL;
	struct mbuf *mbb;

	sdp_dup(&sess, conv_type, remote_sdp, false);
	sdpa = find_media(sess, "audio");
	sdpv = find_media(sess, "video");
	
	bundle.mid = 0;
	bundle.mb = mbuf_alloc(128);
	mbuf_printf(bundle.mb, sdp_session_rattr(sess, "group"));

	list_flush((struct list *)sdp_session_medial(sess, true));
	
	LIST_FOREACH(membl, le) {
		struct conf_member *cm = (struct conf_member *)le->data;

		if (include_audio && sdpa)
			bundle_ssrc(BUNDLE_TYPE_AUDIO, cm, &bundle, sess, sdpa);
		if (sdpv && cm->ssrcv)
			bundle_ssrc(BUNDLE_TYPE_VIDEO, cm, &bundle, sess, sdpv);
	}

	bundle.mb->pos = 0;
	mbuf_strdup(bundle.mb, &grpstr, mbuf_get_left(bundle.mb));
	sdp_safe_session_set_lattr(sess, true, "group", grpstr);
	mem_deref(grpstr);
	mem_deref(bundle.mb);

	sdp_encode(&mbb, sess, true);
	mbuf_strdup(mbb, &sdpres, mbb->end);
	mem_deref(mbb);
		
	if (flow_updateh) {
		flow_updateh(flow, sdpres);
	}

	mem_deref(sdpres);
	mem_deref(sess);

	return err;
}
