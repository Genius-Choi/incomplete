  def test_html5_data_attributes_without_hyphenation
    assert_equal("<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\n",
      render("%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}",
        :hyphenate_data_attrs => false))

    assert_equal("<div data-one_plus_one='2'></div>\n",
      render("%div{:data => {:one_plus_one => 1+1}}",
        :hyphenate_data_attrs => false))

    assert_equal("<div data-foo='Here&#x0027;s a \"quoteful\" string.'></div>\n",
      render(%{%div{:data => {:foo => %{Here's a "quoteful" string.}}}},
        :hyphenate_data_attrs => false)) #'
  end

  def test_html5_data_attributes_with_hyphens
    assert_equal("<div data-foo-bar='blip'></div>\n",
      render("%div{:data => {:foo_bar => 'blip'}}"))
    assert_equal("<div data-baz='bang' data-foo-bar='blip'></div>\n",
      render("%div{:data => {:foo_bar => 'blip', :baz => 'bang'}}"))
  end

	def test_html5_arbitrary_hash_valued_attributes_with
    assert_equal("<div aria-foo='blip'></div>\n",
      render("%div{:aria => {:foo => 'blip'}}"))
    assert_equal("<div foo-baz='bang'></div>\n",
      render("%div{:foo => {:baz => 'bang'}}"))
	end

  def test_arbitrary_attribute_hash_merging
    assert_equal(%Q{<a aria-baz='qux' aria-foo='bar'></a>\n}, render(<<-HAML))
- h1 = {:aria => {:foo => :bar}}
- h2 = {:baz => :qux}
%a{h1, :aria => h2}
HAML
  end


  def test_html5_data_attributes_with_nested_hash
    assert_equal("<div data-a-b='c'></div>\n", render(<<-HAML))
- hash = {:a => {:b => 'c'}}
- hash[:d] = hash
%div{:data => hash}
HAML
  end

  def test_html5_data_attributes_with_nested_hash_and_without_hyphenation
    assert_equal("<div data-a_b='c'></div>\n", render(<<-HAML, :hyphenate_data_attrs => false))
- hash = {:a => {:b => 'c'}}
- hash[:d] = hash
%div{:data => hash}
HAML
  end

  def test_html5_data_attributes_with_multiple_defs
    # Should always use the more-explicit attribute
    assert_equal("<div data-foo='second'></div>\n",
      render("%div{:data => {:foo => 'first'}, 'data-foo' => 'second'}"))
    assert_equal("<div data-foo='first'></div>\n",
      render("%div{'data-foo' => 'first', :data => {:foo => 'second'}}"))
  end

  def test_html5_data_attributes_with_attr_method
    obj = Object.new
    def obj.data_hash
      {:data => {:foo => "bar", :baz => "bang"}}
    end

    def obj.data_val
      {:data => "dat"}
    end

    assert_equal("<div data-baz='bang' data-brat='wurst' data-foo='blip'></div>\n",
      render("%div{data_hash, :data => {:foo => 'blip', :brat => 'wurst'}}", scope: obj))
    assert_equal("<div data-baz='bang' data-foo='blip'></div>\n",
      render("%div{data_hash, 'data-foo' => 'blip'}", scope: obj))
    assert_equal("<div data-baz='bang' data-foo='bar' data='dat'></div>\n",
      render("%div{data_hash, :data => 'dat'}", scope: obj))
    assert_equal("<div data-brat='wurst' data-foo='blip' data='dat'></div>\n",
      render("%div{data_val, :data => {:foo => 'blip', :brat => 'wurst'}}", scope: obj))
  end

  def test_html5_data_attributes_with_identical_attribute_values
    assert_equal("<div data-x='50' data-y='50'></div>\n",
      render("%div{:data => {:x => 50, :y => 50}}"))
  end

  def test_xml_doc_using_html5_format_and_mime_type
    assert_equal(<<XML, render(<<HAML, { :format => :html5, :mime_type => 'text/xml' }))
<?xml version='1.0' encoding='utf-8' ?>
<root>
<element />
<hr />
</root>
XML
!!! XML
%root
  %element/
  %hr
HAML
  end

  def test_xml_doc_using_html4_format_and_mime_type
    assert_equal(<<XML, render(<<HAML, { :format => :html4, :mime_type => 'text/xml' }))
<?xml version='1.0' encoding='utf-8' ?>
<root>
<element />
<hr />
</root>
XML
!!! XML
%root
  %element/
  %hr
HAML
  end

  # New attributes

  def test_basic_new_attributes
    assert_equal("<a>bar</a>\n", render("%a() bar"))
    assert_equal("<a href='foo'>bar</a>\n", render("%a(href='foo') bar"))
    assert_equal("<a b='c' c='d' d='e'>baz</a>\n", render(%q{%a(b="c" c='d' d="e") baz}))
  end

  def test_new_attribute_ids
    assert_equal("<div id='foo_bar'></div>\n", render("#foo(id='bar')"))
    assert_equal("<div id='foo_baz_bar'></div>\n", render("#foo{:id => 'bar'}(id='baz')"))
    assert_equal("<div id='foo_baz_bar'></div>\n", render("#foo(id='baz'){:id => 'bar'}"))
    foo = User.new(42)
    assert_equal("<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\n",
      render("#foo(id='baz'){:id => 'bar'}[foo]", :locals => {:foo => foo}))
    assert_equal("<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\n",
      render("#foo(id='baz')[foo]{:id => 'bar'}", :locals => {:foo => foo}))
    assert_equal("<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\n",
      render("#foo[foo](id='baz'){:id => 'bar'}", :locals => {:foo => foo}))
    assert_equal("<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\n",
      render("#foo[foo]{:id => 'bar'}(id='baz')", :locals => {:foo => foo}))
  end

  def test_new_attribute_classes
    assert_equal("<div class='bar foo'></div>\n", render(".foo(class='bar')"))
    assert_equal("<div class='bar baz foo'></div>\n", render(".foo{:class => 'bar'}(class='baz')"))
    assert_equal("<div class='bar baz foo'></div>\n", render(".foo(class='baz'){:class => 'bar'}"))
    foo = User.new(42)
    assert_equal("<div class='bar baz foo struct_user' id='struct_user_42'></div>\n",
      render(".foo(class='baz'){:class => 'bar'}[foo]", :locals => {:foo => foo}))
    assert_equal("<div class='bar baz foo struct_user' id='struct_user_42'></div>\n",
      render(".foo[foo](class='baz'){:class => 'bar'}", :locals => {:foo => foo}))
    assert_equal("<div class='bar baz foo struct_user' id='struct_user_42'></div>\n",
      render(".foo[foo]{:class => 'bar'}(class='baz')", :locals => {:foo => foo}))
  end

  def test_dynamic_new_attributes
    assert_equal("<a href='12'>bar</a>\n", render("%a(href=foo) bar", :locals => {:foo => 12}))
    assert_equal("<a b='12' c='13' d='14'>bar</a>\n", render("%a(b=b c='13' d=d) bar", :locals => {:b => 12, :d => 14}))
  end

  def test_new_attribute_interpolation
    assert_equal("<a href='12'>bar</a>\n", render('%a(href="1#{1 + 1}") bar'))
    assert_equal("<a href='2: 2, 3: 3'>bar</a>\n", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3}))
    assert_equal(%Q{<a href='1\#{1 + 1}'>bar</a>\n}, render('%a(href="1\#{1 + 1}") bar'))
  end

  def test_truthy_new_attributes
    assert_equal("<a href='href'>bar</a>\n", render("%a(href) bar", :format => :xhtml))
    assert_equal("<a bar='baz' href>bar</a>\n", render("%a(href bar='baz') bar", :format => :html5))
    assert_equal("<a href>bar</a>\n", render("%a(href=true) bar"))
    assert_equal("<a>bar</a>\n", render("%a(href=false) bar"))
  end

  def test_new_attribute_parsing
    assert_equal("<a a2='b2'>bar</a>\n", render("%a(a2=b2) bar", :locals => {:b2 => 'b2'}))
    assert_equal(%Q{<a a='foo"bar'>bar</a>\n}, render(%q{%a(a="#{'foo"bar'}") bar})) #'
    assert_equal(%Q{<a a="foo'bar">bar</a>\n}, render(%q{%a(a="#{"foo'bar"}") bar})) #'
    assert_equal(%Q{<a a='foo"bar'>bar</a>\n}, render(%q{%a(a='foo"bar') bar}))
    assert_equal(%Q{<a a="foo'bar">bar</a>\n}, render(%q{%a(a="foo'bar") bar}))
    assert_equal("<a a:b='foo'>bar</a>\n", render("%a(a:b='foo') bar"))
    assert_equal("<a a='foo' b='bar'>bar</a>\n", render("%a(a = 'foo' b = 'bar') bar"))
    assert_equal("<a a='foo' b='bar'>bar</a>\n", render("%a(a = foo b = bar) bar", :locals => {:foo => 'foo', :bar => 'bar'}))
    assert_equal("<a a='foo'>(b='bar')</a>\n", render("%a(a='foo')(b='bar')"))
    assert_equal("<a a='foo)bar'>baz</a>\n", render("%a(a='foo)bar') baz"))
    assert_equal("<a a='foo'>baz</a>\n", render("%a( a = 'foo' ) baz"))
  end

  def test_new_attribute_escaping
    assert_equal(%Q{<a a='foo " bar'>bar</a>\n}, render(%q{%a(a="foo \" bar") bar}))
    assert_equal(%Q{<a a='foo \\" bar'>bar</a>\n}, render(%q{%a(a="foo \\\\\" bar") bar}))

    assert_equal(%Q{<a a="foo ' bar">bar</a>\n}, render(%q{%a(a='foo \' bar') bar}))
    assert_equal(%Q{<a a="foo \\' bar">bar</a>\n}, render(%q{%a(a='foo \\\\\' bar') bar}))

    assert_equal(%Q{<a a='foo \\ bar'>bar</a>\n}, render(%q{%a(a="foo \\\\ bar") bar}))
    assert_equal(%Q{<a a='foo \#{1 + 1} bar'>bar</a>\n}, render(%q{%a(a="foo \#{1 + 1} bar") bar}))
  end

  def test_multiline_new_attribute
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a(a='b'\n  c='d') bar"))
    assert_equal("<a a='b' b='c' c='d' d='e' e='f' f='j'>bar</a>\n",
      render("%a(a='b' b='c'\n  c='d' d=e\n  e='f' f='j') bar", :locals => {:e => 'e'}))
  end

  def test_new_and_old_attributes
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a(a='b'){:c => 'd'} bar"))
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a{:c => 'd'}(a='b') bar"))
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a(c='d'){:a => 'b'} bar"))
    assert_equal("<a a='b' c='d'>bar</a>\n", render("%a{:a => 'b'}(c='d') bar"))

    # Old-style always takes precedence over new-style,
    # because theoretically old-style could have arbitrary end-of-method-call syntax.
    assert_equal("<a a='b'>bar</a>\n", render("%a{:a => 'b'}(a='d') bar"))
    assert_equal("<a a='b'>bar</a>\n", render("%a(a='d'){:a => 'b'} bar"))

    assert_equal("<a a='b' b='c' c='d' d='e'>bar</a>\n",
      render("%a{:a => 'b',\n:b => 'c'}(c='d'\nd='e') bar"))

    locals = {:b => 'b', :d => 'd'}
    assert_equal("<p a='b' c='d'></p>\n", render("%p{:a => b}(c=d)", :locals => locals))
    assert_equal("<p a='b' c='d'></p>\n", render("%p(a=b){:c => d}", :locals => locals))

    assert_equal("<p id='b_d'></p>\n<p id='b_d'></p>\n", render("%p(id=b){id:d}\n%p(id=b){id:d}", locals: locals))
  end

  # Ruby Multiline

  def test_silent_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
bar, baz, bang
<p>foo</p>
HTML
- foo = ["bar",
         "baz",
         "bang"]
= foo.join(", ")
%p foo
HAML
  end

  def test_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
bar, baz, bang
<p>foo</p>
<p>bar</p>
HTML
= ["bar",
   "baz",
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_with_punctuated_methods_is_continuation
    assert_equal(<<HTML, render(<<HAML))
bar, , true, bang
<p>foo</p>
<p>bar</p>
HTML
= ["bar",
   "  ".strip!,
   "".empty?,
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_character_literals_are_not_continuation
    html = ",\n,\n<p>foo</p>\n"
    assert_equal(html, render(<<HAML))
= ?,
= ?\,
%p foo
HAML
  end

  def test_escaped_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
bar&lt;, baz, bang
<p>foo</p>
<p>bar</p>
HTML
&= ["bar<",
    "baz",
    "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_unescaped_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML, :escape_html => true))
bar<, baz, bang
<p>foo</p>
<p>bar</p>
HTML
!= ["bar<",
    "baz",
    "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_flattened_loud_ruby_multiline
    assert_equal(<<HTML, render(<<HAML))
<pre>bar&#x000A;baz&#x000A;bang</pre>
<p>foo</p>
<p>bar</p>
HTML
~ "<pre>" + ["bar",
             "baz",
             "bang"].join("\\n") + "</pre>"
%p foo
%p bar
HAML
  end

  def test_loud_ruby_multiline_with_block
    assert_equal(<<HTML, render(<<HAML))
#{%w[far faz fang]}<p>foo</p>
<p>bar</p>
HTML
= ["bar",
   "baz",
   "bang"].map do |str|
  - str.gsub("ba",
             "fa")
%p foo
%p bar
HAML
  end

  def test_silent_ruby_multiline_with_block
    assert_equal(<<HTML, render(<<HAML))
far
faz
fang
<p>foo</p>
<p>bar</p>
HTML
- ["bar",
   "baz",
   "bang"].map do |str|
  = str.gsub("ba",
             "fa")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_in_tag
    assert_equal(<<HTML, render(<<HAML))
<p>foo, bar, baz</p>
<p>foo</p>
<p>bar</p>
HTML
%p= ["foo",
     "bar",
     "baz"].join(", ")
%p foo
%p bar
HAML
  end

  def test_escaped_ruby_multiline_in_tag
    assert_equal(<<HTML, render(<<HAML))
<p>foo&lt;, bar, baz</p>
<p>foo</p>
<p>bar</p>
HTML
%p&= ["foo<",
      "bar",
      "baz"].join(", ")
%p foo
%p bar
HAML
  end

  def test_unescaped_ruby_multiline_in_tag
    assert_equal(<<HTML, render(<<HAML, :escape_html => true))
<p>foo<, bar, baz</p>
<p>foo</p>
<p>bar</p>
HTML
%p!= ["foo<",
      "bar",
      "baz"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_with_normal_multiline
    assert_equal(<<HTML, render(<<HAML))
foobarbar, baz, bang
<p>foo</p>
<p>bar</p>
HTML
= "foo" + |
  "bar" + |
  ["bar", |
   "baz",
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  def test_ruby_multiline_after_filter
    assert_equal(<<HTML, render(<<HAML))
foo
bar
bar, baz, bang
<p>foo</p>
<p>bar</p>
HTML
:plain
  foo
  bar
= ["bar",
   "baz",
   "bang"].join(", ")
%p foo
%p bar
HAML
  end

  # Encodings

  def test_utf_8_bom
    assert_equal <<HTML, render(<<HAML)
<div class='foo'>
<p>baz</p>
</div>
HTML
\xEF\xBB\xBF.foo
  %p baz
HAML
  end

  def test_default_encoding
    assert_equal(Encoding.find("utf-8"), render(<<HAML.encode("us-ascii")).encoding)
%p bar
%p foo
HAML
  end

  def test_fake_ascii_encoding
    assert_encoded_equal(<<HTML.force_encoding("ascii-8bit"), render(<<HAML, :encoding => "ascii-8bit"))
<p>bâr</p>
<p>föö</p>
HTML
%p bâr
%p föö
HAML
  end

  def test_convert_template_render_proc
    assert_converts_template_properly {|e| e.render_proc.call}
  end

  def test_convert_template_render
    assert_converts_template_properly {|e| e.render}
  end

  def test_convert_template_def_method
    assert_converts_template_properly do |e|
      o = Object.new
      e.def_method(o, :render)
      o.render
    end
  end

  def test_encoding_error
    render("foo\nbar\nb\xFEaz".force_encoding("utf-8"))
    assert(false, "Expected exception")
  rescue Haml::Error => e
    assert_equal(3, e.line)
    assert_match(/Invalid .* character/, e.message)
  end

  def test_ascii_incompatible_encoding_error
    template = "foo\nbar\nb_z".encode("utf-16le")
    template[9] = "\xFE".force_encoding("utf-16le")
    render(template)
    assert(false, "Expected exception")
  rescue Haml::Error => e
    assert_equal(3, e.line)
    assert_match(/Invalid .* character/, e.message)
  end

  def test_same_coding_comment_as_encoding
    assert_renders_encoded(<<HTML, <<HAML)
<p>bâr</p>
<p>föö</p>
HTML
-# coding: utf-8
%p bâr
%p föö
HAML
  end

  def test_coding_comments
    assert_valid_encoding_comment("-# coding: ibm866")
    assert_valid_encoding_comment("-# CodINg: IbM866")
    assert_valid_encoding_comment("-#coding:ibm866")
    assert_valid_encoding_comment("-# CodINg= ibm866")
    assert_valid_encoding_comment("-# foo BAR FAOJcoding: ibm866")
    assert_valid_encoding_comment("-# coding: ibm866 ASFJ (&(&#!$")
    assert_valid_encoding_comment("-# -*- coding: ibm866")
    assert_valid_encoding_comment("-# coding: ibm866 -*- coding: blah")
    assert_valid_encoding_comment("-# -*- coding: ibm866 -*-")
    assert_valid_encoding_comment("-# -*- encoding: ibm866 -*-")
    assert_valid_encoding_comment('-# -*- coding: "ibm866" -*-')
    assert_valid_encoding_comment("-#-*-coding:ibm866-*-")
    assert_valid_encoding_comment("-#-*-coding:ibm866-*-")
    assert_valid_encoding_comment("-# -*- foo: bar; coding: ibm866; baz: bang -*-")
    assert_valid_encoding_comment("-# foo bar coding: baz -*- coding: ibm866 -*-")
    assert_valid_encoding_comment("-# -*- coding: ibm866 -*- foo bar coding: baz")
  end

  def test_different_coding_than_system
    assert_renders_encoded(<<HTML.encode("IBM866"), <<HAML.encode("IBM866"))
<p>тАЬ</p>
HTML
%p тАЬ
HAML
  end

  def test_block_spacing
    begin
      assert render(<<-HAML)
- foo = ["bar", "baz", "kni"]
- foo.each do | item |
  = item
HAML
    rescue ::SyntaxError
      flunk("Should not have raised syntax error")
    end
  end

  def test_tracing
    result = render('%p{:class => "hello"}', :trace => true, :filename => 'foo').strip
    assert_equal "<p class='hello' data-trace='foo:1'></p>", result
  end

  private

  def assert_valid_encoding_comment(comment)
    assert_renders_encoded(<<HTML.encode("IBM866"), <<HAML.encode("IBM866").force_encoding("UTF-8"))
<p>ЖЛЫ</p>
<p>тАЬ</p>
HTML
#{comment}
%p ЖЛЫ
%p тАЬ
HAML
  end

  def assert_converts_template_properly
    engine = Haml::Engine.new(<<HAML.encode("iso-8859-1"), :encoding => "macRoman")
%p bâr
%p föö
HAML
    assert_encoded_equal(<<HTML.encode("macRoman"), yield(engine))
<p>bâr</p>
<p>föö</p>
HTML
  end

  def assert_renders_encoded(html, haml)
    result = render(haml)
    assert_encoded_equal html, result
  end

  def assert_encoded_equal(expected, actual)
    assert_equal expected.encoding, actual.encoding
    assert_equal expected, actual
  end
end
