static int parse_single_header(server *srv, connection *con, parse_header_state *state, data_string *ds) {
	int cmp = 0;

	/* retreive values
	 *
	 *
	 * the list of options is sorted to simplify the search
	 */

	if (0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Connection")))) {
		array *vals;
		size_t vi;

		/* split on , */

		vals = srv->split_vals;

		array_reset(vals);

		http_request_split_value(vals, ds->value);

		for (vi = 0; vi < vals->used; vi++) {
			data_string *dsv = (data_string *)vals->data[vi];

			if (0 == buffer_caseless_compare(CONST_BUF_LEN(dsv->value), CONST_STR_LEN("keep-alive"))) {
				state->keep_alive_set = HTTP_CONNECTION_KEEPALIVE;

				break;
			} else if (0 == buffer_caseless_compare(CONST_BUF_LEN(dsv->value), CONST_STR_LEN("close"))) {
				state->keep_alive_set = HTTP_CONNECTION_CLOSE;

				break;
			}
		}

	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Content-Length")))) {
		char *err;
		off_t r;

		if (state->con_length_set) {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, "s",
						"duplicate Content-Length-header -> 400");
				log_error_write(srv, __FILE__, __LINE__, "Sb",
						"request-header:\n",
						con->request.request);
			}
			goto invalid_header;
		}

		r = strtoll(ds->value->ptr, &err, 10);

		if (*err == '\0' && r >= 0) {
			state->con_length_set = 1;
			con->request.content_length = r;
		} else {
			log_error_write(srv, __FILE__, __LINE__, "sbs",
					"content-length broken:", ds->value, "-> 400");
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Content-Type")))) {
		/* if dup, only the first one will survive */
		if (!con->request.http_content_type) {
			con->request.http_content_type = ds->value->ptr;
		} else {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, "s",
						"duplicate Content-Type-header -> 400");
				log_error_write(srv, __FILE__, __LINE__, "Sb",
						"request-header:\n",
						con->request.request);
			}
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("Host")))) {
		if (state->reqline_host) {
			/* ignore all host: headers as we got the host in the request line */
			goto drop_header;
		} else if (!con->request.http_host) {
			con->request.http_host = ds->value;
		} else {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, "s",
						"duplicate Host-header -> 400");
				log_error_write(srv, __FILE__, __LINE__, "Sb",
						"request-header:\n",
						con->request.request);
			}
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("If-Modified-Since")))) {
		/* Proxies sometimes send dup headers
		 * if they are the same we ignore the second
		 * if not, we raise an error */
		if (!con->request.http_if_modified_since) {
			con->request.http_if_modified_since = ds->value->ptr;
		} else if (0 == strcasecmp(con->request.http_if_modified_since, ds->value->ptr)) {
			/* ignore it if they are the same */
			goto drop_header;
		} else {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, "s",
						"duplicate If-Modified-Since header -> 400");
				log_error_write(srv, __FILE__, __LINE__, "Sb",
						"request-header:\n",
						con->request.request);
			}
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN("If-None-Match")))) {
		/* if dup, only the first one will survive */
		if (!con->request.http_if_none_match) {
			con->request.http_if_none_match = ds->value->ptr;
		} else {
			goto drop_header;
		}
	}

	array_insert_unique(con->request.headers, (data_unset *)ds);
	return 1;

drop_header:
	ds->free((data_unset *)ds);
	return 1;

invalid_header:
	ds->free((data_unset *)ds);
	return 0;
}
