  void Compute(OpKernelContext* context) override {
    Tensor encoded_t = context->input(0);
    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();

    // Check that the encoded TypeSpec is compatible with the expected TypeSpec.
    // For now, we just check that the class matches.
    //
    // TODO(b/173744905): Update this to do a generic compatibility check. This
    // would require replacing the current design, where Python subclasses of
    // TypeSpec can override is_compatible, with a design where compatibility
    // can be deterministically determined from the metadata.
    auto expected_class = metadata_.type_spec_proto().type_spec_class();
    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();
    OP_REQUIRES(
        context, expected_class == actual_class,
        errors::InvalidArgument(
            "Expected a ", TypeSpecProto::TypeSpecClass_Name(expected_class),
            " (based on `type_spec`), but `encoded` contains a ",
            TypeSpecProto::TypeSpecClass_Name(actual_class)));

    // Extract the component tensors.
    OpOutputList components;
    OP_REQUIRES_OK(context, context->output_list("components", &components));
    int num_components = encoded->flat_components().size();

    OP_REQUIRES(context, component_dtypes_.size() == num_components,
                errors::InvalidArgument("Encoded value has ", num_components,
                                        " tensor components; expected ",
                                        component_dtypes_.size(),
                                        " components based on type_spec"));

    for (int i = 0; i < component_dtypes_.size(); i++) {
      const Tensor& component = encoded->flat_components()[i];
      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),
                  errors::InvalidArgument("Tensor component ", i, " had dtype ",
                                          DataType_Name(component.dtype()),
                                          "; expected dtype ",
                                          DataType_Name(component_dtypes_[i])));
      components.set(i, component);
    }
  }
