createFileDirectoryResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, int maxPduSize, char* directoryName, char* continueAfterFileName)
{
    int maxSize = maxPduSize - 3; /* reserve space for moreFollows */
    uint8_t* buffer = response->buffer;

    bool moreFollows = false;

    int tempStartPos = 30; /* estimated header part with safety margin */
    int tempCurPos = tempStartPos;
    int tempEncoded = 0;

    if (continueAfterFileName != NULL) {
        if (strlen(continueAfterFileName) == 0)
            continueAfterFileName = NULL;
    }

    tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize, directoryName, &continueAfterFileName, &moreFollows);

	if (tempCurPos < 0) {

       if (DEBUG_MMS_SERVER)
            printf("MMS_SERVER: Error opening directory!\n");

       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);

       return;
    }

    tempEncoded = tempCurPos - tempStartPos;

    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize((uint32_t) invokeId) + 2;

    uint32_t listOfDirectoryEntrySeqSize = tempEncoded;

    uint32_t listOfDirectoryEntrySize = 1 + BerEncoder_determineLengthSize(tempEncoded) + tempEncoded;

    uint32_t fileDirectoryResponseSize = 1 + BerEncoder_determineLengthSize(listOfDirectoryEntrySize)
            + listOfDirectoryEntrySize;

    if (moreFollows)
        fileDirectoryResponseSize += 3; /* for moreFollows */

    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileDirectoryResponseSize)
            + fileDirectoryResponseSize;

    int bufPos = 0;

    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);

    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);
    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);

    buffer[bufPos++] = 0xbf;
    bufPos = BerEncoder_encodeTL(0x4d, fileDirectoryResponseSize, buffer, bufPos);
    bufPos = BerEncoder_encodeTL(0xa0, listOfDirectoryEntrySize, buffer, bufPos);

    bufPos = BerEncoder_encodeTL(0x30, listOfDirectoryEntrySeqSize, buffer, bufPos); /* SEQUENCE OF (DirectoryEntry) */

    /* memmove is required instead of memcpy since memory areas overlap */
    memmove(buffer + bufPos, buffer + tempStartPos, tempEncoded);

    bufPos += tempEncoded;

    if (moreFollows)
        bufPos = BerEncoder_encodeBoolean(0x81, moreFollows, buffer, bufPos);

    response->size = bufPos;
}
