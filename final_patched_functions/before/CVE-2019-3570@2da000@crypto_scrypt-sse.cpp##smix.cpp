smix(uint8_t * B, size_t r, uint64_t N, void * V, void * XY)
{
  __m128i * X = (__m128i *) XY;
  __m128i * Y = (__m128i *) ((uintptr_t)(XY) + 128 * r);
  __m128i * Z = (__m128i *) ((uintptr_t)(XY) + 256 * r);
  uint32_t * X32 = (uint32_t *)X;
  uint64_t i, j;
  size_t k;

  /* 1: X <-- B */
  for (k = 0; k < 2 * r; k++) {
    for (i = 0; i < 16; i++) {
      X32[k * 16 + i] = folly::Endian::little32(
                          *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]));
    }
  }

  /* 2: for i = 0 to N - 1 do */
  for (i = 0; i < N; i += 2) {
    /* 3: V_i <-- X */
    blkcpy((void *)((uintptr_t)(V) + i * 128 * r), X, 128 * r);

    /* 4: X <-- H(X) */
    blockmix_salsa8(X, Y, Z, r);

    /* 3: V_i <-- X */
    blkcpy((void *)((uintptr_t)(V) + (i + 1) * 128 * r),
        Y, 128 * r);

    /* 4: X <-- H(X) */
    blockmix_salsa8(Y, X, Z, r);
  }

  /* 6: for i = 0 to N - 1 do */
  for (i = 0; i < N; i += 2) {
    /* 7: j <-- Integerify(X) mod N */
    j = integerify(X, r) & (N - 1);

    /* 8: X <-- H(X \xor V_j) */
    blkxor(X, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);
    blockmix_salsa8(X, Y, Z, r);

    /* 7: j <-- Integerify(X) mod N */
    j = integerify(Y, r) & (N - 1);

    /* 8: X <-- H(X \xor V_j) */
    blkxor(Y, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);
    blockmix_salsa8(Y, X, Z, r);
  }

  /* 10: B' <-- X */
  for (k = 0; k < 2 * r; k++) {
    for (i = 0; i < 16; i++) {
      *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]) =
          folly::Endian::little32(X32[k * 16 + i]);
    }
  }
}
