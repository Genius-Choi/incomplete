bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)
{
    // calculate received certificate fingerprint
    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;
    try {
        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);
        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,
                                                             barrier::FingerprintType::SHA1);
        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,
                                                               barrier::FingerprintType::SHA256);
    } catch (const std::exception& e) {
        LOG((CLOG_ERR "%s", e.what()));
        return false;
    }

    // note: the GUI parses the following two lines of logs, don't change unnecessarily
    LOG((CLOG_NOTE "server fingerprint (SHA1): %s (SHA256): %s",
         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),
         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));

    // Provide debug hint as to what file is being used to verify fingerprint trust
    LOG((CLOG_NOTE "fingerprint_db_path: %s", fingerprint_db_path.u8string().c_str()));

    barrier::FingerprintDatabase db;
    db.read(fingerprint_db_path);

    if (!db.fingerprints().empty()) {
        LOG((CLOG_NOTE "Read %d fingerprints from: %s", db.fingerprints().size(),
             fingerprint_db_path.u8string().c_str()));
    } else {
        LOG((CLOG_NOTE "Could not read fingerprints from: %s",
             fingerprint_db_path.u8string().c_str()));
    }

    if (db.is_trusted(fingerprint_sha256)) {
        LOG((CLOG_NOTE "Fingerprint matches trusted fingerprint"));
        return true;
    } else {
        LOG((CLOG_NOTE "Fingerprint does not match trusted fingerprint"));
        return false;
    }
}
