    def render_in(view_context, &block)
      self.class.compile(raise_errors: true)

      @view_context = view_context
      self.__vc_original_view_context ||= view_context

      @output_buffer = ActionView::OutputBuffer.new

      @lookup_context ||= view_context.lookup_context

      # required for path helpers in older Rails versions
      @view_renderer ||= view_context.view_renderer

      # For content_for
      @view_flow ||= view_context.view_flow

      # For i18n
      @virtual_path ||= virtual_path

      # For template variants (+phone, +desktop, etc.)
      @__vc_variant ||= @lookup_context.variants.first

      # For caching, such as #cache_if
      @current_template = nil unless defined?(@current_template)
      old_current_template = @current_template
      @current_template = self

      if block && defined?(@__vc_content_set_by_with_content)
        raise ArgumentError, "It looks like a block was provided after calling `with_content` on #{self.class.name}, " \
          "which means that ViewComponent doesn't know which content to use.\n\n" \
          "To fix this issue, use either `with_content` or a block."
      end

      @__vc_content_evaluated = false
      @__vc_render_in_block = block

      before_render

      if render?
        render_template_for(@__vc_variant).to_s + output_postamble
      else
        ""
      end
    ensure
      @current_template = old_current_template
    end
