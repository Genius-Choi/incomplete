def bootstrap_tls(
    config,
    init_system,
    dns_name,
    fs_id,
    mountpoint,
    options,
    state_file_dir=STATE_FILE_DIR,
    fallback_ip_address=None,
):
    tls_port_sock = choose_tls_port_and_get_bind_sock(config, options)
    tls_port = get_tls_port_from_sock(tls_port_sock)

    try:
        # override the tlsport option so that we can later override the port the NFS client uses to connect to stunnel.
        # if the user has specified tlsport=X at the command line this will just re-set tlsport to X.
        options["tlsport"] = tls_port

        use_iam = "iam" in options
        ap_id = options.get("accesspoint")
        cert_details = {}
        security_credentials = None
        client_info = get_client_info(config)
        region = get_target_region(config)

        if use_iam:
            aws_creds_uri = options.get("awscredsuri")
            if aws_creds_uri:
                kwargs = {"aws_creds_uri": aws_creds_uri}
            else:
                kwargs = {"awsprofile": get_aws_profile(options, use_iam)}

            security_credentials, credentials_source = get_aws_security_credentials(
                config, use_iam, region, **kwargs
            )

            if credentials_source:
                cert_details["awsCredentialsMethod"] = credentials_source

        if ap_id:
            cert_details["accessPoint"] = ap_id

        # additional symbol appended to avoid naming collisions
        cert_details["mountStateDir"] = (
            get_mount_specific_filename(fs_id, mountpoint, tls_port) + "+"
        )
        # common name for certificate signing request is max 64 characters
        cert_details["commonName"] = socket.gethostname()[0:64]
        region = get_target_region(config)
        cert_details["region"] = region
        cert_details["certificateCreationTime"] = create_certificate(
            config,
            cert_details["mountStateDir"],
            cert_details["commonName"],
            cert_details["region"],
            fs_id,
            security_credentials,
            ap_id,
            client_info,
            base_path=state_file_dir,
        )
        cert_details["certificate"] = os.path.join(
            state_file_dir, cert_details["mountStateDir"], "certificate.pem"
        )
        cert_details["privateKey"] = get_private_key_path()
        cert_details["fsId"] = fs_id

        start_watchdog(init_system)

        if not os.path.exists(state_file_dir):
            create_required_directory(config, state_file_dir)

        verify_level = int(options.get("verify", DEFAULT_STUNNEL_VERIFY_LEVEL))
        ocsp_enabled = is_ocsp_enabled(config, options)

        stunnel_config_file = write_stunnel_config_file(
            config,
            state_file_dir,
            fs_id,
            mountpoint,
            tls_port,
            dns_name,
            verify_level,
            ocsp_enabled,
            options,
            region,
            cert_details=cert_details,
            fallback_ip_address=fallback_ip_address,
        )
        tunnel_args = [_stunnel_bin(), stunnel_config_file]
        if "netns" in options:
            tunnel_args = ["nsenter", "--net=" + options["netns"]] + tunnel_args
    finally:
        # Always close the socket we created when choosing TLS port only until now to
        # 1. avoid concurrent TLS mount port collision 2. enable stunnel process to bind the port
        logging.debug("Closing socket used to choose TLS port %s.", tls_port)
        tls_port_sock.close()

    # launch the tunnel in a process group so if it has any child processes, they can be killed easily by the mount watchdog
    logging.info('Starting TLS tunnel: "%s"', " ".join(tunnel_args))
    tunnel_proc = subprocess.Popen(
        tunnel_args,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
        preexec_fn=os.setsid,
        close_fds=True,
    )
    logging.info("Started TLS tunnel, pid: %d", tunnel_proc.pid)

    temp_tls_state_file = write_tls_tunnel_state_file(
        fs_id,
        mountpoint,
        tls_port,
        tunnel_proc.pid,
        tunnel_args,
        [stunnel_config_file],
        state_file_dir,
        cert_details=cert_details,
    )

    if "netns" not in options:
        test_tlsport(options["tlsport"])
    else:
        with NetNS(nspath=options["netns"]):
            test_tlsport(options["tlsport"])

    try:
        yield tunnel_proc
    finally:
        os.rename(
            os.path.join(state_file_dir, temp_tls_state_file),
            os.path.join(state_file_dir, temp_tls_state_file[1:]),
        )
