x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,
    enum rpki_policy policy, enum cert_type type)
{
	struct metadata_node *meta;
	struct repo_level_node *repo, *head_repo;
	struct defer_node *defer_separator;
	unsigned int work_repo_level;
	int ok;
	int error;

	repo = malloc(sizeof(struct repo_level_node));
	if (repo == NULL)
		return pr_enomem();

	repo->level = 0;
	work_repo_level = working_repo_peek_level();
	head_repo = SLIST_FIRST(&stack->levels);
	if (head_repo != NULL && work_repo_level > head_repo->level)
		repo->level = work_repo_level;

	SLIST_INSERT_HEAD(&stack->levels, repo, next);

	meta = malloc(sizeof(struct metadata_node));
	if (meta == NULL) {
		error = pr_enomem();
		goto end3;
	}

	meta->uri = uri;
	uri_refget(uri);
	serial_numbers_init(&meta->serials);
	subjects_init(&meta->subjects);

	meta->resources = resources_create(false);
	if (meta->resources == NULL) {
		error = pr_enomem();
		goto end4;
	}
	resources_set_policy(meta->resources, policy);
	error = certificate_get_resources(x509, meta->resources, type);
	if (error)
		goto end5;

	/*
	 * rfc8630#section-2.3
	 * "The INR extension(s) of this TA MUST contain a non-empty set of
	 * number resources."
	 * The "It MUST NOT use the "inherit" form of the INR extension(s)"
	 * part is already handled in certificate_get_resources().
	 */
	if (type == TA && resources_empty(meta->resources)) {
		error = pr_val_err("Trust Anchor certificate does not define any number resources.");
		goto end5;
	}

	defer_separator = malloc(sizeof(struct defer_node));
	if (defer_separator == NULL) {
		error = pr_enomem();
		goto end5;
	}
	defer_separator->type = DNT_SEPARATOR;

	ok = sk_X509_push(stack->x509s, x509);
	if (ok <= 0) {
		error = val_crypto_err(
		    "Could not add certificate to trusted stack: %d", ok);
		goto end5;
	}

	SLIST_INSERT_HEAD(&stack->defers, defer_separator, next);
	SLIST_INSERT_HEAD(&stack->metas, meta, next);

	return 0;

end5:	resources_destroy(meta->resources);
end4:	subjects_cleanup(&meta->subjects, subject_cleanup);
	serial_numbers_cleanup(&meta->serials, serial_cleanup);
	uri_refput(meta->uri);
	free(meta);
end3:	SLIST_REMOVE_HEAD(&stack->levels, next);
	free(repo);
	return error;
}
