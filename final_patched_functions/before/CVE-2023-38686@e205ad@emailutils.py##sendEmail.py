def sendEmail(
    sydent: "Sydent",
    templateFile: str,
    mailTo: str,
    substitutions: Dict[str, str],
    log_send_errors: bool = True,
) -> None:
    """
    Sends an email with the given parameters.

    :param sydent: The Sydent instance to use when building the configuration to send the
        email with.
    :param templateFile: The filename of the template to use when building the body of the
        email.
    :param mailTo: The email address to send the email to.
    :param substitutions: The substitutions to use with the template.
    :param log_send_errors: Whether to log errors happening when sending an email.
    """
    mailFrom = sydent.config.email.sender
    myHostname = sydent.config.email.host_name

    midRandom = "".join([random.choice(string.ascii_letters) for _ in range(16)])
    messageid = "<%d%s@%s>" % (time_msec(), midRandom, myHostname)

    substitutions.update(
        {
            "messageid": messageid,
            "date": email.utils.formatdate(localtime=False),
            "to": mailTo,
            "from": mailFrom,
        }
    )

    # use jinja for rendering if jinja templates are present
    if templateFile.endswith(".j2"):
        # We add randomize the multipart boundary to stop user input from
        # conflicting with it.
        substitutions["multipart_boundary"] = generateAlphanumericTokenOfLength(32)
        template = sydent.config.general.template_environment.get_template(templateFile)
        mailString = template.render(substitutions)
    else:
        allSubstitutions = {}
        for k, v in substitutions.items():
            allSubstitutions[k] = v
            allSubstitutions[k + "_forhtml"] = escape(v)
            allSubstitutions[k + "_forurl"] = urllib.parse.quote(v)
        allSubstitutions["multipart_boundary"] = generateAlphanumericTokenOfLength(32)
        with open(templateFile) as template_file:
            mailString = template_file.read() % allSubstitutions

    try:
        check_valid_email_address(mailTo, allow_description=False)
    except EmailAddressException:
        logger.warning("Invalid email address %s", mailTo)
        raise

    mailServer = sydent.config.email.smtp_server
    mailPort = int(sydent.config.email.smtp_port)
    mailUsername = sydent.config.email.smtp_username
    mailPassword = sydent.config.email.smtp_password
    mailTLSMode = sydent.config.email.tls_mode

    logger.info(
        "Sending mail to %s with mail server: %s"
        % (
            mailTo,
            mailServer,
        )
    )
    try:
        smtp: smtplib.SMTP
        if mailTLSMode == "SSL" or mailTLSMode == "TLS":
            smtp = smtplib.SMTP_SSL(mailServer, mailPort, myHostname)
        elif mailTLSMode == "STARTTLS":
            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)
            smtp.starttls()
        else:
            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)
        if mailUsername != "":
            smtp.login(mailUsername, mailPassword)

        email_counter.inc()

        # We're using the parsing above to do basic validation, but instead of
        # failing it may munge the address it returns. So we should *not* use
        # that parsed address, as it may not match any validation done
        # elsewhere.
        smtp.sendmail(mailFrom, mailTo, mailString.encode("utf-8"))
        smtp.quit()
    except Exception as origException:
        if log_send_errors:
            twisted.python.log.err()
        raise EmailSendException() from origException
