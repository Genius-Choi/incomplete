def main():
    module = AnsibleModule(
        argument_spec=dict(
            state=dict(type='str', default='present', choices=['present', 'absent']),
            path=dict(type='path', required=True),
            provider=dict(type='str', choices=['acme', 'assertonly', 'entrust', 'ownca', 'selfsigned']),
            force=dict(type='bool', default=False,),
            csr_path=dict(type='path'),
            csr_content=dict(type='str'),
            backup=dict(type='bool', default=False),
            select_crypto_backend=dict(type='str', default='auto', choices=['auto', 'cryptography', 'pyopenssl']),
            return_content=dict(type='bool', default=False),

            # General properties of a certificate
            privatekey_path=dict(type='path'),
            privatekey_content=dict(type='str'),
            privatekey_passphrase=dict(type='str', no_log=True),

            # provider: assertonly
            signature_algorithms=dict(type='list', elements='str', removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            subject=dict(type='dict', removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            subject_strict=dict(type='bool', default=False, removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            issuer=dict(type='dict', removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            issuer_strict=dict(type='bool', default=False, removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            has_expired=dict(type='bool', default=False, removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            version=dict(type='int', removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            key_usage=dict(type='list', elements='str', aliases=['keyUsage'],
                           removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            key_usage_strict=dict(type='bool', default=False, aliases=['keyUsage_strict'],
                                  removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            extended_key_usage=dict(type='list', elements='str', aliases=['extendedKeyUsage'],
                                    removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            extended_key_usage_strict=dict(type='bool', default=False, aliases=['extendedKeyUsage_strict'],
                                           removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            subject_alt_name=dict(type='list', elements='str', aliases=['subjectAltName'],
                                  removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            subject_alt_name_strict=dict(type='bool', default=False, aliases=['subjectAltName_strict'],
                                         removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            not_before=dict(type='str', aliases=['notBefore'], removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            not_after=dict(type='str', aliases=['notAfter'], removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            valid_at=dict(type='str', removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            invalid_at=dict(type='str', removed_in_version='2.0.0', removed_from_collection='community.crypto'),
            valid_in=dict(type='str', removed_in_version='2.0.0', removed_from_collection='community.crypto'),

            # provider: selfsigned
            selfsigned_version=dict(type='int', default=3),
            selfsigned_digest=dict(type='str', default='sha256'),
            selfsigned_not_before=dict(type='str', default='+0s', aliases=['selfsigned_notBefore']),
            selfsigned_not_after=dict(type='str', default='+3650d', aliases=['selfsigned_notAfter']),
            selfsigned_create_subject_key_identifier=dict(
                type='str',
                default='create_if_not_provided',
                choices=['create_if_not_provided', 'always_create', 'never_create']
            ),

            # provider: ownca
            ownca_path=dict(type='path'),
            ownca_content=dict(type='str'),
            ownca_privatekey_path=dict(type='path'),
            ownca_privatekey_content=dict(type='str'),
            ownca_privatekey_passphrase=dict(type='str', no_log=True),
            ownca_digest=dict(type='str', default='sha256'),
            ownca_version=dict(type='int', default=3),
            ownca_not_before=dict(type='str', default='+0s'),
            ownca_not_after=dict(type='str', default='+3650d'),
            ownca_create_subject_key_identifier=dict(
                type='str',
                default='create_if_not_provided',
                choices=['create_if_not_provided', 'always_create', 'never_create']
            ),
            ownca_create_authority_key_identifier=dict(type='bool', default=True),

            # provider: acme
            acme_accountkey_path=dict(type='path'),
            acme_challenge_path=dict(type='path'),
            acme_chain=dict(type='bool', default=False),
            acme_directory=dict(type='str', default="https://acme-v02.api.letsencrypt.org/directory"),

            # provider: entrust
            entrust_cert_type=dict(type='str', default='STANDARD_SSL',
                                   choices=['STANDARD_SSL', 'ADVANTAGE_SSL', 'UC_SSL', 'EV_SSL', 'WILDCARD_SSL',
                                            'PRIVATE_SSL', 'PD_SSL', 'CDS_ENT_LITE', 'CDS_ENT_PRO', 'SMIME_ENT']),
            entrust_requester_email=dict(type='str'),
            entrust_requester_name=dict(type='str'),
            entrust_requester_phone=dict(type='str'),
            entrust_api_user=dict(type='str'),
            entrust_api_key=dict(type='str', no_log=True),
            entrust_api_client_cert_path=dict(type='path'),
            entrust_api_client_cert_key_path=dict(type='path', no_log=True),
            entrust_api_specification_path=dict(type='path', default='https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml'),
            entrust_not_after=dict(type='str', default='+365d'),
        ),
        supports_check_mode=True,
        add_file_common_args=True,
        required_if=[
            ['state', 'present', ['provider']],
            ['provider', 'entrust', ['entrust_requester_email', 'entrust_requester_name', 'entrust_requester_phone',
                                     'entrust_api_user', 'entrust_api_key', 'entrust_api_client_cert_path',
                                     'entrust_api_client_cert_key_path']],
        ],
        mutually_exclusive=[
            ['csr_path', 'csr_content'],
            ['privatekey_path', 'privatekey_content'],
            ['ownca_path', 'ownca_content'],
            ['ownca_privatekey_path', 'ownca_privatekey_content'],
        ],
    )
    if module._name == 'community.crypto.openssl_certificate':
        module.deprecate("The 'community.crypto.openssl_certificate' module has been renamed to 'community.crypto.x509_certificate'",
                         version='2.0.0', collection_name='community.crypto')

    try:
        if module.params['state'] == 'absent':
            certificate = CertificateAbsent(module)

        else:
            if module.params['provider'] != 'assertonly' and module.params['csr_path'] is None and module.params['csr_content'] is None:
                module.fail_json(msg='csr_path or csr_content is required when provider is not assertonly')

            base_dir = os.path.dirname(module.params['path']) or '.'
            if not os.path.isdir(base_dir):
                module.fail_json(
                    name=base_dir,
                    msg='The directory %s does not exist or the file is not a directory' % base_dir
                )

            provider = module.params['provider']
            if provider == 'assertonly':
                module.deprecate("The 'assertonly' provider is deprecated; please see the examples of "
                                 "the 'x509_certificate' module on how to replace it with other modules",
                                 version='2.0.0', collection_name='community.crypto')
            elif provider == 'selfsigned':
                if module.params['privatekey_path'] is None and module.params['privatekey_content'] is None:
                    module.fail_json(msg='One of privatekey_path and privatekey_content must be specified for the selfsigned provider.')
            elif provider == 'acme':
                if module.params['acme_accountkey_path'] is None:
                    module.fail_json(msg='The acme_accountkey_path option must be specified for the acme provider.')
                if module.params['acme_challenge_path'] is None:
                    module.fail_json(msg='The acme_challenge_path option must be specified for the acme provider.')
            elif provider == 'ownca':
                if module.params['ownca_path'] is None and module.params['ownca_content'] is None:
                    module.fail_json(msg='One of ownca_path and ownca_content must be specified for the ownca provider.')
                if module.params['ownca_privatekey_path'] is None and module.params['ownca_privatekey_content'] is None:
                    module.fail_json(msg='One of ownca_privatekey_path and ownca_privatekey_content must be specified for the ownca provider.')

            backend = module.params['select_crypto_backend']
            if backend == 'auto':
                # Detect what backend we can use
                can_use_cryptography = CRYPTOGRAPHY_FOUND and CRYPTOGRAPHY_VERSION >= LooseVersion(MINIMAL_CRYPTOGRAPHY_VERSION)
                can_use_pyopenssl = PYOPENSSL_FOUND and PYOPENSSL_VERSION >= LooseVersion(MINIMAL_PYOPENSSL_VERSION)

                # If cryptography is available we'll use it
                if can_use_cryptography:
                    backend = 'cryptography'
                elif can_use_pyopenssl:
                    backend = 'pyopenssl'

                if module.params['selfsigned_version'] == 2 or module.params['ownca_version'] == 2:
                    module.warn('crypto backend forced to pyopenssl. The cryptography library does not support v2 certificates')
                    backend = 'pyopenssl'

                # Fail if no backend has been found
                if backend == 'auto':
                    module.fail_json(msg=("Can't detect any of the required Python libraries "
                                          "cryptography (>= {0}) or PyOpenSSL (>= {1})").format(
                                              MINIMAL_CRYPTOGRAPHY_VERSION,
                                              MINIMAL_PYOPENSSL_VERSION))

            if backend == 'pyopenssl':
                if not PYOPENSSL_FOUND:
                    module.fail_json(msg=missing_required_lib('pyOpenSSL >= {0}'.format(MINIMAL_PYOPENSSL_VERSION)),
                                     exception=PYOPENSSL_IMP_ERR)
                if module.params['provider'] in ['selfsigned', 'ownca', 'assertonly']:
                    try:
                        getattr(crypto.X509Req, 'get_extensions')
                    except AttributeError:
                        module.fail_json(msg='You need to have PyOpenSSL>=0.15')

                module.deprecate('The module is using the PyOpenSSL backend. This backend has been deprecated',
                                 version='2.0.0', collection_name='community.crypto')
                if provider == 'selfsigned':
                    certificate = SelfSignedCertificate(module)
                elif provider == 'acme':
                    certificate = AcmeCertificate(module, 'pyopenssl')
                elif provider == 'ownca':
                    certificate = OwnCACertificate(module)
                elif provider == 'entrust':
                    certificate = EntrustCertificate(module, 'pyopenssl')
                else:
                    certificate = AssertOnlyCertificate(module)
            elif backend == 'cryptography':
                if not CRYPTOGRAPHY_FOUND:
                    module.fail_json(msg=missing_required_lib('cryptography >= {0}'.format(MINIMAL_CRYPTOGRAPHY_VERSION)),
                                     exception=CRYPTOGRAPHY_IMP_ERR)
                if module.params['selfsigned_version'] == 2 or module.params['ownca_version'] == 2:
                    module.fail_json(msg='The cryptography backend does not support v2 certificates, '
                                         'use select_crypto_backend=pyopenssl for v2 certificates')
                if provider == 'selfsigned':
                    certificate = SelfSignedCertificateCryptography(module)
                elif provider == 'acme':
                    certificate = AcmeCertificate(module, 'cryptography')
                elif provider == 'ownca':
                    certificate = OwnCACertificateCryptography(module)
                elif provider == 'entrust':
                    certificate = EntrustCertificate(module, 'cryptography')
                else:
                    certificate = AssertOnlyCertificateCryptography(module)

        if module.params['state'] == 'present':
            if module.check_mode:
                result = certificate.dump(check_mode=True)
                result['changed'] = module.params['force'] or not certificate.check(module)
                module.exit_json(**result)

            certificate.generate(module)
        else:
            if module.check_mode:
                result = certificate.dump(check_mode=True)
                result['changed'] = os.path.exists(module.params['path'])
                module.exit_json(**result)

            certificate.remove(module)

        result = certificate.dump()
        module.exit_json(**result)
    except OpenSSLObjectError as exc:
        module.fail_json(msg=to_native(exc))
