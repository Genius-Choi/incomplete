     void SipDialogController::doSendRequestOutsideDialog( SipMessageData* pData ) {
        nta_leg_t* leg = NULL ;
        nta_outgoing_t* orq = NULL ;
        string requestUri ;
        string name ;
        string sipOutboundProxy ;
        tport_t* tp = NULL ;
        std::shared_ptr<SipTransport> pSelectedTransport ;
        bool forceTport = false ;
        string host, port, proto, contact, desc ;
        tagi_t* tags = nullptr;

        try {
            bool useOutboundProxy = false ;
            const char *szRouteUrl = pData->getRouteUrl() ;
            if (*szRouteUrl != '\0') {
                useOutboundProxy = true ;
                sipOutboundProxy.assign(szRouteUrl);
            }
            else {
                useOutboundProxy = m_pController->getConfig()->getSipOutboundProxy( sipOutboundProxy ) ;
            }
            if (useOutboundProxy) {
                DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog sending request to route url: " << sipOutboundProxy ;
            }

            sip_request_t *sip_request = sip_request_make(m_pController->getHome(), pData->getStartLine() ) ;
            if( NULL == sip_request || 
                url_invalid == sip_request->rq_url[0].url_type || 
                url_unknown == sip_request->rq_url[0].url_type  ||
                sip_method_invalid == sip_request->rq_method ||
                sip_method_unknown == sip_request->rq_method  ) {

                throw std::runtime_error(string("invalid request-uri: ") + pData->getStartLine() ) ;
            }
            sip_method_t method = parseStartLine( pData->getStartLine(), name, requestUri ) ;

            int rc = 0 ;
            if( (sip_method_invite == sip_request->rq_method || 
                sip_method_options == sip_request->rq_method ||
                sip_method_notify == sip_request->rq_method ||
                sip_method_message == sip_request->rq_method) && 
                !tport_is_dgram(tp) /*&& NULL != strstr( sip_request->rq_url->url_host, ".invalid")*/ ) {

                std::shared_ptr<UaInvalidData> pData = 
                    m_pController->findTportForSubscription( sip_request->rq_url->url_user, sip_request->rq_url->url_host ) ;

                if( NULL != pData ) {
                    forceTport = true ;
                    tp = pData->getTport() ;
                    DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog selecting existing secondary transport " << std::hex << (void *) tp ;

                    getTransportDescription( tp, desc ) ;
                    DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog - selected transport " << std::hex << (void*)tp << ": " << desc << " for request-uri " << requestUri  ;            

                    const tp_name_t* tpn = tport_name( tport_parent( tp ) );
                    string host = tpn->tpn_host ;
                    string port = tpn->tpn_port ;
                    string proto = tpn->tpn_proto ;

                    contact = "<sip:" + host + ":" + port + ";transport=" + proto + ">";
               }
            }
            if( NULL == tp ) {
                pSelectedTransport = SipTransport::findAppropriateTransport( useOutboundProxy ? sipOutboundProxy.c_str() : requestUri.c_str()) ;
                if (!pSelectedTransport) {
                    throw std::runtime_error(string("requested protocol/transport not available"));
                }

                pSelectedTransport->getDescription(desc);
                pSelectedTransport->getContactUri( contact, true ) ;
                contact = "<" + contact + ">" ;
                host = pSelectedTransport->getHost() ;
                port = pSelectedTransport->getPort() ;

                tp = (tport_t *) pSelectedTransport->getTport() ;
                DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog selected transport " << std::hex << (void*)tp << desc ;
                forceTport = true ;
            }
            su_free( m_pController->getHome(), sip_request ) ;

            if (pSelectedTransport && pSelectedTransport->hasExternalIp()) {
                tags = makeTags( pData->getHeaders(), desc, pSelectedTransport->getExternalIp().c_str()) ;
            }
            else {
                tags = makeTags( pData->getHeaders(), desc, NULL) ;
            }
           
            //if user supplied all or part of the From use it
            string from, to, callid ;
            if( searchForHeader( tags, siptag_from_str, from ) ) {
                if( string::npos != from.find("localhost") ) {
                    if( !replaceHostInUri( from, host.c_str(), port.c_str() ) ) {
                        throw std::runtime_error(string("invalid from value provided by client: ") + from ) ;
                    }                    
                }
            } 
            else {
                from = contact ;
            }

            //default To header to request uri if not provided
            if( !searchForHeader( tags, siptag_to_str, to ) ) {
                to = requestUri ;
            } 

            DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog - from: " << from   ;            
            DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog - to: " << to ;            
            DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog - contact: " << contact  ;            

            // use call-id if supplied
            if( searchForHeader( tags, siptag_call_id_str, callid ) ) {
                DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog - using client-specified call-id: " << callid  ;            
            }

            //set content-type if not supplied and body contains SDP
            string body = pData->getBody() ;
            string contentType ;
            if( body.length() && !searchForHeader( tags, siptag_content_type_str, contentType ) ) {
                if( 0 == body.find("v=0") ) {
                    contentType = "application/sdp" ;
                    DR_LOG(log_debug) << "SipDialogController::doSendRequestOutsideDialog - automatically detecting content-type as application/sdp"  ;
                }
                else {
                    throw std::runtime_error("missing content-type") ;                   
                }
             }

            //prevent looping messages
            normalizeSipUri( requestUri, 0 ) ;
            if( isLocalSipUri( requestUri ) ) {
                throw std::runtime_error("can not send request to myself") ;
            }

            if( !(leg = nta_leg_tcreate( m_pController->getAgent(),
                uacLegCallback, (nta_leg_magic_t *) m_pController,
                SIPTAG_FROM_STR(from.c_str()),
                SIPTAG_TO_STR(to.c_str()),
                TAG_IF( callid.length(), SIPTAG_CALL_ID_STR(callid.c_str())),
                TAG_IF( method == sip_method_register, NTATAG_NO_DIALOG(1)),
                TAG_END() ) ) ) {

                throw std::runtime_error("Error creating leg") ;
            }
            nta_leg_tag( leg, NULL ) ;

            orq = nta_outgoing_tcreate( leg, 
                response_to_request_outside_dialog, 
                (nta_outgoing_magic_t*) m_pController, 
                useOutboundProxy ? URL_STRING_MAKE( sipOutboundProxy.c_str() ) : NULL, 
                method, 
                name.c_str()
                ,URL_STRING_MAKE(requestUri.c_str())
                ,TAG_IF( (method == sip_method_invite || method == sip_method_subscribe) && 
                    !searchForHeader( tags, siptag_contact_str, contact ), SIPTAG_CONTACT_STR( contact.c_str() ) )
                ,TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str()))
                ,TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))
                ,TAG_IF( forceTport, NTATAG_TPORT(tp))
                ,TAG_NEXT(tags) ) ;

            if( NULL == orq ) {
                throw std::runtime_error("Error creating sip transaction for uac request") ;               
            }

            msg_t* m = nta_outgoing_getrequest(orq) ; //adds a reference
            sip_t* sip = sip_object( m ) ;

            DR_LOG(log_info) << "SipDialogController::doSendRequestOutsideDialog - created orq " << std::hex << (void *) orq  <<
                " call-id " << sip->sip_call_id->i_id << " / transaction id: " << pData->getTransactionId();

            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{"method", sip->sip_request->rq_method_name}})

            if( method == sip_method_invite || method == sip_method_subscribe ) {
                std::shared_ptr<SipDialog> dlg = std::make_shared<SipDialog>(pData->getTransactionId(), 
                    leg, orq, sip, m, desc) ;
                string customContact ;
                bool hasCustomContact = searchForHeader( tags, siptag_contact_str, customContact ) ;
                dlg->setLocalContactHeader(hasCustomContact ? customContact.c_str() : contact.c_str());

                addOutgoingInviteTransaction( leg, orq, sip, dlg ) ;
                if (method == sip_method_invite) {
                  Cdr::postCdr( std::make_shared<CdrAttempt>(m, "application"));
                }
            }
            else {
                std::shared_ptr<RIP> p = std::make_shared<RIP>( pData->getTransactionId(), pData->getDialogId() ) ;
                addRIP( orq, p ) ;
                nta_leg_destroy( leg ) ;
            }

            string encodedMessage ;
            EncodeStackMessage( sip, encodedMessage ) ;
            SipMsgData_t meta(m, orq) ;
            string s ;
            meta.toMessageFormat(s) ;
            msg_destroy(m) ;    // releases reference

            string data = s + "|" + pData->getTransactionId() + "|Msg sent:|" + DR_CRLF + encodedMessage ;

            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), "OK", data ) ;
 
        } catch( std::runtime_error& err ) {
            DR_LOG(log_error) << "SipDialogController::doSendRequestOutsideDialog - " << err.what() ;
            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), "NOK", err.what() ) ;  
            m_pController->getClientController()->removeAppTransaction( pData->getTransactionId() ) ;
        }                       

        //N.B.: we must explicitly call the destructor of an object allocated with placement new
        pData->~SipMessageData() ;

        deleteTags(tags);
    }
