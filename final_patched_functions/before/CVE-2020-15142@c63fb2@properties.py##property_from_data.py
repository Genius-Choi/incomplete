def property_from_data(
    name: str, required: bool, data: Union[oai.Reference, oai.Schema]
) -> Union[Property, PropertyError]:
    """ Generate a Property from the OpenAPI dictionary representation of it """
    if isinstance(data, oai.Reference):
        return RefProperty(name=name, required=required, reference=Reference.from_ref(data.ref), default=None)
    if data.enum:
        return EnumProperty(
            name=name,
            required=required,
            values=EnumProperty.values_from_list(data.enum),
            title=data.title or name,
            default=data.default,
        )
    if data.anyOf:
        sub_properties: List[Property] = []
        for sub_prop_data in data.anyOf:
            sub_prop = property_from_data(name=name, required=required, data=sub_prop_data)
            if isinstance(sub_prop, PropertyError):
                return PropertyError(detail=f"Invalid property in union {name}", data=sub_prop_data)
            sub_properties.append(sub_prop)
        return UnionProperty(name=name, required=required, default=data.default, inner_properties=sub_properties)
    if not data.type:
        return PropertyError(data=data, detail="Schemas must either have one of enum, anyOf, or type defined.")
    if data.type == "string":
        return _string_based_property(name=name, required=required, data=data)
    elif data.type == "number":
        return FloatProperty(name=name, default=data.default, required=required)
    elif data.type == "integer":
        return IntProperty(name=name, default=data.default, required=required)
    elif data.type == "boolean":
        return BooleanProperty(name=name, required=required, default=data.default)
    elif data.type == "array":
        if data.items is None:
            return PropertyError(data=data, detail="type array must have items defined")
        inner_prop = property_from_data(name=f"{name}_item", required=True, data=data.items)
        if isinstance(inner_prop, PropertyError):
            return PropertyError(data=inner_prop.data, detail=f"invalid data in items of array {name}")
        return ListProperty(name=name, required=required, default=data.default, inner_property=inner_prop,)
    elif data.type == "object":
        return DictProperty(name=name, required=required, default=data.default)
    return PropertyError(data=data, detail=f"unknown type {data.type}")
