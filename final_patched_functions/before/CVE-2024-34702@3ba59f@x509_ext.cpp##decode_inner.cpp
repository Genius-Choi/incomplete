void Name_Constraints::decode_inner(const std::vector<uint8_t>& in) {
   std::vector<GeneralSubtree> permit, exclude;
   BER_Decoder ber(in);
   BER_Decoder ext = ber.start_sequence();
   BER_Object per = ext.get_next_object();

   ext.push_back(per);
   if(per.is_a(0, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {
      ext.decode_list(permit, ASN1_Type(0), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);
      if(permit.empty()) {
         throw Encoding_Error("Empty Name Contraint list");
      }
   }

   BER_Object exc = ext.get_next_object();
   ext.push_back(exc);
   if(per.is_a(1, ASN1_Class::Constructed | ASN1_Class::ContextSpecific)) {
      ext.decode_list(exclude, ASN1_Type(1), ASN1_Class::Constructed | ASN1_Class::ContextSpecific);
      if(exclude.empty()) {
         throw Encoding_Error("Empty Name Contraint list");
      }
   }

   ext.end_cons();

   if(permit.empty() && exclude.empty()) {
      throw Encoding_Error("Empty Name Contraint extension");
   }

   m_name_constraints = NameConstraints(std::move(permit), std::move(exclude));
}
