int trilogy_parse_handshake_packet(const uint8_t *buff, size_t len, trilogy_handshake_t *out_packet)
{
    int rc;

    trilogy_reader_t reader = TRILOGY_READER(buff, len);

    CHECKED(trilogy_reader_get_uint8(&reader, &out_packet->proto_version));
    if (out_packet->proto_version != 0xa) {
        // incompatible protocol version
        return TRILOGY_PROTOCOL_VIOLATION;
    }

    const char *server_version;
    size_t server_version_len;

    CHECKED(trilogy_reader_get_string(&reader, &server_version, &server_version_len));
    server_version_len = min(server_version_len, sizeof(out_packet->server_version) - 1);
    memcpy(out_packet->server_version, server_version, server_version_len);
    out_packet->server_version[server_version_len] = '\0';

    CHECKED(trilogy_reader_get_uint32(&reader, &out_packet->conn_id));

    CHECKED(trilogy_reader_copy_buffer(&reader, 8, out_packet->scramble));

    // this should be a NULL filler
    uint8_t filler = 0;
    CHECKED(trilogy_reader_get_uint8(&reader, &filler));
    if (filler != '\0') {
        // corrupt handshake packet
        return TRILOGY_PROTOCOL_VIOLATION;
    }

    // lower two bytes of capabilities flags
    uint16_t caps_part = 0;
    CHECKED(trilogy_reader_get_uint16(&reader, &caps_part));
    out_packet->capabilities = caps_part;

    if (!(out_packet->capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41)) {
        // incompatible protocol version
        return TRILOGY_PROTOCOL_VIOLATION;
    }

    uint8_t server_charset;
    CHECKED(trilogy_reader_get_uint8(&reader, &server_charset));

    out_packet->server_charset = server_charset;

    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->server_status));

    // upper 16 bits of capabilities flags

    CHECKED(trilogy_reader_get_uint16(&reader, &caps_part));
    out_packet->capabilities |= ((uint32_t)caps_part << 16);

    uint8_t auth_data_len = 0;
    CHECKED(trilogy_reader_get_uint8(&reader, &auth_data_len));
    if (!(out_packet->capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH)) {
        // this should be a NULL filler
        if (auth_data_len != '\0') {
            // corrupt handshake packet
            return TRILOGY_PROTOCOL_VIOLATION;
        }
    }

    // This space is reserved. It should be all NULL bytes but some tools or
    // future versions of MySQL-compatible clients may use it. This library
    // opts to skip the validation as some servers don't respect the protocol.
    //
    static const uint8_t null_filler[10] = {0};

    const void *str;
    CHECKED(trilogy_reader_get_buffer(&reader, 10, &str));

    if (memcmp(str, null_filler, 10) != 0) {
        // corrupt handshake packet
        return TRILOGY_PROTOCOL_VIOLATION;
    }

    if (out_packet->capabilities & TRILOGY_CAPABILITIES_SECURE_CONNECTION && auth_data_len > 8) {
        uint8_t remaining_auth_data_len = auth_data_len - 8;

        if (remaining_auth_data_len > 13) {
            remaining_auth_data_len = 13;
        }

        CHECKED(trilogy_reader_copy_buffer(&reader, remaining_auth_data_len, out_packet->scramble + 8));
    } else {
        // only support 4.1 protocol or newer with secure connection
        return TRILOGY_PROTOCOL_VIOLATION;
    }

    if (out_packet->capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {
        const char *auth_plugin;
        size_t auth_plugin_len;

        CHECKED(trilogy_reader_get_string(&reader, &auth_plugin, &auth_plugin_len));
        if (auth_plugin_len > sizeof(out_packet->auth_plugin) - 1) {
            return TRILOGY_AUTH_PLUGIN_TOO_LONG;
        }

        memcpy(out_packet->auth_plugin, auth_plugin, auth_plugin_len + 1);
    }

    return trilogy_reader_finish(&reader);

fail:
    return rc;
}
