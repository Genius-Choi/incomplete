extern "C" HRESULT CoreInitializeConstants(
    __in BURN_ENGINE_STATE* pEngineState
    )
{
    HRESULT hr = S_OK;
    BURN_ENGINE_COMMAND* pInternalCommand = &pEngineState->internalCommand;
    BURN_REGISTRATION* pRegistration = &pEngineState->registration;

    hr = DependencyInitialize(pInternalCommand, &pEngineState->dependencies, pRegistration);
    ExitOnFailure(hr, "Failed to initialize dependency data.");

    // Support passing Ancestors to embedded burn bundles.
    if (pInternalCommand->sczAncestors && *pInternalCommand->sczAncestors)
    {
        hr = StrAllocFormatted(&pRegistration->sczBundlePackageAncestors, L"%ls;%ls", pInternalCommand->sczAncestors, pRegistration->sczId);
        ExitOnFailure(hr, "Failed to copy ancestors and self to bundle package ancestors.");
    }
    else
    {
        hr = StrAllocString(&pRegistration->sczBundlePackageAncestors, pRegistration->sczId, 0);
        ExitOnFailure(hr, "Failed to copy self to bundle package ancestors.");
    }
    
    for (DWORD i = 0; i < pEngineState->packages.cPackages; ++i)
    {
        BURN_PACKAGE* pPackage = pEngineState->packages.rgPackages + i;

        if (BURN_PACKAGE_TYPE_BUNDLE == pPackage->type)
        {
            // Pass along any ancestors and ourself to prevent infinite loops.
            pPackage->Bundle.wzAncestors = pRegistration->sczBundlePackageAncestors;
            pPackage->Bundle.wzEngineWorkingDirectory = pInternalCommand->sczEngineWorkingDirectory;
        }
        else if (BURN_PACKAGE_TYPE_EXE == pPackage->type && pPackage->Exe.fBundle)
        {
            pPackage->Exe.wzAncestors = pRegistration->sczBundlePackageAncestors;
            pPackage->Exe.wzEngineWorkingDirectory = pInternalCommand->sczEngineWorkingDirectory;
        }
    }

LExit:
    return hr;
}
