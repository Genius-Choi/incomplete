display_signed_time(gchar *buf, size_t buflen, const nstime_t *ns, int precision)
{
	int nsecs;
	/* this buffer is not NUL terminated */
	gint8 num_buf[CHARS_64_BIT_SIGNED];
	gint8 *num_end = &num_buf[CHARS_64_BIT_SIGNED];
	gint8 *num_ptr;
	size_t num_len;

	if (buflen < 1)
		return;

	/* If the fractional part of the time stamp is negative,
	   print its absolute value and, if the seconds part isn't
	   (the seconds part should be zero in that case), stick
	   a "-" in front of the entire time stamp. */
	nsecs = ns->nsecs;
	if (nsecs < 0) {
		nsecs = -nsecs;
		if (ns->secs >= 0) {
			buf[0] = '-';
			buf++;
			buflen--;
		}
	}

	/*
	 * Fill in num_buf with the seconds value.
	 */
	num_ptr = int64_to_str_back(num_end, ns->secs);

	/*
	 * The length of the string that we want to copy to the buffer
	 * is the minimum of:
	 *
	 *    the length of the digit string;
	 *    the size of the buffer, minus 1 for the terminating
	 *      '\0'.
	 */
	num_len = MIN((size_t)(num_end - num_ptr), buflen - 1);
	if (num_len == 0) {
		/*
		 * Not enough room to copy anything.
		 */
		return;
	}

	/*
	 * Copy over the seconds value.
	 */
	memcpy(buf, num_ptr, num_len);
	buf += num_len;
	buflen -= num_len;

	if (precision == 0) {
		/*
		 * Seconds precision, so no nanosecond.
		 * Nothing more to do other than to
		 * '\0'-terminate the string.
		 */
		*buf = '\0';
		return;
	}

	/*
	 * Append the fractional part.
	 */
	format_fractional_part_nsecs(buf, buflen, (guint32)nsecs, ".", precision);
}
