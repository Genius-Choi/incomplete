def index():
    from octoprint.server import connectivityChecker, printer

    global _templates, _plugin_names, _plugin_vars

    preemptive_cache_enabled = settings().getBoolean(["devel", "cache", "preemptive"])

    locale = _locale_str(g.locale)

    # helper to check if wizards are active
    def wizard_active(templates):
        return templates is not None and bool(templates["wizard"]["order"])

    # we force a refresh if the client forces one and we are not printing or if we have wizards cached
    client_refresh = util.flask.cache_check_headers()
    request_refresh = "_refresh" in request.values
    printing = printer.is_printing()
    if client_refresh and printing:
        logging.getLogger(__name__).warning(
            "Client requested cache refresh via cache-control headers but we are printing. "
            "Not invalidating caches due to resource limitation. Append ?_refresh=true to "
            "the URL if you absolutely require a refresh now"
        )
    client_refresh = client_refresh and not printing
    force_refresh = (
        client_refresh or request_refresh or wizard_active(_templates.get(locale))
    )

    # if we need to refresh our template cache or it's not yet set, process it
    fetch_template_data(refresh=force_refresh)

    now = datetime.datetime.utcnow()

    enable_timelapse = settings().getBoolean(["webcam", "timelapseEnabled"])
    enable_loading_animation = settings().getBoolean(["devel", "showLoadingAnimation"])
    enable_sd_support = settings().get(["feature", "sdSupport"])
    enable_webcam = settings().getBoolean(["webcam", "webcamEnabled"])
    enable_temperature_graph = settings().get(["feature", "temperatureGraph"])
    sockjs_connect_timeout = settings().getInt(["devel", "sockJsConnectTimeout"])

    def default_template_filter(template_type, template_key):
        if template_type == "tab":
            return template_key != "timelapse" or enable_timelapse
        else:
            return True

    default_additional_etag = [
        enable_timelapse,
        enable_loading_animation,
        enable_sd_support,
        enable_webcam,
        enable_temperature_graph,
        sockjs_connect_timeout,
        connectivityChecker.online,
        wizard_active(_templates.get(locale)),
    ] + sorted(
        "{}:{}".format(to_unicode(k, errors="replace"), to_unicode(v, errors="replace"))
        for k, v in _plugin_vars.items()
    )

    def get_preemptively_cached_view(
        key, view, data=None, additional_request_data=None, additional_unless=None
    ):
        if (data is None and additional_request_data is None) or g.locale is None:
            return view

        d = _preemptive_data(
            key, data=data, additional_request_data=additional_request_data
        )

        def unless():
            return _preemptive_unless(
                base_url=request.url_root, additional_unless=additional_unless
            )

        # finally decorate our view
        return util.flask.preemptively_cached(
            cache=preemptiveCache, data=d, unless=unless
        )(view)

    def get_cached_view(
        key,
        view,
        additional_key_data=None,
        additional_files=None,
        additional_etag=None,
        custom_files=None,
        custom_etag=None,
        custom_lastmodified=None,
    ):
        if additional_etag is None:
            additional_etag = []

        def cache_key():
            return _cache_key(key, additional_key_data=additional_key_data)

        def collect_files():
            if callable(custom_files):
                try:
                    files = custom_files()
                    if files:
                        return files
                except Exception:
                    _logger.exception(
                        "Error while trying to retrieve tracked files for plugin {}".format(
                            key
                        )
                    )

            files = _get_all_templates()
            files += _get_all_assets()
            files += _get_all_translationfiles(_locale_str(g.locale), "messages")

            if callable(additional_files):
                try:
                    af = additional_files()
                    if af:
                        files += af
                except Exception:
                    _logger.exception(
                        "Error while trying to retrieve additional tracked files for plugin {}".format(
                            key
                        )
                    )

            return sorted(set(files))

        def compute_lastmodified(files):
            if callable(custom_lastmodified):
                try:
                    lastmodified = custom_lastmodified()
                    if lastmodified:
                        return lastmodified
                except Exception:
                    _logger.exception(
                        "Error while trying to retrieve custom LastModified value for plugin {}".format(
                            key
                        )
                    )

            return _compute_date(files)

        def compute_etag(files, lastmodified, additional=None):
            if callable(custom_etag):
                try:
                    etag = custom_etag()
                    if etag:
                        return etag
                except Exception:
                    _logger.exception(
                        "Error while trying to retrieve custom ETag value for plugin {}".format(
                            key
                        )
                    )

            if lastmodified and not isinstance(lastmodified, str):
                from werkzeug.http import http_date

                lastmodified = http_date(lastmodified)
            if additional is None:
                additional = []

            import hashlib

            hash = hashlib.sha1()

            def hash_update(value):
                hash.update(to_bytes(value, encoding="utf-8", errors="replace"))

            hash_update(octoprint.__version__)
            hash_update(get_python_version_string())
            hash_update(",".join(sorted(files)))
            if lastmodified:
                hash_update(lastmodified)
            for add in additional:
                hash_update(add)
            return hash.hexdigest()

        current_files = collect_files()
        current_lastmodified = compute_lastmodified(current_files)
        current_etag = compute_etag(
            files=current_files,
            lastmodified=current_lastmodified,
            additional=[cache_key()] + additional_etag,
        )

        def check_etag_and_lastmodified():
            lastmodified_ok = util.flask.check_lastmodified(current_lastmodified)
            etag_ok = util.flask.check_etag(current_etag)
            return lastmodified_ok and etag_ok

        def validate_cache(cached):
            return force_refresh or (current_etag != cached.get_etag()[0])

        decorated_view = view
        decorated_view = util.flask.lastmodified(lambda _: current_lastmodified)(
            decorated_view
        )
        decorated_view = util.flask.etagged(lambda _: current_etag)(decorated_view)
        decorated_view = util.flask.cached(
            timeout=-1,
            refreshif=validate_cache,
            key=cache_key,
            unless_response=lambda response: util.flask.cache_check_response_headers(
                response
            )
            or util.flask.cache_check_status_code(response, _valid_status_for_cache),
        )(decorated_view)
        decorated_view = util.flask.with_client_revalidation(decorated_view)
        decorated_view = util.flask.conditional(
            check_etag_and_lastmodified, NOT_MODIFIED
        )(decorated_view)
        return decorated_view

    def plugin_view(p):
        cached = get_cached_view(
            p._identifier,
            p.on_ui_render,
            additional_key_data=p.get_ui_additional_key_data_for_cache,
            additional_files=p.get_ui_additional_tracked_files,
            custom_files=p.get_ui_custom_tracked_files,
            custom_etag=p.get_ui_custom_etag,
            custom_lastmodified=p.get_ui_custom_lastmodified,
            additional_etag=p.get_ui_additional_etag(default_additional_etag),
        )

        if preemptive_cache_enabled and p.get_ui_preemptive_caching_enabled():
            view = get_preemptively_cached_view(
                p._identifier,
                cached,
                p.get_ui_data_for_preemptive_caching,
                p.get_ui_additional_request_data_for_preemptive_caching,
                p.get_ui_preemptive_caching_additional_unless,
            )
        else:
            view = cached

        template_filter = p.get_ui_custom_template_filter(default_template_filter)
        if template_filter is not None and callable(template_filter):
            filtered_templates = _filter_templates(_templates[locale], template_filter)
        else:
            filtered_templates = _templates[locale]

        render_kwargs = _get_render_kwargs(
            filtered_templates, _plugin_names, _plugin_vars, now
        )

        return view(now, request, render_kwargs)

    def default_view():
        filtered_templates = _filter_templates(
            _templates[locale], default_template_filter
        )

        wizard = wizard_active(filtered_templates)
        accesscontrol_active = userManager.has_been_customized()

        render_kwargs = _get_render_kwargs(
            filtered_templates, _plugin_names, _plugin_vars, now
        )
        render_kwargs.update(
            {
                "enableWebcam": enable_webcam,
                "enableTemperatureGraph": enable_temperature_graph,
                "enableAccessControl": True,
                "accessControlActive": accesscontrol_active,
                "enableLoadingAnimation": enable_loading_animation,
                "enableSdSupport": enable_sd_support,
                "sockJsConnectTimeout": sockjs_connect_timeout * 1000,
                "wizard": wizard,
                "online": connectivityChecker.online,
                "now": now,
            }
        )

        # no plugin took an interest, we'll use the default UI
        def make_default_ui():
            r = make_response(render_template("index.jinja2", **render_kwargs))
            if wizard:
                # if we have active wizard dialogs, set non caching headers
                r = util.flask.add_non_caching_response_headers(r)
            return r

        cached = get_cached_view(
            "_default", make_default_ui, additional_etag=default_additional_etag
        )
        preemptively_cached = get_preemptively_cached_view("_default", cached, {}, {})
        return preemptively_cached()

    default_permissions = [Permissions.STATUS, Permissions.SETTINGS_READ]

    response = None

    forced_view = request.headers.get("X-Force-View", None)

    if forced_view:
        # we have view forced by the preemptive cache
        _logger.debug(f"Forcing rendering of view {forced_view}")
        if forced_view != "_default":
            plugin = pluginManager.get_plugin_info(forced_view, require_enabled=True)
            if plugin is not None and isinstance(
                plugin.implementation, octoprint.plugin.UiPlugin
            ):
                permissions = plugin.implementation.get_ui_permissions()
                response = require_login_with(permissions=permissions)
                if not response:
                    response = plugin_view(plugin.implementation)
                    if _logger.isEnabledFor(logging.DEBUG) and isinstance(
                        response, Response
                    ):
                        response.headers[
                            "X-Ui-Plugin"
                        ] = plugin.implementation._identifier
        else:
            response = require_login_with(permissions=default_permissions)
            if not response:
                response = default_view()
                if _logger.isEnabledFor(logging.DEBUG) and isinstance(response, Response):
                    response.headers["X-Ui-Plugin"] = "_default"

    else:
        # select view from plugins and fall back on default view if no plugin will handle it
        ui_plugins = pluginManager.get_implementations(
            octoprint.plugin.UiPlugin, sorting_context="UiPlugin.on_ui_render"
        )
        for plugin in ui_plugins:
            try:
                if plugin.will_handle_ui(request):
                    # plugin claims responsibility, let it render the UI
                    permissions = plugin.get_ui_permissions()
                    response = require_login_with(permissions=permissions)
                    if not response:
                        response = plugin_view(plugin)
                        if response is not None:
                            if _logger.isEnabledFor(logging.DEBUG) and isinstance(
                                response, Response
                            ):
                                response.headers["X-Ui-Plugin"] = plugin._identifier
                            break
                        else:
                            _logger.warning(
                                "UiPlugin {} returned an empty response".format(
                                    plugin._identifier
                                )
                            )
            except Exception:
                _logger.exception(
                    "Error while calling plugin {}, skipping it".format(
                        plugin._identifier
                    ),
                    extra={"plugin": plugin._identifier},
                )
        else:
            response = require_login_with(permissions=default_permissions)
            if not response:
                response = default_view()
                if _logger.isEnabledFor(logging.DEBUG) and isinstance(response, Response):
                    response.headers["X-Ui-Plugin"] = "_default"

    if response is None:
        return abort(404)

    return add_csrf_cookie(response)
