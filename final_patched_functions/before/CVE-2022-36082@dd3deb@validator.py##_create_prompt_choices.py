def _create_prompt_choices(
    parser,
    iterator,
    text,
    on_empty_err,
    on_preview,
    limit=10
):
    def print_err(text):
        print(f"\n{text}\n")

    # Begin searching
    count = 1
    choices = {}
    paginator = Paginator()

    # For next results
    choices['next'] = "next"

    # For previous results
    choices['previous'] = "previous"

    # To see more details about selected result
    if on_preview:
        choices['preview'] = "preview"

    fetch = True
    while True:
        if fetch:
            items = []
            # 10 results displayed at the screen
            for _ in range(limit):
                try:
                    items.append(next(iterator))
                except StopIteration:
                    break
            
            if items:
                paginator.add_page(*items)

                # Append choices for user input
                for item in items:
                    choices[str(count)] = item
                    count += 1
            else:
                try:
                    paginator.previous()
                except IndexError:
                    parser.error(on_empty_err)
                else:
                    print_err("[ERROR] There are no more results")

        def print_choices():
            # Build dynamic bars
            dynamic_bar = ""
            for _ in range(len(text)):
                dynamic_bar += "="
            
            print(dynamic_bar)
            print(text)
            print(dynamic_bar)

            paginator.print()
            
            print("")

            print("type \"next\" to show next results")
            print("type \"previous\" to show previous results")

            if on_preview:
                print(
                    "type \"preview NUMBER\" to show more details about selected result. " \
                    "For example: \"preview 2\""
                )

        print_choices()

        # User input
        _next = False
        previous = False
        preview = False
        while True:
            choice = input_handle("=> ")

            # Parsing on_view
            if choice.startswith('preview'):
                choice = choice.split('preview')[1].strip()
                preview = True

            try:
                item = choices[choice]
            except KeyError:
                print_err('[ERROR] Invalid choice, try again')
                print_choices()
                continue
            else:
                if item == "next":
                    _next = True
                elif item == "previous":
                    try:
                        paginator.previous()
                    except IndexError:
                        print_err('[ERROR] Choices are out of range, try again')
                        print_choices()
                        continue

                    previous = True
                break
        
        if _next:
            paginator.next()
            fetch = True
            continue
        elif previous:
            fetch = False
            continue
        elif preview:
            fetch = False
            on_preview(item)
            continue
        else:
            break
    
    return item
