  def import_csv
    Log.add_info(request, params.inspect)

    file = params[:imp_file]
    mode = params[:mode]
    enc = params[:enc]
    book = params[:filter_book]
    book = Address::BOOK_PRIVATE unless @login_user.admin?(User::AUTH_ADDRESSBOOK)

    all_addresses = Address.get_for(@login_user, book)

    address_names = []
    if (mode == 'add')
      all_addresses.each do |address|
        address_names << address.name
      end
    end

    @imp_errs = {}
    count = -1  # 0 for Header-line
    addresses = [] 

    opt = {
      :skip_blanks => true
    }

    csv = file.read
    begin
      csv.encode!(Encoding::UTF_8, enc, {:invalid => :replace, :undef => :replace, :replace => ' '})
    rescue => evar
      Log.add_error(request, evar)
    end

    found_update = false
    err_col_names = nil
    col_idxs = []

    CSV.parse(csv, opt) do |row|
      unless row.first.nil?
        next if row.first.lstrip.index('#') == 0
      end
      next if row.compact.empty?

      count += 1
      if count == 0  # for Header Line
        err_col_names = Address.check_csv_header(row, book)
        if err_col_names.nil? or err_col_names.empty?
          header_cols = Address.csv_header_cols(book)
          col_idxs = header_cols.collect{|col_name| row.index(col_name)}
          next
        else
        logger.fatal('@@@ ' + err_col_names.inspect)
          @imp_errs[0] = []
          err_col_names.each do |err_col_name|
            @imp_errs[0] << t('address.invalid_column_names') + err_col_name
          end
          break
        end
      end

      address = Address.parse_csv_row(row, book, col_idxs, @login_user)

      check = address.check_import(mode, address_names)

      @imp_errs[count] = check unless check.empty?

      addresses << address

      if (mode == 'update')
        update_address = all_addresses.find do |rec|
          rec.id == address.id
        end
        unless update_address.nil?
          all_addresses.delete(update_address)
          found_update = true
        end
      end
    end

    if err_col_names.nil? or err_col_names.empty?
      if addresses.empty?
        @imp_errs[0] = [t('address.nothing_to_import')]
      else
        if (mode == 'update') and !found_update
          @imp_errs[0] = [t('address.nothing_to_update')]
        end
      end
    end

    # Create or Update
    count = 0
    @imp_cnt = 0
    if @imp_errs.empty?
      addresses.each do |address|
        count += 1
        begin
          address_id = address.id

          address.save!

          @imp_cnt += 1

        rescue => evar
          @imp_errs[count] = [t('address.save_failed') + evar.to_s]
        end
      end
    end

    # Delete
    # Actually, the correct order of the process is Delete -> Create,
    # not to duplicate a Address Name.
    #    3: morita   <- Delete
    #     : morita   <- Create
    # But such a case is most likely to be considered as a 
    # user's miss-operation. We can avoid this case with
    # 'opposite' process.
    del_cnt = 0
    if (@imp_errs.empty? and mode == 'update')
      all_addresses.each do |address|
        address.destroy
        del_cnt += 1
      end
    end

    if @imp_errs.empty?
      flash[:notice] = t('address.imported', :count => addresses.length)
      if (del_cnt > 0)
        flash[:notice] << '<br/>' + t('address.deleted', :count => del_cnt)
      end
    end

    list
    render(:action => 'list')
  end
