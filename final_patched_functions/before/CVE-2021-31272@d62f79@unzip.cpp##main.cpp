int main(int argc, char** argv)
{
    const char* path;
    int map_size_limit = 32 * MiB;

    Core::ArgsParser args_parser;
    args_parser.add_option(map_size_limit, "Maximum chunk size to map", "map-size-limit", 0, "size");
    args_parser.add_positional_argument(path, "File to unzip", "path", Core::ArgsParser::Required::Yes);
    args_parser.parse(argc, argv);

    String zip_file_path { path };

    struct stat st;
    int rc = stat(zip_file_path.characters(), &st);
    if (rc < 0) {
        perror("stat");
        return 1;
    }

    // FIXME: Map file chunk-by-chunk once we have mmap() with offset.
    //        This will require mapping some parts then unmapping them repeatedly,
    //        but it would be significantly faster and less syscall heavy than seek()/read() at every read.
    if (st.st_size >= map_size_limit) {
        fprintf(stderr, "unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\n",
            human_readable_size(map_size_limit).characters(),
            round_up_to_power_of_two(st.st_size, 16));
        return 1;
    }

    auto file_or_error = MappedFile ::map(zip_file_path);
    if (file_or_error.is_error()) {
        warnln("Failed to open {}: {}", zip_file_path, file_or_error.error());
        return 1;
    }
    auto& mapped_file = *file_or_error.value();

    printf("Archive: %s\n", zip_file_path.characters());

    off_t index = 0;
    while (find_next_central_directory(st.st_size, mapped_file, index, index)) {
        bool success = unpack_file_for_central_directory_index(index, mapped_file);
        if (!success) {
            printf("Could not find local file header for a file.\n");
            return 4;
        }
    }

    return 0;
}
