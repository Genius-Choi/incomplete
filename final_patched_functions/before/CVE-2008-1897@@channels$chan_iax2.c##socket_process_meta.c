static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,
	struct iax_frame *fr)
{
	unsigned char metatype;
	struct ast_iax2_meta_trunk_mini *mtm;
	struct ast_iax2_meta_trunk_hdr *mth;
	struct ast_iax2_meta_trunk_entry *mte;
	struct iax2_trunk_peer *tpeer;
	unsigned int ts;
	void *ptr;
	struct timeval rxtrunktime;
	struct ast_frame f = { 0, };

	if (packet_len < sizeof(*meta)) {
		ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\n", 
			ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
		return 1;
	}

	if (meta->metacmd != IAX_META_TRUNK)
		return 1;

	if (packet_len < (sizeof(*meta) + sizeof(*mth))) {
		ast_log(LOG_WARNING, "midget meta trunk packet received (%d of %d min)\n", packet_len,
			(int) (sizeof(*meta) + sizeof(*mth)));
		return 1;
	}
	mth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);
	ts = ntohl(mth->ts);
	metatype = meta->cmddata;
	packet_len -= (sizeof(*meta) + sizeof(*mth));
	ptr = mth->data;
	tpeer = find_tpeer(sin, sockfd);
	if (!tpeer) {
		ast_log(LOG_WARNING, "Unable to accept trunked packet from '%s:%d': No matching peer\n", 
			ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
		return 1;
	}
	tpeer->trunkact = ast_tvnow();
	if (!ts || ast_tvzero(tpeer->rxtrunktime))
		tpeer->rxtrunktime = tpeer->trunkact;
	rxtrunktime = tpeer->rxtrunktime;
	ast_mutex_unlock(&tpeer->lock);
	while (packet_len >= sizeof(*mte)) {
		/* Process channels */
		unsigned short callno, trunked_ts, len;

		if (metatype == IAX_META_TRUNK_MINI) {
			mtm = (struct ast_iax2_meta_trunk_mini *) ptr;
			ptr += sizeof(*mtm);
			packet_len -= sizeof(*mtm);
			len = ntohs(mtm->len);
			callno = ntohs(mtm->mini.callno);
			trunked_ts = ntohs(mtm->mini.ts);
		} else if (metatype == IAX_META_TRUNK_SUPERMINI) {
			mte = (struct ast_iax2_meta_trunk_entry *)ptr;
			ptr += sizeof(*mte);
			packet_len -= sizeof(*mte);
			len = ntohs(mte->len);
			callno = ntohs(mte->callno);
			trunked_ts = 0;
		} else {
			ast_log(LOG_WARNING, "Unknown meta trunk cmd from '%s:%d': dropping\n", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));
			break;
		}
		/* Stop if we don't have enough data */
		if (len > packet_len)
			break;
		fr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);
		if (!fr->callno)
			continue;

		/* If it's a valid call, deliver the contents.  If not, we
		   drop it, since we don't have a scallno to use for an INVAL */
		/* Process as a mini frame */
		memset(&f, 0, sizeof(f));
		f.frametype = AST_FRAME_VOICE;
		if (!iaxs[fr->callno]) {
			/* drop it */
		} else if (iaxs[fr->callno]->voiceformat == 0) {
			ast_log(LOG_WARNING, "Received trunked frame before first full voice frame\n ");
			iax2_vnak(fr->callno);
		} else {
			f.subclass = iaxs[fr->callno]->voiceformat;
			f.datalen = len;
			if (f.datalen >= 0) {
				if (f.datalen)
					f.data = ptr;
				else
					f.data = NULL;
				if (trunked_ts)
					fr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);
				else
					fr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);
				/* Don't pass any packets until we're started */
				if (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
					struct iax_frame *duped_fr;

					/* Common things */
					f.src = "IAX2";
					f.mallocd = 0;
					f.offset = 0;
					if (f.datalen && (f.frametype == AST_FRAME_VOICE)) 
						f.samples = ast_codec_get_samples(&f);
					else
						f.samples = 0;
					fr->outoforder = 0;
					iax_frame_wrap(fr, &f);
					duped_fr = iaxfrdup2(fr);
					if (duped_fr)
						schedule_delivery(duped_fr, 1, 1, &fr->ts);
					if (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)
						iaxs[fr->callno]->last = fr->ts;
				}
			} else {
				ast_log(LOG_WARNING, "Datalen < 0?\n");
			}
		}
		ast_mutex_unlock(&iaxsl[fr->callno]);
		ptr += len;
		packet_len -= len;
	}

	return 1;
}
