stl_fix_normal_directions(stl_file *stl) {
  char *norm_sw;
  /*  int edge_num;*/
  /*  int vnot;*/
  int checked = 0;
  int facet_num;
  /*  int next_facet;*/
  int i;
  int j;
  struct stl_normal {
    int               facet_num;
    struct stl_normal *next;
  };
  struct stl_normal *head;
  struct stl_normal *tail;
  struct stl_normal *newn;
  struct stl_normal *temp;

  if (stl->error) return;

  /* Initialize linked list. */
  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));
  if(head == NULL) perror("stl_fix_normal_directions");
  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));
  if(tail == NULL) perror("stl_fix_normal_directions");
  head->next = tail;
  tail->next = tail;

  /* Initialize list that keeps track of already fixed facets. */
  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));
  if(norm_sw == NULL) perror("stl_fix_normal_directions");


  facet_num = 0;
  /* If normal vector is not within tolerance and backwards:
     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances
     of it being wrong randomly are low if most of the triangles are right: */
  if(stl_check_normal_vector(stl, 0, 0) == 2)
    stl_reverse_facet(stl, 0);

  /* Say that we've fixed this facet: */
  norm_sw[facet_num] = 1;
  checked++;

  for(;;) {
    /* Add neighbors_to_list.
       Add unconnected neighbors to the list:a  */
    for(j = 0; j < 3; j++) {
      /* Reverse the neighboring facets if necessary. */
      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {
        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */
        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {
          stl_reverse_facet
          (stl, stl->neighbors_start[facet_num].neighbor[j]);
        }
      }
      /* If this edge of the facet is connected: */
      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {
        /* If we haven't fixed this facet yet, add it to the list: */
        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {
          /* Add node to beginning of list. */
          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));
          if(newn == NULL) perror("stl_fix_normal_directions");
          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];
          newn->next = head->next;
          head->next = newn;
        }
      }
    }
    /* Get next facet to fix from top of list. */
    if(head->next != tail) {
      facet_num = head->next->facet_num;
      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */
        norm_sw[facet_num] = 1; /* Record this one as being fixed. */
        checked++;
      }
      temp = head->next;	/* Delete this facet from the list. */
      head->next = head->next->next;
      free(temp);
    } else { /* if we ran out of facets to fix: */
      /* All of the facets in this part have been fixed. */
      stl->stats.number_of_parts += 1;
      if(checked >= stl->stats.number_of_facets) {
        /* All of the facets have been checked.  Bail out. */
        break;
      } else {
        /* There is another part here.  Find it and continue. */
        for(i = 0; i < stl->stats.number_of_facets; i++) {
          if(norm_sw[i] == 0) {
            /* This is the first facet of the next part. */
            facet_num = i;
            if(stl_check_normal_vector(stl, i, 0) == 2) {
              stl_reverse_facet(stl, i);
            }

            norm_sw[facet_num] = 1;
            checked++;
            break;
          }
        }
      }
    }
  }
  free(head);
  free(tail);
  free(norm_sw);
}
