[
    {
        "line": 35,
        "fullcodeline": "def pump_stream("
    },
    {
        "line": 74,
        "fullcodeline": "pumps: List[Tuple[str, IO, Callable[..., None] | None]] = []"
    },
    {
        "line": 80,
        "fullcodeline": "threads: List[threading.Thread] = []"
    },
    {
        "line": 60,
        "fullcodeline": "if hasattr(process, \"proc\"):"
    },
    {
        "line": 71,
        "fullcodeline": "if not isinstance(cmdline, (tuple, list)):"
    },
    {
        "line": 82,
        "fullcodeline": "for name, stream, handler in pumps:"
    },
    {
        "line": 89,
        "fullcodeline": "for t in threads:"
    },
    {
        "line": 61,
        "fullcodeline": "process = cast(\"Git.AutoInterrupt\", process)"
    },
    {
        "line": 62,
        "fullcodeline": "cmdline: str | Tuple[str, ...] | List[str] = getattr(process.proc, \"args\", \"\")"
    },
    {
        "line": 63,
        "fullcodeline": "p_stdout = process.proc.stdout if process.proc else None"
    },
    {
        "line": 64,
        "fullcodeline": "p_stderr = process.proc.stderr if process.proc else None"
    },
    {
        "line": 66,
        "fullcodeline": "process = cast(Popen, process)  # type: ignore [redundant-cast]"
    },
    {
        "line": 67,
        "fullcodeline": "cmdline = getattr(process, \"args\", \"\")"
    },
    {
        "line": 68,
        "fullcodeline": "p_stdout = process.stdout"
    },
    {
        "line": 69,
        "fullcodeline": "p_stderr = process.stderr"
    },
    {
        "line": 72,
        "fullcodeline": "cmdline = cmdline.split()"
    },
    {
        "line": 76,
        "fullcodeline": "pumps.append((\"stdout\", p_stdout, stdout_handler))"
    },
    {
        "line": 78,
        "fullcodeline": "pumps.append((\"stderr\", p_stderr, stderr_handler))"
    },
    {
        "line": 112,
        "fullcodeline": "finalizer(process)"
    },
    {
        "line": 83,
        "fullcodeline": "t = threading.Thread(target=pump_stream, args=(cmdline, name, stream, decode_streams, handler))"
    },
    {
        "line": 84,
        "fullcodeline": "t.daemon = True"
    },
    {
        "line": 85,
        "fullcodeline": "t.start()"
    },
    {
        "line": 86,
        "fullcodeline": "threads.append(t)"
    },
    {
        "line": 90,
        "fullcodeline": "t.join(timeout=kill_after_timeout)"
    },
    {
        "line": 91,
        "fullcodeline": "if t.is_alive():"
    },
    {
        "line": 92,
        "fullcodeline": "if isinstance(process, Git.AutoInterrupt):"
    },
    {
        "line": 93,
        "fullcodeline": "process._terminate()"
    },
    {
        "line": 95,
        "fullcodeline": "raise RuntimeError("
    },
    {
        "line": 100,
        "fullcodeline": "error_str: Union[str, bytes] = ("
    },
    {
        "line": 109,
        "fullcodeline": "stderr_handler(error_str)  # type: ignore"
    },
    {
        "line": 101,
        "fullcodeline": "\"error: process killed because it timed out.\" f\" kill_after_timeout={kill_after_timeout} seconds\""
    },
    {
        "line": 103,
        "fullcodeline": "if not decode_streams and isinstance(p_stderr, BinaryIO):"
    },
    {
        "line": 96,
        "fullcodeline": "\"Thread join() timed out in cmd.handle_process_output().\""
    },
    {
        "line": 105,
        "fullcodeline": "error_str = cast(str, error_str)"
    },
    {
        "line": 106,
        "fullcodeline": "error_str = error_str.encode()"
    },
    {
        "line": 97,
        "fullcodeline": "f\" kill_after_timeout={kill_after_timeout} seconds\""
    }
]