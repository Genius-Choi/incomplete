--- before
+++ after
@@ -14,6 +14,7 @@
     char *tid = NULL;
     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));
     struct filedata_s *firstlink = NULL;
+    struct diriter_s di = { -1 };
 
     /* transaction id used for temporary path suffix while installing */
     rasprintf(&tid, ";%08x", (unsigned)rpmtsGetTid(ts));
@@ -56,6 +57,7 @@
         rc = RPMERR_BAD_MAGIC;
         goto exit;
     }
+    rpmfiSetOnChdir(fi, onChdir, &di);
 
     /* Detect and create directories not explicitly in package. */
     if (!rc)
@@ -70,6 +72,16 @@
 	    if (!fp->suffix) {
 		rc = fsmBackup(fi, fp->action);
 	    }
+
+	    if (di.dirfd == -1) {
+		di.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,
+				    (fp->action == FA_CREATE));
+		if (di.dirfd == -1) {
+		    rc = RPMERR_OPEN_FAILED;
+		    break;
+		}
+	    }
+
 	    /* Assume file does't exist when tmp suffix is in use */
 	    if (!fp->suffix) {
 		if (fp->action == FA_TOUCH) {
@@ -104,7 +116,7 @@
                     mode_t mode = fp->sb.st_mode;
                     mode &= ~07777;
                     mode |=  00700;
-                    rc = fsmMkdir(fp->fpath, mode);
+                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);
                 }
             } else if (S_ISLNK(fp->sb.st_mode)) {
 		if (rc == RPMERR_ENOENT) {
@@ -146,6 +158,8 @@
 	fp->stage = FILE_UNPACK;
     }
     fi = rpmfiFree(fi);
+    close(di.dirfd);
+    di.dirfd = -1;
 
     if (!rc && fx < 0 && fx != RPMERR_ITER_END)
 	rc = fx;
