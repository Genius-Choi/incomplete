static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)
{
	if (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {
		/* IF we have no IP without dnsmgr, or this isn't to be monitored, return
		  immediately after clearing things out */
		peer->lastms = 0;
		peer->historicms = 0;
		peer->pokeexpire = -1;
		peer->callno = 0;
		return 0;
	}
	if (peer->callno > 0) {
		ast_log(LOG_NOTICE, "Still have a callno...\n");
		ast_mutex_lock(&iaxsl[peer->callno]);
		iax2_destroy(peer->callno);
		ast_mutex_unlock(&iaxsl[peer->callno]);
	}
	if (heldcall)
		ast_mutex_unlock(&iaxsl[heldcall]);
	peer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);
	if (heldcall)
		ast_mutex_lock(&iaxsl[heldcall]);
	if (peer->callno < 1) {
		ast_log(LOG_WARNING, "Unable to allocate call for poking peer '%s'\n", peer->name);
		return -1;
	}

	/* Speed up retransmission times for this qualify call */
	iaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;
	iaxs[peer->callno]->peerpoke = peer;
	
	/* Remove any pending pokeexpire task */
	if (peer->pokeexpire > -1) {
		if (!ast_sched_del(sched, peer->pokeexpire)) {
			peer->pokeexpire = -1;
			peer_unref(peer);
		}
	}

	/* Queue up a new task to handle no reply */
	/* If the host is already unreachable then use the unreachable interval instead */
	if (peer->lastms < 0) {
		peer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));
	} else
		peer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));

	if (peer->pokeexpire == -1)
		peer_unref(peer);

	/* And send the poke */
	send_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);

	return 0;
}
