--- before
+++ after
@@ -5,7 +5,8 @@
         CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());

 

         try {

-            if (ele.getChildNodes().getLength() > 0) {

+            int childNodesCount = ele.getChildNodes().getLength();

+            if (childNodesCount > 0) {

                 StringBuffer toScan = new StringBuffer();

 

                 for (int i = 0; i < ele.getChildNodes().getLength(); i++) {

@@ -26,7 +27,6 @@
                  * would normally be left with an empty style tag and

                  * break all CSS. To prevent that, we have this check.

                  */

-

                 String cleanHTML = cr.getCleanHTML();

                 cleanHTML = cleanHTML == null || cleanHTML.equals("") ? "/* */" : cleanHTML;

 

@@ -34,21 +34,19 @@
                 /*

                  * Remove every other node after cleaning CSS, there will

                  * be only one node in the end, as it always should have.

+                 * Starting from the end due to list updating on the fly.

                  */

-                for (int i = 1; i < ele.getChildNodes().getLength(); i++) {

+                for (int i = childNodesCount - 1; i >= 1; i--) {

                     Node childNode = ele.getChildNodes().item(i);

                     ele.removeChild(childNode);

                 }

             }

-

         } catch (DOMException | ScanException | ParseException | NumberFormatException e) {

-

             /*

              * ParseException shouldn't be possible anymore, but we'll leave it

              * here because I (Arshan) am hilariously dumb sometimes.

              * Batik can throw NumberFormatExceptions (see bug #48).

              */

-

             addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});

             parentNode.removeChild(ele);

             return true;

