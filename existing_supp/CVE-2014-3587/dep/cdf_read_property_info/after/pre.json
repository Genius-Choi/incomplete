[
    {
        "line": 24,
        "fullcodeline": "sh.sh_len = CDF_TOLE4(shp->sh_len);"
    },
    {
        "line": 30,
        "fullcodeline": "sh.sh_properties = CDF_TOLE4(shp->sh_properties);"
    },
    {
        "line": 34,
        "fullcodeline": "DPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,"
    },
    {
        "line": 49,
        "fullcodeline": "*info = inp;"
    },
    {
        "line": 50,
        "fullcodeline": "inp += *count;"
    },
    {
        "line": 51,
        "fullcodeline": "*count += sh.sh_properties;"
    },
    {
        "line": 16,
        "fullcodeline": "if (offs > UINT32_MAX / 4) {"
    },
    {
        "line": 22,
        "fullcodeline": "if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)"
    },
    {
        "line": 26,
        "fullcodeline": "if (sh.sh_len > CDF_SHLEN_LIMIT) {"
    },
    {
        "line": 32,
        "fullcodeline": "if (sh.sh_properties > CDF_PROP_LIMIT)"
    },
    {
        "line": 47,
        "fullcodeline": "if (inp == NULL)"
    },
    {
        "line": 57,
        "fullcodeline": "if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)"
    },
    {
        "line": 59,
        "fullcodeline": "for (i = 0; i < sh.sh_properties; i++) {"
    },
    {
        "line": 200,
        "fullcodeline": "return -1;"
    },
    {
        "line": 39,
        "fullcodeline": "*maxcount += sh.sh_properties;"
    },
    {
        "line": 60,
        "fullcodeline": "size_t tail = (i << 1) + 1;"
    },
    {
        "line": 64,
        "fullcodeline": "size_t ofs = CDF_GETUINT32(p, tail);"
    },
    {
        "line": 65,
        "fullcodeline": "q = (const uint8_t *)(const void *)"
    },
    {
        "line": 76,
        "fullcodeline": "inp[i].pi_id = CDF_GETUINT32(p, i << 1);"
    },
    {
        "line": 77,
        "fullcodeline": "inp[i].pi_type = CDF_GETUINT32(q, 0);"
    },
    {
        "line": 91,
        "fullcodeline": "o4 = o * sizeof(uint32_t);"
    },
    {
        "line": 37,
        "fullcodeline": "if (*maxcount > CDF_PROP_LIMIT)"
    },
    {
        "line": 43,
        "fullcodeline": "*maxcount = sh.sh_properties;"
    },
    {
        "line": 61,
        "fullcodeline": "if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),"
    },
    {
        "line": 68,
        "fullcodeline": "if (q < p) {"
    },
    {
        "line": 72,
        "fullcodeline": "if (q > e) {"
    },
    {
        "line": 80,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR) {"
    },
    {
        "line": 92,
        "fullcodeline": "if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))"
    },
    {
        "line": 94,
        "fullcodeline": "switch (inp[i].pi_type & CDF_TYPEMASK) {"
    },
    {
        "line": 62,
        "fullcodeline": "__LINE__) == -1)"
    },
    {
        "line": 81,
        "fullcodeline": "nelements = CDF_GETUINT32(q, 1);"
    },
    {
        "line": 86,
        "fullcodeline": "o = 2;"
    },
    {
        "line": 101,
        "fullcodeline": "(void)memcpy(&s16, &q[o4], sizeof(s16));"
    },
    {
        "line": 102,
        "fullcodeline": "inp[i].pi_s16 = CDF_TOLE2(s16);"
    },
    {
        "line": 107,
        "fullcodeline": "(void)memcpy(&s32, &q[o4], sizeof(s32));"
    },
    {
        "line": 108,
        "fullcodeline": "inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);"
    },
    {
        "line": 114,
        "fullcodeline": "(void)memcpy(&u32, &q[o4], sizeof(u32));"
    },
    {
        "line": 115,
        "fullcodeline": "inp[i].pi_u32 = CDF_TOLE4(u32);"
    },
    {
        "line": 120,
        "fullcodeline": "(void)memcpy(&s64, &q[o4], sizeof(s64));"
    },
    {
        "line": 121,
        "fullcodeline": "inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);"
    },
    {
        "line": 126,
        "fullcodeline": "(void)memcpy(&u64, &q[o4], sizeof(u64));"
    },
    {
        "line": 127,
        "fullcodeline": "inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);"
    },
    {
        "line": 132,
        "fullcodeline": "(void)memcpy(&u32, &q[o4], sizeof(u32));"
    },
    {
        "line": 133,
        "fullcodeline": "u32 = CDF_TOLE4(u32);"
    },
    {
        "line": 134,
        "fullcodeline": "memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));"
    },
    {
        "line": 139,
        "fullcodeline": "(void)memcpy(&u64, &q[o4], sizeof(u64));"
    },
    {
        "line": 140,
        "fullcodeline": "u64 = CDF_TOLE8((uint64_t)u64);"
    },
    {
        "line": 141,
        "fullcodeline": "memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));"
    },
    {
        "line": 178,
        "fullcodeline": "i--;"
    },
    {
        "line": 183,
        "fullcodeline": "(void)memcpy(&tp, &q[o4], sizeof(tp));"
    },
    {
        "line": 184,
        "fullcodeline": "inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);"
    },
    {
        "line": 192,
        "fullcodeline": "DPRINTF((\"Don't know how to deal with %x\\n\","
    },
    {
        "line": 66,
        "fullcodeline": "((const char *)(const void *)p + ofs"
    },
    {
        "line": 69,
        "fullcodeline": "DPRINTF((\"Wrapped around %p < %p\\n\", q, p));"
    },
    {
        "line": 73,
        "fullcodeline": "DPRINTF((\"Ran of the end %p > %p\\n\", q, e));"
    },
    {
        "line": 82,
        "fullcodeline": "if (nelements == 0) {"
    },
    {
        "line": 88,
        "fullcodeline": "nelements = 1;"
    },
    {
        "line": 89,
        "fullcodeline": "o = 1;"
    },
    {
        "line": 99,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 105,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 112,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 118,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 124,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 130,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 137,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 145,
        "fullcodeline": "if (nelements > 1) {"
    },
    {
        "line": 160,
        "fullcodeline": "for (j = 0; j < nelements && i < sh.sh_properties;"
    },
    {
        "line": 161,
        "fullcodeline": "j++, i++)"
    },
    {
        "line": 181,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 187,
        "fullcodeline": "if (inp[i].pi_type & CDF_VECTOR)"
    },
    {
        "line": 67,
        "fullcodeline": "- 2 * sizeof(uint32_t));"
    },
    {
        "line": 146,
        "fullcodeline": "size_t nelem = inp - *info;"
    },
    {
        "line": 150,
        "fullcodeline": "*maxcount += nelements;"
    },
    {
        "line": 155,
        "fullcodeline": "*info = inp;"
    },
    {
        "line": 156,
        "fullcodeline": "inp = *info + nelem;"
    },
    {
        "line": 163,
        "fullcodeline": "uint32_t l = CDF_GETUINT32(q, o);"
    },
    {
        "line": 164,
        "fullcodeline": "inp[i].pi_str.s_len = l;"
    },
    {
        "line": 165,
        "fullcodeline": "inp[i].pi_str.s_buf = (const char *)"
    },
    {
        "line": 173,
        "fullcodeline": "o += l >> 1;"
    },
    {
        "line": 176,
        "fullcodeline": "o4 = o * sizeof(uint32_t);"
    },
    {
        "line": 147,
        "fullcodeline": "if (*maxcount > CDF_PROP_LIMIT"
    },
    {
        "line": 153,
        "fullcodeline": "if (inp == NULL)"
    },
    {
        "line": 171,
        "fullcodeline": "if (l & 1)"
    },
    {
        "line": 174,
        "fullcodeline": "if (q + o >= e)"
    },
    {
        "line": 148,
        "fullcodeline": "|| nelements > CDF_PROP_LIMIT)"
    },
    {
        "line": 166,
        "fullcodeline": "(const void *)(&q[o4 + sizeof(l)]);"
    },
    {
        "line": 172,
        "fullcodeline": "l++;"
    }
]