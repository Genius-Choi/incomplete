fio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,
                          void *unread_data, size_t unread_length) {
  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)
    return NULL;
  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);
  // FIO_LOG_DEBUG("Allocated HTTP/1.1 protocol at. %p", (void *)p);
  FIO_ASSERT_ALLOC(p);
  *p = (http1pr_s){
      .p.protocol =
          {
              .on_data = http1_on_data_first_time,
              .on_close = http1_on_close,
              .on_ready = http1_on_ready,
          },
      .p.uuid = uuid,
      .p.settings = settings,
      .max_header_size = settings->max_header_size,
      .is_client = settings->is_client,
  };
  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    memcpy(p->buf, unread_data, unread_length);
    p->buf_len = unread_length;
  }
  fio_attach(uuid, &p->p.protocol);
  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {
    fio_force_event(uuid, FIO_EVENT_ON_DATA);
  }
  return &p->p.protocol;
}
