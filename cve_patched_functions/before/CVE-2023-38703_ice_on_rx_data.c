static void ice_on_rx_data(pj_ice_strans *ice_st, unsigned comp_id, 
                           void *pkt, pj_size_t size,
                           const pj_sockaddr_t *src_addr,
                           unsigned src_addr_len)
{
    struct transport_ice *tp_ice;
    pj_bool_t discard = PJ_FALSE;

    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);
    if (!tp_ice) {
        /* Destroy on progress */
        return;
    }

    if (comp_id == 1) {
        ++tp_ice->rtp_src_cnt;
        pj_sockaddr_cp(&tp_ice->rtp_src_addr, src_addr);
    } else if (comp_id == 2) {
        pj_sockaddr_cp(&tp_ice->rtcp_src_addr, src_addr);
    }

    if (comp_id==1 && (tp_ice->rtp_cb || tp_ice->rtp_cb2)) {
        pj_bool_t rem_switch = PJ_FALSE;

        /* Simulate packet lost on RX direction */
        if (tp_ice->rx_drop_pct) {
            if ((pj_rand() % 100) <= (int)tp_ice->rx_drop_pct) {
                PJ_LOG(5,(tp_ice->base.name, 
                          "RX RTP packet dropped because of pkt lost "
                          "simulation"));
                return;
            }
        }

        if (!discard) {
            if (tp_ice->rtp_cb2) {
                pjmedia_tp_cb_param param;

                param.user_data = tp_ice->stream;
                param.pkt = pkt;
                param.size = size;
                param.src_addr = (tp_ice->use_ice? NULL:
                                  (pj_sockaddr_t *)src_addr);
                param.rem_switch = PJ_FALSE;
                (*tp_ice->rtp_cb2)(&param);
                rem_switch = param.rem_switch;
            } else {
                (*tp_ice->rtp_cb)(tp_ice->stream, pkt, size);
            }
        }
        
#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \
    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)
        if (rem_switch &&
            (tp_ice->options & PJMEDIA_ICE_NO_SRC_ADDR_CHECKING)==0)
        {
            char addr_text[PJ_INET6_ADDRSTRLEN+10];

            /* Set remote RTP address to source address */
            pj_sockaddr_cp(&tp_ice->rtp_src_addr, src_addr);
            pj_sockaddr_cp(&tp_ice->remote_rtp, src_addr);
            tp_ice->addr_len = pj_sockaddr_get_len(&tp_ice->remote_rtp);

            PJ_LOG(4,(tp_ice->base.name,
                      "Remote RTP address switched to %s",
                      pj_sockaddr_print(&tp_ice->remote_rtp, addr_text,
                                        sizeof(addr_text), 3)));

            if (tp_ice->use_rtcp_mux) {
                pj_sockaddr_cp(&tp_ice->remote_rtcp, &tp_ice->remote_rtp);
            } else if (!pj_sockaddr_has_addr(&tp_ice->rtcp_src_addr)) {
                /* Also update remote RTCP address if actual RTCP source
                 * address is not heard yet.
                 */
                pj_uint16_t port;

                pj_sockaddr_cp(&tp_ice->remote_rtcp, &tp_ice->remote_rtp);

                port = (pj_uint16_t)
                       (pj_sockaddr_get_port(&tp_ice->remote_rtp)+1);
                pj_sockaddr_set_port(&tp_ice->remote_rtcp, port);

                PJ_LOG(4,(tp_ice->base.name,
                          "Remote RTCP address switched to predicted "
                          "address %s",
                          pj_sockaddr_print(&tp_ice->remote_rtcp, 
                                            addr_text,
                                            sizeof(addr_text), 3)));
            }
        }
#else
        PJ_UNUSED_ARG(rem_switch);
#endif

    } else if (comp_id==2 && tp_ice->rtcp_cb) {

#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \
    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)
        /* Check if RTCP source address is the same as the configured
         * remote address, and switch the address when they are
         * different.
         */
        if (!tp_ice->use_ice &&
            (tp_ice->options & PJMEDIA_ICE_NO_SRC_ADDR_CHECKING)==0)
        {
            if (pj_sockaddr_cmp(&tp_ice->remote_rtcp, src_addr) == 0) {
                tp_ice->rtcp_src_cnt = 0;
            } else {
                char addr_text[PJ_INET6_ADDRSTRLEN+10];

                ++tp_ice->rtcp_src_cnt;
                if (tp_ice->rtcp_src_cnt < PJMEDIA_RTCP_NAT_PROBATION_CNT) {
                    discard = PJ_TRUE;
                } else {
                    tp_ice->rtcp_src_cnt = 0;
                    pj_sockaddr_cp(&tp_ice->rtcp_src_addr, src_addr);
                    pj_sockaddr_cp(&tp_ice->remote_rtcp, src_addr);

                    pj_assert(tp_ice->addr_len==pj_sockaddr_get_len(src_addr));

                    PJ_LOG(4,(tp_ice->base.name,
                              "Remote RTCP address switched to %s",
                              pj_sockaddr_print(&tp_ice->remote_rtcp,
                                                addr_text, sizeof(addr_text),
                                                3)));
                }
            }
        }
#endif

        if (!discard)
            (*tp_ice->rtcp_cb)(tp_ice->stream, pkt, size);
    }

    PJ_UNUSED_ARG(src_addr_len);
}
