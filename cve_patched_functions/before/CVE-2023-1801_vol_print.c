vol_print(netdissect_options *ndo,
          const u_char *bp, u_int length)
{
	uint32_t vol_op;

	if (length <= sizeof(struct rx_header))
		return;

	/*
	 * Print out the afs call we're invoking.  The table used here was
	 * gleaned from volser/volint.xg
	 */

	vol_op = GET_BE_U_4(bp + sizeof(struct rx_header));

	ND_PRINT(" vol call %s", tok2str(vol_req, "op#%u", vol_op));

	bp += sizeof(struct rx_header) + 4;

	switch (vol_op) {
		case 100:	/* Create volume */
			ND_PRINT(" partition");
			UINTOUT();
			ND_PRINT(" name");
			STROUT(AFSNAMEMAX);
			ND_PRINT(" type");
			UINTOUT();
			ND_PRINT(" parent");
			UINTOUT();
			break;
		case 101:	/* Delete volume */
		case 107:	/* Get flags */
			ND_PRINT(" trans");
			UINTOUT();
			break;
		case 102:	/* Restore */
			ND_PRINT(" totrans");
			UINTOUT();
			ND_PRINT(" flags");
			UINTOUT();
			break;
		case 103:	/* Forward */
			ND_PRINT(" fromtrans");
			UINTOUT();
			ND_PRINT(" fromdate");
			DATEOUT();
			DESTSERVEROUT();
			ND_PRINT(" desttrans");
			INTOUT();
			break;
		case 104:	/* End trans */
			ND_PRINT(" trans");
			UINTOUT();
			break;
		case 105:	/* Clone */
			ND_PRINT(" trans");
			UINTOUT();
			ND_PRINT(" purgevol");
			UINTOUT();
			ND_PRINT(" newtype");
			UINTOUT();
			ND_PRINT(" newname");
			STROUT(AFSNAMEMAX);
			break;
		case 106:	/* Set flags */
			ND_PRINT(" trans");
			UINTOUT();
			ND_PRINT(" flags");
			UINTOUT();
			break;
		case 108:	/* Trans create */
			ND_PRINT(" vol");
			UINTOUT();
			ND_PRINT(" partition");
			UINTOUT();
			ND_PRINT(" flags");
			UINTOUT();
			break;
		case 109:	/* Dump */
		case 655537:	/* Get size */
			ND_PRINT(" fromtrans");
			UINTOUT();
			ND_PRINT(" fromdate");
			DATEOUT();
			break;
		case 110:	/* Get n-th volume */
			ND_PRINT(" index");
			UINTOUT();
			break;
		case 111:	/* Set forwarding */
			ND_PRINT(" tid");
			UINTOUT();
			ND_PRINT(" newsite");
			UINTOUT();
			break;
		case 112:	/* Get name */
		case 113:	/* Get status */
			ND_PRINT(" tid");
			break;
		case 114:	/* Signal restore */
			ND_PRINT(" name");
			STROUT(AFSNAMEMAX);
			ND_PRINT(" type");
			UINTOUT();
			ND_PRINT(" pid");
			UINTOUT();
			ND_PRINT(" cloneid");
			UINTOUT();
			break;
		case 116:	/* List volumes */
			ND_PRINT(" partition");
			UINTOUT();
			ND_PRINT(" flags");
			UINTOUT();
			break;
		case 117:	/* Set id types */
			ND_PRINT(" tid");
			UINTOUT();
			ND_PRINT(" name");
			STROUT(AFSNAMEMAX);
			ND_PRINT(" type");
			UINTOUT();
			ND_PRINT(" pid");
			UINTOUT();
			ND_PRINT(" clone");
			UINTOUT();
			ND_PRINT(" backup");
			UINTOUT();
			break;
		case 119:	/* Partition info */
			ND_PRINT(" name");
			STROUT(AFSNAMEMAX);
			break;
		case 120:	/* Reclone */
			ND_PRINT(" tid");
			UINTOUT();
			break;
		case 121:	/* List one volume */
		case 122:	/* Nuke volume */
		case 124:	/* Extended List volumes */
		case 125:	/* Extended List one volume */
		case 65536:	/* Convert RO to RW volume */
			ND_PRINT(" partid");
			UINTOUT();
			ND_PRINT(" volid");
			UINTOUT();
			break;
		case 123:	/* Set date */
			ND_PRINT(" tid");
			UINTOUT();
			ND_PRINT(" date");
			DATEOUT();
			break;
		case 126:	/* Set info */
			ND_PRINT(" tid");
			UINTOUT();
			break;
		case 128:	/* Forward multiple */
			ND_PRINT(" fromtrans");
			UINTOUT();
			ND_PRINT(" fromdate");
			DATEOUT();
			{
				uint32_t i, j;
				j = GET_BE_U_4(bp);
				bp += sizeof(uint32_t);
				for (i = 0; i < j; i++) {
					DESTSERVEROUT();
					if (i != j - 1)
						ND_PRINT(",");
				}
				if (j == 0)
					ND_PRINT(" <none!>");
			}
			break;
		case 65538:	/* Dump version 2 */
			ND_PRINT(" fromtrans");
			UINTOUT();
			ND_PRINT(" fromdate");
			DATEOUT();
			ND_PRINT(" flags");
			UINTOUT();
			break;
		default:
			;
	}
	return;

trunc:
	ND_PRINT(" [|vol]");
}
