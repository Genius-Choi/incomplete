static int ext4_run_li_request(struct ext4_li_request *elr)
{
	struct ext4_group_desc *gdp = NULL;
	struct super_block *sb = elr->lr_super;
	ext4_group_t ngroups = EXT4_SB(sb)->s_groups_count;
	ext4_group_t group = elr->lr_next_group;
	unsigned int prefetch_ios = 0;
	int ret = 0;
	u64 start_time;

	if (elr->lr_mode == EXT4_LI_MODE_PREFETCH_BBITMAP) {
		elr->lr_next_group = ext4_mb_prefetch(sb, group,
				EXT4_SB(sb)->s_mb_prefetch, &prefetch_ios);
		if (prefetch_ios)
			ext4_mb_prefetch_fini(sb, elr->lr_next_group,
					      prefetch_ios);
		trace_ext4_prefetch_bitmaps(sb, group, elr->lr_next_group,
					    prefetch_ios);
		if (group >= elr->lr_next_group) {
			ret = 1;
			if (elr->lr_first_not_zeroed != ngroups &&
			    !sb_rdonly(sb) && test_opt(sb, INIT_INODE_TABLE)) {
				elr->lr_next_group = elr->lr_first_not_zeroed;
				elr->lr_mode = EXT4_LI_MODE_ITABLE;
				ret = 0;
			}
		}
		return ret;
	}

	for (; group < ngroups; group++) {
		gdp = ext4_get_group_desc(sb, group, NULL);
		if (!gdp) {
			ret = 1;
			break;
		}

		if (!(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))
			break;
	}

	if (group >= ngroups)
		ret = 1;

	if (!ret) {
		start_time = ktime_get_real_ns();
		ret = ext4_init_inode_table(sb, group,
					    elr->lr_timeout ? 0 : 1);
		trace_ext4_lazy_itable_init(sb, group);
		if (elr->lr_timeout == 0) {
			elr->lr_timeout = nsecs_to_jiffies((ktime_get_real_ns() - start_time) *
				EXT4_SB(elr->lr_super)->s_li_wait_mult);
		}
		elr->lr_next_sched = jiffies + elr->lr_timeout;
		elr->lr_next_group = group + 1;
	}
	return ret;
}
