static enum error_type handle_updates(struct mansession *s, const struct message *m, struct ast_config *cfg, const char *dfn)
{
	int x;
	char hdr[40];
	const char *action, *cat, *var, *value, *match, *line, *options;
	struct ast_variable *v;
	struct ast_str *str1 = ast_str_create(16), *str2 = ast_str_create(16);
	enum error_type result = 0;

	for (x = 0; x < 100000; x++) {	/* 100000 = the max number of allowed updates + 1 */
		unsigned int object = 0;
		char *dupoptions;
		int allowdups = 0;
		int istemplate = 0;
		int ignoreerror = 0;
		RAII_VAR(char *, inherit, NULL, ast_free);
		RAII_VAR(char *, catfilter, NULL, ast_free);
		char *token;
		int foundvar = 0;
		int foundcat = 0;
		struct ast_category *category = NULL;

		snprintf(hdr, sizeof(hdr), "Action-%06d", x);
		action = astman_get_header(m, hdr);
		if (ast_strlen_zero(action))		/* breaks the for loop if no action header */
			break;							/* this could cause problems if actions come in misnumbered */

		snprintf(hdr, sizeof(hdr), "Cat-%06d", x);
		cat = astman_get_header(m, hdr);
		if (ast_strlen_zero(cat)) {		/* every action needs a category */
			result =  UNSPECIFIED_CATEGORY;
			break;
		}

		snprintf(hdr, sizeof(hdr), "Var-%06d", x);
		var = astman_get_header(m, hdr);

		snprintf(hdr, sizeof(hdr), "Value-%06d", x);
		value = astman_get_header(m, hdr);

		if (!ast_strlen_zero(value) && *value == '>') {
			object = 1;
			value++;
		}

		snprintf(hdr, sizeof(hdr), "Match-%06d", x);
		match = astman_get_header(m, hdr);

		snprintf(hdr, sizeof(hdr), "Line-%06d", x);
		line = astman_get_header(m, hdr);

		snprintf(hdr, sizeof(hdr), "Options-%06d", x);
		options = astman_get_header(m, hdr);
		if (!ast_strlen_zero(options)) {
			char copy[strlen(options) + 1];
			strcpy(copy, options); /* safe */
			dupoptions = copy;
			while ((token = ast_strsep(&dupoptions, ',', AST_STRSEP_STRIP))) {
				if (!strcasecmp("allowdups", token)) {
					allowdups = 1;
					continue;
				}
				if (!strcasecmp("template", token)) {
					istemplate = 1;
					continue;
				}
				if (!strcasecmp("ignoreerror", token)) {
					ignoreerror = 1;
					continue;
				}
				if (ast_begins_with(token, "inherit")) {
					char *c = ast_strsep(&token, '=', AST_STRSEP_STRIP);
					c = ast_strsep(&token, '=', AST_STRSEP_STRIP);
					if (c) {
						inherit = ast_strdup(c);
					}
					continue;
				}
				if (ast_begins_with(token, "catfilter")) {
					char *c = ast_strsep(&token, '=', AST_STRSEP_STRIP);
					c = ast_strsep(&token, '=', AST_STRSEP_STRIP);
					if (c) {
						catfilter = ast_strdup(c);
					}
					continue;
				}
			}
		}

		if (!strcasecmp(action, "newcat")) {
			struct ast_category *template;
			char *tmpl_name = NULL;

			if (!allowdups) {
				if (ast_category_get(cfg, cat, "TEMPLATES=include")) {
					if (ignoreerror) {
						continue;
					} else {
						result = FAILURE_NEWCAT;	/* already exist */
						break;
					}
				}
			}

			if (istemplate) {
				category = ast_category_new_template(cat, dfn, -1);
			} else {
				category = ast_category_new(cat, dfn, -1);
			}

			if (!category) {
				result = FAILURE_ALLOCATION;
				break;
			}

			if (inherit) {
				while ((tmpl_name = ast_strsep(&inherit, ',', AST_STRSEP_STRIP))) {
					if ((template = ast_category_get(cfg, tmpl_name, "TEMPLATES=restrict"))) {
						if (ast_category_inherit(category, template)) {
							result = FAILURE_ALLOCATION;
							break;
						}
					} else {
						ast_category_destroy(category);
						category = NULL;
						result = FAILURE_TEMPLATE;	/* template not found */
						break;
					}
				}
			}

			if (category != NULL) {
				if (ast_strlen_zero(match)) {
					ast_category_append(cfg, category);
				} else {
					if (ast_category_insert(cfg, category, match)) {
						ast_category_destroy(category);
						result = FAILURE_NEWCAT;
						break;
					}
				}
			}
		} else if (!strcasecmp(action, "renamecat")) {
			if (ast_strlen_zero(value)) {
				result = UNSPECIFIED_ARGUMENT;
				break;
			}

			foundcat = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				ast_category_rename(category, value);
				foundcat = 1;
			}

			if (!foundcat) {
				result = UNKNOWN_CATEGORY;
				break;
			}
		} else if (!strcasecmp(action, "delcat")) {
			foundcat = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				category = ast_category_delete(cfg, category);
				foundcat = 1;
			}

			if (!foundcat && !ignoreerror) {
				result = UNKNOWN_CATEGORY;
				break;
			}
		} else if (!strcasecmp(action, "emptycat")) {
			foundcat = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				ast_category_empty(category);
				foundcat = 1;
			}

			if (!foundcat) {
				result = UNKNOWN_CATEGORY;
				break;
			}
		} else if (!strcasecmp(action, "update")) {
			if (ast_strlen_zero(var)) {
				result = UNSPECIFIED_ARGUMENT;
				break;
			}

			foundcat = 0;
			foundvar = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				if (!ast_variable_update(category, var, value, match, object)) {
					foundvar = 1;
				}
				foundcat = 1;
			}

			if (!foundcat) {
				result = UNKNOWN_CATEGORY;
				break;
			}

			if (!foundvar) {
				result = FAILURE_UPDATE;
				break;
			}
		} else if (!strcasecmp(action, "delete")) {
			if ((ast_strlen_zero(var) && ast_strlen_zero(line))) {
				result = UNSPECIFIED_ARGUMENT;
				break;
			}

			foundcat = 0;
			foundvar = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				if (!ast_variable_delete(category, var, match, line)) {
					foundvar = 1;
				}
				foundcat = 1;
			}

			if (!foundcat) {
				result = UNKNOWN_CATEGORY;
				break;
			}

			if (!foundvar && !ignoreerror) {
				result = FAILURE_UPDATE;
				break;
			}
		} else if (!strcasecmp(action, "append")) {
			if (ast_strlen_zero(var)) {
				result = UNSPECIFIED_ARGUMENT;
				break;
			}

			foundcat = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				if (!(v = ast_variable_new(var, value, dfn))) {
					result = FAILURE_ALLOCATION;
					break;
				}
				if (object || (match && !strcasecmp(match, "object"))) {
					v->object = 1;
				}
				ast_variable_append(category, v);
				foundcat = 1;
			}

			if (!foundcat) {
				result = UNKNOWN_CATEGORY;
				break;
			}
		} else if (!strcasecmp(action, "insert")) {
			if (ast_strlen_zero(var) || ast_strlen_zero(line)) {
				result = UNSPECIFIED_ARGUMENT;
				break;
			}

			foundcat = 0;
			while ((category = ast_category_browse_filtered(cfg, cat, category, catfilter))) {
				if (!(v = ast_variable_new(var, value, dfn))) {
					result = FAILURE_ALLOCATION;
					break;
				}
				ast_variable_insert(category, v, line);
				foundcat = 1;
			}

			if (!foundcat) {
				result = UNKNOWN_CATEGORY;
				break;
			}
		}
		else {
			ast_log(LOG_WARNING, "Action-%06d: %s not handled\n", x, action);
			result = UNKNOWN_ACTION;
			break;
		}
	}
	ast_free(str1);
	ast_free(str2);
	return result;
}
