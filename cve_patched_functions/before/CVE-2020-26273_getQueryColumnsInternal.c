Status getQueryColumnsInternal(const std::string& q,
                               TableColumns& columns,
                               const SQLiteDBInstanceRef& instance) {
  Status status = Status();
  TableColumns results;
  {
    auto lock = instance->attachLock();

    // Turn the query into a prepared statement
    sqlite3_stmt* stmt{nullptr};
    auto rc = sqlite3_prepare_v2(instance->db(),
                                 q.c_str(),
                                 static_cast<int>(q.length() + 1),
                                 &stmt,
                                 nullptr);
    if (rc != SQLITE_OK || stmt == nullptr) {
      auto s = Status::failure(sqlite3_errmsg(instance->db()));
      if (stmt != nullptr) {
        sqlite3_finalize(stmt);
      }
      return s;
    }

    // Get column count
    auto num_columns = sqlite3_column_count(stmt);
    results.reserve(num_columns);

    // Get column names and types
    bool unknown_type = false;
    for (int i = 0; i < num_columns; ++i) {
      auto col_name = sqlite3_column_name(stmt, i);
      auto col_type = sqlite3_column_decltype(stmt, i);

      if (col_name == nullptr) {
        status = Status(1, "Could not get column type");
        break;
      }

      if (col_type == nullptr) {
        // Types are only returned for table columns (not expressions).
        col_type = "UNKNOWN";
        unknown_type = true;
      }
      results.push_back(std::make_tuple(
          col_name, columnTypeName(col_type), ColumnOptions::DEFAULT));
    }

    // An unknown type means we have to parse the plan and SQLite opcodes.
    if (unknown_type) {
      QueryPlanner planner(q, instance);
      planner.applyTypes(results);
    }
    sqlite3_finalize(stmt);
  }

  if (status.ok()) {
    columns = std::move(results);
  }

  return status;
}
