static gnrc_pktsnip_t *_build_ack(gnrc_netif_t *netif,
                                  const uint8_t *dst, uint8_t dst_len,
                                  const sixlowpan_sfr_t *hdr,
                                  const uint8_t *bitmap)
{
    gnrc_pktsnip_t *ack_snip, *ack_netif;
    sixlowpan_sfr_ack_t *ack;

    ack_netif = gnrc_netif_hdr_build(NULL, 0, dst, dst_len);
    if (ack_netif == NULL) {
        DEBUG("6lo sfr: can't allocate netif header for ACK for (%s, %02x).\n",
              gnrc_netif_addr_to_str(dst, dst_len, addr_str), hdr->tag);
        return NULL;
    }
    gnrc_netif_hdr_set_netif(ack_netif->data, netif);

    ack_snip = gnrc_pktbuf_add(NULL, NULL, sizeof(sixlowpan_sfr_ack_t),
                               GNRC_NETTYPE_SIXLOWPAN);

    if (ack_snip == NULL) {
        DEBUG("6lo sfr: can't allocate ACK for (%s, %02x).\n",
              gnrc_netif_addr_to_str(dst, dst_len, addr_str), hdr->tag);
        gnrc_pktbuf_release(ack_netif);
        return NULL;
    }
    ack = ack_snip->data;
    /* https://tools.ietf.org/html/rfc8931#section-6:
     * The Datagram_Tag in the RFRAG_ACK is unique to the reassembling endpoint
     * and is enough information for an intermediate hop to locate the VRB that
     * contains the Datagram_Tag used by the previous hop and the Layer-2
     * information associated with it (interface and Link-Layer address)..
     * [...] The reassembling endpoint of a fragment with the 'E' (ECN) flag set
     * MUST echo that information at most once by setting the 'E' (ECN) flag in
     * the next RFRAG_ACK.
     *
     * => base except dispatch are the same as ack'd RFRAG.
     */
    ack->base = *hdr;
    sixlowpan_sfr_ack_set_disp(&ack->base);
    memcpy(ack->bitmap, bitmap, sizeof(ack->bitmap));
    ack_netif->next = ack_snip;
    return ack_netif;
}
