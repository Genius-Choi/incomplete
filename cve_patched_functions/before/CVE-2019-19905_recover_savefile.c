recover_savefile()
{
    int gfd, lfd, sfd;
    int lev, savelev, hpid, pltmpsiz;
    xchar levc;
    struct version_info version_data;
    int processed[256];
    char savename[SAVESIZE], errbuf[BUFSZ];
    struct savefile_info sfi;
    char tmpplbuf[PL_NSIZ];

    for (lev = 0; lev < 256; lev++)
        processed[lev] = 0;

    /* level 0 file contains:
     *  pid of creating process (ignored here)
     *  level number for current level of save file
     *  name of save file nethack would have created
     *  savefile info
     *  player name
     *  and game state
     */
    gfd = open_levelfile(0, errbuf);
    if (gfd < 0) {
        raw_printf("%s\n", errbuf);
        return FALSE;
    }
    if (read(gfd, (genericptr_t) &hpid, sizeof hpid) != sizeof hpid) {
        raw_printf("\n%s\n%s\n",
            "Checkpoint data incompletely written or subsequently clobbered.",
                   "Recovery impossible.");
        (void) nhclose(gfd);
        return FALSE;
    }
    if (read(gfd, (genericptr_t) &savelev, sizeof(savelev))
        != sizeof(savelev)) {
        raw_printf(
         "\nCheckpointing was not in effect for %s -- recovery impossible.\n",
                   lock);
        (void) nhclose(gfd);
        return FALSE;
    }
    if ((read(gfd, (genericptr_t) savename, sizeof savename)
         != sizeof savename)
        || (read(gfd, (genericptr_t) &version_data, sizeof version_data)
            != sizeof version_data)
        || (read(gfd, (genericptr_t) &sfi, sizeof sfi) != sizeof sfi)
        || (read(gfd, (genericptr_t) &pltmpsiz, sizeof pltmpsiz)
            != sizeof pltmpsiz) || (pltmpsiz > PL_NSIZ)
        || (read(gfd, (genericptr_t) &tmpplbuf, pltmpsiz) != pltmpsiz)) {
        raw_printf("\nError reading %s -- can't recover.\n", lock);
        (void) nhclose(gfd);
        return FALSE;
    }

    /* save file should contain:
     *  version info
     *  savefile info
     *  player name
     *  current level (including pets)
     *  (non-level-based) game state
     *  other levels
     */
    set_savefile_name(TRUE);
    sfd = create_savefile();
    if (sfd < 0) {
        raw_printf("\nCannot recover savefile %s.\n", SAVEF);
        (void) nhclose(gfd);
        return FALSE;
    }

    lfd = open_levelfile(savelev, errbuf);
    if (lfd < 0) {
        raw_printf("\n%s\n", errbuf);
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        delete_savefile();
        return FALSE;
    }

    if (write(sfd, (genericptr_t) &version_data, sizeof version_data)
        != sizeof version_data) {
        raw_printf("\nError writing %s; recovery failed.", SAVEF);
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        (void) nhclose(lfd);
        delete_savefile();
        return FALSE;
    }

    if (write(sfd, (genericptr_t) &sfi, sizeof sfi) != sizeof sfi) {
        raw_printf("\nError writing %s; recovery failed (savefile_info).\n",
                   SAVEF);
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        (void) nhclose(lfd);
        delete_savefile();
        return FALSE;
    }

    if (write(sfd, (genericptr_t) &pltmpsiz, sizeof pltmpsiz)
        != sizeof pltmpsiz) {
        raw_printf("Error writing %s; recovery failed (player name size).\n",
                   SAVEF);
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        (void) nhclose(lfd);
        delete_savefile();
        return FALSE;
    }

    if (write(sfd, (genericptr_t) &tmpplbuf, pltmpsiz) != pltmpsiz) {
        raw_printf("Error writing %s; recovery failed (player name).\n",
                   SAVEF);
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        (void) nhclose(lfd);
        delete_savefile();
        return FALSE;
    }

    if (!copy_bytes(lfd, sfd)) {
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        (void) nhclose(lfd);
        delete_savefile();
        return FALSE;
    }
    (void) nhclose(lfd);
    processed[savelev] = 1;

    if (!copy_bytes(gfd, sfd)) {
        (void) nhclose(gfd);
        (void) nhclose(sfd);
        delete_savefile();
        return FALSE;
    }
    (void) nhclose(gfd);
    processed[0] = 1;

    for (lev = 1; lev < 256; lev++) {
        /* level numbers are kept in xchars in save.c, so the
         * maximum level number (for the endlevel) must be < 256
         */
        if (lev != savelev) {
            lfd = open_levelfile(lev, (char *) 0);
            if (lfd >= 0) {
                /* any or all of these may not exist */
                levc = (xchar) lev;
                write(sfd, (genericptr_t) &levc, sizeof(levc));
                if (!copy_bytes(lfd, sfd)) {
                    (void) nhclose(lfd);
                    (void) nhclose(sfd);
                    delete_savefile();
                    return FALSE;
                }
                (void) nhclose(lfd);
                processed[lev] = 1;
            }
        }
    }
    (void) nhclose(sfd);

#ifdef HOLD_LOCKFILE_OPEN
    really_close();
#endif
    /*
     * We have a successful savefile!
     * Only now do we erase the level files.
     */
    for (lev = 0; lev < 256; lev++) {
        if (processed[lev]) {
            const char *fq_lock;

            set_levelfile_name(lock, lev);
            fq_lock = fqname(lock, LEVELPREFIX, 3);
            (void) unlink(fq_lock);
        }
    }
    return TRUE;
}
