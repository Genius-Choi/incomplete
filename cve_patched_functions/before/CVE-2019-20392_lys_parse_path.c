lys_parse_path(struct ly_ctx *ctx, const char *path, LYS_INFORMAT format)
{
    int fd;
    const struct lys_module *ret;
    const char *rev, *dot, *filename;
    size_t len;

    if (!ctx || !path) {
        LOGARG;
        return NULL;
    }

    fd = open(path, O_RDONLY);
    if (fd == -1) {
        LOGERR(ctx, LY_ESYS, "Opening file \"%s\" failed (%s).", path, strerror(errno));
        return NULL;
    }

    ret = lys_parse_fd(ctx, fd, format);
    close(fd);

    if (!ret) {
        /* error */
        return NULL;
    }

    /* check that name and revision match filename */
    filename = strrchr(path, '/');
    if (!filename) {
        filename = path;
    } else {
        filename++;
    }
    rev = strchr(filename, '@');
    dot = strrchr(filename, '.');

    /* name */
    len = strlen(ret->name);
    if (strncmp(filename, ret->name, len) ||
            ((rev && rev != &filename[len]) || (!rev && dot != &filename[len]))) {
        LOGWRN(ctx, "File name \"%s\" does not match module name \"%s\".", filename, ret->name);
    }
    if (rev) {
        len = dot - ++rev;
        if (!ret->rev_size || len != 10 || strncmp(ret->rev[0].date, rev, len)) {
            LOGWRN(ctx, "File name \"%s\" does not match module revision \"%s\".", filename,
                   ret->rev_size ? ret->rev[0].date : "none");
        }
    }

    if (!ret->filepath) {
        /* store URI */
        char rpath[PATH_MAX];
        if (realpath(path, rpath) != NULL) {
            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, rpath, 0);
        } else {
            ((struct lys_module *)ret)->filepath = lydict_insert(ctx, path, 0);
        }
    }

    return ret;
}
