static pj_status_t ipp_codec_encode( pjmedia_codec *codec, 
				     const struct pjmedia_frame *input,
				     unsigned output_buf_len, 
				     struct pjmedia_frame *output)
{
    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;
    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];
    unsigned samples_per_frame;
    unsigned nsamples;
    pj_size_t tx = 0;
    pj_int16_t *pcm_in   = (pj_int16_t*)input->buf;
    pj_uint8_t  *bits_out = (pj_uint8_t*) output->buf;
    pj_uint8_t pt;

    /* Invoke external VAD if codec has no internal VAD */
    if (codec_data->vad && codec_data->vad_enabled) {
	pj_bool_t is_silence;
	pj_int32_t silence_duration;

	silence_duration = pj_timestamp_diff32(&codec_data->last_tx, 
					       &input->timestamp);

	is_silence = pjmedia_silence_det_detect(codec_data->vad, 
					        (const pj_int16_t*) input->buf,
						(input->size >> 1),
						NULL);
	if (is_silence &&
	    (PJMEDIA_CODEC_MAX_SILENCE_PERIOD == -1 ||
	     silence_duration < (PJMEDIA_CODEC_MAX_SILENCE_PERIOD *
	 			 (int)ippc->clock_rate / 1000)))
	{
	    output->type = PJMEDIA_FRAME_TYPE_NONE;
	    output->buf = NULL;
	    output->size = 0;
	    output->timestamp = input->timestamp;
	    return PJ_SUCCESS;
	} else {
	    codec_data->last_tx = input->timestamp;
	}
    }

    nsamples = input->size >> 1;
    samples_per_frame = ippc->samples_per_frame;
    pt = ippc->pt;

    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, 
		     PJMEDIA_CODEC_EPCMFRMINLEN);

    /* Encode the frames */
    while (nsamples >= samples_per_frame) {
	USC_PCMStream in;
	USC_Bitstream out;

	in.bitrate = codec_data->info->params.modes.bitrate;
	in.nbytes = samples_per_frame << 1;
	in.pBuffer = (char*)pcm_in;
	in.pcmType.bitPerSample = codec_data->info->params.pcmType.bitPerSample;
	in.pcmType.nChannels = codec_data->info->params.pcmType.nChannels;
	in.pcmType.sample_frequency = codec_data->info->params.pcmType.sample_frequency;

	out.pBuffer = (char*)bits_out;

#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR
	/* For AMR: reserve two octets for AMR frame info */
	if (pt == PJMEDIA_RTP_PT_AMR || pt == PJMEDIA_RTP_PT_AMRWB) {
	    out.pBuffer += 2;
	}
#endif

#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1
	/* For G722.1: adjust the encoder input signal level */
	if (pt >= PJMEDIA_RTP_PT_G722_1_16 && 
	    pt <= PJMEDIA_RTP_PT_G7221_RSV2 &&
	    codec_data->g7221_pcm_shift)
	{
	    unsigned i;
	    for (i = 0; i < samples_per_frame; ++i)
		pcm_in[i] >>= codec_data->g7221_pcm_shift;
	}
#endif

	if (USC_NoError != ippc->fxns->Encode(codec_data->enc, &in, &out)) {
	    break;
	}

#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR
	/* For AMR: put info (frametype, degraded, last frame, mode) in the 
	 * first two octets for payload packing.
	 */
	if (pt == PJMEDIA_RTP_PT_AMR || pt == PJMEDIA_RTP_PT_AMRWB) {
	    pj_uint16_t *info = (pj_uint16_t*)bits_out;

	    /* Two octets for AMR frame info, 0=LSB:
	     * bit 0-3	: frame type
	     * bit 5	: STI flag
	     * bit 6	: last frame flag
	     * bit 7	: quality flag
	     * bit 8-11	: mode
	     */
	    out.nbytes += 2;
	    if (out.frametype == 0 || out.frametype == 4 || 
		(pt == PJMEDIA_RTP_PT_AMR && out.frametype == 5) ||
		(pt == PJMEDIA_RTP_PT_AMRWB && out.frametype == 6))
	    {
		/* Speech frame type */
		*info = (char)pjmedia_codec_amr_get_mode(out.bitrate);
		/* Quality */
		if (out.frametype == 5 || out.frametype == 6)
		    *info |= 0x80;
	    } else if (out.frametype == 1 || out.frametype == 2 || 
		       (pt == PJMEDIA_RTP_PT_AMR && out.frametype == 6) ||
		       (pt == PJMEDIA_RTP_PT_AMRWB && out.frametype == 7))
	    {
		/* SID frame type */
		*info = (pj_uint8_t)(pt == PJMEDIA_RTP_PT_AMRWB? 9 : 8);
		/* Quality */
		if (out.frametype == 6 || out.frametype == 7)
		    *info |= 0x80;
		/* STI */
		if (out.frametype != 1)
		    *info |= 0x20;
	    } else {
		/* Untransmited */
		*info = 15;
		out.nbytes = 2;
	    }

	    /* Mode */
	    *info |= (char)pjmedia_codec_amr_get_mode(out.bitrate) << 8;

	    /* Last frame flag */
	    if (nsamples == samples_per_frame)
		*info |= 0x40;
	}
#endif

	pcm_in += samples_per_frame;
	nsamples -= samples_per_frame;
	tx += out.nbytes;
	bits_out += out.nbytes;

#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729
	if (pt == PJMEDIA_RTP_PT_G729) {
	    if (out.frametype == 1) {
		/* SID */
		break;
	    } else if (out.frametype == 0) {
		/* Untransmitted */
		tx -= out.nbytes;
		break;
	    }
	}
#endif

    }

    if (ippc->pack != NULL) {
	ippc->pack(codec_data, output->buf, &tx, output_buf_len);
    }

    /* Check if we don't need to transmit the frame (DTX) */
    if (tx == 0) {
	output->buf = NULL;
	output->size = 0;
	output->timestamp.u64 = input->timestamp.u64;
	output->type = PJMEDIA_FRAME_TYPE_NONE;
	return PJ_SUCCESS;
    }

    output->size = tx;
    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    output->timestamp = input->timestamp;

    return PJ_SUCCESS;
}
