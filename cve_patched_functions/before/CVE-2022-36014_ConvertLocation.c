Location GraphDefImporter::ConvertLocation(StringRef node_name,
                                           StringRef func_name) {
  // Concatenate the node name with the function name to match how the key is
  // formed in Python.
  std::string debug_info_key = (node_name + "@" + func_name).str();
  std::string name_loc = func_name.empty() ? node_name.str() : debug_info_key;
  auto name_loc_id = b_.getStringAttr(name_loc);

  SmallVector<Location> locs;
  const auto &traces = debug_info_.traces();
  // Try to find a stack trace to convert to locations.
  auto it = traces.find(debug_info_key);
  if (it != traces.end()) {
    const auto &trace = it->second;
    locs.reserve(trace.file_line_cols_size());
    for (const auto &loc : trace.file_line_cols()) {
      auto file_name = b_.getStringAttr(debug_info_.files(loc.file_index()));
      locs.push_back(FileLineColLoc::get(file_name, loc.line(), loc.col()));
    }
  }

  if (locs.empty()) return NameLoc::get(name_loc_id);

  // Use the first location to generate a name location.
  Location node_name_loc = NameLoc::get(name_loc_id, locs.front());
  // Generate a stack trace using the remaining locations.
  ArrayRef<Location> callsite_locs = llvm::makeArrayRef(locs).drop_front();
  return callsite_locs.empty() ? node_name_loc
                               : CallSiteLoc::get(node_name_loc, callsite_locs);
}
