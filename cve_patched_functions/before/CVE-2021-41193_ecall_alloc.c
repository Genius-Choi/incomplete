int ecall_alloc(struct ecall **ecallp, struct list *ecalls,
		enum icall_conv_type conv_type,
		const struct ecall_conf *conf,
		struct msystem *msys,
		const char *convid,
		const char *userid_self,
		const char *clientid)
{
	struct ecall *ecall;
	bool muted;
	int err = 0;

	if (!msys || !str_isset(convid))
		return EINVAL;

	ecall = mem_zalloc(sizeof(*ecall), ecall_destructor);
	if (!ecall)
		return ENOMEM;

	ecall->magic = ECALL_MAGIC;
	ecall->conf = conf ? *conf : default_conf;
	ecall->conv_type = conv_type;
	switch(conv_type) {
	case ICALL_CONV_TYPE_CONFERENCE:
	case ICALL_CONV_TYPE_GROUP:
		ecall->max_retries = 2;
		break;
	case ICALL_CONV_TYPE_ONEONONE:
	default:
		ecall->max_retries = 0;
		break;
	}
	ecall->num_retries = 0;

	/* Add some properties */
	err = econn_props_alloc(&ecall->props_local, NULL);
	if (err)
		goto out;

	err = econn_props_add(ecall->props_local, "videosend", "false");
	if (err)
		goto out;

	err = econn_props_add(ecall->props_local, "screensend", "false");
	if (err)
		goto out;

	err = econn_props_add(ecall->props_local, "audiocbr", "false");
	if (err)
		goto out;

	muted = msystem_get_muted();
	err = econn_props_add(ecall->props_local, "muted", muted ? "true" : "false");
	if (err)
		goto out;

	err |= str_dup(&ecall->convid, convid);
	err |= str_dup(&ecall->userid_self, userid_self);
	err |= str_dup(&ecall->clientid_self, clientid);
	if (err)
		goto out;

	ecall->msys = mem_ref(msys);

	ecall->transp.sendh = send_handler;
	ecall->transp.arg = ecall;

	icall_set_functions(&ecall->icall,
			    _icall_add_turnserver,
			    NULL, // _icall_add_sft
			    _icall_start,
			    _icall_answer,
			    _icall_end,
			    _icall_reject,
			    _icall_media_start,
			    _icall_media_stop,
			    _icall_set_media_laddr,
			    _icall_set_video_send_state,
			    _icall_msg_recv,
			    NULL, // _icall_sft_msg_recv
			    _icall_get_members,
			    _icall_set_quality_interval,
			    _icall_dce_send,
			    _icall_set_clients,
			    _icall_update_mute_state,
			    _icall_debug,
			    _icall_stats);

	list_append(ecalls, &ecall->le, ecall);
	list_append(&g_ecalls, &ecall->ecall_le, ecall);

	ecall->ts_start = tmr_jiffies();

	info("ecall(%p): allocated\n", ecall);
 out:
	if (err)
		mem_deref(ecall);
	else if (ecallp)
		*ecallp = ecall;

	return err;
}
