static void bgp_dynamic_capability_llgr(uint8_t *pnt, int action,
					struct capability_header *hdr,
					struct peer *peer)
{
	uint8_t *data = pnt + 3;
	uint8_t *end = data + hdr->length;
	size_t len = end - data;
	afi_t afi;
	safi_t safi;

	if (action == CAPABILITY_ACTION_SET) {
		if (len < BGP_CAP_LLGR_MIN_PACKET_LEN) {
			zlog_err("%pBP: Received invalid Long-Lived Graceful-Restart capability length %zu",
				 peer, len);
			return;
		}

		SET_FLAG(peer->cap, PEER_CAP_LLGR_RCV);

		while (data + BGP_CAP_LLGR_MIN_PACKET_LEN <= end) {
			afi_t afi;
			safi_t safi;
			iana_afi_t pkt_afi;
			iana_safi_t pkt_safi;
			struct graceful_restart_af graf;

			memcpy(&graf, data, sizeof(graf));
			pkt_afi = ntohs(graf.afi);
			pkt_safi = safi_int2iana(graf.safi);

			/* Stale time is after AFI/SAFI/flags.
			 * It's encoded as 24 bits (= 3 bytes), so we need to
			 * put it into 32 bits.
			 */
			uint32_t stale_time;
			uint8_t *stale_time_ptr = data + 4;

			stale_time = stale_time_ptr[0] << 16;
			stale_time |= stale_time_ptr[1] << 8;
			stale_time |= stale_time_ptr[2];

			if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,
						      &safi)) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) not supported. Ignore the Long-lived Graceful Restart capability for this AFI/SAFI",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
			} else if (!peer->afc[afi][safi] ||
				   !CHECK_FLAG(peer->af_cap[afi][safi],
					       PEER_CAP_RESTART_AF_RCV)) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) not enabled. Ignore the Long-lived Graceful Restart capability",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
			} else {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) Long-lived Graceful Restart capability stale time %u sec",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi),
						   stale_time);

				peer->llgr[afi][safi].flags = graf.flag;
				peer->llgr[afi][safi].stale_time =
					MIN(stale_time,
					    peer->bgp->llgr_stale_time);
				SET_FLAG(peer->af_cap[afi][safi],
					 PEER_CAP_LLGR_AF_RCV);
			}

			data += BGP_CAP_LLGR_MIN_PACKET_LEN;
		}
	} else {
		FOREACH_AFI_SAFI (afi, safi) {
			UNSET_FLAG(peer->af_cap[afi][safi],
				   PEER_CAP_LLGR_AF_RCV);

			peer->llgr[afi][safi].flags = 0;
			peer->llgr[afi][safi].stale_time =
				BGP_DEFAULT_LLGR_STALE_TIME;
		}

		UNSET_FLAG(peer->cap, PEER_CAP_LLGR_RCV);
	}
}
