mg_start(const struct mg_callbacks *callbacks,
         void *user_data,
         const char **options)
{
	struct mg_context *ctx;
	const char *name, *value, *default_value;
	int idx, ok, workerthreadcount;
	unsigned int i;
	int itmp;
	void (*exit_callback)(const struct mg_context *ctx) = 0;

	struct mg_workerTLS tls;

#if defined(_WIN32)
	WSADATA data;
	WSAStartup(MAKEWORD(2, 2), &data);
#endif /* _WIN32  */

	/* Allocate context and initialize reasonable general case defaults. */
	if ((ctx = (struct mg_context *)mg_calloc(1, sizeof(*ctx))) == NULL) {
		return NULL;
	}

	/* Random number generator will initialize at the first call */
	ctx->dd.auth_nonce_mask =
	    (uint64_t)get_random() ^ (uint64_t)(ptrdiff_t)(options);

	if (mg_init_library_called == 0) {
		/* Legacy INIT, if mg_start is called without mg_init_library.
		 * Note: This may cause a memory leak */
		const char *ports_option =
		    config_options[LISTENING_PORTS].default_value;

		if (options) {
			const char **run_options = options;
			const char *optname = config_options[LISTENING_PORTS].name;

			/* Try to find the "listening_ports" option */
			while (*run_options) {
				if (!strcmp(*run_options, optname)) {
					ports_option = run_options[1];
				}
				run_options += 2;
			}
		}

		if (is_ssl_port_used(ports_option)) {
			/* Initialize with SSL support */
			mg_init_library(MG_FEATURES_TLS);
		} else {
			/* Initialize without SSL support */
			mg_init_library(MG_FEATURES_DEFAULT);
		}
	}

	tls.is_master = -1;
	tls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);
#if defined(_WIN32)
	tls.pthread_cond_helper_mutex = NULL;
#endif
	pthread_setspecific(sTlsKey, &tls);

	ok = (0 == pthread_mutex_init(&ctx->thread_mutex, &pthread_mutex_attr));
#if !defined(ALTERNATIVE_QUEUE)
	ok &= (0 == pthread_cond_init(&ctx->sq_empty, NULL));
	ok &= (0 == pthread_cond_init(&ctx->sq_full, NULL));
#endif
	ok &= (0 == pthread_mutex_init(&ctx->nonce_mutex, &pthread_mutex_attr));
	if (!ok) {
		/* Fatal error - abort start. However, this situation should never
		 * occur in practice. */
		mg_cry_internal(fc(ctx),
		                "%s",
		                "Cannot initialize thread synchronization objects");
		mg_free(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}

	if (callbacks) {
		ctx->callbacks = *callbacks;
		exit_callback = callbacks->exit_context;
		ctx->callbacks.exit_context = 0;
	}
	ctx->user_data = user_data;
	ctx->dd.handlers = NULL;
	ctx->dd.next = NULL;

#if defined(USE_LUA) && defined(USE_WEBSOCKET)
	ctx->dd.shared_lua_websockets = NULL;
#endif

	/* Store options */
	while (options && (name = *options++) != NULL) {
		if ((idx = get_option_index(name)) == -1) {
			mg_cry_internal(fc(ctx), "Invalid option: %s", name);
			free_context(ctx);
			pthread_setspecific(sTlsKey, NULL);
			return NULL;
		} else if ((value = *options++) == NULL) {
			mg_cry_internal(fc(ctx), "%s: option value cannot be NULL", name);
			free_context(ctx);
			pthread_setspecific(sTlsKey, NULL);
			return NULL;
		}
		if (ctx->dd.config[idx] != NULL) {
			mg_cry_internal(fc(ctx), "warning: %s: duplicate option", name);
			mg_free(ctx->dd.config[idx]);
		}
		ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);
		DEBUG_TRACE("[%s] -> [%s]", name, value);
	}

	/* Set default value if needed */
	for (i = 0; config_options[i].name != NULL; i++) {
		default_value = config_options[i].default_value;
		if ((ctx->dd.config[i] == NULL) && (default_value != NULL)) {
			ctx->dd.config[i] = mg_strdup_ctx(default_value, ctx);
		}
	}

	/* Request size option */
	itmp = atoi(ctx->dd.config[MAX_REQUEST_SIZE]);
	if (itmp < 1024) {
		mg_cry_internal(fc(ctx), "%s", "max_request_size too small");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}
	ctx->max_request_size = (unsigned)itmp;

	/* Worker thread count option */
	workerthreadcount = atoi(ctx->dd.config[NUM_THREADS]);

	if (workerthreadcount > MAX_WORKER_THREADS) {
		mg_cry_internal(fc(ctx), "%s", "Too many worker threads");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}

	if (workerthreadcount <= 0) {
		mg_cry_internal(fc(ctx), "%s", "Invalid number of worker threads");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}

/* Document root */
#if defined(NO_FILES)
	if (ctx->dd.config[DOCUMENT_ROOT] != NULL) {
		mg_cry_internal(fc(ctx), "%s", "Document root must not be set");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}
#endif

	get_system_name(&ctx->systemName);

#if defined(USE_LUA)
	/* If a Lua background script has been configured, start it. */
	if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {
		char ebuf[256];
		struct vec opt_vec;
		struct vec eq_vec;
		const char *sparams;
		lua_State *state = mg_prepare_lua_context_script(
		    ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));
		if (!state) {
			mg_cry_internal(fc(ctx), "lua_background_script error: %s", ebuf);
			free_context(ctx);
			pthread_setspecific(sTlsKey, NULL);
			return NULL;
		}
		ctx->lua_background_state = (void *)state;

		lua_newtable(state);
		reg_boolean(state, "shutdown", 0);

		sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];

		while ((sparams = next_option(sparams, &opt_vec, &eq_vec)) != NULL) {
			reg_llstring(
			    state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);
			if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0)
				break;
		}
		lua_setglobal(state, LUABACKGROUNDPARAMS);

	} else {
		ctx->lua_background_state = 0;
	}
#endif

	/* NOTE(lsm): order is important here. SSL certificates must
	 * be initialized before listening ports. UID must be set last. */
	if (!set_gpass_option(ctx, NULL) ||
#if !defined(NO_SSL)
	    !init_ssl_ctx(ctx, NULL) ||
#endif
	    !set_ports_option(ctx) ||
#if !defined(_WIN32)
	    !set_uid_option(ctx) ||
#endif
	    !set_acl_option(ctx)) {
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}

	ctx->cfg_worker_threads = ((unsigned int)(workerthreadcount));
	ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,
	                                                   sizeof(pthread_t),
	                                                   ctx);

	if (ctx->worker_threadids == NULL) {
		mg_cry_internal(fc(ctx),
		                "%s",
		                "Not enough memory for worker thread ID array");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}
	ctx->worker_connections =
	    (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,
	                                          sizeof(struct mg_connection),
	                                          ctx);
	if (ctx->worker_connections == NULL) {
		mg_cry_internal(fc(ctx),
		                "%s",
		                "Not enough memory for worker thread connection array");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}


#if defined(ALTERNATIVE_QUEUE)
	ctx->client_wait_events =
	    (void **)mg_calloc_ctx(sizeof(ctx->client_wait_events[0]),
	                           ctx->cfg_worker_threads,
	                           ctx);
	if (ctx->client_wait_events == NULL) {
		mg_cry_internal(fc(ctx),
		                "%s",
		                "Not enough memory for worker event array");
		mg_free(ctx->worker_threadids);
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}

	ctx->client_socks =
	    (struct socket *)mg_calloc_ctx(sizeof(ctx->client_socks[0]),
	                                   ctx->cfg_worker_threads,
	                                   ctx);
	if (ctx->client_socks == NULL) {
		mg_cry_internal(fc(ctx),
		                "%s",
		                "Not enough memory for worker socket array");
		mg_free(ctx->client_wait_events);
		mg_free(ctx->worker_threadids);
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}

	for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {
		ctx->client_wait_events[i] = event_create();
		if (ctx->client_wait_events[i] == 0) {
			mg_cry_internal(fc(ctx), "Error creating worker event %i", i);
			while (i > 0) {
				i--;
				event_destroy(ctx->client_wait_events[i]);
			}
			mg_free(ctx->client_socks);
			mg_free(ctx->client_wait_events);
			mg_free(ctx->worker_threadids);
			free_context(ctx);
			pthread_setspecific(sTlsKey, NULL);
			return NULL;
		}
	}
#endif


#if defined(USE_TIMERS)
	if (timers_init(ctx) != 0) {
		mg_cry_internal(fc(ctx), "%s", "Error creating timers");
		free_context(ctx);
		pthread_setspecific(sTlsKey, NULL);
		return NULL;
	}
#endif

	/* Context has been created - init user libraries */
	if (ctx->callbacks.init_context) {
		ctx->callbacks.init_context(ctx);
	}
	ctx->callbacks.exit_context = exit_callback;
	ctx->context_type = CONTEXT_SERVER; /* server context */

	/* Start master (listening) thread */
	mg_start_thread_with_id(master_thread, ctx, &ctx->masterthreadid);

	/* Start worker threads */
	for (i = 0; i < ctx->cfg_worker_threads; i++) {
		struct worker_thread_args *wta = (struct worker_thread_args *)
		    mg_malloc_ctx(sizeof(struct worker_thread_args), ctx);
		if (wta) {
			wta->ctx = ctx;
			wta->index = (int)i;
		}

		if ((wta == NULL)
		    || (mg_start_thread_with_id(worker_thread,
		                                wta,
		                                &ctx->worker_threadids[i]) != 0)) {

			/* thread was not created */
			if (wta != NULL) {
				mg_free(wta);
			}

			if (i > 0) {
				mg_cry_internal(fc(ctx),
				                "Cannot start worker thread %i: error %ld",
				                i + 1,
				                (long)ERRNO);
			} else {
				mg_cry_internal(fc(ctx),
				                "Cannot create threads: error %ld",
				                (long)ERRNO);
				free_context(ctx);
				pthread_setspecific(sTlsKey, NULL);
				return NULL;
			}
			break;
		}
	}

	pthread_setspecific(sTlsKey, NULL);
	return ctx;
}
