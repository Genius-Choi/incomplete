static void on_rx_rtcp(pj_ioqueue_key_t *key, 
                       pj_ioqueue_op_key_t *op_key, 
                       pj_ssize_t bytes_read)
{
    struct transport_udp *udp;
    pj_status_t status = PJ_SUCCESS;
    pj_bool_t transport_restarted = PJ_FALSE;
    unsigned num_err = 0;
    pj_status_t last_err = PJ_SUCCESS;

    PJ_UNUSED_ARG(op_key);

    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);

    if (-bytes_read == PJ_ECANCELLED) {
        TRACE_((udp->base.name, "on_rx_rtcp(): got PJ_ECANCELLED"));
        return;
    }

    if (-bytes_read == PJ_ESOCKETSTOP) {
        TRACE_((udp->base.name, "on_rx_rtcp(): got PJ_ESOCKETSTOP"));

        /* Try to recover by restarting the transport. */
        status = transport_restart(PJ_FALSE, udp);
        if (status != PJ_SUCCESS) {
            bytes_read = -PJ_ESOCKETSTOP;
            call_rtcp_cb(udp, bytes_read);
        }
        return;
    }

    do {
        call_rtcp_cb(udp, bytes_read);

#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \
    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)
        /* Check if RTCP source address is the same as the configured
         * remote address, and switch the address when they are
         * different.
         */
        if (bytes_read>0 &&
            (udp->options & PJMEDIA_UDP_NO_SRC_ADDR_CHECKING)==0)
        {
            if (pj_sockaddr_cmp(&udp->rem_rtcp_addr, &udp->rtcp_src_addr) == 0) {
                /* Still receiving from rem_rtcp_addr, don't switch */
                udp->rtcp_src_cnt = 0;
            } else {
                ++udp->rtcp_src_cnt;

                if (udp->rtcp_src_cnt >= PJMEDIA_RTCP_NAT_PROBATION_CNT ) {
                    char addr_text[PJ_INET6_ADDRSTRLEN+10];

                    udp->rtcp_src_cnt = 0;
                    pj_memcpy(&udp->rem_rtcp_addr, &udp->rtcp_src_addr,
                              sizeof(pj_sockaddr));

                    PJ_LOG(4,(udp->base.name,
                              "Remote RTCP address switched to %s",
                              pj_sockaddr_print(&udp->rtcp_src_addr, addr_text,
                                                sizeof(addr_text), 3)));
                }
            }
        }
#endif

        bytes_read = sizeof(udp->rtcp_pkt);
        udp->rtcp_addr_len = sizeof(udp->rtcp_src_addr);
        status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,
                                     udp->rtcp_pkt, &bytes_read, 0,
                                     &udp->rtcp_src_addr, 
                                     &udp->rtcp_addr_len);

        if (status != PJ_EPENDING && status != PJ_SUCCESS) {
            if (transport_restarted && last_err == status) {
                /* Still the same error after restart */
                bytes_read = -PJ_ESOCKETSTOP;
                call_rtcp_cb(udp, bytes_read);
                break;
            } else if (PJMEDIA_IGNORE_RECV_ERR_CNT) {
                if (last_err == status) {
                    ++num_err;
                } else {
                    num_err = 1;
                    last_err = status;
                }

                if (status == PJ_ESOCKETSTOP ||
                    num_err > PJMEDIA_IGNORE_RECV_ERR_CNT)
                {
                    status = transport_restart(PJ_FALSE, udp);              
                    if (status != PJ_SUCCESS) {
                        bytes_read = -PJ_ESOCKETSTOP;
                        call_rtcp_cb(udp, bytes_read);
                        break;
                    }
                    transport_restarted = PJ_TRUE;
                    num_err = 0;
                }
            }
            bytes_read = -status;
            TRACE_((udp->base.name, "on_rx_rtcp(): recvfrom error=%d", status));
        }       
    } while (status != PJ_EPENDING && status != PJ_ECANCELLED &&
             udp->started);
}
