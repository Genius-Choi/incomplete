WebContents::~WebContents() {
  MarkDestroyed();
  // The destroy() is called.
  if (inspectable_web_contents_) {
#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)
    if (type_ == Type::kBackgroundPage) {
      // Background pages are owned by extensions::ExtensionHost
      inspectable_web_contents_->ReleaseWebContents();
    }
#endif

    inspectable_web_contents_->GetView()->SetDelegate(nullptr);

    if (web_contents()) {
      RenderViewDeleted(web_contents()->GetRenderViewHost());
    }

    if (type_ == Type::kBrowserWindow && owner_window()) {
      // For BrowserWindow we should close the window and clean up everything
      // before WebContents is destroyed.
      for (ExtendedWebContentsObserver& observer : observers_)
        observer.OnCloseContents();
      // BrowserWindow destroys WebContents asynchronously, manually emit the
      // destroyed event here.
      WebContentsDestroyed();
    } else if (Browser::Get()->is_shutting_down()) {
      // Destroy WebContents directly when app is shutting down.
      DestroyWebContents(false /* async */);
    } else {
      // Destroy WebContents asynchronously unless app is shutting down,
      // because destroy() might be called inside WebContents's event handler.
      bool is_browser_view = type_ == Type::kBrowserView;
      DestroyWebContents(!(IsGuest() || is_browser_view) /* async */);
      // The WebContentsDestroyed will not be called automatically because we
      // destroy the webContents in the next tick. So we have to manually
      // call it here to make sure "destroyed" event is emitted.
      WebContentsDestroyed();
    }
  }
}
