pf_free_state(struct pf_state *st)
{
	struct pf_rule_item *ri;

	PF_ASSERT_LOCKED();

#if NPFSYNC > 0
	if (pfsync_state_in_use(st))
		return;
#endif	/* NPFSYNC > 0 */
	KASSERT(st->timeout == PFTM_UNLINKED);
	if (--st->rule.ptr->states_cur == 0 &&
	    st->rule.ptr->src_nodes == 0)
		pf_rm_rule(NULL, st->rule.ptr);
	if (st->anchor.ptr != NULL)
		if (--st->anchor.ptr->states_cur == 0)
			pf_rm_rule(NULL, st->anchor.ptr);
	while ((ri = SLIST_FIRST(&st->match_rules))) {
		SLIST_REMOVE_HEAD(&st->match_rules, entry);
		if (--ri->r->states_cur == 0 &&
		    ri->r->src_nodes == 0)
			pf_rm_rule(NULL, ri->r);
		pool_put(&pf_rule_item_pl, ri);
	}
	pf_normalize_tcp_cleanup(st);
	pfi_kif_unref(st->kif, PFI_KIF_REF_STATE);
	pf_state_list_remove(&pf_state_list, st);
	if (st->tag)
		pf_tag_unref(st->tag);
	pf_state_unref(st);
	pf_status.fcounters[FCNT_STATE_REMOVALS]++;
	pf_status.states--;
}
