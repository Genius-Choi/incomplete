_netplan_netdef_write_ovs(const NetplanState* np_state, const NetplanNetDefinition* def, const char* rootdir, gboolean* has_been_written, GError** error)
{
    g_autoptr(GString) cmds = g_string_new(NULL);
    gchar* dependency = NULL;
    const char* type = netplan_type_to_table_name(def->type);
    g_autofree char* base_config_path = NULL;
    char* value = NULL;
    const NetplanOVSSettings* settings = &np_state->ovs_settings;

    SET_OPT_OUT_PTR(has_been_written, FALSE);

    /* TODO: maybe dynamically query the ovs-vsctl tool path? */

    /* For OVS specific settings, we expect the backend to be set to OVS.
     * The OVS backend is implicitly set, if an interface contains an empty "openvswitch: {}"
     * key, or an "openvswitch:" key, containing more than "external-ids" and/or "other-config". */
    if (def->backend == NETPLAN_BACKEND_OVS) {
        switch (def->type) {
            case NETPLAN_DEF_TYPE_BOND:
                dependency = write_ovs_bond_interfaces(np_state, def, cmds, error);
                if (!dependency)
                    return FALSE;
                write_ovs_tag_netplan(def->id, type, cmds);
                /* Set LACP mode, default to "off" */
                value = def->ovs_settings.lacp? def->ovs_settings.lacp : "off";
                append_systemd_cmd(cmds, OPENVSWITCH_OVS_VSCTL " set Port %s lacp=%s", def->id, value);
                write_ovs_tag_setting(def->id, type, "lacp", NULL, value, cmds);
                if (def->bond_params.mode && !write_ovs_bond_mode(def, cmds, error))
                    return FALSE;
                break;

            case NETPLAN_DEF_TYPE_BRIDGE:
                write_ovs_bridge_interfaces(np_state, def, cmds);
                write_ovs_tag_netplan(def->id, type, cmds);
                /* Set fail-mode, default to "standalone" */
                value = def->ovs_settings.fail_mode? def->ovs_settings.fail_mode : "standalone";
                append_systemd_cmd(cmds, OPENVSWITCH_OVS_VSCTL " set-fail-mode %s %s", def->id, value);
                write_ovs_tag_setting(def->id, type, "global", "set-fail-mode", value, cmds);
                /* Enable/disable mcast-snooping */ 
                value = def->ovs_settings.mcast_snooping? "true" : "false";
                append_systemd_cmd(cmds, OPENVSWITCH_OVS_VSCTL " set Bridge %s mcast_snooping_enable=%s", def->id, value);
                write_ovs_tag_setting(def->id, type, "mcast_snooping_enable", NULL, value, cmds);
                /* Enable/disable rstp */
                value = def->ovs_settings.rstp? "true" : "false";
                append_systemd_cmd(cmds, OPENVSWITCH_OVS_VSCTL " set Bridge %s rstp_enable=%s", def->id, value);
                write_ovs_tag_setting(def->id, type, "rstp_enable", NULL, value, cmds);
                /* Set protocols */
                if (def->ovs_settings.protocols && def->ovs_settings.protocols->len > 0)
                    write_ovs_protocols(&(def->ovs_settings), def->id, cmds);
                else if (settings->protocols && settings->protocols->len > 0)
                    write_ovs_protocols(settings, def->id, cmds);
                /* Set controller target addresses */
                if (def->ovs_settings.controller.addresses && def->ovs_settings.controller.addresses->len > 0) {
                    if (!write_ovs_bridge_controller_targets(settings, &(def->ovs_settings.controller), def->id, cmds, error))
                        return FALSE;

                    /* Set controller connection mode, only applicable if at least one controller target address was set */
                    if (def->ovs_settings.controller.connection_mode) {
                        value = def->ovs_settings.controller.connection_mode;
                        append_systemd_cmd(cmds, OPENVSWITCH_OVS_VSCTL " set Controller %s connection-mode=%s", def->id, value);
                        write_ovs_tag_setting(def->id, "Controller", "connection-mode", NULL, value, cmds);
                    }
                }
                break;

            case NETPLAN_DEF_TYPE_PORT:
                g_assert(def->peer);
                dependency = def->bridge?: def->bond;
                if (!dependency) {
                    g_set_error(error, NETPLAN_BACKEND_ERROR, NETPLAN_ERROR_VALIDATION, "%s: OpenVSwitch patch port needs to be assigned to a bridge/bond\n", def->id);
                    return FALSE;
                }
                /* There is no OVS Port which we could tag netplan=true if this
                 * patch port is assigned as an OVS bond interface. Tag the
                 * Interface instead, to clean it up from a bond. */
                if (def->bond)
                    write_ovs_tag_netplan(def->id, "Interface", cmds);
                else
                    write_ovs_tag_netplan(def->id, type, cmds);
                break;

            case NETPLAN_DEF_TYPE_VLAN:
                g_assert(def->vlan_link);
                dependency = def->vlan_link->id;
                /* Create a fake VLAN bridge */
                append_systemd_cmd(cmds, OPENVSWITCH_OVS_VSCTL " --may-exist add-br %s %s %i", def->id, def->vlan_link->id, def->vlan_id)
                write_ovs_tag_netplan(def->id, type, cmds);
                break;

            default:
                g_set_error(error, NETPLAN_BACKEND_ERROR, NETPLAN_ERROR_VALIDATION, "%s: This device type is not supported with the OpenVSwitch backend\n", def->id);
                return FALSE;
        }

        /* Try writing out a base config */
        /* TODO: make use of netplan_netdef_get_output_filename() */
        base_config_path = g_strjoin(NULL, "run/systemd/network/10-netplan-", def->id, NULL);
        if (!_netplan_netdef_write_network_file(np_state, def, rootdir, base_config_path, has_been_written, error))
            return FALSE;
    } else {
        /* Other interfaces must be part of an OVS bridge or bond to carry additional data */
        if (   (def->ovs_settings.external_ids && g_hash_table_size(def->ovs_settings.external_ids) > 0)
            || (def->ovs_settings.other_config && g_hash_table_size(def->ovs_settings.other_config) > 0)) {
            dependency = def->bridge?: def->bond;
            if (!dependency) {
                g_set_error(error, NETPLAN_BACKEND_ERROR, NETPLAN_ERROR_VALIDATION, "%s: Interface needs to be assigned to an OVS bridge/bond to carry external-ids/other-config\n", def->id);
                return FALSE;
            }
        } else {
            g_debug("Open vSwitch: definition %s is not for us (backend %i)", def->id, def->backend);
            SET_OPT_OUT_PTR(has_been_written, FALSE);
            return TRUE;
        }
    }

    /* Set "external-ids" and "other-config" after NETPLAN_BACKEND_OVS interfaces, as bonds,
     * bridges, etc. might just be created before.*/

    /* Common OVS settings can be specified even for non-OVS interfaces */
    if (def->ovs_settings.external_ids && g_hash_table_size(def->ovs_settings.external_ids) > 0) {
        write_ovs_additional_data(def->ovs_settings.external_ids, type,
                                  def->id, cmds, "external-ids");
    }

    if (def->ovs_settings.other_config && g_hash_table_size(def->ovs_settings.other_config) > 0) {
        write_ovs_additional_data(def->ovs_settings.other_config, type,
                                  def->id, cmds, "other-config");
    }

    /* If we need to configure anything for this netdef, write the required systemd unit */
    gboolean ret = TRUE;
    if (cmds->len > 0)
        ret = write_ovs_systemd_unit(def->id, cmds, rootdir, netplan_type_is_physical(def->type), FALSE, dependency, error);
    SET_OPT_OUT_PTR(has_been_written, TRUE);
    return ret;
}
